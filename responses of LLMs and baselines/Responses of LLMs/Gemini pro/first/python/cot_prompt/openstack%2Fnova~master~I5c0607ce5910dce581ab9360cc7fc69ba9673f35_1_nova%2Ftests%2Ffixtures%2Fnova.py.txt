```python\n1 # Copyright 2010 United States Government as represented by the\n2 # Administrator of the National Aeronautics and Space Administration.\n3 # All Rights Reserved.\n4 #\n5 #    Licensed under the Apache License, Version 2.0 (the "License"); you may\n6 #    not use this file except in compliance with the License. You may obtain\n7 #    a copy of the License at\n8 #\n9 #         http://www.apache.org/licenses/LICENSE-2.0\n10 #\n11 #    Unless required by applicable law or agreed to in writing, software\n12 #    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n13 #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n14 #    License for the specific language governing permissions and limitations\n15 #    under the License.\n16 \n17 """Fixtures for Nova tests."""\n18 \n19 import collections\n20 import contextlib\n21 from contextlib import contextmanager\n22 import functools\n23 import logging as std_logging\n24 import os\n25 import warnings\n26 \n27 import eventlet\n28 import fixtures\n29 import futurist\n30 import mock\n31 from openstack import service_description\n32 from oslo_concurrency import lockutils\n33 from oslo_config import cfg\n34 from oslo_db import exception as db_exc\n35 from oslo_db.sqlalchemy import enginefacade\n36 from oslo_db.sqlalchemy import test_fixtures as db_fixtures\n37 from oslo_log import log as logging\n38 import oslo_messaging as messaging\n39 from oslo_messaging import conffixture as messaging_conffixture\n40 from oslo_privsep import daemon as privsep_daemon\n41 from oslo_utils.fixture import uuidsentinel\n42 from requests import adapters\n43 from sqlalchemy import exc as sqla_exc\n44 from wsgi_intercept import interceptor\n45 \n46 from nova.api.openstack import wsgi_app\n47 from nova.api import wsgi\n48 from nova.compute import multi_cell_list\n49 from nova.compute import rpcapi as compute_rpcapi\n50 from nova import context\n51 from nova.db.api import api as api_db_api\n52 from nova.db.main import api as main_db_api\n53 from nova.db import migration\n54 from nova import exception\n55 from nova import objects\n56 from nova.objects import base as obj_base\n57 from nova.objects import service as service_obj\n58 import nova.privsep\n59 from nova import quota as nova_quota\n60 from nova import rpc\n61 from nova.scheduler import weights\n62 from nova import service\n63 from nova.tests.functional.api import client\n64 from nova import utils\n65 \n66 CONF = cfg.CONF\n67 LOG = logging.getLogger(__name__)\n68 \n69 DB_SCHEMA = collections.defaultdict(str)\n70 PROJECT_ID = \'6f70656e737461636b20342065766572\'\n71 \n72 \n73 class ServiceFixture(fixtures.Fixture):\n74     """Run a service as a test fixture."""\n75 \n76     def __init__(self, name, host=None, cell=None, **kwargs):\n77         name = name\n78         # If not otherwise specified, the host will default to the\n79         # name of the service. Some things like aggregates care that\n80         # this is stable.\n81         host = host or name\n82         kwargs.setdefault(\'host\', host)\n83         kwargs.setdefault(\'binary\', \'nova-%s\' % name)\n84         self.cell = cell\n85         self.kwargs = kwargs\n86 \n87     def setUp(self):\n88         super(ServiceFixture, self).setUp()\n89         self.ctxt = context.get_admin_context()\n90         if self.cell:\n91             context.set_target_cell(self.ctxt, self.cell)\n92 \n93         with mock.patch(\'nova.context.get_admin_context\',\n94                         return_value=self.ctxt):\n95             self.service = service.Service.create(**self.kwargs)\n96             self.service.start()\n97         self.addCleanup(self.service.kill)\n98 \n99 \n100 class NullHandler(std_logging.Handler):\n101     """custom default NullHandler to attempt to format the record.\n102 \n103     Used in conjunction with\n104     log_fixture.get_logging_handle_error_fixture to detect formatting errors in\n105     debug level logs without saving the logs.\n106     """\n107 \n108     def handle(self, record):\n109         self.format(record)\n110 \n111     def emit(self, record):\n112         pass\n113 \n114     def createLock(self):\n115         self.lock = None\n116 \n117 \n118 class StandardLogging(fixtures.Fixture):\n119     """Setup Logging redirection for tests.\n120 \n121     There are a number of things we want to handle with logging in tests:\n122 \n123     * Redirect the logging to somewhere that we can test or dump it later.\n124 \n125     * Ensure that as many DEBUG messages as possible are actually\n126        executed, to ensure they are actually syntactically valid (they\n127        often have not been).\n128 \n129     * Ensure that we create useful output for tests that doesn\'t\n130       overwhelm the testing system (which means we can\'t capture the\n131       100 MB of debug logging on every run).\n132 \n133     To do this we create a logger fixture at the root level, which\n134     defaults to INFO and create a Null Logger at DEBUG which lets\n135     us execute log messages at DEBUG but not keep the output.\n136 \n137     To support local debugging OS_DEBUG=True can be set in the\n138     environment, which will print out the full debug logging.\n139 \n140     There are also a set of overrides for particularly verbose\n141     modules to be even less than INFO.\n142 \n143     """\n144 \n145     def setUp(self):\n146         super(StandardLogging, self).setUp()\n147 \n148         # set root logger to debug\n149         root = std_logging.getLogger()\n150         root.setLevel(std_logging.DEBUG)\n151 \n152         # supports collecting debug level for local runs\n153         if os.environ.get(\'OS_DEBUG\') in (\'True\', \'true\', \'1\', \'yes\'):\n154             level = std_logging.DEBUG\n155         else:\n156             level = std_logging.INFO\n157 \n158         # Collect logs\n159         fs = \'%(asctime)s %(levelname)s [%(name)s] %(message)s\'\n160         self.logger = self.useFixture(\n161             fixtures.FakeLogger(format=fs, level=None))\n162         # TODO(sdague): why can\'t we send level through the fake\n163         # logger? Tests prove that it breaks, but it\'s worth getting\n164         # to the bottom of.\n165         root.handlers[0].setLevel(level)\n166 \n167         if level > std_logging.DEBUG:\n168             # Just attempt to format debug level logs, but don\'t save them\n169             handler = NullHandler()\n170             self.useFixture(fixtures.LogHandler(handler, nuke_handlers=False))\n171             handler.setLevel(std_logging.DEBUG)\n172 \n173             # Don\'t log every single DB migration step\n174             std_logging.getLogger(\n175                 \'migrate.versioning.api\').setLevel(std_logging.WARNING)\n176             # Or alembic for model comparisons.\n177             std_logging.getLogger(\'alembic\').setLevel(std_logging.WARNING)\n178             # Or oslo_db provisioning steps\n179             std_logging