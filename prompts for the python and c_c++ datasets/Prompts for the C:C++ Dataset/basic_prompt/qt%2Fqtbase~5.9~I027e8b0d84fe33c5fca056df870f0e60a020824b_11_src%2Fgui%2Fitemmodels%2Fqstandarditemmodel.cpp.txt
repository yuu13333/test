Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtGui module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qstandarditemmodel.h"
41 
42 #ifndef QT_NO_STANDARDITEMMODEL
43 
44 #include <QtCore/qdatetime.h>
45 #include <QtCore/qlist.h>
46 #include <QtCore/qmap.h>
47 #include <QtCore/qpair.h>
48 #include <QtCore/qvariant.h>
49 #include <QtCore/qvector.h>
50 #include <QtCore/qstringlist.h>
51 #include <QtCore/qbitarray.h>
52 #include <QtCore/qmimedata.h>
53 
54 #include <private/qstandarditemmodel_p.h>
55 #include <qdebug.h>
56 #include <algorithm>
57 
58 QT_BEGIN_NAMESPACE
59 
60 static inline QString qStandardItemModelDataListMimeType()
61 {
62     return QStringLiteral("application/x-qstandarditemmodeldatalist");
63 }
64 
65 class QStandardItemModelLessThan
66 {
67 public:
68     inline QStandardItemModelLessThan()
69         { }
70 
71     inline bool operator()(const QPair<QStandardItem*, int> &l,
72                            const QPair<QStandardItem*, int> &r) const
73     {
74         return *(l.first) < *(r.first);
75     }
76 };
77 
78 class QStandardItemModelGreaterThan
79 {
80 public:
81     inline QStandardItemModelGreaterThan()
82         { }
83 
84     inline bool operator()(const QPair<QStandardItem*, int> &l,
85                            const QPair<QStandardItem*, int> &r) const
86     {
87         return *(r.first) < *(l.first);
88     }
89 };
90 
91 /*!
92   \internal
93 */
94 QPair<int, int> QStandardItemPrivate::position() const
95 {
96     if (QStandardItem *par = parent) {
97         int idx = par->d_func()->childIndex(q_func());
98         if (idx == -1)
99             return QPair<int, int>(-1, -1);
100         return QPair<int, int>(idx / par->columnCount(), idx % par->columnCount());
101     }
102     // ### support header items?
103     return QPair<int, int>(-1, -1);
104 }
105 
106 /*!
107   \internal
108 */
109 void QStandardItemPrivate::setChild(int row, int column, QStandardItem *item,
110                                     bool emitChanged)
111 {
112     Q_Q(QStandardItem);
113     if (item == q) {
114         qWarning("QStandardItem::setChild: Can't make an item a child of itself %p",
115                  item);
116         return;
117     }
118     if ((row < 0) || (column < 0))
119         return;
120     if (!item)
121         item = new QStandardItem;
122     if (rows <= row)
123         q->setRowCount(row + 1);
124     if (columns <= column)
125         q->setColumnCount(column + 1);
126     int index = childIndex(row, column);
127     Q_ASSERT(index != -1);
128     QStandardItem *oldItem = children.at(index);
129     if (item == oldItem)
130         return;
131 
132     if (model && emitChanged) {
133         emit model->layoutAboutToBeChanged();
134     }
135 
136     if (item->d_func()->parent == 0) {
137         item->d_func()->setParentAndModel(q, model);
138     } else {
139         qWarning("QStandardItem::setChild: Ignoring duplicate insertion of item %p",
140                  item);
141         return;
142     }
143     if (oldItem)
144         oldItem->d_func()->setModel(0);
145     delete oldItem;
146     children.replace(index, item);
147 
148     if (model && emitChanged)
149         emit model->layoutChanged();
150 
151     if (emitChanged && model)
152         model->d_func()->itemChanged(item);
153 }
154 
155 
156 /*!
157   \internal
158 */
159 void QStandardItemPrivate::changeFlags(bool enable, Qt::ItemFlags f)
160 {
161     Q_Q(QStandardItem);
162     Qt::ItemFlags flags = q->flags();
163     if (enable)
164         flags |= f;
165     else
166         flags &= ~f;
167     q->setFlags(flags);
168 }
169 
170 /*!
171   \internal
172 */
173 void QStandardItemPrivate::childDeleted(QStandardItem *child)
174 {
175     int index = childIndex(child);
176     Q_ASSERT(index != -1);
177     children.replace(index, 0);
178 }
179 
180 /*!
181   \internal
182 */
183 void QStandardItemPrivate::setItemData(const QMap<int, QVariant> &roles)
184 {
185     Q_Q(QStandardItem);
186 
187     //let's build the vector of new values
188     QVector<QStandardItemData> newValues;
189     for (auto it = roles.begin(), end = roles.end(); it != end; ++it) {
190         const QVariant &value = it.value();
191         if (value.isValid()) {
192             int role = it.key();
193             role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
194             newValues.append(QStandardItemData(role, value));
195         }
196     }
197 
198     if (values!=newValues) {
199         values.swap(newValues);
200         if (model)
201             model->d_func()->itemChanged(q);
202     }
203 }
204 
205 /*!
206   \internal
207 */
208 const QMap<int, QVariant> QStandardItemPrivate::itemData() const
209 {
210     QMap<int, QVariant> result;
211     QVector<QStandardItemData>::const_iterator it;
212     for (it = values.begin(); it != values.end(); ++it)
213         result.insert((*it).role, (*it).value);
214     return result;
215 }
216 
217 /*!
218   \internal
219 */
220 void QStandardItemPrivate::sortChildren(int column, Qt::SortOrder order)
221 {
222     Q_Q(QStandardItem);
223     if (column >= columnCount())
224         return;
225 
226     QVector<QPair<QStandardItem*, int> > sortable;
227     QVector<int> unsortable;
228 
229     sortable.reserve(rowCount());
230     unsortable.reserve(rowCount());
231 
232     for (int row = 0; row < rowCount(); ++row) {
233         QStandardItem *itm = q->child(row, column);
234         if (itm)
235             sortable.append(QPair<QStandardItem*,int>(itm, row));
236         else
237             unsortable.append(row);
238     }
239 
240     if (order == Qt::AscendingOrder) {
241         QStandardItemModelLessThan lt;
242         std::stable_sort(sortable.begin(), sortable.end(), lt);
243     } else {
244         QStandardItemModelGreaterThan gt;
245         std::stable_sort(sortable.begin(), sortable.end(), gt);
246     }
247 
248     QModelIndexList changedPersistentIndexesFrom, changedPersistentIndexesTo;
249     QVector<QStandardItem*> sorted_children(children.count());
250     for (int i = 0; i < rowCount(); ++i) {
251         int r = (i < sortable.count()
252                  ? sortable.at(i).second
253                  : unsortable.at(i - sortable.count()));
254         for (int c = 0; c < columnCount(); ++c) {
255             QStandardItem *itm = q->child(r, c);
256             sorted_children[childIndex(i, c)] = itm;
257             if (model) {
258                 QModelIndex from = model->createIndex(r, c, q);
259                 if (model->d_func()->persistent.indexes.contains(from)) {
260                     QModelIndex to = model->createIndex(i, c, q);
261                     changedPersistentIndexesFrom.append(from);
262                     changedPersistentIndexesTo.append(to);
263                 }
264             }
265         }
266     }
267 
268     children = sorted_children;
269 
270     if (model) {
271         model->changePersistentIndexList(changedPersistentIndexesFrom, changedPersistentIndexesTo);
272     }
273 
274     QVector<QStandardItem*>::iterator it;
275     for (it = children.begin(); it != children.end(); ++it) {
276         if (*it)
277             (*it)->d_func()->sortChildren(column, order);
278     }
279 }
280 
281 /*!
282   \internal
283   set the model of this item and all its children
284   */
285 void QStandardItemPrivate::setModel(QStandardItemModel *mod)
286 {
287     if (children.isEmpty()) {
288         if (model)
289             model->d_func()->invalidatePersistentIndex(model->indexFromItem(q_ptr));
290         model = mod;
291     } else {
292         QStack<QStandardItem*> stack;
293         stack.push(q_ptr);
294         while (!stack.isEmpty()) {
295             QStandardItem *itm = stack.pop();
296             if (itm->d_func()->model) {
297                 itm->d_func()->model->d_func()->invalidatePersistentIndex(itm->d_func()->model->indexFromItem(itm));
298             }
299             itm->d_func()->model = mod;
300             const QVector<QStandardItem*> &childList = itm->d_func()->children;
301             for (int i = 0; i < childList.count(); ++i) {
302                 QStandardItem *chi = childList.at(i);
303                 if (chi)
304                     stack.push(chi);
305             }
306         }
307     }
308 }
309 
310 /*!
311   \internal
312 */
313 QStandardItemModelPrivate::QStandardItemModelPrivate()
314     : root(new QStandardItem),
315       itemPrototype(0),
316       sortRole(Qt::DisplayRole)
317 {
318     root->setFlags(Qt::ItemIsDropEnabled);
319 }
320 
321 /*!
322   \internal
323 */
324 QStandardItemModelPrivate::~QStandardItemModelPrivate()
325 {
326 }
327 
328 /*!
329   \internal
330 */
331 void QStandardItemModelPrivate::init()
332 {
333     Q_Q(QStandardItemModel);
334     QObject::connect(q, SIGNAL(dataChanged(QModelIndex,QModelIndex)),
335                      q, SLOT(_q_emitItemChanged(QModelIndex,QModelIndex)));
336 }
337 
338 /*!
339     \internal
340 */
341 void QStandardItemModelPrivate::_q_emitItemChanged(const QModelIndex &topLeft,
342                                                    const QModelIndex &bottomRight)
343 {
344     Q_Q(QStandardItemModel);
345     QModelIndex parent = topLeft.parent();
346     for (int row = topLeft.row(); row <= bottomRight.row(); ++row) {
347         for (int column = topLeft.column(); column <= bottomRight.column(); ++column) {
348             QModelIndex index = q->index(row, column, parent);
349             if (QStandardItem *item = itemFromIndex(index))
350                 emit q->itemChanged(item);
351         }
352     }
353 }
354 
355 /*!
356     \internal
357 */
358 bool QStandardItemPrivate::insertRows(int row, const QList<QStandardItem*> &items)
359 {
360     Q_Q(QStandardItem);
361     if ((row < 0) || (row > rowCount()))
362         return false;
363     int count = items.count();
364     if (model)
365         model->d_func()->rowsAboutToBeInserted(q, row, row + count - 1);
366     if (rowCount() == 0) {
367         if (columnCount() == 0)
368             q->setColumnCount(1);
369         children.resize(columnCount() * count);
370         rows = count;
371     } else {
372         rows += count;
373         int index = childIndex(row, 0);
374         if (index != -1)
375             children.insert(index, columnCount() * count, 0);
376     }
377     for (int i = 0; i < items.count(); ++i) {
378         QStandardItem *item = items.at(i);
379         item->d_func()->model = model;
380         item->d_func()->parent = q;
381         int index = childIndex(i + row, 0);
382         children.replace(index, item);
383     }
384     if (model)
385         model->d_func()->rowsInserted(q, row, count);
386     return true;
387 }
388 
389 bool QStandardItemPrivate::insertRows(int row, int count, const QList<QStandardItem*> &items)
390 {
391     Q_Q(QStandardItem);
392     if ((count < 1) || (row < 0) || (row > rowCount()))
393         return false;
394     if (model)
395         model->d_func()->rowsAboutToBeInserted(q, row, row + count - 1);
396     if (rowCount() == 0) {
397         children.resize(columnCount() * count);
398         rows = count;
399     } else {
400         rows += count;
401         int index = childIndex(row, 0);
402         if (index != -1)
403             children.insert(index, columnCount() * count, 0);
404     }
405     if (!items.isEmpty()) {
406         int index = childIndex(row, 0);
407         int limit = qMin(items.count(), columnCount() * count);
408         for (int i = 0; i < limit; ++i) {
409             QStandardItem *item = items.at(i);
410             if (item) {
411                 if (item->d_func()->parent == 0) {
412                     item->d_func()->setParentAndModel(q, model);
413                 } else {
414                     qWarning("QStandardItem::insertRows: Ignoring duplicate insertion of item %p",
415                              item);
416                     item = 0;
417                 }
418             }
419             children.replace(index, item);
420             ++index;
421         }
422     }
423     if (model)
424         model->d_func()->rowsInserted(q, row, count);
425     return true;
426 }
427 
428 /*!
429     \internal
430 */
431 bool QStandardItemPrivate::insertColumns(int column, int count, const QList<QStandardItem*> &items)
432 {
433     Q_Q(QStandardItem);
434     if ((count < 1) || (column < 0) || (column > columnCount()))
435         return false;
436     if (model)
437         model->d_func()->columnsAboutToBeInserted(q, column, column + count - 1);
438     if (columnCount() == 0) {
439         children.resize(rowCount() * count);
440         columns = count;
441     } else {
442         columns += count;
443         int index = childIndex(0, column);
444         for (int row = 0; row < rowCount(); ++row) {
445             children.insert(index, count, 0);
446             index += columnCount();
447         }
448     }
449     if (!items.isEmpty()) {
450         int limit = qMin(items.count(), rowCount() * count);
451         for (int i = 0; i < limit; ++i) {
452             QStandardItem *item = items.at(i);
453             if (item) {
454                 if (item->d_func()->parent == 0) {
455                     item->d_func()->setParentAndModel(q, model);
456                 } else {
457                     qWarning("QStandardItem::insertColumns: Ignoring duplicate insertion of item %p",
458                              item);
459                     item = 0;
460                 }
461             }
462             int r = i / count;
463             int c = column + (i % count);
464             int index = childIndex(r, c);
465             children.replace(index, item);
466         }
467     }
468     if (model)
469         model->d_func()->columnsInserted(q, column, count);
470     return true;
471 }
472 
473 /*!
474   \internal
475 */
476 void QStandardItemModelPrivate::itemChanged(QStandardItem *item)
477 {
478     Q_Q(QStandardItemModel);
479     if (item->d_func()->parent == 0) {
480         // Header item
481         int idx = columnHeaderItems.indexOf(item);
482         if (idx != -1) {
483             emit q->headerDataChanged(Qt::Horizontal, idx, idx);
484         } else {
485             idx = rowHeaderItems.indexOf(item);
486             if (idx != -1)
487                 emit q->headerDataChanged(Qt::Vertical, idx, idx);
488         }
489     } else {
490         // Normal item
491         QModelIndex index = q->indexFromItem(item);
492         emit q->dataChanged(index, index);
493     }
494 }
495 
496 /*!
497   \internal
498 */
499 void QStandardItemModelPrivate::rowsAboutToBeInserted(QStandardItem *parent,
500                                                       int start, int end)
501 {
502     Q_Q(QStandardItemModel);
503     QModelIndex index = q->indexFromItem(parent);
504     q->beginInsertRows(index, start, end);
505 }
506 
507 /*!
508   \internal
509 */
510 void QStandardItemModelPrivate::columnsAboutToBeInserted(QStandardItem *parent,
511                                                          int start, int end)
512 {
513     Q_Q(QStandardItemModel);
514     QModelIndex index = q->indexFromItem(parent);
515     q->beginInsertColumns(index, start, end);
516 }
517 
518 /*!
519   \internal
520 */
521 void QStandardItemModelPrivate::rowsAboutToBeRemoved(QStandardItem *parent,
522                                                      int start, int end)
523 {
524     Q_Q(QStandardItemModel);
525     QModelIndex index = q->indexFromItem(parent);
526     q->beginRemoveRows(index, start, end);
527 }
528 
529 /*!
530   \internal
531 */
532 void QStandardItemModelPrivate::columnsAboutToBeRemoved(QStandardItem *parent,
533                                                         int start, int end)
534 {
535     Q_Q(QStandardItemModel);
536     QModelIndex index = q->indexFromItem(parent);
537     q->beginRemoveColumns(index, start, end);
538 }
539 
540 /*!
541   \internal
542 */
543 void QStandardItemModelPrivate::rowsInserted(QStandardItem *parent,
544                                              int row, int count)
545 {
546     Q_Q(QStandardItemModel);
547     if (parent == root.data())
548         rowHeaderItems.insert(row, count, 0);
549     q->endInsertRows();
550 }
551 
552 /*!
553   \internal
554 */
555 void QStandardItemModelPrivate::columnsInserted(QStandardItem *parent,
556                                                 int column, int count)
557 {
558     Q_Q(QStandardItemModel);
559     if (parent == root.data())
560         columnHeaderItems.insert(column, count, 0);
561     q->endInsertColumns();
562 }
563 
564 /*!
565   \internal
566 */
567 void QStandardItemModelPrivate::rowsRemoved(QStandardItem *parent,
568                                             int row, int count)
569 {
570     Q_Q(QStandardItemModel);
571     if (parent == root.data()) {
572         for (int i = row; i < row + count; ++i) {
573             QStandardItem *oldItem = rowHeaderItems.at(i);
574             if (oldItem)
575                 oldItem->d_func()->setModel(0);
576             delete oldItem;
577         }
578         rowHeaderItems.remove(row, count);
579     }
580     q->endRemoveRows();
581 }
582 
583 /*!
584   \internal
585 */
586 void QStandardItemModelPrivate::columnsRemoved(QStandardItem *parent,
587                                                int column, int count)
588 {
589     Q_Q(QStandardItemModel);
590     if (parent == root.data()) {
591         for (int i = column; i < column + count; ++i) {
592             QStandardItem *oldItem = columnHeaderItems.at(i);
593             if (oldItem)
594                 oldItem->d_func()->setModel(0);
595             delete oldItem;
596         }
597         columnHeaderItems.remove(column, count);
598     }
599     q->endRemoveColumns();
600 }
601 
602 /*!
603     \class QStandardItem
604     \brief The QStandardItem class provides an item for use with the
605     QStandardItemModel class.
606     \since 4.2
607     \ingroup model-view
608     \inmodule QtGui
609 
610     Items usually contain text, icons, or checkboxes.
611 
612     Each item can have its own background brush which is set with the
613     setBackground() function. The current background brush can be found with
614     background().  The text label for each item can be rendered with its own
615     font and brush. These are specified with the setFont() and setForeground()
616     functions, and read with font() and foreground().
617 
618     By default, items are enabled, editable, selectable, checkable, and can be
619     used both as the source of a drag and drop operation and as a drop target.
620     Each item's flags can be changed by calling setFlags(). Checkable items
621     can be checked and unchecked with the setCheckState() function. The
622     corresponding checkState() function indicates whether the item is
623     currently checked.
624 
625     You can store application-specific data in an item by calling setData().
626 
627     Each item can have a two-dimensional table of child items. This makes it
628     possible to build hierarchies of items. The typical hierarchy is the tree,
629     in which case the child table is a table with a single column (a list).
630 
631     The dimensions of the child table can be set with setRowCount() and
632     setColumnCount(). Items can be positioned in the child table with
633     setChild(). Get a pointer to a child item with child(). New rows and
634     columns of children can also be inserted with insertRow() and
635     insertColumn(), or appended with appendRow() and appendColumn(). When
636     using the append and insert functions, the dimensions of the child table
637     will grow as needed.
638 
639     An existing row of children can be removed with removeRow() or takeRow();
640     correspondingly, a column can be removed with removeColumn() or
641     takeColumn().
642 
643     An item's children can be sorted by calling sortChildren().
644 
645     \section1 Subclassing
646 
647     When subclassing QStandardItem to provide custom items, it is possible to
648     define new types for them so that they can be distinguished from the base
649     class. The type() function should be reimplemented to return a new type
650     value equal to or greater than \l UserType.
651 
652     Reimplement data() and setData() if you want to perform custom handling of
653     data queries and/or control how an item's data is represented.
654 
655     Reimplement clone() if you want QStandardItemModel to be able to create
656     instances of your custom item class on demand (see
657     QStandardItemModel::setItemPrototype()).
658 
659     Reimplement read() and write() if you want to control how items are
660     represented in their serialized form.
661 
662     Reimplement \l{operator<()} if you want to control the semantics of item
663     comparison. \l{operator<()} determines the sorted order when sorting items
664     with sortChildren() or with QStandardItemModel::sort().
665 
666     \sa QStandardItemModel, {Item View Convenience Classes}, {Model/View Programming}
667 */
668 
669 /*!
670     \enum QStandardItem::ItemType
671 
672     This enum describes the types that are used to describe standard items.
673 
674     \value Type     The default type for standard items.
675     \value UserType The minimum value for custom types. Values below UserType are
676                     reserved by Qt.
677 
678     You can define new user types in QStandardItem subclasses to ensure that
679     custom items are treated specially; for example, when items are sorted.
680 
681     \sa type()
682 */
683 
684 /*!
685     Constructs an item.
686 */
687 QStandardItem::QStandardItem()
688     : QStandardItem(*new QStandardItemPrivate)
689 {
690 }
691 
692 /*!
693     Constructs an item with the given \a text.
694 */
695 QStandardItem::QStandardItem(const QString &text)
696     : QStandardItem(*new QStandardItemPrivate)
697 {
698     setText(text);
699 }
700 
701 /*!
702     Constructs an item with the given \a icon and \a text.
703 */
704 QStandardItem::QStandardItem(const QIcon &icon, const QString &text)
705     : QStandardItem(text)
706 {
707     setIcon(icon);
708 }
709 
710 /*!
711    Constructs an item with \a rows rows and \a columns columns of child items.
712 */
713 QStandardItem::QStandardItem(int rows, int columns)
714     : QStandardItem(*new QStandardItemPrivate)
715 {
716     setRowCount(rows);
717     setColumnCount(columns);
718 }
719 
720 /*!
721   \internal
722 */
723 QStandardItem::QStandardItem(QStandardItemPrivate &dd)
724     : d_ptr(&dd)
725 {
726     Q_D(QStandardItem);
727     d->q_ptr = this;
728 }
729 
730 /*!
731   Constructs a copy of \a other. Note that model() is
732   not copied.
733 
734   This function is useful when reimplementing clone().
735 */
736 QStandardItem::QStandardItem(const QStandardItem &other)
737     : d_ptr(new QStandardItemPrivate)
738 {
739     Q_D(QStandardItem);
740     d->q_ptr = this;
741     operator=(other);
742 }
743 
744 /*!
745   Assigns \a other's data and flags to this item. Note that
746   type() and model() are not copied.
747 
748   This function is useful when reimplementing clone().
749 */
750 QStandardItem &QStandardItem::operator=(const QStandardItem &other)
751 {
752     Q_D(QStandardItem);
753     d->values = other.d_func()->values;
754     return *this;
755 }
756 
757 /*!
758   Destructs the item.
759   This causes the item's children to be destructed as well.
760 */
761 QStandardItem::~QStandardItem()
762 {
763     Q_D(QStandardItem);
764     for (QStandardItem *child : qAsConst(d->children)) {
765         if (child)
766             child->d_func()->setModel(0);
767         delete child;
768     }
769     d->children.clear();
770     if (d->parent && d->model)
771         d->parent->d_func()->childDeleted(this);
772 }
773 
774 /*!
775   Returns the item's parent item, or 0 if the item has no parent.
776   \note For toplevel items parent() returns 0. To receive toplevel
777   item's parent use QStandardItemModel::invisibleRootItem() instead.
778 
779   \sa child(), QStandardItemModel::invisibleRootItem()
780 */
781 QStandardItem *QStandardItem::parent() const
782 {
783     Q_D(const QStandardItem);
784     if (!d->model || (d->model->d_func()->root.data() != d->parent))
785         return d->parent;
786     return 0;
787 }
788 
789 /*!
790     Sets the item's data for the given \a role to the specified \a value.
791 
792     If you subclass QStandardItem and reimplement this function, your
793     reimplementation should call emitDataChanged() if you do not call
794     the base implementation of setData(). This will ensure that e.g.
795     views using the model are notified of the changes.
796 
797     \note The default implementation treats Qt::EditRole and Qt::DisplayRole
798     as referring to the same data.
799 
800     \sa Qt::ItemDataRole, data(), setFlags()
801 */
802 void QStandardItem::setData(const QVariant &value, int role)
803 {
804     Q_D(QStandardItem);
805     role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
806     QVector<QStandardItemData>::iterator it;
807     for (it = d->values.begin(); it != d->values.end(); ++it) {
808         if ((*it).role == role) {
809             if (value.isValid()) {
810                 if ((*it).value.type() == value.type() && (*it).value == value)
811                     return;
812                 (*it).value = value;
813             } else {
814                 d->values.erase(it);
815             }
816             if (d->model)
817                 d->model->d_func()->itemChanged(this);
818             return;
819         }
820     }
821     d->values.append(QStandardItemData(role, value));
822     if (d->model)
823         d->model->d_func()->itemChanged(this);
824 }
825 
826 /*!
827     Returns the item's data for the given \a role, or an invalid
828     QVariant if there is no data for the role.
829 
830     \note The default implementation treats Qt::EditRole and Qt::DisplayRole
831     as referring to the same data.
832 */
833 QVariant QStandardItem::data(int role) const
834 {
835     Q_D(const QStandardItem);
836     role = (role == Qt::EditRole) ? Qt::DisplayRole : role;
837     QVector<QStandardItemData>::const_iterator it;
838     for (it = d->values.begin(); it != d->values.end(); ++it) {
839         if ((*it).role == role)
840             return (*it).value;
841     }
842     return QVariant();
843 }
844 
845 /*!
846   \since 4.4
847 
848   Causes the model associated with this item to emit a
849   \l{QAbstractItemModel::dataChanged()}{dataChanged}() signal for this
850   item.
851 
852   You normally only need to call this function if you have subclassed
853   QStandardItem and reimplemented data() and/or setData().
854 
855   \sa setData()
856 */
857 void QStandardItem::emitDataChanged()
858 {
859     Q_D(QStandardItem);
860     if (d->model)
861         d->model->d_func()->itemChanged(this);
862 }
863 
864 /*!
865   Sets the item flags for the item to \a flags.
866 
867   The item flags determine how the user can interact with the item.
868   This is often used to disable an item.
869 
870   \sa flags(), setData()
871 */
872 void QStandardItem::setFlags(Qt::ItemFlags flags)
873 {
874     setData((int)flags, Qt::UserRole - 1);
875 }
876 
877 /*!
878   Returns the item flags for the item.
879 
880   The item flags determine how the user can interact with the item.
881 
882   By default, items are enabled, editable, selectable, checkable, and can be
883   used both as the source of a drag and drop operation and as a drop target.
884 
885   \sa setFlags()
886 */
887 Qt::ItemFlags QStandardItem::flags() const
888 {
889     QVariant v = data(Qt::UserRole - 1);
890     if (!v.isValid())
891         return (Qt::ItemIsSelectable|Qt::ItemIsEnabled|Qt::ItemIsEditable
892                 |Qt::ItemIsDragEnabled|Qt::ItemIsDropEnabled);
893     return Qt::ItemFlags(v.toInt());
894 }
895 
896 /*!
897     \fn QString QStandardItem::text() const
898 
899     Returns the item's text. This is the text that's presented to the user
900     in a view.
901 
902     \sa setText()
903 */
904 
905 /*!
906     \fn void QStandardItem::setText(const QString &text)
907 
908     Sets the item's text to the \a text specified.
909 
910     \sa text(), setFont(), setForeground()
911 */
912 
913 /*!
914     \fn QIcon QStandardItem::icon() const
915 
916     Returns the item's icon.
917 
918     \sa setIcon(), {QAbstractItemView::iconSize}{iconSize}
919 */
920 
921 /*!
922     \fn void QStandardItem::setIcon(const QIcon &icon)
923 
924     Sets the item's icon to the \a icon specified.
925 */
926 
927 /*!
928     \fn QString QStandardItem::statusTip() const
929 
930     Returns the item's status tip.
931 
932     \sa setStatusTip(), toolTip(), whatsThis()
933 */
934 
935 /*!
936     \fn void QStandardItem::setStatusTip(const QString &statusTip)
937 
938     Sets the item's status tip to the string specified by \a statusTip.
939 
940     \sa statusTip(), setToolTip(), setWhatsThis()
941 */
942 
943 /*!
944     \fn QString QStandardItem::toolTip() const
945 
946     Returns the item's tooltip.
947 
948     \sa setToolTip(), statusTip(), whatsThis()
949 */
950 
951 /*!
952     \fn void QStandardItem::setToolTip(const QString &toolTip)
953 
954     Sets the item's tooltip to the string specified by \a toolTip.
955 
956     \sa toolTip(), setStatusTip(), setWhatsThis()
957 */
958 
959 /*!
960     \fn QString QStandardItem::whatsThis() const
961 
962     Returns the item's "What's This?" help.
963 
964     \sa setWhatsThis(), toolTip(), statusTip()
965 */
966 
967 /*!
968     \fn void QStandardItem::setWhatsThis(const QString &whatsThis)
969 
970     Sets the item's "What's This?" help to the string specified by \a whatsThis.
971 
972     \sa whatsThis(), setStatusTip(), setToolTip()
973 */
974 
975 /*!
976     \fn QFont QStandardItem::font() const
977 
978     Returns the font used to render the item's text.
979 
980     \sa setFont()
981 */
982 
983 /*!
984     \fn void QStandardItem::setFont(const QFont &font)
985 
986     Sets the font used to display the item's text to the given \a font.
987 
988     \sa font(), setText(), setForeground()
989 */
990 
991 /*!
992     \fn QBrush QStandardItem::background() const
993 
994     Returns the brush used to render the item's background.
995 
996     \sa foreground(), setBackground()
997 */
998 
999 /*!
1000     \fn void QStandardItem::setBackground(const QBrush &brush)
1001 
1002     Sets the item's background brush to the specified \a brush.
1003 
1004     \sa background(), setForeground()
1005 */
1006 
1007 /*!
1008     \fn QBrush QStandardItem::foreground() const
1009 
1010     Returns the brush used to render the item's foreground (e.g. text).
1011 
1012     \sa setForeground(), background()
1013 */
1014 
1015 /*!
1016     \fn void QStandardItem::setForeground(const QBrush &brush)
1017 
1018     Sets the brush used to display the item's foreground (e.g. text) to the
1019     given \a brush.
1020 
1021     \sa foreground(), setBackground(), setFont()
1022 */
1023 
1024 /*!
1025     \fn int QStandardItem::textAlignment() const
1026 
1027     Returns the text alignment for the item's text.
1028 */
1029 
1030 /*!
1031     \fn void QStandardItem::setTextAlignment(Qt::Alignment alignment)
1032 
1033     Sets the text alignment for the item's text to the \a alignment
1034     specified.
1035 
1036     \sa textAlignment()
1037 */
1038 
1039 /*!
1040     \fn QSize QStandardItem::sizeHint() const
1041 
1042     Returns the size hint set for the item, or an invalid QSize if no
1043     size hint has been set.
1044 
1045     If no size hint has been set, the item delegate will compute the
1046     size hint based on the item data.
1047 
1048     \sa setSizeHint()
1049 */
1050 
1051 /*!
1052     \fn void QStandardItem::setSizeHint(const QSize &size)
1053 
1054     Sets the size hint for the item to be \a size.
1055     If no size hint is set, the item delegate will compute the
1056     size hint based on the item data.
1057 
1058     \sa sizeHint()
1059 */
1060 
1061 /*!
1062     \fn Qt::CheckState QStandardItem::checkState() const
1063 
1064     Returns the checked state of the item.
1065 
1066     \sa setCheckState(), isCheckable()
1067 */
1068 
1069 /*!
1070     \fn void QStandardItem::setCheckState(Qt::CheckState state)
1071 
1072     Sets the check state of the item to be \a state.
1073 
1074     \sa checkState(), setCheckable()
1075 */
1076 
1077 /*!
1078     \fn QString QStandardItem::accessibleText() const
1079 
1080     Returns the item's accessible text.
1081 
1082     The accessible text is used by assistive technologies (i.e. for users who
1083     cannot use conventional means of interaction).
1084 
1085     \sa setAccessibleText(), accessibleDescription()
1086 */
1087 
1088 /*!
1089     \fn void QStandardItem::setAccessibleText(const QString &accessibleText)
1090 
1091     Sets the item's accessible text to the string specified by \a accessibleText.
1092 
1093     The accessible text is used by assistive technologies (i.e. for users who
1094     cannot use conventional means of interaction).
1095 
1096     \sa accessibleText(), setAccessibleDescription()
1097 */
1098 
1099 /*!
1100     \fn QString QStandardItem::accessibleDescription() const
1101 
1102     Returns the item's accessible description.
1103 
1104     The accessible description is used by assistive technologies (i.e. for
1105     users who cannot use conventional means of interaction).
1106 
1107     \sa setAccessibleDescription(), accessibleText()
1108 */
1109 
1110 /*!
1111     \fn void QStandardItem::setAccessibleDescription(const QString &accessibleDescription)
1112 
1113     Sets the item's accessible description to the string specified by \a
1114     accessibleDescription.
1115 
1116     The accessible description is used by assistive technologies (i.e. for
1117     users who cannot use conventional means of interaction).
1118 
1119     \sa accessibleDescription(), setAccessibleText()
1120 */
1121 
1122 /*!
1123   Sets whether the item is enabled. If \a enabled is true, the item is enabled,
1124   meaning that the user can interact with the item; if \a enabled is false, the
1125   user cannot interact with the item.
1126 
1127   This flag takes precedence over the other item flags; e.g. if an item is not
1128   enabled, it cannot be selected by the user, even if the Qt::ItemIsSelectable
1129   flag has been set.
1130 
1131   \sa isEnabled(), Qt::ItemIsEnabled, setFlags()
1132 */
1133 void QStandardItem::setEnabled(bool enabled)
1134 {
1135     Q_D(QStandardItem);
1136     d->changeFlags(enabled, Qt::ItemIsEnabled);
1137 }
1138 
1139 /*!
1140   \fn bool QStandardItem::isEnabled() const
1141 
1142   Returns whether the item is enabled.
1143 
1144   When an item is enabled, the user can interact with it. The possible
1145   types of interaction are specified by the other item flags, such as
1146   isEditable() and isSelectable().
1147 
1148   The default value is true.
1149 
1150   \sa setEnabled(), flags()
1151 */
1152 
1153 /*!
1154   Sets whether the item is editable. If \a editable is true, the item can be
1155   edited by the user; otherwise, the user cannot edit the item.
1156 
1157   How the user can edit items in a view is determined by the view's edit
1158   triggers; see QAbstractItemView::editTriggers.
1159 
1160   \sa isEditable(), setFlags()
1161 */
1162 void QStandardItem::setEditable(bool editable)
1163 {
1164     Q_D(QStandardItem);
1165     d->changeFlags(editable, Qt::ItemIsEditable);
1166 }
1167 
1168 /*!
1169   \fn bool QStandardItem::isEditable() const
1170 
1171   Returns whether the item can be edited by the user.
1172 
1173   When an item is editable (and enabled), the user can edit the item by
1174   invoking one of the view's edit triggers; see
1175   QAbstractItemView::editTriggers.
1176 
1177   The default value is true.
1178 
1179   \sa setEditable(), flags()
1180 */
1181 
1182 /*!
1183   Sets whether the item is selectable. If \a selectable is true, the item
1184   can be selected by the user; otherwise, the user cannot select the item.
1185 
1186   You can control the selection behavior and mode by manipulating their
1187   view properties; see QAbstractItemView::selectionMode and
1188   QAbstractItemView::selectionBehavior.
1189 
1190   \sa isSelectable(), setFlags()
1191 */
1192 void QStandardItem::setSelectable(bool selectable)
1193 {
1194     Q_D(QStandardItem);
1195     d->changeFlags(selectable, Qt::ItemIsSelectable);
1196 }
1197 
1198 /*!
1199   \fn bool QStandardItem::isSelectable() const
1200 
1201   Returns whether the item is selectable by the user.
1202 
1203   The default value is true.
1204 
1205   \sa setSelectable(), flags()
1206 */
1207 
1208 /*!
1209   Sets whether the item is user-checkable. If \a checkable is true, the
1210   item can be checked by the user; otherwise, the user cannot check
1211   the item.
1212 
1213   The item delegate will render a checkable item with a check box next to the
1214   item's text.
1215 
1216   \sa isCheckable(), setCheckState(), setUserTristate(), setAutoTristate()
1217 */
1218 void QStandardItem::setCheckable(bool checkable)
1219 {
1220     Q_D(QStandardItem);
1221     if (checkable && !isCheckable()) {
1222         // make sure there's data for the checkstate role
1223         if (!data(Qt::CheckStateRole).isValid())
1224             setData(Qt::Unchecked, Qt::CheckStateRole);
1225     }
1226     d->changeFlags(checkable, Qt::ItemIsUserCheckable);
1227 }
1228 
1229 /*!
1230   \fn bool QStandardItem::isCheckable() const
1231 
1232   Returns whether the item is user-checkable.
1233 
1234   The default value is false.
1235 
1236   \sa setCheckable(), checkState(), isUserTristate(), isAutoTristate()
1237 */
1238 
1239 /*!
1240   \fn void QStandardItem::setTristate(bool tristate)
1241   \obsolete
1242 
1243   Use QStandardItem::setAutoTristate(bool tristate) instead.
1244   For a tristate checkbox that the user can change between all three
1245   states, use QStandardItem::setUserTristate(bool tristate) instead.
1246 */
1247 
1248 /*!
1249   \fn void QStandardItem::isTristate() const
1250   \obsolete
1251 
1252   Use QStandardItem::isAutoTristate() instead.
1253   For a tristate checkbox that the user can change between all three
1254   states, use QStandardItem::isUserTristate() instead.
1255 */
1256 
1257 /*!
1258   Determines that the item is tristate and controlled by QTreeWidget if \a tristate
1259   is \c true.
1260   This enables automatic management of the state of parent items in QTreeWidget
1261   (checked if all children are checked, unchecked if all children are unchecked,
1262   or partially checked if only some children are checked).
1263 
1264   \since 5.6
1265   \sa isAutoTristate(), setCheckable(), setCheckState()
1266 */
1267 void QStandardItem::setAutoTristate(bool tristate)
1268 {
1269     Q_D(QStandardItem);
1270     d->changeFlags(tristate, Qt::ItemIsAutoTristate);
1271 }
1272 
1273 /*!
1274   \fn bool QStandardItem::isAutoTristate() const
1275 
1276   Returns whether the item is tristate and is controlled by QTreeWidget.
1277 
1278   The default value is false.
1279 
1280   \since 5.6
1281   \sa setAutoTristate(), isCheckable(), checkState()
1282 */
1283 
1284 /*!
1285   Sets whether the item is tristate and controlled by the user.
1286   If \a tristate is true, the user can cycle through three separate states;
1287   otherwise, the item is checkable with two states.
1288   (Note that this also requires that the item is checkable; see isCheckable().)
1289 
1290   \since 5.6
1291   \sa isUserTristate(), setCheckable(), setCheckState()
1292 */
1293 void QStandardItem::setUserTristate(bool tristate)
1294 {
1295     Q_D(QStandardItem);
1296     d->changeFlags(tristate, Qt::ItemIsUserTristate);
1297 }
1298 
1299 /*!
1300   \fn bool QStandardItem::isUserTristate() const
1301   \since 5.6
1302 
1303   Returns whether the item is tristate; that is, if it's checkable with three
1304   separate states and the user can cycle through all three states.
1305 
1306   The default value is false.
1307 
1308   \sa setUserTristate(), isCheckable(), checkState()
1309 */
1310 
1311 #if QT_DEPRECATED_SINCE(5, 6)
1312 void QStandardItem::setTristate(bool tristate)
1313 {
1314     setAutoTristate(tristate);
1315 }
1316 #endif
1317 
1318 #ifndef QT_NO_DRAGANDDROP
1319 
1320 /*!
1321   Sets whether the item is drag enabled. If \a dragEnabled is true, the item
1322   can be dragged by the user; otherwise, the user cannot drag the item.
1323 
1324   Note that you also need to ensure that item dragging is enabled in the view;
1325   see QAbstractItemView::dragEnabled.
1326 
1327   \sa isDragEnabled(), setDropEnabled(), setFlags()
1328 */
1329 void QStandardItem::setDragEnabled(bool dragEnabled)
1330 {
1331     Q_D(QStandardItem);
1332     d->changeFlags(dragEnabled, Qt::ItemIsDragEnabled);
1333 }
1334 
1335 /*!
1336   \fn bool QStandardItem::isDragEnabled() const
1337 
1338   Returns whether the item is drag enabled. An item that is drag enabled can
1339   be dragged by the user.
1340 
1341   The default value is true.
1342 
1343   Note that item dragging must be enabled in the view for dragging to work;
1344   see QAbstractItemView::dragEnabled.
1345 
1346   \sa setDragEnabled(), isDropEnabled(), flags()
1347 */
1348 
1349 /*!
1350   Sets whether the item is drop enabled. If \a dropEnabled is true, the item
1351   can be used as a drop target; otherwise, it cannot.
1352 
1353   Note that you also need to ensure that drops are enabled in the view; see
1354   QWidget::acceptDrops(); and that the model supports the desired drop actions;
1355   see QAbstractItemModel::supportedDropActions().
1356 
1357   \sa isDropEnabled(), setDragEnabled(), setFlags()
1358 */
1359 void QStandardItem::setDropEnabled(bool dropEnabled)
1360 {
1361     Q_D(QStandardItem);
1362     d->changeFlags(dropEnabled, Qt::ItemIsDropEnabled);
1363 }
1364 
1365 /*!
1366   \fn bool QStandardItem::isDropEnabled() const
1367 
1368   Returns whether the item is drop enabled. When an item is drop enabled, it
1369   can be used as a drop target.
1370 
1371   The default value is true.
1372 
1373   \sa setDropEnabled(), isDragEnabled(), flags()
1374 */
1375 
1376 #endif // QT_NO_DRAGANDDROP
1377 
1378 /*!
1379   Returns the row where the item is located in its parent's child table, or
1380   -1 if the item has no parent.
1381 
1382   \sa column(), parent()
1383 */
1384 int QStandardItem::row() const
1385 {
1386     Q_D(const QStandardItem);
1387     QPair<int, int> pos = d->position();
1388     return pos.first;
1389 }
1390 
1391 /*!
1392   Returns the column where the item is located in its parent's child table,
1393   or -1 if the item has no parent.
1394 
1395   \sa row(), parent()
1396 */
1397 int QStandardItem::column() const
1398 {
1399     Q_D(const QStandardItem);
1400     QPair<int, int> pos = d->position();
1401     return pos.second;
1402 }
1403 
1404 /*!
1405   Returns the QModelIndex associated with this item.
1406 
1407   When you need to invoke item functionality in a QModelIndex-based API (e.g.
1408   QAbstractItemView), you can call this function to obtain an index that
1409   corresponds to the item's location in the model.
1410 
1411   If the item is not associated with a model, an invalid QModelIndex is
1412   returned.
1413 
1414   \sa model(), QStandardItemModel::itemFromIndex()
1415 */
1416 QModelIndex QStandardItem::index() const
1417 {
1418     Q_D(const QStandardItem);
1419     return d->model ? d->model->indexFromItem(this) : QModelIndex();
1420 }
1421 
1422 /*!
1423   Returns the QStandardItemModel that this item belongs to.
1424 
1425   If the item is not a child of another item that belongs to the model, this
1426   function returns 0.
1427 
1428   \sa index()
1429 */
1430 QStandardItemModel *QStandardItem::model() const
1431 {
1432     Q_D(const QStandardItem);
1433     return d->model;
1434 }
1435 
1436 /*!
1437     Sets the number of child item rows to \a rows. If this is less than
1438     rowCount(), the data in the unwanted rows is discarded.
1439 
1440     \sa rowCount(), setColumnCount()
1441 */
1442 void QStandardItem::setRowCount(int rows)
1443 {
1444     int rc = rowCount();
1445     if (rc == rows)
1446         return;
1447     if (rc < rows)
1448         insertRows(qMax(rc, 0), rows - rc);
1449     else
1450         removeRows(qMax(rows, 0), rc - rows);
1451 }
1452 
1453 /*!
1454     Returns the number of child item rows that the item has.
1455 
1456     \sa setRowCount(), columnCount()
1457 */
1458 int QStandardItem::rowCount() const
1459 {
1460     Q_D(const QStandardItem);
1461     return d->rowCount();
1462 }
1463 
1464 /*!
1465     Sets the number of child item columns to \a columns. If this is less than
1466     columnCount(), the data in the unwanted columns is discarded.
1467 
1468     \sa columnCount(), setRowCount()
1469 */
1470 void QStandardItem::setColumnCount(int columns)
1471 {
1472     int cc = columnCount();
1473     if (cc == columns)
1474         return;
1475     if (cc < columns)
1476         insertColumns(qMax(cc, 0), columns - cc);
1477     else
1478         removeColumns(qMax(columns, 0), cc - columns);
1479 }
1480 
1481 /*!
1482     Returns the number of child item columns that the item has.
1483 
1484     \sa setColumnCount(), rowCount()
1485 */
1486 int QStandardItem::columnCount() const
1487 {
1488     Q_D(const QStandardItem);
1489     return d->columnCount();
1490 }
1491 
1492 /*!
1493     Inserts a row at \a row containing \a items. If necessary, the column
1494     count is increased to the size of \a items.
1495 
1496     \sa insertRows(), insertColumn()
1497 */
1498 void QStandardItem::insertRow(int row, const QList<QStandardItem*> &items)
1499 {
1500     Q_D(QStandardItem);
1501     if (row < 0)
1502         return;
1503     if (columnCount() < items.count())
1504         setColumnCount(items.count());
1505     d->insertRows(row, 1, items);
1506 }
1507 
1508 /*!
1509     Inserts \a items at \a row. The column count won't be changed.
1510 
1511     \sa insertRow(), insertColumn()
1512 */
1513 void QStandardItem::insertRows(int row, const QList<QStandardItem*> &items)
1514 {
1515     Q_D(QStandardItem);
1516     if (row < 0)
1517         return;
1518     d->insertRows(row, items);
1519 }
1520 
1521 /*!
1522     Inserts a column at \a column containing \a items. If necessary,
1523     the row count is increased to the size of \a items.
1524 
1525     \sa insertColumns(), insertRow()
1526 */
1527 void QStandardItem::insertColumn(int column, const QList<QStandardItem*> &items)
1528 {
1529     Q_D(QStandardItem);
1530     if (column < 0)
1531         return;
1532     if (rowCount() < items.count())
1533         setRowCount(items.count());
1534     d->insertColumns(column, 1, items);
1535 }
1536 
1537 /*!
1538     Inserts \a count rows of child items at row \a row.
1539 
1540     \sa insertRow(), insertColumns()
1541 */
1542 void QStandardItem::insertRows(int row, int count)
1543 {
1544     Q_D(QStandardItem);
1545     if (rowCount() < row) {
1546         count += row - rowCount();
1547         row = rowCount();
1548     }
1549     d->insertRows(row, count, QList<QStandardItem*>());
1550 }
1551 
1552 /*!
1553     Inserts \a count columns of child items at column \a column.
1554 
1555     \sa insertColumn(), insertRows()
1556 */
1557 void QStandardItem::insertColumns(int column, int count)
1558 {
1559     Q_D(QStandardItem);
1560     if (columnCount() < column) {
1561         count += column - columnCount();
1562         column = columnCount();
1563     }
1564     d->insertColumns(column, count, QList<QStandardItem*>());
1565 }
1566 
1567 /*!
1568     \fn void QStandardItem::appendRow(const QList<QStandardItem*> &items)
1569 
1570     Appends a row containing \a items. If necessary, the column count is
1571     increased to the size of \a items.
1572 
1573     \sa insertRow()
1574 */
1575 
1576 /*!
1577     \fn void QStandardItem::appendRows(const QList<QStandardItem*> &items)
1578 
1579     Appends rows containing \a items.  The column count will not change.
1580 
1581     \sa insertRow()
1582 */
1583 
1584 /*!
1585     \fn void QStandardItem::appendColumn(const QList<QStandardItem*> &items)
1586 
1587     Appends a column containing \a items. If necessary, the row count is
1588     increased to the size of \a items.
1589 
1590     \sa insertColumn()
1591 */
1592 
1593 /*!
1594     \fn bool QStandardItemModel::insertRow(int row, const QModelIndex &parent)
1595 
1596     Inserts a single row before the given \a row in the child items of the
1597     \a parent specified. Returns \c true if the row is inserted; otherwise
1598     returns \c false.
1599 
1600     \sa insertRows(), insertColumn(), removeRow()
1601 */
1602 
1603 /*!
1604     \fn bool QStandardItemModel::insertColumn(int column, const QModelIndex &parent)
1605 
1606     Inserts a single column before the given \a column in the child items of
1607     the \a parent specified. Returns \c true if the column is inserted; otherwise
1608     returns \c false.
1609 
1610     \sa insertColumns(), insertRow(), removeColumn()
1611 */
1612 
1613 /*!
1614     \fn QStandardItem::insertRow(int row, QStandardItem *item)
1615     \overload
1616 
1617     Inserts a row at \a row containing \a item.
1618 
1619     When building a list or a tree that has only one column, this function
1620     provides a convenient way to insert a single new item.
1621 */
1622 
1623 /*!
1624     \fn QStandardItem::appendRow(QStandardItem *item)
1625     \overload
1626 
1627     Appends a row containing \a item.
1628 
1629     When building a list or a tree that has only one column, this function
1630     provides a convenient way to append a single new item.
1631 */
1632 
1633 /*!
1634     Removes the given \a row. The items that were in the row are deleted.
1635 
1636     \sa takeRow(), removeRows(), removeColumn()
1637 */
1638 void QStandardItem::removeRow(int row)
1639 {
1640     removeRows(row, 1);
1641 }
1642 
1643 /*!
1644     Removes the given \a column. The items that were in the
1645     column are deleted.
1646 
1647     \sa takeColumn(), removeColumns(), removeRow()
1648 */
1649 void QStandardItem::removeColumn(int column)
1650 {
1651     removeColumns(column, 1);
1652 }
1653 
1654 /*!
1655     Removes \a count rows at row \a row. The items that were in those rows are
1656     deleted.
1657 
1658     \sa removeRow(), removeColumn()
1659 */
1660 void QStandardItem::removeRows(int row, int count)
1661 {
1662     Q_D(QStandardItem);
1663     if ((count < 1) || (row < 0) || ((row + count) > rowCount()))
1664         return;
1665     if (d->model)
1666         d->model->d_func()->rowsAboutToBeRemoved(this, row, row + count - 1);
1667     int i = d->childIndex(row, 0);
1668     int n = count * d->columnCount();
1669     for (int j = i; j < n+i; ++j) {
1670         QStandardItem *oldItem = d->children.at(j);
1671         if (oldItem)
1672             oldItem->d_func()->setModel(0);
1673         delete oldItem;
1674     }
1675     d->children.remove(qMax(i, 0), n);
1676     d->rows -= count;
1677     if (d->model)
1678         d->model->d_func()->rowsRemoved(this, row, count);
1679 }
1680 
1681 /*!
1682     Removes \a count columns at column \a column. The items that were in those
1683     columns are deleted.
1684 
1685     \sa removeColumn(), removeRows()
1686 */
1687 void QStandardItem::removeColumns(int column, int count)
1688 {
1689     Q_D(QStandardItem);
1690     if ((count < 1) || (column < 0) || ((column + count) > columnCount()))
1691         return;
1692     if (d->model)
1693         d->model->d_func()->columnsAboutToBeRemoved(this, column, column + count - 1);
1694     for (int row = d->rowCount() - 1; row >= 0; --row) {
1695         int i = d->childIndex(row, column);
1696         for (int j=i; j<i+count; ++j) {
1697             QStandardItem *oldItem = d->children.at(j);
1698             if (oldItem)
1699                 oldItem->d_func()->setModel(0);
1700             delete oldItem;
1701         }
1702         d->children.remove(i, count);
1703     }
1704     d->columns -= count;
1705     if (d->model)
1706         d->model->d_func()->columnsRemoved(this, column, count);
1707 }
1708 
1709 /*!
1710     Returns \c true if this item has any children; otherwise returns \c false.
1711 
1712     \sa rowCount(), columnCount(), child()
1713 */
1714 bool QStandardItem::hasChildren() const
1715 {
1716     return (rowCount() > 0) && (columnCount() > 0);
1717 }
1718 
1719 /*!
1720     Sets the child item at (\a row, \a column) to \a item. This item (the parent
1721     item) takes ownership of \a item. If necessary, the row count and column
1722     count are increased to fit the item.
1723 
1724     \note Passing a null pointer to \a item clears the item.
1725 
1726     \sa child()
1727 */
1728 void QStandardItem::setChild(int row, int column, QStandardItem *item)
1729 {
1730     Q_D(QStandardItem);
1731     d->setChild(row, column, item, true);
1732 }
1733 
1734 /*!
1735     \fn QStandardItem::setChild(int row, QStandardItem *item)
1736     \overload
1737 
1738     Sets the child at \a row to \a item.
1739 */
1740 
1741 /*!
1742     Returns the child item at (\a row, \a column) if one has been set; otherwise
1743     returns 0.
1744 
1745     \sa setChild(), takeChild(), parent()
1746 */
1747 QStandardItem *QStandardItem::child(int row, int column) const
1748 {
1749     Q_D(const QStandardItem);
1750     int index = d->childIndex(row, column);
1751     if (index == -1)
1752         return 0;
1753     return d->children.at(index);
1754 }
1755 
1756 /*!
1757     Removes the child item at (\a row, \a column) without deleting it, and returns
1758     a pointer to the item. If there was no child at the given location, then
1759     this function returns 0.
1760 
1761     Note that this function, unlike takeRow() and takeColumn(), does not affect
1762     the dimensions of the child table.
1763 
1764     \sa child(), takeRow(), takeColumn()
1765 */
1766 QStandardItem *QStandardItem::takeChild(int row, int column)
1767 {
1768     Q_D(QStandardItem);
1769     QStandardItem *item = 0;
1770     int index = d->childIndex(row, column);
1771     if (index != -1) {
1772         item = d->children.at(index);
1773         if (item)
1774             item->d_func()->setParentAndModel(0, 0);
1775         d->children.replace(index, 0);
1776     }
1777     return item;
1778 }
1779 
1780 /*!
1781     Removes \a row without deleting the row items, and returns a list of
1782     pointers to the removed items. For items in the row that have not been
1783     set, the corresponding pointers in the list will be 0.
1784 
1785     \sa removeRow(), insertRow(), takeColumn()
1786 */
1787 QList<QStandardItem*> QStandardItem::takeRow(int row)
1788 {
1789     Q_D(QStandardItem);
1790     QList<QStandardItem*> items;
1791     if ((row < 0) || (row >= rowCount()))
1792         return items;
1793     if (d->model)
1794         d->model->d_func()->rowsAboutToBeRemoved(this, row, row);
1795 
1796     int index = d->childIndex(row, 0);  // Will return -1 if there are no columns
1797     if (index != -1) {
1798         int col_count = d->columnCount();
1799         items.reserve(col_count);
1800         for (int column = 0; column < col_count; ++column) {
1801             QStandardItem *ch = d->children.at(index + column);
1802             if (ch)
1803                 ch->d_func()->setParentAndModel(0, 0);
1804             items.append(ch);
1805         }
1806         d->children.remove(index, col_count);
1807     }
1808     d->rows--;
1809     if (d->model)
1810         d->model->d_func()->rowsRemoved(this, row, 1);
1811     return items;
1812 }
1813 
1814 /*!
1815     Removes \a column without deleting the column items, and returns a list of
1816     pointers to the removed items. For items in the column that have not been
1817     set, the corresponding pointers in the list will be 0.
1818 
1819     \sa removeColumn(), insertColumn(), takeRow()
1820 */
1821 QList<QStandardItem*> QStandardItem::takeColumn(int column)
1822 {
1823     Q_D(QStandardItem);
1824     QList<QStandardItem*> items;
1825     if ((column < 0) || (column >= columnCount()))
1826         return items;
1827     if (d->model)
1828         d->model->d_func()->columnsAboutToBeRemoved(this, column, column);
1829 
1830     const int rowCount = d->rowCount();
1831     items.reserve(rowCount);
1832     for (int row = rowCount - 1; row >= 0; --row) {
1833         int index = d->childIndex(row, column);
1834         QStandardItem *ch = d->children.at(index);
1835         if (ch)
1836             ch->d_func()->setParentAndModel(0, 0);
1837         d->children.remove(index);
1838         items.prepend(ch);
1839     }
1840     d->columns--;
1841     if (d->model)
1842         d->model->d_func()->columnsRemoved(this, column, 1);
1843     return items;
1844 }
1845 
1846 /*!
1847     Returns \c true if this item is less than \a other; otherwise returns \c false.
1848 
1849     The default implementation uses the data for the item's sort role (see
1850     QStandardItemModel::sortRole) to perform the comparison if the item
1851     belongs to a model; otherwise, the data for the item's Qt::DisplayRole
1852     (text()) is used to perform the comparison.
1853 
1854     sortChildren() and QStandardItemModel::sort() use this function when
1855     sorting items. If you want custom sorting, you can subclass QStandardItem
1856     and reimplement this function.
1857 */
1858 bool QStandardItem::operator<(const QStandardItem &other) const
1859 {
1860     const int role = model() ? model()->sortRole() : Qt::DisplayRole;
1861     const QVariant l = data(role), r = other.data(role);
1862     return QAbstractItemModelPrivate::isVariantLessThan(l, r);
1863 }
1864 
1865 /*!
1866     Sorts the children of the item using the given \a order, by the values in
1867     the given \a column.
1868 
1869     \note This function is recursive, therefore it sorts the children of the
1870     item, its grandchildren, etc.
1871 
1872     \sa {operator<()}
1873 */
1874 void QStandardItem::sortChildren(int column, Qt::SortOrder order)
1875 {
1876     Q_D(QStandardItem);
1877     if ((column < 0) || (rowCount() == 0))
1878         return;
1879 
1880     QList<QPersistentModelIndex> parents;
1881     if (d->model) {
1882         parents << index();
1883         emit d->model->layoutAboutToBeChanged(parents, QAbstractItemModel::VerticalSortHint);
1884     }
1885     d->sortChildren(column, order);
1886     if (d->model)
1887         emit d->model->layoutChanged(parents, QAbstractItemModel::VerticalSortHint);
1888 }
1889 
1890 /*!
1891     Returns a copy of this item. The item's children are not copied.
1892 
1893     When subclassing QStandardItem, you can reimplement this function
1894     to provide QStandardItemModel with a factory that it can use to
1895     create new items on demand.
1896 
1897     \sa QStandardItemModel::setItemPrototype(), operator=()
1898 */
1899 QStandardItem *QStandardItem::clone() const
1900 {
1901     return new QStandardItem(*this);
1902 }
1903 
1904 /*!
1905     Returns the type of this item. The type is used to distinguish custom
1906     items from the base class. When subclassing QStandardItem, you should
1907     reimplement this function and return a new value greater than or equal
1908     to \l UserType.
1909 
1910     \sa QStandardItem::Type
1911 */
1912 int QStandardItem::type() const
1913 {
1914     return Type;
1915 }
1916 
1917 #ifndef QT_NO_DATASTREAM
1918 
1919 /*!
1920     Reads the item from stream \a in. Only the data and flags of the item are
1921     read, not the child items.
1922 
1923     \sa write()
1924 */
1925 void QStandardItem::read(QDataStream &in)
1926 {
1927     Q_D(QStandardItem);
1928     in >> d->values;
1929     qint32 flags;
1930     in >> flags;
1931     setFlags(Qt::ItemFlags(flags));
1932 }
1933 
1934 /*!
1935     Writes the item to stream \a out. Only the data and flags of the item
1936     are written, not the child items.
1937 
1938     \sa read()
1939 */
1940 void QStandardItem::write(QDataStream &out) const
1941 {
1942     Q_D(const QStandardItem);
1943     out << d->values;
1944     out << flags();
1945 }
1946 
1947 /*!
1948     \relates QStandardItem
1949     \since 4.2
1950 
1951     Reads a QStandardItem from stream \a in into \a item.
1952 
1953     This operator uses QStandardItem::read().
1954 
1955     \sa {Serializing Qt Data Types}
1956 */
1957 QDataStream &operator>>(QDataStream &in, QStandardItem &item)
1958 {
1959     item.read(in);
1960     return in;
1961 }
1962 
1963 /*!
1964     \relates QStandardItem
1965     \since 4.2
1966 
1967     Writes the QStandardItem \a item to stream \a out.
1968 
1969     This operator uses QStandardItem::write().
1970 
1971     \sa {Serializing Qt Data Types}
1972 */
1973 QDataStream &operator<<(QDataStream &out, const QStandardItem &item)
1974 {
1975     item.write(out);
1976     return out;
1977 }
1978 
1979 #endif // QT_NO_DATASTREAM
1980 
1981 /*!
1982     \class QStandardItemModel
1983     \brief The QStandardItemModel class provides a generic model for storing custom data.
1984     \ingroup model-view
1985     \inmodule QtGui
1986 
1987     QStandardItemModel can be used as a repository for standard Qt
1988     data types. It is one of the \l {Model/View Classes} and is part
1989     of Qt's \l {Model/View Programming}{model/view} framework.
1990 
1991     QStandardItemModel provides a classic item-based approach to working with
1992     the model.  The items in a QStandardItemModel are provided by
1993     QStandardItem.
1994 
1995     QStandardItemModel implements the QAbstractItemModel interface, which
1996     means that the model can be used to provide data in any view that supports
1997     that interface (such as QListView, QTableView and QTreeView, and your own
1998     custom views). For performance and flexibility, you may want to subclass
1999     QAbstractItemModel to provide support for different kinds of data
2000     repositories. For example, the QDirModel provides a model interface to the
2001     underlying file system.
2002 
2003     When you want a list or tree, you typically create an empty
2004     QStandardItemModel and use appendRow() to add items to the model, and
2005     item() to access an item.  If your model represents a table, you typically
2006     pass the dimensions of the table to the QStandardItemModel constructor and
2007     use setItem() to position items into the table. You can also use setRowCount()
2008     and setColumnCount() to alter the dimensions of the model. To insert items,
2009     use insertRow() or insertColumn(), and to remove items, use removeRow() or
2010     removeColumn().
2011 
2012     You can set the header labels of your model with setHorizontalHeaderLabels()
2013     and setVerticalHeaderLabels().
2014 
2015     You can search for items in the model with findItems(), and sort the model by
2016     calling sort().
2017 
2018     Call clear() to remove all items from the model.
2019 
2020     An example usage of QStandardItemModel to create a table:
2021 
2022     \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 0
2023 
2024     An example usage of QStandardItemModel to create a tree:
2025 
2026     \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 1
2027 
2028     After setting the model on a view, you typically want to react to user
2029     actions, such as an item being clicked. Since a QAbstractItemView provides
2030     QModelIndex-based signals and functions, you need a way to obtain the
2031     QStandardItem that corresponds to a given QModelIndex, and vice
2032     versa. itemFromIndex() and indexFromItem() provide this mapping. Typical
2033     usage of itemFromIndex() includes obtaining the item at the current index
2034     in a view, and obtaining the item that corresponds to an index carried by
2035     a QAbstractItemView signal, such as QAbstractItemView::clicked(). First
2036     you connect the view's signal to a slot in your class:
2037 
2038     \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 2
2039 
2040     When you receive the signal, you call itemFromIndex() on the given model
2041     index to get a pointer to the item:
2042 
2043     \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 3
2044 
2045     Conversely, you must obtain the QModelIndex of an item when you want to
2046     invoke a model/view function that takes an index as argument. You can
2047     obtain the index either by using the model's indexFromItem() function, or,
2048     equivalently, by calling QStandardItem::index():
2049 
2050     \snippet code/src_gui_itemviews_qstandarditemmodel.cpp 4
2051 
2052     You are, of course, not required to use the item-based approach; you could
2053     instead rely entirely on the QAbstractItemModel interface when working with
2054     the model, or use a combination of the two as appropriate.
2055 
2056     \sa QStandardItem, {Model/View Programming}, QAbstractItemModel,
2057     {itemviews/simpletreemodel}{Simple Tree Model example},
2058     {Item View Convenience Classes}
2059 */
2060 
2061 /*!
2062     \fn void QStandardItemModel::itemChanged(QStandardItem *item)
2063     \since 4.2
2064 
2065     This signal is emitted whenever the data of \a item has changed.
2066 */
2067 
2068 /*!
2069     Constructs a new item model with the given \a parent.
2070 */
2071 QStandardItemModel::QStandardItemModel(QObject *parent)
2072     : QAbstractItemModel(*new QStandardItemModelPrivate, parent)
2073 {
2074     Q_D(QStandardItemModel);
2075     d->init();
2076     d->root->d_func()->setModel(this);
2077 }
2078 
2079 /*!
2080     Constructs a new item model that initially has \a rows rows and \a columns
2081     columns, and that has the given \a parent.
2082 */
2083 QStandardItemModel::QStandardItemModel(int rows, int columns, QObject *parent)
2084     : QAbstractItemModel(*new QStandardItemModelPrivate, parent)
2085 {
2086     Q_D(QStandardItemModel);
2087     d->init();
2088     d->root->insertColumns(0, columns);
2089     d->columnHeaderItems.insert(0, columns, 0);
2090     d->root->insertRows(0, rows);
2091     d->rowHeaderItems.insert(0, rows, 0);
2092     d->root->d_func()->setModel(this);
2093 }
2094 
2095 /*!
2096   \internal
2097 */
2098 QStandardItemModel::QStandardItemModel(QStandardItemModelPrivate &dd, QObject *parent)
2099     : QAbstractItemModel(dd, parent)
2100 {
2101     Q_D(QStandardItemModel);
2102     d->init();
2103 }
2104 
2105 /*!
2106     Destructs the model. The model destroys all its items.
2107 */
2108 QStandardItemModel::~QStandardItemModel()
2109 {
2110     Q_D(QStandardItemModel);
2111     delete d->itemPrototype;
2112     qDeleteAll(d->columnHeaderItems);
2113     qDeleteAll(d->rowHeaderItems);
2114     d->root.reset();
2115 }
2116 
2117 /*!
2118     Sets the item role names to \a roleNames.
2119 */
2120 void QStandardItemModel::setItemRoleNames(const QHash<int,QByteArray> &roleNames)
2121 {
2122     Q_D(QStandardItemModel);
2123     d->roleNames = roleNames;
2124 }
2125 
2126 /*!
2127     Removes all items (including header items) from the model and sets the
2128     number of rows and columns to zero.
2129 
2130     \sa removeColumns(), removeRows()
2131 */
2132 void QStandardItemModel::clear()
2133 {
2134     Q_D(QStandardItemModel);
2135     beginResetModel();
2136     d->root.reset(new QStandardItem);
2137     d->root->setFlags(Qt::ItemIsDropEnabled);
2138     d->root->d_func()->setModel(this);
2139     qDeleteAll(d->columnHeaderItems);
2140     d->columnHeaderItems.clear();
2141     qDeleteAll(d->rowHeaderItems);
2142     d->rowHeaderItems.clear();
2143     endResetModel();
2144 }
2145 
2146 /*!
2147     \since 4.2
2148 
2149     Returns a pointer to the QStandardItem associated with the given \a index.
2150 
2151     Calling this function is typically the initial step when processing
2152     QModelIndex-based signals from a view, such as
2153     QAbstractItemView::activated(). In your slot, you call itemFromIndex(),
2154     with the QModelIndex carried by the signal as argument, to obtain a
2155     pointer to the corresponding QStandardItem.
2156 
2157     Note that this function will lazily create an item for the index (using
2158     itemPrototype()), and set it in the parent item's child table, if no item
2159     already exists at that index.
2160 
2161     If \a index is an invalid index, this function returns 0.
2162 
2163     \sa indexFromItem()
2164 */
2165 QStandardItem *QStandardItemModel::itemFromIndex(const QModelIndex &index) const
2166 {
2167     Q_D(const QStandardItemModel);
2168     if ((index.row() < 0) || (index.column() < 0) || (index.model() != this))
2169         return 0;
2170     QStandardItem *parent = static_cast<QStandardItem*>(index.internalPointer());
2171     if (parent == 0)
2172         return 0;
2173     QStandardItem *item = parent->child(index.row(), index.column());
2174     // lazy part
2175     if (item == 0) {
2176         item = d->createItem();
2177         parent->d_func()->setChild(index.row(), index.column(), item);
2178     }
2179     return item;
2180 }
2181 
2182 /*!
2183     \since 4.2
2184 
2185     Returns the QModelIndex associated with the given \a item.
2186 
2187     Use this function when you want to perform an operation that requires the
2188     QModelIndex of the item, such as
2189     QAbstractItemView::scrollTo(). QStandardItem::index() is provided as
2190     convenience; it is equivalent to calling this function.
2191 
2192     \sa itemFromIndex(), QStandardItem::index()
2193 */
2194 QModelIndex QStandardItemModel::indexFromItem(const QStandardItem *item) const
2195 {
2196     if (item && item->d_func()->parent) {
2197         QPair<int, int> pos = item->d_func()->position();
2198         return createIndex(pos.first, pos.second, item->d_func()->parent);
2199     }
2200     return QModelIndex();
2201 }
2202 
2203 /*!
2204     \since 4.2
2205 
2206     Sets the number of rows in this model to \a rows. If
2207     this is less than rowCount(), the data in the unwanted rows
2208     is discarded.
2209 
2210     \sa setColumnCount()
2211 */
2212 void QStandardItemModel::setRowCount(int rows)
2213 {
2214     Q_D(QStandardItemModel);
2215     d->root->setRowCount(rows);
2216 }
2217 
2218 /*!
2219     \since 4.2
2220 
2221     Sets the number of columns in this model to \a columns. If
2222     this is less than columnCount(), the data in the unwanted columns
2223     is discarded.
2224 
2225     \sa setRowCount()
2226 */
2227 void QStandardItemModel::setColumnCount(int columns)
2228 {
2229     Q_D(QStandardItemModel);
2230     d->root->setColumnCount(columns);
2231 }
2232 
2233 /*!
2234     \since 4.2
2235 
2236     Sets the item for the given \a row and \a column to \a item. The model
2237     takes ownership of the item. If necessary, the row count and column count
2238     are increased to fit the item. The previous item at the given location (if
2239     there was one) is deleted.
2240 
2241     \sa item()
2242 */
2243 void QStandardItemModel::setItem(int row, int column, QStandardItem *item)
2244 {
2245     Q_D(QStandardItemModel);
2246     d->root->d_func()->setChild(row, column, item, true);
2247 }
2248 
2249 /*!
2250   \fn QStandardItemModel::setItem(int row, QStandardItem *item)
2251   \overload
2252 */
2253 
2254 /*!
2255     \since 4.2
2256 
2257     Returns the item for the given \a row and \a column if one has been set;
2258     otherwise returns 0.
2259 
2260     \sa setItem(), takeItem(), itemFromIndex()
2261 */
2262 QStandardItem *QStandardItemModel::item(int row, int column) const
2263 {
2264     Q_D(const QStandardItemModel);
2265     return d->root->child(row, column);
2266 }
2267 
2268 /*!
2269     \since 4.2
2270 
2271     Returns the model's invisible root item.
2272 
2273     The invisible root item provides access to the model's top-level items
2274     through the QStandardItem API, making it possible to write functions that
2275     can treat top-level items and their children in a uniform way; for
2276     example, recursive functions involving a tree model.
2277 
2278     \note Calling \l{QAbstractItemModel::index()}{index()} on the QStandardItem object
2279     retrieved from this function is not valid.
2280 */
2281 QStandardItem *QStandardItemModel::invisibleRootItem() const
2282 {
2283     Q_D(const QStandardItemModel);
2284     return d->root.data();
2285 }
2286 
2287 /*!
2288     \since 4.2
2289 
2290     Sets the horizontal header item for \a column to \a item.  The model takes
2291     ownership of the item. If necessary, the column count is increased to fit
2292     the item. The previous header item (if there was one) is deleted.
2293 
2294     \sa horizontalHeaderItem(), setHorizontalHeaderLabels(),
2295     setVerticalHeaderItem()
2296 */
2297 void QStandardItemModel::setHorizontalHeaderItem(int column, QStandardItem *item)
2298 {
2299     Q_D(QStandardItemModel);
2300     if (column < 0)
2301         return;
2302     if (columnCount() <= column)
2303         setColumnCount(column + 1);
2304 
2305     QStandardItem *oldItem = d->columnHeaderItems.at(column);
2306     if (item == oldItem)
2307         return;
2308 
2309     if (item) {
2310         if (item->model() == 0) {
2311             item->d_func()->setModel(this);
2312         } else {
2313             qWarning("QStandardItem::setHorizontalHeaderItem: Ignoring duplicate insertion of item %p",
2314                      item);
2315             return;
2316         }
2317     }
2318 
2319     if (oldItem)
2320         oldItem->d_func()->setModel(0);
2321     delete oldItem;
2322 
2323     d->columnHeaderItems.replace(column, item);
2324     emit headerDataChanged(Qt::Horizontal, column, column);
2325 }
2326 
2327 /*!
2328     \since 4.2
2329 
2330     Returns the horizontal header item for \a column if one has been set;
2331     otherwise returns 0.
2332 
2333     \sa setHorizontalHeaderItem(), verticalHeaderItem()
2334 */
2335 QStandardItem *QStandardItemModel::horizontalHeaderItem(int column) const
2336 {
2337     Q_D(const QStandardItemModel);
2338     if ((column < 0) || (column >= columnCount()))
2339         return 0;
2340     return d->columnHeaderItems.at(column);
2341 }
2342 
2343 /*!
2344     \since 4.2
2345 
2346     Sets the vertical header item for \a row to \a item.  The model takes
2347     ownership of the item. If necessary, the row count is increased to fit the
2348     item. The previous header item (if there was one) is deleted.
2349 
2350     \sa verticalHeaderItem(), setVerticalHeaderLabels(),
2351     setHorizontalHeaderItem()
2352 */
2353 void QStandardItemModel::setVerticalHeaderItem(int row, QStandardItem *item)
2354 {
2355     Q_D(QStandardItemModel);
2356     if (row < 0)
2357         return;
2358     if (rowCount() <= row)
2359         setRowCount(row + 1);
2360 
2361     QStandardItem *oldItem = d->rowHeaderItems.at(row);
2362     if (item == oldItem)
2363         return;
2364 
2365     if (item) {
2366         if (item->model() == 0) {
2367             item->d_func()->setModel(this);
2368         } else {
2369             qWarning("QStandardItem::setVerticalHeaderItem: Ignoring duplicate insertion of item %p",
2370                      item);
2371             return;
2372         }
2373     }
2374 
2375     if (oldItem)
2376         oldItem->d_func()->setModel(0);
2377     delete oldItem;
2378 
2379     d->rowHeaderItems.replace(row, item);
2380     emit headerDataChanged(Qt::Vertical, row, row);
2381 }
2382 
2383 /*!
2384     \since 4.2
2385 
2386     Returns the vertical header item for row \a row if one has been set;
2387     otherwise returns 0.
2388 
2389     \sa setVerticalHeaderItem(), horizontalHeaderItem()
2390 */
2391 QStandardItem *QStandardItemModel::verticalHeaderItem(int row) const
2392 {
2393     Q_D(const QStandardItemModel);
2394     if ((row < 0) || (row >= rowCount()))
2395         return 0;
2396     return d->rowHeaderItems.at(row);
2397 }
2398 
2399 /*!
2400     \since 4.2
2401 
2402     Sets the horizontal header labels using \a labels. If necessary, the
2403     column count is increased to the size of \a labels.
2404 
2405     \sa setHorizontalHeaderItem()
2406 */
2407 void QStandardItemModel::setHorizontalHeaderLabels(const QStringList &labels)
2408 {
2409     Q_D(QStandardItemModel);
2410     if (columnCount() < labels.count())
2411         setColumnCount(labels.count());
2412     for (int i = 0; i < labels.count(); ++i) {
2413         QStandardItem *item = horizontalHeaderItem(i);
2414         if (!item) {
2415             item = d->createItem();
2416             setHorizontalHeaderItem(i, item);
2417         }
2418         item->setText(labels.at(i));
2419     }
2420 }
2421 
2422 /*!
2423     \since 4.2
2424 
2425     Sets the vertical header labels using \a labels. If necessary, the row
2426     count is increased to the size of \a labels.
2427 
2428     \sa setVerticalHeaderItem()
2429 */
2430 void QStandardItemModel::setVerticalHeaderLabels(const QStringList &labels)
2431 {
2432     Q_D(QStandardItemModel);
2433     if (rowCount() < labels.count())
2434         setRowCount(labels.count());
2435     for (int i = 0; i < labels.count(); ++i) {
2436         QStandardItem *item = verticalHeaderItem(i);
2437         if (!item) {
2438             item = d->createItem();
2439             setVerticalHeaderItem(i, item);
2440         }
2441         item->setText(labels.at(i));
2442     }
2443 }
2444 
2445 /*!
2446     \since 4.2
2447 
2448     Sets the item prototype for the model to the specified \a item. The model
2449     takes ownership of the prototype.
2450 
2451     The item prototype acts as a QStandardItem factory, by relying on the
2452     QStandardItem::clone() function.  To provide your own prototype, subclass
2453     QStandardItem, reimplement QStandardItem::clone() and set the prototype to
2454     be an instance of your custom class. Whenever QStandardItemModel needs to
2455     create an item on demand (for instance, when a view or item delegate calls
2456     setData())), the new items will be instances of your custom class.
2457 
2458     \sa itemPrototype(), QStandardItem::clone()
2459 */
2460 void QStandardItemModel::setItemPrototype(const QStandardItem *item)
2461 {
2462     Q_D(QStandardItemModel);
2463     if (d->itemPrototype != item) {
2464         delete d->itemPrototype;
2465         d->itemPrototype = item;
2466     }
2467 }
2468 
2469 /*!
2470     \since 4.2
2471 
2472     Returns the item prototype used by the model. The model uses the item
2473     prototype as an item factory when it needs to construct new items on
2474     demand (for instance, when a view or item delegate calls setData()).
2475 
2476     \sa setItemPrototype()
2477 */
2478 const QStandardItem *QStandardItemModel::itemPrototype() const
2479 {
2480     Q_D(const QStandardItemModel);
2481     return d->itemPrototype;
2482 }
2483 
2484 /*!
2485     \since 4.2
2486 
2487     Returns a list of items that match the given \a text, using the given \a
2488     flags, in the given \a column.
2489 */
2490 QList<QStandardItem*> QStandardItemModel::findItems(const QString &text,
2491                                                     Qt::MatchFlags flags, int column) const
2492 {
2493     QModelIndexList indexes = match(index(0, column, QModelIndex()),
2494                                     Qt::DisplayRole, text, -1, flags);
2495     QList<QStandardItem*> items;
2496     const int numIndexes = indexes.size();
2497     items.reserve(numIndexes);
2498     for (int i = 0; i < numIndexes; ++i)
2499         items.append(itemFromIndex(indexes.at(i)));
2500     return items;
2501 }
2502 
2503 /*!
2504     \since 4.2
2505 
2506     Appends a row containing \a items. If necessary, the column count is
2507     increased to the size of \a items.
2508 
2509     \sa insertRow(), appendColumn()
2510 */
2511 void QStandardItemModel::appendRow(const QList<QStandardItem*> &items)
2512 {
2513     invisibleRootItem()->appendRow(items);
2514 }
2515 
2516 /*!
2517     \since 4.2
2518 
2519     Appends a column containing \a items. If necessary, the row count is
2520     increased to the size of \a items.
2521 
2522     \sa insertColumn(), appendRow()
2523 */
2524 void QStandardItemModel::appendColumn(const QList<QStandardItem*> &items)
2525 {
2526     invisibleRootItem()->appendColumn(items);
2527 }
2528 
2529 /*!
2530     \since 4.2
2531     \fn QStandardItemModel::appendRow(QStandardItem *item)
2532     \overload
2533 
2534     When building a list or a tree that has only one column, this function
2535     provides a convenient way to append a single new \a item.
2536 */
2537 
2538 /*!
2539     \since 4.2
2540 
2541     Inserts a row at \a row containing \a items. If necessary, the column
2542     count is increased to the size of \a items.
2543 
2544     \sa takeRow(), appendRow(), insertColumn()
2545 */
2546 void QStandardItemModel::insertRow(int row, const QList<QStandardItem*> &items)
2547 {
2548     invisibleRootItem()->insertRow(row, items);
2549 }
2550 
2551 /*!
2552     \since 4.2
2553 
2554     \fn void QStandardItemModel::insertRow(int row, QStandardItem *item)
2555     \overload
2556 
2557     Inserts a row at \a row containing \a item.
2558 
2559     When building a list or a tree that has only one column, this function
2560     provides a convenient way to append a single new item.
2561 */
2562 
2563 /*!
2564     \since 4.2
2565 
2566     Inserts a column at \a column containing \a items. If necessary, the row
2567     count is increased to the size of \a items.
2568 
2569     \sa takeColumn(), appendColumn(), insertRow()
2570 */
2571 void QStandardItemModel::insertColumn(int column, const QList<QStandardItem*> &items)
2572 {
2573     invisibleRootItem()->insertColumn(column, items);
2574 }
2575 
2576 /*!
2577     \since 4.2
2578 
2579     Removes the item at (\a row, \a column) without deleting it. The model
2580     releases ownership of the item.
2581 
2582     \sa item(), takeRow(), takeColumn()
2583 */
2584 QStandardItem *QStandardItemModel::takeItem(int row, int column)
2585 {
2586     Q_D(QStandardItemModel);
2587     return d->root->takeChild(row, column);
2588 }
2589 
2590 /*!
2591     \since 4.2
2592 
2593     Removes the given \a row without deleting the row items, and returns a
2594     list of pointers to the removed items. The model releases ownership of the
2595     items. For items in the row that have not been set, the corresponding
2596     pointers in the list will be 0.
2597 
2598     \sa takeColumn()
2599 */
2600 QList<QStandardItem*> QStandardItemModel::takeRow(int row)
2601 {
2602     Q_D(QStandardItemModel);
2603     return d->root->takeRow(row);
2604 }
2605 
2606 /*!
2607     \since 4.2
2608 
2609     Removes the given \a column without deleting the column items, and returns
2610     a list of pointers to the removed items. The model releases ownership of
2611     the items. For items in the column that have not been set, the
2612     corresponding pointers in the list will be 0.
2613 
2614     \sa takeRow()
2615 */
2616 QList<QStandardItem*> QStandardItemModel::takeColumn(int column)
2617 {
2618     Q_D(QStandardItemModel);
2619     return d->root->takeColumn(column);
2620 }
2621 
2622 /*!
2623     \since 4.2
2624 
2625     Removes the horizontal header item at \a column from the header without
2626     deleting it, and returns a pointer to the item. The model releases
2627     ownership of the item.
2628 
2629     \sa horizontalHeaderItem(), takeVerticalHeaderItem()
2630 */
2631 QStandardItem *QStandardItemModel::takeHorizontalHeaderItem(int column)
2632 {
2633     Q_D(QStandardItemModel);
2634     if ((column < 0) || (column >= columnCount()))
2635         return 0;
2636     QStandardItem *headerItem = d->columnHeaderItems.at(column);
2637     if (headerItem) {
2638         headerItem->d_func()->setParentAndModel(0, 0);
2639         d->columnHeaderItems.replace(column, 0);
2640     }
2641     return headerItem;
2642 }
2643 
2644 /*!
2645     \since 4.2
2646 
2647     Removes the vertical header item at \a row from the header without
2648     deleting it, and returns a pointer to the item. The model releases
2649     ownership of the item.
2650 
2651     \sa verticalHeaderItem(), takeHorizontalHeaderItem()
2652 */
2653 QStandardItem *QStandardItemModel::takeVerticalHeaderItem(int row)
2654 {
2655     Q_D(QStandardItemModel);
2656     if ((row < 0) || (row >= rowCount()))
2657         return 0;
2658     QStandardItem *headerItem = d->rowHeaderItems.at(row);
2659     if (headerItem) {
2660         headerItem->d_func()->setParentAndModel(0, 0);
2661         d->rowHeaderItems.replace(row, 0);
2662     }
2663     return headerItem;
2664 }
2665 
2666 /*!
2667     \since 4.2
2668     \property QStandardItemModel::sortRole
2669     \brief the item role that is used to query the model's data when sorting items
2670 
2671     The default value is Qt::DisplayRole.
2672 
2673     \sa sort(), QStandardItem::sortChildren()
2674 */
2675 int QStandardItemModel::sortRole() const
2676 {
2677     Q_D(const QStandardItemModel);
2678     return d->sortRole;
2679 }
2680 
2681 void QStandardItemModel::setSortRole(int role)
2682 {
2683     Q_D(QStandardItemModel);
2684     d->sortRole = role;
2685 }
2686 
2687 /*!
2688   \reimp
2689 */
2690 int QStandardItemModel::columnCount(const QModelIndex &parent) const
2691 {
2692     Q_D(const QStandardItemModel);
2693     QStandardItem *item = d->itemFromIndex(parent);
2694     return item ? item->columnCount() : 0;
2695 }
2696 
2697 /*!
2698   \reimp
2699 */
2700 QVariant QStandardItemModel::data(const QModelIndex &index, int role) const
2701 {
2702     Q_D(const QStandardItemModel);
2703     QStandardItem *item = d->itemFromIndex(index);
2704     return item ? item->data(role) : QVariant();
2705 }
2706 
2707 /*!
2708   \reimp
2709 */
2710 Qt::ItemFlags QStandardItemModel::flags(const QModelIndex &index) const
2711 {
2712     Q_D(const QStandardItemModel);
2713     if (!d->indexValid(index))
2714         return d->root->flags();
2715     QStandardItem *item = d->itemFromIndex(index);
2716     if (item)
2717         return item->flags();
2718     return Qt::ItemIsSelectable
2719         |Qt::ItemIsEnabled
2720         |Qt::ItemIsEditable
2721         |Qt::ItemIsDragEnabled
2722         |Qt::ItemIsDropEnabled;
2723 }
2724 
2725 /*!
2726   \reimp
2727 */
2728 bool QStandardItemModel::hasChildren(const QModelIndex &parent) const
2729 {
2730     Q_D(const QStandardItemModel);
2731     QStandardItem *item = d->itemFromIndex(parent);
2732     return item ? item->hasChildren() : false;
2733 }
2734 
2735 /*!
2736   \reimp
2737 */
2738 QModelIndex QStandardItemModel::sibling(int row, int column, const QModelIndex &idx) const
2739 {
2740     return QAbstractItemModel::sibling(row, column, idx);
2741 }
2742 
2743 /*!
2744   \reimp
2745 */
2746 QVariant QStandardItemModel::headerData(int section, Qt::Orientation orientation, int role) const
2747 {
2748     Q_D(const QStandardItemModel);
2749     if ((section < 0)
2750         || ((orientation == Qt::Horizontal) && (section >= columnCount()))
2751         || ((orientation == Qt::Vertical) && (section >= rowCount()))) {
2752         return QVariant();
2753     }
2754     QStandardItem *headerItem = 0;
2755     if (orientation == Qt::Horizontal)
2756         headerItem = d->columnHeaderItems.at(section);
2757     else if (orientation == Qt::Vertical)
2758         headerItem = d->rowHeaderItems.at(section);
2759     return headerItem ? headerItem->data(role)
2760         : QAbstractItemModel::headerData(section, orientation, role);
2761 }
2762 
2763 /*!
2764     \reimp
2765 
2766     QStandardItemModel supports both copy and move.
2767 */
2768 Qt::DropActions QStandardItemModel::supportedDropActions () const
2769 {
2770     return Qt::CopyAction | Qt::MoveAction;
2771 }
2772 
2773 /*!
2774   \reimp
2775 */
2776 QModelIndex QStandardItemModel::index(int row, int column, const QModelIndex &parent) const
2777 {
2778     Q_D(const QStandardItemModel);
2779     QStandardItem *parentItem = d->itemFromIndex(parent);
2780     if ((parentItem == 0)
2781         || (row < 0)
2782         || (column < 0)
2783         || (row >= parentItem->rowCount())
2784         || (column >= parentItem->columnCount())) {
2785         return QModelIndex();
2786     }
2787     return createIndex(row, column, parentItem);
2788 }
2789 
2790 /*!
2791   \reimp
2792 */
2793 bool QStandardItemModel::insertColumns(int column, int count, const QModelIndex &parent)
2794 {
2795     Q_D(QStandardItemModel);
2796     QStandardItem *item = parent.isValid() ? itemFromIndex(parent) : d->root.data();
2797     if (item == 0)
2798         return false;
2799     return item->d_func()->insertColumns(column, count, QList<QStandardItem*>());
2800 }
2801 
2802 /*!
2803   \reimp
2804 */
2805 bool QStandardItemModel::insertRows(int row, int count, const QModelIndex &parent)
2806 {
2807     Q_D(QStandardItemModel);
2808     QStandardItem *item = parent.isValid() ? itemFromIndex(parent) : d->root.data();
2809     if (item == 0)
2810         return false;
2811     return item->d_func()->insertRows(row, count, QList<QStandardItem*>());
2812 }
2813 
2814 /*!
2815   \reimp
2816 */
2817 QMap<int, QVariant> QStandardItemModel::itemData(const QModelIndex &index) const
2818 {
2819     Q_D(const QStandardItemModel);
2820     QStandardItem *item = d->itemFromIndex(index);
2821     return item ? item->d_func()->itemData() : QMap<int, QVariant>();
2822 }
2823 
2824 /*!
2825   \reimp
2826 */
2827 QModelIndex QStandardItemModel::parent(const QModelIndex &child) const
2828 {
2829     Q_D(const QStandardItemModel);
2830     if (!d->indexValid(child))
2831         return QModelIndex();
2832     QStandardItem *parentItem = static_cast<QStandardItem*>(child.internalPointer());
2833     return indexFromItem(parentItem);
2834 }
2835 
2836 /*!
2837   \reimp
2838 */
2839 bool QStandardItemModel::removeColumns(int column, int count, const QModelIndex &parent)
2840 {
2841     Q_D(QStandardItemModel);
2842     QStandardItem *item = d->itemFromIndex(parent);
2843     if ((item == 0) || (count < 1) || (column < 0) || ((column + count) > item->columnCount()))
2844         return false;
2845     item->removeColumns(column, count);
2846     return true;
2847 }
2848 
2849 /*!
2850   \reimp
2851 */
2852 bool QStandardItemModel::removeRows(int row, int count, const QModelIndex &parent)
2853 {
2854     Q_D(QStandardItemModel);
2855     QStandardItem *item = d->itemFromIndex(parent);
2856     if ((item == 0) || (count < 1) || (row < 0) || ((row + count) > item->rowCount()))
2857         return false;
2858     item->removeRows(row, count);
2859     return true;
2860 }
2861 
2862 /*!
2863   \reimp
2864 */
2865 int QStandardItemModel::rowCount(const QModelIndex &parent) const
2866 {
2867     Q_D(const QStandardItemModel);
2868     QStandardItem *item = d->itemFromIndex(parent);
2869     return item ? item->rowCount() : 0;
2870 }
2871 
2872 /*!
2873   \reimp
2874 */
2875 bool QStandardItemModel::setData(const QModelIndex &index, const QVariant &value, int role)
2876 {
2877     if (!index.isValid())
2878         return false;
2879     QStandardItem *item = itemFromIndex(index);
2880     if (item == 0)
2881         return false;
2882     item->setData(value, role);
2883     return true;
2884 }
2885 
2886 /*!
2887   \reimp
2888 */
2889 bool QStandardItemModel::setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role)
2890 {
2891     Q_D(QStandardItemModel);
2892     if ((section < 0)
2893         || ((orientation == Qt::Horizontal) && (section >= columnCount()))
2894         || ((orientation == Qt::Vertical) && (section >= rowCount()))) {
2895         return false;
2896     }
2897     QStandardItem *headerItem = 0;
2898     if (orientation == Qt::Horizontal) {
2899         headerItem = d->columnHeaderItems.at(section);
2900         if (headerItem == 0) {
2901             headerItem = d->createItem();
2902             headerItem->d_func()->setModel(this);
2903             d->columnHeaderItems.replace(section, headerItem);
2904         }
2905     } else if (orientation == Qt::Vertical) {
2906         headerItem = d->rowHeaderItems.at(section);
2907         if (headerItem == 0) {
2908             headerItem = d->createItem();
2909             headerItem->d_func()->setModel(this);
2910             d->rowHeaderItems.replace(section, headerItem);
2911         }
2912     }
2913     if (headerItem) {
2914         headerItem->setData(value, role);
2915         return true;
2916     }
2917     return false;
2918 }
2919 
2920 /*!
2921   \reimp
2922 */
2923 bool QStandardItemModel::setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles)
2924 {
2925     QStandardItem *item = itemFromIndex(index);
2926     if (item == 0)
2927         return false;
2928     item->d_func()->setItemData(roles);
2929     return true;
2930 }
2931 
2932 /*!
2933   \reimp
2934 */
2935 void QStandardItemModel::sort(int column, Qt::SortOrder order)
2936 {
2937     Q_D(QStandardItemModel);
2938     d->root->sortChildren(column, order);
2939 }
2940 
2941 /*!
2942   \reimp
2943 */
2944 QStringList QStandardItemModel::mimeTypes() const
2945 {
2946     return QAbstractItemModel::mimeTypes() << qStandardItemModelDataListMimeType();
2947 }
2948 
2949 /*!
2950   \reimp
2951 */
2952 QMimeData *QStandardItemModel::mimeData(const QModelIndexList &indexes) const
2953 {
2954     QMimeData *data = QAbstractItemModel::mimeData(indexes);
2955     if(!data)
2956         return 0;
2957 
2958     const QString format = qStandardItemModelDataListMimeType();
2959     if (!mimeTypes().contains(format))
2960         return data;
2961     QByteArray encoded;
2962     QDataStream stream(&encoded, QIODevice::WriteOnly);
2963 
2964     QSet<QStandardItem*> itemsSet;
2965     QStack<QStandardItem*> stack;
2966     itemsSet.reserve(indexes.count());
2967     stack.reserve(indexes.count());
2968     for (int i = 0; i < indexes.count(); ++i) {
2969         if (QStandardItem *item = itemFromIndex(indexes.at(i))) {
2970             itemsSet << item;
2971             stack.push(item);
2972         } else {
2973             qWarning("QStandardItemModel::mimeData: No item associated with invalid index");
2974             return 0;
2975         }
2976     }
2977 
2978     //remove duplicates childrens
2979     {
2980         QSet<QStandardItem *> seen;
2981         while (!stack.isEmpty()) {
2982             QStandardItem *itm = stack.pop();
2983             if (seen.contains(itm))
2984                 continue;
2985             seen.insert(itm);
2986 
2987             const QVector<QStandardItem*> &childList = itm->d_func()->children;
2988             for (int i = 0; i < childList.count(); ++i) {
2989                 QStandardItem *chi = childList.at(i);
2990                 if (chi) {
2991                     itemsSet.erase(itemsSet.constFind(chi));
2992                     stack.push(chi);
2993                 }
2994             }
2995         }
2996     }
2997 
2998     stack.reserve(itemsSet.count());
2999     for (QStandardItem *item : qAsConst(itemsSet))
3000         stack.push(item);
3001 
3002     //stream everything recursively
3003     while (!stack.isEmpty()) {
3004         QStandardItem *item = stack.pop();
3005         if (itemsSet.contains(item)) //if the item is selection 'top-level', stream its position
3006             stream << item->row() << item->column();
3007 
3008         stream << *item << item->columnCount() << item->d_ptr->children.count();
3009         stack += item->d_ptr->children;
3010     }
3011 
3012     data->setData(format, encoded);
3013     return data;
3014 }
3015 
3016 
3017 /* \internal
3018     Used by QStandardItemModel::dropMimeData
3019     stream out an item and his children
3020  */
3021 void QStandardItemModelPrivate::decodeDataRecursive(QDataStream &stream, QStandardItem *item)
3022 {
3023     int colCount, childCount;
3024     stream >> *item;
3025     stream >> colCount >> childCount;
3026     item->setColumnCount(colCount);
3027 
3028     int childPos = childCount;
3029 
3030     while(childPos > 0) {
3031         childPos--;
3032         QStandardItem *child = createItem();
3033         decodeDataRecursive(stream, child);
3034         item->setChild( childPos / colCount, childPos % colCount, child);
3035     }
3036 }
3037 
3038 
3039 /*!
3040   \reimp
3041 */
3042 bool QStandardItemModel::dropMimeData(const QMimeData *data, Qt::DropAction action,
3043                                       int row, int column, const QModelIndex &parent)
3044 {
3045     Q_D(QStandardItemModel);
3046     // check if the action is supported
3047     if (!data || !(action == Qt::CopyAction || action == Qt::MoveAction))
3048         return false;
3049     // check if the format is supported
3050     const QString format = qStandardItemModelDataListMimeType();
3051     if (!data->hasFormat(format))
3052         return QAbstractItemModel::dropMimeData(data, action, row, column, parent);
3053 
3054     if (row > rowCount(parent))
3055         row = rowCount(parent);
3056     if (row == -1)
3057         row = rowCount(parent);
3058     if (column == -1)
3059         column = 0;
3060 
3061     // decode and insert
3062     QByteArray encoded = data->data(format);
3063     QDataStream stream(&encoded, QIODevice::ReadOnly);
3064 
3065 
3066     //code based on QAbstractItemModel::decodeData
3067     // adapted to work with QStandardItem
3068     int top = INT_MAX;
3069     int left = INT_MAX;
3070     int bottom = 0;
3071     int right = 0;
3072     QVector<int> rows, columns;
3073     QVector<QStandardItem *> items;
3074 
3075     while (!stream.atEnd()) {
3076         int r, c;
3077         QStandardItem *item = d->createItem();
3078         stream >> r >> c;
3079         d->decodeDataRecursive(stream, item);
3080 
3081         rows.append(r);
3082         columns.append(c);
3083         items.append(item);
3084         top = qMin(r, top);
3085         left = qMin(c, left);
3086         bottom = qMax(r, bottom);
3087         right = qMax(c, right);
3088     }
3089 
3090     // insert the dragged items into the table, use a bit array to avoid overwriting items,
3091     // since items from different tables can have the same row and column
3092     int dragRowCount = 0;
3093     int dragColumnCount = right - left + 1;
3094 
3095     // Compute the number of continuous rows upon insertion and modify the rows to match
3096     QVector<int> rowsToInsert(bottom + 1);
3097     for (int i = 0; i < rows.count(); ++i)
3098         rowsToInsert[rows.at(i)] = 1;
3099     for (int i = 0; i < rowsToInsert.count(); ++i) {
3100         if (rowsToInsert.at(i) == 1){
3101             rowsToInsert[i] = dragRowCount;
3102             ++dragRowCount;
3103         }
3104     }
3105     for (int i = 0; i < rows.count(); ++i)
3106         rows[i] = top + rowsToInsert.at(rows.at(i));
3107 
3108     QBitArray isWrittenTo(dragRowCount * dragColumnCount);
3109 
3110     // make space in the table for the dropped data
3111     int colCount = columnCount(parent);
3112     if (colCount < dragColumnCount + column) {
3113         insertColumns(colCount, dragColumnCount + column - colCount, parent);
3114         colCount = columnCount(parent);
3115     }
3116     insertRows(row, dragRowCount, parent);
3117 
3118     row = qMax(0, row);
3119     column = qMax(0, column);
3120 
3121     QStandardItem *parentItem = itemFromIndex (parent);
3122     if (!parentItem)
3123         parentItem = invisibleRootItem();
3124 
3125     QVector<QPersistentModelIndex> newIndexes(items.size());
3126     // set the data in the table
3127     for (int j = 0; j < items.size(); ++j) {
3128         int relativeRow = rows.at(j) - top;
3129         int relativeColumn = columns.at(j) - left;
3130         int destinationRow = relativeRow + row;
3131         int destinationColumn = relativeColumn + column;
3132         int flat = (relativeRow * dragColumnCount) + relativeColumn;
3133         // if the item was already written to, or we just can't fit it in the table, create a new row
3134         if (destinationColumn >= colCount || isWrittenTo.testBit(flat)) {
3135             destinationColumn = qBound(column, destinationColumn, colCount - 1);
3136             destinationRow = row + dragRowCount;
3137             insertRows(row + dragRowCount, 1, parent);
3138             flat = (dragRowCount * dragColumnCount) + relativeColumn;
3139             isWrittenTo.resize(++dragRowCount * dragColumnCount);
3140         }
3141         if (!isWrittenTo.testBit(flat)) {
3142             newIndexes[j] = index(destinationRow, destinationColumn, parentItem->index());
3143             isWrittenTo.setBit(flat);
3144         }
3145     }
3146 
3147     for(int k = 0; k < newIndexes.size(); k++) {
3148         if (newIndexes.at(k).isValid()) {
3149             parentItem->setChild(newIndexes.at(k).row(), newIndexes.at(k).column(), items.at(k));
3150         } else {
3151             delete items.at(k);
3152         }
3153     }
3154 
3155     return true;
3156 }
3157 
3158 QT_END_NAMESPACE
3159 
3160 #include "moc_qstandarditemmodel.cpp"
3161 
3162 #endif // QT_NO_STANDARDITEMMODEL
