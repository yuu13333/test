Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2013 John Layt <jlayt@kde.org>
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qtimezone.h"
41 #include "qtimezoneprivate_p.h"
42 #include "private/qlocale_tools_p.h"
43 
44 #include <QtCore/QFile>
45 #include <QtCore/QHash>
46 #include <QtCore/QDataStream>
47 #include <QtCore/QDateTime>
48 
49 #include <qdebug.h>
50 
51 #include <algorithm>
52 #include <errno.h>
53 #include <limits.h>
54 #if !defined(Q_OS_INTEGRITY)
55 #include <sys/param.h> // to use MAXSYMLINKS constant
56 #endif
57 #include <unistd.h>    // to use _SC_SYMLOOP_MAX constant
58 
59 QT_BEGIN_NAMESPACE
60 
61 /*
62     Private
63 
64     tz file implementation
65 */
66 
67 struct QTzTimeZone {
68     QLocale::Country country;
69     QByteArray comment;
70 };
71 
72 // Define as a type as Q_GLOBAL_STATIC doesn't like it
73 typedef QHash<QByteArray, QTzTimeZone> QTzTimeZoneHash;
74 
75 // Parse zone.tab table, assume lists all installed zones, if not will need to read directories
76 static QTzTimeZoneHash loadTzTimeZones()
77 {
78     QString path = QStringLiteral("/usr/share/zoneinfo/zone.tab");
79     if (!QFile::exists(path))
80         path = QStringLiteral("/usr/lib/zoneinfo/zone.tab");
81     if (!QFile::exists(path))
82         path = QStringLiteral("/etc/zoneinfo/zone.tab");
83 
84     QFile tzif(path);
85     if (!tzif.open(QIODevice::ReadOnly))
86         return QTzTimeZoneHash();
87 
88     QTzTimeZoneHash zonesHash;
89     // TODO QTextStream inefficient, replace later
90     QTextStream ts(&tzif);
91     while (!ts.atEnd()) {
92         const QString line = ts.readLine();
93         // Comment lines are prefixed with a #
94         if (!line.isEmpty() && line.at(0) != '#') {
95             // Data rows are tab-separated columns Region, Coordinates, ID, Optional Comments
96             const auto parts = line.splitRef(QLatin1Char('\t'));
97             QTzTimeZone zone;
98             zone.country = QLocalePrivate::codeToCountry(parts.at(0));
99             if (parts.size() > 3)
100                 zone.comment = parts.at(3).toUtf8();
101             zonesHash.insert(parts.at(2).toUtf8(), zone);
102         }
103     }
104     return zonesHash;
105 }
106 
107 // Hash of available system tz files as loaded by loadTzTimeZones()
108 Q_GLOBAL_STATIC_WITH_ARGS(const QTzTimeZoneHash, tzZones, (loadTzTimeZones()));
109 
110 /*
111     The following is copied and modified from tzfile.h which is in the public domain.
112     Copied as no compatibility guarantee and is never system installed.
113     See https://github.com/eggert/tz/blob/master/tzfile.h
114 */
115 
116 #define TZ_MAGIC      "TZif"
117 #define TZ_MAX_TIMES  1200
118 #define TZ_MAX_TYPES   256  // Limited by what (unsigned char)'s can hold
119 #define TZ_MAX_CHARS    50  // Maximum number of abbreviation characters
120 #define TZ_MAX_LEAPS    50  // Maximum number of leap second corrections
121 
122 struct QTzHeader {
123     char       tzh_magic[4];        // TZ_MAGIC
124     char       tzh_version;         // '\0' or '2' as of 2005
125     char       tzh_reserved[15];    // reserved--must be zero
126     quint32    tzh_ttisgmtcnt;      // number of trans. time flags
127     quint32    tzh_ttisstdcnt;      // number of trans. time flags
128     quint32    tzh_leapcnt;         // number of leap seconds
129     quint32    tzh_timecnt;         // number of transition times
130     quint32    tzh_typecnt;         // number of local time types
131     quint32    tzh_charcnt;         // number of abbr. chars
132 };
133 
134 struct QTzTransition {
135     qint64 tz_time;     // Transition time
136     quint8 tz_typeind;  // Type Index
137 };
138 Q_DECLARE_TYPEINFO(QTzTransition, Q_PRIMITIVE_TYPE);
139 
140 struct QTzType {
141     int tz_gmtoff;  // UTC offset in seconds
142     bool   tz_isdst;   // Is DST
143     quint8 tz_abbrind; // abbreviation list index
144 };
145 Q_DECLARE_TYPEINFO(QTzType, Q_PRIMITIVE_TYPE);
146 
147 
148 // TZ File parsing
149 
150 static QTzHeader parseTzHeader(QDataStream &ds, bool *ok)
151 {
152     QTzHeader hdr;
153     quint8 ch;
154     *ok = false;
155 
156     // Parse Magic, 4 bytes
157     ds.readRawData(hdr.tzh_magic, 4);
158 
159     if (memcmp(hdr.tzh_magic, TZ_MAGIC, 4) != 0 || ds.status() != QDataStream::Ok)
160         return hdr;
161 
162     // Parse Version, 1 byte, before 2005 was '\0', since 2005 a '2', since 2013 a '3'
163     ds >> ch;
164     hdr.tzh_version = ch;
165     if (ds.status() != QDataStream::Ok
166         || (hdr.tzh_version != '2' && hdr.tzh_version != '\0' && hdr.tzh_version != '3')) {
167         return hdr;
168     }
169 
170     // Parse reserved space, 15 bytes
171     ds.readRawData(hdr.tzh_reserved, 15);
172     if (ds.status() != QDataStream::Ok)
173         return hdr;
174 
175     // Parse rest of header, 6 x 4-byte transition counts
176     ds >> hdr.tzh_ttisgmtcnt >> hdr.tzh_ttisstdcnt >> hdr.tzh_leapcnt >> hdr.tzh_timecnt
177        >> hdr.tzh_typecnt >> hdr.tzh_charcnt;
178 
179     // Check defined maximums
180     if (ds.status() != QDataStream::Ok
181         || hdr.tzh_timecnt > TZ_MAX_TIMES
182         || hdr.tzh_typecnt > TZ_MAX_TYPES
183         || hdr.tzh_charcnt > TZ_MAX_CHARS
184         || hdr.tzh_leapcnt > TZ_MAX_LEAPS
185         || hdr.tzh_ttisgmtcnt > hdr.tzh_typecnt
186         || hdr.tzh_ttisstdcnt > hdr.tzh_typecnt) {
187         return hdr;
188     }
189 
190     *ok = true;
191     return hdr;
192 }
193 
194 static QVector<QTzTransition> parseTzTransitions(QDataStream &ds, int tzh_timecnt, bool longTran)
195 {
196     QVector<QTzTransition> transitions(tzh_timecnt);
197 
198     if (longTran) {
199         // Parse tzh_timecnt x 8-byte transition times
200         for (int i = 0; i < tzh_timecnt && ds.status() == QDataStream::Ok; ++i) {
201             ds >> transitions[i].tz_time;
202             if (ds.status() != QDataStream::Ok)
203                 transitions.resize(i);
204         }
205     } else {
206         // Parse tzh_timecnt x 4-byte transition times
207         qint32 val;
208         for (int i = 0; i < tzh_timecnt && ds.status() == QDataStream::Ok; ++i) {
209             ds >> val;
210             transitions[i].tz_time = val;
211             if (ds.status() != QDataStream::Ok)
212                 transitions.resize(i);
213         }
214     }
215 
216     // Parse tzh_timecnt x 1-byte transition type index
217     for (int i = 0; i < tzh_timecnt && ds.status() == QDataStream::Ok; ++i) {
218         quint8 typeind;
219         ds >> typeind;
220         if (ds.status() == QDataStream::Ok)
221             transitions[i].tz_typeind = typeind;
222     }
223 
224     return transitions;
225 }
226 
227 static QVector<QTzType> parseTzTypes(QDataStream &ds, int tzh_typecnt)
228 {
229     QVector<QTzType> types(tzh_typecnt);
230 
231     // Parse tzh_typecnt x transition types
232     for (int i = 0; i < tzh_typecnt && ds.status() == QDataStream::Ok; ++i) {
233         QTzType &type = types[i];
234         // Parse UTC Offset, 4 bytes
235         ds >> type.tz_gmtoff;
236         // Parse Is DST flag, 1 byte
237         if (ds.status() == QDataStream::Ok)
238             ds >> type.tz_isdst;
239         // Parse Abbreviation Array Index, 1 byte
240         if (ds.status() == QDataStream::Ok)
241             ds >> type.tz_abbrind;
242         if (ds.status() != QDataStream::Ok)
243             types.resize(i);
244     }
245 
246     return types;
247 }
248 
249 static QMap<int, QByteArray> parseTzAbbreviations(QDataStream &ds, int tzh_charcnt, const QVector<QTzType> &types)
250 {
251     // Parse the abbreviation list which is tzh_charcnt long with '\0' separated strings. The
252     // QTzType.tz_abbrind index points to the first char of the abbreviation in the array, not the
253     // occurrence in the list. It can also point to a partial string so we need to use the actual typeList
254     // index values when parsing.  By using a map with tz_abbrind as ordered key we get both index
255     // methods in one data structure and can convert the types afterwards.
256     QMap<int, QByteArray> map;
257     quint8 ch;
258     QByteArray input;
259     // First parse the full abbrev string
260     for (int i = 0; i < tzh_charcnt && ds.status() == QDataStream::Ok; ++i) {
261         ds >> ch;
262         if (ds.status() == QDataStream::Ok)
263             input.append(char(ch));
264         else
265             return map;
266     }
267     // Then extract all the substrings pointed to by types
268     for (const QTzType &type : types) {
269         QByteArray abbrev;
270         for (int i = type.tz_abbrind; input.at(i) != '\0'; ++i)
271             abbrev.append(input.at(i));
272         // Have reached end of an abbreviation, so add to map
273         map[type.tz_abbrind] = abbrev;
274     }
275     return map;
276 }
277 
278 static void parseTzLeapSeconds(QDataStream &ds, int tzh_leapcnt, bool longTran)
279 {
280     // Parse tzh_leapcnt x pairs of leap seconds
281     // We don't use leap seconds, so only read and don't store
282     qint32 val;
283     if (longTran) {
284         // v2 file format, each entry is 12 bytes long
285         qint64 time;
286         for (int i = 0; i < tzh_leapcnt && ds.status() == QDataStream::Ok; ++i) {
287             // Parse Leap Occurrence Time, 8 bytes
288             ds >> time;
289             // Parse Leap Seconds To Apply, 4 bytes
290             if (ds.status() == QDataStream::Ok)
291                 ds >> val;
292         }
293     } else {
294         // v0 file format, each entry is 8 bytes long
295         for (int i = 0; i < tzh_leapcnt && ds.status() == QDataStream::Ok; ++i) {
296             // Parse Leap Occurrence Time, 4 bytes
297             ds >> val;
298             // Parse Leap Seconds To Apply, 4 bytes
299             if (ds.status() == QDataStream::Ok)
300                 ds >> val;
301         }
302     }
303 }
304 
305 static QVector<QTzType> parseTzIndicators(QDataStream &ds, const QVector<QTzType> &types, int tzh_ttisstdcnt, int tzh_ttisgmtcnt)
306 {
307     QVector<QTzType> result = types;
308     bool temp;
309     /*
310       Scan and discard indicators.
311 
312       These indicators are only of use (by the date program) when "handling
313       POSIX-style time zone environment variables".  The flags here say whether
314       the *specification* of the zone gave the time in UTC, local standard time
315       or local wall time; but whatever was specified has been digested for us,
316       already, by the zone-info compiler (zic), so that the tz_time values read
317       from the file (by parseTzTransitions) are all in UTC.
318      */
319 
320     // Scan tzh_ttisstdcnt x 1-byte standard/wall indicators
321     for (int i = 0; i < tzh_ttisstdcnt && ds.status() == QDataStream::Ok; ++i)
322         ds >> temp;
323 
324     // Scan tzh_ttisgmtcnt x 1-byte UTC/local indicators
325     for (int i = 0; i < tzh_ttisgmtcnt && ds.status() == QDataStream::Ok; ++i)
326         ds >> temp;
327 
328     return result;
329 }
330 
331 static QByteArray parseTzPosixRule(QDataStream &ds)
332 {
333     // Parse POSIX rule, variable length '\n' enclosed
334     QByteArray rule;
335 
336     quint8 ch;
337     ds >> ch;
338     if (ch != '\n' || ds.status() != QDataStream::Ok)
339         return rule;
340     ds >> ch;
341     while (ch != '\n' && ds.status() == QDataStream::Ok) {
342         rule.append((char)ch);
343         ds >> ch;
344     }
345 
346     return rule;
347 }
348 
349 static QDate calculateDowDate(int year, int month, int dayOfWeek, int week)
350 {
351     QDate date(year, month, 1);
352     int startDow = date.dayOfWeek();
353     if (startDow <= dayOfWeek)
354         date = date.addDays(dayOfWeek - startDow - 7);
355     else
356         date = date.addDays(dayOfWeek - startDow);
357     date = date.addDays(week * 7);
358     while (date.month() != month)
359         date = date.addDays(-7);
360     return date;
361 }
362 
363 static QDate calculatePosixDate(const QByteArray &dateRule, int year)
364 {
365     // Can start with M, J, or a digit
366     if (dateRule.at(0) == 'M') {
367         // nth week in month format "Mmonth.week.dow"
368         QList<QByteArray> dateParts = dateRule.split('.');
369         int month = dateParts.at(0).mid(1).toInt();
370         int week = dateParts.at(1).toInt();
371         int dow = dateParts.at(2).toInt();
372         if (dow == 0)
373             ++dow;
374         return calculateDowDate(year, month, dow, week);
375     } else if (dateRule.at(0) == 'J') {
376         // Day of Year ignores Feb 29
377         int doy = dateRule.mid(1).toInt();
378         QDate date = QDate(year, 1, 1).addDays(doy - 1);
379         if (QDate::isLeapYear(date.year()))
380             date = date.addDays(-1);
381         return date;
382     } else {
383         // Day of Year includes Feb 29
384         int doy = dateRule.toInt();
385         return QDate(year, 1, 1).addDays(doy - 1);
386     }
387 }
388 
389 // returns the time in seconds, INT_MIN if we failed to parse
390 static int parsePosixTime(const char *begin, const char *end)
391 {
392     // Format "hh[:mm[:ss]]"
393     int hour, min = 0, sec = 0;
394 
395     // Note that the calls to qstrtoll do *not* check the end pointer, which
396     // means they proceed until they find a non-digit. We check that we're
397     // still in range at the end, but we may have read from past end. It's the
398     // caller's responsibility to ensure that begin is part of a
399     // null-terminated string.
400 
401     bool ok = false;
402     hour = qstrtoll(begin, &begin, 10, &ok);
403     if (!ok || hour < 0)
404         return INT_MIN;
405     if (begin < end && *begin == ':') {
406         // minutes
407         ++begin;
408         min = qstrtoll(begin, &begin, 10, &ok);
409         if (!ok || min < 0)
410             return INT_MIN;
411 
412         if (begin < end && *begin == ':') {
413             // seconds
414             ++begin;
415             sec = qstrtoll(begin, &begin, 10, &ok);
416             if (!ok || sec < 0)
417                 return INT_MIN;
418         }
419     }
420 
421     // we must have consumed everything
422     if (begin != end)
423         return INT_MIN;
424 
425     return (hour * 60 + min) * 60 + sec;
426 }
427 
428 static QTime parsePosixTransitionTime(const QByteArray &timeRule)
429 {
430     // Format "hh[:mm[:ss]]"
431     int value = parsePosixTime(timeRule.constBegin(), timeRule.constEnd());
432     if (value == INT_MIN) {
433         // if we failed to parse, return 02:00
434         return QTime(2, 0, 0);
435     }
436     return QTime::fromMSecsSinceStartOfDay(value * 1000);
437 }
438 
439 static int parsePosixOffset(const char *begin, const char *end)
440 {
441     // Format "[+|-]hh[:mm[:ss]]"
442     // note that the sign is inverted because POSIX counts in hours West of GMT
443     bool negate = true;
444     if (*begin == '+') {
445         ++begin;
446     } else if (*begin == '-') {
447         negate = false;
448         ++begin;
449     }
450 
451     int value = parsePosixTime(begin, end);
452     if (value == INT_MIN)
453         return value;
454     return negate ? -value : value;
455 }
456 
457 static inline bool asciiIsLetter(char ch)
458 {
459     ch |= 0x20; // lowercases if it is a letter, otherwise just corrupts ch
460     return ch >= 'a' && ch <= 'z';
461 }
462 
463 namespace {
464 
465 struct PosixZone
466 {
467     enum {
468         InvalidOffset = INT_MIN,
469     };
470 
471     QString name;
472     int offset;
473 
474     static PosixZone invalid() { return {QString(), InvalidOffset}; }
475     static PosixZone parse(const char *&pos, const char *end);
476 
477     bool hasValidOffset() const noexcept { return offset != InvalidOffset; }
478 };
479 
480 } // unnamed namespace
481 
482 // Returns the zone name, the offset (in seconds) and advances \a begin to
483 // where the parsing ended. Returns a zone of INT_MIN in case an offset
484 // couldn't be read.
485 PosixZone PosixZone::parse(const char *&pos, const char *end)
486 {
487     static const char offsetChars[] = "0123456789:";
488 
489     const char *nameBegin = pos;
490     const char *nameEnd;
491     Q_ASSERT(pos < end);
492 
493     if (*pos == '<') {
494         nameBegin = pos + 1;    // skip the '<'
495         nameEnd = nameBegin;
496         while (nameEnd < end && *nameEnd != '>') {
497             // POSIX says only alphanumeric, but we allow anything
498             ++nameEnd;
499         }
500         pos = nameEnd + 1;      // skip the '>'
501     } else {
502         nameBegin = pos;
503         nameEnd = nameBegin;
504         while (nameEnd < end && asciiIsLetter(*nameEnd))
505             ++nameEnd;
506         pos = nameEnd;
507     }
508     if (nameEnd - nameBegin < 3)
509         return invalid();  // name must be at least 3 characters long
510 
511     // zone offset, form [+-]hh:mm:ss
512     const char *zoneBegin = pos;
513     const char *zoneEnd = pos;
514     if (zoneEnd < end && (zoneEnd[0] == '+' || zoneEnd[0] == '-'))
515         ++zoneEnd;
516     while (zoneEnd < end) {
517         if (strchr(offsetChars, char(*zoneEnd)) == NULL)
518             break;
519         ++zoneEnd;
520     }
521 
522     QString name = QString::fromUtf8(nameBegin, nameEnd - nameBegin);
523     const int offset = zoneEnd > zoneBegin ? parsePosixOffset(zoneBegin, zoneEnd) : InvalidOffset;
524     pos = zoneEnd;
525     // UTC+hh:mm:ss or GMT+hh:mm:ss should be read as offsets from UTC, not as a
526     // POSIX rule naming a zone as UTC or GMT and specifying a non-zero offset.
527     if (offset != 0 && (name == QLatin1String("UTC") || name == QLatin1String("GMT")))
528         return invalid();
529     return {std::move(name), offset};
530 }
531 
532 static QVector<QTimeZonePrivate::Data> calculatePosixTransitions(const QByteArray &posixRule,
533                                                                  int startYear, int endYear,
534                                                                  qint64 lastTranMSecs)
535 {
536     QVector<QTimeZonePrivate::Data> result;
537 
538     // POSIX Format is like "TZ=CST6CDT,M3.2.0/2:00:00,M11.1.0/2:00:00"
539     // i.e. "std offset dst [offset],start[/time],end[/time]"
540     // See the section about TZ at
541     // http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html
542     QList<QByteArray> parts = posixRule.split(',');
543 
544     PosixZone stdZone, dstZone = PosixZone::invalid();
545     {
546         const QByteArray &zoneinfo = parts.at(0);
547         const char *begin = zoneinfo.constBegin();
548 
549         stdZone = PosixZone::parse(begin, zoneinfo.constEnd());
550         if (!stdZone.hasValidOffset()) {
551             stdZone.offset = 0;     // reset to UTC if we failed to parse
552         } else if (begin < zoneinfo.constEnd()) {
553             dstZone = PosixZone::parse(begin, zoneinfo.constEnd());
554             if (!dstZone.hasValidOffset()) {
555                 // if the dst offset isn't provided, it is 1 hour ahead of the standard offset
556                 dstZone.offset = stdZone.offset + (60 * 60);
557             }
558         }
559     }
560 
561     // If only the name part then no transitions
562     if (parts.count() == 1) {
563         QTimeZonePrivate::Data data;
564         data.atMSecsSinceEpoch = lastTranMSecs;
565         data.offsetFromUtc = stdZone.offset;
566         data.standardTimeOffset = stdZone.offset;
567         data.daylightTimeOffset = 0;
568         data.abbreviation = stdZone.name;
569         result << data;
570         return result;
571     }
572 
573 
574     // Get the std to dst transtion details
575     QList<QByteArray> dstParts = parts.at(1).split('/');
576     QByteArray dstDateRule = dstParts.at(0);
577     QTime dstTime;
578     if (dstParts.count() > 1)
579         dstTime = parsePosixTransitionTime(dstParts.at(1));
580     else
581         dstTime = QTime(2, 0, 0);
582 
583     // Get the dst to std transtion details
584     QList<QByteArray> stdParts = parts.at(2).split('/');
585     QByteArray stdDateRule = stdParts.at(0);
586     QTime stdTime;
587     if (stdParts.count() > 1)
588         stdTime = parsePosixTransitionTime(stdParts.at(1));
589     else
590         stdTime = QTime(2, 0, 0);
591 
592     // Limit year to the range QDateTime can represent:
593     const int minYear = int(QDateTime::YearRange::First);
594     const int maxYear = int(QDateTime::YearRange::Last);
595     startYear = qBound(minYear, startYear, maxYear);
596     endYear = qBound(minYear, endYear, maxYear);
597     Q_ASSERT(startYear <= endYear);
598 
599     for (int year = startYear; year <= endYear; ++year) {
600         QTimeZonePrivate::Data dstData;
601         QDateTime dst(calculatePosixDate(dstDateRule, year), dstTime, Qt::UTC);
602         dstData.atMSecsSinceEpoch = dst.toMSecsSinceEpoch() - (stdZone.offset * 1000);
603         dstData.offsetFromUtc = dstZone.offset;
604         dstData.standardTimeOffset = stdZone.offset;
605         dstData.daylightTimeOffset = dstZone.offset - stdZone.offset;
606         dstData.abbreviation = dstZone.name;
607         QTimeZonePrivate::Data stdData;
608         QDateTime std(calculatePosixDate(stdDateRule, year), stdTime, Qt::UTC);
609         stdData.atMSecsSinceEpoch = std.toMSecsSinceEpoch() - (dstZone.offset * 1000);
610         stdData.offsetFromUtc = stdZone.offset;
611         stdData.standardTimeOffset = stdZone.offset;
612         stdData.daylightTimeOffset = 0;
613         stdData.abbreviation = stdZone.name;
614         // Part of maxYear will overflow (likewise for minYear, below):
615         if (year == maxYear && (dstData.atMSecsSinceEpoch < 0 || stdData.atMSecsSinceEpoch < 0)) {
616             if (dstData.atMSecsSinceEpoch > 0) {
617                 result << dstData;
618             } else if (stdData.atMSecsSinceEpoch > 0) {
619                 result << stdData;
620             }
621         } else if (year < 1970) { // We ignore DST before the epoch.
622             if (year > minYear || stdData.atMSecsSinceEpoch != QTimeZonePrivate::invalidMSecs())
623                 result << stdData;
624         } else if (dst < std) {
625             result << dstData << stdData;
626         } else {
627             result << stdData << dstData;
628         }
629     }
630     return result;
631 }
632 
633 // Create the system default time zone
634 QTzTimeZonePrivate::QTzTimeZonePrivate()
635 {
636     init(systemTimeZoneId());
637 }
638 
639 // Create a named time zone
640 QTzTimeZonePrivate::QTzTimeZonePrivate(const QByteArray &ianaId)
641 {
642     init(ianaId);
643 }
644 
645 QTzTimeZonePrivate::~QTzTimeZonePrivate()
646 {
647 }
648 
649 QTzTimeZonePrivate *QTzTimeZonePrivate::clone() const
650 {
651     return new QTzTimeZonePrivate(*this);
652 }
653 
654 void QTzTimeZonePrivate::init(const QByteArray &ianaId)
655 {
656     QFile tzif;
657     if (ianaId.isEmpty()) {
658         // Open system tz
659         tzif.setFileName(QStringLiteral("/etc/localtime"));
660         if (!tzif.open(QIODevice::ReadOnly))
661             return;
662     } else {
663         // Open named tz, try modern path first, if fails try legacy path
664         tzif.setFileName(QLatin1String("/usr/share/zoneinfo/") + QString::fromLocal8Bit(ianaId));
665         if (!tzif.open(QIODevice::ReadOnly)) {
666             tzif.setFileName(QLatin1String("/usr/lib/zoneinfo/") + QString::fromLocal8Bit(ianaId));
667             if (!tzif.open(QIODevice::ReadOnly)) {
668                 // ianaId may be a POSIX rule, taken from $TZ or /etc/TZ
669                 const QByteArray zoneInfo = ianaId.split(',').at(0);
670                 const char *begin = zoneInfo.constBegin();
671                 if (PosixZone::parse(begin, zoneInfo.constEnd()).hasValidOffset()
672                     && (begin == zoneInfo.constEnd()
673                         || PosixZone::parse(begin, zoneInfo.constEnd()).hasValidOffset())) {
674                     m_id = m_posixRule = ianaId;
675                 }
676                 return;
677             }
678         }
679     }
680 
681     QDataStream ds(&tzif);
682 
683     // Parse the old version block of data
684     bool ok = false;
685     QTzHeader hdr = parseTzHeader(ds, &ok);
686     if (!ok || ds.status() != QDataStream::Ok)
687         return;
688     QVector<QTzTransition> tranList = parseTzTransitions(ds, hdr.tzh_timecnt, false);
689     if (ds.status() != QDataStream::Ok)
690         return;
691     QVector<QTzType> typeList = parseTzTypes(ds, hdr.tzh_typecnt);
692     if (ds.status() != QDataStream::Ok)
693         return;
694     QMap<int, QByteArray> abbrevMap = parseTzAbbreviations(ds, hdr.tzh_charcnt, typeList);
695     if (ds.status() != QDataStream::Ok)
696         return;
697     parseTzLeapSeconds(ds, hdr.tzh_leapcnt, false);
698     if (ds.status() != QDataStream::Ok)
699         return;
700     typeList = parseTzIndicators(ds, typeList, hdr.tzh_ttisstdcnt, hdr.tzh_ttisgmtcnt);
701     if (ds.status() != QDataStream::Ok)
702         return;
703 
704     // If version 2 then parse the second block of data
705     if (hdr.tzh_version == '2' || hdr.tzh_version == '3') {
706         ok = false;
707         QTzHeader hdr2 = parseTzHeader(ds, &ok);
708         if (!ok || ds.status() != QDataStream::Ok)
709             return;
710         tranList = parseTzTransitions(ds, hdr2.tzh_timecnt, true);
711         if (ds.status() != QDataStream::Ok)
712             return;
713         typeList = parseTzTypes(ds, hdr2.tzh_typecnt);
714         if (ds.status() != QDataStream::Ok)
715             return;
716         abbrevMap = parseTzAbbreviations(ds, hdr2.tzh_charcnt, typeList);
717         if (ds.status() != QDataStream::Ok)
718             return;
719         parseTzLeapSeconds(ds, hdr2.tzh_leapcnt, true);
720         if (ds.status() != QDataStream::Ok)
721             return;
722         typeList = parseTzIndicators(ds, typeList, hdr2.tzh_ttisstdcnt, hdr2.tzh_ttisgmtcnt);
723         if (ds.status() != QDataStream::Ok)
724             return;
725         m_posixRule = parseTzPosixRule(ds);
726         if (ds.status() != QDataStream::Ok)
727             return;
728     }
729 
730     // Translate the TZ file into internal format
731 
732     // Translate the array index based tz_abbrind into list index
733     const int size = abbrevMap.size();
734     m_abbreviations.clear();
735     m_abbreviations.reserve(size);
736     QVector<int> abbrindList;
737     abbrindList.reserve(size);
738     for (auto it = abbrevMap.cbegin(), end = abbrevMap.cend(); it != end; ++it) {
739         m_abbreviations.append(it.value());
740         abbrindList.append(it.key());
741     }
742     for (int i = 0; i < typeList.size(); ++i)
743         typeList[i].tz_abbrind = abbrindList.indexOf(typeList.at(i).tz_abbrind);
744 
745     // Offsets are stored as total offset, want to know separate UTC and DST offsets
746     // so find the first non-dst transition to use as base UTC Offset
747     int utcOffset = 0;
748     for (const QTzTransition &tran : qAsConst(tranList)) {
749         if (!typeList.at(tran.tz_typeind).tz_isdst) {
750             utcOffset = typeList.at(tran.tz_typeind).tz_gmtoff;
751             break;
752         }
753     }
754 
755     // Now for each transition time calculate and store our rule:
756     const int tranCount = tranList.count();;
757     m_tranTimes.reserve(tranCount);
758     // The DST offset when in effect: usually stable, usually an hour:
759     int lastDstOff = 3600;
760     for (int i = 0; i < tranCount; i++) {
761         const QTzTransition &tz_tran = tranList.at(i);
762         QTzTransitionTime tran;
763         QTzTransitionRule rule;
764         const QTzType tz_type = typeList.at(tz_tran.tz_typeind);
765 
766         // Calculate the associated Rule
767         if (!tz_type.tz_isdst) {
768             utcOffset = tz_type.tz_gmtoff;
769         } else if (Q_UNLIKELY(tz_type.tz_gmtoff != utcOffset + lastDstOff)) {
770             /*
771               This might be a genuine change in DST offset, but could also be
772               DST starting at the same time as the standard offset changed.  See
773               if DST's end gives a more plausible utcOffset (i.e. one closer to
774               the last we saw, or a simple whole hour):
775             */
776             // Standard offset inferred from net offset and expected DST offset:
777             const int inferStd = tz_type.tz_gmtoff - lastDstOff; // != utcOffset
778             for (int j = i + 1; j < tranCount; j++) {
779                 const QTzType new_type = typeList.at(tranList.at(j).tz_typeind);
780                 if (!new_type.tz_isdst) {
781                     const int newUtc = new_type.tz_gmtoff;
782                     if (newUtc == utcOffset) {
783                         // DST-end can't help us, avoid lots of messy checks.
784                     // else: See if the end matches the familiar DST offset:
785                     } else if (newUtc == inferStd) {
786                         utcOffset = newUtc;
787                     // else: let either end shift us to one hour as DST offset:
788                     } else if (tz_type.tz_gmtoff - 3600 == utcOffset) {
789                         // Start does it
790                     } else if (tz_type.tz_gmtoff - 3600 == newUtc) {
791                         utcOffset = newUtc; // End does it
792                     // else: prefer whichever end gives DST offset closer to
793                     // last, but consider any offset > 0 "closer" than any <= 0:
794                     } else if (newUtc < tz_type.tz_gmtoff
795                                ? (utcOffset >= tz_type.tz_gmtoff
796                                   || qAbs(newUtc - inferStd) < qAbs(utcOffset - inferStd))
797                                : (utcOffset >= tz_type.tz_gmtoff
798                                   && qAbs(newUtc - inferStd) < qAbs(utcOffset - inferStd))) {
799                         utcOffset = newUtc;
800                     }
801                     break;
802                 }
803             }
804             lastDstOff = tz_type.tz_gmtoff - utcOffset;
805         }
806         rule.stdOffset = utcOffset;
807         rule.dstOffset = tz_type.tz_gmtoff - utcOffset;
808         rule.abbreviationIndex = tz_type.tz_abbrind;
809 
810         // If the rule already exist then use that, otherwise add it
811         int ruleIndex = m_tranRules.indexOf(rule);
812         if (ruleIndex == -1) {
813             m_tranRules.append(rule);
814             tran.ruleIndex = m_tranRules.size() - 1;
815         } else {
816             tran.ruleIndex = ruleIndex;
817         }
818 
819         tran.atMSecsSinceEpoch = tz_tran.tz_time * 1000;
820         m_tranTimes.append(tran);
821     }
822     if (m_tranTimes.isEmpty() && m_posixRule.isEmpty())
823         return; // Invalid after all !
824 
825     if (ianaId.isEmpty())
826         m_id = systemTimeZoneId();
827     else
828         m_id = ianaId;
829 }
830 
831 QLocale::Country QTzTimeZonePrivate::country() const
832 {
833     return tzZones->value(m_id).country;
834 }
835 
836 QString QTzTimeZonePrivate::comment() const
837 {
838     return QString::fromUtf8(tzZones->value(m_id).comment);
839 }
840 
841 QString QTzTimeZonePrivate::displayName(qint64 atMSecsSinceEpoch,
842                                         QTimeZone::NameType nameType,
843                                         const QLocale &locale) const
844 {
845 #if QT_CONFIG(icu)
846     if (!m_icu)
847         m_icu = new QIcuTimeZonePrivate(m_id);
848     // TODO small risk may not match if tran times differ due to outdated files
849     // TODO Some valid TZ names are not valid ICU names, use translation table?
850     if (m_icu->isValid())
851         return m_icu->displayName(atMSecsSinceEpoch, nameType, locale);
852 #else
853     Q_UNUSED(nameType)
854     Q_UNUSED(locale)
855 #endif
856     return abbreviation(atMSecsSinceEpoch);
857 }
858 
859 QString QTzTimeZonePrivate::displayName(QTimeZone::TimeType timeType,
860                                         QTimeZone::NameType nameType,
861                                         const QLocale &locale) const
862 {
863 #if QT_CONFIG(icu)
864     if (!m_icu)
865         m_icu = new QIcuTimeZonePrivate(m_id);
866     // TODO small risk may not match if tran times differ due to outdated files
867     // TODO Some valid TZ names are not valid ICU names, use translation table?
868     if (m_icu->isValid())
869         return m_icu->displayName(timeType, nameType, locale);
870 #else
871     Q_UNUSED(timeType)
872     Q_UNUSED(nameType)
873     Q_UNUSED(locale)
874 #endif
875     // If no ICU available then have to use abbreviations instead
876     // Abbreviations don't have GenericTime
877     if (timeType == QTimeZone::GenericTime)
878         timeType = QTimeZone::StandardTime;
879 
880     // Get current tran, if valid and is what we want, then use it
881     const qint64 currentMSecs = QDateTime::currentMSecsSinceEpoch();
882     QTimeZonePrivate::Data tran = data(currentMSecs);
883     if (tran.atMSecsSinceEpoch != invalidMSecs()
884         && ((timeType == QTimeZone::DaylightTime && tran.daylightTimeOffset != 0)
885         || (timeType == QTimeZone::StandardTime && tran.daylightTimeOffset == 0))) {
886         return tran.abbreviation;
887     }
888 
889     // Otherwise get next tran and if valid and is what we want, then use it
890     tran = nextTransition(currentMSecs);
891     if (tran.atMSecsSinceEpoch != invalidMSecs()
892         && ((timeType == QTimeZone::DaylightTime && tran.daylightTimeOffset != 0)
893         || (timeType == QTimeZone::StandardTime && tran.daylightTimeOffset == 0))) {
894         return tran.abbreviation;
895     }
896 
897     // Otherwise get prev tran and if valid and is what we want, then use it
898     tran = previousTransition(currentMSecs);
899     if (tran.atMSecsSinceEpoch != invalidMSecs())
900         tran = previousTransition(tran.atMSecsSinceEpoch);
901     if (tran.atMSecsSinceEpoch != invalidMSecs()
902         && ((timeType == QTimeZone::DaylightTime && tran.daylightTimeOffset != 0)
903         || (timeType == QTimeZone::StandardTime && tran.daylightTimeOffset == 0))) {
904         return tran.abbreviation;
905     }
906 
907     // Otherwise is strange sequence, so work backwards through trans looking for first match, if any
908     auto it = std::partition_point(m_tranTimes.cbegin(), m_tranTimes.cend(),
909                                    [currentMSecs](const QTzTransitionTime &at) {
910                                        return at.atMSecsSinceEpoch <= currentMSecs;
911                                    });
912 
913     while (it != m_tranTimes.cbegin()) {
914         --it;
915         tran = dataForTzTransition(*it);
916         int offset = tran.daylightTimeOffset;
917         if ((timeType == QTimeZone::DaylightTime) != (offset == 0))
918             return tran.abbreviation;
919     }
920 
921     // Otherwise if no match use current data
922     return data(currentMSecs).abbreviation;
923 }
924 
925 QString QTzTimeZonePrivate::abbreviation(qint64 atMSecsSinceEpoch) const
926 {
927     return data(atMSecsSinceEpoch).abbreviation;
928 }
929 
930 int QTzTimeZonePrivate::offsetFromUtc(qint64 atMSecsSinceEpoch) const
931 {
932     const QTimeZonePrivate::Data tran = data(atMSecsSinceEpoch);
933     return tran.offsetFromUtc; // == tran.standardTimeOffset + tran.daylightTimeOffset
934 }
935 
936 int QTzTimeZonePrivate::standardTimeOffset(qint64 atMSecsSinceEpoch) const
937 {
938     return data(atMSecsSinceEpoch).standardTimeOffset;
939 }
940 
941 int QTzTimeZonePrivate::daylightTimeOffset(qint64 atMSecsSinceEpoch) const
942 {
943     return data(atMSecsSinceEpoch).daylightTimeOffset;
944 }
945 
946 bool QTzTimeZonePrivate::hasDaylightTime() const
947 {
948     // TODO Perhaps cache as frequently accessed?
949     for (const QTzTransitionRule &rule : m_tranRules) {
950         if (rule.dstOffset != 0)
951             return true;
952     }
953     return false;
954 }
955 
956 bool QTzTimeZonePrivate::isDaylightTime(qint64 atMSecsSinceEpoch) const
957 {
958     return (daylightTimeOffset(atMSecsSinceEpoch) != 0);
959 }
960 
961 QTimeZonePrivate::Data QTzTimeZonePrivate::dataForTzTransition(QTzTransitionTime tran) const
962 {
963     QTimeZonePrivate::Data data;
964     data.atMSecsSinceEpoch = tran.atMSecsSinceEpoch;
965     QTzTransitionRule rule = m_tranRules.at(tran.ruleIndex);
966     data.standardTimeOffset = rule.stdOffset;
967     data.daylightTimeOffset = rule.dstOffset;
968     data.offsetFromUtc = rule.stdOffset + rule.dstOffset;
969     data.abbreviation = QString::fromUtf8(m_abbreviations.at(rule.abbreviationIndex));
970     return data;
971 }
972 
973 QVector<QTimeZonePrivate::Data> QTzTimeZonePrivate::getPosixTransitions(qint64 msNear) const
974 {
975     const int year = QDateTime::fromMSecsSinceEpoch(msNear, Qt::UTC).date().year();
976     // The Data::atMSecsSinceEpoch of the single entry if zone is constant:
977     qint64 atTime = m_tranTimes.isEmpty() ? msNear : m_tranTimes.last().atMSecsSinceEpoch;
978     return calculatePosixTransitions(m_posixRule, year - 1, year + 1, atTime);
979 }
980 
981 QTimeZonePrivate::Data QTzTimeZonePrivate::data(qint64 forMSecsSinceEpoch) const
982 {
983     // If the required time is after the last transition (or there were none)
984     // and we have a POSIX rule, then use it:
985     if (!m_posixRule.isEmpty()
986         && (m_tranTimes.isEmpty() || m_tranTimes.last().atMSecsSinceEpoch < forMSecsSinceEpoch)) {
987         QVector<QTimeZonePrivate::Data> posixTrans = getPosixTransitions(forMSecsSinceEpoch);
988         auto it = std::partition_point(posixTrans.cbegin(), posixTrans.cend(),
989                                        [forMSecsSinceEpoch] (const QTimeZonePrivate::Data &at) {
990                                            return at.atMSecsSinceEpoch <= forMSecsSinceEpoch;
991                                        });
992         // Use most recent, if any in the past; or the first if we have no other rules:
993         if (it > posixTrans.cbegin() || (m_tranTimes.isEmpty() && it < posixTrans.cend())) {
994             QTimeZonePrivate::Data data = *(it > posixTrans.cbegin() ? it - 1 : it);
995             data.atMSecsSinceEpoch = forMSecsSinceEpoch;
996             return data;
997         }
998     }
999     if (m_tranTimes.isEmpty()) // Only possible if !isValid()
1000         return invalidData();
1001 
1002     // Otherwise, use the rule for the most recent or first transition:
1003     auto last = std::partition_point(m_tranTimes.cbegin(), m_tranTimes.cend(),
1004                                      [forMSecsSinceEpoch] (const QTzTransitionTime &at) {
1005                                          return at.atMSecsSinceEpoch <= forMSecsSinceEpoch;
1006                                      });
1007     if (last > m_tranTimes.cbegin())
1008         --last;
1009     Data data = dataForTzTransition(*last);
1010     data.atMSecsSinceEpoch = forMSecsSinceEpoch;
1011     return data;
1012 }
1013 
1014 bool QTzTimeZonePrivate::hasTransitions() const
1015 {
1016     return true;
1017 }
1018 
1019 QTimeZonePrivate::Data QTzTimeZonePrivate::nextTransition(qint64 afterMSecsSinceEpoch) const
1020 {
1021     // If the required time is after the last transition (or there were none)
1022     // and we have a POSIX rule, then use it:
1023     if (!m_posixRule.isEmpty()
1024         && (m_tranTimes.isEmpty() || m_tranTimes.last().atMSecsSinceEpoch < afterMSecsSinceEpoch)) {
1025         QVector<QTimeZonePrivate::Data> posixTrans = getPosixTransitions(afterMSecsSinceEpoch);
1026         auto it = std::partition_point(posixTrans.cbegin(), posixTrans.cend(),
1027                                        [afterMSecsSinceEpoch] (const QTimeZonePrivate::Data &at) {
1028                                            return at.atMSecsSinceEpoch <= afterMSecsSinceEpoch;
1029                                        });
1030 
1031         return it == posixTrans.cend() ? invalidData() : *it;
1032     }
1033 
1034     // Otherwise, if we can find a valid tran, use its rule:
1035     auto last = std::partition_point(m_tranTimes.cbegin(), m_tranTimes.cend(),
1036                                      [afterMSecsSinceEpoch] (const QTzTransitionTime &at) {
1037                                          return at.atMSecsSinceEpoch <= afterMSecsSinceEpoch;
1038                                      });
1039     return last != m_tranTimes.cend() ? dataForTzTransition(*last) : invalidData();
1040 }
1041 
1042 QTimeZonePrivate::Data QTzTimeZonePrivate::previousTransition(qint64 beforeMSecsSinceEpoch) const
1043 {
1044     // If the required time is after the last transition (or there were none)
1045     // and we have a POSIX rule, then use it:
1046     if (!m_posixRule.isEmpty()
1047         && (m_tranTimes.isEmpty() || m_tranTimes.last().atMSecsSinceEpoch < beforeMSecsSinceEpoch)) {
1048         QVector<QTimeZonePrivate::Data> posixTrans = getPosixTransitions(beforeMSecsSinceEpoch);
1049         auto it = std::partition_point(posixTrans.cbegin(), posixTrans.cend(),
1050                                        [beforeMSecsSinceEpoch] (const QTimeZonePrivate::Data &at) {
1051                                            return at.atMSecsSinceEpoch < beforeMSecsSinceEpoch;
1052                                        });
1053         if (it > posixTrans.cbegin())
1054             return *--it;
1055         // It fell between the last transition (if any) and the first of the POSIX rule:
1056         return m_tranTimes.isEmpty() ? invalidData() : dataForTzTransition(m_tranTimes.last());
1057     }
1058 
1059     // Otherwise if we can find a valid tran then use its rule
1060     auto last = std::partition_point(m_tranTimes.cbegin(), m_tranTimes.cend(),
1061                                      [beforeMSecsSinceEpoch] (const QTzTransitionTime &at) {
1062                                          return at.atMSecsSinceEpoch < beforeMSecsSinceEpoch;
1063                                      });
1064     return last > m_tranTimes.cbegin() ? dataForTzTransition(*--last) : invalidData();
1065 }
1066 
1067 static long getSymloopMax()
1068 {
1069 #if defined(SYMLOOP_MAX)
1070     return SYMLOOP_MAX; // if defined, at runtime it can only be greater than this, so this is a safe bet
1071 #else
1072     errno = 0;
1073     long result = sysconf(_SC_SYMLOOP_MAX);
1074     if (result >= 0)
1075         return result;
1076     // result is -1, meaning either error or no limit
1077     Q_ASSERT(!errno); // ... but it can't be an error, POSIX mandates _SC_SYMLOOP_MAX
1078 
1079     // therefore we can make up our own limit
1080 #  if defined(MAXSYMLINKS)
1081     return MAXSYMLINKS;
1082 #  else
1083     return 8;
1084 #  endif
1085 #endif
1086 }
1087 
1088 // TODO Could cache the value and monitor the required files for any changes
1089 QByteArray QTzTimeZonePrivate::systemTimeZoneId() const
1090 {
1091     // Check TZ env var first, if not populated try find it
1092     QByteArray ianaId = qgetenv("TZ");
1093     if (!ianaId.isEmpty() && ianaId.at(0) == ':')
1094         ianaId = ianaId.mid(1);
1095 
1096     // The TZ value can be ":/etc/localtime" which libc considers
1097     // to be a "default timezone", in which case it will be read
1098     // by one of the blocks below, so unset it here so it is not
1099     // considered as a valid/found ianaId
1100     if (ianaId == "/etc/localtime")
1101         ianaId.clear();
1102 
1103     // On most distros /etc/localtime is a symlink to a real file so extract name from the path
1104     if (ianaId.isEmpty()) {
1105         const QLatin1String zoneinfo("/zoneinfo/");
1106         QString path = QFile::symLinkTarget(QStringLiteral("/etc/localtime"));
1107         int index = -1;
1108         long iteration = getSymloopMax();
1109         // Symlink may point to another symlink etc. before being under zoneinfo/
1110         // We stop on the first path under /zoneinfo/, even if it is itself a
1111         // symlink, like America/Montreal pointing to America/Toronto
1112         while (iteration-- > 0 && !path.isEmpty() && (index = path.indexOf(zoneinfo)) < 0)
1113             path = QFile::symLinkTarget(path);
1114         if (index >= 0) {
1115             // /etc/localtime is a symlink to the current TZ file, so extract from path
1116             ianaId = path.midRef(index + zoneinfo.size()).toUtf8();
1117         }
1118     }
1119 
1120     // On Debian Etch up to Jessie, /etc/localtime is a regular file while the actual name is in /etc/timezone
1121     if (ianaId.isEmpty()) {
1122         QFile tzif(QStringLiteral("/etc/timezone"));
1123         if (tzif.open(QIODevice::ReadOnly)) {
1124             // TODO QTextStream inefficient, replace later
1125             QTextStream ts(&tzif);
1126             if (!ts.atEnd())
1127                 ianaId = ts.readLine().toUtf8();
1128         }
1129     }
1130 
1131     // On some Red Hat distros /etc/localtime is real file with name held in /etc/sysconfig/clock
1132     // in a line like ZONE="Europe/Oslo" or TIMEZONE="Europe/Oslo"
1133     if (ianaId.isEmpty()) {
1134         QFile tzif(QStringLiteral("/etc/sysconfig/clock"));
1135         if (tzif.open(QIODevice::ReadOnly)) {
1136             // TODO QTextStream inefficient, replace later
1137             QTextStream ts(&tzif);
1138             QString line;
1139             while (ianaId.isEmpty() && !ts.atEnd() && ts.status() == QTextStream::Ok) {
1140                 line = ts.readLine();
1141                 if (line.startsWith(QLatin1String("ZONE="))) {
1142                     ianaId = line.midRef(6, line.size() - 7).toUtf8();
1143                 } else if (line.startsWith(QLatin1String("TIMEZONE="))) {
1144                     ianaId = line.midRef(10, line.size() - 11).toUtf8();
1145                 }
1146             }
1147         }
1148     }
1149 
1150     // Some systems (e.g. uClibc) have a default value for $TZ in /etc/TZ:
1151     if (ianaId.isEmpty()) {
1152         QFile zone(QStringLiteral("/etc/TZ"));
1153         if (zone.open(QIODevice::ReadOnly))
1154             ianaId = zone.readAll().trimmed();
1155     }
1156 
1157     // Give up for now and return UTC
1158     if (ianaId.isEmpty())
1159         ianaId = utcQByteArray();
1160 
1161     return ianaId;
1162 }
1163 
1164 bool QTzTimeZonePrivate::isTimeZoneIdAvailable(const QByteArray &ianaId) const
1165 {
1166     return tzZones->contains(ianaId);
1167 }
1168 
1169 QList<QByteArray> QTzTimeZonePrivate::availableTimeZoneIds() const
1170 {
1171     QList<QByteArray> result = tzZones->keys();
1172     std::sort(result.begin(), result.end());
1173     return result;
1174 }
1175 
1176 QList<QByteArray> QTzTimeZonePrivate::availableTimeZoneIds(QLocale::Country country) const
1177 {
1178     // TODO AnyCountry
1179     QList<QByteArray> result;
1180     for (auto it = tzZones->cbegin(), end = tzZones->cend(); it != end; ++it) {
1181         if (it.value().country == country)
1182             result << it.key();
1183     }
1184     std::sort(result.begin(), result.end());
1185     return result;
1186 }
1187 
1188 QT_END_NAMESPACE
