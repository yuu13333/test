Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2019 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Copyright (C) 2013 Olivier Goffart <ogoffart@woboq.com>
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qobject.h"
43 #include "qobject_p.h"
44 #include "qmetaobject_p.h"
45 
46 #include "qabstracteventdispatcher.h"
47 #include "qabstracteventdispatcher_p.h"
48 #include "qcoreapplication.h"
49 #include "qcoreapplication_p.h"
50 #include "qvariant.h"
51 #include "qmetaobject.h"
52 #include <qregexp.h>
53 #if QT_CONFIG(regularexpression)
54 #  include <qregularexpression.h>
55 #endif
56 #include <qthread.h>
57 #include <private/qthread_p.h>
58 #include <qdebug.h>
59 #include <qpair.h>
60 #include <qvarlengtharray.h>
61 #include <qset.h>
62 #if QT_CONFIG(thread)
63 #include <qsemaphore.h>
64 #endif
65 #include <qsharedpointer.h>
66 
67 #include <private/qorderedmutexlocker_p.h>
68 #include <private/qhooks_p.h>
69 #include <qtcore_tracepoints_p.h>
70 
71 #include <new>
72 
73 #include <ctype.h>
74 #include <limits.h>
75 
76 QT_BEGIN_NAMESPACE
77 
78 static int DIRECT_CONNECTION_ONLY = 0;
79 
80 Q_CORE_EXPORT QBasicAtomicPointer<QSignalSpyCallbackSet> qt_signal_spy_callback_set = Q_BASIC_ATOMIC_INITIALIZER(nullptr);
81 
82 void qt_register_signal_spy_callbacks(QSignalSpyCallbackSet *callback_set)
83 {
84     qt_signal_spy_callback_set.store(callback_set);
85 }
86 
87 QDynamicMetaObjectData::~QDynamicMetaObjectData()
88 {
89 }
90 
91 QAbstractDynamicMetaObject::~QAbstractDynamicMetaObject()
92 {
93 }
94 
95 
96 struct QSlotObjectBaseDeleter { // for use with QScopedPointer<QSlotObjectBase,...>
97     static void cleanup(QtPrivate::QSlotObjectBase *slot) {
98         if (slot) slot->destroyIfLastRef();
99     }
100 };
101 static int *queuedConnectionTypes(const QList<QByteArray> &typeNames)
102 {
103     int *types = new int [typeNames.count() + 1];
104     Q_CHECK_PTR(types);
105     for (int i = 0; i < typeNames.count(); ++i) {
106         const QByteArray typeName = typeNames.at(i);
107         if (typeName.endsWith('*'))
108             types[i] = QMetaType::VoidStar;
109         else
110             types[i] = QMetaType::type(typeName);
111 
112         if (!types[i]) {
113             qWarning("QObject::connect: Cannot queue arguments of type '%s'\n"
114                      "(Make sure '%s' is registered using qRegisterMetaType().)",
115                      typeName.constData(), typeName.constData());
116             delete [] types;
117             return 0;
118         }
119     }
120     types[typeNames.count()] = 0;
121 
122     return types;
123 }
124 
125 static int *queuedConnectionTypes(const QArgumentType *argumentTypes, int argc)
126 {
127     QScopedArrayPointer<int> types(new int [argc + 1]);
128     for (int i = 0; i < argc; ++i) {
129         const QArgumentType &type = argumentTypes[i];
130         if (type.type())
131             types[i] = type.type();
132         else if (type.name().endsWith('*'))
133             types[i] = QMetaType::VoidStar;
134         else
135             types[i] = QMetaType::type(type.name());
136 
137         if (!types[i]) {
138             qWarning("QObject::connect: Cannot queue arguments of type '%s'\n"
139                      "(Make sure '%s' is registered using qRegisterMetaType().)",
140                      type.name().constData(), type.name().constData());
141             return 0;
142         }
143     }
144     types[argc] = 0;
145 
146     return types.take();
147 }
148 
149 static QBasicMutex _q_ObjectMutexPool[131];
150 
151 /**
152  * \internal
153  * mutex to be locked when accessing the connectionlists or the senders list
154  */
155 static inline QBasicMutex *signalSlotLock(const QObject *o)
156 {
157     return &_q_ObjectMutexPool[uint(quintptr(o)) % sizeof(_q_ObjectMutexPool)/sizeof(QBasicMutex)];
158 }
159 
160 #if QT_VERSION < 0x60000
161 extern "C" Q_CORE_EXPORT void qt_addObject(QObject *)
162 {}
163 
164 extern "C" Q_CORE_EXPORT void qt_removeObject(QObject *)
165 {}
166 #endif
167 
168 void (*QAbstractDeclarativeData::destroyed)(QAbstractDeclarativeData *, QObject *) = 0;
169 void (*QAbstractDeclarativeData::destroyed_qml1)(QAbstractDeclarativeData *, QObject *) = 0;
170 void (*QAbstractDeclarativeData::parentChanged)(QAbstractDeclarativeData *, QObject *, QObject *) = 0;
171 void (*QAbstractDeclarativeData::signalEmitted)(QAbstractDeclarativeData *, QObject *, int, void **) = 0;
172 int  (*QAbstractDeclarativeData::receivers)(QAbstractDeclarativeData *, const QObject *, int) = 0;
173 bool (*QAbstractDeclarativeData::isSignalConnected)(QAbstractDeclarativeData *, const QObject *, int) = 0;
174 void (*QAbstractDeclarativeData::setWidgetParent)(QObject *, QObject *) = 0;
175 
176 QObjectData::~QObjectData() {}
177 
178 QMetaObject *QObjectData::dynamicMetaObject() const
179 {
180     return metaObject->toDynamicMetaObject(q_ptr);
181 }
182 
183 QObjectPrivate::QObjectPrivate(int version)
184     : threadData(0), currentChildBeingDeleted(0)
185 {
186 #ifdef QT_BUILD_INTERNAL
187     // Don't check the version parameter in internal builds.
188     // This allows incompatible versions to be loaded, possibly for testing.
189     Q_UNUSED(version);
190 #else
191     if (Q_UNLIKELY(version != QObjectPrivateVersion))
192         qFatal("Cannot mix incompatible Qt library (version 0x%x) with this library (version 0x%x)",
193                 version, QObjectPrivateVersion);
194 #endif
195 
196     // QObjectData initialization
197     q_ptr = 0;
198     parent = 0;                                 // no parent yet. It is set by setParent()
199     isWidget = false;                           // assume not a widget object
200     blockSig = false;                           // not blocking signals
201     wasDeleted = false;                         // double-delete catcher
202     isDeletingChildren = false;                 // set by deleteChildren()
203     sendChildEvents = true;                     // if we should send ChildAdded and ChildRemoved events to parent
204     receiveChildEvents = true;
205     postedEvents = 0;
206     extraData = 0;
207     metaObject = 0;
208     isWindow = false;
209     deleteLaterCalled = false;
210 }
211 
212 QObjectPrivate::~QObjectPrivate()
213 {
214     if (extraData && !extraData->runningTimers.isEmpty()) {
215         if (Q_LIKELY(threadData->thread == QThread::currentThread())) {
216             // unregister pending timers
217             if (threadData->hasEventDispatcher())
218                 threadData->eventDispatcher.load()->unregisterTimers(q_ptr);
219 
220             // release the timer ids back to the pool
221             for (int i = 0; i < extraData->runningTimers.size(); ++i)
222                 QAbstractEventDispatcherPrivate::releaseTimerId(extraData->runningTimers.at(i));
223         } else {
224             qWarning("QObject::~QObject: Timers cannot be stopped from another thread");
225         }
226     }
227 
228     if (postedEvents)
229         QCoreApplication::removePostedEvents(q_ptr, 0);
230 
231     threadData->deref();
232 
233     if (metaObject) metaObject->objectDestroyed(q_ptr);
234 
235 #ifndef QT_NO_USERDATA
236     if (extraData)
237         qDeleteAll(extraData->userData);
238 #endif
239     delete extraData;
240 }
241 
242 /*!
243   \internal
244   For a given metaobject, compute the signal offset, and the method offset (including signals)
245 */
246 static void computeOffsets(const QMetaObject *metaobject, int *signalOffset, int *methodOffset)
247 {
248     *signalOffset = *methodOffset = 0;
249     const QMetaObject *m = metaobject->d.superdata;
250     while (m) {
251         const QMetaObjectPrivate *d = QMetaObjectPrivate::get(m);
252         *methodOffset += d->methodCount;
253         Q_ASSERT(d->revision >= 4);
254         *signalOffset += d->signalCount;
255         m = m->d.superdata;
256     }
257 }
258 
259 // Used by QAccessibleWidget
260 bool QObjectPrivate::isSender(const QObject *receiver, const char *signal) const
261 {
262     Q_Q(const QObject);
263     int signal_index = signalIndex(signal);
264     ConnectionData *cd = connections.load();
265     if (signal_index < 0 || !cd)
266         return false;
267     QBasicMutexLocker locker(signalSlotLock(q));
268     if (signal_index < cd->signalVector.count()) {
269         const QObjectPrivate::Connection *c = cd->signalVector.at(signal_index).first;
270 
271         while (c) {
272             if (c->receiver == receiver)
273                 return true;
274             c = c->nextConnectionList;
275         }
276     }
277     return false;
278 }
279 
280 // Used by QAccessibleWidget
281 QObjectList QObjectPrivate::receiverList(const char *signal) const
282 {
283     Q_Q(const QObject);
284     QObjectList returnValue;
285     int signal_index = signalIndex(signal);
286     ConnectionData *cd = connections.load();
287     if (signal_index < 0 || !cd)
288         return returnValue;
289     QBasicMutexLocker locker(signalSlotLock(q));
290     if (signal_index < cd->signalVector.count()) {
291         const QObjectPrivate::Connection *c = cd->signalVector.at(signal_index).first;
292 
293         while (c) {
294             if (c->receiver)
295                 returnValue << c->receiver;
296             c = c->nextConnectionList;
297         }
298     }
299     return returnValue;
300 }
301 
302 // Used by QAccessibleWidget
303 QObjectList QObjectPrivate::senderList() const
304 {
305     QObjectList returnValue;
306     ConnectionData *cd = connections.load();
307     if (cd) {
308         QBasicMutexLocker locker(signalSlotLock(q_func()));
309         for (Connection *c = cd->senders; c; c = c->next)
310             returnValue << c->sender;
311     }
312     return returnValue;
313 }
314 
315 /*!
316   \internal
317   Add the connection \a c to the list of connections of the sender's object
318   for the specified \a signal
319 
320   The signalSlotLock() of the sender and receiver must be locked while calling
321   this function
322 
323   Will also add the connection in the sender's list of the receiver.
324  */
325 void QObjectPrivate::addConnection(int signal, Connection *c)
326 {
327     Q_ASSERT(c->sender == q_ptr);
328     ensureConnectionData();
329     ConnectionData *cd = connections.load();
330     if (signal >= cd->signalVector.count())
331         cd->signalVector.resize(signal + 1);
332 
333     ConnectionList &connectionList = cd->connectionsForSignal(signal);
334     if (connectionList.last) {
335         Q_ASSERT(connectionList.last->receiver);
336         connectionList.last->nextConnectionList = c;
337     } else {
338         connectionList.first = c;
339     }
340     c->id = ++cd->currentConnectionId;
341     c->prevConnectionList = connectionList.last;
342     connectionList.last = c;
343 
344     QObjectPrivate *rd = QObjectPrivate::get(c->receiver);
345     rd->ensureConnectionData();
346 
347     c->prev = &(rd->connections.load()->senders);
348     c->next = *c->prev;
349     *c->prev = c;
350     if (c->next)
351         c->next->prev = &c->next;
352 }
353 
354 void QObjectPrivate::ConnectionData::cleanOrphanedConnectionsImpl(QObject *sender)
355 {
356     Connection *c = nullptr;
357     {
358         QBasicMutexLocker l(signalSlotLock(sender));
359         if (ref > 1)
360             return;
361 
362         // Since ref == 1, no activate() is in process since we locked the mutex. That implies,
363         // that nothing can reference the orphaned connection objects anymore and they can
364         // be safely deleted
365         c = orphanedConnections.load();
366         orphanedConnections.store(nullptr);
367     }
368     while (c) {
369         Q_ASSERT(!c->receiver);
370         Q_ASSERT(!c->prev);
371         QObjectPrivate::Connection *next = c->next;
372         c->freeSlotObject();
373         c->deref();
374         c = next;
375     }
376 }
377 
378 /*! \internal
379 
380   Returns \c true if the signal with index \a signal_index from object \a sender is connected.
381 
382   \a signal_index must be the index returned by QObjectPrivate::signalIndex;
383 */
384 bool QObjectPrivate::isSignalConnected(uint signalIndex, bool checkDeclarative) const
385 {
386     if (checkDeclarative && isDeclarativeSignalConnected(signalIndex))
387         return true;
388 
389     ConnectionData *cd = connections.load();
390     if (!cd)
391         return false;
392 
393     if (cd->allsignals.first)
394         return true;
395 
396     if (signalIndex < uint(cd->signalVector.count())) {
397         const QObjectPrivate::Connection *c = cd->signalVector.at(signalIndex).first;
398         while (c) {
399             if (c->receiver)
400                 return true;
401             c = c->nextConnectionList;
402         }
403     }
404     return false;
405 }
406 
407 
408 /*!
409     \internal
410  */
411 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative, QObjectPrivate::StaticMetaCallFunction callFunction,
412                                const QObject *sender, int signalId,
413                                int nargs, int *types, void **args, QSemaphore *semaphore)
414     : QEvent(MetaCall), slotObj_(0), sender_(sender), signalId_(signalId),
415       nargs_(nargs), types_(types), args_(args), semaphore_(semaphore),
416       callFunction_(callFunction), method_offset_(method_offset), method_relative_(method_relative)
417 { }
418 
419 /*!
420     \internal
421  */
422 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO, const QObject *sender, int signalId,
423                                int nargs, int *types, void **args, QSemaphore *semaphore)
424     : QEvent(MetaCall), slotObj_(slotO), sender_(sender), signalId_(signalId),
425       nargs_(nargs), types_(types), args_(args), semaphore_(semaphore),
426       callFunction_(0), method_offset_(0), method_relative_(ushort(-1))
427 {
428     if (slotObj_)
429         slotObj_->ref();
430 }
431 
432 /*!
433     \internal
434  */
435 QMetaCallEvent::~QMetaCallEvent()
436 {
437     if (types_) {
438         for (int i = 0; i < nargs_; ++i) {
439             if (types_[i] && args_[i])
440                 QMetaType::destroy(types_[i], args_[i]);
441         }
442         free(types_);
443         free(args_);
444     }
445 #if QT_CONFIG(thread)
446     if (semaphore_)
447         semaphore_->release();
448 #endif
449     if (slotObj_)
450         slotObj_->destroyIfLastRef();
451 }
452 
453 /*!
454     \internal
455  */
456 void QMetaCallEvent::placeMetaCall(QObject *object)
457 {
458     if (slotObj_) {
459         slotObj_->call(object, args_);
460     } else if (callFunction_ && method_offset_ <= object->metaObject()->methodOffset()) {
461         callFunction_(object, QMetaObject::InvokeMetaMethod, method_relative_, args_);
462     } else {
463         QMetaObject::metacall(object, QMetaObject::InvokeMetaMethod, method_offset_ + method_relative_, args_);
464     }
465 }
466 
467 /*!
468     \class QSignalBlocker
469     \brief Exception-safe wrapper around QObject::blockSignals().
470     \since 5.3
471     \ingroup objectmodel
472     \inmodule QtCore
473 
474     \reentrant
475 
476     QSignalBlocker can be used wherever you would otherwise use a
477     pair of calls to blockSignals(). It blocks signals in its
478     constructor and in the destructor it resets the state to what
479     it was before the constructor ran.
480 
481     \snippet code/src_corelib_kernel_qobject.cpp 53
482     is thus equivalent to
483     \snippet code/src_corelib_kernel_qobject.cpp 54
484 
485     except the code using QSignalBlocker is safe in the face of
486     exceptions.
487 
488     \sa QMutexLocker, QEventLoopLocker
489 */
490 
491 /*!
492     \fn QSignalBlocker::QSignalBlocker(QObject *object)
493 
494     Constructor. Calls \a{object}->blockSignals(true).
495 */
496 
497 /*!
498     \fn QSignalBlocker::QSignalBlocker(QObject &object)
499     \overload
500 
501     Calls \a{object}.blockSignals(true).
502 */
503 
504 /*!
505     \fn QSignalBlocker::QSignalBlocker(QSignalBlocker &&other)
506 
507     Move-constructs a signal blocker from \a other. \a other will have
508     a no-op destructor, while repsonsibility for restoring the
509     QObject::signalsBlocked() state is transferred to the new object.
510 */
511 
512 /*!
513     \fn QSignalBlocker &QSignalBlocker::operator=(QSignalBlocker &&other)
514 
515     Move-assigns this signal blocker from \a other. \a other will have
516     a no-op destructor, while repsonsibility for restoring the
517     QObject::signalsBlocked() state is transferred to this object.
518 
519     The object's signals this signal blocker was blocking prior to
520     being moved to, if any, are unblocked \e except in the case where
521     both instances block the same object's signals and \c *this is
522     unblocked while \a other is not, at the time of the move.
523 */
524 
525 /*!
526     \fn QSignalBlocker::~QSignalBlocker()
527 
528     Destructor. Restores the QObject::signalsBlocked() state to what it
529     was before the constructor ran, unless unblock() has been called
530     without a following reblock(), in which case it does nothing.
531 */
532 
533 /*!
534     \fn void QSignalBlocker::reblock()
535 
536     Re-blocks signals after a previous unblock().
537 
538     The numbers of reblock() and unblock() calls are not counted, so
539     every reblock() undoes any number of unblock() calls.
540 */
541 
542 /*!
543     \fn void QSignalBlocker::unblock()
544 
545     Temporarily restores the QObject::signalsBlocked() state to what
546     it was before this QSignaBlocker's constructor ran. To undo, use
547     reblock().
548 
549     The numbers of reblock() and unblock() calls are not counted, so
550     every unblock() undoes any number of reblock() calls.
551 */
552 
553 /*!
554     \class QObject
555     \inmodule QtCore
556     \brief The QObject class is the base class of all Qt objects.
557 
558     \ingroup objectmodel
559 
560     \reentrant
561 
562     QObject is the heart of the Qt \l{Object Model}. The central
563     feature in this model is a very powerful mechanism for seamless
564     object communication called \l{signals and slots}. You can
565     connect a signal to a slot with connect() and destroy the
566     connection with disconnect(). To avoid never ending notification
567     loops you can temporarily block signals with blockSignals(). The
568     protected functions connectNotify() and disconnectNotify() make
569     it possible to track connections.
570 
571     QObjects organize themselves in \l {Object Trees & Ownership}
572     {object trees}. When you create a QObject with another object as
573     parent, the object will automatically add itself to the parent's
574     children() list. The parent takes ownership of the object; i.e.,
575     it will automatically delete its children in its destructor. You
576     can look for an object by name and optionally type using
577     findChild() or findChildren().
578 
579     Every object has an objectName() and its class name can be found
580     via the corresponding metaObject() (see QMetaObject::className()).
581     You can determine whether the object's class inherits another
582     class in the QObject inheritance hierarchy by using the
583     inherits() function.
584 
585     When an object is deleted, it emits a destroyed() signal. You can
586     catch this signal to avoid dangling references to QObjects.
587 
588     QObjects can receive events through event() and filter the events
589     of other objects. See installEventFilter() and eventFilter() for
590     details. A convenience handler, childEvent(), can be reimplemented
591     to catch child events.
592 
593     Last but not least, QObject provides the basic timer support in
594     Qt; see QTimer for high-level support for timers.
595 
596     Notice that the Q_OBJECT macro is mandatory for any object that
597     implements signals, slots or properties. You also need to run the
598     \l{moc}{Meta Object Compiler} on the source file. We strongly
599     recommend the use of this macro in all subclasses of QObject
600     regardless of whether or not they actually use signals, slots and
601     properties, since failure to do so may lead certain functions to
602     exhibit strange behavior.
603 
604     All Qt widgets inherit QObject. The convenience function
605     isWidgetType() returns whether an object is actually a widget. It
606     is much faster than
607     \l{qobject_cast()}{qobject_cast}<QWidget *>(\e{obj}) or
608     \e{obj}->\l{inherits()}{inherits}("QWidget").
609 
610     Some QObject functions, e.g. children(), return a QObjectList.
611     QObjectList is a typedef for QList<QObject *>.
612 
613     \section1 Thread Affinity
614 
615     A QObject instance is said to have a \e{thread affinity}, or that
616     it \e{lives} in a certain thread. When a QObject receives a
617     \l{Qt::QueuedConnection}{queued signal} or a \l{The Event
618     System#Sending Events}{posted event}, the slot or event handler
619     will run in the thread that the object lives in.
620 
621     \note If a QObject has no thread affinity (that is, if thread()
622     returns zero), or if it lives in a thread that has no running event
623     loop, then it cannot receive queued signals or posted events.
624 
625     By default, a QObject lives in the thread in which it is created.
626     An object's thread affinity can be queried using thread() and
627     changed using moveToThread().
628 
629     All QObjects must live in the same thread as their parent. Consequently:
630 
631     \list
632     \li setParent() will fail if the two QObjects involved live in
633         different threads.
634     \li When a QObject is moved to another thread, all its children
635         will be automatically moved too.
636     \li moveToThread() will fail if the QObject has a parent.
637     \li If QObjects are created within QThread::run(), they cannot
638         become children of the QThread object because the QThread does
639         not live in the thread that calls QThread::run().
640     \endlist
641 
642     \note A QObject's member variables \e{do not} automatically become
643     its children. The parent-child relationship must be set by either
644     passing a pointer to the child's \l{QObject()}{constructor}, or by
645     calling setParent(). Without this step, the object's member variables
646     will remain in the old thread when moveToThread() is called.
647 
648     \target No copy constructor
649     \section1 No Copy Constructor or Assignment Operator
650 
651     QObject has neither a copy constructor nor an assignment operator.
652     This is by design. Actually, they are declared, but in a
653     \c{private} section with the macro Q_DISABLE_COPY(). In fact, all
654     Qt classes derived from QObject (direct or indirect) use this
655     macro to declare their copy constructor and assignment operator to
656     be private. The reasoning is found in the discussion on
657     \l{Identity vs Value} {Identity vs Value} on the Qt \l{Object
658     Model} page.
659 
660     The main consequence is that you should use pointers to QObject
661     (or to your QObject subclass) where you might otherwise be tempted
662     to use your QObject subclass as a value. For example, without a
663     copy constructor, you can't use a subclass of QObject as the value
664     to be stored in one of the container classes. You must store
665     pointers.
666 
667     \section1 Auto-Connection
668 
669     Qt's meta-object system provides a mechanism to automatically connect
670     signals and slots between QObject subclasses and their children. As long
671     as objects are defined with suitable object names, and slots follow a
672     simple naming convention, this connection can be performed at run-time
673     by the QMetaObject::connectSlotsByName() function.
674 
675     \l uic generates code that invokes this function to enable
676     auto-connection to be performed between widgets on forms created
677     with \e{Qt Designer}. More information about using auto-connection with \e{Qt Designer} is
678     given in the \l{Using a Designer UI File in Your Application} section of
679     the \e{Qt Designer} manual.
680 
681     \section1 Dynamic Properties
682 
683     From Qt 4.2, dynamic properties can be added to and removed from QObject
684     instances at run-time. Dynamic properties do not need to be declared at
685     compile-time, yet they provide the same advantages as static properties
686     and are manipulated using the same API - using property() to read them
687     and setProperty() to write them.
688 
689     From Qt 4.3, dynamic properties are supported by
690     \l{Qt Designer's Widget Editing Mode#The Property Editor}{Qt Designer},
691     and both standard Qt widgets and user-created forms can be given dynamic
692     properties.
693 
694     \section1 Internationalization (I18n)
695 
696     All QObject subclasses support Qt's translation features, making it possible
697     to translate an application's user interface into different languages.
698 
699     To make user-visible text translatable, it must be wrapped in calls to
700     the tr() function. This is explained in detail in the
701     \l{Writing Source Code for Translation} document.
702 
703     \sa QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY()
704     \sa {Object Trees & Ownership}
705 */
706 
707 /*****************************************************************************
708   QObject member functions
709  *****************************************************************************/
710 
711 // check the constructor's parent thread argument
712 static bool check_parent_thread(QObject *parent,
713                                 QThreadData *parentThreadData,
714                                 QThreadData *currentThreadData)
715 {
716     if (parent && parentThreadData != currentThreadData) {
717         QThread *parentThread = parentThreadData->thread;
718         QThread *currentThread = currentThreadData->thread;
719         qWarning("QObject: Cannot create children for a parent that is in a different thread.\n"
720                  "(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)",
721                  parent->metaObject()->className(),
722                  parent,
723                  parentThread ? parentThread->metaObject()->className() : "QThread",
724                  parentThread,
725                  currentThread ? currentThread->metaObject()->className() : "QThread",
726                  currentThread);
727         return false;
728     }
729     return true;
730 }
731 
732 /*!
733     Constructs an object with parent object \a parent.
734 
735     The parent of an object may be viewed as the object's owner. For
736     instance, a \l{QDialog}{dialog box} is the parent of the \uicontrol{OK}
737     and \uicontrol{Cancel} buttons it contains.
738 
739     The destructor of a parent object destroys all child objects.
740 
741     Setting \a parent to 0 constructs an object with no parent. If the
742     object is a widget, it will become a top-level window.
743 
744     \sa parent(), findChild(), findChildren()
745 */
746 
747 QObject::QObject(QObject *parent)
748     : d_ptr(new QObjectPrivate)
749 {
750     Q_D(QObject);
751     d_ptr->q_ptr = this;
752     d->threadData = (parent && !parent->thread()) ? parent->d_func()->threadData : QThreadData::current();
753     d->threadData->ref();
754     if (parent) {
755         QT_TRY {
756             if (!check_parent_thread(parent, parent ? parent->d_func()->threadData : 0, d->threadData))
757                 parent = 0;
758             setParent(parent);
759         } QT_CATCH(...) {
760             d->threadData->deref();
761             QT_RETHROW;
762         }
763     }
764 #if QT_VERSION < 0x60000
765     qt_addObject(this);
766 #endif
767     if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
768         reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
769     Q_TRACE(QObject_ctor, this);
770 }
771 
772 /*!
773     \internal
774  */
775 QObject::QObject(QObjectPrivate &dd, QObject *parent)
776     : d_ptr(&dd)
777 {
778     Q_D(QObject);
779     d_ptr->q_ptr = this;
780     d->threadData = (parent && !parent->thread()) ? parent->d_func()->threadData : QThreadData::current();
781     d->threadData->ref();
782     if (parent) {
783         QT_TRY {
784             if (!check_parent_thread(parent, parent ? parent->d_func()->threadData : 0, d->threadData))
785                 parent = 0;
786             if (d->isWidget) {
787                 if (parent) {
788                     d->parent = parent;
789                     d->parent->d_func()->children.append(this);
790                 }
791                 // no events sent here, this is done at the end of the QWidget constructor
792             } else {
793                 setParent(parent);
794             }
795         } QT_CATCH(...) {
796             d->threadData->deref();
797             QT_RETHROW;
798         }
799     }
800 #if QT_VERSION < 0x60000
801     qt_addObject(this);
802 #endif
803     if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
804         reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
805     Q_TRACE(QObject_ctor, this);
806 }
807 
808 /*!
809     Destroys the object, deleting all its child objects.
810 
811     All signals to and from the object are automatically disconnected, and
812     any pending posted events for the object are removed from the event
813     queue. However, it is often safer to use deleteLater() rather than
814     deleting a QObject subclass directly.
815 
816     \warning All child objects are deleted. If any of these objects
817     are on the stack or global, sooner or later your program will
818     crash. We do not recommend holding pointers to child objects from
819     outside the parent. If you still do, the destroyed() signal gives
820     you an opportunity to detect when an object is destroyed.
821 
822     \warning Deleting a QObject while pending events are waiting to
823     be delivered can cause a crash. You must not delete the QObject
824     directly if it exists in a different thread than the one currently
825     executing. Use deleteLater() instead, which will cause the event
826     loop to delete the object after all pending events have been
827     delivered to it.
828 
829     \sa deleteLater()
830 */
831 
832 QObject::~QObject()
833 {
834     Q_D(QObject);
835     d->wasDeleted = true;
836     d->blockSig = 0; // unblock signals so we always emit destroyed()
837 
838     QtSharedPointer::ExternalRefCountData *sharedRefcount = d->sharedRefcount.load();
839     if (sharedRefcount) {
840         if (sharedRefcount->strongref.load() > 0) {
841             qWarning("QObject: shared QObject was deleted directly. The program is malformed and may crash.");
842             // but continue deleting, it's too late to stop anyway
843         }
844 
845         // indicate to all QWeakPointers that this QObject has now been deleted
846         sharedRefcount->strongref.store(0);
847         if (!sharedRefcount->weakref.deref())
848             delete sharedRefcount;
849     }
850 
851     if (!d->isWidget && d->isSignalConnected(0)) {
852         emit destroyed(this);
853     }
854 
855     if (d->declarativeData) {
856         if (static_cast<QAbstractDeclarativeDataImpl*>(d->declarativeData)->ownedByQml1) {
857             if (QAbstractDeclarativeData::destroyed_qml1)
858                 QAbstractDeclarativeData::destroyed_qml1(d->declarativeData, this);
859         } else {
860             if (QAbstractDeclarativeData::destroyed)
861                 QAbstractDeclarativeData::destroyed(d->declarativeData, this);
862         }
863     }
864 
865     QObjectPrivate::ConnectionData *cd = d->connections.load();
866     if (cd) {
867         if (cd->currentSender) {
868             cd->currentSender->receiverDeleted();
869             cd->currentSender = nullptr;
870         }
871 
872         QBasicMutex *signalSlotMutex = signalSlotLock(this);
873         QBasicMutexLocker locker(signalSlotMutex);
874 
875         // disconnect all receivers
876         int receiverCount = cd->signalVector.count();
877         for (int signal = -1; signal < receiverCount; ++signal) {
878             QObjectPrivate::ConnectionList &connectionList = cd->connectionsForSignal(signal);
879 
880             while (QObjectPrivate::Connection *c = connectionList.first) {
881                 Q_ASSERT(c->receiver);
882 
883                 QBasicMutex *m = signalSlotLock(c->receiver);
884                 bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
885 
886                 cd->removeConnection(c);
887                 Q_ASSERT(connectionList.first != c);
888                 if (needToUnlock)
889                     m->unlock();
890             }
891         }
892 
893         /* Disconnect all senders:
894          */
895         while (QObjectPrivate::Connection *node = cd->senders) {
896             Q_ASSERT(node->receiver);
897             QObject *sender = node->sender;
898             // Send disconnectNotify before removing the connection from sender's connection list.
899             // This ensures any eventual destructor of sender will block on getting receiver's lock
900             // and not finish until we release it.
901             sender->disconnectNotify(QMetaObjectPrivate::signal(sender->metaObject(), node->signal_index));
902             QBasicMutex *m = signalSlotLock(sender);
903             bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
904             //the node has maybe been removed while the mutex was unlocked in relock?
905             if (node != cd->senders) {
906                 // We hold the wrong mutex
907                 Q_ASSERT(needToUnlock);
908                 m->unlock();
909                 continue;
910             }
911 
912             QObjectPrivate::ConnectionData *senderData = sender->d_func()->connections.load();
913             Q_ASSERT(senderData);
914 
915             QtPrivate::QSlotObjectBase *slotObj = nullptr;
916             if (node->isSlotObject) {
917                 slotObj = node->slotObj;
918                 node->isSlotObject = false;
919             }
920 
921             senderData->removeConnection(node);
922             if (needToUnlock)
923                 m->unlock();
924 
925             if (slotObj) {
926                 locker.unlock();
927                 slotObj->destroyIfLastRef();
928                 locker.relock();
929             }
930         }
931 
932         // invalidate all connections on the object and make sure
933         // activate() will skip them
934         cd->currentConnectionId.store(0);
935     }
936     if (cd && !cd->ref.deref())
937         delete cd;
938     d->connections.store(nullptr);
939 
940     if (!d->children.isEmpty())
941         d->deleteChildren();
942 
943 #if QT_VERSION < 0x60000
944     qt_removeObject(this);
945 #endif
946     if (Q_UNLIKELY(qtHookData[QHooks::RemoveQObject]))
947         reinterpret_cast<QHooks::RemoveQObjectCallback>(qtHookData[QHooks::RemoveQObject])(this);
948 
949     Q_TRACE(QObject_dtor, this);
950 
951     if (d->parent)        // remove it from parent object
952         d->setParent_helper(0);
953 }
954 
955 QObjectPrivate::Connection::~Connection()
956 {
957     if (ownArgumentTypes) {
958         const int *v = argumentTypes.load();
959         if (v != &DIRECT_CONNECTION_ONLY)
960             delete [] v;
961     }
962     if (isSlotObject)
963         slotObj->destroyIfLastRef();
964 }
965 
966 
967 /*!
968     \fn const QMetaObject *QObject::metaObject() const
969 
970     Returns a pointer to the meta-object of this object.
971 
972     A meta-object contains information about a class that inherits
973     QObject, e.g. class name, superclass name, properties, signals and
974     slots. Every QObject subclass that contains the Q_OBJECT macro will have a
975     meta-object.
976 
977     The meta-object information is required by the signal/slot
978     connection mechanism and the property system. The inherits()
979     function also makes use of the meta-object.
980 
981     If you have no pointer to an actual object instance but still
982     want to access the meta-object of a class, you can use \l
983     staticMetaObject.
984 
985     Example:
986 
987     \snippet code/src_corelib_kernel_qobject.cpp 1
988 
989     \sa staticMetaObject
990 */
991 
992 /*!
993     \variable QObject::staticMetaObject
994 
995     This variable stores the meta-object for the class.
996 
997     A meta-object contains information about a class that inherits
998     QObject, e.g. class name, superclass name, properties, signals and
999     slots. Every class that contains the Q_OBJECT macro will also have
1000     a meta-object.
1001 
1002     The meta-object information is required by the signal/slot
1003     connection mechanism and the property system. The inherits()
1004     function also makes use of the meta-object.
1005 
1006     If you have a pointer to an object, you can use metaObject() to
1007     retrieve the meta-object associated with that object.
1008 
1009     Example:
1010 
1011     \snippet code/src_corelib_kernel_qobject.cpp 2
1012 
1013     \sa metaObject()
1014 */
1015 
1016 /*!
1017     \fn template <class T> T qobject_cast(QObject *object)
1018     \fn template <class T> T qobject_cast(const QObject *object)
1019     \relates QObject
1020 
1021     Returns the given \a object cast to type T if the object is of type
1022     T (or of a subclass); otherwise returns 0.  If \a object is 0 then
1023     it will also return 0.
1024 
1025     The class T must inherit (directly or indirectly) QObject and be
1026     declared with the \l Q_OBJECT macro.
1027 
1028     A class is considered to inherit itself.
1029 
1030     Example:
1031 
1032     \snippet code/src_corelib_kernel_qobject.cpp 3
1033 
1034     The qobject_cast() function behaves similarly to the standard C++
1035     \c dynamic_cast(), with the advantages that it doesn't require
1036     RTTI support and it works across dynamic library boundaries.
1037 
1038     qobject_cast() can also be used in conjunction with interfaces;
1039     see the \l{tools/plugandpaint/app}{Plug & Paint} example for details.
1040 
1041     \warning If T isn't declared with the Q_OBJECT macro, this
1042     function's return value is undefined.
1043 
1044     \sa QObject::inherits()
1045 */
1046 
1047 /*!
1048     \fn bool QObject::inherits(const char *className) const
1049 
1050     Returns \c true if this object is an instance of a class that
1051     inherits \a className or a QObject subclass that inherits \a
1052     className; otherwise returns \c false.
1053 
1054     A class is considered to inherit itself.
1055 
1056     Example:
1057 
1058     \snippet code/src_corelib_kernel_qobject.cpp 4
1059 
1060     If you need to determine whether an object is an instance of a particular
1061     class for the purpose of casting it, consider using qobject_cast<Type *>(object)
1062     instead.
1063 
1064     \sa metaObject(), qobject_cast()
1065 */
1066 
1067 /*!
1068     \property QObject::objectName
1069 
1070     \brief the name of this object
1071 
1072     You can find an object by name (and type) using findChild().
1073     You can find a set of objects with findChildren().
1074 
1075     \snippet code/src_corelib_kernel_qobject.cpp 5
1076 
1077     By default, this property contains an empty string.
1078 
1079     \sa metaObject(), QMetaObject::className()
1080 */
1081 
1082 QString QObject::objectName() const
1083 {
1084     Q_D(const QObject);
1085     return d->extraData ? d->extraData->objectName : QString();
1086 }
1087 
1088 /*
1089     Sets the object's name to \a name.
1090 */
1091 void QObject::setObjectName(const QString &name)
1092 {
1093     Q_D(QObject);
1094     if (!d->extraData)
1095         d->extraData = new QObjectPrivate::ExtraData;
1096 
1097     if (d->extraData->objectName != name) {
1098         d->extraData->objectName = name;
1099         emit objectNameChanged(d->extraData->objectName, QPrivateSignal());
1100     }
1101 }
1102 
1103 /*! \fn void QObject::objectNameChanged(const QString &objectName)
1104 
1105     This signal is emitted after the object's name has been changed. The new object name is passed as \a objectName.
1106 
1107     \sa QObject::objectName
1108 */
1109 
1110 /*!
1111     \fn bool QObject::isWidgetType() const
1112 
1113     Returns \c true if the object is a widget; otherwise returns \c false.
1114 
1115     Calling this function is equivalent to calling
1116     \c{inherits("QWidget")}, except that it is much faster.
1117 */
1118 
1119 /*!
1120     \fn bool QObject::isWindowType() const
1121 
1122     Returns \c true if the object is a window; otherwise returns \c false.
1123 
1124     Calling this function is equivalent to calling
1125     \c{inherits("QWindow")}, except that it is much faster.
1126 */
1127 
1128 /*!
1129     This virtual function receives events to an object and should
1130     return true if the event \a e was recognized and processed.
1131 
1132     The event() function can be reimplemented to customize the
1133     behavior of an object.
1134 
1135     Make sure you call the parent event class implementation
1136     for all the events you did not handle.
1137 
1138     Example:
1139 
1140     \snippet code/src_corelib_kernel_qobject.cpp 52
1141 
1142     \sa installEventFilter(), timerEvent(), QCoreApplication::sendEvent(),
1143     QCoreApplication::postEvent()
1144 */
1145 
1146 bool QObject::event(QEvent *e)
1147 {
1148     switch (e->type()) {
1149     case QEvent::Timer:
1150         timerEvent((QTimerEvent*)e);
1151         break;
1152 
1153     case QEvent::ChildAdded:
1154     case QEvent::ChildPolished:
1155     case QEvent::ChildRemoved:
1156         childEvent((QChildEvent*)e);
1157         break;
1158 
1159     case QEvent::DeferredDelete:
1160         qDeleteInEventHandler(this);
1161         break;
1162 
1163     case QEvent::MetaCall:
1164         {
1165             QMetaCallEvent *mce = static_cast<QMetaCallEvent*>(e);
1166 
1167             if (!d_func()->connections.load()) {
1168                 QBasicMutexLocker locker(signalSlotLock(this));
1169                 d_func()->ensureConnectionData();
1170             }
1171             QObjectPrivate::Sender sender(this, const_cast<QObject*>(mce->sender()), mce->signalId());
1172 
1173             mce->placeMetaCall(this);
1174             break;
1175         }
1176 
1177     case QEvent::ThreadChange: {
1178         Q_D(QObject);
1179         QThreadData *threadData = d->threadData;
1180         QAbstractEventDispatcher *eventDispatcher = threadData->eventDispatcher.load();
1181         if (eventDispatcher) {
1182             QList<QAbstractEventDispatcher::TimerInfo> timers = eventDispatcher->registeredTimers(this);
1183             if (!timers.isEmpty()) {
1184                 // do not to release our timer ids back to the pool (since the timer ids are moving to a new thread).
1185                 eventDispatcher->unregisterTimers(this);
1186                 QMetaObject::invokeMethod(this, "_q_reregisterTimers", Qt::QueuedConnection,
1187                                           Q_ARG(void*, (new QList<QAbstractEventDispatcher::TimerInfo>(timers))));
1188             }
1189         }
1190         break;
1191     }
1192 
1193     default:
1194         if (e->type() >= QEvent::User) {
1195             customEvent(e);
1196             break;
1197         }
1198         return false;
1199     }
1200     return true;
1201 }
1202 
1203 /*!
1204     \fn void QObject::timerEvent(QTimerEvent *event)
1205 
1206     This event handler can be reimplemented in a subclass to receive
1207     timer events for the object.
1208 
1209     QTimer provides a higher-level interface to the timer
1210     functionality, and also more general information about timers. The
1211     timer event is passed in the \a event parameter.
1212 
1213     \sa startTimer(), killTimer(), event()
1214 */
1215 
1216 void QObject::timerEvent(QTimerEvent *)
1217 {
1218 }
1219 
1220 
1221 /*!
1222     This event handler can be reimplemented in a subclass to receive
1223     child events. The event is passed in the \a event parameter.
1224 
1225     QEvent::ChildAdded and QEvent::ChildRemoved events are sent to
1226     objects when children are added or removed. In both cases you can
1227     only rely on the child being a QObject, or if isWidgetType()
1228     returns \c true, a QWidget. (This is because, in the
1229     \l{QEvent::ChildAdded}{ChildAdded} case, the child is not yet
1230     fully constructed, and in the \l{QEvent::ChildRemoved}{ChildRemoved}
1231     case it might have been destructed already).
1232 
1233     QEvent::ChildPolished events are sent to widgets when children
1234     are polished, or when polished children are added. If you receive
1235     a child polished event, the child's construction is usually
1236     completed. However, this is not guaranteed, and multiple polish
1237     events may be delivered during the execution of a widget's
1238     constructor.
1239 
1240     For every child widget, you receive one
1241     \l{QEvent::ChildAdded}{ChildAdded} event, zero or more
1242     \l{QEvent::ChildPolished}{ChildPolished} events, and one
1243     \l{QEvent::ChildRemoved}{ChildRemoved} event.
1244 
1245     The \l{QEvent::ChildPolished}{ChildPolished} event is omitted if
1246     a child is removed immediately after it is added. If a child is
1247     polished several times during construction and destruction, you
1248     may receive several child polished events for the same child,
1249     each time with a different virtual table.
1250 
1251     \sa event()
1252 */
1253 
1254 void QObject::childEvent(QChildEvent * /* event */)
1255 {
1256 }
1257 
1258 
1259 /*!
1260     This event handler can be reimplemented in a subclass to receive
1261     custom events. Custom events are user-defined events with a type
1262     value at least as large as the QEvent::User item of the
1263     QEvent::Type enum, and is typically a QEvent subclass. The event
1264     is passed in the \a event parameter.
1265 
1266     \sa event(), QEvent
1267 */
1268 void QObject::customEvent(QEvent * /* event */)
1269 {
1270 }
1271 
1272 
1273 
1274 /*!
1275     Filters events if this object has been installed as an event
1276     filter for the \a watched object.
1277 
1278     In your reimplementation of this function, if you want to filter
1279     the \a event out, i.e. stop it being handled further, return
1280     true; otherwise return false.
1281 
1282     Example:
1283     \snippet code/src_corelib_kernel_qobject.cpp 6
1284 
1285     Notice in the example above that unhandled events are passed to
1286     the base class's eventFilter() function, since the base class
1287     might have reimplemented eventFilter() for its own internal
1288     purposes.
1289 
1290     \warning If you delete the receiver object in this function, be
1291     sure to return true. Otherwise, Qt will forward the event to the
1292     deleted object and the program might crash.
1293 
1294     \sa installEventFilter()
1295 */
1296 
1297 bool QObject::eventFilter(QObject * /* watched */, QEvent * /* event */)
1298 {
1299     return false;
1300 }
1301 
1302 /*!
1303     \fn bool QObject::signalsBlocked() const
1304 
1305     Returns \c true if signals are blocked; otherwise returns \c false.
1306 
1307     Signals are not blocked by default.
1308 
1309     \sa blockSignals(), QSignalBlocker
1310 */
1311 
1312 /*!
1313     If \a block is true, signals emitted by this object are blocked
1314     (i.e., emitting a signal will not invoke anything connected to it).
1315     If \a block is false, no such blocking will occur.
1316 
1317     The return value is the previous value of signalsBlocked().
1318 
1319     Note that the destroyed() signal will be emitted even if the signals
1320     for this object have been blocked.
1321 
1322     Signals emitted while being blocked are not buffered.
1323 
1324     \sa signalsBlocked(), QSignalBlocker
1325 */
1326 
1327 bool QObject::blockSignals(bool block) Q_DECL_NOTHROW
1328 {
1329     Q_D(QObject);
1330     bool previous = d->blockSig;
1331     d->blockSig = block;
1332     return previous;
1333 }
1334 
1335 /*!
1336     Returns the thread in which the object lives.
1337 
1338     \sa moveToThread()
1339 */
1340 QThread *QObject::thread() const
1341 {
1342     return d_func()->threadData->thread;
1343 }
1344 
1345 /*!
1346     Changes the thread affinity for this object and its children. The
1347     object cannot be moved if it has a parent. Event processing will
1348     continue in the \a targetThread.
1349 
1350     To move an object to the main thread, use QApplication::instance()
1351     to retrieve a pointer to the current application, and then use
1352     QApplication::thread() to retrieve the thread in which the
1353     application lives. For example:
1354 
1355     \snippet code/src_corelib_kernel_qobject.cpp 7
1356 
1357     If \a targetThread is zero, all event processing for this object
1358     and its children stops.
1359 
1360     Note that all active timers for the object will be reset. The
1361     timers are first stopped in the current thread and restarted (with
1362     the same interval) in the \a targetThread. As a result, constantly
1363     moving an object between threads can postpone timer events
1364     indefinitely.
1365 
1366     A QEvent::ThreadChange event is sent to this object just before
1367     the thread affinity is changed. You can handle this event to
1368     perform any special processing. Note that any new events that are
1369     posted to this object will be handled in the \a targetThread.
1370 
1371     \warning This function is \e not thread-safe; the current thread
1372     must be same as the current thread affinity. In other words, this
1373     function can only "push" an object from the current thread to
1374     another thread, it cannot "pull" an object from any arbitrary
1375     thread to the current thread.
1376 
1377     \sa thread()
1378  */
1379 void QObject::moveToThread(QThread *targetThread)
1380 {
1381     Q_D(QObject);
1382 
1383     if (d->threadData->thread == targetThread) {
1384         // object is already in this thread
1385         return;
1386     }
1387 
1388     if (d->parent != 0) {
1389         qWarning("QObject::moveToThread: Cannot move objects with a parent");
1390         return;
1391     }
1392     if (d->isWidget) {
1393         qWarning("QObject::moveToThread: Widgets cannot be moved to a new thread");
1394         return;
1395     }
1396 
1397     QThreadData *currentData = QThreadData::current();
1398     QThreadData *targetData = targetThread ? QThreadData::get2(targetThread) : nullptr;
1399     if (d->threadData->thread == 0 && currentData == targetData) {
1400         // one exception to the rule: we allow moving objects with no thread affinity to the current thread
1401         currentData = d->threadData;
1402     } else if (d->threadData != currentData) {
1403         qWarning("QObject::moveToThread: Current thread (%p) is not the object's thread (%p).\n"
1404                  "Cannot move to target thread (%p)\n",
1405                  currentData->thread.load(), d->threadData->thread.load(), targetData ? targetData->thread.load() : nullptr);
1406 
1407 #ifdef Q_OS_MAC
1408         qWarning("You might be loading two sets of Qt binaries into the same process. "
1409                  "Check that all plugins are compiled against the right Qt binaries. Export "
1410                  "DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.");
1411 #endif
1412 
1413         return;
1414     }
1415 
1416     // prepare to move
1417     d->moveToThread_helper();
1418 
1419     if (!targetData)
1420         targetData = new QThreadData(0);
1421 
1422     QOrderedMutexLocker locker(&currentData->postEventList.mutex,
1423                                &targetData->postEventList.mutex);
1424 
1425     // keep currentData alive (since we've got it locked)
1426     currentData->ref();
1427 
1428     // move the object
1429     d_func()->setThreadData_helper(currentData, targetData);
1430 
1431     locker.unlock();
1432 
1433     // now currentData can commit suicide if it wants to
1434     currentData->deref();
1435 }
1436 
1437 void QObjectPrivate::moveToThread_helper()
1438 {
1439     Q_Q(QObject);
1440     QEvent e(QEvent::ThreadChange);
1441     QCoreApplication::sendEvent(q, &e);
1442     for (int i = 0; i < children.size(); ++i) {
1443         QObject *child = children.at(i);
1444         child->d_func()->moveToThread_helper();
1445     }
1446 }
1447 
1448 void QObjectPrivate::setThreadData_helper(QThreadData *currentData, QThreadData *targetData)
1449 {
1450     Q_Q(QObject);
1451 
1452     // move posted events
1453     int eventsMoved = 0;
1454     for (int i = 0; i < currentData->postEventList.size(); ++i) {
1455         const QPostEvent &pe = currentData->postEventList.at(i);
1456         if (!pe.event)
1457             continue;
1458         if (pe.receiver == q) {
1459             // move this post event to the targetList
1460             targetData->postEventList.addEvent(pe);
1461             const_cast<QPostEvent &>(pe).event = 0;
1462             ++eventsMoved;
1463         }
1464     }
1465     if (eventsMoved > 0 && targetData->hasEventDispatcher()) {
1466         targetData->canWait = false;
1467         targetData->eventDispatcher.load()->wakeUp();
1468     }
1469 
1470     // the current emitting thread shouldn't restore currentSender after calling moveToThread()
1471     ConnectionData *cd = connections.load();
1472     if (cd && cd->currentSender) {
1473         cd->currentSender->receiverDeleted();
1474         cd->currentSender = nullptr;
1475     }
1476 
1477     // set new thread data
1478     targetData->ref();
1479     threadData->deref();
1480     threadData = targetData;
1481 
1482     for (int i = 0; i < children.size(); ++i) {
1483         QObject *child = children.at(i);
1484         child->d_func()->setThreadData_helper(currentData, targetData);
1485     }
1486 }
1487 
1488 void QObjectPrivate::_q_reregisterTimers(void *pointer)
1489 {
1490     Q_Q(QObject);
1491     QList<QAbstractEventDispatcher::TimerInfo> *timerList = reinterpret_cast<QList<QAbstractEventDispatcher::TimerInfo> *>(pointer);
1492     QAbstractEventDispatcher *eventDispatcher = threadData->eventDispatcher.load();
1493     for (int i = 0; i < timerList->size(); ++i) {
1494         const QAbstractEventDispatcher::TimerInfo &ti = timerList->at(i);
1495         eventDispatcher->registerTimer(ti.timerId, ti.interval, ti.timerType, q);
1496     }
1497     delete timerList;
1498 }
1499 
1500 
1501 //
1502 // The timer flag hasTimer is set when startTimer is called.
1503 // It is not reset when killing the timer because more than
1504 // one timer might be active.
1505 //
1506 
1507 /*!
1508     Starts a timer and returns a timer identifier, or returns zero if
1509     it could not start a timer.
1510 
1511     A timer event will occur every \a interval milliseconds until
1512     killTimer() is called. If \a interval is 0, then the timer event
1513     occurs once every time there are no more window system events to
1514     process.
1515 
1516     The virtual timerEvent() function is called with the QTimerEvent
1517     event parameter class when a timer event occurs. Reimplement this
1518     function to get timer events.
1519 
1520     If multiple timers are running, the QTimerEvent::timerId() can be
1521     used to find out which timer was activated.
1522 
1523     Example:
1524 
1525     \snippet code/src_corelib_kernel_qobject.cpp 8
1526 
1527     Note that QTimer's accuracy depends on the underlying operating system and
1528     hardware. The \a timerType argument allows you to customize the accuracy of
1529     the timer. See Qt::TimerType for information on the different timer types.
1530     Most platforms support an accuracy of 20 milliseconds; some provide more.
1531     If Qt is unable to deliver the requested number of timer events, it will
1532     silently discard some.
1533 
1534     The QTimer class provides a high-level programming interface with
1535     single-shot timers and timer signals instead of events. There is
1536     also a QBasicTimer class that is more lightweight than QTimer and
1537     less clumsy than using timer IDs directly.
1538 
1539     \sa timerEvent(), killTimer(), QTimer::singleShot()
1540 */
1541 
1542 int QObject::startTimer(int interval, Qt::TimerType timerType)
1543 {
1544     Q_D(QObject);
1545 
1546     if (Q_UNLIKELY(interval < 0)) {
1547         qWarning("QObject::startTimer: Timers cannot have negative intervals");
1548         return 0;
1549     }
1550     if (Q_UNLIKELY(!d->threadData->hasEventDispatcher())) {
1551         qWarning("QObject::startTimer: Timers can only be used with threads started with QThread");
1552         return 0;
1553     }
1554     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1555         qWarning("QObject::startTimer: Timers cannot be started from another thread");
1556         return 0;
1557     }
1558     int timerId = d->threadData->eventDispatcher.load()->registerTimer(interval, timerType, this);
1559     if (!d->extraData)
1560         d->extraData = new QObjectPrivate::ExtraData;
1561     d->extraData->runningTimers.append(timerId);
1562     return timerId;
1563 }
1564 
1565 /*!
1566     \since 5.9
1567     \overload
1568     \fn int QObject::startTimer(std::chrono::milliseconds time, Qt::TimerType timerType)
1569 
1570     Starts a timer and returns a timer identifier, or returns zero if
1571     it could not start a timer.
1572 
1573     A timer event will occur every \a time interval until killTimer()
1574     is called. If \a time is equal to \c{std::chrono::duration::zero()},
1575     then the timer event occurs once every time there are no more window
1576     system events to process.
1577 
1578     The virtual timerEvent() function is called with the QTimerEvent
1579     event parameter class when a timer event occurs. Reimplement this
1580     function to get timer events.
1581 
1582     If multiple timers are running, the QTimerEvent::timerId() can be
1583     used to find out which timer was activated.
1584 
1585     Example:
1586 
1587     \snippet code/src_corelib_kernel_qobject.cpp 8
1588 
1589     Note that QTimer's accuracy depends on the underlying operating system and
1590     hardware. The \a timerType argument allows you to customize the accuracy of
1591     the timer. See Qt::TimerType for information on the different timer types.
1592     Most platforms support an accuracy of 20 milliseconds; some provide more.
1593     If Qt is unable to deliver the requested number of timer events, it will
1594     silently discard some.
1595 
1596     The QTimer class provides a high-level programming interface with
1597     single-shot timers and timer signals instead of events. There is
1598     also a QBasicTimer class that is more lightweight than QTimer and
1599     less clumsy than using timer IDs directly.
1600 
1601     \sa timerEvent(), killTimer(), QTimer::singleShot()
1602 */
1603 
1604 /*!
1605     Kills the timer with timer identifier, \a id.
1606 
1607     The timer identifier is returned by startTimer() when a timer
1608     event is started.
1609 
1610     \sa timerEvent(), startTimer()
1611 */
1612 
1613 void QObject::killTimer(int id)
1614 {
1615     Q_D(QObject);
1616     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1617         qWarning("QObject::killTimer: Timers cannot be stopped from another thread");
1618         return;
1619     }
1620     if (id) {
1621         int at = d->extraData ? d->extraData->runningTimers.indexOf(id) : -1;
1622         if (at == -1) {
1623             // timer isn't owned by this object
1624             qWarning("QObject::killTimer(): Error: timer id %d is not valid for object %p (%s, %s), timer has not been killed",
1625                      id,
1626                      this,
1627                      metaObject()->className(),
1628                      qPrintable(objectName()));
1629             return;
1630         }
1631 
1632         if (d->threadData->hasEventDispatcher())
1633             d->threadData->eventDispatcher.load()->unregisterTimer(id);
1634 
1635         d->extraData->runningTimers.remove(at);
1636         QAbstractEventDispatcherPrivate::releaseTimerId(id);
1637     }
1638 }
1639 
1640 
1641 /*!
1642     \fn QObject *QObject::parent() const
1643 
1644     Returns a pointer to the parent object.
1645 
1646     \sa children()
1647 */
1648 
1649 /*!
1650     \fn const QObjectList &QObject::children() const
1651 
1652     Returns a list of child objects.
1653     The QObjectList class is defined in the \c{<QObject>} header
1654     file as the following:
1655 
1656     \quotefromfile kernel/qobject.h
1657     \skipto /typedef .*QObjectList/
1658     \printuntil QObjectList
1659 
1660     The first child added is the \l{QList::first()}{first} object in
1661     the list and the last child added is the \l{QList::last()}{last}
1662     object in the list, i.e. new children are appended at the end.
1663 
1664     Note that the list order changes when QWidget children are
1665     \l{QWidget::raise()}{raised} or \l{QWidget::lower()}{lowered}. A
1666     widget that is raised becomes the last object in the list, and a
1667     widget that is lowered becomes the first object in the list.
1668 
1669     \sa findChild(), findChildren(), parent(), setParent()
1670 */
1671 
1672 
1673 /*!
1674     \fn template<typename T> T *QObject::findChild(const QString &name, Qt::FindChildOptions options) const
1675 
1676     Returns the child of this object that can be cast into type T and
1677     that is called \a name, or 0 if there is no such object.
1678     Omitting the \a name argument causes all object names to be matched.
1679     The search is performed recursively, unless \a options specifies the
1680     option FindDirectChildrenOnly.
1681 
1682     If there is more than one child matching the search, the most
1683     direct ancestor is returned. If there are several direct
1684     ancestors, it is undefined which one will be returned. In that
1685     case, findChildren() should be used.
1686 
1687     This example returns a child \c{QPushButton} of \c{parentWidget}
1688     named \c{"button1"}, even if the button isn't a direct child of
1689     the parent:
1690 
1691     \snippet code/src_corelib_kernel_qobject.cpp 10
1692 
1693     This example returns a \c{QListWidget} child of \c{parentWidget}:
1694 
1695     \snippet code/src_corelib_kernel_qobject.cpp 11
1696 
1697     This example returns a child \c{QPushButton} of \c{parentWidget}
1698     (its direct parent) named \c{"button1"}:
1699 
1700     \snippet code/src_corelib_kernel_qobject.cpp 41
1701 
1702     This example returns a \c{QListWidget} child of \c{parentWidget},
1703     its direct parent:
1704 
1705     \snippet code/src_corelib_kernel_qobject.cpp 42
1706 
1707     \sa findChildren()
1708 */
1709 
1710 /*!
1711     \fn template<typename T> QList<T> QObject::findChildren(const QString &name, Qt::FindChildOptions options) const
1712 
1713     Returns all children of this object with the given \a name that can be
1714     cast to type T, or an empty list if there are no such objects.
1715     Omitting the \a name argument causes all object names to be matched.
1716     The search is performed recursively, unless \a options specifies the
1717     option FindDirectChildrenOnly.
1718 
1719     The following example shows how to find a list of child \c{QWidget}s of
1720     the specified \c{parentWidget} named \c{widgetname}:
1721 
1722     \snippet code/src_corelib_kernel_qobject.cpp 12
1723 
1724     This example returns all \c{QPushButton}s that are children of \c{parentWidget}:
1725 
1726     \snippet code/src_corelib_kernel_qobject.cpp 13
1727 
1728     This example returns all \c{QPushButton}s that are immediate children of \c{parentWidget}:
1729 
1730     \snippet code/src_corelib_kernel_qobject.cpp 43
1731 
1732     \sa findChild()
1733 */
1734 
1735 /*!
1736     \fn template<typename T> QList<T> QObject::findChildren(const QRegExp &regExp, Qt::FindChildOptions options) const
1737     \overload findChildren()
1738     \obsolete
1739 
1740     Returns the children of this object that can be cast to type T
1741     and that have names matching the regular expression \a regExp,
1742     or an empty list if there are no such objects.
1743     The search is performed recursively, unless \a options specifies the
1744     option FindDirectChildrenOnly.
1745 
1746     Use the findChildren overload taking a QRegularExpression instead.
1747 */
1748 
1749 /*!
1750     \fn QList<T> QObject::findChildren(const QRegularExpression &re, Qt::FindChildOptions options) const
1751     \overload findChildren()
1752 
1753     \since 5.0
1754 
1755     Returns the children of this object that can be cast to type T
1756     and that have names matching the regular expression \a re,
1757     or an empty list if there are no such objects.
1758     The search is performed recursively, unless \a options specifies the
1759     option FindDirectChildrenOnly.
1760 */
1761 
1762 /*!
1763     \fn template<typename T> T qFindChild(const QObject *obj, const QString &name)
1764     \relates QObject
1765     \overload qFindChildren()
1766     \obsolete
1767 
1768     This function is equivalent to
1769     \a{obj}->\l{QObject::findChild()}{findChild}<T>(\a name).
1770 
1771     \note This function was provided as a workaround for MSVC 6
1772     which did not support member template functions. It is advised
1773     to use the other form in new code.
1774 
1775     \sa QObject::findChild()
1776 */
1777 
1778 /*!
1779     \fn template<typename T> QList<T> qFindChildren(const QObject *obj, const QString &name)
1780     \relates QObject
1781     \overload qFindChildren()
1782     \obsolete
1783 
1784     This function is equivalent to
1785     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a name).
1786 
1787     \note This function was provided as a workaround for MSVC 6
1788     which did not support member template functions. It is advised
1789     to use the other form in new code.
1790 
1791     \sa QObject::findChildren()
1792 */
1793 
1794 /*!
1795     \fn template<typename T> QList<T> qFindChildren(const QObject *obj, const QRegExp &regExp)
1796     \relates QObject
1797     \overload qFindChildren()
1798 
1799     This function is equivalent to
1800     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a regExp).
1801 
1802     \note This function was provided as a workaround for MSVC 6
1803     which did not support member template functions. It is advised
1804     to use the other form in new code.
1805 
1806     \sa QObject::findChildren()
1807 */
1808 
1809 /*!
1810     \internal
1811 */
1812 void qt_qFindChildren_helper(const QObject *parent, const QString &name,
1813                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1814 {
1815     if (!parent || !list)
1816         return;
1817     const QObjectList &children = parent->children();
1818     QObject *obj;
1819     for (int i = 0; i < children.size(); ++i) {
1820         obj = children.at(i);
1821         if (mo.cast(obj)) {
1822             if (name.isNull() || obj->objectName() == name)
1823                 list->append(obj);
1824         }
1825         if (options & Qt::FindChildrenRecursively)
1826             qt_qFindChildren_helper(obj, name, mo, list, options);
1827     }
1828 }
1829 
1830 #ifndef QT_NO_REGEXP
1831 /*!
1832     \internal
1833 */
1834 void qt_qFindChildren_helper(const QObject *parent, const QRegExp &re,
1835                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1836 {
1837     if (!parent || !list)
1838         return;
1839     const QObjectList &children = parent->children();
1840     QRegExp reCopy = re;
1841     QObject *obj;
1842     for (int i = 0; i < children.size(); ++i) {
1843         obj = children.at(i);
1844         if (mo.cast(obj) && reCopy.indexIn(obj->objectName()) != -1)
1845             list->append(obj);
1846 
1847         if (options & Qt::FindChildrenRecursively)
1848             qt_qFindChildren_helper(obj, re, mo, list, options);
1849     }
1850 }
1851 #endif // QT_NO_REGEXP
1852 
1853 #if QT_CONFIG(regularexpression)
1854 /*!
1855     \internal
1856 */
1857 void qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &re,
1858                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1859 {
1860     if (!parent || !list)
1861         return;
1862     const QObjectList &children = parent->children();
1863     QObject *obj;
1864     for (int i = 0; i < children.size(); ++i) {
1865         obj = children.at(i);
1866         if (mo.cast(obj)) {
1867             QRegularExpressionMatch m = re.match(obj->objectName());
1868             if (m.hasMatch())
1869                 list->append(obj);
1870         }
1871         if (options & Qt::FindChildrenRecursively)
1872             qt_qFindChildren_helper(obj, re, mo, list, options);
1873     }
1874 }
1875 #endif // QT_CONFIG(regularexpression)
1876 
1877 /*!
1878     \internal
1879  */
1880 QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo, Qt::FindChildOptions options)
1881 {
1882     if (!parent)
1883         return 0;
1884     const QObjectList &children = parent->children();
1885     QObject *obj;
1886     int i;
1887     for (i = 0; i < children.size(); ++i) {
1888         obj = children.at(i);
1889         if (mo.cast(obj) && (name.isNull() || obj->objectName() == name))
1890             return obj;
1891     }
1892     if (options & Qt::FindChildrenRecursively) {
1893         for (i = 0; i < children.size(); ++i) {
1894             obj = qt_qFindChild_helper(children.at(i), name, mo, options);
1895             if (obj)
1896                 return obj;
1897         }
1898     }
1899     return 0;
1900 }
1901 
1902 /*!
1903     Makes the object a child of \a parent.
1904 
1905     \sa parent(), children()
1906 */
1907 void QObject::setParent(QObject *parent)
1908 {
1909     Q_D(QObject);
1910     Q_ASSERT(!d->isWidget);
1911     d->setParent_helper(parent);
1912 }
1913 
1914 void QObjectPrivate::deleteChildren()
1915 {
1916     Q_ASSERT_X(!isDeletingChildren, "QObjectPrivate::deleteChildren()", "isDeletingChildren already set, did this function recurse?");
1917     isDeletingChildren = true;
1918     // delete children objects
1919     // don't use qDeleteAll as the destructor of the child might
1920     // delete siblings
1921     for (int i = 0; i < children.count(); ++i) {
1922         currentChildBeingDeleted = children.at(i);
1923         children[i] = 0;
1924         delete currentChildBeingDeleted;
1925     }
1926     children.clear();
1927     currentChildBeingDeleted = 0;
1928     isDeletingChildren = false;
1929 }
1930 
1931 void QObjectPrivate::setParent_helper(QObject *o)
1932 {
1933     Q_Q(QObject);
1934     if (o == parent)
1935         return;
1936     if (parent) {
1937         QObjectPrivate *parentD = parent->d_func();
1938         if (parentD->isDeletingChildren && wasDeleted
1939             && parentD->currentChildBeingDeleted == q) {
1940             // don't do anything since QObjectPrivate::deleteChildren() already
1941             // cleared our entry in parentD->children.
1942         } else {
1943             const int index = parentD->children.indexOf(q);
1944             if (parentD->isDeletingChildren) {
1945                 parentD->children[index] = 0;
1946             } else {
1947                 parentD->children.removeAt(index);
1948                 if (sendChildEvents && parentD->receiveChildEvents) {
1949                     QChildEvent e(QEvent::ChildRemoved, q);
1950                     QCoreApplication::sendEvent(parent, &e);
1951                 }
1952             }
1953         }
1954     }
1955     parent = o;
1956     if (parent) {
1957         // object hierarchies are constrained to a single thread
1958         if (threadData != parent->d_func()->threadData) {
1959             qWarning("QObject::setParent: Cannot set parent, new parent is in a different thread");
1960             parent = 0;
1961             return;
1962         }
1963         parent->d_func()->children.append(q);
1964         if(sendChildEvents && parent->d_func()->receiveChildEvents) {
1965             if (!isWidget) {
1966                 QChildEvent e(QEvent::ChildAdded, q);
1967                 QCoreApplication::sendEvent(parent, &e);
1968             }
1969         }
1970     }
1971     if (!wasDeleted && !isDeletingChildren && declarativeData && QAbstractDeclarativeData::parentChanged)
1972         QAbstractDeclarativeData::parentChanged(declarativeData, q, o);
1973 }
1974 
1975 /*!
1976     \fn void QObject::installEventFilter(QObject *filterObj)
1977 
1978     Installs an event filter \a filterObj on this object. For example:
1979     \snippet code/src_corelib_kernel_qobject.cpp 14
1980 
1981     An event filter is an object that receives all events that are
1982     sent to this object. The filter can either stop the event or
1983     forward it to this object. The event filter \a filterObj receives
1984     events via its eventFilter() function. The eventFilter() function
1985     must return true if the event should be filtered, (i.e. stopped);
1986     otherwise it must return false.
1987 
1988     If multiple event filters are installed on a single object, the
1989     filter that was installed last is activated first.
1990 
1991     Here's a \c KeyPressEater class that eats the key presses of its
1992     monitored objects:
1993 
1994     \snippet code/src_corelib_kernel_qobject.cpp 15
1995 
1996     And here's how to install it on two widgets:
1997 
1998     \snippet code/src_corelib_kernel_qobject.cpp 16
1999 
2000     The QShortcut class, for example, uses this technique to intercept
2001     shortcut key presses.
2002 
2003     \warning If you delete the receiver object in your eventFilter()
2004     function, be sure to return true. If you return false, Qt sends
2005     the event to the deleted object and the program will crash.
2006 
2007     Note that the filtering object must be in the same thread as this
2008     object. If \a filterObj is in a different thread, this function does
2009     nothing. If either \a filterObj or this object are moved to a different
2010     thread after calling this function, the event filter will not be
2011     called until both objects have the same thread affinity again (it
2012     is \e not removed).
2013 
2014     \sa removeEventFilter(), eventFilter(), event()
2015 */
2016 
2017 void QObject::installEventFilter(QObject *obj)
2018 {
2019     Q_D(QObject);
2020     if (!obj)
2021         return;
2022     if (d->threadData != obj->d_func()->threadData) {
2023         qWarning("QObject::installEventFilter(): Cannot filter events for objects in a different thread.");
2024         return;
2025     }
2026 
2027     if (!d->extraData)
2028         d->extraData = new QObjectPrivate::ExtraData;
2029 
2030     // clean up unused items in the list
2031     d->extraData->eventFilters.removeAll((QObject*)0);
2032     d->extraData->eventFilters.removeAll(obj);
2033     d->extraData->eventFilters.prepend(obj);
2034 }
2035 
2036 /*!
2037     Removes an event filter object \a obj from this object. The
2038     request is ignored if such an event filter has not been installed.
2039 
2040     All event filters for this object are automatically removed when
2041     this object is destroyed.
2042 
2043     It is always safe to remove an event filter, even during event
2044     filter activation (i.e. from the eventFilter() function).
2045 
2046     \sa installEventFilter(), eventFilter(), event()
2047 */
2048 
2049 void QObject::removeEventFilter(QObject *obj)
2050 {
2051     Q_D(QObject);
2052     if (d->extraData) {
2053         for (int i = 0; i < d->extraData->eventFilters.count(); ++i) {
2054             if (d->extraData->eventFilters.at(i) == obj)
2055                 d->extraData->eventFilters[i] = 0;
2056         }
2057     }
2058 }
2059 
2060 
2061 /*!
2062     \fn void QObject::destroyed(QObject *obj)
2063 
2064     This signal is emitted immediately before the object \a obj is
2065     destroyed, after any instances of QPointer have been notified,
2066     and can not be blocked.
2067 
2068     All the objects's children are destroyed immediately after this
2069     signal is emitted.
2070 
2071     \sa deleteLater(), QPointer
2072 */
2073 
2074 /*!
2075     Schedules this object for deletion.
2076 
2077     The object will be deleted when control returns to the event
2078     loop. If the event loop is not running when this function is
2079     called (e.g. deleteLater() is called on an object before
2080     QCoreApplication::exec()), the object will be deleted once the
2081     event loop is started. If deleteLater() is called after the main event loop
2082     has stopped, the object will not be deleted.
2083     Since Qt 4.8, if deleteLater() is called on an object that lives in a
2084     thread with no running event loop, the object will be destroyed when the
2085     thread finishes.
2086 
2087     Note that entering and leaving a new event loop (e.g., by opening a modal
2088     dialog) will \e not perform the deferred deletion; for the object to be
2089     deleted, the control must return to the event loop from which
2090     deleteLater() was called.
2091 
2092     \b{Note:} It is safe to call this function more than once; when the
2093     first deferred deletion event is delivered, any pending events for the
2094     object are removed from the event queue.
2095 
2096     \sa destroyed(), QPointer
2097 */
2098 void QObject::deleteLater()
2099 {
2100     QCoreApplication::postEvent(this, new QDeferredDeleteEvent());
2101 }
2102 
2103 /*!
2104     \fn QString QObject::tr(const char *sourceText, const char *disambiguation, int n)
2105     \reentrant
2106 
2107     Returns a translated version of \a sourceText, optionally based on a
2108     \a disambiguation string and value of \a n for strings containing plurals;
2109     otherwise returns QString::fromUtf8(\a sourceText) if no appropriate
2110     translated string is available.
2111 
2112     Example:
2113     \snippet ../widgets/mainwindows/sdi/mainwindow.cpp implicit tr context
2114     \dots
2115 
2116     If the same \a sourceText is used in different roles within the
2117     same context, an additional identifying string may be passed in
2118     \a disambiguation (0 by default). In Qt 4.4 and earlier, this was
2119     the preferred way to pass comments to translators.
2120 
2121     Example:
2122 
2123     \snippet code/src_corelib_kernel_qobject.cpp 17
2124     \dots
2125 
2126     See \l{Writing Source Code for Translation} for a detailed description of
2127     Qt's translation mechanisms in general, and the
2128     \l{Writing Source Code for Translation#Disambiguation}{Disambiguation}
2129     section for information on disambiguation.
2130 
2131     \warning This method is reentrant only if all translators are
2132     installed \e before calling this method. Installing or removing
2133     translators while performing translations is not supported. Doing
2134     so will probably result in crashes or other undesirable behavior.
2135 
2136     \sa QCoreApplication::translate(), {Internationalization with Qt}
2137 */
2138 
2139 /*!
2140     \fn QString QObject::trUtf8(const char *sourceText, const char *disambiguation, int n)
2141     \reentrant
2142     \obsolete
2143 
2144     Returns a translated version of \a sourceText, or
2145     QString::fromUtf8(\a sourceText) if there is no appropriate
2146     version. It is otherwise identical to tr(\a sourceText, \a
2147     disambiguation, \a n).
2148 
2149     \warning This method is reentrant only if all translators are
2150     installed \e before calling this method. Installing or removing
2151     translators while performing translations is not supported. Doing
2152     so will probably result in crashes or other undesirable behavior.
2153 
2154     \warning For portability reasons, we recommend that you use
2155     escape sequences for specifying non-ASCII characters in string
2156     literals to trUtf8(). For example:
2157 
2158     \snippet code/src_corelib_kernel_qobject.cpp 20
2159 
2160     \sa tr(), QCoreApplication::translate(), {Internationalization with Qt}
2161 */
2162 
2163 
2164 
2165 
2166 /*****************************************************************************
2167   Signals and slots
2168  *****************************************************************************/
2169 
2170 
2171 const char *qFlagLocation(const char *method)
2172 {
2173     QThreadData *currentThreadData = QThreadData::current(false);
2174     if (currentThreadData != 0)
2175         currentThreadData->flaggedSignatures.store(method);
2176     return method;
2177 }
2178 
2179 static int extract_code(const char *member)
2180 {
2181     // extract code, ensure QMETHOD_CODE <= code <= QSIGNAL_CODE
2182     return (((int)(*member) - '0') & 0x3);
2183 }
2184 
2185 static const char * extract_location(const char *member)
2186 {
2187     if (QThreadData::current()->flaggedSignatures.contains(member)) {
2188         // signature includes location information after the first null-terminator
2189         const char *location = member + qstrlen(member) + 1;
2190         if (*location != '\0')
2191             return location;
2192     }
2193     return 0;
2194 }
2195 
2196 static bool check_signal_macro(const QObject *sender, const char *signal,
2197                                 const char *func, const char *op)
2198 {
2199     int sigcode = extract_code(signal);
2200     if (sigcode != QSIGNAL_CODE) {
2201         if (sigcode == QSLOT_CODE)
2202             qWarning("QObject::%s: Attempt to %s non-signal %s::%s",
2203                      func, op, sender->metaObject()->className(), signal+1);
2204         else
2205             qWarning("QObject::%s: Use the SIGNAL macro to %s %s::%s",
2206                      func, op, sender->metaObject()->className(), signal);
2207         return false;
2208     }
2209     return true;
2210 }
2211 
2212 static bool check_method_code(int code, const QObject *object,
2213                                const char *method, const char *func)
2214 {
2215     if (code != QSLOT_CODE && code != QSIGNAL_CODE) {
2216         qWarning("QObject::%s: Use the SLOT or SIGNAL macro to "
2217                  "%s %s::%s", func, func, object->metaObject()->className(), method);
2218         return false;
2219     }
2220     return true;
2221 }
2222 
2223 static void err_method_notfound(const QObject *object,
2224                                 const char *method, const char *func)
2225 {
2226     const char *type = "method";
2227     switch (extract_code(method)) {
2228         case QSLOT_CODE:   type = "slot";   break;
2229         case QSIGNAL_CODE: type = "signal"; break;
2230     }
2231     const char *loc = extract_location(method);
2232     if (strchr(method,')') == 0)                // common typing mistake
2233         qWarning("QObject::%s: Parentheses expected, %s %s::%s%s%s",
2234                  func, type, object->metaObject()->className(), method+1,
2235                  loc ? " in ": "", loc ? loc : "");
2236     else
2237         qWarning("QObject::%s: No such %s %s::%s%s%s",
2238                  func, type, object->metaObject()->className(), method+1,
2239                  loc ? " in ": "", loc ? loc : "");
2240 
2241 }
2242 
2243 
2244 static void err_info_about_objects(const char * func,
2245                                     const QObject * sender,
2246                                     const QObject * receiver)
2247 {
2248     QString a = sender ? sender->objectName() : QString();
2249     QString b = receiver ? receiver->objectName() : QString();
2250     if (!a.isEmpty())
2251         qWarning("QObject::%s:  (sender name:   '%s')", func, a.toLocal8Bit().data());
2252     if (!b.isEmpty())
2253         qWarning("QObject::%s:  (receiver name: '%s')", func, b.toLocal8Bit().data());
2254 }
2255 
2256 /*!
2257     Returns a pointer to the object that sent the signal, if called in
2258     a slot activated by a signal; otherwise it returns 0. The pointer
2259     is valid only during the execution of the slot that calls this
2260     function from this object's thread context.
2261 
2262     The pointer returned by this function becomes invalid if the
2263     sender is destroyed, or if the slot is disconnected from the
2264     sender's signal.
2265 
2266     \warning This function violates the object-oriented principle of
2267     modularity. However, getting access to the sender might be useful
2268     when many signals are connected to a single slot.
2269 
2270     \warning As mentioned above, the return value of this function is
2271     not valid when the slot is called via a Qt::DirectConnection from
2272     a thread different from this object's thread. Do not use this
2273     function in this type of scenario.
2274 
2275     \sa senderSignalIndex()
2276 */
2277 
2278 QObject *QObject::sender() const
2279 {
2280     Q_D(const QObject);
2281 
2282     QBasicMutexLocker locker(signalSlotLock(this));
2283     QObjectPrivate::ConnectionData *cd = d->connections.load();
2284     if (!cd || !cd->currentSender)
2285         return nullptr;
2286 
2287     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2288         if (c->sender == cd->currentSender->sender)
2289             return cd->currentSender->sender;
2290     }
2291 
2292     return 0;
2293 }
2294 
2295 /*!
2296     \since 4.8
2297 
2298     Returns the meta-method index of the signal that called the currently
2299     executing slot, which is a member of the class returned by sender().
2300     If called outside of a slot activated by a signal, -1 is returned.
2301 
2302     For signals with default parameters, this function will always return
2303     the index with all parameters, regardless of which was used with
2304     connect(). For example, the signal \c {destroyed(QObject *obj = 0)}
2305     will have two different indexes (with and without the parameter), but
2306     this function will always return the index with a parameter. This does
2307     not apply when overloading signals with different parameters.
2308 
2309     \warning This function violates the object-oriented principle of
2310     modularity. However, getting access to the signal index might be useful
2311     when many signals are connected to a single slot.
2312 
2313     \warning The return value of this function is not valid when the slot
2314     is called via a Qt::DirectConnection from a thread different from this
2315     object's thread. Do not use this function in this type of scenario.
2316 
2317     \sa sender(), QMetaObject::indexOfSignal(), QMetaObject::method()
2318 */
2319 
2320 int QObject::senderSignalIndex() const
2321 {
2322     Q_D(const QObject);
2323 
2324     QBasicMutexLocker locker(signalSlotLock(this));
2325     QObjectPrivate::ConnectionData *cd = d->connections.load();
2326     if (!cd || !cd->currentSender)
2327         return -1;
2328 
2329     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2330         if (c->sender == cd->currentSender->sender) {
2331             // Convert from signal range to method range
2332             return QMetaObjectPrivate::signal(c->sender->metaObject(), cd->currentSender->signal).methodIndex();
2333         }
2334     }
2335 
2336     return -1;
2337 }
2338 
2339 /*!
2340     Returns the number of receivers connected to the \a signal.
2341 
2342     Since both slots and signals can be used as receivers for signals,
2343     and the same connections can be made many times, the number of
2344     receivers is the same as the number of connections made from this
2345     signal.
2346 
2347     When calling this function, you can use the \c SIGNAL() macro to
2348     pass a specific signal:
2349 
2350     \snippet code/src_corelib_kernel_qobject.cpp 21
2351 
2352     \warning This function violates the object-oriented principle of
2353     modularity. However, it might be useful when you need to perform
2354     expensive initialization only if something is connected to a
2355     signal.
2356 
2357     \sa isSignalConnected()
2358 */
2359 
2360 int QObject::receivers(const char *signal) const
2361 {
2362     Q_D(const QObject);
2363     int receivers = 0;
2364     QObjectPrivate::ConnectionData *cd = d->connections.load();
2365     if (signal && cd) {
2366         QByteArray signal_name = QMetaObject::normalizedSignature(signal);
2367         signal = signal_name;
2368 #ifndef QT_NO_DEBUG
2369         if (!check_signal_macro(this, signal, "receivers", "bind"))
2370             return 0;
2371 #endif
2372         signal++; // skip code
2373         int signal_index = d->signalIndex(signal);
2374         if (signal_index < 0) {
2375 #ifndef QT_NO_DEBUG
2376             err_method_notfound(this, signal-1, "receivers");
2377 #endif
2378             return 0;
2379         }
2380 
2381         if (!d->isSignalConnected(signal_index))
2382             return receivers;
2383 
2384         if (d->declarativeData && QAbstractDeclarativeData::receivers) {
2385             receivers += QAbstractDeclarativeData::receivers(d->declarativeData, this,
2386                                                              signal_index);
2387         }
2388 
2389         QBasicMutexLocker locker(signalSlotLock(this));
2390         if (signal_index < cd->signalVector.count()) {
2391             const QObjectPrivate::Connection *c =
2392                 cd->signalVector.at(signal_index).first;
2393             while (c) {
2394                 receivers += c->receiver ? 1 : 0;
2395                 c = c->nextConnectionList;
2396             }
2397         }
2398     }
2399     return receivers;
2400 }
2401 
2402 /*!
2403     \since 5.0
2404     Returns \c true if the \a signal is connected to at least one receiver,
2405     otherwise returns \c false.
2406 
2407     \a signal must be a signal member of this object, otherwise the behaviour
2408     is undefined.
2409 
2410     \snippet code/src_corelib_kernel_qobject.cpp 49
2411 
2412     As the code snippet above illustrates, you can use this function
2413     to avoid emitting a signal that nobody listens to.
2414 
2415     \warning This function violates the object-oriented principle of
2416     modularity. However, it might be useful when you need to perform
2417     expensive initialization only if something is connected to a
2418     signal.
2419 */
2420 bool QObject::isSignalConnected(const QMetaMethod &signal) const
2421 {
2422     Q_D(const QObject);
2423     if (!signal.mobj)
2424         return false;
2425 
2426     Q_ASSERT_X(signal.mobj->cast(this) && signal.methodType() == QMetaMethod::Signal,
2427                "QObject::isSignalConnected" , "the parameter must be a signal member of the object");
2428     uint signalIndex = (signal.handle - QMetaObjectPrivate::get(signal.mobj)->methodData)/5;
2429 
2430     if (signal.mobj->d.data[signal.handle + 4] & MethodCloned)
2431         signalIndex = QMetaObjectPrivate::originalClone(signal.mobj, signalIndex);
2432 
2433     signalIndex += QMetaObjectPrivate::signalOffset(signal.mobj);
2434 
2435     QBasicMutexLocker locker(signalSlotLock(this));
2436     return d->isSignalConnected(signalIndex, true);
2437 }
2438 
2439 /*!
2440     \internal
2441 
2442     This helper function calculates signal and method index for the given
2443     member in the specified class.
2444 
2445     \list
2446     \li If member.mobj is 0 then both signalIndex and methodIndex are set to -1.
2447 
2448     \li If specified member is not a member of obj instance class (or one of
2449     its parent classes) then both signalIndex and methodIndex are set to -1.
2450     \endlist
2451 
2452     This function is used by QObject::connect and QObject::disconnect which
2453     are working with QMetaMethod.
2454 
2455     \a signalIndex is set to the signal index of member. If the member
2456     specified is not signal this variable is set to -1.
2457 
2458     \a methodIndex is set to the method index of the member. If the
2459     member is not a method of the object specified by the \a obj argument this
2460     variable is set to -1.
2461 */
2462 void QMetaObjectPrivate::memberIndexes(const QObject *obj,
2463                                        const QMetaMethod &member,
2464                                        int *signalIndex, int *methodIndex)
2465 {
2466     *signalIndex = -1;
2467     *methodIndex = -1;
2468     if (!obj || !member.mobj)
2469         return;
2470     const QMetaObject *m = obj->metaObject();
2471     // Check that member is member of obj class
2472     while (m != 0 && m != member.mobj)
2473         m = m->d.superdata;
2474     if (!m)
2475         return;
2476     *signalIndex = *methodIndex = (member.handle - get(member.mobj)->methodData)/5;
2477 
2478     int signalOffset;
2479     int methodOffset;
2480     computeOffsets(m, &signalOffset, &methodOffset);
2481 
2482     *methodIndex += methodOffset;
2483     if (member.methodType() == QMetaMethod::Signal) {
2484         *signalIndex = originalClone(m, *signalIndex);
2485         *signalIndex += signalOffset;
2486     } else {
2487         *signalIndex = -1;
2488     }
2489 }
2490 
2491 #ifndef QT_NO_DEBUG
2492 static inline void check_and_warn_compat(const QMetaObject *sender, const QMetaMethod &signal,
2493                                          const QMetaObject *receiver, const QMetaMethod &method)
2494 {
2495     if (signal.attributes() & QMetaMethod::Compatibility) {
2496         if (!(method.attributes() & QMetaMethod::Compatibility))
2497             qWarning("QObject::connect: Connecting from COMPAT signal (%s::%s)",
2498                      sender->className(), signal.methodSignature().constData());
2499     } else if ((method.attributes() & QMetaMethod::Compatibility) &&
2500                method.methodType() == QMetaMethod::Signal) {
2501         qWarning("QObject::connect: Connecting from %s::%s to COMPAT slot (%s::%s)",
2502                  sender->className(), signal.methodSignature().constData(),
2503                  receiver->className(), method.methodSignature().constData());
2504     }
2505 }
2506 #endif
2507 
2508 /*!
2509     \threadsafe
2510 
2511     Creates a connection of the given \a type from the \a signal in
2512     the \a sender object to the \a method in the \a receiver object.
2513     Returns a handle to the connection that can be used to disconnect
2514     it later.
2515 
2516     You must use the \c SIGNAL() and \c SLOT() macros when specifying
2517     the \a signal and the \a method, for example:
2518 
2519     \snippet code/src_corelib_kernel_qobject.cpp 22
2520 
2521     This example ensures that the label always displays the current
2522     scroll bar value. Note that the signal and slots parameters must not
2523     contain any variable names, only the type. E.g. the following would
2524     not work and return false:
2525 
2526     \snippet code/src_corelib_kernel_qobject.cpp 23
2527 
2528     A signal can also be connected to another signal:
2529 
2530     \snippet code/src_corelib_kernel_qobject.cpp 24
2531 
2532     In this example, the \c MyWidget constructor relays a signal from
2533     a private member variable, and makes it available under a name
2534     that relates to \c MyWidget.
2535 
2536     A signal can be connected to many slots and signals. Many signals
2537     can be connected to one slot.
2538 
2539     If a signal is connected to several slots, the slots are activated
2540     in the same order in which the connections were made, when the
2541     signal is emitted.
2542 
2543     The function returns a QMetaObject::Connection that represents
2544     a handle to a connection if it successfully
2545     connects the signal to the slot. The connection handle will be invalid
2546     if it cannot create the connection, for example, if QObject is unable
2547     to verify the existence of either \a signal or \a method, or if their
2548     signatures aren't compatible.
2549     You can check if the handle is valid by casting it to a bool.
2550 
2551     By default, a signal is emitted for every connection you make;
2552     two signals are emitted for duplicate connections. You can break
2553     all of these connections with a single disconnect() call.
2554     If you pass the Qt::UniqueConnection \a type, the connection will only
2555     be made if it is not a duplicate. If there is already a duplicate
2556     (exact same signal to the exact same slot on the same objects),
2557     the connection will fail and connect will return an invalid QMetaObject::Connection.
2558 
2559     \note Qt::UniqueConnections do not work for lambdas, non-member functions
2560     and functors; they only apply to connecting to member functions.
2561 
2562     The optional \a type parameter describes the type of connection
2563     to establish. In particular, it determines whether a particular
2564     signal is delivered to a slot immediately or queued for delivery
2565     at a later time. If the signal is queued, the parameters must be
2566     of types that are known to Qt's meta-object system, because Qt
2567     needs to copy the arguments to store them in an event behind the
2568     scenes. If you try to use a queued connection and get the error
2569     message
2570 
2571     \snippet code/src_corelib_kernel_qobject.cpp 25
2572 
2573     call qRegisterMetaType() to register the data type before you
2574     establish the connection.
2575 
2576     \sa disconnect(), sender(), qRegisterMetaType(), Q_DECLARE_METATYPE(),
2577     {Differences between String-Based and Functor-Based Connections}
2578 */
2579 QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal,
2580                                      const QObject *receiver, const char *method,
2581                                      Qt::ConnectionType type)
2582 {
2583     if (sender == 0 || receiver == 0 || signal == 0 || method == 0) {
2584         qWarning("QObject::connect: Cannot connect %s::%s to %s::%s",
2585                  sender ? sender->metaObject()->className() : "(null)",
2586                  (signal && *signal) ? signal+1 : "(null)",
2587                  receiver ? receiver->metaObject()->className() : "(null)",
2588                  (method && *method) ? method+1 : "(null)");
2589         return QMetaObject::Connection(0);
2590     }
2591     QByteArray tmp_signal_name;
2592 
2593     if (!check_signal_macro(sender, signal, "connect", "bind"))
2594         return QMetaObject::Connection(0);
2595     const QMetaObject *smeta = sender->metaObject();
2596     const char *signal_arg = signal;
2597     ++signal; //skip code
2598     QArgumentTypeArray signalTypes;
2599     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
2600     QByteArray signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2601     int signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2602             &smeta, signalName, signalTypes.size(), signalTypes.constData());
2603     if (signal_index < 0) {
2604         // check for normalized signatures
2605         tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
2606         signal = tmp_signal_name.constData() + 1;
2607 
2608         signalTypes.clear();
2609         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2610         smeta = sender->metaObject();
2611         signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2612                 &smeta, signalName, signalTypes.size(), signalTypes.constData());
2613     }
2614     if (signal_index < 0) {
2615         err_method_notfound(sender, signal_arg, "connect");
2616         err_info_about_objects("connect", sender, receiver);
2617         return QMetaObject::Connection(0);
2618     }
2619     signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
2620     signal_index += QMetaObjectPrivate::signalOffset(smeta);
2621 
2622     QByteArray tmp_method_name;
2623     int membcode = extract_code(method);
2624 
2625     if (!check_method_code(membcode, receiver, method, "connect"))
2626         return QMetaObject::Connection(0);
2627     const char *method_arg = method;
2628     ++method; // skip code
2629 
2630     QArgumentTypeArray methodTypes;
2631     QByteArray methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2632     const QMetaObject *rmeta = receiver->metaObject();
2633     int method_index_relative = -1;
2634     Q_ASSERT(QMetaObjectPrivate::get(rmeta)->revision >= 7);
2635     switch (membcode) {
2636     case QSLOT_CODE:
2637         method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2638                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2639         break;
2640     case QSIGNAL_CODE:
2641         method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2642                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2643         break;
2644     }
2645     if (method_index_relative < 0) {
2646         // check for normalized methods
2647         tmp_method_name = QMetaObject::normalizedSignature(method);
2648         method = tmp_method_name.constData();
2649 
2650         methodTypes.clear();
2651         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2652         // rmeta may have been modified above
2653         rmeta = receiver->metaObject();
2654         switch (membcode) {
2655         case QSLOT_CODE:
2656             method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2657                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2658             break;
2659         case QSIGNAL_CODE:
2660             method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2661                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2662             break;
2663         }
2664     }
2665 
2666     if (method_index_relative < 0) {
2667         err_method_notfound(receiver, method_arg, "connect");
2668         err_info_about_objects("connect", sender, receiver);
2669         return QMetaObject::Connection(0);
2670     }
2671 
2672     if (!QMetaObjectPrivate::checkConnectArgs(signalTypes.size(), signalTypes.constData(),
2673                                               methodTypes.size(), methodTypes.constData())) {
2674         qWarning("QObject::connect: Incompatible sender/receiver arguments"
2675                  "\n        %s::%s --> %s::%s",
2676                  sender->metaObject()->className(), signal,
2677                  receiver->metaObject()->className(), method);
2678         return QMetaObject::Connection(0);
2679     }
2680 
2681     int *types = 0;
2682     if ((type == Qt::QueuedConnection)
2683             && !(types = queuedConnectionTypes(signalTypes.constData(), signalTypes.size()))) {
2684         return QMetaObject::Connection(0);
2685     }
2686 
2687 #ifndef QT_NO_DEBUG
2688     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
2689     QMetaMethod rmethod = rmeta->method(method_index_relative + rmeta->methodOffset());
2690     check_and_warn_compat(smeta, smethod, rmeta, rmethod);
2691 #endif
2692     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2693         sender, signal_index, smeta, receiver, method_index_relative, rmeta ,type, types));
2694     return handle;
2695 }
2696 
2697 /*!
2698     \since 4.8
2699 
2700     Creates a connection of the given \a type from the \a signal in
2701     the \a sender object to the \a method in the \a receiver object.
2702     Returns a handle to the connection that can be used to disconnect
2703     it later.
2704 
2705     The Connection handle will be invalid  if it cannot create the
2706     connection, for example, the parameters were invalid.
2707     You can check if the QMetaObject::Connection is valid by casting it to a bool.
2708 
2709     This function works in the same way as
2710     \c {connect(const QObject *sender, const char *signal,
2711             const QObject *receiver, const char *method,
2712             Qt::ConnectionType type)}
2713     but it uses QMetaMethod to specify signal and method.
2714 
2715     \sa connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)
2716  */
2717 QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal,
2718                                      const QObject *receiver, const QMetaMethod &method,
2719                                      Qt::ConnectionType type)
2720 {
2721     if (sender == 0
2722             || receiver == 0
2723             || signal.methodType() != QMetaMethod::Signal
2724             || method.methodType() == QMetaMethod::Constructor) {
2725         qWarning("QObject::connect: Cannot connect %s::%s to %s::%s",
2726                  sender ? sender->metaObject()->className() : "(null)",
2727                  signal.methodSignature().constData(),
2728                  receiver ? receiver->metaObject()->className() : "(null)",
2729                  method.methodSignature().constData() );
2730         return QMetaObject::Connection(0);
2731     }
2732 
2733     int signal_index;
2734     int method_index;
2735     {
2736         int dummy;
2737         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
2738         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
2739     }
2740 
2741     const QMetaObject *smeta = sender->metaObject();
2742     const QMetaObject *rmeta = receiver->metaObject();
2743     if (signal_index == -1) {
2744         qWarning("QObject::connect: Can't find signal %s on instance of class %s",
2745                  signal.methodSignature().constData(), smeta->className());
2746         return QMetaObject::Connection(0);
2747     }
2748     if (method_index == -1) {
2749         qWarning("QObject::connect: Can't find method %s on instance of class %s",
2750                  method.methodSignature().constData(), rmeta->className());
2751         return QMetaObject::Connection(0);
2752     }
2753 
2754     if (!QMetaObject::checkConnectArgs(signal.methodSignature().constData(), method.methodSignature().constData())) {
2755         qWarning("QObject::connect: Incompatible sender/receiver arguments"
2756                  "\n        %s::%s --> %s::%s",
2757                  smeta->className(), signal.methodSignature().constData(),
2758                  rmeta->className(), method.methodSignature().constData());
2759         return QMetaObject::Connection(0);
2760     }
2761 
2762     int *types = 0;
2763     if ((type == Qt::QueuedConnection)
2764             && !(types = queuedConnectionTypes(signal.parameterTypes())))
2765         return QMetaObject::Connection(0);
2766 
2767 #ifndef QT_NO_DEBUG
2768     check_and_warn_compat(smeta, signal, rmeta, method);
2769 #endif
2770     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2771         sender, signal_index, signal.enclosingMetaObject(), receiver, method_index, 0, type, types));
2772     return handle;
2773 }
2774 
2775 /*!
2776     \fn bool QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const
2777     \overload connect()
2778     \threadsafe
2779 
2780     Connects \a signal from the \a sender object to this object's \a
2781     method.
2782 
2783     Equivalent to connect(\a sender, \a signal, \c this, \a method, \a type).
2784 
2785     Every connection you make emits a signal, so duplicate connections emit
2786     two signals. You can break a connection using disconnect().
2787 
2788     \sa disconnect()
2789 */
2790 
2791 /*!
2792     \threadsafe
2793 
2794     Disconnects \a signal in object \a sender from \a method in object
2795     \a receiver. Returns \c true if the connection is successfully broken;
2796     otherwise returns \c false.
2797 
2798     A signal-slot connection is removed when either of the objects
2799     involved are destroyed.
2800 
2801     disconnect() is typically used in three ways, as the following
2802     examples demonstrate.
2803     \list 1
2804     \li Disconnect everything connected to an object's signals:
2805 
2806        \snippet code/src_corelib_kernel_qobject.cpp 26
2807 
2808        equivalent to the non-static overloaded function
2809 
2810        \snippet code/src_corelib_kernel_qobject.cpp 27
2811 
2812     \li Disconnect everything connected to a specific signal:
2813 
2814        \snippet code/src_corelib_kernel_qobject.cpp 28
2815 
2816        equivalent to the non-static overloaded function
2817 
2818        \snippet code/src_corelib_kernel_qobject.cpp 29
2819 
2820     \li Disconnect a specific receiver:
2821 
2822        \snippet code/src_corelib_kernel_qobject.cpp 30
2823 
2824        equivalent to the non-static overloaded function
2825 
2826        \snippet code/src_corelib_kernel_qobject.cpp 31
2827 
2828     \endlist
2829 
2830     0 may be used as a wildcard, meaning "any signal", "any receiving
2831     object", or "any slot in the receiving object", respectively.
2832 
2833     The \a sender may never be 0. (You cannot disconnect signals from
2834     more than one object in a single call.)
2835 
2836     If \a signal is 0, it disconnects \a receiver and \a method from
2837     any signal. If not, only the specified signal is disconnected.
2838 
2839     If \a receiver is 0, it disconnects anything connected to \a
2840     signal. If not, slots in objects other than \a receiver are not
2841     disconnected.
2842 
2843     If \a method is 0, it disconnects anything that is connected to \a
2844     receiver. If not, only slots named \a method will be disconnected,
2845     and all other slots are left alone. The \a method must be 0 if \a
2846     receiver is left out, so you cannot disconnect a
2847     specifically-named slot on all objects.
2848 
2849     \sa connect()
2850 */
2851 bool QObject::disconnect(const QObject *sender, const char *signal,
2852                          const QObject *receiver, const char *method)
2853 {
2854     if (sender == 0 || (receiver == 0 && method != 0)) {
2855         qWarning("QObject::disconnect: Unexpected null parameter");
2856         return false;
2857     }
2858 
2859     const char *signal_arg = signal;
2860     QByteArray signal_name;
2861     bool signal_found = false;
2862     if (signal) {
2863         QT_TRY {
2864             signal_name = QMetaObject::normalizedSignature(signal);
2865             signal = signal_name.constData();
2866         } QT_CATCH (const std::bad_alloc &) {
2867             // if the signal is already normalized, we can continue.
2868             if (sender->metaObject()->indexOfSignal(signal + 1) == -1)
2869                 QT_RETHROW;
2870         }
2871 
2872         if (!check_signal_macro(sender, signal, "disconnect", "unbind"))
2873             return false;
2874         signal++; // skip code
2875     }
2876 
2877     QByteArray method_name;
2878     const char *method_arg = method;
2879     int membcode = -1;
2880     bool method_found = false;
2881     if (method) {
2882         QT_TRY {
2883             method_name = QMetaObject::normalizedSignature(method);
2884             method = method_name.constData();
2885         } QT_CATCH(const std::bad_alloc &) {
2886             // if the method is already normalized, we can continue.
2887             if (receiver->metaObject()->indexOfMethod(method + 1) == -1)
2888                 QT_RETHROW;
2889         }
2890 
2891         membcode = extract_code(method);
2892         if (!check_method_code(membcode, receiver, method, "disconnect"))
2893             return false;
2894         method++; // skip code
2895     }
2896 
2897     /* We now iterate through all the sender's and receiver's meta
2898      * objects in order to also disconnect possibly shadowed signals
2899      * and slots with the same signature.
2900     */
2901     bool res = false;
2902     const QMetaObject *smeta = sender->metaObject();
2903     QByteArray signalName;
2904     QArgumentTypeArray signalTypes;
2905     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
2906     if (signal)
2907         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2908     QByteArray methodName;
2909     QArgumentTypeArray methodTypes;
2910     Q_ASSERT(!receiver || QMetaObjectPrivate::get(receiver->metaObject())->revision >= 7);
2911     if (method)
2912         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2913     do {
2914         int signal_index = -1;
2915         if (signal) {
2916             signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2917                         &smeta, signalName, signalTypes.size(), signalTypes.constData());
2918             if (signal_index < 0)
2919                 break;
2920             signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
2921             signal_index += QMetaObjectPrivate::signalOffset(smeta);
2922             signal_found = true;
2923         }
2924 
2925         if (!method) {
2926             res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, -1, 0);
2927         } else {
2928             const QMetaObject *rmeta = receiver->metaObject();
2929             do {
2930                 int method_index = QMetaObjectPrivate::indexOfMethod(
2931                             rmeta, methodName, methodTypes.size(), methodTypes.constData());
2932                 if (method_index >= 0)
2933                     while (method_index < rmeta->methodOffset())
2934                             rmeta = rmeta->superClass();
2935                 if (method_index < 0)
2936                     break;
2937                 res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, method_index, 0);
2938                 method_found = true;
2939             } while ((rmeta = rmeta->superClass()));
2940         }
2941     } while (signal && (smeta = smeta->superClass()));
2942 
2943     if (signal && !signal_found) {
2944         err_method_notfound(sender, signal_arg, "disconnect");
2945         err_info_about_objects("disconnect", sender, receiver);
2946     } else if (method && !method_found) {
2947         err_method_notfound(receiver, method_arg, "disconnect");
2948         err_info_about_objects("disconnect", sender, receiver);
2949     }
2950     if (res) {
2951         if (!signal)
2952             const_cast<QObject*>(sender)->disconnectNotify(QMetaMethod());
2953     }
2954     return res;
2955 }
2956 
2957 /*!
2958     \since 4.8
2959 
2960     Disconnects \a signal in object \a sender from \a method in object
2961     \a receiver. Returns \c true if the connection is successfully broken;
2962     otherwise returns \c false.
2963 
2964     This function provides the same possibilities like
2965     \c {disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method) }
2966     but uses QMetaMethod to represent the signal and the method to be disconnected.
2967 
2968     Additionally this function returnsfalse and no signals and slots disconnected
2969     if:
2970     \list 1
2971 
2972         \li \a signal is not a member of sender class or one of its parent classes.
2973 
2974         \li \a method is not a member of receiver class or one of its parent classes.
2975 
2976         \li \a signal instance represents not a signal.
2977 
2978     \endlist
2979 
2980     QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object".
2981     In the same way 0 can be used for \a receiver in the meaning "any receiving object". In this case
2982     method should also be QMetaMethod(). \a sender parameter should be never 0.
2983 
2984     \sa disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
2985  */
2986 bool QObject::disconnect(const QObject *sender, const QMetaMethod &signal,
2987                          const QObject *receiver, const QMetaMethod &method)
2988 {
2989     if (sender == 0 || (receiver == 0 && method.mobj != 0)) {
2990         qWarning("QObject::disconnect: Unexpected null parameter");
2991         return false;
2992     }
2993     if (signal.mobj) {
2994         if(signal.methodType() != QMetaMethod::Signal) {
2995             qWarning("QObject::%s: Attempt to %s non-signal %s::%s",
2996                      "disconnect","unbind",
2997                      sender->metaObject()->className(), signal.methodSignature().constData());
2998             return false;
2999         }
3000     }
3001     if (method.mobj) {
3002         if(method.methodType() == QMetaMethod::Constructor) {
3003             qWarning("QObject::disconect: cannot use constructor as argument %s::%s",
3004                      receiver->metaObject()->className(), method.methodSignature().constData());
3005             return false;
3006         }
3007     }
3008 
3009     // Reconstructing SIGNAL() macro result for signal.methodSignature() string
3010     QByteArray signalSignature;
3011     if (signal.mobj) {
3012         signalSignature.reserve(signal.methodSignature().size()+1);
3013         signalSignature.append((char)(QSIGNAL_CODE + '0'));
3014         signalSignature.append(signal.methodSignature());
3015     }
3016 
3017     int signal_index;
3018     int method_index;
3019     {
3020         int dummy;
3021         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
3022         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
3023     }
3024     // If we are here sender is not null. If signal is not null while signal_index
3025     // is -1 then this signal is not a member of sender.
3026     if (signal.mobj && signal_index == -1) {
3027         qWarning("QObject::disconect: signal %s not found on class %s",
3028                  signal.methodSignature().constData(), sender->metaObject()->className());
3029         return false;
3030     }
3031     // If this condition is true then method is not a member of receeiver.
3032     if (receiver && method.mobj && method_index == -1) {
3033         qWarning("QObject::disconect: method %s not found on class %s",
3034                  method.methodSignature().constData(), receiver->metaObject()->className());
3035         return false;
3036     }
3037 
3038     if (!QMetaObjectPrivate::disconnect(sender, signal_index, signal.mobj, receiver, method_index, 0))
3039         return false;
3040 
3041     if (!signal.isValid()) {
3042         // The signal is a wildcard, meaning all signals were disconnected.
3043         // QMetaObjectPrivate::disconnect() doesn't call disconnectNotify()
3044         // per connection in this case. Call it once now, with an invalid
3045         // QMetaMethod as argument, as documented.
3046         const_cast<QObject*>(sender)->disconnectNotify(signal);
3047     }
3048     return true;
3049 }
3050 
3051 /*!
3052     \threadsafe
3053 
3054     \fn bool QObject::disconnect(const char *signal, const QObject *receiver, const char *method) const
3055     \overload disconnect()
3056 
3057     Disconnects \a signal from \a method of \a receiver.
3058 
3059     A signal-slot connection is removed when either of the objects
3060     involved are destroyed.
3061 */
3062 
3063 /*!
3064     \fn bool QObject::disconnect(const QObject *receiver, const char *method) const
3065     \overload disconnect()
3066 
3067     Disconnects all signals in this object from \a receiver's \a
3068     method.
3069 
3070     A signal-slot connection is removed when either of the objects
3071     involved are destroyed.
3072 */
3073 
3074 
3075 /*!
3076     \since 5.0
3077 
3078     This virtual function is called when something has been connected
3079     to \a signal in this object.
3080 
3081     If you want to compare \a signal with a specific signal, you can
3082     use QMetaMethod::fromSignal() as follows:
3083 
3084     \snippet code/src_corelib_kernel_qobject.cpp 32
3085 
3086     \warning This function violates the object-oriented principle of
3087     modularity. However, it might be useful when you need to perform
3088     expensive initialization only if something is connected to a
3089     signal.
3090 
3091     \warning This function is called from the thread which performs the
3092     connection, which may be a different thread from the thread in
3093     which this object lives.
3094 
3095     \sa connect(), disconnectNotify()
3096 */
3097 
3098 void QObject::connectNotify(const QMetaMethod &signal)
3099 {
3100     Q_UNUSED(signal);
3101 }
3102 
3103 /*!
3104     \since 5.0
3105 
3106     This virtual function is called when something has been
3107     disconnected from \a signal in this object.
3108 
3109     See connectNotify() for an example of how to compare
3110     \a signal with a specific signal.
3111 
3112     If all signals were disconnected from this object (e.g., the
3113     signal argument to disconnect() was 0), disconnectNotify()
3114     is only called once, and the \a signal will be an invalid
3115     QMetaMethod (QMetaMethod::isValid() returns \c false).
3116 
3117     \warning This function violates the object-oriented principle of
3118     modularity. However, it might be useful for optimizing access to
3119     expensive resources.
3120 
3121     \warning This function is called from the thread which performs the
3122     disconnection, which may be a different thread from the thread in
3123     which this object lives. This function may also be called with a QObject
3124     internal mutex locked. It is therefore not allowed to re-enter any
3125     of any QObject functions from your reimplementation and if you lock
3126     a mutex in your reimplementation, make sure that you don't call QObject
3127     functions with that mutex held in other places or it will result in
3128     a deadlock.
3129 
3130     \sa disconnect(), connectNotify()
3131 */
3132 
3133 void QObject::disconnectNotify(const QMetaMethod &signal)
3134 {
3135     Q_UNUSED(signal);
3136 }
3137 
3138 /*
3139     \internal
3140     convert a signal index from the method range to the signal range
3141  */
3142 static int methodIndexToSignalIndex(const QMetaObject **base, int signal_index)
3143 {
3144     if (signal_index < 0)
3145         return signal_index;
3146     const QMetaObject *metaObject = *base;
3147     while (metaObject && metaObject->methodOffset() > signal_index)
3148         metaObject = metaObject->superClass();
3149 
3150     if (metaObject) {
3151         int signalOffset, methodOffset;
3152         computeOffsets(metaObject, &signalOffset, &methodOffset);
3153         if (signal_index < metaObject->methodCount())
3154             signal_index = QMetaObjectPrivate::originalClone(metaObject, signal_index - methodOffset) + signalOffset;
3155         else
3156             signal_index = signal_index - methodOffset + signalOffset;
3157         *base = metaObject;
3158     }
3159     return signal_index;
3160 }
3161 
3162 /*!
3163    \internal
3164    \a types is a 0-terminated vector of meta types for queued
3165    connections.
3166 
3167    if \a signal_index is -1, then we effectively connect *all* signals
3168    from the sender to the receiver's slot
3169  */
3170 QMetaObject::Connection QMetaObject::connect(const QObject *sender, int signal_index,
3171                                           const QObject *receiver, int method_index, int type, int *types)
3172 {
3173     const QMetaObject *smeta = sender->metaObject();
3174     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3175     return Connection(QMetaObjectPrivate::connect(sender, signal_index, smeta,
3176                                        receiver, method_index,
3177                                        0, //FIXME, we could speed this connection up by computing the relative index
3178                                        type, types));
3179 }
3180 
3181 /*!
3182     \internal
3183    Same as the QMetaObject::connect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3184 
3185     method_index is relative to the rmeta metaobject, if rmeta is null, then it is absolute index
3186 
3187     the QObjectPrivate::Connection* has a refcount of 2, so it must be passed to a QMetaObject::Connection
3188  */
3189 QObjectPrivate::Connection *QMetaObjectPrivate::connect(const QObject *sender,
3190                                  int signal_index, const QMetaObject *smeta,
3191                                  const QObject *receiver, int method_index,
3192                                  const QMetaObject *rmeta, int type, int *types)
3193 {
3194     QObject *s = const_cast<QObject *>(sender);
3195     QObject *r = const_cast<QObject *>(receiver);
3196 
3197     int method_offset = rmeta ? rmeta->methodOffset() : 0;
3198     Q_ASSERT(!rmeta || QMetaObjectPrivate::get(rmeta)->revision >= 6);
3199     QObjectPrivate::StaticMetaCallFunction callFunction = rmeta ? rmeta->d.static_metacall : nullptr;
3200 
3201     QOrderedMutexLocker locker(signalSlotLock(sender),
3202                                signalSlotLock(receiver));
3203 
3204     QObjectPrivate::ConnectionData *scd  = QObjectPrivate::get(s)->connections.load();
3205     if (type & Qt::UniqueConnection && scd) {
3206         if (scd->signalVector.count() > signal_index) {
3207             const QObjectPrivate::Connection *c2 = scd->signalVector.at(signal_index).first;
3208 
3209             int method_index_absolute = method_index + method_offset;
3210 
3211             while (c2) {
3212                 if (!c2->isSlotObject && c2->receiver == receiver && c2->method() == method_index_absolute)
3213                     return nullptr;
3214                 c2 = c2->nextConnectionList;
3215             }
3216         }
3217         type &= Qt::UniqueConnection - 1;
3218     }
3219 
3220     QScopedPointer<QObjectPrivate::Connection> c(new QObjectPrivate::Connection);
3221     c->sender = s;
3222     c->signal_index = signal_index;
3223     c->receiver = r;
3224     c->method_relative = method_index;
3225     c->method_offset = method_offset;
3226     c->connectionType = type;
3227     c->isSlotObject = false;
3228     c->argumentTypes.store(types);
3229     c->nextConnectionList = 0;
3230     c->callFunction = callFunction;
3231 
3232     QObjectPrivate::get(s)->addConnection(signal_index, c.data());
3233 
3234     locker.unlock();
3235     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3236     if (smethod.isValid())
3237         s->connectNotify(smethod);
3238 
3239     return c.take();
3240 }
3241 
3242 /*!
3243     \internal
3244  */
3245 bool QMetaObject::disconnect(const QObject *sender, int signal_index,
3246                              const QObject *receiver, int method_index)
3247 {
3248     const QMetaObject *smeta = sender->metaObject();
3249     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3250     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3251                                           receiver, method_index, 0);
3252 }
3253 
3254 /*!
3255     \internal
3256 
3257 Disconnect a single signal connection.  If QMetaObject::connect() has been called
3258 multiple times for the same sender, signal_index, receiver and method_index only
3259 one of these connections will be removed.
3260  */
3261 bool QMetaObject::disconnectOne(const QObject *sender, int signal_index,
3262                                 const QObject *receiver, int method_index)
3263 {
3264     const QMetaObject *smeta = sender->metaObject();
3265     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3266     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3267                                           receiver, method_index, 0,
3268                                           QMetaObjectPrivate::DisconnectOne);
3269 }
3270 
3271 /*!
3272     \internal
3273     Helper function to remove the connection from the senders list and setting the receivers to 0
3274  */
3275 bool QMetaObjectPrivate::disconnectHelper(QObjectPrivate::ConnectionData *connections, int signalIndex,
3276                                           const QObject *receiver, int method_index, void **slot,
3277                                           QBasicMutex *senderMutex, DisconnectType disconnectType)
3278 {
3279     bool success = false;
3280 
3281     auto &connectionList = connections->connectionsForSignal(signalIndex);
3282     auto *c = connectionList.first;
3283     while (c) {
3284         if (c->receiver
3285             && (receiver == nullptr || (c->receiver == receiver
3286                            && (method_index < 0 || (!c->isSlotObject && c->method() == method_index))
3287                            && (slot == nullptr || (c->isSlotObject && c->slotObj->compare(slot)))))) {
3288             bool needToUnlock = false;
3289             QBasicMutex *receiverMutex = nullptr;
3290             if (c->receiver) {
3291                 receiverMutex = signalSlotLock(c->receiver);
3292                 // need to relock this receiver and sender in the correct order
3293                 needToUnlock = QOrderedMutexLocker::relock(senderMutex, receiverMutex);
3294             }
3295             if (c->receiver)
3296                 connections->removeConnection(c);
3297 
3298             if (needToUnlock)
3299                 receiverMutex->unlock();
3300 
3301             success = true;
3302 
3303             if (disconnectType == DisconnectOne)
3304                 return success;
3305         }
3306         c = c->nextConnectionList;
3307     }
3308     return success;
3309 }
3310 
3311 /*!
3312     \internal
3313     Same as the QMetaObject::disconnect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3314  */
3315 bool QMetaObjectPrivate::disconnect(const QObject *sender,
3316                                     int signal_index, const QMetaObject *smeta,
3317                                     const QObject *receiver, int method_index, void **slot,
3318                                     DisconnectType disconnectType)
3319 {
3320     if (!sender)
3321         return false;
3322 
3323     QObject *s = const_cast<QObject *>(sender);
3324 
3325     QBasicMutex *senderMutex = signalSlotLock(sender);
3326     QBasicMutexLocker locker(senderMutex);
3327 
3328     QObjectPrivate::ConnectionData *scd  = QObjectPrivate::get(s)->connections.load();
3329     if (!scd)
3330         return false;
3331 
3332     bool success = false;
3333     {
3334         // prevent incoming connections changing the connections->receivers while unlocked
3335         QObjectPrivate::ConnectionDataPointer connections(scd);
3336 
3337         if (signal_index < 0) {
3338             // remove from all connection lists
3339             for (int sig_index = -1; sig_index < scd->signalVector.count(); ++sig_index) {
3340                 if (disconnectHelper(connections.data(), sig_index, receiver, method_index, slot, senderMutex, disconnectType))
3341                     success = true;
3342             }
3343         } else if (signal_index < scd->signalVector.count()) {
3344             if (disconnectHelper(connections.data(), signal_index, receiver, method_index, slot, senderMutex, disconnectType))
3345                 success = true;
3346         }
3347     }
3348 
3349     locker.unlock();
3350     if (success) {
3351         scd->cleanOrphanedConnections(s);
3352 
3353         QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3354         if (smethod.isValid())
3355             s->disconnectNotify(smethod);
3356     }
3357 
3358     return success;
3359 }
3360 
3361 /*!
3362     \fn void QMetaObject::connectSlotsByName(QObject *object)
3363 
3364     Searches recursively for all child objects of the given \a object, and connects
3365     matching signals from them to slots of \a object that follow the following form:
3366 
3367     \snippet code/src_corelib_kernel_qobject.cpp 33
3368 
3369     Let's assume our object has a child object of type \c{QPushButton} with
3370     the \l{QObject::objectName}{object name} \c{button1}. The slot to catch the
3371     button's \c{clicked()} signal would be:
3372 
3373     \snippet code/src_corelib_kernel_qobject.cpp 34
3374 
3375     If \a object itself has a properly set object name, its own signals are also
3376     connected to its respective slots.
3377 
3378     \sa QObject::setObjectName()
3379  */
3380 void QMetaObject::connectSlotsByName(QObject *o)
3381 {
3382     if (!o)
3383         return;
3384     const QMetaObject *mo = o->metaObject();
3385     Q_ASSERT(mo);
3386     const QObjectList list = // list of all objects to look for matching signals including...
3387             o->findChildren<QObject *>(QString()) // all children of 'o'...
3388             << o; // and the object 'o' itself
3389 
3390     // for each method/slot of o ...
3391     for (int i = 0; i < mo->methodCount(); ++i) {
3392         const QByteArray slotSignature = mo->method(i).methodSignature();
3393         const char *slot = slotSignature.constData();
3394         Q_ASSERT(slot);
3395 
3396         // ...that starts with "on_", ...
3397         if (slot[0] != 'o' || slot[1] != 'n' || slot[2] != '_')
3398             continue;
3399 
3400         // ...we check each object in our list, ...
3401         bool foundIt = false;
3402         for(int j = 0; j < list.count(); ++j) {
3403             const QObject *co = list.at(j);
3404             const QByteArray coName = co->objectName().toLatin1();
3405 
3406             // ...discarding those whose objectName is not fitting the pattern "on_<objectName>_...", ...
3407             if (coName.isEmpty() || qstrncmp(slot + 3, coName.constData(), coName.size()) || slot[coName.size()+3] != '_')
3408                 continue;
3409 
3410             const char *signal = slot + coName.size() + 4; // the 'signal' part of the slot name
3411 
3412             // ...for the presence of a matching signal "on_<objectName>_<signal>".
3413             const QMetaObject *smeta;
3414             int sigIndex = co->d_func()->signalIndex(signal, &smeta);
3415             if (sigIndex < 0) {
3416                 // if no exactly fitting signal (name + complete parameter type list) could be found
3417                 // look for just any signal with the correct name and at least the slot's parameter list.
3418                 // Note: if more than one of thoses signals exist, the one that gets connected is
3419                 // chosen 'at random' (order of declaration in source file)
3420                 QList<QByteArray> compatibleSignals;
3421                 const QMetaObject *smo = co->metaObject();
3422                 int sigLen = qstrlen(signal) - 1; // ignore the trailing ')'
3423                 for (int k = QMetaObjectPrivate::absoluteSignalCount(smo)-1; k >= 0; --k) {
3424                     const QMetaMethod method = QMetaObjectPrivate::signal(smo, k);
3425                     if (!qstrncmp(method.methodSignature().constData(), signal, sigLen)) {
3426                         smeta = method.enclosingMetaObject();
3427                         sigIndex = k;
3428                         compatibleSignals.prepend(method.methodSignature());
3429                     }
3430                 }
3431                 if (compatibleSignals.size() > 1)
3432                     qWarning() << "QMetaObject::connectSlotsByName: Connecting slot" << slot
3433                                << "with the first of the following compatible signals:" << compatibleSignals;
3434             }
3435 
3436             if (sigIndex < 0)
3437                 continue;
3438 
3439             // we connect it...
3440             if (Connection(QMetaObjectPrivate::connect(co, sigIndex, smeta, o, i))) {
3441                 foundIt = true;
3442                 // ...and stop looking for further objects with the same name.
3443                 // Note: the Designer will make sure each object name is unique in the above
3444                 // 'list' but other code may create two child objects with the same name. In
3445                 // this case one is chosen 'at random'.
3446                 break;
3447             }
3448         }
3449         if (foundIt) {
3450             // we found our slot, now skip all overloads
3451             while (mo->method(i + 1).attributes() & QMetaMethod::Cloned)
3452                   ++i;
3453         } else if (!(mo->method(i).attributes() & QMetaMethod::Cloned)) {
3454             // check if the slot has the following signature: "on_..._...(..."
3455             int iParen = slotSignature.indexOf('(');
3456             int iLastUnderscore = slotSignature.lastIndexOf('_', iParen-1);
3457             if (iLastUnderscore > 3)
3458                 qWarning("QMetaObject::connectSlotsByName: No matching signal for %s", slot);
3459         }
3460     }
3461 }
3462 
3463 /*!
3464     \internal
3465 
3466     \a signal must be in the signal index range (see QObjectPrivate::signalIndex()).
3467 */
3468 static void queued_activate(QObject *sender, int signal, QObjectPrivate::Connection *c, void **argv,
3469                             QBasicMutexLocker &locker)
3470 {
3471     const int *argumentTypes = c->argumentTypes.load();
3472     if (!argumentTypes) {
3473         QMetaMethod m = QMetaObjectPrivate::signal(sender->metaObject(), signal);
3474         argumentTypes = queuedConnectionTypes(m.parameterTypes());
3475         if (!argumentTypes) // cannot queue arguments
3476             argumentTypes = &DIRECT_CONNECTION_ONLY;
3477         if (!c->argumentTypes.testAndSetOrdered(0, argumentTypes)) {
3478             if (argumentTypes != &DIRECT_CONNECTION_ONLY)
3479                 delete [] argumentTypes;
3480             argumentTypes = c->argumentTypes.load();
3481         }
3482     }
3483     if (argumentTypes == &DIRECT_CONNECTION_ONLY) // cannot activate
3484         return;
3485     int nargs = 1; // include return type
3486     while (argumentTypes[nargs-1])
3487         ++nargs;
3488     int *types = (int *) malloc(nargs*sizeof(int));
3489     Q_CHECK_PTR(types);
3490     void **args = (void **) malloc(nargs*sizeof(void *));
3491     Q_CHECK_PTR(args);
3492     types[0] = 0; // return type
3493     args[0] = 0; // return value
3494 
3495     if (nargs > 1) {
3496         for (int n = 1; n < nargs; ++n)
3497             types[n] = argumentTypes[n-1];
3498 
3499         locker.unlock();
3500         for (int n = 1; n < nargs; ++n)
3501             args[n] = QMetaType::create(types[n], argv[n]);
3502         locker.relock();
3503 
3504         if (!c->receiver) {
3505             locker.unlock();
3506             // we have been disconnected while the mutex was unlocked
3507             for (int n = 1; n < nargs; ++n)
3508                 QMetaType::destroy(types[n], args[n]);
3509             free(types);
3510             free(args);
3511             locker.relock();
3512             return;
3513         }
3514     }
3515 
3516     QMetaCallEvent *ev = c->isSlotObject ?
3517         new QMetaCallEvent(c->slotObj, sender, signal, nargs, types, args) :
3518         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction, sender, signal, nargs, types, args);
3519     QCoreApplication::postEvent(c->receiver, ev);
3520 }
3521 
3522 template <bool callbacks_enabled>
3523 void doActivate(QObject *sender, int signal_index, void **argv)
3524 {
3525     QObjectPrivate *sp = QObjectPrivate::get(sender);
3526 
3527     if (sp->blockSig)
3528         return;
3529 
3530     if (sp->isDeclarativeSignalConnected(signal_index)
3531             && QAbstractDeclarativeData::signalEmitted) {
3532         Q_TRACE(QMetaObject_activate_begin_declarative_signal, sender, signal_index);
3533         QAbstractDeclarativeData::signalEmitted(sp->declarativeData, sender,
3534                                                 signal_index, argv);
3535         Q_TRACE(QMetaObject_activate_end_declarative_signal, sender, signal_index);
3536     }
3537 
3538     const QSignalSpyCallbackSet *signal_spy_set = callbacks_enabled ? qt_signal_spy_callback_set.load() : nullptr;
3539 
3540     if (!sp->isSignalConnected(signal_index, false)) {
3541         // The possible declarative connection is done, and nothing else is connected
3542         if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3543             signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3544         Q_TRACE(QMetaObject_activate_begin_signal, sender, signal_index);
3545         Q_TRACE(QMetaObject_activate_end_signal, sender, signal_index);
3546         if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3547             signal_spy_set->signal_end_callback(sender, signal_index);
3548         return;
3549     }
3550 
3551     void *empty_argv[] = { nullptr };
3552     if (!argv)
3553         argv = empty_argv;
3554 
3555     if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3556         signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3557     Q_TRACE(QMetaObject_activate_begin_signal, sender, signal_index);
3558 
3559     bool senderDeleted = false;
3560     {
3561     QBasicMutexLocker locker(signalSlotLock(sender));
3562     Q_ASSERT(sp->connections);
3563     QObjectPrivate::ConnectionDataPointer connections(sp->connections.load());
3564 
3565     const QObjectPrivate::ConnectionList *list;
3566     if (signal_index < connections->signalVector.count())
3567         list = &connections->signalVector.at(signal_index);
3568     else
3569         list = &connections->allsignals;
3570 
3571     Qt::HANDLE currentThreadId = QThread::currentThreadId();
3572 
3573     // We need to check against the highest connection id to ensure that signals added
3574     // during the signal emission are not emitted in this emission.
3575     uint highestConnectionId = connections->currentConnectionId.load();
3576     do {
3577         QObjectPrivate::Connection *c = list->first;
3578         if (!c)
3579             continue;
3580 
3581         do {
3582             if (!c->receiver)
3583                 continue;
3584 
3585             QObject * const receiver = c->receiver;
3586             const bool receiverInSameThread = currentThreadId == QObjectPrivate::get(receiver)->threadData->threadId.load();
3587 
3588             // determine if this connection should be sent immediately or
3589             // put into the event queue
3590             if ((c->connectionType == Qt::AutoConnection && !receiverInSameThread)
3591                 || (c->connectionType == Qt::QueuedConnection)) {
3592                 queued_activate(sender, signal_index, c, argv, locker);
3593                 continue;
3594 #if QT_CONFIG(thread)
3595             } else if (c->connectionType == Qt::BlockingQueuedConnection) {
3596                 if (receiverInSameThread) {
3597                     qWarning("Qt: Dead lock detected while activating a BlockingQueuedConnection: "
3598                     "Sender is %s(%p), receiver is %s(%p)",
3599                     sender->metaObject()->className(), sender,
3600                     receiver->metaObject()->className(), receiver);
3601                 }
3602                 QSemaphore semaphore;
3603                 QMetaCallEvent *ev = c->isSlotObject ?
3604                     new QMetaCallEvent(c->slotObj, sender, signal_index, 0, 0, argv, &semaphore) :
3605                     new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction, sender, signal_index, 0, 0, argv, &semaphore);
3606                 QCoreApplication::postEvent(receiver, ev);
3607                 locker.unlock();
3608                 semaphore.acquire();
3609                 locker.relock();
3610                 continue;
3611 #endif
3612             }
3613 
3614             QObjectPrivate::Sender senderData(receiverInSameThread ? receiver : nullptr, sender, signal_index);
3615 
3616             if (c->isSlotObject) {
3617                 c->slotObj->ref();
3618                 QScopedPointer<QtPrivate::QSlotObjectBase, QSlotObjectBaseDeleter> obj(c->slotObj);
3619                 locker.unlock();
3620                 Q_TRACE(QMetaObject_activate_begin_slot_functor, obj.data());
3621                 obj->call(receiver, argv);
3622                 Q_TRACE(QMetaObject_activate_end_slot_functor, obj.data());
3623 
3624                 // Make sure the slot object gets destroyed before the mutex is locked again, as the
3625                 // destructor of the slot object might also lock a mutex from the signalSlotLock() mutex pool,
3626                 // and that would deadlock if the pool happens to return the same mutex.
3627                 obj.reset();
3628 
3629                 locker.relock();
3630             } else if (c->callFunction && c->method_offset <= receiver->metaObject()->methodOffset()) {
3631                 //we compare the vtable to make sure we are not in the destructor of the object.
3632                 const int method_relative = c->method_relative;
3633                 const auto callFunction = c->callFunction;
3634                 locker.unlock();
3635                 const int methodIndex = (Q_HAS_TRACEPOINTS || callbacks_enabled) ? c->method() : 0;
3636                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr)
3637                     signal_spy_set->slot_begin_callback(receiver, methodIndex, argv);
3638                 Q_TRACE(QMetaObject_activate_begin_slot, receiver, methodIndex);
3639 
3640                 callFunction(receiver, QMetaObject::InvokeMetaMethod, method_relative, argv);
3641 
3642                 Q_TRACE(QMetaObject_activate_end_slot, receiver, methodIndex);
3643                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3644                     signal_spy_set->slot_end_callback(receiver, methodIndex);
3645                 locker.relock();
3646             } else {
3647                 const int method = c->method_relative + c->method_offset;
3648                 locker.unlock();
3649 
3650                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr) {
3651                     signal_spy_set->slot_begin_callback(receiver, method, argv);
3652                 }
3653                 Q_TRACE(QMetaObject_activate_begin_slot, receiver, method);
3654 
3655                 QMetaObject::metacall(receiver, QMetaObject::InvokeMetaMethod, method, argv);
3656 
3657                 Q_TRACE(QMetaObject_activate_end_slot, receiver, method);
3658                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3659                     signal_spy_set->slot_end_callback(receiver, method);
3660 
3661                 locker.relock();
3662             }
3663         } while ((c = c->nextConnectionList) != 0 && c->id <= highestConnectionId);
3664 
3665     } while (list != &connections->allsignals &&
3666         //start over for all signals;
3667         ((list = &connections->allsignals), true));
3668 
3669         if (connections->currentConnectionId.load() == 0)
3670             senderDeleted = true;
3671     }
3672     if (!senderDeleted)
3673         sp->connections.load()->cleanOrphanedConnections(sender);
3674 
3675     if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3676         signal_spy_set->signal_end_callback(sender, signal_index);
3677     Q_TRACE(QMetaObject_activate_end_signal, sender, signal_index);
3678 
3679 }
3680 
3681 /*!
3682     \internal
3683  */
3684 void QMetaObject::activate(QObject *sender, const QMetaObject *m, int local_signal_index,
3685                            void **argv)
3686 {
3687     int signal_index = local_signal_index + QMetaObjectPrivate::signalOffset(m);
3688 
3689     if (Q_UNLIKELY(qt_signal_spy_callback_set.load()))
3690         doActivate<true>(sender, signal_index, argv);
3691     else
3692         doActivate<false>(sender, signal_index, argv);
3693 }
3694 
3695 /*!
3696     \internal
3697  */
3698 void QMetaObject::activate(QObject *sender, int signalOffset, int local_signal_index, void **argv)
3699 {
3700     int signal_index = signalOffset + local_signal_index;
3701 
3702     if (Q_UNLIKELY(qt_signal_spy_callback_set.load()))
3703         doActivate<true>(sender, signal_index, argv);
3704     else
3705         doActivate<false>(sender, signal_index, argv);
3706  }
3707 
3708 /*!
3709     \internal
3710    signal_index comes from indexOfMethod()
3711 */
3712 void QMetaObject::activate(QObject *sender, int signal_index, void **argv)
3713 {
3714     const QMetaObject *mo = sender->metaObject();
3715     while (mo->methodOffset() > signal_index)
3716         mo = mo->superClass();
3717     activate(sender, mo, signal_index - mo->methodOffset(), argv);
3718 }
3719 
3720 /*!
3721     \internal
3722     Returns the signal index used in the internal connections->receivers vector.
3723 
3724     It is different from QMetaObject::indexOfSignal():  indexOfSignal is the same as indexOfMethod
3725     while QObjectPrivate::signalIndex is smaller because it doesn't give index to slots.
3726 
3727     If \a meta is not 0, it is set to the meta-object where the signal was found.
3728 */
3729 int QObjectPrivate::signalIndex(const char *signalName,
3730                                 const QMetaObject **meta) const
3731 {
3732     Q_Q(const QObject);
3733     const QMetaObject *base = q->metaObject();
3734     Q_ASSERT(QMetaObjectPrivate::get(base)->revision >= 7);
3735     QArgumentTypeArray types;
3736     QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signalName, types);
3737     int relative_index = QMetaObjectPrivate::indexOfSignalRelative(
3738             &base, name, types.size(), types.constData());
3739     if (relative_index < 0)
3740         return relative_index;
3741     relative_index = QMetaObjectPrivate::originalClone(base, relative_index);
3742     if (meta)
3743         *meta = base;
3744     return relative_index + QMetaObjectPrivate::signalOffset(base);
3745 }
3746 
3747 /*****************************************************************************
3748   Properties
3749  *****************************************************************************/
3750 
3751 #ifndef QT_NO_PROPERTIES
3752 
3753 /*!
3754   Sets the value of the object's \a name property to \a value.
3755 
3756   If the property is defined in the class using Q_PROPERTY then
3757   true is returned on success and false otherwise. If the property
3758   is not defined using Q_PROPERTY, and therefore not listed in the
3759   meta-object, it is added as a dynamic property and false is returned.
3760 
3761   Information about all available properties is provided through the
3762   metaObject() and dynamicPropertyNames().
3763 
3764   Dynamic properties can be queried again using property() and can be
3765   removed by setting the property value to an invalid QVariant.
3766   Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent
3767   to be sent to the object.
3768 
3769   \b{Note:} Dynamic properties starting with "_q_" are reserved for internal
3770   purposes.
3771 
3772   \sa property(), metaObject(), dynamicPropertyNames(), QMetaProperty::write()
3773 */
3774 bool QObject::setProperty(const char *name, const QVariant &value)
3775 {
3776     Q_D(QObject);
3777     const QMetaObject* meta = metaObject();
3778     if (!name || !meta)
3779         return false;
3780 
3781     int id = meta->indexOfProperty(name);
3782     if (id < 0) {
3783         if (!d->extraData)
3784             d->extraData = new QObjectPrivate::ExtraData;
3785 
3786         const int idx = d->extraData->propertyNames.indexOf(name);
3787 
3788         if (!value.isValid()) {
3789             if (idx == -1)
3790                 return false;
3791             d->extraData->propertyNames.removeAt(idx);
3792             d->extraData->propertyValues.removeAt(idx);
3793         } else {
3794             if (idx == -1) {
3795                 d->extraData->propertyNames.append(name);
3796                 d->extraData->propertyValues.append(value);
3797             } else {
3798                 if (value.userType() == d->extraData->propertyValues.at(idx).userType()
3799                         && value == d->extraData->propertyValues.at(idx))
3800                     return false;
3801                 d->extraData->propertyValues[idx] = value;
3802             }
3803         }
3804 
3805         QDynamicPropertyChangeEvent ev(name);
3806         QCoreApplication::sendEvent(this, &ev);
3807 
3808         return false;
3809     }
3810     QMetaProperty p = meta->property(id);
3811 #ifndef QT_NO_DEBUG
3812     if (!p.isWritable())
3813         qWarning("%s::setProperty: Property \"%s\" invalid,"
3814                  " read-only or does not exist", metaObject()->className(), name);
3815 #endif
3816     return p.write(this, value);
3817 }
3818 
3819 /*!
3820   Returns the value of the object's \a name property.
3821 
3822   If no such property exists, the returned variant is invalid.
3823 
3824   Information about all available properties is provided through the
3825   metaObject() and dynamicPropertyNames().
3826 
3827   \sa setProperty(), QVariant::isValid(), metaObject(), dynamicPropertyNames()
3828 */
3829 QVariant QObject::property(const char *name) const
3830 {
3831     Q_D(const QObject);
3832     const QMetaObject* meta = metaObject();
3833     if (!name || !meta)
3834         return QVariant();
3835 
3836     int id = meta->indexOfProperty(name);
3837     if (id < 0) {
3838         if (!d->extraData)
3839             return QVariant();
3840         const int i = d->extraData->propertyNames.indexOf(name);
3841         return d->extraData->propertyValues.value(i);
3842     }
3843     QMetaProperty p = meta->property(id);
3844 #ifndef QT_NO_DEBUG
3845     if (!p.isReadable())
3846         qWarning("%s::property: Property \"%s\" invalid or does not exist",
3847                  metaObject()->className(), name);
3848 #endif
3849     return p.read(this);
3850 }
3851 
3852 /*!
3853     \since 4.2
3854 
3855     Returns the names of all properties that were dynamically added to
3856     the object using setProperty().
3857 */
3858 QList<QByteArray> QObject::dynamicPropertyNames() const
3859 {
3860     Q_D(const QObject);
3861     if (d->extraData)
3862         return d->extraData->propertyNames;
3863     return QList<QByteArray>();
3864 }
3865 
3866 #endif // QT_NO_PROPERTIES
3867 
3868 
3869 /*****************************************************************************
3870   QObject debugging output routines.
3871  *****************************************************************************/
3872 
3873 static void dumpRecursive(int level, const QObject *object)
3874 {
3875     if (object) {
3876         QByteArray buf;
3877         buf.fill(' ', level / 2 * 8);
3878         if (level % 2)
3879             buf += "    ";
3880         QString name = object->objectName();
3881         QString flags = QLatin1String("");
3882 #if 0
3883         if (qApp->focusWidget() == object)
3884             flags += 'F';
3885         if (object->isWidgetType()) {
3886             QWidget * w = (QWidget *)object;
3887             if (w->isVisible()) {
3888                 QString t("<%1,%2,%3,%4>");
3889                 flags += t.arg(w->x()).arg(w->y()).arg(w->width()).arg(w->height());
3890             } else {
3891                 flags += 'I';
3892             }
3893         }
3894 #endif
3895         qDebug("%s%s::%s %s", (const char*)buf, object->metaObject()->className(), name.toLocal8Bit().data(),
3896                flags.toLatin1().data());
3897         QObjectList children = object->children();
3898         if (!children.isEmpty()) {
3899             for (int i = 0; i < children.size(); ++i)
3900                 dumpRecursive(level+1, children.at(i));
3901         }
3902     }
3903 }
3904 
3905 /*!
3906     \overload
3907     \obsolete
3908 
3909     Dumps a tree of children to the debug output.
3910 
3911     \sa dumpObjectInfo()
3912 */
3913 
3914 void QObject::dumpObjectTree()
3915 {
3916     const_cast<const QObject *>(this)->dumpObjectTree();
3917 }
3918 
3919 /*!
3920     Dumps a tree of children to the debug output.
3921 
3922     \note before Qt 5.9, this function was not const.
3923 
3924     \sa dumpObjectInfo()
3925 */
3926 
3927 void QObject::dumpObjectTree() const
3928 {
3929     dumpRecursive(0, this);
3930 }
3931 
3932 /*!
3933     \overload
3934     \obsolete
3935 
3936     Dumps information about signal connections, etc. for this object
3937     to the debug output.
3938 
3939     \sa dumpObjectTree()
3940 */
3941 
3942 void QObject::dumpObjectInfo()
3943 {
3944     const_cast<const QObject *>(this)->dumpObjectInfo();
3945 }
3946 
3947 /*!
3948     Dumps information about signal connections, etc. for this object
3949     to the debug output.
3950 
3951     \note before Qt 5.9, this function was not const.
3952 
3953     \sa dumpObjectTree()
3954 */
3955 
3956 void QObject::dumpObjectInfo() const
3957 {
3958     qDebug("OBJECT %s::%s", metaObject()->className(),
3959            objectName().isEmpty() ? "unnamed" : objectName().toLocal8Bit().data());
3960 
3961     Q_D(const QObject);
3962     QBasicMutexLocker locker(signalSlotLock(this));
3963 
3964     // first, look for connections where this object is the sender
3965     qDebug("  SIGNALS OUT");
3966 
3967     QObjectPrivate::ConnectionData *cd = d->connections.load();
3968     if (cd && cd->signalVector.count()) {
3969         for (int signal_index = 0; signal_index < cd->signalVector.count(); ++signal_index) {
3970             const QMetaMethod signal = QMetaObjectPrivate::signal(metaObject(), signal_index);
3971             qDebug("        signal: %s", signal.methodSignature().constData());
3972 
3973             // receivers
3974             const QObjectPrivate::Connection *c = cd->signalVector.at(signal_index).first;
3975             while (c) {
3976                 if (!c->receiver) {
3977                     qDebug("          <Disconnected receiver>");
3978                     c = c->nextConnectionList;
3979                     continue;
3980                 }
3981                 if (c->isSlotObject) {
3982                     qDebug("          <functor or function pointer>");
3983                     c = c->nextConnectionList;
3984                     continue;
3985                 }
3986                 const QMetaObject *receiverMetaObject = c->receiver->metaObject();
3987                 const QMetaMethod method = receiverMetaObject->method(c->method());
3988                 qDebug("          --> %s::%s %s",
3989                        receiverMetaObject->className(),
3990                        c->receiver->objectName().isEmpty() ? "unnamed" : qPrintable(c->receiver->objectName()),
3991                        method.methodSignature().constData());
3992                 c = c->nextConnectionList;
3993             }
3994         }
3995     } else {
3996         qDebug( "        <None>" );
3997     }
3998 
3999     // now look for connections where this object is the receiver
4000     qDebug("  SIGNALS IN");
4001 
4002     if (cd && cd->senders) {
4003         for (QObjectPrivate::Connection *s = cd->senders; s; s = s->next) {
4004             QByteArray slotName = QByteArrayLiteral("<unknown>");
4005             if (!s->isSlotObject) {
4006                 const QMetaMethod slot = metaObject()->method(s->method());
4007                 slotName = slot.methodSignature();
4008             }
4009             qDebug("          <-- %s::%s %s",
4010                    s->sender->metaObject()->className(),
4011                    s->sender->objectName().isEmpty() ? "unnamed" : qPrintable(s->sender->objectName()),
4012                    slotName.constData());
4013         }
4014     } else {
4015         qDebug("        <None>");
4016     }
4017 }
4018 
4019 #ifndef QT_NO_USERDATA
4020 /*!
4021     \internal
4022  */
4023 uint QObject::registerUserData()
4024 {
4025     static int user_data_registration = 0;
4026     return user_data_registration++;
4027 }
4028 
4029 /*!
4030     \internal
4031  */
4032 QObjectUserData::~QObjectUserData()
4033 {
4034 }
4035 
4036 /*!
4037     \internal
4038  */
4039 void QObject::setUserData(uint id, QObjectUserData* data)
4040 {
4041     Q_D(QObject);
4042     if (!d->extraData)
4043         d->extraData = new QObjectPrivate::ExtraData;
4044 
4045     if (d->extraData->userData.size() <= (int) id)
4046         d->extraData->userData.resize((int) id + 1);
4047     d->extraData->userData[id] = data;
4048 }
4049 
4050 /*!
4051     \internal
4052  */
4053 QObjectUserData* QObject::userData(uint id) const
4054 {
4055     Q_D(const QObject);
4056     if (!d->extraData)
4057         return 0;
4058     if ((int)id < d->extraData->userData.size())
4059         return d->extraData->userData.at(id);
4060     return 0;
4061 }
4062 
4063 #endif // QT_NO_USERDATA
4064 
4065 
4066 #ifndef QT_NO_DEBUG_STREAM
4067 QDebug operator<<(QDebug dbg, const QObject *o)
4068 {
4069     QDebugStateSaver saver(dbg);
4070     if (!o)
4071         return dbg << "QObject(0x0)";
4072     dbg.nospace() << o->metaObject()->className() << '(' << (const void *)o;
4073     if (!o->objectName().isEmpty())
4074         dbg << ", name = " << o->objectName();
4075     dbg << ')';
4076     return dbg;
4077 }
4078 #endif
4079 
4080 /*!
4081     \macro Q_CLASSINFO(Name, Value)
4082     \relates QObject
4083 
4084     This macro associates extra information to the class, which is available
4085     using QObject::metaObject(). Qt makes only limited use of this feature, in
4086     the \l{Active Qt}, \l{Qt D-Bus} and \l{Qt QML module}{Qt QML}.
4087 
4088     The extra information takes the form of a \a Name string and a \a Value
4089     literal string.
4090 
4091     Example:
4092 
4093     \snippet code/src_corelib_kernel_qobject.cpp 35
4094 
4095     \sa QMetaObject::classInfo()
4096     \sa QAxFactory
4097     \sa {Using Qt D-Bus Adaptors}
4098     \sa {Extending QML}
4099 */
4100 
4101 /*!
4102     \macro Q_INTERFACES(...)
4103     \relates QObject
4104 
4105     This macro tells Qt which interfaces the class implements. This
4106     is used when implementing plugins.
4107 
4108     Example:
4109 
4110     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 1
4111     \dots
4112     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 3
4113 
4114     See the \l{tools/plugandpaint/plugins/basictools}{Plug & Paint
4115     Basic Tools} example for details.
4116 
4117     \sa Q_DECLARE_INTERFACE(), Q_PLUGIN_METADATA(), {How to Create Qt Plugins}
4118 */
4119 
4120 /*!
4121     \macro Q_PROPERTY(...)
4122     \relates QObject
4123 
4124     This macro is used for declaring properties in classes that
4125     inherit QObject. Properties behave like class data members, but
4126     they have additional features accessible through the \l
4127     {Meta-Object System}.
4128 
4129     \snippet code/doc_src_properties.cpp 0
4130 
4131     The property name and type and the \c READ function are required.
4132     The type can be any type supported by QVariant, or it can be a
4133     user-defined type.  The other items are optional, but a \c WRITE
4134     function is common.  The attributes default to true except \c USER,
4135     which defaults to false.
4136 
4137     For example:
4138 
4139     \snippet code/src_corelib_kernel_qobject.cpp 37
4140 
4141     For more details about how to use this macro, and a more detailed
4142     example of its use, see the discussion on \l {Qt's Property System}.
4143 
4144     \sa {Qt's Property System}
4145 */
4146 
4147 /*!
4148     \macro Q_ENUMS(...)
4149     \relates QObject
4150     \obsolete
4151 
4152     This macro registers one or several enum types to the meta-object
4153     system.
4154 
4155     For example:
4156 
4157     \snippet code/src_corelib_kernel_qobject.cpp 38
4158 
4159     If you want to register an enum that is declared in another class,
4160     the enum must be fully qualified with the name of the class
4161     defining it. In addition, the class \e defining the enum has to
4162     inherit QObject as well as declare the enum using Q_ENUMS().
4163 
4164     In new code, you should prefer the use of the Q_ENUM() macro, which makes the
4165     type available also to the meta type system.
4166     For instance, QMetaEnum::fromType() will not work with types declared with Q_ENUMS().
4167 
4168     \sa {Qt's Property System}
4169 */
4170 
4171 /*!
4172     \macro Q_FLAGS(...)
4173     \relates QObject
4174     \obsolete
4175 
4176     This macro registers one or several \l{QFlags}{flags types} with the
4177     meta-object system. It is typically used in a class definition to declare
4178     that values of a given enum can be used as flags and combined using the
4179     bitwise OR operator.
4180 
4181     \note This macro takes care of registering individual flag values
4182     with the meta-object system, so it is unnecessary to use Q_ENUMS()
4183     in addition to this macro.
4184 
4185     In new code, you should prefer the use of the Q_FLAG() macro, which makes the
4186     type available also to the meta type system.
4187 
4188     \sa {Qt's Property System}
4189 */
4190 
4191 /*!
4192     \macro Q_ENUM(...)
4193     \relates QObject
4194     \since 5.5
4195 
4196     This macro registers an enum type with the meta-object system.
4197     It must be placed after the enum declaration in a class that has the Q_OBJECT or the
4198     Q_GADGET macro. For namespaces use \l Q_ENUM_NS() instead.
4199 
4200     For example:
4201 
4202     \snippet code/src_corelib_kernel_qobject.cpp 38
4203 
4204     Enumerations that are declared with Q_ENUM have their QMetaEnum registered in the
4205     enclosing QMetaObject. You can also use QMetaEnum::fromType() to get the QMetaEnum.
4206 
4207     Registered enumerations are automatically registered also to the Qt meta
4208     type system, making them known to QMetaType without the need to use
4209     Q_DECLARE_METATYPE(). This will enable useful features; for example, if used
4210     in a QVariant, you can convert them to strings. Likewise, passing them to
4211     QDebug will print out their names.
4212 
4213     \sa {Qt's Property System}
4214 */
4215 
4216 
4217 /*!
4218     \macro Q_FLAG(...)
4219     \relates QObject
4220     \since 5.5
4221 
4222     This macro registers a single \l{QFlags}{flags type} with the
4223     meta-object system. It is typically used in a class definition to declare
4224     that values of a given enum can be used as flags and combined using the
4225     bitwise OR operator. For namespaces use \l Q_FLAG_NS() instead.
4226 
4227     The macro must be placed after the enum declaration.
4228 
4229     For example, in QLibrary, the \l{QLibrary::LoadHints}{LoadHints} flag is
4230     declared in the following way:
4231 
4232     \snippet code/src_corelib_kernel_qobject.cpp 39
4233 
4234     The declaration of the flags themselves is performed in the public section
4235     of the QLibrary class itself, using the \l Q_DECLARE_FLAGS() macro.
4236 
4237     \note The Q_FLAG macro takes care of registering individual flag values
4238     with the meta-object system, so it is unnecessary to use Q_ENUM()
4239     in addition to this macro.
4240 
4241     \sa {Qt's Property System}
4242 */
4243 
4244 /*!
4245     \macro Q_ENUM_NS(...)
4246     \relates QObject
4247     \since 5.8
4248 
4249     This macro registers an enum type with the meta-object system.
4250     It must be placed after the enum declaration in a namespace that
4251     has the Q_NAMESPACE macro. It is the same as \l Q_ENUM but in a
4252     namespace.
4253 
4254     Enumerations that are declared with Q_ENUM_NS have their QMetaEnum
4255     registered in the enclosing QMetaObject. You can also use
4256     QMetaEnum::fromType() to get the QMetaEnum.
4257 
4258     Registered enumerations are automatically registered also to the Qt meta
4259     type system, making them known to QMetaType without the need to use
4260     Q_DECLARE_METATYPE(). This will enable useful features; for example, if
4261     used in a QVariant, you can convert them to strings. Likewise, passing them
4262     to QDebug will print out their names.
4263 
4264     \sa {Qt's Property System}
4265 */
4266 
4267 
4268 /*!
4269     \macro Q_FLAG_NS(...)
4270     \relates QObject
4271     \since 5.8
4272 
4273     This macro registers a single \l{QFlags}{flags type} with the
4274     meta-object system. It is used in a namespace that has the
4275     Q_NAMESPACE macro, to declare that values of a given enum can be
4276     used as flags and combined using the bitwise OR operator.
4277     It is the same as \l Q_FLAG but in a namespace.
4278 
4279     The macro must be placed after the enum declaration.
4280 
4281     \note The Q_FLAG_NS macro takes care of registering individual flag
4282     values with the meta-object system, so it is unnecessary to use
4283     Q_ENUM_NS() in addition to this macro.
4284 
4285     \sa {Qt's Property System}
4286 */
4287 
4288 
4289 /*!
4290     \macro Q_OBJECT
4291     \relates QObject
4292 
4293     The Q_OBJECT macro must appear in the private section of a class
4294     definition that declares its own signals and slots or that uses
4295     other services provided by Qt's meta-object system.
4296 
4297     For example:
4298 
4299     \snippet signalsandslots/signalsandslots.h 1
4300     \codeline
4301     \snippet signalsandslots/signalsandslots.h 2
4302     \snippet signalsandslots/signalsandslots.h 3
4303 
4304     \note This macro requires the class to be a subclass of QObject. Use
4305     Q_GADGET instead of Q_OBJECT to enable the meta object system's support
4306     for enums in a class that is not a QObject subclass.
4307 
4308     \sa {Meta-Object System}, {Signals and Slots}, {Qt's Property System}
4309 */
4310 
4311 /*!
4312     \macro Q_GADGET
4313     \relates QObject
4314 
4315     The Q_GADGET macro is a lighter version of the Q_OBJECT macro for classes
4316     that do not inherit from QObject but still want to use some of the
4317     reflection capabilities offered by QMetaObject. Just like the Q_OBJECT
4318     macro, it must appear in the private section of a class definition.
4319 
4320     Q_GADGETs can have Q_ENUM, Q_PROPERTY and Q_INVOKABLE, but they cannot have
4321     signals or slots
4322 
4323     Q_GADGET makes a class member, \c{staticMetaObject}, available.
4324     \c{staticMetaObject} is of type QMetaObject and provides access to the
4325     enums declared with Q_ENUMS.
4326 */
4327 
4328 /*!
4329     \macro Q_NAMESPACE
4330     \relates QObject
4331     \since 5.8
4332 
4333     The Q_NAMESPACE macro can be used to add QMetaObject capabilities
4334     to a namespace.
4335 
4336     Q_NAMESPACEs can have Q_CLASSINFO, Q_ENUM_NS, Q_FLAG_NS, but they
4337     cannot have Q_ENUM, Q_FLAG, Q_PROPERTY, Q_INVOKABLE, signals nor slots.
4338 
4339     Q_NAMESPACE makes an external variable, \c{staticMetaObject}, available.
4340     \c{staticMetaObject} is of type QMetaObject and provides access to the
4341     enums declared with Q_ENUM_NS/Q_FLAG_NS.
4342 */
4343 
4344 /*!
4345     \macro Q_SIGNALS
4346     \relates QObject
4347 
4348     Use this macro to replace the \c signals keyword in class
4349     declarations, when you want to use Qt Signals and Slots with a
4350     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4351 
4352     The macro is normally used when \c no_keywords is specified with
4353     the \c CONFIG variable in the \c .pro file, but it can be used
4354     even when \c no_keywords is \e not specified.
4355 */
4356 
4357 /*!
4358     \macro Q_SIGNAL
4359     \relates QObject
4360 
4361     This is an additional macro that allows you to mark a single
4362     function as a signal. It can be quite useful, especially when you
4363     use a 3rd-party source code parser which doesn't understand a \c
4364     signals or \c Q_SIGNALS groups.
4365 
4366     Use this macro to replace the \c signals keyword in class
4367     declarations, when you want to use Qt Signals and Slots with a
4368     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4369 
4370     The macro is normally used when \c no_keywords is specified with
4371     the \c CONFIG variable in the \c .pro file, but it can be used
4372     even when \c no_keywords is \e not specified.
4373 */
4374 
4375 /*!
4376     \macro Q_SLOTS
4377     \relates QObject
4378 
4379     Use this macro to replace the \c slots keyword in class
4380     declarations, when you want to use Qt Signals and Slots with a
4381     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4382 
4383     The macro is normally used when \c no_keywords is specified with
4384     the \c CONFIG variable in the \c .pro file, but it can be used
4385     even when \c no_keywords is \e not specified.
4386 */
4387 
4388 /*!
4389     \macro Q_SLOT
4390     \relates QObject
4391 
4392     This is an additional macro that allows you to mark a single
4393     function as a slot. It can be quite useful, especially when you
4394     use a 3rd-party source code parser which doesn't understand a \c
4395     slots or \c Q_SLOTS groups.
4396 
4397     Use this macro to replace the \c slots keyword in class
4398     declarations, when you want to use Qt Signals and Slots with a
4399     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4400 
4401     The macro is normally used when \c no_keywords is specified with
4402     the \c CONFIG variable in the \c .pro file, but it can be used
4403     even when \c no_keywords is \e not specified.
4404 */
4405 
4406 /*!
4407     \macro Q_EMIT
4408     \relates QObject
4409 
4410     Use this macro to replace the \c emit keyword for emitting
4411     signals, when you want to use Qt Signals and Slots with a
4412     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4413 
4414     The macro is normally used when \c no_keywords is specified with
4415     the \c CONFIG variable in the \c .pro file, but it can be used
4416     even when \c no_keywords is \e not specified.
4417 */
4418 
4419 /*!
4420     \macro Q_INVOKABLE
4421     \relates QObject
4422 
4423     Apply this macro to declarations of member functions to allow them to
4424     be invoked via the meta-object system. The macro is written before
4425     the return type, as shown in the following example:
4426 
4427     \snippet qmetaobject-invokable/window.h Window class with invokable method
4428 
4429     The \c invokableMethod() function is marked up using Q_INVOKABLE, causing
4430     it to be registered with the meta-object system and enabling it to be
4431     invoked using QMetaObject::invokeMethod().
4432     Since \c normalMethod() function is not registered in this way, it cannot
4433     be invoked using QMetaObject::invokeMethod().
4434 
4435     If an invokable member function returns a pointer to a QObject or a
4436     subclass of QObject and it is invoked from QML, special ownership rules
4437     apply. See \l{qtqml-cppintegration-data.html}{Data Type Conversion Between QML and C++}
4438     for more information.
4439 */
4440 
4441 /*!
4442     \macro Q_REVISION
4443     \relates QObject
4444 
4445     Apply this macro to declarations of member functions to tag them with a
4446     revision number in the meta-object system. The macro is written before
4447     the return type, as shown in the following example:
4448 
4449     \snippet qmetaobject-revision/window.h Window class with revision
4450 
4451     This is useful when using the meta-object system to dynamically expose
4452     objects to another API, as you can match the version expected by multiple
4453     versions of the other API. Consider the following simplified example:
4454 
4455     \snippet qmetaobject-revision/main.cpp Window class using revision
4456 
4457     Using the same Window class as the previous example, the newProperty and
4458     newMethod would only be exposed in this code when the expected version is
4459     1 or greater.
4460 
4461     Since all methods are considered to be in revision 0 if untagged, a tag
4462     of Q_REVISION(0) is invalid and ignored.
4463 
4464     This tag is not used by the meta-object system itself. Currently this is only
4465     used by the QtQml module.
4466 
4467     For a more generic string tag, see \l QMetaMethod::tag()
4468 
4469     \sa QMetaMethod::revision()
4470 */
4471 
4472 /*!
4473     \macro Q_SET_OBJECT_NAME(Object)
4474     \relates QObject
4475     \since 5.0
4476 
4477     This macro assigns \a Object the objectName "Object".
4478 
4479     It doesn't matter whether \a Object is a pointer or not, the
4480     macro figures that out by itself.
4481 
4482     \sa QObject::objectName()
4483 */
4484 
4485 /*!
4486     \macro QT_NO_NARROWING_CONVERSIONS_IN_CONNECT
4487     \relates QObject
4488     \since 5.8
4489 
4490     Defining this macro will disable narrowing and floating-point-to-integral
4491     conversions between the arguments carried by a signal and the arguments
4492     accepted by a slot, when the signal and the slot are connected using the
4493     PMF-based syntax.
4494 
4495     \sa QObject::connect
4496 */
4497 
4498 /*!
4499     \typedef QObjectList
4500     \relates QObject
4501 
4502     Synonym for QList<QObject *>.
4503 */
4504 
4505 void qDeleteInEventHandler(QObject *o)
4506 {
4507     delete o;
4508 }
4509 
4510 /*!
4511     \fn template<typename PointerToMemberFunction> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)
4512     \overload connect()
4513     \threadsafe
4514 
4515     Creates a connection of the given \a type from the \a signal in
4516     the \a sender object to the \a method in the \a receiver object.
4517     Returns a handle to the connection that can be used to disconnect
4518     it later.
4519 
4520     The signal must be a function declared as a signal in the header.
4521     The slot function can be any member function that can be connected
4522     to the signal.
4523     A slot can be connected to a given signal if the signal has at
4524     least as many arguments as the slot, and there is an implicit
4525     conversion between the types of the corresponding arguments in the
4526     signal and the slot.
4527 
4528     Example:
4529 
4530     \snippet code/src_corelib_kernel_qobject.cpp 44
4531 
4532     This example ensures that the label always displays the current
4533     line edit text.
4534 
4535     A signal can be connected to many slots and signals. Many signals
4536     can be connected to one slot.
4537 
4538     If a signal is connected to several slots, the slots are activated
4539     in the same order as the order the connection was made, when the
4540     signal is emitted
4541 
4542     The function returns an handle to a connection if it successfully
4543     connects the signal to the slot. The Connection handle will be invalid
4544     if it cannot create the connection, for example, if QObject is unable
4545     to verify the existence of \a signal (if it was not declared as a signal)
4546     You can check if the QMetaObject::Connection is valid by casting it to a bool.
4547 
4548     By default, a signal is emitted for every connection you make;
4549     two signals are emitted for duplicate connections. You can break
4550     all of these connections with a single disconnect() call.
4551     If you pass the Qt::UniqueConnection \a type, the connection will only
4552     be made if it is not a duplicate. If there is already a duplicate
4553     (exact same signal to the exact same slot on the same objects),
4554     the connection will fail and connect will return an invalid QMetaObject::Connection.
4555 
4556     The optional \a type parameter describes the type of connection
4557     to establish. In particular, it determines whether a particular
4558     signal is delivered to a slot immediately or queued for delivery
4559     at a later time. If the signal is queued, the parameters must be
4560     of types that are known to Qt's meta-object system, because Qt
4561     needs to copy the arguments to store them in an event behind the
4562     scenes. If you try to use a queued connection and get the error
4563     message
4564 
4565     \snippet code/src_corelib_kernel_qobject.cpp 25
4566 
4567     make sure to declare the argument type with Q_DECLARE_METATYPE
4568 
4569     Overloaded functions can be resolved with help of \l qOverload.
4570 
4571     \sa {Differences between String-Based and Functor-Based Connections}
4572  */
4573 
4574 /*!
4575     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
4576 
4577     \threadsafe
4578     \overload connect()
4579 
4580     Creates a connection from \a signal in
4581     \a sender object to \a functor, and returns a handle to the connection
4582 
4583     The signal must be a function declared as a signal in the header.
4584     The slot function can be any function or functor that can be connected
4585     to the signal.
4586     A function can be connected to a given signal if the signal has at
4587     least as many argument as the slot. A functor can be connected to a signal
4588     if they have exactly the same number of arguments. There must exist implicit
4589     conversion between the types of the corresponding arguments in the
4590     signal and the slot.
4591 
4592     Example:
4593 
4594     \snippet code/src_corelib_kernel_qobject.cpp 45
4595 
4596     Lambda expressions can also be used:
4597 
4598     \snippet code/src_corelib_kernel_qobject.cpp 46
4599 
4600     The connection will automatically disconnect if the sender is destroyed.
4601     However, you should take care that any objects used within the functor
4602     are still alive when the signal is emitted.
4603 
4604     Overloaded functions can be resolved with help of \l qOverload.
4605 
4606  */
4607 
4608 /*!
4609     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)
4610 
4611     \threadsafe
4612     \overload connect()
4613 
4614     \since 5.2
4615 
4616     Creates a connection of a given \a type from \a signal in
4617     \a sender object to \a functor to be placed in a specific event
4618     loop of \a context, and returns a handle to the connection.
4619 
4620     \note Qt::UniqueConnections do not work for lambdas, non-member functions
4621     and functors; they only apply to connecting to member functions.
4622 
4623     The signal must be a function declared as a signal in the header.
4624     The slot function can be any function or functor that can be connected
4625     to the signal.
4626     A function can be connected to a given signal if the signal has at
4627     least as many argument as the slot. A functor can be connected to a signal
4628     if they have exactly the same number of arguments. There must exist implicit
4629     conversion between the types of the corresponding arguments in the
4630     signal and the slot.
4631 
4632     Example:
4633 
4634     \snippet code/src_corelib_kernel_qobject.cpp 50
4635 
4636     Lambda expressions can also be used:
4637 
4638     \snippet code/src_corelib_kernel_qobject.cpp 51
4639 
4640     The connection will automatically disconnect if the sender or the context
4641     is destroyed.
4642     However, you should take care that any objects used within the functor
4643     are still alive when the signal is emitted.
4644 
4645     Overloaded functions can be resolved with help of \l qOverload.
4646  */
4647 
4648 /*!
4649     \internal
4650 
4651     Implementation of the template version of connect
4652 
4653     \a sender is the sender object
4654     \a signal is a pointer to a pointer to a member signal of the sender
4655     \a receiver is the receiver object, may not be null, will be equal to sender when
4656                 connecting to a static function or a functor
4657     \a slot a pointer only used when using Qt::UniqueConnection
4658     \a type the Qt::ConnctionType passed as argument to connect
4659     \a types an array of integer with the metatype id of the parameter of the signal
4660              to be used with queued connection
4661              must stay valid at least for the whole time of the connection, this function
4662              do not take ownership. typically static data.
4663              If null, then the types will be computed when the signal is emit in a queued
4664              connection from the types from the signature.
4665     \a senderMetaObject is the metaobject used to lookup the signal, the signal must be in
4666                         this metaobject
4667  */
4668 QMetaObject::Connection QObject::connectImpl(const QObject *sender, void **signal,
4669                                              const QObject *receiver, void **slot,
4670                                              QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
4671                                              const int *types, const QMetaObject *senderMetaObject)
4672 {
4673     if (!signal) {
4674         qWarning("QObject::connect: invalid null parameter");
4675         if (slotObj)
4676             slotObj->destroyIfLastRef();
4677         return QMetaObject::Connection();
4678     }
4679 
4680     int signal_index = -1;
4681     void *args[] = { &signal_index, signal };
4682     for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
4683         senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
4684         if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
4685             break;
4686     }
4687     if (!senderMetaObject) {
4688         qWarning("QObject::connect: signal not found in %s", sender->metaObject()->className());
4689         slotObj->destroyIfLastRef();
4690         return QMetaObject::Connection(0);
4691     }
4692     signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
4693     return QObjectPrivate::connectImpl(sender, signal_index, receiver, slot, slotObj, type, types, senderMetaObject);
4694 }
4695 
4696 /*!
4697     \internal
4698 
4699     Internal version of connect used by the template version of QObject::connect (called via connectImpl) and
4700     also used by the QObjectPrivate::connect version used by QML. The signal_index is expected to be relative
4701     to the number of signals.
4702  */
4703 QMetaObject::Connection QObjectPrivate::connectImpl(const QObject *sender, int signal_index,
4704                                              const QObject *receiver, void **slot,
4705                                              QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
4706                                              const int *types, const QMetaObject *senderMetaObject)
4707 {
4708     if (!sender || !receiver || !slotObj || !senderMetaObject) {
4709         const char *senderString = sender ? sender->metaObject()->className()
4710                                           : senderMetaObject ? senderMetaObject->className()
4711                                           : "Unknown";
4712         const char *receiverString = receiver ? receiver->metaObject()->className()
4713                                               : "Unknown";
4714         qWarning("QObject::connect(%s, %s): invalid null parameter", senderString, receiverString);
4715         if (slotObj)
4716             slotObj->destroyIfLastRef();
4717         return QMetaObject::Connection();
4718     }
4719 
4720     QObject *s = const_cast<QObject *>(sender);
4721     QObject *r = const_cast<QObject *>(receiver);
4722 
4723     QOrderedMutexLocker locker(signalSlotLock(sender),
4724                                signalSlotLock(receiver));
4725 
4726     if (type & Qt::UniqueConnection && slot && QObjectPrivate::get(s)->connections.load()) {
4727         QObjectPrivate::ConnectionData *connections = QObjectPrivate::get(s)->connections.load();
4728         if (connections->signalVector.count() > signal_index) {
4729             const QObjectPrivate::Connection *c2 = connections->signalVector.at(signal_index).first;
4730 
4731             while (c2) {
4732                 if (c2->receiver == receiver && c2->isSlotObject && c2->slotObj->compare(slot)) {
4733                     slotObj->destroyIfLastRef();
4734                     return QMetaObject::Connection();
4735                 }
4736                 c2 = c2->nextConnectionList;
4737             }
4738         }
4739         type = static_cast<Qt::ConnectionType>(type ^ Qt::UniqueConnection);
4740     }
4741 
4742     QScopedPointer<QObjectPrivate::Connection> c(new QObjectPrivate::Connection);
4743     c->sender = s;
4744     c->signal_index = signal_index;
4745     c->receiver = r;
4746     c->slotObj = slotObj;
4747     c->connectionType = type;
4748     c->isSlotObject = true;
4749     if (types) {
4750         c->argumentTypes.store(types);
4751         c->ownArgumentTypes = false;
4752     }
4753 
4754     QObjectPrivate::get(s)->addConnection(signal_index, c.data());
4755     QMetaObject::Connection ret(c.take());
4756     locker.unlock();
4757 
4758     QMetaMethod method = QMetaObjectPrivate::signal(senderMetaObject, signal_index);
4759     Q_ASSERT(method.isValid());
4760     s->connectNotify(method);
4761 
4762     return ret;
4763 }
4764 
4765 /*!
4766     Disconnect a connection.
4767 
4768     If the \a connection is invalid or has already been disconnected, do nothing
4769     and return false.
4770 
4771    \sa connect()
4772  */
4773 bool QObject::disconnect(const QMetaObject::Connection &connection)
4774 {
4775     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(connection.d_ptr);
4776 
4777     if (!c)
4778         return false;
4779 
4780     QBasicMutex *senderMutex = signalSlotLock(c->sender);
4781     QBasicMutex *receiverMutex = signalSlotLock(c->receiver);
4782 
4783     QObjectPrivate::ConnectionData *connections;
4784     {
4785         QOrderedMutexLocker locker(senderMutex, receiverMutex);
4786 
4787         if (!c->receiver)
4788             return false;
4789 
4790         connections = QObjectPrivate::get(c->sender)->connections.load();
4791         Q_ASSERT(connections);
4792         connections->removeConnection(c);
4793     }
4794 
4795     connections->cleanOrphanedConnections(c->sender);
4796 
4797     c->sender->disconnectNotify(QMetaObjectPrivate::signal(c->sender->metaObject(),
4798                                                            c->signal_index));
4799 
4800     const_cast<QMetaObject::Connection &>(connection).d_ptr = nullptr;
4801     c->deref(); // has been removed from the QMetaObject::Connection object
4802 
4803     return true;
4804 }
4805 
4806 /*! \fn template<typename PointerToMemberFunction> bool QObject::disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
4807     \overload diconnect()
4808     \threadsafe
4809 
4810     Disconnects \a signal in object \a sender from \a method in object
4811     \a receiver. Returns \c true if the connection is successfully broken;
4812     otherwise returns \c false.
4813 
4814     A signal-slot connection is removed when either of the objects
4815     involved are destroyed.
4816 
4817     disconnect() is typically used in three ways, as the following
4818     examples demonstrate.
4819     \list 1
4820     \li Disconnect everything connected to an object's signals:
4821 
4822        \snippet code/src_corelib_kernel_qobject.cpp 26
4823 
4824     \li Disconnect everything connected to a specific signal:
4825 
4826        \snippet code/src_corelib_kernel_qobject.cpp 47
4827 
4828     \li Disconnect a specific receiver:
4829 
4830        \snippet code/src_corelib_kernel_qobject.cpp 30
4831 
4832     \li Disconnect a connection from one specific signal to a specific slot:
4833 
4834        \snippet code/src_corelib_kernel_qobject.cpp 48
4835 
4836 
4837     \endlist
4838 
4839     0 may be used as a wildcard, meaning "any signal", "any receiving
4840     object", or "any slot in the receiving object", respectively.
4841 
4842     The \a sender may never be 0. (You cannot disconnect signals from
4843     more than one object in a single call.)
4844 
4845     If \a signal is 0, it disconnects \a receiver and \a method from
4846     any signal. If not, only the specified signal is disconnected.
4847 
4848     If \a receiver is 0, it disconnects anything connected to \a
4849     signal. If not, slots in objects other than \a receiver are not
4850     disconnected.
4851 
4852     If \a method is 0, it disconnects anything that is connected to \a
4853     receiver. If not, only slots named \a method will be disconnected,
4854     and all other slots are left alone. The \a method must be 0 if \a
4855     receiver is left out, so you cannot disconnect a
4856     specifically-named slot on all objects.
4857 
4858     \note It is not possible to use this overload to diconnect signals
4859     connected to functors or lambda expressions. That is because it is not
4860     possible to compare them. Instead, use the overload that takes a
4861     QMetaObject::Connection
4862 
4863     \sa connect()
4864 */
4865 
4866 bool QObject::disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, const QMetaObject *senderMetaObject)
4867 {
4868     if (sender == 0 || (receiver == 0 && slot != 0)) {
4869         qWarning("QObject::disconnect: Unexpected null parameter");
4870         return false;
4871     }
4872 
4873     int signal_index = -1;
4874     if (signal) {
4875         void *args[] = { &signal_index, signal };
4876         for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
4877             senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
4878             if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
4879                 break;
4880         }
4881         if (!senderMetaObject) {
4882             qWarning("QObject::disconnect: signal not found in %s", sender->metaObject()->className());
4883             return QMetaObject::Connection(0);
4884         }
4885         signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
4886     }
4887 
4888     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, receiver, -1, slot);
4889 }
4890 
4891 /*!
4892  \internal
4893  Used by QML to connect a signal by index to a slot implemented in JavaScript (wrapped in a custom QSlotOBjectBase subclass).
4894 
4895  The signal_index is an index relative to the number of methods.
4896  */
4897 QMetaObject::Connection QObjectPrivate::connect(const QObject *sender, int signal_index, QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type)
4898 {
4899     if (!sender) {
4900         qWarning("QObject::connect: invalid null parameter");
4901         if (slotObj)
4902             slotObj->destroyIfLastRef();
4903         return QMetaObject::Connection();
4904     }
4905     const QMetaObject *senderMetaObject = sender->metaObject();
4906     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
4907 
4908     return QObjectPrivate::connectImpl(sender, signal_index, sender, /*slot*/0, slotObj, type, /*types*/0, senderMetaObject);
4909 }
4910 
4911 /*!
4912  \internal
4913  Used by QML to disconnect a signal by index that's connected to a slot implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass)
4914  In the QML case the slot is not a pointer to a pointer to the function to disconnect, but instead it is a pointer to an array of internal values
4915  required for the disconnect.
4916  */
4917 bool QObjectPrivate::disconnect(const QObject *sender, int signal_index, void **slot)
4918 {
4919     const QMetaObject *senderMetaObject = sender->metaObject();
4920     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
4921 
4922     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, sender, -1, slot);
4923 }
4924 
4925 /*! \class QMetaObject::Connection
4926     \inmodule QtCore
4927      Represents a handle to a signal-slot connection.
4928      It can be used to disconnect that connection, or check if
4929      the connection was successful
4930 
4931      \sa QObject::disconnect()
4932  */
4933 
4934 /*!
4935     Create a copy of the handle to the \a other connection
4936  */
4937 QMetaObject::Connection::Connection(const QMetaObject::Connection &other) : d_ptr(other.d_ptr)
4938 {
4939     if (d_ptr)
4940         static_cast<QObjectPrivate::Connection *>(d_ptr)->ref();
4941 }
4942 
4943 /*!
4944     Assigns \a other to this connection and returns a reference to this connection.
4945 */
4946 QMetaObject::Connection& QMetaObject::Connection::operator=(const QMetaObject::Connection& other)
4947 {
4948     if (other.d_ptr != d_ptr) {
4949         if (d_ptr)
4950             static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
4951         d_ptr = other.d_ptr;
4952         if (other.d_ptr)
4953             static_cast<QObjectPrivate::Connection *>(other.d_ptr)->ref();
4954     }
4955     return *this;
4956 }
4957 
4958 /*!
4959     Creates a Connection instance.
4960 */
4961 
4962 QMetaObject::Connection::Connection() : d_ptr(0) {}
4963 
4964 /*!
4965     Destructor for QMetaObject::Connection.
4966 */
4967 QMetaObject::Connection::~Connection()
4968 {
4969     if (d_ptr)
4970         static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
4971 }
4972 
4973 /*! \internal Returns true if the object is still connected */
4974 bool QMetaObject::Connection::isConnected_helper() const
4975 {
4976     Q_ASSERT(d_ptr);    // we're only called from operator RestrictedBool() const
4977     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(d_ptr);
4978 
4979     return c->receiver;
4980 }
4981 
4982 
4983 /*!
4984     \fn QMetaObject::Connection::operator bool() const
4985 
4986     Returns \c true if the connection is valid.
4987 
4988     The connection is valid if the call to QObject::connect succeeded.
4989     The connection is invalid if QObject::connect was not able to find
4990     the signal or the slot, or if the arguments do not match.
4991  */
4992 
4993 QT_END_NAMESPACE
4994 
4995 #include "moc_qnamespace.cpp"
4996 #include "moc_qobject.cpp"
