Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the test suite of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
21 ** included in the packaging of this file. Please review the following
22 ** information to ensure the GNU General Public License requirements will
23 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
24 **
25 ** $QT_END_LICENSE$
26 **
27 ****************************************************************************/
28 
29 
30 #include <QtTest/QtTest>
31 
32 #include <qabstractitemview.h>
33 #include <qstandarditemmodel.h>
34 #include <qapplication.h>
35 #include <qevent.h>
36 #include <qlistview.h>
37 #include <qlistwidget.h>
38 #include <qtableview.h>
39 #include <qtablewidget.h>
40 #include <qtreeview.h>
41 #include <qtreewidget.h>
42 #include <qheaderview.h>
43 #include <qspinbox.h>
44 #include <qitemdelegate.h>
45 #include <qpushbutton.h>
46 #include <qscrollbar.h>
47 #include <qboxlayout.h>
48 #include <qitemdelegate.h>
49 #include <qlineedit.h>
50 #include <qpainter.h>
51 #include <qscreen.h>
52 #include <qscopedpointer.h>
53 #include <qstyleditemdelegate.h>
54 #include <qstringlistmodel.h>
55 #include <qsortfilterproxymodel.h>
56 #include <qproxystyle.h>
57 
58 static inline void setFrameless(QWidget *w)
59 {
60     Qt::WindowFlags flags = w->windowFlags();
61     flags |= Qt::FramelessWindowHint;
62     flags &= ~(Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint);
63     w->setWindowFlags(flags);
64 }
65 
66 static inline void centerOnScreen(QWidget *w)
67 {
68     const QPoint offset = QPoint(w->width() / 2, w->height() / 2);
69     w->move(QGuiApplication::primaryScreen()->availableGeometry().center() - offset);
70 }
71 
72 // Move cursor out of widget area to avoid undesired interaction on Mac.
73 static inline void moveCursorAway(const QWidget *topLevel)
74 {
75 #ifndef QT_NO_CURSOR
76     QCursor::setPos(topLevel->geometry().topRight() + QPoint(100, 0));
77 #else
78     Q_UNUSED(topLevel)
79 #endif
80 }
81 
82 class GeometriesTestView : public QTableView
83 {
84     Q_OBJECT
85 public:
86     GeometriesTestView() : QTableView(), updateGeometriesCalled(false) {}
87     bool updateGeometriesCalled;
88 protected slots:
89     void updateGeometries() Q_DECL_OVERRIDE { updateGeometriesCalled = true; QTableView::updateGeometries(); }
90 };
91 
92 class tst_QAbstractItemView : public QObject
93 {
94     Q_OBJECT
95 
96 public:
97     void basic_tests(QAbstractItemView *view);
98 
99 private slots:
100     void cleanup();
101     void getSetCheck();
102     void emptyModels_data();
103     void emptyModels();
104     void setModel_data();
105     void setModel();
106     void noModel();
107     void dragSelect();
108     void rowDelegate();
109     void columnDelegate();
110     void selectAll();
111     void ctrlA();
112     void persistentEditorFocus();
113     void setItemDelegate();
114     void setItemDelegate_data();
115     // The dragAndDrop() test doesn't work, and is thus disabled on Mac and Windows
116     // for the following reasons:
117     //   Mac: use of GetCurrentEventButtonState() in QDragManager::drag()
118     //   Win: unknown reason
119 #if !defined(Q_OS_MAC) && !defined(Q_OS_WIN)
120 #if 0
121     void dragAndDrop();
122     void dragAndDropOnChild();
123 #endif
124 #endif
125     void noFallbackToRoot();
126     void setCurrentIndex_data();
127     void setCurrentIndex();
128 
129     void task221955_selectedEditor();
130     void task250754_fontChange();
131     void task200665_itemEntered();
132     void task257481_emptyEditor();
133     void shiftArrowSelectionAfterScrolling();
134     void shiftSelectionAfterRubberbandSelection();
135     void ctrlRubberbandSelection();
136     void QTBUG6407_extendedSelection();
137     void QTBUG6753_selectOnSelection();
138     void testDelegateDestroyEditor();
139     void testClickedSignal();
140     void testChangeEditorState();
141     void deselectInSingleSelection();
142     void testNoActivateOnDisabledItem();
143     void testFocusPolicy_data();
144     void testFocusPolicy();
145     void QTBUG31411_noSelection();
146     void QTBUG39324_settingSameInstanceOfIndexWidget();
147     void sizeHintChangeTriggersLayout();
148     void shiftSelectionAfterChangingModelContents();
149     void QTBUG48968_reentrant_updateEditorGeometries();
150     void QTBUG50102_SH_ItemView_ScrollMode();
151     void QTBUG50535_update_on_new_selection_model();
152     void QTBUG46785_mouseout_keeps_hover_state();
153     void testSelectionModelInSyncWithView();
154     void testClickToSelect();
155 };
156 
157 class MyAbstractItemDelegate : public QAbstractItemDelegate
158 {
159 public:
160     MyAbstractItemDelegate() : QAbstractItemDelegate() { calledVirtualDtor = false; }
161     void paint(QPainter *, const QStyleOptionViewItem &, const QModelIndex &) const {}
162     QSize sizeHint(const QStyleOptionViewItem &, const QModelIndex &) const { return size; }
163     QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &, const QModelIndex &) const
164     {
165         openedEditor = new QWidget(parent);
166         return openedEditor;
167     }
168     void destroyEditor(QWidget *editor, const QModelIndex &) const
169     {
170         calledVirtualDtor = true;
171         editor->deleteLater();
172     }
173     void changeSize() { size = QSize(50, 50); emit sizeHintChanged(QModelIndex()); }
174     mutable bool calledVirtualDtor;
175     mutable QWidget *openedEditor;
176     QSize size;
177 };
178 
179 // Testing get/set functions
180 void tst_QAbstractItemView::getSetCheck()
181 {
182     QListView view;
183     QAbstractItemView *obj1 = &view;
184     // QAbstractItemDelegate * QAbstractItemView::itemDelegate()
185     // void QAbstractItemView::setItemDelegate(QAbstractItemDelegate *)
186     MyAbstractItemDelegate *var1 = new MyAbstractItemDelegate;
187     obj1->setItemDelegate(var1);
188     QCOMPARE((QAbstractItemDelegate*)var1, obj1->itemDelegate());
189     obj1->setItemDelegate((QAbstractItemDelegate *)0);
190     QCOMPARE((QAbstractItemDelegate *)0, obj1->itemDelegate());
191     delete var1;
192 
193     // EditTriggers QAbstractItemView::editTriggers()
194     // void QAbstractItemView::setEditTriggers(EditTriggers)
195     obj1->setEditTriggers(QAbstractItemView::EditTriggers(QAbstractItemView::NoEditTriggers));
196     QCOMPARE(QAbstractItemView::EditTriggers(QAbstractItemView::NoEditTriggers), obj1->editTriggers());
197     obj1->setEditTriggers(QAbstractItemView::EditTriggers(QAbstractItemView::CurrentChanged));
198     QCOMPARE(QAbstractItemView::EditTriggers(QAbstractItemView::CurrentChanged), obj1->editTriggers());
199     obj1->setEditTriggers(QAbstractItemView::EditTriggers(QAbstractItemView::DoubleClicked));
200     QCOMPARE(QAbstractItemView::EditTriggers(QAbstractItemView::DoubleClicked), obj1->editTriggers());
201     obj1->setEditTriggers(QAbstractItemView::EditTriggers(QAbstractItemView::SelectedClicked));
202     QCOMPARE(QAbstractItemView::EditTriggers(QAbstractItemView::SelectedClicked), obj1->editTriggers());
203     obj1->setEditTriggers(QAbstractItemView::EditTriggers(QAbstractItemView::EditKeyPressed));
204     QCOMPARE(QAbstractItemView::EditTriggers(QAbstractItemView::EditKeyPressed), obj1->editTriggers());
205     obj1->setEditTriggers(QAbstractItemView::EditTriggers(QAbstractItemView::AnyKeyPressed));
206     QCOMPARE(QAbstractItemView::EditTriggers(QAbstractItemView::AnyKeyPressed), obj1->editTriggers());
207     obj1->setEditTriggers(QAbstractItemView::EditTriggers(QAbstractItemView::AllEditTriggers));
208     QCOMPARE(QAbstractItemView::EditTriggers(QAbstractItemView::AllEditTriggers), obj1->editTriggers());
209 
210     // bool QAbstractItemView::tabKeyNavigation()
211     // void QAbstractItemView::setTabKeyNavigation(bool)
212     obj1->setTabKeyNavigation(false);
213     QCOMPARE(false, obj1->tabKeyNavigation());
214     obj1->setTabKeyNavigation(true);
215     QCOMPARE(true, obj1->tabKeyNavigation());
216 
217     // bool QAbstractItemView::dragEnabled()
218     // void QAbstractItemView::setDragEnabled(bool)
219 #ifndef QT_NO_DRAGANDDROP
220     obj1->setDragEnabled(false);
221     QCOMPARE(false, obj1->dragEnabled());
222     obj1->setDragEnabled(true);
223     QCOMPARE(true, obj1->dragEnabled());
224 #endif
225     // bool QAbstractItemView::alternatingRowColors()
226     // void QAbstractItemView::setAlternatingRowColors(bool)
227     obj1->setAlternatingRowColors(false);
228     QCOMPARE(false, obj1->alternatingRowColors());
229     obj1->setAlternatingRowColors(true);
230     QCOMPARE(true, obj1->alternatingRowColors());
231 
232     // State QAbstractItemView::state()
233     // void QAbstractItemView::setState(State)
234     obj1->setState(QAbstractItemView::NoState);
235     QCOMPARE(QAbstractItemView::NoState, obj1->state());
236     obj1->setState(QAbstractItemView::DraggingState);
237     QCOMPARE(QAbstractItemView::DraggingState, obj1->state());
238     obj1->setState(QAbstractItemView::DragSelectingState);
239     QCOMPARE(QAbstractItemView::DragSelectingState, obj1->state());
240     obj1->setState(QAbstractItemView::EditingState);
241     QCOMPARE(QAbstractItemView::EditingState, obj1->state());
242     obj1->setState(QAbstractItemView::ExpandingState);
243     QCOMPARE(QAbstractItemView::ExpandingState, obj1->state());
244     obj1->setState(QAbstractItemView::CollapsingState);
245     QCOMPARE(QAbstractItemView::CollapsingState, obj1->state());
246 
247     // QWidget QAbstractScrollArea::viewport()
248     // void setViewport(QWidget*)
249     QWidget *vp = new QWidget;
250     obj1->setViewport(vp);
251     QCOMPARE(vp, obj1->viewport());
252 
253     QCOMPARE(16, obj1->autoScrollMargin());
254     obj1->setAutoScrollMargin(20);
255     QCOMPARE(20, obj1->autoScrollMargin());
256     obj1->setAutoScrollMargin(16);
257     QCOMPARE(16, obj1->autoScrollMargin());
258 }
259 
260 void tst_QAbstractItemView::cleanup()
261 {
262     QVERIFY(QApplication::topLevelWidgets().isEmpty());
263 }
264 
265 void tst_QAbstractItemView::emptyModels_data()
266 {
267     QTest::addColumn<QString>("viewType");
268 
269     QTest::newRow("QListView") << "QListView";
270     QTest::newRow("QTableView") << "QTableView";
271     QTest::newRow("QTreeView") << "QTreeView";
272     QTest::newRow("QHeaderView") << "QHeaderView";
273 }
274 
275 void tst_QAbstractItemView::emptyModels()
276 {
277     QFETCH(QString, viewType);
278 
279     QScopedPointer<QAbstractItemView> view;
280     if (viewType == "QListView")
281         view.reset(new QListView());
282     else if (viewType == "QTableView")
283         view.reset(new QTableView());
284     else if (viewType == "QTreeView")
285         view.reset(new QTreeView());
286     else if (viewType == "QHeaderView")
287         view.reset(new QHeaderView(Qt::Vertical));
288     else
289         QVERIFY(0);
290     centerOnScreen(view.data());
291     moveCursorAway(view.data());
292     view->show();
293     QVERIFY(QTest::qWaitForWindowExposed(view.data()));
294 
295     QVERIFY(!view->model());
296     QVERIFY(!view->selectionModel());
297     //QVERIFY(view->itemDelegate() != 0);
298 
299     basic_tests(view.data());
300 }
301 
302 void tst_QAbstractItemView::setModel_data()
303 {
304     QTest::addColumn<QString>("viewType");
305 
306     QTest::newRow("QListView") << "QListView";
307     QTest::newRow("QTableView") << "QTableView";
308     QTest::newRow("QTreeView") << "QTreeView";
309     QTest::newRow("QHeaderView") << "QHeaderView";
310 }
311 
312 void tst_QAbstractItemView::setModel()
313 {
314     QFETCH(QString, viewType);
315 
316     QScopedPointer<QAbstractItemView> view;
317 
318     if (viewType == "QListView")
319         view.reset(new QListView());
320     else if (viewType == "QTableView")
321         view.reset(new QTableView());
322     else if (viewType == "QTreeView")
323         view.reset(new QTreeView());
324     else if (viewType == "QHeaderView")
325         view.reset(new QHeaderView(Qt::Vertical));
326     else
327         QVERIFY(0);
328     centerOnScreen(view.data());
329     moveCursorAway(view.data());
330     view->show();
331     QVERIFY(QTest::qWaitForWindowExposed(view.data()));
332 
333     QStandardItemModel model(20,20);
334     view->setModel(0);
335     view->setModel(&model);
336     basic_tests(view.data());
337 }
338 
339 void tst_QAbstractItemView::basic_tests(QAbstractItemView *view)
340 {
341     // setSelectionModel
342     // Will assert as it should
343     //view->setSelectionModel(0);
344     // setItemDelegate
345     //view->setItemDelegate(0);
346     // Will asswert as it should
347 
348     // setSelectionMode
349     view->setSelectionMode(QAbstractItemView::SingleSelection);
350     QCOMPARE(view->selectionMode(), QAbstractItemView::SingleSelection);
351     view->setSelectionMode(QAbstractItemView::ContiguousSelection);
352     QCOMPARE(view->selectionMode(), QAbstractItemView::ContiguousSelection);
353     view->setSelectionMode(QAbstractItemView::ExtendedSelection);
354     QCOMPARE(view->selectionMode(), QAbstractItemView::ExtendedSelection);
355     view->setSelectionMode(QAbstractItemView::MultiSelection);
356     QCOMPARE(view->selectionMode(), QAbstractItemView::MultiSelection);
357     view->setSelectionMode(QAbstractItemView::NoSelection);
358     QCOMPARE(view->selectionMode(), QAbstractItemView::NoSelection);
359 
360     // setSelectionBehavior
361     view->setSelectionBehavior(QAbstractItemView::SelectItems);
362     QCOMPARE(view->selectionBehavior(), QAbstractItemView::SelectItems);
363     view->setSelectionBehavior(QAbstractItemView::SelectRows);
364     QCOMPARE(view->selectionBehavior(), QAbstractItemView::SelectRows);
365     view->setSelectionBehavior(QAbstractItemView::SelectColumns);
366     QCOMPARE(view->selectionBehavior(), QAbstractItemView::SelectColumns);
367 
368     // setEditTriggers
369     view->setEditTriggers(QAbstractItemView::EditKeyPressed);
370     QCOMPARE(view->editTriggers(), QAbstractItemView::EditKeyPressed);
371     view->setEditTriggers(QAbstractItemView::NoEditTriggers);
372     QCOMPARE(view->editTriggers(), QAbstractItemView::NoEditTriggers);
373     view->setEditTriggers(QAbstractItemView::CurrentChanged);
374     QCOMPARE(view->editTriggers(), QAbstractItemView::CurrentChanged);
375     view->setEditTriggers(QAbstractItemView::DoubleClicked);
376     QCOMPARE(view->editTriggers(), QAbstractItemView::DoubleClicked);
377     view->setEditTriggers(QAbstractItemView::SelectedClicked);
378     QCOMPARE(view->editTriggers(), QAbstractItemView::SelectedClicked);
379     view->setEditTriggers(QAbstractItemView::AnyKeyPressed);
380     QCOMPARE(view->editTriggers(), QAbstractItemView::AnyKeyPressed);
381     view->setEditTriggers(QAbstractItemView::AllEditTriggers);
382     QCOMPARE(view->editTriggers(), QAbstractItemView::AllEditTriggers);
383 
384     // setAutoScroll
385     view->setAutoScroll(false);
386     QCOMPARE(view->hasAutoScroll(), false);
387     view->setAutoScroll(true);
388     QCOMPARE(view->hasAutoScroll(), true);
389 
390     // setTabKeyNavigation
391     view->setTabKeyNavigation(false);
392     QCOMPARE(view->tabKeyNavigation(), false);
393     view->setTabKeyNavigation(true);
394     QCOMPARE(view->tabKeyNavigation(), true);
395 
396 #ifndef QT_NO_DRAGANDDROP
397     // setDropIndicatorShown
398     view->setDropIndicatorShown(false);
399     QCOMPARE(view->showDropIndicator(), false);
400     view->setDropIndicatorShown(true);
401     QCOMPARE(view->showDropIndicator(), true);
402 
403     // setDragEnabled
404     view->setDragEnabled(false);
405     QCOMPARE(view->dragEnabled(), false);
406     view->setDragEnabled(true);
407     QCOMPARE(view->dragEnabled(), true);
408 #endif
409 
410     // setAlternatingRowColors
411     view->setAlternatingRowColors(false);
412     QCOMPARE(view->alternatingRowColors(), false);
413     view->setAlternatingRowColors(true);
414     QCOMPARE(view->alternatingRowColors(), true);
415 
416     // setIconSize
417     view->setIconSize(QSize(16, 16));
418     QCOMPARE(view->iconSize(), QSize(16, 16));
419     QSignalSpy spy(view, &QAbstractItemView::iconSizeChanged);
420     QVERIFY(spy.isValid());
421     view->setIconSize(QSize(32, 32));
422     QCOMPARE(view->iconSize(), QSize(32, 32));
423     QCOMPARE(spy.count(), 1);
424     QCOMPARE(spy.at(0).at(0).value<QSize>(), QSize(32, 32));
425     // Should this happen?
426     view->setIconSize(QSize(-1, -1));
427     QCOMPARE(view->iconSize(), QSize(-1, -1));
428     QCOMPARE(spy.count(), 2);
429 
430     QCOMPARE(view->currentIndex(), QModelIndex());
431     QCOMPARE(view->rootIndex(), QModelIndex());
432 
433     view->keyboardSearch("");
434     view->keyboardSearch("foo");
435     view->keyboardSearch("1");
436 
437     QCOMPARE(view->visualRect(QModelIndex()), QRect());
438 
439     view->scrollTo(QModelIndex());
440 
441     QCOMPARE(view->sizeHintForIndex(QModelIndex()), QSize());
442     QCOMPARE(view->indexAt(QPoint(-1, -1)), QModelIndex());
443 
444     if (!view->model()){
445         QCOMPARE(view->indexAt(QPoint(10, 10)), QModelIndex());
446         QCOMPARE(view->sizeHintForRow(0), -1);
447         QCOMPARE(view->sizeHintForColumn(0), -1);
448     }else if (view->itemDelegate()){
449         view->sizeHintForRow(0);
450         view->sizeHintForColumn(0);
451     }
452     view->openPersistentEditor(QModelIndex());
453     view->closePersistentEditor(QModelIndex());
454 
455     view->reset();
456     view->setRootIndex(QModelIndex());
457     view->doItemsLayout();
458     view->selectAll();
459     view->edit(QModelIndex());
460     view->clearSelection();
461     view->setCurrentIndex(QModelIndex());
462 
463     // protected methods
464     view->dataChanged(QModelIndex(), QModelIndex());
465     view->rowsInserted(QModelIndex(), -1, -1);
466     view->rowsAboutToBeRemoved(QModelIndex(), -1, -1);
467     view->selectionChanged(QItemSelection(), QItemSelection());
468     if (view->model()){
469         view->currentChanged(QModelIndex(), QModelIndex());
470         view->currentChanged(QModelIndex(), view->model()->index(0,0));
471     }
472     view->updateEditorData();
473     view->updateEditorGeometries();
474     view->updateGeometries();
475     view->verticalScrollbarAction(QAbstractSlider::SliderSingleStepAdd);
476     view->horizontalScrollbarAction(QAbstractSlider::SliderSingleStepAdd);
477     view->verticalScrollbarValueChanged(10);
478     view->horizontalScrollbarValueChanged(10);
479     view->closeEditor(0, QAbstractItemDelegate::NoHint);
480     view->commitData(0);
481     view->editorDestroyed(0);
482 
483     view->setHorizontalStepsPerItem(2);
484     view->horizontalStepsPerItem();
485     view->setVerticalStepsPerItem(2);
486     view->verticalStepsPerItem();
487 
488     // Will assert as it should
489     // view->setIndexWidget(QModelIndex(), 0);
490 
491     view->moveCursor(QAbstractItemView::MoveUp, Qt::NoModifier);
492     view->horizontalOffset();
493     view->verticalOffset();
494 
495 //    view->isIndexHidden(QModelIndex()); // will (correctly) assert
496     if(view->model())
497         view->isIndexHidden(view->model()->index(0,0));
498 
499     view->setSelection(QRect(0, 0, 10, 10), QItemSelectionModel::ClearAndSelect);
500     view->setSelection(QRect(-1, -1, -1, -1), QItemSelectionModel::ClearAndSelect);
501     view->visualRegionForSelection(QItemSelection());
502     view->selectedIndexes();
503 
504     view->edit(QModelIndex(), QAbstractItemView::NoEditTriggers, 0);
505 
506     view->selectionCommand(QModelIndex(), 0);
507 
508 #ifndef QT_NO_DRAGANDDROP
509     if (!view->model())
510         view->startDrag(Qt::CopyAction);
511 
512     view->viewOptions();
513 
514     view->setState(QAbstractItemView::NoState);
515     QVERIFY(view->state()==QAbstractItemView::NoState);
516     view->setState(QAbstractItemView::DraggingState);
517     QVERIFY(view->state()==QAbstractItemView::DraggingState);
518     view->setState(QAbstractItemView::DragSelectingState);
519     QVERIFY(view->state()==QAbstractItemView::DragSelectingState);
520     view->setState(QAbstractItemView::EditingState);
521     QVERIFY(view->state()==QAbstractItemView::EditingState);
522     view->setState(QAbstractItemView::ExpandingState);
523     QVERIFY(view->state()==QAbstractItemView::ExpandingState);
524     view->setState(QAbstractItemView::CollapsingState);
525     QVERIFY(view->state()==QAbstractItemView::CollapsingState);
526 #endif
527 
528     view->startAutoScroll();
529     view->stopAutoScroll();
530     view->doAutoScroll();
531 
532     // testing mouseFoo and key functions
533 //     QTest::mousePress(view, Qt::LeftButton, Qt::NoModifier, QPoint(0,0));
534 //     mouseMove(view, Qt::LeftButton, Qt::NoModifier, QPoint(10,10));
535 //     QTest::mouseRelease(view, Qt::LeftButton, Qt::NoModifier, QPoint(10,10));
536 //     QTest::mouseClick(view, Qt::LeftButton, Qt::NoModifier, QPoint(10,10));
537 //     mouseDClick(view, Qt::LeftButton, Qt::NoModifier, QPoint(10,10));
538 //     QTest::keyClick(view, Qt::Key_A);
539 }
540 
541 void tst_QAbstractItemView::noModel()
542 {
543     // From task #85415
544 
545     QStandardItemModel model(20,20);
546     QTreeView view;
547     setFrameless(&view);
548 
549     view.setModel(&model);
550     // Make the viewport smaller than the contents, so that we can scroll
551     view.resize(100,100);
552     centerOnScreen(&view);
553     moveCursorAway(&view);
554     view.show();
555     QVERIFY(QTest::qWaitForWindowExposed(&view));
556 
557     // make sure that the scrollbars are not at value 0
558     view.scrollTo(view.model()->index(10,10));
559     QApplication::processEvents();
560 
561     view.setModel(0);
562     // Due to the model is removed, this will generate a valueChanged signal on both scrollbars. (value to 0)
563     QApplication::processEvents();
564     QCOMPARE(view.model(), nullptr);
565 }
566 
567 void tst_QAbstractItemView::dragSelect()
568 {
569     // From task #86108
570 
571     QStandardItemModel model(64,64);
572 
573     QTableView view;
574     view.setModel(&model);
575     centerOnScreen(&view);
576     moveCursorAway(&view);
577     view.setVisible(true);
578     QVERIFY(QTest::qWaitForWindowExposed(&view));
579 
580     const int delay = 2;
581     for (int i = 0; i < 2; ++i) {
582         bool tracking = (i == 1);
583         view.setMouseTracking(false);
584         QTest::mouseMove(&view, QPoint(0, 0), delay);
585         view.setMouseTracking(tracking);
586         QTest::mouseMove(&view, QPoint(50, 50), delay);
587         QVERIFY(view.selectionModel()->selectedIndexes().isEmpty());
588     }
589 }
590 
591 void tst_QAbstractItemView::rowDelegate()
592 {
593     QStandardItemModel model(4,4);
594     MyAbstractItemDelegate delegate;
595 
596     QTableView view;
597     view.setModel(&model);
598     view.setItemDelegateForRow(3, &delegate);
599     centerOnScreen(&view);
600     moveCursorAway(&view);
601     view.show();
602     QVERIFY(QTest::qWaitForWindowExposed(&view));
603 
604     QModelIndex index = model.index(3, 0);
605     view.openPersistentEditor(index);
606     QWidget *w = view.indexWidget(index);
607     QVERIFY(w);
608     QCOMPARE(w->metaObject()->className(), "QWidget");
609 }
610 
611 void tst_QAbstractItemView::columnDelegate()
612 {
613     QStandardItemModel model(4,4);
614     MyAbstractItemDelegate delegate;
615 
616     QTableView view;
617     view.setModel(&model);
618     view.setItemDelegateForColumn(3, &delegate);
619     centerOnScreen(&view);
620     moveCursorAway(&view);
621     view.show();
622     QVERIFY(QTest::qWaitForWindowExposed(&view));
623 
624     QModelIndex index = model.index(0, 3);
625     view.openPersistentEditor(index);
626     QWidget *w = view.indexWidget(index);
627     QVERIFY(w);
628     QCOMPARE(w->metaObject()->className(), "QWidget");
629 }
630 
631 void tst_QAbstractItemView::sizeHintChangeTriggersLayout()
632 {
633     QStandardItemModel model(4, 4);
634     MyAbstractItemDelegate delegate;
635     MyAbstractItemDelegate rowDelegate;
636     MyAbstractItemDelegate columnDelegate;
637 
638     GeometriesTestView view;
639     view.setModel(&model);
640     view.setItemDelegate(&delegate);
641     view.setItemDelegateForRow(1, &rowDelegate);
642     view.setItemDelegateForColumn(2, &columnDelegate);
643     view.show();
644     QVERIFY(QTest::qWaitForWindowExposed(&view));
645     view.updateGeometriesCalled = false;
646     delegate.changeSize();
647     QCoreApplication::sendPostedEvents();
648     QVERIFY(view.updateGeometriesCalled);
649     view.updateGeometriesCalled = false;
650     rowDelegate.changeSize();
651     QCoreApplication::sendPostedEvents();
652     QVERIFY(view.updateGeometriesCalled);
653     view.updateGeometriesCalled = false;
654     columnDelegate.changeSize();
655     QCoreApplication::sendPostedEvents();
656     QVERIFY(view.updateGeometriesCalled);
657 }
658 
659 void tst_QAbstractItemView::selectAll()
660 {
661     QStandardItemModel model(4,4);
662     QTableView view;
663     view.setModel(&model);
664 
665     QAbstractItemView *tst_view = &view;
666 
667     QCOMPARE(tst_view->selectedIndexes().count(), 0);
668     view.selectAll();
669     QCOMPARE(tst_view->selectedIndexes().count(), 4*4);
670 }
671 
672 void tst_QAbstractItemView::ctrlA()
673 {
674     QStandardItemModel model(4,4);
675     QTableView view;
676     view.setModel(&model);
677 
678     QAbstractItemView *tst_view = &view;
679 
680     QCOMPARE(tst_view->selectedIndexes().count(), 0);
681     QTest::keyClick(&view, Qt::Key_A, Qt::ControlModifier);
682     QCOMPARE(tst_view->selectedIndexes().count(), 4*4);
683 }
684 
685 void tst_QAbstractItemView::persistentEditorFocus()
686 {
687     // one row, three columns
688     QStandardItemModel model(1, 3);
689     for(int i = 0; i < model.columnCount(); ++i)
690         model.setData(model.index(0, i), i);
691     QTableView view;
692     view.setModel(&model);
693 
694     view.openPersistentEditor(model.index(0, 1));
695     view.openPersistentEditor(model.index(0, 2));
696 
697     //these are spinboxes because we put numbers inside
698     QList<QSpinBox*> list = view.viewport()->findChildren<QSpinBox*>();
699     QCOMPARE(list.count(), 2); //these should be the 2 editors
700 
701     view.setCurrentIndex(model.index(0, 0));
702     QCOMPARE(view.currentIndex(), model.index(0, 0));
703     centerOnScreen(&view);
704     moveCursorAway(&view);
705     view.show();
706     QVERIFY(QTest::qWaitForWindowExposed(&view));
707 
708     for (int i = 0; i < list.count(); ++i) {
709         QTRY_VERIFY(list.at(i)->isVisible());
710         QPoint p = QPoint(5, 5);
711         QMouseEvent mouseEvent(QEvent::MouseButtonPress, p, Qt::LeftButton,
712                                Qt::LeftButton, Qt::NoModifier);
713         qApp->sendEvent(list.at(i), &mouseEvent);
714         if (!qApp->focusWidget())
715             QSKIP("Some window managers don't handle focus that well");
716         QTRY_COMPARE(qApp->focusWidget(), static_cast<QWidget *>(list.at(i)));
717     }
718 }
719 
720 
721 #if !defined(Q_OS_MAC) && !defined(Q_OS_WIN)
722 
723 #if 0
724 
725 static void sendMouseMove(QWidget *widget, QPoint pos = QPoint())
726 {
727     if (pos.isNull())
728         pos = widget->rect().center();
729     QMouseEvent event(QEvent::MouseMove, pos, widget->mapToGlobal(pos), Qt::NoButton, 0, 0);
730     QCursor::setPos(widget->mapToGlobal(pos));
731     qApp->processEvents();
732     QVERIFY(QTest::qWaitForWindowExposed(widget));
733     QApplication::sendEvent(widget, &event);
734 }
735 
736 static void sendMousePress(
737     QWidget *widget, QPoint pos = QPoint(), Qt::MouseButton button = Qt::LeftButton)
738 {
739     if (pos.isNull())
740          pos = widget->rect().center();
741     QMouseEvent event(QEvent::MouseButtonPress, pos, widget->mapToGlobal(pos), button, 0, 0);
742     QApplication::sendEvent(widget, &event);
743 }
744 
745 static void sendMouseRelease(
746     QWidget *widget, QPoint pos = QPoint(), Qt::MouseButton button = Qt::LeftButton)
747 {
748     if (pos.isNull())
749          pos = widget->rect().center();
750     QMouseEvent event(QEvent::MouseButtonRelease, pos, widget->mapToGlobal(pos), button, 0, 0);
751     QApplication::sendEvent(widget, &event);
752 }
753 
754 class DnDTestModel : public QStandardItemModel
755 {
756     Q_OBJECT
757     bool dropMimeData(const QMimeData *md, Qt::DropAction action, int r, int c, const QModelIndex &p)
758     {
759         dropAction_result = action;
760         QStandardItemModel::dropMimeData(md, action, r, c, p);
761         return true;
762     }
763     Qt::DropActions supportedDropActions() const { return Qt::CopyAction | Qt::MoveAction; }
764 
765     Qt::DropAction dropAction_result;
766 public:
767     DnDTestModel() : QStandardItemModel(20, 20), dropAction_result(Qt::IgnoreAction) {
768         for (int i = 0; i < rowCount(); ++i)
769             setData(index(i, 0), QString::number(i));
770     }
771     Qt::DropAction dropAction() const { return dropAction_result; }
772 };
773 
774 class DnDTestView : public QTreeView
775 {
776     Q_OBJECT
777 
778     QPoint dropPoint;
779     Qt::DropAction dropAction;
780 
781     void dragEnterEvent(QDragEnterEvent *event)
782     {
783         QAbstractItemView::dragEnterEvent(event);
784     }
785 
786     void dropEvent(QDropEvent *event)
787     {
788         event->setDropAction(dropAction);
789         QTreeView::dropEvent(event);
790     }
791 
792     void timerEvent(QTimerEvent *event)
793     {
794         killTimer(event->timerId());
795         sendMouseMove(this, dropPoint);
796         sendMouseRelease(this);
797     }
798 
799     void mousePressEvent(QMouseEvent *e)
800     {
801         QTreeView::mousePressEvent(e);
802 
803         startTimer(0);
804         setState(DraggingState);
805         startDrag(dropAction);
806     }
807 
808 public:
809     DnDTestView(Qt::DropAction dropAction, QAbstractItemModel *model)
810         : dropAction(dropAction)
811     {
812         header()->hide();
813         setModel(model);
814         setDragDropMode(QAbstractItemView::DragDrop);
815         setAcceptDrops(true);
816         setDragEnabled(true);
817     }
818 
819     void dragAndDrop(QPoint drag, QPoint drop)
820     {
821         dropPoint = drop;
822         setCurrentIndex(indexAt(drag));
823         sendMousePress(viewport(), drag);
824     }
825 };
826 
827 class DnDTestWidget : public QWidget
828 {
829     Q_OBJECT
830 
831     Qt::DropAction dropAction_request;
832     Qt::DropAction dropAction_result;
833     QWidget *dropTarget;
834 
835     void timerEvent(QTimerEvent *event)
836     {
837         killTimer(event->timerId());
838         sendMouseMove(dropTarget);
839         sendMouseRelease(dropTarget);
840     }
841 
842     void mousePressEvent(QMouseEvent *)
843     {
844         QDrag *drag = new QDrag(this);
845         QMimeData *mimeData = new QMimeData;
846         mimeData->setData("application/x-qabstractitemmodeldatalist", QByteArray(""));
847         drag->setMimeData(mimeData);
848         startTimer(0);
849         dropAction_result = drag->start(dropAction_request);
850     }
851 
852 public:
853     Qt::DropAction dropAction() const { return dropAction_result; }
854 
855     void dragAndDrop(QWidget *dropTarget, Qt::DropAction dropAction)
856     {
857         this->dropTarget = dropTarget;
858         dropAction_request = dropAction;
859         sendMousePress(this);
860     }
861 };
862 
863 void tst_QAbstractItemView::dragAndDrop()
864 {
865     // From Task 137729
866 
867 
868     const int attempts = 10;
869     int successes = 0;
870     for (int i = 0; i < attempts; ++i) {
871         Qt::DropAction dropAction = Qt::MoveAction;
872 
873         DnDTestModel model;
874         DnDTestView view(dropAction, &model);
875         DnDTestWidget widget;
876 
877         const int size = 200;
878         widget.setFixedSize(size, size);
879         view.setFixedSize(size, size);
880 
881         widget.move(0, 0);
882         view.move(int(size * 1.5), int(size * 1.5));
883 
884         widget.show();
885         view.show();
886         QVERIFY(QTest::qWaitForWindowExposed(&widget));
887         QVERIFY(QTest::qWaitForWindowExposed(&view));
888 
889         widget.dragAndDrop(&view, dropAction);
890         if (model.dropAction() == dropAction
891             && widget.dropAction() == dropAction)
892             ++successes;
893     }
894 
895     if (successes < attempts) {
896         QString msg = QString("# successes (%1) < # attempts (%2)").arg(successes).arg(attempts);
897         QWARN(msg.toLatin1());
898     }
899     QVERIFY(successes > 0); // allow for some "event unstability" (i.e. unless
900                             // successes == 0, QAbstractItemView is probably ok!)
901 }
902 
903 void tst_QAbstractItemView::dragAndDropOnChild()
904 {
905 
906     const int attempts = 10;
907     int successes = 0;
908     for (int i = 0; i < attempts; ++i) {
909         Qt::DropAction dropAction = Qt::MoveAction;
910 
911         DnDTestModel model;
912         QModelIndex parent = model.index(0, 0);
913         model.insertRow(0, parent);
914         model.insertColumn(0, parent);
915         QModelIndex child = model.index(0, 0, parent);
916         model.setData(child, "child");
917         QCOMPARE(model.rowCount(parent), 1);
918         DnDTestView view(dropAction, &model);
919         view.setExpanded(parent, true);
920         view.setDragDropMode(QAbstractItemView::InternalMove);
921 
922         const int size = 200;
923         view.setFixedSize(size, size);
924         view.move(int(size * 1.5), int(size * 1.5));
925         view.show();
926         QVERIFY(QTest::qWaitForWindowExposed(&view));
927 
928         view.dragAndDrop(view.visualRect(parent).center(),
929                          view.visualRect(child).center());
930         if (model.dropAction() == dropAction)
931             ++successes;
932     }
933 
934     QCOMPARE(successes, 0);
935 }
936 
937 #endif // 0
938 #endif // !Q_OS_MAC && !Q_OS_WIN
939 
940 class TestModel : public QStandardItemModel
941 {
942 public:
943     TestModel(int rows, int columns) : QStandardItemModel(rows, columns)
944     {
945         setData_count = 0;
946     }
947 
948     virtual bool setData(const QModelIndex &/*index*/, const QVariant &/*value*/, int /*role = Qt::EditRole*/)
949     {
950         ++setData_count;
951         return true;
952     }
953 
954     int setData_count;
955 };
956 
957 typedef QList<int> IntList;
958 
959 void tst_QAbstractItemView::setItemDelegate_data()
960 {
961     // default is rows, a -1 will switch to columns
962     QTest::addColumn<IntList>("rowsOrColumnsWithDelegate");
963     QTest::addColumn<QPoint>("cellToEdit");
964     QTest::newRow("4 columndelegates")
965                 << (IntList() << -1 << 0 << 1 << 2 << 3)
966                 << QPoint(0, 0);
967     QTest::newRow("2 identical rowdelegates on the same row")
968                 << (IntList() << 0 << 0)
969                 << QPoint(0, 0);
970     QTest::newRow("2 identical columndelegates on the same column")
971                 << (IntList() << -1 << 2 << 2)
972                 << QPoint(2, 0);
973     QTest::newRow("2 duplicate delegates, 1 row and 1 column")
974                 << (IntList() << 0 << -1 << 2)
975                 << QPoint(2, 0);
976     QTest::newRow("4 duplicate delegates, 2 row and 2 column")
977                 << (IntList() << 0 << 0 << -1 << 2 << 2)
978                 << QPoint(2, 0);
979 
980 }
981 
982 void tst_QAbstractItemView::setItemDelegate()
983 {
984     QFETCH(IntList, rowsOrColumnsWithDelegate);
985     QFETCH(QPoint, cellToEdit);
986     QTableView v;
987     QItemDelegate *delegate = new QItemDelegate(&v);
988     TestModel model(5, 5);
989     v.setModel(&model);
990 
991     bool row = true;
992     foreach (int rc, rowsOrColumnsWithDelegate) {
993         if (rc == -1) {
994             row = !row;
995         } else {
996             if (row) {
997                 v.setItemDelegateForRow(rc, delegate);
998             } else {
999                 v.setItemDelegateForColumn(rc, delegate);
1000             }
1001         }
1002     }
1003     centerOnScreen(&v);
1004     moveCursorAway(&v);
1005     v.show();
1006 #if 0 // Used to be included in Qt4 for Q_WS_X11
1007     QCursor::setPos(v.geometry().center());
1008 #endif
1009     QApplication::setActiveWindow(&v);
1010     QVERIFY(QTest::qWaitForWindowActive(&v));
1011 
1012     QModelIndex index = model.index(cellToEdit.y(), cellToEdit.x());
1013     v.edit(index);
1014 
1015     // This will close the editor
1016     QTRY_VERIFY(QApplication::focusWidget());
1017     QWidget *editor = QApplication::focusWidget();
1018     QVERIFY(editor);
1019     editor->hide();
1020     delete editor;
1021     QCOMPARE(model.setData_count, 1);
1022     delete delegate;
1023 }
1024 
1025 void tst_QAbstractItemView::noFallbackToRoot()
1026 {
1027     QStandardItemModel model(0, 1);
1028     for (int i = 0; i < 5; ++i)
1029         model.appendRow(new QStandardItem("top" + QString::number(i)));
1030     QStandardItem *par1 = model.item(1);
1031     for (int j = 0; j < 15; ++j)
1032         par1->appendRow(new QStandardItem("sub" + QString::number(j)));
1033     QStandardItem *par2 = par1->child(2);
1034     for (int k = 0; k < 10; ++k)
1035         par2->appendRow(new QStandardItem("bot" + QString::number(k)));
1036     QStandardItem *it1 = par2->child(5);
1037 
1038     QModelIndex parent1 = model.indexFromItem(par1);
1039     QModelIndex parent2 = model.indexFromItem(par2);
1040     QModelIndex item1 = model.indexFromItem(it1);
1041 
1042     QTreeView v;
1043     v.setModel(&model);
1044     v.setRootIndex(parent1);
1045     v.setCurrentIndex(item1);
1046     QCOMPARE(v.currentIndex(), item1);
1047     QVERIFY(model.removeRows(0, 10, parent2));
1048     QCOMPARE(v.currentIndex(), parent2);
1049     QVERIFY(model.removeRows(0, 15, parent1));
1050     QCOMPARE(v.currentIndex(), QModelIndex());
1051 }
1052 
1053 void tst_QAbstractItemView::setCurrentIndex_data()
1054 {
1055     QTest::addColumn<QString>("viewType");
1056     QTest::addColumn<int>("itemFlags");
1057     QTest::addColumn<bool>("result");
1058 
1059     QStringList widgets;
1060     widgets << "QListView" << "QTreeView" << "QHeaderView" << "QTableView";
1061 
1062     foreach(QString widget, widgets) {
1063         QTest::newRow((widget+QLatin1String(": no flags")).toLocal8Bit().constData())
1064             << widget << (int)0 << false;
1065         QTest::newRow((widget+QLatin1String(": checkable")).toLocal8Bit().constData())
1066             << widget << (int)Qt::ItemIsUserCheckable << false;
1067         QTest::newRow((widget+QLatin1String(": selectable")).toLocal8Bit().constData())
1068             << widget << (int)Qt::ItemIsSelectable << false;
1069         QTest::newRow((widget+QLatin1String(": enabled")).toLocal8Bit().constData())
1070             << widget << (int)Qt::ItemIsEnabled << true;
1071         QTest::newRow((widget+QLatin1String(": enabled|selectable")).toLocal8Bit().constData())
1072             << widget << (int)(Qt::ItemIsSelectable|Qt::ItemIsEnabled) << true;
1073     }
1074 }
1075 
1076 void tst_QAbstractItemView::setCurrentIndex()
1077 {
1078     QFETCH(QString, viewType);
1079     QFETCH(int, itemFlags);
1080     QFETCH(bool, result);
1081 
1082     QScopedPointer<QAbstractItemView> view;
1083 
1084     if (viewType == "QListView")
1085         view.reset(new QListView());
1086     else if (viewType == "QTableView")
1087         view.reset(new QTableView());
1088     else if (viewType == "QTreeView")
1089         view.reset(new QTreeView());
1090     else if (viewType == "QHeaderView")
1091         view.reset(new QHeaderView(Qt::Vertical));
1092     else
1093         QVERIFY(0);
1094 
1095     centerOnScreen(view.data());
1096     moveCursorAway(view.data());
1097     view->show();
1098     QVERIFY(QTest::qWaitForWindowExposed(view.data()));
1099 
1100     QStandardItemModel *model = new QStandardItemModel(view.data());
1101     QStandardItem *item = new QStandardItem("first item");
1102     item->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
1103     model->appendRow(item);
1104 
1105     item = new QStandardItem("test item");
1106     item->setFlags(Qt::ItemFlags(itemFlags));
1107     model->appendRow(item);
1108 
1109     view->setModel(model);
1110 
1111     view->setCurrentIndex(model->index(0,0));
1112     QCOMPARE(view->currentIndex(), model->index(0,0));
1113     view->setCurrentIndex(model->index(1,0));
1114     QVERIFY(view->currentIndex() == model->index(result ? 1 : 0,0));
1115 }
1116 
1117 void tst_QAbstractItemView::task221955_selectedEditor()
1118 {
1119     QPushButton *button;
1120 
1121     QTreeWidget tree;
1122     tree.setColumnCount(2);
1123 
1124     tree.addTopLevelItem(new QTreeWidgetItem(QStringList() << "Foo" <<"1"));
1125     tree.addTopLevelItem(new QTreeWidgetItem(QStringList() << "Bar" <<"2"));
1126     tree.addTopLevelItem(new QTreeWidgetItem(QStringList() << "Baz" <<"3"));
1127 
1128     QTreeWidgetItem *dummy = new QTreeWidgetItem();
1129     tree.addTopLevelItem(dummy);
1130     tree.setItemWidget(dummy, 0, button = new QPushButton("More..."));
1131     button->setAutoFillBackground(true);  // as recommended in doc
1132 
1133     centerOnScreen(&tree);
1134     moveCursorAway(&tree);
1135     tree.show();
1136     tree.setFocus();
1137     tree.setCurrentIndex(tree.model()->index(1,0));
1138     QApplication::setActiveWindow(&tree);
1139     QVERIFY(QTest::qWaitForWindowActive(&tree));
1140 
1141     QVERIFY(! tree.selectionModel()->selectedIndexes().contains(tree.model()->index(3,0)));
1142 
1143     //We set the focus to the button, the index need to be selected
1144     button->setFocus();
1145     QTest::qWait(100);
1146     QVERIFY(tree.selectionModel()->selectedIndexes().contains(tree.model()->index(3,0)));
1147 
1148     tree.setCurrentIndex(tree.model()->index(1,0));
1149     QVERIFY(! tree.selectionModel()->selectedIndexes().contains(tree.model()->index(3,0)));
1150 
1151     //Same thing but with the flag NoSelection,   nothing can be selected.
1152     tree.setFocus();
1153     tree.setSelectionMode(QAbstractItemView::NoSelection);
1154     tree.clearSelection();
1155     QVERIFY(tree.selectionModel()->selectedIndexes().isEmpty());
1156     QTest::qWait(10);
1157     button->setFocus();
1158     QTest::qWait(50);
1159     QVERIFY(tree.selectionModel()->selectedIndexes().isEmpty());
1160 }
1161 
1162 void tst_QAbstractItemView::task250754_fontChange()
1163 {
1164     QString app_css = qApp->styleSheet();
1165     qApp->setStyleSheet("/*  */");
1166 
1167     QWidget w;
1168     QTreeView tree(&w);
1169     QVBoxLayout *vLayout = new QVBoxLayout(&w);
1170     vLayout->addWidget(&tree);
1171 
1172     QStandardItemModel *m = new QStandardItemModel(this);
1173     for (int i=0; i<20; ++i) {
1174         QStandardItem *item = new QStandardItem(QStringLiteral("Item number ") + QString::number(i));
1175         for (int j=0; j<5; ++j) {
1176             QStandardItem *child = new QStandardItem(QStringLiteral("Child Item number ") + QString::number(j));
1177             item->setChild(j, 0, child);
1178         }
1179         m->setItem(i, 0, item);
1180     }
1181     tree.setModel(m);
1182 
1183     tree.setHeaderHidden(true); // The header is (in certain styles) dpi dependent
1184     w.resize(160, 350); // Minimum width for windows with frame on Windows 8
1185     centerOnScreen(&w);
1186     moveCursorAway(&w);
1187     w.showNormal();
1188     QVERIFY(QTest::qWaitForWindowExposed(&w));
1189     QFont font = tree.font();
1190     font.setPixelSize(10);
1191     tree.setFont(font);
1192     QTRY_VERIFY(!tree.verticalScrollBar()->isVisible());
1193 
1194     font.setPixelSize(60);
1195     tree.setFont(font);
1196     //now with the huge items, the scrollbar must be visible
1197     QTRY_VERIFY(tree.verticalScrollBar()->isVisible());
1198 
1199     qApp->setStyleSheet(app_css);
1200 }
1201 
1202 void tst_QAbstractItemView::task200665_itemEntered()
1203 {
1204     //we test that view will emit entered
1205     //when the scrollbar move but not the mouse itself
1206     QStandardItemModel model(1000,1);
1207     QListView view;
1208     view.setModel(&model);
1209     centerOnScreen(&view);
1210     moveCursorAway(&view);
1211     view.show();
1212     QVERIFY(QTest::qWaitForWindowExposed(&view));
1213     QCursor::setPos( view.geometry().center() );
1214     QCoreApplication::processEvents();
1215     QSignalSpy spy(&view, SIGNAL(entered(QModelIndex)));
1216     view.verticalScrollBar()->setValue(view.verticalScrollBar()->maximum());
1217 
1218     QTRY_COMPARE(spy.count(), 1);
1219 }
1220 
1221 void tst_QAbstractItemView::task257481_emptyEditor()
1222 {
1223     QIcon icon = qApp->style()->standardIcon(QStyle::SP_ComputerIcon);
1224 
1225     QStandardItemModel model;
1226 
1227     model.appendRow( new QStandardItem(icon, QString()) );
1228     model.appendRow( new QStandardItem(icon, "Editor works") );
1229     model.appendRow( new QStandardItem( QString() ) );
1230 
1231     QTreeView treeView;
1232     treeView.setRootIsDecorated(false);
1233     treeView.setModel(&model);
1234     centerOnScreen(&treeView);
1235     moveCursorAway(&treeView);
1236     treeView.show();
1237     QVERIFY(QTest::qWaitForWindowExposed(&treeView));
1238 
1239     treeView.edit(model.index(0,0));
1240     QList<QLineEdit *> lineEditors = treeView.viewport()->findChildren<QLineEdit *>();
1241     QCOMPARE(lineEditors.count(), 1);
1242     QVERIFY(!lineEditors.first()->size().isEmpty());
1243 
1244     QTest::qWait(30);
1245 
1246     treeView.edit(model.index(1,0));
1247     lineEditors = treeView.viewport()->findChildren<QLineEdit *>();
1248     QCOMPARE(lineEditors.count(), 1);
1249     QVERIFY(!lineEditors.first()->size().isEmpty());
1250 
1251     QTest::qWait(30);
1252 
1253     treeView.edit(model.index(2,0));
1254     lineEditors = treeView.viewport()->findChildren<QLineEdit *>();
1255     QCOMPARE(lineEditors.count(), 1);
1256     QVERIFY(!lineEditors.first()->size().isEmpty());
1257 }
1258 
1259 void tst_QAbstractItemView::shiftArrowSelectionAfterScrolling()
1260 {
1261     QStandardItemModel model;
1262     for (int i=0; i<10; ++i) {
1263         QStandardItem *item = new QStandardItem(QString::number(i));
1264         model.setItem(i, 0, item);
1265     }
1266 
1267     QListView view;
1268     view.setFixedSize(160, 250); // Minimum width for windows with frame on Windows 8
1269     view.setFlow(QListView::LeftToRight);
1270     view.setGridSize(QSize(100, 100));
1271     view.setSelectionMode(QListView::ExtendedSelection);
1272     view.setViewMode(QListView::IconMode);
1273     view.setModel(&model);
1274     centerOnScreen(&view);
1275     moveCursorAway(&view);
1276     view.show();
1277     QVERIFY(QTest::qWaitForWindowExposed(&view));
1278 
1279     QModelIndex index0 = model.index(0, 0);
1280     QModelIndex index1 = model.index(1, 0);
1281     QModelIndex index9 = model.index(9, 0);
1282 
1283     view.selectionModel()->setCurrentIndex(index0, QItemSelectionModel::NoUpdate);
1284     QCOMPARE(view.currentIndex(), index0);
1285 
1286     view.scrollTo(index9);
1287     QTest::keyClick(&view, Qt::Key_Down, Qt::ShiftModifier);
1288 
1289     QCOMPARE(view.currentIndex(), index1);
1290     QModelIndexList selected = view.selectionModel()->selectedIndexes();
1291     QCOMPARE(selected.count(), 2);
1292     QVERIFY(selected.contains(index0));
1293     QVERIFY(selected.contains(index1));
1294 }
1295 
1296 void tst_QAbstractItemView::shiftSelectionAfterRubberbandSelection()
1297 {
1298     QStandardItemModel model;
1299     for (int i=0; i<3; ++i) {
1300         QStandardItem *item = new QStandardItem(QString::number(i));
1301         model.setItem(i, 0, item);
1302     }
1303 
1304     QListView view;
1305     view.setFixedSize(160, 450); // Minimum width for windows with frame on Windows 8
1306     view.setFlow(QListView::LeftToRight);
1307     view.setGridSize(QSize(100, 100));
1308     view.setSelectionMode(QListView::ExtendedSelection);
1309     view.setViewMode(QListView::IconMode);
1310     view.setModel(&model);
1311     centerOnScreen(&view);
1312     moveCursorAway(&view);
1313     view.show();
1314     QVERIFY(QTest::qWaitForWindowExposed(&view));
1315 
1316     QModelIndex index0 = model.index(0, 0);
1317     QModelIndex index1 = model.index(1, 0);
1318     QModelIndex index2 = model.index(2, 0);
1319 
1320     view.setCurrentIndex(index0);
1321     QCOMPARE(view.currentIndex(), index0);
1322 
1323     // Determine the points where the rubberband selection starts and ends
1324     QPoint pressPos = view.visualRect(index1).bottomRight() + QPoint(1, 1);
1325     QPoint releasePos = view.visualRect(index1).center();
1326     QVERIFY(!view.indexAt(pressPos).isValid());
1327     QCOMPARE(view.indexAt(releasePos), index1);
1328 
1329     // Select item 1 using a rubberband selection
1330     // The mouse move event has to be created manually because the QTest framework does not
1331     // contain a function for mouse moves with buttons pressed
1332     QTest::mousePress(view.viewport(), Qt::LeftButton, Qt::NoModifier, pressPos);
1333     QMouseEvent moveEvent(QEvent::MouseMove, releasePos, Qt::NoButton, Qt::LeftButton, Qt::NoModifier);
1334     bool moveEventReceived = qApp->notify(view.viewport(), &moveEvent);
1335     QVERIFY(moveEventReceived);
1336     QTest::mouseRelease(view.viewport(), Qt::LeftButton, Qt::NoModifier, releasePos);
1337     QCOMPARE(view.currentIndex(), index1);
1338 
1339     // Shift-click item 2
1340     QPoint item2Pos = view.visualRect(index2).center();
1341     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ShiftModifier, item2Pos);
1342     QCOMPARE(view.currentIndex(), index2);
1343 
1344     // Verify that the selection worked OK
1345     QModelIndexList selected = view.selectionModel()->selectedIndexes();
1346     QCOMPARE(selected.count(), 2);
1347     QVERIFY(selected.contains(index1));
1348     QVERIFY(selected.contains(index2));
1349 
1350     // Select item 0 to revert the selection
1351     view.setCurrentIndex(index0);
1352     QCOMPARE(view.currentIndex(), index0);
1353 
1354     // Repeat the same steps as above, but with a Shift-Arrow selection
1355     QTest::mousePress(view.viewport(), Qt::LeftButton, Qt::NoModifier, pressPos);
1356     QMouseEvent moveEvent2(QEvent::MouseMove, releasePos, Qt::NoButton, Qt::LeftButton, Qt::NoModifier);
1357     moveEventReceived = qApp->notify(view.viewport(), &moveEvent2);
1358     QVERIFY(moveEventReceived);
1359     QTest::mouseRelease(view.viewport(), Qt::LeftButton, Qt::NoModifier, releasePos);
1360     QCOMPARE(view.currentIndex(), index1);
1361 
1362     // Press Shift-Down
1363     QTest::keyClick(&view, Qt::Key_Down, Qt::ShiftModifier);
1364     QCOMPARE(view.currentIndex(), index2);
1365 
1366     // Verify that the selection worked OK
1367     selected = view.selectionModel()->selectedIndexes();
1368     QCOMPARE(selected.count(), 2);
1369     QVERIFY(selected.contains(index1));
1370     QVERIFY(selected.contains(index2));
1371 }
1372 
1373 void tst_QAbstractItemView::ctrlRubberbandSelection()
1374 {
1375     QStandardItemModel model;
1376     for (int i=0; i<3; ++i) {
1377         QStandardItem *item = new QStandardItem(QString::number(i));
1378         model.setItem(i, 0, item);
1379     }
1380 
1381     QListView view;
1382     view.setFixedSize(160, 450); // Minimum width for windows with frame on Windows 8
1383     view.setFlow(QListView::LeftToRight);
1384     view.setGridSize(QSize(100, 100));
1385     view.setSelectionMode(QListView::ExtendedSelection);
1386     view.setViewMode(QListView::IconMode);
1387     view.setModel(&model);
1388     centerOnScreen(&view);
1389     moveCursorAway(&view);
1390     view.show();
1391     QVERIFY(QTest::qWaitForWindowExposed(&view));
1392 
1393     QModelIndex index1 = model.index(1, 0);
1394     QModelIndex index2 = model.index(2, 0);
1395 
1396     // Select item 1
1397     view.setCurrentIndex(index1);
1398     QModelIndexList selected = view.selectionModel()->selectedIndexes();
1399     QCOMPARE(selected.count(), 1);
1400     QVERIFY(selected.contains(index1));
1401 
1402     // Now press control and draw a rubberband around items 1 and 2.
1403     // The mouse move event has to be created manually because the QTest framework does not
1404     // contain a function for mouse moves with buttons pressed.
1405     QPoint pressPos = view.visualRect(index1).topLeft() - QPoint(1, 1);
1406     QPoint releasePos = view.visualRect(index2).bottomRight() + QPoint(1, 1);
1407     QTest::mousePress(view.viewport(), Qt::LeftButton, Qt::ControlModifier, pressPos);
1408     QMouseEvent moveEvent(QEvent::MouseMove, releasePos, Qt::NoButton, Qt::LeftButton, Qt::ControlModifier);
1409     bool moveEventReceived = qApp->notify(view.viewport(), &moveEvent);
1410     QVERIFY(moveEventReceived);
1411     QTest::mouseRelease(view.viewport(), Qt::LeftButton, Qt::ControlModifier, releasePos);
1412 
1413     // Verify that item 2 is selected now
1414     selected = view.selectionModel()->selectedIndexes();
1415     QCOMPARE(selected.count(), 1);
1416     QVERIFY(selected.contains(index2));
1417 }
1418 
1419 void tst_QAbstractItemView::QTBUG6407_extendedSelection()
1420 {
1421     QListWidget view;
1422     view.setSelectionMode(QAbstractItemView::ExtendedSelection);
1423     for(int i = 0; i < 50; ++i)
1424         view.addItem(QString::number(i));
1425 
1426     QFont font = view.font();
1427     font.setPixelSize(10);
1428     view.setFont(font);
1429     view.resize(200,240);
1430     centerOnScreen(&view);
1431     moveCursorAway(&view);
1432 
1433     view.show();
1434     QApplication::setActiveWindow(&view);
1435     QVERIFY(QTest::qWaitForWindowActive(&view));
1436     QCOMPARE(static_cast<QWidget *>(&view), QApplication::activeWindow());
1437 
1438     view.verticalScrollBar()->setValue(view.verticalScrollBar()->maximum());
1439     QTest::qWait(20);
1440 
1441     QModelIndex index49 = view.model()->index(49,0);
1442     QPoint p = view.visualRect(index49).center();
1443     QVERIFY(view.viewport()->rect().contains(p));
1444     QTest::mouseClick(view.viewport(), Qt::LeftButton, 0, p);
1445     QCOMPARE(view.currentIndex(), index49);
1446     QCOMPARE(view.selectedItems().count(), 1);
1447 
1448     QModelIndex index47 = view.model()->index(47,0);
1449     p = view.visualRect(index47).center();
1450     QVERIFY(view.viewport()->rect().contains(p));
1451     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ShiftModifier, p);
1452     QCOMPARE(view.currentIndex(), index47);
1453     QCOMPARE(view.selectedItems().count(), 3); //49, 48, 47;
1454 
1455     QModelIndex index44 = view.model()->index(44,0);
1456     p = view.visualRect(index44).center();
1457     QVERIFY(view.viewport()->rect().contains(p));
1458     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ShiftModifier, p);
1459     QCOMPARE(view.currentIndex(), index44);
1460     QCOMPARE(view.selectedItems().count(), 6); //49 .. 44;
1461 
1462 }
1463 
1464 void tst_QAbstractItemView::QTBUG6753_selectOnSelection()
1465 {
1466     QTableWidget table(5, 5);
1467     for (int i = 0; i < table.rowCount(); ++i)
1468         for (int j = 0; j < table.columnCount(); ++j)
1469             table.setItem(i, j, new QTableWidgetItem("choo-be-doo-wah"));
1470 
1471     centerOnScreen(&table);
1472     moveCursorAway(&table);
1473     table.show();
1474     QVERIFY(QTest::qWaitForWindowExposed(&table));
1475 
1476     table.setSelectionMode(QAbstractItemView::ExtendedSelection);
1477     table.selectAll();
1478     QVERIFY(QTest::qWaitForWindowExposed(&table));
1479     QModelIndex item = table.model()->index(1,1);
1480     QRect itemRect = table.visualRect(item);
1481     QTest::mouseMove(table.viewport(), itemRect.center());
1482     QTest::mouseClick(table.viewport(), Qt::LeftButton, Qt::NoModifier, itemRect.center());
1483     QTest::qWait(20);
1484 
1485     QCOMPARE(table.selectedItems().count(), 1);
1486     QCOMPARE(table.selectedItems().first(), table.item(item.row(), item.column()));
1487 }
1488 
1489 void tst_QAbstractItemView::testDelegateDestroyEditor()
1490 {
1491     QTableWidget table(5, 5);
1492     MyAbstractItemDelegate delegate;
1493     table.setItemDelegate(&delegate);
1494     table.edit(table.model()->index(1, 1));
1495     QAbstractItemView *tv = &table;
1496     QVERIFY(!delegate.calledVirtualDtor);
1497     tv->closeEditor(delegate.openedEditor, QAbstractItemDelegate::NoHint);
1498     QVERIFY(delegate.calledVirtualDtor);
1499 }
1500 
1501 void tst_QAbstractItemView::testClickedSignal()
1502 {
1503     QTableWidget view(5, 5);
1504 
1505     centerOnScreen(&view);
1506     moveCursorAway(&view);
1507     view.showNormal();
1508     QApplication::setActiveWindow(&view);
1509     QVERIFY(QTest::qWaitForWindowActive(&view));
1510     QCOMPARE(static_cast<QWidget *>(&view), QApplication::activeWindow());
1511 
1512     QModelIndex index49 = view.model()->index(49,0);
1513     QPoint p = view.visualRect(index49).center();
1514     QVERIFY(view.viewport()->rect().contains(p));
1515 
1516     QSignalSpy clickedSpy(&view, SIGNAL(clicked(QModelIndex)));
1517 
1518     QTest::mouseClick(view.viewport(), Qt::LeftButton, 0, p);
1519     QCOMPARE(clickedSpy.count(), 1);
1520 
1521     QTest::mouseClick(view.viewport(), Qt::RightButton, 0, p);
1522     // We expect that right-clicks do not cause the clicked() signal to
1523     // be emitted.
1524     QCOMPARE(clickedSpy.count(), 1);
1525 
1526 }
1527 
1528 class StateChangeDelegate : public QItemDelegate {
1529   Q_OBJECT
1530 
1531 public:
1532   explicit StateChangeDelegate(QObject* parent = 0) :
1533     QItemDelegate(parent)
1534   {}
1535 
1536   void setEditorData(QWidget *editor, const QModelIndex &index) const Q_DECL_OVERRIDE {
1537       Q_UNUSED(index);
1538       static bool w = true;
1539       editor->setEnabled(w);
1540       w = !w;
1541   }
1542 };
1543 
1544 class StateChangeModel : public QStandardItemModel {
1545   Q_OBJECT
1546 
1547 public:
1548   explicit StateChangeModel(QObject *parent = 0) :
1549     QStandardItemModel(parent)
1550   {}
1551 
1552   void emitDataChanged() {
1553     emit dataChanged(index(0, 0), index(0, 1));
1554   }
1555 };
1556 
1557 
1558 void tst_QAbstractItemView::testChangeEditorState()
1559 {
1560     // Test for QTBUG-25370
1561     StateChangeModel model;
1562     {
1563       QStandardItem* item = new QStandardItem("a");
1564       model.setItem(0, 0, item);
1565     }
1566     {
1567       QStandardItem* item = new QStandardItem("b");
1568       model.setItem(0, 1, item);
1569     }
1570 
1571     QTableView view;
1572     view.setEditTriggers(QAbstractItemView::CurrentChanged);
1573     view.setItemDelegate(new StateChangeDelegate);
1574     view.setModel(&model);
1575     centerOnScreen(&view);
1576     moveCursorAway(&view);
1577     view.show();
1578     QApplication::setActiveWindow(&view);
1579     QVERIFY(QTest::qWaitForWindowActive(&view));
1580     QCOMPARE(static_cast<QWidget *>(&view), QApplication::activeWindow());
1581 
1582     model.emitDataChanged();
1583     // No segfault - the test passes.
1584 }
1585 
1586 void tst_QAbstractItemView::deselectInSingleSelection()
1587 {
1588     QTableView view;
1589     QStandardItemModel s;
1590     s.setRowCount(10);
1591     s.setColumnCount(10);
1592     view.setModel(&s);
1593     centerOnScreen(&view);
1594     moveCursorAway(&view);
1595     view.show();
1596     QVERIFY(QTest::qWaitForWindowExposed(&view));
1597     view.setSelectionMode(QAbstractItemView::SingleSelection);
1598     view.setEditTriggers(QAbstractItemView::NoEditTriggers);
1599     QApplication::setActiveWindow(&view);
1600     QVERIFY(QTest::qWaitForWindowExposed(&view));
1601     // mouse
1602     QModelIndex index22 = s.index(2, 2);
1603     QRect rect22 = view.visualRect(index22);
1604     QPoint clickpos = rect22.center();
1605     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, clickpos);
1606     QCOMPARE(view.currentIndex(), index22);
1607     QCOMPARE(view.selectionModel()->selectedIndexes().count(), 1);
1608     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ControlModifier, clickpos);
1609     QCOMPARE(view.currentIndex(), index22);
1610     QCOMPARE(view.selectionModel()->selectedIndexes().count(), 0);
1611 
1612     // second click with modifier however does select
1613     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ControlModifier, clickpos);
1614     QCOMPARE(view.currentIndex(), index22);
1615     QCOMPARE(view.selectionModel()->selectedIndexes().count(), 1);
1616 
1617     // keyboard
1618     QTest::keyClick(&view, Qt::Key_Space, Qt::NoModifier);
1619     QCOMPARE(view.currentIndex(), index22);
1620     QCOMPARE(view.selectionModel()->selectedIndexes().count(), 1);
1621     QTest::keyClick(&view, Qt::Key_Space, Qt::ControlModifier);
1622     QCOMPARE(view.currentIndex(), index22);
1623     QCOMPARE(view.selectionModel()->selectedIndexes().count(), 0);
1624 
1625     // second keypress with modifier however does select
1626     QTest::keyClick(&view, Qt::Key_Space, Qt::ControlModifier);
1627     QCOMPARE(view.currentIndex(), index22);
1628     QCOMPARE(view.selectionModel()->selectedIndexes().count(), 1);
1629 }
1630 
1631 void tst_QAbstractItemView::testNoActivateOnDisabledItem()
1632 {
1633     QTreeView treeView;
1634     QStandardItemModel model(1, 1);
1635     QStandardItem *item = new QStandardItem("item");
1636     model.setItem(0, 0, item);
1637     item->setFlags(Qt::NoItemFlags);
1638     treeView.setModel(&model);
1639     centerOnScreen(&treeView);
1640     moveCursorAway(&treeView);
1641     treeView.show();
1642 
1643     QApplication::setActiveWindow(&treeView);
1644     QVERIFY(QTest::qWaitForWindowActive(&treeView));
1645 
1646     QSignalSpy activatedSpy(&treeView, SIGNAL(activated(QModelIndex)));
1647 
1648     // Ensure clicking on a disabled item doesn't emit itemActivated.
1649     QModelIndex itemIndex = treeView.model()->index(0, 0);
1650     QPoint clickPos = treeView.visualRect(itemIndex).center();
1651     QTest::mouseClick(treeView.viewport(), Qt::LeftButton, 0, clickPos);
1652 
1653     QCOMPARE(activatedSpy.count(), 0);
1654 }
1655 
1656 void tst_QAbstractItemView::testFocusPolicy_data()
1657 {
1658     QTest::addColumn<QAbstractItemDelegate*>("delegate");
1659 
1660     QAbstractItemDelegate *styledItemDelegate = new QStyledItemDelegate(this);
1661     QAbstractItemDelegate *itemDelegate = new QItemDelegate(this);
1662 
1663     QTest::newRow("QStyledItemDelegate") << styledItemDelegate;
1664     QTest::newRow("QItemDelegate") << itemDelegate;
1665 }
1666 
1667 void tst_QAbstractItemView::testFocusPolicy()
1668 {
1669     QFETCH(QAbstractItemDelegate*, delegate);
1670 
1671     QWidget window;
1672     QTableView *table = new QTableView(&window);
1673     table->setItemDelegate(delegate);
1674     QVBoxLayout *layout = new QVBoxLayout(&window);
1675     layout->addWidget(table);
1676 
1677     QStandardItemModel model;
1678     model.setRowCount(10);
1679     model.setColumnCount(10);
1680     table->setModel(&model);
1681     table->setCurrentIndex(model.index(1, 1));
1682 
1683     centerOnScreen(&window);
1684     moveCursorAway(&window);
1685 
1686     window.show();
1687     QApplication::setActiveWindow(&window);
1688     QVERIFY(QTest::qWaitForWindowActive(&window));
1689 
1690     // itemview accepts focus => editor is closed => return focus to the itemview
1691     QPoint clickpos = table->visualRect(model.index(1, 1)).center();
1692     QTest::mouseDClick(table->viewport(), Qt::LeftButton, Qt::NoModifier, clickpos);
1693     QWidget *editor = qApp->focusWidget();
1694     QVERIFY(editor);
1695     QTest::keyClick(editor, Qt::Key_Escape, Qt::NoModifier);
1696     QCOMPARE(qApp->focusWidget(), table);
1697 
1698     // itemview doesn't accept focus => editor is closed => clear the focus
1699     table->setFocusPolicy(Qt::NoFocus);
1700     QTest::mouseDClick(table->viewport(), Qt::LeftButton, Qt::NoModifier, clickpos);
1701     editor = qApp->focusWidget();
1702     QVERIFY(editor);
1703     QTest::keyClick(editor, Qt::Key_Escape, Qt::NoModifier);
1704     QVERIFY(!qApp->focusWidget());
1705 }
1706 
1707 void tst_QAbstractItemView::QTBUG31411_noSelection()
1708 {
1709     QWidget window;
1710     QTableView *table = new QTableView(&window);
1711     table->setSelectionMode(QAbstractItemView::NoSelection);
1712     QVBoxLayout *layout = new QVBoxLayout(&window);
1713     layout->addWidget(table);
1714 
1715     QStandardItemModel model;
1716     model.setRowCount(10);
1717     model.setColumnCount(10);
1718     table->setModel(&model);
1719     table->setCurrentIndex(model.index(1, 1));
1720 
1721     centerOnScreen(&window);
1722     moveCursorAway(&window);
1723 
1724     window.show();
1725     QApplication::setActiveWindow(&window);
1726     QVERIFY(QTest::qWaitForWindowActive(&window));
1727 
1728     qRegisterMetaType<QItemSelection>();
1729     QSignalSpy selectionChangeSpy(table->selectionModel(), SIGNAL(selectionChanged(QItemSelection,QItemSelection)));
1730     QVERIFY(selectionChangeSpy.isValid());
1731 
1732     QPoint clickpos = table->visualRect(model.index(1, 1)).center();
1733     QTest::mouseClick(table->viewport(), Qt::LeftButton, Qt::NoModifier, clickpos);
1734     QTest::mouseDClick(table->viewport(), Qt::LeftButton, Qt::NoModifier, clickpos);
1735 
1736     QPointer<QWidget> editor1 = qApp->focusWidget();
1737     QVERIFY(editor1);
1738     QTest::keyClick(editor1, Qt::Key_Tab, Qt::NoModifier);
1739 
1740     QPointer<QWidget> editor2 = qApp->focusWidget();
1741     QVERIFY(editor2);
1742     QTest::keyClick(editor2, Qt::Key_Escape, Qt::NoModifier);
1743 
1744     QCOMPARE(selectionChangeSpy.count(), 0);
1745 }
1746 
1747 void tst_QAbstractItemView::QTBUG39324_settingSameInstanceOfIndexWidget()
1748 {
1749     QStringList list;
1750     list << "FOO" << "bar";
1751     QScopedPointer<QStringListModel> model(new QStringListModel(list));
1752 
1753     QScopedPointer<QTableView> table(new QTableView());
1754     table->setModel(model.data());
1755 
1756     QModelIndex index = model->index(0,0);
1757     QLineEdit *lineEdit = new QLineEdit();
1758     table->setIndexWidget(index, lineEdit);
1759     table->setIndexWidget(index, lineEdit);
1760     QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);
1761     table->show();
1762 }
1763 
1764 void tst_QAbstractItemView::shiftSelectionAfterChangingModelContents()
1765 {
1766     QStringList list;
1767     list << "A" << "B" << "C" << "D" << "E" << "F";
1768     QStringListModel model(list);
1769     QSortFilterProxyModel proxyModel;
1770     proxyModel.setSourceModel(&model);
1771     proxyModel.sort(0, Qt::AscendingOrder);
1772     proxyModel.setDynamicSortFilter(true);
1773 
1774     QPersistentModelIndex indexA(proxyModel.index(0, 0));
1775     QPersistentModelIndex indexB(proxyModel.index(1, 0));
1776     QPersistentModelIndex indexC(proxyModel.index(2, 0));
1777     QPersistentModelIndex indexD(proxyModel.index(3, 0));
1778     QPersistentModelIndex indexE(proxyModel.index(4, 0));
1779     QPersistentModelIndex indexF(proxyModel.index(5, 0));
1780 
1781     QListView view;
1782     view.setModel(&proxyModel);
1783     view.setSelectionMode(QAbstractItemView::ExtendedSelection);
1784     view.show();
1785     QTest::qWaitForWindowExposed(&view);
1786 
1787     // Click "C"
1788     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, view.visualRect(indexC).center());
1789     QModelIndexList selected = view.selectionModel()->selectedIndexes();
1790     QCOMPARE(selected.count(), 1);
1791     QVERIFY(selected.contains(indexC));
1792 
1793     // Insert new item "B1"
1794     model.insertRow(0);
1795     model.setData(model.index(0, 0), "B1");
1796 
1797     // Shift-click "D" -> we expect that "C" and "D" are selected
1798     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ShiftModifier, view.visualRect(indexD).center());
1799     selected = view.selectionModel()->selectedIndexes();
1800     QCOMPARE(selected.count(), 2);
1801     QVERIFY(selected.contains(indexC));
1802     QVERIFY(selected.contains(indexD));
1803 
1804     // Click "D"
1805     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, view.visualRect(indexD).center());
1806     selected = view.selectionModel()->selectedIndexes();
1807     QCOMPARE(selected.count(), 1);
1808     QVERIFY(selected.contains(indexD));
1809 
1810     // Remove items "B" and "C"
1811     model.removeRows(proxyModel.mapToSource(indexB).row(), 1);
1812     model.removeRows(proxyModel.mapToSource(indexC).row(), 1);
1813     QVERIFY(!indexB.isValid());
1814     QVERIFY(!indexC.isValid());
1815 
1816     // Shift-click "F" -> we expect that "D", "E", and "F" are selected
1817     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ShiftModifier, view.visualRect(indexF).center());
1818     selected = view.selectionModel()->selectedIndexes();
1819     QCOMPARE(selected.count(), 3);
1820     QVERIFY(selected.contains(indexD));
1821     QVERIFY(selected.contains(indexE));
1822     QVERIFY(selected.contains(indexF));
1823 
1824     // Move to "A" by pressing "Up" repeatedly
1825     while (view.currentIndex() != indexA) {
1826         QTest::keyClick(&view, Qt::Key_Up);
1827     }
1828     selected = view.selectionModel()->selectedIndexes();
1829     QCOMPARE(selected.count(), 1);
1830     QVERIFY(selected.contains(indexA));
1831 
1832     // Change the sort order
1833     proxyModel.sort(0, Qt::DescendingOrder);
1834 
1835     // Shift-click "F" -> All items should be selected
1836     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::ShiftModifier, view.visualRect(indexF).center());
1837     selected = view.selectionModel()->selectedIndexes();
1838     QCOMPARE(selected.count(), model.rowCount());
1839 
1840     // Restore the old sort order
1841     proxyModel.sort(0, Qt::AscendingOrder);
1842 
1843     // Click "D"
1844     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, view.visualRect(indexD).center());
1845     selected = view.selectionModel()->selectedIndexes();
1846     QCOMPARE(selected.count(), 1);
1847     QVERIFY(selected.contains(indexD));
1848 
1849     // Insert new item "B2"
1850     model.insertRow(0);
1851     model.setData(model.index(0, 0), "B2");
1852 
1853     // Press Shift+Down -> "D" and "E" should be selected.
1854     QTest::keyClick(&view, Qt::Key_Down, Qt::ShiftModifier);
1855     selected = view.selectionModel()->selectedIndexes();
1856     QCOMPARE(selected.count(), 2);
1857     QVERIFY(selected.contains(indexD));
1858     QVERIFY(selected.contains(indexE));
1859 
1860     // Click "A" to reset the current selection starting point;
1861     //then select "D" via QAbstractItemView::setCurrentIndex(const QModelIndex&).
1862     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, view.visualRect(indexA).center());
1863     view.setCurrentIndex(indexD);
1864     selected = view.selectionModel()->selectedIndexes();
1865     QCOMPARE(selected.count(), 1);
1866     QVERIFY(selected.contains(indexD));
1867 
1868     // Insert new item "B3"
1869     model.insertRow(0);
1870     model.setData(model.index(0, 0), "B3");
1871 
1872     // Press Shift+Down -> "D" and "E" should be selected.
1873     QTest::keyClick(&view, Qt::Key_Down, Qt::ShiftModifier);
1874     selected = view.selectionModel()->selectedIndexes();
1875     QCOMPARE(selected.count(), 2);
1876     QVERIFY(selected.contains(indexD));
1877     QVERIFY(selected.contains(indexE));
1878 }
1879 
1880 void tst_QAbstractItemView::QTBUG48968_reentrant_updateEditorGeometries()
1881 {
1882 
1883     QStandardItemModel *m = new QStandardItemModel(this);
1884     for (int i=0; i<10; ++i) {
1885         QStandardItem *item = new QStandardItem(QString("Item number %1").arg(i));
1886         item->setEditable(true);
1887         for (int j=0; j<5; ++j) {
1888             QStandardItem *child = new QStandardItem(QString("Child Item number %1").arg(j));
1889             item->setChild(j, 0, child);
1890         }
1891         m->setItem(i, 0, item);
1892     }
1893 
1894     QTreeView tree;
1895     tree.setModel(m);
1896     tree.setRootIsDecorated(false);
1897     QObject::connect(&tree, SIGNAL(doubleClicked(QModelIndex)), &tree, SLOT(setRootIndex(QModelIndex)));
1898     tree.show();
1899     QTest::qWaitForWindowActive(&tree);
1900 
1901     // Trigger editing idx
1902     QModelIndex idx = m->index(1, 0);
1903     const QPoint pos = tree.visualRect(idx).center();
1904     QTest::mouseClick(tree.viewport(), Qt::LeftButton, Qt::NoModifier, pos);
1905     QTest::mouseDClick(tree.viewport(), Qt::LeftButton, Qt::NoModifier, pos);
1906 
1907     // Add more children to idx
1908     QStandardItem *item = m->itemFromIndex(idx);
1909     for (int j=5; j<10; ++j) {
1910         QStandardItem *child = new QStandardItem(QString("Child Item number %1").arg(j));
1911         item->setChild(j, 0, child);
1912     }
1913 
1914     // No crash, all fine.
1915 }
1916 
1917 class ScrollModeProxyStyle: public QProxyStyle
1918 {
1919 public:
1920     ScrollModeProxyStyle(QAbstractItemView::ScrollMode sm, QStyle *style = 0)
1921         : QProxyStyle(style)
1922         , scrollMode(sm == QAbstractItemView::ScrollPerItem ?
1923                      QAbstractItemView::ScrollPerPixel : QAbstractItemView::ScrollPerItem)
1924     { }
1925 
1926     int styleHint(QStyle::StyleHint hint, const QStyleOption *opt, const QWidget *w, QStyleHintReturn *returnData) const override
1927     {
1928         if (hint == SH_ItemView_ScrollMode)
1929             return scrollMode;
1930 
1931         return baseStyle()->styleHint(hint, opt, w, returnData);
1932     }
1933 
1934     QAbstractItemView::ScrollMode scrollMode;
1935 };
1936 
1937 void tst_QAbstractItemView::QTBUG50102_SH_ItemView_ScrollMode()
1938 {
1939     QListView view;
1940 
1941     // Default comes from the style
1942     auto styleScrollMode = static_cast<QAbstractItemView::ScrollMode>(view.style()->styleHint(QStyle::SH_ItemView_ScrollMode, 0, &view, 0));
1943     QCOMPARE(view.verticalScrollMode(), styleScrollMode);
1944     QCOMPARE(view.horizontalScrollMode(), styleScrollMode);
1945 
1946     // Change style, get new value
1947     view.setStyle(new ScrollModeProxyStyle(styleScrollMode));
1948     auto proxyScrollMode = static_cast<QAbstractItemView::ScrollMode>(view.style()->styleHint(QStyle::SH_ItemView_ScrollMode, 0, &view, 0));
1949     QVERIFY(styleScrollMode != proxyScrollMode);
1950     QCOMPARE(view.verticalScrollMode(), proxyScrollMode);
1951     QCOMPARE(view.horizontalScrollMode(), proxyScrollMode);
1952 
1953     // Explicitly set vertical, same value
1954     view.setVerticalScrollMode(proxyScrollMode);
1955     QCOMPARE(view.verticalScrollMode(), proxyScrollMode);
1956     QCOMPARE(view.horizontalScrollMode(), proxyScrollMode);
1957 
1958     // Change style, won't change value for vertical, will change for horizontal
1959     view.setStyle(new ScrollModeProxyStyle(proxyScrollMode));
1960     QCOMPARE(view.verticalScrollMode(), proxyScrollMode);
1961     QCOMPARE(view.horizontalScrollMode(), styleScrollMode);
1962 }
1963 
1964 void tst_QAbstractItemView::QTBUG50535_update_on_new_selection_model()
1965 {
1966     QStandardItemModel model;
1967     for (int i = 0; i < 10; ++i)
1968         model.appendRow(new QStandardItem(QStringLiteral("%1").arg(i)));
1969 
1970     class ListView : public QListView
1971     {
1972     public:
1973         ListView()
1974             : m_paintEventsCount(0), m_deselectedMustBeEmpty(false), m_selectionChangedOk(true)
1975         {
1976         }
1977 
1978         void setSelectionModel(QItemSelectionModel *model) Q_DECL_OVERRIDE
1979         {
1980             m_deselectedMustBeEmpty = !selectionModel() || !model || selectionModel()->model() != model->model();
1981             QListView::setSelectionModel(model);
1982             m_deselectedMustBeEmpty = false;
1983         }
1984         int m_paintEventsCount;
1985         bool selectionChangedOk() const { return m_selectionChangedOk; }
1986 
1987     protected:
1988         bool viewportEvent(QEvent *event) Q_DECL_OVERRIDE
1989         {
1990             if (event->type() == QEvent::Paint)
1991                 ++m_paintEventsCount;
1992             return QListView::viewportEvent(event);
1993         }
1994 
1995         void selectionChanged(const QItemSelection &selected,
1996                               const QItemSelection &deselected) Q_DECL_OVERRIDE
1997         {
1998             if (m_deselectedMustBeEmpty && !deselected.isEmpty())
1999                 m_selectionChangedOk = false;
2000 
2001             // Make sure both selections belong to the same model
2002             foreach (const QModelIndex &nmi, selected.indexes()) {
2003                 foreach (const QModelIndex &omi, deselected.indexes()) {
2004                     m_selectionChangedOk = m_selectionChangedOk && (nmi.model() == omi.model());
2005                 }
2006             }
2007             QListView::selectionChanged(selected, deselected);
2008         }
2009     private:
2010         bool m_deselectedMustBeEmpty;
2011         bool m_selectionChangedOk;
2012     };
2013 
2014     // keep the current/selected row in the "low range", i.e. be sure it's visible, otherwise we
2015     // don't get updates and the test fails.
2016 
2017     ListView view;
2018     view.setModel(&model);
2019     view.selectionModel()->setCurrentIndex(model.index(1, 0), QItemSelectionModel::SelectCurrent);
2020     view.show();
2021     QVERIFY(QTest::qWaitForWindowExposed(&view));
2022     QVERIFY(view.selectionChangedOk());
2023 
2024     QItemSelectionModel selectionModel(&model);
2025     selectionModel.setCurrentIndex(model.index(2, 0), QItemSelectionModel::Current);
2026 
2027     int oldPaintEventsCount = view.m_paintEventsCount;
2028     view.setSelectionModel(&selectionModel);
2029     QTRY_VERIFY(view.m_paintEventsCount > oldPaintEventsCount);
2030     QVERIFY(view.selectionChangedOk());
2031 
2032 
2033     QItemSelectionModel selectionModel2(&model);
2034     selectionModel2.select(model.index(0, 0), QItemSelectionModel::ClearAndSelect);
2035     selectionModel2.setCurrentIndex(model.index(1, 0), QItemSelectionModel::Current);
2036 
2037     oldPaintEventsCount = view.m_paintEventsCount;
2038     view.setSelectionModel(&selectionModel2);
2039     QTRY_VERIFY(view.m_paintEventsCount > oldPaintEventsCount);
2040     QVERIFY(view.selectionChangedOk());
2041 
2042     // Tests QAbstractItemView::selectionChanged
2043     QStandardItemModel model1;
2044     for (int i = 0; i < 10; ++i)
2045         model1.appendRow(new QStandardItem(QString::number(i)));
2046     view.setModel(&model1);
2047 
2048     QItemSelectionModel selectionModel1(&model1);
2049     selectionModel1.select(model1.index(0, 0), QItemSelectionModel::ClearAndSelect);
2050     selectionModel1.setCurrentIndex(model1.index(1, 0), QItemSelectionModel::Current);
2051     view.setSelectionModel(&selectionModel1);
2052     QVERIFY(view.selectionChangedOk());
2053 }
2054 
2055 void tst_QAbstractItemView::testSelectionModelInSyncWithView()
2056 {
2057     QStandardItemModel model;
2058     for (int i = 0; i < 10; ++i)
2059         model.appendRow(new QStandardItem(QStringLiteral("%1").arg(i)));
2060 
2061     class ListView : public QListView
2062     {
2063     public:
2064         using QListView::selectedIndexes;
2065     };
2066 
2067     ListView view;
2068     QVERIFY(!view.selectionModel());
2069 
2070     view.setModel(&model);
2071     QVERIFY(view.selectionModel());
2072     QVERIFY(view.selectedIndexes().isEmpty());
2073     QVERIFY(view.selectionModel()->selection().isEmpty());
2074 
2075     view.setCurrentIndex(model.index(0, 0));
2076     QCOMPARE(view.currentIndex(), model.index(0, 0));
2077     QCOMPARE(view.selectionModel()->currentIndex(), model.index(0, 0));
2078 
2079     view.selectionModel()->setCurrentIndex(model.index(1, 0), QItemSelectionModel::SelectCurrent);
2080     QCOMPARE(view.currentIndex(), model.index(1, 0));
2081     QCOMPARE(view.selectedIndexes(), QModelIndexList() << model.index(1, 0));
2082     QCOMPARE(view.selectionModel()->currentIndex(), model.index(1, 0));
2083     QCOMPARE(view.selectionModel()->selection().indexes(), QModelIndexList() << model.index(1, 0));
2084 
2085     view.show();
2086     QVERIFY(QTest::qWaitForWindowExposed(&view));
2087 
2088     QItemSelectionModel selectionModel(&model);
2089     selectionModel.setCurrentIndex(model.index(2, 0), QItemSelectionModel::Current);
2090 
2091     view.setSelectionModel(&selectionModel);
2092     QCOMPARE(view.currentIndex(), model.index(2, 0));
2093     QCOMPARE(view.selectedIndexes(), QModelIndexList());
2094     QCOMPARE(view.selectionModel()->currentIndex(), model.index(2, 0));
2095     QCOMPARE(view.selectionModel()->selection().indexes(),  QModelIndexList());
2096 
2097 
2098     QItemSelectionModel selectionModel2(&model);
2099     selectionModel2.select(model.index(0, 0), QItemSelectionModel::ClearAndSelect);
2100     selectionModel2.setCurrentIndex(model.index(1, 0), QItemSelectionModel::Current);
2101 
2102     view.setSelectionModel(&selectionModel2);
2103     QCOMPARE(view.currentIndex(), model.index(1, 0));
2104     QCOMPARE(view.selectedIndexes(), QModelIndexList() << model.index(0, 0));
2105     QCOMPARE(view.selectionModel()->currentIndex(), model.index(1, 0));
2106     QCOMPARE(view.selectionModel()->selection().indexes(),  QModelIndexList() << model.index(0, 0));
2107 }
2108 
2109 class SetSelectionTestView : public QListView
2110 {
2111     Q_OBJECT
2112 public:
2113     SetSelectionTestView() : QListView() {}
2114 
2115 signals:
2116     void setSelectionCalled(const QRect &rect);
2117 
2118 protected:
2119     void setSelection(const QRect &rect, QItemSelectionModel::SelectionFlags flags) Q_DECL_OVERRIDE
2120     {
2121         emit setSelectionCalled(rect);
2122         QListView::setSelection(rect, flags);
2123     }
2124 };
2125 
2126 void tst_QAbstractItemView::testClickToSelect()
2127 {
2128     // This test verifies that the QRect that is passed from QAbstractItemView::mousePressEvent
2129     // to the virtual method QAbstractItemView::setSelection(const QRect &, SelectionFlags)
2130     // is the 1x1 rect which conains exactly the clicked pixel if no modifiers are pressed.
2131 
2132     QStringList list;
2133     list << "A" << "B" << "C";
2134     QStringListModel model(list);
2135 
2136     SetSelectionTestView view;
2137     view.setModel(&model);
2138     view.show();
2139     QTest::qWaitForWindowExposed(&view);
2140 
2141     QSignalSpy spy(&view, &SetSelectionTestView::setSelectionCalled);
2142 
2143     const QModelIndex indexA(model.index(0, 0));
2144     const QRect visualRectA = view.visualRect(indexA);
2145     const QPoint centerA = visualRectA.center();
2146 
2147     // Click the center of the visualRect of item "A"
2148     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, centerA);
2149     QCOMPARE(spy.count(), 1);
2150     QCOMPARE(spy.back().front().value<QRect>(), QRect(centerA, QSize(1, 1)));
2151 
2152     // Click a point slightly away from the center
2153     const QPoint nearCenterA = centerA + QPoint(1, 1);
2154     QVERIFY(visualRectA.contains(nearCenterA));
2155     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, nearCenterA);
2156     QCOMPARE(spy.count(), 2);
2157     QCOMPARE(spy.back().front().value<QRect>(), QRect(nearCenterA, QSize(1, 1)));
2158 }
2159 
2160 class HoverItemDelegate : public QItemDelegate
2161 {
2162 public:
2163     void paint(QPainter *painter, const QStyleOptionViewItem &opt, const QModelIndex &index) const override
2164     {
2165         Q_UNUSED(index);
2166         if (opt.state & QStyle::State_MouseOver)
2167             painter->fillRect(opt.rect, Qt::red);
2168         else
2169             painter->fillRect(opt.rect, Qt::blue);
2170     }
2171 };
2172 
2173 void tst_QAbstractItemView::QTBUG46785_mouseout_keeps_hover_state()
2174 {
2175     QTableWidget table(5, 5);
2176     table.verticalHeader()->hide();
2177     table.horizontalHeader()->hide();
2178     table.setMouseTracking(true);
2179     table.setItemDelegate(new HoverItemDelegate);
2180     centerOnScreen(&table);
2181     table.show();
2182     QVERIFY(QTest::qWaitForWindowActive(&table));
2183 
2184     QModelIndex item = table.model()->index(0,0);
2185     QRect itemRect = table.visualRect(item);
2186 
2187     // Move the mouse into the center of the item at 0,0
2188     QTest::mouseMove(table.viewport(), itemRect.center());
2189     QTest::mouseClick(table.viewport(), Qt::LeftButton, 0, itemRect.center());
2190 
2191     // Check to see if the pixel is red (mouse over)
2192     QImage img = table.grab().toImage();
2193     QCOMPARE(img.pixel(itemRect.center()), qRgb(255, 0, 0));
2194 
2195     // Move the mouse off the table
2196     QTest::mouseMove(table.viewport(), QPoint(-50, 0));
2197     QTest::mouseClick(table.viewport(), Qt::LeftButton, 0, QPoint(-50, 0));
2198 
2199     // Check to see if the pixel is blue (mouse out)
2200     img = table.grab().toImage();
2201     QCOMPARE(img.pixel(itemRect.center()), qRgb(0, 0, 255));
2202 }
2203 
2204 QTEST_MAIN(tst_QAbstractItemView)
2205 #include "tst_qabstractitemview.moc"
