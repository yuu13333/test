Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Copyright (C) 2013 Olivier Goffart <ogoffart@woboq.com>
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qobject.h"
43 #include "qobject_p.h"
44 #include "qmetaobject_p.h"
45 
46 #include "qabstracteventdispatcher.h"
47 #include "qabstracteventdispatcher_p.h"
48 #include "qcoreapplication.h"
49 #include "qcoreapplication_p.h"
50 #include "qvariant.h"
51 #include "qmetaobject.h"
52 #include <qregexp.h>
53 #if QT_CONFIG(regularexpression)
54 #  include <qregularexpression.h>
55 #endif
56 #include <qthread.h>
57 #include <private/qthread_p.h>
58 #include <qdebug.h>
59 #include <qpair.h>
60 #include <qvarlengtharray.h>
61 #include <qset.h>
62 #if QT_CONFIG(thread)
63 #include <qsemaphore.h>
64 #endif
65 #include <qsharedpointer.h>
66 
67 #include <private/qorderedmutexlocker_p.h>
68 #include <private/qhooks_p.h>
69 #include <qtcore_tracepoints_p.h>
70 
71 #include <new>
72 
73 #include <ctype.h>
74 #include <limits.h>
75 
76 QT_BEGIN_NAMESPACE
77 
78 static int DIRECT_CONNECTION_ONLY = 0;
79 
80 Q_CORE_EXPORT QSignalSpyCallbackSet *qt_signal_spy_callback_set = nullptr;
81 
82 void qt_register_signal_spy_callbacks(QSignalSpyCallbackSet *callback_set)
83 {
84     qt_signal_spy_callback_set = callback_set;
85 }
86 
87 QDynamicMetaObjectData::~QDynamicMetaObjectData()
88 {
89 }
90 
91 QAbstractDynamicMetaObject::~QAbstractDynamicMetaObject()
92 {
93 }
94 
95 
96 struct QSlotObjectBaseDeleter { // for use with QScopedPointer<QSlotObjectBase,...>
97     static void cleanup(QtPrivate::QSlotObjectBase *slot) {
98         if (slot) slot->destroyIfLastRef();
99     }
100 };
101 static int *queuedConnectionTypes(const QList<QByteArray> &typeNames)
102 {
103     int *types = new int [typeNames.count() + 1];
104     Q_CHECK_PTR(types);
105     for (int i = 0; i < typeNames.count(); ++i) {
106         const QByteArray typeName = typeNames.at(i);
107         if (typeName.endsWith('*'))
108             types[i] = QMetaType::VoidStar;
109         else
110             types[i] = QMetaType::type(typeName);
111 
112         if (!types[i]) {
113             qWarning("QObject::connect: Cannot queue arguments of type '%s'\n"
114                      "(Make sure '%s' is registered using qRegisterMetaType().)",
115                      typeName.constData(), typeName.constData());
116             delete [] types;
117             return 0;
118         }
119     }
120     types[typeNames.count()] = 0;
121 
122     return types;
123 }
124 
125 static int *queuedConnectionTypes(const QArgumentType *argumentTypes, int argc)
126 {
127     QScopedArrayPointer<int> types(new int [argc + 1]);
128     for (int i = 0; i < argc; ++i) {
129         const QArgumentType &type = argumentTypes[i];
130         if (type.type())
131             types[i] = type.type();
132         else if (type.name().endsWith('*'))
133             types[i] = QMetaType::VoidStar;
134         else
135             types[i] = QMetaType::type(type.name());
136 
137         if (!types[i]) {
138             qWarning("QObject::connect: Cannot queue arguments of type '%s'\n"
139                      "(Make sure '%s' is registered using qRegisterMetaType().)",
140                      type.name().constData(), type.name().constData());
141             return 0;
142         }
143     }
144     types[argc] = 0;
145 
146     return types.take();
147 }
148 
149 static QBasicMutex _q_ObjectMutexPool[131];
150 
151 /**
152  * \internal
153  * mutex to be locked when accessing the connectionlists or the senders list
154  */
155 static inline QMutex *signalSlotLock(const QObject *o)
156 {
157     return static_cast<QMutex *>(&_q_ObjectMutexPool[
158         uint(quintptr(o)) % sizeof(_q_ObjectMutexPool)/sizeof(QBasicMutex)]);
159 }
160 
161 #if QT_VERSION < 0x60000
162 extern "C" Q_CORE_EXPORT void qt_addObject(QObject *)
163 {}
164 
165 extern "C" Q_CORE_EXPORT void qt_removeObject(QObject *)
166 {}
167 #endif
168 
169 void (*QAbstractDeclarativeData::destroyed)(QAbstractDeclarativeData *, QObject *) = 0;
170 void (*QAbstractDeclarativeData::destroyed_qml1)(QAbstractDeclarativeData *, QObject *) = 0;
171 void (*QAbstractDeclarativeData::parentChanged)(QAbstractDeclarativeData *, QObject *, QObject *) = 0;
172 void (*QAbstractDeclarativeData::signalEmitted)(QAbstractDeclarativeData *, QObject *, int, void **) = 0;
173 int  (*QAbstractDeclarativeData::receivers)(QAbstractDeclarativeData *, const QObject *, int) = 0;
174 bool (*QAbstractDeclarativeData::isSignalConnected)(QAbstractDeclarativeData *, const QObject *, int) = 0;
175 void (*QAbstractDeclarativeData::setWidgetParent)(QObject *, QObject *) = 0;
176 
177 QObjectData::~QObjectData() {}
178 
179 QMetaObject *QObjectData::dynamicMetaObject() const
180 {
181     return metaObject->toDynamicMetaObject(q_ptr);
182 }
183 
184 QObjectPrivate::QObjectPrivate(int version)
185     : threadData(0), currentChildBeingDeleted(0)
186 {
187 #ifdef QT_BUILD_INTERNAL
188     // Don't check the version parameter in internal builds.
189     // This allows incompatible versions to be loaded, possibly for testing.
190     Q_UNUSED(version);
191 #else
192     if (Q_UNLIKELY(version != QObjectPrivateVersion))
193         qFatal("Cannot mix incompatible Qt library (version 0x%x) with this library (version 0x%x)",
194                 version, QObjectPrivateVersion);
195 #endif
196 
197     // QObjectData initialization
198     q_ptr = 0;
199     parent = 0;                                 // no parent yet. It is set by setParent()
200     isWidget = false;                           // assume not a widget object
201     blockSig = false;                           // not blocking signals
202     wasDeleted = false;                         // double-delete catcher
203     isDeletingChildren = false;                 // set by deleteChildren()
204     sendChildEvents = true;                     // if we should send ChildAdded and ChildRemoved events to parent
205     receiveChildEvents = true;
206     postedEvents = 0;
207     extraData = 0;
208     metaObject = 0;
209     isWindow = false;
210     deleteLaterCalled = false;
211 }
212 
213 QObjectPrivate::~QObjectPrivate()
214 {
215     if (extraData && !extraData->runningTimers.isEmpty()) {
216         if (Q_LIKELY(threadData->thread == QThread::currentThread())) {
217             // unregister pending timers
218             if (threadData->hasEventDispatcher())
219                 threadData->eventDispatcher.load()->unregisterTimers(q_ptr);
220 
221             // release the timer ids back to the pool
222             for (int i = 0; i < extraData->runningTimers.size(); ++i)
223                 QAbstractEventDispatcherPrivate::releaseTimerId(extraData->runningTimers.at(i));
224         } else {
225             qWarning("QObject::~QObject: Timers cannot be stopped from another thread");
226         }
227     }
228 
229     if (postedEvents)
230         QCoreApplication::removePostedEvents(q_ptr, 0);
231 
232     threadData->deref();
233 
234     if (metaObject) metaObject->objectDestroyed(q_ptr);
235 
236 #ifndef QT_NO_USERDATA
237     if (extraData)
238         qDeleteAll(extraData->userData);
239 #endif
240     delete extraData;
241 }
242 
243 /*!
244   \internal
245   For a given metaobject, compute the signal offset, and the method offset (including signals)
246 */
247 static void computeOffsets(const QMetaObject *metaobject, int *signalOffset, int *methodOffset)
248 {
249     *signalOffset = *methodOffset = 0;
250     const QMetaObject *m = metaobject->d.superdata;
251     while (m) {
252         const QMetaObjectPrivate *d = QMetaObjectPrivate::get(m);
253         *methodOffset += d->methodCount;
254         Q_ASSERT(d->revision >= 4);
255         *signalOffset += d->signalCount;
256         m = m->d.superdata;
257     }
258 }
259 
260 // Used by QAccessibleWidget
261 bool QObjectPrivate::isSender(const QObject *receiver, const char *signal) const
262 {
263     Q_Q(const QObject);
264     int signal_index = signalIndex(signal);
265     if (signal_index < 0 || !connections)
266         return false;
267     QMutexLocker locker(signalSlotLock(q));
268     if (signal_index < connections->signalVector.count()) {
269         const QObjectPrivate::Connection *c = connections->signalVector.at(signal_index).first;
270 
271         while (c) {
272             if (c->receiver == receiver)
273                 return true;
274             c = c->nextConnectionList;
275         }
276     }
277     return false;
278 }
279 
280 // Used by QAccessibleWidget
281 QObjectList QObjectPrivate::receiverList(const char *signal) const
282 {
283     Q_Q(const QObject);
284     QObjectList returnValue;
285     int signal_index = signalIndex(signal);
286     if (signal_index < 0 || !connections)
287         return returnValue;
288     QMutexLocker locker(signalSlotLock(q));
289     if (signal_index < connections->signalVector.count()) {
290         const QObjectPrivate::Connection *c = connections->signalVector.at(signal_index).first;
291 
292         while (c) {
293             if (c->receiver)
294                 returnValue << c->receiver;
295             c = c->nextConnectionList;
296         }
297     }
298     return returnValue;
299 }
300 
301 // Used by QAccessibleWidget
302 QObjectList QObjectPrivate::senderList() const
303 {
304     QObjectList returnValue;
305     if (connections) {
306         QMutexLocker locker(signalSlotLock(q_func()));
307         for (Connection *c = connections->senders; c; c = c->next)
308             returnValue << c->sender;
309     }
310     return returnValue;
311 }
312 
313 /*!
314   \internal
315   Add the connection \a c to the list of connections of the sender's object
316   for the specified \a signal
317 
318   The signalSlotLock() of the sender and receiver must be locked while calling
319   this function
320 
321   Will also add the connection in the sender's list of the receiver.
322  */
323 void QObjectPrivate::addConnection(int signal, Connection *c)
324 {
325     Q_ASSERT(c->sender == q_ptr);
326     ensureConnectionData();
327     if (signal >= connections->signalVector.count())
328         connections->signalVector.resize(signal + 1);
329 
330     ConnectionList &connectionList = connections->connectionsForSignal(signal);
331     if (connectionList.last) {
332         connectionList.last->nextConnectionList = c;
333     } else {
334         connectionList.first = c;
335     }
336     connectionList.last = c;
337 
338     cleanConnectionLists();
339 
340     QObjectPrivate *rd = QObjectPrivate::get(c->receiver);
341     rd->ensureConnectionData();
342 
343     c->prev = &(rd->connections->senders);
344     c->next = *c->prev;
345     *c->prev = c;
346     if (c->next)
347         c->next->prev = &c->next;
348 }
349 
350 void QObjectPrivate::cleanConnectionLists()
351 {
352     if (connections->dirty && !connections->inUse) {
353         // remove broken connections
354         for (int signal = -1; signal < connections->signalVector.count(); ++signal) {
355             ConnectionList &connectionList = connections->connectionsForSignal(signal);
356 
357             // Set to the last entry in the connection list that was *not*
358             // deleted.  This is needed to update the list's last pointer
359             // at the end of the cleanup.
360             QObjectPrivate::Connection *last = 0;
361 
362             QObjectPrivate::Connection **prev = &connectionList.first;
363             QObjectPrivate::Connection *c = *prev;
364             while (c) {
365                 if (c->receiver) {
366                     last = c;
367                     prev = &c->nextConnectionList;
368                     c = *prev;
369                 } else {
370                     QObjectPrivate::Connection *next = c->nextConnectionList;
371                     *prev = next;
372                     c->deref();
373                     c = next;
374                 }
375             }
376 
377             // Correct the connection list's last pointer.
378             // As conectionList.last could equal last, this could be a noop
379             connectionList.last = last;
380         }
381         connections->dirty = false;
382     }
383 }
384 
385 /*! \internal
386 
387   Returns \c true if the signal with index \a signal_index from object \a sender is connected.
388 
389   \a signal_index must be the index returned by QObjectPrivate::signalIndex;
390 */
391 bool QObjectPrivate::isSignalConnected(uint signalIndex, bool checkDeclarative) const
392 {
393     if (checkDeclarative && isDeclarativeSignalConnected(signalIndex))
394         return true;
395 
396     if (!connections)
397         return false;
398 
399     if (connections->allsignals.first)
400         return true;
401 
402     if (signalIndex < uint(connections->signalVector.count())) {
403         const QObjectPrivate::Connection *c = connections->signalVector.at(signalIndex).first;
404         while (c) {
405             if (c->receiver)
406                 return true;
407             c = c->nextConnectionList;
408         }
409     }
410     return false;
411 }
412 
413 
414 /*!
415     \internal
416  */
417 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative, QObjectPrivate::StaticMetaCallFunction callFunction,
418                                const QObject *sender, int signalId,
419                                int nargs, int *types, void **args, QSemaphore *semaphore)
420     : QEvent(MetaCall), slotObj_(0), sender_(sender), signalId_(signalId),
421       nargs_(nargs), types_(types), args_(args), semaphore_(semaphore),
422       callFunction_(callFunction), method_offset_(method_offset), method_relative_(method_relative)
423 { }
424 
425 /*!
426     \internal
427  */
428 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO, const QObject *sender, int signalId,
429                                int nargs, int *types, void **args, QSemaphore *semaphore)
430     : QEvent(MetaCall), slotObj_(slotO), sender_(sender), signalId_(signalId),
431       nargs_(nargs), types_(types), args_(args), semaphore_(semaphore),
432       callFunction_(0), method_offset_(0), method_relative_(ushort(-1))
433 {
434     if (slotObj_)
435         slotObj_->ref();
436 }
437 
438 /*!
439     \internal
440  */
441 QMetaCallEvent::~QMetaCallEvent()
442 {
443     if (types_) {
444         for (int i = 0; i < nargs_; ++i) {
445             if (types_[i] && args_[i])
446                 QMetaType::destroy(types_[i], args_[i]);
447         }
448         free(types_);
449         free(args_);
450     }
451 #if QT_CONFIG(thread)
452     if (semaphore_)
453         semaphore_->release();
454 #endif
455     if (slotObj_)
456         slotObj_->destroyIfLastRef();
457 }
458 
459 /*!
460     \internal
461  */
462 void QMetaCallEvent::placeMetaCall(QObject *object)
463 {
464     if (slotObj_) {
465         slotObj_->call(object, args_);
466     } else if (callFunction_ && method_offset_ <= object->metaObject()->methodOffset()) {
467         callFunction_(object, QMetaObject::InvokeMetaMethod, method_relative_, args_);
468     } else {
469         QMetaObject::metacall(object, QMetaObject::InvokeMetaMethod, method_offset_ + method_relative_, args_);
470     }
471 }
472 
473 /*!
474     \class QSignalBlocker
475     \brief Exception-safe wrapper around QObject::blockSignals().
476     \since 5.3
477     \ingroup objectmodel
478     \inmodule QtCore
479 
480     \reentrant
481 
482     QSignalBlocker can be used wherever you would otherwise use a
483     pair of calls to blockSignals(). It blocks signals in its
484     constructor and in the destructor it resets the state to what
485     it was before the constructor ran.
486 
487     \snippet code/src_corelib_kernel_qobject.cpp 53
488     is thus equivalent to
489     \snippet code/src_corelib_kernel_qobject.cpp 54
490 
491     except the code using QSignalBlocker is safe in the face of
492     exceptions.
493 
494     \sa QMutexLocker, QEventLoopLocker
495 */
496 
497 /*!
498     \fn QSignalBlocker::QSignalBlocker(QObject *object)
499 
500     Constructor. Calls \a{object}->blockSignals(true).
501 */
502 
503 /*!
504     \fn QSignalBlocker::QSignalBlocker(QObject &object)
505     \overload
506 
507     Calls \a{object}.blockSignals(true).
508 */
509 
510 /*!
511     \fn QSignalBlocker::QSignalBlocker(QSignalBlocker &&other)
512 
513     Move-constructs a signal blocker from \a other. \a other will have
514     a no-op destructor, while repsonsibility for restoring the
515     QObject::signalsBlocked() state is transferred to the new object.
516 */
517 
518 /*!
519     \fn QSignalBlocker &QSignalBlocker::operator=(QSignalBlocker &&other)
520 
521     Move-assigns this signal blocker from \a other. \a other will have
522     a no-op destructor, while repsonsibility for restoring the
523     QObject::signalsBlocked() state is transferred to this object.
524 
525     The object's signals this signal blocker was blocking prior to
526     being moved to, if any, are unblocked \e except in the case where
527     both instances block the same object's signals and \c *this is
528     unblocked while \a other is not, at the time of the move.
529 */
530 
531 /*!
532     \fn QSignalBlocker::~QSignalBlocker()
533 
534     Destructor. Restores the QObject::signalsBlocked() state to what it
535     was before the constructor ran, unless unblock() has been called
536     without a following reblock(), in which case it does nothing.
537 */
538 
539 /*!
540     \fn void QSignalBlocker::reblock()
541 
542     Re-blocks signals after a previous unblock().
543 
544     The numbers of reblock() and unblock() calls are not counted, so
545     every reblock() undoes any number of unblock() calls.
546 */
547 
548 /*!
549     \fn void QSignalBlocker::unblock()
550 
551     Temporarily restores the QObject::signalsBlocked() state to what
552     it was before this QSignaBlocker's constructor ran. To undo, use
553     reblock().
554 
555     The numbers of reblock() and unblock() calls are not counted, so
556     every unblock() undoes any number of reblock() calls.
557 */
558 
559 /*!
560     \class QObject
561     \inmodule QtCore
562     \brief The QObject class is the base class of all Qt objects.
563 
564     \ingroup objectmodel
565 
566     \reentrant
567 
568     QObject is the heart of the Qt \l{Object Model}. The central
569     feature in this model is a very powerful mechanism for seamless
570     object communication called \l{signals and slots}. You can
571     connect a signal to a slot with connect() and destroy the
572     connection with disconnect(). To avoid never ending notification
573     loops you can temporarily block signals with blockSignals(). The
574     protected functions connectNotify() and disconnectNotify() make
575     it possible to track connections.
576 
577     QObjects organize themselves in \l {Object Trees & Ownership}
578     {object trees}. When you create a QObject with another object as
579     parent, the object will automatically add itself to the parent's
580     children() list. The parent takes ownership of the object; i.e.,
581     it will automatically delete its children in its destructor. You
582     can look for an object by name and optionally type using
583     findChild() or findChildren().
584 
585     Every object has an objectName() and its class name can be found
586     via the corresponding metaObject() (see QMetaObject::className()).
587     You can determine whether the object's class inherits another
588     class in the QObject inheritance hierarchy by using the
589     inherits() function.
590 
591     When an object is deleted, it emits a destroyed() signal. You can
592     catch this signal to avoid dangling references to QObjects.
593 
594     QObjects can receive events through event() and filter the events
595     of other objects. See installEventFilter() and eventFilter() for
596     details. A convenience handler, childEvent(), can be reimplemented
597     to catch child events.
598 
599     Last but not least, QObject provides the basic timer support in
600     Qt; see QTimer for high-level support for timers.
601 
602     Notice that the Q_OBJECT macro is mandatory for any object that
603     implements signals, slots or properties. You also need to run the
604     \l{moc}{Meta Object Compiler} on the source file. We strongly
605     recommend the use of this macro in all subclasses of QObject
606     regardless of whether or not they actually use signals, slots and
607     properties, since failure to do so may lead certain functions to
608     exhibit strange behavior.
609 
610     All Qt widgets inherit QObject. The convenience function
611     isWidgetType() returns whether an object is actually a widget. It
612     is much faster than
613     \l{qobject_cast()}{qobject_cast}<QWidget *>(\e{obj}) or
614     \e{obj}->\l{inherits()}{inherits}("QWidget").
615 
616     Some QObject functions, e.g. children(), return a QObjectList.
617     QObjectList is a typedef for QList<QObject *>.
618 
619     \section1 Thread Affinity
620 
621     A QObject instance is said to have a \e{thread affinity}, or that
622     it \e{lives} in a certain thread. When a QObject receives a
623     \l{Qt::QueuedConnection}{queued signal} or a \l{The Event
624     System#Sending Events}{posted event}, the slot or event handler
625     will run in the thread that the object lives in.
626 
627     \note If a QObject has no thread affinity (that is, if thread()
628     returns zero), or if it lives in a thread that has no running event
629     loop, then it cannot receive queued signals or posted events.
630 
631     By default, a QObject lives in the thread in which it is created.
632     An object's thread affinity can be queried using thread() and
633     changed using moveToThread().
634 
635     All QObjects must live in the same thread as their parent. Consequently:
636 
637     \list
638     \li setParent() will fail if the two QObjects involved live in
639         different threads.
640     \li When a QObject is moved to another thread, all its children
641         will be automatically moved too.
642     \li moveToThread() will fail if the QObject has a parent.
643     \li If QObjects are created within QThread::run(), they cannot
644         become children of the QThread object because the QThread does
645         not live in the thread that calls QThread::run().
646     \endlist
647 
648     \note A QObject's member variables \e{do not} automatically become
649     its children. The parent-child relationship must be set by either
650     passing a pointer to the child's \l{QObject()}{constructor}, or by
651     calling setParent(). Without this step, the object's member variables
652     will remain in the old thread when moveToThread() is called.
653 
654     \target No copy constructor
655     \section1 No Copy Constructor or Assignment Operator
656 
657     QObject has neither a copy constructor nor an assignment operator.
658     This is by design. Actually, they are declared, but in a
659     \c{private} section with the macro Q_DISABLE_COPY(). In fact, all
660     Qt classes derived from QObject (direct or indirect) use this
661     macro to declare their copy constructor and assignment operator to
662     be private. The reasoning is found in the discussion on
663     \l{Identity vs Value} {Identity vs Value} on the Qt \l{Object
664     Model} page.
665 
666     The main consequence is that you should use pointers to QObject
667     (or to your QObject subclass) where you might otherwise be tempted
668     to use your QObject subclass as a value. For example, without a
669     copy constructor, you can't use a subclass of QObject as the value
670     to be stored in one of the container classes. You must store
671     pointers.
672 
673     \section1 Auto-Connection
674 
675     Qt's meta-object system provides a mechanism to automatically connect
676     signals and slots between QObject subclasses and their children. As long
677     as objects are defined with suitable object names, and slots follow a
678     simple naming convention, this connection can be performed at run-time
679     by the QMetaObject::connectSlotsByName() function.
680 
681     \l uic generates code that invokes this function to enable
682     auto-connection to be performed between widgets on forms created
683     with \e{Qt Designer}. More information about using auto-connection with \e{Qt Designer} is
684     given in the \l{Using a Designer UI File in Your Application} section of
685     the \e{Qt Designer} manual.
686 
687     \section1 Dynamic Properties
688 
689     From Qt 4.2, dynamic properties can be added to and removed from QObject
690     instances at run-time. Dynamic properties do not need to be declared at
691     compile-time, yet they provide the same advantages as static properties
692     and are manipulated using the same API - using property() to read them
693     and setProperty() to write them.
694 
695     From Qt 4.3, dynamic properties are supported by
696     \l{Qt Designer's Widget Editing Mode#The Property Editor}{Qt Designer},
697     and both standard Qt widgets and user-created forms can be given dynamic
698     properties.
699 
700     \section1 Internationalization (I18n)
701 
702     All QObject subclasses support Qt's translation features, making it possible
703     to translate an application's user interface into different languages.
704 
705     To make user-visible text translatable, it must be wrapped in calls to
706     the tr() function. This is explained in detail in the
707     \l{Writing Source Code for Translation} document.
708 
709     \sa QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY()
710     \sa {Object Trees & Ownership}
711 */
712 
713 /*****************************************************************************
714   QObject member functions
715  *****************************************************************************/
716 
717 // check the constructor's parent thread argument
718 static bool check_parent_thread(QObject *parent,
719                                 QThreadData *parentThreadData,
720                                 QThreadData *currentThreadData)
721 {
722     if (parent && parentThreadData != currentThreadData) {
723         QThread *parentThread = parentThreadData->thread;
724         QThread *currentThread = currentThreadData->thread;
725         qWarning("QObject: Cannot create children for a parent that is in a different thread.\n"
726                  "(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)",
727                  parent->metaObject()->className(),
728                  parent,
729                  parentThread ? parentThread->metaObject()->className() : "QThread",
730                  parentThread,
731                  currentThread ? currentThread->metaObject()->className() : "QThread",
732                  currentThread);
733         return false;
734     }
735     return true;
736 }
737 
738 /*!
739     Constructs an object with parent object \a parent.
740 
741     The parent of an object may be viewed as the object's owner. For
742     instance, a \l{QDialog}{dialog box} is the parent of the \uicontrol{OK}
743     and \uicontrol{Cancel} buttons it contains.
744 
745     The destructor of a parent object destroys all child objects.
746 
747     Setting \a parent to 0 constructs an object with no parent. If the
748     object is a widget, it will become a top-level window.
749 
750     \sa parent(), findChild(), findChildren()
751 */
752 
753 QObject::QObject(QObject *parent)
754     : d_ptr(new QObjectPrivate)
755 {
756     Q_D(QObject);
757     d_ptr->q_ptr = this;
758     d->threadData = (parent && !parent->thread()) ? parent->d_func()->threadData : QThreadData::current();
759     d->threadData->ref();
760     if (parent) {
761         QT_TRY {
762             if (!check_parent_thread(parent, parent ? parent->d_func()->threadData : 0, d->threadData))
763                 parent = 0;
764             setParent(parent);
765         } QT_CATCH(...) {
766             d->threadData->deref();
767             QT_RETHROW;
768         }
769     }
770 #if QT_VERSION < 0x60000
771     qt_addObject(this);
772 #endif
773     if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
774         reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
775     Q_TRACE(QObject_ctor, this);
776 }
777 
778 /*!
779     \internal
780  */
781 QObject::QObject(QObjectPrivate &dd, QObject *parent)
782     : d_ptr(&dd)
783 {
784     Q_D(QObject);
785     d_ptr->q_ptr = this;
786     d->threadData = (parent && !parent->thread()) ? parent->d_func()->threadData : QThreadData::current();
787     d->threadData->ref();
788     if (parent) {
789         QT_TRY {
790             if (!check_parent_thread(parent, parent ? parent->d_func()->threadData : 0, d->threadData))
791                 parent = 0;
792             if (d->isWidget) {
793                 if (parent) {
794                     d->parent = parent;
795                     d->parent->d_func()->children.append(this);
796                 }
797                 // no events sent here, this is done at the end of the QWidget constructor
798             } else {
799                 setParent(parent);
800             }
801         } QT_CATCH(...) {
802             d->threadData->deref();
803             QT_RETHROW;
804         }
805     }
806 #if QT_VERSION < 0x60000
807     qt_addObject(this);
808 #endif
809     if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
810         reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
811     Q_TRACE(QObject_ctor, this);
812 }
813 
814 /*!
815     Destroys the object, deleting all its child objects.
816 
817     All signals to and from the object are automatically disconnected, and
818     any pending posted events for the object are removed from the event
819     queue. However, it is often safer to use deleteLater() rather than
820     deleting a QObject subclass directly.
821 
822     \warning All child objects are deleted. If any of these objects
823     are on the stack or global, sooner or later your program will
824     crash. We do not recommend holding pointers to child objects from
825     outside the parent. If you still do, the destroyed() signal gives
826     you an opportunity to detect when an object is destroyed.
827 
828     \warning Deleting a QObject while pending events are waiting to
829     be delivered can cause a crash. You must not delete the QObject
830     directly if it exists in a different thread than the one currently
831     executing. Use deleteLater() instead, which will cause the event
832     loop to delete the object after all pending events have been
833     delivered to it.
834 
835     \sa deleteLater()
836 */
837 
838 QObject::~QObject()
839 {
840     Q_D(QObject);
841     d->wasDeleted = true;
842     d->blockSig = 0; // unblock signals so we always emit destroyed()
843 
844     QtSharedPointer::ExternalRefCountData *sharedRefcount = d->sharedRefcount.load();
845     if (sharedRefcount) {
846         if (sharedRefcount->strongref.load() > 0) {
847             qWarning("QObject: shared QObject was deleted directly. The program is malformed and may crash.");
848             // but continue deleting, it's too late to stop anyway
849         }
850 
851         // indicate to all QWeakPointers that this QObject has now been deleted
852         sharedRefcount->strongref.store(0);
853         if (!sharedRefcount->weakref.deref())
854             delete sharedRefcount;
855     }
856 
857     if (!d->isWidget && d->isSignalConnected(0)) {
858         emit destroyed(this);
859     }
860 
861     if (d->declarativeData) {
862         if (static_cast<QAbstractDeclarativeDataImpl*>(d->declarativeData)->ownedByQml1) {
863             if (QAbstractDeclarativeData::destroyed_qml1)
864                 QAbstractDeclarativeData::destroyed_qml1(d->declarativeData, this);
865         } else {
866             if (QAbstractDeclarativeData::destroyed)
867                 QAbstractDeclarativeData::destroyed(d->declarativeData, this);
868         }
869     }
870 
871     if (d->connections) {
872         if (d->connections->currentSender) {
873             d->connections->currentSender->receiverDeleted();
874             d->connections->currentSender = nullptr;
875         }
876 
877         QMutex *signalSlotMutex = signalSlotLock(this);
878         QMutexLocker locker(signalSlotMutex);
879         ++d->connections->inUse;
880 
881         // disconnect all receivers
882         if (d->connections->signalVector.count()) {
883             int receiverCount = d->connections->signalVector.count();
884             for (int signal = -1; signal < receiverCount; ++signal) {
885                 QObjectPrivate::ConnectionList &connectionList = d->connections->connectionsForSignal(signal);
886 
887                 while (QObjectPrivate::Connection *c = connectionList.first) {
888                     if (!c->receiver) {
889                         connectionList.first = c->nextConnectionList;
890                         c->deref();
891                         continue;
892                     }
893 
894                     QMutex *m = signalSlotLock(c->receiver);
895                     bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
896 
897                     if (c->receiver) {
898                         *c->prev = c->next;
899                         if (c->next) c->next->prev = c->prev;
900                     }
901                     c->receiver = 0;
902                     if (needToUnlock)
903                         m->unlock();
904 
905                     connectionList.first = c->nextConnectionList;
906 
907                     // The destroy operation must happen outside the lock
908                     if (c->isSlotObject) {
909                         c->isSlotObject = false;
910                         locker.unlock();
911                         c->slotObj->destroyIfLastRef();
912                         locker.relock();
913                     }
914                     c->deref();
915                 }
916             }
917         }
918 
919         /* Disconnect all senders:
920          * This loop basically just does
921          *     for (node = d->senders; node; node = node->next) { ... }
922          *
923          * We need to temporarily unlock the receiver mutex to destroy the functors or to lock the
924          * sender's mutex. And when the mutex is released, node->next might be destroyed by another
925          * thread. That's why we set node->prev to &node, that way, if node is destroyed, node will
926          * be updated.
927          */
928         QObjectPrivate::Connection *node = d->connections->senders;
929         while (node) {
930             QObject *sender = node->sender;
931             // Send disconnectNotify before removing the connection from sender's connection list.
932             // This ensures any eventual destructor of sender will block on getting receiver's lock
933             // and not finish until we release it.
934             sender->disconnectNotify(QMetaObjectPrivate::signal(sender->metaObject(), node->signal_index));
935             QMutex *m = signalSlotLock(sender);
936             node->prev = &node;
937             bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
938             //the node has maybe been removed while the mutex was unlocked in relock?
939             if (!node || node->sender != sender) {
940                 // We hold the wrong mutex
941                 Q_ASSERT(needToUnlock);
942                 m->unlock();
943                 continue;
944             }
945             node->receiver = 0;
946             QObjectPrivate::ConnectionData *senderData = sender->d_func()->connections;
947             if (senderData)
948                 senderData->dirty = true;
949 
950             QtPrivate::QSlotObjectBase *slotObj = nullptr;
951             if (node->isSlotObject) {
952                 slotObj = node->slotObj;
953                 node->isSlotObject = false;
954             }
955 
956             node = node->next;
957             if (needToUnlock)
958                 m->unlock();
959 
960             if (slotObj) {
961                 if (node)
962                     node->prev = &node;
963                 locker.unlock();
964                 slotObj->destroyIfLastRef();
965                 locker.relock();
966             }
967         }
968 
969         if (!--d->connections->inUse) {
970             delete d->connections;
971         } else {
972             d->connections->orphaned = true;
973         }
974     }
975 
976     if (!d->children.isEmpty())
977         d->deleteChildren();
978 
979 #if QT_VERSION < 0x60000
980     qt_removeObject(this);
981 #endif
982     if (Q_UNLIKELY(qtHookData[QHooks::RemoveQObject]))
983         reinterpret_cast<QHooks::RemoveQObjectCallback>(qtHookData[QHooks::RemoveQObject])(this);
984 
985     Q_TRACE(QObject_dtor, this);
986 
987     if (d->parent)        // remove it from parent object
988         d->setParent_helper(0);
989 }
990 
991 QObjectPrivate::Connection::~Connection()
992 {
993     if (ownArgumentTypes) {
994         const int *v = argumentTypes.load();
995         if (v != &DIRECT_CONNECTION_ONLY)
996             delete [] v;
997     }
998     if (isSlotObject)
999         slotObj->destroyIfLastRef();
1000 }
1001 
1002 
1003 /*!
1004     \fn const QMetaObject *QObject::metaObject() const
1005 
1006     Returns a pointer to the meta-object of this object.
1007 
1008     A meta-object contains information about a class that inherits
1009     QObject, e.g. class name, superclass name, properties, signals and
1010     slots. Every QObject subclass that contains the Q_OBJECT macro will have a
1011     meta-object.
1012 
1013     The meta-object information is required by the signal/slot
1014     connection mechanism and the property system. The inherits()
1015     function also makes use of the meta-object.
1016 
1017     If you have no pointer to an actual object instance but still
1018     want to access the meta-object of a class, you can use \l
1019     staticMetaObject.
1020 
1021     Example:
1022 
1023     \snippet code/src_corelib_kernel_qobject.cpp 1
1024 
1025     \sa staticMetaObject
1026 */
1027 
1028 /*!
1029     \variable QObject::staticMetaObject
1030 
1031     This variable stores the meta-object for the class.
1032 
1033     A meta-object contains information about a class that inherits
1034     QObject, e.g. class name, superclass name, properties, signals and
1035     slots. Every class that contains the Q_OBJECT macro will also have
1036     a meta-object.
1037 
1038     The meta-object information is required by the signal/slot
1039     connection mechanism and the property system. The inherits()
1040     function also makes use of the meta-object.
1041 
1042     If you have a pointer to an object, you can use metaObject() to
1043     retrieve the meta-object associated with that object.
1044 
1045     Example:
1046 
1047     \snippet code/src_corelib_kernel_qobject.cpp 2
1048 
1049     \sa metaObject()
1050 */
1051 
1052 /*!
1053     \fn template <class T> T qobject_cast(QObject *object)
1054     \fn template <class T> T qobject_cast(const QObject *object)
1055     \relates QObject
1056 
1057     Returns the given \a object cast to type T if the object is of type
1058     T (or of a subclass); otherwise returns 0.  If \a object is 0 then
1059     it will also return 0.
1060 
1061     The class T must inherit (directly or indirectly) QObject and be
1062     declared with the \l Q_OBJECT macro.
1063 
1064     A class is considered to inherit itself.
1065 
1066     Example:
1067 
1068     \snippet code/src_corelib_kernel_qobject.cpp 3
1069 
1070     The qobject_cast() function behaves similarly to the standard C++
1071     \c dynamic_cast(), with the advantages that it doesn't require
1072     RTTI support and it works across dynamic library boundaries.
1073 
1074     qobject_cast() can also be used in conjunction with interfaces;
1075     see the \l{tools/plugandpaint/app}{Plug & Paint} example for details.
1076 
1077     \warning If T isn't declared with the Q_OBJECT macro, this
1078     function's return value is undefined.
1079 
1080     \sa QObject::inherits()
1081 */
1082 
1083 /*!
1084     \fn bool QObject::inherits(const char *className) const
1085 
1086     Returns \c true if this object is an instance of a class that
1087     inherits \a className or a QObject subclass that inherits \a
1088     className; otherwise returns \c false.
1089 
1090     A class is considered to inherit itself.
1091 
1092     Example:
1093 
1094     \snippet code/src_corelib_kernel_qobject.cpp 4
1095 
1096     If you need to determine whether an object is an instance of a particular
1097     class for the purpose of casting it, consider using qobject_cast<Type *>(object)
1098     instead.
1099 
1100     \sa metaObject(), qobject_cast()
1101 */
1102 
1103 /*!
1104     \property QObject::objectName
1105 
1106     \brief the name of this object
1107 
1108     You can find an object by name (and type) using findChild().
1109     You can find a set of objects with findChildren().
1110 
1111     \snippet code/src_corelib_kernel_qobject.cpp 5
1112 
1113     By default, this property contains an empty string.
1114 
1115     \sa metaObject(), QMetaObject::className()
1116 */
1117 
1118 QString QObject::objectName() const
1119 {
1120     Q_D(const QObject);
1121     return d->extraData ? d->extraData->objectName : QString();
1122 }
1123 
1124 /*
1125     Sets the object's name to \a name.
1126 */
1127 void QObject::setObjectName(const QString &name)
1128 {
1129     Q_D(QObject);
1130     if (!d->extraData)
1131         d->extraData = new QObjectPrivate::ExtraData;
1132 
1133     if (d->extraData->objectName != name) {
1134         d->extraData->objectName = name;
1135         emit objectNameChanged(d->extraData->objectName, QPrivateSignal());
1136     }
1137 }
1138 
1139 /*! \fn void QObject::objectNameChanged(const QString &objectName)
1140 
1141     This signal is emitted after the object's name has been changed. The new object name is passed as \a objectName.
1142 
1143     \sa QObject::objectName
1144 */
1145 
1146 /*!
1147     \fn bool QObject::isWidgetType() const
1148 
1149     Returns \c true if the object is a widget; otherwise returns \c false.
1150 
1151     Calling this function is equivalent to calling
1152     \c{inherits("QWidget")}, except that it is much faster.
1153 */
1154 
1155 /*!
1156     \fn bool QObject::isWindowType() const
1157 
1158     Returns \c true if the object is a window; otherwise returns \c false.
1159 
1160     Calling this function is equivalent to calling
1161     \c{inherits("QWindow")}, except that it is much faster.
1162 */
1163 
1164 /*!
1165     This virtual function receives events to an object and should
1166     return true if the event \a e was recognized and processed.
1167 
1168     The event() function can be reimplemented to customize the
1169     behavior of an object.
1170 
1171     Make sure you call the parent event class implementation
1172     for all the events you did not handle.
1173 
1174     Example:
1175 
1176     \snippet code/src_corelib_kernel_qobject.cpp 52
1177 
1178     \sa installEventFilter(), timerEvent(), QCoreApplication::sendEvent(),
1179     QCoreApplication::postEvent()
1180 */
1181 
1182 bool QObject::event(QEvent *e)
1183 {
1184     switch (e->type()) {
1185     case QEvent::Timer:
1186         timerEvent((QTimerEvent*)e);
1187         break;
1188 
1189     case QEvent::ChildAdded:
1190     case QEvent::ChildPolished:
1191     case QEvent::ChildRemoved:
1192         childEvent((QChildEvent*)e);
1193         break;
1194 
1195     case QEvent::DeferredDelete:
1196         qDeleteInEventHandler(this);
1197         break;
1198 
1199     case QEvent::MetaCall:
1200         {
1201             QMetaCallEvent *mce = static_cast<QMetaCallEvent*>(e);
1202 
1203             if (!d_func()->connections) {
1204                 QMutexLocker locker(signalSlotLock(this));
1205                 d_func()->ensureConnectionData();
1206             }
1207             QObjectPrivate::Sender sender(this, const_cast<QObject*>(mce->sender()), mce->signalId());
1208 
1209             mce->placeMetaCall(this);
1210             break;
1211         }
1212 
1213     case QEvent::ThreadChange: {
1214         Q_D(QObject);
1215         QThreadData *threadData = d->threadData;
1216         QAbstractEventDispatcher *eventDispatcher = threadData->eventDispatcher.load();
1217         if (eventDispatcher) {
1218             QList<QAbstractEventDispatcher::TimerInfo> timers = eventDispatcher->registeredTimers(this);
1219             if (!timers.isEmpty()) {
1220                 // do not to release our timer ids back to the pool (since the timer ids are moving to a new thread).
1221                 eventDispatcher->unregisterTimers(this);
1222                 QMetaObject::invokeMethod(this, "_q_reregisterTimers", Qt::QueuedConnection,
1223                                           Q_ARG(void*, (new QList<QAbstractEventDispatcher::TimerInfo>(timers))));
1224             }
1225         }
1226         break;
1227     }
1228 
1229     default:
1230         if (e->type() >= QEvent::User) {
1231             customEvent(e);
1232             break;
1233         }
1234         return false;
1235     }
1236     return true;
1237 }
1238 
1239 /*!
1240     \fn void QObject::timerEvent(QTimerEvent *event)
1241 
1242     This event handler can be reimplemented in a subclass to receive
1243     timer events for the object.
1244 
1245     QTimer provides a higher-level interface to the timer
1246     functionality, and also more general information about timers. The
1247     timer event is passed in the \a event parameter.
1248 
1249     \sa startTimer(), killTimer(), event()
1250 */
1251 
1252 void QObject::timerEvent(QTimerEvent *)
1253 {
1254 }
1255 
1256 
1257 /*!
1258     This event handler can be reimplemented in a subclass to receive
1259     child events. The event is passed in the \a event parameter.
1260 
1261     QEvent::ChildAdded and QEvent::ChildRemoved events are sent to
1262     objects when children are added or removed. In both cases you can
1263     only rely on the child being a QObject, or if isWidgetType()
1264     returns \c true, a QWidget. (This is because, in the
1265     \l{QEvent::ChildAdded}{ChildAdded} case, the child is not yet
1266     fully constructed, and in the \l{QEvent::ChildRemoved}{ChildRemoved}
1267     case it might have been destructed already).
1268 
1269     QEvent::ChildPolished events are sent to widgets when children
1270     are polished, or when polished children are added. If you receive
1271     a child polished event, the child's construction is usually
1272     completed. However, this is not guaranteed, and multiple polish
1273     events may be delivered during the execution of a widget's
1274     constructor.
1275 
1276     For every child widget, you receive one
1277     \l{QEvent::ChildAdded}{ChildAdded} event, zero or more
1278     \l{QEvent::ChildPolished}{ChildPolished} events, and one
1279     \l{QEvent::ChildRemoved}{ChildRemoved} event.
1280 
1281     The \l{QEvent::ChildPolished}{ChildPolished} event is omitted if
1282     a child is removed immediately after it is added. If a child is
1283     polished several times during construction and destruction, you
1284     may receive several child polished events for the same child,
1285     each time with a different virtual table.
1286 
1287     \sa event()
1288 */
1289 
1290 void QObject::childEvent(QChildEvent * /* event */)
1291 {
1292 }
1293 
1294 
1295 /*!
1296     This event handler can be reimplemented in a subclass to receive
1297     custom events. Custom events are user-defined events with a type
1298     value at least as large as the QEvent::User item of the
1299     QEvent::Type enum, and is typically a QEvent subclass. The event
1300     is passed in the \a event parameter.
1301 
1302     \sa event(), QEvent
1303 */
1304 void QObject::customEvent(QEvent * /* event */)
1305 {
1306 }
1307 
1308 
1309 
1310 /*!
1311     Filters events if this object has been installed as an event
1312     filter for the \a watched object.
1313 
1314     In your reimplementation of this function, if you want to filter
1315     the \a event out, i.e. stop it being handled further, return
1316     true; otherwise return false.
1317 
1318     Example:
1319     \snippet code/src_corelib_kernel_qobject.cpp 6
1320 
1321     Notice in the example above that unhandled events are passed to
1322     the base class's eventFilter() function, since the base class
1323     might have reimplemented eventFilter() for its own internal
1324     purposes.
1325 
1326     \warning If you delete the receiver object in this function, be
1327     sure to return true. Otherwise, Qt will forward the event to the
1328     deleted object and the program might crash.
1329 
1330     \sa installEventFilter()
1331 */
1332 
1333 bool QObject::eventFilter(QObject * /* watched */, QEvent * /* event */)
1334 {
1335     return false;
1336 }
1337 
1338 /*!
1339     \fn bool QObject::signalsBlocked() const
1340 
1341     Returns \c true if signals are blocked; otherwise returns \c false.
1342 
1343     Signals are not blocked by default.
1344 
1345     \sa blockSignals(), QSignalBlocker
1346 */
1347 
1348 /*!
1349     If \a block is true, signals emitted by this object are blocked
1350     (i.e., emitting a signal will not invoke anything connected to it).
1351     If \a block is false, no such blocking will occur.
1352 
1353     The return value is the previous value of signalsBlocked().
1354 
1355     Note that the destroyed() signal will be emitted even if the signals
1356     for this object have been blocked.
1357 
1358     Signals emitted while being blocked are not buffered.
1359 
1360     \sa signalsBlocked(), QSignalBlocker
1361 */
1362 
1363 bool QObject::blockSignals(bool block) Q_DECL_NOTHROW
1364 {
1365     Q_D(QObject);
1366     bool previous = d->blockSig;
1367     d->blockSig = block;
1368     return previous;
1369 }
1370 
1371 /*!
1372     Returns the thread in which the object lives.
1373 
1374     \sa moveToThread()
1375 */
1376 QThread *QObject::thread() const
1377 {
1378     return d_func()->threadData->thread;
1379 }
1380 
1381 /*!
1382     Changes the thread affinity for this object and its children. The
1383     object cannot be moved if it has a parent. Event processing will
1384     continue in the \a targetThread.
1385 
1386     To move an object to the main thread, use QApplication::instance()
1387     to retrieve a pointer to the current application, and then use
1388     QApplication::thread() to retrieve the thread in which the
1389     application lives. For example:
1390 
1391     \snippet code/src_corelib_kernel_qobject.cpp 7
1392 
1393     If \a targetThread is zero, all event processing for this object
1394     and its children stops.
1395 
1396     Note that all active timers for the object will be reset. The
1397     timers are first stopped in the current thread and restarted (with
1398     the same interval) in the \a targetThread. As a result, constantly
1399     moving an object between threads can postpone timer events
1400     indefinitely.
1401 
1402     A QEvent::ThreadChange event is sent to this object just before
1403     the thread affinity is changed. You can handle this event to
1404     perform any special processing. Note that any new events that are
1405     posted to this object will be handled in the \a targetThread.
1406 
1407     \warning This function is \e not thread-safe; the current thread
1408     must be same as the current thread affinity. In other words, this
1409     function can only "push" an object from the current thread to
1410     another thread, it cannot "pull" an object from any arbitrary
1411     thread to the current thread.
1412 
1413     \sa thread()
1414  */
1415 void QObject::moveToThread(QThread *targetThread)
1416 {
1417     Q_D(QObject);
1418 
1419     if (d->threadData->thread == targetThread) {
1420         // object is already in this thread
1421         return;
1422     }
1423 
1424     if (d->parent != 0) {
1425         qWarning("QObject::moveToThread: Cannot move objects with a parent");
1426         return;
1427     }
1428     if (d->isWidget) {
1429         qWarning("QObject::moveToThread: Widgets cannot be moved to a new thread");
1430         return;
1431     }
1432 
1433     QThreadData *currentData = QThreadData::current();
1434     QThreadData *targetData = targetThread ? QThreadData::get2(targetThread) : nullptr;
1435     if (d->threadData->thread == 0 && currentData == targetData) {
1436         // one exception to the rule: we allow moving objects with no thread affinity to the current thread
1437         currentData = d->threadData;
1438     } else if (d->threadData != currentData) {
1439         qWarning("QObject::moveToThread: Current thread (%p) is not the object's thread (%p).\n"
1440                  "Cannot move to target thread (%p)\n",
1441                  currentData->thread.load(), d->threadData->thread.load(), targetData ? targetData->thread.load() : nullptr);
1442 
1443 #ifdef Q_OS_MAC
1444         qWarning("You might be loading two sets of Qt binaries into the same process. "
1445                  "Check that all plugins are compiled against the right Qt binaries. Export "
1446                  "DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.");
1447 #endif
1448 
1449         return;
1450     }
1451 
1452     // prepare to move
1453     d->moveToThread_helper();
1454 
1455     if (!targetData)
1456         targetData = new QThreadData(0);
1457 
1458     QOrderedMutexLocker locker(&currentData->postEventList.mutex,
1459                                &targetData->postEventList.mutex);
1460 
1461     // keep currentData alive (since we've got it locked)
1462     currentData->ref();
1463 
1464     // move the object
1465     d_func()->setThreadData_helper(currentData, targetData);
1466 
1467     locker.unlock();
1468 
1469     // now currentData can commit suicide if it wants to
1470     currentData->deref();
1471 }
1472 
1473 void QObjectPrivate::moveToThread_helper()
1474 {
1475     Q_Q(QObject);
1476     QEvent e(QEvent::ThreadChange);
1477     QCoreApplication::sendEvent(q, &e);
1478     for (int i = 0; i < children.size(); ++i) {
1479         QObject *child = children.at(i);
1480         child->d_func()->moveToThread_helper();
1481     }
1482 }
1483 
1484 void QObjectPrivate::setThreadData_helper(QThreadData *currentData, QThreadData *targetData)
1485 {
1486     Q_Q(QObject);
1487 
1488     // move posted events
1489     int eventsMoved = 0;
1490     for (int i = 0; i < currentData->postEventList.size(); ++i) {
1491         const QPostEvent &pe = currentData->postEventList.at(i);
1492         if (!pe.event)
1493             continue;
1494         if (pe.receiver == q) {
1495             // move this post event to the targetList
1496             targetData->postEventList.addEvent(pe);
1497             const_cast<QPostEvent &>(pe).event = 0;
1498             ++eventsMoved;
1499         }
1500     }
1501     if (eventsMoved > 0 && targetData->hasEventDispatcher()) {
1502         targetData->canWait = false;
1503         targetData->eventDispatcher.load()->wakeUp();
1504     }
1505 
1506     // the current emitting thread shouldn't restore currentSender after calling moveToThread()
1507     if (connections && connections->currentSender) {
1508         connections->currentSender->receiverDeleted();
1509         connections->currentSender = nullptr;
1510     }
1511 
1512     // set new thread data
1513     targetData->ref();
1514     threadData->deref();
1515     threadData = targetData;
1516 
1517     for (int i = 0; i < children.size(); ++i) {
1518         QObject *child = children.at(i);
1519         child->d_func()->setThreadData_helper(currentData, targetData);
1520     }
1521 }
1522 
1523 void QObjectPrivate::_q_reregisterTimers(void *pointer)
1524 {
1525     Q_Q(QObject);
1526     QList<QAbstractEventDispatcher::TimerInfo> *timerList = reinterpret_cast<QList<QAbstractEventDispatcher::TimerInfo> *>(pointer);
1527     QAbstractEventDispatcher *eventDispatcher = threadData->eventDispatcher.load();
1528     for (int i = 0; i < timerList->size(); ++i) {
1529         const QAbstractEventDispatcher::TimerInfo &ti = timerList->at(i);
1530         eventDispatcher->registerTimer(ti.timerId, ti.interval, ti.timerType, q);
1531     }
1532     delete timerList;
1533 }
1534 
1535 
1536 //
1537 // The timer flag hasTimer is set when startTimer is called.
1538 // It is not reset when killing the timer because more than
1539 // one timer might be active.
1540 //
1541 
1542 /*!
1543     Starts a timer and returns a timer identifier, or returns zero if
1544     it could not start a timer.
1545 
1546     A timer event will occur every \a interval milliseconds until
1547     killTimer() is called. If \a interval is 0, then the timer event
1548     occurs once every time there are no more window system events to
1549     process.
1550 
1551     The virtual timerEvent() function is called with the QTimerEvent
1552     event parameter class when a timer event occurs. Reimplement this
1553     function to get timer events.
1554 
1555     If multiple timers are running, the QTimerEvent::timerId() can be
1556     used to find out which timer was activated.
1557 
1558     Example:
1559 
1560     \snippet code/src_corelib_kernel_qobject.cpp 8
1561 
1562     Note that QTimer's accuracy depends on the underlying operating system and
1563     hardware. The \a timerType argument allows you to customize the accuracy of
1564     the timer. See Qt::TimerType for information on the different timer types.
1565     Most platforms support an accuracy of 20 milliseconds; some provide more.
1566     If Qt is unable to deliver the requested number of timer events, it will
1567     silently discard some.
1568 
1569     The QTimer class provides a high-level programming interface with
1570     single-shot timers and timer signals instead of events. There is
1571     also a QBasicTimer class that is more lightweight than QTimer and
1572     less clumsy than using timer IDs directly.
1573 
1574     \sa timerEvent(), killTimer(), QTimer::singleShot()
1575 */
1576 
1577 int QObject::startTimer(int interval, Qt::TimerType timerType)
1578 {
1579     Q_D(QObject);
1580 
1581     if (Q_UNLIKELY(interval < 0)) {
1582         qWarning("QObject::startTimer: Timers cannot have negative intervals");
1583         return 0;
1584     }
1585     if (Q_UNLIKELY(!d->threadData->hasEventDispatcher())) {
1586         qWarning("QObject::startTimer: Timers can only be used with threads started with QThread");
1587         return 0;
1588     }
1589     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1590         qWarning("QObject::startTimer: Timers cannot be started from another thread");
1591         return 0;
1592     }
1593     int timerId = d->threadData->eventDispatcher.load()->registerTimer(interval, timerType, this);
1594     if (!d->extraData)
1595         d->extraData = new QObjectPrivate::ExtraData;
1596     d->extraData->runningTimers.append(timerId);
1597     return timerId;
1598 }
1599 
1600 /*!
1601     \since 5.9
1602     \overload
1603     \fn int QObject::startTimer(std::chrono::milliseconds time, Qt::TimerType timerType)
1604 
1605     Starts a timer and returns a timer identifier, or returns zero if
1606     it could not start a timer.
1607 
1608     A timer event will occur every \a time interval until killTimer()
1609     is called. If \a time is equal to \c{std::chrono::duration::zero()},
1610     then the timer event occurs once every time there are no more window
1611     system events to process.
1612 
1613     The virtual timerEvent() function is called with the QTimerEvent
1614     event parameter class when a timer event occurs. Reimplement this
1615     function to get timer events.
1616 
1617     If multiple timers are running, the QTimerEvent::timerId() can be
1618     used to find out which timer was activated.
1619 
1620     Example:
1621 
1622     \snippet code/src_corelib_kernel_qobject.cpp 8
1623 
1624     Note that QTimer's accuracy depends on the underlying operating system and
1625     hardware. The \a timerType argument allows you to customize the accuracy of
1626     the timer. See Qt::TimerType for information on the different timer types.
1627     Most platforms support an accuracy of 20 milliseconds; some provide more.
1628     If Qt is unable to deliver the requested number of timer events, it will
1629     silently discard some.
1630 
1631     The QTimer class provides a high-level programming interface with
1632     single-shot timers and timer signals instead of events. There is
1633     also a QBasicTimer class that is more lightweight than QTimer and
1634     less clumsy than using timer IDs directly.
1635 
1636     \sa timerEvent(), killTimer(), QTimer::singleShot()
1637 */
1638 
1639 /*!
1640     Kills the timer with timer identifier, \a id.
1641 
1642     The timer identifier is returned by startTimer() when a timer
1643     event is started.
1644 
1645     \sa timerEvent(), startTimer()
1646 */
1647 
1648 void QObject::killTimer(int id)
1649 {
1650     Q_D(QObject);
1651     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1652         qWarning("QObject::killTimer: Timers cannot be stopped from another thread");
1653         return;
1654     }
1655     if (id) {
1656         int at = d->extraData ? d->extraData->runningTimers.indexOf(id) : -1;
1657         if (at == -1) {
1658             // timer isn't owned by this object
1659             qWarning("QObject::killTimer(): Error: timer id %d is not valid for object %p (%s, %s), timer has not been killed",
1660                      id,
1661                      this,
1662                      metaObject()->className(),
1663                      qPrintable(objectName()));
1664             return;
1665         }
1666 
1667         if (d->threadData->hasEventDispatcher())
1668             d->threadData->eventDispatcher.load()->unregisterTimer(id);
1669 
1670         d->extraData->runningTimers.remove(at);
1671         QAbstractEventDispatcherPrivate::releaseTimerId(id);
1672     }
1673 }
1674 
1675 
1676 /*!
1677     \fn QObject *QObject::parent() const
1678 
1679     Returns a pointer to the parent object.
1680 
1681     \sa children()
1682 */
1683 
1684 /*!
1685     \fn const QObjectList &QObject::children() const
1686 
1687     Returns a list of child objects.
1688     The QObjectList class is defined in the \c{<QObject>} header
1689     file as the following:
1690 
1691     \quotefromfile kernel/qobject.h
1692     \skipto /typedef .*QObjectList/
1693     \printuntil QObjectList
1694 
1695     The first child added is the \l{QList::first()}{first} object in
1696     the list and the last child added is the \l{QList::last()}{last}
1697     object in the list, i.e. new children are appended at the end.
1698 
1699     Note that the list order changes when QWidget children are
1700     \l{QWidget::raise()}{raised} or \l{QWidget::lower()}{lowered}. A
1701     widget that is raised becomes the last object in the list, and a
1702     widget that is lowered becomes the first object in the list.
1703 
1704     \sa findChild(), findChildren(), parent(), setParent()
1705 */
1706 
1707 
1708 /*!
1709     \fn template<typename T> T *QObject::findChild(const QString &name, Qt::FindChildOptions options) const
1710 
1711     Returns the child of this object that can be cast into type T and
1712     that is called \a name, or 0 if there is no such object.
1713     Omitting the \a name argument causes all object names to be matched.
1714     The search is performed recursively, unless \a options specifies the
1715     option FindDirectChildrenOnly.
1716 
1717     If there is more than one child matching the search, the most
1718     direct ancestor is returned. If there are several direct
1719     ancestors, it is undefined which one will be returned. In that
1720     case, findChildren() should be used.
1721 
1722     This example returns a child \c{QPushButton} of \c{parentWidget}
1723     named \c{"button1"}, even if the button isn't a direct child of
1724     the parent:
1725 
1726     \snippet code/src_corelib_kernel_qobject.cpp 10
1727 
1728     This example returns a \c{QListWidget} child of \c{parentWidget}:
1729 
1730     \snippet code/src_corelib_kernel_qobject.cpp 11
1731 
1732     This example returns a child \c{QPushButton} of \c{parentWidget}
1733     (its direct parent) named \c{"button1"}:
1734 
1735     \snippet code/src_corelib_kernel_qobject.cpp 41
1736 
1737     This example returns a \c{QListWidget} child of \c{parentWidget},
1738     its direct parent:
1739 
1740     \snippet code/src_corelib_kernel_qobject.cpp 42
1741 
1742     \sa findChildren()
1743 */
1744 
1745 /*!
1746     \fn template<typename T> QList<T> QObject::findChildren(const QString &name, Qt::FindChildOptions options) const
1747 
1748     Returns all children of this object with the given \a name that can be
1749     cast to type T, or an empty list if there are no such objects.
1750     Omitting the \a name argument causes all object names to be matched.
1751     The search is performed recursively, unless \a options specifies the
1752     option FindDirectChildrenOnly.
1753 
1754     The following example shows how to find a list of child \c{QWidget}s of
1755     the specified \c{parentWidget} named \c{widgetname}:
1756 
1757     \snippet code/src_corelib_kernel_qobject.cpp 12
1758 
1759     This example returns all \c{QPushButton}s that are children of \c{parentWidget}:
1760 
1761     \snippet code/src_corelib_kernel_qobject.cpp 13
1762 
1763     This example returns all \c{QPushButton}s that are immediate children of \c{parentWidget}:
1764 
1765     \snippet code/src_corelib_kernel_qobject.cpp 43
1766 
1767     \sa findChild()
1768 */
1769 
1770 /*!
1771     \fn template<typename T> QList<T> QObject::findChildren(const QRegExp &regExp, Qt::FindChildOptions options) const
1772     \overload findChildren()
1773     \obsolete
1774 
1775     Returns the children of this object that can be cast to type T
1776     and that have names matching the regular expression \a regExp,
1777     or an empty list if there are no such objects.
1778     The search is performed recursively, unless \a options specifies the
1779     option FindDirectChildrenOnly.
1780 
1781     Use the findChildren overload taking a QRegularExpression instead.
1782 */
1783 
1784 /*!
1785     \fn QList<T> QObject::findChildren(const QRegularExpression &re, Qt::FindChildOptions options) const
1786     \overload findChildren()
1787 
1788     \since 5.0
1789 
1790     Returns the children of this object that can be cast to type T
1791     and that have names matching the regular expression \a re,
1792     or an empty list if there are no such objects.
1793     The search is performed recursively, unless \a options specifies the
1794     option FindDirectChildrenOnly.
1795 */
1796 
1797 /*!
1798     \fn template<typename T> T qFindChild(const QObject *obj, const QString &name)
1799     \relates QObject
1800     \overload qFindChildren()
1801     \obsolete
1802 
1803     This function is equivalent to
1804     \a{obj}->\l{QObject::findChild()}{findChild}<T>(\a name).
1805 
1806     \note This function was provided as a workaround for MSVC 6
1807     which did not support member template functions. It is advised
1808     to use the other form in new code.
1809 
1810     \sa QObject::findChild()
1811 */
1812 
1813 /*!
1814     \fn template<typename T> QList<T> qFindChildren(const QObject *obj, const QString &name)
1815     \relates QObject
1816     \overload qFindChildren()
1817     \obsolete
1818 
1819     This function is equivalent to
1820     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a name).
1821 
1822     \note This function was provided as a workaround for MSVC 6
1823     which did not support member template functions. It is advised
1824     to use the other form in new code.
1825 
1826     \sa QObject::findChildren()
1827 */
1828 
1829 /*!
1830     \fn template<typename T> QList<T> qFindChildren(const QObject *obj, const QRegExp &regExp)
1831     \relates QObject
1832     \overload qFindChildren()
1833 
1834     This function is equivalent to
1835     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a regExp).
1836 
1837     \note This function was provided as a workaround for MSVC 6
1838     which did not support member template functions. It is advised
1839     to use the other form in new code.
1840 
1841     \sa QObject::findChildren()
1842 */
1843 
1844 /*!
1845     \internal
1846 */
1847 void qt_qFindChildren_helper(const QObject *parent, const QString &name,
1848                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1849 {
1850     if (!parent || !list)
1851         return;
1852     const QObjectList &children = parent->children();
1853     QObject *obj;
1854     for (int i = 0; i < children.size(); ++i) {
1855         obj = children.at(i);
1856         if (mo.cast(obj)) {
1857             if (name.isNull() || obj->objectName() == name)
1858                 list->append(obj);
1859         }
1860         if (options & Qt::FindChildrenRecursively)
1861             qt_qFindChildren_helper(obj, name, mo, list, options);
1862     }
1863 }
1864 
1865 #ifndef QT_NO_REGEXP
1866 /*!
1867     \internal
1868 */
1869 void qt_qFindChildren_helper(const QObject *parent, const QRegExp &re,
1870                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1871 {
1872     if (!parent || !list)
1873         return;
1874     const QObjectList &children = parent->children();
1875     QRegExp reCopy = re;
1876     QObject *obj;
1877     for (int i = 0; i < children.size(); ++i) {
1878         obj = children.at(i);
1879         if (mo.cast(obj) && reCopy.indexIn(obj->objectName()) != -1)
1880             list->append(obj);
1881 
1882         if (options & Qt::FindChildrenRecursively)
1883             qt_qFindChildren_helper(obj, re, mo, list, options);
1884     }
1885 }
1886 #endif // QT_NO_REGEXP
1887 
1888 #if QT_CONFIG(regularexpression)
1889 /*!
1890     \internal
1891 */
1892 void qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &re,
1893                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1894 {
1895     if (!parent || !list)
1896         return;
1897     const QObjectList &children = parent->children();
1898     QObject *obj;
1899     for (int i = 0; i < children.size(); ++i) {
1900         obj = children.at(i);
1901         if (mo.cast(obj)) {
1902             QRegularExpressionMatch m = re.match(obj->objectName());
1903             if (m.hasMatch())
1904                 list->append(obj);
1905         }
1906         if (options & Qt::FindChildrenRecursively)
1907             qt_qFindChildren_helper(obj, re, mo, list, options);
1908     }
1909 }
1910 #endif // QT_CONFIG(regularexpression)
1911 
1912 /*!
1913     \internal
1914  */
1915 QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo, Qt::FindChildOptions options)
1916 {
1917     if (!parent)
1918         return 0;
1919     const QObjectList &children = parent->children();
1920     QObject *obj;
1921     int i;
1922     for (i = 0; i < children.size(); ++i) {
1923         obj = children.at(i);
1924         if (mo.cast(obj) && (name.isNull() || obj->objectName() == name))
1925             return obj;
1926     }
1927     if (options & Qt::FindChildrenRecursively) {
1928         for (i = 0; i < children.size(); ++i) {
1929             obj = qt_qFindChild_helper(children.at(i), name, mo, options);
1930             if (obj)
1931                 return obj;
1932         }
1933     }
1934     return 0;
1935 }
1936 
1937 /*!
1938     Makes the object a child of \a parent.
1939 
1940     \sa parent(), children()
1941 */
1942 void QObject::setParent(QObject *parent)
1943 {
1944     Q_D(QObject);
1945     Q_ASSERT(!d->isWidget);
1946     d->setParent_helper(parent);
1947 }
1948 
1949 void QObjectPrivate::deleteChildren()
1950 {
1951     Q_ASSERT_X(!isDeletingChildren, "QObjectPrivate::deleteChildren()", "isDeletingChildren already set, did this function recurse?");
1952     isDeletingChildren = true;
1953     // delete children objects
1954     // don't use qDeleteAll as the destructor of the child might
1955     // delete siblings
1956     for (int i = 0; i < children.count(); ++i) {
1957         currentChildBeingDeleted = children.at(i);
1958         children[i] = 0;
1959         delete currentChildBeingDeleted;
1960     }
1961     children.clear();
1962     currentChildBeingDeleted = 0;
1963     isDeletingChildren = false;
1964 }
1965 
1966 void QObjectPrivate::setParent_helper(QObject *o)
1967 {
1968     Q_Q(QObject);
1969     if (o == parent)
1970         return;
1971     if (parent) {
1972         QObjectPrivate *parentD = parent->d_func();
1973         if (parentD->isDeletingChildren && wasDeleted
1974             && parentD->currentChildBeingDeleted == q) {
1975             // don't do anything since QObjectPrivate::deleteChildren() already
1976             // cleared our entry in parentD->children.
1977         } else {
1978             const int index = parentD->children.indexOf(q);
1979             if (parentD->isDeletingChildren) {
1980                 parentD->children[index] = 0;
1981             } else {
1982                 parentD->children.removeAt(index);
1983                 if (sendChildEvents && parentD->receiveChildEvents) {
1984                     QChildEvent e(QEvent::ChildRemoved, q);
1985                     QCoreApplication::sendEvent(parent, &e);
1986                 }
1987             }
1988         }
1989     }
1990     parent = o;
1991     if (parent) {
1992         // object hierarchies are constrained to a single thread
1993         if (threadData != parent->d_func()->threadData) {
1994             qWarning("QObject::setParent: Cannot set parent, new parent is in a different thread");
1995             parent = 0;
1996             return;
1997         }
1998         parent->d_func()->children.append(q);
1999         if(sendChildEvents && parent->d_func()->receiveChildEvents) {
2000             if (!isWidget) {
2001                 QChildEvent e(QEvent::ChildAdded, q);
2002                 QCoreApplication::sendEvent(parent, &e);
2003             }
2004         }
2005     }
2006     if (!wasDeleted && !isDeletingChildren && declarativeData && QAbstractDeclarativeData::parentChanged)
2007         QAbstractDeclarativeData::parentChanged(declarativeData, q, o);
2008 }
2009 
2010 /*!
2011     \fn void QObject::installEventFilter(QObject *filterObj)
2012 
2013     Installs an event filter \a filterObj on this object. For example:
2014     \snippet code/src_corelib_kernel_qobject.cpp 14
2015 
2016     An event filter is an object that receives all events that are
2017     sent to this object. The filter can either stop the event or
2018     forward it to this object. The event filter \a filterObj receives
2019     events via its eventFilter() function. The eventFilter() function
2020     must return true if the event should be filtered, (i.e. stopped);
2021     otherwise it must return false.
2022 
2023     If multiple event filters are installed on a single object, the
2024     filter that was installed last is activated first.
2025 
2026     Here's a \c KeyPressEater class that eats the key presses of its
2027     monitored objects:
2028 
2029     \snippet code/src_corelib_kernel_qobject.cpp 15
2030 
2031     And here's how to install it on two widgets:
2032 
2033     \snippet code/src_corelib_kernel_qobject.cpp 16
2034 
2035     The QShortcut class, for example, uses this technique to intercept
2036     shortcut key presses.
2037 
2038     \warning If you delete the receiver object in your eventFilter()
2039     function, be sure to return true. If you return false, Qt sends
2040     the event to the deleted object and the program will crash.
2041 
2042     Note that the filtering object must be in the same thread as this
2043     object. If \a filterObj is in a different thread, this function does
2044     nothing. If either \a filterObj or this object are moved to a different
2045     thread after calling this function, the event filter will not be
2046     called until both objects have the same thread affinity again (it
2047     is \e not removed).
2048 
2049     \sa removeEventFilter(), eventFilter(), event()
2050 */
2051 
2052 void QObject::installEventFilter(QObject *obj)
2053 {
2054     Q_D(QObject);
2055     if (!obj)
2056         return;
2057     if (d->threadData != obj->d_func()->threadData) {
2058         qWarning("QObject::installEventFilter(): Cannot filter events for objects in a different thread.");
2059         return;
2060     }
2061 
2062     if (!d->extraData)
2063         d->extraData = new QObjectPrivate::ExtraData;
2064 
2065     // clean up unused items in the list
2066     d->extraData->eventFilters.removeAll((QObject*)0);
2067     d->extraData->eventFilters.removeAll(obj);
2068     d->extraData->eventFilters.prepend(obj);
2069 }
2070 
2071 /*!
2072     Removes an event filter object \a obj from this object. The
2073     request is ignored if such an event filter has not been installed.
2074 
2075     All event filters for this object are automatically removed when
2076     this object is destroyed.
2077 
2078     It is always safe to remove an event filter, even during event
2079     filter activation (i.e. from the eventFilter() function).
2080 
2081     \sa installEventFilter(), eventFilter(), event()
2082 */
2083 
2084 void QObject::removeEventFilter(QObject *obj)
2085 {
2086     Q_D(QObject);
2087     if (d->extraData) {
2088         for (int i = 0; i < d->extraData->eventFilters.count(); ++i) {
2089             if (d->extraData->eventFilters.at(i) == obj)
2090                 d->extraData->eventFilters[i] = 0;
2091         }
2092     }
2093 }
2094 
2095 
2096 /*!
2097     \fn void QObject::destroyed(QObject *obj)
2098 
2099     This signal is emitted immediately before the object \a obj is
2100     destroyed, after any instances of QPointer have been notified,
2101     and can not be blocked.
2102 
2103     All the objects's children are destroyed immediately after this
2104     signal is emitted.
2105 
2106     \sa deleteLater(), QPointer
2107 */
2108 
2109 /*!
2110     Schedules this object for deletion.
2111 
2112     The object will be deleted when control returns to the event
2113     loop. If the event loop is not running when this function is
2114     called (e.g. deleteLater() is called on an object before
2115     QCoreApplication::exec()), the object will be deleted once the
2116     event loop is started. If deleteLater() is called after the main event loop
2117     has stopped, the object will not be deleted.
2118     Since Qt 4.8, if deleteLater() is called on an object that lives in a
2119     thread with no running event loop, the object will be destroyed when the
2120     thread finishes.
2121 
2122     Note that entering and leaving a new event loop (e.g., by opening a modal
2123     dialog) will \e not perform the deferred deletion; for the object to be
2124     deleted, the control must return to the event loop from which
2125     deleteLater() was called.
2126 
2127     \b{Note:} It is safe to call this function more than once; when the
2128     first deferred deletion event is delivered, any pending events for the
2129     object are removed from the event queue.
2130 
2131     \sa destroyed(), QPointer
2132 */
2133 void QObject::deleteLater()
2134 {
2135     QCoreApplication::postEvent(this, new QDeferredDeleteEvent());
2136 }
2137 
2138 /*!
2139     \fn QString QObject::tr(const char *sourceText, const char *disambiguation, int n)
2140     \reentrant
2141 
2142     Returns a translated version of \a sourceText, optionally based on a
2143     \a disambiguation string and value of \a n for strings containing plurals;
2144     otherwise returns QString::fromUtf8(\a sourceText) if no appropriate
2145     translated string is available.
2146 
2147     Example:
2148     \snippet ../widgets/mainwindows/sdi/mainwindow.cpp implicit tr context
2149     \dots
2150 
2151     If the same \a sourceText is used in different roles within the
2152     same context, an additional identifying string may be passed in
2153     \a disambiguation (0 by default). In Qt 4.4 and earlier, this was
2154     the preferred way to pass comments to translators.
2155 
2156     Example:
2157 
2158     \snippet code/src_corelib_kernel_qobject.cpp 17
2159     \dots
2160 
2161     See \l{Writing Source Code for Translation} for a detailed description of
2162     Qt's translation mechanisms in general, and the
2163     \l{Writing Source Code for Translation#Disambiguation}{Disambiguation}
2164     section for information on disambiguation.
2165 
2166     \warning This method is reentrant only if all translators are
2167     installed \e before calling this method. Installing or removing
2168     translators while performing translations is not supported. Doing
2169     so will probably result in crashes or other undesirable behavior.
2170 
2171     \sa QCoreApplication::translate(), {Internationalization with Qt}
2172 */
2173 
2174 /*!
2175     \fn QString QObject::trUtf8(const char *sourceText, const char *disambiguation, int n)
2176     \reentrant
2177     \obsolete
2178 
2179     Returns a translated version of \a sourceText, or
2180     QString::fromUtf8(\a sourceText) if there is no appropriate
2181     version. It is otherwise identical to tr(\a sourceText, \a
2182     disambiguation, \a n).
2183 
2184     \warning This method is reentrant only if all translators are
2185     installed \e before calling this method. Installing or removing
2186     translators while performing translations is not supported. Doing
2187     so will probably result in crashes or other undesirable behavior.
2188 
2189     \warning For portability reasons, we recommend that you use
2190     escape sequences for specifying non-ASCII characters in string
2191     literals to trUtf8(). For example:
2192 
2193     \snippet code/src_corelib_kernel_qobject.cpp 20
2194 
2195     \sa tr(), QCoreApplication::translate(), {Internationalization with Qt}
2196 */
2197 
2198 
2199 
2200 
2201 /*****************************************************************************
2202   Signals and slots
2203  *****************************************************************************/
2204 
2205 
2206 const char *qFlagLocation(const char *method)
2207 {
2208     QThreadData *currentThreadData = QThreadData::current(false);
2209     if (currentThreadData != 0)
2210         currentThreadData->flaggedSignatures.store(method);
2211     return method;
2212 }
2213 
2214 static int extract_code(const char *member)
2215 {
2216     // extract code, ensure QMETHOD_CODE <= code <= QSIGNAL_CODE
2217     return (((int)(*member) - '0') & 0x3);
2218 }
2219 
2220 static const char * extract_location(const char *member)
2221 {
2222     if (QThreadData::current()->flaggedSignatures.contains(member)) {
2223         // signature includes location information after the first null-terminator
2224         const char *location = member + qstrlen(member) + 1;
2225         if (*location != '\0')
2226             return location;
2227     }
2228     return 0;
2229 }
2230 
2231 static bool check_signal_macro(const QObject *sender, const char *signal,
2232                                 const char *func, const char *op)
2233 {
2234     int sigcode = extract_code(signal);
2235     if (sigcode != QSIGNAL_CODE) {
2236         if (sigcode == QSLOT_CODE)
2237             qWarning("QObject::%s: Attempt to %s non-signal %s::%s",
2238                      func, op, sender->metaObject()->className(), signal+1);
2239         else
2240             qWarning("QObject::%s: Use the SIGNAL macro to %s %s::%s",
2241                      func, op, sender->metaObject()->className(), signal);
2242         return false;
2243     }
2244     return true;
2245 }
2246 
2247 static bool check_method_code(int code, const QObject *object,
2248                                const char *method, const char *func)
2249 {
2250     if (code != QSLOT_CODE && code != QSIGNAL_CODE) {
2251         qWarning("QObject::%s: Use the SLOT or SIGNAL macro to "
2252                  "%s %s::%s", func, func, object->metaObject()->className(), method);
2253         return false;
2254     }
2255     return true;
2256 }
2257 
2258 static void err_method_notfound(const QObject *object,
2259                                 const char *method, const char *func)
2260 {
2261     const char *type = "method";
2262     switch (extract_code(method)) {
2263         case QSLOT_CODE:   type = "slot";   break;
2264         case QSIGNAL_CODE: type = "signal"; break;
2265     }
2266     const char *loc = extract_location(method);
2267     if (strchr(method,')') == 0)                // common typing mistake
2268         qWarning("QObject::%s: Parentheses expected, %s %s::%s%s%s",
2269                  func, type, object->metaObject()->className(), method+1,
2270                  loc ? " in ": "", loc ? loc : "");
2271     else
2272         qWarning("QObject::%s: No such %s %s::%s%s%s",
2273                  func, type, object->metaObject()->className(), method+1,
2274                  loc ? " in ": "", loc ? loc : "");
2275 
2276 }
2277 
2278 
2279 static void err_info_about_objects(const char * func,
2280                                     const QObject * sender,
2281                                     const QObject * receiver)
2282 {
2283     QString a = sender ? sender->objectName() : QString();
2284     QString b = receiver ? receiver->objectName() : QString();
2285     if (!a.isEmpty())
2286         qWarning("QObject::%s:  (sender name:   '%s')", func, a.toLocal8Bit().data());
2287     if (!b.isEmpty())
2288         qWarning("QObject::%s:  (receiver name: '%s')", func, b.toLocal8Bit().data());
2289 }
2290 
2291 /*!
2292     Returns a pointer to the object that sent the signal, if called in
2293     a slot activated by a signal; otherwise it returns 0. The pointer
2294     is valid only during the execution of the slot that calls this
2295     function from this object's thread context.
2296 
2297     The pointer returned by this function becomes invalid if the
2298     sender is destroyed, or if the slot is disconnected from the
2299     sender's signal.
2300 
2301     \warning This function violates the object-oriented principle of
2302     modularity. However, getting access to the sender might be useful
2303     when many signals are connected to a single slot.
2304 
2305     \warning As mentioned above, the return value of this function is
2306     not valid when the slot is called via a Qt::DirectConnection from
2307     a thread different from this object's thread. Do not use this
2308     function in this type of scenario.
2309 
2310     \sa senderSignalIndex()
2311 */
2312 
2313 QObject *QObject::sender() const
2314 {
2315     Q_D(const QObject);
2316 
2317     QMutexLocker locker(signalSlotLock(this));
2318     if (!d->connections || !d->connections->currentSender)
2319         return nullptr;
2320 
2321     for (QObjectPrivate::Connection *c = d->connections->senders; c; c = c->next) {
2322         if (c->sender == d->connections->currentSender->sender)
2323             return d->connections->currentSender->sender;
2324     }
2325 
2326     return 0;
2327 }
2328 
2329 /*!
2330     \since 4.8
2331 
2332     Returns the meta-method index of the signal that called the currently
2333     executing slot, which is a member of the class returned by sender().
2334     If called outside of a slot activated by a signal, -1 is returned.
2335 
2336     For signals with default parameters, this function will always return
2337     the index with all parameters, regardless of which was used with
2338     connect(). For example, the signal \c {destroyed(QObject *obj = 0)}
2339     will have two different indexes (with and without the parameter), but
2340     this function will always return the index with a parameter. This does
2341     not apply when overloading signals with different parameters.
2342 
2343     \warning This function violates the object-oriented principle of
2344     modularity. However, getting access to the signal index might be useful
2345     when many signals are connected to a single slot.
2346 
2347     \warning The return value of this function is not valid when the slot
2348     is called via a Qt::DirectConnection from a thread different from this
2349     object's thread. Do not use this function in this type of scenario.
2350 
2351     \sa sender(), QMetaObject::indexOfSignal(), QMetaObject::method()
2352 */
2353 
2354 int QObject::senderSignalIndex() const
2355 {
2356     Q_D(const QObject);
2357 
2358     QMutexLocker locker(signalSlotLock(this));
2359     if (!d->connections || !d->connections->currentSender)
2360         return -1;
2361 
2362     for (QObjectPrivate::Connection *c = d->connections->senders; c; c = c->next) {
2363         if (c->sender == d->connections->currentSender->sender) {
2364             // Convert from signal range to method range
2365             return QMetaObjectPrivate::signal(c->sender->metaObject(), d->connections->currentSender->signal).methodIndex();
2366         }
2367     }
2368 
2369     return -1;
2370 }
2371 
2372 /*!
2373     Returns the number of receivers connected to the \a signal.
2374 
2375     Since both slots and signals can be used as receivers for signals,
2376     and the same connections can be made many times, the number of
2377     receivers is the same as the number of connections made from this
2378     signal.
2379 
2380     When calling this function, you can use the \c SIGNAL() macro to
2381     pass a specific signal:
2382 
2383     \snippet code/src_corelib_kernel_qobject.cpp 21
2384 
2385     \warning This function violates the object-oriented principle of
2386     modularity. However, it might be useful when you need to perform
2387     expensive initialization only if something is connected to a
2388     signal.
2389 
2390     \sa isSignalConnected()
2391 */
2392 
2393 int QObject::receivers(const char *signal) const
2394 {
2395     Q_D(const QObject);
2396     int receivers = 0;
2397     if (signal && d->connections) {
2398         QByteArray signal_name = QMetaObject::normalizedSignature(signal);
2399         signal = signal_name;
2400 #ifndef QT_NO_DEBUG
2401         if (!check_signal_macro(this, signal, "receivers", "bind"))
2402             return 0;
2403 #endif
2404         signal++; // skip code
2405         int signal_index = d->signalIndex(signal);
2406         if (signal_index < 0) {
2407 #ifndef QT_NO_DEBUG
2408             err_method_notfound(this, signal-1, "receivers");
2409 #endif
2410             return 0;
2411         }
2412 
2413         if (!d->isSignalConnected(signal_index))
2414             return receivers;
2415 
2416         if (d->declarativeData && QAbstractDeclarativeData::receivers) {
2417             receivers += QAbstractDeclarativeData::receivers(d->declarativeData, this,
2418                                                              signal_index);
2419         }
2420 
2421         QMutexLocker locker(signalSlotLock(this));
2422         if (signal_index < d->connections->signalVector.count()) {
2423             const QObjectPrivate::Connection *c =
2424                 d->connections->signalVector.at(signal_index).first;
2425             while (c) {
2426                 receivers += c->receiver ? 1 : 0;
2427                 c = c->nextConnectionList;
2428             }
2429         }
2430     }
2431     return receivers;
2432 }
2433 
2434 /*!
2435     \since 5.0
2436     Returns \c true if the \a signal is connected to at least one receiver,
2437     otherwise returns \c false.
2438 
2439     \a signal must be a signal member of this object, otherwise the behaviour
2440     is undefined.
2441 
2442     \snippet code/src_corelib_kernel_qobject.cpp 49
2443 
2444     As the code snippet above illustrates, you can use this function
2445     to avoid emitting a signal that nobody listens to.
2446 
2447     \warning This function violates the object-oriented principle of
2448     modularity. However, it might be useful when you need to perform
2449     expensive initialization only if something is connected to a
2450     signal.
2451 */
2452 bool QObject::isSignalConnected(const QMetaMethod &signal) const
2453 {
2454     Q_D(const QObject);
2455     if (!signal.mobj)
2456         return false;
2457 
2458     Q_ASSERT_X(signal.mobj->cast(this) && signal.methodType() == QMetaMethod::Signal,
2459                "QObject::isSignalConnected" , "the parameter must be a signal member of the object");
2460     uint signalIndex = (signal.handle - QMetaObjectPrivate::get(signal.mobj)->methodData)/5;
2461 
2462     if (signal.mobj->d.data[signal.handle + 4] & MethodCloned)
2463         signalIndex = QMetaObjectPrivate::originalClone(signal.mobj, signalIndex);
2464 
2465     signalIndex += QMetaObjectPrivate::signalOffset(signal.mobj);
2466 
2467     QMutexLocker locker(signalSlotLock(this));
2468     return d->isSignalConnected(signalIndex, true);
2469 }
2470 
2471 /*!
2472     \internal
2473 
2474     This helper function calculates signal and method index for the given
2475     member in the specified class.
2476 
2477     \list
2478     \li If member.mobj is 0 then both signalIndex and methodIndex are set to -1.
2479 
2480     \li If specified member is not a member of obj instance class (or one of
2481     its parent classes) then both signalIndex and methodIndex are set to -1.
2482     \endlist
2483 
2484     This function is used by QObject::connect and QObject::disconnect which
2485     are working with QMetaMethod.
2486 
2487     \a signalIndex is set to the signal index of member. If the member
2488     specified is not signal this variable is set to -1.
2489 
2490     \a methodIndex is set to the method index of the member. If the
2491     member is not a method of the object specified by the \a obj argument this
2492     variable is set to -1.
2493 */
2494 void QMetaObjectPrivate::memberIndexes(const QObject *obj,
2495                                        const QMetaMethod &member,
2496                                        int *signalIndex, int *methodIndex)
2497 {
2498     *signalIndex = -1;
2499     *methodIndex = -1;
2500     if (!obj || !member.mobj)
2501         return;
2502     const QMetaObject *m = obj->metaObject();
2503     // Check that member is member of obj class
2504     while (m != 0 && m != member.mobj)
2505         m = m->d.superdata;
2506     if (!m)
2507         return;
2508     *signalIndex = *methodIndex = (member.handle - get(member.mobj)->methodData)/5;
2509 
2510     int signalOffset;
2511     int methodOffset;
2512     computeOffsets(m, &signalOffset, &methodOffset);
2513 
2514     *methodIndex += methodOffset;
2515     if (member.methodType() == QMetaMethod::Signal) {
2516         *signalIndex = originalClone(m, *signalIndex);
2517         *signalIndex += signalOffset;
2518     } else {
2519         *signalIndex = -1;
2520     }
2521 }
2522 
2523 #ifndef QT_NO_DEBUG
2524 static inline void check_and_warn_compat(const QMetaObject *sender, const QMetaMethod &signal,
2525                                          const QMetaObject *receiver, const QMetaMethod &method)
2526 {
2527     if (signal.attributes() & QMetaMethod::Compatibility) {
2528         if (!(method.attributes() & QMetaMethod::Compatibility))
2529             qWarning("QObject::connect: Connecting from COMPAT signal (%s::%s)",
2530                      sender->className(), signal.methodSignature().constData());
2531     } else if ((method.attributes() & QMetaMethod::Compatibility) &&
2532                method.methodType() == QMetaMethod::Signal) {
2533         qWarning("QObject::connect: Connecting from %s::%s to COMPAT slot (%s::%s)",
2534                  sender->className(), signal.methodSignature().constData(),
2535                  receiver->className(), method.methodSignature().constData());
2536     }
2537 }
2538 #endif
2539 
2540 /*!
2541     \threadsafe
2542 
2543     Creates a connection of the given \a type from the \a signal in
2544     the \a sender object to the \a method in the \a receiver object.
2545     Returns a handle to the connection that can be used to disconnect
2546     it later.
2547 
2548     You must use the \c SIGNAL() and \c SLOT() macros when specifying
2549     the \a signal and the \a method, for example:
2550 
2551     \snippet code/src_corelib_kernel_qobject.cpp 22
2552 
2553     This example ensures that the label always displays the current
2554     scroll bar value. Note that the signal and slots parameters must not
2555     contain any variable names, only the type. E.g. the following would
2556     not work and return false:
2557 
2558     \snippet code/src_corelib_kernel_qobject.cpp 23
2559 
2560     A signal can also be connected to another signal:
2561 
2562     \snippet code/src_corelib_kernel_qobject.cpp 24
2563 
2564     In this example, the \c MyWidget constructor relays a signal from
2565     a private member variable, and makes it available under a name
2566     that relates to \c MyWidget.
2567 
2568     A signal can be connected to many slots and signals. Many signals
2569     can be connected to one slot.
2570 
2571     If a signal is connected to several slots, the slots are activated
2572     in the same order in which the connections were made, when the
2573     signal is emitted.
2574 
2575     The function returns a QMetaObject::Connection that represents
2576     a handle to a connection if it successfully
2577     connects the signal to the slot. The connection handle will be invalid
2578     if it cannot create the connection, for example, if QObject is unable
2579     to verify the existence of either \a signal or \a method, or if their
2580     signatures aren't compatible.
2581     You can check if the handle is valid by casting it to a bool.
2582 
2583     By default, a signal is emitted for every connection you make;
2584     two signals are emitted for duplicate connections. You can break
2585     all of these connections with a single disconnect() call.
2586     If you pass the Qt::UniqueConnection \a type, the connection will only
2587     be made if it is not a duplicate. If there is already a duplicate
2588     (exact same signal to the exact same slot on the same objects),
2589     the connection will fail and connect will return an invalid QMetaObject::Connection.
2590 
2591     \note Qt::UniqueConnections do not work for lambdas, non-member functions
2592     and functors; they only apply to connecting to member functions.
2593 
2594     The optional \a type parameter describes the type of connection
2595     to establish. In particular, it determines whether a particular
2596     signal is delivered to a slot immediately or queued for delivery
2597     at a later time. If the signal is queued, the parameters must be
2598     of types that are known to Qt's meta-object system, because Qt
2599     needs to copy the arguments to store them in an event behind the
2600     scenes. If you try to use a queued connection and get the error
2601     message
2602 
2603     \snippet code/src_corelib_kernel_qobject.cpp 25
2604 
2605     call qRegisterMetaType() to register the data type before you
2606     establish the connection.
2607 
2608     \sa disconnect(), sender(), qRegisterMetaType(), Q_DECLARE_METATYPE(),
2609     {Differences between String-Based and Functor-Based Connections}
2610 */
2611 QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal,
2612                                      const QObject *receiver, const char *method,
2613                                      Qt::ConnectionType type)
2614 {
2615     if (sender == 0 || receiver == 0 || signal == 0 || method == 0) {
2616         qWarning("QObject::connect: Cannot connect %s::%s to %s::%s",
2617                  sender ? sender->metaObject()->className() : "(null)",
2618                  (signal && *signal) ? signal+1 : "(null)",
2619                  receiver ? receiver->metaObject()->className() : "(null)",
2620                  (method && *method) ? method+1 : "(null)");
2621         return QMetaObject::Connection(0);
2622     }
2623     QByteArray tmp_signal_name;
2624 
2625     if (!check_signal_macro(sender, signal, "connect", "bind"))
2626         return QMetaObject::Connection(0);
2627     const QMetaObject *smeta = sender->metaObject();
2628     const char *signal_arg = signal;
2629     ++signal; //skip code
2630     QArgumentTypeArray signalTypes;
2631     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
2632     QByteArray signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2633     int signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2634             &smeta, signalName, signalTypes.size(), signalTypes.constData());
2635     if (signal_index < 0) {
2636         // check for normalized signatures
2637         tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
2638         signal = tmp_signal_name.constData() + 1;
2639 
2640         signalTypes.clear();
2641         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2642         smeta = sender->metaObject();
2643         signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2644                 &smeta, signalName, signalTypes.size(), signalTypes.constData());
2645     }
2646     if (signal_index < 0) {
2647         err_method_notfound(sender, signal_arg, "connect");
2648         err_info_about_objects("connect", sender, receiver);
2649         return QMetaObject::Connection(0);
2650     }
2651     signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
2652     signal_index += QMetaObjectPrivate::signalOffset(smeta);
2653 
2654     QByteArray tmp_method_name;
2655     int membcode = extract_code(method);
2656 
2657     if (!check_method_code(membcode, receiver, method, "connect"))
2658         return QMetaObject::Connection(0);
2659     const char *method_arg = method;
2660     ++method; // skip code
2661 
2662     QArgumentTypeArray methodTypes;
2663     QByteArray methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2664     const QMetaObject *rmeta = receiver->metaObject();
2665     int method_index_relative = -1;
2666     Q_ASSERT(QMetaObjectPrivate::get(rmeta)->revision >= 7);
2667     switch (membcode) {
2668     case QSLOT_CODE:
2669         method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2670                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2671         break;
2672     case QSIGNAL_CODE:
2673         method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2674                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2675         break;
2676     }
2677     if (method_index_relative < 0) {
2678         // check for normalized methods
2679         tmp_method_name = QMetaObject::normalizedSignature(method);
2680         method = tmp_method_name.constData();
2681 
2682         methodTypes.clear();
2683         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2684         // rmeta may have been modified above
2685         rmeta = receiver->metaObject();
2686         switch (membcode) {
2687         case QSLOT_CODE:
2688             method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2689                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2690             break;
2691         case QSIGNAL_CODE:
2692             method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2693                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2694             break;
2695         }
2696     }
2697 
2698     if (method_index_relative < 0) {
2699         err_method_notfound(receiver, method_arg, "connect");
2700         err_info_about_objects("connect", sender, receiver);
2701         return QMetaObject::Connection(0);
2702     }
2703 
2704     if (!QMetaObjectPrivate::checkConnectArgs(signalTypes.size(), signalTypes.constData(),
2705                                               methodTypes.size(), methodTypes.constData())) {
2706         qWarning("QObject::connect: Incompatible sender/receiver arguments"
2707                  "\n        %s::%s --> %s::%s",
2708                  sender->metaObject()->className(), signal,
2709                  receiver->metaObject()->className(), method);
2710         return QMetaObject::Connection(0);
2711     }
2712 
2713     int *types = 0;
2714     if ((type == Qt::QueuedConnection)
2715             && !(types = queuedConnectionTypes(signalTypes.constData(), signalTypes.size()))) {
2716         return QMetaObject::Connection(0);
2717     }
2718 
2719 #ifndef QT_NO_DEBUG
2720     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
2721     QMetaMethod rmethod = rmeta->method(method_index_relative + rmeta->methodOffset());
2722     check_and_warn_compat(smeta, smethod, rmeta, rmethod);
2723 #endif
2724     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2725         sender, signal_index, smeta, receiver, method_index_relative, rmeta ,type, types));
2726     return handle;
2727 }
2728 
2729 /*!
2730     \since 4.8
2731 
2732     Creates a connection of the given \a type from the \a signal in
2733     the \a sender object to the \a method in the \a receiver object.
2734     Returns a handle to the connection that can be used to disconnect
2735     it later.
2736 
2737     The Connection handle will be invalid  if it cannot create the
2738     connection, for example, the parameters were invalid.
2739     You can check if the QMetaObject::Connection is valid by casting it to a bool.
2740 
2741     This function works in the same way as
2742     \c {connect(const QObject *sender, const char *signal,
2743             const QObject *receiver, const char *method,
2744             Qt::ConnectionType type)}
2745     but it uses QMetaMethod to specify signal and method.
2746 
2747     \sa connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)
2748  */
2749 QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal,
2750                                      const QObject *receiver, const QMetaMethod &method,
2751                                      Qt::ConnectionType type)
2752 {
2753     if (sender == 0
2754             || receiver == 0
2755             || signal.methodType() != QMetaMethod::Signal
2756             || method.methodType() == QMetaMethod::Constructor) {
2757         qWarning("QObject::connect: Cannot connect %s::%s to %s::%s",
2758                  sender ? sender->metaObject()->className() : "(null)",
2759                  signal.methodSignature().constData(),
2760                  receiver ? receiver->metaObject()->className() : "(null)",
2761                  method.methodSignature().constData() );
2762         return QMetaObject::Connection(0);
2763     }
2764 
2765     int signal_index;
2766     int method_index;
2767     {
2768         int dummy;
2769         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
2770         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
2771     }
2772 
2773     const QMetaObject *smeta = sender->metaObject();
2774     const QMetaObject *rmeta = receiver->metaObject();
2775     if (signal_index == -1) {
2776         qWarning("QObject::connect: Can't find signal %s on instance of class %s",
2777                  signal.methodSignature().constData(), smeta->className());
2778         return QMetaObject::Connection(0);
2779     }
2780     if (method_index == -1) {
2781         qWarning("QObject::connect: Can't find method %s on instance of class %s",
2782                  method.methodSignature().constData(), rmeta->className());
2783         return QMetaObject::Connection(0);
2784     }
2785 
2786     if (!QMetaObject::checkConnectArgs(signal.methodSignature().constData(), method.methodSignature().constData())) {
2787         qWarning("QObject::connect: Incompatible sender/receiver arguments"
2788                  "\n        %s::%s --> %s::%s",
2789                  smeta->className(), signal.methodSignature().constData(),
2790                  rmeta->className(), method.methodSignature().constData());
2791         return QMetaObject::Connection(0);
2792     }
2793 
2794     int *types = 0;
2795     if ((type == Qt::QueuedConnection)
2796             && !(types = queuedConnectionTypes(signal.parameterTypes())))
2797         return QMetaObject::Connection(0);
2798 
2799 #ifndef QT_NO_DEBUG
2800     check_and_warn_compat(smeta, signal, rmeta, method);
2801 #endif
2802     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2803         sender, signal_index, signal.enclosingMetaObject(), receiver, method_index, 0, type, types));
2804     return handle;
2805 }
2806 
2807 /*!
2808     \fn bool QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const
2809     \overload connect()
2810     \threadsafe
2811 
2812     Connects \a signal from the \a sender object to this object's \a
2813     method.
2814 
2815     Equivalent to connect(\a sender, \a signal, \c this, \a method, \a type).
2816 
2817     Every connection you make emits a signal, so duplicate connections emit
2818     two signals. You can break a connection using disconnect().
2819 
2820     \sa disconnect()
2821 */
2822 
2823 /*!
2824     \threadsafe
2825 
2826     Disconnects \a signal in object \a sender from \a method in object
2827     \a receiver. Returns \c true if the connection is successfully broken;
2828     otherwise returns \c false.
2829 
2830     A signal-slot connection is removed when either of the objects
2831     involved are destroyed.
2832 
2833     disconnect() is typically used in three ways, as the following
2834     examples demonstrate.
2835     \list 1
2836     \li Disconnect everything connected to an object's signals:
2837 
2838        \snippet code/src_corelib_kernel_qobject.cpp 26
2839 
2840        equivalent to the non-static overloaded function
2841 
2842        \snippet code/src_corelib_kernel_qobject.cpp 27
2843 
2844     \li Disconnect everything connected to a specific signal:
2845 
2846        \snippet code/src_corelib_kernel_qobject.cpp 28
2847 
2848        equivalent to the non-static overloaded function
2849 
2850        \snippet code/src_corelib_kernel_qobject.cpp 29
2851 
2852     \li Disconnect a specific receiver:
2853 
2854        \snippet code/src_corelib_kernel_qobject.cpp 30
2855 
2856        equivalent to the non-static overloaded function
2857 
2858        \snippet code/src_corelib_kernel_qobject.cpp 31
2859 
2860     \endlist
2861 
2862     0 may be used as a wildcard, meaning "any signal", "any receiving
2863     object", or "any slot in the receiving object", respectively.
2864 
2865     The \a sender may never be 0. (You cannot disconnect signals from
2866     more than one object in a single call.)
2867 
2868     If \a signal is 0, it disconnects \a receiver and \a method from
2869     any signal. If not, only the specified signal is disconnected.
2870 
2871     If \a receiver is 0, it disconnects anything connected to \a
2872     signal. If not, slots in objects other than \a receiver are not
2873     disconnected.
2874 
2875     If \a method is 0, it disconnects anything that is connected to \a
2876     receiver. If not, only slots named \a method will be disconnected,
2877     and all other slots are left alone. The \a method must be 0 if \a
2878     receiver is left out, so you cannot disconnect a
2879     specifically-named slot on all objects.
2880 
2881     \sa connect()
2882 */
2883 bool QObject::disconnect(const QObject *sender, const char *signal,
2884                          const QObject *receiver, const char *method)
2885 {
2886     if (sender == 0 || (receiver == 0 && method != 0)) {
2887         qWarning("QObject::disconnect: Unexpected null parameter");
2888         return false;
2889     }
2890 
2891     const char *signal_arg = signal;
2892     QByteArray signal_name;
2893     bool signal_found = false;
2894     if (signal) {
2895         QT_TRY {
2896             signal_name = QMetaObject::normalizedSignature(signal);
2897             signal = signal_name.constData();
2898         } QT_CATCH (const std::bad_alloc &) {
2899             // if the signal is already normalized, we can continue.
2900             if (sender->metaObject()->indexOfSignal(signal + 1) == -1)
2901                 QT_RETHROW;
2902         }
2903 
2904         if (!check_signal_macro(sender, signal, "disconnect", "unbind"))
2905             return false;
2906         signal++; // skip code
2907     }
2908 
2909     QByteArray method_name;
2910     const char *method_arg = method;
2911     int membcode = -1;
2912     bool method_found = false;
2913     if (method) {
2914         QT_TRY {
2915             method_name = QMetaObject::normalizedSignature(method);
2916             method = method_name.constData();
2917         } QT_CATCH(const std::bad_alloc &) {
2918             // if the method is already normalized, we can continue.
2919             if (receiver->metaObject()->indexOfMethod(method + 1) == -1)
2920                 QT_RETHROW;
2921         }
2922 
2923         membcode = extract_code(method);
2924         if (!check_method_code(membcode, receiver, method, "disconnect"))
2925             return false;
2926         method++; // skip code
2927     }
2928 
2929     /* We now iterate through all the sender's and receiver's meta
2930      * objects in order to also disconnect possibly shadowed signals
2931      * and slots with the same signature.
2932     */
2933     bool res = false;
2934     const QMetaObject *smeta = sender->metaObject();
2935     QByteArray signalName;
2936     QArgumentTypeArray signalTypes;
2937     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
2938     if (signal)
2939         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2940     QByteArray methodName;
2941     QArgumentTypeArray methodTypes;
2942     Q_ASSERT(!receiver || QMetaObjectPrivate::get(receiver->metaObject())->revision >= 7);
2943     if (method)
2944         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2945     do {
2946         int signal_index = -1;
2947         if (signal) {
2948             signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2949                         &smeta, signalName, signalTypes.size(), signalTypes.constData());
2950             if (signal_index < 0)
2951                 break;
2952             signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
2953             signal_index += QMetaObjectPrivate::signalOffset(smeta);
2954             signal_found = true;
2955         }
2956 
2957         if (!method) {
2958             res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, -1, 0);
2959         } else {
2960             const QMetaObject *rmeta = receiver->metaObject();
2961             do {
2962                 int method_index = QMetaObjectPrivate::indexOfMethod(
2963                             rmeta, methodName, methodTypes.size(), methodTypes.constData());
2964                 if (method_index >= 0)
2965                     while (method_index < rmeta->methodOffset())
2966                             rmeta = rmeta->superClass();
2967                 if (method_index < 0)
2968                     break;
2969                 res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, method_index, 0);
2970                 method_found = true;
2971             } while ((rmeta = rmeta->superClass()));
2972         }
2973     } while (signal && (smeta = smeta->superClass()));
2974 
2975     if (signal && !signal_found) {
2976         err_method_notfound(sender, signal_arg, "disconnect");
2977         err_info_about_objects("disconnect", sender, receiver);
2978     } else if (method && !method_found) {
2979         err_method_notfound(receiver, method_arg, "disconnect");
2980         err_info_about_objects("disconnect", sender, receiver);
2981     }
2982     if (res) {
2983         if (!signal)
2984             const_cast<QObject*>(sender)->disconnectNotify(QMetaMethod());
2985     }
2986     return res;
2987 }
2988 
2989 /*!
2990     \since 4.8
2991 
2992     Disconnects \a signal in object \a sender from \a method in object
2993     \a receiver. Returns \c true if the connection is successfully broken;
2994     otherwise returns \c false.
2995 
2996     This function provides the same possibilities like
2997     \c {disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method) }
2998     but uses QMetaMethod to represent the signal and the method to be disconnected.
2999 
3000     Additionally this function returnsfalse and no signals and slots disconnected
3001     if:
3002     \list 1
3003 
3004         \li \a signal is not a member of sender class or one of its parent classes.
3005 
3006         \li \a method is not a member of receiver class or one of its parent classes.
3007 
3008         \li \a signal instance represents not a signal.
3009 
3010     \endlist
3011 
3012     QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object".
3013     In the same way 0 can be used for \a receiver in the meaning "any receiving object". In this case
3014     method should also be QMetaMethod(). \a sender parameter should be never 0.
3015 
3016     \sa disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
3017  */
3018 bool QObject::disconnect(const QObject *sender, const QMetaMethod &signal,
3019                          const QObject *receiver, const QMetaMethod &method)
3020 {
3021     if (sender == 0 || (receiver == 0 && method.mobj != 0)) {
3022         qWarning("QObject::disconnect: Unexpected null parameter");
3023         return false;
3024     }
3025     if (signal.mobj) {
3026         if(signal.methodType() != QMetaMethod::Signal) {
3027             qWarning("QObject::%s: Attempt to %s non-signal %s::%s",
3028                      "disconnect","unbind",
3029                      sender->metaObject()->className(), signal.methodSignature().constData());
3030             return false;
3031         }
3032     }
3033     if (method.mobj) {
3034         if(method.methodType() == QMetaMethod::Constructor) {
3035             qWarning("QObject::disconect: cannot use constructor as argument %s::%s",
3036                      receiver->metaObject()->className(), method.methodSignature().constData());
3037             return false;
3038         }
3039     }
3040 
3041     // Reconstructing SIGNAL() macro result for signal.methodSignature() string
3042     QByteArray signalSignature;
3043     if (signal.mobj) {
3044         signalSignature.reserve(signal.methodSignature().size()+1);
3045         signalSignature.append((char)(QSIGNAL_CODE + '0'));
3046         signalSignature.append(signal.methodSignature());
3047     }
3048 
3049     int signal_index;
3050     int method_index;
3051     {
3052         int dummy;
3053         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
3054         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
3055     }
3056     // If we are here sender is not null. If signal is not null while signal_index
3057     // is -1 then this signal is not a member of sender.
3058     if (signal.mobj && signal_index == -1) {
3059         qWarning("QObject::disconect: signal %s not found on class %s",
3060                  signal.methodSignature().constData(), sender->metaObject()->className());
3061         return false;
3062     }
3063     // If this condition is true then method is not a member of receeiver.
3064     if (receiver && method.mobj && method_index == -1) {
3065         qWarning("QObject::disconect: method %s not found on class %s",
3066                  method.methodSignature().constData(), receiver->metaObject()->className());
3067         return false;
3068     }
3069 
3070     if (!QMetaObjectPrivate::disconnect(sender, signal_index, signal.mobj, receiver, method_index, 0))
3071         return false;
3072 
3073     if (!signal.isValid()) {
3074         // The signal is a wildcard, meaning all signals were disconnected.
3075         // QMetaObjectPrivate::disconnect() doesn't call disconnectNotify()
3076         // per connection in this case. Call it once now, with an invalid
3077         // QMetaMethod as argument, as documented.
3078         const_cast<QObject*>(sender)->disconnectNotify(signal);
3079     }
3080     return true;
3081 }
3082 
3083 /*!
3084     \threadsafe
3085 
3086     \fn bool QObject::disconnect(const char *signal, const QObject *receiver, const char *method) const
3087     \overload disconnect()
3088 
3089     Disconnects \a signal from \a method of \a receiver.
3090 
3091     A signal-slot connection is removed when either of the objects
3092     involved are destroyed.
3093 */
3094 
3095 /*!
3096     \fn bool QObject::disconnect(const QObject *receiver, const char *method) const
3097     \overload disconnect()
3098 
3099     Disconnects all signals in this object from \a receiver's \a
3100     method.
3101 
3102     A signal-slot connection is removed when either of the objects
3103     involved are destroyed.
3104 */
3105 
3106 
3107 /*!
3108     \since 5.0
3109 
3110     This virtual function is called when something has been connected
3111     to \a signal in this object.
3112 
3113     If you want to compare \a signal with a specific signal, you can
3114     use QMetaMethod::fromSignal() as follows:
3115 
3116     \snippet code/src_corelib_kernel_qobject.cpp 32
3117 
3118     \warning This function violates the object-oriented principle of
3119     modularity. However, it might be useful when you need to perform
3120     expensive initialization only if something is connected to a
3121     signal.
3122 
3123     \warning This function is called from the thread which performs the
3124     connection, which may be a different thread from the thread in
3125     which this object lives.
3126 
3127     \sa connect(), disconnectNotify()
3128 */
3129 
3130 void QObject::connectNotify(const QMetaMethod &signal)
3131 {
3132     Q_UNUSED(signal);
3133 }
3134 
3135 /*!
3136     \since 5.0
3137 
3138     This virtual function is called when something has been
3139     disconnected from \a signal in this object.
3140 
3141     See connectNotify() for an example of how to compare
3142     \a signal with a specific signal.
3143 
3144     If all signals were disconnected from this object (e.g., the
3145     signal argument to disconnect() was 0), disconnectNotify()
3146     is only called once, and the \a signal will be an invalid
3147     QMetaMethod (QMetaMethod::isValid() returns \c false).
3148 
3149     \warning This function violates the object-oriented principle of
3150     modularity. However, it might be useful for optimizing access to
3151     expensive resources.
3152 
3153     \warning This function is called from the thread which performs the
3154     disconnection, which may be a different thread from the thread in
3155     which this object lives. This function may also be called with a QObject
3156     internal mutex locked. It is therefore not allowed to re-enter any
3157     of any QObject functions from your reimplementation and if you lock
3158     a mutex in your reimplementation, make sure that you don't call QObject
3159     functions with that mutex held in other places or it will result in
3160     a deadlock.
3161 
3162     \sa disconnect(), connectNotify()
3163 */
3164 
3165 void QObject::disconnectNotify(const QMetaMethod &signal)
3166 {
3167     Q_UNUSED(signal);
3168 }
3169 
3170 /*
3171     \internal
3172     convert a signal index from the method range to the signal range
3173  */
3174 static int methodIndexToSignalIndex(const QMetaObject **base, int signal_index)
3175 {
3176     if (signal_index < 0)
3177         return signal_index;
3178     const QMetaObject *metaObject = *base;
3179     while (metaObject && metaObject->methodOffset() > signal_index)
3180         metaObject = metaObject->superClass();
3181 
3182     if (metaObject) {
3183         int signalOffset, methodOffset;
3184         computeOffsets(metaObject, &signalOffset, &methodOffset);
3185         if (signal_index < metaObject->methodCount())
3186             signal_index = QMetaObjectPrivate::originalClone(metaObject, signal_index - methodOffset) + signalOffset;
3187         else
3188             signal_index = signal_index - methodOffset + signalOffset;
3189         *base = metaObject;
3190     }
3191     return signal_index;
3192 }
3193 
3194 /*!
3195    \internal
3196    \a types is a 0-terminated vector of meta types for queued
3197    connections.
3198 
3199    if \a signal_index is -1, then we effectively connect *all* signals
3200    from the sender to the receiver's slot
3201  */
3202 QMetaObject::Connection QMetaObject::connect(const QObject *sender, int signal_index,
3203                                           const QObject *receiver, int method_index, int type, int *types)
3204 {
3205     const QMetaObject *smeta = sender->metaObject();
3206     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3207     return Connection(QMetaObjectPrivate::connect(sender, signal_index, smeta,
3208                                        receiver, method_index,
3209                                        0, //FIXME, we could speed this connection up by computing the relative index
3210                                        type, types));
3211 }
3212 
3213 /*!
3214     \internal
3215    Same as the QMetaObject::connect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3216 
3217     method_index is relative to the rmeta metaobject, if rmeta is null, then it is absolute index
3218 
3219     the QObjectPrivate::Connection* has a refcount of 2, so it must be passed to a QMetaObject::Connection
3220  */
3221 QObjectPrivate::Connection *QMetaObjectPrivate::connect(const QObject *sender,
3222                                  int signal_index, const QMetaObject *smeta,
3223                                  const QObject *receiver, int method_index,
3224                                  const QMetaObject *rmeta, int type, int *types)
3225 {
3226     QObject *s = const_cast<QObject *>(sender);
3227     QObject *r = const_cast<QObject *>(receiver);
3228 
3229     int method_offset = rmeta ? rmeta->methodOffset() : 0;
3230     Q_ASSERT(!rmeta || QMetaObjectPrivate::get(rmeta)->revision >= 6);
3231     QObjectPrivate::StaticMetaCallFunction callFunction = rmeta ? rmeta->d.static_metacall : nullptr;
3232 
3233     QOrderedMutexLocker locker(signalSlotLock(sender),
3234                                signalSlotLock(receiver));
3235 
3236     QObjectPrivate *sd  = QObjectPrivate::get(s);
3237     if (type & Qt::UniqueConnection && sd->connections) {
3238         if (sd->connections->signalVector.count() > signal_index) {
3239             const QObjectPrivate::Connection *c2 = sd->connections->signalVector.at(signal_index).first;
3240 
3241             int method_index_absolute = method_index + method_offset;
3242 
3243             while (c2) {
3244                 if (!c2->isSlotObject && c2->receiver == receiver && c2->method() == method_index_absolute)
3245                     return nullptr;
3246                 c2 = c2->nextConnectionList;
3247             }
3248         }
3249         type &= Qt::UniqueConnection - 1;
3250     }
3251 
3252     QScopedPointer<QObjectPrivate::Connection> c(new QObjectPrivate::Connection);
3253     c->sender = s;
3254     c->signal_index = signal_index;
3255     c->receiver = r;
3256     c->method_relative = method_index;
3257     c->method_offset = method_offset;
3258     c->connectionType = type;
3259     c->isSlotObject = false;
3260     c->argumentTypes.store(types);
3261     c->nextConnectionList = 0;
3262     c->callFunction = callFunction;
3263 
3264     QObjectPrivate::get(s)->addConnection(signal_index, c.data());
3265 
3266     locker.unlock();
3267     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3268     if (smethod.isValid())
3269         s->connectNotify(smethod);
3270 
3271     return c.take();
3272 }
3273 
3274 /*!
3275     \internal
3276  */
3277 bool QMetaObject::disconnect(const QObject *sender, int signal_index,
3278                              const QObject *receiver, int method_index)
3279 {
3280     const QMetaObject *smeta = sender->metaObject();
3281     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3282     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3283                                           receiver, method_index, 0);
3284 }
3285 
3286 /*!
3287     \internal
3288 
3289 Disconnect a single signal connection.  If QMetaObject::connect() has been called
3290 multiple times for the same sender, signal_index, receiver and method_index only
3291 one of these connections will be removed.
3292  */
3293 bool QMetaObject::disconnectOne(const QObject *sender, int signal_index,
3294                                 const QObject *receiver, int method_index)
3295 {
3296     const QMetaObject *smeta = sender->metaObject();
3297     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3298     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3299                                           receiver, method_index, 0,
3300                                           QMetaObjectPrivate::DisconnectOne);
3301 }
3302 
3303 /*!
3304     \internal
3305     Helper function to remove the connection from the senders list and setting the receivers to 0
3306  */
3307 bool QMetaObjectPrivate::disconnectHelper(QObjectPrivate::Connection *c,
3308                                           const QObject *receiver, int method_index, void **slot,
3309                                           QMutex *senderMutex, DisconnectType disconnectType)
3310 {
3311     bool success = false;
3312     while (c) {
3313         if (c->receiver
3314             && (receiver == 0 || (c->receiver == receiver
3315                            && (method_index < 0 || (!c->isSlotObject && c->method() == method_index))
3316                            && (slot == 0 || (c->isSlotObject && c->slotObj->compare(slot)))))) {
3317             bool needToUnlock = false;
3318             QMutex *receiverMutex = 0;
3319             if (c->receiver) {
3320                 receiverMutex = signalSlotLock(c->receiver);
3321                 // need to relock this receiver and sender in the correct order
3322                 needToUnlock = QOrderedMutexLocker::relock(senderMutex, receiverMutex);
3323             }
3324             if (c->receiver) {
3325                 *c->prev = c->next;
3326                 if (c->next)
3327                     c->next->prev = c->prev;
3328             }
3329 
3330             if (needToUnlock)
3331                 receiverMutex->unlock();
3332 
3333             c->receiver = 0;
3334 
3335             if (c->isSlotObject) {
3336                 c->isSlotObject = false;
3337                 senderMutex->unlock();
3338                 c->slotObj->destroyIfLastRef();
3339                 senderMutex->lock();
3340             }
3341 
3342             success = true;
3343 
3344             if (disconnectType == DisconnectOne)
3345                 return success;
3346         }
3347         c = c->nextConnectionList;
3348     }
3349     return success;
3350 }
3351 
3352 /*!
3353     \internal
3354     Same as the QMetaObject::disconnect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3355  */
3356 bool QMetaObjectPrivate::disconnect(const QObject *sender,
3357                                     int signal_index, const QMetaObject *smeta,
3358                                     const QObject *receiver, int method_index, void **slot,
3359                                     DisconnectType disconnectType)
3360 {
3361     if (!sender)
3362         return false;
3363 
3364     QObject *s = const_cast<QObject *>(sender);
3365 
3366     QMutex *senderMutex = signalSlotLock(sender);
3367     QMutexLocker locker(senderMutex);
3368 
3369     QObjectPrivate *sd = QObjectPrivate::get(s);
3370     if (!sd->connections)
3371         return false;
3372 
3373     // prevent incoming connections changing the connections->receivers while unlocked
3374     ++sd->connections->inUse;
3375 
3376     bool success = false;
3377     if (signal_index < 0) {
3378         // remove from all connection lists
3379         for (int sig_index = -1; sig_index < sd->connections->signalVector.count(); ++sig_index) {
3380             QObjectPrivate::Connection *c = sd->connections->connectionsForSignal(sig_index).first;
3381             if (disconnectHelper(c, receiver, method_index, slot, senderMutex, disconnectType)) {
3382                 success = true;
3383                 sd->connections->dirty = true;
3384             }
3385         }
3386     } else if (signal_index < sd->connections->signalVector.count()) {
3387         QObjectPrivate::Connection *c = sd->connections->signalVector.at(signal_index).first;
3388         if (disconnectHelper(c, receiver, method_index, slot, senderMutex, disconnectType)) {
3389             success = true;
3390             sd->connections->dirty = true;
3391         }
3392     }
3393 
3394     --sd->connections->inUse;
3395     Q_ASSERT(sd->connections->inUse >= 0);
3396     if (sd->connections->orphaned && !sd->connections->inUse)
3397         delete sd->connections;
3398 
3399     locker.unlock();
3400     if (success) {
3401         QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3402         if (smethod.isValid())
3403             s->disconnectNotify(smethod);
3404     }
3405 
3406     return success;
3407 }
3408 
3409 /*!
3410     \fn void QMetaObject::connectSlotsByName(QObject *object)
3411 
3412     Searches recursively for all child objects of the given \a object, and connects
3413     matching signals from them to slots of \a object that follow the following form:
3414 
3415     \snippet code/src_corelib_kernel_qobject.cpp 33
3416 
3417     Let's assume our object has a child object of type \c{QPushButton} with
3418     the \l{QObject::objectName}{object name} \c{button1}. The slot to catch the
3419     button's \c{clicked()} signal would be:
3420 
3421     \snippet code/src_corelib_kernel_qobject.cpp 34
3422 
3423     If \a object itself has a properly set object name, its own signals are also
3424     connected to its respective slots.
3425 
3426     \sa QObject::setObjectName()
3427  */
3428 void QMetaObject::connectSlotsByName(QObject *o)
3429 {
3430     if (!o)
3431         return;
3432     const QMetaObject *mo = o->metaObject();
3433     Q_ASSERT(mo);
3434     const QObjectList list = // list of all objects to look for matching signals including...
3435             o->findChildren<QObject *>(QString()) // all children of 'o'...
3436             << o; // and the object 'o' itself
3437 
3438     // for each method/slot of o ...
3439     for (int i = 0; i < mo->methodCount(); ++i) {
3440         const QByteArray slotSignature = mo->method(i).methodSignature();
3441         const char *slot = slotSignature.constData();
3442         Q_ASSERT(slot);
3443 
3444         // ...that starts with "on_", ...
3445         if (slot[0] != 'o' || slot[1] != 'n' || slot[2] != '_')
3446             continue;
3447 
3448         // ...we check each object in our list, ...
3449         bool foundIt = false;
3450         for(int j = 0; j < list.count(); ++j) {
3451             const QObject *co = list.at(j);
3452             const QByteArray coName = co->objectName().toLatin1();
3453 
3454             // ...discarding those whose objectName is not fitting the pattern "on_<objectName>_...", ...
3455             if (coName.isEmpty() || qstrncmp(slot + 3, coName.constData(), coName.size()) || slot[coName.size()+3] != '_')
3456                 continue;
3457 
3458             const char *signal = slot + coName.size() + 4; // the 'signal' part of the slot name
3459 
3460             // ...for the presence of a matching signal "on_<objectName>_<signal>".
3461             const QMetaObject *smeta;
3462             int sigIndex = co->d_func()->signalIndex(signal, &smeta);
3463             if (sigIndex < 0) {
3464                 // if no exactly fitting signal (name + complete parameter type list) could be found
3465                 // look for just any signal with the correct name and at least the slot's parameter list.
3466                 // Note: if more than one of thoses signals exist, the one that gets connected is
3467                 // chosen 'at random' (order of declaration in source file)
3468                 QList<QByteArray> compatibleSignals;
3469                 const QMetaObject *smo = co->metaObject();
3470                 int sigLen = qstrlen(signal) - 1; // ignore the trailing ')'
3471                 for (int k = QMetaObjectPrivate::absoluteSignalCount(smo)-1; k >= 0; --k) {
3472                     const QMetaMethod method = QMetaObjectPrivate::signal(smo, k);
3473                     if (!qstrncmp(method.methodSignature().constData(), signal, sigLen)) {
3474                         smeta = method.enclosingMetaObject();
3475                         sigIndex = k;
3476                         compatibleSignals.prepend(method.methodSignature());
3477                     }
3478                 }
3479                 if (compatibleSignals.size() > 1)
3480                     qWarning() << "QMetaObject::connectSlotsByName: Connecting slot" << slot
3481                                << "with the first of the following compatible signals:" << compatibleSignals;
3482             }
3483 
3484             if (sigIndex < 0)
3485                 continue;
3486 
3487             // we connect it...
3488             if (Connection(QMetaObjectPrivate::connect(co, sigIndex, smeta, o, i))) {
3489                 foundIt = true;
3490                 // ...and stop looking for further objects with the same name.
3491                 // Note: the Designer will make sure each object name is unique in the above
3492                 // 'list' but other code may create two child objects with the same name. In
3493                 // this case one is chosen 'at random'.
3494                 break;
3495             }
3496         }
3497         if (foundIt) {
3498             // we found our slot, now skip all overloads
3499             while (mo->method(i + 1).attributes() & QMetaMethod::Cloned)
3500                   ++i;
3501         } else if (!(mo->method(i).attributes() & QMetaMethod::Cloned)) {
3502             // check if the slot has the following signature: "on_..._...(..."
3503             int iParen = slotSignature.indexOf('(');
3504             int iLastUnderscore = slotSignature.lastIndexOf('_', iParen-1);
3505             if (iLastUnderscore > 3)
3506                 qWarning("QMetaObject::connectSlotsByName: No matching signal for %s", slot);
3507         }
3508     }
3509 }
3510 
3511 /*!
3512     \internal
3513 
3514     \a signal must be in the signal index range (see QObjectPrivate::signalIndex()).
3515 */
3516 static void queued_activate(QObject *sender, int signal, QObjectPrivate::Connection *c, void **argv,
3517                             QMutexLocker &locker)
3518 {
3519     const int *argumentTypes = c->argumentTypes.load();
3520     if (!argumentTypes) {
3521         QMetaMethod m = QMetaObjectPrivate::signal(sender->metaObject(), signal);
3522         argumentTypes = queuedConnectionTypes(m.parameterTypes());
3523         if (!argumentTypes) // cannot queue arguments
3524             argumentTypes = &DIRECT_CONNECTION_ONLY;
3525         if (!c->argumentTypes.testAndSetOrdered(0, argumentTypes)) {
3526             if (argumentTypes != &DIRECT_CONNECTION_ONLY)
3527                 delete [] argumentTypes;
3528             argumentTypes = c->argumentTypes.load();
3529         }
3530     }
3531     if (argumentTypes == &DIRECT_CONNECTION_ONLY) // cannot activate
3532         return;
3533     int nargs = 1; // include return type
3534     while (argumentTypes[nargs-1])
3535         ++nargs;
3536     int *types = (int *) malloc(nargs*sizeof(int));
3537     Q_CHECK_PTR(types);
3538     void **args = (void **) malloc(nargs*sizeof(void *));
3539     Q_CHECK_PTR(args);
3540     types[0] = 0; // return type
3541     args[0] = 0; // return value
3542 
3543     if (nargs > 1) {
3544         for (int n = 1; n < nargs; ++n)
3545             types[n] = argumentTypes[n-1];
3546 
3547         locker.unlock();
3548         for (int n = 1; n < nargs; ++n)
3549             args[n] = QMetaType::create(types[n], argv[n]);
3550         locker.relock();
3551 
3552         if (!c->receiver) {
3553             locker.unlock();
3554             // we have been disconnected while the mutex was unlocked
3555             for (int n = 1; n < nargs; ++n)
3556                 QMetaType::destroy(types[n], args[n]);
3557             free(types);
3558             free(args);
3559             locker.relock();
3560             return;
3561         }
3562     }
3563 
3564     QMetaCallEvent *ev = c->isSlotObject ?
3565         new QMetaCallEvent(c->slotObj, sender, signal, nargs, types, args) :
3566         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction, sender, signal, nargs, types, args);
3567     QCoreApplication::postEvent(c->receiver, ev);
3568 }
3569 
3570 template <bool callbacks_enabled>
3571 void doActivate(QObject *sender, int signal_index, void **argv)
3572 {
3573     QObjectPrivate *sp = QObjectPrivate::get(sender);
3574 
3575     if (sp->blockSig)
3576         return;
3577 
3578     if (sp->isDeclarativeSignalConnected(signal_index)
3579             && QAbstractDeclarativeData::signalEmitted) {
3580         Q_TRACE(QMetaObject_activate_begin_declarative_signal, sender, signal_index);
3581         QAbstractDeclarativeData::signalEmitted(sp->declarativeData, sender,
3582                                                 signal_index, argv);
3583         Q_TRACE(QMetaObject_activate_end_declarative_signal, sender, signal_index);
3584     }
3585 
3586     bool isConnected = sp->isSignalConnected(signal_index, false);
3587 
3588     if (!isConnected
3589         && (!callbacks_enabled || !qt_signal_spy_callback_set)
3590         && !Q_TRACE_ENABLED(QMetaObject_activate_begin_signal)
3591         && !Q_TRACE_ENABLED(QMetaObject_activate_end_signal)) {
3592         // The possible declarative connection is done, and nothing else is connected, so:
3593         return;
3594     }
3595 
3596     void *empty_argv[] = { nullptr };
3597     if (!argv)
3598         argv = empty_argv;
3599 
3600     if (callbacks_enabled && qt_signal_spy_callback_set->signal_begin_callback != nullptr)
3601         qt_signal_spy_callback_set->signal_begin_callback(sender, signal_index, argv);
3602     Q_TRACE(QMetaObject_activate_begin_signal, sender, signal_index);
3603 
3604     {
3605     QMutexLocker locker(signalSlotLock(sender));
3606     struct ConnectionDataRef {
3607         QObjectPrivate::ConnectionData *connections;
3608         ConnectionDataRef(QObjectPrivate::ConnectionData *connections) : connections(connections)
3609         {
3610             if (connections)
3611                 ++connections->inUse;
3612         }
3613         ~ConnectionDataRef()
3614         {
3615             if (!connections)
3616                 return;
3617 
3618             --connections->inUse;
3619             Q_ASSERT(connections->inUse >= 0);
3620             if (connections->orphaned) {
3621                 if (!connections->inUse)
3622                     delete connections;
3623             }
3624         }
3625 
3626         QObjectPrivate::ConnectionData *operator->() const { return connections; }
3627     };
3628     Q_ASSERT(sp->connections);
3629     ConnectionDataRef connections = sp->connections;
3630 
3631     const QObjectPrivate::ConnectionList *list;
3632     if (signal_index < connections->signalVector.count())
3633         list = &connections->signalVector.at(signal_index);
3634     else
3635         list = &connections->allsignals;
3636 
3637     Qt::HANDLE currentThreadId = QThread::currentThreadId();
3638 
3639     do {
3640         QObjectPrivate::Connection *c = list->first;
3641         if (!c) continue;
3642         // We need to check against last here to ensure that signals added
3643         // during the signal emission are not emitted in this emission.
3644         QObjectPrivate::Connection *last = list->last;
3645 
3646         do {
3647             if (!c->receiver)
3648                 continue;
3649 
3650             QObject * const receiver = c->receiver;
3651             const bool receiverInSameThread = currentThreadId == QObjectPrivate::get(receiver)->threadData->threadId.load();
3652 
3653             // determine if this connection should be sent immediately or
3654             // put into the event queue
3655             if ((c->connectionType == Qt::AutoConnection && !receiverInSameThread)
3656                 || (c->connectionType == Qt::QueuedConnection)) {
3657                 queued_activate(sender, signal_index, c, argv, locker);
3658                 continue;
3659 #if QT_CONFIG(thread)
3660             } else if (c->connectionType == Qt::BlockingQueuedConnection) {
3661                 if (receiverInSameThread) {
3662                     qWarning("Qt: Dead lock detected while activating a BlockingQueuedConnection: "
3663                     "Sender is %s(%p), receiver is %s(%p)",
3664                     sender->metaObject()->className(), sender,
3665                     receiver->metaObject()->className(), receiver);
3666                 }
3667                 QSemaphore semaphore;
3668                 QMetaCallEvent *ev = c->isSlotObject ?
3669                     new QMetaCallEvent(c->slotObj, sender, signal_index, 0, 0, argv, &semaphore) :
3670                     new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction, sender, signal_index, 0, 0, argv, &semaphore);
3671                 QCoreApplication::postEvent(receiver, ev);
3672                 locker.unlock();
3673                 semaphore.acquire();
3674                 locker.relock();
3675                 continue;
3676 #endif
3677             }
3678 
3679             QObjectPrivate::Sender senderData(receiverInSameThread ? receiver : nullptr, sender, signal_index);
3680 
3681             if (c->isSlotObject) {
3682                 c->slotObj->ref();
3683                 QScopedPointer<QtPrivate::QSlotObjectBase, QSlotObjectBaseDeleter> obj(c->slotObj);
3684                 locker.unlock();
3685                 Q_TRACE(QMetaObject_activate_begin_slot_functor, obj.data());
3686                 obj->call(receiver, argv);
3687                 Q_TRACE(QMetaObject_activate_end_slot_functor, obj.data());
3688 
3689                 // Make sure the slot object gets destroyed before the mutex is locked again, as the
3690                 // destructor of the slot object might also lock a mutex from the signalSlotLock() mutex pool,
3691                 // and that would deadlock if the pool happens to return the same mutex.
3692                 obj.reset();
3693 
3694                 locker.relock();
3695             } else if (c->callFunction && c->method_offset <= receiver->metaObject()->methodOffset()) {
3696                 //we compare the vtable to make sure we are not in the destructor of the object.
3697                 const int method_relative = c->method_relative;
3698                 const auto callFunction = c->callFunction;
3699                 locker.unlock();
3700                 const int methodIndex = (Q_HAS_TRACEPOINTS || callbacks_enabled) ? c->method() : 0;
3701                 if (callbacks_enabled && qt_signal_spy_callback_set->slot_begin_callback != nullptr)
3702                     qt_signal_spy_callback_set->slot_begin_callback(receiver, methodIndex, argv);
3703                 Q_TRACE(QMetaObject_activate_begin_slot, receiver, methodIndex);
3704 
3705                 callFunction(receiver, QMetaObject::InvokeMetaMethod, method_relative, argv);
3706 
3707                 Q_TRACE(QMetaObject_activate_end_slot, receiver, methodIndex);
3708                 if (callbacks_enabled && qt_signal_spy_callback_set->slot_end_callback != nullptr)
3709                     qt_signal_spy_callback_set->slot_end_callback(receiver, methodIndex);
3710                 locker.relock();
3711             } else {
3712                 const int method = c->method_relative + c->method_offset;
3713                 locker.unlock();
3714 
3715                 if (callbacks_enabled && qt_signal_spy_callback_set->slot_begin_callback != nullptr) {
3716                     qt_signal_spy_callback_set->slot_begin_callback(receiver, method, argv);
3717                 }
3718                 Q_TRACE(QMetaObject_activate_begin_slot, receiver, method);
3719 
3720                 QMetaObject::metacall(receiver, QMetaObject::InvokeMetaMethod, method, argv);
3721 
3722                 Q_TRACE(QMetaObject_activate_end_slot, receiver, method);
3723                 if (callbacks_enabled && qt_signal_spy_callback_set->slot_end_callback != nullptr)
3724                     qt_signal_spy_callback_set->slot_end_callback(receiver, method);
3725 
3726                 locker.relock();
3727             }
3728 
3729             if (connections->orphaned)
3730                 break;
3731         } while (c != last && (c = c->nextConnectionList) != 0);
3732 
3733         if (connections->orphaned)
3734             break;
3735     } while (list != &connections->allsignals &&
3736         //start over for all signals;
3737         ((list = &connections->allsignals), true));
3738 
3739     }
3740 
3741     if (callbacks_enabled && qt_signal_spy_callback_set->signal_end_callback != nullptr)
3742         qt_signal_spy_callback_set->signal_end_callback(sender, signal_index);
3743     Q_TRACE(QMetaObject_activate_end_signal, sender, signal_index);
3744 
3745 }
3746 
3747 /*!
3748     \internal
3749  */
3750 void QMetaObject::activate(QObject *sender, const QMetaObject *m, int local_signal_index,
3751                            void **argv)
3752 {
3753     int signal_index = local_signal_index + QMetaObjectPrivate::signalOffset(m);
3754 
3755     if (Q_UNLIKELY(qt_signal_spy_callback_set))
3756         doActivate<true>(sender, signal_index, argv);
3757     else
3758         doActivate<false>(sender, signal_index, argv);
3759 }
3760 
3761 /*!
3762     \internal
3763  */
3764 void QMetaObject::activate(QObject *sender, int signalOffset, int local_signal_index, void **argv)
3765 {
3766     int signal_index = signalOffset + local_signal_index;
3767 
3768     if (Q_UNLIKELY(qt_signal_spy_callback_set))
3769         doActivate<true>(sender, signal_index, argv);
3770     else
3771         doActivate<false>(sender, signal_index, argv);
3772  }
3773 
3774 /*!
3775     \internal
3776    signal_index comes from indexOfMethod()
3777 */
3778 void QMetaObject::activate(QObject *sender, int signal_index, void **argv)
3779 {
3780     const QMetaObject *mo = sender->metaObject();
3781     while (mo->methodOffset() > signal_index)
3782         mo = mo->superClass();
3783     activate(sender, mo, signal_index - mo->methodOffset(), argv);
3784 }
3785 
3786 /*!
3787     \internal
3788     Returns the signal index used in the internal connections->receivers vector.
3789 
3790     It is different from QMetaObject::indexOfSignal():  indexOfSignal is the same as indexOfMethod
3791     while QObjectPrivate::signalIndex is smaller because it doesn't give index to slots.
3792 
3793     If \a meta is not 0, it is set to the meta-object where the signal was found.
3794 */
3795 int QObjectPrivate::signalIndex(const char *signalName,
3796                                 const QMetaObject **meta) const
3797 {
3798     Q_Q(const QObject);
3799     const QMetaObject *base = q->metaObject();
3800     Q_ASSERT(QMetaObjectPrivate::get(base)->revision >= 7);
3801     QArgumentTypeArray types;
3802     QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signalName, types);
3803     int relative_index = QMetaObjectPrivate::indexOfSignalRelative(
3804             &base, name, types.size(), types.constData());
3805     if (relative_index < 0)
3806         return relative_index;
3807     relative_index = QMetaObjectPrivate::originalClone(base, relative_index);
3808     if (meta)
3809         *meta = base;
3810     return relative_index + QMetaObjectPrivate::signalOffset(base);
3811 }
3812 
3813 /*****************************************************************************
3814   Properties
3815  *****************************************************************************/
3816 
3817 #ifndef QT_NO_PROPERTIES
3818 
3819 /*!
3820   Sets the value of the object's \a name property to \a value.
3821 
3822   If the property is defined in the class using Q_PROPERTY then
3823   true is returned on success and false otherwise. If the property
3824   is not defined using Q_PROPERTY, and therefore not listed in the
3825   meta-object, it is added as a dynamic property and false is returned.
3826 
3827   Information about all available properties is provided through the
3828   metaObject() and dynamicPropertyNames().
3829 
3830   Dynamic properties can be queried again using property() and can be
3831   removed by setting the property value to an invalid QVariant.
3832   Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent
3833   to be sent to the object.
3834 
3835   \b{Note:} Dynamic properties starting with "_q_" are reserved for internal
3836   purposes.
3837 
3838   \sa property(), metaObject(), dynamicPropertyNames(), QMetaProperty::write()
3839 */
3840 bool QObject::setProperty(const char *name, const QVariant &value)
3841 {
3842     Q_D(QObject);
3843     const QMetaObject* meta = metaObject();
3844     if (!name || !meta)
3845         return false;
3846 
3847     int id = meta->indexOfProperty(name);
3848     if (id < 0) {
3849         if (!d->extraData)
3850             d->extraData = new QObjectPrivate::ExtraData;
3851 
3852         const int idx = d->extraData->propertyNames.indexOf(name);
3853 
3854         if (!value.isValid()) {
3855             if (idx == -1)
3856                 return false;
3857             d->extraData->propertyNames.removeAt(idx);
3858             d->extraData->propertyValues.removeAt(idx);
3859         } else {
3860             if (idx == -1) {
3861                 d->extraData->propertyNames.append(name);
3862                 d->extraData->propertyValues.append(value);
3863             } else {
3864                 if (value.userType() == d->extraData->propertyValues.at(idx).userType()
3865                         && value == d->extraData->propertyValues.at(idx))
3866                     return false;
3867                 d->extraData->propertyValues[idx] = value;
3868             }
3869         }
3870 
3871         QDynamicPropertyChangeEvent ev(name);
3872         QCoreApplication::sendEvent(this, &ev);
3873 
3874         return false;
3875     }
3876     QMetaProperty p = meta->property(id);
3877 #ifndef QT_NO_DEBUG
3878     if (!p.isWritable())
3879         qWarning("%s::setProperty: Property \"%s\" invalid,"
3880                  " read-only or does not exist", metaObject()->className(), name);
3881 #endif
3882     return p.write(this, value);
3883 }
3884 
3885 /*!
3886   Returns the value of the object's \a name property.
3887 
3888   If no such property exists, the returned variant is invalid.
3889 
3890   Information about all available properties is provided through the
3891   metaObject() and dynamicPropertyNames().
3892 
3893   \sa setProperty(), QVariant::isValid(), metaObject(), dynamicPropertyNames()
3894 */
3895 QVariant QObject::property(const char *name) const
3896 {
3897     Q_D(const QObject);
3898     const QMetaObject* meta = metaObject();
3899     if (!name || !meta)
3900         return QVariant();
3901 
3902     int id = meta->indexOfProperty(name);
3903     if (id < 0) {
3904         if (!d->extraData)
3905             return QVariant();
3906         const int i = d->extraData->propertyNames.indexOf(name);
3907         return d->extraData->propertyValues.value(i);
3908     }
3909     QMetaProperty p = meta->property(id);
3910 #ifndef QT_NO_DEBUG
3911     if (!p.isReadable())
3912         qWarning("%s::property: Property \"%s\" invalid or does not exist",
3913                  metaObject()->className(), name);
3914 #endif
3915     return p.read(this);
3916 }
3917 
3918 /*!
3919     \since 4.2
3920 
3921     Returns the names of all properties that were dynamically added to
3922     the object using setProperty().
3923 */
3924 QList<QByteArray> QObject::dynamicPropertyNames() const
3925 {
3926     Q_D(const QObject);
3927     if (d->extraData)
3928         return d->extraData->propertyNames;
3929     return QList<QByteArray>();
3930 }
3931 
3932 #endif // QT_NO_PROPERTIES
3933 
3934 
3935 /*****************************************************************************
3936   QObject debugging output routines.
3937  *****************************************************************************/
3938 
3939 static void dumpRecursive(int level, const QObject *object)
3940 {
3941     if (object) {
3942         QByteArray buf;
3943         buf.fill(' ', level / 2 * 8);
3944         if (level % 2)
3945             buf += "    ";
3946         QString name = object->objectName();
3947         QString flags = QLatin1String("");
3948 #if 0
3949         if (qApp->focusWidget() == object)
3950             flags += 'F';
3951         if (object->isWidgetType()) {
3952             QWidget * w = (QWidget *)object;
3953             if (w->isVisible()) {
3954                 QString t("<%1,%2,%3,%4>");
3955                 flags += t.arg(w->x()).arg(w->y()).arg(w->width()).arg(w->height());
3956             } else {
3957                 flags += 'I';
3958             }
3959         }
3960 #endif
3961         qDebug("%s%s::%s %s", (const char*)buf, object->metaObject()->className(), name.toLocal8Bit().data(),
3962                flags.toLatin1().data());
3963         QObjectList children = object->children();
3964         if (!children.isEmpty()) {
3965             for (int i = 0; i < children.size(); ++i)
3966                 dumpRecursive(level+1, children.at(i));
3967         }
3968     }
3969 }
3970 
3971 /*!
3972     \overload
3973     \obsolete
3974 
3975     Dumps a tree of children to the debug output.
3976 
3977     \sa dumpObjectInfo()
3978 */
3979 
3980 void QObject::dumpObjectTree()
3981 {
3982     const_cast<const QObject *>(this)->dumpObjectTree();
3983 }
3984 
3985 /*!
3986     Dumps a tree of children to the debug output.
3987 
3988     \note before Qt 5.9, this function was not const.
3989 
3990     \sa dumpObjectInfo()
3991 */
3992 
3993 void QObject::dumpObjectTree() const
3994 {
3995     dumpRecursive(0, this);
3996 }
3997 
3998 /*!
3999     \overload
4000     \obsolete
4001 
4002     Dumps information about signal connections, etc. for this object
4003     to the debug output.
4004 
4005     \sa dumpObjectTree()
4006 */
4007 
4008 void QObject::dumpObjectInfo()
4009 {
4010     const_cast<const QObject *>(this)->dumpObjectInfo();
4011 }
4012 
4013 /*!
4014     Dumps information about signal connections, etc. for this object
4015     to the debug output.
4016 
4017     \note before Qt 5.9, this function was not const.
4018 
4019     \sa dumpObjectTree()
4020 */
4021 
4022 void QObject::dumpObjectInfo() const
4023 {
4024     qDebug("OBJECT %s::%s", metaObject()->className(),
4025            objectName().isEmpty() ? "unnamed" : objectName().toLocal8Bit().data());
4026 
4027     Q_D(const QObject);
4028     QMutexLocker locker(signalSlotLock(this));
4029 
4030     // first, look for connections where this object is the sender
4031     qDebug("  SIGNALS OUT");
4032 
4033     if (d->connections && d->connections->signalVector.count()) {
4034         for (int signal_index = 0; signal_index < d->connections->signalVector.count(); ++signal_index) {
4035             const QMetaMethod signal = QMetaObjectPrivate::signal(metaObject(), signal_index);
4036             qDebug("        signal: %s", signal.methodSignature().constData());
4037 
4038             // receivers
4039             const QObjectPrivate::Connection *c = d->connections->signalVector.at(signal_index).first;
4040             while (c) {
4041                 if (!c->receiver) {
4042                     qDebug("          <Disconnected receiver>");
4043                     c = c->nextConnectionList;
4044                     continue;
4045                 }
4046                 if (c->isSlotObject) {
4047                     qDebug("          <functor or function pointer>");
4048                     c = c->nextConnectionList;
4049                     continue;
4050                 }
4051                 const QMetaObject *receiverMetaObject = c->receiver->metaObject();
4052                 const QMetaMethod method = receiverMetaObject->method(c->method());
4053                 qDebug("          --> %s::%s %s",
4054                        receiverMetaObject->className(),
4055                        c->receiver->objectName().isEmpty() ? "unnamed" : qPrintable(c->receiver->objectName()),
4056                        method.methodSignature().constData());
4057                 c = c->nextConnectionList;
4058             }
4059         }
4060     } else {
4061         qDebug( "        <None>" );
4062     }
4063 
4064     // now look for connections where this object is the receiver
4065     qDebug("  SIGNALS IN");
4066 
4067     if (d->connections && d->connections->senders) {
4068         for (QObjectPrivate::Connection *s = d->connections->senders; s; s = s->next) {
4069             QByteArray slotName = QByteArrayLiteral("<unknown>");
4070             if (!s->isSlotObject) {
4071                 const QMetaMethod slot = metaObject()->method(s->method());
4072                 slotName = slot.methodSignature();
4073             }
4074             qDebug("          <-- %s::%s %s",
4075                    s->sender->metaObject()->className(),
4076                    s->sender->objectName().isEmpty() ? "unnamed" : qPrintable(s->sender->objectName()),
4077                    slotName.constData());
4078         }
4079     } else {
4080         qDebug("        <None>");
4081     }
4082 }
4083 
4084 #ifndef QT_NO_USERDATA
4085 /*!
4086     \internal
4087  */
4088 uint QObject::registerUserData()
4089 {
4090     static int user_data_registration = 0;
4091     return user_data_registration++;
4092 }
4093 
4094 /*!
4095     \internal
4096  */
4097 QObjectUserData::~QObjectUserData()
4098 {
4099 }
4100 
4101 /*!
4102     \internal
4103  */
4104 void QObject::setUserData(uint id, QObjectUserData* data)
4105 {
4106     Q_D(QObject);
4107     if (!d->extraData)
4108         d->extraData = new QObjectPrivate::ExtraData;
4109 
4110     if (d->extraData->userData.size() <= (int) id)
4111         d->extraData->userData.resize((int) id + 1);
4112     d->extraData->userData[id] = data;
4113 }
4114 
4115 /*!
4116     \internal
4117  */
4118 QObjectUserData* QObject::userData(uint id) const
4119 {
4120     Q_D(const QObject);
4121     if (!d->extraData)
4122         return 0;
4123     if ((int)id < d->extraData->userData.size())
4124         return d->extraData->userData.at(id);
4125     return 0;
4126 }
4127 
4128 #endif // QT_NO_USERDATA
4129 
4130 
4131 #ifndef QT_NO_DEBUG_STREAM
4132 QDebug operator<<(QDebug dbg, const QObject *o)
4133 {
4134     QDebugStateSaver saver(dbg);
4135     if (!o)
4136         return dbg << "QObject(0x0)";
4137     dbg.nospace() << o->metaObject()->className() << '(' << (const void *)o;
4138     if (!o->objectName().isEmpty())
4139         dbg << ", name = " << o->objectName();
4140     dbg << ')';
4141     return dbg;
4142 }
4143 #endif
4144 
4145 /*!
4146     \macro Q_CLASSINFO(Name, Value)
4147     \relates QObject
4148 
4149     This macro associates extra information to the class, which is available
4150     using QObject::metaObject(). Qt makes only limited use of this feature, in
4151     the \l{Active Qt}, \l{Qt D-Bus} and \l{Qt QML module}{Qt QML}.
4152 
4153     The extra information takes the form of a \a Name string and a \a Value
4154     literal string.
4155 
4156     Example:
4157 
4158     \snippet code/src_corelib_kernel_qobject.cpp 35
4159 
4160     \sa QMetaObject::classInfo()
4161     \sa QAxFactory
4162     \sa {Using Qt D-Bus Adaptors}
4163     \sa {Extending QML}
4164 */
4165 
4166 /*!
4167     \macro Q_INTERFACES(...)
4168     \relates QObject
4169 
4170     This macro tells Qt which interfaces the class implements. This
4171     is used when implementing plugins.
4172 
4173     Example:
4174 
4175     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 1
4176     \dots
4177     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 3
4178 
4179     See the \l{tools/plugandpaint/plugins/basictools}{Plug & Paint
4180     Basic Tools} example for details.
4181 
4182     \sa Q_DECLARE_INTERFACE(), Q_PLUGIN_METADATA(), {How to Create Qt Plugins}
4183 */
4184 
4185 /*!
4186     \macro Q_PROPERTY(...)
4187     \relates QObject
4188 
4189     This macro is used for declaring properties in classes that
4190     inherit QObject. Properties behave like class data members, but
4191     they have additional features accessible through the \l
4192     {Meta-Object System}.
4193 
4194     \snippet code/doc_src_properties.cpp 0
4195 
4196     The property name and type and the \c READ function are required.
4197     The type can be any type supported by QVariant, or it can be a
4198     user-defined type.  The other items are optional, but a \c WRITE
4199     function is common.  The attributes default to true except \c USER,
4200     which defaults to false.
4201 
4202     For example:
4203 
4204     \snippet code/src_corelib_kernel_qobject.cpp 37
4205 
4206     For more details about how to use this macro, and a more detailed
4207     example of its use, see the discussion on \l {Qt's Property System}.
4208 
4209     \sa {Qt's Property System}
4210 */
4211 
4212 /*!
4213     \macro Q_ENUMS(...)
4214     \relates QObject
4215     \obsolete
4216 
4217     This macro registers one or several enum types to the meta-object
4218     system.
4219 
4220     For example:
4221 
4222     \snippet code/src_corelib_kernel_qobject.cpp 38
4223 
4224     If you want to register an enum that is declared in another class,
4225     the enum must be fully qualified with the name of the class
4226     defining it. In addition, the class \e defining the enum has to
4227     inherit QObject as well as declare the enum using Q_ENUMS().
4228 
4229     In new code, you should prefer the use of the Q_ENUM() macro, which makes the
4230     type available also to the meta type system.
4231     For instance, QMetaEnum::fromType() will not work with types declared with Q_ENUMS().
4232 
4233     \sa {Qt's Property System}
4234 */
4235 
4236 /*!
4237     \macro Q_FLAGS(...)
4238     \relates QObject
4239     \obsolete
4240 
4241     This macro registers one or several \l{QFlags}{flags types} with the
4242     meta-object system. It is typically used in a class definition to declare
4243     that values of a given enum can be used as flags and combined using the
4244     bitwise OR operator.
4245 
4246     \note This macro takes care of registering individual flag values
4247     with the meta-object system, so it is unnecessary to use Q_ENUMS()
4248     in addition to this macro.
4249 
4250     In new code, you should prefer the use of the Q_FLAG() macro, which makes the
4251     type available also to the meta type system.
4252 
4253     \sa {Qt's Property System}
4254 */
4255 
4256 /*!
4257     \macro Q_ENUM(...)
4258     \relates QObject
4259     \since 5.5
4260 
4261     This macro registers an enum type with the meta-object system.
4262     It must be placed after the enum declaration in a class that has the Q_OBJECT or the
4263     Q_GADGET macro. For namespaces use \l Q_ENUM_NS() instead.
4264 
4265     For example:
4266 
4267     \snippet code/src_corelib_kernel_qobject.cpp 38
4268 
4269     Enumerations that are declared with Q_ENUM have their QMetaEnum registered in the
4270     enclosing QMetaObject. You can also use QMetaEnum::fromType() to get the QMetaEnum.
4271 
4272     Registered enumerations are automatically registered also to the Qt meta
4273     type system, making them known to QMetaType without the need to use
4274     Q_DECLARE_METATYPE(). This will enable useful features; for example, if used
4275     in a QVariant, you can convert them to strings. Likewise, passing them to
4276     QDebug will print out their names.
4277 
4278     \sa {Qt's Property System}
4279 */
4280 
4281 
4282 /*!
4283     \macro Q_FLAG(...)
4284     \relates QObject
4285     \since 5.5
4286 
4287     This macro registers a single \l{QFlags}{flags type} with the
4288     meta-object system. It is typically used in a class definition to declare
4289     that values of a given enum can be used as flags and combined using the
4290     bitwise OR operator. For namespaces use \l Q_FLAG_NS() instead.
4291 
4292     The macro must be placed after the enum declaration.
4293 
4294     For example, in QLibrary, the \l{QLibrary::LoadHints}{LoadHints} flag is
4295     declared in the following way:
4296 
4297     \snippet code/src_corelib_kernel_qobject.cpp 39
4298 
4299     The declaration of the flags themselves is performed in the public section
4300     of the QLibrary class itself, using the \l Q_DECLARE_FLAGS() macro.
4301 
4302     \note The Q_FLAG macro takes care of registering individual flag values
4303     with the meta-object system, so it is unnecessary to use Q_ENUM()
4304     in addition to this macro.
4305 
4306     \sa {Qt's Property System}
4307 */
4308 
4309 /*!
4310     \macro Q_ENUM_NS(...)
4311     \relates QObject
4312     \since 5.8
4313 
4314     This macro registers an enum type with the meta-object system.
4315     It must be placed after the enum declaration in a namespace that
4316     has the Q_NAMESPACE macro. It is the same as \l Q_ENUM but in a
4317     namespace.
4318 
4319     Enumerations that are declared with Q_ENUM_NS have their QMetaEnum
4320     registered in the enclosing QMetaObject. You can also use
4321     QMetaEnum::fromType() to get the QMetaEnum.
4322 
4323     Registered enumerations are automatically registered also to the Qt meta
4324     type system, making them known to QMetaType without the need to use
4325     Q_DECLARE_METATYPE(). This will enable useful features; for example, if
4326     used in a QVariant, you can convert them to strings. Likewise, passing them
4327     to QDebug will print out their names.
4328 
4329     \sa {Qt's Property System}
4330 */
4331 
4332 
4333 /*!
4334     \macro Q_FLAG_NS(...)
4335     \relates QObject
4336     \since 5.8
4337 
4338     This macro registers a single \l{QFlags}{flags type} with the
4339     meta-object system. It is used in a namespace that has the
4340     Q_NAMESPACE macro, to declare that values of a given enum can be
4341     used as flags and combined using the bitwise OR operator.
4342     It is the same as \l Q_FLAG but in a namespace.
4343 
4344     The macro must be placed after the enum declaration.
4345 
4346     \note The Q_FLAG_NS macro takes care of registering individual flag
4347     values with the meta-object system, so it is unnecessary to use
4348     Q_ENUM_NS() in addition to this macro.
4349 
4350     \sa {Qt's Property System}
4351 */
4352 
4353 
4354 /*!
4355     \macro Q_OBJECT
4356     \relates QObject
4357 
4358     The Q_OBJECT macro must appear in the private section of a class
4359     definition that declares its own signals and slots or that uses
4360     other services provided by Qt's meta-object system.
4361 
4362     For example:
4363 
4364     \snippet signalsandslots/signalsandslots.h 1
4365     \codeline
4366     \snippet signalsandslots/signalsandslots.h 2
4367     \snippet signalsandslots/signalsandslots.h 3
4368 
4369     \note This macro requires the class to be a subclass of QObject. Use
4370     Q_GADGET instead of Q_OBJECT to enable the meta object system's support
4371     for enums in a class that is not a QObject subclass.
4372 
4373     \sa {Meta-Object System}, {Signals and Slots}, {Qt's Property System}
4374 */
4375 
4376 /*!
4377     \macro Q_GADGET
4378     \relates QObject
4379 
4380     The Q_GADGET macro is a lighter version of the Q_OBJECT macro for classes
4381     that do not inherit from QObject but still want to use some of the
4382     reflection capabilities offered by QMetaObject. Just like the Q_OBJECT
4383     macro, it must appear in the private section of a class definition.
4384 
4385     Q_GADGETs can have Q_ENUM, Q_PROPERTY and Q_INVOKABLE, but they cannot have
4386     signals or slots
4387 
4388     Q_GADGET makes a class member, \c{staticMetaObject}, available.
4389     \c{staticMetaObject} is of type QMetaObject and provides access to the
4390     enums declared with Q_ENUMS.
4391 */
4392 
4393 /*!
4394     \macro Q_NAMESPACE
4395     \relates QObject
4396     \since 5.8
4397 
4398     The Q_NAMESPACE macro can be used to add QMetaObject capabilities
4399     to a namespace.
4400 
4401     Q_NAMESPACEs can have Q_CLASSINFO, Q_ENUM_NS, Q_FLAG_NS, but they
4402     cannot have Q_ENUM, Q_FLAG, Q_PROPERTY, Q_INVOKABLE, signals nor slots.
4403 
4404     Q_NAMESPACE makes an external variable, \c{staticMetaObject}, available.
4405     \c{staticMetaObject} is of type QMetaObject and provides access to the
4406     enums declared with Q_ENUM_NS/Q_FLAG_NS.
4407 */
4408 
4409 /*!
4410     \macro Q_SIGNALS
4411     \relates QObject
4412 
4413     Use this macro to replace the \c signals keyword in class
4414     declarations, when you want to use Qt Signals and Slots with a
4415     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4416 
4417     The macro is normally used when \c no_keywords is specified with
4418     the \c CONFIG variable in the \c .pro file, but it can be used
4419     even when \c no_keywords is \e not specified.
4420 */
4421 
4422 /*!
4423     \macro Q_SIGNAL
4424     \relates QObject
4425 
4426     This is an additional macro that allows you to mark a single
4427     function as a signal. It can be quite useful, especially when you
4428     use a 3rd-party source code parser which doesn't understand a \c
4429     signals or \c Q_SIGNALS groups.
4430 
4431     Use this macro to replace the \c signals keyword in class
4432     declarations, when you want to use Qt Signals and Slots with a
4433     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4434 
4435     The macro is normally used when \c no_keywords is specified with
4436     the \c CONFIG variable in the \c .pro file, but it can be used
4437     even when \c no_keywords is \e not specified.
4438 */
4439 
4440 /*!
4441     \macro Q_SLOTS
4442     \relates QObject
4443 
4444     Use this macro to replace the \c slots keyword in class
4445     declarations, when you want to use Qt Signals and Slots with a
4446     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4447 
4448     The macro is normally used when \c no_keywords is specified with
4449     the \c CONFIG variable in the \c .pro file, but it can be used
4450     even when \c no_keywords is \e not specified.
4451 */
4452 
4453 /*!
4454     \macro Q_SLOT
4455     \relates QObject
4456 
4457     This is an additional macro that allows you to mark a single
4458     function as a slot. It can be quite useful, especially when you
4459     use a 3rd-party source code parser which doesn't understand a \c
4460     slots or \c Q_SLOTS groups.
4461 
4462     Use this macro to replace the \c slots keyword in class
4463     declarations, when you want to use Qt Signals and Slots with a
4464     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4465 
4466     The macro is normally used when \c no_keywords is specified with
4467     the \c CONFIG variable in the \c .pro file, but it can be used
4468     even when \c no_keywords is \e not specified.
4469 */
4470 
4471 /*!
4472     \macro Q_EMIT
4473     \relates QObject
4474 
4475     Use this macro to replace the \c emit keyword for emitting
4476     signals, when you want to use Qt Signals and Slots with a
4477     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4478 
4479     The macro is normally used when \c no_keywords is specified with
4480     the \c CONFIG variable in the \c .pro file, but it can be used
4481     even when \c no_keywords is \e not specified.
4482 */
4483 
4484 /*!
4485     \macro Q_INVOKABLE
4486     \relates QObject
4487 
4488     Apply this macro to declarations of member functions to allow them to
4489     be invoked via the meta-object system. The macro is written before
4490     the return type, as shown in the following example:
4491 
4492     \snippet qmetaobject-invokable/window.h Window class with invokable method
4493 
4494     The \c invokableMethod() function is marked up using Q_INVOKABLE, causing
4495     it to be registered with the meta-object system and enabling it to be
4496     invoked using QMetaObject::invokeMethod().
4497     Since \c normalMethod() function is not registered in this way, it cannot
4498     be invoked using QMetaObject::invokeMethod().
4499 
4500     If an invokable member function returns a pointer to a QObject or a
4501     subclass of QObject and it is invoked from QML, special ownership rules
4502     apply. See \l{qtqml-cppintegration-data.html}{Data Type Conversion Between QML and C++}
4503     for more information.
4504 */
4505 
4506 /*!
4507     \macro Q_REVISION
4508     \relates QObject
4509 
4510     Apply this macro to declarations of member functions to tag them with a
4511     revision number in the meta-object system. The macro is written before
4512     the return type, as shown in the following example:
4513 
4514     \snippet qmetaobject-revision/window.h Window class with revision
4515 
4516     This is useful when using the meta-object system to dynamically expose
4517     objects to another API, as you can match the version expected by multiple
4518     versions of the other API. Consider the following simplified example:
4519 
4520     \snippet qmetaobject-revision/main.cpp Window class using revision
4521 
4522     Using the same Window class as the previous example, the newProperty and
4523     newMethod would only be exposed in this code when the expected version is
4524     1 or greater.
4525 
4526     Since all methods are considered to be in revision 0 if untagged, a tag
4527     of Q_REVISION(0) is invalid and ignored.
4528 
4529     This tag is not used by the meta-object system itself. Currently this is only
4530     used by the QtQml module.
4531 
4532     For a more generic string tag, see \l QMetaMethod::tag()
4533 
4534     \sa QMetaMethod::revision()
4535 */
4536 
4537 /*!
4538     \macro Q_SET_OBJECT_NAME(Object)
4539     \relates QObject
4540     \since 5.0
4541 
4542     This macro assigns \a Object the objectName "Object".
4543 
4544     It doesn't matter whether \a Object is a pointer or not, the
4545     macro figures that out by itself.
4546 
4547     \sa QObject::objectName()
4548 */
4549 
4550 /*!
4551     \macro QT_NO_NARROWING_CONVERSIONS_IN_CONNECT
4552     \relates QObject
4553     \since 5.8
4554 
4555     Defining this macro will disable narrowing and floating-point-to-integral
4556     conversions between the arguments carried by a signal and the arguments
4557     accepted by a slot, when the signal and the slot are connected using the
4558     PMF-based syntax.
4559 
4560     \sa QObject::connect
4561 */
4562 
4563 /*!
4564     \typedef QObjectList
4565     \relates QObject
4566 
4567     Synonym for QList<QObject *>.
4568 */
4569 
4570 void qDeleteInEventHandler(QObject *o)
4571 {
4572     delete o;
4573 }
4574 
4575 /*!
4576     \fn template<typename PointerToMemberFunction> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)
4577     \overload connect()
4578     \threadsafe
4579 
4580     Creates a connection of the given \a type from the \a signal in
4581     the \a sender object to the \a method in the \a receiver object.
4582     Returns a handle to the connection that can be used to disconnect
4583     it later.
4584 
4585     The signal must be a function declared as a signal in the header.
4586     The slot function can be any member function that can be connected
4587     to the signal.
4588     A slot can be connected to a given signal if the signal has at
4589     least as many arguments as the slot, and there is an implicit
4590     conversion between the types of the corresponding arguments in the
4591     signal and the slot.
4592 
4593     Example:
4594 
4595     \snippet code/src_corelib_kernel_qobject.cpp 44
4596 
4597     This example ensures that the label always displays the current
4598     line edit text.
4599 
4600     A signal can be connected to many slots and signals. Many signals
4601     can be connected to one slot.
4602 
4603     If a signal is connected to several slots, the slots are activated
4604     in the same order as the order the connection was made, when the
4605     signal is emitted
4606 
4607     The function returns an handle to a connection if it successfully
4608     connects the signal to the slot. The Connection handle will be invalid
4609     if it cannot create the connection, for example, if QObject is unable
4610     to verify the existence of \a signal (if it was not declared as a signal)
4611     You can check if the QMetaObject::Connection is valid by casting it to a bool.
4612 
4613     By default, a signal is emitted for every connection you make;
4614     two signals are emitted for duplicate connections. You can break
4615     all of these connections with a single disconnect() call.
4616     If you pass the Qt::UniqueConnection \a type, the connection will only
4617     be made if it is not a duplicate. If there is already a duplicate
4618     (exact same signal to the exact same slot on the same objects),
4619     the connection will fail and connect will return an invalid QMetaObject::Connection.
4620 
4621     The optional \a type parameter describes the type of connection
4622     to establish. In particular, it determines whether a particular
4623     signal is delivered to a slot immediately or queued for delivery
4624     at a later time. If the signal is queued, the parameters must be
4625     of types that are known to Qt's meta-object system, because Qt
4626     needs to copy the arguments to store them in an event behind the
4627     scenes. If you try to use a queued connection and get the error
4628     message
4629 
4630     \snippet code/src_corelib_kernel_qobject.cpp 25
4631 
4632     make sure to declare the argument type with Q_DECLARE_METATYPE
4633 
4634     Overloaded functions can be resolved with help of \l qOverload.
4635 
4636     \sa {Differences between String-Based and Functor-Based Connections}
4637  */
4638 
4639 /*!
4640     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
4641 
4642     \threadsafe
4643     \overload connect()
4644 
4645     Creates a connection from \a signal in
4646     \a sender object to \a functor, and returns a handle to the connection
4647 
4648     The signal must be a function declared as a signal in the header.
4649     The slot function can be any function or functor that can be connected
4650     to the signal.
4651     A function can be connected to a given signal if the signal has at
4652     least as many argument as the slot. A functor can be connected to a signal
4653     if they have exactly the same number of arguments. There must exist implicit
4654     conversion between the types of the corresponding arguments in the
4655     signal and the slot.
4656 
4657     Example:
4658 
4659     \snippet code/src_corelib_kernel_qobject.cpp 45
4660 
4661     Lambda expressions can also be used:
4662 
4663     \snippet code/src_corelib_kernel_qobject.cpp 46
4664 
4665     The connection will automatically disconnect if the sender is destroyed.
4666     However, you should take care that any objects used within the functor
4667     are still alive when the signal is emitted.
4668 
4669     Overloaded functions can be resolved with help of \l qOverload.
4670 
4671  */
4672 
4673 /*!
4674     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)
4675 
4676     \threadsafe
4677     \overload connect()
4678 
4679     \since 5.2
4680 
4681     Creates a connection of a given \a type from \a signal in
4682     \a sender object to \a functor to be placed in a specific event
4683     loop of \a context, and returns a handle to the connection.
4684 
4685     \note Qt::UniqueConnections do not work for lambdas, non-member functions
4686     and functors; they only apply to connecting to member functions.
4687 
4688     The signal must be a function declared as a signal in the header.
4689     The slot function can be any function or functor that can be connected
4690     to the signal.
4691     A function can be connected to a given signal if the signal has at
4692     least as many argument as the slot. A functor can be connected to a signal
4693     if they have exactly the same number of arguments. There must exist implicit
4694     conversion between the types of the corresponding arguments in the
4695     signal and the slot.
4696 
4697     Example:
4698 
4699     \snippet code/src_corelib_kernel_qobject.cpp 50
4700 
4701     Lambda expressions can also be used:
4702 
4703     \snippet code/src_corelib_kernel_qobject.cpp 51
4704 
4705     The connection will automatically disconnect if the sender or the context
4706     is destroyed.
4707     However, you should take care that any objects used within the functor
4708     are still alive when the signal is emitted.
4709 
4710     Overloaded functions can be resolved with help of \l qOverload.
4711  */
4712 
4713 /*!
4714     \internal
4715 
4716     Implementation of the template version of connect
4717 
4718     \a sender is the sender object
4719     \a signal is a pointer to a pointer to a member signal of the sender
4720     \a receiver is the receiver object, may not be null, will be equal to sender when
4721                 connecting to a static function or a functor
4722     \a slot a pointer only used when using Qt::UniqueConnection
4723     \a type the Qt::ConnctionType passed as argument to connect
4724     \a types an array of integer with the metatype id of the parameter of the signal
4725              to be used with queued connection
4726              must stay valid at least for the whole time of the connection, this function
4727              do not take ownership. typically static data.
4728              If null, then the types will be computed when the signal is emit in a queued
4729              connection from the types from the signature.
4730     \a senderMetaObject is the metaobject used to lookup the signal, the signal must be in
4731                         this metaobject
4732  */
4733 QMetaObject::Connection QObject::connectImpl(const QObject *sender, void **signal,
4734                                              const QObject *receiver, void **slot,
4735                                              QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
4736                                              const int *types, const QMetaObject *senderMetaObject)
4737 {
4738     if (!signal) {
4739         qWarning("QObject::connect: invalid null parameter");
4740         if (slotObj)
4741             slotObj->destroyIfLastRef();
4742         return QMetaObject::Connection();
4743     }
4744 
4745     int signal_index = -1;
4746     void *args[] = { &signal_index, signal };
4747     for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
4748         senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
4749         if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
4750             break;
4751     }
4752     if (!senderMetaObject) {
4753         qWarning("QObject::connect: signal not found in %s", sender->metaObject()->className());
4754         slotObj->destroyIfLastRef();
4755         return QMetaObject::Connection(0);
4756     }
4757     signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
4758     return QObjectPrivate::connectImpl(sender, signal_index, receiver, slot, slotObj, type, types, senderMetaObject);
4759 }
4760 
4761 /*!
4762     \internal
4763 
4764     Internal version of connect used by the template version of QObject::connect (called via connectImpl) and
4765     also used by the QObjectPrivate::connect version used by QML. The signal_index is expected to be relative
4766     to the number of signals.
4767  */
4768 QMetaObject::Connection QObjectPrivate::connectImpl(const QObject *sender, int signal_index,
4769                                              const QObject *receiver, void **slot,
4770                                              QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
4771                                              const int *types, const QMetaObject *senderMetaObject)
4772 {
4773     if (!sender || !receiver || !slotObj || !senderMetaObject) {
4774         const char *senderString = sender ? sender->metaObject()->className()
4775                                           : senderMetaObject ? senderMetaObject->className()
4776                                           : "Unknown";
4777         const char *receiverString = receiver ? receiver->metaObject()->className()
4778                                               : "Unknown";
4779         qWarning("QObject::connect(%s, %s): invalid null parameter", senderString, receiverString);
4780         if (slotObj)
4781             slotObj->destroyIfLastRef();
4782         return QMetaObject::Connection();
4783     }
4784 
4785     QObject *s = const_cast<QObject *>(sender);
4786     QObject *r = const_cast<QObject *>(receiver);
4787 
4788     QOrderedMutexLocker locker(signalSlotLock(sender),
4789                                signalSlotLock(receiver));
4790 
4791     if (type & Qt::UniqueConnection && slot && QObjectPrivate::get(s)->connections) {
4792         QObjectPrivate::ConnectionData *connections = QObjectPrivate::get(s)->connections;
4793         if (connections->signalVector.count() > signal_index) {
4794             const QObjectPrivate::Connection *c2 = connections->signalVector.at(signal_index).first;
4795 
4796             while (c2) {
4797                 if (c2->receiver == receiver && c2->isSlotObject && c2->slotObj->compare(slot)) {
4798                     slotObj->destroyIfLastRef();
4799                     return QMetaObject::Connection();
4800                 }
4801                 c2 = c2->nextConnectionList;
4802             }
4803         }
4804         type = static_cast<Qt::ConnectionType>(type ^ Qt::UniqueConnection);
4805     }
4806 
4807     QScopedPointer<QObjectPrivate::Connection> c(new QObjectPrivate::Connection);
4808     c->sender = s;
4809     c->signal_index = signal_index;
4810     c->receiver = r;
4811     c->slotObj = slotObj;
4812     c->connectionType = type;
4813     c->isSlotObject = true;
4814     if (types) {
4815         c->argumentTypes.store(types);
4816         c->ownArgumentTypes = false;
4817     }
4818 
4819     QObjectPrivate::get(s)->addConnection(signal_index, c.data());
4820     QMetaObject::Connection ret(c.take());
4821     locker.unlock();
4822 
4823     QMetaMethod method = QMetaObjectPrivate::signal(senderMetaObject, signal_index);
4824     Q_ASSERT(method.isValid());
4825     s->connectNotify(method);
4826 
4827     return ret;
4828 }
4829 
4830 /*!
4831     Disconnect a connection.
4832 
4833     If the \a connection is invalid or has already been disconnected, do nothing
4834     and return false.
4835 
4836    \sa connect()
4837  */
4838 bool QObject::disconnect(const QMetaObject::Connection &connection)
4839 {
4840     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(connection.d_ptr);
4841 
4842     if (!c || !c->receiver)
4843         return false;
4844 
4845     QMutex *senderMutex = signalSlotLock(c->sender);
4846     QMutex *receiverMutex = signalSlotLock(c->receiver);
4847 
4848     {
4849         QOrderedMutexLocker locker(senderMutex, receiverMutex);
4850 
4851         QObjectPrivate::ConnectionData *connections = QObjectPrivate::get(c->sender)->connections;
4852         Q_ASSERT(connections);
4853         connections->dirty = true;
4854 
4855         *c->prev = c->next;
4856         if (c->next)
4857             c->next->prev = c->prev;
4858         c->receiver = nullptr;
4859     }
4860 
4861     // destroy the QSlotObject, if possible
4862     if (c->isSlotObject) {
4863         c->slotObj->destroyIfLastRef();
4864         c->isSlotObject = false;
4865     }
4866 
4867     c->sender->disconnectNotify(QMetaObjectPrivate::signal(c->sender->metaObject(),
4868                                                            c->signal_index));
4869 
4870     const_cast<QMetaObject::Connection &>(connection).d_ptr = nullptr;
4871     c->deref(); // has been removed from the QMetaObject::Connection object
4872 
4873     return true;
4874 }
4875 
4876 /*! \fn template<typename PointerToMemberFunction> bool QObject::disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
4877     \overload diconnect()
4878     \threadsafe
4879 
4880     Disconnects \a signal in object \a sender from \a method in object
4881     \a receiver. Returns \c true if the connection is successfully broken;
4882     otherwise returns \c false.
4883 
4884     A signal-slot connection is removed when either of the objects
4885     involved are destroyed.
4886 
4887     disconnect() is typically used in three ways, as the following
4888     examples demonstrate.
4889     \list 1
4890     \li Disconnect everything connected to an object's signals:
4891 
4892        \snippet code/src_corelib_kernel_qobject.cpp 26
4893 
4894     \li Disconnect everything connected to a specific signal:
4895 
4896        \snippet code/src_corelib_kernel_qobject.cpp 47
4897 
4898     \li Disconnect a specific receiver:
4899 
4900        \snippet code/src_corelib_kernel_qobject.cpp 30
4901 
4902     \li Disconnect a connection from one specific signal to a specific slot:
4903 
4904        \snippet code/src_corelib_kernel_qobject.cpp 48
4905 
4906 
4907     \endlist
4908 
4909     0 may be used as a wildcard, meaning "any signal", "any receiving
4910     object", or "any slot in the receiving object", respectively.
4911 
4912     The \a sender may never be 0. (You cannot disconnect signals from
4913     more than one object in a single call.)
4914 
4915     If \a signal is 0, it disconnects \a receiver and \a method from
4916     any signal. If not, only the specified signal is disconnected.
4917 
4918     If \a receiver is 0, it disconnects anything connected to \a
4919     signal. If not, slots in objects other than \a receiver are not
4920     disconnected.
4921 
4922     If \a method is 0, it disconnects anything that is connected to \a
4923     receiver. If not, only slots named \a method will be disconnected,
4924     and all other slots are left alone. The \a method must be 0 if \a
4925     receiver is left out, so you cannot disconnect a
4926     specifically-named slot on all objects.
4927 
4928     \note It is not possible to use this overload to diconnect signals
4929     connected to functors or lambda expressions. That is because it is not
4930     possible to compare them. Instead, use the overload that takes a
4931     QMetaObject::Connection
4932 
4933     \sa connect()
4934 */
4935 
4936 bool QObject::disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, const QMetaObject *senderMetaObject)
4937 {
4938     if (sender == 0 || (receiver == 0 && slot != 0)) {
4939         qWarning("QObject::disconnect: Unexpected null parameter");
4940         return false;
4941     }
4942 
4943     int signal_index = -1;
4944     if (signal) {
4945         void *args[] = { &signal_index, signal };
4946         for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
4947             senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
4948             if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
4949                 break;
4950         }
4951         if (!senderMetaObject) {
4952             qWarning("QObject::disconnect: signal not found in %s", sender->metaObject()->className());
4953             return QMetaObject::Connection(0);
4954         }
4955         signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
4956     }
4957 
4958     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, receiver, -1, slot);
4959 }
4960 
4961 /*!
4962  \internal
4963  Used by QML to connect a signal by index to a slot implemented in JavaScript (wrapped in a custom QSlotOBjectBase subclass).
4964 
4965  The signal_index is an index relative to the number of methods.
4966  */
4967 QMetaObject::Connection QObjectPrivate::connect(const QObject *sender, int signal_index, QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type)
4968 {
4969     if (!sender) {
4970         qWarning("QObject::connect: invalid null parameter");
4971         if (slotObj)
4972             slotObj->destroyIfLastRef();
4973         return QMetaObject::Connection();
4974     }
4975     const QMetaObject *senderMetaObject = sender->metaObject();
4976     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
4977 
4978     return QObjectPrivate::connectImpl(sender, signal_index, sender, /*slot*/0, slotObj, type, /*types*/0, senderMetaObject);
4979 }
4980 
4981 /*!
4982  \internal
4983  Used by QML to disconnect a signal by index that's connected to a slot implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass)
4984  In the QML case the slot is not a pointer to a pointer to the function to disconnect, but instead it is a pointer to an array of internal values
4985  required for the disconnect.
4986  */
4987 bool QObjectPrivate::disconnect(const QObject *sender, int signal_index, void **slot)
4988 {
4989     const QMetaObject *senderMetaObject = sender->metaObject();
4990     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
4991 
4992     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, sender, -1, slot);
4993 }
4994 
4995 /*! \class QMetaObject::Connection
4996     \inmodule QtCore
4997      Represents a handle to a signal-slot connection.
4998      It can be used to disconnect that connection, or check if
4999      the connection was successful
5000 
5001      \sa QObject::disconnect()
5002  */
5003 
5004 /*!
5005     Create a copy of the handle to the \a other connection
5006  */
5007 QMetaObject::Connection::Connection(const QMetaObject::Connection &other) : d_ptr(other.d_ptr)
5008 {
5009     if (d_ptr)
5010         static_cast<QObjectPrivate::Connection *>(d_ptr)->ref();
5011 }
5012 
5013 /*!
5014     Assigns \a other to this connection and returns a reference to this connection.
5015 */
5016 QMetaObject::Connection& QMetaObject::Connection::operator=(const QMetaObject::Connection& other)
5017 {
5018     if (other.d_ptr != d_ptr) {
5019         if (d_ptr)
5020             static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5021         d_ptr = other.d_ptr;
5022         if (other.d_ptr)
5023             static_cast<QObjectPrivate::Connection *>(other.d_ptr)->ref();
5024     }
5025     return *this;
5026 }
5027 
5028 /*!
5029     Creates a Connection instance.
5030 */
5031 
5032 QMetaObject::Connection::Connection() : d_ptr(0) {}
5033 
5034 /*!
5035     Destructor for QMetaObject::Connection.
5036 */
5037 QMetaObject::Connection::~Connection()
5038 {
5039     if (d_ptr)
5040         static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5041 }
5042 
5043 /*! \internal Returns true if the object is still connected */
5044 bool QMetaObject::Connection::isConnected_helper() const
5045 {
5046     Q_ASSERT(d_ptr);    // we're only called from operator RestrictedBool() const
5047     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(d_ptr);
5048 
5049     return c->receiver;
5050 }
5051 
5052 
5053 /*!
5054     \fn QMetaObject::Connection::operator bool() const
5055 
5056     Returns \c true if the connection is valid.
5057 
5058     The connection is valid if the call to QObject::connect succeeded.
5059     The connection is invalid if QObject::connect was not able to find
5060     the signal or the slot, or if the arguments do not match.
5061  */
5062 
5063 QT_END_NAMESPACE
5064 
5065 #include "moc_qnamespace.cpp"
5066 #include "moc_qobject.cpp"
