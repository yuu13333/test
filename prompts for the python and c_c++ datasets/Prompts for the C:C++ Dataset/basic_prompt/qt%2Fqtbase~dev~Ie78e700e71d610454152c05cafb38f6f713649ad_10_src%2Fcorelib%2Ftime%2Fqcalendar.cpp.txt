Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 #include "qcalendar.h"
40 #include "qcalendarbackend_p.h"
41 #include "qgregoriancalendar_p.h"
42 #ifndef QT_BOOTSTRAPPED
43 #include "qjuliancalendar_p.h"
44 #include "qmilankoviccalendar_p.h"
45 #endif
46 #if QT_CONFIG(jalalicalendar)
47 #include "qjalalicalendar_p.h"
48 #endif
49 #if QT_CONFIG(islamiccivilcalendar)
50 #include "qislamiccivilcalendar_p.h"
51 #endif
52 
53 #include "qatomic.h"
54 #include "qdatetime.h"
55 #include "qcalendarmath_p.h"
56 #include <qhash.h>
57 #include <qmutex.h>
58 #include <private/qlocking_p.h>
59 #include <qdebug.h>
60 
61 #include <vector>
62 
63 QT_BEGIN_NAMESPACE
64 
65 static const QCalendarBackend *backendFromEnum(QCalendar::System system);
66 
67 namespace {
68 
69 struct CalendarName : public QString
70 {
71     CalendarName(const QString &name) : QString(name) {}
72 };
73 
74 inline bool operator==(const CalendarName &u, const CalendarName &v)
75 {
76     return u.compare(v, Qt::CaseInsensitive) == 0;
77 }
78 
79 inline size_t qHash(const CalendarName &key, size_t seed = 0) noexcept
80 {
81     return qHash(key.toLower(), seed);
82 }
83 
84 static QBasicMutex registryMutex; // Protects registry from concurrent access
85 struct Registry
86 {
87     std::vector<QCalendarBackend *> byId;
88     QHash<CalendarName, QCalendarBackend *> byName;
89     QAtomicPointer<const QCalendarBackend> gregorianCalendar = nullptr;
90     QAtomicInteger<int> status = 0; // 1: populated, 2: destructing
91 
92     Registry()
93     {
94         byId.resize(int(QCalendar::System::Last) + 1);
95     }
96 
97     ~Registry()
98     {
99         status.storeRelaxed(2);
100         const auto lock = qt_scoped_lock(registryMutex);
101         qDeleteAll(byId);
102     }
103 
104     bool registerName(QCalendarBackend *calendar, const QString &name)
105     {
106         Q_ASSERT(!name.isEmpty());
107         if (status.loadRelaxed() > 1 || name.isEmpty())
108             return false;
109         const auto lock = qt_scoped_lock(registryMutex);
110 
111         const auto found = byName.find(name);
112         if (found != byName.end()) {
113             // Re-registering a calendar with a name it has already is OK (and
114             // can be used to test whether its constructor successfully
115             // registered its primary name).
116             return found.value() == calendar;
117         }
118         byName.insert(name, calendar);
119         return true;
120     }
121     void addCalendar(QCalendarBackend *calendar, const QString &name, QCalendar::System id)
122     {
123         if (status.loadRelaxed() > 1 || name.isEmpty() || !registerName(calendar, name))
124             return;
125         const auto lock = qt_scoped_lock(registryMutex);
126         Q_ASSERT(byId.size() >= size_t(id));
127         if (id == QCalendar::System::User) {
128             byId.push_back(calendar);
129         } else {
130             Q_ASSERT(byId[size_t(id)] == nullptr);
131             byId[size_t(id)] = calendar;
132         }
133         if (id == QCalendar::System::Gregorian) {
134             Q_ASSERT(!gregorianCalendar.loadRelaxed());
135             gregorianCalendar.storeRelease(calendar);
136         }
137     }
138     /*
139         \internal
140         Ensures each \c{enum}-available calendar has been instantiated.
141 
142         This arranges for each to register itself by name; it only does anything on
143         its first call, which ensures that name-based lookups can always find all
144         the calendars available via the \c enum.
145     */
146     void populate()
147     {
148         if (status.loadRelaxed())
149             return;
150 
151         const auto lock = qt_scoped_lock(registryMutex);
152         if (status.loadRelaxed())
153             return;
154 
155         for (int i = 0; i <= int(QCalendar::System::Last); ++i) {
156             if (!byId[i])
157                 (void)backendFromEnum(QCalendar::System(i));
158         }
159 
160         status.storeRelaxed(1);
161     }
162 };
163 
164 }
165 
166 Q_GLOBAL_STATIC(Registry, calendarRegistry);
167 
168 static const QCalendarBackend *backendFromEnum(QCalendar::System system)
169 {
170     QCalendarBackend *backend = nullptr;
171     switch (system) {
172     case QCalendar::System::Gregorian:
173         backend = new QGregorianCalendar;
174         break;
175 #ifndef QT_BOOTSTRAPPED
176     case QCalendar::System::Julian:
177         backend = new QJulianCalendar;
178         break;
179     case QCalendar::System::Milankovic:
180         backend = new QMilankovicCalendar;
181         break;
182 #endif
183 #if QT_CONFIG(jalalicalendar)
184     case QCalendar::System::Jalali:
185         backend = new QJalaliCalendar;
186         break;
187 #endif
188 #if QT_CONFIG(islamiccivilcalendar)
189     case QCalendar::System::IslamicCivil:
190         backend = new QIslamicCivilCalendar;
191         break;
192 #else // When highest-numbered system isn't enabled, ensure we have a case for Last:
193     case QCalendar::System::Last:
194 #endif
195     case QCalendar::System::User:
196         Q_UNREACHABLE();
197     }
198     if (!backend)
199         return backend;
200     const QString name = backend->name();
201     // Check for successful registration:
202     if (calendarRegistry->registerName(backend, name))
203         return backend;
204     delete backend;
205     const auto lock = qt_scoped_lock(registryMutex);
206     const auto found = calendarRegistry->byName.find(name);
207     if (found != calendarRegistry->byName.end())
208         return found.value();
209     return nullptr;
210 }
211 
212 /*!
213     \since 5.14
214 
215     \class QCalendarBackend
216     \inmodule QtCore
217     \internal
218     \reentrant
219     \brief The QCalendarBackend class provides basic calendaring functions.
220 
221     QCalendarBackend provides the base class on which all calendar types are
222     implemented. On construction, the backend is registered with its primary
223     name.
224 
225     A backend, once successfully registered with its primary name, may also be
226     registered with aliases, where the calendar is known by several
227     names. Registering with the name used by CLDR (the Unicode consortium's
228     Common Locale Data Repository) is recommended, particularly when interacting
229     with third-party software. Once a backend is registered for a name,
230     QCalendar can be constructed using that name to select the backend.
231 
232     Each built-in backend has a distinct primary name and all built-in backends
233     are instantiated before any custom backend is registered, to prevent custom
234     backends with conflicting names from replacing built-in backends.
235 
236     Each calendar backend must inherit from QCalendarBackend and implement its
237     pure virtual methods. It may also override some other virtual methods, as
238     needed.
239 
240     Most backends are pure code, with no data elements. Such backends should
241     normally be implemented as singletons. For a backend to be added to the
242     QCalendar::System \c enum, it must be such a singleton, with a case in
243     backendFromEnum()'s switch statement (above) to instantiate it.
244 
245     \section1 Instantiating backends
246 
247     Backends may be defined by third-party, plugin or user code. When such
248     custom backends are instantiated, in their calls to the QCalendarBackend
249     base-class constructor, each instance should pass a distinct primary name to
250     the base-class constructor and omit the \c system parameter.
251 
252     A backend class that has instance variables as well as code may be
253     instantiated many times, each with a distinct primary name, to implement
254     distinct backends - presumably variants on some parameterized calendar.
255     Each instance is then a distinct backend. A pure code backend class shall
256     typically only be instantiated once, as it is only capable of representing
257     one backend.
258 
259     Each backend should be instantiated exactly once, on the heap (using the C++
260     \c new operator); this will register it with the QCalendar implementation
261     code and ensure it is available, by its primary name, to all code that may
262     subsequently need it.  It will be deleted on program termination along with
263     the registry in which QCalendar records backends.
264 
265     The single exception to this is that each backend's instantiator should
266     verify that it was registered successfully with its primary name. It can do
267     this by calling registerAlias() with that name; this will return true if it
268     is already registered with the name. If it returns false, the instantiation
269     has used a name that was already in use so the new backend has not been
270     registered and the instantiator retains ownership of the backend instance;
271     it will not be accessible to QCalendar. (Since registerAlias() is protected,
272     a custom backend's class shall typically need to provide a method to perform
273     this check for its instantiator.)
274 
275     Built-in backends, identified by QCalendar::System values other than User,
276     should only be instantiated by code in the implementation of QCalendar; no
277     other code should ever instantiate one. As noted above, such a backend must
278     be a singleton. Its constructor passes down the \c enum member that
279     identifies it as \c system to the base-class constructor.
280 
281     The shareable base-classes for backends, QRomanCalendar and QHijriCalendar,
282     are not themselves identified by QCalendar::System and may be used as
283     base-classes for custom calendar backends, but cannot be instantiated
284     themselves.
285 
286     \sa registerAlias(), QDate, QDateTime, QDateEdit, QDateTimeEdit,
287         QCalendarWidget
288 */
289 
290 /*!
291     Constructs the calendar and registers it under \a name using \a system.
292 
293     On successful registration, the calendar backend registry takes over
294     ownership of the instance and shall delete it on program exit in the course
295     of the registry's own destruction. The instance can determine whether it was
296     successfully registered by calling registerAlias() with the same \a name it
297     passed to this base-class constructor. If that returns \c false, the
298     instance has not been registered, QCalendar cannot use it, it should not
299     attempt to register any other aliases and the code that instantiated the
300     backend is responsible for deleting it.
301 
302     The \a system is optional and should only be passed by built-in
303     implementations of the standard calendars documented in \l
304     QCalendar::System. Custom backends should not pass \a system.
305 
306     Only one backend instance should ever be registered for any given \a system:
307     in the event of a backend being created when one with the same \a system
308     already exists, the new backend is not registered. The \a name passed with a
309     \a system (other than \l{QCalendar::System}{User}) must be the \c{name()} of
310     the backend constructed.
311 
312     The \a name must be non-empty and unique; after one backend has been
313     registered for a name or alias, no other backend can be registered with that
314     name. The presence of another backend registered with the same name may mean
315     the backend is redundant, as the system already has a backend to handle the
316     given calendar type.
317 
318     \note \c{QCalendar(name).isValid()} will return true precisely when the
319     given \c name is in use already. This can be used as a test before
320     instantiating a backend with the given \c name.
321 
322     \sa calendarSystem(), registerAlias()
323 */
324 QCalendarBackend::QCalendarBackend(const QString &name, QCalendar::System system)
325 {
326     Q_ASSERT(!name.isEmpty());
327     // Will lock the registry mutex on its own, so no need to do it here:
328     calendarRegistry->addCalendar(this, name, system);
329 }
330 
331 /*!
332     Destroys the calendar.
333 
334     Client code should only call this if instantiation failed to register the
335     backend, as revealed by the instanee failing to registerAlias() with the
336     name it passed to this base-class's constructor. Only a backend that fails
337     to register can safely be deleted; and the client code that instantiated it
338     is indeed responsible for deleting it.
339 
340     Once a backend has been successfully registered, there may be QCalendar
341     instances using it; deleting it while they still reference it would lead to
342     undefined behavior. Such a backend shall be deleted when the calendar
343     backend registry is deleted on program exit; the registry takes over
344     ownership of the instance on successful registration.
345 
346     \sa registerAlias()
347 */
348 QCalendarBackend::~QCalendarBackend()
349 {
350     // Either the registry is destroying itself, in which case it takes care of
351     // dropping any references to this, or this never got registered, so there
352     // is no need to tell the registry to forget it.
353 }
354 
355 /*!
356     The calendar system of this calendar.
357 
358     Each calendar backend constructible from the QCalendar::System \c enum
359     should return the member of that \c enum that produces it. Other calendars
360     should return User.
361 
362     \sa QCalendarBackend::fromEnum()
363 */
364 QCalendar::System QCalendarBackend::calendarSystem() const
365 {
366     return QCalendar::System::User;
367 }
368 
369 /*!
370     \fn QString QCalendarBackend::name() const;
371 
372     This pure virtual method should be overloaded by each backend implementation
373     to return the name that the backend passes to the base-class as its name.
374 */
375 
376 /*!
377     The primary name of this calendar.
378 */
379 QString QCalendar::name() const
380 {
381     return d ? d->name() : QString();
382 }
383 
384 // date queries
385 /*!
386    \fn int QCalendarBackend::daysInMonth(int month, int year) const
387 
388    Returns number of days in the month number \a month, in year \a year.
389 
390    An implementation should return 0 if the given year had no such month. If
391    year is QCalendar::Unspecified, return the usual number of days for the
392    month, in those years that include it.
393 
394    Calendars with intercallary days may represent these as extra days of the
395    preceding month, or as short months separate from the usual ones. In the
396    former case, daysInMonth(month, year) should be the number of ordinary days
397    in the month, although \c{isDateValid(year, month, day)} might return \c true
398    for some larger values of \c day.
399 
400    \sa daysInYear(), monthsInYear(), minimumDaysInMonth(), maximumDaysInMonth()
401 */
402 
403 // properties of the calendar
404 
405 /*!
406     \fn bool QCalendarBackend::isLeapYear(int year) const
407 
408     Returns \c true if the specified \a year is a leap year for this calendar.
409 
410     \sa daysInYear(), isDateValid()
411 */
412 
413 /*!
414     \fn bool QCalendarBackend::isLunar() const
415 
416     Returns \c true if this calendar is a lunar calendar. Otherwise returns \c
417     false.
418 
419     A lunar calendar is a calendar based upon the monthly cycles of the Moon's
420     phases (synodic months). This contrasts with solar calendars, whose annual
421     cycles are based only upon the solar year.
422 
423     \sa isLuniSolar(), isSolar(), isProleptic()
424 */
425 
426 /*!
427     \fn bool QCalendarBackend::isLuniSolar() const
428 
429     Returns \c true if this calendar is a lunisolar calendar. Otherwise returns
430     \c false.
431 
432     A lunisolar calendar is a calendar whose date indicates both the moon phase
433     and the time of the solar year.
434 
435     \sa isLunar(), isSolar(), isProleptic()
436 */
437 
438 /*!
439     \fn bool QCalendarBackend::isSolar() const
440 
441     Returns \c true if this calendar is a solar calendar. Otherwise returns
442     \c false.
443 
444     A solar calendar is a calendar whose dates indicate the season or almost
445     equivalently the apparent position of the sun relative to the fixed stars.
446     The Gregorian calendar, widely accepted as standard in the world,
447     is an example of solar calendar.
448 
449     \sa isLuniSolar(), isLunar(), isProleptic()
450 */
451 
452 /*!
453     Returns the total number of days in the year number \a year.
454     Returns zero if there is no such year in this calendar.
455 
456     This base implementation returns 366 for leap years and 365 for ordinary
457     years.
458 
459     \sa monthsInYear(), daysInMonth(), isLeapYear()
460 */
461 int QCalendarBackend::daysInYear(int year) const
462 {
463     return monthsInYear(year) ? isLeapYear(year) ? 366 : 365 : 0;
464 }
465 
466 /*!
467     Returns the total number of months in the year number \a year.
468     Returns zero if there is no such year in this calendar.
469 
470     This base implementation returns 12 for any valid year.
471 
472     \sa daysInYear(), maximumMonthsInYear(), isDateValid()
473 */
474 int QCalendarBackend::monthsInYear(int year) const
475 {
476     return year > 0 || (year < 0 ? isProleptic() : hasYearZero()) ? 12 : 0;
477 }
478 
479 /*!
480     Returns \c true if the date specified by \a year, \a month, and \a day is
481     valid for this calendar; otherwise returns \c false. For example,
482     the date 2018-04-19 is valid for the Gregorian calendar, but 2018-16-19 and
483     2018-04-38 are invalid.
484 
485     Calendars with intercallary days may represent these as extra days of the
486     preceding month or as short months separate from the usual ones. In the
487     former case, a \a day value greater than \c{daysInMonth(\a{month},
488     \a{year})} may be valid.
489 
490     \sa daysInMonth(), monthsInYear()
491 */
492 bool QCalendarBackend::isDateValid(int year, int month, int day) const
493 {
494     return day > 0 && day <= daysInMonth(month, year);
495 }
496 
497 /*!
498     Returns \c true if this calendar is a proleptic calendar. Otherwise returns
499     \c false.
500 
501     A proleptic calendar results from allowing negative year numbers to indicate
502     years before the nominal start of the calendar system.
503 
504     \sa isLuniSolar(), isSolar(), isLunar(), hasYearZero()
505 */
506 
507 bool QCalendarBackend::isProleptic() const
508 {
509     return true;
510 }
511 
512 /*!
513     Returns \c true if year number \c 0 is considered a valid year in this
514     calendar. Otherwise returns \c false.
515 
516     \sa isDateValid(), isProleptic()
517 */
518 
519 bool QCalendarBackend::hasYearZero() const
520 {
521     return false;
522 }
523 
524 /*!
525     Returns the maximum number of days in a month for any year.
526 
527     This base implementation returns 31, as this is a common case.
528 
529     For calendars with intercallary days, although daysInMonth() doesn't include
530     the intercallary days in its count for an individual month,
531     maximumDaysInMonth() should include intercallary days, so that it is the
532     maximum value of \c day for which \c{isDateValid(year, month, day)} can be
533     true.
534 
535     \sa maximumMonthsInYear(), daysInMonth()
536 */
537 int QCalendarBackend::maximumDaysInMonth() const
538 {
539     return 31;
540 }
541 
542 /*!
543     Returns the minimum number of days in any valid month of any valid year.
544 
545     This base implementation returns 29, as this is a common case.
546 
547     \sa maximumMonthsInYear(), daysInMonth()
548 */
549 int QCalendarBackend::minimumDaysInMonth() const
550 {
551     return 29;
552 }
553 
554 /*!
555     Returns the maximum number of months possible in any year.
556 
557     This base implementation returns 12, as this is a common case.
558 
559     \sa maximumDaysInMonth(), monthsInYear()
560 */
561 int QCalendarBackend::maximumMonthsInYear() const
562 {
563     return 12;
564 }
565 
566 // Julian day number calculations
567 
568 /*!
569     \fn bool QCalendarBackend::dateToJulianDay(int year, int month, int day, qint64 *jd) const
570 
571     Computes the Julian day number corresponding to the specified \a year, \a
572     month, and \a day. Returns true and sets \a jd if there is such a date in
573     this calendar; otherwise, returns false.
574 
575     \sa QCalendar::partsFromDate(), julianDayToDate()
576 */
577 
578 /*!
579     \fn QCalendar::YearMonthDay QCalendarBackend::julianDayToDate(qint64 jd) const
580 
581     Computes the year, month, and day in this calendar for the given Julian day
582     number \a jd. If the given day falls outside this calendar's scope
583     (e.g. before the start-date of a non-proleptic calendar), the returned
584     structure's isValid() is false; otherwise, its year, month, and day fields
585     provide this calendar's description of the date.
586 
587     \sa QCalendar::dateFromParts(), dateToJulianDay()
588 */
589 
590 /*!
591    Returns the day of the week for the given Julian Day Number \a jd.
592 
593    This is 1 for Monday through 7 for Sunday.
594 
595    Calendars with intercallary days may return larger values for these
596    intercallary days. They should avoid using 0 for any special purpose (it is
597    already used in QDate::dayOfWeek() to mean an invalid date). The calendar
598    should treat the numbers used as an \c enum, whose values need not be
599    contiguous, nor need they follow closely from the 1 through 7 of the usual
600    returns. It suffices that weekDayName() can recognize each such number as
601    identifying a distinct name, that it returns to identify the particular
602    intercallary day.
603 
604    This base implementation uses the day-numbering that various calendars have
605    borrowed off the Hebrew calendar.
606 
607    \sa weekDayName(), standaloneWeekDayName(), QDate::dayOfWeek()
608  */
609 int QCalendarBackend::dayOfWeek(qint64 jd) const
610 {
611     return QRoundingDown::qMod(jd, 7) + 1;
612 }
613 
614 // Month and week-day name look-ups (implemented in qlocale.cpp):
615 /*!
616     \fn QString QCalendarBackend::monthName(const QLocale &locale, int month, int year,
617                                             QLocale::FormatType format) const
618 
619     Returns the name of the specified \a month in the given \a year for the
620     chosen \a locale, using the given \a format to determine how complete the
621     name is.
622 
623     If \a year is Unspecified, return the name for the month that usually has
624     this number within a typical year. Calendars with a leap month that isn't
625     always the last may need to take account of the year to map the month number
626     to the particular year's month with that number.
627 
628     \note Backends for which CLDR provides data can configure the default
629     implementation of the two month name look-up methods by arranging for
630     localeMonthIndexData() and localeMonthData() to provide access to the CLDR
631     data (see cldr2qlocalexml.py, qlocalexml2cpp.py and existing backends).
632     Conversely, backends that override both month name look-up methods need not
633     return anything meaningful from localeMonthIndexData() or localeMonthData().
634 
635     \sa standaloneMonthName(), QLocale::monthName()
636 */
637 
638 /*!
639     \fn QString QCalendarBackend::standaloneMonthName(const QLocale &locale, int month, int year
640                                                       QLocale::FormatType format) const
641 
642     Returns the standalone name of the specified \a month in the chosen \a
643     locale, using the specified \a format to determine how complete the name is.
644 
645     If \a year is Unspecified, return the standalone name for the month that
646     usually has this number within a typical year. Calendars with a leap month
647     that isn't always the last may need to take account of the year to map the
648     month number to the particular year's month with that number.
649 
650     \sa monthName(), QLocale::standaloneMonthName()
651 */
652 
653 /*!
654     \fn QString QCalendarBackend::weekDayName(const QLocale &locale, int day,
655                                               QLocale::FormatType format) const
656 
657     Returns the name of the specified \a day of the week in the chosen \a
658     locale, using the specified \a format to determine how complete the name is.
659 
660     The base implementation handles \a day values from 1 to 7 using the day
661     names CLDR provides, which are suitable for calendards that use the same
662     (Hebrew-derived) week as the Gregorian calendar.
663 
664     Calendars whose dayOfWeek() returns a value outside the range from 1 to 7
665     need to reimplement this method to handle such extra week-day values. They
666     can assume that \a day is a value returned by the same calendar's
667     dayOfWeek().
668 
669     \sa dayOfWeek(), standaloneWeekDayName(), QLocale::dayName()
670 */
671 
672 /*!
673     \fn QString QCalendarBackend::standaloneWeekDayName(const QLocale &locale, int day,
674                                                         QLocale::FormatType format) const
675 
676     Returns the standalone name of the specified \a day of the week in the
677     chosen \a locale, using the specified \a format to determine how complete
678     the name is.
679 
680     The base implementation handles \a day values from 1 to 7 using the
681     standalone day names CLDR provides, which are suitable for calendards that
682     use the same (Hebrew-derived) week as the Gregorian calendar.
683 
684     Calendars whose dayOfWeek() returns a value outside the range from 1 to 7
685     need to reimplement this method to handle such extra week-day values. They
686     can assume that \a day is a value returned by the same calendar's
687     dayOfWeek().
688 
689     \sa dayOfWeek(), weekDayName(), QLocale::standaloneDayName()
690 */
691 
692 /*!
693     \fn QString QCalendarBackend::dateTimeToString(QStringView format, const QDateTime &datetime,
694                                                    QDate dateOnly, QTime timeOnly,
695                                                    const QLocale &locale) const
696 
697     Returns a string representing a given date, time or date-time.
698 
699     If \a datetime is specified and valid, it is used and both date and time
700     format tokens are converted to appropriate representations of the parts of
701     the datetime. Otherwise, if \a dateOnly is valid, only date format tokens
702     are converted; else, if \a timeOnly is valid, only time format tokens are
703     converted. If none are valid, an empty string is returned.
704 
705     The specified \a locale influences how some format tokens are converted; for
706     example, when substituting day and month names and their short-forms. For
707     the supported formatting tokens, see QDate::toString() and
708     QTime::toString(). As described above, the provided date, time and date-time
709     determine which of these tokens are recognized: where these appear in \a
710     format they are replaced by data. Any text in \a format not recognized as a
711     format token is copied verbatim into the result string.
712 
713     \sa QDate::toString(), QTime::toString(), QDateTime::toString()
714 */
715 // End of methods implemented in qlocale.cpp
716 
717 /*!
718     Returns a list of names of the available calendar systems. Any
719     QCalendarBackend sub-class must be registered before being exposed to Date
720     and Time APIs.
721 
722     \sa registerAlias(), fromName()
723 */
724 QStringList QCalendarBackend::availableCalendars()
725 {
726     if (calendarRegistry.isDestroyed())
727         return {};
728     calendarRegistry->populate();
729     const auto registryLock = qt_scoped_lock(registryMutex);
730     return QStringList(calendarRegistry->byName.keyBegin(), calendarRegistry->byName.keyEnd());
731 }
732 
733 /*!
734     Registers an alias for this calendar backend. Once a backend is registered,
735     its name will be included in the list of available calendars and the
736     calendar can be instantiated by name.
737 
738     Returns \c false if the given \a name is already in use by a different
739     backend or \c true if this calendar is already registered with this
740     name. (This can be used, with its primary name, to test whether a backend's
741     construction successfully registered it.) Otherwise it registers this
742     calendar backend for this name and returns \c true.
743 
744     \sa availableCalendars(), fromName()
745 */
746 bool QCalendarBackend::registerAlias(const QString &name)
747 {
748     if (calendarRegistry.isDestroyed() || name.isEmpty())
749         return false;
750     // Constructing this accessed the registry, so ensured it exists:
751     Q_ASSERT(calendarRegistry.exists());
752 
753     // Not taking the lock on the registry here because it's just one call
754     // (which internally locks anyway).
755     return calendarRegistry->registerName(this, name);
756 }
757 
758 /*!
759     \internal
760     Returns a pointer to a named calendar backend.
761 
762     If the given \a name is present in availableCalendars(), the backend
763     matching it is returned; otherwise, \c nullptr is returned. Matching of
764     names ignores case. Note that this won't provoke construction of a calendar
765     backend, it will only return ones that have been instantiated (and not yet
766     destroyed) by some other means. However, calendars available via the
767     QCalendar::System \c enum are always registered when this is called.
768 
769     \sa availableCalendars(), registerAlias(), fromEnum()
770 */
771 const QCalendarBackend *QCalendarBackend::fromName(QStringView name)
772 {
773     if (calendarRegistry.isDestroyed())
774         return nullptr;
775     calendarRegistry->populate();
776     const auto registryLock = qt_scoped_lock(registryMutex);
777     auto it = calendarRegistry->byName.find(name.toString());
778     return it == calendarRegistry->byName.end() ? nullptr : *it;
779 }
780 
781 /*!
782     \internal
783     \overload
784  */
785 const QCalendarBackend *QCalendarBackend::fromName(QLatin1String name)
786 {
787     if (calendarRegistry.isDestroyed())
788         return nullptr;
789     calendarRegistry->populate();
790     const auto registryLock = qt_scoped_lock(registryMutex);
791     auto it = calendarRegistry->byName.find(QString(name));
792     return it == calendarRegistry->byName.end() ? nullptr : *it;
793 }
794 
795 /*!
796     \internal
797     Returns a pointer to a calendar backend, specified by \c enum.
798 
799     This will instantiate the indicated calendar (which will enable fromName()
800     to return it subsequently), but only for the Qt-supported calendars for
801     which (where relevant) the appropriate feature has been enabled.
802 */
803 const QCalendarBackend *QCalendarBackend::fromEnum(QCalendar::System system)
804 {
805     if (calendarRegistry.isDestroyed() || system == QCalendar::System::User)
806         return nullptr;
807 
808     const auto registryLock = qt_scoped_lock(registryMutex);
809 
810     Q_ASSERT(calendarRegistry->byId.size() >= size_t(system));
811     if (auto *c = calendarRegistry->byId[size_t(system)])
812         return c;
813     auto *result = backendFromEnum(system);
814     // Try to check that we don't have a race setting this Gregorian
815     // calendar in the registry
816     Q_ASSERT(result == calendarRegistry->byId[size_t(system)]);
817     return result;
818 }
819 
820 /*!
821     \since 5.14
822 
823     \class QCalendar
824     \inmodule QtCore
825     \reentrant
826     \brief The QCalendar class describes calendar systems.
827 
828     A QCalendar object maps a year, month, and day-number to a specific day
829     (ultimately identified by its Julian day number), using the rules of a
830     particular system.
831 
832     The default QCalendar() is a proleptic Gregorian calendar, which has no year
833     zero. Other calendars may be supported by enabling suitable features or
834     loading plugins. Calendars supported as features can be constructed by
835     passing the QCalendar::System enumeration to the constructor. All supported
836     calendars may be constructed by name, once they have been constructed. (Thus
837     plugins instantiate their calendar backend to register it.) Built-in
838     backends, accessible via QCalendar::System, are also always available by
839     name.
840 
841     A QCalendar value is immutable.
842 
843     \sa QDate, QDateTime
844 */
845 
846 /*!
847     \enum QCalendar::System
848 
849     This enumerated type is used to specify a choice of calendar system.
850 
851     \value Gregorian The default calendar, used internationally.
852     \value Julian An ancient Roman calendar with too few leap years.
853     \value Milankovic A revised Julian calendar used by some Orthodox churches.
854     \value Jalali The Solar Hijri calendar (also called Persian).
855     \value IslamicCivil The (tabular) Islamic Civil calendar.
856     \omitvalue Last
857     \omitvalue User
858 
859     \sa QCalendar
860 */
861 
862 /*!
863     \fn QCalendar::QCalendar()
864     \fn QCalendar::QCalendar(QCalendar::System system)
865     \fn QCalendar::QCalendar(QLatin1String name)
866     \fn QCalendar::QCalendar(QStringView name)
867 
868     Constructs a calendar object.
869 
870     The choice of calendar to use may be indicated as \a system, using the
871     enumeration QCalendar::System, or by \a name, using a string (either Unicode
872     or Latin 1). Construction by name may depend on an instance of the given
873     calendar being constructed by other means first. With no argument, the
874     default constructor returns the Gregorian calendar.
875 
876     \sa QCalendar, System, isValid()
877 */
878 
879 QCalendar::QCalendar()
880     : d(nullptr)
881 {
882     if (calendarRegistry.isDestroyed())
883         return;
884     d = calendarRegistry->gregorianCalendar.loadAcquire();
885     if (!d) {
886         auto fresh = new QGregorianCalendar;
887         if (!calendarRegistry->gregorianCalendar.testAndSetOrdered(fresh, fresh, d)) {
888             delete fresh;
889             d = calendarRegistry->gregorianCalendar.loadRelaxed();
890         }
891     }
892     Q_ASSERT(d);
893 }
894 
895 QCalendar::QCalendar(QCalendar::System system)
896     : d(QCalendarBackend::fromEnum(system))
897 {
898     // If system is valid, we should get a valid d for that system.
899     Q_ASSERT(uint(system) > uint(QCalendar::System::Last) || (d && d->calendarSystem() == system));
900 }
901 
902 QCalendar::QCalendar(QLatin1String name)
903     : d(QCalendarBackend::fromName(name)) {}
904 
905 QCalendar::QCalendar(QStringView name)
906     : d(QCalendarBackend::fromName(name)) {}
907 
908 /*!
909     \fn bool QCalendar::isValid() const
910 
911     Returns true if this is a valid calendar object.
912 
913     Constructing a calendar with an unrecognised calendar name may result in an
914     invalid object. Use this method to check after creating a calendar by name.
915 */
916 
917 // Date queries:
918 
919 /*!
920     Returns the number of days in the given \a month of the given \a year.
921 
922     Months are numbered consecutively, starting with 1 for the first month of
923     each year. If \a year is \c Unspecified (its default, if not passed), the
924     month's length in a normal year is returned.
925 
926     \sa maximumDaysInMonth(), minimumDaysInMonth()
927 */
928 int QCalendar::daysInMonth(int month, int year) const
929 {
930     return d ? d->daysInMonth(month, year) : 0;
931 }
932 
933 /*!
934     Returns the number of days in the given \a year.
935 
936     Handling of \c Unspecified as \a year is undefined.
937 */
938 int QCalendar::daysInYear(int year) const
939 {
940     return d ? d->daysInYear(year) : 0;
941 }
942 
943 /*!
944     Returns the number of months in the given \a year.
945 
946     If \a year is \c Unspecified, returns the maximum number of months in a
947     year.
948 
949     \sa maximumMonthsInYear()
950 */
951 int QCalendar::monthsInYear(int year) const
952 {
953     return d ? year == Unspecified ? d->maximumMonthsInYear() : d->monthsInYear(year) : 0;
954 }
955 
956 /*!
957     Returns \c true precisely if the given \a year, \a month, and \a day specify
958     a valid date in this calendar.
959 
960     Usually this means 1 <= month <= monthsInYear(year) and 1 <= day <=
961     daysInMonth(month, year). However, calendars with intercallary days or
962     months may complicate that.
963 */
964 bool QCalendar::isDateValid(int year, int month, int day) const
965 {
966     return d && d->isDateValid(year, month, day);
967 }
968 
969 // properties of the calendar
970 
971 /*!
972     Returns \c true if this calendar object is the Gregorian calendar object
973     used as default calendar by other Qt APIs, e.g. in QDate.
974 */
975 bool QCalendar::isGregorian() const
976 {
977     Q_ASSERT(calendarRegistry.exists());
978     return d == calendarRegistry->gregorianCalendar.loadRelaxed();
979 }
980 
981 /*!
982     Returns \c true if the given \a year is a leap year.
983 
984     Since the year is not a whole number of days long, some years are longer
985     than others. The difference may be a whole month or just a single day; the
986     details vary between calendars.
987 
988     \sa isDateValid()
989 */
990 bool QCalendar::isLeapYear(int year) const
991 {
992     return d && d->isLeapYear(year);
993 }
994 
995 /*!
996     Returns \c true if this calendar is a lunar calendar.
997 
998     A lunar calendar is one based primarily on the phases of the moon.
999 */
1000 bool QCalendar::isLunar() const
1001 {
1002     return d && d->isLunar();
1003 }
1004 
1005 /*!
1006     Returns \c true if this calendar is luni-solar.
1007 
1008     A luni-solar calendar expresses the phases of the moon but adapts itself to
1009     also keep track of the Sun's varying position in the sky, relative to the
1010     fixed stars.
1011 */
1012 bool QCalendar::isLuniSolar() const
1013 {
1014     return d && d->isLuniSolar();
1015 }
1016 
1017 /*!
1018     Returns \c true if this calendar is solar.
1019 
1020     A solar calendar is based primarily on the Sun's varying position in the
1021     sky, relative to the fixed stars.
1022 */
1023 bool QCalendar::isSolar() const
1024 {
1025     return d && d->isSolar();
1026 }
1027 
1028 /*!
1029     Returns \c true if this calendar is proleptic.
1030 
1031     A proleptic calendar is able to describe years arbitrarily long before its
1032     first. These are represented by negative year numbers and possibly by a year
1033     zero.
1034 
1035     \sa hasYearZero()
1036 */
1037 bool QCalendar::isProleptic() const
1038 {
1039     return d && d->isProleptic();
1040 }
1041 
1042 /*!
1043     Returns \c true if this calendar has a year zero.
1044 
1045     A calendar may represent years from its first year onwards but provide no
1046     way to describe years before its first; such a calendar has no year zero and
1047     is not proleptic.
1048 
1049     A calendar which represents years before its first may number these years
1050     simply by following the usual integer counting, so that the year before the
1051     first is year zero, with negative-numbered years preceding this; such a
1052     calendar is proleptic and has a year zero. A calendar might also have a year
1053     zero (for example, the year of some great event, with subsequent years being
1054     the first year after that event, the second year after, and so on) without
1055     describing years before its year zero. Such a calendar would have a year
1056     zero without being proleptic.
1057 
1058     Some calendars, however, represent years before their first by an alternate
1059     numbering; for example, the proleptic Gregorian calendar's first year is 1
1060     CE and the year before it is 1 BCE, preceded by 2 BCE and so on. In this
1061     case, we use negative year numbers for this alternate numbering, with year
1062     -1 as the year before year 1, year -2 as the year before year -1 and so
1063     on. Such a calendar is proleptic but has no year zero.
1064 
1065     \sa isProleptic()
1066 */
1067 bool QCalendar::hasYearZero() const
1068 {
1069     return d && d->hasYearZero();
1070 }
1071 
1072 /*!
1073     Returns the number of days in the longest month in the calendar, in any year.
1074 
1075     \sa daysInMonth(), minimumDaysInMonth()
1076 */
1077 int QCalendar::maximumDaysInMonth() const
1078 {
1079     return d ? d->maximumDaysInMonth() : 0;
1080 }
1081 
1082 /*!
1083     Returns the number of days in the shortest month in the calendar, in any year.
1084 
1085     \sa daysInMonth(), maximumDaysInMonth()
1086 */
1087 int QCalendar::minimumDaysInMonth() const
1088 {
1089     return d ? d->minimumDaysInMonth() : 0;
1090 }
1091 
1092 /*!
1093     Returns the largest number of months that any year may contain.
1094 
1095     \sa monthName(), standaloneMonthName(), monthsInYear()
1096 */
1097 int QCalendar::maximumMonthsInYear() const
1098 {
1099     return d ? d->maximumMonthsInYear() : 0;
1100 }
1101 
1102 // Julian Day conversions:
1103 
1104 /*!
1105     \fn QDate QCalendar::dateFromParts(int year, int month, int day) const
1106     \fn QDate QCalendar::dateFromParts(const QCalendar::YearMonthDay &parts) const
1107 
1108     Converts a year, month, and day to a QDate.
1109 
1110     The \a year, \a month, and \a day may be passed as separate numbers or
1111     packaged together as the members of \a parts. Returns a QDate with the given
1112     year, month, and day of the month in this calendar, if there is one.
1113     Otherwise, including the case where any of the values is
1114     QCalendar::Unspecified, returns a QDate whose isNull() is true.
1115 
1116     \sa isDateValid(), partsFromDate()
1117 */
1118 QDate QCalendar::dateFromParts(int year, int month, int day) const
1119 {
1120     qint64 jd;
1121     return d && d->dateToJulianDay(year, month, day, &jd)
1122         ? QDate::fromJulianDay(jd) : QDate();
1123 }
1124 
1125 QDate QCalendar::dateFromParts(const QCalendar::YearMonthDay &parts) const
1126 {
1127     return parts.isValid() ? dateFromParts(parts.year, parts.month, parts.day) : QDate();
1128 }
1129 
1130 /*!
1131     Converts a QDate to a year, month, and day of the month.
1132 
1133     The returned structure's isValid() shall be false if the calendar is unable
1134     to represent the given \a date. Otherwise its year, month, and day
1135     members record the so-named parts of its representation.
1136 
1137     \sa dateFromParts(), isProleptic(), hasYearZero()
1138 */
1139 QCalendar::YearMonthDay QCalendar::partsFromDate(QDate date) const
1140 {
1141     return d ? d->julianDayToDate(date.toJulianDay()) : YearMonthDay();
1142 }
1143 
1144 /*!
1145     Returns the day of the week number for the given \a date.
1146 
1147     Returns zero if the calendar is unable to represent the indicated date.
1148     Returns 1 for Monday through 7 for Sunday. Calendars with intercallary days
1149     may use other numbers to represent these.
1150 
1151     \sa partsFromDate(), Qt::DayOfWeek
1152 */
1153 int QCalendar::dayOfWeek(QDate date) const
1154 {
1155     return d ? d->dayOfWeek(date.toJulianDay()) : 0;
1156 }
1157 
1158 // Locale data access
1159 
1160 /*!
1161     Returns a suitably localised name for a month.
1162 
1163     The month is indicated by a number, with \a month = 1 meaning the first
1164     month of the year and subsequent months numbered accordingly. Returns an
1165     empty string if the \a month number is unrecognized.
1166 
1167     The \a year may be Unspecified, in which case the mapping from numbers to
1168     names for a typical year's months should be used. Some calendars have leap
1169     months that aren't always at the end of the year; their mapping of month
1170     numbers to names may then depend on the placement of a leap month. Thus the
1171     year should normally be specified, if known.
1172 
1173     The name is returned in the form that would normally be used in a full date,
1174     in the specified \a locale; the \a format determines how fully it shall be
1175     expressed (i.e. to what extent it is abbreviated).
1176 
1177     \sa standaloneMonthName(), maximumMonthsInYear(), dateTimeToString()
1178 */
1179 QString QCalendar::monthName(const QLocale &locale, int month, int year,
1180                              QLocale::FormatType format) const
1181 {
1182     const int maxMonth = year == Unspecified ? maximumMonthsInYear() : monthsInYear(year);
1183     if (!d || month < 1 || month > maxMonth)
1184         return QString();
1185 
1186     return d->monthName(locale, month, year, format);
1187 }
1188 
1189 /*!
1190     Returns a suitably localised standalone name for a month.
1191 
1192     The month is indicated by a number, with \a month = 1 meaning the first
1193     month of the year and subsequent months numbered accordingly. Returns an
1194     empty string if the \a month number is unrecognized.
1195 
1196     The \a year may be Unspecified, in which case the mapping from numbers to
1197     names for a typical year's months should be used. Some calendars have leap
1198     months that aren't always at the end of the year; their mapping of month
1199     numbers to names may then depend on the placement of a leap month. Thus the
1200     year should normally be specified, if known.
1201 
1202     The name is returned in the form that would be used in isolation in the
1203     specified \a locale; the \a format determines how fully it shall be
1204     expressed (i.e. to what extent it is abbreviated).
1205 
1206     \sa monthName(), maximumMonthsInYear(), dateTimeToString()
1207 */
1208 QString QCalendar::standaloneMonthName(const QLocale &locale, int month, int year,
1209                                        QLocale::FormatType format) const
1210 {
1211     const int maxMonth = year == Unspecified ? maximumMonthsInYear() : monthsInYear(year);
1212     if (!d || month < 1 || month > maxMonth)
1213         return QString();
1214 
1215     return d->standaloneMonthName(locale, month, year, format);
1216 }
1217 
1218 /*!
1219     Returns a suitably localised name for a day of the week.
1220 
1221     The days of the week are numbered from 1 for Monday through 7 for
1222     Sunday. Some calendars may support higher numbers for other days
1223     (e.g. intercallary days, that are not part of any week). Returns an empty
1224     string if the \a day number is unrecognized.
1225 
1226     The name is returned in the form that would normally be used in a full date,
1227     in the specified \a locale; the \a format determines how fully it shall be
1228     expressed (i.e. to what extent it is abbreviated).
1229 
1230     \sa standaloneWeekDayName(), dayOfWeek()
1231 */
1232 QString QCalendar::weekDayName(const QLocale &locale, int day,
1233                                QLocale::FormatType format) const
1234 {
1235     return d ? d->weekDayName(locale, day, format) : QString();
1236 }
1237 
1238 /*!
1239     Returns a suitably localised standalone name for a day of the week.
1240 
1241     The days of the week are numbered from 1 for Monday through 7 for
1242     Sunday. Some calendars may support higher numbers for other days
1243     (e.g. intercallary days, that are not part of any week). Returns an empty
1244     string if the \a day number is unrecognized.
1245 
1246     The name is returned in the form that would be used in isolation (for
1247     example as a column heading in a calendar's tabular display of a month with
1248     successive weeks as rows) in the specified \a locale; the \a format
1249     determines how fully it shall be expressed (i.e. to what extent it is
1250     abbreviated).
1251 
1252     \sa weekDayName(), dayOfWeek()
1253 */
1254 QString QCalendar::standaloneWeekDayName(const QLocale &locale, int day,
1255                                          QLocale::FormatType format) const
1256 {
1257     return d ? d->standaloneWeekDayName(locale, day, format) : QString();
1258 }
1259 
1260 /*!
1261     Returns a string representing a given date, time or date-time.
1262 
1263     If \a datetime is valid, it is represented and format specifiers for both
1264     date and time fields are recognized; otherwise, if \a dateOnly is valid, it
1265     is represented and only format specifiers for date fields are recognized;
1266     finally, if \a timeOnly is valid, it is represented and only format
1267     specifiers for time fields are recognized. If none of these is valid, an
1268     empty string is returned.
1269 
1270     See QDate::toString and QTime::toString() for the supported field
1271     specifiers.  Characters in \a format that are recognized as field specifiers
1272     are replaced by text representing appropriate data from the date and/or time
1273     being represented. The texts to represent them may depend on the \a locale
1274     specified. Other charagers in \a format are copied verbatim into the
1275     returned string.
1276 
1277     \sa monthName(), weekDayName(), QDate::toString(), QTime::toString()
1278 */
1279 QString QCalendar::dateTimeToString(QStringView format, const QDateTime &datetime,
1280                                     QDate dateOnly, QTime timeOnly,
1281                                     const QLocale &locale) const
1282 {
1283     return d ? d->dateTimeToString(format, datetime, dateOnly, timeOnly, locale) : QString();
1284 }
1285 
1286 /*!
1287     Returns a list of names of the available calendar systems.
1288 
1289     These may be supplied by plugins or other code linked into an application,
1290     in addition to the ones provided by Qt, some of which are controlled by
1291     features.
1292 */
1293 QStringList QCalendar::availableCalendars()
1294 {
1295     return QCalendarBackend::availableCalendars();
1296 }
1297 
1298 QT_END_NAMESPACE
