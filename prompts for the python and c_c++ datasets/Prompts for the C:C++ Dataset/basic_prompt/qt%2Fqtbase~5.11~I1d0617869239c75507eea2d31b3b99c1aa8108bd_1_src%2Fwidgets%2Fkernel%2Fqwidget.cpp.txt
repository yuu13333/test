Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2017 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtWidgets module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qapplication.h"
42 #include "qapplication_p.h"
43 #include "qbrush.h"
44 #include "qcursor.h"
45 #include "qdesktopwidget_p.h"
46 #include "qevent.h"
47 #include "qlayout.h"
48 #if QT_CONFIG(menu)
49 #include "qmenu.h"
50 #endif
51 #include "qmetaobject.h"
52 #include "qpixmap.h"
53 #include "qpointer.h"
54 #include "qstack.h"
55 #include "qstyle.h"
56 #include "qstylefactory.h"
57 #include "qvariant.h"
58 #include "qwidget.h"
59 #include "qstyleoption.h"
60 #include "qstylehints.h"
61 #ifndef QT_NO_ACCESSIBILITY
62 # include "qaccessible.h"
63 #endif
64 #if 0 // Used to be included in Qt4 for Q_WS_MAC
65 # include "qt_mac_p.h"
66 # include "qt_cocoa_helpers_mac_p.h"
67 # include "qmainwindow.h"
68 # include "qtoolbar.h"
69 # include <private/qmainwindowlayout_p.h>
70 #endif
71 #include <qpa/qplatformwindow.h>
72 #include "private/qwidgetwindow_p.h"
73 #include "qpainter.h"
74 #include "qtooltip.h"
75 #if QT_CONFIG(whatsthis)
76 #include "qwhatsthis.h"
77 #endif
78 #include "qdebug.h"
79 #include "private/qstylesheetstyle_p.h"
80 #include "private/qstyle_p.h"
81 #include "qproxystyle.h"
82 #include "qfileinfo.h"
83 #include <QtGui/private/qhighdpiscaling_p.h>
84 #include <QtGui/qinputmethod.h>
85 #include <QtGui/qopenglcontext.h>
86 #include <QtGui/private/qopenglcontext_p.h>
87 #include <QtGui/qoffscreensurface.h>
88 
89 #if QT_CONFIG(graphicseffect)
90 #include <private/qgraphicseffect_p.h>
91 #endif
92 #include <qbackingstore.h>
93 #include <private/qwidgetbackingstore_p.h>
94 #if 0 // Used to be included in Qt4 for Q_WS_MAC
95 # include <private/qpaintengine_mac_p.h>
96 #endif
97 #include <private/qpaintengine_raster_p.h>
98 
99 #include "qwidget_p.h"
100 #include <QtGui/private/qwindow_p.h>
101 #include "qaction_p.h"
102 #include "qlayout_p.h"
103 #if QT_CONFIG(graphicsview)
104 #include "QtWidgets/qgraphicsproxywidget.h"
105 #include "QtWidgets/qgraphicsscene.h"
106 #include "private/qgraphicsproxywidget_p.h"
107 #endif
108 #include "QtWidgets/qabstractscrollarea.h"
109 #include "private/qabstractscrollarea_p.h"
110 #include "private/qevent_p.h"
111 
112 #include "private/qgesturemanager_p.h"
113 
114 #ifdef QT_KEYPAD_NAVIGATION
115 #if QT_CONFIG(tabwidget)
116 #include "qtabwidget.h" // Needed in inTabWidget()
117 #endif
118 #endif // QT_KEYPAD_NAVIGATION
119 
120 #include "qwindowcontainer_p.h"
121 
122 #include <QtPlatformHeaders/qxcbwindowfunctions.h>
123 
124 // widget/widget data creation count
125 //#define QWIDGET_EXTRA_DEBUG
126 //#define ALIEN_DEBUG
127 
128 QT_BEGIN_NAMESPACE
129 
130 #if 0 // Used to be included in Qt4 for Q_WS_MAC
131 bool qt_mac_clearDirtyOnWidgetInsideDrawWidget = false;
132 #endif
133 
134 static inline bool qRectIntersects(const QRect &r1, const QRect &r2)
135 {
136     return (qMax(r1.left(), r2.left()) <= qMin(r1.right(), r2.right()) &&
137             qMax(r1.top(), r2.top()) <= qMin(r1.bottom(), r2.bottom()));
138 }
139 
140 #if 0 // Used to be included in Qt4 for Q_WS_MAC
141 #  define QT_NO_PAINT_DEBUG
142 #endif
143 
144 extern bool qt_sendSpontaneousEvent(QObject*, QEvent*); // qapplication.cpp
145 extern QDesktopWidget *qt_desktopWidget; // qapplication.cpp
146 
147 /*!
148     \internal
149     \class QWidgetBackingStoreTracker
150     \brief Class which allows tracking of which widgets are using a given backing store
151 
152     QWidgetBackingStoreTracker is a thin wrapper around a QWidgetBackingStore pointer,
153     which maintains a list of the QWidgets which are currently using the backing
154     store.  This list is modified via the registerWidget and unregisterWidget functions.
155  */
156 
157 QWidgetBackingStoreTracker::QWidgetBackingStoreTracker()
158     :   m_ptr(0)
159 {
160 
161 }
162 
163 QWidgetBackingStoreTracker::~QWidgetBackingStoreTracker()
164 {
165     delete m_ptr;
166 }
167 
168 /*!
169     \internal
170     Destroy the contained QWidgetBackingStore, if not null, and clear the list of
171     widgets using the backing store, then create a new QWidgetBackingStore, providing
172     the QWidget.
173  */
174 void QWidgetBackingStoreTracker::create(QWidget *widget)
175 {
176     destroy();
177     m_ptr = new QWidgetBackingStore(widget);
178 }
179 
180 /*!
181     \internal
182     Destroy the contained QWidgetBackingStore, if not null, and clear the list of
183     widgets using the backing store.
184  */
185 void QWidgetBackingStoreTracker::destroy()
186 {
187     delete m_ptr;
188     m_ptr = 0;
189     m_widgets.clear();
190 }
191 
192 /*!
193     \internal
194     Add the widget to the list of widgets currently using the backing store.
195     If the widget was already in the list, this function is a no-op.
196  */
197 void QWidgetBackingStoreTracker::registerWidget(QWidget *w)
198 {
199     Q_ASSERT(m_ptr);
200     Q_ASSERT(w->internalWinId());
201     Q_ASSERT(qt_widget_private(w)->maybeBackingStore() == m_ptr);
202     m_widgets.insert(w);
203 }
204 
205 /*!
206     \internal
207     Remove the widget from the list of widgets currently using the backing store.
208     If the widget was in the list, and removing it causes the list to be empty,
209     the backing store is deleted.
210     If the widget was not in the list, this function is a no-op.
211  */
212 void QWidgetBackingStoreTracker::unregisterWidget(QWidget *w)
213 {
214     if (m_widgets.remove(w) && m_widgets.isEmpty()) {
215         delete m_ptr;
216         m_ptr = 0;
217     }
218 }
219 
220 /*!
221     \internal
222     Recursively remove widget and all of its descendents.
223  */
224 void QWidgetBackingStoreTracker::unregisterWidgetSubtree(QWidget *widget)
225 {
226     unregisterWidget(widget);
227     foreach (QObject *child, widget->children())
228         if (QWidget *childWidget = qobject_cast<QWidget *>(child))
229             unregisterWidgetSubtree(childWidget);
230 }
231 
232 QWidgetPrivate::QWidgetPrivate(int version)
233     : QObjectPrivate(version)
234       , extra(0)
235       , focus_next(0)
236       , focus_prev(0)
237       , focus_child(0)
238       , layout(0)
239       , needsFlush(0)
240       , redirectDev(0)
241       , widgetItem(0)
242       , extraPaintEngine(0)
243       , polished(0)
244       , graphicsEffect(0)
245 #if !defined(QT_NO_IM)
246       , imHints(Qt::ImhNone)
247 #endif
248 #ifndef QT_NO_TOOLTIP
249       , toolTipDuration(-1)
250 #endif
251       , inheritedFontResolveMask(0)
252       , inheritedPaletteResolveMask(0)
253       , leftmargin(0)
254       , topmargin(0)
255       , rightmargin(0)
256       , bottommargin(0)
257       , leftLayoutItemMargin(0)
258       , topLayoutItemMargin(0)
259       , rightLayoutItemMargin(0)
260       , bottomLayoutItemMargin(0)
261       , hd(0)
262       , size_policy(QSizePolicy::Preferred, QSizePolicy::Preferred)
263       , fg_role(QPalette::NoRole)
264       , bg_role(QPalette::NoRole)
265       , dirtyOpaqueChildren(1)
266       , isOpaque(0)
267       , retainSizeWhenHiddenChanged(0)
268       , inDirtyList(0)
269       , isScrolled(0)
270       , isMoved(0)
271       , usesDoubleBufferedGLContext(0)
272       , mustHaveWindowHandle(0)
273       , renderToTexture(0)
274       , textureChildSeen(0)
275 #ifndef QT_NO_IM
276       , inheritsInputMethodHints(0)
277 #endif
278 #ifndef QT_NO_OPENGL
279       , renderToTextureReallyDirty(1)
280       , renderToTextureComposeActive(0)
281 #endif
282       , childrenHiddenByWState(0)
283       , childrenShownByExpose(0)
284 #if defined(Q_OS_WIN)
285       , noPaintOnScreen(0)
286 #endif
287 #if 0 // Used to be included in Qt4 for Q_WS_X11
288       , picture(0)
289 #elif 0 // Used to be included in Qt4 for Q_WS_WIN
290   #ifndef QT_NO_GESTURES
291       , nativeGesturePanEnabled(0)
292   #endif
293 #elif 0 // Used to be included in Qt4 for Q_WS_MAC
294       , needWindowChange(0)
295       , window_event(0)
296       , qd_hd(0)
297 #endif
298 {
299     if (Q_UNLIKELY(!qApp)) {
300         qFatal("QWidget: Must construct a QApplication before a QWidget");
301         return;
302     }
303 
304 #ifdef QT_BUILD_INTERNAL
305     // Don't check the version parameter in internal builds.
306     // This allows incompatible versions to be loaded, possibly for testing.
307     Q_UNUSED(version);
308 #else
309     if (Q_UNLIKELY(version != QObjectPrivateVersion))
310         qFatal("Cannot mix incompatible Qt library (version 0x%x) with this library (version 0x%x)",
311                 version, QObjectPrivateVersion);
312 #endif
313 
314     isWidget = true;
315     memset(high_attributes, 0, sizeof(high_attributes));
316 #if 0 // Used to be included in Qt4 for Q_WS_MAC
317     drawRectOriginalAdded = false;
318     originalDrawMethod = true;
319     changeMethods = false;
320     isInUnifiedToolbar = false;
321     unifiedSurface = 0;
322     toolbar_ancestor = 0;
323     flushRequested = false;
324     touchEventsEnabled = false;
325 #endif
326 #ifdef QWIDGET_EXTRA_DEBUG
327     static int count = 0;
328     qDebug() << "widgets" << ++count;
329 #endif
330 }
331 
332 
333 QWidgetPrivate::~QWidgetPrivate()
334 {
335     if (widgetItem)
336         widgetItem->wid = 0;
337 
338     if (extra)
339         deleteExtra();
340 }
341 
342 /*!
343     \internal
344 */
345 void QWidgetPrivate::scrollChildren(int dx, int dy)
346 {
347     Q_Q(QWidget);
348     if (q->children().size() > 0) {        // scroll children
349         QPoint pd(dx, dy);
350         QObjectList childObjects = q->children();
351         for (int i = 0; i < childObjects.size(); ++i) { // move all children
352             QWidget *w = qobject_cast<QWidget*>(childObjects.at(i));
353             if (w && !w->isWindow()) {
354                 QPoint oldp = w->pos();
355                 QRect  r(w->pos() + pd, w->size());
356                 w->data->crect = r;
357                 if (w->testAttribute(Qt::WA_WState_Created))
358                     w->d_func()->setWSGeometry();
359                 w->d_func()->setDirtyOpaqueRegion();
360                 QMoveEvent e(r.topLeft(), oldp);
361                 QApplication::sendEvent(w, &e);
362             }
363         }
364     }
365 }
366 
367 void QWidgetPrivate::setWSGeometry()
368 {
369     Q_Q(QWidget);
370     if (QWindow *window = q->windowHandle())
371         window->setGeometry(data.crect);
372 }
373 
374 void QWidgetPrivate::updateWidgetTransform(QEvent *event)
375 {
376     Q_Q(QWidget);
377     if (q == QGuiApplication::focusObject() || event->type() == QEvent::FocusIn) {
378         QTransform t;
379         QPoint p = q->mapTo(q->topLevelWidget(), QPoint(0,0));
380         t.translate(p.x(), p.y());
381         QGuiApplication::inputMethod()->setInputItemTransform(t);
382         QGuiApplication::inputMethod()->setInputItemRectangle(q->rect());
383         QGuiApplication::inputMethod()->update(Qt::ImInputItemClipRectangle);
384     }
385 }
386 
387 #ifdef QT_KEYPAD_NAVIGATION
388 QPointer<QWidget> QWidgetPrivate::editingWidget;
389 
390 /*!
391     Returns \c true if this widget currently has edit focus; otherwise false.
392 
393     This feature is only available in Qt for Embedded Linux.
394 
395     \sa setEditFocus(), QApplication::keypadNavigationEnabled()
396 */
397 bool QWidget::hasEditFocus() const
398 {
399     const QWidget* w = this;
400     while (w->d_func()->extra && w->d_func()->extra->focus_proxy)
401         w = w->d_func()->extra->focus_proxy;
402     return QWidgetPrivate::editingWidget == w;
403 }
404 
405 /*!
406     \fn void QWidget::setEditFocus(bool enable)
407 
408     If \a enable is true, make this widget have edit focus, in which
409     case Qt::Key_Up and Qt::Key_Down will be delivered to the widget
410     normally; otherwise, Qt::Key_Up and Qt::Key_Down are used to
411     change focus.
412 
413     This feature is only available in Qt for Embedded Linux.
414 
415     \sa hasEditFocus(), QApplication::keypadNavigationEnabled()
416 */
417 void QWidget::setEditFocus(bool on)
418 {
419     QWidget *f = this;
420     while (f->d_func()->extra && f->d_func()->extra->focus_proxy)
421         f = f->d_func()->extra->focus_proxy;
422 
423     if (QWidgetPrivate::editingWidget && QWidgetPrivate::editingWidget != f)
424         QWidgetPrivate::editingWidget->setEditFocus(false);
425 
426     if (on && !f->hasFocus())
427         f->setFocus();
428 
429     if ((!on && !QWidgetPrivate::editingWidget)
430         || (on && QWidgetPrivate::editingWidget == f)) {
431         return;
432     }
433 
434     if (!on && QWidgetPrivate::editingWidget == f) {
435         QWidgetPrivate::editingWidget = 0;
436         QEvent event(QEvent::LeaveEditFocus);
437         QApplication::sendEvent(f, &event);
438         QApplication::sendEvent(f->style(), &event);
439     } else if (on) {
440         QWidgetPrivate::editingWidget = f;
441         QEvent event(QEvent::EnterEditFocus);
442         QApplication::sendEvent(f, &event);
443         QApplication::sendEvent(f->style(), &event);
444     }
445 }
446 #endif
447 
448 /*!
449     \property QWidget::autoFillBackground
450     \brief whether the widget background is filled automatically
451     \since 4.1
452 
453     If enabled, this property will cause Qt to fill the background of the
454     widget before invoking the paint event. The color used is defined by the
455     QPalette::Window color role from the widget's \l{QPalette}{palette}.
456 
457     In addition, Windows are always filled with QPalette::Window, unless the
458     WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.
459 
460     This property cannot be turned off (i.e., set to false) if a widget's
461     parent has a static gradient for its background.
462 
463     \warning Use this property with caution in conjunction with
464     \l{Qt Style Sheets}. When a widget has a style sheet with a valid
465     background or a border-image, this property is automatically disabled.
466 
467     By default, this property is \c false.
468 
469     \sa Qt::WA_OpaquePaintEvent, Qt::WA_NoSystemBackground,
470     {QWidget#Transparency and Double Buffering}{Transparency and Double Buffering}
471 */
472 bool QWidget::autoFillBackground() const
473 {
474     Q_D(const QWidget);
475     return d->extra && d->extra->autoFillBackground;
476 }
477 
478 void QWidget::setAutoFillBackground(bool enabled)
479 {
480     Q_D(QWidget);
481     if (!d->extra)
482         d->createExtra();
483     if (d->extra->autoFillBackground == enabled)
484         return;
485 
486     d->extra->autoFillBackground = enabled;
487     d->updateIsOpaque();
488     update();
489     d->updateIsOpaque();
490 }
491 
492 /*!
493     \class QWidget
494     \brief The QWidget class is the base class of all user interface objects.
495 
496     \ingroup basicwidgets
497     \inmodule QtWidgets
498 
499     The widget is the atom of the user interface: it receives mouse, keyboard
500     and other events from the window system, and paints a representation of
501     itself on the screen. Every widget is rectangular, and they are sorted in a
502     Z-order. A widget is clipped by its parent and by the widgets in front of
503     it.
504 
505     A widget that is not embedded in a parent widget is called a window.
506     Usually, windows have a frame and a title bar, although it is also possible
507     to create windows without such decoration using suitable
508     \l{Qt::WindowFlags}{window flags}). In Qt, QMainWindow and the various
509     subclasses of QDialog are the most common window types.
510 
511     Every widget's constructor accepts one or two standard arguments:
512 
513     \list 1
514         \li  \c{QWidget *parent = 0} is the parent of the new widget. If it is 0
515             (the default), the new widget will be a window. If not, it will be
516             a child of \e parent, and be constrained by \e parent's geometry
517             (unless you specify Qt::Window as window flag).
518         \li  \c{Qt::WindowFlags f = 0} (where available) sets the window flags;
519             the default is suitable for almost all widgets, but to get, for
520             example, a window without a window system frame, you must use
521             special flags.
522     \endlist
523 
524     QWidget has many member functions, but some of them have little direct
525     functionality; for example, QWidget has a font property, but never uses
526     this itself. There are many subclasses which provide real functionality,
527     such as QLabel, QPushButton, QListWidget, and QTabWidget.
528 
529 
530     \section1 Top-Level and Child Widgets
531 
532     A widget without a parent widget is always an independent window (top-level
533     widget). For these widgets, setWindowTitle() and setWindowIcon() set the
534     title bar and icon respectively.
535 
536     Non-window widgets are child widgets, displayed within their parent
537     widgets. Most widgets in Qt are mainly useful as child widgets. For
538     example, it is possible to display a button as a top-level window, but most
539     people prefer to put their buttons inside other widgets, such as QDialog.
540 
541     \image parent-child-widgets.png A parent widget containing various child widgets.
542 
543     The diagram above shows a QGroupBox widget being used to hold various child
544     widgets in a layout provided by QGridLayout. The QLabel child widgets have
545     been outlined to indicate their full sizes.
546 
547     If you want to use a QWidget to hold child widgets you will usually want to
548     add a layout to the parent QWidget. See \l{Layout Management} for more
549     information.
550 
551 
552     \section1 Composite Widgets
553 
554     When a widget is used as a container to group a number of child widgets, it
555     is known as a composite widget. These can be created by constructing a
556     widget with the required visual properties - a QFrame, for example - and
557     adding child widgets to it, usually managed by a layout. The above diagram
558     shows such a composite widget that was created using Qt Designer.
559 
560     Composite widgets can also be created by subclassing a standard widget,
561     such as QWidget or QFrame, and adding the necessary layout and child
562     widgets in the constructor of the subclass. Many of the \l{Qt Widgets Examples}
563     {examples provided with Qt} use this approach, and it is also covered in
564     the Qt \l{Tutorials}.
565 
566 
567     \section1 Custom Widgets and Painting
568 
569     Since QWidget is a subclass of QPaintDevice, subclasses can be used to
570     display custom content that is composed using a series of painting
571     operations with an instance of the QPainter class. This approach contrasts
572     with the canvas-style approach used by the \l{Graphics View}
573     {Graphics View Framework} where items are added to a scene by the
574     application and are rendered by the framework itself.
575 
576     Each widget performs all painting operations from within its paintEvent()
577     function. This is called whenever the widget needs to be redrawn, either
578     as a result of some external change or when requested by the application.
579 
580     The \l{widgets/analogclock}{Analog Clock example} shows how a simple widget
581     can handle paint events.
582 
583 
584     \section1 Size Hints and Size Policies
585 
586     When implementing a new widget, it is almost always useful to reimplement
587     sizeHint() to provide a reasonable default size for the widget and to set
588     the correct size policy with setSizePolicy().
589 
590     By default, composite widgets which do not provide a size hint will be
591     sized according to the space requirements of their child widgets.
592 
593     The size policy lets you supply good default behavior for the layout
594     management system, so that other widgets can contain and manage yours
595     easily. The default size policy indicates that the size hint represents
596     the preferred size of the widget, and this is often good enough for many
597     widgets.
598 
599     \note The size of top-level widgets are constrained to 2/3 of the desktop's
600     height and width. You can resize() the widget manually if these bounds are
601     inadequate.
602 
603 
604     \section1 Events
605 
606     Widgets respond to events that are typically caused by user actions. Qt
607     delivers events to widgets by calling specific event handler functions with
608     instances of QEvent subclasses containing information about each event.
609 
610     If your widget only contains child widgets, you probably do not need to
611     implement any event handlers. If you want to detect a mouse click in a
612     child widget call the child's underMouse() function inside the widget's
613     mousePressEvent().
614 
615     The \l{widgets/scribble}{Scribble example} implements a wider set of
616     events to handle mouse movement, button presses, and window resizing.
617 
618     You will need to supply the behavior and content for your own widgets, but
619     here is a brief overview of the events that are relevant to QWidget,
620     starting with the most common ones:
621 
622     \list
623         \li  paintEvent() is called whenever the widget needs to be repainted.
624             Every widget displaying custom content must implement it. Painting
625             using a QPainter can only take place in a paintEvent() or a
626             function called by a paintEvent().
627         \li  resizeEvent() is called when the widget has been resized.
628         \li  mousePressEvent() is called when a mouse button is pressed while
629             the mouse cursor is inside the widget, or when the widget has
630             grabbed the mouse using grabMouse(). Pressing the mouse without
631             releasing it is effectively the same as calling grabMouse().
632         \li  mouseReleaseEvent() is called when a mouse button is released. A
633             widget receives mouse release events when it has received the
634             corresponding mouse press event. This means that if the user
635             presses the mouse inside \e your widget, then drags the mouse
636             somewhere else before releasing the mouse button, \e your widget
637             receives the release event. There is one exception: if a popup menu
638             appears while the mouse button is held down, this popup immediately
639             steals the mouse events.
640         \li  mouseDoubleClickEvent() is called when the user double-clicks in
641             the widget. If the user double-clicks, the widget receives a mouse
642             press event, a mouse release event, (a mouse click event,) a second
643             mouse press, this event and finally a second mouse release event.
644             (Some mouse move events may also be
645             received if the mouse is not held steady during this operation.) It
646             is \e{not possible} to distinguish a click from a double-click
647             until the second click arrives. (This is one reason why most GUI
648             books recommend that double-clicks be an extension of
649             single-clicks, rather than trigger a different action.)
650     \endlist
651 
652     Widgets that accept keyboard input need to reimplement a few more event
653     handlers:
654 
655     \list
656         \li  keyPressEvent() is called whenever a key is pressed, and again when
657             a key has been held down long enough for it to auto-repeat. The
658             \uicontrol Tab and \uicontrol Shift+Tab keys are only passed to the widget if
659             they are not used by the focus-change mechanisms. To force those
660             keys to be processed by your widget, you must reimplement
661             QWidget::event().
662         \li  focusInEvent() is called when the widget gains keyboard focus
663             (assuming you have called setFocusPolicy()). Well-behaved widgets
664             indicate that they own the keyboard focus in a clear but discreet
665             way.
666         \li  focusOutEvent() is called when the widget loses keyboard focus.
667     \endlist
668 
669     You may be required to also reimplement some of the less common event
670     handlers:
671 
672     \list
673         \li  mouseMoveEvent() is called whenever the mouse moves while a mouse
674             button is held down. This can be useful during drag and drop
675             operations. If you call \l{setMouseTracking()}{setMouseTracking}(true),
676             you get mouse move events even when no buttons are held down.
677             (See also the \l{Drag and Drop} guide.)
678         \li  keyReleaseEvent() is called whenever a key is released and while it
679             is held down (if the key is auto-repeating). In that case, the
680             widget will receive a pair of key release and key press event for
681             every repeat. The \uicontrol Tab and \uicontrol Shift+Tab keys are only passed
682             to the widget if they are not used by the focus-change mechanisms.
683             To force those keys to be processed by your widget, you must
684             reimplement QWidget::event().
685         \li  wheelEvent() is called whenever the user turns the mouse wheel
686             while the widget has the focus.
687         \li  enterEvent() is called when the mouse enters the widget's screen
688             space. (This excludes screen space owned by any of the widget's
689             children.)
690         \li  leaveEvent() is called when the mouse leaves the widget's screen
691             space. If the mouse enters a child widget it will not cause a
692             leaveEvent().
693         \li  moveEvent() is called when the widget has been moved relative to
694             its parent.
695         \li  closeEvent() is called when the user closes the widget (or when
696             close() is called).
697     \endlist
698 
699     There are also some rather obscure events described in the documentation
700     for QEvent::Type. To handle these events, you need to reimplement event()
701     directly.
702 
703     The default implementation of event() handles \uicontrol Tab and \uicontrol Shift+Tab
704     (to move the keyboard focus), and passes on most of the other events to
705     one of the more specialized handlers above.
706 
707     Events and the mechanism used to deliver them are covered in
708     \l{The Event System}.
709 
710     \section1 Groups of Functions and Properties
711 
712     \table
713     \header \li Context \li Functions and Properties
714 
715     \row \li Window functions \li
716         show(),
717         hide(),
718         raise(),
719         lower(),
720         close().
721 
722     \row \li Top-level windows \li
723         \l windowModified, \l windowTitle, \l windowIcon,
724         \l isActiveWindow, activateWindow(), \l minimized, showMinimized(),
725         \l maximized, showMaximized(), \l fullScreen, showFullScreen(),
726         showNormal().
727 
728     \row \li Window contents \li
729         update(),
730         repaint(),
731         scroll().
732 
733     \row \li Geometry \li
734         \l pos, x(), y(), \l rect, \l size, width(), height(), move(), resize(),
735         \l sizePolicy, sizeHint(), minimumSizeHint(),
736         updateGeometry(), layout(),
737         \l frameGeometry, \l geometry, \l childrenRect, \l childrenRegion,
738         adjustSize(),
739         mapFromGlobal(), mapToGlobal(),
740         mapFromParent(), mapToParent(),
741         \l maximumSize, \l minimumSize, \l sizeIncrement,
742         \l baseSize, setFixedSize()
743 
744     \row \li Mode \li
745         \l visible, isVisibleTo(),
746         \l enabled, isEnabledTo(),
747         \l modal,
748         isWindow(),
749         \l mouseTracking,
750         \l updatesEnabled,
751         visibleRegion().
752 
753     \row \li Look and feel \li
754         style(),
755         setStyle(),
756         \l styleSheet,
757         \l cursor,
758         \l font,
759         \l palette,
760         backgroundRole(), setBackgroundRole(),
761         fontInfo(), fontMetrics().
762 
763     \row \li Keyboard focus functions \li
764         \l focus, \l focusPolicy,
765         setFocus(), clearFocus(), setTabOrder(), setFocusProxy(),
766         focusNextChild(), focusPreviousChild().
767 
768     \row \li Mouse and keyboard grabbing \li
769         grabMouse(), releaseMouse(),
770         grabKeyboard(), releaseKeyboard(),
771         mouseGrabber(), keyboardGrabber().
772 
773     \row \li Event handlers \li
774         event(),
775         mousePressEvent(),
776         mouseReleaseEvent(),
777         mouseDoubleClickEvent(),
778         mouseMoveEvent(),
779         keyPressEvent(),
780         keyReleaseEvent(),
781         focusInEvent(),
782         focusOutEvent(),
783         wheelEvent(),
784         enterEvent(),
785         leaveEvent(),
786         paintEvent(),
787         moveEvent(),
788         resizeEvent(),
789         closeEvent(),
790         dragEnterEvent(),
791         dragMoveEvent(),
792         dragLeaveEvent(),
793         dropEvent(),
794         childEvent(),
795         showEvent(),
796         hideEvent(),
797         customEvent().
798         changeEvent(),
799 
800     \row \li System functions \li
801         parentWidget(), window(), setParent(), winId(),
802         find(), metric().
803 
804     \row \li Context menu \li
805        contextMenuPolicy, contextMenuEvent(),
806        customContextMenuRequested(), actions()
807 
808     \row \li Interactive help \li
809         setToolTip(), setWhatsThis()
810 
811     \endtable
812 
813 
814     \section1 Widget Style Sheets
815 
816     In addition to the standard widget styles for each platform, widgets can
817     also be styled according to rules specified in a \l{styleSheet}
818     {style sheet}. This feature enables you to customize the appearance of
819     specific widgets to provide visual cues to users about their purpose. For
820     example, a button could be styled in a particular way to indicate that it
821     performs a destructive action.
822 
823     The use of widget style sheets is described in more detail in the
824     \l{Qt Style Sheets} document.
825 
826 
827     \section1 Transparency and Double Buffering
828 
829     Since Qt 4.0, QWidget automatically double-buffers its painting, so there
830     is no need to write double-buffering code in paintEvent() to avoid
831     flicker.
832 
833     Since Qt 4.1, the Qt::WA_ContentsPropagated widget attribute has been
834     deprecated. Instead, the contents of parent widgets are propagated by
835     default to each of their children as long as Qt::WA_PaintOnScreen is not
836     set. Custom widgets can be written to take advantage of this feature by
837     updating irregular regions (to create non-rectangular child widgets), or
838     painting with colors that have less than full alpha component. The
839     following diagram shows how attributes and properties of a custom widget
840     can be fine-tuned to achieve different effects.
841 
842     \image propagation-custom.png
843 
844     In the above diagram, a semi-transparent rectangular child widget with an
845     area removed is constructed and added to a parent widget (a QLabel showing
846     a pixmap). Then, different properties and widget attributes are set to
847     achieve different effects:
848 
849     \list
850         \li  The left widget has no additional properties or widget attributes
851             set. This default state suits most custom widgets using
852             transparency, are irregularly-shaped, or do not paint over their
853             entire area with an opaque brush.
854         \li  The center widget has the \l autoFillBackground property set. This
855             property is used with custom widgets that rely on the widget to
856             supply a default background, and do not paint over their entire
857             area with an opaque brush.
858         \li  The right widget has the Qt::WA_OpaquePaintEvent widget attribute
859             set. This indicates that the widget will paint over its entire area
860             with opaque colors. The widget's area will initially be
861             \e{uninitialized}, represented in the diagram with a red diagonal
862             grid pattern that shines through the overpainted area. The
863             Qt::WA_OpaquePaintArea attribute is useful for widgets that need to
864             paint their own specialized contents quickly and do not need a
865             default filled background.
866     \endlist
867 
868     To rapidly update custom widgets with simple background colors, such as
869     real-time plotting or graphing widgets, it is better to define a suitable
870     background color (using setBackgroundRole() with the
871     QPalette::Window role), set the \l autoFillBackground property, and only
872     implement the necessary drawing functionality in the widget's paintEvent().
873 
874     To rapidly update custom widgets that constantly paint over their entire
875     areas with opaque content, e.g., video streaming widgets, it is better to
876     set the widget's Qt::WA_OpaquePaintEvent, avoiding any unnecessary overhead
877     associated with repainting the widget's background.
878 
879     If a widget has both the Qt::WA_OpaquePaintEvent widget attribute \e{and}
880     the \l autoFillBackground property set, the Qt::WA_OpaquePaintEvent
881     attribute takes precedence. Depending on your requirements, you should
882     choose either one of them.
883 
884     Since Qt 4.1, the contents of parent widgets are also propagated to
885     standard Qt widgets. This can lead to some unexpected results if the
886     parent widget is decorated in a non-standard way, as shown in the diagram
887     below.
888 
889     \image propagation-standard.png
890 
891     The scope for customizing the painting behavior of standard Qt widgets,
892     without resorting to subclassing, is slightly less than that possible for
893     custom widgets. Usually, the desired appearance of a standard widget can be
894     achieved by setting its \l autoFillBackground property.
895 
896 
897     \section1 Creating Translucent Windows
898 
899     Since Qt 4.5, it has been possible to create windows with translucent regions
900     on window systems that support compositing.
901 
902     To enable this feature in a top-level widget, set its Qt::WA_TranslucentBackground
903     attribute with setAttribute() and ensure that its background is painted with
904     non-opaque colors in the regions you want to be partially transparent.
905 
906     Platform notes:
907 
908     \list
909     \li X11: This feature relies on the use of an X server that supports ARGB visuals
910     and a compositing window manager.
911     \li Windows: The widget needs to have the Qt::FramelessWindowHint window flag set
912     for the translucency to work.
913     \endlist
914 
915 
916     \section1 Native Widgets vs Alien Widgets
917 
918     Introduced in Qt 4.4, alien widgets are widgets unknown to the windowing
919     system. They do not have a native window handle associated with them. This
920     feature significantly speeds up widget painting, resizing, and removes flicker.
921 
922     Should you require the old behavior with native windows, you can choose
923     one of the following options:
924 
925     \list 1
926         \li  Use the \c{QT_USE_NATIVE_WINDOWS=1} in your environment.
927         \li  Set the Qt::AA_NativeWindows attribute on your application. All
928             widgets will be native widgets.
929         \li  Set the Qt::WA_NativeWindow attribute on widgets: The widget itself
930             and all of its ancestors will become native (unless
931             Qt::WA_DontCreateNativeAncestors is set).
932         \li  Call QWidget::winId to enforce a native window (this implies 3).
933         \li  Set the Qt::WA_PaintOnScreen attribute to enforce a native window
934             (this implies 3).
935     \endlist
936 
937     \sa QEvent, QPainter, QGridLayout, QBoxLayout
938 
939 */
940 
941 QWidgetMapper *QWidgetPrivate::mapper = 0;          // widget with wid
942 QWidgetSet *QWidgetPrivate::allWidgets = 0;         // widgets with no wid
943 
944 
945 /*****************************************************************************
946   QWidget utility functions
947  *****************************************************************************/
948 
949 QRegion qt_dirtyRegion(QWidget *widget)
950 {
951     if (!widget)
952         return QRegion();
953 
954     QWidgetBackingStore *bs = qt_widget_private(widget)->maybeBackingStore();
955     if (!bs)
956         return QRegion();
957 
958     return bs->dirtyRegion(widget);
959 }
960 
961 /*****************************************************************************
962   QWidget member functions
963  *****************************************************************************/
964 
965 /*
966     Widget state flags:
967   \list
968   \li Qt::WA_WState_Created The widget has a valid winId().
969   \li Qt::WA_WState_Visible The widget is currently visible.
970   \li Qt::WA_WState_Hidden The widget is hidden, i.e. it won't
971   become visible unless you call show() on it. Qt::WA_WState_Hidden
972   implies !Qt::WA_WState_Visible.
973   \li Qt::WA_WState_CompressKeys Compress keyboard events.
974   \li Qt::WA_WState_BlockUpdates Repaints and updates are disabled.
975   \li Qt::WA_WState_InPaintEvent Currently processing a paint event.
976   \li Qt::WA_WState_Reparented The widget has been reparented.
977   \li Qt::WA_WState_ConfigPending A configuration (resize/move) event is pending.
978   \li Qt::WA_WState_DND (Deprecated) The widget supports drag and drop, see setAcceptDrops().
979   \endlist
980 */
981 
982 struct QWidgetExceptionCleaner
983 {
984     /* this cleans up when the constructor throws an exception */
985     static inline void cleanup(QWidget *that, QWidgetPrivate *d)
986     {
987 #ifdef QT_NO_EXCEPTIONS
988         Q_UNUSED(that);
989         Q_UNUSED(d);
990 #else
991         QWidgetPrivate::allWidgets->remove(that);
992         if (d->focus_next != that) {
993             if (d->focus_next)
994                 d->focus_next->d_func()->focus_prev = d->focus_prev;
995             if (d->focus_prev)
996                 d->focus_prev->d_func()->focus_next = d->focus_next;
997         }
998 #endif
999     }
1000 };
1001 
1002 /*!
1003     Constructs a widget which is a child of \a parent, with  widget
1004     flags set to \a f.
1005 
1006     If \a parent is 0, the new widget becomes a window. If
1007     \a parent is another widget, this widget becomes a child window
1008     inside \a parent. The new widget is deleted when its \a parent is
1009     deleted.
1010 
1011     The widget flags argument, \a f, is normally 0, but it can be set
1012     to customize the frame of a window (i.e. \a
1013     parent must be 0). To customize the frame, use a value composed
1014     from the bitwise OR of any of the \l{Qt::WindowFlags}{window flags}.
1015 
1016     If you add a child widget to an already visible widget you must
1017     explicitly show the child to make it visible.
1018 
1019     Note that the X11 version of Qt may not be able to deliver all
1020     combinations of style flags on all systems. This is because on
1021     X11, Qt can only ask the window manager, and the window manager
1022     can override the application's settings. On Windows, Qt can set
1023     whatever flags you want.
1024 
1025     \sa windowFlags
1026 */
1027 QWidget::QWidget(QWidget *parent, Qt::WindowFlags f)
1028     : QObject(*new QWidgetPrivate, 0), QPaintDevice()
1029 {
1030     QT_TRY {
1031         d_func()->init(parent, f);
1032     } QT_CATCH(...) {
1033         QWidgetExceptionCleaner::cleanup(this, d_func());
1034         QT_RETHROW;
1035     }
1036 }
1037 
1038 
1039 /*! \internal
1040 */
1041 QWidget::QWidget(QWidgetPrivate &dd, QWidget* parent, Qt::WindowFlags f)
1042     : QObject(dd, 0), QPaintDevice()
1043 {
1044     Q_D(QWidget);
1045     QT_TRY {
1046         d->init(parent, f);
1047     } QT_CATCH(...) {
1048         QWidgetExceptionCleaner::cleanup(this, d_func());
1049         QT_RETHROW;
1050     }
1051 }
1052 
1053 /*!
1054     \internal
1055 */
1056 int QWidget::devType() const
1057 {
1058     return QInternal::Widget;
1059 }
1060 
1061 
1062 //### w is a "this" ptr, passed as a param because QWorkspace needs special logic
1063 void QWidgetPrivate::adjustFlags(Qt::WindowFlags &flags, QWidget *w)
1064 {
1065     bool customize =  (flags & (Qt::CustomizeWindowHint
1066             | Qt::FramelessWindowHint
1067             | Qt::WindowTitleHint
1068             | Qt::WindowSystemMenuHint
1069             | Qt::WindowMinimizeButtonHint
1070             | Qt::WindowMaximizeButtonHint
1071             | Qt::WindowCloseButtonHint
1072             | Qt::WindowContextHelpButtonHint));
1073 
1074     uint type = (flags & Qt::WindowType_Mask);
1075 
1076     if ((type == Qt::Widget || type == Qt::SubWindow) && w && !w->parent()) {
1077         type = Qt::Window;
1078         flags |= Qt::Window;
1079     }
1080 
1081     if (flags & Qt::CustomizeWindowHint) {
1082         // modify window flags to make them consistent.
1083         // Only enable this on non-Mac platforms. Since the old way of doing this would
1084         // interpret WindowSystemMenuHint as a close button and we can't change that behavior
1085         // we can't just add this in.
1086 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
1087         if ((flags & (Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint))
1088 #  ifdef Q_OS_WIN
1089             && type != Qt::Dialog // QTBUG-2027, allow for menu-less dialogs.
1090 #  endif
1091            ) {
1092             flags |= Qt::WindowSystemMenuHint;
1093 #else
1094         if (flags & (Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint
1095                      | Qt::WindowSystemMenuHint)) {
1096 #endif
1097             flags |= Qt::WindowTitleHint;
1098             flags &= ~Qt::FramelessWindowHint;
1099         }
1100     } else if (customize && !(flags & Qt::FramelessWindowHint)) {
1101         // if any of the window hints that affect the titlebar are set
1102         // and the window is supposed to have frame, we add a titlebar
1103         // and system menu by default.
1104         flags |= Qt::WindowSystemMenuHint;
1105         flags |= Qt::WindowTitleHint;
1106     }
1107     if (customize)
1108         ; // don't modify window flags if the user explicitly set them.
1109     else if (type == Qt::Dialog || type == Qt::Sheet) {
1110         flags |= Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint;
1111         // ### fixme: Qt 6: Never set Qt::WindowContextHelpButtonHint flag automatically
1112         if (!QApplicationPrivate::testAttribute(Qt::AA_DisableWindowContextHelpButton))
1113             flags |= Qt::WindowContextHelpButtonHint;
1114     } else if (type == Qt::Tool)
1115         flags |= Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint;
1116     else
1117         flags |= Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowMinimizeButtonHint |
1118                 Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint | Qt::WindowFullscreenButtonHint;
1119     if (w->testAttribute(Qt::WA_TransparentForMouseEvents))
1120         flags |= Qt::WindowTransparentForInput;
1121 }
1122 
1123 void QWidgetPrivate::init(QWidget *parentWidget, Qt::WindowFlags f)
1124 {
1125     Q_Q(QWidget);
1126     if (Q_UNLIKELY(!qobject_cast<QApplication *>(QCoreApplication::instance())))
1127         qFatal("QWidget: Cannot create a QWidget without QApplication");
1128 
1129     Q_ASSERT(allWidgets);
1130     if (allWidgets)
1131         allWidgets->insert(q);
1132 
1133     int targetScreen = -1;
1134     if (parentWidget && parentWidget->windowType() == Qt::Desktop) {
1135         const QDesktopScreenWidget *sw = qobject_cast<const QDesktopScreenWidget *>(parentWidget);
1136         targetScreen = sw ? sw->screenNumber() : 0;
1137         parentWidget = 0;
1138     }
1139 
1140     q->data = &data;
1141 
1142 #ifndef QT_NO_THREAD
1143     if (!parent) {
1144         Q_ASSERT_X(q->thread() == qApp->thread(), "QWidget",
1145                    "Widgets must be created in the GUI thread.");
1146     }
1147 #endif
1148 
1149 #if 0 // Used to be included in Qt4 for Q_WS_X11
1150     if (desktopWidget) {
1151         // make sure the widget is created on the same screen as the
1152         // programmer specified desktop widget
1153         xinfo = desktopWidget->d_func()->xinfo;
1154     }
1155 #endif
1156     if (targetScreen >= 0) {
1157         topData()->initialScreenIndex = targetScreen;
1158         if (QWindow *window = q->windowHandle())
1159             window->setScreen(QGuiApplication::screens().value(targetScreen, nullptr));
1160     }
1161 
1162     data.fstrut_dirty = true;
1163 
1164     data.winid = 0;
1165     data.widget_attributes = 0;
1166     data.window_flags = f;
1167     data.window_state = 0;
1168     data.focus_policy = 0;
1169     data.context_menu_policy = Qt::DefaultContextMenu;
1170     data.window_modality = Qt::NonModal;
1171 
1172     data.sizehint_forced = 0;
1173     data.is_closing = 0;
1174     data.in_show = 0;
1175     data.in_set_window_state = 0;
1176     data.in_destructor = false;
1177 
1178     // Widgets with Qt::MSWindowsOwnDC (typically QGLWidget) must have a window handle.
1179     if (f & Qt::MSWindowsOwnDC) {
1180         mustHaveWindowHandle = 1;
1181         q->setAttribute(Qt::WA_NativeWindow);
1182     }
1183 //#if 0 // Used to be included in Qt4 for Q_WS_MAC
1184 //    q->setAttribute(Qt::WA_NativeWindow);
1185 //#endif
1186 
1187     q->setAttribute(Qt::WA_QuitOnClose); // might be cleared in adjustQuitOnCloseAttribute()
1188     adjustQuitOnCloseAttribute();
1189 
1190     q->setAttribute(Qt::WA_ContentsMarginsRespectsSafeArea);
1191     q->setAttribute(Qt::WA_WState_Hidden);
1192 
1193     //give potential windows a bigger "pre-initial" size; create_sys() will give them a new size later
1194     data.crect = parentWidget ? QRect(0,0,100,30) : QRect(0,0,640,480);
1195     focus_next = focus_prev = q;
1196 
1197     if ((f & Qt::WindowType_Mask) == Qt::Desktop)
1198         q->create();
1199     else if (parentWidget)
1200         q->setParent(parentWidget, data.window_flags);
1201     else {
1202         adjustFlags(data.window_flags, q);
1203         resolveLayoutDirection();
1204         // opaque system background?
1205         const QBrush &background = q->palette().brush(QPalette::Window);
1206         setOpaque(q->isWindow() && background.style() != Qt::NoBrush && background.isOpaque());
1207     }
1208     data.fnt = QFont(data.fnt, q);
1209 #if 0 // Used to be included in Qt4 for Q_WS_X11
1210     data.fnt.x11SetScreen(xinfo.screen());
1211 #endif
1212 
1213     q->setAttribute(Qt::WA_PendingMoveEvent);
1214     q->setAttribute(Qt::WA_PendingResizeEvent);
1215 
1216     if (++QWidgetPrivate::instanceCounter > QWidgetPrivate::maxInstances)
1217         QWidgetPrivate::maxInstances = QWidgetPrivate::instanceCounter;
1218 
1219     if (QApplicationPrivate::testAttribute(Qt::AA_ImmediateWidgetCreation)) // ### fixme: Qt 6: Remove AA_ImmediateWidgetCreation.
1220         q->create();
1221 
1222     QEvent e(QEvent::Create);
1223     QApplication::sendEvent(q, &e);
1224     QApplication::postEvent(q, new QEvent(QEvent::PolishRequest));
1225 
1226     extraPaintEngine = 0;
1227 
1228 #if 0 // Used to be included in Qt4 for Q_WS_MAC
1229     // If we add a child to the unified toolbar, we have to redirect the painting.
1230     if (parentWidget && parentWidget->d_func() && parentWidget->d_func()->isInUnifiedToolbar) {
1231         if (parentWidget->d_func()->unifiedSurface) {
1232             QWidget *toolbar = parentWidget->d_func()->toolbar_ancestor;
1233             parentWidget->d_func()->unifiedSurface->recursiveRedirect(toolbar, toolbar, toolbar->d_func()->toolbar_offset);
1234         }
1235     }
1236 #endif
1237 }
1238 
1239 
1240 
1241 void QWidgetPrivate::createRecursively()
1242 {
1243     Q_Q(QWidget);
1244     q->create(0, true, true);
1245     for (int i = 0; i < children.size(); ++i) {
1246         QWidget *child = qobject_cast<QWidget *>(children.at(i));
1247         if (child && !child->isHidden() && !child->isWindow() && !child->testAttribute(Qt::WA_WState_Created))
1248             child->d_func()->createRecursively();
1249     }
1250 }
1251 
1252 
1253 // ### fixme: Qt 6: Remove parameter window from QWidget::create()
1254 
1255 /*!
1256     Creates a new widget window.
1257 
1258     The parameter \a window is ignored in Qt 5. Please use
1259     QWindow::fromWinId() to create a QWindow wrapping a foreign
1260     window and pass it to QWidget::createWindowContainer() instead.
1261 
1262     Initializes the window (sets the geometry etc.) if \a
1263     initializeWindow is true. If \a initializeWindow is false, no
1264     initialization is performed. This parameter only makes sense if \a
1265     window is a valid window.
1266 
1267     Destroys the old window if \a destroyOldWindow is true. If \a
1268     destroyOldWindow is false, you are responsible for destroying the
1269     window yourself (using platform native code).
1270 
1271     The QWidget constructor calls create(0,true,true) to create a
1272     window for this widget.
1273 
1274     \sa createWindowContainer(), QWindow::fromWinId()
1275 */
1276 
1277 void QWidget::create(WId window, bool initializeWindow, bool destroyOldWindow)
1278 {
1279     Q_D(QWidget);
1280     if (Q_UNLIKELY(window))
1281         qWarning("QWidget::create(): Parameter 'window' does not have any effect.");
1282     if (testAttribute(Qt::WA_WState_Created) && window == 0 && internalWinId())
1283         return;
1284 
1285     if (d->data.in_destructor)
1286         return;
1287 
1288     Qt::WindowType type = windowType();
1289     Qt::WindowFlags &flags = data->window_flags;
1290 
1291     if ((type == Qt::Widget || type == Qt::SubWindow) && !parentWidget()) {
1292         type = Qt::Window;
1293         flags |= Qt::Window;
1294     }
1295 
1296     if (QWidget *parent = parentWidget()) {
1297         if (type & Qt::Window) {
1298             if (!parent->testAttribute(Qt::WA_WState_Created))
1299                 parent->createWinId();
1300         } else if (testAttribute(Qt::WA_NativeWindow) && !parent->internalWinId()
1301                    && !testAttribute(Qt::WA_DontCreateNativeAncestors)) {
1302             // We're about to create a native child widget that doesn't have a native parent;
1303             // enforce a native handle for the parent unless the Qt::WA_DontCreateNativeAncestors
1304             // attribute is set.
1305             d->createWinId();
1306             // Nothing more to do.
1307             Q_ASSERT(testAttribute(Qt::WA_WState_Created));
1308             Q_ASSERT(internalWinId());
1309             return;
1310         }
1311     }
1312 
1313 
1314     static const bool paintOnScreenEnv = qEnvironmentVariableIntValue("QT_ONSCREEN_PAINT") > 0;
1315     if (paintOnScreenEnv)
1316         setAttribute(Qt::WA_PaintOnScreen);
1317 
1318     if (QApplicationPrivate::testAttribute(Qt::AA_NativeWindows))
1319         setAttribute(Qt::WA_NativeWindow);
1320 
1321 #ifdef ALIEN_DEBUG
1322     qDebug() << "QWidget::create:" << this << "parent:" << parentWidget()
1323              << "Alien?" << !testAttribute(Qt::WA_NativeWindow);
1324 #endif
1325 
1326 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ && !defined(QT_NO_DRAGANDDROP)
1327     // Unregister the dropsite (if already registered) before we
1328     // re-create the widget with a native window.
1329     if (testAttribute(Qt::WA_WState_Created) && !internalWinId() && testAttribute(Qt::WA_NativeWindow)
1330             && d->extra && d->extra->dropTarget) {
1331         d->registerDropSite(false);
1332     }
1333 #endif
1334 
1335     d->updateIsOpaque();
1336 
1337     setAttribute(Qt::WA_WState_Created);                        // set created flag
1338     d->create_sys(window, initializeWindow, destroyOldWindow);
1339 
1340     // a real toplevel window needs a backing store
1341     if (isWindow() && windowType() != Qt::Desktop) {
1342         d->topData()->backingStoreTracker.destroy();
1343         d->topData()->backingStoreTracker.create(this);
1344     }
1345 
1346     d->setModal_sys();
1347 
1348     if (!isWindow() && parentWidget() && parentWidget()->testAttribute(Qt::WA_DropSiteRegistered))
1349         setAttribute(Qt::WA_DropSiteRegistered, true);
1350 
1351 #ifdef QT_EVAL
1352     extern void qt_eval_init_widget(QWidget *w);
1353     qt_eval_init_widget(this);
1354 #endif
1355 
1356     // need to force the resting of the icon after changing parents
1357     if (testAttribute(Qt::WA_SetWindowIcon))
1358         d->setWindowIcon_sys();
1359 
1360     if (isWindow() && !d->topData()->iconText.isEmpty())
1361         d->setWindowIconText_helper(d->topData()->iconText);
1362     if (isWindow() && !d->topData()->caption.isEmpty())
1363         d->setWindowTitle_helper(d->topData()->caption);
1364     if (isWindow() && !d->topData()->filePath.isEmpty())
1365         d->setWindowFilePath_helper(d->topData()->filePath);
1366     if (windowType() != Qt::Desktop) {
1367         d->updateSystemBackground();
1368 
1369         if (isWindow() && !testAttribute(Qt::WA_SetWindowIcon))
1370             d->setWindowIcon_sys();
1371     }
1372 
1373     // Frame strut update needed in cases where there are native widgets such as QGLWidget,
1374     // as those force native window creation on their ancestors before they are shown.
1375     // If the strut is not updated, any subsequent move of the top level window before show
1376     // will cause window frame to be ignored when positioning the window.
1377     // Note that this only helps on platforms that handle window creation synchronously.
1378     d->updateFrameStrut();
1379 }
1380 
1381 void q_createNativeChildrenAndSetParent(const QWidget *parentWidget)
1382 {
1383     QObjectList children = parentWidget->children();
1384     for (int i = 0; i < children.size(); i++) {
1385         if (children.at(i)->isWidgetType()) {
1386             const QWidget *childWidget = qobject_cast<const QWidget *>(children.at(i));
1387             if (childWidget) { // should not be necessary
1388                 if (childWidget->testAttribute(Qt::WA_NativeWindow)) {
1389                     if (!childWidget->internalWinId())
1390                         childWidget->winId();
1391                     if (childWidget->windowHandle()) {
1392                         if (childWidget->isWindow()) {
1393                             childWidget->windowHandle()->setTransientParent(parentWidget->window()->windowHandle());
1394                         } else {
1395                             childWidget->windowHandle()->setParent(childWidget->nativeParentWidget()->windowHandle());
1396                         }
1397                     }
1398                 } else {
1399                     q_createNativeChildrenAndSetParent(childWidget);
1400                 }
1401             }
1402         }
1403     }
1404 
1405 }
1406 
1407 void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyOldWindow)
1408 {
1409     Q_Q(QWidget);
1410 
1411     Q_UNUSED(window);
1412     Q_UNUSED(initializeWindow);
1413     Q_UNUSED(destroyOldWindow);
1414 
1415     if (!q->testAttribute(Qt::WA_NativeWindow) && !q->isWindow())
1416         return; // we only care about real toplevels
1417 
1418     QWidgetWindow *win = topData()->window;
1419     // topData() ensures the extra is created but does not ensure 'window' is non-null
1420     // in case the extra was already valid.
1421     if (!win) {
1422         createTLSysExtra();
1423         win = topData()->window;
1424     }
1425 
1426     const auto dynamicPropertyNames = q->dynamicPropertyNames();
1427     for (const QByteArray &propertyName : dynamicPropertyNames) {
1428         if (!qstrncmp(propertyName, "_q_platform_", 12))
1429             win->setProperty(propertyName, q->property(propertyName));
1430     }
1431 
1432     Qt::WindowFlags &flags = data.window_flags;
1433 
1434 #if defined(Q_OS_IOS) || defined(Q_OS_TVOS)
1435     if (q->testAttribute(Qt::WA_ContentsMarginsRespectsSafeArea))
1436         flags |= Qt::MaximizeUsingFullscreenGeometryHint;
1437 #endif
1438 
1439     if (q->testAttribute(Qt::WA_ShowWithoutActivating))
1440         win->setProperty("_q_showWithoutActivating", QVariant(true));
1441     if (q->testAttribute(Qt::WA_MacAlwaysShowToolWindow))
1442         win->setProperty("_q_macAlwaysShowToolWindow", QVariant(true));
1443     setNetWmWindowTypes(true); // do nothing if none of WA_X11NetWmWindowType* is set
1444     win->setFlags(flags);
1445     fixPosIncludesFrame();
1446     if (q->testAttribute(Qt::WA_Moved)
1447         || !QGuiApplicationPrivate::platformIntegration()->hasCapability(QPlatformIntegration::WindowManagement))
1448         win->setGeometry(q->geometry());
1449     else
1450         win->resize(q->size());
1451     if (win->isTopLevel()) {
1452         int screenNumber = topData()->initialScreenIndex;
1453         topData()->initialScreenIndex = -1;
1454         if (screenNumber < 0) {
1455             screenNumber = q->windowType() != Qt::Desktop
1456                 ? QDesktopWidgetPrivate::screenNumber(q) : 0;
1457         }
1458         win->setScreen(QGuiApplication::screens().value(screenNumber, nullptr));
1459     }
1460 
1461     QSurfaceFormat format = win->requestedFormat();
1462     if ((flags & Qt::Window) && win->surfaceType() != QSurface::OpenGLSurface
1463             && q->testAttribute(Qt::WA_TranslucentBackground)) {
1464         format.setAlphaBufferSize(8);
1465     }
1466     win->setFormat(format);
1467 
1468     if (QWidget *nativeParent = q->nativeParentWidget()) {
1469         if (nativeParent->windowHandle()) {
1470             if (flags & Qt::Window) {
1471                 win->setTransientParent(nativeParent->window()->windowHandle());
1472                 win->setParent(0);
1473             } else {
1474                 win->setTransientParent(0);
1475                 win->setParent(nativeParent->windowHandle());
1476             }
1477         }
1478     }
1479 
1480     qt_window_private(win)->positionPolicy = topData()->posIncludesFrame ?
1481         QWindowPrivate::WindowFrameInclusive : QWindowPrivate::WindowFrameExclusive;
1482 
1483     if (q->windowType() != Qt::Desktop || q->testAttribute(Qt::WA_NativeWindow)) {
1484         win->create();
1485         // Enable nonclient-area events for QDockWidget and other NonClientArea-mouse event processing.
1486         win->handle()->setFrameStrutEventsEnabled(true);
1487     }
1488 
1489     data.window_flags = win->flags();
1490     if (!win->isTopLevel()) // In a Widget world foreign windows can only be top level
1491       data.window_flags &= ~Qt::ForeignWindow;
1492 
1493     if (!topData()->role.isNull())
1494         QXcbWindowFunctions::setWmWindowRole(win, topData()->role.toLatin1());
1495 
1496     QBackingStore *store = q->backingStore();
1497 
1498     if (!store) {
1499         if (q->windowType() != Qt::Desktop) {
1500             if (q->isTopLevel())
1501                 q->setBackingStore(new QBackingStore(win));
1502         } else {
1503             q->setAttribute(Qt::WA_PaintOnScreen, true);
1504         }
1505     }
1506 
1507     setWindowModified_helper();
1508 
1509     if (win->handle()) {
1510         WId id = win->winId();
1511         // See the QPlatformWindow::winId() documentation
1512         Q_ASSERT(id != WId(0));
1513         setWinId(id);
1514     }
1515 
1516     // Check children and create windows for them if necessary
1517     q_createNativeChildrenAndSetParent(q);
1518 
1519     if (extra && !extra->mask.isEmpty())
1520         setMask_sys(extra->mask);
1521 
1522     if (data.crect.width() == 0 || data.crect.height() == 0) {
1523         q->setAttribute(Qt::WA_OutsideWSRange, true);
1524     } else if (q->isVisible()) {
1525         // If widget is already shown, set window visible, too
1526         win->setNativeWindowVisibility(true);
1527     }
1528 }
1529 
1530 #ifdef Q_OS_WIN
1531 static const char activeXNativeParentHandleProperty[] = "_q_embedded_native_parent_handle";
1532 #endif
1533 
1534 void QWidgetPrivate::createTLSysExtra()
1535 {
1536     Q_Q(QWidget);
1537     if (!extra->topextra->window && (q->testAttribute(Qt::WA_NativeWindow) || q->isWindow())) {
1538         extra->topextra->window = new QWidgetWindow(q);
1539         if (extra->minw || extra->minh)
1540             extra->topextra->window->setMinimumSize(QSize(extra->minw, extra->minh));
1541         if (extra->maxw != QWIDGETSIZE_MAX || extra->maxh != QWIDGETSIZE_MAX)
1542             extra->topextra->window->setMaximumSize(QSize(extra->maxw, extra->maxh));
1543         if (extra->topextra->opacity != 255 && q->isWindow())
1544             extra->topextra->window->setOpacity(qreal(extra->topextra->opacity) / qreal(255));
1545 #ifdef Q_OS_WIN
1546         // Pass on native parent handle for Widget embedded into Active X.
1547         const QVariant activeXNativeParentHandle = q->property(activeXNativeParentHandleProperty);
1548         if (activeXNativeParentHandle.isValid())
1549             extra->topextra->window->setProperty(activeXNativeParentHandleProperty, activeXNativeParentHandle);
1550         if (q->inherits("QTipLabel") || q->inherits("QAlphaWidget"))
1551             extra->topextra->window->setProperty("_q_windowsDropShadow", QVariant(true));
1552 #endif
1553     }
1554 
1555 }
1556 
1557 /*!
1558     Destroys the widget.
1559 
1560     All this widget's children are deleted first. The application
1561     exits if this widget is the main widget.
1562 */
1563 
1564 QWidget::~QWidget()
1565 {
1566     Q_D(QWidget);
1567     d->data.in_destructor = true;
1568 
1569 #if defined (QT_CHECK_STATE)
1570     if (Q_UNLIKELY(paintingActive()))
1571         qWarning("QWidget: %s (%s) deleted while being painted", className(), name());
1572 #endif
1573 
1574 #ifndef QT_NO_GESTURES
1575     if (QGestureManager *manager = QGestureManager::instance()) {
1576         // \forall Qt::GestureType type : ungrabGesture(type) (inlined)
1577         for (auto it = d->gestureContext.keyBegin(), end = d->gestureContext.keyEnd(); it != end; ++it)
1578             manager->cleanupCachedGestures(this, *it);
1579     }
1580     d->gestureContext.clear();
1581 #endif
1582 
1583     // force acceptDrops false before winId is destroyed.
1584     d->registerDropSite(false);
1585 
1586 #ifndef QT_NO_ACTION
1587     // remove all actions from this widget
1588     for (int i = 0; i < d->actions.size(); ++i) {
1589         QActionPrivate *apriv = d->actions.at(i)->d_func();
1590         apriv->widgets.removeAll(this);
1591     }
1592     d->actions.clear();
1593 #endif
1594 
1595 #ifndef QT_NO_SHORTCUT
1596     // Remove all shortcuts grabbed by this
1597     // widget, unless application is closing
1598     if (!QApplicationPrivate::is_app_closing && testAttribute(Qt::WA_GrabbedShortcut))
1599         qApp->d_func()->shortcutMap.removeShortcut(0, this, QKeySequence());
1600 #endif
1601 
1602     // delete layout while we still are a valid widget
1603     delete d->layout;
1604     d->layout = 0;
1605     // Remove myself from focus list
1606 
1607     Q_ASSERT(d->focus_next->d_func()->focus_prev == this);
1608     Q_ASSERT(d->focus_prev->d_func()->focus_next == this);
1609 
1610     if (d->focus_next != this) {
1611         d->focus_next->d_func()->focus_prev = d->focus_prev;
1612         d->focus_prev->d_func()->focus_next = d->focus_next;
1613         d->focus_next = d->focus_prev = 0;
1614     }
1615 
1616 
1617     QT_TRY {
1618 #if QT_CONFIG(graphicsview)
1619         const QWidget* w = this;
1620         while (w->d_func()->extra && w->d_func()->extra->focus_proxy)
1621             w = w->d_func()->extra->focus_proxy;
1622         QWidget *window = w->window();
1623         QWExtra *e = window ? window->d_func()->extra : 0;
1624         if (!e || !e->proxyWidget || (w->parentWidget() && w->parentWidget()->d_func()->focus_child == this))
1625 #endif
1626         clearFocus();
1627     } QT_CATCH(...) {
1628         // swallow this problem because we are in a destructor
1629     }
1630 
1631     d->setDirtyOpaqueRegion();
1632 
1633     if (isWindow() && isVisible() && internalWinId()) {
1634         QT_TRY {
1635             d->close_helper(QWidgetPrivate::CloseNoEvent);
1636         } QT_CATCH(...) {
1637             // if we're out of memory, at least hide the window.
1638             QT_TRY {
1639                 hide();
1640             } QT_CATCH(...) {
1641                 // and if that also doesn't work, then give up
1642             }
1643         }
1644     }
1645 
1646 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_X11 */|| 0 /* Used to be included in Qt4 for Q_WS_MAC */
1647     else if (!internalWinId() && isVisible()) {
1648         qApp->d_func()->sendSyntheticEnterLeave(this);
1649     }
1650 #endif
1651     else if (isVisible()) {
1652         qApp->d_func()->sendSyntheticEnterLeave(this);
1653     }
1654 
1655     if (QWidgetBackingStore *bs = d->maybeBackingStore()) {
1656         bs->removeDirtyWidget(this);
1657         if (testAttribute(Qt::WA_StaticContents))
1658             bs->removeStaticWidget(this);
1659     }
1660 
1661     delete d->needsFlush;
1662     d->needsFlush = 0;
1663 
1664     // The next 20 lines are duplicated from QObject, but required here
1665     // since QWidget deletes is children itself
1666     bool blocked = d->blockSig;
1667     d->blockSig = 0; // unblock signals so we always emit destroyed()
1668 
1669     if (d->isSignalConnected(0)) {
1670         QT_TRY {
1671             emit destroyed(this);
1672         } QT_CATCH(...) {
1673             // all the signal/slots connections are still in place - if we don't
1674             // quit now, we will crash pretty soon.
1675             qWarning("Detected an unexpected exception in ~QWidget while emitting destroyed().");
1676             QT_RETHROW;
1677         }
1678     }
1679 
1680     if (d->declarativeData) {
1681         if (static_cast<QAbstractDeclarativeDataImpl*>(d->declarativeData)->ownedByQml1) {
1682             if (QAbstractDeclarativeData::destroyed_qml1)
1683                 QAbstractDeclarativeData::destroyed_qml1(d->declarativeData, this);
1684         } else {
1685             if (QAbstractDeclarativeData::destroyed)
1686                 QAbstractDeclarativeData::destroyed(d->declarativeData, this);
1687         }
1688         d->declarativeData = 0;                 // don't activate again in ~QObject
1689     }
1690 
1691     d->blockSig = blocked;
1692 
1693 #if 0 // Used to be included in Qt4 for Q_WS_MAC
1694     // QCocoaView holds a pointer back to this widget. Clear it now
1695     // to make sure it's not followed later on. The lifetime of the
1696     // QCocoaView might exceed the lifetime of this widget in cases
1697     // where Cocoa itself holds references to it.
1698     extern void qt_mac_clearCocoaViewQWidgetPointers(QWidget *);
1699     qt_mac_clearCocoaViewQWidgetPointers(this);
1700 #endif
1701 
1702     if (!d->children.isEmpty())
1703         d->deleteChildren();
1704 
1705     QApplication::removePostedEvents(this);
1706 
1707     QT_TRY {
1708         destroy();                                        // platform-dependent cleanup
1709     } QT_CATCH(...) {
1710         // if this fails we can't do anything about it but at least we are not allowed to throw.
1711     }
1712     --QWidgetPrivate::instanceCounter;
1713 
1714     if (QWidgetPrivate::allWidgets) // might have been deleted by ~QApplication
1715         QWidgetPrivate::allWidgets->remove(this);
1716 
1717     QT_TRY {
1718         QEvent e(QEvent::Destroy);
1719         QCoreApplication::sendEvent(this, &e);
1720     } QT_CATCH(const std::exception&) {
1721         // if this fails we can't do anything about it but at least we are not allowed to throw.
1722     }
1723 
1724 #if QT_CONFIG(graphicseffect)
1725     delete d->graphicsEffect;
1726 #endif
1727 }
1728 
1729 int QWidgetPrivate::instanceCounter = 0;  // Current number of widget instances
1730 int QWidgetPrivate::maxInstances = 0;     // Maximum number of widget instances
1731 
1732 void QWidgetPrivate::setWinId(WId id)                // set widget identifier
1733 {
1734     Q_Q(QWidget);
1735     // the user might create a widget with Qt::Desktop window
1736     // attribute (or create another QDesktopWidget instance), which
1737     // will have the same windowid (the root window id) as the
1738     // qt_desktopWidget. We should not add the second desktop widget
1739     // to the mapper.
1740     bool userDesktopWidget = qt_desktopWidget != 0 && qt_desktopWidget != q && q->windowType() == Qt::Desktop;
1741     if (mapper && data.winid && !userDesktopWidget) {
1742         mapper->remove(data.winid);
1743     }
1744 
1745     const WId oldWinId = data.winid;
1746 
1747     data.winid = id;
1748 #if 0 // Used to be included in Qt4 for Q_WS_X11
1749     hd = id; // X11: hd == ident
1750 #endif
1751     if (mapper && id && !userDesktopWidget) {
1752         mapper->insert(data.winid, q);
1753     }
1754 
1755     if(oldWinId != id) {
1756         QEvent e(QEvent::WinIdChange);
1757         QCoreApplication::sendEvent(q, &e);
1758     }
1759 }
1760 
1761 void QWidgetPrivate::createTLExtra()
1762 {
1763     if (!extra)
1764         createExtra();
1765     if (!extra->topextra) {
1766         QTLWExtra* x = extra->topextra = new QTLWExtra;
1767         x->icon = 0;
1768         x->backingStore = 0;
1769         x->sharedPainter = 0;
1770         x->incw = x->inch = 0;
1771         x->basew = x->baseh = 0;
1772         x->frameStrut.setCoords(0, 0, 0, 0);
1773         x->normalGeometry = QRect(0,0,-1,-1);
1774         x->savedFlags = 0;
1775         x->opacity = 255;
1776         x->posIncludesFrame = 0;
1777         x->sizeAdjusted = false;
1778         x->inTopLevelResize = false;
1779         x->inRepaint = false;
1780         x->embedded = 0;
1781         x->window = 0;
1782         x->shareContext = 0;
1783         x->initialScreenIndex = -1;
1784 #if 0 // Used to be included in Qt4 for Q_WS_MAC
1785         x->wasMaximized = false;
1786 #endif
1787 #ifdef QWIDGET_EXTRA_DEBUG
1788         static int count = 0;
1789         qDebug() << "tlextra" << ++count;
1790 #endif
1791     }
1792 }
1793 
1794 /*!
1795   \internal
1796   Creates the widget extra data.
1797 */
1798 
1799 void QWidgetPrivate::createExtra()
1800 {
1801     if (!extra) {                                // if not exists
1802         extra = new QWExtra;
1803         extra->glContext = 0;
1804         extra->topextra = 0;
1805 #if QT_CONFIG(graphicsview)
1806         extra->proxyWidget = 0;
1807 #endif
1808 #ifndef QT_NO_CURSOR
1809         extra->curs = 0;
1810 #endif
1811         extra->minw = 0;
1812         extra->minh = 0;
1813         extra->maxw = QWIDGETSIZE_MAX;
1814         extra->maxh = QWIDGETSIZE_MAX;
1815         extra->customDpiX = 0;
1816         extra->customDpiY = 0;
1817         extra->explicitMinSize = 0;
1818         extra->explicitMaxSize = 0;
1819         extra->autoFillBackground = 0;
1820         extra->nativeChildrenForced = 0;
1821         extra->inRenderWithPainter = 0;
1822         extra->hasWindowContainer = false;
1823         extra->hasMask = 0;
1824         createSysExtra();
1825 #ifdef QWIDGET_EXTRA_DEBUG
1826         static int count = 0;
1827         qDebug() << "extra" << ++count;
1828 #endif
1829     }
1830 }
1831 
1832 void QWidgetPrivate::createSysExtra()
1833 {
1834 }
1835 
1836 /*!
1837   \internal
1838   Deletes the widget extra data.
1839 */
1840 
1841 void QWidgetPrivate::deleteExtra()
1842 {
1843     if (extra) {                                // if exists
1844 #ifndef QT_NO_CURSOR
1845         delete extra->curs;
1846 #endif
1847         deleteSysExtra();
1848 #ifndef QT_NO_STYLE_STYLESHEET
1849         // dereference the stylesheet style
1850         if (QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(extra->style))
1851             proxy->deref();
1852 #endif
1853         if (extra->topextra) {
1854             deleteTLSysExtra();
1855             // extra->topextra->backingStore destroyed in QWidgetPrivate::deleteTLSysExtra()
1856             delete extra->topextra->icon;
1857             delete extra->topextra;
1858         }
1859         delete extra;
1860         // extra->xic destroyed in QWidget::destroy()
1861         extra = 0;
1862     }
1863 }
1864 
1865 void QWidgetPrivate::deleteSysExtra()
1866 {
1867 }
1868 
1869 static void deleteBackingStore(QWidgetPrivate *d)
1870 {
1871     QTLWExtra *topData = d->topData();
1872 
1873     delete topData->backingStore;
1874     topData->backingStore = 0;
1875 }
1876 
1877 void QWidgetPrivate::deleteTLSysExtra()
1878 {
1879     if (extra && extra->topextra) {
1880         //the qplatformbackingstore may hold a reference to the window, so the backingstore
1881         //needs to be deleted first.
1882 
1883         extra->topextra->backingStoreTracker.destroy();
1884         deleteBackingStore(this);
1885 #ifndef QT_NO_OPENGL
1886         qDeleteAll(extra->topextra->widgetTextures);
1887         extra->topextra->widgetTextures.clear();
1888         delete extra->topextra->shareContext;
1889         extra->topextra->shareContext = 0;
1890 #endif
1891 
1892         //the toplevel might have a context with a "qglcontext associated with it. We need to
1893         //delete the qglcontext before we delete the qplatformopenglcontext.
1894         //One unfortunate thing about this is that we potentially create a glContext just to
1895         //delete it straight afterwards.
1896         if (extra->topextra->window) {
1897             extra->topextra->window->destroy();
1898         }
1899         delete extra->topextra->window;
1900         extra->topextra->window = 0;
1901 
1902     }
1903 }
1904 
1905 /*
1906   Returns \c true if there are widgets above this which overlap with
1907   \a rect, which is in parent's coordinate system (same as crect).
1908 */
1909 
1910 bool QWidgetPrivate::isOverlapped(const QRect &rect) const
1911 {
1912     Q_Q(const QWidget);
1913 
1914     const QWidget *w = q;
1915     QRect r = rect;
1916     while (w) {
1917         if (w->isWindow())
1918             return false;
1919         QWidgetPrivate *pd = w->parentWidget()->d_func();
1920         bool above = false;
1921         for (int i = 0; i < pd->children.size(); ++i) {
1922             QWidget *sibling = qobject_cast<QWidget *>(pd->children.at(i));
1923             if (!sibling || !sibling->isVisible() || sibling->isWindow())
1924                 continue;
1925             if (!above) {
1926                 above = (sibling == w);
1927                 continue;
1928             }
1929 
1930             if (qRectIntersects(sibling->d_func()->effectiveRectFor(sibling->data->crect), r)) {
1931                 const QWExtra *siblingExtra = sibling->d_func()->extra;
1932                 if (siblingExtra && siblingExtra->hasMask && !sibling->d_func()->graphicsEffect
1933                     && !siblingExtra->mask.translated(sibling->data->crect.topLeft()).intersects(r)) {
1934                     continue;
1935                 }
1936                 return true;
1937             }
1938         }
1939         w = w->parentWidget();
1940         r.translate(pd->data.crect.topLeft());
1941     }
1942     return false;
1943 }
1944 
1945 void QWidgetPrivate::syncBackingStore()
1946 {
1947     if (paintOnScreen()) {
1948         repaint_sys(dirty);
1949         dirty = QRegion();
1950     } else if (QWidgetBackingStore *bs = maybeBackingStore()) {
1951         bs->sync();
1952     }
1953 }
1954 
1955 void QWidgetPrivate::syncBackingStore(const QRegion &region)
1956 {
1957     if (paintOnScreen())
1958         repaint_sys(region);
1959     else if (QWidgetBackingStore *bs = maybeBackingStore()) {
1960         bs->sync(q_func(), region);
1961     }
1962 }
1963 
1964 void QWidgetPrivate::setUpdatesEnabled_helper(bool enable)
1965 {
1966     Q_Q(QWidget);
1967 
1968     if (enable && !q->isWindow() && q->parentWidget() && !q->parentWidget()->updatesEnabled())
1969         return; // nothing we can do
1970 
1971     if (enable != q->testAttribute(Qt::WA_UpdatesDisabled))
1972         return; // nothing to do
1973 
1974     q->setAttribute(Qt::WA_UpdatesDisabled, !enable);
1975     if (enable)
1976         q->update();
1977 
1978     Qt::WidgetAttribute attribute = enable ? Qt::WA_ForceUpdatesDisabled : Qt::WA_UpdatesDisabled;
1979     for (int i = 0; i < children.size(); ++i) {
1980         QWidget *w = qobject_cast<QWidget *>(children.at(i));
1981         if (w && !w->isWindow() && !w->testAttribute(attribute))
1982             w->d_func()->setUpdatesEnabled_helper(enable);
1983     }
1984 }
1985 
1986 /*!
1987     \internal
1988 
1989     Propagate this widget's palette to all children, except style sheet
1990     widgets, and windows that don't enable window propagation (palettes don't
1991     normally propagate to windows).
1992 */
1993 void QWidgetPrivate::propagatePaletteChange()
1994 {
1995     Q_Q(QWidget);
1996     // Propagate a new inherited mask to all children.
1997 #if QT_CONFIG(graphicsview)
1998     if (!q->parentWidget() && extra && extra->proxyWidget) {
1999         QGraphicsProxyWidget *p = extra->proxyWidget;
2000         inheritedPaletteResolveMask = p->d_func()->inheritedPaletteResolveMask | p->palette().resolve();
2001     } else
2002 #endif // QT_CONFIG(graphicsview)
2003         if (q->isWindow() && !q->testAttribute(Qt::WA_WindowPropagation)) {
2004         inheritedPaletteResolveMask = 0;
2005     }
2006     int mask = data.pal.resolve() | inheritedPaletteResolveMask;
2007 
2008     const bool useStyleSheetPropagationInWidgetStyles =
2009         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
2010 
2011     QEvent pc(QEvent::PaletteChange);
2012     QApplication::sendEvent(q, &pc);
2013     for (int i = 0; i < children.size(); ++i) {
2014         QWidget *w = qobject_cast<QWidget*>(children.at(i));
2015         if (w && (!w->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles)
2016             && (!w->isWindow() || w->testAttribute(Qt::WA_WindowPropagation))) {
2017             QWidgetPrivate *wd = w->d_func();
2018             wd->inheritedPaletteResolveMask = mask;
2019             wd->resolvePalette();
2020         }
2021     }
2022 }
2023 
2024 /*
2025   Returns the widget's clipping rectangle.
2026 */
2027 QRect QWidgetPrivate::clipRect() const
2028 {
2029     Q_Q(const QWidget);
2030     const QWidget * w = q;
2031     if (!w->isVisible())
2032         return QRect();
2033     QRect r = effectiveRectFor(q->rect());
2034     int ox = 0;
2035     int oy = 0;
2036     while (w
2037             && w->isVisible()
2038             && !w->isWindow()
2039             && w->parentWidget()) {
2040         ox -= w->x();
2041         oy -= w->y();
2042         w = w->parentWidget();
2043         r &= QRect(ox, oy, w->width(), w->height());
2044     }
2045     return r;
2046 }
2047 
2048 /*
2049   Returns the widget's clipping region (without siblings).
2050 */
2051 QRegion QWidgetPrivate::clipRegion() const
2052 {
2053     Q_Q(const QWidget);
2054     if (!q->isVisible())
2055         return QRegion();
2056     QRegion r(q->rect());
2057     const QWidget * w = q;
2058     const QWidget *ignoreUpTo;
2059     int ox = 0;
2060     int oy = 0;
2061     while (w
2062            && w->isVisible()
2063            && !w->isWindow()
2064            && w->parentWidget()) {
2065         ox -= w->x();
2066         oy -= w->y();
2067         ignoreUpTo = w;
2068         w = w->parentWidget();
2069         r &= QRegion(ox, oy, w->width(), w->height());
2070 
2071         int i = 0;
2072         while(w->d_func()->children.at(i++) != static_cast<const QObject *>(ignoreUpTo))
2073             ;
2074         for ( ; i < w->d_func()->children.size(); ++i) {
2075             if(QWidget *sibling = qobject_cast<QWidget *>(w->d_func()->children.at(i))) {
2076                 if(sibling->isVisible() && !sibling->isWindow()) {
2077                     QRect siblingRect(ox+sibling->x(), oy+sibling->y(),
2078                                       sibling->width(), sibling->height());
2079                     if (qRectIntersects(siblingRect, q->rect()))
2080                         r -= QRegion(siblingRect);
2081                 }
2082             }
2083         }
2084     }
2085     return r;
2086 }
2087 
2088 void QWidgetPrivate::setSystemClip(QPaintEngine *paintEngine, qreal devicePixelRatio, const QRegion &region)
2089 {
2090 // Transform the system clip region from device-independent pixels to device pixels
2091     QTransform scaleTransform;
2092     scaleTransform.scale(devicePixelRatio, devicePixelRatio);
2093 
2094     paintEngine->d_func()->baseSystemClip = region;
2095     paintEngine->d_func()->setSystemTransform(scaleTransform);
2096 
2097 }
2098 
2099 #if QT_CONFIG(graphicseffect)
2100 void QWidgetPrivate::invalidateGraphicsEffectsRecursively()
2101 {
2102     Q_Q(QWidget);
2103     QWidget *w = q;
2104     do {
2105         if (w->graphicsEffect()) {
2106             QWidgetEffectSourcePrivate *sourced =
2107                 static_cast<QWidgetEffectSourcePrivate *>(w->graphicsEffect()->source()->d_func());
2108             if (!sourced->updateDueToGraphicsEffect)
2109                 w->graphicsEffect()->source()->d_func()->invalidateCache();
2110         }
2111         w = w->parentWidget();
2112     } while (w);
2113 }
2114 #endif // QT_CONFIG(graphicseffect)
2115 
2116 void QWidgetPrivate::setDirtyOpaqueRegion()
2117 {
2118     Q_Q(QWidget);
2119 
2120     dirtyOpaqueChildren = true;
2121 
2122 #if QT_CONFIG(graphicseffect)
2123     invalidateGraphicsEffectsRecursively();
2124 #endif // QT_CONFIG(graphicseffect)
2125 
2126     if (q->isWindow())
2127         return;
2128 
2129     QWidget *parent = q->parentWidget();
2130     if (!parent)
2131         return;
2132 
2133     // TODO: instead of setting dirtyflag, manipulate the dirtyregion directly?
2134     QWidgetPrivate *pd = parent->d_func();
2135     if (!pd->dirtyOpaqueChildren)
2136         pd->setDirtyOpaqueRegion();
2137 }
2138 
2139 const QRegion &QWidgetPrivate::getOpaqueChildren() const
2140 {
2141     if (!dirtyOpaqueChildren)
2142         return opaqueChildren;
2143 
2144     QWidgetPrivate *that = const_cast<QWidgetPrivate*>(this);
2145     that->opaqueChildren = QRegion();
2146 
2147     for (int i = 0; i < children.size(); ++i) {
2148         QWidget *child = qobject_cast<QWidget *>(children.at(i));
2149         if (!child || !child->isVisible() || child->isWindow())
2150             continue;
2151 
2152         const QPoint offset = child->geometry().topLeft();
2153         QWidgetPrivate *childd = child->d_func();
2154         QRegion r = childd->isOpaque ? child->rect() : childd->getOpaqueChildren();
2155         if (childd->extra && childd->extra->hasMask)
2156             r &= childd->extra->mask;
2157         if (r.isEmpty())
2158             continue;
2159         r.translate(offset);
2160         that->opaqueChildren += r;
2161     }
2162 
2163     that->opaqueChildren &= q_func()->rect();
2164     that->dirtyOpaqueChildren = false;
2165 
2166     return that->opaqueChildren;
2167 }
2168 
2169 void QWidgetPrivate::subtractOpaqueChildren(QRegion &source, const QRect &clipRect) const
2170 {
2171     if (children.isEmpty() || clipRect.isEmpty())
2172         return;
2173 
2174     const QRegion &r = getOpaqueChildren();
2175     if (!r.isEmpty())
2176         source -= (r & clipRect);
2177 }
2178 
2179 //subtract any relatives that are higher up than me --- this is too expensive !!!
2180 void QWidgetPrivate::subtractOpaqueSiblings(QRegion &sourceRegion, bool *hasDirtySiblingsAbove,
2181                                             bool alsoNonOpaque) const
2182 {
2183     Q_Q(const QWidget);
2184     static int disableSubtractOpaqueSiblings = qEnvironmentVariableIntValue("QT_NO_SUBTRACTOPAQUESIBLINGS");
2185     if (disableSubtractOpaqueSiblings || q->isWindow())
2186         return;
2187 
2188 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2189     if (q->d_func()->isInUnifiedToolbar)
2190         return;
2191 #endif
2192 
2193     QRect clipBoundingRect;
2194     bool dirtyClipBoundingRect = true;
2195 
2196     QRegion parentClip;
2197     bool dirtyParentClip = true;
2198 
2199     QPoint parentOffset = data.crect.topLeft();
2200 
2201     const QWidget *w = q;
2202 
2203     while (w) {
2204         if (w->isWindow())
2205             break;
2206         QWidgetPrivate *pd = w->parentWidget()->d_func();
2207         const int myIndex = pd->children.indexOf(const_cast<QWidget *>(w));
2208         const QRect widgetGeometry = w->d_func()->effectiveRectFor(w->data->crect);
2209         for (int i = myIndex + 1; i < pd->children.size(); ++i) {
2210             QWidget *sibling = qobject_cast<QWidget *>(pd->children.at(i));
2211             if (!sibling || !sibling->isVisible() || sibling->isWindow())
2212                 continue;
2213 
2214             const QRect siblingGeometry = sibling->d_func()->effectiveRectFor(sibling->data->crect);
2215             if (!qRectIntersects(siblingGeometry, widgetGeometry))
2216                 continue;
2217 
2218             if (dirtyClipBoundingRect) {
2219                 clipBoundingRect = sourceRegion.boundingRect();
2220                 dirtyClipBoundingRect = false;
2221             }
2222 
2223             if (!qRectIntersects(siblingGeometry, clipBoundingRect.translated(parentOffset)))
2224                 continue;
2225 
2226             if (dirtyParentClip) {
2227                 parentClip = sourceRegion.translated(parentOffset);
2228                 dirtyParentClip = false;
2229             }
2230 
2231             const QPoint siblingPos(sibling->data->crect.topLeft());
2232             const QRect siblingClipRect(sibling->d_func()->clipRect());
2233             QRegion siblingDirty(parentClip);
2234             siblingDirty &= (siblingClipRect.translated(siblingPos));
2235             const bool hasMask = sibling->d_func()->extra && sibling->d_func()->extra->hasMask
2236                                  && !sibling->d_func()->graphicsEffect;
2237             if (hasMask)
2238                 siblingDirty &= sibling->d_func()->extra->mask.translated(siblingPos);
2239             if (siblingDirty.isEmpty())
2240                 continue;
2241 
2242             if (sibling->d_func()->isOpaque || alsoNonOpaque) {
2243                 if (hasMask) {
2244                     siblingDirty.translate(-parentOffset);
2245                     sourceRegion -= siblingDirty;
2246                 } else {
2247                     sourceRegion -= siblingGeometry.translated(-parentOffset);
2248                 }
2249             } else {
2250                 if (hasDirtySiblingsAbove)
2251                     *hasDirtySiblingsAbove = true;
2252                 if (sibling->d_func()->children.isEmpty())
2253                     continue;
2254                 QRegion opaqueSiblingChildren(sibling->d_func()->getOpaqueChildren());
2255                 opaqueSiblingChildren.translate(-parentOffset + siblingPos);
2256                 sourceRegion -= opaqueSiblingChildren;
2257             }
2258             if (sourceRegion.isEmpty())
2259                 return;
2260 
2261             dirtyClipBoundingRect = true;
2262             dirtyParentClip = true;
2263         }
2264 
2265         w = w->parentWidget();
2266         parentOffset += pd->data.crect.topLeft();
2267         dirtyParentClip = true;
2268     }
2269 }
2270 
2271 void QWidgetPrivate::clipToEffectiveMask(QRegion &region) const
2272 {
2273     Q_Q(const QWidget);
2274 
2275     const QWidget *w = q;
2276     QPoint offset;
2277 
2278 #if QT_CONFIG(graphicseffect)
2279     if (graphicsEffect) {
2280         w = q->parentWidget();
2281         offset -= data.crect.topLeft();
2282     }
2283 #endif // QT_CONFIG(graphicseffect)
2284 
2285     while (w) {
2286         const QWidgetPrivate *wd = w->d_func();
2287         if (wd->extra && wd->extra->hasMask)
2288             region &= (w != q) ? wd->extra->mask.translated(offset) : wd->extra->mask;
2289         if (w->isWindow())
2290             return;
2291         offset -= wd->data.crect.topLeft();
2292         w = w->parentWidget();
2293     }
2294 }
2295 
2296 bool QWidgetPrivate::paintOnScreen() const
2297 {
2298 #if defined(QT_NO_BACKINGSTORE)
2299     return true;
2300 #else
2301     Q_Q(const QWidget);
2302     if (q->testAttribute(Qt::WA_PaintOnScreen)
2303             || (!q->isWindow() && q->window()->testAttribute(Qt::WA_PaintOnScreen))) {
2304         return true;
2305     }
2306 
2307     return false;
2308 #endif
2309 }
2310 
2311 void QWidgetPrivate::updateIsOpaque()
2312 {
2313     // hw: todo: only needed if opacity actually changed
2314     setDirtyOpaqueRegion();
2315 
2316 #if QT_CONFIG(graphicseffect)
2317     if (graphicsEffect) {
2318         // ### We should probably add QGraphicsEffect::isOpaque at some point.
2319         setOpaque(false);
2320         return;
2321     }
2322 #endif // QT_CONFIG(graphicseffect)
2323 
2324     Q_Q(QWidget);
2325 #if 0 // Used to be included in Qt4 for Q_WS_X11
2326     if (q->testAttribute(Qt::WA_X11OpenGLOverlay)) {
2327         setOpaque(false);
2328         return;
2329     }
2330 #endif
2331 
2332     if (q->testAttribute(Qt::WA_OpaquePaintEvent) || q->testAttribute(Qt::WA_PaintOnScreen)) {
2333         setOpaque(true);
2334         return;
2335     }
2336 
2337     const QPalette &pal = q->palette();
2338 
2339     if (q->autoFillBackground()) {
2340         const QBrush &autoFillBrush = pal.brush(q->backgroundRole());
2341         if (autoFillBrush.style() != Qt::NoBrush && autoFillBrush.isOpaque()) {
2342             setOpaque(true);
2343             return;
2344         }
2345     }
2346 
2347     if (q->isWindow() && !q->testAttribute(Qt::WA_NoSystemBackground)) {
2348         const QBrush &windowBrush = q->palette().brush(QPalette::Window);
2349         if (windowBrush.style() != Qt::NoBrush && windowBrush.isOpaque()) {
2350             setOpaque(true);
2351             return;
2352         }
2353     }
2354     setOpaque(false);
2355 }
2356 
2357 void QWidgetPrivate::setOpaque(bool opaque)
2358 {
2359     if (isOpaque != opaque) {
2360         isOpaque = opaque;
2361         updateIsTranslucent();
2362     }
2363 }
2364 
2365 void QWidgetPrivate::updateIsTranslucent()
2366 {
2367     Q_Q(QWidget);
2368     if (QWindow *window = q->windowHandle()) {
2369         QSurfaceFormat format = window->format();
2370         const int oldAlpha = format.alphaBufferSize();
2371         const int newAlpha = q->testAttribute(Qt::WA_TranslucentBackground)? 8 : 0;
2372         if (oldAlpha != newAlpha) {
2373             format.setAlphaBufferSize(newAlpha);
2374             window->setFormat(format);
2375         }
2376     }
2377 }
2378 
2379 static inline void fillRegion(QPainter *painter, const QRegion &rgn, const QBrush &brush)
2380 {
2381     Q_ASSERT(painter);
2382 
2383     if (brush.style() == Qt::TexturePattern) {
2384 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2385         // Optimize pattern filling on mac by using HITheme directly
2386         // when filling with the standard widget background.
2387         // Defined in qmacstyle_mac.cpp
2388         extern void qt_mac_fill_background(QPainter *painter, const QRegion &rgn, const QBrush &brush);
2389         qt_mac_fill_background(painter, rgn, brush);
2390 #else
2391         {
2392             const QRect rect(rgn.boundingRect());
2393             painter->setClipRegion(rgn);
2394             painter->drawTiledPixmap(rect, brush.texture(), rect.topLeft());
2395         }
2396 #endif
2397 
2398     } else if (brush.gradient()
2399                && brush.gradient()->coordinateMode() == QGradient::ObjectBoundingMode) {
2400         painter->save();
2401         painter->setClipRegion(rgn);
2402         painter->fillRect(0, 0, painter->device()->width(), painter->device()->height(), brush);
2403         painter->restore();
2404     } else {
2405         for (const QRect &rect : rgn)
2406             painter->fillRect(rect, brush);
2407     }
2408 }
2409 
2410 void QWidgetPrivate::paintBackground(QPainter *painter, const QRegion &rgn, int flags) const
2411 {
2412     Q_Q(const QWidget);
2413 
2414 #if QT_CONFIG(scrollarea)
2415     bool resetBrushOrigin = false;
2416     QPointF oldBrushOrigin;
2417     //If we are painting the viewport of a scrollarea, we must apply an offset to the brush in case we are drawing a texture
2418     QAbstractScrollArea *scrollArea = qobject_cast<QAbstractScrollArea *>(parent);
2419     if (scrollArea && scrollArea->viewport() == q) {
2420         QObjectData *scrollPrivate = static_cast<QWidget *>(scrollArea)->d_ptr.data();
2421         QAbstractScrollAreaPrivate *priv = static_cast<QAbstractScrollAreaPrivate *>(scrollPrivate);
2422         oldBrushOrigin = painter->brushOrigin();
2423         resetBrushOrigin = true;
2424         painter->setBrushOrigin(-priv->contentsOffset());
2425 
2426     }
2427 #endif // QT_CONFIG(scrollarea)
2428 
2429     const QBrush autoFillBrush = q->palette().brush(q->backgroundRole());
2430 
2431     if ((flags & DrawAsRoot) && !(q->autoFillBackground() && autoFillBrush.isOpaque())) {
2432         const QBrush bg = q->palette().brush(QPalette::Window);
2433         if (!(flags & DontSetCompositionMode)) {
2434             //copy alpha straight in
2435             QPainter::CompositionMode oldMode = painter->compositionMode();
2436             painter->setCompositionMode(QPainter::CompositionMode_Source);
2437             fillRegion(painter, rgn, bg);
2438             painter->setCompositionMode(oldMode);
2439         } else {
2440             fillRegion(painter, rgn, bg);
2441         }
2442     }
2443 
2444     if (q->autoFillBackground())
2445         fillRegion(painter, rgn, autoFillBrush);
2446 
2447     if (q->testAttribute(Qt::WA_StyledBackground)) {
2448         painter->setClipRegion(rgn);
2449         QStyleOption opt;
2450         opt.initFrom(q);
2451         q->style()->drawPrimitive(QStyle::PE_Widget, &opt, painter, q);
2452     }
2453 
2454 #if QT_CONFIG(scrollarea)
2455     if (resetBrushOrigin)
2456         painter->setBrushOrigin(oldBrushOrigin);
2457 #endif // QT_CONFIG(scrollarea)
2458 }
2459 
2460 /*
2461   \internal
2462   This function is called when a widget is hidden or destroyed.
2463   It resets some application global pointers that should only refer active,
2464   visible widgets.
2465 */
2466 
2467 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2468     extern QPointer<QWidget> qt_button_down;
2469 #else
2470     extern QWidget *qt_button_down;
2471 #endif
2472 
2473 void QWidgetPrivate::deactivateWidgetCleanup()
2474 {
2475     Q_Q(QWidget);
2476     // If this was the active application window, reset it
2477     if (QApplication::activeWindow() == q)
2478         QApplication::setActiveWindow(0);
2479     // If the is the active mouse press widget, reset it
2480     if (q == qt_button_down)
2481         qt_button_down = 0;
2482 }
2483 
2484 
2485 /*!
2486     Returns a pointer to the widget with window identifer/handle \a
2487     id.
2488 
2489     The window identifier type depends on the underlying window
2490     system, see \c qwindowdefs.h for the actual definition. If there
2491     is no widget with this identifier, 0 is returned.
2492 */
2493 
2494 QWidget *QWidget::find(WId id)
2495 {
2496     return QWidgetPrivate::mapper ? QWidgetPrivate::mapper->value(id, 0) : 0;
2497 }
2498 
2499 
2500 
2501 /*!
2502     \fn WId QWidget::internalWinId() const
2503     \internal
2504     Returns the window system identifier of the widget, or 0 if the widget is not created yet.
2505 
2506 */
2507 
2508 /*!
2509     \fn WId QWidget::winId() const
2510 
2511     Returns the window system identifier of the widget.
2512 
2513     Portable in principle, but if you use it you are probably about to
2514     do something non-portable. Be careful.
2515 
2516     If a widget is non-native (alien) and winId() is invoked on it, that widget
2517     will be provided a native handle.
2518 
2519     This value may change at run-time. An event with type QEvent::WinIdChange
2520     will be sent to the widget following a change in window system identifier.
2521 
2522     \sa find()
2523 */
2524 WId QWidget::winId() const
2525 {
2526     if (!testAttribute(Qt::WA_WState_Created) || !internalWinId()) {
2527 #ifdef ALIEN_DEBUG
2528         qDebug() << "QWidget::winId: creating native window for" << this;
2529 #endif
2530         QWidget *that = const_cast<QWidget*>(this);
2531         that->setAttribute(Qt::WA_NativeWindow);
2532         that->d_func()->createWinId();
2533         return that->data->winid;
2534     }
2535     return data->winid;
2536 }
2537 
2538 void QWidgetPrivate::createWinId()
2539 {
2540     Q_Q(QWidget);
2541 
2542 #ifdef ALIEN_DEBUG
2543     qDebug() << "QWidgetPrivate::createWinId for" << q;
2544 #endif
2545     const bool forceNativeWindow = q->testAttribute(Qt::WA_NativeWindow);
2546     if (!q->testAttribute(Qt::WA_WState_Created) || (forceNativeWindow && !q->internalWinId())) {
2547         if (!q->isWindow()) {
2548             QWidget *parent = q->parentWidget();
2549             QWidgetPrivate *pd = parent->d_func();
2550             if (forceNativeWindow && !q->testAttribute(Qt::WA_DontCreateNativeAncestors))
2551                 parent->setAttribute(Qt::WA_NativeWindow);
2552             if (!parent->internalWinId()) {
2553                 pd->createWinId();
2554             }
2555 
2556             for (int i = 0; i < pd->children.size(); ++i) {
2557                 QWidget *w = qobject_cast<QWidget *>(pd->children.at(i));
2558                 if (w && !w->isWindow() && (!w->testAttribute(Qt::WA_WState_Created)
2559                                             || (!w->internalWinId() && w->testAttribute(Qt::WA_NativeWindow)))) {
2560                     w->create();
2561                 }
2562             }
2563         } else {
2564             q->create();
2565         }
2566     }
2567 }
2568 
2569 
2570 /*!
2571 \internal
2572 Ensures that the widget has a window system identifier, i.e. that it is known to the windowing system.
2573 
2574 */
2575 
2576 void QWidget::createWinId()
2577 {
2578     Q_D(QWidget);
2579 #ifdef ALIEN_DEBUG
2580     qDebug()  << "QWidget::createWinId" << this;
2581 #endif
2582 //    qWarning("QWidget::createWinId is obsolete, please fix your code.");
2583     d->createWinId();
2584 }
2585 
2586 /*!
2587     \since 4.4
2588 
2589     Returns the effective window system identifier of the widget, i.e. the
2590     native parent's window system identifier.
2591 
2592     If the widget is native, this function returns the native widget ID.
2593     Otherwise, the window ID of the first native parent widget, i.e., the
2594     top-level widget that contains this widget, is returned.
2595 
2596     \note We recommend that you do not store this value as it is likely to
2597     change at run-time.
2598 
2599     \sa nativeParentWidget()
2600 */
2601 WId QWidget::effectiveWinId() const
2602 {
2603     const WId id = internalWinId();
2604     if (id || !testAttribute(Qt::WA_WState_Created))
2605         return id;
2606     if (const QWidget *realParent = nativeParentWidget())
2607         return realParent->internalWinId();
2608     return 0;
2609 }
2610 
2611 /*!
2612     If this is a native widget, return the associated QWindow.
2613     Otherwise return null.
2614 
2615     Native widgets include toplevel widgets, QGLWidget, and child widgets
2616     on which winId() was called.
2617 
2618     \since 5.0
2619 
2620     \sa winId()
2621 */
2622 QWindow *QWidget::windowHandle() const
2623 {
2624     Q_D(const QWidget);
2625     return d->windowHandle();
2626 }
2627 
2628 #ifndef QT_NO_STYLE_STYLESHEET
2629 
2630 /*!
2631     \property QWidget::styleSheet
2632     \brief the widget's style sheet
2633     \since 4.2
2634 
2635     The style sheet contains a textual description of customizations to the
2636     widget's style, as described in the \l{Qt Style Sheets} document.
2637 
2638     Since Qt 4.5, Qt style sheets fully supports \macos.
2639 
2640     \warning Qt style sheets are currently not supported for custom QStyle
2641     subclasses. We plan to address this in some future release.
2642 
2643     \sa setStyle(), QApplication::styleSheet, {Qt Style Sheets}
2644 */
2645 QString QWidget::styleSheet() const
2646 {
2647     Q_D(const QWidget);
2648     if (!d->extra)
2649         return QString();
2650     return d->extra->styleSheet;
2651 }
2652 
2653 void QWidget::setStyleSheet(const QString& styleSheet)
2654 {
2655     Q_D(QWidget);
2656     if (data->in_destructor)
2657         return;
2658     d->createExtra();
2659 
2660     QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(d->extra->style);
2661     d->extra->styleSheet = styleSheet;
2662     if (styleSheet.isEmpty()) { // stylesheet removed
2663         if (!proxy)
2664             return;
2665 
2666         d->inheritStyle();
2667         return;
2668     }
2669 
2670     if (proxy) { // style sheet update
2671         if (d->polished)
2672             proxy->repolish(this);
2673         return;
2674     }
2675 
2676     if (testAttribute(Qt::WA_SetStyle)) {
2677         d->setStyle_helper(new QStyleSheetStyle(d->extra->style), true);
2678     } else {
2679         d->setStyle_helper(new QStyleSheetStyle(0), true);
2680     }
2681 }
2682 
2683 #endif // QT_NO_STYLE_STYLESHEET
2684 
2685 /*!
2686     \sa QWidget::setStyle(), QApplication::setStyle(), QApplication::style()
2687 */
2688 
2689 QStyle *QWidget::style() const
2690 {
2691     Q_D(const QWidget);
2692 
2693     if (d->extra && d->extra->style)
2694         return d->extra->style;
2695     return QApplication::style();
2696 }
2697 
2698 /*!
2699     Sets the widget's GUI style to \a style. The ownership of the style
2700     object is not transferred.
2701 
2702     If no style is set, the widget uses the application's style,
2703     QApplication::style() instead.
2704 
2705     Setting a widget's style has no effect on existing or future child
2706     widgets.
2707 
2708     \warning This function is particularly useful for demonstration
2709     purposes, where you want to show Qt's styling capabilities. Real
2710     applications should avoid it and use one consistent GUI style
2711     instead.
2712 
2713     \warning Qt style sheets are currently not supported for custom QStyle
2714     subclasses. We plan to address this in some future release.
2715 
2716     \sa style(), QStyle, QApplication::style(), QApplication::setStyle()
2717 */
2718 
2719 void QWidget::setStyle(QStyle *style)
2720 {
2721     Q_D(QWidget);
2722 
2723     if (auto proxy = qobject_cast<QProxyStyle*>(style)) {
2724         if (proxy->baseStyle() == qApp->style()) {
2725             qWarning() << "QWidget::setStyle: proxy style is stealing ownership from QApplication, might crash";
2726 #if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
2727             // people had enough time to fix their code by the time Qt 6 arrives
2728             return;
2729 #endif
2730         }
2731     }
2732 
2733     setAttribute(Qt::WA_SetStyle, style != 0);
2734     d->createExtra();
2735 #ifndef QT_NO_STYLE_STYLESHEET
2736     if (QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(style)) {
2737         //if for some reason someone try to set a QStyleSheetStyle, ref it
2738         //(this may happen for exemple in QButtonDialogBox which propagates its style)
2739         proxy->ref();
2740         d->setStyle_helper(style, false);
2741     } else if (qobject_cast<QStyleSheetStyle *>(d->extra->style) || !qApp->styleSheet().isEmpty()) {
2742         // if we have an application stylesheet or have a proxy already, propagate
2743         d->setStyle_helper(new QStyleSheetStyle(style), true);
2744     } else
2745 #endif
2746         d->setStyle_helper(style, false);
2747 }
2748 
2749 void QWidgetPrivate::setStyle_helper(QStyle *newStyle, bool propagate, bool
2750 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2751         metalHack
2752 #endif
2753         )
2754 {
2755     Q_Q(QWidget);
2756     QStyle *oldStyle  = q->style();
2757 #ifndef QT_NO_STYLE_STYLESHEET
2758     QPointer<QStyle> origStyle;
2759 #endif
2760 
2761 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2762     // the metalhack boolean allows Qt/Mac to do a proper re-polish depending
2763     // on how the Qt::WA_MacBrushedMetal attribute is set. It is only ever
2764     // set when changing that attribute and passes the widget's CURRENT style.
2765     // therefore no need to do a reassignment.
2766     if (!metalHack)
2767 #endif
2768     {
2769         createExtra();
2770 
2771 #ifndef QT_NO_STYLE_STYLESHEET
2772         origStyle = extra->style.data();
2773 #endif
2774         extra->style = newStyle;
2775     }
2776 
2777     // repolish
2778     if (q->windowType() != Qt::Desktop) {
2779         if (polished) {
2780             oldStyle->unpolish(q);
2781 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2782             if (metalHack)
2783                 macUpdateMetalAttribute();
2784 #endif
2785             q->style()->polish(q);
2786 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2787         } else if (metalHack) {
2788             macUpdateMetalAttribute();
2789 #endif
2790         }
2791     }
2792 
2793     if (propagate) {
2794         // We copy the list because the order may be modified
2795         const QObjectList childrenList = children;
2796         for (int i = 0; i < childrenList.size(); ++i) {
2797             QWidget *c = qobject_cast<QWidget*>(childrenList.at(i));
2798             if (c)
2799                 c->d_func()->inheritStyle();
2800         }
2801     }
2802 
2803 #ifndef QT_NO_STYLE_STYLESHEET
2804     if (!qobject_cast<QStyleSheetStyle*>(newStyle)) {
2805         if (const QStyleSheetStyle* cssStyle = qobject_cast<QStyleSheetStyle*>(origStyle.data())) {
2806             cssStyle->clearWidgetFont(q);
2807         }
2808     }
2809 #endif
2810 
2811     QEvent e(QEvent::StyleChange);
2812     QApplication::sendEvent(q, &e);
2813 
2814 #ifndef QT_NO_STYLE_STYLESHEET
2815     // dereference the old stylesheet style
2816     if (QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(origStyle.data()))
2817         proxy->deref();
2818 #endif
2819 }
2820 
2821 // Inherits style from the current parent and propagates it as necessary
2822 void QWidgetPrivate::inheritStyle()
2823 {
2824 #ifndef QT_NO_STYLE_STYLESHEET
2825     Q_Q(QWidget);
2826 
2827     QStyleSheetStyle *proxy = extra ? qobject_cast<QStyleSheetStyle *>(extra->style) : 0;
2828 
2829     if (!q->styleSheet().isEmpty()) {
2830         Q_ASSERT(proxy);
2831         proxy->repolish(q);
2832         return;
2833     }
2834 
2835     QStyle *origStyle = proxy ? proxy->base : (extra ? (QStyle*)extra->style : 0);
2836     QWidget *parent = q->parentWidget();
2837     QStyle *parentStyle = (parent && parent->d_func()->extra) ? (QStyle*)parent->d_func()->extra->style : 0;
2838     // If we have stylesheet on app or parent has stylesheet style, we need
2839     // to be running a proxy
2840     if (!qApp->styleSheet().isEmpty() || qobject_cast<QStyleSheetStyle *>(parentStyle)) {
2841         QStyle *newStyle = parentStyle;
2842         if (q->testAttribute(Qt::WA_SetStyle))
2843             newStyle = new QStyleSheetStyle(origStyle);
2844         else if (QStyleSheetStyle *newProxy = qobject_cast<QStyleSheetStyle *>(parentStyle))
2845             newProxy->ref();
2846 
2847         setStyle_helper(newStyle, true);
2848         return;
2849     }
2850 
2851     // So, we have no stylesheet on parent/app and we have an empty stylesheet
2852     // we just need our original style back
2853     if (origStyle == (extra ? (QStyle*)extra->style : 0)) // is it any different?
2854         return;
2855 
2856     // We could have inherited the proxy from our parent (which has a custom style)
2857     // In such a case we need to start following the application style (i.e revert
2858     // the propagation behavior of QStyleSheetStyle)
2859     if (!q->testAttribute(Qt::WA_SetStyle))
2860         origStyle = 0;
2861 
2862     setStyle_helper(origStyle, true);
2863 #endif // QT_NO_STYLE_STYLESHEET
2864 }
2865 
2866 
2867 /*!
2868     \fn bool QWidget::isWindow() const
2869 
2870     Returns \c true if the widget is an independent window, otherwise
2871     returns \c false.
2872 
2873     A window is a widget that isn't visually the child of any other
2874     widget and that usually has a frame and a
2875     \l{QWidget::setWindowTitle()}{window title}.
2876 
2877     A window can have a \l{QWidget::parentWidget()}{parent widget}.
2878     It will then be grouped with its parent and deleted when the
2879     parent is deleted, minimized when the parent is minimized etc. If
2880     supported by the window manager, it will also have a common
2881     taskbar entry with its parent.
2882 
2883     QDialog and QMainWindow widgets are by default windows, even if a
2884     parent widget is specified in the constructor. This behavior is
2885     specified by the Qt::Window flag.
2886 
2887     \sa window(), isModal(), parentWidget()
2888 */
2889 
2890 /*!
2891     \property QWidget::modal
2892     \brief whether the widget is a modal widget
2893 
2894     This property only makes sense for windows. A modal widget
2895     prevents widgets in all other windows from getting any input.
2896 
2897     By default, this property is \c false.
2898 
2899     \sa isWindow(), windowModality, QDialog
2900 */
2901 
2902 /*!
2903     \property QWidget::windowModality
2904     \brief which windows are blocked by the modal widget
2905     \since 4.1
2906 
2907     This property only makes sense for windows. A modal widget
2908     prevents widgets in other windows from getting input. The value of
2909     this property controls which windows are blocked when the widget
2910     is visible. Changing this property while the window is visible has
2911     no effect; you must hide() the widget first, then show() it again.
2912 
2913     By default, this property is Qt::NonModal.
2914 
2915     \sa isWindow(), QWidget::modal, QDialog
2916 */
2917 
2918 Qt::WindowModality QWidget::windowModality() const
2919 {
2920     return static_cast<Qt::WindowModality>(data->window_modality);
2921 }
2922 
2923 void QWidget::setWindowModality(Qt::WindowModality windowModality)
2924 {
2925     data->window_modality = windowModality;
2926     // setModal_sys() will be called by setAttribute()
2927     setAttribute(Qt::WA_ShowModal, (data->window_modality != Qt::NonModal));
2928     setAttribute(Qt::WA_SetWindowModality, true);
2929 }
2930 
2931 void QWidgetPrivate::setModal_sys()
2932 {
2933     Q_Q(QWidget);
2934     if (q->windowHandle())
2935         q->windowHandle()->setModality(q->windowModality());
2936 }
2937 
2938 /*!
2939     \fn bool QWidget::underMouse() const
2940 
2941     Returns \c true if the widget is under the mouse cursor; otherwise
2942     returns \c false.
2943 
2944     This value is not updated properly during drag and drop
2945     operations.
2946 
2947     \sa enterEvent(), leaveEvent()
2948 */
2949 
2950 /*!
2951     \property QWidget::minimized
2952     \brief whether this widget is minimized (iconified)
2953 
2954     This property is only relevant for windows.
2955 
2956     By default, this property is \c false.
2957 
2958     \sa showMinimized(), visible, show(), hide(), showNormal(), maximized
2959 */
2960 bool QWidget::isMinimized() const
2961 { return data->window_state & Qt::WindowMinimized; }
2962 
2963 /*!
2964     Shows the widget minimized, as an icon.
2965 
2966     Calling this function only affects \l{isWindow()}{windows}.
2967 
2968     \sa showNormal(), showMaximized(), show(), hide(), isVisible(),
2969         isMinimized()
2970 */
2971 void QWidget::showMinimized()
2972 {
2973     bool isMin = isMinimized();
2974     if (isMin && isVisible())
2975         return;
2976 
2977     ensurePolished();
2978 
2979     if (!isMin)
2980         setWindowState((windowState() & ~Qt::WindowActive) | Qt::WindowMinimized);
2981     setVisible(true);
2982 }
2983 
2984 /*!
2985     \property QWidget::maximized
2986     \brief whether this widget is maximized
2987 
2988     This property is only relevant for windows.
2989 
2990     \note Due to limitations on some window systems, this does not always
2991     report the expected results (e.g., if the user on X11 maximizes the
2992     window via the window manager, Qt has no way of distinguishing this
2993     from any other resize). This is expected to improve as window manager
2994     protocols evolve.
2995 
2996     By default, this property is \c false.
2997 
2998     \sa windowState(), showMaximized(), visible, show(), hide(), showNormal(), minimized
2999 */
3000 bool QWidget::isMaximized() const
3001 { return data->window_state & Qt::WindowMaximized; }
3002 
3003 
3004 
3005 /*!
3006     Returns the current window state. The window state is a OR'ed
3007     combination of Qt::WindowState: Qt::WindowMinimized,
3008     Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.
3009 
3010   \sa Qt::WindowState, setWindowState()
3011  */
3012 Qt::WindowStates QWidget::windowState() const
3013 {
3014     return Qt::WindowStates(data->window_state);
3015 }
3016 
3017 /*!\internal
3018 
3019    The function sets the window state on child widgets similar to
3020    setWindowState(). The difference is that the window state changed
3021    event has the isOverride() flag set. It exists mainly to keep
3022    QWorkspace working.
3023  */
3024 void QWidget::overrideWindowState(Qt::WindowStates newstate)
3025 {
3026     QWindowStateChangeEvent e(Qt::WindowStates(data->window_state), true);
3027     data->window_state  = newstate;
3028     QApplication::sendEvent(this, &e);
3029 }
3030 
3031 /*!
3032     \fn void QWidget::setWindowState(Qt::WindowStates windowState)
3033 
3034     Sets the window state to \a windowState. The window state is a OR'ed
3035     combination of Qt::WindowState: Qt::WindowMinimized,
3036     Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.
3037 
3038     If the window is not visible (i.e. isVisible() returns \c false), the
3039     window state will take effect when show() is called. For visible
3040     windows, the change is immediate. For example, to toggle between
3041     full-screen and normal mode, use the following code:
3042 
3043     \snippet code/src_gui_kernel_qwidget.cpp 0
3044 
3045     In order to restore and activate a minimized window (while
3046     preserving its maximized and/or full-screen state), use the following:
3047 
3048     \snippet code/src_gui_kernel_qwidget.cpp 1
3049 
3050     Calling this function will hide the widget. You must call show() to make
3051     the widget visible again.
3052 
3053     \note On some window systems Qt::WindowActive is not immediate, and may be
3054     ignored in certain cases.
3055 
3056     When the window state changes, the widget receives a changeEvent()
3057     of type QEvent::WindowStateChange.
3058 
3059     \sa Qt::WindowState, windowState()
3060 */
3061 void QWidget::setWindowState(Qt::WindowStates newstate)
3062 {
3063     Q_D(QWidget);
3064     Qt::WindowStates oldstate = windowState();
3065     if (oldstate == newstate)
3066         return;
3067     if (isWindow() && !testAttribute(Qt::WA_WState_Created))
3068         create();
3069 
3070     data->window_state = newstate;
3071     data->in_set_window_state = 1;
3072     if (isWindow()) {
3073         // Ensure the initial size is valid, since we store it as normalGeometry below.
3074         if (!testAttribute(Qt::WA_Resized) && !isVisible())
3075             adjustSize();
3076 
3077         d->createTLExtra();
3078         if (!(oldstate & (Qt::WindowMinimized | Qt::WindowMaximized | Qt::WindowFullScreen)))
3079             d->topData()->normalGeometry = geometry();
3080 
3081         Q_ASSERT(windowHandle());
3082         windowHandle()->setWindowStates(newstate & ~Qt::WindowActive);
3083     }
3084     data->in_set_window_state = 0;
3085 
3086     if (newstate & Qt::WindowActive)
3087         activateWindow();
3088 
3089     QWindowStateChangeEvent e(oldstate);
3090     QApplication::sendEvent(this, &e);
3091 }
3092 
3093 /*!
3094     \property QWidget::fullScreen
3095     \brief whether the widget is shown in full screen mode
3096 
3097     A widget in full screen mode occupies the whole screen area and does not
3098     display window decorations, such as a title bar.
3099 
3100     By default, this property is \c false.
3101 
3102     \sa windowState(), minimized, maximized
3103 */
3104 bool QWidget::isFullScreen() const
3105 { return data->window_state & Qt::WindowFullScreen; }
3106 
3107 /*!
3108     Shows the widget in full-screen mode.
3109 
3110     Calling this function only affects \l{isWindow()}{windows}.
3111 
3112     To return from full-screen mode, call showNormal().
3113 
3114     Full-screen mode works fine under Windows, but has certain
3115     problems under X. These problems are due to limitations of the
3116     ICCCM protocol that specifies the communication between X11
3117     clients and the window manager. ICCCM simply does not understand
3118     the concept of non-decorated full-screen windows. Therefore, the
3119     best we can do is to request a borderless window and place and
3120     resize it to fill the entire screen. Depending on the window
3121     manager, this may or may not work. The borderless window is
3122     requested using MOTIF hints, which are at least partially
3123     supported by virtually all modern window managers.
3124 
3125     An alternative would be to bypass the window manager entirely and
3126     create a window with the Qt::X11BypassWindowManagerHint flag. This
3127     has other severe problems though, like totally broken keyboard focus
3128     and very strange effects on desktop changes or when the user raises
3129     other windows.
3130 
3131     X11 window managers that follow modern post-ICCCM specifications
3132     support full-screen mode properly.
3133 
3134     \sa showNormal(), showMaximized(), show(), hide(), isVisible()
3135 */
3136 void QWidget::showFullScreen()
3137 {
3138 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3139     // If the unified toolbar is enabled, we have to disable it before going fullscreen.
3140     QMainWindow *mainWindow = qobject_cast<QMainWindow*>(this);
3141     if (mainWindow && mainWindow->unifiedTitleAndToolBarOnMac()) {
3142         mainWindow->setUnifiedTitleAndToolBarOnMac(false);
3143         QMainWindowLayout *mainLayout = qobject_cast<QMainWindowLayout*>(mainWindow->layout());
3144         mainLayout->activateUnifiedToolbarAfterFullScreen = true;
3145     }
3146 #endif
3147     ensurePolished();
3148 
3149     setWindowState((windowState() & ~(Qt::WindowMinimized | Qt::WindowMaximized))
3150                    | Qt::WindowFullScreen);
3151     setVisible(true);
3152 #if !defined Q_OS_QNX // On QNX this window will be activated anyway from libscreen
3153                       // activating it here before libscreen activates it causes problems
3154     activateWindow();
3155 #endif
3156 }
3157 
3158 /*!
3159     Shows the widget maximized.
3160 
3161     Calling this function only affects \l{isWindow()}{windows}.
3162 
3163     On X11, this function may not work properly with certain window
3164     managers. See the \l{Window Geometry} documentation for an explanation.
3165 
3166     \sa setWindowState(), showNormal(), showMinimized(), show(), hide(), isVisible()
3167 */
3168 void QWidget::showMaximized()
3169 {
3170     ensurePolished();
3171 
3172     setWindowState((windowState() & ~(Qt::WindowMinimized | Qt::WindowFullScreen))
3173                    | Qt::WindowMaximized);
3174 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3175     // If the unified toolbar was enabled before going fullscreen, we have to enable it back.
3176     QMainWindow *mainWindow = qobject_cast<QMainWindow*>(this);
3177     if (mainWindow)
3178     {
3179         QMainWindowLayout *mainLayout = qobject_cast<QMainWindowLayout*>(mainWindow->layout());
3180         if (mainLayout->activateUnifiedToolbarAfterFullScreen) {
3181             mainWindow->setUnifiedTitleAndToolBarOnMac(true);
3182             mainLayout->activateUnifiedToolbarAfterFullScreen = false;
3183         }
3184     }
3185 #endif
3186     setVisible(true);
3187 }
3188 
3189 /*!
3190     Restores the widget after it has been maximized or minimized.
3191 
3192     Calling this function only affects \l{isWindow()}{windows}.
3193 
3194     \sa setWindowState(), showMinimized(), showMaximized(), show(), hide(), isVisible()
3195 */
3196 void QWidget::showNormal()
3197 {
3198     ensurePolished();
3199 
3200     setWindowState(windowState() & ~(Qt::WindowMinimized
3201                                      | Qt::WindowMaximized
3202                                      | Qt::WindowFullScreen));
3203 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3204     // If the unified toolbar was enabled before going fullscreen, we have to enable it back.
3205     QMainWindow *mainWindow = qobject_cast<QMainWindow*>(this);
3206     if (mainWindow)
3207     {
3208         QMainWindowLayout *mainLayout = qobject_cast<QMainWindowLayout*>(mainWindow->layout());
3209         if (mainLayout->activateUnifiedToolbarAfterFullScreen) {
3210             mainWindow->setUnifiedTitleAndToolBarOnMac(true);
3211             mainLayout->activateUnifiedToolbarAfterFullScreen = false;
3212         }
3213     }
3214 #endif
3215     setVisible(true);
3216 }
3217 
3218 /*!
3219     Returns \c true if this widget would become enabled if \a ancestor is
3220     enabled; otherwise returns \c false.
3221 
3222 
3223 
3224     This is the case if neither the widget itself nor every parent up
3225     to but excluding \a ancestor has been explicitly disabled.
3226 
3227     isEnabledTo(0) returns false if this widget or any if its ancestors
3228     was explicitly disabled.
3229 
3230     The word ancestor here means a parent widget within the same window.
3231 
3232     Therefore isEnabledTo(0) stops at this widget's window, unlike
3233     isEnabled() which also takes parent windows into considerations.
3234 
3235     \sa setEnabled(), enabled
3236 */
3237 
3238 bool QWidget::isEnabledTo(const QWidget *ancestor) const
3239 {
3240     const QWidget * w = this;
3241     while (!w->testAttribute(Qt::WA_ForceDisabled)
3242             && !w->isWindow()
3243             && w->parentWidget()
3244             && w->parentWidget() != ancestor)
3245         w = w->parentWidget();
3246     return !w->testAttribute(Qt::WA_ForceDisabled);
3247 }
3248 
3249 #ifndef QT_NO_ACTION
3250 /*!
3251     Appends the action \a action to this widget's list of actions.
3252 
3253     All QWidgets have a list of \l{QAction}s, however they can be
3254     represented graphically in many different ways. The default use of
3255     the QAction list (as returned by actions()) is to create a context
3256     QMenu.
3257 
3258     A QWidget should only have one of each action and adding an action
3259     it already has will not cause the same action to be in the widget twice.
3260 
3261     The ownership of \a action is not transferred to this QWidget.
3262 
3263     \sa removeAction(), insertAction(), actions(), QMenu
3264 */
3265 void QWidget::addAction(QAction *action)
3266 {
3267     insertAction(0, action);
3268 }
3269 
3270 /*!
3271     Appends the actions \a actions to this widget's list of actions.
3272 
3273     \sa removeAction(), QMenu, addAction()
3274 */
3275 #if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
3276 void QWidget::addActions(const QList<QAction *> &actions)
3277 #else
3278 void QWidget::addActions(QList<QAction*> actions)
3279 #endif
3280 {
3281     for(int i = 0; i < actions.count(); i++)
3282         insertAction(0, actions.at(i));
3283 }
3284 
3285 /*!
3286     Inserts the action \a action to this widget's list of actions,
3287     before the action \a before. It appends the action if \a before is 0 or
3288     \a before is not a valid action for this widget.
3289 
3290     A QWidget should only have one of each action.
3291 
3292     \sa removeAction(), addAction(), QMenu, contextMenuPolicy, actions()
3293 */
3294 void QWidget::insertAction(QAction *before, QAction *action)
3295 {
3296     if (Q_UNLIKELY(!action)) {
3297         qWarning("QWidget::insertAction: Attempt to insert null action");
3298         return;
3299     }
3300 
3301     Q_D(QWidget);
3302     if(d->actions.contains(action))
3303         removeAction(action);
3304 
3305     int pos = d->actions.indexOf(before);
3306     if (pos < 0) {
3307         before = 0;
3308         pos = d->actions.size();
3309     }
3310     d->actions.insert(pos, action);
3311 
3312     QActionPrivate *apriv = action->d_func();
3313     apriv->widgets.append(this);
3314 
3315     QActionEvent e(QEvent::ActionAdded, action, before);
3316     QApplication::sendEvent(this, &e);
3317 }
3318 
3319 /*!
3320     Inserts the actions \a actions to this widget's list of actions,
3321     before the action \a before. It appends the action if \a before is 0 or
3322     \a before is not a valid action for this widget.
3323 
3324     A QWidget can have at most one of each action.
3325 
3326     \sa removeAction(), QMenu, insertAction(), contextMenuPolicy
3327 */
3328 #if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
3329 void QWidget::insertActions(QAction *before, const QList<QAction*> &actions)
3330 #else
3331 void QWidget::insertActions(QAction *before, QList<QAction*> actions)
3332 #endif
3333 {
3334     for(int i = 0; i < actions.count(); ++i)
3335         insertAction(before, actions.at(i));
3336 }
3337 
3338 /*!
3339     Removes the action \a action from this widget's list of actions.
3340     \sa insertAction(), actions(), insertAction()
3341 */
3342 void QWidget::removeAction(QAction *action)
3343 {
3344     if (!action)
3345         return;
3346 
3347     Q_D(QWidget);
3348 
3349     QActionPrivate *apriv = action->d_func();
3350     apriv->widgets.removeAll(this);
3351 
3352     if (d->actions.removeAll(action)) {
3353         QActionEvent e(QEvent::ActionRemoved, action);
3354         QApplication::sendEvent(this, &e);
3355     }
3356 }
3357 
3358 /*!
3359     Returns the (possibly empty) list of this widget's actions.
3360 
3361     \sa contextMenuPolicy, insertAction(), removeAction()
3362 */
3363 QList<QAction*> QWidget::actions() const
3364 {
3365     Q_D(const QWidget);
3366     return d->actions;
3367 }
3368 #endif // QT_NO_ACTION
3369 
3370 /*!
3371   \fn bool QWidget::isEnabledToTLW() const
3372   \obsolete
3373 
3374   This function is deprecated. It is equivalent to isEnabled()
3375 */
3376 
3377 /*!
3378     \property QWidget::enabled
3379     \brief whether the widget is enabled
3380 
3381     In general an enabled widget handles keyboard and mouse events; a disabled
3382     widget does not. An exception is made with \l{QAbstractButton}.
3383 
3384     Some widgets display themselves differently when they are
3385     disabled. For example a button might draw its label grayed out. If
3386     your widget needs to know when it becomes enabled or disabled, you
3387     can use the changeEvent() with type QEvent::EnabledChange.
3388 
3389     Disabling a widget implicitly disables all its children. Enabling
3390     respectively enables all child widgets unless they have been
3391     explicitly disabled. It it not possible to explicitly enable a child
3392     widget which is not a window while its parent widget remains disabled.
3393 
3394     By default, this property is \c true.
3395 
3396     \sa isEnabledTo(), QKeyEvent, QMouseEvent, changeEvent()
3397 */
3398 void QWidget::setEnabled(bool enable)
3399 {
3400     Q_D(QWidget);
3401     setAttribute(Qt::WA_ForceDisabled, !enable);
3402     d->setEnabled_helper(enable);
3403 }
3404 
3405 void QWidgetPrivate::setEnabled_helper(bool enable)
3406 {
3407     Q_Q(QWidget);
3408 
3409     if (enable && !q->isWindow() && q->parentWidget() && !q->parentWidget()->isEnabled())
3410         return; // nothing we can do
3411 
3412     if (enable != q->testAttribute(Qt::WA_Disabled))
3413         return; // nothing to do
3414 
3415     q->setAttribute(Qt::WA_Disabled, !enable);
3416     updateSystemBackground();
3417 
3418     if (!enable && q->window()->focusWidget() == q) {
3419         bool parentIsEnabled = (!q->parentWidget() || q->parentWidget()->isEnabled());
3420         if (!parentIsEnabled || !q->focusNextChild())
3421             q->clearFocus();
3422     }
3423 
3424     Qt::WidgetAttribute attribute = enable ? Qt::WA_ForceDisabled : Qt::WA_Disabled;
3425     for (int i = 0; i < children.size(); ++i) {
3426         QWidget *w = qobject_cast<QWidget *>(children.at(i));
3427         if (w && !w->testAttribute(attribute))
3428             w->d_func()->setEnabled_helper(enable);
3429     }
3430 #if 0 // Used to be included in Qt4 for Q_WS_X11
3431     if (q->testAttribute(Qt::WA_SetCursor) || q->isWindow()) {
3432         // enforce the windows behavior of clearing the cursor on
3433         // disabled widgets
3434         qt_x11_enforce_cursor(q);
3435     }
3436 #endif
3437 #ifndef QT_NO_CURSOR
3438     if (q->testAttribute(Qt::WA_SetCursor) || q->isWindow()) {
3439         // enforce the windows behavior of clearing the cursor on
3440         // disabled widgets
3441         qt_qpa_set_cursor(q, false);
3442     }
3443 #endif
3444 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3445     setEnabled_helper_sys(enable);
3446 #endif
3447 #ifndef QT_NO_IM
3448     if (q->testAttribute(Qt::WA_InputMethodEnabled) && q->hasFocus()) {
3449         QWidget *focusWidget = effectiveFocusWidget();
3450 
3451         if (enable) {
3452             if (focusWidget->testAttribute(Qt::WA_InputMethodEnabled))
3453                 QGuiApplication::inputMethod()->update(Qt::ImEnabled);
3454         } else {
3455             QGuiApplication::inputMethod()->commit();
3456             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
3457         }
3458     }
3459 #endif //QT_NO_IM
3460     QEvent e(QEvent::EnabledChange);
3461     QApplication::sendEvent(q, &e);
3462 }
3463 
3464 /*!
3465     \property QWidget::acceptDrops
3466     \brief whether drop events are enabled for this widget
3467 
3468     Setting this property to true announces to the system that this
3469     widget \e may be able to accept drop events.
3470 
3471     If the widget is the desktop (windowType() == Qt::Desktop), this may
3472     fail if another application is using the desktop; you can call
3473     acceptDrops() to test if this occurs.
3474 
3475     \warning Do not modify this property in a drag and drop event handler.
3476 
3477     By default, this property is \c false.
3478 
3479     \sa {Drag and Drop}
3480 */
3481 bool QWidget::acceptDrops() const
3482 {
3483     return testAttribute(Qt::WA_AcceptDrops);
3484 }
3485 
3486 void QWidget::setAcceptDrops(bool on)
3487 {
3488     setAttribute(Qt::WA_AcceptDrops, on);
3489 
3490 }
3491 
3492 void QWidgetPrivate::registerDropSite(bool on)
3493 {
3494     Q_UNUSED(on);
3495 }
3496 
3497 /*!
3498     Disables widget input events if \a disable is true; otherwise
3499     enables input events.
3500 
3501     See the \l enabled documentation for more information.
3502 
3503     \sa isEnabledTo(), QKeyEvent, QMouseEvent, changeEvent()
3504 */
3505 void QWidget::setDisabled(bool disable)
3506 {
3507     setEnabled(!disable);
3508 }
3509 
3510 /*!
3511     \property QWidget::frameGeometry
3512     \brief geometry of the widget relative to its parent including any
3513     window frame
3514 
3515     See the \l{Window Geometry} documentation for an overview of geometry
3516     issues with windows.
3517 
3518     By default, this property contains a value that depends on the user's
3519     platform and screen geometry.
3520 
3521     \sa geometry(), x(), y(), pos()
3522 */
3523 QRect QWidget::frameGeometry() const
3524 {
3525     Q_D(const QWidget);
3526     if (isWindow() && ! (windowType() == Qt::Popup)) {
3527         QRect fs = d->frameStrut();
3528         return QRect(data->crect.x() - fs.left(),
3529                      data->crect.y() - fs.top(),
3530                      data->crect.width() + fs.left() + fs.right(),
3531                      data->crect.height() + fs.top() + fs.bottom());
3532     }
3533     return data->crect;
3534 }
3535 
3536 /*!
3537     \property QWidget::x
3538 
3539     \brief the x coordinate of the widget relative to its parent including
3540     any window frame
3541 
3542     See the \l{Window Geometry} documentation for an overview of geometry
3543     issues with windows.
3544 
3545     By default, this property has a value of 0.
3546 
3547     \sa frameGeometry, y, pos
3548 */
3549 int QWidget::x() const
3550 {
3551     Q_D(const QWidget);
3552     if (isWindow() && ! (windowType() == Qt::Popup))
3553         return data->crect.x() - d->frameStrut().left();
3554     return data->crect.x();
3555 }
3556 
3557 /*!
3558     \property QWidget::y
3559     \brief the y coordinate of the widget relative to its parent and
3560     including any window frame
3561 
3562     See the \l{Window Geometry} documentation for an overview of geometry
3563     issues with windows.
3564 
3565     By default, this property has a value of 0.
3566 
3567     \sa frameGeometry, x, pos
3568 */
3569 int QWidget::y() const
3570 {
3571     Q_D(const QWidget);
3572     if (isWindow() && ! (windowType() == Qt::Popup))
3573         return data->crect.y() - d->frameStrut().top();
3574     return data->crect.y();
3575 }
3576 
3577 /*!
3578     \property QWidget::pos
3579     \brief the position of the widget within its parent widget
3580 
3581     If the widget is a window, the position is that of the widget on
3582     the desktop, including its frame.
3583 
3584     When changing the position, the widget, if visible, receives a
3585     move event (moveEvent()) immediately. If the widget is not
3586     currently visible, it is guaranteed to receive an event before it
3587     is shown.
3588 
3589     By default, this property contains a position that refers to the
3590     origin.
3591 
3592     \warning Calling move() or setGeometry() inside moveEvent() can
3593     lead to infinite recursion.
3594 
3595     See the \l{Window Geometry} documentation for an overview of geometry
3596     issues with windows.
3597 
3598     \sa frameGeometry, size, x(), y()
3599 */
3600 QPoint QWidget::pos() const
3601 {
3602     Q_D(const QWidget);
3603     QPoint result = data->crect.topLeft();
3604     if (isWindow() && ! (windowType() == Qt::Popup))
3605         if (!d->maybeTopData() || !d->maybeTopData()->posIncludesFrame)
3606             result -= d->frameStrut().topLeft();
3607     return result;
3608 }
3609 
3610 /*!
3611     \property QWidget::geometry
3612     \brief the geometry of the widget relative to its parent and
3613     excluding the window frame
3614 
3615     When changing the geometry, the widget, if visible, receives a
3616     move event (moveEvent()) and/or a resize event (resizeEvent())
3617     immediately. If the widget is not currently visible, it is
3618     guaranteed to receive appropriate events before it is shown.
3619 
3620     The size component is adjusted if it lies outside the range
3621     defined by minimumSize() and maximumSize().
3622 
3623     \warning Calling setGeometry() inside resizeEvent() or moveEvent()
3624     can lead to infinite recursion.
3625 
3626     See the \l{Window Geometry} documentation for an overview of geometry
3627     issues with windows.
3628 
3629     By default, this property contains a value that depends on the user's
3630     platform and screen geometry.
3631 
3632     \sa frameGeometry(), rect(), move(), resize(), moveEvent(),
3633         resizeEvent(), minimumSize(), maximumSize()
3634 */
3635 
3636 /*!
3637     \property QWidget::normalGeometry
3638 
3639     \brief the geometry of the widget as it will appear when shown as
3640     a normal (not maximized or full screen) top-level widget
3641 
3642     For child widgets this property always holds an empty rectangle.
3643 
3644     By default, this property contains an empty rectangle.
3645 
3646     \sa QWidget::windowState(), QWidget::geometry
3647 */
3648 
3649 /*!
3650     \property QWidget::size
3651     \brief the size of the widget excluding any window frame
3652 
3653     If the widget is visible when it is being resized, it receives a resize event
3654     (resizeEvent()) immediately. If the widget is not currently
3655     visible, it is guaranteed to receive an event before it is shown.
3656 
3657     The size is adjusted if it lies outside the range defined by
3658     minimumSize() and maximumSize().
3659 
3660     By default, this property contains a value that depends on the user's
3661     platform and screen geometry.
3662 
3663     \warning Calling resize() or setGeometry() inside resizeEvent() can
3664     lead to infinite recursion.
3665 
3666     \note Setting the size to \c{QSize(0, 0)} will cause the widget to not
3667     appear on screen. This also applies to windows.
3668 
3669     \sa pos, geometry, minimumSize, maximumSize, resizeEvent(), adjustSize()
3670 */
3671 
3672 /*!
3673     \property QWidget::width
3674     \brief the width of the widget excluding any window frame
3675 
3676     See the \l{Window Geometry} documentation for an overview of geometry
3677     issues with windows.
3678 
3679     \note Do not use this function to find the width of a screen on
3680     a \l{QDesktopWidget}{multiple screen desktop}. Read
3681     \l{QDesktopWidget#Screen Geometry}{this note} for details.
3682 
3683     By default, this property contains a value that depends on the user's
3684     platform and screen geometry.
3685 
3686     \sa geometry, height, size
3687 */
3688 
3689 /*!
3690     \property QWidget::height
3691     \brief the height of the widget excluding any window frame
3692 
3693     See the \l{Window Geometry} documentation for an overview of geometry
3694     issues with windows.
3695 
3696     \note Do not use this function to find the height of a screen
3697     on a \l{QDesktopWidget}{multiple screen desktop}. Read
3698     \l{QDesktopWidget#Screen Geometry}{this note} for details.
3699 
3700     By default, this property contains a value that depends on the user's
3701     platform and screen geometry.
3702 
3703     \sa geometry, width, size
3704 */
3705 
3706 /*!
3707     \property QWidget::rect
3708     \brief the internal geometry of the widget excluding any window
3709     frame
3710 
3711     The rect property equals QRect(0, 0, width(), height()).
3712 
3713     See the \l{Window Geometry} documentation for an overview of geometry
3714     issues with windows.
3715 
3716     By default, this property contains a value that depends on the user's
3717     platform and screen geometry.
3718 
3719     \sa size
3720 */
3721 
3722 
3723 QRect QWidget::normalGeometry() const
3724 {
3725     Q_D(const QWidget);
3726     if (!d->extra || !d->extra->topextra)
3727         return QRect();
3728 
3729     if (!isMaximized() && !isFullScreen())
3730         return geometry();
3731 
3732     return d->topData()->normalGeometry;
3733 }
3734 
3735 
3736 /*!
3737     \property QWidget::childrenRect
3738     \brief the bounding rectangle of the widget's children
3739 
3740     Hidden children are excluded.
3741 
3742     By default, for a widget with no children, this property contains a
3743     rectangle with zero width and height located at the origin.
3744 
3745     \sa childrenRegion(), geometry()
3746 */
3747 
3748 QRect QWidget::childrenRect() const
3749 {
3750     Q_D(const QWidget);
3751     QRect r(0, 0, 0, 0);
3752     for (int i = 0; i < d->children.size(); ++i) {
3753         QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
3754         if (w && !w->isWindow() && !w->isHidden())
3755             r |= w->geometry();
3756     }
3757     return r;
3758 }
3759 
3760 /*!
3761     \property QWidget::childrenRegion
3762     \brief the combined region occupied by the widget's children
3763 
3764     Hidden children are excluded.
3765 
3766     By default, for a widget with no children, this property contains an
3767     empty region.
3768 
3769     \sa childrenRect(), geometry(), mask()
3770 */
3771 
3772 QRegion QWidget::childrenRegion() const
3773 {
3774     Q_D(const QWidget);
3775     QRegion r;
3776     for (int i = 0; i < d->children.size(); ++i) {
3777         QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
3778         if (w && !w->isWindow() && !w->isHidden()) {
3779             QRegion mask = w->mask();
3780             if (mask.isEmpty())
3781                 r |= w->geometry();
3782             else
3783                 r |= mask.translated(w->pos());
3784         }
3785     }
3786     return r;
3787 }
3788 
3789 
3790 /*!
3791     \property QWidget::minimumSize
3792     \brief the widget's minimum size
3793 
3794     The widget cannot be resized to a smaller size than the minimum
3795     widget size. The widget's size is forced to the minimum size if
3796     the current size is smaller.
3797 
3798     The minimum size set by this function will override the minimum size
3799     defined by QLayout. In order to unset the minimum size, use a
3800     value of \c{QSize(0, 0)}.
3801 
3802     By default, this property contains a size with zero width and height.
3803 
3804     \sa minimumWidth, minimumHeight, maximumSize, sizeIncrement
3805 */
3806 
3807 QSize QWidget::minimumSize() const
3808 {
3809     Q_D(const QWidget);
3810     return d->extra ? QSize(d->extra->minw, d->extra->minh) : QSize(0, 0);
3811 }
3812 
3813 /*!
3814     \property QWidget::maximumSize
3815     \brief the widget's maximum size in pixels
3816 
3817     The widget cannot be resized to a larger size than the maximum
3818     widget size.
3819 
3820     By default, this property contains a size in which both width and height
3821     have values of 16777215.
3822 
3823     \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size
3824     of widgets.
3825 
3826     \sa maximumWidth, maximumHeight, minimumSize, sizeIncrement
3827 */
3828 
3829 QSize QWidget::maximumSize() const
3830 {
3831     Q_D(const QWidget);
3832     return d->extra ? QSize(d->extra->maxw, d->extra->maxh)
3833                  : QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
3834 }
3835 
3836 
3837 /*!
3838     \property QWidget::minimumWidth
3839     \brief the widget's minimum width in pixels
3840 
3841     This property corresponds to the width held by the \l minimumSize property.
3842 
3843     By default, this property has a value of 0.
3844 
3845     \sa minimumSize, minimumHeight
3846 */
3847 
3848 /*!
3849     \property QWidget::minimumHeight
3850     \brief the widget's minimum height in pixels
3851 
3852     This property corresponds to the height held by the \l minimumSize property.
3853 
3854     By default, this property has a value of 0.
3855 
3856     \sa minimumSize, minimumWidth
3857 */
3858 
3859 /*!
3860     \property QWidget::maximumWidth
3861     \brief the widget's maximum width in pixels
3862 
3863     This property corresponds to the width held by the \l maximumSize property.
3864 
3865     By default, this property contains a value of 16777215.
3866 
3867     \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size
3868     of widgets.
3869 
3870     \sa maximumSize, maximumHeight
3871 */
3872 
3873 /*!
3874     \property QWidget::maximumHeight
3875     \brief the widget's maximum height in pixels
3876 
3877     This property corresponds to the height held by the \l maximumSize property.
3878 
3879     By default, this property contains a value of 16777215.
3880 
3881     \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size
3882     of widgets.
3883 
3884     \sa maximumSize, maximumWidth
3885 */
3886 
3887 /*!
3888     \property QWidget::sizeIncrement
3889     \brief the size increment of the widget
3890 
3891     When the user resizes the window, the size will move in steps of
3892     sizeIncrement().width() pixels horizontally and
3893     sizeIncrement.height() pixels vertically, with baseSize() as the
3894     basis. Preferred widget sizes are for non-negative integers \e i
3895     and \e j:
3896     \snippet code/src_gui_kernel_qwidget.cpp 2
3897 
3898     Note that while you can set the size increment for all widgets, it
3899     only affects windows.
3900 
3901     By default, this property contains a size with zero width and height.
3902 
3903     \warning The size increment has no effect under Windows, and may
3904     be disregarded by the window manager on X11.
3905 
3906     \sa size, minimumSize, maximumSize
3907 */
3908 QSize QWidget::sizeIncrement() const
3909 {
3910     Q_D(const QWidget);
3911     return (d->extra && d->extra->topextra)
3912         ? QSize(d->extra->topextra->incw, d->extra->topextra->inch)
3913         : QSize(0, 0);
3914 }
3915 
3916 /*!
3917     \property QWidget::baseSize
3918     \brief the base size of the widget
3919 
3920     The base size is used to calculate a proper widget size if the
3921     widget defines sizeIncrement().
3922 
3923     By default, for a newly-created widget, this property contains a size with
3924     zero width and height.
3925 
3926     \sa setSizeIncrement()
3927 */
3928 
3929 QSize QWidget::baseSize() const
3930 {
3931     Q_D(const QWidget);
3932     return (d->extra != 0 && d->extra->topextra != 0)
3933         ? QSize(d->extra->topextra->basew, d->extra->topextra->baseh)
3934         : QSize(0, 0);
3935 }
3936 
3937 bool QWidgetPrivate::setMinimumSize_helper(int &minw, int &minh)
3938 {
3939     Q_Q(QWidget);
3940 
3941     int mw = minw, mh = minh;
3942     if (mw == QWIDGETSIZE_MAX)
3943         mw = 0;
3944     if (mh == QWIDGETSIZE_MAX)
3945         mh = 0;
3946     if (Q_UNLIKELY(minw > QWIDGETSIZE_MAX || minh > QWIDGETSIZE_MAX)) {
3947         qWarning("QWidget::setMinimumSize: (%s/%s) "
3948                 "The largest allowed size is (%d,%d)",
3949                  q->objectName().toLocal8Bit().data(), q->metaObject()->className(), QWIDGETSIZE_MAX,
3950                 QWIDGETSIZE_MAX);
3951         minw = mw = qMin<int>(minw, QWIDGETSIZE_MAX);
3952         minh = mh = qMin<int>(minh, QWIDGETSIZE_MAX);
3953     }
3954     if (Q_UNLIKELY(minw < 0 || minh < 0)) {
3955         qWarning("QWidget::setMinimumSize: (%s/%s) Negative sizes (%d,%d) "
3956                 "are not possible",
3957                 q->objectName().toLocal8Bit().data(), q->metaObject()->className(), minw, minh);
3958         minw = mw = qMax(minw, 0);
3959         minh = mh = qMax(minh, 0);
3960     }
3961     createExtra();
3962     if (extra->minw == mw && extra->minh == mh)
3963         return false;
3964     extra->minw = mw;
3965     extra->minh = mh;
3966     extra->explicitMinSize = (mw ? Qt::Horizontal : 0) | (mh ? Qt::Vertical : 0);
3967     return true;
3968 }
3969 
3970 void QWidgetPrivate::setConstraints_sys()
3971 {
3972     Q_Q(QWidget);
3973     if (extra && q->windowHandle()) {
3974         QWindow *win = q->windowHandle();
3975         QWindowPrivate *winp = qt_window_private(win);
3976 
3977         winp->minimumSize = QSize(extra->minw, extra->minh);
3978         winp->maximumSize = QSize(extra->maxw, extra->maxh);
3979 
3980         if (extra->topextra) {
3981             winp->baseSize = QSize(extra->topextra->basew, extra->topextra->baseh);
3982             winp->sizeIncrement = QSize(extra->topextra->incw, extra->topextra->inch);
3983         }
3984 
3985         if (winp->platformWindow) {
3986             fixPosIncludesFrame();
3987             winp->platformWindow->propagateSizeHints();
3988         }
3989     }
3990 }
3991 
3992 /*!
3993     \overload
3994 
3995     This function corresponds to setMinimumSize(QSize(minw, minh)).
3996     Sets the minimum width to \a minw and the minimum height to \a
3997     minh.
3998 */
3999 
4000 void QWidget::setMinimumSize(int minw, int minh)
4001 {
4002     Q_D(QWidget);
4003     if (!d->setMinimumSize_helper(minw, minh))
4004         return;
4005 
4006     if (isWindow())
4007         d->setConstraints_sys();
4008     if (minw > width() || minh > height()) {
4009         bool resized = testAttribute(Qt::WA_Resized);
4010         bool maximized = isMaximized();
4011         resize(qMax(minw,width()), qMax(minh,height()));
4012         setAttribute(Qt::WA_Resized, resized); //not a user resize
4013         if (maximized)
4014             data->window_state = data->window_state | Qt::WindowMaximized;
4015     }
4016 #if QT_CONFIG(graphicsview)
4017     if (d->extra) {
4018         if (d->extra->proxyWidget)
4019             d->extra->proxyWidget->setMinimumSize(minw, minh);
4020     }
4021 #endif
4022     d->updateGeometry_helper(d->extra->minw == d->extra->maxw && d->extra->minh == d->extra->maxh);
4023 }
4024 
4025 bool QWidgetPrivate::setMaximumSize_helper(int &maxw, int &maxh)
4026 {
4027     Q_Q(QWidget);
4028     if (Q_UNLIKELY(maxw > QWIDGETSIZE_MAX || maxh > QWIDGETSIZE_MAX)) {
4029         qWarning("QWidget::setMaximumSize: (%s/%s) "
4030                 "The largest allowed size is (%d,%d)",
4031                  q->objectName().toLocal8Bit().data(), q->metaObject()->className(), QWIDGETSIZE_MAX,
4032                 QWIDGETSIZE_MAX);
4033         maxw = qMin<int>(maxw, QWIDGETSIZE_MAX);
4034         maxh = qMin<int>(maxh, QWIDGETSIZE_MAX);
4035     }
4036     if (Q_UNLIKELY(maxw < 0 || maxh < 0)) {
4037         qWarning("QWidget::setMaximumSize: (%s/%s) Negative sizes (%d,%d) "
4038                 "are not possible",
4039                 q->objectName().toLocal8Bit().data(), q->metaObject()->className(), maxw, maxh);
4040         maxw = qMax(maxw, 0);
4041         maxh = qMax(maxh, 0);
4042     }
4043     createExtra();
4044     if (extra->maxw == maxw && extra->maxh == maxh)
4045         return false;
4046     extra->maxw = maxw;
4047     extra->maxh = maxh;
4048     extra->explicitMaxSize = (maxw != QWIDGETSIZE_MAX ? Qt::Horizontal : 0) |
4049                              (maxh != QWIDGETSIZE_MAX ? Qt::Vertical : 0);
4050     return true;
4051 }
4052 
4053 /*!
4054     \overload
4055 
4056     This function corresponds to setMaximumSize(QSize(\a maxw, \a
4057     maxh)). Sets the maximum width to \a maxw and the maximum height
4058     to \a maxh.
4059 */
4060 void QWidget::setMaximumSize(int maxw, int maxh)
4061 {
4062     Q_D(QWidget);
4063     if (!d->setMaximumSize_helper(maxw, maxh))
4064         return;
4065 
4066     if (isWindow())
4067         d->setConstraints_sys();
4068     if (maxw < width() || maxh < height()) {
4069         bool resized = testAttribute(Qt::WA_Resized);
4070         resize(qMin(maxw,width()), qMin(maxh,height()));
4071         setAttribute(Qt::WA_Resized, resized); //not a user resize
4072     }
4073 
4074 #if QT_CONFIG(graphicsview)
4075     if (d->extra) {
4076         if (d->extra->proxyWidget)
4077             d->extra->proxyWidget->setMaximumSize(maxw, maxh);
4078     }
4079 #endif
4080 
4081     d->updateGeometry_helper(d->extra->minw == d->extra->maxw && d->extra->minh == d->extra->maxh);
4082 }
4083 
4084 /*!
4085     \overload
4086 
4087     Sets the x (width) size increment to \a w and the y (height) size
4088     increment to \a h.
4089 */
4090 void QWidget::setSizeIncrement(int w, int h)
4091 {
4092     Q_D(QWidget);
4093     d->createTLExtra();
4094     QTLWExtra* x = d->topData();
4095     if (x->incw == w && x->inch == h)
4096         return;
4097     x->incw = w;
4098     x->inch = h;
4099     if (isWindow())
4100         d->setConstraints_sys();
4101 }
4102 
4103 /*!
4104     \overload
4105 
4106     This corresponds to setBaseSize(QSize(\a basew, \a baseh)). Sets
4107     the widgets base size to width \a basew and height \a baseh.
4108 */
4109 void QWidget::setBaseSize(int basew, int baseh)
4110 {
4111     Q_D(QWidget);
4112     d->createTLExtra();
4113     QTLWExtra* x = d->topData();
4114     if (x->basew == basew && x->baseh == baseh)
4115         return;
4116     x->basew = basew;
4117     x->baseh = baseh;
4118     if (isWindow())
4119         d->setConstraints_sys();
4120 }
4121 
4122 /*!
4123     Sets both the minimum and maximum sizes of the widget to \a s,
4124     thereby preventing it from ever growing or shrinking.
4125 
4126     This will override the default size constraints set by QLayout.
4127 
4128     To remove constraints, set the size to QWIDGETSIZE_MAX.
4129 
4130     Alternatively, if you want the widget to have a
4131     fixed size based on its contents, you can call
4132     QLayout::setSizeConstraint(QLayout::SetFixedSize);
4133 
4134     \sa maximumSize, minimumSize
4135 */
4136 
4137 void QWidget::setFixedSize(const QSize & s)
4138 {
4139     setFixedSize(s.width(), s.height());
4140 }
4141 
4142 
4143 /*!
4144     \fn void QWidget::setFixedSize(int w, int h)
4145     \overload
4146 
4147     Sets the width of the widget to \a w and the height to \a h.
4148 */
4149 
4150 void QWidget::setFixedSize(int w, int h)
4151 {
4152     Q_D(QWidget);
4153     bool minSizeSet = d->setMinimumSize_helper(w, h);
4154     bool maxSizeSet = d->setMaximumSize_helper(w, h);
4155     if (!minSizeSet && !maxSizeSet)
4156         return;
4157 
4158     if (isWindow())
4159         d->setConstraints_sys();
4160     else
4161         d->updateGeometry_helper(true);
4162 
4163     if (w != QWIDGETSIZE_MAX || h != QWIDGETSIZE_MAX)
4164         resize(w, h);
4165 }
4166 
4167 void QWidget::setMinimumWidth(int w)
4168 {
4169     Q_D(QWidget);
4170     d->createExtra();
4171     uint expl = d->extra->explicitMinSize | (w ? Qt::Horizontal : 0);
4172     setMinimumSize(w, minimumSize().height());
4173     d->extra->explicitMinSize = expl;
4174 }
4175 
4176 void QWidget::setMinimumHeight(int h)
4177 {
4178     Q_D(QWidget);
4179     d->createExtra();
4180     uint expl = d->extra->explicitMinSize | (h ? Qt::Vertical : 0);
4181     setMinimumSize(minimumSize().width(), h);
4182     d->extra->explicitMinSize = expl;
4183 }
4184 
4185 void QWidget::setMaximumWidth(int w)
4186 {
4187     Q_D(QWidget);
4188     d->createExtra();
4189     uint expl = d->extra->explicitMaxSize | (w == QWIDGETSIZE_MAX ? 0 : Qt::Horizontal);
4190     setMaximumSize(w, maximumSize().height());
4191     d->extra->explicitMaxSize = expl;
4192 }
4193 
4194 void QWidget::setMaximumHeight(int h)
4195 {
4196     Q_D(QWidget);
4197     d->createExtra();
4198     uint expl = d->extra->explicitMaxSize | (h == QWIDGETSIZE_MAX ? 0 : Qt::Vertical);
4199     setMaximumSize(maximumSize().width(), h);
4200     d->extra->explicitMaxSize = expl;
4201 }
4202 
4203 /*!
4204     Sets both the minimum and maximum width of the widget to \a w
4205     without changing the heights. Provided for convenience.
4206 
4207     \sa sizeHint(), minimumSize(), maximumSize(), setFixedSize()
4208 */
4209 
4210 void QWidget::setFixedWidth(int w)
4211 {
4212     Q_D(QWidget);
4213     d->createExtra();
4214     uint explMin = d->extra->explicitMinSize | Qt::Horizontal;
4215     uint explMax = d->extra->explicitMaxSize | Qt::Horizontal;
4216     setMinimumSize(w, minimumSize().height());
4217     setMaximumSize(w, maximumSize().height());
4218     d->extra->explicitMinSize = explMin;
4219     d->extra->explicitMaxSize = explMax;
4220 }
4221 
4222 
4223 /*!
4224     Sets both the minimum and maximum heights of the widget to \a h
4225     without changing the widths. Provided for convenience.
4226 
4227     \sa sizeHint(), minimumSize(), maximumSize(), setFixedSize()
4228 */
4229 
4230 void QWidget::setFixedHeight(int h)
4231 {
4232     Q_D(QWidget);
4233     d->createExtra();
4234     uint explMin = d->extra->explicitMinSize | Qt::Vertical;
4235     uint explMax = d->extra->explicitMaxSize | Qt::Vertical;
4236     setMinimumSize(minimumSize().width(), h);
4237     setMaximumSize(maximumSize().width(), h);
4238     d->extra->explicitMinSize = explMin;
4239     d->extra->explicitMaxSize = explMax;
4240 }
4241 
4242 
4243 /*!
4244     Translates the widget coordinate \a pos to the coordinate system
4245     of \a parent. The \a parent must not be 0 and must be a parent
4246     of the calling widget.
4247 
4248     \sa mapFrom(), mapToParent(), mapToGlobal(), underMouse()
4249 */
4250 
4251 QPoint QWidget::mapTo(const QWidget * parent, const QPoint & pos) const
4252 {
4253     QPoint p = pos;
4254     if (parent) {
4255         const QWidget * w = this;
4256         while (w != parent) {
4257             Q_ASSERT_X(w, "QWidget::mapTo(const QWidget *parent, const QPoint &pos)",
4258                        "parent must be in parent hierarchy");
4259             p = w->mapToParent(p);
4260             w = w->parentWidget();
4261         }
4262     }
4263     return p;
4264 }
4265 
4266 
4267 /*!
4268     Translates the widget coordinate \a pos from the coordinate system
4269     of \a parent to this widget's coordinate system. The \a parent
4270     must not be 0 and must be a parent of the calling widget.
4271 
4272     \sa mapTo(), mapFromParent(), mapFromGlobal(), underMouse()
4273 */
4274 
4275 QPoint QWidget::mapFrom(const QWidget * parent, const QPoint & pos) const
4276 {
4277     QPoint p(pos);
4278     if (parent) {
4279         const QWidget * w = this;
4280         while (w != parent) {
4281             Q_ASSERT_X(w, "QWidget::mapFrom(const QWidget *parent, const QPoint &pos)",
4282                        "parent must be in parent hierarchy");
4283 
4284             p = w->mapFromParent(p);
4285             w = w->parentWidget();
4286         }
4287     }
4288     return p;
4289 }
4290 
4291 
4292 /*!
4293     Translates the widget coordinate \a pos to a coordinate in the
4294     parent widget.
4295 
4296     Same as mapToGlobal() if the widget has no parent.
4297 
4298     \sa mapFromParent(), mapTo(), mapToGlobal(), underMouse()
4299 */
4300 
4301 QPoint QWidget::mapToParent(const QPoint &pos) const
4302 {
4303     return pos + data->crect.topLeft();
4304 }
4305 
4306 /*!
4307     Translates the parent widget coordinate \a pos to widget
4308     coordinates.
4309 
4310     Same as mapFromGlobal() if the widget has no parent.
4311 
4312     \sa mapToParent(), mapFrom(), mapFromGlobal(), underMouse()
4313 */
4314 
4315 QPoint QWidget::mapFromParent(const QPoint &pos) const
4316 {
4317     return pos - data->crect.topLeft();
4318 }
4319 
4320 
4321 /*!
4322     Returns the window for this widget, i.e. the next ancestor widget
4323     that has (or could have) a window-system frame.
4324 
4325     If the widget is a window, the widget itself is returned.
4326 
4327     Typical usage is changing the window title:
4328 
4329     \snippet code/src_gui_kernel_qwidget.cpp 3
4330 
4331     \sa isWindow()
4332 */
4333 
4334 QWidget *QWidget::window() const
4335 {
4336     QWidget *w = const_cast<QWidget *>(this);
4337     QWidget *p = w->parentWidget();
4338     while (!w->isWindow() && p) {
4339         w = p;
4340         p = p->parentWidget();
4341     }
4342     return w;
4343 }
4344 
4345 /*!
4346     \since 4.4
4347 
4348     Returns the native parent for this widget, i.e. the next ancestor widget
4349     that has a system identifier, or 0 if it does not have any native parent.
4350 
4351     \sa effectiveWinId()
4352 */
4353 QWidget *QWidget::nativeParentWidget() const
4354 {
4355     QWidget *parent = parentWidget();
4356     while (parent && !parent->internalWinId())
4357         parent = parent->parentWidget();
4358     return parent;
4359 }
4360 
4361 /*! \fn QWidget *QWidget::topLevelWidget() const
4362     \obsolete
4363 
4364     Use window() instead.
4365 */
4366 
4367 
4368 
4369 /*!
4370   Returns the background role of the widget.
4371 
4372   The background role defines the brush from the widget's \l palette that
4373   is used to render the background.
4374 
4375   If no explicit background role is set, the widget inherts its parent
4376   widget's background role.
4377 
4378   \sa setBackgroundRole(), foregroundRole()
4379  */
4380 QPalette::ColorRole QWidget::backgroundRole() const
4381 {
4382 
4383     const QWidget *w = this;
4384     do {
4385         QPalette::ColorRole role = w->d_func()->bg_role;
4386         if (role != QPalette::NoRole)
4387             return role;
4388         if (w->isWindow() || w->windowType() == Qt::SubWindow)
4389             break;
4390         w = w->parentWidget();
4391     } while (w);
4392     return QPalette::Window;
4393 }
4394 
4395 /*!
4396   Sets the background role of the widget to \a role.
4397 
4398   The background role defines the brush from the widget's \l palette that
4399   is used to render the background.
4400 
4401   If \a role is QPalette::NoRole, then the widget inherits its
4402   parent's background role.
4403 
4404   Note that styles are free to choose any color from the palette.
4405   You can modify the palette or set a style sheet if you don't
4406   achieve the result you want with setBackgroundRole().
4407 
4408   \sa backgroundRole(), foregroundRole()
4409  */
4410 
4411 void QWidget::setBackgroundRole(QPalette::ColorRole role)
4412 {
4413     Q_D(QWidget);
4414     d->bg_role = role;
4415     d->updateSystemBackground();
4416     d->propagatePaletteChange();
4417     d->updateIsOpaque();
4418 }
4419 
4420 /*!
4421   Returns the foreground role.
4422 
4423   The foreground role defines the color from the widget's \l palette that
4424   is used to draw the foreground.
4425 
4426   If no explicit foreground role is set, the function returns a role
4427   that contrasts with the background role.
4428 
4429   \sa setForegroundRole(), backgroundRole()
4430  */
4431 QPalette::ColorRole QWidget::foregroundRole() const
4432 {
4433     Q_D(const QWidget);
4434     QPalette::ColorRole rl = QPalette::ColorRole(d->fg_role);
4435     if (rl != QPalette::NoRole)
4436         return rl;
4437     QPalette::ColorRole role = QPalette::WindowText;
4438     switch (backgroundRole()) {
4439     case QPalette::Button:
4440         role = QPalette::ButtonText;
4441         break;
4442     case QPalette::Base:
4443         role = QPalette::Text;
4444         break;
4445     case QPalette::Dark:
4446     case QPalette::Shadow:
4447         role = QPalette::Light;
4448         break;
4449     case QPalette::Highlight:
4450         role = QPalette::HighlightedText;
4451         break;
4452     case QPalette::ToolTipBase:
4453         role = QPalette::ToolTipText;
4454         break;
4455     default:
4456         ;
4457     }
4458     return role;
4459 }
4460 
4461 /*!
4462   Sets the foreground role of the widget to \a role.
4463 
4464   The foreground role defines the color from the widget's \l palette that
4465   is used to draw the foreground.
4466 
4467   If \a role is QPalette::NoRole, the widget uses a foreground role
4468   that contrasts with the background role.
4469 
4470   Note that styles are free to choose any color from the palette.
4471   You can modify the palette or set a style sheet if you don't
4472   achieve the result you want with setForegroundRole().
4473 
4474   \sa foregroundRole(), backgroundRole()
4475  */
4476 void QWidget::setForegroundRole(QPalette::ColorRole role)
4477 {
4478     Q_D(QWidget);
4479     d->fg_role = role;
4480     d->updateSystemBackground();
4481     d->propagatePaletteChange();
4482 }
4483 
4484 /*!
4485     \property QWidget::palette
4486     \brief the widget's palette
4487 
4488     This property describes the widget's palette. The palette is used by the
4489     widget's style when rendering standard components, and is available as a
4490     means to ensure that custom widgets can maintain consistency with the
4491     native platform's look and feel. It's common that different platforms, or
4492     different styles, have different palettes.
4493 
4494     When you assign a new palette to a widget, the color roles from this
4495     palette are combined with the widget's default palette to form the
4496     widget's final palette. The palette entry for the widget's background role
4497     is used to fill the widget's background (see QWidget::autoFillBackground),
4498     and the foreground role initializes QPainter's pen.
4499 
4500     The default depends on the system environment. QApplication maintains a
4501     system/theme palette which serves as a default for all widgets.  There may
4502     also be special palette defaults for certain types of widgets (e.g., on
4503     Windows Vista, all classes that derive from QMenuBar have a special
4504     default palette). You can also define default palettes for widgets
4505     yourself by passing a custom palette and the name of a widget to
4506     QApplication::setPalette(). Finally, the style always has the option of
4507     polishing the palette as it's assigned (see QStyle::polish()).
4508 
4509     QWidget propagates explicit palette roles from parent to child. If you
4510     assign a brush or color to a specific role on a palette and assign that
4511     palette to a widget, that role will propagate to all the widget's
4512     children, overriding any system defaults for that role. Note that palettes
4513     by default don't propagate to windows (see isWindow()) unless the
4514     Qt::WA_WindowPropagation attribute is enabled.
4515 
4516     QWidget's palette propagation is similar to its font propagation.
4517 
4518     The current style, which is used to render the content of all standard Qt
4519     widgets, is free to choose colors and brushes from the widget palette, or
4520     in some cases, to ignore the palette (partially, or completely). In
4521     particular, certain styles like GTK style, Mac style, and Windows Vista
4522     style, depend on third party APIs to render the content of widgets,
4523     and these styles typically do not follow the palette. Because of this,
4524     assigning roles to a widget's palette is not guaranteed to change the
4525     appearance of the widget. Instead, you may choose to apply a \l
4526     styleSheet. You can refer to our Knowledge Base article
4527     \l{http://qt.nokia.com/developer/knowledgebase/22}{here} for more
4528     information.
4529 
4530     \warning Do not use this function in conjunction with \l{Qt Style Sheets}.
4531     When using style sheets, the palette of a widget can be customized using
4532     the "color", "background-color", "selection-color",
4533     "selection-background-color" and "alternate-background-color".
4534 
4535     \sa QApplication::palette(), QWidget::font()
4536 */
4537 const QPalette &QWidget::palette() const
4538 {
4539     if (!isEnabled()) {
4540         data->pal.setCurrentColorGroup(QPalette::Disabled);
4541     } else if ((!isVisible() || isActiveWindow())
4542 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
4543         && !QApplicationPrivate::isBlockedByModal(const_cast<QWidget *>(this))
4544 #endif
4545         ) {
4546         data->pal.setCurrentColorGroup(QPalette::Active);
4547     } else {
4548 #if 0 // Used to be included in Qt4 for Q_WS_MAC
4549         extern bool qt_mac_can_clickThrough(const QWidget *); //qwidget_mac.cpp
4550         if (qt_mac_can_clickThrough(this))
4551             data->pal.setCurrentColorGroup(QPalette::Active);
4552         else
4553 #endif
4554             data->pal.setCurrentColorGroup(QPalette::Inactive);
4555     }
4556     return data->pal;
4557 }
4558 
4559 void QWidget::setPalette(const QPalette &palette)
4560 {
4561     Q_D(QWidget);
4562     setAttribute(Qt::WA_SetPalette, palette.resolve() != 0);
4563 
4564     // Determine which palette is inherited from this widget's ancestors and
4565     // QApplication::palette, resolve this against \a palette (attributes from
4566     // the inherited palette are copied over this widget's palette). Then
4567     // propagate this palette to this widget's children.
4568     QPalette naturalPalette = d->naturalWidgetPalette(d->inheritedPaletteResolveMask);
4569     QPalette resolvedPalette = palette.resolve(naturalPalette);
4570     d->setPalette_helper(resolvedPalette);
4571 }
4572 
4573 /*!
4574     \internal
4575 
4576     Returns the palette that the widget \a w inherits from its ancestors and
4577     QApplication::palette. \a inheritedMask is the combination of the widget's
4578     ancestors palette request masks (i.e., which attributes from the parent
4579     widget's palette are implicitly imposed on this widget by the user). Note
4580     that this font does not take into account the palette set on \a w itself.
4581 */
4582 QPalette QWidgetPrivate::naturalWidgetPalette(uint inheritedMask) const
4583 {
4584     Q_Q(const QWidget);
4585 
4586     const bool useStyleSheetPropagationInWidgetStyles =
4587         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
4588 
4589     QPalette naturalPalette = QApplication::palette(q);
4590     if ((!q->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles)
4591         && (!q->isWindow() || q->testAttribute(Qt::WA_WindowPropagation)
4592 #if QT_CONFIG(graphicsview)
4593             || (extra && extra->proxyWidget)
4594 #endif // QT_CONFIG(graphicsview)
4595             )) {
4596         if (QWidget *p = q->parentWidget()) {
4597             if (!p->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles) {
4598                 if (!naturalPalette.isCopyOf(QApplication::palette())) {
4599                     QPalette inheritedPalette = p->palette();
4600                     inheritedPalette.resolve(inheritedMask);
4601                     naturalPalette = inheritedPalette.resolve(naturalPalette);
4602                 } else {
4603                     naturalPalette = p->palette();
4604                 }
4605             }
4606         }
4607 #if QT_CONFIG(graphicsview)
4608         else if (extra && extra->proxyWidget) {
4609             QPalette inheritedPalette = extra->proxyWidget->palette();
4610             inheritedPalette.resolve(inheritedMask);
4611             naturalPalette = inheritedPalette.resolve(naturalPalette);
4612         }
4613 #endif // QT_CONFIG(graphicsview)
4614     }
4615     naturalPalette.resolve(0);
4616     return naturalPalette;
4617 }
4618 /*!
4619     \internal
4620 
4621     Determine which palette is inherited from this widget's ancestors and
4622     QApplication::palette, resolve this against this widget's palette
4623     (attributes from the inherited palette are copied over this widget's
4624     palette). Then propagate this palette to this widget's children.
4625 */
4626 void QWidgetPrivate::resolvePalette()
4627 {
4628     QPalette naturalPalette = naturalWidgetPalette(inheritedPaletteResolveMask);
4629     QPalette resolvedPalette = data.pal.resolve(naturalPalette);
4630     setPalette_helper(resolvedPalette);
4631 }
4632 
4633 void QWidgetPrivate::setPalette_helper(const QPalette &palette)
4634 {
4635     Q_Q(QWidget);
4636     if (data.pal == palette && data.pal.resolve() == palette.resolve())
4637         return;
4638     data.pal = palette;
4639     updateSystemBackground();
4640     propagatePaletteChange();
4641     updateIsOpaque();
4642     q->update();
4643     updateIsOpaque();
4644 }
4645 
4646 void QWidgetPrivate::updateSystemBackground()
4647 {
4648 }
4649 
4650 /*!
4651     \property QWidget::font
4652     \brief the font currently set for the widget
4653 
4654     This property describes the widget's requested font. The font is used by
4655     the widget's style when rendering standard components, and is available as
4656     a means to ensure that custom widgets can maintain consistency with the
4657     native platform's look and feel. It's common that different platforms, or
4658     different styles, define different fonts for an application.
4659 
4660     When you assign a new font to a widget, the properties from this font are
4661     combined with the widget's default font to form the widget's final
4662     font. You can call fontInfo() to get a copy of the widget's final
4663     font. The final font is also used to initialize QPainter's font.
4664 
4665     The default depends on the system environment. QApplication maintains a
4666     system/theme font which serves as a default for all widgets.  There may
4667     also be special font defaults for certain types of widgets. You can also
4668     define default fonts for widgets yourself by passing a custom font and the
4669     name of a widget to QApplication::setFont(). Finally, the font is matched
4670     against Qt's font database to find the best match.
4671 
4672     QWidget propagates explicit font properties from parent to child. If you
4673     change a specific property on a font and assign that font to a widget,
4674     that property will propagate to all the widget's children, overriding any
4675     system defaults for that property. Note that fonts by default don't
4676     propagate to windows (see isWindow()) unless the Qt::WA_WindowPropagation
4677     attribute is enabled.
4678 
4679     QWidget's font propagation is similar to its palette propagation.
4680 
4681     The current style, which is used to render the content of all standard Qt
4682     widgets, is free to choose to use the widget font, or in some cases, to
4683     ignore it (partially, or completely). In particular, certain styles like
4684     GTK style, Mac style, and Windows Vista style, apply special
4685     modifications to the widget font to match the platform's native look and
4686     feel. Because of this, assigning properties to a widget's font is not
4687     guaranteed to change the appearance of the widget. Instead, you may choose
4688     to apply a \l styleSheet.
4689 
4690     \note If \l{Qt Style Sheets} are used on the same widget as setFont(),
4691     style sheets will take precedence if the settings conflict.
4692 
4693     \sa fontInfo(), fontMetrics()
4694 */
4695 
4696 void QWidget::setFont(const QFont &font)
4697 {
4698     Q_D(QWidget);
4699 
4700 #ifndef QT_NO_STYLE_STYLESHEET
4701     const QStyleSheetStyle* style;
4702     if (d->extra && (style = qobject_cast<const QStyleSheetStyle*>(d->extra->style))) {
4703         style->saveWidgetFont(this, font);
4704     }
4705 #endif
4706 
4707     setAttribute(Qt::WA_SetFont, font.resolve() != 0);
4708 
4709     // Determine which font is inherited from this widget's ancestors and
4710     // QApplication::font, resolve this against \a font (attributes from the
4711     // inherited font are copied over). Then propagate this font to this
4712     // widget's children.
4713     QFont naturalFont = d->naturalWidgetFont(d->inheritedFontResolveMask);
4714     QFont resolvedFont = font.resolve(naturalFont);
4715     d->setFont_helper(resolvedFont);
4716 }
4717 
4718 /*
4719     \internal
4720 
4721     Returns the font that the widget \a w inherits from its ancestors and
4722     QApplication::font. \a inheritedMask is the combination of the widget's
4723     ancestors font request masks (i.e., which attributes from the parent
4724     widget's font are implicitly imposed on this widget by the user). Note
4725     that this font does not take into account the font set on \a w itself.
4726 
4727     ### Stylesheet has a different font propagation mechanism. When a stylesheet
4728         is applied, fonts are not propagated anymore
4729 */
4730 QFont QWidgetPrivate::naturalWidgetFont(uint inheritedMask) const
4731 {
4732     Q_Q(const QWidget);
4733 
4734     const bool useStyleSheetPropagationInWidgetStyles =
4735         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
4736 
4737     QFont naturalFont = QApplication::font(q);
4738     if ((!q->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles)
4739         && (!q->isWindow() || q->testAttribute(Qt::WA_WindowPropagation)
4740 #if QT_CONFIG(graphicsview)
4741             || (extra && extra->proxyWidget)
4742 #endif // QT_CONFIG(graphicsview)
4743             )) {
4744         if (QWidget *p = q->parentWidget()) {
4745             if (!p->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles) {
4746                 if (!naturalFont.isCopyOf(QApplication::font())) {
4747                     if (inheritedMask != 0) {
4748                         QFont inheritedFont = p->font();
4749                         inheritedFont.resolve(inheritedMask);
4750                         naturalFont = inheritedFont.resolve(naturalFont);
4751                     } // else nothing to do (naturalFont = naturalFont)
4752                 } else {
4753                     naturalFont = p->font();
4754                 }
4755             }
4756         }
4757 #if QT_CONFIG(graphicsview)
4758         else if (extra && extra->proxyWidget) {
4759             if (inheritedMask != 0) {
4760                 QFont inheritedFont = extra->proxyWidget->font();
4761                 inheritedFont.resolve(inheritedMask);
4762                 naturalFont = inheritedFont.resolve(naturalFont);
4763             } // else nothing to do (naturalFont = naturalFont)
4764         }
4765 #endif // QT_CONFIG(graphicsview)
4766     }
4767     naturalFont.resolve(0);
4768     return naturalFont;
4769 }
4770 
4771 /*!
4772     \internal
4773 
4774     Determine which font is implicitly imposed on this widget by its ancestors
4775     and QApplication::font, resolve this against its own font (attributes from
4776     the implicit font are copied over). Then propagate this font to this
4777     widget's children.
4778 */
4779 void QWidgetPrivate::resolveFont()
4780 {
4781     QFont naturalFont = naturalWidgetFont(inheritedFontResolveMask);
4782     QFont resolvedFont = data.fnt.resolve(naturalFont);
4783     setFont_helper(resolvedFont);
4784 }
4785 
4786 /*!
4787     \internal
4788 
4789     Assign \a font to this widget, and propagate it to all children, except
4790     style sheet widgets (handled differently) and windows that don't enable
4791     window propagation.  \a implicitMask is the union of all ancestor widgets'
4792     font request masks, and determines which attributes from this widget's
4793     font should propagate.
4794 */
4795 void QWidgetPrivate::updateFont(const QFont &font)
4796 {
4797     Q_Q(QWidget);
4798 #ifndef QT_NO_STYLE_STYLESHEET
4799     const QStyleSheetStyle* cssStyle;
4800     cssStyle = extra ? qobject_cast<const QStyleSheetStyle*>(extra->style) : 0;
4801     const bool useStyleSheetPropagationInWidgetStyles =
4802         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
4803 #endif
4804 
4805     data.fnt = QFont(font, q);
4806 #if 0 // Used to be included in Qt4 for Q_WS_X11
4807     // make sure the font set on this widget is associated with the correct screen
4808     data.fnt.x11SetScreen(xinfo.screen());
4809 #endif
4810     // Combine new mask with natural mask and propagate to children.
4811 #if QT_CONFIG(graphicsview)
4812     if (!q->parentWidget() && extra && extra->proxyWidget) {
4813         QGraphicsProxyWidget *p = extra->proxyWidget;
4814         inheritedFontResolveMask = p->d_func()->inheritedFontResolveMask | p->font().resolve();
4815     } else
4816 #endif // QT_CONFIG(graphicsview)
4817     if (q->isWindow() && !q->testAttribute(Qt::WA_WindowPropagation)) {
4818         inheritedFontResolveMask = 0;
4819     }
4820     uint newMask = data.fnt.resolve() | inheritedFontResolveMask;
4821 
4822     for (int i = 0; i < children.size(); ++i) {
4823         QWidget *w = qobject_cast<QWidget*>(children.at(i));
4824         if (w) {
4825             if (0) {
4826 #ifndef QT_NO_STYLE_STYLESHEET
4827             } else if (!useStyleSheetPropagationInWidgetStyles && w->testAttribute(Qt::WA_StyleSheet)) {
4828                 // Style sheets follow a different font propagation scheme.
4829                 if (cssStyle)
4830                     cssStyle->updateStyleSheetFont(w);
4831 #endif
4832             } else if ((!w->isWindow() || w->testAttribute(Qt::WA_WindowPropagation))) {
4833                 // Propagate font changes.
4834                 QWidgetPrivate *wd = w->d_func();
4835                 wd->inheritedFontResolveMask = newMask;
4836                 wd->resolveFont();
4837             }
4838         }
4839     }
4840 
4841 #ifndef QT_NO_STYLE_STYLESHEET
4842     if (!useStyleSheetPropagationInWidgetStyles && cssStyle) {
4843         cssStyle->updateStyleSheetFont(q);
4844     }
4845 #endif
4846 
4847     QEvent e(QEvent::FontChange);
4848     QApplication::sendEvent(q, &e);
4849 }
4850 
4851 void QWidgetPrivate::setLayoutDirection_helper(Qt::LayoutDirection direction)
4852 {
4853     Q_Q(QWidget);
4854 
4855     if ( (direction == Qt::RightToLeft) == q->testAttribute(Qt::WA_RightToLeft))
4856         return;
4857     q->setAttribute(Qt::WA_RightToLeft, (direction == Qt::RightToLeft));
4858     if (!children.isEmpty()) {
4859         for (int i = 0; i < children.size(); ++i) {
4860             QWidget *w = qobject_cast<QWidget*>(children.at(i));
4861             if (w && !w->isWindow() && !w->testAttribute(Qt::WA_SetLayoutDirection))
4862                 w->d_func()->setLayoutDirection_helper(direction);
4863         }
4864     }
4865     QEvent e(QEvent::LayoutDirectionChange);
4866     QApplication::sendEvent(q, &e);
4867 }
4868 
4869 void QWidgetPrivate::resolveLayoutDirection()
4870 {
4871     Q_Q(const QWidget);
4872     if (!q->testAttribute(Qt::WA_SetLayoutDirection))
4873         setLayoutDirection_helper(q->isWindow() ? QApplication::layoutDirection() : q->parentWidget()->layoutDirection());
4874 }
4875 
4876 /*!
4877     \property QWidget::layoutDirection
4878 
4879     \brief the layout direction for this widget
4880 
4881     By default, this property is set to Qt::LeftToRight.
4882 
4883     When the layout direction is set on a widget, it will propagate to
4884     the widget's children, but not to a child that is a window and not
4885     to a child for which setLayoutDirection() has been explicitly
4886     called. Also, child widgets added \e after setLayoutDirection()
4887     has been called for the parent do not inherit the parent's layout
4888     direction.
4889 
4890     This method no longer affects text layout direction since Qt 4.7.
4891 
4892     \sa QApplication::layoutDirection
4893 */
4894 void QWidget::setLayoutDirection(Qt::LayoutDirection direction)
4895 {
4896     Q_D(QWidget);
4897 
4898     if (direction == Qt::LayoutDirectionAuto) {
4899         unsetLayoutDirection();
4900         return;
4901     }
4902 
4903     setAttribute(Qt::WA_SetLayoutDirection);
4904     d->setLayoutDirection_helper(direction);
4905 }
4906 
4907 Qt::LayoutDirection QWidget::layoutDirection() const
4908 {
4909     return testAttribute(Qt::WA_RightToLeft) ? Qt::RightToLeft : Qt::LeftToRight;
4910 }
4911 
4912 void QWidget::unsetLayoutDirection()
4913 {
4914     Q_D(QWidget);
4915     setAttribute(Qt::WA_SetLayoutDirection, false);
4916     d->resolveLayoutDirection();
4917 }
4918 
4919 /*!
4920     \fn QFontMetrics QWidget::fontMetrics() const
4921 
4922     Returns the font metrics for the widget's current font.
4923     Equivalent to \c QFontMetrics(widget->font()).
4924 
4925     \sa font(), fontInfo(), setFont()
4926 */
4927 
4928 /*!
4929     \fn QFontInfo QWidget::fontInfo() const
4930 
4931     Returns the font info for the widget's current font.
4932     Equivalent to \c QFontInfo(widget->font()).
4933 
4934     \sa font(), fontMetrics(), setFont()
4935 */
4936 
4937 
4938 /*!
4939     \property QWidget::cursor
4940     \brief the cursor shape for this widget
4941 
4942     The mouse cursor will assume this shape when it's over this
4943     widget. See the \l{Qt::CursorShape}{list of predefined cursor objects} for a range of useful shapes.
4944 
4945     An editor widget might use an I-beam cursor:
4946     \snippet code/src_gui_kernel_qwidget.cpp 6
4947 
4948     If no cursor has been set, or after a call to unsetCursor(), the
4949     parent's cursor is used.
4950 
4951     By default, this property contains a cursor with the Qt::ArrowCursor
4952     shape.
4953 
4954     Some underlying window implementations will reset the cursor if it
4955     leaves a widget even if the mouse is grabbed. If you want to have
4956     a cursor set for all widgets, even when outside the window, consider
4957     QApplication::setOverrideCursor().
4958 
4959     \sa QApplication::setOverrideCursor()
4960 */
4961 
4962 #ifndef QT_NO_CURSOR
4963 QCursor QWidget::cursor() const
4964 {
4965     Q_D(const QWidget);
4966     if (testAttribute(Qt::WA_SetCursor))
4967         return (d->extra && d->extra->curs)
4968             ? *d->extra->curs
4969             : QCursor(Qt::ArrowCursor);
4970     if (isWindow() || !parentWidget())
4971         return QCursor(Qt::ArrowCursor);
4972     return parentWidget()->cursor();
4973 }
4974 
4975 void QWidget::setCursor(const QCursor &cursor)
4976 {
4977     Q_D(QWidget);
4978 // On Mac we must set the cursor even if it is the ArrowCursor.
4979 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
4980     if (cursor.shape() != Qt::ArrowCursor
4981         || (d->extra && d->extra->curs))
4982 #endif
4983     {
4984         d->createExtra();
4985         QCursor *newCursor = new QCursor(cursor);
4986         delete d->extra->curs;
4987         d->extra->curs = newCursor;
4988     }
4989     setAttribute(Qt::WA_SetCursor);
4990     d->setCursor_sys(cursor);
4991 
4992     QEvent event(QEvent::CursorChange);
4993     QApplication::sendEvent(this, &event);
4994 }
4995 
4996 void QWidgetPrivate::setCursor_sys(const QCursor &cursor)
4997 {
4998     Q_UNUSED(cursor);
4999     Q_Q(QWidget);
5000     qt_qpa_set_cursor(q, false);
5001 }
5002 
5003 void QWidget::unsetCursor()
5004 {
5005     Q_D(QWidget);
5006     if (d->extra) {
5007         delete d->extra->curs;
5008         d->extra->curs = 0;
5009     }
5010     if (!isWindow())
5011         setAttribute(Qt::WA_SetCursor, false);
5012     d->unsetCursor_sys();
5013 
5014     QEvent event(QEvent::CursorChange);
5015     QApplication::sendEvent(this, &event);
5016 }
5017 
5018 void QWidgetPrivate::unsetCursor_sys()
5019 {
5020     Q_Q(QWidget);
5021     qt_qpa_set_cursor(q, false);
5022 }
5023 
5024 static inline void applyCursor(QWidget *w, const QCursor &c)
5025 {
5026     if (QWindow *window = w->windowHandle())
5027         window->setCursor(c);
5028 }
5029 
5030 static inline void unsetCursor(QWidget *w)
5031 {
5032     if (QWindow *window = w->windowHandle())
5033         window->unsetCursor();
5034 }
5035 
5036 void qt_qpa_set_cursor(QWidget *w, bool force)
5037 {
5038     if (!w->testAttribute(Qt::WA_WState_Created))
5039         return;
5040 
5041     static QPointer<QWidget> lastUnderMouse = 0;
5042     if (force) {
5043         lastUnderMouse = w;
5044     } else if (lastUnderMouse) {
5045         const WId lastWinId = lastUnderMouse->effectiveWinId();
5046         const WId winId = w->effectiveWinId();
5047         if (lastWinId && lastWinId == winId)
5048             w = lastUnderMouse;
5049     } else if (!w->internalWinId()) {
5050         return; // The mouse is not under this widget, and it's not native, so don't change it.
5051     }
5052 
5053     while (!w->internalWinId() && w->parentWidget() && !w->isWindow()
5054            && !w->testAttribute(Qt::WA_SetCursor))
5055         w = w->parentWidget();
5056 
5057     QWidget *nativeParent = w;
5058     if (!w->internalWinId())
5059         nativeParent = w->nativeParentWidget();
5060     if (!nativeParent || !nativeParent->internalWinId())
5061         return;
5062 
5063     if (w->isWindow() || w->testAttribute(Qt::WA_SetCursor)) {
5064         if (w->isEnabled())
5065             applyCursor(nativeParent, w->cursor());
5066         else
5067             // Enforce the windows behavior of clearing the cursor on
5068             // disabled widgets.
5069             unsetCursor(nativeParent);
5070     } else {
5071         unsetCursor(nativeParent);
5072     }
5073 }
5074 #endif
5075 
5076 /*!
5077     \enum QWidget::RenderFlag
5078 
5079     This enum describes how to render the widget when calling QWidget::render().
5080 
5081     \value DrawWindowBackground If you enable this option, the widget's background
5082     is rendered into the target even if autoFillBackground is not set. By default,
5083     this option is enabled.
5084 
5085     \value DrawChildren If you enable this option, the widget's children
5086     are rendered recursively into the target. By default, this option is enabled.
5087 
5088     \value IgnoreMask If you enable this option, the widget's QWidget::mask()
5089     is ignored when rendering into the target. By default, this option is disabled.
5090 
5091     \since 4.3
5092 */
5093 
5094 /*!
5095     \since 4.3
5096 
5097     Renders the \a sourceRegion of this widget into the \a target
5098     using \a renderFlags to determine how to render. Rendering
5099     starts at \a targetOffset in the \a target. For example:
5100 
5101     \snippet code/src_gui_kernel_qwidget.cpp 7
5102 
5103     If \a sourceRegion is a null region, this function will use QWidget::rect() as
5104     the region, i.e. the entire widget.
5105 
5106     Ensure that you call QPainter::end() for the \a target device's
5107     active painter (if any) before rendering. For example:
5108 
5109     \snippet code/src_gui_kernel_qwidget.cpp 8
5110 
5111     \note To obtain the contents of a QOpenGLWidget, use QOpenGLWidget::grabFramebuffer()
5112     instead.
5113 
5114     \note To obtain the contents of a QGLWidget (deprecated), use
5115     QGLWidget::grabFrameBuffer() or QGLWidget::renderPixmap() instead.
5116 */
5117 void QWidget::render(QPaintDevice *target, const QPoint &targetOffset,
5118                      const QRegion &sourceRegion, RenderFlags renderFlags)
5119 {
5120     QPainter p(target);
5121     render(&p, targetOffset, sourceRegion, renderFlags);
5122 }
5123 
5124 /*!
5125     \overload
5126 
5127     Renders the widget into the \a painter's QPainter::device().
5128 
5129     Transformations and settings applied to the \a painter will be used
5130     when rendering.
5131 
5132     \note The \a painter must be active. On \macos the widget will be
5133     rendered into a QPixmap and then drawn by the \a painter.
5134 
5135     \sa QPainter::device()
5136 */
5137 void QWidget::render(QPainter *painter, const QPoint &targetOffset,
5138                      const QRegion &sourceRegion, RenderFlags renderFlags)
5139 {
5140     if (Q_UNLIKELY(!painter)) {
5141         qWarning("QWidget::render: Null pointer to painter");
5142         return;
5143     }
5144 
5145     if (Q_UNLIKELY(!painter->isActive())) {
5146         qWarning("QWidget::render: Cannot render with an inactive painter");
5147         return;
5148     }
5149 
5150     const qreal opacity = painter->opacity();
5151     if (qFuzzyIsNull(opacity))
5152         return; // Fully transparent.
5153 
5154     Q_D(QWidget);
5155     const bool inRenderWithPainter = d->extra && d->extra->inRenderWithPainter;
5156     const QRegion toBePainted = !inRenderWithPainter ? d->prepareToRender(sourceRegion, renderFlags)
5157                                                      : sourceRegion;
5158     if (toBePainted.isEmpty())
5159         return;
5160 
5161     if (!d->extra)
5162         d->createExtra();
5163     d->extra->inRenderWithPainter = true;
5164 
5165     QPaintEngine *engine = painter->paintEngine();
5166     Q_ASSERT(engine);
5167     QPaintEnginePrivate *enginePriv = engine->d_func();
5168     Q_ASSERT(enginePriv);
5169     QPaintDevice *target = engine->paintDevice();
5170     Q_ASSERT(target);
5171 
5172     // Render via a pixmap when dealing with non-opaque painters or printers.
5173     if (!inRenderWithPainter && (opacity < 1.0 || (target->devType() == QInternal::Printer))) {
5174         d->render_helper(painter, targetOffset, toBePainted, renderFlags);
5175         d->extra->inRenderWithPainter = inRenderWithPainter;
5176         return;
5177     }
5178 
5179     // Set new shared painter.
5180     QPainter *oldPainter = d->sharedPainter();
5181     d->setSharedPainter(painter);
5182 
5183     // Save current system clip, viewport and transform,
5184     const QTransform oldTransform = enginePriv->systemTransform;
5185     const QRegion oldSystemClip = enginePriv->systemClip;
5186     const QRegion oldBaseClip = enginePriv->baseSystemClip;
5187     const QRegion oldSystemViewport = enginePriv->systemViewport;
5188 
5189     // This ensures that all painting triggered by render() is clipped to the current engine clip.
5190     if (painter->hasClipping()) {
5191         const QRegion painterClip = painter->deviceTransform().map(painter->clipRegion());
5192         enginePriv->setSystemViewport(oldSystemClip.isEmpty() ? painterClip : oldSystemClip & painterClip);
5193     } else {
5194         enginePriv->setSystemViewport(oldSystemClip);
5195     }
5196 
5197     d->render(target, targetOffset, toBePainted, renderFlags);
5198 
5199     // Restore system clip, viewport and transform.
5200     enginePriv->baseSystemClip = oldBaseClip;
5201     enginePriv->setSystemTransformAndViewport(oldTransform, oldSystemViewport);
5202     enginePriv->systemStateChanged();
5203 
5204     // Restore shared painter.
5205     d->setSharedPainter(oldPainter);
5206 
5207     d->extra->inRenderWithPainter = inRenderWithPainter;
5208 }
5209 
5210 static void sendResizeEvents(QWidget *target)
5211 {
5212     QResizeEvent e(target->size(), QSize());
5213     QApplication::sendEvent(target, &e);
5214 
5215     const QObjectList children = target->children();
5216     for (int i = 0; i < children.size(); ++i) {
5217         if (!children.at(i)->isWidgetType())
5218             continue;
5219         QWidget *child = static_cast<QWidget*>(children.at(i));
5220         if (!child->isWindow() && child->testAttribute(Qt::WA_PendingResizeEvent))
5221             sendResizeEvents(child);
5222     }
5223 }
5224 
5225 /*!
5226     \since 5.0
5227 
5228     Renders the widget into a pixmap restricted by the
5229     given \a rectangle. If the widget has any children, then
5230     they are also painted in the appropriate positions.
5231 
5232     If a rectangle with an invalid size is specified  (the default),
5233     the entire widget is painted.
5234 
5235     \sa render(), QPixmap
5236 */
5237 QPixmap QWidget::grab(const QRect &rectangle)
5238 {
5239     Q_D(QWidget);
5240     if (testAttribute(Qt::WA_PendingResizeEvent) || !testAttribute(Qt::WA_WState_Created))
5241         sendResizeEvents(this);
5242 
5243     const QWidget::RenderFlags renderFlags = QWidget::DrawWindowBackground | QWidget::DrawChildren | QWidget::IgnoreMask;
5244 
5245     const bool oldDirtyOpaqueChildren =  d->dirtyOpaqueChildren;
5246     QRect r(rectangle);
5247     if (r.width() < 0 || r.height() < 0) {
5248         // For grabbing widgets that haven't been shown yet,
5249         // we trigger the layouting mechanism to determine the widget's size.
5250         r = d->prepareToRender(QRegion(), renderFlags).boundingRect();
5251         r.setTopLeft(rectangle.topLeft());
5252     }
5253 
5254     if (!r.intersects(rect()))
5255         return QPixmap();
5256 
5257     const qreal dpr = devicePixelRatioF();
5258     QPixmap res((QSizeF(r.size()) * dpr).toSize());
5259     res.setDevicePixelRatio(dpr);
5260     if (!d->isOpaque)
5261         res.fill(Qt::transparent);
5262     d->render(&res, QPoint(), QRegion(r), renderFlags);
5263 
5264     d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
5265     return res;
5266 }
5267 
5268 /*!
5269     \brief The graphicsEffect function returns a pointer to the
5270     widget's graphics effect.
5271 
5272     If the widget has no graphics effect, 0 is returned.
5273 
5274     \since 4.6
5275 
5276     \sa setGraphicsEffect()
5277 */
5278 #if QT_CONFIG(graphicseffect)
5279 QGraphicsEffect *QWidget::graphicsEffect() const
5280 {
5281     Q_D(const QWidget);
5282     return d->graphicsEffect;
5283 }
5284 #endif // QT_CONFIG(graphicseffect)
5285 
5286 /*!
5287 
5288   \brief The setGraphicsEffect function is for setting the widget's graphics effect.
5289 
5290     Sets \a effect as the widget's effect. If there already is an effect installed
5291     on this widget, QWidget will delete the existing effect before installing
5292     the new \a effect.
5293 
5294     If \a effect is the installed effect on a different widget, setGraphicsEffect() will remove
5295     the effect from the widget and install it on this widget.
5296 
5297     QWidget takes ownership of \a effect.
5298 
5299     \note This function will apply the effect on itself and all its children.
5300 
5301     \note Graphics effects are not supported for OpenGL-based widgets, such as QGLWidget,
5302     QOpenGLWidget and QQuickWidget.
5303 
5304     \since 4.6
5305 
5306     \sa graphicsEffect()
5307 */
5308 #if QT_CONFIG(graphicseffect)
5309 void QWidget::setGraphicsEffect(QGraphicsEffect *effect)
5310 {
5311     Q_D(QWidget);
5312     if (d->graphicsEffect == effect)
5313         return;
5314 
5315     if (d->graphicsEffect) {
5316         d->invalidateBuffer(rect());
5317         delete d->graphicsEffect;
5318         d->graphicsEffect = 0;
5319     }
5320 
5321     if (effect) {
5322         // Set new effect.
5323         QGraphicsEffectSourcePrivate *sourced = new QWidgetEffectSourcePrivate(this);
5324         QGraphicsEffectSource *source = new QGraphicsEffectSource(*sourced);
5325         d->graphicsEffect = effect;
5326         effect->d_func()->setGraphicsEffectSource(source);
5327         update();
5328     }
5329 
5330     d->updateIsOpaque();
5331 }
5332 #endif // QT_CONFIG(graphicseffect)
5333 
5334 bool QWidgetPrivate::isAboutToShow() const
5335 {
5336     if (data.in_show)
5337         return true;
5338 
5339     Q_Q(const QWidget);
5340     if (q->isHidden())
5341         return false;
5342 
5343     // The widget will be shown if any of its ancestors are about to show.
5344     QWidget *parent = q->parentWidget();
5345     return parent ? parent->d_func()->isAboutToShow() : false;
5346 }
5347 
5348 QRegion QWidgetPrivate::prepareToRender(const QRegion &region, QWidget::RenderFlags renderFlags)
5349 {
5350     Q_Q(QWidget);
5351     const bool isVisible = q->isVisible();
5352 
5353     // Make sure the widget is laid out correctly.
5354     if (!isVisible && !isAboutToShow()) {
5355         QWidget *topLevel = q->window();
5356         (void)topLevel->d_func()->topData(); // Make sure we at least have top-data.
5357         topLevel->ensurePolished();
5358 
5359         // Invalidate the layout of hidden ancestors (incl. myself) and pretend
5360         // they're not explicitly hidden.
5361         QWidget *widget = q;
5362         QWidgetList hiddenWidgets;
5363         while (widget) {
5364             if (widget->isHidden()) {
5365                 widget->setAttribute(Qt::WA_WState_Hidden, false);
5366                 hiddenWidgets.append(widget);
5367                 if (!widget->isWindow() && widget->parentWidget()->d_func()->layout)
5368                     widget->d_func()->updateGeometry_helper(true);
5369             }
5370             widget = widget->parentWidget();
5371         }
5372 
5373         // Activate top-level layout.
5374         if (topLevel->d_func()->layout)
5375             topLevel->d_func()->layout->activate();
5376 
5377         // Adjust size if necessary.
5378         QTLWExtra *topLevelExtra = topLevel->d_func()->maybeTopData();
5379         if (topLevelExtra && !topLevelExtra->sizeAdjusted
5380             && !topLevel->testAttribute(Qt::WA_Resized)) {
5381             topLevel->adjustSize();
5382             topLevel->setAttribute(Qt::WA_Resized, false);
5383         }
5384 
5385         // Activate child layouts.
5386         topLevel->d_func()->activateChildLayoutsRecursively();
5387 
5388         // We're not cheating with WA_WState_Hidden anymore.
5389         for (int i = 0; i < hiddenWidgets.size(); ++i) {
5390             QWidget *widget = hiddenWidgets.at(i);
5391             widget->setAttribute(Qt::WA_WState_Hidden);
5392             if (!widget->isWindow() && widget->parentWidget()->d_func()->layout)
5393                 widget->parentWidget()->d_func()->layout->invalidate();
5394         }
5395     } else if (isVisible) {
5396         q->window()->d_func()->sendPendingMoveAndResizeEvents(true, true);
5397     }
5398 
5399     // Calculate the region to be painted.
5400     QRegion toBePainted = !region.isEmpty() ? region : QRegion(q->rect());
5401     if (!(renderFlags & QWidget::IgnoreMask) && extra && extra->hasMask)
5402         toBePainted &= extra->mask;
5403     return toBePainted;
5404 }
5405 
5406 void QWidgetPrivate::render_helper(QPainter *painter, const QPoint &targetOffset, const QRegion &toBePainted,
5407                                    QWidget::RenderFlags renderFlags)
5408 {
5409     Q_ASSERT(painter);
5410     Q_ASSERT(!toBePainted.isEmpty());
5411 
5412     Q_Q(QWidget);
5413 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
5414     const QTransform originalTransform = painter->worldTransform();
5415     const bool useDeviceCoordinates = originalTransform.isScaling();
5416     if (!useDeviceCoordinates) {
5417 #endif
5418         // Render via a pixmap.
5419         const QRect rect = toBePainted.boundingRect();
5420         const QSize size = rect.size();
5421         if (size.isNull())
5422             return;
5423 
5424         const qreal pixmapDevicePixelRatio = painter->device()->devicePixelRatioF();
5425         QPixmap pixmap(size * pixmapDevicePixelRatio);
5426         pixmap.setDevicePixelRatio(pixmapDevicePixelRatio);
5427 
5428         if (!(renderFlags & QWidget::DrawWindowBackground) || !isOpaque)
5429             pixmap.fill(Qt::transparent);
5430         q->render(&pixmap, QPoint(), toBePainted, renderFlags);
5431 
5432         const bool restore = !(painter->renderHints() & QPainter::SmoothPixmapTransform);
5433         painter->setRenderHints(QPainter::SmoothPixmapTransform, true);
5434 
5435         painter->drawPixmap(targetOffset, pixmap);
5436 
5437         if (restore)
5438             painter->setRenderHints(QPainter::SmoothPixmapTransform, false);
5439 
5440 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
5441     } else {
5442         // Render via a pixmap in device coordinates (to avoid pixmap scaling).
5443         QTransform transform = originalTransform;
5444         transform.translate(targetOffset.x(), targetOffset.y());
5445 
5446         QPaintDevice *device = painter->device();
5447         Q_ASSERT(device);
5448 
5449         // Calculate device rect.
5450         const QRectF rect(toBePainted.boundingRect());
5451         QRect deviceRect = transform.mapRect(QRectF(0, 0, rect.width(), rect.height())).toAlignedRect();
5452         deviceRect &= QRect(0, 0, device->width(), device->height());
5453 
5454         QPixmap pixmap(deviceRect.size());
5455         pixmap.fill(Qt::transparent);
5456 
5457         // Create a pixmap device coordinate painter.
5458         QPainter pixmapPainter(&pixmap);
5459         pixmapPainter.setRenderHints(painter->renderHints());
5460         transform *= QTransform::fromTranslate(-deviceRect.x(), -deviceRect.y());
5461         pixmapPainter.setTransform(transform);
5462 
5463         q->render(&pixmapPainter, QPoint(), toBePainted, renderFlags);
5464         pixmapPainter.end();
5465 
5466         // And then draw the pixmap.
5467         painter->setTransform(QTransform());
5468         painter->drawPixmap(deviceRect.topLeft(), pixmap);
5469         painter->setTransform(originalTransform);
5470     }
5471 #endif
5472 }
5473 
5474 void QWidgetPrivate::drawWidget(QPaintDevice *pdev, const QRegion &rgn, const QPoint &offset, int flags,
5475                                 QPainter *sharedPainter, QWidgetBackingStore *backingStore)
5476 {
5477     if (rgn.isEmpty())
5478         return;
5479 
5480     const bool asRoot = flags & DrawAsRoot;
5481     bool onScreen = paintOnScreen();
5482 
5483     Q_Q(QWidget);
5484 #if QT_CONFIG(graphicseffect)
5485     if (graphicsEffect && graphicsEffect->isEnabled()) {
5486         QGraphicsEffectSource *source = graphicsEffect->d_func()->source;
5487         QWidgetEffectSourcePrivate *sourced = static_cast<QWidgetEffectSourcePrivate *>
5488                                                          (source->d_func());
5489         if (!sourced->context) {
5490             QWidgetPaintContext context(pdev, rgn, offset, flags, sharedPainter, backingStore);
5491             sourced->context = &context;
5492             if (!sharedPainter) {
5493                 setSystemClip(pdev->paintEngine(), pdev->devicePixelRatioF(), rgn.translated(offset));
5494                 QPainter p(pdev);
5495                 p.translate(offset);
5496                 context.painter = context.sharedPainter = &p;
5497                 graphicsEffect->draw(&p);
5498                 setSystemClip(pdev->paintEngine(), 1, QRegion());
5499             } else {
5500                 context.painter = context.sharedPainter = sharedPainter;
5501                 if (sharedPainter->worldTransform() != sourced->lastEffectTransform) {
5502                     sourced->invalidateCache();
5503                     sourced->lastEffectTransform = sharedPainter->worldTransform();
5504                 }
5505                 sharedPainter->save();
5506                 sharedPainter->translate(offset);
5507                 setSystemClip(sharedPainter->paintEngine(), sharedPainter->device()->devicePixelRatioF(), rgn.translated(offset));
5508                 graphicsEffect->draw(sharedPainter);
5509                 setSystemClip(sharedPainter->paintEngine(), 1, QRegion());
5510                 sharedPainter->restore();
5511             }
5512             sourced->context = 0;
5513 
5514             // Native widgets need to be marked dirty on screen so painting will be done in correct context
5515             // Same check as in the no effects case below.
5516             if (backingStore && !onScreen && !asRoot && (q->internalWinId() || !q->nativeParentWidget()->isWindow()))
5517                 backingStore->markDirtyOnScreen(rgn, q, offset);
5518 
5519             return;
5520         }
5521     }
5522 #endif // QT_CONFIG(graphicseffect)
5523 
5524     const bool alsoOnScreen = flags & DrawPaintOnScreen;
5525     const bool recursive = flags & DrawRecursive;
5526     const bool alsoInvisible = flags & DrawInvisible;
5527 
5528     Q_ASSERT(sharedPainter ? sharedPainter->isActive() : true);
5529 
5530     QRegion toBePainted(rgn);
5531     if (asRoot && !alsoInvisible)
5532         toBePainted &= clipRect(); //(rgn & visibleRegion());
5533     if (!(flags & DontSubtractOpaqueChildren))
5534         subtractOpaqueChildren(toBePainted, q->rect());
5535 
5536     if (!toBePainted.isEmpty()) {
5537         if (!onScreen || alsoOnScreen) {
5538             //update the "in paint event" flag
5539             if (Q_UNLIKELY(q->testAttribute(Qt::WA_WState_InPaintEvent)))
5540                 qWarning("QWidget::repaint: Recursive repaint detected");
5541             q->setAttribute(Qt::WA_WState_InPaintEvent);
5542 
5543             //clip away the new area
5544 #ifndef QT_NO_PAINT_DEBUG
5545             bool flushed = QWidgetBackingStore::flushPaint(q, toBePainted);
5546 #endif
5547             QPaintEngine *paintEngine = pdev->paintEngine();
5548             if (paintEngine) {
5549                 setRedirected(pdev, -offset);
5550 
5551 #if 0 // Used to be included in Qt4 for Q_WS_MAC
5552                 // (Alien support) Special case for Mac when redirecting: If the paint device
5553                 // is of the Widget type we need to set WA_WState_InPaintEvent since painting
5554                 // outside the paint event is not supported on QWidgets. The attributeis
5555                 // restored further down.
5556                 if (pdev->devType() == QInternal::Widget)
5557                     static_cast<QWidget *>(pdev)->setAttribute(Qt::WA_WState_InPaintEvent);
5558 
5559 #endif
5560                 if (sharedPainter)
5561                     setSystemClip(pdev->paintEngine(), pdev->devicePixelRatioF(), toBePainted);
5562                 else
5563                     paintEngine->d_func()->systemRect = q->data->crect;
5564 
5565                 //paint the background
5566                 if ((asRoot || q->autoFillBackground() || onScreen || q->testAttribute(Qt::WA_StyledBackground))
5567                     && !q->testAttribute(Qt::WA_OpaquePaintEvent) && !q->testAttribute(Qt::WA_NoSystemBackground)) {
5568 #ifndef QT_NO_OPENGL
5569                     beginBackingStorePainting();
5570 #endif
5571                     QPainter p(q);
5572                     paintBackground(&p, toBePainted, (asRoot || onScreen) ? flags | DrawAsRoot : 0);
5573 #ifndef QT_NO_OPENGL
5574                     endBackingStorePainting();
5575 #endif
5576                 }
5577 
5578                 if (!sharedPainter)
5579                     setSystemClip(pdev->paintEngine(), pdev->devicePixelRatioF(), toBePainted.translated(offset));
5580 
5581                 if (!onScreen && !asRoot && !isOpaque && q->testAttribute(Qt::WA_TintedBackground)) {
5582 #ifndef QT_NO_OPENGL
5583                     beginBackingStorePainting();
5584 #endif
5585                     QPainter p(q);
5586                     QColor tint = q->palette().window().color();
5587                     tint.setAlphaF(qreal(.6));
5588                     p.fillRect(toBePainted.boundingRect(), tint);
5589 #ifndef QT_NO_OPENGL
5590                     endBackingStorePainting();
5591 #endif
5592                 }
5593             }
5594 
5595 #if 0
5596             qDebug() << "painting" << q << "opaque ==" << isOpaque();
5597             qDebug() << "clipping to" << toBePainted << "location == " << offset
5598                      << "geometry ==" << QRect(q->mapTo(q->window(), QPoint(0, 0)), q->size());
5599 #endif
5600 
5601             bool skipPaintEvent = false;
5602 #ifndef QT_NO_OPENGL
5603             if (renderToTexture) {
5604                 // This widget renders into a texture which is composed later. We just need to
5605                 // punch a hole in the backingstore, so the texture will be visible.
5606                 if (!q->testAttribute(Qt::WA_AlwaysStackOnTop)) {
5607                     beginBackingStorePainting();
5608                     if (backingStore) {
5609                         QPainter p(q);
5610                         p.setCompositionMode(QPainter::CompositionMode_Source);
5611                         p.fillRect(q->rect(), Qt::transparent);
5612                     } else {
5613                         QImage img = grabFramebuffer();
5614                         QPainter p(q);
5615                         // We are not drawing to a backingstore: fall back to QImage
5616                         p.drawImage(q->rect(), img);
5617                         skipPaintEvent = true;
5618                     }
5619                     endBackingStorePainting();
5620                 }
5621                 if (renderToTextureReallyDirty)
5622                     renderToTextureReallyDirty = 0;
5623                 else
5624                     skipPaintEvent = true;
5625             }
5626 #endif // QT_NO_OPENGL
5627 
5628             if (!skipPaintEvent) {
5629                 //actually send the paint event
5630                 sendPaintEvent(toBePainted);
5631             }
5632 
5633             // Native widgets need to be marked dirty on screen so painting will be done in correct context
5634             if (backingStore && !onScreen && !asRoot && (q->internalWinId() || (q->nativeParentWidget() && !q->nativeParentWidget()->isWindow())))
5635                 backingStore->markDirtyOnScreen(toBePainted, q, offset);
5636 
5637             //restore
5638             if (paintEngine) {
5639 #if 0 // Used to be included in Qt4 for Q_WS_MAC
5640                 if (pdev->devType() == QInternal::Widget)
5641                     static_cast<QWidget *>(pdev)->setAttribute(Qt::WA_WState_InPaintEvent, false);
5642 #endif
5643                 restoreRedirected();
5644                 if (!sharedPainter)
5645                     paintEngine->d_func()->systemRect = QRect();
5646                 else
5647                     paintEngine->d_func()->currentClipDevice = 0;
5648 
5649                 setSystemClip(pdev->paintEngine(), 1, QRegion());
5650             }
5651             q->setAttribute(Qt::WA_WState_InPaintEvent, false);
5652             if (Q_UNLIKELY(q->paintingActive()))
5653                 qWarning("QWidget::repaint: It is dangerous to leave painters active on a widget outside of the PaintEvent");
5654 
5655             if (paintEngine && paintEngine->autoDestruct()) {
5656                 delete paintEngine;
5657             }
5658 
5659 #ifndef QT_NO_PAINT_DEBUG
5660             if (flushed)
5661                 QWidgetBackingStore::unflushPaint(q, toBePainted);
5662 #endif
5663         } else if (q->isWindow()) {
5664             QPaintEngine *engine = pdev->paintEngine();
5665             if (engine) {
5666                 QPainter p(pdev);
5667                 p.setClipRegion(toBePainted);
5668                 const QBrush bg = q->palette().brush(QPalette::Window);
5669                 if (bg.style() == Qt::TexturePattern)
5670                     p.drawTiledPixmap(q->rect(), bg.texture());
5671                 else
5672                     p.fillRect(q->rect(), bg);
5673 
5674                 if (engine->autoDestruct())
5675                     delete engine;
5676             }
5677         }
5678     }
5679 
5680     if (recursive && !children.isEmpty()) {
5681         paintSiblingsRecursive(pdev, children, children.size() - 1, rgn, offset, flags & ~DrawAsRoot
5682                                 , sharedPainter, backingStore);
5683     }
5684 }
5685 
5686 void QWidgetPrivate::sendPaintEvent(const QRegion &toBePainted)
5687 {
5688     Q_Q(QWidget);
5689     QPaintEvent e(toBePainted);
5690     QCoreApplication::sendSpontaneousEvent(q, &e);
5691 
5692 #ifndef QT_NO_OPENGL
5693     if (renderToTexture)
5694         resolveSamples();
5695 #endif // QT_NO_OPENGL
5696 }
5697 
5698 void QWidgetPrivate::render(QPaintDevice *target, const QPoint &targetOffset,
5699                             const QRegion &sourceRegion, QWidget::RenderFlags renderFlags)
5700 {
5701     if (Q_UNLIKELY(!target)) {
5702         qWarning("QWidget::render: null pointer to paint device");
5703         return;
5704     }
5705 
5706     const bool inRenderWithPainter = extra && extra->inRenderWithPainter;
5707     QRegion paintRegion = !inRenderWithPainter
5708                           ? prepareToRender(sourceRegion, renderFlags)
5709                           : sourceRegion;
5710     if (paintRegion.isEmpty())
5711         return;
5712 
5713 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
5714     QPainter *oldSharedPainter = inRenderWithPainter ? sharedPainter() : 0;
5715 
5716     // Use the target's shared painter if set (typically set when doing
5717     // "other->render(widget);" in the widget's paintEvent.
5718     if (target->devType() == QInternal::Widget) {
5719         QWidgetPrivate *targetPrivate = static_cast<QWidget *>(target)->d_func();
5720         if (targetPrivate->extra && targetPrivate->extra->inRenderWithPainter) {
5721             QPainter *targetPainter = targetPrivate->sharedPainter();
5722             if (targetPainter && targetPainter->isActive())
5723                 setSharedPainter(targetPainter);
5724         }
5725     }
5726 #endif
5727 
5728     // Use the target's redirected device if set and adjust offset and paint
5729     // region accordingly. This is typically the case when people call render
5730     // from the paintEvent.
5731     QPoint offset = targetOffset;
5732     offset -= paintRegion.boundingRect().topLeft();
5733     QPoint redirectionOffset;
5734     QPaintDevice *redirected = 0;
5735 
5736     if (target->devType() == QInternal::Widget)
5737         redirected = static_cast<QWidget *>(target)->d_func()->redirected(&redirectionOffset);
5738     if (!redirected)
5739         redirected = QPainter::redirected(target, &redirectionOffset);
5740 
5741     if (redirected) {
5742         target = redirected;
5743         offset -= redirectionOffset;
5744     }
5745 
5746     if (!inRenderWithPainter) { // Clip handled by shared painter (in qpainter.cpp).
5747         if (QPaintEngine *targetEngine = target->paintEngine()) {
5748             const QRegion targetSystemClip = targetEngine->systemClip();
5749             if (!targetSystemClip.isEmpty())
5750                 paintRegion &= targetSystemClip.translated(-offset);
5751         }
5752     }
5753 
5754     // Set backingstore flags.
5755     int flags = DrawPaintOnScreen | DrawInvisible;
5756     if (renderFlags & QWidget::DrawWindowBackground)
5757         flags |= DrawAsRoot;
5758 
5759     if (renderFlags & QWidget::DrawChildren)
5760         flags |= DrawRecursive;
5761     else
5762         flags |= DontSubtractOpaqueChildren;
5763 
5764     flags |= DontSetCompositionMode;
5765 
5766     // Render via backingstore.
5767     drawWidget(target, paintRegion, offset, flags, sharedPainter());
5768 
5769     // Restore shared painter.
5770     if (oldSharedPainter)
5771         setSharedPainter(oldSharedPainter);
5772 }
5773 
5774 void QWidgetPrivate::paintSiblingsRecursive(QPaintDevice *pdev, const QObjectList& siblings, int index, const QRegion &rgn,
5775                                             const QPoint &offset, int flags
5776                                             , QPainter *sharedPainter, QWidgetBackingStore *backingStore)
5777 {
5778     QWidget *w = 0;
5779     QRect boundingRect;
5780     bool dirtyBoundingRect = true;
5781     const bool exludeOpaqueChildren = (flags & DontDrawOpaqueChildren);
5782     const bool excludeNativeChildren = (flags & DontDrawNativeChildren);
5783 
5784     do {
5785         QWidget *x =  qobject_cast<QWidget*>(siblings.at(index));
5786         if (x && !(exludeOpaqueChildren && x->d_func()->isOpaque) && !x->isHidden() && !x->isWindow()
5787             && !(excludeNativeChildren && x->internalWinId())) {
5788             if (dirtyBoundingRect) {
5789                 boundingRect = rgn.boundingRect();
5790                 dirtyBoundingRect = false;
5791             }
5792 
5793             if (qRectIntersects(boundingRect, x->d_func()->effectiveRectFor(x->data->crect))) {
5794                 w = x;
5795                 break;
5796             }
5797         }
5798         --index;
5799     } while (index >= 0);
5800 
5801     if (!w)
5802         return;
5803 
5804     QWidgetPrivate *wd = w->d_func();
5805     const QPoint widgetPos(w->data->crect.topLeft());
5806     const bool hasMask = wd->extra && wd->extra->hasMask && !wd->graphicsEffect;
5807     if (index > 0) {
5808         QRegion wr(rgn);
5809         if (wd->isOpaque)
5810             wr -= hasMask ? wd->extra->mask.translated(widgetPos) : w->data->crect;
5811         paintSiblingsRecursive(pdev, siblings, --index, wr, offset, flags
5812                                , sharedPainter, backingStore);
5813     }
5814 
5815     if (w->updatesEnabled()
5816 #if QT_CONFIG(graphicsview)
5817             && (!w->d_func()->extra || !w->d_func()->extra->proxyWidget)
5818 #endif // QT_CONFIG(graphicsview)
5819        ) {
5820         QRegion wRegion(rgn);
5821         wRegion &= wd->effectiveRectFor(w->data->crect);
5822         wRegion.translate(-widgetPos);
5823         if (hasMask)
5824             wRegion &= wd->extra->mask;
5825         wd->drawWidget(pdev, wRegion, offset + widgetPos, flags, sharedPainter, backingStore);
5826     }
5827 }
5828 
5829 #if QT_CONFIG(graphicseffect)
5830 QRectF QWidgetEffectSourcePrivate::boundingRect(Qt::CoordinateSystem system) const
5831 {
5832     if (system != Qt::DeviceCoordinates)
5833         return m_widget->rect();
5834 
5835     if (Q_UNLIKELY(!context)) {
5836         // Device coordinates without context not yet supported.
5837         qWarning("QGraphicsEffectSource::boundingRect: Not yet implemented, lacking device context");
5838         return QRectF();
5839     }
5840 
5841     return context->painter->worldTransform().mapRect(m_widget->rect());
5842 }
5843 
5844 void QWidgetEffectSourcePrivate::draw(QPainter *painter)
5845 {
5846     if (!context || context->painter != painter) {
5847         m_widget->render(painter);
5848         return;
5849     }
5850 
5851     // The region saved in the context is neither clipped to the rect
5852     // nor the mask, so we have to clip it here before calling drawWidget.
5853     QRegion toBePainted = context->rgn;
5854     toBePainted &= m_widget->rect();
5855     QWidgetPrivate *wd = qt_widget_private(m_widget);
5856     if (wd->extra && wd->extra->hasMask)
5857         toBePainted &= wd->extra->mask;
5858 
5859     wd->drawWidget(context->pdev, toBePainted, context->offset, context->flags,
5860                    context->sharedPainter, context->backingStore);
5861 }
5862 
5863 QPixmap QWidgetEffectSourcePrivate::pixmap(Qt::CoordinateSystem system, QPoint *offset,
5864                                            QGraphicsEffect::PixmapPadMode mode) const
5865 {
5866     const bool deviceCoordinates = (system == Qt::DeviceCoordinates);
5867     if (Q_UNLIKELY(!context && deviceCoordinates)) {
5868         // Device coordinates without context not yet supported.
5869         qWarning("QGraphicsEffectSource::pixmap: Not yet implemented, lacking device context");
5870         return QPixmap();
5871     }
5872 
5873     QPoint pixmapOffset;
5874     QRectF sourceRect = m_widget->rect();
5875 
5876     if (deviceCoordinates) {
5877         const QTransform &painterTransform = context->painter->worldTransform();
5878         sourceRect = painterTransform.mapRect(sourceRect);
5879         pixmapOffset = painterTransform.map(pixmapOffset);
5880     }
5881 
5882     QRect effectRect;
5883 
5884     if (mode == QGraphicsEffect::PadToEffectiveBoundingRect)
5885         effectRect = m_widget->graphicsEffect()->boundingRectFor(sourceRect).toAlignedRect();
5886     else if (mode == QGraphicsEffect::PadToTransparentBorder)
5887         effectRect = sourceRect.adjusted(-1, -1, 1, 1).toAlignedRect();
5888     else
5889         effectRect = sourceRect.toAlignedRect();
5890 
5891     if (offset)
5892         *offset = effectRect.topLeft();
5893 
5894     pixmapOffset -= effectRect.topLeft();
5895 
5896     const qreal dpr = context->painter->device()->devicePixelRatioF();
5897     QPixmap pixmap(effectRect.size() * dpr);
5898     pixmap.setDevicePixelRatio(dpr);
5899 
5900     pixmap.fill(Qt::transparent);
5901     m_widget->render(&pixmap, pixmapOffset, QRegion(), QWidget::DrawChildren);
5902     return pixmap;
5903 }
5904 #endif // QT_CONFIG(graphicseffect)
5905 
5906 #if QT_CONFIG(graphicsview)
5907 /*!
5908     \internal
5909 
5910     Finds the nearest widget embedded in a graphics proxy widget along the chain formed by this
5911     widget and its ancestors. The search starts at \a origin (inclusive).
5912     If successful, the function returns the proxy that embeds the widget, or 0 if no embedded
5913     widget was found.
5914 */
5915 QGraphicsProxyWidget * QWidgetPrivate::nearestGraphicsProxyWidget(const QWidget *origin)
5916 {
5917     if (origin) {
5918         QWExtra *extra = origin->d_func()->extra;
5919         if (extra && extra->proxyWidget)
5920             return extra->proxyWidget;
5921         return nearestGraphicsProxyWidget(origin->parentWidget());
5922     }
5923     return 0;
5924 }
5925 #endif
5926 
5927 /*!
5928     \property QWidget::locale
5929     \brief the widget's locale
5930     \since 4.3
5931 
5932     As long as no special locale has been set, this is either
5933     the parent's locale or (if this widget is a top level widget),
5934     the default locale.
5935 
5936     If the widget displays dates or numbers, these should be formatted
5937     using the widget's locale.
5938 
5939     \sa QLocale, QLocale::setDefault()
5940 */
5941 
5942 void QWidgetPrivate::setLocale_helper(const QLocale &loc, bool forceUpdate)
5943 {
5944     Q_Q(QWidget);
5945     if (locale == loc && !forceUpdate)
5946         return;
5947 
5948     locale = loc;
5949 
5950     if (!children.isEmpty()) {
5951         for (int i = 0; i < children.size(); ++i) {
5952             QWidget *w = qobject_cast<QWidget*>(children.at(i));
5953             if (!w)
5954                 continue;
5955             if (w->testAttribute(Qt::WA_SetLocale))
5956                 continue;
5957             if (w->isWindow() && !w->testAttribute(Qt::WA_WindowPropagation))
5958                 continue;
5959             w->d_func()->setLocale_helper(loc, forceUpdate);
5960         }
5961     }
5962     QEvent e(QEvent::LocaleChange);
5963     QApplication::sendEvent(q, &e);
5964 }
5965 
5966 void QWidget::setLocale(const QLocale &locale)
5967 {
5968     Q_D(QWidget);
5969 
5970     setAttribute(Qt::WA_SetLocale);
5971     d->setLocale_helper(locale);
5972 }
5973 
5974 QLocale QWidget::locale() const
5975 {
5976     Q_D(const QWidget);
5977 
5978     return d->locale;
5979 }
5980 
5981 void QWidgetPrivate::resolveLocale()
5982 {
5983     Q_Q(const QWidget);
5984 
5985     if (!q->testAttribute(Qt::WA_SetLocale)) {
5986         QWidget *parent = q->parentWidget();
5987         setLocale_helper(!parent || (q->isWindow() && !q->testAttribute(Qt::WA_WindowPropagation))
5988                          ? QLocale() : parent->locale());
5989     }
5990 }
5991 
5992 void QWidget::unsetLocale()
5993 {
5994     Q_D(QWidget);
5995     setAttribute(Qt::WA_SetLocale, false);
5996     d->resolveLocale();
5997 }
5998 
5999 /*!
6000     \property QWidget::windowTitle
6001     \brief the window title (caption)
6002 
6003     This property only makes sense for top-level widgets, such as
6004     windows and dialogs. If no caption has been set, the title is based of the
6005     \l windowFilePath. If neither of these is set, then the title is
6006     an empty string.
6007 
6008     If you use the \l windowModified mechanism, the window title must
6009     contain a "[*]" placeholder, which indicates where the '*' should
6010     appear. Normally, it should appear right after the file name
6011     (e.g., "document1.txt[*] - Text Editor"). If the \l
6012     windowModified property is \c false (the default), the placeholder
6013     is simply removed.
6014 
6015     On some desktop platforms (including Windows and Unix), the application name
6016     (from QGuiApplication::applicationDisplayName) is added at the end of the
6017     window title, if set. This is done by the QPA plugin, so it is shown to the
6018     user, but isn't part of the windowTitle string.
6019 
6020     \sa windowIcon, windowModified, windowFilePath
6021 */
6022 QString QWidget::windowTitle() const
6023 {
6024     Q_D(const QWidget);
6025     if (d->extra && d->extra->topextra) {
6026         if (!d->extra->topextra->caption.isEmpty())
6027             return d->extra->topextra->caption;
6028         if (!d->extra->topextra->filePath.isEmpty())
6029             return QFileInfo(d->extra->topextra->filePath).fileName() + QLatin1String("[*]");
6030     }
6031     return QString();
6032 }
6033 
6034 /*!
6035     Returns a modified window title with the [*] place holder
6036     replaced according to the rules described in QWidget::setWindowTitle
6037 
6038     This function assumes that "[*]" can be quoted by another
6039     "[*]", so it will replace two place holders by one and
6040     a single last one by either "*" or nothing depending on
6041     the modified flag.
6042 
6043     \internal
6044 */
6045 QString qt_setWindowTitle_helperHelper(const QString &title, const QWidget *widget)
6046 {
6047     Q_ASSERT(widget);
6048 
6049 #ifdef QT_EVAL
6050     extern QString qt_eval_adapt_window_title(const QString &title);
6051     QString cap = qt_eval_adapt_window_title(title);
6052 #else
6053     QString cap = title;
6054 #endif
6055 
6056     if (cap.isEmpty())
6057         return cap;
6058 
6059     QLatin1String placeHolder("[*]");
6060     int index = cap.indexOf(placeHolder);
6061 
6062     // here the magic begins
6063     while (index != -1) {
6064         index += placeHolder.size();
6065         int count = 1;
6066         while (cap.indexOf(placeHolder, index) == index) {
6067             ++count;
6068             index += placeHolder.size();
6069         }
6070 
6071         if (count%2) { // odd number of [*] -> replace last one
6072             int lastIndex = cap.lastIndexOf(placeHolder, index - 1);
6073             if (widget->isWindowModified()
6074              && widget->style()->styleHint(QStyle::SH_TitleBar_ModifyNotification, 0, widget))
6075                 cap.replace(lastIndex, 3, QWidget::tr("*"));
6076             else
6077                 cap.remove(lastIndex, 3);
6078         }
6079 
6080         index = cap.indexOf(placeHolder, index);
6081     }
6082 
6083     cap.replace(QLatin1String("[*][*]"), placeHolder);
6084 
6085     return cap;
6086 }
6087 
6088 void QWidgetPrivate::setWindowTitle_helper(const QString &title)
6089 {
6090     Q_Q(QWidget);
6091     if (q->testAttribute(Qt::WA_WState_Created))
6092         setWindowTitle_sys(qt_setWindowTitle_helperHelper(title, q));
6093 }
6094 
6095 void QWidgetPrivate::setWindowTitle_sys(const QString &caption)
6096 {
6097     Q_Q(QWidget);
6098     if (!q->isWindow())
6099         return;
6100 
6101     if (QWindow *window = q->windowHandle())
6102         window->setTitle(caption);
6103 
6104 }
6105 
6106 void QWidgetPrivate::setWindowIconText_helper(const QString &title)
6107 {
6108     Q_Q(QWidget);
6109     if (q->testAttribute(Qt::WA_WState_Created))
6110         setWindowIconText_sys(qt_setWindowTitle_helperHelper(title, q));
6111 }
6112 
6113 void QWidgetPrivate::setWindowIconText_sys(const QString &iconText)
6114 {
6115     Q_Q(QWidget);
6116     // ### The QWidget property is deprecated, but the XCB window function is not.
6117     // It should remain available for the rare application that needs it.
6118     if (QWindow *window = q->windowHandle())
6119         QXcbWindowFunctions::setWmWindowIconText(window, iconText);
6120 }
6121 
6122 /*!
6123     \fn void QWidget::windowIconTextChanged(const QString &iconText)
6124 
6125     This signal is emitted when the window's icon text has changed, with the
6126     new \a iconText as an argument.
6127 
6128     \since 5.2
6129     \obsolete
6130 
6131     This signal is deprecated.
6132 */
6133 
6134 void QWidget::setWindowIconText(const QString &iconText)
6135 {
6136     if (QWidget::windowIconText() == iconText)
6137         return;
6138 
6139     Q_D(QWidget);
6140     d->topData()->iconText = iconText;
6141     d->setWindowIconText_helper(iconText);
6142 
6143     QEvent e(QEvent::IconTextChange);
6144     QApplication::sendEvent(this, &e);
6145 
6146     emit windowIconTextChanged(iconText);
6147 }
6148 
6149 /*!
6150     \fn void QWidget::windowTitleChanged(const QString &title)
6151 
6152     This signal is emitted when the window's title has changed, with the
6153     new \a title as an argument.
6154 
6155     \since 5.2
6156 */
6157 
6158 void QWidget::setWindowTitle(const QString &title)
6159 {
6160     if (QWidget::windowTitle() == title && !title.isEmpty() && !title.isNull())
6161         return;
6162 
6163     Q_D(QWidget);
6164     d->topData()->caption = title;
6165     d->setWindowTitle_helper(title);
6166 
6167     QEvent e(QEvent::WindowTitleChange);
6168     QApplication::sendEvent(this, &e);
6169 
6170     emit windowTitleChanged(title);
6171 }
6172 
6173 
6174 /*!
6175     \property QWidget::windowIcon
6176     \brief the widget's icon
6177 
6178     This property only makes sense for windows. If no icon
6179     has been set, windowIcon() returns the application icon
6180     (QApplication::windowIcon()).
6181 
6182     \sa windowTitle
6183 */
6184 QIcon QWidget::windowIcon() const
6185 {
6186     const QWidget *w = this;
6187     while (w) {
6188         const QWidgetPrivate *d = w->d_func();
6189         if (d->extra && d->extra->topextra && d->extra->topextra->icon)
6190             return *d->extra->topextra->icon;
6191         w = w->parentWidget();
6192     }
6193     return QApplication::windowIcon();
6194 }
6195 
6196 void QWidgetPrivate::setWindowIcon_helper()
6197 {
6198     Q_Q(QWidget);
6199     QEvent e(QEvent::WindowIconChange);
6200 
6201     // Do not send the event if the widget is a top level.
6202     // In that case, setWindowIcon_sys does it, and event propagation from
6203     // QWidgetWindow to the top level QWidget ensures that the event reaches
6204     // the top level anyhow
6205     if (!q->windowHandle())
6206         QApplication::sendEvent(q, &e);
6207     for (int i = 0; i < children.size(); ++i) {
6208         QWidget *w = qobject_cast<QWidget *>(children.at(i));
6209         if (w && !w->isWindow())
6210             QApplication::sendEvent(w, &e);
6211     }
6212 }
6213 
6214 /*!
6215     \fn void QWidget::windowIconChanged(const QIcon &icon)
6216 
6217     This signal is emitted when the window's icon has changed, with the
6218     new \a icon as an argument.
6219 
6220     \since 5.2
6221 */
6222 
6223 void QWidget::setWindowIcon(const QIcon &icon)
6224 {
6225     Q_D(QWidget);
6226 
6227     setAttribute(Qt::WA_SetWindowIcon, !icon.isNull());
6228     d->createTLExtra();
6229 
6230     if (!d->extra->topextra->icon)
6231         d->extra->topextra->icon = new QIcon();
6232     *d->extra->topextra->icon = icon;
6233 
6234     d->setWindowIcon_sys();
6235     d->setWindowIcon_helper();
6236 
6237     emit windowIconChanged(icon);
6238 }
6239 
6240 void QWidgetPrivate::setWindowIcon_sys()
6241 {
6242     Q_Q(QWidget);
6243     if (QWindow *window = q->windowHandle())
6244         window->setIcon(q->windowIcon());
6245 }
6246 
6247 /*!
6248     \property QWidget::windowIconText
6249     \brief the text to be displayed on the icon of a minimized window
6250 
6251     This property only makes sense for windows. If no icon
6252     text has been set, this accessor returns an empty string.
6253     It is only implemented on the X11 platform, and only certain
6254     window managers use this window property.
6255 
6256     \obsolete
6257     This property is deprecated.
6258 
6259     \sa windowIcon, windowTitle
6260 */
6261 
6262 QString QWidget::windowIconText() const
6263 {
6264     Q_D(const QWidget);
6265     return (d->extra && d->extra->topextra) ? d->extra->topextra->iconText : QString();
6266 }
6267 
6268 /*!
6269     \property QWidget::windowFilePath
6270     \since 4.4
6271     \brief the file path associated with a widget
6272 
6273     This property only makes sense for windows. It associates a file path with
6274     a window. If you set the file path, but have not set the window title, Qt
6275     sets the window title to the file name of the specified path, obtained using
6276     QFileInfo::fileName().
6277 
6278     If the window title is set at any point, then the window title takes precedence and
6279     will be shown instead of the file path string.
6280 
6281     Additionally, on \macos, this has an added benefit that it sets the
6282     \l{http://developer.apple.com/documentation/UserExperience/Conceptual/OSXHIGuidelines/XHIGWindows/chapter_17_section_3.html}{proxy icon}
6283     for the window, assuming that the file path exists.
6284 
6285     If no file path is set, this property contains an empty string.
6286 
6287     By default, this property contains an empty string.
6288 
6289     \sa windowTitle, windowIcon
6290 */
6291 
6292 QString QWidget::windowFilePath() const
6293 {
6294     Q_D(const QWidget);
6295     return (d->extra && d->extra->topextra) ? d->extra->topextra->filePath : QString();
6296 }
6297 
6298 void QWidget::setWindowFilePath(const QString &filePath)
6299 {
6300     if (filePath == windowFilePath())
6301         return;
6302 
6303     Q_D(QWidget);
6304 
6305     d->createTLExtra();
6306     d->extra->topextra->filePath = filePath;
6307     d->setWindowFilePath_helper(filePath);
6308 }
6309 
6310 void QWidgetPrivate::setWindowFilePath_helper(const QString &filePath)
6311 {
6312     if (extra->topextra && extra->topextra->caption.isEmpty()) {
6313 #ifdef Q_OS_MAC
6314         setWindowTitle_helper(QFileInfo(filePath).fileName());
6315 #else
6316         Q_Q(QWidget);
6317         Q_UNUSED(filePath);
6318         setWindowTitle_helper(q->windowTitle());
6319 #endif
6320     }
6321 #ifdef Q_OS_MAC
6322     setWindowFilePath_sys(filePath);
6323 #endif
6324 }
6325 
6326 void QWidgetPrivate::setWindowFilePath_sys(const QString &filePath)
6327 {
6328     Q_Q(QWidget);
6329     if (!q->isWindow())
6330         return;
6331 
6332     if (QWindow *window = q->windowHandle())
6333         window->setFilePath(filePath);
6334 }
6335 
6336 /*!
6337     Returns the window's role, or an empty string.
6338 
6339     \sa windowIcon, windowTitle
6340 */
6341 
6342 QString QWidget::windowRole() const
6343 {
6344     Q_D(const QWidget);
6345     return (d->extra && d->extra->topextra) ? d->extra->topextra->role : QString();
6346 }
6347 
6348 /*!
6349     Sets the window's role to \a role. This only makes sense for
6350     windows on X11.
6351 */
6352 void QWidget::setWindowRole(const QString &role)
6353 {
6354     Q_D(QWidget);
6355     d->createTLExtra();
6356     d->topData()->role = role;
6357     if (windowHandle())
6358         QXcbWindowFunctions::setWmWindowRole(windowHandle(), role.toLatin1());
6359 }
6360 
6361 /*!
6362     \property QWidget::mouseTracking
6363     \brief whether mouse tracking is enabled for the widget
6364 
6365     If mouse tracking is disabled (the default), the widget only
6366     receives mouse move events when at least one mouse button is
6367     pressed while the mouse is being moved.
6368 
6369     If mouse tracking is enabled, the widget receives mouse move
6370     events even if no buttons are pressed.
6371 
6372     \sa mouseMoveEvent()
6373 */
6374 
6375 /*!
6376     \property QWidget::tabletTracking
6377     \brief whether tablet tracking is enabled for the widget
6378     \since 5.9
6379 
6380     If tablet tracking is disabled (the default), the widget only
6381     receives tablet move events when the stylus is in contact with
6382     the tablet, or at least one stylus button is pressed,
6383     while the stylus is being moved.
6384 
6385     If tablet tracking is enabled, the widget receives tablet move
6386     events even while hovering in proximity.  This is useful for
6387     monitoring position as well as the auxiliary properties such
6388     as rotation and tilt, and providing feedback in the UI.
6389 
6390     \sa tabletEvent()
6391 */
6392 
6393 
6394 /*!
6395     Sets the widget's focus proxy to widget \a w. If \a w is 0, the
6396     function resets this widget to have no focus proxy.
6397 
6398     Some widgets can "have focus", but create a child widget, such as
6399     QLineEdit, to actually handle the focus. In this case, the widget
6400     can set the line edit to be its focus proxy.
6401 
6402     setFocusProxy() sets the widget which will actually get focus when
6403     "this widget" gets it. If there is a focus proxy, setFocus() and
6404     hasFocus() operate on the focus proxy.
6405 
6406     \sa focusProxy()
6407 */
6408 
6409 void QWidget::setFocusProxy(QWidget * w)
6410 {
6411     Q_D(QWidget);
6412     if (!w && !d->extra)
6413         return;
6414 
6415     for (QWidget* fp  = w; fp; fp = fp->focusProxy()) {
6416         if (Q_UNLIKELY(fp == this)) {
6417             qWarning("QWidget: %s (%s) already in focus proxy chain", metaObject()->className(), objectName().toLocal8Bit().constData());
6418             return;
6419         }
6420     }
6421 
6422     d->createExtra();
6423     d->extra->focus_proxy = w;
6424 }
6425 
6426 
6427 /*!
6428     Returns the focus proxy, or 0 if there is no focus proxy.
6429 
6430     \sa setFocusProxy()
6431 */
6432 
6433 QWidget * QWidget::focusProxy() const
6434 {
6435     Q_D(const QWidget);
6436     return d->extra ? (QWidget *)d->extra->focus_proxy : 0;
6437 }
6438 
6439 
6440 /*!
6441     \property QWidget::focus
6442     \brief whether this widget (or its focus proxy) has the keyboard
6443     input focus
6444 
6445     By default, this property is \c false.
6446 
6447     \note Obtaining the value of this property for a widget is effectively equivalent
6448     to checking whether QApplication::focusWidget() refers to the widget.
6449 
6450     \sa setFocus(), clearFocus(), setFocusPolicy(), QApplication::focusWidget()
6451 */
6452 bool QWidget::hasFocus() const
6453 {
6454     const QWidget* w = this;
6455     while (w->d_func()->extra && w->d_func()->extra->focus_proxy)
6456         w = w->d_func()->extra->focus_proxy;
6457 #if QT_CONFIG(graphicsview)
6458     if (QWidget *window = w->window()) {
6459         QWExtra *e = window->d_func()->extra;
6460         if (e && e->proxyWidget && e->proxyWidget->hasFocus() && window->focusWidget() == w)
6461             return true;
6462     }
6463 #endif // QT_CONFIG(graphicsview)
6464     return (QApplication::focusWidget() == w);
6465 }
6466 
6467 /*!
6468     Gives the keyboard input focus to this widget (or its focus
6469     proxy) if this widget or one of its parents is the \l{isActiveWindow()}{active window}. The \a reason argument will
6470     be passed into any focus event sent from this function, it is used
6471     to give an explanation of what caused the widget to get focus.
6472     If the window is not active, the widget will be given the focus when
6473     the window becomes active.
6474 
6475     First, a focus about to change event is sent to the focus widget (if any) to
6476     tell it that it is about to lose the focus. Then focus is changed, a
6477     focus out event is sent to the previous focus item and a focus in event is sent
6478     to the new item to tell it that it just received the focus.
6479     (Nothing happens if the focus in and focus out widgets are the
6480     same.)
6481 
6482     \note On embedded platforms, setFocus() will not cause an input panel
6483     to be opened by the input method. If you want this to happen, you
6484     have to send a QEvent::RequestSoftwareInputPanel event to the
6485     widget yourself.
6486 
6487     setFocus() gives focus to a widget regardless of its focus policy,
6488     but does not clear any keyboard grab (see grabKeyboard()).
6489 
6490     Be aware that if the widget is hidden, it will not accept focus
6491     until it is shown.
6492 
6493     \warning If you call setFocus() in a function which may itself be
6494     called from focusOutEvent() or focusInEvent(), you may get an
6495     infinite recursion.
6496 
6497     \sa hasFocus(), clearFocus(), focusInEvent(), focusOutEvent(),
6498     setFocusPolicy(), focusWidget(), QApplication::focusWidget(), grabKeyboard(),
6499     grabMouse(), {Keyboard Focus in Widgets}, QEvent::RequestSoftwareInputPanel
6500 */
6501 
6502 void QWidget::setFocus(Qt::FocusReason reason)
6503 {
6504     if (!isEnabled())
6505         return;
6506 
6507     QWidget *f = d_func()->deepestFocusProxy();
6508     if (!f)
6509         f = this;
6510 
6511     if (QApplication::focusWidget() == f
6512 #if 0 // Used to be included in Qt4 for Q_WS_WIN
6513         && GetFocus() == f->internalWinId()
6514 #endif
6515        )
6516         return;
6517 
6518 #if QT_CONFIG(graphicsview)
6519     QWidget *previousProxyFocus = 0;
6520     if (QWExtra *topData = window()->d_func()->extra) {
6521         if (topData->proxyWidget && topData->proxyWidget->hasFocus()) {
6522             previousProxyFocus = topData->proxyWidget->widget()->focusWidget();
6523             if (previousProxyFocus && previousProxyFocus->focusProxy())
6524                 previousProxyFocus = previousProxyFocus->focusProxy();
6525             if (previousProxyFocus == this && !topData->proxyWidget->d_func()->proxyIsGivingFocus)
6526                 return;
6527         }
6528     }
6529 #endif
6530 
6531 #if QT_CONFIG(graphicsview)
6532     // Update proxy state
6533     if (QWExtra *topData = window()->d_func()->extra) {
6534         if (topData->proxyWidget && !topData->proxyWidget->hasFocus()) {
6535             f->d_func()->updateFocusChild();
6536             topData->proxyWidget->d_func()->focusFromWidgetToProxy = 1;
6537             topData->proxyWidget->setFocus(reason);
6538             topData->proxyWidget->d_func()->focusFromWidgetToProxy = 0;
6539         }
6540     }
6541 #endif
6542 
6543     if (f->isActiveWindow()) {
6544         QWidget *prev = QApplicationPrivate::focus_widget;
6545         if (prev) {
6546             if (reason != Qt::PopupFocusReason && reason != Qt::MenuBarFocusReason
6547                 && prev->testAttribute(Qt::WA_InputMethodEnabled)) {
6548                 QGuiApplication::inputMethod()->commit();
6549             }
6550 
6551             if (reason != Qt::NoFocusReason) {
6552                 QFocusEvent focusAboutToChange(QEvent::FocusAboutToChange, reason);
6553                 QApplication::sendEvent(prev, &focusAboutToChange);
6554             }
6555         }
6556 
6557         f->d_func()->updateFocusChild();
6558 
6559         QApplicationPrivate::setFocusWidget(f, reason);
6560 #ifndef QT_NO_ACCESSIBILITY
6561 # ifdef Q_OS_WIN
6562         // The negation of the condition in setFocus_sys
6563         if (!(testAttribute(Qt::WA_WState_Created) && window()->windowType() != Qt::Popup && internalWinId()))
6564             //setFocusWidget will already post a focus event for us (that the AT client receives) on Windows
6565 # endif
6566         // menus update the focus manually and this would create bogus events
6567         if (!(f->inherits("QMenuBar") || f->inherits("QMenu") || f->inherits("QMenuItem")))
6568         {
6569             QAccessibleEvent event(f, QAccessible::Focus);
6570             QAccessible::updateAccessibility(&event);
6571         }
6572 #endif
6573 #if QT_CONFIG(graphicsview)
6574         if (QWExtra *topData = window()->d_func()->extra) {
6575             if (topData->proxyWidget) {
6576                 if (previousProxyFocus && previousProxyFocus != f) {
6577                     // Send event to self
6578                     QFocusEvent event(QEvent::FocusOut, reason);
6579                     QPointer<QWidget> that = previousProxyFocus;
6580                     QApplication::sendEvent(previousProxyFocus, &event);
6581                     if (that)
6582                         QApplication::sendEvent(that->style(), &event);
6583                 }
6584                 if (!isHidden()) {
6585 #if QT_CONFIG(graphicsview)
6586                     // Update proxy state
6587                     if (QWExtra *topData = window()->d_func()->extra)
6588                         if (topData->proxyWidget && topData->proxyWidget->hasFocus())
6589                             topData->proxyWidget->d_func()->updateProxyInputMethodAcceptanceFromWidget();
6590 #endif
6591                     // Send event to self
6592                     QFocusEvent event(QEvent::FocusIn, reason);
6593                     QPointer<QWidget> that = f;
6594                     QApplication::sendEvent(f, &event);
6595                     if (that)
6596                         QApplication::sendEvent(that->style(), &event);
6597                 }
6598             }
6599         }
6600 #endif
6601     } else {
6602         f->d_func()->updateFocusChild();
6603     }
6604 }
6605 
6606 
6607 /*!\internal
6608  * A focus proxy can have its own focus proxy, which can have its own
6609  * proxy, and so on. This helper function returns the widget that sits
6610  * at the bottom of the proxy chain, and therefore the one that should
6611  * normally get focus if this widget receives a focus request.
6612  */
6613 QWidget *QWidgetPrivate::deepestFocusProxy() const
6614 {
6615     Q_Q(const QWidget);
6616 
6617     QWidget *focusProxy = q->focusProxy();
6618     if (!focusProxy)
6619         return nullptr;
6620 
6621     while (QWidget *nextFocusProxy = focusProxy->focusProxy())
6622         focusProxy = nextFocusProxy;
6623 
6624     return focusProxy;
6625 }
6626 
6627 void QWidgetPrivate::setFocus_sys()
6628 {
6629     Q_Q(QWidget);
6630     // Embedded native widget may have taken the focus; get it back to toplevel if that is the case
6631     const QWidget *topLevel = q->window();
6632     if (topLevel->windowType() != Qt::Popup) {
6633         if (QWindow *nativeWindow = q->window()->windowHandle()) {
6634             if (nativeWindow != QGuiApplication::focusWindow()
6635                 && q->testAttribute(Qt::WA_WState_Created)) {
6636                 nativeWindow->requestActivate();
6637             }
6638         }
6639     }
6640 }
6641 
6642 // updates focus_child on parent widgets to point into this widget
6643 void QWidgetPrivate::updateFocusChild()
6644 {
6645     Q_Q(QWidget);
6646 
6647     QWidget *w = q;
6648     if (q->isHidden()) {
6649         while (w && w->isHidden()) {
6650             w->d_func()->focus_child = q;
6651             w = w->isWindow() ? 0 : w->parentWidget();
6652         }
6653     } else {
6654         while (w) {
6655             w->d_func()->focus_child = q;
6656             w = w->isWindow() ? 0 : w->parentWidget();
6657         }
6658     }
6659 
6660     if (QTLWExtra *extra = q->window()->d_func()->maybeTopData()) {
6661         if (extra->window)
6662             emit extra->window->focusObjectChanged(q);
6663     }
6664 }
6665 
6666 /*!
6667     \fn void QWidget::setFocus()
6668     \overload
6669 
6670     Gives the keyboard input focus to this widget (or its focus
6671     proxy) if this widget or one of its parents is the
6672     \l{isActiveWindow()}{active window}.
6673 */
6674 
6675 /*!
6676     Takes keyboard input focus from the widget.
6677 
6678     If the widget has active focus, a \l{focusOutEvent()}{focus out event} is sent to this widget to tell it that it has
6679     lost the focus.
6680 
6681     This widget must enable focus setting in order to get the keyboard
6682     input focus, i.e. it must call setFocusPolicy().
6683 
6684     \sa hasFocus(), setFocus(), focusInEvent(), focusOutEvent(),
6685     setFocusPolicy(), QApplication::focusWidget()
6686 */
6687 
6688 void QWidget::clearFocus()
6689 {
6690     if (hasFocus()) {
6691         if (testAttribute(Qt::WA_InputMethodEnabled))
6692             QGuiApplication::inputMethod()->commit();
6693 
6694         QFocusEvent focusAboutToChange(QEvent::FocusAboutToChange);
6695         QApplication::sendEvent(this, &focusAboutToChange);
6696     }
6697 
6698     QWidget *w = this;
6699     while (w) {
6700         // Just like setFocus(), we update (clear) the focus_child of our parents
6701         if (w->d_func()->focus_child == this)
6702             w->d_func()->focus_child = 0;
6703         w = w->parentWidget();
6704     }
6705 
6706     // Since we've unconditionally cleared the focus_child of our parents, we need
6707     // to report this to the rest of Qt. Note that the focus_child is not the same
6708     // thing as the application's focusWidget, which is why this piece of code is
6709     // not inside the hasFocus() block below.
6710     if (QTLWExtra *extra = window()->d_func()->maybeTopData()) {
6711         if (extra->window)
6712             emit extra->window->focusObjectChanged(extra->window->focusObject());
6713     }
6714 
6715 #if QT_CONFIG(graphicsview)
6716     QWExtra *topData = d_func()->extra;
6717     if (topData && topData->proxyWidget)
6718         topData->proxyWidget->clearFocus();
6719 #endif
6720 
6721     if (hasFocus()) {
6722         // Update proxy state
6723         QApplicationPrivate::setFocusWidget(0, Qt::OtherFocusReason);
6724 #if 0 // Used to be included in Qt4 for Q_WS_WIN
6725         if (!(windowType() == Qt::Popup) && GetFocus() == internalWinId())
6726             SetFocus(0);
6727         else
6728 #endif
6729         {
6730 #ifndef QT_NO_ACCESSIBILITY
6731             QAccessibleEvent event(this, QAccessible::Focus);
6732             QAccessible::updateAccessibility(&event);
6733 #endif
6734         }
6735     }
6736 }
6737 
6738 
6739 /*!
6740     \fn bool QWidget::focusNextChild()
6741 
6742     Finds a new widget to give the keyboard focus to, as appropriate
6743     for \uicontrol Tab, and returns \c true if it can find a new widget, or
6744     false if it can't.
6745 
6746     \sa focusPreviousChild()
6747 */
6748 
6749 /*!
6750     \fn bool QWidget::focusPreviousChild()
6751 
6752     Finds a new widget to give the keyboard focus to, as appropriate
6753     for \uicontrol Shift+Tab, and returns \c true if it can find a new widget,
6754     or false if it can't.
6755 
6756     \sa focusNextChild()
6757 */
6758 
6759 /*!
6760     Finds a new widget to give the keyboard focus to, as appropriate
6761     for Tab and Shift+Tab, and returns \c true if it can find a new
6762     widget, or false if it can't.
6763 
6764     If \a next is true, this function searches forward, if \a next
6765     is false, it searches backward.
6766 
6767     Sometimes, you will want to reimplement this function. For
6768     example, a web browser might reimplement it to move its "current
6769     active link" forward or backward, and call
6770     focusNextPrevChild() only when it reaches the last or
6771     first link on the "page".
6772 
6773     Child widgets call focusNextPrevChild() on their parent widgets,
6774     but only the window that contains the child widgets decides where
6775     to redirect focus. By reimplementing this function for an object,
6776     you thus gain control of focus traversal for all child widgets.
6777 
6778     \sa focusNextChild(), focusPreviousChild()
6779 */
6780 
6781 bool QWidget::focusNextPrevChild(bool next)
6782 {
6783     QWidget* p = parentWidget();
6784     bool isSubWindow = (windowType() == Qt::SubWindow);
6785     if (!isWindow() && !isSubWindow && p)
6786         return p->focusNextPrevChild(next);
6787 #if QT_CONFIG(graphicsview)
6788     Q_D(QWidget);
6789     if (d->extra && d->extra->proxyWidget)
6790         return d->extra->proxyWidget->focusNextPrevChild(next);
6791 #endif
6792 
6793     bool wrappingOccurred = false;
6794     QWidget *w = QApplicationPrivate::focusNextPrevChild_helper(this, next,
6795                                                                 &wrappingOccurred);
6796     if (!w) return false;
6797 
6798     Qt::FocusReason reason = next ? Qt::TabFocusReason : Qt::BacktabFocusReason;
6799 
6800     /* If we are about to wrap the focus chain, give the platform
6801      * implementation a chance to alter the wrapping behavior.  This is
6802      * especially needed when the window is embedded in a window created by
6803      * another process.
6804      */
6805     if (wrappingOccurred) {
6806         QWindow *window = windowHandle();
6807         if (window != 0) {
6808             QWindowPrivate *winp = qt_window_private(window);
6809 
6810             if (winp->platformWindow != 0) {
6811                 QFocusEvent event(QEvent::FocusIn, reason);
6812                 event.ignore();
6813                 winp->platformWindow->windowEvent(&event);
6814                 if (event.isAccepted()) return true;
6815             }
6816         }
6817     }
6818 
6819     w->setFocus(reason);
6820     return true;
6821 }
6822 
6823 /*!
6824     Returns the last child of this widget that setFocus had been
6825     called on.  For top level widgets this is the widget that will get
6826     focus in case this window gets activated
6827 
6828     This is not the same as QApplication::focusWidget(), which returns
6829     the focus widget in the currently active window.
6830 */
6831 
6832 QWidget *QWidget::focusWidget() const
6833 {
6834     return const_cast<QWidget *>(d_func()->focus_child);
6835 }
6836 
6837 /*!
6838     Returns the next widget in this widget's focus chain.
6839 
6840     \sa previousInFocusChain()
6841 */
6842 QWidget *QWidget::nextInFocusChain() const
6843 {
6844     return const_cast<QWidget *>(d_func()->focus_next);
6845 }
6846 
6847 /*!
6848     \brief The previousInFocusChain function returns the previous
6849     widget in this widget's focus chain.
6850 
6851     \sa nextInFocusChain()
6852 
6853     \since 4.6
6854 */
6855 QWidget *QWidget::previousInFocusChain() const
6856 {
6857     return const_cast<QWidget *>(d_func()->focus_prev);
6858 }
6859 
6860 /*!
6861     \property QWidget::isActiveWindow
6862     \brief whether this widget's window is the active window
6863 
6864     The active window is the window that contains the widget that has
6865     keyboard focus (The window may still have focus if it has no
6866     widgets or none of its widgets accepts keyboard focus).
6867 
6868     When popup windows are visible, this property is \c true for both the
6869     active window \e and for the popup.
6870 
6871     By default, this property is \c false.
6872 
6873     \sa activateWindow(), QApplication::activeWindow()
6874 */
6875 bool QWidget::isActiveWindow() const
6876 {
6877     QWidget *tlw = window();
6878     if(tlw == QApplication::activeWindow() || (isVisible() && (tlw->windowType() == Qt::Popup)))
6879         return true;
6880 
6881 #if QT_CONFIG(graphicsview)
6882     if (QWExtra *tlwExtra = tlw->d_func()->extra) {
6883         if (isVisible() && tlwExtra->proxyWidget)
6884             return tlwExtra->proxyWidget->isActiveWindow();
6885     }
6886 #endif
6887 
6888     if(style()->styleHint(QStyle::SH_Widget_ShareActivation, 0, this)) {
6889         if(tlw->windowType() == Qt::Tool &&
6890            !tlw->isModal() &&
6891            (!tlw->parentWidget() || tlw->parentWidget()->isActiveWindow()))
6892            return true;
6893         QWidget *w = QApplication::activeWindow();
6894         while(w && tlw->windowType() == Qt::Tool &&
6895               !w->isModal() && w->parentWidget()) {
6896             w = w->parentWidget()->window();
6897             if(w == tlw)
6898                 return true;
6899         }
6900     }
6901 
6902     // Check for an active window container
6903     if (QWindow *ww = QGuiApplication::focusWindow()) {
6904         while (ww) {
6905             QWidgetWindow *qww = qobject_cast<QWidgetWindow *>(ww);
6906             QWindowContainer *qwc = qww ? qobject_cast<QWindowContainer *>(qww->widget()) : 0;
6907             if (qwc && qwc->topLevelWidget() == tlw)
6908                 return true;
6909             ww = ww->parent();
6910         }
6911     }
6912 
6913     // Check if platform adaptation thinks the window is active. This is necessary for
6914     // example in case of ActiveQt servers that are embedded into another application.
6915     // Those are separate processes that are not part of the parent application Qt window/widget
6916     // hierarchy, so they need to rely on native methods to determine if they are part of the
6917     // active window.
6918     if (const QWindow *w = tlw->windowHandle()) {
6919         if (w->handle())
6920             return w->handle()->isActive();
6921     }
6922 
6923     return false;
6924 }
6925 
6926 /*!
6927     Puts the \a second widget after the \a first widget in the focus order.
6928 
6929     It effectively removes the \a second widget from its focus chain and
6930     inserts it after the \a first widget.
6931 
6932     Note that since the tab order of the \a second widget is changed, you
6933     should order a chain like this:
6934 
6935     \snippet code/src_gui_kernel_qwidget.cpp 9
6936 
6937     \e not like this:
6938 
6939     \snippet code/src_gui_kernel_qwidget.cpp 10
6940 
6941     If \a first or \a second has a focus proxy, setTabOrder()
6942     correctly substitutes the proxy.
6943 
6944     \note Since Qt 5.10: A widget that has a child as focus proxy is understood as
6945     a compound widget. When setting a tab order between one or two compound widgets, the
6946     local tab order inside each will be preserved. This means that if both widgets are
6947     compound widgets, the resulting tab order will be from the last child inside
6948     \a first, to the first child inside \a second.
6949 
6950     \sa setFocusPolicy(), setFocusProxy(), {Keyboard Focus in Widgets}
6951 */
6952 void QWidget::setTabOrder(QWidget* first, QWidget *second)
6953 {
6954     if (!first || !second || first == second
6955             || first->focusPolicy() == Qt::NoFocus
6956             || second->focusPolicy() == Qt::NoFocus)
6957         return;
6958 
6959     if (Q_UNLIKELY(first->window() != second->window())) {
6960         qWarning("QWidget::setTabOrder: 'first' and 'second' must be in the same window");
6961         return;
6962     }
6963 
6964     auto determineLastFocusChild = [](QWidget *target, QWidget *&lastFocusChild)
6965     {
6966         // Since we need to repeat the same logic for both 'first' and 'second', we add a function that
6967         // determines the last focus child for a widget, taking proxies and compound widgets into account.
6968         // If the target is not a compound widget (it doesn't have a focus proxy that points to a child),
6969         // 'lastFocusChild' will be set to the target itself.
6970         lastFocusChild = target;
6971 
6972         QWidget *focusProxy = target->d_func()->deepestFocusProxy();
6973         if (!focusProxy || !target->isAncestorOf(focusProxy))
6974             return;
6975 
6976         lastFocusChild = focusProxy;
6977 
6978         for (QWidget *focusNext = lastFocusChild->d_func()->focus_next;
6979              focusNext != focusProxy && target->isAncestorOf(focusNext) && focusNext->window() == focusProxy->window();
6980              focusNext = focusNext->d_func()->focus_next) {
6981             if (focusNext->focusPolicy() != Qt::NoFocus)
6982                 lastFocusChild = focusNext;
6983         }
6984     };
6985 
6986     QWidget *lastFocusChildOfFirst, *lastFocusChildOfSecond;
6987     determineLastFocusChild(first, lastFocusChildOfFirst);
6988     determineLastFocusChild(second, lastFocusChildOfSecond);
6989 
6990     // If the tab order is already correct, exit early
6991     if (lastFocusChildOfFirst->d_func()->focus_next == second)
6992         return;
6993 
6994     // Note that we need to handle two different sections in the tab chain; The section
6995     // that 'first' belongs to (firstSection), where we are about to insert 'second', and
6996     // the section that 'second' used be a part of (secondSection). When we pull 'second'
6997     // out of the second section and insert it into the first, we also need to ensure
6998     // that we leave the second section in a connected state.
6999     QWidget *firstChainOldSecond = lastFocusChildOfFirst->d_func()->focus_next;
7000     QWidget *secondChainNewFirst = second->d_func()->focus_prev;
7001     QWidget *secondChainNewSecond = lastFocusChildOfSecond->d_func()->focus_next;
7002 
7003     // Insert 'second' after 'first'
7004     lastFocusChildOfFirst->d_func()->focus_next = second;
7005     second->d_func()->focus_prev = lastFocusChildOfFirst;
7006 
7007     // The widget that used to be 'second' in the first section, should now become 'third'
7008     lastFocusChildOfSecond->d_func()->focus_next = firstChainOldSecond;
7009     firstChainOldSecond->d_func()->focus_prev = lastFocusChildOfSecond;
7010 
7011     // Repair the second section after we pulled 'second' out of it
7012     secondChainNewFirst->d_func()->focus_next = secondChainNewSecond;
7013     secondChainNewSecond->d_func()->focus_prev = secondChainNewFirst;
7014 }
7015 
7016 /*!\internal
7017 
7018   Moves the relevant subwidgets of this widget from the \a oldtlw's
7019   tab chain to that of the new parent, if there's anything to move and
7020   we're really moving
7021 
7022   This function is called from QWidget::reparent() *after* the widget
7023   has been reparented.
7024 
7025   \sa reparent()
7026 */
7027 
7028 void QWidgetPrivate::reparentFocusWidgets(QWidget * oldtlw)
7029 {
7030     Q_Q(QWidget);
7031     if (oldtlw == q->window())
7032         return; // nothing to do
7033 
7034     if(focus_child)
7035         focus_child->clearFocus();
7036 
7037     // separate the focus chain into new (children of myself) and old (the rest)
7038     QWidget *firstOld = 0;
7039     //QWidget *firstNew = q; //invariant
7040     QWidget *o = 0; // last in the old list
7041     QWidget *n = q; // last in the new list
7042 
7043     bool prevWasNew = true;
7044     QWidget *w = focus_next;
7045 
7046     //Note: for efficiency, we do not maintain the list invariant inside the loop
7047     //we append items to the relevant list, and we optimize by not changing pointers
7048     //when subsequent items are going into the same list.
7049     while (w  != q) {
7050         bool currentIsNew =  q->isAncestorOf(w);
7051         if (currentIsNew) {
7052             if (!prevWasNew) {
7053                 //prev was old -- append to new list
7054                 n->d_func()->focus_next = w;
7055                 w->d_func()->focus_prev = n;
7056             }
7057             n = w;
7058         } else {
7059             if (prevWasNew) {
7060                 //prev was new -- append to old list, if there is one
7061                 if (o) {
7062                     o->d_func()->focus_next = w;
7063                     w->d_func()->focus_prev = o;
7064                 } else {
7065                     // "create" the old list
7066                     firstOld = w;
7067                 }
7068             }
7069             o = w;
7070         }
7071         w = w->d_func()->focus_next;
7072         prevWasNew = currentIsNew;
7073     }
7074 
7075     //repair the old list:
7076     if (firstOld) {
7077         o->d_func()->focus_next = firstOld;
7078         firstOld->d_func()->focus_prev = o;
7079     }
7080 
7081     if (!q->isWindow()) {
7082         QWidget *topLevel = q->window();
7083         //insert new chain into toplevel's chain
7084 
7085         QWidget *prev = topLevel->d_func()->focus_prev;
7086 
7087         topLevel->d_func()->focus_prev = n;
7088         prev->d_func()->focus_next = q;
7089 
7090         focus_prev = prev;
7091         n->d_func()->focus_next = topLevel;
7092     } else {
7093         //repair the new list
7094             n->d_func()->focus_next = q;
7095             focus_prev = n;
7096     }
7097 
7098 }
7099 
7100 /*!\internal
7101 
7102   Measures the shortest distance from a point to a rect.
7103 
7104   This function is called from QDesktopwidget::screen(QPoint) to find the
7105   closest screen for a point.
7106   In directional KeypadNavigation, it is called to find the closest
7107   widget to the current focus widget center.
7108 */
7109 int QWidgetPrivate::pointToRect(const QPoint &p, const QRect &r)
7110 {
7111     int dx = 0;
7112     int dy = 0;
7113     if (p.x() < r.left())
7114         dx = r.left() - p.x();
7115     else if (p.x() > r.right())
7116         dx = p.x() - r.right();
7117     if (p.y() < r.top())
7118         dy = r.top() - p.y();
7119     else if (p.y() > r.bottom())
7120         dy = p.y() - r.bottom();
7121     return dx + dy;
7122 }
7123 
7124 /*!
7125     \property QWidget::frameSize
7126     \brief the size of the widget including any window frame
7127 
7128     By default, this property contains a value that depends on the user's
7129     platform and screen geometry.
7130 */
7131 QSize QWidget::frameSize() const
7132 {
7133     Q_D(const QWidget);
7134     if (isWindow() && !(windowType() == Qt::Popup)) {
7135         QRect fs = d->frameStrut();
7136         return QSize(data->crect.width() + fs.left() + fs.right(),
7137                       data->crect.height() + fs.top() + fs.bottom());
7138     }
7139     return data->crect.size();
7140 }
7141 
7142 /*! \fn void QWidget::move(int x, int y)
7143 
7144     \overload
7145 
7146     This corresponds to move(QPoint(\a x, \a y)).
7147 */
7148 
7149 void QWidget::move(const QPoint &p)
7150 {
7151     Q_D(QWidget);
7152     setAttribute(Qt::WA_Moved);
7153     if (testAttribute(Qt::WA_WState_Created)) {
7154         if (isWindow())
7155             d->topData()->posIncludesFrame = false;
7156         d->setGeometry_sys(p.x() + geometry().x() - QWidget::x(),
7157                        p.y() + geometry().y() - QWidget::y(),
7158                        width(), height(), true);
7159         d->setDirtyOpaqueRegion();
7160     } else {
7161         // no frame yet: see also QWidgetPrivate::fixPosIncludesFrame(), QWindowPrivate::PositionPolicy.
7162         if (isWindow())
7163             d->topData()->posIncludesFrame = true;
7164         data->crect.moveTopLeft(p); // no frame yet
7165         setAttribute(Qt::WA_PendingMoveEvent);
7166     }
7167 
7168     if (d->extra && d->extra->hasWindowContainer)
7169         QWindowContainer::parentWasMoved(this);
7170 }
7171 
7172 // move() was invoked with Qt::WA_WState_Created not set (frame geometry
7173 // unknown), that is, crect has a position including the frame.
7174 // If we can determine the frame strut, fix that and clear the flag.
7175 void QWidgetPrivate::fixPosIncludesFrame()
7176 {
7177     Q_Q(QWidget);
7178     if (QTLWExtra *te = maybeTopData()) {
7179         if (te->posIncludesFrame) {
7180             // For Qt::WA_DontShowOnScreen, assume a frame of 0 (for
7181             // example, in QGraphicsProxyWidget).
7182             if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
7183                 te->posIncludesFrame = 0;
7184             } else {
7185                 if (q->windowHandle() && q->windowHandle()->handle()) {
7186                     updateFrameStrut();
7187                     if (!q->data->fstrut_dirty) {
7188                         data.crect.translate(te->frameStrut.x(), te->frameStrut.y());
7189                         te->posIncludesFrame = 0;
7190                     }
7191                 } // windowHandle()
7192             } // !WA_DontShowOnScreen
7193         } // posIncludesFrame
7194     } // QTLWExtra
7195 }
7196 
7197 /*! \fn void QWidget::resize(int w, int h)
7198     \overload
7199 
7200     This corresponds to resize(QSize(\a w, \a h)).
7201 */
7202 
7203 void QWidget::resize(const QSize &s)
7204 {
7205     Q_D(QWidget);
7206     setAttribute(Qt::WA_Resized);
7207     if (testAttribute(Qt::WA_WState_Created)) {
7208         d->fixPosIncludesFrame();
7209         d->setGeometry_sys(geometry().x(), geometry().y(), s.width(), s.height(), false);
7210         d->setDirtyOpaqueRegion();
7211     } else {
7212         data->crect.setSize(s.boundedTo(maximumSize()).expandedTo(minimumSize()));
7213         setAttribute(Qt::WA_PendingResizeEvent);
7214     }
7215 }
7216 
7217 void QWidget::setGeometry(const QRect &r)
7218 {
7219     Q_D(QWidget);
7220     setAttribute(Qt::WA_Resized);
7221     setAttribute(Qt::WA_Moved);
7222     if (isWindow())
7223         d->topData()->posIncludesFrame = 0;
7224     if (testAttribute(Qt::WA_WState_Created)) {
7225         d->setGeometry_sys(r.x(), r.y(), r.width(), r.height(), true);
7226         d->setDirtyOpaqueRegion();
7227     } else {
7228         data->crect.setTopLeft(r.topLeft());
7229         data->crect.setSize(r.size().boundedTo(maximumSize()).expandedTo(minimumSize()));
7230         setAttribute(Qt::WA_PendingMoveEvent);
7231         setAttribute(Qt::WA_PendingResizeEvent);
7232     }
7233 
7234     if (d->extra && d->extra->hasWindowContainer)
7235         QWindowContainer::parentWasMoved(this);
7236 }
7237 
7238 void QWidgetPrivate::setGeometry_sys(int x, int y, int w, int h, bool isMove)
7239 {
7240     Q_Q(QWidget);
7241     if (extra) {                                // any size restrictions?
7242         w = qMin(w,extra->maxw);
7243         h = qMin(h,extra->maxh);
7244         w = qMax(w,extra->minw);
7245         h = qMax(h,extra->minh);
7246     }
7247 
7248     if (q->isWindow() && q->windowHandle()) {
7249         QPlatformIntegration *integration = QGuiApplicationPrivate::platformIntegration();
7250         if (!integration->hasCapability(QPlatformIntegration::NonFullScreenWindows)) {
7251             x = 0;
7252             y = 0;
7253             w = q->windowHandle()->width();
7254             h = q->windowHandle()->height();
7255         }
7256     }
7257 
7258     QPoint oldp = q->geometry().topLeft();
7259     QSize olds = q->size();
7260     QRect r(x, y, w, h);
7261 
7262     bool isResize = olds != r.size();
7263     if (!isMove)
7264         isMove = oldp != r.topLeft();
7265 
7266 
7267     // We only care about stuff that changes the geometry, or may
7268     // cause the window manager to change its state
7269     if (r.size() == olds && oldp == r.topLeft())
7270         return;
7271 
7272     if (!data.in_set_window_state) {
7273         q->data->window_state &= ~Qt::WindowMaximized;
7274         q->data->window_state &= ~Qt::WindowFullScreen;
7275         if (q->isWindow())
7276             topData()->normalGeometry = QRect(0, 0, -1, -1);
7277     }
7278 
7279     QPoint oldPos = q->pos();
7280     data.crect = r;
7281 
7282     bool needsShow = false;
7283 
7284     if (q->isWindow() || q->windowHandle()) {
7285         if (!(data.window_state & Qt::WindowFullScreen) && (w == 0 || h == 0)) {
7286             q->setAttribute(Qt::WA_OutsideWSRange, true);
7287             if (q->isVisible())
7288                 hide_sys();
7289             data.crect = QRect(x, y, w, h);
7290         } else if (q->testAttribute(Qt::WA_OutsideWSRange)) {
7291             q->setAttribute(Qt::WA_OutsideWSRange, false);
7292             needsShow = true;
7293         }
7294     }
7295 
7296     if (q->isVisible()) {
7297         if (!q->testAttribute(Qt::WA_DontShowOnScreen) && !q->testAttribute(Qt::WA_OutsideWSRange)) {
7298             if (QWindow *win = q->windowHandle()) {
7299                 if (q->isWindow()) {
7300                     if (isResize && !isMove)
7301                         win->resize(w, h);
7302                     else if (isMove && !isResize)
7303                         win->setPosition(x, y);
7304                     else
7305                         win->setGeometry(q->geometry());
7306                 } else {
7307                     QPoint posInNativeParent =  q->mapTo(q->nativeParentWidget(),QPoint());
7308                     win->setGeometry(QRect(posInNativeParent,r.size()));
7309                 }
7310 
7311                 if (needsShow)
7312                     show_sys();
7313             }
7314 
7315             if (!q->isWindow()) {
7316                 if (renderToTexture) {
7317                     QRegion updateRegion(q->geometry());
7318                     updateRegion += QRect(oldPos, olds);
7319                     q->parentWidget()->d_func()->invalidateBuffer(updateRegion);
7320                 } else if (isMove && !isResize) {
7321                     moveRect(QRect(oldPos, olds), x - oldPos.x(), y - oldPos.y());
7322                 } else {
7323                     invalidateBuffer_resizeHelper(oldPos, olds);
7324                 }
7325             }
7326         }
7327 
7328         if (isMove) {
7329             QMoveEvent e(q->pos(), oldPos);
7330             QApplication::sendEvent(q, &e);
7331         }
7332         if (isResize) {
7333             QResizeEvent e(r.size(), olds);
7334             QApplication::sendEvent(q, &e);
7335             if (q->windowHandle())
7336                 q->update();
7337         }
7338     } else { // not visible
7339         if (isMove && q->pos() != oldPos)
7340             q->setAttribute(Qt::WA_PendingMoveEvent, true);
7341         if (isResize)
7342             q->setAttribute(Qt::WA_PendingResizeEvent, true);
7343     }
7344 
7345 }
7346 
7347 /*!
7348     \since 4.2
7349     Saves the current geometry and state for top-level widgets.
7350 
7351     To save the geometry when the window closes, you can
7352     implement a close event like this:
7353 
7354     \snippet code/src_gui_kernel_qwidget.cpp 11
7355 
7356     See the \l{Window Geometry} documentation for an overview of geometry
7357     issues with windows.
7358 
7359     Use QMainWindow::saveState() to save the geometry and the state of
7360     toolbars and dock widgets.
7361 
7362     \sa restoreGeometry(), QMainWindow::saveState(), QMainWindow::restoreState()
7363 */
7364 QByteArray QWidget::saveGeometry() const
7365 {
7366 #if 0 // Used to be included in Qt4 for Q_WS_MAC
7367     // We check if the window was maximized during this invocation. If so, we need to record the
7368     // starting position as 0,0.
7369     Q_D(const QWidget);
7370     QRect newFramePosition = frameGeometry();
7371     QRect newNormalPosition = normalGeometry();
7372     if(d->topData()->wasMaximized && !(windowState() & Qt::WindowMaximized)) {
7373         // Change the starting position
7374         newFramePosition.moveTo(0, 0);
7375         newNormalPosition.moveTo(0, 0);
7376     }
7377 #endif
7378     QByteArray array;
7379     QDataStream stream(&array, QIODevice::WriteOnly);
7380     stream.setVersion(QDataStream::Qt_4_0);
7381     const quint32 magicNumber = 0x1D9D0CB;
7382     // Version history:
7383     // - Qt 4.2 - 4.8.6, 5.0 - 5.3    : Version 1.0
7384     // - Qt 4.8.6 - today, 5.4 - today: Version 2.0, save screen width in addition to check for high DPI scaling.
7385     quint16 majorVersion = 2;
7386     quint16 minorVersion = 0;
7387     const int screenNumber = QDesktopWidgetPrivate::screenNumber(this);
7388     stream << magicNumber
7389            << majorVersion
7390            << minorVersion
7391 #if 0 // Used to be included in Qt4 for Q_WS_MAC
7392            << newFramePosition
7393            << newNormalPosition
7394 #else
7395            << frameGeometry()
7396            << normalGeometry()
7397 #endif
7398            << qint32(screenNumber)
7399            << quint8(windowState() & Qt::WindowMaximized)
7400            << quint8(windowState() & Qt::WindowFullScreen)
7401            << qint32(QDesktopWidgetPrivate::screenGeometry(screenNumber).width()); // 1.1 onwards
7402     return array;
7403 }
7404 
7405 /*!
7406     \since 4.2
7407 
7408     Restores the geometry and state of top-level widgets stored in the
7409     byte array \a geometry. Returns \c true on success; otherwise
7410     returns \c false.
7411 
7412     If the restored geometry is off-screen, it will be modified to be
7413     inside the available screen geometry.
7414 
7415     To restore geometry saved using QSettings, you can use code like
7416     this:
7417 
7418     \snippet code/src_gui_kernel_qwidget.cpp 12
7419 
7420     See the \l{Window Geometry} documentation for an overview of geometry
7421     issues with windows.
7422 
7423     Use QMainWindow::restoreState() to restore the geometry and the
7424     state of toolbars and dock widgets.
7425 
7426     \sa saveGeometry(), QSettings, QMainWindow::saveState(), QMainWindow::restoreState()
7427 */
7428 bool QWidget::restoreGeometry(const QByteArray &geometry)
7429 {
7430     if (geometry.size() < 4)
7431         return false;
7432     QDataStream stream(geometry);
7433     stream.setVersion(QDataStream::Qt_4_0);
7434 
7435     const quint32 magicNumber = 0x1D9D0CB;
7436     quint32 storedMagicNumber;
7437     stream >> storedMagicNumber;
7438     if (storedMagicNumber != magicNumber)
7439         return false;
7440 
7441     const quint16 currentMajorVersion = 2;
7442     quint16 majorVersion = 0;
7443     quint16 minorVersion = 0;
7444 
7445     stream >> majorVersion >> minorVersion;
7446 
7447     if (majorVersion > currentMajorVersion)
7448         return false;
7449     // (Allow all minor versions.)
7450 
7451     QRect restoredFrameGeometry;
7452      QRect restoredNormalGeometry;
7453     qint32 restoredScreenNumber;
7454     quint8 maximized;
7455     quint8 fullScreen;
7456     qint32 restoredScreenWidth = 0;
7457 
7458     stream >> restoredFrameGeometry
7459            >> restoredNormalGeometry
7460            >> restoredScreenNumber
7461            >> maximized
7462            >> fullScreen;
7463 
7464     if (majorVersion > 1)
7465         stream >> restoredScreenWidth;
7466 
7467     if (restoredScreenNumber >= QDesktopWidgetPrivate::numScreens())
7468         restoredScreenNumber = QDesktopWidgetPrivate::primaryScreen();
7469     const qreal screenWidthF = qreal(QDesktopWidgetPrivate::screenGeometry(restoredScreenNumber).width());
7470     // Sanity check bailing out when large variations of screen sizes occur due to
7471     // high DPI scaling or different levels of DPI awareness.
7472     if (restoredScreenWidth) {
7473         const qreal factor = qreal(restoredScreenWidth) / screenWidthF;
7474         if (factor < 0.8 || factor > 1.25)
7475             return false;
7476     } else {
7477         // Saved by Qt 5.3 and earlier, try to prevent too large windows
7478         // unless the size will be adapted by maximized or fullscreen.
7479         if (!maximized && !fullScreen && qreal(restoredFrameGeometry.width()) / screenWidthF > 1.5)
7480             return false;
7481     }
7482 
7483     const int frameHeight = 20;
7484     if (!restoredFrameGeometry.isValid())
7485         restoredFrameGeometry = QRect(QPoint(0,0), sizeHint());
7486 
7487     if (!restoredNormalGeometry.isValid())
7488         restoredNormalGeometry = QRect(QPoint(0, frameHeight), sizeHint());
7489     if (!restoredNormalGeometry.isValid()) {
7490         // use the widget's adjustedSize if the sizeHint() doesn't help
7491         restoredNormalGeometry.setSize(restoredNormalGeometry
7492                                        .size()
7493                                        .expandedTo(d_func()->adjustedSize()));
7494     }
7495 
7496     const QRect availableGeometry = QDesktopWidgetPrivate::availableGeometry(restoredScreenNumber);
7497 
7498     // Modify the restored geometry if we are about to restore to coordinates
7499     // that would make the window "lost". This happens if:
7500     // - The restored geometry is completely oustside the available geometry
7501     // - The title bar is outside the available geometry.
7502     // - (Mac only) The window is higher than the available geometry. It must
7503     //   be possible to bring the size grip on screen by moving the window.
7504 #if 0 // Used to be included in Qt4 for Q_WS_MAC
7505     restoredFrameGeometry.setHeight(qMin(restoredFrameGeometry.height(), availableGeometry.height()));
7506     restoredNormalGeometry.setHeight(qMin(restoredNormalGeometry.height(), availableGeometry.height() - frameHeight));
7507 #endif
7508 
7509     if (!restoredFrameGeometry.intersects(availableGeometry)) {
7510         restoredFrameGeometry.moveBottom(qMin(restoredFrameGeometry.bottom(), availableGeometry.bottom()));
7511         restoredFrameGeometry.moveLeft(qMax(restoredFrameGeometry.left(), availableGeometry.left()));
7512         restoredFrameGeometry.moveRight(qMin(restoredFrameGeometry.right(), availableGeometry.right()));
7513     }
7514     restoredFrameGeometry.moveTop(qMax(restoredFrameGeometry.top(), availableGeometry.top()));
7515 
7516     if (!restoredNormalGeometry.intersects(availableGeometry)) {
7517         restoredNormalGeometry.moveBottom(qMin(restoredNormalGeometry.bottom(), availableGeometry.bottom()));
7518         restoredNormalGeometry.moveLeft(qMax(restoredNormalGeometry.left(), availableGeometry.left()));
7519         restoredNormalGeometry.moveRight(qMin(restoredNormalGeometry.right(), availableGeometry.right()));
7520     }
7521     restoredNormalGeometry.moveTop(qMax(restoredNormalGeometry.top(), availableGeometry.top() + frameHeight));
7522 
7523     if (maximized || fullScreen) {
7524         // set geometry before setting the window state to make
7525         // sure the window is maximized to the right screen.
7526         Qt::WindowStates ws = windowState();
7527 #ifndef Q_OS_WIN
7528         setGeometry(restoredNormalGeometry);
7529 #else
7530         if (ws & Qt::WindowFullScreen) {
7531             // Full screen is not a real window state on Windows.
7532             move(availableGeometry.topLeft());
7533         } else if (ws & Qt::WindowMaximized) {
7534             // Setting a geometry on an already maximized window causes this to be
7535             // restored into a broken, half-maximized state, non-resizable state (QTBUG-4397).
7536             // Move the window in normal state if needed.
7537             if (restoredScreenNumber != QDesktopWidgetPrivate::screenNumber(this)) {
7538                 setWindowState(Qt::WindowNoState);
7539                 setGeometry(restoredNormalGeometry);
7540             }
7541         } else {
7542             setGeometry(restoredNormalGeometry);
7543         }
7544 #endif // Q_OS_WIN
7545         if (maximized)
7546             ws |= Qt::WindowMaximized;
7547         if (fullScreen)
7548             ws |= Qt::WindowFullScreen;
7549        setWindowState(ws);
7550        d_func()->topData()->normalGeometry = restoredNormalGeometry;
7551     } else {
7552         QPoint offset;
7553 #if 0 // Used to be included in Qt4 for Q_WS_X11
7554         if (isFullScreen())
7555             offset = d_func()->topData()->fullScreenOffset;
7556 #endif
7557         setWindowState(windowState() & ~(Qt::WindowMaximized | Qt::WindowFullScreen));
7558         move(restoredFrameGeometry.topLeft() + offset);
7559         resize(restoredNormalGeometry.size());
7560     }
7561     return true;
7562 }
7563 
7564 /*!\fn void QWidget::setGeometry(int x, int y, int w, int h)
7565     \overload
7566 
7567     This corresponds to setGeometry(QRect(\a x, \a y, \a w, \a h)).
7568 */
7569 
7570 /*!
7571   Sets the margins around the contents of the widget to have the sizes
7572   \a left, \a top, \a right, and \a bottom. The margins are used by
7573   the layout system, and may be used by subclasses to specify the area
7574   to draw in (e.g. excluding the frame).
7575 
7576   Changing the margins will trigger a resizeEvent().
7577 
7578   \sa contentsRect(), getContentsMargins()
7579 */
7580 void QWidget::setContentsMargins(int left, int top, int right, int bottom)
7581 {
7582     Q_D(QWidget);
7583     if (left == d->leftmargin && top == d->topmargin
7584          && right == d->rightmargin && bottom == d->bottommargin)
7585         return;
7586     d->leftmargin = left;
7587     d->topmargin = top;
7588     d->rightmargin = right;
7589     d->bottommargin = bottom;
7590 
7591     d->updateContentsRect();
7592 }
7593 
7594 /*!
7595   \overload
7596   \since 4.6
7597 
7598   \brief The setContentsMargins function sets the margins around the
7599   widget's contents.
7600 
7601   Sets the margins around the contents of the widget to have the
7602   sizes determined by \a margins. The margins are
7603   used by the layout system, and may be used by subclasses to
7604   specify the area to draw in (e.g. excluding the frame).
7605 
7606   Changing the margins will trigger a resizeEvent().
7607 
7608   \sa contentsRect(), getContentsMargins()
7609 */
7610 void QWidget::setContentsMargins(const QMargins &margins)
7611 {
7612     setContentsMargins(margins.left(), margins.top(),
7613                        margins.right(), margins.bottom());
7614 }
7615 
7616 void QWidgetPrivate::updateContentsRect()
7617 {
7618     Q_Q(QWidget);
7619 
7620     if (layout)
7621         layout->update(); //force activate; will do updateGeometry
7622     else
7623         q->updateGeometry();
7624 
7625     if (q->isVisible()) {
7626         q->update();
7627         QResizeEvent e(q->data->crect.size(), q->data->crect.size());
7628         QApplication::sendEvent(q, &e);
7629     } else {
7630         q->setAttribute(Qt::WA_PendingResizeEvent, true);
7631     }
7632 
7633     QEvent e(QEvent::ContentsRectChange);
7634     QApplication::sendEvent(q, &e);
7635 }
7636 
7637 /*!
7638   Returns the widget's contents margins for \a left, \a top, \a
7639   right, and \a bottom.
7640 
7641   \sa setContentsMargins(), contentsRect()
7642  */
7643 void QWidget::getContentsMargins(int *left, int *top, int *right, int *bottom) const
7644 {
7645     QMargins m = contentsMargins();
7646     if (left)
7647         *left = m.left();
7648     if (top)
7649         *top = m.top();
7650     if (right)
7651         *right = m.right();
7652     if (bottom)
7653         *bottom = m.bottom();
7654 }
7655 
7656 // FIXME: Move to qmargins.h for next minor Qt release
7657 QMargins operator|(const QMargins &m1, const QMargins &m2)
7658 {
7659     return QMargins(qMax(m1.left(), m2.left()), qMax(m1.top(), m2.top()),
7660         qMax(m1.right(), m2.right()), qMax(m1.bottom(), m2.bottom()));
7661 }
7662 
7663 /*!
7664   \since 4.6
7665 
7666   \brief The contentsMargins function returns the widget's contents margins.
7667 
7668   \sa getContentsMargins(), setContentsMargins(), contentsRect()
7669  */
7670 QMargins QWidget::contentsMargins() const
7671 {
7672     Q_D(const QWidget);
7673     QMargins userMargins(d->leftmargin, d->topmargin, d->rightmargin, d->bottommargin);
7674     return testAttribute(Qt::WA_ContentsMarginsRespectsSafeArea) ?
7675         userMargins | d->safeAreaMargins() : userMargins;
7676 }
7677 
7678 /*!
7679     Returns the area inside the widget's margins.
7680 
7681     \sa setContentsMargins(), getContentsMargins()
7682 */
7683 QRect QWidget::contentsRect() const
7684 {
7685     return rect() - contentsMargins();
7686 }
7687 
7688 QMargins QWidgetPrivate::safeAreaMargins() const
7689 {
7690     Q_Q(const QWidget);
7691     QWidget *nativeWidget = q->window();
7692     if (!nativeWidget->windowHandle())
7693         return QMargins();
7694 
7695     QPlatformWindow *platformWindow = nativeWidget->windowHandle()->handle();
7696     if (!platformWindow)
7697         return QMargins();
7698 
7699     QMargins safeAreaMargins = platformWindow->safeAreaMargins();
7700 
7701     if (!q->isWindow()) {
7702         // In theory the native parent widget already has a contents rect reflecting
7703         // the safe area of that widget, but we can't be sure that the widget or child
7704         // widgets of that widget have respected the contents rect when setting their
7705         // geometry, so we need to manually compute the safe area.
7706 
7707         // Unless the native widget doesn't have any margins, in which case there's
7708         // nothing for us to compute.
7709         if (safeAreaMargins.isNull())
7710             return QMargins();
7711 
7712         // Or, if one of our ancestors are in a layout that does not have WA_LayoutOnEntireRect
7713         // set, then we know that the layout has already taken care of placing us inside the
7714         // safe area, by taking the contents rect of its parent widget into account.
7715         const QWidget *assumedSafeWidget = nullptr;
7716         for (const QWidget *w = q; w != nativeWidget; w = w->parentWidget()) {
7717             QWidget *parentWidget = w->parentWidget();
7718             if (parentWidget->testAttribute(Qt::WA_LayoutOnEntireRect))
7719                 continue; // Layout not going to help us
7720 
7721             QLayout *layout = parentWidget->layout();
7722             if (!layout)
7723                 continue;
7724 
7725             if (layout->geometry().isNull())
7726                 continue; // Layout hasn't been activated yet
7727 
7728             if (layout->indexOf(const_cast<QWidget *>(w)) < 0)
7729                 continue; // Widget is not in layout
7730 
7731             assumedSafeWidget = w;
7732             break;
7733         }
7734 
7735 #if !defined(QT_DEBUG)
7736         if (assumedSafeWidget) {
7737             // We found a layout that we assume will take care of keeping us within the safe area
7738             // For debug builds we still map the safe area using the fallback logic, so that we
7739             // can detect any misbehaving layouts.
7740             return QMargins();
7741         }
7742 #endif
7743 
7744         // In all other cases we need to map the safe area of the native parent to the widget.
7745         // This depends on the widget being positioned and sized already, which means the initial
7746         // layout will be wrong, but the layout will then adjust itself.
7747         QPoint topLeftMargins = q->mapFrom(nativeWidget, QPoint(safeAreaMargins.left(), safeAreaMargins.top()));
7748         QRect widgetRect = q->isVisible() ? q->visibleRegion().boundingRect() : q->rect();
7749         QPoint bottomRightMargins = widgetRect.bottomRight() - q->mapFrom(nativeWidget,
7750             nativeWidget->rect().bottomRight() - QPoint(safeAreaMargins.right(), safeAreaMargins.bottom()));
7751 
7752         // Margins should never be negative
7753         safeAreaMargins = QMargins(qMax(0, topLeftMargins.x()), qMax(0, topLeftMargins.y()),
7754             qMax(0, bottomRightMargins.x()), qMax(0, bottomRightMargins.y()));
7755 
7756         if (!safeAreaMargins.isNull() && assumedSafeWidget) {
7757             QLayout *layout = assumedSafeWidget->parentWidget()->layout();
7758             qWarning() << layout << "is laying out" << assumedSafeWidget
7759                 << "outside of the contents rect of" << layout->parentWidget();
7760             return QMargins(); // Return empty margin to visually highlight the error
7761         }
7762     }
7763 
7764     return safeAreaMargins;
7765 }
7766 
7767 /*!
7768   \fn void QWidget::customContextMenuRequested(const QPoint &pos)
7769 
7770   This signal is emitted when the widget's \l contextMenuPolicy is
7771   Qt::CustomContextMenu, and the user has requested a context menu on
7772   the widget. The position \a pos is the position of the context menu
7773   event that the widget receives. Normally this is in widget
7774   coordinates. The exception to this rule is QAbstractScrollArea and
7775   its subclasses that map the context menu event to coordinates of the
7776   \l{QAbstractScrollArea::viewport()}{viewport()}.
7777 
7778 
7779   \sa mapToGlobal(), QMenu, contextMenuPolicy
7780 */
7781 
7782 
7783 /*!
7784     \property QWidget::contextMenuPolicy
7785     \brief how the widget shows a context menu
7786 
7787     The default value of this property is Qt::DefaultContextMenu,
7788     which means the contextMenuEvent() handler is called. Other values
7789     are Qt::NoContextMenu, Qt::PreventContextMenu,
7790     Qt::ActionsContextMenu, and Qt::CustomContextMenu. With
7791     Qt::CustomContextMenu, the signal customContextMenuRequested() is
7792     emitted.
7793 
7794     \sa contextMenuEvent(), customContextMenuRequested(), actions()
7795 */
7796 
7797 Qt::ContextMenuPolicy QWidget::contextMenuPolicy() const
7798 {
7799     return (Qt::ContextMenuPolicy)data->context_menu_policy;
7800 }
7801 
7802 void QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy)
7803 {
7804     data->context_menu_policy = (uint) policy;
7805 }
7806 
7807 /*!
7808     \property QWidget::focusPolicy
7809     \brief the way the widget accepts keyboard focus
7810 
7811     The policy is Qt::TabFocus if the widget accepts keyboard
7812     focus by tabbing, Qt::ClickFocus if the widget accepts
7813     focus by clicking, Qt::StrongFocus if it accepts both, and
7814     Qt::NoFocus (the default) if it does not accept focus at
7815     all.
7816 
7817     You must enable keyboard focus for a widget if it processes
7818     keyboard events. This is normally done from the widget's
7819     constructor. For instance, the QLineEdit constructor calls
7820     setFocusPolicy(Qt::StrongFocus).
7821 
7822     If the widget has a focus proxy, then the focus policy will
7823     be propagated to it.
7824 
7825     \sa focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent(), enabled
7826 */
7827 
7828 
7829 Qt::FocusPolicy QWidget::focusPolicy() const
7830 {
7831     return (Qt::FocusPolicy)data->focus_policy;
7832 }
7833 
7834 void QWidget::setFocusPolicy(Qt::FocusPolicy policy)
7835 {
7836     data->focus_policy = (uint) policy;
7837     Q_D(QWidget);
7838     if (d->extra && d->extra->focus_proxy)
7839         d->extra->focus_proxy->setFocusPolicy(policy);
7840 }
7841 
7842 /*!
7843     \property QWidget::updatesEnabled
7844     \brief whether updates are enabled
7845 
7846     An updates enabled widget receives paint events and has a system
7847     background; a disabled widget does not. This also implies that
7848     calling update() and repaint() has no effect if updates are
7849     disabled.
7850 
7851     By default, this property is \c true.
7852 
7853     setUpdatesEnabled() is normally used to disable updates for a
7854     short period of time, for instance to avoid screen flicker during
7855     large changes. In Qt, widgets normally do not generate screen
7856     flicker, but on X11 the server might erase regions on the screen
7857     when widgets get hidden before they can be replaced by other
7858     widgets. Disabling updates solves this.
7859 
7860     Example:
7861     \snippet code/src_gui_kernel_qwidget.cpp 13
7862 
7863     Disabling a widget implicitly disables all its children. Enabling a widget
7864     enables all child widgets \e except top-level widgets or those that
7865     have been explicitly disabled. Re-enabling updates implicitly calls
7866     update() on the widget.
7867 
7868     \sa paintEvent()
7869 */
7870 void QWidget::setUpdatesEnabled(bool enable)
7871 {
7872     Q_D(QWidget);
7873     setAttribute(Qt::WA_ForceUpdatesDisabled, !enable);
7874     d->setUpdatesEnabled_helper(enable);
7875 }
7876 
7877 /*!
7878     Shows the widget and its child widgets.
7879 
7880     This is equivalent to calling showFullScreen(), showMaximized(), or setVisible(true),
7881     depending on the platform's default behavior for the window flags.
7882 
7883      \sa raise(), showEvent(), hide(), setVisible(), showMinimized(), showMaximized(),
7884     showNormal(), isVisible(), windowFlags()
7885 */
7886 void QWidget::show()
7887 {
7888     Qt::WindowState defaultState = QGuiApplicationPrivate::platformIntegration()->defaultWindowState(data->window_flags);
7889     if (defaultState == Qt::WindowFullScreen)
7890         showFullScreen();
7891     else if (defaultState == Qt::WindowMaximized)
7892         showMaximized();
7893     else
7894         setVisible(true); // FIXME: Why not showNormal(), like QWindow::show()?
7895 }
7896 
7897 /*! \internal
7898 
7899    Makes the widget visible in the isVisible() meaning of the word.
7900    It is only called for toplevels or widgets with visible parents.
7901  */
7902 void QWidgetPrivate::show_recursive()
7903 {
7904     Q_Q(QWidget);
7905     // polish if necessary
7906 
7907     if (!q->testAttribute(Qt::WA_WState_Created))
7908         createRecursively();
7909     q->ensurePolished();
7910 
7911     if (!q->isWindow() && q->parentWidget()->d_func()->layout && !q->parentWidget()->data->in_show)
7912         q->parentWidget()->d_func()->layout->activate();
7913     // activate our layout before we and our children become visible
7914     if (layout)
7915         layout->activate();
7916 
7917     show_helper();
7918 }
7919 
7920 void QWidgetPrivate::sendPendingMoveAndResizeEvents(bool recursive, bool disableUpdates)
7921 {
7922     Q_Q(QWidget);
7923 
7924     disableUpdates = disableUpdates && q->updatesEnabled();
7925     if (disableUpdates)
7926         q->setAttribute(Qt::WA_UpdatesDisabled);
7927 
7928     if (q->testAttribute(Qt::WA_PendingMoveEvent)) {
7929         QMoveEvent e(data.crect.topLeft(), data.crect.topLeft());
7930         QApplication::sendEvent(q, &e);
7931         q->setAttribute(Qt::WA_PendingMoveEvent, false);
7932     }
7933 
7934     if (q->testAttribute(Qt::WA_PendingResizeEvent)) {
7935         QResizeEvent e(data.crect.size(), QSize());
7936         QApplication::sendEvent(q, &e);
7937         q->setAttribute(Qt::WA_PendingResizeEvent, false);
7938     }
7939 
7940     if (disableUpdates)
7941         q->setAttribute(Qt::WA_UpdatesDisabled, false);
7942 
7943     if (!recursive)
7944         return;
7945 
7946     for (int i = 0; i < children.size(); ++i) {
7947         if (QWidget *child = qobject_cast<QWidget *>(children.at(i)))
7948             child->d_func()->sendPendingMoveAndResizeEvents(recursive, disableUpdates);
7949     }
7950 }
7951 
7952 void QWidgetPrivate::activateChildLayoutsRecursively()
7953 {
7954     sendPendingMoveAndResizeEvents(false, true);
7955 
7956     for (int i = 0; i < children.size(); ++i) {
7957         QWidget *child = qobject_cast<QWidget *>(children.at(i));
7958         if (!child || child->isHidden() || child->isWindow())
7959             continue;
7960 
7961         child->ensurePolished();
7962 
7963         // Activate child's layout
7964         QWidgetPrivate *childPrivate = child->d_func();
7965         if (childPrivate->layout)
7966             childPrivate->layout->activate();
7967 
7968         // Pretend we're visible.
7969         const bool wasVisible = child->isVisible();
7970         if (!wasVisible)
7971             child->setAttribute(Qt::WA_WState_Visible);
7972 
7973         // Do the same for all my children.
7974         childPrivate->activateChildLayoutsRecursively();
7975 
7976         // We're not cheating anymore.
7977         if (!wasVisible)
7978             child->setAttribute(Qt::WA_WState_Visible, false);
7979     }
7980 }
7981 
7982 void QWidgetPrivate::show_helper()
7983 {
7984     Q_Q(QWidget);
7985     data.in_show = true; // qws optimization
7986     // make sure we receive pending move and resize events
7987     sendPendingMoveAndResizeEvents();
7988 
7989     // become visible before showing all children
7990     q->setAttribute(Qt::WA_WState_Visible);
7991 
7992     // finally show all children recursively
7993     showChildren(false);
7994 
7995 
7996 
7997     const bool isWindow = q->isWindow();
7998 #if QT_CONFIG(graphicsview)
7999     bool isEmbedded = isWindow && q->graphicsProxyWidget() != nullptr;
8000 #else
8001     bool isEmbedded = false;
8002 #endif
8003 
8004     // popup handling: new popups and tools need to be raised, and
8005     // existing popups must be closed. Also propagate the current
8006     // windows's KeyboardFocusChange status.
8007     if (isWindow && !isEmbedded) {
8008         if ((q->windowType() == Qt::Tool) || (q->windowType() == Qt::Popup) || q->windowType() == Qt::ToolTip) {
8009             q->raise();
8010             if (q->parentWidget() && q->parentWidget()->window()->testAttribute(Qt::WA_KeyboardFocusChange))
8011                 q->setAttribute(Qt::WA_KeyboardFocusChange);
8012         } else {
8013             while (QApplication::activePopupWidget()) {
8014                 if (!QApplication::activePopupWidget()->close())
8015                     break;
8016             }
8017         }
8018     }
8019 
8020     // Automatic embedding of child windows of widgets already embedded into
8021     // QGraphicsProxyWidget when they are shown the first time.
8022 #if QT_CONFIG(graphicsview)
8023     if (isWindow) {
8024         if (!isEmbedded && !bypassGraphicsProxyWidget(q)) {
8025             QGraphicsProxyWidget *ancestorProxy = nearestGraphicsProxyWidget(q->parentWidget());
8026             if (ancestorProxy) {
8027                 isEmbedded = true;
8028                 ancestorProxy->d_func()->embedSubWindow(q);
8029             }
8030         }
8031     }
8032 #else
8033     Q_UNUSED(isEmbedded);
8034 #endif
8035 
8036     // On Windows, show the popup now so that our own focus handling
8037     // stores the correct old focus widget even if it's stolen in the
8038     // showevent
8039 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_MAC */
8040     if (!isEmbedded && q->windowType() == Qt::Popup)
8041         qApp->d_func()->openPopup(q);
8042 #endif
8043 
8044     // send the show event before showing the window
8045     QShowEvent showEvent;
8046     QApplication::sendEvent(q, &showEvent);
8047 
8048     show_sys();
8049 
8050     if (!isEmbedded && q->windowType() == Qt::Popup)
8051         qApp->d_func()->openPopup(q);
8052 
8053 #ifndef QT_NO_ACCESSIBILITY
8054     if (q->windowType() != Qt::ToolTip) {    // Tooltips are read aloud twice in MS narrator.
8055         QAccessibleEvent event(q, QAccessible::ObjectShow);
8056         QAccessible::updateAccessibility(&event);
8057     }
8058 #endif
8059 
8060     if (QApplicationPrivate::hidden_focus_widget == q) {
8061         QApplicationPrivate::hidden_focus_widget = 0;
8062         q->setFocus(Qt::OtherFocusReason);
8063     }
8064 
8065     // Process events when showing a Qt::SplashScreen widget before the event loop
8066     // is spinnning; otherwise it might not show up on particular platforms.
8067     // This makes QSplashScreen behave the same on all platforms.
8068     if (!qApp->d_func()->in_exec && q->windowType() == Qt::SplashScreen)
8069         QApplication::processEvents();
8070 
8071     data.in_show = false;  // reset qws optimization
8072 }
8073 
8074 void QWidgetPrivate::show_sys()
8075 {
8076     Q_Q(QWidget);
8077 
8078     QWidgetWindow *window = windowHandle();
8079 
8080     if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
8081         invalidateBuffer(q->rect());
8082         q->setAttribute(Qt::WA_Mapped);
8083         // add our window the modal window list (native dialogs)
8084         if (window && q->isWindow()
8085 #if QT_CONFIG(graphicsview)
8086             && (!extra || !extra->proxyWidget)
8087 #endif
8088             && q->windowModality() != Qt::NonModal) {
8089             QGuiApplicationPrivate::showModalWindow(window);
8090         }
8091         return;
8092     }
8093 
8094     if (renderToTexture && !q->isWindow())
8095         QApplication::postEvent(q->parentWidget(), new QUpdateLaterEvent(q->geometry()));
8096     else
8097         QApplication::postEvent(q, new QUpdateLaterEvent(q->rect()));
8098 
8099     if ((!q->isWindow() && !q->testAttribute(Qt::WA_NativeWindow))
8100             || q->testAttribute(Qt::WA_OutsideWSRange)) {
8101         return;
8102     }
8103 
8104     if (window) {
8105         if (q->isWindow())
8106             fixPosIncludesFrame();
8107         QRect geomRect = q->geometry();
8108         if (!q->isWindow()) {
8109             QPoint topLeftOfWindow = q->mapTo(q->nativeParentWidget(),QPoint());
8110             geomRect.moveTopLeft(topLeftOfWindow);
8111         }
8112         const QRect windowRect = window->geometry();
8113         if (windowRect != geomRect) {
8114             if (q->testAttribute(Qt::WA_Moved)
8115                 || !QGuiApplicationPrivate::platformIntegration()->hasCapability(QPlatformIntegration::WindowManagement))
8116                 window->setGeometry(geomRect);
8117             else
8118                 window->resize(geomRect.size());
8119         }
8120 
8121 #ifndef QT_NO_CURSOR
8122         qt_qpa_set_cursor(q, false); // Needed in case cursor was set before show
8123 #endif
8124         invalidateBuffer(q->rect());
8125         window->setNativeWindowVisibility(true);
8126         // Was the window moved by the Window system or QPlatformWindow::initialGeometry() ?
8127         if (window->isTopLevel()) {
8128             const QPoint crectTopLeft = q->data->crect.topLeft();
8129             const QPoint windowTopLeft = window->geometry().topLeft();
8130             if (crectTopLeft == QPoint(0, 0) && windowTopLeft != crectTopLeft)
8131                 q->data->crect.moveTopLeft(windowTopLeft);
8132         }
8133     }
8134 }
8135 
8136 /*!
8137     Hides the widget. This function is equivalent to
8138     setVisible(false).
8139 
8140 
8141     \note If you are working with QDialog or its subclasses and you invoke
8142     the show() function after this function, the dialog will be displayed in
8143     its original position.
8144 
8145     \sa hideEvent(), isHidden(), show(), setVisible(), isVisible(), close()
8146 */
8147 void QWidget::hide()
8148 {
8149     setVisible(false);
8150 }
8151 
8152 /*!\internal
8153  */
8154 void QWidgetPrivate::hide_helper()
8155 {
8156     Q_Q(QWidget);
8157 
8158     bool isEmbedded = false;
8159 #if QT_CONFIG(graphicsview)
8160     isEmbedded = q->isWindow() && !bypassGraphicsProxyWidget(q) && nearestGraphicsProxyWidget(q->parentWidget()) != 0;
8161 #else
8162     Q_UNUSED(isEmbedded);
8163 #endif
8164 
8165     if (!isEmbedded && (q->windowType() == Qt::Popup))
8166         qApp->d_func()->closePopup(q);
8167 
8168 #if 0 // Used to be included in Qt4 for Q_WS_WIN
8169     if (q->isWindow() && !(q->windowType() == Qt::Popup) && q->parentWidget()
8170         && !q->parentWidget()->isHidden() && q->isActiveWindow())
8171         q->parentWidget()->activateWindow();        // Activate parent
8172 #endif
8173 
8174     q->setAttribute(Qt::WA_Mapped, false);
8175     hide_sys();
8176 
8177     bool wasVisible = q->testAttribute(Qt::WA_WState_Visible);
8178 
8179     if (wasVisible) {
8180         q->setAttribute(Qt::WA_WState_Visible, false);
8181 
8182     }
8183 
8184     QHideEvent hideEvent;
8185     QApplication::sendEvent(q, &hideEvent);
8186     hideChildren(false);
8187 
8188     // next bit tries to move the focus if the focus widget is now
8189     // hidden.
8190     if (wasVisible) {
8191         qApp->d_func()->sendSyntheticEnterLeave(q);
8192         QWidget *fw = QApplication::focusWidget();
8193         while (fw &&  !fw->isWindow()) {
8194             if (fw == q) {
8195                 q->focusNextPrevChild(true);
8196                 break;
8197             }
8198             fw = fw->parentWidget();
8199         }
8200     }
8201 
8202     if (QWidgetBackingStore *bs = maybeBackingStore())
8203         bs->removeDirtyWidget(q);
8204 
8205 #ifndef QT_NO_ACCESSIBILITY
8206     if (wasVisible) {
8207         QAccessibleEvent event(q, QAccessible::ObjectHide);
8208         QAccessible::updateAccessibility(&event);
8209     }
8210 #endif
8211 }
8212 
8213 void QWidgetPrivate::hide_sys()
8214 {
8215     Q_Q(QWidget);
8216 
8217     QWidgetWindow *window = windowHandle();
8218 
8219     if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
8220         q->setAttribute(Qt::WA_Mapped, false);
8221         // remove our window from the modal window list (native dialogs)
8222         if (window && q->isWindow()
8223 #if QT_CONFIG(graphicsview)
8224             && (!extra || !extra->proxyWidget)
8225 #endif
8226             && q->windowModality() != Qt::NonModal) {
8227             QGuiApplicationPrivate::hideModalWindow(window);
8228         }
8229         // do not return here, if window non-zero, we must hide it
8230     }
8231 
8232     deactivateWidgetCleanup();
8233 
8234     if (!q->isWindow()) {
8235         QWidget *p = q->parentWidget();
8236         if (p &&p->isVisible()) {
8237             if (renderToTexture)
8238                 p->d_func()->invalidateBuffer(q->geometry());
8239             else
8240                 invalidateBuffer(q->rect());
8241         }
8242     } else {
8243         invalidateBuffer(q->rect());
8244     }
8245 
8246     if (window)
8247         window->setNativeWindowVisibility(false);
8248 }
8249 
8250 /*!
8251     \fn bool QWidget::isHidden() const
8252 
8253     Returns \c true if the widget is hidden, otherwise returns \c false.
8254 
8255     A hidden widget will only become visible when show() is called on
8256     it. It will not be automatically shown when the parent is shown.
8257 
8258     To check visibility, use !isVisible() instead (notice the exclamation mark).
8259 
8260     isHidden() implies !isVisible(), but a widget can be not visible
8261     and not hidden at the same time. This is the case for widgets that are children of
8262     widgets that are not visible.
8263 
8264 
8265     Widgets are hidden if:
8266     \list
8267         \li they were created as independent windows,
8268         \li they were created as children of visible widgets,
8269         \li hide() or setVisible(false) was called.
8270     \endlist
8271 */
8272 
8273 
8274 void QWidget::setVisible(bool visible)
8275 {
8276     if (visible) { // show
8277         if (testAttribute(Qt::WA_WState_ExplicitShowHide) && !testAttribute(Qt::WA_WState_Hidden))
8278             return;
8279 
8280         Q_D(QWidget);
8281 
8282         // Designer uses a trick to make grabWidget work without showing
8283         if (!isWindow() && parentWidget() && parentWidget()->isVisible()
8284             && !parentWidget()->testAttribute(Qt::WA_WState_Created))
8285             parentWidget()->window()->d_func()->createRecursively();
8286 
8287         //create toplevels but not children of non-visible parents
8288         QWidget *pw = parentWidget();
8289         if (!testAttribute(Qt::WA_WState_Created)
8290             && (isWindow() || pw->testAttribute(Qt::WA_WState_Created))) {
8291             create();
8292         }
8293 
8294         bool wasResized = testAttribute(Qt::WA_Resized);
8295         Qt::WindowStates initialWindowState = windowState();
8296 
8297         // polish if necessary
8298         ensurePolished();
8299 
8300         // remember that show was called explicitly
8301         setAttribute(Qt::WA_WState_ExplicitShowHide);
8302         // whether we need to inform the parent widget immediately
8303         bool needUpdateGeometry = !isWindow() && testAttribute(Qt::WA_WState_Hidden);
8304         // we are no longer hidden
8305         setAttribute(Qt::WA_WState_Hidden, false);
8306 
8307         if (needUpdateGeometry)
8308             d->updateGeometry_helper(true);
8309 
8310         // activate our layout before we and our children become visible
8311         if (d->layout)
8312             d->layout->activate();
8313 
8314         if (!isWindow()) {
8315             QWidget *parent = parentWidget();
8316             while (parent && parent->isVisible() && parent->d_func()->layout  && !parent->data->in_show) {
8317                 parent->d_func()->layout->activate();
8318                 if (parent->isWindow())
8319                     break;
8320                 parent = parent->parentWidget();
8321             }
8322             if (parent)
8323                 parent->d_func()->setDirtyOpaqueRegion();
8324         }
8325 
8326         // adjust size if necessary
8327         if (!wasResized
8328             && (isWindow() || !parentWidget()->d_func()->layout))  {
8329             if (isWindow()) {
8330                 adjustSize();
8331                 if (windowState() != initialWindowState)
8332                     setWindowState(initialWindowState);
8333             } else {
8334                 adjustSize();
8335             }
8336             setAttribute(Qt::WA_Resized, false);
8337         }
8338 
8339         setAttribute(Qt::WA_KeyboardFocusChange, false);
8340 
8341         if (isWindow() || parentWidget()->isVisible()) {
8342             d->show_helper();
8343 
8344             qApp->d_func()->sendSyntheticEnterLeave(this);
8345         }
8346 
8347         QEvent showToParentEvent(QEvent::ShowToParent);
8348         QApplication::sendEvent(this, &showToParentEvent);
8349     } else { // hide
8350         if (testAttribute(Qt::WA_WState_ExplicitShowHide) && testAttribute(Qt::WA_WState_Hidden))
8351             return;
8352 #if 0 // Used to be included in Qt4 for Q_WS_WIN
8353         // reset WS_DISABLED style in a Blocked window
8354         if(isWindow() && testAttribute(Qt::WA_WState_Created)
8355            && QApplicationPrivate::isBlockedByModal(this))
8356         {
8357             LONG dwStyle = GetWindowLong(winId(), GWL_STYLE);
8358             dwStyle &= ~WS_DISABLED;
8359             SetWindowLong(winId(), GWL_STYLE, dwStyle);
8360         }
8361 #endif
8362         if (QApplicationPrivate::hidden_focus_widget == this)
8363             QApplicationPrivate::hidden_focus_widget = 0;
8364 
8365         Q_D(QWidget);
8366 
8367         // hw: The test on getOpaqueRegion() needs to be more intelligent
8368         // currently it doesn't work if the widget is hidden (the region will
8369         // be clipped). The real check should be testing the cached region
8370         // (and dirty flag) directly.
8371         if (!isWindow() && parentWidget()) // && !d->getOpaqueRegion().isEmpty())
8372             parentWidget()->d_func()->setDirtyOpaqueRegion();
8373 
8374         setAttribute(Qt::WA_WState_Hidden);
8375         setAttribute(Qt::WA_WState_ExplicitShowHide);
8376         if (testAttribute(Qt::WA_WState_Created))
8377             d->hide_helper();
8378 
8379         // invalidate layout similar to updateGeometry()
8380         if (!isWindow() && parentWidget()) {
8381             if (parentWidget()->d_func()->layout)
8382                 parentWidget()->d_func()->layout->invalidate();
8383             else if (parentWidget()->isVisible())
8384                 QApplication::postEvent(parentWidget(), new QEvent(QEvent::LayoutRequest));
8385         }
8386 
8387         QEvent hideToParentEvent(QEvent::HideToParent);
8388         QApplication::sendEvent(this, &hideToParentEvent);
8389     }
8390 }
8391 
8392 /*!
8393     Convenience function, equivalent to setVisible(!\a hidden).
8394 */
8395 void QWidget::setHidden(bool hidden)
8396 {
8397     setVisible(!hidden);
8398 }
8399 
8400 void QWidgetPrivate::_q_showIfNotHidden()
8401 {
8402     Q_Q(QWidget);
8403     if ( !(q->isHidden() && q->testAttribute(Qt::WA_WState_ExplicitShowHide)) )
8404         q->setVisible(true);
8405 }
8406 
8407 void QWidgetPrivate::showChildren(bool spontaneous)
8408 {
8409     QList<QObject*> childList = children;
8410     for (int i = 0; i < childList.size(); ++i) {
8411         QWidget *widget = qobject_cast<QWidget*>(childList.at(i));
8412         if (!widget
8413             || widget->isWindow()
8414             || widget->testAttribute(Qt::WA_WState_Hidden))
8415             continue;
8416         if (spontaneous) {
8417             widget->setAttribute(Qt::WA_Mapped);
8418             widget->d_func()->showChildren(true);
8419             QShowEvent e;
8420             QApplication::sendSpontaneousEvent(widget, &e);
8421         } else {
8422             if (widget->testAttribute(Qt::WA_WState_ExplicitShowHide))
8423                 widget->d_func()->show_recursive();
8424             else
8425                 widget->show();
8426         }
8427     }
8428 }
8429 
8430 void QWidgetPrivate::hideChildren(bool spontaneous)
8431 {
8432     QList<QObject*> childList = children;
8433     for (int i = 0; i < childList.size(); ++i) {
8434         QWidget *widget = qobject_cast<QWidget*>(childList.at(i));
8435         if (!widget || widget->isWindow() || widget->testAttribute(Qt::WA_WState_Hidden))
8436             continue;
8437 #if 0 // Used to be included in Qt4 for Q_WS_MAC
8438         // Before doing anything we need to make sure that we don't leave anything in a non-consistent state.
8439         // When hiding a widget we need to make sure that no mouse_down events are active, because
8440         // the mouse_up event will never be received by a hidden widget or one of its descendants.
8441         // The solution is simple, before going through with this we check if there are any mouse_down events in
8442         // progress, if so we check if it is related to this widget or not. If so, we just reset the mouse_down and
8443         // then we continue.
8444         // In X11 and Windows we send a mouse_release event, however we don't do that here because we were already
8445         // ignoring that from before. I.e. Carbon did not send the mouse release event, so we will not send the
8446         // mouse release event. There are two ways to interpret this:
8447         // 1. If we don't send the mouse release event, the widget might get into an inconsistent state, i.e. it
8448         // might be waiting for a release event that will never arrive.
8449         // 2. If we send the mouse release event, then the widget might decide to trigger an action that is not
8450         // supposed to trigger because it is not visible.
8451         if(widget == qt_button_down)
8452             qt_button_down = 0;
8453 #endif
8454         if (spontaneous)
8455             widget->setAttribute(Qt::WA_Mapped, false);
8456         else
8457             widget->setAttribute(Qt::WA_WState_Visible, false);
8458         widget->d_func()->hideChildren(spontaneous);
8459         QHideEvent e;
8460         if (spontaneous) {
8461             QApplication::sendSpontaneousEvent(widget, &e);
8462         } else {
8463             QApplication::sendEvent(widget, &e);
8464             if (widget->internalWinId()
8465                 && widget->testAttribute(Qt::WA_DontCreateNativeAncestors)) {
8466                 // hide_sys() on an ancestor won't have any affect on this
8467                 // widget, so it needs an explicit hide_sys() of its own
8468                 widget->d_func()->hide_sys();
8469             }
8470         }
8471         qApp->d_func()->sendSyntheticEnterLeave(widget);
8472 #ifndef QT_NO_ACCESSIBILITY
8473         if (!spontaneous) {
8474             QAccessibleEvent event(widget, QAccessible::ObjectHide);
8475             QAccessible::updateAccessibility(&event);
8476         }
8477 #endif
8478     }
8479 }
8480 
8481 bool QWidgetPrivate::close_helper(CloseMode mode)
8482 {
8483     if (data.is_closing)
8484         return true;
8485 
8486     Q_Q(QWidget);
8487     data.is_closing = 1;
8488 
8489     QPointer<QWidget> that = q;
8490     QPointer<QWidget> parentWidget = q->parentWidget();
8491 
8492     bool quitOnClose = q->testAttribute(Qt::WA_QuitOnClose);
8493     if (mode != CloseNoEvent) {
8494         QCloseEvent e;
8495         if (mode == CloseWithSpontaneousEvent)
8496             QApplication::sendSpontaneousEvent(q, &e);
8497         else
8498             QApplication::sendEvent(q, &e);
8499         if (!that.isNull() && !e.isAccepted()) {
8500             data.is_closing = 0;
8501             return false;
8502         }
8503     }
8504 
8505     if (!that.isNull() && !q->isHidden())
8506         q->hide();
8507 
8508     // Attempt to close the application only if this has WA_QuitOnClose set and a non-visible parent
8509     quitOnClose = quitOnClose && (parentWidget.isNull() || !parentWidget->isVisible());
8510 
8511     if (quitOnClose) {
8512         /* if there is no non-withdrawn primary window left (except
8513            the ones without QuitOnClose), we emit the lastWindowClosed
8514            signal */
8515         QWidgetList list = QApplication::topLevelWidgets();
8516         bool lastWindowClosed = true;
8517         for (int i = 0; i < list.size(); ++i) {
8518             QWidget *w = list.at(i);
8519             if (!w->isVisible() || w->parentWidget() || !w->testAttribute(Qt::WA_QuitOnClose))
8520                 continue;
8521             lastWindowClosed = false;
8522             break;
8523         }
8524         if (lastWindowClosed) {
8525             QGuiApplicationPrivate::emitLastWindowClosed();
8526             QCoreApplicationPrivate *applicationPrivate = static_cast<QCoreApplicationPrivate*>(QObjectPrivate::get(QCoreApplication::instance()));
8527             applicationPrivate->maybeQuit();
8528         }
8529     }
8530 
8531 
8532     if (!that.isNull()) {
8533         data.is_closing = 0;
8534         if (q->testAttribute(Qt::WA_DeleteOnClose)) {
8535             q->setAttribute(Qt::WA_DeleteOnClose, false);
8536             q->deleteLater();
8537         }
8538     }
8539     return true;
8540 }
8541 
8542 
8543 /*!
8544     Closes this widget. Returns \c true if the widget was closed;
8545     otherwise returns \c false.
8546 
8547     First it sends the widget a QCloseEvent. The widget is
8548     \l{hide()}{hidden} if it \l{QEvent::accept()}{accepts}
8549     the close event. If it \l{QEvent::ignore()}{ignores}
8550     the event, nothing happens. The default
8551     implementation of QWidget::closeEvent() accepts the close event.
8552 
8553     If the widget has the Qt::WA_DeleteOnClose flag, the widget
8554     is also deleted. A close events is delivered to the widget no
8555     matter if the widget is visible or not.
8556 
8557     The \l QApplication::lastWindowClosed() signal is emitted when the
8558     last visible primary window (i.e. window with no parent) with the
8559     Qt::WA_QuitOnClose attribute set is closed. By default this
8560     attribute is set for all widgets except transient windows such as
8561     splash screens, tool windows, and popup menus.
8562 
8563 */
8564 
8565 bool QWidget::close()
8566 {
8567     return d_func()->close_helper(QWidgetPrivate::CloseWithEvent);
8568 }
8569 
8570 /*!
8571     \property QWidget::visible
8572     \brief whether the widget is visible
8573 
8574     Calling setVisible(true) or show() sets the widget to visible
8575     status if all its parent widgets up to the window are visible. If
8576     an ancestor is not visible, the widget won't become visible until
8577     all its ancestors are shown. If its size or position has changed,
8578     Qt guarantees that a widget gets move and resize events just
8579     before it is shown. If the widget has not been resized yet, Qt
8580     will adjust the widget's size to a useful default using
8581     adjustSize().
8582 
8583     Calling setVisible(false) or hide() hides a widget explicitly. An
8584     explicitly hidden widget will never become visible, even if all
8585     its ancestors become visible, unless you show it.
8586 
8587     A widget receives show and hide events when its visibility status
8588     changes. Between a hide and a show event, there is no need to
8589     waste CPU cycles preparing or displaying information to the user.
8590     A video application, for example, might simply stop generating new
8591     frames.
8592 
8593     A widget that happens to be obscured by other windows on the
8594     screen is considered to be visible. The same applies to iconified
8595     windows and windows that exist on another virtual
8596     desktop (on platforms that support this concept). A widget
8597     receives spontaneous show and hide events when its mapping status
8598     is changed by the window system, e.g. a spontaneous hide event
8599     when the user minimizes the window, and a spontaneous show event
8600     when the window is restored again.
8601 
8602     You almost never have to reimplement the setVisible() function. If
8603     you need to change some settings before a widget is shown, use
8604     showEvent() instead. If you need to do some delayed initialization
8605     use the Polish event delivered to the event() function.
8606 
8607     \sa show(), hide(), isHidden(), isVisibleTo(), isMinimized(),
8608     showEvent(), hideEvent()
8609 */
8610 
8611 
8612 /*!
8613     Returns \c true if this widget would become visible if \a ancestor is
8614     shown; otherwise returns \c false.
8615 
8616     The true case occurs if neither the widget itself nor any parent
8617     up to but excluding \a ancestor has been explicitly hidden.
8618 
8619     This function will still return true if the widget is obscured by
8620     other windows on the screen, but could be physically visible if it
8621     or they were to be moved.
8622 
8623     isVisibleTo(0) is identical to isVisible().
8624 
8625     \sa show(), hide(), isVisible()
8626 */
8627 
8628 bool QWidget::isVisibleTo(const QWidget *ancestor) const
8629 {
8630     if (!ancestor)
8631         return isVisible();
8632     const QWidget * w = this;
8633     while (!w->isHidden()
8634             && !w->isWindow()
8635             && w->parentWidget()
8636             && w->parentWidget() != ancestor)
8637         w = w->parentWidget();
8638     return !w->isHidden();
8639 }
8640 
8641 
8642 /*!
8643     Returns the unobscured region where paint events can occur.
8644 
8645     For visible widgets, this is an approximation of the area not
8646     covered by other widgets; otherwise, this is an empty region.
8647 
8648     The repaint() function calls this function if necessary, so in
8649     general you do not need to call it.
8650 
8651 */
8652 QRegion QWidget::visibleRegion() const
8653 {
8654     Q_D(const QWidget);
8655 
8656     QRect clipRect = d->clipRect();
8657     if (clipRect.isEmpty())
8658         return QRegion();
8659     QRegion r(clipRect);
8660     d->subtractOpaqueChildren(r, clipRect);
8661     d->subtractOpaqueSiblings(r);
8662     return r;
8663 }
8664 
8665 
8666 QSize QWidgetPrivate::adjustedSize() const
8667 {
8668     Q_Q(const QWidget);
8669 
8670     QSize s = q->sizeHint();
8671 
8672     if (q->isWindow()) {
8673         Qt::Orientations exp;
8674         if (layout) {
8675             if (layout->hasHeightForWidth())
8676                 s.setHeight(layout->totalHeightForWidth(s.width()));
8677             exp = layout->expandingDirections();
8678         } else
8679         {
8680             if (q->sizePolicy().hasHeightForWidth())
8681                 s.setHeight(q->heightForWidth(s.width()));
8682             exp = q->sizePolicy().expandingDirections();
8683         }
8684         if (exp & Qt::Horizontal)
8685             s.setWidth(qMax(s.width(), 200));
8686         if (exp & Qt::Vertical)
8687             s.setHeight(qMax(s.height(), 100));
8688 #if 0 // Used to be included in Qt4 for Q_WS_X11
8689         QRect screen = QDesktopWidgetPrivate::screenGeometry(q->x11Info().screen());
8690 #else // all others
8691         QRect screen = QDesktopWidgetPrivate::screenGeometry(q->pos());
8692 #endif
8693         s.setWidth(qMin(s.width(), screen.width()*2/3));
8694         s.setHeight(qMin(s.height(), screen.height()*2/3));
8695 
8696         if (QTLWExtra *extra = maybeTopData())
8697             extra->sizeAdjusted = true;
8698     }
8699 
8700     if (!s.isValid()) {
8701         QRect r = q->childrenRect(); // get children rectangle
8702         if (r.isNull())
8703             return s;
8704         s = r.size() + QSize(2 * r.x(), 2 * r.y());
8705     }
8706 
8707     return s;
8708 }
8709 
8710 /*!
8711     Adjusts the size of the widget to fit its contents.
8712 
8713     This function uses sizeHint() if it is valid, i.e., the size hint's width
8714     and height are \>= 0. Otherwise, it sets the size to the children
8715     rectangle that covers all child widgets (the union of all child widget
8716     rectangles).
8717 
8718     For windows, the screen size is also taken into account. If the sizeHint()
8719     is less than (200, 100) and the size policy is \l{QSizePolicy::Expanding}
8720     {expanding}, the window will be at least (200, 100). The maximum size of
8721     a window is 2/3 of the screen's width and height.
8722 
8723     \sa sizeHint(), childrenRect()
8724 */
8725 
8726 void QWidget::adjustSize()
8727 {
8728     Q_D(QWidget);
8729     ensurePolished();
8730     QSize s = d->adjustedSize();
8731 
8732     if (d->layout)
8733         d->layout->activate();
8734 
8735     if (s.isValid())
8736         resize(s);
8737 }
8738 
8739 
8740 /*!
8741     \property QWidget::sizeHint
8742     \brief the recommended size for the widget
8743 
8744     If the value of this property is an invalid size, no size is
8745     recommended.
8746 
8747     The default implementation of sizeHint() returns an invalid size
8748     if there is no layout for this widget, and returns the layout's
8749     preferred size otherwise.
8750 
8751     \sa QSize::isValid(), minimumSizeHint(), sizePolicy(),
8752     setMinimumSize(), updateGeometry()
8753 */
8754 
8755 QSize QWidget::sizeHint() const
8756 {
8757     Q_D(const QWidget);
8758     if (d->layout)
8759         return d->layout->totalSizeHint();
8760     return QSize(-1, -1);
8761 }
8762 
8763 /*!
8764     \property QWidget::minimumSizeHint
8765     \brief the recommended minimum size for the widget
8766 
8767     If the value of this property is an invalid size, no minimum size
8768     is recommended.
8769 
8770     The default implementation of minimumSizeHint() returns an invalid
8771     size if there is no layout for this widget, and returns the
8772     layout's minimum size otherwise. Most built-in widgets reimplement
8773     minimumSizeHint().
8774 
8775     \l QLayout will never resize a widget to a size smaller than the
8776     minimum size hint unless minimumSize() is set or the size policy is
8777     set to QSizePolicy::Ignore. If minimumSize() is set, the minimum
8778     size hint will be ignored.
8779 
8780     \sa QSize::isValid(), resize(), setMinimumSize(), sizePolicy()
8781 */
8782 QSize QWidget::minimumSizeHint() const
8783 {
8784     Q_D(const QWidget);
8785     if (d->layout)
8786         return d->layout->totalMinimumSize();
8787     return QSize(-1, -1);
8788 }
8789 
8790 
8791 /*!
8792     \fn QWidget *QWidget::parentWidget() const
8793 
8794     Returns the parent of this widget, or 0 if it does not have any
8795     parent widget.
8796 */
8797 
8798 
8799 /*!
8800     Returns \c true if this widget is a parent, (or grandparent and so on
8801     to any level), of the given \a child, and both widgets are within
8802     the same window; otherwise returns \c false.
8803 */
8804 
8805 bool QWidget::isAncestorOf(const QWidget *child) const
8806 {
8807     while (child) {
8808         if (child == this)
8809             return true;
8810         if (child->isWindow())
8811             return false;
8812         child = child->parentWidget();
8813     }
8814     return false;
8815 }
8816 
8817 #if 0 // Used to be included in Qt4 for Q_WS_WIN
8818 inline void setDisabledStyle(QWidget *w, bool setStyle)
8819 {
8820     // set/reset WS_DISABLED style.
8821     if(w && w->isWindow() && w->isVisible() && w->isEnabled()) {
8822         LONG dwStyle = GetWindowLong(w->winId(), GWL_STYLE);
8823         LONG newStyle = dwStyle;
8824         if (setStyle)
8825             newStyle |= WS_DISABLED;
8826         else
8827             newStyle &= ~WS_DISABLED;
8828         if (newStyle != dwStyle) {
8829             SetWindowLong(w->winId(), GWL_STYLE, newStyle);
8830             // we might need to repaint in some situations (eg. menu)
8831             w->repaint();
8832         }
8833     }
8834 }
8835 #endif
8836 
8837 /*****************************************************************************
8838   QWidget event handling
8839  *****************************************************************************/
8840 
8841 /*!
8842     This is the main event handler; it handles event \a event. You can
8843     reimplement this function in a subclass, but we recommend using
8844     one of the specialized event handlers instead.
8845 
8846     Key press and release events are treated differently from other
8847     events. event() checks for Tab and Shift+Tab and tries to move the
8848     focus appropriately. If there is no widget to move the focus to
8849     (or the key press is not Tab or Shift+Tab), event() calls
8850     keyPressEvent().
8851 
8852     Mouse and tablet event handling is also slightly special: only
8853     when the widget is \l enabled, event() will call the specialized
8854     handlers such as mousePressEvent(); otherwise it will discard the
8855     event.
8856 
8857     This function returns \c true if the event was recognized, otherwise
8858     it returns \c false.  If the recognized event was accepted (see \l
8859     QEvent::accepted), any further processing such as event
8860     propagation to the parent widget stops.
8861 
8862     \sa closeEvent(), focusInEvent(), focusOutEvent(), enterEvent(),
8863     keyPressEvent(), keyReleaseEvent(), leaveEvent(),
8864     mouseDoubleClickEvent(), mouseMoveEvent(), mousePressEvent(),
8865     mouseReleaseEvent(), moveEvent(), paintEvent(), resizeEvent(),
8866     QObject::event(), QObject::timerEvent()
8867 */
8868 
8869 bool QWidget::event(QEvent *event)
8870 {
8871     Q_D(QWidget);
8872 
8873     // ignore mouse and key events when disabled
8874     if (!isEnabled()) {
8875         switch(event->type()) {
8876         case QEvent::TabletPress:
8877         case QEvent::TabletRelease:
8878         case QEvent::TabletMove:
8879         case QEvent::MouseButtonPress:
8880         case QEvent::MouseButtonRelease:
8881         case QEvent::MouseButtonDblClick:
8882         case QEvent::MouseMove:
8883         case QEvent::TouchBegin:
8884         case QEvent::TouchUpdate:
8885         case QEvent::TouchEnd:
8886         case QEvent::TouchCancel:
8887         case QEvent::ContextMenu:
8888         case QEvent::KeyPress:
8889         case QEvent::KeyRelease:
8890 #if QT_CONFIG(wheelevent)
8891         case QEvent::Wheel:
8892 #endif
8893             return false;
8894         default:
8895             break;
8896         }
8897     }
8898     switch (event->type()) {
8899     case QEvent::MouseMove:
8900         mouseMoveEvent((QMouseEvent*)event);
8901         break;
8902 
8903     case QEvent::MouseButtonPress:
8904         mousePressEvent((QMouseEvent*)event);
8905         break;
8906 
8907     case QEvent::MouseButtonRelease:
8908         mouseReleaseEvent((QMouseEvent*)event);
8909         break;
8910 
8911     case QEvent::MouseButtonDblClick:
8912         mouseDoubleClickEvent((QMouseEvent*)event);
8913         break;
8914 #if QT_CONFIG(wheelevent)
8915     case QEvent::Wheel:
8916         wheelEvent((QWheelEvent*)event);
8917         break;
8918 #endif
8919 #if QT_CONFIG(tabletevent)
8920     case QEvent::TabletMove:
8921         if (static_cast<QTabletEvent *>(event)->buttons() == Qt::NoButton && !testAttribute(Qt::WA_TabletTracking))
8922             break;
8923         Q_FALLTHROUGH();
8924     case QEvent::TabletPress:
8925     case QEvent::TabletRelease:
8926         tabletEvent((QTabletEvent*)event);
8927         break;
8928 #endif
8929     case QEvent::KeyPress: {
8930         QKeyEvent *k = (QKeyEvent *)event;
8931         bool res = false;
8932         if (!(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier))) {  //### Add MetaModifier?
8933             if (k->key() == Qt::Key_Backtab
8934                 || (k->key() == Qt::Key_Tab && (k->modifiers() & Qt::ShiftModifier)))
8935                 res = focusNextPrevChild(false);
8936             else if (k->key() == Qt::Key_Tab)
8937                 res = focusNextPrevChild(true);
8938             if (res)
8939                 break;
8940         }
8941         keyPressEvent(k);
8942 #ifdef QT_KEYPAD_NAVIGATION
8943         if (!k->isAccepted() && QApplication::keypadNavigationEnabled()
8944             && !(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::ShiftModifier))) {
8945             if (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder) {
8946                 if (k->key() == Qt::Key_Up)
8947                     res = focusNextPrevChild(false);
8948                 else if (k->key() == Qt::Key_Down)
8949                     res = focusNextPrevChild(true);
8950             } else if (QApplication::navigationMode() == Qt::NavigationModeKeypadDirectional) {
8951                 if (k->key() == Qt::Key_Up)
8952                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionNorth);
8953                 else if (k->key() == Qt::Key_Right)
8954                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionEast);
8955                 else if (k->key() == Qt::Key_Down)
8956                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionSouth);
8957                 else if (k->key() == Qt::Key_Left)
8958                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionWest);
8959             }
8960             if (res) {
8961                 k->accept();
8962                 break;
8963             }
8964         }
8965 #endif
8966 #if QT_CONFIG(whatsthis)
8967         if (!k->isAccepted()
8968             && k->modifiers() & Qt::ShiftModifier && k->key() == Qt::Key_F1
8969             && d->whatsThis.size()) {
8970             QWhatsThis::showText(mapToGlobal(inputMethodQuery(Qt::ImCursorRectangle).toRect().center()), d->whatsThis, this);
8971             k->accept();
8972         }
8973 #endif
8974     }
8975         break;
8976 
8977     case QEvent::KeyRelease:
8978         keyReleaseEvent((QKeyEvent*)event);
8979         Q_FALLTHROUGH();
8980     case QEvent::ShortcutOverride:
8981         break;
8982 
8983     case QEvent::InputMethod:
8984         inputMethodEvent((QInputMethodEvent *) event);
8985         break;
8986 
8987     case QEvent::InputMethodQuery:
8988         if (testAttribute(Qt::WA_InputMethodEnabled)) {
8989             QInputMethodQueryEvent *query = static_cast<QInputMethodQueryEvent *>(event);
8990             Qt::InputMethodQueries queries = query->queries();
8991             for (uint i = 0; i < 32; ++i) {
8992                 Qt::InputMethodQuery q = (Qt::InputMethodQuery)(int)(queries & (1<<i));
8993                 if (q) {
8994                     QVariant v = inputMethodQuery(q);
8995                     if (q == Qt::ImEnabled && !v.isValid() && isEnabled())
8996                         v = QVariant(true); // special case for Qt4 compatibility
8997                     query->setValue(q, v);
8998                 }
8999             }
9000             query->accept();
9001         }
9002         break;
9003 
9004     case QEvent::PolishRequest:
9005         ensurePolished();
9006         break;
9007 
9008     case QEvent::Polish: {
9009         style()->polish(this);
9010         setAttribute(Qt::WA_WState_Polished);
9011         if (!QApplication::font(this).isCopyOf(QApplication::font()))
9012             d->resolveFont();
9013         if (!QApplication::palette(this).isCopyOf(QApplication::palette()))
9014             d->resolvePalette();
9015     }
9016         break;
9017 
9018     case QEvent::ApplicationWindowIconChange:
9019         if (isWindow() && !testAttribute(Qt::WA_SetWindowIcon)) {
9020             d->setWindowIcon_sys();
9021             d->setWindowIcon_helper();
9022         }
9023         break;
9024     case QEvent::FocusIn:
9025         focusInEvent((QFocusEvent*)event);
9026         d->updateWidgetTransform(event);
9027         break;
9028 
9029     case QEvent::FocusOut:
9030         focusOutEvent((QFocusEvent*)event);
9031         break;
9032 
9033     case QEvent::Enter:
9034 #if QT_CONFIG(statustip)
9035         if (d->statusTip.size()) {
9036             QStatusTipEvent tip(d->statusTip);
9037             QApplication::sendEvent(const_cast<QWidget *>(this), &tip);
9038         }
9039 #endif
9040         enterEvent(event);
9041         break;
9042 
9043     case QEvent::Leave:
9044 #if QT_CONFIG(statustip)
9045         if (d->statusTip.size()) {
9046             QString empty;
9047             QStatusTipEvent tip(empty);
9048             QApplication::sendEvent(const_cast<QWidget *>(this), &tip);
9049         }
9050 #endif
9051         leaveEvent(event);
9052         break;
9053 
9054     case QEvent::HoverEnter:
9055     case QEvent::HoverLeave:
9056         update();
9057         break;
9058 
9059     case QEvent::Paint:
9060         // At this point the event has to be delivered, regardless
9061         // whether the widget isVisible() or not because it
9062         // already went through the filters
9063         paintEvent((QPaintEvent*)event);
9064         break;
9065 
9066     case QEvent::Move:
9067         moveEvent((QMoveEvent*)event);
9068         d->updateWidgetTransform(event);
9069         break;
9070 
9071     case QEvent::Resize:
9072         resizeEvent((QResizeEvent*)event);
9073         d->updateWidgetTransform(event);
9074         break;
9075 
9076     case QEvent::Close:
9077         closeEvent((QCloseEvent *)event);
9078         break;
9079 
9080 #ifndef QT_NO_CONTEXTMENU
9081     case QEvent::ContextMenu:
9082         switch (data->context_menu_policy) {
9083         case Qt::PreventContextMenu:
9084             break;
9085         case Qt::DefaultContextMenu:
9086             contextMenuEvent(static_cast<QContextMenuEvent *>(event));
9087             break;
9088         case Qt::CustomContextMenu:
9089             emit customContextMenuRequested(static_cast<QContextMenuEvent *>(event)->pos());
9090             break;
9091 #if QT_CONFIG(menu)
9092         case Qt::ActionsContextMenu:
9093             if (d->actions.count()) {
9094                 QMenu::exec(d->actions, static_cast<QContextMenuEvent *>(event)->globalPos(),
9095                             0, this);
9096                 break;
9097             }
9098             Q_FALLTHROUGH();
9099 #endif
9100         default:
9101             event->ignore();
9102             break;
9103         }
9104         break;
9105 #endif // QT_NO_CONTEXTMENU
9106 
9107 #ifndef QT_NO_DRAGANDDROP
9108     case QEvent::Drop:
9109         dropEvent((QDropEvent*) event);
9110         break;
9111 
9112     case QEvent::DragEnter:
9113         dragEnterEvent((QDragEnterEvent*) event);
9114         break;
9115 
9116     case QEvent::DragMove:
9117         dragMoveEvent((QDragMoveEvent*) event);
9118         break;
9119 
9120     case QEvent::DragLeave:
9121         dragLeaveEvent((QDragLeaveEvent*) event);
9122         break;
9123 #endif
9124 
9125     case QEvent::Show:
9126         showEvent((QShowEvent*) event);
9127         break;
9128 
9129     case QEvent::Hide:
9130         hideEvent((QHideEvent*) event);
9131         break;
9132 
9133     case QEvent::ShowWindowRequest:
9134         if (!isHidden())
9135             d->show_sys();
9136         break;
9137 
9138     case QEvent::ApplicationFontChange:
9139         d->resolveFont();
9140         break;
9141     case QEvent::ApplicationPaletteChange:
9142         if (!(windowType() == Qt::Desktop))
9143             d->resolvePalette();
9144         break;
9145 
9146     case QEvent::ToolBarChange:
9147     case QEvent::ActivationChange:
9148     case QEvent::EnabledChange:
9149     case QEvent::FontChange:
9150     case QEvent::StyleChange:
9151     case QEvent::PaletteChange:
9152     case QEvent::WindowTitleChange:
9153     case QEvent::IconTextChange:
9154     case QEvent::ModifiedChange:
9155     case QEvent::MouseTrackingChange:
9156     case QEvent::TabletTrackingChange:
9157     case QEvent::ParentChange:
9158     case QEvent::LocaleChange:
9159     case QEvent::MacSizeChange:
9160     case QEvent::ContentsRectChange:
9161     case QEvent::ThemeChange:
9162     case QEvent::ReadOnlyChange:
9163         changeEvent(event);
9164         break;
9165 
9166     case QEvent::WindowStateChange: {
9167         const bool wasMinimized = static_cast<const QWindowStateChangeEvent *>(event)->oldState() & Qt::WindowMinimized;
9168         if (wasMinimized != isMinimized()) {
9169             QWidget *widget = const_cast<QWidget *>(this);
9170             if (wasMinimized) {
9171                 // Always send the spontaneous events here, otherwise it can break the application!
9172                 if (!d->childrenShownByExpose) {
9173                     // Show widgets only when they are not yet shown by the expose event
9174                     d->showChildren(true);
9175                     QShowEvent showEvent;
9176                     QCoreApplication::sendSpontaneousEvent(widget, &showEvent);
9177                 }
9178                 d->childrenHiddenByWState = false; // Set it always to "false" when window is restored
9179             } else {
9180                 QHideEvent hideEvent;
9181                 QCoreApplication::sendSpontaneousEvent(widget, &hideEvent);
9182                 d->hideChildren(true);
9183                 d->childrenHiddenByWState = true;
9184             }
9185             d->childrenShownByExpose = false; // Set it always to "false" when window state changes
9186         }
9187         changeEvent(event);
9188     }
9189         break;
9190 
9191     case QEvent::WindowActivate:
9192     case QEvent::WindowDeactivate: {
9193         if (isVisible() && !palette().isEqual(QPalette::Active, QPalette::Inactive))
9194             update();
9195         QList<QObject*> childList = d->children;
9196         for (int i = 0; i < childList.size(); ++i) {
9197             QWidget *w = qobject_cast<QWidget *>(childList.at(i));
9198             if (w && w->isVisible() && !w->isWindow())
9199                 QApplication::sendEvent(w, event);
9200         }
9201         break; }
9202 
9203     case QEvent::LanguageChange:
9204         changeEvent(event);
9205         {
9206             QList<QObject*> childList = d->children;
9207             for (int i = 0; i < childList.size(); ++i) {
9208                 QObject *o = childList.at(i);
9209                 if (o)
9210                     QApplication::sendEvent(o, event);
9211             }
9212         }
9213         update();
9214         break;
9215 
9216     case QEvent::ApplicationLayoutDirectionChange:
9217         d->resolveLayoutDirection();
9218         break;
9219 
9220     case QEvent::LayoutDirectionChange:
9221         if (d->layout)
9222             d->layout->invalidate();
9223         update();
9224         changeEvent(event);
9225         break;
9226     case QEvent::UpdateRequest:
9227         d->syncBackingStore();
9228         break;
9229     case QEvent::UpdateLater:
9230         update(static_cast<QUpdateLaterEvent*>(event)->region());
9231         break;
9232     case QEvent::StyleAnimationUpdate:
9233         if (isVisible() && !window()->isMinimized()) {
9234             event->accept();
9235             update();
9236         }
9237         break;
9238 
9239     case QEvent::WindowBlocked:
9240     case QEvent::WindowUnblocked:
9241         if (!d->children.isEmpty()) {
9242             QWidget *modalWidget = QApplication::activeModalWidget();
9243             for (int i = 0; i < d->children.size(); ++i) {
9244                 QObject *o = d->children.at(i);
9245                 if (o && o != modalWidget && o->isWidgetType()) {
9246                     QWidget *w  = static_cast<QWidget *>(o);
9247                     // do not forward the event to child windows; QApplication does this for us
9248                     if (!w->isWindow())
9249                         QApplication::sendEvent(w, event);
9250                 }
9251             }
9252         }
9253 #if 0 // Used to be included in Qt4 for Q_WS_WIN
9254             setDisabledStyle(this, (event->type() == QEvent::WindowBlocked));
9255 #endif
9256         break;
9257 #ifndef QT_NO_TOOLTIP
9258     case QEvent::ToolTip:
9259         if (!d->toolTip.isEmpty())
9260             QToolTip::showText(static_cast<QHelpEvent*>(event)->globalPos(), d->toolTip, this, QRect(), d->toolTipDuration);
9261         else
9262             event->ignore();
9263         break;
9264 #endif
9265 #if QT_CONFIG(whatsthis)
9266     case QEvent::WhatsThis:
9267         if (d->whatsThis.size())
9268             QWhatsThis::showText(static_cast<QHelpEvent *>(event)->globalPos(), d->whatsThis, this);
9269         else
9270             event->ignore();
9271         break;
9272     case QEvent::QueryWhatsThis:
9273         if (d->whatsThis.isEmpty())
9274             event->ignore();
9275         break;
9276 #endif
9277     case QEvent::EmbeddingControl:
9278         d->topData()->frameStrut.setCoords(0 ,0, 0, 0);
9279         data->fstrut_dirty = false;
9280 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_X11 */
9281         d->topData()->embedded = 1;
9282 #endif
9283         break;
9284 #ifndef QT_NO_ACTION
9285     case QEvent::ActionAdded:
9286     case QEvent::ActionRemoved:
9287     case QEvent::ActionChanged:
9288         actionEvent((QActionEvent*)event);
9289         break;
9290 #endif
9291 
9292     case QEvent::KeyboardLayoutChange:
9293         {
9294             changeEvent(event);
9295 
9296             // inform children of the change
9297             QList<QObject*> childList = d->children;
9298             for (int i = 0; i < childList.size(); ++i) {
9299                 QWidget *w = qobject_cast<QWidget *>(childList.at(i));
9300                 if (w && w->isVisible() && !w->isWindow())
9301                     QApplication::sendEvent(w, event);
9302             }
9303             break;
9304         }
9305 #if 0 // Used to be included in Qt4 for Q_WS_MAC
9306     case QEvent::MacGLWindowChange:
9307         d->needWindowChange = false;
9308         break;
9309 #endif
9310     case QEvent::TouchBegin:
9311     case QEvent::TouchUpdate:
9312     case QEvent::TouchEnd:
9313     case QEvent::TouchCancel:
9314     {
9315         event->ignore();
9316         break;
9317     }
9318 #ifndef QT_NO_GESTURES
9319     case QEvent::Gesture:
9320         event->ignore();
9321         break;
9322 #endif
9323     case QEvent::ScreenChangeInternal:
9324         if (const QTLWExtra *te = d->maybeTopData()) {
9325             const QWindow *win = te->window;
9326             d->setWinId((win && win->handle()) ? win->handle()->winId() : 0);
9327         }
9328         if (d->data.fnt.d->dpi != logicalDpiY())
9329             d->updateFont(d->data.fnt);
9330 #ifndef QT_NO_OPENGL
9331         d->renderToTextureReallyDirty = 1;
9332 #endif
9333         break;
9334 #ifndef QT_NO_PROPERTIES
9335     case QEvent::DynamicPropertyChange: {
9336         const QByteArray &propName = static_cast<QDynamicPropertyChangeEvent *>(event)->propertyName();
9337         if (propName.length() == 13 && !qstrncmp(propName, "_q_customDpi", 12)) {
9338             uint value = property(propName.constData()).toUInt();
9339             if (!d->extra)
9340                 d->createExtra();
9341             const char axis = propName.at(12);
9342             if (axis == 'X')
9343                 d->extra->customDpiX = value;
9344             else if (axis == 'Y')
9345                 d->extra->customDpiY = value;
9346             d->updateFont(d->data.fnt);
9347         }
9348         if (windowHandle() && !qstrncmp(propName, "_q_platform_", 12))
9349             windowHandle()->setProperty(propName, property(propName));
9350         Q_FALLTHROUGH();
9351     }
9352 #endif
9353     default:
9354         return QObject::event(event);
9355     }
9356     return true;
9357 }
9358 
9359 /*!
9360   This event handler can be reimplemented to handle state changes.
9361 
9362   The state being changed in this event can be retrieved through the \a event
9363   supplied.
9364 
9365   Change events include: QEvent::ToolBarChange,
9366   QEvent::ActivationChange, QEvent::EnabledChange, QEvent::FontChange,
9367   QEvent::StyleChange, QEvent::PaletteChange,
9368   QEvent::WindowTitleChange, QEvent::IconTextChange,
9369   QEvent::ModifiedChange, QEvent::MouseTrackingChange,
9370   QEvent::ParentChange, QEvent::WindowStateChange,
9371   QEvent::LanguageChange, QEvent::LocaleChange,
9372   QEvent::LayoutDirectionChange, QEvent::ReadOnlyChange.
9373 
9374 */
9375 void QWidget::changeEvent(QEvent * event)
9376 {
9377     switch(event->type()) {
9378     case QEvent::EnabledChange: {
9379         update();
9380 #ifndef QT_NO_ACCESSIBILITY
9381         QAccessible::State s;
9382         s.disabled = true;
9383         QAccessibleStateChangeEvent event(this, s);
9384         QAccessible::updateAccessibility(&event);
9385 #endif
9386         break;
9387     }
9388 
9389     case QEvent::FontChange:
9390     case QEvent::StyleChange: {
9391         Q_D(QWidget);
9392         update();
9393         updateGeometry();
9394         if (d->layout)
9395             d->layout->invalidate();
9396         break;
9397     }
9398 
9399     case QEvent::PaletteChange:
9400         update();
9401         break;
9402 
9403     case QEvent::ThemeChange:
9404         if (QApplication::desktopSettingsAware() && windowType() != Qt::Desktop
9405             && qApp && !QApplication::closingDown()) {
9406             if (testAttribute(Qt::WA_WState_Polished))
9407                 QApplication::style()->unpolish(this);
9408             if (testAttribute(Qt::WA_WState_Polished))
9409                 QApplication::style()->polish(this);
9410             QEvent styleChangedEvent(QEvent::StyleChange);
9411             QCoreApplication::sendEvent(this, &styleChangedEvent);
9412             if (isVisible())
9413                 update();
9414         }
9415         break;
9416 
9417 #ifdef Q_OS_MAC
9418     case QEvent::MacSizeChange:
9419         updateGeometry();
9420         break;
9421 #elif 0 // Used to be included in Qt4 for Q_WS_MAC
9422     case QEvent::ToolTipChange:
9423     case QEvent::MouseTrackingChange:
9424         qt_mac_update_mouseTracking(this);
9425         break;
9426 #endif
9427 
9428     default:
9429         break;
9430     }
9431 }
9432 
9433 /*!
9434     This event handler, for event \a event, can be reimplemented in a
9435     subclass to receive mouse move events for the widget.
9436 
9437     If mouse tracking is switched off, mouse move events only occur if
9438     a mouse button is pressed while the mouse is being moved. If mouse
9439     tracking is switched on, mouse move events occur even if no mouse
9440     button is pressed.
9441 
9442     QMouseEvent::pos() reports the position of the mouse cursor,
9443     relative to this widget. For press and release events, the
9444     position is usually the same as the position of the last mouse
9445     move event, but it might be different if the user's hand shakes.
9446     This is a feature of the underlying window system, not Qt.
9447 
9448     If you want to show a tooltip immediately, while the mouse is
9449     moving (e.g., to get the mouse coordinates with QMouseEvent::pos()
9450     and show them as a tooltip), you must first enable mouse tracking
9451     as described above. Then, to ensure that the tooltip is updated
9452     immediately, you must call QToolTip::showText() instead of
9453     setToolTip() in your implementation of mouseMoveEvent().
9454 
9455     \sa setMouseTracking(), mousePressEvent(), mouseReleaseEvent(),
9456     mouseDoubleClickEvent(), event(), QMouseEvent, {Scribble Example}
9457 */
9458 
9459 void QWidget::mouseMoveEvent(QMouseEvent *event)
9460 {
9461     event->ignore();
9462 }
9463 
9464 /*!
9465     This event handler, for event \a event, can be reimplemented in a
9466     subclass to receive mouse press events for the widget.
9467 
9468     If you create new widgets in the mousePressEvent() the
9469     mouseReleaseEvent() may not end up where you expect, depending on
9470     the underlying window system (or X11 window manager), the widgets'
9471     location and maybe more.
9472 
9473     The default implementation implements the closing of popup widgets
9474     when you click outside the window. For other widget types it does
9475     nothing.
9476 
9477     \sa mouseReleaseEvent(), mouseDoubleClickEvent(),
9478     mouseMoveEvent(), event(), QMouseEvent, {Scribble Example}
9479 */
9480 
9481 void QWidget::mousePressEvent(QMouseEvent *event)
9482 {
9483     event->ignore();
9484     if ((windowType() == Qt::Popup)) {
9485         event->accept();
9486         QWidget* w;
9487         while ((w = QApplication::activePopupWidget()) && w != this){
9488             w->close();
9489             if (QApplication::activePopupWidget() == w) // widget does not want to disappear
9490                 w->hide(); // hide at least
9491         }
9492         if (!rect().contains(event->pos())){
9493             close();
9494         }
9495     }
9496 }
9497 
9498 /*!
9499     This event handler, for event \a event, can be reimplemented in a
9500     subclass to receive mouse release events for the widget.
9501 
9502     \sa mousePressEvent(), mouseDoubleClickEvent(),
9503     mouseMoveEvent(), event(), QMouseEvent, {Scribble Example}
9504 */
9505 
9506 void QWidget::mouseReleaseEvent(QMouseEvent *event)
9507 {
9508     event->ignore();
9509 }
9510 
9511 /*!
9512     This event handler, for event \a event, can be reimplemented in a
9513     subclass to receive mouse double click events for the widget.
9514 
9515     The default implementation calls mousePressEvent().
9516 
9517     \note The widget will also receive mouse press and mouse release
9518     events in addition to the double click event. It is up to the
9519     developer to ensure that the application interprets these events
9520     correctly.
9521 
9522     \sa mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(),
9523     event(), QMouseEvent
9524 */
9525 
9526 void QWidget::mouseDoubleClickEvent(QMouseEvent *event)
9527 {
9528     mousePressEvent(event);
9529 }
9530 
9531 #if QT_CONFIG(wheelevent)
9532 /*!
9533     This event handler, for event \a event, can be reimplemented in a
9534     subclass to receive wheel events for the widget.
9535 
9536     If you reimplement this handler, it is very important that you
9537     \l{QEvent}{ignore()} the event if you do not handle
9538     it, so that the widget's parent can interpret it.
9539 
9540     The default implementation ignores the event.
9541 
9542     \sa QEvent::ignore(), QEvent::accept(), event(),
9543     QWheelEvent
9544 */
9545 
9546 void QWidget::wheelEvent(QWheelEvent *event)
9547 {
9548     event->ignore();
9549 }
9550 #endif // QT_CONFIG(wheelevent)
9551 
9552 #if QT_CONFIG(tabletevent)
9553 /*!
9554     This event handler, for event \a event, can be reimplemented in a
9555     subclass to receive tablet events for the widget.
9556 
9557     If you reimplement this handler, it is very important that you
9558     \l{QEvent}{ignore()} the event if you do not handle
9559     it, so that the widget's parent can interpret it.
9560 
9561     The default implementation ignores the event.
9562 
9563     If tablet tracking is switched off, tablet move events only occur if the
9564     stylus is in contact with the tablet, or at least one stylus button is
9565     pressed, while the stylus is being moved. If tablet tracking is switched on,
9566     tablet move events occur even while the stylus is hovering in proximity of
9567     the tablet, with no buttons pressed.
9568 
9569     \sa QEvent::ignore(), QEvent::accept(), event(), setTabletTracking(),
9570     QTabletEvent
9571 */
9572 
9573 void QWidget::tabletEvent(QTabletEvent *event)
9574 {
9575     event->ignore();
9576 }
9577 #endif // QT_CONFIG(tabletevent)
9578 
9579 /*!
9580     This event handler, for event \a event, can be reimplemented in a
9581     subclass to receive key press events for the widget.
9582 
9583     A widget must call setFocusPolicy() to accept focus initially and
9584     have focus in order to receive a key press event.
9585 
9586     If you reimplement this handler, it is very important that you
9587     call the base class implementation if you do not act upon the key.
9588 
9589     The default implementation closes popup widgets if the user
9590     presses the key sequence for QKeySequence::Cancel (typically the
9591     Escape key). Otherwise the event is ignored, so that the widget's
9592     parent can interpret it.
9593 
9594     Note that QKeyEvent starts with isAccepted() == true, so you do not
9595     need to call QKeyEvent::accept() - just do not call the base class
9596     implementation if you act upon the key.
9597 
9598     \sa keyReleaseEvent(), setFocusPolicy(),
9599     focusInEvent(), focusOutEvent(), event(), QKeyEvent, {Tetrix Example}
9600 */
9601 
9602 void QWidget::keyPressEvent(QKeyEvent *event)
9603 {
9604 #ifndef QT_NO_SHORTCUT
9605     if ((windowType() == Qt::Popup) && event->matches(QKeySequence::Cancel)) {
9606         event->accept();
9607         close();
9608     } else
9609 #endif
9610     {
9611         event->ignore();
9612     }
9613 }
9614 
9615 /*!
9616     This event handler, for event \a event, can be reimplemented in a
9617     subclass to receive key release events for the widget.
9618 
9619     A widget must \l{setFocusPolicy()}{accept focus}
9620     initially and \l{hasFocus()}{have focus} in order to
9621     receive a key release event.
9622 
9623     If you reimplement this handler, it is very important that you
9624     call the base class implementation if you do not act upon the key.
9625 
9626     The default implementation ignores the event, so that the widget's
9627     parent can interpret it.
9628 
9629     Note that QKeyEvent starts with isAccepted() == true, so you do not
9630     need to call QKeyEvent::accept() - just do not call the base class
9631     implementation if you act upon the key.
9632 
9633     \sa keyPressEvent(), QEvent::ignore(), setFocusPolicy(),
9634     focusInEvent(), focusOutEvent(), event(), QKeyEvent
9635 */
9636 
9637 void QWidget::keyReleaseEvent(QKeyEvent *event)
9638 {
9639     event->ignore();
9640 }
9641 
9642 /*!
9643     \fn void QWidget::focusInEvent(QFocusEvent *event)
9644 
9645     This event handler can be reimplemented in a subclass to receive
9646     keyboard focus events (focus received) for the widget. The event
9647     is passed in the \a event parameter
9648 
9649     A widget normally must setFocusPolicy() to something other than
9650     Qt::NoFocus in order to receive focus events. (Note that the
9651     application programmer can call setFocus() on any widget, even
9652     those that do not normally accept focus.)
9653 
9654     The default implementation updates the widget (except for windows
9655     that do not specify a focusPolicy()).
9656 
9657     \sa focusOutEvent(), setFocusPolicy(), keyPressEvent(),
9658     keyReleaseEvent(), event(), QFocusEvent
9659 */
9660 
9661 void QWidget::focusInEvent(QFocusEvent *)
9662 {
9663     if (focusPolicy() != Qt::NoFocus || !isWindow()) {
9664         update();
9665     }
9666 }
9667 
9668 /*!
9669     \fn void QWidget::focusOutEvent(QFocusEvent *event)
9670 
9671     This event handler can be reimplemented in a subclass to receive
9672     keyboard focus events (focus lost) for the widget. The events is
9673     passed in the \a event parameter.
9674 
9675     A widget normally must setFocusPolicy() to something other than
9676     Qt::NoFocus in order to receive focus events. (Note that the
9677     application programmer can call setFocus() on any widget, even
9678     those that do not normally accept focus.)
9679 
9680     The default implementation updates the widget (except for windows
9681     that do not specify a focusPolicy()).
9682 
9683     \sa focusInEvent(), setFocusPolicy(), keyPressEvent(),
9684     keyReleaseEvent(), event(), QFocusEvent
9685 */
9686 
9687 void QWidget::focusOutEvent(QFocusEvent *)
9688 {
9689     if (focusPolicy() != Qt::NoFocus || !isWindow())
9690         update();
9691 
9692 #if !defined(QT_PLATFORM_UIKIT)
9693     // FIXME: revisit autoSIP logic, QTBUG-42906
9694     if (qApp->autoSipEnabled() && testAttribute(Qt::WA_InputMethodEnabled))
9695         QGuiApplication::inputMethod()->hide();
9696 #endif
9697 }
9698 
9699 /*!
9700     \fn void QWidget::enterEvent(QEvent *event)
9701 
9702     This event handler can be reimplemented in a subclass to receive
9703     widget enter events which are passed in the \a event parameter.
9704 
9705     An event is sent to the widget when the mouse cursor enters the
9706     widget.
9707 
9708     \sa leaveEvent(), mouseMoveEvent(), event()
9709 */
9710 
9711 void QWidget::enterEvent(QEvent *)
9712 {
9713 }
9714 
9715 // ### Qt 6: void QWidget::enterEvent(QEnterEvent *).
9716 
9717 /*!
9718     \fn void QWidget::leaveEvent(QEvent *event)
9719 
9720     This event handler can be reimplemented in a subclass to receive
9721     widget leave events which are passed in the \a event parameter.
9722 
9723     A leave event is sent to the widget when the mouse cursor leaves
9724     the widget.
9725 
9726     \sa enterEvent(), mouseMoveEvent(), event()
9727 */
9728 
9729 void QWidget::leaveEvent(QEvent *)
9730 {
9731 }
9732 
9733 /*!
9734     \fn void QWidget::paintEvent(QPaintEvent *event)
9735 
9736     This event handler can be reimplemented in a subclass to receive paint
9737     events passed in \a event.
9738 
9739     A paint event is a request to repaint all or part of a widget. It can
9740     happen for one of the following reasons:
9741 
9742     \list
9743         \li repaint() or update() was invoked,
9744         \li the widget was obscured and has now been uncovered, or
9745         \li many other reasons.
9746     \endlist
9747 
9748     Many widgets can simply repaint their entire surface when asked to, but
9749     some slow widgets need to optimize by painting only the requested region:
9750     QPaintEvent::region(). This speed optimization does not change the result,
9751     as painting is clipped to that region during event processing. QListView
9752     and QTableView do this, for example.
9753 
9754     Qt also tries to speed up painting by merging multiple paint events into
9755     one. When update() is called several times or the window system sends
9756     several paint events, Qt merges these events into one event with a larger
9757     region (see QRegion::united()). The repaint() function does not permit this
9758     optimization, so we suggest using update() whenever possible.
9759 
9760     When the paint event occurs, the update region has normally been erased, so
9761     you are painting on the widget's background.
9762 
9763     The background can be set using setBackgroundRole() and setPalette().
9764 
9765     Since Qt 4.0, QWidget automatically double-buffers its painting, so there
9766     is no need to write double-buffering code in paintEvent() to avoid flicker.
9767 
9768     \note Generally, you should refrain from calling update() or repaint()
9769     \b{inside} a paintEvent(). For example, calling update() or repaint() on
9770     children inside a paintEvent() results in undefined behavior; the child may
9771     or may not get a paint event.
9772 
9773     \warning If you are using a custom paint engine without Qt's backingstore,
9774     Qt::WA_PaintOnScreen must be set. Otherwise, QWidget::paintEngine() will
9775     never be called; the backingstore will be used instead.
9776 
9777     \sa event(), repaint(), update(), QPainter, QPixmap, QPaintEvent,
9778     {Analog Clock Example}
9779 */
9780 
9781 void QWidget::paintEvent(QPaintEvent *)
9782 {
9783 }
9784 
9785 
9786 /*!
9787     \fn void QWidget::moveEvent(QMoveEvent *event)
9788 
9789     This event handler can be reimplemented in a subclass to receive
9790     widget move events which are passed in the \a event parameter.
9791     When the widget receives this event, it is already at the new
9792     position.
9793 
9794     The old position is accessible through QMoveEvent::oldPos().
9795 
9796     \sa resizeEvent(), event(), move(), QMoveEvent
9797 */
9798 
9799 void QWidget::moveEvent(QMoveEvent *)
9800 {
9801 }
9802 
9803 
9804 /*!
9805     This event handler can be reimplemented in a subclass to receive
9806     widget resize events which are passed in the \a event parameter.
9807     When resizeEvent() is called, the widget already has its new
9808     geometry. The old size is accessible through
9809     QResizeEvent::oldSize().
9810 
9811     The widget will be erased and receive a paint event immediately
9812     after processing the resize event. No drawing need be (or should
9813     be) done inside this handler.
9814 
9815 
9816     \sa moveEvent(), event(), resize(), QResizeEvent, paintEvent(),
9817         {Scribble Example}
9818 */
9819 
9820 void QWidget::resizeEvent(QResizeEvent * /* event */)
9821 {
9822 }
9823 
9824 #ifndef QT_NO_ACTION
9825 /*!
9826     \fn void QWidget::actionEvent(QActionEvent *event)
9827 
9828     This event handler is called with the given \a event whenever the
9829     widget's actions are changed.
9830 
9831     \sa addAction(), insertAction(), removeAction(), actions(), QActionEvent
9832 */
9833 void QWidget::actionEvent(QActionEvent *)
9834 {
9835 
9836 }
9837 #endif
9838 
9839 /*!
9840     This event handler is called with the given \a event when Qt receives a window
9841     close request for a top-level widget from the window system.
9842 
9843     By default, the event is accepted and the widget is closed. You can reimplement
9844     this function to change the way the widget responds to window close requests.
9845     For example, you can prevent the window from closing by calling \l{QEvent::}{ignore()}
9846     on all events.
9847 
9848     Main window applications typically use reimplementations of this function to check
9849     whether the user's work has been saved and ask for permission before closing.
9850     For example, the \l{Application Example} uses a helper function to determine whether
9851     or not to close the window:
9852 
9853     \snippet mainwindows/application/mainwindow.cpp 3
9854     \snippet mainwindows/application/mainwindow.cpp 4
9855 
9856     \sa event(), hide(), close(), QCloseEvent, {Application Example}
9857 */
9858 
9859 void QWidget::closeEvent(QCloseEvent *event)
9860 {
9861     event->accept();
9862 }
9863 
9864 #ifndef QT_NO_CONTEXTMENU
9865 /*!
9866     This event handler, for event \a event, can be reimplemented in a
9867     subclass to receive widget context menu events.
9868 
9869     The handler is called when the widget's \l contextMenuPolicy is
9870     Qt::DefaultContextMenu.
9871 
9872     The default implementation ignores the context event.
9873     See the \l QContextMenuEvent documentation for more details.
9874 
9875     \sa event(), QContextMenuEvent, customContextMenuRequested()
9876 */
9877 
9878 void QWidget::contextMenuEvent(QContextMenuEvent *event)
9879 {
9880     event->ignore();
9881 }
9882 #endif // QT_NO_CONTEXTMENU
9883 
9884 
9885 /*!
9886     This event handler, for event \a event, can be reimplemented in a
9887     subclass to receive Input Method composition events. This handler
9888     is called when the state of the input method changes.
9889 
9890     Note that when creating custom text editing widgets, the
9891     Qt::WA_InputMethodEnabled window attribute must be set explicitly
9892     (using the setAttribute() function) in order to receive input
9893     method events.
9894 
9895     The default implementation calls event->ignore(), which rejects the
9896     Input Method event. See the \l QInputMethodEvent documentation for more
9897     details.
9898 
9899     \sa event(), QInputMethodEvent
9900 */
9901 void QWidget::inputMethodEvent(QInputMethodEvent *event)
9902 {
9903     event->ignore();
9904 }
9905 
9906 /*!
9907     This method is only relevant for input widgets. It is used by the
9908     input method to query a set of properties of the widget to be
9909     able to support complex input method operations as support for
9910     surrounding text and reconversions.
9911 
9912     \a query specifies which property is queried.
9913 
9914     \sa inputMethodEvent(), QInputMethodEvent, QInputMethodQueryEvent, inputMethodHints
9915 */
9916 QVariant QWidget::inputMethodQuery(Qt::InputMethodQuery query) const
9917 {
9918     switch(query) {
9919     case Qt::ImCursorRectangle:
9920         return QRect(width()/2, 0, 1, height());
9921     case Qt::ImFont:
9922         return font();
9923     case Qt::ImAnchorPosition:
9924         // Fallback.
9925         return inputMethodQuery(Qt::ImCursorPosition);
9926     case Qt::ImHints:
9927         return (int)inputMethodHints();
9928     case Qt::ImInputItemClipRectangle:
9929         return d_func()->clipRect();
9930     default:
9931         return QVariant();
9932     }
9933 }
9934 
9935 /*!
9936     \property QWidget::inputMethodHints
9937     \brief What input method specific hints the widget has.
9938 
9939     This is only relevant for input widgets. It is used by
9940     the input method to retrieve hints as to how the input method
9941     should operate. For example, if the Qt::ImhFormattedNumbersOnly flag
9942     is set, the input method may change its visual components to reflect
9943     that only numbers can be entered.
9944 
9945     \warning Some widgets require certain flags in order to work as
9946     intended. To set a flag, do \c{w->setInputMethodHints(w->inputMethodHints()|f)}
9947     instead of \c{w->setInputMethodHints(f)}.
9948 
9949     \note The flags are only hints, so the particular input method
9950           implementation is free to ignore them. If you want to be
9951           sure that a certain type of characters are entered,
9952           you should also set a QValidator on the widget.
9953 
9954     The default value is Qt::ImhNone.
9955 
9956     \since 4.6
9957 
9958     \sa inputMethodQuery()
9959 */
9960 Qt::InputMethodHints QWidget::inputMethodHints() const
9961 {
9962 #ifndef QT_NO_IM
9963     const QWidgetPrivate *priv = d_func();
9964     while (priv->inheritsInputMethodHints) {
9965         priv = priv->q_func()->parentWidget()->d_func();
9966         Q_ASSERT(priv);
9967     }
9968     return priv->imHints;
9969 #else //QT_NO_IM
9970     return 0;
9971 #endif //QT_NO_IM
9972 }
9973 
9974 void QWidget::setInputMethodHints(Qt::InputMethodHints hints)
9975 {
9976 #ifndef QT_NO_IM
9977     Q_D(QWidget);
9978     if (d->imHints == hints)
9979         return;
9980     d->imHints = hints;
9981     if (this == QGuiApplication::focusObject())
9982         QGuiApplication::inputMethod()->update(Qt::ImHints);
9983 #else
9984     Q_UNUSED(hints);
9985 #endif //QT_NO_IM
9986 }
9987 
9988 
9989 #ifndef QT_NO_DRAGANDDROP
9990 
9991 /*!
9992     \fn void QWidget::dragEnterEvent(QDragEnterEvent *event)
9993 
9994     This event handler is called when a drag is in progress and the
9995     mouse enters this widget. The event is passed in the \a event parameter.
9996 
9997     If the event is ignored, the widget won't receive any \l{dragMoveEvent()}{drag
9998     move events}.
9999 
10000     See the \l{dnd.html}{Drag-and-drop documentation} for an
10001     overview of how to provide drag-and-drop in your application.
10002 
10003     \sa QDrag, QDragEnterEvent
10004 */
10005 void QWidget::dragEnterEvent(QDragEnterEvent *)
10006 {
10007 }
10008 
10009 /*!
10010     \fn void QWidget::dragMoveEvent(QDragMoveEvent *event)
10011 
10012     This event handler is called if a drag is in progress, and when
10013     any of the following conditions occur: the cursor enters this widget,
10014     the cursor moves within this widget, or a modifier key is pressed on
10015     the keyboard while this widget has the focus. The event is passed
10016     in the \a event parameter.
10017 
10018     See the \l{dnd.html}{Drag-and-drop documentation} for an
10019     overview of how to provide drag-and-drop in your application.
10020 
10021     \sa QDrag, QDragMoveEvent
10022 */
10023 void QWidget::dragMoveEvent(QDragMoveEvent *)
10024 {
10025 }
10026 
10027 /*!
10028     \fn void QWidget::dragLeaveEvent(QDragLeaveEvent *event)
10029 
10030     This event handler is called when a drag is in progress and the
10031     mouse leaves this widget. The event is passed in the \a event
10032     parameter.
10033 
10034     See the \l{dnd.html}{Drag-and-drop documentation} for an
10035     overview of how to provide drag-and-drop in your application.
10036 
10037     \sa QDrag, QDragLeaveEvent
10038 */
10039 void QWidget::dragLeaveEvent(QDragLeaveEvent *)
10040 {
10041 }
10042 
10043 /*!
10044     \fn void QWidget::dropEvent(QDropEvent *event)
10045 
10046     This event handler is called when the drag is dropped on this
10047     widget. The event is passed in the \a event parameter.
10048 
10049     See the \l{dnd.html}{Drag-and-drop documentation} for an
10050     overview of how to provide drag-and-drop in your application.
10051 
10052     \sa QDrag, QDropEvent
10053 */
10054 void QWidget::dropEvent(QDropEvent *)
10055 {
10056 }
10057 
10058 #endif // QT_NO_DRAGANDDROP
10059 
10060 /*!
10061     \fn void QWidget::showEvent(QShowEvent *event)
10062 
10063     This event handler can be reimplemented in a subclass to receive
10064     widget show events which are passed in the \a event parameter.
10065 
10066     Non-spontaneous show events are sent to widgets immediately
10067     before they are shown. The spontaneous show events of windows are
10068     delivered afterwards.
10069 
10070     Note: A widget receives spontaneous show and hide events when its
10071     mapping status is changed by the window system, e.g. a spontaneous
10072     hide event when the user minimizes the window, and a spontaneous
10073     show event when the window is restored again. After receiving a
10074     spontaneous hide event, a widget is still considered visible in
10075     the sense of isVisible().
10076 
10077     \sa visible, event(), QShowEvent
10078 */
10079 void QWidget::showEvent(QShowEvent *)
10080 {
10081 }
10082 
10083 /*!
10084     \fn void QWidget::hideEvent(QHideEvent *event)
10085 
10086     This event handler can be reimplemented in a subclass to receive
10087     widget hide events. The event is passed in the \a event parameter.
10088 
10089     Hide events are sent to widgets immediately after they have been
10090     hidden.
10091 
10092     Note: A widget receives spontaneous show and hide events when its
10093     mapping status is changed by the window system, e.g. a spontaneous
10094     hide event when the user minimizes the window, and a spontaneous
10095     show event when the window is restored again. After receiving a
10096     spontaneous hide event, a widget is still considered visible in
10097     the sense of isVisible().
10098 
10099     \sa visible, event(), QHideEvent
10100 */
10101 void QWidget::hideEvent(QHideEvent *)
10102 {
10103 }
10104 
10105 /*!
10106     This special event handler can be reimplemented in a subclass to
10107     receive native platform events identified by \a eventType
10108     which are passed in the \a message parameter.
10109 
10110     In your reimplementation of this function, if you want to stop the
10111     event being handled by Qt, return true and set \a result.
10112     If you return false, this native event is passed back to Qt,
10113     which translates the event into a Qt event and sends it to the widget.
10114 
10115     \note Events are only delivered to this event handler if the widget is
10116     has a native Window handle.
10117 
10118     \note This function superseedes the event filter functions
10119     x11Event(), winEvent() and macEvent() of Qt 4.
10120 
10121     \table
10122     \header \li Platform \li Event Type Identifier \li Message Type \li Result Type
10123     \row \li Windows \li "windows_generic_MSG" \li MSG * \li LRESULT
10124     \row \li macOS \li "NSEvent" \li NSEvent * \li
10125     \endtable
10126 */
10127 
10128 bool QWidget::nativeEvent(const QByteArray &eventType, void *message, long *result)
10129 {
10130     Q_UNUSED(eventType);
10131     Q_UNUSED(message);
10132     Q_UNUSED(result);
10133     return false;
10134 }
10135 
10136 /*!
10137     Ensures that the widget and its children have been polished by
10138     QStyle (i.e., have a proper font and palette).
10139 
10140     QWidget calls this function after it has been fully constructed
10141     but before it is shown the very first time. You can call this
10142     function if you want to ensure that the widget is polished before
10143     doing an operation, e.g., the correct font size might be needed in
10144     the widget's sizeHint() reimplementation. Note that this function
10145     \e is called from the default implementation of sizeHint().
10146 
10147     Polishing is useful for final initialization that must happen after
10148     all constructors (from base classes as well as from subclasses)
10149     have been called.
10150 
10151     If you need to change some settings when a widget is polished,
10152     reimplement event() and handle the QEvent::Polish event type.
10153 
10154     \b{Note:} The function is declared const so that it can be called from
10155     other const functions (e.g., sizeHint()).
10156 
10157     \sa event()
10158 */
10159 void QWidget::ensurePolished() const
10160 {
10161     Q_D(const QWidget);
10162 
10163     const QMetaObject *m = metaObject();
10164     if (m == d->polished)
10165         return;
10166     d->polished = m;
10167 
10168     QEvent e(QEvent::Polish);
10169     QCoreApplication::sendEvent(const_cast<QWidget *>(this), &e);
10170 
10171     // polish children after 'this'
10172     QList<QObject*> children = d->children;
10173     for (int i = 0; i < children.size(); ++i) {
10174         QObject *o = children.at(i);
10175         if(!o->isWidgetType())
10176             continue;
10177         if (QWidget *w = qobject_cast<QWidget *>(o))
10178             w->ensurePolished();
10179     }
10180 
10181     if (d->parent && d->sendChildEvents) {
10182         QChildEvent e(QEvent::ChildPolished, const_cast<QWidget *>(this));
10183         QCoreApplication::sendEvent(d->parent, &e);
10184     }
10185 }
10186 
10187 /*!
10188     Returns the mask currently set on a widget. If no mask is set the
10189     return value will be an empty region.
10190 
10191     \sa setMask(), clearMask(), QRegion::isEmpty(), {Shaped Clock Example}
10192 */
10193 QRegion QWidget::mask() const
10194 {
10195     Q_D(const QWidget);
10196     return d->extra ? d->extra->mask : QRegion();
10197 }
10198 
10199 /*!
10200     Returns the layout manager that is installed on this widget, or 0
10201     if no layout manager is installed.
10202 
10203     The layout manager sets the geometry of the widget's children
10204     that have been added to the layout.
10205 
10206     \sa setLayout(), sizePolicy(), {Layout Management}
10207 */
10208 QLayout *QWidget::layout() const
10209 {
10210     return d_func()->layout;
10211 }
10212 
10213 
10214 /*!
10215     \fn void QWidget::setLayout(QLayout *layout)
10216 
10217     Sets the layout manager for this widget to \a layout.
10218 
10219     If there already is a layout manager installed on this widget,
10220     QWidget won't let you install another. You must first delete the
10221     existing layout manager (returned by layout()) before you can
10222     call setLayout() with the new layout.
10223 
10224     If \a layout is the layout manager on a different widget, setLayout()
10225     will reparent the layout and make it the layout manager for this widget.
10226 
10227     Example:
10228 
10229     \snippet layouts/layouts.cpp 24
10230 
10231     An alternative to calling this function is to pass this widget to
10232     the layout's constructor.
10233 
10234     The QWidget will take ownership of \a layout.
10235 
10236     \sa layout(), {Layout Management}
10237 */
10238 
10239 void QWidget::setLayout(QLayout *l)
10240 {
10241     if (Q_UNLIKELY(!l)) {
10242         qWarning("QWidget::setLayout: Cannot set layout to 0");
10243         return;
10244     }
10245     if (layout()) {
10246         if (Q_UNLIKELY(layout() != l))
10247             qWarning("QWidget::setLayout: Attempting to set QLayout \"%s\" on %s \"%s\", which already has a"
10248                      " layout", l->objectName().toLocal8Bit().data(), metaObject()->className(),
10249                      objectName().toLocal8Bit().data());
10250         return;
10251     }
10252 
10253     QObject *oldParent = l->parent();
10254     if (oldParent && oldParent != this) {
10255         if (oldParent->isWidgetType()) {
10256             // Steal the layout off a widget parent. Takes effect when
10257             // morphing laid-out container widgets in Designer.
10258             QWidget *oldParentWidget = static_cast<QWidget *>(oldParent);
10259             oldParentWidget->takeLayout();
10260         } else {
10261             qWarning("QWidget::setLayout: Attempting to set QLayout \"%s\" on %s \"%s\", when the QLayout already has a parent",
10262                      l->objectName().toLocal8Bit().data(), metaObject()->className(),
10263                      objectName().toLocal8Bit().data());
10264             return;
10265         }
10266     }
10267 
10268     Q_D(QWidget);
10269     l->d_func()->topLevel = true;
10270     d->layout = l;
10271     if (oldParent != this) {
10272         l->setParent(this);
10273         l->d_func()->reparentChildWidgets(this);
10274         l->invalidate();
10275     }
10276 
10277     if (isWindow() && d->maybeTopData())
10278         d->topData()->sizeAdjusted = false;
10279 }
10280 
10281 /*!
10282     \fn QLayout *QWidget::takeLayout()
10283 
10284     Remove the layout from the widget.
10285     \since 4.5
10286 */
10287 
10288 QLayout *QWidget::takeLayout()
10289 {
10290     Q_D(QWidget);
10291     QLayout *l =  layout();
10292     if (!l)
10293         return 0;
10294     d->layout = 0;
10295     l->setParent(0);
10296     return l;
10297 }
10298 
10299 /*!
10300     \property QWidget::sizePolicy
10301     \brief the default layout behavior of the widget
10302 
10303     If there is a QLayout that manages this widget's children, the
10304     size policy specified by that layout is used. If there is no such
10305     QLayout, the result of this function is used.
10306 
10307     The default policy is Preferred/Preferred, which means that the
10308     widget can be freely resized, but prefers to be the size
10309     sizeHint() returns. Button-like widgets set the size policy to
10310     specify that they may stretch horizontally, but are fixed
10311     vertically. The same applies to lineedit controls (such as
10312     QLineEdit, QSpinBox or an editable QComboBox) and other
10313     horizontally orientated widgets (such as QProgressBar).
10314     QToolButton's are normally square, so they allow growth in both
10315     directions. Widgets that support different directions (such as
10316     QSlider, QScrollBar or QHeader) specify stretching in the
10317     respective direction only. Widgets that can provide scroll bars
10318     (usually subclasses of QScrollArea) tend to specify that they can
10319     use additional space, and that they can make do with less than
10320     sizeHint().
10321 
10322     \sa sizeHint(), QLayout, QSizePolicy, updateGeometry()
10323 */
10324 QSizePolicy QWidget::sizePolicy() const
10325 {
10326     Q_D(const QWidget);
10327     return d->size_policy;
10328 }
10329 
10330 void QWidget::setSizePolicy(QSizePolicy policy)
10331 {
10332     Q_D(QWidget);
10333     setAttribute(Qt::WA_WState_OwnSizePolicy);
10334     if (policy == d->size_policy)
10335         return;
10336 
10337     if (d->size_policy.retainSizeWhenHidden() != policy.retainSizeWhenHidden())
10338         d->retainSizeWhenHiddenChanged = 1;
10339 
10340     d->size_policy = policy;
10341 
10342 #if QT_CONFIG(graphicsview)
10343     if (QWExtra *extra = d->extra) {
10344         if (extra->proxyWidget)
10345             extra->proxyWidget->setSizePolicy(policy);
10346     }
10347 #endif
10348 
10349     updateGeometry();
10350     d->retainSizeWhenHiddenChanged = 0;
10351 
10352     if (isWindow() && d->maybeTopData())
10353         d->topData()->sizeAdjusted = false;
10354 }
10355 
10356 /*!
10357     \fn void QWidget::setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)
10358     \overload
10359 
10360     Sets the size policy of the widget to \a horizontal and \a
10361     vertical, with standard stretch and no height-for-width.
10362 
10363     \sa QSizePolicy::QSizePolicy()
10364 */
10365 
10366 /*!
10367     Returns the preferred height for this widget, given the width \a w.
10368 
10369     If this widget has a layout, the default implementation returns
10370     the layout's preferred height.  if there is no layout, the default
10371     implementation returns -1 indicating that the preferred height
10372     does not depend on the width.
10373 */
10374 
10375 int QWidget::heightForWidth(int w) const
10376 {
10377     if (layout() && layout()->hasHeightForWidth())
10378         return layout()->totalHeightForWidth(w);
10379     return -1;
10380 }
10381 
10382 
10383 /*!
10384     \since 5.0
10385 
10386     Returns \c true if the widget's preferred height depends on its width; otherwise returns \c false.
10387 */
10388 bool QWidget::hasHeightForWidth() const
10389 {
10390     Q_D(const QWidget);
10391     return d->layout ? d->layout->hasHeightForWidth() : d->size_policy.hasHeightForWidth();
10392 }
10393 
10394 /*!
10395     \fn QWidget *QWidget::childAt(int x, int y) const
10396 
10397     Returns the visible child widget at the position (\a{x}, \a{y})
10398     in the widget's coordinate system. If there is no visible child
10399     widget at the specified position, the function returns 0.
10400 */
10401 
10402 /*!
10403     \overload
10404 
10405     Returns the visible child widget at point \a p in the widget's own
10406     coordinate system.
10407 */
10408 
10409 QWidget *QWidget::childAt(const QPoint &p) const
10410 {
10411     return d_func()->childAt_helper(p, false);
10412 }
10413 
10414 QWidget *QWidgetPrivate::childAt_helper(const QPoint &p, bool ignoreChildrenInDestructor) const
10415 {
10416     if (children.isEmpty())
10417         return 0;
10418 
10419     if (!pointInsideRectAndMask(p))
10420         return 0;
10421     return childAtRecursiveHelper(p, ignoreChildrenInDestructor);
10422 }
10423 
10424 QWidget *QWidgetPrivate::childAtRecursiveHelper(const QPoint &p, bool ignoreChildrenInDestructor) const
10425 {
10426     for (int i = children.size() - 1; i >= 0; --i) {
10427         QWidget *child = qobject_cast<QWidget *>(children.at(i));
10428         if (!child || child->isWindow() || child->isHidden() || child->testAttribute(Qt::WA_TransparentForMouseEvents)
10429             || (ignoreChildrenInDestructor && child->data->in_destructor)) {
10430             continue;
10431         }
10432 
10433         // Map the point 'p' from parent coordinates to child coordinates.
10434         QPoint childPoint = p;
10435         childPoint -= child->data->crect.topLeft();
10436 
10437         // Check if the point hits the child.
10438         if (!child->d_func()->pointInsideRectAndMask(childPoint))
10439             continue;
10440 
10441         // Do the same for the child's descendants.
10442         if (QWidget *w = child->d_func()->childAtRecursiveHelper(childPoint, ignoreChildrenInDestructor))
10443             return w;
10444 
10445         // We have found our target; namely the child at position 'p'.
10446         return child;
10447     }
10448     return 0;
10449 }
10450 
10451 void QWidgetPrivate::updateGeometry_helper(bool forceUpdate)
10452 {
10453     Q_Q(QWidget);
10454     if (widgetItem)
10455         widgetItem->invalidateSizeCache();
10456     QWidget *parent;
10457     if (forceUpdate || !extra || extra->minw != extra->maxw || extra->minh != extra->maxh) {
10458         const int isHidden = q->isHidden() && !size_policy.retainSizeWhenHidden() && !retainSizeWhenHiddenChanged;
10459 
10460         if (!q->isWindow() && !isHidden && (parent = q->parentWidget())) {
10461             if (parent->d_func()->layout)
10462                 parent->d_func()->layout->invalidate();
10463             else if (parent->isVisible())
10464                 QApplication::postEvent(parent, new QEvent(QEvent::LayoutRequest));
10465         }
10466     }
10467 }
10468 
10469 /*!
10470     Notifies the layout system that this widget has changed and may
10471     need to change geometry.
10472 
10473     Call this function if the sizeHint() or sizePolicy() have changed.
10474 
10475     For explicitly hidden widgets, updateGeometry() is a no-op. The
10476     layout system will be notified as soon as the widget is shown.
10477 */
10478 
10479 void QWidget::updateGeometry()
10480 {
10481     Q_D(QWidget);
10482     d->updateGeometry_helper(false);
10483 }
10484 
10485 /*! \property QWidget::windowFlags
10486 
10487     Window flags are a combination of a type (e.g. Qt::Dialog) and
10488     zero or more hints to the window system (e.g.
10489     Qt::FramelessWindowHint).
10490 
10491     If the widget had type Qt::Widget or Qt::SubWindow and becomes a
10492     window (Qt::Window, Qt::Dialog, etc.), it is put at position (0,
10493     0) on the desktop. If the widget is a window and becomes a
10494     Qt::Widget or Qt::SubWindow, it is put at position (0, 0)
10495     relative to its parent widget.
10496 
10497     \note This function calls setParent() when changing the flags for
10498     a window, causing the widget to be hidden. You must call show() to make
10499     the widget visible again..
10500 
10501     \sa windowType(), setWindowFlag(), {Window Flags Example}
10502 */
10503 void QWidget::setWindowFlags(Qt::WindowFlags flags)
10504 {
10505     Q_D(QWidget);
10506     d->setWindowFlags(flags);
10507 }
10508 
10509 /*!
10510     \since 5.9
10511 
10512     Sets the window flag \a flag on this widget if \a on is true;
10513     otherwise clears the flag.
10514 
10515     \sa setWindowFlags(), windowFlags(), windowType()
10516 */
10517 void QWidget::setWindowFlag(Qt::WindowType flag, bool on)
10518 {
10519     Q_D(QWidget);
10520     if (on)
10521         d->setWindowFlags(data->window_flags | flag);
10522     else
10523         d->setWindowFlags(data->window_flags & ~flag);
10524 }
10525 
10526 /*! \internal
10527 
10528     Implemented in QWidgetPrivate so that QMdiSubWindowPrivate can reimplement it.
10529 */
10530 void QWidgetPrivate::setWindowFlags(Qt::WindowFlags flags)
10531 {
10532     Q_Q(QWidget);
10533     if (q->data->window_flags == flags)
10534         return;
10535 
10536     if ((q->data->window_flags | flags) & Qt::Window) {
10537         // the old type was a window and/or the new type is a window
10538         QPoint oldPos = q->pos();
10539         bool visible = q->isVisible();
10540         const bool windowFlagChanged = (q->data->window_flags ^ flags) & Qt::Window;
10541         q->setParent(q->parentWidget(), flags);
10542 
10543         // if both types are windows or neither of them are, we restore
10544         // the old position
10545         if (!windowFlagChanged && (visible || q->testAttribute(Qt::WA_Moved)))
10546             q->move(oldPos);
10547         // for backward-compatibility we change Qt::WA_QuitOnClose attribute value only when the window was recreated.
10548         adjustQuitOnCloseAttribute();
10549     } else {
10550         q->data->window_flags = flags;
10551     }
10552 }
10553 
10554 /*!
10555     Sets the window flags for the widget to \a flags,
10556     \e without telling the window system.
10557 
10558     \warning Do not call this function unless you really know what
10559     you're doing.
10560 
10561     \sa setWindowFlags()
10562 */
10563 void QWidget::overrideWindowFlags(Qt::WindowFlags flags)
10564 {
10565     data->window_flags = flags;
10566 }
10567 
10568 /*!
10569     \fn Qt::WindowType QWidget::windowType() const
10570 
10571     Returns the window type of this widget. This is identical to
10572     windowFlags() & Qt::WindowType_Mask.
10573 
10574     \sa windowFlags
10575 */
10576 
10577 /*!
10578     Sets the parent of the widget to \a parent, and resets the window
10579     flags. The widget is moved to position (0, 0) in its new parent.
10580 
10581     If the new parent widget is in a different window, the
10582     reparented widget and its children are appended to the end of the
10583     \l{setFocusPolicy()}{tab chain} of the new parent
10584     widget, in the same internal order as before. If one of the moved
10585     widgets had keyboard focus, setParent() calls clearFocus() for that
10586     widget.
10587 
10588     If the new parent widget is in the same window as the
10589     old parent, setting the parent doesn't change the tab order or
10590     keyboard focus.
10591 
10592     If the "new" parent widget is the old parent widget, this function
10593     does nothing.
10594 
10595     \note The widget becomes invisible as part of changing its parent,
10596     even if it was previously visible. You must call show() to make the
10597     widget visible again.
10598 
10599     \warning It is very unlikely that you will ever need this
10600     function. If you have a widget that changes its content
10601     dynamically, it is far easier to use \l QStackedWidget.
10602 
10603     \sa setWindowFlags()
10604 */
10605 void QWidget::setParent(QWidget *parent)
10606 {
10607     if (parent == parentWidget())
10608         return;
10609     setParent((QWidget*)parent, windowFlags() & ~Qt::WindowType_Mask);
10610 }
10611 
10612 #ifndef QT_NO_OPENGL
10613 static void sendWindowChangeToTextureChildrenRecursively(QWidget *widget)
10614 {
10615     QWidgetPrivate *d = QWidgetPrivate::get(widget);
10616     if (d->renderToTexture) {
10617         QEvent e(QEvent::WindowChangeInternal);
10618         QApplication::sendEvent(widget, &e);
10619     }
10620 
10621     for (int i = 0; i < d->children.size(); ++i) {
10622         QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
10623         if (w && !w->isWindow() && QWidgetPrivate::get(w)->textureChildSeen)
10624             sendWindowChangeToTextureChildrenRecursively(w);
10625     }
10626 }
10627 #endif
10628 
10629 /*!
10630     \overload
10631 
10632     This function also takes widget flags, \a f as an argument.
10633 */
10634 
10635 void QWidget::setParent(QWidget *parent, Qt::WindowFlags f)
10636 {
10637     Q_D(QWidget);
10638     bool resized = testAttribute(Qt::WA_Resized);
10639     bool wasCreated = testAttribute(Qt::WA_WState_Created);
10640     QWidget *oldtlw = window();
10641 
10642     if (f & Qt::Window) // Frame geometry likely changes, refresh.
10643         d->data.fstrut_dirty = true;
10644 
10645     QWidget *desktopWidget = 0;
10646     if (parent && parent->windowType() == Qt::Desktop)
10647         desktopWidget = parent;
10648     bool newParent = (parent != parentWidget()) || !wasCreated || desktopWidget;
10649 
10650     if (newParent && parent && !desktopWidget) {
10651         if (testAttribute(Qt::WA_NativeWindow) && !qApp->testAttribute(Qt::AA_DontCreateNativeWidgetSiblings))
10652             parent->d_func()->enforceNativeChildren();
10653         else if (parent->d_func()->nativeChildrenForced() || parent->testAttribute(Qt::WA_PaintOnScreen))
10654             setAttribute(Qt::WA_NativeWindow);
10655     }
10656 
10657     if (wasCreated) {
10658         if (!testAttribute(Qt::WA_WState_Hidden)) {
10659             hide();
10660             setAttribute(Qt::WA_WState_ExplicitShowHide, false);
10661         }
10662         if (newParent) {
10663             QEvent e(QEvent::ParentAboutToChange);
10664             QApplication::sendEvent(this, &e);
10665         }
10666     }
10667     if (newParent && isAncestorOf(focusWidget()))
10668         focusWidget()->clearFocus();
10669 
10670     QTLWExtra *oldTopExtra = window()->d_func()->maybeTopData();
10671     QWidgetBackingStoreTracker *oldBsTracker = oldTopExtra ? &oldTopExtra->backingStoreTracker : 0;
10672 
10673     d->setParent_sys(parent, f);
10674 
10675     QTLWExtra *topExtra = window()->d_func()->maybeTopData();
10676     QWidgetBackingStoreTracker *bsTracker = topExtra ? &topExtra->backingStoreTracker : 0;
10677     if (oldBsTracker && oldBsTracker != bsTracker)
10678         oldBsTracker->unregisterWidgetSubtree(this);
10679 
10680     if (desktopWidget)
10681         parent = 0;
10682 
10683 #ifndef QT_NO_OPENGL
10684     if (d->textureChildSeen && parent) {
10685         // set the textureChildSeen flag up the whole parent chain
10686         QWidgetPrivate::get(parent)->setTextureChildSeen();
10687     }
10688 #endif
10689 
10690     if (QWidgetBackingStore *oldBs = oldtlw->d_func()->maybeBackingStore()) {
10691         if (newParent)
10692             oldBs->removeDirtyWidget(this);
10693         // Move the widget and all its static children from
10694         // the old backing store to the new one.
10695         oldBs->moveStaticWidgets(this);
10696     }
10697 
10698     // ### fixme: Qt 6: Remove AA_ImmediateWidgetCreation.
10699     if (QApplicationPrivate::testAttribute(Qt::AA_ImmediateWidgetCreation) && !testAttribute(Qt::WA_WState_Created))
10700         create();
10701 
10702     d->reparentFocusWidgets(oldtlw);
10703     setAttribute(Qt::WA_Resized, resized);
10704 
10705     const bool useStyleSheetPropagationInWidgetStyles =
10706         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
10707 
10708     if (!useStyleSheetPropagationInWidgetStyles && !testAttribute(Qt::WA_StyleSheet)
10709         && (!parent || !parent->testAttribute(Qt::WA_StyleSheet))) {
10710         d->resolveFont();
10711         d->resolvePalette();
10712     }
10713     d->resolveLayoutDirection();
10714     d->resolveLocale();
10715 
10716     // Note: GL widgets under WGL or EGL will always need a ParentChange
10717     // event to handle recreation/rebinding of the GL context, hence the
10718     // (f & Qt::MSWindowsOwnDC) clause (which is set on QGLWidgets on all
10719     // platforms).
10720     if (newParent
10721 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || defined(QT_OPENGL_ES)
10722         || (f & Qt::MSWindowsOwnDC)
10723 #endif
10724         ) {
10725         // propagate enabled updates enabled state to non-windows
10726         if (!isWindow()) {
10727             if (!testAttribute(Qt::WA_ForceDisabled))
10728                 d->setEnabled_helper(parent ? parent->isEnabled() : true);
10729             if (!testAttribute(Qt::WA_ForceUpdatesDisabled))
10730                 d->setUpdatesEnabled_helper(parent ? parent->updatesEnabled() : true);
10731         }
10732         d->inheritStyle();
10733 
10734         // send and post remaining QObject events
10735         if (parent && d->sendChildEvents) {
10736             QChildEvent e(QEvent::ChildAdded, this);
10737             QApplication::sendEvent(parent, &e);
10738         }
10739 
10740 //### already hidden above ---> must probably do something smart on the mac
10741 // #if 0 // Used to be included in Qt4 for Q_WS_MAC
10742 //             extern bool qt_mac_is_macdrawer(const QWidget *); //qwidget_mac.cpp
10743 //             if(!qt_mac_is_macdrawer(q)) //special case
10744 //                 q->setAttribute(Qt::WA_WState_Hidden);
10745 // #else
10746 //             q->setAttribute(Qt::WA_WState_Hidden);
10747 //#endif
10748 
10749         if (parent && d->sendChildEvents && d->polished) {
10750             QChildEvent e(QEvent::ChildPolished, this);
10751             QCoreApplication::sendEvent(parent, &e);
10752         }
10753 
10754         QEvent e(QEvent::ParentChange);
10755         QApplication::sendEvent(this, &e);
10756     }
10757 #ifndef QT_NO_OPENGL
10758     //renderToTexture widgets also need to know when their top-level window changes
10759     if (d->textureChildSeen && oldtlw != window()) {
10760         sendWindowChangeToTextureChildrenRecursively(this);
10761     }
10762 #endif
10763 
10764     if (!wasCreated) {
10765         if (isWindow() || parentWidget()->isVisible())
10766             setAttribute(Qt::WA_WState_Hidden, true);
10767         else if (!testAttribute(Qt::WA_WState_ExplicitShowHide))
10768             setAttribute(Qt::WA_WState_Hidden, false);
10769     }
10770 
10771     d->updateIsOpaque();
10772 
10773 #if QT_CONFIG(graphicsview)
10774     // Embed the widget into a proxy if the parent is embedded.
10775     // ### Doesn't handle reparenting out of an embedded widget.
10776     if (oldtlw->graphicsProxyWidget()) {
10777         if (QGraphicsProxyWidget *ancestorProxy = d->nearestGraphicsProxyWidget(oldtlw))
10778             ancestorProxy->d_func()->unembedSubWindow(this);
10779     }
10780     if (isWindow() && parent && !graphicsProxyWidget() && !bypassGraphicsProxyWidget(this)) {
10781         if (QGraphicsProxyWidget *ancestorProxy = d->nearestGraphicsProxyWidget(parent))
10782             ancestorProxy->d_func()->embedSubWindow(this);
10783     }
10784 #endif
10785 
10786     if (d->extra && d->extra->hasWindowContainer)
10787         QWindowContainer::parentWasChanged(this);
10788 }
10789 
10790 void QWidgetPrivate::setParent_sys(QWidget *newparent, Qt::WindowFlags f)
10791 {
10792     Q_Q(QWidget);
10793 
10794     Qt::WindowFlags oldFlags = data.window_flags;
10795     bool wasCreated = q->testAttribute(Qt::WA_WState_Created);
10796 
10797     int targetScreen = -1;
10798     // Handle a request to move the widget to a particular screen
10799     if (newparent && newparent->windowType() == Qt::Desktop) {
10800         // make sure the widget is created on the same screen as the
10801         // programmer specified desktop widget
10802         const QDesktopScreenWidget *sw = qobject_cast<const QDesktopScreenWidget *>(newparent);
10803         targetScreen = sw ? sw->screenNumber() : 0;
10804         newparent = 0;
10805     }
10806 
10807     setWinId(0);
10808 
10809     if (parent != newparent) {
10810         QObjectPrivate::setParent_helper(newparent); //### why does this have to be done in the _sys function???
10811         if (q->windowHandle()) {
10812             q->windowHandle()->setFlags(f);
10813             QWidget *parentWithWindow =
10814                 newparent ? (newparent->windowHandle() ? newparent : newparent->nativeParentWidget()) : 0;
10815             if (parentWithWindow) {
10816                 QWidget *topLevel = parentWithWindow->window();
10817                 if ((f & Qt::Window) && topLevel && topLevel->windowHandle()) {
10818                     q->windowHandle()->setTransientParent(topLevel->windowHandle());
10819                     q->windowHandle()->setParent(0);
10820                 } else {
10821                     q->windowHandle()->setTransientParent(0);
10822                     q->windowHandle()->setParent(parentWithWindow->windowHandle());
10823                 }
10824             } else {
10825                 q->windowHandle()->setTransientParent(0);
10826                 q->windowHandle()->setParent(0);
10827             }
10828         }
10829     }
10830 
10831     if (!newparent) {
10832         f |= Qt::Window;
10833         if (targetScreen == -1) {
10834             if (parent)
10835                 targetScreen = QDesktopWidgetPrivate::screenNumber(q->parentWidget()->window());
10836         }
10837     }
10838 
10839     bool explicitlyHidden = q->testAttribute(Qt::WA_WState_Hidden) && q->testAttribute(Qt::WA_WState_ExplicitShowHide);
10840 
10841     // Reparenting toplevel to child
10842     if (wasCreated && !(f & Qt::Window) && (oldFlags & Qt::Window) && !q->testAttribute(Qt::WA_NativeWindow)) {
10843         if (extra && extra->hasWindowContainer)
10844             QWindowContainer::toplevelAboutToBeDestroyed(q);
10845 
10846         QWindow *newParentWindow = newparent->windowHandle();
10847         if (!newParentWindow)
10848             if (QWidget *npw = newparent->nativeParentWidget())
10849                 newParentWindow = npw->windowHandle();
10850 
10851         Q_FOREACH (QObject *child, q->windowHandle()->children()) {
10852             QWindow *childWindow = qobject_cast<QWindow *>(child);
10853             if (!childWindow)
10854                 continue;
10855 
10856             QWidgetWindow *childWW = qobject_cast<QWidgetWindow *>(childWindow);
10857             QWidget *childWidget = childWW ? childWW->widget() : 0;
10858             if (!childWW || (childWidget && childWidget->testAttribute(Qt::WA_NativeWindow)))
10859                 childWindow->setParent(newParentWindow);
10860         }
10861         q->destroy();
10862     }
10863 
10864     adjustFlags(f, q);
10865     data.window_flags = f;
10866     q->setAttribute(Qt::WA_WState_Created, false);
10867     q->setAttribute(Qt::WA_WState_Visible, false);
10868     q->setAttribute(Qt::WA_WState_Hidden, false);
10869 
10870     if (newparent && wasCreated && (q->testAttribute(Qt::WA_NativeWindow) || (f & Qt::Window)))
10871         q->createWinId();
10872 
10873     if (q->isWindow() || (!newparent || newparent->isVisible()) || explicitlyHidden)
10874         q->setAttribute(Qt::WA_WState_Hidden);
10875     q->setAttribute(Qt::WA_WState_ExplicitShowHide, explicitlyHidden);
10876 
10877     // move the window to the selected screen
10878     if (!newparent && targetScreen != -1) {
10879         // only if it is already created
10880         if (q->testAttribute(Qt::WA_WState_Created))
10881             q->windowHandle()->setScreen(QGuiApplication::screens().value(targetScreen, 0));
10882         else
10883             topData()->initialScreenIndex = targetScreen;
10884     }
10885 }
10886 
10887 /*!
10888     Scrolls the widget including its children \a dx pixels to the
10889     right and \a dy downward. Both \a dx and \a dy may be negative.
10890 
10891     After scrolling, the widgets will receive paint events for
10892     the areas that need to be repainted. For widgets that Qt knows to
10893     be opaque, this is only the newly exposed parts.
10894     For example, if an opaque widget is scrolled 8 pixels to the left,
10895     only an 8-pixel wide stripe at the right edge needs updating.
10896 
10897     Since widgets propagate the contents of their parents by default,
10898     you need to set the \l autoFillBackground property, or use
10899     setAttribute() to set the Qt::WA_OpaquePaintEvent attribute, to make
10900     a widget opaque.
10901 
10902     For widgets that use contents propagation, a scroll will cause an
10903     update of the entire scroll area.
10904 
10905     \sa {Transparency and Double Buffering}
10906 */
10907 
10908 void QWidget::scroll(int dx, int dy)
10909 {
10910     if ((!updatesEnabled() && children().size() == 0) || !isVisible())
10911         return;
10912     if (dx == 0 && dy == 0)
10913         return;
10914     Q_D(QWidget);
10915 #if QT_CONFIG(graphicsview)
10916     if (QGraphicsProxyWidget *proxy = QWidgetPrivate::nearestGraphicsProxyWidget(this)) {
10917         // Graphics View maintains its own dirty region as a list of rects;
10918         // until we can connect item updates directly to the view, we must
10919         // separately add a translated dirty region.
10920         for (const QRect &rect : d->dirty)
10921             proxy->update(rect.translated(dx, dy));
10922         proxy->scroll(dx, dy, proxy->subWidgetRect(this));
10923         return;
10924     }
10925 #endif
10926     d->setDirtyOpaqueRegion();
10927     d->scroll_sys(dx, dy);
10928 }
10929 
10930 void QWidgetPrivate::scroll_sys(int dx, int dy)
10931 {
10932     Q_Q(QWidget);
10933     scrollChildren(dx, dy);
10934     scrollRect(q->rect(), dx, dy);
10935 }
10936 
10937 /*!
10938     \overload
10939 
10940     This version only scrolls \a r and does not move the children of
10941     the widget.
10942 
10943     If \a r is empty or invalid, the result is undefined.
10944 
10945     \sa QScrollArea
10946 */
10947 void QWidget::scroll(int dx, int dy, const QRect &r)
10948 {
10949 
10950     if ((!updatesEnabled() && children().size() == 0) || !isVisible())
10951         return;
10952     if (dx == 0 && dy == 0)
10953         return;
10954     Q_D(QWidget);
10955 #if QT_CONFIG(graphicsview)
10956     if (QGraphicsProxyWidget *proxy = QWidgetPrivate::nearestGraphicsProxyWidget(this)) {
10957         // Graphics View maintains its own dirty region as a list of rects;
10958         // until we can connect item updates directly to the view, we must
10959         // separately add a translated dirty region.
10960         if (!d->dirty.isEmpty()) {
10961             for (const QRect &rect : d->dirty.translated(dx, dy) & r)
10962                 proxy->update(rect);
10963         }
10964         proxy->scroll(dx, dy, r.translated(proxy->subWidgetRect(this).topLeft().toPoint()));
10965         return;
10966     }
10967 #endif
10968     d->scroll_sys(dx, dy, r);
10969 }
10970 
10971 void QWidgetPrivate::scroll_sys(int dx, int dy, const QRect &r)
10972 {
10973     scrollRect(r, dx, dy);
10974 }
10975 
10976 /*!
10977     Repaints the widget directly by calling paintEvent() immediately,
10978     unless updates are disabled or the widget is hidden.
10979 
10980     We suggest only using repaint() if you need an immediate repaint,
10981     for example during animation. In almost all circumstances update()
10982     is better, as it permits Qt to optimize for speed and minimize
10983     flicker.
10984 
10985     \warning If you call repaint() in a function which may itself be
10986     called from paintEvent(), you may get infinite recursion. The
10987     update() function never causes recursion.
10988 
10989     \sa update(), paintEvent(), setUpdatesEnabled()
10990 */
10991 
10992 void QWidget::repaint()
10993 {
10994     repaint(rect());
10995 }
10996 
10997 /*! \overload
10998 
10999     This version repaints a rectangle (\a x, \a y, \a w, \a h) inside
11000     the widget.
11001 
11002     If \a w is negative, it is replaced with \c{width() - x}, and if
11003     \a h is negative, it is replaced width \c{height() - y}.
11004 */
11005 void QWidget::repaint(int x, int y, int w, int h)
11006 {
11007     if (x > data->crect.width() || y > data->crect.height())
11008         return;
11009 
11010     if (w < 0)
11011         w = data->crect.width()  - x;
11012     if (h < 0)
11013         h = data->crect.height() - y;
11014 
11015     repaint(QRect(x, y, w, h));
11016 }
11017 
11018 /*! \overload
11019 
11020     This version repaints a rectangle \a rect inside the widget.
11021 */
11022 void QWidget::repaint(const QRect &rect)
11023 {
11024     Q_D(QWidget);
11025     d->repaint(rect);
11026 }
11027 
11028 /*!
11029     \overload
11030 
11031     This version repaints a region \a rgn inside the widget.
11032 */
11033 void QWidget::repaint(const QRegion &rgn)
11034 {
11035     Q_D(QWidget);
11036     d->repaint(rgn);
11037 }
11038 
11039 template <typename T>
11040 void QWidgetPrivate::repaint(T r)
11041 {
11042     Q_Q(QWidget);
11043 
11044     if (!q->isVisible() || !q->updatesEnabled() || r.isEmpty())
11045         return;
11046 
11047     QTLWExtra *tlwExtra = q->window()->d_func()->maybeTopData();
11048     if (tlwExtra && !tlwExtra->inTopLevelResize && tlwExtra->backingStore) {
11049         tlwExtra->inRepaint = true;
11050         tlwExtra->backingStoreTracker->markDirty(r, q, QWidgetBackingStore::UpdateNow);
11051         tlwExtra->inRepaint = false;
11052     }
11053 }
11054 
11055 /*!
11056     Updates the widget unless updates are disabled or the widget is
11057     hidden.
11058 
11059     This function does not cause an immediate repaint; instead it
11060     schedules a paint event for processing when Qt returns to the main
11061     event loop. This permits Qt to optimize for more speed and less
11062     flicker than a call to repaint() does.
11063 
11064     Calling update() several times normally results in just one
11065     paintEvent() call.
11066 
11067     Qt normally erases the widget's area before the paintEvent() call.
11068     If the Qt::WA_OpaquePaintEvent widget attribute is set, the widget is
11069     responsible for painting all its pixels with an opaque color.
11070 
11071     \sa repaint(), paintEvent(), setUpdatesEnabled(), {Analog Clock Example}
11072 */
11073 void QWidget::update()
11074 {
11075     update(rect());
11076 }
11077 
11078 /*! \fn void QWidget::update(int x, int y, int w, int h)
11079     \overload
11080 
11081     This version updates a rectangle (\a x, \a y, \a w, \a h) inside
11082     the widget.
11083 */
11084 
11085 /*!
11086     \overload
11087 
11088     This version updates a rectangle \a rect inside the widget.
11089 */
11090 void QWidget::update(const QRect &rect)
11091 {
11092     Q_D(QWidget);
11093     d->update(rect);
11094 }
11095 
11096 /*!
11097     \overload
11098 
11099     This version repaints a region \a rgn inside the widget.
11100 */
11101 void QWidget::update(const QRegion &rgn)
11102 {
11103     Q_D(QWidget);
11104     d->update(rgn);
11105 }
11106 
11107 template <typename T>
11108 void QWidgetPrivate::update(T r)
11109 {
11110     Q_Q(QWidget);
11111 
11112     if (!q->isVisible() || !q->updatesEnabled())
11113         return;
11114 
11115     T clipped = r & q->rect();
11116 
11117     if (clipped.isEmpty())
11118         return;
11119 
11120     if (q->testAttribute(Qt::WA_WState_InPaintEvent)) {
11121         QApplication::postEvent(q, new QUpdateLaterEvent(clipped));
11122         return;
11123     }
11124 
11125     QTLWExtra *tlwExtra = q->window()->d_func()->maybeTopData();
11126     if (tlwExtra && !tlwExtra->inTopLevelResize && tlwExtra->backingStore)
11127         tlwExtra->backingStoreTracker->markDirty(clipped, q);
11128 }
11129 
11130  /*!
11131   \internal
11132 
11133   This just sets the corresponding attribute bit to 1 or 0
11134  */
11135 static void setAttribute_internal(Qt::WidgetAttribute attribute, bool on, QWidgetData *data,
11136                                   QWidgetPrivate *d)
11137 {
11138     if (attribute < int(8*sizeof(uint))) {
11139         if (on)
11140             data->widget_attributes |= (1<<attribute);
11141         else
11142             data->widget_attributes &= ~(1<<attribute);
11143     } else {
11144         const int x = attribute - 8*sizeof(uint);
11145         const int int_off = x / (8*sizeof(uint));
11146         if (on)
11147             d->high_attributes[int_off] |= (1<<(x-(int_off*8*sizeof(uint))));
11148         else
11149             d->high_attributes[int_off] &= ~(1<<(x-(int_off*8*sizeof(uint))));
11150     }
11151 }
11152 
11153 #ifdef Q_OS_MAC
11154 void QWidgetPrivate::macUpdateSizeAttribute()
11155 {
11156     Q_Q(QWidget);
11157     QEvent event(QEvent::MacSizeChange);
11158     QApplication::sendEvent(q, &event);
11159     for (int i = 0; i < children.size(); ++i) {
11160         QWidget *w = qobject_cast<QWidget *>(children.at(i));
11161         if (w && (!w->isWindow() || w->testAttribute(Qt::WA_WindowPropagation))
11162               && !q->testAttribute(Qt::WA_MacMiniSize) // no attribute set? inherit from parent
11163               && !w->testAttribute(Qt::WA_MacSmallSize)
11164               && !w->testAttribute(Qt::WA_MacNormalSize))
11165             w->d_func()->macUpdateSizeAttribute();
11166     }
11167     resolveFont();
11168 }
11169 #endif
11170 
11171 /*!
11172     Sets the attribute \a attribute on this widget if \a on is true;
11173     otherwise clears the attribute.
11174 
11175     \sa testAttribute()
11176 */
11177 void QWidget::setAttribute(Qt::WidgetAttribute attribute, bool on)
11178 {
11179     if (testAttribute(attribute) == on)
11180         return;
11181 
11182     Q_D(QWidget);
11183     Q_STATIC_ASSERT_X(sizeof(d->high_attributes)*8 >= (Qt::WA_AttributeCount - sizeof(uint)*8),
11184                       "QWidget::setAttribute(WidgetAttribute, bool): "
11185                       "QWidgetPrivate::high_attributes[] too small to contain all attributes in WidgetAttribute");
11186 #ifdef Q_OS_WIN
11187     // ### Don't use PaintOnScreen+paintEngine() to do native painting in some future release
11188     if (attribute == Qt::WA_PaintOnScreen && on && windowType() != Qt::Desktop && !inherits("QGLWidget")) {
11189         // see ::paintEngine for details
11190         paintEngine();
11191         if (d->noPaintOnScreen)
11192             return;
11193     }
11194 #endif
11195 
11196     // Don't set WA_NativeWindow on platforms that don't support it -- except for QGLWidget, which depends on it
11197     if (attribute == Qt::WA_NativeWindow && !d->mustHaveWindowHandle) {
11198         QPlatformIntegration *platformIntegration = QGuiApplicationPrivate::platformIntegration();
11199         if (!platformIntegration->hasCapability(QPlatformIntegration::NativeWidgets))
11200             return;
11201     }
11202 
11203     setAttribute_internal(attribute, on, data, d);
11204 
11205     switch (attribute) {
11206 
11207 #ifndef QT_NO_DRAGANDDROP
11208     case Qt::WA_AcceptDrops:  {
11209         if (on && !testAttribute(Qt::WA_DropSiteRegistered))
11210             setAttribute(Qt::WA_DropSiteRegistered, true);
11211         else if (!on && (isWindow() || !parentWidget() || !parentWidget()->testAttribute(Qt::WA_DropSiteRegistered)))
11212             setAttribute(Qt::WA_DropSiteRegistered, false);
11213         QEvent e(QEvent::AcceptDropsChange);
11214         QApplication::sendEvent(this, &e);
11215         break;
11216     }
11217     case Qt::WA_DropSiteRegistered:  {
11218         d->registerDropSite(on);
11219         for (int i = 0; i < d->children.size(); ++i) {
11220             QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
11221             if (w && !w->isWindow() && !w->testAttribute(Qt::WA_AcceptDrops) && w->testAttribute(Qt::WA_DropSiteRegistered) != on)
11222                 w->setAttribute(Qt::WA_DropSiteRegistered, on);
11223         }
11224         break;
11225     }
11226 #endif
11227 
11228     case Qt::WA_NoChildEventsForParent:
11229         d->sendChildEvents = !on;
11230         break;
11231     case Qt::WA_NoChildEventsFromChildren:
11232         d->receiveChildEvents = !on;
11233         break;
11234 #if 0 // Used to be included in Qt4 for Q_WS_MAC
11235     case Qt::WA_MacOpaqueSizeGrip:
11236         d->macUpdateOpaqueSizeGrip();
11237         break;
11238     case Qt::WA_MacShowFocusRect:
11239         if (hasFocus()) {
11240             clearFocus();
11241             setFocus();
11242         }
11243         break;
11244     case Qt::WA_Hover:
11245         qt_mac_update_mouseTracking(this);
11246         break;
11247     case Qt::WA_MacAlwaysShowToolWindow:
11248         d->macUpdateHideOnSuspend();
11249         break;
11250 #endif
11251     case Qt::WA_MacNormalSize:
11252     case Qt::WA_MacSmallSize:
11253     case Qt::WA_MacMiniSize:
11254 #ifdef Q_OS_MAC
11255         {
11256             // We can only have one of these set at a time
11257             const Qt::WidgetAttribute MacSizes[] = { Qt::WA_MacNormalSize, Qt::WA_MacSmallSize,
11258                                                      Qt::WA_MacMiniSize };
11259             for (int i = 0; i < 3; ++i) {
11260                 if (MacSizes[i] != attribute)
11261                     setAttribute_internal(MacSizes[i], false, data, d);
11262             }
11263             d->macUpdateSizeAttribute();
11264         }
11265 #endif
11266         break;
11267     case Qt::WA_ShowModal:
11268         if (!on) {
11269             // reset modality type to NonModal when clearing WA_ShowModal
11270             data->window_modality = Qt::NonModal;
11271         } else if (data->window_modality == Qt::NonModal) {
11272             // determine the modality type if it hasn't been set prior
11273             // to setting WA_ShowModal. set the default to WindowModal
11274             // if we are the child of a group leader; otherwise use
11275             // ApplicationModal.
11276             QWidget *w = parentWidget();
11277             if (w)
11278                 w = w->window();
11279             while (w && !w->testAttribute(Qt::WA_GroupLeader)) {
11280                 w = w->parentWidget();
11281                 if (w)
11282                     w = w->window();
11283             }
11284             data->window_modality = (w && w->testAttribute(Qt::WA_GroupLeader))
11285                                     ? Qt::WindowModal
11286                                     : Qt::ApplicationModal;
11287             // Some window managers do not allow us to enter modality after the
11288             // window is visible.The window must be hidden before changing the
11289             // windowModality property and then reshown.
11290         }
11291         if (testAttribute(Qt::WA_WState_Created)) {
11292             // don't call setModal_sys() before create_sys()
11293             d->setModal_sys();
11294         }
11295         break;
11296     case Qt::WA_MouseTracking: {
11297         QEvent e(QEvent::MouseTrackingChange);
11298         QApplication::sendEvent(this, &e);
11299         break; }
11300     case Qt::WA_TabletTracking: {
11301         QEvent e(QEvent::TabletTrackingChange);
11302         QApplication::sendEvent(this, &e);
11303         break; }
11304     case Qt::WA_NativeWindow: {
11305         d->createTLExtra();
11306         if (on)
11307             d->createTLSysExtra();
11308 #ifndef QT_NO_IM
11309         QWidget *focusWidget = d->effectiveFocusWidget();
11310         if (on && !internalWinId() && this == QGuiApplication::focusObject()
11311             && focusWidget->testAttribute(Qt::WA_InputMethodEnabled)) {
11312             QGuiApplication::inputMethod()->commit();
11313             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
11314         }
11315         if (!qApp->testAttribute(Qt::AA_DontCreateNativeWidgetSiblings) && parentWidget())
11316             parentWidget()->d_func()->enforceNativeChildren();
11317         if (on && !internalWinId() && testAttribute(Qt::WA_WState_Created))
11318             d->createWinId();
11319         if (isEnabled() && focusWidget->isEnabled() && this == QGuiApplication::focusObject()
11320             && focusWidget->testAttribute(Qt::WA_InputMethodEnabled)) {
11321             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
11322         }
11323 #endif //QT_NO_IM
11324         break;
11325     }
11326     case Qt::WA_PaintOnScreen:
11327         d->updateIsOpaque();
11328 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_X11 */ || 0 /* Used to be included in Qt4 for Q_WS_MAC */
11329         // Recreate the widget if it's already created as an alien widget and
11330         // WA_PaintOnScreen is enabled. Paint on screen widgets must have win id.
11331         // So must their children.
11332         if (on) {
11333             setAttribute(Qt::WA_NativeWindow);
11334             d->enforceNativeChildren();
11335         }
11336 #endif
11337         Q_FALLTHROUGH();
11338     case Qt::WA_OpaquePaintEvent:
11339         d->updateIsOpaque();
11340         break;
11341     case Qt::WA_NoSystemBackground:
11342         d->updateIsOpaque();
11343         Q_FALLTHROUGH();
11344     case Qt::WA_UpdatesDisabled:
11345         d->updateSystemBackground();
11346         break;
11347     case Qt::WA_TransparentForMouseEvents:
11348 #if 0 // Used to be included in Qt4 for Q_WS_MAC
11349         d->macUpdateIgnoreMouseEvents();
11350 #endif
11351         break;
11352     case Qt::WA_InputMethodEnabled: {
11353 #ifndef QT_NO_IM
11354         if (QGuiApplication::focusObject() == this) {
11355             if (!on)
11356                 QGuiApplication::inputMethod()->commit();
11357             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
11358         }
11359 #endif //QT_NO_IM
11360         break;
11361     }
11362     case Qt::WA_WindowPropagation:
11363         d->resolvePalette();
11364         d->resolveFont();
11365         d->resolveLocale();
11366         break;
11367 #if 0 // Used to be included in Qt4 for Q_WS_X11
11368     case Qt::WA_NoX11EventCompression:
11369         if (!d->extra)
11370             d->createExtra();
11371         d->extra->compress_events = on;
11372         break;
11373     case Qt::WA_X11OpenGLOverlay:
11374         d->updateIsOpaque();
11375         break;
11376     case Qt::WA_X11DoNotAcceptFocus:
11377         if (testAttribute(Qt::WA_WState_Created))
11378             d->updateX11AcceptFocus();
11379         break;
11380 #endif
11381     case Qt::WA_DontShowOnScreen: {
11382         if (on && isVisible()) {
11383             // Make sure we keep the current state and only hide the widget
11384             // from the desktop. show_sys will only update platform specific
11385             // attributes at this point.
11386             d->hide_sys();
11387             d->show_sys();
11388         }
11389         break;
11390     }
11391 
11392     case Qt::WA_X11NetWmWindowTypeDesktop:
11393     case Qt::WA_X11NetWmWindowTypeDock:
11394     case Qt::WA_X11NetWmWindowTypeToolBar:
11395     case Qt::WA_X11NetWmWindowTypeMenu:
11396     case Qt::WA_X11NetWmWindowTypeUtility:
11397     case Qt::WA_X11NetWmWindowTypeSplash:
11398     case Qt::WA_X11NetWmWindowTypeDialog:
11399     case Qt::WA_X11NetWmWindowTypeDropDownMenu:
11400     case Qt::WA_X11NetWmWindowTypePopupMenu:
11401     case Qt::WA_X11NetWmWindowTypeToolTip:
11402     case Qt::WA_X11NetWmWindowTypeNotification:
11403     case Qt::WA_X11NetWmWindowTypeCombo:
11404     case Qt::WA_X11NetWmWindowTypeDND:
11405         d->setNetWmWindowTypes();
11406         break;
11407 
11408     case Qt::WA_StaticContents:
11409         if (QWidgetBackingStore *bs = d->maybeBackingStore()) {
11410             if (on)
11411                 bs->addStaticWidget(this);
11412             else
11413                 bs->removeStaticWidget(this);
11414         }
11415         break;
11416     case Qt::WA_TranslucentBackground:
11417         if (on) {
11418             setAttribute(Qt::WA_NoSystemBackground);
11419             d->updateIsTranslucent();
11420         }
11421 
11422         break;
11423     case Qt::WA_AcceptTouchEvents:
11424 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_MAC */
11425         if (on)
11426             d->registerTouchWindow();
11427 #endif
11428         break;
11429     default:
11430         break;
11431     }
11432 }
11433 
11434 /*! \fn bool QWidget::testAttribute(Qt::WidgetAttribute attribute) const
11435 
11436   Returns \c true if attribute \a attribute is set on this widget;
11437   otherwise returns \c false.
11438 
11439   \sa setAttribute()
11440  */
11441 bool QWidget::testAttribute_helper(Qt::WidgetAttribute attribute) const
11442 {
11443     Q_D(const QWidget);
11444     const int x = attribute - 8*sizeof(uint);
11445     const int int_off = x / (8*sizeof(uint));
11446     return (d->high_attributes[int_off] & (1<<(x-(int_off*8*sizeof(uint)))));
11447 }
11448 
11449 /*!
11450   \property QWidget::windowOpacity
11451 
11452   \brief The level of opacity for the window.
11453 
11454   The valid range of opacity is from 1.0 (completely opaque) to
11455   0.0 (completely transparent).
11456 
11457   By default the value of this property is 1.0.
11458 
11459   This feature is available on Embedded Linux, \macos, Windows,
11460   and X11 platforms that support the Composite extension.
11461 
11462   \note On X11 you need to have a composite manager running,
11463   and the X11 specific _NET_WM_WINDOW_OPACITY atom needs to be
11464   supported by the window manager you are using.
11465 
11466   \warning Changing this property from opaque to transparent might issue a
11467   paint event that needs to be processed before the window is displayed
11468   correctly. This affects mainly the use of QPixmap::grabWindow(). Also note
11469   that semi-transparent windows update and resize significantly slower than
11470   opaque windows.
11471 
11472   \sa setMask()
11473 */
11474 qreal QWidget::windowOpacity() const
11475 {
11476     Q_D(const QWidget);
11477     return (isWindow() && d->maybeTopData()) ? d->maybeTopData()->opacity / 255. : 1.0;
11478 }
11479 
11480 void QWidget::setWindowOpacity(qreal opacity)
11481 {
11482     Q_D(QWidget);
11483     if (!isWindow())
11484         return;
11485 
11486     opacity = qBound(qreal(0.0), opacity, qreal(1.0));
11487     QTLWExtra *extra = d->topData();
11488     extra->opacity = uint(opacity * 255);
11489     setAttribute(Qt::WA_WState_WindowOpacitySet);
11490     d->setWindowOpacity_sys(opacity);
11491 
11492     if (!testAttribute(Qt::WA_WState_Created))
11493         return;
11494 
11495 #if QT_CONFIG(graphicsview)
11496     if (QGraphicsProxyWidget *proxy = graphicsProxyWidget()) {
11497         // Avoid invalidating the cache if set.
11498         if (proxy->cacheMode() == QGraphicsItem::NoCache)
11499             proxy->update();
11500         else if (QGraphicsScene *scene = proxy->scene())
11501             scene->update(proxy->sceneBoundingRect());
11502         return;
11503     }
11504 #endif
11505 }
11506 
11507 void QWidgetPrivate::setWindowOpacity_sys(qreal level)
11508 {
11509     Q_Q(QWidget);
11510     if (q->windowHandle())
11511         q->windowHandle()->setOpacity(level);
11512 }
11513 
11514 /*!
11515     \property QWidget::windowModified
11516     \brief whether the document shown in the window has unsaved changes
11517 
11518     A modified window is a window whose content has changed but has
11519     not been saved to disk. This flag will have different effects
11520     varied by the platform. On \macos the close button will have a
11521     modified look; on other platforms, the window title will have an
11522     '*' (asterisk).
11523 
11524     The window title must contain a "[*]" placeholder, which
11525     indicates where the '*' should appear. Normally, it should appear
11526     right after the file name (e.g., "document1.txt[*] - Text
11527     Editor"). If the window isn't modified, the placeholder is simply
11528     removed.
11529 
11530     Note that if a widget is set as modified, all its ancestors will
11531     also be set as modified. However, if you call \c
11532     {setWindowModified(false)} on a widget, this will not propagate to
11533     its parent because other children of the parent might have been
11534     modified.
11535 
11536     \sa windowTitle, {Application Example}, {SDI Example}, {MDI Example}
11537 */
11538 bool QWidget::isWindowModified() const
11539 {
11540     return testAttribute(Qt::WA_WindowModified);
11541 }
11542 
11543 void QWidget::setWindowModified(bool mod)
11544 {
11545     Q_D(QWidget);
11546     setAttribute(Qt::WA_WindowModified, mod);
11547 
11548     d->setWindowModified_helper();
11549 
11550     QEvent e(QEvent::ModifiedChange);
11551     QApplication::sendEvent(this, &e);
11552 }
11553 
11554 void QWidgetPrivate::setWindowModified_helper()
11555 {
11556     Q_Q(QWidget);
11557     QWindow *window = q->windowHandle();
11558     if (!window)
11559         return;
11560     QPlatformWindow *platformWindow = window->handle();
11561     if (!platformWindow)
11562         return;
11563     bool on = q->testAttribute(Qt::WA_WindowModified);
11564     if (!platformWindow->setWindowModified(on)) {
11565         if (Q_UNLIKELY(on && !q->windowTitle().contains(QLatin1String("[*]"))))
11566             qWarning("QWidget::setWindowModified: The window title does not contain a '[*]' placeholder");
11567         setWindowTitle_helper(q->windowTitle());
11568         setWindowIconText_helper(q->windowIconText());
11569     }
11570 }
11571 
11572 #ifndef QT_NO_TOOLTIP
11573 /*!
11574   \property QWidget::toolTip
11575 
11576   \brief the widget's tooltip
11577 
11578   Note that by default tooltips are only shown for widgets that are
11579   children of the active window. You can change this behavior by
11580   setting the attribute Qt::WA_AlwaysShowToolTips on the \e window,
11581   not on the widget with the tooltip.
11582 
11583   If you want to control a tooltip's behavior, you can intercept the
11584   event() function and catch the QEvent::ToolTip event (e.g., if you
11585   want to customize the area for which the tooltip should be shown).
11586 
11587   By default, this property contains an empty string.
11588 
11589   \sa QToolTip, statusTip, whatsThis
11590 */
11591 void QWidget::setToolTip(const QString &s)
11592 {
11593     Q_D(QWidget);
11594     d->toolTip = s;
11595 
11596     QEvent event(QEvent::ToolTipChange);
11597     QApplication::sendEvent(this, &event);
11598 }
11599 
11600 QString QWidget::toolTip() const
11601 {
11602     Q_D(const QWidget);
11603     return d->toolTip;
11604 }
11605 
11606 /*!
11607   \property QWidget::toolTipDuration
11608   \brief the widget's tooltip duration
11609   \since 5.2
11610 
11611   Specifies how long time the tooltip will be displayed, in milliseconds.
11612   If the value is -1 (default) the duration is calculated depending on the length of the tooltip.
11613 
11614   \sa toolTip
11615 */
11616 
11617 void QWidget::setToolTipDuration(int msec)
11618 {
11619     Q_D(QWidget);
11620     d->toolTipDuration = msec;
11621 }
11622 
11623 int QWidget::toolTipDuration() const
11624 {
11625     Q_D(const QWidget);
11626     return d->toolTipDuration;
11627 }
11628 
11629 #endif // QT_NO_TOOLTIP
11630 
11631 
11632 #if QT_CONFIG(statustip)
11633 /*!
11634   \property QWidget::statusTip
11635   \brief the widget's status tip
11636 
11637   By default, this property contains an empty string.
11638 
11639   \sa toolTip, whatsThis
11640 */
11641 void QWidget::setStatusTip(const QString &s)
11642 {
11643     Q_D(QWidget);
11644     d->statusTip = s;
11645 }
11646 
11647 QString QWidget::statusTip() const
11648 {
11649     Q_D(const QWidget);
11650     return d->statusTip;
11651 }
11652 #endif // QT_CONFIG(statustip)
11653 
11654 #if QT_CONFIG(whatsthis)
11655 /*!
11656   \property QWidget::whatsThis
11657 
11658   \brief the widget's What's This help text.
11659 
11660   By default, this property contains an empty string.
11661 
11662   \sa QWhatsThis, QWidget::toolTip, QWidget::statusTip
11663 */
11664 void QWidget::setWhatsThis(const QString &s)
11665 {
11666     Q_D(QWidget);
11667     d->whatsThis = s;
11668 }
11669 
11670 QString QWidget::whatsThis() const
11671 {
11672     Q_D(const QWidget);
11673     return d->whatsThis;
11674 }
11675 #endif // QT_CONFIG(whatsthis)
11676 
11677 #ifndef QT_NO_ACCESSIBILITY
11678 /*!
11679   \property QWidget::accessibleName
11680 
11681   \brief the widget's name as seen by assistive technologies
11682 
11683   This is the primary name by which assistive technology such as screen readers
11684   announce this widget. For most widgets setting this property is not required.
11685   For example for QPushButton the button's text will be used.
11686 
11687   It is important to set this property when the widget does not provide any
11688   text. For example a button that only contains an icon needs to set this
11689   property to work with screen readers.
11690   The name should be short and equivalent to the visual information conveyed
11691   by the widget.
11692 
11693   This property has to be \l{Internationalization with Qt}{localized}.
11694 
11695   By default, this property contains an empty string.
11696 
11697   \sa QWidget::accessibleDescription, QAccessibleInterface::text()
11698 */
11699 void QWidget::setAccessibleName(const QString &name)
11700 {
11701     Q_D(QWidget);
11702     d->accessibleName = name;
11703     QAccessibleEvent event(this, QAccessible::NameChanged);
11704     QAccessible::updateAccessibility(&event);
11705 }
11706 
11707 QString QWidget::accessibleName() const
11708 {
11709     Q_D(const QWidget);
11710     return d->accessibleName;
11711 }
11712 
11713 /*!
11714   \property QWidget::accessibleDescription
11715 
11716   \brief the widget's description as seen by assistive technologies
11717 
11718   The accessible description of a widget should convey what a widget does.
11719   While the \l accessibleName should be a short and consise string (e.g. \gui{Save}),
11720   the description should give more context, such as \gui{Saves the current document}.
11721 
11722   This property has to be \l{Internationalization with Qt}{localized}.
11723 
11724   By default, this property contains an empty string and Qt falls back
11725   to using the tool tip to provide this information.
11726 
11727   \sa QWidget::accessibleName, QAccessibleInterface::text()
11728 */
11729 void QWidget::setAccessibleDescription(const QString &description)
11730 {
11731     Q_D(QWidget);
11732     d->accessibleDescription = description;
11733     QAccessibleEvent event(this, QAccessible::DescriptionChanged);
11734     QAccessible::updateAccessibility(&event);
11735 }
11736 
11737 QString QWidget::accessibleDescription() const
11738 {
11739     Q_D(const QWidget);
11740     return d->accessibleDescription;
11741 }
11742 #endif // QT_NO_ACCESSIBILITY
11743 
11744 #ifndef QT_NO_SHORTCUT
11745 /*!
11746     Adds a shortcut to Qt's shortcut system that watches for the given
11747     \a key sequence in the given \a context. If the \a context is
11748     Qt::ApplicationShortcut, the shortcut applies to the application as a
11749     whole. Otherwise, it is either local to this widget, Qt::WidgetShortcut,
11750     or to the window itself, Qt::WindowShortcut.
11751 
11752     If the same \a key sequence has been grabbed by several widgets,
11753     when the \a key sequence occurs a QEvent::Shortcut event is sent
11754     to all the widgets to which it applies in a non-deterministic
11755     order, but with the ``ambiguous'' flag set to true.
11756 
11757     \warning You should not normally need to use this function;
11758     instead create \l{QAction}s with the shortcut key sequences you
11759     require (if you also want equivalent menu options and toolbar
11760     buttons), or create \l{QShortcut}s if you just need key sequences.
11761     Both QAction and QShortcut handle all the event filtering for you,
11762     and provide signals which are triggered when the user triggers the
11763     key sequence, so are much easier to use than this low-level
11764     function.
11765 
11766     \sa releaseShortcut(), setShortcutEnabled()
11767 */
11768 int QWidget::grabShortcut(const QKeySequence &key, Qt::ShortcutContext context)
11769 {
11770     Q_ASSERT(qApp);
11771     if (key.isEmpty())
11772         return 0;
11773     setAttribute(Qt::WA_GrabbedShortcut);
11774     return qApp->d_func()->shortcutMap.addShortcut(this, key, context, qWidgetShortcutContextMatcher);
11775 }
11776 
11777 /*!
11778     Removes the shortcut with the given \a id from Qt's shortcut
11779     system. The widget will no longer receive QEvent::Shortcut events
11780     for the shortcut's key sequence (unless it has other shortcuts
11781     with the same key sequence).
11782 
11783     \warning You should not normally need to use this function since
11784     Qt's shortcut system removes shortcuts automatically when their
11785     parent widget is destroyed. It is best to use QAction or
11786     QShortcut to handle shortcuts, since they are easier to use than
11787     this low-level function. Note also that this is an expensive
11788     operation.
11789 
11790     \sa grabShortcut(), setShortcutEnabled()
11791 */
11792 void QWidget::releaseShortcut(int id)
11793 {
11794     Q_ASSERT(qApp);
11795     if (id)
11796         qApp->d_func()->shortcutMap.removeShortcut(id, this, 0);
11797 }
11798 
11799 /*!
11800     If \a enable is true, the shortcut with the given \a id is
11801     enabled; otherwise the shortcut is disabled.
11802 
11803     \warning You should not normally need to use this function since
11804     Qt's shortcut system enables/disables shortcuts automatically as
11805     widgets become hidden/visible and gain or lose focus. It is best
11806     to use QAction or QShortcut to handle shortcuts, since they are
11807     easier to use than this low-level function.
11808 
11809     \sa grabShortcut(), releaseShortcut()
11810 */
11811 void QWidget::setShortcutEnabled(int id, bool enable)
11812 {
11813     Q_ASSERT(qApp);
11814     if (id)
11815         qApp->d_func()->shortcutMap.setShortcutEnabled(enable, id, this, 0);
11816 }
11817 
11818 /*!
11819     \since 4.2
11820 
11821     If \a enable is true, auto repeat of the shortcut with the
11822     given \a id is enabled; otherwise it is disabled.
11823 
11824     \sa grabShortcut(), releaseShortcut()
11825 */
11826 void QWidget::setShortcutAutoRepeat(int id, bool enable)
11827 {
11828     Q_ASSERT(qApp);
11829     if (id)
11830         qApp->d_func()->shortcutMap.setShortcutAutoRepeat(enable, id, this, 0);
11831 }
11832 #endif // QT_NO_SHORTCUT
11833 
11834 /*!
11835     Updates the widget's micro focus.
11836 */
11837 void QWidget::updateMicroFocus()
11838 {
11839     // updating everything since this is currently called for any kind of state change
11840     if (this == QGuiApplication::focusObject())
11841         QGuiApplication::inputMethod()->update(Qt::ImQueryAll);
11842 }
11843 
11844 /*!
11845     Raises this widget to the top of the parent widget's stack.
11846 
11847     After this call the widget will be visually in front of any
11848     overlapping sibling widgets.
11849 
11850     \note When using activateWindow(), you can call this function to
11851     ensure that the window is stacked on top.
11852 
11853     \sa lower(), stackUnder()
11854 */
11855 
11856 void QWidget::raise()
11857 {
11858     Q_D(QWidget);
11859     if (!isWindow()) {
11860         QWidget *p = parentWidget();
11861         const int parentChildCount = p->d_func()->children.size();
11862         if (parentChildCount < 2)
11863             return;
11864         const int from = p->d_func()->children.indexOf(this);
11865         Q_ASSERT(from >= 0);
11866         // Do nothing if the widget is already in correct stacking order _and_ created.
11867         if (from != parentChildCount -1)
11868             p->d_func()->children.move(from, parentChildCount - 1);
11869         if (!testAttribute(Qt::WA_WState_Created) && p->testAttribute(Qt::WA_WState_Created))
11870             create();
11871         else if (from == parentChildCount - 1)
11872             return;
11873 
11874         QRegion region(rect());
11875         d->subtractOpaqueSiblings(region);
11876         d->invalidateBuffer(region);
11877     }
11878     if (testAttribute(Qt::WA_WState_Created))
11879         d->raise_sys();
11880 
11881     if (d->extra && d->extra->hasWindowContainer)
11882         QWindowContainer::parentWasRaised(this);
11883 
11884     QEvent e(QEvent::ZOrderChange);
11885     QApplication::sendEvent(this, &e);
11886 }
11887 
11888 void QWidgetPrivate::raise_sys()
11889 {
11890     Q_Q(QWidget);
11891     if (q->isWindow() || q->testAttribute(Qt::WA_NativeWindow)) {
11892         q->windowHandle()->raise();
11893     } else if (renderToTexture) {
11894         if (QWidget *p = q->parentWidget()) {
11895             setDirtyOpaqueRegion();
11896             p->d_func()->invalidateBuffer(effectiveRectFor(q->geometry()));
11897         }
11898     }
11899 }
11900 
11901 /*!
11902     Lowers the widget to the bottom of the parent widget's stack.
11903 
11904     After this call the widget will be visually behind (and therefore
11905     obscured by) any overlapping sibling widgets.
11906 
11907     \sa raise(), stackUnder()
11908 */
11909 
11910 void QWidget::lower()
11911 {
11912     Q_D(QWidget);
11913     if (!isWindow()) {
11914         QWidget *p = parentWidget();
11915         const int parentChildCount = p->d_func()->children.size();
11916         if (parentChildCount < 2)
11917             return;
11918         const int from = p->d_func()->children.indexOf(this);
11919         Q_ASSERT(from >= 0);
11920         // Do nothing if the widget is already in correct stacking order _and_ created.
11921         if (from != 0)
11922             p->d_func()->children.move(from, 0);
11923         if (!testAttribute(Qt::WA_WState_Created) && p->testAttribute(Qt::WA_WState_Created))
11924             create();
11925         else if (from == 0)
11926             return;
11927     }
11928     if (testAttribute(Qt::WA_WState_Created))
11929         d->lower_sys();
11930 
11931     if (d->extra && d->extra->hasWindowContainer)
11932         QWindowContainer::parentWasLowered(this);
11933 
11934     QEvent e(QEvent::ZOrderChange);
11935     QApplication::sendEvent(this, &e);
11936 }
11937 
11938 void QWidgetPrivate::lower_sys()
11939 {
11940     Q_Q(QWidget);
11941     if (q->isWindow() || q->testAttribute(Qt::WA_NativeWindow)) {
11942         Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
11943         q->windowHandle()->lower();
11944     } else if (QWidget *p = q->parentWidget()) {
11945         setDirtyOpaqueRegion();
11946         p->d_func()->invalidateBuffer(effectiveRectFor(q->geometry()));
11947     }
11948 }
11949 
11950 /*!
11951     Places the widget under \a w in the parent widget's stack.
11952 
11953     To make this work, the widget itself and \a w must be siblings.
11954 
11955     \sa raise(), lower()
11956 */
11957 void QWidget::stackUnder(QWidget* w)
11958 {
11959     Q_D(QWidget);
11960     QWidget *p = parentWidget();
11961     if (!w || isWindow() || p != w->parentWidget() || this == w)
11962         return;
11963     if (p) {
11964         int from = p->d_func()->children.indexOf(this);
11965         int to = p->d_func()->children.indexOf(w);
11966         Q_ASSERT(from >= 0);
11967         Q_ASSERT(to >= 0);
11968         if (from < to)
11969             --to;
11970         // Do nothing if the widget is already in correct stacking order _and_ created.
11971         if (from != to)
11972             p->d_func()->children.move(from, to);
11973         if (!testAttribute(Qt::WA_WState_Created) && p->testAttribute(Qt::WA_WState_Created))
11974             create();
11975         else if (from == to)
11976             return;
11977     }
11978     if (testAttribute(Qt::WA_WState_Created))
11979         d->stackUnder_sys(w);
11980 
11981     QEvent e(QEvent::ZOrderChange);
11982     QApplication::sendEvent(this, &e);
11983 }
11984 
11985 void QWidgetPrivate::stackUnder_sys(QWidget*)
11986 {
11987     Q_Q(QWidget);
11988     if (QWidget *p = q->parentWidget()) {
11989         setDirtyOpaqueRegion();
11990         p->d_func()->invalidateBuffer(effectiveRectFor(q->geometry()));
11991     }
11992 }
11993 
11994 /*!
11995     \fn bool QWidget::isTopLevel() const
11996     \obsolete
11997 
11998     Use isWindow() instead.
11999 */
12000 
12001 /*!
12002     \fn bool QWidget::isRightToLeft() const
12003     \internal
12004 */
12005 
12006 /*!
12007     \fn bool QWidget::isLeftToRight() const
12008     \internal
12009 */
12010 
12011 /*!
12012      \macro QWIDGETSIZE_MAX
12013      \relates QWidget
12014 
12015      Defines the maximum size for a QWidget object.
12016 
12017      The largest allowed size for a widget is QSize(QWIDGETSIZE_MAX,
12018      QWIDGETSIZE_MAX), i.e. QSize (16777215,16777215).
12019 
12020      \sa QWidget::setMaximumSize()
12021 */
12022 
12023 /*!
12024     \fn QWidget::setupUi(QWidget *widget)
12025 
12026     Sets up the user interface for the specified \a widget.
12027 
12028     \note This function is available with widgets that derive from user
12029     interface descriptions created using \l{uic}.
12030 
12031     \sa {Using a Designer UI File in Your Application}
12032 */
12033 
12034 QRect QWidgetPrivate::frameStrut() const
12035 {
12036     Q_Q(const QWidget);
12037     if (!q->isWindow() || (q->windowType() == Qt::Desktop) || q->testAttribute(Qt::WA_DontShowOnScreen)) {
12038         // x2 = x1 + w - 1, so w/h = 1
12039         return QRect(0, 0, 1, 1);
12040     }
12041 
12042     if (data.fstrut_dirty
12043 #if 1 // Used to be excluded in Qt4 for Q_WS_WIN
12044         // ### Fix properly for 4.3
12045         && q->isVisible()
12046 #endif
12047         && q->testAttribute(Qt::WA_WState_Created))
12048         const_cast<QWidgetPrivate *>(this)->updateFrameStrut();
12049 
12050     return maybeTopData() ? maybeTopData()->frameStrut : QRect();
12051 }
12052 
12053 void QWidgetPrivate::updateFrameStrut()
12054 {
12055     Q_Q(QWidget);
12056     if (q->data->fstrut_dirty) {
12057         if (QTLWExtra *te = maybeTopData()) {
12058             if (te->window && te->window->handle()) {
12059                 const QMargins margins = te->window->frameMargins();
12060                 if (!margins.isNull()) {
12061                     te->frameStrut.setCoords(margins.left(), margins.top(), margins.right(), margins.bottom());
12062                     q->data->fstrut_dirty = false;
12063                 }
12064             }
12065         }
12066     }
12067 }
12068 
12069 #ifdef QT_KEYPAD_NAVIGATION
12070 /*!
12071     \internal
12072 
12073     Changes the focus  from the current focusWidget to a widget in
12074     the \a direction.
12075 
12076     Returns \c true, if there was a widget in that direction
12077 */
12078 bool QWidgetPrivate::navigateToDirection(Direction direction)
12079 {
12080     QWidget *targetWidget = widgetInNavigationDirection(direction);
12081     if (targetWidget)
12082         targetWidget->setFocus();
12083     return (targetWidget != 0);
12084 }
12085 
12086 /*!
12087     \internal
12088 
12089     Searches for a widget that is positioned in the \a direction, starting
12090     from the current focusWidget.
12091 
12092     Returns the pointer to a found widget or 0, if there was no widget in
12093     that direction.
12094 */
12095 QWidget *QWidgetPrivate::widgetInNavigationDirection(Direction direction)
12096 {
12097     const QWidget *sourceWidget = QApplication::focusWidget();
12098     if (!sourceWidget)
12099         return 0;
12100     const QRect sourceRect = sourceWidget->rect().translated(sourceWidget->mapToGlobal(QPoint()));
12101     const int sourceX =
12102             (direction == DirectionNorth || direction == DirectionSouth) ?
12103                 (sourceRect.left() + (sourceRect.right() - sourceRect.left()) / 2)
12104                 :(direction == DirectionEast ? sourceRect.right() : sourceRect.left());
12105     const int sourceY =
12106             (direction == DirectionEast || direction == DirectionWest) ?
12107                 (sourceRect.top() + (sourceRect.bottom() - sourceRect.top()) / 2)
12108                 :(direction == DirectionSouth ? sourceRect.bottom() : sourceRect.top());
12109     const QPoint sourcePoint(sourceX, sourceY);
12110     const QPoint sourceCenter = sourceRect.center();
12111     const QWidget *sourceWindow = sourceWidget->window();
12112 
12113     QWidget *targetWidget = 0;
12114     int shortestDistance = INT_MAX;
12115 
12116     const auto targetCandidates = QApplication::allWidgets();
12117     for (QWidget *targetCandidate : targetCandidates) {
12118 
12119         const QRect targetCandidateRect = targetCandidate->rect().translated(targetCandidate->mapToGlobal(QPoint()));
12120 
12121         // For focus proxies, the child widget handling the focus can have keypad navigation focus,
12122         // but the owner of the proxy cannot.
12123         // Additionally, empty widgets should be ignored.
12124         if (targetCandidate->focusProxy() || targetCandidateRect.isEmpty())
12125             continue;
12126 
12127         // Only navigate to a target widget that...
12128         if (       targetCandidate != sourceWidget
12129                    // ...takes the focus,
12130                 && targetCandidate->focusPolicy() & Qt::TabFocus
12131                    // ...is above if DirectionNorth,
12132                 && !(direction == DirectionNorth && targetCandidateRect.bottom() > sourceRect.top())
12133                    // ...is on the right if DirectionEast,
12134                 && !(direction == DirectionEast  && targetCandidateRect.left()   < sourceRect.right())
12135                    // ...is below if DirectionSouth,
12136                 && !(direction == DirectionSouth && targetCandidateRect.top()    < sourceRect.bottom())
12137                    // ...is on the left if DirectionWest,
12138                 && !(direction == DirectionWest  && targetCandidateRect.right()  > sourceRect.left())
12139                    // ...is enabled,
12140                 && targetCandidate->isEnabled()
12141                    // ...is visible,
12142                 && targetCandidate->isVisible()
12143                    // ...is in the same window,
12144                 && targetCandidate->window() == sourceWindow) {
12145             const int targetCandidateDistance = pointToRect(sourcePoint, targetCandidateRect);
12146             if (targetCandidateDistance < shortestDistance) {
12147                 shortestDistance = targetCandidateDistance;
12148                 targetWidget = targetCandidate;
12149             }
12150         }
12151     }
12152     return targetWidget;
12153 }
12154 
12155 /*!
12156     \internal
12157 
12158     Tells us if it there is currently a reachable widget by keypad navigation in
12159     a certain \a orientation.
12160     If no navigation is possible, occurring key events in that \a orientation may
12161     be used to interact with the value in the focused widget, even though it
12162     currently has not the editFocus.
12163 
12164     \sa QWidgetPrivate::widgetInNavigationDirection(), QWidget::hasEditFocus()
12165 */
12166 bool QWidgetPrivate::canKeypadNavigate(Qt::Orientation orientation)
12167 {
12168     return orientation == Qt::Horizontal?
12169             (QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionEast)
12170                     || QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionWest))
12171             :(QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionNorth)
12172                     || QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionSouth));
12173 }
12174 /*!
12175     \internal
12176 
12177     Checks, if the \a widget is inside a QTabWidget. If is is inside
12178     one, left/right key events will be used to switch between tabs in keypad
12179     navigation. If there is no QTabWidget, the horizontal key events can be used
12180 to
12181     interact with the value in the focused widget, even though it currently has
12182     not the editFocus.
12183 
12184     \sa QWidget::hasEditFocus()
12185 */
12186 bool QWidgetPrivate::inTabWidget(QWidget *widget)
12187 {
12188     for (QWidget *tabWidget = widget; tabWidget; tabWidget = tabWidget->parentWidget())
12189         if (qobject_cast<const QTabWidget*>(tabWidget))
12190             return true;
12191     return false;
12192 }
12193 #endif
12194 
12195 /*!
12196     \since 5.0
12197     \internal
12198 
12199     Sets the backing store to be the \a store specified.
12200     The QWidget will take ownership of the \a store.
12201 */
12202 void QWidget::setBackingStore(QBackingStore *store)
12203 {
12204     // ### createWinId() ??
12205 
12206     if (!isTopLevel())
12207         return;
12208 
12209     Q_D(QWidget);
12210 
12211     QTLWExtra *topData = d->topData();
12212     if (topData->backingStore == store)
12213         return;
12214 
12215     QBackingStore *oldStore = topData->backingStore;
12216     deleteBackingStore(d);
12217     topData->backingStore = store;
12218 
12219     QWidgetBackingStore *bs = d->maybeBackingStore();
12220     if (!bs)
12221         return;
12222 
12223     if (isTopLevel()) {
12224         if (bs->store != oldStore && bs->store != store)
12225             delete bs->store;
12226         bs->store = store;
12227     }
12228 }
12229 
12230 /*!
12231     \since 5.0
12232 
12233     Returns the QBackingStore this widget will be drawn into.
12234 */
12235 QBackingStore *QWidget::backingStore() const
12236 {
12237     Q_D(const QWidget);
12238     QTLWExtra *extra = d->maybeTopData();
12239     if (extra && extra->backingStore)
12240         return extra->backingStore;
12241 
12242     QWidgetBackingStore *bs = d->maybeBackingStore();
12243 
12244     return bs ? bs->store : 0;
12245 }
12246 
12247 void QWidgetPrivate::getLayoutItemMargins(int *left, int *top, int *right, int *bottom) const
12248 {
12249     if (left)
12250         *left = (int)leftLayoutItemMargin;
12251     if (top)
12252         *top = (int)topLayoutItemMargin;
12253     if (right)
12254         *right = (int)rightLayoutItemMargin;
12255     if (bottom)
12256         *bottom = (int)bottomLayoutItemMargin;
12257 }
12258 
12259 void QWidgetPrivate::setLayoutItemMargins(int left, int top, int right, int bottom)
12260 {
12261     if (leftLayoutItemMargin == left
12262         && topLayoutItemMargin == top
12263         && rightLayoutItemMargin == right
12264         && bottomLayoutItemMargin == bottom)
12265         return;
12266 
12267     Q_Q(QWidget);
12268     leftLayoutItemMargin = (signed char)left;
12269     topLayoutItemMargin = (signed char)top;
12270     rightLayoutItemMargin = (signed char)right;
12271     bottomLayoutItemMargin = (signed char)bottom;
12272     q->updateGeometry();
12273 }
12274 
12275 void QWidgetPrivate::setLayoutItemMargins(QStyle::SubElement element, const QStyleOption *opt)
12276 {
12277     Q_Q(QWidget);
12278     QStyleOption myOpt;
12279     if (!opt) {
12280         myOpt.initFrom(q);
12281         myOpt.rect.setRect(0, 0, 32768, 32768);     // arbitrary
12282         opt = &myOpt;
12283     }
12284 
12285     QRect liRect = q->style()->subElementRect(element, opt, q);
12286     if (liRect.isValid()) {
12287         leftLayoutItemMargin = (signed char)(opt->rect.left() - liRect.left());
12288         topLayoutItemMargin = (signed char)(opt->rect.top() - liRect.top());
12289         rightLayoutItemMargin = (signed char)(liRect.right() - opt->rect.right());
12290         bottomLayoutItemMargin = (signed char)(liRect.bottom() - opt->rect.bottom());
12291     } else {
12292         leftLayoutItemMargin = 0;
12293         topLayoutItemMargin = 0;
12294         rightLayoutItemMargin = 0;
12295         bottomLayoutItemMargin = 0;
12296     }
12297 }
12298 // resets the Qt::WA_QuitOnClose attribute to the default value for transient widgets.
12299 void QWidgetPrivate::adjustQuitOnCloseAttribute()
12300 {
12301     Q_Q(QWidget);
12302 
12303     if (!q->parentWidget()) {
12304         Qt::WindowType type = q->windowType();
12305         if (type == Qt::Widget || type == Qt::SubWindow)
12306             type = Qt::Window;
12307         if (type != Qt::Widget && type != Qt::Window && type != Qt::Dialog)
12308             q->setAttribute(Qt::WA_QuitOnClose, false);
12309     }
12310 }
12311 
12312 QOpenGLContext *QWidgetPrivate::shareContext() const
12313 {
12314 #ifdef QT_NO_OPENGL
12315     return 0;
12316 #else
12317     if (Q_UNLIKELY(!extra || !extra->topextra || !extra->topextra->window))
12318         return 0;
12319 
12320     QWidgetPrivate *that = const_cast<QWidgetPrivate *>(this);
12321     if (!extra->topextra->shareContext) {
12322         QOpenGLContext *ctx = new QOpenGLContext;
12323         ctx->setShareContext(qt_gl_global_share_context());
12324         ctx->setFormat(extra->topextra->window->format());
12325         ctx->setScreen(extra->topextra->window->screen());
12326         ctx->create();
12327         that->extra->topextra->shareContext = ctx;
12328     }
12329     return that->extra->topextra->shareContext;
12330 #endif // QT_NO_OPENGL
12331 }
12332 
12333 #ifndef QT_NO_OPENGL
12334 void QWidgetPrivate::sendComposeStatus(QWidget *w, bool end)
12335 {
12336     QWidgetPrivate *wd = QWidgetPrivate::get(w);
12337     if (!wd->textureChildSeen)
12338         return;
12339     if (end)
12340         wd->endCompose();
12341     else
12342         wd->beginCompose();
12343     for (int i = 0; i < wd->children.size(); ++i) {
12344         w = qobject_cast<QWidget *>(wd->children.at(i));
12345         if (w && !w->isWindow() && !w->isHidden() && QWidgetPrivate::get(w)->textureChildSeen)
12346             sendComposeStatus(w, end);
12347     }
12348 }
12349 #endif // QT_NO_OPENGL
12350 
12351 Q_WIDGETS_EXPORT QWidgetData *qt_qwidget_data(QWidget *widget)
12352 {
12353     return widget->data;
12354 }
12355 
12356 Q_WIDGETS_EXPORT QWidgetPrivate *qt_widget_private(QWidget *widget)
12357 {
12358     return widget->d_func();
12359 }
12360 
12361 
12362 #if QT_CONFIG(graphicsview)
12363 /*!
12364    \since 4.5
12365 
12366    Returns the proxy widget for the corresponding embedded widget in a graphics
12367    view; otherwise returns 0.
12368 
12369    \sa QGraphicsProxyWidget::createProxyForChildWidget(),
12370        QGraphicsScene::addWidget()
12371  */
12372 QGraphicsProxyWidget *QWidget::graphicsProxyWidget() const
12373 {
12374     Q_D(const QWidget);
12375     if (d->extra) {
12376         return d->extra->proxyWidget;
12377     }
12378     return 0;
12379 }
12380 #endif
12381 
12382 #ifndef QT_NO_GESTURES
12383 /*!
12384     Subscribes the widget to a given \a gesture with specific \a flags.
12385 
12386     \sa ungrabGesture(), QGestureEvent
12387     \since 4.6
12388 */
12389 void QWidget::grabGesture(Qt::GestureType gesture, Qt::GestureFlags flags)
12390 {
12391     Q_D(QWidget);
12392     d->gestureContext.insert(gesture, flags);
12393     (void)QGestureManager::instance(); // create a gesture manager
12394 }
12395 
12396 /*!
12397     Unsubscribes the widget from a given \a gesture type
12398 
12399     \sa grabGesture(), QGestureEvent
12400     \since 4.6
12401 */
12402 void QWidget::ungrabGesture(Qt::GestureType gesture)
12403 {
12404     // if you modify this function, check the inlined version in ~QWidget, too
12405     Q_D(QWidget);
12406     if (d->gestureContext.remove(gesture)) {
12407         if (QGestureManager *manager = QGestureManager::instance())
12408             manager->cleanupCachedGestures(this, gesture);
12409     }
12410 }
12411 #endif // QT_NO_GESTURES
12412 
12413 /*!
12414     \fn void QWidget::destroy(bool destroyWindow, bool destroySubWindows)
12415 
12416     Frees up window system resources. Destroys the widget window if \a
12417     destroyWindow is true.
12418 
12419     destroy() calls itself recursively for all the child widgets,
12420     passing \a destroySubWindows for the \a destroyWindow parameter.
12421     To have more control over destruction of subwidgets, destroy
12422     subwidgets selectively first.
12423 
12424     This function is usually called from the QWidget destructor.
12425 */
12426 void QWidget::destroy(bool destroyWindow, bool destroySubWindows)
12427 {
12428     Q_D(QWidget);
12429 
12430     d->aboutToDestroy();
12431     if (!isWindow() && parentWidget())
12432         parentWidget()->d_func()->invalidateBuffer(d->effectiveRectFor(geometry()));
12433     d->deactivateWidgetCleanup();
12434 
12435     if ((windowType() == Qt::Popup) && qApp)
12436         qApp->d_func()->closePopup(this);
12437 
12438     if (this == QApplicationPrivate::active_window)
12439         QApplication::setActiveWindow(0);
12440     if (QWidget::mouseGrabber() == this)
12441         releaseMouse();
12442     if (QWidget::keyboardGrabber() == this)
12443         releaseKeyboard();
12444 
12445     setAttribute(Qt::WA_WState_Created, false);
12446 
12447     if (windowType() != Qt::Desktop) {
12448         if (destroySubWindows) {
12449             QObjectList childList(children());
12450             for (int i = 0; i < childList.size(); i++) {
12451                 QWidget *widget = qobject_cast<QWidget *>(childList.at(i));
12452                 if (widget && widget->testAttribute(Qt::WA_NativeWindow)) {
12453                     if (widget->windowHandle()) {
12454                         widget->destroy();
12455                     }
12456                 }
12457             }
12458         }
12459         if (destroyWindow) {
12460             d->deleteTLSysExtra();
12461         } else {
12462             if (parentWidget() && parentWidget()->testAttribute(Qt::WA_WState_Created)) {
12463                 d->hide_sys();
12464             }
12465         }
12466 
12467         d->setWinId(0);
12468     }
12469 }
12470 
12471 /*!
12472     \fn QPaintEngine *QWidget::paintEngine() const
12473 
12474     Returns the widget's paint engine.
12475 
12476     Note that this function should not be called explicitly by the
12477     user, since it's meant for reimplementation purposes only. The
12478     function is called by Qt internally, and the default
12479     implementation may not always return a valid pointer.
12480 */
12481 QPaintEngine *QWidget::paintEngine() const
12482 {
12483     qWarning("QWidget::paintEngine: Should no longer be called");
12484 
12485 #ifdef Q_OS_WIN
12486     // We set this bit which is checked in setAttribute for
12487     // Qt::WA_PaintOnScreen. We do this to allow these two scenarios:
12488     //
12489     // 1. Users accidentally set Qt::WA_PaintOnScreen on X and port to
12490     // Windows which would mean suddenly their widgets stop working.
12491     //
12492     // 2. Users set paint on screen and subclass paintEngine() to
12493     // return 0, in which case we have a "hole" in the backingstore
12494     // allowing use of GDI or DirectX directly.
12495     //
12496     // 1 is WRONG, but to minimize silent failures, we have set this
12497     // bit to ignore the setAttribute call. 2. needs to be
12498     // supported because its our only means of embedding native
12499     // graphics stuff.
12500     const_cast<QWidgetPrivate *>(d_func())->noPaintOnScreen = 1;
12501 #endif
12502 
12503     return 0; //##### @@@
12504 }
12505 
12506 // Do not call QWindow::mapToGlobal() until QPlatformWindow is properly showing.
12507 static inline bool canMapPosition(QWindow *window)
12508 {
12509     return window->handle() && !qt_window_private(window)->resizeEventPending;
12510 }
12511 
12512 #if QT_CONFIG(graphicsview)
12513 static inline QGraphicsProxyWidget *graphicsProxyWidget(const QWidget *w)
12514 {
12515     QGraphicsProxyWidget *result = nullptr;
12516     const QWidgetPrivate *d = qt_widget_private(const_cast<QWidget *>(w));
12517     if (d->extra)
12518         result = d->extra->proxyWidget;
12519     return result;
12520 }
12521 #endif // QT_CONFIG(graphicsview)
12522 
12523 struct MapToGlobalTransformResult {
12524     QTransform transform;
12525     QWindow *window;
12526 };
12527 
12528 static MapToGlobalTransformResult mapToGlobalTransform(const QWidget *w)
12529 {
12530     MapToGlobalTransformResult result;
12531     result.window = nullptr;
12532     for ( ; w ; w = w->parentWidget()) {
12533 #if QT_CONFIG(graphicsview)
12534         if (QGraphicsProxyWidget *qgpw = graphicsProxyWidget(w)) {
12535             if (const QGraphicsScene *scene = qgpw->scene()) {
12536                 const QList <QGraphicsView *> views = scene->views();
12537                 if (!views.isEmpty()) {
12538                     result.transform *= qgpw->sceneTransform();
12539                     result.transform *= views.first()->viewportTransform();
12540                     w = views.first()->viewport();
12541                 }
12542             }
12543         }
12544 #endif // QT_CONFIG(graphicsview)
12545         QWindow *window = w->windowHandle();
12546         if (window && canMapPosition(window)) {
12547             result.window = window;
12548             break;
12549         }
12550 
12551         const QPoint topLeft = w->geometry().topLeft();
12552         result.transform.translate(topLeft.x(), topLeft.y());
12553         if (w->isWindow())
12554             break;
12555     }
12556     return result;
12557 }
12558 
12559 /*!
12560     \fn QPoint QWidget::mapToGlobal(const QPoint &pos) const
12561 
12562     Translates the widget coordinate \a pos to global screen
12563     coordinates. For example, \c{mapToGlobal(QPoint(0,0))} would give
12564     the global coordinates of the top-left pixel of the widget.
12565 
12566     \sa mapFromGlobal(), mapTo(), mapToParent()
12567 */
12568 QPoint QWidget::mapToGlobal(const QPoint &pos) const
12569 {
12570     const MapToGlobalTransformResult t = mapToGlobalTransform(this);
12571     const QPoint g = t.transform.map(pos);
12572     return t.window ? t.window->mapToGlobal(g) : g;
12573 }
12574 
12575 /*!
12576     \fn QPoint QWidget::mapFromGlobal(const QPoint &pos) const
12577 
12578     Translates the global screen coordinate \a pos to widget
12579     coordinates.
12580 
12581     \sa mapToGlobal(), mapFrom(), mapFromParent()
12582 */
12583 QPoint QWidget::mapFromGlobal(const QPoint &pos) const
12584 {
12585    const MapToGlobalTransformResult t = mapToGlobalTransform(this);
12586    const QPoint windowLocal = t.window ? t.window->mapFromGlobal(pos) : pos;
12587    return t.transform.inverted().map(windowLocal);
12588 }
12589 
12590 QWidget *qt_pressGrab = 0;
12591 QWidget *qt_mouseGrb = 0;
12592 static bool mouseGrabWithCursor = false;
12593 static QWidget *keyboardGrb = 0;
12594 
12595 static inline QWindow *grabberWindow(const QWidget *w)
12596 {
12597     QWindow *window = w->windowHandle();
12598     if (!window)
12599         if (const QWidget *nativeParent = w->nativeParentWidget())
12600             window = nativeParent->windowHandle();
12601     return window;
12602 }
12603 
12604 #ifndef QT_NO_CURSOR
12605 static void grabMouseForWidget(QWidget *widget, const QCursor *cursor = 0)
12606 #else
12607 static void grabMouseForWidget(QWidget *widget)
12608 #endif
12609 {
12610     if (qt_mouseGrb)
12611         qt_mouseGrb->releaseMouse();
12612 
12613     mouseGrabWithCursor = false;
12614     if (QWindow *window = grabberWindow(widget)) {
12615 #ifndef QT_NO_CURSOR
12616         if (cursor) {
12617             mouseGrabWithCursor = true;
12618             QGuiApplication::setOverrideCursor(*cursor);
12619         }
12620 #endif // !QT_NO_CURSOR
12621         window->setMouseGrabEnabled(true);
12622     }
12623 
12624     qt_mouseGrb = widget;
12625     qt_pressGrab = 0;
12626 }
12627 
12628 static void releaseMouseGrabOfWidget(QWidget *widget)
12629 {
12630     if (qt_mouseGrb == widget) {
12631         if (QWindow *window = grabberWindow(widget)) {
12632 #ifndef QT_NO_CURSOR
12633             if (mouseGrabWithCursor) {
12634                 QGuiApplication::restoreOverrideCursor();
12635                 mouseGrabWithCursor = false;
12636             }
12637 #endif // !QT_NO_CURSOR
12638             window->setMouseGrabEnabled(false);
12639         }
12640     }
12641     qt_mouseGrb = 0;
12642 }
12643 
12644 /*!
12645     \fn void QWidget::grabMouse()
12646 
12647     Grabs the mouse input.
12648 
12649     This widget receives all mouse events until releaseMouse() is
12650     called; other widgets get no mouse events at all. Keyboard
12651     events are not affected. Use grabKeyboard() if you want to grab
12652     that.
12653 
12654     \warning Bugs in mouse-grabbing applications very often lock the
12655     terminal. Use this function with extreme caution, and consider
12656     using the \c -nograb command line option while debugging.
12657 
12658     It is almost never necessary to grab the mouse when using Qt, as
12659     Qt grabs and releases it sensibly. In particular, Qt grabs the
12660     mouse when a mouse button is pressed and keeps it until the last
12661     button is released.
12662 
12663     \note Only visible widgets can grab mouse input. If isVisible()
12664     returns \c false for a widget, that widget cannot call grabMouse().
12665 
12666     \note On Windows, grabMouse() only works when the mouse is inside a window
12667     owned by the process.
12668     On \macos, grabMouse() only works when the mouse is inside the frame of that widget.
12669 
12670     \sa releaseMouse(), grabKeyboard(), releaseKeyboard()
12671 */
12672 void QWidget::grabMouse()
12673 {
12674     grabMouseForWidget(this);
12675 }
12676 
12677 /*!
12678     \fn void QWidget::grabMouse(const QCursor &cursor)
12679     \overload grabMouse()
12680 
12681     Grabs the mouse input and changes the cursor shape.
12682 
12683     The cursor will assume shape \a cursor (for as long as the mouse
12684     focus is grabbed) and this widget will be the only one to receive
12685     mouse events until releaseMouse() is called().
12686 
12687     \warning Grabbing the mouse might lock the terminal.
12688 
12689     \note See the note in QWidget::grabMouse().
12690 
12691     \sa releaseMouse(), grabKeyboard(), releaseKeyboard(), setCursor()
12692 */
12693 #ifndef QT_NO_CURSOR
12694 void QWidget::grabMouse(const QCursor &cursor)
12695 {
12696     grabMouseForWidget(this, &cursor);
12697 }
12698 #endif
12699 
12700 bool QWidgetPrivate::stealMouseGrab(bool grab)
12701 {
12702     // This is like a combination of grab/releaseMouse() but with error checking
12703     // and it has no effect on the result of mouseGrabber().
12704     Q_Q(QWidget);
12705     QWindow *window = grabberWindow(q);
12706     return window ? window->setMouseGrabEnabled(grab) : false;
12707 }
12708 
12709 /*!
12710     \fn void QWidget::releaseMouse()
12711 
12712     Releases the mouse grab.
12713 
12714     \sa grabMouse(), grabKeyboard(), releaseKeyboard()
12715 */
12716 void QWidget::releaseMouse()
12717 {
12718     releaseMouseGrabOfWidget(this);
12719 }
12720 
12721 /*!
12722     \fn void QWidget::grabKeyboard()
12723 
12724     Grabs the keyboard input.
12725 
12726     This widget receives all keyboard events until releaseKeyboard()
12727     is called; other widgets get no keyboard events at all. Mouse
12728     events are not affected. Use grabMouse() if you want to grab that.
12729 
12730     The focus widget is not affected, except that it doesn't receive
12731     any keyboard events. setFocus() moves the focus as usual, but the
12732     new focus widget receives keyboard events only after
12733     releaseKeyboard() is called.
12734 
12735     If a different widget is currently grabbing keyboard input, that
12736     widget's grab is released first.
12737 
12738     \sa releaseKeyboard(), grabMouse(), releaseMouse(), focusWidget()
12739 */
12740 void QWidget::grabKeyboard()
12741 {
12742     if (keyboardGrb)
12743         keyboardGrb->releaseKeyboard();
12744     if (QWindow *window = grabberWindow(this))
12745         window->setKeyboardGrabEnabled(true);
12746     keyboardGrb = this;
12747 }
12748 
12749 bool QWidgetPrivate::stealKeyboardGrab(bool grab)
12750 {
12751     // This is like a combination of grab/releaseKeyboard() but with error
12752     // checking and it has no effect on the result of keyboardGrabber().
12753     Q_Q(QWidget);
12754     QWindow *window = grabberWindow(q);
12755     return window ? window->setKeyboardGrabEnabled(grab) : false;
12756 }
12757 
12758 /*!
12759     \fn void QWidget::releaseKeyboard()
12760 
12761     Releases the keyboard grab.
12762 
12763     \sa grabKeyboard(), grabMouse(), releaseMouse()
12764 */
12765 void QWidget::releaseKeyboard()
12766 {
12767     if (keyboardGrb == this) {
12768         if (QWindow *window = grabberWindow(this))
12769             window->setKeyboardGrabEnabled(false);
12770         keyboardGrb = 0;
12771     }
12772 }
12773 
12774 /*!
12775     \fn QWidget *QWidget::mouseGrabber()
12776 
12777     Returns the widget that is currently grabbing the mouse input.
12778 
12779     If no widget in this application is currently grabbing the mouse,
12780     0 is returned.
12781 
12782     \sa grabMouse(), keyboardGrabber()
12783 */
12784 QWidget *QWidget::mouseGrabber()
12785 {
12786     if (qt_mouseGrb)
12787         return qt_mouseGrb;
12788     return qt_pressGrab;
12789 }
12790 
12791 /*!
12792     \fn QWidget *QWidget::keyboardGrabber()
12793 
12794     Returns the widget that is currently grabbing the keyboard input.
12795 
12796     If no widget in this application is currently grabbing the
12797     keyboard, 0 is returned.
12798 
12799     \sa grabMouse(), mouseGrabber()
12800 */
12801 QWidget *QWidget::keyboardGrabber()
12802 {
12803     return keyboardGrb;
12804 }
12805 
12806 /*!
12807     \fn void QWidget::activateWindow()
12808 
12809     Sets the top-level widget containing this widget to be the active
12810     window.
12811 
12812     An active window is a visible top-level window that has the
12813     keyboard input focus.
12814 
12815     This function performs the same operation as clicking the mouse on
12816     the title bar of a top-level window. On X11, the result depends on
12817     the Window Manager. If you want to ensure that the window is
12818     stacked on top as well you should also call raise(). Note that the
12819     window must be visible, otherwise activateWindow() has no effect.
12820 
12821     On Windows, if you are calling this when the application is not
12822     currently the active one then it will not make it the active
12823     window.  It will change the color of the taskbar entry to indicate
12824     that the window has changed in some way. This is because Microsoft
12825     does not allow an application to interrupt what the user is currently
12826     doing in another application.
12827 
12828     \sa isActiveWindow(), window(), show(), QWindowsWindowFunctions::setWindowActivationBehavior()
12829 */
12830 void QWidget::activateWindow()
12831 {
12832     QWindow *const wnd = window()->windowHandle();
12833 
12834     if (wnd)
12835         wnd->requestActivate();
12836 }
12837 
12838 /*!
12839 
12840     Internal implementation of the virtual QPaintDevice::metric()
12841     function.
12842 
12843     \a m is the metric to get.
12844 */
12845 int QWidget::metric(PaintDeviceMetric m) const
12846 {
12847     QWindow *topLevelWindow = 0;
12848     QScreen *screen = 0;
12849     if (QWidget *topLevel = window()) {
12850         topLevelWindow = topLevel->windowHandle();
12851         if (topLevelWindow)
12852             screen = topLevelWindow->screen();
12853     }
12854     if (!screen && QGuiApplication::primaryScreen())
12855         screen = QGuiApplication::primaryScreen();
12856 
12857     if (!screen) {
12858         if (m == PdmDpiX || m == PdmDpiY)
12859               return 72;
12860         return QPaintDevice::metric(m);
12861     }
12862     int val;
12863     if (m == PdmWidth) {
12864         val = data->crect.width();
12865     } else if (m == PdmWidthMM) {
12866         val = data->crect.width() * screen->physicalSize().width() / screen->geometry().width();
12867     } else if (m == PdmHeight) {
12868         val = data->crect.height();
12869     } else if (m == PdmHeightMM) {
12870         val = data->crect.height() * screen->physicalSize().height() / screen->geometry().height();
12871     } else if (m == PdmDepth) {
12872         return screen->depth();
12873     } else if (m == PdmDpiX) {
12874         for (const QWidget *p = this; p; p = p->parentWidget()) {
12875             if (p->d_func()->extra && p->d_func()->extra->customDpiX)
12876                 return p->d_func()->extra->customDpiX;
12877         }
12878         return qRound(screen->logicalDotsPerInchX());
12879     } else if (m == PdmDpiY) {
12880         for (const QWidget *p = this; p; p = p->parentWidget()) {
12881             if (p->d_func()->extra && p->d_func()->extra->customDpiY)
12882                 return p->d_func()->extra->customDpiY;
12883         }
12884         return qRound(screen->logicalDotsPerInchY());
12885     } else if (m == PdmPhysicalDpiX) {
12886         return qRound(screen->physicalDotsPerInchX());
12887     } else if (m == PdmPhysicalDpiY) {
12888         return qRound(screen->physicalDotsPerInchY());
12889     } else if (m == PdmDevicePixelRatio) {
12890         return topLevelWindow ? topLevelWindow->devicePixelRatio() : qApp->devicePixelRatio();
12891     } else if (m == PdmDevicePixelRatioScaled) {
12892         return (QPaintDevice::devicePixelRatioFScale() *
12893                 (topLevelWindow ? topLevelWindow->devicePixelRatio() : qApp->devicePixelRatio()));
12894     } else {
12895         val = QPaintDevice::metric(m);// XXX
12896     }
12897     return val;
12898 }
12899 
12900 /*!
12901     Initializes the \a painter pen, background and font to the same as
12902     the given widget's. This function is called automatically when the
12903     painter is opened on a QWidget.
12904 */
12905 void QWidget::initPainter(QPainter *painter) const
12906 {
12907     const QPalette &pal = palette();
12908     painter->d_func()->state->pen = QPen(pal.brush(foregroundRole()), 1);
12909     painter->d_func()->state->bgBrush = pal.brush(backgroundRole());
12910     QFont f(font(), const_cast<QWidget *>(this));
12911     painter->d_func()->state->deviceFont = f;
12912     painter->d_func()->state->font = f;
12913 }
12914 
12915 /*!
12916     \internal
12917 
12918     Do PaintDevice rendering with the specified \a offset.
12919 */
12920 QPaintDevice *QWidget::redirected(QPoint *offset) const
12921 {
12922     return d_func()->redirected(offset);
12923 }
12924 
12925 /*!
12926     \internal
12927 
12928     A painter that is shared among other instances of QPainter.
12929 */
12930 QPainter *QWidget::sharedPainter() const
12931 {
12932     // Someone sent a paint event directly to the widget
12933     if (!d_func()->redirectDev)
12934         return 0;
12935 
12936     QPainter *sp = d_func()->sharedPainter();
12937     if (!sp || !sp->isActive())
12938         return 0;
12939 
12940     if (sp->paintEngine()->paintDevice() != d_func()->redirectDev)
12941         return 0;
12942 
12943     return sp;
12944 }
12945 
12946 /*!
12947     \fn void QWidget::setMask(const QRegion &region)
12948     \overload
12949 
12950     Causes only the parts of the widget which overlap \a region to be
12951     visible. If the region includes pixels outside the rect() of the
12952     widget, window system controls in that area may or may not be
12953     visible, depending on the platform.
12954 
12955     Note that this effect can be slow if the region is particularly
12956     complex.
12957 
12958     \sa windowOpacity
12959 */
12960 void QWidget::setMask(const QRegion &newMask)
12961 {
12962     Q_D(QWidget);
12963 
12964     d->createExtra();
12965     if (newMask == d->extra->mask)
12966         return;
12967 
12968 #ifndef QT_NO_BACKINGSTORE
12969     const QRegion oldMask(d->extra->mask);
12970 #endif
12971 
12972     d->extra->mask = newMask;
12973     d->extra->hasMask = !newMask.isEmpty();
12974 
12975 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
12976     if (!testAttribute(Qt::WA_WState_Created))
12977         return;
12978 #endif
12979 
12980     d->setMask_sys(newMask);
12981 
12982 #ifndef QT_NO_BACKINGSTORE
12983     if (!isVisible())
12984         return;
12985 
12986     if (!d->extra->hasMask) {
12987         // Mask was cleared; update newly exposed area.
12988         QRegion expose(rect());
12989         expose -= oldMask;
12990         if (!expose.isEmpty()) {
12991             d->setDirtyOpaqueRegion();
12992             update(expose);
12993         }
12994         return;
12995     }
12996 
12997     if (!isWindow()) {
12998         // Update newly exposed area on the parent widget.
12999         QRegion parentExpose(rect());
13000         parentExpose -= newMask;
13001         if (!parentExpose.isEmpty()) {
13002             d->setDirtyOpaqueRegion();
13003             parentExpose.translate(data->crect.topLeft());
13004             parentWidget()->update(parentExpose);
13005         }
13006 
13007         // Update newly exposed area on this widget
13008         if (!oldMask.isEmpty())
13009             update(newMask - oldMask);
13010     }
13011 #endif
13012 }
13013 
13014 void QWidgetPrivate::setMask_sys(const QRegion &region)
13015 {
13016     Q_Q(QWidget);
13017     if (QWindow *window = q->windowHandle())
13018         window->setMask(region);
13019 }
13020 
13021 /*!
13022     \fn void QWidget::setMask(const QBitmap &bitmap)
13023 
13024     Causes only the pixels of the widget for which \a bitmap has a
13025     corresponding 1 bit to be visible. If the region includes pixels
13026     outside the rect() of the widget, window system controls in that
13027     area may or may not be visible, depending on the platform.
13028 
13029     Note that this effect can be slow if the region is particularly
13030     complex.
13031 
13032     The following code shows how an image with an alpha channel can be
13033     used to generate a mask for a widget:
13034 
13035     \snippet widget-mask/main.cpp 0
13036 
13037     The label shown by this code is masked using the image it contains,
13038     giving the appearance that an irregularly-shaped image is being drawn
13039     directly onto the screen.
13040 
13041     Masked widgets receive mouse events only on their visible
13042     portions.
13043 
13044     \sa clearMask(), windowOpacity(), {Shaped Clock Example}
13045 */
13046 void QWidget::setMask(const QBitmap &bitmap)
13047 {
13048     setMask(QRegion(bitmap));
13049 }
13050 
13051 /*!
13052     \fn void QWidget::clearMask()
13053 
13054     Removes any mask set by setMask().
13055 
13056     \sa setMask()
13057 */
13058 void QWidget::clearMask()
13059 {
13060     Q_D(QWidget);
13061     if (!d->extra || !d->extra->hasMask)
13062         return;
13063     setMask(QRegion());
13064 }
13065 
13066 void QWidgetPrivate::setWidgetParentHelper(QObject *widgetAsObject, QObject *newParent)
13067 {
13068     Q_ASSERT(widgetAsObject->isWidgetType());
13069     Q_ASSERT(!newParent || newParent->isWidgetType());
13070     QWidget *widget = static_cast<QWidget*>(widgetAsObject);
13071     widget->setParent(static_cast<QWidget*>(newParent));
13072 }
13073 
13074 void QWidgetPrivate::setNetWmWindowTypes(bool skipIfMissing)
13075 {
13076     Q_Q(QWidget);
13077 
13078     if (!q->windowHandle())
13079         return;
13080 
13081     int wmWindowType = 0;
13082     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDesktop))
13083         wmWindowType |= QXcbWindowFunctions::Desktop;
13084     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDock))
13085         wmWindowType |= QXcbWindowFunctions::Dock;
13086     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeToolBar))
13087         wmWindowType |= QXcbWindowFunctions::Toolbar;
13088     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeMenu))
13089         wmWindowType |= QXcbWindowFunctions::Menu;
13090     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeUtility))
13091         wmWindowType |= QXcbWindowFunctions::Utility;
13092     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeSplash))
13093         wmWindowType |= QXcbWindowFunctions::Splash;
13094     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDialog))
13095         wmWindowType |= QXcbWindowFunctions::Dialog;
13096     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDropDownMenu))
13097         wmWindowType |= QXcbWindowFunctions::DropDownMenu;
13098     if (q->testAttribute(Qt::WA_X11NetWmWindowTypePopupMenu))
13099         wmWindowType |= QXcbWindowFunctions::PopupMenu;
13100     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeToolTip))
13101         wmWindowType |= QXcbWindowFunctions::Tooltip;
13102     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeNotification))
13103         wmWindowType |= QXcbWindowFunctions::Notification;
13104     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeCombo))
13105         wmWindowType |= QXcbWindowFunctions::Combo;
13106     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDND))
13107         wmWindowType |= QXcbWindowFunctions::Dnd;
13108 
13109     if (wmWindowType == 0 && skipIfMissing)
13110         return;
13111 
13112     QXcbWindowFunctions::setWmWindowType(q->windowHandle(), static_cast<QXcbWindowFunctions::WmWindowType>(wmWindowType));
13113 }
13114 
13115 #ifndef QT_NO_DEBUG_STREAM
13116 
13117 static inline void formatWidgetAttributes(QDebug debug, const QWidget *widget)
13118 {
13119     const QMetaObject *qtMo = qt_getEnumMetaObject(Qt::WA_AttributeCount);
13120     const QMetaEnum me = qtMo->enumerator(qtMo->indexOfEnumerator("WidgetAttribute"));
13121     debug << ", attributes=[";
13122     int count = 0;
13123     for (int a = 0; a < Qt::WA_AttributeCount; ++a) {
13124         if (widget->testAttribute(static_cast<Qt::WidgetAttribute>(a))) {
13125             if (count++)
13126                 debug << ',';
13127             debug << me.valueToKey(a);
13128         }
13129     }
13130     debug << ']';
13131 }
13132 
13133 QDebug operator<<(QDebug debug, const QWidget *widget)
13134 {
13135     const QDebugStateSaver saver(debug);
13136     debug.nospace();
13137     if (widget) {
13138         debug << widget->metaObject()->className() << '(' << (const void *)widget;
13139         if (!widget->objectName().isEmpty())
13140             debug << ", name=" << widget->objectName();
13141         if (debug.verbosity() > 2) {
13142             const QRect geometry = widget->geometry();
13143             const QRect frameGeometry = widget->frameGeometry();
13144             if (widget->isVisible())
13145                 debug << ", visible";
13146             if (!widget->isEnabled())
13147                 debug << ", disabled";
13148             debug << ", states=" << widget->windowState()
13149                 << ", type=" << widget->windowType() << ", flags=" <<  widget->windowFlags();
13150             formatWidgetAttributes(debug, widget);
13151             if (widget->isWindow())
13152                 debug << ", window";
13153             debug << ", " << geometry.width() << 'x' << geometry.height()
13154                 << forcesign << geometry.x() << geometry.y() << noforcesign;
13155             if (frameGeometry != geometry) {
13156                 const QMargins margins(geometry.x() - frameGeometry.x(),
13157                                        geometry.y() - frameGeometry.y(),
13158                                        frameGeometry.right() - geometry.right(),
13159                                        frameGeometry.bottom() - geometry.bottom());
13160                 debug << ", margins=" << margins;
13161             }
13162             debug << ", devicePixelRatio=" << widget->devicePixelRatioF();
13163             if (const WId wid = widget->internalWinId())
13164                 debug << ", winId=0x" << hex << wid << dec;
13165         }
13166         debug << ')';
13167     } else {
13168         debug << "QWidget(0x0)";
13169     }
13170     return debug;
13171 }
13172 #endif // !QT_NO_DEBUG_STREAM
13173 
13174 QT_END_NAMESPACE
13175 
13176 #include "moc_qwidget.cpp"
13177 
