Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2017 Intel Corporation.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include <QtTest/QtTest>
41 #include <qplatformdefs.h>
42 #include <private/qfsfileengine_p.h>
43 #include <private/qfilesystementry_p.h>
44 #include <private/qfilesystemengine_p.h>
45 #include <private/qfilesystemmetadata_p.h>
46 
47 #ifdef Q_OS_UNIX
48 #  include <private/qcore_unix_p.h>
49 #  include <sys/types.h>
50 #  include <sys/stat.h>
51 #  include <sys/time.h>
52 #  include <fcntl.h>
53 #  include <unistd.h>
54 
55 #  define SYMLINK_EXTENSION ""
56 enum { SupportsSymlinks = true };
57 #endif
58 
59 #ifdef Q_OS_WIN
60 #  include <qt_windows.h>
61 #  define access _access
62 #  define chmod _chmod
63 #  define unlink _unlink
64 #  define mkdir(name, x) QT_MKDIR(name)
65 
66 #  ifdef Q_OS_WINRT
67 enum { SupportsSymlinks = false };
68 #  else
69 #    include <shlobj.h>
70 #    include <accctrl.h>
71 #    define SYMLINK_EXTENSION ".lnk"
72 #  endif
73 #endif
74 
75 Q_DECLARE_METATYPE(QSystemError)
76 
77 char *toString(QSystemError err)
78 {
79     return qstrdup(err.toString().toUtf8());
80 }
81 
82 char *toString(QFile::Permissions p)
83 {
84     char buf[7];
85     snprintf(buf, sizeof(buf), "0x%04x", int(p));
86     return qstrdup(buf);
87 }
88 
89 static QDateTime round(QDateTime dt)
90 {
91     dt.setSecsSinceEpoch(dt.toSecsSinceEpoch());
92     return dt.toLocalTime();
93 }
94 
95 static void del(const QString &path)
96 {
97     QVERIFY2(unlink(QFile::encodeName(path)) == 0,
98              (QSystemError::stdString() + " removing file " + path).toUtf8());
99 };
100 
101 #ifdef Q_OS_UNIX
102 static bool isOneOfOurGroups(gid_t gid)
103 {
104     if (gid == getgid())
105         return true;
106 
107     // get additional GIDs
108     QVarLengthArray<gid_t, 16> additional(sysconf(_SC_NGROUPS_MAX));
109     int n = getgroups(additional.size(), additional.data());
110     if (n == -1) {
111         qErrnoWarning("getgroups");
112         return false;
113     }
114 
115     additional.resize(n);
116     return std::find(additional.begin(), additional.end(), gid) != additional.end();
117 }
118 #endif
119 
120 struct FileDescriptorCloser
121 {
122     int fd;
123     ~FileDescriptorCloser() { QT_CLOSE(fd); }
124 };
125 
126 class tst_QFileSystemEngine : public QObject
127 {
128     Q_OBJECT
129     QString m_testData;
130     QString m_tempDir;
131 
132 #ifdef Q_OS_WIN
133     // there are several paths in C:/Windows that we should not have access to,
134     // so choose one
135     QString unreadablePath = "C:/windows/System32/config/";
136     QString unwritablePath = "C:/";
137     QString unreadableFile = "C:/pagefile.sys";
138 #else
139     QString unreadablePath = "/root/";
140     QString unwritablePath = "/";
141     QString unreadableFile = "/etc/shadow";
142 #endif
143 
144 public:
145     tst_QFileSystemEngine();
146 
147 private slots:
148     void initTestCase();
149     void cleanupTestCase();
150 
151     void fillMetaData_data();
152     void fillMetaData();
153 #ifdef Q_OS_UNIX
154     void fillMetaData_removedFile();
155 #endif
156 
157     void setPermissions_data();
158     void setPermissions();
159 
160     void setFileTime_data();
161     void setFileTime();
162 };
163 
164 tst_QFileSystemEngine::tst_QFileSystemEngine()
165 {
166     // confirm that the paths are as advertised
167     if (access(QFile::encodeName(unreadablePath), F_OK) != 0 || access(QFile::encodeName(unreadablePath), R_OK) == 0)
168         unreadablePath.clear();
169 
170     if (access(QFile::encodeName(unreadableFile), F_OK) != 0 || access(QFile::encodeName(unreadableFile), R_OK) == 0)
171         unreadableFile.clear();
172 
173     if (access(QFile::encodeName(unwritablePath), F_OK) != 0 || access(QFile::encodeName(unwritablePath), R_OK) != 0
174             || access(QFile::encodeName(unwritablePath), W_OK) == 0)
175         unwritablePath.clear();
176 
177 #ifdef Q_OS_UNIX
178     if (access(QFile::encodeName(unreadablePath), X_OK) == 0)
179         unreadablePath.clear();
180 #endif
181 }
182 
183 void tst_QFileSystemEngine::initTestCase()
184 {
185     m_testData = QFINDTESTDATA("testdata");
186     QVERIFY(!m_testData.isEmpty());
187     QVERIFY2(!m_testData.startsWith(':'), "Test data cannot be in Qt resources");
188     m_testData.append('/');
189 
190     m_tempDir = QFileSystemEngine::tempPath() + "/tst_qfilesystemengine-" +
191             QString::number(QDateTime::currentDateTimeUtc().toMSecsSinceEpoch());
192     QVERIFY2(mkdir(QFile::encodeName(m_tempDir), 0700) == 0, QSystemError::stdString().toUtf8());
193     QVERIFY2(mkdir(QFile::encodeName(m_tempDir + "/subdir"), 0700) == 0, QSystemError::stdString().toUtf8());
194     m_tempDir += '/';
195 
196     auto touch = [=](const char *name, uint perms = 0600) {
197         int fd = QT_OPEN(QFile::encodeName(m_tempDir + name),
198                          QT_OPEN_RDWR | QT_OPEN_CREAT, perms);
199         if (fd != -1)
200             QT_CLOSE(fd);
201         return fd != -1;
202     };
203 
204     QVERIFY2(touch("dummy"), QSystemError::stdString().toUtf8());
205 
206     // used by fillMetaData
207     QVERIFY2(touch("writablefile.txt", 0600), QSystemError::stdString().toUtf8());
208     QVERIFY2(touch("readonlyfile.txt", 0400), QSystemError::stdString().toUtf8());
209 
210 #ifdef Q_OS_UNIX
211     QVERIFY2(touch("unreadablefile.txt", 0), QSystemError::stdString().toUtf8());
212     QVERIFY2(mkfifo(QFile::encodeName(m_tempDir + "fifo"), 0600) == 0,
213              QSystemError::stdString().toUtf8());
214 #endif
215 
216     // using QFileInfo here would use QFileSystemEngine, so we try with C
217     // library functions (which accept Unix-style forward slashes even on
218     // Windows)
219     QT_STATBUF statBuffer;
220     QByteArray testDir = QFile::encodeName(m_testData) ;
221 
222     QVERIFY2(QT_STAT(testDir, &statBuffer) == 0, QSystemError::stdString().toUtf8());
223     QVERIFY((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_DIR);
224     QVERIFY2(QT_STAT(testDir + ".hiddendirectory", &statBuffer) == 0, QSystemError::stdString().toUtf8());
225     QVERIFY((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_DIR);
226 
227     QVERIFY2(QT_STAT(testDir + "emptyfile", &statBuffer) == 0, QSystemError::stdString().toUtf8());
228     QVERIFY((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_REG);
229     QCOMPARE(qint64(statBuffer.st_size), qint64(0));
230 
231     QVERIFY2(QT_STAT(testDir + "regularfile.txt", &statBuffer) == 0, QSystemError::stdString().toUtf8());
232     QVERIFY((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_REG);
233     QVERIFY(statBuffer.st_size != 0);
234 
235     QVERIFY2(QT_STAT(testDir + ".hiddenfile", &statBuffer) == 0, QSystemError::stdString().toUtf8());
236     QVERIFY((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_REG);
237 
238 #ifdef Q_OS_UNIX
239     QVERIFY2(QT_ACCESS(testDir + "link-to-regularfile.txt", R_OK) == 0, QSystemError::stdString().toUtf8());
240     QVERIFY2(QT_ACCESS(testDir + "link-to-emptyfile", R_OK) == 0, QSystemError::stdString().toUtf8());
241     QVERIFY2(QT_LSTAT(testDir + "link-to-nonexistent", &statBuffer) == 0, QSystemError::stdString().toUtf8());
242     QVERIFY(S_ISLNK(statBuffer.st_mode));
243 #else
244     QVERIFY2(QT_ACCESS(testDir + "link-to-nonexistent.lnk", R_OK) == 0, QSystemError::stdString().toUtf8());
245 
246     // however, the non-broken symlink must be created now
247     QFSFileEngine engine(m_testData + "regularfile.txt");
248     QVERIFY2(engine.link(m_tempDir + "link-to-regularfile.txt.lnk"), engine.errorString().toUtf8());
249 #endif
250 }
251 
252 void tst_QFileSystemEngine::cleanupTestCase()
253 {
254 #ifdef Q_OS_WIN
255     del(m_tempDir + "link-to-regularfile.txt.lnk");
256 #else
257     del(m_tempDir + "unreadablefile.txt");
258     del(m_tempDir + "fifo");
259 #endif
260 
261     chmod(QFile::encodeName(m_tempDir + "readonlyfile.txt"), 0600);
262     del(m_tempDir + "readonlyfile.txt");
263     del(m_tempDir + "writablefile.txt");
264 
265     del(m_tempDir + "dummy");
266 
267     [=]() {
268         QVERIFY2(QT_RMDIR(QFile::encodeName(m_tempDir + "subdir")) == 0, QSystemError::stdString().toUtf8());
269     }();
270     QVERIFY2(QT_RMDIR(QFile::encodeName(m_tempDir)) == 0, QSystemError::stdString().toUtf8());
271 }
272 
273 void tst_QFileSystemEngine::fillMetaData_data()
274 {
275     QTest::addColumn<QString>("name");
276     QTest::addColumn<bool>("isLink");
277     QTest::addColumn<uint>("mustHaveFlags");
278     QTest::addColumn<uint>("mustNotHaveFlags");
279 
280     QTest::newRow("nonexistent")
281             << "nonexistent" << false
282             << 0U << uint(QFileSystemMetaData::ExistsAttribute);
283     QTest::newRow("L:nonexistent")
284             << "nonexistent" << true
285             << 0U << uint(QFileSystemMetaData::ExistsAttribute);
286 
287     // directories
288     uint expectedDirFlags = QFileSystemMetaData::DirectoryType;
289     uint unexpectedDirFlags = uint(QFileSystemMetaData::FileType | QFileSystemMetaData::SequentialType |
290                                    QFileSystemMetaData::HiddenAttribute);
291 #ifdef Q_OS_UNIX
292     expectedDirFlags |= QFileSystemMetaData::ReadPermissions | QFileSystemMetaData::ExecutePermissions;
293 #endif
294     QTest::newRow("directory")
295             << m_testData << false
296             << expectedDirFlags << unexpectedDirFlags;
297     QTest::newRow("L:directory")
298             << m_testData << true
299             << expectedDirFlags << unexpectedDirFlags;
300 #ifdef Q_OS_UNIX
301     QTest::newRow("/")
302             << "/" << false
303             << expectedDirFlags
304             << uint(unexpectedDirFlags | (QFileSystemMetaData::WritePermissions & ~QFileSystemMetaData::OwnerWritePermission));
305     QTest::newRow("TMPDIR") // might be a private dir
306             << QFileSystemEngine::tempPath() << false
307             << uint(QFileSystemMetaData::DirectoryType | QFileSystemMetaData::UserPermissions)
308             << uint(unexpectedDirFlags);
309     uint tmpHidden = 0;
310 #  ifdef Q_OS_MACOS
311     tmpHidden = QFileSystemMetaData::HiddenAttribute;
312 #  endif
313     QTest::newRow("/tmp")
314             << "/tmp" << false
315             << (expectedDirFlags | QFileSystemMetaData::WritePermissions | tmpHidden)
316             << uint(unexpectedDirFlags & ~tmpHidden);
317     if (access("/root", R_OK) == -1 && errno == EACCES)
318         QTest::newRow("/root")
319                 << "/root" << false
320                 << uint(QFileSystemMetaData::DirectoryType | QFileSystemMetaData::OwnerPermissions)
321                 << uint(unexpectedDirFlags | (QFileSystemMetaData::Permissions & ~QFileSystemMetaData::OwnerPermissions));
322     QTest::newRow("hiddendirectory")
323             << (m_testData + ".hiddendirectory") << false
324             << uint(expectedDirFlags | QFileSystemMetaData::HiddenAttribute)
325             << uint(unexpectedDirFlags & ~QFileSystemMetaData::HiddenAttribute);
326     QTest::newRow("L:hiddendirectory")
327             << (m_testData + ".hiddendirectory") << true
328             << uint(expectedDirFlags | QFileSystemMetaData::HiddenAttribute)
329             << uint(unexpectedDirFlags & ~QFileSystemMetaData::HiddenAttribute);
330 #endif
331 
332     // files
333     // files from the Git repository may be group/other writable or not
334     // files we've just created aren't
335     uint expectedFileFlags = QFileSystemMetaData::FileType;
336     uint unexpectedFileFlags = uint(QFileSystemMetaData::DirectoryType | QFileSystemMetaData::SequentialType |
337                                     QFileSystemMetaData::HiddenAttribute | QFileSystemMetaData::ExecutePermissions);
338     uint unexpectedOurFileFlags = unexpectedFileFlags |
339             uint(QFileSystemMetaData::GroupPermissions | QFileSystemMetaData::OtherPermissions);
340 
341 #ifdef Q_OS_UNIX
342     expectedFileFlags |= QFileSystemMetaData::OwnerReadPermission;
343 #endif
344     QTest::newRow("regularfile.txt")
345             << (m_testData + "regularfile.txt") << false
346             << expectedFileFlags << unexpectedFileFlags;
347     QTest::newRow("L:regularfile.txt")
348             << (m_testData + "regularfile.txt") << true
349             << expectedFileFlags << unexpectedFileFlags;
350     QTest::newRow("emptyfile")
351             << (m_testData + "emptyfile") << false
352             << expectedFileFlags << unexpectedFileFlags;
353     QTest::newRow("L:emptyfile")
354             << (m_testData + "emptyfile") << true
355             << expectedFileFlags << unexpectedFileFlags;    
356     QTest::newRow("writablefile.txt")
357             << (m_tempDir + "writablefile.txt") << false
358             << uint(expectedFileFlags | QFileSystemMetaData::UserWritePermission | QFileSystemMetaData::OwnerWritePermission)
359             << unexpectedOurFileFlags;
360     QTest::newRow("L:writablefile.txt")
361             << (m_tempDir + "writablefile.txt") << true
362             << uint(expectedFileFlags | QFileSystemMetaData::UserWritePermission | QFileSystemMetaData::OwnerWritePermission)
363             << unexpectedOurFileFlags;
364     QTest::newRow("readonlyfile.txt")
365             << (m_tempDir + "readonlyfile.txt") << false
366             << uint(expectedFileFlags | QFileSystemMetaData::OwnerReadPermission)
367             << uint(unexpectedOurFileFlags | QFileSystemMetaData::WritePermissions);
368     QTest::newRow("L:readonlyfile.txt")
369             << (m_tempDir + "readonlyfile.txt") << true
370             << uint(expectedFileFlags | QFileSystemMetaData::OwnerReadPermission)
371             << uint(unexpectedOurFileFlags | QFileSystemMetaData::WritePermissions);
372     if (!unreadableFile.isEmpty())
373         QTest::newRow("system-unreadable-file")
374                 << unreadableFile << false
375                 << uint(QFileSystemMetaData::FileType | QFileSystemMetaData::OwnerReadPermission | QFileSystemMetaData::OwnerWritePermission)
376                 << uint(unexpectedFileFlags | QFileSystemMetaData::UserPermissions | QFileSystemMetaData::OtherPermissions);
377 #ifdef Q_OS_UNIX
378     QTest::newRow("unreadablefile.txt")
379             << (m_tempDir + "unreadablefile.txt") << false
380             << uint(expectedFileFlags & ~QFileSystemMetaData::ReadPermissions)
381             << uint(unexpectedFileFlags | QFileSystemMetaData::Permissions);
382     QTest::newRow("L:unreadablefile.txt")
383             << (m_tempDir + "unreadablefile.txt") << true
384             << uint(expectedFileFlags & ~QFileSystemMetaData::ReadPermissions)
385             << uint(unexpectedFileFlags | QFileSystemMetaData::Permissions);
386     QTest::newRow("hiddenfile")
387             << (m_testData + ".hiddenfile") << false
388             << uint(expectedFileFlags | QFileSystemMetaData::HiddenAttribute)
389             << uint(unexpectedFileFlags & ~QFileSystemMetaData::HiddenAttribute);
390     QTest::newRow("L:hiddenfile")
391             << (m_testData + ".hiddenfile") << true
392             << uint(expectedFileFlags | QFileSystemMetaData::HiddenAttribute)
393             << uint(unexpectedFileFlags & ~QFileSystemMetaData::HiddenAttribute);
394 #endif
395 
396     // links
397     QTest::newRow("link-to-regularfile.txt" SYMLINK_EXTENSION)
398             << (m_testData + "link-to-regularfile.txt" SYMLINK_EXTENSION) << true
399             << expectedFileFlags << unexpectedFileFlags;
400     QTest::newRow("L:link-to-regularfile.txt" SYMLINK_EXTENSION)
401             << (m_testData + "link-to-regularfile.txt" SYMLINK_EXTENSION) << true
402             << (expectedFileFlags | QFileSystemMetaData::LegacyLinkType)
403             << unexpectedFileFlags;
404     QTest::newRow("link-to-nonexistent")
405 #ifdef Q_OS_WIN
406             << (m_tempDir + "link-to-nonexistent.lnk")
407 #else
408             << (m_testData + "link-to-nonexistent")
409 #endif
410             << false << 0U << uint(QFileSystemMetaData::ExistsAttribute);
411     QTest::newRow("L:link-to-nonexistent")
412 #ifdef Q_OS_WIN
413             << (m_tempDir + "link-to-nonexistent.lnk")
414 #else
415             << (m_testData + "link-to-nonexistent")
416 #endif
417             << true << uint(QFileSystemMetaData::LegacyLinkType)
418             << uint(QFileSystemMetaData::ExistsAttribute);
419 
420     // special files
421 #ifdef Q_OS_UNIX
422     QTest::newRow("/dev/null")
423             << "/dev/null" << false
424             << uint(QFileSystemMetaData::ReadPermissions | QFileSystemMetaData::WritePermissions | QFileSystemMetaData::SequentialType)
425             << uint(QFileSystemMetaData::ExecutePermissions | QFileSystemMetaData::HiddenAttribute);
426 #endif
427 #ifdef Q_OS_LINUX
428     QTest::newRow("fifo")
429             << (m_tempDir + "fifo") << false
430             << uint(QFileSystemMetaData::OwnerReadPermission | QFileSystemMetaData::OwnerWritePermission |
431                     QFileSystemMetaData::UserReadPermission | QFileSystemMetaData::UserWritePermission | QFileSystemMetaData::SequentialType)
432             << uint(QFileSystemMetaData::ExecutePermissions | QFileSystemMetaData::GroupPermissions |
433                     QFileSystemMetaData::OtherPermissions | QFileSystemMetaData::HiddenAttribute);
434 #endif
435 }
436 
437 void tst_QFileSystemEngine::fillMetaData()
438 {
439     QFETCH(QString, name);
440     QFETCH(bool, isLink);
441     QFETCH(uint, mustHaveFlags);
442     QFETCH(uint, mustNotHaveFlags);
443     QVERIFY2((mustHaveFlags & mustNotHaveFlags) == 0,
444              "Malformed test - 0x" + QByteArray::number(mustHaveFlags & mustNotHaveFlags, 16));
445 
446     QFileSystemMetaData::MetaDataFlags what;
447 #ifdef Q_OS_WIN
448     what = QFileSystemMetaData::WinStatFlags;
449 #else
450     what = QFileSystemMetaData::PosixStatFlags | QFileSystemMetaData::HiddenAttribute
451             | QFileSystemMetaData::BundleType | QFileSystemMetaData::AliasType
452             | QFileSystemMetaData::UserPermissions;
453 #endif
454     if (isLink)
455         what |= QFileSystemMetaData::LegacyLinkType;
456 
457     bool mustExist = true;
458     if (mustNotHaveFlags & QFileSystemMetaData::ExistsAttribute) {
459         mustExist = false;
460     } else {
461         mustHaveFlags |= QFileSystemMetaData::ExistsAttribute;
462     }
463     mustHaveFlags &= what;
464 
465     QFileSystemEntry entry(name);
466     QFileSystemMetaData data;
467     QSystemResult<> r = QFileSystemEngine::fillMetaData(entry, data, what);
468 
469     if (!mustExist) {
470         QVERIFY(r.isError());
471         if (mustHaveFlags & QFileSystemMetaData::LegacyLinkType)
472             QVERIFY(data.isLegacyLink());
473         return;
474     }
475 
476     if (r.isError())
477         QVERIFY2(!r.isError(), r.error().toString().toUtf8());
478 
479     // some information is always present
480     QVERIFY(data.hasFlags(QFileSystemMetaData::HiddenAttribute));
481     QVERIFY(data.hasFlags(QFileSystemMetaData::SizeAttribute));
482     QVERIFY(data.hasFlags(QFileSystemMetaData::ExistsAttribute));
483     QVERIFY(data.hasFlags(QFileSystemMetaData::WasDeletedAttribute));
484 #ifdef Q_OS_WIN
485     QVERIFY(data.hasFlags(QFileSystemMetaData::WinStatFlags));
486 #else
487     QVERIFY(data.hasFlags(QFileSystemMetaData::PosixStatFlags));
488 #endif
489 
490 #define ATTRCOMPARE(test, flag) \
491     if (mustHaveFlags & (flag)) \
492         QVERIFY(test); \
493     else if (mustNotHaveFlags & (flag)) \
494         QVERIFY(!test)
495     ATTRCOMPARE(data.exists(), QFileSystemMetaData::ExistsAttribute);
496     ATTRCOMPARE(data.isLegacyLink(), QFileSystemMetaData::LegacyLinkType);
497     ATTRCOMPARE(data.isFile(), QFileSystemMetaData::FileType);
498     ATTRCOMPARE(data.isDirectory(), QFileSystemMetaData::DirectoryType);
499     ATTRCOMPARE(data.isSequential(), QFileSystemMetaData::SequentialType);
500     ATTRCOMPARE(data.isHidden(), QFileSystemMetaData::HiddenAttribute);
501     QVERIFY(!data.wasDeleted());
502 
503     if (mustHaveFlags & QFileSystemMetaData::Permissions) {
504         QFile::Permissions perms = data.permissions();
505         auto mustHavePerms = QFile::Permissions(mustHaveFlags & QFileSystemMetaData::Permissions);
506         QCOMPARE(perms & mustHaveFlags, mustHavePerms);
507     }
508     if (mustNotHaveFlags & QFileSystemMetaData::Permissions) {
509         QFile::Permissions perms = data.permissions();
510         QCOMPARE(perms & mustNotHaveFlags, QFile::Permissions());
511     }
512 
513 #ifdef Q_OS_WIN
514     QVERIFY(data.birthTime().isValid());
515 #endif
516     QVERIFY(data.modificationTime().isValid());
517     QVERIFY(data.metadataChangeTime().isValid());
518     QVERIFY(data.accessTime().isValid());
519 
520     // compare some information
521     QT_STATBUF statBuffer = {};
522     QVERIFY2(QT_STAT(QFile::encodeName(name), &statBuffer) == 0, QSystemError::stdString().toUtf8());
523     if ((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_REG) {
524         QVERIFY(data.isFile());
525         QVERIFY(!data.isDirectory());
526         QVERIFY(!data.isSequential());
527         QCOMPARE(data.size(), qint64(statBuffer.st_size));
528     } else if ((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_DIR) {
529         QVERIFY(!data.isFile());
530         QVERIFY(data.isDirectory());
531         QVERIFY(!data.isSequential());
532     } else {
533         QVERIFY(!data.isFile());
534         QVERIFY(!data.isDirectory());
535     }
536     QCOMPARE(!data.wasDeleted(), statBuffer.st_nlink > 0);
537     QCOMPARE(round(data.modificationTime()), QDateTime::fromSecsSinceEpoch(statBuffer.st_mtime));
538     QCOMPARE(round(data.accessTime()), QDateTime::fromSecsSinceEpoch(statBuffer.st_atime));
539 #ifdef Q_OS_WIN
540     // On Windows, st_ctime stores the birth time; no change time is stored
541     QCOMPARE(round(data.birthTime()), QDateTime::fromSecsSinceEpoch(statBuffer.st_ctime));
542 #else
543     QCOMPARE(round(data.metadataChangeTime()), QDateTime::fromSecsSinceEpoch(statBuffer.st_ctime));
544 #  ifdef Q_OS_BSD4
545     // POSIX has no st_birthtime, though it's present on some systems
546     if (statBuffer.st_birthtime)
547         QCOMPARE(round(data.birthTime()), QDateTime::fromSecsSinceEpoch(statBuffer.st_birthtime));
548 #  endif
549 #endif
550     if (data.hasFlags(QFileSystemMetaData::OwnerIds)) {
551         QCOMPARE(data.userId(), uint(statBuffer.st_uid));
552         QCOMPARE(data.groupId(), uint(statBuffer.st_gid));
553     }
554 
555     // now try with a handle
556     int openflags = QT_OPEN_RDONLY;
557 #ifdef O_PATH
558     openflags |= O_PATH;    // can open (but not read) unreadable file
559 #endif
560 #ifdef O_DIRECTORY
561     if (data.isDirectory())
562         openflags |= O_DIRECTORY;
563 #else
564     if (data.isDirectory()) {
565         // don't try to open a directory without O_DIRECTORY
566         return;
567     }
568 #endif
569 
570     int fd = QT_OPEN(QFile::encodeName(name), openflags);
571     if (fd == -1 && (mustNotHaveFlags & QFileSystemMetaData::UserReadPermission))
572         return;
573     QVERIFY2(fd != -1, QSystemError::stdString().toUtf8());
574 
575     // automatically close the file for is
576     FileDescriptorCloser closeFd = { fd };
577 
578     QFileSystemMetaData data2;
579     r = QFileSystemEngine::fillMetaData(fd, data2);
580     if (r.isError())
581         QVERIFY2(!r.isError(), r.error().toString().toUtf8());
582 
583 #ifdef Q_OS_WIN
584     QVERIFY(data2.hasFlags(QFileSystemMetaData::WinStatFlags));
585     QVERIFY(data2.hasFlags(QFileSystemMetaData::ExistsAttribute));
586     QVERIFY(data2.exists());
587     ATTRCOMPARE(data2.isHidden(), QFileSystemMetaData::HiddenAttribute);
588 #else
589     QVERIFY(data2.hasFlags(QFileSystemMetaData::PosixStatFlags));
590     QVERIFY(!data2.hasFlags(QFileSystemMetaData::ExistsAttribute));
591     QVERIFY(!data2.hasFlags(QFileSystemMetaData::HiddenAttribute));
592 #endif
593     QVERIFY(!data2.hasFlags(QFileSystemMetaData::LegacyLinkType));
594 
595     ATTRCOMPARE(data2.isFile(), QFileSystemMetaData::FileType);
596     ATTRCOMPARE(data2.isDirectory(), QFileSystemMetaData::DirectoryType);
597     ATTRCOMPARE(data2.isSequential(), QFileSystemMetaData::SequentialType);
598     QVERIFY(!data2.wasDeleted());
599 
600     if ((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_REG) {
601         QVERIFY(data2.isFile());
602         QVERIFY(!data2.isDirectory());
603         QVERIFY(!data2.isSequential());
604         QCOMPARE(data2.size(), qint64(statBuffer.st_size));
605     } else if ((statBuffer.st_mode & QT_STAT_MASK) == QT_STAT_DIR) {
606         QVERIFY(!data2.isFile());
607         QVERIFY(data2.isDirectory());
608         QVERIFY(!data2.isSequential());
609     } else {
610         QVERIFY(!data2.isFile());
611         QVERIFY(!data2.isDirectory());
612     }
613 
614     if (mustHaveFlags & QFileSystemMetaData::Permissions) {
615         QFile::Permissions perms = data2.permissions();
616         auto mustHavePerms = QFile::Permissions(mustHaveFlags & QFileSystemMetaData::Permissions
617                                                 & ~QFileSystemMetaData::UserPermissions);
618         QCOMPARE(perms & mustHaveFlags, mustHavePerms);
619     }
620     if (mustNotHaveFlags & QFileSystemMetaData::Permissions) {
621         QFile::Permissions perms = data2.permissions();
622         QCOMPARE(perms & mustNotHaveFlags, QFile::Permissions());
623     }
624 
625     QCOMPARE(data2.birthTime(), data.birthTime());
626     QCOMPARE(data2.modificationTime(), data.modificationTime());
627     QCOMPARE(data2.metadataChangeTime(), data.metadataChangeTime());
628     QVERIFY(data2.accessTime() >= data.accessTime());  // we accessed the file...
629 }
630 
631 #ifdef Q_OS_UNIX
632 void tst_QFileSystemEngine::fillMetaData_removedFile()
633 {
634     // create the file execute-only
635     QFileSystemEntry entry(m_tempDir + "removedfile.txt");
636     int fd = QT_OPEN(entry.nativeFilePath(), QT_OPEN_RDWR | QT_OPEN_CREAT, 0111);
637     QVERIFY2(fd != -1, QSystemError::stdString().toUtf8());
638     if (unlink(entry.nativeFilePath()) == -1)
639         QSKIP("Could not remove open file: " + QSystemError::stdString().toUtf8());
640 
641     // write something to it
642     QVERIFY2(QT_WRITE(fd, "Hello", 5) == 5, QSystemError::stdString().toUtf8());
643 
644     QFileSystemMetaData data;
645     QSystemResult<> r = QFileSystemEngine::fillMetaData(fd, data);
646     if (r.isError())
647         QVERIFY2(!r.isError(), r.toString().toUtf8());
648 
649     // some information is always present and some can't be calculated
650     QVERIFY(!data.hasFlags(QFileSystemMetaData::HiddenAttribute));
651     QVERIFY(!data.hasFlags(QFileSystemMetaData::ExistsAttribute));
652     QVERIFY(!data.hasFlags(QFileSystemMetaData::UserPermissions));
653     QVERIFY(data.hasFlags(QFileSystemMetaData::SizeAttribute));
654     QVERIFY(data.hasFlags(QFileSystemMetaData::WasDeletedAttribute));
655     QVERIFY(data.hasFlags(QFileSystemMetaData::PosixStatFlags));
656 
657     QVERIFY(data.wasDeleted()); // inode exists but file was erased
658 
659     QVERIFY(data.isFile());
660     QVERIFY(!data.isDirectory());
661     QVERIFY(!data.isSequential());
662 
663     QCOMPARE(data.size(), qint64(5));
664 
665     // we've just created this file, so we know the identity
666     QCOMPARE(data.userId(), uint(getuid()));
667     QVERIFY2(isOneOfOurGroups(data.groupId()), QByteArray::number(data.groupId()));
668 
669     QCOMPARE(data.permissions() & QFileSystemMetaData::OwnerPermissions, QFileSystemMetaData::OwnerExecutePermission);
670 
671     QVERIFY(data.modificationTime().isValid());
672     QVERIFY(data.metadataChangeTime().isValid());
673     QVERIFY(data.accessTime().isValid());
674 }
675 #endif
676 
677 void tst_QFileSystemEngine::setPermissions_data()
678 {
679     QTest::addColumn<QString>("name");
680     QTest::addColumn<uint>("perms");
681     QTest::addColumn<QSystemError>("expectedError");
682     QTest::addColumn<bool>("tryFchmod");
683 
684 #ifdef Q_OS_WIN
685     QSystemError enoent(ERROR_FILE_NOT_FOUND, QSystemError::NativeError);
686     auto errorFor = [](const QString &path) {
687         HANDLE h = CreateFile2((const wchar_t*)path.utf16(),
688                                GENERIC_READ | GENERIC_WRITE,
689                                FILE_SHARE_READ,
690                                OPEN_ALWAYS, NULL);
691         if (h != INVALID_HANDLE_VALUE) {
692             qWarning("Whoa! I succeeded in creating file %s", qUtf8Printable(path));
693             CloseHandle(h);
694             del(path);
695         }
696         return QSystemError::lastErrorFor(QSystemError::StandardLibraryError);
697     };
698 #else
699     QSystemError enoent(ENOENT, QSystemError::StandardLibraryError);
700     auto errorFor = [](const QString &path) {
701         int fd = QT_OPEN(QFile::encodeName(path), QT_OPEN_RDWR | QT_OPEN_CREAT);
702         if (fd != -1) {
703             qWarning("Whoa! I succeeded in creating file %s", qUtf8Printable(path));
704             QT_CLOSE(fd);
705             del(path);
706         }
707         return QSystemError::lastErrorFor(QSystemError::StandardLibraryError);
708     };
709 #endif
710 
711     QTest::newRow("nonexistent:u+r") << "nonexistent" << uint(QFile::ReadOwner) << enoent << false;
712 
713     if (!unreadablePath.isEmpty())
714         QTest::newRow("unreadable") << (unreadablePath + "file.txt") << uint(QFile::WriteGroup)
715                                     << errorFor(unreadablePath + "file.txt") << false;
716 
717     if (!unwritablePath.isEmpty())
718     if (access(QFileSystemEngine::rootPath().toLatin1(), W_OK) == -1)
719         QTest::newRow("unwritable") << unwritablePath << uint(QFile::WriteOther)
720                                     << errorFor(unwritablePath) << true;
721 
722 #ifdef Q_OS_WIN
723     // On Windows, we only have two accessible modes: user read and user write
724     // (execute permissions are implied for all directories)
725     QTest::newRow("file-readonly") << (m_tempDir + "dummy")
726                                    << uint(QFile::ReadOwner)
727                                    << QSystemError() << true;
728     QTest::newRow("dir-readonly") << (m_tempDir + "subdir")
729                                   << uint(QFile::ReadOwner | QFile::ExeOwner)
730                                   << QSystemError() << true;
731 #else
732     QTest::newRow("file-124") << (m_tempDir + "dummy")
733                               << uint(QFile::ExeOwner | QFile::WriteGroup | QFile::ReadGroup)
734                               << QSystemError() << true;
735     QTest::newRow("dir-457") << (m_tempDir + "subdir")
736                              << uint(QFile::ReadOwner | QFile::ReadGroup | QFile::ExeGroup |
737                                      QFile::ReadOther | QFile::WriteOther | QFile::ExeOther)
738                              << QSystemError() << true;
739 #endif
740 }
741 
742 void tst_QFileSystemEngine::setPermissions()
743 {
744     QFETCH(QString, name);
745     QFETCH(uint, perms);
746     QFETCH(QSystemError, expectedError);
747 
748     QFileSystemEntry entry(name);
749     QFileSystemMetaData data;
750     QFile::Permissions permissions(perms);
751     QSystemResult<> r = QFileSystemEngine::setPermissions(entry, permissions, &data);
752 
753     QSystemError actualError;
754     if (r.isError())
755         actualError = r.error();
756     QCOMPARE(actualError, expectedError);
757 
758     QT_STATBUF statBuffer = {};
759 
760     if (!r.isError()) {
761         QVERIFY(data.hasFlags(QFileSystemMetaData::UserPermissions | QFileSystemMetaData::GroupPermissions
762                               | QFileSystemMetaData::OtherPermissions));
763         QCOMPARE(data.permissions(), permissions);
764 
765         // confirm it worked
766         QVERIFY2(QT_STAT(QFile::encodeName(name), &statBuffer) == 0, QSystemError::stdString().toUtf8());
767 #ifdef Q_OS_UNIX
768         QCOMPARE(bool(statBuffer.st_mode & 0001), bool(perms & QFile::ExeOther));
769         QCOMPARE(bool(statBuffer.st_mode & 0002), bool(perms & QFile::WriteOther));
770         QCOMPARE(bool(statBuffer.st_mode & 0004), bool(perms & QFile::ReadOther));
771         QCOMPARE(bool(statBuffer.st_mode & 0010), bool(perms & QFile::ExeGroup));
772         QCOMPARE(bool(statBuffer.st_mode & 0020), bool(perms & QFile::WriteGroup));
773         QCOMPARE(bool(statBuffer.st_mode & 0040), bool(perms & QFile::ReadGroup));
774 #endif
775         QCOMPARE(bool(statBuffer.st_mode & 0100), bool(perms & QFile::ExeOwner));
776         QCOMPARE(bool(statBuffer.st_mode & 0200), bool(perms & QFile::WriteOwner));
777         QCOMPARE(bool(statBuffer.st_mode & 0400), bool(perms & QFile::ReadOwner));
778 
779         // reset the permissions (ignore errors)
780         chmod(QFile::encodeName(name), 0600 | (statBuffer.st_mode & QT_STAT_DIR ? 0100 : 0));
781     }
782 
783 #ifdef Q_OS_UNIX
784     // Windows has no concept of fchmod(2)
785     QFETCH(bool, tryFchmod);
786     if (!tryFchmod)
787         return;
788 
789     // now try with a handle
790     int openflags = QT_OPEN_RDONLY;
791 #ifdef O_DIRECTORY
792     if (statBuffer.st_mode & QT_STAT_DIR)
793         openflags |= O_DIRECTORY;
794 #else
795     if (statBuffer.st_mode & QT_STAT_DIR) {
796         // don't try to open a directory without O_DIRECTORY
797         return;
798     }
799 #endif
800 
801     int fd = QT_OPEN(QFile::encodeName(name), openflags);
802     QVERIFY2(fd != -1, QSystemError::stdString().toUtf8());
803 
804     // automatically close the file for is
805     FileDescriptorCloser closeFd = { fd };
806 
807     r = QFileSystemEngine::setPermissions(fd, permissions, &data);
808     if (r.isError())
809         actualError = r.error();
810     else
811         actualError = QSystemError();
812     QCOMPARE(actualError, expectedError);
813 
814     if (!r.isError()) {
815         QVERIFY(data.hasFlags(QFileSystemMetaData::UserPermissions | QFileSystemMetaData::GroupPermissions
816                               | QFileSystemMetaData::OtherPermissions));
817         QCOMPARE(data.permissions(), permissions);
818 
819         // confirm it worked
820         QVERIFY2(QT_STAT(QFile::encodeName(name), &statBuffer) == 0, QSystemError::stdString().toUtf8());
821         QCOMPARE(bool(statBuffer.st_mode & 0001), bool(perms & QFile::ExeOther));
822         QCOMPARE(bool(statBuffer.st_mode & 0002), bool(perms & QFile::WriteOther));
823         QCOMPARE(bool(statBuffer.st_mode & 0004), bool(perms & QFile::ReadOther));
824         QCOMPARE(bool(statBuffer.st_mode & 0010), bool(perms & QFile::ExeGroup));
825         QCOMPARE(bool(statBuffer.st_mode & 0020), bool(perms & QFile::WriteGroup));
826         QCOMPARE(bool(statBuffer.st_mode & 0040), bool(perms & QFile::ReadGroup));
827         QCOMPARE(bool(statBuffer.st_mode & 0100), bool(perms & QFile::ExeOwner));
828         QCOMPARE(bool(statBuffer.st_mode & 0200), bool(perms & QFile::WriteOwner));
829         QCOMPARE(bool(statBuffer.st_mode & 0400), bool(perms & QFile::ReadOwner));
830 
831         // reset the permissions (ignore errors)
832         fchmod(fd, 0600 | (S_ISDIR(statBuffer.st_mode) ? 0100 : 0));
833     }
834 #endif // Q_OS_UNIX
835 }
836 
837 void tst_QFileSystemEngine::setFileTime_data()
838 {
839     QTest::addColumn<int>("what");
840     QTest::addColumn<QDateTime>("newDate");
841 
842     // Both Unix and Windows can do atime and mtime; Windows can also change
843     // birth time. On FAT filesytems, btime is a multiple of 10 ms, mtime must
844     // be a multiple of 2 and atime is rounded to the day, so ensure we use
845     // that.
846 
847     int perturbation = QRandomGenerator::global()->bounded(32);
848 
849     QTest::newRow("atime-past")
850             << int(QAbstractFileEngine::AccessTime)
851             << QDateTime(QDate(1970, 1, 2), QTime(0,0,0)).addDays(perturbation);
852     QTest::newRow("atime-today")
853             << int(QAbstractFileEngine::AccessTime)
854             << QDateTime(QDate::currentDate(), QTime(0,0,0));
855     QTest::newRow("atime-futre")
856             << int(QAbstractFileEngine::AccessTime)
857             << QDateTime(QDate::currentDate().addYears(1 + perturbation), QTime(0,0,0));
858 
859     QTest::newRow("mtime-past")
860             << int(QAbstractFileEngine::ModificationTime)
861             << QDateTime::fromSecsSinceEpoch(1 + perturbation * 2);
862     QTest::newRow("mtime-now")
863             << int(QAbstractFileEngine::ModificationTime)
864             << QDateTime::fromSecsSinceEpoch(QDateTime::currentSecsSinceEpoch() * 2 / 2);
865     QTest::newRow("mtime-future")
866             << int(QAbstractFileEngine::ModificationTime)
867             << QDateTime::fromSecsSinceEpoch((QDateTime::currentSecsSinceEpoch() + 7200 + perturbation) * 2 / 2);
868 
869 #ifdef Q_OS_WIN
870     QTest::newRow("btime-past")
871             << int(QAbstractFileEngine::BirthTime)
872             << QDateTime::fromMSecsSinceEpoch(1 + perturbation * 20);
873     QTest::newRow("btime-now")
874             << int(QAbstractFileEngine::BirthTime)
875             << QDateTime::fromMSecsSinceEpoch(QDateTime::currentMSecsSinceEpoch() * 10 / 10);
876     QTest::newRow("btime-future")
877             << int(QAbstractFileEngine::BirthTime)
878             << QDateTime::fromSecsSinceEpoch(QDateTime::currentSecsSinceEpoch() + 7200 + perturbation);
879 #endif
880 }
881 
882 void tst_QFileSystemEngine::setFileTime()
883 {
884     QFETCH(int, what);
885     QFETCH(QDateTime, newDate);
886     auto whatTime = QAbstractFileEngine::FileTime(what);
887 
888     int fd = QT_OPEN(QFile::encodeName(m_tempDir + "dummy"), QT_OPEN_RDWR);
889     QVERIFY2(fd != -1, QSystemError::stdString().toUtf8());
890 
891     // automatically close the file for is
892     FileDescriptorCloser closeFd = { fd };
893 
894 #ifdef Q_OS_WIN
895     HANDLE h = HANDLE(_get_osfhandle(fd));
896     QVERIFY2(h != INVALID_HANDLE_VALUE, QSystemError::stdString().toUtf8());
897 #else
898     int h = fd;
899 #endif
900 
901     QSystemError actualError;
902     QSystemResult<> r = QFileSystemEngine::setFileTime(h, newDate, whatTime);
903     if (r.isError())
904         actualError = r.error();
905     QCOMPARE(actualError, QSystemError());
906 
907     // get the time to compare
908     QFileSystemMetaData data;
909     r = QFileSystemEngine::fillMetaData(h, data);
910     actualError = QSystemError();
911     if (r.isError())
912         actualError = r.error();
913     QCOMPARE(actualError, QSystemError());
914 
915     QCOMPARE(data.fileTime(whatTime), newDate);
916 }
917 
918 QTEST_MAIN(tst_QFileSystemEngine)
919 #include <tst_qfilesystemengine.moc>
