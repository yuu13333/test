Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qjnienvironment.h"
41 #include "qjnihelpers_p.h"
42 #include "qjniobject.h"
43 
44 #include <QtCore/QReadWriteLock>
45 #include <QtCore/QHash>
46 
47 QT_BEGIN_NAMESPACE
48 
49 /*!
50     \class QJniObject
51     \inmodule QtCore
52     \brief Provides a convenient set of APIs to call Java code from C++ using the Java Native Interface (JNI).
53     \since 6.1
54 
55     \sa QJniEnvironment
56 
57     \section1 General Notes
58 
59     \list
60         \li Class names needs to contain the fully-qualified class name, for example: \b"java/lang/String".
61         \li Method signatures are written as \b"(Arguments)ReturnType"
62         \li All object types are returned as a QJniObject.
63     \endlist
64 
65     \note This API has been tested mainly for Android.
66 
67     \section1 Method Signatures
68 
69     For functions that take no arguments, QJniObject provides convenience functions that will use
70     the correct signature based on the provided template type. For example:
71 
72     \code
73     jint x = QJniObject::callMethod<jint>("getSize");
74     QJniObject::callMethod<void>("touch");
75     \endcode
76 
77     In other cases you will need to supply the signature yourself, and it is important that the
78     signature matches the function you want to call. The signature structure is \b \(A\)R, where \b A
79     is the type of the argument\(s\) and \b R is the return type. Array types in the signature must
80     have the \b\[ suffix and the fully-qualified type names must have the \b L prefix and \b ; suffix.
81 
82     The example below demonstrates how to call two different static functions.
83     \code
84     // Java class
85     package org.qtproject.qt;
86     class TestClass
87     {
88        static String fromNumber(int x) { ... }
89        static String[] stringArray(String s1, String s2) { ... }
90     }
91     \endcode
92 
93     The signature for the first function is \b"\(I\)Ljava/lang/String;"
94 
95     \code
96     // C++ code
97     QJniObject stringNumber = QJniObject::callStaticObjectMethod("org/qtproject/qt/TestClass",
98                                                                                "fromNumber"
99                                                                                "(I)Ljava/lang/String;",
100                                                                                10);
101     \endcode
102 
103     and the signature for the second function is \b"\(Ljava/lang/String;Ljava/lang/String;\)\[Ljava/lang/String;"
104 
105     \code
106     // C++ code
107     QJniObject string1 = QJniObject::fromString("String1");
108     QJniObject string2 = QJniObject::fromString("String2");
109     QJniObject stringArray = QJniObject::callStaticObjectMethod("org/qtproject/qt/TestClass",
110                                                                               "stringArray"
111                                                                               "(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;"
112                                                                                string1.object<jstring>(),
113                                                                                string2.object<jstring>());
114     \endcode
115 
116 
117     \section1 Handling Java Exception
118 
119     When calling Java functions that might throw an exception, it is important that you check, handle
120     and clear out the exception before continuing.
121 
122     \note It is unsafe to make a JNI call when there are exceptions pending.
123 
124     \snippet jni/src_qjJniobject.cpp Check for exceptions
125 
126     \section1 Java Native Methods
127 
128     Java native methods makes it possible to call native code from Java, this is done by creating a
129     function declaration in Java and prefixing it with the \b native keyword.
130     Before a native function can be called from Java, you need to map the Java native function to a
131     native function in your code. Mapping functions can be done by calling the RegisterNatives() function
132     through the \l{QJniEnvironment}{JNI environment pointer}.
133 
134     The example below demonstrates how this could be done.
135 
136     Java implementation:
137     \snippet jni/src_qjniobject.cpp Java native methods
138 
139     C++ Implementation:
140     \snippet jni/src_qjniobject.cpp Registering native methods
141 
142     \section1 The Lifetime of a Java Object
143 
144     Most \l{Object types}{objects} received from Java will be local references and will only stay valid
145     in the scope you received them. After that, the object becomes eligible for garbage collection. If you
146     want to keep a Java object alive you need to either create a new global reference to the object and
147     release it when you are done, or construct a new QJniObject and let it manage the lifetime of the Java object.
148     \sa object()
149 
150     \note The QJniObject does only manage its own references, if you construct a QJniObject from a
151           global or local reference that reference will not be released by the QJniObject.
152 
153     \section1 JNI Types
154 
155     \section2 Object Types
156     \table
157     \header
158         \li Type
159         \li Signature
160     \row
161         \li jobject
162         \li Ljava/lang/Object;
163     \row
164         \li jclass
165         \li Ljava/lang/Class;
166     \row
167         \li jstring
168         \li Ljava/lang/String;
169     \row
170         \li jthrowable
171         \li Ljava/lang/Throwable;
172     \row
173         \li jobjectArray
174         \li [Ljava/lang/Object;
175     \row
176         \li jarray
177         \li [\e<type>
178     \row
179         \li jbooleanArray
180         \li [Z
181     \row
182         \li jbyteArray
183         \li [B
184     \row
185         \li jcharArray
186         \li [C
187     \row
188         \li jshortArray
189         \li [S
190     \row
191         \li jintArray
192         \li [I
193     \row
194         \li jlongArray
195         \li [J
196     \row
197         \li jfloatArray
198         \li [F
199     \row
200         \li jdoubleArray
201         \li [D
202     \endtable
203 
204     \section2 Primitive Types
205     \table
206     \header
207         \li Type
208         \li Signature
209     \row
210         \li jboolean
211         \li Z
212     \row
213         \li jbyte
214         \li B
215     \row
216         \li jchar
217         \li C
218     \row
219        \li jshort
220        \li S
221     \row
222         \li jint
223         \li I
224     \row
225         \li jlong
226         \li J
227     \row
228         \li jfloat
229         \li F
230     \row
231         \li jdouble
232         \li D
233     \endtable
234 
235     \section3 Other
236     \table
237     \header
238         \li Type
239         \li Signature
240     \row
241         \li void
242         \li V
243     \row
244         \li \e{Custom type}
245         \li L\e<fully-qualified-name>;
246     \endtable
247 
248     For more information about JNI see: \l http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html
249 */
250 
251 /*!
252     \fn bool operator==(const QJniObject &o1, const QJniObject &o2)
253 
254     \relates QJniObject
255 
256     Returns true if both objects, \a o1 and \a o2, are referencing the same Java object, or if both
257     are NULL. In any other cases false will be returned.
258 */
259 
260 /*!
261     \fn bool operator!=(const QJniObject &o1, const QJniObject &o2)
262     \relates QJniObject
263 
264     Returns true if \a o1 holds a reference to a different object than \a o2.
265 */
266 
267 static inline QLatin1String keyBase()
268 {
269     return QLatin1String("%1%2:%3");
270 }
271 
272 static QString qt_convertJString(jstring string)
273 {
274     QJniEnvironment env;
275     int strLength = env->GetStringLength(string);
276     QString res(strLength, Qt::Uninitialized);
277     env->GetStringRegion(string, 0, strLength, reinterpret_cast<jchar *>(res.data()));
278     return res;
279 }
280 
281 typedef QHash<QString, jclass> JClassHash;
282 Q_GLOBAL_STATIC(JClassHash, cachedClasses)
283 Q_GLOBAL_STATIC(QReadWriteLock, cachedClassesLock)
284 
285 static QByteArray toBinaryEncClassName(const QByteArray &className)
286 {
287     return QByteArray(className).replace('/', '.');
288 }
289 
290 static jclass getCachedClass(const QByteArray &classBinEnc, bool *isCached = nullptr)
291 {
292     QReadLocker locker(cachedClassesLock);
293     const QHash<QString, jclass>::const_iterator &it = cachedClasses->constFind(QString::fromLatin1(classBinEnc));
294     const bool found = (it != cachedClasses->constEnd());
295 
296     if (isCached)
297         *isCached = found;
298 
299     return found ? it.value() : 0;
300 }
301 
302 inline static jclass loadClass(const QByteArray &className, JNIEnv *env, bool binEncoded = false)
303 {
304     const QByteArray &binEncClassName = binEncoded ? className : toBinaryEncClassName(className);
305 
306     bool isCached = false;
307     jclass clazz = getCachedClass(binEncClassName, &isCached);
308     if (clazz || isCached)
309         return clazz;
310 
311     QJniObject classLoader(QtAndroidPrivate::classLoader());
312     if (!classLoader.isValid())
313         return nullptr;
314 
315     QWriteLocker locker(cachedClassesLock);
316     // did we lose the race?
317     const QLatin1String key(binEncClassName);
318     const QHash<QString, jclass>::const_iterator &it = cachedClasses->constFind(key);
319     if (it != cachedClasses->constEnd())
320         return it.value();
321 
322     QJniObject stringName = QJniObject::fromString(key);
323     QJniObject classObject = classLoader.callObjectMethod("loadClass",
324                                                           "(Ljava/lang/String;)Ljava/lang/Class;",
325                                                           stringName.object());
326 
327     if (!QJniEnvironment::exceptionCheckAndClear(env) && classObject.isValid())
328         clazz = static_cast<jclass>(env->NewGlobalRef(classObject.object()));
329 
330     cachedClasses->insert(key, clazz);
331     return clazz;
332 }
333 
334 typedef QHash<QString, jmethodID> JMethodIDHash;
335 Q_GLOBAL_STATIC(JMethodIDHash, cachedMethodID)
336 Q_GLOBAL_STATIC(QReadWriteLock, cachedMethodIDLock)
337 
338 static inline jmethodID getMethodID(JNIEnv *env,
339                                     jclass clazz,
340                                     const char *name,
341                                     const char *sig,
342                                     bool isStatic = false)
343 {
344     jmethodID id = isStatic ? env->GetStaticMethodID(clazz, name, sig)
345                             : env->GetMethodID(clazz, name, sig);
346 
347     if (QJniEnvironment::exceptionCheckAndClear(env))
348         return nullptr;
349 
350     return id;
351 }
352 
353 static jmethodID getCachedMethodID(JNIEnv *env,
354                                    jclass clazz,
355                                    const QByteArray &className,
356                                    const char *name,
357                                    const char *sig,
358                                    bool isStatic = false)
359 {
360     if (className.isEmpty())
361         return getMethodID(env, clazz, name, sig, isStatic);
362 
363     const QString key = keyBase().arg(QLatin1String(className), QLatin1String(name), QLatin1String(sig));
364     QHash<QString, jmethodID>::const_iterator it;
365 
366     {
367         QReadLocker locker(cachedMethodIDLock);
368         it = cachedMethodID->constFind(key);
369         if (it != cachedMethodID->constEnd())
370             return it.value();
371     }
372 
373     {
374         QWriteLocker locker(cachedMethodIDLock);
375         it = cachedMethodID->constFind(key);
376         if (it != cachedMethodID->constEnd())
377             return it.value();
378 
379         jmethodID id = getMethodID(env, clazz, name, sig, isStatic);
380 
381         cachedMethodID->insert(key, id);
382         return id;
383     }
384 }
385 
386 typedef QHash<QString, jfieldID> JFieldIDHash;
387 Q_GLOBAL_STATIC(JFieldIDHash, cachedFieldID)
388 Q_GLOBAL_STATIC(QReadWriteLock, cachedFieldIDLock)
389 
390 static inline jfieldID getFieldID(JNIEnv *env,
391                                   jclass clazz,
392                                   const char *name,
393                                   const char *sig,
394                                   bool isStatic = false)
395 {
396     jfieldID id = isStatic ? env->GetStaticFieldID(clazz, name, sig)
397                            : env->GetFieldID(clazz, name, sig);
398 
399     if (QJniEnvironment::exceptionCheckAndClear(env))
400         return nullptr;
401 
402     return id;
403 }
404 
405 static jfieldID getCachedFieldID(JNIEnv *env,
406                                  jclass clazz,
407                                  const QByteArray &className,
408                                  const char *name,
409                                  const char *sig,
410                                  bool isStatic = false)
411 {
412     if (className.isNull())
413         return getFieldID(env, clazz, name, sig, isStatic);
414 
415     const QString key = keyBase().arg(QLatin1String(className), QLatin1String(name), QLatin1String(sig));
416     QHash<QString, jfieldID>::const_iterator it;
417 
418     {
419         QReadLocker locker(cachedFieldIDLock);
420         it = cachedFieldID->constFind(key);
421         if (it != cachedFieldID->constEnd())
422             return it.value();
423     }
424 
425     {
426         QWriteLocker locker(cachedFieldIDLock);
427         it = cachedFieldID->constFind(key);
428         if (it != cachedFieldID->constEnd())
429             return it.value();
430 
431         jfieldID id = getFieldID(env, clazz, name, sig, isStatic);
432 
433         cachedFieldID->insert(key, id);
434         return id;
435     }
436 }
437 
438 jclass QtAndroidPrivate::findClass(const char *className, JNIEnv *env)
439 {
440     const QByteArray &classDotEnc = toBinaryEncClassName(className);
441     bool isCached = false;
442     jclass clazz = getCachedClass(classDotEnc, &isCached);
443 
444     const bool found = clazz || (clazz == 0 && isCached);
445 
446     if (found)
447         return clazz;
448 
449     const QLatin1String key(classDotEnc);
450     if (env) { // We got an env. pointer (We expect this to be the right env. and call FindClass())
451         QWriteLocker locker(cachedClassesLock);
452         const QHash<QString, jclass>::const_iterator &it = cachedClasses->constFind(key);
453         // Did we lose the race?
454         if (it != cachedClasses->constEnd())
455             return it.value();
456 
457         jclass fclazz = env->FindClass(className);
458         if (!QJniEnvironment::exceptionCheckAndClear(env)) {
459             clazz = static_cast<jclass>(env->NewGlobalRef(fclazz));
460             env->DeleteLocalRef(fclazz);
461         }
462 
463         if (clazz)
464             cachedClasses->insert(key, clazz);
465     }
466 
467     if (clazz == 0) // We didn't get an env. pointer or we got one with the WRONG class loader...
468         clazz = loadClass(classDotEnc, QJniEnvironment(), true);
469 
470     return clazz;
471 }
472 
473 class QJniObjectPrivate
474 {
475 public:
476     QJniObjectPrivate() = default;
477     ~QJniObjectPrivate() {
478         QJniEnvironment env;
479         if (m_jobject)
480             env->DeleteGlobalRef(m_jobject);
481         if (m_jclass && m_own_jclass)
482             env->DeleteGlobalRef(m_jclass);
483     }
484 
485     jobject m_jobject = nullptr;
486     jclass m_jclass = nullptr;
487     bool m_own_jclass = true;
488     QByteArray m_className;
489 };
490 
491 /*!
492     \fn QJniObject::QJniObject()
493 
494     Constructs an invalid QJniObject.
495 
496     \sa isValid()
497 */
498 QJniObject::QJniObject()
499     : d(new QJniObjectPrivate())
500 {
501 }
502 
503 /*!
504     \fn QJniObject::QJniObject(const char *className)
505 
506     Constructs a new QJniObject by calling the default constructor of \a className.
507 
508     \code
509     QJniObject myJavaString("java/lang/String");
510     \endcode
511 */
512 QJniObject::QJniObject(const char *className)
513     : d(new QJniObjectPrivate())
514 {
515     QJniEnvironment env;
516     d->m_className = toBinaryEncClassName(className);
517     d->m_jclass = loadClass(d->m_className, env, true);
518     d->m_own_jclass = false;
519     if (d->m_jclass) {
520         // get default constructor
521         jmethodID constructorId = getCachedMethodID(env, d->m_jclass, d->m_className, "<init>", "()V");
522         if (constructorId) {
523             jobject obj = env->NewObject(d->m_jclass, constructorId);
524             if (obj) {
525                 d->m_jobject = env->NewGlobalRef(obj);
526                 env->DeleteLocalRef(obj);
527             }
528         }
529     }
530 }
531 
532 /*!
533     \fn QJniObject::QJniObject(const char *className, const char *signature, ...)
534 
535     Constructs a new QJniObject by calling the constructor of \a className with \a signature
536     and arguments.
537 
538     \code
539     QJniEnvironment env;
540     char* str = "Hello";
541     jstring myJStringArg = env->NewStringUTF(str);
542     QJniObject myNewJavaString("java/lang/String", "(Ljava/lang/String;)V", myJStringArg);
543     \endcode
544 */
545 QJniObject::QJniObject(const char *className, const char *sig, ...)
546     : d(new QJniObjectPrivate())
547 {
548     QJniEnvironment env;
549     d->m_className = toBinaryEncClassName(className);
550     d->m_jclass = loadClass(d->m_className, env, true);
551     d->m_own_jclass = false;
552     if (d->m_jclass) {
553         jmethodID constructorId = getCachedMethodID(env, d->m_jclass, d->m_className, "<init>", sig);
554         if (constructorId) {
555             va_list args;
556             va_start(args, sig);
557             jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
558             va_end(args);
559             if (obj) {
560                 d->m_jobject = env->NewGlobalRef(obj);
561                 env->DeleteLocalRef(obj);
562             }
563         }
564     }
565 }
566 
567 QJniObject::QJniObject(const char *className, const char *sig, const QVaListPrivate &args)
568     : d(new QJniObjectPrivate())
569 {
570     QJniEnvironment env;
571     d->m_className = toBinaryEncClassName(className);
572     d->m_jclass = loadClass(d->m_className, env, true);
573     d->m_own_jclass = false;
574     if (d->m_jclass) {
575         jmethodID constructorId = getCachedMethodID(env, d->m_jclass, d->m_className, "<init>", sig);
576         if (constructorId) {
577             jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
578             if (obj) {
579                 d->m_jobject = env->NewGlobalRef(obj);
580                 env->DeleteLocalRef(obj);
581             }
582         }
583     }
584 }
585 
586 /*!
587     \fn QJniObject::QJniObject(jclass clazz, const char *signature, ...)
588 
589     Constructs a new QJniObject from \a clazz by calling the constructor with \a signature
590     and arguments.
591 
592     \code
593     QJniEnvironment env;
594     jclass myClazz = env.findClass("org/qtproject/qt/TestClass");
595     QJniObject(myClazz, "(I)V", 3);
596     \endcode
597 */
598 QJniObject::QJniObject(jclass clazz, const char *sig, ...)
599     : d(new QJniObjectPrivate())
600 {
601     QJniEnvironment env;
602     if (clazz) {
603         d->m_jclass = static_cast<jclass>(env->NewGlobalRef(clazz));
604         if (d->m_jclass) {
605             jmethodID constructorId = getMethodID(env, d->m_jclass, "<init>", sig);
606             if (constructorId) {
607                 va_list args;
608                 va_start(args, sig);
609                 jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
610                 va_end(args);
611                 if (obj) {
612                     d->m_jobject = env->NewGlobalRef(obj);
613                     env->DeleteLocalRef(obj);
614                 }
615             }
616         }
617     }
618 }
619 
620 /*!
621     \fn QJniObject::QJniObject(jclass clazz)
622 
623     Constructs a new QJniObject by calling the default constructor of \a clazz.
624 
625     Note: The QJniObject will create a new reference to the class \a clazz
626           and releases it again when it is destroyed. References to the class created
627           outside the QJniObject needs to be managed by the caller.
628 */
629 
630 QJniObject::QJniObject(jclass clazz)
631     : d(new QJniObjectPrivate())
632 {
633     QJniEnvironment env;
634     d->m_jclass = static_cast<jclass>(env->NewGlobalRef(clazz));
635     if (d->m_jclass) {
636         // get default constructor
637         jmethodID constructorId = getMethodID(env, d->m_jclass, "<init>", "()V");
638         if (constructorId) {
639             jobject obj = env->NewObject(d->m_jclass, constructorId);
640             if (obj) {
641                 d->m_jobject = env->NewGlobalRef(obj);
642                 env->DeleteLocalRef(obj);
643             }
644         }
645     }
646 }
647 
648 QJniObject::QJniObject(jclass clazz, const char *sig, const QVaListPrivate &args)
649     : d(new QJniObjectPrivate())
650 {
651     QJniEnvironment env;
652     if (clazz) {
653         d->m_jclass = static_cast<jclass>(env->NewGlobalRef(clazz));
654         if (d->m_jclass) {
655             jmethodID constructorId = getMethodID(env, d->m_jclass, "<init>", sig);
656             if (constructorId) {
657                 jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
658                 if (obj) {
659                     d->m_jobject = env->NewGlobalRef(obj);
660                     env->DeleteLocalRef(obj);
661                 }
662             }
663         }
664     }
665 }
666 
667 /*!
668     \fn QJniObject::QJniObject(jobject object)
669 
670     Constructs a new QJniObject around the Java object \a object.
671 
672     \note The QJniObject will hold a reference to the Java object \a object
673     and release it when destroyed. Any references to the Java object \a object
674     outside QJniObject needs to be managed by the caller. In most cases you
675     should never call this function with a local reference unless you intend
676     to manage the local reference yourself. See QJniObject::fromLocalRef()
677     for converting a local reference to a QJniObject.
678 
679     \sa fromLocalRef()
680 */
681 QJniObject::QJniObject(jobject obj)
682     : d(new QJniObjectPrivate())
683 {
684     if (!obj)
685         return;
686 
687     QJniEnvironment env;
688     d->m_jobject = env->NewGlobalRef(obj);
689     jclass cls = env->GetObjectClass(obj);
690     d->m_jclass = static_cast<jclass>(env->NewGlobalRef(cls));
691     env->DeleteLocalRef(cls);
692 }
693 
694 /*!
695     \fn QJniObject::~QJniObject()
696 
697     Destroys the QJniObject and releases any references held by the QJniObject.
698 */
699 QJniObject::~QJniObject()
700 {}
701 
702 /*!
703     \fn template <typename T> T QJniObject::object() const
704 
705     Returns the object held by the QJniObject as type T.
706 
707     \code
708     QJniObject string = QJniObject::fromString("Hello, JNI");
709     jstring jstring = string.object<jstring>();
710     \endcode
711 
712     \note The returned object is still owned by the QJniObject. If you want to keep the object valid
713     you should create a new QJniObject or make a new global reference to the object and
714     free it yourself.
715 
716     \snippet jni/src_qjniobject.cpp QJniObject scope
717 
718     \code
719     jobject object = jniObject.object();
720     \endcode
721 */
722 Q_CORE_EXPORT jobject QJniObject::object() const
723 {
724     return javaObject();
725 }
726 
727 QJniObject QJniObject::callObjectMethodV(const char *methodName,
728                                          const char *sig,
729                                          va_list args) const
730 {
731     QJniEnvironment env;
732     jobject res = nullptr;
733     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
734     if (id) {
735         res = env->CallObjectMethodV(d->m_jobject, id, args);
736         if (res && env.exceptionCheckAndClear())
737             res = nullptr;
738     }
739 
740     QJniObject obj(res);
741     env->DeleteLocalRef(res);
742     return obj;
743 }
744 
745 QJniObject QJniObject::callStaticObjectMethodV(const char *className,
746                                                const char *methodName,
747                                                const char *sig,
748                                                va_list args)
749 {
750     QJniEnvironment env;
751     jobject res = nullptr;
752     jclass clazz = loadClass(className, env);
753     if (clazz) {
754         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName, sig, true);
755         if (id) {
756             res = env->CallStaticObjectMethodV(clazz, id, args);
757             if (res && env.exceptionCheckAndClear())
758                 res = nullptr;
759         }
760     }
761 
762     QJniObject obj(res);
763     env->DeleteLocalRef(res);
764     return obj;
765 }
766 
767 QJniObject QJniObject::callStaticObjectMethodV(jclass clazz,
768                                                const char *methodName,
769                                                const char *sig,
770                                                va_list args)
771 {
772     QJniEnvironment env;
773     jobject res = nullptr;
774     jmethodID id = getMethodID(env, clazz, methodName, sig, true);
775     if (id) {
776         res = env->CallStaticObjectMethodV(clazz, id, args);
777         if (res && env.exceptionCheckAndClear())
778             res = nullptr;
779     }
780 
781     QJniObject obj(res);
782     env->DeleteLocalRef(res);
783     return obj;
784 }
785 
786 /*!
787     \fn template <typename T> T QJniObject::callMethod(const char *methodName, const char *sig, ...) const
788 
789     Calls the method \a  methodName with a signature \a sig and returns the value.
790 
791     \code
792     QJniObject myJavaString = ...;
793     jint index = myJavaString.callMethod<jint>("indexOf", "(I)I", 0x0051);
794     \endcode
795 
796 */
797 template <>
798 Q_CORE_EXPORT void QJniObject::callMethod<void>(const char *methodName, const char *sig, ...) const
799 {
800     QJniEnvironment env;
801     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
802     if (id) {
803         va_list args;
804         va_start(args, sig);
805         env->CallVoidMethodV(d->m_jobject, id, args);
806         va_end(args);
807         env.exceptionCheckAndClear();
808     }
809 }
810 
811 /*!
812     \fn template <typename T> T QJniObject::callMethod(const char *methodName) const
813 
814     Calls the method \a methodName and returns the value.
815 
816     \code
817     QJniObject myJavaString = ...;
818     jint size = myJavaString.callMethod<jint>("length");
819     \endcode
820 */
821 template <>
822 Q_CORE_EXPORT void QJniObject::callMethod<void>(const char *methodName) const
823 {
824     callMethod<void>(methodName, "()V");
825 }
826 
827 /*!
828     \fn template <typename T> T QJniObject::callStaticMethod(const char *className, const char *methodName, const char *signature, ...)
829 
830     Calls the static method with \a methodName with \a signature on class \a className with optional arguments.
831 
832     \code
833     ...
834     jint a = 2;
835     jint b = 4;
836     jint max = QJniObject::callStaticMethod<jint>("java/lang/Math", "max", "(II)I", a, b);
837     ...
838     \endcode
839 */
840 template <>
841 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(const char *className,
842                                                       const char *methodName,
843                                                       const char *sig,
844                                                       ...)
845 {
846     QJniEnvironment env;
847     jclass clazz = loadClass(className, env);
848     if (clazz) {
849         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className),
850                                          methodName, sig, true);
851         if (id) {
852             va_list args;
853             va_start(args, sig);
854             env->CallStaticVoidMethodV(clazz, id, args);
855             va_end(args);
856             env.exceptionCheckAndClear();
857         }
858     }
859 }
860 
861 /*!
862     \fn template <typename T> T QJniObject::callStaticMethod(const char *className, const char *methodName)
863 
864     Calls the static method \a methodName on class \a className and returns the value.
865 
866     \code
867     jint value = QJniObject::callStaticMethod<jint>("MyClass", "staticMethod");
868     \endcode
869 */
870 template <>
871 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(const char *className, const char *methodName)
872 {
873     callStaticMethod<void>(className, methodName, "()V");
874 }
875 
876 /*!
877     \fn template <typename T> T QJniObject::callStaticMethod(jclass clazz, const char *methodName, const char *signature, ...)
878 
879     Calls the static method \a methodName with \a signature on \a clazz and returns the value.
880 
881     \code
882     ...
883     jclass javaMathClass = ...; // ("java/lang/Math")
884     jint a = 2;
885     jint b = 4;
886     jint max = QJniObject::callStaticMethod<jint>(javaMathClass, "max", "(II)I", a, b);
887     ...
888     \endcode
889 */
890 template <>
891 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(jclass clazz,
892                                                       const char *methodName,
893                                                       const char *sig,
894                                                       ...)
895 {
896     QJniEnvironment env;
897     if (clazz) {
898         jmethodID id = getMethodID(env, clazz, methodName, sig, true);
899         if (id) {
900             va_list args;
901             va_start(args, sig);
902             env->CallStaticVoidMethodV(clazz, id, args);
903             va_end(args);
904             env.exceptionCheckAndClear();
905         }
906     }
907 }
908 
909 template <>
910 Q_CORE_EXPORT void QJniObject::callStaticMethodV<void>(const char *className,
911                                                        const char *methodName,
912                                                        const char *sig,
913                                                        va_list args)
914 {
915     QJniEnvironment env;
916     jclass clazz = loadClass(className, env);
917     if (clazz) {
918         jmethodID id = getCachedMethodID(env, clazz,
919                                          toBinaryEncClassName(className), methodName,
920                                          sig, true);
921         if (id) {
922             env->CallStaticVoidMethodV(clazz, id, args);
923             env.exceptionCheckAndClear();
924         }
925     }
926 }
927 
928 template <>
929 Q_CORE_EXPORT void QJniObject::callStaticMethodV<void>(jclass clazz,
930                                                        const char *methodName,
931                                                        const char *sig,
932                                                        va_list args)
933 {
934     QJniEnvironment env;
935     jmethodID id = getMethodID(env, clazz, methodName, sig, true);
936     if (id) {
937         env->CallStaticVoidMethodV(clazz, id, args);
938         env.exceptionCheckAndClear();
939     }
940 }
941 
942 /*!
943     \fn template <typename T> T QJniObject::callStaticMethod(jclass clazz, const char *methodName)
944 
945     Calls the static method \a methodName on \a clazz and returns the value.
946 
947     \code
948     ...
949     jclass javaMathClass = ...; // ("java/lang/Math")
950     jdouble randNr = QJniObject::callStaticMethod<jdouble>(javaMathClass, "random");
951     ...
952     \endcode
953 */
954 template <>
955 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(jclass clazz, const char *methodName)
956 {
957     callStaticMethod<void>(clazz, methodName, "()V");
958 }
959 
960 template <>
961 Q_CORE_EXPORT void QJniObject::callMethodV<void>(const char *methodName, const char *sig,
962                                                  va_list args) const
963 {
964     QJniEnvironment env;
965     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
966     if (id) {
967         env->CallVoidMethodV(d->m_jobject, id, args);
968         env.exceptionCheckAndClear();
969     }
970 }
971 
972 #define MAKE_JNI_METHODS(MethodName, Type, Signature) \
973 template <> Q_CORE_EXPORT Type QJniObject::callMethod<Type>(const char *methodName, \
974                                                                    const char *sig, ...) const \
975 { \
976     QJniEnvironment env; \
977     Type res = 0; \
978     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig); \
979     if (id) { \
980         va_list args; \
981         va_start(args, sig); \
982         res = env->Call##MethodName##MethodV(d->m_jobject, id, args); \
983         va_end(args); \
984         if (env.exceptionCheckAndClear()) \
985             res = 0; \
986     } \
987     return res; \
988 }\
989 template <> Q_CORE_EXPORT Type QJniObject::callMethod<Type>(const char *methodName) const \
990 { \
991     return callMethod<Type>(methodName, Signature); \
992 } \
993 \
994 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(const char *className, \
995                                                                   const char *methodName, \
996                                                                   const char *sig, \
997                                                                   ...) \
998 { \
999     QJniEnvironment env; \
1000     Type res = 0; \
1001     jclass clazz = loadClass(className, env); \
1002     if (clazz) { \
1003         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName, \
1004                                          sig, true); \
1005         if (id) { \
1006             va_list args; \
1007             va_start(args, sig); \
1008             res = env->CallStatic##MethodName##MethodV(clazz, id, args); \
1009             va_end(args); \
1010             if (env.exceptionCheckAndClear())  \
1011                 res = 0; \
1012         } \
1013     } \
1014     return res; \
1015 } \
1016 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(const char *className, \
1017                                                                   const char *methodName) \
1018 { \
1019     return callStaticMethod<Type>(className, methodName, Signature); \
1020 }\
1021 \
1022 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(jclass clazz, \
1023                                                                   const char *methodName, \
1024                                                                   const char *sig, \
1025                                                                   ...) \
1026 { \
1027     QJniEnvironment env; \
1028     Type res = 0; \
1029     if (clazz) { \
1030         jmethodID id = getMethodID(env, clazz, methodName, sig, true); \
1031         if (id) { \
1032             va_list args; \
1033             va_start(args, sig); \
1034             res = env->CallStatic##MethodName##MethodV(clazz, id, args); \
1035             va_end(args); \
1036             if (env.exceptionCheckAndClear()) \
1037                 res = 0; \
1038         } \
1039     } \
1040     return res; \
1041 } \
1042 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(jclass clazz, \
1043                                                                   const char *methodName) \
1044 { \
1045     return callStaticMethod<Type>(clazz, methodName, Signature); \
1046 }\
1047 template <> \
1048 Q_CORE_EXPORT Type QJniObject::callMethodV<Type>(const char *methodName, const char *sig,\
1049                                                  va_list args) const\
1050 {\
1051     QJniEnvironment env;\
1052     Type res = 0;\
1053     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);\
1054     if (id) {\
1055         res = env->Call##MethodName##MethodV(d->m_jobject, id, args);\
1056         if (env.exceptionCheckAndClear())  \
1057             res = 0; \
1058     }\
1059     return res;\
1060 }\
1061 template <>\
1062 Q_CORE_EXPORT Type QJniObject::callStaticMethodV<Type>(const char *className,\
1063                                                      const char *methodName,\
1064                                                      const char *sig,\
1065                                                      va_list args)\
1066 {\
1067     QJniEnvironment env;\
1068     Type res = 0;\
1069     jclass clazz = loadClass(className, env);\
1070     if (clazz) {\
1071         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName,\
1072                                          sig, true);\
1073         if (id) {\
1074             res = env->CallStatic##MethodName##MethodV(clazz, id, args);\
1075             if (env.exceptionCheckAndClear())  \
1076                 res = 0; \
1077         }\
1078     }\
1079     return res;\
1080 }\
1081 template <>\
1082 Q_CORE_EXPORT Type QJniObject::callStaticMethodV<Type>(jclass clazz,\
1083                                                      const char *methodName,\
1084                                                      const char *sig,\
1085                                                      va_list args)\
1086 {\
1087     QJniEnvironment env;\
1088     Type res = 0;\
1089     jmethodID id = getMethodID(env, clazz, methodName, sig, true);\
1090     if (id) {\
1091         res = env->CallStatic##MethodName##MethodV(clazz, id, args);\
1092         if (env.exceptionCheckAndClear())  \
1093             res = 0; \
1094     }\
1095     return res;\
1096 }
1097 
1098 #define DECLARE_JNI_METHODS(MethodName, Type, Signature) MAKE_JNI_METHODS(MethodName, \
1099                                                                           Type, \
1100                                                                           Signature)
1101 DECLARE_JNI_METHODS(Boolean, jboolean, "()Z")
1102 DECLARE_JNI_METHODS(Byte, jbyte, "()B")
1103 DECLARE_JNI_METHODS(Char, jchar, "()C")
1104 DECLARE_JNI_METHODS(Short, jshort, "()S")
1105 DECLARE_JNI_METHODS(Int, jint, "()I")
1106 DECLARE_JNI_METHODS(Long, jlong, "()J")
1107 DECLARE_JNI_METHODS(Float, jfloat, "()F")
1108 DECLARE_JNI_METHODS(Double, jdouble, "()D")
1109 
1110 /*!
1111     \fn QJniObject QJniObject::callObjectMethod(const char *methodName, const char *signature, ...) const
1112 
1113     Calls the Java object's method \a methodName with the signature \a signature and arguments
1114 
1115     \code
1116     QJniObject myJavaString; ==> "Hello, Java"
1117     QJniObject mySubstring = myJavaString.callObjectMethod("substring", "(II)Ljava/lang/String;", 7, 10);
1118     \endcode
1119 */
1120 QJniObject QJniObject::callObjectMethod(const char *methodName, const char *sig, ...) const
1121 {
1122     QJniEnvironment env;
1123     jobject res = nullptr;
1124     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
1125     if (id) {
1126         va_list args;
1127         va_start(args, sig);
1128         res = env->CallObjectMethodV(d->m_jobject, id, args);
1129         va_end(args);
1130         if (res && env.exceptionCheckAndClear())
1131             res = nullptr;
1132     }
1133 
1134     QJniObject obj(res);
1135     env->DeleteLocalRef(res);
1136     return obj;
1137 }
1138 
1139 /*!
1140     \fn QJniObject QJniObject::callStaticObjectMethod(const char *className, const char *methodName, const char *signature, ...)
1141 
1142     Calls the static method with \a methodName and \a signature on the class \a className.
1143 
1144     \code
1145     QJniObject thread = QJniObject::callStaticObjectMethod("java/lang/Thread", "currentThread", "()Ljava/lang/Thread;");
1146     QJniObject string = QJniObject::callStaticObjectMethod("java/lang/String", "valueOf", "(I)Ljava/lang/String;", 10);
1147     \endcode
1148 */
1149 QJniObject QJniObject::callStaticObjectMethod(const char *className,
1150                                               const char *methodName,
1151                                               const char *sig,
1152                                               ...)
1153 {
1154     QJniEnvironment env;
1155     jobject res = nullptr;
1156     jclass clazz = loadClass(className, env);
1157     if (clazz) {
1158         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName,
1159                                          sig, true);
1160         if (id) {
1161             va_list args;
1162             va_start(args, sig);
1163             res = env->CallStaticObjectMethodV(clazz, id, args);
1164             va_end(args);
1165             if (res && env.exceptionCheckAndClear())
1166                 res = nullptr;
1167         }
1168     }
1169 
1170     QJniObject obj(res);
1171     env->DeleteLocalRef(res);
1172     return obj;
1173 }
1174 
1175 /*!
1176     \fn QJniObject QJniObject::callStaticObjectMethod(jclass clazz, const char *methodName, const char *signature, ...)
1177 
1178     Calls the static method with \a methodName and \a signature on class \a clazz.
1179 */
1180 QJniObject QJniObject::callStaticObjectMethod(jclass clazz,
1181                                               const char *methodName,
1182                                               const char *sig,
1183                                               ...)
1184 {
1185     QJniEnvironment env;
1186     jobject res = nullptr;
1187     if (clazz) {
1188         jmethodID id = getMethodID(env, clazz, methodName, sig, true);
1189         if (id) {
1190             va_list args;
1191             va_start(args, sig);
1192             res = env->CallStaticObjectMethodV(clazz, id, args);
1193             va_end(args);
1194             if (res && env.exceptionCheckAndClear())
1195                 res = nullptr;
1196         }
1197     }
1198     QJniObject obj(res);
1199     env->DeleteLocalRef(res);
1200     return obj;
1201 }
1202 
1203 /*!
1204     \fn QJniObject QJniObject::callObjectMethod(const char *methodName) const
1205 
1206     Calls the Java objects method \a methodName and returns a new QJniObject for
1207     the returned Java object.
1208 
1209     \code
1210     ...
1211     QJniObject myJavaString1 = ...;
1212     QJniObject myJavaString2 = myJavaString1.callObjectMethod<jstring>("toString");
1213     ...
1214     \endcode
1215 */
1216 
1217 /*!
1218     \fn QJniObject QJniObject::callStaticObjectMethod(const char *className, const char *methodName)
1219 
1220     Calls the static method with \a methodName on the class \a className.
1221 
1222     \code
1223     QJniObject string = QJniObject::callStaticObjectMethod<jstring>("CustomClass", "getClassName");
1224     \endcode
1225 */
1226 
1227 /*!
1228     \fn QJniObject QJniObject::callStaticObjectMethod(jclass clazz, const char *methodName)
1229 
1230     Calls the static method with \a methodName on \a clazz.
1231 
1232 */
1233 
1234 /*!
1235     \fn template <typename T> QJniObject &QJniObject::operator=(T object)
1236 
1237     Replace the current object with \a object. The old Java object will be released.
1238 */
1239 #define MAKE_JNI_OBJECT_METHODS(Type, Signature) \
1240 template <> \
1241 Q_CORE_EXPORT QJniObject QJniObject::callObjectMethod<Type>(const char *methodName) const \
1242 { \
1243     return callObjectMethod(methodName, Signature); \
1244 } \
1245 template <> \
1246 Q_CORE_EXPORT QJniObject QJniObject::callStaticObjectMethod<Type>(const char *className, \
1247                                                                   const char *methodName) \
1248 { \
1249     return callStaticObjectMethod(className, methodName, Signature); \
1250 } \
1251 template <> \
1252 Q_CORE_EXPORT QJniObject QJniObject::callStaticObjectMethod<Type>(jclass clazz, \
1253                                                                   const char *methodName) \
1254 { \
1255     return callStaticObjectMethod(clazz, methodName, Signature); \
1256 }\
1257 template <>\
1258 Q_CORE_EXPORT Type QJniObject::object<Type>() const\
1259 {\
1260     return static_cast<Type>(javaObject());\
1261 }\
1262 template <>\
1263 Q_CORE_EXPORT QJniObject &QJniObject::operator=(Type obj)\
1264 {\
1265     assign(static_cast<jobject>(obj));\
1266     return *this;\
1267 }
1268 
1269 #define DECLARE_JNI_OBJECT_METHODS(Type, Signature) MAKE_JNI_OBJECT_METHODS(Type, Signature)
1270 
1271 DECLARE_JNI_OBJECT_METHODS(jobject, "()Ljava/lang/Object;")
1272 DECLARE_JNI_OBJECT_METHODS(jclass, "()Ljava/lang/Class;")
1273 DECLARE_JNI_OBJECT_METHODS(jstring, "()Ljava/lang/String;")
1274 DECLARE_JNI_OBJECT_METHODS(jobjectArray, "()[Ljava/lang/Object;")
1275 DECLARE_JNI_OBJECT_METHODS(jbooleanArray, "()[Z")
1276 DECLARE_JNI_OBJECT_METHODS(jbyteArray, "()[B")
1277 DECLARE_JNI_OBJECT_METHODS(jshortArray, "()[S")
1278 DECLARE_JNI_OBJECT_METHODS(jintArray, "()[I")
1279 DECLARE_JNI_OBJECT_METHODS(jlongArray, "()[J")
1280 DECLARE_JNI_OBJECT_METHODS(jfloatArray, "()[F")
1281 DECLARE_JNI_OBJECT_METHODS(jdoubleArray, "()[D")
1282 DECLARE_JNI_OBJECT_METHODS(jcharArray, "()[C")
1283 DECLARE_JNI_OBJECT_METHODS(jthrowable, "()Ljava/lang/Throwable;")
1284 
1285 /*!
1286     \fn template <typename T> void QJniObject::setStaticField(const char *className, const char *fieldName, const char *signature, T value);
1287 
1288     Sets the static field with \a fieldName and \a signature to \a value on class named \a className.
1289 */
1290 template <>
1291 Q_CORE_EXPORT void QJniObject::setStaticField<jobject>(const char *className,
1292                                                        const char *fieldName,
1293                                                        const char *sig,
1294                                                        jobject value)
1295 {
1296     QJniEnvironment env;
1297     jclass clazz = loadClass(className, env);
1298 
1299     if (!clazz)
1300         return;
1301 
1302     jfieldID id = getCachedFieldID(env, clazz, className, fieldName, sig, true);
1303     if (id) {
1304         env->SetStaticObjectField(clazz, id, value);
1305         env.exceptionCheckAndClear();
1306     }
1307 }
1308 
1309 /*!
1310     \fn template <typename T> void QJniObject::setStaticField(jclass clazz, const char *fieldName, const char *signature, T value);
1311 
1312     Sets the static field with \a fieldName and \a signature to \a value on class \a clazz.
1313 */
1314 template <> Q_CORE_EXPORT void QJniObject::setStaticField<jobject>(jclass clazz,
1315                                                                    const char *fieldName,
1316                                                                    const char *sig,
1317                                                                    jobject value)
1318 {
1319     QJniEnvironment env;
1320     jfieldID id = getFieldID(env, clazz, fieldName, sig, true);
1321 
1322     if (id) {
1323         env->SetStaticObjectField(clazz, id, value);
1324         env.exceptionCheckAndClear();
1325     }
1326 }
1327 
1328 /*!
1329     \fn T QJniObject::getField(const char *fieldName) const
1330 
1331     Retrieves the value of the field \a fieldName.
1332 
1333     \code
1334     QJniObject volumeControl = ...;
1335     jint fieldValue = volumeControl.getField<jint>("MAX_VOLUME");
1336     \endcode
1337 */
1338 
1339 /*!
1340     \fn T QJniObject::getStaticField(const char *className, const char *fieldName)
1341 
1342     Retrieves the value from the static field \a fieldName on the class \a className.
1343 */
1344 
1345 /*!
1346     \fn T QJniObject::getStaticField(jclass clazz, const char *fieldName)
1347 
1348     Retrieves the value from the static field \a fieldName on \a clazz.
1349 */
1350 
1351 /*!
1352     \fn template <typename T> void QJniObject::setStaticField(const char *className, const char *fieldName, T value)
1353 
1354     Sets the static field \a fieldName of the class named \a className to \a value.
1355 */
1356 
1357 /*!
1358     \fn template <typename T> void QJniObject::setStaticField(jclass clazz, const char *fieldName, T value)
1359 
1360     Sets the static field \a fieldName of the class \a clazz to \a value.
1361 */
1362 #define MAKE_JNI_PRIMITIVE_FIELDS(FieldName, Type, Signature) \
1363 template <> Q_CORE_EXPORT Type QJniObject::getField<Type>(const char *fieldName) const \
1364 { \
1365     QJniEnvironment env; \
1366     Type res = 0; \
1367     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, Signature); \
1368     if (id) {\
1369         res = env->Get##FieldName##Field(d->m_jobject, id); \
1370         if (env.exceptionCheckAndClear())  \
1371             res = 0; \
1372     } \
1373     return res;\
1374 } \
1375 template <> \
1376 Q_CORE_EXPORT Type QJniObject::getStaticField<Type>(const char *className, const char *fieldName) \
1377 { \
1378     QJniEnvironment env; \
1379     jclass clazz = loadClass(className, env); \
1380     if (!clazz) \
1381         return 0; \
1382     jfieldID id = getCachedFieldID(env, clazz, toBinaryEncClassName(className), fieldName, \
1383                                    Signature, true); \
1384     if (!id) \
1385         return 0; \
1386     Type res = env->GetStatic##FieldName##Field(clazz, id); \
1387     if (env.exceptionCheckAndClear())  \
1388         res = 0; \
1389     return res;\
1390 } \
1391 template <>\
1392 Q_CORE_EXPORT Type QJniObject::getStaticField<Type>(jclass clazz, const char *fieldName)\
1393 {\
1394     QJniEnvironment env;\
1395     Type res = 0;\
1396     jfieldID id = getFieldID(env, clazz, fieldName, Signature, true);\
1397     if (id) {\
1398         res = env->GetStatic##FieldName##Field(clazz, id);\
1399         if (env.exceptionCheckAndClear())  \
1400             res = 0; \
1401     }\
1402     return res;\
1403 }\
1404 template <> Q_CORE_EXPORT void QJniObject::setStaticField<Type>(const char *className, \
1405                                                                 const char *fieldName, \
1406                                                                 Type value) \
1407 { \
1408     QJniEnvironment env; \
1409     jclass clazz = loadClass(className, env); \
1410     if (!clazz) \
1411         return; \
1412     jfieldID id = getCachedFieldID(env, clazz, className, fieldName, Signature, true); \
1413     if (!id) \
1414         return; \
1415     env->SetStatic##FieldName##Field(clazz, id, value); \
1416     env.exceptionCheckAndClear(); \
1417 }\
1418 template <> Q_CORE_EXPORT void QJniObject::setStaticField<Type>(jclass clazz,\
1419                                                                 const char *fieldName,\
1420                                                                 Type value)\
1421 {\
1422     QJniEnvironment env;\
1423     jfieldID id = getFieldID(env, clazz, fieldName, Signature, true);\
1424     if (id) {\
1425         env->SetStatic##FieldName##Field(clazz, id, value);\
1426         env.exceptionCheckAndClear();\
1427     }\
1428 }\
1429 template <> Q_CORE_EXPORT void QJniObject::setField<Type>(const char *fieldName, Type value) \
1430 { \
1431     QJniEnvironment env; \
1432     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, Signature); \
1433     if (id) { \
1434         env->Set##FieldName##Field(d->m_jobject, id, value); \
1435         env.exceptionCheckAndClear(); \
1436     } \
1437 } \
1438 
1439 #define DECLARE_JNI_PRIMITIVE_FIELDS(FieldName, Type, Signature) MAKE_JNI_PRIMITIVE_FIELDS(FieldName, Type, \
1440                                                                                Signature)
1441 DECLARE_JNI_PRIMITIVE_FIELDS(Boolean, jboolean, "Z")
1442 DECLARE_JNI_PRIMITIVE_FIELDS(Byte, jbyte, "B")
1443 DECLARE_JNI_PRIMITIVE_FIELDS(Char, jchar, "C")
1444 DECLARE_JNI_PRIMITIVE_FIELDS(Short, jshort, "S")
1445 DECLARE_JNI_PRIMITIVE_FIELDS(Int, jint, "I")
1446 DECLARE_JNI_PRIMITIVE_FIELDS(Long, jlong, "J")
1447 DECLARE_JNI_PRIMITIVE_FIELDS(Float, jfloat, "F")
1448 DECLARE_JNI_PRIMITIVE_FIELDS(Double, jdouble, "D")
1449 
1450 /*!
1451     \fn QJniObject QJniObject::getStaticObjectField(const char *className, const char *fieldName, const char *signature)
1452     Retrieves the object from the field with \a signature and \a fieldName on class \a className.
1453 
1454     \note This function can be used without a template type.
1455 
1456     \code
1457     QJniObject jobj = QJniObject::getStaticObjectField("class/with/Fields", "FIELD_NAME", "Ljava/lang/String;");
1458     \endcode
1459 */
1460 QJniObject QJniObject::getStaticObjectField(const char *className,
1461                                             const char *fieldName,
1462                                             const char *sig)
1463 {
1464     QJniEnvironment env;
1465     jclass clazz = loadClass(className, env);
1466     if (!clazz)
1467         return QJniObject();
1468     jfieldID id = getCachedFieldID(env, clazz, toBinaryEncClassName(className), fieldName,
1469                                    sig, true);
1470     if (!id)
1471         return QJniObject();
1472     jobject res = env->GetStaticObjectField(clazz, id);
1473     if (res && env.exceptionCheckAndClear())
1474         res = nullptr;
1475     QJniObject obj(res);
1476     env->DeleteLocalRef(res);
1477     return obj;
1478 }
1479 
1480 /*!
1481     \fn QJniObject QJniObject::getStaticObjectField(jclass clazz, const char *fieldName, const char *signature)
1482     Retrieves the object from the field with \a signature and \a fieldName on \a clazz.
1483 
1484     \note This function can be used without a template type.
1485 
1486     \code
1487     QJniObject jobj = QJniObject::getStaticObjectField(clazz, "FIELD_NAME", "Ljava/lang/String;");
1488     \endcode
1489 */
1490 QJniObject QJniObject::getStaticObjectField(jclass clazz,
1491                                             const char *fieldName,
1492                                             const char *sig)
1493 {
1494     QJniEnvironment env;
1495     jobject res = nullptr;
1496     jfieldID id = getFieldID(env, clazz, fieldName, sig, true);
1497     if (id) {
1498         res = env->GetStaticObjectField(clazz, id);
1499         if (res && env.exceptionCheckAndClear())
1500             res = nullptr;
1501     }
1502 
1503     QJniObject obj(res);
1504     env->DeleteLocalRef(res);
1505     return obj;
1506 }
1507 
1508 /*!
1509     \fn QJniObject QJniObject::getStaticObjectField<jobject>(jclass clazz, const char *fieldName, const char *signature)
1510 
1511     Retrieves the \a jobject from the field with \a signature and \a fieldName on \a clazz.
1512 */
1513 template <>
1514 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobject>(jclass clazz,
1515                                                                    const char *fieldName,
1516                                                                    const char *sig)
1517 {
1518     return getStaticObjectField(clazz, fieldName, sig);
1519 }
1520 
1521 /*!
1522     \fn QJniObject QJniObject::getStaticObjectField<jobject>(jclass clazz, const char *fieldName, const char *signature)
1523 
1524     Retrieves the jobject from the field with \a signature and \a fieldName on class named \a className.
1525 */
1526 template <>
1527 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobject>(const char *className,
1528                                                                    const char *fieldName,
1529                                                                    const char *sig)
1530 {
1531     return getStaticObjectField(className, fieldName, sig);
1532 }
1533 
1534 /*!
1535     \fn QJniObject QJniObject::getStaticObjectField<jobjectArray>(jclass clazz, const char *fieldName, const char *signature)
1536 
1537     Retrieves the jobjectArray from the field with \a signature and \a fieldName on \a clazz.
1538 */
1539 template <>
1540 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobjectArray>(jclass clazz,
1541                                                                         const char *fieldName,
1542                                                                         const char *sig)
1543 {
1544     return getStaticObjectField(clazz, fieldName, sig);
1545 }
1546 
1547 /*!
1548     \fn QJniObject QJniObject::getStaticObjectField<jobjectArray>(jclass clazz, const char *fieldName, const char *signature)
1549 
1550     Retrieves the jobjectArray from the field with \a signature and \a fieldName on the class named \a className.
1551 */
1552 template <>
1553 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobjectArray>(const char *className,
1554                                                                         const char *fieldName,
1555                                                                         const char *sig)
1556 {
1557     return getStaticObjectField(className, fieldName, sig);
1558 }
1559 
1560 /*!
1561     \fn template <typename T> void QJniObject::setField(const char *fieldName, const char *signature, T value)
1562 
1563     Sets the value of \a fieldName with \a signature to \a value.
1564 
1565     \code
1566     QJniObject stringArray = ...;
1567     QJniObject obj = ...;
1568     obj.setField<jobjectArray>("KEY_VALUES", "([Ljava/lang/String;)V", stringArray.object<jobjectArray>())
1569     \endcode
1570 */
1571 template <> Q_CORE_EXPORT
1572 void QJniObject::setField<jobject>(const char *fieldName, const char *sig, jobject value)
1573 {
1574     QJniEnvironment env;
1575     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, sig);
1576     if (id) {
1577         env->SetObjectField(d->m_jobject, id, value);
1578         env.exceptionCheckAndClear();
1579     }
1580 }
1581 
1582 template <> Q_CORE_EXPORT
1583 void QJniObject::setField<jobjectArray>(const char *fieldName, const char *sig, jobjectArray value)
1584 {
1585     QJniEnvironment env;
1586     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, sig);
1587     if (id) {
1588         env->SetObjectField(d->m_jobject, id, value);
1589         env.exceptionCheckAndClear();
1590     }
1591 }
1592 
1593 /*!
1594     \fn QJniObject QJniObject::getObjectField(const char *fieldName) const
1595 
1596     Retrieves the object of field \a fieldName.
1597 
1598     \code
1599     QJniObject field = jniObject.getObjectField<jstring>("FIELD_NAME");
1600     \endcode
1601 */
1602 
1603 /*!
1604     \fn QJniObject QJniObject::getObjectField(const char *fieldName, const char *signature) const
1605 
1606     Retrieves the object from the field with \a signature and \a fieldName.
1607 
1608     \note This function can be used without a template type.
1609 
1610     \code
1611     QJniObject field = jniObject.getObjectField("FIELD_NAME", "Ljava/lang/String;");
1612     \endcode
1613 */
1614 QJniObject QJniObject::getObjectField(const char *fieldName, const char *sig) const
1615 {
1616     QJniEnvironment env;
1617     jobject res = nullptr;
1618     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, sig);
1619     if (id) {
1620         res = env->GetObjectField(d->m_jobject, id);
1621         if (res && env.exceptionCheckAndClear())
1622             res = nullptr;
1623     }
1624 
1625     QJniObject obj(res);
1626     env->DeleteLocalRef(res);
1627     return obj;
1628 }
1629 
1630 /*!
1631     \fn template <typename T> void QJniObject::setField(const char *fieldName, T value)
1632 
1633     Sets the value of \a fieldName to \a value.
1634 
1635     \code
1636     ...
1637     QJniObject obj;
1638     obj.setField<jint>("AN_INT_FIELD", 10);
1639     jstring myString = ...
1640     obj.setField<jstring>("A_STRING_FIELD", myString);
1641     ...
1642     \endcode
1643 */
1644 
1645 /*!
1646     \fn QJniObject QJniObject::getStaticObjectField(const char *className, const char *fieldName)
1647 
1648     Retrieves the object from the field \a fieldName on the class \a className.
1649 
1650     \code
1651     QJniObject jobj = QJniObject::getStaticObjectField<jstring>("class/with/Fields", "FIELD_NAME");
1652     \endcode
1653 */
1654 
1655 /*!
1656     \fn QJniObject QJniObject::getStaticObjectField(jclass clazz, const char *fieldName)
1657 
1658     Retrieves the object from the field \a fieldName on \a clazz.
1659 
1660     \code
1661     QJniObject jobj = QJniObject::getStaticObjectField<jstring>(clazz, "FIELD_NAME");
1662     \endcode
1663 */
1664 
1665 #define MAKE_JNI_OBJECT_FILEDS(Type, Signature) \
1666 template <> Q_CORE_EXPORT void QJniObject::setField<Type>(const char *fieldName, Type value) \
1667 { \
1668     QJniObject::setField<jobject>(fieldName, Signature, value); \
1669 } \
1670 \
1671 template <> Q_CORE_EXPORT void QJniObject::setStaticField<Type>(const char *className, \
1672                                                                 const char *fieldName, \
1673                                                                 Type value) \
1674 { \
1675     QJniObject::setStaticField<jobject>(className, fieldName, Signature, value); \
1676 }\
1677 template <>\
1678 Q_CORE_EXPORT QJniObject QJniObject::getObjectField<Type>(const char *fieldName) const\
1679 {\
1680     return getObjectField(fieldName, Signature);\
1681 }\
1682 template <>\
1683 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<Type>(jclass clazz,\
1684                                                                 const char *fieldName)\
1685 {\
1686     return getStaticObjectField(clazz, fieldName, Signature);\
1687 }\
1688 template <>\
1689 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<Type>(const char *className,\
1690                                                                 const char *fieldName)\
1691 {\
1692     return getStaticObjectField(className, fieldName, Signature);\
1693 }\
1694 
1695 #define DECLARE_JNI_OBJECT_FILEDS(Type, Signature) MAKE_JNI_OBJECT_FILEDS(Type, Signature)
1696 
1697 DECLARE_JNI_OBJECT_FILEDS(jobject, "Ljava/lang/Object;")
1698 DECLARE_JNI_OBJECT_FILEDS(jobjectArray, "[Ljava/lang/Object;")
1699 DECLARE_JNI_OBJECT_FILEDS(jstring, "Ljava/lang/String;")
1700 DECLARE_JNI_OBJECT_FILEDS(jclass, "Ljava/lang/Class;")
1701 DECLARE_JNI_OBJECT_FILEDS(jthrowable, "Ljava/lang/Throwable;")
1702 DECLARE_JNI_OBJECT_FILEDS(jbooleanArray, "[Z")
1703 DECLARE_JNI_OBJECT_FILEDS(jbyteArray, "[B")
1704 DECLARE_JNI_OBJECT_FILEDS(jcharArray, "[C")
1705 DECLARE_JNI_OBJECT_FILEDS(jshortArray, "[S")
1706 DECLARE_JNI_OBJECT_FILEDS(jintArray, "[I")
1707 DECLARE_JNI_OBJECT_FILEDS(jlongArray, "[J")
1708 DECLARE_JNI_OBJECT_FILEDS(jfloatArray, "[F")
1709 DECLARE_JNI_OBJECT_FILEDS(jdoubleArray, "[D")
1710 
1711 /*!
1712     \fn QJniObject QJniObject::fromString(const QString &string)
1713 
1714     Creates a Java string from the QString \a string and returns a QJniObject holding that string.
1715 
1716     \code
1717     QString myQString = "QString";
1718     QJniObject myJavaString = QJniObject::fromString(myQString);
1719     \endcode
1720 
1721     \sa toString()
1722 */
1723 QJniObject QJniObject::fromString(const QString &string)
1724 {
1725     QJniEnvironment env;
1726     jstring res = env->NewString(reinterpret_cast<const jchar*>(string.constData()),
1727                                                                 string.length());
1728     QJniObject obj(res);
1729     env->DeleteLocalRef(res);
1730     return obj;
1731 }
1732 
1733 /*!
1734     \fn QString QJniObject::toString() const
1735 
1736     Returns a QString with a string representation of the java object.
1737     Calling this function on a Java String object is a convenient way of getting the actual string
1738     data.
1739 
1740     \code
1741     QJniObject string = ...; //  "Hello Java"
1742     QString qstring = string.toString(); // "Hello Java"
1743     \endcode
1744 
1745     \sa fromString()
1746 */
1747 QString QJniObject::toString() const
1748 {
1749     if (!isValid())
1750         return QString();
1751 
1752     QJniObject string = callObjectMethod<jstring>("toString");
1753     return qt_convertJString(static_cast<jstring>(string.object()));
1754 }
1755 
1756 /*!
1757     \fn bool QJniObject::isClassAvailable(const char *className)
1758 
1759     Returns true if the Java class \a className is available.
1760 
1761     \code
1762     if (QJniObject::isClassAvailable("java/lang/String")) {
1763         // condition statement
1764     }
1765     \endcode
1766 */
1767 bool QJniObject::isClassAvailable(const char *className)
1768 {
1769     QJniEnvironment env;
1770 
1771     if (!env)
1772         return false;
1773 
1774     jclass clazz = loadClass(className, env);
1775     return (clazz != 0);
1776 }
1777 
1778 /*!
1779     \fn bool QJniObject::isValid() const
1780 
1781     Returns true if this instance holds a valid Java object.
1782 
1783     \code
1784     QJniObject qjniObject;                        ==> isValid() == false
1785     QJniObject qjniObject(0)                      ==> isValid() == false
1786     QJniObject qjniObject("could/not/find/Class") ==> isValid() == false
1787     \endcode
1788 */
1789 bool QJniObject::isValid() const
1790 {
1791     return d->m_jobject;
1792 }
1793 
1794 /*!
1795     \fn QJniObject QJniObject::fromLocalRef(jobject localRef)
1796     \since 6.1
1797 
1798     Creates a QJniObject from the local JNI reference \a localRef.
1799     This function takes ownership of \a localRef and frees it before returning.
1800 
1801     \note Only call this function with a local JNI reference. For example, most raw JNI calls, through
1802     the JNI environment, returns local references to a java object.
1803 
1804     \code
1805     jobject localRef = env->GetObjectArrayElement(array, index);
1806     QJniObject element = QJniObject::fromLocalRef(localRef);
1807     \endcode
1808 */
1809 QJniObject QJniObject::fromLocalRef(jobject lref)
1810 {
1811     QJniObject obj(lref);
1812     QJniEnvironment()->DeleteLocalRef(lref);
1813     return obj;
1814 }
1815 
1816 bool QJniObject::isSameObject(jobject obj) const
1817 {
1818     return QJniEnvironment()->IsSameObject(d->m_jobject, obj);
1819 }
1820 
1821 bool QJniObject::isSameObject(const QJniObject &other) const
1822 {
1823     return isSameObject(other.d->m_jobject);
1824 }
1825 
1826 void QJniObject::assign(jobject obj)
1827 {
1828     if (isSameObject(obj))
1829         return;
1830 
1831     jobject jobj = static_cast<jobject>(obj);
1832     d = QSharedPointer<QJniObjectPrivate>::create();
1833     if (obj) {
1834         QJniEnvironment env;
1835         d->m_jobject = env->NewGlobalRef(jobj);
1836         jclass objectClass = env->GetObjectClass(jobj);
1837         d->m_jclass = static_cast<jclass>(env->NewGlobalRef(objectClass));
1838         env->DeleteLocalRef(objectClass);
1839     }
1840 }
1841 
1842 jobject QJniObject::javaObject() const
1843 {
1844     return d->m_jobject;
1845 }
1846 
1847 QT_END_NAMESPACE
