Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtTest module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include <QtTest/qtestcase.h>
42 #include <QtTest/qtestassert.h>
43 
44 #include <QtCore/qbytearray.h>
45 #include <QtCore/qcoreapplication.h>
46 #include <QtCore/qdebug.h>
47 #include <QtCore/qdir.h>
48 #include <QtCore/qdiriterator.h>
49 #include <QtCore/qfile.h>
50 #include <QtCore/qfileinfo.h>
51 #include <QtCore/qfloat16.h>
52 #include <QtCore/qlibraryinfo.h>
53 #include <QtCore/qlist.h>
54 #include <QtCore/qmetaobject.h>
55 #include <QtCore/qobject.h>
56 #include <QtCore/qstringlist.h>
57 #include <QtCore/qtemporarydir.h>
58 #include <QtCore/qthread.h>
59 #include <QtCore/qvarlengtharray.h>
60 #include <QtCore/private/qlocking_p.h>
61 #include <QtCore/private/qtools_p.h>
62 #include <QtCore/private/qwaitcondition_p.h>
63 
64 #include <QtCore/qtestsupport_core.h>
65 
66 #include <QtTest/private/qtestlog_p.h>
67 #include <QtTest/private/qtesttable_p.h>
68 #include <QtTest/qtestdata.h>
69 #include <QtTest/private/qtestresult_p.h>
70 #include <QtTest/private/qsignaldumper_p.h>
71 #include <QtTest/private/qbenchmark_p.h>
72 #include <QtTest/private/cycle_p.h>
73 #include <QtTest/private/qtestblacklist_p.h>
74 #if defined(HAVE_XCTEST)
75 #include <QtTest/private/qxctestlogger_p.h>
76 #endif
77 #if defined Q_OS_MACOS
78 #include <QtTest/private/qtestutil_macos_p.h>
79 #endif
80 
81 #if defined(Q_OS_DARWIN)
82 #include <QtTest/private/qappletestlogger_p.h>
83 #endif
84 
85 #include <cmath>
86 #include <numeric>
87 #include <algorithm>
88 #include <condition_variable>
89 #include <mutex>
90 #include <chrono>
91 
92 #include <stdarg.h>
93 #include <stdio.h>
94 #include <stdlib.h>
95 
96 #if defined(Q_OS_LINUX)
97 #include <sys/types.h>
98 #include <fcntl.h>
99 #endif
100 
101 #ifdef Q_OS_WIN
102 # if !defined(Q_CC_MINGW) || (defined(Q_CC_MINGW) && defined(__MINGW64_VERSION_MAJOR))
103 #  include <crtdbg.h>
104 # endif
105 #include <qt_windows.h> // for Sleep
106 #endif
107 #ifdef Q_OS_UNIX
108 #include <errno.h>
109 #include <signal.h>
110 #include <time.h>
111 #include <unistd.h>
112 # if !defined(Q_OS_INTEGRITY)
113 #  include <sys/resource.h>
114 # endif
115 #endif
116 
117 #if defined(Q_OS_MACOS)
118 #include <IOKit/pwr_mgt/IOPMLib.h>
119 #include <mach/task.h>
120 #include <mach/mach_init.h>
121 #include <CoreFoundation/CFPreferences.h>
122 #endif
123 
124 #include <vector>
125 
126 QT_BEGIN_NAMESPACE
127 
128 using QtMiscUtils::toHexUpper;
129 using QtMiscUtils::fromHex;
130 
131 static bool debuggerPresent()
132 {
133 #if defined(Q_OS_LINUX)
134     int fd = open("/proc/self/status", O_RDONLY);
135     if (fd == -1)
136         return false;
137     char buffer[2048];
138     ssize_t size = read(fd, buffer, sizeof(buffer) - 1);
139     if (size == -1) {
140         close(fd);
141         return false;
142     }
143     buffer[size] = 0;
144     const char tracerPidToken[] = "\nTracerPid:";
145     char *tracerPid = strstr(buffer, tracerPidToken);
146     if (!tracerPid) {
147         close(fd);
148         return false;
149     }
150     tracerPid += sizeof(tracerPidToken);
151     long int pid = strtol(tracerPid, &tracerPid, 10);
152     close(fd);
153     return pid != 0;
154 #elif defined(Q_OS_WIN)
155     return IsDebuggerPresent();
156 #elif defined(Q_OS_MACOS)
157     // Check if there is an exception handler for the process:
158     mach_msg_type_number_t portCount = 0;
159     exception_mask_t masks[EXC_TYPES_COUNT];
160     mach_port_t ports[EXC_TYPES_COUNT];
161     exception_behavior_t behaviors[EXC_TYPES_COUNT];
162     thread_state_flavor_t flavors[EXC_TYPES_COUNT];
163     exception_mask_t mask = EXC_MASK_ALL & ~(EXC_MASK_RESOURCE | EXC_MASK_GUARD);
164     kern_return_t result = task_get_exception_ports(mach_task_self(), mask, masks, &portCount,
165                                                     ports, behaviors, flavors);
166     if (result == KERN_SUCCESS) {
167         for (mach_msg_type_number_t portIndex = 0; portIndex < portCount; ++portIndex) {
168             if (MACH_PORT_VALID(ports[portIndex])) {
169                 return true;
170             }
171         }
172     }
173     return false;
174 #else
175     // TODO
176     return false;
177 #endif
178 }
179 
180 #if !defined(Q_OS_WASM)
181 static bool hasSystemCrashReporter()
182 {
183 #if defined(Q_OS_MACOS)
184     return QTestPrivate::macCrashReporterWillShowDialog();
185 #else
186     return false;
187 #endif
188 }
189 
190 static void disableCoreDump()
191 {
192     bool ok = false;
193     const int disableCoreDump = qEnvironmentVariableIntValue("QTEST_DISABLE_CORE_DUMP", &ok);
194     if (ok && disableCoreDump) {
195 #if defined(Q_OS_UNIX) && !defined(Q_OS_INTEGRITY)
196         struct rlimit limit;
197         limit.rlim_cur = 0;
198         limit.rlim_max = 0;
199         if (setrlimit(RLIMIT_CORE, &limit) != 0)
200             qWarning("Failed to disable core dumps: %d", errno);
201 #endif
202     }
203 }
204 Q_CONSTRUCTOR_FUNCTION(disableCoreDump);
205 
206 static void stackTrace()
207 {
208     bool ok = false;
209     const int disableStackDump = qEnvironmentVariableIntValue("QTEST_DISABLE_STACK_DUMP", &ok);
210     if (ok && disableStackDump)
211         return;
212 
213     if (debuggerPresent() || hasSystemCrashReporter())
214         return;
215 
216 #if defined(Q_OS_LINUX) || (defined(Q_OS_MACOS) && !defined(Q_PROCESSOR_ARM_64))
217     const int msecsFunctionTime = qRound(QTestLog::msecsFunctionTime());
218     const int msecsTotalTime = qRound(QTestLog::msecsTotalTime());
219     fprintf(stderr, "\n=== Received signal at function time: %dms, total time: %dms, dumping stack ===\n",
220             msecsFunctionTime, msecsTotalTime);
221 #endif
222 #ifdef Q_OS_LINUX
223     char cmd[512];
224     qsnprintf(cmd, 512, "gdb --pid %d 1>&2 2>/dev/null <<EOF\n"
225                          "set prompt\n"
226                          "set height 0\n"
227                          "thread apply all where full\n"
228                          "detach\n"
229                          "quit\n"
230                          "EOF\n",
231                          static_cast<int>(getpid()));
232     if (system(cmd) == -1)
233         fprintf(stderr, "calling gdb failed\n");
234     fprintf(stderr, "=== End of stack trace ===\n");
235 #elif defined(Q_OS_MACOS)
236     char cmd[512];
237     qsnprintf(cmd, 512, "lldb -p %d 1>&2 2>/dev/null <<EOF\n"
238                          "bt all\n"
239                          "quit\n"
240                          "EOF\n",
241                          static_cast<int>(getpid()));
242     if (system(cmd) == -1)
243         fprintf(stderr, "calling lldb failed\n");
244     fprintf(stderr, "=== End of stack trace ===\n");
245 #endif
246 }
247 #endif // !Q_OS_WASM
248 
249 static bool installCoverageTool(const char * appname, const char * testname)
250 {
251 #if defined(__COVERAGESCANNER__) && !QT_CONFIG(testlib_selfcover)
252     if (!qEnvironmentVariableIsEmpty("QT_TESTCOCOON_ACTIVE"))
253         return false;
254     // Set environment variable QT_TESTCOCOON_ACTIVE to prevent an eventual subtest from
255     // being considered as a stand-alone test regarding the coverage analysis.
256     qputenv("QT_TESTCOCOON_ACTIVE", "1");
257 
258     // Install Coverage Tool
259     __coveragescanner_install(appname);
260     __coveragescanner_testname(testname);
261     __coveragescanner_clear();
262     return true;
263 #else
264     Q_UNUSED(appname);
265     Q_UNUSED(testname);
266     return false;
267 #endif
268 }
269 
270 static bool isValidSlot(const QMetaMethod &sl)
271 {
272     if (sl.access() != QMetaMethod::Private || sl.parameterCount() != 0
273         || sl.returnType() != QMetaType::Void || sl.methodType() != QMetaMethod::Slot)
274         return false;
275     const QByteArray name = sl.name();
276     return !(name.isEmpty() || name.endsWith("_data")
277         || name == "initTestCase" || name == "cleanupTestCase"
278         || name == "init" || name == "cleanup");
279 }
280 
281 namespace QTestPrivate
282 {
283     Q_TESTLIB_EXPORT Qt::MouseButtons qtestMouseButtons = Qt::NoButton;
284 }
285 
286 namespace QTest
287 {
288 
289 QString Internal::formatTryTimeoutDebugMessage(q_no_char8_t::QUtf8StringView expr, int timeout, int actual)
290 {
291     return QLatin1String("QTestLib: This test case check (\"%1\") failed because the requested timeout (%2 ms) was too short, %3 ms would have been sufficient this time.")
292             // ### Qt 7: remove the toString() (or earlier, when arg() can handle QUtf8StringView), passing the view directly
293             .arg(expr.toString(), QString::number(timeout), QString::number(actual));
294 }
295 
296 extern Q_TESTLIB_EXPORT int lastMouseTimestamp;
297 
298 class WatchDog;
299 
300 static QObject *currentTestObject = nullptr;
301 static QString mainSourcePath;
302 
303 #if defined(Q_OS_MACOS)
304 static IOPMAssertionID macPowerSavingDisabled = 0;
305 #endif
306 
307 class TestMethods {
308 public:
309     Q_DISABLE_COPY_MOVE(TestMethods)
310 
311     using MetaMethods = std::vector<QMetaMethod>;
312 
313     explicit TestMethods(const QObject *o, MetaMethods m = {});
314 
315     void invokeTests(QObject *testObject) const;
316 
317     static QMetaMethod findMethod(const QObject *obj, const char *signature);
318 
319 private:
320     bool invokeTest(int index, const char *data, WatchDog *watchDog) const;
321     void invokeTestOnData(int index) const;
322 
323     QMetaMethod m_initTestCaseMethod; // might not exist, check isValid().
324     QMetaMethod m_initTestCaseDataMethod;
325     QMetaMethod m_cleanupTestCaseMethod;
326     QMetaMethod m_initMethod;
327     QMetaMethod m_cleanupMethod;
328 
329     MetaMethods m_methods;
330 };
331 
332 TestMethods::TestMethods(const QObject *o, MetaMethods m)
333     : m_initTestCaseMethod(TestMethods::findMethod(o, "initTestCase()"))
334     , m_initTestCaseDataMethod(TestMethods::findMethod(o, "initTestCase_data()"))
335     , m_cleanupTestCaseMethod(TestMethods::findMethod(o, "cleanupTestCase()"))
336     , m_initMethod(TestMethods::findMethod(o, "init()"))
337     , m_cleanupMethod(TestMethods::findMethod(o, "cleanup()"))
338     , m_methods(std::move(m))
339 {
340     if (m_methods.empty()) {
341         const QMetaObject *metaObject = o->metaObject();
342         const int count = metaObject->methodCount();
343         m_methods.reserve(count);
344         for (int i = 0; i < count; ++i) {
345             const QMetaMethod me = metaObject->method(i);
346             if (isValidSlot(me))
347                 m_methods.push_back(me);
348         }
349     }
350 }
351 
352 QMetaMethod TestMethods::findMethod(const QObject *obj, const char *signature)
353 {
354     const QMetaObject *metaObject = obj->metaObject();
355     const int funcIndex = metaObject->indexOfMethod(signature);
356     return funcIndex >= 0 ? metaObject->method(funcIndex) : QMetaMethod();
357 }
358 
359 static int keyDelay = -1;
360 static int mouseDelay = -1;
361 static int eventDelay = -1;
362 #if QT_CONFIG(thread)
363 static int timeout = -1;
364 #endif
365 static bool noCrashHandler = false;
366 
367 /*! \internal
368     Invoke a method of the object without generating warning if the method does not exist
369  */
370 static void invokeMethod(QObject *obj, const char *methodName)
371 {
372     const QMetaObject *metaObject = obj->metaObject();
373     int funcIndex = metaObject->indexOfMethod(methodName);
374     if (funcIndex >= 0) {
375         QMetaMethod method = metaObject->method(funcIndex);
376         method.invoke(obj, Qt::DirectConnection);
377     }
378 }
379 
380 int defaultEventDelay()
381 {
382     if (eventDelay == -1) {
383         const QByteArray env = qgetenv("QTEST_EVENT_DELAY");
384         if (!env.isEmpty())
385             eventDelay = atoi(env.constData());
386         else
387             eventDelay = 0;
388     }
389     return eventDelay;
390 }
391 
392 int Q_TESTLIB_EXPORT defaultMouseDelay()
393 {
394     if (mouseDelay == -1) {
395         const QByteArray env = qgetenv("QTEST_MOUSEEVENT_DELAY");
396         if (!env.isEmpty())
397             mouseDelay = atoi(env.constData());
398         else
399             mouseDelay = defaultEventDelay();
400     }
401     return mouseDelay;
402 }
403 
404 int Q_TESTLIB_EXPORT defaultKeyDelay()
405 {
406     if (keyDelay == -1) {
407         const QByteArray env = qgetenv("QTEST_KEYEVENT_DELAY");
408         if (!env.isEmpty())
409             keyDelay = atoi(env.constData());
410         else
411             keyDelay = defaultEventDelay();
412     }
413     return keyDelay;
414 }
415 #if QT_CONFIG(thread)
416 static std::chrono::milliseconds defaultTimeout()
417 {
418     if (timeout == -1) {
419         bool ok = false;
420         timeout = qEnvironmentVariableIntValue("QTEST_FUNCTION_TIMEOUT", &ok);
421 
422         if (!ok || timeout <= 0)
423             timeout = 5*60*1000;
424     }
425     return std::chrono::milliseconds{timeout};
426 }
427 #endif
428 
429 Q_TESTLIB_EXPORT bool printAvailableFunctions = false;
430 Q_TESTLIB_EXPORT QStringList testFunctions;
431 Q_TESTLIB_EXPORT QStringList testTags;
432 
433 static void qPrintTestSlots(FILE *stream, const char *filter = nullptr)
434 {
435     for (int i = 0; i < QTest::currentTestObject->metaObject()->methodCount(); ++i) {
436         QMetaMethod sl = QTest::currentTestObject->metaObject()->method(i);
437         if (isValidSlot(sl)) {
438             const QByteArray signature = sl.methodSignature();
439             if (!filter || QString::fromLatin1(signature).contains(QLatin1String(filter), Qt::CaseInsensitive))
440                 fprintf(stream, "%s\n", signature.constData());
441         }
442     }
443 }
444 
445 static void qPrintDataTags(FILE *stream)
446 {
447     // Avoid invoking the actual test functions, and also avoid printing irrelevant output:
448     QTestLog::setPrintAvailableTagsMode();
449 
450     // Get global data tags:
451     QTestTable::globalTestTable();
452     invokeMethod(QTest::currentTestObject, "initTestCase_data()");
453     const QTestTable *gTable = QTestTable::globalTestTable();
454 
455     const QMetaObject *currTestMetaObj = QTest::currentTestObject->metaObject();
456 
457     // Process test functions:
458     for (int i = 0; i < currTestMetaObj->methodCount(); ++i) {
459         QMetaMethod tf = currTestMetaObj->method(i);
460 
461         if (isValidSlot(tf)) {
462 
463             // Retrieve local tags:
464             QStringList localTags;
465             QTestTable table;
466             char *slot = qstrdup(tf.methodSignature().constData());
467             slot[strlen(slot) - 2] = '\0';
468             QByteArray member;
469             member.resize(qstrlen(slot) + qstrlen("_data()") + 1);
470             qsnprintf(member.data(), member.size(), "%s_data()", slot);
471             invokeMethod(QTest::currentTestObject, member.constData());
472             const int dataCount = table.dataCount();
473             localTags.reserve(dataCount);
474             for (int j = 0; j < dataCount; ++j)
475                 localTags << QLatin1String(table.testData(j)->dataTag());
476 
477             // Print all tag combinations:
478             if (gTable->dataCount() == 0) {
479                 if (localTags.count() == 0) {
480                     // No tags at all, so just print the test function:
481                     fprintf(stream, "%s %s\n", currTestMetaObj->className(), slot);
482                 } else {
483                     // Only local tags, so print each of them:
484                     for (int k = 0; k < localTags.size(); ++k)
485                         fprintf(
486                             stream, "%s %s %s\n",
487                             currTestMetaObj->className(), slot, localTags.at(k).toLatin1().data());
488                 }
489             } else {
490                 for (int j = 0; j < gTable->dataCount(); ++j) {
491                     if (localTags.count() == 0) {
492                         // Only global tags, so print the current one:
493                         fprintf(
494                             stream, "%s %s __global__ %s\n",
495                             currTestMetaObj->className(), slot, gTable->testData(j)->dataTag());
496                     } else {
497                         // Local and global tags, so print each of the local ones and
498                         // the current global one:
499                         for (int k = 0; k < localTags.size(); ++k)
500                             fprintf(
501                                 stream, "%s %s %s __global__ %s\n", currTestMetaObj->className(), slot,
502                                 localTags.at(k).toLatin1().data(), gTable->testData(j)->dataTag());
503                     }
504                 }
505             }
506 
507             delete[] slot;
508         }
509     }
510 }
511 
512 static int qToInt(const char *str)
513 {
514     char *pEnd;
515     int l = static_cast<int>(strtol(str, &pEnd, 10));
516     if (*pEnd != 0) {
517         fprintf(stderr, "Invalid numeric parameter: '%s'\n", str);
518         exit(1);
519     }
520     return l;
521 }
522 
523 Q_TESTLIB_EXPORT void qtest_qParseArgs(int argc, const char *const argv[], bool qml)
524 {
525     int logFormat = -1; // Not set
526     const char *logFilename = nullptr;
527 
528     QTest::testFunctions.clear();
529     QTest::testTags.clear();
530 
531 #if defined(Q_OS_MAC) && defined(HAVE_XCTEST)
532     if (QXcodeTestLogger::canLogTestProgress())
533         logFormat = QTestLog::XCTest;
534 #endif
535 
536     const char *testOptions =
537          " New-style logging options:\n"
538          " -o filename,format  : Output results to file in the specified format\n"
539          "                       Use - to output to stdout\n"
540          "                       Valid formats are:\n"
541          "                         txt      : Plain text\n"
542          "                         csv      : CSV format (suitable for benchmarks)\n"
543          "                         junitxml : XML JUnit document\n"
544          "                         xml      : XML document\n"
545          "                         lightxml : A stream of XML tags\n"
546          "                         teamcity : TeamCity format\n"
547          "                         tap      : Test Anything Protocol\n"
548          "\n"
549          "     *** Multiple loggers can be specified, but at most one can log to stdout.\n"
550          "\n"
551          " Old-style logging options:\n"
552          " -o filename         : Write the output into file\n"
553          " -txt                : Output results in Plain Text\n"
554          " -csv                : Output results in a CSV format (suitable for benchmarks)\n"
555          " -junitxml           : Output results as XML JUnit document\n"
556          " -xml                : Output results as XML document\n"
557          " -lightxml           : Output results as stream of XML tags\n"
558          " -teamcity           : Output results in TeamCity format\n"
559          " -tap                : Output results in Test Anything Protocol format\n"
560          "\n"
561          "     *** If no output file is specified, stdout is assumed.\n"
562          "     *** If no output format is specified, -txt is assumed.\n"
563          "\n"
564          " Test log detail options:\n"
565          " -silent             : Log failures and fatal errors only\n"
566          " -v1                 : Log the start of each testfunction\n"
567          " -v2                 : Log each QVERIFY/QCOMPARE/QTEST (implies -v1)\n"
568          " -vs                 : Log every signal emission and resulting slot invocations\n"
569          "\n"
570          "     *** The -silent and -v1 options only affect plain text output.\n"
571          "\n"
572          " Testing options:\n"
573          " -functions          : Returns a list of current testfunctions\n"
574          " -datatags           : Returns a list of current data tags.\n"
575          "                       A global data tag is preceded by ' __global__ '.\n"
576          " -eventdelay ms      : Set default delay for mouse and keyboard simulation to ms milliseconds\n"
577          " -keydelay ms        : Set default delay for keyboard simulation to ms milliseconds\n"
578          " -mousedelay ms      : Set default delay for mouse simulation to ms milliseconds\n"
579          " -maxwarnings n      : Sets the maximum amount of messages to output.\n"
580          "                       0 means unlimited, default: 2000\n"
581          " -nocrashhandler     : Disables the crash handler. Useful for debugging crashes.\n"
582          "\n"
583          " Benchmarking options:\n"
584 #if QT_CONFIG(valgrind)
585          " -callgrind          : Use callgrind to time benchmarks\n"
586 #endif
587 #ifdef QTESTLIB_USE_PERF_EVENTS
588          " -perf               : Use Linux perf events to time benchmarks\n"
589          " -perfcounter name   : Use the counter named 'name'\n"
590          " -perfcounterlist    : Lists the counters available\n"
591 #endif
592 #ifdef HAVE_TICK_COUNTER
593          " -tickcounter        : Use CPU tick counters to time benchmarks\n"
594 #endif
595          " -eventcounter       : Counts events received during benchmarks\n"
596          " -minimumvalue n     : Sets the minimum acceptable measurement value\n"
597          " -minimumtotal n     : Sets the minimum acceptable total for repeated executions of a test function\n"
598          " -iterations  n      : Sets the number of accumulation iterations.\n"
599          " -median  n          : Sets the number of median iterations.\n"
600          " -vb                 : Print out verbose benchmarking information.\n";
601 
602     for (int i = 1; i < argc; ++i) {
603         if (strcmp(argv[i], "-help") == 0 || strcmp(argv[i], "--help") == 0
604             || strcmp(argv[i], "/?") == 0) {
605             printf(" Usage: %s [options] [testfunction[:testdata]]...\n"
606                    "    By default, all testfunctions will be run.\n\n"
607                    "%s", argv[0], testOptions);
608 
609             if (qml) {
610                 printf ("\n"
611                         " QmlTest options:\n"
612                         " -import dir         : Specify an import directory.\n"
613                         " -plugins dir        : Specify a directory where to search for plugins.\n"
614                         " -input dir/file     : Specify the root directory for test cases or a single test case file.\n"
615                         " -translation file   : Specify the translation file.\n"
616                         " -file-selector dir  : Specify a file selector for the QML engine.\n"
617                         );
618             }
619 
620             printf("\n"
621                    " -help               : This help\n");
622             exit(0);
623         } else if (strcmp(argv[i], "-functions") == 0) {
624             if (qml) {
625                 QTest::printAvailableFunctions = true;
626             } else {
627                 qPrintTestSlots(stdout);
628                 exit(0);
629             }
630         } else if (strcmp(argv[i], "-datatags") == 0) {
631             if (!qml) {
632                 qPrintDataTags(stdout);
633                 exit(0);
634             }
635         } else if (strcmp(argv[i], "-txt") == 0) {
636             logFormat = QTestLog::Plain;
637         } else if (strcmp(argv[i], "-csv") == 0) {
638             logFormat = QTestLog::CSV;
639         } else if (strcmp(argv[i], "-junitxml") == 0 || strcmp(argv[i], "-xunitxml") == 0)  {
640             logFormat = QTestLog::JUnitXML;
641         } else if (strcmp(argv[i], "-xml") == 0) {
642             logFormat = QTestLog::XML;
643         } else if (strcmp(argv[i], "-lightxml") == 0) {
644             logFormat = QTestLog::LightXML;
645         } else if (strcmp(argv[i], "-teamcity") == 0) {
646             logFormat = QTestLog::TeamCity;
647         } else if (strcmp(argv[i], "-tap") == 0) {
648             logFormat = QTestLog::TAP;
649         } else if (strcmp(argv[i], "-silent") == 0) {
650             QTestLog::setVerboseLevel(-1);
651         } else if (strcmp(argv[i], "-v1") == 0) {
652             QTestLog::setVerboseLevel(1);
653         } else if (strcmp(argv[i], "-v2") == 0) {
654             QTestLog::setVerboseLevel(2);
655         } else if (strcmp(argv[i], "-vs") == 0) {
656             QSignalDumper::setEnabled(true);
657         } else if (strcmp(argv[i], "-o") == 0) {
658             if (i + 1 >= argc) {
659                 fprintf(stderr, "-o needs an extra parameter specifying the filename and optional format\n");
660                 exit(1);
661             }
662             ++i;
663             // Do we have the old or new style -o option?
664             char *filename = new char[strlen(argv[i])+1];
665             char *format = new char[strlen(argv[i])+1];
666             if (sscanf(argv[i], "%[^,],%s", filename, format) == 1) {
667                 // Old-style
668                 logFilename = argv[i];
669             } else {
670                 // New-style
671                 if (strcmp(format, "txt") == 0)
672                     logFormat = QTestLog::Plain;
673                 else if (strcmp(format, "csv") == 0)
674                     logFormat = QTestLog::CSV;
675                 else if (strcmp(format, "lightxml") == 0)
676                     logFormat = QTestLog::LightXML;
677                 else if (strcmp(format, "xml") == 0)
678                     logFormat = QTestLog::XML;
679                 else if (strcmp(format, "junitxml") == 0 || strcmp(format, "xunitxml") == 0)
680                     logFormat = QTestLog::JUnitXML;
681                 else if (strcmp(format, "teamcity") == 0)
682                     logFormat = QTestLog::TeamCity;
683                 else if (strcmp(format, "tap") == 0)
684                     logFormat = QTestLog::TAP;
685                 else {
686                     fprintf(stderr, "output format must be one of txt, csv, lightxml, xml, tap, teamcity or junitxml\n");
687                     exit(1);
688                 }
689                 if (strcmp(filename, "-") == 0 && QTestLog::loggerUsingStdout()) {
690                     fprintf(stderr, "only one logger can log to stdout\n");
691                     exit(1);
692                 }
693                 QTestLog::addLogger(QTestLog::LogMode(logFormat), filename);
694             }
695             delete [] filename;
696             delete [] format;
697         } else if (strcmp(argv[i], "-eventdelay") == 0) {
698             if (i + 1 >= argc) {
699                 fprintf(stderr, "-eventdelay needs an extra parameter to indicate the delay(ms)\n");
700                 exit(1);
701             } else {
702                 QTest::eventDelay = qToInt(argv[++i]);
703             }
704         } else if (strcmp(argv[i], "-keydelay") == 0) {
705             if (i + 1 >= argc) {
706                 fprintf(stderr, "-keydelay needs an extra parameter to indicate the delay(ms)\n");
707                 exit(1);
708             } else {
709                 QTest::keyDelay = qToInt(argv[++i]);
710             }
711         } else if (strcmp(argv[i], "-mousedelay") == 0) {
712             if (i + 1 >= argc) {
713                 fprintf(stderr, "-mousedelay needs an extra parameter to indicate the delay(ms)\n");
714                 exit(1);
715             } else {
716                 QTest::mouseDelay = qToInt(argv[++i]);
717             }
718         } else if (strcmp(argv[i], "-maxwarnings") == 0) {
719             if (i + 1 >= argc) {
720                 fprintf(stderr, "-maxwarnings needs an extra parameter with the amount of warnings\n");
721                 exit(1);
722             } else {
723                 QTestLog::setMaxWarnings(qToInt(argv[++i]));
724             }
725         } else if (strcmp(argv[i], "-nocrashhandler") == 0) {
726             QTest::noCrashHandler = true;
727 #if QT_CONFIG(valgrind)
728         } else if (strcmp(argv[i], "-callgrind") == 0) {
729             if (QBenchmarkValgrindUtils::haveValgrind())
730                 if (QFileInfo(QDir::currentPath()).isWritable()) {
731                     QBenchmarkGlobalData::current->setMode(QBenchmarkGlobalData::CallgrindParentProcess);
732                 } else {
733                     fprintf(stderr, "WARNING: Current directory not writable. Using the walltime measurer.\n");
734                 }
735             else {
736                 fprintf(stderr, "WARNING: Valgrind not found or too old. Make sure it is installed and in your path. "
737                        "Using the walltime measurer.\n");
738             }
739         } else if (strcmp(argv[i], "-callgrindchild") == 0) { // "private" option
740             QBenchmarkGlobalData::current->setMode(QBenchmarkGlobalData::CallgrindChildProcess);
741             QBenchmarkGlobalData::current->callgrindOutFileBase =
742                 QBenchmarkValgrindUtils::outFileBase();
743 #endif
744 #ifdef QTESTLIB_USE_PERF_EVENTS
745         } else if (strcmp(argv[i], "-perf") == 0) {
746             if (QBenchmarkPerfEventsMeasurer::isAvailable()) {
747                 // perf available
748                 QBenchmarkGlobalData::current->setMode(QBenchmarkGlobalData::PerfCounter);
749             } else {
750                 fprintf(stderr, "WARNING: Linux perf events not available. Using the walltime measurer.\n");
751             }
752         } else if (strcmp(argv[i], "-perfcounter") == 0) {
753             if (i + 1 >= argc) {
754                 fprintf(stderr, "-perfcounter needs an extra parameter with the name of the counter\n");
755                 exit(1);
756             } else {
757                 QBenchmarkPerfEventsMeasurer::setCounter(argv[++i]);
758             }
759         } else if (strcmp(argv[i], "-perfcounterlist") == 0) {
760             QBenchmarkPerfEventsMeasurer::listCounters();
761             exit(0);
762 #endif
763 #ifdef HAVE_TICK_COUNTER
764         } else if (strcmp(argv[i], "-tickcounter") == 0) {
765             QBenchmarkGlobalData::current->setMode(QBenchmarkGlobalData::TickCounter);
766 #endif
767         } else if (strcmp(argv[i], "-eventcounter") == 0) {
768             QBenchmarkGlobalData::current->setMode(QBenchmarkGlobalData::EventCounter);
769         } else if (strcmp(argv[i], "-minimumvalue") == 0) {
770             if (i + 1 >= argc) {
771                 fprintf(stderr, "-minimumvalue needs an extra parameter to indicate the minimum time(ms)\n");
772                 exit(1);
773             } else {
774                 QBenchmarkGlobalData::current->walltimeMinimum = qToInt(argv[++i]);
775             }
776         } else if (strcmp(argv[i], "-minimumtotal") == 0) {
777             if (i + 1 >= argc) {
778                 fprintf(stderr, "-minimumtotal needs an extra parameter to indicate the minimum total measurement\n");
779                 exit(1);
780             } else {
781                 QBenchmarkGlobalData::current->minimumTotal = qToInt(argv[++i]);
782             }
783         } else if (strcmp(argv[i], "-iterations") == 0) {
784             if (i + 1 >= argc) {
785                 fprintf(stderr, "-iterations needs an extra parameter to indicate the number of iterations\n");
786                 exit(1);
787             } else {
788                 QBenchmarkGlobalData::current->iterationCount = qToInt(argv[++i]);
789             }
790         } else if (strcmp(argv[i], "-median") == 0) {
791             if (i + 1 >= argc) {
792                 fprintf(stderr, "-median needs an extra parameter to indicate the number of median iterations\n");
793                 exit(1);
794             } else {
795                 QBenchmarkGlobalData::current->medianIterationCount = qToInt(argv[++i]);
796             }
797 
798         } else if (strcmp(argv[i], "-vb") == 0) {
799             QBenchmarkGlobalData::current->verboseOutput = true;
800 #if defined(Q_OS_DARWIN)
801         } else if (strncmp(argv[i], "-Apple", 6) == 0) {
802             i += 1; // Skip Apple-specific user preferences
803             continue;
804 # if defined(HAVE_XCTEST)
805         } else if (int skip = QXcodeTestLogger::parseCommandLineArgument(argv[i])) {
806             i += (skip - 1); // Eating argv[i] with a continue counts towards skips
807             continue;
808 # endif
809 #endif
810         } else if (argv[i][0] == '-') {
811             fprintf(stderr, "Unknown option: '%s'\n\n%s", argv[i], testOptions);
812             if (qml) {
813                 fprintf(stderr, "\nqmltest related options:\n"
814                                 " -import    : Specify an import directory.\n"
815                                 " -plugins   : Specify a directory where to search for plugins.\n"
816                                 " -input     : Specify the root directory for test cases.\n"
817                        );
818             }
819 
820             fprintf(stderr, "\n"
821                             " -help      : This help\n");
822             exit(1);
823         } else {
824             // We can't check the availability of test functions until
825             // we load the QML files.  So just store the data for now.
826             int colon = -1;
827             int offset;
828             for (offset = 0; argv[i][offset]; ++offset) {
829                 if (argv[i][offset] == ':') {
830                     if (argv[i][offset + 1] == ':') {
831                         // "::" is used as a test name separator.
832                         // e.g. "ClickTests::test_click:row1".
833                         ++offset;
834                     } else {
835                         colon = offset;
836                         break;
837                     }
838                 }
839             }
840             if (colon == -1) {
841                 QTest::testFunctions += QString::fromLatin1(argv[i]);
842                 QTest::testTags += QString();
843             } else {
844                 QTest::testFunctions +=
845                     QString::fromLatin1(argv[i], colon);
846                 QTest::testTags +=
847                     QString::fromLatin1(argv[i] + colon + 1);
848             }
849         }
850     }
851 
852     bool installedTestCoverage = installCoverageTool(QTestResult::currentAppName(), QTestResult::currentTestObjectName());
853     QTestLog::setInstalledTestCoverage(installedTestCoverage);
854 
855     // If no loggers were created by the long version of the -o command-line
856     // option, but a logger was requested via the old-style option, add it.
857     const bool explicitLoggerRequested = logFormat != -1;
858     if (QTestLog::loggerCount() == 0 && explicitLoggerRequested)
859         QTestLog::addLogger(QTestLog::LogMode(logFormat), logFilename);
860 
861     bool addFallbackLogger = !explicitLoggerRequested;
862 
863 #if defined(QT_USE_APPLE_UNIFIED_LOGGING)
864     // Any explicitly requested loggers will be added by now, so we can check if they use stdout
865     const bool safeToAddAppleLogger = !AppleUnifiedLogger::willMirrorToStderr() || !QTestLog::loggerUsingStdout();
866     if (safeToAddAppleLogger && QAppleTestLogger::debugLoggingEnabled()) {
867         QTestLog::addLogger(QTestLog::Apple, nullptr);
868         if (AppleUnifiedLogger::willMirrorToStderr() && !logFilename)
869             addFallbackLogger = false; // Prevent plain test logger fallback below
870     }
871 #endif
872 
873     if (addFallbackLogger)
874         QTestLog::addLogger(QTestLog::Plain, logFilename);
875 }
876 
877 // Temporary, backwards compatibility, until qtdeclarative's use of it is converted
878 Q_TESTLIB_EXPORT void qtest_qParseArgs(int argc, char *argv[], bool qml) {
879     qtest_qParseArgs(argc, const_cast<const char *const *>(argv), qml);
880 }
881 
882 QBenchmarkResult qMedian(const QList<QBenchmarkResult> &container)
883 {
884     const int count = container.count();
885     if (count == 0)
886         return QBenchmarkResult();
887 
888     if (count == 1)
889         return container.front();
890 
891     QList<QBenchmarkResult> containerCopy = container;
892     std::sort(containerCopy.begin(), containerCopy.end());
893 
894     const int middle = count / 2;
895 
896     // ### handle even-sized containers here by doing an aritmetic mean of the two middle items.
897     return containerCopy.at(middle);
898 }
899 
900 struct QTestDataSetter
901 {
902     QTestDataSetter(QTestData *data)
903     {
904         QTestResult::setCurrentTestData(data);
905     }
906     ~QTestDataSetter()
907     {
908         QTestResult::setCurrentTestData(nullptr);
909     }
910 };
911 
912 namespace {
913 
914 qreal addResult(qreal current, const QBenchmarkResult& r)
915 {
916     return current + r.value;
917 }
918 
919 }
920 
921 void TestMethods::invokeTestOnData(int index) const
922 {
923     /* Benchmarking: for each median iteration*/
924 
925     bool isBenchmark = false;
926     int i = (QBenchmarkGlobalData::current->measurer->needsWarmupIteration()) ? -1 : 0;
927 
928     QList<QBenchmarkResult> results;
929     bool minimumTotalReached = false;
930     do {
931         QBenchmarkTestMethodData::current->beginDataRun();
932 
933         /* Benchmarking: for each accumulation iteration*/
934         bool invokeOk;
935         do {
936             if (m_initMethod.isValid())
937                 m_initMethod.invoke(QTest::currentTestObject, Qt::DirectConnection);
938             if (QTestResult::skipCurrentTest() || QTestResult::currentTestFailed())
939                 break;
940 
941             QBenchmarkTestMethodData::current->result = QBenchmarkResult();
942             QBenchmarkTestMethodData::current->resultAccepted = false;
943 
944             QBenchmarkGlobalData::current->context.tag =
945                 QLatin1String(
946                     QTestResult::currentDataTag()
947                     ? QTestResult::currentDataTag() : "");
948 
949             invokeOk = m_methods[index].invoke(QTest::currentTestObject, Qt::DirectConnection);
950             if (!invokeOk)
951                 QTestResult::addFailure("Unable to execute slot", __FILE__, __LINE__);
952 
953             isBenchmark = QBenchmarkTestMethodData::current->isBenchmark();
954 
955             QTestResult::finishedCurrentTestData();
956 
957             if (m_cleanupMethod.isValid())
958                 m_cleanupMethod.invoke(QTest::currentTestObject, Qt::DirectConnection);
959 
960             // Process any deleteLater(), like event-loop based apps would do. Fixes memleak reports.
961             if (QCoreApplication::instance())
962                 QCoreApplication::sendPostedEvents(nullptr, QEvent::DeferredDelete);
963 
964             // If the test isn't a benchmark, finalize the result after cleanup() has finished.
965             if (!isBenchmark)
966                 QTestResult::finishedCurrentTestDataCleanup();
967 
968             // If this test method has a benchmark, repeat until all measurements are
969             // acceptable.
970             // The QBENCHMARK macro increases the number of iterations for each run until
971             // this happens.
972         } while (invokeOk && isBenchmark
973                  && QBenchmarkTestMethodData::current->resultsAccepted() == false
974                  && !QTestResult::skipCurrentTest() && !QTestResult::currentTestFailed());
975 
976         QBenchmarkTestMethodData::current->endDataRun();
977         if (!QTestResult::skipCurrentTest() && !QTestResult::currentTestFailed()) {
978             if (i > -1)  // iteration -1 is the warmup iteration.
979                 results.append(QBenchmarkTestMethodData::current->result);
980 
981             if (isBenchmark && QBenchmarkGlobalData::current->verboseOutput) {
982                 if (i == -1) {
983                     QTestLog::info(qPrintable(
984                         QString::fromLatin1("warmup stage result      : %1")
985                             .arg(QBenchmarkTestMethodData::current->result.value)), nullptr, 0);
986                 } else {
987                     QTestLog::info(qPrintable(
988                         QString::fromLatin1("accumulation stage result: %1")
989                             .arg(QBenchmarkTestMethodData::current->result.value)), nullptr, 0);
990                 }
991             }
992         }
993 
994         // Verify if the minimum total measurement is reached, if it was specified:
995         if (QBenchmarkGlobalData::current->minimumTotal == -1) {
996             minimumTotalReached = true;
997         } else {
998             const qreal total = std::accumulate(results.begin(), results.end(), 0.0, addResult);
999             minimumTotalReached = (total >= QBenchmarkGlobalData::current->minimumTotal);
1000         }
1001     } while (isBenchmark
1002              && ((++i < QBenchmarkGlobalData::current->adjustMedianIterationCount()) || !minimumTotalReached)
1003              && !QTestResult::skipCurrentTest() && !QTestResult::currentTestFailed());
1004 
1005     // If the test is a benchmark, finalize the result after all iterations have finished.
1006     if (isBenchmark) {
1007         bool testPassed = !QTestResult::skipCurrentTest() && !QTestResult::currentTestFailed();
1008         QTestResult::finishedCurrentTestDataCleanup();
1009         // Only report benchmark figures if the test passed
1010         if (testPassed && QBenchmarkTestMethodData::current->resultsAccepted())
1011             QTestLog::addBenchmarkResult(qMedian(results));
1012     }
1013 }
1014 
1015 #if QT_CONFIG(thread)
1016 
1017 class WatchDog : public QThread
1018 {
1019     enum Expectation {
1020         ThreadStart,
1021         TestFunctionStart,
1022         TestFunctionEnd,
1023         ThreadEnd,
1024     };
1025 
1026     bool waitFor(std::unique_lock<QtPrivate::mutex> &m, Expectation e) {
1027         auto expectationChanged = [this, e] { return expecting.load(std::memory_order_relaxed) != e; };
1028         switch (e) {
1029         case TestFunctionEnd:
1030             return waitCondition.wait_for(m, defaultTimeout(), expectationChanged);
1031         case ThreadStart:
1032         case ThreadEnd:
1033         case TestFunctionStart:
1034             waitCondition.wait(m, expectationChanged);
1035             return true;
1036         }
1037         Q_UNREACHABLE();
1038         return false;
1039     }
1040 
1041 public:
1042     WatchDog()
1043     {
1044         setObjectName(QLatin1String("QtTest Watchdog"));
1045         auto locker = qt_unique_lock(mutex);
1046         expecting.store(ThreadStart, std::memory_order_relaxed);
1047         start();
1048         waitFor(locker, ThreadStart);
1049     }
1050     ~WatchDog() {
1051         {
1052             const auto locker = qt_scoped_lock(mutex);
1053             expecting.store(ThreadEnd, std::memory_order_relaxed);
1054             waitCondition.notify_all();
1055         }
1056         wait();
1057     }
1058 
1059     void beginTest() {
1060         const auto locker = qt_scoped_lock(mutex);
1061         expecting.store(TestFunctionEnd, std::memory_order_relaxed);
1062         waitCondition.notify_all();
1063     }
1064 
1065     void testFinished() {
1066         const auto locker = qt_scoped_lock(mutex);
1067         expecting.store(TestFunctionStart, std::memory_order_relaxed);
1068         waitCondition.notify_all();
1069     }
1070 
1071     void run() override {
1072         auto locker = qt_unique_lock(mutex);
1073         expecting.store(TestFunctionStart, std::memory_order_release);
1074         waitCondition.notify_all();
1075         while (true) {
1076             Expectation e = expecting.load(std::memory_order_acquire);
1077             switch (e) {
1078             case ThreadEnd:
1079                 return;
1080             case ThreadStart:
1081                 Q_UNREACHABLE();
1082             case TestFunctionStart:
1083             case TestFunctionEnd:
1084                 if (Q_UNLIKELY(!waitFor(locker, e))) {
1085 #ifndef Q_OS_WASM
1086                     stackTrace();
1087 #endif
1088                     qFatal("Test function timed out");
1089                 }
1090             }
1091         }
1092     }
1093 
1094 private:
1095     QtPrivate::mutex mutex;
1096     QtPrivate::condition_variable waitCondition;
1097     std::atomic<Expectation> expecting;
1098 };
1099 
1100 #else // !QT_CONFIG(thread)
1101 
1102 class WatchDog : public QObject
1103 {
1104 public:
1105     void beginTest() {};
1106     void testFinished() {};
1107 };
1108 
1109 #endif
1110 
1111 
1112 /*!
1113     \internal
1114 
1115     Call slot_data(), init(), slot(), cleanup(), init(), slot(), cleanup(), ...
1116     If data is set then it is the only test that is performed
1117 
1118     If the function was successfully called, true is returned, otherwise
1119     false.
1120  */
1121 bool TestMethods::invokeTest(int index, const char *data, WatchDog *watchDog) const
1122 {
1123     QBenchmarkTestMethodData benchmarkData;
1124     QBenchmarkTestMethodData::current = &benchmarkData;
1125 
1126     const QByteArray &name = m_methods[index].name();
1127     QBenchmarkGlobalData::current->context.slotName = QLatin1String(name) + QLatin1String("()");
1128 
1129     char member[512];
1130     QTestTable table;
1131 
1132     QTestResult::setCurrentTestFunction(name.constData());
1133 
1134     const QTestTable *gTable = QTestTable::globalTestTable();
1135     const int globalDataCount = gTable->dataCount();
1136     int curGlobalDataIndex = 0;
1137 
1138     /* For each entry in the global data table, do: */
1139     do {
1140         if (!gTable->isEmpty())
1141             QTestResult::setCurrentGlobalTestData(gTable->testData(curGlobalDataIndex));
1142 
1143         if (curGlobalDataIndex == 0) {
1144             qsnprintf(member, 512, "%s_data()", name.constData());
1145             invokeMethod(QTest::currentTestObject, member);
1146             if (QTestResult::skipCurrentTest())
1147                 break;
1148         }
1149 
1150         bool foundFunction = false;
1151         int curDataIndex = 0;
1152         const int dataCount = table.dataCount();
1153 
1154         // Data tag requested but none available?
1155         if (data && !dataCount) {
1156             // Let empty data tag through.
1157             if (!*data)
1158                 data = nullptr;
1159             else {
1160                 fprintf(stderr, "Unknown testdata for function %s(): '%s'\n", name.constData(), data);
1161                 fprintf(stderr, "Function has no testdata.\n");
1162                 return false;
1163             }
1164         }
1165 
1166         /* For each entry in this test's data table, do: */
1167         do {
1168             QTestResult::setSkipCurrentTest(false);
1169             QTestResult::setBlacklistCurrentTest(false);
1170             if (!data || !qstrcmp(data, table.testData(curDataIndex)->dataTag())) {
1171                 foundFunction = true;
1172 
1173                 QTestPrivate::checkBlackLists(name.constData(), dataCount ? table.testData(curDataIndex)->dataTag() : nullptr);
1174 
1175                 QTestDataSetter s(curDataIndex >= dataCount ? nullptr : table.testData(curDataIndex));
1176 
1177                 QTestPrivate::qtestMouseButtons = Qt::NoButton;
1178                 if (watchDog)
1179                     watchDog->beginTest();
1180                 QTest::lastMouseTimestamp += 500;   // Maintain at least 500ms mouse event timestamps between each test function call
1181                 invokeTestOnData(index);
1182                 if (watchDog)
1183                     watchDog->testFinished();
1184 
1185                 if (data)
1186                     break;
1187             }
1188             ++curDataIndex;
1189         } while (curDataIndex < dataCount);
1190 
1191         if (data && !foundFunction) {
1192             fprintf(stderr, "Unknown testdata for function %s: '%s()'\n", name.constData(), data);
1193             fprintf(stderr, "Available testdata:\n");
1194             for (int i = 0; i < table.dataCount(); ++i)
1195                 fprintf(stderr, "%s\n", table.testData(i)->dataTag());
1196             return false;
1197         }
1198 
1199         QTestResult::setCurrentGlobalTestData(nullptr);
1200         ++curGlobalDataIndex;
1201     } while (curGlobalDataIndex < globalDataCount);
1202 
1203     QTestResult::finishedCurrentTestFunction();
1204     QTestResult::setSkipCurrentTest(false);
1205     QTestResult::setBlacklistCurrentTest(false);
1206     QTestResult::setCurrentTestData(nullptr);
1207 
1208     return true;
1209 }
1210 
1211 void *fetchData(QTestData *data, const char *tagName, int typeId)
1212 {
1213     QTEST_ASSERT(typeId);
1214     QTEST_ASSERT_X(data, "QTest::fetchData()", "Test data requested, but no testdata available.");
1215     QTEST_ASSERT(data->parent());
1216 
1217     int idx = data->parent()->indexOf(tagName);
1218 
1219     if (Q_UNLIKELY(idx == -1 || idx >= data->dataCount())) {
1220         qFatal("QFETCH: Requested testdata '%s' not available, check your _data function.",
1221                 tagName);
1222     }
1223 
1224     if (Q_UNLIKELY(typeId != data->parent()->elementTypeId(idx))) {
1225         qFatal("Requested type '%s' does not match available type '%s'.",
1226                QMetaType(typeId).name(),
1227                QMetaType(data->parent()->elementTypeId(idx)).name());
1228     }
1229 
1230     return data->data(idx);
1231 }
1232 
1233 /*!
1234  * \internal
1235  */
1236 char *formatString(const char *prefix, const char *suffix, size_t numArguments, ...)
1237 {
1238     va_list ap;
1239     va_start(ap, numArguments);
1240 
1241     QByteArray arguments;
1242     arguments += prefix;
1243 
1244     if (numArguments > 0) {
1245         arguments += va_arg(ap, const char *);
1246 
1247         for (size_t i = 1; i < numArguments; ++i) {
1248             arguments += ", ";
1249             arguments += va_arg(ap, const char *);
1250         }
1251     }
1252 
1253     va_end(ap);
1254     arguments += suffix;
1255     return qstrdup(arguments.constData());
1256 }
1257 
1258 /*!
1259   \fn char* QTest::toHexRepresentation(const char *ba, int length)
1260 
1261   Returns a pointer to a string that is the string \a ba represented
1262   as a space-separated sequence of hex characters. If the input is
1263   considered too long, it is truncated. A trucation is indicated in
1264   the returned string as an ellipsis at the end. The caller has
1265   ownership of the returned pointer and must ensure it is later passed
1266   to operator delete[].
1267 
1268   \a length is the length of the string \a ba.
1269  */
1270 char *toHexRepresentation(const char *ba, int length)
1271 {
1272     if (length == 0)
1273         return qstrdup("");
1274 
1275     /* We output at maximum about maxLen characters in order to avoid
1276      * running out of memory and flooding things when the byte array
1277      * is large.
1278      *
1279      * maxLen can't be for example 200 because Qt Test is sprinkled with fixed
1280      * size char arrays.
1281      * */
1282     const int maxLen = 50;
1283     const int len = qMin(maxLen, length);
1284     char *result = nullptr;
1285 
1286     if (length > maxLen) {
1287         const int size = len * 3 + 4;
1288         result = new char[size];
1289 
1290         char *const forElipsis = result + size - 5;
1291         forElipsis[0] = ' ';
1292         forElipsis[1] = '.';
1293         forElipsis[2] = '.';
1294         forElipsis[3] = '.';
1295         result[size - 1] = '\0';
1296     }
1297     else {
1298         const int size = len * 3;
1299         result = new char[size];
1300         result[size - 1] = '\0';
1301     }
1302 
1303     int i = 0;
1304     int o = 0;
1305 
1306     while (true) {
1307         const char at = ba[i];
1308 
1309         result[o] = toHexUpper(at >> 4);
1310         ++o;
1311         result[o] = toHexUpper(at);
1312 
1313         ++i;
1314         ++o;
1315         if (i == len)
1316             break;
1317         result[o] = ' ';
1318         ++o;
1319     }
1320 
1321     return result;
1322 }
1323 
1324 /*!
1325     \internal
1326     Returns the same QByteArray but with only the ASCII characters still shown;
1327     everything else is replaced with \c {\xHH}.
1328 */
1329 char *toPrettyCString(const char *p, int length)
1330 {
1331     bool trimmed = false;
1332     QScopedArrayPointer<char> buffer(new char[256]);
1333     const char *end = p + length;
1334     char *dst = buffer.data();
1335 
1336     bool lastWasHexEscape = false;
1337     *dst++ = '"';
1338     for ( ; p != end; ++p) {
1339         // we can add:
1340         //  1 byte: a single character
1341         //  2 bytes: a simple escape sequence (\n)
1342         //  3 bytes: "" and a character
1343         //  4 bytes: an hex escape sequence (\xHH)
1344         if (dst - buffer.data() > 246) {
1345             // plus the quote, the three dots and NUL, it's 255 in the worst case
1346             trimmed = true;
1347             break;
1348         }
1349 
1350         // check if we need to insert "" to break an hex escape sequence
1351         if (Q_UNLIKELY(lastWasHexEscape)) {
1352             if (fromHex(*p) != -1) {
1353                 // yes, insert it
1354                 *dst++ = '"';
1355                 *dst++ = '"';
1356             }
1357             lastWasHexEscape = false;
1358         }
1359 
1360         if (*p < 0x7f && *p >= 0x20 && *p != '\\' && *p != '"') {
1361             *dst++ = *p;
1362             continue;
1363         }
1364 
1365         // write as an escape sequence
1366         // this means we may advance dst to buffer.data() + 247 or 250
1367         *dst++ = '\\';
1368         switch (*p) {
1369         case 0x5c:
1370         case 0x22:
1371             *dst++ = uchar(*p);
1372             break;
1373         case 0x8:
1374             *dst++ = 'b';
1375             break;
1376         case 0xc:
1377             *dst++ = 'f';
1378             break;
1379         case 0xa:
1380             *dst++ = 'n';
1381             break;
1382         case 0xd:
1383             *dst++ = 'r';
1384             break;
1385         case 0x9:
1386             *dst++ = 't';
1387             break;
1388         default:
1389             // print as hex escape
1390             *dst++ = 'x';
1391             *dst++ = toHexUpper(uchar(*p) >> 4);
1392             *dst++ = toHexUpper(uchar(*p));
1393             lastWasHexEscape = true;
1394             break;
1395         }
1396     }
1397 
1398     *dst++ = '"';
1399     if (trimmed) {
1400         *dst++ = '.';
1401         *dst++ = '.';
1402         *dst++ = '.';
1403     }
1404     *dst++ = '\0';
1405     return buffer.take();
1406 }
1407 
1408 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
1409 // this used to be the signature up to and including Qt 5.9
1410 // keep it for BC reasons:
1411 Q_TESTLIB_EXPORT
1412 char *toPrettyUnicode(const ushort *p, int length)
1413 {
1414     return toPrettyUnicode(QStringView(p, length));
1415 }
1416 #endif
1417 
1418 /*!
1419     \internal
1420     Returns the same QString but with only the ASCII characters still shown;
1421     everything else is replaced with \c {\uXXXX}.
1422 
1423     Similar to QDebug::putString().
1424 */
1425 char *toPrettyUnicode(QStringView string)
1426 {
1427     auto p = reinterpret_cast<const ushort *>(string.utf16());
1428     auto length = string.size();
1429     // keep it simple for the vast majority of cases
1430     bool trimmed = false;
1431     QScopedArrayPointer<char> buffer(new char[256]);
1432     const ushort *end = p + length;
1433     char *dst = buffer.data();
1434 
1435     *dst++ = '"';
1436     for ( ; p != end; ++p) {
1437         if (dst - buffer.data() > 245) {
1438             // plus the quote, the three dots and NUL, it's 250, 251 or 255
1439             trimmed = true;
1440             break;
1441         }
1442 
1443         if (*p < 0x7f && *p >= 0x20 && *p != '\\' && *p != '"') {
1444             *dst++ = *p;
1445             continue;
1446         }
1447 
1448         // write as an escape sequence
1449         // this means we may advance dst to buffer.data() + 246 or 250
1450         *dst++ = '\\';
1451         switch (*p) {
1452         case 0x22:
1453         case 0x5c:
1454             *dst++ = uchar(*p);
1455             break;
1456         case 0x8:
1457             *dst++ = 'b';
1458             break;
1459         case 0xc:
1460             *dst++ = 'f';
1461             break;
1462         case 0xa:
1463             *dst++ = 'n';
1464             break;
1465         case 0xd:
1466             *dst++ = 'r';
1467             break;
1468         case 0x9:
1469             *dst++ = 't';
1470             break;
1471         default:
1472             *dst++ = 'u';
1473             *dst++ = toHexUpper(*p >> 12);
1474             *dst++ = toHexUpper(*p >> 8);
1475             *dst++ = toHexUpper(*p >> 4);
1476             *dst++ = toHexUpper(*p);
1477         }
1478     }
1479 
1480     *dst++ = '"';
1481     if (trimmed) {
1482         *dst++ = '.';
1483         *dst++ = '.';
1484         *dst++ = '.';
1485     }
1486     *dst++ = '\0';
1487     return buffer.take();
1488 }
1489 
1490 void TestMethods::invokeTests(QObject *testObject) const
1491 {
1492     const QMetaObject *metaObject = testObject->metaObject();
1493     QTEST_ASSERT(metaObject);
1494     QTestResult::setCurrentTestFunction("initTestCase");
1495     if (m_initTestCaseDataMethod.isValid())
1496         m_initTestCaseDataMethod.invoke(testObject, Qt::DirectConnection);
1497 
1498     QScopedPointer<WatchDog> watchDog;
1499     if (!debuggerPresent()
1500 #if QT_CONFIG(valgrind)
1501         && QBenchmarkGlobalData::current->mode() != QBenchmarkGlobalData::CallgrindChildProcess
1502 #endif
1503        ) {
1504         watchDog.reset(new WatchDog);
1505     }
1506 
1507     QSignalDumper::startDump();
1508 
1509     if (!QTestResult::skipCurrentTest() && !QTest::currentTestFailed()) {
1510         if (m_initTestCaseMethod.isValid())
1511             m_initTestCaseMethod.invoke(testObject, Qt::DirectConnection);
1512 
1513         // finishedCurrentTestDataCleanup() resets QTestResult::currentTestFailed(), so use a local copy.
1514         const bool previousFailed = QTestResult::currentTestFailed();
1515         QTestResult::finishedCurrentTestData();
1516         QTestResult::finishedCurrentTestDataCleanup();
1517         QTestResult::finishedCurrentTestFunction();
1518 
1519         if (!QTestResult::skipCurrentTest() && !previousFailed) {
1520             for (int i = 0, count = int(m_methods.size()); i < count; ++i) {
1521                 const char *data = nullptr;
1522                 if (i < QTest::testTags.size() && !QTest::testTags.at(i).isEmpty())
1523                     data = qstrdup(QTest::testTags.at(i).toLatin1().constData());
1524                 const bool ok = invokeTest(i, data, watchDog.data());
1525                 delete [] data;
1526                 if (!ok)
1527                     break;
1528             }
1529         }
1530 
1531         QTestResult::setSkipCurrentTest(false);
1532         QTestResult::setBlacklistCurrentTest(false);
1533         QTestResult::setCurrentTestFunction("cleanupTestCase");
1534         if (m_cleanupTestCaseMethod.isValid())
1535             m_cleanupTestCaseMethod.invoke(testObject, Qt::DirectConnection);
1536         QTestResult::finishedCurrentTestData();
1537         QTestResult::finishedCurrentTestDataCleanup();
1538     }
1539     QTestResult::finishedCurrentTestFunction();
1540     QTestResult::setCurrentTestFunction(nullptr);
1541 
1542     QSignalDumper::endDump();
1543 }
1544 
1545 #if defined(Q_OS_WIN)
1546 
1547 // Helper class for resolving symbol names by dynamically loading "dbghelp.dll".
1548 class DebugSymbolResolver
1549 {
1550     Q_DISABLE_COPY_MOVE(DebugSymbolResolver)
1551 public:
1552     struct Symbol {
1553         Symbol() : name(nullptr), address(0) {}
1554 
1555         const char *name; // Must be freed by caller.
1556         DWORD64 address;
1557     };
1558 
1559     explicit DebugSymbolResolver(HANDLE process);
1560     ~DebugSymbolResolver() { cleanup(); }
1561 
1562     bool isValid() const { return m_symFromAddr; }
1563 
1564     Symbol resolveSymbol(DWORD64 address) const;
1565 
1566 private:
1567     // typedefs from DbgHelp.h/.dll
1568     struct DBGHELP_SYMBOL_INFO { // SYMBOL_INFO
1569         ULONG       SizeOfStruct;
1570         ULONG       TypeIndex;        // Type Index of symbol
1571         ULONG64     Reserved[2];
1572         ULONG       Index;
1573         ULONG       Size;
1574         ULONG64     ModBase;          // Base Address of module comtaining this symbol
1575         ULONG       Flags;
1576         ULONG64     Value;            // Value of symbol, ValuePresent should be 1
1577         ULONG64     Address;          // Address of symbol including base address of module
1578         ULONG       Register;         // register holding value or pointer to value
1579         ULONG       Scope;            // scope of the symbol
1580         ULONG       Tag;              // pdb classification
1581         ULONG       NameLen;          // Actual length of name
1582         ULONG       MaxNameLen;
1583         CHAR        Name[1];          // Name of symbol
1584     };
1585 
1586     typedef BOOL (__stdcall *SymInitializeType)(HANDLE, PCSTR, BOOL);
1587     typedef BOOL (__stdcall *SymFromAddrType)(HANDLE, DWORD64, PDWORD64, DBGHELP_SYMBOL_INFO *);
1588 
1589     void cleanup();
1590 
1591     const HANDLE m_process;
1592     HMODULE m_dbgHelpLib;
1593     SymFromAddrType m_symFromAddr;
1594 };
1595 
1596 void DebugSymbolResolver::cleanup()
1597 {
1598     if (m_dbgHelpLib)
1599         FreeLibrary(m_dbgHelpLib);
1600     m_dbgHelpLib = 0;
1601     m_symFromAddr = nullptr;
1602 }
1603 
1604 DebugSymbolResolver::DebugSymbolResolver(HANDLE process)
1605     : m_process(process), m_dbgHelpLib(0), m_symFromAddr(nullptr)
1606 {
1607     bool success = false;
1608     m_dbgHelpLib = LoadLibraryW(L"dbghelp.dll");
1609     if (m_dbgHelpLib) {
1610         SymInitializeType symInitialize = reinterpret_cast<SymInitializeType>(
1611             reinterpret_cast<QFunctionPointer>(GetProcAddress(m_dbgHelpLib, "SymInitialize")));
1612         m_symFromAddr = reinterpret_cast<SymFromAddrType>(
1613             reinterpret_cast<QFunctionPointer>(GetProcAddress(m_dbgHelpLib, "SymFromAddr")));
1614         success = symInitialize && m_symFromAddr && symInitialize(process, NULL, TRUE);
1615     }
1616     if (!success)
1617         cleanup();
1618 }
1619 
1620 DebugSymbolResolver::Symbol DebugSymbolResolver::resolveSymbol(DWORD64 address) const
1621 {
1622     // reserve additional buffer where SymFromAddr() will store the name
1623     struct NamedSymbolInfo : public DBGHELP_SYMBOL_INFO {
1624         enum { symbolNameLength = 255 };
1625 
1626         char name[symbolNameLength + 1];
1627     };
1628 
1629     Symbol result;
1630     if (!isValid())
1631         return result;
1632     NamedSymbolInfo symbolBuffer;
1633     memset(&symbolBuffer, 0, sizeof(NamedSymbolInfo));
1634     symbolBuffer.MaxNameLen = NamedSymbolInfo::symbolNameLength;
1635     symbolBuffer.SizeOfStruct = sizeof(DBGHELP_SYMBOL_INFO);
1636     if (!m_symFromAddr(m_process, address, 0, &symbolBuffer))
1637         return result;
1638     result.name = qstrdup(symbolBuffer.Name);
1639     result.address = symbolBuffer.Address;
1640     return result;
1641 }
1642 
1643 #endif // Q_OS_WIN
1644 
1645 class FatalSignalHandler
1646 {
1647 public:
1648     FatalSignalHandler()
1649     {
1650 #if defined(Q_OS_WIN)
1651 #  if !defined(Q_CC_MINGW)
1652         _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG);
1653 #  endif
1654         SetErrorMode(SetErrorMode(0) | SEM_NOGPFAULTERRORBOX);
1655         SetUnhandledExceptionFilter(windowsFaultHandler);
1656 #elif defined(Q_OS_UNIX) && !defined(Q_OS_WASM)
1657         sigemptyset(&handledSignals);
1658 
1659         const int fatalSignals[] = {
1660              SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGBUS, SIGFPE, SIGSEGV, SIGPIPE, SIGTERM, 0 };
1661 
1662         struct sigaction act;
1663         memset(&act, 0, sizeof(act));
1664         act.sa_handler = FatalSignalHandler::signal;
1665 
1666         // Remove the handler after it is invoked.
1667 #  if !defined(Q_OS_INTEGRITY)
1668         act.sa_flags = SA_RESETHAND;
1669 #  endif
1670 
1671     // tvOS/watchOS both define SA_ONSTACK (in sys/signal.h) but mark sigaltstack() as
1672     // unavailable (__WATCHOS_PROHIBITED __TVOS_PROHIBITED in signal.h)
1673 #  if defined(SA_ONSTACK) && !defined(Q_OS_TVOS) && !defined(Q_OS_WATCHOS)
1674         // Let the signal handlers use an alternate stack
1675         // This is necessary if SIGSEGV is to catch a stack overflow
1676 #    if defined(Q_CC_GNU) && defined(Q_OF_ELF)
1677         // Put the alternate stack in the .lbss (large BSS) section so that it doesn't
1678         // interfere with normal .bss symbols
1679         __attribute__((section(".lbss.altstack"), aligned(4096)))
1680 #    endif
1681         static char alternate_stack[16 * 1024];
1682         stack_t stack;
1683         stack.ss_flags = 0;
1684         stack.ss_size = sizeof alternate_stack;
1685         stack.ss_sp = alternate_stack;
1686         sigaltstack(&stack, nullptr);
1687         act.sa_flags |= SA_ONSTACK;
1688 #  endif
1689 
1690         // Block all fatal signals in our signal handler so we don't try to close
1691         // the testlog twice.
1692         sigemptyset(&act.sa_mask);
1693         for (int i = 0; fatalSignals[i]; ++i)
1694             sigaddset(&act.sa_mask, fatalSignals[i]);
1695 
1696         struct sigaction oldact;
1697 
1698         for (int i = 0; fatalSignals[i]; ++i) {
1699             sigaction(fatalSignals[i], &act, &oldact);
1700             if (
1701 #  ifdef SA_SIGINFO
1702                 oldact.sa_flags & SA_SIGINFO ||
1703 #  endif
1704                 oldact.sa_handler != SIG_DFL) {
1705                 sigaction(fatalSignals[i], &oldact, nullptr);
1706             } else
1707             {
1708                 sigaddset(&handledSignals, fatalSignals[i]);
1709             }
1710         }
1711 #endif // defined(Q_OS_UNIX) && !defined(Q_OS_WASM)
1712     }
1713 
1714     ~FatalSignalHandler()
1715     {
1716 #if defined(Q_OS_UNIX) && !defined(Q_OS_WASM)
1717         // Unregister any of our remaining signal handlers
1718         struct sigaction act;
1719         memset(&act, 0, sizeof(act));
1720         act.sa_handler = SIG_DFL;
1721 
1722         struct sigaction oldact;
1723 
1724         for (int i = 1; i < 32; ++i) {
1725             if (!sigismember(&handledSignals, i))
1726                 continue;
1727             sigaction(i, &act, &oldact);
1728 
1729             // If someone overwrote it in the mean time, put it back
1730             if (oldact.sa_handler != FatalSignalHandler::signal)
1731                 sigaction(i, &oldact, nullptr);
1732         }
1733 #endif
1734     }
1735 
1736 private:
1737 #if defined(Q_OS_WIN)
1738     static LONG WINAPI windowsFaultHandler(struct _EXCEPTION_POINTERS *exInfo)
1739     {
1740         enum { maxStackFrames = 100 };
1741         char appName[MAX_PATH];
1742         if (!GetModuleFileNameA(NULL, appName, MAX_PATH))
1743             appName[0] = 0;
1744         const int msecsFunctionTime = qRound(QTestLog::msecsFunctionTime());
1745         const int msecsTotalTime = qRound(QTestLog::msecsTotalTime());
1746         const void *exceptionAddress = exInfo->ExceptionRecord->ExceptionAddress;
1747         printf("A crash occurred in %s.\n"
1748                "Function time: %dms Total time: %dms\n\n"
1749                "Exception address: 0x%p\n"
1750                "Exception code   : 0x%lx\n",
1751                appName, msecsFunctionTime, msecsTotalTime,
1752                exceptionAddress, exInfo->ExceptionRecord->ExceptionCode);
1753 
1754         DebugSymbolResolver resolver(GetCurrentProcess());
1755         if (resolver.isValid()) {
1756             DebugSymbolResolver::Symbol exceptionSymbol = resolver.resolveSymbol(DWORD64(exceptionAddress));
1757             if (exceptionSymbol.name) {
1758                 printf("Nearby symbol    : %s\n", exceptionSymbol.name);
1759                 delete [] exceptionSymbol.name;
1760             }
1761             void *stack[maxStackFrames];
1762             fputs("\nStack:\n", stdout);
1763             const unsigned frameCount = CaptureStackBackTrace(0, DWORD(maxStackFrames), stack, NULL);
1764             for (unsigned f = 0; f < frameCount; ++f)     {
1765                 DebugSymbolResolver::Symbol symbol = resolver.resolveSymbol(DWORD64(stack[f]));
1766                 if (symbol.name) {
1767                     printf("#%3u: %s() - 0x%p\n", f + 1, symbol.name, (const void *)symbol.address);
1768                     delete [] symbol.name;
1769                 } else {
1770                     printf("#%3u: Unable to obtain symbol\n", f + 1);
1771                 }
1772             }
1773         }
1774 
1775         fputc('\n', stdout);
1776         fflush(stdout);
1777 
1778         return EXCEPTION_EXECUTE_HANDLER;
1779     }
1780 #endif // defined(Q_OS_WIN)
1781 
1782 #if defined(Q_OS_UNIX) && !defined(Q_OS_WASM)
1783     static void signal(int signum)
1784     {
1785         const int msecsFunctionTime = qRound(QTestLog::msecsFunctionTime());
1786         const int msecsTotalTime = qRound(QTestLog::msecsTotalTime());
1787         if (signum != SIGINT) {
1788             stackTrace();
1789             if (qEnvironmentVariableIsSet("QTEST_PAUSE_ON_CRASH")) {
1790                 fprintf(stderr, "Pausing process %d for debugging\n", getpid());
1791                 raise(SIGSTOP);
1792             }
1793         }
1794         qFatal("Received signal %d\n"
1795                "         Function time: %dms Total time: %dms",
1796                signum, msecsFunctionTime, msecsTotalTime);
1797 #  if defined(Q_OS_INTEGRITY)
1798         {
1799             struct sigaction act;
1800             memset(&act, 0, sizeof(struct sigaction));
1801             act.sa_handler = SIG_DFL;
1802             sigaction(signum, &act, NULL);
1803         }
1804 #  endif
1805     }
1806 
1807     sigset_t handledSignals;
1808 #endif // defined(Q_OS_UNIX) && !defined(Q_OS_WASM)
1809 };
1810 
1811 } // namespace
1812 
1813 static void initEnvironment()
1814 {
1815     qputenv("QT_QTESTLIB_RUNNING", "1");
1816 }
1817 
1818 /*!
1819     Executes tests declared in \a testObject. In addition, the private slots
1820     \c{initTestCase()}, \c{cleanupTestCase()}, \c{init()} and \c{cleanup()}
1821     are executed if they exist. See \l{Creating a Test} for more details.
1822 
1823     Optionally, the command line arguments \a argc and \a argv can be provided.
1824     For a list of recognized arguments, read \l {Qt Test Command Line Arguments}.
1825 
1826     The following example will run all tests in \c MyTestObject:
1827 
1828     \snippet code/src_qtestlib_qtestcase.cpp 18
1829 
1830     This function returns 0 if no tests failed, or a value other than 0 if one
1831     or more tests failed or in case of unhandled exceptions.  (Skipped tests do
1832     not influence the return value.)
1833 
1834     For stand-alone test applications, the convenience macro \l QTEST_MAIN() can
1835     be used to declare a main() function that parses the command line arguments
1836     and executes the tests, avoiding the need to call this function explicitly.
1837 
1838     The return value from this function is also the exit code of the test
1839     application when the \l QTEST_MAIN() macro is used.
1840 
1841     For stand-alone test applications, this function should not be called more
1842     than once, as command-line options for logging test output to files and
1843     executing individual test functions will not behave correctly.
1844 
1845     Note: This function is not reentrant, only one test can run at a time. A
1846     test that was executed with qExec() can't run another test via qExec() and
1847     threads are not allowed to call qExec() simultaneously.
1848 
1849     If you have programatically created the arguments, as opposed to getting them
1850     from the arguments in \c main(), it is likely of interest to use
1851     QTest::qExec(QObject *, const QStringList &) since it is Unicode safe.
1852 
1853     \sa QTEST_MAIN()
1854 */
1855 
1856 int QTest::qExec(QObject *testObject, int argc, char **argv)
1857 {
1858     qInit(testObject, argc, argv);
1859     int ret = qRun();
1860     qCleanup();
1861     return ret;
1862 }
1863 
1864 /*! \internal
1865  */
1866 void QTest::qInit(QObject *testObject, int argc, char **argv)
1867 {
1868     initEnvironment();
1869     QBenchmarkGlobalData::current = new QBenchmarkGlobalData;
1870 
1871 #if defined(Q_OS_MACOS)
1872     // Don't restore saved window state for auto tests
1873     QTestPrivate::disableWindowRestore();
1874 
1875     // Disable App Nap which may cause tests to stall
1876     QTestPrivate::AppNapDisabler appNapDisabler;
1877 
1878     if (qApp && (qstrcmp(qApp->metaObject()->className(), "QApplication") == 0)) {
1879         IOPMAssertionCreateWithName(kIOPMAssertionTypeNoDisplaySleep,
1880             kIOPMAssertionLevelOn, CFSTR("QtTest running tests"),
1881             &macPowerSavingDisabled);
1882     }
1883 #endif
1884 
1885     QTestPrivate::parseBlackList();
1886     QTestResult::reset();
1887 
1888     QTEST_ASSERT(testObject);
1889     QTEST_ASSERT(!currentTestObject);
1890     currentTestObject = testObject;
1891 
1892     const QMetaObject *metaObject = testObject->metaObject();
1893     QTEST_ASSERT(metaObject);
1894 
1895     QTestResult::setCurrentTestObject(metaObject->className());
1896     if (argc > 0)
1897         QTestResult::setCurrentAppName(argv[0]);
1898 
1899     qtest_qParseArgs(argc, argv, false);
1900 
1901     QTestTable::globalTestTable();
1902     QTestLog::startLogging();
1903 }
1904 
1905 /*! \internal
1906  */
1907 int QTest::qRun()
1908 {
1909     QTEST_ASSERT(currentTestObject);
1910 
1911 #if QT_CONFIG(valgrind)
1912     int callgrindChildExitCode = 0;
1913 #endif
1914 
1915 #ifndef QT_NO_EXCEPTIONS
1916     try {
1917 #endif
1918 
1919 #if QT_CONFIG(valgrind)
1920     if (QBenchmarkGlobalData::current->mode() == QBenchmarkGlobalData::CallgrindParentProcess) {
1921         if (Q_UNLIKELY(!qApp))
1922             qFatal("QtTest: -callgrind option is not available with QTEST_APPLESS_MAIN");
1923 
1924         const QStringList origAppArgs(QCoreApplication::arguments());
1925         if (!QBenchmarkValgrindUtils::rerunThroughCallgrind(origAppArgs, callgrindChildExitCode))
1926             return -1;
1927 
1928         QBenchmarkValgrindUtils::cleanup();
1929 
1930     } else
1931 #endif
1932     {
1933         QScopedPointer<FatalSignalHandler> handler;
1934         if (!noCrashHandler)
1935             handler.reset(new FatalSignalHandler);
1936 
1937         TestMethods::MetaMethods commandLineMethods;
1938         commandLineMethods.reserve(static_cast<size_t>(QTest::testFunctions.size()));
1939         for (const QString &tf : qAsConst(QTest::testFunctions)) {
1940                 const QByteArray tfB = tf.toLatin1();
1941                 const QByteArray signature = tfB + QByteArrayLiteral("()");
1942                 QMetaMethod m = TestMethods::findMethod(currentTestObject, signature.constData());
1943                 if (!m.isValid() || !isValidSlot(m)) {
1944                     fprintf(stderr, "Unknown test function: '%s'. Possible matches:\n", tfB.constData());
1945                     qPrintTestSlots(stderr, tfB.constData());
1946                     fprintf(stderr, "\n%s -functions\nlists all available test functions.\n", QTestResult::currentAppName());
1947                     exit(1);
1948                 }
1949                 commandLineMethods.push_back(m);
1950         }
1951         TestMethods test(currentTestObject, std::move(commandLineMethods));
1952         test.invokeTests(currentTestObject);
1953     }
1954 
1955 #ifndef QT_NO_EXCEPTIONS
1956     } catch (...) {
1957         QTestResult::addFailure("Caught unhandled exception", __FILE__, __LINE__);
1958         if (QTestResult::currentTestFunction()) {
1959             QTestResult::finishedCurrentTestFunction();
1960             QTestResult::setCurrentTestFunction(nullptr);
1961         }
1962 
1963         qCleanup();
1964 
1965         // Re-throw exception to make debugging easier
1966         throw;
1967         return 1;
1968     }
1969 #endif
1970 
1971 #if QT_CONFIG(valgrind)
1972     if (QBenchmarkGlobalData::current->mode() == QBenchmarkGlobalData::CallgrindParentProcess)
1973         return callgrindChildExitCode;
1974 #endif
1975     // make sure our exit code is never going above 127
1976     // since that could wrap and indicate 0 test fails
1977     return qMin(QTestLog::failCount(), 127);
1978 }
1979 
1980 /*! \internal
1981  */
1982 void QTest::qCleanup()
1983 {
1984     currentTestObject = nullptr;
1985 
1986     QTestTable::clearGlobalTestTable();
1987     QTestLog::stopLogging();
1988 
1989     delete QBenchmarkGlobalData::current;
1990     QBenchmarkGlobalData::current = nullptr;
1991 
1992 #if defined(Q_OS_MACOS)
1993     IOPMAssertionRelease(macPowerSavingDisabled);
1994 #endif
1995 }
1996 
1997 /*!
1998   \overload
1999   \since 4.4
2000 
2001   Behaves identically to qExec(QObject *, int, char**) but takes a
2002   QStringList of \a arguments instead of a \c char** list.
2003  */
2004 int QTest::qExec(QObject *testObject, const QStringList &arguments)
2005 {
2006     const int argc = arguments.count();
2007     QVarLengthArray<char *> argv(argc);
2008 
2009     QList<QByteArray> args;
2010     args.reserve(argc);
2011 
2012     for (int i = 0; i < argc; ++i)
2013     {
2014         args.append(arguments.at(i).toLocal8Bit().constData());
2015         argv[i] = args.last().data();
2016     }
2017 
2018     return qExec(testObject, argc, argv.data());
2019 }
2020 
2021 /*! \internal
2022  */
2023 void QTest::qFail(const char *message, const char *file, int line)
2024 {
2025     QTestResult::fail(message, file, line);
2026 }
2027 
2028 /*! \internal
2029  */
2030 bool QTest::qVerify(bool statement, const char *statementStr, const char *description,
2031                    const char *file, int line)
2032 {
2033     return QTestResult::verify(statement, statementStr, description, file, line);
2034 }
2035 
2036 /*! \fn void QTest::qSkip(const char *message, const char *file, int line)
2037 \internal
2038  */
2039 void QTest::qSkip(const char *message, const char *file, int line)
2040 {
2041     QTestResult::addSkip(message, file, line);
2042     QTestResult::setSkipCurrentTest(true);
2043 }
2044 
2045 /*! \fn bool QTest::qExpectFail(const char *dataIndex, const char *comment, TestFailMode mode, const char *file, int line)
2046 \internal
2047  */
2048 bool QTest::qExpectFail(const char *dataIndex, const char *comment,
2049                        QTest::TestFailMode mode, const char *file, int line)
2050 {
2051     return QTestResult::expectFail(dataIndex, qstrdup(comment), mode, file, line);
2052 }
2053 
2054 /*! \internal
2055  */
2056 void QTest::qWarn(const char *message, const char *file, int line)
2057 {
2058     QTestLog::warn(message, file, line);
2059 }
2060 
2061 /*!
2062     Ignores messages created by qDebug(), qInfo() or qWarning(). If the \a message
2063     with the corresponding \a type is outputted, it will be removed from the
2064     test log. If the test finished and the \a message was not outputted,
2065     a test failure is appended to the test log.
2066 
2067     \b {Note:} Invoking this function will only ignore one message.
2068     If the message you want to ignore is outputted twice, you have to
2069     call ignoreMessage() twice, too.
2070 
2071     Example:
2072     \snippet code/src_qtestlib_qtestcase.cpp 19
2073 
2074     The example above tests that QDir::mkdir() outputs the right warning when invoked
2075     with an invalid file name.
2076 */
2077 void QTest::ignoreMessage(QtMsgType type, const char *message)
2078 {
2079     QTestLog::ignoreMessage(type, message);
2080 }
2081 
2082 #if QT_CONFIG(regularexpression)
2083 /*!
2084     \overload
2085 
2086     Ignores messages created by qDebug(), qInfo() or qWarning(). If the message
2087     matching \a messagePattern
2088     with the corresponding \a type is outputted, it will be removed from the
2089     test log. If the test finished and the message was not outputted,
2090     a test failure is appended to the test log.
2091 
2092     \b {Note:} Invoking this function will only ignore one message.
2093     If the message you want to ignore is outputted twice, you have to
2094     call ignoreMessage() twice, too.
2095 
2096     \since 5.3
2097 */
2098 void QTest::ignoreMessage(QtMsgType type, const QRegularExpression &messagePattern)
2099 {
2100     QTestLog::ignoreMessage(type, messagePattern);
2101 }
2102 #endif // QT_CONFIG(regularexpression)
2103 
2104 /*! \internal
2105  */
2106 
2107 #ifdef Q_OS_WIN
2108 static inline bool isWindowsBuildDirectory(const QString &dirName)
2109 {
2110     return dirName.compare(QLatin1String("Debug"), Qt::CaseInsensitive) == 0
2111            || dirName.compare(QLatin1String("Release"), Qt::CaseInsensitive) == 0;
2112 }
2113 #endif
2114 
2115 #if QT_CONFIG(temporaryfile)
2116 /*!
2117     Extracts a directory from resources to disk. The content is extracted
2118     recursively to a temporary folder. The extracted content is removed
2119     automatically once the last reference to the return value goes out of scope.
2120 
2121     \a dirName is the name of the directory to extract from resources.
2122 
2123     Returns the temporary directory where the data was extracted or null in case of
2124     errors.
2125  */
2126 QSharedPointer<QTemporaryDir> QTest::qExtractTestData(const QString &dirName)
2127 {
2128       QSharedPointer<QTemporaryDir> result; // null until success, then == tempDir
2129 
2130       QSharedPointer<QTemporaryDir> tempDir = QSharedPointer<QTemporaryDir>::create();
2131 
2132       tempDir->setAutoRemove(true);
2133 
2134       if (!tempDir->isValid())
2135           return result;
2136 
2137       const QString dataPath = tempDir->path();
2138       const QString resourcePath = QLatin1Char(':') + dirName;
2139       const QFileInfo fileInfo(resourcePath);
2140 
2141       if (!fileInfo.isDir()) {
2142           qWarning("Resource path '%s' is not a directory.", qPrintable(resourcePath));
2143           return result;
2144       }
2145 
2146       QDirIterator it(resourcePath, QDirIterator::Subdirectories);
2147       if (!it.hasNext()) {
2148           qWarning("Resource directory '%s' is empty.", qPrintable(resourcePath));
2149           return result;
2150       }
2151 
2152       while (it.hasNext()) {
2153           it.next();
2154 
2155           QFileInfo fileInfo = it.fileInfo();
2156 
2157           if (!fileInfo.isDir()) {
2158               const QString destination = dataPath + QLatin1Char('/') + QStringView{fileInfo.filePath()}.mid(resourcePath.length());
2159               QFileInfo destinationFileInfo(destination);
2160               QDir().mkpath(destinationFileInfo.path());
2161               if (!QFile::copy(fileInfo.filePath(), destination)) {
2162                   qWarning("Failed to copy '%s'.", qPrintable(fileInfo.filePath()));
2163                   return result;
2164               }
2165               if (!QFile::setPermissions(destination, QFile::ReadUser | QFile::WriteUser | QFile::ReadGroup)) {
2166                   qWarning("Failed to set permissions on '%s'.", qPrintable(destination));
2167                   return result;
2168               }
2169           }
2170       }
2171 
2172       result = std::move(tempDir);
2173 
2174       return result;
2175 }
2176 #endif // QT_CONFIG(temporaryfile)
2177 
2178 /*! \internal
2179  */
2180 
2181 QString QTest::qFindTestData(const QString& base, const char *file, int line, const char *builddir,
2182                              const char *sourcedir)
2183 {
2184     QString found;
2185 
2186     // Testdata priorities:
2187 
2188     //  1. relative to test binary.
2189     if (qApp) {
2190         QDir binDirectory(QCoreApplication::applicationDirPath());
2191         if (binDirectory.exists(base)) {
2192             found = binDirectory.absoluteFilePath(base);
2193         }
2194 #ifdef Q_OS_WIN
2195         // Windows: The executable is typically located in one of the
2196         // 'Release' or 'Debug' directories.
2197         else if (isWindowsBuildDirectory(binDirectory.dirName())
2198                  && binDirectory.cdUp() && binDirectory.exists(base)) {
2199             found = binDirectory.absoluteFilePath(base);
2200         }
2201 #endif // Q_OS_WIN
2202         else if (QTestLog::verboseLevel() >= 2) {
2203             const QString candidate = QDir::toNativeSeparators(QCoreApplication::applicationDirPath() + QLatin1Char('/') + base);
2204             QTestLog::info(qPrintable(
2205                 QString::fromLatin1("testdata %1 not found relative to test binary [%2]; "
2206                                     "checking next location").arg(base, candidate)),
2207                 file, line);
2208         }
2209     }
2210 
2211     //  2. installed path.
2212     if (found.isEmpty()) {
2213         const char *testObjectName = QTestResult::currentTestObjectName();
2214         if (testObjectName) {
2215             const QString testsPath = QLibraryInfo::path(QLibraryInfo::TestsPath);
2216             const QString candidate = QString::fromLatin1("%1/%2/%3")
2217                 .arg(testsPath, QFile::decodeName(testObjectName).toLower(), base);
2218             if (QFileInfo::exists(candidate)) {
2219                 found = candidate;
2220             } else if (QTestLog::verboseLevel() >= 2) {
2221                 QTestLog::info(qPrintable(
2222                     QString::fromLatin1("testdata %1 not found in tests install path [%2]; "
2223                                         "checking next location")
2224                         .arg(base, QDir::toNativeSeparators(candidate))),
2225                     file, line);
2226             }
2227         }
2228     }
2229 
2230     //  3. relative to test source.
2231     if (found.isEmpty() && qstrncmp(file, ":/", 2) != 0) {
2232         // srcdir is the directory containing the calling source file.
2233         QFileInfo srcdir(QFileInfo(QFile::decodeName(file)).path());
2234 
2235         // If the srcdir is relative, that means it is relative to the current working
2236         // directory of the compiler at compile time, which should be passed in as `builddir'.
2237         if (!srcdir.isAbsolute() && builddir) {
2238             srcdir.setFile(QFile::decodeName(builddir) + QLatin1String("/") + srcdir.filePath());
2239         }
2240 
2241         const QString canonicalPath = srcdir.canonicalFilePath();
2242         const QString candidate = QString::fromLatin1("%1/%2").arg(canonicalPath, base);
2243         if (!canonicalPath.isEmpty() && QFileInfo::exists(candidate)) {
2244             found = candidate;
2245         } else if (QTestLog::verboseLevel() >= 2) {
2246             QTestLog::info(qPrintable(
2247                 QString::fromLatin1("testdata %1 not found relative to source path [%2]")
2248                     .arg(base, QDir::toNativeSeparators(candidate))),
2249                 file, line);
2250         }
2251     }
2252 
2253     // 4. Try resources
2254     if (found.isEmpty()) {
2255         const QString candidate = QString::fromLatin1(":/%1").arg(base);
2256         if (QFileInfo::exists(candidate)) {
2257             found = candidate;
2258         } else if (QTestLog::verboseLevel() >= 2) {
2259             QTestLog::info(qPrintable(
2260                 QString::fromLatin1("testdata %1 not found in resources [%2]")
2261                     .arg(base, QDir::toNativeSeparators(candidate))),
2262                 file, line);
2263         }
2264     }
2265 
2266     // 5. Try current directory
2267     if (found.isEmpty()) {
2268         const QString candidate = QDir::currentPath() + QLatin1Char('/') + base;
2269         if (QFileInfo::exists(candidate)) {
2270             found = candidate;
2271         } else if (QTestLog::verboseLevel() >= 2) {
2272             QTestLog::info(qPrintable(
2273                 QString::fromLatin1("testdata %1 not found in current directory [%2]")
2274                     .arg(base, QDir::toNativeSeparators(candidate))),
2275                 file, line);
2276         }
2277     }
2278 
2279     // 6. Try main source directory
2280     if (found.isEmpty()) {
2281         const QString candidate = QTest::mainSourcePath % QLatin1Char('/') % base;
2282         if (QFileInfo::exists(candidate)) {
2283             found = candidate;
2284         } else if (QTestLog::verboseLevel() >= 2) {
2285             QTestLog::info(qPrintable(
2286                 QString::fromLatin1("testdata %1 not found in main source directory [%2]")
2287                     .arg(base, QDir::toNativeSeparators(candidate))),
2288                 file, line);
2289         }
2290     }
2291 
2292     // 7. Try the supplied source directory
2293     if (found.isEmpty() && sourcedir) {
2294         const QString candidate = QFile::decodeName(sourcedir) % QLatin1Char('/') % base;
2295         if (QFileInfo::exists(candidate)) {
2296             found = candidate;
2297         } else if (QTestLog::verboseLevel() >= 2) {
2298             QTestLog::info(qPrintable(
2299                 QString::fromLatin1("testdata %1 not found in supplied source directory [%2]")
2300                     .arg(base, QDir::toNativeSeparators(candidate))),
2301                 file, line);
2302         }
2303     }
2304 
2305 
2306     if (found.isEmpty()) {
2307         QTest::qWarn(qPrintable(
2308             QString::fromLatin1("testdata %1 could not be located!").arg(base)),
2309             file, line);
2310     } else if (QTestLog::verboseLevel() >= 1) {
2311         QTestLog::info(qPrintable(
2312             QString::fromLatin1("testdata %1 was located at %2").arg(base, QDir::toNativeSeparators(found))),
2313             file, line);
2314     }
2315 
2316     return found;
2317 }
2318 
2319 /*! \internal
2320  */
2321 QString QTest::qFindTestData(const char *base, const char *file, int line, const char *builddir,
2322                              const char *sourcedir)
2323 {
2324     return qFindTestData(QFile::decodeName(base), file, line, builddir, sourcedir);
2325 }
2326 
2327 /*! \internal
2328  */
2329 void *QTest::qData(const char *tagName, int typeId)
2330 {
2331     return fetchData(QTestResult::currentTestData(), tagName, typeId);
2332 }
2333 
2334 /*! \internal
2335  */
2336 void *QTest::qGlobalData(const char *tagName, int typeId)
2337 {
2338     return fetchData(QTestResult::currentGlobalTestData(), tagName, typeId);
2339 }
2340 
2341 /*! \internal
2342  */
2343 void *QTest::qElementData(const char *tagName, int metaTypeId)
2344 {
2345     QTEST_ASSERT(tagName);
2346     QTestData *data = QTestResult::currentTestData();
2347     QTEST_ASSERT(data);
2348     QTEST_ASSERT(data->parent());
2349 
2350     int idx = data->parent()->indexOf(tagName);
2351     QTEST_ASSERT(idx != -1);
2352     QTEST_ASSERT(data->parent()->elementTypeId(idx) == metaTypeId);
2353 
2354     return data->data(data->parent()->indexOf(tagName));
2355 }
2356 
2357 /*! \internal
2358  */
2359 void QTest::addColumnInternal(int id, const char *name)
2360 {
2361     QTestTable *tbl = QTestTable::currentTestTable();
2362     QTEST_ASSERT_X(tbl, "QTest::addColumn()", "Cannot add testdata outside of a _data slot.");
2363 
2364     tbl->addColumn(id, name);
2365 }
2366 
2367 /*!
2368     Appends a new row to the current test data. \a dataTag is the name of
2369     the testdata that will appear in the test output. Returns a QTestData reference
2370     that can be used to stream in data.
2371 
2372     Example:
2373     \snippet code/src_qtestlib_qtestcase.cpp 20
2374 
2375     \b {Note:} This macro can only be used in a test's data function
2376     that is invoked by the test framework.
2377 
2378     See \l {Chapter 2: Data Driven Testing}{Data Driven Testing} for
2379     a more extensive example.
2380 
2381     \sa addColumn(), QFETCH()
2382 */
2383 QTestData &QTest::newRow(const char *dataTag)
2384 {
2385     QTEST_ASSERT_X(dataTag, "QTest::newRow()", "Data tag cannot be null");
2386     QTestTable *tbl = QTestTable::currentTestTable();
2387     QTEST_ASSERT_X(tbl, "QTest::newRow()", "Cannot add testdata outside of a _data slot.");
2388     QTEST_ASSERT_X(tbl->elementCount(), "QTest::newRow()", "Must add columns before attempting to add rows.");
2389 
2390     return *tbl->newData(dataTag);
2391 }
2392 
2393 /*!
2394     \since 5.9
2395 
2396     Appends a new row to the current test data. The function's arguments are passed
2397     to qsnprintf() for formatting according to \a format. See the qvsnprintf()
2398     documentation for caveats and limitations.
2399 
2400     The formatted string will appear as the name of this test data in the test output.
2401 
2402     Returns a QTestData reference that can be used to stream in data.
2403 
2404     Example:
2405     \snippet code/src_qtestlib_qtestcase.cpp addRow
2406 
2407     \b {Note:} This function can only be used in a test's data function
2408     that is invoked by the test framework.
2409 
2410     See \l {Chapter 2: Data Driven Testing}{Data Driven Testing} for
2411     a more extensive example.
2412 
2413     \sa addColumn(), QFETCH()
2414 */
2415 QTestData &QTest::addRow(const char *format, ...)
2416 {
2417     QTEST_ASSERT_X(format, "QTest::addRow()", "Format string cannot be null");
2418     QTestTable *tbl = QTestTable::currentTestTable();
2419     QTEST_ASSERT_X(tbl, "QTest::addRow()", "Cannot add testdata outside of a _data slot.");
2420     QTEST_ASSERT_X(tbl->elementCount(), "QTest::addRow()", "Must add columns before attempting to add rows.");
2421 
2422     char buf[1024];
2423 
2424     va_list va;
2425     va_start(va, format);
2426     // we don't care about failures, we accept truncation, as well as trailing garbage.
2427     // Names with more than 1K characters are nonsense, anyway.
2428     (void)qvsnprintf(buf, sizeof buf, format, va);
2429     buf[sizeof buf - 1] = '\0';
2430     va_end(va);
2431 
2432     return *tbl->newData(buf);
2433 }
2434 
2435 /*! \fn template <typename T> void QTest::addColumn(const char *name, T *dummy = 0)
2436 
2437     Adds a column with type \c{T} to the current test data.
2438     \a name is the name of the column. \a dummy is a workaround
2439     for buggy compilers and can be ignored.
2440 
2441     To populate the column with values, newRow() can be used. Use
2442     \l QFETCH() to fetch the data in the actual test.
2443 
2444     Example:
2445     \snippet code/src_qtestlib_qtestcase.cpp 21
2446 
2447     To add custom types to the testdata, the type must be registered with
2448     QMetaType via \l Q_DECLARE_METATYPE().
2449 
2450     \b {Note:} This macro can only be used in a test's data function
2451     that is invoked by the test framework.
2452 
2453     See \l {Chapter 2: Data Driven Testing}{Data Driven Testing} for
2454     a more extensive example.
2455 
2456     \sa QTest::newRow(), QFETCH(), QMetaType
2457 */
2458 
2459 /*!
2460     Returns the name of the binary that is currently executed.
2461 */
2462 const char *QTest::currentAppName()
2463 {
2464     return QTestResult::currentAppName();
2465 }
2466 
2467 /*!
2468     Returns the name of the test function that is currently executed.
2469 
2470     Example:
2471 
2472     \snippet code/src_qtestlib_qtestcase.cpp 22
2473 */
2474 const char *QTest::currentTestFunction()
2475 {
2476     return QTestResult::currentTestFunction();
2477 }
2478 
2479 /*!
2480     Returns the name of the current test data. If the test doesn't
2481     have any assigned testdata, the function returns 0.
2482 */
2483 const char *QTest::currentDataTag()
2484 {
2485     return QTestResult::currentDataTag();
2486 }
2487 
2488 /*!
2489     Returns \c true if the current test function failed, otherwise false.
2490 */
2491 bool QTest::currentTestFailed()
2492 {
2493     return QTestResult::currentTestFailed();
2494 }
2495 
2496 /*! \internal
2497  */
2498 QObject *QTest::testObject()
2499 {
2500     return currentTestObject;
2501 }
2502 
2503 /*! \internal
2504  */
2505 void QTest::setMainSourcePath(const char *file, const char *builddir)
2506 {
2507     QString mainSourceFile = QFile::decodeName(file);
2508     QFileInfo fi;
2509     if (builddir)
2510         fi.setFile(QDir(QFile::decodeName(builddir)), mainSourceFile);
2511     else
2512         fi.setFile(mainSourceFile);
2513     QTest::mainSourcePath = fi.absolutePath();
2514 }
2515 
2516 /*! \internal
2517     This function is called by various specializations of QTest::qCompare
2518     to decide whether to report a failure and to produce verbose test output.
2519 
2520     The failureMsg parameter can be null, in which case a default message
2521     will be output if the compare fails.  If the compare succeeds, failureMsg
2522     will not be output.
2523 
2524     If the caller has already passed a failure message showing the compared
2525     values, or if those values cannot be stringified, val1 and val2 can be null.
2526  */
2527 bool QTest::compare_helper(bool success, const char *failureMsg,
2528                            char *val1, char *val2,
2529                            const char *actual, const char *expected,
2530                            const char *file, int line)
2531 {
2532     return QTestResult::compare(success, failureMsg, val1, val2, actual, expected, file, line);
2533 }
2534 
2535 template <typename T>
2536 static bool floatingCompare(const T &actual, const T &expected)
2537 {
2538     switch (qFpClassify(expected))
2539     {
2540     case FP_INFINITE:
2541         return (expected < 0) == (actual < 0) && qFpClassify(actual) == FP_INFINITE;
2542     case FP_NAN:
2543         return qFpClassify(actual) == FP_NAN;
2544     default:
2545         if (!qFuzzyIsNull(expected))
2546             return qFuzzyCompare(actual, expected);
2547         Q_FALLTHROUGH();
2548     case FP_SUBNORMAL: // subnormal is always fuzzily null
2549     case FP_ZERO:
2550         return qFuzzyIsNull(actual);
2551     }
2552 }
2553 
2554 /*! \fn bool QTest::qCompare(const qfloat16 &t1, const qfloat16 &t2, const char *actual, const char *expected, const char *file, int line)
2555     \internal
2556  */
2557 bool QTest::qCompare(qfloat16 const &t1, qfloat16 const &t2, const char *actual, const char *expected,
2558                      const char *file, int line)
2559 {
2560     return compare_helper(floatingCompare(t1, t2),
2561                           "Compared qfloat16s are not the same (fuzzy compare)",
2562                           toString(t1), toString(t2), actual, expected, file, line);
2563 }
2564 
2565 /*! \fn bool QTest::qCompare(const float &t1, const float &t2, const char *actual, const char *expected, const char *file, int line)
2566     \internal
2567  */
2568 bool QTest::qCompare(float const &t1, float const &t2, const char *actual, const char *expected,
2569                     const char *file, int line)
2570 {
2571     return QTestResult::compare(floatingCompare(t1, t2),
2572                                 "Compared floats are not the same (fuzzy compare)",
2573                                 t1, t2, actual, expected, file, line);
2574 }
2575 
2576 /*! \fn bool QTest::qCompare(const double &t1, const double &t2, const char *actual, const char *expected, const char *file, int line)
2577     \internal
2578  */
2579 bool QTest::qCompare(double const &t1, double const &t2, const char *actual, const char *expected,
2580                     const char *file, int line)
2581 {
2582     return QTestResult::compare(floatingCompare(t1, t2),
2583                                 "Compared doubles are not the same (fuzzy compare)",
2584                                 t1, t2, actual, expected, file, line);
2585 }
2586 
2587 /*! \fn bool QTest::qCompare(int t1, int t2, const char *actual, const char *expected, const char *file, int line)
2588     \internal
2589     \since 5.14
2590  */
2591 bool QTest::qCompare(int t1, int t2, const char *actual, const char *expected,
2592                     const char *file, int line)
2593 {
2594     return QTestResult::compare(t1 == t2,
2595                                 "Compared values are not the same",
2596                                 t1, t2, actual, expected, file, line);
2597 }
2598 
2599 #if QT_POINTER_SIZE == 8
2600 /*! \fn bool QTest::qCompare(qsizetype t1, qsizetype t2, const char *actual, const char *expected, const char *file, int line)
2601     \internal
2602     \since 6.0
2603  */
2604 
2605 bool QTest::qCompare(qsizetype t1, qsizetype t2, const char *actual, const char *expected,
2606                      const char *file, int line)
2607 {
2608     return QTestResult::compare(t1 == t2,
2609                                 "Compared values are not the same",
2610                                 t1, t2, actual, expected, file, line);
2611 }
2612 #endif // QT_POINTER_SIZE == 8
2613 
2614 /*! \fn bool QTest::qCompare(unsigned t1, unsigned t2, const char *actual, const char *expected, const char *file, int line)
2615     \internal
2616     \since 5.14
2617  */
2618 bool QTest::qCompare(unsigned t1, unsigned t2, const char *actual, const char *expected,
2619                     const char *file, int line)
2620 {
2621     return QTestResult::compare(t1 == t2,
2622                                 "Compared values are not the same",
2623                                 t1, t2, actual, expected, file, line);
2624 }
2625 
2626 /*! \fn bool QTest::qCompare(QStringView t1, QStringView t2, const char *actual, const char *expected, const char *file, int line)
2627     \internal
2628     \since 5.14
2629  */
2630 bool QTest::qCompare(QStringView t1, QStringView t2, const char *actual, const char *expected,
2631                      const char *file, int line)
2632 {
2633     return QTestResult::compare(t1 == t2,
2634                                 "Compared values are not the same",
2635                                 t1, t2, actual, expected, file, line);
2636 }
2637 
2638 /*! \fn bool QTest::qCompare(QStringView t1, const QLatin1String &t2, const char *actual, const char *expected, const char *file, int line)
2639     \internal
2640     \since 5.14
2641  */
2642 bool QTest::qCompare(QStringView t1, const QLatin1String &t2, const char *actual, const char *expected,
2643                      const char *file, int line)
2644 {
2645     return QTestResult::compare(t1 == t2,
2646                                 "Compared values are not the same",
2647                                 t1, t2, actual, expected, file, line);
2648 }
2649 
2650 /*! \fn bool QTest::qCompare(const QLatin1String &t1, QStringView t2, const char *actual, const char *expected, const char *file, int line)
2651     \internal
2652     \since 5.14
2653  */
2654 bool QTest::qCompare(const QLatin1String &t1, QStringView t2, const char *actual, const char *expected,
2655                      const char *file, int line)
2656 {
2657     return QTestResult::compare(t1 == t2,
2658                                 "Compared values are not the same",
2659                                 t1, t2, actual, expected, file, line);
2660 }
2661 
2662 /*! \fn bool QTest::qCompare(const QString &t1, const QString &t2, const char *actual, const char *expected, const char *file, int line)
2663     \internal
2664     \since 5.14
2665  */
2666 
2667 /*! \fn bool QTest::qCompare(const QString &t1, const QLatin1String &t2, const char *actual, const char *expected, const char *file, int line)
2668     \internal
2669     \since 5.14
2670  */
2671 
2672 /*! \fn bool QTest::qCompare(const QLatin1String &t1, const QString &t2, const char *actual, const char *expected, const char *file, int line)
2673     \internal
2674     \since 5.14
2675  */
2676 
2677 /*! \fn bool QTest::qCompare(const double &t1, const float &t2, const char *actual, const char *expected, const char *file, int line)
2678     \internal
2679  */
2680 
2681 /*! \fn bool QTest::qCompare(const float &t1, const double &t2, const char *actual, const char *expected, const char *file, int line)
2682     \internal
2683  */
2684 
2685 #define TO_STRING_IMPL(TYPE, FORMAT) \
2686 template <> Q_TESTLIB_EXPORT char *QTest::toString<TYPE>(const TYPE &t) \
2687 { \
2688     char *msg = new char[128]; \
2689     qsnprintf(msg, 128, #FORMAT, t); \
2690     return msg; \
2691 }
2692 
2693 TO_STRING_IMPL(short, %hd)
2694 TO_STRING_IMPL(ushort, %hu)
2695 TO_STRING_IMPL(int, %d)
2696 TO_STRING_IMPL(uint, %u)
2697 TO_STRING_IMPL(long, %ld)
2698 TO_STRING_IMPL(ulong, %lu)
2699 #if defined(Q_OS_WIN)
2700 TO_STRING_IMPL(qint64, %I64d)
2701 TO_STRING_IMPL(quint64, %I64u)
2702 #else
2703 TO_STRING_IMPL(qint64, %lld)
2704 TO_STRING_IMPL(quint64, %llu)
2705 #endif
2706 TO_STRING_IMPL(bool, %d)
2707 TO_STRING_IMPL(signed char, %hhd)
2708 TO_STRING_IMPL(unsigned char, %hhu)
2709 
2710 /*!
2711   \internal
2712 
2713   Be consistent about leading 0 in exponent.
2714 
2715   POSIX specifies that %e (hence %g when using it) uses at least two digits in
2716   the exponent, requiring a leading 0 on single-digit exponents; (at least)
2717   MinGW includes a leading zero also on an already-two-digit exponent,
2718   e.g. 9e-040, which differs from more usual platforms.  So massage that away.
2719  */
2720 static void massageExponent(char *text)
2721 {
2722     char *p = strchr(text, 'e');
2723     if (!p)
2724         return;
2725     const char *const end = p + strlen(p); // *end is '\0'
2726     p += (p[1] == '-' || p[1] == '+') ? 2 : 1;
2727     if (p[0] != '0' || end - 2 <= p)
2728         return;
2729     // We have a leading 0 on an exponent of at least two more digits
2730     const char *n = p + 1;
2731     while (end - 2 > n && n[0] == '0')
2732         ++n;
2733     memmove(p, n, end + 1 - n);
2734 }
2735 
2736 // Be consistent about display of infinities and NaNs (snprintf()'s varies,
2737 // notably on MinGW, despite POSIX documenting "[-]inf" or "[-]infinity" for %f,
2738 // %e and %g, uppercasing for their capital versions; similar for "nan"):
2739 #define TO_STRING_FLOAT(TYPE, FORMAT) \
2740 template <> Q_TESTLIB_EXPORT char *QTest::toString<TYPE>(const TYPE &t) \
2741 { \
2742     char *msg = new char[128]; \
2743     switch (qFpClassify(t)) { \
2744     case FP_INFINITE: \
2745         qstrncpy(msg, (t < 0 ? "-inf" : "inf"), 128); \
2746         break; \
2747     case FP_NAN: \
2748         qstrncpy(msg, "nan", 128); \
2749         break; \
2750     default: \
2751         qsnprintf(msg, 128, #FORMAT, double(t));    \
2752         massageExponent(msg); \
2753         break; \
2754     } \
2755     return msg; \
2756 }
2757 
2758 TO_STRING_FLOAT(qfloat16, %.3g)
2759 TO_STRING_FLOAT(float, %g)
2760 TO_STRING_FLOAT(double, %.12g)
2761 
2762 template <> Q_TESTLIB_EXPORT char *QTest::toString<char>(const char &t)
2763 {
2764     unsigned char c = static_cast<unsigned char>(t);
2765     char *msg = new char[16];
2766     switch (c) {
2767     case 0x00:
2768         qstrcpy(msg, "'\\0'");
2769         break;
2770     case 0x07:
2771         qstrcpy(msg, "'\\a'");
2772         break;
2773     case 0x08:
2774         qstrcpy(msg, "'\\b'");
2775         break;
2776     case 0x09:
2777         qstrcpy(msg, "'\\t'");
2778         break;
2779     case 0x0a:
2780         qstrcpy(msg, "'\\n'");
2781         break;
2782     case 0x0b:
2783         qstrcpy(msg, "'\\v'");
2784         break;
2785     case 0x0c:
2786         qstrcpy(msg, "'\\f'");
2787         break;
2788     case 0x0d:
2789         qstrcpy(msg, "'\\r'");
2790         break;
2791     case 0x22:
2792         qstrcpy(msg, "'\\\"'");
2793         break;
2794     case 0x27:
2795         qstrcpy(msg, "'\\\''");
2796         break;
2797     case 0x5c:
2798         qstrcpy(msg, "'\\\\'");
2799         break;
2800     default:
2801         if (c < 0x20 || c >= 0x7F)
2802             qsnprintf(msg, 16, "'\\x%02x'", c);
2803         else
2804             qsnprintf(msg, 16, "'%c'" , c);
2805     }
2806     return msg;
2807 }
2808 
2809 /*! \internal
2810  */
2811 char *QTest::toString(const char *str)
2812 {
2813     if (!str) {
2814         char *msg = new char[1];
2815         *msg = '\0';
2816         return msg;
2817     }
2818     char *msg = new char[strlen(str) + 1];
2819     return qstrcpy(msg, str);
2820 }
2821 
2822 /*! \internal
2823  */
2824 char *QTest::toString(const volatile void *p) // Use volatile to match compare_ptr_helper()
2825 {
2826     return QTest::toString(const_cast<const void *>(p));
2827 }
2828 
2829 char *QTest::toString(const void *p)
2830 {
2831     char *msg = new char[128];
2832     qsnprintf(msg, 128, "%p", p);
2833     return msg;
2834 }
2835 
2836 /*! \internal
2837  */
2838 char *QTest::toString(const volatile QObject *vo)
2839 {
2840     if (vo == nullptr)
2841         return qstrdup("<null>");
2842 
2843     auto *o = const_cast<const QObject*>(vo);
2844     const QString &name = o->objectName();
2845     const char *className = o->metaObject()->className();
2846     char *msg = new char[256];
2847     if (name.isEmpty())
2848         qsnprintf(msg, 256, "%s/%p", className, o);
2849     else
2850         qsnprintf(msg, 256, "%s/\"%s\"", className, qPrintable(name));
2851     return msg;
2852 }
2853 
2854 /*! \fn char *QTest::toString(const QColor &color)
2855     \internal
2856  */
2857 
2858 /*! \fn char *QTest::toString(const QRegion &region)
2859     \internal
2860  */
2861 
2862 /*! \fn char *QTest::toString(const QHostAddress &addr)
2863     \internal
2864  */
2865 
2866 /*! \fn char *QTest::toString(QNetworkReply::NetworkError code)
2867     \internal
2868  */
2869 
2870 /*! \fn char *QTest::toString(const QNetworkCookie &cookie)
2871     \internal
2872  */
2873 
2874 /*! \fn char *QTest::toString(const QList<QNetworkCookie> &list)
2875     \internal
2876  */
2877 
2878 /*! \internal
2879  */
2880 bool QTest::compare_string_helper(const char *t1, const char *t2, const char *actual,
2881                                   const char *expected, const char *file, int line)
2882 {
2883     return compare_helper(qstrcmp(t1, t2) == 0, "Compared strings are not the same",
2884                           toString(t1), toString(t2), actual, expected, file, line);
2885 }
2886 
2887 /*!
2888    \namespace QTest::Internal
2889    \internal
2890 */
2891 
2892 /*! \fn bool QTest::compare_ptr_helper(const volatile void *t1, const volatile void *t2, const char *actual, const char *expected, const char *file, int line)
2893     \internal
2894 */
2895 
2896 /*! \fn bool QTest::compare_ptr_helper(const volatile void *t1, std::nullptr_t, const char *actual, const char *expected, const char *file, int line)
2897     \internal
2898 */
2899 
2900 /*! \fn bool QTest::compare_ptr_helper(std::nullptr_t, const volatile void *t2, const char *actual, const char *expected, const char *file, int line)
2901     \internal
2902 */
2903 
2904 /*! \fn template <typename T1, typename T2> bool QTest::qCompare(const T1 &t1, const T2 &t2, const char *actual, const char *expected, const char *file, int line)
2905     \internal
2906 */
2907 
2908 /*! \fn bool QTest::qCompare(const QIcon &t1, const QIcon &t2, const char *actual, const char *expected, const char *file, int line)
2909     \internal
2910 */
2911 
2912 /*! \fn bool QTest::qCompare(const QImage &t1, const QImage &t2, const char *actual, const char *expected, const char *file, int line)
2913     \internal
2914 */
2915 
2916 /*! \fn bool QTest::qCompare(const QPixmap &t1, const QPixmap &t2, const char *actual, const char *expected, const char *file, int line)
2917     \internal
2918 */
2919 
2920 /*! \fn template <typename T> bool QTest::qCompare(const T &t1, const T &t2, const char *actual, const char *expected, const char *file, int line)
2921     \internal
2922 */
2923 
2924 /*! \fn template <typename T> bool QTest::qCompare(const T *t1, const T *t2, const char *actual, const char *expected, const char *file, int line)
2925     \internal
2926 */
2927 
2928 /*! \fn template <typename T> bool QTest::qCompare(T *t, std::nullptr_t, const char *actual, const char *expected, const char *file, int line)
2929     \internal
2930 */
2931 
2932 /*! \fn template <typename T> bool QTest::qCompare(std::nullptr_t, T *t, const char *actual, const char *expected, const char *file, int line)
2933     \internal
2934 */
2935 
2936 /*! \fn template <typename T> bool QTest::qCompare(T *t1, T *t2, const char *actual, const char *expected, const char *file, int line)
2937     \internal
2938 */
2939 
2940 /*! \fn template <typename T1, typename T2> bool QTest::qCompare(const T1 *t1, const T2 *t2, const char *actual, const char *expected, const char *file, int line)
2941     \internal
2942 */
2943 
2944 /*! \fn template <typename T1, typename T2> bool QTest::qCompare(T1 *t1, T2 *t2, const char *actual, const char *expected, const char *file, int line)
2945     \internal
2946 */
2947 
2948 /*! \fn bool QTest::qCompare(const char *t1, const char *t2, const char *actual, const char *expected, const char *file, int line)
2949     \internal
2950 */
2951 
2952 /*! \fn bool QTest::qCompare(char *t1, char *t2, const char *actual, const char *expected, const char *file, int line)
2953     \internal
2954 */
2955 
2956 /*! \fn bool QTest::qCompare(char *t1, const char *t2, const char *actual, const char *expected, const char *file, int line)
2957     \internal
2958 */
2959 
2960 /*! \fn bool QTest::qCompare(const char *t1, char *t2, const char *actual, const char *expected, const char *file, int line)
2961     \internal
2962 */
2963 
2964 /*! \fn bool QTest::qCompare(const QString &t1, const QLatin1String &t2, const char *actual, const char *expected, const char *file, int line)
2965     \internal
2966 */
2967 
2968 /*! \fn bool QTest::qCompare(const QLatin1String &t1, const QString &t2, const char *actual, const char *expected, const char *file, int line)
2969     \internal
2970 */
2971 
2972 /*! \fn bool QTest::qCompare(const QStringList &t1, const QStringList &t2, const char *actual, const char *expected, const char *file, int line)
2973     \internal
2974 */
2975 
2976 /*! \fn  template <typename T> bool QTest::qCompare(const QList<T> &t1, const QList<T> &t2, const char *actual, const char *expected, const char *file, int line)
2977     \internal
2978 */
2979 
2980 /*! \fn template <typename T> bool QTest::qCompare(const QFlags<T> &t1, const T &t2, const char *actual, const char *expected, const char *file, int line)
2981     \internal
2982 */
2983 
2984 /*! \fn template <typename T> bool QTest::qCompare(const QFlags<T> &t1, const int &t2, const char *actual, const char *expected, const char *file, int line)
2985     \internal
2986 */
2987 
2988 /*! \fn bool QTest::qCompare(const qint64 &t1, const qint32 &t2, const char *actual, const char *expected, const char *file, int line)
2989     \internal
2990 */
2991 
2992 /*! \fn bool QTest::qCompare(const qint64 &t1, const quint32 &t2, const char *actual, const char *expected, const char *file, int line)
2993     \internal
2994 */
2995 
2996 /*! \fn bool QTest::qCompare(const quint64 &t1, const quint32 &t2, const char *actual, const char *expected, const char *file, int line)
2997     \internal
2998 */
2999 
3000 /*! \fn bool QTest::qCompare(const qint32 &t1, const qint64 &t2, const char *actual, const char *expected, const char *file, int line)
3001     \internal
3002 */
3003 
3004 /*! \fn bool QTest::qCompare(const quint32 &t1, const qint64 &t2, const char *actual, const char *expected, const char *file, int line)
3005     \internal
3006 */
3007 
3008 /*! \fn bool QTest::qCompare(const quint32 &t1, const quint64 &t2, const char *actual, const char *expected, const char *file, int line)
3009     \internal
3010 */
3011 
3012 /*! \fn  template <typename T> bool QTest::qTest(const T& actual, const char *elementName, const char *actualStr, const char *expected, const char *file, int line)
3013     \internal
3014 */
3015 
3016 /*! \fn void QTest::sendKeyEvent(KeyAction action, QWidget *widget, Qt::Key code, QString text, Qt::KeyboardModifiers modifier, int delay=-1)
3017     \internal
3018 */
3019 
3020 /*! \fn void QTest::sendKeyEvent(KeyAction action, QWindow *window, Qt::Key code, QString text, Qt::KeyboardModifiers modifier, int delay=-1)
3021     \internal
3022 */
3023 
3024 /*! \fn void QTest::sendKeyEvent(KeyAction action, QWidget *widget, Qt::Key code, char ascii, Qt::KeyboardModifiers modifier, int delay=-1)
3025     \internal
3026 */
3027 
3028 /*! \fn void QTest::sendKeyEvent(KeyAction action, QWindow *window, Qt::Key code, char ascii, Qt::KeyboardModifiers modifier, int delay=-1)
3029     \internal
3030 */
3031 
3032 /*! \fn void QTest::simulateEvent(QWidget *widget, bool press, int code, Qt::KeyboardModifiers modifier, QString text, bool repeat, int delay=-1)
3033     \internal
3034 */
3035 
3036 /*! \fn void QTest::simulateEvent(QWindow *window, bool press, int code, Qt::KeyboardModifiers modifier, QString text, bool repeat, int delay=-1)
3037     \internal
3038 */
3039 
3040 QT_END_NAMESPACE
