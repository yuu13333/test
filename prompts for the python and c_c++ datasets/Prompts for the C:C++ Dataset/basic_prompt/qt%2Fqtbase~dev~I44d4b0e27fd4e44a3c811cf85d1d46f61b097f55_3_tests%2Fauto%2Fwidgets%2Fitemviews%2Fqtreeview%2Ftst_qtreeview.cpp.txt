Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the test suite of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
21 ** included in the packaging of this file. Please review the following
22 ** information to ensure the GNU General Public License requirements will
23 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
24 **
25 ** $QT_END_LICENSE$
26 **
27 ****************************************************************************/
28 
29 #include "../../../../shared/fakedirmodel.h"
30 
31 #include <QHeaderView>
32 #include <QLabel>
33 #include <QLineEdit>
34 #include <QMainWindow>
35 #include <QProxyStyle>
36 #include <QPushButton>
37 #include <QScrollBar>
38 #include <QSignalSpy>
39 #include <QSortFilterProxyModel>
40 #include <QStatusBar>
41 #include <QStringListModel>
42 #include <QStyledItemDelegate>
43 #include <QTextEdit>
44 #include <QTimer>
45 #include <QToolButton>
46 #include <QTreeWidget>
47 #include <QTest>
48 #include <QVBoxLayout>
49 #include <private/qtreeview_p.h>
50 #include <private/qtesthelpers_p.h>
51 
52 using namespace QTestPrivate;
53 
54 #if QT_CONFIG(draganddrop)
55 Q_DECLARE_METATYPE(QAbstractItemView::DragDropMode)
56 #endif
57 Q_DECLARE_METATYPE(QAbstractItemView::EditTriggers)
58 Q_DECLARE_METATYPE(QAbstractItemView::EditTrigger)
59 
60 using IntBounds = std::numeric_limits<int>;
61 static void initStandardTreeModel(QStandardItemModel *model)
62 {
63     QStandardItem *item;
64     item = new QStandardItem(QLatin1String("Row 1 Item"));
65     model->insertRow(0, item);
66 
67     item = new QStandardItem(QLatin1String("Row 2 Item"));
68     item->setCheckable(true);
69     model->insertRow(1, item);
70 
71     QStandardItem *childItem = new QStandardItem(QLatin1String("Row 2 Child Item"));
72     item->setChild(0, childItem);
73 
74     item = new QStandardItem(QLatin1String("Row 3 Item"));
75     item->setIcon(QIcon());
76     model->insertRow(2, item);
77 }
78 
79 class TreeView : public QTreeView
80 {
81     Q_OBJECT
82 public:
83     using QTreeView::QTreeView;
84     using QTreeView::selectedIndexes;
85 
86     void paintEvent(QPaintEvent *event) override
87     {
88         QTreeView::paintEvent(event);
89         wasPainted = true;
90     }
91     void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight,
92                      const QList<int> &roles = QList<int>()) override
93     {
94         QTreeView::dataChanged(topLeft, bottomRight, roles);
95         QTreeViewPrivate *av = static_cast<QTreeViewPrivate*>(qt_widget_private(this));
96         m_intersectecRect = av->intersectedRect(av->viewport->rect(), topLeft, bottomRight);
97     }
98     mutable QRect m_intersectecRect;
99     bool wasPainted = false;
100 public slots:
101     void handleSelectionChanged()
102     {
103         //let's select the last item
104         QModelIndex idx = model()->index(0, 0);
105         selectionModel()->select(QItemSelection(idx, idx), QItemSelectionModel::Select);
106         disconnect(selectionModel(), &QItemSelectionModel::selectionChanged,
107                    this, &TreeView::handleSelectionChanged);
108     }
109 };
110 
111 class tst_QTreeView : public QObject
112 {
113     Q_OBJECT
114 
115 public slots:
116     void selectionOrderTest();
117 
118 private slots:
119     void initTestCase() { QApplication::setKeyboardInputInterval(100); }
120     void getSetCheck();
121 
122     // one test per QTreeView property
123     void construction();
124     void alternatingRowColors();
125     void currentIndex_data();
126     void currentIndex();
127 #if QT_CONFIG(draganddrop)
128     void dragDropMode_data();
129     void dragDropMode();
130     void dragDropModeFromDragEnabledAndAcceptDrops_data();
131     void dragDropModeFromDragEnabledAndAcceptDrops();
132     void dragDropOverwriteMode();
133 #endif
134     void editTriggers_data();
135     void editTriggers();
136     void hasAutoScroll();
137     void horizontalScrollMode();
138     void iconSize();
139     void indexAt();
140     void indexWidget();
141     void itemDelegate();
142     void itemDelegateForColumnOrRow();
143     void keyboardSearch();
144     void keyboardSearchMultiColumn();
145     void setModel();
146     void openPersistentEditor();
147     void rootIndex();
148 
149     // specialized tests below
150     void setHeader();
151     void columnHidden();
152     void rowHidden();
153     void noDelegate();
154     void noModel();
155     void emptyModel();
156     void removeRows();
157     void removeCols();
158     void limitedExpand();
159     void expandAndCollapse_data();
160     void expandAndCollapse();
161     void expandAndCollapseAll();
162     void expandWithNoChildren();
163 #if QT_CONFIG(animation)
164     void quickExpandCollapse();
165 #endif
166     void keyboardNavigation();
167     void headerSections();
168     void moveCursor_data();
169     void moveCursor();
170     void setSelection_data();
171     void setSelection();
172     void extendedSelection_data();
173     void extendedSelection();
174     void indexAbove();
175     void indexBelow();
176     void clicked();
177     void mouseDoubleClick();
178     void rowsAboutToBeRemoved();
179     void headerSections_unhideSection();
180     void columnAt();
181     void scrollTo();
182     void rowsAboutToBeRemoved_move();
183     void resizeColumnToContents();
184     void insertAfterSelect();
185     void removeAfterSelect();
186     void hiddenItems();
187     void spanningItems();
188     void rowSizeHint();
189     void setSortingEnabledTopLevel();
190     void setSortingEnabledChild();
191     void headerHidden();
192     void indentation();
193 
194     void selection();
195     void removeAndInsertExpandedCol0();
196     void selectionWithHiddenItems();
197     void selectAll();
198 
199     void disabledButCheckable();
200     void sortByColumn_data();
201     void sortByColumn();
202 
203     void evilModel_data();
204     void evilModel();
205 
206     void indexRowSizeHint();
207     void addRowsWhileSectionsAreHidden();
208     void filterProxyModelCrash();
209     void renderToPixmap_data();
210     void renderToPixmap();
211     void styleOptionViewItem();
212     void keyboardNavigationWithDisabled();
213     void saveRestoreState();
214 
215     void statusTip_data();
216     void statusTip();
217     void fetchMoreOnScroll();
218     void checkIntersectedRect_data();
219     void checkIntersectedRect();
220 
221     // task-specific tests:
222     void task174627_moveLeftToRoot();
223     void task171902_expandWith1stColHidden();
224     void task203696_hidingColumnsAndRowsn();
225     void task211293_removeRootIndex();
226     void task216717_updateChildren();
227     void task220298_selectColumns();
228     void task224091_appendColumns();
229     void task225539_deleteModel();
230     void task230123_setItemsExpandable();
231     void task202039_closePersistentEditor();
232     void task238873_avoidAutoReopening();
233     void task244304_clickOnDecoration();
234     void task246536_scrollbarsNotWorking();
235     void task250683_wrongSectionSize();
236     void task239271_addRowsWithFirstColumnHidden();
237     void task254234_proxySort();
238     void task248022_changeSelection();
239     void task245654_changeModelAndExpandAll();
240     void doubleClickedWithSpans();
241     void taskQTBUG_6450_selectAllWith1stColumnHidden();
242     void taskQTBUG_9216_setSizeAndUniformRowHeightsWrongRepaint();
243     void taskQTBUG_11466_keyboardNavigationRegression();
244     void taskQTBUG_13567_removeLastItemRegression();
245     void taskQTBUG_25333_adjustViewOptionsForIndex();
246     void taskQTBUG_18539_emitLayoutChanged();
247     void taskQTBUG_8176_emitOnExpandAll();
248     void taskQTBUG_37813_crash();
249     void taskQTBUG_45697_crash();
250     void taskQTBUG_7232_AllowUserToControlSingleStep();
251     void taskQTBUG_8376();
252     void taskQTBUG_61476();
253     void taskQTBUG_88966_expandAfterTake();
254     void testInitialFocus();
255     void fetchUntilScreenFull();
256 };
257 
258 class QtTestModel: public QAbstractItemModel
259 {
260     Q_OBJECT
261 public:
262     QtTestModel(int _rows, int _cols, QObject *parent = nullptr)
263         : QAbstractItemModel(parent), rows(_rows), cols(_cols)
264     {}
265 
266     inline qint32 level(const QModelIndex &index) const
267     {
268         return index.isValid() ? qint32(index.internalId()) : qint32(-1);
269     }
270 
271     bool canFetchMore(const QModelIndex &) const override { return !fetched; }
272 
273     void fetchMore(const QModelIndex &) override { fetched = true; }
274 
275     bool hasChildren(const QModelIndex &parent = QModelIndex()) const override
276     {
277         bool hasFetched = fetched;
278         fetched = true;
279         bool r = QAbstractItemModel::hasChildren(parent);
280         fetched = hasFetched;
281         return r;
282     }
283 
284     int rowCount(const QModelIndex& parent = QModelIndex()) const override
285     {
286         if (!fetched)
287             qFatal("%s: rowCount should not be called before fetching", Q_FUNC_INFO);
288         if ((parent.column() > 0) || (level(parent) > levels))
289             return 0;
290         return rows;
291     }
292     int columnCount(const QModelIndex& parent = QModelIndex()) const override
293     {
294         if ((parent.column() > 0) || (level(parent) > levels))
295             return 0;
296         return cols;
297     }
298 
299     bool isEditable(const QModelIndex &index) const
300     {
301         if (index.isValid())
302             return true;
303         return false;
304     }
305 
306     QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override
307     {
308         if (onlyValidCalls) {
309             Q_ASSERT(row >= 0);
310             Q_ASSERT(column >= 0);
311             Q_ASSERT(row < rows);
312             Q_ASSERT(column < cols);
313         }
314         if (row < 0 || column < 0 || (level(parent) > levels) || column >= cols || row >= rows) {
315             return QModelIndex();
316         }
317         QModelIndex i = createIndex(row, column, quintptr(level(parent) + 1));
318         parentHash[i] = parent;
319         return i;
320     }
321 
322     QModelIndex parent(const QModelIndex &index) const override
323     {
324         if (!parentHash.contains(index))
325             return QModelIndex();
326         return parentHash[index];
327     }
328 
329     QVariant data(const QModelIndex &idx, int role) const override
330     {
331         if (!idx.isValid())
332             return QVariant();
333 
334         if (role == Qt::DisplayRole) {
335             if (idx.row() < 0 || idx.column() < 0 || idx.column() >= cols || idx.row() >= rows) {
336                 wrongIndex = true;
337                 qWarning("Invalid modelIndex [%d,%d,%p]", idx.row(), idx.column(),
338                          idx.internalPointer());
339             }
340             QString result = QLatin1Char('[') + QString::number(idx.row()) + QLatin1Char(',')
341                 + QString::number(idx.column()) + QLatin1Char(',') +  QString::number(level(idx))
342                 + QLatin1Char(']');
343             if (idx.row() & 1)
344                 result += QLatin1String(" - this item is extra wide");
345             return result;
346         }
347         if (decorationsEnabled && role == Qt::DecorationRole) {
348             QPixmap pm(16,16);
349             pm.fill(QColor::fromHsv((idx.column() % 16)*8 + 64, 254, (idx.row() % 16)*8 + 32));
350             return pm;
351         }
352         if (statusTipsEnabled && role == Qt::StatusTipRole)
353             return QString("[%1,%2,%3] -- Status").arg(idx.row()).arg(idx.column()).arg(level(idx));
354         return QVariant();
355     }
356 
357     QVariant headerData(int section, Qt::Orientation orientation,
358                         int role = Qt::DisplayRole) const override
359     {
360         Q_UNUSED(orientation);
361         if (section < 0 || section >= columnCount())
362             return QVariant();
363         if (statusTipsEnabled && role == Qt::StatusTipRole)
364             return QString("Header %1 -- Status").arg(section);
365         return QVariant();
366     }
367 
368     void simulateMoveRows()
369     {
370         beginMoveRows(QModelIndex(), 0, 0, QModelIndex(), 2);
371         endMoveRows();
372     }
373 
374     void removeLastRow()
375     {
376         beginRemoveRows(QModelIndex(), rows - 1, rows - 1);
377         --rows;
378         endRemoveRows();
379     }
380 
381     void removeAllRows()
382     {
383         beginRemoveRows(QModelIndex(), 0, rows - 1);
384         rows = 0;
385         endRemoveRows();
386     }
387 
388     void removeLastColumn()
389     {
390         beginRemoveColumns(QModelIndex(), cols - 1, cols - 1);
391         --cols;
392         endRemoveColumns();
393     }
394 
395     void removeAllColumns()
396     {
397         beginRemoveColumns(QModelIndex(), 0, cols - 1);
398         cols = 0;
399         endRemoveColumns();
400     }
401 
402     void insertNewRow()
403     {
404         beginInsertRows(QModelIndex(), rows - 1, rows - 1);
405         ++rows;
406         endInsertRows();
407     }
408 
409     void setDecorationsEnabled(bool enable)
410     {
411         decorationsEnabled = enable;
412     }
413 
414     mutable QMap<QModelIndex,QModelIndex> parentHash;
415     int rows = 0;
416     int cols = 0;
417     int levels = IntBounds::max();
418     mutable bool wrongIndex = false;
419     mutable bool fetched = false;
420     bool decorationsEnabled = false;
421     bool statusTipsEnabled = false;
422     bool onlyValidCalls = false;
423 };
424 
425 // Testing get/set functions
426 void tst_QTreeView::getSetCheck()
427 {
428     QTreeView obj1;
429 
430     // int QTreeView::indentation()
431     // void QTreeView::setIndentation(int)
432     const int styledIndentation = obj1.style()->pixelMetric(
433           QStyle::PM_TreeViewIndentation, nullptr, &obj1);
434     QCOMPARE(obj1.indentation(), styledIndentation);
435     obj1.setIndentation(0);
436     QCOMPARE(obj1.indentation(), 0);
437     obj1.setIndentation(IntBounds::min());
438     QCOMPARE(obj1.indentation(), IntBounds::min());
439     obj1.setIndentation(IntBounds::max());
440     QCOMPARE(obj1.indentation(), IntBounds::max());
441 
442     // bool QTreeView::rootIsDecorated()
443     // void QTreeView::setRootIsDecorated(bool)
444     QCOMPARE(obj1.rootIsDecorated(), true);
445     obj1.setRootIsDecorated(false);
446     QCOMPARE(obj1.rootIsDecorated(), false);
447     obj1.setRootIsDecorated(true);
448     QCOMPARE(obj1.rootIsDecorated(), true);
449 
450     // bool QTreeView::uniformRowHeights()
451     // void QTreeView::setUniformRowHeights(bool)
452     QCOMPARE(obj1.uniformRowHeights(), false);
453     obj1.setUniformRowHeights(false);
454     QCOMPARE(obj1.uniformRowHeights(), false);
455     obj1.setUniformRowHeights(true);
456     QCOMPARE(obj1.uniformRowHeights(), true);
457 
458     // bool QTreeView::itemsExpandable()
459     // void QTreeView::setItemsExpandable(bool)
460     QCOMPARE(obj1.itemsExpandable(), true);
461     obj1.setItemsExpandable(false);
462     QCOMPARE(obj1.itemsExpandable(), false);
463     obj1.setItemsExpandable(true);
464     QCOMPARE(obj1.itemsExpandable(), true);
465 
466     // bool QTreeView::allColumnsShowFocus
467     // void QTreeView::setAllColumnsShowFocus
468     QCOMPARE(obj1.allColumnsShowFocus(), false);
469     obj1.setAllColumnsShowFocus(false);
470     QCOMPARE(obj1.allColumnsShowFocus(), false);
471     obj1.setAllColumnsShowFocus(true);
472     QCOMPARE(obj1.allColumnsShowFocus(), true);
473 
474     // bool QTreeView::isAnimated
475     // void QTreeView::setAnimated
476     QCOMPARE(obj1.isAnimated(), false);
477     obj1.setAnimated(false);
478     QCOMPARE(obj1.isAnimated(), false);
479     obj1.setAnimated(true);
480     QCOMPARE(obj1.isAnimated(), true);
481 
482     // bool QTreeView::setSortingEnabled
483     // void QTreeView::isSortingEnabled
484     QCOMPARE(obj1.isSortingEnabled(), false);
485     obj1.setSortingEnabled(false);
486     QCOMPARE(obj1.isSortingEnabled(), false);
487     obj1.setSortingEnabled(true);
488     QCOMPARE(obj1.isSortingEnabled(), true);
489 }
490 
491 void tst_QTreeView::construction()
492 {
493     QTreeView view;
494 
495     // QAbstractItemView properties
496     QVERIFY(!view.alternatingRowColors());
497     QCOMPARE(view.currentIndex(), QModelIndex());
498 #if QT_CONFIG(draganddrop)
499     QCOMPARE(view.dragDropMode(), QAbstractItemView::NoDragDrop);
500     QVERIFY(!view.dragDropOverwriteMode());
501     QVERIFY(!view.dragEnabled());
502 #endif
503     QCOMPARE(view.editTriggers(), QAbstractItemView::EditKeyPressed | QAbstractItemView::DoubleClicked);
504     QVERIFY(view.hasAutoScroll());
505     QCOMPARE(view.horizontalScrollMode(), QAbstractItemView::ScrollPerPixel);
506     QCOMPARE(view.iconSize(), QSize());
507     QCOMPARE(view.indexAt(QPoint()), QModelIndex());
508     QVERIFY(!view.indexWidget(QModelIndex()));
509     QVERIFY(qobject_cast<QStyledItemDelegate *>(view.itemDelegate()));
510     QVERIFY(!view.itemDelegateForColumn(-1));
511     QVERIFY(!view.itemDelegateForColumn(0));
512     QVERIFY(!view.itemDelegateForColumn(1));
513     QVERIFY(!view.itemDelegateForRow(-1));
514     QVERIFY(!view.itemDelegateForRow(0));
515     QVERIFY(!view.itemDelegateForRow(1));
516     QVERIFY(!view.model());
517     QCOMPARE(view.rootIndex(), QModelIndex());
518     QCOMPARE(view.selectionBehavior(), QAbstractItemView::SelectRows);
519     QCOMPARE(view.selectionMode(), QAbstractItemView::SingleSelection);
520     QVERIFY(!view.selectionModel());
521 #if QT_CONFIG(draganddrop)
522     QVERIFY(view.showDropIndicator());
523 #endif
524     QCOMPARE(view.QAbstractItemView::sizeHintForColumn(-1), -1); // <- protected in QTreeView
525     QCOMPARE(view.QAbstractItemView::sizeHintForColumn(0), -1); // <- protected in QTreeView
526     QCOMPARE(view.QAbstractItemView::sizeHintForColumn(1), -1); // <- protected in QTreeView
527     QCOMPARE(view.sizeHintForIndex(QModelIndex()), QSize());
528     QCOMPARE(view.sizeHintForRow(-1), -1);
529     QCOMPARE(view.sizeHintForRow(0), -1);
530     QCOMPARE(view.sizeHintForRow(1), -1);
531     QVERIFY(!view.tabKeyNavigation());
532     QCOMPARE(view.textElideMode(), Qt::ElideRight);
533     QCOMPARE(static_cast<int>(view.verticalScrollMode()),
534              view.style()->styleHint(QStyle::SH_ItemView_ScrollMode, nullptr, &view));
535     QCOMPARE(view.visualRect(QModelIndex()), QRect());
536 
537     // QTreeView properties
538     QVERIFY(!view.allColumnsShowFocus());
539     QCOMPARE(view.autoExpandDelay(), -1);
540     QCOMPARE(view.columnAt(-1), -1);
541     QCOMPARE(view.columnAt(0), -1);
542     QCOMPARE(view.columnAt(1), -1);
543     QCOMPARE(view.columnViewportPosition(-1), -1);
544     QCOMPARE(view.columnViewportPosition(0), -1);
545     QCOMPARE(view.columnViewportPosition(1), -1);
546     QCOMPARE(view.columnWidth(-1), 0);
547     QCOMPARE(view.columnWidth(0), 0);
548     QCOMPARE(view.columnWidth(1), 0);
549     QVERIFY(view.header());
550     QCOMPARE(view.indentation(),
551              view.style()->pixelMetric(QStyle::PM_TreeViewIndentation, nullptr, &view));
552     QCOMPARE(view.indexAbove(QModelIndex()), QModelIndex());
553     QCOMPARE(view.indexBelow(QModelIndex()), QModelIndex());
554     QVERIFY(!view.isAnimated());
555     QVERIFY(!view.isColumnHidden(-1));
556     QVERIFY(!view.isColumnHidden(0));
557     QVERIFY(!view.isColumnHidden(1));
558     QVERIFY(!view.isExpanded(QModelIndex()));
559     QVERIFY(!view.isRowHidden(-1, QModelIndex()));
560     QVERIFY(!view.isRowHidden(0, QModelIndex()));
561     QVERIFY(!view.isRowHidden(1, QModelIndex()));
562     QVERIFY(!view.isFirstColumnSpanned(-1, QModelIndex()));
563     QVERIFY(!view.isFirstColumnSpanned(0, QModelIndex()));
564     QVERIFY(!view.isFirstColumnSpanned(1, QModelIndex()));
565     QVERIFY(!view.isSortingEnabled());
566     QVERIFY(view.itemsExpandable());
567     QVERIFY(view.rootIsDecorated());
568     QVERIFY(!view.uniformRowHeights());
569     QCOMPARE(view.visualRect(QModelIndex()), QRect());
570     QVERIFY(!view.wordWrap());
571 }
572 
573 void tst_QTreeView::alternatingRowColors()
574 {
575     QTreeView view;
576     QVERIFY(!view.alternatingRowColors());
577     view.setAlternatingRowColors(true);
578     QVERIFY(view.alternatingRowColors());
579     view.setAlternatingRowColors(false);
580     QVERIFY(!view.alternatingRowColors());
581 
582     // ### Test visual effect.
583 }
584 
585 void tst_QTreeView::currentIndex_data()
586 {
587     QTest::addColumn<int>("row");
588     QTest::addColumn<int>("column");
589     QTest::addColumn<int>("indexRow");
590     QTest::addColumn<int>("indexColumn");
591     QTest::addColumn<int>("parentIndexRow");
592     QTest::addColumn<int>("parentIndexColumn");
593 
594     QTest::newRow("-1, -1") << -1 << -1 << -1 << -1 << -1 << -1;
595     QTest::newRow("-1, 0") << -1 << 0 << -1 << -1 << -1 << -1;
596     QTest::newRow("0, -1") << 0 << -1 << -1 << -1 << -1 << -1;
597     QTest::newRow("0, 0") << 0 << 0 << 0 << 0 << -1 << -1;
598     QTest::newRow("0, 1") << 0 << 0 << 0 << 0 << -1 << -1;
599     QTest::newRow("1, 0") << 1 << 0 << 1 << 0 << -1 << -1;
600     QTest::newRow("1, 1") << 1 << 1 << -1 << -1 << -1 << -1;
601     QTest::newRow("2, 0") << 2 << 0 << 2 << 0 << -1 << -1;
602     QTest::newRow("2, 1") << 2 << 1 << -1 << -1 << -1 << -1;
603     QTest::newRow("3, -1") << 3 << -1 << -1 << -1 << -1 << -1;
604     QTest::newRow("3, 0") << 3 << 0 << -1 << -1 << -1 << -1;
605     QTest::newRow("3, 1") << 3 << 1 << -1 << -1 << -1 << -1;
606 }
607 
608 void tst_QTreeView::currentIndex()
609 {
610     QFETCH(int, row);
611     QFETCH(int, column);
612     QFETCH(int, indexRow);
613     QFETCH(int, indexColumn);
614     QFETCH(int, parentIndexRow);
615     QFETCH(int, parentIndexColumn);
616 
617     QTreeView view;
618     QStandardItemModel treeModel;
619     initStandardTreeModel(&treeModel);
620     view.setModel(&treeModel);
621 
622     QCOMPARE(view.currentIndex(), QModelIndex());
623     view.setCurrentIndex(view.model()->index(row, column));
624     QCOMPARE(view.currentIndex().row(), indexRow);
625     QCOMPARE(view.currentIndex().column(), indexColumn);
626     QCOMPARE(view.currentIndex().parent().row(), parentIndexRow);
627     QCOMPARE(view.currentIndex().parent().column(), parentIndexColumn);
628 
629     // ### Test child and grandChild indexes.
630 }
631 
632 #if QT_CONFIG(draganddrop)
633 
634 void tst_QTreeView::dragDropMode_data()
635 {
636     QTest::addColumn<QAbstractItemView::DragDropMode>("dragDropMode");
637     QTest::addColumn<bool>("acceptDrops");
638     QTest::addColumn<bool>("dragEnabled");
639     QTest::newRow("NoDragDrop") << QAbstractItemView::NoDragDrop << false << false;
640     QTest::newRow("DragOnly") << QAbstractItemView::DragOnly << false << true;
641     QTest::newRow("DropOnly") << QAbstractItemView::DropOnly << true << false;
642     QTest::newRow("DragDrop") << QAbstractItemView::DragDrop << true << true;
643     QTest::newRow("InternalMove") << QAbstractItemView::InternalMove << true << true;
644 }
645 
646 void tst_QTreeView::dragDropMode()
647 {
648     QFETCH(QAbstractItemView::DragDropMode, dragDropMode);
649     QFETCH(bool, acceptDrops);
650     QFETCH(bool, dragEnabled);
651 
652     QTreeView view;
653     QCOMPARE(view.dragDropMode(), QAbstractItemView::NoDragDrop);
654     QVERIFY(!view.acceptDrops());
655     QVERIFY(!view.dragEnabled());
656 
657     view.setDragDropMode(dragDropMode);
658     QCOMPARE(view.dragDropMode(), dragDropMode);
659     QCOMPARE(view.acceptDrops(), acceptDrops);
660     QCOMPARE(view.dragEnabled(), dragEnabled);
661 
662     // ### Test effects of this mode
663 }
664 
665 void tst_QTreeView::dragDropModeFromDragEnabledAndAcceptDrops_data()
666 {
667     QTest::addColumn<bool>("dragEnabled");
668     QTest::addColumn<bool>("acceptDrops");
669     QTest::addColumn<QAbstractItemView::DragDropMode>("dragDropMode");
670     QTest::addColumn<bool>("setBehavior");
671     QTest::addColumn<QAbstractItemView::DragDropMode>("behavior");
672 
673     QTest::newRow("NoDragDrop -1") << false << false << QAbstractItemView::NoDragDrop << false << QAbstractItemView::DragDropMode();
674     QTest::newRow("NoDragDrop 0") << false << false << QAbstractItemView::NoDragDrop << true << QAbstractItemView::NoDragDrop;
675     QTest::newRow("NoDragDrop 1") << false << false << QAbstractItemView::NoDragDrop << true << QAbstractItemView::DragOnly;
676     QTest::newRow("NoDragDrop 2") << false << false << QAbstractItemView::NoDragDrop << true << QAbstractItemView::DropOnly;
677     QTest::newRow("NoDragDrop 3") << false << false << QAbstractItemView::NoDragDrop << true << QAbstractItemView::DragDrop;
678     QTest::newRow("NoDragDrop 4") << false << false << QAbstractItemView::NoDragDrop << true << QAbstractItemView::InternalMove;
679     QTest::newRow("DragOnly -1") << true << false << QAbstractItemView::DragOnly << false << QAbstractItemView::DragDropMode();
680     QTest::newRow("DragOnly 0") << true << false << QAbstractItemView::DragOnly << true << QAbstractItemView::NoDragDrop;
681     QTest::newRow("DragOnly 1") << true << false << QAbstractItemView::DragOnly << true << QAbstractItemView::DragOnly;
682     QTest::newRow("DragOnly 2") << true << false << QAbstractItemView::DragOnly << true << QAbstractItemView::DropOnly;
683     QTest::newRow("DragOnly 3") << true << false << QAbstractItemView::DragOnly << true << QAbstractItemView::DragDrop;
684     QTest::newRow("DragOnly 4") << true << false << QAbstractItemView::DragOnly << true << QAbstractItemView::InternalMove;
685     QTest::newRow("DropOnly -1") << false << true << QAbstractItemView::DropOnly << false << QAbstractItemView::DragDropMode();
686     QTest::newRow("DropOnly 0") << false << true << QAbstractItemView::DropOnly << true << QAbstractItemView::NoDragDrop;
687     QTest::newRow("DropOnly 1") << false << true << QAbstractItemView::DropOnly << true << QAbstractItemView::DragOnly;
688     QTest::newRow("DropOnly 2") << false << true << QAbstractItemView::DropOnly << true << QAbstractItemView::DropOnly;
689     QTest::newRow("DropOnly 3") << false << true << QAbstractItemView::DropOnly << true << QAbstractItemView::DragDrop;
690     QTest::newRow("DropOnly 4") << false << true << QAbstractItemView::DropOnly << true << QAbstractItemView::InternalMove;
691     QTest::newRow("DragDrop -1") << true << true << QAbstractItemView::DragDrop << false << QAbstractItemView::DragDropMode();
692     QTest::newRow("DragDrop 0") << true << true << QAbstractItemView::DragDrop << false << QAbstractItemView::DragDropMode();
693     QTest::newRow("DragDrop 1") << true << true << QAbstractItemView::DragDrop << true << QAbstractItemView::NoDragDrop;
694     QTest::newRow("DragDrop 2") << true << true << QAbstractItemView::DragDrop << true << QAbstractItemView::DragOnly;
695     QTest::newRow("DragDrop 3") << true << true << QAbstractItemView::DragDrop << true << QAbstractItemView::DropOnly;
696     QTest::newRow("DragDrop 4") << true << true << QAbstractItemView::DragDrop << true << QAbstractItemView::DragDrop;
697     QTest::newRow("DragDrop 5") << true << true << QAbstractItemView::InternalMove << true << QAbstractItemView::InternalMove;
698 }
699 
700 void tst_QTreeView::dragDropModeFromDragEnabledAndAcceptDrops()
701 {
702     QFETCH(bool, acceptDrops);
703     QFETCH(bool, dragEnabled);
704     QFETCH(QAbstractItemView::DragDropMode, dragDropMode);
705     QFETCH(bool, setBehavior);
706     QFETCH(QAbstractItemView::DragDropMode, behavior);
707 
708     QTreeView view;
709     QCOMPARE(view.dragDropMode(), QAbstractItemView::NoDragDrop);
710 
711     if (setBehavior)
712         view.setDragDropMode(behavior);
713 
714     view.setAcceptDrops(acceptDrops);
715     view.setDragEnabled(dragEnabled);
716     QCOMPARE(view.dragDropMode(), dragDropMode);
717 
718     // ### Test effects of this mode
719 }
720 
721 void tst_QTreeView::dragDropOverwriteMode()
722 {
723     QTreeView view;
724     QVERIFY(!view.dragDropOverwriteMode());
725     view.setDragDropOverwriteMode(true);
726     QVERIFY(view.dragDropOverwriteMode());
727     view.setDragDropOverwriteMode(false);
728     QVERIFY(!view.dragDropOverwriteMode());
729 
730     // ### This property changes the behavior of dropIndicatorPosition(),
731     // which is protected and called only from within QListWidget and
732     // QTableWidget, from their reimplementations of dropMimeData(). Hard to
733     // test.
734 }
735 #endif
736 
737 void tst_QTreeView::editTriggers_data()
738 {
739     QTest::addColumn<QAbstractItemView::EditTriggers>("editTriggers");
740     QTest::addColumn<QAbstractItemView::EditTrigger>("triggeredTrigger");
741     QTest::addColumn<bool>("editorOpened");
742 
743     // NoEditTriggers
744     QTest::newRow("NoEditTriggers 0") << QAbstractItemView::EditTriggers(QAbstractItemView::NoEditTriggers)
745                                       << QAbstractItemView::NoEditTriggers << false;
746     QTest::newRow("NoEditTriggers 1") << QAbstractItemView::EditTriggers(QAbstractItemView::NoEditTriggers)
747                                       << QAbstractItemView::CurrentChanged << false;
748     QTest::newRow("NoEditTriggers 2") << QAbstractItemView::EditTriggers(QAbstractItemView::NoEditTriggers)
749                                       << QAbstractItemView::DoubleClicked << false;
750     QTest::newRow("NoEditTriggers 3") << QAbstractItemView::EditTriggers(QAbstractItemView::NoEditTriggers)
751                                       << QAbstractItemView::SelectedClicked << false;
752     QTest::newRow("NoEditTriggers 4") << QAbstractItemView::EditTriggers(QAbstractItemView::NoEditTriggers)
753                                       << QAbstractItemView::EditKeyPressed << false;
754 
755     // CurrentChanged
756     QTest::newRow("CurrentChanged 0") << QAbstractItemView::EditTriggers(QAbstractItemView::CurrentChanged)
757                                       << QAbstractItemView::NoEditTriggers << false;
758     QTest::newRow("CurrentChanged 1") << QAbstractItemView::EditTriggers(QAbstractItemView::CurrentChanged)
759                                       << QAbstractItemView::CurrentChanged << true;
760     QTest::newRow("CurrentChanged 2") << QAbstractItemView::EditTriggers(QAbstractItemView::CurrentChanged)
761                                       << QAbstractItemView::DoubleClicked << false;
762     QTest::newRow("CurrentChanged 3") << QAbstractItemView::EditTriggers(QAbstractItemView::CurrentChanged)
763                                       << QAbstractItemView::SelectedClicked << false;
764     QTest::newRow("CurrentChanged 4") << QAbstractItemView::EditTriggers(QAbstractItemView::CurrentChanged)
765                                       << QAbstractItemView::EditKeyPressed << false;
766 
767     // DoubleClicked
768     QTest::newRow("DoubleClicked 0") << QAbstractItemView::EditTriggers(QAbstractItemView::DoubleClicked)
769                                      << QAbstractItemView::NoEditTriggers << false;
770     QTest::newRow("DoubleClicked 1") << QAbstractItemView::EditTriggers(QAbstractItemView::DoubleClicked)
771                                      << QAbstractItemView::CurrentChanged << false;
772     QTest::newRow("DoubleClicked 2") << QAbstractItemView::EditTriggers(QAbstractItemView::DoubleClicked)
773                                      << QAbstractItemView::DoubleClicked << true;
774     QTest::newRow("DoubleClicked 3") << QAbstractItemView::EditTriggers(QAbstractItemView::DoubleClicked)
775                                      << QAbstractItemView::SelectedClicked << false;
776     QTest::newRow("DoubleClicked 4") << QAbstractItemView::EditTriggers(QAbstractItemView::DoubleClicked)
777                                      << QAbstractItemView::EditKeyPressed << false;
778 
779     // SelectedClicked
780     QTest::newRow("SelectedClicked 0") << QAbstractItemView::EditTriggers(QAbstractItemView::SelectedClicked)
781                                        << QAbstractItemView::NoEditTriggers << false;
782     QTest::newRow("SelectedClicked 1") << QAbstractItemView::EditTriggers(QAbstractItemView::SelectedClicked)
783                                        << QAbstractItemView::CurrentChanged << false;
784     QTest::newRow("SelectedClicked 2") << QAbstractItemView::EditTriggers(QAbstractItemView::SelectedClicked)
785                                        << QAbstractItemView::DoubleClicked << false;
786     QTest::newRow("SelectedClicked 3") << QAbstractItemView::EditTriggers(QAbstractItemView::SelectedClicked)
787                                        << QAbstractItemView::SelectedClicked << true;
788     QTest::newRow("SelectedClicked 4") << QAbstractItemView::EditTriggers(QAbstractItemView::SelectedClicked)
789                                        << QAbstractItemView::EditKeyPressed << false;
790 
791     // EditKeyPressed
792     QTest::newRow("EditKeyPressed 0") << QAbstractItemView::EditTriggers(QAbstractItemView::EditKeyPressed)
793                                       << QAbstractItemView::NoEditTriggers << false;
794     QTest::newRow("EditKeyPressed 1") << QAbstractItemView::EditTriggers(QAbstractItemView::EditKeyPressed)
795                                       << QAbstractItemView::CurrentChanged << false;
796     QTest::newRow("EditKeyPressed 2") << QAbstractItemView::EditTriggers(QAbstractItemView::EditKeyPressed)
797                                       << QAbstractItemView::DoubleClicked << false;
798     QTest::newRow("EditKeyPressed 3") << QAbstractItemView::EditTriggers(QAbstractItemView::EditKeyPressed)
799                                       << QAbstractItemView::SelectedClicked << false;
800     QTest::newRow("EditKeyPressed 4") << QAbstractItemView::EditTriggers(QAbstractItemView::EditKeyPressed)
801                                       << QAbstractItemView::EditKeyPressed << true;
802 }
803 
804 void tst_QTreeView::editTriggers()
805 {
806     QFETCH(QAbstractItemView::EditTriggers, editTriggers);
807     QFETCH(QAbstractItemView::EditTrigger, triggeredTrigger);
808     QFETCH(bool, editorOpened);
809 
810     QTreeView view;
811     QStandardItemModel treeModel;
812     initStandardTreeModel(&treeModel);
813     view.setModel(&treeModel);
814     view.show();
815 
816     QCOMPARE(view.editTriggers(), QAbstractItemView::EditKeyPressed | QAbstractItemView::DoubleClicked);
817 
818     // Initialize the first index
819     view.setCurrentIndex(view.model()->index(0, 0));
820 
821     // Verify that we don't have any editor initially
822     QVERIFY(!view.findChild<QLineEdit *>(QString()));
823 
824     // Set the triggers
825     view.setEditTriggers(editTriggers);
826 
827     // Interact with the view
828     switch (triggeredTrigger) {
829     case QAbstractItemView::NoEditTriggers:
830         // Do nothing, the editor shouldn't be there
831         break;
832     case QAbstractItemView::CurrentChanged:
833         // Change the index to open an editor
834         view.setCurrentIndex(view.model()->index(1, 0));
835         break;
836     case QAbstractItemView::DoubleClicked:
837         // Doubleclick the center of the current cell
838         QTest::mouseClick(view.viewport(), Qt::LeftButton, {},
839                           view.visualRect(view.model()->index(0, 0)).center());
840         QTest::mouseDClick(view.viewport(), Qt::LeftButton, {},
841                            view.visualRect(view.model()->index(0, 0)).center());
842         break;
843     case QAbstractItemView::SelectedClicked:
844         // Click the center of the current cell
845         view.selectionModel()->select(view.model()->index(0, 0), QItemSelectionModel::Select);
846         QTest::mouseClick(view.viewport(), Qt::LeftButton, {},
847                           view.visualRect(view.model()->index(0, 0)).center());
848         QTest::qWait(qRound(QApplication::doubleClickInterval() * 1.5));
849         break;
850     case QAbstractItemView::EditKeyPressed:
851         view.setFocus();
852 #ifdef Q_OS_MAC
853         // OS X uses Enter for editing
854         QTest::keyPress(&view, Qt::Key_Enter);
855 #else
856         // All other platforms use F2
857         QTest::keyPress(&view, Qt::Key_F2);
858 #endif
859         break;
860     default:
861         break;
862     }
863 
864     // Check if we got an editor
865     QTRY_COMPARE(view.findChild<QLineEdit *>(QString()) != nullptr, editorOpened);
866 }
867 
868 void tst_QTreeView::hasAutoScroll()
869 {
870     QTreeView view;
871     QVERIFY(view.hasAutoScroll());
872     view.setAutoScroll(false);
873     QVERIFY(!view.hasAutoScroll());
874     view.setAutoScroll(true);
875     QVERIFY(view.hasAutoScroll());
876 }
877 
878 void tst_QTreeView::horizontalScrollMode()
879 {
880     QStandardItemModel model;
881     for (int i = 0; i < 100; ++i) {
882         model.appendRow(QList<QStandardItem *>()
883                         << new QStandardItem("An item that has very long text and should"
884                                              " cause the horizontal scroll bar to appear.")
885                         << new QStandardItem("An item that has very long text and should"
886                                              " cause the horizontal scroll bar to appear."));
887     }
888 
889     QTreeView view;
890     setFrameless(&view);
891     view.setModel(&model);
892     view.setFixedSize(100, 100);
893     view.header()->resizeSection(0, 200);
894     view.show();
895 
896     QCOMPARE(view.horizontalScrollMode(), QAbstractItemView::ScrollPerPixel);
897     QCOMPARE(view.horizontalScrollBar()->minimum(), 0);
898     QVERIFY(view.horizontalScrollBar()->maximum() > 2);
899 
900     view.setHorizontalScrollMode(QAbstractItemView::ScrollPerItem);
901     QCOMPARE(view.horizontalScrollMode(), QAbstractItemView::ScrollPerItem);
902     QCOMPARE(view.horizontalScrollBar()->minimum(), 0);
903     QCOMPARE(view.horizontalScrollBar()->maximum(), 1);
904 
905     view.setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);
906     QCOMPARE(view.horizontalScrollMode(), QAbstractItemView::ScrollPerPixel);
907     QCOMPARE(view.horizontalScrollBar()->minimum(), 0);
908     QVERIFY(view.horizontalScrollBar()->maximum() > 2);
909 }
910 
911 class RepaintTreeView : public QTreeView
912 {
913 public:
914     using QTreeView::QTreeView;
915     bool repainted = false;
916 
917 protected:
918     void paintEvent(QPaintEvent *event) override
919     { repainted = true; QTreeView::paintEvent(event); }
920 };
921 
922 void tst_QTreeView::iconSize()
923 {
924     RepaintTreeView view;
925     QCOMPARE(view.iconSize(), QSize());
926 
927     QStandardItemModel treeModel;
928     initStandardTreeModel(&treeModel);
929     view.setModel(&treeModel);
930     QCOMPARE(view.iconSize(), QSize());
931     QVERIFY(!view.repainted);
932 
933     view.show();
934     view.update();
935     QVERIFY(QTest::qWaitForWindowExposed(&view));
936     QTRY_VERIFY(view.repainted);
937     QCOMPARE(view.iconSize(), QSize());
938 
939     view.repainted = false;
940     view.setIconSize(QSize());
941     QTRY_VERIFY(!view.repainted);
942     QCOMPARE(view.iconSize(), QSize());
943 
944     view.setIconSize(QSize(10, 10));
945     QTRY_VERIFY(view.repainted);
946     QCOMPARE(view.iconSize(), QSize(10, 10));
947 
948     view.repainted = false;
949     view.setIconSize(QSize(10000, 10000));
950     QTRY_VERIFY(view.repainted);
951     QCOMPARE(view.iconSize(), QSize(10000, 10000));
952 }
953 
954 void tst_QTreeView::indexAt()
955 {
956     QtTestModel model(5, 5);
957 
958     QTreeView view;
959     QCOMPARE(view.indexAt(QPoint()), QModelIndex());
960     view.setModel(&model);
961     QVERIFY(view.indexAt(QPoint()) != QModelIndex());
962 
963     QSize itemSize = view.visualRect(model.index(0, 0)).size();
964     for (int i = 0; i < model.rowCount(); ++i) {
965         QPoint pos(itemSize.width() / 2, (i * itemSize.height()) + (itemSize.height() / 2));
966         QModelIndex index = view.indexAt(pos);
967         QCOMPARE(index, model.index(i, 0));
968     }
969 
970     /*
971       // ### this is wrong; the widget _will_ affect the item size
972     for (int j = 0; j < model.rowCount(); ++j)
973         view.setIndexWidget(model.index(j, 0), new QPushButton);
974     */
975 
976     for (int k = 0; k < model.rowCount(); ++k) {
977         QPoint pos(itemSize.width() / 2, (k * itemSize.height()) + (itemSize.height() / 2));
978         QModelIndex index = view.indexAt(pos);
979         QCOMPARE(index, model.index(k, 0));
980     }
981 
982     view.show();
983     view.resize(600, 600);
984     view.header()->setStretchLastSection(false);
985     QCOMPARE(view.indexAt(QPoint(550, 20)), QModelIndex());
986 }
987 
988 void tst_QTreeView::indexWidget()
989 {
990     QTreeView view;
991     QStandardItemModel treeModel;
992     initStandardTreeModel(&treeModel);
993     view.setModel(&treeModel);
994     view.resize(300, 400);  // make sure the width of the view is larger than the widgets below
995 
996     QModelIndex index = view.model()->index(0, 0);
997 
998     QVERIFY(!view.indexWidget(QModelIndex()));
999     QVERIFY(!view.indexWidget(index));
1000 
1001     QString text = QLatin1String("TestLabel");
1002 
1003     QWidget *label = new QLabel(text);
1004     view.setIndexWidget(QModelIndex(), label);
1005     QVERIFY(!view.indexWidget(QModelIndex()));
1006     QVERIFY(!label->parent());
1007     view.setIndexWidget(index, label);
1008     QCOMPARE(view.indexWidget(index), label);
1009     QCOMPARE(label->parentWidget(), view.viewport());
1010 
1011 
1012     QTextEdit *widget = new QTextEdit(text);
1013     widget->setFixedSize(200,100);
1014     view.setIndexWidget(index, widget);
1015     QCOMPARE(view.indexWidget(index), static_cast<QWidget *>(widget));
1016 
1017     QCOMPARE(widget->parentWidget(), view.viewport());
1018     QCOMPARE(widget->geometry(), view.visualRect(index).intersected(widget->geometry()));
1019     QCOMPARE(widget->toPlainText(), text);
1020 
1021     //now let's try to do that later when the widget is already shown
1022     view.show();
1023     QVERIFY(QTest::qWaitForWindowExposed(&view));
1024     index = view.model()->index(1, 0);
1025     QVERIFY(!view.indexWidget(index));
1026 
1027     widget = new QTextEdit(text);
1028     widget->setFixedSize(200,100);
1029     view.setIndexWidget(index, widget);
1030     QCOMPARE(view.indexWidget(index), static_cast<QWidget *>(widget));
1031 
1032     QCOMPARE(widget->parentWidget(), view.viewport());
1033     QCOMPARE(widget->geometry(), view.visualRect(index).intersected(widget->geometry()));
1034     QCOMPARE(widget->toPlainText(), text);
1035 }
1036 
1037 void tst_QTreeView::itemDelegate()
1038 {
1039     QPointer<QAbstractItemDelegate> oldDelegate;
1040     QPointer<QStyledItemDelegate> otherItemDelegate;
1041 
1042     {
1043         QTreeView view;
1044         QVERIFY(qobject_cast<QStyledItemDelegate *>(view.itemDelegate()));
1045         QPointer<QAbstractItemDelegate> oldDelegate = view.itemDelegate();
1046 
1047         otherItemDelegate = new QStyledItemDelegate;
1048         view.setItemDelegate(otherItemDelegate);
1049         QVERIFY(!otherItemDelegate->parent());
1050         QVERIFY(oldDelegate);
1051 
1052         QCOMPARE(view.itemDelegate(), otherItemDelegate);
1053 
1054         view.setItemDelegate(nullptr);
1055         QVERIFY(!view.itemDelegate()); // <- view does its own drawing?
1056         QVERIFY(otherItemDelegate);
1057     }
1058 
1059     // This is strange. Why doesn't setItemDelegate() reparent the delegate?
1060     QVERIFY(!oldDelegate);
1061     QVERIFY(otherItemDelegate);
1062 
1063     delete otherItemDelegate;
1064 }
1065 
1066 void tst_QTreeView::itemDelegateForColumnOrRow()
1067 {
1068     QTreeView view;
1069     QAbstractItemDelegate *defaultDelegate = view.itemDelegate();
1070     QVERIFY(defaultDelegate);
1071 
1072     QVERIFY(!view.itemDelegateForRow(0));
1073     QVERIFY(!view.itemDelegateForColumn(0));
1074     QCOMPARE(view.itemDelegateForIndex(QModelIndex()), defaultDelegate);
1075 
1076     QStandardItemModel model;
1077     for (int i = 0; i < 100; ++i) {
1078         model.appendRow(QList<QStandardItem *>()
1079                         << new QStandardItem("An item that has very long text and should"
1080                                              " cause the horizontal scroll bar to appear.")
1081                         << new QStandardItem("An item that has very long text and should"
1082                                              " cause the horizontal scroll bar to appear.")
1083                         << new QStandardItem("An item that has very long text and should"
1084                                              " cause the horizontal scroll bar to appear."));
1085     }
1086     view.setModel(&model);
1087 
1088     QVERIFY(!view.itemDelegateForRow(0));
1089     QVERIFY(!view.itemDelegateForColumn(0));
1090     QCOMPARE(view.itemDelegateForIndex(QModelIndex()), defaultDelegate);
1091     QCOMPARE(view.itemDelegateForIndex(view.model()->index(0, 0)), defaultDelegate);
1092 
1093     QPointer<QAbstractItemDelegate> rowDelegate = new QStyledItemDelegate;
1094     view.setItemDelegateForRow(0, rowDelegate);
1095     QVERIFY(!rowDelegate->parent());
1096     QCOMPARE(view.itemDelegateForRow(0), rowDelegate);
1097     QCOMPARE(view.itemDelegateForIndex(view.model()->index(0, 0)), rowDelegate);
1098     QCOMPARE(view.itemDelegateForIndex(view.model()->index(0, 1)), rowDelegate);
1099     QCOMPARE(view.itemDelegateForIndex(view.model()->index(1, 0)), defaultDelegate);
1100     QCOMPARE(view.itemDelegateForIndex(view.model()->index(1, 1)), defaultDelegate);
1101 
1102     QPointer<QAbstractItemDelegate> columnDelegate = new QStyledItemDelegate;
1103     view.setItemDelegateForColumn(1, columnDelegate);
1104     QVERIFY(!columnDelegate->parent());
1105     QCOMPARE(view.itemDelegateForColumn(1), columnDelegate);
1106     QCOMPARE(view.itemDelegateForIndex(view.model()->index(0, 0)), rowDelegate);
1107     QCOMPARE(view.itemDelegateForIndex(view.model()->index(0, 1)), rowDelegate); // row wins
1108     QCOMPARE(view.itemDelegateForIndex(view.model()->index(1, 0)), defaultDelegate);
1109     QCOMPARE(view.itemDelegateForIndex(view.model()->index(1, 1)), columnDelegate);
1110 
1111     view.setItemDelegateForRow(0, nullptr);
1112     QVERIFY(!view.itemDelegateForRow(0));
1113     QVERIFY(rowDelegate); // <- wasn't deleted
1114 
1115     view.setItemDelegateForColumn(1, nullptr);
1116     QVERIFY(!view.itemDelegateForColumn(1));
1117     QVERIFY(columnDelegate); // <- wasn't deleted
1118 
1119     delete rowDelegate;
1120     delete columnDelegate;
1121 }
1122 
1123 void tst_QTreeView::keyboardSearch()
1124 {
1125     QTreeView view;
1126     QStandardItemModel model;
1127     model.appendRow(new QStandardItem("Andreas"));
1128     model.appendRow(new QStandardItem("Baldrian"));
1129     model.appendRow(new QStandardItem("Cecilie"));
1130     view.setModel(&model);
1131     view.show();
1132 
1133     // Nothing is selected
1134     QVERIFY(!view.selectionModel()->hasSelection());
1135     QVERIFY(!view.selectionModel()->isSelected(model.index(0, 0)));
1136 
1137     // First item is selected
1138     view.keyboardSearch(QLatin1String("A"));
1139     QTRY_VERIFY(view.selectionModel()->isSelected(model.index(0, 0)));
1140 
1141     // First item is still selected
1142     view.keyboardSearch(QLatin1String("n"));
1143     QVERIFY(view.selectionModel()->isSelected(model.index(0, 0)));
1144 
1145     // No "AnB" item - keep the same selection.
1146     view.keyboardSearch(QLatin1String("B"));
1147     QVERIFY(view.selectionModel()->isSelected(model.index(0, 0)));
1148 
1149     // Wait a bit.
1150     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1151 
1152     // The item that starts with B is selected.
1153     view.keyboardSearch(QLatin1String("B"));
1154     QVERIFY(view.selectionModel()->isSelected(model.index(1, 0)));
1155 
1156     // Test that it wraps round
1157     model.appendRow(new QStandardItem("Andy"));
1158     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1159     view.keyboardSearch(QLatin1String("A"));
1160     QVERIFY(view.selectionModel()->isSelected(model.index(3, 0)));
1161     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1162     view.keyboardSearch(QLatin1String("A"));
1163     QVERIFY(view.selectionModel()->isSelected(model.index(0, 0)));
1164     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1165     view.keyboardSearch(QLatin1String("A"));
1166     QVERIFY(view.selectionModel()->isSelected(model.index(3, 0)));
1167 
1168     // Test that it handles the case where the first item is hidden correctly
1169     model.insertRow(0, new QStandardItem("Hidden item"));
1170     view.setRowHidden(0, QModelIndex(), true);
1171 
1172     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1173     view.keyboardSearch(QLatin1String("A"));
1174     QVERIFY(view.selectionModel()->isSelected(model.index(1, 0)));
1175     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1176     view.keyboardSearch(QLatin1String("A"));
1177     QVERIFY(view.selectionModel()->isSelected(model.index(4, 0)));
1178     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1179     view.keyboardSearch(QLatin1String("A"));
1180     QVERIFY(view.selectionModel()->isSelected(model.index(1, 0)));
1181 
1182     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1183     model.clear();
1184     view.setCurrentIndex(QModelIndex());
1185     model.appendRow({ new QStandardItem("Andreas"), new QStandardItem("Alicia") });
1186     model.appendRow({ new QStandardItem("Baldrian"), new QStandardItem("Belinda") });
1187     model.appendRow({ new QStandardItem("Cecilie"), new QStandardItem("Claire") });
1188     QVERIFY(!view.selectionModel()->hasSelection());
1189     QVERIFY(!view.selectionModel()->isSelected(model.index(0, 0)));
1190 
1191     // We want to search on the 2nd column so we have to force it to have
1192     // an index in that column as a starting point
1193     view.setCurrentIndex(QModelIndex(model.index(0, 1)));
1194     // Second item in first row is selected
1195     view.keyboardSearch(QLatin1String("A"));
1196     QTRY_VERIFY(view.selectionModel()->isSelected(model.index(0, 1)));
1197     QVERIFY(view.currentIndex() == model.index(0, 1));
1198 
1199     // Second item in first row is still selected
1200     view.keyboardSearch(QLatin1String("l"));
1201     QVERIFY(view.selectionModel()->isSelected(model.index(0, 1)));
1202     QCOMPARE(view.currentIndex(), model.index(0, 1));
1203 
1204     // No "AnB" item - keep the same selection.
1205     view.keyboardSearch(QLatin1String("B"));
1206     QVERIFY(view.selectionModel()->isSelected(model.index(0, 1)));
1207     QCOMPARE(view.currentIndex(), model.index(0, 1));
1208 
1209     // Wait a bit.
1210     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1211 
1212     // The item that starts with B is selected.
1213     view.keyboardSearch(QLatin1String("B"));
1214     QVERIFY(view.selectionModel()->isSelected(model.index(1, 1)));
1215     QCOMPARE(view.currentIndex(), model.index(1, 1));
1216 
1217     // Test that it wraps round
1218     model.appendRow({ new QStandardItem("Andy"), new QStandardItem("Adele") });
1219     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1220     view.keyboardSearch(QLatin1String("A"));
1221     QVERIFY(view.selectionModel()->isSelected(model.index(3, 1)));
1222     QCOMPARE(view.currentIndex(), model.index(3, 1));
1223     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1224     view.keyboardSearch(QLatin1String("A"));
1225     QVERIFY(view.selectionModel()->isSelected(model.index(0, 1)));
1226     QCOMPARE(view.currentIndex(), model.index(0, 1));
1227     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1228     view.keyboardSearch(QLatin1String("A"));
1229     QVERIFY(view.selectionModel()->isSelected(model.index(3, 1)));
1230     QCOMPARE(view.currentIndex(), model.index(3, 1));
1231 
1232     // Test that it handles the case where the first item is hidden correctly
1233     model.insertRow(0, new QStandardItem("Hidden item"));
1234     view.setRowHidden(0, QModelIndex(), true);
1235 
1236     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1237     view.keyboardSearch(QLatin1String("A"));
1238     QVERIFY(view.selectionModel()->isSelected(model.index(1, 1)));
1239     QCOMPARE(view.currentIndex(), model.index(1, 1));
1240     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1241     view.keyboardSearch(QLatin1String("A"));
1242     QVERIFY(view.selectionModel()->isSelected(model.index(4, 1)));
1243     QCOMPARE(view.currentIndex(), model.index(4, 1));
1244     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1245     view.keyboardSearch(QLatin1String("A"));
1246     QVERIFY(view.selectionModel()->isSelected(model.index(1, 1)));
1247     QCOMPARE(view.currentIndex(), model.index(1, 1));
1248 }
1249 
1250 void tst_QTreeView::keyboardSearchMultiColumn()
1251 {
1252     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
1253         QSKIP("Wayland: This fails. Figure out why.");
1254 
1255     QTreeView view;
1256     QStandardItemModel model(4, 2);
1257 
1258     model.setItem(0, 0, new QStandardItem("1"));    model.setItem(0, 1, new QStandardItem("green"));
1259     model.setItem(1, 0, new QStandardItem("bad"));  model.setItem(1, 1, new QStandardItem("eggs"));
1260     model.setItem(2, 0, new QStandardItem("moof")); model.setItem(2, 1, new QStandardItem("and"));
1261     model.setItem(3, 0, new QStandardItem("elf"));  model.setItem(3, 1, new QStandardItem("ham"));
1262 
1263     view.setModel(&model);
1264     view.show();
1265     QApplication::setActiveWindow(&view);
1266     QVERIFY(QTest::qWaitForWindowActive(&view));
1267 
1268     view.setCurrentIndex(model.index(0, 1));
1269 
1270     // First item is selected
1271     view.keyboardSearch(QLatin1String("eggs"));
1272     QVERIFY(view.selectionModel()->isSelected(model.index(1, 1)));
1273 
1274     QTest::qWait(QApplication::keyboardInputInterval() * 2);
1275 
1276     // 'ham' is selected
1277     view.keyboardSearch(QLatin1String("h"));
1278     QVERIFY(view.selectionModel()->isSelected(model.index(3, 1)));
1279 }
1280 
1281 void tst_QTreeView::setModel()
1282 {
1283     QTreeView view;
1284     view.show();
1285     QCOMPARE(view.model(), nullptr);
1286     QCOMPARE(view.selectionModel(), nullptr);
1287     QCOMPARE(view.header()->model(), nullptr);
1288     QCOMPARE(view.header()->selectionModel(), nullptr);
1289 
1290     for (int x = 0; x < 2; ++x) {
1291         QtTestModel *model = new QtTestModel(10, 8);
1292         QAbstractItemModel *oldModel = view.model();
1293         QSignalSpy modelDestroyedSpy(oldModel ? oldModel : model, &QObject::destroyed);
1294         // set the same model twice
1295         for (int i = 0; i < 2; ++i) {
1296             QItemSelectionModel *oldSelectionModel = view.selectionModel();
1297             QItemSelectionModel *dummy = new QItemSelectionModel(model);
1298             QSignalSpy selectionModelDestroyedSpy(
1299                 oldSelectionModel ? oldSelectionModel : dummy, &QObject::destroyed);
1300             view.setModel(model);
1301 //                QCOMPARE(selectionModelDestroyedSpy.count(), (x == 0 || i == 1) ? 0 : 1);
1302             QCOMPARE(view.model(), model);
1303             QCOMPARE(view.header()->model(), model);
1304             QCOMPARE(view.selectionModel() != oldSelectionModel, (i == 0));
1305         }
1306         QTRY_COMPARE(modelDestroyedSpy.count(), 0);
1307 
1308         view.setModel(nullptr);
1309         QCOMPARE(view.model(), nullptr);
1310         // ### shouldn't selectionModel also be 0 now?
1311 //        QCOMPARE(view.selectionModel(), nullptr);
1312         delete model;
1313     }
1314 }
1315 
1316 void tst_QTreeView::openPersistentEditor()
1317 {
1318     QTreeView view;
1319     QStandardItemModel treeModel;
1320     initStandardTreeModel(&treeModel);
1321     view.setModel(&treeModel);
1322     view.show();
1323 
1324     QVERIFY(!view.viewport()->findChild<QLineEdit *>());
1325     view.openPersistentEditor(view.model()->index(0, 0));
1326     QVERIFY(view.viewport()->findChild<QLineEdit *>());
1327 
1328     view.closePersistentEditor(view.model()->index(0, 0));
1329     QVERIFY(!view.viewport()->findChild<QLineEdit *>()->isVisible());
1330 
1331     QCoreApplication::sendPostedEvents(nullptr, QEvent::DeferredDelete);
1332     QVERIFY(!view.viewport()->findChild<QLineEdit *>());
1333 }
1334 
1335 void tst_QTreeView::rootIndex()
1336 {
1337     QTreeView view;
1338     QCOMPARE(view.rootIndex(), QModelIndex());
1339     QStandardItemModel treeModel;
1340     initStandardTreeModel(&treeModel);
1341     view.setModel(&treeModel);
1342     QCOMPARE(view.rootIndex(), QModelIndex());
1343 
1344     view.setRootIndex(view.model()->index(1, 0));
1345 
1346     QCOMPARE(view.model()->data(view.model()->index(0, view.header()->visualIndex(0), view.rootIndex()), Qt::DisplayRole)
1347              .toString(), QString("Row 2 Child Item"));
1348 }
1349 
1350 void tst_QTreeView::setHeader()
1351 {
1352     QTreeView view;
1353     QVERIFY(view.header() != nullptr);
1354     QCOMPARE(view.header()->orientation(), Qt::Horizontal);
1355     QCOMPARE(view.header()->parent(), &view);
1356     for (int x = 0; x < 2; ++x) {
1357         QSignalSpy destroyedSpy(view.header(), &QObject::destroyed);
1358         Qt::Orientation orient = x ? Qt::Vertical : Qt::Horizontal;
1359         QHeaderView *head = new QHeaderView(orient);
1360         view.setHeader(head);
1361         QCOMPARE(destroyedSpy.count(), 1);
1362         QCOMPARE(head->parent(), &view);
1363         QCOMPARE(view.header(), head);
1364         view.setHeader(head);
1365         QCOMPARE(view.header(), head);
1366         view.setHeader(nullptr);
1367         QCOMPARE(view.header(), head);
1368     }
1369 }
1370 
1371 void tst_QTreeView::columnHidden()
1372 {
1373     QTreeView view;
1374     QtTestModel model(10, 8);
1375     view.setModel(&model);
1376     view.show();
1377     for (int c = 0; c < model.columnCount(); ++c)
1378         QCOMPARE(view.isColumnHidden(c), false);
1379     // hide even columns
1380     for (int c = 0; c < model.columnCount(); c += 2)
1381         view.setColumnHidden(c, true);
1382     for (int c = 0; c < model.columnCount(); ++c)
1383         QCOMPARE(view.isColumnHidden(c), (c & 1) == 0);
1384     view.update();
1385     // hide odd columns too
1386     for (int c = 1; c < model.columnCount(); c += 2)
1387         view.setColumnHidden(c, true);
1388     for (int c = 0; c < model.columnCount(); ++c)
1389         QCOMPARE(view.isColumnHidden(c), true);
1390     view.update();
1391 
1392     // QTBUG 54610
1393     // QAbstractItemViewPrivate::_q_layoutChanged() is called on
1394     // rows/columnMoved and because this function is virtual,
1395     // QHeaderViewPrivate::_q_layoutChanged() was called and unhided
1396     // all sections because QHeaderViewPrivate::_q_layoutAboutToBeChanged()
1397     // could not fill persistentHiddenSections (and is not needed)
1398     view.hideColumn(model.cols - 1);
1399     QCOMPARE(view.isColumnHidden(model.cols - 1), true);
1400     model.simulateMoveRows();
1401     QCOMPARE(view.isColumnHidden(model.cols - 1), true);
1402 }
1403 
1404 void tst_QTreeView::rowHidden()
1405 {
1406     QtTestModel model(4, 6);
1407     model.levels = 3;
1408     QTreeView view;
1409     view.resize(500,500);
1410     view.setModel(&model);
1411     view.show();
1412 
1413     QCOMPARE(view.isRowHidden(-1, QModelIndex()), false);
1414     QCOMPARE(view.isRowHidden(999999, QModelIndex()), false);
1415     view.setRowHidden(-1, QModelIndex(), true);
1416     view.setRowHidden(999999, QModelIndex(), true);
1417     QCOMPARE(view.isRowHidden(-1, QModelIndex()), false);
1418     QCOMPARE(view.isRowHidden(999999, QModelIndex()), false);
1419 
1420     view.setRowHidden(0, QModelIndex(), true);
1421     QCOMPARE(view.isRowHidden(0, QModelIndex()), true);
1422     view.setRowHidden(0, QModelIndex(), false);
1423     QCOMPARE(view.isRowHidden(0, QModelIndex()), false);
1424 
1425     QStack<QModelIndex> parents;
1426     parents.push(QModelIndex());
1427     while (!parents.isEmpty()) {
1428         QModelIndex p = parents.pop();
1429         if (model.canFetchMore(p))
1430             model.fetchMore(p);
1431         int rows = model.rowCount(p);
1432         // hide all
1433         for (int r = 0; r < rows; ++r) {
1434             view.setRowHidden(r, p, true);
1435             QCOMPARE(view.isRowHidden(r, p), true);
1436         }
1437         // hide none
1438         for (int r = 0; r < rows; ++r) {
1439             view.setRowHidden(r, p, false);
1440             QCOMPARE(view.isRowHidden(r, p), false);
1441         }
1442         // hide only even rows
1443         for (int r = 0; r < rows; ++r) {
1444             bool hide = (r & 1) == 0;
1445             view.setRowHidden(r, p, hide);
1446             QCOMPARE(view.isRowHidden(r, p), hide);
1447         }
1448         for (int r = 0; r < rows; ++r)
1449             parents.push(model.index(r, 0, p));
1450     }
1451 
1452     parents.push(QModelIndex());
1453     while (!parents.isEmpty()) {
1454         QModelIndex p = parents.pop();
1455         // all even rows should still be hidden
1456         for (int r = 0; r < model.rowCount(p); ++r)
1457             QCOMPARE(view.isRowHidden(r, p), (r & 1) == 0);
1458         if (model.rowCount(p) > 0) {
1459             for (int r = 0; r < model.rowCount(p); ++r)
1460                 parents.push(model.index(r, 0, p));
1461         }
1462     }
1463 }
1464 
1465 void tst_QTreeView::noDelegate()
1466 {
1467     QtTestModel model(10, 7);
1468     QTreeView view;
1469     view.setModel(&model);
1470     view.setItemDelegate(nullptr);
1471     QCOMPARE(view.itemDelegate(), nullptr);
1472 }
1473 
1474 void tst_QTreeView::noModel()
1475 {
1476     QTreeView view;
1477     view.show();
1478     view.setRowHidden(0, QModelIndex(), true);
1479     // no model -> not able to hide a row
1480     QVERIFY(!view.isRowHidden(0, QModelIndex()));
1481 }
1482 
1483 void tst_QTreeView::emptyModel()
1484 {
1485     QtTestModel model(0, 0);
1486     QTreeView view;
1487     view.setModel(&model);
1488     view.show();
1489     QVERIFY(!model.wrongIndex);
1490 }
1491 
1492 void tst_QTreeView::removeRows()
1493 {
1494     QtTestModel model(7, 10);
1495 
1496     QTreeView view;
1497 
1498     view.setModel(&model);
1499     view.show();
1500 
1501     model.removeLastRow();
1502     QVERIFY(!model.wrongIndex);
1503 
1504     model.removeAllRows();
1505     QVERIFY(!model.wrongIndex);
1506 }
1507 
1508 void tst_QTreeView::removeCols()
1509 {
1510     QtTestModel model(5, 8);
1511 
1512     QTreeView view;
1513     view.setModel(&model);
1514     view.show();
1515     model.fetched = true;
1516     model.removeLastColumn();
1517     QVERIFY(!model.wrongIndex);
1518     QCOMPARE(view.header()->count(), model.cols);
1519 
1520     model.removeAllColumns();
1521     QVERIFY(!model.wrongIndex);
1522     QCOMPARE(view.header()->count(), model.cols);
1523 }
1524 
1525 void tst_QTreeView::limitedExpand()
1526 {
1527     {
1528         QStandardItemModel model;
1529         QStandardItem *parentItem = model.invisibleRootItem();
1530         parentItem->appendRow(new QStandardItem);
1531         parentItem->appendRow(new QStandardItem);
1532         parentItem->appendRow(new QStandardItem);
1533 
1534         QStandardItem *firstItem = model.item(0, 0);
1535         firstItem->setFlags(firstItem->flags() | Qt::ItemNeverHasChildren);
1536 
1537         QTreeView view;
1538         view.setModel(&model);
1539 
1540         QSignalSpy spy(&view, &QTreeView::expanded);
1541         QVERIFY(spy.isValid());
1542 
1543         view.expand(model.index(0, 0));
1544         QCOMPARE(spy.count(), 0);
1545 
1546         view.expand(model.index(1, 0));
1547         QCOMPARE(spy.count(), 1);
1548     }
1549     {
1550         QStringListModel model(QStringList() << "one" << "two");
1551         QTreeView view;
1552         view.setModel(&model);
1553 
1554         QSignalSpy spy(&view, &QTreeView::expanded);
1555         QVERIFY(spy.isValid());
1556 
1557         view.expand(model.index(0, 0));
1558         QCOMPARE(spy.count(), 0);
1559         view.expandAll();
1560         QCOMPARE(spy.count(), 0);
1561     }
1562 }
1563 
1564 void tst_QTreeView::expandAndCollapse_data()
1565 {
1566     QTest::addColumn<bool>("animationEnabled");
1567     QTest::newRow("normal") << false;
1568     QTest::newRow("animated") << true;
1569 }
1570 
1571 void tst_QTreeView::expandAndCollapse()
1572 {
1573     QFETCH(bool, animationEnabled);
1574 
1575     QtTestModel model(10, 9);
1576 
1577     QTreeView view;
1578     view.setUniformRowHeights(true);
1579     view.setModel(&model);
1580     view.setAnimated(animationEnabled);
1581     view.show();
1582 
1583     QModelIndex a = model.index(0, 0, QModelIndex());
1584     QModelIndex b = model.index(0, 0, a);
1585 
1586     QSignalSpy expandedSpy(&view, &QTreeView::expanded);
1587     QSignalSpy collapsedSpy(&view, &QTreeView::collapsed);
1588     QVariantList args;
1589 
1590     for (int y = 0; y < 2; ++y) {
1591         view.setVisible(y == 0);
1592         for (int x = 0; x < 2; ++x) {
1593             view.setItemsExpandable(x == 0);
1594 
1595             // Test bad args
1596             view.expand(QModelIndex());
1597             QCOMPARE(view.isExpanded(QModelIndex()), false);
1598             view.collapse(QModelIndex());
1599             QCOMPARE(expandedSpy.count(), 0);
1600             QCOMPARE(collapsedSpy.count(), 0);
1601 
1602             // expand a first level item
1603             QVERIFY(!view.isExpanded(a));
1604             view.expand(a);
1605             QVERIFY(view.isExpanded(a));
1606             QCOMPARE(expandedSpy.count(), 1);
1607             QCOMPARE(collapsedSpy.count(), 0);
1608             args = expandedSpy.takeFirst();
1609             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), a);
1610 
1611             view.expand(a);
1612             QVERIFY(view.isExpanded(a));
1613             QCOMPARE(expandedSpy.count(), 0);
1614             QCOMPARE(collapsedSpy.count(), 0);
1615 
1616             // expand a second level item
1617             QVERIFY(!view.isExpanded(b));
1618             view.expand(b);
1619             QVERIFY(view.isExpanded(a));
1620             QVERIFY(view.isExpanded(b));
1621             QCOMPARE(expandedSpy.count(), 1);
1622             QCOMPARE(collapsedSpy.count(), 0);
1623             args = expandedSpy.takeFirst();
1624             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), b);
1625 
1626             view.expand(b);
1627             QVERIFY(view.isExpanded(b));
1628             QCOMPARE(expandedSpy.count(), 0);
1629             QCOMPARE(collapsedSpy.count(), 0);
1630 
1631             // collapse the first level item
1632             view.collapse(a);
1633             QVERIFY(!view.isExpanded(a));
1634             QVERIFY(view.isExpanded(b));
1635             QCOMPARE(expandedSpy.count(), 0);
1636             QCOMPARE(collapsedSpy.count(), 1);
1637             args = collapsedSpy.takeFirst();
1638             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), a);
1639 
1640             view.collapse(a);
1641             QVERIFY(!view.isExpanded(a));
1642             QCOMPARE(expandedSpy.count(), 0);
1643             QCOMPARE(collapsedSpy.count(), 0);
1644 
1645             // expand the first level item again
1646             view.expand(a);
1647             QVERIFY(view.isExpanded(a));
1648             QVERIFY(view.isExpanded(b));
1649             QCOMPARE(expandedSpy.count(), 1);
1650             QCOMPARE(collapsedSpy.count(), 0);
1651             args = expandedSpy.takeFirst();
1652             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), a);
1653 
1654             // collapse the second level item
1655             view.collapse(b);
1656             QVERIFY(view.isExpanded(a));
1657             QVERIFY(!view.isExpanded(b));
1658             QCOMPARE(expandedSpy.count(), 0);
1659             QCOMPARE(collapsedSpy.count(), 1);
1660             args = collapsedSpy.takeFirst();
1661             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), b);
1662 
1663             // collapse the first level item
1664             view.collapse(a);
1665             QVERIFY(!view.isExpanded(a));
1666             QVERIFY(!view.isExpanded(b));
1667             QCOMPARE(expandedSpy.count(), 0);
1668             QCOMPARE(collapsedSpy.count(), 1);
1669             args = collapsedSpy.takeFirst();
1670             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), a);
1671 
1672             // expand and remove row
1673             QPersistentModelIndex c = model.index(9, 0, b);
1674             view.expand(a);
1675             view.expand(b);
1676             model.removeLastRow(); // remove c
1677             QVERIFY(view.isExpanded(a));
1678             QVERIFY(view.isExpanded(b));
1679             QVERIFY(!view.isExpanded(c));
1680             QCOMPARE(expandedSpy.count(), 2);
1681             QCOMPARE(collapsedSpy.count(), 0);
1682             args = expandedSpy.takeFirst();
1683             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), a);
1684             args = expandedSpy.takeFirst();
1685             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), b);
1686 
1687             view.collapse(a);
1688             view.collapse(b);
1689             QVERIFY(!view.isExpanded(a));
1690             QVERIFY(!view.isExpanded(b));
1691             QVERIFY(!view.isExpanded(c));
1692             QCOMPARE(expandedSpy.count(), 0);
1693             QCOMPARE(collapsedSpy.count(), 2);
1694             args = collapsedSpy.takeFirst();
1695             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), a);
1696             args = collapsedSpy.takeFirst();
1697             QCOMPARE(qvariant_cast<QModelIndex>(args.at(0)), b);
1698         }
1699     }
1700 }
1701 
1702 static void checkExpandState(const QAbstractItemModel &model, const QTreeView &view,
1703                              const QModelIndex &startIdx, bool bIsExpanded, int *count)
1704 {
1705     *count = 0;
1706     QStack<QModelIndex> parents;
1707     parents.push(startIdx);
1708     if (startIdx.isValid()) {
1709         QCOMPARE(view.isExpanded(startIdx), bIsExpanded);
1710         *count += 1;
1711     }
1712     while (!parents.isEmpty()) {
1713         const QModelIndex p = parents.pop();
1714         const int rows = model.rowCount(p);
1715         for (int r = 0; r < rows; ++r) {
1716             const QModelIndex c = model.index(r, 0, p);
1717             QCOMPARE(view.isExpanded(c), bIsExpanded);
1718             parents.push(c);
1719         }
1720         *count += rows;
1721     }
1722 }
1723 
1724 void tst_QTreeView::expandAndCollapseAll()
1725 {
1726     QStandardItemModel model;
1727     // QtTestModel has a broken parent/child handling which will break the test
1728     for (int i1 = 0; i1 < 3; ++i1) {
1729         QStandardItem *s1 = new QStandardItem;
1730         s1->setText(QString::number(i1));
1731         model.appendRow(s1);
1732         for (int i2 = 0; i2 < 3; ++i2) {
1733             QStandardItem *s2 = new QStandardItem;
1734             s2->setText(QStringLiteral("%1 - %2").arg(i1).arg(i2));
1735             s1->appendRow(s2);
1736             for (int i3 = 0; i3 < 3; ++i3) {
1737                 QStandardItem *s3 = new QStandardItem;
1738                 s3->setText(QStringLiteral("%1 - %2 - %3").arg(i1).arg(i2).arg(i3));
1739                 s2->appendRow(s3);
1740             }
1741         }
1742     }
1743     QTreeView view;
1744     view.setUniformRowHeights(true);
1745     view.setModel(&model);
1746     view.show();
1747     QVERIFY(QTest::qWaitForWindowExposed(&view));
1748 
1749     QSignalSpy expandedSpy(&view, &QTreeView::expanded);
1750     QSignalSpy collapsedSpy(&view, &QTreeView::collapsed);
1751     int count;
1752 
1753     view.expandAll();
1754     checkExpandState(model, view, QModelIndex(), true, &count);
1755     QCOMPARE(collapsedSpy.count(), 0);
1756     QCOMPARE(expandedSpy.count(),  39); // == 3 (first) + 9 (second) + 27 (third level)
1757     QCOMPARE(count, 39);
1758 
1759     collapsedSpy.clear();
1760     expandedSpy.clear();
1761     view.collapseAll();
1762     checkExpandState(model, view, QModelIndex(), false, &count);
1763     QCOMPARE(collapsedSpy.count(), 39);
1764     QCOMPARE(expandedSpy.count(), 0);
1765     QCOMPARE(count, 39);
1766 
1767     collapsedSpy.clear();
1768     expandedSpy.clear();
1769     view.expandRecursively(model.index(0, 0));
1770     QCOMPARE(expandedSpy.count(), 13); // 1 + 3 + 9
1771 
1772     checkExpandState(model, view, model.index(0, 0), true, &count);
1773     QCOMPARE(count, 13);
1774     checkExpandState(model, view, model.index(1, 0), false, &count);
1775     QCOMPARE(count, 13);
1776     checkExpandState(model, view, model.index(2, 0), false, &count);
1777     QCOMPARE(count, 13);
1778 
1779     expandedSpy.clear();
1780     view.collapseAll();
1781     view.expandRecursively(model.index(0, 0), 1);
1782     QCOMPARE(expandedSpy.count(), 4); // 1 + 3
1783     view.expandRecursively(model.index(0, 0), 2);
1784     QCOMPARE(expandedSpy.count(), 13); // (1 + 3) + 9
1785 
1786     checkExpandState(model, view, model.index(0, 0), true, &count);
1787     QCOMPARE(count, 13);
1788     checkExpandState(model, view, model.index(1, 0), false, &count);
1789     QCOMPARE(count, 13);
1790     checkExpandState(model, view, model.index(2, 0), false, &count);
1791     QCOMPARE(count, 13);
1792 }
1793 
1794 void tst_QTreeView::expandWithNoChildren()
1795 {
1796     QTreeView tree;
1797     QStandardItemModel model(1, 1);
1798     tree.setModel(&model);
1799     tree.setAnimated(true);
1800     tree.doItemsLayout();
1801     //this test should not output warnings
1802     tree.expand(model.index(0,0));
1803 }
1804 
1805 static void populateModel(QStandardItemModel *model)
1806 {
1807     const int depth = 10;
1808     for (int i1 = 0; i1 < depth; ++i1) {
1809         QStandardItem *s1 = new QStandardItem;
1810         s1->setText(QString::number(i1));
1811         model->appendRow(s1);
1812         for (int i2 = 0; i2 < depth; ++i2) {
1813             QStandardItem *s2 = new QStandardItem;
1814             s2->setText(QStringLiteral("%1 - %2").arg(i1).arg(i2));
1815             s1->appendRow(s2);
1816             for (int i3 = 0; i3 < depth; ++i3) {
1817                 QStandardItem *s3 = new QStandardItem;
1818                 s3->setText(QStringLiteral("%1 - %2 - %3").arg(i1).arg(i2).arg(i3));
1819                 s2->appendRow(s3);
1820             }
1821         }
1822     }
1823 }
1824 
1825 void tst_QTreeView::taskQTBUG_88966_expandAfterTake()
1826 {
1827     QStandardItemModel model;
1828     populateModel(&model);
1829     QTreeView view;
1830     view.setUniformRowHeights(true);
1831     view.setModel(&model);
1832     view.show();
1833     QVERIFY(QTest::qWaitForWindowExposed(&view));
1834 
1835     view.expandAll();
1836     while (model.takeItem(0))
1837         ; // mimic clear, but leave QTreeViewPrivate::expandedIndexes dirty
1838 
1839     populateModel(&model); // populate model again
1840     view.expandAll(); // add new items to QTreeViewPrivate::expandedIndexes; if corrupted, may crash
1841 }
1842 
1843 void tst_QTreeView::keyboardNavigation()
1844 {
1845     const int rows = 10;
1846     const int columns = 7;
1847 
1848     QtTestModel model(rows, columns);
1849 
1850     QTreeView view;
1851     view.setModel(&model);
1852     view.show();
1853 
1854     const auto keymoves = {
1855         Qt::Key_Down, Qt::Key_Right, Qt::Key_Right, Qt::Key_Right,
1856         Qt::Key_Down, Qt::Key_Down, Qt::Key_Down, Qt::Key_Down,
1857         Qt::Key_Right, Qt::Key_Right, Qt::Key_Right,
1858         Qt::Key_Left, Qt::Key_Up, Qt::Key_Left, Qt::Key_Left,
1859         Qt::Key_Up, Qt::Key_Down, Qt::Key_Up, Qt::Key_Up,
1860         Qt::Key_Up, Qt::Key_Up, Qt::Key_Up, Qt::Key_Up,
1861         Qt::Key_Left, Qt::Key_Left, Qt::Key_Up, Qt::Key_Down
1862     };
1863 
1864     int row    = 0;
1865     int column = 0;
1866     QModelIndex index = model.index(row, column, QModelIndex());
1867     view.setCurrentIndex(index);
1868     QCOMPARE(view.currentIndex(), index);
1869 
1870     for (Qt::Key key : keymoves) {
1871         QTest::keyClick(&view, key);
1872 
1873         switch (key) {
1874         case Qt::Key_Up:
1875             if (row > 0) {
1876                 index = index.sibling(row - 1, column);
1877                 row -= 1;
1878             } else if (index.parent() != QModelIndex()) {
1879                 index = index.parent();
1880                 row = index.row();
1881             }
1882             break;
1883         case Qt::Key_Down:
1884             if (view.isExpanded(index)) {
1885                 row = 0;
1886                 index = model.index(row, column, index);
1887             } else {
1888                 row = qMin(rows - 1, row + 1);
1889                 index = index.sibling(row, column);
1890             }
1891             break;
1892         case Qt::Key_Left: {
1893             QScrollBar *b = view.horizontalScrollBar();
1894             if (b->value() == b->minimum())
1895                 QVERIFY(!view.isExpanded(index));
1896             // windows style right will walk to the parent
1897             if (view.currentIndex() != index) {
1898                 QCOMPARE(view.currentIndex(), index.parent());
1899                 index = view.currentIndex();
1900                 row = index.row();
1901                 column = index.column();
1902             }
1903             break;
1904         }
1905         case Qt::Key_Right:
1906             QVERIFY(view.isExpanded(index));
1907             // windows style right will walk to the first child
1908             if (view.currentIndex() != index) {
1909                 QCOMPARE(view.currentIndex().parent(), index);
1910                 row = view.currentIndex().row();
1911                 column = view.currentIndex().column();
1912                 index = view.currentIndex();
1913             }
1914             break;
1915         default:
1916             QVERIFY(false);
1917         }
1918 
1919         QCOMPARE(view.currentIndex().row(), row);
1920         QCOMPARE(view.currentIndex().column(), column);
1921         QCOMPARE(view.currentIndex(), index);
1922     }
1923 }
1924 
1925 class Dmodel : public QtTestModel
1926 {
1927     Q_OBJECT
1928 public:
1929     using QtTestModel::QtTestModel;
1930     int columnCount(const QModelIndex &parent) const override
1931     {
1932         if (parent.row() == 5)
1933             return 1;
1934         return QtTestModel::columnCount(parent);
1935     }
1936 };
1937 
1938 void tst_QTreeView::headerSections()
1939 {
1940     Dmodel model(10, 10);
1941 
1942     QTreeView view;
1943     QHeaderView *header = view.header();
1944 
1945     view.setModel(&model);
1946     QModelIndex index = model.index(5, 0);
1947     view.setRootIndex(index);
1948     QCOMPARE(model.columnCount(QModelIndex()), 10);
1949     QCOMPARE(model.columnCount(index), 1);
1950     QCOMPARE(header->count(), model.columnCount(index));
1951 }
1952 
1953 void tst_QTreeView::moveCursor_data()
1954 {
1955     QTest::addColumn<bool>("uniformRowHeights");
1956     QTest::addColumn<bool>("scrollPerPixel");
1957     QTest::newRow("uniformRowHeights = false, scrollPerPixel = false")
1958         << false << false;
1959     QTest::newRow("uniformRowHeights = true, scrollPerPixel = false")
1960         << true << false;
1961     QTest::newRow("uniformRowHeights = false, scrollPerPixel = true")
1962         << false << true;
1963     QTest::newRow("uniformRowHeights = true, scrollPerPixel = true")
1964         << true << true;
1965 }
1966 
1967 void tst_QTreeView::moveCursor()
1968 {
1969     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
1970         QSKIP("Wayland: This fails. Figure out why.");
1971 
1972     QFETCH(bool, uniformRowHeights);
1973     QFETCH(bool, scrollPerPixel);
1974     QtTestModel model(8, 6);
1975 
1976     QTreeView view;
1977     view.setUniformRowHeights(uniformRowHeights);
1978     view.setModel(&model);
1979     view.setRowHidden(0, QModelIndex(), true);
1980     view.setVerticalScrollMode(scrollPerPixel ?
1981             QAbstractItemView::ScrollPerPixel :
1982             QAbstractItemView::ScrollPerItem);
1983     QVERIFY(view.isRowHidden(0, QModelIndex()));
1984     view.setColumnHidden(0, true);
1985     QVERIFY(view.isColumnHidden(0));
1986     view.show();
1987     QApplication::setActiveWindow(&view);
1988     QVERIFY(QTest::qWaitForWindowActive(&view));
1989 
1990     //here the first visible index should be selected
1991     //because the view got the focus
1992     QModelIndex expected = model.index(1, 1, QModelIndex());
1993     QCOMPARE(view.currentIndex(), expected);
1994 
1995     //then pressing down should go to the next line
1996     QModelIndex actual = view.moveCursor(QTreeView::MoveDown, Qt::NoModifier);
1997     expected = model.index(2, 1, QModelIndex());
1998     QCOMPARE(actual, expected);
1999 
2000     view.setRowHidden(0, QModelIndex(), false);
2001     view.setColumnHidden(0, false);
2002 
2003     // PageUp was broken with uniform row heights turned on
2004     view.setCurrentIndex(model.index(1, 0));
2005     actual = view.moveCursor(QTreeView::MovePageUp, Qt::NoModifier);
2006     expected = model.index(0, 0, QModelIndex());
2007     QCOMPARE(actual, expected);
2008 
2009     //let's try another column
2010     view.setCurrentIndex(model.index(1, 1));
2011     view.setSelectionBehavior(QAbstractItemView::SelectItems);
2012     QTest::keyClick(view.viewport(), Qt::Key_Up);
2013     expected = model.index(0, 1, QModelIndex());
2014     QCOMPARE(view.currentIndex(), expected);
2015     QTest::keyClick(view.viewport(), Qt::Key_Down);
2016     expected = model.index(1, 1, QModelIndex());
2017     QCOMPARE(view.currentIndex(), expected);
2018     QTest::keyClick(view.viewport(), Qt::Key_Up);
2019     expected = model.index(0, 1, QModelIndex());
2020     QCOMPARE(view.currentIndex(), expected);
2021     view.setColumnHidden(0, true);
2022     QTest::keyClick(view.viewport(), Qt::Key_Left);
2023     expected = model.index(0, 1, QModelIndex()); //it shouldn't have changed
2024     QCOMPARE(view.currentIndex(), expected);
2025     view.setColumnHidden(0, false);
2026     QTest::keyClick(view.viewport(), Qt::Key_Left);
2027     expected = model.index(0, 0, QModelIndex());
2028     QCOMPARE(view.currentIndex(), expected);
2029 }
2030 
2031 class TestDelegate : public QStyledItemDelegate
2032 {
2033     Q_OBJECT
2034 public:
2035     using QStyledItemDelegate::QStyledItemDelegate;
2036     QSize sizeHint(const QStyleOptionViewItem &, const QModelIndex &) const override
2037     { return QSize(200, 50); }
2038 };
2039 
2040 typedef QList<QPoint> PointList;
2041 
2042 void tst_QTreeView::setSelection_data()
2043 {
2044     QTest::addColumn<QRect>("selectionRect");
2045     QTest::addColumn<QAbstractItemView::SelectionMode>("selectionMode");
2046     QTest::addColumn<QItemSelectionModel::SelectionFlags>("selectionCommand");
2047     QTest::addColumn<PointList>("expectedItems");
2048     QTest::addColumn<int>("verticalOffset");
2049 
2050     const PointList pl1{QPoint(0, 0), QPoint(1, 0), QPoint(2, 0), QPoint(3, 0), QPoint(4, 0)};
2051     const PointList pl2{QPoint(0, 0), QPoint(1, 0), QPoint(2, 0), QPoint(3, 0), QPoint(4, 0),
2052                         QPoint(0, 1), QPoint(1, 1), QPoint(2, 1), QPoint(3, 1), QPoint(4, 1)};
2053     const QItemSelectionModel::SelectionFlags selFlags(QItemSelectionModel::ClearAndSelect |
2054                                                        QItemSelectionModel::Rows);
2055     QTest::newRow("(0,0,50,20),rows")
2056        << QRect(0, 0, 50, 20)
2057        << QAbstractItemView::SingleSelection
2058        << selFlags << pl1 << 0;
2059 
2060     QTest::newRow("(0,0,50,90),rows")
2061        << QRect(0, 0, 50, 90)
2062        << QAbstractItemView::ExtendedSelection
2063        << selFlags << pl2 << 0;
2064 
2065     QTest::newRow("(50,0,0,90),rows,invalid rect")
2066        << QRect(QPoint(50, 0), QPoint(0, 90))
2067        << QAbstractItemView::ExtendedSelection
2068        << selFlags << pl2 << 0;
2069 
2070     QTest::newRow("(0,-20,20,50),rows")
2071        << QRect(0, -20, 20, 50)
2072        << QAbstractItemView::ExtendedSelection
2073        << selFlags << pl2 << 1;
2074     QTest::newRow("(0,-50,20,90),rows")
2075        << QRect(0, -50, 20, 90)
2076        << QAbstractItemView::ExtendedSelection
2077        << selFlags << pl2 << 1;
2078 }
2079 
2080 void tst_QTreeView::setSelection()
2081 {
2082     QFETCH(QRect, selectionRect);
2083     QFETCH(QAbstractItemView::SelectionMode, selectionMode);
2084     QFETCH(QItemSelectionModel::SelectionFlags, selectionCommand);
2085     QFETCH(PointList, expectedItems);
2086     QFETCH(int, verticalOffset);
2087 
2088     QtTestModel model(10, 5);
2089     model.levels = 1;
2090     model.setDecorationsEnabled(true);
2091     QTreeView view;
2092     view.resize(400, 300);
2093     view.show();
2094     view.setRootIsDecorated(false);
2095     view.setItemDelegate(new TestDelegate(&view));
2096     view.setSelectionMode(selectionMode);
2097     view.setModel(&model);
2098     view.setUniformRowHeights(true);
2099     view.setVerticalScrollMode(QAbstractItemView::ScrollPerItem);
2100     view.scrollTo(model.index(verticalOffset, 0), QAbstractItemView::PositionAtTop);
2101     view.setSelection(selectionRect, selectionCommand);
2102     QItemSelectionModel *selectionModel = view.selectionModel();
2103     QVERIFY(selectionModel);
2104 
2105     const QModelIndexList selectedIndexes = selectionModel->selectedIndexes();
2106     QCOMPARE(selectedIndexes.count(), expectedItems.count());
2107     for (const QModelIndex &idx : selectedIndexes)
2108         QVERIFY(expectedItems.contains(QPoint(idx.column(), idx.row())));
2109 }
2110 
2111 void tst_QTreeView::indexAbove()
2112 {
2113     QtTestModel model(6, 7);
2114     model.levels = 2;
2115     QTreeView view;
2116 
2117     QCOMPARE(view.indexAbove(QModelIndex()), QModelIndex());
2118     view.setModel(&model);
2119     QCOMPARE(view.indexAbove(QModelIndex()), QModelIndex());
2120 
2121     QStack<QModelIndex> parents;
2122     parents.push(QModelIndex());
2123     while (!parents.isEmpty()) {
2124         QModelIndex p = parents.pop();
2125         if (model.canFetchMore(p))
2126             model.fetchMore(p);
2127         int rows = model.rowCount(p);
2128         for (int r = rows - 1; r > 0; --r) {
2129             for (int column = 0; column < 3; ++column) {
2130                 QModelIndex idx = model.index(r, column, p);
2131                 QModelIndex expected = model.index(r - 1, column, p);
2132                 QCOMPARE(view.indexAbove(idx), expected);
2133             }
2134         }
2135         // hide even rows
2136         for (int r = 0; r < rows; r+=2)
2137             view.setRowHidden(r, p, true);
2138         for (int r = rows - 1; r > 0; r-=2) {
2139             for (int column = 0; column < 3; ++column) {
2140                 QModelIndex idx = model.index(r, column, p);
2141                 QModelIndex expected = model.index(r - 2, column, p);
2142                 QCOMPARE(view.indexAbove(idx), expected);
2143             }
2144         }
2145 //        for (int r = 0; r < rows; ++r)
2146 //            parents.push(model.index(r, 0, p));
2147     }
2148 }
2149 
2150 void tst_QTreeView::indexBelow()
2151 {
2152     QtTestModel model(2, 2);
2153 
2154     QTreeView view;
2155     view.setModel(&model);
2156     view.show();
2157 
2158     {
2159         QModelIndex i = model.index(0, 0, view.rootIndex());
2160         QVERIFY(i.isValid());
2161         QCOMPARE(i.row(), 0);
2162         QCOMPARE(i.column(), 0);
2163 
2164         i = view.indexBelow(i);
2165         QVERIFY(i.isValid());
2166         QCOMPARE(i.row(), 1);
2167         QCOMPARE(i.column(), 0);
2168         i = view.indexBelow(i);
2169         QVERIFY(!i.isValid());
2170     }
2171 
2172     {
2173         QModelIndex i = model.index(0, 1, view.rootIndex());
2174         QVERIFY(i.isValid());
2175         QCOMPARE(i.row(), 0);
2176         QCOMPARE(i.column(), 1);
2177 
2178         i = view.indexBelow(i);
2179         QVERIFY(i.isValid());
2180         QCOMPARE(i.row(), 1);
2181         QCOMPARE(i.column(), 1);
2182         i = view.indexBelow(i);
2183         QVERIFY(!i.isValid());
2184     }
2185 }
2186 
2187 void tst_QTreeView::clicked()
2188 {
2189     QtTestModel model(10, 2);
2190 
2191     QTreeView view;
2192     view.setModel(&model);
2193     view.show();
2194 
2195     QVERIFY(QTest::qWaitForWindowExposed(&view));
2196 
2197     QModelIndex firstIndex = model.index(0, 0, QModelIndex());
2198     QVERIFY(firstIndex.isValid());
2199     int itemHeight = view.visualRect(firstIndex).height();
2200     int itemOffset = view.visualRect(firstIndex).width() / 2;
2201     view.resize(200, itemHeight * (model.rows + 2));
2202 
2203     for (int i = 0; i < model.rowCount(); ++i) {
2204         QPoint p(itemOffset, 1 + itemHeight * i);
2205         QModelIndex index = view.indexAt(p);
2206         if (!index.isValid())
2207             continue;
2208         QSignalSpy spy(&view, &QTreeView::clicked);
2209         QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, p);
2210         QTRY_COMPARE(spy.count(), 1);
2211     }
2212 }
2213 
2214 void tst_QTreeView::mouseDoubleClick()
2215 {
2216     // Test double clicks outside the viewport.
2217     // (Should be a no-op and should not expand any item.)
2218 
2219     QStandardItemModel model(20, 2);
2220     for (int i = 0; i < model.rowCount(); i++) {
2221         QModelIndex index = model.index(i, 0, QModelIndex());
2222         model.insertRows(0, 20, index);
2223         model.insertColumns(0, 2,index);
2224         for (int i1 = 0; i1 <  model.rowCount(index); i1++) {
2225             QVERIFY(model.index(i1, 0, index).isValid());
2226         }
2227     }
2228 
2229     QTreeView view;
2230     view.setModel(&model);
2231 
2232     // make sure the viewport height is smaller than the contents height.
2233     view.resize(200, 200);
2234     view.move(0, 0);
2235     view.show();
2236     QModelIndex index = model.index(0, 0, QModelIndex());
2237     view.setCurrentIndex(index);
2238 
2239     view.setExpanded(model.index(0,0, QModelIndex()), true);
2240     view.setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
2241     view.setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
2242 
2243     // Make sure all items are collapsed
2244     for (int i = 0; i < model.rowCount(QModelIndex()); i++)
2245         view.setExpanded(model.index(i, 0, QModelIndex()), false);
2246 
2247     int maximum = view.verticalScrollBar()->maximum();
2248 
2249     // Doubleclick in the bottom right corner, in the unused area between the vertical and horizontal scrollbar.
2250     int vsw = view.verticalScrollBar()->width();
2251     int hsh = view.horizontalScrollBar()->height();
2252     QTest::mouseDClick(&view, Qt::LeftButton, Qt::NoModifier, QPoint(view.width() - vsw + 1, view.height() - hsh + 1));
2253     // Should not have expanded, thus maximum() should have the same value.
2254     QCOMPARE(maximum, view.verticalScrollBar()->maximum());
2255 
2256     view.setExpandsOnDoubleClick(false);
2257     QTest::mouseDClick(&view, Qt::LeftButton, Qt::NoModifier, view.visualRect(index).center());
2258     QVERIFY(!view.isExpanded(index));
2259 }
2260 
2261 void tst_QTreeView::rowsAboutToBeRemoved()
2262 {
2263     QStandardItemModel model(3, 1);
2264     for (int i = 0; i < model.rowCount(); i++) {
2265         const QString iS = QString::number(i);
2266         QModelIndex index = model.index(i, 0, QModelIndex());
2267         model.setData(index, iS);
2268         model.insertRows(0, 4, index);
2269         model.insertColumns(0,1,index);
2270         for (int i1 = 0; i1 <  model.rowCount(index); i1++) {
2271             QModelIndex index2 = model.index(i1, 0, index);
2272             model.setData(index2, iS + QString::number(i1));
2273         }
2274     }
2275 
2276     QTreeView view;
2277     view.setModel(&model);
2278     view.show();
2279     QModelIndex index = model.index(0,0, QModelIndex());
2280     view.setCurrentIndex(index);
2281     view.setExpanded(model.index(0,0, QModelIndex()), true);
2282 
2283     for (int i = 0; i < model.rowCount(QModelIndex()); i++)
2284         view.setExpanded(model.index(i, 0, QModelIndex()), true);
2285 
2286     QSignalSpy spy1(&model, &QAbstractItemModel::rowsAboutToBeRemoved);
2287 
2288     model.removeRows(1,1);
2289     QCOMPARE((view.state()), 0);
2290     // Should not be 5 (or any other number for that sake :)
2291     QCOMPARE(spy1.count(), 1);
2292 
2293 }
2294 
2295 void tst_QTreeView::headerSections_unhideSection()
2296 {
2297     QtTestModel model(10, 7);
2298 
2299     QTreeView view;
2300 
2301     view.setModel(&model);
2302     view.show();
2303     int size = view.header()->sectionSize(0);
2304     view.setColumnHidden(0, true);
2305 
2306     // should go back to old size
2307     view.setColumnHidden(0, false);
2308     QCOMPARE(size, view.header()->sectionSize(0));
2309 }
2310 
2311 void tst_QTreeView::columnAt()
2312 {
2313     QtTestModel model(10, 10);
2314     QTreeView view;
2315     view.resize(500,500);
2316     view.setModel(&model);
2317 
2318     QCOMPARE(view.columnAt(0), 0);
2319     // really this is testing the header... so not much more should be needed if the header is working...
2320 }
2321 
2322 void tst_QTreeView::scrollTo()
2323 {
2324 #define CHECK_VISIBLE(ROW,COL) QVERIFY(QRect(QPoint(),view.viewport()->size()).contains(\
2325                     view.visualRect(model.index((ROW),(COL),QModelIndex()))))
2326 
2327     QtTestModel model(100, 100);
2328     QTreeView view;
2329     view.setUniformRowHeights(true);
2330     view.scrollTo(QModelIndex(), QTreeView::PositionAtTop);
2331     view.setModel(&model);
2332 
2333     // ### check the scrollbar values an make sure it actually scrolls to the item
2334     // ### check for bot item based and pixel based scrolling
2335     // ### create a data function for this test
2336 
2337     view.scrollTo(QModelIndex());
2338     view.scrollTo(model.index(0, 0, QModelIndex()));
2339     view.scrollTo(model.index(0, 0, QModelIndex()), QTreeView::PositionAtTop);
2340     view.scrollTo(model.index(0, 0, QModelIndex()), QTreeView::PositionAtBottom);
2341 
2342     view.show();
2343     view.setVerticalScrollMode(QAbstractItemView::ScrollPerItem); //some styles change that in Polish
2344     view.resize(300, 200);
2345 
2346     QVERIFY(QTest::qWaitForWindowExposed(&view));
2347     //view.verticalScrollBar()->setValue(0);
2348 
2349     view.scrollTo(model.index(0, 0, QModelIndex()));
2350     CHECK_VISIBLE(0,0);
2351     QCOMPARE(view.verticalScrollBar()->value(), 0);
2352 
2353     view.header()->resizeSection(0, 5); // now we only see the branches
2354     view.scrollTo(model.index(5, 0, QModelIndex()), QTreeView::PositionAtTop);
2355     QCOMPARE(view.verticalScrollBar()->value(), 5);
2356 
2357     view.scrollTo(model.index(60, 60, QModelIndex()));
2358 
2359     CHECK_VISIBLE(60,60);
2360     view.scrollTo(model.index(60, 30, QModelIndex()));
2361     CHECK_VISIBLE(60,30);
2362     view.scrollTo(model.index(30, 30, QModelIndex()));
2363     CHECK_VISIBLE(30,30);
2364 
2365     // TODO force it to move to the left and then the right
2366 }
2367 
2368 void tst_QTreeView::rowsAboutToBeRemoved_move()
2369 {
2370     QStandardItemModel model(3,1);
2371     QTreeView view;
2372     view.setModel(&model);
2373     QModelIndex indexThatWantsToLiveButWillDieDieITellYou;
2374     QModelIndex parent = model.index(2, 0);
2375     view.expand(parent);
2376     for (int i = 0; i < 6; ++i) {
2377         model.insertRows(0, 1, parent);
2378         model.insertColumns(0, 1, parent);
2379         QModelIndex index = model.index(0, 0, parent);
2380         view.expand(index);
2381         if (i == 3)
2382             indexThatWantsToLiveButWillDieDieITellYou = index;
2383         model.setData(index, i);
2384         parent = index;
2385     }
2386     view.resize(600,800);
2387     view.show();
2388     QVERIFY(QTest::qWaitForWindowExposed(&view));
2389     view.doItemsLayout();
2390     view.executeDelayedItemsLayout();
2391     parent = indexThatWantsToLiveButWillDieDieITellYou.parent();
2392     QCOMPARE(view.isExpanded(indexThatWantsToLiveButWillDieDieITellYou), true);
2393     QCOMPARE(parent.isValid(), true);
2394     QCOMPARE(parent.parent().isValid(), true);
2395     view.expand(parent);
2396     QCOMPARE(view.isExpanded(parent), true);
2397     QCOMPARE(view.isExpanded(indexThatWantsToLiveButWillDieDieITellYou), true);
2398     model.removeRow(0, indexThatWantsToLiveButWillDieDieITellYou);
2399     QCOMPARE(view.isExpanded(parent), true);
2400     QCOMPARE(view.isExpanded(indexThatWantsToLiveButWillDieDieITellYou), true);
2401 }
2402 
2403 void tst_QTreeView::resizeColumnToContents()
2404 {
2405     QStandardItemModel model(50,2);
2406     for (int r = 0; r < model.rowCount(); ++r) {
2407         const QString rS = QString::number(r);
2408         for (int c = 0; c < model.columnCount(); ++c) {
2409             QModelIndex idx = model.index(r, c);
2410             model.setData(idx, rS + QLatin1Char(',') + QString::number(c));
2411             model.insertColumns(0, 2, idx);
2412             model.insertRows(0, 6, idx);
2413             for (int i = 0; i < 6; ++i) {
2414                 const QString iS = QString::number(i);
2415                 for (int j = 0; j < 2 ; ++j) {
2416                     model.setData(model.index(i, j, idx), QLatin1String("child") + iS + QString::number(j));
2417                 }
2418             }
2419         }
2420     }
2421     QTreeView view;
2422     view.setModel(&model);
2423     view.show();
2424     QVERIFY(QTest::qWaitForWindowExposed(&view));
2425 
2426     view.scrollToBottom();
2427     view.resizeColumnToContents(0);
2428     int oldColumnSize = view.header()->sectionSize(0);
2429     view.setRootIndex(model.index(0, 0));
2430     view.resizeColumnToContents(0);        //Earlier, this gave an assert
2431     QVERIFY(view.header()->sectionSize(0) > oldColumnSize);
2432 }
2433 
2434 void tst_QTreeView::insertAfterSelect()
2435 {
2436     QtTestModel model(10, 10);
2437     QTreeView view;
2438     view.setModel(&model);
2439     view.show();
2440     QVERIFY(QTest::qWaitForWindowExposed(&view));
2441 
2442     QModelIndex firstIndex = model.index(0, 0, QModelIndex());
2443     QVERIFY(firstIndex.isValid());
2444     int itemOffset = view.visualRect(firstIndex).width() / 2;
2445     QPoint p(itemOffset, 1);
2446     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, p);
2447     QVERIFY(view.selectionModel()->isSelected(firstIndex));
2448     model.insertNewRow();
2449     QVERIFY(view.selectionModel()->isSelected(firstIndex)); // Should still be selected
2450 }
2451 
2452 void tst_QTreeView::removeAfterSelect()
2453 {
2454     QtTestModel model(10, 10);
2455     QTreeView view;
2456     view.setModel(&model);
2457     view.show();
2458     QVERIFY(QTest::qWaitForWindowExposed(&view));
2459 
2460     QModelIndex firstIndex = model.index(0, 0, QModelIndex());
2461     QVERIFY(firstIndex.isValid());
2462     int itemOffset = view.visualRect(firstIndex).width() / 2;
2463     QPoint p(itemOffset, 1);
2464     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, p);
2465     QVERIFY(view.selectionModel()->isSelected(firstIndex));
2466     model.removeLastRow();
2467     QVERIFY(view.selectionModel()->isSelected(firstIndex)); // Should still be selected
2468 }
2469 
2470 void tst_QTreeView::hiddenItems()
2471 {
2472     QtTestModel model(10, 10);
2473     QTreeView view;
2474     view.setModel(&model);
2475     view.show();
2476     QVERIFY(QTest::qWaitForWindowExposed(&view));
2477 
2478     QModelIndex firstIndex = model.index(1, 0, QModelIndex());
2479     QVERIFY(firstIndex.isValid());
2480     if (model.canFetchMore(firstIndex))
2481         model.fetchMore(firstIndex);
2482     for (int i = 0; i < model.rowCount(firstIndex); i++)
2483         view.setRowHidden(i , firstIndex, true );
2484 
2485     int itemOffset = view.visualRect(firstIndex).width() / 2;
2486     int itemHeight = view.visualRect(firstIndex).height();
2487     QPoint p(itemOffset, itemHeight + 1);
2488     view.setExpanded(firstIndex, false);
2489     QTest::mouseDClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, p);
2490     QCOMPARE(view.isExpanded(firstIndex), false);
2491 
2492     p.setX(5);
2493     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, p);
2494     QCOMPARE(view.isExpanded(firstIndex), false);
2495 }
2496 
2497 void tst_QTreeView::spanningItems()
2498 {
2499     QtTestModel model(10, 10);
2500     model.onlyValidCalls = true;
2501     QTreeView view;
2502     view.setModel(&model);
2503     view.show();
2504     QVERIFY(QTest::qWaitForWindowExposed(&view));
2505 
2506     int itemWidth = view.header()->sectionSize(0);
2507     int itemHeight = view.visualRect(model.index(0, 0, QModelIndex())).height();
2508 
2509     // every second row is spanning
2510     for (int i = 1; i < model.rowCount(QModelIndex()); i += 2)
2511         view.setFirstColumnSpanned(i , QModelIndex(), true);
2512 
2513     // non-spanning item
2514     QPoint p(itemWidth / 2, itemHeight / 2); // column 0, row 0
2515     view.setCurrentIndex(QModelIndex());
2516     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, p);
2517     QCOMPARE(view.currentIndex(), model.index(0, 0, QModelIndex()));
2518     QCOMPARE(view.header()->sectionSize(0) - view.indentation(),
2519              view.visualRect(model.index(0, 0, QModelIndex())).width());
2520 
2521     // spanning item
2522     p.setX(itemWidth + (itemWidth / 2)); // column 1
2523     p.setY(itemHeight + (itemHeight / 2)); // row 1
2524     QTest::mouseClick(view.viewport(), Qt::LeftButton, Qt::NoModifier, p);
2525     QCOMPARE(view.currentIndex(), model.index(1, 0, QModelIndex()));
2526     QCOMPARE(view.header()->length() - view.indentation(),
2527              view.visualRect(model.index(1, 0, QModelIndex())).width());
2528 
2529     // size hint
2530     // every second row is un-spanned
2531     QStyleOptionViewItem option;
2532     view.initViewItemOption(&option);
2533     int w = view.header()->sectionSizeHint(0);
2534     for (int i = 0; i < model.rowCount(QModelIndex()); ++i) {
2535         if (!view.isFirstColumnSpanned(i, QModelIndex())) {
2536             QModelIndex index = model.index(i, 0, QModelIndex());
2537             w = qMax(w, view.itemDelegateForIndex(index)->sizeHint(option, index).width() + view.indentation());
2538         }
2539     }
2540     QCOMPARE(view.sizeHintForColumn(0), w);
2541 
2542     view.repaint(); // to check that this doesn't hit any assert
2543 }
2544 
2545 void tst_QTreeView::selectionOrderTest()
2546 {
2547     QVERIFY(static_cast<QItemSelectionModel*>(sender())->currentIndex().row() != -1);
2548 }
2549 
2550 void tst_QTreeView::selection()
2551 {
2552     if (!QGuiApplication::platformName().compare(QLatin1String("wayland"), Qt::CaseInsensitive))
2553         QSKIP("Wayland: This causes a crash triggered by setVisible(false)");
2554 
2555     QTreeView treeView;
2556     QStandardItemModel m(10, 2);
2557     for (int i = 0;i < 10; ++i)
2558         m.setData(m.index(i, 0), i);
2559     treeView.setModel(&m);
2560     treeView.show();
2561     QVERIFY(QTest::qWaitForWindowExposed(&treeView));
2562 
2563     treeView.setSelectionBehavior(QAbstractItemView::SelectRows);
2564     treeView.setSelectionMode(QAbstractItemView::ExtendedSelection);
2565 
2566     connect(treeView.selectionModel(), &QItemSelectionModel::selectionChanged,
2567             this, &tst_QTreeView::selectionOrderTest);
2568 
2569     QTest::mousePress(treeView.viewport(), Qt::LeftButton, {},
2570                       treeView.visualRect(m.index(1, 0)).center());
2571     QTest::keyPress(treeView.viewport(), Qt::Key_Down);
2572     auto selectedRows = treeView.selectionModel()->selectedRows();
2573     QCOMPARE(selectedRows.size(), 1);
2574     QCOMPARE(selectedRows.first(), m.index(2, 0, QModelIndex()));
2575     QTest::keyPress(treeView.viewport(), Qt::Key_5);
2576     selectedRows = treeView.selectionModel()->selectedRows();
2577     QCOMPARE(selectedRows.size(), 1);
2578     QCOMPARE(selectedRows.first(), m.index(5, 0, QModelIndex()));
2579 }
2580 
2581 //From task 151686 QTreeView ExtendedSelection selects hidden rows
2582 void tst_QTreeView::selectionWithHiddenItems()
2583 {
2584     QStandardItemModel model;
2585 
2586     QStandardItem item0("row 0");
2587     QStandardItem item1("row 1");
2588     QStandardItem item2("row 2");
2589     QStandardItem item3("row 3");
2590     model.appendColumn({&item0, &item1, &item2, &item3});
2591 
2592     QStandardItem child("child");
2593     item1.appendRow(&child);
2594 
2595     QTreeView view;
2596     view.setModel(&model);
2597     view.setSelectionMode(QAbstractItemView::ExtendedSelection);
2598     view.show();
2599     QVERIFY(QTest::qWaitForWindowExposed(&view));
2600 
2601     //child should not be selected as it is hidden (its parent is not expanded)
2602     view.selectAll();
2603     QCOMPARE(view.selectionModel()->selection().count(), 1); //one range
2604     QCOMPARE(view.selectionModel()->selectedRows().count(), 4);
2605     view.expandAll();
2606     QVERIFY(view.isExpanded(item1.index()));
2607     QCOMPARE(view.selectionModel()->selection().count(), 1);
2608     QCOMPARE(view.selectionModel()->selectedRows().count(), 4);
2609     QVERIFY( !view.selectionModel()->isSelected(model.indexFromItem(&child)));
2610     view.clearSelection();
2611     QVERIFY(view.isExpanded(item1.index()));
2612 
2613     //child should be selected as it is visible (its parent is expanded)
2614     view.selectAll();
2615     QCOMPARE(view.selectionModel()->selection().count(), 2);
2616     QCOMPARE(view.selectionModel()->selectedRows().count(), 5); //everything is selected
2617     view.clearSelection();
2618 
2619     //we hide the node with a child (there should then be 3 items selected in 2 ranges)
2620     view.setRowHidden(1, QModelIndex(), true);
2621     QVERIFY(view.isExpanded(item1.index()));
2622     view.selectAll();
2623     QCOMPARE(view.selectionModel()->selection().count(), 2);
2624     QCOMPARE(view.selectionModel()->selectedRows().count(), 3);
2625     QVERIFY(!view.selectionModel()->isSelected(model.indexFromItem(&item1)));
2626     QVERIFY(!view.selectionModel()->isSelected(model.indexFromItem(&child)));
2627 
2628     view.setRowHidden(1, QModelIndex(), false);
2629     QVERIFY(view.isExpanded(item1.index()));
2630     view.clearSelection();
2631 
2632     //we hide a node without children (there should then be 4 items selected in 3 ranges)
2633     view.setRowHidden(2, QModelIndex(), true);
2634     QVERIFY(view.isExpanded(item1.index()));
2635     view.selectAll();
2636     QVERIFY(view.isExpanded(item1.index()));
2637     QCOMPARE(view.selectionModel()->selection().count(), 3);
2638     QCOMPARE(view.selectionModel()->selectedRows().count(), 4);
2639     QVERIFY( !view.selectionModel()->isSelected(model.indexFromItem(&item2)));
2640     view.setRowHidden(2, QModelIndex(), false);
2641     QVERIFY(view.isExpanded(item1.index()));
2642     view.clearSelection();
2643 }
2644 
2645 void tst_QTreeView::selectAll()
2646 {
2647     QStandardItemModel model(4, 4);
2648     QTreeView view2;
2649     view2.setModel(&model);
2650     view2.setSelectionMode(QAbstractItemView::ExtendedSelection);
2651     view2.selectAll();  // Should work with an empty model
2652     //everything should be selected since we are in ExtendedSelection mode
2653     QCOMPARE(view2.selectedIndexes().count(), model.rowCount() * model.columnCount());
2654 
2655     for (int i = 0; i < model.rowCount(); ++i)
2656         model.setData(model.index(i,0), QLatin1String("row ") + QString::number(i));
2657     QTreeView view;
2658     view.setModel(&model);
2659     int selectedCount = view.selectedIndexes().count();
2660     view.selectAll();
2661     QCOMPARE(view.selectedIndexes().count(), selectedCount);
2662 
2663     QTreeView view3;
2664     view3.setModel(&model);
2665     view3.setSelectionMode(QAbstractItemView::NoSelection);
2666     view3.selectAll();
2667     QCOMPARE(view3.selectedIndexes().count(), 0);
2668 }
2669 
2670 void tst_QTreeView::extendedSelection_data()
2671 {
2672     QTest::addColumn<QPoint>("mousePressPos");
2673     QTest::addColumn<int>("selectedCount");
2674 
2675     QTest::newRow("select") << QPoint(10, 10) << 2;
2676     QTest::newRow("unselect") << QPoint(10, 300) << 0;
2677 }
2678 
2679 void tst_QTreeView::extendedSelection()
2680 {
2681     QFETCH(QPoint, mousePressPos);
2682     QFETCH(int, selectedCount);
2683 
2684     QStandardItemModel model(5, 2);
2685     QWidget topLevel;
2686     QTreeView view(&topLevel);
2687     view.resize(qMax(mousePressPos.x() * 2, 300), qMax(mousePressPos.y() * 2, 350));
2688     view.setModel(&model);
2689     view.setSelectionMode(QAbstractItemView::ExtendedSelection);
2690     topLevel.show();
2691     QVERIFY(QTest::qWaitForWindowExposed(&topLevel));
2692     QTest::mousePress(view.viewport(), Qt::LeftButton, {}, mousePressPos);
2693     QCOMPARE(view.selectionModel()->selectedIndexes().count(), selectedCount);
2694 }
2695 
2696 void tst_QTreeView::rowSizeHint()
2697 {
2698     //tests whether the correct visible columns are taken into account when
2699     //calculating the height of a line
2700     QStandardItemModel model(1, 3);
2701     model.setData(model.index(0, 0), QSize(20, 40), Qt::SizeHintRole);
2702     model.setData(model.index(0, 1), QSize(20, 10), Qt::SizeHintRole);
2703     model.setData(model.index(0, 2), QSize(20, 10), Qt::SizeHintRole);
2704     QTreeView view;
2705     view.setModel(&model);
2706 
2707     view.header()->moveSection(1, 0); //the 2nd column goes to the 1st place
2708 
2709     view.show();
2710     QVERIFY(QTest::qWaitForWindowExposed(&view));
2711 
2712     //it must be 40 since the tallest item that defines the height of a line
2713     QCOMPARE(view.visualRect(model.index(0,0)).height(), 40);
2714     QCOMPARE(view.visualRect(model.index(0,1)).height(), 40);
2715     QCOMPARE(view.visualRect(model.index(0,2)).height(), 40);
2716 }
2717 
2718 
2719 //From task 155449 (QTreeWidget has a large width for the first section when sorting
2720 //is turned on before items are added)
2721 
2722 void tst_QTreeView::setSortingEnabledTopLevel()
2723 {
2724     QTreeView view;
2725     QStandardItemModel model(1, 1);
2726     view.setModel(&model);
2727     const int size = view.header()->sectionSize(0);
2728     view.setSortingEnabled(true);
2729     model.setColumnCount(3);
2730     //we test that changing the column count doesn't change the 1st column size
2731     QCOMPARE(view.header()->sectionSize(0), size);
2732 }
2733 
2734 void tst_QTreeView::setSortingEnabledChild()
2735 {
2736     QMainWindow win;
2737     QTreeView view;
2738     // two columns to not get in trouble with stretchLastSection
2739     QStandardItemModel model(1, 2);
2740     view.setModel(&model);
2741     view.header()->setDefaultSectionSize(92);
2742     win.setCentralWidget(&view);
2743     const int size = view.header()->sectionSize(0);
2744     view.setSortingEnabled(true);
2745     model.setColumnCount(3);
2746     //we test that changing the column count doesn't change the 1st column size
2747     QCOMPARE(view.header()->sectionSize(0), size);
2748 }
2749 
2750 void tst_QTreeView::headerHidden()
2751 {
2752     QTreeView view;
2753     QStandardItemModel model;
2754     view.setModel(&model);
2755     QCOMPARE(view.isHeaderHidden(), false);
2756     QCOMPARE(view.header()->isHidden(), false);
2757     view.setHeaderHidden(true);
2758     QCOMPARE(view.isHeaderHidden(), true);
2759     QCOMPARE(view.header()->isHidden(), true);
2760 }
2761 
2762 class TestTreeViewStyle : public QProxyStyle
2763 {
2764     Q_OBJECT
2765 public:
2766     using QProxyStyle::QProxyStyle;
2767     int pixelMetric(PixelMetric metric, const QStyleOption *option = nullptr,
2768                     const QWidget *widget = nullptr) const override
2769     {
2770         if (metric == QStyle::PM_TreeViewIndentation)
2771             return indentation;
2772         else
2773             return QProxyStyle::pixelMetric(metric, option, widget);
2774     }
2775     int indentation = 20;
2776 };
2777 
2778 void tst_QTreeView::indentation()
2779 {
2780     TestTreeViewStyle style1;
2781     TestTreeViewStyle style2;
2782     style1.indentation = 20;
2783     style2.indentation = 30;
2784 
2785     QTreeView view;
2786     view.setStyle(&style1);
2787     QCOMPARE(view.indentation(), style1.indentation);
2788     view.setStyle(&style2);
2789     QCOMPARE(view.indentation(), style2.indentation);
2790     view.setIndentation(70);
2791     QCOMPARE(view.indentation(), 70);
2792     view.setStyle(&style1);
2793     QCOMPARE(view.indentation(), 70);
2794     view.resetIndentation();
2795     QCOMPARE(view.indentation(), style1.indentation);
2796     view.setStyle(&style2);
2797     QCOMPARE(view.indentation(), style2.indentation);
2798 }
2799 
2800 // From Task 145199 (crash when column 0 having at least one expanded item is removed and then
2801 // inserted). The test passes simply if it doesn't crash, hence there are no calls
2802 // to QCOMPARE() or QVERIFY().
2803 void tst_QTreeView::removeAndInsertExpandedCol0()
2804 {
2805     QTreeView view;
2806     QStandardItemModel model;
2807     view.setModel(&model);
2808 
2809     model.setColumnCount(1);
2810 
2811     QStandardItem *item0 = new QStandardItem(QString("item 0"));
2812     model.invisibleRootItem()->appendRow(item0);
2813     view.expand(item0->index());
2814     QStandardItem *item1 = new QStandardItem(QString("item 1"));
2815     item0->appendRow(item1);
2816 
2817     model.removeColumns(0, 1);
2818     model.insertColumns(0, 1);
2819 
2820     view.show();
2821     QVERIFY(QTest::qWaitForWindowExposed(&view));
2822 }
2823 
2824 void tst_QTreeView::disabledButCheckable()
2825 {
2826     QTreeView view;
2827     QStandardItemModel model;
2828     QStandardItem *item;
2829     item = new QStandardItem(QLatin1String("Row 1 Item"));
2830     model.insertRow(0, item);
2831 
2832     item = new QStandardItem(QLatin1String("Row 2 Item"));
2833     item->setCheckable(true);
2834     item->setEnabled(false);
2835     model.insertRow(1, item);
2836 
2837     view.setModel(&model);
2838     view.setCurrentIndex(model.index(1,0));
2839     QCOMPARE(item->checkState(), Qt::Unchecked);
2840     view.show();
2841 
2842     QTest::keyClick(&view, Qt::Key_Space);
2843     QCOMPARE(item->checkState(), Qt::Unchecked);
2844 }
2845 
2846 void tst_QTreeView::sortByColumn_data()
2847 {
2848     QTest::addColumn<bool>("sortingEnabled");
2849     QTest::newRow("sorting enabled") << true;
2850     QTest::newRow("sorting disabled") << false;
2851 }
2852 
2853 // Checks sorting and that sortByColumn also sets the sortIndicator
2854 void tst_QTreeView::sortByColumn()
2855 {
2856     QFETCH(bool, sortingEnabled);
2857     QTreeView view;
2858     QStandardItemModel model(4, 2);
2859     QSortFilterProxyModel sfpm; // default QStandardItemModel does not support 'unsorted' state
2860     sfpm.setSourceModel(&model);
2861     model.setItem(0, 0, new QStandardItem("b"));
2862     model.setItem(1, 0, new QStandardItem("d"));
2863     model.setItem(2, 0, new QStandardItem("c"));
2864     model.setItem(3, 0, new QStandardItem("a"));
2865     model.setItem(0, 1, new QStandardItem("e"));
2866     model.setItem(1, 1, new QStandardItem("g"));
2867     model.setItem(2, 1, new QStandardItem("h"));
2868     model.setItem(3, 1, new QStandardItem("f"));
2869 
2870     view.setSortingEnabled(sortingEnabled);
2871     view.setModel(&sfpm);
2872 
2873     view.sortByColumn(1, Qt::DescendingOrder);
2874     QCOMPARE(view.header()->sortIndicatorSection(), 1);
2875     QCOMPARE(view.model()->data(view.model()->index(0, 0)).toString(), QString::fromLatin1("c"));
2876     QCOMPARE(view.model()->data(view.model()->index(1, 0)).toString(), QString::fromLatin1("d"));
2877     QCOMPARE(view.model()->data(view.model()->index(0, 1)).toString(), QString::fromLatin1("h"));
2878     QCOMPARE(view.model()->data(view.model()->index(1, 1)).toString(), QString::fromLatin1("g"));
2879 
2880     view.sortByColumn(0, Qt::AscendingOrder);
2881     QCOMPARE(view.header()->sortIndicatorSection(), 0);
2882     QCOMPARE(view.model()->data(view.model()->index(0, 0)).toString(), QString::fromLatin1("a"));
2883     QCOMPARE(view.model()->data(view.model()->index(1, 0)).toString(), QString::fromLatin1("b"));
2884     QCOMPARE(view.model()->data(view.model()->index(0, 1)).toString(), QString::fromLatin1("f"));
2885     QCOMPARE(view.model()->data(view.model()->index(1, 1)).toString(), QString::fromLatin1("e"));
2886 
2887     view.sortByColumn(-1, Qt::AscendingOrder);
2888     QCOMPARE(view.header()->sortIndicatorSection(), -1);
2889     QCOMPARE(view.model()->data(view.model()->index(0, 0)).toString(), QString::fromLatin1("b"));
2890     QCOMPARE(view.model()->data(view.model()->index(1, 0)).toString(), QString::fromLatin1("d"));
2891     QCOMPARE(view.model()->data(view.model()->index(0, 1)).toString(), QString::fromLatin1("e"));
2892     QCOMPARE(view.model()->data(view.model()->index(1, 1)).toString(), QString::fromLatin1("g"));
2893 
2894     // a new 'sortByColumn()' should do a re-sort (e.g. due to the data changed), QTBUG-86268
2895     view.setModel(&model);
2896     view.sortByColumn(0, Qt::AscendingOrder);
2897     QCOMPARE(view.model()->data(view.model()->index(0, 0)).toString(), QString::fromLatin1("a"));
2898     model.setItem(0, 0, new QStandardItem("x"));
2899     view.sortByColumn(0, Qt::AscendingOrder);
2900     QCOMPARE(view.model()->data(view.model()->index(0, 0)).toString(), QString::fromLatin1("b"));
2901 }
2902 
2903 /*
2904     This is a model that every time kill() is called it will completely change
2905     all of its nodes for new nodes.  It then qFatal's if you later use a dead node.
2906  */
2907 class EvilModel: public QAbstractItemModel
2908 {
2909     Q_OBJECT
2910 public:
2911     class Node
2912     {
2913     public:
2914         Node(Node *p = nullptr, int level = 0) : parent(p)
2915         {
2916             populate(level);
2917         }
2918         ~Node()
2919         {
2920             qDeleteAll(children.begin(), children.end());
2921             qDeleteAll(deadChildren.begin(), deadChildren.end());
2922         }
2923 
2924         void populate(int level = 0)
2925         {
2926             if (level < 4) {
2927                 for (int i = 0; i < 5; ++i)
2928                     children.append(new Node(this, level + 1));
2929             }
2930         }
2931         void kill()
2932         {
2933             for (int i = children.count() -1; i >= 0; --i) {
2934                 children.at(i)->kill();
2935                 if (parent == nullptr) {
2936                     deadChildren.append(children.at(i));
2937                     children.removeAt(i);
2938                 }
2939             }
2940             if (parent == nullptr) {
2941                 if (!children.isEmpty())
2942                     qFatal("%s: children should be empty when parent is null", Q_FUNC_INFO);
2943                 populate();
2944             } else {
2945                 isDead = true;
2946             }
2947         }
2948 
2949         QList<Node *> children;
2950         QList<Node *> deadChildren;
2951         Node *parent;
2952         bool isDead = false;
2953     };
2954 
2955     Node *root;
2956     bool crash = false;
2957 
2958     EvilModel(QObject *parent = nullptr): QAbstractItemModel(parent), root(new Node)
2959     {}
2960     ~EvilModel()
2961     {
2962         delete root;
2963     }
2964 
2965     void setCrash()
2966     {
2967         crash = true;
2968     }
2969 
2970     void change()
2971     {
2972         emit layoutAboutToBeChanged();
2973         QModelIndexList oldList = persistentIndexList();
2974         QList<QStack<int>> oldListPath;
2975         for (int i = 0; i < oldList.count(); ++i) {
2976             QModelIndex idx = oldList.at(i);
2977             QStack<int> path;
2978             while (idx.isValid()) {
2979                 path.push(idx.row());
2980                 idx = idx.parent();
2981             }
2982             oldListPath.append(path);
2983         }
2984         root->kill();
2985 
2986         QModelIndexList newList;
2987         for (auto path : qAsConst(oldListPath)) {
2988             QModelIndex idx;
2989             while (!path.isEmpty())
2990                 idx = index(path.pop(), 0, idx);
2991             newList.append(idx);
2992         }
2993 
2994         changePersistentIndexList(oldList, newList);
2995         emit layoutChanged();
2996     }
2997 
2998     int rowCount(const QModelIndex &parent = QModelIndex()) const override
2999     {
3000         Node *parentNode = root;
3001         if (parent.isValid()) {
3002             parentNode = static_cast<Node*>(parent.internalPointer());
3003             if (parentNode->isDead)
3004                 qFatal("%s: parentNode is dead!", Q_FUNC_INFO);
3005         }
3006         return parentNode->children.count();
3007     }
3008     int columnCount(const QModelIndex &parent = QModelIndex()) const override
3009     {
3010         return parent.column() > 0 ? 0 : 1;
3011     }
3012 
3013     QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override
3014     {
3015         Node *grandparentNode = static_cast<Node*>(parent.internalPointer());
3016         Node *parentNode = root;
3017         if (parent.isValid()) {
3018             if (grandparentNode->isDead)
3019                 qFatal("%s: grandparentNode is dead!", Q_FUNC_INFO);
3020             parentNode = grandparentNode->children[parent.row()];
3021             if (parentNode->isDead)
3022                 qFatal("%s: grandparentNode is dead!", Q_FUNC_INFO);
3023         }
3024         return createIndex(row, column, parentNode);
3025     }
3026 
3027     QModelIndex parent(const QModelIndex &index) const override
3028     {
3029         Node *parent = static_cast<Node*>(index.internalPointer());
3030         Node *grandparent = parent->parent;
3031         if (!grandparent)
3032             return QModelIndex();
3033         return createIndex(grandparent->children.indexOf(parent), 0, grandparent);
3034     }
3035 
3036     QVariant data(const QModelIndex &idx, int role) const override
3037     {
3038         if (crash) {
3039             QTest::qFail("Should not get here...", __FILE__, __LINE__);
3040             return QVariant();
3041         }
3042         if (idx.isValid() && role == Qt::DisplayRole) {
3043             Node *parentNode = root;
3044             if (idx.isValid()) {
3045                 parentNode = static_cast<Node*>(idx.internalPointer());
3046                 if (parentNode->isDead)
3047                     qFatal("%s: grandparentNode is dead!", Q_FUNC_INFO);
3048             }
3049             return QLatin1Char('[') + QString::number(idx.row()) + QLatin1Char(',')
3050                 + QString::number(idx.column()) + QLatin1Char(',')
3051                 + QLatin1String(parentNode->isDead ? "dead" : "alive") + QLatin1Char(']');
3052         }
3053         return QVariant();
3054     }
3055 };
3056 
3057 void tst_QTreeView::evilModel_data()
3058 {
3059     QTest::addColumn<bool>("visible");
3060     QTest::newRow("visible") << false;
3061     QTest::newRow("visible") << true;
3062 }
3063 
3064 void tst_QTreeView::evilModel()
3065 {
3066     QFETCH(bool, visible);
3067     // init
3068     TreeView view;
3069     EvilModel model;
3070     view.setModel(&model);
3071     view.setVisible(visible);
3072     QPersistentModelIndex firstLevel = model.index(0, 0);
3073     QPersistentModelIndex secondLevel = model.index(1, 0, firstLevel);
3074     QPersistentModelIndex thirdLevel = model.index(2, 0, secondLevel);
3075     view.setExpanded(firstLevel, true);
3076     view.setExpanded(secondLevel, true);
3077     view.setExpanded(thirdLevel, true);
3078     model.change();
3079 
3080     // tests
3081     view.setRowHidden(0, firstLevel, true);
3082     model.change();
3083 
3084     view.setFirstColumnSpanned(1, QModelIndex(), true);
3085     model.change();
3086 
3087     view.expand(secondLevel);
3088     model.change();
3089 
3090     view.collapse(secondLevel);
3091     model.change();
3092 
3093     view.isExpanded(secondLevel);
3094     view.setCurrentIndex(firstLevel);
3095     model.change();
3096 
3097     view.keyboardSearch("foo");
3098     model.change();
3099 
3100     view.visualRect(secondLevel);
3101     model.change();
3102 
3103     view.scrollTo(thirdLevel);
3104     model.change();
3105 
3106     view.update();  // will not do anything since view is not visible
3107     model.change();
3108 
3109     QTest::mouseDClick(view.viewport(), Qt::LeftButton);
3110     model.change();
3111 
3112     view.indexAt(QPoint(10, 10));
3113     model.change();
3114 
3115     view.indexAbove(model.index(2, 0));
3116     model.change();
3117 
3118     view.indexBelow(model.index(1, 0));
3119     model.change();
3120 
3121     QRect rect(0, 0, 10, 10);
3122     view.setSelection(rect, QItemSelectionModel::Select);
3123     model.change();
3124 
3125     view.moveCursor(QTreeView::MoveDown, Qt::NoModifier);
3126     model.change();
3127 
3128     view.resizeColumnToContents(1);
3129     model.change();
3130 
3131     view.QAbstractItemView::sizeHintForColumn(1);
3132     model.change();
3133 
3134     view.rowHeight(secondLevel);
3135     model.change();
3136 
3137     view.setRootIsDecorated(true);
3138     model.change();
3139 
3140     view.setItemsExpandable(false);
3141     model.change();
3142 
3143     view.columnViewportPosition(0);
3144     model.change();
3145 
3146     view.columnWidth(0);
3147     model.change();
3148 
3149     view.setColumnWidth(0, 30);
3150     model.change();
3151 
3152     view.columnAt(15);
3153     model.change();
3154 
3155     view.isColumnHidden(1);
3156     model.change();
3157 
3158     view.setColumnHidden(2, true);
3159     model.change();
3160 
3161     view.isHeaderHidden();
3162     model.change();
3163 
3164     view.setHeaderHidden(true);
3165     model.change();
3166 
3167     view.isRowHidden(2, secondLevel);
3168     model.change();
3169 
3170     view.setRowHidden(3, secondLevel, true);
3171     model.change();
3172 
3173     view.isFirstColumnSpanned(3, thirdLevel);
3174     model.change();
3175 
3176     view.setSortingEnabled(true);
3177     model.change();
3178 
3179     view.isSortingEnabled();
3180     model.change();
3181 
3182     view.setAnimated(true);
3183     model.change();
3184 
3185     view.isAnimated();
3186     model.change();
3187 
3188     view.setAllColumnsShowFocus(true);
3189     model.change();
3190 
3191     view.allColumnsShowFocus();
3192     model.change();
3193 
3194     view.doItemsLayout();
3195     model.change();
3196 
3197     view.reset();
3198     model.change();
3199 
3200     view.sortByColumn(1, Qt::AscendingOrder);
3201     model.change();
3202 
3203     view.dataChanged(secondLevel, secondLevel);
3204     model.change();
3205 
3206     view.hideColumn(1);
3207     model.change();
3208 
3209     view.showColumn(1);
3210     model.change();
3211 
3212     view.resizeColumnToContents(1);
3213     model.change();
3214 
3215     view.sortByColumn(1, Qt::DescendingOrder);
3216     model.change();
3217 
3218     view.selectAll();
3219     model.change();
3220 
3221     view.expandAll();
3222     model.change();
3223 
3224     view.collapseAll();
3225     model.change();
3226 
3227     view.expandToDepth(3);
3228     model.change();
3229 
3230     view.setRootIndex(secondLevel);
3231 
3232     model.setCrash();
3233     view.setModel(nullptr);
3234 }
3235 
3236 void tst_QTreeView::indexRowSizeHint()
3237 {
3238     QStandardItemModel model(10, 1);
3239     QTreeView view;
3240 
3241     view.setModel(&model);
3242 
3243     QModelIndex index = model.index(5, 0);
3244     QPushButton *w = new QPushButton("Test");
3245     view.setIndexWidget(index, w);
3246 
3247     view.show();
3248 
3249     QCOMPARE(view.indexRowSizeHint(index), w->sizeHint().height());
3250 }
3251 
3252 void tst_QTreeView::filterProxyModelCrash()
3253 {
3254     QStandardItemModel model;
3255     QList<QStandardItem *> items;
3256     for (int i = 0; i < 100; i++)
3257         items << new QStandardItem(QLatin1String("item ") + QString::number(i));
3258     model.appendColumn(items);
3259 
3260     QSortFilterProxyModel proxy;
3261     proxy.setSourceModel(&model);
3262 
3263     TreeView view;
3264     view.setModel(&proxy);
3265     view.show();
3266     QVERIFY(QTest::qWaitForWindowExposed(&view));
3267     proxy.invalidate();
3268     view.verticalScrollBar()->setValue(15);
3269     QTest::qWait(20);
3270 
3271     proxy.invalidate();
3272     view.update(); //used to crash
3273     QTRY_VERIFY(view.wasPainted);
3274 }
3275 
3276 void tst_QTreeView::renderToPixmap_data()
3277 {
3278     QTest::addColumn<int>("row");
3279     QTest::newRow("row-0") << 0;
3280     QTest::newRow("row-1") << 1;
3281 }
3282 
3283 void tst_QTreeView::renderToPixmap()
3284 {
3285     QFETCH(int, row);
3286     QTreeView view;
3287     QStandardItemModel model;
3288 
3289     model.appendRow(new QStandardItem("Spanning"));
3290     model.appendRow({ new QStandardItem("Not"), new QStandardItem("Spanning") });
3291 
3292     view.setModel(&model);
3293     view.setFirstColumnSpanned(0, QModelIndex(), true);
3294 
3295 #ifdef QT_BUILD_INTERNAL
3296     {
3297         // We select the index at row=0 because it spans the
3298         // column (regression test for an assert)
3299         // We select the index at row=1 for coverage.
3300         QItemSelection sel(model.index(row,0), model.index(row,1));
3301         QRect rect;
3302         view.d_func()->renderToPixmap(sel.indexes(), &rect);
3303     }
3304 #endif
3305 }
3306 
3307 void tst_QTreeView::styleOptionViewItem()
3308 {
3309     class MyDelegate : public QStyledItemDelegate
3310     {
3311         static QString posToString(QStyleOptionViewItem::ViewItemPosition pos)
3312         {
3313             static const char* s_pos[] = { "Invalid", "Beginning", "Middle", "End", "OnlyOne" };
3314             return s_pos[pos];
3315         }
3316     public:
3317         using QStyledItemDelegate::QStyledItemDelegate;
3318         void paint(QPainter *painter, const QStyleOptionViewItem &option,
3319                    const QModelIndex &index) const override
3320         {
3321             QStyleOptionViewItem opt(option);
3322             initStyleOption(&opt, index);
3323 
3324             QVERIFY(!opt.text.isEmpty());
3325             QCOMPARE(opt.index, index);
3326             //qDebug() << index << opt.text;
3327 
3328             if (allCollapsed) {
3329                 QCOMPARE(!opt.features.testFlag(QStyleOptionViewItem::Alternate),
3330                          !(index.row() % 2));
3331             }
3332             QCOMPARE(!opt.features.testFlag(QStyleOptionViewItem::HasCheckIndicator),
3333                      !opt.text.contains("Checkable"));
3334 
3335             const QString posStr(posToString(opt.viewItemPosition));
3336             if (opt.text.contains("Beginning"))
3337                 QCOMPARE(posStr, posToString(QStyleOptionViewItem::Beginning));
3338 
3339             if (opt.text.contains("Middle"))
3340                 QCOMPARE(posStr, posToString(QStyleOptionViewItem::Middle));
3341 
3342             if (opt.text.contains("End"))
3343                 QCOMPARE(posStr, posToString(QStyleOptionViewItem::End));
3344 
3345             if (opt.text.contains("OnlyOne"))
3346                 QCOMPARE(posStr, posToString(QStyleOptionViewItem::OnlyOne));
3347 
3348             if (opt.text.contains("Checked"))
3349                 QCOMPARE(opt.checkState, Qt::Checked);
3350             else
3351                 QCOMPARE(opt.checkState, Qt::Unchecked);
3352 
3353             QCOMPARE(!opt.state.testFlag(QStyle::State_Children),
3354                      !opt.text.contains("HasChildren"));
3355             QCOMPARE(opt.state.testFlag(QStyle::State_Sibling),
3356                      !opt.text.contains("Last"));
3357 
3358             QVERIFY(!opt.text.contains("Assert"));
3359 
3360             QStyledItemDelegate::paint(painter, option, index);
3361             count++;
3362         }
3363         mutable int count = 0;
3364         bool allCollapsed = false;
3365     };
3366 
3367     QTreeView view;
3368     QStandardItemModel model;
3369     view.setModel(&model);
3370     MyDelegate delegate;
3371     view.setItemDelegate(&delegate);
3372     model.appendRow({ new QStandardItem("Beginning"),
3373                       new QStandardItem("Hidden"),
3374                       new QStandardItem("Middle"),
3375                       new QStandardItem("Middle"),
3376                       new QStandardItem("End") });
3377     QStandardItem *par1 = new QStandardItem("Beginning HasChildren");
3378     model.appendRow({ par1,
3379                       new QStandardItem("Hidden"),
3380                       new QStandardItem("Middle HasChildren"),
3381                       new QStandardItem("Middle HasChildren"),
3382                       new QStandardItem("End HasChildren") });
3383     model.appendRow({ new QStandardItem("OnlyOne"),
3384                       new QStandardItem("Hidden"),
3385                       new QStandardItem("Assert"),
3386                       new QStandardItem("Assert"),
3387                       new QStandardItem("Assert") });
3388     QStandardItem *checkable = new QStandardItem("Checkable");
3389     checkable->setCheckable(true);
3390     QStandardItem *checked = new QStandardItem("Checkable Checked");
3391     checked->setCheckable(true);
3392     checked->setCheckState(Qt::Checked);
3393     model.appendRow({ new QStandardItem("Beginning"),
3394                       new QStandardItem("Hidden"),
3395                       checkable, checked,
3396                       new QStandardItem("End") });
3397     model.appendRow({ new QStandardItem("Beginning Last"),
3398                       new QStandardItem("Hidden"),
3399                       new QStandardItem("Middle Last"),
3400                       new QStandardItem("Middle Last"),
3401                       new QStandardItem("End Last") });
3402     par1->appendRow({ new QStandardItem("Beginning"),
3403                       new QStandardItem("Hidden"),
3404                       new QStandardItem("Middle"),
3405                       new QStandardItem("Middle"),
3406                       new QStandardItem("End") });
3407     QStandardItem *par2 = new QStandardItem("Beginning HasChildren");
3408     par1->appendRow({ par2,
3409                       new QStandardItem("Hidden"),
3410                       new QStandardItem("Middle HasChildren"),
3411                       new QStandardItem("Middle HasChildren"),
3412                       new QStandardItem("End HasChildren") });
3413     par2->appendRow({ new QStandardItem("Beginning Last"),
3414                       new QStandardItem("Hidden"),
3415                       new QStandardItem("Middle Last"),
3416                       new QStandardItem("Middle Last"),
3417                       new QStandardItem("End Last") });
3418     QStandardItem *par3 = new QStandardItem("Beginning Last");
3419     par1->appendRow({ par3, new QStandardItem("Hidden"),
3420                       new QStandardItem("Middle Last"),
3421                       new QStandardItem("Middle Last"),
3422                       new QStandardItem("End Last") });
3423     par3->appendRow({ new QStandardItem("Assert"),
3424                       new QStandardItem("Hidden"),
3425                       new QStandardItem("Assert"),
3426                       new QStandardItem("Assert"),
3427                       new QStandardItem("Asser") });
3428     view.setRowHidden(0, par3->index(), true);
3429     par1->appendRow({ new QStandardItem("Assert"),
3430                       new QStandardItem("Hidden"),
3431                       new QStandardItem("Assert"),
3432                       new QStandardItem("Assert"),
3433                       new QStandardItem("Asser") });
3434     view.setRowHidden(3, par1->index(), true);
3435 
3436     view.setColumnHidden(1, true);
3437     const int visibleColumns = 4;
3438     const int modelColumns = 5;
3439 
3440     view.header()->swapSections(2, 3);
3441     view.setFirstColumnSpanned(2, QModelIndex(), true);
3442     view.setAlternatingRowColors(true);
3443 
3444 #ifdef QT_BUILD_INTERNAL
3445     {
3446         // Test the rendering to pixmap before painting the widget.
3447         // The rendering to pixmap should not depend on having been
3448         // painted already yet.
3449         delegate.count = 0;
3450         QItemSelection sel(model.index(0,0), model.index(0,modelColumns-1));
3451         QRect rect;
3452         view.d_func()->renderToPixmap(sel.indexes(), &rect);
3453         if (delegate.count != visibleColumns) {
3454             qDebug() << rect << view.rect() << view.isVisible();
3455         }
3456         QTRY_COMPARE(delegate.count, visibleColumns);
3457     }
3458 #endif
3459 
3460     delegate.count = 0;
3461     delegate.allCollapsed = true;
3462     view.showMaximized();
3463     QVERIFY(QTest::qWaitForWindowExposed(&view));
3464     QTRY_VERIFY(delegate.count >= 13);
3465     delegate.count = 0;
3466     delegate.allCollapsed = false;
3467     view.expandAll();
3468     QTRY_VERIFY(delegate.count >= 13);
3469     delegate.count = 0;
3470     view.collapse(par2->index());
3471     QTRY_VERIFY(delegate.count >= 4);
3472 
3473     // test that the rendering of drag pixmap sets the correct options too (QTBUG-15834)
3474 #ifdef QT_BUILD_INTERNAL
3475     delegate.count = 0;
3476     QItemSelection sel(model.index(0,0), model.index(0,modelColumns-1));
3477     QRect rect;
3478     view.d_func()->renderToPixmap(sel.indexes(), &rect);
3479     if (delegate.count != visibleColumns) {
3480         qDebug() << rect << view.rect() << view.isVisible();
3481     }
3482     QTRY_COMPARE(delegate.count, visibleColumns);
3483 #endif
3484 
3485     //test dynamic models
3486     {
3487         delegate.count = 0;
3488         QStandardItemModel model2;
3489         QStandardItem *item0 = new QStandardItem("OnlyOne Last");
3490         model2.appendRow(item0);
3491         view.setModel(&model2);
3492         QTRY_VERIFY(delegate.count >= 1);
3493 
3494         QStandardItem *item00 = new QStandardItem("OnlyOne Last");
3495         item0->appendRow(item00);
3496         item0->setText("OnlyOne Last HasChildren");
3497         delegate.count = 0;
3498         view.expandAll();
3499         QTRY_VERIFY(delegate.count >= 2);
3500 
3501         QStandardItem *item1 = new QStandardItem("OnlyOne Last");
3502         delegate.count = 0;
3503         item0->setText("OnlyOne HasChildren");
3504         model2.appendRow(item1);
3505         QTRY_VERIFY(delegate.count >= 3);
3506 
3507         QStandardItem *item01 = new QStandardItem("OnlyOne Last");
3508         delegate.count = 0;
3509         item00->setText("OnlyOne");
3510         item0->appendRow(item01);
3511         QTRY_VERIFY(delegate.count >= 4);
3512 
3513         QStandardItem *item000 = new QStandardItem("OnlyOne Last");
3514         delegate.count = 0;
3515         item00->setText("OnlyOne HasChildren");
3516         item00->appendRow(item000);
3517         QTRY_VERIFY(delegate.count >= 5);
3518 
3519         delegate.count = 0;
3520         item0->removeRow(0);
3521         QTRY_VERIFY(delegate.count >= 3);
3522 
3523         item00 = new QStandardItem("OnlyOne");
3524         item0->insertRow(0, item00);
3525 
3526         delegate.count = 0;
3527         view.expandAll();
3528         QTRY_VERIFY(delegate.count >= 4);
3529 
3530         delegate.count = 0;
3531         item0->removeRow(1);
3532         item00->setText("OnlyOne Last");
3533         QTRY_VERIFY(delegate.count >= 3);
3534 
3535         delegate.count = 0;
3536         item0->removeRow(0);
3537         item0->setText("OnlyOne");
3538         QTRY_VERIFY(delegate.count >= 2);
3539 
3540         //with hidden items
3541         item0->setText("OnlyOne HasChildren");
3542         item00 = new QStandardItem("OnlyOne");
3543         item0->appendRow(item00);
3544         item01 = new QStandardItem("Assert");
3545         item0->appendRow(item01);
3546         view.setRowHidden(1, item0->index(), true);
3547         view.expandAll();
3548         QStandardItem *item02 = new QStandardItem("OnlyOne Last");
3549         item0->appendRow(item02);
3550         delegate.count = 0;
3551         QTRY_VERIFY(delegate.count >= 4);
3552 
3553         item0->removeRow(2);
3554         item00->setText("OnlyOne Last");
3555         delegate.count = 0;
3556         QTRY_VERIFY(delegate.count >= 3);
3557 
3558         item00->setText("OnlyOne");
3559         item0->insertRow(2, new QStandardItem("OnlyOne Last"));
3560         view.collapse(item0->index());
3561         item0->removeRow(0);
3562         delegate.count = 0;
3563         QTRY_VERIFY(delegate.count >= 2);
3564 
3565         item0->removeRow(1);
3566         item0->setText("OnlyOne");
3567         delegate.count = 0;
3568         QTRY_VERIFY(delegate.count >= 2);
3569     }
3570 }
3571 
3572 class task174627_TreeView : public QTreeView
3573 {
3574     Q_OBJECT
3575 protected slots:
3576     void currentChanged(const QModelIndex &current, const QModelIndex &) override
3577     { emit signalCurrentChanged(current); }
3578 signals:
3579     void signalCurrentChanged(const QModelIndex &);
3580 };
3581 
3582 void tst_QTreeView::task174627_moveLeftToRoot()
3583 {
3584     QStandardItemModel model;
3585     QStandardItem *item1 = new QStandardItem(QString("item 1"));
3586     model.invisibleRootItem()->appendRow(item1);
3587     QStandardItem *item2 = new QStandardItem(QString("item 2"));
3588     item1->appendRow(item2);
3589 
3590     task174627_TreeView view;
3591     view.setModel(&model);
3592     view.setRootIndex(item1->index());
3593     view.setCurrentIndex(item2->index());
3594 
3595     QSignalSpy spy(&view, &task174627_TreeView::signalCurrentChanged);
3596     QTest::keyClick(&view, Qt::Key_Left);
3597     QCOMPARE(spy.count(), 0);
3598 }
3599 
3600 void tst_QTreeView::task171902_expandWith1stColHidden()
3601 {
3602     //the task was: if the first column of a treeview is hidden, the expanded state is not correctly restored
3603     QStandardItemModel model;
3604     QStandardItem root("root"), root2("root"),
3605         subitem("subitem"), subitem2("subitem"),
3606         subsubitem("subsubitem"), subsubitem2("subsubitem");
3607 
3608     model.appendRow({ &root, &root2 });
3609     root.appendRow({ &subitem, &subitem2 });
3610     subitem.appendRow({ &subsubitem, &subsubitem2 });
3611 
3612     QTreeView view;
3613     view.setModel(&model);
3614 
3615     view.setColumnHidden(0, true);
3616     view.expandAll();
3617     view.collapse(root.index());
3618     view.expand(root.index());
3619 
3620     QCOMPARE(view.isExpanded(root.index()), true);
3621     QCOMPARE(view.isExpanded(subitem.index()), true);
3622 
3623 }
3624 
3625 void tst_QTreeView::task203696_hidingColumnsAndRowsn()
3626 {
3627     QTreeView view;
3628     QStandardItemModel model(0, 3);
3629     for (int i = 0; i < 3; ++i) {
3630         const QString prefix = QLatin1String("row ") + QString::number(i) + QLatin1String(" col ");
3631         model.insertRow(model.rowCount());
3632         for (int j = 0; j < model.columnCount(); ++j)
3633             model.setData(model.index(i, j), prefix + QString::number(j));
3634     }
3635     view.setModel(&model);
3636     view.show();
3637     view.setColumnHidden(0, true);
3638     view.setRowHidden(0, QModelIndex(), true);
3639     QCOMPARE(view.indexAt(QPoint(0, 0)), model.index(1, 1));
3640 }
3641 
3642 
3643 void tst_QTreeView::addRowsWhileSectionsAreHidden()
3644 {
3645     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
3646         QSKIP("Wayland: This fails. Figure out why.");
3647 
3648     QTreeView view;
3649     for (int pass = 1; pass <= 2; ++pass) {
3650         QStandardItemModel *model = new QStandardItemModel(6, pass, &view);
3651         view.setModel(model);
3652         view.show();
3653         QVERIFY(QTest::qWaitForWindowActive(&view));
3654 
3655         for (int i = 0; i < 3; ++i)
3656         {
3657             model->insertRow(model->rowCount());
3658             const QString prefix = QLatin1String("row ") + QString::number(i) + QLatin1String(" col ");
3659             for (int j = 0; j < model->columnCount(); ++j)
3660                 model->setData(model->index(i, j), prefix + QString::number(j));
3661         }
3662         for (int col = 0; col < pass; ++col)
3663             view.setColumnHidden(col, true);
3664         for (int i = 3; i < 6; ++i)
3665         {
3666             model->insertRow(model->rowCount());
3667             const QString prefix = QLatin1String("row ") + QString::number(i) + QLatin1String(" col ");
3668             for (int j = 0; j < model->columnCount(); ++j)
3669                 model->setData(model->index(i, j), prefix + QString::number(j));
3670         }
3671         for (int col = 0; col < pass; ++col)
3672             view.setColumnHidden(col, false);
3673 
3674         auto allVisualRectsValid = [](QTreeView *view, QStandardItemModel *model) {
3675             for (int i = 0; i < 6; ++i) {
3676                 if (!view->visualRect(model->index(i, 0)).isValid())
3677                     return false;
3678             }
3679             return true;
3680         };
3681         QTRY_VERIFY(allVisualRectsValid(&view, model));
3682 
3683         delete model;
3684     }
3685 }
3686 
3687 void tst_QTreeView::task216717_updateChildren()
3688 {
3689     class Tree : public QTreeWidget
3690     {
3691         protected:
3692             void paintEvent(QPaintEvent *e) override
3693             {
3694                 QTreeWidget::paintEvent(e);
3695                 refreshed = true;
3696             }
3697         public:
3698             bool refreshed = false;
3699     } tree;
3700     tree.show();
3701     QVERIFY(QTest::qWaitForWindowExposed(&tree));
3702     tree.refreshed = false;
3703     QTreeWidgetItem *parent = new QTreeWidgetItem({ "parent" });
3704     tree.addTopLevelItem(parent);
3705     QTRY_VERIFY(tree.refreshed);
3706     tree.refreshed = false;
3707     parent->addChild(new QTreeWidgetItem({ "child" }));
3708     QTRY_VERIFY(tree.refreshed);
3709 
3710 }
3711 
3712 void tst_QTreeView::task220298_selectColumns()
3713 {
3714     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
3715         QSKIP("Wayland: This fails. Figure out why.");
3716 
3717     //this is a very simple 3x3 model where the internalId of the index are different for each cell
3718     class Model : public QAbstractTableModel
3719     {
3720         public:
3721             int columnCount(const QModelIndex & parent = QModelIndex()) const override
3722             { return parent.isValid() ? 0 : 3; }
3723             int rowCount(const QModelIndex & parent = QModelIndex()) const override
3724             { return parent.isValid() ? 0 : 3; }
3725 
3726             QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const override
3727             {
3728                 if (role == Qt::DisplayRole) {
3729                     return QVariant(QString::number(index.column()) + QLatin1Char('-')
3730                         + QString::number(index.row()));
3731                 }
3732                 return QVariant();
3733             }
3734 
3735             QModelIndex index(int row, int column, const QModelIndex & parent = QModelIndex()) const override
3736             {
3737                 return hasIndex(row, column, parent) ? createIndex(row, column, quintptr(column * 10 + row)) : QModelIndex();
3738             }
3739     };
3740 
3741     TreeView view;
3742     Model model;
3743     view.setModel(&model);
3744     view.show();
3745     QVERIFY(QTest::qWaitForWindowActive(&view));
3746     QTest::mouseClick(view.viewport(), Qt::LeftButton, {},
3747                       view.visualRect(view.model()->index(1, 1)).center());
3748     QTRY_VERIFY(view.selectedIndexes().contains(view.model()->index(1, 2)));
3749     QVERIFY(view.selectedIndexes().contains(view.model()->index(1, 1)));
3750     QVERIFY(view.selectedIndexes().contains(view.model()->index(1, 0)));
3751 }
3752 
3753 
3754 void tst_QTreeView::task224091_appendColumns()
3755 {
3756     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
3757         QSKIP("Wayland: This fails. Figure out why.");
3758 
3759     QStandardItemModel *model = new QStandardItemModel();
3760     QWidget* topLevel= new QWidget;
3761     setFrameless(topLevel);
3762     QTreeView *treeView = new QTreeView(topLevel);
3763     treeView->setModel(model);
3764     topLevel->show();
3765     treeView->resize(50, 50);
3766     QApplication::setActiveWindow(topLevel);
3767     QVERIFY(QTest::qWaitForWindowActive(topLevel));
3768 
3769     QVERIFY(!treeView->verticalScrollBar()->isVisible());
3770 
3771     QList<QStandardItem *> projlist;
3772     for (int k = 0; k < 10; ++k)
3773         projlist.append(new QStandardItem(QLatin1String("Top Level ") + QString::number(k)));
3774     model->appendColumn(projlist);
3775     model->invisibleRootItem()->appendRow(new QStandardItem("end"));
3776 
3777     QTRY_VERIFY(treeView->verticalScrollBar()->isVisible());
3778 
3779     delete topLevel;
3780     delete model;
3781 }
3782 
3783 void tst_QTreeView::task211293_removeRootIndex()
3784 {
3785     QTreeView view;
3786     QStandardItemModel model;
3787     QStandardItem *A1 = new QStandardItem("A1");
3788     QStandardItem *B11 = new QStandardItem("B1.1");
3789     QStandardItem *C111 = new QStandardItem("C1.1.1");
3790     QStandardItem *C112 = new QStandardItem("C1.1.2");
3791     QStandardItem *C113 = new QStandardItem("C1.1.3");
3792     QStandardItem *D1131 = new QStandardItem("D1.1.3.1");
3793     QStandardItem *E11311 = new QStandardItem("E1.1.3.1.1");
3794     QStandardItem *E11312 = new QStandardItem("E1.1.3.1.2");
3795     QStandardItem *E11313 = new QStandardItem("E1.1.3.1.3");
3796     QStandardItem *E11314 = new QStandardItem("E1.1.3.1.4");
3797     QStandardItem *D1132 = new QStandardItem("D1.1.3.2");
3798     QStandardItem *E11321 = new QStandardItem("E1.1.3.2.1");
3799     D1132->appendRow(E11321);
3800     D1131->appendRow(E11311);
3801     D1131->appendRow(E11312);
3802     D1131->appendRow(E11313);
3803     D1131->appendRow(E11314);
3804     C113->appendRow(D1131);
3805     C113->appendRow(D1132);
3806     B11->appendRow(C111);
3807     B11->appendRow(C112);
3808     B11->appendRow(C113);
3809     A1->appendRow(B11);
3810     model.appendRow(A1);
3811     view.setModel(&model);
3812     view.setRootIndex(model.indexFromItem(B11));
3813     view.setExpanded(model.indexFromItem(B11), true);
3814     view.setCurrentIndex(model.indexFromItem(E11314));
3815     view.setExpanded(model.indexFromItem(E11314), true);
3816     view.show();
3817     QVERIFY(QTest::qWaitForWindowExposed(&view));
3818     QVERIFY(model.removeRows(0, 1));
3819 }
3820 
3821 void tst_QTreeView::task225539_deleteModel()
3822 {
3823     QTreeView treeView;
3824     treeView.show();
3825     QStandardItemModel *model = new QStandardItemModel(&treeView);
3826 
3827     QStandardItem *parentItem = model->invisibleRootItem();
3828     QStandardItem *item = new QStandardItem(QString("item"));
3829     parentItem->appendRow(item);
3830 
3831     treeView.setModel(model);
3832 
3833     QCOMPARE(item->index(), treeView.indexAt(QPoint()));
3834 
3835     delete model;
3836 
3837     QVERIFY(!treeView.indexAt(QPoint()).isValid());
3838 }
3839 
3840 void tst_QTreeView::task230123_setItemsExpandable()
3841 {
3842     //let's check that we prevent the expansion inside a treeview
3843     //when the property is set.
3844     QTreeWidget tree;
3845 
3846     QTreeWidgetItem root;
3847     QTreeWidgetItem child;
3848     root.addChild(&child);
3849     tree.addTopLevelItem(&root);
3850 
3851     tree.setCurrentItem(&root);
3852 
3853     tree.setItemsExpandable(false);
3854 
3855     QTest::keyClick(&tree, Qt::Key_Plus);
3856     QVERIFY(!root.isExpanded());
3857 
3858     QTest::keyClick(&tree, Qt::Key_Right);
3859     QVERIFY(!root.isExpanded());
3860 
3861     tree.setItemsExpandable(true);
3862 
3863     QTest::keyClick(&tree, Qt::Key_Plus);
3864     QVERIFY(root.isExpanded());
3865 
3866     QTest::keyClick(&tree, Qt::Key_Minus);
3867     QVERIFY(!root.isExpanded());
3868 
3869     QTest::keyClick(&tree, Qt::Key_Right);
3870     QVERIFY(root.isExpanded());
3871 
3872     QTest::keyClick(&tree, Qt::Key_Left);
3873     QVERIFY(!root.isExpanded());
3874 
3875     QTest::keyClick(&tree, Qt::Key_Right);
3876     QVERIFY(root.isExpanded());
3877 
3878     const bool navToChild = tree.style()->styleHint(QStyle::SH_ItemView_ArrowKeysNavigateIntoChildren, nullptr, &tree);
3879     QTest::keyClick(&tree, Qt::Key_Right);
3880     QCOMPARE(tree.currentItem(), navToChild ? &child : &root);
3881 
3882     QTest::keyClick(&tree, Qt::Key_Right);
3883     //it should not be expanded: it has no leaf
3884     QCOMPARE(child.isExpanded(), false);
3885 
3886     QTest::keyClick(&tree, Qt::Key_Left);
3887     QCOMPARE(tree.currentItem(), &root);
3888 
3889     QTest::keyClick(&tree, Qt::Key_Left);
3890     QVERIFY(!root.isExpanded());
3891 }
3892 
3893 void tst_QTreeView::task202039_closePersistentEditor()
3894 {
3895     QStandardItemModel model(1, 1);
3896     QTreeView view;
3897     view.setModel(&model);
3898 
3899     QModelIndex current = model.index(0,0);
3900     QTest::mousePress(view.viewport(), Qt::LeftButton, {}, view.visualRect(current).center());
3901     QTest::mouseDClick(view.viewport(), Qt::LeftButton, {}, view.visualRect(current).center());
3902     QCOMPARE(view.currentIndex(), current);
3903     QVERIFY(view.indexWidget(current));
3904 
3905     view.closePersistentEditor(current);
3906     QVERIFY(!view.indexWidget(current));
3907 
3908     //here was the bug: closing the persistent editor would not reset the state
3909     //and it was impossible to go into editinon again
3910     QTest::mousePress(view.viewport(), Qt::LeftButton, {}, view.visualRect(current).center());
3911     QTest::mouseDClick(view.viewport(), Qt::LeftButton, {}, view.visualRect(current).center());
3912     QCOMPARE(view.currentIndex(), current);
3913     QVERIFY(view.indexWidget(current));
3914 }
3915 
3916 void tst_QTreeView::task238873_avoidAutoReopening()
3917 {
3918     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
3919         QSKIP("Wayland: This fails. Figure out why.");
3920 
3921     QStandardItemModel model;
3922 
3923     QStandardItem item0("row 0");
3924     QStandardItem item1("row 1");
3925     QStandardItem item2("row 2");
3926     QStandardItem item3("row 3");
3927     model.appendColumn( QList<QStandardItem*>() << &item0 << &item1 << &item2 << &item3);
3928 
3929     QStandardItem child("child");
3930     item1.appendRow( &child);
3931 
3932     QTreeView view;
3933     view.setModel(&model);
3934     view.show();
3935     view.expandAll();
3936     QVERIFY(QTest::qWaitForWindowActive(&view));
3937 
3938     QTest::mouseClick(view.viewport(), Qt::LeftButton, {}, view.visualRect(child.index()).center());
3939     QTRY_COMPARE(view.currentIndex(), child.index());
3940 
3941     view.setExpanded(item1.index(), false);
3942 
3943     QTRY_VERIFY(!view.isExpanded(item1.index()));
3944 }
3945 
3946 void tst_QTreeView::task244304_clickOnDecoration()
3947 {
3948     QTreeView view;
3949     QStandardItemModel model;
3950     QStandardItem item0("row 0");
3951     QStandardItem item00("row 0");
3952     item0.appendRow(&item00);
3953     QStandardItem item1("row 1");
3954     model.appendColumn({ &item0, &item1 });
3955     view.setModel(&model);
3956 
3957     QVERIFY(!view.currentIndex().isValid());
3958     QRect rect = view.visualRect(item0.index());
3959     //we click on the decoration
3960     QTest::mouseClick(view.viewport(), Qt::LeftButton, {},
3961                       rect.topLeft() + QPoint(-rect.left() / 2, rect.height() / 2));
3962     QVERIFY(!view.currentIndex().isValid());
3963     QVERIFY(view.isExpanded(item0.index()));
3964 
3965     rect = view.visualRect(item1.index());
3966     //the item has no decoration, it should get selected
3967     QTest::mouseClick(view.viewport(), Qt::LeftButton, {},
3968                       rect.topLeft() + QPoint(-rect.left() / 2, rect.height() / 2));
3969     QCOMPARE(view.currentIndex(), item1.index());
3970 }
3971 
3972 void tst_QTreeView::task246536_scrollbarsNotWorking()
3973 {
3974     class MyObject : public QObject
3975     {
3976     public:
3977         using QObject::QObject;
3978         bool eventFilter(QObject*, QEvent *e) override
3979         {
3980             if (e->type() == QEvent::Paint)
3981                 count++;
3982 
3983             return false;
3984         }
3985         int count = 0;
3986     };
3987     QTreeView tree;
3988     MyObject o;
3989     tree.viewport()->installEventFilter(&o);
3990     QStandardItemModel model;
3991     tree.setModel(&model);
3992     tree.show();
3993     QVERIFY(QTest::qWaitForWindowExposed(&tree));
3994     QList<QStandardItem *> items;
3995     for (int i = 0; i < 100; ++i)
3996         items << new QStandardItem(QLatin1String("item ") + QString::number(i));
3997     o.count = 0;
3998     model.invisibleRootItem()->appendColumn(items);
3999     QTRY_VERIFY(o.count > 0);
4000     o.count = 0;
4001     tree.verticalScrollBar()->setValue(50);
4002     QTRY_VERIFY(o.count > 0);
4003 }
4004 
4005 void tst_QTreeView::task250683_wrongSectionSize()
4006 {
4007     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
4008         QSKIP("Wayland: This fails. Figure out why.");
4009 
4010     QStandardItemModel model;
4011     populateFakeDirModel(&model);
4012 
4013     QTreeView treeView;
4014     treeView.header()->setSectionResizeMode(QHeaderView::ResizeToContents);
4015     treeView.setModel(&model);
4016     treeView.setColumnHidden(2, true);
4017     treeView.setColumnHidden(3, true);
4018 
4019     treeView.show();
4020     QVERIFY(QTest::qWaitForWindowActive(&treeView));
4021 
4022     QCOMPARE(treeView.header()->sectionSize(0) + treeView.header()->sectionSize(1), treeView.viewport()->width());
4023 }
4024 
4025 void tst_QTreeView::task239271_addRowsWithFirstColumnHidden()
4026 {
4027     class MyDelegate : public QStyledItemDelegate
4028     {
4029     public:
4030         void paint(QPainter *painter, const QStyleOptionViewItem &option,
4031                    const QModelIndex &index) const override
4032         {
4033             paintedIndexes << index;
4034             QStyledItemDelegate::paint(painter, option, index);
4035         }
4036         mutable QSet<QModelIndex> paintedIndexes;
4037     };
4038 
4039     QTreeView view;
4040     QStandardItemModel model;
4041     view.setModel(&model);
4042     MyDelegate delegate;
4043     view.setItemDelegate(&delegate);
4044     QStandardItem root0("root0"), root1("root1");
4045     model.invisibleRootItem()->appendRow(QList<QStandardItem*>() << &root0 << &root1);
4046     QStandardItem sub0("sub0"), sub00("sub00");
4047     root0.appendRow(QList<QStandardItem*>() << &sub0 << &sub00);
4048     view.expand(root0.index());
4049 
4050     view.hideColumn(0);
4051     view.show();
4052     QVERIFY(QTest::qWaitForWindowExposed(&view));
4053     delegate.paintedIndexes.clear();
4054     QStandardItem sub1("sub1"), sub11("sub11");
4055     root0.appendRow(QList<QStandardItem*>() << &sub1 << &sub11);
4056 
4057     //items in the 2nd column should have been painted
4058     QTRY_VERIFY(!delegate.paintedIndexes.isEmpty());
4059     QVERIFY(delegate.paintedIndexes.contains(sub00.index()));
4060     QVERIFY(delegate.paintedIndexes.contains(sub11.index()));
4061 }
4062 
4063 void tst_QTreeView::task254234_proxySort()
4064 {
4065     //based on tst_QTreeView::sortByColumn
4066     // it used not to work when setting the source of a proxy after enabling sorting
4067     QTreeView view;
4068     QStandardItemModel model(4, 2);
4069     model.setItem(0, 0, new QStandardItem("b"));
4070     model.setItem(1, 0, new QStandardItem("d"));
4071     model.setItem(2, 0, new QStandardItem("c"));
4072     model.setItem(3, 0, new QStandardItem("a"));
4073     model.setItem(0, 1, new QStandardItem("e"));
4074     model.setItem(1, 1, new QStandardItem("g"));
4075     model.setItem(2, 1, new QStandardItem("h"));
4076     model.setItem(3, 1, new QStandardItem("f"));
4077 
4078     view.sortByColumn(1, Qt::DescendingOrder);
4079     view.setSortingEnabled(true);
4080 
4081     QSortFilterProxyModel proxy;
4082     proxy.setDynamicSortFilter(true);
4083     view.setModel(&proxy);
4084     proxy.setSourceModel(&model);
4085     QCOMPARE(view.header()->sortIndicatorSection(), 1);
4086     QCOMPARE(view.model()->data(view.model()->index(0, 1)).toString(), QString::fromLatin1("h"));
4087     QCOMPARE(view.model()->data(view.model()->index(1, 1)).toString(), QString::fromLatin1("g"));
4088 }
4089 
4090 void tst_QTreeView::task248022_changeSelection()
4091 {
4092     //we check that changing the selection between the mouse press and the mouse release
4093     //works correctly
4094     TreeView view;
4095     const QStringList list({"1", "2"});
4096     QStringListModel model(list);
4097     view.setSelectionMode(QAbstractItemView::ExtendedSelection);
4098     view.setModel(&model);
4099     connect(view.selectionModel(), &QItemSelectionModel::selectionChanged,
4100             &view, &TreeView::handleSelectionChanged);
4101     QTest::mouseClick(view.viewport(), Qt::LeftButton, {},
4102                       view.visualRect(model.index(1)).center());
4103     QCOMPARE(view.selectionModel()->selectedIndexes().count(), list.count());
4104 }
4105 
4106 void tst_QTreeView::task245654_changeModelAndExpandAll()
4107 {
4108     QTreeView view;
4109     QScopedPointer<QStandardItemModel> model(new QStandardItemModel);
4110     QStandardItem *top = new QStandardItem("top");
4111     QStandardItem *sub = new QStandardItem("sub");
4112     top->appendRow(sub);
4113     model->appendRow(top);
4114     view.setModel(model.data());
4115     view.expandAll();
4116     view.show();
4117     QVERIFY(QTest::qWaitForWindowExposed(&view));
4118     QTRY_VERIFY(view.isExpanded(top->index()));
4119 
4120     //now let's try to delete the model
4121     //then repopulate and expand again
4122     model.reset(new QStandardItemModel);
4123     top = new QStandardItem("top");
4124     sub = new QStandardItem("sub");
4125     top->appendRow(sub);
4126     model->appendRow(top);
4127     view.setModel(model.data());
4128     view.expandAll();
4129     QTRY_VERIFY(view.isExpanded(top->index()));
4130 }
4131 
4132 void tst_QTreeView::doubleClickedWithSpans()
4133 {
4134     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
4135         QSKIP("Wayland: This fails. Figure out why.");
4136 
4137     QTreeView view;
4138     QStandardItemModel model(1, 2);
4139     view.setModel(&model);
4140     view.setFirstColumnSpanned(0, QModelIndex(), true);
4141     view.show();
4142     QApplication::setActiveWindow(&view);
4143     QVERIFY(QTest::qWaitForWindowActive(&view));
4144     QVERIFY(view.isActiveWindow());
4145 
4146     QPoint p(10, 10);
4147     QCOMPARE(view.indexAt(p), model.index(0, 0));
4148     QSignalSpy spy(&view, &QAbstractItemView::doubleClicked);
4149     QTest::mousePress(view.viewport(), Qt::LeftButton, {}, p);
4150     QTest::mouseDClick(view.viewport(), Qt::LeftButton, {}, p);
4151     QTest::mouseRelease(view.viewport(), Qt::LeftButton, {}, p);
4152     QCOMPARE(spy.count(), 1);
4153 
4154     //let's click on the 2nd column
4155     p.setX(p.x() + view.header()->sectionSize(0));
4156     QCOMPARE(view.indexAt(p), model.index(0, 0));
4157 
4158     //end the previous edition
4159     QTest::mouseClick(view.viewport(), Qt::LeftButton, {}, p);
4160     QTest::mousePress(view.viewport(), Qt::LeftButton, {}, p);
4161     QTest::mouseDClick(view.viewport(), Qt::LeftButton, {}, p);
4162     QTest::mouseRelease(view.viewport(), Qt::LeftButton, {}, p);
4163     QTRY_COMPARE(spy.count(), 2);
4164 }
4165 
4166 void tst_QTreeView::taskQTBUG_6450_selectAllWith1stColumnHidden()
4167 {
4168     QTreeWidget tree;
4169     tree.setSelectionMode(QAbstractItemView::MultiSelection);
4170     tree.setColumnCount(2);
4171     QList<QTreeWidgetItem *> items;
4172     const int nrRows = 10;
4173     for (int i = 0; i < nrRows; ++i) {
4174         const QString text = QLatin1String("item: ") + QString::number(i);
4175         items.append(new QTreeWidgetItem(static_cast<QTreeWidget *>(nullptr),
4176                                          QStringList(text)));
4177         items.last()->setText(1, QString("is an item"));
4178     }
4179     tree.insertTopLevelItems(0, items);
4180 
4181     tree.hideColumn(0);
4182     tree.selectAll();
4183 
4184     QVERIFY(tree.selectionModel()->hasSelection());
4185     for (int i = 0; i < nrRows; ++i)
4186         QVERIFY(tree.selectionModel()->isRowSelected(i, QModelIndex()));
4187 }
4188 
4189 class TreeViewQTBUG_9216 : public QTreeView
4190 {
4191     Q_OBJECT
4192 public:
4193     void paintEvent(QPaintEvent *event) override
4194     {
4195         if (doCompare)
4196             QCOMPARE(event->rect(), viewport()->rect());
4197         QTreeView::paintEvent(event);
4198         painted++;
4199     }
4200     int painted = 0;
4201     bool doCompare = false;
4202 };
4203 
4204 void tst_QTreeView::taskQTBUG_9216_setSizeAndUniformRowHeightsWrongRepaint()
4205 {
4206     QStandardItemModel model(10, 10, this);
4207     for (int row = 0; row < 10; row++) {
4208         const QString prefix = QLatin1String("row ") + QString::number(row) + QLatin1String(", col ");
4209         for (int col = 0; col < 10; col++)
4210             model.setItem(row, col, new QStandardItem(prefix + QString::number(col)));
4211     }
4212     TreeViewQTBUG_9216 view;
4213     view.setUniformRowHeights(true);
4214     view.setModel(&model);
4215     view.painted = 0;
4216     view.doCompare = false;
4217     view.show();
4218     QVERIFY(QTest::qWaitForWindowExposed(&view));
4219     QTRY_VERIFY(view.painted > 0);
4220 
4221     QTest::qWait(100);  // This one is needed to make the test fail before the patch.
4222     view.painted = 0;
4223     view.doCompare = true;
4224     model.setData(model.index(0, 0), QVariant(QSize(50, 50)), Qt::SizeHintRole);
4225     QTRY_VERIFY(view.painted > 0);
4226 }
4227 
4228 void tst_QTreeView::keyboardNavigationWithDisabled()
4229 {
4230     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
4231         QSKIP("Wayland: This fails. Figure out why.");
4232 
4233     QWidget topLevel;
4234     QTreeView view(&topLevel);
4235     QStandardItemModel model(90, 0);
4236     for (int i = 0; i < 90; i ++) {
4237         model.setItem(i, new QStandardItem(QString::number(i)));
4238         model.item(i)->setEnabled(i % 6 == 0);
4239     }
4240     view.setModel(&model);
4241 
4242     view.resize(200, view.visualRect(model.index(0,0)).height()*10);
4243     topLevel.show();
4244     QApplication::setActiveWindow(&topLevel);
4245     QVERIFY(QTest::qWaitForWindowActive(&topLevel));
4246     QVERIFY(topLevel.isActiveWindow());
4247 
4248     view.setCurrentIndex(model.index(1, 0));
4249     QTest::keyClick(view.viewport(), Qt::Key_Up);
4250     QCOMPARE(view.currentIndex(), model.index(0, 0));
4251     QTest::keyClick(view.viewport(), Qt::Key_Down);
4252     QCOMPARE(view.currentIndex(), model.index(6, 0));
4253     QTest::keyClick(view.viewport(), Qt::Key_PageDown);
4254     QCOMPARE(view.currentIndex(), model.index(18, 0));
4255     QTest::keyClick(view.viewport(), Qt::Key_Down);
4256     QCOMPARE(view.currentIndex(), model.index(24, 0));
4257     QTest::keyClick(view.viewport(), Qt::Key_PageUp);
4258     QCOMPARE(view.currentIndex(), model.index(12, 0));
4259     QTest::keyClick(view.viewport(), Qt::Key_Up);
4260     QCOMPARE(view.currentIndex(), model.index(6, 0));
4261     // QTBUG-44746 - when first/last item is disabled,
4262     // Key_PageUp/Down/Home/End will not work as expected.
4263     model.item(0)->setEnabled(false);
4264     model.item(1)->setEnabled(true);
4265     model.item(2)->setEnabled(true);
4266     model.item(model.rowCount() - 1)->setEnabled(false);
4267     model.item(model.rowCount() - 2)->setEnabled(true);
4268     model.item(model.rowCount() - 3)->setEnabled(true);
4269     // PageUp
4270     view.setCurrentIndex(model.index(2, 0));
4271     QCOMPARE(view.currentIndex(), model.index(2, 0));
4272     QTest::keyClick(view.viewport(), Qt::Key_PageUp);
4273     QCOMPARE(view.currentIndex(), model.index(1, 0));
4274     // PageDown
4275     view.setCurrentIndex(model.index(model.rowCount() - 3, 0));
4276     QCOMPARE(view.currentIndex(), model.index(model.rowCount() - 3, 0));
4277     QTest::keyClick(view.viewport(), Qt::Key_PageDown);
4278     QCOMPARE(view.currentIndex(), model.index(model.rowCount() - 2, 0));
4279     // Key_Home
4280     QTest::keyClick(view.viewport(), Qt::Key_Home);
4281     QCOMPARE(view.currentIndex(), model.index(1, 0));
4282     // Key_End
4283     QTest::keyClick(view.viewport(), Qt::Key_End);
4284     QCOMPARE(view.currentIndex(), model.index(model.rowCount() - 2, 0));
4285 }
4286 
4287 class RemoveColumnOne : public QSortFilterProxyModel
4288 {
4289     Q_OBJECT
4290 public:
4291     bool filterAcceptsColumn(int source_column, const QModelIndex &) const override
4292     {
4293         if (m_removeColumn)
4294             return source_column != 1;
4295         return true;
4296     }
4297     void removeColumn()
4298     {
4299         m_removeColumn = true;
4300         invalidate();
4301     }
4302 private:
4303     bool m_removeColumn = false;
4304 };
4305 
4306 
4307 void tst_QTreeView::saveRestoreState()
4308 {
4309     QStandardItemModel model;
4310     for (int i = 0; i < 100; i++) {
4311         model.appendRow({new QStandardItem(QStringLiteral("item ") + QString::number(i)),
4312                          new QStandardItem(QStringLiteral("hidden by proxy")),
4313                          new QStandardItem(QStringLiteral("hidden by user")) });
4314     }
4315     QCOMPARE(model.columnCount(), 3);
4316 
4317     RemoveColumnOne proxy;
4318     proxy.setSourceModel(&model);
4319     QCOMPARE(proxy.columnCount(), 3);
4320 
4321     QTreeView view;
4322     view.setModel(&proxy);
4323     view.resize(500, 500);
4324     view.show();
4325     view.header()->hideSection(2);
4326     QVERIFY(view.header()->isSectionHidden(2));
4327     proxy.removeColumn();
4328     QCOMPARE(proxy.columnCount(), 2);
4329     QVERIFY(view.header()->isSectionHidden(1));
4330     const QByteArray data = view.header()->saveState();
4331 
4332     QTreeView view2;
4333     view2.setModel(&proxy);
4334     view2.resize(500, 500);
4335     view2.show();
4336     view2.header()->restoreState(data);
4337     QVERIFY(view2.header()->isSectionHidden(1));
4338 }
4339 
4340 class Model_11466 : public QAbstractItemModel
4341 {
4342     Q_OBJECT
4343 public:
4344     Model_11466(QObject *parent = nullptr) : QAbstractItemModel(parent)
4345         , m_selectionModel(new QItemSelectionModel(this, this))
4346     {
4347         connect(m_selectionModel, &QItemSelectionModel::currentChanged,
4348                 this, &Model_11466::slotCurrentChanged);
4349     }
4350 
4351     int rowCount(const QModelIndex &parent) const override
4352     {
4353         if (parent.isValid())
4354             return (parent.internalId() == 0) ? 4 : 0;
4355         return 2; // two top level items
4356     }
4357 
4358     int columnCount(const QModelIndex & /* parent */) const override
4359     {
4360         return 2;
4361     }
4362 
4363     QVariant data(const QModelIndex &index, int role) const override
4364     {
4365         if (role == Qt::DisplayRole && index.isValid()) {
4366             qint64 parentRowPlusOne = qint64(index.internalId());
4367             QString str;
4368             QTextStream stream(&str);
4369             if (parentRowPlusOne > 0)
4370                 stream << parentRowPlusOne << " -> " << index.row() << " : " << index.column();
4371             else
4372                 stream << index.row() << " : " << index.column();
4373             return QVariant(str);
4374         }
4375         return QVariant();
4376     }
4377 
4378     QModelIndex parent(const QModelIndex &index) const override
4379     {
4380         if (index.isValid()) {
4381             qint64 parentRowPlusOne = qint64(index.internalId());
4382             if (parentRowPlusOne > 0) {
4383                 int row = static_cast<int>(parentRowPlusOne - 1);
4384                 return createIndex(row, 0);
4385             }
4386         }
4387         return QModelIndex();
4388     }
4389 
4390     void bindView(QTreeView *view)
4391     {
4392         // sets the view to this model with a shared selection model
4393         QItemSelectionModel *oldModel = view->selectionModel();
4394         if (oldModel != m_selectionModel)
4395             delete oldModel;
4396         view->setModel(this); // this creates a new selection model for the view, but we don't want it either ...
4397         oldModel = view->selectionModel();
4398         view->setSelectionModel(m_selectionModel);
4399         delete oldModel;
4400     }
4401 
4402     QModelIndex index(int row, int column, const QModelIndex &parent) const override
4403     {
4404         return createIndex(row, column, parent.isValid() ? quintptr(parent.row() + 1) : quintptr(0));
4405     }
4406 
4407 public slots:
4408     void slotCurrentChanged(const QModelIndex &current,const QModelIndex &)
4409     {
4410         if (m_block)
4411             return;
4412 
4413         if (current.isValid()) {
4414             int selectedRow = current.row();
4415             const quintptr parentRowPlusOne = current.internalId();
4416 
4417             for (int i = 0; i < 2; ++i) {
4418                 // announce the removal of all non top level items
4419                 beginRemoveRows(createIndex(i, 0), 0, 3);
4420                 // nothing to actually do for the removal
4421                 endRemoveRows();
4422 
4423                 // put them back in again
4424                 beginInsertRows(createIndex(i, 0), 0, 3);
4425                 // nothing to actually do for the insertion
4426                 endInsertRows();
4427             }
4428             // reselect the current item ...
4429             QModelIndex selectedIndex = createIndex(selectedRow, 0, parentRowPlusOne);
4430 
4431             m_block = true; // recursion block
4432             m_selectionModel->select(selectedIndex, QItemSelectionModel::ClearAndSelect|QItemSelectionModel::Current|QItemSelectionModel::Rows);
4433             m_selectionModel->setCurrentIndex(selectedIndex, QItemSelectionModel::NoUpdate);
4434             m_block = false;
4435         } else {
4436             m_selectionModel->clear();
4437         }
4438     }
4439 
4440 private:
4441     bool m_block = false;
4442     QItemSelectionModel *m_selectionModel;
4443 };
4444 
4445 void tst_QTreeView::taskQTBUG_11466_keyboardNavigationRegression()
4446 {
4447     QTreeView treeView;
4448     treeView.setSelectionBehavior(QAbstractItemView::SelectRows);
4449     treeView.setSelectionMode(QAbstractItemView::SingleSelection);
4450     Model_11466 model(&treeView);
4451     model.bindView(&treeView);
4452     treeView.expandAll();
4453     treeView.show();
4454     QVERIFY(QTest::qWaitForWindowExposed(&treeView));
4455 
4456     QTest::keyPress(treeView.viewport(), Qt::Key_Down);
4457     QTRY_COMPARE(treeView.currentIndex(), treeView.selectionModel()->selection().indexes().first());
4458 }
4459 
4460 void tst_QTreeView::taskQTBUG_13567_removeLastItemRegression()
4461 {
4462     QtTestModel model(200, 1);
4463 
4464     QTreeView view;
4465     view.setSelectionMode(QAbstractItemView::ExtendedSelection);
4466     view.setModel(&model);
4467     view.show();
4468     QVERIFY(QTest::qWaitForWindowExposed(&view));
4469 
4470     view.scrollToBottom();
4471     QTest::qWait(10);
4472     CHECK_VISIBLE(199, 0);
4473 
4474     view.setCurrentIndex(model.index(199, 0));
4475     model.removeLastRow();
4476     QTRY_COMPARE(view.currentIndex(), model.index(198, 0));
4477     CHECK_VISIBLE(198, 0);
4478 }
4479 
4480 // From QTBUG-25333 (QTreeWidget drag crashes when there was a hidden item in tree)
4481 // The test passes simply if it doesn't crash, hence there are no calls
4482 // to QCOMPARE() or QVERIFY().
4483 // Note: define QT_BUILD_INTERNAL to run this test
4484 void tst_QTreeView::taskQTBUG_25333_adjustViewOptionsForIndex()
4485 {
4486     QTreeView view;
4487     QStandardItemModel model;
4488     QStandardItem *item1 = new QStandardItem("Item1");
4489     QStandardItem *item2 = new QStandardItem("Item2");
4490     QStandardItem *item3 = new QStandardItem("Item3");
4491     QStandardItem *data1 = new QStandardItem("Data1");
4492     QStandardItem *data2 = new QStandardItem("Data2");
4493     QStandardItem *data3 = new QStandardItem("Data3");
4494 
4495     // Create a treeview
4496     model.appendRow({ item1, data1 });
4497     model.appendRow({ item2, data2 });
4498     model.appendRow({ item3, data3 });
4499 
4500     view.setModel(&model);
4501 
4502     // Hide a row
4503     view.setRowHidden(1, QModelIndex(), true);
4504     view.expandAll();
4505 
4506     view.show();
4507 
4508 #ifdef QT_BUILD_INTERNAL
4509     {
4510         QStyleOptionViewItem option;
4511 
4512         view.d_func()->adjustViewOptionsForIndex(&option, model.indexFromItem(item1));
4513 
4514         view.d_func()->adjustViewOptionsForIndex(&option, model.indexFromItem(item3));
4515     }
4516 #endif
4517 
4518 }
4519 
4520 void tst_QTreeView::taskQTBUG_18539_emitLayoutChanged()
4521 {
4522     qRegisterMetaType<QList<QPersistentModelIndex>>();
4523     qRegisterMetaType<QAbstractItemModel::LayoutChangeHint>();
4524 
4525     QTreeView view;
4526 
4527     QStandardItem* item = new QStandardItem("Orig");
4528     QStandardItem* child = new QStandardItem("Child");
4529     item->setChild(0, 0, child);
4530 
4531     QStandardItemModel model;
4532     model.appendRow(item);
4533 
4534     view.setModel(&model);
4535 
4536     QStandardItem* replacementItem = new QStandardItem("Replacement");
4537     QStandardItem* replacementChild = new QStandardItem("ReplacementChild");
4538 
4539     replacementItem->setChild(0, 0, replacementChild);
4540 
4541     QSignalSpy beforeSpy(&model, &QAbstractItemModel::layoutAboutToBeChanged);
4542     QSignalSpy afterSpy(&model, &QAbstractItemModel::layoutChanged);
4543 
4544     QSignalSpy beforeRISpy(&model, &QAbstractItemModel::rowsAboutToBeInserted);
4545     QSignalSpy afterRISpy(&model, &QAbstractItemModel::rowsInserted);
4546 
4547     QSignalSpy beforeRRSpy(&model, &QAbstractItemModel::rowsAboutToBeRemoved);
4548     QSignalSpy afterRRSpy(&model, &QAbstractItemModel::rowsRemoved);
4549 
4550     model.setItem(0, 0, replacementItem);
4551 
4552     QCOMPARE(beforeSpy.size(), 1);
4553     QCOMPARE(afterSpy.size(), 1);
4554 
4555     QCOMPARE(beforeRISpy.size(), 0);
4556     QCOMPARE(afterRISpy.size(), 0);
4557 
4558     QCOMPARE(beforeRISpy.size(), 0);
4559     QCOMPARE(afterRISpy.size(), 0);
4560 }
4561 
4562 void tst_QTreeView::taskQTBUG_8176_emitOnExpandAll()
4563 {
4564     QTreeWidget tw;
4565     QTreeWidgetItem *item = new QTreeWidgetItem(&tw, QStringList(QString("item 1")));
4566     QTreeWidgetItem *item2 = new QTreeWidgetItem(item, QStringList(QString("item 2")));
4567     new QTreeWidgetItem(item2, QStringList(QString("item 3")));
4568     new QTreeWidgetItem(item2, QStringList(QString("item 4")));
4569     QTreeWidgetItem *item5 = new QTreeWidgetItem(&tw, QStringList(QString("item 5")));
4570     new QTreeWidgetItem(item5, QStringList(QString("item 6")));
4571     QSignalSpy spy(&tw, &QTreeView::expanded);
4572 
4573     // expand all
4574     tw.expandAll();
4575     QCOMPARE(spy.size(), 6);
4576     spy.clear();
4577     tw.collapseAll();
4578     item2->setExpanded(true);
4579     spy.clear();
4580     tw.expandAll();
4581     QCOMPARE(spy.size(), 5);
4582 
4583     // collapse all
4584     QSignalSpy spy2(&tw, &QTreeView::collapsed);
4585     tw.collapseAll();
4586     QCOMPARE(spy2.size(), 6);
4587     tw.expandAll();
4588     item2->setExpanded(false);
4589     spy2.clear();
4590     tw.collapseAll();
4591     QCOMPARE(spy2.size(), 5);
4592 
4593     // expand to depth
4594     item2->setExpanded(true);
4595     spy.clear();
4596     spy2.clear();
4597     tw.expandToDepth(0);
4598 
4599     QCOMPARE(spy.size(), 2); // item and item5 are expanded
4600     QCOMPARE(spy2.size(), 1); // item2 is collapsed
4601 }
4602 
4603 void tst_QTreeView::testInitialFocus()
4604 {
4605     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
4606         QSKIP("Wayland: This fails. Figure out why.");
4607 
4608     QTreeWidget treeWidget;
4609     treeWidget.setColumnCount(5);
4610     new QTreeWidgetItem(&treeWidget, QString("1;2;3;4;5").split(QLatin1Char(';')));
4611     treeWidget.setTreePosition(2);
4612     treeWidget.header()->hideSection(0);      // make sure we skip hidden section(s)
4613     treeWidget.header()->swapSections(1, 2);  // make sure that we look for first visual index (and not first logical)
4614     treeWidget.show();
4615     QVERIFY(QTest::qWaitForWindowExposed(&treeWidget));
4616     QTRY_COMPARE(treeWidget.currentIndex().column(), 2);
4617 }
4618 
4619 #if QT_CONFIG(animation)
4620 void tst_QTreeView::quickExpandCollapse()
4621 {
4622     //this unit tests makes sure the state after the animation is restored correctly
4623     //after starting a 2nd animation while the first one was still on-going
4624     //this tests that the stateBeforeAnimation is not set to AnimatingState
4625     QTreeView tree;
4626     tree.setAnimated(true);
4627     QStandardItemModel model;
4628     QStandardItem *root = new QStandardItem("root");
4629     root->appendRow(new QStandardItem("subnode"));
4630     model.appendRow(root);
4631     tree.setModel(&model);
4632 
4633     QModelIndex rootIndex = root->index();
4634     QVERIFY(rootIndex.isValid());
4635 
4636     tree.show();
4637     QVERIFY(QTest::qWaitForWindowExposed(&tree));
4638 
4639     const QAbstractItemView::State initialState = tree.state();
4640 
4641     tree.expand(rootIndex);
4642     QCOMPARE(tree.state(), QTreeView::AnimatingState);
4643 
4644     tree.collapse(rootIndex);
4645     QCOMPARE(tree.state(), QTreeView::AnimatingState);
4646 
4647     //the animation lasts for 250ms max so 5000 (default) should be enough
4648     QTRY_COMPARE(tree.state(), initialState);
4649 }
4650 #endif // animation
4651 
4652 void tst_QTreeView::taskQTBUG_37813_crash()
4653 {
4654     // QTBUG_37813: Crash in visual / logical index mapping in QTreeViewPrivate::adjustViewOptionsForIndex()
4655     // when hiding/moving columns. It is reproduceable with a QTreeWidget only.
4656 #ifdef QT_BUILD_INTERNAL
4657     QTreeWidget treeWidget;
4658     treeWidget.setDragEnabled(true);
4659     treeWidget.setColumnCount(2);
4660     QList<QTreeWidgetItem *> items;
4661     for (int r = 0; r < 2; ++r) {
4662         const QString prefix = QLatin1String("Row ") + QString::number(r) + QLatin1String(" Column ");
4663         QTreeWidgetItem *item = new QTreeWidgetItem();
4664         for (int c = 0; c < treeWidget.columnCount(); ++c)
4665             item->setText(c, prefix + QString::number(c));
4666         items.append(item);
4667     }
4668     treeWidget.addTopLevelItems(items);
4669     treeWidget.setColumnHidden(0, true);
4670     treeWidget.header()->moveSection(0, 1);
4671     QItemSelection sel(treeWidget.model()->index(0, 0), treeWidget.model()->index(0, 1));
4672     QRect rect;
4673     QAbstractItemViewPrivate *av = static_cast<QAbstractItemViewPrivate*>(qt_widget_private(&treeWidget));
4674     const QPixmap pixmap = av->renderToPixmap(sel.indexes(), &rect);
4675     QVERIFY(pixmap.size().isValid());
4676 #endif // QT_BUILD_INTERNAL
4677 }
4678 
4679 // QTBUG-45697: Using a QTreeView with a multi-column model filtered by QSortFilterProxyModel,
4680 // when sorting the source model while the widget is not yet visible and showing the widget
4681 // later on, corruption occurs in QTreeView.
4682 class Qtbug45697TestWidget : public QWidget
4683 {
4684    Q_OBJECT
4685 public:
4686     static const int columnCount = 3;
4687 
4688     explicit Qtbug45697TestWidget(QWidget *parent = nullptr);
4689     int timerTick() const { return m_timerTick; }
4690 
4691 public slots:
4692     void slotTimer();
4693 
4694 private:
4695    QTreeView *m_treeView;
4696    QStandardItemModel *m_model;
4697    QSortFilterProxyModel *m_sortFilterProxyModel;
4698    int m_timerTick = 0;
4699 };
4700 
4701 Qtbug45697TestWidget::Qtbug45697TestWidget(QWidget *parent)
4702     : QWidget(parent), m_treeView(new QTreeView(this))
4703     , m_model(new QStandardItemModel(0, Qtbug45697TestWidget::columnCount, this))
4704     , m_sortFilterProxyModel(new QSortFilterProxyModel(this))
4705  {
4706    QVBoxLayout *vBoxLayout = new QVBoxLayout(this);
4707    vBoxLayout->addWidget(m_treeView);
4708 
4709    for (char sortChar = 'z'; sortChar >= 'a' ; --sortChar) {
4710        QList<QStandardItem *>  items;
4711        for (int column = 0; column < Qtbug45697TestWidget::columnCount; ++column) {
4712            const QString text = QLatin1Char(sortChar) + QLatin1String(" ") + QString::number(column);
4713            items.append(new QStandardItem(text));
4714        }
4715        m_model->appendRow(items);
4716    }
4717 
4718    m_sortFilterProxyModel->setSourceModel(m_model);
4719    m_treeView->setModel(m_sortFilterProxyModel);
4720 
4721    QHeaderView *headerView = m_treeView->header();
4722    for (int s = 1, lastSection = headerView->count() - 1; s < lastSection; ++s)
4723        headerView->setSectionResizeMode(s, QHeaderView::ResizeToContents);
4724 
4725    QTimer *timer = new QTimer(this);
4726    timer->setInterval(50);
4727    connect(timer, &QTimer::timeout, this, &Qtbug45697TestWidget::slotTimer);
4728    timer->start();
4729 }
4730 
4731 void Qtbug45697TestWidget::slotTimer()
4732 {
4733     switch (m_timerTick++) {
4734     case 0:
4735         m_model->sort(0);
4736         break;
4737     case 1:
4738         show();
4739         break;
4740     default:
4741         close();
4742         break;
4743     }
4744 }
4745 
4746 void tst_QTreeView::taskQTBUG_45697_crash()
4747 {
4748     Qtbug45697TestWidget testWidget;
4749     testWidget.setWindowTitle(QTest::currentTestFunction());
4750     testWidget.resize(400, 400);
4751     testWidget.move(QGuiApplication::primaryScreen()->availableGeometry().topLeft() + QPoint(100, 100));
4752     QTRY_VERIFY(testWidget.timerTick() >= 2);
4753 }
4754 
4755 void tst_QTreeView::taskQTBUG_7232_AllowUserToControlSingleStep()
4756 {
4757     // When we set the scrollMode to ScrollPerPixel it will adjust the scrollbars singleStep automatically
4758     // Setting a singlestep on a scrollbar should however imply that the user takes control.
4759     // Setting a singlestep to -1 return to an automatic control of the singleStep.
4760     QTreeWidget t;
4761     t.setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
4762     t.setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
4763     t.setColumnCount(2);
4764     QTreeWidgetItem *mainItem = new QTreeWidgetItem(&t, QStringList() << "Root");
4765     for (int i = 0; i < 200; ++i) {
4766         QTreeWidgetItem *item = new QTreeWidgetItem(mainItem, QStringList(QString("Item")));
4767         new QTreeWidgetItem(item, QStringList() << "Child" << "1");
4768         new QTreeWidgetItem(item, QStringList() << "Child" << "2");
4769         new QTreeWidgetItem(item, QStringList() << "Child" << "3");
4770     }
4771     t.expandAll();
4772 
4773     t.setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
4774     t.setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);
4775 
4776     t.setGeometry(200, 200, 200, 200);
4777     int vStep1 = t.verticalScrollBar()->singleStep();
4778     int hStep1 = t.horizontalScrollBar()->singleStep();
4779     QVERIFY(vStep1 > 1);
4780     QVERIFY(hStep1 > 1);
4781 
4782     t.verticalScrollBar()->setSingleStep(1);
4783     t.setGeometry(300, 300, 300, 300);
4784     QCOMPARE(t.verticalScrollBar()->singleStep(), 1);
4785 
4786     t.horizontalScrollBar()->setSingleStep(1);
4787     t.setGeometry(400, 400, 400, 400);
4788     QCOMPARE(t.horizontalScrollBar()->singleStep(), 1);
4789 
4790     t.setGeometry(200, 200, 200, 200);
4791     t.verticalScrollBar()->setSingleStep(-1);
4792     t.horizontalScrollBar()->setSingleStep(-1);
4793     QCOMPARE(vStep1, t.verticalScrollBar()->singleStep());
4794     QCOMPARE(hStep1, t.horizontalScrollBar()->singleStep());
4795 }
4796 
4797 void tst_QTreeView::statusTip_data()
4798 {
4799     QTest::addColumn<bool>("intermediateParent");
4800     QTest::newRow("noIntermediate") << false;
4801     QTest::newRow("intermediate") << true;
4802 }
4803 
4804 void tst_QTreeView::statusTip()
4805 {
4806     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
4807         QSKIP("Wayland: This fails. Figure out why.");
4808 
4809     QFETCH(bool, intermediateParent);
4810     QMainWindow mw;
4811     QtTestModel model(5, 5);
4812     model.statusTipsEnabled = true;
4813     QTreeView *view = new QTreeView;
4814     view->setModel(&model);
4815     view->viewport()->setMouseTracking(true);
4816     view->header()->viewport()->setMouseTracking(true);
4817     if (intermediateParent) {
4818         QWidget *inter = new QWidget;
4819         QVBoxLayout *vbox = new QVBoxLayout;
4820         inter->setLayout(vbox);
4821         vbox->addWidget(view);
4822         mw.setCentralWidget(inter);
4823     } else {
4824         mw.setCentralWidget(view);
4825     }
4826     mw.statusBar();
4827     mw.setGeometry(QRect(QPoint(QGuiApplication::primaryScreen()->geometry().center() - QPoint(250, 250)),
4828                                 QSize(500, 500)));
4829     mw.show();
4830     QApplication::setActiveWindow(&mw);
4831     QVERIFY(QTest::qWaitForWindowActive(&mw));
4832     // Ensure it is moved away first and then moved to the relevant section
4833     QTest::mouseMove(mw.windowHandle(), view->mapTo(&mw, view->rect().bottomLeft() + QPoint(20, 20)));
4834     QPoint centerPoint = view->viewport()->mapTo(&mw, view->visualRect(model.index(0, 0)).center());
4835     QTest::mouseMove(mw.windowHandle(), centerPoint);
4836     QTRY_COMPARE(mw.statusBar()->currentMessage(), QLatin1String("[0,0,0] -- Status"));
4837     centerPoint = view->viewport()->mapTo(&mw, view->visualRect(model.index(0, 1)).center());
4838     QTest::mouseMove(mw.windowHandle(), centerPoint);
4839     QTRY_COMPARE(mw.statusBar()->currentMessage(), QLatin1String("[0,1,0] -- Status"));
4840     centerPoint = view->header()->viewport()->mapTo(&mw,
4841                     QPoint(view->header()->sectionViewportPosition(0) + view->header()->sectionSize(0) / 2,
4842                            view->header()->height() / 2));
4843     QTest::mouseMove(mw.windowHandle(), centerPoint);
4844     QTRY_COMPARE(mw.statusBar()->currentMessage(), QLatin1String("Header 0 -- Status"));
4845 }
4846 
4847 class FetchMoreModel : public QStandardItemModel
4848 {
4849     Q_OBJECT
4850 public:
4851     FetchMoreModel(QObject *parent = nullptr) : QStandardItemModel(parent)
4852     {
4853         for (int i = 0; i < 20; ++i) {
4854             QStandardItem *item = new QStandardItem("Row");
4855             item->appendRow(new QStandardItem("Child"));
4856             appendRow(item);
4857         }
4858     }
4859     bool canFetchMore(const QModelIndex &parent) const override
4860     {
4861         if (!canFetchReady || !parent.isValid())
4862             return false;
4863         if (!parent.parent().isValid())
4864             return rowCount(parent) < 20;
4865         return false;
4866     }
4867     void fetchMore(const QModelIndex &parent) override
4868     {
4869         QStandardItem *item = itemFromIndex(parent);
4870         for (int i = 0; i < 19; ++i)
4871             item->appendRow(new QStandardItem(QStringLiteral("New Child ") + QString::number(i)));
4872     }
4873     bool canFetchReady = false;
4874 };
4875 
4876 void tst_QTreeView::fetchMoreOnScroll()
4877 {
4878     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
4879         QSKIP("Wayland: This fails. Figure out why.");
4880 
4881     QTreeView tw;
4882     FetchMoreModel im;
4883     tw.setModel(&im);
4884     tw.show();
4885     tw.expandAll();
4886     QVERIFY(QTest::qWaitForWindowActive(&tw));
4887     // Now we can allow the fetch to happen
4888     im.canFetchReady = true;
4889     tw.verticalScrollBar()->setValue(tw.verticalScrollBar()->maximum());
4890     // The item should have now fetched the other children, thus bringing the count to 20
4891     QCOMPARE(im.item(19)->rowCount(), 20);
4892 }
4893 
4894 void tst_QTreeView::checkIntersectedRect_data()
4895 {
4896     auto createModel = [](int rowCount)
4897     {
4898         QStandardItemModel *model = new QStandardItemModel;
4899         for (int i = 0; i < rowCount; ++i) {
4900             const QList<QStandardItem *> sil({new QStandardItem(QString("Row %1 Item").arg(i)),
4901                                               new QStandardItem(QString("2nd column"))});
4902             model->appendRow(sil);
4903         }
4904         for (int i = 2; i < 4; ++i) {
4905             const QList<QStandardItem *> sil({new QStandardItem(QString("Row %1 Item").arg(i)),
4906                                               new QStandardItem(QString("2nd column"))});
4907             model->item(i)->appendRow(sil);
4908         }
4909         return model;
4910     };
4911     QTest::addColumn<QStandardItemModel *>("model");
4912     QTest::addColumn<QList<QModelIndex>>("changedIndexes");
4913     QTest::addColumn<bool>("isEmpty");
4914     {
4915         auto model = createModel(5);
4916         QTest::newRow("multiple columns")
4917                 << model << QList<QModelIndex>({ model->index(0, 0), model->index(0, 1) }) << false;
4918     }
4919     {
4920         auto model = createModel(5);
4921         QTest::newRow("multiple rows")
4922                 << model
4923                 << QList<QModelIndex>(
4924                            { model->index(0, 0), model->index(1, 0), model->index(2, 0) })
4925                 << false;
4926     }
4927     {
4928         auto model = createModel(5);
4929         const QModelIndex idxRow2(model->indexFromItem(model->item(2)));
4930         QTest::newRow("child row")
4931                 << model
4932                 << QList<QModelIndex>({ model->index(0, 0, idxRow2), model->index(0, 1, idxRow2) })
4933                 << false;
4934         }
4935     {
4936         auto model = createModel(5);
4937         QTest::newRow("hidden row")
4938                 << model << QList<QModelIndex>({ model->index(3, 0), model->index(3, 1) }) << true;
4939     }
4940     {
4941         auto model = createModel(5);
4942         const QModelIndex idxRow3(model->indexFromItem(model->item(3)));
4943         QTest::newRow("hidden child row")
4944                 << model
4945                 << QList<QModelIndex>({ model->index(0, 0, idxRow3), model->index(0, 1, idxRow3) })
4946                 << true;
4947     }
4948     {
4949         auto model = createModel(50);
4950         QTest::newRow("row outside viewport")
4951                 << model << QList<QModelIndex>({ model->index(49, 0), model->index(49, 1) })
4952                 << true;
4953     }
4954 }
4955 
4956 void tst_QTreeView::checkIntersectedRect()
4957 {
4958     QFETCH(QStandardItemModel *, model);
4959     QFETCH(const QList<QModelIndex>, changedIndexes);
4960     QFETCH(bool, isEmpty);
4961 
4962     TreeView view;
4963     model->setParent(&view);
4964     view.setModel(model);
4965     view.resize(400, 400);
4966     view.show();
4967     view.expandAll();
4968     view.setRowHidden(3, QModelIndex(), true);
4969     QVERIFY(QTest::qWaitForWindowExposed(&view));
4970 
4971     view.m_intersectecRect = QRect();
4972     emit view.model()->dataChanged(changedIndexes.first(), changedIndexes.last());
4973     if (isEmpty) {
4974         QVERIFY(view.m_intersectecRect.isEmpty());
4975     } else if (!changedIndexes.first().isValid()) {
4976         QCOMPARE(view.m_intersectecRect, view.viewport()->rect());
4977     } else {
4978         const auto parent = changedIndexes.first().parent();
4979         const int rCount = view.model()->rowCount(parent);
4980         const int cCount = view.model()->columnCount(parent);
4981         for (int r = 0; r < rCount; ++r) {
4982             for (int c = 0; c < cCount; ++c) {
4983                 const QModelIndex &idx = view.model()->index(r, c, parent);
4984                 const auto rect = view.visualRect(idx);
4985                 if (changedIndexes.contains(idx))
4986                     QVERIFY(view.m_intersectecRect.contains(rect));
4987                 else
4988                     QVERIFY(!view.m_intersectecRect.contains(rect));
4989             }
4990         }
4991     }
4992 }
4993 
4994 static void fillModeltaskQTBUG_8376(QAbstractItemModel &model)
4995 {
4996     model.insertRow(0);
4997     model.insertColumn(0);
4998     model.insertColumn(1);
4999     QModelIndex index = model.index(0, 0);
5000     model.setData(index, "Level0");
5001     {
5002         model.insertRow(0, index);
5003         model.insertRow(1, index);
5004         model.insertColumn(0, index);
5005         model.insertColumn(1, index);
5006 
5007         QModelIndex idx;
5008         idx = model.index(0, 0, index);
5009         model.setData(idx, "Level1");
5010 
5011         idx = model.index(0, 1, index);
5012         model.setData(idx, "very\nvery\nhigh\ncell");
5013     }
5014 }
5015 
5016 void tst_QTreeView::taskQTBUG_8376()
5017 {
5018     QTreeView tv;
5019     QStandardItemModel model;
5020     fillModeltaskQTBUG_8376(model);
5021     tv.setModel(&model);
5022     tv.expandAll(); // init layout
5023 
5024     QModelIndex idxLvl0 = model.index(0, 0);
5025     QModelIndex idxLvl1 = model.index(0, 1, idxLvl0);
5026     const int rowHeightLvl0 = tv.rowHeight(idxLvl0);
5027     const int rowHeightLvl1Visible = tv.rowHeight(idxLvl1);
5028     QVERIFY(rowHeightLvl0 < rowHeightLvl1Visible);
5029 
5030     tv.hideColumn(1);
5031     const int rowHeightLvl1Hidden = tv.rowHeight(idxLvl1);
5032     QCOMPARE(rowHeightLvl0, rowHeightLvl1Hidden);
5033 
5034     tv.showColumn(1);
5035     const int rowHeightLvl1Visible2 = tv.rowHeight(idxLvl1);
5036     QCOMPARE(rowHeightLvl1Visible, rowHeightLvl1Visible2);
5037 }
5038 
5039 void tst_QTreeView::taskQTBUG_61476()
5040 {
5041     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
5042         QSKIP("Wayland: This fails. Figure out why.");
5043 
5044     // This checks that if a user clicks on an item to collapse it that it
5045     // does not edit (in this case change the check state) the item that is
5046     // now over the mouse just because it got a release event
5047     QTreeView tv;
5048     QStandardItemModel model;
5049     QStandardItem *lastTopLevel = nullptr;
5050     {
5051         for (int i = 0; i < 4; ++i) {
5052             QStandardItem *item = new QStandardItem(QLatin1String("Row Item"));
5053             item->setCheckable(true);
5054             item->setCheckState(Qt::Checked);
5055             model.appendRow(item);
5056             lastTopLevel = item;
5057             for (int j = 0; j < 2; ++j) {
5058                 QStandardItem *childItem = new QStandardItem(QLatin1String("Child row Item"));
5059                 childItem->setCheckable(true);
5060                 childItem->setCheckState(Qt::Checked);
5061                 item->appendRow(childItem);
5062                 QStandardItem *grandChild = new QStandardItem(QLatin1String("Grand child row Item"));
5063                 grandChild->setCheckable(true);
5064                 grandChild->setCheckState(Qt::Checked);
5065                 childItem->appendRow(grandChild);
5066             }
5067         }
5068     }
5069     tv.setModel(&model);
5070     tv.expandAll();
5071     // We need it to be this size so that the effect of the collapsing will
5072     // cause the parent item to move to be under the cursor
5073     tv.resize(200, 200);
5074     tv.show();
5075     QVERIFY(QTest::qWaitForWindowActive(&tv));
5076     tv.verticalScrollBar()->setValue(tv.verticalScrollBar()->maximum());
5077 
5078     // We want to press specifically right around where a checkbox for the
5079     // parent item could be when collapsing
5080     QTreeViewPrivate *priv = static_cast<QTreeViewPrivate*>(qt_widget_private(&tv));
5081     const QModelIndex mi = lastTopLevel->child(0)->index();
5082     const QRect rect = priv->itemDecorationRect(mi);
5083     const QPoint pos = rect.center();
5084 
5085     QTest::mousePress(tv.viewport(), Qt::LeftButton, {}, pos);
5086     const bool expandsOnPress =
5087         (tv.style()->styleHint(QStyle::SH_ListViewExpand_SelectMouseType, nullptr, &tv) == QEvent::MouseButtonPress);
5088     if (expandsOnPress)
5089         QTRY_VERIFY(!tv.isExpanded(mi));
5090 
5091     QTest::mouseRelease(tv.viewport(), Qt::LeftButton, {}, pos);
5092     QTRY_VERIFY(!tv.isExpanded(mi));
5093     QCOMPARE(lastTopLevel->checkState(), Qt::Checked);
5094 
5095     // Test that it does not toggle the check state of a previously selected item when collapsing an
5096     // item causes it to position the item under the mouse to be the decoration for the selected item
5097     tv.expandAll();
5098     tv.verticalScrollBar()->setValue(tv.verticalScrollBar()->maximum());
5099     // It is not enough to programmatically select the item, we need to have it clicked on
5100     QTest::mouseClick(tv.viewport(), Qt::LeftButton, {}, tv.visualRect(lastTopLevel->index()).center());
5101     QTest::mousePress(tv.viewport(), Qt::LeftButton, {}, pos);
5102     if (expandsOnPress)
5103         QTRY_VERIFY(!tv.isExpanded(mi));
5104     QTest::mouseRelease(tv.viewport(), Qt::LeftButton, {}, pos);
5105     QTRY_VERIFY(!tv.isExpanded(mi));
5106     QCOMPARE(lastTopLevel->checkState(), Qt::Checked);
5107 }
5108 
5109 void tst_QTreeView::fetchUntilScreenFull()
5110 {
5111     class TreeModel : public QAbstractItemModel
5112     {
5113     public:
5114         const int maxChildren = 49;
5115         explicit TreeModel(QObject* parent = nullptr) : QAbstractItemModel(parent)
5116         {
5117             QVariant rootData1("Parent Col 1");
5118             QVariant rootData2("Parent Col 2");
5119             QVector<QVariant> rootData;
5120             rootData.append(rootData1);
5121             rootData.append(rootData2);
5122 
5123             m_root = new TreeItem(rootData, nullptr);
5124 
5125             QVariant childData1("Col 1");
5126             QVariant childData2("Col 2");
5127             QVector<QVariant> childData;
5128             childData.append(childData1);
5129             childData.append(childData2);
5130 
5131             TreeItem* item_1 = new TreeItem(childData, m_root);
5132             m_root->children.append(item_1);
5133 
5134             TreeItem* item_2 = new TreeItem(childData, item_1);
5135             item_1->children.append(item_2);
5136         }
5137 
5138         QModelIndex index(const int row, const int column,
5139             const QModelIndex& parent = QModelIndex()) const override
5140         {
5141             if (!hasIndex(row, column, parent))
5142                 return QModelIndex();
5143 
5144             TreeItem* parentItem =
5145                 parent.isValid() ? static_cast<TreeItem*>(parent.internalPointer()) : m_root;
5146             TreeItem* childItem = parentItem->children.at(row);
5147             return createIndex(row, column, childItem);
5148         }
5149 
5150         int rowCount(const QModelIndex& parent) const override
5151         {
5152             if (parent.column() > 0)
5153                 return 0;
5154 
5155             TreeItem* parentItem = parent.isValid() ? static_cast<TreeItem*>(parent.internalPointer())
5156                 : m_root;
5157             return parentItem->children.count();
5158         }
5159 
5160         int columnCount(const QModelIndex&) const override { return 2; }
5161 
5162         QModelIndex parent(const QModelIndex& childIndex) const override
5163         {
5164             if (!childIndex.isValid())
5165                 return QModelIndex();
5166 
5167             TreeItem* parentItem =
5168                 static_cast<TreeItem*>(childIndex.internalPointer())->parent;
5169             return parentItem == m_root ? QModelIndex()
5170                 : createIndex(parentItem->rowInParent(), 0, parentItem);
5171         }
5172 
5173         QVariant data(const QModelIndex& index, const int role) const override
5174         {
5175             if (!index.isValid() || role != Qt::DisplayRole)
5176                 return QVariant();
5177 
5178             TreeItem* item = static_cast<TreeItem*>(index.internalPointer());
5179             return item->data.at(index.column());
5180         }
5181 
5182         bool canFetchMore(const QModelIndex& parent) const override
5183         {
5184             if (!parent.isValid()) {
5185                 return false;
5186             } else {
5187                 TreeItem* item = static_cast<TreeItem*>(parent.internalPointer());
5188                 return item->children.size() < maxChildren;
5189             }
5190         }
5191 
5192         void fetchMore(const QModelIndex& parent) override
5193         {
5194             if (!parent.isValid())
5195                 return;
5196 
5197             fetchMoreCount++;
5198             TreeItem* parentItem = static_cast<TreeItem*>(parent.internalPointer());
5199             int childCount = parentItem->children.size();
5200 
5201             beginInsertRows(parent, childCount, childCount);
5202 
5203             QVariant childData1("Col 1");
5204             QVariant childData2("Col 2");
5205             QVector<QVariant> childData;
5206             childData.append(childData1);
5207             childData.append(childData2);
5208             TreeItem* newChild = new TreeItem(childData, parentItem);
5209             parentItem->children.append(newChild);
5210 
5211             endInsertRows();
5212         }
5213 
5214         int fetchMoreCount = 0;
5215     private:
5216         struct TreeItem
5217         {
5218             TreeItem(const QVector<QVariant>& values, TreeItem* parent)
5219                 : data(values), parent(parent)
5220             {
5221             }
5222             ~TreeItem() { qDeleteAll(children); }
5223             int rowInParent() const
5224             {
5225                 if (parent)
5226                     return parent->children.indexOf(const_cast<TreeItem*>(this));
5227                 return 0;
5228             }
5229             QVector<QVariant> data;
5230             QVector<TreeItem*> children;
5231             TreeItem* parent = nullptr;
5232         };
5233         TreeItem* m_root;
5234     };
5235 
5236     QTreeView tv;
5237     TreeModel model;
5238     tv.setModel(&model);
5239 
5240     const int itemHeight = tv.sizeHintForRow(0);
5241     tv.resize(250, itemHeight * 10);
5242     tv.show();
5243     QVERIFY(QTest::qWaitForWindowExposed(&tv));
5244 
5245     tv.expand(model.index(0, 0));
5246     const int viewportHeight = tv.viewport()->height();
5247     const int itemCount = viewportHeight / itemHeight;
5248     const int minFetchCount = itemCount - 1;
5249     const int maxFetchCount = itemCount + 1;
5250 
5251     const bool expectedItemNumberFetched = model.fetchMoreCount >= minFetchCount
5252                                          && model.fetchMoreCount <= maxFetchCount;
5253     if (!expectedItemNumberFetched)
5254         qDebug() << model.fetchMoreCount << minFetchCount << maxFetchCount;
5255     QVERIFY(expectedItemNumberFetched);
5256 }
5257 
5258 
5259 QTEST_MAIN(tst_QTreeView)
5260 #include "tst_qtreeview.moc"
