Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qplatformdefs.h"
42 #include "qdatetime.h"
43 
44 #include "qcalendar.h"
45 #include "qdatastream.h"
46 #include "qdebug.h"
47 #include "qset.h"
48 #include "qlocale.h"
49 
50 #include "private/qdatetime_p.h"
51 #if QT_CONFIG(datetimeparser)
52 #include "private/qdatetimeparser_p.h"
53 #endif
54 #ifdef Q_OS_DARWIN
55 #include "private/qcore_mac_p.h"
56 #endif
57 #include "private/qgregoriancalendar_p.h"
58 #include "private/qnumeric_p.h"
59 #include "private/qstringiterator_p.h"
60 #if QT_CONFIG(timezone)
61 #include "private/qtimezoneprivate_p.h"
62 #endif
63 
64 #include <cmath>
65 #ifdef Q_OS_WIN
66 #  include <qt_windows.h>
67 #endif
68 #include <time.h>
69 #ifdef Q_CC_MINGW
70 #  include <unistd.h> // Define _POSIX_THREAD_SAFE_FUNCTIONS to obtain localtime_r()
71 #endif
72 
73 QT_BEGIN_NAMESPACE
74 
75 /*****************************************************************************
76   Date/Time Constants
77  *****************************************************************************/
78 
79 enum : qint64 {
80     SECS_PER_DAY = 86400,
81     MSECS_PER_DAY = 86400000,
82     SECS_PER_HOUR = 3600,
83     MSECS_PER_HOUR = 3600000,
84     SECS_PER_MIN = 60,
85     MSECS_PER_MIN = 60000,
86     MSECS_PER_SEC = 1000,
87     TIME_T_MAX = 2145916799,  // int maximum 2037-12-31T23:59:59 UTC
88     JULIAN_DAY_FOR_EPOCH = 2440588 // result of julianDayFromDate(1970, 1, 1)
89 };
90 
91 /*****************************************************************************
92   QDate static helper functions
93  *****************************************************************************/
94 
95 static inline QDate fixedDate(QCalendar::YearMonthDay &&parts, QCalendar cal)
96 {
97     if ((parts.year < 0 && !cal.isProleptic()) || (parts.year == 0 && !cal.hasYearZero()))
98         return QDate();
99 
100     parts.day = qMin(parts.day, cal.daysInMonth(parts.month, parts.year));
101     return cal.dateFromParts(parts);
102 }
103 
104 static inline QDate fixedDate(QCalendar::YearMonthDay &&parts)
105 {
106     if (parts.year) {
107         parts.day = qMin(parts.day, QGregorianCalendar::monthLength(parts.month, parts.year));
108         qint64 jd;
109         if (QGregorianCalendar::julianFromParts(parts.year, parts.month, parts.day, &jd))
110             return QDate::fromJulianDay(jd);
111     }
112     return QDate();
113 }
114 
115 /*****************************************************************************
116   Date/Time formatting helper functions
117  *****************************************************************************/
118 
119 #if QT_CONFIG(textdate)
120 static const char qt_shortMonthNames[][4] = {
121     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
122     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
123 };
124 
125 static int fromShortMonthName(QStringView monthName)
126 {
127     for (unsigned int i = 0; i < sizeof(qt_shortMonthNames) / sizeof(qt_shortMonthNames[0]); ++i) {
128         if (monthName == QLatin1String(qt_shortMonthNames[i], 3))
129             return i + 1;
130     }
131     return -1;
132 }
133 #endif // textdate
134 
135 #if QT_CONFIG(datestring) // depends on, so implies, textdate
136 struct ParsedRfcDateTime {
137     QDate date;
138     QTime time;
139     int utcOffset;
140 };
141 
142 static int shortDayFromName(QStringView name)
143 {
144     const char16_t shortDayNames[] = u"MonTueWedThuFriSatSun";
145     for (int i = 0; i < 7; i++) {
146         if (name == QStringView(shortDayNames + 3 * i, 3))
147             return i + 1;
148     }
149     return 0;
150 }
151 
152 static ParsedRfcDateTime rfcDateImpl(QStringView s)
153 {
154     // Matches "[ddd,] dd MMM yyyy[ hh:mm[:ss]] [±hhmm]" - correct RFC 822, 2822, 5322 format -
155     // or           "ddd MMM dd[ hh:mm:ss] yyyy [±hhmm]" - permissive RFC 850, 1036 (read only)
156     ParsedRfcDateTime result;
157 
158     auto words = QStringView{s}.split(u' ', Qt::SkipEmptyParts);
159     if (words.size() < 3 || words.size() > 6)
160         return result;
161     const QChar colon(u':');
162     bool ok = true;
163     QDate date;
164 
165     const auto isShortName = [](QStringView name) {
166         return (name.length() == 3 && name[0].isUpper()
167                 && name[1].isLower() && name[2].isLower());
168     };
169 
170     /* Reject entirely (return) if the string is malformed; however, if the date
171      * is merely invalid, (break, so as to) go on to parsing of the time.
172      */
173     int yearIndex;
174     do { // "loop" so that we can use break on merely invalid, but "right shape" date.
175         QStringView dayName;
176         bool rfcX22 = true;
177         if (words.at(0).endsWith(u',')) {
178             dayName = words.takeFirst().chopped(1);
179         } else if (!words.at(0)[0].isDigit()) {
180             dayName = words.takeFirst();
181             rfcX22 = false;
182         } // else: dayName is not specified (so we can only be RFC *22)
183         if (words.size() < 3 || words.size() > 5)
184             return result;
185 
186         // Don't break before setting yearIndex.
187         int dayIndex, monthIndex;
188         if (rfcX22) {
189             // dd MMM yyyy [hh:mm[:ss]] [±hhmm]
190             dayIndex = 0;
191             monthIndex = 1;
192             yearIndex = 2;
193         } else {
194             // MMM dd[ hh:mm:ss] yyyy [±hhmm]
195             dayIndex = 1;
196             monthIndex = 0;
197             yearIndex = words.size() > 3 && words.at(2).contains(colon) ? 3 : 2;
198         }
199 
200         int dayOfWeek = 0;
201         if (!dayName.isEmpty()) {
202             if (!isShortName(dayName))
203                 return result;
204             dayOfWeek = shortDayFromName(dayName);
205             if (!dayOfWeek)
206                 break;
207         }
208 
209         const int day = words.at(dayIndex).toInt(&ok);
210         if (!ok)
211             return result;
212         const int year = words.at(yearIndex).toInt(&ok);
213         if (!ok)
214             return result;
215         const QStringView monthName = words.at(monthIndex);
216         if (!isShortName(monthName))
217             return result;
218         int month = fromShortMonthName(monthName);
219         if (month < 0)
220             break;
221 
222         date = QDate(year, month, day);
223         if (dayOfWeek && date.dayOfWeek() != dayOfWeek)
224             date = QDate();
225     } while (false);
226     words.remove(yearIndex);
227     words.remove(0, 2); // month and day-of-month, in some order
228 
229     // Time: [hh:mm[:ss]]
230     QTime time;
231     if (words.size() && words.at(0).contains(colon)) {
232         const QStringView when = words.takeFirst();
233         if (when.size() < 5 || when[2] != colon
234             || (when.size() == 8 ? when[5] != colon : when.size() > 5)) {
235             return result;
236         }
237         const int hour = when.first(2).toInt(&ok);
238         if (!ok)
239             return result;
240         const int minute = when.sliced(3, 2).toInt(&ok);
241         if (!ok)
242             return result;
243         const auto secs = when.size() == 8 ? when.last(2).toInt(&ok) : 0;
244         if (!ok)
245             return result;
246         time = QTime(hour, minute, secs);
247     }
248 
249     // Offset: [±hh[mm]]
250     int offset = 0;
251     if (words.size()) {
252         const QStringView zone = words.takeFirst();
253         if (words.size() || !(zone.size() == 3 || zone.size() == 5))
254             return result;
255         bool negate = false;
256         if (zone[0] == u'-')
257             negate = true;
258         else if (zone[0] != u'+')
259             return result;
260         const int hour = zone.sliced(1, 2).toInt(&ok);
261         if (!ok)
262             return result;
263         const auto minute = zone.size() == 5 ? zone.last(2).toInt(&ok) : 0;
264         if (!ok)
265             return result;
266         offset = (hour * 60 + minute) * 60;
267         if (negate)
268             offset = -offset;
269     }
270 
271     result.date = date;
272     result.time = time;
273     result.utcOffset = offset;
274     return result;
275 }
276 #endif // datestring
277 
278 // Return offset in [+-]HH:mm format
279 static QString toOffsetString(Qt::DateFormat format, int offset)
280 {
281     return QString::asprintf("%c%02d%s%02d",
282                              offset >= 0 ? '+' : '-',
283                              qAbs(offset) / int(SECS_PER_HOUR),
284                              // Qt::ISODate puts : between the hours and minutes, but Qt:TextDate does not:
285                              format == Qt::TextDate ? "" : ":",
286                              (qAbs(offset) / 60) % 60);
287 }
288 
289 #if QT_CONFIG(datestring)
290 // Parse offset in [+-]HH[[:]mm] format
291 static int fromOffsetString(QStringView offsetString, bool *valid) noexcept
292 {
293     *valid = false;
294 
295     const int size = offsetString.size();
296     if (size < 2 || size > 6)
297         return 0;
298 
299     // sign will be +1 for a positive and -1 for a negative offset
300     int sign;
301 
302     // First char must be + or -
303     const QChar signChar = offsetString[0];
304     if (signChar == u'+')
305         sign = 1;
306     else if (signChar == u'-')
307         sign = -1;
308     else
309         return 0;
310 
311     // Split the hour and minute parts
312     const QStringView time = offsetString.sliced(1);
313     qsizetype hhLen = time.indexOf(u':');
314     qsizetype mmIndex;
315     if (hhLen == -1)
316         mmIndex = hhLen = 2; // [+-]HHmm or [+-]HH format
317     else
318         mmIndex = hhLen + 1;
319 
320     const QStringView hhRef = time.first(qMin(hhLen, time.size()));
321     bool ok = false;
322     const int hour = hhRef.toInt(&ok);
323     if (!ok || hour > 23) // More generous than QTimeZone::MaxUtcOffsetSecs
324         return 0;
325 
326     const QStringView mmRef = time.sliced(qMin(mmIndex, time.size()));
327     const int minute = mmRef.isEmpty() ? 0 : mmRef.toInt(&ok);
328     if (!ok || minute < 0 || minute > 59)
329         return 0;
330 
331     *valid = true;
332     return sign * ((hour * 60) + minute) * 60;
333 }
334 #endif // datestring
335 
336 /*****************************************************************************
337   QDate member functions
338  *****************************************************************************/
339 
340 /*!
341     \class QDate
342     \inmodule QtCore
343     \reentrant
344     \brief The QDate class provides date functions.
345 
346     A QDate object represents a particular day, regardless of calendar, locale
347     or other settings used when creating it or supplied by the system.  It can
348     report the year, month and day of the month that represent the day with
349     respect to the proleptic Gregorian calendar or any calendar supplied as a
350     QCalendar object. QDate objects should be passed by value rather than by
351     reference to const; they simply package \c qint64.
352 
353     A QDate object is typically created by giving the year, month, and day
354     numbers explicitly. Note that QDate interprets year numbers less than 100 as
355     presented, i.e., as years 1 through 99, without adding any offset. The
356     static function currentDate() creates a QDate object containing the date
357     read from the system clock. An explicit date can also be set using
358     setDate(). The fromString() function returns a QDate given a string and a
359     date format which is used to interpret the date within the string.
360 
361     The year(), month(), and day() functions provide access to the year, month,
362     and day numbers. When more than one of these values is needed, it is more
363     efficient to call QCalendar::partsFromDate(), to save repeating (potentially
364     expensive) calendrical calculations.
365 
366     Also, dayOfWeek() and dayOfYear() functions are provided. The same
367     information is provided in textual format by toString(). QLocale can map the
368     day numbers to names, QCalendar can map month numbers to names.
369 
370     QDate provides a full set of operators to compare two QDate
371     objects where smaller means earlier, and larger means later.
372 
373     You can increment (or decrement) a date by a given number of days
374     using addDays(). Similarly you can use addMonths() and addYears().
375     The daysTo() function returns the number of days between two
376     dates.
377 
378     The daysInMonth() and daysInYear() functions return how many days there are
379     in this date's month and year, respectively. The isLeapYear() function
380     indicates whether a date is in a leap year. QCalendar can also supply this
381     information, in some cases more conveniently.
382 
383     \section1 Remarks
384 
385     \note All conversion to and from string formats is done using the C locale.
386     For localized conversions, see QLocale.
387 
388     In the Gregorian calendar, there is no year 0. Dates in that year are
389     considered invalid. The year -1 is the year "1 before Christ" or "1 before
390     common era." The day before 1 January 1 CE, QDate(1, 1, 1), is 31 December
391     1 BCE, QDate(-1, 12, 31). Various other calendars behave similarly; see
392     QCalendar::hasYearZero().
393 
394     \section2 Range of Valid Dates
395 
396     Dates are stored internally as a Julian Day number, an integer count of
397     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian
398     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).
399     As well as being an efficient and accurate way of storing an absolute date,
400     it is suitable for converting a date into other calendar systems such as
401     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using
402     QDate::toJulianDay() and can be set using QDate::fromJulianDay().
403 
404     The range of Julian Day numbers that QDate can represent is, for technical
405     reasons, limited to between -784350574879 and 784354017364, which means from
406     before 2 billion BCE to after 2 billion CE. This is more than seven times as
407     wide as the range of dates a QDateTime can represent.
408 
409     \sa QTime, QDateTime, QCalendar, QDateTime::YearRange, QDateEdit, QDateTimeEdit, QCalendarWidget
410 */
411 
412 /*!
413     \fn QDate::QDate()
414 
415     Constructs a null date. Null dates are invalid.
416 
417     \sa isNull(), isValid()
418 */
419 
420 /*!
421     Constructs a date with year \a y, month \a m and day \a d.
422 
423     The date is understood in terms of the Gregorian calendar. If the specified
424     date is invalid, the date is not set and isValid() returns \c false.
425 
426     \warning Years 1 to 99 are interpreted as is. Year 0 is invalid.
427 
428     \sa isValid(), QCalendar::dateFromParts()
429 */
430 
431 QDate::QDate(int y, int m, int d)
432 {
433     if (!QGregorianCalendar::julianFromParts(y, m, d, &jd))
434         jd = nullJd();
435 }
436 
437 QDate::QDate(int y, int m, int d, QCalendar cal)
438 {
439     *this = cal.dateFromParts(y, m, d);
440 }
441 
442 /*!
443     \fn bool QDate::isNull() const
444 
445     Returns \c true if the date is null; otherwise returns \c false. A null
446     date is invalid.
447 
448     \note The behavior of this function is equivalent to isValid().
449 
450     \sa isValid()
451 */
452 
453 /*!
454     \fn bool QDate::isValid() const
455 
456     Returns \c true if this date is valid; otherwise returns \c false.
457 
458     \sa isNull(), QCalendar::isDateValid()
459 */
460 
461 /*!
462     Returns the year of this date.
463 
464     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
465 
466     Returns 0 if the date is invalid. For some calendars, dates before their
467     first year may all be invalid.
468 
469     If using a calendar which has a year 0, check using isValid() if the return
470     is 0. Such calendars use negative year numbers in the obvious way, with
471     year 1 preceded by year 0, in turn preceded by year -1 and so on.
472 
473     Some calendars, despite having no year 0, have a conventional numbering of
474     the years before their first year, counting backwards from 1. For example,
475     in the proleptic Gregorian calendar, successive years before 1 CE (the first
476     year) are identified as 1 BCE, 2 BCE, 3 BCE and so on. For such calendars,
477     negative year numbers are used to indicate these years before year 1, with
478     -1 indicating the year before 1.
479 
480     \sa month(), day(), QCalendar::hasYearZero(), QCalendar::isProleptic(), QCalendar::partsFromDate()
481 */
482 
483 int QDate::year(QCalendar cal) const
484 {
485     if (isValid()) {
486         const auto parts = cal.partsFromDate(*this);
487         if (parts.isValid())
488             return parts.year;
489     }
490     return 0;
491 }
492 
493 /*!
494   \overload
495  */
496 
497 int QDate::year() const
498 {
499     if (isValid()) {
500         const auto parts = QGregorianCalendar::partsFromJulian(jd);
501         if (parts.isValid())
502             return parts.year;
503     }
504     return 0;
505 }
506 
507 /*!
508     Returns the month-number for the date.
509 
510     Numbers the months of the year starting with 1 for the first. Uses \a cal
511     as calendar if supplied, else the Gregorian calendar, for which the month
512     numbering is as follows:
513 
514     \list
515     \li 1 = "January"
516     \li 2 = "February"
517     \li 3 = "March"
518     \li 4 = "April"
519     \li 5 = "May"
520     \li 6 = "June"
521     \li 7 = "July"
522     \li 8 = "August"
523     \li 9 = "September"
524     \li 10 = "October"
525     \li 11 = "November"
526     \li 12 = "December"
527     \endlist
528 
529     Returns 0 if the date is invalid. Note that some calendars may have more
530     than 12 months in some years.
531 
532     \sa year(), day(), QCalendar::partsFromDate()
533 */
534 
535 int QDate::month(QCalendar cal) const
536 {
537     if (isValid()) {
538         const auto parts = cal.partsFromDate(*this);
539         if (parts.isValid())
540             return parts.month;
541     }
542     return 0;
543 }
544 
545 /*!
546   \overload
547  */
548 
549 int QDate::month() const
550 {
551     if (isValid()) {
552         const auto parts = QGregorianCalendar::partsFromJulian(jd);
553         if (parts.isValid())
554             return parts.month;
555     }
556     return 0;
557 }
558 
559 /*!
560     Returns the day of the month for this date.
561 
562     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
563     the return ranges from 1 to 31). Returns 0 if the date is invalid.
564 
565     \sa year(), month(), dayOfWeek(), QCalendar::partsFromDate()
566 */
567 
568 int QDate::day(QCalendar cal) const
569 {
570     if (isValid()) {
571         const auto parts = cal.partsFromDate(*this);
572         if (parts.isValid())
573             return parts.day;
574     }
575     return 0;
576 }
577 
578 /*!
579   \overload
580  */
581 
582 int QDate::day() const
583 {
584     if (isValid()) {
585         const auto parts = QGregorianCalendar::partsFromJulian(jd);
586         if (parts.isValid())
587             return parts.day;
588     }
589     return 0;
590 }
591 
592 /*!
593     Returns the weekday (1 = Monday to 7 = Sunday) for this date.
594 
595     Uses \a cal as calendar if supplied, else the Gregorian calendar. Returns 0
596     if the date is invalid. Some calendars may give special meaning
597     (e.g. intercallary days) to values greater than 7.
598 
599     \sa day(), dayOfYear(), QCalendar::dayOfWeek(), Qt::DayOfWeek
600 */
601 
602 int QDate::dayOfWeek(QCalendar cal) const
603 {
604     if (isNull())
605         return 0;
606 
607     return cal.dayOfWeek(*this);
608 }
609 
610 /*!
611   \overload
612  */
613 
614 int QDate::dayOfWeek() const
615 {
616     return isValid() ? QGregorianCalendar::weekDayOfJulian(jd) : 0;
617 }
618 
619 /*!
620     Returns the day of the year (1 for the first day) for this date.
621 
622     Uses \a cal as calendar if supplied, else the Gregorian calendar.
623     Returns 0 if either the date or the first day of its year is invalid.
624 
625     \sa day(), dayOfWeek(), QCalendar::daysInYear()
626 */
627 
628 int QDate::dayOfYear(QCalendar cal) const
629 {
630     if (isValid()) {
631         QDate firstDay = cal.dateFromParts(year(cal), 1, 1);
632         if (firstDay.isValid())
633             return firstDay.daysTo(*this) + 1;
634     }
635     return 0;
636 }
637 
638 /*!
639   \overload
640  */
641 
642 int QDate::dayOfYear() const
643 {
644     if (isValid()) {
645         qint64 first;
646         if (QGregorianCalendar::julianFromParts(year(), 1, 1, &first))
647             return jd - first + 1;
648     }
649     return 0;
650 }
651 
652 /*!
653     Returns the number of days in the month for this date.
654 
655     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
656     the result ranges from 28 to 31). Returns 0 if the date is invalid.
657 
658     \sa day(), daysInYear(), QCalendar::daysInMonth(),
659         QCalendar::maximumDaysInMonth(), QCalendar::minimumDaysInMonth()
660 */
661 
662 int QDate::daysInMonth(QCalendar cal) const
663 {
664     if (isValid()) {
665         const auto parts = cal.partsFromDate(*this);
666         if (parts.isValid())
667             return cal.daysInMonth(parts.month, parts.year);
668     }
669     return 0;
670 }
671 
672 /*!
673   \overload
674  */
675 
676 int QDate::daysInMonth() const
677 {
678     if (isValid()) {
679         const auto parts = QGregorianCalendar::partsFromJulian(jd);
680         if (parts.isValid())
681             return QGregorianCalendar::monthLength(parts.month, parts.year);
682     }
683     return 0;
684 }
685 
686 /*!
687     Returns the number of days in the year for this date.
688 
689     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
690     the result is 365 or 366). Returns 0 if the date is invalid.
691 
692     \sa day(), daysInMonth(), QCalendar::daysInYear(), QCalendar::maximumMonthsInYear()
693 */
694 
695 int QDate::daysInYear(QCalendar cal) const
696 {
697     if (isNull())
698         return 0;
699 
700     return cal.daysInYear(year(cal));
701 }
702 
703 /*!
704   \overload
705  */
706 
707 int QDate::daysInYear() const
708 {
709     return isValid() ? QGregorianCalendar::leapTest(year()) ? 366 : 365 : 0;
710 }
711 
712 /*!
713     Returns the ISO 8601 week number (1 to 53).
714 
715     Returns 0 if the date is invalid. Otherwise, returns the week number for the
716     date. If \a yearNumber is not \nullptr (its default), stores the year as
717     *\a{yearNumber}.
718 
719     In accordance with ISO 8601, each week falls in the year to which most of
720     its days belong, in the Gregorian calendar. As ISO 8601's week starts on
721     Monday, this is the year in which the week's Thursday falls. Most years have
722     52 weeks, but some have 53.
723 
724     \note *\a{yearNumber} is not always the same as year(). For example, 1
725     January 2000 has week number 52 in the year 1999, and 31 December
726     2002 has week number 1 in the year 2003.
727 
728     \sa isValid()
729 */
730 
731 int QDate::weekNumber(int *yearNumber) const
732 {
733     if (!isValid())
734         return 0;
735 
736     // This could be replaced by use of QIso8601Calendar, once we implement it.
737     // The Thursday of the same week determines our answer:
738     QDate thursday(addDays(4 - dayOfWeek()));
739     int year = thursday.year();
740     // Week n's Thurs's DOY has 1 <= DOY - 7*(n-1) < 8, so 0 <= DOY + 6 - 7*n < 7:
741     int week = (thursday.dayOfYear() + 6) / 7;
742 
743     if (yearNumber)
744         *yearNumber = year;
745     return week;
746 }
747 
748 static bool inDateTimeRange(qint64 jd, bool start)
749 {
750     using Bounds = std::numeric_limits<qint64>;
751     if (jd < Bounds::min() + JULIAN_DAY_FOR_EPOCH)
752         return false;
753     jd -= JULIAN_DAY_FOR_EPOCH;
754     const qint64 maxDay = Bounds::max() / MSECS_PER_DAY;
755     const qint64 minDay = Bounds::min() / MSECS_PER_DAY - 1;
756     // (Divisions rounded towards zero, as MSECS_PER_DAY has factors other than two.)
757     // Range includes start of last day and end of first:
758     if (start)
759         return jd > minDay && jd <= maxDay;
760     return jd >= minDay && jd < maxDay;
761 }
762 
763 static QDateTime toEarliest(QDate day, const QDateTime &form)
764 {
765     const Qt::TimeSpec spec = form.timeSpec();
766     const int offset = (spec == Qt::OffsetFromUTC) ? form.offsetFromUtc() : 0;
767 #if QT_CONFIG(timezone)
768     QTimeZone zone;
769     if (spec == Qt::TimeZone)
770         zone = form.timeZone();
771 #endif
772     auto moment = [=](QTime time) {
773         switch (spec) {
774         case Qt::OffsetFromUTC: return QDateTime(day, time, spec, offset);
775 #if QT_CONFIG(timezone)
776         case Qt::TimeZone: return QDateTime(day, time, zone);
777 #endif
778         default: return QDateTime(day, time, spec);
779         }
780     };
781     // Longest routine time-zone transition is 2 hours:
782     QDateTime when = moment(QTime(2, 0));
783     if (!when.isValid()) {
784         // Noon should be safe ...
785         when = moment(QTime(12, 0));
786         if (!when.isValid()) {
787             // ... unless it's a 24-hour jump (moving the date-line)
788             when = moment(QTime(23, 59, 59, 999));
789             if (!when.isValid())
790                 return QDateTime();
791         }
792     }
793     int high = when.time().msecsSinceStartOfDay() / 60000;
794     int low = 0;
795     // Binary chop to the right minute
796     while (high > low + 1) {
797         int mid = (high + low) / 2;
798         QDateTime probe = moment(QTime(mid / 60, mid % 60));
799         if (probe.isValid() && probe.date() == day) {
800             high = mid;
801             when = probe;
802         } else {
803             low = mid;
804         }
805     }
806     return when;
807 }
808 
809 /*!
810     \since 5.14
811     \fn QDateTime QDate::startOfDay(Qt::TimeSpec spec, int offsetSeconds) const
812     \fn QDateTime QDate::startOfDay(const QTimeZone &zone) const
813 
814     Returns the start-moment of the day.  Usually, this shall be midnight at the
815     start of the day: however, if a time-zone transition causes the given date
816     to skip over that midnight (e.g. a DST spring-forward skipping from the end
817     of the previous day to 01:00 of the new day), the actual earliest time in
818     the day is returned.  This can only arise when the start-moment is specified
819     in terms of a time-zone (by passing its QTimeZone as \a zone) or in terms of
820     local time (by passing Qt::LocalTime as \a spec; this is its default).
821 
822     The \a offsetSeconds is ignored unless \a spec is Qt::OffsetFromUTC, when it
823     gives the implied zone's offset from UTC.  As UTC and such zones have no
824     transitions, the start of the day is QTime(0, 0) in these cases.
825 
826     In the rare case of a date that was entirely skipped (this happens when a
827     zone east of the international date-line switches to being west of it), the
828     return shall be invalid.  Passing Qt::TimeZone as \a spec (instead of
829     passing a QTimeZone) or passing an invalid time-zone as \a zone will also
830     produce an invalid result, as shall dates that start outside the range
831     representable by QDateTime.
832 
833     \sa endOfDay()
834 */
835 QDateTime QDate::startOfDay(Qt::TimeSpec spec, int offsetSeconds) const
836 {
837     if (!inDateTimeRange(jd, true))
838         return QDateTime();
839 
840     switch (spec) {
841     case Qt::TimeZone: // should pass a QTimeZone instead of Qt::TimeZone
842         qWarning() << "Called QDate::startOfDay(Qt::TimeZone) on" << *this;
843         return QDateTime();
844     case Qt::OffsetFromUTC:
845     case Qt::UTC:
846         return QDateTime(*this, QTime(0, 0), spec, offsetSeconds);
847 
848     case Qt::LocalTime:
849         if (offsetSeconds)
850             qWarning("Ignoring offset (%d seconds) passed with Qt::LocalTime", offsetSeconds);
851         break;
852     }
853     QDateTime when(*this, QTime(0, 0), spec);
854     if (!when.isValid())
855         when = toEarliest(*this, when);
856 
857     return when.isValid() ? when : QDateTime();
858 }
859 
860 #if QT_CONFIG(timezone)
861 /*!
862   \overload
863   \since 5.14
864 */
865 QDateTime QDate::startOfDay(const QTimeZone &zone) const
866 {
867     if (!inDateTimeRange(jd, true) || !zone.isValid())
868         return QDateTime();
869 
870     QDateTime when(*this, QTime(0, 0), zone);
871     if (when.isValid())
872         return when;
873 
874     // The start of the day must have fallen in a spring-forward's gap; find the spring-forward:
875     if (zone.hasTransitions()) {
876         QTimeZone::OffsetData tran
877             // There's unlikely to be another transition before noon tomorrow.
878             // However, the whole of today may have been skipped !
879             = zone.previousTransition(QDateTime(addDays(1), QTime(12, 0), zone));
880         const QDateTime &at = tran.atUtc.toTimeZone(zone);
881         if (at.isValid() && at.date() == *this)
882             return at;
883     }
884 
885     when = toEarliest(*this, when);
886     return when.isValid() ? when : QDateTime();
887 }
888 #endif // timezone
889 
890 static QDateTime toLatest(QDate day, const QDateTime &form)
891 {
892     const Qt::TimeSpec spec = form.timeSpec();
893     const int offset = (spec == Qt::OffsetFromUTC) ? form.offsetFromUtc() : 0;
894 #if QT_CONFIG(timezone)
895     QTimeZone zone;
896     if (spec == Qt::TimeZone)
897         zone = form.timeZone();
898 #endif
899     auto moment = [=](QTime time) {
900         switch (spec) {
901         case Qt::OffsetFromUTC: return QDateTime(day, time, spec, offset);
902 #if QT_CONFIG(timezone)
903         case Qt::TimeZone: return QDateTime(day, time, zone);
904 #endif
905         default: return QDateTime(day, time, spec);
906         }
907     };
908     // Longest routine time-zone transition is 2 hours:
909     QDateTime when = moment(QTime(21, 59, 59, 999));
910     if (!when.isValid()) {
911         // Noon should be safe ...
912         when = moment(QTime(12, 0));
913         if (!when.isValid()) {
914             // ... unless it's a 24-hour jump (moving the date-line)
915             when = moment(QTime(0, 0));
916             if (!when.isValid())
917                 return QDateTime();
918         }
919     }
920     int high = 24 * 60;
921     int low = when.time().msecsSinceStartOfDay() / 60000;
922     // Binary chop to the right minute
923     while (high > low + 1) {
924         int mid = (high + low) / 2;
925         QDateTime probe = moment(QTime(mid / 60, mid % 60, 59, 999));
926         if (probe.isValid() && probe.date() == day) {
927             low = mid;
928             when = probe;
929         } else {
930             high = mid;
931         }
932     }
933     return when;
934 }
935 
936 /*!
937     \since 5.14
938     \fn QDateTime QDate::endOfDay(Qt::TimeSpec spec, int offsetSeconds) const
939     \fn QDateTime QDate::endOfDay(const QTimeZone &zone) const
940 
941     Returns the end-moment of the day.  Usually, this is one millisecond before
942     the midnight at the end of the day: however, if a time-zone transition
943     causes the given date to skip over that midnight (e.g. a DST spring-forward
944     skipping from just before 23:00 to the start of the next day), the actual
945     latest time in the day is returned.  This can only arise when the
946     start-moment is specified in terms of a time-zone (by passing its QTimeZone
947     as \a zone) or in terms of local time (by passing Qt::LocalTime as \a spec;
948     this is its default).
949 
950     The \a offsetSeconds is ignored unless \a spec is Qt::OffsetFromUTC, when it
951     gives the implied zone's offset from UTC.  As UTC and such zones have no
952     transitions, the end of the day is QTime(23, 59, 59, 999) in these cases.
953 
954     In the rare case of a date that was entirely skipped (this happens when a
955     zone east of the international date-line switches to being west of it), the
956     return shall be invalid.  Passing Qt::TimeZone as \a spec (instead of
957     passing a QTimeZone) will also produce an invalid result, as shall dates
958     that end outside the range representable by QDateTime.
959 
960     \sa startOfDay()
961 */
962 QDateTime QDate::endOfDay(Qt::TimeSpec spec, int offsetSeconds) const
963 {
964     if (!inDateTimeRange(jd, false))
965         return QDateTime();
966 
967     switch (spec) {
968     case Qt::TimeZone: // should pass a QTimeZone instead of Qt::TimeZone
969         qWarning() << "Called QDate::endOfDay(Qt::TimeZone) on" << *this;
970         return QDateTime();
971     case Qt::UTC:
972     case Qt::OffsetFromUTC:
973         return QDateTime(*this, QTime(23, 59, 59, 999), spec, offsetSeconds);
974 
975     case Qt::LocalTime:
976         if (offsetSeconds)
977             qWarning("Ignoring offset (%d seconds) passed with Qt::LocalTime", offsetSeconds);
978         break;
979     }
980     QDateTime when(*this, QTime(23, 59, 59, 999), spec);
981     if (!when.isValid())
982         when = toLatest(*this, when);
983     return when.isValid() ? when : QDateTime();
984 }
985 
986 #if QT_CONFIG(timezone)
987 /*!
988   \overload
989   \since 5.14
990 */
991 QDateTime QDate::endOfDay(const QTimeZone &zone) const
992 {
993     if (!inDateTimeRange(jd, false) || !zone.isValid())
994         return QDateTime();
995 
996     QDateTime when(*this, QTime(23, 59, 59, 999), zone);
997     if (when.isValid())
998         return when;
999 
1000     // The end of the day must have fallen in a spring-forward's gap; find the spring-forward:
1001     if (zone.hasTransitions()) {
1002         QTimeZone::OffsetData tran
1003             // It's unlikely there's been another transition since yesterday noon.
1004             // However, the whole of today may have been skipped !
1005             = zone.nextTransition(QDateTime(addDays(-1), QTime(12, 0), zone));
1006         const QDateTime &at = tran.atUtc.toTimeZone(zone);
1007         if (at.isValid() && at.date() == *this)
1008             return at;
1009     }
1010 
1011     when = toLatest(*this, when);
1012     return when.isValid() ? when : QDateTime();
1013 }
1014 #endif // timezone
1015 
1016 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1017 
1018 static QString toStringTextDate(QDate date)
1019 {
1020     if (date.isValid()) {
1021         QCalendar cal; // Always Gregorian
1022         const auto parts = cal.partsFromDate(date);
1023         if (parts.isValid()) {
1024             const QLatin1Char sp(' ');
1025             return QLocale::c().dayName(cal.dayOfWeek(date), QLocale::ShortFormat) + sp
1026                 + cal.monthName(QLocale::c(), parts.month, parts.year, QLocale::ShortFormat)
1027                 // Documented to use 4-digit year
1028                 + sp + QString::asprintf("%d %04d", parts.day, parts.year);
1029         }
1030     }
1031     return QString();
1032 }
1033 
1034 static QString toStringIsoDate(QDate date)
1035 {
1036     const auto parts = QCalendar().partsFromDate(date);
1037     if (parts.isValid() && parts.year >= 0 && parts.year <= 9999)
1038         return QString::asprintf("%04d-%02d-%02d", parts.year, parts.month, parts.day);
1039     return QString();
1040 }
1041 
1042 /*!
1043     \overload
1044 
1045     Returns the date as a string. The \a format parameter determines the format
1046     of the string.
1047 
1048     If the \a format is Qt::TextDate, the string is formatted in the default
1049     way. The day and month names will be in English. An example of this
1050     formatting is "Sat May 20 1995". For localized formatting, see
1051     \l{QLocale::toString()}.
1052 
1053     If the \a format is Qt::ISODate, the string format corresponds
1054     to the ISO 8601 extended specification for representations of
1055     dates and times, taking the form yyyy-MM-dd, where yyyy is the
1056     year, MM is the month of the year (between 01 and 12), and dd is
1057     the day of the month between 01 and 31.
1058 
1059     If the \a format is Qt::RFC2822Date, the string is formatted in
1060     an \l{RFC 2822} compatible way. An example of this formatting is
1061     "20 May 1995".
1062 
1063     If the date is invalid, an empty string will be returned.
1064 
1065     \warning The Qt::ISODate format is only valid for years in the
1066     range 0 to 9999.
1067 
1068     \sa fromString(), QLocale::toString()
1069 */
1070 QString QDate::toString(Qt::DateFormat format) const
1071 {
1072     if (!isValid())
1073         return QString();
1074 
1075     switch (format) {
1076     case Qt::RFC2822Date:
1077         return QLocale::c().toString(*this, u"dd MMM yyyy");
1078     default:
1079     case Qt::TextDate:
1080         return toStringTextDate(*this);
1081     case Qt::ISODate:
1082     case Qt::ISODateWithMs:
1083         // No calendar dependence
1084         return toStringIsoDate(*this);
1085     }
1086 }
1087 
1088 /*!
1089     \fn QString QDate::toString(const QString &format, QCalendar cal) const
1090     \fn QString QDate::toString(QStringView format, QCalendar cal) const
1091 
1092     Returns the date as a string. The \a format parameter determines the format
1093     of the result string. If \a cal is supplied, it determines the calendar used
1094     to represent the date; it defaults to Gregorian.
1095 
1096     These expressions may be used:
1097 
1098     \table
1099     \header \li Expression \li Output
1100     \row \li d \li The day as a number without a leading zero (1 to 31)
1101     \row \li dd \li The day as a number with a leading zero (01 to 31)
1102     \row \li ddd \li The abbreviated day name ('Mon' to 'Sun').
1103     \row \li dddd \li The long day name ('Monday' to 'Sunday').
1104     \row \li M \li The month as a number without a leading zero (1 to 12)
1105     \row \li MM \li The month as a number with a leading zero (01 to 12)
1106     \row \li MMM \li The abbreviated month name ('Jan' to 'Dec').
1107     \row \li MMMM \li The long month name ('January' to 'December').
1108     \row \li yy \li The year as a two digit number (00 to 99)
1109     \row \li yyyy \li The year as a four digit number. If the year is negative,
1110             a minus sign is prepended, making five characters.
1111     \endtable
1112 
1113     Any sequence of characters enclosed in single quotes will be included
1114     verbatim in the output string (stripped of the quotes), even if it contains
1115     formatting characters. Two consecutive single quotes ("''") are replaced by
1116     a single quote in the output. All other characters in the format string are
1117     included verbatim in the output string.
1118 
1119     Formats without separators (e.g. "ddMM") are supported but must be used with
1120     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
1121     produces "212" it could mean either the 2nd of December or the 21st of
1122     February).
1123 
1124     Example format strings (assuming that the QDate is the 20 July
1125     1969):
1126 
1127     \table
1128     \header \li Format            \li Result
1129     \row    \li dd.MM.yyyy        \li 20.07.1969
1130     \row    \li ddd MMMM d yy     \li Sun July 20 69
1131     \row    \li 'The day is' dddd \li The day is Sunday
1132     \endtable
1133 
1134     If the datetime is invalid, an empty string will be returned.
1135 
1136     \note Day and month names are given in English (C locale).
1137     If localized month and day names are desired, use
1138     QLocale::system().toString().
1139 
1140     \sa fromString(), QDateTime::toString(), QTime::toString(), QLocale::toString()
1141 
1142 */
1143 QString QDate::toString(QStringView format, QCalendar cal) const
1144 {
1145     return QLocale::c().toString(*this, format, cal);
1146 }
1147 #endif // datestring
1148 
1149 /*!
1150     \since 4.2
1151 
1152     Sets this to represent the date, in the Gregorian calendar, with the given
1153     \a year, \a month and \a day numbers. Returns true if the resulting date is
1154     valid, otherwise it sets this to represent an invalid date and returns
1155     false.
1156 
1157     \sa isValid(), QCalendar::dateFromParts()
1158 */
1159 bool QDate::setDate(int year, int month, int day)
1160 {
1161     if (QGregorianCalendar::julianFromParts(year, month, day, &jd))
1162         return true;
1163 
1164     jd = nullJd();
1165     return false;
1166 }
1167 
1168 /*!
1169     \since 5.14
1170 
1171     Sets this to represent the date, in the given calendar \a cal, with the
1172     given \a year, \a month and \a day numbers. Returns true if the resulting
1173     date is valid, otherwise it sets this to represent an invalid date and
1174     returns false.
1175 
1176     \sa isValid(), QCalendar::dateFromParts()
1177 */
1178 
1179 bool QDate::setDate(int year, int month, int day, QCalendar cal)
1180 {
1181     *this = QDate(year, month, day, cal);
1182     return isValid();
1183 }
1184 
1185 /*!
1186     \since 4.5
1187 
1188     Extracts the date's year, month, and day, and assigns them to
1189     *\a year, *\a month, and *\a day. The pointers may be null.
1190 
1191     Returns 0 if the date is invalid.
1192 
1193     \note In Qt versions prior to 5.7, this function is marked as non-\c{const}.
1194 
1195     \sa year(), month(), day(), isValid(), QCalendar::partsFromDate()
1196 */
1197 void QDate::getDate(int *year, int *month, int *day) const
1198 {
1199     QCalendar::YearMonthDay parts; // invalid by default
1200     if (isValid())
1201         parts = QGregorianCalendar::partsFromJulian(jd);
1202 
1203     const bool ok = parts.isValid();
1204     if (year)
1205         *year = ok ? parts.year : 0;
1206     if (month)
1207         *month = ok ? parts.month : 0;
1208     if (day)
1209         *day = ok ? parts.day : 0;
1210 }
1211 
1212 /*!
1213     Returns a QDate object containing a date \a ndays later than the
1214     date of this object (or earlier if \a ndays is negative).
1215 
1216     Returns a null date if the current date is invalid or the new date is
1217     out of range.
1218 
1219     \sa addMonths(), addYears(), daysTo()
1220 */
1221 
1222 QDate QDate::addDays(qint64 ndays) const
1223 {
1224     if (isNull())
1225         return QDate();
1226 
1227     // Due to limits on minJd() and maxJd() we know that any overflow
1228     // will be invalid and caught by fromJulianDay().
1229     return fromJulianDay(jd + ndays);
1230 }
1231 
1232 /*!
1233     Returns a QDate object containing a date \a nmonths later than the
1234     date of this object (or earlier if \a nmonths is negative).
1235 
1236     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
1237 
1238     \note If the ending day/month combination does not exist in the resulting
1239     month/year, this function will return a date that is the latest valid date
1240     in the selected month.
1241 
1242     \sa addDays(), addYears()
1243 */
1244 
1245 QDate QDate::addMonths(int nmonths, QCalendar cal) const
1246 {
1247     if (!isValid())
1248         return QDate();
1249 
1250     if (nmonths == 0)
1251         return *this;
1252 
1253     auto parts = cal.partsFromDate(*this);
1254 
1255     if (!parts.isValid())
1256         return QDate();
1257     Q_ASSERT(parts.year || cal.hasYearZero());
1258 
1259     parts.month += nmonths;
1260     while (parts.month <= 0) {
1261         if (--parts.year || cal.hasYearZero())
1262             parts.month += cal.monthsInYear(parts.year);
1263     }
1264     int count = cal.monthsInYear(parts.year);
1265     while (parts.month > count) {
1266         parts.month -= count;
1267         count = (++parts.year || cal.hasYearZero()) ? cal.monthsInYear(parts.year) : 0;
1268     }
1269 
1270     return fixedDate(std::move(parts), cal);
1271 }
1272 
1273 /*!
1274   \overload
1275 */
1276 
1277 QDate QDate::addMonths(int nmonths) const
1278 {
1279     if (isNull())
1280         return QDate();
1281 
1282     if (nmonths == 0)
1283         return *this;
1284 
1285     auto parts = QGregorianCalendar::partsFromJulian(jd);
1286 
1287     if (!parts.isValid())
1288         return QDate();
1289     Q_ASSERT(parts.year);
1290 
1291     parts.month += nmonths;
1292     while (parts.month <= 0) {
1293         if (--parts.year) // skip over year 0
1294             parts.month += 12;
1295     }
1296     while (parts.month > 12) {
1297         parts.month -= 12;
1298         if (!++parts.year) // skip over year 0
1299             ++parts.year;
1300     }
1301 
1302     return fixedDate(std::move(parts));
1303 }
1304 
1305 /*!
1306     Returns a QDate object containing a date \a nyears later than the
1307     date of this object (or earlier if \a nyears is negative).
1308 
1309     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
1310 
1311     \note If the ending day/month combination does not exist in the resulting
1312     year (e.g., for the Gregorian calendar, if the date was Feb 29 and the final
1313     year is not a leap year), this function will return a date that is the
1314     latest valid date in the given month (in the example, Feb 28).
1315 
1316     \sa addDays(), addMonths()
1317 */
1318 
1319 QDate QDate::addYears(int nyears, QCalendar cal) const
1320 {
1321     if (!isValid())
1322         return QDate();
1323 
1324     auto parts = cal.partsFromDate(*this);
1325     if (!parts.isValid())
1326         return QDate();
1327 
1328     int old_y = parts.year;
1329     parts.year += nyears;
1330 
1331     // If we just crossed (or hit) a missing year zero, adjust year by +/- 1:
1332     if (!cal.hasYearZero() && ((old_y > 0) != (parts.year > 0) || !parts.year))
1333         parts.year += nyears > 0 ? +1 : -1;
1334 
1335     return fixedDate(std::move(parts), cal);
1336 }
1337 
1338 /*!
1339     \overload
1340 */
1341 
1342 QDate QDate::addYears(int nyears) const
1343 {
1344     if (isNull())
1345         return QDate();
1346 
1347     auto parts = QGregorianCalendar::partsFromJulian(jd);
1348     if (!parts.isValid())
1349         return QDate();
1350 
1351     int old_y = parts.year;
1352     parts.year += nyears;
1353 
1354     // If we just crossed (or hit) a missing year zero, adjust year by +/- 1:
1355     if ((old_y > 0) != (parts.year > 0) || !parts.year)
1356         parts.year += nyears > 0 ? +1 : -1;
1357 
1358     return fixedDate(std::move(parts));
1359 }
1360 
1361 /*!
1362     Returns the number of days from this date to \a d (which is
1363     negative if \a d is earlier than this date).
1364 
1365     Returns 0 if either date is invalid.
1366 
1367     Example:
1368     \snippet code/src_corelib_time_qdatetime.cpp 0
1369 
1370     \sa addDays()
1371 */
1372 
1373 qint64 QDate::daysTo(QDate d) const
1374 {
1375     if (isNull() || d.isNull())
1376         return 0;
1377 
1378     // Due to limits on minJd() and maxJd() we know this will never overflow
1379     return d.jd - jd;
1380 }
1381 
1382 
1383 /*!
1384     \fn bool QDate::operator==(QDate lhs, QDate rhs)
1385 
1386     Returns \c true if \a lhs and \a rhs represent the same day, otherwise
1387     \c false.
1388 */
1389 
1390 /*!
1391     \fn bool QDate::operator!=(QDate lhs, QDate rhs)
1392 
1393     Returns \c true if \a lhs and \a rhs represent distinct days; otherwise
1394     returns \c false.
1395 
1396     \sa operator==()
1397 */
1398 
1399 /*!
1400     \fn bool QDate::operator<(QDate lhs, QDate rhs)
1401 
1402     Returns \c true if \a lhs is earlier than \a rhs; otherwise returns \c false.
1403 */
1404 
1405 /*!
1406     \fn bool QDate::operator<=(QDate lhs, QDate rhs)
1407 
1408     Returns \c true if \a lhs is earlier than or equal to \a rhs;
1409     otherwise returns \c false.
1410 */
1411 
1412 /*!
1413     \fn bool QDate::operator>(QDate lhs, QDate rhs)
1414 
1415     Returns \c true if \a lhs is later than \a rhs; otherwise returns \c false.
1416 */
1417 
1418 /*!
1419     \fn bool QDate::operator>=(QDate lhs, QDate rhs)
1420 
1421     Returns \c true if \a lhs is later than or equal to \a rhs;
1422     otherwise returns \c false.
1423 */
1424 
1425 /*!
1426     \fn QDate::currentDate()
1427     Returns the current date, as reported by the system clock.
1428 
1429     \sa QTime::currentTime(), QDateTime::currentDateTime()
1430 */
1431 
1432 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1433 namespace {
1434 
1435 struct ParsedInt { qulonglong value = 0; bool ok = false; };
1436 
1437 /*
1438     /internal
1439 
1440     Read a whole number that must be the whole text.  QStringView::toULongLong()
1441     will happily ignore spaces and accept signs; but various date formats'
1442     fields (e.g. all in ISO) should not.
1443 */
1444 ParsedInt readInt(QStringView text)
1445 {
1446     ParsedInt result;
1447     for (QStringIterator it(text); it.hasNext();) {
1448         if (!QChar::isDigit(it.next()))
1449             return result;
1450     }
1451     result.value = text.toULongLong(&result.ok);
1452     return result;
1453 }
1454 
1455 }
1456 
1457 /*!
1458     \fn QDate QDate::fromString(const QString &string, Qt::DateFormat format)
1459 
1460     Returns the QDate represented by the \a string, using the
1461     \a format given, or an invalid date if the string cannot be
1462     parsed.
1463 
1464     Note for Qt::TextDate: only English month names (e.g. "Jan" in short form or
1465     "January" in long form) are recognized.
1466 
1467     \sa toString(), QLocale::toDate()
1468 */
1469 
1470 /*!
1471     \overload
1472     \since 6.0
1473 */
1474 QDate QDate::fromString(QStringView string, Qt::DateFormat format)
1475 {
1476     if (string.isEmpty())
1477         return QDate();
1478 
1479     switch (format) {
1480     case Qt::RFC2822Date:
1481         return rfcDateImpl(string).date;
1482     default:
1483     case Qt::TextDate: {
1484         // Documented as "ddd MMM d yyyy"
1485         auto parts = string.split(u' ', Qt::SkipEmptyParts);
1486 
1487         if (parts.count() != 4)
1488             return QDate();
1489 
1490         bool ok = false;
1491         int year = parts.at(3).toInt(&ok);
1492         int day = ok ? parts.at(2).toInt(&ok) : 0;
1493         if (!ok || !day)
1494             return QDate();
1495 
1496         const int month = fromShortMonthName(parts.at(1));
1497         if (month == -1) // Month name matches no English or localised name.
1498             return QDate();
1499 
1500         return QDate(year, month, day);
1501         }
1502     case Qt::ISODate:
1503         // Semi-strict parsing, must be long enough and have punctuators as separators
1504         if (string.size() >= 10 && string.at(4).isPunct() && string.at(7).isPunct()
1505                 && (string.size() == 10 || !string.at(10).isDigit())) {
1506             const ParsedInt year = readInt(string.first(4));
1507             const ParsedInt month = readInt(string.sliced(5, 2));
1508             const ParsedInt day = readInt(string.sliced(8, 2));
1509             if (year.ok && year.value > 0 && year.value <= 9999 && month.ok && day.ok)
1510                 return QDate(year.value, month.value, day.value);
1511         }
1512         break;
1513     }
1514     return QDate();
1515 }
1516 
1517 /*!
1518     \fn QDate QDate::fromString(const QString &string, const QString &format, QCalendar cal)
1519 
1520     Returns the QDate represented by the \a string, using the \a
1521     format given, or an invalid date if the string cannot be parsed.
1522 
1523     Uses \a cal as calendar if supplied, else the Gregorian calendar. Ranges of
1524     values in the format descriptions below are for the latter; they may be
1525     different for other calendars.
1526 
1527     These expressions may be used for the format:
1528 
1529     \table
1530     \header \li Expression \li Output
1531     \row \li d \li The day as a number without a leading zero (1 to 31)
1532     \row \li dd \li The day as a number with a leading zero (01 to 31)
1533     \row \li ddd \li The abbreviated day name ('Mon' to 'Sun').
1534     \row \li dddd \li The long day name ('Monday' to 'Sunday').
1535     \row \li M \li The month as a number without a leading zero (1 to 12)
1536     \row \li MM \li The month as a number with a leading zero (01 to 12)
1537     \row \li MMM \li The abbreviated month name ('Jan' to 'Dec').
1538     \row \li MMMM \li The long month name ('January' to 'December').
1539     \row \li yy \li The year as a two digit number (00 to 99)
1540     \row \li yyyy \li The year as a four digit number, possibly plus a leading
1541              minus sign for negative years.
1542     \endtable
1543 
1544     \note Day and month names must be given in English (C locale).
1545     If localized month and day names are used, use
1546     QLocale::system().toDate().
1547 
1548     All other input characters will be treated as text. Any non-empty sequence
1549     of characters enclosed in single quotes will also be treated (stripped of
1550     the quotes) as text and not be interpreted as expressions. For example:
1551 
1552     \snippet code/src_corelib_time_qdatetime.cpp 1
1553 
1554     If the format is not satisfied, an invalid QDate is returned. The
1555     expressions that don't expect leading zeroes (d, M) will be
1556     greedy. This means that they will use two digits even if this
1557     will put them outside the accepted range of values and leaves too
1558     few digits for other sections. For example, the following format
1559     string could have meant January 30 but the M will grab two
1560     digits, resulting in an invalid date:
1561 
1562     \snippet code/src_corelib_time_qdatetime.cpp 2
1563 
1564     For any field that is not represented in the format the following
1565     defaults are used:
1566 
1567     \table
1568     \header \li Field  \li Default value
1569     \row    \li Year   \li 1900
1570     \row    \li Month  \li 1 (January)
1571     \row    \li Day    \li 1
1572     \endtable
1573 
1574     The following examples demonstrate the default values:
1575 
1576     \snippet code/src_corelib_time_qdatetime.cpp 3
1577 
1578     \sa toString(), QDateTime::fromString(), QTime::fromString(),
1579         QLocale::toDate()
1580 */
1581 
1582 /*!
1583     \fn QDate QDate::fromString(QStringView string, QStringView format, QCalendar cal)
1584     \overload
1585     \since 6.0
1586 */
1587 
1588 /*!
1589     \overload
1590     \since 6.0
1591 */
1592 QDate QDate::fromString(const QString &string, QStringView format, QCalendar cal)
1593 {
1594     QDate date;
1595 #if QT_CONFIG(datetimeparser)
1596     QDateTimeParser dt(QMetaType::QDate, QDateTimeParser::FromString, cal);
1597     dt.setDefaultLocale(QLocale::c());
1598     if (dt.parseFormat(format))
1599         dt.fromString(string, &date, nullptr);
1600 #else
1601     Q_UNUSED(string);
1602     Q_UNUSED(format);
1603     Q_UNUSED(cal);
1604 #endif
1605     return date;
1606 }
1607 #endif // datestring
1608 
1609 /*!
1610     \overload
1611 
1612     Returns \c true if the specified date (\a year, \a month, and \a day) is
1613     valid in the Gregorian calendar; otherwise returns \c false.
1614 
1615     Example:
1616     \snippet code/src_corelib_time_qdatetime.cpp 4
1617 
1618     \sa isNull(), setDate(), QCalendar::isDateValid()
1619 */
1620 
1621 bool QDate::isValid(int year, int month, int day)
1622 {
1623     return QGregorianCalendar::validParts(year, month, day);
1624 }
1625 
1626 /*!
1627     \fn bool QDate::isLeapYear(int year)
1628 
1629     Returns \c true if the specified \a year is a leap year in the Gregorian
1630     calendar; otherwise returns \c false.
1631 
1632     \sa QCalendar::isLeapYear()
1633 */
1634 
1635 bool QDate::isLeapYear(int y)
1636 {
1637     return QGregorianCalendar::leapTest(y);
1638 }
1639 
1640 /*! \fn static QDate QDate::fromJulianDay(qint64 jd)
1641 
1642     Converts the Julian day \a jd to a QDate.
1643 
1644     \sa toJulianDay()
1645 */
1646 
1647 /*! \fn int QDate::toJulianDay() const
1648 
1649     Converts the date to a Julian day.
1650 
1651     \sa fromJulianDay()
1652 */
1653 
1654 /*****************************************************************************
1655   QTime member functions
1656  *****************************************************************************/
1657 
1658 /*!
1659     \class QTime
1660     \inmodule QtCore
1661     \reentrant
1662 
1663     \brief The QTime class provides clock time functions.
1664 
1665     A QTime object contains a clock time, which it can express as the numbers of
1666     hours, minutes, seconds, and milliseconds since midnight. It provides
1667     functions for comparing times and for manipulating a time by adding a number
1668     of milliseconds. QTime objects should be passed by value rather than by
1669     reference to const; they simply package \c int.
1670 
1671     QTime uses the 24-hour clock format; it has no concept of AM/PM.
1672     Unlike QDateTime, QTime knows nothing about time zones or
1673     daylight-saving time (DST).
1674 
1675     A QTime object is typically created either by giving the number of hours,
1676     minutes, seconds, and milliseconds explicitly, or by using the static
1677     function currentTime(), which creates a QTime object that represents the
1678     system's local time.
1679 
1680     The hour(), minute(), second(), and msec() functions provide
1681     access to the number of hours, minutes, seconds, and milliseconds
1682     of the time. The same information is provided in textual format by
1683     the toString() function.
1684 
1685     The addSecs() and addMSecs() functions provide the time a given
1686     number of seconds or milliseconds later than a given time.
1687     Correspondingly, the number of seconds or milliseconds
1688     between two times can be found using secsTo() or msecsTo().
1689 
1690     QTime provides a full set of operators to compare two QTime
1691     objects; an earlier time is considered smaller than a later one;
1692     if A.msecsTo(B) is positive, then A < B.
1693 
1694     QTime objects can also be created from a text representation using
1695     fromString() and converted to a string representation using toString(). All
1696     conversion to and from string formats is done using the C locale.  For
1697     localized conversions, see QLocale.
1698 
1699     \sa QDate, QDateTime
1700 */
1701 
1702 /*!
1703     \fn QTime::QTime()
1704 
1705     Constructs a null time object. For a null time, isNull() returns \c true and
1706     isValid() returns \c false. If you need a zero time, use QTime(0, 0).  For
1707     the start of a day, see QDate::startOfDay().
1708 
1709     \sa isNull(), isValid()
1710 */
1711 
1712 /*!
1713     Constructs a time with hour \a h, minute \a m, seconds \a s and
1714     milliseconds \a ms.
1715 
1716     \a h must be in the range 0 to 23, \a m and \a s must be in the
1717     range 0 to 59, and \a ms must be in the range 0 to 999.
1718 
1719     \sa isValid()
1720 */
1721 
1722 QTime::QTime(int h, int m, int s, int ms)
1723 {
1724     setHMS(h, m, s, ms);
1725 }
1726 
1727 
1728 /*!
1729     \fn bool QTime::isNull() const
1730 
1731     Returns \c true if the time is null (i.e., the QTime object was
1732     constructed using the default constructor); otherwise returns
1733     false. A null time is also an invalid time.
1734 
1735     \sa isValid()
1736 */
1737 
1738 /*!
1739     Returns \c true if the time is valid; otherwise returns \c false. For example,
1740     the time 23:30:55.746 is valid, but 24:12:30 is invalid.
1741 
1742     \sa isNull()
1743 */
1744 
1745 bool QTime::isValid() const
1746 {
1747     return mds > NullTime && mds < MSECS_PER_DAY;
1748 }
1749 
1750 
1751 /*!
1752     Returns the hour part (0 to 23) of the time.
1753 
1754     Returns -1 if the time is invalid.
1755 
1756     \sa minute(), second(), msec()
1757 */
1758 
1759 int QTime::hour() const
1760 {
1761     if (!isValid())
1762         return -1;
1763 
1764     return ds() / MSECS_PER_HOUR;
1765 }
1766 
1767 /*!
1768     Returns the minute part (0 to 59) of the time.
1769 
1770     Returns -1 if the time is invalid.
1771 
1772     \sa hour(), second(), msec()
1773 */
1774 
1775 int QTime::minute() const
1776 {
1777     if (!isValid())
1778         return -1;
1779 
1780     return (ds() % MSECS_PER_HOUR) / MSECS_PER_MIN;
1781 }
1782 
1783 /*!
1784     Returns the second part (0 to 59) of the time.
1785 
1786     Returns -1 if the time is invalid.
1787 
1788     \sa hour(), minute(), msec()
1789 */
1790 
1791 int QTime::second() const
1792 {
1793     if (!isValid())
1794         return -1;
1795 
1796     return (ds() / MSECS_PER_SEC) % SECS_PER_MIN;
1797 }
1798 
1799 /*!
1800     Returns the millisecond part (0 to 999) of the time.
1801 
1802     Returns -1 if the time is invalid.
1803 
1804     \sa hour(), minute(), second()
1805 */
1806 
1807 int QTime::msec() const
1808 {
1809     if (!isValid())
1810         return -1;
1811 
1812     return ds() % MSECS_PER_SEC;
1813 }
1814 
1815 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1816 /*!
1817     \overload
1818 
1819     Returns the time as a string. The \a format parameter determines
1820     the format of the string.
1821 
1822     If \a format is Qt::TextDate, the string format is HH:mm:ss;
1823     e.g. 1 second before midnight would be "23:59:59".
1824 
1825     If \a format is Qt::ISODate, the string format corresponds to the
1826     ISO 8601 extended specification for representations of dates,
1827     represented by HH:mm:ss. To include milliseconds in the ISO 8601
1828     date, use the \a format Qt::ISODateWithMs, which corresponds to
1829     HH:mm:ss.zzz.
1830 
1831     If the \a format is Qt::RFC2822Date, the string is formatted in
1832     an \l{RFC 2822} compatible way. An example of this formatting is
1833     "23:59:20".
1834 
1835     If the time is invalid, an empty string will be returned.
1836 
1837     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1838 */
1839 
1840 QString QTime::toString(Qt::DateFormat format) const
1841 {
1842     if (!isValid())
1843         return QString();
1844 
1845     switch (format) {
1846     case Qt::ISODateWithMs:
1847         return QString::asprintf("%02d:%02d:%02d.%03d", hour(), minute(), second(), msec());
1848     case Qt::RFC2822Date:
1849     case Qt::ISODate:
1850     case Qt::TextDate:
1851     default:
1852         return QString::asprintf("%02d:%02d:%02d", hour(), minute(), second());
1853     }
1854 }
1855 
1856 /*!
1857     \fn QString QTime::toString(const QString &format) const
1858     \fn QString QTime::toString(QStringView format) const
1859 
1860     Returns the time as a string. The \a format parameter determines
1861     the format of the result string.
1862 
1863     These expressions may be used:
1864 
1865     \table
1866     \header \li Expression \li Output
1867     \row \li h
1868          \li The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
1869     \row \li hh
1870          \li The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
1871     \row \li H
1872          \li The hour without a leading zero (0 to 23, even with AM/PM display)
1873     \row \li HH
1874          \li The hour with a leading zero (00 to 23, even with AM/PM display)
1875     \row \li m \li The minute without a leading zero (0 to 59)
1876     \row \li mm \li The minute with a leading zero (00 to 59)
1877     \row \li s \li The whole second, without any leading zero (0 to 59)
1878     \row \li ss \li The whole second, with a leading zero where applicable (00 to 59)
1879     \row \li z \li The fractional part of the second, to go after a decimal
1880                 point, without trailing zeroes (0 to 999).  Thus "\c{s.z}"
1881                 reports the seconds to full available (millisecond) precision
1882                 without trailing zeroes.
1883     \row \li zzz \li The fractional part of the second, to millisecond
1884                 precision, including trailing zeroes where applicable (000 to 999).
1885     \row \li AP or A
1886          \li Use AM/PM display. \e A/AP will be replaced by 'AM' or 'PM'
1887     \row \li ap or a
1888          \li Use am/pm display. \e a/ap will be replaced by 'am' or 'pm'
1889     \row \li t \li The timezone (for example "CEST")
1890     \endtable
1891 
1892     Any non-empty sequence of characters enclosed in single quotes will be
1893     included verbatim in the output string (stripped of the quotes), even if it
1894     contains formatting characters. Two consecutive single quotes ("''") are
1895     replaced by a single quote in the output. All other characters in the format
1896     string are included verbatim in the output string.
1897 
1898     Formats without separators (e.g. "ddMM") are supported but must be used with
1899     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
1900     produces "212" it could mean either the 2nd of December or the 21st of
1901     February).
1902 
1903     Example format strings (assuming that the QTime is 14:13:09.042 and the system
1904     locale is \c{en_US})
1905 
1906     \table
1907     \header \li Format \li Result
1908     \row \li hh:mm:ss.zzz \li 14:13:09.042
1909     \row \li h:m:s ap     \li 2:13:9 pm
1910     \row \li H:m:s a      \li 14:13:9 pm
1911     \endtable
1912 
1913     If the time is invalid, an empty string will be returned.
1914 
1915     \note If localized forms of am or pm (the AP, ap, A or a formats) are
1916     desired, please use QLocale::system().toString().
1917 
1918     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1919 */
1920 QString QTime::toString(QStringView format) const
1921 {
1922     return QLocale::c().toString(*this, format);
1923 }
1924 #endif // datestring
1925 
1926 /*!
1927     Sets the time to hour \a h, minute \a m, seconds \a s and
1928     milliseconds \a ms.
1929 
1930     \a h must be in the range 0 to 23, \a m and \a s must be in the
1931     range 0 to 59, and \a ms must be in the range 0 to 999.
1932     Returns \c true if the set time is valid; otherwise returns \c false.
1933 
1934     \sa isValid()
1935 */
1936 
1937 bool QTime::setHMS(int h, int m, int s, int ms)
1938 {
1939     if (!isValid(h,m,s,ms)) {
1940         mds = NullTime;                // make this invalid
1941         return false;
1942     }
1943     mds = (h * SECS_PER_HOUR + m * SECS_PER_MIN + s) * MSECS_PER_SEC + ms;
1944     return true;
1945 }
1946 
1947 /*!
1948     Returns a QTime object containing a time \a s seconds later
1949     than the time of this object (or earlier if \a s is negative).
1950 
1951     Note that the time will wrap if it passes midnight.
1952 
1953     Returns a null time if this time is invalid.
1954 
1955     Example:
1956 
1957     \snippet code/src_corelib_time_qdatetime.cpp 5
1958 
1959     \sa addMSecs(), secsTo(), QDateTime::addSecs()
1960 */
1961 
1962 QTime QTime::addSecs(int s) const
1963 {
1964     s %= SECS_PER_DAY;
1965     return addMSecs(s * MSECS_PER_SEC);
1966 }
1967 
1968 /*!
1969     Returns the number of seconds from this time to \a t.
1970     If \a t is earlier than this time, the number of seconds returned
1971     is negative.
1972 
1973     Because QTime measures time within a day and there are 86400
1974     seconds in a day, the result is always between -86400 and 86400.
1975 
1976     secsTo() does not take into account any milliseconds.
1977 
1978     Returns 0 if either time is invalid.
1979 
1980     \sa addSecs(), QDateTime::secsTo()
1981 */
1982 
1983 int QTime::secsTo(QTime t) const
1984 {
1985     if (!isValid() || !t.isValid())
1986         return 0;
1987 
1988     // Truncate milliseconds as we do not want to consider them.
1989     int ourSeconds = ds() / MSECS_PER_SEC;
1990     int theirSeconds = t.ds() / MSECS_PER_SEC;
1991     return theirSeconds - ourSeconds;
1992 }
1993 
1994 /*!
1995     Returns a QTime object containing a time \a ms milliseconds later
1996     than the time of this object (or earlier if \a ms is negative).
1997 
1998     Note that the time will wrap if it passes midnight. See addSecs()
1999     for an example.
2000 
2001     Returns a null time if this time is invalid.
2002 
2003     \sa addSecs(), msecsTo(), QDateTime::addMSecs()
2004 */
2005 
2006 QTime QTime::addMSecs(int ms) const
2007 {
2008     QTime t;
2009     if (isValid()) {
2010         if (ms < 0) {
2011             // %,/ not well-defined for -ve, so always work with +ve.
2012             int negdays = (MSECS_PER_DAY - ms) / MSECS_PER_DAY;
2013             t.mds = (ds() + ms + negdays * MSECS_PER_DAY) % MSECS_PER_DAY;
2014         } else {
2015             t.mds = (ds() + ms) % MSECS_PER_DAY;
2016         }
2017     }
2018     return t;
2019 }
2020 
2021 /*!
2022     Returns the number of milliseconds from this time to \a t.
2023     If \a t is earlier than this time, the number of milliseconds returned
2024     is negative.
2025 
2026     Because QTime measures time within a day and there are 86400
2027     seconds in a day, the result is always between -86400000 and
2028     86400000 ms.
2029 
2030     Returns 0 if either time is invalid.
2031 
2032     \sa secsTo(), addMSecs(), QDateTime::msecsTo()
2033 */
2034 
2035 int QTime::msecsTo(QTime t) const
2036 {
2037     if (!isValid() || !t.isValid())
2038         return 0;
2039     return t.ds() - ds();
2040 }
2041 
2042 
2043 /*!
2044     \fn bool QTime::operator==(QTime lhs, QTime rhs)
2045 
2046     Returns \c true if \a lhs is equal to \a rhs; otherwise returns \c false.
2047 */
2048 
2049 /*!
2050     \fn bool QTime::operator!=(QTime lhs, QTime rhs)
2051 
2052     Returns \c true if \a lhs is different from \a rhs; otherwise returns \c false.
2053 */
2054 
2055 /*!
2056     \fn bool QTime::operator<(QTime lhs, QTime rhs)
2057 
2058     Returns \c true if \a lhs is earlier than \a rhs; otherwise returns \c false.
2059 */
2060 
2061 /*!
2062     \fn bool QTime::operator<=(QTime lhs, QTime rhs)
2063 
2064     Returns \c true if \a lhs is earlier than or equal to \a rhs;
2065     otherwise returns \c false.
2066 */
2067 
2068 /*!
2069     \fn bool QTime::operator>(QTime lhs, QTime rhs)
2070 
2071     Returns \c true if \a lhs is later than \a rhs; otherwise returns \c false.
2072 */
2073 
2074 /*!
2075     \fn bool QTime::operator>=(QTime lhs, QTime rhs)
2076 
2077     Returns \c true if \a lhs is later than or equal to \a rhs;
2078     otherwise returns \c false.
2079 */
2080 
2081 /*!
2082     \fn QTime QTime::fromMSecsSinceStartOfDay(int msecs)
2083 
2084     Returns a new QTime instance with the time set to the number of \a msecs
2085     since the start of the day, i.e. since 00:00:00.
2086 
2087     If \a msecs falls outside the valid range an invalid QTime will be returned.
2088 
2089     \sa msecsSinceStartOfDay()
2090 */
2091 
2092 /*!
2093     \fn int QTime::msecsSinceStartOfDay() const
2094 
2095     Returns the number of msecs since the start of the day, i.e. since 00:00:00.
2096 
2097     \sa fromMSecsSinceStartOfDay()
2098 */
2099 
2100 /*!
2101     \fn QTime::currentTime()
2102 
2103     Returns the current time as reported by the system clock.
2104 
2105     Note that the accuracy depends on the accuracy of the underlying
2106     operating system; not all systems provide 1-millisecond accuracy.
2107 
2108     Furthermore, currentTime() only increases within each day; it shall drop by
2109     24 hours each time midnight passes; and, beside this, changes in it may not
2110     correspond to elapsed time, if a daylight-saving transition intervenes.
2111 
2112     \sa QDateTime::currentDateTime(), QDateTime::currentDateTimeUtc()
2113 */
2114 
2115 #if QT_CONFIG(datestring) // depends on, so implies, textdate
2116 
2117 static QTime fromIsoTimeString(QStringView string, Qt::DateFormat format, bool *isMidnight24)
2118 {
2119     Q_ASSERT(format == Qt::TextDate || format == Qt::ISODate || format == Qt::ISODateWithMs);
2120     if (isMidnight24)
2121         *isMidnight24 = false;
2122     // Match /\d\d(:\d\d(:\d\d)?)?([,.]\d+)?/ as "HH[:mm[:ss]][.zzz]"
2123     // The fractional part, if present, is in the same units as the field it follows.
2124     // TextDate restricts fractional parts to the seconds field.
2125 
2126     QStringView tail;
2127     const int dot = string.indexOf(u'.'), comma = string.indexOf(u',');
2128     if (dot != -1) {
2129         tail = string.sliced(dot + 1);
2130         if (tail.indexOf(u'.') != -1) // Forbid second dot:
2131             return QTime();
2132         string = string.first(dot);
2133     } else if (comma != -1) {
2134         tail = string.sliced(comma + 1);
2135         string = string.first(comma);
2136     }
2137     if (tail.indexOf(u',') != -1) // Forbid comma after first dot-or-comma:
2138         return QTime();
2139 
2140     const ParsedInt frac = readInt(tail);
2141     // There must be *some* digits in a fractional part; and it must be all digits:
2142     if (tail.isEmpty() ? dot != -1 || comma != -1 : !frac.ok)
2143         return QTime();
2144     Q_ASSERT(frac.ok ^ tail.isEmpty());
2145     double fraction = frac.ok ? frac.value * std::pow(0.1, tail.size()) : 0.0;
2146 
2147     const int size = string.size();
2148     if (size < 2 || size > 8)
2149         return QTime();
2150 
2151     ParsedInt hour = readInt(string.first(2));
2152     if (!hour.ok || hour.value > (format == Qt::TextDate ? 23 : 24))
2153         return QTime();
2154 
2155     ParsedInt minute;
2156     if (string.size() > 2) {
2157         if (string[2] == u':' && string.size() > 4)
2158             minute = readInt(string.sliced(3, 2));
2159         if (!minute.ok || minute.value >= 60)
2160             return QTime();
2161     } else if (format == Qt::TextDate) { // Requires minutes
2162         return QTime();
2163     } else if (frac.ok) {
2164         Q_ASSERT(!(fraction < 0.0) && fraction < 1.0);
2165         fraction *= 60;
2166         minute.value = qulonglong(fraction);
2167         fraction -= minute.value;
2168     }
2169 
2170     ParsedInt second;
2171     if (string.size() > 5) {
2172         if (string[5] == u':' && string.size() == 8)
2173             second = readInt(string.sliced(6, 2));
2174         if (!second.ok || second.value >= 60)
2175             return QTime();
2176     } else if (frac.ok) {
2177         if (format == Qt::TextDate) // Doesn't allow fraction of minutes
2178             return QTime();
2179         Q_ASSERT(!(fraction < 0.0) && fraction < 1.0);
2180         fraction *= 60;
2181         second.value = qulonglong(fraction);
2182         fraction -= second.value;
2183     }
2184 
2185     Q_ASSERT(!(fraction < 0.0) && fraction < 1.0);
2186     // Round millis to nearest (unlike minutes and seconds, rounded down):
2187     int msec = frac.ok ? qRound(MSECS_PER_SEC * fraction) : 0;
2188     // But handle overflow gracefully:
2189     if (msec == MSECS_PER_SEC) {
2190         // If we can (when data were otherwise valid) validly propagate overflow
2191         // into other fields, do so:
2192         if (isMidnight24 || hour.value < 23 || minute.value < 59 || second.value < 59) {
2193             msec = 0;
2194             if (++second.value == 60) {
2195                 second.value = 0;
2196                 if (++minute.value == 60) {
2197                     minute.value = 0;
2198                     ++hour.value;
2199                     // May need to propagate further via isMidnight24, see below
2200                 }
2201             }
2202         } else {
2203             // QTime::fromString() or Qt::TextDate: rounding up would cause
2204             // 23:59:59.999... to become invalid; clip to 999 ms instead:
2205             msec = MSECS_PER_SEC - 1;
2206         }
2207     }
2208 
2209     // For ISO date format, 24:0:0 means 0:0:0 on the next day:
2210     if (hour.value == 24 && minute.value == 0 && second.value == 0 && msec == 0) {
2211         Q_ASSERT(format != Qt::TextDate); // It clipped hour at 23, above.
2212         if (isMidnight24)
2213             *isMidnight24 = true;
2214         hour.value = 0;
2215     }
2216 
2217     return QTime(hour.value, minute.value, second.value, msec);
2218 }
2219 
2220 /*!
2221     \fn QTime QTime::fromString(const QString &string, Qt::DateFormat format)
2222 
2223     Returns the time represented in the \a string as a QTime using the
2224     \a format given, or an invalid time if this is not possible.
2225 
2226     \sa toString(), QLocale::toTime()
2227 */
2228 
2229 /*!
2230     \overload
2231     \since 6.0
2232 */
2233 QTime QTime::fromString(QStringView string, Qt::DateFormat format)
2234 {
2235     if (string.isEmpty())
2236         return QTime();
2237 
2238     switch (format) {
2239     case Qt::RFC2822Date:
2240         return rfcDateImpl(string).time;
2241     case Qt::ISODate:
2242     case Qt::ISODateWithMs:
2243     case Qt::TextDate:
2244     default:
2245         return fromIsoTimeString(string, format, nullptr);
2246     }
2247 }
2248 
2249 /*!
2250     \fn QTime QTime::fromString(const QString &string, const QString &format)
2251 
2252     Returns the QTime represented by the \a string, using the \a
2253     format given, or an invalid time if the string cannot be parsed.
2254 
2255     These expressions may be used for the format:
2256 
2257     \table
2258     \header \li Expression \li Output
2259     \row \li h
2260          \li The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
2261     \row \li hh
2262          \li The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
2263     \row \li H
2264          \li The hour without a leading zero (0 to 23, even with AM/PM display)
2265     \row \li HH
2266          \li The hour with a leading zero (00 to 23, even with AM/PM display)
2267     \row \li m \li The minute without a leading zero (0 to 59)
2268     \row \li mm \li The minute with a leading zero (00 to 59)
2269     \row \li s \li The whole second, without any leading zero (0 to 59)
2270     \row \li ss \li The whole second, with a leading zero where applicable (00 to 59)
2271     \row \li z \li The fractional part of the second, to go after a decimal
2272                 point, without trailing zeroes (0 to 999).  Thus "\c{s.z}"
2273                 reports the seconds to full available (millisecond) precision
2274                 without trailing zeroes.
2275     \row \li zzz \li The fractional part of the second, to millisecond
2276                 precision, including trailing zeroes where applicable (000 to 999).
2277     \row \li AP or A
2278          \li Interpret as an AM/PM time. \e A/AP will match 'AM' or 'PM'.
2279     \row \li ap or a
2280          \li Interpret as an am/pm time. \e a/ap will match 'am' or 'pm'.
2281     \endtable
2282 
2283     All other input characters will be treated as text. Any non-empty sequence
2284     of characters enclosed in single quotes will also be treated (stripped of
2285     the quotes) as text and not be interpreted as expressions.
2286 
2287     \snippet code/src_corelib_time_qdatetime.cpp 6
2288 
2289     If the format is not satisfied, an invalid QTime is returned.
2290     Expressions that do not expect leading zeroes to be given (h, m, s
2291     and z) are greedy. This means that they will use two digits (or three, for z) even if
2292     this puts them outside the range of accepted values and leaves too
2293     few digits for other sections. For example, the following string
2294     could have meant 00:07:10, but the m will grab two digits, resulting
2295     in an invalid time:
2296 
2297     \snippet code/src_corelib_time_qdatetime.cpp 7
2298 
2299     Any field that is not represented in the format will be set to zero.
2300     For example:
2301 
2302     \snippet code/src_corelib_time_qdatetime.cpp 8
2303 
2304     \note If localized forms of am or pm (the AP, ap, A or a formats) are used,
2305     please use QLocale::system().toTime().
2306 
2307     \sa toString(), QDateTime::fromString(), QDate::fromString(),
2308     QLocale::toTime()
2309 */
2310 
2311 /*!
2312     \fn QTime QTime::fromString(QStringView string, QStringView format)
2313     \overload
2314     \since 6.0
2315 */
2316 
2317 /*!
2318     \overload
2319     \since 6.0
2320 */
2321 QTime QTime::fromString(const QString &string, QStringView format)
2322 {
2323     QTime time;
2324 #if QT_CONFIG(datetimeparser)
2325     QDateTimeParser dt(QMetaType::QTime, QDateTimeParser::FromString, QCalendar());
2326     dt.setDefaultLocale(QLocale::c());
2327     if (dt.parseFormat(format))
2328         dt.fromString(string, nullptr, &time);
2329 #else
2330     Q_UNUSED(string);
2331     Q_UNUSED(format);
2332 #endif
2333     return time;
2334 }
2335 #endif // datestring
2336 
2337 
2338 /*!
2339     \overload
2340 
2341     Returns \c true if the specified time is valid; otherwise returns
2342     false.
2343 
2344     The time is valid if \a h is in the range 0 to 23, \a m and
2345     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.
2346 
2347     Example:
2348 
2349     \snippet code/src_corelib_time_qdatetime.cpp 9
2350 */
2351 
2352 bool QTime::isValid(int h, int m, int s, int ms)
2353 {
2354     return uint(h) < 24 && uint(m) < 60 && uint(s) < SECS_PER_MIN && uint(ms) < MSECS_PER_SEC;
2355 }
2356 
2357 /*****************************************************************************
2358   QDateTime static helper functions
2359  *****************************************************************************/
2360 
2361 // get the types from QDateTime (through QDateTimePrivate)
2362 typedef QDateTimePrivate::QDateTimeShortData ShortData;
2363 typedef QDateTimePrivate::QDateTimeData QDateTimeData;
2364 
2365 // Returns the platform variant of timezone, i.e. the standard time offset
2366 // The timezone external variable is documented as always holding the
2367 // Standard Time offset as seconds west of Greenwich, i.e. UTC+01:00 is -3600
2368 // Note this may not be historicaly accurate.
2369 // Relies on tzset, mktime, or localtime having been called to populate timezone
2370 static int qt_timezone()
2371 {
2372 #if defined(_MSC_VER)
2373         long offset;
2374         _get_timezone(&offset);
2375         return offset;
2376 #elif defined(Q_OS_BSD4) && !defined(Q_OS_DARWIN)
2377         time_t clock = time(NULL);
2378         struct tm t;
2379         localtime_r(&clock, &t);
2380         // QTBUG-36080 Workaround for systems without the POSIX timezone
2381         // variable. This solution is not very efficient but fixing it is up to
2382         // the libc implementations.
2383         //
2384         // tm_gmtoff has some important differences compared to the timezone
2385         // variable:
2386         // - It returns the number of seconds east of UTC, and we want the
2387         //   number of seconds west of UTC.
2388         // - It also takes DST into account, so we need to adjust it to always
2389         //   get the Standard Time offset.
2390         return -t.tm_gmtoff + (t.tm_isdst ? (long)SECS_PER_HOUR : 0L);
2391 #elif defined(Q_OS_INTEGRITY) || defined(Q_OS_RTEMS)
2392         return 0;
2393 #else
2394         return timezone;
2395 #endif // Q_OS_WIN
2396 }
2397 
2398 // Returns the tzname, assume tzset has been called already
2399 static QString qt_tzname(QDateTimePrivate::DaylightStatus daylightStatus)
2400 {
2401     int isDst = (daylightStatus == QDateTimePrivate::DaylightTime) ? 1 : 0;
2402 #if defined(Q_CC_MSVC)
2403     size_t s = 0;
2404     char name[512];
2405     if (_get_tzname(&s, name, 512, isDst))
2406         return QString();
2407     return QString::fromLocal8Bit(name);
2408 #else
2409     return QString::fromLocal8Bit(tzname[isDst]);
2410 #endif // Q_OS_WIN
2411 }
2412 
2413 #if QT_CONFIG(datetimeparser)
2414 /*
2415   \internal
2416   Implemented here to share qt_tzname()
2417 */
2418 int QDateTimeParser::startsWithLocalTimeZone(QStringView name)
2419 {
2420     QDateTimePrivate::DaylightStatus zones[2] = {
2421         QDateTimePrivate::StandardTime,
2422         QDateTimePrivate::DaylightTime
2423     };
2424     for (const auto z : zones) {
2425         QString zone(qt_tzname(z));
2426         if (name.startsWith(zone))
2427             return zone.size();
2428     }
2429     return 0;
2430 }
2431 #endif // datetimeparser
2432 
2433 // Calls the platform variant of mktime for the given date, time and daylightStatus,
2434 // and updates the date, time, daylightStatus and abbreviation with the returned values
2435 // If the date falls outside the 1970 to 2037 range supported by mktime / time_t
2436 // then null date/time will be returned, you should adjust the date first if
2437 // you need a guaranteed result.
2438 static qint64 qt_mktime(QDate *date, QTime *time, QDateTimePrivate::DaylightStatus *daylightStatus,
2439                         QString *abbreviation, bool *ok = nullptr)
2440 {
2441     const qint64 msec = time->msec();
2442     int yy, mm, dd;
2443     date->getDate(&yy, &mm, &dd);
2444 
2445     // All other platforms provide standard C library time functions
2446     tm local;
2447     memset(&local, 0, sizeof(local)); // tm_[wy]day plus any non-standard fields
2448     local.tm_sec = time->second();
2449     local.tm_min = time->minute();
2450     local.tm_hour = time->hour();
2451     local.tm_mday = dd;
2452     local.tm_mon = mm - 1;
2453     local.tm_year = yy - 1900;
2454     local.tm_isdst = daylightStatus ? int(*daylightStatus) : -1;
2455 
2456 #if defined(Q_OS_WIN)
2457     int hh = local.tm_hour;
2458 #endif // Q_OS_WIN
2459     time_t secsSinceEpoch = qMkTime(&local);
2460     if (secsSinceEpoch != time_t(-1)) {
2461         *date = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2462         *time = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2463 #if defined(Q_OS_WIN)
2464         // Windows mktime for the missing hour subtracts 1 hour from the time
2465         // instead of adding 1 hour.  If time differs and is standard time then
2466         // this has happened, so add 2 hours to the time and 1 hour to the msecs
2467         if (local.tm_isdst == 0 && local.tm_hour != hh) {
2468             if (time->hour() >= 22)
2469                 *date = date->addDays(1);
2470             *time = time->addSecs(2 * SECS_PER_HOUR);
2471             secsSinceEpoch += SECS_PER_HOUR;
2472             local.tm_isdst = 1;
2473         }
2474 #endif // Q_OS_WIN
2475         if (local.tm_isdst > 0) {
2476             if (daylightStatus)
2477                 *daylightStatus = QDateTimePrivate::DaylightTime;
2478             if (abbreviation)
2479                 *abbreviation = qt_tzname(QDateTimePrivate::DaylightTime);
2480         } else {
2481             if (daylightStatus) {
2482                 *daylightStatus = (local.tm_isdst == 0
2483                                    ? QDateTimePrivate::StandardTime
2484                                    : QDateTimePrivate::UnknownDaylightTime);
2485             }
2486             if (abbreviation)
2487                 *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2488         }
2489     } else if (yy == 1969 && mm == 12 && dd == 31
2490                && QTime(0, 0).secsTo(*time) == SECS_PER_DAY - 1) {
2491         // There was, of course, a last second in 1969, at time_t(-1); we won't
2492         // rescue it if it's not in normalised form, and we don't know its DST
2493         // status (unless we did already), but let's not wantonly declare it
2494         // invalid.
2495     } else {
2496         *date = QDate();
2497         *time = QTime();
2498         if (daylightStatus)
2499             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2500         if (abbreviation)
2501             *abbreviation = QString();
2502         if (ok)
2503             *ok = false;
2504         return 0;
2505     }
2506     if (ok)
2507         *ok = true;
2508 
2509     return qint64(secsSinceEpoch) * MSECS_PER_SEC + msec;
2510 }
2511 
2512 // Calls the platform variant of localtime for the given msecs, and updates
2513 // the date, time, and DST status with the returned values.
2514 static bool qt_localtime(qint64 msecsSinceEpoch, QDate *localDate, QTime *localTime,
2515                          QDateTimePrivate::DaylightStatus *daylightStatus)
2516 {
2517     const time_t secsSinceEpoch = msecsSinceEpoch / MSECS_PER_SEC;
2518     const int msec = msecsSinceEpoch % MSECS_PER_SEC;
2519 
2520     tm local;
2521     bool valid = false;
2522 
2523     // localtime() is specified to work as if it called tzset().
2524     // localtime_r() does not have this constraint, so make an explicit call.
2525     // The explicit call should also request the timezone info be re-parsed.
2526     qTzSet();
2527 #if QT_CONFIG(thread) && defined(_POSIX_THREAD_SAFE_FUNCTIONS)
2528     // Use the reentrant version of localtime() where available
2529     // as is thread-safe and doesn't use a shared static data area
2530     if (tm *res = localtime_r(&secsSinceEpoch, &local)) {
2531         Q_ASSERT(res == &local);
2532         valid = true;
2533     }
2534 #elif defined(Q_CC_MSVC)
2535     if (!_localtime64_s(&local, &secsSinceEpoch))
2536         valid = true;
2537 #else
2538     // Returns shared static data which may be overwritten at any time
2539     // So copy the result asap
2540     if (tm *res = localtime(&secsSinceEpoch)) {
2541         local = *res;
2542         valid = true;
2543     }
2544 #endif
2545     if (valid) {
2546         *localDate = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2547         *localTime = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2548         if (daylightStatus) {
2549             if (local.tm_isdst > 0)
2550                 *daylightStatus = QDateTimePrivate::DaylightTime;
2551             else if (local.tm_isdst < 0)
2552                 *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2553             else
2554                 *daylightStatus = QDateTimePrivate::StandardTime;
2555         }
2556         return true;
2557     } else {
2558         *localDate = QDate();
2559         *localTime = QTime();
2560         if (daylightStatus)
2561             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2562         return false;
2563     }
2564 }
2565 
2566 // Converts an msecs value into a date and time
2567 static void msecsToTime(qint64 msecs, QDate *date, QTime *time)
2568 {
2569     qint64 jd = JULIAN_DAY_FOR_EPOCH;
2570     qint64 ds = 0;
2571 
2572     if (msecs >= MSECS_PER_DAY || msecs <= -MSECS_PER_DAY) {
2573         jd += msecs / MSECS_PER_DAY;
2574         msecs %= MSECS_PER_DAY;
2575     }
2576 
2577     if (msecs < 0) {
2578         ds = MSECS_PER_DAY - msecs - 1;
2579         jd -= ds / MSECS_PER_DAY;
2580         ds = ds % MSECS_PER_DAY;
2581         ds = MSECS_PER_DAY - ds - 1;
2582     } else {
2583         ds = msecs;
2584     }
2585 
2586     if (date)
2587         *date = QDate::fromJulianDay(jd);
2588     if (time)
2589         *time = QTime::fromMSecsSinceStartOfDay(ds);
2590 }
2591 
2592 // Converts a date/time value into msecs
2593 static qint64 timeToMSecs(QDate date, QTime time)
2594 {
2595     return ((date.toJulianDay() - JULIAN_DAY_FOR_EPOCH) * MSECS_PER_DAY)
2596            + time.msecsSinceStartOfDay();
2597 }
2598 
2599 // Convert an MSecs Since Epoch into Local Time
2600 static bool epochMSecsToLocalTime(qint64 msecs, QDate *localDate, QTime *localTime,
2601                                   QDateTimePrivate::DaylightStatus *daylightStatus = nullptr)
2602 {
2603     if (msecs < 0) {
2604         // Docs state any LocalTime before 1970-01-01 will *not* have any Daylight Time applied
2605         // Instead just use the standard offset from UTC to convert to UTC time
2606         qTzSet();
2607         msecsToTime(msecs - qt_timezone() * MSECS_PER_SEC, localDate, localTime);
2608         if (daylightStatus)
2609             *daylightStatus = QDateTimePrivate::StandardTime;
2610         return true;
2611     } else if (msecs > TIME_T_MAX * MSECS_PER_SEC) {
2612         // Docs state any LocalTime after 2037-12-31 *will* have any DST applied
2613         // but this may fall outside the supported time_t range, so need to fake it.
2614         // Use existing method to fake the conversion, but this is deeply flawed as it may
2615         // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2616         // TODO Use QTimeZone when available to apply the future rule correctly
2617         QDate utcDate;
2618         QTime utcTime;
2619         msecsToTime(msecs, &utcDate, &utcTime);
2620         int year, month, day;
2621         utcDate.getDate(&year, &month, &day);
2622         // 2037 is not a leap year, so make sure date isn't Feb 29
2623         if (month == 2 && day == 29)
2624             --day;
2625         QDate fakeDate(2037, month, day);
2626         qint64 fakeMsecs = QDateTime(fakeDate, utcTime, Qt::UTC).toMSecsSinceEpoch();
2627         bool res = qt_localtime(fakeMsecs, localDate, localTime, daylightStatus);
2628         *localDate = localDate->addDays(fakeDate.daysTo(utcDate));
2629         return res;
2630     } else {
2631         // Falls inside time_t suported range so can use localtime
2632         return qt_localtime(msecs, localDate, localTime, daylightStatus);
2633     }
2634 }
2635 
2636 // Convert a LocalTime expressed in local msecs encoding and the corresponding
2637 // DST status into a UTC epoch msecs. Optionally populate the returned
2638 // values from mktime for the adjusted local date and time.
2639 static qint64 localMSecsToEpochMSecs(qint64 localMsecs,
2640                                      QDateTimePrivate::DaylightStatus *daylightStatus,
2641                                      QDate *localDate = nullptr, QTime *localTime = nullptr,
2642                                      QString *abbreviation = nullptr)
2643 {
2644     QDate dt;
2645     QTime tm;
2646     msecsToTime(localMsecs, &dt, &tm);
2647 
2648     const qint64 msecsMax = TIME_T_MAX * MSECS_PER_SEC;
2649 
2650     if (localMsecs <= MSECS_PER_DAY) {
2651 
2652         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
2653 
2654         // First, if localMsecs is within +/- 1 day of minimum time_t try mktime in case it does
2655         // fall after minimum and needs proper DST conversion
2656         if (localMsecs >= -MSECS_PER_DAY) {
2657             bool valid;
2658             qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation, &valid);
2659             if (valid && utcMsecs >= 0) {
2660                 // mktime worked and falls in valid range, so use it
2661                 if (localDate)
2662                     *localDate = dt;
2663                 if (localTime)
2664                     *localTime = tm;
2665                 return utcMsecs;
2666             }
2667         } else {
2668             // If we don't call mktime then need to call tzset to get offset
2669             qTzSet();
2670         }
2671         // Time is clearly before 1970-01-01 so just use standard offset to convert
2672         qint64 utcMsecs = localMsecs + qt_timezone() * MSECS_PER_SEC;
2673         if (localDate || localTime)
2674             msecsToTime(localMsecs, localDate, localTime);
2675         if (daylightStatus)
2676             *daylightStatus = QDateTimePrivate::StandardTime;
2677         if (abbreviation)
2678             *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2679         return utcMsecs;
2680 
2681     } else if (localMsecs >= msecsMax - MSECS_PER_DAY) {
2682 
2683         // Docs state any LocalTime after 2037-12-31 *will* have any DST applied
2684         // but this may fall outside the supported time_t range, so need to fake it.
2685 
2686         // First, if localMsecs is within +/- 1 day of maximum time_t try mktime in case it does
2687         // fall before maximum and can use proper DST conversion
2688         if (localMsecs <= msecsMax + MSECS_PER_DAY) {
2689             bool valid;
2690             qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation, &valid);
2691             if (valid && utcMsecs <= msecsMax) {
2692                 // mktime worked and falls in valid range, so use it
2693                 if (localDate)
2694                     *localDate = dt;
2695                 if (localTime)
2696                     *localTime = tm;
2697                 return utcMsecs;
2698             }
2699         }
2700         // Use existing method to fake the conversion, but this is deeply flawed as it may
2701         // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2702         // TODO Use QTimeZone when available to apply the future rule correctly
2703         int year, month, day;
2704         dt.getDate(&year, &month, &day);
2705         // 2037 is not a leap year, so make sure date isn't Feb 29
2706         if (month == 2 && day == 29)
2707             --day;
2708         QDate fakeDate(2037, month, day);
2709         qint64 fakeDiff = fakeDate.daysTo(dt);
2710         qint64 utcMsecs = qt_mktime(&fakeDate, &tm, daylightStatus, abbreviation);
2711         if (localDate)
2712             *localDate = fakeDate.addDays(fakeDiff);
2713         if (localTime)
2714             *localTime = tm;
2715         QDate utcDate;
2716         QTime utcTime;
2717         msecsToTime(utcMsecs, &utcDate, &utcTime);
2718         utcDate = utcDate.addDays(fakeDiff);
2719         utcMsecs = timeToMSecs(utcDate, utcTime);
2720         return utcMsecs;
2721 
2722     } else {
2723 
2724         // Clearly falls inside 1970-2037 suported range so can use mktime
2725         qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation);
2726         if (localDate)
2727             *localDate = dt;
2728         if (localTime)
2729             *localTime = tm;
2730         return utcMsecs;
2731 
2732     }
2733 }
2734 
2735 static inline bool specCanBeSmall(Qt::TimeSpec spec)
2736 {
2737     return spec == Qt::LocalTime || spec == Qt::UTC;
2738 }
2739 
2740 static inline bool msecsCanBeSmall(qint64 msecs)
2741 {
2742     if (!QDateTimeData::CanBeSmall)
2743         return false;
2744 
2745     ShortData sd;
2746     sd.msecs = qintptr(msecs);
2747     return sd.msecs == msecs;
2748 }
2749 
2750 static constexpr inline
2751 QDateTimePrivate::StatusFlags mergeSpec(QDateTimePrivate::StatusFlags status, Qt::TimeSpec spec)
2752 {
2753     return QDateTimePrivate::StatusFlags((status & ~QDateTimePrivate::TimeSpecMask) |
2754                                          (int(spec) << QDateTimePrivate::TimeSpecShift));
2755 }
2756 
2757 static constexpr inline Qt::TimeSpec extractSpec(QDateTimePrivate::StatusFlags status)
2758 {
2759     return Qt::TimeSpec((status & QDateTimePrivate::TimeSpecMask) >> QDateTimePrivate::TimeSpecShift);
2760 }
2761 
2762 // Set the Daylight Status if LocalTime set via msecs
2763 static constexpr inline QDateTimePrivate::StatusFlags
2764 mergeDaylightStatus(QDateTimePrivate::StatusFlags sf, QDateTimePrivate::DaylightStatus status)
2765 {
2766     sf &= ~QDateTimePrivate::DaylightMask;
2767     if (status == QDateTimePrivate::DaylightTime) {
2768         sf |= QDateTimePrivate::SetToDaylightTime;
2769     } else if (status == QDateTimePrivate::StandardTime) {
2770         sf |= QDateTimePrivate::SetToStandardTime;
2771     }
2772     return sf;
2773 }
2774 
2775 // Get the DST Status if LocalTime set via msecs
2776 static constexpr inline
2777 QDateTimePrivate::DaylightStatus extractDaylightStatus(QDateTimePrivate::StatusFlags status)
2778 {
2779     if (status & QDateTimePrivate::SetToDaylightTime)
2780         return QDateTimePrivate::DaylightTime;
2781     if (status & QDateTimePrivate::SetToStandardTime)
2782         return QDateTimePrivate::StandardTime;
2783     return QDateTimePrivate::UnknownDaylightTime;
2784 }
2785 
2786 static inline qint64 getMSecs(const QDateTimeData &d)
2787 {
2788     if (d.isShort()) {
2789         // same as, but producing better code
2790         //return d.data.msecs;
2791         return qintptr(d.d) >> 8;
2792     }
2793     return d->m_msecs;
2794 }
2795 
2796 static inline QDateTimePrivate::StatusFlags getStatus(const QDateTimeData &d)
2797 {
2798     if (d.isShort()) {
2799         // same as, but producing better code
2800         //return StatusFlag(d.data.status);
2801         return QDateTimePrivate::StatusFlag(qintptr(d.d) & 0xFF);
2802     }
2803     return d->m_status;
2804 }
2805 
2806 static inline Qt::TimeSpec getSpec(const QDateTimeData &d)
2807 {
2808     return extractSpec(getStatus(d));
2809 }
2810 
2811 /* True if we *can cheaply determine* that a and b use the same offset.
2812    If they use different offsets or it would be expensive to find out, false.
2813    Calls to toMSecsSinceEpoch() are expensive, for these purposes.
2814    See QDateTime's comparison operators.
2815 */
2816 static inline bool usesSameOffset(const QDateTimeData &a, const QDateTimeData &b)
2817 {
2818     const auto status = getStatus(a);
2819     if (status != getStatus(b))
2820         return false;
2821     // Status includes DST-ness, so we now know they match in it.
2822 
2823     switch (extractSpec(status)) {
2824     case Qt::LocalTime:
2825     case Qt::UTC:
2826         return true;
2827 
2828     case Qt::TimeZone:
2829         /* TimeZone always determines its offset during construction of the
2830            private data. Even if we're in different zones, what matters is the
2831            offset actually in effect at the specific time. (DST can cause things
2832            with the same time-zone to use different offsets, but we already
2833            checked their DSTs match.) */
2834     case Qt::OffsetFromUTC: // always knows its offset, which is all that matters.
2835         Q_ASSERT(!a.isShort() && !b.isShort());
2836         return a->m_offsetFromUtc == b->m_offsetFromUtc;
2837     }
2838     Q_UNREACHABLE();
2839     return false;
2840 }
2841 
2842 // Refresh the LocalTime or TimeZone validity and offset
2843 static void refreshZonedDateTime(QDateTimeData &d, Qt::TimeSpec spec)
2844 {
2845     Q_ASSERT(spec == Qt::TimeZone || spec == Qt::LocalTime);
2846     auto status = getStatus(d);
2847     Q_ASSERT(extractSpec(status) == spec);
2848     int offsetFromUtc = 0;
2849 
2850     // If not valid date and time then is invalid
2851     if (!(status & QDateTimePrivate::ValidDate) || !(status & QDateTimePrivate::ValidTime)) {
2852         status &= ~QDateTimePrivate::ValidDateTime;
2853     } else {
2854         // We have a valid date and time and a Qt::LocalTime or Qt::TimeZone that needs calculating
2855         // LocalTime and TimeZone might fall into a "missing" DST transition hour
2856         // Calling toEpochMSecs will adjust the returned date/time if it does
2857         const qint64 msecs = getMSecs(d);
2858         qint64 epochMSecs = 0;
2859         QDate testDate;
2860         QTime testTime;
2861         auto dstStatus = extractDaylightStatus(status);
2862         if (spec == Qt::LocalTime) {
2863             epochMSecs = localMSecsToEpochMSecs(msecs, &dstStatus, &testDate, &testTime);
2864 #if QT_CONFIG(timezone)
2865         // else spec == Qt::TimeZone, so check zone is valid:
2866         } else if (d->m_timeZone.isValid()) {
2867             epochMSecs = QDateTimePrivate::zoneMSecsToEpochMSecs(
2868                 msecs, d->m_timeZone, dstStatus, &testDate, &testTime);
2869 #endif // timezone
2870         } // else: testDate, testTime haven't been set, so are invalid.
2871         // Cache the offset to use in offsetFromUtc() &c.
2872         offsetFromUtc = (msecs - epochMSecs) / MSECS_PER_SEC;
2873         if (testDate.isValid() && testTime.isValid()
2874             && timeToMSecs(testDate, testTime) == msecs) {
2875             status = mergeDaylightStatus(status, dstStatus);
2876             status |= QDateTimePrivate::ValidDateTime;
2877         } else {
2878             status &= ~QDateTimePrivate::ValidDateTime;
2879         }
2880     }
2881 
2882     if (status & QDateTimePrivate::ShortData) {
2883         d.data.status = status;
2884     } else {
2885         d->m_status = status;
2886         d->m_offsetFromUtc = offsetFromUtc;
2887     }
2888 }
2889 
2890 // Check the UTC / offsetFromUTC validity
2891 static void refreshSimpleDateTime(QDateTimeData &d)
2892 {
2893     auto status = getStatus(d);
2894     Q_ASSERT(extractSpec(status) == Qt::UTC || extractSpec(status) == Qt::OffsetFromUTC);
2895     if ((status & QDateTimePrivate::ValidDate) && (status & QDateTimePrivate::ValidTime))
2896         status |= QDateTimePrivate::ValidDateTime;
2897     else
2898         status &= ~QDateTimePrivate::ValidDateTime;
2899 
2900     if (status & QDateTimePrivate::ShortData)
2901         d.data.status = status;
2902     else
2903         d->m_status = status;
2904 }
2905 
2906 // Clean up and set status after assorted set-up or reworking:
2907 static void checkValidDateTime(QDateTimeData &d)
2908 {
2909     auto status = getStatus(d);
2910     auto spec = extractSpec(status);
2911     switch (spec) {
2912     case Qt::OffsetFromUTC:
2913     case Qt::UTC:
2914         // for these, a valid date and a valid time imply a valid QDateTime
2915         refreshSimpleDateTime(d);
2916         break;
2917     case Qt::TimeZone:
2918     case Qt::LocalTime:
2919         // for these, we need to check whether the timezone is valid and whether
2920         // the time is valid in that timezone. Expensive, but no other option.
2921         refreshZonedDateTime(d, spec);
2922         break;
2923     }
2924 }
2925 
2926 // Caller needs to refresh after calling this
2927 static void setTimeSpec(QDateTimeData &d, Qt::TimeSpec spec, int offsetSeconds)
2928 {
2929     auto status = getStatus(d);
2930     status &= ~(QDateTimePrivate::ValidDateTime | QDateTimePrivate::DaylightMask |
2931                 QDateTimePrivate::TimeSpecMask);
2932 
2933     switch (spec) {
2934     case Qt::OffsetFromUTC:
2935         if (offsetSeconds == 0)
2936             spec = Qt::UTC;
2937         break;
2938     case Qt::TimeZone:
2939         qWarning("Using TimeZone in setTimeSpec() is unsupported"); // Use system time zone instead
2940         spec = Qt::LocalTime;
2941         Q_FALLTHROUGH();
2942     case Qt::UTC:
2943     case Qt::LocalTime:
2944         offsetSeconds = 0;
2945         break;
2946     }
2947 
2948     status = mergeSpec(status, spec);
2949     if (d.isShort() && offsetSeconds == 0) {
2950         d.data.status = status;
2951     } else {
2952         d.detach();
2953         d->m_status = status & ~QDateTimePrivate::ShortData;
2954         d->m_offsetFromUtc = offsetSeconds;
2955 #if QT_CONFIG(timezone)
2956         d->m_timeZone = QTimeZone();
2957 #endif // timezone
2958     }
2959 }
2960 
2961 static void setDateTime(QDateTimeData &d, QDate date, QTime time)
2962 {
2963     // If the date is valid and the time is not we set time to 00:00:00
2964     QTime useTime = time;
2965     if (!useTime.isValid() && date.isValid())
2966         useTime = QTime::fromMSecsSinceStartOfDay(0);
2967 
2968     QDateTimePrivate::StatusFlags newStatus = { };
2969 
2970     // Set date value and status
2971     qint64 days = 0;
2972     if (date.isValid()) {
2973         days = date.toJulianDay() - JULIAN_DAY_FOR_EPOCH;
2974         newStatus = QDateTimePrivate::ValidDate;
2975     }
2976 
2977     // Set time value and status
2978     int ds = 0;
2979     if (useTime.isValid()) {
2980         ds = useTime.msecsSinceStartOfDay();
2981         newStatus |= QDateTimePrivate::ValidTime;
2982     }
2983     Q_ASSERT(ds < MSECS_PER_DAY);
2984     // Only the later parts of the very first day are representable - its start
2985     // would overflow - so get ds the same side of 0 as days:
2986     if (days < 0 && ds > 0) {
2987         days++;
2988         ds -= MSECS_PER_DAY;
2989     }
2990 
2991     // Check in representable range:
2992     qint64 msecs = 0;
2993     if (mul_overflow(days, std::integral_constant<qint64, MSECS_PER_DAY>(), &msecs)
2994         || add_overflow(msecs, qint64(ds), &msecs)) {
2995         newStatus = QDateTimePrivate::StatusFlags{};
2996     } else if (d.isShort()) {
2997         // let's see if we can keep this short
2998         if (msecsCanBeSmall(msecs)) {
2999             // yes, we can
3000             d.data.msecs = qintptr(msecs);
3001             d.data.status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
3002             d.data.status |= newStatus;
3003         } else {
3004             // nope...
3005             d.detach();
3006         }
3007     }
3008     if (!d.isShort()) {
3009         d.detach();
3010         d->m_msecs = msecs;
3011         d->m_status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
3012         d->m_status |= newStatus;
3013     }
3014 }
3015 
3016 static QPair<QDate, QTime> getDateTime(const QDateTimeData &d)
3017 {
3018     QPair<QDate, QTime> result;
3019     qint64 msecs = getMSecs(d);
3020     auto status = getStatus(d);
3021     msecsToTime(msecs, &result.first, &result.second);
3022 
3023     if (!status.testFlag(QDateTimePrivate::ValidDate))
3024         result.first = QDate();
3025 
3026     if (!status.testFlag(QDateTimePrivate::ValidTime))
3027         result.second = QTime();
3028 
3029     return result;
3030 }
3031 
3032 /*****************************************************************************
3033   QDateTime::Data member functions
3034  *****************************************************************************/
3035 
3036 inline QDateTime::Data::Data() noexcept
3037 {
3038     // default-constructed data has a special exception:
3039     // it can be small even if CanBeSmall == false
3040     // (optimization so we don't allocate memory in the default constructor)
3041     quintptr value = quintptr(mergeSpec(QDateTimePrivate::ShortData, Qt::LocalTime));
3042     d = reinterpret_cast<QDateTimePrivate *>(value);
3043 }
3044 
3045 inline QDateTime::Data::Data(Qt::TimeSpec spec)
3046 {
3047     if (CanBeSmall && Q_LIKELY(specCanBeSmall(spec))) {
3048         d = reinterpret_cast<QDateTimePrivate *>(quintptr(mergeSpec(QDateTimePrivate::ShortData, spec)));
3049     } else {
3050         // the structure is too small, we need to detach
3051         d = new QDateTimePrivate;
3052         d->ref.ref();
3053         d->m_status = mergeSpec({}, spec);
3054     }
3055 }
3056 
3057 inline QDateTime::Data::Data(const Data &other)
3058     : d(other.d)
3059 {
3060     if (!isShort()) {
3061         // check if we could shrink
3062         if (specCanBeSmall(extractSpec(d->m_status)) && msecsCanBeSmall(d->m_msecs)) {
3063             ShortData sd;
3064             sd.msecs = qintptr(d->m_msecs);
3065             sd.status = d->m_status | QDateTimePrivate::ShortData;
3066             data = sd;
3067         } else {
3068             // no, have to keep it big
3069             d->ref.ref();
3070         }
3071     }
3072 }
3073 
3074 inline QDateTime::Data::Data(Data &&other)
3075     : d(other.d)
3076 {
3077     // reset the other to a short state
3078     Data dummy;
3079     Q_ASSERT(dummy.isShort());
3080     other.d = dummy.d;
3081 }
3082 
3083 inline QDateTime::Data &QDateTime::Data::operator=(const Data &other)
3084 {
3085     if (d == other.d)
3086         return *this;
3087 
3088     auto x = d;
3089     d = other.d;
3090     if (!other.isShort()) {
3091         // check if we could shrink
3092         if (specCanBeSmall(extractSpec(other.d->m_status)) && msecsCanBeSmall(other.d->m_msecs)) {
3093             ShortData sd;
3094             sd.msecs = qintptr(other.d->m_msecs);
3095             sd.status = other.d->m_status | QDateTimePrivate::ShortData;
3096             data = sd;
3097         } else {
3098             // no, have to keep it big
3099             other.d->ref.ref();
3100         }
3101     }
3102 
3103     if (!(quintptr(x) & QDateTimePrivate::ShortData) && !x->ref.deref())
3104         delete x;
3105     return *this;
3106 }
3107 
3108 inline QDateTime::Data::~Data()
3109 {
3110     if (!isShort() && !d->ref.deref())
3111         delete d;
3112 }
3113 
3114 inline bool QDateTime::Data::isShort() const
3115 {
3116     bool b = quintptr(d) & QDateTimePrivate::ShortData;
3117 
3118     // sanity check:
3119     Q_ASSERT(b || (d->m_status & QDateTimePrivate::ShortData) == 0);
3120 
3121     // even if CanBeSmall = false, we have short data for a default-constructed
3122     // QDateTime object. But it's unlikely.
3123     if (CanBeSmall)
3124         return Q_LIKELY(b);
3125     return Q_UNLIKELY(b);
3126 }
3127 
3128 inline void QDateTime::Data::detach()
3129 {
3130     QDateTimePrivate *x;
3131     bool wasShort = isShort();
3132     if (wasShort) {
3133         // force enlarging
3134         x = new QDateTimePrivate;
3135         x->m_status = QDateTimePrivate::StatusFlag(data.status & ~QDateTimePrivate::ShortData);
3136         x->m_msecs = data.msecs;
3137     } else {
3138         if (d->ref.loadRelaxed() == 1)
3139             return;
3140 
3141         x = new QDateTimePrivate(*d);
3142     }
3143 
3144     x->ref.storeRelaxed(1);
3145     if (!wasShort && !d->ref.deref())
3146         delete d;
3147     d = x;
3148 }
3149 
3150 inline const QDateTimePrivate *QDateTime::Data::operator->() const
3151 {
3152     Q_ASSERT(!isShort());
3153     return d;
3154 }
3155 
3156 inline QDateTimePrivate *QDateTime::Data::operator->()
3157 {
3158     // should we attempt to detach here?
3159     Q_ASSERT(!isShort());
3160     Q_ASSERT(d->ref.loadRelaxed() == 1);
3161     return d;
3162 }
3163 
3164 /*****************************************************************************
3165   QDateTimePrivate member functions
3166  *****************************************************************************/
3167 
3168 Q_NEVER_INLINE
3169 QDateTime::Data QDateTimePrivate::create(QDate toDate, QTime toTime, Qt::TimeSpec toSpec,
3170                                          int offsetSeconds)
3171 {
3172     QDateTime::Data result(toSpec);
3173     setTimeSpec(result, toSpec, offsetSeconds);
3174     setDateTime(result, toDate, toTime);
3175     if (toSpec == Qt::OffsetFromUTC || toSpec == Qt::UTC)
3176         refreshSimpleDateTime(result);
3177     else
3178         refreshZonedDateTime(result, Qt::LocalTime);
3179     return result;
3180 }
3181 
3182 #if QT_CONFIG(timezone)
3183 inline QDateTime::Data QDateTimePrivate::create(QDate toDate, QTime toTime,
3184                                                 const QTimeZone &toTimeZone)
3185 {
3186     QDateTime::Data result(Qt::TimeZone);
3187     Q_ASSERT(!result.isShort());
3188 
3189     result.d->m_status = mergeSpec(result.d->m_status, Qt::TimeZone);
3190     result.d->m_timeZone = toTimeZone;
3191     setDateTime(result, toDate, toTime);
3192     refreshZonedDateTime(result, Qt::TimeZone);
3193     return result;
3194 }
3195 
3196 // Convert a TimeZone time expressed in zone msecs encoding into a UTC epoch msecs
3197 // DST transitions are disambiguated by hint.
3198 inline qint64 QDateTimePrivate::zoneMSecsToEpochMSecs(qint64 zoneMSecs, const QTimeZone &zone,
3199                                                       DaylightStatus hint,
3200                                                       QDate *zoneDate, QTime *zoneTime)
3201 {
3202     Q_ASSERT(zone.isValid());
3203     // Get the effective data from QTimeZone
3204     QTimeZonePrivate::Data data = zone.d->dataForLocalTime(zoneMSecs, int(hint));
3205     Q_ASSERT(zone.d->offsetFromUtc(data.atMSecsSinceEpoch) == data.offsetFromUtc);
3206     Q_ASSERT((zoneMSecs - data.atMSecsSinceEpoch) / 1000 == data.offsetFromUtc
3207              // If zoneMSecs fell in a spring-forward's gap, we get this instead:
3208              || (zoneMSecs - data.atMSecsSinceEpoch) / 1000 == data.standardTimeOffset
3209              // If we have a second DST, like in Europe/Berlin 1947 (mid-summer time).
3210              // If zoneMSecs fell in a gap at beginning of mid-summer time, we get this instead:
3211              || (zoneMSecs - data.atMSecsSinceEpoch) / 1000 == 2 * data.standardTimeOffset
3212              // If it fell in a skipped day (Pacific date-line crossings), this happens:
3213              || (data.offsetFromUtc - (zoneMSecs - data.atMSecsSinceEpoch) / 1000) % 86400 == 0);
3214     // Docs state any time before 1970-01-01 will *not* have any DST applied
3215     // but all affected times afterwards will have DST applied.
3216     if (data.atMSecsSinceEpoch < 0) {
3217         msecsToTime(zoneMSecs, zoneDate, zoneTime);
3218         return zoneMSecs - data.standardTimeOffset * MSECS_PER_SEC;
3219     } else {
3220         msecsToTime(data.atMSecsSinceEpoch + data.offsetFromUtc * MSECS_PER_SEC,
3221                     zoneDate, zoneTime);
3222         return data.atMSecsSinceEpoch;
3223     }
3224 }
3225 #endif // timezone
3226 
3227 /*****************************************************************************
3228   QDateTime member functions
3229  *****************************************************************************/
3230 
3231 /*!
3232     \class QDateTime
3233     \inmodule QtCore
3234     \ingroup shared
3235     \reentrant
3236     \brief The QDateTime class provides date and time functions.
3237 
3238 
3239     A QDateTime object encodes a calendar date and a clock time (a
3240     "datetime"). It combines features of the QDate and QTime classes.
3241     It can read the current datetime from the system clock. It
3242     provides functions for comparing datetimes and for manipulating a
3243     datetime by adding a number of seconds, days, months, or years.
3244 
3245     QDateTime can describe datetimes with respect to \l{Qt::LocalTime}{local
3246     time}, to \l{Qt::UTC}{UTC}, to a specified \l{Qt::OffsetFromUTC}{offset from
3247     UTC} or to a specified \l{Qt::TimeZone}{time zone}, in conjunction with the
3248     QTimeZone class. For example, a time zone of "Europe/Berlin" will apply the
3249     daylight-saving rules as used in Germany since 1970. In contrast, an offset
3250     from UTC of +3600 seconds is one hour ahead of UTC (usually written in ISO
3251     standard notation as "UTC+01:00"), with no daylight-saving offset or
3252     changes. When using either local time or a specified time zone, time-zone
3253     transitions such as the starts and ends of daylight-saving time (DST; but
3254     see below) are taken into account. The choice of system used to represent a
3255     datetime is described as its "timespec".
3256 
3257     A QDateTime object is typically created either by giving a date and time
3258     explicitly in the constructor, or by using a static function such as
3259     currentDateTime() or fromMSecsSinceEpoch(). The date and time can be changed
3260     with setDate() and setTime(). A datetime can also be set using the
3261     setMSecsSinceEpoch() function that takes the time, in milliseconds, since
3262     00:00:00 on January 1, 1970. The fromString() function returns a QDateTime,
3263     given a string and a date format used to interpret the date within the
3264     string.
3265 
3266     QDateTime::currentDateTime() returns a QDateTime that expresses the current
3267     time with respect to local time. QDateTime::currentDateTimeUtc() returns a
3268     QDateTime that expresses the current time with respect to UTC.
3269 
3270     The date() and time() functions provide access to the date and
3271     time parts of the datetime. The same information is provided in
3272     textual format by the toString() function.
3273 
3274     QDateTime provides a full set of operators to compare two
3275     QDateTime objects, where smaller means earlier and larger means
3276     later.
3277 
3278     You can increment (or decrement) a datetime by a given number of
3279     milliseconds using addMSecs(), seconds using addSecs(), or days using
3280     addDays(). Similarly, you can use addMonths() and addYears(). The daysTo()
3281     function returns the number of days between two datetimes, secsTo() returns
3282     the number of seconds between two datetimes, and msecsTo() returns the
3283     number of milliseconds between two datetimes. These operations are aware of
3284     daylight-saving time (DST) and other time-zone transitions, where
3285     applicable.
3286 
3287     Use toTimeSpec() to express a datetime in local time or UTC,
3288     toOffsetFromUtc() to express in terms of an offset from UTC, or toTimeZone()
3289     to express it with respect to a general time zone. You can use timeSpec() to
3290     find out what time-spec a QDateTime object stores its time relative to. When
3291     that is Qt::TimeZone, you can use timeZone() to find out which zone it is
3292     using.
3293 
3294     \note QDateTime does not account for leap seconds.
3295 
3296     \section1 Remarks
3297 
3298     \note All conversion to and from string formats is done using the C locale.
3299     For localized conversions, see QLocale.
3300 
3301     \note There is no year 0 in the Gregorian calendar. Dates in that year are
3302     considered invalid. The year -1 is the year "1 before Christ" or "1 before
3303     common era." The day before 1 January 1 CE is 31 December 1 BCE.
3304 
3305     \section2 Range of Valid Dates
3306 
3307     The range of values that QDateTime can represent is dependent on the
3308     internal storage implementation. QDateTime is currently stored in a qint64
3309     as a serial msecs value encoding the date and time. This restricts the date
3310     range to about +/- 292 million years, compared to the QDate range of +/- 2
3311     billion years. Care must be taken when creating a QDateTime with extreme
3312     values that you do not overflow the storage. The exact range of supported
3313     values varies depending on the Qt::TimeSpec and time zone.
3314 
3315     \section2 Use of Timezones
3316 
3317     QDateTime uses the system's time zone information to determine the current
3318     local time zone and its offset from UTC. If the system is not configured
3319     correctly or not up-to-date, QDateTime will give wrong results.
3320 
3321     QDateTime likewise uses system-provided information to determine the offsets
3322     of other timezones from UTC. If this information is incomplete or out of
3323     date, QDateTime will give wrong results. See the QTimeZone documentation for
3324     more details.
3325 
3326     On modern Unix systems, this means QDateTime usually has accurate
3327     information about historical transitions (including DST, see below) whenever
3328     possible. On Windows, where the system doesn't support historical timezone
3329     data, historical accuracy is not maintained with respect to timezone
3330     transitions, notably including DST.
3331 
3332     \section2 Daylight-Saving Time (DST)
3333 
3334     QDateTime takes into account transitions between Standard Time and
3335     Daylight-Saving Time. For example, if the transition is at 2am and the clock
3336     goes forward to 3am, then there is a "missing" hour from 02:00:00 to
3337     02:59:59.999 which QDateTime considers to be invalid. Any date arithmetic
3338     performed will take this missing hour into account and return a valid
3339     result. For example, adding one minute to 01:59:59 will get 03:00:00.
3340 
3341     The range of valid dates taking DST into account is 1970-01-01 to the
3342     present, and rules are in place for handling DST correctly until 2037-12-31,
3343     but these could change. For dates after 2037, QDateTime makes a \e{best
3344     guess} using the rules for year 2037, but we can't guarantee accuracy;
3345     indeed, for \e{any} future date, the time-zone may change its rules before
3346     that date comes around. For dates before 1970, QDateTime doesn't take DST
3347     changes into account, even if the system's time zone database provides that
3348     information, although it does take into account changes to the time-zone's
3349     standard offset, where this information is available.
3350 
3351     \section2 Offsets From UTC
3352 
3353     There is no explicit size restriction on an offset from UTC, but there is an
3354     implicit limit imposed when using the toString() and fromString() methods
3355     which use a [+|-]hh:mm format, effectively limiting the range to +/- 99
3356     hours and 59 minutes and whole minutes only. Note that currently no time
3357     zone lies outside the range of +/- 14 hours.
3358 
3359     \sa QDate, QTime, QDateTimeEdit, QTimeZone
3360 */
3361 
3362 /*!
3363     \since 5.14
3364     \enum QDateTime::YearRange
3365 
3366     This enumerated type describes the range of years (in the Gregorian
3367     calendar) representable by QDateTime:
3368 
3369     \value First The later parts of this year are representable
3370     \value Last The earlier parts of this year are representable
3371 
3372     All dates strictly between these two years are also representable.
3373     Note, however, that the Gregorian Calendar has no year zero.
3374 
3375     \note QDate can describe dates in a wider range of years.  For most
3376     purposes, this makes little difference, as the range of years that QDateTime
3377     can support reaches 292 million years either side of 1970.
3378 
3379     \sa isValid(), QDate
3380 */
3381 
3382 /*!
3383     Constructs a null datetime.
3384 
3385     A null datetime is invalid, since its date and time are invalid.
3386 
3387     \sa isValid()
3388 */
3389 QDateTime::QDateTime() noexcept
3390 {
3391 }
3392 
3393 /*!
3394     Constructs a datetime with the given \a date and \a time, using
3395     the time specification defined by \a spec and \a offsetSeconds seconds.
3396 
3397     If \a date is valid and \a time is not, the time will be set to midnight.
3398 
3399     If the \a spec is not Qt::OffsetFromUTC then \a offsetSeconds will be ignored.
3400 
3401     If the \a spec is Qt::OffsetFromUTC and \a offsetSeconds is 0 then the
3402     timeSpec() will be set to Qt::UTC, i.e. an offset of 0 seconds.
3403 
3404     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3405     i.e. the current system time zone.  To create a Qt::TimeZone datetime
3406     use the correct constructor.
3407 */
3408 
3409 QDateTime::QDateTime(QDate date, QTime time, Qt::TimeSpec spec, int offsetSeconds)
3410          : d(QDateTimePrivate::create(date, time, spec, offsetSeconds))
3411 {
3412 }
3413 
3414 #if QT_CONFIG(timezone)
3415 /*!
3416     \since 5.2
3417 
3418     Constructs a datetime with the given \a date and \a time, using
3419     the Time Zone specified by \a timeZone.
3420 
3421     If \a date is valid and \a time is not, the time will be set to 00:00:00.
3422 
3423     If \a timeZone is invalid then the datetime will be invalid.
3424 */
3425 
3426 QDateTime::QDateTime(QDate date, QTime time, const QTimeZone &timeZone)
3427     : d(QDateTimePrivate::create(date, time, timeZone))
3428 {
3429 }
3430 #endif // timezone
3431 
3432 /*!
3433     Constructs a copy of the \a other datetime.
3434 */
3435 QDateTime::QDateTime(const QDateTime &other) noexcept
3436     : d(other.d)
3437 {
3438 }
3439 
3440 /*!
3441     \since 5.8
3442     Moves the content of the temporary \a other datetime to this object and
3443     leaves \a other in an unspecified (but proper) state.
3444 */
3445 QDateTime::QDateTime(QDateTime &&other) noexcept
3446     : d(std::move(other.d))
3447 {
3448 }
3449 
3450 /*!
3451     Destroys the datetime.
3452 */
3453 QDateTime::~QDateTime()
3454 {
3455 }
3456 
3457 /*!
3458     Makes a copy of the \a other datetime and returns a reference to the
3459     copy.
3460 */
3461 
3462 QDateTime &QDateTime::operator=(const QDateTime &other) noexcept
3463 {
3464     d = other.d;
3465     return *this;
3466 }
3467 /*!
3468     \fn void QDateTime::swap(QDateTime &other)
3469     \since 5.0
3470 
3471     Swaps this datetime with \a other. This operation is very fast
3472     and never fails.
3473 */
3474 
3475 /*!
3476     Returns \c true if both the date and the time are null; otherwise
3477     returns \c false. A null datetime is invalid.
3478 
3479     \sa QDate::isNull(), QTime::isNull(), isValid()
3480 */
3481 
3482 bool QDateTime::isNull() const
3483 {
3484     auto status = getStatus(d);
3485     return !status.testFlag(QDateTimePrivate::ValidDate) &&
3486             !status.testFlag(QDateTimePrivate::ValidTime);
3487 }
3488 
3489 /*!
3490     Returns \c true if both the date and the time are valid and they are valid in
3491     the current Qt::TimeSpec, otherwise returns \c false.
3492 
3493     If the timeSpec() is Qt::LocalTime or Qt::TimeZone then the date and time are
3494     checked to see if they fall in the Standard Time to Daylight-Saving Time transition
3495     hour, i.e. if the transition is at 2am and the clock goes forward to 3am
3496     then the time from 02:00:00 to 02:59:59.999 is considered to be invalid.
3497 
3498     \sa QDateTime::YearRange, QDate::isValid(), QTime::isValid()
3499 */
3500 
3501 bool QDateTime::isValid() const
3502 {
3503     auto status = getStatus(d);
3504     return status & QDateTimePrivate::ValidDateTime;
3505 }
3506 
3507 /*!
3508     Returns the date part of the datetime.
3509 
3510     \sa setDate(), time(), timeSpec()
3511 */
3512 
3513 QDate QDateTime::date() const
3514 {
3515     auto status = getStatus(d);
3516     if (!status.testFlag(QDateTimePrivate::ValidDate))
3517         return QDate();
3518     QDate dt;
3519     msecsToTime(getMSecs(d), &dt, nullptr);
3520     return dt;
3521 }
3522 
3523 /*!
3524     Returns the time part of the datetime.
3525 
3526     \sa setTime(), date(), timeSpec()
3527 */
3528 
3529 QTime QDateTime::time() const
3530 {
3531     auto status = getStatus(d);
3532     if (!status.testFlag(QDateTimePrivate::ValidTime))
3533         return QTime();
3534     QTime tm;
3535     msecsToTime(getMSecs(d), nullptr, &tm);
3536     return tm;
3537 }
3538 
3539 /*!
3540     Returns the time specification of the datetime.
3541 
3542     \sa setTimeSpec(), date(), time(), Qt::TimeSpec
3543 */
3544 
3545 Qt::TimeSpec QDateTime::timeSpec() const
3546 {
3547     return getSpec(d);
3548 }
3549 
3550 #if QT_CONFIG(timezone)
3551 /*!
3552     \since 5.2
3553 
3554     Returns the time zone of the datetime.
3555 
3556     If the timeSpec() is Qt::LocalTime then an instance of the current system
3557     time zone will be returned. Note however that if you copy this time zone
3558     the instance will not remain in sync if the system time zone changes.
3559 
3560     \sa setTimeZone(), Qt::TimeSpec
3561 */
3562 
3563 QTimeZone QDateTime::timeZone() const
3564 {
3565     switch (getSpec(d)) {
3566     case Qt::UTC:
3567         return QTimeZone::utc();
3568     case Qt::OffsetFromUTC:
3569         return QTimeZone(d->m_offsetFromUtc);
3570     case Qt::TimeZone:
3571         if (d->m_timeZone.isValid())
3572             return d->m_timeZone;
3573         break;
3574     case Qt::LocalTime:
3575         return QTimeZone::systemTimeZone();
3576     }
3577     return QTimeZone();
3578 }
3579 #endif // timezone
3580 
3581 /*!
3582     \since 5.2
3583 
3584     Returns this date-time's Offset From UTC in seconds.
3585 
3586     The result depends on timeSpec():
3587     \list
3588     \li \c Qt::UTC The offset is 0.
3589     \li \c Qt::OffsetFromUTC The offset is the value originally set.
3590     \li \c Qt::LocalTime The local time's offset from UTC is returned.
3591     \li \c Qt::TimeZone The offset used by the time-zone is returned.
3592     \endlist
3593 
3594     For the last two, the offset at this date and time will be returned, taking
3595     account of Daylight-Saving Offset unless the date precedes the start of
3596     1970. The offset is the difference between the local time or time in the
3597     given time-zone and UTC time; it is positive in time-zones ahead of UTC
3598     (East of The Prime Meridian), negative for those behind UTC (West of The
3599     Prime Meridian).
3600 
3601     \sa setOffsetFromUtc()
3602 */
3603 
3604 int QDateTime::offsetFromUtc() const
3605 {
3606     if (!d.isShort())
3607         return d->m_offsetFromUtc;
3608     if (!isValid())
3609         return 0;
3610 
3611     auto spec = getSpec(d);
3612     if (spec == Qt::LocalTime) {
3613         // we didn't cache the value, so we need to calculate it now...
3614         qint64 msecs = getMSecs(d);
3615         return (msecs - toMSecsSinceEpoch()) / MSECS_PER_SEC;
3616     }
3617 
3618     Q_ASSERT(spec == Qt::UTC);
3619     return 0;
3620 }
3621 
3622 /*!
3623     \since 5.2
3624 
3625     Returns the Time Zone Abbreviation for this datetime.
3626 
3627     The returned string depends on timeSpec():
3628 
3629     \list
3630     \li For Qt::UTC it is "UTC".
3631     \li For Qt::OffsetFromUTC it will be in the format "UTC[+-]00:00".
3632     \li For Qt::LocalTime, the host system is queried.
3633     \li For Qt::TimeZone, the associated QTimeZone object is queried.
3634     \endlist
3635 
3636     \note The abbreviation is not guaranteed to be unique, i.e. different time
3637     zones may have the same abbreviation. For Qt::LocalTime and Qt::TimeZone,
3638     when returned by the host system, the abbreviation may be localized.
3639 
3640     \sa timeSpec(), QTimeZone::abbreviation()
3641 */
3642 
3643 QString QDateTime::timeZoneAbbreviation() const
3644 {
3645     if (!isValid())
3646         return QString();
3647 
3648     switch (getSpec(d)) {
3649     case Qt::UTC:
3650         return QLatin1String("UTC");
3651     case Qt::OffsetFromUTC:
3652         return QLatin1String("UTC") + toOffsetString(Qt::ISODate, d->m_offsetFromUtc);
3653     case Qt::TimeZone:
3654 #if !QT_CONFIG(timezone)
3655         break;
3656 #else
3657         Q_ASSERT(d->m_timeZone.isValid());
3658         return d->m_timeZone.abbreviation(*this);
3659 #endif // timezone
3660     case Qt::LocalTime:  {
3661         QString abbrev;
3662         auto status = extractDaylightStatus(getStatus(d));
3663         localMSecsToEpochMSecs(getMSecs(d), &status, nullptr, nullptr, &abbrev);
3664         return abbrev;
3665         }
3666     }
3667     return QString();
3668 }
3669 
3670 /*!
3671     \since 5.2
3672 
3673     Returns if this datetime falls in Daylight-Saving Time.
3674 
3675     If the Qt::TimeSpec is not Qt::LocalTime or Qt::TimeZone then will always
3676     return false.
3677 
3678     \sa timeSpec()
3679 */
3680 
3681 bool QDateTime::isDaylightTime() const
3682 {
3683     if (!isValid())
3684         return false;
3685 
3686     switch (getSpec(d)) {
3687     case Qt::UTC:
3688     case Qt::OffsetFromUTC:
3689         return false;
3690     case Qt::TimeZone:
3691 #if !QT_CONFIG(timezone)
3692         break;
3693 #else
3694         Q_ASSERT(d->m_timeZone.isValid());
3695         return d->m_timeZone.d->isDaylightTime(toMSecsSinceEpoch());
3696 #endif // timezone
3697     case Qt::LocalTime: {
3698         auto status = extractDaylightStatus(getStatus(d));
3699         if (status == QDateTimePrivate::UnknownDaylightTime)
3700             localMSecsToEpochMSecs(getMSecs(d), &status);
3701         return (status == QDateTimePrivate::DaylightTime);
3702         }
3703     }
3704     return false;
3705 }
3706 
3707 /*!
3708     Sets the date part of this datetime to \a date. If no time is set yet, it
3709     is set to midnight. If \a date is invalid, this QDateTime becomes invalid.
3710 
3711     \sa date(), setTime(), setTimeSpec()
3712 */
3713 
3714 void QDateTime::setDate(QDate date)
3715 {
3716     setDateTime(d, date, time());
3717     checkValidDateTime(d);
3718 }
3719 
3720 /*!
3721     Sets the time part of this datetime to \a time. If \a time is not valid,
3722     this function sets it to midnight. Therefore, it's possible to clear any
3723     set time in a QDateTime by setting it to a default QTime:
3724 
3725     \code
3726         QDateTime dt = QDateTime::currentDateTime();
3727         dt.setTime(QTime());
3728     \endcode
3729 
3730     \sa time(), setDate(), setTimeSpec()
3731 */
3732 
3733 void QDateTime::setTime(QTime time)
3734 {
3735     setDateTime(d, date(), time);
3736     checkValidDateTime(d);
3737 }
3738 
3739 /*!
3740     Sets the time specification used in this datetime to \a spec.
3741     The datetime will refer to a different point in time.
3742 
3743     If \a spec is Qt::OffsetFromUTC then the timeSpec() will be set
3744     to Qt::UTC, i.e. an effective offset of 0.
3745 
3746     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3747     i.e. the current system time zone.
3748 
3749     Example:
3750     \snippet code/src_corelib_time_qdatetime.cpp 19
3751 
3752     \sa timeSpec(), setDate(), setTime(), setTimeZone(), Qt::TimeSpec
3753 */
3754 
3755 void QDateTime::setTimeSpec(Qt::TimeSpec spec)
3756 {
3757     QT_PREPEND_NAMESPACE(setTimeSpec(d, spec, 0));
3758     if (spec == Qt::OffsetFromUTC || spec == Qt::UTC)
3759         refreshSimpleDateTime(d);
3760     else
3761         refreshZonedDateTime(d, Qt::LocalTime);
3762 }
3763 
3764 /*!
3765     \since 5.2
3766 
3767     Sets the timeSpec() to Qt::OffsetFromUTC and the offset to \a offsetSeconds.
3768     The datetime will refer to a different point in time.
3769 
3770     The maximum and minimum offset is 14 positive or negative hours.  If
3771     \a offsetSeconds is larger or smaller than that, then the result is
3772     undefined.
3773 
3774     If \a offsetSeconds is 0 then the timeSpec() will be set to Qt::UTC.
3775 
3776     \sa isValid(), offsetFromUtc()
3777 */
3778 
3779 void QDateTime::setOffsetFromUtc(int offsetSeconds)
3780 {
3781     QT_PREPEND_NAMESPACE(setTimeSpec(d, Qt::OffsetFromUTC, offsetSeconds));
3782     refreshSimpleDateTime(d);
3783 }
3784 
3785 #if QT_CONFIG(timezone)
3786 /*!
3787     \since 5.2
3788 
3789     Sets the time zone used in this datetime to \a toZone.
3790     The datetime will refer to a different point in time.
3791 
3792     If \a toZone is invalid then the datetime will be invalid.
3793 
3794     \sa timeZone(), Qt::TimeSpec
3795 */
3796 
3797 void QDateTime::setTimeZone(const QTimeZone &toZone)
3798 {
3799     d.detach();         // always detach
3800     d->m_status = mergeSpec(d->m_status, Qt::TimeZone);
3801     d->m_offsetFromUtc = 0;
3802     d->m_timeZone = toZone;
3803     refreshZonedDateTime(d, Qt::TimeZone);
3804 }
3805 #endif // timezone
3806 
3807 /*!
3808     \since 4.7
3809 
3810     Returns the datetime as the number of milliseconds that have passed
3811     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3812 
3813     On systems that do not support time zones, this function will
3814     behave as if local time were Qt::UTC.
3815 
3816     The behavior for this function is undefined if the datetime stored in
3817     this object is not valid. However, for all valid dates, this function
3818     returns a unique value.
3819 
3820     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3821 */
3822 qint64 QDateTime::toMSecsSinceEpoch() const
3823 {
3824     // Note: QDateTimeParser relies on this producing a useful result, even when
3825     // !isValid(), at least when the invalidity is a time in a fall-back (that
3826     // we'll have adjusted to lie outside it, but marked invalid because it's
3827     // not what was asked for). Other things may be doing similar.
3828     switch (getSpec(d)) {
3829     case Qt::UTC:
3830         return getMSecs(d);
3831 
3832     case Qt::OffsetFromUTC:
3833         Q_ASSERT(!d.isShort());
3834         return d->m_msecs - d->m_offsetFromUtc * MSECS_PER_SEC;
3835 
3836     case Qt::LocalTime: {
3837         // recalculate the local timezone
3838         auto status = extractDaylightStatus(getStatus(d));
3839         // If short, use offset saved by refreshZonedDateTime() on creation:
3840         if (!d.isShort())
3841             return d->m_msecs - d->m_offsetFromUtc * MSECS_PER_SEC;
3842         // Offset from UTC not recorded: need to recompute.
3843         return localMSecsToEpochMSecs(getMSecs(d), &status);
3844     }
3845 
3846     case Qt::TimeZone:
3847         Q_ASSERT(!d.isShort());
3848 #if QT_CONFIG(timezone)
3849         // Use offset refreshZonedDateTime() saved on creation:
3850         if (d->m_timeZone.isValid())
3851             return d->m_msecs - d->m_offsetFromUtc * MSECS_PER_SEC;
3852 #endif
3853         return 0;
3854     }
3855     Q_UNREACHABLE();
3856     return 0;
3857 }
3858 
3859 /*!
3860     \since 5.8
3861 
3862     Returns the datetime as the number of seconds that have passed since
3863     1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3864 
3865     On systems that do not support time zones, this function will
3866     behave as if local time were Qt::UTC.
3867 
3868     The behavior for this function is undefined if the datetime stored in
3869     this object is not valid. However, for all valid dates, this function
3870     returns a unique value.
3871 
3872     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3873 */
3874 qint64 QDateTime::toSecsSinceEpoch() const
3875 {
3876     return toMSecsSinceEpoch() / MSECS_PER_SEC;
3877 }
3878 
3879 /*!
3880     \since 4.7
3881 
3882     Sets the date and time given the number of milliseconds \a msecs that have
3883     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3884     (Qt::UTC). On systems that do not support time zones this function
3885     will behave as if local time were Qt::UTC.
3886 
3887     Note that passing the minimum of \c qint64
3888     (\c{std::numeric_limits<qint64>::min()}) to \a msecs will result in
3889     undefined behavior.
3890 
3891     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3892 */
3893 void QDateTime::setMSecsSinceEpoch(qint64 msecs)
3894 {
3895     auto status = getStatus(d);
3896     const auto spec = extractSpec(status);
3897 
3898     status &= ~QDateTimePrivate::ValidityMask;
3899     switch (spec) {
3900     case Qt::UTC:
3901         status |= QDateTimePrivate::ValidWhenMask;
3902         break;
3903     case Qt::OffsetFromUTC:
3904         msecs += d->m_offsetFromUtc * MSECS_PER_SEC;
3905         status |= QDateTimePrivate::ValidWhenMask;
3906         break;
3907     case Qt::TimeZone:
3908         Q_ASSERT(!d.isShort());
3909 #if QT_CONFIG(timezone)
3910         d.detach();
3911         if (!d->m_timeZone.isValid())
3912             break;
3913         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
3914         // but all affected times afterwards will have DST applied.
3915         if (msecs >= 0) {
3916             status = mergeDaylightStatus(status,
3917                                          d->m_timeZone.d->isDaylightTime(msecs)
3918                                          ? QDateTimePrivate::DaylightTime
3919                                          : QDateTimePrivate::StandardTime);
3920             d->m_offsetFromUtc = d->m_timeZone.d->offsetFromUtc(msecs);
3921         } else {
3922             status = mergeDaylightStatus(status, QDateTimePrivate::StandardTime);
3923             d->m_offsetFromUtc = d->m_timeZone.d->standardTimeOffset(msecs);
3924         }
3925         if (!add_overflow(msecs, d->m_offsetFromUtc * MSECS_PER_SEC, &msecs))
3926             status |= QDateTimePrivate::ValidWhenMask;
3927 #endif // timezone
3928         break;
3929     case Qt::LocalTime: {
3930         QDate dt;
3931         QTime tm;
3932         QDateTimePrivate::DaylightStatus dstStatus;
3933         epochMSecsToLocalTime(msecs, &dt, &tm, &dstStatus);
3934         setDateTime(d, dt, tm);
3935         refreshZonedDateTime(d, spec); // FIXME: we do this again, below
3936         msecs = getMSecs(d);
3937         status = mergeDaylightStatus(getStatus(d), dstStatus);
3938         break;
3939         }
3940     }
3941 
3942     if (msecsCanBeSmall(msecs) && d.isShort()) {
3943         // we can keep short
3944         d.data.msecs = qintptr(msecs);
3945         d.data.status = status;
3946     } else {
3947         d.detach();
3948         d->m_status = status & ~QDateTimePrivate::ShortData;
3949         d->m_msecs = msecs;
3950     }
3951 
3952     if (spec == Qt::LocalTime || spec == Qt::TimeZone) {
3953         refreshZonedDateTime(d, spec);
3954         Q_ASSERT((d.isShort() ? d.data.msecs : d->m_msecs) == msecs);
3955     }
3956 }
3957 
3958 /*!
3959     \since 5.8
3960 
3961     Sets the date and time given the number of seconds \a secs that have
3962     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3963     (Qt::UTC). On systems that do not support time zones this function
3964     will behave as if local time were Qt::UTC.
3965 
3966     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3967 */
3968 void QDateTime::setSecsSinceEpoch(qint64 secs)
3969 {
3970     qint64 msecs;
3971     if (!mul_overflow(secs, std::integral_constant<qint64, MSECS_PER_SEC>(), &msecs)) {
3972         setMSecsSinceEpoch(msecs);
3973     } else if (d.isShort()) {
3974         d.data.status &= ~QDateTimePrivate::ValidWhenMask;
3975     } else {
3976         d.detach();
3977         d->m_status &= ~QDateTimePrivate::ValidWhenMask;
3978     }
3979 }
3980 
3981 #if QT_CONFIG(datestring) // depends on, so implies, textdate
3982 /*!
3983     \overload
3984 
3985     Returns the datetime as a string in the \a format given.
3986 
3987     If the \a format is Qt::TextDate, the string is formatted in the default
3988     way. The day and month names will be in English. An example of this
3989     formatting is "Wed May 20 03:40:13 1998". For localized formatting, see
3990     \l{QLocale::toString()}.
3991 
3992     If the \a format is Qt::ISODate, the string format corresponds
3993     to the ISO 8601 extended specification for representations of
3994     dates and times, taking the form yyyy-MM-ddTHH:mm:ss[Z|[+|-]HH:mm],
3995     depending on the timeSpec() of the QDateTime. If the timeSpec()
3996     is Qt::UTC, Z will be appended to the string; if the timeSpec() is
3997     Qt::OffsetFromUTC, the offset in hours and minutes from UTC will
3998     be appended to the string. To include milliseconds in the ISO 8601
3999     date, use the \a format Qt::ISODateWithMs, which corresponds to
4000     yyyy-MM-ddTHH:mm:ss.zzz[Z|[+|-]HH:mm].
4001 
4002     If the \a format is Qt::RFC2822Date, the string is formatted
4003     following \l{RFC 2822}.
4004 
4005     If the datetime is invalid, an empty string will be returned.
4006 
4007     \warning The Qt::ISODate format is only valid for years in the
4008     range 0 to 9999.
4009 
4010     \sa fromString(), QDate::toString(), QTime::toString(),
4011     QLocale::toString()
4012 */
4013 QString QDateTime::toString(Qt::DateFormat format) const
4014 {
4015     QString buf;
4016     if (!isValid())
4017         return buf;
4018 
4019     switch (format) {
4020     case Qt::RFC2822Date:
4021         buf = QLocale::c().toString(*this, u"dd MMM yyyy hh:mm:ss ");
4022         buf += toOffsetString(Qt::TextDate, offsetFromUtc());
4023         return buf;
4024     default:
4025     case Qt::TextDate: {
4026         const QPair<QDate, QTime> p = getDateTime(d);
4027         buf = toStringTextDate(p.first);
4028         // Insert time between date's day and year:
4029         buf.insert(buf.lastIndexOf(u' '),
4030                    u' ' + p.second.toString(Qt::TextDate));
4031         // Append zone/offset indicator, as appropriate:
4032         switch (timeSpec()) {
4033         case Qt::LocalTime:
4034             break;
4035 #if QT_CONFIG(timezone)
4036         case Qt::TimeZone:
4037             buf += u' ' + d->m_timeZone.displayName(
4038                 *this, QTimeZone::OffsetName, QLocale::c());
4039             break;
4040 #endif
4041         default:
4042 #if 0 // ### Qt 7 GMT: use UTC instead, see qnamespace.qdoc documentation
4043             buf += QLatin1String(" UTC");
4044 #else
4045             buf += QLatin1String(" GMT");
4046 #endif
4047             if (getSpec(d) == Qt::OffsetFromUTC)
4048                 buf += toOffsetString(Qt::TextDate, offsetFromUtc());
4049         }
4050         return buf;
4051     }
4052     case Qt::ISODate:
4053     case Qt::ISODateWithMs: {
4054         const QPair<QDate, QTime> p = getDateTime(d);
4055         buf = toStringIsoDate(p.first);
4056         if (buf.isEmpty())
4057             return QString();   // failed to convert
4058         buf += u'T' + p.second.toString(format);
4059         switch (getSpec(d)) {
4060         case Qt::UTC:
4061             buf += u'Z';
4062             break;
4063         case Qt::OffsetFromUTC:
4064 #if QT_CONFIG(timezone)
4065         case Qt::TimeZone:
4066 #endif
4067             buf += toOffsetString(Qt::ISODate, offsetFromUtc());
4068             break;
4069         default:
4070             break;
4071         }
4072         return buf;
4073     }
4074     }
4075 }
4076 
4077 /*!
4078     \fn QString QDateTime::toString(const QString &format, QCalendar cal) const
4079     \fn QString QDateTime::toString(QStringView format, QCalendar cal) const
4080 
4081     Returns the datetime as a string. The \a format parameter determines the
4082     format of the result string. If \a cal is supplied, it determines the calendar
4083     used to represent the date; it defaults to Gregorian. See QTime::toString()
4084     and QDate::toString() for the supported specifiers for time and date,
4085     respectively.
4086 
4087     Any sequence of characters enclosed in single quotes will be included
4088     verbatim in the output string (stripped of the quotes), even if it contains
4089     formatting characters. Two consecutive single quotes ("''") are replaced by
4090     a single quote in the output. All other characters in the format string are
4091     included verbatim in the output string.
4092 
4093     Formats without separators (e.g. "ddMM") are supported but must be used with
4094     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
4095     produces "212" it could mean either the 2nd of December or the 21st of
4096     February).
4097 
4098     Example format strings (assumed that the QDateTime is 21 May 2001
4099     14:13:09.120):
4100 
4101     \table
4102     \header \li Format       \li Result
4103     \row \li dd.MM.yyyy      \li 21.05.2001
4104     \row \li ddd MMMM d yy   \li Tue May 21 01
4105     \row \li hh:mm:ss.zzz    \li 14:13:09.120
4106     \row \li hh:mm:ss.z      \li 14:13:09.12
4107     \row \li h:m:s ap        \li 2:13:9 pm
4108     \endtable
4109 
4110     If the datetime is invalid, an empty string will be returned.
4111 
4112     \note Day and month names as well as AM/PM indication are given in English (C locale).
4113     If localized month and day names and localized forms of AM/PM are used, use
4114     QLocale::system().toDateTime().
4115 
4116     \sa fromString(), QDate::toString(), QTime::toString(), QLocale::toString()
4117 */
4118 QString QDateTime::toString(QStringView format, QCalendar cal) const
4119 {
4120     return QLocale::c().toString(*this, format, cal);
4121 }
4122 #endif // datestring
4123 
4124 static inline void massageAdjustedDateTime(QDateTimeData &d, QDate date, QTime time)
4125 {
4126     /*
4127       If we have just adjusted to a day with a DST transition, our given time
4128       may lie in the transition hour (either missing or duplicated).  For any
4129       other time, telling mktime (deep in the bowels of localMSecsToEpochMSecs)
4130       we don't know its DST-ness will produce no adjustment (just a decision as
4131       to its DST-ness); but for a time in spring's missing hour it'll adjust the
4132       time while picking a DST-ness.  (Handling of autumn is trickier, as either
4133       DST-ness is valid, without adjusting the time.  We might want to propagate
4134       the daylight status in that case, but it's hard to do so without breaking
4135       (far more common) other cases; and it makes little difference, as the two
4136       answers do then differ only in DST-ness.)
4137     */
4138     auto spec = getSpec(d);
4139     if (spec == Qt::LocalTime) {
4140         QDateTimePrivate::DaylightStatus status = QDateTimePrivate::UnknownDaylightTime;
4141         localMSecsToEpochMSecs(timeToMSecs(date, time), &status, &date, &time);
4142 #if QT_CONFIG(timezone)
4143     } else if (spec == Qt::TimeZone && d->m_timeZone.isValid()) {
4144         QDateTimePrivate::zoneMSecsToEpochMSecs(timeToMSecs(date, time),
4145                                                 d->m_timeZone,
4146                                                 QDateTimePrivate::UnknownDaylightTime,
4147                                                 &date, &time);
4148 #endif // timezone
4149     }
4150     setDateTime(d, date, time);
4151     checkValidDateTime(d);
4152 }
4153 
4154 /*!
4155     Returns a QDateTime object containing a datetime \a ndays days
4156     later than the datetime of this object (or earlier if \a ndays is
4157     negative).
4158 
4159     If the timeSpec() is Qt::LocalTime and the resulting
4160     date and time fall in the Standard Time to Daylight-Saving Time transition
4161     hour then the result will be adjusted accordingly, i.e. if the transition
4162     is at 2am and the clock goes forward to 3am and the result falls between
4163     2am and 3am then the result will be adjusted to fall after 3am.
4164 
4165     \sa daysTo(), addMonths(), addYears(), addSecs()
4166 */
4167 
4168 QDateTime QDateTime::addDays(qint64 ndays) const
4169 {
4170     if (isNull())
4171         return QDateTime();
4172 
4173     QDateTime dt(*this);
4174     QPair<QDate, QTime> p = getDateTime(d);
4175     massageAdjustedDateTime(dt.d, p.first.addDays(ndays), p.second);
4176     return dt;
4177 }
4178 
4179 /*!
4180     Returns a QDateTime object containing a datetime \a nmonths months
4181     later than the datetime of this object (or earlier if \a nmonths
4182     is negative).
4183 
4184     If the timeSpec() is Qt::LocalTime and the resulting
4185     date and time fall in the Standard Time to Daylight-Saving Time transition
4186     hour then the result will be adjusted accordingly, i.e. if the transition
4187     is at 2am and the clock goes forward to 3am and the result falls between
4188     2am and 3am then the result will be adjusted to fall after 3am.
4189 
4190     \sa daysTo(), addDays(), addYears(), addSecs()
4191 */
4192 
4193 QDateTime QDateTime::addMonths(int nmonths) const
4194 {
4195     if (isNull())
4196         return QDateTime();
4197 
4198     QDateTime dt(*this);
4199     QPair<QDate, QTime> p = getDateTime(d);
4200     massageAdjustedDateTime(dt.d, p.first.addMonths(nmonths), p.second);
4201     return dt;
4202 }
4203 
4204 /*!
4205     Returns a QDateTime object containing a datetime \a nyears years
4206     later than the datetime of this object (or earlier if \a nyears is
4207     negative).
4208 
4209     If the timeSpec() is Qt::LocalTime and the resulting
4210     date and time fall in the Standard Time to Daylight-Saving Time transition
4211     hour then the result will be adjusted accordingly, i.e. if the transition
4212     is at 2am and the clock goes forward to 3am and the result falls between
4213     2am and 3am then the result will be adjusted to fall after 3am.
4214 
4215     \sa daysTo(), addDays(), addMonths(), addSecs()
4216 */
4217 
4218 QDateTime QDateTime::addYears(int nyears) const
4219 {
4220     if (isNull())
4221         return QDateTime();
4222 
4223     QDateTime dt(*this);
4224     QPair<QDate, QTime> p = getDateTime(d);
4225     massageAdjustedDateTime(dt.d, p.first.addYears(nyears), p.second);
4226     return dt;
4227 }
4228 
4229 /*!
4230     Returns a QDateTime object containing a datetime \a s seconds
4231     later than the datetime of this object (or earlier if \a s is
4232     negative).
4233 
4234     If this datetime is invalid, an invalid datetime will be returned.
4235 
4236     \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears()
4237 */
4238 
4239 QDateTime QDateTime::addSecs(qint64 s) const
4240 {
4241     qint64 msecs;
4242     if (mul_overflow(s, std::integral_constant<qint64, MSECS_PER_SEC>(), &msecs))
4243         return QDateTime();
4244     return addMSecs(msecs);
4245 }
4246 
4247 /*!
4248     Returns a QDateTime object containing a datetime \a msecs miliseconds
4249     later than the datetime of this object (or earlier if \a msecs is
4250     negative).
4251 
4252     If this datetime is invalid, an invalid datetime will be returned.
4253 
4254     \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears()
4255 */
4256 QDateTime QDateTime::addMSecs(qint64 msecs) const
4257 {
4258     if (!isValid())
4259         return QDateTime();
4260 
4261     QDateTime dt(*this);
4262     switch (getSpec(d)) {
4263     case Qt::LocalTime:
4264     case Qt::TimeZone:
4265         // Convert to real UTC first in case this crosses a DST transition:
4266         if (!add_overflow(toMSecsSinceEpoch(), msecs, &msecs)) {
4267             dt.setMSecsSinceEpoch(msecs);
4268         } else if (dt.d.isShort()) {
4269             dt.d.data.status &= ~QDateTimePrivate::ValidWhenMask;
4270         } else {
4271             dt.d.detach();
4272             dt.d->m_status &= ~QDateTimePrivate::ValidWhenMask;
4273         }
4274         break;
4275     case Qt::UTC:
4276     case Qt::OffsetFromUTC:
4277         // No need to convert, just add on
4278         if (add_overflow(getMSecs(d), msecs, &msecs)) {
4279             if (dt.d.isShort()) {
4280                 dt.d.data.status &= ~QDateTimePrivate::ValidWhenMask;
4281             } else {
4282                 dt.d.detach();
4283                 dt.d->m_status &= ~QDateTimePrivate::ValidWhenMask;
4284             }
4285         } else if (d.isShort()) {
4286             // need to check if we need to enlarge first
4287             if (msecsCanBeSmall(msecs)) {
4288                 dt.d.data.msecs = qintptr(msecs);
4289             } else {
4290                 dt.d.detach();
4291                 dt.d->m_msecs = msecs;
4292             }
4293         } else {
4294             dt.d.detach();
4295             dt.d->m_msecs = msecs;
4296         }
4297         break;
4298     }
4299     return dt;
4300 }
4301 
4302 /*!
4303     Returns the number of days from this datetime to the \a other
4304     datetime. The number of days is counted as the number of times
4305     midnight is reached between this datetime to the \a other
4306     datetime. This means that a 10 minute difference from 23:55 to
4307     0:05 the next day counts as one day.
4308 
4309     If the \a other datetime is earlier than this datetime,
4310     the value returned is negative.
4311 
4312     Example:
4313     \snippet code/src_corelib_time_qdatetime.cpp 15
4314 
4315     \sa addDays(), secsTo(), msecsTo()
4316 */
4317 
4318 qint64 QDateTime::daysTo(const QDateTime &other) const
4319 {
4320     return date().daysTo(other.date());
4321 }
4322 
4323 /*!
4324     Returns the number of seconds from this datetime to the \a other
4325     datetime. If the \a other datetime is earlier than this datetime,
4326     the value returned is negative.
4327 
4328     Before performing the comparison, the two datetimes are converted
4329     to Qt::UTC to ensure that the result is correct if daylight-saving
4330     (DST) applies to one of the two datetimes but not the other.
4331 
4332     Returns 0 if either datetime is invalid.
4333 
4334     Example:
4335     \snippet code/src_corelib_time_qdatetime.cpp 11
4336 
4337     \sa addSecs(), daysTo(), QTime::secsTo()
4338 */
4339 
4340 qint64 QDateTime::secsTo(const QDateTime &other) const
4341 {
4342     return msecsTo(other) / MSECS_PER_SEC;
4343 }
4344 
4345 /*!
4346     Returns the number of milliseconds from this datetime to the \a other
4347     datetime. If the \a other datetime is earlier than this datetime,
4348     the value returned is negative.
4349 
4350     Before performing the comparison, the two datetimes are converted
4351     to Qt::UTC to ensure that the result is correct if daylight-saving
4352     (DST) applies to one of the two datetimes and but not the other.
4353 
4354     Returns 0 if either datetime is invalid.
4355 
4356     \sa addMSecs(), daysTo(), QTime::msecsTo()
4357 */
4358 
4359 qint64 QDateTime::msecsTo(const QDateTime &other) const
4360 {
4361     if (!isValid() || !other.isValid())
4362         return 0;
4363 
4364     return other.toMSecsSinceEpoch() - toMSecsSinceEpoch();
4365 }
4366 
4367 /*!
4368     Returns a copy of this datetime converted to the given time
4369     \a spec.
4370 
4371     If \a spec is Qt::OffsetFromUTC then it is set to Qt::UTC.  To set to a
4372     spec of Qt::OffsetFromUTC use toOffsetFromUtc().
4373 
4374     If \a spec is Qt::TimeZone then it is set to Qt::LocalTime,
4375     i.e. the local Time Zone.
4376 
4377     Example:
4378     \snippet code/src_corelib_time_qdatetime.cpp 16
4379 
4380     \sa timeSpec(), toTimeZone(), toOffsetFromUtc()
4381 */
4382 
4383 QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const
4384 {
4385     if (getSpec(d) == spec && (spec == Qt::UTC || spec == Qt::LocalTime))
4386         return *this;
4387 
4388     if (!isValid()) {
4389         QDateTime ret = *this;
4390         ret.setTimeSpec(spec);
4391         return ret;
4392     }
4393 
4394     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), spec, 0);
4395 }
4396 
4397 /*!
4398     \since 5.2
4399 
4400     \fn QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4401 
4402     Returns a copy of this datetime converted to a spec of Qt::OffsetFromUTC
4403     with the given \a offsetSeconds.
4404 
4405     If the \a offsetSeconds equals 0 then a UTC datetime will be returned
4406 
4407     \sa setOffsetFromUtc(), offsetFromUtc(), toTimeSpec()
4408 */
4409 
4410 QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4411 {
4412     if (getSpec(d) == Qt::OffsetFromUTC
4413             && d->m_offsetFromUtc == offsetSeconds)
4414         return *this;
4415 
4416     if (!isValid()) {
4417         QDateTime ret = *this;
4418         ret.setOffsetFromUtc(offsetSeconds);
4419         return ret;
4420     }
4421 
4422     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), Qt::OffsetFromUTC, offsetSeconds);
4423 }
4424 
4425 #if QT_CONFIG(timezone)
4426 /*!
4427     \since 5.2
4428 
4429     Returns a copy of this datetime converted to the given \a timeZone
4430 
4431     \sa timeZone(), toTimeSpec()
4432 */
4433 
4434 QDateTime QDateTime::toTimeZone(const QTimeZone &timeZone) const
4435 {
4436     if (getSpec(d) == Qt::TimeZone && d->m_timeZone == timeZone)
4437         return *this;
4438 
4439     if (!isValid()) {
4440         QDateTime ret = *this;
4441         ret.setTimeZone(timeZone);
4442         return ret;
4443     }
4444 
4445     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), timeZone);
4446 }
4447 #endif // timezone
4448 
4449 /*!
4450     \internal
4451     Returns \c true if this datetime is equal to the \a other datetime;
4452     otherwise returns \c false.
4453 
4454     \sa precedes(), operator==()
4455 */
4456 
4457 bool QDateTime::equals(const QDateTime &other) const
4458 {
4459     if (!isValid())
4460         return !other.isValid();
4461     if (!other.isValid())
4462         return false;
4463 
4464     if (usesSameOffset(d, other.d))
4465         return getMSecs(d) == getMSecs(other.d);
4466 
4467     // Convert to UTC and compare
4468     return toMSecsSinceEpoch() == other.toMSecsSinceEpoch();
4469 }
4470 
4471 /*!
4472     \fn bool QDateTime::operator==(const QDateTime &lhs, const QDateTime &rhs)
4473 
4474     Returns \c true if \a lhs is the same as \a rhs; otherwise returns \c false.
4475 
4476     Two datetimes are different if either the date, the time, or the time zone
4477     components are different. Since 5.14, all invalid datetime are equal (and
4478     less than all valid datetimes).
4479 
4480     \sa operator!=(), operator<(), operator<=(), operator>(), operator>=()
4481 */
4482 
4483 /*!
4484     \fn bool QDateTime::operator!=(const QDateTime &lhs, const QDateTime &rhs)
4485 
4486     Returns \c true if \a lhs is different from \a rhs; otherwise returns \c
4487     false.
4488 
4489     Two datetimes are different if either the date, the time, or the time zone
4490     components are different. Since 5.14, all invalid datetime are equal (and
4491     less than all valid datetimes).
4492 
4493     \sa operator==()
4494 */
4495 
4496 /*!
4497     \internal
4498     Returns \c true if \a lhs is earlier than the \a rhs
4499     datetime; otherwise returns \c false.
4500 
4501     \sa equals(), operator<()
4502 */
4503 
4504 bool QDateTime::precedes(const QDateTime &other) const
4505 {
4506     if (!isValid())
4507         return other.isValid();
4508     if (!other.isValid())
4509         return false;
4510 
4511     if (usesSameOffset(d, other.d))
4512         return getMSecs(d) < getMSecs(other.d);
4513 
4514     // Convert to UTC and compare
4515     return toMSecsSinceEpoch() < other.toMSecsSinceEpoch();
4516 }
4517 
4518 /*!
4519     \fn bool QDateTime::operator<(const QDateTime &lhs, const QDateTime &rhs)
4520 
4521     Returns \c true if \a lhs is earlier than \a rhs;
4522     otherwise returns \c false.
4523 
4524     \sa operator==()
4525 */
4526 
4527 /*!
4528     \fn bool QDateTime::operator<=(const QDateTime &lhs, const QDateTime &rhs)
4529 
4530     Returns \c true if \a lhs is earlier than or equal to \a rhs; otherwise
4531     returns \c false.
4532 
4533     \sa operator==()
4534 */
4535 
4536 /*!
4537     \fn bool QDateTime::operator>(const QDateTime &lhs, const QDateTime &rhs)
4538 
4539     Returns \c true if \a lhs is later than \a rhs; otherwise returns \c false.
4540 
4541     \sa operator==()
4542 */
4543 
4544 /*!
4545     \fn bool QDateTime::operator>=(const QDateTime &lhs, const QDateTime &rhs)
4546 
4547     Returns \c true if \a lhs is later than or equal to \a rhs;
4548     otherwise returns \c false.
4549 
4550     \sa operator==()
4551 */
4552 
4553 /*!
4554     \fn QDateTime QDateTime::currentDateTime()
4555     Returns the current datetime, as reported by the system clock, in
4556     the local time zone.
4557 
4558     \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4559 */
4560 
4561 /*!
4562     \fn QDateTime QDateTime::currentDateTimeUtc()
4563     \since 4.7
4564     Returns the current datetime, as reported by the system clock, in
4565     UTC.
4566 
4567     \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4568 */
4569 
4570 /*!
4571     \fn qint64 QDateTime::currentMSecsSinceEpoch()
4572     \since 4.7
4573 
4574     Returns the number of milliseconds since 1970-01-01T00:00:00 Universal
4575     Coordinated Time. This number is like the POSIX time_t variable, but
4576     expressed in milliseconds instead.
4577 
4578     \sa currentDateTime(), currentDateTimeUtc(), toTimeSpec()
4579 */
4580 
4581 /*!
4582     \fn qint64 QDateTime::currentSecsSinceEpoch()
4583     \since 5.8
4584 
4585     Returns the number of seconds since 1970-01-01T00:00:00 Universal
4586     Coordinated Time.
4587 
4588     \sa currentMSecsSinceEpoch()
4589 */
4590 
4591 #if defined(Q_OS_WIN)
4592 static inline uint msecsFromDecomposed(int hour, int minute, int sec, int msec = 0)
4593 {
4594     return MSECS_PER_HOUR * hour + MSECS_PER_MIN * minute + MSECS_PER_SEC * sec + msec;
4595 }
4596 
4597 QDate QDate::currentDate()
4598 {
4599     SYSTEMTIME st;
4600     memset(&st, 0, sizeof(SYSTEMTIME));
4601     GetLocalTime(&st);
4602     return QDate(st.wYear, st.wMonth, st.wDay);
4603 }
4604 
4605 QTime QTime::currentTime()
4606 {
4607     QTime ct;
4608     SYSTEMTIME st;
4609     memset(&st, 0, sizeof(SYSTEMTIME));
4610     GetLocalTime(&st);
4611     ct.setHMS(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4612     return ct;
4613 }
4614 
4615 QDateTime QDateTime::currentDateTime()
4616 {
4617     QTime t;
4618     SYSTEMTIME st;
4619     memset(&st, 0, sizeof(SYSTEMTIME));
4620     GetLocalTime(&st);
4621     QDate d(st.wYear, st.wMonth, st.wDay);
4622     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4623     return QDateTime(d, t);
4624 }
4625 
4626 QDateTime QDateTime::currentDateTimeUtc()
4627 {
4628     QTime t;
4629     SYSTEMTIME st;
4630     memset(&st, 0, sizeof(SYSTEMTIME));
4631     GetSystemTime(&st);
4632     QDate d(st.wYear, st.wMonth, st.wDay);
4633     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4634     return QDateTime(d, t, Qt::UTC);
4635 }
4636 
4637 qint64 QDateTime::currentMSecsSinceEpoch() noexcept
4638 {
4639     SYSTEMTIME st;
4640     memset(&st, 0, sizeof(SYSTEMTIME));
4641     GetSystemTime(&st);
4642     const qint64 daysAfterEpoch = QDate(1970, 1, 1).daysTo(QDate(st.wYear, st.wMonth, st.wDay));
4643 
4644     return msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds) +
4645            daysAfterEpoch * MSECS_PER_DAY;
4646 }
4647 
4648 qint64 QDateTime::currentSecsSinceEpoch() noexcept
4649 {
4650     SYSTEMTIME st;
4651     memset(&st, 0, sizeof(SYSTEMTIME));
4652     GetSystemTime(&st);
4653     const qint64 daysAfterEpoch = QDate(1970, 1, 1).daysTo(QDate(st.wYear, st.wMonth, st.wDay));
4654 
4655     return st.wHour * SECS_PER_HOUR + st.wMinute * SECS_PER_MIN + st.wSecond +
4656            daysAfterEpoch * SECS_PER_DAY;
4657 }
4658 
4659 #elif defined(Q_OS_UNIX)
4660 QDate QDate::currentDate()
4661 {
4662     return QDateTime::currentDateTime().date();
4663 }
4664 
4665 QTime QTime::currentTime()
4666 {
4667     return QDateTime::currentDateTime().time();
4668 }
4669 
4670 QDateTime QDateTime::currentDateTime()
4671 {
4672     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::LocalTime);
4673 }
4674 
4675 QDateTime QDateTime::currentDateTimeUtc()
4676 {
4677     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::UTC);
4678 }
4679 
4680 qint64 QDateTime::currentMSecsSinceEpoch() noexcept
4681 {
4682     // posix compliant system
4683     // we have milliseconds
4684     struct timeval tv;
4685     gettimeofday(&tv, nullptr);
4686     return tv.tv_sec * MSECS_PER_SEC + tv.tv_usec / 1000;
4687 }
4688 
4689 qint64 QDateTime::currentSecsSinceEpoch() noexcept
4690 {
4691     struct timeval tv;
4692     gettimeofday(&tv, nullptr);
4693     return tv.tv_sec;
4694 }
4695 #else
4696 #error "What system is this?"
4697 #endif
4698 
4699 /*!
4700   Returns a datetime whose date and time are the number of milliseconds \a msecs
4701   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4702   Time (Qt::UTC) and converted to the given \a spec.
4703 
4704   Note that there are possible values for \a msecs that lie outside the valid
4705   range of QDateTime, both negative and positive. The behavior of this
4706   function is undefined for those values.
4707 
4708   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4709   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4710   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4711 
4712   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4713   i.e. the current system time zone.
4714 
4715   \sa toMSecsSinceEpoch(), setMSecsSinceEpoch()
4716 */
4717 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, Qt::TimeSpec spec, int offsetSeconds)
4718 {
4719     QDateTime dt;
4720     QT_PREPEND_NAMESPACE(setTimeSpec(dt.d, spec, offsetSeconds));
4721     dt.setMSecsSinceEpoch(msecs);
4722     return dt;
4723 }
4724 
4725 /*!
4726   \since 5.8
4727 
4728   Returns a datetime whose date and time are the number of seconds \a secs
4729   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4730   Time (Qt::UTC) and converted to the given \a spec.
4731 
4732   Note that there are possible values for \a secs that lie outside the valid
4733   range of QDateTime, both negative and positive. The behavior of this
4734   function is undefined for those values.
4735 
4736   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4737   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4738   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4739 
4740   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4741   i.e. the current system time zone.
4742 
4743   \sa toSecsSinceEpoch(), setSecsSinceEpoch()
4744 */
4745 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, Qt::TimeSpec spec, int offsetSeconds)
4746 {
4747     constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / MSECS_PER_SEC;
4748     constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / MSECS_PER_SEC;
4749     if (secs > maxSeconds || secs < minSeconds)
4750         return QDateTime(); // Would {und,ov}erflow
4751     return fromMSecsSinceEpoch(secs * MSECS_PER_SEC, spec, offsetSeconds);
4752 }
4753 
4754 #if QT_CONFIG(timezone)
4755 /*!
4756     \since 5.2
4757 
4758     Returns a datetime whose date and time are the number of milliseconds \a msecs
4759     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4760     Time (Qt::UTC) and with the given \a timeZone.
4761 
4762     \sa fromSecsSinceEpoch()
4763 */
4764 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, const QTimeZone &timeZone)
4765 {
4766     QDateTime dt;
4767     dt.setTimeZone(timeZone);
4768     if (timeZone.isValid())
4769         dt.setMSecsSinceEpoch(msecs);
4770     return dt;
4771 }
4772 
4773 /*!
4774     \since 5.8
4775 
4776     Returns a datetime whose date and time are the number of seconds \a secs
4777     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4778     Time (Qt::UTC) and with the given \a timeZone.
4779 
4780     \sa fromMSecsSinceEpoch()
4781 */
4782 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, const QTimeZone &timeZone)
4783 {
4784     constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / MSECS_PER_SEC;
4785     constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / MSECS_PER_SEC;
4786     if (secs > maxSeconds || secs < minSeconds)
4787         return QDateTime(); // Would {und,ov}erflow
4788     return fromMSecsSinceEpoch(secs * MSECS_PER_SEC, timeZone);
4789 }
4790 #endif
4791 
4792 #if QT_CONFIG(datestring) // depends on, so implies, textdate
4793 
4794 /*!
4795     \fn QDateTime QDateTime::fromString(const QString &string, Qt::DateFormat format)
4796 
4797     Returns the QDateTime represented by the \a string, using the
4798     \a format given, or an invalid datetime if this is not possible.
4799 
4800     Note for Qt::TextDate: only English short month names (e.g. "Jan" in short
4801     form or "January" in long form) are recognized.
4802 
4803     \sa toString(), QLocale::toDateTime()
4804 */
4805 
4806 /*!
4807     \overload
4808     \since 6.0
4809 */
4810 QDateTime QDateTime::fromString(QStringView string, Qt::DateFormat format)
4811 {
4812     if (string.isEmpty())
4813         return QDateTime();
4814 
4815     switch (format) {
4816     case Qt::RFC2822Date: {
4817         const ParsedRfcDateTime rfc = rfcDateImpl(string);
4818 
4819         if (!rfc.date.isValid() || !rfc.time.isValid())
4820             return QDateTime();
4821 
4822         QDateTime dateTime(rfc.date, rfc.time, Qt::UTC);
4823         dateTime.setOffsetFromUtc(rfc.utcOffset);
4824         return dateTime;
4825     }
4826     case Qt::ISODate:
4827     case Qt::ISODateWithMs: {
4828         const int size = string.size();
4829         if (size < 10)
4830             return QDateTime();
4831 
4832         QDate date = QDate::fromString(string.first(10), Qt::ISODate);
4833         if (!date.isValid())
4834             return QDateTime();
4835         if (size == 10)
4836             return date.startOfDay();
4837 
4838         Qt::TimeSpec spec = Qt::LocalTime;
4839         QStringView isoString = string.sliced(10); // trim "yyyy-MM-dd"
4840 
4841         // Must be left with T (or space) and at least one digit for the hour:
4842         if (isoString.size() < 2
4843             || !(isoString.startsWith(u'T', Qt::CaseInsensitive)
4844                  // RFC 3339 (section 5.6) allows a space here.  (It actually
4845                  // allows any separator one considers more readable, merely
4846                  // giving space as an example - but let's not go wild !)
4847                  || isoString.startsWith(u' '))) {
4848             return QDateTime();
4849         }
4850         isoString = isoString.sliced(1); // trim 'T' (or space)
4851 
4852         int offset = 0;
4853         // Check end of string for Time Zone definition, either Z for UTC or [+-]HH:mm for Offset
4854         if (isoString.endsWith(u'Z', Qt::CaseInsensitive)) {
4855             spec = Qt::UTC;
4856             isoString.chop(1); // trim 'Z'
4857         } else {
4858             // the loop below is faster but functionally equal to:
4859             // const int signIndex = isoString.indexOf(QRegulargExpression(QStringLiteral("[+-]")));
4860             int signIndex = isoString.size() - 1;
4861             Q_ASSERT(signIndex >= 0);
4862             bool found = false;
4863             do {
4864                 QChar character(isoString[signIndex]);
4865                 found = character == u'+' || character == u'-';
4866             } while (!found && --signIndex >= 0);
4867 
4868             if (found) {
4869                 bool ok;
4870                 offset = fromOffsetString(isoString.sliced(signIndex), &ok);
4871                 if (!ok)
4872                     return QDateTime();
4873                 isoString = isoString.first(signIndex);
4874                 spec = Qt::OffsetFromUTC;
4875             }
4876         }
4877 
4878         // Might be end of day (24:00, including variants), which QTime considers invalid.
4879         // ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
4880         bool isMidnight24 = false;
4881         QTime time = fromIsoTimeString(isoString, format, &isMidnight24);
4882         if (!time.isValid())
4883             return QDateTime();
4884         if (isMidnight24) // time is 0:0, but we want the start of next day:
4885             return date.addDays(1).startOfDay(spec, offset);
4886         return QDateTime(date, time, spec, offset);
4887     }
4888     case Qt::TextDate: {
4889         QList<QStringView> parts = string.split(u' ', Qt::SkipEmptyParts);
4890 
4891         // Documented as "ddd MMM d HH:mm:ss yyyy" with optional offset-suffix;
4892         // and allow time either before or after year.
4893         if (parts.count() < 5 || parts.count() > 6)
4894             return QDateTime();
4895 
4896         // Year and time can be in either order.
4897         // Guess which by looking for ':' in the time
4898         int yearPart = 3;
4899         int timePart = 3;
4900         if (parts.at(3).contains(u':'))
4901             yearPart = 4;
4902         else if (parts.at(4).contains(u':'))
4903             timePart = 4;
4904         else
4905             return QDateTime();
4906 
4907         bool ok = false;
4908         int day = parts.at(2).toInt(&ok);
4909         int year = ok ? parts.at(yearPart).toInt(&ok) : 0;
4910         int month = fromShortMonthName(parts.at(1));
4911         if (!ok || year == 0 || day == 0 || month < 1)
4912             return QDateTime();
4913 
4914         const QDate date(year, month, day);
4915         if (!date.isValid())
4916             return QDateTime();
4917 
4918         const QTime time = fromIsoTimeString(parts.at(timePart), format, nullptr);
4919         if (!time.isValid())
4920             return QDateTime();
4921 
4922         if (parts.count() == 5)
4923             return QDateTime(date, time, Qt::LocalTime);
4924 
4925         QStringView tz = parts.at(5);
4926         if (tz.startsWith(QLatin1String("UTC"))
4927             // GMT has long been deprecated as an alias for UTC.
4928             || tz.startsWith(QLatin1String("GMT"), Qt::CaseInsensitive)) {
4929             tz = tz.sliced(3);
4930             if (tz.isEmpty())
4931                 return QDateTime(date, time, Qt::UTC);
4932 
4933             int offset = fromOffsetString(tz, &ok);
4934             return ok ? QDateTime(date, time, Qt::OffsetFromUTC, offset) : QDateTime();
4935         }
4936         return QDateTime();
4937     }
4938     }
4939 
4940     return QDateTime();
4941 }
4942 
4943 /*!
4944     \fn QDateTime QDateTime::fromString(const QString &string, const QString &format, QCalendar cal)
4945 
4946     Returns the QDateTime represented by the \a string, using the \a
4947     format given, or an invalid datetime if the string cannot be parsed.
4948 
4949     Uses the calendar \a cal if supplied, else Gregorian.
4950 
4951     In addition to the expressions, recognized in the format string to represent
4952     parts of the date and time, by QDate::fromString() and QTime::fromString(),
4953     this method supports:
4954 
4955     \table
4956     \header \li Expression \li Output
4957     \row \li t \li the timezone (for example "CEST")
4958     \endtable
4959 
4960     If no 't' format specifier is present, the system's local time-zone is used.
4961     For the defaults of all other fields, see QDate::fromString() and QTime::fromString().
4962 
4963     For example:
4964 
4965     \snippet code/src_corelib_time_qdatetime.cpp 14
4966 
4967     All other input characters will be treated as text. Any non-empty sequence
4968     of characters enclosed in single quotes will also be treated (stripped of
4969     the quotes) as text and not be interpreted as expressions.
4970 
4971     \snippet code/src_corelib_time_qdatetime.cpp 12
4972 
4973     If the format is not satisfied, an invalid QDateTime is returned.  If the
4974     format is satisfied but \a string represents an invalid date-time (e.g. in a
4975     gap skipped by a time-zone transition), an invalid QDateTime is returned,
4976     whose toMSecsSinceEpoch() represents a near-by date-time that is
4977     valid. Passing that to fromMSecsSinceEpoch() will produce a valid date-time
4978     that isn't faithfully represented by the string parsed.
4979 
4980     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be
4981     greedy. This means that they will use two digits (or three, for z) even if this will
4982     put them outside the range and/or leave too few digits for other
4983     sections.
4984 
4985     \snippet code/src_corelib_time_qdatetime.cpp 13
4986 
4987     This could have meant 1 January 00:30.00 but the M will grab
4988     two digits.
4989 
4990     Incorrectly specified fields of the \a string will cause an invalid
4991     QDateTime to be returned. For example, consider the following code,
4992     where the two digit year 12 is read as 1912 (see the table below for all
4993     field defaults); the resulting datetime is invalid because 23 April 1912
4994     was a Tuesday, not a Monday:
4995 
4996     \snippet code/src_corelib_time_qdatetime.cpp 20
4997 
4998     The correct code is:
4999 
5000     \snippet code/src_corelib_time_qdatetime.cpp 21
5001 
5002     \note Day and month names as well as AM/PM indication must be given in English (C locale).
5003     If localized month and day names and localized forms of AM/PM are used, use
5004     QLocale::system().toDateTime().
5005 
5006     \sa toString(), QDate::fromString(), QTime::fromString(),
5007     QLocale::toDateTime()
5008 */
5009 
5010 /*!
5011     \fn QDateTime QDateTime::fromString(QStringView string, QStringView format, QCalendar cal)
5012     \overload
5013     \since 6.0
5014 */
5015 
5016 /*!
5017     \overload
5018     \since 6.0
5019 */
5020 QDateTime QDateTime::fromString(const QString &string, QStringView format, QCalendar cal)
5021 {
5022 #if QT_CONFIG(datetimeparser)
5023     QDateTime datetime;
5024 
5025     QDateTimeParser dt(QMetaType::QDateTime, QDateTimeParser::FromString, cal);
5026     dt.setDefaultLocale(QLocale::c());
5027     if (dt.parseFormat(format) && (dt.fromString(string, &datetime) || !datetime.isValid()))
5028         return datetime;
5029 #else
5030     Q_UNUSED(string);
5031     Q_UNUSED(format);
5032     Q_UNUSED(cal);
5033 #endif
5034     return QDateTime();
5035 }
5036 
5037 #endif // datestring
5038 /*!
5039     \fn QDateTime QDateTime::toLocalTime() const
5040 
5041     Returns a datetime containing the date and time information in
5042     this datetime, but specified using the Qt::LocalTime definition.
5043 
5044     Example:
5045 
5046     \snippet code/src_corelib_time_qdatetime.cpp 17
5047 
5048     \sa toTimeSpec()
5049 */
5050 
5051 /*!
5052     \fn QDateTime QDateTime::toUTC() const
5053 
5054     Returns a datetime containing the date and time information in
5055     this datetime, but specified using the Qt::UTC definition.
5056 
5057     Example:
5058 
5059     \snippet code/src_corelib_time_qdatetime.cpp 18
5060 
5061     \sa toTimeSpec()
5062 */
5063 
5064 /*****************************************************************************
5065   Date/time stream functions
5066  *****************************************************************************/
5067 
5068 #ifndef QT_NO_DATASTREAM
5069 /*!
5070     \relates QDate
5071 
5072     Writes the \a date to stream \a out.
5073 
5074     \sa {Serializing Qt Data Types}
5075 */
5076 
5077 QDataStream &operator<<(QDataStream &out, QDate date)
5078 {
5079     if (out.version() < QDataStream::Qt_5_0)
5080         return out << quint32(date.jd);
5081     else
5082         return out << qint64(date.jd);
5083 }
5084 
5085 /*!
5086     \relates QDate
5087 
5088     Reads a date from stream \a in into the \a date.
5089 
5090     \sa {Serializing Qt Data Types}
5091 */
5092 
5093 QDataStream &operator>>(QDataStream &in, QDate &date)
5094 {
5095     if (in.version() < QDataStream::Qt_5_0) {
5096         quint32 jd;
5097         in >> jd;
5098         // Older versions consider 0 an invalid jd.
5099         date.jd = (jd != 0 ? jd : QDate::nullJd());
5100     } else {
5101         qint64 jd;
5102         in >> jd;
5103         date.jd = jd;
5104     }
5105 
5106     return in;
5107 }
5108 
5109 /*!
5110     \relates QTime
5111 
5112     Writes \a time to stream \a out.
5113 
5114     \sa {Serializing Qt Data Types}
5115 */
5116 
5117 QDataStream &operator<<(QDataStream &out, QTime time)
5118 {
5119     if (out.version() >= QDataStream::Qt_4_0) {
5120         return out << quint32(time.mds);
5121     } else {
5122         // Qt3 had no support for reading -1, QTime() was valid and serialized as 0
5123         return out << quint32(time.isNull() ? 0 : time.mds);
5124     }
5125 }
5126 
5127 /*!
5128     \relates QTime
5129 
5130     Reads a time from stream \a in into the given \a time.
5131 
5132     \sa {Serializing Qt Data Types}
5133 */
5134 
5135 QDataStream &operator>>(QDataStream &in, QTime &time)
5136 {
5137     quint32 ds;
5138     in >> ds;
5139     if (in.version() >= QDataStream::Qt_4_0) {
5140         time.mds = int(ds);
5141     } else {
5142         // Qt3 would write 0 for a null time
5143         time.mds = (ds == 0) ? QTime::NullTime : int(ds);
5144     }
5145     return in;
5146 }
5147 
5148 /*!
5149     \relates QDateTime
5150 
5151     Writes \a dateTime to the \a out stream.
5152 
5153     \sa {Serializing Qt Data Types}
5154 */
5155 QDataStream &operator<<(QDataStream &out, const QDateTime &dateTime)
5156 {
5157     QPair<QDate, QTime> dateAndTime;
5158 
5159     if (out.version() >= QDataStream::Qt_5_2) {
5160 
5161         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5162         dateAndTime = getDateTime(dateTime.d);
5163         out << dateAndTime << qint8(dateTime.timeSpec());
5164         if (dateTime.timeSpec() == Qt::OffsetFromUTC)
5165             out << qint32(dateTime.offsetFromUtc());
5166 #if QT_CONFIG(timezone)
5167         else if (dateTime.timeSpec() == Qt::TimeZone)
5168             out << dateTime.timeZone();
5169 #endif // timezone
5170 
5171     } else if (out.version() == QDataStream::Qt_5_0) {
5172 
5173         // In Qt 5.0 we incorrectly serialised all datetimes as UTC.
5174         // This approach is wrong and should not be used again; it breaks
5175         // the guarantee that a deserialised local datetime is the same time
5176         // of day, regardless of which timezone it was serialised in.
5177         dateAndTime = getDateTime((dateTime.isValid() ? dateTime.toUTC() : dateTime).d);
5178         out << dateAndTime << qint8(dateTime.timeSpec());
5179 
5180     } else if (out.version() >= QDataStream::Qt_4_0) {
5181 
5182         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5183         dateAndTime = getDateTime(dateTime.d);
5184         out << dateAndTime;
5185         switch (dateTime.timeSpec()) {
5186         case Qt::UTC:
5187             out << (qint8)QDateTimePrivate::UTC;
5188             break;
5189         case Qt::OffsetFromUTC:
5190             out << (qint8)QDateTimePrivate::OffsetFromUTC;
5191             break;
5192         case Qt::TimeZone:
5193             out << (qint8)QDateTimePrivate::TimeZone;
5194             break;
5195         case Qt::LocalTime:
5196             out << (qint8)QDateTimePrivate::LocalUnknown;
5197             break;
5198         }
5199 
5200     } else { // version < QDataStream::Qt_4_0
5201 
5202         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5203         dateAndTime = getDateTime(dateTime.d);
5204         out << dateAndTime;
5205 
5206     }
5207 
5208     return out;
5209 }
5210 
5211 /*!
5212     \relates QDateTime
5213 
5214     Reads a datetime from the stream \a in into \a dateTime.
5215 
5216     \sa {Serializing Qt Data Types}
5217 */
5218 
5219 QDataStream &operator>>(QDataStream &in, QDateTime &dateTime)
5220 {
5221     QDate dt;
5222     QTime tm;
5223     qint8 ts = 0;
5224     Qt::TimeSpec spec = Qt::LocalTime;
5225     qint32 offset = 0;
5226 #if QT_CONFIG(timezone)
5227     QTimeZone tz;
5228 #endif // timezone
5229 
5230     if (in.version() >= QDataStream::Qt_5_2) {
5231 
5232         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5233         in >> dt >> tm >> ts;
5234         spec = static_cast<Qt::TimeSpec>(ts);
5235         if (spec == Qt::OffsetFromUTC) {
5236             in >> offset;
5237             dateTime = QDateTime(dt, tm, spec, offset);
5238 #if QT_CONFIG(timezone)
5239         } else if (spec == Qt::TimeZone) {
5240             in >> tz;
5241             dateTime = QDateTime(dt, tm, tz);
5242 #endif // timezone
5243         } else {
5244             dateTime = QDateTime(dt, tm, spec);
5245         }
5246 
5247     } else if (in.version() == QDataStream::Qt_5_0) {
5248 
5249         // In Qt 5.0 we incorrectly serialised all datetimes as UTC
5250         in >> dt >> tm >> ts;
5251         spec = static_cast<Qt::TimeSpec>(ts);
5252         dateTime = QDateTime(dt, tm, Qt::UTC);
5253         dateTime = dateTime.toTimeSpec(spec);
5254 
5255     } else if (in.version() >= QDataStream::Qt_4_0) {
5256 
5257         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5258         in >> dt >> tm >> ts;
5259         switch ((QDateTimePrivate::Spec)ts) {
5260         case QDateTimePrivate::UTC:
5261             spec = Qt::UTC;
5262             break;
5263         case QDateTimePrivate::OffsetFromUTC:
5264             spec = Qt::OffsetFromUTC;
5265             break;
5266         case QDateTimePrivate::TimeZone:
5267             spec = Qt::TimeZone;
5268 #if QT_CONFIG(timezone)
5269             // FIXME: need to use a different constructor !
5270 #endif
5271             break;
5272         case QDateTimePrivate::LocalUnknown:
5273         case QDateTimePrivate::LocalStandard:
5274         case QDateTimePrivate::LocalDST:
5275             spec = Qt::LocalTime;
5276             break;
5277         }
5278         dateTime = QDateTime(dt, tm, spec, offset);
5279 
5280     } else { // version < QDataStream::Qt_4_0
5281 
5282         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5283         in >> dt >> tm;
5284         dateTime = QDateTime(dt, tm, spec, offset);
5285 
5286     }
5287 
5288     return in;
5289 }
5290 #endif // QT_NO_DATASTREAM
5291 
5292 /*****************************************************************************
5293   Date / Time Debug Streams
5294 *****************************************************************************/
5295 
5296 #if !defined(QT_NO_DEBUG_STREAM) && QT_CONFIG(datestring)
5297 QDebug operator<<(QDebug dbg, QDate date)
5298 {
5299     QDebugStateSaver saver(dbg);
5300     dbg.nospace() << "QDate(";
5301     if (date.isValid())
5302         dbg.nospace() << date.toString(Qt::ISODate);
5303     else
5304         dbg.nospace() << "Invalid";
5305     dbg.nospace() << ')';
5306     return dbg;
5307 }
5308 
5309 QDebug operator<<(QDebug dbg, QTime time)
5310 {
5311     QDebugStateSaver saver(dbg);
5312     dbg.nospace() << "QTime(";
5313     if (time.isValid())
5314         dbg.nospace() << time.toString(u"HH:mm:ss.zzz");
5315     else
5316         dbg.nospace() << "Invalid";
5317     dbg.nospace() << ')';
5318     return dbg;
5319 }
5320 
5321 QDebug operator<<(QDebug dbg, const QDateTime &date)
5322 {
5323     QDebugStateSaver saver(dbg);
5324     dbg.nospace() << "QDateTime(";
5325     if (date.isValid()) {
5326         const Qt::TimeSpec ts = date.timeSpec();
5327         dbg.noquote() << date.toString(u"yyyy-MM-dd HH:mm:ss.zzz t")
5328                       << ' ' << ts;
5329         switch (ts) {
5330         case Qt::UTC:
5331             break;
5332         case Qt::OffsetFromUTC:
5333             dbg.space() << date.offsetFromUtc() << 's';
5334             break;
5335         case Qt::TimeZone:
5336 #if QT_CONFIG(timezone)
5337             dbg.space() << date.timeZone().id();
5338 #endif // timezone
5339             break;
5340         case Qt::LocalTime:
5341             break;
5342         }
5343     } else {
5344         dbg.nospace() << "Invalid";
5345     }
5346     return dbg.nospace() << ')';
5347 }
5348 #endif // debug_stream && datestring
5349 
5350 /*! \fn size_t qHash(const QDateTime &key, size_t seed = 0)
5351     \relates QHash
5352     \since 5.0
5353 
5354     Returns the hash value for the \a key, using \a seed to seed the calculation.
5355 */
5356 size_t qHash(const QDateTime &key, size_t seed)
5357 {
5358     // Use to toMSecsSinceEpoch instead of individual qHash functions for
5359     // QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
5360     // to the same timezone. If we don't, qHash would return different hashes for
5361     // two QDateTimes that are equivalent once converted to the same timezone.
5362     return key.isValid() ? qHash(key.toMSecsSinceEpoch(), seed) : seed;
5363 }
5364 
5365 /*! \fn size_t qHash(QDate key, size_t seed = 0)
5366     \relates QHash
5367     \since 5.0
5368 
5369     Returns the hash value for the \a key, using \a seed to seed the calculation.
5370 */
5371 size_t qHash(QDate key, size_t seed) noexcept
5372 {
5373     return qHash(key.toJulianDay(), seed);
5374 }
5375 
5376 /*! \fn size_t qHash(QTime key, size_t seed = 0)
5377     \relates QHash
5378     \since 5.0
5379 
5380     Returns the hash value for the \a key, using \a seed to seed the calculation.
5381 */
5382 size_t qHash(QTime key, size_t seed) noexcept
5383 {
5384     return qHash(key.msecsSinceStartOfDay(), seed);
5385 }
5386 
5387 QT_END_NAMESPACE
