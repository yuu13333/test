Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qglobal.h"
42 
43 #if !defined(QWS) && defined(Q_OS_MAC)
44 #   include "private/qcore_mac_p.h"
45 #   include <CoreFoundation/CoreFoundation.h>
46 #endif
47 
48 #include "qplatformdefs.h"
49 
50 #include "qdatastream.h"
51 #include "qdebug.h"
52 #include "qhashfunctions.h"
53 #include "qstring.h"
54 #include "qlocale.h"
55 #include "qlocale_p.h"
56 #include "qlocale_tools_p.h"
57 #if QT_CONFIG(datetimeparser)
58 #include "qdatetimeparser_p.h"
59 #endif
60 #include "qnamespace.h"
61 #include "qdatetime.h"
62 #include "qstringlist.h"
63 #include "qvariant.h"
64 #include "qstringbuilder.h"
65 #include "private/qnumeric_p.h"
66 #include <cmath>
67 #ifndef QT_NO_SYSTEMLOCALE
68 #   include "qmutex.h"
69 #endif
70 #ifdef Q_OS_WIN
71 #   include <qt_windows.h>
72 #   include <time.h>
73 #endif
74 
75 QT_BEGIN_NAMESPACE
76 
77 #ifndef QT_NO_SYSTEMLOCALE
78 static QSystemLocale *_systemLocale = 0;
79 class QSystemLocaleSingleton: public QSystemLocale
80 {
81 public:
82     QSystemLocaleSingleton() : QSystemLocale(true) {}
83 };
84 
85 Q_GLOBAL_STATIC(QSystemLocaleSingleton, QSystemLocale_globalSystemLocale)
86 static QLocaleData *system_data = 0;
87 static QLocaleData globalLocaleData;
88 #endif
89 
90 /******************************************************************************
91 ** Helpers for accessing Qt locale database
92 */
93 
94 QT_BEGIN_INCLUDE_NAMESPACE
95 #include "qlocale_data_p.h"
96 QT_END_INCLUDE_NAMESPACE
97 
98 QLocale::Language QLocalePrivate::codeToLanguage(QStringView code) Q_DECL_NOTHROW
99 {
100     const auto len = code.size();
101     if (len != 2 && len != 3)
102         return QLocale::C;
103     ushort uc1 = code[0].toLower().unicode();
104     ushort uc2 = code[1].toLower().unicode();
105     ushort uc3 = len > 2 ? code[2].toLower().unicode() : 0;
106 
107     const unsigned char *c = language_code_list;
108     for (; *c != 0; c += 3) {
109         if (uc1 == c[0] && uc2 == c[1] && uc3 == c[2])
110             return QLocale::Language((c - language_code_list)/3);
111     }
112 
113     if (uc3 == 0) {
114         // legacy codes
115         if (uc1 == 'n' && uc2 == 'o') { // no -> nb
116             Q_STATIC_ASSERT(QLocale::Norwegian == QLocale::NorwegianBokmal);
117             return QLocale::Norwegian;
118         }
119         if (uc1 == 't' && uc2 == 'l') { // tl -> fil
120             Q_STATIC_ASSERT(QLocale::Tagalog == QLocale::Filipino);
121             return QLocale::Tagalog;
122         }
123         if (uc1 == 's' && uc2 == 'h') { // sh -> sr[_Latn]
124             Q_STATIC_ASSERT(QLocale::SerboCroatian == QLocale::Serbian);
125             return QLocale::SerboCroatian;
126         }
127         if (uc1 == 'm' && uc2 == 'o') { // mo -> ro
128             Q_STATIC_ASSERT(QLocale::Moldavian == QLocale::Romanian);
129             return QLocale::Moldavian;
130         }
131         // Android uses the following deprecated codes
132         if (uc1 == 'i' && uc2 == 'w') // iw -> he
133             return QLocale::Hebrew;
134         if (uc1 == 'i' && uc2 == 'n') // in -> id
135             return QLocale::Indonesian;
136         if (uc1 == 'j' && uc2 == 'i') // ji -> yi
137             return QLocale::Yiddish;
138     }
139     return QLocale::C;
140 }
141 
142 QLocale::Script QLocalePrivate::codeToScript(QStringView code) Q_DECL_NOTHROW
143 {
144     const auto len = code.size();
145     if (len != 4)
146         return QLocale::AnyScript;
147 
148     // script is titlecased in our data
149     unsigned char c0 = code[0].toUpper().toLatin1();
150     unsigned char c1 = code[1].toLower().toLatin1();
151     unsigned char c2 = code[2].toLower().toLatin1();
152     unsigned char c3 = code[3].toLower().toLatin1();
153 
154     const unsigned char *c = script_code_list;
155     for (int i = 0; i < QLocale::LastScript; ++i, c += 4) {
156         if (c0 == c[0] && c1 == c[1] && c2 == c[2] && c3 == c[3])
157             return QLocale::Script(i);
158     }
159     return QLocale::AnyScript;
160 }
161 
162 QLocale::Country QLocalePrivate::codeToCountry(QStringView code) Q_DECL_NOTHROW
163 {
164     const auto len = code.size();
165     if (len != 2 && len != 3)
166         return QLocale::AnyCountry;
167 
168     ushort uc1 = code[0].toUpper().unicode();
169     ushort uc2 = code[1].toUpper().unicode();
170     ushort uc3 = len > 2 ? code[2].toUpper().unicode() : 0;
171 
172     const unsigned char *c = country_code_list;
173     for (; *c != 0; c += 3) {
174         if (uc1 == c[0] && uc2 == c[1] && uc3 == c[2])
175             return QLocale::Country((c - country_code_list)/3);
176     }
177 
178     return QLocale::AnyCountry;
179 }
180 
181 QLatin1String QLocalePrivate::languageToCode(QLocale::Language language)
182 {
183     if (language == QLocale::AnyLanguage)
184         return QLatin1String();
185     if (language == QLocale::C)
186         return QLatin1String("C");
187 
188     const unsigned char *c = language_code_list + 3*(uint(language));
189 
190     return QLatin1String(reinterpret_cast<const char*>(c), c[2] == 0 ? 2 : 3);
191 
192 }
193 
194 QLatin1String QLocalePrivate::scriptToCode(QLocale::Script script)
195 {
196     if (script == QLocale::AnyScript || script > QLocale::LastScript)
197         return QLatin1String();
198     const unsigned char *c = script_code_list + 4*(uint(script));
199     return QLatin1String(reinterpret_cast<const char *>(c), 4);
200 }
201 
202 QLatin1String QLocalePrivate::countryToCode(QLocale::Country country)
203 {
204     if (country == QLocale::AnyCountry)
205         return QLatin1String();
206 
207     const unsigned char *c = country_code_list + 3*(uint(country));
208 
209     return QLatin1String(reinterpret_cast<const char*>(c), c[2] == 0 ? 2 : 3);
210 }
211 
212 // http://www.unicode.org/reports/tr35/#Likely_Subtags
213 static bool addLikelySubtags(QLocaleId &localeId)
214 {
215     // ### optimize with bsearch
216     const int likely_subtags_count = sizeof(likely_subtags) / sizeof(likely_subtags[0]);
217     const QLocaleId *p = likely_subtags;
218     const QLocaleId *const e = p + likely_subtags_count;
219     for ( ; p < e; p += 2) {
220         if (localeId == p[0]) {
221             localeId = p[1];
222             return true;
223         }
224     }
225     return false;
226 }
227 
228 QLocaleId QLocaleId::withLikelySubtagsAdded() const
229 {
230     // language_script_region
231     if (language_id || script_id || country_id) {
232         QLocaleId id = QLocaleId::fromIds(language_id, script_id, country_id);
233         if (addLikelySubtags(id))
234             return id;
235     }
236     // language_script
237     if (country_id) {
238         QLocaleId id = QLocaleId::fromIds(language_id, script_id, 0);
239         if (addLikelySubtags(id)) {
240             id.country_id = country_id;
241             return id;
242         }
243     }
244     // language_region
245     if (script_id) {
246         QLocaleId id = QLocaleId::fromIds(language_id, 0, country_id);
247         if (addLikelySubtags(id)) {
248             id.script_id = script_id;
249             return id;
250         }
251     }
252     // language
253     if (script_id && country_id) {
254         QLocaleId id = QLocaleId::fromIds(language_id, 0, 0);
255         if (addLikelySubtags(id)) {
256             id.script_id = script_id;
257             id.country_id = country_id;
258             return id;
259         }
260     }
261     return *this;
262 }
263 
264 QLocaleId QLocaleId::withLikelySubtagsRemoved() const
265 {
266     QLocaleId max = withLikelySubtagsAdded();
267     // language
268     {
269         QLocaleId id = QLocaleId::fromIds(language_id, 0, 0);
270         if (id.withLikelySubtagsAdded() == max)
271             return id;
272     }
273     // language_region
274     if (country_id) {
275         QLocaleId id = QLocaleId::fromIds(language_id, 0, country_id);
276         if (id.withLikelySubtagsAdded() == max)
277             return id;
278     }
279     // language_script
280     if (script_id) {
281         QLocaleId id = QLocaleId::fromIds(language_id, script_id, 0);
282         if (id.withLikelySubtagsAdded() == max)
283             return id;
284     }
285     return max;
286 }
287 
288 QByteArray QLocaleId::name(char separator) const
289 {
290     if (language_id == QLocale::AnyLanguage)
291         return QByteArray();
292     if (language_id == QLocale::C)
293         return QByteArrayLiteral("C");
294 
295     const unsigned char *lang = language_code_list + 3 * language_id;
296     const unsigned char *script =
297             (script_id != QLocale::AnyScript ? script_code_list + 4 * script_id : 0);
298     const unsigned char *country =
299             (country_id != QLocale::AnyCountry ? country_code_list + 3 * country_id : 0);
300     char len = (lang[2] != 0 ? 3 : 2) + (script ? 4+1 : 0) + (country ? (country[2] != 0 ? 3 : 2)+1 : 0);
301     QByteArray name(len, Qt::Uninitialized);
302     char *uc = name.data();
303     *uc++ = lang[0];
304     *uc++ = lang[1];
305     if (lang[2] != 0)
306         *uc++ = lang[2];
307     if (script) {
308         *uc++ = separator;
309         *uc++ = script[0];
310         *uc++ = script[1];
311         *uc++ = script[2];
312         *uc++ = script[3];
313     }
314     if (country) {
315         *uc++ = separator;
316         *uc++ = country[0];
317         *uc++ = country[1];
318         if (country[2] != 0)
319             *uc++ = country[2];
320     }
321     return name;
322 }
323 
324 QByteArray QLocalePrivate::bcp47Name(char separator) const
325 {
326     if (m_data->m_language_id == QLocale::AnyLanguage)
327         return QByteArray();
328     if (m_data->m_language_id == QLocale::C)
329         return QByteArrayLiteral("en");
330 
331     QLocaleId localeId = QLocaleId::fromIds(m_data->m_language_id, m_data->m_script_id, m_data->m_country_id);
332     return localeId.withLikelySubtagsRemoved().name(separator);
333 }
334 
335 static const QLocaleData *findLocaleDataById(const QLocaleId &localeId)
336 {
337     const uint idx = locale_index[localeId.language_id];
338 
339     const QLocaleData *data = locale_data + idx;
340 
341     if (idx == 0) // default language has no associated script or country
342         return data;
343 
344     Q_ASSERT(data->m_language_id == localeId.language_id);
345 
346     if (localeId.script_id == QLocale::AnyScript && localeId.country_id == QLocale::AnyCountry)
347         return data;
348 
349     if (localeId.script_id == QLocale::AnyScript) {
350         do {
351             if (data->m_country_id == localeId.country_id)
352                 return data;
353             ++data;
354         } while (data->m_language_id && data->m_language_id == localeId.language_id);
355     } else if (localeId.country_id == QLocale::AnyCountry) {
356         do {
357             if (data->m_script_id == localeId.script_id)
358                 return data;
359             ++data;
360         } while (data->m_language_id && data->m_language_id == localeId.language_id);
361     } else {
362         do {
363             if (data->m_script_id == localeId.script_id && data->m_country_id == localeId.country_id)
364                 return data;
365             ++data;
366         } while (data->m_language_id && data->m_language_id == localeId.language_id);
367     }
368 
369     return 0;
370 }
371 
372 const QLocaleData *QLocaleData::findLocaleData(QLocale::Language language, QLocale::Script script, QLocale::Country country)
373 {
374     QLocaleId localeId = QLocaleId::fromIds(language, script, country);
375     QLocaleId likelyId = localeId.withLikelySubtagsAdded();
376 
377     const uint idx = locale_index[likelyId.language_id];
378 
379     // Try a straight match with the likely data:
380     if (const QLocaleData *const data = findLocaleDataById(likelyId))
381         return data;
382     QList<QLocaleId> tried;
383     tried.push_back(likelyId);
384 
385     // No match; try again with likely country
386     if (country != QLocale::AnyCountry
387         && (language != QLocale::AnyLanguage || script != QLocale::AnyScript)) {
388         localeId = QLocaleId::fromIds(language, script, QLocale::AnyCountry);
389         likelyId = localeId.withLikelySubtagsAdded();
390         if (!tried.contains(likelyId)) {
391             if (const QLocaleData *const data = findLocaleDataById(likelyId))
392                 return data;
393             tried.push_back(likelyId);
394         }
395 
396         // No match; try again with any country
397         if (!tried.contains(localeId)) {
398             if (const QLocaleData *const data = findLocaleDataById(localeId))
399                 return data;
400             tried.push_back(localeId);
401         }
402     }
403 
404     // No match; try again with likely script
405     if (script != QLocale::AnyScript
406         && (language != QLocale::AnyLanguage || country != QLocale::AnyCountry)) {
407         localeId = QLocaleId::fromIds(language, QLocale::AnyScript, country);
408         likelyId = localeId.withLikelySubtagsAdded();
409         if (!tried.contains(likelyId)) {
410             if (const QLocaleData *const data = findLocaleDataById(likelyId))
411                 return data;
412             tried.push_back(likelyId);
413         }
414 
415         // No match; try again with any script
416         if (!tried.contains(localeId)) {
417             if (const QLocaleData *const data = findLocaleDataById(localeId))
418                 return data;
419             tried.push_back(localeId);
420         }
421     }
422 
423     // No match; return data at original index
424     return locale_data + idx;
425 }
426 
427 static bool parse_locale_tag(const QString &input, int &i, QString *result, const QString &separators)
428 {
429     *result = QString(8, Qt::Uninitialized); // worst case according to BCP47
430     QChar *pch = result->data();
431     const QChar *uc = input.data() + i;
432     const int l = input.length();
433     int size = 0;
434     for (; i < l && size < 8; ++i, ++size) {
435         if (separators.contains(*uc))
436             break;
437         if (! ((uc->unicode() >= 'a' && uc->unicode() <= 'z') ||
438                (uc->unicode() >= 'A' && uc->unicode() <= 'Z') ||
439                (uc->unicode() >= '0' && uc->unicode() <= '9')) ) // latin only
440             return false;
441         *pch++ = *uc++;
442     }
443     result->truncate(size);
444     return true;
445 }
446 
447 bool qt_splitLocaleName(const QString &name, QString &lang, QString &script, QString &cntry)
448 {
449     const int length = name.length();
450 
451     lang = script = cntry = QString();
452 
453     const QString separators = QStringLiteral("_-.@");
454     enum ParserState { NoState, LangState, ScriptState, CountryState };
455     ParserState state = LangState;
456     for (int i = 0; i < length && state != NoState; ) {
457         QString value;
458         if (!parse_locale_tag(name, i, &value, separators) ||value.isEmpty())
459             break;
460         QChar sep = i < length ? name.at(i) : QChar();
461         switch (state) {
462         case LangState:
463             if (!sep.isNull() && !separators.contains(sep)) {
464                 state = NoState;
465                 break;
466             }
467             lang = value;
468             if (i == length) {
469                 // just language was specified
470                 state = NoState;
471                 break;
472             }
473             state = ScriptState;
474             break;
475         case ScriptState: {
476             QString scripts = QString::fromLatin1((const char *)script_code_list, sizeof(script_code_list) - 1);
477             if (value.length() == 4 && scripts.indexOf(value) % 4 == 0) {
478                 // script name is always 4 characters
479                 script = value;
480                 state = CountryState;
481             } else {
482                 // it wasn't a script, maybe it is a country then?
483                 cntry = value;
484                 state = NoState;
485             }
486             break;
487         }
488         case CountryState:
489             cntry = value;
490             state = NoState;
491             break;
492         case NoState:
493             // shouldn't happen
494             qWarning("QLocale: This should never happen");
495             break;
496         }
497         ++i;
498     }
499     return lang.length() == 2 || lang.length() == 3;
500 }
501 
502 void QLocalePrivate::getLangAndCountry(const QString &name, QLocale::Language &lang,
503                                        QLocale::Script &script, QLocale::Country &cntry)
504 {
505     lang = QLocale::C;
506     script = QLocale::AnyScript;
507     cntry = QLocale::AnyCountry;
508 
509     QString lang_code;
510     QString script_code;
511     QString cntry_code;
512     if (!qt_splitLocaleName(name, lang_code, script_code, cntry_code))
513         return;
514 
515     lang = QLocalePrivate::codeToLanguage(lang_code);
516     if (lang == QLocale::C)
517         return;
518     script = QLocalePrivate::codeToScript(script_code);
519     cntry = QLocalePrivate::codeToCountry(cntry_code);
520 }
521 
522 static const QLocaleData *findLocaleData(const QString &name)
523 {
524     QLocale::Language lang;
525     QLocale::Script script;
526     QLocale::Country cntry;
527     QLocalePrivate::getLangAndCountry(name, lang, script, cntry);
528 
529     return QLocaleData::findLocaleData(lang, script, cntry);
530 }
531 
532 QString qt_readEscapedFormatString(QStringView format, int *idx)
533 {
534     int &i = *idx;
535 
536     Q_ASSERT(format.at(i) == QLatin1Char('\''));
537     ++i;
538     if (i == format.size())
539         return QString();
540     if (format.at(i).unicode() == '\'') { // "''" outside of a quoted stirng
541         ++i;
542         return QLatin1String("'");
543     }
544 
545     QString result;
546 
547     while (i < format.size()) {
548         if (format.at(i).unicode() == '\'') {
549             if (i + 1 < format.size() && format.at(i + 1).unicode() == '\'') {
550                 // "''" inside of a quoted string
551                 result.append(QLatin1Char('\''));
552                 i += 2;
553             } else {
554                 break;
555             }
556         } else {
557             result.append(format.at(i++));
558         }
559     }
560     if (i < format.size())
561         ++i;
562 
563     return result;
564 }
565 
566 /*!
567     \internal
568 
569     Counts the number of identical leading characters in \a s.
570 
571     If \a s is empty, returns 0.
572 
573     Otherwise, returns the number of consecutive \c{s.front()}
574     characters at the start of \a s.
575 
576     \code
577     qt_repeatCount(u"a");   // == 1
578     qt_repeatCount(u"ab");  // == 1
579     qt_repeatCount(u"aab"); // == 2
580     \endcode
581 */
582 int qt_repeatCount(QStringView s)
583 {
584     if (s.isEmpty())
585         return 0;
586     const QChar c = s.front();
587     qsizetype j = 1;
588     while (j < s.size() && s.at(j) == c)
589         ++j;
590     return int(j);
591 }
592 
593 static const QLocaleData *default_data = 0;
594 static QLocale::NumberOptions default_number_options = QLocale::DefaultNumberOptions;
595 
596 static const QLocaleData *const c_data = locale_data;
597 static QLocalePrivate *c_private()
598 {
599     static QLocalePrivate c_locale = { c_data, Q_BASIC_ATOMIC_INITIALIZER(1), QLocale::OmitGroupSeparator };
600     return &c_locale;
601 }
602 
603 #ifndef QT_NO_SYSTEMLOCALE
604 /******************************************************************************
605 ** Default system locale behavior
606 */
607 
608 /*!
609   Constructs a QSystemLocale object. The constructor will automatically
610   install this object as the system locale and remove any earlier installed
611   system locales.
612 */
613 QSystemLocale::QSystemLocale()
614 {
615     _systemLocale = this;
616 
617     if (system_data)
618         system_data->m_language_id = 0;
619 }
620 
621 /*!
622     \internal
623 */
624 QSystemLocale::QSystemLocale(bool)
625 { }
626 
627 /*!
628   Deletes the object.
629 */
630 QSystemLocale::~QSystemLocale()
631 {
632     if (_systemLocale == this) {
633         _systemLocale = 0;
634 
635         if (system_data)
636             system_data->m_language_id = 0;
637     }
638 }
639 
640 static const QSystemLocale *systemLocale()
641 {
642     if (_systemLocale)
643         return _systemLocale;
644     return QSystemLocale_globalSystemLocale();
645 }
646 
647 void QLocalePrivate::updateSystemPrivate()
648 {
649     const QSystemLocale *sys_locale = systemLocale();
650     if (!system_data)
651         system_data = &globalLocaleData;
652 
653     // tell the object that the system locale has changed.
654     sys_locale->query(QSystemLocale::LocaleChanged, QVariant());
655 
656     *system_data = *sys_locale->fallbackUiLocale().d->m_data;
657 
658     QVariant res = sys_locale->query(QSystemLocale::LanguageId, QVariant());
659     if (!res.isNull()) {
660         system_data->m_language_id = res.toInt();
661         system_data->m_script_id = QLocale::AnyScript; // default for compatibility
662     }
663     res = sys_locale->query(QSystemLocale::CountryId, QVariant());
664     if (!res.isNull()) {
665         system_data->m_country_id = res.toInt();
666         system_data->m_script_id = QLocale::AnyScript; // default for compatibility
667     }
668     res = sys_locale->query(QSystemLocale::ScriptId, QVariant());
669     if (!res.isNull())
670         system_data->m_script_id = res.toInt();
671 
672     res = sys_locale->query(QSystemLocale::DecimalPoint, QVariant());
673     if (!res.isNull())
674         system_data->m_decimal = res.toString().at(0).unicode();
675 
676     res = sys_locale->query(QSystemLocale::GroupSeparator, QVariant());
677     if (!res.isNull())
678         system_data->m_group = res.toString().at(0).unicode();
679 
680     res = sys_locale->query(QSystemLocale::ZeroDigit, QVariant());
681     if (!res.isNull())
682         system_data->m_zero = res.toString().at(0).unicode();
683 
684     res = sys_locale->query(QSystemLocale::NegativeSign, QVariant());
685     if (!res.isNull())
686         system_data->m_minus = res.toString().at(0).unicode();
687 
688     res = sys_locale->query(QSystemLocale::PositiveSign, QVariant());
689     if (!res.isNull())
690         system_data->m_plus = res.toString().at(0).unicode();
691 }
692 #endif // !QT_NO_SYSTEMLOCALE
693 
694 static const QLocaleData *systemData()
695 {
696 #ifndef QT_NO_SYSTEMLOCALE
697     /*
698       Copy over the information from the fallback locale and modify.
699 
700       This modifies (cross-thread) global state, so take care to only call it in
701       one thread.
702     */
703     {
704         static QBasicMutex systemDataMutex;
705         systemDataMutex.lock();
706         if (!system_data || system_data->m_language_id == 0)
707             QLocalePrivate::updateSystemPrivate();
708         systemDataMutex.unlock();
709     }
710 
711     return system_data;
712 #else
713     return locale_data;
714 #endif
715 }
716 
717 static const QLocaleData *defaultData()
718 {
719     if (!default_data)
720         default_data = systemData();
721     return default_data;
722 }
723 
724 const QLocaleData *QLocaleData::c()
725 {
726     Q_ASSERT(locale_index[QLocale::C] == 0);
727     return c_data;
728 }
729 
730 static inline QString getLocaleData(const ushort *data, int size)
731 {
732     return size > 0 ? QString::fromRawData(reinterpret_cast<const QChar *>(data), size) : QString();
733 }
734 
735 static QString getLocaleListData(const ushort *data, int size, int index)
736 {
737     static const ushort separator = ';';
738     while (index && size > 0) {
739         while (*data != separator)
740             ++data, --size;
741         --index;
742         ++data;
743         --size;
744     }
745     const ushort *end = data;
746     while (size > 0 && *end != separator)
747         ++end, --size;
748     return getLocaleData(data, end - data);
749 }
750 
751 
752 #ifndef QT_NO_DATASTREAM
753 QDataStream &operator<<(QDataStream &ds, const QLocale &l)
754 {
755     ds << l.name();
756     return ds;
757 }
758 
759 QDataStream &operator>>(QDataStream &ds, QLocale &l)
760 {
761     QString s;
762     ds >> s;
763     l = QLocale(s);
764     return ds;
765 }
766 #endif // QT_NO_DATASTREAM
767 
768 
769 static const int locale_data_size = sizeof(locale_data)/sizeof(QLocaleData) - 1;
770 
771 Q_GLOBAL_STATIC_WITH_ARGS(QSharedDataPointer<QLocalePrivate>, defaultLocalePrivate,
772                           (QLocalePrivate::create(defaultData(), default_number_options)))
773 
774 static QLocalePrivate *localePrivateByName(const QString &name)
775 {
776     if (name == QLatin1String("C"))
777         return c_private();
778     const QLocaleData *data = findLocaleData(name);
779     return QLocalePrivate::create(data, data->m_language_id == QLocale::C ?
780                                       QLocale::OmitGroupSeparator : QLocale::DefaultNumberOptions);
781 }
782 
783 static QLocalePrivate *findLocalePrivate(QLocale::Language language, QLocale::Script script,
784                                          QLocale::Country country)
785 {
786     if (language == QLocale::C)
787         return c_private();
788 
789     const QLocaleData *data = QLocaleData::findLocaleData(language, script, country);
790 
791     QLocale::NumberOptions numberOptions = QLocale::DefaultNumberOptions;
792 
793     // If not found, should default to system
794     if (data->m_language_id == QLocale::C && language != QLocale::C) {
795         numberOptions = default_number_options;
796         data = defaultData();
797     }
798     return QLocalePrivate::create(data, numberOptions);
799 }
800 
801 
802 /*!
803  \internal
804 */
805 QLocale::QLocale(QLocalePrivate &dd)
806     : d(&dd)
807 {}
808 
809 
810 /*!
811     Constructs a QLocale object with the specified \a name,
812     which has the format
813     "language[_script][_country][.codeset][@modifier]" or "C", where:
814 
815     \list
816     \li language is a lowercase, two-letter, ISO 639 language code (also some three-letter codes),
817     \li script is a titlecase, four-letter, ISO 15924 script code,
818     \li country is an uppercase, two-letter, ISO 3166 country code (also "419" as defined by United Nations),
819     \li and codeset and modifier are ignored.
820     \endlist
821 
822     The separator can be either underscore or a minus sign.
823 
824     If the string violates the locale format, or language is not
825     a valid ISO 639 code, the "C" locale is used instead. If country
826     is not present, or is not a valid ISO 3166 code, the most
827     appropriate country is chosen for the specified language.
828 
829     The language, script and country codes are converted to their respective
830     \c Language, \c Script and \c Country enums. After this conversion is
831     performed, the constructor behaves exactly like QLocale(Country, Script,
832     Language).
833 
834     This constructor is much slower than QLocale(Country, Script, Language).
835 
836     \sa bcp47Name()
837 */
838 
839 QLocale::QLocale(const QString &name)
840     : d(localePrivateByName(name))
841 {
842 }
843 
844 /*!
845     Constructs a QLocale object initialized with the default locale. If
846     no default locale was set using setDefault(), this locale will
847     be the same as the one returned by system().
848 
849     \sa setDefault()
850 */
851 
852 QLocale::QLocale()
853     : d(*defaultLocalePrivate)
854 {
855     // Make sure system data is up to date
856     systemData();
857 }
858 
859 /*!
860     Constructs a QLocale object with the specified \a language and \a
861     country.
862 
863     \list
864     \li If the language/country pair is found in the database, it is used.
865     \li If the language is found but the country is not, or if the country
866        is \c AnyCountry, the language is used with the most
867        appropriate available country (for example, Germany for German),
868     \li If neither the language nor the country are found, QLocale
869        defaults to the default locale (see setDefault()).
870     \endlist
871 
872     The language and country that are actually used can be queried
873     using language() and country().
874 
875     \sa setDefault(), language(), country()
876 */
877 
878 QLocale::QLocale(Language language, Country country)
879     : d(findLocalePrivate(language, QLocale::AnyScript, country))
880 {
881 }
882 
883 /*!
884     \since 4.8
885 
886     Constructs a QLocale object with the specified \a language, \a script and
887     \a country.
888 
889     \list
890     \li If the language/script/country is found in the database, it is used.
891     \li If both \a script is AnyScript and \a country is AnyCountry, the
892        language is used with the most appropriate available script and country
893        (for example, Germany for German),
894     \li If either \a script is AnyScript or \a country is AnyCountry, the
895        language is used with the first locale that matches the given \a script
896        and \a country.
897     \li If neither the language nor the country are found, QLocale
898        defaults to the default locale (see setDefault()).
899     \endlist
900 
901     The language, script and country that are actually used can be queried
902     using language(), script() and country().
903 
904     \sa setDefault(), language(), script(), country()
905 */
906 
907 QLocale::QLocale(Language language, Script script, Country country)
908     : d(findLocalePrivate(language, script, country))
909 {
910 }
911 
912 /*!
913     Constructs a QLocale object as a copy of \a other.
914 */
915 
916 QLocale::QLocale(const QLocale &other)
917 {
918     d = other.d;
919 }
920 
921 /*!
922     Destructor
923 */
924 
925 QLocale::~QLocale()
926 {
927 }
928 
929 /*!
930     Assigns \a other to this QLocale object and returns a reference
931     to this QLocale object.
932 */
933 
934 QLocale &QLocale::operator=(const QLocale &other)
935 {
936     d = other.d;
937     return *this;
938 }
939 
940 bool QLocale::operator==(const QLocale &other) const
941 {
942     return d->m_data == other.d->m_data && d->m_numberOptions == other.d->m_numberOptions;
943 }
944 
945 bool QLocale::operator!=(const QLocale &other) const
946 {
947     return d->m_data != other.d->m_data || d->m_numberOptions != other.d->m_numberOptions;
948 }
949 
950 /*!
951     \fn void QLocale::swap(QLocale &other)
952     \since 5.6
953 
954     Swaps locale \a other with this locale. This operation is very fast and
955     never fails.
956 */
957 
958 /*!
959     \since 5.6
960     \relates QLocale
961 
962     Returns the hash value for \a key, using
963     \a seed to seed the calculation.
964 */
965 uint qHash(const QLocale &key, uint seed) Q_DECL_NOTHROW
966 {
967     QtPrivate::QHashCombine hash;
968     seed = hash(seed, key.d->m_data);
969     seed = hash(seed, key.d->m_numberOptions);
970     return seed;
971 }
972 
973 /*!
974     \since 4.2
975 
976     Sets the \a options related to number conversions for this
977     QLocale instance.
978 */
979 void QLocale::setNumberOptions(NumberOptions options)
980 {
981     d->m_numberOptions = options;
982 }
983 
984 /*!
985     \since 4.2
986 
987     Returns the options related to number conversions for this
988     QLocale instance.
989 
990     By default, no options are set for the standard locales.
991 */
992 QLocale::NumberOptions QLocale::numberOptions() const
993 {
994     return static_cast<NumberOptions>(d->m_numberOptions);
995 }
996 
997 /*!
998     \since 4.8
999 
1000     Returns \a str quoted according to the current locale using the given
1001     quotation \a style.
1002 */
1003 QString QLocale::quoteString(const QString &str, QuotationStyle style) const
1004 {
1005     return quoteString(QStringRef(&str), style);
1006 }
1007 
1008 /*!
1009     \since 4.8
1010 
1011     \overload
1012 */
1013 QString QLocale::quoteString(const QStringRef &str, QuotationStyle style) const
1014 {
1015 #ifndef QT_NO_SYSTEMLOCALE
1016     if (d->m_data == systemData()) {
1017         QVariant res;
1018         if (style == QLocale::AlternateQuotation)
1019             res = systemLocale()->query(QSystemLocale::StringToAlternateQuotation, QVariant::fromValue(str));
1020         if (res.isNull() || style == QLocale::StandardQuotation)
1021             res = systemLocale()->query(QSystemLocale::StringToStandardQuotation, QVariant::fromValue(str));
1022         if (!res.isNull())
1023             return res.toString();
1024     }
1025 #endif
1026 
1027     if (style == QLocale::StandardQuotation)
1028         return QChar(d->m_data->m_quotation_start) % str % QChar(d->m_data->m_quotation_end);
1029     else
1030         return QChar(d->m_data->m_alternate_quotation_start) % str % QChar(d->m_data->m_alternate_quotation_end);
1031 }
1032 
1033 /*!
1034     \since 4.8
1035 
1036     Returns a string that represents a join of a given \a list of strings with
1037     a separator defined by the locale.
1038 */
1039 QString QLocale::createSeparatedList(const QStringList &list) const
1040 {
1041 #ifndef QT_NO_SYSTEMLOCALE
1042     if (d->m_data == systemData()) {
1043         QVariant res;
1044         res = systemLocale()->query(QSystemLocale::ListToSeparatedString, QVariant::fromValue(list));
1045 
1046         if (!res.isNull())
1047             return res.toString();
1048     }
1049 #endif
1050 
1051     const int size = list.size();
1052     if (size == 1) {
1053         return list.at(0);
1054     } else if (size == 2) {
1055         QString format = getLocaleData(list_pattern_part_data + d->m_data->m_list_pattern_part_two_idx, d->m_data->m_list_pattern_part_two_size);
1056         return format.arg(list.at(0), list.at(1));
1057     } else if (size > 2) {
1058         QString formatStart = getLocaleData(list_pattern_part_data + d->m_data->m_list_pattern_part_start_idx, d->m_data->m_list_pattern_part_start_size);
1059         QString formatMid = getLocaleData(list_pattern_part_data + d->m_data->m_list_pattern_part_mid_idx, d->m_data->m_list_pattern_part_mid_size);
1060         QString formatEnd = getLocaleData(list_pattern_part_data + d->m_data->m_list_pattern_part_end_idx, d->m_data->m_list_pattern_part_end_size);
1061         QString result = formatStart.arg(list.at(0), list.at(1));
1062         for (int i = 2; i < size - 1; ++i)
1063             result = formatMid.arg(result, list.at(i));
1064         result = formatEnd.arg(result, list.at(size - 1));
1065         return result;
1066     }
1067 
1068     return QString();
1069 }
1070 
1071 /*!
1072     \nonreentrant
1073 
1074     Sets the global default locale to \a locale. These
1075     values are used when a QLocale object is constructed with
1076     no arguments. If this function is not called, the system's
1077     locale is used.
1078 
1079     \warning In a multithreaded application, the default locale
1080     should be set at application startup, before any non-GUI threads
1081     are created.
1082 
1083     \sa system(), c()
1084 */
1085 
1086 void QLocale::setDefault(const QLocale &locale)
1087 {
1088     default_data = locale.d->m_data;
1089     default_number_options = locale.numberOptions();
1090 
1091     if (defaultLocalePrivate.exists()) {
1092         // update the cached private
1093         *defaultLocalePrivate = locale.d;
1094     }
1095 }
1096 
1097 /*!
1098     Returns the language of this locale.
1099 
1100     \sa script(), country(), languageToString(), bcp47Name()
1101 */
1102 QLocale::Language QLocale::language() const
1103 {
1104     return Language(d->languageId());
1105 }
1106 
1107 /*!
1108     \since 4.8
1109 
1110     Returns the script of this locale.
1111 
1112     \sa language(), country(), languageToString(), scriptToString(), bcp47Name()
1113 */
1114 QLocale::Script QLocale::script() const
1115 {
1116     return Script(d->m_data->m_script_id);
1117 }
1118 
1119 /*!
1120     Returns the country of this locale.
1121 
1122     \sa language(), script(), countryToString(), bcp47Name()
1123 */
1124 QLocale::Country QLocale::country() const
1125 {
1126     return Country(d->countryId());
1127 }
1128 
1129 /*!
1130     Returns the language and country of this locale as a
1131     string of the form "language_country", where
1132     language is a lowercase, two-letter ISO 639 language code,
1133     and country is an uppercase, two- or three-letter ISO 3166 country code.
1134 
1135     Note that even if QLocale object was constructed with an explicit script,
1136     name() will not contain it for compatibility reasons. Use bcp47Name() instead
1137     if you need a full locale name.
1138 
1139     \sa QLocale(), language(), script(), country(), bcp47Name()
1140 */
1141 
1142 QString QLocale::name() const
1143 {
1144     Language l = language();
1145     if (l == C)
1146         return d->languageCode();
1147 
1148     Country c = country();
1149     if (c == AnyCountry)
1150         return d->languageCode();
1151 
1152     return d->languageCode() + QLatin1Char('_') + d->countryCode();
1153 }
1154 
1155 static qlonglong toIntegral_helper(const QLocaleData *d, QStringView str, bool *ok,
1156                                    QLocale::NumberOptions mode, qlonglong)
1157 {
1158     return d->stringToLongLong(str, 10, ok, mode);
1159 }
1160 
1161 static qulonglong toIntegral_helper(const QLocaleData *d, QStringView str, bool *ok,
1162                                     QLocale::NumberOptions mode, qulonglong)
1163 {
1164     return d->stringToUnsLongLong(str, 10, ok, mode);
1165 }
1166 
1167 template <typename T> static inline
1168 T toIntegral_helper(const QLocalePrivate *d, QStringView str, bool *ok)
1169 {
1170     // ### Qt6: use std::conditional<std::is_unsigned<T>::value, qulonglong, qlonglong>::type
1171     const bool isUnsigned = T(0) < T(-1);
1172     typedef typename QtPrivate::QConditional<isUnsigned, qulonglong, qlonglong>::Type Int64;
1173 
1174     // we select the right overload by the last, unused parameter
1175     Int64 val = toIntegral_helper(d->m_data, str, ok, d->m_numberOptions, Int64());
1176     if (T(val) != val) {
1177         if (ok)
1178             *ok = false;
1179         val = 0;
1180     }
1181     return T(val);
1182 }
1183 
1184 
1185 /*!
1186     \since 4.8
1187 
1188     Returns the dash-separated language, script and country (and possibly other BCP47 fields)
1189     of this locale as a string.
1190 
1191     Unlike the uiLanguages() the returned value of the bcp47Name() represents
1192     the locale name of the QLocale data but not the language the user-interface
1193     should be in.
1194 
1195     This function tries to conform the locale name to BCP47.
1196 
1197     \sa language(), country(), script(), uiLanguages()
1198 */
1199 QString QLocale::bcp47Name() const
1200 {
1201     return QString::fromLatin1(d->bcp47Name());
1202 }
1203 
1204 /*!
1205     Returns a QString containing the name of \a language.
1206 
1207     \sa countryToString(), scriptToString(), bcp47Name()
1208 */
1209 
1210 QString QLocale::languageToString(Language language)
1211 {
1212     if (uint(language) > uint(QLocale::LastLanguage))
1213         return QLatin1String("Unknown");
1214     return QLatin1String(language_name_list + language_name_index[language]);
1215 }
1216 
1217 /*!
1218     Returns a QString containing the name of \a country.
1219 
1220     \sa languageToString(), scriptToString(), country(), bcp47Name()
1221 */
1222 
1223 QString QLocale::countryToString(Country country)
1224 {
1225     if (uint(country) > uint(QLocale::LastCountry))
1226         return QLatin1String("Unknown");
1227     return QLatin1String(country_name_list + country_name_index[country]);
1228 }
1229 
1230 /*!
1231     \since 4.8
1232 
1233     Returns a QString containing the name of \a script.
1234 
1235     \sa languageToString(), countryToString(), script(), bcp47Name()
1236 */
1237 QString QLocale::scriptToString(QLocale::Script script)
1238 {
1239     if (uint(script) > uint(QLocale::LastScript))
1240         return QLatin1String("Unknown");
1241     return QLatin1String(script_name_list + script_name_index[script]);
1242 }
1243 
1244 #if QT_STRINGVIEW_LEVEL < 2
1245 /*!
1246     Returns the short int represented by the localized string \a s.
1247 
1248     If the conversion fails the function returns 0.
1249 
1250     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1251     to \c false, and success by setting *\a{ok} to \c true.
1252 
1253     This function ignores leading and trailing whitespace.
1254 
1255     \sa toUShort(), toString()
1256 */
1257 
1258 short QLocale::toShort(const QString &s, bool *ok) const
1259 {
1260     return toIntegral_helper<short>(d, s, ok);
1261 }
1262 
1263 /*!
1264     Returns the unsigned short int represented by the localized string \a s.
1265 
1266     If the conversion fails the function returns 0.
1267 
1268     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1269     to \c false, and success by setting *\a{ok} to \c true.
1270 
1271     This function ignores leading and trailing whitespace.
1272 
1273     \sa toShort(), toString()
1274 */
1275 
1276 ushort QLocale::toUShort(const QString &s, bool *ok) const
1277 {
1278     return toIntegral_helper<ushort>(d, s, ok);
1279 }
1280 
1281 /*!
1282     Returns the int represented by the localized string \a s.
1283 
1284     If the conversion fails the function returns 0.
1285 
1286     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1287     to \c false, and success by setting *\a{ok} to \c true.
1288 
1289     This function ignores leading and trailing whitespace.
1290 
1291     \sa toUInt(), toString()
1292 */
1293 
1294 int QLocale::toInt(const QString &s, bool *ok) const
1295 {
1296     return toIntegral_helper<int>(d, s, ok);
1297 }
1298 
1299 /*!
1300     Returns the unsigned int represented by the localized string \a s.
1301 
1302     If the conversion fails the function returns 0.
1303 
1304     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1305     to \c false, and success by setting *\a{ok} to \c true.
1306 
1307     This function ignores leading and trailing whitespace.
1308 
1309     \sa toInt(), toString()
1310 */
1311 
1312 uint QLocale::toUInt(const QString &s, bool *ok) const
1313 {
1314     return toIntegral_helper<uint>(d, s, ok);
1315 }
1316 
1317 /*!
1318     Returns the long long int represented by the localized string \a s.
1319 
1320     If the conversion fails the function returns 0.
1321 
1322     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1323     to \c false, and success by setting *\a{ok} to \c true.
1324 
1325     This function ignores leading and trailing whitespace.
1326 
1327     \sa toInt(), toULongLong(), toDouble(), toString()
1328 */
1329 
1330 
1331 qlonglong QLocale::toLongLong(const QString &s, bool *ok) const
1332 {
1333     return toIntegral_helper<qlonglong>(d, s, ok);
1334 }
1335 
1336 /*!
1337     Returns the unsigned long long int represented by the localized
1338     string \a s.
1339 
1340     If the conversion fails the function returns 0.
1341 
1342     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1343     to \c false, and success by setting *\a{ok} to \c true.
1344 
1345     This function ignores leading and trailing whitespace.
1346 
1347     \sa toLongLong(), toInt(), toDouble(), toString()
1348 */
1349 
1350 qulonglong QLocale::toULongLong(const QString &s, bool *ok) const
1351 {
1352     return toIntegral_helper<qulonglong>(d, s, ok);
1353 }
1354 
1355 /*!
1356     Returns the float represented by the localized string \a s, or 0.0
1357     if the conversion failed.
1358 
1359     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1360     to \c false, and success by setting *\a{ok} to \c true.
1361 
1362     This function does not fall back to the 'C' locale if the string
1363     cannot be interpreted in this locale.
1364 
1365     This function ignores leading and trailing whitespace.
1366 
1367     \sa toDouble(), toInt(), toString()
1368 */
1369 
1370 float QLocale::toFloat(const QString &s, bool *ok) const
1371 {
1372     return QLocaleData::convertDoubleToFloat(toDouble(s, ok), ok);
1373 }
1374 
1375 /*!
1376     Returns the double represented by the localized string \a s, or
1377     0.0 if the conversion failed.
1378 
1379     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1380     to \c false, and success by setting *\a{ok} to \c true.
1381 
1382     This function does not fall back to the 'C' locale if the string
1383     cannot be interpreted in this locale.
1384 
1385     \snippet code/src_corelib_tools_qlocale.cpp 3
1386 
1387     Notice that the last conversion returns 1234.0, because '.' is the
1388     thousands group separator in the German locale.
1389 
1390     This function ignores leading and trailing whitespace.
1391 
1392     \sa toFloat(), toInt(), toString()
1393 */
1394 
1395 double QLocale::toDouble(const QString &s, bool *ok) const
1396 {
1397     return d->m_data->stringToDouble(s, ok, d->m_numberOptions);
1398 }
1399 
1400 /*!
1401     Returns the short int represented by the localized string \a s.
1402 
1403     If the conversion fails the function returns 0.
1404 
1405     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1406     to \c false, and success by setting *\a{ok} to \c true.
1407 
1408     This function ignores leading and trailing whitespace.
1409 
1410     \sa toUShort(), toString()
1411 
1412     \since 5.1
1413 */
1414 
1415 short QLocale::toShort(const QStringRef &s, bool *ok) const
1416 {
1417     return toIntegral_helper<short>(d, s, ok);
1418 }
1419 
1420 /*!
1421     Returns the unsigned short int represented by the localized string \a s.
1422 
1423     If the conversion fails the function returns 0.
1424 
1425     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1426     to \c false, and success by setting *\a{ok} to \c true.
1427 
1428     This function ignores leading and trailing whitespace.
1429 
1430     \sa toShort(), toString()
1431 
1432     \since 5.1
1433 */
1434 
1435 ushort QLocale::toUShort(const QStringRef &s, bool *ok) const
1436 {
1437     return toIntegral_helper<ushort>(d, s, ok);
1438 }
1439 
1440 /*!
1441     Returns the int represented by the localized string \a s.
1442 
1443     If the conversion fails the function returns 0.
1444 
1445     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1446     to \c false, and success by setting *\a{ok} to \c true.
1447 
1448     This function ignores leading and trailing whitespace.
1449 
1450     \sa toUInt(), toString()
1451 
1452     \since 5.1
1453 */
1454 
1455 int QLocale::toInt(const QStringRef &s, bool *ok) const
1456 {
1457     return toIntegral_helper<int>(d, s, ok);
1458 }
1459 
1460 /*!
1461     Returns the unsigned int represented by the localized string \a s.
1462 
1463     If the conversion fails the function returns 0.
1464 
1465     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1466     to \c false, and success by setting *\a{ok} to \c true.
1467 
1468     This function ignores leading and trailing whitespace.
1469 
1470     \sa toInt(), toString()
1471 
1472     \since 5.1
1473 */
1474 
1475 uint QLocale::toUInt(const QStringRef &s, bool *ok) const
1476 {
1477     return toIntegral_helper<uint>(d, s, ok);
1478 }
1479 
1480 /*!
1481     Returns the long long int represented by the localized string \a s.
1482 
1483     If the conversion fails the function returns 0.
1484 
1485     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1486     to \c false, and success by setting *\a{ok} to \c true.
1487 
1488     This function ignores leading and trailing whitespace.
1489 
1490     \sa toInt(), toULongLong(), toDouble(), toString()
1491 
1492     \since 5.1
1493 */
1494 
1495 
1496 qlonglong QLocale::toLongLong(const QStringRef &s, bool *ok) const
1497 {
1498     return toIntegral_helper<qlonglong>(d, s, ok);
1499 }
1500 
1501 /*!
1502     Returns the unsigned long long int represented by the localized
1503     string \a s.
1504 
1505     If the conversion fails the function returns 0.
1506 
1507     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1508     to \c false, and success by setting *\a{ok} to \c true.
1509 
1510     This function ignores leading and trailing whitespace.
1511 
1512     \sa toLongLong(), toInt(), toDouble(), toString()
1513 
1514     \since 5.1
1515 */
1516 
1517 qulonglong QLocale::toULongLong(const QStringRef &s, bool *ok) const
1518 {
1519     return toIntegral_helper<qulonglong>(d, s, ok);
1520 }
1521 
1522 /*!
1523     Returns the float represented by the localized string \a s.
1524 
1525     Returns an infinity if the conversion overflows or 0.0 if the
1526     conversion fails for any other reason.
1527 
1528     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1529     to \c false, and success by setting *\a{ok} to \c true.
1530 
1531     This function does not fall back to the 'C' locale if the string
1532     cannot be interpreted in this locale.
1533 
1534     This function ignores leading and trailing whitespace.
1535 
1536     \sa toDouble(), toInt(), toString()
1537 
1538     \since 5.1
1539 */
1540 
1541 float QLocale::toFloat(const QStringRef &s, bool *ok) const
1542 {
1543     return QLocaleData::convertDoubleToFloat(toDouble(s, ok), ok);
1544 }
1545 
1546 /*!
1547     Returns the double represented by the localized string \a s.
1548 
1549     Returns an infinity if the conversion overflows or 0.0 if the
1550     conversion fails for any other reason.
1551 
1552     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1553     to \c false, and success by setting *\a{ok} to \c true.
1554 
1555     This function does not fall back to the 'C' locale if the string
1556     cannot be interpreted in this locale.
1557 
1558     \snippet code/src_corelib_tools_qlocale.cpp 3
1559 
1560     Notice that the last conversion returns 1234.0, because '.' is the
1561     thousands group separator in the German locale.
1562 
1563     This function ignores leading and trailing whitespace.
1564 
1565     \sa toFloat(), toInt(), toString()
1566 
1567     \since 5.1
1568 */
1569 
1570 double QLocale::toDouble(const QStringRef &s, bool *ok) const
1571 {
1572     return d->m_data->stringToDouble(s, ok, d->m_numberOptions);
1573 }
1574 #endif // QT_STRINGVIEW_LEVEL < 2
1575 
1576 /*!
1577     Returns the short int represented by the localized string \a s.
1578 
1579     If the conversion fails, the function returns 0.
1580 
1581     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1582     to \c false, and success by setting *\a{ok} to \c true.
1583 
1584     This function ignores leading and trailing whitespace.
1585 
1586     \sa toUShort(), toString()
1587 
1588     \since 5.10
1589 */
1590 
1591 short QLocale::toShort(QStringView s, bool *ok) const
1592 {
1593     return toIntegral_helper<short>(d, s, ok);
1594 }
1595 
1596 /*!
1597     Returns the unsigned short int represented by the localized string \a s.
1598 
1599     If the conversion fails, the function returns 0.
1600 
1601     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1602     to \c false, and success by setting *\a{ok} to \c true.
1603 
1604     This function ignores leading and trailing whitespace.
1605 
1606     \sa toShort(), toString()
1607 
1608     \since 5.10
1609 */
1610 
1611 ushort QLocale::toUShort(QStringView s, bool *ok) const
1612 {
1613     return toIntegral_helper<ushort>(d, s, ok);
1614 }
1615 
1616 /*!
1617     Returns the int represented by the localized string \a s.
1618 
1619     If the conversion fails, the function returns 0.
1620 
1621     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1622     to \c false, and success by setting *\a{ok} to \c true.
1623 
1624     This function ignores leading and trailing whitespace.
1625 
1626     \sa toUInt(), toString()
1627 
1628     \since 5.10
1629 */
1630 
1631 int QLocale::toInt(QStringView s, bool *ok) const
1632 {
1633     return toIntegral_helper<int>(d, s, ok);
1634 }
1635 
1636 /*!
1637     Returns the unsigned int represented by the localized string \a s.
1638 
1639     If the conversion fails, the function returns 0.
1640 
1641     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1642     to \c false, and success by setting *\a{ok} to \c true.
1643 
1644     This function ignores leading and trailing whitespace.
1645 
1646     \sa toInt(), toString()
1647 
1648     \since 5.10
1649 */
1650 
1651 uint QLocale::toUInt(QStringView s, bool *ok) const
1652 {
1653     return toIntegral_helper<uint>(d, s, ok);
1654 }
1655 
1656 /*!
1657     Returns the long long int represented by the localized string \a s.
1658 
1659     If the conversion fails, the function returns 0.
1660 
1661     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1662     to \c false, and success by setting *\a{ok} to \c true.
1663 
1664     This function ignores leading and trailing whitespace.
1665 
1666     \sa toInt(), toULongLong(), toDouble(), toString()
1667 
1668     \since 5.10
1669 */
1670 
1671 
1672 qlonglong QLocale::toLongLong(QStringView s, bool *ok) const
1673 {
1674     return toIntegral_helper<qlonglong>(d, s, ok);
1675 }
1676 
1677 /*!
1678     Returns the unsigned long long int represented by the localized
1679     string \a s.
1680 
1681     If the conversion fails, the function returns 0.
1682 
1683     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1684     to \c false, and success by setting *\a{ok} to \c true.
1685 
1686     This function ignores leading and trailing whitespace.
1687 
1688     \sa toLongLong(), toInt(), toDouble(), toString()
1689 
1690     \since 5.10
1691 */
1692 
1693 qulonglong QLocale::toULongLong(QStringView s, bool *ok) const
1694 {
1695     return toIntegral_helper<qulonglong>(d, s, ok);
1696 }
1697 
1698 /*!
1699     Returns the float represented by the localized string \a s.
1700 
1701     Returns an infinity if the conversion overflows or 0.0 if the
1702     conversion fails for any other reason.
1703 
1704     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1705     to \c false, and success by setting *\a{ok} to \c true.
1706 
1707     This function ignores leading and trailing whitespace.
1708 
1709     \sa toDouble(), toInt(), toString()
1710 
1711     \since 5.10
1712 */
1713 
1714 float QLocale::toFloat(QStringView s, bool *ok) const
1715 {
1716     return QLocaleData::convertDoubleToFloat(toDouble(s, ok), ok);
1717 }
1718 
1719 /*!
1720     Returns the double represented by the localized string \a s.
1721 
1722     Returns an infinity if the conversion overflows or 0.0 if the
1723     conversion fails for any other reason.
1724 
1725     If \a ok is not \c nullptr, failure is reported by setting *\a{ok}
1726     to \c false, and success by setting *\a{ok} to \c true.
1727 
1728     Unlike QString::toDouble(), this function does not fall back to
1729     the "C" locale if the string cannot be interpreted in this
1730     locale.
1731 
1732     \snippet code/src_corelib_tools_qlocale.cpp 3-qstringview
1733 
1734     Notice that the last conversion returns 1234.0, because '.' is the
1735     thousands group separator in the German locale.
1736 
1737     This function ignores leading and trailing whitespace.
1738 
1739     \sa toFloat(), toInt(), toString()
1740 
1741     \since 5.10
1742 */
1743 
1744 double QLocale::toDouble(QStringView s, bool *ok) const
1745 {
1746     return d->m_data->stringToDouble(s, ok, d->m_numberOptions);
1747 }
1748 
1749 /*!
1750     Returns a localized string representation of \a i.
1751 
1752     \sa toLongLong()
1753 */
1754 
1755 QString QLocale::toString(qlonglong i) const
1756 {
1757     int flags = d->m_numberOptions & OmitGroupSeparator
1758                     ? 0
1759                     : QLocaleData::ThousandsGroup;
1760 
1761     return d->m_data->longLongToString(i, -1, 10, -1, flags);
1762 }
1763 
1764 /*!
1765     \overload
1766 
1767     \sa toULongLong()
1768 */
1769 
1770 QString QLocale::toString(qulonglong i) const
1771 {
1772     int flags = d->m_numberOptions & OmitGroupSeparator
1773                     ? 0
1774                     : QLocaleData::ThousandsGroup;
1775 
1776     return d->m_data->unsLongLongToString(i, -1, 10, -1, flags);
1777 }
1778 
1779 #if QT_STRINGVIEW_LEVEL < 2
1780 /*!
1781     Returns a localized string representation of the given \a date in the
1782     specified \a format.
1783     If \a format is an empty string, an empty string is returned.
1784 
1785     \sa QDate::toString()
1786 */
1787 
1788 QString QLocale::toString(const QDate &date, const QString &format) const
1789 {
1790     return d->dateTimeToString(format, QDateTime(), date, QTime(), this);
1791 }
1792 #endif
1793 
1794 /*!
1795     \since 5.10
1796 
1797     Returns a localized string representation of the given \a date in the
1798     specified \a format.
1799     If \a format is an empty string, an empty string is returned.
1800 
1801     \sa QDate::toString()
1802 */
1803 QString QLocale::toString(const QDate &date, QStringView format) const
1804 {
1805     return d->dateTimeToString(format, QDateTime(), date, QTime(), this);
1806 }
1807 
1808 /*!
1809     Returns a localized string representation of the given \a date according
1810     to the specified \a format.
1811 */
1812 
1813 QString QLocale::toString(const QDate &date, FormatType format) const
1814 {
1815     if (!date.isValid())
1816         return QString();
1817 
1818 #ifndef QT_NO_SYSTEMLOCALE
1819     if (d->m_data == systemData()) {
1820         QVariant res = systemLocale()->query(format == LongFormat
1821                                              ? QSystemLocale::DateToStringLong : QSystemLocale::DateToStringShort,
1822                                              date);
1823         if (!res.isNull())
1824             return res.toString();
1825     }
1826 #endif
1827 
1828     QString format_str = dateFormat(format);
1829     return toString(date, format_str);
1830 }
1831 
1832 static bool timeFormatContainsAP(QStringView format)
1833 {
1834     int i = 0;
1835     while (i < format.size()) {
1836         if (format.at(i).unicode() == '\'') {
1837             qt_readEscapedFormatString(format, &i);
1838             continue;
1839         }
1840 
1841         if (format.at(i).toLower().unicode() == 'a')
1842             return true;
1843 
1844         ++i;
1845     }
1846     return false;
1847 }
1848 
1849 #if QT_STRINGVIEW_LEVEL < 2
1850 /*!
1851     Returns a localized string representation of the given \a time according
1852     to the specified \a format.
1853     If \a format is an empty string, an empty string is returned.
1854 
1855     \sa QTime::toString()
1856 */
1857 QString QLocale::toString(const QTime &time, const QString &format) const
1858 {
1859     return d->dateTimeToString(format, QDateTime(), QDate(), time, this);
1860 }
1861 #endif
1862 
1863 /*!
1864     \since 5.10
1865 
1866     Returns a localized string representation of the given \a time according
1867     to the specified \a format.
1868     If \a format is an empty string, an empty string is returned.
1869 
1870     \sa QTime::toString()
1871 */
1872 QString QLocale::toString(const QTime &time, QStringView format) const
1873 {
1874     return d->dateTimeToString(format, QDateTime(), QDate(), time, this);
1875 }
1876 
1877 #if QT_STRINGVIEW_LEVEL < 2
1878 /*!
1879     \since 4.4
1880 
1881     Returns a localized string representation of the given \a dateTime according
1882     to the specified \a format.
1883     If \a format is an empty string, an empty string is returned.
1884 
1885     \sa QDateTime::toString(), QDate::toString(), QTime::toString()
1886 */
1887 
1888 QString QLocale::toString(const QDateTime &dateTime, const QString &format) const
1889 {
1890     return d->dateTimeToString(format, dateTime, QDate(), QTime(), this);
1891 }
1892 #endif
1893 
1894 /*!
1895     \since 5.10
1896 
1897     Returns a localized string representation of the given \a dateTime according
1898     to the specified \a format.
1899     If \a format is an empty string, an empty string is returned.
1900 
1901     \sa QDateTime::toString(), QDate::toString(), QTime::toString()
1902 */
1903 QString QLocale::toString(const QDateTime &dateTime, QStringView format) const
1904 {
1905     return d->dateTimeToString(format, dateTime, QDate(), QTime(), this);
1906 }
1907 
1908 /*!
1909     \since 4.4
1910 
1911     Returns a localized string representation of the given \a dateTime according
1912     to the specified \a format.
1913 */
1914 
1915 QString QLocale::toString(const QDateTime &dateTime, FormatType format) const
1916 {
1917     if (!dateTime.isValid())
1918         return QString();
1919 
1920 #ifndef QT_NO_SYSTEMLOCALE
1921     if (d->m_data == systemData()) {
1922         QVariant res = systemLocale()->query(format == LongFormat
1923                                              ? QSystemLocale::DateTimeToStringLong
1924                                              : QSystemLocale::DateTimeToStringShort,
1925                                              dateTime);
1926         if (!res.isNull())
1927             return res.toString();
1928     }
1929 #endif
1930 
1931     const QString format_str = dateTimeFormat(format);
1932     return toString(dateTime, format_str);
1933 }
1934 
1935 
1936 /*!
1937     Returns a localized string representation of the given \a time in the
1938     specified \a format.
1939 */
1940 
1941 QString QLocale::toString(const QTime &time, FormatType format) const
1942 {
1943     if (!time.isValid())
1944         return QString();
1945 
1946 #ifndef QT_NO_SYSTEMLOCALE
1947     if (d->m_data == systemData()) {
1948         QVariant res = systemLocale()->query(format == LongFormat
1949                                              ? QSystemLocale::TimeToStringLong : QSystemLocale::TimeToStringShort,
1950                                              time);
1951         if (!res.isNull())
1952             return res.toString();
1953     }
1954 #endif
1955 
1956     QString format_str = timeFormat(format);
1957     return toString(time, format_str);
1958 }
1959 
1960 /*!
1961     \since 4.1
1962 
1963     Returns the date format used for the current locale.
1964 
1965     If \a format is LongFormat the format will be a long version.
1966     Otherwise it uses a shorter version.
1967 
1968     \sa QDate::toString(), QDate::fromString()
1969 */
1970 
1971 QString QLocale::dateFormat(FormatType format) const
1972 {
1973 #ifndef QT_NO_SYSTEMLOCALE
1974     if (d->m_data == systemData()) {
1975         QVariant res = systemLocale()->query(format == LongFormat
1976                                              ? QSystemLocale::DateFormatLong : QSystemLocale::DateFormatShort,
1977                                              QVariant());
1978         if (!res.isNull())
1979             return res.toString();
1980     }
1981 #endif
1982 
1983     quint32 idx, size;
1984     switch (format) {
1985     case LongFormat:
1986         idx = d->m_data->m_long_date_format_idx;
1987         size = d->m_data->m_long_date_format_size;
1988         break;
1989     default:
1990         idx = d->m_data->m_short_date_format_idx;
1991         size = d->m_data->m_short_date_format_size;
1992         break;
1993     }
1994     return getLocaleData(date_format_data + idx, size);
1995 }
1996 
1997 /*!
1998     \since 4.1
1999 
2000     Returns the time format used for the current locale.
2001 
2002     If \a format is LongFormat the format will be a long version.
2003     Otherwise it uses a shorter version.
2004 
2005     \sa QTime::toString(), QTime::fromString()
2006 */
2007 
2008 QString QLocale::timeFormat(FormatType format) const
2009 {
2010 #ifndef QT_NO_SYSTEMLOCALE
2011     if (d->m_data == systemData()) {
2012         QVariant res = systemLocale()->query(format == LongFormat
2013                                              ? QSystemLocale::TimeFormatLong : QSystemLocale::TimeFormatShort,
2014                                              QVariant());
2015         if (!res.isNull())
2016             return res.toString();
2017     }
2018 #endif
2019 
2020     quint32 idx, size;
2021     switch (format) {
2022     case LongFormat:
2023         idx = d->m_data->m_long_time_format_idx;
2024         size = d->m_data->m_long_time_format_size;
2025         break;
2026     default:
2027         idx = d->m_data->m_short_time_format_idx;
2028         size = d->m_data->m_short_time_format_size;
2029         break;
2030     }
2031     return getLocaleData(time_format_data + idx, size);
2032 }
2033 
2034 /*!
2035     \since 4.4
2036 
2037     Returns the date time format used for the current locale.
2038 
2039     If \a format is ShortFormat the format will be a short version.
2040     Otherwise it uses a longer version.
2041 
2042     \sa QDateTime::toString(), QDateTime::fromString()
2043 */
2044 
2045 QString QLocale::dateTimeFormat(FormatType format) const
2046 {
2047 #ifndef QT_NO_SYSTEMLOCALE
2048     if (d->m_data == systemData()) {
2049         QVariant res = systemLocale()->query(format == LongFormat
2050                                              ? QSystemLocale::DateTimeFormatLong
2051                                              : QSystemLocale::DateTimeFormatShort,
2052                                              QVariant());
2053         if (!res.isNull()) {
2054             return res.toString();
2055         }
2056     }
2057 #endif
2058     return dateFormat(format) + QLatin1Char(' ') + timeFormat(format);
2059 }
2060 
2061 /*!
2062     \since 4.4
2063 
2064     Parses the time string given in \a string and returns the
2065     time. The format of the time string is chosen according to the
2066     \a format parameter (see timeFormat()).
2067 
2068     If the time could not be parsed, returns an invalid time.
2069 
2070     \sa timeFormat(), toDate(), toDateTime(), QTime::fromString()
2071 */
2072 #if QT_CONFIG(datestring)
2073 QTime QLocale::toTime(const QString &string, FormatType format) const
2074 {
2075     return toTime(string, timeFormat(format));
2076 }
2077 #endif
2078 
2079 /*!
2080     \since 4.4
2081 
2082     Parses the date string given in \a string and returns the
2083     date. The format of the date string is chosen according to the
2084     \a format parameter (see dateFormat()).
2085 
2086     If the date could not be parsed, returns an invalid date.
2087 
2088     \sa dateFormat(), toTime(), toDateTime(), QDate::fromString()
2089 */
2090 #if QT_CONFIG(datestring)
2091 QDate QLocale::toDate(const QString &string, FormatType format) const
2092 {
2093     return toDate(string, dateFormat(format));
2094 }
2095 #endif
2096 
2097 /*!
2098     \since 4.4
2099 
2100     Parses the date/time string given in \a string and returns the
2101     time. The format of the date/time string is chosen according to the
2102     \a format parameter (see dateTimeFormat()).
2103 
2104     If the string could not be parsed, returns an invalid QDateTime.
2105 
2106     \sa dateTimeFormat(), toTime(), toDate(), QDateTime::fromString()
2107 */
2108 
2109 #if QT_CONFIG(datestring)
2110 QDateTime QLocale::toDateTime(const QString &string, FormatType format) const
2111 {
2112     return toDateTime(string, dateTimeFormat(format));
2113 }
2114 #endif
2115 
2116 /*!
2117     \since 4.4
2118 
2119     Parses the time string given in \a string and returns the
2120     time. See QTime::fromString() for information on what is a valid
2121     format string.
2122 
2123     If the time could not be parsed, returns an invalid time.
2124 
2125     \sa timeFormat(), toDate(), toDateTime(), QTime::fromString()
2126 */
2127 #if QT_CONFIG(datestring)
2128 QTime QLocale::toTime(const QString &string, const QString &format) const
2129 {
2130     QTime time;
2131 #if QT_CONFIG(datetimeparser)
2132     QDateTimeParser dt(QVariant::Time, QDateTimeParser::FromString);
2133     dt.setDefaultLocale(*this);
2134     if (dt.parseFormat(format))
2135         dt.fromString(string, 0, &time);
2136 #else
2137     Q_UNUSED(string);
2138     Q_UNUSED(format);
2139 #endif
2140     return time;
2141 }
2142 #endif
2143 
2144 /*!
2145     \since 4.4
2146 
2147     Parses the date string given in \a string and returns the
2148     date. See QDate::fromString() for information on the expressions
2149     that can be used with this function.
2150 
2151     This function searches month names and the names of the days of
2152     the week in the current locale.
2153 
2154     If the date could not be parsed, returns an invalid date.
2155 
2156     \sa dateFormat(), toTime(), toDateTime(), QDate::fromString()
2157 */
2158 #if QT_CONFIG(datestring)
2159 QDate QLocale::toDate(const QString &string, const QString &format) const
2160 {
2161     QDate date;
2162 #if QT_CONFIG(datetimeparser)
2163     QDateTimeParser dt(QVariant::Date, QDateTimeParser::FromString);
2164     dt.setDefaultLocale(*this);
2165     if (dt.parseFormat(format))
2166         dt.fromString(string, &date, 0);
2167 #else
2168     Q_UNUSED(string);
2169     Q_UNUSED(format);
2170 #endif
2171     return date;
2172 }
2173 #endif
2174 
2175 /*!
2176     \since 4.4
2177 
2178     Parses the date/time string given in \a string and returns the
2179     time.  See QDateTime::fromString() for information on the expressions
2180     that can be used with this function.
2181 
2182     \note The month and day names used must be given in the user's local
2183     language.
2184 
2185     If the string could not be parsed, returns an invalid QDateTime.
2186 
2187     \sa dateTimeFormat(), toTime(), toDate(), QDateTime::fromString()
2188 */
2189 #if QT_CONFIG(datestring)
2190 QDateTime QLocale::toDateTime(const QString &string, const QString &format) const
2191 {
2192 #if QT_CONFIG(datetimeparser)
2193     QTime time;
2194     QDate date;
2195 
2196     QDateTimeParser dt(QVariant::DateTime, QDateTimeParser::FromString);
2197     dt.setDefaultLocale(*this);
2198     if (dt.parseFormat(format) && dt.fromString(string, &date, &time))
2199         return QDateTime(date, time);
2200 #else
2201     Q_UNUSED(string);
2202     Q_UNUSED(format);
2203 #endif
2204     return QDateTime(QDate(), QTime(-1, -1, -1));
2205 }
2206 #endif
2207 
2208 
2209 /*!
2210     \since 4.1
2211 
2212     Returns the decimal point character of this locale.
2213 */
2214 QChar QLocale::decimalPoint() const
2215 {
2216     return d->decimal();
2217 }
2218 
2219 /*!
2220     \since 4.1
2221 
2222     Returns the group separator character of this locale.
2223 */
2224 QChar QLocale::groupSeparator() const
2225 {
2226     return d->group();
2227 }
2228 
2229 /*!
2230     \since 4.1
2231 
2232     Returns the percent character of this locale.
2233 */
2234 QChar QLocale::percent() const
2235 {
2236     return d->percent();
2237 }
2238 
2239 /*!
2240     \since 4.1
2241 
2242     Returns the zero digit character of this locale.
2243 */
2244 QChar QLocale::zeroDigit() const
2245 {
2246     return d->zero();
2247 }
2248 
2249 /*!
2250     \since 4.1
2251 
2252     Returns the negative sign character of this locale.
2253 */
2254 QChar QLocale::negativeSign() const
2255 {
2256     return d->minus();
2257 }
2258 
2259 /*!
2260     \since 4.5
2261 
2262     Returns the positive sign character of this locale.
2263 */
2264 QChar QLocale::positiveSign() const
2265 {
2266     return d->plus();
2267 }
2268 
2269 /*!
2270     \since 4.1
2271 
2272     Returns the exponential character of this locale.
2273 */
2274 QChar QLocale::exponential() const
2275 {
2276     return d->exponential();
2277 }
2278 
2279 static bool qIsUpper(char c)
2280 {
2281     return c >= 'A' && c <= 'Z';
2282 }
2283 
2284 static char qToLower(char c)
2285 {
2286     if (c >= 'A' && c <= 'Z')
2287         return c - 'A' + 'a';
2288     else
2289         return c;
2290 }
2291 
2292 /*!
2293     \overload
2294 
2295     \a f and \a prec have the same meaning as in QString::number(double, char, int).
2296 
2297     \sa toDouble()
2298 */
2299 
2300 QString QLocale::toString(double i, char f, int prec) const
2301 {
2302     QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
2303     uint flags = 0;
2304 
2305     if (qIsUpper(f))
2306         flags = QLocaleData::CapitalEorX;
2307     f = qToLower(f);
2308 
2309     switch (f) {
2310         case 'f':
2311             form = QLocaleData::DFDecimal;
2312             break;
2313         case 'e':
2314             form = QLocaleData::DFExponent;
2315             break;
2316         case 'g':
2317             form = QLocaleData::DFSignificantDigits;
2318             break;
2319         default:
2320             break;
2321     }
2322 
2323     if (!(d->m_numberOptions & OmitGroupSeparator))
2324         flags |= QLocaleData::ThousandsGroup;
2325     if (!(d->m_numberOptions & OmitLeadingZeroInExponent))
2326         flags |= QLocaleData::ZeroPadExponent;
2327     if (d->m_numberOptions & IncludeTrailingZeroesAfterDot)
2328         flags |= QLocaleData::AddTrailingZeroes;
2329     return d->m_data->doubleToString(i, prec, form, -1, flags);
2330 }
2331 
2332 /*!
2333     \fn QLocale QLocale::c()
2334 
2335     Returns a QLocale object initialized to the "C" locale.
2336 
2337     \sa system()
2338 */
2339 
2340 /*!
2341     Returns a QLocale object initialized to the system locale.
2342 
2343     On Windows and Mac, this locale will use the decimal/grouping characters and date/time
2344     formats specified in the system configuration panel.
2345 
2346     \sa c()
2347 */
2348 
2349 QLocale QLocale::system()
2350 {
2351     return QLocale(*QLocalePrivate::create(systemData()));
2352 }
2353 
2354 
2355 /*!
2356     \since 4.8
2357 
2358     Returns a list of valid locale objects that match the given \a language, \a
2359     script and \a country.
2360 
2361     Getting a list of all locales:
2362     QList<QLocale> allLocales = QLocale::matchingLocales(QLocale::AnyLanguage, QLocale::AnyScript, QLocale::AnyCountry);
2363 
2364     Getting a list of locales suitable for Russia:
2365     QList<QLocale> locales = QLocale::matchingLocales(QLocale::AnyLanguage, QLocale::AnyScript, QLocale::Russia);
2366 */
2367 QList<QLocale> QLocale::matchingLocales(QLocale::Language language,
2368                                         QLocale::Script script,
2369                                         QLocale::Country country)
2370 {
2371     if (uint(language) > QLocale::LastLanguage || uint(script) > QLocale::LastScript ||
2372             uint(country) > QLocale::LastCountry)
2373         return QList<QLocale>();
2374 
2375     if (language == QLocale::C)
2376         return QList<QLocale>() << QLocale(QLocale::C);
2377 
2378     QList<QLocale> result;
2379     if (language == QLocale::AnyLanguage && script == QLocale::AnyScript && country == QLocale::AnyCountry)
2380         result.reserve(locale_data_size);
2381     const QLocaleData *data = locale_data + locale_index[language];
2382     while ( (data != locale_data + locale_data_size)
2383             && (language == QLocale::AnyLanguage || data->m_language_id == uint(language))) {
2384         if ((script == QLocale::AnyScript || data->m_script_id == uint(script))
2385             && (country == QLocale::AnyCountry || data->m_country_id == uint(country))) {
2386             result.append(QLocale(*(data->m_language_id == C ? c_private()
2387                                     : QLocalePrivate::create(data))));
2388         }
2389         ++data;
2390     }
2391     return result;
2392 }
2393 
2394 /*!
2395     \obsolete
2396     \since 4.3
2397 
2398     Returns the list of countries that have entries for \a language in Qt's locale
2399     database. If the result is an empty list, then \a language is not represented in
2400     Qt's locale database.
2401 
2402     \sa matchingLocales()
2403 */
2404 QList<QLocale::Country> QLocale::countriesForLanguage(Language language)
2405 {
2406     QList<Country> result;
2407     if (language == C) {
2408         result << AnyCountry;
2409         return result;
2410     }
2411 
2412     unsigned language_id = language;
2413     const QLocaleData *data = locale_data + locale_index[language_id];
2414     while (data->m_language_id == language_id) {
2415         const QLocale::Country country = static_cast<Country>(data->m_country_id);
2416         if (!result.contains(country))
2417             result.append(country);
2418         ++data;
2419     }
2420 
2421     return result;
2422 }
2423 
2424 /*!
2425     \since 4.2
2426 
2427     Returns the localized name of \a month, in the format specified
2428     by \a type.
2429 
2430     \sa dayName(), standaloneMonthName()
2431 */
2432 QString QLocale::monthName(int month, FormatType type) const
2433 {
2434     if (month < 1 || month > 12)
2435         return QString();
2436 
2437 #ifndef QT_NO_SYSTEMLOCALE
2438     if (d->m_data == systemData()) {
2439         QVariant res = systemLocale()->query(type == LongFormat
2440                                              ? QSystemLocale::MonthNameLong : QSystemLocale::MonthNameShort,
2441                                              month);
2442         if (!res.isNull())
2443             return res.toString();
2444     }
2445 #endif
2446 
2447     quint32 idx, size;
2448     switch (type) {
2449     case QLocale::LongFormat:
2450         idx = d->m_data->m_long_month_names_idx;
2451         size = d->m_data->m_long_month_names_size;
2452         break;
2453     case QLocale::ShortFormat:
2454         idx = d->m_data->m_short_month_names_idx;
2455         size = d->m_data->m_short_month_names_size;
2456         break;
2457     case QLocale::NarrowFormat:
2458         idx = d->m_data->m_narrow_month_names_idx;
2459         size = d->m_data->m_narrow_month_names_size;
2460         break;
2461     default:
2462         return QString();
2463     }
2464     return getLocaleListData(months_data + idx, size, month - 1);
2465 }
2466 
2467 /*!
2468     \since 4.5
2469 
2470     Returns the localized name of \a month that is used as a
2471     standalone text, in the format specified by \a type.
2472 
2473     If the locale information doesn't specify the standalone month
2474     name then return value is the same as in monthName().
2475 
2476     \sa monthName(), standaloneDayName()
2477 */
2478 QString QLocale::standaloneMonthName(int month, FormatType type) const
2479 {
2480     if (month < 1 || month > 12)
2481         return QString();
2482 
2483 #ifndef QT_NO_SYSTEMLOCALE
2484     if (d->m_data == systemData()) {
2485         QVariant res = systemLocale()->query(type == LongFormat
2486                                              ? QSystemLocale::StandaloneMonthNameLong : QSystemLocale::StandaloneMonthNameShort,
2487                                              month);
2488         if (!res.isNull())
2489             return res.toString();
2490     }
2491 #endif
2492 
2493     quint32 idx, size;
2494     switch (type) {
2495     case QLocale::LongFormat:
2496         idx = d->m_data->m_standalone_long_month_names_idx;
2497         size = d->m_data->m_standalone_long_month_names_size;
2498         break;
2499     case QLocale::ShortFormat:
2500         idx = d->m_data->m_standalone_short_month_names_idx;
2501         size = d->m_data->m_standalone_short_month_names_size;
2502         break;
2503     case QLocale::NarrowFormat:
2504         idx = d->m_data->m_standalone_narrow_month_names_idx;
2505         size = d->m_data->m_standalone_narrow_month_names_size;
2506         break;
2507     default:
2508         return QString();
2509     }
2510     QString name = getLocaleListData(months_data + idx, size, month - 1);
2511     if (name.isEmpty())
2512         return monthName(month, type);
2513     return name;
2514 }
2515 
2516 /*!
2517     \since 4.2
2518 
2519     Returns the localized name of the \a day (where 1 represents
2520     Monday, 2 represents Tuesday and so on), in the format specified
2521     by \a type.
2522 
2523     \sa monthName(), standaloneDayName()
2524 */
2525 QString QLocale::dayName(int day, FormatType type) const
2526 {
2527     if (day < 1 || day > 7)
2528         return QString();
2529 
2530 #ifndef QT_NO_SYSTEMLOCALE
2531     if (d->m_data == systemData()) {
2532         QVariant res = systemLocale()->query(type == LongFormat
2533                                              ? QSystemLocale::DayNameLong : QSystemLocale::DayNameShort,
2534                                              day);
2535         if (!res.isNull())
2536             return res.toString();
2537     }
2538 #endif
2539     if (day == 7)
2540         day = 0;
2541 
2542     quint32 idx, size;
2543     switch (type) {
2544     case QLocale::LongFormat:
2545         idx = d->m_data->m_long_day_names_idx;
2546         size = d->m_data->m_long_day_names_size;
2547         break;
2548     case QLocale::ShortFormat:
2549         idx = d->m_data->m_short_day_names_idx;
2550         size = d->m_data->m_short_day_names_size;
2551         break;
2552     case QLocale::NarrowFormat:
2553         idx = d->m_data->m_narrow_day_names_idx;
2554         size = d->m_data->m_narrow_day_names_size;
2555         break;
2556     default:
2557         return QString();
2558     }
2559     return getLocaleListData(days_data + idx, size, day);
2560 }
2561 
2562 /*!
2563     \since 4.5
2564 
2565     Returns the localized name of the \a day (where 1 represents
2566     Monday, 2 represents Tuesday and so on) that is used as a
2567     standalone text, in the format specified by \a type.
2568 
2569     If the locale information does not specify the standalone day
2570     name then return value is the same as in dayName().
2571 
2572     \sa dayName(), standaloneMonthName()
2573 */
2574 QString QLocale::standaloneDayName(int day, FormatType type) const
2575 {
2576     if (day < 1 || day > 7)
2577         return QString();
2578 
2579 #ifndef QT_NO_SYSTEMLOCALE
2580     if (d->m_data == systemData()) {
2581         QVariant res = systemLocale()->query(type == LongFormat
2582                                              ? QSystemLocale::DayNameLong : QSystemLocale::DayNameShort,
2583                                              day);
2584         if (!res.isNull())
2585             return res.toString();
2586     }
2587 #endif
2588     if (day == 7)
2589         day = 0;
2590 
2591     quint32 idx, size;
2592     switch (type) {
2593     case QLocale::LongFormat:
2594         idx = d->m_data->m_standalone_long_day_names_idx;
2595         size = d->m_data->m_standalone_long_day_names_size;
2596         break;
2597     case QLocale::ShortFormat:
2598         idx = d->m_data->m_standalone_short_day_names_idx;
2599         size = d->m_data->m_standalone_short_day_names_size;
2600         break;
2601     case QLocale::NarrowFormat:
2602         idx = d->m_data->m_standalone_narrow_day_names_idx;
2603         size = d->m_data->m_standalone_narrow_day_names_size;
2604         break;
2605     default:
2606         return QString();
2607     }
2608     QString name = getLocaleListData(days_data + idx, size, day);
2609     if (name.isEmpty())
2610         return dayName(day == 0 ? 7 : day, type);
2611     return name;
2612 }
2613 
2614 /*!
2615     \since 4.8
2616 
2617     Returns the first day of the week according to the current locale.
2618 */
2619 Qt::DayOfWeek QLocale::firstDayOfWeek() const
2620 {
2621 #ifndef QT_NO_SYSTEMLOCALE
2622     if (d->m_data == systemData()) {
2623         QVariant res = systemLocale()->query(QSystemLocale::FirstDayOfWeek, QVariant());
2624         if (!res.isNull())
2625             return static_cast<Qt::DayOfWeek>(res.toUInt());
2626     }
2627 #endif
2628     return static_cast<Qt::DayOfWeek>(d->m_data->m_first_day_of_week);
2629 }
2630 
2631 QLocale::MeasurementSystem QLocalePrivate::measurementSystem() const
2632 {
2633     for (int i = 0; i < ImperialMeasurementSystemsCount; ++i) {
2634         if (ImperialMeasurementSystems[i].languageId == m_data->m_language_id
2635             && ImperialMeasurementSystems[i].countryId == m_data->m_country_id) {
2636             return ImperialMeasurementSystems[i].system;
2637         }
2638     }
2639     return QLocale::MetricSystem;
2640 }
2641 
2642 /*!
2643     \since 4.8
2644 
2645     Returns a list of days that are considered weekdays according to the current locale.
2646 */
2647 QList<Qt::DayOfWeek> QLocale::weekdays() const
2648 {
2649 #ifndef QT_NO_SYSTEMLOCALE
2650     if (d->m_data == systemData()) {
2651         QVariant res = systemLocale()->query(QSystemLocale::Weekdays, QVariant());
2652         if (!res.isNull())
2653             return static_cast<QList<Qt::DayOfWeek> >(res.value<QList<Qt::DayOfWeek> >());
2654     }
2655 #endif
2656     QList<Qt::DayOfWeek> weekdays;
2657     quint16 weekendStart = d->m_data->m_weekend_start;
2658     quint16 weekendEnd = d->m_data->m_weekend_end;
2659     for (int day = Qt::Monday; day <= Qt::Sunday; day++) {
2660         if ((weekendEnd >= weekendStart && (day < weekendStart || day > weekendEnd)) ||
2661             (weekendEnd < weekendStart && (day > weekendEnd && day < weekendStart)))
2662                 weekdays << static_cast<Qt::DayOfWeek>(day);
2663     }
2664     return weekdays;
2665 }
2666 
2667 /*!
2668     \since 4.4
2669 
2670     Returns the measurement system for the locale.
2671 */
2672 QLocale::MeasurementSystem QLocale::measurementSystem() const
2673 {
2674 #ifndef QT_NO_SYSTEMLOCALE
2675     if (d->m_data == systemData()) {
2676         QVariant res = systemLocale()->query(QSystemLocale::MeasurementSystem, QVariant());
2677         if (!res.isNull())
2678             return MeasurementSystem(res.toInt());
2679     }
2680 #endif
2681 
2682     return d->measurementSystem();
2683 }
2684 
2685 /*!
2686   \since 4.7
2687 
2688   Returns the text direction of the language.
2689 */
2690 Qt::LayoutDirection QLocale::textDirection() const
2691 {
2692     switch (script()) {
2693     case QLocale::AdlamScript:
2694     case QLocale::ArabicScript:
2695     case QLocale::AvestanScript:
2696     case QLocale::CypriotScript:
2697     case QLocale::HatranScript:
2698     case QLocale::HebrewScript:
2699     case QLocale::ImperialAramaicScript:
2700     case QLocale::InscriptionalPahlaviScript:
2701     case QLocale::InscriptionalParthianScript:
2702     case QLocale::KharoshthiScript:
2703     case QLocale::LydianScript:
2704     case QLocale::MandaeanScript:
2705     case QLocale::ManichaeanScript:
2706     case QLocale::MendeKikakuiScript:
2707     case QLocale::MeroiticCursiveScript:
2708     case QLocale::MeroiticScript:
2709     case QLocale::NabataeanScript:
2710     case QLocale::NkoScript:
2711     case QLocale::OldHungarianScript:
2712     case QLocale::OldNorthArabianScript:
2713     case QLocale::OldSouthArabianScript:
2714     case QLocale::OrkhonScript:
2715     case QLocale::PalmyreneScript:
2716     case QLocale::PhoenicianScript:
2717     case QLocale::PsalterPahlaviScript:
2718     case QLocale::SamaritanScript:
2719     case QLocale::SyriacScript:
2720     case QLocale::ThaanaScript:
2721         return Qt::RightToLeft;
2722     default:
2723         break;
2724     }
2725     return Qt::LeftToRight;
2726 }
2727 
2728 /*!
2729   \since 4.8
2730 
2731   Returns an uppercase copy of \a str.
2732 
2733   If Qt Core is using the ICU libraries, they will be used to perform
2734   the transformation according to the rules of the current locale.
2735   Otherwise the conversion may be done in a platform-dependent manner,
2736   with QString::toUpper() as a generic fallback.
2737 
2738   \sa QString::toUpper()
2739 */
2740 QString QLocale::toUpper(const QString &str) const
2741 {
2742 #if QT_CONFIG(icu)
2743     bool ok = true;
2744     QString result = QIcu::toUpper(d->bcp47Name('_'), str, &ok);
2745     if (ok)
2746         return result;
2747     // else fall through and use Qt's toUpper
2748 #endif
2749     return str.toUpper();
2750 }
2751 
2752 /*!
2753   \since 4.8
2754 
2755   Returns a lowercase copy of \a str.
2756 
2757   If Qt Core is using the ICU libraries, they will be used to perform
2758   the transformation according to the rules of the current locale.
2759   Otherwise the conversion may be done in a platform-dependent manner,
2760   with QString::toLower() as a generic fallback.
2761 
2762   \sa QString::toLower()
2763 */
2764 QString QLocale::toLower(const QString &str) const
2765 {
2766 #if QT_CONFIG(icu)
2767     bool ok = true;
2768     const QString result = QIcu::toLower(d->bcp47Name('_'), str, &ok);
2769     if (ok)
2770         return result;
2771     // else fall through and use Qt's toUpper
2772 #endif
2773     return str.toLower();
2774 }
2775 
2776 
2777 /*!
2778     \since 4.5
2779 
2780     Returns the localized name of the "AM" suffix for times specified using
2781     the conventions of the 12-hour clock.
2782 
2783     \sa pmText()
2784 */
2785 QString QLocale::amText() const
2786 {
2787 #ifndef QT_NO_SYSTEMLOCALE
2788     if (d->m_data == systemData()) {
2789         QVariant res = systemLocale()->query(QSystemLocale::AMText, QVariant());
2790         if (!res.isNull())
2791             return res.toString();
2792     }
2793 #endif
2794     return getLocaleData(am_data + d->m_data->m_am_idx, d->m_data->m_am_size);
2795 }
2796 
2797 /*!
2798     \since 4.5
2799 
2800     Returns the localized name of the "PM" suffix for times specified using
2801     the conventions of the 12-hour clock.
2802 
2803     \sa amText()
2804 */
2805 QString QLocale::pmText() const
2806 {
2807 #ifndef QT_NO_SYSTEMLOCALE
2808     if (d->m_data == systemData()) {
2809         QVariant res = systemLocale()->query(QSystemLocale::PMText, QVariant());
2810         if (!res.isNull())
2811             return res.toString();
2812     }
2813 #endif
2814     return getLocaleData(pm_data + d->m_data->m_pm_idx, d->m_data->m_pm_size);
2815 }
2816 
2817 
2818 QString QLocalePrivate::dateTimeToString(QStringView format, const QDateTime &datetime,
2819                                          const QDate &dateOnly, const QTime &timeOnly,
2820                                          const QLocale *q) const
2821 {
2822     QDate date;
2823     QTime time;
2824     bool formatDate = false;
2825     bool formatTime = false;
2826     if (datetime.isValid()) {
2827         date = datetime.date();
2828         time = datetime.time();
2829         formatDate = true;
2830         formatTime = true;
2831     } else if (dateOnly.isValid()) {
2832         date = dateOnly;
2833         formatDate = true;
2834     } else if (timeOnly.isValid()) {
2835         time = timeOnly;
2836         formatTime = true;
2837     } else {
2838         return QString();
2839     }
2840 
2841     QString result;
2842 
2843     int i = 0;
2844     while (i < format.size()) {
2845         if (format.at(i).unicode() == '\'') {
2846             result.append(qt_readEscapedFormatString(format, &i));
2847             continue;
2848         }
2849 
2850         const QChar c = format.at(i);
2851         int repeat = qt_repeatCount(format.mid(i));
2852         bool used = false;
2853         if (formatDate) {
2854             switch (c.unicode()) {
2855             case 'y':
2856                 used = true;
2857                 if (repeat >= 4)
2858                     repeat = 4;
2859                 else if (repeat >= 2)
2860                     repeat = 2;
2861 
2862                 switch (repeat) {
2863                 case 4: {
2864                     const int yr = date.year();
2865                     const int len = (yr < 0) ? 5 : 4;
2866                     result.append(m_data->longLongToString(yr, -1, 10, len, QLocaleData::ZeroPadded));
2867                     break;
2868                 }
2869                 case 2:
2870                     result.append(m_data->longLongToString(date.year() % 100, -1, 10, 2,
2871                                                    QLocaleData::ZeroPadded));
2872                     break;
2873                 default:
2874                     repeat = 1;
2875                     result.append(c);
2876                     break;
2877                 }
2878                 break;
2879 
2880             case 'M':
2881                 used = true;
2882                 repeat = qMin(repeat, 4);
2883                 switch (repeat) {
2884                 case 1:
2885                     result.append(m_data->longLongToString(date.month()));
2886                     break;
2887                 case 2:
2888                     result.append(m_data->longLongToString(date.month(), -1, 10, 2, QLocaleData::ZeroPadded));
2889                     break;
2890                 case 3:
2891                     result.append(q->monthName(date.month(), QLocale::ShortFormat));
2892                     break;
2893                 case 4:
2894                     result.append(q->monthName(date.month(), QLocale::LongFormat));
2895                     break;
2896                 }
2897                 break;
2898 
2899             case 'd':
2900                 used = true;
2901                 repeat = qMin(repeat, 4);
2902                 switch (repeat) {
2903                 case 1:
2904                     result.append(m_data->longLongToString(date.day()));
2905                     break;
2906                 case 2:
2907                     result.append(m_data->longLongToString(date.day(), -1, 10, 2, QLocaleData::ZeroPadded));
2908                     break;
2909                 case 3:
2910                     result.append(q->dayName(date.dayOfWeek(), QLocale::ShortFormat));
2911                     break;
2912                 case 4:
2913                     result.append(q->dayName(date.dayOfWeek(), QLocale::LongFormat));
2914                     break;
2915                 }
2916                 break;
2917 
2918             default:
2919                 break;
2920             }
2921         }
2922         if (!used && formatTime) {
2923             switch (c.unicode()) {
2924             case 'h': {
2925                 used = true;
2926                 repeat = qMin(repeat, 2);
2927                 int hour = time.hour();
2928                 if (timeFormatContainsAP(format)) {
2929                     if (hour > 12)
2930                         hour -= 12;
2931                     else if (hour == 0)
2932                         hour = 12;
2933                 }
2934 
2935                 switch (repeat) {
2936                 case 1:
2937                     result.append(m_data->longLongToString(hour));
2938                     break;
2939                 case 2:
2940                     result.append(m_data->longLongToString(hour, -1, 10, 2, QLocaleData::ZeroPadded));
2941                     break;
2942                 }
2943                 break;
2944             }
2945             case 'H':
2946                 used = true;
2947                 repeat = qMin(repeat, 2);
2948                 switch (repeat) {
2949                 case 1:
2950                     result.append(m_data->longLongToString(time.hour()));
2951                     break;
2952                 case 2:
2953                     result.append(m_data->longLongToString(time.hour(), -1, 10, 2, QLocaleData::ZeroPadded));
2954                     break;
2955                 }
2956                 break;
2957 
2958             case 'm':
2959                 used = true;
2960                 repeat = qMin(repeat, 2);
2961                 switch (repeat) {
2962                 case 1:
2963                     result.append(m_data->longLongToString(time.minute()));
2964                     break;
2965                 case 2:
2966                     result.append(m_data->longLongToString(time.minute(), -1, 10, 2, QLocaleData::ZeroPadded));
2967                     break;
2968                 }
2969                 break;
2970 
2971             case 's':
2972                 used = true;
2973                 repeat = qMin(repeat, 2);
2974                 switch (repeat) {
2975                 case 1:
2976                     result.append(m_data->longLongToString(time.second()));
2977                     break;
2978                 case 2:
2979                     result.append(m_data->longLongToString(time.second(), -1, 10, 2, QLocaleData::ZeroPadded));
2980                     break;
2981                 }
2982                 break;
2983 
2984             case 'a':
2985                 used = true;
2986                 if (i + 1 < format.size() && format.at(i + 1).unicode() == 'p') {
2987                     repeat = 2;
2988                 } else {
2989                     repeat = 1;
2990                 }
2991                 result.append(time.hour() < 12 ? q->amText().toLower() : q->pmText().toLower());
2992                 break;
2993 
2994             case 'A':
2995                 used = true;
2996                 if (i + 1 < format.size() && format.at(i + 1).unicode() == 'P') {
2997                     repeat = 2;
2998                 } else {
2999                     repeat = 1;
3000                 }
3001                 result.append(time.hour() < 12 ? q->amText().toUpper() : q->pmText().toUpper());
3002                 break;
3003 
3004             case 'z':
3005                 used = true;
3006                 if (repeat >= 3) {
3007                     repeat = 3;
3008                 } else {
3009                     repeat = 1;
3010                 }
3011 
3012                 // note: the millisecond component is treated like the decimal part of the seconds
3013                 // so ms == 2 is always printed as "002", but ms == 200 can be either "2" or "200"
3014                 result.append(m_data->longLongToString(time.msec(), -1, 10, 3, QLocaleData::ZeroPadded));
3015                 if (repeat == 1) {
3016                     if (result.endsWith(zero()))
3017                         result.chop(1);
3018                     if (result.endsWith(zero()))
3019                         result.chop(1);
3020                 }
3021 
3022                 break;
3023 
3024             case 't':
3025                 used = true;
3026                 repeat = 1;
3027                 // If we have a QDateTime use the time spec otherwise use the current system tzname
3028                 if (formatDate) {
3029                     result.append(datetime.timeZoneAbbreviation());
3030                 } else {
3031                     result.append(QDateTime::currentDateTime().timeZoneAbbreviation());
3032                 }
3033                 break;
3034 
3035             default:
3036                 break;
3037             }
3038         }
3039         if (!used) {
3040             result.append(QString(repeat, c));
3041         }
3042         i += repeat;
3043     }
3044 
3045     return result;
3046 }
3047 
3048 QString QLocaleData::doubleToString(double d, int precision, DoubleForm form,
3049                                     int width, unsigned flags) const
3050 {
3051     return doubleToString(m_zero, m_plus, m_minus, m_exponential, m_group, m_decimal,
3052                           d, precision, form, width, flags);
3053 }
3054 
3055 QString QLocaleData::doubleToString(const QChar _zero, const QChar plus, const QChar minus,
3056                                     const QChar exponential, const QChar group, const QChar decimal,
3057                                     double d, int precision, DoubleForm form, int width, unsigned flags)
3058 {
3059     if (precision != QLocale::FloatingPointShortest && precision < 0)
3060         precision = 6;
3061     if (width < 0)
3062         width = 0;
3063 
3064     bool negative = false;
3065     QString num_str;
3066 
3067     int decpt;
3068     int bufSize = 1;
3069     if (precision == QLocale::FloatingPointShortest)
3070         bufSize += DoubleMaxSignificant;
3071     else if (form == DFDecimal) // optimize for numbers between -512k and 512k
3072         bufSize += ((d > (1 << 19) || d < -(1 << 19)) ? DoubleMaxDigitsBeforeDecimal : 6) +
3073                 precision;
3074     else // Add extra digit due to different interpretations of precision. Also, "nan" has to fit.
3075         bufSize += qMax(2, precision) + 1;
3076 
3077     QVarLengthArray<char> buf(bufSize);
3078     int length;
3079 
3080     doubleToAscii(d, form, precision, buf.data(), bufSize, negative, length, decpt);
3081 
3082     if (qstrncmp(buf.data(), "inf", 3) == 0 || qstrncmp(buf.data(), "nan", 3) == 0) {
3083         num_str = QString::fromLatin1(buf.data(), length);
3084     } else { // Handle normal numbers
3085         QString digits = QString::fromLatin1(buf.data(), length);
3086 
3087         if (_zero.unicode() != '0') {
3088             ushort z = _zero.unicode() - '0';
3089             for (int i = 0; i < digits.length(); ++i)
3090                 reinterpret_cast<ushort *>(digits.data())[i] += z;
3091         }
3092 
3093         bool always_show_decpt = (flags & ForcePoint);
3094         switch (form) {
3095             case DFExponent: {
3096                 num_str = exponentForm(_zero, decimal, exponential, group, plus, minus,
3097                                        digits, decpt, precision, PMDecimalDigits,
3098                                        always_show_decpt, flags & ZeroPadExponent);
3099                 break;
3100             }
3101             case DFDecimal: {
3102                 num_str = decimalForm(_zero, decimal, group,
3103                                       digits, decpt, precision, PMDecimalDigits,
3104                                       always_show_decpt, flags & ThousandsGroup);
3105                 break;
3106             }
3107             case DFSignificantDigits: {
3108                 PrecisionMode mode = (flags & AddTrailingZeroes) ?
3109                             PMSignificantDigits : PMChopTrailingZeros;
3110 
3111                 int cutoff = precision < 0 ? 6 : precision;
3112                 // Find out which representation is shorter
3113                 if (precision == QLocale::FloatingPointShortest && decpt > 0) {
3114                     cutoff = digits.length() + 4; // 'e', '+'/'-', one digit exponent
3115                     if (decpt <= 10) {
3116                         ++cutoff;
3117                     } else {
3118                         cutoff += decpt > 100 ? 2 : 1;
3119                     }
3120                     if (!always_show_decpt && digits.length() > decpt)
3121                         ++cutoff; // decpt shown in exponent form, but not in decimal form
3122                 }
3123 
3124                 if (decpt != digits.length() && (decpt <= -4 || decpt > cutoff))
3125                     num_str = exponentForm(_zero, decimal, exponential, group, plus, minus,
3126                                            digits, decpt, precision, mode,
3127                                            always_show_decpt, flags & ZeroPadExponent);
3128                 else
3129                     num_str = decimalForm(_zero, decimal, group,
3130                                           digits, decpt, precision, mode,
3131                                           always_show_decpt, flags & ThousandsGroup);
3132                 break;
3133             }
3134         }
3135 
3136         if (isZero(d))
3137             negative = false;
3138 
3139         // pad with zeros. LeftAdjusted overrides this flag). Also, we don't
3140         // pad special numbers
3141         if (flags & QLocaleData::ZeroPadded && !(flags & QLocaleData::LeftAdjusted)) {
3142             int num_pad_chars = width - num_str.length();
3143             // leave space for the sign
3144             if (negative
3145                     || flags & QLocaleData::AlwaysShowSign
3146                     || flags & QLocaleData::BlankBeforePositive)
3147                 --num_pad_chars;
3148 
3149             for (int i = 0; i < num_pad_chars; ++i)
3150                 num_str.prepend(_zero);
3151         }
3152     }
3153 
3154     // add sign
3155     if (negative)
3156         num_str.prepend(minus);
3157     else if (flags & QLocaleData::AlwaysShowSign)
3158         num_str.prepend(plus);
3159     else if (flags & QLocaleData::BlankBeforePositive)
3160         num_str.prepend(QLatin1Char(' '));
3161 
3162     if (flags & QLocaleData::CapitalEorX)
3163         num_str = std::move(num_str).toUpper();
3164 
3165     return num_str;
3166 }
3167 
3168 QString QLocaleData::longLongToString(qlonglong l, int precision,
3169                                             int base, int width,
3170                                             unsigned flags) const
3171 {
3172     return longLongToString(m_zero, m_group, m_plus, m_minus,
3173                                             l, precision, base, width, flags);
3174 }
3175 
3176 QString QLocaleData::longLongToString(const QChar zero, const QChar group,
3177                                          const QChar plus, const QChar minus,
3178                                          qlonglong l, int precision,
3179                                          int base, int width,
3180                                          unsigned flags)
3181 {
3182     bool precision_not_specified = false;
3183     if (precision == -1) {
3184         precision_not_specified = true;
3185         precision = 1;
3186     }
3187 
3188     bool negative = l < 0;
3189     if (base != 10) {
3190         // these are not supported by sprintf for octal and hex
3191         flags &= ~AlwaysShowSign;
3192         flags &= ~BlankBeforePositive;
3193         negative = false; // neither are negative numbers
3194     }
3195 
3196 QT_WARNING_PUSH
3197     /* "unary minus operator applied to unsigned type, result still unsigned" */
3198 QT_WARNING_DISABLE_MSVC(4146)
3199     /*
3200       Negating std::numeric_limits<qlonglong>::min() hits undefined behavior, so
3201       taking an absolute value has to cast to unsigned to change sign.
3202      */
3203     QString num_str = qulltoa(negative ? -qulonglong(l) : qulonglong(l), base, zero);
3204 QT_WARNING_POP
3205 
3206     uint cnt_thousand_sep = 0;
3207     if (flags & ThousandsGroup && base == 10) {
3208         for (int i = num_str.length() - 3; i > 0; i -= 3) {
3209             num_str.insert(i, group);
3210             ++cnt_thousand_sep;
3211         }
3212     }
3213 
3214     for (int i = num_str.length()/* - cnt_thousand_sep*/; i < precision; ++i)
3215         num_str.prepend(base == 10 ? zero : QChar::fromLatin1('0'));
3216 
3217     if ((flags & ShowBase)
3218             && base == 8
3219             && (num_str.isEmpty() || num_str[0].unicode() != QLatin1Char('0')))
3220         num_str.prepend(QLatin1Char('0'));
3221 
3222     // LeftAdjusted overrides this flag ZeroPadded. sprintf only padds
3223     // when precision is not specified in the format string
3224     bool zero_padded = flags & ZeroPadded
3225                         && !(flags & LeftAdjusted)
3226                         && precision_not_specified;
3227 
3228     if (zero_padded) {
3229         int num_pad_chars = width - num_str.length();
3230 
3231         // leave space for the sign
3232         if (negative
3233                 || flags & AlwaysShowSign
3234                 || flags & BlankBeforePositive)
3235             --num_pad_chars;
3236 
3237         // leave space for optional '0x' in hex form
3238         if (base == 16 && (flags & ShowBase))
3239             num_pad_chars -= 2;
3240         // leave space for optional '0b' in binary form
3241         else if (base == 2 && (flags & ShowBase))
3242             num_pad_chars -= 2;
3243 
3244         for (int i = 0; i < num_pad_chars; ++i)
3245             num_str.prepend(base == 10 ? zero : QChar::fromLatin1('0'));
3246     }
3247 
3248     if (flags & CapitalEorX)
3249         num_str = std::move(num_str).toUpper();
3250 
3251     if (base == 16 && (flags & ShowBase))
3252         num_str.prepend(QLatin1String(flags & UppercaseBase ? "0X" : "0x"));
3253     if (base == 2 && (flags & ShowBase))
3254         num_str.prepend(QLatin1String(flags & UppercaseBase ? "0B" : "0b"));
3255 
3256     // add sign
3257     if (negative)
3258         num_str.prepend(minus);
3259     else if (flags & AlwaysShowSign)
3260         num_str.prepend(plus);
3261     else if (flags & BlankBeforePositive)
3262         num_str.prepend(QLatin1Char(' '));
3263 
3264     return num_str;
3265 }
3266 
3267 QString QLocaleData::unsLongLongToString(qulonglong l, int precision,
3268                                             int base, int width,
3269                                             unsigned flags) const
3270 {
3271     return unsLongLongToString(m_zero, m_group, m_plus,
3272                                                l, precision, base, width, flags);
3273 }
3274 
3275 QString QLocaleData::unsLongLongToString(const QChar zero, const QChar group,
3276                                             const QChar plus,
3277                                             qulonglong l, int precision,
3278                                             int base, int width,
3279                                             unsigned flags)
3280 {
3281     const QChar resultZero = base == 10 ? zero : QChar(QLatin1Char('0'));
3282     QString num_str = l ? qulltoa(l, base, zero) : QString(resultZero);
3283 
3284     bool precision_not_specified = false;
3285     if (precision == -1) {
3286         if (flags == NoFlags)
3287             return num_str; // fast-path: nothing below applies, so we're done.
3288 
3289         precision_not_specified = true;
3290         precision = 1;
3291     }
3292 
3293     uint cnt_thousand_sep = 0;
3294     if (flags & ThousandsGroup && base == 10) {
3295         for (int i = num_str.length() - 3; i > 0; i -=3) {
3296             num_str.insert(i, group);
3297             ++cnt_thousand_sep;
3298         }
3299     }
3300 
3301     const int zeroPadding = precision - num_str.length()/* + cnt_thousand_sep*/;
3302     if (zeroPadding > 0)
3303         num_str.prepend(QString(zeroPadding, resultZero));
3304 
3305     if ((flags & ShowBase)
3306             && base == 8
3307             && (num_str.isEmpty() || num_str.at(0).unicode() != QLatin1Char('0')))
3308         num_str.prepend(QLatin1Char('0'));
3309 
3310     // LeftAdjusted overrides this flag ZeroPadded. sprintf only padds
3311     // when precision is not specified in the format string
3312     bool zero_padded = flags & ZeroPadded
3313                         && !(flags & LeftAdjusted)
3314                         && precision_not_specified;
3315 
3316     if (zero_padded) {
3317         int num_pad_chars = width - num_str.length();
3318 
3319         // leave space for optional '0x' in hex form
3320         if (base == 16 && flags & ShowBase)
3321             num_pad_chars -= 2;
3322         // leave space for optional '0b' in binary form
3323         else if (base == 2 && flags & ShowBase)
3324             num_pad_chars -= 2;
3325 
3326         if (num_pad_chars > 0)
3327             num_str.prepend(QString(num_pad_chars, resultZero));
3328     }
3329 
3330     if (flags & CapitalEorX)
3331         num_str = std::move(num_str).toUpper();
3332 
3333     if (base == 16 && flags & ShowBase)
3334         num_str.prepend(QLatin1String(flags & UppercaseBase ? "0X" : "0x"));
3335     else if (base == 2 && flags & ShowBase)
3336         num_str.prepend(QLatin1String(flags & UppercaseBase ? "0B" : "0b"));
3337 
3338     // add sign
3339     if (flags & AlwaysShowSign)
3340         num_str.prepend(plus);
3341     else if (flags & BlankBeforePositive)
3342         num_str.prepend(QLatin1Char(' '));
3343 
3344     return num_str;
3345 }
3346 
3347 /*
3348     Converts a number in locale to its representation in the C locale.
3349     Only has to guarantee that a string that is a correct representation of
3350     a number will be converted. If junk is passed in, junk will be passed
3351     out and the error will be detected during the actual conversion to a
3352     number. We can't detect junk here, since we don't even know the base
3353     of the number.
3354 */
3355 bool QLocaleData::numberToCLocale(QStringView s, QLocale::NumberOptions number_options,
3356                                   CharBuff *result) const
3357 {
3358     const QChar *uc = s.data();
3359     auto l = s.size();
3360     decltype(l) idx = 0;
3361 
3362     // Skip whitespace
3363     while (idx < l && uc[idx].isSpace())
3364         ++idx;
3365     if (idx == l)
3366         return false;
3367 
3368     // Check trailing whitespace
3369     for (; idx < l; --l) {
3370         if (!uc[l - 1].isSpace())
3371             break;
3372     }
3373 
3374     int group_cnt = 0; // counts number of group chars
3375     int decpt_idx = -1;
3376     int last_separator_idx = -1;
3377     int start_of_digits_idx = -1;
3378     int exponent_idx = -1;
3379 
3380     while (idx < l) {
3381         const QChar in = uc[idx];
3382 
3383         char out = digitToCLocale(in);
3384         if (out == 0) {
3385             if (in == m_list)
3386                 out = ';';
3387             else if (in == m_percent)
3388                 out = '%';
3389             // for handling base-x numbers
3390             else if (in.unicode() >= 'A' && in.unicode() <= 'Z')
3391                 out = in.toLower().toLatin1();
3392             else if (in.unicode() >= 'a' && in.unicode() <= 'z')
3393                 out = in.toLatin1();
3394             else
3395                 break;
3396         } else if (out == '.') {
3397             // Fail if more than one decimal point or point after e
3398             if (decpt_idx != -1 || exponent_idx != -1)
3399                 return false;
3400             decpt_idx = idx;
3401         } else if (out == 'e' || out == 'E') {
3402             exponent_idx = idx;
3403         }
3404 
3405         if (number_options & QLocale::RejectLeadingZeroInExponent) {
3406             if (exponent_idx != -1 && out == '0' && idx < l - 1) {
3407                 // After the exponent there can only be '+', '-' or digits.
3408                 // If we find a '0' directly after some non-digit, then that is a leading zero.
3409                 if (result->last() < '0' || result->last() > '9')
3410                     return false;
3411             }
3412         }
3413 
3414         if (number_options & QLocale::RejectTrailingZeroesAfterDot) {
3415             // If we've seen a decimal point and the last character after the exponent is 0, then
3416             // that is a trailing zero.
3417             if (decpt_idx >= 0 && idx == exponent_idx && result->last() == '0')
3418                     return false;
3419         }
3420 
3421         if (!(number_options & QLocale::RejectGroupSeparator)) {
3422             if (start_of_digits_idx == -1 && out >= '0' && out <= '9') {
3423                 start_of_digits_idx = idx;
3424             } else if (out == ',') {
3425                 // Don't allow group chars after the decimal point or exponent
3426                 if (decpt_idx != -1 || exponent_idx != -1)
3427                     return false;
3428 
3429                 // check distance from the last separator or from the beginning of the digits
3430                 // ### FIXME: Some locales allow other groupings! See https://en.wikipedia.org/wiki/Thousands_separator
3431                 if (last_separator_idx != -1 && idx - last_separator_idx != 4)
3432                     return false;
3433                 if (last_separator_idx == -1 && (start_of_digits_idx == -1 || idx - start_of_digits_idx > 3))
3434                     return false;
3435 
3436                 last_separator_idx = idx;
3437                 ++group_cnt;
3438 
3439                 // don't add the group separator
3440                 ++idx;
3441                 continue;
3442             } else if (out == '.' || out == 'e' || out == 'E') {
3443                 // check distance from the last separator
3444                 // ### FIXME: Some locales allow other groupings! See https://en.wikipedia.org/wiki/Thousands_separator
3445                 if (last_separator_idx != -1 && idx - last_separator_idx != 4)
3446                     return false;
3447 
3448                 // stop processing separators
3449                 last_separator_idx = -1;
3450             }
3451         }
3452 
3453         result->append(out);
3454 
3455         ++idx;
3456     }
3457 
3458     if (!(number_options & QLocale::RejectGroupSeparator)) {
3459         // group separator post-processing
3460         // did we end in a separator?
3461         if (last_separator_idx + 1 == idx)
3462             return false;
3463         // were there enough digits since the last separator?
3464         if (last_separator_idx != -1 && idx - last_separator_idx != 4)
3465             return false;
3466     }
3467 
3468     if (number_options & QLocale::RejectTrailingZeroesAfterDot) {
3469         // In decimal form, the last character can be a trailing zero if we've seen a decpt.
3470         if (decpt_idx != -1 && exponent_idx == -1 && result->last() == '0')
3471             return false;
3472     }
3473 
3474     result->append('\0');
3475     return idx == l;
3476 }
3477 
3478 bool QLocaleData::validateChars(QStringView str, NumberMode numMode, QByteArray *buff,
3479                                 int decDigits, QLocale::NumberOptions number_options) const
3480 {
3481     buff->clear();
3482     buff->reserve(str.length());
3483 
3484     const bool scientific = numMode == DoubleScientificMode;
3485     bool lastWasE = false;
3486     bool lastWasDigit = false;
3487     int eCnt = 0;
3488     int decPointCnt = 0;
3489     bool dec = false;
3490     int decDigitCnt = 0;
3491 
3492     for (qsizetype i = 0; i < str.size(); ++i) {
3493         char c = digitToCLocale(str.at(i));
3494 
3495         if (c >= '0' && c <= '9') {
3496             if (numMode != IntegerMode) {
3497                 // If a double has too many digits after decpt, it shall be Invalid.
3498                 if (dec && decDigits != -1 && decDigits < ++decDigitCnt)
3499                     return false;
3500             }
3501 
3502             // The only non-digit character after the 'e' can be '+' or '-'.
3503             // If a zero is directly after that, then the exponent is zero-padded.
3504             if ((number_options & QLocale::RejectLeadingZeroInExponent) && c == '0' && eCnt > 0 &&
3505                     !lastWasDigit)
3506                 return false;
3507 
3508             lastWasDigit = true;
3509         } else {
3510             switch (c) {
3511                 case '.':
3512                     if (numMode == IntegerMode) {
3513                         // If an integer has a decimal point, it shall be Invalid.
3514                         return false;
3515                     } else {
3516                         // If a double has more than one decimal point, it shall be Invalid.
3517                         if (++decPointCnt > 1)
3518                             return false;
3519 #if 0
3520                         // If a double with no decimal digits has a decimal point, it shall be
3521                         // Invalid.
3522                         if (decDigits == 0)
3523                             return false;
3524 #endif                  // On second thoughts, it shall be Valid.
3525 
3526                         dec = true;
3527                     }
3528                     break;
3529 
3530                 case '+':
3531                 case '-':
3532                     if (scientific) {
3533                         // If a scientific has a sign that's not at the beginning or after
3534                         // an 'e', it shall be Invalid.
3535                         if (i != 0 && !lastWasE)
3536                             return false;
3537                     } else {
3538                         // If a non-scientific has a sign that's not at the beginning,
3539                         // it shall be Invalid.
3540                         if (i != 0)
3541                             return false;
3542                     }
3543                     break;
3544 
3545                 case ',':
3546                     //it can only be placed after a digit which is before the decimal point
3547                     if ((number_options & QLocale::RejectGroupSeparator) || !lastWasDigit ||
3548                             decPointCnt > 0)
3549                         return false;
3550                     break;
3551 
3552                 case 'e':
3553                     if (scientific) {
3554                         // If a scientific has more than one 'e', it shall be Invalid.
3555                         if (++eCnt > 1)
3556                             return false;
3557                         dec = false;
3558                     } else {
3559                         // If a non-scientific has an 'e', it shall be Invalid.
3560                         return false;
3561                     }
3562                     break;
3563 
3564                 default:
3565                     // If it's not a valid digit, it shall be Invalid.
3566                     return false;
3567             }
3568             lastWasDigit = false;
3569         }
3570 
3571         lastWasE = c == 'e';
3572         if (c != ',')
3573             buff->append(c);
3574     }
3575 
3576     return true;
3577 }
3578 
3579 double QLocaleData::stringToDouble(QStringView str, bool *ok,
3580                                    QLocale::NumberOptions number_options) const
3581 {
3582     CharBuff buff;
3583     if (!numberToCLocale(str, number_options, &buff)) {
3584         if (ok != 0)
3585             *ok = false;
3586         return 0.0;
3587     }
3588     int processed = 0;
3589     bool nonNullOk = false;
3590     double d = asciiToDouble(buff.constData(), buff.length() - 1, nonNullOk, processed);
3591     if (ok)
3592         *ok = nonNullOk;
3593     return d;
3594 }
3595 
3596 qlonglong QLocaleData::stringToLongLong(QStringView str, int base, bool *ok,
3597                                         QLocale::NumberOptions number_options) const
3598 {
3599     CharBuff buff;
3600     if (!numberToCLocale(str, number_options, &buff)) {
3601         if (ok != 0)
3602             *ok = false;
3603         return 0;
3604     }
3605 
3606     return bytearrayToLongLong(buff.constData(), base, ok);
3607 }
3608 
3609 qulonglong QLocaleData::stringToUnsLongLong(QStringView str, int base, bool *ok,
3610                                             QLocale::NumberOptions number_options) const
3611 {
3612     CharBuff buff;
3613     if (!numberToCLocale(str, number_options, &buff)) {
3614         if (ok != 0)
3615             *ok = false;
3616         return 0;
3617     }
3618 
3619     return bytearrayToUnsLongLong(buff.constData(), base, ok);
3620 }
3621 
3622 double QLocaleData::bytearrayToDouble(const char *num, bool *ok)
3623 {
3624     bool nonNullOk = false;
3625     int len = static_cast<int>(strlen(num));
3626     Q_ASSERT(len >= 0);
3627     int processed = 0;
3628     double d = asciiToDouble(num, len, nonNullOk, processed);
3629     if (ok)
3630         *ok = nonNullOk;
3631     return d;
3632 }
3633 
3634 qlonglong QLocaleData::bytearrayToLongLong(const char *num, int base, bool *ok)
3635 {
3636     bool _ok;
3637     const char *endptr;
3638 
3639     if (*num == '\0') {
3640         if (ok != 0)
3641             *ok = false;
3642         return 0;
3643     }
3644 
3645     qlonglong l = qstrtoll(num, &endptr, base, &_ok);
3646 
3647     if (!_ok) {
3648         if (ok != 0)
3649             *ok = false;
3650         return 0;
3651     }
3652 
3653     if (*endptr != '\0') {
3654         // we stopped at a non-digit character after converting some digits
3655         if (ok != 0)
3656             *ok = false;
3657         return 0;
3658     }
3659 
3660     if (ok != 0)
3661         *ok = true;
3662     return l;
3663 }
3664 
3665 qulonglong QLocaleData::bytearrayToUnsLongLong(const char *num, int base, bool *ok)
3666 {
3667     bool _ok;
3668     const char *endptr;
3669     qulonglong l = qstrtoull(num, &endptr, base, &_ok);
3670 
3671     if (!_ok || *endptr != '\0') {
3672         if (ok != 0)
3673             *ok = false;
3674         return 0;
3675     }
3676 
3677     if (ok != 0)
3678         *ok = true;
3679     return l;
3680 }
3681 
3682 /*!
3683     \since 4.8
3684 
3685     \enum QLocale::CurrencySymbolFormat
3686 
3687     Specifies the format of the currency symbol.
3688 
3689     \value CurrencyIsoCode a ISO-4217 code of the currency.
3690     \value CurrencySymbol a currency symbol.
3691     \value CurrencyDisplayName a user readable name of the currency.
3692 */
3693 
3694 /*!
3695     \since 4.8
3696     Returns a currency symbol according to the \a format.
3697 */
3698 QString QLocale::currencySymbol(QLocale::CurrencySymbolFormat format) const
3699 {
3700 #ifndef QT_NO_SYSTEMLOCALE
3701     if (d->m_data == systemData()) {
3702         QVariant res = systemLocale()->query(QSystemLocale::CurrencySymbol, format);
3703         if (!res.isNull())
3704             return res.toString();
3705     }
3706 #endif
3707     quint32 idx, size;
3708     switch (format) {
3709     case CurrencySymbol:
3710         idx = d->m_data->m_currency_symbol_idx;
3711         size = d->m_data->m_currency_symbol_size;
3712         return getLocaleData(currency_symbol_data + idx, size);
3713     case CurrencyDisplayName:
3714         idx = d->m_data->m_currency_display_name_idx;
3715         size = d->m_data->m_currency_display_name_size;
3716         return getLocaleListData(currency_display_name_data + idx, size, 0);
3717     case CurrencyIsoCode: {
3718         int len = 0;
3719         const QLocaleData *data = this->d->m_data;
3720         for (; len < 3; ++len)
3721             if (!data->m_currency_iso_code[len])
3722                 break;
3723         return len ? QString::fromLatin1(data->m_currency_iso_code, len) : QString();
3724     }
3725     }
3726     return QString();
3727 }
3728 
3729 /*!
3730     \since 4.8
3731 
3732     Returns a localized string representation of \a value as a currency.
3733     If the \a symbol is provided it is used instead of the default currency symbol.
3734 
3735     \sa currencySymbol()
3736 */
3737 QString QLocale::toCurrencyString(qlonglong value, const QString &symbol) const
3738 {
3739 #ifndef QT_NO_SYSTEMLOCALE
3740     if (d->m_data == systemData()) {
3741         QSystemLocale::CurrencyToStringArgument arg(value, symbol);
3742         QVariant res = systemLocale()->query(QSystemLocale::CurrencyToString, QVariant::fromValue(arg));
3743         if (!res.isNull())
3744             return res.toString();
3745     }
3746 #endif
3747     const QLocalePrivate *d = this->d;
3748     quint8 idx = d->m_data->m_currency_format_idx;
3749     quint8 size = d->m_data->m_currency_format_size;
3750     if (d->m_data->m_currency_negative_format_size && value < 0) {
3751         idx = d->m_data->m_currency_negative_format_idx;
3752         size = d->m_data->m_currency_negative_format_size;
3753         value = -value;
3754     }
3755     QString str = toString(value);
3756     QString sym = symbol.isNull() ? currencySymbol() : symbol;
3757     if (sym.isEmpty())
3758         sym = currencySymbol(QLocale::CurrencyIsoCode);
3759     QString format = getLocaleData(currency_format_data + idx, size);
3760     return format.arg(str, sym);
3761 }
3762 
3763 /*!
3764     \since 4.8
3765     \overload
3766 */
3767 QString QLocale::toCurrencyString(qulonglong value, const QString &symbol) const
3768 {
3769 #ifndef QT_NO_SYSTEMLOCALE
3770     if (d->m_data == systemData()) {
3771         QSystemLocale::CurrencyToStringArgument arg(value, symbol);
3772         QVariant res = systemLocale()->query(QSystemLocale::CurrencyToString, QVariant::fromValue(arg));
3773         if (!res.isNull())
3774             return res.toString();
3775     }
3776 #endif
3777     const QLocaleData *data = this->d->m_data;
3778     quint8 idx = data->m_currency_format_idx;
3779     quint8 size = data->m_currency_format_size;
3780     QString str = toString(value);
3781     QString sym = symbol.isNull() ? currencySymbol() : symbol;
3782     if (sym.isEmpty())
3783         sym = currencySymbol(QLocale::CurrencyIsoCode);
3784     QString format = getLocaleData(currency_format_data + idx, size);
3785     return format.arg(str, sym);
3786 }
3787 
3788 #if QT_VERSION < QT_VERSION_CHECK(6,0,0)
3789 /*!
3790     \since 4.8
3791     \overload
3792 */
3793 QString QLocale::toCurrencyString(double value, const QString &symbol) const
3794 {
3795     return toCurrencyString(value, symbol, d->m_data->m_currency_digits);
3796 }
3797 #endif
3798 
3799 /*!
3800     \since 5.7
3801     \overload toCurrencyString()
3802 
3803     Returns a localized string representation of \a value as a currency.
3804     If the \a symbol is provided it is used instead of the default currency symbol.
3805     If the \a precision is provided it is used to set the precision of the currency value.
3806 
3807     \sa currencySymbol()
3808  */
3809 QString QLocale::toCurrencyString(double value, const QString &symbol, int precision) const
3810 {
3811 #ifndef QT_NO_SYSTEMLOCALE
3812     if (d->m_data == systemData()) {
3813         QSystemLocale::CurrencyToStringArgument arg(value, symbol);
3814         QVariant res = systemLocale()->query(QSystemLocale::CurrencyToString, QVariant::fromValue(arg));
3815         if (!res.isNull())
3816             return res.toString();
3817     }
3818 #endif
3819     const QLocaleData *data = this->d->m_data;
3820     quint8 idx = data->m_currency_format_idx;
3821     quint8 size = data->m_currency_format_size;
3822     if (data->m_currency_negative_format_size && value < 0) {
3823         idx = data->m_currency_negative_format_idx;
3824         size = data->m_currency_negative_format_size;
3825         value = -value;
3826     }
3827     QString str = toString(value, 'f', precision == -1 ? d->m_data->m_currency_digits : precision);
3828     QString sym = symbol.isNull() ? currencySymbol() : symbol;
3829     if (sym.isEmpty())
3830         sym = currencySymbol(QLocale::CurrencyIsoCode);
3831     QString format = getLocaleData(currency_format_data + idx, size);
3832     return format.arg(str, sym);
3833 }
3834 
3835 /*!
3836   \fn QString QLocale::toCurrencyString(float i, const QString &symbol) const
3837   \fn QString QLocale::toCurrencyString(float i, const QString &symbol, int precision) const
3838   \overload toCurrencyString()
3839 */
3840 
3841 /*!
3842     \since 5.10
3843 
3844     \enum QLocale::DataSizeFormat
3845 
3846     Specifies the format for representation of data quantities.
3847 
3848     \omitvalue DataSizeBase1000
3849     \omitvalue DataSizeSIQuantifiers
3850     \value DataSizeIecFormat            format using base 1024 and IEC prefixes: KiB, MiB, GiB, ...
3851     \value DataSizeTraditionalFormat    format using base 1024 and SI prefixes: kB, MB, GB, ...
3852     \value DataSizeSIFormat             format using base 1000 and SI prefixes: kB, MB, GB, ...
3853 
3854     \sa formattedDataSize()
3855 */
3856 
3857 /*!
3858     \since 5.10
3859 
3860     Converts a size in bytes to a human-readable localized string, comprising a
3861     number and a quantified unit. The quantifier is chosen such that the number
3862     is at least one, and as small as possible. For example if \a bytes is
3863     16384, \a precision is 2, and \a format is \l DataSizeIecFormat (the
3864     default), this function returns "16.00 KiB"; for 1330409069609 bytes it
3865     returns "1.21 GiB"; and so on. If \a format is \l DataSizeIecFormat or
3866     \l DataSizeTraditionalFormat, the given number of bytes is divided by a
3867     power of 1024, with result less than 1024; for \l DataSizeSIFormat, it is
3868     divided by a power of 1000, with result less than 1000.
3869     \c DataSizeIecFormat uses the new IEC standard quantifiers Ki, Mi and so on,
3870     whereas \c DataSizeSIFormat uses the older SI quantifiers k, M, etc., and
3871     \c DataSizeTraditionalFormat abuses them.
3872 */
3873 QString QLocale::formattedDataSize(qint64 bytes, int precision, DataSizeFormats format)
3874 {
3875     int power, base = 1000;
3876     if (!bytes) {
3877         power = 0;
3878     } else if (format & DataSizeBase1000) {
3879         power = int(std::log10(qAbs(bytes)) / 3);
3880     } else { // Compute log2(bytes) / 10:
3881         power = int((63 - qCountLeadingZeroBits(quint64(qAbs(bytes)))) / 10);
3882         base = 1024;
3883     }
3884     // Only go to doubles if we'll be using a quantifier:
3885     const QString number = power
3886         ? toString(bytes / std::pow(double(base), power), 'f', qMin(precision, 3 * power))
3887         : toString(bytes);
3888 
3889     // We don't support sizes in units larger than exbibytes because
3890     // the number of bytes would not fit into qint64.
3891     Q_ASSERT(power <= 6 && power >= 0);
3892     QString unit;
3893     if (power > 0) {
3894         quint16 index, size;
3895         if (format & DataSizeSIQuantifiers) {
3896             index = d->m_data->m_byte_si_quantified_idx;
3897             size = d->m_data->m_byte_si_quantified_size;
3898         } else {
3899             index = d->m_data->m_byte_iec_quantified_idx;
3900             size = d->m_data->m_byte_iec_quantified_size;
3901         }
3902         unit = getLocaleListData(byte_unit_data + index, size, power - 1);
3903     } else {
3904         unit = getLocaleData(byte_unit_data + d->m_data->m_byte_idx, d->m_data->m_byte_size);
3905     }
3906 
3907     return number + QLatin1Char(' ') + unit;
3908 }
3909 
3910 /*!
3911     \since 4.8
3912 
3913     Returns an ordered list of locale names for translation purposes in
3914     preference order (like "en-Latn-US", "en-US", "en").
3915 
3916     The return value represents locale names that the user expects to see the
3917     UI translation in.
3918 
3919     Most like you do not need to use this function directly, but just pass the
3920     QLocale object to the QTranslator::load() function.
3921 
3922     The first item in the list is the most preferred one.
3923 
3924     \sa QTranslator, bcp47Name()
3925 */
3926 QStringList QLocale::uiLanguages() const
3927 {
3928 #ifndef QT_NO_SYSTEMLOCALE
3929     if (d->m_data == systemData()) {
3930         QVariant res = systemLocale()->query(QSystemLocale::UILanguages, QVariant());
3931         if (!res.isNull()) {
3932             QStringList result = res.toStringList();
3933             if (!result.isEmpty())
3934                 return result;
3935         }
3936     }
3937 #endif
3938     QLocaleId id = QLocaleId::fromIds(d->m_data->m_language_id, d->m_data->m_script_id, d->m_data->m_country_id);
3939     const QLocaleId max = id.withLikelySubtagsAdded();
3940     const QLocaleId min = max.withLikelySubtagsRemoved();
3941 
3942     QStringList uiLanguages;
3943     uiLanguages.append(QString::fromLatin1(min.name()));
3944     if (id.script_id) {
3945         id.script_id = 0;
3946         if (id != min && id.withLikelySubtagsAdded() == max)
3947             uiLanguages.append(QString::fromLatin1(id.name()));
3948     }
3949     if (max != min && max != id)
3950         uiLanguages.append(QString::fromLatin1(max.name()));
3951     return uiLanguages;
3952 }
3953 
3954 /*!
3955     \since 4.8
3956 
3957     Returns a native name of the language for the locale. For example
3958     "Schwiizerttsch" for Swiss-German locale.
3959 
3960     \sa nativeCountryName(), languageToString()
3961 */
3962 QString QLocale::nativeLanguageName() const
3963 {
3964 #ifndef QT_NO_SYSTEMLOCALE
3965     if (d->m_data == systemData()) {
3966         QVariant res = systemLocale()->query(QSystemLocale::NativeLanguageName, QVariant());
3967         if (!res.isNull())
3968             return res.toString();
3969     }
3970 #endif
3971     return getLocaleData(endonyms_data + d->m_data->m_language_endonym_idx, d->m_data->m_language_endonym_size);
3972 }
3973 
3974 /*!
3975     \since 4.8
3976 
3977     Returns a native name of the country for the locale. For example
3978     "Espaa" for Spanish/Spain locale.
3979 
3980     \sa nativeLanguageName(), countryToString()
3981 */
3982 QString QLocale::nativeCountryName() const
3983 {
3984 #ifndef QT_NO_SYSTEMLOCALE
3985     if (d->m_data == systemData()) {
3986         QVariant res = systemLocale()->query(QSystemLocale::NativeCountryName, QVariant());
3987         if (!res.isNull())
3988             return res.toString();
3989     }
3990 #endif
3991     return getLocaleData(endonyms_data + d->m_data->m_country_endonym_idx, d->m_data->m_country_endonym_size);
3992 }
3993 
3994 #ifndef QT_NO_DEBUG_STREAM
3995 QDebug operator<<(QDebug dbg, const QLocale &l)
3996 {
3997     QDebugStateSaver saver(dbg);
3998     dbg.nospace().noquote()
3999         << "QLocale(" << QLocale::languageToString(l.language())
4000         << ", " << QLocale::scriptToString(l.script())
4001         << ", " << QLocale::countryToString(l.country()) << ')';
4002     return dbg;
4003 }
4004 #endif
4005 QT_END_NAMESPACE
4006 
4007 #ifndef QT_NO_QOBJECT
4008 #include "moc_qlocale.cpp"
4009 #endif
