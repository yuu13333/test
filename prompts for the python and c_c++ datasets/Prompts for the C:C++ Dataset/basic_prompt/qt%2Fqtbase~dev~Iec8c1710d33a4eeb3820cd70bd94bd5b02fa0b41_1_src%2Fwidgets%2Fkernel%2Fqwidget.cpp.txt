Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2017 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtWidgets module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qapplication.h"
42 #include "qapplication_p.h"
43 #include "qbrush.h"
44 #include "qcursor.h"
45 #include "qdesktopwidget_p.h"
46 #include "qevent.h"
47 #include "qlayout.h"
48 #include "qmenu.h"
49 #include "qmetaobject.h"
50 #include "qpixmap.h"
51 #include "qpointer.h"
52 #include "qstack.h"
53 #include "qstyle.h"
54 #include "qstylefactory.h"
55 #include "qvariant.h"
56 #include "qwidget.h"
57 #include "qstyleoption.h"
58 #include "qstylehints.h"
59 #ifndef QT_NO_ACCESSIBILITY
60 # include "qaccessible.h"
61 #endif
62 #if 0 // Used to be included in Qt4 for Q_WS_MAC
63 # include "qt_mac_p.h"
64 # include "qt_cocoa_helpers_mac_p.h"
65 # include "qmainwindow.h"
66 # include "qtoolbar.h"
67 # include <private/qmainwindowlayout_p.h>
68 #endif
69 #include <qpa/qplatformwindow.h>
70 #include "private/qwidgetwindow_p.h"
71 #include "qpainter.h"
72 #include "qtooltip.h"
73 #if QT_CONFIG(whatsthis)
74 #include "qwhatsthis.h"
75 #endif
76 #include "qdebug.h"
77 #include "private/qstylesheetstyle_p.h"
78 #include "private/qstyle_p.h"
79 #include "qfileinfo.h"
80 #include <QtGui/private/qhighdpiscaling_p.h>
81 #include <QtGui/qinputmethod.h>
82 #include <QtGui/qopenglcontext.h>
83 #include <QtGui/private/qopenglcontext_p.h>
84 #include <QtGui/qoffscreensurface.h>
85 
86 #if QT_CONFIG(graphicseffect)
87 #include <private/qgraphicseffect_p.h>
88 #endif
89 #include <qbackingstore.h>
90 #include <private/qwidgetbackingstore_p.h>
91 #if 0 // Used to be included in Qt4 for Q_WS_MAC
92 # include <private/qpaintengine_mac_p.h>
93 #endif
94 #include <private/qpaintengine_raster_p.h>
95 
96 #include "qwidget_p.h"
97 #include <QtGui/private/qwindow_p.h>
98 #include "qaction_p.h"
99 #include "qlayout_p.h"
100 #if QT_CONFIG(graphicsview)
101 #include "QtWidgets/qgraphicsproxywidget.h"
102 #include "QtWidgets/qgraphicsscene.h"
103 #include "private/qgraphicsproxywidget_p.h"
104 #endif
105 #include "QtWidgets/qabstractscrollarea.h"
106 #include "private/qabstractscrollarea_p.h"
107 #include "private/qevent_p.h"
108 
109 #include "private/qgesturemanager_p.h"
110 
111 #ifdef QT_KEYPAD_NAVIGATION
112 #if QT_CONFIG(tabwidget)
113 #include "qtabwidget.h" // Needed in inTabWidget()
114 #endif
115 #endif // QT_KEYPAD_NAVIGATION
116 
117 #include "qwindowcontainer_p.h"
118 
119 #include <QtPlatformHeaders/qxcbwindowfunctions.h>
120 
121 // widget/widget data creation count
122 //#define QWIDGET_EXTRA_DEBUG
123 //#define ALIEN_DEBUG
124 
125 QT_BEGIN_NAMESPACE
126 
127 static bool qt_enable_backingstore = true;
128 #if 0 // Used to be included in Qt4 for Q_WS_X11
129 // for compatibility with Qt 4.0
130 Q_WIDGETS_EXPORT void qt_x11_set_global_double_buffer(bool enable)
131 {
132     qt_enable_backingstore = enable;
133 }
134 #endif
135 
136 #if 0 // Used to be included in Qt4 for Q_WS_MAC
137 bool qt_mac_clearDirtyOnWidgetInsideDrawWidget = false;
138 #endif
139 
140 static inline bool qRectIntersects(const QRect &r1, const QRect &r2)
141 {
142     return (qMax(r1.left(), r2.left()) <= qMin(r1.right(), r2.right()) &&
143             qMax(r1.top(), r2.top()) <= qMin(r1.bottom(), r2.bottom()));
144 }
145 
146 static inline bool hasBackingStoreSupport()
147 {
148     return true;
149 }
150 
151 #if 0 // Used to be included in Qt4 for Q_WS_MAC
152 #  define QT_NO_PAINT_DEBUG
153 #endif
154 
155 extern bool qt_sendSpontaneousEvent(QObject*, QEvent*); // qapplication.cpp
156 extern QDesktopWidget *qt_desktopWidget; // qapplication.cpp
157 
158 /*!
159     \internal
160     \class QWidgetBackingStoreTracker
161     \brief Class which allows tracking of which widgets are using a given backing store
162 
163     QWidgetBackingStoreTracker is a thin wrapper around a QWidgetBackingStore pointer,
164     which maintains a list of the QWidgets which are currently using the backing
165     store.  This list is modified via the registerWidget and unregisterWidget functions.
166  */
167 
168 QWidgetBackingStoreTracker::QWidgetBackingStoreTracker()
169     :   m_ptr(0)
170 {
171 
172 }
173 
174 QWidgetBackingStoreTracker::~QWidgetBackingStoreTracker()
175 {
176     delete m_ptr;
177 }
178 
179 /*!
180     \internal
181     Destroy the contained QWidgetBackingStore, if not null, and clear the list of
182     widgets using the backing store, then create a new QWidgetBackingStore, providing
183     the QWidget.
184  */
185 void QWidgetBackingStoreTracker::create(QWidget *widget)
186 {
187     destroy();
188     m_ptr = new QWidgetBackingStore(widget);
189 }
190 
191 /*!
192     \internal
193     Destroy the contained QWidgetBackingStore, if not null, and clear the list of
194     widgets using the backing store.
195  */
196 void QWidgetBackingStoreTracker::destroy()
197 {
198     delete m_ptr;
199     m_ptr = 0;
200     m_widgets.clear();
201 }
202 
203 /*!
204     \internal
205     Add the widget to the list of widgets currently using the backing store.
206     If the widget was already in the list, this function is a no-op.
207  */
208 void QWidgetBackingStoreTracker::registerWidget(QWidget *w)
209 {
210     Q_ASSERT(m_ptr);
211     Q_ASSERT(w->internalWinId());
212     Q_ASSERT(qt_widget_private(w)->maybeBackingStore() == m_ptr);
213     m_widgets.insert(w);
214 }
215 
216 /*!
217     \internal
218     Remove the widget from the list of widgets currently using the backing store.
219     If the widget was in the list, and removing it causes the list to be empty,
220     the backing store is deleted.
221     If the widget was not in the list, this function is a no-op.
222  */
223 void QWidgetBackingStoreTracker::unregisterWidget(QWidget *w)
224 {
225     if (m_widgets.remove(w) && m_widgets.isEmpty()) {
226         delete m_ptr;
227         m_ptr = 0;
228     }
229 }
230 
231 /*!
232     \internal
233     Recursively remove widget and all of its descendents.
234  */
235 void QWidgetBackingStoreTracker::unregisterWidgetSubtree(QWidget *widget)
236 {
237     unregisterWidget(widget);
238     foreach (QObject *child, widget->children())
239         if (QWidget *childWidget = qobject_cast<QWidget *>(child))
240             unregisterWidgetSubtree(childWidget);
241 }
242 
243 QWidgetPrivate::QWidgetPrivate(int version)
244     : QObjectPrivate(version)
245       , extra(0)
246       , focus_next(0)
247       , focus_prev(0)
248       , focus_child(0)
249       , layout(0)
250       , needsFlush(0)
251       , redirectDev(0)
252       , widgetItem(0)
253       , extraPaintEngine(0)
254       , polished(0)
255       , graphicsEffect(0)
256 #if !defined(QT_NO_IM)
257       , imHints(Qt::ImhNone)
258 #endif
259 #ifndef QT_NO_TOOLTIP
260       , toolTipDuration(-1)
261 #endif
262       , inheritedFontResolveMask(0)
263       , inheritedPaletteResolveMask(0)
264       , leftmargin(0)
265       , topmargin(0)
266       , rightmargin(0)
267       , bottommargin(0)
268       , leftLayoutItemMargin(0)
269       , topLayoutItemMargin(0)
270       , rightLayoutItemMargin(0)
271       , bottomLayoutItemMargin(0)
272       , hd(0)
273       , size_policy(QSizePolicy::Preferred, QSizePolicy::Preferred)
274       , fg_role(QPalette::NoRole)
275       , bg_role(QPalette::NoRole)
276       , dirtyOpaqueChildren(1)
277       , isOpaque(0)
278       , retainSizeWhenHiddenChanged(0)
279       , inDirtyList(0)
280       , isScrolled(0)
281       , isMoved(0)
282       , usesDoubleBufferedGLContext(0)
283       , mustHaveWindowHandle(0)
284       , renderToTexture(0)
285       , textureChildSeen(0)
286 #ifndef QT_NO_IM
287       , inheritsInputMethodHints(0)
288 #endif
289 #ifndef QT_NO_OPENGL
290       , renderToTextureReallyDirty(1)
291       , renderToTextureComposeActive(0)
292 #endif
293       , childrenHiddenByWState(0)
294       , childrenShownByExpose(0)
295 #if defined(Q_OS_WIN)
296       , noPaintOnScreen(0)
297 #endif
298 #if 0 // Used to be included in Qt4 for Q_WS_X11
299       , picture(0)
300 #elif 0 // Used to be included in Qt4 for Q_WS_WIN
301   #ifndef QT_NO_GESTURES
302       , nativeGesturePanEnabled(0)
303   #endif
304 #elif 0 // Used to be included in Qt4 for Q_WS_MAC
305       , needWindowChange(0)
306       , window_event(0)
307       , qd_hd(0)
308 #endif
309 {
310     if (Q_UNLIKELY(!qApp)) {
311         qFatal("QWidget: Must construct a QApplication before a QWidget");
312         return;
313     }
314 
315 #ifdef QT_BUILD_INTERNAL
316     // Don't check the version parameter in internal builds.
317     // This allows incompatible versions to be loaded, possibly for testing.
318     Q_UNUSED(version);
319 #else
320     if (Q_UNLIKELY(version != QObjectPrivateVersion))
321         qFatal("Cannot mix incompatible Qt library (version 0x%x) with this library (version 0x%x)",
322                 version, QObjectPrivateVersion);
323 #endif
324 
325     isWidget = true;
326     memset(high_attributes, 0, sizeof(high_attributes));
327 #if 0 // Used to be included in Qt4 for Q_WS_MAC
328     drawRectOriginalAdded = false;
329     originalDrawMethod = true;
330     changeMethods = false;
331     isInUnifiedToolbar = false;
332     unifiedSurface = 0;
333     toolbar_ancestor = 0;
334     flushRequested = false;
335     touchEventsEnabled = false;
336 #endif
337 #ifdef QWIDGET_EXTRA_DEBUG
338     static int count = 0;
339     qDebug() << "widgets" << ++count;
340 #endif
341 }
342 
343 
344 QWidgetPrivate::~QWidgetPrivate()
345 {
346     if (widgetItem)
347         widgetItem->wid = 0;
348 
349     if (extra)
350         deleteExtra();
351 }
352 
353 /*!
354     \internal
355 */
356 void QWidgetPrivate::scrollChildren(int dx, int dy)
357 {
358     Q_Q(QWidget);
359     if (q->children().size() > 0) {        // scroll children
360         QPoint pd(dx, dy);
361         QObjectList childObjects = q->children();
362         for (int i = 0; i < childObjects.size(); ++i) { // move all children
363             QWidget *w = qobject_cast<QWidget*>(childObjects.at(i));
364             if (w && !w->isWindow()) {
365                 QPoint oldp = w->pos();
366                 QRect  r(w->pos() + pd, w->size());
367                 w->data->crect = r;
368                 if (w->testAttribute(Qt::WA_WState_Created))
369                     w->d_func()->setWSGeometry();
370                 w->d_func()->setDirtyOpaqueRegion();
371                 QMoveEvent e(r.topLeft(), oldp);
372                 QApplication::sendEvent(w, &e);
373             }
374         }
375     }
376 }
377 
378 void QWidgetPrivate::setWSGeometry()
379 {
380     Q_Q(QWidget);
381     if (QWindow *window = q->windowHandle())
382         window->setGeometry(data.crect);
383 }
384 
385 void QWidgetPrivate::updateWidgetTransform(QEvent *event)
386 {
387     Q_Q(QWidget);
388     if (q == QGuiApplication::focusObject() || event->type() == QEvent::FocusIn) {
389         QTransform t;
390         QPoint p = q->mapTo(q->topLevelWidget(), QPoint(0,0));
391         t.translate(p.x(), p.y());
392         QGuiApplication::inputMethod()->setInputItemTransform(t);
393         QGuiApplication::inputMethod()->setInputItemRectangle(q->rect());
394         QGuiApplication::inputMethod()->update(Qt::ImInputItemClipRectangle);
395     }
396 }
397 
398 #ifdef QT_KEYPAD_NAVIGATION
399 QPointer<QWidget> QWidgetPrivate::editingWidget;
400 
401 /*!
402     Returns \c true if this widget currently has edit focus; otherwise false.
403 
404     This feature is only available in Qt for Embedded Linux.
405 
406     \sa setEditFocus(), QApplication::keypadNavigationEnabled()
407 */
408 bool QWidget::hasEditFocus() const
409 {
410     const QWidget* w = this;
411     while (w->d_func()->extra && w->d_func()->extra->focus_proxy)
412         w = w->d_func()->extra->focus_proxy;
413     return QWidgetPrivate::editingWidget == w;
414 }
415 
416 /*!
417     \fn void QWidget::setEditFocus(bool enable)
418 
419     If \a enable is true, make this widget have edit focus, in which
420     case Qt::Key_Up and Qt::Key_Down will be delivered to the widget
421     normally; otherwise, Qt::Key_Up and Qt::Key_Down are used to
422     change focus.
423 
424     This feature is only available in Qt for Embedded Linux.
425 
426     \sa hasEditFocus(), QApplication::keypadNavigationEnabled()
427 */
428 void QWidget::setEditFocus(bool on)
429 {
430     QWidget *f = this;
431     while (f->d_func()->extra && f->d_func()->extra->focus_proxy)
432         f = f->d_func()->extra->focus_proxy;
433 
434     if (QWidgetPrivate::editingWidget && QWidgetPrivate::editingWidget != f)
435         QWidgetPrivate::editingWidget->setEditFocus(false);
436 
437     if (on && !f->hasFocus())
438         f->setFocus();
439 
440     if ((!on && !QWidgetPrivate::editingWidget)
441         || (on && QWidgetPrivate::editingWidget == f)) {
442         return;
443     }
444 
445     if (!on && QWidgetPrivate::editingWidget == f) {
446         QWidgetPrivate::editingWidget = 0;
447         QEvent event(QEvent::LeaveEditFocus);
448         QApplication::sendEvent(f, &event);
449         QApplication::sendEvent(f->style(), &event);
450     } else if (on) {
451         QWidgetPrivate::editingWidget = f;
452         QEvent event(QEvent::EnterEditFocus);
453         QApplication::sendEvent(f, &event);
454         QApplication::sendEvent(f->style(), &event);
455     }
456 }
457 #endif
458 
459 /*!
460     \property QWidget::autoFillBackground
461     \brief whether the widget background is filled automatically
462     \since 4.1
463 
464     If enabled, this property will cause Qt to fill the background of the
465     widget before invoking the paint event. The color used is defined by the
466     QPalette::Window color role from the widget's \l{QPalette}{palette}.
467 
468     In addition, Windows are always filled with QPalette::Window, unless the
469     WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.
470 
471     This property cannot be turned off (i.e., set to false) if a widget's
472     parent has a static gradient for its background.
473 
474     \warning Use this property with caution in conjunction with
475     \l{Qt Style Sheets}. When a widget has a style sheet with a valid
476     background or a border-image, this property is automatically disabled.
477 
478     By default, this property is \c false.
479 
480     \sa Qt::WA_OpaquePaintEvent, Qt::WA_NoSystemBackground,
481     {QWidget#Transparency and Double Buffering}{Transparency and Double Buffering}
482 */
483 bool QWidget::autoFillBackground() const
484 {
485     Q_D(const QWidget);
486     return d->extra && d->extra->autoFillBackground;
487 }
488 
489 void QWidget::setAutoFillBackground(bool enabled)
490 {
491     Q_D(QWidget);
492     if (!d->extra)
493         d->createExtra();
494     if (d->extra->autoFillBackground == enabled)
495         return;
496 
497     d->extra->autoFillBackground = enabled;
498     d->updateIsOpaque();
499     update();
500     d->updateIsOpaque();
501 }
502 
503 /*!
504     \class QWidget
505     \brief The QWidget class is the base class of all user interface objects.
506 
507     \ingroup basicwidgets
508     \inmodule QtWidgets
509 
510     The widget is the atom of the user interface: it receives mouse, keyboard
511     and other events from the window system, and paints a representation of
512     itself on the screen. Every widget is rectangular, and they are sorted in a
513     Z-order. A widget is clipped by its parent and by the widgets in front of
514     it.
515 
516     A widget that is not embedded in a parent widget is called a window.
517     Usually, windows have a frame and a title bar, although it is also possible
518     to create windows without such decoration using suitable
519     \l{Qt::WindowFlags}{window flags}). In Qt, QMainWindow and the various
520     subclasses of QDialog are the most common window types.
521 
522     Every widget's constructor accepts one or two standard arguments:
523 
524     \list 1
525         \li  \c{QWidget *parent = 0} is the parent of the new widget. If it is 0
526             (the default), the new widget will be a window. If not, it will be
527             a child of \e parent, and be constrained by \e parent's geometry
528             (unless you specify Qt::Window as window flag).
529         \li  \c{Qt::WindowFlags f = 0} (where available) sets the window flags;
530             the default is suitable for almost all widgets, but to get, for
531             example, a window without a window system frame, you must use
532             special flags.
533     \endlist
534 
535     QWidget has many member functions, but some of them have little direct
536     functionality; for example, QWidget has a font property, but never uses
537     this itself. There are many subclasses which provide real functionality,
538     such as QLabel, QPushButton, QListWidget, and QTabWidget.
539 
540 
541     \section1 Top-Level and Child Widgets
542 
543     A widget without a parent widget is always an independent window (top-level
544     widget). For these widgets, setWindowTitle() and setWindowIcon() set the
545     title bar and icon respectively.
546 
547     Non-window widgets are child widgets, displayed within their parent
548     widgets. Most widgets in Qt are mainly useful as child widgets. For
549     example, it is possible to display a button as a top-level window, but most
550     people prefer to put their buttons inside other widgets, such as QDialog.
551 
552     \image parent-child-widgets.png A parent widget containing various child widgets.
553 
554     The diagram above shows a QGroupBox widget being used to hold various child
555     widgets in a layout provided by QGridLayout. The QLabel child widgets have
556     been outlined to indicate their full sizes.
557 
558     If you want to use a QWidget to hold child widgets you will usually want to
559     add a layout to the parent QWidget. See \l{Layout Management} for more
560     information.
561 
562 
563     \section1 Composite Widgets
564 
565     When a widget is used as a container to group a number of child widgets, it
566     is known as a composite widget. These can be created by constructing a
567     widget with the required visual properties - a QFrame, for example - and
568     adding child widgets to it, usually managed by a layout. The above diagram
569     shows such a composite widget that was created using Qt Designer.
570 
571     Composite widgets can also be created by subclassing a standard widget,
572     such as QWidget or QFrame, and adding the necessary layout and child
573     widgets in the constructor of the subclass. Many of the \l{Qt Widgets Examples}
574     {examples provided with Qt} use this approach, and it is also covered in
575     the Qt \l{Tutorials}.
576 
577 
578     \section1 Custom Widgets and Painting
579 
580     Since QWidget is a subclass of QPaintDevice, subclasses can be used to
581     display custom content that is composed using a series of painting
582     operations with an instance of the QPainter class. This approach contrasts
583     with the canvas-style approach used by the \l{Graphics View}
584     {Graphics View Framework} where items are added to a scene by the
585     application and are rendered by the framework itself.
586 
587     Each widget performs all painting operations from within its paintEvent()
588     function. This is called whenever the widget needs to be redrawn, either
589     as a result of some external change or when requested by the application.
590 
591     The \l{widgets/analogclock}{Analog Clock example} shows how a simple widget
592     can handle paint events.
593 
594 
595     \section1 Size Hints and Size Policies
596 
597     When implementing a new widget, it is almost always useful to reimplement
598     sizeHint() to provide a reasonable default size for the widget and to set
599     the correct size policy with setSizePolicy().
600 
601     By default, composite widgets which do not provide a size hint will be
602     sized according to the space requirements of their child widgets.
603 
604     The size policy lets you supply good default behavior for the layout
605     management system, so that other widgets can contain and manage yours
606     easily. The default size policy indicates that the size hint represents
607     the preferred size of the widget, and this is often good enough for many
608     widgets.
609 
610     \note The size of top-level widgets are constrained to 2/3 of the desktop's
611     height and width. You can resize() the widget manually if these bounds are
612     inadequate.
613 
614 
615     \section1 Events
616 
617     Widgets respond to events that are typically caused by user actions. Qt
618     delivers events to widgets by calling specific event handler functions with
619     instances of QEvent subclasses containing information about each event.
620 
621     If your widget only contains child widgets, you probably do not need to
622     implement any event handlers. If you want to detect a mouse click in a
623     child widget call the child's underMouse() function inside the widget's
624     mousePressEvent().
625 
626     The \l{widgets/scribble}{Scribble example} implements a wider set of
627     events to handle mouse movement, button presses, and window resizing.
628 
629     You will need to supply the behavior and content for your own widgets, but
630     here is a brief overview of the events that are relevant to QWidget,
631     starting with the most common ones:
632 
633     \list
634         \li  paintEvent() is called whenever the widget needs to be repainted.
635             Every widget displaying custom content must implement it. Painting
636             using a QPainter can only take place in a paintEvent() or a
637             function called by a paintEvent().
638         \li  resizeEvent() is called when the widget has been resized.
639         \li  mousePressEvent() is called when a mouse button is pressed while
640             the mouse cursor is inside the widget, or when the widget has
641             grabbed the mouse using grabMouse(). Pressing the mouse without
642             releasing it is effectively the same as calling grabMouse().
643         \li  mouseReleaseEvent() is called when a mouse button is released. A
644             widget receives mouse release events when it has received the
645             corresponding mouse press event. This means that if the user
646             presses the mouse inside \e your widget, then drags the mouse
647             somewhere else before releasing the mouse button, \e your widget
648             receives the release event. There is one exception: if a popup menu
649             appears while the mouse button is held down, this popup immediately
650             steals the mouse events.
651         \li  mouseDoubleClickEvent() is called when the user double-clicks in
652             the widget. If the user double-clicks, the widget receives a mouse
653             press event, a mouse release event, (a mouse click event,) a second
654             mouse press, this event and finally a second mouse release event.
655             (Some mouse move events may also be
656             received if the mouse is not held steady during this operation.) It
657             is \e{not possible} to distinguish a click from a double-click
658             until the second click arrives. (This is one reason why most GUI
659             books recommend that double-clicks be an extension of
660             single-clicks, rather than trigger a different action.)
661     \endlist
662 
663     Widgets that accept keyboard input need to reimplement a few more event
664     handlers:
665 
666     \list
667         \li  keyPressEvent() is called whenever a key is pressed, and again when
668             a key has been held down long enough for it to auto-repeat. The
669             \uicontrol Tab and \uicontrol Shift+Tab keys are only passed to the widget if
670             they are not used by the focus-change mechanisms. To force those
671             keys to be processed by your widget, you must reimplement
672             QWidget::event().
673         \li  focusInEvent() is called when the widget gains keyboard focus
674             (assuming you have called setFocusPolicy()). Well-behaved widgets
675             indicate that they own the keyboard focus in a clear but discreet
676             way.
677         \li  focusOutEvent() is called when the widget loses keyboard focus.
678     \endlist
679 
680     You may be required to also reimplement some of the less common event
681     handlers:
682 
683     \list
684         \li  mouseMoveEvent() is called whenever the mouse moves while a mouse
685             button is held down. This can be useful during drag and drop
686             operations. If you call \l{setMouseTracking()}{setMouseTracking}(true),
687             you get mouse move events even when no buttons are held down.
688             (See also the \l{Drag and Drop} guide.)
689         \li  keyReleaseEvent() is called whenever a key is released and while it
690             is held down (if the key is auto-repeating). In that case, the
691             widget will receive a pair of key release and key press event for
692             every repeat. The \uicontrol Tab and \uicontrol Shift+Tab keys are only passed
693             to the widget if they are not used by the focus-change mechanisms.
694             To force those keys to be processed by your widget, you must
695             reimplement QWidget::event().
696         \li  wheelEvent() is called whenever the user turns the mouse wheel
697             while the widget has the focus.
698         \li  enterEvent() is called when the mouse enters the widget's screen
699             space. (This excludes screen space owned by any of the widget's
700             children.)
701         \li  leaveEvent() is called when the mouse leaves the widget's screen
702             space. If the mouse enters a child widget it will not cause a
703             leaveEvent().
704         \li  moveEvent() is called when the widget has been moved relative to
705             its parent.
706         \li  closeEvent() is called when the user closes the widget (or when
707             close() is called).
708     \endlist
709 
710     There are also some rather obscure events described in the documentation
711     for QEvent::Type. To handle these events, you need to reimplement event()
712     directly.
713 
714     The default implementation of event() handles \uicontrol Tab and \uicontrol Shift+Tab
715     (to move the keyboard focus), and passes on most of the other events to
716     one of the more specialized handlers above.
717 
718     Events and the mechanism used to deliver them are covered in
719     \l{The Event System}.
720 
721     \section1 Groups of Functions and Properties
722 
723     \table
724     \header \li Context \li Functions and Properties
725 
726     \row \li Window functions \li
727         show(),
728         hide(),
729         raise(),
730         lower(),
731         close().
732 
733     \row \li Top-level windows \li
734         \l windowModified, \l windowTitle, \l windowIcon,
735         \l isActiveWindow, activateWindow(), \l minimized, showMinimized(),
736         \l maximized, showMaximized(), \l fullScreen, showFullScreen(),
737         showNormal().
738 
739     \row \li Window contents \li
740         update(),
741         repaint(),
742         scroll().
743 
744     \row \li Geometry \li
745         \l pos, x(), y(), \l rect, \l size, width(), height(), move(), resize(),
746         \l sizePolicy, sizeHint(), minimumSizeHint(),
747         updateGeometry(), layout(),
748         \l frameGeometry, \l geometry, \l childrenRect, \l childrenRegion,
749         adjustSize(),
750         mapFromGlobal(), mapToGlobal(),
751         mapFromParent(), mapToParent(),
752         \l maximumSize, \l minimumSize, \l sizeIncrement,
753         \l baseSize, setFixedSize()
754 
755     \row \li Mode \li
756         \l visible, isVisibleTo(),
757         \l enabled, isEnabledTo(),
758         \l modal,
759         isWindow(),
760         \l mouseTracking,
761         \l updatesEnabled,
762         visibleRegion().
763 
764     \row \li Look and feel \li
765         style(),
766         setStyle(),
767         \l styleSheet,
768         \l cursor,
769         \l font,
770         \l palette,
771         backgroundRole(), setBackgroundRole(),
772         fontInfo(), fontMetrics().
773 
774     \row \li Keyboard focus functions \li
775         \l focus, \l focusPolicy,
776         setFocus(), clearFocus(), setTabOrder(), setFocusProxy(),
777         focusNextChild(), focusPreviousChild().
778 
779     \row \li Mouse and keyboard grabbing \li
780         grabMouse(), releaseMouse(),
781         grabKeyboard(), releaseKeyboard(),
782         mouseGrabber(), keyboardGrabber().
783 
784     \row \li Event handlers \li
785         event(),
786         mousePressEvent(),
787         mouseReleaseEvent(),
788         mouseDoubleClickEvent(),
789         mouseMoveEvent(),
790         keyPressEvent(),
791         keyReleaseEvent(),
792         focusInEvent(),
793         focusOutEvent(),
794         wheelEvent(),
795         enterEvent(),
796         leaveEvent(),
797         paintEvent(),
798         moveEvent(),
799         resizeEvent(),
800         closeEvent(),
801         dragEnterEvent(),
802         dragMoveEvent(),
803         dragLeaveEvent(),
804         dropEvent(),
805         childEvent(),
806         showEvent(),
807         hideEvent(),
808         customEvent().
809         changeEvent(),
810 
811     \row \li System functions \li
812         parentWidget(), window(), setParent(), winId(),
813         find(), metric().
814 
815     \row \li Context menu \li
816        contextMenuPolicy, contextMenuEvent(),
817        customContextMenuRequested(), actions()
818 
819     \row \li Interactive help \li
820         setToolTip(), setWhatsThis()
821 
822     \endtable
823 
824 
825     \section1 Widget Style Sheets
826 
827     In addition to the standard widget styles for each platform, widgets can
828     also be styled according to rules specified in a \l{styleSheet}
829     {style sheet}. This feature enables you to customize the appearance of
830     specific widgets to provide visual cues to users about their purpose. For
831     example, a button could be styled in a particular way to indicate that it
832     performs a destructive action.
833 
834     The use of widget style sheets is described in more detail in the
835     \l{Qt Style Sheets} document.
836 
837 
838     \section1 Transparency and Double Buffering
839 
840     Since Qt 4.0, QWidget automatically double-buffers its painting, so there
841     is no need to write double-buffering code in paintEvent() to avoid
842     flicker.
843 
844     Since Qt 4.1, the Qt::WA_ContentsPropagated widget attribute has been
845     deprecated. Instead, the contents of parent widgets are propagated by
846     default to each of their children as long as Qt::WA_PaintOnScreen is not
847     set. Custom widgets can be written to take advantage of this feature by
848     updating irregular regions (to create non-rectangular child widgets), or
849     painting with colors that have less than full alpha component. The
850     following diagram shows how attributes and properties of a custom widget
851     can be fine-tuned to achieve different effects.
852 
853     \image propagation-custom.png
854 
855     In the above diagram, a semi-transparent rectangular child widget with an
856     area removed is constructed and added to a parent widget (a QLabel showing
857     a pixmap). Then, different properties and widget attributes are set to
858     achieve different effects:
859 
860     \list
861         \li  The left widget has no additional properties or widget attributes
862             set. This default state suits most custom widgets using
863             transparency, are irregularly-shaped, or do not paint over their
864             entire area with an opaque brush.
865         \li  The center widget has the \l autoFillBackground property set. This
866             property is used with custom widgets that rely on the widget to
867             supply a default background, and do not paint over their entire
868             area with an opaque brush.
869         \li  The right widget has the Qt::WA_OpaquePaintEvent widget attribute
870             set. This indicates that the widget will paint over its entire area
871             with opaque colors. The widget's area will initially be
872             \e{uninitialized}, represented in the diagram with a red diagonal
873             grid pattern that shines through the overpainted area. The
874             Qt::WA_OpaquePaintArea attribute is useful for widgets that need to
875             paint their own specialized contents quickly and do not need a
876             default filled background.
877     \endlist
878 
879     To rapidly update custom widgets with simple background colors, such as
880     real-time plotting or graphing widgets, it is better to define a suitable
881     background color (using setBackgroundRole() with the
882     QPalette::Window role), set the \l autoFillBackground property, and only
883     implement the necessary drawing functionality in the widget's paintEvent().
884 
885     To rapidly update custom widgets that constantly paint over their entire
886     areas with opaque content, e.g., video streaming widgets, it is better to
887     set the widget's Qt::WA_OpaquePaintEvent, avoiding any unnecessary overhead
888     associated with repainting the widget's background.
889 
890     If a widget has both the Qt::WA_OpaquePaintEvent widget attribute \e{and}
891     the \l autoFillBackground property set, the Qt::WA_OpaquePaintEvent
892     attribute takes precedence. Depending on your requirements, you should
893     choose either one of them.
894 
895     Since Qt 4.1, the contents of parent widgets are also propagated to
896     standard Qt widgets. This can lead to some unexpected results if the
897     parent widget is decorated in a non-standard way, as shown in the diagram
898     below.
899 
900     \image propagation-standard.png
901 
902     The scope for customizing the painting behavior of standard Qt widgets,
903     without resorting to subclassing, is slightly less than that possible for
904     custom widgets. Usually, the desired appearance of a standard widget can be
905     achieved by setting its \l autoFillBackground property.
906 
907 
908     \section1 Creating Translucent Windows
909 
910     Since Qt 4.5, it has been possible to create windows with translucent regions
911     on window systems that support compositing.
912 
913     To enable this feature in a top-level widget, set its Qt::WA_TranslucentBackground
914     attribute with setAttribute() and ensure that its background is painted with
915     non-opaque colors in the regions you want to be partially transparent.
916 
917     Platform notes:
918 
919     \list
920     \li X11: This feature relies on the use of an X server that supports ARGB visuals
921     and a compositing window manager.
922     \li Windows: The widget needs to have the Qt::FramelessWindowHint window flag set
923     for the translucency to work.
924     \endlist
925 
926 
927     \section1 Native Widgets vs Alien Widgets
928 
929     Introduced in Qt 4.4, alien widgets are widgets unknown to the windowing
930     system. They do not have a native window handle associated with them. This
931     feature significantly speeds up widget painting, resizing, and removes flicker.
932 
933     Should you require the old behavior with native windows, you can choose
934     one of the following options:
935 
936     \list 1
937         \li  Use the \c{QT_USE_NATIVE_WINDOWS=1} in your environment.
938         \li  Set the Qt::AA_NativeWindows attribute on your application. All
939             widgets will be native widgets.
940         \li  Set the Qt::WA_NativeWindow attribute on widgets: The widget itself
941             and all of its ancestors will become native (unless
942             Qt::WA_DontCreateNativeAncestors is set).
943         \li  Call QWidget::winId to enforce a native window (this implies 3).
944         \li  Set the Qt::WA_PaintOnScreen attribute to enforce a native window
945             (this implies 3).
946     \endlist
947 
948     \sa QEvent, QPainter, QGridLayout, QBoxLayout
949 
950 */
951 
952 QWidgetMapper *QWidgetPrivate::mapper = 0;          // widget with wid
953 QWidgetSet *QWidgetPrivate::allWidgets = 0;         // widgets with no wid
954 
955 
956 /*****************************************************************************
957   QWidget utility functions
958  *****************************************************************************/
959 
960 QRegion qt_dirtyRegion(QWidget *widget)
961 {
962     if (!widget)
963         return QRegion();
964 
965     QWidgetBackingStore *bs = qt_widget_private(widget)->maybeBackingStore();
966     if (!bs)
967         return QRegion();
968 
969     return bs->dirtyRegion(widget);
970 }
971 
972 /*****************************************************************************
973   QWidget member functions
974  *****************************************************************************/
975 
976 /*
977     Widget state flags:
978   \list
979   \li Qt::WA_WState_Created The widget has a valid winId().
980   \li Qt::WA_WState_Visible The widget is currently visible.
981   \li Qt::WA_WState_Hidden The widget is hidden, i.e. it won't
982   become visible unless you call show() on it. Qt::WA_WState_Hidden
983   implies !Qt::WA_WState_Visible.
984   \li Qt::WA_WState_CompressKeys Compress keyboard events.
985   \li Qt::WA_WState_BlockUpdates Repaints and updates are disabled.
986   \li Qt::WA_WState_InPaintEvent Currently processing a paint event.
987   \li Qt::WA_WState_Reparented The widget has been reparented.
988   \li Qt::WA_WState_ConfigPending A configuration (resize/move) event is pending.
989   \li Qt::WA_WState_DND (Deprecated) The widget supports drag and drop, see setAcceptDrops().
990   \endlist
991 */
992 
993 struct QWidgetExceptionCleaner
994 {
995     /* this cleans up when the constructor throws an exception */
996     static inline void cleanup(QWidget *that, QWidgetPrivate *d)
997     {
998 #ifdef QT_NO_EXCEPTIONS
999         Q_UNUSED(that);
1000         Q_UNUSED(d);
1001 #else
1002         QWidgetPrivate::allWidgets->remove(that);
1003         if (d->focus_next != that) {
1004             if (d->focus_next)
1005                 d->focus_next->d_func()->focus_prev = d->focus_prev;
1006             if (d->focus_prev)
1007                 d->focus_prev->d_func()->focus_next = d->focus_next;
1008         }
1009 #endif
1010     }
1011 };
1012 
1013 /*!
1014     Constructs a widget which is a child of \a parent, with  widget
1015     flags set to \a f.
1016 
1017     If \a parent is 0, the new widget becomes a window. If
1018     \a parent is another widget, this widget becomes a child window
1019     inside \a parent. The new widget is deleted when its \a parent is
1020     deleted.
1021 
1022     The widget flags argument, \a f, is normally 0, but it can be set
1023     to customize the frame of a window (i.e. \a
1024     parent must be 0). To customize the frame, use a value composed
1025     from the bitwise OR of any of the \l{Qt::WindowFlags}{window flags}.
1026 
1027     If you add a child widget to an already visible widget you must
1028     explicitly show the child to make it visible.
1029 
1030     Note that the X11 version of Qt may not be able to deliver all
1031     combinations of style flags on all systems. This is because on
1032     X11, Qt can only ask the window manager, and the window manager
1033     can override the application's settings. On Windows, Qt can set
1034     whatever flags you want.
1035 
1036     \sa windowFlags
1037 */
1038 QWidget::QWidget(QWidget *parent, Qt::WindowFlags f)
1039     : QObject(*new QWidgetPrivate, 0), QPaintDevice()
1040 {
1041     QT_TRY {
1042         d_func()->init(parent, f);
1043     } QT_CATCH(...) {
1044         QWidgetExceptionCleaner::cleanup(this, d_func());
1045         QT_RETHROW;
1046     }
1047 }
1048 
1049 
1050 /*! \internal
1051 */
1052 QWidget::QWidget(QWidgetPrivate &dd, QWidget* parent, Qt::WindowFlags f)
1053     : QObject(dd, 0), QPaintDevice()
1054 {
1055     Q_D(QWidget);
1056     QT_TRY {
1057         d->init(parent, f);
1058     } QT_CATCH(...) {
1059         QWidgetExceptionCleaner::cleanup(this, d_func());
1060         QT_RETHROW;
1061     }
1062 }
1063 
1064 /*!
1065     \internal
1066 */
1067 int QWidget::devType() const
1068 {
1069     return QInternal::Widget;
1070 }
1071 
1072 
1073 //### w is a "this" ptr, passed as a param because QWorkspace needs special logic
1074 void QWidgetPrivate::adjustFlags(Qt::WindowFlags &flags, QWidget *w)
1075 {
1076     bool customize =  (flags & (Qt::CustomizeWindowHint
1077             | Qt::FramelessWindowHint
1078             | Qt::WindowTitleHint
1079             | Qt::WindowSystemMenuHint
1080             | Qt::WindowMinimizeButtonHint
1081             | Qt::WindowMaximizeButtonHint
1082             | Qt::WindowCloseButtonHint
1083             | Qt::WindowContextHelpButtonHint));
1084 
1085     uint type = (flags & Qt::WindowType_Mask);
1086 
1087     if ((type == Qt::Widget || type == Qt::SubWindow) && w && !w->parent()) {
1088         type = Qt::Window;
1089         flags |= Qt::Window;
1090     }
1091 
1092     if (flags & Qt::CustomizeWindowHint) {
1093         // modify window flags to make them consistent.
1094         // Only enable this on non-Mac platforms. Since the old way of doing this would
1095         // interpret WindowSystemMenuHint as a close button and we can't change that behavior
1096         // we can't just add this in.
1097 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
1098         if ((flags & (Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint | Qt::WindowContextHelpButtonHint))
1099 #  ifdef Q_OS_WIN
1100             && type != Qt::Dialog // QTBUG-2027, allow for menu-less dialogs.
1101 #  endif
1102            ) {
1103             flags |= Qt::WindowSystemMenuHint;
1104 #else
1105         if (flags & (Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint
1106                      | Qt::WindowSystemMenuHint)) {
1107 #endif
1108             flags |= Qt::WindowTitleHint;
1109             flags &= ~Qt::FramelessWindowHint;
1110         }
1111     } else if (customize && !(flags & Qt::FramelessWindowHint)) {
1112         // if any of the window hints that affect the titlebar are set
1113         // and the window is supposed to have frame, we add a titlebar
1114         // and system menu by default.
1115         flags |= Qt::WindowSystemMenuHint;
1116         flags |= Qt::WindowTitleHint;
1117     }
1118     if (customize)
1119         ; // don't modify window flags if the user explicitly set them.
1120     else if (type == Qt::Dialog || type == Qt::Sheet) {
1121         flags |= Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint;
1122         // ### fixme: Qt 6: Never set Qt::WindowContextHelpButtonHint flag automatically
1123         if (!QApplicationPrivate::testAttribute(Qt::AA_DisableWindowContextHelpButton))
1124             flags |= Qt::WindowContextHelpButtonHint;
1125     } else if (type == Qt::Tool)
1126         flags |= Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowCloseButtonHint;
1127     else
1128         flags |= Qt::WindowTitleHint | Qt::WindowSystemMenuHint | Qt::WindowMinimizeButtonHint |
1129                 Qt::WindowMaximizeButtonHint | Qt::WindowCloseButtonHint | Qt::WindowFullscreenButtonHint;
1130     if (w->testAttribute(Qt::WA_TransparentForMouseEvents))
1131         flags |= Qt::WindowTransparentForInput;
1132 }
1133 
1134 void QWidgetPrivate::init(QWidget *parentWidget, Qt::WindowFlags f)
1135 {
1136     Q_Q(QWidget);
1137     if (Q_UNLIKELY(!qobject_cast<QApplication *>(QCoreApplication::instance())))
1138         qFatal("QWidget: Cannot create a QWidget without QApplication");
1139 
1140     Q_ASSERT(allWidgets);
1141     if (allWidgets)
1142         allWidgets->insert(q);
1143 
1144     int targetScreen = -1;
1145     if (parentWidget && parentWidget->windowType() == Qt::Desktop) {
1146         const QDesktopScreenWidget *sw = qobject_cast<const QDesktopScreenWidget *>(parentWidget);
1147         targetScreen = sw ? sw->screenNumber() : 0;
1148         parentWidget = 0;
1149     }
1150 
1151     q->data = &data;
1152 
1153 #ifndef QT_NO_THREAD
1154     if (!parent) {
1155         Q_ASSERT_X(q->thread() == qApp->thread(), "QWidget",
1156                    "Widgets must be created in the GUI thread.");
1157     }
1158 #endif
1159 
1160 #if 0 // Used to be included in Qt4 for Q_WS_X11
1161     if (desktopWidget) {
1162         // make sure the widget is created on the same screen as the
1163         // programmer specified desktop widget
1164         xinfo = desktopWidget->d_func()->xinfo;
1165     }
1166 #endif
1167     if (targetScreen >= 0) {
1168         topData()->initialScreenIndex = targetScreen;
1169         if (QWindow *window = q->windowHandle())
1170             window->setScreen(QGuiApplication::screens().value(targetScreen, nullptr));
1171     }
1172 
1173     data.fstrut_dirty = true;
1174 
1175     data.winid = 0;
1176     data.widget_attributes = 0;
1177     data.window_flags = f;
1178     data.window_state = 0;
1179     data.focus_policy = 0;
1180     data.context_menu_policy = Qt::DefaultContextMenu;
1181     data.window_modality = Qt::NonModal;
1182 
1183     data.sizehint_forced = 0;
1184     data.is_closing = 0;
1185     data.in_show = 0;
1186     data.in_set_window_state = 0;
1187     data.in_destructor = false;
1188 
1189     // Widgets with Qt::MSWindowsOwnDC (typically QGLWidget) must have a window handle.
1190     if (f & Qt::MSWindowsOwnDC) {
1191         mustHaveWindowHandle = 1;
1192         q->setAttribute(Qt::WA_NativeWindow);
1193     }
1194 //#if 0 // Used to be included in Qt4 for Q_WS_MAC
1195 //    q->setAttribute(Qt::WA_NativeWindow);
1196 //#endif
1197 
1198     q->setAttribute(Qt::WA_QuitOnClose); // might be cleared in adjustQuitOnCloseAttribute()
1199     adjustQuitOnCloseAttribute();
1200 
1201     q->setAttribute(Qt::WA_WState_Hidden);
1202 
1203     //give potential windows a bigger "pre-initial" size; create_sys() will give them a new size later
1204     data.crect = parentWidget ? QRect(0,0,100,30) : QRect(0,0,640,480);
1205     focus_next = focus_prev = q;
1206 
1207     if ((f & Qt::WindowType_Mask) == Qt::Desktop)
1208         q->create();
1209     else if (parentWidget)
1210         q->setParent(parentWidget, data.window_flags);
1211     else {
1212         adjustFlags(data.window_flags, q);
1213         resolveLayoutDirection();
1214         // opaque system background?
1215         const QBrush &background = q->palette().brush(QPalette::Window);
1216         setOpaque(q->isWindow() && background.style() != Qt::NoBrush && background.isOpaque());
1217     }
1218     data.fnt = QFont(data.fnt, q);
1219 #if 0 // Used to be included in Qt4 for Q_WS_X11
1220     data.fnt.x11SetScreen(xinfo.screen());
1221 #endif
1222 
1223     q->setAttribute(Qt::WA_PendingMoveEvent);
1224     q->setAttribute(Qt::WA_PendingResizeEvent);
1225 
1226     if (++QWidgetPrivate::instanceCounter > QWidgetPrivate::maxInstances)
1227         QWidgetPrivate::maxInstances = QWidgetPrivate::instanceCounter;
1228 
1229     if (QApplicationPrivate::testAttribute(Qt::AA_ImmediateWidgetCreation)) // ### fixme: Qt 6: Remove AA_ImmediateWidgetCreation.
1230         q->create();
1231 
1232     QEvent e(QEvent::Create);
1233     QApplication::sendEvent(q, &e);
1234     QApplication::postEvent(q, new QEvent(QEvent::PolishRequest));
1235 
1236     extraPaintEngine = 0;
1237 
1238 #if 0 // Used to be included in Qt4 for Q_WS_MAC
1239     // If we add a child to the unified toolbar, we have to redirect the painting.
1240     if (parentWidget && parentWidget->d_func() && parentWidget->d_func()->isInUnifiedToolbar) {
1241         if (parentWidget->d_func()->unifiedSurface) {
1242             QWidget *toolbar = parentWidget->d_func()->toolbar_ancestor;
1243             parentWidget->d_func()->unifiedSurface->recursiveRedirect(toolbar, toolbar, toolbar->d_func()->toolbar_offset);
1244         }
1245     }
1246 #endif
1247 }
1248 
1249 
1250 
1251 void QWidgetPrivate::createRecursively()
1252 {
1253     Q_Q(QWidget);
1254     q->create(0, true, true);
1255     for (int i = 0; i < children.size(); ++i) {
1256         QWidget *child = qobject_cast<QWidget *>(children.at(i));
1257         if (child && !child->isHidden() && !child->isWindow() && !child->testAttribute(Qt::WA_WState_Created))
1258             child->d_func()->createRecursively();
1259     }
1260 }
1261 
1262 
1263 // ### fixme: Qt 6: Remove parameter window from QWidget::create()
1264 
1265 /*!
1266     Creates a new widget window.
1267 
1268     The parameter \a window is ignored in Qt 5. Please use
1269     QWindow::fromWinId() to create a QWindow wrapping a foreign
1270     window and pass it to QWidget::createWindowContainer() instead.
1271 
1272     Initializes the window (sets the geometry etc.) if \a
1273     initializeWindow is true. If \a initializeWindow is false, no
1274     initialization is performed. This parameter only makes sense if \a
1275     window is a valid window.
1276 
1277     Destroys the old window if \a destroyOldWindow is true. If \a
1278     destroyOldWindow is false, you are responsible for destroying the
1279     window yourself (using platform native code).
1280 
1281     The QWidget constructor calls create(0,true,true) to create a
1282     window for this widget.
1283 
1284     \sa createWindowContainer(), QWindow::fromWinId()
1285 */
1286 
1287 void QWidget::create(WId window, bool initializeWindow, bool destroyOldWindow)
1288 {
1289     Q_D(QWidget);
1290     if (Q_UNLIKELY(window))
1291         qWarning("QWidget::create(): Parameter 'window' does not have any effect.");
1292     if (testAttribute(Qt::WA_WState_Created) && window == 0 && internalWinId())
1293         return;
1294 
1295     if (d->data.in_destructor)
1296         return;
1297 
1298     Qt::WindowType type = windowType();
1299     Qt::WindowFlags &flags = data->window_flags;
1300 
1301     if ((type == Qt::Widget || type == Qt::SubWindow) && !parentWidget()) {
1302         type = Qt::Window;
1303         flags |= Qt::Window;
1304     }
1305 
1306     if (QWidget *parent = parentWidget()) {
1307         if (type & Qt::Window) {
1308             if (!parent->testAttribute(Qt::WA_WState_Created))
1309                 parent->createWinId();
1310         } else if (testAttribute(Qt::WA_NativeWindow) && !parent->internalWinId()
1311                    && !testAttribute(Qt::WA_DontCreateNativeAncestors)) {
1312             // We're about to create a native child widget that doesn't have a native parent;
1313             // enforce a native handle for the parent unless the Qt::WA_DontCreateNativeAncestors
1314             // attribute is set.
1315             d->createWinId();
1316             // Nothing more to do.
1317             Q_ASSERT(testAttribute(Qt::WA_WState_Created));
1318             Q_ASSERT(internalWinId());
1319             return;
1320         }
1321     }
1322 
1323 
1324     static const bool paintOnScreenEnv = qEnvironmentVariableIntValue("QT_ONSCREEN_PAINT") > 0;
1325     if (paintOnScreenEnv)
1326         setAttribute(Qt::WA_PaintOnScreen);
1327 
1328     if (QApplicationPrivate::testAttribute(Qt::AA_NativeWindows))
1329         setAttribute(Qt::WA_NativeWindow);
1330 
1331 #ifdef ALIEN_DEBUG
1332     qDebug() << "QWidget::create:" << this << "parent:" << parentWidget()
1333              << "Alien?" << !testAttribute(Qt::WA_NativeWindow);
1334 #endif
1335 
1336 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ && !defined(QT_NO_DRAGANDDROP)
1337     // Unregister the dropsite (if already registered) before we
1338     // re-create the widget with a native window.
1339     if (testAttribute(Qt::WA_WState_Created) && !internalWinId() && testAttribute(Qt::WA_NativeWindow)
1340             && d->extra && d->extra->dropTarget) {
1341         d->registerDropSite(false);
1342     }
1343 #endif
1344 
1345     d->updateIsOpaque();
1346 
1347     setAttribute(Qt::WA_WState_Created);                        // set created flag
1348     d->create_sys(window, initializeWindow, destroyOldWindow);
1349 
1350     // a real toplevel window needs a backing store
1351     if (isWindow() && windowType() != Qt::Desktop) {
1352         d->topData()->backingStoreTracker.destroy();
1353         if (hasBackingStoreSupport())
1354             d->topData()->backingStoreTracker.create(this);
1355     }
1356 
1357     d->setModal_sys();
1358 
1359     if (!isWindow() && parentWidget() && parentWidget()->testAttribute(Qt::WA_DropSiteRegistered))
1360         setAttribute(Qt::WA_DropSiteRegistered, true);
1361 
1362 #ifdef QT_EVAL
1363     extern void qt_eval_init_widget(QWidget *w);
1364     qt_eval_init_widget(this);
1365 #endif
1366 
1367     // need to force the resting of the icon after changing parents
1368     if (testAttribute(Qt::WA_SetWindowIcon))
1369         d->setWindowIcon_sys();
1370 
1371     if (isWindow() && !d->topData()->iconText.isEmpty())
1372         d->setWindowIconText_helper(d->topData()->iconText);
1373     if (isWindow() && !d->topData()->caption.isEmpty())
1374         d->setWindowTitle_helper(d->topData()->caption);
1375     if (windowType() != Qt::Desktop) {
1376         d->updateSystemBackground();
1377 
1378         if (isWindow() && !testAttribute(Qt::WA_SetWindowIcon))
1379             d->setWindowIcon_sys();
1380     }
1381 
1382     // Frame strut update needed in cases where there are native widgets such as QGLWidget,
1383     // as those force native window creation on their ancestors before they are shown.
1384     // If the strut is not updated, any subsequent move of the top level window before show
1385     // will cause window frame to be ignored when positioning the window.
1386     // Note that this only helps on platforms that handle window creation synchronously.
1387     d->updateFrameStrut();
1388 }
1389 
1390 void q_createNativeChildrenAndSetParent(const QWidget *parentWidget)
1391 {
1392     QObjectList children = parentWidget->children();
1393     for (int i = 0; i < children.size(); i++) {
1394         if (children.at(i)->isWidgetType()) {
1395             const QWidget *childWidget = qobject_cast<const QWidget *>(children.at(i));
1396             if (childWidget) { // should not be necessary
1397                 if (childWidget->testAttribute(Qt::WA_NativeWindow)) {
1398                     if (!childWidget->internalWinId())
1399                         childWidget->winId();
1400                     if (childWidget->windowHandle()) {
1401                         if (childWidget->isWindow()) {
1402                             childWidget->windowHandle()->setTransientParent(parentWidget->window()->windowHandle());
1403                         } else {
1404                             childWidget->windowHandle()->setParent(childWidget->nativeParentWidget()->windowHandle());
1405                         }
1406                     }
1407                 } else {
1408                     q_createNativeChildrenAndSetParent(childWidget);
1409                 }
1410             }
1411         }
1412     }
1413 
1414 }
1415 
1416 void QWidgetPrivate::create_sys(WId window, bool initializeWindow, bool destroyOldWindow)
1417 {
1418     Q_Q(QWidget);
1419 
1420     Q_UNUSED(window);
1421     Q_UNUSED(initializeWindow);
1422     Q_UNUSED(destroyOldWindow);
1423 
1424     Qt::WindowFlags flags = data.window_flags;
1425 
1426     if (!q->testAttribute(Qt::WA_NativeWindow) && !q->isWindow())
1427         return; // we only care about real toplevels
1428 
1429     QWidgetWindow *win = topData()->window;
1430     // topData() ensures the extra is created but does not ensure 'window' is non-null
1431     // in case the extra was already valid.
1432     if (!win) {
1433         createTLSysExtra();
1434         win = topData()->window;
1435     }
1436 
1437     const auto dynamicPropertyNames = q->dynamicPropertyNames();
1438     for (const QByteArray &propertyName : dynamicPropertyNames) {
1439         if (!qstrncmp(propertyName, "_q_platform_", 12))
1440             win->setProperty(propertyName, q->property(propertyName));
1441     }
1442 
1443     if (q->testAttribute(Qt::WA_ShowWithoutActivating))
1444         win->setProperty("_q_showWithoutActivating", QVariant(true));
1445     if (q->testAttribute(Qt::WA_MacAlwaysShowToolWindow))
1446         win->setProperty("_q_macAlwaysShowToolWindow", QVariant(true));
1447     setNetWmWindowTypes(true); // do nothing if none of WA_X11NetWmWindowType* is set
1448     win->setFlags(data.window_flags);
1449     fixPosIncludesFrame();
1450     if (q->testAttribute(Qt::WA_Moved)
1451         || !QGuiApplicationPrivate::platformIntegration()->hasCapability(QPlatformIntegration::WindowManagement))
1452         win->setGeometry(q->geometry());
1453     else
1454         win->resize(q->size());
1455     if (win->isTopLevel()) {
1456         int screenNumber = topData()->initialScreenIndex;
1457         topData()->initialScreenIndex = -1;
1458         if (screenNumber < 0) {
1459             screenNumber = q->windowType() != Qt::Desktop
1460                 ? QDesktopWidgetPrivate::screenNumber(q) : 0;
1461         }
1462         win->setScreen(QGuiApplication::screens().value(screenNumber, nullptr));
1463     }
1464 
1465     QSurfaceFormat format = win->requestedFormat();
1466     if ((flags & Qt::Window) && win->surfaceType() != QSurface::OpenGLSurface
1467             && q->testAttribute(Qt::WA_TranslucentBackground)) {
1468         format.setAlphaBufferSize(8);
1469     }
1470     win->setFormat(format);
1471 
1472     if (QWidget *nativeParent = q->nativeParentWidget()) {
1473         if (nativeParent->windowHandle()) {
1474             if (flags & Qt::Window) {
1475                 win->setTransientParent(nativeParent->window()->windowHandle());
1476                 win->setParent(0);
1477             } else {
1478                 win->setTransientParent(0);
1479                 win->setParent(nativeParent->windowHandle());
1480             }
1481         }
1482     }
1483 
1484     qt_window_private(win)->positionPolicy = topData()->posIncludesFrame ?
1485         QWindowPrivate::WindowFrameInclusive : QWindowPrivate::WindowFrameExclusive;
1486 
1487     if (q->windowType() != Qt::Desktop || q->testAttribute(Qt::WA_NativeWindow)) {
1488         win->create();
1489         // Enable nonclient-area events for QDockWidget and other NonClientArea-mouse event processing.
1490         win->handle()->setFrameStrutEventsEnabled(true);
1491     }
1492 
1493     data.window_flags = win->flags();
1494     if (!win->isTopLevel()) // In a Widget world foreign windows can only be top level
1495       data.window_flags &= ~Qt::ForeignWindow;
1496 
1497     if (!topData()->role.isNull())
1498         QXcbWindowFunctions::setWmWindowRole(win, topData()->role.toLatin1());
1499 
1500     QBackingStore *store = q->backingStore();
1501 
1502     if (!store) {
1503         if (q->windowType() != Qt::Desktop) {
1504             if (q->isTopLevel())
1505                 q->setBackingStore(new QBackingStore(win));
1506         } else {
1507             q->setAttribute(Qt::WA_PaintOnScreen, true);
1508         }
1509     }
1510 
1511     setWindowModified_helper();
1512 
1513     if (win->handle()) {
1514         WId id = win->winId();
1515         // See the QPlatformWindow::winId() documentation
1516         Q_ASSERT(id != WId(0));
1517         setWinId(id);
1518     }
1519 
1520     // Check children and create windows for them if necessary
1521     q_createNativeChildrenAndSetParent(q);
1522 
1523     if (extra && !extra->mask.isEmpty())
1524         setMask_sys(extra->mask);
1525 
1526     if (data.crect.width() == 0 || data.crect.height() == 0) {
1527         q->setAttribute(Qt::WA_OutsideWSRange, true);
1528     } else if (q->isVisible()) {
1529         // If widget is already shown, set window visible, too
1530         win->setNativeWindowVisibility(true);
1531     }
1532 }
1533 
1534 #ifdef Q_OS_WIN
1535 static const char activeXNativeParentHandleProperty[] = "_q_embedded_native_parent_handle";
1536 #endif
1537 
1538 void QWidgetPrivate::createTLSysExtra()
1539 {
1540     Q_Q(QWidget);
1541     if (!extra->topextra->window && (q->testAttribute(Qt::WA_NativeWindow) || q->isWindow())) {
1542         extra->topextra->window = new QWidgetWindow(q);
1543         if (extra->minw || extra->minh)
1544             extra->topextra->window->setMinimumSize(QSize(extra->minw, extra->minh));
1545         if (extra->maxw != QWIDGETSIZE_MAX || extra->maxh != QWIDGETSIZE_MAX)
1546             extra->topextra->window->setMaximumSize(QSize(extra->maxw, extra->maxh));
1547         if (extra->topextra->opacity != 255 && q->isWindow())
1548             extra->topextra->window->setOpacity(qreal(extra->topextra->opacity) / qreal(255));
1549 #ifdef Q_OS_WIN
1550         // Pass on native parent handle for Widget embedded into Active X.
1551         const QVariant activeXNativeParentHandle = q->property(activeXNativeParentHandleProperty);
1552         if (activeXNativeParentHandle.isValid())
1553             extra->topextra->window->setProperty(activeXNativeParentHandleProperty, activeXNativeParentHandle);
1554         if (q->inherits("QTipLabel") || q->inherits("QAlphaWidget"))
1555             extra->topextra->window->setProperty("_q_windowsDropShadow", QVariant(true));
1556 #endif
1557     }
1558 
1559 }
1560 
1561 /*!
1562     Destroys the widget.
1563 
1564     All this widget's children are deleted first. The application
1565     exits if this widget is the main widget.
1566 */
1567 
1568 QWidget::~QWidget()
1569 {
1570     Q_D(QWidget);
1571     d->data.in_destructor = true;
1572 
1573 #if defined (QT_CHECK_STATE)
1574     if (Q_UNLIKELY(paintingActive()))
1575         qWarning("QWidget: %s (%s) deleted while being painted", className(), name());
1576 #endif
1577 
1578 #ifndef QT_NO_GESTURES
1579     if (QGestureManager *manager = QGestureManager::instance()) {
1580         // \forall Qt::GestureType type : ungrabGesture(type) (inlined)
1581         for (auto it = d->gestureContext.keyBegin(), end = d->gestureContext.keyEnd(); it != end; ++it)
1582             manager->cleanupCachedGestures(this, *it);
1583     }
1584     d->gestureContext.clear();
1585 #endif
1586 
1587     // force acceptDrops false before winId is destroyed.
1588     d->registerDropSite(false);
1589 
1590 #ifndef QT_NO_ACTION
1591     // remove all actions from this widget
1592     for (int i = 0; i < d->actions.size(); ++i) {
1593         QActionPrivate *apriv = d->actions.at(i)->d_func();
1594         apriv->widgets.removeAll(this);
1595     }
1596     d->actions.clear();
1597 #endif
1598 
1599 #ifndef QT_NO_SHORTCUT
1600     // Remove all shortcuts grabbed by this
1601     // widget, unless application is closing
1602     if (!QApplicationPrivate::is_app_closing && testAttribute(Qt::WA_GrabbedShortcut))
1603         qApp->d_func()->shortcutMap.removeShortcut(0, this, QKeySequence());
1604 #endif
1605 
1606     // delete layout while we still are a valid widget
1607     delete d->layout;
1608     d->layout = 0;
1609     // Remove myself from focus list
1610 
1611     Q_ASSERT(d->focus_next->d_func()->focus_prev == this);
1612     Q_ASSERT(d->focus_prev->d_func()->focus_next == this);
1613 
1614     if (d->focus_next != this) {
1615         d->focus_next->d_func()->focus_prev = d->focus_prev;
1616         d->focus_prev->d_func()->focus_next = d->focus_next;
1617         d->focus_next = d->focus_prev = 0;
1618     }
1619 
1620 
1621     QT_TRY {
1622 #if QT_CONFIG(graphicsview)
1623         const QWidget* w = this;
1624         while (w->d_func()->extra && w->d_func()->extra->focus_proxy)
1625             w = w->d_func()->extra->focus_proxy;
1626         QWidget *window = w->window();
1627         QWExtra *e = window ? window->d_func()->extra : 0;
1628         if (!e || !e->proxyWidget || (w->parentWidget() && w->parentWidget()->d_func()->focus_child == this))
1629 #endif
1630         clearFocus();
1631     } QT_CATCH(...) {
1632         // swallow this problem because we are in a destructor
1633     }
1634 
1635     d->setDirtyOpaqueRegion();
1636 
1637     if (isWindow() && isVisible() && internalWinId()) {
1638         QT_TRY {
1639             d->close_helper(QWidgetPrivate::CloseNoEvent);
1640         } QT_CATCH(...) {
1641             // if we're out of memory, at least hide the window.
1642             QT_TRY {
1643                 hide();
1644             } QT_CATCH(...) {
1645                 // and if that also doesn't work, then give up
1646             }
1647         }
1648     }
1649 
1650 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_X11 */|| 0 /* Used to be included in Qt4 for Q_WS_MAC */
1651     else if (!internalWinId() && isVisible()) {
1652         qApp->d_func()->sendSyntheticEnterLeave(this);
1653     }
1654 #endif
1655     else if (isVisible()) {
1656         qApp->d_func()->sendSyntheticEnterLeave(this);
1657     }
1658 
1659     if (QWidgetBackingStore *bs = d->maybeBackingStore()) {
1660         bs->removeDirtyWidget(this);
1661         if (testAttribute(Qt::WA_StaticContents))
1662             bs->removeStaticWidget(this);
1663     }
1664 
1665     delete d->needsFlush;
1666     d->needsFlush = 0;
1667 
1668     // The next 20 lines are duplicated from QObject, but required here
1669     // since QWidget deletes is children itself
1670     bool blocked = d->blockSig;
1671     d->blockSig = 0; // unblock signals so we always emit destroyed()
1672 
1673     if (d->isSignalConnected(0)) {
1674         QT_TRY {
1675             emit destroyed(this);
1676         } QT_CATCH(...) {
1677             // all the signal/slots connections are still in place - if we don't
1678             // quit now, we will crash pretty soon.
1679             qWarning("Detected an unexpected exception in ~QWidget while emitting destroyed().");
1680             QT_RETHROW;
1681         }
1682     }
1683 
1684     if (d->declarativeData) {
1685         if (static_cast<QAbstractDeclarativeDataImpl*>(d->declarativeData)->ownedByQml1) {
1686             if (QAbstractDeclarativeData::destroyed_qml1)
1687                 QAbstractDeclarativeData::destroyed_qml1(d->declarativeData, this);
1688         } else {
1689             if (QAbstractDeclarativeData::destroyed)
1690                 QAbstractDeclarativeData::destroyed(d->declarativeData, this);
1691         }
1692         d->declarativeData = 0;                 // don't activate again in ~QObject
1693     }
1694 
1695     d->blockSig = blocked;
1696 
1697 #if 0 // Used to be included in Qt4 for Q_WS_MAC
1698     // QCocoaView holds a pointer back to this widget. Clear it now
1699     // to make sure it's not followed later on. The lifetime of the
1700     // QCocoaView might exceed the lifetime of this widget in cases
1701     // where Cocoa itself holds references to it.
1702     extern void qt_mac_clearCocoaViewQWidgetPointers(QWidget *);
1703     qt_mac_clearCocoaViewQWidgetPointers(this);
1704 #endif
1705 
1706     if (!d->children.isEmpty())
1707         d->deleteChildren();
1708 
1709     QApplication::removePostedEvents(this);
1710 
1711     QT_TRY {
1712         destroy();                                        // platform-dependent cleanup
1713     } QT_CATCH(...) {
1714         // if this fails we can't do anything about it but at least we are not allowed to throw.
1715     }
1716     --QWidgetPrivate::instanceCounter;
1717 
1718     if (QWidgetPrivate::allWidgets) // might have been deleted by ~QApplication
1719         QWidgetPrivate::allWidgets->remove(this);
1720 
1721     QT_TRY {
1722         QEvent e(QEvent::Destroy);
1723         QCoreApplication::sendEvent(this, &e);
1724     } QT_CATCH(const std::exception&) {
1725         // if this fails we can't do anything about it but at least we are not allowed to throw.
1726     }
1727 
1728 #if QT_CONFIG(graphicseffect)
1729     delete d->graphicsEffect;
1730 #endif
1731 }
1732 
1733 int QWidgetPrivate::instanceCounter = 0;  // Current number of widget instances
1734 int QWidgetPrivate::maxInstances = 0;     // Maximum number of widget instances
1735 
1736 void QWidgetPrivate::setWinId(WId id)                // set widget identifier
1737 {
1738     Q_Q(QWidget);
1739     // the user might create a widget with Qt::Desktop window
1740     // attribute (or create another QDesktopWidget instance), which
1741     // will have the same windowid (the root window id) as the
1742     // qt_desktopWidget. We should not add the second desktop widget
1743     // to the mapper.
1744     bool userDesktopWidget = qt_desktopWidget != 0 && qt_desktopWidget != q && q->windowType() == Qt::Desktop;
1745     if (mapper && data.winid && !userDesktopWidget) {
1746         mapper->remove(data.winid);
1747     }
1748 
1749     const WId oldWinId = data.winid;
1750 
1751     data.winid = id;
1752 #if 0 // Used to be included in Qt4 for Q_WS_X11
1753     hd = id; // X11: hd == ident
1754 #endif
1755     if (mapper && id && !userDesktopWidget) {
1756         mapper->insert(data.winid, q);
1757     }
1758 
1759     if(oldWinId != id) {
1760         QEvent e(QEvent::WinIdChange);
1761         QCoreApplication::sendEvent(q, &e);
1762     }
1763 }
1764 
1765 void QWidgetPrivate::createTLExtra()
1766 {
1767     if (!extra)
1768         createExtra();
1769     if (!extra->topextra) {
1770         QTLWExtra* x = extra->topextra = new QTLWExtra;
1771         x->icon = 0;
1772         x->backingStore = 0;
1773         x->sharedPainter = 0;
1774         x->incw = x->inch = 0;
1775         x->basew = x->baseh = 0;
1776         x->frameStrut.setCoords(0, 0, 0, 0);
1777         x->normalGeometry = QRect(0,0,-1,-1);
1778         x->savedFlags = 0;
1779         x->opacity = 255;
1780         x->posIncludesFrame = 0;
1781         x->sizeAdjusted = false;
1782         x->inTopLevelResize = false;
1783         x->inRepaint = false;
1784         x->embedded = 0;
1785         x->window = 0;
1786         x->shareContext = 0;
1787         x->initialScreenIndex = -1;
1788 #if 0 // Used to be included in Qt4 for Q_WS_MAC
1789         x->wasMaximized = false;
1790 #endif
1791 #ifdef QWIDGET_EXTRA_DEBUG
1792         static int count = 0;
1793         qDebug() << "tlextra" << ++count;
1794 #endif
1795     }
1796 }
1797 
1798 /*!
1799   \internal
1800   Creates the widget extra data.
1801 */
1802 
1803 void QWidgetPrivate::createExtra()
1804 {
1805     if (!extra) {                                // if not exists
1806         extra = new QWExtra;
1807         extra->glContext = 0;
1808         extra->topextra = 0;
1809 #if QT_CONFIG(graphicsview)
1810         extra->proxyWidget = 0;
1811 #endif
1812 #ifndef QT_NO_CURSOR
1813         extra->curs = 0;
1814 #endif
1815         extra->minw = 0;
1816         extra->minh = 0;
1817         extra->maxw = QWIDGETSIZE_MAX;
1818         extra->maxh = QWIDGETSIZE_MAX;
1819         extra->customDpiX = 0;
1820         extra->customDpiY = 0;
1821         extra->explicitMinSize = 0;
1822         extra->explicitMaxSize = 0;
1823         extra->autoFillBackground = 0;
1824         extra->nativeChildrenForced = 0;
1825         extra->inRenderWithPainter = 0;
1826         extra->hasWindowContainer = false;
1827         extra->hasMask = 0;
1828         createSysExtra();
1829 #ifdef QWIDGET_EXTRA_DEBUG
1830         static int count = 0;
1831         qDebug() << "extra" << ++count;
1832 #endif
1833     }
1834 }
1835 
1836 void QWidgetPrivate::createSysExtra()
1837 {
1838 }
1839 
1840 /*!
1841   \internal
1842   Deletes the widget extra data.
1843 */
1844 
1845 void QWidgetPrivate::deleteExtra()
1846 {
1847     if (extra) {                                // if exists
1848 #ifndef QT_NO_CURSOR
1849         delete extra->curs;
1850 #endif
1851         deleteSysExtra();
1852 #ifndef QT_NO_STYLE_STYLESHEET
1853         // dereference the stylesheet style
1854         if (QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(extra->style))
1855             proxy->deref();
1856 #endif
1857         if (extra->topextra) {
1858             deleteTLSysExtra();
1859             // extra->topextra->backingStore destroyed in QWidgetPrivate::deleteTLSysExtra()
1860             delete extra->topextra->icon;
1861             delete extra->topextra;
1862         }
1863         delete extra;
1864         // extra->xic destroyed in QWidget::destroy()
1865         extra = 0;
1866     }
1867 }
1868 
1869 void QWidgetPrivate::deleteSysExtra()
1870 {
1871 }
1872 
1873 static void deleteBackingStore(QWidgetPrivate *d)
1874 {
1875     QTLWExtra *topData = d->topData();
1876 
1877     // The context must be current when destroying the backing store as it may attempt to
1878     // release resources like textures and shader programs. The window may not be suitable
1879     // anymore as there will often not be a platform window underneath at this stage. Fall
1880     // back to a QOffscreenSurface in this case.
1881     QScopedPointer<QOffscreenSurface> tempSurface;
1882 #ifndef QT_NO_OPENGL
1883     if (d->textureChildSeen && topData->shareContext) {
1884         if (topData->window->handle()) {
1885             topData->shareContext->makeCurrent(topData->window);
1886         } else {
1887             tempSurface.reset(new QOffscreenSurface);
1888             tempSurface->setFormat(topData->shareContext->format());
1889             tempSurface->create();
1890             topData->shareContext->makeCurrent(tempSurface.data());
1891         }
1892     }
1893 #endif
1894 
1895     delete topData->backingStore;
1896     topData->backingStore = 0;
1897 
1898 #ifndef QT_NO_OPENGL
1899     if (d->textureChildSeen && topData->shareContext)
1900         topData->shareContext->doneCurrent();
1901 #endif
1902 }
1903 
1904 void QWidgetPrivate::deleteTLSysExtra()
1905 {
1906     if (extra && extra->topextra) {
1907         //the qplatformbackingstore may hold a reference to the window, so the backingstore
1908         //needs to be deleted first. If the backingstore holds GL resources, we need to
1909         // make the context current here. This is taken care of by deleteBackingStore().
1910 
1911         extra->topextra->backingStoreTracker.destroy();
1912         deleteBackingStore(this);
1913 #ifndef QT_NO_OPENGL
1914         qDeleteAll(extra->topextra->widgetTextures);
1915         extra->topextra->widgetTextures.clear();
1916         delete extra->topextra->shareContext;
1917         extra->topextra->shareContext = 0;
1918 #endif
1919 
1920         //the toplevel might have a context with a "qglcontext associated with it. We need to
1921         //delete the qglcontext before we delete the qplatformopenglcontext.
1922         //One unfortunate thing about this is that we potentially create a glContext just to
1923         //delete it straight afterwards.
1924         if (extra->topextra->window) {
1925             extra->topextra->window->destroy();
1926         }
1927         delete extra->topextra->window;
1928         extra->topextra->window = 0;
1929 
1930     }
1931 }
1932 
1933 /*
1934   Returns \c true if there are widgets above this which overlap with
1935   \a rect, which is in parent's coordinate system (same as crect).
1936 */
1937 
1938 bool QWidgetPrivate::isOverlapped(const QRect &rect) const
1939 {
1940     Q_Q(const QWidget);
1941 
1942     const QWidget *w = q;
1943     QRect r = rect;
1944     while (w) {
1945         if (w->isWindow())
1946             return false;
1947         QWidgetPrivate *pd = w->parentWidget()->d_func();
1948         bool above = false;
1949         for (int i = 0; i < pd->children.size(); ++i) {
1950             QWidget *sibling = qobject_cast<QWidget *>(pd->children.at(i));
1951             if (!sibling || !sibling->isVisible() || sibling->isWindow())
1952                 continue;
1953             if (!above) {
1954                 above = (sibling == w);
1955                 continue;
1956             }
1957 
1958             if (qRectIntersects(sibling->d_func()->effectiveRectFor(sibling->data->crect), r)) {
1959                 const QWExtra *siblingExtra = sibling->d_func()->extra;
1960                 if (siblingExtra && siblingExtra->hasMask && !sibling->d_func()->graphicsEffect
1961                     && !siblingExtra->mask.translated(sibling->data->crect.topLeft()).intersects(r)) {
1962                     continue;
1963                 }
1964                 return true;
1965             }
1966         }
1967         w = w->parentWidget();
1968         r.translate(pd->data.crect.topLeft());
1969     }
1970     return false;
1971 }
1972 
1973 void QWidgetPrivate::syncBackingStore()
1974 {
1975     if (paintOnScreen()) {
1976         repaint_sys(dirty);
1977         dirty = QRegion();
1978     } else if (QWidgetBackingStore *bs = maybeBackingStore()) {
1979         bs->sync();
1980     }
1981 }
1982 
1983 void QWidgetPrivate::syncBackingStore(const QRegion &region)
1984 {
1985     if (paintOnScreen())
1986         repaint_sys(region);
1987     else if (QWidgetBackingStore *bs = maybeBackingStore()) {
1988         bs->sync(q_func(), region);
1989     }
1990 }
1991 
1992 void QWidgetPrivate::setUpdatesEnabled_helper(bool enable)
1993 {
1994     Q_Q(QWidget);
1995 
1996     if (enable && !q->isWindow() && q->parentWidget() && !q->parentWidget()->updatesEnabled())
1997         return; // nothing we can do
1998 
1999     if (enable != q->testAttribute(Qt::WA_UpdatesDisabled))
2000         return; // nothing to do
2001 
2002     q->setAttribute(Qt::WA_UpdatesDisabled, !enable);
2003     if (enable)
2004         q->update();
2005 
2006     Qt::WidgetAttribute attribute = enable ? Qt::WA_ForceUpdatesDisabled : Qt::WA_UpdatesDisabled;
2007     for (int i = 0; i < children.size(); ++i) {
2008         QWidget *w = qobject_cast<QWidget *>(children.at(i));
2009         if (w && !w->isWindow() && !w->testAttribute(attribute))
2010             w->d_func()->setUpdatesEnabled_helper(enable);
2011     }
2012 }
2013 
2014 /*!
2015     \internal
2016 
2017     Propagate this widget's palette to all children, except style sheet
2018     widgets, and windows that don't enable window propagation (palettes don't
2019     normally propagate to windows).
2020 */
2021 void QWidgetPrivate::propagatePaletteChange()
2022 {
2023     Q_Q(QWidget);
2024     // Propagate a new inherited mask to all children.
2025 #if QT_CONFIG(graphicsview)
2026     if (!q->parentWidget() && extra && extra->proxyWidget) {
2027         QGraphicsProxyWidget *p = extra->proxyWidget;
2028         inheritedPaletteResolveMask = p->d_func()->inheritedPaletteResolveMask | p->palette().resolve();
2029     } else
2030 #endif // QT_CONFIG(graphicsview)
2031         if (q->isWindow() && !q->testAttribute(Qt::WA_WindowPropagation)) {
2032         inheritedPaletteResolveMask = 0;
2033     }
2034     int mask = data.pal.resolve() | inheritedPaletteResolveMask;
2035 
2036     const bool useStyleSheetPropagationInWidgetStyles =
2037         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
2038 
2039     QEvent pc(QEvent::PaletteChange);
2040     QApplication::sendEvent(q, &pc);
2041     for (int i = 0; i < children.size(); ++i) {
2042         QWidget *w = qobject_cast<QWidget*>(children.at(i));
2043         if (w && (!w->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles)
2044             && (!w->isWindow() || w->testAttribute(Qt::WA_WindowPropagation))) {
2045             QWidgetPrivate *wd = w->d_func();
2046             wd->inheritedPaletteResolveMask = mask;
2047             wd->resolvePalette();
2048         }
2049     }
2050 }
2051 
2052 /*
2053   Returns the widget's clipping rectangle.
2054 */
2055 QRect QWidgetPrivate::clipRect() const
2056 {
2057     Q_Q(const QWidget);
2058     const QWidget * w = q;
2059     if (!w->isVisible())
2060         return QRect();
2061     QRect r = effectiveRectFor(q->rect());
2062     int ox = 0;
2063     int oy = 0;
2064     while (w
2065             && w->isVisible()
2066             && !w->isWindow()
2067             && w->parentWidget()) {
2068         ox -= w->x();
2069         oy -= w->y();
2070         w = w->parentWidget();
2071         r &= QRect(ox, oy, w->width(), w->height());
2072     }
2073     return r;
2074 }
2075 
2076 /*
2077   Returns the widget's clipping region (without siblings).
2078 */
2079 QRegion QWidgetPrivate::clipRegion() const
2080 {
2081     Q_Q(const QWidget);
2082     if (!q->isVisible())
2083         return QRegion();
2084     QRegion r(q->rect());
2085     const QWidget * w = q;
2086     const QWidget *ignoreUpTo;
2087     int ox = 0;
2088     int oy = 0;
2089     while (w
2090            && w->isVisible()
2091            && !w->isWindow()
2092            && w->parentWidget()) {
2093         ox -= w->x();
2094         oy -= w->y();
2095         ignoreUpTo = w;
2096         w = w->parentWidget();
2097         r &= QRegion(ox, oy, w->width(), w->height());
2098 
2099         int i = 0;
2100         while(w->d_func()->children.at(i++) != static_cast<const QObject *>(ignoreUpTo))
2101             ;
2102         for ( ; i < w->d_func()->children.size(); ++i) {
2103             if(QWidget *sibling = qobject_cast<QWidget *>(w->d_func()->children.at(i))) {
2104                 if(sibling->isVisible() && !sibling->isWindow()) {
2105                     QRect siblingRect(ox+sibling->x(), oy+sibling->y(),
2106                                       sibling->width(), sibling->height());
2107                     if (qRectIntersects(siblingRect, q->rect()))
2108                         r -= QRegion(siblingRect);
2109                 }
2110             }
2111         }
2112     }
2113     return r;
2114 }
2115 
2116 void QWidgetPrivate::setSystemClip(QPaintEngine *paintEngine, qreal devicePixelRatio, const QRegion &region)
2117 {
2118 // Transform the system clip region from device-independent pixels to device pixels
2119     QTransform scaleTransform;
2120     scaleTransform.scale(devicePixelRatio, devicePixelRatio);
2121 
2122     paintEngine->d_func()->baseSystemClip = region;
2123     paintEngine->d_func()->setSystemTransform(scaleTransform);
2124 
2125 }
2126 
2127 #if QT_CONFIG(graphicseffect)
2128 void QWidgetPrivate::invalidateGraphicsEffectsRecursively()
2129 {
2130     Q_Q(QWidget);
2131     QWidget *w = q;
2132     do {
2133         if (w->graphicsEffect()) {
2134             QWidgetEffectSourcePrivate *sourced =
2135                 static_cast<QWidgetEffectSourcePrivate *>(w->graphicsEffect()->source()->d_func());
2136             if (!sourced->updateDueToGraphicsEffect)
2137                 w->graphicsEffect()->source()->d_func()->invalidateCache();
2138         }
2139         w = w->parentWidget();
2140     } while (w);
2141 }
2142 #endif // QT_CONFIG(graphicseffect)
2143 
2144 void QWidgetPrivate::setDirtyOpaqueRegion()
2145 {
2146     Q_Q(QWidget);
2147 
2148     dirtyOpaqueChildren = true;
2149 
2150 #if QT_CONFIG(graphicseffect)
2151     invalidateGraphicsEffectsRecursively();
2152 #endif // QT_CONFIG(graphicseffect)
2153 
2154     if (q->isWindow())
2155         return;
2156 
2157     QWidget *parent = q->parentWidget();
2158     if (!parent)
2159         return;
2160 
2161     // TODO: instead of setting dirtyflag, manipulate the dirtyregion directly?
2162     QWidgetPrivate *pd = parent->d_func();
2163     if (!pd->dirtyOpaqueChildren)
2164         pd->setDirtyOpaqueRegion();
2165 }
2166 
2167 const QRegion &QWidgetPrivate::getOpaqueChildren() const
2168 {
2169     if (!dirtyOpaqueChildren)
2170         return opaqueChildren;
2171 
2172     QWidgetPrivate *that = const_cast<QWidgetPrivate*>(this);
2173     that->opaqueChildren = QRegion();
2174 
2175     for (int i = 0; i < children.size(); ++i) {
2176         QWidget *child = qobject_cast<QWidget *>(children.at(i));
2177         if (!child || !child->isVisible() || child->isWindow())
2178             continue;
2179 
2180         const QPoint offset = child->geometry().topLeft();
2181         QWidgetPrivate *childd = child->d_func();
2182         QRegion r = childd->isOpaque ? child->rect() : childd->getOpaqueChildren();
2183         if (childd->extra && childd->extra->hasMask)
2184             r &= childd->extra->mask;
2185         if (r.isEmpty())
2186             continue;
2187         r.translate(offset);
2188         that->opaqueChildren += r;
2189     }
2190 
2191     that->opaqueChildren &= q_func()->rect();
2192     that->dirtyOpaqueChildren = false;
2193 
2194     return that->opaqueChildren;
2195 }
2196 
2197 void QWidgetPrivate::subtractOpaqueChildren(QRegion &source, const QRect &clipRect) const
2198 {
2199     if (children.isEmpty() || clipRect.isEmpty())
2200         return;
2201 
2202     const QRegion &r = getOpaqueChildren();
2203     if (!r.isEmpty())
2204         source -= (r & clipRect);
2205 }
2206 
2207 //subtract any relatives that are higher up than me --- this is too expensive !!!
2208 void QWidgetPrivate::subtractOpaqueSiblings(QRegion &sourceRegion, bool *hasDirtySiblingsAbove,
2209                                             bool alsoNonOpaque) const
2210 {
2211     Q_Q(const QWidget);
2212     static int disableSubtractOpaqueSiblings = qEnvironmentVariableIntValue("QT_NO_SUBTRACTOPAQUESIBLINGS");
2213     if (disableSubtractOpaqueSiblings || q->isWindow())
2214         return;
2215 
2216 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2217     if (q->d_func()->isInUnifiedToolbar)
2218         return;
2219 #endif
2220 
2221     QRect clipBoundingRect;
2222     bool dirtyClipBoundingRect = true;
2223 
2224     QRegion parentClip;
2225     bool dirtyParentClip = true;
2226 
2227     QPoint parentOffset = data.crect.topLeft();
2228 
2229     const QWidget *w = q;
2230 
2231     while (w) {
2232         if (w->isWindow())
2233             break;
2234         QWidgetPrivate *pd = w->parentWidget()->d_func();
2235         const int myIndex = pd->children.indexOf(const_cast<QWidget *>(w));
2236         const QRect widgetGeometry = w->d_func()->effectiveRectFor(w->data->crect);
2237         for (int i = myIndex + 1; i < pd->children.size(); ++i) {
2238             QWidget *sibling = qobject_cast<QWidget *>(pd->children.at(i));
2239             if (!sibling || !sibling->isVisible() || sibling->isWindow())
2240                 continue;
2241 
2242             const QRect siblingGeometry = sibling->d_func()->effectiveRectFor(sibling->data->crect);
2243             if (!qRectIntersects(siblingGeometry, widgetGeometry))
2244                 continue;
2245 
2246             if (dirtyClipBoundingRect) {
2247                 clipBoundingRect = sourceRegion.boundingRect();
2248                 dirtyClipBoundingRect = false;
2249             }
2250 
2251             if (!qRectIntersects(siblingGeometry, clipBoundingRect.translated(parentOffset)))
2252                 continue;
2253 
2254             if (dirtyParentClip) {
2255                 parentClip = sourceRegion.translated(parentOffset);
2256                 dirtyParentClip = false;
2257             }
2258 
2259             const QPoint siblingPos(sibling->data->crect.topLeft());
2260             const QRect siblingClipRect(sibling->d_func()->clipRect());
2261             QRegion siblingDirty(parentClip);
2262             siblingDirty &= (siblingClipRect.translated(siblingPos));
2263             const bool hasMask = sibling->d_func()->extra && sibling->d_func()->extra->hasMask
2264                                  && !sibling->d_func()->graphicsEffect;
2265             if (hasMask)
2266                 siblingDirty &= sibling->d_func()->extra->mask.translated(siblingPos);
2267             if (siblingDirty.isEmpty())
2268                 continue;
2269 
2270             if (sibling->d_func()->isOpaque || alsoNonOpaque) {
2271                 if (hasMask) {
2272                     siblingDirty.translate(-parentOffset);
2273                     sourceRegion -= siblingDirty;
2274                 } else {
2275                     sourceRegion -= siblingGeometry.translated(-parentOffset);
2276                 }
2277             } else {
2278                 if (hasDirtySiblingsAbove)
2279                     *hasDirtySiblingsAbove = true;
2280                 if (sibling->d_func()->children.isEmpty())
2281                     continue;
2282                 QRegion opaqueSiblingChildren(sibling->d_func()->getOpaqueChildren());
2283                 opaqueSiblingChildren.translate(-parentOffset + siblingPos);
2284                 sourceRegion -= opaqueSiblingChildren;
2285             }
2286             if (sourceRegion.isEmpty())
2287                 return;
2288 
2289             dirtyClipBoundingRect = true;
2290             dirtyParentClip = true;
2291         }
2292 
2293         w = w->parentWidget();
2294         parentOffset += pd->data.crect.topLeft();
2295         dirtyParentClip = true;
2296     }
2297 }
2298 
2299 void QWidgetPrivate::clipToEffectiveMask(QRegion &region) const
2300 {
2301     Q_Q(const QWidget);
2302 
2303     const QWidget *w = q;
2304     QPoint offset;
2305 
2306 #if QT_CONFIG(graphicseffect)
2307     if (graphicsEffect) {
2308         w = q->parentWidget();
2309         offset -= data.crect.topLeft();
2310     }
2311 #endif // QT_CONFIG(graphicseffect)
2312 
2313     while (w) {
2314         const QWidgetPrivate *wd = w->d_func();
2315         if (wd->extra && wd->extra->hasMask)
2316             region &= (w != q) ? wd->extra->mask.translated(offset) : wd->extra->mask;
2317         if (w->isWindow())
2318             return;
2319         offset -= wd->data.crect.topLeft();
2320         w = w->parentWidget();
2321     }
2322 }
2323 
2324 bool QWidgetPrivate::paintOnScreen() const
2325 {
2326 #if defined(QT_NO_BACKINGSTORE)
2327     return true;
2328 #else
2329     Q_Q(const QWidget);
2330     if (q->testAttribute(Qt::WA_PaintOnScreen)
2331             || (!q->isWindow() && q->window()->testAttribute(Qt::WA_PaintOnScreen))) {
2332         return true;
2333     }
2334 
2335     return !qt_enable_backingstore;
2336 #endif
2337 }
2338 
2339 void QWidgetPrivate::updateIsOpaque()
2340 {
2341     // hw: todo: only needed if opacity actually changed
2342     setDirtyOpaqueRegion();
2343 
2344 #if QT_CONFIG(graphicseffect)
2345     if (graphicsEffect) {
2346         // ### We should probably add QGraphicsEffect::isOpaque at some point.
2347         setOpaque(false);
2348         return;
2349     }
2350 #endif // QT_CONFIG(graphicseffect)
2351 
2352     Q_Q(QWidget);
2353 #if 0 // Used to be included in Qt4 for Q_WS_X11
2354     if (q->testAttribute(Qt::WA_X11OpenGLOverlay)) {
2355         setOpaque(false);
2356         return;
2357     }
2358 #endif
2359 
2360     if (q->testAttribute(Qt::WA_OpaquePaintEvent) || q->testAttribute(Qt::WA_PaintOnScreen)) {
2361         setOpaque(true);
2362         return;
2363     }
2364 
2365     const QPalette &pal = q->palette();
2366 
2367     if (q->autoFillBackground()) {
2368         const QBrush &autoFillBrush = pal.brush(q->backgroundRole());
2369         if (autoFillBrush.style() != Qt::NoBrush && autoFillBrush.isOpaque()) {
2370             setOpaque(true);
2371             return;
2372         }
2373     }
2374 
2375     if (q->isWindow() && !q->testAttribute(Qt::WA_NoSystemBackground)) {
2376         const QBrush &windowBrush = q->palette().brush(QPalette::Window);
2377         if (windowBrush.style() != Qt::NoBrush && windowBrush.isOpaque()) {
2378             setOpaque(true);
2379             return;
2380         }
2381     }
2382     setOpaque(false);
2383 }
2384 
2385 void QWidgetPrivate::setOpaque(bool opaque)
2386 {
2387     if (isOpaque != opaque) {
2388         isOpaque = opaque;
2389         updateIsTranslucent();
2390     }
2391 }
2392 
2393 void QWidgetPrivate::updateIsTranslucent()
2394 {
2395     Q_Q(QWidget);
2396     if (QWindow *window = q->windowHandle()) {
2397         QSurfaceFormat format = window->format();
2398         const int oldAlpha = format.alphaBufferSize();
2399         const int newAlpha = q->testAttribute(Qt::WA_TranslucentBackground)? 8 : 0;
2400         if (oldAlpha != newAlpha) {
2401             format.setAlphaBufferSize(newAlpha);
2402             window->setFormat(format);
2403         }
2404     }
2405 }
2406 
2407 static inline void fillRegion(QPainter *painter, const QRegion &rgn, const QBrush &brush)
2408 {
2409     Q_ASSERT(painter);
2410 
2411     if (brush.style() == Qt::TexturePattern) {
2412 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2413         // Optimize pattern filling on mac by using HITheme directly
2414         // when filling with the standard widget background.
2415         // Defined in qmacstyle_mac.cpp
2416         extern void qt_mac_fill_background(QPainter *painter, const QRegion &rgn, const QBrush &brush);
2417         qt_mac_fill_background(painter, rgn, brush);
2418 #else
2419         {
2420             const QRect rect(rgn.boundingRect());
2421             painter->setClipRegion(rgn);
2422             painter->drawTiledPixmap(rect, brush.texture(), rect.topLeft());
2423         }
2424 #endif
2425 
2426     } else if (brush.gradient()
2427                && brush.gradient()->coordinateMode() == QGradient::ObjectBoundingMode) {
2428         painter->save();
2429         painter->setClipRegion(rgn);
2430         painter->fillRect(0, 0, painter->device()->width(), painter->device()->height(), brush);
2431         painter->restore();
2432     } else {
2433         for (const QRect &rect : rgn)
2434             painter->fillRect(rect, brush);
2435     }
2436 }
2437 
2438 void QWidgetPrivate::paintBackground(QPainter *painter, const QRegion &rgn, int flags) const
2439 {
2440     Q_Q(const QWidget);
2441 
2442 #ifndef QT_NO_SCROLLAREA
2443     bool resetBrushOrigin = false;
2444     QPointF oldBrushOrigin;
2445     //If we are painting the viewport of a scrollarea, we must apply an offset to the brush in case we are drawing a texture
2446     QAbstractScrollArea *scrollArea = qobject_cast<QAbstractScrollArea *>(parent);
2447     if (scrollArea && scrollArea->viewport() == q) {
2448         QObjectData *scrollPrivate = static_cast<QWidget *>(scrollArea)->d_ptr.data();
2449         QAbstractScrollAreaPrivate *priv = static_cast<QAbstractScrollAreaPrivate *>(scrollPrivate);
2450         oldBrushOrigin = painter->brushOrigin();
2451         resetBrushOrigin = true;
2452         painter->setBrushOrigin(-priv->contentsOffset());
2453 
2454     }
2455 #endif // QT_NO_SCROLLAREA
2456 
2457     const QBrush autoFillBrush = q->palette().brush(q->backgroundRole());
2458 
2459     if ((flags & DrawAsRoot) && !(q->autoFillBackground() && autoFillBrush.isOpaque())) {
2460         const QBrush bg = q->palette().brush(QPalette::Window);
2461         if (!(flags & DontSetCompositionMode)) {
2462             //copy alpha straight in
2463             QPainter::CompositionMode oldMode = painter->compositionMode();
2464             painter->setCompositionMode(QPainter::CompositionMode_Source);
2465             fillRegion(painter, rgn, bg);
2466             painter->setCompositionMode(oldMode);
2467         } else {
2468             fillRegion(painter, rgn, bg);
2469         }
2470     }
2471 
2472     if (q->autoFillBackground())
2473         fillRegion(painter, rgn, autoFillBrush);
2474 
2475     if (q->testAttribute(Qt::WA_StyledBackground)) {
2476         painter->setClipRegion(rgn);
2477         QStyleOption opt;
2478         opt.initFrom(q);
2479         q->style()->drawPrimitive(QStyle::PE_Widget, &opt, painter, q);
2480     }
2481 
2482 #ifndef QT_NO_SCROLLAREA
2483     if (resetBrushOrigin)
2484         painter->setBrushOrigin(oldBrushOrigin);
2485 #endif // QT_NO_SCROLLAREA
2486 }
2487 
2488 /*
2489   \internal
2490   This function is called when a widget is hidden or destroyed.
2491   It resets some application global pointers that should only refer active,
2492   visible widgets.
2493 */
2494 
2495 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2496     extern QPointer<QWidget> qt_button_down;
2497 #else
2498     extern QWidget *qt_button_down;
2499 #endif
2500 
2501 void QWidgetPrivate::deactivateWidgetCleanup()
2502 {
2503     Q_Q(QWidget);
2504     // If this was the active application window, reset it
2505     if (QApplication::activeWindow() == q)
2506         QApplication::setActiveWindow(0);
2507     // If the is the active mouse press widget, reset it
2508     if (q == qt_button_down)
2509         qt_button_down = 0;
2510 }
2511 
2512 
2513 /*!
2514     Returns a pointer to the widget with window identifer/handle \a
2515     id.
2516 
2517     The window identifier type depends on the underlying window
2518     system, see \c qwindowdefs.h for the actual definition. If there
2519     is no widget with this identifier, 0 is returned.
2520 */
2521 
2522 QWidget *QWidget::find(WId id)
2523 {
2524     return QWidgetPrivate::mapper ? QWidgetPrivate::mapper->value(id, 0) : 0;
2525 }
2526 
2527 
2528 
2529 /*!
2530     \fn WId QWidget::internalWinId() const
2531     \internal
2532     Returns the window system identifier of the widget, or 0 if the widget is not created yet.
2533 
2534 */
2535 
2536 /*!
2537     \fn WId QWidget::winId() const
2538 
2539     Returns the window system identifier of the widget.
2540 
2541     Portable in principle, but if you use it you are probably about to
2542     do something non-portable. Be careful.
2543 
2544     If a widget is non-native (alien) and winId() is invoked on it, that widget
2545     will be provided a native handle.
2546 
2547     This value may change at run-time. An event with type QEvent::WinIdChange
2548     will be sent to the widget following a change in window system identifier.
2549 
2550     \sa find()
2551 */
2552 WId QWidget::winId() const
2553 {
2554     if (!testAttribute(Qt::WA_WState_Created) || !internalWinId()) {
2555 #ifdef ALIEN_DEBUG
2556         qDebug() << "QWidget::winId: creating native window for" << this;
2557 #endif
2558         QWidget *that = const_cast<QWidget*>(this);
2559         that->setAttribute(Qt::WA_NativeWindow);
2560         that->d_func()->createWinId();
2561         return that->data->winid;
2562     }
2563     return data->winid;
2564 }
2565 
2566 void QWidgetPrivate::createWinId()
2567 {
2568     Q_Q(QWidget);
2569 
2570 #ifdef ALIEN_DEBUG
2571     qDebug() << "QWidgetPrivate::createWinId for" << q;
2572 #endif
2573     const bool forceNativeWindow = q->testAttribute(Qt::WA_NativeWindow);
2574     if (!q->testAttribute(Qt::WA_WState_Created) || (forceNativeWindow && !q->internalWinId())) {
2575         if (!q->isWindow()) {
2576             QWidget *parent = q->parentWidget();
2577             QWidgetPrivate *pd = parent->d_func();
2578             if (forceNativeWindow && !q->testAttribute(Qt::WA_DontCreateNativeAncestors))
2579                 parent->setAttribute(Qt::WA_NativeWindow);
2580             if (!parent->internalWinId()) {
2581                 pd->createWinId();
2582             }
2583 
2584             for (int i = 0; i < pd->children.size(); ++i) {
2585                 QWidget *w = qobject_cast<QWidget *>(pd->children.at(i));
2586                 if (w && !w->isWindow() && (!w->testAttribute(Qt::WA_WState_Created)
2587                                             || (!w->internalWinId() && w->testAttribute(Qt::WA_NativeWindow)))) {
2588                     w->create();
2589                 }
2590             }
2591         } else {
2592             q->create();
2593         }
2594     }
2595 }
2596 
2597 
2598 /*!
2599 \internal
2600 Ensures that the widget has a window system identifier, i.e. that it is known to the windowing system.
2601 
2602 */
2603 
2604 void QWidget::createWinId()
2605 {
2606     Q_D(QWidget);
2607 #ifdef ALIEN_DEBUG
2608     qDebug()  << "QWidget::createWinId" << this;
2609 #endif
2610 //    qWarning("QWidget::createWinId is obsolete, please fix your code.");
2611     d->createWinId();
2612 }
2613 
2614 /*!
2615     \since 4.4
2616 
2617     Returns the effective window system identifier of the widget, i.e. the
2618     native parent's window system identifier.
2619 
2620     If the widget is native, this function returns the native widget ID.
2621     Otherwise, the window ID of the first native parent widget, i.e., the
2622     top-level widget that contains this widget, is returned.
2623 
2624     \note We recommend that you do not store this value as it is likely to
2625     change at run-time.
2626 
2627     \sa nativeParentWidget()
2628 */
2629 WId QWidget::effectiveWinId() const
2630 {
2631     const WId id = internalWinId();
2632     if (id || !testAttribute(Qt::WA_WState_Created))
2633         return id;
2634     if (const QWidget *realParent = nativeParentWidget())
2635         return realParent->internalWinId();
2636     return 0;
2637 }
2638 
2639 /*!
2640     If this is a native widget, return the associated QWindow.
2641     Otherwise return null.
2642 
2643     Native widgets include toplevel widgets, QGLWidget, and child widgets
2644     on which winId() was called.
2645 
2646     \since 5.0
2647 
2648     \sa winId()
2649 */
2650 QWindow *QWidget::windowHandle() const
2651 {
2652     Q_D(const QWidget);
2653     return d->windowHandle();
2654 }
2655 
2656 #ifndef QT_NO_STYLE_STYLESHEET
2657 
2658 /*!
2659     \property QWidget::styleSheet
2660     \brief the widget's style sheet
2661     \since 4.2
2662 
2663     The style sheet contains a textual description of customizations to the
2664     widget's style, as described in the \l{Qt Style Sheets} document.
2665 
2666     Since Qt 4.5, Qt style sheets fully supports \macos.
2667 
2668     \warning Qt style sheets are currently not supported for custom QStyle
2669     subclasses. We plan to address this in some future release.
2670 
2671     \sa setStyle(), QApplication::styleSheet, {Qt Style Sheets}
2672 */
2673 QString QWidget::styleSheet() const
2674 {
2675     Q_D(const QWidget);
2676     if (!d->extra)
2677         return QString();
2678     return d->extra->styleSheet;
2679 }
2680 
2681 void QWidget::setStyleSheet(const QString& styleSheet)
2682 {
2683     Q_D(QWidget);
2684     if (data->in_destructor)
2685         return;
2686     d->createExtra();
2687 
2688     QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(d->extra->style);
2689     d->extra->styleSheet = styleSheet;
2690     if (styleSheet.isEmpty()) { // stylesheet removed
2691         if (!proxy)
2692             return;
2693 
2694         d->inheritStyle();
2695         return;
2696     }
2697 
2698     if (proxy) { // style sheet update
2699         if (d->polished)
2700             proxy->repolish(this);
2701         return;
2702     }
2703 
2704     if (testAttribute(Qt::WA_SetStyle)) {
2705         d->setStyle_helper(new QStyleSheetStyle(d->extra->style), true);
2706     } else {
2707         d->setStyle_helper(new QStyleSheetStyle(0), true);
2708     }
2709 }
2710 
2711 #endif // QT_NO_STYLE_STYLESHEET
2712 
2713 /*!
2714     \sa QWidget::setStyle(), QApplication::setStyle(), QApplication::style()
2715 */
2716 
2717 QStyle *QWidget::style() const
2718 {
2719     Q_D(const QWidget);
2720 
2721     if (d->extra && d->extra->style)
2722         return d->extra->style;
2723     return QApplication::style();
2724 }
2725 
2726 /*!
2727     Sets the widget's GUI style to \a style. The ownership of the style
2728     object is not transferred.
2729 
2730     If no style is set, the widget uses the application's style,
2731     QApplication::style() instead.
2732 
2733     Setting a widget's style has no effect on existing or future child
2734     widgets.
2735 
2736     \warning This function is particularly useful for demonstration
2737     purposes, where you want to show Qt's styling capabilities. Real
2738     applications should avoid it and use one consistent GUI style
2739     instead.
2740 
2741     \warning Qt style sheets are currently not supported for custom QStyle
2742     subclasses. We plan to address this in some future release.
2743 
2744     \sa style(), QStyle, QApplication::style(), QApplication::setStyle()
2745 */
2746 
2747 void QWidget::setStyle(QStyle *style)
2748 {
2749     Q_D(QWidget);
2750     setAttribute(Qt::WA_SetStyle, style != 0);
2751     d->createExtra();
2752 #ifndef QT_NO_STYLE_STYLESHEET
2753     if (QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(style)) {
2754         //if for some reason someone try to set a QStyleSheetStyle, ref it
2755         //(this may happen for exemple in QButtonDialogBox which propagates its style)
2756         proxy->ref();
2757         d->setStyle_helper(style, false);
2758     } else if (qobject_cast<QStyleSheetStyle *>(d->extra->style) || !qApp->styleSheet().isEmpty()) {
2759         // if we have an application stylesheet or have a proxy already, propagate
2760         d->setStyle_helper(new QStyleSheetStyle(style), true);
2761     } else
2762 #endif
2763         d->setStyle_helper(style, false);
2764 }
2765 
2766 void QWidgetPrivate::setStyle_helper(QStyle *newStyle, bool propagate, bool
2767 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2768         metalHack
2769 #endif
2770         )
2771 {
2772     Q_Q(QWidget);
2773     QStyle *oldStyle  = q->style();
2774 #ifndef QT_NO_STYLE_STYLESHEET
2775     QPointer<QStyle> origStyle;
2776 #endif
2777 
2778 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2779     // the metalhack boolean allows Qt/Mac to do a proper re-polish depending
2780     // on how the Qt::WA_MacBrushedMetal attribute is set. It is only ever
2781     // set when changing that attribute and passes the widget's CURRENT style.
2782     // therefore no need to do a reassignment.
2783     if (!metalHack)
2784 #endif
2785     {
2786         createExtra();
2787 
2788 #ifndef QT_NO_STYLE_STYLESHEET
2789         origStyle = extra->style.data();
2790 #endif
2791         extra->style = newStyle;
2792     }
2793 
2794     // repolish
2795     if (q->windowType() != Qt::Desktop) {
2796         if (polished) {
2797             oldStyle->unpolish(q);
2798 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2799             if (metalHack)
2800                 macUpdateMetalAttribute();
2801 #endif
2802             q->style()->polish(q);
2803 #if 0 // Used to be included in Qt4 for Q_WS_MAC
2804         } else if (metalHack) {
2805             macUpdateMetalAttribute();
2806 #endif
2807         }
2808     }
2809 
2810     if (propagate) {
2811         // We copy the list because the order may be modified
2812         const QObjectList childrenList = children;
2813         for (int i = 0; i < childrenList.size(); ++i) {
2814             QWidget *c = qobject_cast<QWidget*>(childrenList.at(i));
2815             if (c)
2816                 c->d_func()->inheritStyle();
2817         }
2818     }
2819 
2820 #ifndef QT_NO_STYLE_STYLESHEET
2821     if (!qobject_cast<QStyleSheetStyle*>(newStyle)) {
2822         if (const QStyleSheetStyle* cssStyle = qobject_cast<QStyleSheetStyle*>(origStyle.data())) {
2823             cssStyle->clearWidgetFont(q);
2824         }
2825     }
2826 #endif
2827 
2828     QEvent e(QEvent::StyleChange);
2829     QApplication::sendEvent(q, &e);
2830 
2831 #ifndef QT_NO_STYLE_STYLESHEET
2832     // dereference the old stylesheet style
2833     if (QStyleSheetStyle *proxy = qobject_cast<QStyleSheetStyle *>(origStyle.data()))
2834         proxy->deref();
2835 #endif
2836 }
2837 
2838 // Inherits style from the current parent and propagates it as necessary
2839 void QWidgetPrivate::inheritStyle()
2840 {
2841 #ifndef QT_NO_STYLE_STYLESHEET
2842     Q_Q(QWidget);
2843 
2844     QStyleSheetStyle *proxy = extra ? qobject_cast<QStyleSheetStyle *>(extra->style) : 0;
2845 
2846     if (!q->styleSheet().isEmpty()) {
2847         Q_ASSERT(proxy);
2848         proxy->repolish(q);
2849         return;
2850     }
2851 
2852     QStyle *origStyle = proxy ? proxy->base : (extra ? (QStyle*)extra->style : 0);
2853     QWidget *parent = q->parentWidget();
2854     QStyle *parentStyle = (parent && parent->d_func()->extra) ? (QStyle*)parent->d_func()->extra->style : 0;
2855     // If we have stylesheet on app or parent has stylesheet style, we need
2856     // to be running a proxy
2857     if (!qApp->styleSheet().isEmpty() || qobject_cast<QStyleSheetStyle *>(parentStyle)) {
2858         QStyle *newStyle = parentStyle;
2859         if (q->testAttribute(Qt::WA_SetStyle))
2860             newStyle = new QStyleSheetStyle(origStyle);
2861         else if (QStyleSheetStyle *newProxy = qobject_cast<QStyleSheetStyle *>(parentStyle))
2862             newProxy->ref();
2863 
2864         setStyle_helper(newStyle, true);
2865         return;
2866     }
2867 
2868     // So, we have no stylesheet on parent/app and we have an empty stylesheet
2869     // we just need our original style back
2870     if (origStyle == (extra ? (QStyle*)extra->style : 0)) // is it any different?
2871         return;
2872 
2873     // We could have inherited the proxy from our parent (which has a custom style)
2874     // In such a case we need to start following the application style (i.e revert
2875     // the propagation behavior of QStyleSheetStyle)
2876     if (!q->testAttribute(Qt::WA_SetStyle))
2877         origStyle = 0;
2878 
2879     setStyle_helper(origStyle, true);
2880 #endif // QT_NO_STYLE_STYLESHEET
2881 }
2882 
2883 
2884 /*!
2885     \fn bool QWidget::isWindow() const
2886 
2887     Returns \c true if the widget is an independent window, otherwise
2888     returns \c false.
2889 
2890     A window is a widget that isn't visually the child of any other
2891     widget and that usually has a frame and a
2892     \l{QWidget::setWindowTitle()}{window title}.
2893 
2894     A window can have a \l{QWidget::parentWidget()}{parent widget}.
2895     It will then be grouped with its parent and deleted when the
2896     parent is deleted, minimized when the parent is minimized etc. If
2897     supported by the window manager, it will also have a common
2898     taskbar entry with its parent.
2899 
2900     QDialog and QMainWindow widgets are by default windows, even if a
2901     parent widget is specified in the constructor. This behavior is
2902     specified by the Qt::Window flag.
2903 
2904     \sa window(), isModal(), parentWidget()
2905 */
2906 
2907 /*!
2908     \property QWidget::modal
2909     \brief whether the widget is a modal widget
2910 
2911     This property only makes sense for windows. A modal widget
2912     prevents widgets in all other windows from getting any input.
2913 
2914     By default, this property is \c false.
2915 
2916     \sa isWindow(), windowModality, QDialog
2917 */
2918 
2919 /*!
2920     \property QWidget::windowModality
2921     \brief which windows are blocked by the modal widget
2922     \since 4.1
2923 
2924     This property only makes sense for windows. A modal widget
2925     prevents widgets in other windows from getting input. The value of
2926     this property controls which windows are blocked when the widget
2927     is visible. Changing this property while the window is visible has
2928     no effect; you must hide() the widget first, then show() it again.
2929 
2930     By default, this property is Qt::NonModal.
2931 
2932     \sa isWindow(), QWidget::modal, QDialog
2933 */
2934 
2935 Qt::WindowModality QWidget::windowModality() const
2936 {
2937     return static_cast<Qt::WindowModality>(data->window_modality);
2938 }
2939 
2940 void QWidget::setWindowModality(Qt::WindowModality windowModality)
2941 {
2942     data->window_modality = windowModality;
2943     // setModal_sys() will be called by setAttribute()
2944     setAttribute(Qt::WA_ShowModal, (data->window_modality != Qt::NonModal));
2945     setAttribute(Qt::WA_SetWindowModality, true);
2946 }
2947 
2948 void QWidgetPrivate::setModal_sys()
2949 {
2950     Q_Q(QWidget);
2951     if (q->windowHandle())
2952         q->windowHandle()->setModality(q->windowModality());
2953 }
2954 
2955 /*!
2956     \fn bool QWidget::underMouse() const
2957 
2958     Returns \c true if the widget is under the mouse cursor; otherwise
2959     returns \c false.
2960 
2961     This value is not updated properly during drag and drop
2962     operations.
2963 
2964     \sa enterEvent(), leaveEvent()
2965 */
2966 
2967 /*!
2968     \property QWidget::minimized
2969     \brief whether this widget is minimized (iconified)
2970 
2971     This property is only relevant for windows.
2972 
2973     By default, this property is \c false.
2974 
2975     \sa showMinimized(), visible, show(), hide(), showNormal(), maximized
2976 */
2977 bool QWidget::isMinimized() const
2978 { return data->window_state & Qt::WindowMinimized; }
2979 
2980 /*!
2981     Shows the widget minimized, as an icon.
2982 
2983     Calling this function only affects \l{isWindow()}{windows}.
2984 
2985     \sa showNormal(), showMaximized(), show(), hide(), isVisible(),
2986         isMinimized()
2987 */
2988 void QWidget::showMinimized()
2989 {
2990     bool isMin = isMinimized();
2991     if (isMin && isVisible())
2992         return;
2993 
2994     ensurePolished();
2995 
2996     if (!isMin)
2997         setWindowState((windowState() & ~Qt::WindowActive) | Qt::WindowMinimized);
2998     setVisible(true);
2999 }
3000 
3001 /*!
3002     \property QWidget::maximized
3003     \brief whether this widget is maximized
3004 
3005     This property is only relevant for windows.
3006 
3007     \note Due to limitations on some window systems, this does not always
3008     report the expected results (e.g., if the user on X11 maximizes the
3009     window via the window manager, Qt has no way of distinguishing this
3010     from any other resize). This is expected to improve as window manager
3011     protocols evolve.
3012 
3013     By default, this property is \c false.
3014 
3015     \sa windowState(), showMaximized(), visible, show(), hide(), showNormal(), minimized
3016 */
3017 bool QWidget::isMaximized() const
3018 { return data->window_state & Qt::WindowMaximized; }
3019 
3020 
3021 
3022 /*!
3023     Returns the current window state. The window state is a OR'ed
3024     combination of Qt::WindowState: Qt::WindowMinimized,
3025     Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.
3026 
3027   \sa Qt::WindowState, setWindowState()
3028  */
3029 Qt::WindowStates QWidget::windowState() const
3030 {
3031     return Qt::WindowStates(data->window_state);
3032 }
3033 
3034 /*!\internal
3035 
3036    The function sets the window state on child widgets similar to
3037    setWindowState(). The difference is that the window state changed
3038    event has the isOverride() flag set. It exists mainly to keep
3039    QWorkspace working.
3040  */
3041 void QWidget::overrideWindowState(Qt::WindowStates newstate)
3042 {
3043     QWindowStateChangeEvent e(Qt::WindowStates(data->window_state), true);
3044     data->window_state  = newstate;
3045     QApplication::sendEvent(this, &e);
3046 }
3047 
3048 /*!
3049     \fn void QWidget::setWindowState(Qt::WindowStates windowState)
3050 
3051     Sets the window state to \a windowState. The window state is a OR'ed
3052     combination of Qt::WindowState: Qt::WindowMinimized,
3053     Qt::WindowMaximized, Qt::WindowFullScreen, and Qt::WindowActive.
3054 
3055     If the window is not visible (i.e. isVisible() returns \c false), the
3056     window state will take effect when show() is called. For visible
3057     windows, the change is immediate. For example, to toggle between
3058     full-screen and normal mode, use the following code:
3059 
3060     \snippet code/src_gui_kernel_qwidget.cpp 0
3061 
3062     In order to restore and activate a minimized window (while
3063     preserving its maximized and/or full-screen state), use the following:
3064 
3065     \snippet code/src_gui_kernel_qwidget.cpp 1
3066 
3067     Calling this function will hide the widget. You must call show() to make
3068     the widget visible again.
3069 
3070     \note On some window systems Qt::WindowActive is not immediate, and may be
3071     ignored in certain cases.
3072 
3073     When the window state changes, the widget receives a changeEvent()
3074     of type QEvent::WindowStateChange.
3075 
3076     \sa Qt::WindowState, windowState()
3077 */
3078 void QWidget::setWindowState(Qt::WindowStates newstate)
3079 {
3080     Q_D(QWidget);
3081     Qt::WindowStates oldstate = windowState();
3082     if (oldstate == newstate)
3083         return;
3084     if (isWindow() && !testAttribute(Qt::WA_WState_Created))
3085         create();
3086 
3087     data->window_state = newstate;
3088     data->in_set_window_state = 1;
3089     if (isWindow()) {
3090         // Ensure the initial size is valid, since we store it as normalGeometry below.
3091         if (!testAttribute(Qt::WA_Resized) && !isVisible())
3092             adjustSize();
3093 
3094         d->createTLExtra();
3095         if (!(oldstate & (Qt::WindowMinimized | Qt::WindowMaximized | Qt::WindowFullScreen)))
3096             d->topData()->normalGeometry = geometry();
3097 
3098         Q_ASSERT(windowHandle());
3099         windowHandle()->setWindowStates(newstate & ~Qt::WindowActive);
3100     }
3101     data->in_set_window_state = 0;
3102 
3103     if (newstate & Qt::WindowActive)
3104         activateWindow();
3105 
3106     QWindowStateChangeEvent e(oldstate);
3107     QApplication::sendEvent(this, &e);
3108 }
3109 
3110 /*!
3111     \property QWidget::fullScreen
3112     \brief whether the widget is shown in full screen mode
3113 
3114     A widget in full screen mode occupies the whole screen area and does not
3115     display window decorations, such as a title bar.
3116 
3117     By default, this property is \c false.
3118 
3119     \sa windowState(), minimized, maximized
3120 */
3121 bool QWidget::isFullScreen() const
3122 { return data->window_state & Qt::WindowFullScreen; }
3123 
3124 /*!
3125     Shows the widget in full-screen mode.
3126 
3127     Calling this function only affects \l{isWindow()}{windows}.
3128 
3129     To return from full-screen mode, call showNormal().
3130 
3131     Full-screen mode works fine under Windows, but has certain
3132     problems under X. These problems are due to limitations of the
3133     ICCCM protocol that specifies the communication between X11
3134     clients and the window manager. ICCCM simply does not understand
3135     the concept of non-decorated full-screen windows. Therefore, the
3136     best we can do is to request a borderless window and place and
3137     resize it to fill the entire screen. Depending on the window
3138     manager, this may or may not work. The borderless window is
3139     requested using MOTIF hints, which are at least partially
3140     supported by virtually all modern window managers.
3141 
3142     An alternative would be to bypass the window manager entirely and
3143     create a window with the Qt::X11BypassWindowManagerHint flag. This
3144     has other severe problems though, like totally broken keyboard focus
3145     and very strange effects on desktop changes or when the user raises
3146     other windows.
3147 
3148     X11 window managers that follow modern post-ICCCM specifications
3149     support full-screen mode properly.
3150 
3151     \sa showNormal(), showMaximized(), show(), hide(), isVisible()
3152 */
3153 void QWidget::showFullScreen()
3154 {
3155 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3156     // If the unified toolbar is enabled, we have to disable it before going fullscreen.
3157     QMainWindow *mainWindow = qobject_cast<QMainWindow*>(this);
3158     if (mainWindow && mainWindow->unifiedTitleAndToolBarOnMac()) {
3159         mainWindow->setUnifiedTitleAndToolBarOnMac(false);
3160         QMainWindowLayout *mainLayout = qobject_cast<QMainWindowLayout*>(mainWindow->layout());
3161         mainLayout->activateUnifiedToolbarAfterFullScreen = true;
3162     }
3163 #endif
3164     ensurePolished();
3165 
3166     setWindowState((windowState() & ~(Qt::WindowMinimized | Qt::WindowMaximized))
3167                    | Qt::WindowFullScreen);
3168     setVisible(true);
3169 #if !defined Q_OS_QNX // On QNX this window will be activated anyway from libscreen
3170                       // activating it here before libscreen activates it causes problems
3171     activateWindow();
3172 #endif
3173 }
3174 
3175 /*!
3176     Shows the widget maximized.
3177 
3178     Calling this function only affects \l{isWindow()}{windows}.
3179 
3180     On X11, this function may not work properly with certain window
3181     managers. See the \l{Window Geometry} documentation for an explanation.
3182 
3183     \sa setWindowState(), showNormal(), showMinimized(), show(), hide(), isVisible()
3184 */
3185 void QWidget::showMaximized()
3186 {
3187     ensurePolished();
3188 
3189     setWindowState((windowState() & ~(Qt::WindowMinimized | Qt::WindowFullScreen))
3190                    | Qt::WindowMaximized);
3191 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3192     // If the unified toolbar was enabled before going fullscreen, we have to enable it back.
3193     QMainWindow *mainWindow = qobject_cast<QMainWindow*>(this);
3194     if (mainWindow)
3195     {
3196         QMainWindowLayout *mainLayout = qobject_cast<QMainWindowLayout*>(mainWindow->layout());
3197         if (mainLayout->activateUnifiedToolbarAfterFullScreen) {
3198             mainWindow->setUnifiedTitleAndToolBarOnMac(true);
3199             mainLayout->activateUnifiedToolbarAfterFullScreen = false;
3200         }
3201     }
3202 #endif
3203     setVisible(true);
3204 }
3205 
3206 /*!
3207     Restores the widget after it has been maximized or minimized.
3208 
3209     Calling this function only affects \l{isWindow()}{windows}.
3210 
3211     \sa setWindowState(), showMinimized(), showMaximized(), show(), hide(), isVisible()
3212 */
3213 void QWidget::showNormal()
3214 {
3215     ensurePolished();
3216 
3217     setWindowState(windowState() & ~(Qt::WindowMinimized
3218                                      | Qt::WindowMaximized
3219                                      | Qt::WindowFullScreen));
3220 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3221     // If the unified toolbar was enabled before going fullscreen, we have to enable it back.
3222     QMainWindow *mainWindow = qobject_cast<QMainWindow*>(this);
3223     if (mainWindow)
3224     {
3225         QMainWindowLayout *mainLayout = qobject_cast<QMainWindowLayout*>(mainWindow->layout());
3226         if (mainLayout->activateUnifiedToolbarAfterFullScreen) {
3227             mainWindow->setUnifiedTitleAndToolBarOnMac(true);
3228             mainLayout->activateUnifiedToolbarAfterFullScreen = false;
3229         }
3230     }
3231 #endif
3232     setVisible(true);
3233 }
3234 
3235 /*!
3236     Returns \c true if this widget would become enabled if \a ancestor is
3237     enabled; otherwise returns \c false.
3238 
3239 
3240 
3241     This is the case if neither the widget itself nor every parent up
3242     to but excluding \a ancestor has been explicitly disabled.
3243 
3244     isEnabledTo(0) returns false if this widget or any if its ancestors
3245     was explicitly disabled.
3246 
3247     The word ancestor here means a parent widget within the same window.
3248 
3249     Therefore isEnabledTo(0) stops at this widget's window, unlike
3250     isEnabled() which also takes parent windows into considerations.
3251 
3252     \sa setEnabled(), enabled
3253 */
3254 
3255 bool QWidget::isEnabledTo(const QWidget *ancestor) const
3256 {
3257     const QWidget * w = this;
3258     while (!w->testAttribute(Qt::WA_ForceDisabled)
3259             && !w->isWindow()
3260             && w->parentWidget()
3261             && w->parentWidget() != ancestor)
3262         w = w->parentWidget();
3263     return !w->testAttribute(Qt::WA_ForceDisabled);
3264 }
3265 
3266 #ifndef QT_NO_ACTION
3267 /*!
3268     Appends the action \a action to this widget's list of actions.
3269 
3270     All QWidgets have a list of \l{QAction}s, however they can be
3271     represented graphically in many different ways. The default use of
3272     the QAction list (as returned by actions()) is to create a context
3273     QMenu.
3274 
3275     A QWidget should only have one of each action and adding an action
3276     it already has will not cause the same action to be in the widget twice.
3277 
3278     The ownership of \a action is not transferred to this QWidget.
3279 
3280     \sa removeAction(), insertAction(), actions(), QMenu
3281 */
3282 void QWidget::addAction(QAction *action)
3283 {
3284     insertAction(0, action);
3285 }
3286 
3287 /*!
3288     Appends the actions \a actions to this widget's list of actions.
3289 
3290     \sa removeAction(), QMenu, addAction()
3291 */
3292 #if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
3293 void QWidget::addActions(const QList<QAction *> &actions)
3294 #else
3295 void QWidget::addActions(QList<QAction*> actions)
3296 #endif
3297 {
3298     for(int i = 0; i < actions.count(); i++)
3299         insertAction(0, actions.at(i));
3300 }
3301 
3302 /*!
3303     Inserts the action \a action to this widget's list of actions,
3304     before the action \a before. It appends the action if \a before is 0 or
3305     \a before is not a valid action for this widget.
3306 
3307     A QWidget should only have one of each action.
3308 
3309     \sa removeAction(), addAction(), QMenu, contextMenuPolicy, actions()
3310 */
3311 void QWidget::insertAction(QAction *before, QAction *action)
3312 {
3313     if (Q_UNLIKELY(!action)) {
3314         qWarning("QWidget::insertAction: Attempt to insert null action");
3315         return;
3316     }
3317 
3318     Q_D(QWidget);
3319     if(d->actions.contains(action))
3320         removeAction(action);
3321 
3322     int pos = d->actions.indexOf(before);
3323     if (pos < 0) {
3324         before = 0;
3325         pos = d->actions.size();
3326     }
3327     d->actions.insert(pos, action);
3328 
3329     QActionPrivate *apriv = action->d_func();
3330     apriv->widgets.append(this);
3331 
3332     QActionEvent e(QEvent::ActionAdded, action, before);
3333     QApplication::sendEvent(this, &e);
3334 }
3335 
3336 /*!
3337     Inserts the actions \a actions to this widget's list of actions,
3338     before the action \a before. It appends the action if \a before is 0 or
3339     \a before is not a valid action for this widget.
3340 
3341     A QWidget can have at most one of each action.
3342 
3343     \sa removeAction(), QMenu, insertAction(), contextMenuPolicy
3344 */
3345 #if QT_VERSION >= QT_VERSION_CHECK(6,0,0)
3346 void QWidget::insertActions(QAction *before, const QList<QAction*> &actions)
3347 #else
3348 void QWidget::insertActions(QAction *before, QList<QAction*> actions)
3349 #endif
3350 {
3351     for(int i = 0; i < actions.count(); ++i)
3352         insertAction(before, actions.at(i));
3353 }
3354 
3355 /*!
3356     Removes the action \a action from this widget's list of actions.
3357     \sa insertAction(), actions(), insertAction()
3358 */
3359 void QWidget::removeAction(QAction *action)
3360 {
3361     if (!action)
3362         return;
3363 
3364     Q_D(QWidget);
3365 
3366     QActionPrivate *apriv = action->d_func();
3367     apriv->widgets.removeAll(this);
3368 
3369     if (d->actions.removeAll(action)) {
3370         QActionEvent e(QEvent::ActionRemoved, action);
3371         QApplication::sendEvent(this, &e);
3372     }
3373 }
3374 
3375 /*!
3376     Returns the (possibly empty) list of this widget's actions.
3377 
3378     \sa contextMenuPolicy, insertAction(), removeAction()
3379 */
3380 QList<QAction*> QWidget::actions() const
3381 {
3382     Q_D(const QWidget);
3383     return d->actions;
3384 }
3385 #endif // QT_NO_ACTION
3386 
3387 /*!
3388   \fn bool QWidget::isEnabledToTLW() const
3389   \obsolete
3390 
3391   This function is deprecated. It is equivalent to isEnabled()
3392 */
3393 
3394 /*!
3395     \property QWidget::enabled
3396     \brief whether the widget is enabled
3397 
3398     In general an enabled widget handles keyboard and mouse events; a disabled
3399     widget does not. An exception is made with \l{QAbstractButton}.
3400 
3401     Some widgets display themselves differently when they are
3402     disabled. For example a button might draw its label grayed out. If
3403     your widget needs to know when it becomes enabled or disabled, you
3404     can use the changeEvent() with type QEvent::EnabledChange.
3405 
3406     Disabling a widget implicitly disables all its children. Enabling
3407     respectively enables all child widgets unless they have been
3408     explicitly disabled. It it not possible to explicitly enable a child
3409     widget which is not a window while its parent widget remains disabled.
3410 
3411     By default, this property is \c true.
3412 
3413     \sa isEnabledTo(), QKeyEvent, QMouseEvent, changeEvent()
3414 */
3415 void QWidget::setEnabled(bool enable)
3416 {
3417     Q_D(QWidget);
3418     setAttribute(Qt::WA_ForceDisabled, !enable);
3419     d->setEnabled_helper(enable);
3420 }
3421 
3422 void QWidgetPrivate::setEnabled_helper(bool enable)
3423 {
3424     Q_Q(QWidget);
3425 
3426     if (enable && !q->isWindow() && q->parentWidget() && !q->parentWidget()->isEnabled())
3427         return; // nothing we can do
3428 
3429     if (enable != q->testAttribute(Qt::WA_Disabled))
3430         return; // nothing to do
3431 
3432     q->setAttribute(Qt::WA_Disabled, !enable);
3433     updateSystemBackground();
3434 
3435     if (!enable && q->window()->focusWidget() == q) {
3436         bool parentIsEnabled = (!q->parentWidget() || q->parentWidget()->isEnabled());
3437         if (!parentIsEnabled || !q->focusNextChild())
3438             q->clearFocus();
3439     }
3440 
3441     Qt::WidgetAttribute attribute = enable ? Qt::WA_ForceDisabled : Qt::WA_Disabled;
3442     for (int i = 0; i < children.size(); ++i) {
3443         QWidget *w = qobject_cast<QWidget *>(children.at(i));
3444         if (w && !w->testAttribute(attribute))
3445             w->d_func()->setEnabled_helper(enable);
3446     }
3447 #if 0 // Used to be included in Qt4 for Q_WS_X11
3448     if (q->testAttribute(Qt::WA_SetCursor) || q->isWindow()) {
3449         // enforce the windows behavior of clearing the cursor on
3450         // disabled widgets
3451         qt_x11_enforce_cursor(q);
3452     }
3453 #endif
3454 #ifndef QT_NO_CURSOR
3455     if (q->testAttribute(Qt::WA_SetCursor) || q->isWindow()) {
3456         // enforce the windows behavior of clearing the cursor on
3457         // disabled widgets
3458         qt_qpa_set_cursor(q, false);
3459     }
3460 #endif
3461 #if 0 // Used to be included in Qt4 for Q_WS_MAC
3462     setEnabled_helper_sys(enable);
3463 #endif
3464 #ifndef QT_NO_IM
3465     if (q->testAttribute(Qt::WA_InputMethodEnabled) && q->hasFocus()) {
3466         QWidget *focusWidget = effectiveFocusWidget();
3467 
3468         if (enable) {
3469             if (focusWidget->testAttribute(Qt::WA_InputMethodEnabled))
3470                 QGuiApplication::inputMethod()->update(Qt::ImEnabled);
3471         } else {
3472             QGuiApplication::inputMethod()->commit();
3473             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
3474         }
3475     }
3476 #endif //QT_NO_IM
3477     QEvent e(QEvent::EnabledChange);
3478     QApplication::sendEvent(q, &e);
3479 }
3480 
3481 /*!
3482     \property QWidget::acceptDrops
3483     \brief whether drop events are enabled for this widget
3484 
3485     Setting this property to true announces to the system that this
3486     widget \e may be able to accept drop events.
3487 
3488     If the widget is the desktop (windowType() == Qt::Desktop), this may
3489     fail if another application is using the desktop; you can call
3490     acceptDrops() to test if this occurs.
3491 
3492     \warning Do not modify this property in a drag and drop event handler.
3493 
3494     By default, this property is \c false.
3495 
3496     \sa {Drag and Drop}
3497 */
3498 bool QWidget::acceptDrops() const
3499 {
3500     return testAttribute(Qt::WA_AcceptDrops);
3501 }
3502 
3503 void QWidget::setAcceptDrops(bool on)
3504 {
3505     setAttribute(Qt::WA_AcceptDrops, on);
3506 
3507 }
3508 
3509 void QWidgetPrivate::registerDropSite(bool on)
3510 {
3511     Q_UNUSED(on);
3512 }
3513 
3514 /*!
3515     Disables widget input events if \a disable is true; otherwise
3516     enables input events.
3517 
3518     See the \l enabled documentation for more information.
3519 
3520     \sa isEnabledTo(), QKeyEvent, QMouseEvent, changeEvent()
3521 */
3522 void QWidget::setDisabled(bool disable)
3523 {
3524     setEnabled(!disable);
3525 }
3526 
3527 /*!
3528     \property QWidget::frameGeometry
3529     \brief geometry of the widget relative to its parent including any
3530     window frame
3531 
3532     See the \l{Window Geometry} documentation for an overview of geometry
3533     issues with windows.
3534 
3535     By default, this property contains a value that depends on the user's
3536     platform and screen geometry.
3537 
3538     \sa geometry(), x(), y(), pos()
3539 */
3540 QRect QWidget::frameGeometry() const
3541 {
3542     Q_D(const QWidget);
3543     if (isWindow() && ! (windowType() == Qt::Popup)) {
3544         QRect fs = d->frameStrut();
3545         return QRect(data->crect.x() - fs.left(),
3546                      data->crect.y() - fs.top(),
3547                      data->crect.width() + fs.left() + fs.right(),
3548                      data->crect.height() + fs.top() + fs.bottom());
3549     }
3550     return data->crect;
3551 }
3552 
3553 /*!
3554     \property QWidget::x
3555 
3556     \brief the x coordinate of the widget relative to its parent including
3557     any window frame
3558 
3559     See the \l{Window Geometry} documentation for an overview of geometry
3560     issues with windows.
3561 
3562     By default, this property has a value of 0.
3563 
3564     \sa frameGeometry, y, pos
3565 */
3566 int QWidget::x() const
3567 {
3568     Q_D(const QWidget);
3569     if (isWindow() && ! (windowType() == Qt::Popup))
3570         return data->crect.x() - d->frameStrut().left();
3571     return data->crect.x();
3572 }
3573 
3574 /*!
3575     \property QWidget::y
3576     \brief the y coordinate of the widget relative to its parent and
3577     including any window frame
3578 
3579     See the \l{Window Geometry} documentation for an overview of geometry
3580     issues with windows.
3581 
3582     By default, this property has a value of 0.
3583 
3584     \sa frameGeometry, x, pos
3585 */
3586 int QWidget::y() const
3587 {
3588     Q_D(const QWidget);
3589     if (isWindow() && ! (windowType() == Qt::Popup))
3590         return data->crect.y() - d->frameStrut().top();
3591     return data->crect.y();
3592 }
3593 
3594 /*!
3595     \property QWidget::pos
3596     \brief the position of the widget within its parent widget
3597 
3598     If the widget is a window, the position is that of the widget on
3599     the desktop, including its frame.
3600 
3601     When changing the position, the widget, if visible, receives a
3602     move event (moveEvent()) immediately. If the widget is not
3603     currently visible, it is guaranteed to receive an event before it
3604     is shown.
3605 
3606     By default, this property contains a position that refers to the
3607     origin.
3608 
3609     \warning Calling move() or setGeometry() inside moveEvent() can
3610     lead to infinite recursion.
3611 
3612     See the \l{Window Geometry} documentation for an overview of geometry
3613     issues with windows.
3614 
3615     \sa frameGeometry, size, x(), y()
3616 */
3617 QPoint QWidget::pos() const
3618 {
3619     Q_D(const QWidget);
3620     QPoint result = data->crect.topLeft();
3621     if (isWindow() && ! (windowType() == Qt::Popup))
3622         if (!d->maybeTopData() || !d->maybeTopData()->posIncludesFrame)
3623             result -= d->frameStrut().topLeft();
3624     return result;
3625 }
3626 
3627 /*!
3628     \property QWidget::geometry
3629     \brief the geometry of the widget relative to its parent and
3630     excluding the window frame
3631 
3632     When changing the geometry, the widget, if visible, receives a
3633     move event (moveEvent()) and/or a resize event (resizeEvent())
3634     immediately. If the widget is not currently visible, it is
3635     guaranteed to receive appropriate events before it is shown.
3636 
3637     The size component is adjusted if it lies outside the range
3638     defined by minimumSize() and maximumSize().
3639 
3640     \warning Calling setGeometry() inside resizeEvent() or moveEvent()
3641     can lead to infinite recursion.
3642 
3643     See the \l{Window Geometry} documentation for an overview of geometry
3644     issues with windows.
3645 
3646     By default, this property contains a value that depends on the user's
3647     platform and screen geometry.
3648 
3649     \sa frameGeometry(), rect(), move(), resize(), moveEvent(),
3650         resizeEvent(), minimumSize(), maximumSize()
3651 */
3652 
3653 /*!
3654     \property QWidget::normalGeometry
3655 
3656     \brief the geometry of the widget as it will appear when shown as
3657     a normal (not maximized or full screen) top-level widget
3658 
3659     For child widgets this property always holds an empty rectangle.
3660 
3661     By default, this property contains an empty rectangle.
3662 
3663     \sa QWidget::windowState(), QWidget::geometry
3664 */
3665 
3666 /*!
3667     \property QWidget::size
3668     \brief the size of the widget excluding any window frame
3669 
3670     If the widget is visible when it is being resized, it receives a resize event
3671     (resizeEvent()) immediately. If the widget is not currently
3672     visible, it is guaranteed to receive an event before it is shown.
3673 
3674     The size is adjusted if it lies outside the range defined by
3675     minimumSize() and maximumSize().
3676 
3677     By default, this property contains a value that depends on the user's
3678     platform and screen geometry.
3679 
3680     \warning Calling resize() or setGeometry() inside resizeEvent() can
3681     lead to infinite recursion.
3682 
3683     \note Setting the size to \c{QSize(0, 0)} will cause the widget to not
3684     appear on screen. This also applies to windows.
3685 
3686     \sa pos, geometry, minimumSize, maximumSize, resizeEvent(), adjustSize()
3687 */
3688 
3689 /*!
3690     \property QWidget::width
3691     \brief the width of the widget excluding any window frame
3692 
3693     See the \l{Window Geometry} documentation for an overview of geometry
3694     issues with windows.
3695 
3696     \note Do not use this function to find the width of a screen on
3697     a \l{QDesktopWidget}{multiple screen desktop}. Read
3698     \l{QDesktopWidget#Screen Geometry}{this note} for details.
3699 
3700     By default, this property contains a value that depends on the user's
3701     platform and screen geometry.
3702 
3703     \sa geometry, height, size
3704 */
3705 
3706 /*!
3707     \property QWidget::height
3708     \brief the height of the widget excluding any window frame
3709 
3710     See the \l{Window Geometry} documentation for an overview of geometry
3711     issues with windows.
3712 
3713     \note Do not use this function to find the height of a screen
3714     on a \l{QDesktopWidget}{multiple screen desktop}. Read
3715     \l{QDesktopWidget#Screen Geometry}{this note} for details.
3716 
3717     By default, this property contains a value that depends on the user's
3718     platform and screen geometry.
3719 
3720     \sa geometry, width, size
3721 */
3722 
3723 /*!
3724     \property QWidget::rect
3725     \brief the internal geometry of the widget excluding any window
3726     frame
3727 
3728     The rect property equals QRect(0, 0, width(), height()).
3729 
3730     See the \l{Window Geometry} documentation for an overview of geometry
3731     issues with windows.
3732 
3733     By default, this property contains a value that depends on the user's
3734     platform and screen geometry.
3735 
3736     \sa size
3737 */
3738 
3739 
3740 QRect QWidget::normalGeometry() const
3741 {
3742     Q_D(const QWidget);
3743     if (!d->extra || !d->extra->topextra)
3744         return QRect();
3745 
3746     if (!isMaximized() && !isFullScreen())
3747         return geometry();
3748 
3749     return d->topData()->normalGeometry;
3750 }
3751 
3752 
3753 /*!
3754     \property QWidget::childrenRect
3755     \brief the bounding rectangle of the widget's children
3756 
3757     Hidden children are excluded.
3758 
3759     By default, for a widget with no children, this property contains a
3760     rectangle with zero width and height located at the origin.
3761 
3762     \sa childrenRegion(), geometry()
3763 */
3764 
3765 QRect QWidget::childrenRect() const
3766 {
3767     Q_D(const QWidget);
3768     QRect r(0, 0, 0, 0);
3769     for (int i = 0; i < d->children.size(); ++i) {
3770         QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
3771         if (w && !w->isWindow() && !w->isHidden())
3772             r |= w->geometry();
3773     }
3774     return r;
3775 }
3776 
3777 /*!
3778     \property QWidget::childrenRegion
3779     \brief the combined region occupied by the widget's children
3780 
3781     Hidden children are excluded.
3782 
3783     By default, for a widget with no children, this property contains an
3784     empty region.
3785 
3786     \sa childrenRect(), geometry(), mask()
3787 */
3788 
3789 QRegion QWidget::childrenRegion() const
3790 {
3791     Q_D(const QWidget);
3792     QRegion r;
3793     for (int i = 0; i < d->children.size(); ++i) {
3794         QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
3795         if (w && !w->isWindow() && !w->isHidden()) {
3796             QRegion mask = w->mask();
3797             if (mask.isEmpty())
3798                 r |= w->geometry();
3799             else
3800                 r |= mask.translated(w->pos());
3801         }
3802     }
3803     return r;
3804 }
3805 
3806 
3807 /*!
3808     \property QWidget::minimumSize
3809     \brief the widget's minimum size
3810 
3811     The widget cannot be resized to a smaller size than the minimum
3812     widget size. The widget's size is forced to the minimum size if
3813     the current size is smaller.
3814 
3815     The minimum size set by this function will override the minimum size
3816     defined by QLayout. In order to unset the minimum size, use a
3817     value of \c{QSize(0, 0)}.
3818 
3819     By default, this property contains a size with zero width and height.
3820 
3821     \sa minimumWidth, minimumHeight, maximumSize, sizeIncrement
3822 */
3823 
3824 QSize QWidget::minimumSize() const
3825 {
3826     Q_D(const QWidget);
3827     return d->extra ? QSize(d->extra->minw, d->extra->minh) : QSize(0, 0);
3828 }
3829 
3830 /*!
3831     \property QWidget::maximumSize
3832     \brief the widget's maximum size in pixels
3833 
3834     The widget cannot be resized to a larger size than the maximum
3835     widget size.
3836 
3837     By default, this property contains a size in which both width and height
3838     have values of 16777215.
3839 
3840     \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size
3841     of widgets.
3842 
3843     \sa maximumWidth, maximumHeight, minimumSize, sizeIncrement
3844 */
3845 
3846 QSize QWidget::maximumSize() const
3847 {
3848     Q_D(const QWidget);
3849     return d->extra ? QSize(d->extra->maxw, d->extra->maxh)
3850                  : QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
3851 }
3852 
3853 
3854 /*!
3855     \property QWidget::minimumWidth
3856     \brief the widget's minimum width in pixels
3857 
3858     This property corresponds to the width held by the \l minimumSize property.
3859 
3860     By default, this property has a value of 0.
3861 
3862     \sa minimumSize, minimumHeight
3863 */
3864 
3865 /*!
3866     \property QWidget::minimumHeight
3867     \brief the widget's minimum height in pixels
3868 
3869     This property corresponds to the height held by the \l minimumSize property.
3870 
3871     By default, this property has a value of 0.
3872 
3873     \sa minimumSize, minimumWidth
3874 */
3875 
3876 /*!
3877     \property QWidget::maximumWidth
3878     \brief the widget's maximum width in pixels
3879 
3880     This property corresponds to the width held by the \l maximumSize property.
3881 
3882     By default, this property contains a value of 16777215.
3883 
3884     \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size
3885     of widgets.
3886 
3887     \sa maximumSize, maximumHeight
3888 */
3889 
3890 /*!
3891     \property QWidget::maximumHeight
3892     \brief the widget's maximum height in pixels
3893 
3894     This property corresponds to the height held by the \l maximumSize property.
3895 
3896     By default, this property contains a value of 16777215.
3897 
3898     \note The definition of the \c QWIDGETSIZE_MAX macro limits the maximum size
3899     of widgets.
3900 
3901     \sa maximumSize, maximumWidth
3902 */
3903 
3904 /*!
3905     \property QWidget::sizeIncrement
3906     \brief the size increment of the widget
3907 
3908     When the user resizes the window, the size will move in steps of
3909     sizeIncrement().width() pixels horizontally and
3910     sizeIncrement.height() pixels vertically, with baseSize() as the
3911     basis. Preferred widget sizes are for non-negative integers \e i
3912     and \e j:
3913     \snippet code/src_gui_kernel_qwidget.cpp 2
3914 
3915     Note that while you can set the size increment for all widgets, it
3916     only affects windows.
3917 
3918     By default, this property contains a size with zero width and height.
3919 
3920     \warning The size increment has no effect under Windows, and may
3921     be disregarded by the window manager on X11.
3922 
3923     \sa size, minimumSize, maximumSize
3924 */
3925 QSize QWidget::sizeIncrement() const
3926 {
3927     Q_D(const QWidget);
3928     return (d->extra && d->extra->topextra)
3929         ? QSize(d->extra->topextra->incw, d->extra->topextra->inch)
3930         : QSize(0, 0);
3931 }
3932 
3933 /*!
3934     \property QWidget::baseSize
3935     \brief the base size of the widget
3936 
3937     The base size is used to calculate a proper widget size if the
3938     widget defines sizeIncrement().
3939 
3940     By default, for a newly-created widget, this property contains a size with
3941     zero width and height.
3942 
3943     \sa setSizeIncrement()
3944 */
3945 
3946 QSize QWidget::baseSize() const
3947 {
3948     Q_D(const QWidget);
3949     return (d->extra != 0 && d->extra->topextra != 0)
3950         ? QSize(d->extra->topextra->basew, d->extra->topextra->baseh)
3951         : QSize(0, 0);
3952 }
3953 
3954 bool QWidgetPrivate::setMinimumSize_helper(int &minw, int &minh)
3955 {
3956     Q_Q(QWidget);
3957 
3958     int mw = minw, mh = minh;
3959     if (mw == QWIDGETSIZE_MAX)
3960         mw = 0;
3961     if (mh == QWIDGETSIZE_MAX)
3962         mh = 0;
3963     if (Q_UNLIKELY(minw > QWIDGETSIZE_MAX || minh > QWIDGETSIZE_MAX)) {
3964         qWarning("QWidget::setMinimumSize: (%s/%s) "
3965                 "The largest allowed size is (%d,%d)",
3966                  q->objectName().toLocal8Bit().data(), q->metaObject()->className(), QWIDGETSIZE_MAX,
3967                 QWIDGETSIZE_MAX);
3968         minw = mw = qMin<int>(minw, QWIDGETSIZE_MAX);
3969         minh = mh = qMin<int>(minh, QWIDGETSIZE_MAX);
3970     }
3971     if (Q_UNLIKELY(minw < 0 || minh < 0)) {
3972         qWarning("QWidget::setMinimumSize: (%s/%s) Negative sizes (%d,%d) "
3973                 "are not possible",
3974                 q->objectName().toLocal8Bit().data(), q->metaObject()->className(), minw, minh);
3975         minw = mw = qMax(minw, 0);
3976         minh = mh = qMax(minh, 0);
3977     }
3978     createExtra();
3979     if (extra->minw == mw && extra->minh == mh)
3980         return false;
3981     extra->minw = mw;
3982     extra->minh = mh;
3983     extra->explicitMinSize = (mw ? Qt::Horizontal : 0) | (mh ? Qt::Vertical : 0);
3984     return true;
3985 }
3986 
3987 void QWidgetPrivate::setConstraints_sys()
3988 {
3989     Q_Q(QWidget);
3990     if (extra && q->windowHandle()) {
3991         QWindow *win = q->windowHandle();
3992         QWindowPrivate *winp = qt_window_private(win);
3993 
3994         winp->minimumSize = QSize(extra->minw, extra->minh);
3995         winp->maximumSize = QSize(extra->maxw, extra->maxh);
3996 
3997         if (extra->topextra) {
3998             winp->baseSize = QSize(extra->topextra->basew, extra->topextra->baseh);
3999             winp->sizeIncrement = QSize(extra->topextra->incw, extra->topextra->inch);
4000         }
4001 
4002         if (winp->platformWindow) {
4003             fixPosIncludesFrame();
4004             winp->platformWindow->propagateSizeHints();
4005         }
4006     }
4007 }
4008 
4009 /*!
4010     \overload
4011 
4012     This function corresponds to setMinimumSize(QSize(minw, minh)).
4013     Sets the minimum width to \a minw and the minimum height to \a
4014     minh.
4015 */
4016 
4017 void QWidget::setMinimumSize(int minw, int minh)
4018 {
4019     Q_D(QWidget);
4020     if (!d->setMinimumSize_helper(minw, minh))
4021         return;
4022 
4023     if (isWindow())
4024         d->setConstraints_sys();
4025     if (minw > width() || minh > height()) {
4026         bool resized = testAttribute(Qt::WA_Resized);
4027         bool maximized = isMaximized();
4028         resize(qMax(minw,width()), qMax(minh,height()));
4029         setAttribute(Qt::WA_Resized, resized); //not a user resize
4030         if (maximized)
4031             data->window_state = data->window_state | Qt::WindowMaximized;
4032     }
4033 #if QT_CONFIG(graphicsview)
4034     if (d->extra) {
4035         if (d->extra->proxyWidget)
4036             d->extra->proxyWidget->setMinimumSize(minw, minh);
4037     }
4038 #endif
4039     d->updateGeometry_helper(d->extra->minw == d->extra->maxw && d->extra->minh == d->extra->maxh);
4040 }
4041 
4042 bool QWidgetPrivate::setMaximumSize_helper(int &maxw, int &maxh)
4043 {
4044     Q_Q(QWidget);
4045     if (Q_UNLIKELY(maxw > QWIDGETSIZE_MAX || maxh > QWIDGETSIZE_MAX)) {
4046         qWarning("QWidget::setMaximumSize: (%s/%s) "
4047                 "The largest allowed size is (%d,%d)",
4048                  q->objectName().toLocal8Bit().data(), q->metaObject()->className(), QWIDGETSIZE_MAX,
4049                 QWIDGETSIZE_MAX);
4050         maxw = qMin<int>(maxw, QWIDGETSIZE_MAX);
4051         maxh = qMin<int>(maxh, QWIDGETSIZE_MAX);
4052     }
4053     if (Q_UNLIKELY(maxw < 0 || maxh < 0)) {
4054         qWarning("QWidget::setMaximumSize: (%s/%s) Negative sizes (%d,%d) "
4055                 "are not possible",
4056                 q->objectName().toLocal8Bit().data(), q->metaObject()->className(), maxw, maxh);
4057         maxw = qMax(maxw, 0);
4058         maxh = qMax(maxh, 0);
4059     }
4060     createExtra();
4061     if (extra->maxw == maxw && extra->maxh == maxh)
4062         return false;
4063     extra->maxw = maxw;
4064     extra->maxh = maxh;
4065     extra->explicitMaxSize = (maxw != QWIDGETSIZE_MAX ? Qt::Horizontal : 0) |
4066                              (maxh != QWIDGETSIZE_MAX ? Qt::Vertical : 0);
4067     return true;
4068 }
4069 
4070 /*!
4071     \overload
4072 
4073     This function corresponds to setMaximumSize(QSize(\a maxw, \a
4074     maxh)). Sets the maximum width to \a maxw and the maximum height
4075     to \a maxh.
4076 */
4077 void QWidget::setMaximumSize(int maxw, int maxh)
4078 {
4079     Q_D(QWidget);
4080     if (!d->setMaximumSize_helper(maxw, maxh))
4081         return;
4082 
4083     if (isWindow())
4084         d->setConstraints_sys();
4085     if (maxw < width() || maxh < height()) {
4086         bool resized = testAttribute(Qt::WA_Resized);
4087         resize(qMin(maxw,width()), qMin(maxh,height()));
4088         setAttribute(Qt::WA_Resized, resized); //not a user resize
4089     }
4090 
4091 #if QT_CONFIG(graphicsview)
4092     if (d->extra) {
4093         if (d->extra->proxyWidget)
4094             d->extra->proxyWidget->setMaximumSize(maxw, maxh);
4095     }
4096 #endif
4097 
4098     d->updateGeometry_helper(d->extra->minw == d->extra->maxw && d->extra->minh == d->extra->maxh);
4099 }
4100 
4101 /*!
4102     \overload
4103 
4104     Sets the x (width) size increment to \a w and the y (height) size
4105     increment to \a h.
4106 */
4107 void QWidget::setSizeIncrement(int w, int h)
4108 {
4109     Q_D(QWidget);
4110     d->createTLExtra();
4111     QTLWExtra* x = d->topData();
4112     if (x->incw == w && x->inch == h)
4113         return;
4114     x->incw = w;
4115     x->inch = h;
4116     if (isWindow())
4117         d->setConstraints_sys();
4118 }
4119 
4120 /*!
4121     \overload
4122 
4123     This corresponds to setBaseSize(QSize(\a basew, \a baseh)). Sets
4124     the widgets base size to width \a basew and height \a baseh.
4125 */
4126 void QWidget::setBaseSize(int basew, int baseh)
4127 {
4128     Q_D(QWidget);
4129     d->createTLExtra();
4130     QTLWExtra* x = d->topData();
4131     if (x->basew == basew && x->baseh == baseh)
4132         return;
4133     x->basew = basew;
4134     x->baseh = baseh;
4135     if (isWindow())
4136         d->setConstraints_sys();
4137 }
4138 
4139 /*!
4140     Sets both the minimum and maximum sizes of the widget to \a s,
4141     thereby preventing it from ever growing or shrinking.
4142 
4143     This will override the default size constraints set by QLayout.
4144 
4145     To remove constraints, set the size to QWIDGETSIZE_MAX.
4146 
4147     Alternatively, if you want the widget to have a
4148     fixed size based on its contents, you can call
4149     QLayout::setSizeConstraint(QLayout::SetFixedSize);
4150 
4151     \sa maximumSize, minimumSize
4152 */
4153 
4154 void QWidget::setFixedSize(const QSize & s)
4155 {
4156     setFixedSize(s.width(), s.height());
4157 }
4158 
4159 
4160 /*!
4161     \fn void QWidget::setFixedSize(int w, int h)
4162     \overload
4163 
4164     Sets the width of the widget to \a w and the height to \a h.
4165 */
4166 
4167 void QWidget::setFixedSize(int w, int h)
4168 {
4169     Q_D(QWidget);
4170     bool minSizeSet = d->setMinimumSize_helper(w, h);
4171     bool maxSizeSet = d->setMaximumSize_helper(w, h);
4172     if (!minSizeSet && !maxSizeSet)
4173         return;
4174 
4175     if (isWindow())
4176         d->setConstraints_sys();
4177     else
4178         d->updateGeometry_helper(true);
4179 
4180     if (w != QWIDGETSIZE_MAX || h != QWIDGETSIZE_MAX)
4181         resize(w, h);
4182 }
4183 
4184 void QWidget::setMinimumWidth(int w)
4185 {
4186     Q_D(QWidget);
4187     d->createExtra();
4188     uint expl = d->extra->explicitMinSize | (w ? Qt::Horizontal : 0);
4189     setMinimumSize(w, minimumSize().height());
4190     d->extra->explicitMinSize = expl;
4191 }
4192 
4193 void QWidget::setMinimumHeight(int h)
4194 {
4195     Q_D(QWidget);
4196     d->createExtra();
4197     uint expl = d->extra->explicitMinSize | (h ? Qt::Vertical : 0);
4198     setMinimumSize(minimumSize().width(), h);
4199     d->extra->explicitMinSize = expl;
4200 }
4201 
4202 void QWidget::setMaximumWidth(int w)
4203 {
4204     Q_D(QWidget);
4205     d->createExtra();
4206     uint expl = d->extra->explicitMaxSize | (w == QWIDGETSIZE_MAX ? 0 : Qt::Horizontal);
4207     setMaximumSize(w, maximumSize().height());
4208     d->extra->explicitMaxSize = expl;
4209 }
4210 
4211 void QWidget::setMaximumHeight(int h)
4212 {
4213     Q_D(QWidget);
4214     d->createExtra();
4215     uint expl = d->extra->explicitMaxSize | (h == QWIDGETSIZE_MAX ? 0 : Qt::Vertical);
4216     setMaximumSize(maximumSize().width(), h);
4217     d->extra->explicitMaxSize = expl;
4218 }
4219 
4220 /*!
4221     Sets both the minimum and maximum width of the widget to \a w
4222     without changing the heights. Provided for convenience.
4223 
4224     \sa sizeHint(), minimumSize(), maximumSize(), setFixedSize()
4225 */
4226 
4227 void QWidget::setFixedWidth(int w)
4228 {
4229     Q_D(QWidget);
4230     d->createExtra();
4231     uint explMin = d->extra->explicitMinSize | Qt::Horizontal;
4232     uint explMax = d->extra->explicitMaxSize | Qt::Horizontal;
4233     setMinimumSize(w, minimumSize().height());
4234     setMaximumSize(w, maximumSize().height());
4235     d->extra->explicitMinSize = explMin;
4236     d->extra->explicitMaxSize = explMax;
4237 }
4238 
4239 
4240 /*!
4241     Sets both the minimum and maximum heights of the widget to \a h
4242     without changing the widths. Provided for convenience.
4243 
4244     \sa sizeHint(), minimumSize(), maximumSize(), setFixedSize()
4245 */
4246 
4247 void QWidget::setFixedHeight(int h)
4248 {
4249     Q_D(QWidget);
4250     d->createExtra();
4251     uint explMin = d->extra->explicitMinSize | Qt::Vertical;
4252     uint explMax = d->extra->explicitMaxSize | Qt::Vertical;
4253     setMinimumSize(minimumSize().width(), h);
4254     setMaximumSize(maximumSize().width(), h);
4255     d->extra->explicitMinSize = explMin;
4256     d->extra->explicitMaxSize = explMax;
4257 }
4258 
4259 
4260 /*!
4261     Translates the widget coordinate \a pos to the coordinate system
4262     of \a parent. The \a parent must not be 0 and must be a parent
4263     of the calling widget.
4264 
4265     \sa mapFrom(), mapToParent(), mapToGlobal(), underMouse()
4266 */
4267 
4268 QPoint QWidget::mapTo(const QWidget * parent, const QPoint & pos) const
4269 {
4270     QPoint p = pos;
4271     if (parent) {
4272         const QWidget * w = this;
4273         while (w != parent) {
4274             Q_ASSERT_X(w, "QWidget::mapTo(const QWidget *parent, const QPoint &pos)",
4275                        "parent must be in parent hierarchy");
4276             p = w->mapToParent(p);
4277             w = w->parentWidget();
4278         }
4279     }
4280     return p;
4281 }
4282 
4283 
4284 /*!
4285     Translates the widget coordinate \a pos from the coordinate system
4286     of \a parent to this widget's coordinate system. The \a parent
4287     must not be 0 and must be a parent of the calling widget.
4288 
4289     \sa mapTo(), mapFromParent(), mapFromGlobal(), underMouse()
4290 */
4291 
4292 QPoint QWidget::mapFrom(const QWidget * parent, const QPoint & pos) const
4293 {
4294     QPoint p(pos);
4295     if (parent) {
4296         const QWidget * w = this;
4297         while (w != parent) {
4298             Q_ASSERT_X(w, "QWidget::mapFrom(const QWidget *parent, const QPoint &pos)",
4299                        "parent must be in parent hierarchy");
4300 
4301             p = w->mapFromParent(p);
4302             w = w->parentWidget();
4303         }
4304     }
4305     return p;
4306 }
4307 
4308 
4309 /*!
4310     Translates the widget coordinate \a pos to a coordinate in the
4311     parent widget.
4312 
4313     Same as mapToGlobal() if the widget has no parent.
4314 
4315     \sa mapFromParent(), mapTo(), mapToGlobal(), underMouse()
4316 */
4317 
4318 QPoint QWidget::mapToParent(const QPoint &pos) const
4319 {
4320     return pos + data->crect.topLeft();
4321 }
4322 
4323 /*!
4324     Translates the parent widget coordinate \a pos to widget
4325     coordinates.
4326 
4327     Same as mapFromGlobal() if the widget has no parent.
4328 
4329     \sa mapToParent(), mapFrom(), mapFromGlobal(), underMouse()
4330 */
4331 
4332 QPoint QWidget::mapFromParent(const QPoint &pos) const
4333 {
4334     return pos - data->crect.topLeft();
4335 }
4336 
4337 
4338 /*!
4339     Returns the window for this widget, i.e. the next ancestor widget
4340     that has (or could have) a window-system frame.
4341 
4342     If the widget is a window, the widget itself is returned.
4343 
4344     Typical usage is changing the window title:
4345 
4346     \snippet code/src_gui_kernel_qwidget.cpp 3
4347 
4348     \sa isWindow()
4349 */
4350 
4351 QWidget *QWidget::window() const
4352 {
4353     QWidget *w = const_cast<QWidget *>(this);
4354     QWidget *p = w->parentWidget();
4355     while (!w->isWindow() && p) {
4356         w = p;
4357         p = p->parentWidget();
4358     }
4359     return w;
4360 }
4361 
4362 /*!
4363     \since 4.4
4364 
4365     Returns the native parent for this widget, i.e. the next ancestor widget
4366     that has a system identifier, or 0 if it does not have any native parent.
4367 
4368     \sa effectiveWinId()
4369 */
4370 QWidget *QWidget::nativeParentWidget() const
4371 {
4372     QWidget *parent = parentWidget();
4373     while (parent && !parent->internalWinId())
4374         parent = parent->parentWidget();
4375     return parent;
4376 }
4377 
4378 /*! \fn QWidget *QWidget::topLevelWidget() const
4379     \obsolete
4380 
4381     Use window() instead.
4382 */
4383 
4384 
4385 
4386 /*!
4387   Returns the background role of the widget.
4388 
4389   The background role defines the brush from the widget's \l palette that
4390   is used to render the background.
4391 
4392   If no explicit background role is set, the widget inherts its parent
4393   widget's background role.
4394 
4395   \sa setBackgroundRole(), foregroundRole()
4396  */
4397 QPalette::ColorRole QWidget::backgroundRole() const
4398 {
4399 
4400     const QWidget *w = this;
4401     do {
4402         QPalette::ColorRole role = w->d_func()->bg_role;
4403         if (role != QPalette::NoRole)
4404             return role;
4405         if (w->isWindow() || w->windowType() == Qt::SubWindow)
4406             break;
4407         w = w->parentWidget();
4408     } while (w);
4409     return QPalette::Window;
4410 }
4411 
4412 /*!
4413   Sets the background role of the widget to \a role.
4414 
4415   The background role defines the brush from the widget's \l palette that
4416   is used to render the background.
4417 
4418   If \a role is QPalette::NoRole, then the widget inherits its
4419   parent's background role.
4420 
4421   Note that styles are free to choose any color from the palette.
4422   You can modify the palette or set a style sheet if you don't
4423   achieve the result you want with setBackgroundRole().
4424 
4425   \sa backgroundRole(), foregroundRole()
4426  */
4427 
4428 void QWidget::setBackgroundRole(QPalette::ColorRole role)
4429 {
4430     Q_D(QWidget);
4431     d->bg_role = role;
4432     d->updateSystemBackground();
4433     d->propagatePaletteChange();
4434     d->updateIsOpaque();
4435 }
4436 
4437 /*!
4438   Returns the foreground role.
4439 
4440   The foreground role defines the color from the widget's \l palette that
4441   is used to draw the foreground.
4442 
4443   If no explicit foreground role is set, the function returns a role
4444   that contrasts with the background role.
4445 
4446   \sa setForegroundRole(), backgroundRole()
4447  */
4448 QPalette::ColorRole QWidget::foregroundRole() const
4449 {
4450     Q_D(const QWidget);
4451     QPalette::ColorRole rl = QPalette::ColorRole(d->fg_role);
4452     if (rl != QPalette::NoRole)
4453         return rl;
4454     QPalette::ColorRole role = QPalette::WindowText;
4455     switch (backgroundRole()) {
4456     case QPalette::Button:
4457         role = QPalette::ButtonText;
4458         break;
4459     case QPalette::Base:
4460         role = QPalette::Text;
4461         break;
4462     case QPalette::Dark:
4463     case QPalette::Shadow:
4464         role = QPalette::Light;
4465         break;
4466     case QPalette::Highlight:
4467         role = QPalette::HighlightedText;
4468         break;
4469     case QPalette::ToolTipBase:
4470         role = QPalette::ToolTipText;
4471         break;
4472     default:
4473         ;
4474     }
4475     return role;
4476 }
4477 
4478 /*!
4479   Sets the foreground role of the widget to \a role.
4480 
4481   The foreground role defines the color from the widget's \l palette that
4482   is used to draw the foreground.
4483 
4484   If \a role is QPalette::NoRole, the widget uses a foreground role
4485   that contrasts with the background role.
4486 
4487   Note that styles are free to choose any color from the palette.
4488   You can modify the palette or set a style sheet if you don't
4489   achieve the result you want with setForegroundRole().
4490 
4491   \sa foregroundRole(), backgroundRole()
4492  */
4493 void QWidget::setForegroundRole(QPalette::ColorRole role)
4494 {
4495     Q_D(QWidget);
4496     d->fg_role = role;
4497     d->updateSystemBackground();
4498     d->propagatePaletteChange();
4499 }
4500 
4501 /*!
4502     \property QWidget::palette
4503     \brief the widget's palette
4504 
4505     This property describes the widget's palette. The palette is used by the
4506     widget's style when rendering standard components, and is available as a
4507     means to ensure that custom widgets can maintain consistency with the
4508     native platform's look and feel. It's common that different platforms, or
4509     different styles, have different palettes.
4510 
4511     When you assign a new palette to a widget, the color roles from this
4512     palette are combined with the widget's default palette to form the
4513     widget's final palette. The palette entry for the widget's background role
4514     is used to fill the widget's background (see QWidget::autoFillBackground),
4515     and the foreground role initializes QPainter's pen.
4516 
4517     The default depends on the system environment. QApplication maintains a
4518     system/theme palette which serves as a default for all widgets.  There may
4519     also be special palette defaults for certain types of widgets (e.g., on
4520     Windows Vista, all classes that derive from QMenuBar have a special
4521     default palette). You can also define default palettes for widgets
4522     yourself by passing a custom palette and the name of a widget to
4523     QApplication::setPalette(). Finally, the style always has the option of
4524     polishing the palette as it's assigned (see QStyle::polish()).
4525 
4526     QWidget propagates explicit palette roles from parent to child. If you
4527     assign a brush or color to a specific role on a palette and assign that
4528     palette to a widget, that role will propagate to all the widget's
4529     children, overriding any system defaults for that role. Note that palettes
4530     by default don't propagate to windows (see isWindow()) unless the
4531     Qt::WA_WindowPropagation attribute is enabled.
4532 
4533     QWidget's palette propagation is similar to its font propagation.
4534 
4535     The current style, which is used to render the content of all standard Qt
4536     widgets, is free to choose colors and brushes from the widget palette, or
4537     in some cases, to ignore the palette (partially, or completely). In
4538     particular, certain styles like GTK style, Mac style, and Windows Vista
4539     style, depend on third party APIs to render the content of widgets,
4540     and these styles typically do not follow the palette. Because of this,
4541     assigning roles to a widget's palette is not guaranteed to change the
4542     appearance of the widget. Instead, you may choose to apply a \l
4543     styleSheet. You can refer to our Knowledge Base article
4544     \l{http://qt.nokia.com/developer/knowledgebase/22}{here} for more
4545     information.
4546 
4547     \warning Do not use this function in conjunction with \l{Qt Style Sheets}.
4548     When using style sheets, the palette of a widget can be customized using
4549     the "color", "background-color", "selection-color",
4550     "selection-background-color" and "alternate-background-color".
4551 
4552     \sa QApplication::palette(), QWidget::font()
4553 */
4554 const QPalette &QWidget::palette() const
4555 {
4556     if (!isEnabled()) {
4557         data->pal.setCurrentColorGroup(QPalette::Disabled);
4558     } else if ((!isVisible() || isActiveWindow())
4559 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
4560         && !QApplicationPrivate::isBlockedByModal(const_cast<QWidget *>(this))
4561 #endif
4562         ) {
4563         data->pal.setCurrentColorGroup(QPalette::Active);
4564     } else {
4565 #if 0 // Used to be included in Qt4 for Q_WS_MAC
4566         extern bool qt_mac_can_clickThrough(const QWidget *); //qwidget_mac.cpp
4567         if (qt_mac_can_clickThrough(this))
4568             data->pal.setCurrentColorGroup(QPalette::Active);
4569         else
4570 #endif
4571             data->pal.setCurrentColorGroup(QPalette::Inactive);
4572     }
4573     return data->pal;
4574 }
4575 
4576 void QWidget::setPalette(const QPalette &palette)
4577 {
4578     Q_D(QWidget);
4579     setAttribute(Qt::WA_SetPalette, palette.resolve() != 0);
4580 
4581     // Determine which palette is inherited from this widget's ancestors and
4582     // QApplication::palette, resolve this against \a palette (attributes from
4583     // the inherited palette are copied over this widget's palette). Then
4584     // propagate this palette to this widget's children.
4585     QPalette naturalPalette = d->naturalWidgetPalette(d->inheritedPaletteResolveMask);
4586     QPalette resolvedPalette = palette.resolve(naturalPalette);
4587     d->setPalette_helper(resolvedPalette);
4588 }
4589 
4590 /*!
4591     \internal
4592 
4593     Returns the palette that the widget \a w inherits from its ancestors and
4594     QApplication::palette. \a inheritedMask is the combination of the widget's
4595     ancestors palette request masks (i.e., which attributes from the parent
4596     widget's palette are implicitly imposed on this widget by the user). Note
4597     that this font does not take into account the palette set on \a w itself.
4598 */
4599 QPalette QWidgetPrivate::naturalWidgetPalette(uint inheritedMask) const
4600 {
4601     Q_Q(const QWidget);
4602 
4603     const bool useStyleSheetPropagationInWidgetStyles =
4604         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
4605 
4606     QPalette naturalPalette = QApplication::palette(q);
4607     if ((!q->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles)
4608         && (!q->isWindow() || q->testAttribute(Qt::WA_WindowPropagation)
4609 #if QT_CONFIG(graphicsview)
4610             || (extra && extra->proxyWidget)
4611 #endif // QT_CONFIG(graphicsview)
4612             )) {
4613         if (QWidget *p = q->parentWidget()) {
4614             if (!p->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles) {
4615                 if (!naturalPalette.isCopyOf(QApplication::palette())) {
4616                     QPalette inheritedPalette = p->palette();
4617                     inheritedPalette.resolve(inheritedMask);
4618                     naturalPalette = inheritedPalette.resolve(naturalPalette);
4619                 } else {
4620                     naturalPalette = p->palette();
4621                 }
4622             }
4623         }
4624 #if QT_CONFIG(graphicsview)
4625         else if (extra && extra->proxyWidget) {
4626             QPalette inheritedPalette = extra->proxyWidget->palette();
4627             inheritedPalette.resolve(inheritedMask);
4628             naturalPalette = inheritedPalette.resolve(naturalPalette);
4629         }
4630 #endif // QT_CONFIG(graphicsview)
4631     }
4632     naturalPalette.resolve(0);
4633     return naturalPalette;
4634 }
4635 /*!
4636     \internal
4637 
4638     Determine which palette is inherited from this widget's ancestors and
4639     QApplication::palette, resolve this against this widget's palette
4640     (attributes from the inherited palette are copied over this widget's
4641     palette). Then propagate this palette to this widget's children.
4642 */
4643 void QWidgetPrivate::resolvePalette()
4644 {
4645     QPalette naturalPalette = naturalWidgetPalette(inheritedPaletteResolveMask);
4646     QPalette resolvedPalette = data.pal.resolve(naturalPalette);
4647     setPalette_helper(resolvedPalette);
4648 }
4649 
4650 void QWidgetPrivate::setPalette_helper(const QPalette &palette)
4651 {
4652     Q_Q(QWidget);
4653     if (data.pal == palette && data.pal.resolve() == palette.resolve())
4654         return;
4655     data.pal = palette;
4656     updateSystemBackground();
4657     propagatePaletteChange();
4658     updateIsOpaque();
4659     q->update();
4660     updateIsOpaque();
4661 }
4662 
4663 void QWidgetPrivate::updateSystemBackground()
4664 {
4665 }
4666 
4667 /*!
4668     \property QWidget::font
4669     \brief the font currently set for the widget
4670 
4671     This property describes the widget's requested font. The font is used by
4672     the widget's style when rendering standard components, and is available as
4673     a means to ensure that custom widgets can maintain consistency with the
4674     native platform's look and feel. It's common that different platforms, or
4675     different styles, define different fonts for an application.
4676 
4677     When you assign a new font to a widget, the properties from this font are
4678     combined with the widget's default font to form the widget's final
4679     font. You can call fontInfo() to get a copy of the widget's final
4680     font. The final font is also used to initialize QPainter's font.
4681 
4682     The default depends on the system environment. QApplication maintains a
4683     system/theme font which serves as a default for all widgets.  There may
4684     also be special font defaults for certain types of widgets. You can also
4685     define default fonts for widgets yourself by passing a custom font and the
4686     name of a widget to QApplication::setFont(). Finally, the font is matched
4687     against Qt's font database to find the best match.
4688 
4689     QWidget propagates explicit font properties from parent to child. If you
4690     change a specific property on a font and assign that font to a widget,
4691     that property will propagate to all the widget's children, overriding any
4692     system defaults for that property. Note that fonts by default don't
4693     propagate to windows (see isWindow()) unless the Qt::WA_WindowPropagation
4694     attribute is enabled.
4695 
4696     QWidget's font propagation is similar to its palette propagation.
4697 
4698     The current style, which is used to render the content of all standard Qt
4699     widgets, is free to choose to use the widget font, or in some cases, to
4700     ignore it (partially, or completely). In particular, certain styles like
4701     GTK style, Mac style, and Windows Vista style, apply special
4702     modifications to the widget font to match the platform's native look and
4703     feel. Because of this, assigning properties to a widget's font is not
4704     guaranteed to change the appearance of the widget. Instead, you may choose
4705     to apply a \l styleSheet.
4706 
4707     \note If \l{Qt Style Sheets} are used on the same widget as setFont(),
4708     style sheets will take precedence if the settings conflict.
4709 
4710     \sa fontInfo(), fontMetrics()
4711 */
4712 
4713 void QWidget::setFont(const QFont &font)
4714 {
4715     Q_D(QWidget);
4716 
4717 #ifndef QT_NO_STYLE_STYLESHEET
4718     const QStyleSheetStyle* style;
4719     if (d->extra && (style = qobject_cast<const QStyleSheetStyle*>(d->extra->style))) {
4720         style->saveWidgetFont(this, font);
4721     }
4722 #endif
4723 
4724     setAttribute(Qt::WA_SetFont, font.resolve() != 0);
4725 
4726     // Determine which font is inherited from this widget's ancestors and
4727     // QApplication::font, resolve this against \a font (attributes from the
4728     // inherited font are copied over). Then propagate this font to this
4729     // widget's children.
4730     QFont naturalFont = d->naturalWidgetFont(d->inheritedFontResolveMask);
4731     QFont resolvedFont = font.resolve(naturalFont);
4732     d->setFont_helper(resolvedFont);
4733 }
4734 
4735 /*
4736     \internal
4737 
4738     Returns the font that the widget \a w inherits from its ancestors and
4739     QApplication::font. \a inheritedMask is the combination of the widget's
4740     ancestors font request masks (i.e., which attributes from the parent
4741     widget's font are implicitly imposed on this widget by the user). Note
4742     that this font does not take into account the font set on \a w itself.
4743 
4744     ### Stylesheet has a different font propagation mechanism. When a stylesheet
4745         is applied, fonts are not propagated anymore
4746 */
4747 QFont QWidgetPrivate::naturalWidgetFont(uint inheritedMask) const
4748 {
4749     Q_Q(const QWidget);
4750 
4751     const bool useStyleSheetPropagationInWidgetStyles =
4752         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
4753 
4754     QFont naturalFont = QApplication::font(q);
4755     if ((!q->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles)
4756         && (!q->isWindow() || q->testAttribute(Qt::WA_WindowPropagation)
4757 #if QT_CONFIG(graphicsview)
4758             || (extra && extra->proxyWidget)
4759 #endif // QT_CONFIG(graphicsview)
4760             )) {
4761         if (QWidget *p = q->parentWidget()) {
4762             if (!p->testAttribute(Qt::WA_StyleSheet) || useStyleSheetPropagationInWidgetStyles) {
4763                 if (!naturalFont.isCopyOf(QApplication::font())) {
4764                     if (inheritedMask != 0) {
4765                         QFont inheritedFont = p->font();
4766                         inheritedFont.resolve(inheritedMask);
4767                         naturalFont = inheritedFont.resolve(naturalFont);
4768                     } // else nothing to do (naturalFont = naturalFont)
4769                 } else {
4770                     naturalFont = p->font();
4771                 }
4772             }
4773         }
4774 #if QT_CONFIG(graphicsview)
4775         else if (extra && extra->proxyWidget) {
4776             if (inheritedMask != 0) {
4777                 QFont inheritedFont = extra->proxyWidget->font();
4778                 inheritedFont.resolve(inheritedMask);
4779                 naturalFont = inheritedFont.resolve(naturalFont);
4780             } // else nothing to do (naturalFont = naturalFont)
4781         }
4782 #endif // QT_CONFIG(graphicsview)
4783     }
4784     naturalFont.resolve(0);
4785     return naturalFont;
4786 }
4787 
4788 /*!
4789     \internal
4790 
4791     Determine which font is implicitly imposed on this widget by its ancestors
4792     and QApplication::font, resolve this against its own font (attributes from
4793     the implicit font are copied over). Then propagate this font to this
4794     widget's children.
4795 */
4796 void QWidgetPrivate::resolveFont()
4797 {
4798     QFont naturalFont = naturalWidgetFont(inheritedFontResolveMask);
4799     QFont resolvedFont = data.fnt.resolve(naturalFont);
4800     setFont_helper(resolvedFont);
4801 }
4802 
4803 /*!
4804     \internal
4805 
4806     Assign \a font to this widget, and propagate it to all children, except
4807     style sheet widgets (handled differently) and windows that don't enable
4808     window propagation.  \a implicitMask is the union of all ancestor widgets'
4809     font request masks, and determines which attributes from this widget's
4810     font should propagate.
4811 */
4812 void QWidgetPrivate::updateFont(const QFont &font)
4813 {
4814     Q_Q(QWidget);
4815 #ifndef QT_NO_STYLE_STYLESHEET
4816     const QStyleSheetStyle* cssStyle;
4817     cssStyle = extra ? qobject_cast<const QStyleSheetStyle*>(extra->style) : 0;
4818     const bool useStyleSheetPropagationInWidgetStyles =
4819         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
4820 #endif
4821 
4822     data.fnt = QFont(font, q);
4823 #if 0 // Used to be included in Qt4 for Q_WS_X11
4824     // make sure the font set on this widget is associated with the correct screen
4825     data.fnt.x11SetScreen(xinfo.screen());
4826 #endif
4827     // Combine new mask with natural mask and propagate to children.
4828 #if QT_CONFIG(graphicsview)
4829     if (!q->parentWidget() && extra && extra->proxyWidget) {
4830         QGraphicsProxyWidget *p = extra->proxyWidget;
4831         inheritedFontResolveMask = p->d_func()->inheritedFontResolveMask | p->font().resolve();
4832     } else
4833 #endif // QT_CONFIG(graphicsview)
4834     if (q->isWindow() && !q->testAttribute(Qt::WA_WindowPropagation)) {
4835         inheritedFontResolveMask = 0;
4836     }
4837     uint newMask = data.fnt.resolve() | inheritedFontResolveMask;
4838 
4839     for (int i = 0; i < children.size(); ++i) {
4840         QWidget *w = qobject_cast<QWidget*>(children.at(i));
4841         if (w) {
4842             if (0) {
4843 #ifndef QT_NO_STYLE_STYLESHEET
4844             } else if (!useStyleSheetPropagationInWidgetStyles && w->testAttribute(Qt::WA_StyleSheet)) {
4845                 // Style sheets follow a different font propagation scheme.
4846                 if (cssStyle)
4847                     cssStyle->updateStyleSheetFont(w);
4848 #endif
4849             } else if ((!w->isWindow() || w->testAttribute(Qt::WA_WindowPropagation))) {
4850                 // Propagate font changes.
4851                 QWidgetPrivate *wd = w->d_func();
4852                 wd->inheritedFontResolveMask = newMask;
4853                 wd->resolveFont();
4854             }
4855         }
4856     }
4857 
4858 #ifndef QT_NO_STYLE_STYLESHEET
4859     if (!useStyleSheetPropagationInWidgetStyles && cssStyle) {
4860         cssStyle->updateStyleSheetFont(q);
4861     }
4862 #endif
4863 
4864     QEvent e(QEvent::FontChange);
4865     QApplication::sendEvent(q, &e);
4866 }
4867 
4868 void QWidgetPrivate::setLayoutDirection_helper(Qt::LayoutDirection direction)
4869 {
4870     Q_Q(QWidget);
4871 
4872     if ( (direction == Qt::RightToLeft) == q->testAttribute(Qt::WA_RightToLeft))
4873         return;
4874     q->setAttribute(Qt::WA_RightToLeft, (direction == Qt::RightToLeft));
4875     if (!children.isEmpty()) {
4876         for (int i = 0; i < children.size(); ++i) {
4877             QWidget *w = qobject_cast<QWidget*>(children.at(i));
4878             if (w && !w->isWindow() && !w->testAttribute(Qt::WA_SetLayoutDirection))
4879                 w->d_func()->setLayoutDirection_helper(direction);
4880         }
4881     }
4882     QEvent e(QEvent::LayoutDirectionChange);
4883     QApplication::sendEvent(q, &e);
4884 }
4885 
4886 void QWidgetPrivate::resolveLayoutDirection()
4887 {
4888     Q_Q(const QWidget);
4889     if (!q->testAttribute(Qt::WA_SetLayoutDirection))
4890         setLayoutDirection_helper(q->isWindow() ? QApplication::layoutDirection() : q->parentWidget()->layoutDirection());
4891 }
4892 
4893 /*!
4894     \property QWidget::layoutDirection
4895 
4896     \brief the layout direction for this widget
4897 
4898     By default, this property is set to Qt::LeftToRight.
4899 
4900     When the layout direction is set on a widget, it will propagate to
4901     the widget's children, but not to a child that is a window and not
4902     to a child for which setLayoutDirection() has been explicitly
4903     called. Also, child widgets added \e after setLayoutDirection()
4904     has been called for the parent do not inherit the parent's layout
4905     direction.
4906 
4907     This method no longer affects text layout direction since Qt 4.7.
4908 
4909     \sa QApplication::layoutDirection
4910 */
4911 void QWidget::setLayoutDirection(Qt::LayoutDirection direction)
4912 {
4913     Q_D(QWidget);
4914 
4915     if (direction == Qt::LayoutDirectionAuto) {
4916         unsetLayoutDirection();
4917         return;
4918     }
4919 
4920     setAttribute(Qt::WA_SetLayoutDirection);
4921     d->setLayoutDirection_helper(direction);
4922 }
4923 
4924 Qt::LayoutDirection QWidget::layoutDirection() const
4925 {
4926     return testAttribute(Qt::WA_RightToLeft) ? Qt::RightToLeft : Qt::LeftToRight;
4927 }
4928 
4929 void QWidget::unsetLayoutDirection()
4930 {
4931     Q_D(QWidget);
4932     setAttribute(Qt::WA_SetLayoutDirection, false);
4933     d->resolveLayoutDirection();
4934 }
4935 
4936 /*!
4937     \fn QFontMetrics QWidget::fontMetrics() const
4938 
4939     Returns the font metrics for the widget's current font.
4940     Equivalent to \c QFontMetrics(widget->font()).
4941 
4942     \sa font(), fontInfo(), setFont()
4943 */
4944 
4945 /*!
4946     \fn QFontInfo QWidget::fontInfo() const
4947 
4948     Returns the font info for the widget's current font.
4949     Equivalent to \c QFontInfo(widget->font()).
4950 
4951     \sa font(), fontMetrics(), setFont()
4952 */
4953 
4954 
4955 /*!
4956     \property QWidget::cursor
4957     \brief the cursor shape for this widget
4958 
4959     The mouse cursor will assume this shape when it's over this
4960     widget. See the \l{Qt::CursorShape}{list of predefined cursor objects} for a range of useful shapes.
4961 
4962     An editor widget might use an I-beam cursor:
4963     \snippet code/src_gui_kernel_qwidget.cpp 6
4964 
4965     If no cursor has been set, or after a call to unsetCursor(), the
4966     parent's cursor is used.
4967 
4968     By default, this property contains a cursor with the Qt::ArrowCursor
4969     shape.
4970 
4971     Some underlying window implementations will reset the cursor if it
4972     leaves a widget even if the mouse is grabbed. If you want to have
4973     a cursor set for all widgets, even when outside the window, consider
4974     QApplication::setOverrideCursor().
4975 
4976     \sa QApplication::setOverrideCursor()
4977 */
4978 
4979 #ifndef QT_NO_CURSOR
4980 QCursor QWidget::cursor() const
4981 {
4982     Q_D(const QWidget);
4983     if (testAttribute(Qt::WA_SetCursor))
4984         return (d->extra && d->extra->curs)
4985             ? *d->extra->curs
4986             : QCursor(Qt::ArrowCursor);
4987     if (isWindow() || !parentWidget())
4988         return QCursor(Qt::ArrowCursor);
4989     return parentWidget()->cursor();
4990 }
4991 
4992 void QWidget::setCursor(const QCursor &cursor)
4993 {
4994     Q_D(QWidget);
4995 // On Mac we must set the cursor even if it is the ArrowCursor.
4996 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
4997     if (cursor.shape() != Qt::ArrowCursor
4998         || (d->extra && d->extra->curs))
4999 #endif
5000     {
5001         d->createExtra();
5002         QCursor *newCursor = new QCursor(cursor);
5003         delete d->extra->curs;
5004         d->extra->curs = newCursor;
5005     }
5006     setAttribute(Qt::WA_SetCursor);
5007     d->setCursor_sys(cursor);
5008 
5009     QEvent event(QEvent::CursorChange);
5010     QApplication::sendEvent(this, &event);
5011 }
5012 
5013 void QWidgetPrivate::setCursor_sys(const QCursor &cursor)
5014 {
5015     Q_UNUSED(cursor);
5016     Q_Q(QWidget);
5017     qt_qpa_set_cursor(q, false);
5018 }
5019 
5020 void QWidget::unsetCursor()
5021 {
5022     Q_D(QWidget);
5023     if (d->extra) {
5024         delete d->extra->curs;
5025         d->extra->curs = 0;
5026     }
5027     if (!isWindow())
5028         setAttribute(Qt::WA_SetCursor, false);
5029     d->unsetCursor_sys();
5030 
5031     QEvent event(QEvent::CursorChange);
5032     QApplication::sendEvent(this, &event);
5033 }
5034 
5035 void QWidgetPrivate::unsetCursor_sys()
5036 {
5037     Q_Q(QWidget);
5038     qt_qpa_set_cursor(q, false);
5039 }
5040 
5041 static inline void applyCursor(QWidget *w, const QCursor &c)
5042 {
5043     if (QWindow *window = w->windowHandle())
5044         window->setCursor(c);
5045 }
5046 
5047 static inline void unsetCursor(QWidget *w)
5048 {
5049     if (QWindow *window = w->windowHandle())
5050         window->unsetCursor();
5051 }
5052 
5053 void qt_qpa_set_cursor(QWidget *w, bool force)
5054 {
5055     if (!w->testAttribute(Qt::WA_WState_Created))
5056         return;
5057 
5058     static QPointer<QWidget> lastUnderMouse = 0;
5059     if (force) {
5060         lastUnderMouse = w;
5061     } else if (lastUnderMouse) {
5062         const WId lastWinId = lastUnderMouse->effectiveWinId();
5063         const WId winId = w->effectiveWinId();
5064         if (lastWinId && lastWinId == winId)
5065             w = lastUnderMouse;
5066     } else if (!w->internalWinId()) {
5067         return; // The mouse is not under this widget, and it's not native, so don't change it.
5068     }
5069 
5070     while (!w->internalWinId() && w->parentWidget() && !w->isWindow()
5071            && !w->testAttribute(Qt::WA_SetCursor))
5072         w = w->parentWidget();
5073 
5074     QWidget *nativeParent = w;
5075     if (!w->internalWinId())
5076         nativeParent = w->nativeParentWidget();
5077     if (!nativeParent || !nativeParent->internalWinId())
5078         return;
5079 
5080     if (w->isWindow() || w->testAttribute(Qt::WA_SetCursor)) {
5081         if (w->isEnabled())
5082             applyCursor(nativeParent, w->cursor());
5083         else
5084             // Enforce the windows behavior of clearing the cursor on
5085             // disabled widgets.
5086             unsetCursor(nativeParent);
5087     } else {
5088         unsetCursor(nativeParent);
5089     }
5090 }
5091 #endif
5092 
5093 /*!
5094     \enum QWidget::RenderFlag
5095 
5096     This enum describes how to render the widget when calling QWidget::render().
5097 
5098     \value DrawWindowBackground If you enable this option, the widget's background
5099     is rendered into the target even if autoFillBackground is not set. By default,
5100     this option is enabled.
5101 
5102     \value DrawChildren If you enable this option, the widget's children
5103     are rendered recursively into the target. By default, this option is enabled.
5104 
5105     \value IgnoreMask If you enable this option, the widget's QWidget::mask()
5106     is ignored when rendering into the target. By default, this option is disabled.
5107 
5108     \since 4.3
5109 */
5110 
5111 /*!
5112     \since 4.3
5113 
5114     Renders the \a sourceRegion of this widget into the \a target
5115     using \a renderFlags to determine how to render. Rendering
5116     starts at \a targetOffset in the \a target. For example:
5117 
5118     \snippet code/src_gui_kernel_qwidget.cpp 7
5119 
5120     If \a sourceRegion is a null region, this function will use QWidget::rect() as
5121     the region, i.e. the entire widget.
5122 
5123     Ensure that you call QPainter::end() for the \a target device's
5124     active painter (if any) before rendering. For example:
5125 
5126     \snippet code/src_gui_kernel_qwidget.cpp 8
5127 
5128     \note To obtain the contents of a QOpenGLWidget, use QOpenGLWidget::grabFramebuffer()
5129     instead.
5130 
5131     \note To obtain the contents of a QGLWidget (deprecated), use
5132     QGLWidget::grabFrameBuffer() or QGLWidget::renderPixmap() instead.
5133 */
5134 void QWidget::render(QPaintDevice *target, const QPoint &targetOffset,
5135                      const QRegion &sourceRegion, RenderFlags renderFlags)
5136 {
5137     QPainter p(target);
5138     render(&p, targetOffset, sourceRegion, renderFlags);
5139 }
5140 
5141 /*!
5142     \overload
5143 
5144     Renders the widget into the \a painter's QPainter::device().
5145 
5146     Transformations and settings applied to the \a painter will be used
5147     when rendering.
5148 
5149     \note The \a painter must be active. On \macos the widget will be
5150     rendered into a QPixmap and then drawn by the \a painter.
5151 
5152     \sa QPainter::device()
5153 */
5154 void QWidget::render(QPainter *painter, const QPoint &targetOffset,
5155                      const QRegion &sourceRegion, RenderFlags renderFlags)
5156 {
5157     if (Q_UNLIKELY(!painter)) {
5158         qWarning("QWidget::render: Null pointer to painter");
5159         return;
5160     }
5161 
5162     if (Q_UNLIKELY(!painter->isActive())) {
5163         qWarning("QWidget::render: Cannot render with an inactive painter");
5164         return;
5165     }
5166 
5167     const qreal opacity = painter->opacity();
5168     if (qFuzzyIsNull(opacity))
5169         return; // Fully transparent.
5170 
5171     Q_D(QWidget);
5172     const bool inRenderWithPainter = d->extra && d->extra->inRenderWithPainter;
5173     const QRegion toBePainted = !inRenderWithPainter ? d->prepareToRender(sourceRegion, renderFlags)
5174                                                      : sourceRegion;
5175     if (toBePainted.isEmpty())
5176         return;
5177 
5178     if (!d->extra)
5179         d->createExtra();
5180     d->extra->inRenderWithPainter = true;
5181 
5182     QPaintEngine *engine = painter->paintEngine();
5183     Q_ASSERT(engine);
5184     QPaintEnginePrivate *enginePriv = engine->d_func();
5185     Q_ASSERT(enginePriv);
5186     QPaintDevice *target = engine->paintDevice();
5187     Q_ASSERT(target);
5188 
5189     // Render via a pixmap when dealing with non-opaque painters or printers.
5190     if (!inRenderWithPainter && (opacity < 1.0 || (target->devType() == QInternal::Printer))) {
5191         d->render_helper(painter, targetOffset, toBePainted, renderFlags);
5192         d->extra->inRenderWithPainter = inRenderWithPainter;
5193         return;
5194     }
5195 
5196     // Set new shared painter.
5197     QPainter *oldPainter = d->sharedPainter();
5198     d->setSharedPainter(painter);
5199 
5200     // Save current system clip, viewport and transform,
5201     const QTransform oldTransform = enginePriv->systemTransform;
5202     const QRegion oldSystemClip = enginePriv->systemClip;
5203     const QRegion oldBaseClip = enginePriv->baseSystemClip;
5204     const QRegion oldSystemViewport = enginePriv->systemViewport;
5205 
5206     // This ensures that all painting triggered by render() is clipped to the current engine clip.
5207     if (painter->hasClipping()) {
5208         const QRegion painterClip = painter->deviceTransform().map(painter->clipRegion());
5209         enginePriv->setSystemViewport(oldSystemClip.isEmpty() ? painterClip : oldSystemClip & painterClip);
5210     } else {
5211         enginePriv->setSystemViewport(oldSystemClip);
5212     }
5213 
5214     d->render(target, targetOffset, toBePainted, renderFlags);
5215 
5216     // Restore system clip, viewport and transform.
5217     enginePriv->baseSystemClip = oldBaseClip;
5218     enginePriv->setSystemTransformAndViewport(oldTransform, oldSystemViewport);
5219     enginePriv->systemStateChanged();
5220 
5221     // Restore shared painter.
5222     d->setSharedPainter(oldPainter);
5223 
5224     d->extra->inRenderWithPainter = inRenderWithPainter;
5225 }
5226 
5227 static void sendResizeEvents(QWidget *target)
5228 {
5229     QResizeEvent e(target->size(), QSize());
5230     QApplication::sendEvent(target, &e);
5231 
5232     const QObjectList children = target->children();
5233     for (int i = 0; i < children.size(); ++i) {
5234         if (!children.at(i)->isWidgetType())
5235             continue;
5236         QWidget *child = static_cast<QWidget*>(children.at(i));
5237         if (!child->isWindow() && child->testAttribute(Qt::WA_PendingResizeEvent))
5238             sendResizeEvents(child);
5239     }
5240 }
5241 
5242 /*!
5243     \since 5.0
5244 
5245     Renders the widget into a pixmap restricted by the
5246     given \a rectangle. If the widget has any children, then
5247     they are also painted in the appropriate positions.
5248 
5249     If a rectangle with an invalid size is specified  (the default),
5250     the entire widget is painted.
5251 
5252     \sa render(), QPixmap
5253 */
5254 QPixmap QWidget::grab(const QRect &rectangle)
5255 {
5256     Q_D(QWidget);
5257     if (testAttribute(Qt::WA_PendingResizeEvent) || !testAttribute(Qt::WA_WState_Created))
5258         sendResizeEvents(this);
5259 
5260     const QWidget::RenderFlags renderFlags = QWidget::DrawWindowBackground | QWidget::DrawChildren | QWidget::IgnoreMask;
5261 
5262     const bool oldDirtyOpaqueChildren =  d->dirtyOpaqueChildren;
5263     QRect r(rectangle);
5264     if (r.width() < 0 || r.height() < 0) {
5265         // For grabbing widgets that haven't been shown yet,
5266         // we trigger the layouting mechanism to determine the widget's size.
5267         r = d->prepareToRender(QRegion(), renderFlags).boundingRect();
5268         r.setTopLeft(rectangle.topLeft());
5269     }
5270 
5271     if (!r.intersects(rect()))
5272         return QPixmap();
5273 
5274     const qreal dpr = devicePixelRatioF();
5275     QPixmap res((QSizeF(r.size()) * dpr).toSize());
5276     res.setDevicePixelRatio(dpr);
5277     if (!d->isOpaque)
5278         res.fill(Qt::transparent);
5279     d->render(&res, QPoint(), QRegion(r), renderFlags);
5280 
5281     d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
5282     return res;
5283 }
5284 
5285 /*!
5286     \brief The graphicsEffect function returns a pointer to the
5287     widget's graphics effect.
5288 
5289     If the widget has no graphics effect, 0 is returned.
5290 
5291     \since 4.6
5292 
5293     \sa setGraphicsEffect()
5294 */
5295 #if QT_CONFIG(graphicseffect)
5296 QGraphicsEffect *QWidget::graphicsEffect() const
5297 {
5298     Q_D(const QWidget);
5299     return d->graphicsEffect;
5300 }
5301 #endif // QT_CONFIG(graphicseffect)
5302 
5303 /*!
5304 
5305   \brief The setGraphicsEffect function is for setting the widget's graphics effect.
5306 
5307     Sets \a effect as the widget's effect. If there already is an effect installed
5308     on this widget, QWidget will delete the existing effect before installing
5309     the new \a effect.
5310 
5311     If \a effect is the installed effect on a different widget, setGraphicsEffect() will remove
5312     the effect from the widget and install it on this widget.
5313 
5314     QWidget takes ownership of \a effect.
5315 
5316     \note This function will apply the effect on itself and all its children.
5317 
5318     \note Graphics effects are not supported for OpenGL-based widgets, such as QGLWidget,
5319     QOpenGLWidget and QQuickWidget.
5320 
5321     \since 4.6
5322 
5323     \sa graphicsEffect()
5324 */
5325 #if QT_CONFIG(graphicseffect)
5326 void QWidget::setGraphicsEffect(QGraphicsEffect *effect)
5327 {
5328     Q_D(QWidget);
5329     if (d->graphicsEffect == effect)
5330         return;
5331 
5332     if (d->graphicsEffect) {
5333         d->invalidateBuffer(rect());
5334         delete d->graphicsEffect;
5335         d->graphicsEffect = 0;
5336     }
5337 
5338     if (effect) {
5339         // Set new effect.
5340         QGraphicsEffectSourcePrivate *sourced = new QWidgetEffectSourcePrivate(this);
5341         QGraphicsEffectSource *source = new QGraphicsEffectSource(*sourced);
5342         d->graphicsEffect = effect;
5343         effect->d_func()->setGraphicsEffectSource(source);
5344         update();
5345     }
5346 
5347     d->updateIsOpaque();
5348 }
5349 #endif // QT_CONFIG(graphicseffect)
5350 
5351 bool QWidgetPrivate::isAboutToShow() const
5352 {
5353     if (data.in_show)
5354         return true;
5355 
5356     Q_Q(const QWidget);
5357     if (q->isHidden())
5358         return false;
5359 
5360     // The widget will be shown if any of its ancestors are about to show.
5361     QWidget *parent = q->parentWidget();
5362     return parent ? parent->d_func()->isAboutToShow() : false;
5363 }
5364 
5365 QRegion QWidgetPrivate::prepareToRender(const QRegion &region, QWidget::RenderFlags renderFlags)
5366 {
5367     Q_Q(QWidget);
5368     const bool isVisible = q->isVisible();
5369 
5370     // Make sure the widget is laid out correctly.
5371     if (!isVisible && !isAboutToShow()) {
5372         QWidget *topLevel = q->window();
5373         (void)topLevel->d_func()->topData(); // Make sure we at least have top-data.
5374         topLevel->ensurePolished();
5375 
5376         // Invalidate the layout of hidden ancestors (incl. myself) and pretend
5377         // they're not explicitly hidden.
5378         QWidget *widget = q;
5379         QWidgetList hiddenWidgets;
5380         while (widget) {
5381             if (widget->isHidden()) {
5382                 widget->setAttribute(Qt::WA_WState_Hidden, false);
5383                 hiddenWidgets.append(widget);
5384                 if (!widget->isWindow() && widget->parentWidget()->d_func()->layout)
5385                     widget->d_func()->updateGeometry_helper(true);
5386             }
5387             widget = widget->parentWidget();
5388         }
5389 
5390         // Activate top-level layout.
5391         if (topLevel->d_func()->layout)
5392             topLevel->d_func()->layout->activate();
5393 
5394         // Adjust size if necessary.
5395         QTLWExtra *topLevelExtra = topLevel->d_func()->maybeTopData();
5396         if (topLevelExtra && !topLevelExtra->sizeAdjusted
5397             && !topLevel->testAttribute(Qt::WA_Resized)) {
5398             topLevel->adjustSize();
5399             topLevel->setAttribute(Qt::WA_Resized, false);
5400         }
5401 
5402         // Activate child layouts.
5403         topLevel->d_func()->activateChildLayoutsRecursively();
5404 
5405         // We're not cheating with WA_WState_Hidden anymore.
5406         for (int i = 0; i < hiddenWidgets.size(); ++i) {
5407             QWidget *widget = hiddenWidgets.at(i);
5408             widget->setAttribute(Qt::WA_WState_Hidden);
5409             if (!widget->isWindow() && widget->parentWidget()->d_func()->layout)
5410                 widget->parentWidget()->d_func()->layout->invalidate();
5411         }
5412     } else if (isVisible) {
5413         q->window()->d_func()->sendPendingMoveAndResizeEvents(true, true);
5414     }
5415 
5416     // Calculate the region to be painted.
5417     QRegion toBePainted = !region.isEmpty() ? region : QRegion(q->rect());
5418     if (!(renderFlags & QWidget::IgnoreMask) && extra && extra->hasMask)
5419         toBePainted &= extra->mask;
5420     return toBePainted;
5421 }
5422 
5423 void QWidgetPrivate::render_helper(QPainter *painter, const QPoint &targetOffset, const QRegion &toBePainted,
5424                                    QWidget::RenderFlags renderFlags)
5425 {
5426     Q_ASSERT(painter);
5427     Q_ASSERT(!toBePainted.isEmpty());
5428 
5429     Q_Q(QWidget);
5430 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
5431     const QTransform originalTransform = painter->worldTransform();
5432     const bool useDeviceCoordinates = originalTransform.isScaling();
5433     if (!useDeviceCoordinates) {
5434 #endif
5435         // Render via a pixmap.
5436         const QRect rect = toBePainted.boundingRect();
5437         const QSize size = rect.size();
5438         if (size.isNull())
5439             return;
5440 
5441         const qreal pixmapDevicePixelRatio = painter->device()->devicePixelRatioF();
5442         QPixmap pixmap(size * pixmapDevicePixelRatio);
5443         pixmap.setDevicePixelRatio(pixmapDevicePixelRatio);
5444 
5445         if (!(renderFlags & QWidget::DrawWindowBackground) || !isOpaque)
5446             pixmap.fill(Qt::transparent);
5447         q->render(&pixmap, QPoint(), toBePainted, renderFlags);
5448 
5449         const bool restore = !(painter->renderHints() & QPainter::SmoothPixmapTransform);
5450         painter->setRenderHints(QPainter::SmoothPixmapTransform, true);
5451 
5452         painter->drawPixmap(targetOffset, pixmap);
5453 
5454         if (restore)
5455             painter->setRenderHints(QPainter::SmoothPixmapTransform, false);
5456 
5457 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
5458     } else {
5459         // Render via a pixmap in device coordinates (to avoid pixmap scaling).
5460         QTransform transform = originalTransform;
5461         transform.translate(targetOffset.x(), targetOffset.y());
5462 
5463         QPaintDevice *device = painter->device();
5464         Q_ASSERT(device);
5465 
5466         // Calculate device rect.
5467         const QRectF rect(toBePainted.boundingRect());
5468         QRect deviceRect = transform.mapRect(QRectF(0, 0, rect.width(), rect.height())).toAlignedRect();
5469         deviceRect &= QRect(0, 0, device->width(), device->height());
5470 
5471         QPixmap pixmap(deviceRect.size());
5472         pixmap.fill(Qt::transparent);
5473 
5474         // Create a pixmap device coordinate painter.
5475         QPainter pixmapPainter(&pixmap);
5476         pixmapPainter.setRenderHints(painter->renderHints());
5477         transform *= QTransform::fromTranslate(-deviceRect.x(), -deviceRect.y());
5478         pixmapPainter.setTransform(transform);
5479 
5480         q->render(&pixmapPainter, QPoint(), toBePainted, renderFlags);
5481         pixmapPainter.end();
5482 
5483         // And then draw the pixmap.
5484         painter->setTransform(QTransform());
5485         painter->drawPixmap(deviceRect.topLeft(), pixmap);
5486         painter->setTransform(originalTransform);
5487     }
5488 #endif
5489 }
5490 
5491 void QWidgetPrivate::drawWidget(QPaintDevice *pdev, const QRegion &rgn, const QPoint &offset, int flags,
5492                                 QPainter *sharedPainter, QWidgetBackingStore *backingStore)
5493 {
5494     if (rgn.isEmpty())
5495         return;
5496 
5497     const bool asRoot = flags & DrawAsRoot;
5498     bool onScreen = paintOnScreen();
5499 
5500     Q_Q(QWidget);
5501 #if QT_CONFIG(graphicseffect)
5502     if (graphicsEffect && graphicsEffect->isEnabled()) {
5503         QGraphicsEffectSource *source = graphicsEffect->d_func()->source;
5504         QWidgetEffectSourcePrivate *sourced = static_cast<QWidgetEffectSourcePrivate *>
5505                                                          (source->d_func());
5506         if (!sourced->context) {
5507             QWidgetPaintContext context(pdev, rgn, offset, flags, sharedPainter, backingStore);
5508             sourced->context = &context;
5509             if (!sharedPainter) {
5510                 setSystemClip(pdev->paintEngine(), pdev->devicePixelRatioF(), rgn.translated(offset));
5511                 QPainter p(pdev);
5512                 p.translate(offset);
5513                 context.painter = &p;
5514                 graphicsEffect->draw(&p);
5515                 setSystemClip(pdev->paintEngine(), 1, QRegion());
5516             } else {
5517                 context.painter = sharedPainter;
5518                 if (sharedPainter->worldTransform() != sourced->lastEffectTransform) {
5519                     sourced->invalidateCache();
5520                     sourced->lastEffectTransform = sharedPainter->worldTransform();
5521                 }
5522                 sharedPainter->save();
5523                 sharedPainter->translate(offset);
5524                 setSystemClip(sharedPainter->paintEngine(), sharedPainter->device()->devicePixelRatioF(), rgn.translated(offset));
5525                 graphicsEffect->draw(sharedPainter);
5526                 setSystemClip(sharedPainter->paintEngine(), 1, QRegion());
5527                 sharedPainter->restore();
5528             }
5529             sourced->context = 0;
5530 
5531             // Native widgets need to be marked dirty on screen so painting will be done in correct context
5532             // Same check as in the no effects case below.
5533             if (backingStore && !onScreen && !asRoot && (q->internalWinId() || !q->nativeParentWidget()->isWindow()))
5534                 backingStore->markDirtyOnScreen(rgn, q, offset);
5535 
5536             return;
5537         }
5538     }
5539 #endif // QT_CONFIG(graphicseffect)
5540 
5541     const bool alsoOnScreen = flags & DrawPaintOnScreen;
5542     const bool recursive = flags & DrawRecursive;
5543     const bool alsoInvisible = flags & DrawInvisible;
5544 
5545     Q_ASSERT(sharedPainter ? sharedPainter->isActive() : true);
5546 
5547     QRegion toBePainted(rgn);
5548     if (asRoot && !alsoInvisible)
5549         toBePainted &= clipRect(); //(rgn & visibleRegion());
5550     if (!(flags & DontSubtractOpaqueChildren))
5551         subtractOpaqueChildren(toBePainted, q->rect());
5552 
5553     if (!toBePainted.isEmpty()) {
5554         if (!onScreen || alsoOnScreen) {
5555             //update the "in paint event" flag
5556             if (Q_UNLIKELY(q->testAttribute(Qt::WA_WState_InPaintEvent)))
5557                 qWarning("QWidget::repaint: Recursive repaint detected");
5558             q->setAttribute(Qt::WA_WState_InPaintEvent);
5559 
5560             //clip away the new area
5561 #ifndef QT_NO_PAINT_DEBUG
5562             bool flushed = QWidgetBackingStore::flushPaint(q, toBePainted);
5563 #endif
5564             QPaintEngine *paintEngine = pdev->paintEngine();
5565             if (paintEngine) {
5566                 setRedirected(pdev, -offset);
5567 
5568 #if 0 // Used to be included in Qt4 for Q_WS_MAC
5569                 // (Alien support) Special case for Mac when redirecting: If the paint device
5570                 // is of the Widget type we need to set WA_WState_InPaintEvent since painting
5571                 // outside the paint event is not supported on QWidgets. The attributeis
5572                 // restored further down.
5573                 if (pdev->devType() == QInternal::Widget)
5574                     static_cast<QWidget *>(pdev)->setAttribute(Qt::WA_WState_InPaintEvent);
5575 
5576 #endif
5577                 if (sharedPainter)
5578                     setSystemClip(pdev->paintEngine(), pdev->devicePixelRatioF(), toBePainted);
5579                 else
5580                     paintEngine->d_func()->systemRect = q->data->crect;
5581 
5582                 //paint the background
5583                 if ((asRoot || q->autoFillBackground() || onScreen || q->testAttribute(Qt::WA_StyledBackground))
5584                     && !q->testAttribute(Qt::WA_OpaquePaintEvent) && !q->testAttribute(Qt::WA_NoSystemBackground)) {
5585 #ifndef QT_NO_OPENGL
5586                     beginBackingStorePainting();
5587 #endif
5588                     QPainter p(q);
5589                     paintBackground(&p, toBePainted, (asRoot || onScreen) ? flags | DrawAsRoot : 0);
5590 #ifndef QT_NO_OPENGL
5591                     endBackingStorePainting();
5592 #endif
5593                 }
5594 
5595                 if (!sharedPainter)
5596                     setSystemClip(pdev->paintEngine(), pdev->devicePixelRatioF(), toBePainted.translated(offset));
5597 
5598                 if (!onScreen && !asRoot && !isOpaque && q->testAttribute(Qt::WA_TintedBackground)) {
5599 #ifndef QT_NO_OPENGL
5600                     beginBackingStorePainting();
5601 #endif
5602                     QPainter p(q);
5603                     QColor tint = q->palette().window().color();
5604                     tint.setAlphaF(qreal(.6));
5605                     p.fillRect(toBePainted.boundingRect(), tint);
5606 #ifndef QT_NO_OPENGL
5607                     endBackingStorePainting();
5608 #endif
5609                 }
5610             }
5611 
5612 #if 0
5613             qDebug() << "painting" << q << "opaque ==" << isOpaque();
5614             qDebug() << "clipping to" << toBePainted << "location == " << offset
5615                      << "geometry ==" << QRect(q->mapTo(q->window(), QPoint(0, 0)), q->size());
5616 #endif
5617 
5618             bool skipPaintEvent = false;
5619 #ifndef QT_NO_OPENGL
5620             if (renderToTexture) {
5621                 // This widget renders into a texture which is composed later. We just need to
5622                 // punch a hole in the backingstore, so the texture will be visible.
5623                 if (!q->testAttribute(Qt::WA_AlwaysStackOnTop)) {
5624                     beginBackingStorePainting();
5625                     if (backingStore) {
5626                         QPainter p(q);
5627                         p.setCompositionMode(QPainter::CompositionMode_Source);
5628                         p.fillRect(q->rect(), Qt::transparent);
5629                     } else {
5630                         QImage img = grabFramebuffer();
5631                         QPainter p(q);
5632                         // We are not drawing to a backingstore: fall back to QImage
5633                         p.drawImage(q->rect(), img);
5634                         skipPaintEvent = true;
5635                     }
5636                     endBackingStorePainting();
5637                 }
5638                 if (renderToTextureReallyDirty)
5639                     renderToTextureReallyDirty = 0;
5640                 else
5641                     skipPaintEvent = true;
5642             }
5643 #endif // QT_NO_OPENGL
5644 
5645             if (!skipPaintEvent) {
5646                 //actually send the paint event
5647                 sendPaintEvent(toBePainted);
5648             }
5649 
5650             // Native widgets need to be marked dirty on screen so painting will be done in correct context
5651             if (backingStore && !onScreen && !asRoot && (q->internalWinId() || (q->nativeParentWidget() && !q->nativeParentWidget()->isWindow())))
5652                 backingStore->markDirtyOnScreen(toBePainted, q, offset);
5653 
5654             //restore
5655             if (paintEngine) {
5656 #if 0 // Used to be included in Qt4 for Q_WS_MAC
5657                 if (pdev->devType() == QInternal::Widget)
5658                     static_cast<QWidget *>(pdev)->setAttribute(Qt::WA_WState_InPaintEvent, false);
5659 #endif
5660                 restoreRedirected();
5661                 if (!sharedPainter)
5662                     paintEngine->d_func()->systemRect = QRect();
5663                 else
5664                     paintEngine->d_func()->currentClipDevice = 0;
5665 
5666                 setSystemClip(pdev->paintEngine(), 1, QRegion());
5667             }
5668             q->setAttribute(Qt::WA_WState_InPaintEvent, false);
5669             if (Q_UNLIKELY(q->paintingActive()))
5670                 qWarning("QWidget::repaint: It is dangerous to leave painters active on a widget outside of the PaintEvent");
5671 
5672             if (paintEngine && paintEngine->autoDestruct()) {
5673                 delete paintEngine;
5674             }
5675 
5676 #ifndef QT_NO_PAINT_DEBUG
5677             if (flushed)
5678                 QWidgetBackingStore::unflushPaint(q, toBePainted);
5679 #endif
5680         } else if (q->isWindow()) {
5681             QPaintEngine *engine = pdev->paintEngine();
5682             if (engine) {
5683                 QPainter p(pdev);
5684                 p.setClipRegion(toBePainted);
5685                 const QBrush bg = q->palette().brush(QPalette::Window);
5686                 if (bg.style() == Qt::TexturePattern)
5687                     p.drawTiledPixmap(q->rect(), bg.texture());
5688                 else
5689                     p.fillRect(q->rect(), bg);
5690 
5691                 if (engine->autoDestruct())
5692                     delete engine;
5693             }
5694         }
5695     }
5696 
5697     if (recursive && !children.isEmpty()) {
5698         paintSiblingsRecursive(pdev, children, children.size() - 1, rgn, offset, flags & ~DrawAsRoot
5699                                 , sharedPainter, backingStore);
5700     }
5701 }
5702 
5703 void QWidgetPrivate::sendPaintEvent(const QRegion &toBePainted)
5704 {
5705     Q_Q(QWidget);
5706     QPaintEvent e(toBePainted);
5707     QCoreApplication::sendSpontaneousEvent(q, &e);
5708 
5709 #ifndef QT_NO_OPENGL
5710     if (renderToTexture)
5711         resolveSamples();
5712 #endif // QT_NO_OPENGL
5713 }
5714 
5715 void QWidgetPrivate::render(QPaintDevice *target, const QPoint &targetOffset,
5716                             const QRegion &sourceRegion, QWidget::RenderFlags renderFlags)
5717 {
5718     if (Q_UNLIKELY(!target)) {
5719         qWarning("QWidget::render: null pointer to paint device");
5720         return;
5721     }
5722 
5723     const bool inRenderWithPainter = extra && extra->inRenderWithPainter;
5724     QRegion paintRegion = !inRenderWithPainter
5725                           ? prepareToRender(sourceRegion, renderFlags)
5726                           : sourceRegion;
5727     if (paintRegion.isEmpty())
5728         return;
5729 
5730 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
5731     QPainter *oldSharedPainter = inRenderWithPainter ? sharedPainter() : 0;
5732 
5733     // Use the target's shared painter if set (typically set when doing
5734     // "other->render(widget);" in the widget's paintEvent.
5735     if (target->devType() == QInternal::Widget) {
5736         QWidgetPrivate *targetPrivate = static_cast<QWidget *>(target)->d_func();
5737         if (targetPrivate->extra && targetPrivate->extra->inRenderWithPainter) {
5738             QPainter *targetPainter = targetPrivate->sharedPainter();
5739             if (targetPainter && targetPainter->isActive())
5740                 setSharedPainter(targetPainter);
5741         }
5742     }
5743 #endif
5744 
5745     // Use the target's redirected device if set and adjust offset and paint
5746     // region accordingly. This is typically the case when people call render
5747     // from the paintEvent.
5748     QPoint offset = targetOffset;
5749     offset -= paintRegion.boundingRect().topLeft();
5750     QPoint redirectionOffset;
5751     QPaintDevice *redirected = 0;
5752 
5753     if (target->devType() == QInternal::Widget)
5754         redirected = static_cast<QWidget *>(target)->d_func()->redirected(&redirectionOffset);
5755     if (!redirected)
5756         redirected = QPainter::redirected(target, &redirectionOffset);
5757 
5758     if (redirected) {
5759         target = redirected;
5760         offset -= redirectionOffset;
5761     }
5762 
5763     if (!inRenderWithPainter) { // Clip handled by shared painter (in qpainter.cpp).
5764         if (QPaintEngine *targetEngine = target->paintEngine()) {
5765             const QRegion targetSystemClip = targetEngine->systemClip();
5766             if (!targetSystemClip.isEmpty())
5767                 paintRegion &= targetSystemClip.translated(-offset);
5768         }
5769     }
5770 
5771     // Set backingstore flags.
5772     int flags = DrawPaintOnScreen | DrawInvisible;
5773     if (renderFlags & QWidget::DrawWindowBackground)
5774         flags |= DrawAsRoot;
5775 
5776     if (renderFlags & QWidget::DrawChildren)
5777         flags |= DrawRecursive;
5778     else
5779         flags |= DontSubtractOpaqueChildren;
5780 
5781     flags |= DontSetCompositionMode;
5782 
5783     // Render via backingstore.
5784     drawWidget(target, paintRegion, offset, flags, sharedPainter());
5785 
5786     // Restore shared painter.
5787     if (oldSharedPainter)
5788         setSharedPainter(oldSharedPainter);
5789 }
5790 
5791 void QWidgetPrivate::paintSiblingsRecursive(QPaintDevice *pdev, const QObjectList& siblings, int index, const QRegion &rgn,
5792                                             const QPoint &offset, int flags
5793                                             , QPainter *sharedPainter, QWidgetBackingStore *backingStore)
5794 {
5795     QWidget *w = 0;
5796     QRect boundingRect;
5797     bool dirtyBoundingRect = true;
5798     const bool exludeOpaqueChildren = (flags & DontDrawOpaqueChildren);
5799     const bool excludeNativeChildren = (flags & DontDrawNativeChildren);
5800 
5801     do {
5802         QWidget *x =  qobject_cast<QWidget*>(siblings.at(index));
5803         if (x && !(exludeOpaqueChildren && x->d_func()->isOpaque) && !x->isHidden() && !x->isWindow()
5804             && !(excludeNativeChildren && x->internalWinId())) {
5805             if (dirtyBoundingRect) {
5806                 boundingRect = rgn.boundingRect();
5807                 dirtyBoundingRect = false;
5808             }
5809 
5810             if (qRectIntersects(boundingRect, x->d_func()->effectiveRectFor(x->data->crect))) {
5811                 w = x;
5812                 break;
5813             }
5814         }
5815         --index;
5816     } while (index >= 0);
5817 
5818     if (!w)
5819         return;
5820 
5821     QWidgetPrivate *wd = w->d_func();
5822     const QPoint widgetPos(w->data->crect.topLeft());
5823     const bool hasMask = wd->extra && wd->extra->hasMask && !wd->graphicsEffect;
5824     if (index > 0) {
5825         QRegion wr(rgn);
5826         if (wd->isOpaque)
5827             wr -= hasMask ? wd->extra->mask.translated(widgetPos) : w->data->crect;
5828         paintSiblingsRecursive(pdev, siblings, --index, wr, offset, flags
5829                                , sharedPainter, backingStore);
5830     }
5831 
5832     if (w->updatesEnabled()
5833 #if QT_CONFIG(graphicsview)
5834             && (!w->d_func()->extra || !w->d_func()->extra->proxyWidget)
5835 #endif // QT_CONFIG(graphicsview)
5836        ) {
5837         QRegion wRegion(rgn);
5838         wRegion &= wd->effectiveRectFor(w->data->crect);
5839         wRegion.translate(-widgetPos);
5840         if (hasMask)
5841             wRegion &= wd->extra->mask;
5842         wd->drawWidget(pdev, wRegion, offset + widgetPos, flags, sharedPainter, backingStore);
5843     }
5844 }
5845 
5846 #if QT_CONFIG(graphicseffect)
5847 QRectF QWidgetEffectSourcePrivate::boundingRect(Qt::CoordinateSystem system) const
5848 {
5849     if (system != Qt::DeviceCoordinates)
5850         return m_widget->rect();
5851 
5852     if (Q_UNLIKELY(!context)) {
5853         // Device coordinates without context not yet supported.
5854         qWarning("QGraphicsEffectSource::boundingRect: Not yet implemented, lacking device context");
5855         return QRectF();
5856     }
5857 
5858     return context->painter->worldTransform().mapRect(m_widget->rect());
5859 }
5860 
5861 void QWidgetEffectSourcePrivate::draw(QPainter *painter)
5862 {
5863     if (!context || context->painter != painter) {
5864         m_widget->render(painter);
5865         return;
5866     }
5867 
5868     // The region saved in the context is neither clipped to the rect
5869     // nor the mask, so we have to clip it here before calling drawWidget.
5870     QRegion toBePainted = context->rgn;
5871     toBePainted &= m_widget->rect();
5872     QWidgetPrivate *wd = qt_widget_private(m_widget);
5873     if (wd->extra && wd->extra->hasMask)
5874         toBePainted &= wd->extra->mask;
5875 
5876     wd->drawWidget(context->pdev, toBePainted, context->offset, context->flags,
5877                    context->sharedPainter, context->backingStore);
5878 }
5879 
5880 QPixmap QWidgetEffectSourcePrivate::pixmap(Qt::CoordinateSystem system, QPoint *offset,
5881                                            QGraphicsEffect::PixmapPadMode mode) const
5882 {
5883     const bool deviceCoordinates = (system == Qt::DeviceCoordinates);
5884     if (Q_UNLIKELY(!context && deviceCoordinates)) {
5885         // Device coordinates without context not yet supported.
5886         qWarning("QGraphicsEffectSource::pixmap: Not yet implemented, lacking device context");
5887         return QPixmap();
5888     }
5889 
5890     QPoint pixmapOffset;
5891     QRectF sourceRect = m_widget->rect();
5892 
5893     if (deviceCoordinates) {
5894         const QTransform &painterTransform = context->painter->worldTransform();
5895         sourceRect = painterTransform.mapRect(sourceRect);
5896         pixmapOffset = painterTransform.map(pixmapOffset);
5897     }
5898 
5899     QRect effectRect;
5900 
5901     if (mode == QGraphicsEffect::PadToEffectiveBoundingRect)
5902         effectRect = m_widget->graphicsEffect()->boundingRectFor(sourceRect).toAlignedRect();
5903     else if (mode == QGraphicsEffect::PadToTransparentBorder)
5904         effectRect = sourceRect.adjusted(-1, -1, 1, 1).toAlignedRect();
5905     else
5906         effectRect = sourceRect.toAlignedRect();
5907 
5908     if (offset)
5909         *offset = effectRect.topLeft();
5910 
5911     pixmapOffset -= effectRect.topLeft();
5912 
5913     const qreal dpr = context->painter->device()->devicePixelRatio();
5914     QPixmap pixmap(effectRect.size() * dpr);
5915     pixmap.setDevicePixelRatio(dpr);
5916 
5917     pixmap.fill(Qt::transparent);
5918     m_widget->render(&pixmap, pixmapOffset, QRegion(), QWidget::DrawChildren);
5919     return pixmap;
5920 }
5921 #endif // QT_CONFIG(graphicseffect)
5922 
5923 #if QT_CONFIG(graphicsview)
5924 /*!
5925     \internal
5926 
5927     Finds the nearest widget embedded in a graphics proxy widget along the chain formed by this
5928     widget and its ancestors. The search starts at \a origin (inclusive).
5929     If successful, the function returns the proxy that embeds the widget, or 0 if no embedded
5930     widget was found.
5931 */
5932 QGraphicsProxyWidget * QWidgetPrivate::nearestGraphicsProxyWidget(const QWidget *origin)
5933 {
5934     if (origin) {
5935         QWExtra *extra = origin->d_func()->extra;
5936         if (extra && extra->proxyWidget)
5937             return extra->proxyWidget;
5938         return nearestGraphicsProxyWidget(origin->parentWidget());
5939     }
5940     return 0;
5941 }
5942 #endif
5943 
5944 /*!
5945     \property QWidget::locale
5946     \brief the widget's locale
5947     \since 4.3
5948 
5949     As long as no special locale has been set, this is either
5950     the parent's locale or (if this widget is a top level widget),
5951     the default locale.
5952 
5953     If the widget displays dates or numbers, these should be formatted
5954     using the widget's locale.
5955 
5956     \sa QLocale, QLocale::setDefault()
5957 */
5958 
5959 void QWidgetPrivate::setLocale_helper(const QLocale &loc, bool forceUpdate)
5960 {
5961     Q_Q(QWidget);
5962     if (locale == loc && !forceUpdate)
5963         return;
5964 
5965     locale = loc;
5966 
5967     if (!children.isEmpty()) {
5968         for (int i = 0; i < children.size(); ++i) {
5969             QWidget *w = qobject_cast<QWidget*>(children.at(i));
5970             if (!w)
5971                 continue;
5972             if (w->testAttribute(Qt::WA_SetLocale))
5973                 continue;
5974             if (w->isWindow() && !w->testAttribute(Qt::WA_WindowPropagation))
5975                 continue;
5976             w->d_func()->setLocale_helper(loc, forceUpdate);
5977         }
5978     }
5979     QEvent e(QEvent::LocaleChange);
5980     QApplication::sendEvent(q, &e);
5981 }
5982 
5983 void QWidget::setLocale(const QLocale &locale)
5984 {
5985     Q_D(QWidget);
5986 
5987     setAttribute(Qt::WA_SetLocale);
5988     d->setLocale_helper(locale);
5989 }
5990 
5991 QLocale QWidget::locale() const
5992 {
5993     Q_D(const QWidget);
5994 
5995     return d->locale;
5996 }
5997 
5998 void QWidgetPrivate::resolveLocale()
5999 {
6000     Q_Q(const QWidget);
6001 
6002     if (!q->testAttribute(Qt::WA_SetLocale)) {
6003         setLocale_helper(q->isWindow() && !q->testAttribute(Qt::WA_WindowPropagation)
6004                             ? QLocale()
6005                             : q->parentWidget()->locale());
6006     }
6007 }
6008 
6009 void QWidget::unsetLocale()
6010 {
6011     Q_D(QWidget);
6012     setAttribute(Qt::WA_SetLocale, false);
6013     d->resolveLocale();
6014 }
6015 
6016 /*!
6017     \property QWidget::windowTitle
6018     \brief the window title (caption)
6019 
6020     This property only makes sense for top-level widgets, such as
6021     windows and dialogs. If no caption has been set, the title is based of the
6022     \l windowFilePath. If neither of these is set, then the title is
6023     an empty string.
6024 
6025     If you use the \l windowModified mechanism, the window title must
6026     contain a "[*]" placeholder, which indicates where the '*' should
6027     appear. Normally, it should appear right after the file name
6028     (e.g., "document1.txt[*] - Text Editor"). If the \l
6029     windowModified property is \c false (the default), the placeholder
6030     is simply removed.
6031 
6032     On some desktop platforms (including Windows and Unix), the application name
6033     (from QGuiApplication::applicationDisplayName) is added at the end of the
6034     window title, if set. This is done by the QPA plugin, so it is shown to the
6035     user, but isn't part of the windowTitle string.
6036 
6037     \sa windowIcon, windowModified, windowFilePath
6038 */
6039 QString QWidget::windowTitle() const
6040 {
6041     Q_D(const QWidget);
6042     if (d->extra && d->extra->topextra) {
6043         if (!d->extra->topextra->caption.isEmpty())
6044             return d->extra->topextra->caption;
6045         if (!d->extra->topextra->filePath.isEmpty())
6046             return QFileInfo(d->extra->topextra->filePath).fileName() + QLatin1String("[*]");
6047     }
6048     return QString();
6049 }
6050 
6051 /*!
6052     Returns a modified window title with the [*] place holder
6053     replaced according to the rules described in QWidget::setWindowTitle
6054 
6055     This function assumes that "[*]" can be quoted by another
6056     "[*]", so it will replace two place holders by one and
6057     a single last one by either "*" or nothing depending on
6058     the modified flag.
6059 
6060     \internal
6061 */
6062 QString qt_setWindowTitle_helperHelper(const QString &title, const QWidget *widget)
6063 {
6064     Q_ASSERT(widget);
6065 
6066 #ifdef QT_EVAL
6067     extern QString qt_eval_adapt_window_title(const QString &title);
6068     QString cap = qt_eval_adapt_window_title(title);
6069 #else
6070     QString cap = title;
6071 #endif
6072 
6073     if (cap.isEmpty())
6074         return cap;
6075 
6076     QLatin1String placeHolder("[*]");
6077     int index = cap.indexOf(placeHolder);
6078 
6079     // here the magic begins
6080     while (index != -1) {
6081         index += placeHolder.size();
6082         int count = 1;
6083         while (cap.indexOf(placeHolder, index) == index) {
6084             ++count;
6085             index += placeHolder.size();
6086         }
6087 
6088         if (count%2) { // odd number of [*] -> replace last one
6089             int lastIndex = cap.lastIndexOf(placeHolder, index - 1);
6090             if (widget->isWindowModified()
6091              && widget->style()->styleHint(QStyle::SH_TitleBar_ModifyNotification, 0, widget))
6092                 cap.replace(lastIndex, 3, QWidget::tr("*"));
6093             else
6094                 cap.remove(lastIndex, 3);
6095         }
6096 
6097         index = cap.indexOf(placeHolder, index);
6098     }
6099 
6100     cap.replace(QLatin1String("[*][*]"), placeHolder);
6101 
6102     return cap;
6103 }
6104 
6105 void QWidgetPrivate::setWindowTitle_helper(const QString &title)
6106 {
6107     Q_Q(QWidget);
6108     if (q->testAttribute(Qt::WA_WState_Created))
6109         setWindowTitle_sys(qt_setWindowTitle_helperHelper(title, q));
6110 }
6111 
6112 void QWidgetPrivate::setWindowTitle_sys(const QString &caption)
6113 {
6114     Q_Q(QWidget);
6115     if (!q->isWindow())
6116         return;
6117 
6118     if (QWindow *window = q->windowHandle())
6119         window->setTitle(caption);
6120 
6121 }
6122 
6123 void QWidgetPrivate::setWindowIconText_helper(const QString &title)
6124 {
6125     Q_Q(QWidget);
6126     if (q->testAttribute(Qt::WA_WState_Created))
6127         setWindowIconText_sys(qt_setWindowTitle_helperHelper(title, q));
6128 }
6129 
6130 void QWidgetPrivate::setWindowIconText_sys(const QString &iconText)
6131 {
6132     Q_Q(QWidget);
6133     // ### The QWidget property is deprecated, but the XCB window function is not.
6134     // It should remain available for the rare application that needs it.
6135     if (QWindow *window = q->windowHandle())
6136         QXcbWindowFunctions::setWmWindowIconText(window, iconText);
6137 }
6138 
6139 /*!
6140     \fn void QWidget::windowIconTextChanged(const QString &iconText)
6141 
6142     This signal is emitted when the window's icon text has changed, with the
6143     new \a iconText as an argument.
6144 
6145     \since 5.2
6146     \obsolete
6147 
6148     This signal is deprecated.
6149 */
6150 
6151 void QWidget::setWindowIconText(const QString &iconText)
6152 {
6153     if (QWidget::windowIconText() == iconText)
6154         return;
6155 
6156     Q_D(QWidget);
6157     d->topData()->iconText = iconText;
6158     d->setWindowIconText_helper(iconText);
6159 
6160     QEvent e(QEvent::IconTextChange);
6161     QApplication::sendEvent(this, &e);
6162 
6163     emit windowIconTextChanged(iconText);
6164 }
6165 
6166 /*!
6167     \fn void QWidget::windowTitleChanged(const QString &title)
6168 
6169     This signal is emitted when the window's title has changed, with the
6170     new \a title as an argument.
6171 
6172     \since 5.2
6173 */
6174 
6175 void QWidget::setWindowTitle(const QString &title)
6176 {
6177     if (QWidget::windowTitle() == title && !title.isEmpty() && !title.isNull())
6178         return;
6179 
6180     Q_D(QWidget);
6181     d->topData()->caption = title;
6182     d->setWindowTitle_helper(title);
6183 
6184     QEvent e(QEvent::WindowTitleChange);
6185     QApplication::sendEvent(this, &e);
6186 
6187     emit windowTitleChanged(title);
6188 }
6189 
6190 
6191 /*!
6192     \property QWidget::windowIcon
6193     \brief the widget's icon
6194 
6195     This property only makes sense for windows. If no icon
6196     has been set, windowIcon() returns the application icon
6197     (QApplication::windowIcon()).
6198 
6199     \sa windowTitle
6200 */
6201 QIcon QWidget::windowIcon() const
6202 {
6203     const QWidget *w = this;
6204     while (w) {
6205         const QWidgetPrivate *d = w->d_func();
6206         if (d->extra && d->extra->topextra && d->extra->topextra->icon)
6207             return *d->extra->topextra->icon;
6208         w = w->parentWidget();
6209     }
6210     return QApplication::windowIcon();
6211 }
6212 
6213 void QWidgetPrivate::setWindowIcon_helper()
6214 {
6215     Q_Q(QWidget);
6216     QEvent e(QEvent::WindowIconChange);
6217 
6218     // Do not send the event if the widget is a top level.
6219     // In that case, setWindowIcon_sys does it, and event propagation from
6220     // QWidgetWindow to the top level QWidget ensures that the event reaches
6221     // the top level anyhow
6222     if (!q->windowHandle())
6223         QApplication::sendEvent(q, &e);
6224     for (int i = 0; i < children.size(); ++i) {
6225         QWidget *w = qobject_cast<QWidget *>(children.at(i));
6226         if (w && !w->isWindow())
6227             QApplication::sendEvent(w, &e);
6228     }
6229 }
6230 
6231 /*!
6232     \fn void QWidget::windowIconChanged(const QIcon &icon)
6233 
6234     This signal is emitted when the window's icon has changed, with the
6235     new \a icon as an argument.
6236 
6237     \since 5.2
6238 */
6239 
6240 void QWidget::setWindowIcon(const QIcon &icon)
6241 {
6242     Q_D(QWidget);
6243 
6244     setAttribute(Qt::WA_SetWindowIcon, !icon.isNull());
6245     d->createTLExtra();
6246 
6247     if (!d->extra->topextra->icon)
6248         d->extra->topextra->icon = new QIcon();
6249     *d->extra->topextra->icon = icon;
6250 
6251     d->setWindowIcon_sys();
6252     d->setWindowIcon_helper();
6253 
6254     emit windowIconChanged(icon);
6255 }
6256 
6257 void QWidgetPrivate::setWindowIcon_sys()
6258 {
6259     Q_Q(QWidget);
6260     if (QWindow *window = q->windowHandle())
6261         window->setIcon(q->windowIcon());
6262 }
6263 
6264 /*!
6265     \property QWidget::windowIconText
6266     \brief the text to be displayed on the icon of a minimized window
6267 
6268     This property only makes sense for windows. If no icon
6269     text has been set, this accessor returns an empty string.
6270     It is only implemented on the X11 platform, and only certain
6271     window managers use this window property.
6272 
6273     \obsolete
6274     This property is deprecated.
6275 
6276     \sa windowIcon, windowTitle
6277 */
6278 
6279 QString QWidget::windowIconText() const
6280 {
6281     Q_D(const QWidget);
6282     return (d->extra && d->extra->topextra) ? d->extra->topextra->iconText : QString();
6283 }
6284 
6285 /*!
6286     \property QWidget::windowFilePath
6287     \since 4.4
6288     \brief the file path associated with a widget
6289 
6290     This property only makes sense for windows. It associates a file path with
6291     a window. If you set the file path, but have not set the window title, Qt
6292     sets the window title to the file name of the specified path, obtained using
6293     QFileInfo::fileName().
6294 
6295     If the window title is set at any point, then the window title takes precedence and
6296     will be shown instead of the file path string.
6297 
6298     Additionally, on \macos, this has an added benefit that it sets the
6299     \l{http://developer.apple.com/documentation/UserExperience/Conceptual/OSXHIGuidelines/XHIGWindows/chapter_17_section_3.html}{proxy icon}
6300     for the window, assuming that the file path exists.
6301 
6302     If no file path is set, this property contains an empty string.
6303 
6304     By default, this property contains an empty string.
6305 
6306     \sa windowTitle, windowIcon
6307 */
6308 
6309 QString QWidget::windowFilePath() const
6310 {
6311     Q_D(const QWidget);
6312     return (d->extra && d->extra->topextra) ? d->extra->topextra->filePath : QString();
6313 }
6314 
6315 void QWidget::setWindowFilePath(const QString &filePath)
6316 {
6317     if (filePath == windowFilePath())
6318         return;
6319 
6320     Q_D(QWidget);
6321 
6322     d->createTLExtra();
6323     d->extra->topextra->filePath = filePath;
6324     d->setWindowFilePath_helper(filePath);
6325 }
6326 
6327 void QWidgetPrivate::setWindowFilePath_helper(const QString &filePath)
6328 {
6329     if (extra->topextra && extra->topextra->caption.isEmpty()) {
6330 #ifdef Q_OS_MAC
6331         setWindowTitle_helper(QFileInfo(filePath).fileName());
6332 #else
6333         Q_Q(QWidget);
6334         Q_UNUSED(filePath);
6335         setWindowTitle_helper(q->windowTitle());
6336 #endif
6337     }
6338 #ifdef Q_OS_MAC
6339     setWindowFilePath_sys(filePath);
6340 #endif
6341 }
6342 
6343 void QWidgetPrivate::setWindowFilePath_sys(const QString &filePath)
6344 {
6345     Q_Q(QWidget);
6346     if (!q->isWindow())
6347         return;
6348 
6349     if (QWindow *window = q->windowHandle())
6350         window->setFilePath(filePath);
6351 }
6352 
6353 /*!
6354     Returns the window's role, or an empty string.
6355 
6356     \sa windowIcon, windowTitle
6357 */
6358 
6359 QString QWidget::windowRole() const
6360 {
6361     Q_D(const QWidget);
6362     return (d->extra && d->extra->topextra) ? d->extra->topextra->role : QString();
6363 }
6364 
6365 /*!
6366     Sets the window's role to \a role. This only makes sense for
6367     windows on X11.
6368 */
6369 void QWidget::setWindowRole(const QString &role)
6370 {
6371     Q_D(QWidget);
6372     d->createTLExtra();
6373     d->topData()->role = role;
6374     if (windowHandle())
6375         QXcbWindowFunctions::setWmWindowRole(windowHandle(), role.toLatin1());
6376 }
6377 
6378 /*!
6379     \property QWidget::mouseTracking
6380     \brief whether mouse tracking is enabled for the widget
6381 
6382     If mouse tracking is disabled (the default), the widget only
6383     receives mouse move events when at least one mouse button is
6384     pressed while the mouse is being moved.
6385 
6386     If mouse tracking is enabled, the widget receives mouse move
6387     events even if no buttons are pressed.
6388 
6389     \sa mouseMoveEvent()
6390 */
6391 
6392 /*!
6393     \property QWidget::tabletTracking
6394     \brief whether tablet tracking is enabled for the widget
6395     \since 5.9
6396 
6397     If tablet tracking is disabled (the default), the widget only
6398     receives tablet move events when the stylus is in contact with
6399     the tablet, or at least one stylus button is pressed,
6400     while the stylus is being moved.
6401 
6402     If tablet tracking is enabled, the widget receives tablet move
6403     events even while hovering in proximity.  This is useful for
6404     monitoring position as well as the auxiliary properties such
6405     as rotation and tilt, and providing feedback in the UI.
6406 
6407     \sa tabletEvent()
6408 */
6409 
6410 
6411 /*!
6412     Sets the widget's focus proxy to widget \a w. If \a w is 0, the
6413     function resets this widget to have no focus proxy.
6414 
6415     Some widgets can "have focus", but create a child widget, such as
6416     QLineEdit, to actually handle the focus. In this case, the widget
6417     can set the line edit to be its focus proxy.
6418 
6419     setFocusProxy() sets the widget which will actually get focus when
6420     "this widget" gets it. If there is a focus proxy, setFocus() and
6421     hasFocus() operate on the focus proxy.
6422 
6423     \sa focusProxy()
6424 */
6425 
6426 void QWidget::setFocusProxy(QWidget * w)
6427 {
6428     Q_D(QWidget);
6429     if (!w && !d->extra)
6430         return;
6431 
6432     for (QWidget* fp  = w; fp; fp = fp->focusProxy()) {
6433         if (Q_UNLIKELY(fp == this)) {
6434             qWarning("QWidget: %s (%s) already in focus proxy chain", metaObject()->className(), objectName().toLocal8Bit().constData());
6435             return;
6436         }
6437     }
6438 
6439     d->createExtra();
6440     d->extra->focus_proxy = w;
6441 }
6442 
6443 
6444 /*!
6445     Returns the focus proxy, or 0 if there is no focus proxy.
6446 
6447     \sa setFocusProxy()
6448 */
6449 
6450 QWidget * QWidget::focusProxy() const
6451 {
6452     Q_D(const QWidget);
6453     return d->extra ? (QWidget *)d->extra->focus_proxy : 0;
6454 }
6455 
6456 
6457 /*!
6458     \property QWidget::focus
6459     \brief whether this widget (or its focus proxy) has the keyboard
6460     input focus
6461 
6462     By default, this property is \c false.
6463 
6464     \note Obtaining the value of this property for a widget is effectively equivalent
6465     to checking whether QApplication::focusWidget() refers to the widget.
6466 
6467     \sa setFocus(), clearFocus(), setFocusPolicy(), QApplication::focusWidget()
6468 */
6469 bool QWidget::hasFocus() const
6470 {
6471     const QWidget* w = this;
6472     while (w->d_func()->extra && w->d_func()->extra->focus_proxy)
6473         w = w->d_func()->extra->focus_proxy;
6474 #if QT_CONFIG(graphicsview)
6475     if (QWidget *window = w->window()) {
6476         QWExtra *e = window->d_func()->extra;
6477         if (e && e->proxyWidget && e->proxyWidget->hasFocus() && window->focusWidget() == w)
6478             return true;
6479     }
6480 #endif // QT_CONFIG(graphicsview)
6481     return (QApplication::focusWidget() == w);
6482 }
6483 
6484 /*!
6485     Gives the keyboard input focus to this widget (or its focus
6486     proxy) if this widget or one of its parents is the \l{isActiveWindow()}{active window}. The \a reason argument will
6487     be passed into any focus event sent from this function, it is used
6488     to give an explanation of what caused the widget to get focus.
6489     If the window is not active, the widget will be given the focus when
6490     the window becomes active.
6491 
6492     First, a focus about to change event is sent to the focus widget (if any) to
6493     tell it that it is about to lose the focus. Then focus is changed, a
6494     focus out event is sent to the previous focus item and a focus in event is sent
6495     to the new item to tell it that it just received the focus.
6496     (Nothing happens if the focus in and focus out widgets are the
6497     same.)
6498 
6499     \note On embedded platforms, setFocus() will not cause an input panel
6500     to be opened by the input method. If you want this to happen, you
6501     have to send a QEvent::RequestSoftwareInputPanel event to the
6502     widget yourself.
6503 
6504     setFocus() gives focus to a widget regardless of its focus policy,
6505     but does not clear any keyboard grab (see grabKeyboard()).
6506 
6507     Be aware that if the widget is hidden, it will not accept focus
6508     until it is shown.
6509 
6510     \warning If you call setFocus() in a function which may itself be
6511     called from focusOutEvent() or focusInEvent(), you may get an
6512     infinite recursion.
6513 
6514     \sa hasFocus(), clearFocus(), focusInEvent(), focusOutEvent(),
6515     setFocusPolicy(), focusWidget(), QApplication::focusWidget(), grabKeyboard(),
6516     grabMouse(), {Keyboard Focus in Widgets}, QEvent::RequestSoftwareInputPanel
6517 */
6518 
6519 void QWidget::setFocus(Qt::FocusReason reason)
6520 {
6521     if (!isEnabled())
6522         return;
6523 
6524     QWidget *f = this;
6525     while (f->d_func()->extra && f->d_func()->extra->focus_proxy)
6526         f = f->d_func()->extra->focus_proxy;
6527 
6528     if (QApplication::focusWidget() == f
6529 #if 0 // Used to be included in Qt4 for Q_WS_WIN
6530         && GetFocus() == f->internalWinId()
6531 #endif
6532        )
6533         return;
6534 
6535 #if QT_CONFIG(graphicsview)
6536     QWidget *previousProxyFocus = 0;
6537     if (QWExtra *topData = window()->d_func()->extra) {
6538         if (topData->proxyWidget && topData->proxyWidget->hasFocus()) {
6539             previousProxyFocus = topData->proxyWidget->widget()->focusWidget();
6540             if (previousProxyFocus && previousProxyFocus->focusProxy())
6541                 previousProxyFocus = previousProxyFocus->focusProxy();
6542             if (previousProxyFocus == this && !topData->proxyWidget->d_func()->proxyIsGivingFocus)
6543                 return;
6544         }
6545     }
6546 #endif
6547 
6548 #if QT_CONFIG(graphicsview)
6549     // Update proxy state
6550     if (QWExtra *topData = window()->d_func()->extra) {
6551         if (topData->proxyWidget && !topData->proxyWidget->hasFocus()) {
6552             f->d_func()->updateFocusChild();
6553             topData->proxyWidget->d_func()->focusFromWidgetToProxy = 1;
6554             topData->proxyWidget->setFocus(reason);
6555             topData->proxyWidget->d_func()->focusFromWidgetToProxy = 0;
6556         }
6557     }
6558 #endif
6559 
6560     if (f->isActiveWindow()) {
6561         QWidget *prev = QApplicationPrivate::focus_widget;
6562         if (prev) {
6563             if (reason != Qt::PopupFocusReason && reason != Qt::MenuBarFocusReason
6564                 && prev->testAttribute(Qt::WA_InputMethodEnabled)) {
6565                 QGuiApplication::inputMethod()->commit();
6566             }
6567 
6568             if (reason != Qt::NoFocusReason) {
6569                 QFocusEvent focusAboutToChange(QEvent::FocusAboutToChange, reason);
6570                 QApplication::sendEvent(prev, &focusAboutToChange);
6571             }
6572         }
6573 
6574         f->d_func()->updateFocusChild();
6575 
6576         QApplicationPrivate::setFocusWidget(f, reason);
6577 #ifndef QT_NO_ACCESSIBILITY
6578 # ifdef Q_OS_WIN
6579         // The negation of the condition in setFocus_sys
6580         if (!(testAttribute(Qt::WA_WState_Created) && window()->windowType() != Qt::Popup && internalWinId()))
6581             //setFocusWidget will already post a focus event for us (that the AT client receives) on Windows
6582 # endif
6583         // menus update the focus manually and this would create bogus events
6584         if (!(f->inherits("QMenuBar") || f->inherits("QMenu") || f->inherits("QMenuItem")))
6585         {
6586             QAccessibleEvent event(f, QAccessible::Focus);
6587             QAccessible::updateAccessibility(&event);
6588         }
6589 #endif
6590 #if QT_CONFIG(graphicsview)
6591         if (QWExtra *topData = window()->d_func()->extra) {
6592             if (topData->proxyWidget) {
6593                 if (previousProxyFocus && previousProxyFocus != f) {
6594                     // Send event to self
6595                     QFocusEvent event(QEvent::FocusOut, reason);
6596                     QPointer<QWidget> that = previousProxyFocus;
6597                     QApplication::sendEvent(previousProxyFocus, &event);
6598                     if (that)
6599                         QApplication::sendEvent(that->style(), &event);
6600                 }
6601                 if (!isHidden()) {
6602 #if QT_CONFIG(graphicsview)
6603                     // Update proxy state
6604                     if (QWExtra *topData = window()->d_func()->extra)
6605                         if (topData->proxyWidget && topData->proxyWidget->hasFocus())
6606                             topData->proxyWidget->d_func()->updateProxyInputMethodAcceptanceFromWidget();
6607 #endif
6608                     // Send event to self
6609                     QFocusEvent event(QEvent::FocusIn, reason);
6610                     QPointer<QWidget> that = f;
6611                     QApplication::sendEvent(f, &event);
6612                     if (that)
6613                         QApplication::sendEvent(that->style(), &event);
6614                 }
6615             }
6616         }
6617 #endif
6618     } else {
6619         f->d_func()->updateFocusChild();
6620     }
6621 }
6622 
6623 void QWidgetPrivate::setFocus_sys()
6624 {
6625     Q_Q(QWidget);
6626     // Embedded native widget may have taken the focus; get it back to toplevel if that is the case
6627     const QWidget *topLevel = q->window();
6628     if (topLevel->windowType() != Qt::Popup) {
6629         if (QWindow *nativeWindow = q->window()->windowHandle()) {
6630             if (nativeWindow != QGuiApplication::focusWindow()
6631                 && q->testAttribute(Qt::WA_WState_Created)) {
6632                 nativeWindow->requestActivate();
6633             }
6634         }
6635     }
6636 }
6637 
6638 // updates focus_child on parent widgets to point into this widget
6639 void QWidgetPrivate::updateFocusChild()
6640 {
6641     Q_Q(QWidget);
6642 
6643     QWidget *w = q;
6644     if (q->isHidden()) {
6645         while (w && w->isHidden()) {
6646             w->d_func()->focus_child = q;
6647             w = w->isWindow() ? 0 : w->parentWidget();
6648         }
6649     } else {
6650         while (w) {
6651             w->d_func()->focus_child = q;
6652             w = w->isWindow() ? 0 : w->parentWidget();
6653         }
6654     }
6655 
6656     if (QTLWExtra *extra = q->window()->d_func()->maybeTopData()) {
6657         if (extra->window)
6658             emit extra->window->focusObjectChanged(q);
6659     }
6660 }
6661 
6662 /*!
6663     \fn void QWidget::setFocus()
6664     \overload
6665 
6666     Gives the keyboard input focus to this widget (or its focus
6667     proxy) if this widget or one of its parents is the
6668     \l{isActiveWindow()}{active window}.
6669 */
6670 
6671 /*!
6672     Takes keyboard input focus from the widget.
6673 
6674     If the widget has active focus, a \l{focusOutEvent()}{focus out event} is sent to this widget to tell it that it has
6675     lost the focus.
6676 
6677     This widget must enable focus setting in order to get the keyboard
6678     input focus, i.e. it must call setFocusPolicy().
6679 
6680     \sa hasFocus(), setFocus(), focusInEvent(), focusOutEvent(),
6681     setFocusPolicy(), QApplication::focusWidget()
6682 */
6683 
6684 void QWidget::clearFocus()
6685 {
6686     if (hasFocus()) {
6687         if (testAttribute(Qt::WA_InputMethodEnabled))
6688             QGuiApplication::inputMethod()->commit();
6689 
6690         QFocusEvent focusAboutToChange(QEvent::FocusAboutToChange);
6691         QApplication::sendEvent(this, &focusAboutToChange);
6692     }
6693 
6694     QWidget *w = this;
6695     while (w) {
6696         // Just like setFocus(), we update (clear) the focus_child of our parents
6697         if (w->d_func()->focus_child == this)
6698             w->d_func()->focus_child = 0;
6699         w = w->parentWidget();
6700     }
6701 
6702     // Since we've unconditionally cleared the focus_child of our parents, we need
6703     // to report this to the rest of Qt. Note that the focus_child is not the same
6704     // thing as the application's focusWidget, which is why this piece of code is
6705     // not inside the hasFocus() block below.
6706     if (QTLWExtra *extra = window()->d_func()->maybeTopData()) {
6707         if (extra->window)
6708             emit extra->window->focusObjectChanged(extra->window->focusObject());
6709     }
6710 
6711 #if QT_CONFIG(graphicsview)
6712     QWExtra *topData = d_func()->extra;
6713     if (topData && topData->proxyWidget)
6714         topData->proxyWidget->clearFocus();
6715 #endif
6716 
6717     if (hasFocus()) {
6718         // Update proxy state
6719         QApplicationPrivate::setFocusWidget(0, Qt::OtherFocusReason);
6720 #if 0 // Used to be included in Qt4 for Q_WS_WIN
6721         if (!(windowType() == Qt::Popup) && GetFocus() == internalWinId())
6722             SetFocus(0);
6723         else
6724 #endif
6725         {
6726 #ifndef QT_NO_ACCESSIBILITY
6727             QAccessibleEvent event(this, QAccessible::Focus);
6728             QAccessible::updateAccessibility(&event);
6729 #endif
6730         }
6731     }
6732 }
6733 
6734 
6735 /*!
6736     \fn bool QWidget::focusNextChild()
6737 
6738     Finds a new widget to give the keyboard focus to, as appropriate
6739     for \uicontrol Tab, and returns \c true if it can find a new widget, or
6740     false if it can't.
6741 
6742     \sa focusPreviousChild()
6743 */
6744 
6745 /*!
6746     \fn bool QWidget::focusPreviousChild()
6747 
6748     Finds a new widget to give the keyboard focus to, as appropriate
6749     for \uicontrol Shift+Tab, and returns \c true if it can find a new widget,
6750     or false if it can't.
6751 
6752     \sa focusNextChild()
6753 */
6754 
6755 /*!
6756     Finds a new widget to give the keyboard focus to, as appropriate
6757     for Tab and Shift+Tab, and returns \c true if it can find a new
6758     widget, or false if it can't.
6759 
6760     If \a next is true, this function searches forward, if \a next
6761     is false, it searches backward.
6762 
6763     Sometimes, you will want to reimplement this function. For
6764     example, a web browser might reimplement it to move its "current
6765     active link" forward or backward, and call
6766     focusNextPrevChild() only when it reaches the last or
6767     first link on the "page".
6768 
6769     Child widgets call focusNextPrevChild() on their parent widgets,
6770     but only the window that contains the child widgets decides where
6771     to redirect focus. By reimplementing this function for an object,
6772     you thus gain control of focus traversal for all child widgets.
6773 
6774     \sa focusNextChild(), focusPreviousChild()
6775 */
6776 
6777 bool QWidget::focusNextPrevChild(bool next)
6778 {
6779     QWidget* p = parentWidget();
6780     bool isSubWindow = (windowType() == Qt::SubWindow);
6781     if (!isWindow() && !isSubWindow && p)
6782         return p->focusNextPrevChild(next);
6783 #if QT_CONFIG(graphicsview)
6784     Q_D(QWidget);
6785     if (d->extra && d->extra->proxyWidget)
6786         return d->extra->proxyWidget->focusNextPrevChild(next);
6787 #endif
6788 
6789     bool wrappingOccurred = false;
6790     QWidget *w = QApplicationPrivate::focusNextPrevChild_helper(this, next,
6791                                                                 &wrappingOccurred);
6792     if (!w) return false;
6793 
6794     Qt::FocusReason reason = next ? Qt::TabFocusReason : Qt::BacktabFocusReason;
6795 
6796     /* If we are about to wrap the focus chain, give the platform
6797      * implementation a chance to alter the wrapping behavior.  This is
6798      * especially needed when the window is embedded in a window created by
6799      * another process.
6800      */
6801     if (wrappingOccurred) {
6802         QWindow *window = windowHandle();
6803         if (window != 0) {
6804             QWindowPrivate *winp = qt_window_private(window);
6805 
6806             if (winp->platformWindow != 0) {
6807                 QFocusEvent event(QEvent::FocusIn, reason);
6808                 event.ignore();
6809                 winp->platformWindow->windowEvent(&event);
6810                 if (event.isAccepted()) return true;
6811             }
6812         }
6813     }
6814 
6815     w->setFocus(reason);
6816     return true;
6817 }
6818 
6819 /*!
6820     Returns the last child of this widget that setFocus had been
6821     called on.  For top level widgets this is the widget that will get
6822     focus in case this window gets activated
6823 
6824     This is not the same as QApplication::focusWidget(), which returns
6825     the focus widget in the currently active window.
6826 */
6827 
6828 QWidget *QWidget::focusWidget() const
6829 {
6830     return const_cast<QWidget *>(d_func()->focus_child);
6831 }
6832 
6833 /*!
6834     Returns the next widget in this widget's focus chain.
6835 
6836     \sa previousInFocusChain()
6837 */
6838 QWidget *QWidget::nextInFocusChain() const
6839 {
6840     return const_cast<QWidget *>(d_func()->focus_next);
6841 }
6842 
6843 /*!
6844     \brief The previousInFocusChain function returns the previous
6845     widget in this widget's focus chain.
6846 
6847     \sa nextInFocusChain()
6848 
6849     \since 4.6
6850 */
6851 QWidget *QWidget::previousInFocusChain() const
6852 {
6853     return const_cast<QWidget *>(d_func()->focus_prev);
6854 }
6855 
6856 /*!
6857     \property QWidget::isActiveWindow
6858     \brief whether this widget's window is the active window
6859 
6860     The active window is the window that contains the widget that has
6861     keyboard focus (The window may still have focus if it has no
6862     widgets or none of its widgets accepts keyboard focus).
6863 
6864     When popup windows are visible, this property is \c true for both the
6865     active window \e and for the popup.
6866 
6867     By default, this property is \c false.
6868 
6869     \sa activateWindow(), QApplication::activeWindow()
6870 */
6871 bool QWidget::isActiveWindow() const
6872 {
6873     QWidget *tlw = window();
6874     if(tlw == QApplication::activeWindow() || (isVisible() && (tlw->windowType() == Qt::Popup)))
6875         return true;
6876 
6877 #if QT_CONFIG(graphicsview)
6878     if (QWExtra *tlwExtra = tlw->d_func()->extra) {
6879         if (isVisible() && tlwExtra->proxyWidget)
6880             return tlwExtra->proxyWidget->isActiveWindow();
6881     }
6882 #endif
6883 
6884     if(style()->styleHint(QStyle::SH_Widget_ShareActivation, 0, this)) {
6885         if(tlw->windowType() == Qt::Tool &&
6886            !tlw->isModal() &&
6887            (!tlw->parentWidget() || tlw->parentWidget()->isActiveWindow()))
6888            return true;
6889         QWidget *w = QApplication::activeWindow();
6890         while(w && tlw->windowType() == Qt::Tool &&
6891               !w->isModal() && w->parentWidget()) {
6892             w = w->parentWidget()->window();
6893             if(w == tlw)
6894                 return true;
6895         }
6896     }
6897 
6898     // Check for an active window container
6899     if (QWindow *ww = QGuiApplication::focusWindow()) {
6900         while (ww) {
6901             QWidgetWindow *qww = qobject_cast<QWidgetWindow *>(ww);
6902             QWindowContainer *qwc = qww ? qobject_cast<QWindowContainer *>(qww->widget()) : 0;
6903             if (qwc && qwc->topLevelWidget() == tlw)
6904                 return true;
6905             ww = ww->parent();
6906         }
6907     }
6908 
6909     // Check if platform adaptation thinks the window is active. This is necessary for
6910     // example in case of ActiveQt servers that are embedded into another application.
6911     // Those are separate processes that are not part of the parent application Qt window/widget
6912     // hierarchy, so they need to rely on native methods to determine if they are part of the
6913     // active window.
6914     if (const QWindow *w = tlw->windowHandle()) {
6915         if (w->handle())
6916             return w->handle()->isActive();
6917     }
6918 
6919     return false;
6920 }
6921 
6922 /*!
6923     Puts the \a second widget after the \a first widget in the focus order.
6924 
6925     Note that since the tab order of the \a second widget is changed, you
6926     should order a chain like this:
6927 
6928     \snippet code/src_gui_kernel_qwidget.cpp 9
6929 
6930     \e not like this:
6931 
6932     \snippet code/src_gui_kernel_qwidget.cpp 10
6933 
6934     If \a first or \a second has a focus proxy, setTabOrder()
6935     correctly substitutes the proxy.
6936 
6937     \sa setFocusPolicy(), setFocusProxy(), {Keyboard Focus in Widgets}
6938 */
6939 void QWidget::setTabOrder(QWidget* first, QWidget *second)
6940 {
6941     if (!first || !second || first->focusPolicy() == Qt::NoFocus || second->focusPolicy() == Qt::NoFocus)
6942         return;
6943 
6944     if (Q_UNLIKELY(first->window() != second->window())) {
6945         qWarning("QWidget::setTabOrder: 'first' and 'second' must be in the same window");
6946         return;
6947     }
6948 
6949     QWidget *fp = first->focusProxy();
6950     if (fp) {
6951         // If first is redirected, set first to the last child of first
6952         // that can take keyboard focus so that second is inserted after
6953         // that last child, and the focus order within first is (more
6954         // likely to be) preserved.
6955         QList<QWidget *> l = first->findChildren<QWidget *>();
6956         for (int i = l.size()-1; i >= 0; --i) {
6957             QWidget * next = l.at(i);
6958             if (next->window() == fp->window()) {
6959                 fp = next;
6960                 if (fp->focusPolicy() != Qt::NoFocus)
6961                     break;
6962             }
6963         }
6964         first = fp;
6965     }
6966 
6967     if (fp == second)
6968         return;
6969 
6970     if (QWidget *sp = second->focusProxy())
6971         second = sp;
6972 
6973 //    QWidget *fp = first->d_func()->focus_prev;
6974     QWidget *fn = first->d_func()->focus_next;
6975 
6976     if (fn == second || first == second)
6977         return;
6978 
6979     QWidget *sp = second->d_func()->focus_prev;
6980     QWidget *sn = second->d_func()->focus_next;
6981 
6982     fn->d_func()->focus_prev = second;
6983     first->d_func()->focus_next = second;
6984 
6985     second->d_func()->focus_next = fn;
6986     second->d_func()->focus_prev = first;
6987 
6988     sp->d_func()->focus_next = sn;
6989     sn->d_func()->focus_prev = sp;
6990 
6991 
6992     Q_ASSERT(first->d_func()->focus_next->d_func()->focus_prev == first);
6993     Q_ASSERT(first->d_func()->focus_prev->d_func()->focus_next == first);
6994 
6995     Q_ASSERT(second->d_func()->focus_next->d_func()->focus_prev == second);
6996     Q_ASSERT(second->d_func()->focus_prev->d_func()->focus_next == second);
6997 }
6998 
6999 /*!\internal
7000 
7001   Moves the relevant subwidgets of this widget from the \a oldtlw's
7002   tab chain to that of the new parent, if there's anything to move and
7003   we're really moving
7004 
7005   This function is called from QWidget::reparent() *after* the widget
7006   has been reparented.
7007 
7008   \sa reparent()
7009 */
7010 
7011 void QWidgetPrivate::reparentFocusWidgets(QWidget * oldtlw)
7012 {
7013     Q_Q(QWidget);
7014     if (oldtlw == q->window())
7015         return; // nothing to do
7016 
7017     if(focus_child)
7018         focus_child->clearFocus();
7019 
7020     // separate the focus chain into new (children of myself) and old (the rest)
7021     QWidget *firstOld = 0;
7022     //QWidget *firstNew = q; //invariant
7023     QWidget *o = 0; // last in the old list
7024     QWidget *n = q; // last in the new list
7025 
7026     bool prevWasNew = true;
7027     QWidget *w = focus_next;
7028 
7029     //Note: for efficiency, we do not maintain the list invariant inside the loop
7030     //we append items to the relevant list, and we optimize by not changing pointers
7031     //when subsequent items are going into the same list.
7032     while (w  != q) {
7033         bool currentIsNew =  q->isAncestorOf(w);
7034         if (currentIsNew) {
7035             if (!prevWasNew) {
7036                 //prev was old -- append to new list
7037                 n->d_func()->focus_next = w;
7038                 w->d_func()->focus_prev = n;
7039             }
7040             n = w;
7041         } else {
7042             if (prevWasNew) {
7043                 //prev was new -- append to old list, if there is one
7044                 if (o) {
7045                     o->d_func()->focus_next = w;
7046                     w->d_func()->focus_prev = o;
7047                 } else {
7048                     // "create" the old list
7049                     firstOld = w;
7050                 }
7051             }
7052             o = w;
7053         }
7054         w = w->d_func()->focus_next;
7055         prevWasNew = currentIsNew;
7056     }
7057 
7058     //repair the old list:
7059     if (firstOld) {
7060         o->d_func()->focus_next = firstOld;
7061         firstOld->d_func()->focus_prev = o;
7062     }
7063 
7064     if (!q->isWindow()) {
7065         QWidget *topLevel = q->window();
7066         //insert new chain into toplevel's chain
7067 
7068         QWidget *prev = topLevel->d_func()->focus_prev;
7069 
7070         topLevel->d_func()->focus_prev = n;
7071         prev->d_func()->focus_next = q;
7072 
7073         focus_prev = prev;
7074         n->d_func()->focus_next = topLevel;
7075     } else {
7076         //repair the new list
7077             n->d_func()->focus_next = q;
7078             focus_prev = n;
7079     }
7080 
7081 }
7082 
7083 /*!\internal
7084 
7085   Measures the shortest distance from a point to a rect.
7086 
7087   This function is called from QDesktopwidget::screen(QPoint) to find the
7088   closest screen for a point.
7089   In directional KeypadNavigation, it is called to find the closest
7090   widget to the current focus widget center.
7091 */
7092 int QWidgetPrivate::pointToRect(const QPoint &p, const QRect &r)
7093 {
7094     int dx = 0;
7095     int dy = 0;
7096     if (p.x() < r.left())
7097         dx = r.left() - p.x();
7098     else if (p.x() > r.right())
7099         dx = p.x() - r.right();
7100     if (p.y() < r.top())
7101         dy = r.top() - p.y();
7102     else if (p.y() > r.bottom())
7103         dy = p.y() - r.bottom();
7104     return dx + dy;
7105 }
7106 
7107 /*!
7108     \property QWidget::frameSize
7109     \brief the size of the widget including any window frame
7110 
7111     By default, this property contains a value that depends on the user's
7112     platform and screen geometry.
7113 */
7114 QSize QWidget::frameSize() const
7115 {
7116     Q_D(const QWidget);
7117     if (isWindow() && !(windowType() == Qt::Popup)) {
7118         QRect fs = d->frameStrut();
7119         return QSize(data->crect.width() + fs.left() + fs.right(),
7120                       data->crect.height() + fs.top() + fs.bottom());
7121     }
7122     return data->crect.size();
7123 }
7124 
7125 /*! \fn void QWidget::move(int x, int y)
7126 
7127     \overload
7128 
7129     This corresponds to move(QPoint(\a x, \a y)).
7130 */
7131 
7132 void QWidget::move(const QPoint &p)
7133 {
7134     Q_D(QWidget);
7135     setAttribute(Qt::WA_Moved);
7136     if (testAttribute(Qt::WA_WState_Created)) {
7137         if (isWindow())
7138             d->topData()->posIncludesFrame = false;
7139         d->setGeometry_sys(p.x() + geometry().x() - QWidget::x(),
7140                        p.y() + geometry().y() - QWidget::y(),
7141                        width(), height(), true);
7142         d->setDirtyOpaqueRegion();
7143     } else {
7144         // no frame yet: see also QWidgetPrivate::fixPosIncludesFrame(), QWindowPrivate::PositionPolicy.
7145         if (isWindow())
7146             d->topData()->posIncludesFrame = true;
7147         data->crect.moveTopLeft(p); // no frame yet
7148         setAttribute(Qt::WA_PendingMoveEvent);
7149     }
7150 
7151     if (d->extra && d->extra->hasWindowContainer)
7152         QWindowContainer::parentWasMoved(this);
7153 }
7154 
7155 // move() was invoked with Qt::WA_WState_Created not set (frame geometry
7156 // unknown), that is, crect has a position including the frame.
7157 // If we can determine the frame strut, fix that and clear the flag.
7158 void QWidgetPrivate::fixPosIncludesFrame()
7159 {
7160     Q_Q(QWidget);
7161     if (QTLWExtra *te = maybeTopData()) {
7162         if (te->posIncludesFrame) {
7163             // For Qt::WA_DontShowOnScreen, assume a frame of 0 (for
7164             // example, in QGraphicsProxyWidget).
7165             if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
7166                 te->posIncludesFrame = 0;
7167             } else {
7168                 if (q->windowHandle() && q->windowHandle()->handle()) {
7169                     updateFrameStrut();
7170                     if (!q->data->fstrut_dirty) {
7171                         data.crect.translate(te->frameStrut.x(), te->frameStrut.y());
7172                         te->posIncludesFrame = 0;
7173                     }
7174                 } // windowHandle()
7175             } // !WA_DontShowOnScreen
7176         } // posIncludesFrame
7177     } // QTLWExtra
7178 }
7179 
7180 /*! \fn void QWidget::resize(int w, int h)
7181     \overload
7182 
7183     This corresponds to resize(QSize(\a w, \a h)).
7184 */
7185 
7186 void QWidget::resize(const QSize &s)
7187 {
7188     Q_D(QWidget);
7189     setAttribute(Qt::WA_Resized);
7190     if (testAttribute(Qt::WA_WState_Created)) {
7191         d->fixPosIncludesFrame();
7192         d->setGeometry_sys(geometry().x(), geometry().y(), s.width(), s.height(), false);
7193         d->setDirtyOpaqueRegion();
7194     } else {
7195         data->crect.setSize(s.boundedTo(maximumSize()).expandedTo(minimumSize()));
7196         setAttribute(Qt::WA_PendingResizeEvent);
7197     }
7198 }
7199 
7200 void QWidget::setGeometry(const QRect &r)
7201 {
7202     Q_D(QWidget);
7203     setAttribute(Qt::WA_Resized);
7204     setAttribute(Qt::WA_Moved);
7205     if (isWindow())
7206         d->topData()->posIncludesFrame = 0;
7207     if (testAttribute(Qt::WA_WState_Created)) {
7208         d->setGeometry_sys(r.x(), r.y(), r.width(), r.height(), true);
7209         d->setDirtyOpaqueRegion();
7210     } else {
7211         data->crect.setTopLeft(r.topLeft());
7212         data->crect.setSize(r.size().boundedTo(maximumSize()).expandedTo(minimumSize()));
7213         setAttribute(Qt::WA_PendingMoveEvent);
7214         setAttribute(Qt::WA_PendingResizeEvent);
7215     }
7216 
7217     if (d->extra && d->extra->hasWindowContainer)
7218         QWindowContainer::parentWasMoved(this);
7219 }
7220 
7221 void QWidgetPrivate::setGeometry_sys(int x, int y, int w, int h, bool isMove)
7222 {
7223     Q_Q(QWidget);
7224     if (extra) {                                // any size restrictions?
7225         w = qMin(w,extra->maxw);
7226         h = qMin(h,extra->maxh);
7227         w = qMax(w,extra->minw);
7228         h = qMax(h,extra->minh);
7229     }
7230 
7231     if (q->isWindow() && q->windowHandle()) {
7232         QPlatformIntegration *integration = QGuiApplicationPrivate::platformIntegration();
7233         if (!integration->hasCapability(QPlatformIntegration::NonFullScreenWindows)) {
7234             x = 0;
7235             y = 0;
7236             w = q->windowHandle()->width();
7237             h = q->windowHandle()->height();
7238         }
7239     }
7240 
7241     QPoint oldp = q->geometry().topLeft();
7242     QSize olds = q->size();
7243     QRect r(x, y, w, h);
7244 
7245     bool isResize = olds != r.size();
7246     if (!isMove)
7247         isMove = oldp != r.topLeft();
7248 
7249 
7250     // We only care about stuff that changes the geometry, or may
7251     // cause the window manager to change its state
7252     if (r.size() == olds && oldp == r.topLeft())
7253         return;
7254 
7255     if (!data.in_set_window_state) {
7256         q->data->window_state &= ~Qt::WindowMaximized;
7257         q->data->window_state &= ~Qt::WindowFullScreen;
7258         if (q->isWindow())
7259             topData()->normalGeometry = QRect(0, 0, -1, -1);
7260     }
7261 
7262     QPoint oldPos = q->pos();
7263     data.crect = r;
7264 
7265     bool needsShow = false;
7266 
7267     if (q->isWindow() || q->windowHandle()) {
7268         if (!(data.window_state & Qt::WindowFullScreen) && (w == 0 || h == 0)) {
7269             q->setAttribute(Qt::WA_OutsideWSRange, true);
7270             if (q->isVisible())
7271                 hide_sys();
7272             data.crect = QRect(x, y, w, h);
7273         } else if (q->testAttribute(Qt::WA_OutsideWSRange)) {
7274             q->setAttribute(Qt::WA_OutsideWSRange, false);
7275             needsShow = true;
7276         }
7277     }
7278 
7279     if (q->isVisible()) {
7280         if (!q->testAttribute(Qt::WA_DontShowOnScreen) && !q->testAttribute(Qt::WA_OutsideWSRange)) {
7281             if (QWindow *win = q->windowHandle()) {
7282                 if (q->isWindow()) {
7283                     if (isResize && !isMove)
7284                         win->resize(w, h);
7285                     else if (isMove && !isResize)
7286                         win->setPosition(x, y);
7287                     else
7288                         win->setGeometry(q->geometry());
7289                 } else {
7290                     QPoint posInNativeParent =  q->mapTo(q->nativeParentWidget(),QPoint());
7291                     win->setGeometry(QRect(posInNativeParent,r.size()));
7292                 }
7293 
7294                 if (needsShow)
7295                     show_sys();
7296             }
7297 
7298             if (!q->isWindow()) {
7299                 if (renderToTexture) {
7300                     QRegion updateRegion(q->geometry());
7301                     updateRegion += QRect(oldPos, olds);
7302                     q->parentWidget()->d_func()->invalidateBuffer(updateRegion);
7303                 } else if (isMove && !isResize) {
7304                     moveRect(QRect(oldPos, olds), x - oldPos.x(), y - oldPos.y());
7305                 } else {
7306                     invalidateBuffer_resizeHelper(oldPos, olds);
7307                 }
7308             }
7309         }
7310 
7311         if (isMove) {
7312             QMoveEvent e(q->pos(), oldPos);
7313             QApplication::sendEvent(q, &e);
7314         }
7315         if (isResize) {
7316             QResizeEvent e(r.size(), olds);
7317             QApplication::sendEvent(q, &e);
7318             if (q->windowHandle())
7319                 q->update();
7320         }
7321     } else { // not visible
7322         if (isMove && q->pos() != oldPos)
7323             q->setAttribute(Qt::WA_PendingMoveEvent, true);
7324         if (isResize)
7325             q->setAttribute(Qt::WA_PendingResizeEvent, true);
7326     }
7327 
7328 }
7329 
7330 /*!
7331     \since 4.2
7332     Saves the current geometry and state for top-level widgets.
7333 
7334     To save the geometry when the window closes, you can
7335     implement a close event like this:
7336 
7337     \snippet code/src_gui_kernel_qwidget.cpp 11
7338 
7339     See the \l{Window Geometry} documentation for an overview of geometry
7340     issues with windows.
7341 
7342     Use QMainWindow::saveState() to save the geometry and the state of
7343     toolbars and dock widgets.
7344 
7345     \sa restoreGeometry(), QMainWindow::saveState(), QMainWindow::restoreState()
7346 */
7347 QByteArray QWidget::saveGeometry() const
7348 {
7349 #if 0 // Used to be included in Qt4 for Q_WS_MAC
7350     // We check if the window was maximized during this invocation. If so, we need to record the
7351     // starting position as 0,0.
7352     Q_D(const QWidget);
7353     QRect newFramePosition = frameGeometry();
7354     QRect newNormalPosition = normalGeometry();
7355     if(d->topData()->wasMaximized && !(windowState() & Qt::WindowMaximized)) {
7356         // Change the starting position
7357         newFramePosition.moveTo(0, 0);
7358         newNormalPosition.moveTo(0, 0);
7359     }
7360 #endif
7361     QByteArray array;
7362     QDataStream stream(&array, QIODevice::WriteOnly);
7363     stream.setVersion(QDataStream::Qt_4_0);
7364     const quint32 magicNumber = 0x1D9D0CB;
7365     // Version history:
7366     // - Qt 4.2 - 4.8.6, 5.0 - 5.3    : Version 1.0
7367     // - Qt 4.8.6 - today, 5.4 - today: Version 2.0, save screen width in addition to check for high DPI scaling.
7368     quint16 majorVersion = 2;
7369     quint16 minorVersion = 0;
7370     const int screenNumber = QDesktopWidgetPrivate::screenNumber(this);
7371     stream << magicNumber
7372            << majorVersion
7373            << minorVersion
7374 #if 0 // Used to be included in Qt4 for Q_WS_MAC
7375            << newFramePosition
7376            << newNormalPosition
7377 #else
7378            << frameGeometry()
7379            << normalGeometry()
7380 #endif
7381            << qint32(screenNumber)
7382            << quint8(windowState() & Qt::WindowMaximized)
7383            << quint8(windowState() & Qt::WindowFullScreen)
7384            << qint32(QDesktopWidgetPrivate::screenGeometry(screenNumber).width()); // 1.1 onwards
7385     return array;
7386 }
7387 
7388 /*!
7389     \since 4.2
7390 
7391     Restores the geometry and state of top-level widgets stored in the
7392     byte array \a geometry. Returns \c true on success; otherwise
7393     returns \c false.
7394 
7395     If the restored geometry is off-screen, it will be modified to be
7396     inside the available screen geometry.
7397 
7398     To restore geometry saved using QSettings, you can use code like
7399     this:
7400 
7401     \snippet code/src_gui_kernel_qwidget.cpp 12
7402 
7403     See the \l{Window Geometry} documentation for an overview of geometry
7404     issues with windows.
7405 
7406     Use QMainWindow::restoreState() to restore the geometry and the
7407     state of toolbars and dock widgets.
7408 
7409     \sa saveGeometry(), QSettings, QMainWindow::saveState(), QMainWindow::restoreState()
7410 */
7411 bool QWidget::restoreGeometry(const QByteArray &geometry)
7412 {
7413     if (geometry.size() < 4)
7414         return false;
7415     QDataStream stream(geometry);
7416     stream.setVersion(QDataStream::Qt_4_0);
7417 
7418     const quint32 magicNumber = 0x1D9D0CB;
7419     quint32 storedMagicNumber;
7420     stream >> storedMagicNumber;
7421     if (storedMagicNumber != magicNumber)
7422         return false;
7423 
7424     const quint16 currentMajorVersion = 2;
7425     quint16 majorVersion = 0;
7426     quint16 minorVersion = 0;
7427 
7428     stream >> majorVersion >> minorVersion;
7429 
7430     if (majorVersion > currentMajorVersion)
7431         return false;
7432     // (Allow all minor versions.)
7433 
7434     QRect restoredFrameGeometry;
7435      QRect restoredNormalGeometry;
7436     qint32 restoredScreenNumber;
7437     quint8 maximized;
7438     quint8 fullScreen;
7439     qint32 restoredScreenWidth = 0;
7440 
7441     stream >> restoredFrameGeometry
7442            >> restoredNormalGeometry
7443            >> restoredScreenNumber
7444            >> maximized
7445            >> fullScreen;
7446 
7447     if (majorVersion > 1)
7448         stream >> restoredScreenWidth;
7449 
7450     if (restoredScreenNumber >= QDesktopWidgetPrivate::numScreens())
7451         restoredScreenNumber = QDesktopWidgetPrivate::primaryScreen();
7452     const qreal screenWidthF = qreal(QDesktopWidgetPrivate::screenGeometry(restoredScreenNumber).width());
7453     // Sanity check bailing out when large variations of screen sizes occur due to
7454     // high DPI scaling or different levels of DPI awareness.
7455     if (restoredScreenWidth) {
7456         const qreal factor = qreal(restoredScreenWidth) / screenWidthF;
7457         if (factor < 0.8 || factor > 1.25)
7458             return false;
7459     } else {
7460         // Saved by Qt 5.3 and earlier, try to prevent too large windows
7461         // unless the size will be adapted by maximized or fullscreen.
7462         if (!maximized && !fullScreen && qreal(restoredFrameGeometry.width()) / screenWidthF > 1.5)
7463             return false;
7464     }
7465 
7466     const int frameHeight = 20;
7467     if (!restoredFrameGeometry.isValid())
7468         restoredFrameGeometry = QRect(QPoint(0,0), sizeHint());
7469 
7470     if (!restoredNormalGeometry.isValid())
7471         restoredNormalGeometry = QRect(QPoint(0, frameHeight), sizeHint());
7472     if (!restoredNormalGeometry.isValid()) {
7473         // use the widget's adjustedSize if the sizeHint() doesn't help
7474         restoredNormalGeometry.setSize(restoredNormalGeometry
7475                                        .size()
7476                                        .expandedTo(d_func()->adjustedSize()));
7477     }
7478 
7479     const QRect availableGeometry = QDesktopWidgetPrivate::availableGeometry(restoredScreenNumber);
7480 
7481     // Modify the restored geometry if we are about to restore to coordinates
7482     // that would make the window "lost". This happens if:
7483     // - The restored geometry is completely oustside the available geometry
7484     // - The title bar is outside the available geometry.
7485     // - (Mac only) The window is higher than the available geometry. It must
7486     //   be possible to bring the size grip on screen by moving the window.
7487 #if 0 // Used to be included in Qt4 for Q_WS_MAC
7488     restoredFrameGeometry.setHeight(qMin(restoredFrameGeometry.height(), availableGeometry.height()));
7489     restoredNormalGeometry.setHeight(qMin(restoredNormalGeometry.height(), availableGeometry.height() - frameHeight));
7490 #endif
7491 
7492     if (!restoredFrameGeometry.intersects(availableGeometry)) {
7493         restoredFrameGeometry.moveBottom(qMin(restoredFrameGeometry.bottom(), availableGeometry.bottom()));
7494         restoredFrameGeometry.moveLeft(qMax(restoredFrameGeometry.left(), availableGeometry.left()));
7495         restoredFrameGeometry.moveRight(qMin(restoredFrameGeometry.right(), availableGeometry.right()));
7496     }
7497     restoredFrameGeometry.moveTop(qMax(restoredFrameGeometry.top(), availableGeometry.top()));
7498 
7499     if (!restoredNormalGeometry.intersects(availableGeometry)) {
7500         restoredNormalGeometry.moveBottom(qMin(restoredNormalGeometry.bottom(), availableGeometry.bottom()));
7501         restoredNormalGeometry.moveLeft(qMax(restoredNormalGeometry.left(), availableGeometry.left()));
7502         restoredNormalGeometry.moveRight(qMin(restoredNormalGeometry.right(), availableGeometry.right()));
7503     }
7504     restoredNormalGeometry.moveTop(qMax(restoredNormalGeometry.top(), availableGeometry.top() + frameHeight));
7505 
7506     if (maximized || fullScreen) {
7507         // set geometry before setting the window state to make
7508         // sure the window is maximized to the right screen.
7509         Qt::WindowStates ws = windowState();
7510 #ifndef Q_OS_WIN
7511         setGeometry(restoredNormalGeometry);
7512 #else
7513         if (ws & Qt::WindowFullScreen) {
7514             // Full screen is not a real window state on Windows.
7515             move(availableGeometry.topLeft());
7516         } else if (ws & Qt::WindowMaximized) {
7517             // Setting a geometry on an already maximized window causes this to be
7518             // restored into a broken, half-maximized state, non-resizable state (QTBUG-4397).
7519             // Move the window in normal state if needed.
7520             if (restoredScreenNumber != QDesktopWidgetPrivate::screenNumber(this)) {
7521                 setWindowState(Qt::WindowNoState);
7522                 setGeometry(restoredNormalGeometry);
7523             }
7524         } else {
7525             setGeometry(restoredNormalGeometry);
7526         }
7527 #endif // Q_OS_WIN
7528         if (maximized)
7529             ws |= Qt::WindowMaximized;
7530         if (fullScreen)
7531             ws |= Qt::WindowFullScreen;
7532        setWindowState(ws);
7533        d_func()->topData()->normalGeometry = restoredNormalGeometry;
7534     } else {
7535         QPoint offset;
7536 #if 0 // Used to be included in Qt4 for Q_WS_X11
7537         if (isFullScreen())
7538             offset = d_func()->topData()->fullScreenOffset;
7539 #endif
7540         setWindowState(windowState() & ~(Qt::WindowMaximized | Qt::WindowFullScreen));
7541         move(restoredFrameGeometry.topLeft() + offset);
7542         resize(restoredNormalGeometry.size());
7543     }
7544     return true;
7545 }
7546 
7547 /*!\fn void QWidget::setGeometry(int x, int y, int w, int h)
7548     \overload
7549 
7550     This corresponds to setGeometry(QRect(\a x, \a y, \a w, \a h)).
7551 */
7552 
7553 /*!
7554   Sets the margins around the contents of the widget to have the sizes
7555   \a left, \a top, \a right, and \a bottom. The margins are used by
7556   the layout system, and may be used by subclasses to specify the area
7557   to draw in (e.g. excluding the frame).
7558 
7559   Changing the margins will trigger a resizeEvent().
7560 
7561   \sa contentsRect(), getContentsMargins()
7562 */
7563 void QWidget::setContentsMargins(int left, int top, int right, int bottom)
7564 {
7565     Q_D(QWidget);
7566     if (left == d->leftmargin && top == d->topmargin
7567          && right == d->rightmargin && bottom == d->bottommargin)
7568         return;
7569     d->leftmargin = left;
7570     d->topmargin = top;
7571     d->rightmargin = right;
7572     d->bottommargin = bottom;
7573 
7574     if (QLayout *l=d->layout)
7575         l->update(); //force activate; will do updateGeometry
7576     else
7577         updateGeometry();
7578 
7579     if (isVisible()) {
7580         update();
7581         QResizeEvent e(data->crect.size(), data->crect.size());
7582         QApplication::sendEvent(this, &e);
7583     } else {
7584         setAttribute(Qt::WA_PendingResizeEvent, true);
7585     }
7586 
7587     QEvent e(QEvent::ContentsRectChange);
7588     QApplication::sendEvent(this, &e);
7589 }
7590 
7591 /*!
7592   \overload
7593   \since 4.6
7594 
7595   \brief The setContentsMargins function sets the margins around the
7596   widget's contents.
7597 
7598   Sets the margins around the contents of the widget to have the
7599   sizes determined by \a margins. The margins are
7600   used by the layout system, and may be used by subclasses to
7601   specify the area to draw in (e.g. excluding the frame).
7602 
7603   Changing the margins will trigger a resizeEvent().
7604 
7605   \sa contentsRect(), getContentsMargins()
7606 */
7607 void QWidget::setContentsMargins(const QMargins &margins)
7608 {
7609     setContentsMargins(margins.left(), margins.top(),
7610                        margins.right(), margins.bottom());
7611 }
7612 
7613 /*!
7614   Returns the widget's contents margins for \a left, \a top, \a
7615   right, and \a bottom.
7616 
7617   \sa setContentsMargins(), contentsRect()
7618  */
7619 void QWidget::getContentsMargins(int *left, int *top, int *right, int *bottom) const
7620 {
7621     Q_D(const QWidget);
7622     if (left)
7623         *left = d->leftmargin;
7624     if (top)
7625         *top = d->topmargin;
7626     if (right)
7627         *right = d->rightmargin;
7628     if (bottom)
7629         *bottom = d->bottommargin;
7630 }
7631 
7632 /*!
7633   \since 4.6
7634 
7635   \brief The contentsMargins function returns the widget's contents margins.
7636 
7637   \sa getContentsMargins(), setContentsMargins(), contentsRect()
7638  */
7639 QMargins QWidget::contentsMargins() const
7640 {
7641     Q_D(const QWidget);
7642     return QMargins(d->leftmargin, d->topmargin, d->rightmargin, d->bottommargin);
7643 }
7644 
7645 
7646 /*!
7647     Returns the area inside the widget's margins.
7648 
7649     \sa setContentsMargins(), getContentsMargins()
7650 */
7651 QRect QWidget::contentsRect() const
7652 {
7653     Q_D(const QWidget);
7654     return QRect(QPoint(d->leftmargin, d->topmargin),
7655                  QPoint(data->crect.width() - 1 - d->rightmargin,
7656                         data->crect.height() - 1 - d->bottommargin));
7657 
7658 }
7659 
7660 
7661 
7662 /*!
7663   \fn void QWidget::customContextMenuRequested(const QPoint &pos)
7664 
7665   This signal is emitted when the widget's \l contextMenuPolicy is
7666   Qt::CustomContextMenu, and the user has requested a context menu on
7667   the widget. The position \a pos is the position of the context menu
7668   event that the widget receives. Normally this is in widget
7669   coordinates. The exception to this rule is QAbstractScrollArea and
7670   its subclasses that map the context menu event to coordinates of the
7671   \l{QAbstractScrollArea::viewport()}{viewport()}.
7672 
7673 
7674   \sa mapToGlobal(), QMenu, contextMenuPolicy
7675 */
7676 
7677 
7678 /*!
7679     \property QWidget::contextMenuPolicy
7680     \brief how the widget shows a context menu
7681 
7682     The default value of this property is Qt::DefaultContextMenu,
7683     which means the contextMenuEvent() handler is called. Other values
7684     are Qt::NoContextMenu, Qt::PreventContextMenu,
7685     Qt::ActionsContextMenu, and Qt::CustomContextMenu. With
7686     Qt::CustomContextMenu, the signal customContextMenuRequested() is
7687     emitted.
7688 
7689     \sa contextMenuEvent(), customContextMenuRequested(), actions()
7690 */
7691 
7692 Qt::ContextMenuPolicy QWidget::contextMenuPolicy() const
7693 {
7694     return (Qt::ContextMenuPolicy)data->context_menu_policy;
7695 }
7696 
7697 void QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy)
7698 {
7699     data->context_menu_policy = (uint) policy;
7700 }
7701 
7702 /*!
7703     \property QWidget::focusPolicy
7704     \brief the way the widget accepts keyboard focus
7705 
7706     The policy is Qt::TabFocus if the widget accepts keyboard
7707     focus by tabbing, Qt::ClickFocus if the widget accepts
7708     focus by clicking, Qt::StrongFocus if it accepts both, and
7709     Qt::NoFocus (the default) if it does not accept focus at
7710     all.
7711 
7712     You must enable keyboard focus for a widget if it processes
7713     keyboard events. This is normally done from the widget's
7714     constructor. For instance, the QLineEdit constructor calls
7715     setFocusPolicy(Qt::StrongFocus).
7716 
7717     If the widget has a focus proxy, then the focus policy will
7718     be propagated to it.
7719 
7720     \sa focusInEvent(), focusOutEvent(), keyPressEvent(), keyReleaseEvent(), enabled
7721 */
7722 
7723 
7724 Qt::FocusPolicy QWidget::focusPolicy() const
7725 {
7726     return (Qt::FocusPolicy)data->focus_policy;
7727 }
7728 
7729 void QWidget::setFocusPolicy(Qt::FocusPolicy policy)
7730 {
7731     data->focus_policy = (uint) policy;
7732     Q_D(QWidget);
7733     if (d->extra && d->extra->focus_proxy)
7734         d->extra->focus_proxy->setFocusPolicy(policy);
7735 }
7736 
7737 /*!
7738     \property QWidget::updatesEnabled
7739     \brief whether updates are enabled
7740 
7741     An updates enabled widget receives paint events and has a system
7742     background; a disabled widget does not. This also implies that
7743     calling update() and repaint() has no effect if updates are
7744     disabled.
7745 
7746     By default, this property is \c true.
7747 
7748     setUpdatesEnabled() is normally used to disable updates for a
7749     short period of time, for instance to avoid screen flicker during
7750     large changes. In Qt, widgets normally do not generate screen
7751     flicker, but on X11 the server might erase regions on the screen
7752     when widgets get hidden before they can be replaced by other
7753     widgets. Disabling updates solves this.
7754 
7755     Example:
7756     \snippet code/src_gui_kernel_qwidget.cpp 13
7757 
7758     Disabling a widget implicitly disables all its children. Enabling a widget
7759     enables all child widgets \e except top-level widgets or those that
7760     have been explicitly disabled. Re-enabling updates implicitly calls
7761     update() on the widget.
7762 
7763     \sa paintEvent()
7764 */
7765 void QWidget::setUpdatesEnabled(bool enable)
7766 {
7767     Q_D(QWidget);
7768     setAttribute(Qt::WA_ForceUpdatesDisabled, !enable);
7769     d->setUpdatesEnabled_helper(enable);
7770 }
7771 
7772 /*!
7773     Shows the widget and its child widgets.
7774 
7775     This is equivalent to calling showFullScreen(), showMaximized(), or setVisible(true),
7776     depending on the platform's default behavior for the window flags.
7777 
7778      \sa raise(), showEvent(), hide(), setVisible(), showMinimized(), showMaximized(),
7779     showNormal(), isVisible(), windowFlags()
7780 */
7781 void QWidget::show()
7782 {
7783     Qt::WindowState defaultState = QGuiApplicationPrivate::platformIntegration()->defaultWindowState(data->window_flags);
7784     if (defaultState == Qt::WindowFullScreen)
7785         showFullScreen();
7786     else if (defaultState == Qt::WindowMaximized)
7787         showMaximized();
7788     else
7789         setVisible(true); // FIXME: Why not showNormal(), like QWindow::show()?
7790 }
7791 
7792 /*! \internal
7793 
7794    Makes the widget visible in the isVisible() meaning of the word.
7795    It is only called for toplevels or widgets with visible parents.
7796  */
7797 void QWidgetPrivate::show_recursive()
7798 {
7799     Q_Q(QWidget);
7800     // polish if necessary
7801 
7802     if (!q->testAttribute(Qt::WA_WState_Created))
7803         createRecursively();
7804     q->ensurePolished();
7805 
7806     if (!q->isWindow() && q->parentWidget()->d_func()->layout && !q->parentWidget()->data->in_show)
7807         q->parentWidget()->d_func()->layout->activate();
7808     // activate our layout before we and our children become visible
7809     if (layout)
7810         layout->activate();
7811 
7812     show_helper();
7813 }
7814 
7815 void QWidgetPrivate::sendPendingMoveAndResizeEvents(bool recursive, bool disableUpdates)
7816 {
7817     Q_Q(QWidget);
7818 
7819     disableUpdates = disableUpdates && q->updatesEnabled();
7820     if (disableUpdates)
7821         q->setAttribute(Qt::WA_UpdatesDisabled);
7822 
7823     if (q->testAttribute(Qt::WA_PendingMoveEvent)) {
7824         QMoveEvent e(data.crect.topLeft(), data.crect.topLeft());
7825         QApplication::sendEvent(q, &e);
7826         q->setAttribute(Qt::WA_PendingMoveEvent, false);
7827     }
7828 
7829     if (q->testAttribute(Qt::WA_PendingResizeEvent)) {
7830         QResizeEvent e(data.crect.size(), QSize());
7831         QApplication::sendEvent(q, &e);
7832         q->setAttribute(Qt::WA_PendingResizeEvent, false);
7833     }
7834 
7835     if (disableUpdates)
7836         q->setAttribute(Qt::WA_UpdatesDisabled, false);
7837 
7838     if (!recursive)
7839         return;
7840 
7841     for (int i = 0; i < children.size(); ++i) {
7842         if (QWidget *child = qobject_cast<QWidget *>(children.at(i)))
7843             child->d_func()->sendPendingMoveAndResizeEvents(recursive, disableUpdates);
7844     }
7845 }
7846 
7847 void QWidgetPrivate::activateChildLayoutsRecursively()
7848 {
7849     sendPendingMoveAndResizeEvents(false, true);
7850 
7851     for (int i = 0; i < children.size(); ++i) {
7852         QWidget *child = qobject_cast<QWidget *>(children.at(i));
7853         if (!child || child->isHidden() || child->isWindow())
7854             continue;
7855 
7856         child->ensurePolished();
7857 
7858         // Activate child's layout
7859         QWidgetPrivate *childPrivate = child->d_func();
7860         if (childPrivate->layout)
7861             childPrivate->layout->activate();
7862 
7863         // Pretend we're visible.
7864         const bool wasVisible = child->isVisible();
7865         if (!wasVisible)
7866             child->setAttribute(Qt::WA_WState_Visible);
7867 
7868         // Do the same for all my children.
7869         childPrivate->activateChildLayoutsRecursively();
7870 
7871         // We're not cheating anymore.
7872         if (!wasVisible)
7873             child->setAttribute(Qt::WA_WState_Visible, false);
7874     }
7875 }
7876 
7877 void QWidgetPrivate::show_helper()
7878 {
7879     Q_Q(QWidget);
7880     data.in_show = true; // qws optimization
7881     // make sure we receive pending move and resize events
7882     sendPendingMoveAndResizeEvents();
7883 
7884     // become visible before showing all children
7885     q->setAttribute(Qt::WA_WState_Visible);
7886 
7887     // finally show all children recursively
7888     showChildren(false);
7889 
7890 
7891 
7892     const bool isWindow = q->isWindow();
7893 #if QT_CONFIG(graphicsview)
7894     bool isEmbedded = isWindow && q->graphicsProxyWidget() != nullptr;
7895 #else
7896     bool isEmbedded = false;
7897 #endif
7898 
7899     // popup handling: new popups and tools need to be raised, and
7900     // existing popups must be closed. Also propagate the current
7901     // windows's KeyboardFocusChange status.
7902     if (isWindow && !isEmbedded) {
7903         if ((q->windowType() == Qt::Tool) || (q->windowType() == Qt::Popup) || q->windowType() == Qt::ToolTip) {
7904             q->raise();
7905             if (q->parentWidget() && q->parentWidget()->window()->testAttribute(Qt::WA_KeyboardFocusChange))
7906                 q->setAttribute(Qt::WA_KeyboardFocusChange);
7907         } else {
7908             while (QApplication::activePopupWidget()) {
7909                 if (!QApplication::activePopupWidget()->close())
7910                     break;
7911             }
7912         }
7913     }
7914 
7915     // Automatic embedding of child windows of widgets already embedded into
7916     // QGraphicsProxyWidget when they are shown the first time.
7917 #if QT_CONFIG(graphicsview)
7918     if (isWindow) {
7919         if (!isEmbedded && !bypassGraphicsProxyWidget(q)) {
7920             QGraphicsProxyWidget *ancestorProxy = nearestGraphicsProxyWidget(q->parentWidget());
7921             if (ancestorProxy) {
7922                 isEmbedded = true;
7923                 ancestorProxy->d_func()->embedSubWindow(q);
7924             }
7925         }
7926     }
7927 #else
7928     Q_UNUSED(isEmbedded);
7929 #endif
7930 
7931     // On Windows, show the popup now so that our own focus handling
7932     // stores the correct old focus widget even if it's stolen in the
7933     // showevent
7934 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_MAC */
7935     if (!isEmbedded && q->windowType() == Qt::Popup)
7936         qApp->d_func()->openPopup(q);
7937 #endif
7938 
7939     // send the show event before showing the window
7940     QShowEvent showEvent;
7941     QApplication::sendEvent(q, &showEvent);
7942 
7943     show_sys();
7944 
7945     if (!isEmbedded && q->windowType() == Qt::Popup)
7946         qApp->d_func()->openPopup(q);
7947 
7948 #ifndef QT_NO_ACCESSIBILITY
7949     if (q->windowType() != Qt::ToolTip) {    // Tooltips are read aloud twice in MS narrator.
7950         QAccessibleEvent event(q, QAccessible::ObjectShow);
7951         QAccessible::updateAccessibility(&event);
7952     }
7953 #endif
7954 
7955     if (QApplicationPrivate::hidden_focus_widget == q) {
7956         QApplicationPrivate::hidden_focus_widget = 0;
7957         q->setFocus(Qt::OtherFocusReason);
7958     }
7959 
7960     // Process events when showing a Qt::SplashScreen widget before the event loop
7961     // is spinnning; otherwise it might not show up on particular platforms.
7962     // This makes QSplashScreen behave the same on all platforms.
7963     if (!qApp->d_func()->in_exec && q->windowType() == Qt::SplashScreen)
7964         QApplication::processEvents();
7965 
7966     data.in_show = false;  // reset qws optimization
7967 }
7968 
7969 void QWidgetPrivate::show_sys()
7970 {
7971     Q_Q(QWidget);
7972 
7973     QWidgetWindow *window = windowHandle();
7974 
7975     if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
7976         invalidateBuffer(q->rect());
7977         q->setAttribute(Qt::WA_Mapped);
7978         // add our window the modal window list (native dialogs)
7979         if (window && q->isWindow()
7980 #if QT_CONFIG(graphicsview)
7981             && (!extra || !extra->proxyWidget)
7982 #endif
7983             && q->windowModality() != Qt::NonModal) {
7984             QGuiApplicationPrivate::showModalWindow(window);
7985         }
7986         return;
7987     }
7988 
7989     if (renderToTexture && !q->isWindow())
7990         QApplication::postEvent(q->parentWidget(), new QUpdateLaterEvent(q->geometry()));
7991     else
7992         QApplication::postEvent(q, new QUpdateLaterEvent(q->rect()));
7993 
7994     if ((!q->isWindow() && !q->testAttribute(Qt::WA_NativeWindow))
7995             || q->testAttribute(Qt::WA_OutsideWSRange)) {
7996         return;
7997     }
7998 
7999     if (window) {
8000         if (q->isWindow())
8001             fixPosIncludesFrame();
8002         QRect geomRect = q->geometry();
8003         if (!q->isWindow()) {
8004             QPoint topLeftOfWindow = q->mapTo(q->nativeParentWidget(),QPoint());
8005             geomRect.moveTopLeft(topLeftOfWindow);
8006         }
8007         const QRect windowRect = window->geometry();
8008         if (windowRect != geomRect) {
8009             if (q->testAttribute(Qt::WA_Moved)
8010                 || !QGuiApplicationPrivate::platformIntegration()->hasCapability(QPlatformIntegration::WindowManagement))
8011                 window->setGeometry(geomRect);
8012             else
8013                 window->resize(geomRect.size());
8014         }
8015 
8016 #ifndef QT_NO_CURSOR
8017         qt_qpa_set_cursor(q, false); // Needed in case cursor was set before show
8018 #endif
8019         invalidateBuffer(q->rect());
8020         window->setNativeWindowVisibility(true);
8021         // Was the window moved by the Window system or QPlatformWindow::initialGeometry() ?
8022         if (window->isTopLevel()) {
8023             const QPoint crectTopLeft = q->data->crect.topLeft();
8024             const QPoint windowTopLeft = window->geometry().topLeft();
8025             if (crectTopLeft == QPoint(0, 0) && windowTopLeft != crectTopLeft)
8026                 q->data->crect.moveTopLeft(windowTopLeft);
8027         }
8028     }
8029 }
8030 
8031 /*!
8032     Hides the widget. This function is equivalent to
8033     setVisible(false).
8034 
8035 
8036     \note If you are working with QDialog or its subclasses and you invoke
8037     the show() function after this function, the dialog will be displayed in
8038     its original position.
8039 
8040     \sa hideEvent(), isHidden(), show(), setVisible(), isVisible(), close()
8041 */
8042 void QWidget::hide()
8043 {
8044     setVisible(false);
8045 }
8046 
8047 /*!\internal
8048  */
8049 void QWidgetPrivate::hide_helper()
8050 {
8051     Q_Q(QWidget);
8052 
8053     bool isEmbedded = false;
8054 #if QT_CONFIG(graphicsview)
8055     isEmbedded = q->isWindow() && !bypassGraphicsProxyWidget(q) && nearestGraphicsProxyWidget(q->parentWidget()) != 0;
8056 #else
8057     Q_UNUSED(isEmbedded);
8058 #endif
8059 
8060     if (!isEmbedded && (q->windowType() == Qt::Popup))
8061         qApp->d_func()->closePopup(q);
8062 
8063 #if 0 // Used to be included in Qt4 for Q_WS_WIN
8064     if (q->isWindow() && !(q->windowType() == Qt::Popup) && q->parentWidget()
8065         && !q->parentWidget()->isHidden() && q->isActiveWindow())
8066         q->parentWidget()->activateWindow();        // Activate parent
8067 #endif
8068 
8069     q->setAttribute(Qt::WA_Mapped, false);
8070     hide_sys();
8071 
8072     bool wasVisible = q->testAttribute(Qt::WA_WState_Visible);
8073 
8074     if (wasVisible) {
8075         q->setAttribute(Qt::WA_WState_Visible, false);
8076 
8077     }
8078 
8079     QHideEvent hideEvent;
8080     QApplication::sendEvent(q, &hideEvent);
8081     hideChildren(false);
8082 
8083     // next bit tries to move the focus if the focus widget is now
8084     // hidden.
8085     if (wasVisible) {
8086         qApp->d_func()->sendSyntheticEnterLeave(q);
8087         QWidget *fw = QApplication::focusWidget();
8088         while (fw &&  !fw->isWindow()) {
8089             if (fw == q) {
8090                 q->focusNextPrevChild(true);
8091                 break;
8092             }
8093             fw = fw->parentWidget();
8094         }
8095     }
8096 
8097     if (QWidgetBackingStore *bs = maybeBackingStore())
8098         bs->removeDirtyWidget(q);
8099 
8100 #ifndef QT_NO_ACCESSIBILITY
8101     if (wasVisible) {
8102         QAccessibleEvent event(q, QAccessible::ObjectHide);
8103         QAccessible::updateAccessibility(&event);
8104     }
8105 #endif
8106 }
8107 
8108 void QWidgetPrivate::hide_sys()
8109 {
8110     Q_Q(QWidget);
8111 
8112     QWidgetWindow *window = windowHandle();
8113 
8114     if (q->testAttribute(Qt::WA_DontShowOnScreen)) {
8115         q->setAttribute(Qt::WA_Mapped, false);
8116         // remove our window from the modal window list (native dialogs)
8117         if (window && q->isWindow()
8118 #if QT_CONFIG(graphicsview)
8119             && (!extra || !extra->proxyWidget)
8120 #endif
8121             && q->windowModality() != Qt::NonModal) {
8122             QGuiApplicationPrivate::hideModalWindow(window);
8123         }
8124         // do not return here, if window non-zero, we must hide it
8125     }
8126 
8127     deactivateWidgetCleanup();
8128 
8129     if (!q->isWindow()) {
8130         QWidget *p = q->parentWidget();
8131         if (p &&p->isVisible()) {
8132             if (renderToTexture)
8133                 p->d_func()->invalidateBuffer(q->geometry());
8134             else
8135                 invalidateBuffer(q->rect());
8136         }
8137     } else {
8138         invalidateBuffer(q->rect());
8139     }
8140 
8141     if (window)
8142         window->setNativeWindowVisibility(false);
8143 }
8144 
8145 /*!
8146     \fn bool QWidget::isHidden() const
8147 
8148     Returns \c true if the widget is hidden, otherwise returns \c false.
8149 
8150     A hidden widget will only become visible when show() is called on
8151     it. It will not be automatically shown when the parent is shown.
8152 
8153     To check visibility, use !isVisible() instead (notice the exclamation mark).
8154 
8155     isHidden() implies !isVisible(), but a widget can be not visible
8156     and not hidden at the same time. This is the case for widgets that are children of
8157     widgets that are not visible.
8158 
8159 
8160     Widgets are hidden if:
8161     \list
8162         \li they were created as independent windows,
8163         \li they were created as children of visible widgets,
8164         \li hide() or setVisible(false) was called.
8165     \endlist
8166 */
8167 
8168 
8169 void QWidget::setVisible(bool visible)
8170 {
8171     if (visible) { // show
8172         if (testAttribute(Qt::WA_WState_ExplicitShowHide) && !testAttribute(Qt::WA_WState_Hidden))
8173             return;
8174 
8175         Q_D(QWidget);
8176 
8177         // Designer uses a trick to make grabWidget work without showing
8178         if (!isWindow() && parentWidget() && parentWidget()->isVisible()
8179             && !parentWidget()->testAttribute(Qt::WA_WState_Created))
8180             parentWidget()->window()->d_func()->createRecursively();
8181 
8182         //create toplevels but not children of non-visible parents
8183         QWidget *pw = parentWidget();
8184         if (!testAttribute(Qt::WA_WState_Created)
8185             && (isWindow() || pw->testAttribute(Qt::WA_WState_Created))) {
8186             create();
8187         }
8188 
8189         bool wasResized = testAttribute(Qt::WA_Resized);
8190         Qt::WindowStates initialWindowState = windowState();
8191 
8192         // polish if necessary
8193         ensurePolished();
8194 
8195         // remember that show was called explicitly
8196         setAttribute(Qt::WA_WState_ExplicitShowHide);
8197         // whether we need to inform the parent widget immediately
8198         bool needUpdateGeometry = !isWindow() && testAttribute(Qt::WA_WState_Hidden);
8199         // we are no longer hidden
8200         setAttribute(Qt::WA_WState_Hidden, false);
8201 
8202         if (needUpdateGeometry)
8203             d->updateGeometry_helper(true);
8204 
8205         // activate our layout before we and our children become visible
8206         if (d->layout)
8207             d->layout->activate();
8208 
8209         if (!isWindow()) {
8210             QWidget *parent = parentWidget();
8211             while (parent && parent->isVisible() && parent->d_func()->layout  && !parent->data->in_show) {
8212                 parent->d_func()->layout->activate();
8213                 if (parent->isWindow())
8214                     break;
8215                 parent = parent->parentWidget();
8216             }
8217             if (parent)
8218                 parent->d_func()->setDirtyOpaqueRegion();
8219         }
8220 
8221         // adjust size if necessary
8222         if (!wasResized
8223             && (isWindow() || !parentWidget()->d_func()->layout))  {
8224             if (isWindow()) {
8225                 adjustSize();
8226                 if (windowState() != initialWindowState)
8227                     setWindowState(initialWindowState);
8228             } else {
8229                 adjustSize();
8230             }
8231             setAttribute(Qt::WA_Resized, false);
8232         }
8233 
8234         setAttribute(Qt::WA_KeyboardFocusChange, false);
8235 
8236         if (isWindow() || parentWidget()->isVisible()) {
8237             d->show_helper();
8238 
8239             qApp->d_func()->sendSyntheticEnterLeave(this);
8240         }
8241 
8242         QEvent showToParentEvent(QEvent::ShowToParent);
8243         QApplication::sendEvent(this, &showToParentEvent);
8244     } else { // hide
8245         if (testAttribute(Qt::WA_WState_ExplicitShowHide) && testAttribute(Qt::WA_WState_Hidden))
8246             return;
8247 #if 0 // Used to be included in Qt4 for Q_WS_WIN
8248         // reset WS_DISABLED style in a Blocked window
8249         if(isWindow() && testAttribute(Qt::WA_WState_Created)
8250            && QApplicationPrivate::isBlockedByModal(this))
8251         {
8252             LONG dwStyle = GetWindowLong(winId(), GWL_STYLE);
8253             dwStyle &= ~WS_DISABLED;
8254             SetWindowLong(winId(), GWL_STYLE, dwStyle);
8255         }
8256 #endif
8257         if (QApplicationPrivate::hidden_focus_widget == this)
8258             QApplicationPrivate::hidden_focus_widget = 0;
8259 
8260         Q_D(QWidget);
8261 
8262         // hw: The test on getOpaqueRegion() needs to be more intelligent
8263         // currently it doesn't work if the widget is hidden (the region will
8264         // be clipped). The real check should be testing the cached region
8265         // (and dirty flag) directly.
8266         if (!isWindow() && parentWidget()) // && !d->getOpaqueRegion().isEmpty())
8267             parentWidget()->d_func()->setDirtyOpaqueRegion();
8268 
8269         setAttribute(Qt::WA_WState_Hidden);
8270         setAttribute(Qt::WA_WState_ExplicitShowHide);
8271         if (testAttribute(Qt::WA_WState_Created))
8272             d->hide_helper();
8273 
8274         // invalidate layout similar to updateGeometry()
8275         if (!isWindow() && parentWidget()) {
8276             if (parentWidget()->d_func()->layout)
8277                 parentWidget()->d_func()->layout->invalidate();
8278             else if (parentWidget()->isVisible())
8279                 QApplication::postEvent(parentWidget(), new QEvent(QEvent::LayoutRequest));
8280         }
8281 
8282         QEvent hideToParentEvent(QEvent::HideToParent);
8283         QApplication::sendEvent(this, &hideToParentEvent);
8284     }
8285 }
8286 
8287 /*!
8288     Convenience function, equivalent to setVisible(!\a hidden).
8289 */
8290 void QWidget::setHidden(bool hidden)
8291 {
8292     setVisible(!hidden);
8293 }
8294 
8295 void QWidgetPrivate::_q_showIfNotHidden()
8296 {
8297     Q_Q(QWidget);
8298     if ( !(q->isHidden() && q->testAttribute(Qt::WA_WState_ExplicitShowHide)) )
8299         q->setVisible(true);
8300 }
8301 
8302 void QWidgetPrivate::showChildren(bool spontaneous)
8303 {
8304     QList<QObject*> childList = children;
8305     for (int i = 0; i < childList.size(); ++i) {
8306         QWidget *widget = qobject_cast<QWidget*>(childList.at(i));
8307         if (!widget
8308             || widget->isWindow()
8309             || widget->testAttribute(Qt::WA_WState_Hidden))
8310             continue;
8311         if (spontaneous) {
8312             widget->setAttribute(Qt::WA_Mapped);
8313             widget->d_func()->showChildren(true);
8314             QShowEvent e;
8315             QApplication::sendSpontaneousEvent(widget, &e);
8316         } else {
8317             if (widget->testAttribute(Qt::WA_WState_ExplicitShowHide))
8318                 widget->d_func()->show_recursive();
8319             else
8320                 widget->show();
8321         }
8322     }
8323 }
8324 
8325 void QWidgetPrivate::hideChildren(bool spontaneous)
8326 {
8327     QList<QObject*> childList = children;
8328     for (int i = 0; i < childList.size(); ++i) {
8329         QWidget *widget = qobject_cast<QWidget*>(childList.at(i));
8330         if (!widget || widget->isWindow() || widget->testAttribute(Qt::WA_WState_Hidden))
8331             continue;
8332 #if 0 // Used to be included in Qt4 for Q_WS_MAC
8333         // Before doing anything we need to make sure that we don't leave anything in a non-consistent state.
8334         // When hiding a widget we need to make sure that no mouse_down events are active, because
8335         // the mouse_up event will never be received by a hidden widget or one of its descendants.
8336         // The solution is simple, before going through with this we check if there are any mouse_down events in
8337         // progress, if so we check if it is related to this widget or not. If so, we just reset the mouse_down and
8338         // then we continue.
8339         // In X11 and Windows we send a mouse_release event, however we don't do that here because we were already
8340         // ignoring that from before. I.e. Carbon did not send the mouse release event, so we will not send the
8341         // mouse release event. There are two ways to interpret this:
8342         // 1. If we don't send the mouse release event, the widget might get into an inconsistent state, i.e. it
8343         // might be waiting for a release event that will never arrive.
8344         // 2. If we send the mouse release event, then the widget might decide to trigger an action that is not
8345         // supposed to trigger because it is not visible.
8346         if(widget == qt_button_down)
8347             qt_button_down = 0;
8348 #endif
8349         if (spontaneous)
8350             widget->setAttribute(Qt::WA_Mapped, false);
8351         else
8352             widget->setAttribute(Qt::WA_WState_Visible, false);
8353         widget->d_func()->hideChildren(spontaneous);
8354         QHideEvent e;
8355         if (spontaneous) {
8356             QApplication::sendSpontaneousEvent(widget, &e);
8357         } else {
8358             QApplication::sendEvent(widget, &e);
8359             if (widget->internalWinId()
8360                 && widget->testAttribute(Qt::WA_DontCreateNativeAncestors)) {
8361                 // hide_sys() on an ancestor won't have any affect on this
8362                 // widget, so it needs an explicit hide_sys() of its own
8363                 widget->d_func()->hide_sys();
8364             }
8365         }
8366         qApp->d_func()->sendSyntheticEnterLeave(widget);
8367 #ifndef QT_NO_ACCESSIBILITY
8368         if (!spontaneous) {
8369             QAccessibleEvent event(widget, QAccessible::ObjectHide);
8370             QAccessible::updateAccessibility(&event);
8371         }
8372 #endif
8373     }
8374 }
8375 
8376 bool QWidgetPrivate::close_helper(CloseMode mode)
8377 {
8378     if (data.is_closing)
8379         return true;
8380 
8381     Q_Q(QWidget);
8382     data.is_closing = 1;
8383 
8384     QPointer<QWidget> that = q;
8385     QPointer<QWidget> parentWidget = q->parentWidget();
8386 
8387     bool quitOnClose = q->testAttribute(Qt::WA_QuitOnClose);
8388     if (mode != CloseNoEvent) {
8389         QCloseEvent e;
8390         if (mode == CloseWithSpontaneousEvent)
8391             QApplication::sendSpontaneousEvent(q, &e);
8392         else
8393             QApplication::sendEvent(q, &e);
8394         if (!that.isNull() && !e.isAccepted()) {
8395             data.is_closing = 0;
8396             return false;
8397         }
8398     }
8399 
8400     if (!that.isNull() && !q->isHidden())
8401         q->hide();
8402 
8403     // Attempt to close the application only if this has WA_QuitOnClose set and a non-visible parent
8404     quitOnClose = quitOnClose && (parentWidget.isNull() || !parentWidget->isVisible());
8405 
8406     if (quitOnClose) {
8407         /* if there is no non-withdrawn primary window left (except
8408            the ones without QuitOnClose), we emit the lastWindowClosed
8409            signal */
8410         QWidgetList list = QApplication::topLevelWidgets();
8411         bool lastWindowClosed = true;
8412         for (int i = 0; i < list.size(); ++i) {
8413             QWidget *w = list.at(i);
8414             if (!w->isVisible() || w->parentWidget() || !w->testAttribute(Qt::WA_QuitOnClose))
8415                 continue;
8416             lastWindowClosed = false;
8417             break;
8418         }
8419         if (lastWindowClosed) {
8420             QGuiApplicationPrivate::emitLastWindowClosed();
8421             QCoreApplicationPrivate *applicationPrivate = static_cast<QCoreApplicationPrivate*>(QObjectPrivate::get(QCoreApplication::instance()));
8422             applicationPrivate->maybeQuit();
8423         }
8424     }
8425 
8426 
8427     if (!that.isNull()) {
8428         data.is_closing = 0;
8429         if (q->testAttribute(Qt::WA_DeleteOnClose)) {
8430             q->setAttribute(Qt::WA_DeleteOnClose, false);
8431             q->deleteLater();
8432         }
8433     }
8434     return true;
8435 }
8436 
8437 
8438 /*!
8439     Closes this widget. Returns \c true if the widget was closed;
8440     otherwise returns \c false.
8441 
8442     First it sends the widget a QCloseEvent. The widget is
8443     \l{hide()}{hidden} if it \l{QEvent::accept()}{accepts}
8444     the close event. If it \l{QEvent::ignore()}{ignores}
8445     the event, nothing happens. The default
8446     implementation of QWidget::closeEvent() accepts the close event.
8447 
8448     If the widget has the Qt::WA_DeleteOnClose flag, the widget
8449     is also deleted. A close events is delivered to the widget no
8450     matter if the widget is visible or not.
8451 
8452     The \l QApplication::lastWindowClosed() signal is emitted when the
8453     last visible primary window (i.e. window with no parent) with the
8454     Qt::WA_QuitOnClose attribute set is closed. By default this
8455     attribute is set for all widgets except transient windows such as
8456     splash screens, tool windows, and popup menus.
8457 
8458 */
8459 
8460 bool QWidget::close()
8461 {
8462     return d_func()->close_helper(QWidgetPrivate::CloseWithEvent);
8463 }
8464 
8465 /*!
8466     \property QWidget::visible
8467     \brief whether the widget is visible
8468 
8469     Calling setVisible(true) or show() sets the widget to visible
8470     status if all its parent widgets up to the window are visible. If
8471     an ancestor is not visible, the widget won't become visible until
8472     all its ancestors are shown. If its size or position has changed,
8473     Qt guarantees that a widget gets move and resize events just
8474     before it is shown. If the widget has not been resized yet, Qt
8475     will adjust the widget's size to a useful default using
8476     adjustSize().
8477 
8478     Calling setVisible(false) or hide() hides a widget explicitly. An
8479     explicitly hidden widget will never become visible, even if all
8480     its ancestors become visible, unless you show it.
8481 
8482     A widget receives show and hide events when its visibility status
8483     changes. Between a hide and a show event, there is no need to
8484     waste CPU cycles preparing or displaying information to the user.
8485     A video application, for example, might simply stop generating new
8486     frames.
8487 
8488     A widget that happens to be obscured by other windows on the
8489     screen is considered to be visible. The same applies to iconified
8490     windows and windows that exist on another virtual
8491     desktop (on platforms that support this concept). A widget
8492     receives spontaneous show and hide events when its mapping status
8493     is changed by the window system, e.g. a spontaneous hide event
8494     when the user minimizes the window, and a spontaneous show event
8495     when the window is restored again.
8496 
8497     You almost never have to reimplement the setVisible() function. If
8498     you need to change some settings before a widget is shown, use
8499     showEvent() instead. If you need to do some delayed initialization
8500     use the Polish event delivered to the event() function.
8501 
8502     \sa show(), hide(), isHidden(), isVisibleTo(), isMinimized(),
8503     showEvent(), hideEvent()
8504 */
8505 
8506 
8507 /*!
8508     Returns \c true if this widget would become visible if \a ancestor is
8509     shown; otherwise returns \c false.
8510 
8511     The true case occurs if neither the widget itself nor any parent
8512     up to but excluding \a ancestor has been explicitly hidden.
8513 
8514     This function will still return true if the widget is obscured by
8515     other windows on the screen, but could be physically visible if it
8516     or they were to be moved.
8517 
8518     isVisibleTo(0) is identical to isVisible().
8519 
8520     \sa show(), hide(), isVisible()
8521 */
8522 
8523 bool QWidget::isVisibleTo(const QWidget *ancestor) const
8524 {
8525     if (!ancestor)
8526         return isVisible();
8527     const QWidget * w = this;
8528     while (!w->isHidden()
8529             && !w->isWindow()
8530             && w->parentWidget()
8531             && w->parentWidget() != ancestor)
8532         w = w->parentWidget();
8533     return !w->isHidden();
8534 }
8535 
8536 
8537 /*!
8538     Returns the unobscured region where paint events can occur.
8539 
8540     For visible widgets, this is an approximation of the area not
8541     covered by other widgets; otherwise, this is an empty region.
8542 
8543     The repaint() function calls this function if necessary, so in
8544     general you do not need to call it.
8545 
8546 */
8547 QRegion QWidget::visibleRegion() const
8548 {
8549     Q_D(const QWidget);
8550 
8551     QRect clipRect = d->clipRect();
8552     if (clipRect.isEmpty())
8553         return QRegion();
8554     QRegion r(clipRect);
8555     d->subtractOpaqueChildren(r, clipRect);
8556     d->subtractOpaqueSiblings(r);
8557     return r;
8558 }
8559 
8560 
8561 QSize QWidgetPrivate::adjustedSize() const
8562 {
8563     Q_Q(const QWidget);
8564 
8565     QSize s = q->sizeHint();
8566 
8567     if (q->isWindow()) {
8568         Qt::Orientations exp;
8569         if (layout) {
8570             if (layout->hasHeightForWidth())
8571                 s.setHeight(layout->totalHeightForWidth(s.width()));
8572             exp = layout->expandingDirections();
8573         } else
8574         {
8575             if (q->sizePolicy().hasHeightForWidth())
8576                 s.setHeight(q->heightForWidth(s.width()));
8577             exp = q->sizePolicy().expandingDirections();
8578         }
8579         if (exp & Qt::Horizontal)
8580             s.setWidth(qMax(s.width(), 200));
8581         if (exp & Qt::Vertical)
8582             s.setHeight(qMax(s.height(), 100));
8583 #if 0 // Used to be included in Qt4 for Q_WS_X11
8584         QRect screen = QDesktopWidgetPrivate::screenGeometry(q->x11Info().screen());
8585 #else // all others
8586         QRect screen = QDesktopWidgetPrivate::screenGeometry(q->pos());
8587 #endif
8588         s.setWidth(qMin(s.width(), screen.width()*2/3));
8589         s.setHeight(qMin(s.height(), screen.height()*2/3));
8590 
8591         if (QTLWExtra *extra = maybeTopData())
8592             extra->sizeAdjusted = true;
8593     }
8594 
8595     if (!s.isValid()) {
8596         QRect r = q->childrenRect(); // get children rectangle
8597         if (r.isNull())
8598             return s;
8599         s = r.size() + QSize(2 * r.x(), 2 * r.y());
8600     }
8601 
8602     return s;
8603 }
8604 
8605 /*!
8606     Adjusts the size of the widget to fit its contents.
8607 
8608     This function uses sizeHint() if it is valid, i.e., the size hint's width
8609     and height are \>= 0. Otherwise, it sets the size to the children
8610     rectangle that covers all child widgets (the union of all child widget
8611     rectangles).
8612 
8613     For windows, the screen size is also taken into account. If the sizeHint()
8614     is less than (200, 100) and the size policy is \l{QSizePolicy::Expanding}
8615     {expanding}, the window will be at least (200, 100). The maximum size of
8616     a window is 2/3 of the screen's width and height.
8617 
8618     \sa sizeHint(), childrenRect()
8619 */
8620 
8621 void QWidget::adjustSize()
8622 {
8623     Q_D(QWidget);
8624     ensurePolished();
8625     QSize s = d->adjustedSize();
8626 
8627     if (d->layout)
8628         d->layout->activate();
8629 
8630     if (s.isValid())
8631         resize(s);
8632 }
8633 
8634 
8635 /*!
8636     \property QWidget::sizeHint
8637     \brief the recommended size for the widget
8638 
8639     If the value of this property is an invalid size, no size is
8640     recommended.
8641 
8642     The default implementation of sizeHint() returns an invalid size
8643     if there is no layout for this widget, and returns the layout's
8644     preferred size otherwise.
8645 
8646     \sa QSize::isValid(), minimumSizeHint(), sizePolicy(),
8647     setMinimumSize(), updateGeometry()
8648 */
8649 
8650 QSize QWidget::sizeHint() const
8651 {
8652     Q_D(const QWidget);
8653     if (d->layout)
8654         return d->layout->totalSizeHint();
8655     return QSize(-1, -1);
8656 }
8657 
8658 /*!
8659     \property QWidget::minimumSizeHint
8660     \brief the recommended minimum size for the widget
8661 
8662     If the value of this property is an invalid size, no minimum size
8663     is recommended.
8664 
8665     The default implementation of minimumSizeHint() returns an invalid
8666     size if there is no layout for this widget, and returns the
8667     layout's minimum size otherwise. Most built-in widgets reimplement
8668     minimumSizeHint().
8669 
8670     \l QLayout will never resize a widget to a size smaller than the
8671     minimum size hint unless minimumSize() is set or the size policy is
8672     set to QSizePolicy::Ignore. If minimumSize() is set, the minimum
8673     size hint will be ignored.
8674 
8675     \sa QSize::isValid(), resize(), setMinimumSize(), sizePolicy()
8676 */
8677 QSize QWidget::minimumSizeHint() const
8678 {
8679     Q_D(const QWidget);
8680     if (d->layout)
8681         return d->layout->totalMinimumSize();
8682     return QSize(-1, -1);
8683 }
8684 
8685 
8686 /*!
8687     \fn QWidget *QWidget::parentWidget() const
8688 
8689     Returns the parent of this widget, or 0 if it does not have any
8690     parent widget.
8691 */
8692 
8693 
8694 /*!
8695     Returns \c true if this widget is a parent, (or grandparent and so on
8696     to any level), of the given \a child, and both widgets are within
8697     the same window; otherwise returns \c false.
8698 */
8699 
8700 bool QWidget::isAncestorOf(const QWidget *child) const
8701 {
8702     while (child) {
8703         if (child == this)
8704             return true;
8705         if (child->isWindow())
8706             return false;
8707         child = child->parentWidget();
8708     }
8709     return false;
8710 }
8711 
8712 #if 0 // Used to be included in Qt4 for Q_WS_WIN
8713 inline void setDisabledStyle(QWidget *w, bool setStyle)
8714 {
8715     // set/reset WS_DISABLED style.
8716     if(w && w->isWindow() && w->isVisible() && w->isEnabled()) {
8717         LONG dwStyle = GetWindowLong(w->winId(), GWL_STYLE);
8718         LONG newStyle = dwStyle;
8719         if (setStyle)
8720             newStyle |= WS_DISABLED;
8721         else
8722             newStyle &= ~WS_DISABLED;
8723         if (newStyle != dwStyle) {
8724             SetWindowLong(w->winId(), GWL_STYLE, newStyle);
8725             // we might need to repaint in some situations (eg. menu)
8726             w->repaint();
8727         }
8728     }
8729 }
8730 #endif
8731 
8732 /*****************************************************************************
8733   QWidget event handling
8734  *****************************************************************************/
8735 
8736 /*!
8737     This is the main event handler; it handles event \a event. You can
8738     reimplement this function in a subclass, but we recommend using
8739     one of the specialized event handlers instead.
8740 
8741     Key press and release events are treated differently from other
8742     events. event() checks for Tab and Shift+Tab and tries to move the
8743     focus appropriately. If there is no widget to move the focus to
8744     (or the key press is not Tab or Shift+Tab), event() calls
8745     keyPressEvent().
8746 
8747     Mouse and tablet event handling is also slightly special: only
8748     when the widget is \l enabled, event() will call the specialized
8749     handlers such as mousePressEvent(); otherwise it will discard the
8750     event.
8751 
8752     This function returns \c true if the event was recognized, otherwise
8753     it returns \c false.  If the recognized event was accepted (see \l
8754     QEvent::accepted), any further processing such as event
8755     propagation to the parent widget stops.
8756 
8757     \sa closeEvent(), focusInEvent(), focusOutEvent(), enterEvent(),
8758     keyPressEvent(), keyReleaseEvent(), leaveEvent(),
8759     mouseDoubleClickEvent(), mouseMoveEvent(), mousePressEvent(),
8760     mouseReleaseEvent(), moveEvent(), paintEvent(), resizeEvent(),
8761     QObject::event(), QObject::timerEvent()
8762 */
8763 
8764 bool QWidget::event(QEvent *event)
8765 {
8766     Q_D(QWidget);
8767 
8768     // ignore mouse and key events when disabled
8769     if (!isEnabled()) {
8770         switch(event->type()) {
8771         case QEvent::TabletPress:
8772         case QEvent::TabletRelease:
8773         case QEvent::TabletMove:
8774         case QEvent::MouseButtonPress:
8775         case QEvent::MouseButtonRelease:
8776         case QEvent::MouseButtonDblClick:
8777         case QEvent::MouseMove:
8778         case QEvent::TouchBegin:
8779         case QEvent::TouchUpdate:
8780         case QEvent::TouchEnd:
8781         case QEvent::TouchCancel:
8782         case QEvent::ContextMenu:
8783         case QEvent::KeyPress:
8784         case QEvent::KeyRelease:
8785 #if QT_CONFIG(wheelevent)
8786         case QEvent::Wheel:
8787 #endif
8788             return false;
8789         default:
8790             break;
8791         }
8792     }
8793     switch (event->type()) {
8794     case QEvent::MouseMove:
8795         mouseMoveEvent((QMouseEvent*)event);
8796         break;
8797 
8798     case QEvent::MouseButtonPress:
8799         mousePressEvent((QMouseEvent*)event);
8800         break;
8801 
8802     case QEvent::MouseButtonRelease:
8803         mouseReleaseEvent((QMouseEvent*)event);
8804         break;
8805 
8806     case QEvent::MouseButtonDblClick:
8807         mouseDoubleClickEvent((QMouseEvent*)event);
8808         break;
8809 #if QT_CONFIG(wheelevent)
8810     case QEvent::Wheel:
8811         wheelEvent((QWheelEvent*)event);
8812         break;
8813 #endif
8814 #if QT_CONFIG(tabletevent)
8815     case QEvent::TabletMove:
8816         if (static_cast<QTabletEvent *>(event)->buttons() == Qt::NoButton && !testAttribute(Qt::WA_TabletTracking))
8817             break;
8818         Q_FALLTHROUGH();
8819     case QEvent::TabletPress:
8820     case QEvent::TabletRelease:
8821         tabletEvent((QTabletEvent*)event);
8822         break;
8823 #endif
8824     case QEvent::KeyPress: {
8825         QKeyEvent *k = (QKeyEvent *)event;
8826         bool res = false;
8827         if (!(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier))) {  //### Add MetaModifier?
8828             if (k->key() == Qt::Key_Backtab
8829                 || (k->key() == Qt::Key_Tab && (k->modifiers() & Qt::ShiftModifier)))
8830                 res = focusNextPrevChild(false);
8831             else if (k->key() == Qt::Key_Tab)
8832                 res = focusNextPrevChild(true);
8833             if (res)
8834                 break;
8835         }
8836         keyPressEvent(k);
8837 #ifdef QT_KEYPAD_NAVIGATION
8838         if (!k->isAccepted() && QApplication::keypadNavigationEnabled()
8839             && !(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::ShiftModifier))) {
8840             if (QApplication::navigationMode() == Qt::NavigationModeKeypadTabOrder) {
8841                 if (k->key() == Qt::Key_Up)
8842                     res = focusNextPrevChild(false);
8843                 else if (k->key() == Qt::Key_Down)
8844                     res = focusNextPrevChild(true);
8845             } else if (QApplication::navigationMode() == Qt::NavigationModeKeypadDirectional) {
8846                 if (k->key() == Qt::Key_Up)
8847                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionNorth);
8848                 else if (k->key() == Qt::Key_Right)
8849                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionEast);
8850                 else if (k->key() == Qt::Key_Down)
8851                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionSouth);
8852                 else if (k->key() == Qt::Key_Left)
8853                     res = QWidgetPrivate::navigateToDirection(QWidgetPrivate::DirectionWest);
8854             }
8855             if (res) {
8856                 k->accept();
8857                 break;
8858             }
8859         }
8860 #endif
8861 #if QT_CONFIG(whatsthis)
8862         if (!k->isAccepted()
8863             && k->modifiers() & Qt::ShiftModifier && k->key() == Qt::Key_F1
8864             && d->whatsThis.size()) {
8865             QWhatsThis::showText(mapToGlobal(inputMethodQuery(Qt::ImCursorRectangle).toRect().center()), d->whatsThis, this);
8866             k->accept();
8867         }
8868 #endif
8869     }
8870         break;
8871 
8872     case QEvent::KeyRelease:
8873         keyReleaseEvent((QKeyEvent*)event);
8874         Q_FALLTHROUGH();
8875     case QEvent::ShortcutOverride:
8876         break;
8877 
8878     case QEvent::InputMethod:
8879         inputMethodEvent((QInputMethodEvent *) event);
8880         break;
8881 
8882     case QEvent::InputMethodQuery:
8883         if (testAttribute(Qt::WA_InputMethodEnabled)) {
8884             QInputMethodQueryEvent *query = static_cast<QInputMethodQueryEvent *>(event);
8885             Qt::InputMethodQueries queries = query->queries();
8886             for (uint i = 0; i < 32; ++i) {
8887                 Qt::InputMethodQuery q = (Qt::InputMethodQuery)(int)(queries & (1<<i));
8888                 if (q) {
8889                     QVariant v = inputMethodQuery(q);
8890                     if (q == Qt::ImEnabled && !v.isValid() && isEnabled())
8891                         v = QVariant(true); // special case for Qt4 compatibility
8892                     query->setValue(q, v);
8893                 }
8894             }
8895             query->accept();
8896         }
8897         break;
8898 
8899     case QEvent::PolishRequest:
8900         ensurePolished();
8901         break;
8902 
8903     case QEvent::Polish: {
8904         style()->polish(this);
8905         setAttribute(Qt::WA_WState_Polished);
8906         if (!QApplication::font(this).isCopyOf(QApplication::font()))
8907             d->resolveFont();
8908         if (!QApplication::palette(this).isCopyOf(QApplication::palette()))
8909             d->resolvePalette();
8910     }
8911         break;
8912 
8913     case QEvent::ApplicationWindowIconChange:
8914         if (isWindow() && !testAttribute(Qt::WA_SetWindowIcon)) {
8915             d->setWindowIcon_sys();
8916             d->setWindowIcon_helper();
8917         }
8918         break;
8919     case QEvent::FocusIn:
8920         focusInEvent((QFocusEvent*)event);
8921         d->updateWidgetTransform(event);
8922         break;
8923 
8924     case QEvent::FocusOut:
8925         focusOutEvent((QFocusEvent*)event);
8926         break;
8927 
8928     case QEvent::Enter:
8929 #if QT_CONFIG(statustip)
8930         if (d->statusTip.size()) {
8931             QStatusTipEvent tip(d->statusTip);
8932             QApplication::sendEvent(const_cast<QWidget *>(this), &tip);
8933         }
8934 #endif
8935         enterEvent(event);
8936         break;
8937 
8938     case QEvent::Leave:
8939 #if QT_CONFIG(statustip)
8940         if (d->statusTip.size()) {
8941             QString empty;
8942             QStatusTipEvent tip(empty);
8943             QApplication::sendEvent(const_cast<QWidget *>(this), &tip);
8944         }
8945 #endif
8946         leaveEvent(event);
8947         break;
8948 
8949     case QEvent::HoverEnter:
8950     case QEvent::HoverLeave:
8951         update();
8952         break;
8953 
8954     case QEvent::Paint:
8955         // At this point the event has to be delivered, regardless
8956         // whether the widget isVisible() or not because it
8957         // already went through the filters
8958         paintEvent((QPaintEvent*)event);
8959         break;
8960 
8961     case QEvent::Move:
8962         moveEvent((QMoveEvent*)event);
8963         d->updateWidgetTransform(event);
8964         break;
8965 
8966     case QEvent::Resize:
8967         resizeEvent((QResizeEvent*)event);
8968         d->updateWidgetTransform(event);
8969         break;
8970 
8971     case QEvent::Close:
8972         closeEvent((QCloseEvent *)event);
8973         break;
8974 
8975 #ifndef QT_NO_CONTEXTMENU
8976     case QEvent::ContextMenu:
8977         switch (data->context_menu_policy) {
8978         case Qt::PreventContextMenu:
8979             break;
8980         case Qt::DefaultContextMenu:
8981             contextMenuEvent(static_cast<QContextMenuEvent *>(event));
8982             break;
8983         case Qt::CustomContextMenu:
8984             emit customContextMenuRequested(static_cast<QContextMenuEvent *>(event)->pos());
8985             break;
8986 #ifndef QT_NO_MENU
8987         case Qt::ActionsContextMenu:
8988             if (d->actions.count()) {
8989                 QMenu::exec(d->actions, static_cast<QContextMenuEvent *>(event)->globalPos(),
8990                             0, this);
8991                 break;
8992             }
8993             Q_FALLTHROUGH();
8994 #endif
8995         default:
8996             event->ignore();
8997             break;
8998         }
8999         break;
9000 #endif // QT_NO_CONTEXTMENU
9001 
9002 #ifndef QT_NO_DRAGANDDROP
9003     case QEvent::Drop:
9004         dropEvent((QDropEvent*) event);
9005         break;
9006 
9007     case QEvent::DragEnter:
9008         dragEnterEvent((QDragEnterEvent*) event);
9009         break;
9010 
9011     case QEvent::DragMove:
9012         dragMoveEvent((QDragMoveEvent*) event);
9013         break;
9014 
9015     case QEvent::DragLeave:
9016         dragLeaveEvent((QDragLeaveEvent*) event);
9017         break;
9018 #endif
9019 
9020     case QEvent::Show:
9021         showEvent((QShowEvent*) event);
9022         break;
9023 
9024     case QEvent::Hide:
9025         hideEvent((QHideEvent*) event);
9026         break;
9027 
9028     case QEvent::ShowWindowRequest:
9029         if (!isHidden())
9030             d->show_sys();
9031         break;
9032 
9033     case QEvent::ApplicationFontChange:
9034         d->resolveFont();
9035         break;
9036     case QEvent::ApplicationPaletteChange:
9037         if (!(windowType() == Qt::Desktop))
9038             d->resolvePalette();
9039         break;
9040 
9041     case QEvent::ToolBarChange:
9042     case QEvent::ActivationChange:
9043     case QEvent::EnabledChange:
9044     case QEvent::FontChange:
9045     case QEvent::StyleChange:
9046     case QEvent::PaletteChange:
9047     case QEvent::WindowTitleChange:
9048     case QEvent::IconTextChange:
9049     case QEvent::ModifiedChange:
9050     case QEvent::MouseTrackingChange:
9051     case QEvent::TabletTrackingChange:
9052     case QEvent::ParentChange:
9053     case QEvent::LocaleChange:
9054     case QEvent::MacSizeChange:
9055     case QEvent::ContentsRectChange:
9056     case QEvent::ThemeChange:
9057     case QEvent::ReadOnlyChange:
9058         changeEvent(event);
9059         break;
9060 
9061     case QEvent::WindowStateChange: {
9062         const bool wasMinimized = static_cast<const QWindowStateChangeEvent *>(event)->oldState() & Qt::WindowMinimized;
9063         if (wasMinimized != isMinimized()) {
9064             QWidget *widget = const_cast<QWidget *>(this);
9065             if (wasMinimized) {
9066                 // Always send the spontaneous events here, otherwise it can break the application!
9067                 if (!d->childrenShownByExpose) {
9068                     // Show widgets only when they are not yet shown by the expose event
9069                     d->showChildren(true);
9070                     QShowEvent showEvent;
9071                     QCoreApplication::sendSpontaneousEvent(widget, &showEvent);
9072                 }
9073                 d->childrenHiddenByWState = false; // Set it always to "false" when window is restored
9074             } else {
9075                 QHideEvent hideEvent;
9076                 QCoreApplication::sendSpontaneousEvent(widget, &hideEvent);
9077                 d->hideChildren(true);
9078                 d->childrenHiddenByWState = true;
9079             }
9080             d->childrenShownByExpose = false; // Set it always to "false" when window state changes
9081         }
9082         changeEvent(event);
9083     }
9084         break;
9085 
9086     case QEvent::WindowActivate:
9087     case QEvent::WindowDeactivate: {
9088         if (isVisible() && !palette().isEqual(QPalette::Active, QPalette::Inactive))
9089             update();
9090         QList<QObject*> childList = d->children;
9091         for (int i = 0; i < childList.size(); ++i) {
9092             QWidget *w = qobject_cast<QWidget *>(childList.at(i));
9093             if (w && w->isVisible() && !w->isWindow())
9094                 QApplication::sendEvent(w, event);
9095         }
9096         break; }
9097 
9098     case QEvent::LanguageChange:
9099         changeEvent(event);
9100         {
9101             QList<QObject*> childList = d->children;
9102             for (int i = 0; i < childList.size(); ++i) {
9103                 QObject *o = childList.at(i);
9104                 if (o)
9105                     QApplication::sendEvent(o, event);
9106             }
9107         }
9108         update();
9109         break;
9110 
9111     case QEvent::ApplicationLayoutDirectionChange:
9112         d->resolveLayoutDirection();
9113         break;
9114 
9115     case QEvent::LayoutDirectionChange:
9116         if (d->layout)
9117             d->layout->invalidate();
9118         update();
9119         changeEvent(event);
9120         break;
9121     case QEvent::UpdateRequest:
9122         d->syncBackingStore();
9123         break;
9124     case QEvent::UpdateLater:
9125         update(static_cast<QUpdateLaterEvent*>(event)->region());
9126         break;
9127     case QEvent::StyleAnimationUpdate:
9128         if (isVisible() && !window()->isMinimized()) {
9129             event->accept();
9130             update();
9131         }
9132         break;
9133 
9134     case QEvent::WindowBlocked:
9135     case QEvent::WindowUnblocked:
9136         if (!d->children.isEmpty()) {
9137             QWidget *modalWidget = QApplication::activeModalWidget();
9138             for (int i = 0; i < d->children.size(); ++i) {
9139                 QObject *o = d->children.at(i);
9140                 if (o && o != modalWidget && o->isWidgetType()) {
9141                     QWidget *w  = static_cast<QWidget *>(o);
9142                     // do not forward the event to child windows; QApplication does this for us
9143                     if (!w->isWindow())
9144                         QApplication::sendEvent(w, event);
9145                 }
9146             }
9147         }
9148 #if 0 // Used to be included in Qt4 for Q_WS_WIN
9149             setDisabledStyle(this, (event->type() == QEvent::WindowBlocked));
9150 #endif
9151         break;
9152 #ifndef QT_NO_TOOLTIP
9153     case QEvent::ToolTip:
9154         if (!d->toolTip.isEmpty())
9155             QToolTip::showText(static_cast<QHelpEvent*>(event)->globalPos(), d->toolTip, this, QRect(), d->toolTipDuration);
9156         else
9157             event->ignore();
9158         break;
9159 #endif
9160 #if QT_CONFIG(whatsthis)
9161     case QEvent::WhatsThis:
9162         if (d->whatsThis.size())
9163             QWhatsThis::showText(static_cast<QHelpEvent *>(event)->globalPos(), d->whatsThis, this);
9164         else
9165             event->ignore();
9166         break;
9167     case QEvent::QueryWhatsThis:
9168         if (d->whatsThis.isEmpty())
9169             event->ignore();
9170         break;
9171 #endif
9172     case QEvent::EmbeddingControl:
9173         d->topData()->frameStrut.setCoords(0 ,0, 0, 0);
9174         data->fstrut_dirty = false;
9175 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_X11 */
9176         d->topData()->embedded = 1;
9177 #endif
9178         break;
9179 #ifndef QT_NO_ACTION
9180     case QEvent::ActionAdded:
9181     case QEvent::ActionRemoved:
9182     case QEvent::ActionChanged:
9183         actionEvent((QActionEvent*)event);
9184         break;
9185 #endif
9186 
9187     case QEvent::KeyboardLayoutChange:
9188         {
9189             changeEvent(event);
9190 
9191             // inform children of the change
9192             QList<QObject*> childList = d->children;
9193             for (int i = 0; i < childList.size(); ++i) {
9194                 QWidget *w = qobject_cast<QWidget *>(childList.at(i));
9195                 if (w && w->isVisible() && !w->isWindow())
9196                     QApplication::sendEvent(w, event);
9197             }
9198             break;
9199         }
9200 #if 0 // Used to be included in Qt4 for Q_WS_MAC
9201     case QEvent::MacGLWindowChange:
9202         d->needWindowChange = false;
9203         break;
9204 #endif
9205     case QEvent::TouchBegin:
9206     case QEvent::TouchUpdate:
9207     case QEvent::TouchEnd:
9208     case QEvent::TouchCancel:
9209     {
9210         event->ignore();
9211         break;
9212     }
9213 #ifndef QT_NO_GESTURES
9214     case QEvent::Gesture:
9215         event->ignore();
9216         break;
9217 #endif
9218     case QEvent::ScreenChangeInternal:
9219         if (const QTLWExtra *te = d->maybeTopData()) {
9220             const QWindow *win = te->window;
9221             d->setWinId((win && win->handle()) ? win->handle()->winId() : 0);
9222         }
9223         if (d->data.fnt.d->dpi != logicalDpiY())
9224             d->updateFont(d->data.fnt);
9225 #ifndef QT_NO_OPENGL
9226         d->renderToTextureReallyDirty = 1;
9227 #endif
9228         break;
9229 #ifndef QT_NO_PROPERTIES
9230     case QEvent::DynamicPropertyChange: {
9231         const QByteArray &propName = static_cast<QDynamicPropertyChangeEvent *>(event)->propertyName();
9232         if (propName.length() == 13 && !qstrncmp(propName, "_q_customDpi", 12)) {
9233             uint value = property(propName.constData()).toUInt();
9234             if (!d->extra)
9235                 d->createExtra();
9236             const char axis = propName.at(12);
9237             if (axis == 'X')
9238                 d->extra->customDpiX = value;
9239             else if (axis == 'Y')
9240                 d->extra->customDpiY = value;
9241             d->updateFont(d->data.fnt);
9242         }
9243         if (windowHandle() && !qstrncmp(propName, "_q_platform_", 12))
9244             windowHandle()->setProperty(propName, property(propName));
9245         Q_FALLTHROUGH();
9246     }
9247 #endif
9248     default:
9249         return QObject::event(event);
9250     }
9251     return true;
9252 }
9253 
9254 /*!
9255   This event handler can be reimplemented to handle state changes.
9256 
9257   The state being changed in this event can be retrieved through the \a event
9258   supplied.
9259 
9260   Change events include: QEvent::ToolBarChange,
9261   QEvent::ActivationChange, QEvent::EnabledChange, QEvent::FontChange,
9262   QEvent::StyleChange, QEvent::PaletteChange,
9263   QEvent::WindowTitleChange, QEvent::IconTextChange,
9264   QEvent::ModifiedChange, QEvent::MouseTrackingChange,
9265   QEvent::ParentChange, QEvent::WindowStateChange,
9266   QEvent::LanguageChange, QEvent::LocaleChange,
9267   QEvent::LayoutDirectionChange, QEvent::ReadOnlyChange.
9268 
9269 */
9270 void QWidget::changeEvent(QEvent * event)
9271 {
9272     switch(event->type()) {
9273     case QEvent::EnabledChange: {
9274         update();
9275 #ifndef QT_NO_ACCESSIBILITY
9276         QAccessible::State s;
9277         s.disabled = true;
9278         QAccessibleStateChangeEvent event(this, s);
9279         QAccessible::updateAccessibility(&event);
9280 #endif
9281         break;
9282     }
9283 
9284     case QEvent::FontChange:
9285     case QEvent::StyleChange: {
9286         Q_D(QWidget);
9287         update();
9288         updateGeometry();
9289         if (d->layout)
9290             d->layout->invalidate();
9291         break;
9292     }
9293 
9294     case QEvent::PaletteChange:
9295         update();
9296         break;
9297 
9298     case QEvent::ThemeChange:
9299         if (QApplication::desktopSettingsAware() && windowType() != Qt::Desktop
9300             && qApp && !QApplication::closingDown()) {
9301             if (testAttribute(Qt::WA_WState_Polished))
9302                 QApplication::style()->unpolish(this);
9303             if (testAttribute(Qt::WA_WState_Polished))
9304                 QApplication::style()->polish(this);
9305             QEvent styleChangedEvent(QEvent::StyleChange);
9306             QCoreApplication::sendEvent(this, &styleChangedEvent);
9307             if (isVisible())
9308                 update();
9309         }
9310         break;
9311 
9312 #ifdef Q_OS_MAC
9313     case QEvent::MacSizeChange:
9314         updateGeometry();
9315         break;
9316 #elif 0 // Used to be included in Qt4 for Q_WS_MAC
9317     case QEvent::ToolTipChange:
9318     case QEvent::MouseTrackingChange:
9319         qt_mac_update_mouseTracking(this);
9320         break;
9321 #endif
9322 
9323     default:
9324         break;
9325     }
9326 }
9327 
9328 /*!
9329     This event handler, for event \a event, can be reimplemented in a
9330     subclass to receive mouse move events for the widget.
9331 
9332     If mouse tracking is switched off, mouse move events only occur if
9333     a mouse button is pressed while the mouse is being moved. If mouse
9334     tracking is switched on, mouse move events occur even if no mouse
9335     button is pressed.
9336 
9337     QMouseEvent::pos() reports the position of the mouse cursor,
9338     relative to this widget. For press and release events, the
9339     position is usually the same as the position of the last mouse
9340     move event, but it might be different if the user's hand shakes.
9341     This is a feature of the underlying window system, not Qt.
9342 
9343     If you want to show a tooltip immediately, while the mouse is
9344     moving (e.g., to get the mouse coordinates with QMouseEvent::pos()
9345     and show them as a tooltip), you must first enable mouse tracking
9346     as described above. Then, to ensure that the tooltip is updated
9347     immediately, you must call QToolTip::showText() instead of
9348     setToolTip() in your implementation of mouseMoveEvent().
9349 
9350     \sa setMouseTracking(), mousePressEvent(), mouseReleaseEvent(),
9351     mouseDoubleClickEvent(), event(), QMouseEvent, {Scribble Example}
9352 */
9353 
9354 void QWidget::mouseMoveEvent(QMouseEvent *event)
9355 {
9356     event->ignore();
9357 }
9358 
9359 /*!
9360     This event handler, for event \a event, can be reimplemented in a
9361     subclass to receive mouse press events for the widget.
9362 
9363     If you create new widgets in the mousePressEvent() the
9364     mouseReleaseEvent() may not end up where you expect, depending on
9365     the underlying window system (or X11 window manager), the widgets'
9366     location and maybe more.
9367 
9368     The default implementation implements the closing of popup widgets
9369     when you click outside the window. For other widget types it does
9370     nothing.
9371 
9372     \sa mouseReleaseEvent(), mouseDoubleClickEvent(),
9373     mouseMoveEvent(), event(), QMouseEvent, {Scribble Example}
9374 */
9375 
9376 void QWidget::mousePressEvent(QMouseEvent *event)
9377 {
9378     event->ignore();
9379     if ((windowType() == Qt::Popup)) {
9380         event->accept();
9381         QWidget* w;
9382         while ((w = QApplication::activePopupWidget()) && w != this){
9383             w->close();
9384             if (QApplication::activePopupWidget() == w) // widget does not want to disappear
9385                 w->hide(); // hide at least
9386         }
9387         if (!rect().contains(event->pos())){
9388             close();
9389         }
9390     }
9391 }
9392 
9393 /*!
9394     This event handler, for event \a event, can be reimplemented in a
9395     subclass to receive mouse release events for the widget.
9396 
9397     \sa mousePressEvent(), mouseDoubleClickEvent(),
9398     mouseMoveEvent(), event(), QMouseEvent, {Scribble Example}
9399 */
9400 
9401 void QWidget::mouseReleaseEvent(QMouseEvent *event)
9402 {
9403     event->ignore();
9404 }
9405 
9406 /*!
9407     This event handler, for event \a event, can be reimplemented in a
9408     subclass to receive mouse double click events for the widget.
9409 
9410     The default implementation calls mousePressEvent().
9411 
9412     \note The widget will also receive mouse press and mouse release
9413     events in addition to the double click event. It is up to the
9414     developer to ensure that the application interprets these events
9415     correctly.
9416 
9417     \sa mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(),
9418     event(), QMouseEvent
9419 */
9420 
9421 void QWidget::mouseDoubleClickEvent(QMouseEvent *event)
9422 {
9423     mousePressEvent(event);
9424 }
9425 
9426 #if QT_CONFIG(wheelevent)
9427 /*!
9428     This event handler, for event \a event, can be reimplemented in a
9429     subclass to receive wheel events for the widget.
9430 
9431     If you reimplement this handler, it is very important that you
9432     \l{QEvent}{ignore()} the event if you do not handle
9433     it, so that the widget's parent can interpret it.
9434 
9435     The default implementation ignores the event.
9436 
9437     \sa QEvent::ignore(), QEvent::accept(), event(),
9438     QWheelEvent
9439 */
9440 
9441 void QWidget::wheelEvent(QWheelEvent *event)
9442 {
9443     event->ignore();
9444 }
9445 #endif // QT_CONFIG(wheelevent)
9446 
9447 #if QT_CONFIG(tabletevent)
9448 /*!
9449     This event handler, for event \a event, can be reimplemented in a
9450     subclass to receive tablet events for the widget.
9451 
9452     If you reimplement this handler, it is very important that you
9453     \l{QEvent}{ignore()} the event if you do not handle
9454     it, so that the widget's parent can interpret it.
9455 
9456     The default implementation ignores the event.
9457 
9458     If tablet tracking is switched off, tablet move events only occur if the
9459     stylus is in contact with the tablet, or at least one stylus button is
9460     pressed, while the stylus is being moved. If tablet tracking is switched on,
9461     tablet move events occur even while the stylus is hovering in proximity of
9462     the tablet, with no buttons pressed.
9463 
9464     \sa QEvent::ignore(), QEvent::accept(), event(), setTabletTracking(),
9465     QTabletEvent
9466 */
9467 
9468 void QWidget::tabletEvent(QTabletEvent *event)
9469 {
9470     event->ignore();
9471 }
9472 #endif // QT_CONFIG(tabletevent)
9473 
9474 /*!
9475     This event handler, for event \a event, can be reimplemented in a
9476     subclass to receive key press events for the widget.
9477 
9478     A widget must call setFocusPolicy() to accept focus initially and
9479     have focus in order to receive a key press event.
9480 
9481     If you reimplement this handler, it is very important that you
9482     call the base class implementation if you do not act upon the key.
9483 
9484     The default implementation closes popup widgets if the user
9485     presses the key sequence for QKeySequence::Cancel (typically the
9486     Escape key). Otherwise the event is ignored, so that the widget's
9487     parent can interpret it.
9488 
9489     Note that QKeyEvent starts with isAccepted() == true, so you do not
9490     need to call QKeyEvent::accept() - just do not call the base class
9491     implementation if you act upon the key.
9492 
9493     \sa keyReleaseEvent(), setFocusPolicy(),
9494     focusInEvent(), focusOutEvent(), event(), QKeyEvent, {Tetrix Example}
9495 */
9496 
9497 void QWidget::keyPressEvent(QKeyEvent *event)
9498 {
9499 #ifndef QT_NO_SHORTCUT
9500     if ((windowType() == Qt::Popup) && event->matches(QKeySequence::Cancel)) {
9501         event->accept();
9502         close();
9503     } else
9504 #endif
9505     {
9506         event->ignore();
9507     }
9508 }
9509 
9510 /*!
9511     This event handler, for event \a event, can be reimplemented in a
9512     subclass to receive key release events for the widget.
9513 
9514     A widget must \l{setFocusPolicy()}{accept focus}
9515     initially and \l{hasFocus()}{have focus} in order to
9516     receive a key release event.
9517 
9518     If you reimplement this handler, it is very important that you
9519     call the base class implementation if you do not act upon the key.
9520 
9521     The default implementation ignores the event, so that the widget's
9522     parent can interpret it.
9523 
9524     Note that QKeyEvent starts with isAccepted() == true, so you do not
9525     need to call QKeyEvent::accept() - just do not call the base class
9526     implementation if you act upon the key.
9527 
9528     \sa keyPressEvent(), QEvent::ignore(), setFocusPolicy(),
9529     focusInEvent(), focusOutEvent(), event(), QKeyEvent
9530 */
9531 
9532 void QWidget::keyReleaseEvent(QKeyEvent *event)
9533 {
9534     event->ignore();
9535 }
9536 
9537 /*!
9538     \fn void QWidget::focusInEvent(QFocusEvent *event)
9539 
9540     This event handler can be reimplemented in a subclass to receive
9541     keyboard focus events (focus received) for the widget. The event
9542     is passed in the \a event parameter
9543 
9544     A widget normally must setFocusPolicy() to something other than
9545     Qt::NoFocus in order to receive focus events. (Note that the
9546     application programmer can call setFocus() on any widget, even
9547     those that do not normally accept focus.)
9548 
9549     The default implementation updates the widget (except for windows
9550     that do not specify a focusPolicy()).
9551 
9552     \sa focusOutEvent(), setFocusPolicy(), keyPressEvent(),
9553     keyReleaseEvent(), event(), QFocusEvent
9554 */
9555 
9556 void QWidget::focusInEvent(QFocusEvent *)
9557 {
9558     if (focusPolicy() != Qt::NoFocus || !isWindow()) {
9559         update();
9560     }
9561 }
9562 
9563 /*!
9564     \fn void QWidget::focusOutEvent(QFocusEvent *event)
9565 
9566     This event handler can be reimplemented in a subclass to receive
9567     keyboard focus events (focus lost) for the widget. The events is
9568     passed in the \a event parameter.
9569 
9570     A widget normally must setFocusPolicy() to something other than
9571     Qt::NoFocus in order to receive focus events. (Note that the
9572     application programmer can call setFocus() on any widget, even
9573     those that do not normally accept focus.)
9574 
9575     The default implementation updates the widget (except for windows
9576     that do not specify a focusPolicy()).
9577 
9578     \sa focusInEvent(), setFocusPolicy(), keyPressEvent(),
9579     keyReleaseEvent(), event(), QFocusEvent
9580 */
9581 
9582 void QWidget::focusOutEvent(QFocusEvent *)
9583 {
9584     if (focusPolicy() != Qt::NoFocus || !isWindow())
9585         update();
9586 
9587 #if !defined(QT_PLATFORM_UIKIT)
9588     // FIXME: revisit autoSIP logic, QTBUG-42906
9589     if (qApp->autoSipEnabled() && testAttribute(Qt::WA_InputMethodEnabled))
9590         QGuiApplication::inputMethod()->hide();
9591 #endif
9592 }
9593 
9594 /*!
9595     \fn void QWidget::enterEvent(QEvent *event)
9596 
9597     This event handler can be reimplemented in a subclass to receive
9598     widget enter events which are passed in the \a event parameter.
9599 
9600     An event is sent to the widget when the mouse cursor enters the
9601     widget.
9602 
9603     \sa leaveEvent(), mouseMoveEvent(), event()
9604 */
9605 
9606 void QWidget::enterEvent(QEvent *)
9607 {
9608 }
9609 
9610 // ### Qt 6: void QWidget::enterEvent(QEnterEvent *).
9611 
9612 /*!
9613     \fn void QWidget::leaveEvent(QEvent *event)
9614 
9615     This event handler can be reimplemented in a subclass to receive
9616     widget leave events which are passed in the \a event parameter.
9617 
9618     A leave event is sent to the widget when the mouse cursor leaves
9619     the widget.
9620 
9621     \sa enterEvent(), mouseMoveEvent(), event()
9622 */
9623 
9624 void QWidget::leaveEvent(QEvent *)
9625 {
9626 }
9627 
9628 /*!
9629     \fn void QWidget::paintEvent(QPaintEvent *event)
9630 
9631     This event handler can be reimplemented in a subclass to receive paint
9632     events passed in \a event.
9633 
9634     A paint event is a request to repaint all or part of a widget. It can
9635     happen for one of the following reasons:
9636 
9637     \list
9638         \li repaint() or update() was invoked,
9639         \li the widget was obscured and has now been uncovered, or
9640         \li many other reasons.
9641     \endlist
9642 
9643     Many widgets can simply repaint their entire surface when asked to, but
9644     some slow widgets need to optimize by painting only the requested region:
9645     QPaintEvent::region(). This speed optimization does not change the result,
9646     as painting is clipped to that region during event processing. QListView
9647     and QTableView do this, for example.
9648 
9649     Qt also tries to speed up painting by merging multiple paint events into
9650     one. When update() is called several times or the window system sends
9651     several paint events, Qt merges these events into one event with a larger
9652     region (see QRegion::united()). The repaint() function does not permit this
9653     optimization, so we suggest using update() whenever possible.
9654 
9655     When the paint event occurs, the update region has normally been erased, so
9656     you are painting on the widget's background.
9657 
9658     The background can be set using setBackgroundRole() and setPalette().
9659 
9660     Since Qt 4.0, QWidget automatically double-buffers its painting, so there
9661     is no need to write double-buffering code in paintEvent() to avoid flicker.
9662 
9663     \note Generally, you should refrain from calling update() or repaint()
9664     \b{inside} a paintEvent(). For example, calling update() or repaint() on
9665     children inside a paintEvent() results in undefined behavior; the child may
9666     or may not get a paint event.
9667 
9668     \warning If you are using a custom paint engine without Qt's backingstore,
9669     Qt::WA_PaintOnScreen must be set. Otherwise, QWidget::paintEngine() will
9670     never be called; the backingstore will be used instead.
9671 
9672     \sa event(), repaint(), update(), QPainter, QPixmap, QPaintEvent,
9673     {Analog Clock Example}
9674 */
9675 
9676 void QWidget::paintEvent(QPaintEvent *)
9677 {
9678 }
9679 
9680 
9681 /*!
9682     \fn void QWidget::moveEvent(QMoveEvent *event)
9683 
9684     This event handler can be reimplemented in a subclass to receive
9685     widget move events which are passed in the \a event parameter.
9686     When the widget receives this event, it is already at the new
9687     position.
9688 
9689     The old position is accessible through QMoveEvent::oldPos().
9690 
9691     \sa resizeEvent(), event(), move(), QMoveEvent
9692 */
9693 
9694 void QWidget::moveEvent(QMoveEvent *)
9695 {
9696 }
9697 
9698 
9699 /*!
9700     This event handler can be reimplemented in a subclass to receive
9701     widget resize events which are passed in the \a event parameter.
9702     When resizeEvent() is called, the widget already has its new
9703     geometry. The old size is accessible through
9704     QResizeEvent::oldSize().
9705 
9706     The widget will be erased and receive a paint event immediately
9707     after processing the resize event. No drawing need be (or should
9708     be) done inside this handler.
9709 
9710 
9711     \sa moveEvent(), event(), resize(), QResizeEvent, paintEvent(),
9712         {Scribble Example}
9713 */
9714 
9715 void QWidget::resizeEvent(QResizeEvent * /* event */)
9716 {
9717 }
9718 
9719 #ifndef QT_NO_ACTION
9720 /*!
9721     \fn void QWidget::actionEvent(QActionEvent *event)
9722 
9723     This event handler is called with the given \a event whenever the
9724     widget's actions are changed.
9725 
9726     \sa addAction(), insertAction(), removeAction(), actions(), QActionEvent
9727 */
9728 void QWidget::actionEvent(QActionEvent *)
9729 {
9730 
9731 }
9732 #endif
9733 
9734 /*!
9735     This event handler is called with the given \a event when Qt receives a window
9736     close request for a top-level widget from the window system.
9737 
9738     By default, the event is accepted and the widget is closed. You can reimplement
9739     this function to change the way the widget responds to window close requests.
9740     For example, you can prevent the window from closing by calling \l{QEvent::}{ignore()}
9741     on all events.
9742 
9743     Main window applications typically use reimplementations of this function to check
9744     whether the user's work has been saved and ask for permission before closing.
9745     For example, the \l{Application Example} uses a helper function to determine whether
9746     or not to close the window:
9747 
9748     \snippet mainwindows/application/mainwindow.cpp 3
9749     \snippet mainwindows/application/mainwindow.cpp 4
9750 
9751     \sa event(), hide(), close(), QCloseEvent, {Application Example}
9752 */
9753 
9754 void QWidget::closeEvent(QCloseEvent *event)
9755 {
9756     event->accept();
9757 }
9758 
9759 #ifndef QT_NO_CONTEXTMENU
9760 /*!
9761     This event handler, for event \a event, can be reimplemented in a
9762     subclass to receive widget context menu events.
9763 
9764     The handler is called when the widget's \l contextMenuPolicy is
9765     Qt::DefaultContextMenu.
9766 
9767     The default implementation ignores the context event.
9768     See the \l QContextMenuEvent documentation for more details.
9769 
9770     \sa event(), QContextMenuEvent, customContextMenuRequested()
9771 */
9772 
9773 void QWidget::contextMenuEvent(QContextMenuEvent *event)
9774 {
9775     event->ignore();
9776 }
9777 #endif // QT_NO_CONTEXTMENU
9778 
9779 
9780 /*!
9781     This event handler, for event \a event, can be reimplemented in a
9782     subclass to receive Input Method composition events. This handler
9783     is called when the state of the input method changes.
9784 
9785     Note that when creating custom text editing widgets, the
9786     Qt::WA_InputMethodEnabled window attribute must be set explicitly
9787     (using the setAttribute() function) in order to receive input
9788     method events.
9789 
9790     The default implementation calls event->ignore(), which rejects the
9791     Input Method event. See the \l QInputMethodEvent documentation for more
9792     details.
9793 
9794     \sa event(), QInputMethodEvent
9795 */
9796 void QWidget::inputMethodEvent(QInputMethodEvent *event)
9797 {
9798     event->ignore();
9799 }
9800 
9801 /*!
9802     This method is only relevant for input widgets. It is used by the
9803     input method to query a set of properties of the widget to be
9804     able to support complex input method operations as support for
9805     surrounding text and reconversions.
9806 
9807     \a query specifies which property is queried.
9808 
9809     \sa inputMethodEvent(), QInputMethodEvent, QInputMethodQueryEvent, inputMethodHints
9810 */
9811 QVariant QWidget::inputMethodQuery(Qt::InputMethodQuery query) const
9812 {
9813     switch(query) {
9814     case Qt::ImCursorRectangle:
9815         return QRect(width()/2, 0, 1, height());
9816     case Qt::ImFont:
9817         return font();
9818     case Qt::ImAnchorPosition:
9819         // Fallback.
9820         return inputMethodQuery(Qt::ImCursorPosition);
9821     case Qt::ImHints:
9822         return (int)inputMethodHints();
9823     case Qt::ImInputItemClipRectangle:
9824         return d_func()->clipRect();
9825     default:
9826         return QVariant();
9827     }
9828 }
9829 
9830 /*!
9831     \property QWidget::inputMethodHints
9832     \brief What input method specific hints the widget has.
9833 
9834     This is only relevant for input widgets. It is used by
9835     the input method to retrieve hints as to how the input method
9836     should operate. For example, if the Qt::ImhFormattedNumbersOnly flag
9837     is set, the input method may change its visual components to reflect
9838     that only numbers can be entered.
9839 
9840     \warning Some widgets require certain flags in order to work as
9841     intended. To set a flag, do \c{w->setInputMethodHints(w->inputMethodHints()|f)}
9842     instead of \c{w->setInputMethodHints(f)}.
9843 
9844     \note The flags are only hints, so the particular input method
9845           implementation is free to ignore them. If you want to be
9846           sure that a certain type of characters are entered,
9847           you should also set a QValidator on the widget.
9848 
9849     The default value is Qt::ImhNone.
9850 
9851     \since 4.6
9852 
9853     \sa inputMethodQuery()
9854 */
9855 Qt::InputMethodHints QWidget::inputMethodHints() const
9856 {
9857 #ifndef QT_NO_IM
9858     const QWidgetPrivate *priv = d_func();
9859     while (priv->inheritsInputMethodHints) {
9860         priv = priv->q_func()->parentWidget()->d_func();
9861         Q_ASSERT(priv);
9862     }
9863     return priv->imHints;
9864 #else //QT_NO_IM
9865     return 0;
9866 #endif //QT_NO_IM
9867 }
9868 
9869 void QWidget::setInputMethodHints(Qt::InputMethodHints hints)
9870 {
9871 #ifndef QT_NO_IM
9872     Q_D(QWidget);
9873     if (d->imHints == hints)
9874         return;
9875     d->imHints = hints;
9876     if (this == QGuiApplication::focusObject())
9877         QGuiApplication::inputMethod()->update(Qt::ImHints);
9878 #else
9879     Q_UNUSED(hints);
9880 #endif //QT_NO_IM
9881 }
9882 
9883 
9884 #ifndef QT_NO_DRAGANDDROP
9885 
9886 /*!
9887     \fn void QWidget::dragEnterEvent(QDragEnterEvent *event)
9888 
9889     This event handler is called when a drag is in progress and the
9890     mouse enters this widget. The event is passed in the \a event parameter.
9891 
9892     If the event is ignored, the widget won't receive any \l{dragMoveEvent()}{drag
9893     move events}.
9894 
9895     See the \l{dnd.html}{Drag-and-drop documentation} for an
9896     overview of how to provide drag-and-drop in your application.
9897 
9898     \sa QDrag, QDragEnterEvent
9899 */
9900 void QWidget::dragEnterEvent(QDragEnterEvent *)
9901 {
9902 }
9903 
9904 /*!
9905     \fn void QWidget::dragMoveEvent(QDragMoveEvent *event)
9906 
9907     This event handler is called if a drag is in progress, and when
9908     any of the following conditions occur: the cursor enters this widget,
9909     the cursor moves within this widget, or a modifier key is pressed on
9910     the keyboard while this widget has the focus. The event is passed
9911     in the \a event parameter.
9912 
9913     See the \l{dnd.html}{Drag-and-drop documentation} for an
9914     overview of how to provide drag-and-drop in your application.
9915 
9916     \sa QDrag, QDragMoveEvent
9917 */
9918 void QWidget::dragMoveEvent(QDragMoveEvent *)
9919 {
9920 }
9921 
9922 /*!
9923     \fn void QWidget::dragLeaveEvent(QDragLeaveEvent *event)
9924 
9925     This event handler is called when a drag is in progress and the
9926     mouse leaves this widget. The event is passed in the \a event
9927     parameter.
9928 
9929     See the \l{dnd.html}{Drag-and-drop documentation} for an
9930     overview of how to provide drag-and-drop in your application.
9931 
9932     \sa QDrag, QDragLeaveEvent
9933 */
9934 void QWidget::dragLeaveEvent(QDragLeaveEvent *)
9935 {
9936 }
9937 
9938 /*!
9939     \fn void QWidget::dropEvent(QDropEvent *event)
9940 
9941     This event handler is called when the drag is dropped on this
9942     widget. The event is passed in the \a event parameter.
9943 
9944     See the \l{dnd.html}{Drag-and-drop documentation} for an
9945     overview of how to provide drag-and-drop in your application.
9946 
9947     \sa QDrag, QDropEvent
9948 */
9949 void QWidget::dropEvent(QDropEvent *)
9950 {
9951 }
9952 
9953 #endif // QT_NO_DRAGANDDROP
9954 
9955 /*!
9956     \fn void QWidget::showEvent(QShowEvent *event)
9957 
9958     This event handler can be reimplemented in a subclass to receive
9959     widget show events which are passed in the \a event parameter.
9960 
9961     Non-spontaneous show events are sent to widgets immediately
9962     before they are shown. The spontaneous show events of windows are
9963     delivered afterwards.
9964 
9965     Note: A widget receives spontaneous show and hide events when its
9966     mapping status is changed by the window system, e.g. a spontaneous
9967     hide event when the user minimizes the window, and a spontaneous
9968     show event when the window is restored again. After receiving a
9969     spontaneous hide event, a widget is still considered visible in
9970     the sense of isVisible().
9971 
9972     \sa visible, event(), QShowEvent
9973 */
9974 void QWidget::showEvent(QShowEvent *)
9975 {
9976 }
9977 
9978 /*!
9979     \fn void QWidget::hideEvent(QHideEvent *event)
9980 
9981     This event handler can be reimplemented in a subclass to receive
9982     widget hide events. The event is passed in the \a event parameter.
9983 
9984     Hide events are sent to widgets immediately after they have been
9985     hidden.
9986 
9987     Note: A widget receives spontaneous show and hide events when its
9988     mapping status is changed by the window system, e.g. a spontaneous
9989     hide event when the user minimizes the window, and a spontaneous
9990     show event when the window is restored again. After receiving a
9991     spontaneous hide event, a widget is still considered visible in
9992     the sense of isVisible().
9993 
9994     \sa visible, event(), QHideEvent
9995 */
9996 void QWidget::hideEvent(QHideEvent *)
9997 {
9998 }
9999 
10000 /*!
10001     This special event handler can be reimplemented in a subclass to
10002     receive native platform events identified by \a eventType
10003     which are passed in the \a message parameter.
10004 
10005     In your reimplementation of this function, if you want to stop the
10006     event being handled by Qt, return true and set \a result.
10007     If you return false, this native event is passed back to Qt,
10008     which translates the event into a Qt event and sends it to the widget.
10009 
10010     \note Events are only delivered to this event handler if the widget is
10011     has a native Window handle.
10012 
10013     \note This function superseedes the event filter functions
10014     x11Event(), winEvent() and macEvent() of Qt 4.
10015 
10016     \table
10017     \header \li Platform \li Event Type Identifier \li Message Type \li Result Type
10018     \row \li Windows \li "windows_generic_MSG" \li MSG * \li LRESULT
10019     \row \li macOS \li "NSEvent" \li NSEvent * \li
10020     \endtable
10021 */
10022 
10023 bool QWidget::nativeEvent(const QByteArray &eventType, void *message, long *result)
10024 {
10025     Q_UNUSED(eventType);
10026     Q_UNUSED(message);
10027     Q_UNUSED(result);
10028     return false;
10029 }
10030 
10031 /*!
10032     Ensures that the widget and its children have been polished by
10033     QStyle (i.e., have a proper font and palette).
10034 
10035     QWidget calls this function after it has been fully constructed
10036     but before it is shown the very first time. You can call this
10037     function if you want to ensure that the widget is polished before
10038     doing an operation, e.g., the correct font size might be needed in
10039     the widget's sizeHint() reimplementation. Note that this function
10040     \e is called from the default implementation of sizeHint().
10041 
10042     Polishing is useful for final initialization that must happen after
10043     all constructors (from base classes as well as from subclasses)
10044     have been called.
10045 
10046     If you need to change some settings when a widget is polished,
10047     reimplement event() and handle the QEvent::Polish event type.
10048 
10049     \b{Note:} The function is declared const so that it can be called from
10050     other const functions (e.g., sizeHint()).
10051 
10052     \sa event()
10053 */
10054 void QWidget::ensurePolished() const
10055 {
10056     Q_D(const QWidget);
10057 
10058     const QMetaObject *m = metaObject();
10059     if (m == d->polished)
10060         return;
10061     d->polished = m;
10062 
10063     QEvent e(QEvent::Polish);
10064     QCoreApplication::sendEvent(const_cast<QWidget *>(this), &e);
10065 
10066     // polish children after 'this'
10067     QList<QObject*> children = d->children;
10068     for (int i = 0; i < children.size(); ++i) {
10069         QObject *o = children.at(i);
10070         if(!o->isWidgetType())
10071             continue;
10072         if (QWidget *w = qobject_cast<QWidget *>(o))
10073             w->ensurePolished();
10074     }
10075 
10076     if (d->parent && d->sendChildEvents) {
10077         QChildEvent e(QEvent::ChildPolished, const_cast<QWidget *>(this));
10078         QCoreApplication::sendEvent(d->parent, &e);
10079     }
10080 }
10081 
10082 /*!
10083     Returns the mask currently set on a widget. If no mask is set the
10084     return value will be an empty region.
10085 
10086     \sa setMask(), clearMask(), QRegion::isEmpty(), {Shaped Clock Example}
10087 */
10088 QRegion QWidget::mask() const
10089 {
10090     Q_D(const QWidget);
10091     return d->extra ? d->extra->mask : QRegion();
10092 }
10093 
10094 /*!
10095     Returns the layout manager that is installed on this widget, or 0
10096     if no layout manager is installed.
10097 
10098     The layout manager sets the geometry of the widget's children
10099     that have been added to the layout.
10100 
10101     \sa setLayout(), sizePolicy(), {Layout Management}
10102 */
10103 QLayout *QWidget::layout() const
10104 {
10105     return d_func()->layout;
10106 }
10107 
10108 
10109 /*!
10110     \fn void QWidget::setLayout(QLayout *layout)
10111 
10112     Sets the layout manager for this widget to \a layout.
10113 
10114     If there already is a layout manager installed on this widget,
10115     QWidget won't let you install another. You must first delete the
10116     existing layout manager (returned by layout()) before you can
10117     call setLayout() with the new layout.
10118 
10119     If \a layout is the layout manager on a different widget, setLayout()
10120     will reparent the layout and make it the layout manager for this widget.
10121 
10122     Example:
10123 
10124     \snippet layouts/layouts.cpp 24
10125 
10126     An alternative to calling this function is to pass this widget to
10127     the layout's constructor.
10128 
10129     The QWidget will take ownership of \a layout.
10130 
10131     \sa layout(), {Layout Management}
10132 */
10133 
10134 void QWidget::setLayout(QLayout *l)
10135 {
10136     if (Q_UNLIKELY(!l)) {
10137         qWarning("QWidget::setLayout: Cannot set layout to 0");
10138         return;
10139     }
10140     if (layout()) {
10141         if (Q_UNLIKELY(layout() != l))
10142             qWarning("QWidget::setLayout: Attempting to set QLayout \"%s\" on %s \"%s\", which already has a"
10143                      " layout", l->objectName().toLocal8Bit().data(), metaObject()->className(),
10144                      objectName().toLocal8Bit().data());
10145         return;
10146     }
10147 
10148     QObject *oldParent = l->parent();
10149     if (oldParent && oldParent != this) {
10150         if (oldParent->isWidgetType()) {
10151             // Steal the layout off a widget parent. Takes effect when
10152             // morphing laid-out container widgets in Designer.
10153             QWidget *oldParentWidget = static_cast<QWidget *>(oldParent);
10154             oldParentWidget->takeLayout();
10155         } else {
10156             qWarning("QWidget::setLayout: Attempting to set QLayout \"%s\" on %s \"%s\", when the QLayout already has a parent",
10157                      l->objectName().toLocal8Bit().data(), metaObject()->className(),
10158                      objectName().toLocal8Bit().data());
10159             return;
10160         }
10161     }
10162 
10163     Q_D(QWidget);
10164     l->d_func()->topLevel = true;
10165     d->layout = l;
10166     if (oldParent != this) {
10167         l->setParent(this);
10168         l->d_func()->reparentChildWidgets(this);
10169         l->invalidate();
10170     }
10171 
10172     if (isWindow() && d->maybeTopData())
10173         d->topData()->sizeAdjusted = false;
10174 }
10175 
10176 /*!
10177     \fn QLayout *QWidget::takeLayout()
10178 
10179     Remove the layout from the widget.
10180     \since 4.5
10181 */
10182 
10183 QLayout *QWidget::takeLayout()
10184 {
10185     Q_D(QWidget);
10186     QLayout *l =  layout();
10187     if (!l)
10188         return 0;
10189     d->layout = 0;
10190     l->setParent(0);
10191     return l;
10192 }
10193 
10194 /*!
10195     \property QWidget::sizePolicy
10196     \brief the default layout behavior of the widget
10197 
10198     If there is a QLayout that manages this widget's children, the
10199     size policy specified by that layout is used. If there is no such
10200     QLayout, the result of this function is used.
10201 
10202     The default policy is Preferred/Preferred, which means that the
10203     widget can be freely resized, but prefers to be the size
10204     sizeHint() returns. Button-like widgets set the size policy to
10205     specify that they may stretch horizontally, but are fixed
10206     vertically. The same applies to lineedit controls (such as
10207     QLineEdit, QSpinBox or an editable QComboBox) and other
10208     horizontally orientated widgets (such as QProgressBar).
10209     QToolButton's are normally square, so they allow growth in both
10210     directions. Widgets that support different directions (such as
10211     QSlider, QScrollBar or QHeader) specify stretching in the
10212     respective direction only. Widgets that can provide scroll bars
10213     (usually subclasses of QScrollArea) tend to specify that they can
10214     use additional space, and that they can make do with less than
10215     sizeHint().
10216 
10217     \sa sizeHint(), QLayout, QSizePolicy, updateGeometry()
10218 */
10219 QSizePolicy QWidget::sizePolicy() const
10220 {
10221     Q_D(const QWidget);
10222     return d->size_policy;
10223 }
10224 
10225 void QWidget::setSizePolicy(QSizePolicy policy)
10226 {
10227     Q_D(QWidget);
10228     setAttribute(Qt::WA_WState_OwnSizePolicy);
10229     if (policy == d->size_policy)
10230         return;
10231 
10232     if (d->size_policy.retainSizeWhenHidden() != policy.retainSizeWhenHidden())
10233         d->retainSizeWhenHiddenChanged = 1;
10234 
10235     d->size_policy = policy;
10236 
10237 #if QT_CONFIG(graphicsview)
10238     if (QWExtra *extra = d->extra) {
10239         if (extra->proxyWidget)
10240             extra->proxyWidget->setSizePolicy(policy);
10241     }
10242 #endif
10243 
10244     updateGeometry();
10245     d->retainSizeWhenHiddenChanged = 0;
10246 
10247     if (isWindow() && d->maybeTopData())
10248         d->topData()->sizeAdjusted = false;
10249 }
10250 
10251 /*!
10252     \fn void QWidget::setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)
10253     \overload
10254 
10255     Sets the size policy of the widget to \a horizontal and \a
10256     vertical, with standard stretch and no height-for-width.
10257 
10258     \sa QSizePolicy::QSizePolicy()
10259 */
10260 
10261 /*!
10262     Returns the preferred height for this widget, given the width \a w.
10263 
10264     If this widget has a layout, the default implementation returns
10265     the layout's preferred height.  if there is no layout, the default
10266     implementation returns -1 indicating that the preferred height
10267     does not depend on the width.
10268 */
10269 
10270 int QWidget::heightForWidth(int w) const
10271 {
10272     if (layout() && layout()->hasHeightForWidth())
10273         return layout()->totalHeightForWidth(w);
10274     return -1;
10275 }
10276 
10277 
10278 /*!
10279     \since 5.0
10280 
10281     Returns \c true if the widget's preferred height depends on its width; otherwise returns \c false.
10282 */
10283 bool QWidget::hasHeightForWidth() const
10284 {
10285     Q_D(const QWidget);
10286     return d->layout ? d->layout->hasHeightForWidth() : d->size_policy.hasHeightForWidth();
10287 }
10288 
10289 /*!
10290     \fn QWidget *QWidget::childAt(int x, int y) const
10291 
10292     Returns the visible child widget at the position (\a{x}, \a{y})
10293     in the widget's coordinate system. If there is no visible child
10294     widget at the specified position, the function returns 0.
10295 */
10296 
10297 /*!
10298     \overload
10299 
10300     Returns the visible child widget at point \a p in the widget's own
10301     coordinate system.
10302 */
10303 
10304 QWidget *QWidget::childAt(const QPoint &p) const
10305 {
10306     return d_func()->childAt_helper(p, false);
10307 }
10308 
10309 QWidget *QWidgetPrivate::childAt_helper(const QPoint &p, bool ignoreChildrenInDestructor) const
10310 {
10311     if (children.isEmpty())
10312         return 0;
10313 
10314     if (!pointInsideRectAndMask(p))
10315         return 0;
10316     return childAtRecursiveHelper(p, ignoreChildrenInDestructor);
10317 }
10318 
10319 QWidget *QWidgetPrivate::childAtRecursiveHelper(const QPoint &p, bool ignoreChildrenInDestructor) const
10320 {
10321     for (int i = children.size() - 1; i >= 0; --i) {
10322         QWidget *child = qobject_cast<QWidget *>(children.at(i));
10323         if (!child || child->isWindow() || child->isHidden() || child->testAttribute(Qt::WA_TransparentForMouseEvents)
10324             || (ignoreChildrenInDestructor && child->data->in_destructor)) {
10325             continue;
10326         }
10327 
10328         // Map the point 'p' from parent coordinates to child coordinates.
10329         QPoint childPoint = p;
10330         childPoint -= child->data->crect.topLeft();
10331 
10332         // Check if the point hits the child.
10333         if (!child->d_func()->pointInsideRectAndMask(childPoint))
10334             continue;
10335 
10336         // Do the same for the child's descendants.
10337         if (QWidget *w = child->d_func()->childAtRecursiveHelper(childPoint, ignoreChildrenInDestructor))
10338             return w;
10339 
10340         // We have found our target; namely the child at position 'p'.
10341         return child;
10342     }
10343     return 0;
10344 }
10345 
10346 void QWidgetPrivate::updateGeometry_helper(bool forceUpdate)
10347 {
10348     Q_Q(QWidget);
10349     if (widgetItem)
10350         widgetItem->invalidateSizeCache();
10351     QWidget *parent;
10352     if (forceUpdate || !extra || extra->minw != extra->maxw || extra->minh != extra->maxh) {
10353         const int isHidden = q->isHidden() && !size_policy.retainSizeWhenHidden() && !retainSizeWhenHiddenChanged;
10354 
10355         if (!q->isWindow() && !isHidden && (parent = q->parentWidget())) {
10356             if (parent->d_func()->layout)
10357                 parent->d_func()->layout->invalidate();
10358             else if (parent->isVisible())
10359                 QApplication::postEvent(parent, new QEvent(QEvent::LayoutRequest));
10360         }
10361     }
10362 }
10363 
10364 /*!
10365     Notifies the layout system that this widget has changed and may
10366     need to change geometry.
10367 
10368     Call this function if the sizeHint() or sizePolicy() have changed.
10369 
10370     For explicitly hidden widgets, updateGeometry() is a no-op. The
10371     layout system will be notified as soon as the widget is shown.
10372 */
10373 
10374 void QWidget::updateGeometry()
10375 {
10376     Q_D(QWidget);
10377     d->updateGeometry_helper(false);
10378 }
10379 
10380 /*! \property QWidget::windowFlags
10381 
10382     Window flags are a combination of a type (e.g. Qt::Dialog) and
10383     zero or more hints to the window system (e.g.
10384     Qt::FramelessWindowHint).
10385 
10386     If the widget had type Qt::Widget or Qt::SubWindow and becomes a
10387     window (Qt::Window, Qt::Dialog, etc.), it is put at position (0,
10388     0) on the desktop. If the widget is a window and becomes a
10389     Qt::Widget or Qt::SubWindow, it is put at position (0, 0)
10390     relative to its parent widget.
10391 
10392     \note This function calls setParent() when changing the flags for
10393     a window, causing the widget to be hidden. You must call show() to make
10394     the widget visible again..
10395 
10396     \sa windowType(), setWindowFlag(), {Window Flags Example}
10397 */
10398 void QWidget::setWindowFlags(Qt::WindowFlags flags)
10399 {
10400     Q_D(QWidget);
10401     d->setWindowFlags(flags);
10402 }
10403 
10404 /*!
10405     \since 5.9
10406 
10407     Sets the window flag \a flag on this widget if \a on is true;
10408     otherwise clears the flag.
10409 
10410     \sa setWindowFlags(), windowFlags(), windowType()
10411 */
10412 void QWidget::setWindowFlag(Qt::WindowType flag, bool on)
10413 {
10414     Q_D(QWidget);
10415     if (on)
10416         d->setWindowFlags(data->window_flags | flag);
10417     else
10418         d->setWindowFlags(data->window_flags & ~flag);
10419 }
10420 
10421 /*! \internal
10422 
10423     Implemented in QWidgetPrivate so that QMdiSubWindowPrivate can reimplement it.
10424 */
10425 void QWidgetPrivate::setWindowFlags(Qt::WindowFlags flags)
10426 {
10427     Q_Q(QWidget);
10428     if (q->data->window_flags == flags)
10429         return;
10430 
10431     if ((q->data->window_flags | flags) & Qt::Window) {
10432         // the old type was a window and/or the new type is a window
10433         QPoint oldPos = q->pos();
10434         bool visible = q->isVisible();
10435         const bool windowFlagChanged = (q->data->window_flags ^ flags) & Qt::Window;
10436         q->setParent(q->parentWidget(), flags);
10437 
10438         // if both types are windows or neither of them are, we restore
10439         // the old position
10440         if (!windowFlagChanged && (visible || q->testAttribute(Qt::WA_Moved)))
10441             q->move(oldPos);
10442         // for backward-compatibility we change Qt::WA_QuitOnClose attribute value only when the window was recreated.
10443         adjustQuitOnCloseAttribute();
10444     } else {
10445         q->data->window_flags = flags;
10446     }
10447 }
10448 
10449 /*!
10450     Sets the window flags for the widget to \a flags,
10451     \e without telling the window system.
10452 
10453     \warning Do not call this function unless you really know what
10454     you're doing.
10455 
10456     \sa setWindowFlags()
10457 */
10458 void QWidget::overrideWindowFlags(Qt::WindowFlags flags)
10459 {
10460     data->window_flags = flags;
10461 }
10462 
10463 /*!
10464     \fn Qt::WindowType QWidget::windowType() const
10465 
10466     Returns the window type of this widget. This is identical to
10467     windowFlags() & Qt::WindowType_Mask.
10468 
10469     \sa windowFlags
10470 */
10471 
10472 /*!
10473     Sets the parent of the widget to \a parent, and resets the window
10474     flags. The widget is moved to position (0, 0) in its new parent.
10475 
10476     If the new parent widget is in a different window, the
10477     reparented widget and its children are appended to the end of the
10478     \l{setFocusPolicy()}{tab chain} of the new parent
10479     widget, in the same internal order as before. If one of the moved
10480     widgets had keyboard focus, setParent() calls clearFocus() for that
10481     widget.
10482 
10483     If the new parent widget is in the same window as the
10484     old parent, setting the parent doesn't change the tab order or
10485     keyboard focus.
10486 
10487     If the "new" parent widget is the old parent widget, this function
10488     does nothing.
10489 
10490     \note The widget becomes invisible as part of changing its parent,
10491     even if it was previously visible. You must call show() to make the
10492     widget visible again.
10493 
10494     \warning It is very unlikely that you will ever need this
10495     function. If you have a widget that changes its content
10496     dynamically, it is far easier to use \l QStackedWidget.
10497 
10498     \sa setWindowFlags()
10499 */
10500 void QWidget::setParent(QWidget *parent)
10501 {
10502     if (parent == parentWidget())
10503         return;
10504     setParent((QWidget*)parent, windowFlags() & ~Qt::WindowType_Mask);
10505 }
10506 
10507 #ifndef QT_NO_OPENGL
10508 static void sendWindowChangeToTextureChildrenRecursively(QWidget *widget)
10509 {
10510     QWidgetPrivate *d = QWidgetPrivate::get(widget);
10511     if (d->renderToTexture) {
10512         QEvent e(QEvent::WindowChangeInternal);
10513         QApplication::sendEvent(widget, &e);
10514     }
10515 
10516     for (int i = 0; i < d->children.size(); ++i) {
10517         QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
10518         if (w && !w->isWindow() && QWidgetPrivate::get(w)->textureChildSeen)
10519             sendWindowChangeToTextureChildrenRecursively(w);
10520     }
10521 }
10522 #endif
10523 
10524 /*!
10525     \overload
10526 
10527     This function also takes widget flags, \a f as an argument.
10528 */
10529 
10530 void QWidget::setParent(QWidget *parent, Qt::WindowFlags f)
10531 {
10532     Q_D(QWidget);
10533     bool resized = testAttribute(Qt::WA_Resized);
10534     bool wasCreated = testAttribute(Qt::WA_WState_Created);
10535     QWidget *oldtlw = window();
10536 
10537     if (f & Qt::Window) // Frame geometry likely changes, refresh.
10538         d->data.fstrut_dirty = true;
10539 
10540     QWidget *desktopWidget = 0;
10541     if (parent && parent->windowType() == Qt::Desktop)
10542         desktopWidget = parent;
10543     bool newParent = (parent != parentWidget()) || !wasCreated || desktopWidget;
10544 
10545     if (newParent && parent && !desktopWidget) {
10546         if (testAttribute(Qt::WA_NativeWindow) && !qApp->testAttribute(Qt::AA_DontCreateNativeWidgetSiblings))
10547             parent->d_func()->enforceNativeChildren();
10548         else if (parent->d_func()->nativeChildrenForced() || parent->testAttribute(Qt::WA_PaintOnScreen))
10549             setAttribute(Qt::WA_NativeWindow);
10550     }
10551 
10552     if (wasCreated) {
10553         if (!testAttribute(Qt::WA_WState_Hidden)) {
10554             hide();
10555             setAttribute(Qt::WA_WState_ExplicitShowHide, false);
10556         }
10557         if (newParent) {
10558             QEvent e(QEvent::ParentAboutToChange);
10559             QApplication::sendEvent(this, &e);
10560         }
10561     }
10562     if (newParent && isAncestorOf(focusWidget()))
10563         focusWidget()->clearFocus();
10564 
10565     QTLWExtra *oldTopExtra = window()->d_func()->maybeTopData();
10566     QWidgetBackingStoreTracker *oldBsTracker = oldTopExtra ? &oldTopExtra->backingStoreTracker : 0;
10567 
10568     d->setParent_sys(parent, f);
10569 
10570     QTLWExtra *topExtra = window()->d_func()->maybeTopData();
10571     QWidgetBackingStoreTracker *bsTracker = topExtra ? &topExtra->backingStoreTracker : 0;
10572     if (oldBsTracker && oldBsTracker != bsTracker)
10573         oldBsTracker->unregisterWidgetSubtree(this);
10574 
10575     if (desktopWidget)
10576         parent = 0;
10577 
10578 #ifndef QT_NO_OPENGL
10579     if (d->textureChildSeen && parent) {
10580         // set the textureChildSeen flag up the whole parent chain
10581         QWidgetPrivate::get(parent)->setTextureChildSeen();
10582     }
10583 #endif
10584 
10585     if (QWidgetBackingStore *oldBs = oldtlw->d_func()->maybeBackingStore()) {
10586         if (newParent)
10587             oldBs->removeDirtyWidget(this);
10588         // Move the widget and all its static children from
10589         // the old backing store to the new one.
10590         oldBs->moveStaticWidgets(this);
10591     }
10592 
10593     // ### fixme: Qt 6: Remove AA_ImmediateWidgetCreation.
10594     if (QApplicationPrivate::testAttribute(Qt::AA_ImmediateWidgetCreation) && !testAttribute(Qt::WA_WState_Created))
10595         create();
10596 
10597     d->reparentFocusWidgets(oldtlw);
10598     setAttribute(Qt::WA_Resized, resized);
10599 
10600     const bool useStyleSheetPropagationInWidgetStyles =
10601         QCoreApplication::testAttribute(Qt::AA_UseStyleSheetPropagationInWidgetStyles);
10602 
10603     if (!useStyleSheetPropagationInWidgetStyles && !testAttribute(Qt::WA_StyleSheet)
10604         && (!parent || !parent->testAttribute(Qt::WA_StyleSheet))) {
10605         d->resolveFont();
10606         d->resolvePalette();
10607     }
10608     d->resolveLayoutDirection();
10609     d->resolveLocale();
10610 
10611     // Note: GL widgets under WGL or EGL will always need a ParentChange
10612     // event to handle recreation/rebinding of the GL context, hence the
10613     // (f & Qt::MSWindowsOwnDC) clause (which is set on QGLWidgets on all
10614     // platforms).
10615     if (newParent
10616 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || defined(QT_OPENGL_ES)
10617         || (f & Qt::MSWindowsOwnDC)
10618 #endif
10619         ) {
10620         // propagate enabled updates enabled state to non-windows
10621         if (!isWindow()) {
10622             if (!testAttribute(Qt::WA_ForceDisabled))
10623                 d->setEnabled_helper(parent ? parent->isEnabled() : true);
10624             if (!testAttribute(Qt::WA_ForceUpdatesDisabled))
10625                 d->setUpdatesEnabled_helper(parent ? parent->updatesEnabled() : true);
10626         }
10627         d->inheritStyle();
10628 
10629         // send and post remaining QObject events
10630         if (parent && d->sendChildEvents) {
10631             QChildEvent e(QEvent::ChildAdded, this);
10632             QApplication::sendEvent(parent, &e);
10633         }
10634 
10635 //### already hidden above ---> must probably do something smart on the mac
10636 // #if 0 // Used to be included in Qt4 for Q_WS_MAC
10637 //             extern bool qt_mac_is_macdrawer(const QWidget *); //qwidget_mac.cpp
10638 //             if(!qt_mac_is_macdrawer(q)) //special case
10639 //                 q->setAttribute(Qt::WA_WState_Hidden);
10640 // #else
10641 //             q->setAttribute(Qt::WA_WState_Hidden);
10642 //#endif
10643 
10644         if (parent && d->sendChildEvents && d->polished) {
10645             QChildEvent e(QEvent::ChildPolished, this);
10646             QCoreApplication::sendEvent(parent, &e);
10647         }
10648 
10649         QEvent e(QEvent::ParentChange);
10650         QApplication::sendEvent(this, &e);
10651     }
10652 #ifndef QT_NO_OPENGL
10653     //renderToTexture widgets also need to know when their top-level window changes
10654     if (d->textureChildSeen && oldtlw != window()) {
10655         sendWindowChangeToTextureChildrenRecursively(this);
10656     }
10657 #endif
10658 
10659     if (!wasCreated) {
10660         if (isWindow() || parentWidget()->isVisible())
10661             setAttribute(Qt::WA_WState_Hidden, true);
10662         else if (!testAttribute(Qt::WA_WState_ExplicitShowHide))
10663             setAttribute(Qt::WA_WState_Hidden, false);
10664     }
10665 
10666     d->updateIsOpaque();
10667 
10668 #if QT_CONFIG(graphicsview)
10669     // Embed the widget into a proxy if the parent is embedded.
10670     // ### Doesn't handle reparenting out of an embedded widget.
10671     if (oldtlw->graphicsProxyWidget()) {
10672         if (QGraphicsProxyWidget *ancestorProxy = d->nearestGraphicsProxyWidget(oldtlw))
10673             ancestorProxy->d_func()->unembedSubWindow(this);
10674     }
10675     if (isWindow() && parent && !graphicsProxyWidget() && !bypassGraphicsProxyWidget(this)) {
10676         if (QGraphicsProxyWidget *ancestorProxy = d->nearestGraphicsProxyWidget(parent))
10677             ancestorProxy->d_func()->embedSubWindow(this);
10678     }
10679 #endif
10680 
10681     if (d->extra && d->extra->hasWindowContainer)
10682         QWindowContainer::parentWasChanged(this);
10683 }
10684 
10685 void QWidgetPrivate::setParent_sys(QWidget *newparent, Qt::WindowFlags f)
10686 {
10687     Q_Q(QWidget);
10688 
10689     Qt::WindowFlags oldFlags = data.window_flags;
10690     bool wasCreated = q->testAttribute(Qt::WA_WState_Created);
10691 
10692     int targetScreen = -1;
10693     // Handle a request to move the widget to a particular screen
10694     if (newparent && newparent->windowType() == Qt::Desktop) {
10695         // make sure the widget is created on the same screen as the
10696         // programmer specified desktop widget
10697         const QDesktopScreenWidget *sw = qobject_cast<const QDesktopScreenWidget *>(newparent);
10698         targetScreen = sw ? sw->screenNumber() : 0;
10699         newparent = 0;
10700     }
10701 
10702     setWinId(0);
10703 
10704     if (parent != newparent) {
10705         QObjectPrivate::setParent_helper(newparent); //### why does this have to be done in the _sys function???
10706         if (q->windowHandle()) {
10707             q->windowHandle()->setFlags(f);
10708             QWidget *parentWithWindow =
10709                 newparent ? (newparent->windowHandle() ? newparent : newparent->nativeParentWidget()) : 0;
10710             if (parentWithWindow) {
10711                 QWidget *topLevel = parentWithWindow->window();
10712                 if ((f & Qt::Window) && topLevel && topLevel->windowHandle()) {
10713                     q->windowHandle()->setTransientParent(topLevel->windowHandle());
10714                     q->windowHandle()->setParent(0);
10715                 } else {
10716                     q->windowHandle()->setTransientParent(0);
10717                     q->windowHandle()->setParent(parentWithWindow->windowHandle());
10718                 }
10719             } else {
10720                 q->windowHandle()->setTransientParent(0);
10721                 q->windowHandle()->setParent(0);
10722             }
10723         }
10724     }
10725 
10726     if (!newparent) {
10727         f |= Qt::Window;
10728         if (targetScreen == -1) {
10729             if (parent)
10730                 targetScreen = QDesktopWidgetPrivate::screenNumber(q->parentWidget()->window());
10731         }
10732     }
10733 
10734     bool explicitlyHidden = q->testAttribute(Qt::WA_WState_Hidden) && q->testAttribute(Qt::WA_WState_ExplicitShowHide);
10735 
10736     // Reparenting toplevel to child
10737     if (wasCreated && !(f & Qt::Window) && (oldFlags & Qt::Window) && !q->testAttribute(Qt::WA_NativeWindow)) {
10738         if (extra && extra->hasWindowContainer)
10739             QWindowContainer::toplevelAboutToBeDestroyed(q);
10740 
10741         QWindow *newParentWindow = newparent->windowHandle();
10742         if (!newParentWindow)
10743             if (QWidget *npw = newparent->nativeParentWidget())
10744                 newParentWindow = npw->windowHandle();
10745 
10746         Q_FOREACH (QObject *child, q->windowHandle()->children()) {
10747             QWindow *childWindow = qobject_cast<QWindow *>(child);
10748             if (!childWindow)
10749                 continue;
10750 
10751             QWidgetWindow *childWW = qobject_cast<QWidgetWindow *>(childWindow);
10752             QWidget *childWidget = childWW ? childWW->widget() : 0;
10753             if (!childWW || (childWidget && childWidget->testAttribute(Qt::WA_NativeWindow)))
10754                 childWindow->setParent(newParentWindow);
10755         }
10756         q->destroy();
10757     }
10758 
10759     adjustFlags(f, q);
10760     data.window_flags = f;
10761     q->setAttribute(Qt::WA_WState_Created, false);
10762     q->setAttribute(Qt::WA_WState_Visible, false);
10763     q->setAttribute(Qt::WA_WState_Hidden, false);
10764 
10765     if (newparent && wasCreated && (q->testAttribute(Qt::WA_NativeWindow) || (f & Qt::Window)))
10766         q->createWinId();
10767 
10768     if (q->isWindow() || (!newparent || newparent->isVisible()) || explicitlyHidden)
10769         q->setAttribute(Qt::WA_WState_Hidden);
10770     q->setAttribute(Qt::WA_WState_ExplicitShowHide, explicitlyHidden);
10771 
10772     // move the window to the selected screen
10773     if (!newparent && targetScreen != -1) {
10774         // only if it is already created
10775         if (q->testAttribute(Qt::WA_WState_Created))
10776             q->windowHandle()->setScreen(QGuiApplication::screens().value(targetScreen, 0));
10777         else
10778             topData()->initialScreenIndex = targetScreen;
10779     }
10780 }
10781 
10782 /*!
10783     Scrolls the widget including its children \a dx pixels to the
10784     right and \a dy downward. Both \a dx and \a dy may be negative.
10785 
10786     After scrolling, the widgets will receive paint events for
10787     the areas that need to be repainted. For widgets that Qt knows to
10788     be opaque, this is only the newly exposed parts.
10789     For example, if an opaque widget is scrolled 8 pixels to the left,
10790     only an 8-pixel wide stripe at the right edge needs updating.
10791 
10792     Since widgets propagate the contents of their parents by default,
10793     you need to set the \l autoFillBackground property, or use
10794     setAttribute() to set the Qt::WA_OpaquePaintEvent attribute, to make
10795     a widget opaque.
10796 
10797     For widgets that use contents propagation, a scroll will cause an
10798     update of the entire scroll area.
10799 
10800     \sa {Transparency and Double Buffering}
10801 */
10802 
10803 void QWidget::scroll(int dx, int dy)
10804 {
10805     if ((!updatesEnabled() && children().size() == 0) || !isVisible())
10806         return;
10807     if (dx == 0 && dy == 0)
10808         return;
10809     Q_D(QWidget);
10810 #if QT_CONFIG(graphicsview)
10811     if (QGraphicsProxyWidget *proxy = QWidgetPrivate::nearestGraphicsProxyWidget(this)) {
10812         // Graphics View maintains its own dirty region as a list of rects;
10813         // until we can connect item updates directly to the view, we must
10814         // separately add a translated dirty region.
10815         for (const QRect &rect : d->dirty)
10816             proxy->update(rect.translated(dx, dy));
10817         proxy->scroll(dx, dy, proxy->subWidgetRect(this));
10818         return;
10819     }
10820 #endif
10821     d->setDirtyOpaqueRegion();
10822     d->scroll_sys(dx, dy);
10823 }
10824 
10825 void QWidgetPrivate::scroll_sys(int dx, int dy)
10826 {
10827     Q_Q(QWidget);
10828     scrollChildren(dx, dy);
10829     scrollRect(q->rect(), dx, dy);
10830 }
10831 
10832 /*!
10833     \overload
10834 
10835     This version only scrolls \a r and does not move the children of
10836     the widget.
10837 
10838     If \a r is empty or invalid, the result is undefined.
10839 
10840     \sa QScrollArea
10841 */
10842 void QWidget::scroll(int dx, int dy, const QRect &r)
10843 {
10844 
10845     if ((!updatesEnabled() && children().size() == 0) || !isVisible())
10846         return;
10847     if (dx == 0 && dy == 0)
10848         return;
10849     Q_D(QWidget);
10850 #if QT_CONFIG(graphicsview)
10851     if (QGraphicsProxyWidget *proxy = QWidgetPrivate::nearestGraphicsProxyWidget(this)) {
10852         // Graphics View maintains its own dirty region as a list of rects;
10853         // until we can connect item updates directly to the view, we must
10854         // separately add a translated dirty region.
10855         if (!d->dirty.isEmpty()) {
10856             for (const QRect &rect : d->dirty.translated(dx, dy) & r)
10857                 proxy->update(rect);
10858         }
10859         proxy->scroll(dx, dy, r.translated(proxy->subWidgetRect(this).topLeft().toPoint()));
10860         return;
10861     }
10862 #endif
10863     d->scroll_sys(dx, dy, r);
10864 }
10865 
10866 void QWidgetPrivate::scroll_sys(int dx, int dy, const QRect &r)
10867 {
10868     scrollRect(r, dx, dy);
10869 }
10870 
10871 /*!
10872     Repaints the widget directly by calling paintEvent() immediately,
10873     unless updates are disabled or the widget is hidden.
10874 
10875     We suggest only using repaint() if you need an immediate repaint,
10876     for example during animation. In almost all circumstances update()
10877     is better, as it permits Qt to optimize for speed and minimize
10878     flicker.
10879 
10880     \warning If you call repaint() in a function which may itself be
10881     called from paintEvent(), you may get infinite recursion. The
10882     update() function never causes recursion.
10883 
10884     \sa update(), paintEvent(), setUpdatesEnabled()
10885 */
10886 
10887 void QWidget::repaint()
10888 {
10889     repaint(rect());
10890 }
10891 
10892 /*! \overload
10893 
10894     This version repaints a rectangle (\a x, \a y, \a w, \a h) inside
10895     the widget.
10896 
10897     If \a w is negative, it is replaced with \c{width() - x}, and if
10898     \a h is negative, it is replaced width \c{height() - y}.
10899 */
10900 void QWidget::repaint(int x, int y, int w, int h)
10901 {
10902     if (x > data->crect.width() || y > data->crect.height())
10903         return;
10904 
10905     if (w < 0)
10906         w = data->crect.width()  - x;
10907     if (h < 0)
10908         h = data->crect.height() - y;
10909 
10910     repaint(QRect(x, y, w, h));
10911 }
10912 
10913 /*! \overload
10914 
10915     This version repaints a rectangle \a rect inside the widget.
10916 */
10917 void QWidget::repaint(const QRect &rect)
10918 {
10919     Q_D(QWidget);
10920 
10921     if (testAttribute(Qt::WA_WState_ConfigPending)) {
10922         update(rect);
10923         return;
10924     }
10925 
10926     if (!isVisible() || !updatesEnabled() || rect.isEmpty())
10927         return;
10928 
10929     if (hasBackingStoreSupport()) {
10930         QTLWExtra *tlwExtra = window()->d_func()->maybeTopData();
10931         if (tlwExtra && !tlwExtra->inTopLevelResize && tlwExtra->backingStore) {
10932             tlwExtra->inRepaint = true;
10933             tlwExtra->backingStoreTracker->markDirty(rect, this, QWidgetBackingStore::UpdateNow);
10934             tlwExtra->inRepaint = false;
10935         }
10936     } else {
10937         d->repaint_sys(rect);
10938     }
10939 }
10940 
10941 /*!
10942     \overload
10943 
10944     This version repaints a region \a rgn inside the widget.
10945 */
10946 void QWidget::repaint(const QRegion &rgn)
10947 {
10948     Q_D(QWidget);
10949 
10950     if (testAttribute(Qt::WA_WState_ConfigPending)) {
10951         update(rgn);
10952         return;
10953     }
10954 
10955     if (!isVisible() || !updatesEnabled() || rgn.isEmpty())
10956         return;
10957 
10958     if (hasBackingStoreSupport()) {
10959         QTLWExtra *tlwExtra = window()->d_func()->maybeTopData();
10960         if (tlwExtra && !tlwExtra->inTopLevelResize && tlwExtra->backingStore) {
10961             tlwExtra->inRepaint = true;
10962             tlwExtra->backingStoreTracker->markDirty(rgn, this, QWidgetBackingStore::UpdateNow);
10963             tlwExtra->inRepaint = false;
10964         }
10965     } else {
10966         d->repaint_sys(rgn);
10967     }
10968 }
10969 
10970 /*!
10971     Updates the widget unless updates are disabled or the widget is
10972     hidden.
10973 
10974     This function does not cause an immediate repaint; instead it
10975     schedules a paint event for processing when Qt returns to the main
10976     event loop. This permits Qt to optimize for more speed and less
10977     flicker than a call to repaint() does.
10978 
10979     Calling update() several times normally results in just one
10980     paintEvent() call.
10981 
10982     Qt normally erases the widget's area before the paintEvent() call.
10983     If the Qt::WA_OpaquePaintEvent widget attribute is set, the widget is
10984     responsible for painting all its pixels with an opaque color.
10985 
10986     \sa repaint(), paintEvent(), setUpdatesEnabled(), {Analog Clock Example}
10987 */
10988 void QWidget::update()
10989 {
10990     update(rect());
10991 }
10992 
10993 /*! \fn void QWidget::update(int x, int y, int w, int h)
10994     \overload
10995 
10996     This version updates a rectangle (\a x, \a y, \a w, \a h) inside
10997     the widget.
10998 */
10999 
11000 /*!
11001     \overload
11002 
11003     This version updates a rectangle \a rect inside the widget.
11004 */
11005 void QWidget::update(const QRect &rect)
11006 {
11007     if (!isVisible() || !updatesEnabled())
11008         return;
11009 
11010     QRect r = rect & QWidget::rect();
11011 
11012     if (r.isEmpty())
11013         return;
11014 
11015     if (testAttribute(Qt::WA_WState_InPaintEvent)) {
11016         QApplication::postEvent(this, new QUpdateLaterEvent(r));
11017         return;
11018     }
11019 
11020     if (hasBackingStoreSupport()) {
11021         QTLWExtra *tlwExtra = window()->d_func()->maybeTopData();
11022         if (tlwExtra && !tlwExtra->inTopLevelResize && tlwExtra->backingStore)
11023             tlwExtra->backingStoreTracker->markDirty(r, this);
11024     } else {
11025         d_func()->repaint_sys(r);
11026     }
11027 }
11028 
11029 /*!
11030     \overload
11031 
11032     This version repaints a region \a rgn inside the widget.
11033 */
11034 void QWidget::update(const QRegion &rgn)
11035 {
11036     if (!isVisible() || !updatesEnabled())
11037         return;
11038 
11039     QRegion r = rgn & QWidget::rect();
11040 
11041     if (r.isEmpty())
11042         return;
11043 
11044     if (testAttribute(Qt::WA_WState_InPaintEvent)) {
11045         QApplication::postEvent(this, new QUpdateLaterEvent(r));
11046         return;
11047     }
11048 
11049     if (hasBackingStoreSupport()) {
11050         QTLWExtra *tlwExtra = window()->d_func()->maybeTopData();
11051         if (tlwExtra && !tlwExtra->inTopLevelResize && tlwExtra->backingStore)
11052             tlwExtra->backingStoreTracker->markDirty(r, this);
11053     } else {
11054         d_func()->repaint_sys(r);
11055     }
11056 }
11057 
11058 
11059  /*!
11060   \internal
11061 
11062   This just sets the corresponding attribute bit to 1 or 0
11063  */
11064 static void setAttribute_internal(Qt::WidgetAttribute attribute, bool on, QWidgetData *data,
11065                                   QWidgetPrivate *d)
11066 {
11067     if (attribute < int(8*sizeof(uint))) {
11068         if (on)
11069             data->widget_attributes |= (1<<attribute);
11070         else
11071             data->widget_attributes &= ~(1<<attribute);
11072     } else {
11073         const int x = attribute - 8*sizeof(uint);
11074         const int int_off = x / (8*sizeof(uint));
11075         if (on)
11076             d->high_attributes[int_off] |= (1<<(x-(int_off*8*sizeof(uint))));
11077         else
11078             d->high_attributes[int_off] &= ~(1<<(x-(int_off*8*sizeof(uint))));
11079     }
11080 }
11081 
11082 #ifdef Q_OS_MAC
11083 void QWidgetPrivate::macUpdateSizeAttribute()
11084 {
11085     Q_Q(QWidget);
11086     QEvent event(QEvent::MacSizeChange);
11087     QApplication::sendEvent(q, &event);
11088     for (int i = 0; i < children.size(); ++i) {
11089         QWidget *w = qobject_cast<QWidget *>(children.at(i));
11090         if (w && (!w->isWindow() || w->testAttribute(Qt::WA_WindowPropagation))
11091               && !q->testAttribute(Qt::WA_MacMiniSize) // no attribute set? inherit from parent
11092               && !w->testAttribute(Qt::WA_MacSmallSize)
11093               && !w->testAttribute(Qt::WA_MacNormalSize))
11094             w->d_func()->macUpdateSizeAttribute();
11095     }
11096     resolveFont();
11097 }
11098 #endif
11099 
11100 /*!
11101     Sets the attribute \a attribute on this widget if \a on is true;
11102     otherwise clears the attribute.
11103 
11104     \sa testAttribute()
11105 */
11106 void QWidget::setAttribute(Qt::WidgetAttribute attribute, bool on)
11107 {
11108     if (testAttribute(attribute) == on)
11109         return;
11110 
11111     Q_D(QWidget);
11112     Q_STATIC_ASSERT_X(sizeof(d->high_attributes)*8 >= (Qt::WA_AttributeCount - sizeof(uint)*8),
11113                       "QWidget::setAttribute(WidgetAttribute, bool): "
11114                       "QWidgetPrivate::high_attributes[] too small to contain all attributes in WidgetAttribute");
11115 #ifdef Q_OS_WIN
11116     // ### Don't use PaintOnScreen+paintEngine() to do native painting in some future release
11117     if (attribute == Qt::WA_PaintOnScreen && on && windowType() != Qt::Desktop && !inherits("QGLWidget")) {
11118         // see ::paintEngine for details
11119         paintEngine();
11120         if (d->noPaintOnScreen)
11121             return;
11122     }
11123 #endif
11124 
11125     // Don't set WA_NativeWindow on platforms that don't support it -- except for QGLWidget, which depends on it
11126     if (attribute == Qt::WA_NativeWindow && !d->mustHaveWindowHandle) {
11127         QPlatformIntegration *platformIntegration = QGuiApplicationPrivate::platformIntegration();
11128         if (!platformIntegration->hasCapability(QPlatformIntegration::NativeWidgets))
11129             return;
11130     }
11131 
11132     setAttribute_internal(attribute, on, data, d);
11133 
11134     switch (attribute) {
11135 
11136 #ifndef QT_NO_DRAGANDDROP
11137     case Qt::WA_AcceptDrops:  {
11138         if (on && !testAttribute(Qt::WA_DropSiteRegistered))
11139             setAttribute(Qt::WA_DropSiteRegistered, true);
11140         else if (!on && (isWindow() || !parentWidget() || !parentWidget()->testAttribute(Qt::WA_DropSiteRegistered)))
11141             setAttribute(Qt::WA_DropSiteRegistered, false);
11142         QEvent e(QEvent::AcceptDropsChange);
11143         QApplication::sendEvent(this, &e);
11144         break;
11145     }
11146     case Qt::WA_DropSiteRegistered:  {
11147         d->registerDropSite(on);
11148         for (int i = 0; i < d->children.size(); ++i) {
11149             QWidget *w = qobject_cast<QWidget *>(d->children.at(i));
11150             if (w && !w->isWindow() && !w->testAttribute(Qt::WA_AcceptDrops) && w->testAttribute(Qt::WA_DropSiteRegistered) != on)
11151                 w->setAttribute(Qt::WA_DropSiteRegistered, on);
11152         }
11153         break;
11154     }
11155 #endif
11156 
11157     case Qt::WA_NoChildEventsForParent:
11158         d->sendChildEvents = !on;
11159         break;
11160     case Qt::WA_NoChildEventsFromChildren:
11161         d->receiveChildEvents = !on;
11162         break;
11163     case Qt::WA_MacBrushedMetal:
11164 #if 0 // Used to be included in Qt4 for Q_WS_MAC
11165         d->setStyle_helper(style(), false, true);  // Make sure things get unpolished/polished correctly.
11166         // fall through since changing the metal attribute affects the opaque size grip.
11167     case Qt::WA_MacOpaqueSizeGrip:
11168         d->macUpdateOpaqueSizeGrip();
11169         break;
11170     case Qt::WA_MacShowFocusRect:
11171         if (hasFocus()) {
11172             clearFocus();
11173             setFocus();
11174         }
11175         break;
11176     case Qt::WA_Hover:
11177         qt_mac_update_mouseTracking(this);
11178         break;
11179 #endif
11180     case Qt::WA_MacAlwaysShowToolWindow:
11181 #if 0 // Used to be included in Qt4 for Q_WS_MAC
11182         d->macUpdateHideOnSuspend();
11183 #endif
11184         break;
11185     case Qt::WA_MacNormalSize:
11186     case Qt::WA_MacSmallSize:
11187     case Qt::WA_MacMiniSize:
11188 #ifdef Q_OS_MAC
11189         {
11190             // We can only have one of these set at a time
11191             const Qt::WidgetAttribute MacSizes[] = { Qt::WA_MacNormalSize, Qt::WA_MacSmallSize,
11192                                                      Qt::WA_MacMiniSize };
11193             for (int i = 0; i < 3; ++i) {
11194                 if (MacSizes[i] != attribute)
11195                     setAttribute_internal(MacSizes[i], false, data, d);
11196             }
11197             d->macUpdateSizeAttribute();
11198         }
11199 #endif
11200         break;
11201     case Qt::WA_ShowModal:
11202         if (!on) {
11203             // reset modality type to NonModal when clearing WA_ShowModal
11204             data->window_modality = Qt::NonModal;
11205         } else if (data->window_modality == Qt::NonModal) {
11206             // determine the modality type if it hasn't been set prior
11207             // to setting WA_ShowModal. set the default to WindowModal
11208             // if we are the child of a group leader; otherwise use
11209             // ApplicationModal.
11210             QWidget *w = parentWidget();
11211             if (w)
11212                 w = w->window();
11213             while (w && !w->testAttribute(Qt::WA_GroupLeader)) {
11214                 w = w->parentWidget();
11215                 if (w)
11216                     w = w->window();
11217             }
11218             data->window_modality = (w && w->testAttribute(Qt::WA_GroupLeader))
11219                                     ? Qt::WindowModal
11220                                     : Qt::ApplicationModal;
11221             // Some window managers do not allow us to enter modality after the
11222             // window is visible.The window must be hidden before changing the
11223             // windowModality property and then reshown.
11224         }
11225         if (testAttribute(Qt::WA_WState_Created)) {
11226             // don't call setModal_sys() before create_sys()
11227             d->setModal_sys();
11228         }
11229         break;
11230     case Qt::WA_MouseTracking: {
11231         QEvent e(QEvent::MouseTrackingChange);
11232         QApplication::sendEvent(this, &e);
11233         break; }
11234     case Qt::WA_TabletTracking: {
11235         QEvent e(QEvent::TabletTrackingChange);
11236         QApplication::sendEvent(this, &e);
11237         break; }
11238     case Qt::WA_NativeWindow: {
11239         d->createTLExtra();
11240         if (on)
11241             d->createTLSysExtra();
11242 #ifndef QT_NO_IM
11243         QWidget *focusWidget = d->effectiveFocusWidget();
11244         if (on && !internalWinId() && this == QGuiApplication::focusObject()
11245             && focusWidget->testAttribute(Qt::WA_InputMethodEnabled)) {
11246             QGuiApplication::inputMethod()->commit();
11247             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
11248         }
11249         if (!qApp->testAttribute(Qt::AA_DontCreateNativeWidgetSiblings) && parentWidget())
11250             parentWidget()->d_func()->enforceNativeChildren();
11251         if (on && !internalWinId() && testAttribute(Qt::WA_WState_Created))
11252             d->createWinId();
11253         if (isEnabled() && focusWidget->isEnabled() && this == QGuiApplication::focusObject()
11254             && focusWidget->testAttribute(Qt::WA_InputMethodEnabled)) {
11255             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
11256         }
11257 #endif //QT_NO_IM
11258         break;
11259     }
11260     case Qt::WA_PaintOnScreen:
11261         d->updateIsOpaque();
11262 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_X11 */ || 0 /* Used to be included in Qt4 for Q_WS_MAC */
11263         // Recreate the widget if it's already created as an alien widget and
11264         // WA_PaintOnScreen is enabled. Paint on screen widgets must have win id.
11265         // So must their children.
11266         if (on) {
11267             setAttribute(Qt::WA_NativeWindow);
11268             d->enforceNativeChildren();
11269         }
11270 #endif
11271         Q_FALLTHROUGH();
11272     case Qt::WA_OpaquePaintEvent:
11273         d->updateIsOpaque();
11274         break;
11275     case Qt::WA_NoSystemBackground:
11276         d->updateIsOpaque();
11277         Q_FALLTHROUGH();
11278     case Qt::WA_UpdatesDisabled:
11279         d->updateSystemBackground();
11280         break;
11281     case Qt::WA_TransparentForMouseEvents:
11282 #if 0 // Used to be included in Qt4 for Q_WS_MAC
11283         d->macUpdateIgnoreMouseEvents();
11284 #endif
11285         break;
11286     case Qt::WA_InputMethodEnabled: {
11287 #ifndef QT_NO_IM
11288         if (QGuiApplication::focusObject() == this) {
11289             if (!on)
11290                 QGuiApplication::inputMethod()->commit();
11291             QGuiApplication::inputMethod()->update(Qt::ImEnabled);
11292         }
11293 #endif //QT_NO_IM
11294         break;
11295     }
11296     case Qt::WA_WindowPropagation:
11297         d->resolvePalette();
11298         d->resolveFont();
11299         d->resolveLocale();
11300         break;
11301 #if 0 // Used to be included in Qt4 for Q_WS_X11
11302     case Qt::WA_NoX11EventCompression:
11303         if (!d->extra)
11304             d->createExtra();
11305         d->extra->compress_events = on;
11306         break;
11307     case Qt::WA_X11OpenGLOverlay:
11308         d->updateIsOpaque();
11309         break;
11310     case Qt::WA_X11DoNotAcceptFocus:
11311         if (testAttribute(Qt::WA_WState_Created))
11312             d->updateX11AcceptFocus();
11313         break;
11314 #endif
11315     case Qt::WA_DontShowOnScreen: {
11316         if (on && isVisible()) {
11317             // Make sure we keep the current state and only hide the widget
11318             // from the desktop. show_sys will only update platform specific
11319             // attributes at this point.
11320             d->hide_sys();
11321             d->show_sys();
11322         }
11323         break;
11324     }
11325 
11326     case Qt::WA_X11NetWmWindowTypeDesktop:
11327     case Qt::WA_X11NetWmWindowTypeDock:
11328     case Qt::WA_X11NetWmWindowTypeToolBar:
11329     case Qt::WA_X11NetWmWindowTypeMenu:
11330     case Qt::WA_X11NetWmWindowTypeUtility:
11331     case Qt::WA_X11NetWmWindowTypeSplash:
11332     case Qt::WA_X11NetWmWindowTypeDialog:
11333     case Qt::WA_X11NetWmWindowTypeDropDownMenu:
11334     case Qt::WA_X11NetWmWindowTypePopupMenu:
11335     case Qt::WA_X11NetWmWindowTypeToolTip:
11336     case Qt::WA_X11NetWmWindowTypeNotification:
11337     case Qt::WA_X11NetWmWindowTypeCombo:
11338     case Qt::WA_X11NetWmWindowTypeDND:
11339         d->setNetWmWindowTypes();
11340         break;
11341 
11342     case Qt::WA_StaticContents:
11343         if (QWidgetBackingStore *bs = d->maybeBackingStore()) {
11344             if (on)
11345                 bs->addStaticWidget(this);
11346             else
11347                 bs->removeStaticWidget(this);
11348         }
11349         break;
11350     case Qt::WA_TranslucentBackground:
11351         if (on) {
11352             setAttribute(Qt::WA_NoSystemBackground);
11353             d->updateIsTranslucent();
11354         }
11355 
11356         break;
11357     case Qt::WA_AcceptTouchEvents:
11358 #if 0 /* Used to be included in Qt4 for Q_WS_WIN */ || 0 /* Used to be included in Qt4 for Q_WS_MAC */
11359         if (on)
11360             d->registerTouchWindow();
11361 #endif
11362         break;
11363     default:
11364         break;
11365     }
11366 }
11367 
11368 /*! \fn bool QWidget::testAttribute(Qt::WidgetAttribute attribute) const
11369 
11370   Returns \c true if attribute \a attribute is set on this widget;
11371   otherwise returns \c false.
11372 
11373   \sa setAttribute()
11374  */
11375 bool QWidget::testAttribute_helper(Qt::WidgetAttribute attribute) const
11376 {
11377     Q_D(const QWidget);
11378     const int x = attribute - 8*sizeof(uint);
11379     const int int_off = x / (8*sizeof(uint));
11380     return (d->high_attributes[int_off] & (1<<(x-(int_off*8*sizeof(uint)))));
11381 }
11382 
11383 /*!
11384   \property QWidget::windowOpacity
11385 
11386   \brief The level of opacity for the window.
11387 
11388   The valid range of opacity is from 1.0 (completely opaque) to
11389   0.0 (completely transparent).
11390 
11391   By default the value of this property is 1.0.
11392 
11393   This feature is available on Embedded Linux, \macos, Windows,
11394   and X11 platforms that support the Composite extension.
11395 
11396   \note On X11 you need to have a composite manager running,
11397   and the X11 specific _NET_WM_WINDOW_OPACITY atom needs to be
11398   supported by the window manager you are using.
11399 
11400   \warning Changing this property from opaque to transparent might issue a
11401   paint event that needs to be processed before the window is displayed
11402   correctly. This affects mainly the use of QPixmap::grabWindow(). Also note
11403   that semi-transparent windows update and resize significantly slower than
11404   opaque windows.
11405 
11406   \sa setMask()
11407 */
11408 qreal QWidget::windowOpacity() const
11409 {
11410     Q_D(const QWidget);
11411     return (isWindow() && d->maybeTopData()) ? d->maybeTopData()->opacity / 255. : 1.0;
11412 }
11413 
11414 void QWidget::setWindowOpacity(qreal opacity)
11415 {
11416     Q_D(QWidget);
11417     if (!isWindow())
11418         return;
11419 
11420     opacity = qBound(qreal(0.0), opacity, qreal(1.0));
11421     QTLWExtra *extra = d->topData();
11422     extra->opacity = uint(opacity * 255);
11423     setAttribute(Qt::WA_WState_WindowOpacitySet);
11424     d->setWindowOpacity_sys(opacity);
11425 
11426     if (!testAttribute(Qt::WA_WState_Created))
11427         return;
11428 
11429 #if QT_CONFIG(graphicsview)
11430     if (QGraphicsProxyWidget *proxy = graphicsProxyWidget()) {
11431         // Avoid invalidating the cache if set.
11432         if (proxy->cacheMode() == QGraphicsItem::NoCache)
11433             proxy->update();
11434         else if (QGraphicsScene *scene = proxy->scene())
11435             scene->update(proxy->sceneBoundingRect());
11436         return;
11437     }
11438 #endif
11439 }
11440 
11441 void QWidgetPrivate::setWindowOpacity_sys(qreal level)
11442 {
11443     Q_Q(QWidget);
11444     if (q->windowHandle())
11445         q->windowHandle()->setOpacity(level);
11446 }
11447 
11448 /*!
11449     \property QWidget::windowModified
11450     \brief whether the document shown in the window has unsaved changes
11451 
11452     A modified window is a window whose content has changed but has
11453     not been saved to disk. This flag will have different effects
11454     varied by the platform. On \macos the close button will have a
11455     modified look; on other platforms, the window title will have an
11456     '*' (asterisk).
11457 
11458     The window title must contain a "[*]" placeholder, which
11459     indicates where the '*' should appear. Normally, it should appear
11460     right after the file name (e.g., "document1.txt[*] - Text
11461     Editor"). If the window isn't modified, the placeholder is simply
11462     removed.
11463 
11464     Note that if a widget is set as modified, all its ancestors will
11465     also be set as modified. However, if you call \c
11466     {setWindowModified(false)} on a widget, this will not propagate to
11467     its parent because other children of the parent might have been
11468     modified.
11469 
11470     \sa windowTitle, {Application Example}, {SDI Example}, {MDI Example}
11471 */
11472 bool QWidget::isWindowModified() const
11473 {
11474     return testAttribute(Qt::WA_WindowModified);
11475 }
11476 
11477 void QWidget::setWindowModified(bool mod)
11478 {
11479     Q_D(QWidget);
11480     setAttribute(Qt::WA_WindowModified, mod);
11481 
11482     d->setWindowModified_helper();
11483 
11484     QEvent e(QEvent::ModifiedChange);
11485     QApplication::sendEvent(this, &e);
11486 }
11487 
11488 void QWidgetPrivate::setWindowModified_helper()
11489 {
11490     Q_Q(QWidget);
11491     QWindow *window = q->windowHandle();
11492     if (!window)
11493         return;
11494     QPlatformWindow *platformWindow = window->handle();
11495     if (!platformWindow)
11496         return;
11497     bool on = q->testAttribute(Qt::WA_WindowModified);
11498     if (!platformWindow->setWindowModified(on)) {
11499         if (Q_UNLIKELY(on && !q->windowTitle().contains(QLatin1String("[*]"))))
11500             qWarning("QWidget::setWindowModified: The window title does not contain a '[*]' placeholder");
11501         setWindowTitle_helper(q->windowTitle());
11502         setWindowIconText_helper(q->windowIconText());
11503     }
11504 }
11505 
11506 #ifndef QT_NO_TOOLTIP
11507 /*!
11508   \property QWidget::toolTip
11509 
11510   \brief the widget's tooltip
11511 
11512   Note that by default tooltips are only shown for widgets that are
11513   children of the active window. You can change this behavior by
11514   setting the attribute Qt::WA_AlwaysShowToolTips on the \e window,
11515   not on the widget with the tooltip.
11516 
11517   If you want to control a tooltip's behavior, you can intercept the
11518   event() function and catch the QEvent::ToolTip event (e.g., if you
11519   want to customize the area for which the tooltip should be shown).
11520 
11521   By default, this property contains an empty string.
11522 
11523   \sa QToolTip, statusTip, whatsThis
11524 */
11525 void QWidget::setToolTip(const QString &s)
11526 {
11527     Q_D(QWidget);
11528     d->toolTip = s;
11529 
11530     QEvent event(QEvent::ToolTipChange);
11531     QApplication::sendEvent(this, &event);
11532 }
11533 
11534 QString QWidget::toolTip() const
11535 {
11536     Q_D(const QWidget);
11537     return d->toolTip;
11538 }
11539 
11540 /*!
11541   \property QWidget::toolTipDuration
11542   \brief the widget's tooltip duration
11543   \since 5.2
11544 
11545   Specifies how long time the tooltip will be displayed, in milliseconds.
11546   If the value is -1 (default) the duration is calculated depending on the length of the tooltip.
11547 
11548   \sa toolTip
11549 */
11550 
11551 void QWidget::setToolTipDuration(int msec)
11552 {
11553     Q_D(QWidget);
11554     d->toolTipDuration = msec;
11555 }
11556 
11557 int QWidget::toolTipDuration() const
11558 {
11559     Q_D(const QWidget);
11560     return d->toolTipDuration;
11561 }
11562 
11563 #endif // QT_NO_TOOLTIP
11564 
11565 
11566 #if QT_CONFIG(statustip)
11567 /*!
11568   \property QWidget::statusTip
11569   \brief the widget's status tip
11570 
11571   By default, this property contains an empty string.
11572 
11573   \sa toolTip, whatsThis
11574 */
11575 void QWidget::setStatusTip(const QString &s)
11576 {
11577     Q_D(QWidget);
11578     d->statusTip = s;
11579 }
11580 
11581 QString QWidget::statusTip() const
11582 {
11583     Q_D(const QWidget);
11584     return d->statusTip;
11585 }
11586 #endif // QT_CONFIG(statustip)
11587 
11588 #if QT_CONFIG(whatsthis)
11589 /*!
11590   \property QWidget::whatsThis
11591 
11592   \brief the widget's What's This help text.
11593 
11594   By default, this property contains an empty string.
11595 
11596   \sa QWhatsThis, QWidget::toolTip, QWidget::statusTip
11597 */
11598 void QWidget::setWhatsThis(const QString &s)
11599 {
11600     Q_D(QWidget);
11601     d->whatsThis = s;
11602 }
11603 
11604 QString QWidget::whatsThis() const
11605 {
11606     Q_D(const QWidget);
11607     return d->whatsThis;
11608 }
11609 #endif // QT_CONFIG(whatsthis)
11610 
11611 #ifndef QT_NO_ACCESSIBILITY
11612 /*!
11613   \property QWidget::accessibleName
11614 
11615   \brief the widget's name as seen by assistive technologies
11616 
11617   This is the primary name by which assistive technology such as screen readers
11618   announce this widget. For most widgets setting this property is not required.
11619   For example for QPushButton the button's text will be used.
11620 
11621   It is important to set this property when the widget does not provide any
11622   text. For example a button that only contains an icon needs to set this
11623   property to work with screen readers.
11624   The name should be short and equivalent to the visual information conveyed
11625   by the widget.
11626 
11627   This property has to be \l{Internationalization with Qt}{localized}.
11628 
11629   By default, this property contains an empty string.
11630 
11631   \sa QWidget::accessibleDescription, QAccessibleInterface::text()
11632 */
11633 void QWidget::setAccessibleName(const QString &name)
11634 {
11635     Q_D(QWidget);
11636     d->accessibleName = name;
11637     QAccessibleEvent event(this, QAccessible::NameChanged);
11638     QAccessible::updateAccessibility(&event);
11639 }
11640 
11641 QString QWidget::accessibleName() const
11642 {
11643     Q_D(const QWidget);
11644     return d->accessibleName;
11645 }
11646 
11647 /*!
11648   \property QWidget::accessibleDescription
11649 
11650   \brief the widget's description as seen by assistive technologies
11651 
11652   The accessible description of a widget should convey what a widget does.
11653   While the \l accessibleName should be a short and consise string (e.g. \gui{Save}),
11654   the description should give more context, such as \gui{Saves the current document}.
11655 
11656   This property has to be \l{Internationalization with Qt}{localized}.
11657 
11658   By default, this property contains an empty string and Qt falls back
11659   to using the tool tip to provide this information.
11660 
11661   \sa QWidget::accessibleName, QAccessibleInterface::text()
11662 */
11663 void QWidget::setAccessibleDescription(const QString &description)
11664 {
11665     Q_D(QWidget);
11666     d->accessibleDescription = description;
11667     QAccessibleEvent event(this, QAccessible::DescriptionChanged);
11668     QAccessible::updateAccessibility(&event);
11669 }
11670 
11671 QString QWidget::accessibleDescription() const
11672 {
11673     Q_D(const QWidget);
11674     return d->accessibleDescription;
11675 }
11676 #endif // QT_NO_ACCESSIBILITY
11677 
11678 #ifndef QT_NO_SHORTCUT
11679 /*!
11680     Adds a shortcut to Qt's shortcut system that watches for the given
11681     \a key sequence in the given \a context. If the \a context is
11682     Qt::ApplicationShortcut, the shortcut applies to the application as a
11683     whole. Otherwise, it is either local to this widget, Qt::WidgetShortcut,
11684     or to the window itself, Qt::WindowShortcut.
11685 
11686     If the same \a key sequence has been grabbed by several widgets,
11687     when the \a key sequence occurs a QEvent::Shortcut event is sent
11688     to all the widgets to which it applies in a non-deterministic
11689     order, but with the ``ambiguous'' flag set to true.
11690 
11691     \warning You should not normally need to use this function;
11692     instead create \l{QAction}s with the shortcut key sequences you
11693     require (if you also want equivalent menu options and toolbar
11694     buttons), or create \l{QShortcut}s if you just need key sequences.
11695     Both QAction and QShortcut handle all the event filtering for you,
11696     and provide signals which are triggered when the user triggers the
11697     key sequence, so are much easier to use than this low-level
11698     function.
11699 
11700     \sa releaseShortcut(), setShortcutEnabled()
11701 */
11702 int QWidget::grabShortcut(const QKeySequence &key, Qt::ShortcutContext context)
11703 {
11704     Q_ASSERT(qApp);
11705     if (key.isEmpty())
11706         return 0;
11707     setAttribute(Qt::WA_GrabbedShortcut);
11708     return qApp->d_func()->shortcutMap.addShortcut(this, key, context, qWidgetShortcutContextMatcher);
11709 }
11710 
11711 /*!
11712     Removes the shortcut with the given \a id from Qt's shortcut
11713     system. The widget will no longer receive QEvent::Shortcut events
11714     for the shortcut's key sequence (unless it has other shortcuts
11715     with the same key sequence).
11716 
11717     \warning You should not normally need to use this function since
11718     Qt's shortcut system removes shortcuts automatically when their
11719     parent widget is destroyed. It is best to use QAction or
11720     QShortcut to handle shortcuts, since they are easier to use than
11721     this low-level function. Note also that this is an expensive
11722     operation.
11723 
11724     \sa grabShortcut(), setShortcutEnabled()
11725 */
11726 void QWidget::releaseShortcut(int id)
11727 {
11728     Q_ASSERT(qApp);
11729     if (id)
11730         qApp->d_func()->shortcutMap.removeShortcut(id, this, 0);
11731 }
11732 
11733 /*!
11734     If \a enable is true, the shortcut with the given \a id is
11735     enabled; otherwise the shortcut is disabled.
11736 
11737     \warning You should not normally need to use this function since
11738     Qt's shortcut system enables/disables shortcuts automatically as
11739     widgets become hidden/visible and gain or lose focus. It is best
11740     to use QAction or QShortcut to handle shortcuts, since they are
11741     easier to use than this low-level function.
11742 
11743     \sa grabShortcut(), releaseShortcut()
11744 */
11745 void QWidget::setShortcutEnabled(int id, bool enable)
11746 {
11747     Q_ASSERT(qApp);
11748     if (id)
11749         qApp->d_func()->shortcutMap.setShortcutEnabled(enable, id, this, 0);
11750 }
11751 
11752 /*!
11753     \since 4.2
11754 
11755     If \a enable is true, auto repeat of the shortcut with the
11756     given \a id is enabled; otherwise it is disabled.
11757 
11758     \sa grabShortcut(), releaseShortcut()
11759 */
11760 void QWidget::setShortcutAutoRepeat(int id, bool enable)
11761 {
11762     Q_ASSERT(qApp);
11763     if (id)
11764         qApp->d_func()->shortcutMap.setShortcutAutoRepeat(enable, id, this, 0);
11765 }
11766 #endif // QT_NO_SHORTCUT
11767 
11768 /*!
11769     Updates the widget's micro focus.
11770 */
11771 void QWidget::updateMicroFocus()
11772 {
11773     // updating everything since this is currently called for any kind of state change
11774     if (this == QGuiApplication::focusObject())
11775         QGuiApplication::inputMethod()->update(Qt::ImQueryAll);
11776 }
11777 
11778 /*!
11779     Raises this widget to the top of the parent widget's stack.
11780 
11781     After this call the widget will be visually in front of any
11782     overlapping sibling widgets.
11783 
11784     \note When using activateWindow(), you can call this function to
11785     ensure that the window is stacked on top.
11786 
11787     \sa lower(), stackUnder()
11788 */
11789 
11790 void QWidget::raise()
11791 {
11792     Q_D(QWidget);
11793     if (!isWindow()) {
11794         QWidget *p = parentWidget();
11795         const int parentChildCount = p->d_func()->children.size();
11796         if (parentChildCount < 2)
11797             return;
11798         const int from = p->d_func()->children.indexOf(this);
11799         Q_ASSERT(from >= 0);
11800         // Do nothing if the widget is already in correct stacking order _and_ created.
11801         if (from != parentChildCount -1)
11802             p->d_func()->children.move(from, parentChildCount - 1);
11803         if (!testAttribute(Qt::WA_WState_Created) && p->testAttribute(Qt::WA_WState_Created))
11804             create();
11805         else if (from == parentChildCount - 1)
11806             return;
11807 
11808         QRegion region(rect());
11809         d->subtractOpaqueSiblings(region);
11810         d->invalidateBuffer(region);
11811     }
11812     if (testAttribute(Qt::WA_WState_Created))
11813         d->raise_sys();
11814 
11815     if (d->extra && d->extra->hasWindowContainer)
11816         QWindowContainer::parentWasRaised(this);
11817 
11818     QEvent e(QEvent::ZOrderChange);
11819     QApplication::sendEvent(this, &e);
11820 }
11821 
11822 void QWidgetPrivate::raise_sys()
11823 {
11824     Q_Q(QWidget);
11825     if (q->isWindow() || q->testAttribute(Qt::WA_NativeWindow)) {
11826         q->windowHandle()->raise();
11827     } else if (renderToTexture) {
11828         if (QWidget *p = q->parentWidget()) {
11829             setDirtyOpaqueRegion();
11830             p->d_func()->invalidateBuffer(effectiveRectFor(q->geometry()));
11831         }
11832     }
11833 }
11834 
11835 /*!
11836     Lowers the widget to the bottom of the parent widget's stack.
11837 
11838     After this call the widget will be visually behind (and therefore
11839     obscured by) any overlapping sibling widgets.
11840 
11841     \sa raise(), stackUnder()
11842 */
11843 
11844 void QWidget::lower()
11845 {
11846     Q_D(QWidget);
11847     if (!isWindow()) {
11848         QWidget *p = parentWidget();
11849         const int parentChildCount = p->d_func()->children.size();
11850         if (parentChildCount < 2)
11851             return;
11852         const int from = p->d_func()->children.indexOf(this);
11853         Q_ASSERT(from >= 0);
11854         // Do nothing if the widget is already in correct stacking order _and_ created.
11855         if (from != 0)
11856             p->d_func()->children.move(from, 0);
11857         if (!testAttribute(Qt::WA_WState_Created) && p->testAttribute(Qt::WA_WState_Created))
11858             create();
11859         else if (from == 0)
11860             return;
11861     }
11862     if (testAttribute(Qt::WA_WState_Created))
11863         d->lower_sys();
11864 
11865     if (d->extra && d->extra->hasWindowContainer)
11866         QWindowContainer::parentWasLowered(this);
11867 
11868     QEvent e(QEvent::ZOrderChange);
11869     QApplication::sendEvent(this, &e);
11870 }
11871 
11872 void QWidgetPrivate::lower_sys()
11873 {
11874     Q_Q(QWidget);
11875     if (q->isWindow() || q->testAttribute(Qt::WA_NativeWindow)) {
11876         Q_ASSERT(q->testAttribute(Qt::WA_WState_Created));
11877         q->windowHandle()->lower();
11878     } else if (QWidget *p = q->parentWidget()) {
11879         setDirtyOpaqueRegion();
11880         p->d_func()->invalidateBuffer(effectiveRectFor(q->geometry()));
11881     }
11882 }
11883 
11884 /*!
11885     Places the widget under \a w in the parent widget's stack.
11886 
11887     To make this work, the widget itself and \a w must be siblings.
11888 
11889     \sa raise(), lower()
11890 */
11891 void QWidget::stackUnder(QWidget* w)
11892 {
11893     Q_D(QWidget);
11894     QWidget *p = parentWidget();
11895     if (!w || isWindow() || p != w->parentWidget() || this == w)
11896         return;
11897     if (p) {
11898         int from = p->d_func()->children.indexOf(this);
11899         int to = p->d_func()->children.indexOf(w);
11900         Q_ASSERT(from >= 0);
11901         Q_ASSERT(to >= 0);
11902         if (from < to)
11903             --to;
11904         // Do nothing if the widget is already in correct stacking order _and_ created.
11905         if (from != to)
11906             p->d_func()->children.move(from, to);
11907         if (!testAttribute(Qt::WA_WState_Created) && p->testAttribute(Qt::WA_WState_Created))
11908             create();
11909         else if (from == to)
11910             return;
11911     }
11912     if (testAttribute(Qt::WA_WState_Created))
11913         d->stackUnder_sys(w);
11914 
11915     QEvent e(QEvent::ZOrderChange);
11916     QApplication::sendEvent(this, &e);
11917 }
11918 
11919 void QWidgetPrivate::stackUnder_sys(QWidget*)
11920 {
11921     Q_Q(QWidget);
11922     if (QWidget *p = q->parentWidget()) {
11923         setDirtyOpaqueRegion();
11924         p->d_func()->invalidateBuffer(effectiveRectFor(q->geometry()));
11925     }
11926 }
11927 
11928 /*!
11929     \fn bool QWidget::isTopLevel() const
11930     \obsolete
11931 
11932     Use isWindow() instead.
11933 */
11934 
11935 /*!
11936     \fn bool QWidget::isRightToLeft() const
11937     \internal
11938 */
11939 
11940 /*!
11941     \fn bool QWidget::isLeftToRight() const
11942     \internal
11943 */
11944 
11945 /*!
11946      \macro QWIDGETSIZE_MAX
11947      \relates QWidget
11948 
11949      Defines the maximum size for a QWidget object.
11950 
11951      The largest allowed size for a widget is QSize(QWIDGETSIZE_MAX,
11952      QWIDGETSIZE_MAX), i.e. QSize (16777215,16777215).
11953 
11954      \sa QWidget::setMaximumSize()
11955 */
11956 
11957 /*!
11958     \fn QWidget::setupUi(QWidget *widget)
11959 
11960     Sets up the user interface for the specified \a widget.
11961 
11962     \note This function is available with widgets that derive from user
11963     interface descriptions created using \l{uic}.
11964 
11965     \sa {Using a Designer UI File in Your Application}
11966 */
11967 
11968 QRect QWidgetPrivate::frameStrut() const
11969 {
11970     Q_Q(const QWidget);
11971     if (!q->isWindow() || (q->windowType() == Qt::Desktop) || q->testAttribute(Qt::WA_DontShowOnScreen)) {
11972         // x2 = x1 + w - 1, so w/h = 1
11973         return QRect(0, 0, 1, 1);
11974     }
11975 
11976     if (data.fstrut_dirty
11977 #if 1 // Used to be excluded in Qt4 for Q_WS_WIN
11978         // ### Fix properly for 4.3
11979         && q->isVisible()
11980 #endif
11981         && q->testAttribute(Qt::WA_WState_Created))
11982         const_cast<QWidgetPrivate *>(this)->updateFrameStrut();
11983 
11984     return maybeTopData() ? maybeTopData()->frameStrut : QRect();
11985 }
11986 
11987 void QWidgetPrivate::updateFrameStrut()
11988 {
11989     Q_Q(QWidget);
11990     if (q->data->fstrut_dirty) {
11991         if (QTLWExtra *te = maybeTopData()) {
11992             if (te->window && te->window->handle()) {
11993                 const QMargins margins = te->window->frameMargins();
11994                 if (!margins.isNull()) {
11995                     te->frameStrut.setCoords(margins.left(), margins.top(), margins.right(), margins.bottom());
11996                     q->data->fstrut_dirty = false;
11997                 }
11998             }
11999         }
12000     }
12001 }
12002 
12003 #ifdef QT_KEYPAD_NAVIGATION
12004 /*!
12005     \internal
12006 
12007     Changes the focus  from the current focusWidget to a widget in
12008     the \a direction.
12009 
12010     Returns \c true, if there was a widget in that direction
12011 */
12012 bool QWidgetPrivate::navigateToDirection(Direction direction)
12013 {
12014     QWidget *targetWidget = widgetInNavigationDirection(direction);
12015     if (targetWidget)
12016         targetWidget->setFocus();
12017     return (targetWidget != 0);
12018 }
12019 
12020 /*!
12021     \internal
12022 
12023     Searches for a widget that is positioned in the \a direction, starting
12024     from the current focusWidget.
12025 
12026     Returns the pointer to a found widget or 0, if there was no widget in
12027     that direction.
12028 */
12029 QWidget *QWidgetPrivate::widgetInNavigationDirection(Direction direction)
12030 {
12031     const QWidget *sourceWidget = QApplication::focusWidget();
12032     if (!sourceWidget)
12033         return 0;
12034     const QRect sourceRect = sourceWidget->rect().translated(sourceWidget->mapToGlobal(QPoint()));
12035     const int sourceX =
12036             (direction == DirectionNorth || direction == DirectionSouth) ?
12037                 (sourceRect.left() + (sourceRect.right() - sourceRect.left()) / 2)
12038                 :(direction == DirectionEast ? sourceRect.right() : sourceRect.left());
12039     const int sourceY =
12040             (direction == DirectionEast || direction == DirectionWest) ?
12041                 (sourceRect.top() + (sourceRect.bottom() - sourceRect.top()) / 2)
12042                 :(direction == DirectionSouth ? sourceRect.bottom() : sourceRect.top());
12043     const QPoint sourcePoint(sourceX, sourceY);
12044     const QPoint sourceCenter = sourceRect.center();
12045     const QWidget *sourceWindow = sourceWidget->window();
12046 
12047     QWidget *targetWidget = 0;
12048     int shortestDistance = INT_MAX;
12049 
12050     const auto targetCandidates = QApplication::allWidgets();
12051     for (QWidget *targetCandidate : targetCandidates) {
12052 
12053         const QRect targetCandidateRect = targetCandidate->rect().translated(targetCandidate->mapToGlobal(QPoint()));
12054 
12055         // For focus proxies, the child widget handling the focus can have keypad navigation focus,
12056         // but the owner of the proxy cannot.
12057         // Additionally, empty widgets should be ignored.
12058         if (targetCandidate->focusProxy() || targetCandidateRect.isEmpty())
12059             continue;
12060 
12061         // Only navigate to a target widget that...
12062         if (       targetCandidate != sourceWidget
12063                    // ...takes the focus,
12064                 && targetCandidate->focusPolicy() & Qt::TabFocus
12065                    // ...is above if DirectionNorth,
12066                 && !(direction == DirectionNorth && targetCandidateRect.bottom() > sourceRect.top())
12067                    // ...is on the right if DirectionEast,
12068                 && !(direction == DirectionEast  && targetCandidateRect.left()   < sourceRect.right())
12069                    // ...is below if DirectionSouth,
12070                 && !(direction == DirectionSouth && targetCandidateRect.top()    < sourceRect.bottom())
12071                    // ...is on the left if DirectionWest,
12072                 && !(direction == DirectionWest  && targetCandidateRect.right()  > sourceRect.left())
12073                    // ...is enabled,
12074                 && targetCandidate->isEnabled()
12075                    // ...is visible,
12076                 && targetCandidate->isVisible()
12077                    // ...is in the same window,
12078                 && targetCandidate->window() == sourceWindow) {
12079             const int targetCandidateDistance = pointToRect(sourcePoint, targetCandidateRect);
12080             if (targetCandidateDistance < shortestDistance) {
12081                 shortestDistance = targetCandidateDistance;
12082                 targetWidget = targetCandidate;
12083             }
12084         }
12085     }
12086     return targetWidget;
12087 }
12088 
12089 /*!
12090     \internal
12091 
12092     Tells us if it there is currently a reachable widget by keypad navigation in
12093     a certain \a orientation.
12094     If no navigation is possible, occurring key events in that \a orientation may
12095     be used to interact with the value in the focused widget, even though it
12096     currently has not the editFocus.
12097 
12098     \sa QWidgetPrivate::widgetInNavigationDirection(), QWidget::hasEditFocus()
12099 */
12100 bool QWidgetPrivate::canKeypadNavigate(Qt::Orientation orientation)
12101 {
12102     return orientation == Qt::Horizontal?
12103             (QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionEast)
12104                     || QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionWest))
12105             :(QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionNorth)
12106                     || QWidgetPrivate::widgetInNavigationDirection(QWidgetPrivate::DirectionSouth));
12107 }
12108 /*!
12109     \internal
12110 
12111     Checks, if the \a widget is inside a QTabWidget. If is is inside
12112     one, left/right key events will be used to switch between tabs in keypad
12113     navigation. If there is no QTabWidget, the horizontal key events can be used
12114 to
12115     interact with the value in the focused widget, even though it currently has
12116     not the editFocus.
12117 
12118     \sa QWidget::hasEditFocus()
12119 */
12120 bool QWidgetPrivate::inTabWidget(QWidget *widget)
12121 {
12122     for (QWidget *tabWidget = widget; tabWidget; tabWidget = tabWidget->parentWidget())
12123         if (qobject_cast<const QTabWidget*>(tabWidget))
12124             return true;
12125     return false;
12126 }
12127 #endif
12128 
12129 /*!
12130     \since 5.0
12131     \internal
12132 
12133     Sets the backing store to be the \a store specified.
12134     The QWidget will take ownership of the \a store.
12135 */
12136 void QWidget::setBackingStore(QBackingStore *store)
12137 {
12138     // ### createWinId() ??
12139 
12140     if (!isTopLevel())
12141         return;
12142 
12143     Q_D(QWidget);
12144 
12145     QTLWExtra *topData = d->topData();
12146     if (topData->backingStore == store)
12147         return;
12148 
12149     QBackingStore *oldStore = topData->backingStore;
12150     deleteBackingStore(d);
12151     topData->backingStore = store;
12152 
12153     QWidgetBackingStore *bs = d->maybeBackingStore();
12154     if (!bs)
12155         return;
12156 
12157     if (isTopLevel()) {
12158         if (bs->store != oldStore && bs->store != store)
12159             delete bs->store;
12160         bs->store = store;
12161     }
12162 }
12163 
12164 /*!
12165     \since 5.0
12166 
12167     Returns the QBackingStore this widget will be drawn into.
12168 */
12169 QBackingStore *QWidget::backingStore() const
12170 {
12171     Q_D(const QWidget);
12172     QTLWExtra *extra = d->maybeTopData();
12173     if (extra && extra->backingStore)
12174         return extra->backingStore;
12175 
12176     QWidgetBackingStore *bs = d->maybeBackingStore();
12177 
12178     return bs ? bs->store : 0;
12179 }
12180 
12181 void QWidgetPrivate::getLayoutItemMargins(int *left, int *top, int *right, int *bottom) const
12182 {
12183     if (left)
12184         *left = (int)leftLayoutItemMargin;
12185     if (top)
12186         *top = (int)topLayoutItemMargin;
12187     if (right)
12188         *right = (int)rightLayoutItemMargin;
12189     if (bottom)
12190         *bottom = (int)bottomLayoutItemMargin;
12191 }
12192 
12193 void QWidgetPrivate::setLayoutItemMargins(int left, int top, int right, int bottom)
12194 {
12195     if (leftLayoutItemMargin == left
12196         && topLayoutItemMargin == top
12197         && rightLayoutItemMargin == right
12198         && bottomLayoutItemMargin == bottom)
12199         return;
12200 
12201     Q_Q(QWidget);
12202     leftLayoutItemMargin = (signed char)left;
12203     topLayoutItemMargin = (signed char)top;
12204     rightLayoutItemMargin = (signed char)right;
12205     bottomLayoutItemMargin = (signed char)bottom;
12206     q->updateGeometry();
12207 }
12208 
12209 void QWidgetPrivate::setLayoutItemMargins(QStyle::SubElement element, const QStyleOption *opt)
12210 {
12211     Q_Q(QWidget);
12212     QStyleOption myOpt;
12213     if (!opt) {
12214         myOpt.initFrom(q);
12215         myOpt.rect.setRect(0, 0, 32768, 32768);     // arbitrary
12216         opt = &myOpt;
12217     }
12218 
12219     QRect liRect = q->style()->subElementRect(element, opt, q);
12220     if (liRect.isValid()) {
12221         leftLayoutItemMargin = (signed char)(opt->rect.left() - liRect.left());
12222         topLayoutItemMargin = (signed char)(opt->rect.top() - liRect.top());
12223         rightLayoutItemMargin = (signed char)(liRect.right() - opt->rect.right());
12224         bottomLayoutItemMargin = (signed char)(liRect.bottom() - opt->rect.bottom());
12225     } else {
12226         leftLayoutItemMargin = 0;
12227         topLayoutItemMargin = 0;
12228         rightLayoutItemMargin = 0;
12229         bottomLayoutItemMargin = 0;
12230     }
12231 }
12232 // resets the Qt::WA_QuitOnClose attribute to the default value for transient widgets.
12233 void QWidgetPrivate::adjustQuitOnCloseAttribute()
12234 {
12235     Q_Q(QWidget);
12236 
12237     if (!q->parentWidget()) {
12238         Qt::WindowType type = q->windowType();
12239         if (type == Qt::Widget || type == Qt::SubWindow)
12240             type = Qt::Window;
12241         if (type != Qt::Widget && type != Qt::Window && type != Qt::Dialog)
12242             q->setAttribute(Qt::WA_QuitOnClose, false);
12243     }
12244 }
12245 
12246 QOpenGLContext *QWidgetPrivate::shareContext() const
12247 {
12248 #ifdef QT_NO_OPENGL
12249     return 0;
12250 #else
12251     if (Q_UNLIKELY(!extra || !extra->topextra || !extra->topextra->window))
12252         return 0;
12253 
12254     QWidgetPrivate *that = const_cast<QWidgetPrivate *>(this);
12255     if (!extra->topextra->shareContext) {
12256         QOpenGLContext *ctx = new QOpenGLContext;
12257         ctx->setShareContext(qt_gl_global_share_context());
12258         ctx->setFormat(extra->topextra->window->format());
12259         ctx->setScreen(extra->topextra->window->screen());
12260         ctx->create();
12261         that->extra->topextra->shareContext = ctx;
12262     }
12263     return that->extra->topextra->shareContext;
12264 #endif // QT_NO_OPENGL
12265 }
12266 
12267 #ifndef QT_NO_OPENGL
12268 void QWidgetPrivate::sendComposeStatus(QWidget *w, bool end)
12269 {
12270     QWidgetPrivate *wd = QWidgetPrivate::get(w);
12271     if (!wd->textureChildSeen)
12272         return;
12273     if (end)
12274         wd->endCompose();
12275     else
12276         wd->beginCompose();
12277     for (int i = 0; i < wd->children.size(); ++i) {
12278         w = qobject_cast<QWidget *>(wd->children.at(i));
12279         if (w && !w->isWindow() && !w->isHidden() && QWidgetPrivate::get(w)->textureChildSeen)
12280             sendComposeStatus(w, end);
12281     }
12282 }
12283 #endif // QT_NO_OPENGL
12284 
12285 Q_WIDGETS_EXPORT QWidgetData *qt_qwidget_data(QWidget *widget)
12286 {
12287     return widget->data;
12288 }
12289 
12290 Q_WIDGETS_EXPORT QWidgetPrivate *qt_widget_private(QWidget *widget)
12291 {
12292     return widget->d_func();
12293 }
12294 
12295 
12296 #if QT_CONFIG(graphicsview)
12297 /*!
12298    \since 4.5
12299 
12300    Returns the proxy widget for the corresponding embedded widget in a graphics
12301    view; otherwise returns 0.
12302 
12303    \sa QGraphicsProxyWidget::createProxyForChildWidget(),
12304        QGraphicsScene::addWidget()
12305  */
12306 QGraphicsProxyWidget *QWidget::graphicsProxyWidget() const
12307 {
12308     Q_D(const QWidget);
12309     if (d->extra) {
12310         return d->extra->proxyWidget;
12311     }
12312     return 0;
12313 }
12314 #endif
12315 
12316 #ifndef QT_NO_GESTURES
12317 /*!
12318     Subscribes the widget to a given \a gesture with specific \a flags.
12319 
12320     \sa ungrabGesture(), QGestureEvent
12321     \since 4.6
12322 */
12323 void QWidget::grabGesture(Qt::GestureType gesture, Qt::GestureFlags flags)
12324 {
12325     Q_D(QWidget);
12326     d->gestureContext.insert(gesture, flags);
12327     (void)QGestureManager::instance(); // create a gesture manager
12328 }
12329 
12330 /*!
12331     Unsubscribes the widget from a given \a gesture type
12332 
12333     \sa grabGesture(), QGestureEvent
12334     \since 4.6
12335 */
12336 void QWidget::ungrabGesture(Qt::GestureType gesture)
12337 {
12338     // if you modify this function, check the inlined version in ~QWidget, too
12339     Q_D(QWidget);
12340     if (d->gestureContext.remove(gesture)) {
12341         if (QGestureManager *manager = QGestureManager::instance())
12342             manager->cleanupCachedGestures(this, gesture);
12343     }
12344 }
12345 #endif // QT_NO_GESTURES
12346 
12347 /*!
12348     \fn void QWidget::destroy(bool destroyWindow, bool destroySubWindows)
12349 
12350     Frees up window system resources. Destroys the widget window if \a
12351     destroyWindow is true.
12352 
12353     destroy() calls itself recursively for all the child widgets,
12354     passing \a destroySubWindows for the \a destroyWindow parameter.
12355     To have more control over destruction of subwidgets, destroy
12356     subwidgets selectively first.
12357 
12358     This function is usually called from the QWidget destructor.
12359 */
12360 void QWidget::destroy(bool destroyWindow, bool destroySubWindows)
12361 {
12362     Q_D(QWidget);
12363 
12364     d->aboutToDestroy();
12365     if (!isWindow() && parentWidget())
12366         parentWidget()->d_func()->invalidateBuffer(d->effectiveRectFor(geometry()));
12367     d->deactivateWidgetCleanup();
12368 
12369     if ((windowType() == Qt::Popup) && qApp)
12370         qApp->d_func()->closePopup(this);
12371 
12372     if (this == QApplicationPrivate::active_window)
12373         QApplication::setActiveWindow(0);
12374     if (QWidget::mouseGrabber() == this)
12375         releaseMouse();
12376     if (QWidget::keyboardGrabber() == this)
12377         releaseKeyboard();
12378 
12379     setAttribute(Qt::WA_WState_Created, false);
12380 
12381     if (windowType() != Qt::Desktop) {
12382         if (destroySubWindows) {
12383             QObjectList childList(children());
12384             for (int i = 0; i < childList.size(); i++) {
12385                 QWidget *widget = qobject_cast<QWidget *>(childList.at(i));
12386                 if (widget && widget->testAttribute(Qt::WA_NativeWindow)) {
12387                     if (widget->windowHandle()) {
12388                         widget->destroy();
12389                     }
12390                 }
12391             }
12392         }
12393         if (destroyWindow) {
12394             d->deleteTLSysExtra();
12395         } else {
12396             if (parentWidget() && parentWidget()->testAttribute(Qt::WA_WState_Created)) {
12397                 d->hide_sys();
12398             }
12399         }
12400 
12401         d->setWinId(0);
12402     }
12403 }
12404 
12405 /*!
12406     \fn QPaintEngine *QWidget::paintEngine() const
12407 
12408     Returns the widget's paint engine.
12409 
12410     Note that this function should not be called explicitly by the
12411     user, since it's meant for reimplementation purposes only. The
12412     function is called by Qt internally, and the default
12413     implementation may not always return a valid pointer.
12414 */
12415 QPaintEngine *QWidget::paintEngine() const
12416 {
12417     qWarning("QWidget::paintEngine: Should no longer be called");
12418 
12419 #ifdef Q_OS_WIN
12420     // We set this bit which is checked in setAttribute for
12421     // Qt::WA_PaintOnScreen. We do this to allow these two scenarios:
12422     //
12423     // 1. Users accidentally set Qt::WA_PaintOnScreen on X and port to
12424     // Windows which would mean suddenly their widgets stop working.
12425     //
12426     // 2. Users set paint on screen and subclass paintEngine() to
12427     // return 0, in which case we have a "hole" in the backingstore
12428     // allowing use of GDI or DirectX directly.
12429     //
12430     // 1 is WRONG, but to minimize silent failures, we have set this
12431     // bit to ignore the setAttribute call. 2. needs to be
12432     // supported because its our only means of embedding native
12433     // graphics stuff.
12434     const_cast<QWidgetPrivate *>(d_func())->noPaintOnScreen = 1;
12435 #endif
12436 
12437     return 0; //##### @@@
12438 }
12439 
12440 // Do not call QWindow::mapToGlobal() until QPlatformWindow is properly showing.
12441 static inline bool canMapPosition(QWindow *window)
12442 {
12443     return window->handle() && !qt_window_private(window)->resizeEventPending;
12444 }
12445 
12446 #if QT_CONFIG(graphicsview)
12447 static inline QGraphicsProxyWidget *graphicsProxyWidget(const QWidget *w)
12448 {
12449     QGraphicsProxyWidget *result = nullptr;
12450     const QWidgetPrivate *d = qt_widget_private(const_cast<QWidget *>(w));
12451     if (d->extra)
12452         result = d->extra->proxyWidget;
12453     return result;
12454 }
12455 #endif // QT_CONFIG(graphicsview)
12456 
12457 struct MapToGlobalTransformResult {
12458     QTransform transform;
12459     QWindow *window;
12460 };
12461 
12462 static MapToGlobalTransformResult mapToGlobalTransform(const QWidget *w)
12463 {
12464     MapToGlobalTransformResult result;
12465     result.window = nullptr;
12466     for ( ; w ; w = w->parentWidget()) {
12467 #if QT_CONFIG(graphicsview)
12468         if (QGraphicsProxyWidget *qgpw = graphicsProxyWidget(w)) {
12469             if (const QGraphicsScene *scene = qgpw->scene()) {
12470                 const QList <QGraphicsView *> views = scene->views();
12471                 if (!views.isEmpty()) {
12472                     result.transform *= qgpw->sceneTransform();
12473                     result.transform *= views.first()->viewportTransform();
12474                     w = views.first()->viewport();
12475                 }
12476             }
12477         }
12478 #endif // QT_CONFIG(graphicsview)
12479         QWindow *window = w->windowHandle();
12480         if (window && canMapPosition(window)) {
12481             result.window = window;
12482             break;
12483         }
12484 
12485         const QPoint topLeft = w->geometry().topLeft();
12486         result.transform.translate(topLeft.x(), topLeft.y());
12487         if (w->isWindow())
12488             break;
12489     }
12490     return result;
12491 }
12492 
12493 /*!
12494     \fn QPoint QWidget::mapToGlobal(const QPoint &pos) const
12495 
12496     Translates the widget coordinate \a pos to global screen
12497     coordinates. For example, \c{mapToGlobal(QPoint(0,0))} would give
12498     the global coordinates of the top-left pixel of the widget.
12499 
12500     \sa mapFromGlobal(), mapTo(), mapToParent()
12501 */
12502 QPoint QWidget::mapToGlobal(const QPoint &pos) const
12503 {
12504     const MapToGlobalTransformResult t = mapToGlobalTransform(this);
12505     const QPoint g = t.transform.map(pos);
12506     return t.window ? t.window->mapToGlobal(g) : g;
12507 }
12508 
12509 /*!
12510     \fn QPoint QWidget::mapFromGlobal(const QPoint &pos) const
12511 
12512     Translates the global screen coordinate \a pos to widget
12513     coordinates.
12514 
12515     \sa mapToGlobal(), mapFrom(), mapFromParent()
12516 */
12517 QPoint QWidget::mapFromGlobal(const QPoint &pos) const
12518 {
12519    const MapToGlobalTransformResult t = mapToGlobalTransform(this);
12520    const QPoint windowLocal = t.window ? t.window->mapFromGlobal(pos) : pos;
12521    return t.transform.inverted().map(windowLocal);
12522 }
12523 
12524 QWidget *qt_pressGrab = 0;
12525 QWidget *qt_mouseGrb = 0;
12526 static bool mouseGrabWithCursor = false;
12527 static QWidget *keyboardGrb = 0;
12528 
12529 static inline QWindow *grabberWindow(const QWidget *w)
12530 {
12531     QWindow *window = w->windowHandle();
12532     if (!window)
12533         if (const QWidget *nativeParent = w->nativeParentWidget())
12534             window = nativeParent->windowHandle();
12535     return window;
12536 }
12537 
12538 #ifndef QT_NO_CURSOR
12539 static void grabMouseForWidget(QWidget *widget, const QCursor *cursor = 0)
12540 #else
12541 static void grabMouseForWidget(QWidget *widget)
12542 #endif
12543 {
12544     if (qt_mouseGrb)
12545         qt_mouseGrb->releaseMouse();
12546 
12547     mouseGrabWithCursor = false;
12548     if (QWindow *window = grabberWindow(widget)) {
12549 #ifndef QT_NO_CURSOR
12550         if (cursor) {
12551             mouseGrabWithCursor = true;
12552             QGuiApplication::setOverrideCursor(*cursor);
12553         }
12554 #endif // !QT_NO_CURSOR
12555         window->setMouseGrabEnabled(true);
12556     }
12557 
12558     qt_mouseGrb = widget;
12559     qt_pressGrab = 0;
12560 }
12561 
12562 static void releaseMouseGrabOfWidget(QWidget *widget)
12563 {
12564     if (qt_mouseGrb == widget) {
12565         if (QWindow *window = grabberWindow(widget)) {
12566 #ifndef QT_NO_CURSOR
12567             if (mouseGrabWithCursor) {
12568                 QGuiApplication::restoreOverrideCursor();
12569                 mouseGrabWithCursor = false;
12570             }
12571 #endif // !QT_NO_CURSOR
12572             window->setMouseGrabEnabled(false);
12573         }
12574     }
12575     qt_mouseGrb = 0;
12576 }
12577 
12578 /*!
12579     \fn void QWidget::grabMouse()
12580 
12581     Grabs the mouse input.
12582 
12583     This widget receives all mouse events until releaseMouse() is
12584     called; other widgets get no mouse events at all. Keyboard
12585     events are not affected. Use grabKeyboard() if you want to grab
12586     that.
12587 
12588     \warning Bugs in mouse-grabbing applications very often lock the
12589     terminal. Use this function with extreme caution, and consider
12590     using the \c -nograb command line option while debugging.
12591 
12592     It is almost never necessary to grab the mouse when using Qt, as
12593     Qt grabs and releases it sensibly. In particular, Qt grabs the
12594     mouse when a mouse button is pressed and keeps it until the last
12595     button is released.
12596 
12597     \note Only visible widgets can grab mouse input. If isVisible()
12598     returns \c false for a widget, that widget cannot call grabMouse().
12599 
12600     \note On Windows, grabMouse() only works when the mouse is inside a window
12601     owned by the process.
12602     On \macos, grabMouse() only works when the mouse is inside the frame of that widget.
12603 
12604     \sa releaseMouse(), grabKeyboard(), releaseKeyboard()
12605 */
12606 void QWidget::grabMouse()
12607 {
12608     grabMouseForWidget(this);
12609 }
12610 
12611 /*!
12612     \fn void QWidget::grabMouse(const QCursor &cursor)
12613     \overload grabMouse()
12614 
12615     Grabs the mouse input and changes the cursor shape.
12616 
12617     The cursor will assume shape \a cursor (for as long as the mouse
12618     focus is grabbed) and this widget will be the only one to receive
12619     mouse events until releaseMouse() is called().
12620 
12621     \warning Grabbing the mouse might lock the terminal.
12622 
12623     \note See the note in QWidget::grabMouse().
12624 
12625     \sa releaseMouse(), grabKeyboard(), releaseKeyboard(), setCursor()
12626 */
12627 #ifndef QT_NO_CURSOR
12628 void QWidget::grabMouse(const QCursor &cursor)
12629 {
12630     grabMouseForWidget(this, &cursor);
12631 }
12632 #endif
12633 
12634 bool QWidgetPrivate::stealMouseGrab(bool grab)
12635 {
12636     // This is like a combination of grab/releaseMouse() but with error checking
12637     // and it has no effect on the result of mouseGrabber().
12638     Q_Q(QWidget);
12639     QWindow *window = grabberWindow(q);
12640     return window ? window->setMouseGrabEnabled(grab) : false;
12641 }
12642 
12643 /*!
12644     \fn void QWidget::releaseMouse()
12645 
12646     Releases the mouse grab.
12647 
12648     \sa grabMouse(), grabKeyboard(), releaseKeyboard()
12649 */
12650 void QWidget::releaseMouse()
12651 {
12652     releaseMouseGrabOfWidget(this);
12653 }
12654 
12655 /*!
12656     \fn void QWidget::grabKeyboard()
12657 
12658     Grabs the keyboard input.
12659 
12660     This widget receives all keyboard events until releaseKeyboard()
12661     is called; other widgets get no keyboard events at all. Mouse
12662     events are not affected. Use grabMouse() if you want to grab that.
12663 
12664     The focus widget is not affected, except that it doesn't receive
12665     any keyboard events. setFocus() moves the focus as usual, but the
12666     new focus widget receives keyboard events only after
12667     releaseKeyboard() is called.
12668 
12669     If a different widget is currently grabbing keyboard input, that
12670     widget's grab is released first.
12671 
12672     \sa releaseKeyboard(), grabMouse(), releaseMouse(), focusWidget()
12673 */
12674 void QWidget::grabKeyboard()
12675 {
12676     if (keyboardGrb)
12677         keyboardGrb->releaseKeyboard();
12678     if (QWindow *window = grabberWindow(this))
12679         window->setKeyboardGrabEnabled(true);
12680     keyboardGrb = this;
12681 }
12682 
12683 bool QWidgetPrivate::stealKeyboardGrab(bool grab)
12684 {
12685     // This is like a combination of grab/releaseKeyboard() but with error
12686     // checking and it has no effect on the result of keyboardGrabber().
12687     Q_Q(QWidget);
12688     QWindow *window = grabberWindow(q);
12689     return window ? window->setKeyboardGrabEnabled(grab) : false;
12690 }
12691 
12692 /*!
12693     \fn void QWidget::releaseKeyboard()
12694 
12695     Releases the keyboard grab.
12696 
12697     \sa grabKeyboard(), grabMouse(), releaseMouse()
12698 */
12699 void QWidget::releaseKeyboard()
12700 {
12701     if (keyboardGrb == this) {
12702         if (QWindow *window = grabberWindow(this))
12703             window->setKeyboardGrabEnabled(false);
12704         keyboardGrb = 0;
12705     }
12706 }
12707 
12708 /*!
12709     \fn QWidget *QWidget::mouseGrabber()
12710 
12711     Returns the widget that is currently grabbing the mouse input.
12712 
12713     If no widget in this application is currently grabbing the mouse,
12714     0 is returned.
12715 
12716     \sa grabMouse(), keyboardGrabber()
12717 */
12718 QWidget *QWidget::mouseGrabber()
12719 {
12720     if (qt_mouseGrb)
12721         return qt_mouseGrb;
12722     return qt_pressGrab;
12723 }
12724 
12725 /*!
12726     \fn QWidget *QWidget::keyboardGrabber()
12727 
12728     Returns the widget that is currently grabbing the keyboard input.
12729 
12730     If no widget in this application is currently grabbing the
12731     keyboard, 0 is returned.
12732 
12733     \sa grabMouse(), mouseGrabber()
12734 */
12735 QWidget *QWidget::keyboardGrabber()
12736 {
12737     return keyboardGrb;
12738 }
12739 
12740 /*!
12741     \fn void QWidget::activateWindow()
12742 
12743     Sets the top-level widget containing this widget to be the active
12744     window.
12745 
12746     An active window is a visible top-level window that has the
12747     keyboard input focus.
12748 
12749     This function performs the same operation as clicking the mouse on
12750     the title bar of a top-level window. On X11, the result depends on
12751     the Window Manager. If you want to ensure that the window is
12752     stacked on top as well you should also call raise(). Note that the
12753     window must be visible, otherwise activateWindow() has no effect.
12754 
12755     On Windows, if you are calling this when the application is not
12756     currently the active one then it will not make it the active
12757     window.  It will change the color of the taskbar entry to indicate
12758     that the window has changed in some way. This is because Microsoft
12759     does not allow an application to interrupt what the user is currently
12760     doing in another application.
12761 
12762     \sa isActiveWindow(), window(), show(), QWindowsWindowFunctions::setWindowActivationBehavior()
12763 */
12764 void QWidget::activateWindow()
12765 {
12766     QWindow *const wnd = window()->windowHandle();
12767 
12768     if (wnd)
12769         wnd->requestActivate();
12770 }
12771 
12772 /*!
12773 
12774     Internal implementation of the virtual QPaintDevice::metric()
12775     function.
12776 
12777     \a m is the metric to get.
12778 */
12779 int QWidget::metric(PaintDeviceMetric m) const
12780 {
12781     QWindow *topLevelWindow = 0;
12782     QScreen *screen = 0;
12783     if (QWidget *topLevel = window()) {
12784         topLevelWindow = topLevel->windowHandle();
12785         if (topLevelWindow)
12786             screen = topLevelWindow->screen();
12787     }
12788     if (!screen && QGuiApplication::primaryScreen())
12789         screen = QGuiApplication::primaryScreen();
12790 
12791     if (!screen) {
12792         if (m == PdmDpiX || m == PdmDpiY)
12793               return 72;
12794         return QPaintDevice::metric(m);
12795     }
12796     int val;
12797     if (m == PdmWidth) {
12798         val = data->crect.width();
12799     } else if (m == PdmWidthMM) {
12800         val = data->crect.width() * screen->physicalSize().width() / screen->geometry().width();
12801     } else if (m == PdmHeight) {
12802         val = data->crect.height();
12803     } else if (m == PdmHeightMM) {
12804         val = data->crect.height() * screen->physicalSize().height() / screen->geometry().height();
12805     } else if (m == PdmDepth) {
12806         return screen->depth();
12807     } else if (m == PdmDpiX) {
12808         for (const QWidget *p = this; p; p = p->parentWidget()) {
12809             if (p->d_func()->extra && p->d_func()->extra->customDpiX)
12810                 return p->d_func()->extra->customDpiX;
12811         }
12812         return qRound(screen->logicalDotsPerInchX());
12813     } else if (m == PdmDpiY) {
12814         for (const QWidget *p = this; p; p = p->parentWidget()) {
12815             if (p->d_func()->extra && p->d_func()->extra->customDpiY)
12816                 return p->d_func()->extra->customDpiY;
12817         }
12818         return qRound(screen->logicalDotsPerInchY());
12819     } else if (m == PdmPhysicalDpiX) {
12820         return qRound(screen->physicalDotsPerInchX());
12821     } else if (m == PdmPhysicalDpiY) {
12822         return qRound(screen->physicalDotsPerInchY());
12823     } else if (m == PdmDevicePixelRatio) {
12824         return topLevelWindow ? topLevelWindow->devicePixelRatio() : qApp->devicePixelRatio();
12825     } else if (m == PdmDevicePixelRatioScaled) {
12826         return (QPaintDevice::devicePixelRatioFScale() *
12827                 (topLevelWindow ? topLevelWindow->devicePixelRatio() : qApp->devicePixelRatio()));
12828     } else {
12829         val = QPaintDevice::metric(m);// XXX
12830     }
12831     return val;
12832 }
12833 
12834 /*!
12835     Initializes the \a painter pen, background and font to the same as
12836     the given widget's. This function is called automatically when the
12837     painter is opened on a QWidget.
12838 */
12839 void QWidget::initPainter(QPainter *painter) const
12840 {
12841     const QPalette &pal = palette();
12842     painter->d_func()->state->pen = QPen(pal.brush(foregroundRole()), 1);
12843     painter->d_func()->state->bgBrush = pal.brush(backgroundRole());
12844     QFont f(font(), const_cast<QWidget *>(this));
12845     painter->d_func()->state->deviceFont = f;
12846     painter->d_func()->state->font = f;
12847 }
12848 
12849 /*!
12850     \internal
12851 
12852     Do PaintDevice rendering with the specified \a offset.
12853 */
12854 QPaintDevice *QWidget::redirected(QPoint *offset) const
12855 {
12856     return d_func()->redirected(offset);
12857 }
12858 
12859 /*!
12860     \internal
12861 
12862     A painter that is shared among other instances of QPainter.
12863 */
12864 QPainter *QWidget::sharedPainter() const
12865 {
12866     // Someone sent a paint event directly to the widget
12867     if (!d_func()->redirectDev)
12868         return 0;
12869 
12870     QPainter *sp = d_func()->sharedPainter();
12871     if (!sp || !sp->isActive())
12872         return 0;
12873 
12874     if (sp->paintEngine()->paintDevice() != d_func()->redirectDev)
12875         return 0;
12876 
12877     return sp;
12878 }
12879 
12880 /*!
12881     \fn void QWidget::setMask(const QRegion &region)
12882     \overload
12883 
12884     Causes only the parts of the widget which overlap \a region to be
12885     visible. If the region includes pixels outside the rect() of the
12886     widget, window system controls in that area may or may not be
12887     visible, depending on the platform.
12888 
12889     Note that this effect can be slow if the region is particularly
12890     complex.
12891 
12892     \sa windowOpacity
12893 */
12894 void QWidget::setMask(const QRegion &newMask)
12895 {
12896     Q_D(QWidget);
12897 
12898     d->createExtra();
12899     if (newMask == d->extra->mask)
12900         return;
12901 
12902 #ifndef QT_NO_BACKINGSTORE
12903     const QRegion oldMask(d->extra->mask);
12904 #endif
12905 
12906     d->extra->mask = newMask;
12907     d->extra->hasMask = !newMask.isEmpty();
12908 
12909 #if 1 // Used to be excluded in Qt4 for Q_WS_MAC
12910     if (!testAttribute(Qt::WA_WState_Created))
12911         return;
12912 #endif
12913 
12914     d->setMask_sys(newMask);
12915 
12916 #ifndef QT_NO_BACKINGSTORE
12917     if (!isVisible())
12918         return;
12919 
12920     if (!d->extra->hasMask) {
12921         // Mask was cleared; update newly exposed area.
12922         QRegion expose(rect());
12923         expose -= oldMask;
12924         if (!expose.isEmpty()) {
12925             d->setDirtyOpaqueRegion();
12926             update(expose);
12927         }
12928         return;
12929     }
12930 
12931     if (!isWindow()) {
12932         // Update newly exposed area on the parent widget.
12933         QRegion parentExpose(rect());
12934         parentExpose -= newMask;
12935         if (!parentExpose.isEmpty()) {
12936             d->setDirtyOpaqueRegion();
12937             parentExpose.translate(data->crect.topLeft());
12938             parentWidget()->update(parentExpose);
12939         }
12940 
12941         // Update newly exposed area on this widget
12942         if (!oldMask.isEmpty())
12943             update(newMask - oldMask);
12944     }
12945 #endif
12946 }
12947 
12948 void QWidgetPrivate::setMask_sys(const QRegion &region)
12949 {
12950     Q_Q(QWidget);
12951     if (QWindow *window = q->windowHandle())
12952         window->setMask(region);
12953 }
12954 
12955 /*!
12956     \fn void QWidget::setMask(const QBitmap &bitmap)
12957 
12958     Causes only the pixels of the widget for which \a bitmap has a
12959     corresponding 1 bit to be visible. If the region includes pixels
12960     outside the rect() of the widget, window system controls in that
12961     area may or may not be visible, depending on the platform.
12962 
12963     Note that this effect can be slow if the region is particularly
12964     complex.
12965 
12966     The following code shows how an image with an alpha channel can be
12967     used to generate a mask for a widget:
12968 
12969     \snippet widget-mask/main.cpp 0
12970 
12971     The label shown by this code is masked using the image it contains,
12972     giving the appearance that an irregularly-shaped image is being drawn
12973     directly onto the screen.
12974 
12975     Masked widgets receive mouse events only on their visible
12976     portions.
12977 
12978     \sa clearMask(), windowOpacity(), {Shaped Clock Example}
12979 */
12980 void QWidget::setMask(const QBitmap &bitmap)
12981 {
12982     setMask(QRegion(bitmap));
12983 }
12984 
12985 /*!
12986     \fn void QWidget::clearMask()
12987 
12988     Removes any mask set by setMask().
12989 
12990     \sa setMask()
12991 */
12992 void QWidget::clearMask()
12993 {
12994     Q_D(QWidget);
12995     if (!d->extra || !d->extra->hasMask)
12996         return;
12997     setMask(QRegion());
12998 }
12999 
13000 void QWidgetPrivate::setWidgetParentHelper(QObject *widgetAsObject, QObject *newParent)
13001 {
13002     Q_ASSERT(widgetAsObject->isWidgetType());
13003     Q_ASSERT(!newParent || newParent->isWidgetType());
13004     QWidget *widget = static_cast<QWidget*>(widgetAsObject);
13005     widget->setParent(static_cast<QWidget*>(newParent));
13006 }
13007 
13008 void QWidgetPrivate::setNetWmWindowTypes(bool skipIfMissing)
13009 {
13010     Q_Q(QWidget);
13011 
13012     if (!q->windowHandle())
13013         return;
13014 
13015     int wmWindowType = 0;
13016     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDesktop))
13017         wmWindowType |= QXcbWindowFunctions::Desktop;
13018     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDock))
13019         wmWindowType |= QXcbWindowFunctions::Dock;
13020     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeToolBar))
13021         wmWindowType |= QXcbWindowFunctions::Toolbar;
13022     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeMenu))
13023         wmWindowType |= QXcbWindowFunctions::Menu;
13024     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeUtility))
13025         wmWindowType |= QXcbWindowFunctions::Utility;
13026     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeSplash))
13027         wmWindowType |= QXcbWindowFunctions::Splash;
13028     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDialog))
13029         wmWindowType |= QXcbWindowFunctions::Dialog;
13030     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDropDownMenu))
13031         wmWindowType |= QXcbWindowFunctions::DropDownMenu;
13032     if (q->testAttribute(Qt::WA_X11NetWmWindowTypePopupMenu))
13033         wmWindowType |= QXcbWindowFunctions::PopupMenu;
13034     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeToolTip))
13035         wmWindowType |= QXcbWindowFunctions::Tooltip;
13036     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeNotification))
13037         wmWindowType |= QXcbWindowFunctions::Notification;
13038     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeCombo))
13039         wmWindowType |= QXcbWindowFunctions::Combo;
13040     if (q->testAttribute(Qt::WA_X11NetWmWindowTypeDND))
13041         wmWindowType |= QXcbWindowFunctions::Dnd;
13042 
13043     if (wmWindowType == 0 && skipIfMissing)
13044         return;
13045 
13046     QXcbWindowFunctions::setWmWindowType(q->windowHandle(), static_cast<QXcbWindowFunctions::WmWindowType>(wmWindowType));
13047 }
13048 
13049 #ifndef QT_NO_DEBUG_STREAM
13050 
13051 static inline void formatWidgetAttributes(QDebug debug, const QWidget *widget)
13052 {
13053     const QMetaObject *qtMo = qt_getEnumMetaObject(Qt::WA_AttributeCount);
13054     const QMetaEnum me = qtMo->enumerator(qtMo->indexOfEnumerator("WidgetAttribute"));
13055     debug << ", attributes=[";
13056     int count = 0;
13057     for (int a = 0; a < Qt::WA_AttributeCount; ++a) {
13058         if (widget->testAttribute(static_cast<Qt::WidgetAttribute>(a))) {
13059             if (count++)
13060                 debug << ',';
13061             debug << me.valueToKey(a);
13062         }
13063     }
13064     debug << ']';
13065 }
13066 
13067 QDebug operator<<(QDebug debug, const QWidget *widget)
13068 {
13069     const QDebugStateSaver saver(debug);
13070     debug.nospace();
13071     if (widget) {
13072         debug << widget->metaObject()->className() << '(' << (const void *)widget;
13073         if (!widget->objectName().isEmpty())
13074             debug << ", name=" << widget->objectName();
13075         if (debug.verbosity() > 2) {
13076             const QRect geometry = widget->geometry();
13077             const QRect frameGeometry = widget->frameGeometry();
13078             if (widget->isVisible())
13079                 debug << ", visible";
13080             if (!widget->isEnabled())
13081                 debug << ", disabled";
13082             debug << ", states=" << widget->windowState()
13083                 << ", type=" << widget->windowType() << ", flags=" <<  widget->windowFlags();
13084             formatWidgetAttributes(debug, widget);
13085             if (widget->isWindow())
13086                 debug << ", window";
13087             debug << ", " << geometry.width() << 'x' << geometry.height()
13088                 << forcesign << geometry.x() << geometry.y() << noforcesign;
13089             if (frameGeometry != geometry) {
13090                 const QMargins margins(geometry.x() - frameGeometry.x(),
13091                                        geometry.y() - frameGeometry.y(),
13092                                        frameGeometry.right() - geometry.right(),
13093                                        frameGeometry.bottom() - geometry.bottom());
13094                 debug << ", margins=" << margins;
13095             }
13096             debug << ", devicePixelRatio=" << widget->devicePixelRatioF();
13097             if (const WId wid = widget->internalWinId())
13098                 debug << ", winId=0x" << hex << wid << dec;
13099         }
13100         debug << ')';
13101     } else {
13102         debug << "QWidget(0x0)";
13103     }
13104     return debug;
13105 }
13106 #endif // !QT_NO_DEBUG_STREAM
13107 
13108 QT_END_NAMESPACE
13109 
13110 #include "moc_qwidget.cpp"
13111 
