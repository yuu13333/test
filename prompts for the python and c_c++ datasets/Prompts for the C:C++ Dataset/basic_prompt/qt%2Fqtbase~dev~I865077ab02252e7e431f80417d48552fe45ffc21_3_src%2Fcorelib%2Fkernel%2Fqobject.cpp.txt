Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2019 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Copyright (C) 2013 Olivier Goffart <ogoffart@woboq.com>
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qobject.h"
43 #include "qobject_p.h"
44 #include "qmetaobject_p.h"
45 
46 #include "qabstracteventdispatcher.h"
47 #include "qabstracteventdispatcher_p.h"
48 #include "qcoreapplication.h"
49 #include "qcoreapplication_p.h"
50 #include "qloggingcategory.h"
51 #include "qvariant.h"
52 #include "qmetaobject.h"
53 #if QT_CONFIG(regularexpression)
54 #  include <qregularexpression.h>
55 #endif
56 #include <qthread.h>
57 #include <private/qthread_p.h>
58 #include <qdebug.h>
59 #include <qpair.h>
60 #include <qvarlengtharray.h>
61 #include <qscopeguard.h>
62 #include <qset.h>
63 #if QT_CONFIG(thread)
64 #include <qsemaphore.h>
65 #endif
66 #include <qsharedpointer.h>
67 
68 #include <private/qorderedmutexlocker_p.h>
69 #include <private/qhooks_p.h>
70 #include <qtcore_tracepoints_p.h>
71 
72 #include <new>
73 #include <mutex>
74 
75 #include <ctype.h>
76 #include <limits.h>
77 
78 QT_BEGIN_NAMESPACE
79 
80 static int DIRECT_CONNECTION_ONLY = 0;
81 
82 Q_LOGGING_CATEGORY(lcConnectSlotsByName, "qt.core.qmetaobject.connectslotsbyname")
83 Q_LOGGING_CATEGORY(lcConnect, "qt.core.qobject.connect")
84 
85 Q_CORE_EXPORT QBasicAtomicPointer<QSignalSpyCallbackSet> qt_signal_spy_callback_set = Q_BASIC_ATOMIC_INITIALIZER(nullptr);
86 
87 void qt_register_signal_spy_callbacks(QSignalSpyCallbackSet *callback_set)
88 {
89     qt_signal_spy_callback_set.storeRelease(callback_set);
90 }
91 
92 QDynamicMetaObjectData::~QDynamicMetaObjectData()
93 {
94 }
95 
96 QAbstractDynamicMetaObject::~QAbstractDynamicMetaObject()
97 {
98 }
99 
100 static int *queuedConnectionTypes(const QMetaMethod &method)
101 {
102     const auto parameterCount = method.parameterCount();
103     int *typeIds = new int[parameterCount + 1];
104     Q_CHECK_PTR(typeIds);
105     for (int i = 0; i < parameterCount; ++i) {
106         const QMetaType metaType = method.parameterMetaType(i);
107         if (metaType.flags() & QMetaType::IsPointer)
108             typeIds[i] = QMetaType::VoidStar;
109         else
110             typeIds[i] = metaType.id();
111         if (!typeIds[i]) {
112             const QByteArray typeName = method.parameterTypeName(i);
113             qCWarning(lcConnect,
114                       "QObject::connect: Cannot queue arguments of type '%s'\n"
115                       "(Make sure '%s' is registered using qRegisterMetaType().)",
116                       typeName.constData(), typeName.constData());
117             delete[] typeIds;
118             return nullptr;
119         }
120     }
121     typeIds[parameterCount] = 0;
122 
123     return typeIds;
124 }
125 
126 static int *queuedConnectionTypes(const QArgumentType *argumentTypes, int argc)
127 {
128     QScopedArrayPointer<int> types(new int[argc + 1]);
129     for (int i = 0; i < argc; ++i) {
130         const QArgumentType &type = argumentTypes[i];
131         if (type.type())
132             types[i] = type.type();
133         else if (type.name().endsWith('*'))
134             types[i] = QMetaType::VoidStar;
135         else
136             types[i] = QMetaType::fromName(type.name()).id();
137 
138         if (!types[i]) {
139             qCWarning(lcConnect,
140                       "QObject::connect: Cannot queue arguments of type '%s'\n"
141                       "(Make sure '%s' is registered using qRegisterMetaType().)",
142                       type.name().constData(), type.name().constData());
143             return nullptr;
144         }
145     }
146     types[argc] = 0;
147 
148     return types.take();
149 }
150 
151 static QBasicMutex _q_ObjectMutexPool[131];
152 
153 /**
154  * \internal
155  * mutex to be locked when accessing the connection lists or the senders list
156  */
157 static inline QBasicMutex *signalSlotLock(const QObject *o)
158 {
159     return &_q_ObjectMutexPool[uint(quintptr(o)) % sizeof(_q_ObjectMutexPool)/sizeof(QBasicMutex)];
160 }
161 
162 #if QT_VERSION < 0x60000
163 extern "C" Q_CORE_EXPORT void qt_addObject(QObject *)
164 {}
165 
166 extern "C" Q_CORE_EXPORT void qt_removeObject(QObject *)
167 {}
168 #endif
169 
170 void (*QAbstractDeclarativeData::destroyed)(QAbstractDeclarativeData *, QObject *) = nullptr;
171 void (*QAbstractDeclarativeData::signalEmitted)(QAbstractDeclarativeData *, QObject *, int, void **) = nullptr;
172 int  (*QAbstractDeclarativeData::receivers)(QAbstractDeclarativeData *, const QObject *, int) = nullptr;
173 bool (*QAbstractDeclarativeData::isSignalConnected)(QAbstractDeclarativeData *, const QObject *, int) = nullptr;
174 void (*QAbstractDeclarativeData::setWidgetParent)(QObject *, QObject *) = nullptr;
175 
176 /*!
177     \fn QObjectData::QObjectData()
178     \internal
179  */
180 
181 
182 QObjectData::~QObjectData() {}
183 
184 QMetaObject *QObjectData::dynamicMetaObject() const
185 {
186     return metaObject->toDynamicMetaObject(q_ptr);
187 }
188 
189 QObjectPrivate::QObjectPrivate(int version)
190     : threadData(nullptr), currentChildBeingDeleted(nullptr)
191 {
192     checkForIncompatibleLibraryVersion(version);
193 
194     // QObjectData initialization
195     q_ptr = nullptr;
196     parent = nullptr;                           // no parent yet. It is set by setParent()
197     isWidget = false;                           // assume not a widget object
198     blockSig = false;                           // not blocking signals
199     wasDeleted = false;                         // double-delete catcher
200     isDeletingChildren = false;                 // set by deleteChildren()
201     sendChildEvents = true;                     // if we should send ChildAdded and ChildRemoved events to parent
202     receiveChildEvents = true;
203     postedEvents = 0;
204     extraData = nullptr;
205     metaObject = nullptr;
206     isWindow = false;
207     deleteLaterCalled = false;
208 }
209 
210 QObjectPrivate::~QObjectPrivate()
211 {
212     auto thisThreadData = threadData.loadRelaxed();
213     if (extraData && !extraData->runningTimers.isEmpty()) {
214         if (Q_LIKELY(thisThreadData->thread.loadAcquire() == QThread::currentThread())) {
215             // unregister pending timers
216             if (thisThreadData->hasEventDispatcher())
217                 thisThreadData->eventDispatcher.loadRelaxed()->unregisterTimers(q_ptr);
218 
219             // release the timer ids back to the pool
220             for (int i = 0; i < extraData->runningTimers.size(); ++i)
221                 QAbstractEventDispatcherPrivate::releaseTimerId(extraData->runningTimers.at(i));
222         } else {
223             qWarning("QObject::~QObject: Timers cannot be stopped from another thread");
224         }
225     }
226 
227     if (postedEvents)
228         QCoreApplication::removePostedEvents(q_ptr, 0);
229 
230     thisThreadData->deref();
231 
232     if (metaObject)
233         metaObject->objectDestroyed(q_ptr);
234 
235     delete extraData;
236 }
237 
238 /*!
239   \internal
240   For a given metaobject, compute the signal offset, and the method offset (including signals)
241 */
242 static void computeOffsets(const QMetaObject *metaobject, int *signalOffset, int *methodOffset)
243 {
244     *signalOffset = *methodOffset = 0;
245     const QMetaObject *m = metaobject->d.superdata;
246     while (m) {
247         const QMetaObjectPrivate *d = QMetaObjectPrivate::get(m);
248         *methodOffset += d->methodCount;
249         Q_ASSERT(d->revision >= 4);
250         *signalOffset += d->signalCount;
251         m = m->d.superdata;
252     }
253 }
254 
255 // Used by QAccessibleWidget
256 bool QObjectPrivate::isSender(const QObject *receiver, const char *signal) const
257 {
258     Q_Q(const QObject);
259     int signal_index = signalIndex(signal);
260     ConnectionData *cd = connections.loadRelaxed();
261     if (signal_index < 0 || !cd)
262         return false;
263     QBasicMutexLocker locker(signalSlotLock(q));
264     if (signal_index < cd->signalVectorCount()) {
265         const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
266 
267         while (c) {
268             if (c->receiver.loadRelaxed() == receiver)
269                 return true;
270             c = c->nextConnectionList.loadRelaxed();
271         }
272     }
273     return false;
274 }
275 
276 // Used by QAccessibleWidget
277 QObjectList QObjectPrivate::receiverList(const char *signal) const
278 {
279     QObjectList returnValue;
280     int signal_index = signalIndex(signal);
281     ConnectionData *cd = connections.loadRelaxed();
282     if (signal_index < 0 || !cd)
283         return returnValue;
284     if (signal_index < cd->signalVectorCount()) {
285         const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
286 
287         while (c) {
288             QObject *r = c->receiver.loadRelaxed();
289             if (r)
290                 returnValue << r;
291             c = c->nextConnectionList.loadRelaxed();
292         }
293     }
294     return returnValue;
295 }
296 
297 // Used by QAccessibleWidget
298 QObjectList QObjectPrivate::senderList() const
299 {
300     QObjectList returnValue;
301     ConnectionData *cd = connections.loadRelaxed();
302     if (cd) {
303         QBasicMutexLocker locker(signalSlotLock(q_func()));
304         for (Connection *c = cd->senders; c; c = c->next)
305             returnValue << c->sender;
306     }
307     return returnValue;
308 }
309 
310 /*!
311   \internal
312   Add the connection \a c to the list of connections of the sender's object
313   for the specified \a signal
314 
315   The signalSlotLock() of the sender and receiver must be locked while calling
316   this function
317 
318   Will also add the connection in the sender's list of the receiver.
319  */
320 void QObjectPrivate::addConnection(int signal, Connection *c)
321 {
322     Q_ASSERT(c->sender == q_ptr);
323     ensureConnectionData();
324     ConnectionData *cd = connections.loadRelaxed();
325     cd->resizeSignalVector(signal + 1);
326 
327     ConnectionList &connectionList = cd->connectionsForSignal(signal);
328     if (connectionList.last.loadRelaxed()) {
329         Q_ASSERT(connectionList.last.loadRelaxed()->receiver.loadRelaxed());
330         connectionList.last.loadRelaxed()->nextConnectionList.storeRelaxed(c);
331     } else {
332         connectionList.first.storeRelaxed(c);
333     }
334     c->id = ++cd->currentConnectionId;
335     c->prevConnectionList = connectionList.last.loadRelaxed();
336     connectionList.last.storeRelaxed(c);
337 
338     QObjectPrivate *rd = QObjectPrivate::get(c->receiver.loadRelaxed());
339     rd->ensureConnectionData();
340 
341     c->prev = &(rd->connections.loadRelaxed()->senders);
342     c->next = *c->prev;
343     *c->prev = c;
344     if (c->next)
345         c->next->prev = &c->next;
346 }
347 
348 void QObjectPrivate::ConnectionData::removeConnection(QObjectPrivate::Connection *c)
349 {
350     Q_ASSERT(c->receiver.loadRelaxed());
351     ConnectionList &connections = signalVector.loadRelaxed()->at(c->signal_index);
352     c->receiver.storeRelaxed(nullptr);
353     QThreadData *td = c->receiverThreadData.loadRelaxed();
354     if (td)
355         td->deref();
356     c->receiverThreadData.storeRelaxed(nullptr);
357 
358 #ifndef QT_NO_DEBUG
359     bool found = false;
360     for (Connection *cc = connections.first.loadRelaxed(); cc; cc = cc->nextConnectionList.loadRelaxed()) {
361         if (cc == c) {
362             found = true;
363             break;
364         }
365     }
366     Q_ASSERT(found);
367 #endif
368 
369     // remove from the senders linked list
370     *c->prev = c->next;
371     if (c->next)
372         c->next->prev = c->prev;
373     c->prev = nullptr;
374 
375     if (connections.first.loadRelaxed() == c)
376         connections.first.storeRelaxed(c->nextConnectionList.loadRelaxed());
377     if (connections.last.loadRelaxed() == c)
378         connections.last.storeRelaxed(c->prevConnectionList);
379     Q_ASSERT(signalVector.loadRelaxed()->at(c->signal_index).first.loadRelaxed() != c);
380     Q_ASSERT(signalVector.loadRelaxed()->at(c->signal_index).last.loadRelaxed() != c);
381 
382     // keep c->nextConnectionList intact, as it might still get accessed by activate
383     Connection *n = c->nextConnectionList.loadRelaxed();
384     if (n)
385         n->prevConnectionList = c->prevConnectionList;
386     if (c->prevConnectionList)
387         c->prevConnectionList->nextConnectionList.storeRelaxed(n);
388     c->prevConnectionList = nullptr;
389 
390     Q_ASSERT(c != orphaned.loadRelaxed());
391     // add c to orphanedConnections
392     Connection *o = nullptr;
393     /* No ABA issue here: When adding a node, we only care about the list head, it doesn't
394      * matter if the tail changes.
395      */
396     do {
397         o = orphaned.loadRelaxed();
398         c->nextInOrphanList = o;
399     } while (!orphaned.testAndSetRelease(o, c));
400 
401 #ifndef QT_NO_DEBUG
402     found = false;
403     for (Connection *cc = connections.first.loadRelaxed(); cc; cc = cc->nextConnectionList.loadRelaxed()) {
404         if (cc == c) {
405             found = true;
406             break;
407         }
408     }
409     Q_ASSERT(!found);
410 #endif
411 
412 }
413 
414 void QObjectPrivate::ConnectionData::cleanOrphanedConnectionsImpl(QObject *sender, LockPolicy lockPolicy)
415 {
416     QBasicMutex *senderMutex = signalSlotLock(sender);
417     ConnectionOrSignalVector *c = nullptr;
418     {
419         std::unique_lock<QBasicMutex> lock(*senderMutex, std::defer_lock_t{});
420         if (lockPolicy == NeedToLock)
421             lock.lock();
422         if (ref.loadAcquire() > 1)
423             return;
424 
425         // Since ref == 1, no activate() is in process since we locked the mutex. That implies,
426         // that nothing can reference the orphaned connection objects anymore and they can
427         // be safely deleted
428         c = orphaned.fetchAndStoreRelaxed(nullptr);
429     }
430     if (c) {
431         // Deleting c might run arbitrary user code, so we must not hold the lock
432         if (lockPolicy == AlreadyLockedAndTemporarilyReleasingLock) {
433             senderMutex->unlock();
434             deleteOrphaned(c);
435             senderMutex->lock();
436         } else {
437             deleteOrphaned(c);
438         }
439     }
440 }
441 
442 void QObjectPrivate::ConnectionData::deleteOrphaned(QObjectPrivate::ConnectionOrSignalVector *o)
443 {
444     while (o) {
445         QObjectPrivate::ConnectionOrSignalVector *next = nullptr;
446         if (SignalVector *v = ConnectionOrSignalVector::asSignalVector(o)) {
447             next = v->nextInOrphanList;
448             free(v);
449         } else {
450             QObjectPrivate::Connection *c = static_cast<Connection *>(o);
451             next = c->nextInOrphanList;
452             Q_ASSERT(!c->receiver.loadRelaxed());
453             Q_ASSERT(!c->prev);
454             c->freeSlotObject();
455             c->deref();
456         }
457         o = next;
458     }
459 }
460 
461 /*! \internal
462 
463   Returns \c true if the signal with index \a signal_index from object \a sender is connected.
464 
465   \a signal_index must be the index returned by QObjectPrivate::signalIndex;
466 */
467 bool QObjectPrivate::isSignalConnected(uint signalIndex, bool checkDeclarative) const
468 {
469     if (checkDeclarative && isDeclarativeSignalConnected(signalIndex))
470         return true;
471 
472     ConnectionData *cd = connections.loadRelaxed();
473     if (!cd)
474         return false;
475     SignalVector *signalVector = cd->signalVector.loadRelaxed();
476     if (!signalVector)
477         return false;
478 
479     if (signalVector->at(-1).first.loadRelaxed())
480         return true;
481 
482     if (signalIndex < uint(cd->signalVectorCount())) {
483         const QObjectPrivate::Connection *c = signalVector->at(signalIndex).first.loadRelaxed();
484         while (c) {
485             if (c->receiver.loadRelaxed())
486                 return true;
487             c = c->nextConnectionList.loadRelaxed();
488         }
489     }
490     return false;
491 }
492 
493 bool QObjectPrivate::maybeSignalConnected(uint signalIndex) const
494 {
495     ConnectionData *cd = connections.loadRelaxed();
496     if (!cd)
497         return false;
498     SignalVector *signalVector = cd->signalVector.loadRelaxed();
499     if (!signalVector)
500         return false;
501 
502     if (signalVector->at(-1).first.loadAcquire())
503         return true;
504 
505     if (signalIndex < uint(cd->signalVectorCount())) {
506         const QObjectPrivate::Connection *c = signalVector->at(signalIndex).first.loadAcquire();
507         return c != nullptr;
508     }
509     return false;
510 }
511 
512 /*!
513     \internal
514  */
515 QAbstractMetaCallEvent::~QAbstractMetaCallEvent()
516 {
517 #if QT_CONFIG(thread)
518     if (semaphore_)
519         semaphore_->release();
520 #endif
521 }
522 
523 /*!
524     \internal
525  */
526 inline void QMetaCallEvent::allocArgs()
527 {
528     if (!d.nargs_)
529         return;
530 
531     constexpr size_t each = sizeof(void*) + sizeof(QMetaType);
532     void *const memory = d.nargs_ * each > sizeof(prealloc_) ?
533         calloc(d.nargs_, each) : prealloc_;
534 
535     Q_CHECK_PTR(memory);
536     d.args_ = static_cast<void **>(memory);
537 }
538 
539 /*!
540     \internal
541 
542     Used for blocking queued connections, just passes \a args through without
543     allocating any memory.
544  */
545 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative,
546                                QObjectPrivate::StaticMetaCallFunction callFunction,
547                                const QObject *sender, int signalId,
548                                void **args, QSemaphore *semaphore)
549     : QAbstractMetaCallEvent(sender, signalId, semaphore),
550       d({nullptr, args, callFunction, 0, method_offset, method_relative}),
551       prealloc_()
552 {
553 }
554 
555 /*!
556     \internal
557 
558     Used for blocking queued connections, just passes \a args through without
559     allocating any memory.
560  */
561 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO,
562                                const QObject *sender, int signalId,
563                                void **args, QSemaphore *semaphore)
564     : QAbstractMetaCallEvent(sender, signalId, semaphore),
565       d({slotO, args, nullptr, 0, 0, ushort(-1)}),
566       prealloc_()
567 {
568     if (d.slotObj_)
569         d.slotObj_->ref();
570 }
571 
572 /*!
573     \internal
574 
575     Allocates memory for \a nargs; code creating an event needs to initialize
576     the void* and int arrays by accessing \a args() and \a types(), respectively.
577  */
578 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative,
579                                QObjectPrivate::StaticMetaCallFunction callFunction,
580                                const QObject *sender, int signalId,
581                                int nargs)
582     : QAbstractMetaCallEvent(sender, signalId),
583       d({nullptr, nullptr, callFunction, nargs, method_offset, method_relative}),
584       prealloc_()
585 {
586     allocArgs();
587 }
588 
589 /*!
590     \internal
591 
592     Allocates memory for \a nargs; code creating an event needs to initialize
593     the void* and int arrays by accessing \a args() and \a types(), respectively.
594  */
595 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO,
596                                const QObject *sender, int signalId,
597                                int nargs)
598     : QAbstractMetaCallEvent(sender, signalId),
599       d({slotO, nullptr, nullptr, nargs, 0, ushort(-1)}),
600       prealloc_()
601 {
602     if (d.slotObj_)
603         d.slotObj_->ref();
604     allocArgs();
605 }
606 
607 /*!
608     \internal
609  */
610 QMetaCallEvent::~QMetaCallEvent()
611 {
612     if (d.nargs_) {
613         QMetaType *t = types();
614         for (int i = 0; i < d.nargs_; ++i) {
615             if (t[i].isValid() && d.args_[i])
616                 t[i].destroy(d.args_[i]);
617         }
618         if (reinterpret_cast<void *>(d.args_) != reinterpret_cast<void *>(prealloc_))
619             free(d.args_);
620     }
621     if (d.slotObj_)
622         d.slotObj_->destroyIfLastRef();
623 }
624 
625 /*!
626     \internal
627  */
628 void QMetaCallEvent::placeMetaCall(QObject *object)
629 {
630     if (d.slotObj_) {
631         d.slotObj_->call(object, d.args_);
632     } else if (d.callFunction_ && d.method_offset_ <= object->metaObject()->methodOffset()) {
633         d.callFunction_(object, QMetaObject::InvokeMetaMethod, d.method_relative_, d.args_);
634     } else {
635         QMetaObject::metacall(object, QMetaObject::InvokeMetaMethod,
636                               d.method_offset_ + d.method_relative_, d.args_);
637     }
638 }
639 
640 /*!
641     \class QSignalBlocker
642     \brief Exception-safe wrapper around QObject::blockSignals().
643     \since 5.3
644     \ingroup objectmodel
645     \inmodule QtCore
646 
647     \reentrant
648 
649     QSignalBlocker can be used wherever you would otherwise use a
650     pair of calls to blockSignals(). It blocks signals in its
651     constructor and in the destructor it resets the state to what
652     it was before the constructor ran.
653 
654     \snippet code/src_corelib_kernel_qobject.cpp 53
655     is thus equivalent to
656     \snippet code/src_corelib_kernel_qobject.cpp 54
657 
658     except the code using QSignalBlocker is safe in the face of
659     exceptions.
660 
661     \sa QMutexLocker, QEventLoopLocker
662 */
663 
664 /*!
665     \fn QSignalBlocker::QSignalBlocker(QObject *object)
666 
667     Constructor. Calls \a{object}->blockSignals(true).
668 */
669 
670 /*!
671     \fn QSignalBlocker::QSignalBlocker(QObject &object)
672     \overload
673 
674     Calls \a{object}.blockSignals(true).
675 */
676 
677 /*!
678     \fn QSignalBlocker::QSignalBlocker(QSignalBlocker &&other)
679 
680     Move-constructs a signal blocker from \a other. \a other will have
681     a no-op destructor, while responsibility for restoring the
682     QObject::signalsBlocked() state is transferred to the new object.
683 */
684 
685 /*!
686     \fn QSignalBlocker &QSignalBlocker::operator=(QSignalBlocker &&other)
687 
688     Move-assigns this signal blocker from \a other. \a other will have
689     a no-op destructor, while responsibility for restoring the
690     QObject::signalsBlocked() state is transferred to this object.
691 
692     The object's signals this signal blocker was blocking prior to
693     being moved to, if any, are unblocked \e except in the case where
694     both instances block the same object's signals and \c *this is
695     unblocked while \a other is not, at the time of the move.
696 */
697 
698 /*!
699     \fn QSignalBlocker::~QSignalBlocker()
700 
701     Destructor. Restores the QObject::signalsBlocked() state to what it
702     was before the constructor ran, unless unblock() has been called
703     without a following reblock(), in which case it does nothing.
704 */
705 
706 /*!
707     \fn void QSignalBlocker::reblock()
708 
709     Re-blocks signals after a previous unblock().
710 
711     The numbers of reblock() and unblock() calls are not counted, so
712     every reblock() undoes any number of unblock() calls.
713 */
714 
715 /*!
716     \fn void QSignalBlocker::unblock()
717 
718     Temporarily restores the QObject::signalsBlocked() state to what
719     it was before this QSignalBlocker's constructor ran. To undo, use
720     reblock().
721 
722     The numbers of reblock() and unblock() calls are not counted, so
723     every unblock() undoes any number of reblock() calls.
724 */
725 
726 /*!
727     \class QObject
728     \inmodule QtCore
729     \brief The QObject class is the base class of all Qt objects.
730 
731     \ingroup objectmodel
732 
733     \reentrant
734 
735     QObject is the heart of the Qt \l{Object Model}. The central
736     feature in this model is a very powerful mechanism for seamless
737     object communication called \l{signals and slots}. You can
738     connect a signal to a slot with connect() and destroy the
739     connection with disconnect(). To avoid never ending notification
740     loops you can temporarily block signals with blockSignals(). The
741     protected functions connectNotify() and disconnectNotify() make
742     it possible to track connections.
743 
744     QObjects organize themselves in \l {Object Trees & Ownership}
745     {object trees}. When you create a QObject with another object as
746     parent, the object will automatically add itself to the parent's
747     children() list. The parent takes ownership of the object; i.e.,
748     it will automatically delete its children in its destructor. You
749     can look for an object by name and optionally type using
750     findChild() or findChildren().
751 
752     Every object has an objectName() and its class name can be found
753     via the corresponding metaObject() (see QMetaObject::className()).
754     You can determine whether the object's class inherits another
755     class in the QObject inheritance hierarchy by using the
756     inherits() function.
757 
758     When an object is deleted, it emits a destroyed() signal. You can
759     catch this signal to avoid dangling references to QObjects.
760 
761     QObjects can receive events through event() and filter the events
762     of other objects. See installEventFilter() and eventFilter() for
763     details. A convenience handler, childEvent(), can be reimplemented
764     to catch child events.
765 
766     Last but not least, QObject provides the basic timer support in
767     Qt; see QTimer for high-level support for timers.
768 
769     Notice that the Q_OBJECT macro is mandatory for any object that
770     implements signals, slots or properties. You also need to run the
771     \l{moc}{Meta Object Compiler} on the source file. We strongly
772     recommend the use of this macro in all subclasses of QObject
773     regardless of whether or not they actually use signals, slots and
774     properties, since failure to do so may lead certain functions to
775     exhibit strange behavior.
776 
777     All Qt widgets inherit QObject. The convenience function
778     isWidgetType() returns whether an object is actually a widget. It
779     is much faster than
780     \l{qobject_cast()}{qobject_cast}<QWidget *>(\e{obj}) or
781     \e{obj}->\l{inherits()}{inherits}("QWidget").
782 
783     Some QObject functions, e.g. children(), return a QObjectList.
784     QObjectList is a typedef for QList<QObject *>.
785 
786     \section1 Thread Affinity
787 
788     A QObject instance is said to have a \e{thread affinity}, or that
789     it \e{lives} in a certain thread. When a QObject receives a
790     \l{Qt::QueuedConnection}{queued signal} or a \l{The Event
791     System#Sending Events}{posted event}, the slot or event handler
792     will run in the thread that the object lives in.
793 
794     \note If a QObject has no thread affinity (that is, if thread()
795     returns zero), or if it lives in a thread that has no running event
796     loop, then it cannot receive queued signals or posted events.
797 
798     By default, a QObject lives in the thread in which it is created.
799     An object's thread affinity can be queried using thread() and
800     changed using moveToThread().
801 
802     All QObjects must live in the same thread as their parent. Consequently:
803 
804     \list
805     \li setParent() will fail if the two QObjects involved live in
806         different threads.
807     \li When a QObject is moved to another thread, all its children
808         will be automatically moved too.
809     \li moveToThread() will fail if the QObject has a parent.
810     \li If QObjects are created within QThread::run(), they cannot
811         become children of the QThread object because the QThread does
812         not live in the thread that calls QThread::run().
813     \endlist
814 
815     \note A QObject's member variables \e{do not} automatically become
816     its children. The parent-child relationship must be set by either
817     passing a pointer to the child's \l{QObject()}{constructor}, or by
818     calling setParent(). Without this step, the object's member variables
819     will remain in the old thread when moveToThread() is called.
820 
821     \target No copy constructor
822     \section1 No Copy Constructor or Assignment Operator
823 
824     QObject has neither a copy constructor nor an assignment operator.
825     This is by design. Actually, they are declared, but in a
826     \c{private} section with the macro Q_DISABLE_COPY(). In fact, all
827     Qt classes derived from QObject (direct or indirect) use this
828     macro to declare their copy constructor and assignment operator to
829     be private. The reasoning is found in the discussion on
830     \l{Identity vs Value} {Identity vs Value} on the Qt \l{Object
831     Model} page.
832 
833     The main consequence is that you should use pointers to QObject
834     (or to your QObject subclass) where you might otherwise be tempted
835     to use your QObject subclass as a value. For example, without a
836     copy constructor, you can't use a subclass of QObject as the value
837     to be stored in one of the container classes. You must store
838     pointers.
839 
840     \section1 Auto-Connection
841 
842     Qt's meta-object system provides a mechanism to automatically connect
843     signals and slots between QObject subclasses and their children. As long
844     as objects are defined with suitable object names, and slots follow a
845     simple naming convention, this connection can be performed at run-time
846     by the QMetaObject::connectSlotsByName() function.
847 
848     \l uic generates code that invokes this function to enable
849     auto-connection to be performed between widgets on forms created
850     with \e{Qt Designer}. More information about using auto-connection with \e{Qt Designer} is
851     given in the \l{Using a Designer UI File in Your Application} section of
852     the \e{Qt Designer} manual.
853 
854     \section1 Dynamic Properties
855 
856     From Qt 4.2, dynamic properties can be added to and removed from QObject
857     instances at run-time. Dynamic properties do not need to be declared at
858     compile-time, yet they provide the same advantages as static properties
859     and are manipulated using the same API - using property() to read them
860     and setProperty() to write them.
861 
862     From Qt 4.3, dynamic properties are supported by
863     \l{Qt Designer's Widget Editing Mode#The Property Editor}{Qt Designer},
864     and both standard Qt widgets and user-created forms can be given dynamic
865     properties.
866 
867     \section1 Internationalization (I18n)
868 
869     All QObject subclasses support Qt's translation features, making it possible
870     to translate an application's user interface into different languages.
871 
872     To make user-visible text translatable, it must be wrapped in calls to
873     the tr() function. This is explained in detail in the
874     \l{Writing Source Code for Translation} document.
875 
876     \sa QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY()
877     \sa {Object Trees & Ownership}
878 */
879 
880 /*****************************************************************************
881   QObject member functions
882  *****************************************************************************/
883 
884 // check the constructor's parent thread argument
885 static bool check_parent_thread(QObject *parent,
886                                 QThreadData *parentThreadData,
887                                 QThreadData *currentThreadData)
888 {
889     if (parent && parentThreadData != currentThreadData) {
890         QThread *parentThread = parentThreadData->thread.loadAcquire();
891         QThread *currentThread = currentThreadData->thread.loadAcquire();
892         qWarning("QObject: Cannot create children for a parent that is in a different thread.\n"
893                  "(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)",
894                  parent->metaObject()->className(),
895                  parent,
896                  parentThread ? parentThread->metaObject()->className() : "QThread",
897                  parentThread,
898                  currentThread ? currentThread->metaObject()->className() : "QThread",
899                  currentThread);
900         return false;
901     }
902     return true;
903 }
904 
905 /*!
906     Constructs an object with parent object \a parent.
907 
908     The parent of an object may be viewed as the object's owner. For
909     instance, a \l{QDialog}{dialog box} is the parent of the \uicontrol{OK}
910     and \uicontrol{Cancel} buttons it contains.
911 
912     The destructor of a parent object destroys all child objects.
913 
914     Setting \a parent to \nullptr constructs an object with no parent. If the
915     object is a widget, it will become a top-level window.
916 
917     \sa parent(), findChild(), findChildren()
918 */
919 
920 QObject::QObject(QObject *parent)
921     : QObject(*new QObjectPrivate, parent)
922 {
923 }
924 
925 /*!
926     \internal
927  */
928 QObject::QObject(QObjectPrivate &dd, QObject *parent)
929     : d_ptr(&dd)
930 {
931     Q_ASSERT_X(this != parent, Q_FUNC_INFO, "Cannot parent a QObject to itself");
932 
933     Q_D(QObject);
934     d_ptr->q_ptr = this;
935     auto threadData = (parent && !parent->thread()) ? parent->d_func()->threadData.loadRelaxed() : QThreadData::current();
936     threadData->ref();
937     d->threadData.storeRelaxed(threadData);
938     if (parent) {
939         QT_TRY {
940             if (!check_parent_thread(parent, parent ? parent->d_func()->threadData.loadRelaxed() : nullptr, threadData))
941                 parent = nullptr;
942             if (d->isWidget) {
943                 if (parent) {
944                     d->parent = parent;
945                     d->parent->d_func()->children.append(this);
946                 }
947                 // no events sent here, this is done at the end of the QWidget constructor
948             } else {
949                 setParent(parent);
950             }
951         } QT_CATCH(...) {
952             threadData->deref();
953             QT_RETHROW;
954         }
955     }
956 #if QT_VERSION < 0x60000
957     qt_addObject(this);
958 #endif
959     if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
960         reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
961     Q_TRACE(QObject_ctor, this);
962 }
963 
964 void QObjectPrivate::clearBindingStorage()
965 {
966     bindingStorage.clear();
967 }
968 
969 /*!
970     Destroys the object, deleting all its child objects.
971 
972     All signals to and from the object are automatically disconnected, and
973     any pending posted events for the object are removed from the event
974     queue. However, it is often safer to use deleteLater() rather than
975     deleting a QObject subclass directly.
976 
977     \warning All child objects are deleted. If any of these objects
978     are on the stack or global, sooner or later your program will
979     crash. We do not recommend holding pointers to child objects from
980     outside the parent. If you still do, the destroyed() signal gives
981     you an opportunity to detect when an object is destroyed.
982 
983     \warning Deleting a QObject while pending events are waiting to
984     be delivered can cause a crash. You must not delete the QObject
985     directly if it exists in a different thread than the one currently
986     executing. Use deleteLater() instead, which will cause the event
987     loop to delete the object after all pending events have been
988     delivered to it.
989 
990     \sa deleteLater()
991 */
992 
993 QObject::~QObject()
994 {
995     Q_D(QObject);
996     d->wasDeleted = true;
997     d->blockSig = 0; // unblock signals so we always emit destroyed()
998 
999     // If we reached this point, we need to clear the binding data
1000     // as the corresponding properties are no longer useful
1001     d->clearBindingStorage();
1002 
1003     QtSharedPointer::ExternalRefCountData *sharedRefcount = d->sharedRefcount.loadRelaxed();
1004     if (sharedRefcount) {
1005         if (sharedRefcount->strongref.loadRelaxed() > 0) {
1006             qWarning("QObject: shared QObject was deleted directly. The program is malformed and may crash.");
1007             // but continue deleting, it's too late to stop anyway
1008         }
1009 
1010         // indicate to all QWeakPointers that this QObject has now been deleted
1011         sharedRefcount->strongref.storeRelaxed(0);
1012         if (!sharedRefcount->weakref.deref())
1013             delete sharedRefcount;
1014     }
1015 
1016     if (!d->isWidget && d->isSignalConnected(0)) {
1017         emit destroyed(this);
1018     }
1019 
1020     if (d->declarativeData && QAbstractDeclarativeData::destroyed)
1021         QAbstractDeclarativeData::destroyed(d->declarativeData, this);
1022 
1023     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
1024     if (cd) {
1025         if (cd->currentSender) {
1026             cd->currentSender->receiverDeleted();
1027             cd->currentSender = nullptr;
1028         }
1029 
1030         QBasicMutex *signalSlotMutex = signalSlotLock(this);
1031         QBasicMutexLocker locker(signalSlotMutex);
1032 
1033         // disconnect all receivers
1034         int receiverCount = cd->signalVectorCount();
1035         for (int signal = -1; signal < receiverCount; ++signal) {
1036             QObjectPrivate::ConnectionList &connectionList = cd->connectionsForSignal(signal);
1037 
1038             while (QObjectPrivate::Connection *c = connectionList.first.loadRelaxed()) {
1039                 Q_ASSERT(c->receiver.loadAcquire());
1040 
1041                 QBasicMutex *m = signalSlotLock(c->receiver.loadRelaxed());
1042                 bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
1043                 if (c == connectionList.first.loadAcquire() && c->receiver.loadAcquire()) {
1044                     cd->removeConnection(c);
1045                     Q_ASSERT(connectionList.first.loadRelaxed() != c);
1046                 }
1047                 if (needToUnlock)
1048                     m->unlock();
1049             }
1050         }
1051 
1052         /* Disconnect all senders:
1053          */
1054         while (QObjectPrivate::Connection *node = cd->senders) {
1055             Q_ASSERT(node->receiver.loadAcquire());
1056             QObject *sender = node->sender;
1057             // Send disconnectNotify before removing the connection from sender's connection list.
1058             // This ensures any eventual destructor of sender will block on getting receiver's lock
1059             // and not finish until we release it.
1060             sender->disconnectNotify(QMetaObjectPrivate::signal(sender->metaObject(), node->signal_index));
1061             QBasicMutex *m = signalSlotLock(sender);
1062             bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
1063             //the node has maybe been removed while the mutex was unlocked in relock?
1064             if (node != cd->senders) {
1065                 // We hold the wrong mutex
1066                 Q_ASSERT(needToUnlock);
1067                 m->unlock();
1068                 continue;
1069             }
1070 
1071             QObjectPrivate::ConnectionData *senderData = sender->d_func()->connections.loadRelaxed();
1072             Q_ASSERT(senderData);
1073 
1074             QtPrivate::QSlotObjectBase *slotObj = nullptr;
1075             if (node->isSlotObject) {
1076                 slotObj = node->slotObj;
1077                 node->isSlotObject = false;
1078             }
1079 
1080             senderData->removeConnection(node);
1081             /*
1082               When we unlock, another thread has the chance to delete/modify sender data.
1083               Thus we need to call cleanOrphanedConnections before unlocking. We use the
1084               variant of the function which assumes that the lock is already held to avoid
1085               a deadlock.
1086               We need to hold m, the sender lock. Considering that we might execute arbitrary user
1087               code, we should already release the signalSlotMutex here â€“ unless they are the same.
1088             */
1089             const bool locksAreTheSame = signalSlotMutex == m;
1090             if (!locksAreTheSame)
1091                 locker.unlock();
1092             senderData->cleanOrphanedConnections(
1093                         sender,
1094                         QObjectPrivate::ConnectionData::AlreadyLockedAndTemporarilyReleasingLock
1095                         );
1096             if (needToUnlock)
1097                 m->unlock();
1098 
1099             if (locksAreTheSame) // otherwise already unlocked
1100                 locker.unlock();
1101             if (slotObj)
1102                 slotObj->destroyIfLastRef();
1103             locker.relock();
1104         }
1105 
1106         // invalidate all connections on the object and make sure
1107         // activate() will skip them
1108         cd->currentConnectionId.storeRelaxed(0);
1109     }
1110     if (cd && !cd->ref.deref())
1111         delete cd;
1112     d->connections.storeRelaxed(nullptr);
1113 
1114     if (!d->children.isEmpty())
1115         d->deleteChildren();
1116 
1117 #if QT_VERSION < 0x60000
1118     qt_removeObject(this);
1119 #endif
1120     if (Q_UNLIKELY(qtHookData[QHooks::RemoveQObject]))
1121         reinterpret_cast<QHooks::RemoveQObjectCallback>(qtHookData[QHooks::RemoveQObject])(this);
1122 
1123     Q_TRACE(QObject_dtor, this);
1124 
1125     if (d->parent)        // remove it from parent object
1126         d->setParent_helper(nullptr);
1127 }
1128 
1129 QObjectPrivate::Connection::~Connection()
1130 {
1131     if (ownArgumentTypes) {
1132         const int *v = argumentTypes.loadRelaxed();
1133         if (v != &DIRECT_CONNECTION_ONLY)
1134             delete[] v;
1135     }
1136     if (isSlotObject)
1137         slotObj->destroyIfLastRef();
1138 }
1139 
1140 
1141 /*!
1142     \fn const QMetaObject *QObject::metaObject() const
1143 
1144     Returns a pointer to the meta-object of this object.
1145 
1146     A meta-object contains information about a class that inherits
1147     QObject, e.g. class name, superclass name, properties, signals and
1148     slots. Every QObject subclass that contains the Q_OBJECT macro will have a
1149     meta-object.
1150 
1151     The meta-object information is required by the signal/slot
1152     connection mechanism and the property system. The inherits()
1153     function also makes use of the meta-object.
1154 
1155     If you have no pointer to an actual object instance but still
1156     want to access the meta-object of a class, you can use \l
1157     staticMetaObject.
1158 
1159     Example:
1160 
1161     \snippet code/src_corelib_kernel_qobject.cpp 1
1162 
1163     \sa staticMetaObject
1164 */
1165 
1166 /*!
1167     \variable QObject::staticMetaObject
1168 
1169     This variable stores the meta-object for the class.
1170 
1171     A meta-object contains information about a class that inherits
1172     QObject, e.g. class name, superclass name, properties, signals and
1173     slots. Every class that contains the Q_OBJECT macro will also have
1174     a meta-object.
1175 
1176     The meta-object information is required by the signal/slot
1177     connection mechanism and the property system. The inherits()
1178     function also makes use of the meta-object.
1179 
1180     If you have a pointer to an object, you can use metaObject() to
1181     retrieve the meta-object associated with that object.
1182 
1183     Example:
1184 
1185     \snippet code/src_corelib_kernel_qobject.cpp 2
1186 
1187     \sa metaObject()
1188 */
1189 
1190 /*!
1191     \fn template <class T> T qobject_cast(QObject *object)
1192     \fn template <class T> T qobject_cast(const QObject *object)
1193     \relates QObject
1194 
1195     Returns the given \a object cast to type T if the object is of type
1196     T (or of a subclass); otherwise returns \nullptr. If \a object is
1197     \nullptr then it will also return \nullptr.
1198 
1199     The class T must inherit (directly or indirectly) QObject and be
1200     declared with the \l Q_OBJECT macro.
1201 
1202     A class is considered to inherit itself.
1203 
1204     Example:
1205 
1206     \snippet code/src_corelib_kernel_qobject.cpp 3
1207 
1208     The qobject_cast() function behaves similarly to the standard C++
1209     \c dynamic_cast(), with the advantages that it doesn't require
1210     RTTI support and it works across dynamic library boundaries.
1211 
1212     qobject_cast() can also be used in conjunction with interfaces;
1213     see the \l{tools/plugandpaint/app}{Plug & Paint} example for details.
1214 
1215     \warning If T isn't declared with the Q_OBJECT macro, this
1216     function's return value is undefined.
1217 
1218     \sa QObject::inherits()
1219 */
1220 
1221 /*!
1222     \fn bool QObject::inherits(const char *className) const
1223 
1224     Returns \c true if this object is an instance of a class that
1225     inherits \a className or a QObject subclass that inherits \a
1226     className; otherwise returns \c false.
1227 
1228     A class is considered to inherit itself.
1229 
1230     Example:
1231 
1232     \snippet code/src_corelib_kernel_qobject.cpp 4
1233 
1234     If you need to determine whether an object is an instance of a particular
1235     class for the purpose of casting it, consider using qobject_cast<Type *>(object)
1236     instead.
1237 
1238     \sa metaObject(), qobject_cast()
1239 */
1240 
1241 /*!
1242     \property QObject::objectName
1243 
1244     \brief the name of this object
1245 
1246     You can find an object by name (and type) using findChild().
1247     You can find a set of objects with findChildren().
1248 
1249     \snippet code/src_corelib_kernel_qobject.cpp 5
1250 
1251     By default, this property contains an empty string.
1252 
1253     \sa metaObject(), QMetaObject::className()
1254 */
1255 
1256 QString QObject::objectName() const
1257 {
1258     Q_D(const QObject);
1259     if (!d->extraData && QtPrivate::isAnyBindingEvaluating()) {
1260         QObjectPrivate *dd = const_cast<QObjectPrivate *>(d);
1261         // extraData is mutable, so this should be safe
1262         dd->extraData = new QObjectPrivate::ExtraData(dd);
1263     }
1264     return d->extraData ? d->extraData->objectName : QString();
1265 }
1266 
1267 /*
1268     Sets the object's name to \a name.
1269 */
1270 void QObject::setObjectName(const QString &name)
1271 {
1272     Q_D(QObject);
1273 
1274     if (!d->extraData)
1275         d->extraData = new QObjectPrivate::ExtraData(d);
1276 
1277     d->extraData->objectName.removeBindingUnlessInWrapper();
1278 
1279     if (d->extraData->objectName != name) {
1280         d->extraData->objectName.setValueBypassingBindings(name);
1281         d->extraData->objectName.notify(); // also emits a signal
1282     }
1283 }
1284 
1285 QBindable<QString> QObject::bindableObjectName()
1286 {
1287     Q_D(QObject);
1288 
1289     if (!d->extraData)
1290         d->extraData = new QObjectPrivate::ExtraData(d);
1291 
1292     return QBindable<QString>(&d->extraData->objectName);
1293 }
1294 
1295 /*! \fn void QObject::objectNameChanged(const QString &objectName)
1296 
1297     This signal is emitted after the object's name has been changed. The new object name is passed as \a objectName.
1298 
1299     \sa QObject::objectName
1300 */
1301 
1302 /*!
1303     \fn bool QObject::isWidgetType() const
1304 
1305     Returns \c true if the object is a widget; otherwise returns \c false.
1306 
1307     Calling this function is equivalent to calling
1308     \c{inherits("QWidget")}, except that it is much faster.
1309 */
1310 
1311 /*!
1312     \fn bool QObject::isWindowType() const
1313 
1314     Returns \c true if the object is a window; otherwise returns \c false.
1315 
1316     Calling this function is equivalent to calling
1317     \c{inherits("QWindow")}, except that it is much faster.
1318 */
1319 
1320 /*!
1321     This virtual function receives events to an object and should
1322     return true if the event \a e was recognized and processed.
1323 
1324     The event() function can be reimplemented to customize the
1325     behavior of an object.
1326 
1327     Make sure you call the parent event class implementation
1328     for all the events you did not handle.
1329 
1330     Example:
1331 
1332     \snippet code/src_corelib_kernel_qobject.cpp 52
1333 
1334     \sa installEventFilter(), timerEvent(), QCoreApplication::sendEvent(),
1335     QCoreApplication::postEvent()
1336 */
1337 
1338 bool QObject::event(QEvent *e)
1339 {
1340     switch (e->type()) {
1341     case QEvent::Timer:
1342         timerEvent((QTimerEvent *)e);
1343         break;
1344 
1345     case QEvent::ChildAdded:
1346     case QEvent::ChildPolished:
1347     case QEvent::ChildRemoved:
1348         childEvent((QChildEvent *)e);
1349         break;
1350 
1351     case QEvent::DeferredDelete:
1352         qDeleteInEventHandler(this);
1353         break;
1354 
1355     case QEvent::MetaCall:
1356         {
1357             QAbstractMetaCallEvent *mce = static_cast<QAbstractMetaCallEvent*>(e);
1358 
1359             if (!d_func()->connections.loadRelaxed()) {
1360                 QBasicMutexLocker locker(signalSlotLock(this));
1361                 d_func()->ensureConnectionData();
1362             }
1363             QObjectPrivate::Sender sender(this, const_cast<QObject*>(mce->sender()), mce->signalId());
1364 
1365             mce->placeMetaCall(this);
1366             break;
1367         }
1368 
1369     case QEvent::ThreadChange: {
1370         Q_D(QObject);
1371         QThreadData *threadData = d->threadData.loadRelaxed();
1372         QAbstractEventDispatcher *eventDispatcher = threadData->eventDispatcher.loadRelaxed();
1373         if (eventDispatcher) {
1374             QList<QAbstractEventDispatcher::TimerInfo> timers = eventDispatcher->registeredTimers(this);
1375             if (!timers.isEmpty()) {
1376                 // do not to release our timer ids back to the pool (since the timer ids are moving to a new thread).
1377                 eventDispatcher->unregisterTimers(this);
1378                 QMetaObject::invokeMethod(this, "_q_reregisterTimers", Qt::QueuedConnection,
1379                                           Q_ARG(void*, (new QList<QAbstractEventDispatcher::TimerInfo>(timers))));
1380             }
1381         }
1382         break;
1383     }
1384 
1385     default:
1386         if (e->type() >= QEvent::User) {
1387             customEvent(e);
1388             break;
1389         }
1390         return false;
1391     }
1392     return true;
1393 }
1394 
1395 /*!
1396     \fn void QObject::timerEvent(QTimerEvent *event)
1397 
1398     This event handler can be reimplemented in a subclass to receive
1399     timer events for the object.
1400 
1401     QTimer provides a higher-level interface to the timer
1402     functionality, and also more general information about timers. The
1403     timer event is passed in the \a event parameter.
1404 
1405     \sa startTimer(), killTimer(), event()
1406 */
1407 
1408 void QObject::timerEvent(QTimerEvent *)
1409 {
1410 }
1411 
1412 
1413 /*!
1414     This event handler can be reimplemented in a subclass to receive
1415     child events. The event is passed in the \a event parameter.
1416 
1417     QEvent::ChildAdded and QEvent::ChildRemoved events are sent to
1418     objects when children are added or removed. In both cases you can
1419     only rely on the child being a QObject, or if isWidgetType()
1420     returns \c true, a QWidget. (This is because, in the
1421     \l{QEvent::ChildAdded}{ChildAdded} case, the child is not yet
1422     fully constructed, and in the \l{QEvent::ChildRemoved}{ChildRemoved}
1423     case it might have been destructed already).
1424 
1425     QEvent::ChildPolished events are sent to widgets when children
1426     are polished, or when polished children are added. If you receive
1427     a child polished event, the child's construction is usually
1428     completed. However, this is not guaranteed, and multiple polish
1429     events may be delivered during the execution of a widget's
1430     constructor.
1431 
1432     For every child widget, you receive one
1433     \l{QEvent::ChildAdded}{ChildAdded} event, zero or more
1434     \l{QEvent::ChildPolished}{ChildPolished} events, and one
1435     \l{QEvent::ChildRemoved}{ChildRemoved} event.
1436 
1437     The \l{QEvent::ChildPolished}{ChildPolished} event is omitted if
1438     a child is removed immediately after it is added. If a child is
1439     polished several times during construction and destruction, you
1440     may receive several child polished events for the same child,
1441     each time with a different virtual table.
1442 
1443     \sa event()
1444 */
1445 
1446 void QObject::childEvent(QChildEvent * /* event */)
1447 {
1448 }
1449 
1450 
1451 /*!
1452     This event handler can be reimplemented in a subclass to receive
1453     custom events. Custom events are user-defined events with a type
1454     value at least as large as the QEvent::User item of the
1455     QEvent::Type enum, and is typically a QEvent subclass. The event
1456     is passed in the \a event parameter.
1457 
1458     \sa event(), QEvent
1459 */
1460 void QObject::customEvent(QEvent * /* event */)
1461 {
1462 }
1463 
1464 
1465 
1466 /*!
1467     Filters events if this object has been installed as an event
1468     filter for the \a watched object.
1469 
1470     In your reimplementation of this function, if you want to filter
1471     the \a event out, i.e. stop it being handled further, return
1472     true; otherwise return false.
1473 
1474     Example:
1475     \snippet code/src_corelib_kernel_qobject.cpp 6
1476 
1477     Notice in the example above that unhandled events are passed to
1478     the base class's eventFilter() function, since the base class
1479     might have reimplemented eventFilter() for its own internal
1480     purposes.
1481 
1482     Some events, such as \l QEvent::ShortcutOverride must be explicitly
1483     accepted (by calling \l {QEvent::}{accept()} on them) in order to prevent
1484     propagation.
1485 
1486     \warning If you delete the receiver object in this function, be
1487     sure to return true. Otherwise, Qt will forward the event to the
1488     deleted object and the program might crash.
1489 
1490     \sa installEventFilter()
1491 */
1492 
1493 bool QObject::eventFilter(QObject * /* watched */, QEvent * /* event */)
1494 {
1495     return false;
1496 }
1497 
1498 /*!
1499     \fn bool QObject::signalsBlocked() const
1500 
1501     Returns \c true if signals are blocked; otherwise returns \c false.
1502 
1503     Signals are not blocked by default.
1504 
1505     \sa blockSignals(), QSignalBlocker
1506 */
1507 
1508 /*!
1509     If \a block is true, signals emitted by this object are blocked
1510     (i.e., emitting a signal will not invoke anything connected to it).
1511     If \a block is false, no such blocking will occur.
1512 
1513     The return value is the previous value of signalsBlocked().
1514 
1515     Note that the destroyed() signal will be emitted even if the signals
1516     for this object have been blocked.
1517 
1518     Signals emitted while being blocked are not buffered.
1519 
1520     \sa signalsBlocked(), QSignalBlocker
1521 */
1522 
1523 bool QObject::blockSignals(bool block) noexcept
1524 {
1525     Q_D(QObject);
1526     bool previous = d->blockSig;
1527     d->blockSig = block;
1528     return previous;
1529 }
1530 
1531 /*!
1532     Returns the thread in which the object lives.
1533 
1534     \sa moveToThread()
1535 */
1536 QThread *QObject::thread() const
1537 {
1538     return d_func()->threadData.loadRelaxed()->thread.loadAcquire();
1539 }
1540 
1541 /*!
1542     Changes the thread affinity for this object and its children. The
1543     object cannot be moved if it has a parent. Event processing will
1544     continue in the \a targetThread.
1545 
1546     To move an object to the main thread, use QApplication::instance()
1547     to retrieve a pointer to the current application, and then use
1548     QApplication::thread() to retrieve the thread in which the
1549     application lives. For example:
1550 
1551     \snippet code/src_corelib_kernel_qobject.cpp 7
1552 
1553     If \a targetThread is \nullptr, all event processing for this object
1554     and its children stops, as they are no longer associated with any
1555     thread.
1556 
1557     Note that all active timers for the object will be reset. The
1558     timers are first stopped in the current thread and restarted (with
1559     the same interval) in the \a targetThread. As a result, constantly
1560     moving an object between threads can postpone timer events
1561     indefinitely.
1562 
1563     A QEvent::ThreadChange event is sent to this object just before
1564     the thread affinity is changed. You can handle this event to
1565     perform any special processing. Note that any new events that are
1566     posted to this object will be handled in the \a targetThread,
1567     provided it is not \nullptr: when it is \nullptr, no event processing
1568     for this object or its children can happen, as they are no longer
1569     associated with any thread.
1570 
1571     \warning This function is \e not thread-safe; the current thread
1572     must be same as the current thread affinity. In other words, this
1573     function can only "push" an object from the current thread to
1574     another thread, it cannot "pull" an object from any arbitrary
1575     thread to the current thread. There is one exception to this rule
1576     however: objects with no thread affinity can be "pulled" to the
1577     current thread.
1578 
1579     \sa thread()
1580  */
1581 void QObject::moveToThread(QThread *targetThread)
1582 {
1583     Q_D(QObject);
1584 
1585     if (d->threadData.loadRelaxed()->thread.loadAcquire() == targetThread) {
1586         // object is already in this thread
1587         return;
1588     }
1589 
1590     if (d->parent != nullptr) {
1591         qWarning("QObject::moveToThread: Cannot move objects with a parent");
1592         return;
1593     }
1594     if (d->isWidget) {
1595         qWarning("QObject::moveToThread: Widgets cannot be moved to a new thread");
1596         return;
1597     }
1598     if (!d->bindingStorage.isEmpty()) {
1599         qWarning("QObject::moveToThread: Can not move objects that contain bindings or are used in bindings to a new thread.");
1600         return;
1601     }
1602 
1603     QThreadData *currentData = QThreadData::current();
1604     QThreadData *targetData = targetThread ? QThreadData::get2(targetThread) : nullptr;
1605     QThreadData *thisThreadData = d->threadData.loadRelaxed();
1606     if (!thisThreadData->thread.loadAcquire() && currentData == targetData) {
1607         // one exception to the rule: we allow moving objects with no thread affinity to the current thread
1608         currentData = d->threadData;
1609     } else if (thisThreadData != currentData) {
1610         qWarning("QObject::moveToThread: Current thread (%p) is not the object's thread (%p).\n"
1611                  "Cannot move to target thread (%p)\n",
1612                  currentData->thread.loadRelaxed(), thisThreadData->thread.loadRelaxed(), targetData ? targetData->thread.loadRelaxed() : nullptr);
1613 
1614 #ifdef Q_OS_MAC
1615         qWarning("You might be loading two sets of Qt binaries into the same process. "
1616                  "Check that all plugins are compiled against the right Qt binaries. Export "
1617                  "DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.");
1618 #endif
1619 
1620         return;
1621     }
1622 
1623     // prepare to move
1624     d->moveToThread_helper();
1625 
1626     if (!targetData)
1627         targetData = new QThreadData(0);
1628 
1629     // make sure nobody adds/removes connections to this object while we're moving it
1630     QMutexLocker l(signalSlotLock(this));
1631 
1632     QOrderedMutexLocker locker(&currentData->postEventList.mutex,
1633                                &targetData->postEventList.mutex);
1634 
1635     // keep currentData alive (since we've got it locked)
1636     currentData->ref();
1637 
1638     // move the object
1639     d_func()->setThreadData_helper(currentData, targetData);
1640 
1641     locker.unlock();
1642 
1643     // now currentData can commit suicide if it wants to
1644     currentData->deref();
1645 }
1646 
1647 void QObjectPrivate::moveToThread_helper()
1648 {
1649     Q_Q(QObject);
1650     QEvent e(QEvent::ThreadChange);
1651     QCoreApplication::sendEvent(q, &e);
1652     for (int i = 0; i < children.size(); ++i) {
1653         QObject *child = children.at(i);
1654         child->d_func()->moveToThread_helper();
1655     }
1656 }
1657 
1658 void QObjectPrivate::setThreadData_helper(QThreadData *currentData, QThreadData *targetData)
1659 {
1660     Q_Q(QObject);
1661 
1662     // move posted events
1663     int eventsMoved = 0;
1664     for (int i = 0; i < currentData->postEventList.size(); ++i) {
1665         const QPostEvent &pe = currentData->postEventList.at(i);
1666         if (!pe.event)
1667             continue;
1668         if (pe.receiver == q) {
1669             // move this post event to the targetList
1670             targetData->postEventList.addEvent(pe);
1671             const_cast<QPostEvent &>(pe).event = nullptr;
1672             ++eventsMoved;
1673         }
1674     }
1675     if (eventsMoved > 0 && targetData->hasEventDispatcher()) {
1676         targetData->canWait = false;
1677         targetData->eventDispatcher.loadRelaxed()->wakeUp();
1678     }
1679 
1680     // the current emitting thread shouldn't restore currentSender after calling moveToThread()
1681     ConnectionData *cd = connections.loadRelaxed();
1682     if (cd) {
1683         if (cd->currentSender) {
1684             cd->currentSender->receiverDeleted();
1685             cd->currentSender = nullptr;
1686         }
1687 
1688         // adjust the receiverThreadId values in the Connections
1689         if (cd) {
1690             auto *c = cd->senders;
1691             while (c) {
1692                 QObject *r = c->receiver.loadRelaxed();
1693                 if (r) {
1694                     Q_ASSERT(r == q);
1695                     targetData->ref();
1696                     QThreadData *old = c->receiverThreadData.loadRelaxed();
1697                     if (old)
1698                         old->deref();
1699                     c->receiverThreadData.storeRelaxed(targetData);
1700                 }
1701                 c = c->next;
1702             }
1703         }
1704 
1705     }
1706 
1707     // set new thread data
1708     targetData->ref();
1709     threadData.loadRelaxed()->deref();
1710 
1711     // synchronizes with loadAcquire e.g. in QCoreApplication::postEvent
1712     threadData.storeRelease(targetData);
1713 
1714     for (int i = 0; i < children.size(); ++i) {
1715         QObject *child = children.at(i);
1716         child->d_func()->setThreadData_helper(currentData, targetData);
1717     }
1718 }
1719 
1720 void QObjectPrivate::_q_reregisterTimers(void *pointer)
1721 {
1722     Q_Q(QObject);
1723     QList<QAbstractEventDispatcher::TimerInfo> *timerList = reinterpret_cast<QList<QAbstractEventDispatcher::TimerInfo> *>(pointer);
1724     QAbstractEventDispatcher *eventDispatcher = threadData.loadRelaxed()->eventDispatcher.loadRelaxed();
1725     for (int i = 0; i < timerList->size(); ++i) {
1726         const QAbstractEventDispatcher::TimerInfo &ti = timerList->at(i);
1727         eventDispatcher->registerTimer(ti.timerId, ti.interval, ti.timerType, q);
1728     }
1729     delete timerList;
1730 }
1731 
1732 
1733 //
1734 // The timer flag hasTimer is set when startTimer is called.
1735 // It is not reset when killing the timer because more than
1736 // one timer might be active.
1737 //
1738 
1739 /*!
1740     Starts a timer and returns a timer identifier, or returns zero if
1741     it could not start a timer.
1742 
1743     A timer event will occur every \a interval milliseconds until
1744     killTimer() is called. If \a interval is 0, then the timer event
1745     occurs once every time there are no more window system events to
1746     process.
1747 
1748     The virtual timerEvent() function is called with the QTimerEvent
1749     event parameter class when a timer event occurs. Reimplement this
1750     function to get timer events.
1751 
1752     If multiple timers are running, the QTimerEvent::timerId() can be
1753     used to find out which timer was activated.
1754 
1755     Example:
1756 
1757     \snippet code/src_corelib_kernel_qobject.cpp 8
1758 
1759     Note that QTimer's accuracy depends on the underlying operating system and
1760     hardware. The \a timerType argument allows you to customize the accuracy of
1761     the timer. See Qt::TimerType for information on the different timer types.
1762     Most platforms support an accuracy of 20 milliseconds; some provide more.
1763     If Qt is unable to deliver the requested number of timer events, it will
1764     silently discard some.
1765 
1766     The QTimer class provides a high-level programming interface with
1767     single-shot timers and timer signals instead of events. There is
1768     also a QBasicTimer class that is more lightweight than QTimer and
1769     less clumsy than using timer IDs directly.
1770 
1771     \sa timerEvent(), killTimer(), QTimer::singleShot()
1772 */
1773 
1774 int QObject::startTimer(int interval, Qt::TimerType timerType)
1775 {
1776     Q_D(QObject);
1777 
1778     if (Q_UNLIKELY(interval < 0)) {
1779         qWarning("QObject::startTimer: Timers cannot have negative intervals");
1780         return 0;
1781     }
1782 
1783     auto thisThreadData = d->threadData.loadRelaxed();
1784     if (Q_UNLIKELY(!thisThreadData->hasEventDispatcher())) {
1785         qWarning("QObject::startTimer: Timers can only be used with threads started with QThread");
1786         return 0;
1787     }
1788     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1789         qWarning("QObject::startTimer: Timers cannot be started from another thread");
1790         return 0;
1791     }
1792     int timerId = thisThreadData->eventDispatcher.loadRelaxed()->registerTimer(interval, timerType, this);
1793     if (!d->extraData)
1794         d->extraData = new QObjectPrivate::ExtraData(d);
1795     d->extraData->runningTimers.append(timerId);
1796     return timerId;
1797 }
1798 
1799 /*!
1800     \since 5.9
1801     \overload
1802     \fn int QObject::startTimer(std::chrono::milliseconds time, Qt::TimerType timerType)
1803 
1804     Starts a timer and returns a timer identifier, or returns zero if
1805     it could not start a timer.
1806 
1807     A timer event will occur every \a time interval until killTimer()
1808     is called. If \a time is equal to \c{std::chrono::duration::zero()},
1809     then the timer event occurs once every time there are no more window
1810     system events to process.
1811 
1812     The virtual timerEvent() function is called with the QTimerEvent
1813     event parameter class when a timer event occurs. Reimplement this
1814     function to get timer events.
1815 
1816     If multiple timers are running, the QTimerEvent::timerId() can be
1817     used to find out which timer was activated.
1818 
1819     Example:
1820 
1821     \snippet code/src_corelib_kernel_qobject.cpp 8
1822 
1823     Note that QTimer's accuracy depends on the underlying operating system and
1824     hardware. The \a timerType argument allows you to customize the accuracy of
1825     the timer. See Qt::TimerType for information on the different timer types.
1826     Most platforms support an accuracy of 20 milliseconds; some provide more.
1827     If Qt is unable to deliver the requested number of timer events, it will
1828     silently discard some.
1829 
1830     The QTimer class provides a high-level programming interface with
1831     single-shot timers and timer signals instead of events. There is
1832     also a QBasicTimer class that is more lightweight than QTimer and
1833     less clumsy than using timer IDs directly.
1834 
1835     \sa timerEvent(), killTimer(), QTimer::singleShot()
1836 */
1837 
1838 /*!
1839     Kills the timer with timer identifier, \a id.
1840 
1841     The timer identifier is returned by startTimer() when a timer
1842     event is started.
1843 
1844     \sa timerEvent(), startTimer()
1845 */
1846 
1847 void QObject::killTimer(int id)
1848 {
1849     Q_D(QObject);
1850     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1851         qWarning("QObject::killTimer: Timers cannot be stopped from another thread");
1852         return;
1853     }
1854     if (id) {
1855         int at = d->extraData ? d->extraData->runningTimers.indexOf(id) : -1;
1856         if (at == -1) {
1857             // timer isn't owned by this object
1858             qWarning("QObject::killTimer(): Error: timer id %d is not valid for object %p (%s, %ls), timer has not been killed",
1859                      id,
1860                      this,
1861                      metaObject()->className(),
1862                      qUtf16Printable(objectName()));
1863             return;
1864         }
1865 
1866         auto thisThreadData = d->threadData.loadRelaxed();
1867         if (thisThreadData->hasEventDispatcher())
1868             thisThreadData->eventDispatcher.loadRelaxed()->unregisterTimer(id);
1869 
1870         d->extraData->runningTimers.remove(at);
1871         QAbstractEventDispatcherPrivate::releaseTimerId(id);
1872     }
1873 }
1874 
1875 
1876 /*!
1877     \fn QObject *QObject::parent() const
1878 
1879     Returns a pointer to the parent object.
1880 
1881     \sa children()
1882 */
1883 
1884 /*!
1885     \fn const QObjectList &QObject::children() const
1886 
1887     Returns a list of child objects.
1888     The QObjectList class is defined in the \c{<QObject>} header
1889     file as the following:
1890 
1891     \quotefromfile kernel/qobject.h
1892     \skipto /typedef .*QObjectList/
1893     \printuntil QObjectList
1894 
1895     The first child added is the \l{QList::first()}{first} object in
1896     the list and the last child added is the \l{QList::last()}{last}
1897     object in the list, i.e. new children are appended at the end.
1898 
1899     Note that the list order changes when QWidget children are
1900     \l{QWidget::raise()}{raised} or \l{QWidget::lower()}{lowered}. A
1901     widget that is raised becomes the last object in the list, and a
1902     widget that is lowered becomes the first object in the list.
1903 
1904     \sa findChild(), findChildren(), parent(), setParent()
1905 */
1906 
1907 
1908 /*!
1909     \fn template<typename T> T *QObject::findChild(const QString &name, Qt::FindChildOptions options) const
1910 
1911     Returns the child of this object that can be cast into type T and
1912     that is called \a name, or \nullptr if there is no such object.
1913     Omitting the \a name argument causes all object names to be matched.
1914     The search is performed recursively, unless \a options specifies the
1915     option FindDirectChildrenOnly.
1916 
1917     If there is more than one child matching the search, the most
1918     direct ancestor is returned. If there are several direct
1919     ancestors, it is undefined which one will be returned. In that
1920     case, findChildren() should be used.
1921 
1922     This example returns a child \c{QPushButton} of \c{parentWidget}
1923     named \c{"button1"}, even if the button isn't a direct child of
1924     the parent:
1925 
1926     \snippet code/src_corelib_kernel_qobject.cpp 10
1927 
1928     This example returns a \c{QListWidget} child of \c{parentWidget}:
1929 
1930     \snippet code/src_corelib_kernel_qobject.cpp 11
1931 
1932     This example returns a child \c{QPushButton} of \c{parentWidget}
1933     (its direct parent) named \c{"button1"}:
1934 
1935     \snippet code/src_corelib_kernel_qobject.cpp 41
1936 
1937     This example returns a \c{QListWidget} child of \c{parentWidget},
1938     its direct parent:
1939 
1940     \snippet code/src_corelib_kernel_qobject.cpp 42
1941 
1942     \sa findChildren()
1943 */
1944 
1945 /*!
1946     \fn template<typename T> QList<T> QObject::findChildren(const QString &name, Qt::FindChildOptions options) const
1947 
1948     Returns all children of this object with the given \a name that can be
1949     cast to type T, or an empty list if there are no such objects.
1950     A null \a name argument causes all objects to be matched, an empty one
1951     only those whose objectName is empty.
1952     The search is performed recursively, unless \a options specifies the
1953     option FindDirectChildrenOnly.
1954 
1955     The following example shows how to find a list of child \c{QWidget}s of
1956     the specified \c{parentWidget} named \c{widgetname}:
1957 
1958     \snippet code/src_corelib_kernel_qobject.cpp 12
1959 
1960     This example returns all \c{QPushButton}s that are children of \c{parentWidget}:
1961 
1962     \snippet code/src_corelib_kernel_qobject.cpp 13
1963 
1964     This example returns all \c{QPushButton}s that are immediate children of \c{parentWidget}:
1965 
1966     \snippet code/src_corelib_kernel_qobject.cpp 43
1967 
1968     \sa findChild()
1969 */
1970 
1971 /*!
1972     \fn template<typename T> QList<T> QObject::findChildren(Qt::FindChildOptions options) const
1973     \overload
1974     \since 6.3
1975 
1976     Returns all children of this object that can be cast to type T, or
1977     an empty list if there are no such objects.
1978     The search is performed recursively, unless \a options specifies the
1979     option FindDirectChildrenOnly.
1980 
1981     \sa findChild()
1982 */
1983 
1984 /*!
1985     \fn QList<T> QObject::findChildren(const QRegularExpression &re, Qt::FindChildOptions options) const
1986     \overload findChildren()
1987 
1988     \since 5.0
1989 
1990     Returns the children of this object that can be cast to type T
1991     and that have names matching the regular expression \a re,
1992     or an empty list if there are no such objects.
1993     The search is performed recursively, unless \a options specifies the
1994     option FindDirectChildrenOnly.
1995 */
1996 
1997 /*!
1998     \fn template<typename T> T qFindChild(const QObject *obj, const QString &name)
1999     \relates QObject
2000     \overload qFindChildren()
2001     \deprecated
2002 
2003     This function is equivalent to
2004     \a{obj}->\l{QObject::findChild()}{findChild}<T>(\a name).
2005 
2006     \note This function was provided as a workaround for MSVC 6
2007     which did not support member template functions. It is advised
2008     to use the other form in new code.
2009 
2010     \sa QObject::findChild()
2011 */
2012 
2013 /*!
2014     \fn template<typename T> QList<T> qFindChildren(const QObject *obj, const QString &name)
2015     \relates QObject
2016     \overload qFindChildren()
2017     \deprecated
2018 
2019     This function is equivalent to
2020     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a name).
2021 
2022     \note This function was provided as a workaround for MSVC 6
2023     which did not support member template functions. It is advised
2024     to use the other form in new code.
2025 
2026     \sa QObject::findChildren()
2027 */
2028 
2029 static void qt_qFindChildren_with_name(const QObject *parent, const QString &name,
2030                                        const QMetaObject &mo, QList<void *> *list,
2031                                        Qt::FindChildOptions options)
2032 {
2033     Q_ASSERT(parent);
2034     Q_ASSERT(list);
2035     Q_ASSERT(!name.isNull());
2036     for (QObject *obj : parent->children()) {
2037         if (mo.cast(obj) && obj->objectName() == name)
2038             list->append(obj);
2039         if (options & Qt::FindChildrenRecursively)
2040             qt_qFindChildren_with_name(obj, name, mo, list, options);
2041     }
2042 }
2043 
2044 /*!
2045     \internal
2046 */
2047 void qt_qFindChildren_helper(const QObject *parent, const QString &name,
2048                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
2049 {
2050     if (name.isNull())
2051         return qt_qFindChildren_helper(parent, mo, list, options);
2052     else
2053         return qt_qFindChildren_with_name(parent, name, mo, list, options);
2054 }
2055 
2056 /*!
2057     \internal
2058 */
2059 void qt_qFindChildren_helper(const QObject *parent, const QMetaObject &mo,
2060                              QList<void*> *list, Qt::FindChildOptions options)
2061 {
2062     Q_ASSERT(parent);
2063     Q_ASSERT(list);
2064     for (QObject *obj : parent->children()) {
2065         if (mo.cast(obj))
2066             list->append(obj);
2067         if (options & Qt::FindChildrenRecursively)
2068             qt_qFindChildren_helper(obj, mo, list, options);
2069     }
2070 }
2071 
2072 #if QT_CONFIG(regularexpression)
2073 /*!
2074     \internal
2075 */
2076 void qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &re,
2077                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
2078 {
2079     Q_ASSERT(parent);
2080     Q_ASSERT(list);
2081     for (QObject *obj : parent->children()) {
2082         if (mo.cast(obj)) {
2083             QRegularExpressionMatch m = re.match(obj->objectName());
2084             if (m.hasMatch())
2085                 list->append(obj);
2086         }
2087         if (options & Qt::FindChildrenRecursively)
2088             qt_qFindChildren_helper(obj, re, mo, list, options);
2089     }
2090 }
2091 #endif // QT_CONFIG(regularexpression)
2092 
2093 /*!
2094     \internal
2095  */
2096 QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo, Qt::FindChildOptions options)
2097 {
2098     Q_ASSERT(parent);
2099     for (QObject *obj : parent->children()) {
2100         if (mo.cast(obj) && (name.isNull() || obj->objectName() == name))
2101             return obj;
2102     }
2103     if (options & Qt::FindChildrenRecursively) {
2104         for (QObject *child : parent->children()) {
2105             if (QObject *obj = qt_qFindChild_helper(child, name, mo, options))
2106                 return obj;
2107         }
2108     }
2109     return nullptr;
2110 }
2111 
2112 /*!
2113     Makes the object a child of \a parent.
2114 
2115     \sa parent(), children()
2116 */
2117 void QObject::setParent(QObject *parent)
2118 {
2119     Q_D(QObject);
2120     Q_ASSERT(!d->isWidget);
2121     d->setParent_helper(parent);
2122 }
2123 
2124 void QObjectPrivate::deleteChildren()
2125 {
2126     Q_ASSERT_X(!isDeletingChildren, "QObjectPrivate::deleteChildren()", "isDeletingChildren already set, did this function recurse?");
2127     isDeletingChildren = true;
2128     // delete children objects
2129     // don't use qDeleteAll as the destructor of the child might
2130     // delete siblings
2131     for (int i = 0; i < children.count(); ++i) {
2132         currentChildBeingDeleted = children.at(i);
2133         children[i] = nullptr;
2134         delete currentChildBeingDeleted;
2135     }
2136     children.clear();
2137     currentChildBeingDeleted = nullptr;
2138     isDeletingChildren = false;
2139 }
2140 
2141 void QObjectPrivate::setParent_helper(QObject *o)
2142 {
2143     Q_Q(QObject);
2144     Q_ASSERT_X(q != o, Q_FUNC_INFO, "Cannot parent a QObject to itself");
2145 #ifdef QT_DEBUG
2146     const auto checkForParentChildLoops = qScopeGuard([&](){
2147         int depth = 0;
2148         auto p = parent;
2149         while (p) {
2150             if (++depth == CheckForParentChildLoopsWarnDepth) {
2151                 qWarning("QObject %p (class: '%s', object name: '%s') may have a loop in its parent-child chain; "
2152                          "this is undefined behavior",
2153                          q, q->metaObject()->className(), qPrintable(q->objectName()));
2154             }
2155             p = p->parent();
2156         }
2157     });
2158 #endif
2159 
2160     if (o == parent)
2161         return;
2162 
2163     if (parent) {
2164         QObjectPrivate *parentD = parent->d_func();
2165         if (parentD->isDeletingChildren && wasDeleted
2166             && parentD->currentChildBeingDeleted == q) {
2167             // don't do anything since QObjectPrivate::deleteChildren() already
2168             // cleared our entry in parentD->children.
2169         } else {
2170             const int index = parentD->children.indexOf(q);
2171             if (index < 0) {
2172                 // we're probably recursing into setParent() from a ChildRemoved event, don't do anything
2173             } else if (parentD->isDeletingChildren) {
2174                 parentD->children[index] = nullptr;
2175             } else {
2176                 parentD->children.removeAt(index);
2177                 if (sendChildEvents && parentD->receiveChildEvents) {
2178                     QChildEvent e(QEvent::ChildRemoved, q);
2179                     QCoreApplication::sendEvent(parent, &e);
2180                 }
2181             }
2182         }
2183     }
2184     parent = o;
2185     if (parent) {
2186         // object hierarchies are constrained to a single thread
2187         if (threadData != parent->d_func()->threadData) {
2188             qWarning("QObject::setParent: Cannot set parent, new parent is in a different thread");
2189             parent = nullptr;
2190             return;
2191         }
2192         parent->d_func()->children.append(q);
2193         if (sendChildEvents && parent->d_func()->receiveChildEvents) {
2194             if (!isWidget) {
2195                 QChildEvent e(QEvent::ChildAdded, q);
2196                 QCoreApplication::sendEvent(parent, &e);
2197             }
2198         }
2199     }
2200 }
2201 
2202 /*!
2203     \fn void QObject::installEventFilter(QObject *filterObj)
2204 
2205     Installs an event filter \a filterObj on this object. For example:
2206     \snippet code/src_corelib_kernel_qobject.cpp 14
2207 
2208     An event filter is an object that receives all events that are
2209     sent to this object. The filter can either stop the event or
2210     forward it to this object. The event filter \a filterObj receives
2211     events via its eventFilter() function. The eventFilter() function
2212     must return true if the event should be filtered, (i.e. stopped);
2213     otherwise it must return false.
2214 
2215     If multiple event filters are installed on a single object, the
2216     filter that was installed last is activated first.
2217 
2218     Here's a \c KeyPressEater class that eats the key presses of its
2219     monitored objects:
2220 
2221     \snippet code/src_corelib_kernel_qobject.cpp 15
2222 
2223     And here's how to install it on two widgets:
2224 
2225     \snippet code/src_corelib_kernel_qobject.cpp 16
2226 
2227     The QShortcut class, for example, uses this technique to intercept
2228     shortcut key presses.
2229 
2230     \warning If you delete the receiver object in your eventFilter()
2231     function, be sure to return true. If you return false, Qt sends
2232     the event to the deleted object and the program will crash.
2233 
2234     Note that the filtering object must be in the same thread as this
2235     object. If \a filterObj is in a different thread, this function does
2236     nothing. If either \a filterObj or this object are moved to a different
2237     thread after calling this function, the event filter will not be
2238     called until both objects have the same thread affinity again (it
2239     is \e not removed).
2240 
2241     \sa removeEventFilter(), eventFilter(), event()
2242 */
2243 
2244 void QObject::installEventFilter(QObject *obj)
2245 {
2246     Q_D(QObject);
2247     if (!obj)
2248         return;
2249     if (d->threadData != obj->d_func()->threadData) {
2250         qWarning("QObject::installEventFilter(): Cannot filter events for objects in a different thread.");
2251         return;
2252     }
2253 
2254     if (!d->extraData)
2255         d->extraData = new QObjectPrivate::ExtraData(d);
2256 
2257     // clean up unused items in the list
2258     d->extraData->eventFilters.removeAll((QObject *)nullptr);
2259     d->extraData->eventFilters.removeAll(obj);
2260     d->extraData->eventFilters.prepend(obj);
2261 }
2262 
2263 /*!
2264     Removes an event filter object \a obj from this object. The
2265     request is ignored if such an event filter has not been installed.
2266 
2267     All event filters for this object are automatically removed when
2268     this object is destroyed.
2269 
2270     It is always safe to remove an event filter, even during event
2271     filter activation (i.e. from the eventFilter() function).
2272 
2273     \sa installEventFilter(), eventFilter(), event()
2274 */
2275 
2276 void QObject::removeEventFilter(QObject *obj)
2277 {
2278     Q_D(QObject);
2279     if (d->extraData) {
2280         for (int i = 0; i < d->extraData->eventFilters.count(); ++i) {
2281             if (d->extraData->eventFilters.at(i) == obj)
2282                 d->extraData->eventFilters[i] = nullptr;
2283         }
2284     }
2285 }
2286 
2287 /*!
2288     \fn void QObject::destroyed(QObject *obj)
2289 
2290     This signal is emitted immediately before the object \a obj is
2291     destroyed, after any instances of QPointer have been notified,
2292     and cannot be blocked.
2293 
2294     All the objects's children are destroyed immediately after this
2295     signal is emitted.
2296 
2297     \sa deleteLater(), QPointer
2298 */
2299 
2300 /*!
2301     \threadsafe
2302 
2303     Schedules this object for deletion.
2304 
2305     The object will be deleted when control returns to the event
2306     loop. If the event loop is not running when this function is
2307     called (e.g. deleteLater() is called on an object before
2308     QCoreApplication::exec()), the object will be deleted once the
2309     event loop is started. If deleteLater() is called after the main event loop
2310     has stopped, the object will not be deleted.
2311     Since Qt 4.8, if deleteLater() is called on an object that lives in a
2312     thread with no running event loop, the object will be destroyed when the
2313     thread finishes.
2314 
2315     Note that entering and leaving a new event loop (e.g., by opening a modal
2316     dialog) will \e not perform the deferred deletion; for the object to be
2317     deleted, the control must return to the event loop from which deleteLater()
2318     was called. This does not apply to objects deleted while a previous, nested
2319     event loop was still running: the Qt event loop will delete those objects
2320     as soon as the new nested event loop starts.
2321 
2322     \b{Note:} It is safe to call this function more than once; when the
2323     first deferred deletion event is delivered, any pending events for the
2324     object are removed from the event queue.
2325 
2326     \sa destroyed(), QPointer
2327 */
2328 void QObject::deleteLater()
2329 {
2330     QCoreApplication::postEvent(this, new QDeferredDeleteEvent());
2331 }
2332 
2333 /*!
2334     \fn QString QObject::tr(const char *sourceText, const char *disambiguation, int n)
2335     \reentrant
2336 
2337     Returns a translated version of \a sourceText, optionally based on a
2338     \a disambiguation string and value of \a n for strings containing plurals;
2339     otherwise returns QString::fromUtf8(\a sourceText) if no appropriate
2340     translated string is available.
2341 
2342     Example:
2343     \snippet ../widgets/mainwindows/sdi/mainwindow.cpp implicit tr context
2344     \dots
2345 
2346     If the same \a sourceText is used in different roles within the
2347     same context, an additional identifying string may be passed in
2348     \a disambiguation (\nullptr by default). In Qt 4.4 and earlier, this was
2349     the preferred way to pass comments to translators.
2350 
2351     Example:
2352 
2353     \snippet code/src_corelib_kernel_qobject.cpp 17
2354     \dots
2355 
2356     See \l{Writing Source Code for Translation} for a detailed description of
2357     Qt's translation mechanisms in general, and the
2358     \l{Writing Source Code for Translation#Disambiguation}{Disambiguation}
2359     section for information on disambiguation.
2360 
2361     \warning This method is reentrant only if all translators are
2362     installed \e before calling this method. Installing or removing
2363     translators while performing translations is not supported. Doing
2364     so will probably result in crashes or other undesirable behavior.
2365 
2366     \sa QCoreApplication::translate(), {Internationalization with Qt}
2367 */
2368 
2369 /*****************************************************************************
2370   Signals and slots
2371  *****************************************************************************/
2372 
2373 const char *qFlagLocation(const char *method)
2374 {
2375     QThreadData *currentThreadData = QThreadData::current(false);
2376     if (currentThreadData != nullptr)
2377         currentThreadData->flaggedSignatures.store(method);
2378     return method;
2379 }
2380 
2381 static int extract_code(const char *member)
2382 {
2383     // extract code, ensure QMETHOD_CODE <= code <= QSIGNAL_CODE
2384     return (((int)(*member) - '0') & 0x3);
2385 }
2386 
2387 static const char *extract_location(const char *member)
2388 {
2389     if (QThreadData::current()->flaggedSignatures.contains(member)) {
2390         // signature includes location information after the first null-terminator
2391         const char *location = member + qstrlen(member) + 1;
2392         if (*location != '\0')
2393             return location;
2394     }
2395     return nullptr;
2396 }
2397 
2398 static bool check_signal_macro(const QObject *sender, const char *signal,
2399                                 const char *func, const char *op)
2400 {
2401     int sigcode = extract_code(signal);
2402     if (sigcode != QSIGNAL_CODE) {
2403         if (sigcode == QSLOT_CODE)
2404             qCWarning(lcConnect, "QObject::%s: Attempt to %s non-signal %s::%s", func, op,
2405                       sender->metaObject()->className(), signal + 1);
2406         else
2407             qCWarning(lcConnect, "QObject::%s: Use the SIGNAL macro to %s %s::%s", func, op,
2408                       sender->metaObject()->className(), signal);
2409         return false;
2410     }
2411     return true;
2412 }
2413 
2414 static bool check_method_code(int code, const QObject *object, const char *method, const char *func)
2415 {
2416     if (code != QSLOT_CODE && code != QSIGNAL_CODE) {
2417         qCWarning(lcConnect,
2418                   "QObject::%s: Use the SLOT or SIGNAL macro to "
2419                   "%s %s::%s",
2420                   func, func, object->metaObject()->className(), method);
2421         return false;
2422     }
2423     return true;
2424 }
2425 
2426 static void err_method_notfound(const QObject *object,
2427                                 const char *method, const char *func)
2428 {
2429     const char *type = "method";
2430     switch (extract_code(method)) {
2431         case QSLOT_CODE:   type = "slot";   break;
2432         case QSIGNAL_CODE: type = "signal"; break;
2433     }
2434     const char *loc = extract_location(method);
2435     if (strchr(method, ')') == nullptr) // common typing mistake
2436         qCWarning(lcConnect, "QObject::%s: Parentheses expected, %s %s::%s%s%s", func, type,
2437                   object->metaObject()->className(), method + 1, loc ? " in " : "", loc ? loc : "");
2438     else
2439         qCWarning(lcConnect, "QObject::%s: No such %s %s::%s%s%s", func, type,
2440                   object->metaObject()->className(), method + 1, loc ? " in " : "", loc ? loc : "");
2441 }
2442 
2443 static void err_info_about_objects(const char *func, const QObject *sender, const QObject *receiver)
2444 {
2445     QString a = sender ? sender->objectName() : QString();
2446     QString b = receiver ? receiver->objectName() : QString();
2447     if (!a.isEmpty())
2448         qCWarning(lcConnect, "QObject::%s:  (sender name:   '%s')", func, a.toLocal8Bit().data());
2449     if (!b.isEmpty())
2450         qCWarning(lcConnect, "QObject::%s:  (receiver name: '%s')", func, b.toLocal8Bit().data());
2451 }
2452 
2453 /*!
2454     Returns a pointer to the object that sent the signal, if called in
2455     a slot activated by a signal; otherwise it returns \nullptr. The pointer
2456     is valid only during the execution of the slot that calls this
2457     function from this object's thread context.
2458 
2459     The pointer returned by this function becomes invalid if the
2460     sender is destroyed, or if the slot is disconnected from the
2461     sender's signal.
2462 
2463     \warning This function violates the object-oriented principle of
2464     modularity. However, getting access to the sender might be useful
2465     when many signals are connected to a single slot.
2466 
2467     \warning As mentioned above, the return value of this function is
2468     not valid when the slot is called via a Qt::DirectConnection from
2469     a thread different from this object's thread. Do not use this
2470     function in this type of scenario.
2471 
2472     \sa senderSignalIndex()
2473 */
2474 
2475 QObject *QObject::sender() const
2476 {
2477     Q_D(const QObject);
2478 
2479     QBasicMutexLocker locker(signalSlotLock(this));
2480     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2481     if (!cd || !cd->currentSender)
2482         return nullptr;
2483 
2484     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2485         if (c->sender == cd->currentSender->sender)
2486             return cd->currentSender->sender;
2487     }
2488 
2489     return nullptr;
2490 }
2491 
2492 /*!
2493     \since 4.8
2494 
2495     Returns the meta-method index of the signal that called the currently
2496     executing slot, which is a member of the class returned by sender().
2497     If called outside of a slot activated by a signal, -1 is returned.
2498 
2499     For signals with default parameters, this function will always return
2500     the index with all parameters, regardless of which was used with
2501     connect(). For example, the signal \c {destroyed(QObject *obj = \nullptr)}
2502     will have two different indexes (with and without the parameter), but
2503     this function will always return the index with a parameter. This does
2504     not apply when overloading signals with different parameters.
2505 
2506     \warning This function violates the object-oriented principle of
2507     modularity. However, getting access to the signal index might be useful
2508     when many signals are connected to a single slot.
2509 
2510     \warning The return value of this function is not valid when the slot
2511     is called via a Qt::DirectConnection from a thread different from this
2512     object's thread. Do not use this function in this type of scenario.
2513 
2514     \sa sender(), QMetaObject::indexOfSignal(), QMetaObject::method()
2515 */
2516 
2517 int QObject::senderSignalIndex() const
2518 {
2519     Q_D(const QObject);
2520 
2521     QBasicMutexLocker locker(signalSlotLock(this));
2522     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2523     if (!cd || !cd->currentSender)
2524         return -1;
2525 
2526     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2527         if (c->sender == cd->currentSender->sender) {
2528             // Convert from signal range to method range
2529             return QMetaObjectPrivate::signal(c->sender->metaObject(), cd->currentSender->signal).methodIndex();
2530         }
2531     }
2532 
2533     return -1;
2534 }
2535 
2536 /*!
2537     Returns the number of receivers connected to the \a signal.
2538 
2539     Since both slots and signals can be used as receivers for signals,
2540     and the same connections can be made many times, the number of
2541     receivers is the same as the number of connections made from this
2542     signal.
2543 
2544     When calling this function, you can use the \c SIGNAL() macro to
2545     pass a specific signal:
2546 
2547     \snippet code/src_corelib_kernel_qobject.cpp 21
2548 
2549     \warning This function violates the object-oriented principle of
2550     modularity. However, it might be useful when you need to perform
2551     expensive initialization only if something is connected to a
2552     signal.
2553 
2554     \sa isSignalConnected()
2555 */
2556 
2557 int QObject::receivers(const char *signal) const
2558 {
2559     Q_D(const QObject);
2560     int receivers = 0;
2561     if (signal) {
2562         QByteArray signal_name = QMetaObject::normalizedSignature(signal);
2563         signal = signal_name;
2564 #ifndef QT_NO_DEBUG
2565         if (!check_signal_macro(this, signal, "receivers", "bind"))
2566             return 0;
2567 #endif
2568         signal++; // skip code
2569         int signal_index = d->signalIndex(signal);
2570         if (signal_index < 0) {
2571 #ifndef QT_NO_DEBUG
2572             err_method_notfound(this, signal - 1, "receivers");
2573 #endif
2574             return 0;
2575         }
2576 
2577         if (!d->isSignalConnected(signal_index))
2578             return receivers;
2579 
2580         if (d->declarativeData && QAbstractDeclarativeData::receivers) {
2581             receivers += QAbstractDeclarativeData::receivers(d->declarativeData, this,
2582                                                              signal_index);
2583         }
2584 
2585         QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2586         QBasicMutexLocker locker(signalSlotLock(this));
2587         if (cd && signal_index < cd->signalVectorCount()) {
2588             const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
2589             while (c) {
2590                 receivers += c->receiver.loadRelaxed() ? 1 : 0;
2591                 c = c->nextConnectionList.loadRelaxed();
2592             }
2593         }
2594     }
2595     return receivers;
2596 }
2597 
2598 /*!
2599     \since 5.0
2600     Returns \c true if the \a signal is connected to at least one receiver,
2601     otherwise returns \c false.
2602 
2603     \a signal must be a signal member of this object, otherwise the behaviour
2604     is undefined.
2605 
2606     \snippet code/src_corelib_kernel_qobject.cpp 49
2607 
2608     As the code snippet above illustrates, you can use this function
2609     to avoid emitting a signal that nobody listens to.
2610 
2611     \warning This function violates the object-oriented principle of
2612     modularity. However, it might be useful when you need to perform
2613     expensive initialization only if something is connected to a
2614     signal.
2615 */
2616 bool QObject::isSignalConnected(const QMetaMethod &signal) const
2617 {
2618     Q_D(const QObject);
2619     if (!signal.mobj)
2620         return false;
2621 
2622     Q_ASSERT_X(signal.mobj->cast(this) && signal.methodType() == QMetaMethod::Signal,
2623                "QObject::isSignalConnected" , "the parameter must be a signal member of the object");
2624     uint signalIndex = signal.relativeMethodIndex();
2625 
2626     if (signal.data.flags() & MethodCloned)
2627         signalIndex = QMetaObjectPrivate::originalClone(signal.mobj, signalIndex);
2628 
2629     signalIndex += QMetaObjectPrivate::signalOffset(signal.mobj);
2630 
2631     QBasicMutexLocker locker(signalSlotLock(this));
2632     return d->isSignalConnected(signalIndex, true);
2633 }
2634 
2635 /*!
2636     \internal
2637 
2638     This helper function calculates signal and method index for the given
2639     member in the specified class.
2640 
2641     \list
2642     \li If member.mobj is \nullptr then both signalIndex and methodIndex are set to -1.
2643 
2644     \li If specified member is not a member of obj instance class (or one of
2645     its parent classes) then both signalIndex and methodIndex are set to -1.
2646     \endlist
2647 
2648     This function is used by QObject::connect and QObject::disconnect which
2649     are working with QMetaMethod.
2650 
2651     \a signalIndex is set to the signal index of member. If the member
2652     specified is not signal this variable is set to -1.
2653 
2654     \a methodIndex is set to the method index of the member. If the
2655     member is not a method of the object specified by the \a obj argument this
2656     variable is set to -1.
2657 */
2658 void QMetaObjectPrivate::memberIndexes(const QObject *obj,
2659                                        const QMetaMethod &member,
2660                                        int *signalIndex, int *methodIndex)
2661 {
2662     *signalIndex = -1;
2663     *methodIndex = -1;
2664     if (!obj || !member.mobj)
2665         return;
2666     const QMetaObject *m = obj->metaObject();
2667     // Check that member is member of obj class
2668     while (m != nullptr && m != member.mobj)
2669         m = m->d.superdata;
2670     if (!m)
2671         return;
2672     *signalIndex = *methodIndex = member.relativeMethodIndex();
2673 
2674     int signalOffset;
2675     int methodOffset;
2676     computeOffsets(m, &signalOffset, &methodOffset);
2677 
2678     *methodIndex += methodOffset;
2679     if (member.methodType() == QMetaMethod::Signal) {
2680         *signalIndex = originalClone(m, *signalIndex);
2681         *signalIndex += signalOffset;
2682     } else {
2683         *signalIndex = -1;
2684     }
2685 }
2686 
2687 #ifndef QT_NO_DEBUG
2688 static inline void check_and_warn_compat(const QMetaObject *sender, const QMetaMethod &signal,
2689                                          const QMetaObject *receiver, const QMetaMethod &method)
2690 {
2691     if (signal.attributes() & QMetaMethod::Compatibility) {
2692         if (!(method.attributes() & QMetaMethod::Compatibility))
2693             qCWarning(lcConnect, "QObject::connect: Connecting from COMPAT signal (%s::%s)",
2694                       sender->className(), signal.methodSignature().constData());
2695     } else if ((method.attributes() & QMetaMethod::Compatibility)
2696                && method.methodType() == QMetaMethod::Signal) {
2697         qCWarning(lcConnect, "QObject::connect: Connecting from %s::%s to COMPAT slot (%s::%s)",
2698                   sender->className(), signal.methodSignature().constData(), receiver->className(),
2699                   method.methodSignature().constData());
2700     }
2701 }
2702 #endif
2703 
2704 /*!
2705     \threadsafe
2706 
2707     Creates a connection of the given \a type from the \a signal in
2708     the \a sender object to the \a method in the \a receiver object.
2709     Returns a handle to the connection that can be used to disconnect
2710     it later.
2711 
2712     You must use the \c SIGNAL() and \c SLOT() macros when specifying
2713     the \a signal and the \a method, for example:
2714 
2715     \snippet code/src_corelib_kernel_qobject.cpp 22
2716 
2717     This example ensures that the label always displays the current
2718     scroll bar value. Note that the signal and slots parameters must not
2719     contain any variable names, only the type. E.g. the following would
2720     not work and return false:
2721 
2722     \snippet code/src_corelib_kernel_qobject.cpp 23
2723 
2724     A signal can also be connected to another signal:
2725 
2726     \snippet code/src_corelib_kernel_qobject.cpp 24
2727 
2728     In this example, the \c MyWidget constructor relays a signal from
2729     a private member variable, and makes it available under a name
2730     that relates to \c MyWidget.
2731 
2732     A signal can be connected to many slots and signals. Many signals
2733     can be connected to one slot.
2734 
2735     If a signal is connected to several slots, the slots are activated
2736     in the same order in which the connections were made, when the
2737     signal is emitted.
2738 
2739     The function returns a QMetaObject::Connection that represents
2740     a handle to a connection if it successfully
2741     connects the signal to the slot. The connection handle will be invalid
2742     if it cannot create the connection, for example, if QObject is unable
2743     to verify the existence of either \a signal or \a method, or if their
2744     signatures aren't compatible.
2745     You can check if the handle is valid by casting it to a bool.
2746 
2747     By default, a signal is emitted for every connection you make;
2748     two signals are emitted for duplicate connections. You can break
2749     all of these connections with a single disconnect() call.
2750     If you pass the Qt::UniqueConnection \a type, the connection will only
2751     be made if it is not a duplicate. If there is already a duplicate
2752     (exact same signal to the exact same slot on the same objects),
2753     the connection will fail and connect will return an invalid QMetaObject::Connection.
2754 
2755     \note Qt::UniqueConnections do not work for lambdas, non-member functions
2756     and functors; they only apply to connecting to member functions.
2757 
2758     The optional \a type parameter describes the type of connection
2759     to establish. In particular, it determines whether a particular
2760     signal is delivered to a slot immediately or queued for delivery
2761     at a later time. If the signal is queued, the parameters must be
2762     of types that are known to Qt's meta-object system, because Qt
2763     needs to copy the arguments to store them in an event behind the
2764     scenes. If you try to use a queued connection and get the error
2765     message
2766 
2767     \snippet code/src_corelib_kernel_qobject.cpp 25
2768 
2769     call qRegisterMetaType() to register the data type before you
2770     establish the connection.
2771 
2772     \sa disconnect(), sender(), qRegisterMetaType(), Q_DECLARE_METATYPE(),
2773     {Differences between String-Based and Functor-Based Connections}
2774 */
2775 QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal,
2776                                          const QObject *receiver, const char *method,
2777                                          Qt::ConnectionType type)
2778 {
2779     if (sender == nullptr || receiver == nullptr || signal == nullptr || method == nullptr) {
2780         qCWarning(lcConnect, "QObject::connect: Cannot connect %s::%s to %s::%s",
2781                   sender ? sender->metaObject()->className() : "(nullptr)",
2782                   (signal && *signal) ? signal + 1 : "(nullptr)",
2783                   receiver ? receiver->metaObject()->className() : "(nullptr)",
2784                   (method && *method) ? method + 1 : "(nullptr)");
2785         return QMetaObject::Connection(nullptr);
2786     }
2787     QByteArray tmp_signal_name;
2788 
2789     if (!check_signal_macro(sender, signal, "connect", "bind"))
2790         return QMetaObject::Connection(nullptr);
2791     const QMetaObject *smeta = sender->metaObject();
2792     const char *signal_arg = signal;
2793     ++signal; // skip code
2794     QArgumentTypeArray signalTypes;
2795     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
2796     QByteArray signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2797     int signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2798             &smeta, signalName, signalTypes.size(), signalTypes.constData());
2799     if (signal_index < 0) {
2800         // check for normalized signatures
2801         tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
2802         signal = tmp_signal_name.constData() + 1;
2803 
2804         signalTypes.clear();
2805         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2806         smeta = sender->metaObject();
2807         signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2808                 &smeta, signalName, signalTypes.size(), signalTypes.constData());
2809     }
2810     if (signal_index < 0) {
2811         err_method_notfound(sender, signal_arg, "connect");
2812         err_info_about_objects("connect", sender, receiver);
2813         return QMetaObject::Connection(nullptr);
2814     }
2815     signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
2816     signal_index += QMetaObjectPrivate::signalOffset(smeta);
2817 
2818     QByteArray tmp_method_name;
2819     int membcode = extract_code(method);
2820 
2821     if (!check_method_code(membcode, receiver, method, "connect"))
2822         return QMetaObject::Connection(nullptr);
2823     const char *method_arg = method;
2824     ++method; // skip code
2825 
2826     QArgumentTypeArray methodTypes;
2827     QByteArray methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2828     const QMetaObject *rmeta = receiver->metaObject();
2829     int method_index_relative = -1;
2830     Q_ASSERT(QMetaObjectPrivate::get(rmeta)->revision >= 7);
2831     switch (membcode) {
2832     case QSLOT_CODE:
2833         method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2834                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2835         break;
2836     case QSIGNAL_CODE:
2837         method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2838                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2839         break;
2840     }
2841     if (method_index_relative < 0) {
2842         // check for normalized methods
2843         tmp_method_name = QMetaObject::normalizedSignature(method);
2844         method = tmp_method_name.constData();
2845 
2846         methodTypes.clear();
2847         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2848         // rmeta may have been modified above
2849         rmeta = receiver->metaObject();
2850         switch (membcode) {
2851         case QSLOT_CODE:
2852             method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2853                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2854             break;
2855         case QSIGNAL_CODE:
2856             method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2857                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2858             break;
2859         }
2860     }
2861 
2862     if (method_index_relative < 0) {
2863         err_method_notfound(receiver, method_arg, "connect");
2864         err_info_about_objects("connect", sender, receiver);
2865         return QMetaObject::Connection(nullptr);
2866     }
2867 
2868     if (!QMetaObjectPrivate::checkConnectArgs(signalTypes.size(), signalTypes.constData(),
2869                                               methodTypes.size(), methodTypes.constData())) {
2870         qCWarning(lcConnect,
2871                   "QObject::connect: Incompatible sender/receiver arguments"
2872                   "\n        %s::%s --> %s::%s",
2873                   sender->metaObject()->className(), signal, receiver->metaObject()->className(),
2874                   method);
2875         return QMetaObject::Connection(nullptr);
2876     }
2877 
2878     int *types = nullptr;
2879     if ((type == Qt::QueuedConnection)
2880             && !(types = queuedConnectionTypes(signalTypes.constData(), signalTypes.size()))) {
2881         return QMetaObject::Connection(nullptr);
2882     }
2883 
2884 #ifndef QT_NO_DEBUG
2885     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
2886     QMetaMethod rmethod = rmeta->method(method_index_relative + rmeta->methodOffset());
2887     check_and_warn_compat(smeta, smethod, rmeta, rmethod);
2888 #endif
2889     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2890         sender, signal_index, smeta, receiver, method_index_relative, rmeta ,type, types));
2891     return handle;
2892 }
2893 
2894 /*!
2895     \since 4.8
2896 
2897     Creates a connection of the given \a type from the \a signal in
2898     the \a sender object to the \a method in the \a receiver object.
2899     Returns a handle to the connection that can be used to disconnect
2900     it later.
2901 
2902     The Connection handle will be invalid  if it cannot create the
2903     connection, for example, the parameters were invalid.
2904     You can check if the QMetaObject::Connection is valid by casting it to a bool.
2905 
2906     This function works in the same way as
2907     \c {connect(const QObject *sender, const char *signal,
2908             const QObject *receiver, const char *method,
2909             Qt::ConnectionType type)}
2910     but it uses QMetaMethod to specify signal and method.
2911 
2912     \sa connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)
2913  */
2914 QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal,
2915                                      const QObject *receiver, const QMetaMethod &method,
2916                                      Qt::ConnectionType type)
2917 {
2918     if (sender == nullptr
2919             || receiver == nullptr
2920             || signal.methodType() != QMetaMethod::Signal
2921             || method.methodType() == QMetaMethod::Constructor) {
2922         qCWarning(lcConnect, "QObject::connect: Cannot connect %s::%s to %s::%s",
2923                   sender ? sender->metaObject()->className() : "(nullptr)",
2924                   signal.methodSignature().constData(),
2925                   receiver ? receiver->metaObject()->className() : "(nullptr)",
2926                   method.methodSignature().constData());
2927         return QMetaObject::Connection(nullptr);
2928     }
2929 
2930     int signal_index;
2931     int method_index;
2932     {
2933         int dummy;
2934         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
2935         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
2936     }
2937 
2938     const QMetaObject *smeta = sender->metaObject();
2939     const QMetaObject *rmeta = receiver->metaObject();
2940     if (signal_index == -1) {
2941         qCWarning(lcConnect, "QObject::connect: Can't find signal %s on instance of class %s",
2942                   signal.methodSignature().constData(), smeta->className());
2943         return QMetaObject::Connection(nullptr);
2944     }
2945     if (method_index == -1) {
2946         qCWarning(lcConnect, "QObject::connect: Can't find method %s on instance of class %s",
2947                   method.methodSignature().constData(), rmeta->className());
2948         return QMetaObject::Connection(nullptr);
2949     }
2950 
2951     if (!QMetaObject::checkConnectArgs(signal.methodSignature().constData(),
2952                                        method.methodSignature().constData())) {
2953         qCWarning(lcConnect,
2954                   "QObject::connect: Incompatible sender/receiver arguments"
2955                   "\n        %s::%s --> %s::%s",
2956                   smeta->className(), signal.methodSignature().constData(), rmeta->className(),
2957                   method.methodSignature().constData());
2958         return QMetaObject::Connection(nullptr);
2959     }
2960 
2961     int *types = nullptr;
2962     if ((type == Qt::QueuedConnection) && !(types = queuedConnectionTypes(signal)))
2963         return QMetaObject::Connection(nullptr);
2964 
2965 #ifndef QT_NO_DEBUG
2966     check_and_warn_compat(smeta, signal, rmeta, method);
2967 #endif
2968     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2969         sender, signal_index, signal.enclosingMetaObject(), receiver, method_index, nullptr, type, types));
2970     return handle;
2971 }
2972 
2973 /*!
2974     \fn bool QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const
2975     \overload connect()
2976     \threadsafe
2977 
2978     Connects \a signal from the \a sender object to this object's \a
2979     method.
2980 
2981     Equivalent to connect(\a sender, \a signal, \c this, \a method, \a type).
2982 
2983     Every connection you make emits a signal, so duplicate connections emit
2984     two signals. You can break a connection using disconnect().
2985 
2986     \sa disconnect()
2987 */
2988 
2989 /*!
2990     \threadsafe
2991 
2992     Disconnects \a signal in object \a sender from \a method in object
2993     \a receiver. Returns \c true if the connection is successfully broken;
2994     otherwise returns \c false.
2995 
2996     A signal-slot connection is removed when either of the objects
2997     involved are destroyed.
2998 
2999     disconnect() is typically used in three ways, as the following
3000     examples demonstrate.
3001     \list 1
3002     \li Disconnect everything connected to an object's signals:
3003 
3004        \snippet code/src_corelib_kernel_qobject.cpp 26
3005 
3006        equivalent to the non-static overloaded function
3007 
3008        \snippet code/src_corelib_kernel_qobject.cpp 27
3009 
3010     \li Disconnect everything connected to a specific signal:
3011 
3012        \snippet code/src_corelib_kernel_qobject.cpp 28
3013 
3014        equivalent to the non-static overloaded function
3015 
3016        \snippet code/src_corelib_kernel_qobject.cpp 29
3017 
3018     \li Disconnect a specific receiver:
3019 
3020        \snippet code/src_corelib_kernel_qobject.cpp 30
3021 
3022        equivalent to the non-static overloaded function
3023 
3024        \snippet code/src_corelib_kernel_qobject.cpp 31
3025 
3026     \endlist
3027 
3028     \nullptr may be used as a wildcard, meaning "any signal", "any receiving
3029     object", or "any slot in the receiving object", respectively.
3030 
3031     The \a sender may never be \nullptr. (You cannot disconnect signals
3032     from more than one object in a single call.)
3033 
3034     If \a signal is \nullptr, it disconnects \a receiver and \a method from
3035     any signal. If not, only the specified signal is disconnected.
3036 
3037     If \a receiver is \nullptr, it disconnects anything connected to \a
3038     signal. If not, slots in objects other than \a receiver are not
3039     disconnected.
3040 
3041     If \a method is \nullptr, it disconnects anything that is connected to \a
3042     receiver. If not, only slots named \a method will be disconnected,
3043     and all other slots are left alone. The \a method must be \nullptr
3044     if \a receiver is left out, so you cannot disconnect a
3045     specifically-named slot on all objects.
3046 
3047     \include includes/qobject.qdocinc disconnect-all
3048 
3049     \sa connect()
3050 */
3051 bool QObject::disconnect(const QObject *sender, const char *signal,
3052                          const QObject *receiver, const char *method)
3053 {
3054     if (sender == nullptr || (receiver == nullptr && method != nullptr)) {
3055         qCWarning(lcConnect, "QObject::disconnect: Unexpected nullptr parameter");
3056         return false;
3057     }
3058 
3059     const char *signal_arg = signal;
3060     QByteArray signal_name;
3061     bool signal_found = false;
3062     if (signal) {
3063         QT_TRY {
3064             signal_name = QMetaObject::normalizedSignature(signal);
3065             signal = signal_name.constData();
3066         } QT_CATCH (const std::bad_alloc &) {
3067             // if the signal is already normalized, we can continue.
3068             if (sender->metaObject()->indexOfSignal(signal + 1) == -1)
3069                 QT_RETHROW;
3070         }
3071 
3072         if (!check_signal_macro(sender, signal, "disconnect", "unbind"))
3073             return false;
3074         signal++; // skip code
3075     }
3076 
3077     QByteArray method_name;
3078     const char *method_arg = method;
3079     int membcode = -1;
3080     bool method_found = false;
3081     if (method) {
3082         QT_TRY {
3083             method_name = QMetaObject::normalizedSignature(method);
3084             method = method_name.constData();
3085         } QT_CATCH(const std::bad_alloc &) {
3086             // if the method is already normalized, we can continue.
3087             if (receiver->metaObject()->indexOfMethod(method + 1) == -1)
3088                 QT_RETHROW;
3089         }
3090 
3091         membcode = extract_code(method);
3092         if (!check_method_code(membcode, receiver, method, "disconnect"))
3093             return false;
3094         method++; // skip code
3095     }
3096 
3097     /* We now iterate through all the sender's and receiver's meta
3098      * objects in order to also disconnect possibly shadowed signals
3099      * and slots with the same signature.
3100     */
3101     bool res = false;
3102     const QMetaObject *smeta = sender->metaObject();
3103     QByteArray signalName;
3104     QArgumentTypeArray signalTypes;
3105     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
3106     if (signal)
3107         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
3108     QByteArray methodName;
3109     QArgumentTypeArray methodTypes;
3110     Q_ASSERT(!receiver || QMetaObjectPrivate::get(receiver->metaObject())->revision >= 7);
3111     if (method)
3112         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
3113     do {
3114         int signal_index = -1;
3115         if (signal) {
3116             signal_index = QMetaObjectPrivate::indexOfSignalRelative(
3117                         &smeta, signalName, signalTypes.size(), signalTypes.constData());
3118             if (signal_index < 0)
3119                 break;
3120             signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
3121             signal_index += QMetaObjectPrivate::signalOffset(smeta);
3122             signal_found = true;
3123         }
3124 
3125         if (!method) {
3126             res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, -1, nullptr);
3127         } else {
3128             const QMetaObject *rmeta = receiver->metaObject();
3129             do {
3130                 int method_index = QMetaObjectPrivate::indexOfMethod(
3131                             rmeta, methodName, methodTypes.size(), methodTypes.constData());
3132                 if (method_index >= 0)
3133                     while (method_index < rmeta->methodOffset())
3134                             rmeta = rmeta->superClass();
3135                 if (method_index < 0)
3136                     break;
3137                 res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, method_index, nullptr);
3138                 method_found = true;
3139             } while ((rmeta = rmeta->superClass()));
3140         }
3141     } while (signal && (smeta = smeta->superClass()));
3142 
3143     if (signal && !signal_found) {
3144         err_method_notfound(sender, signal_arg, "disconnect");
3145         err_info_about_objects("disconnect", sender, receiver);
3146     } else if (method && !method_found) {
3147         err_method_notfound(receiver, method_arg, "disconnect");
3148         err_info_about_objects("disconnect", sender, receiver);
3149     }
3150     if (res) {
3151         if (!signal)
3152             const_cast<QObject *>(sender)->disconnectNotify(QMetaMethod());
3153     }
3154     return res;
3155 }
3156 
3157 /*!
3158     \since 4.8
3159 
3160     Disconnects \a signal in object \a sender from \a method in object
3161     \a receiver. Returns \c true if the connection is successfully broken;
3162     otherwise returns \c false.
3163 
3164     This function provides the same possibilities like
3165     \c {disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method) }
3166     but uses QMetaMethod to represent the signal and the method to be disconnected.
3167 
3168     Additionally this function returns false and no signals and slots disconnected
3169     if:
3170     \list 1
3171 
3172         \li \a signal is not a member of sender class or one of its parent classes.
3173 
3174         \li \a method is not a member of receiver class or one of its parent classes.
3175 
3176         \li \a signal instance represents not a signal.
3177 
3178     \endlist
3179 
3180     QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object".
3181     In the same way \nullptr can be used for \a receiver in the meaning "any receiving object".
3182     In this case method should also be QMetaMethod(). \a sender parameter should be never \nullptr.
3183 
3184     \include includes/qobject.qdocinc disconnect-all
3185 
3186     \sa disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
3187  */
3188 bool QObject::disconnect(const QObject *sender, const QMetaMethod &signal,
3189                          const QObject *receiver, const QMetaMethod &method)
3190 {
3191     if (sender == nullptr || (receiver == nullptr && method.mobj != nullptr)) {
3192         qCWarning(lcConnect, "QObject::disconnect: Unexpected nullptr parameter");
3193         return false;
3194     }
3195     if (signal.mobj) {
3196         if (signal.methodType() != QMetaMethod::Signal) {
3197             qCWarning(lcConnect, "QObject::%s: Attempt to %s non-signal %s::%s",
3198                      "disconnect","unbind",
3199                      sender->metaObject()->className(), signal.methodSignature().constData());
3200             return false;
3201         }
3202     }
3203     if (method.mobj) {
3204         if (method.methodType() == QMetaMethod::Constructor) {
3205             qCWarning(lcConnect, "QObject::disconnect: cannot use constructor as argument %s::%s",
3206                       receiver->metaObject()->className(), method.methodSignature().constData());
3207             return false;
3208         }
3209     }
3210 
3211     int signal_index;
3212     int method_index;
3213     {
3214         int dummy;
3215         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
3216         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
3217     }
3218     // If we are here sender is not nullptr. If signal is not nullptr while signal_index
3219     // is -1 then this signal is not a member of sender.
3220     if (signal.mobj && signal_index == -1) {
3221         qCWarning(lcConnect, "QObject::disconnect: signal %s not found on class %s",
3222                   signal.methodSignature().constData(), sender->metaObject()->className());
3223         return false;
3224     }
3225     // If this condition is true then method is not a member of receiver.
3226     if (receiver && method.mobj && method_index == -1) {
3227         qCWarning(lcConnect, "QObject::disconnect: method %s not found on class %s",
3228                   method.methodSignature().constData(), receiver->metaObject()->className());
3229         return false;
3230     }
3231 
3232     if (!QMetaObjectPrivate::disconnect(sender, signal_index, signal.mobj, receiver, method_index, nullptr))
3233         return false;
3234 
3235     if (!signal.isValid()) {
3236         // The signal is a wildcard, meaning all signals were disconnected.
3237         // QMetaObjectPrivate::disconnect() doesn't call disconnectNotify()
3238         // per connection in this case. Call it once now, with an invalid
3239         // QMetaMethod as argument, as documented.
3240         const_cast<QObject *>(sender)->disconnectNotify(signal);
3241     }
3242     return true;
3243 }
3244 
3245 /*!
3246     \threadsafe
3247 
3248     \fn bool QObject::disconnect(const char *signal, const QObject *receiver, const char *method) const
3249     \overload disconnect()
3250 
3251     Disconnects \a signal from \a method of \a receiver.
3252 
3253     A signal-slot connection is removed when either of the objects
3254     involved are destroyed.
3255 
3256     \include includes/qobject.qdocinc disconnect-all
3257 */
3258 
3259 /*!
3260     \fn bool QObject::disconnect(const QObject *receiver, const char *method) const
3261     \overload disconnect()
3262 
3263     Disconnects all signals in this object from \a receiver's \a
3264     method.
3265 
3266     A signal-slot connection is removed when either of the objects
3267     involved are destroyed.
3268 */
3269 
3270 
3271 /*!
3272     \since 5.0
3273 
3274     This virtual function is called when something has been connected
3275     to \a signal in this object.
3276 
3277     If you want to compare \a signal with a specific signal, you can
3278     use QMetaMethod::fromSignal() as follows:
3279 
3280     \snippet code/src_corelib_kernel_qobject.cpp 32
3281 
3282     \warning This function violates the object-oriented principle of
3283     modularity. However, it might be useful when you need to perform
3284     expensive initialization only if something is connected to a
3285     signal.
3286 
3287     \warning This function is called from the thread which performs the
3288     connection, which may be a different thread from the thread in
3289     which this object lives.
3290 
3291     \sa connect(), disconnectNotify()
3292 */
3293 
3294 void QObject::connectNotify(const QMetaMethod &signal)
3295 {
3296     Q_UNUSED(signal);
3297 }
3298 
3299 /*!
3300     \since 5.0
3301 
3302     This virtual function is called when something has been
3303     disconnected from \a signal in this object.
3304 
3305     See connectNotify() for an example of how to compare
3306     \a signal with a specific signal.
3307 
3308     If all signals were disconnected from this object (e.g., the
3309     signal argument to disconnect() was \nullptr), disconnectNotify()
3310     is only called once, and the \a signal will be an invalid
3311     QMetaMethod (QMetaMethod::isValid() returns \c false).
3312 
3313     \warning This function violates the object-oriented principle of
3314     modularity. However, it might be useful for optimizing access to
3315     expensive resources.
3316 
3317     \warning This function is called from the thread which performs the
3318     disconnection, which may be a different thread from the thread in
3319     which this object lives. This function may also be called with a QObject
3320     internal mutex locked. It is therefore not allowed to re-enter any
3321     of any QObject functions from your reimplementation and if you lock
3322     a mutex in your reimplementation, make sure that you don't call QObject
3323     functions with that mutex held in other places or it will result in
3324     a deadlock.
3325 
3326     \sa disconnect(), connectNotify()
3327 */
3328 
3329 void QObject::disconnectNotify(const QMetaMethod &signal)
3330 {
3331     Q_UNUSED(signal);
3332 }
3333 
3334 /*
3335     \internal
3336     convert a signal index from the method range to the signal range
3337  */
3338 static int methodIndexToSignalIndex(const QMetaObject **base, int signal_index)
3339 {
3340     if (signal_index < 0)
3341         return signal_index;
3342     const QMetaObject *metaObject = *base;
3343     while (metaObject && metaObject->methodOffset() > signal_index)
3344         metaObject = metaObject->superClass();
3345 
3346     if (metaObject) {
3347         int signalOffset, methodOffset;
3348         computeOffsets(metaObject, &signalOffset, &methodOffset);
3349         if (signal_index < metaObject->methodCount())
3350             signal_index = QMetaObjectPrivate::originalClone(metaObject, signal_index - methodOffset) + signalOffset;
3351         else
3352             signal_index = signal_index - methodOffset + signalOffset;
3353         *base = metaObject;
3354     }
3355     return signal_index;
3356 }
3357 
3358 /*!
3359    \internal
3360    \a types is a 0-terminated vector of meta types for queued
3361    connections.
3362 
3363    if \a signal_index is -1, then we effectively connect *all* signals
3364    from the sender to the receiver's slot
3365  */
3366 QMetaObject::Connection QMetaObject::connect(const QObject *sender, int signal_index,
3367                                              const QObject *receiver, int method_index, int type,
3368                                              int *types)
3369 {
3370     const QMetaObject *smeta = sender->metaObject();
3371     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3372     return Connection(QMetaObjectPrivate::connect(sender, signal_index, smeta,
3373                                        receiver, method_index,
3374                                        nullptr, //FIXME, we could speed this connection up by computing the relative index
3375                                        type, types));
3376 }
3377 
3378 /*!
3379     \internal
3380    Same as the QMetaObject::connect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3381 
3382     method_index is relative to the rmeta metaobject, if rmeta is \nullptr, then it is absolute index
3383 
3384     the QObjectPrivate::Connection* has a refcount of 2, so it must be passed to a QMetaObject::Connection
3385  */
3386 QObjectPrivate::Connection *QMetaObjectPrivate::connect(const QObject *sender,
3387                                  int signal_index, const QMetaObject *smeta,
3388                                  const QObject *receiver, int method_index,
3389                                  const QMetaObject *rmeta, int type, int *types)
3390 {
3391     QObject *s = const_cast<QObject *>(sender);
3392     QObject *r = const_cast<QObject *>(receiver);
3393 
3394     int method_offset = rmeta ? rmeta->methodOffset() : 0;
3395     Q_ASSERT(!rmeta || QMetaObjectPrivate::get(rmeta)->revision >= 6);
3396     QObjectPrivate::StaticMetaCallFunction callFunction = rmeta ? rmeta->d.static_metacall : nullptr;
3397 
3398     QOrderedMutexLocker locker(signalSlotLock(sender),
3399                                signalSlotLock(receiver));
3400 
3401     QObjectPrivate::ConnectionData *scd  = QObjectPrivate::get(s)->connections.loadRelaxed();
3402     if (type & Qt::UniqueConnection && scd) {
3403         if (scd->signalVectorCount() > signal_index) {
3404             const QObjectPrivate::Connection *c2 = scd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
3405 
3406             int method_index_absolute = method_index + method_offset;
3407 
3408             while (c2) {
3409                 if (!c2->isSlotObject && c2->receiver.loadRelaxed() == receiver && c2->method() == method_index_absolute)
3410                     return nullptr;
3411                 c2 = c2->nextConnectionList.loadRelaxed();
3412             }
3413         }
3414     }
3415     type &= ~Qt::UniqueConnection;
3416 
3417     const bool isSingleShot = type & Qt::SingleShotConnection;
3418     type &= ~Qt::SingleShotConnection;
3419 
3420     Q_ASSERT(type >= 0);
3421     Q_ASSERT(type <= 3);
3422 
3423     std::unique_ptr<QObjectPrivate::Connection> c{new QObjectPrivate::Connection};
3424     c->sender = s;
3425     c->signal_index = signal_index;
3426     c->receiver.storeRelaxed(r);
3427     QThreadData *td = r->d_func()->threadData;
3428     td->ref();
3429     c->receiverThreadData.storeRelaxed(td);
3430     c->method_relative = method_index;
3431     c->method_offset = method_offset;
3432     c->connectionType = type;
3433     c->isSlotObject = false;
3434     c->argumentTypes.storeRelaxed(types);
3435     c->callFunction = callFunction;
3436     c->isSingleShot = isSingleShot;
3437 
3438     QObjectPrivate::get(s)->addConnection(signal_index, c.get());
3439 
3440     locker.unlock();
3441     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3442     if (smethod.isValid())
3443         s->connectNotify(smethod);
3444 
3445     return c.release();
3446 }
3447 
3448 /*!
3449     \internal
3450  */
3451 bool QMetaObject::disconnect(const QObject *sender, int signal_index,
3452                              const QObject *receiver, int method_index)
3453 {
3454     const QMetaObject *smeta = sender->metaObject();
3455     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3456     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3457                                           receiver, method_index, nullptr);
3458 }
3459 
3460 /*!
3461     \internal
3462 
3463 Disconnect a single signal connection.  If QMetaObject::connect() has been called
3464 multiple times for the same sender, signal_index, receiver and method_index only
3465 one of these connections will be removed.
3466  */
3467 bool QMetaObject::disconnectOne(const QObject *sender, int signal_index,
3468                                 const QObject *receiver, int method_index)
3469 {
3470     const QMetaObject *smeta = sender->metaObject();
3471     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3472     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3473                                           receiver, method_index, nullptr,
3474                                           QMetaObjectPrivate::DisconnectOne);
3475 }
3476 
3477 /*!
3478     \internal
3479     Helper function to remove the connection from the senders list and set the receivers to \nullptr
3480  */
3481 bool QMetaObjectPrivate::disconnectHelper(QObjectPrivate::ConnectionData *connections, int signalIndex,
3482                                           const QObject *receiver, int method_index, void **slot,
3483                                           QBasicMutex *senderMutex, DisconnectType disconnectType)
3484 {
3485     bool success = false;
3486 
3487     auto &connectionList = connections->connectionsForSignal(signalIndex);
3488     auto *c = connectionList.first.loadRelaxed();
3489     while (c) {
3490         QObject *r = c->receiver.loadRelaxed();
3491         auto next = c->nextConnectionList.loadRelaxed();
3492         if (r && (receiver == nullptr || (r == receiver
3493                            && (method_index < 0 || (!c->isSlotObject && c->method() == method_index))
3494                            && (slot == nullptr || (c->isSlotObject && c->slotObj->compare(slot)))))) {
3495             bool needToUnlock = false;
3496             QBasicMutex *receiverMutex = nullptr;
3497             if (r) {
3498                 // protect c while we potentially unlock the mutex
3499                 c->ref();
3500                 receiverMutex = signalSlotLock(r);
3501                 // need to relock this receiver and sender in the correct order
3502                 needToUnlock = QOrderedMutexLocker::relock(senderMutex, receiverMutex);
3503                 c->deref(); // TODO: can we actually reach refcount zero here?
3504             }
3505             if (auto r2 = c->receiver.loadRelaxed()) {
3506                 if (r != r2) {
3507                     // we have the wrong mutex, and something in the list has changed
3508                     // retry with current connection
3509                     Q_ASSERT(needToUnlock);
3510                     receiverMutex->unlock();
3511                     continue;
3512                 }
3513                 // if we had to un- and relock, someone might have modified the list
3514                 next = c->nextConnectionList.loadRelaxed();
3515                 connections->removeConnection(c);
3516             }
3517 
3518             if (needToUnlock)
3519                 receiverMutex->unlock();
3520 
3521             success = true;
3522 
3523             if (disconnectType == DisconnectOne)
3524                 return success;
3525         }
3526         c = next;
3527     }
3528     return success;
3529 }
3530 
3531 /*!
3532     \internal
3533     Same as the QMetaObject::disconnect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3534  */
3535 bool QMetaObjectPrivate::disconnect(const QObject *sender,
3536                                     int signal_index, const QMetaObject *smeta,
3537                                     const QObject *receiver, int method_index, void **slot,
3538                                     DisconnectType disconnectType)
3539 {
3540     if (!sender)
3541         return false;
3542 
3543     QObject *s = const_cast<QObject *>(sender);
3544 
3545     QBasicMutex *senderMutex = signalSlotLock(sender);
3546     QBasicMutexLocker locker(senderMutex);
3547 
3548     QObjectPrivate::ConnectionData *scd = QObjectPrivate::get(s)->connections.loadRelaxed();
3549     if (!scd)
3550         return false;
3551 
3552     bool success = false;
3553     {
3554         // prevent incoming connections changing the connections->receivers while unlocked
3555         QObjectPrivate::ConnectionDataPointer connections(scd);
3556 
3557         if (signal_index < 0) {
3558             // remove from all connection lists
3559             for (int sig_index = -1; sig_index < scd->signalVectorCount(); ++sig_index) {
3560                 if (disconnectHelper(connections.data(), sig_index, receiver, method_index, slot, senderMutex, disconnectType))
3561                     success = true;
3562             }
3563         } else if (signal_index < scd->signalVectorCount()) {
3564             if (disconnectHelper(connections.data(), signal_index, receiver, method_index, slot, senderMutex, disconnectType))
3565                 success = true;
3566         }
3567     }
3568 
3569     locker.unlock();
3570     if (success) {
3571         scd->cleanOrphanedConnections(s);
3572 
3573         QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3574         if (smethod.isValid())
3575             s->disconnectNotify(smethod);
3576     }
3577 
3578     return success;
3579 }
3580 
3581 // Helpers for formatting the connect statements of connectSlotsByName()'s debug mode
3582 static QByteArray formatConnectionSignature(const char *className, const QMetaMethod &method)
3583 {
3584     const auto signature = method.methodSignature();
3585     Q_ASSERT(signature.endsWith(')'));
3586     const int openParen = signature.indexOf('(');
3587     const bool hasParameters = openParen >= 0 && openParen < signature.size() - 2;
3588     QByteArray result;
3589     if (hasParameters) {
3590         result += "qOverload<"
3591             + signature.mid(openParen + 1, signature.size() - openParen - 2) + ">(";
3592     }
3593     result += '&';
3594     result += className + QByteArrayLiteral("::") + method.name();
3595     if (hasParameters)
3596         result += ')';
3597     return result;
3598 }
3599 
3600 static QByteArray msgConnect(const QMetaObject *senderMo, const QByteArray &senderName,
3601                              const QMetaMethod &signal, const QObject *receiver, int receiverIndex)
3602 {
3603     const auto receiverMo = receiver->metaObject();
3604     const auto slot = receiverMo->method(receiverIndex);
3605     QByteArray message = QByteArrayLiteral("QObject::connect(")
3606         + senderName + ", " + formatConnectionSignature(senderMo->className(), signal)
3607         + ", " + receiver->objectName().toLatin1() + ", "
3608         + formatConnectionSignature(receiverMo->className(), slot) + ");";
3609     return message;
3610 }
3611 
3612 /*!
3613     \fn void QMetaObject::connectSlotsByName(QObject *object)
3614 
3615     Searches recursively for all child objects of the given \a object, and connects
3616     matching signals from them to slots of \a object that follow the following form:
3617 
3618     \snippet code/src_corelib_kernel_qobject.cpp 33
3619 
3620     Let's assume our object has a child object of type \c{QPushButton} with
3621     the \l{QObject::objectName}{object name} \c{button1}. The slot to catch the
3622     button's \c{clicked()} signal would be:
3623 
3624     \snippet code/src_corelib_kernel_qobject.cpp 34
3625 
3626     If \a object itself has a properly set object name, its own signals are also
3627     connected to its respective slots.
3628 
3629     \sa QObject::setObjectName()
3630  */
3631 void QMetaObject::connectSlotsByName(QObject *o)
3632 {
3633     if (!o)
3634         return;
3635     const QMetaObject *mo = o->metaObject();
3636     Q_ASSERT(mo);
3637     const QObjectList list = // list of all objects to look for matching signals including...
3638             o->findChildren<QObject *>() // all children of 'o'...
3639             << o; // and the object 'o' itself
3640 
3641     // for each method/slot of o ...
3642     for (int i = 0; i < mo->methodCount(); ++i) {
3643         const QByteArray slotSignature = mo->method(i).methodSignature();
3644         const char *slot = slotSignature.constData();
3645         Q_ASSERT(slot);
3646 
3647         // ...that starts with "on_", ...
3648         if (slot[0] != 'o' || slot[1] != 'n' || slot[2] != '_')
3649             continue;
3650 
3651         // ...we check each object in our list, ...
3652         bool foundIt = false;
3653         for (int j = 0; j < list.count(); ++j) {
3654             const QObject *co = list.at(j);
3655             const QByteArray coName = co->objectName().toLatin1();
3656 
3657             // ...discarding those whose objectName is not fitting the pattern "on_<objectName>_...", ...
3658             if (coName.isEmpty() || qstrncmp(slot + 3, coName.constData(), coName.size()) || slot[coName.size()+3] != '_')
3659                 continue;
3660 
3661             const char *signal = slot + coName.size() + 4; // the 'signal' part of the slot name
3662 
3663             // ...for the presence of a matching signal "on_<objectName>_<signal>".
3664             const QMetaObject *smeta;
3665             int sigIndex = co->d_func()->signalIndex(signal, &smeta);
3666             if (sigIndex < 0) {
3667                 // if no exactly fitting signal (name + complete parameter type list) could be found
3668                 // look for just any signal with the correct name and at least the slot's parameter list.
3669                 // Note: if more than one of those signals exist, the one that gets connected is
3670                 // chosen 'at random' (order of declaration in source file)
3671                 QList<QByteArray> compatibleSignals;
3672                 const QMetaObject *smo = co->metaObject();
3673                 int sigLen = int(qstrlen(signal)) - 1; // ignore the trailing ')'
3674                 for (int k = QMetaObjectPrivate::absoluteSignalCount(smo)-1; k >= 0; --k) {
3675                     const QMetaMethod method = QMetaObjectPrivate::signal(smo, k);
3676                     if (!qstrncmp(method.methodSignature().constData(), signal, sigLen)) {
3677                         smeta = method.enclosingMetaObject();
3678                         sigIndex = k;
3679                         compatibleSignals.prepend(method.methodSignature());
3680                     }
3681                 }
3682                 if (compatibleSignals.size() > 1)
3683                     qCWarning(lcConnectSlotsByName) << "QMetaObject::connectSlotsByName: Connecting slot" << slot
3684                                << "with the first of the following compatible signals:" << compatibleSignals;
3685             }
3686 
3687             if (sigIndex < 0)
3688                 continue;
3689 
3690             // we connect it...
3691             if (Connection(QMetaObjectPrivate::connect(co, sigIndex, smeta, o, i))) {
3692                 foundIt = true;
3693                 qCDebug(lcConnectSlotsByName, "%s",
3694                         msgConnect(smeta, coName, QMetaObjectPrivate::signal(smeta, sigIndex), o,  i).constData());
3695                 // ...and stop looking for further objects with the same name.
3696                 // Note: the Designer will make sure each object name is unique in the above
3697                 // 'list' but other code may create two child objects with the same name. In
3698                 // this case one is chosen 'at random'.
3699                 break;
3700             }
3701         }
3702         if (foundIt) {
3703             // we found our slot, now skip all overloads
3704             while (mo->method(i + 1).attributes() & QMetaMethod::Cloned)
3705                 ++i;
3706         } else if (!(mo->method(i).attributes() & QMetaMethod::Cloned)) {
3707             // check if the slot has the following signature: "on_..._...(..."
3708             int iParen = slotSignature.indexOf('(');
3709             int iLastUnderscore = slotSignature.lastIndexOf('_', iParen - 1);
3710             if (iLastUnderscore > 3)
3711                 qCWarning(lcConnectSlotsByName,
3712                           "QMetaObject::connectSlotsByName: No matching signal for %s", slot);
3713         }
3714     }
3715 }
3716 
3717 /*!
3718      \internal
3719      A small RAII helper for QSlotObjectBase.
3720      Calls ref on construction and destroyLastRef in its dtor.
3721      Allows construction from a nullptr in which case it does nothing.
3722  */
3723 struct SlotObjectGuard {
3724     SlotObjectGuard() = default;
3725     // move would be fine, but we do not need it currently
3726     Q_DISABLE_COPY_MOVE(SlotObjectGuard)
3727     explicit SlotObjectGuard(QtPrivate::QSlotObjectBase *slotObject)
3728         : m_slotObject(slotObject)
3729     {
3730         if (m_slotObject)
3731             m_slotObject->ref();
3732     }
3733 
3734     QtPrivate::QSlotObjectBase const *operator->() const
3735     { return m_slotObject; }
3736 
3737     QtPrivate::QSlotObjectBase *operator->()
3738     { return m_slotObject; }
3739 
3740     ~SlotObjectGuard() {
3741         if (m_slotObject)
3742             m_slotObject->destroyIfLastRef();
3743     }
3744 private:
3745     QtPrivate::QSlotObjectBase *m_slotObject = nullptr;
3746 };
3747 
3748 /*!
3749     \internal
3750 
3751     \a signal must be in the signal index range (see QObjectPrivate::signalIndex()).
3752 */
3753 static void queued_activate(QObject *sender, int signal, QObjectPrivate::Connection *c, void **argv)
3754 {
3755     const int *argumentTypes = c->argumentTypes.loadRelaxed();
3756     if (!argumentTypes) {
3757         QMetaMethod m = QMetaObjectPrivate::signal(sender->metaObject(), signal);
3758         argumentTypes = queuedConnectionTypes(m);
3759         if (!argumentTypes) // cannot queue arguments
3760             argumentTypes = &DIRECT_CONNECTION_ONLY;
3761         if (!c->argumentTypes.testAndSetOrdered(nullptr, argumentTypes)) {
3762             if (argumentTypes != &DIRECT_CONNECTION_ONLY)
3763                 delete[] argumentTypes;
3764             argumentTypes = c->argumentTypes.loadRelaxed();
3765         }
3766     }
3767     if (argumentTypes == &DIRECT_CONNECTION_ONLY) // cannot activate
3768         return;
3769     int nargs = 1; // include return type
3770     while (argumentTypes[nargs - 1])
3771         ++nargs;
3772 
3773     QBasicMutexLocker locker(signalSlotLock(c->receiver.loadRelaxed()));
3774     QObject *receiver = c->receiver.loadRelaxed();
3775     if (!receiver) {
3776         // the connection has been disconnected before we got the lock
3777         return;
3778     }
3779 
3780     SlotObjectGuard slotObjectGuard { c->isSlotObject ? c->slotObj : nullptr };
3781     locker.unlock();
3782 
3783     QMetaCallEvent *ev = c->isSlotObject ?
3784         new QMetaCallEvent(c->slotObj, sender, signal, nargs) :
3785         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction, sender, signal, nargs);
3786 
3787     void **args = ev->args();
3788     QMetaType *types = ev->types();
3789 
3790     types[0] = QMetaType(); // return type
3791     args[0] = nullptr; // return value
3792 
3793     if (nargs > 1) {
3794         for (int n = 1; n < nargs; ++n)
3795             types[n] = QMetaType(argumentTypes[n - 1]);
3796 
3797         for (int n = 1; n < nargs; ++n)
3798             args[n] = types[n].create(argv[n]);
3799     }
3800 
3801     if (c->isSingleShot && !QObjectPrivate::disconnect(c)) {
3802         delete ev;
3803         return;
3804     }
3805 
3806     locker.relock();
3807     if (!c->isSingleShot && !c->receiver.loadRelaxed()) {
3808         // the connection has been disconnected while we were unlocked
3809         locker.unlock();
3810         delete ev;
3811         return;
3812     }
3813 
3814     QCoreApplication::postEvent(receiver, ev);
3815 }
3816 
3817 template <bool callbacks_enabled>
3818 void doActivate(QObject *sender, int signal_index, void **argv)
3819 {
3820     QObjectPrivate *sp = QObjectPrivate::get(sender);
3821 
3822     if (sp->blockSig)
3823         return;
3824 
3825     Q_TRACE_SCOPE(QMetaObject_activate, sender, signal_index);
3826 
3827     if (sp->isDeclarativeSignalConnected(signal_index)
3828             && QAbstractDeclarativeData::signalEmitted) {
3829         Q_TRACE_SCOPE(QMetaObject_activate_declarative_signal, sender, signal_index);
3830         QAbstractDeclarativeData::signalEmitted(sp->declarativeData, sender,
3831                                                 signal_index, argv);
3832     }
3833 
3834     const QSignalSpyCallbackSet *signal_spy_set = callbacks_enabled ? qt_signal_spy_callback_set.loadAcquire() : nullptr;
3835 
3836     void *empty_argv[] = { nullptr };
3837     if (!argv)
3838         argv = empty_argv;
3839 
3840     if (!sp->maybeSignalConnected(signal_index)) {
3841         // The possible declarative connection is done, and nothing else is connected
3842         if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3843             signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3844         if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3845             signal_spy_set->signal_end_callback(sender, signal_index);
3846         return;
3847     }
3848 
3849     if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3850         signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3851 
3852     bool senderDeleted = false;
3853     {
3854     Q_ASSERT(sp->connections.loadAcquire());
3855     QObjectPrivate::ConnectionDataPointer connections(sp->connections.loadRelaxed());
3856     QObjectPrivate::SignalVector *signalVector = connections->signalVector.loadRelaxed();
3857 
3858     const QObjectPrivate::ConnectionList *list;
3859     if (signal_index < signalVector->count())
3860         list = &signalVector->at(signal_index);
3861     else
3862         list = &signalVector->at(-1);
3863 
3864     Qt::HANDLE currentThreadId = QThread::currentThreadId();
3865     bool inSenderThread = currentThreadId == QObjectPrivate::get(sender)->threadData.loadRelaxed()->threadId.loadRelaxed();
3866 
3867     // We need to check against the highest connection id to ensure that signals added
3868     // during the signal emission are not emitted in this emission.
3869     uint highestConnectionId = connections->currentConnectionId.loadRelaxed();
3870     do {
3871         QObjectPrivate::Connection *c = list->first.loadRelaxed();
3872         if (!c)
3873             continue;
3874 
3875         do {
3876             QObject * const receiver = c->receiver.loadRelaxed();
3877             if (!receiver)
3878                 continue;
3879 
3880             QThreadData *td = c->receiverThreadData.loadRelaxed();
3881             if (!td)
3882                 continue;
3883 
3884             bool receiverInSameThread;
3885             if (inSenderThread) {
3886                 receiverInSameThread = currentThreadId == td->threadId.loadRelaxed();
3887             } else {
3888                 // need to lock before reading the threadId, because moveToThread() could interfere
3889                 QMutexLocker lock(signalSlotLock(receiver));
3890                 receiverInSameThread = currentThreadId == td->threadId.loadRelaxed();
3891             }
3892 
3893 
3894             // determine if this connection should be sent immediately or
3895             // put into the event queue
3896             if ((c->connectionType == Qt::AutoConnection && !receiverInSameThread)
3897                 || (c->connectionType == Qt::QueuedConnection)) {
3898                 queued_activate(sender, signal_index, c, argv);
3899                 continue;
3900 #if QT_CONFIG(thread)
3901             } else if (c->connectionType == Qt::BlockingQueuedConnection) {
3902                 if (receiverInSameThread) {
3903                     qWarning("Qt: Dead lock detected while activating a BlockingQueuedConnection: "
3904                     "Sender is %s(%p), receiver is %s(%p)",
3905                     sender->metaObject()->className(), sender,
3906                     receiver->metaObject()->className(), receiver);
3907                 }
3908 
3909                 if (c->isSingleShot && !QObjectPrivate::disconnect(c))
3910                     continue;
3911 
3912                 QSemaphore semaphore;
3913                 {
3914                     QBasicMutexLocker locker(signalSlotLock(receiver));
3915                     if (!c->isSingleShot && !c->receiver.loadAcquire())
3916                         continue;
3917                     QMetaCallEvent *ev = c->isSlotObject ?
3918                         new QMetaCallEvent(c->slotObj, sender, signal_index, argv, &semaphore) :
3919                         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction,
3920                                            sender, signal_index, argv, &semaphore);
3921                     QCoreApplication::postEvent(receiver, ev);
3922                 }
3923                 semaphore.acquire();
3924                 continue;
3925 #endif
3926             }
3927 
3928             if (c->isSingleShot && !QObjectPrivate::disconnect(c))
3929                 continue;
3930 
3931             QObjectPrivate::Sender senderData(receiverInSameThread ? receiver : nullptr, sender, signal_index);
3932 
3933             if (c->isSlotObject) {
3934                 SlotObjectGuard obj{c->slotObj};
3935 
3936                 {
3937                     Q_TRACE_SCOPE(QMetaObject_activate_slot_functor, obj.get());
3938                     obj->call(receiver, argv);
3939                 }
3940             } else if (c->callFunction && c->method_offset <= receiver->metaObject()->methodOffset()) {
3941                 //we compare the vtable to make sure we are not in the destructor of the object.
3942                 const int method_relative = c->method_relative;
3943                 const auto callFunction = c->callFunction;
3944                 const int methodIndex = (Q_HAS_TRACEPOINTS || callbacks_enabled) ? c->method() : 0;
3945                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr)
3946                     signal_spy_set->slot_begin_callback(receiver, methodIndex, argv);
3947 
3948                 {
3949                     Q_TRACE_SCOPE(QMetaObject_activate_slot, receiver, methodIndex);
3950                     callFunction(receiver, QMetaObject::InvokeMetaMethod, method_relative, argv);
3951                 }
3952 
3953                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3954                     signal_spy_set->slot_end_callback(receiver, methodIndex);
3955             } else {
3956                 const int method = c->method_relative + c->method_offset;
3957 
3958                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr) {
3959                     signal_spy_set->slot_begin_callback(receiver, method, argv);
3960                 }
3961 
3962                 {
3963                     Q_TRACE_SCOPE(QMetaObject_activate_slot, receiver, method);
3964                     QMetaObject::metacall(receiver, QMetaObject::InvokeMetaMethod, method, argv);
3965                 }
3966 
3967                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3968                     signal_spy_set->slot_end_callback(receiver, method);
3969             }
3970         } while ((c = c->nextConnectionList.loadRelaxed()) != nullptr && c->id <= highestConnectionId);
3971 
3972     } while (list != &signalVector->at(-1) &&
3973         //start over for all signals;
3974         ((list = &signalVector->at(-1)), true));
3975 
3976         if (connections->currentConnectionId.loadRelaxed() == 0)
3977             senderDeleted = true;
3978     }
3979     if (!senderDeleted) {
3980         sp->connections.loadRelaxed()->cleanOrphanedConnections(sender);
3981 
3982         if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3983             signal_spy_set->signal_end_callback(sender, signal_index);
3984     }
3985 }
3986 
3987 /*!
3988     \internal
3989  */
3990 void QMetaObject::activate(QObject *sender, const QMetaObject *m, int local_signal_index,
3991                            void **argv)
3992 {
3993     int signal_index = local_signal_index + QMetaObjectPrivate::signalOffset(m);
3994 
3995     if (Q_UNLIKELY(qt_signal_spy_callback_set.loadRelaxed()))
3996         doActivate<true>(sender, signal_index, argv);
3997     else
3998         doActivate<false>(sender, signal_index, argv);
3999 }
4000 
4001 /*!
4002     \internal
4003  */
4004 void QMetaObject::activate(QObject *sender, int signalOffset, int local_signal_index, void **argv)
4005 {
4006     int signal_index = signalOffset + local_signal_index;
4007 
4008     if (Q_UNLIKELY(qt_signal_spy_callback_set.loadRelaxed()))
4009         doActivate<true>(sender, signal_index, argv);
4010     else
4011         doActivate<false>(sender, signal_index, argv);
4012 }
4013 
4014 /*!
4015     \internal
4016    signal_index comes from indexOfMethod()
4017 */
4018 void QMetaObject::activate(QObject *sender, int signal_index, void **argv)
4019 {
4020     const QMetaObject *mo = sender->metaObject();
4021     while (mo->methodOffset() > signal_index)
4022         mo = mo->superClass();
4023     activate(sender, mo, signal_index - mo->methodOffset(), argv);
4024 }
4025 
4026 /*!
4027     \internal
4028     Returns the signal index used in the internal connections->receivers vector.
4029 
4030     It is different from QMetaObject::indexOfSignal():  indexOfSignal is the same as indexOfMethod
4031     while QObjectPrivate::signalIndex is smaller because it doesn't give index to slots.
4032 
4033     If \a meta is not \nullptr, it is set to the meta-object where the signal was found.
4034 */
4035 int QObjectPrivate::signalIndex(const char *signalName,
4036                                 const QMetaObject **meta) const
4037 {
4038     Q_Q(const QObject);
4039     const QMetaObject *base = q->metaObject();
4040     Q_ASSERT(QMetaObjectPrivate::get(base)->revision >= 7);
4041     QArgumentTypeArray types;
4042     QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signalName, types);
4043     int relative_index = QMetaObjectPrivate::indexOfSignalRelative(
4044             &base, name, types.size(), types.constData());
4045     if (relative_index < 0)
4046         return relative_index;
4047     relative_index = QMetaObjectPrivate::originalClone(base, relative_index);
4048     if (meta)
4049         *meta = base;
4050     return relative_index + QMetaObjectPrivate::signalOffset(base);
4051 }
4052 
4053 /*****************************************************************************
4054   Properties
4055  *****************************************************************************/
4056 
4057 #ifndef QT_NO_PROPERTIES
4058 
4059 /*!
4060   Sets the value of the object's \a name property to \a value.
4061 
4062   If the property is defined in the class using Q_PROPERTY then
4063   true is returned on success and false otherwise. If the property
4064   is not defined using Q_PROPERTY, and therefore not listed in the
4065   meta-object, it is added as a dynamic property and false is returned.
4066 
4067   Information about all available properties is provided through the
4068   metaObject() and dynamicPropertyNames().
4069 
4070   Dynamic properties can be queried again using property() and can be
4071   removed by setting the property value to an invalid QVariant.
4072   Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent
4073   to be sent to the object.
4074 
4075   \b{Note:} Dynamic properties starting with "_q_" are reserved for internal
4076   purposes.
4077 
4078   \sa property(), metaObject(), dynamicPropertyNames(), QMetaProperty::write()
4079 */
4080 bool QObject::setProperty(const char *name, const QVariant &value)
4081 {
4082     Q_D(QObject);
4083     const QMetaObject *meta = metaObject();
4084     if (!name || !meta)
4085         return false;
4086 
4087     int id = meta->indexOfProperty(name);
4088     if (id < 0) {
4089         if (!d->extraData)
4090             d->extraData = new QObjectPrivate::ExtraData(d);
4091 
4092         const int idx = d->extraData->propertyNames.indexOf(name);
4093 
4094         if (!value.isValid()) {
4095             if (idx == -1)
4096                 return false;
4097             d->extraData->propertyNames.removeAt(idx);
4098             d->extraData->propertyValues.removeAt(idx);
4099         } else {
4100             if (idx == -1) {
4101                 d->extraData->propertyNames.append(name);
4102                 d->extraData->propertyValues.append(value);
4103             } else {
4104                 if (value.userType() == d->extraData->propertyValues.at(idx).userType()
4105                         && value == d->extraData->propertyValues.at(idx))
4106                     return false;
4107                 d->extraData->propertyValues[idx] = value;
4108             }
4109         }
4110 
4111         QDynamicPropertyChangeEvent ev(name);
4112         QCoreApplication::sendEvent(this, &ev);
4113 
4114         return false;
4115     }
4116     QMetaProperty p = meta->property(id);
4117 #ifndef QT_NO_DEBUG
4118     if (!p.isWritable())
4119         qWarning("%s::setProperty: Property \"%s\" invalid,"
4120                  " read-only or does not exist", metaObject()->className(), name);
4121 #endif
4122     return p.write(this, value);
4123 }
4124 
4125 /*!
4126   Returns the value of the object's \a name property.
4127 
4128   If no such property exists, the returned variant is invalid.
4129 
4130   Information about all available properties is provided through the
4131   metaObject() and dynamicPropertyNames().
4132 
4133   \sa setProperty(), QVariant::isValid(), metaObject(), dynamicPropertyNames()
4134 */
4135 QVariant QObject::property(const char *name) const
4136 {
4137     Q_D(const QObject);
4138     const QMetaObject *meta = metaObject();
4139     if (!name || !meta)
4140         return QVariant();
4141 
4142     int id = meta->indexOfProperty(name);
4143     if (id < 0) {
4144         if (!d->extraData)
4145             return QVariant();
4146         const int i = d->extraData->propertyNames.indexOf(name);
4147         return d->extraData->propertyValues.value(i);
4148     }
4149     QMetaProperty p = meta->property(id);
4150 #ifndef QT_NO_DEBUG
4151     if (!p.isReadable())
4152         qWarning("%s::property: Property \"%s\" invalid or does not exist",
4153                  metaObject()->className(), name);
4154 #endif
4155     return p.read(this);
4156 }
4157 
4158 /*!
4159     \since 4.2
4160 
4161     Returns the names of all properties that were dynamically added to
4162     the object using setProperty().
4163 */
4164 QList<QByteArray> QObject::dynamicPropertyNames() const
4165 {
4166     Q_D(const QObject);
4167     if (d->extraData)
4168         return d->extraData->propertyNames;
4169     return QList<QByteArray>();
4170 }
4171 
4172 #endif // QT_NO_PROPERTIES
4173 
4174 
4175 /*****************************************************************************
4176   QObject debugging output routines.
4177  *****************************************************************************/
4178 
4179 static void dumpRecursive(int level, const QObject *object)
4180 {
4181     if (object) {
4182         QByteArray buf;
4183         buf.fill(' ', level / 2 * 8);
4184         if (level % 2)
4185             buf += "    ";
4186         QString name = object->objectName();
4187         QString flags = QLatin1String("");
4188 #if 0
4189         if (qApp->focusWidget() == object)
4190             flags += 'F';
4191         if (object->isWidgetType()) {
4192             QWidget * w = (QWidget *)object;
4193             if (w->isVisible()) {
4194                 QString t("<%1,%2,%3,%4>");
4195                 flags += t.arg(w->x()).arg(w->y()).arg(w->width()).arg(w->height());
4196             } else {
4197                 flags += 'I';
4198             }
4199         }
4200 #endif
4201         qDebug("%s%s::%s %s", (const char*)buf, object->metaObject()->className(), name.toLocal8Bit().data(),
4202                flags.toLatin1().data());
4203         QObjectList children = object->children();
4204         if (!children.isEmpty()) {
4205             for (int i = 0; i < children.size(); ++i)
4206                 dumpRecursive(level+1, children.at(i));
4207         }
4208     }
4209 }
4210 
4211 
4212 /*!
4213     Dumps a tree of children to the debug output.
4214 
4215     \note before Qt 5.9, this function was not const.
4216 
4217     \sa dumpObjectInfo()
4218 */
4219 
4220 void QObject::dumpObjectTree() const
4221 {
4222     dumpRecursive(0, this);
4223 }
4224 
4225 /*!
4226     Dumps information about signal connections, etc. for this object
4227     to the debug output.
4228 
4229     \note before Qt 5.9, this function was not const.
4230 
4231     \sa dumpObjectTree()
4232 */
4233 
4234 void QObject::dumpObjectInfo() const
4235 {
4236     qDebug("OBJECT %s::%s", metaObject()->className(),
4237            objectName().isEmpty() ? "unnamed" : objectName().toLocal8Bit().data());
4238 
4239     Q_D(const QObject);
4240     QBasicMutexLocker locker(signalSlotLock(this));
4241 
4242     // first, look for connections where this object is the sender
4243     qDebug("  SIGNALS OUT");
4244 
4245     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
4246     if (cd && cd->signalVectorCount() > 0) {
4247         QObjectPrivate::SignalVector *signalVector = cd->signalVector.loadRelaxed();
4248         for (int signal_index = 0; signal_index < signalVector->count(); ++signal_index) {
4249             const QObjectPrivate::Connection *c = signalVector->at(signal_index).first.loadRelaxed();
4250             if (!c)
4251                 continue;
4252             const QMetaMethod signal = QMetaObjectPrivate::signal(metaObject(), signal_index);
4253             qDebug("        signal: %s", signal.methodSignature().constData());
4254 
4255             // receivers
4256             while (c) {
4257                 if (!c->receiver.loadRelaxed()) {
4258                     qDebug("          <Disconnected receiver>");
4259                     c = c->nextConnectionList.loadRelaxed();
4260                     continue;
4261                 }
4262                 if (c->isSlotObject) {
4263                     qDebug("          <functor or function pointer>");
4264                     c = c->nextConnectionList.loadRelaxed();
4265                     continue;
4266                 }
4267                 const QMetaObject *receiverMetaObject = c->receiver.loadRelaxed()->metaObject();
4268                 const QMetaMethod method = receiverMetaObject->method(c->method());
4269                 qDebug("          --> %s::%s %s",
4270                        receiverMetaObject->className(),
4271                        c->receiver.loadRelaxed()->objectName().isEmpty() ? "unnamed" : qPrintable(c->receiver.loadRelaxed()->objectName()),
4272                        method.methodSignature().constData());
4273                 c = c->nextConnectionList.loadRelaxed();
4274             }
4275         }
4276     } else {
4277         qDebug( "        <None>" );
4278     }
4279 
4280     // now look for connections where this object is the receiver
4281     qDebug("  SIGNALS IN");
4282 
4283     if (cd && cd->senders) {
4284         for (QObjectPrivate::Connection *s = cd->senders; s; s = s->next) {
4285             QByteArray slotName = QByteArrayLiteral("<unknown>");
4286             if (!s->isSlotObject) {
4287                 const QMetaMethod slot = metaObject()->method(s->method());
4288                 slotName = slot.methodSignature();
4289             }
4290             qDebug("          <-- %s::%s %s",
4291                    s->sender->metaObject()->className(),
4292                    s->sender->objectName().isEmpty() ? "unnamed" : qPrintable(s->sender->objectName()),
4293                    slotName.constData());
4294         }
4295     } else {
4296         qDebug("        <None>");
4297     }
4298 }
4299 
4300 
4301 #ifndef QT_NO_DEBUG_STREAM
4302 QDebug operator<<(QDebug dbg, const QObject *o)
4303 {
4304     QDebugStateSaver saver(dbg);
4305     if (!o)
4306         return dbg << "QObject(0x0)";
4307     dbg.nospace() << o->metaObject()->className() << '(' << (const void *)o;
4308     if (!o->objectName().isEmpty())
4309         dbg << ", name = " << o->objectName();
4310     dbg << ')';
4311     return dbg;
4312 }
4313 #endif
4314 
4315 /*!
4316     \macro Q_CLASSINFO(Name, Value)
4317     \relates QObject
4318 
4319     This macro associates extra information to the class, which is available
4320     using QObject::metaObject(). Qt makes only limited use of this feature in
4321     \l{Qt D-Bus} and \l{Qt QML} modules.
4322 
4323     The extra information takes the form of a \a Name string and a \a Value
4324     literal string.
4325 
4326     Example:
4327 
4328     \snippet code/src_corelib_kernel_qobject.cpp 35
4329 
4330     \sa QMetaObject::classInfo()
4331     \sa {Using Qt D-Bus Adaptors}
4332     \sa {Extending QML}
4333 */
4334 
4335 /*!
4336     \macro Q_INTERFACES(...)
4337     \relates QObject
4338 
4339     This macro tells Qt which interfaces the class implements. This
4340     is used when implementing plugins.
4341 
4342     Example:
4343 
4344     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 1
4345     \dots
4346     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 3
4347 
4348     See the \l{tools/plugandpaint/plugins/basictools}{Plug & Paint
4349     Basic Tools} example for details.
4350 
4351     \sa Q_DECLARE_INTERFACE(), Q_PLUGIN_METADATA(), {How to Create Qt Plugins}
4352 */
4353 
4354 /*!
4355     \macro Q_PROPERTY(...)
4356     \relates QObject
4357 
4358     This macro is used for declaring properties in classes that
4359     inherit QObject. Properties behave like class data members, but
4360     they have additional features accessible through the \l
4361     {Meta-Object System}.
4362 
4363     \snippet code/doc_src_properties.cpp 0
4364 
4365     The property name and type and the \c READ function are required.
4366     The type can be any type supported by QVariant, or it can be a
4367     user-defined type.  The other items are optional, but a \c WRITE
4368     function is common.  The attributes default to true except \c USER,
4369     which defaults to false.
4370 
4371     For example:
4372 
4373     \snippet code/src_corelib_kernel_qobject.cpp 37
4374 
4375     For more details about how to use this macro, and a more detailed
4376     example of its use, see the discussion on \l {Qt's Property System}.
4377 
4378     \sa {Qt's Property System}
4379 */
4380 
4381 /*!
4382     \macro Q_ENUMS(...)
4383     \relates QObject
4384     \deprecated
4385 
4386     In new code, you should prefer the use of the Q_ENUM() macro, which makes the
4387     type available also to the meta type system.
4388     For instance, QMetaEnum::fromType() will not work with types declared with Q_ENUMS().
4389 
4390     This macro registers one or several enum types to the meta-object
4391     system.
4392 
4393     If you want to register an enum that is declared in another class,
4394     the enum must be fully qualified with the name of the class
4395     defining it. In addition, the class \e defining the enum has to
4396     inherit QObject as well as declare the enum using Q_ENUMS().
4397 
4398     \sa {Qt's Property System}
4399 */
4400 
4401 /*!
4402     \macro Q_FLAGS(...)
4403     \relates QObject
4404     \deprecated
4405 
4406     This macro registers one or several \l{QFlags}{flags types} with the
4407     meta-object system. It is typically used in a class definition to declare
4408     that values of a given enum can be used as flags and combined using the
4409     bitwise OR operator.
4410 
4411     \note This macro takes care of registering individual flag values
4412     with the meta-object system, so it is unnecessary to use Q_ENUMS()
4413     in addition to this macro.
4414 
4415     In new code, you should prefer the use of the Q_FLAG() macro, which makes the
4416     type available also to the meta type system.
4417 
4418     \sa {Qt's Property System}
4419 */
4420 
4421 /*!
4422     \macro Q_ENUM(...)
4423     \relates QObject
4424     \since 5.5
4425 
4426     This macro registers an enum type with the meta-object system.
4427     It must be placed after the enum declaration in a class that has the Q_OBJECT or the
4428     Q_GADGET macro. For namespaces use \l Q_ENUM_NS() instead.
4429 
4430     For example:
4431 
4432     \snippet code/src_corelib_kernel_qobject.cpp 38
4433 
4434     Enumerations that are declared with Q_ENUM have their QMetaEnum registered in the
4435     enclosing QMetaObject. You can also use QMetaEnum::fromType() to get the QMetaEnum.
4436 
4437     Registered enumerations are automatically registered also to the Qt meta
4438     type system, making them known to QMetaType without the need to use
4439     Q_DECLARE_METATYPE(). This will enable useful features; for example, if used
4440     in a QVariant, you can convert them to strings. Likewise, passing them to
4441     QDebug will print out their names.
4442 
4443     Mind that the enum values are stored as signed \c int in the meta object system.
4444     Registering enumerations with values outside the range of values valid for \c int
4445     will lead to overflows and potentially undefined behavior when accessing them through
4446     the meta object system. QML, for example, does access registered enumerations through
4447     the meta object system.
4448 
4449     \sa {Qt's Property System}
4450 */
4451 
4452 
4453 /*!
4454     \macro Q_FLAG(...)
4455     \relates QObject
4456     \since 5.5
4457 
4458     This macro registers a single \l{QFlags}{flags type} with the
4459     meta-object system. It is typically used in a class definition to declare
4460     that values of a given enum can be used as flags and combined using the
4461     bitwise OR operator. For namespaces use \l Q_FLAG_NS() instead.
4462 
4463     The macro must be placed after the enum declaration. The declaration of
4464     the flags type is done using the \l Q_DECLARE_FLAGS() macro.
4465 
4466     For example, in QItemSelectionModel, the
4467     \l{QItemSelectionModel::SelectionFlags}{SelectionFlags} flag is
4468     declared in the following way:
4469 
4470     \snippet code/src_corelib_kernel_qobject.cpp 39
4471 
4472     \note The Q_FLAG macro takes care of registering individual flag values
4473     with the meta-object system, so it is unnecessary to use Q_ENUM()
4474     in addition to this macro.
4475 
4476     \sa {Qt's Property System}
4477 */
4478 
4479 /*!
4480     \macro Q_ENUM_NS(...)
4481     \relates QObject
4482     \since 5.8
4483 
4484     This macro registers an enum type with the meta-object system.
4485     It must be placed after the enum declaration in a namespace that
4486     has the Q_NAMESPACE macro. It is the same as \l Q_ENUM but in a
4487     namespace.
4488 
4489     Enumerations that are declared with Q_ENUM_NS have their QMetaEnum
4490     registered in the enclosing QMetaObject. You can also use
4491     QMetaEnum::fromType() to get the QMetaEnum.
4492 
4493     Registered enumerations are automatically registered also to the Qt meta
4494     type system, making them known to QMetaType without the need to use
4495     Q_DECLARE_METATYPE(). This will enable useful features; for example, if
4496     used in a QVariant, you can convert them to strings. Likewise, passing them
4497     to QDebug will print out their names.
4498 
4499     Mind that the enum values are stored as signed \c int in the meta object system.
4500     Registering enumerations with values outside the range of values valid for \c int
4501     will lead to overflows and potentially undefined behavior when accessing them through
4502     the meta object system. QML, for example, does access registered enumerations through
4503     the meta object system.
4504 
4505     \sa {Qt's Property System}
4506 */
4507 
4508 
4509 /*!
4510     \macro Q_FLAG_NS(...)
4511     \relates QObject
4512     \since 5.8
4513 
4514     This macro registers a single \l{QFlags}{flags type} with the
4515     meta-object system. It is used in a namespace that has the
4516     Q_NAMESPACE macro, to declare that values of a given enum can be
4517     used as flags and combined using the bitwise OR operator.
4518     It is the same as \l Q_FLAG but in a namespace.
4519 
4520     The macro must be placed after the enum declaration.
4521 
4522     \note The Q_FLAG_NS macro takes care of registering individual flag
4523     values with the meta-object system, so it is unnecessary to use
4524     Q_ENUM_NS() in addition to this macro.
4525 
4526     \sa {Qt's Property System}
4527 */
4528 
4529 
4530 /*!
4531     \macro Q_OBJECT
4532     \relates QObject
4533 
4534     The Q_OBJECT macro must appear in the private section of a class
4535     definition that declares its own signals and slots or that uses
4536     other services provided by Qt's meta-object system.
4537 
4538     For example:
4539 
4540     \snippet signalsandslots/signalsandslots.h 1
4541     \codeline
4542     \snippet signalsandslots/signalsandslots.h 2
4543     \snippet signalsandslots/signalsandslots.h 3
4544 
4545     \note This macro requires the class to be a subclass of QObject. Use
4546     Q_GADGET instead of Q_OBJECT to enable the meta object system's support
4547     for enums in a class that is not a QObject subclass.
4548 
4549     \sa {Meta-Object System}, {Signals and Slots}, {Qt's Property System}
4550 */
4551 
4552 /*!
4553     \macro Q_GADGET
4554     \relates QObject
4555 
4556     The Q_GADGET macro is a lighter version of the Q_OBJECT macro for classes
4557     that do not inherit from QObject but still want to use some of the
4558     reflection capabilities offered by QMetaObject. Just like the Q_OBJECT
4559     macro, it must appear in the private section of a class definition.
4560 
4561     Q_GADGETs can have Q_ENUM, Q_PROPERTY and Q_INVOKABLE, but they cannot have
4562     signals or slots.
4563 
4564     Q_GADGET makes a class member, \c{staticMetaObject}, available.
4565     \c{staticMetaObject} is of type QMetaObject and provides access to the
4566     enums declared with Q_ENUMS.
4567 */
4568 
4569 /*!
4570     \macro Q_NAMESPACE
4571     \relates QObject
4572     \since 5.8
4573 
4574     The Q_NAMESPACE macro can be used to add QMetaObject capabilities
4575     to a namespace.
4576 
4577     Q_NAMESPACEs can have Q_CLASSINFO, Q_ENUM_NS, Q_FLAG_NS, but they
4578     cannot have Q_ENUM, Q_FLAG, Q_PROPERTY, Q_INVOKABLE, signals nor slots.
4579 
4580     Q_NAMESPACE makes an external variable, \c{staticMetaObject}, available.
4581     \c{staticMetaObject} is of type QMetaObject and provides access to the
4582     enums declared with Q_ENUM_NS/Q_FLAG_NS.
4583 
4584     For example:
4585 
4586     \code
4587     namespace test {
4588     Q_NAMESPACE
4589     ...
4590     \endcode
4591 
4592     \sa Q_NAMESPACE_EXPORT
4593 */
4594 
4595 /*!
4596     \macro Q_NAMESPACE_EXPORT(EXPORT_MACRO)
4597     \relates QObject
4598     \since 5.14
4599 
4600     The Q_NAMESPACE_EXPORT macro can be used to add QMetaObject capabilities
4601     to a namespace.
4602 
4603     It works exactly like the Q_NAMESPACE macro. However, the external
4604     \c{staticMetaObject} variable that gets defined in the namespace
4605     is declared with the supplied \a EXPORT_MACRO qualifier. This is
4606     useful if the object needs to be exported from a dynamic library.
4607 
4608     For example:
4609 
4610     \code
4611     namespace test {
4612     Q_NAMESPACE_EXPORT(EXPORT_MACRO)
4613     ...
4614     \endcode
4615 
4616     \sa Q_NAMESPACE, {Creating Shared Libraries}
4617 */
4618 
4619 /*!
4620     \macro Q_MOC_INCLUDE
4621     \relates QObject
4622     \since 6.0
4623 
4624     The Q_MOC_INCLUDE macro can be used within or outside a class, and tell the
4625     \l{moc}{Meta Object Compiler} to add an include.
4626 
4627     \code
4628         // Put this in your code and the generated code will include this header.
4629         Q_MOC_INCLUDE("myheader.h")
4630     \endcode
4631 
4632     This is useful if the types you use as properties or signal/slots arguments
4633     are forward declared.
4634 */
4635 
4636 /*!
4637     \macro Q_SIGNALS
4638     \relates QObject
4639 
4640     Use this macro to replace the \c signals keyword in class
4641     declarations, when you want to use Qt Signals and Slots with a
4642     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4643 
4644     The macro is normally used when \c no_keywords is specified with
4645     the \c CONFIG variable in the \c .pro file, but it can be used
4646     even when \c no_keywords is \e not specified.
4647 */
4648 
4649 /*!
4650     \macro Q_SIGNAL
4651     \relates QObject
4652 
4653     This is an additional macro that allows you to mark a single
4654     function as a signal. It can be quite useful, especially when you
4655     use a 3rd-party source code parser which doesn't understand a \c
4656     signals or \c Q_SIGNALS groups.
4657 
4658     Use this macro to replace the \c signals keyword in class
4659     declarations, when you want to use Qt Signals and Slots with a
4660     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4661 
4662     The macro is normally used when \c no_keywords is specified with
4663     the \c CONFIG variable in the \c .pro file, but it can be used
4664     even when \c no_keywords is \e not specified.
4665 */
4666 
4667 /*!
4668     \macro Q_SLOTS
4669     \relates QObject
4670 
4671     Use this macro to replace the \c slots keyword in class
4672     declarations, when you want to use Qt Signals and Slots with a
4673     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4674 
4675     The macro is normally used when \c no_keywords is specified with
4676     the \c CONFIG variable in the \c .pro file, but it can be used
4677     even when \c no_keywords is \e not specified.
4678 */
4679 
4680 /*!
4681     \macro Q_SLOT
4682     \relates QObject
4683 
4684     This is an additional macro that allows you to mark a single
4685     function as a slot. It can be quite useful, especially when you
4686     use a 3rd-party source code parser which doesn't understand a \c
4687     slots or \c Q_SLOTS groups.
4688 
4689     Use this macro to replace the \c slots keyword in class
4690     declarations, when you want to use Qt Signals and Slots with a
4691     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4692 
4693     The macro is normally used when \c no_keywords is specified with
4694     the \c CONFIG variable in the \c .pro file, but it can be used
4695     even when \c no_keywords is \e not specified.
4696 */
4697 
4698 /*!
4699     \macro Q_EMIT
4700     \relates QObject
4701 
4702     Use this macro to replace the \c emit keyword for emitting
4703     signals, when you want to use Qt Signals and Slots with a
4704     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4705 
4706     The macro is normally used when \c no_keywords is specified with
4707     the \c CONFIG variable in the \c .pro file, but it can be used
4708     even when \c no_keywords is \e not specified.
4709 */
4710 
4711 /*!
4712     \macro Q_INVOKABLE
4713     \relates QObject
4714 
4715     Apply this macro to declarations of member functions to allow them to
4716     be invoked via the meta-object system. The macro is written before
4717     the return type, as shown in the following example:
4718 
4719     \snippet qmetaobject-invokable/window.h Window class with invokable method
4720 
4721     The \c invokableMethod() function is marked up using Q_INVOKABLE, causing
4722     it to be registered with the meta-object system and enabling it to be
4723     invoked using QMetaObject::invokeMethod().
4724     Since \c normalMethod() function is not registered in this way, it cannot
4725     be invoked using QMetaObject::invokeMethod().
4726 
4727     If an invokable member function returns a pointer to a QObject or a
4728     subclass of QObject and it is invoked from QML, special ownership rules
4729     apply. See \l{qtqml-cppintegration-data.html}{Data Type Conversion Between QML and C++}
4730     for more information.
4731 */
4732 
4733 /*!
4734     \macro Q_REVISION
4735     \relates QObject
4736 
4737     Apply this macro to declarations of member functions to tag them with a
4738     revision number in the meta-object system. The macro is written before
4739     the return type, as shown in the following example:
4740 
4741     \snippet qmetaobject-revision/window.h Window class with revision
4742 
4743     This is useful when using the meta-object system to dynamically expose
4744     objects to another API, as you can match the version expected by multiple
4745     versions of the other API. Consider the following simplified example:
4746 
4747     \snippet qmetaobject-revision/main.cpp Window class using revision
4748 
4749     Using the same Window class as the previous example, the newProperty and
4750     newMethod would only be exposed in this code when the expected version is
4751     \c{2.1} or greater.
4752 
4753     Since all methods are considered to be in revision \c{0} if untagged, a tag
4754     of \c{Q_REVISION(0)} or \c{Q_REVISION(0, 0)} is invalid and ignored.
4755 
4756     You can pass one or two integer parameters to \c{Q_REVISION}. If you pass
4757     one parameter, it denotes the minor version only. This means that the major
4758     version is unspecified. If you pass two, the first parameter is the major
4759     version and the second parameter is the minor version.
4760 
4761     This tag is not used by the meta-object system itself. Currently this is only
4762     used by the QtQml module.
4763 
4764     For a more generic string tag, see \l QMetaMethod::tag()
4765 
4766     \sa QMetaMethod::revision()
4767 */
4768 
4769 /*!
4770     \macro Q_SET_OBJECT_NAME(Object)
4771     \relates QObject
4772     \since 5.0
4773 
4774     This macro assigns \a Object the objectName "Object".
4775 
4776     It doesn't matter whether \a Object is a pointer or not, the
4777     macro figures that out by itself.
4778 
4779     \sa QObject::objectName()
4780 */
4781 
4782 /*!
4783     \macro QT_NO_NARROWING_CONVERSIONS_IN_CONNECT
4784     \relates QObject
4785     \since 5.8
4786 
4787     Defining this macro will disable narrowing and floating-point-to-integral
4788     conversions between the arguments carried by a signal and the arguments
4789     accepted by a slot, when the signal and the slot are connected using the
4790     PMF-based syntax.
4791 
4792     \sa QObject::connect
4793 */
4794 
4795 /*!
4796     \typedef QObjectList
4797     \relates QObject
4798 
4799     Synonym for QList<QObject *>.
4800 */
4801 
4802 void qDeleteInEventHandler(QObject *o)
4803 {
4804     delete o;
4805 }
4806 
4807 /*!
4808     \fn template<typename PointerToMemberFunction> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)
4809     \overload connect()
4810     \threadsafe
4811 
4812     Creates a connection of the given \a type from the \a signal in
4813     the \a sender object to the \a method in the \a receiver object.
4814     Returns a handle to the connection that can be used to disconnect
4815     it later.
4816 
4817     The signal must be a function declared as a signal in the header.
4818     The slot function can be any member function that can be connected
4819     to the signal.
4820     A slot can be connected to a given signal if the signal has at
4821     least as many arguments as the slot, and there is an implicit
4822     conversion between the types of the corresponding arguments in the
4823     signal and the slot.
4824 
4825     Example:
4826 
4827     \snippet code/src_corelib_kernel_qobject.cpp 44
4828 
4829     This example ensures that the label always displays the current
4830     line edit text.
4831 
4832     A signal can be connected to many slots and signals. Many signals
4833     can be connected to one slot.
4834 
4835     If a signal is connected to several slots, the slots are activated
4836     in the same order as the order the connection was made, when the
4837     signal is emitted
4838 
4839     The function returns an handle to a connection if it successfully
4840     connects the signal to the slot. The Connection handle will be invalid
4841     if it cannot create the connection, for example, if QObject is unable
4842     to verify the existence of \a signal (if it was not declared as a signal)
4843     You can check if the QMetaObject::Connection is valid by casting it to a bool.
4844 
4845     By default, a signal is emitted for every connection you make;
4846     two signals are emitted for duplicate connections. You can break
4847     all of these connections with a single disconnect() call.
4848     If you pass the Qt::UniqueConnection \a type, the connection will only
4849     be made if it is not a duplicate. If there is already a duplicate
4850     (exact same signal to the exact same slot on the same objects),
4851     the connection will fail and connect will return an invalid QMetaObject::Connection.
4852 
4853     The optional \a type parameter describes the type of connection
4854     to establish. In particular, it determines whether a particular
4855     signal is delivered to a slot immediately or queued for delivery
4856     at a later time. If the signal is queued, the parameters must be
4857     of types that are known to Qt's meta-object system, because Qt
4858     needs to copy the arguments to store them in an event behind the
4859     scenes. If you try to use a queued connection and get the error
4860     message
4861 
4862     \snippet code/src_corelib_kernel_qobject.cpp 25
4863 
4864     make sure to declare the argument type with Q_DECLARE_METATYPE
4865 
4866     Overloaded functions can be resolved with help of \l qOverload.
4867 
4868     \sa {Differences between String-Based and Functor-Based Connections}
4869  */
4870 
4871 /*!
4872     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
4873 
4874     \threadsafe
4875     \overload connect()
4876 
4877     Creates a connection from \a signal in
4878     \a sender object to \a functor, and returns a handle to the connection
4879 
4880     The signal must be a function declared as a signal in the header.
4881     The slot function can be any function or functor that can be connected
4882     to the signal.
4883     A slot function can be connected to a given signal if the signal has at
4884     least as many arguments as the slot function. There must exist implicit
4885     conversion between the types of the corresponding arguments in the
4886     signal and the slot.
4887 
4888     Example:
4889 
4890     \snippet code/src_corelib_kernel_qobject.cpp 45
4891 
4892     Lambda expressions can also be used:
4893 
4894     \snippet code/src_corelib_kernel_qobject.cpp 46
4895 
4896     The connection will automatically disconnect if the sender is destroyed.
4897     However, you should take care that any objects used within the functor
4898     are still alive when the signal is emitted.
4899 
4900     Overloaded functions can be resolved with help of \l qOverload.
4901 
4902  */
4903 
4904 /*!
4905     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)
4906 
4907     \threadsafe
4908     \overload connect()
4909 
4910     \since 5.2
4911 
4912     Creates a connection of a given \a type from \a signal in
4913     \a sender object to \a functor to be placed in a specific event
4914     loop of \a context, and returns a handle to the connection.
4915 
4916     \note Qt::UniqueConnections do not work for lambdas, non-member functions
4917     and functors; they only apply to connecting to member functions.
4918 
4919     The signal must be a function declared as a signal in the header.
4920     The slot function can be any function or functor that can be connected
4921     to the signal.
4922     A slot function can be connected to a given signal if the signal has at
4923     least as many arguments as the slot function. There must exist implicit
4924     conversion between the types of the corresponding arguments in the
4925     signal and the slot.
4926 
4927     Example:
4928 
4929     \snippet code/src_corelib_kernel_qobject.cpp 50
4930 
4931     Lambda expressions can also be used:
4932 
4933     \snippet code/src_corelib_kernel_qobject.cpp 51
4934 
4935     The connection will automatically disconnect if the sender or the context
4936     is destroyed.
4937     However, you should take care that any objects used within the functor
4938     are still alive when the signal is emitted.
4939 
4940     Overloaded functions can be resolved with help of \l qOverload.
4941  */
4942 
4943 /*!
4944     \internal
4945 
4946     Implementation of the template version of connect
4947 
4948     \a sender is the sender object
4949     \a signal is a pointer to a pointer to a member signal of the sender
4950     \a receiver is the receiver object, may not be \nullptr, will be equal to sender when
4951                 connecting to a static function or a functor
4952     \a slot a pointer only used when using Qt::UniqueConnection
4953     \a type the Qt::ConnectionType passed as argument to connect
4954     \a types an array of integer with the metatype id of the parameter of the signal
4955              to be used with queued connection
4956              must stay valid at least for the whole time of the connection, this function
4957              do not take ownership. typically static data.
4958              If \nullptr, then the types will be computed when the signal is emit in a queued
4959              connection from the types from the signature.
4960     \a senderMetaObject is the metaobject used to lookup the signal, the signal must be in
4961                         this metaobject
4962  */
4963 QMetaObject::Connection QObject::connectImpl(const QObject *sender, void **signal,
4964                                              const QObject *receiver, void **slot,
4965                                              QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
4966                                              const int *types, const QMetaObject *senderMetaObject)
4967 {
4968     if (!signal) {
4969         qCWarning(lcConnect, "QObject::connect: invalid nullptr parameter");
4970         if (slotObj)
4971             slotObj->destroyIfLastRef();
4972         return QMetaObject::Connection();
4973     }
4974 
4975     int signal_index = -1;
4976     void *args[] = { &signal_index, signal };
4977     for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
4978         senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
4979         if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
4980             break;
4981     }
4982     if (!senderMetaObject) {
4983         qCWarning(lcConnect, "QObject::connect: signal not found in %s", sender->metaObject()->className());
4984         slotObj->destroyIfLastRef();
4985         return QMetaObject::Connection(nullptr);
4986     }
4987     signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
4988     return QObjectPrivate::connectImpl(sender, signal_index, receiver, slot, slotObj, type, types, senderMetaObject);
4989 }
4990 
4991 /*!
4992     \internal
4993 
4994     Internal version of connect used by the template version of QObject::connect (called via connectImpl) and
4995     also used by the QObjectPrivate::connect version used by QML. The signal_index is expected to be relative
4996     to the number of signals.
4997  */
4998 QMetaObject::Connection QObjectPrivate::connectImpl(const QObject *sender, int signal_index,
4999                                              const QObject *receiver, void **slot,
5000                                              QtPrivate::QSlotObjectBase *slotObj, int type,
5001                                              const int *types, const QMetaObject *senderMetaObject)
5002 {
5003     if (!sender || !receiver || !slotObj || !senderMetaObject) {
5004         const char *senderString = sender ? sender->metaObject()->className()
5005                                           : senderMetaObject ? senderMetaObject->className()
5006                                           : "Unknown";
5007         const char *receiverString = receiver ? receiver->metaObject()->className()
5008                                               : "Unknown";
5009         qCWarning(lcConnect, "QObject::connect(%s, %s): invalid nullptr parameter", senderString, receiverString);
5010         if (slotObj)
5011             slotObj->destroyIfLastRef();
5012         return QMetaObject::Connection();
5013     }
5014 
5015     QObject *s = const_cast<QObject *>(sender);
5016     QObject *r = const_cast<QObject *>(receiver);
5017 
5018     QOrderedMutexLocker locker(signalSlotLock(sender),
5019                                signalSlotLock(receiver));
5020 
5021     if (type & Qt::UniqueConnection && slot && QObjectPrivate::get(s)->connections.loadRelaxed()) {
5022         QObjectPrivate::ConnectionData *connections = QObjectPrivate::get(s)->connections.loadRelaxed();
5023         if (connections->signalVectorCount() > signal_index) {
5024             const QObjectPrivate::Connection *c2 = connections->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
5025 
5026             while (c2) {
5027                 if (c2->receiver.loadRelaxed() == receiver && c2->isSlotObject && c2->slotObj->compare(slot)) {
5028                     slotObj->destroyIfLastRef();
5029                     return QMetaObject::Connection();
5030                 }
5031                 c2 = c2->nextConnectionList.loadRelaxed();
5032             }
5033         }
5034     }
5035     type &= ~Qt::UniqueConnection;
5036 
5037     const bool isSingleShot = type & Qt::SingleShotConnection;
5038     type &= ~Qt::SingleShotConnection;
5039 
5040     Q_ASSERT(type >= 0);
5041     Q_ASSERT(type <= 3);
5042 
5043     std::unique_ptr<QObjectPrivate::Connection> c{new QObjectPrivate::Connection};
5044     c->sender = s;
5045     c->signal_index = signal_index;
5046     QThreadData *td = r->d_func()->threadData;
5047     td->ref();
5048     c->receiverThreadData.storeRelaxed(td);
5049     c->receiver.storeRelaxed(r);
5050     c->slotObj = slotObj;
5051     c->connectionType = type;
5052     c->isSlotObject = true;
5053     if (types) {
5054         c->argumentTypes.storeRelaxed(types);
5055         c->ownArgumentTypes = false;
5056     }
5057     c->isSingleShot = isSingleShot;
5058 
5059     QObjectPrivate::get(s)->addConnection(signal_index, c.get());
5060     QMetaObject::Connection ret(c.release());
5061     locker.unlock();
5062 
5063     QMetaMethod method = QMetaObjectPrivate::signal(senderMetaObject, signal_index);
5064     Q_ASSERT(method.isValid());
5065     s->connectNotify(method);
5066 
5067     return ret;
5068 }
5069 
5070 /*!
5071     Disconnect a connection.
5072 
5073     If the \a connection is invalid or has already been disconnected, do nothing
5074     and return false.
5075 
5076    \sa connect()
5077  */
5078 bool QObject::disconnect(const QMetaObject::Connection &connection)
5079 {
5080     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(connection.d_ptr);
5081     if (!c)
5082         return false;
5083     const bool disconnected = QObjectPrivate::disconnect(c);
5084     const_cast<QMetaObject::Connection &>(connection).d_ptr = nullptr;
5085     c->deref(); // has been removed from the QMetaObject::Connection object
5086     return disconnected;
5087 }
5088 
5089 /*! \fn template<typename PointerToMemberFunction> bool QObject::disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
5090     \overload disconnect()
5091     \threadsafe
5092 
5093     Disconnects \a signal in object \a sender from \a method in object
5094     \a receiver. Returns \c true if the connection is successfully broken;
5095     otherwise returns \c false.
5096 
5097     A signal-slot connection is removed when either of the objects
5098     involved are destroyed.
5099 
5100     disconnect() is typically used in three ways, as the following
5101     examples demonstrate.
5102     \list 1
5103     \li Disconnect everything connected to an object's signals:
5104 
5105        \snippet code/src_corelib_kernel_qobject.cpp 26
5106 
5107     \li Disconnect everything connected to a specific signal:
5108 
5109        \snippet code/src_corelib_kernel_qobject.cpp 47
5110 
5111     \li Disconnect a specific receiver:
5112 
5113        \snippet code/src_corelib_kernel_qobject.cpp 30
5114 
5115     \li Disconnect a connection from one specific signal to a specific slot:
5116 
5117        \snippet code/src_corelib_kernel_qobject.cpp 48
5118 
5119 
5120     \endlist
5121 
5122     \nullptr may be used as a wildcard, meaning "any signal", "any receiving
5123     object", or "any slot in the receiving object", respectively.
5124 
5125     The \a sender may never be \nullptr. (You cannot disconnect signals
5126     from more than one object in a single call.)
5127 
5128     If \a signal is \nullptr, it disconnects \a receiver and \a method from
5129     any signal. If not, only the specified signal is disconnected.
5130 
5131     If \a receiver is \nullptr, it disconnects anything connected to \a
5132     signal. If not, only slots in the specified receiver are disconnected.
5133     disconnect() with a non-null \a receiver also disconnects slot functions
5134     that were connected with \a receiver as their context object.
5135 
5136     If \a method is \nullptr, it disconnects anything that is connected to \a
5137     receiver. If not, only slots named \a method will be disconnected,
5138     and all other slots are left alone. The \a method must be \nullptr
5139     if \a receiver is left out, so you cannot disconnect a
5140     specifically-named slot on all objects.
5141 
5142     \note It is not possible to use this overload to disconnect signals
5143     connected to functors or lambda expressions. That is because it is not
5144     possible to compare them. Instead, use the overload that takes a
5145     QMetaObject::Connection
5146 
5147     \sa connect()
5148 */
5149 
5150 bool QObject::disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, const QMetaObject *senderMetaObject)
5151 {
5152     if (sender == nullptr || (receiver == nullptr && slot != nullptr)) {
5153         qCWarning(lcConnect, "QObject::disconnect: Unexpected nullptr parameter");
5154         return false;
5155     }
5156 
5157     int signal_index = -1;
5158     if (signal) {
5159         void *args[] = { &signal_index, signal };
5160         for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
5161             senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
5162             if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
5163                 break;
5164         }
5165         if (!senderMetaObject) {
5166             qCWarning(lcConnect, "QObject::disconnect: signal not found in %s", sender->metaObject()->className());
5167             return false;
5168         }
5169         signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
5170     }
5171 
5172     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, receiver, -1, slot);
5173 }
5174 
5175 /*!
5176  \internal
5177  Used by QML to connect a signal by index to a slot implemented in JavaScript
5178  (wrapped in a custom QSlotObjectBase subclass).
5179 
5180  This version of connect assumes that sender and receiver are the same object.
5181 
5182  The signal_index is an index relative to the number of methods.
5183  */
5184 QMetaObject::Connection QObjectPrivate::connect(const QObject *sender, int signal_index, QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type)
5185 {
5186     return QObjectPrivate::connect(sender, signal_index, sender, slotObj, type);
5187 }
5188 
5189 /*!
5190  \internal
5191  Used by QML to connect a signal by index to a slot implemented in JavaScript
5192  (wrapped in a custom QSlotObjectBase subclass).
5193 
5194  This is an overload that should be used when \a sender and \a receiver are
5195  different objects.
5196 
5197  The signal_index is an index relative to the number of methods.
5198  */
5199 QMetaObject::Connection QObjectPrivate::connect(const QObject *sender, int signal_index,
5200                                                 const QObject *receiver,
5201                                                 QtPrivate::QSlotObjectBase *slotObj,
5202                                                 Qt::ConnectionType type)
5203 {
5204     if (!sender) {
5205         qCWarning(lcConnect, "QObject::connect: invalid nullptr parameter");
5206         if (slotObj)
5207             slotObj->destroyIfLastRef();
5208         return QMetaObject::Connection();
5209     }
5210     const QMetaObject *senderMetaObject = sender->metaObject();
5211     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
5212 
5213     return QObjectPrivate::connectImpl(sender, signal_index, receiver, /*slot*/ nullptr, slotObj,
5214                                        type, /*types*/ nullptr, senderMetaObject);
5215 }
5216 
5217 /*!
5218  \internal
5219  Used by QML to disconnect a signal by index that's connected to a slot implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass)
5220  In the QML case the slot is not a pointer to a pointer to the function to disconnect, but instead it is a pointer to an array of internal values
5221  required for the disconnect.
5222 
5223  This version of disconnect assumes that sender and receiver are the same object.
5224  */
5225 bool QObjectPrivate::disconnect(const QObject *sender, int signal_index, void **slot)
5226 {
5227     return QObjectPrivate::disconnect(sender, signal_index, sender, slot);
5228 }
5229 
5230 /*!
5231  \internal
5232 
5233  Used by QML to disconnect a signal by index that's connected to a slot
5234  implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass) In the
5235  QML case the slot is not a pointer to a pointer to the function to disconnect,
5236  but instead it is a pointer to an array of internal values required for the
5237  disconnect.
5238 
5239  This is an overload that should be used when \a sender and \a receiver are
5240  different objects.
5241  */
5242 bool QObjectPrivate::disconnect(const QObject *sender, int signal_index, const QObject *receiver,
5243                                 void **slot)
5244 {
5245     const QMetaObject *senderMetaObject = sender->metaObject();
5246     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
5247 
5248     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, receiver, -1,
5249                                           slot);
5250 }
5251 
5252 /*!
5253     \internal
5254     \threadsafe
5255 */
5256 bool QObjectPrivate::disconnect(QObjectPrivate::Connection *c)
5257 {
5258     if (!c)
5259         return false;
5260     QObject *receiver = c->receiver.loadRelaxed();
5261     if (!receiver)
5262         return false;
5263 
5264     QBasicMutex *senderMutex = signalSlotLock(c->sender);
5265     QBasicMutex *receiverMutex = signalSlotLock(receiver);
5266 
5267     QObjectPrivate::ConnectionData *connections;
5268     {
5269         QOrderedMutexLocker locker(senderMutex, receiverMutex);
5270 
5271         // load receiver once again and recheck to ensure nobody else has removed the connection in the meantime
5272         receiver = c->receiver.loadRelaxed();
5273         if (!receiver)
5274             return false;
5275 
5276         connections = QObjectPrivate::get(c->sender)->connections.loadRelaxed();
5277         Q_ASSERT(connections);
5278         connections->removeConnection(c);
5279 
5280         c->sender->disconnectNotify(QMetaObjectPrivate::signal(c->sender->metaObject(), c->signal_index));
5281         // We must not hold the receiver mutex, else we risk dead-locking; we also only need the sender mutex
5282         // It is however vital to hold the senderMutex before calling cleanOrphanedConnections, as otherwise
5283         // another thread might modify/delete the connection
5284         if (receiverMutex != senderMutex) {
5285             receiverMutex->unlock();
5286         }
5287         connections->cleanOrphanedConnections(c->sender, ConnectionData::AlreadyLockedAndTemporarilyReleasingLock);
5288         senderMutex->unlock(); // now both sender and receiver mutex have been manually unlocked
5289         locker.dismiss(); // so we dismiss the QOrderedMutexLocker
5290     }
5291 
5292     return true;
5293 }
5294 
5295 /*! \class QMetaObject::Connection
5296     \inmodule QtCore
5297      Represents a handle to a signal-slot (or signal-functor) connection.
5298 
5299      It can be used to check if the connection is valid and to disconnect it using
5300      QObject::disconnect(). For a signal-functor connection without a context object,
5301      it is the only way to selectively disconnect that connection.
5302 
5303      As Connection is just a handle, the underlying signal-slot connection is unaffected
5304      when Connection is destroyed or reassigned.
5305  */
5306 
5307 /*!
5308     Create a copy of the handle to the \a other connection
5309  */
5310 QMetaObject::Connection::Connection(const QMetaObject::Connection &other) : d_ptr(other.d_ptr)
5311 {
5312     if (d_ptr)
5313         static_cast<QObjectPrivate::Connection *>(d_ptr)->ref();
5314 }
5315 
5316 /*!
5317     Assigns \a other to this connection and returns a reference to this connection.
5318 */
5319 QMetaObject::Connection &QMetaObject::Connection::operator=(const QMetaObject::Connection &other)
5320 {
5321     if (other.d_ptr != d_ptr) {
5322         if (d_ptr)
5323             static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5324         d_ptr = other.d_ptr;
5325         if (other.d_ptr)
5326             static_cast<QObjectPrivate::Connection *>(other.d_ptr)->ref();
5327     }
5328     return *this;
5329 }
5330 
5331 /*!
5332     Creates a Connection instance.
5333 */
5334 
5335 QMetaObject::Connection::Connection() : d_ptr(nullptr) {}
5336 
5337 /*!
5338     Destructor for QMetaObject::Connection.
5339 */
5340 QMetaObject::Connection::~Connection()
5341 {
5342     if (d_ptr)
5343         static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5344 }
5345 
5346 /*! \internal Returns true if the object is still connected */
5347 bool QMetaObject::Connection::isConnected_helper() const
5348 {
5349     Q_ASSERT(d_ptr);    // we're only called from operator RestrictedBool() const
5350     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(d_ptr);
5351 
5352     return c->receiver.loadRelaxed();
5353 }
5354 
5355 
5356 /*!
5357     \fn QMetaObject::Connection::operator bool() const
5358 
5359     Returns \c true if the connection is valid.
5360 
5361     The connection is valid if the call to QObject::connect succeeded.
5362     The connection is invalid if QObject::connect was not able to find
5363     the signal or the slot, or if the arguments do not match.
5364  */
5365 
5366 QT_END_NAMESPACE
5367 
5368 #include "moc_qobject.cpp"
