Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "cppselectionchanger.h"
27 
28 #include <utils/textutils.h>
29 #include <utils/qtcassert.h>
30 
31 #include <QDebug>
32 #include <QString>
33 #include <QTextBlock>
34 #include <QTextDocument>
35 
36 using namespace CPlusPlus;
37 using namespace Utils::Text;
38 
39 enum {
40     debug = false
41 };
42 
43 namespace CppTools {
44 
45 namespace Internal {
46 const int kChangeSelectionNodeIndexNotSet = -1;
47 const int kChangeSelectionNodeIndexWholeDocoument = -2;
48 }
49 
50 using namespace CppTools::Internal;
51 
52 CppSelectionChanger::CppSelectionChanger(QObject *parent)
53     : QObject(parent)
54     , m_initialChangeSelectionCursor()
55     , m_workingCursor()
56     , m_doc(0)
57     , m_unit(0)
58     , m_direction(ExpandSelection)
59     , m_changeSelectionNodeIndex(kChangeSelectionNodeIndexNotSet)
60     , m_nodeCurrentStep(kChangeSelectionNodeIndexNotSet)
61     , m_inChangeSelection(false)
62 {
63 }
64 
65 void CppSelectionChanger::onCursorPositionChanged(const QTextCursor &newCursor)
66 {
67     // Reset the text cursor to be used for initial change selection behavior, only in the case
68     // that the cursor is not being modified by the actual change selection methods.
69     if (!m_inChangeSelection) {
70         m_initialChangeSelectionCursor = newCursor;
71         setNodeIndexAndStep(NodeIndexAndStepNotSet);
72         if (debug)
73             qDebug() << "Updating change selection cursor position:" << newCursor.position();
74     }
75 }
76 
77 namespace {
78 
79 bool hasNoSelectionAndShrinking(
80         CppSelectionChanger::Direction direction,
81         const QTextCursor &cursor)
82 {
83     if (direction == CppSelectionChanger::ShrinkSelection && !cursor.hasSelection()) {
84         if (debug)
85             qDebug() << "No selection to shrink, exiting early.";
86         return true;
87     }
88     return false;
89 }
90 
91 void ensureCursorSelectionIsNotFlipped(QTextCursor &cursor)
92 {
93     if (cursor.hasSelection() && (cursor.anchor() > cursor.position()))
94         cursor = flippedCursor(cursor);
95 
96     if (debug) {
97         Utils::OptionalLineColumn lineColumn = convertPosition(cursor.document(), cursor.position());
98         QTC_CHECK(lineColumn);
99 
100         qDebug() << "Cursor details: " << cursor.anchor() << cursor.position()
101                  << " l,c:" << lineColumn->line << ":" << lineColumn->column;
102     }
103 }
104 
105 bool isDocumentAvailable(const CPlusPlus::Document::Ptr doc)
106 {
107     if (!doc) {
108         if (debug)
109             qDebug() << "Document is not available.";
110         return false;
111     }
112     return true;
113 }
114 
115 QTextCursor getWholeDocumentCursor(const QTextCursor &cursor)
116 {
117     QTextCursor newWholeDocumentCursor(cursor);
118     newWholeDocumentCursor.setPosition(0, QTextCursor::MoveAnchor);
119     newWholeDocumentCursor.setPosition(cursor.document()->characterCount() - 1,
120                                        QTextCursor::KeepAnchor);
121     return newWholeDocumentCursor;
122 }
123 
124 bool isWholeDocumentSelectedAndExpanding(
125         CppSelectionChanger::Direction direction,
126         const QTextCursor &cursor)
127 {
128     if (direction == CppSelectionChanger::ExpandSelection && cursor.hasSelection()) {
129         const QTextCursor wholeDocumentCursor = getWholeDocumentCursor(cursor);
130         if (wholeDocumentCursor == cursor) {
131             if (debug)
132                 qDebug() << "Selection is whole document, nothing to expand, exiting early.";
133             return true;
134         }
135     }
136     return false;
137 }
138 
139 } // end of anonymous namespace
140 
141 int CppSelectionChanger::getTokenStartCursorPosition(
142         unsigned tokenIndex,
143         const QTextCursor &cursor) const
144 {
145     unsigned startLine, startColumn;
146     m_unit->getTokenStartPosition(tokenIndex, &startLine, &startColumn);
147 
148     const QTextDocument *document = cursor.document();
149     const int startPosition =
150             document->findBlockByNumber(static_cast<int>(startLine) - 1).position()
151             + static_cast<int>(startColumn) - 1;
152 
153     return startPosition;
154 }
155 
156 int CppSelectionChanger::getTokenEndCursorPosition(
157         unsigned tokenIndex,
158         const QTextCursor &cursor) const
159 {
160     unsigned endLine, endColumn;
161     m_unit->getTokenEndPosition(tokenIndex, &endLine, &endColumn);
162 
163     const QTextDocument *document = cursor.document();
164     const int endPosition =
165             document->findBlockByNumber(static_cast<int>(endLine) - 1).position()
166             + static_cast<int>(endColumn) - 1;
167 
168     return endPosition;
169 }
170 
171 void CppSelectionChanger::printTokenDebugInfo(
172         unsigned tokenIndex,
173         const QTextCursor &cursor,
174         QString prefix) const
175 {
176     unsigned line, column;
177     const Token token = m_unit->tokenAt(tokenIndex);
178     m_unit->getTokenStartPosition(tokenIndex, &line, &column);
179     const int startPos = getTokenStartCursorPosition(tokenIndex, cursor);
180     const int endPos = getTokenEndCursorPosition(tokenIndex, cursor);
181 
182     qDebug() << qSetFieldWidth(20) << prefix << qSetFieldWidth(0)
183              << token.spell() << tokenIndex
184              << " l, c:" << line << ":" << column
185              << " offset: " << token.utf16chars() << startPos << endPos;
186 }
187 
188 bool CppSelectionChanger::shouldSkipASTNodeBasedOnPosition(
189         const ASTNodePositions &positions,
190         const QTextCursor &cursor) const
191 {
192     bool shouldSkipNode = false;
193 
194     bool isEqual = cursor.anchor() == positions.astPosStart
195                    && cursor.position() == positions.astPosEnd;
196 
197     // New selections should include initial selection.
198     bool includesInitialSelection =
199             m_initialChangeSelectionCursor.anchor() >= positions.astPosStart &&
200             m_initialChangeSelectionCursor.position() <= positions.astPosEnd;
201 
202     // Prefer new selections to start with initial cursor if anchor == position.
203     if (!m_initialChangeSelectionCursor.hasSelection()) {
204         includesInitialSelection =
205                 m_initialChangeSelectionCursor.position() < positions.astPosEnd;
206     }
207 
208     // When expanding: Skip if new selection is smaller than current cursor selection.
209     // When shrinking: Skip if new selection is bigger than current cursor selection.
210     bool isNewSelectionSmaller = positions.astPosStart > cursor.anchor()
211                                  || positions.astPosEnd < cursor.position();
212     bool isNewSelectionBigger = positions.astPosStart < cursor.anchor()
213                                 || positions.astPosEnd > cursor.position();
214 
215     if (m_direction == CppSelectionChanger::ExpandSelection
216         && (isNewSelectionSmaller || isEqual || !includesInitialSelection)) {
217         shouldSkipNode = true;
218     } else if (m_direction == CppSelectionChanger::ShrinkSelection
219                && (isNewSelectionBigger || isEqual || !includesInitialSelection)) {
220         shouldSkipNode = true;
221     }
222 
223     if (debug && shouldSkipNode) {
224         qDebug() << "isEqual:" << isEqual << "includesInitialSelection:" << includesInitialSelection
225                  << "isNewSelectionSmaller:" << isNewSelectionSmaller << "isNewSelectionBigger:"
226                  << isNewSelectionBigger;
227     }
228 
229     return shouldSkipNode;
230 }
231 
232 ASTNodePositions CppSelectionChanger::getASTPositions(AST *ast, const QTextCursor &cursor) const
233 {
234     ASTNodePositions positions(ast);
235 
236     // An AST node's contents is bound by its first token start position inclusively,
237     // and its last token start position exclusively.
238     // So we are also interested in the second to last token, which is actually
239     // included in the bounds.
240     positions.firstTokenIndex = ast->firstToken();
241     positions.lastTokenIndex = ast->lastToken();
242     positions.secondToLastTokenIndex = positions.lastTokenIndex - 1;
243 
244     // The AST position start is the start of the first token.
245     positions.astPosStart = getTokenStartCursorPosition(positions.firstTokenIndex, cursor);
246 
247     // The end position depends on whether, there is only one token involved in the current AST
248     // node or multiple ones.
249     // Default we assume that there is only one token, so the end position of the AST node
250     // is the start of the last token.
251     // If there is more than one (second to last token will be different to the first token)
252     // use the second to last token end position as the AST node end position.
253     positions.astPosEnd = getTokenStartCursorPosition(positions.lastTokenIndex, cursor);
254     if (positions.lastTokenIndex != positions.firstTokenIndex)
255         positions.astPosEnd = getTokenEndCursorPosition(positions.secondToLastTokenIndex, cursor);
256 
257     if (debug) {
258         qDebug() << "Token positions start and end:"
259                  << positions.astPosStart << positions.astPosEnd;
260     }
261 
262     return positions;
263 }
264 
265 void CppSelectionChanger::updateCursorSelection(
266         QTextCursor &cursorToModify,
267         ASTNodePositions positions)
268 {
269     m_workingCursor.setPosition(positions.astPosStart, QTextCursor::MoveAnchor);
270     m_workingCursor.setPosition(positions.astPosEnd, QTextCursor::KeepAnchor);
271     cursorToModify = m_workingCursor;
272 
273     if (debug) {
274         printTokenDebugInfo(positions.firstTokenIndex, m_workingCursor,
275                             QString::fromLatin1("First token:"));
276         printTokenDebugInfo(positions.lastTokenIndex, m_workingCursor,
277                             QString::fromLatin1("Last token:"));
278         printTokenDebugInfo(positions.secondToLastTokenIndex, m_workingCursor,
279                             QString::fromLatin1("Second to last:"));
280 
281         qDebug() << "Anchor is now: " << m_workingCursor.anchor();
282         qDebug() << "Position is now: " << m_workingCursor.position();
283     }
284 }
285 
286 int CppSelectionChanger::getFirstCurrentStepForASTNode(AST *ast) const
287 {
288     if (m_direction == ExpandSelection)
289         return 1;
290     else
291         return possibleASTStepCount(ast);
292 }
293 
294 bool CppSelectionChanger::isLastPossibleStepForASTNode(AST *ast) const
295 {
296     if (m_direction == ExpandSelection)
297         return currentASTStep() == possibleASTStepCount(ast);
298     else
299         return currentASTStep() == 1;
300 }
301 
302 ASTNodePositions CppSelectionChanger::getFineTunedASTPositions(AST *ast,
303                                                                const QTextCursor &cursor) const
304 {
305     ASTNodePositions positions = getASTPositions(ast, cursor);
306     fineTuneASTNodePositions(positions);
307     return positions;
308 }
309 
310 ASTNodePositions CppSelectionChanger::findRelevantASTPositionsFromCursor(
311         const QList<AST *> &astPath,
312         const QTextCursor &cursor,
313         int startingFromNodeIndex)
314 {
315     ASTNodePositions currentNodePositions;
316     const int size = astPath.size();
317     int currentAstIndex = m_direction == ExpandSelection ? size - 1 : 0;
318 
319     // Adjust starting node index, if a valid value was passed.
320     if (startingFromNodeIndex != kChangeSelectionNodeIndexNotSet)
321         currentAstIndex = startingFromNodeIndex;
322 
323     if (currentAstIndex < size && currentAstIndex >= 0) {
324         AST *ast = astPath.at(currentAstIndex);
325         m_changeSelectionNodeIndex = currentAstIndex;
326         m_nodeCurrentStep = getFirstCurrentStepForASTNode(ast);
327         currentNodePositions = getFineTunedASTPositions(ast, cursor);
328 
329         if (debug && startingFromNodeIndex == kChangeSelectionNodeIndexNotSet)
330             qDebug() << "Setting AST index for the first time.";
331     }
332 
333     if (!currentNodePositions.ast)
334         setNodeIndexAndStep(NodeIndexAndStepNotSet);
335 
336     return currentNodePositions;
337 }
338 
339 ASTNodePositions CppSelectionChanger::findRelevantASTPositionsFromCursorWhenNodeIndexNotSet(
340         const QList<AST *> astPath,
341         const QTextCursor &cursor)
342 {
343     // Find relevant AST node from cursor, when the user expands for the first time.
344     return findRelevantASTPositionsFromCursor(astPath, cursor);
345 }
346 
347 ASTNodePositions CppSelectionChanger::findRelevantASTPositionsFromCursorWhenWholeDocumentSelected(
348         const QList<AST *> astPath,
349         const QTextCursor &cursor)
350 {
351     // Can't expand more, because whole document is selected.
352     if (m_direction == ExpandSelection)
353         return 0;
354 
355     // In case of shrink, select the next smaller selection.
356     return findRelevantASTPositionsFromCursor(astPath, cursor);
357 }
358 
359 ASTNodePositions CppSelectionChanger::findRelevantASTPositionsFromCursorFromPreviousNodeIndex(
360         const QList<AST *> astPath,
361         const QTextCursor &cursor)
362 {
363     ASTNodePositions nodePositions;
364 
365     // This is not the first expansion, use the previous node index.
366     nodePositions.ast = astPath.at(m_changeSelectionNodeIndex);
367 
368     // We reached the last possible step for the current AST node, so we move to the
369     // next / previous one depending on the direction.
370     if (isLastPossibleStepForASTNode(nodePositions.ast)) {
371         int newAstIndex = m_changeSelectionNodeIndex;
372         if (m_direction == ExpandSelection)
373             --newAstIndex;
374         else
375             ++newAstIndex;
376 
377         if (newAstIndex < 0 || newAstIndex >= astPath.count()) {
378             if (debug)
379                 qDebug() << "Skipping expansion because there is no available next AST node.";
380             return 0;
381         }
382 
383         // Switch to next AST and set the first step.
384         nodePositions = findRelevantASTPositionsFromCursor(astPath, cursor, newAstIndex);
385         if (!nodePositions)
386             return 0;
387 
388         if (debug)
389             qDebug() << "Moved to next AST node.";
390     } else {
391         // There are possible steps available for current node, so move to the next / previous
392         // step.
393         if (m_direction == ExpandSelection)
394             ++m_nodeCurrentStep;
395         else
396             --m_nodeCurrentStep;
397         nodePositions = getFineTunedASTPositions(nodePositions.ast, cursor);
398 
399         if (debug)
400             qDebug() << "Moved to next AST step.";
401     }
402 
403     return nodePositions;
404 }
405 
406 ASTNodePositions CppSelectionChanger::findNextASTStepPositions(const QTextCursor &cursor)
407 {
408     // Find AST node path starting from the initial change selection cursor.
409     // The ASTPath class, only takes into consideration the position of the cursor, but not the
410     // anchor. We make up for that later in the code.
411     QTextCursor cursorToStartFrom(m_initialChangeSelectionCursor);
412 
413     ASTPath astPathFinder(m_doc);
414     const QList<AST *> astPath = astPathFinder(cursorToStartFrom);
415 
416 #ifdef WITH_AST_PATH_DUMP
417     if (debug)
418         ASTPath::dump(astPath);
419 #endif
420 
421     if (astPath.size() == 0)
422         return 0;
423 
424     ASTNodePositions currentNodePositions;
425     if (m_changeSelectionNodeIndex == kChangeSelectionNodeIndexNotSet) {
426         currentNodePositions = findRelevantASTPositionsFromCursorWhenNodeIndexNotSet(astPath,
427                                                                                      cursor);
428     } else if (m_changeSelectionNodeIndex == kChangeSelectionNodeIndexWholeDocoument) {
429         currentNodePositions = findRelevantASTPositionsFromCursorWhenWholeDocumentSelected(astPath,
430                                                                                            cursor);
431     } else {
432         currentNodePositions = findRelevantASTPositionsFromCursorFromPreviousNodeIndex(astPath,
433                                                                                        cursor);
434     }
435 
436     if (debug) {
437         qDebug() << "m_changeSelectionNodeIndex:" << m_changeSelectionNodeIndex
438                  << "possible step count:" << possibleASTStepCount(currentNodePositions.ast)
439                  << "current step:" << m_nodeCurrentStep;
440     }
441 
442     QTC_ASSERT(m_nodeCurrentStep >= 1, return 0);
443 
444     return currentNodePositions;
445 }
446 
447 void CppSelectionChanger::fineTuneForStatementPositions(unsigned firstParenTokenIndex,
448                                                         unsigned lastParenTokenIndex,
449                                                         ASTNodePositions &positions) const
450 {
451     Token firstParenToken = m_unit->tokenAt(firstParenTokenIndex);
452     Token lastParenToken = m_unit->tokenAt(lastParenTokenIndex);
453     if (debug) {
454         qDebug() << "firstParenToken:" << firstParenToken.spell();
455         qDebug() << "lastParenToken:" << lastParenToken.spell();
456     }
457 
458     int newPosStart = getTokenStartCursorPosition(firstParenTokenIndex, m_workingCursor);
459     int newPosEnd = getTokenEndCursorPosition(lastParenTokenIndex, m_workingCursor);
460 
461     bool isOutsideParen =
462             m_initialChangeSelectionCursor.position() <= newPosStart;
463 
464     if (currentASTStep() == 1 && !isOutsideParen) {
465         if (debug)
466             qDebug() << "Selecting Paren contents of for statement.";
467         positions.astPosStart = newPosStart + 1;
468         positions.astPosEnd = newPosEnd - 1;
469     }
470     if (currentASTStep() == 2 && !isOutsideParen) {
471         if (debug)
472             qDebug() << "Selecting Paren of for statement together with contents.";
473         positions.astPosStart = newPosStart;
474         positions.astPosEnd = newPosEnd;
475     }
476 }
477 
478 void CppSelectionChanger::fineTuneASTNodePositions(ASTNodePositions &positions) const
479 {
480     AST *ast = positions.ast;
481 
482     if (ast->asCompoundStatement()) {
483         // Allow first selecting the contents of the scope, without selecting the braces, and
484         // afterwards select the contents together with  braces.
485         if (currentASTStep() == 1) {
486             if (debug)
487                 qDebug() << "Selecting inner contents of compound statement.";
488 
489             unsigned firstInnerTokenIndex = positions.firstTokenIndex + 1;
490             unsigned lastInnerTokenIndex = positions.lastTokenIndex - 2;
491             Token firstInnerToken = m_unit->tokenAt(firstInnerTokenIndex);
492             Token lastInnerToken = m_unit->tokenAt(lastInnerTokenIndex);
493             if (debug) {
494                 qDebug() << "LastInnerToken:" << lastInnerToken.spell();
495                 qDebug() << "FirstInnerToken:" << firstInnerToken.spell();
496             }
497 
498             // Check if compound statement is empty, then select just the blank space inside it.
499             int newPosStart, newPosEnd;
500             if (positions.secondToLastTokenIndex - positions.firstTokenIndex <= 1) {
501                 // TODO: If the empty space has a new tab character, or spaces, and the document is
502                 // not saved, the last semantic info is not updated, and the selection is not
503                 // properly computed. Figure out how to work around this.
504                 newPosStart = getTokenEndCursorPosition(positions.firstTokenIndex, m_workingCursor);
505                 newPosEnd = getTokenStartCursorPosition(positions.secondToLastTokenIndex,
506                                                         m_workingCursor);
507                 if (debug)
508                     qDebug() << "Selecting inner contents of compound statement which is empty.";
509             } else {
510                 // Select the inner contents of the scope, without the braces.
511                 newPosStart = getTokenStartCursorPosition(firstInnerTokenIndex, m_workingCursor);
512                 newPosEnd = getTokenEndCursorPosition(lastInnerTokenIndex, m_workingCursor);
513             }
514 
515             if (debug) {
516                 qDebug() << "New" << newPosStart << newPosEnd
517                          << "Old" << m_workingCursor.anchor() << m_workingCursor.position();
518             }
519 
520             positions.astPosStart = newPosStart;
521             positions.astPosEnd = newPosEnd;
522         }
523         // Next time, we select the braces as well. Reverse for shrinking.
524         // The positions already have the correct selection, so no need to set them.
525     } else if (CallAST *callAST = ast->asCall()) {
526         unsigned firstParenTokenIndex = callAST->lparen_token;
527         unsigned lastParenTokenIndex = callAST->rparen_token;
528         Token firstParenToken = m_unit->tokenAt(firstParenTokenIndex);
529         Token lastParenToken = m_unit->tokenAt(lastParenTokenIndex);
530         if (debug) {
531             qDebug() << "firstParenToken:" << firstParenToken.spell();
532             qDebug() << "lastParenToken:" << lastParenToken.spell();
533         }
534 
535         // Select the parenthesis of the call, and everything between.
536         int newPosStart = getTokenStartCursorPosition(firstParenTokenIndex, m_workingCursor);
537         int newPosEnd = getTokenEndCursorPosition(lastParenTokenIndex, m_workingCursor);
538 
539         bool isInFunctionName =
540                 m_initialChangeSelectionCursor.position() <= newPosStart;
541 
542         // If cursor is inside the function name, select the name implicitly (because it's a
543         // different AST node), and then the whole call expression (so just one step).
544         // If cursor is inside parentheses, on first step select everything inside them,
545         // on second step select the everything inside parentheses including them,
546         // on third step select the whole call expression.
547         if (currentASTStep() == 1 && !isInFunctionName) {
548             if (debug)
549                 qDebug() << "Selecting everything inside parentheses.";
550             positions.astPosStart = newPosStart + 1;
551             positions.astPosEnd = newPosEnd - 1;
552         }
553         if (currentASTStep() == 2 && !isInFunctionName) {
554             if (debug)
555                 qDebug() << "Selecting everything inside and including "
556                             "the parentheses of the function call.";
557             positions.astPosStart = newPosStart;
558             positions.astPosEnd = newPosEnd;
559         }
560     } else if (StringLiteralAST *stringLiteralAST = ast->asStringLiteral()) {
561         // Select literal without quotes on first step, and the whole literal on next step.
562         if (currentASTStep() == 1) {
563             Token firstToken = m_unit->tokenAt(stringLiteralAST->firstToken());
564             bool isRawLiteral = firstToken.f.kind >= T_FIRST_RAW_STRING_LITERAL
565                                 && firstToken.f.kind <= T_RAW_UTF32_STRING_LITERAL;
566             if (debug && isRawLiteral)
567                 qDebug() << "Is raw literal.";
568 
569             // Start from positions that include quotes.
570             int newPosStart = positions.astPosStart;
571             int newPosEnd = positions.astPosEnd;
572 
573             // Decrement last position to skip last quote.
574             --newPosEnd;
575 
576             // If raw literal also skip parenthesis.
577             if (isRawLiteral)
578                 --newPosEnd;
579 
580             // Start position will be the end position minus the size of the actual contents of the
581             // literal.
582             newPosStart = newPosEnd - static_cast<int>(firstToken.string->size());
583 
584             // Skip raw literal parentheses.
585             if (isRawLiteral)
586                 newPosStart += 2;
587 
588             positions.astPosStart = newPosStart;
589             positions.astPosEnd = newPosEnd;
590             if (debug)
591                 qDebug() << "Selecting inner contents of string literal.";
592         }
593     } else if (NumericLiteralAST *numericLiteralAST = ast->asNumericLiteral()) {
594         Token firstToken = m_unit->tokenAt(numericLiteralAST->firstToken());
595         // If char literal, select it without quotes on first step.
596         if (firstToken.isCharLiteral()) {
597             if (currentASTStep() == 1) {
598                 if (debug)
599                     qDebug() << "Selecting inner contents of char literal.";
600 
601                 int newPosStart = positions.astPosStart;
602                 int newPosEnd = positions.astPosEnd;
603                 newPosEnd = newPosEnd - 1;
604                 newPosStart = newPosEnd - static_cast<int>(firstToken.literal->size());
605 
606                 positions.astPosStart = newPosStart;
607                 positions.astPosEnd = newPosEnd;
608             }
609         }
610     } else if (ForStatementAST *forStatementAST = ast->asForStatement()) {
611         unsigned firstParenTokenIndex = forStatementAST->lparen_token;
612         unsigned lastParenTokenIndex = forStatementAST->rparen_token;
613         fineTuneForStatementPositions(firstParenTokenIndex, lastParenTokenIndex, positions);
614     } else if (RangeBasedForStatementAST *rangeForStatementAST = ast->asRangeBasedForStatement()) {
615         unsigned firstParenTokenIndex = rangeForStatementAST->lparen_token;
616         unsigned lastParenTokenIndex = rangeForStatementAST->rparen_token;
617         fineTuneForStatementPositions(firstParenTokenIndex, lastParenTokenIndex, positions);
618     } else if (ClassSpecifierAST *classSpecificerAST = ast->asClassSpecifier()) {
619 
620         unsigned firstBraceTokenIndex = classSpecificerAST->lbrace_token;
621         unsigned lastBraceTokenIndex = classSpecificerAST->rbrace_token;
622         unsigned classKeywordTokenIndex = classSpecificerAST->classkey_token;
623 
624         Token firstBraceToken = m_unit->tokenAt(firstBraceTokenIndex);
625         Token lastBraceToken = m_unit->tokenAt(lastBraceTokenIndex);
626         Token classKeywordToken = m_unit->tokenAt(classKeywordTokenIndex);
627 
628         if (debug) {
629             qDebug() << "firstBraceToken:" << firstBraceToken.spell();
630             qDebug() << "lastBraceToken:" << lastBraceToken.spell();
631             qDebug() << "classKeywordToken:" << classKeywordToken.spell();
632 
633         }
634 
635         int newPosStart = getTokenStartCursorPosition(firstBraceTokenIndex, m_workingCursor);
636         int newPosEnd = getTokenEndCursorPosition(lastBraceTokenIndex, m_workingCursor);
637 
638         bool isOutsideBraces =
639                 m_initialChangeSelectionCursor.position() <= newPosStart;
640         bool isInsideBraces = !isOutsideBraces;
641 
642         int classKeywordPosStart = getTokenStartCursorPosition(classKeywordTokenIndex,
643                                                                m_workingCursor);
644 
645         int classKeywordPosEnd = getTokenEndCursorPosition(classKeywordTokenIndex, m_workingCursor);
646 
647         bool isInClassKeyword = m_initialChangeSelectionCursor.anchor() >= classKeywordPosStart &&
648                                 m_initialChangeSelectionCursor.position() <= classKeywordPosEnd;
649 
650         bool isInClassName = false;
651         int classNamePosEnd = newPosEnd;
652         NameAST *nameAST = classSpecificerAST->name;
653         if (nameAST) {
654             SimpleNameAST *classNameAST = nameAST->asSimpleName();
655             if (classNameAST) {
656                 unsigned identifierTokenIndex = classNameAST->identifier_token;
657                 Token identifierToken = m_unit->tokenAt(identifierTokenIndex);
658                 if (debug)
659                     qDebug() << "identifierToken:" << identifierToken.spell();
660 
661                 int classNamePosStart = getTokenStartCursorPosition(identifierTokenIndex,
662                                                                     m_workingCursor);
663                 classNamePosEnd = getTokenEndCursorPosition(identifierTokenIndex,
664                                                             m_workingCursor);
665 
666                 isInClassName = m_initialChangeSelectionCursor.anchor() >= classNamePosStart &&
667                                 m_initialChangeSelectionCursor.position() <= classNamePosEnd;
668             }
669         }
670 
671         if (currentASTStep() == 1 && isInsideBraces) {
672             if (debug)
673                 qDebug() << "Selecting everything inside braces of class statement.";
674             positions.astPosStart = newPosStart + 1;
675             positions.astPosEnd = newPosEnd - 1;
676         }
677         if (currentASTStep() == 2 && isInsideBraces) {
678             if (debug)
679                 qDebug() << "Selecting braces of class statement.";
680             positions.astPosStart = newPosStart;
681             positions.astPosEnd = newPosEnd;
682         }
683         if (currentASTStep() == 1 && isInClassKeyword) {
684             if (debug)
685                 qDebug() << "Selecting class keyword.";
686             positions.astPosStart = classKeywordPosStart;
687             positions.astPosEnd = classKeywordPosEnd;
688         }
689         if (currentASTStep() == 2 && isInClassKeyword) {
690             if (debug)
691                 qDebug() << "Selecting class keyword and name.";
692             positions.astPosStart = classKeywordPosStart;
693             positions.astPosEnd = classNamePosEnd;
694         }
695         if (currentASTStep() == 1 && isInClassName) {
696             if (debug)
697                 qDebug() << "Selecting class keyword and name.";
698             positions.astPosStart = classKeywordPosStart;
699             positions.astPosEnd = classNamePosEnd;
700         }
701     } else if (NamespaceAST *namespaceAST = ast->asNamespace()) {
702         unsigned namespaceTokenIndex = namespaceAST->namespace_token;
703         unsigned identifierTokenIndex = namespaceAST->identifier_token;
704         Token namespaceToken = m_unit->tokenAt(namespaceTokenIndex);
705         Token identifierToken = m_unit->tokenAt(identifierTokenIndex);
706         if (debug) {
707             qDebug() << "namespace token:" << namespaceToken.spell();
708             qDebug() << "identifier token:" << identifierToken.spell();
709         }
710 
711         int namespacePosStart = getTokenStartCursorPosition(namespaceTokenIndex, m_workingCursor);
712         int namespacePosEnd = getTokenEndCursorPosition(namespaceTokenIndex, m_workingCursor);
713 
714         int identifierPosStart = getTokenStartCursorPosition(identifierTokenIndex, m_workingCursor);
715         int identifierPosEnd = getTokenEndCursorPosition(identifierTokenIndex, m_workingCursor);
716 
717         bool isInNamespaceKeyword =
718                 m_initialChangeSelectionCursor.position() <= namespacePosEnd;
719 
720         bool isInNamespaceIdentifier =
721                 m_initialChangeSelectionCursor.anchor() >= identifierPosStart &&
722                 m_initialChangeSelectionCursor.position() <= identifierPosEnd;
723 
724         if (currentASTStep() == 1) {
725             if (isInNamespaceKeyword) {
726                 if (debug)
727                     qDebug() << "Selecting namespace keyword.";
728                 positions.astPosStart = namespacePosStart;
729                 positions.astPosEnd = namespacePosEnd;
730             }
731             else if (isInNamespaceIdentifier) {
732                 if (debug)
733                     qDebug() << "Selecting namespace identifier.";
734                 positions.astPosStart = identifierPosStart;
735                 positions.astPosEnd = identifierPosEnd;
736             }
737         }
738         else if (currentASTStep() == 2) {
739             if (isInNamespaceKeyword || isInNamespaceIdentifier) {
740                 if (debug)
741                     qDebug() << "Selecting namespace keyword and identifier.";
742                 positions.astPosStart = namespacePosStart;
743                 positions.astPosEnd = identifierPosEnd;
744 
745             }
746         }
747     } else if (ExpressionListParenAST *parenAST = ast->asExpressionListParen()) {
748         unsigned firstParenTokenIndex = parenAST->lparen_token;
749         unsigned lastParenTokenIndex = parenAST->rparen_token;
750         Token firstParenToken = m_unit->tokenAt(firstParenTokenIndex);
751         Token lastParenToken = m_unit->tokenAt(lastParenTokenIndex);
752         if (debug) {
753             qDebug() << "firstParenToken:" << firstParenToken.spell();
754             qDebug() << "lastParenToken:" << lastParenToken.spell();
755         }
756 
757         // Select the parentheses, and everything between.
758         int newPosStart = getTokenStartCursorPosition(firstParenTokenIndex, m_workingCursor);
759         int newPosEnd = getTokenEndCursorPosition(lastParenTokenIndex, m_workingCursor);
760 
761         if (currentASTStep() == 1) {
762             if (debug)
763                 qDebug() << "Selecting everything inside parentheses.";
764             positions.astPosStart = newPosStart + 1;
765             positions.astPosEnd = newPosEnd - 1;
766         }
767         if (currentASTStep() == 2) {
768             if (debug)
769                 qDebug() << "Selecting everything inside including the parentheses.";
770             positions.astPosStart = newPosStart;
771             positions.astPosEnd = newPosEnd;
772         }
773     } else if (FunctionDeclaratorAST* functionDeclaratorAST = ast->asFunctionDeclarator()) {
774         unsigned firstParenTokenIndex = functionDeclaratorAST->lparen_token;
775         unsigned lastParenTokenIndex = functionDeclaratorAST->rparen_token;
776         Token firstParenToken = m_unit->tokenAt(firstParenTokenIndex);
777         Token lastParenToken = m_unit->tokenAt(lastParenTokenIndex);
778         if (debug) {
779             qDebug() << "firstParenToken:" << firstParenToken.spell();
780             qDebug() << "lastParenToken:" << lastParenToken.spell();
781         }
782 
783         int newPosStart = getTokenStartCursorPosition(firstParenTokenIndex, m_workingCursor);
784         int newPosEnd = getTokenEndCursorPosition(lastParenTokenIndex, m_workingCursor);
785 
786         if (currentASTStep() == 1) {
787             if (debug)
788                 qDebug() << "Selecting everything inside and including the parentheses.";
789             positions.astPosStart = newPosStart;
790             positions.astPosEnd = newPosEnd;
791         }
792     } else if (FunctionDefinitionAST *functionDefinitionAST = ast->asFunctionDefinition()) {
793         if (!functionDefinitionAST->function_body)
794             return;
795 
796         CompoundStatementAST *compoundStatementAST =
797                 functionDefinitionAST->function_body->asCompoundStatement();
798         if (!compoundStatementAST)
799             return;
800 
801         if (!functionDefinitionAST->decl_specifier_list
802                 || !functionDefinitionAST->decl_specifier_list->value)
803             return;
804 
805         SimpleSpecifierAST *simpleSpecifierAST =
806                 functionDefinitionAST->decl_specifier_list->value->asSimpleSpecifier();
807         if (!simpleSpecifierAST)
808             return;
809 
810         unsigned firstBraceTokenIndex = compoundStatementAST->lbrace_token;
811         unsigned specifierTokenIndex = simpleSpecifierAST->firstToken();
812         Token firstBraceToken = m_unit->tokenAt(firstBraceTokenIndex);
813         Token specifierToken = m_unit->tokenAt(specifierTokenIndex);
814         if (debug) {
815             qDebug() << "firstBraceToken:" << firstBraceToken.spell();
816             qDebug() << "specifierToken:" << specifierToken.spell();
817         }
818 
819         int firstBracePosEnd = getTokenStartCursorPosition(firstBraceTokenIndex, m_workingCursor);
820 
821         bool isOutsideBraces =
822                 m_initialChangeSelectionCursor.position() <= firstBracePosEnd;
823 
824         if (currentASTStep() == 1 && isOutsideBraces) {
825             int newPosStart = getTokenStartCursorPosition(specifierTokenIndex, m_workingCursor);
826 
827             if (debug)
828                 qDebug() << "Selecting everything to the left of the function braces.";
829             positions.astPosStart = newPosStart;
830             positions.astPosEnd = firstBracePosEnd - 1;
831         }
832     } else if (DeclaratorAST *declaratorAST = ast->asDeclarator()) {
833         PostfixDeclaratorListAST *list = declaratorAST->postfix_declarator_list;
834         if (!list)
835             return;
836 
837         PostfixDeclaratorAST *postfixDeclarator = list->value;
838         if (!postfixDeclarator)
839             return;
840 
841         FunctionDeclaratorAST *functionDeclarator = postfixDeclarator->asFunctionDeclarator();
842         if (!functionDeclarator)
843             return;
844 
845         SpecifierListAST *cv_list = functionDeclarator->cv_qualifier_list;
846         if (!cv_list)
847             return;
848 
849         SpecifierAST *first_cv = cv_list->value;
850         if (!first_cv)
851             return;
852 
853         unsigned firstCVTokenIndex = first_cv->firstToken();
854         Token firstCVToken = m_unit->tokenAt(firstCVTokenIndex);
855         if (debug) {
856             qDebug() << "firstCVTokenIndex:" << firstCVToken.spell();
857         }
858 
859         int cvPosStart = getTokenStartCursorPosition(firstCVTokenIndex, m_workingCursor);
860         bool isBeforeCVList = m_initialChangeSelectionCursor.position() < cvPosStart;
861 
862         if (currentASTStep() == 1 && isBeforeCVList) {
863             if (debug)
864                 qDebug() << "Selecting function declarator without CV qualifiers.";
865 
866             int newPosEnd = cvPosStart;
867             positions.astPosEnd = newPosEnd - 1;
868         }
869 
870     } else if (TemplateIdAST *templateIdAST = ast->asTemplateId()) {
871         unsigned identifierTokenIndex = templateIdAST->identifier_token;
872         Token identifierToken = m_unit->tokenAt(identifierTokenIndex);
873         if (debug) {
874             qDebug() << "identifierTokenIndex:" << identifierToken.spell();
875         }
876 
877         int newPosStart = getTokenStartCursorPosition(identifierTokenIndex, m_workingCursor);
878         int newPosEnd = getTokenEndCursorPosition(identifierTokenIndex, m_workingCursor);
879 
880         bool isInsideIdentifier = m_initialChangeSelectionCursor.anchor() >= newPosStart &&
881                                   m_initialChangeSelectionCursor.position() <= newPosEnd;
882 
883         if (currentASTStep() == 1 && isInsideIdentifier) {
884             if (debug)
885                 qDebug() << "Selecting just identifier before selecting template id.";
886             positions.astPosStart = newPosStart;
887             positions.astPosEnd = newPosEnd;
888         }
889     } else if (TemplateDeclarationAST *templateDeclarationAST = ast->asTemplateDeclaration()) {
890         unsigned templateKeywordTokenIndex = templateDeclarationAST->template_token;
891         unsigned greaterTokenIndex = templateDeclarationAST->greater_token;
892         Token templateKeywordToken = m_unit->tokenAt(templateKeywordTokenIndex);
893         Token greaterToken = m_unit->tokenAt(greaterTokenIndex);
894         if (debug) {
895             qDebug() << "templateKeywordTokenIndex:" << templateKeywordToken.spell();
896             qDebug() << "greaterTokenIndex:" << greaterToken.spell();
897         }
898 
899         int templateKeywordPosStart = getTokenStartCursorPosition(templateKeywordTokenIndex,
900                                                                   m_workingCursor);
901         int templateKeywordPosEnd = getTokenEndCursorPosition(templateKeywordTokenIndex,
902                                                               m_workingCursor);
903 
904         int templateParametersPosEnd = getTokenEndCursorPosition(greaterTokenIndex,
905                                                                  m_workingCursor);
906 
907         bool isInsideTemplateKeyword =
908                 m_initialChangeSelectionCursor.anchor() >= templateKeywordPosStart &&
909                 m_initialChangeSelectionCursor.position() <= templateKeywordPosEnd;
910 
911         if (currentASTStep() == 1 && isInsideTemplateKeyword) {
912             if (debug)
913                 qDebug() << "Selecting template keyword.";
914             positions.astPosStart = templateKeywordPosStart;
915             positions.astPosEnd = templateKeywordPosEnd;
916         }
917         if (currentASTStep() == 2 && isInsideTemplateKeyword) {
918             if (debug)
919                 qDebug() << "Selecting template keyword and parameters.";
920             positions.astPosStart = templateKeywordPosStart;
921             positions.astPosEnd = templateParametersPosEnd;
922         }
923     } else if (LambdaExpressionAST *lambdaExpressionAST = ast->asLambdaExpression()) {
924         // TODO: Fix more lambda cases.
925         LambdaIntroducerAST *lambdaIntroducerAST = lambdaExpressionAST->lambda_introducer;
926         LambdaDeclaratorAST *lambdaDeclaratorAST = lambdaExpressionAST->lambda_declarator;
927         TrailingReturnTypeAST *trailingReturnTypeAST = lambdaDeclaratorAST->trailing_return_type;
928         unsigned firstSquareBracketTokenIndex = lambdaIntroducerAST->lbracket_token;
929         unsigned lastParenTokenIndex = lambdaDeclaratorAST->rparen_token;
930 
931         Token firstSquareBracketToken = m_unit->tokenAt(firstSquareBracketTokenIndex);
932         Token lastParenToken = m_unit->tokenAt(lastParenTokenIndex);
933         if (debug) {
934             qDebug() << "firstSquareBracketToken:" << firstSquareBracketToken.spell();
935             qDebug() << "lastParenToken:" << lastParenToken.spell();
936         }
937 
938         int firstSquareBracketPosStart = getTokenStartCursorPosition(firstSquareBracketTokenIndex,
939                                                                      m_workingCursor);
940         int lastParenPosEnd = getTokenEndCursorPosition(lastParenTokenIndex, m_workingCursor);
941 
942 
943         bool isInsideDeclarator =
944                 m_initialChangeSelectionCursor.anchor() >= firstSquareBracketPosStart &&
945                 m_initialChangeSelectionCursor.position() <= lastParenPosEnd;
946 
947         if (currentASTStep() == 1 && isInsideDeclarator) {
948             if (debug)
949                 qDebug() << "Selecting lambda capture group and arguments.";
950             positions.astPosStart = firstSquareBracketPosStart;
951             positions.astPosEnd = lastParenPosEnd;
952         }
953         if (currentASTStep() == 2 && isInsideDeclarator && trailingReturnTypeAST) {
954             if (debug)
955                 qDebug() << "Selecting lambda prototype.";
956 
957             unsigned lastReturnTypeTokenIndex = trailingReturnTypeAST->lastToken();
958             Token lastReturnTypeToken = m_unit->tokenAt(lastReturnTypeTokenIndex);
959             if (debug)
960                 qDebug() << "lastReturnTypeToken:" << lastReturnTypeToken.spell();
961             int lastReturnTypePosEnd = getTokenEndCursorPosition(lastReturnTypeTokenIndex,
962                                                                  m_workingCursor);
963 
964             positions.astPosStart = firstSquareBracketPosStart;
965             positions.astPosEnd = lastReturnTypePosEnd - 2;
966         }
967     }
968 }
969 
970 bool CppSelectionChanger::performSelectionChange(QTextCursor &cursorToModify)
971 {
972     forever {
973         if (ASTNodePositions positions = findNextASTStepPositions(m_workingCursor)) {
974             if (!shouldSkipASTNodeBasedOnPosition(positions, m_workingCursor)) {
975                 updateCursorSelection(cursorToModify, positions);
976                 return true;
977             } else {
978                 if (debug)
979                     qDebug() << "Skipping node.";
980             }
981         } else if (m_direction == ShrinkSelection) {
982             // The last possible action to do, if there was no step with a smaller selection, is
983             // to set the cursor to the initial change selection cursor, without an anchor.
984             QTextCursor finalCursor(m_initialChangeSelectionCursor);
985             finalCursor.setPosition(finalCursor.position(), QTextCursor::MoveAnchor);
986             cursorToModify = finalCursor;
987             setNodeIndexAndStep(NodeIndexAndStepNotSet);
988             if (debug)
989                 qDebug() << "Final shrink selection case.";
990             return true;
991         } else if (m_direction == ExpandSelection) {
992             // The last possible action to do, if there was no step with a bigger selection, is
993             // to set the cursor to the whole document including header inclusions.
994             QTextCursor finalCursor = getWholeDocumentCursor(m_initialChangeSelectionCursor);
995             cursorToModify = finalCursor;
996             setNodeIndexAndStep(NodeIndexAndStepWholeDocument);
997             if (debug)
998                 qDebug() << "Final expand selection case.";
999             return true;
1000         }
1001         // Break out of the loop, because no further modification of the selection can be done.
1002         else break;
1003     }
1004 
1005     // No next step found for given direction, return early without modifying the cursor.
1006     return false;
1007 }
1008 
1009 void CppSelectionChanger::setNodeIndexAndStep(NodeIndexAndStepState state)
1010 {
1011     switch (state) {
1012         case NodeIndexAndStepWholeDocument:
1013             m_changeSelectionNodeIndex = kChangeSelectionNodeIndexWholeDocoument;
1014             m_nodeCurrentStep = kChangeSelectionNodeIndexWholeDocoument;
1015             break;
1016         case NodeIndexAndStepNotSet:
1017         default:
1018             m_changeSelectionNodeIndex = kChangeSelectionNodeIndexNotSet;
1019             m_nodeCurrentStep = kChangeSelectionNodeIndexNotSet;
1020             break;
1021     }
1022 }
1023 
1024 bool CppSelectionChanger::changeSelection(
1025         Direction direction,
1026         QTextCursor &cursorToModify,
1027         const CPlusPlus::Document::Ptr doc)
1028 {
1029     m_workingCursor = cursorToModify;
1030 
1031     if (hasNoSelectionAndShrinking(direction, m_workingCursor))
1032         return false;
1033 
1034     if (isWholeDocumentSelectedAndExpanding(direction, m_workingCursor))
1035         return false;
1036 
1037     if (!isDocumentAvailable(doc)) {
1038         return false;
1039     }
1040 
1041     ensureCursorSelectionIsNotFlipped(m_workingCursor);
1042 
1043     m_doc = doc;
1044     m_unit = m_doc->translationUnit();
1045     m_direction = direction;
1046 
1047     return performSelectionChange(cursorToModify);
1048 }
1049 
1050 void CppSelectionChanger::startChangeSelection()
1051 {
1052     // Stop cursorPositionChanged signal handler from setting the initial
1053     // change selection cursor, when the cursor is being changed as a result of the change
1054     // selection operation.
1055     m_inChangeSelection = true;
1056 }
1057 
1058 void CppSelectionChanger::stopChangeSelection()
1059 {
1060     m_inChangeSelection = false;
1061 }
1062 
1063 int CppSelectionChanger::possibleASTStepCount(CPlusPlus::AST *ast) const
1064 {
1065     // Different AST nodes, have a different number of steps though which they can go.
1066     // For example in a string literal, we first want to select the literal contents on the first
1067     // step, and then the quotes + the literal content in the second step.
1068     if (!ast)
1069         return 1;
1070     if (ast->asCompoundStatement())
1071         return 2;
1072     if (ast->asCall())
1073         return 3;
1074     if (ast->asStringLiteral())
1075         return 2;
1076     if (NumericLiteralAST* numericLiteralAST = ast->asNumericLiteral()) {
1077         Token firstToken = m_unit->tokenAt(numericLiteralAST->firstToken());
1078         if (firstToken.isCharLiteral())
1079             return 2;
1080         return 1;
1081     }
1082     if (ast->asForStatement())
1083         return 3;
1084     if (ast->asRangeBasedForStatement())
1085         return 3;
1086     if (ast->asClassSpecifier())
1087         return 3;
1088     if (ast->asNamespace())
1089         return 3;
1090     if (ast->asExpressionListParen())
1091         return 2;
1092     if (ast->asFunctionDeclarator())
1093         return 1;
1094     if (ast->asFunctionDefinition())
1095         return 2;
1096     if (ast->asTemplateId())
1097         return 2;
1098     if (ast->asDeclarator())
1099         return 2;
1100     if (ast->asTemplateDeclaration())
1101         return 3;
1102     if (ast->asLambdaExpression())
1103         return 3;
1104 
1105     return 1;
1106 }
1107 
1108 int CppSelectionChanger::currentASTStep() const
1109 {
1110     return m_nodeCurrentStep;
1111 }
1112 
1113 } // namespace CppTools
