Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtDBus module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qdbusintegrator_p.h"
42 
43 #include <qcoreapplication.h>
44 #include <qelapsedtimer.h>
45 #include <qdebug.h>
46 #include <qmetaobject.h>
47 #include <qobject.h>
48 #include <qsocketnotifier.h>
49 #include <qstringlist.h>
50 #include <qtimer.h>
51 #include <qthread.h>
52 #include <private/qlocking_p.h>
53 
54 #include "qdbusargument.h"
55 #include "qdbusconnection_p.h"
56 #include "qdbusconnectionmanager_p.h"
57 #include "qdbusinterface_p.h"
58 #include "qdbusmessage.h"
59 #include "qdbusmetatype.h"
60 #include "qdbusmetatype_p.h"
61 #include "qdbusabstractadaptor.h"
62 #include "qdbusabstractadaptor_p.h"
63 #include "qdbusserver.h"
64 #include "qdbusutil_p.h"
65 #include "qdbusvirtualobject.h"
66 #include "qdbusmessage_p.h"
67 #include "qdbuscontext_p.h"
68 #include "qdbuspendingcall_p.h"
69 
70 #include "qdbusthreaddebug_p.h"
71 
72 #include <algorithm>
73 #ifdef interface
74 #undef interface
75 #endif
76 
77 #ifndef QT_NO_DBUS
78 
79 QT_BEGIN_NAMESPACE
80 
81 // used with dbus_server_allocate_data_slot
82 static dbus_int32_t server_slot = -1;
83 
84 static QBasicAtomicInt isDebugging = Q_BASIC_ATOMIC_INITIALIZER(-1);
85 #define qDBusDebug              if (::isDebugging == 0); else qDebug
86 
87 static inline QDebug operator<<(QDebug dbg, const QThread *th)
88 {
89     QDebugStateSaver saver(dbg);
90     dbg.nospace() << "QThread(ptr=" << (const void*)th;
91     if (th && !th->objectName().isEmpty())
92         dbg.nospace() << ", name=" << th->objectName();
93     else if (th)
94         dbg.nospace() << ", name=" << th->metaObject()->className();
95     dbg.nospace() << ')';
96     return dbg;
97 }
98 
99 #if QDBUS_THREAD_DEBUG
100 static inline QDebug operator<<(QDebug dbg, const QDBusConnectionPrivate *conn)
101 {
102     QDebugStateSaver saver(dbg);
103     dbg.nospace() << "QDBusConnection("
104                   << "ptr=" << (const void*)conn
105                   << ", name=" << conn->name
106                   << ", baseService=" << conn->baseService
107                   << ')';
108     return dbg;
109 }
110 
111 void qdbusDefaultThreadDebug(int action, int condition, QDBusConnectionPrivate *conn)
112 {
113     qDBusDebug() << QThread::currentThread()
114                  << "Qt D-Bus threading action" << action
115                  << (condition == QDBusLockerBase::BeforeLock ? "before lock" :
116                      condition == QDBusLockerBase::AfterLock ? "after lock" :
117                      condition == QDBusLockerBase::BeforeUnlock ? "before unlock" :
118                      condition == QDBusLockerBase::AfterUnlock ? "after unlock" :
119                      condition == QDBusLockerBase::BeforePost ? "before event posting" :
120                      condition == QDBusLockerBase::AfterPost ? "after event posting" :
121                      condition == QDBusLockerBase::BeforeDeliver ? "before event delivery" :
122                      condition == QDBusLockerBase::AfterDeliver ? "after event delivery" :
123                      condition == QDBusLockerBase::BeforeAcquire ? "before acquire" :
124                      condition == QDBusLockerBase::AfterAcquire ? "after acquire" :
125                      condition == QDBusLockerBase::BeforeRelease ? "before release" :
126                      condition == QDBusLockerBase::AfterRelease ? "after release" :
127                      "condition unknown")
128                  << "in connection" << conn;
129 }
130 qdbusThreadDebugFunc qdbusThreadDebug = 0;
131 #endif
132 
133 typedef QVarLengthArray<QDBusSpyCallEvent::Hook, 4> QDBusSpyHookList;
134 Q_GLOBAL_STATIC(QDBusSpyHookList, qDBusSpyHookList)
135 
136 extern "C" {
137 
138     // libdbus-1 callbacks
139 
140 static dbus_bool_t qDBusAddTimeout(DBusTimeout *timeout, void *data)
141 {
142     Q_ASSERT(timeout);
143     Q_ASSERT(data);
144 
145   //  qDebug("addTimeout %d", q_dbus_timeout_get_interval(timeout));
146 
147     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(data);
148     Q_ASSERT(QThread::currentThread() == d->thread());
149 
150     // we may get called from qDBusToggleTimeout
151     if (Q_UNLIKELY(!q_dbus_timeout_get_enabled(timeout)))
152         return false;
153 
154     Q_ASSERT(d->timeouts.key(timeout, 0) == 0);
155 
156     int timerId = d->startTimer(q_dbus_timeout_get_interval(timeout));
157     Q_ASSERT_X(timerId, "QDBusConnection", "Failed to start a timer");
158     if (!timerId)
159         return false;
160 
161     d->timeouts[timerId] = timeout;
162     return true;
163 }
164 
165 static void qDBusRemoveTimeout(DBusTimeout *timeout, void *data)
166 {
167     Q_ASSERT(timeout);
168     Q_ASSERT(data);
169 
170   //  qDebug("removeTimeout");
171 
172     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(data);
173     Q_ASSERT(QThread::currentThread() == d->thread());
174 
175     QDBusConnectionPrivate::TimeoutHash::iterator it = d->timeouts.begin();
176     while (it != d->timeouts.end()) {
177         if (it.value() == timeout) {
178             d->killTimer(it.key());
179             it = d->timeouts.erase(it);
180             break;
181         } else {
182             ++it;
183         }
184     }
185 }
186 
187 static void qDBusToggleTimeout(DBusTimeout *timeout, void *data)
188 {
189     Q_ASSERT(timeout);
190     Q_ASSERT(data);
191 
192     //qDebug("ToggleTimeout");
193 
194     qDBusRemoveTimeout(timeout, data);
195     qDBusAddTimeout(timeout, data);
196 }
197 
198 static dbus_bool_t qDBusAddWatch(DBusWatch *watch, void *data)
199 {
200     Q_ASSERT(watch);
201     Q_ASSERT(data);
202 
203     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(data);
204     Q_ASSERT(QThread::currentThread() == d->thread());
205 
206     int flags = q_dbus_watch_get_flags(watch);
207     int fd = q_dbus_watch_get_unix_fd(watch);
208 
209     QDBusConnectionPrivate::Watcher watcher;
210 
211     if (flags & DBUS_WATCH_READABLE) {
212         //qDebug("addReadWatch %d", fd);
213         watcher.watch = watch;
214         watcher.read = new QSocketNotifier(fd, QSocketNotifier::Read, d);
215         watcher.read->setEnabled(q_dbus_watch_get_enabled(watch));
216         d->connect(watcher.read, &QSocketNotifier::activated, d, &QDBusConnectionPrivate::socketRead);
217     }
218     if (flags & DBUS_WATCH_WRITABLE) {
219         //qDebug("addWriteWatch %d", fd);
220         watcher.watch = watch;
221         watcher.write = new QSocketNotifier(fd, QSocketNotifier::Write, d);
222         watcher.write->setEnabled(q_dbus_watch_get_enabled(watch));
223         d->connect(watcher.write, &QSocketNotifier::activated, d, &QDBusConnectionPrivate::socketWrite);
224     }
225     d->watchers.insertMulti(fd, watcher);
226 
227     return true;
228 }
229 
230 static void qDBusRemoveWatch(DBusWatch *watch, void *data)
231 {
232     Q_ASSERT(watch);
233     Q_ASSERT(data);
234 
235     //qDebug("remove watch");
236 
237     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(data);
238     Q_ASSERT(QThread::currentThread() == d->thread());
239     int fd = q_dbus_watch_get_unix_fd(watch);
240 
241     QDBusConnectionPrivate::WatcherHash::iterator i = d->watchers.find(fd);
242     while (i != d->watchers.end() && i.key() == fd) {
243         if (i.value().watch == watch) {
244             delete i.value().read;
245             delete i.value().write;
246             i = d->watchers.erase(i);
247         } else {
248             ++i;
249         }
250     }
251 }
252 
253 static void qDBusToggleWatch(DBusWatch *watch, void *data)
254 {
255     Q_ASSERT(watch);
256     Q_ASSERT(data);
257 
258     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(data);
259     Q_ASSERT(QThread::currentThread() == d->thread());
260     int fd = q_dbus_watch_get_unix_fd(watch);
261 
262     QDBusConnectionPrivate::WatcherHash::iterator i = d->watchers.find(fd);
263     while (i != d->watchers.end() && i.key() == fd) {
264         if (i.value().watch == watch) {
265             bool enabled = q_dbus_watch_get_enabled(watch);
266             int flags = q_dbus_watch_get_flags(watch);
267 
268             //qDebug("toggle watch %d to %d (write: %d, read: %d)", q_dbus_watch_get_fd(watch), enabled, flags & DBUS_WATCH_WRITABLE, flags & DBUS_WATCH_READABLE);
269 
270             if (flags & DBUS_WATCH_READABLE && i.value().read)
271                 i.value().read->setEnabled(enabled);
272             if (flags & DBUS_WATCH_WRITABLE && i.value().write)
273                 i.value().write->setEnabled(enabled);
274             return;
275         }
276         ++i;
277     }
278 }
279 
280 static void qDBusUpdateDispatchStatus(DBusConnection *connection, DBusDispatchStatus new_status, void *data)
281 {
282     Q_ASSERT(connection);
283     Q_UNUSED(connection);
284     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(data);
285     if (new_status == DBUS_DISPATCH_DATA_REMAINS)
286         emit d->dispatchStatusChanged();
287 }
288 
289 static void qDBusNewConnection(DBusServer *server, DBusConnection *connection, void *data)
290 {
291     // ### We may want to separate the server from the QDBusConnectionPrivate
292     Q_ASSERT(server); Q_UNUSED(server);
293     Q_ASSERT(connection);
294     Q_ASSERT(data);
295 
296     if (!QDBusConnectionManager::instance())
297         return;
298 
299     // keep the connection alive
300     q_dbus_connection_ref(connection);
301     QDBusConnectionPrivate *serverConnection = static_cast<QDBusConnectionPrivate *>(data);
302 
303     // allow anonymous authentication
304     if (serverConnection->anonymousAuthenticationAllowed)
305         q_dbus_connection_set_allow_anonymous(connection, true);
306 
307     QDBusConnectionPrivate *newConnection = new QDBusConnectionPrivate(serverConnection->parent());
308     const auto locker = qt_scoped_lock(QDBusConnectionManager::instance()->mutex);
309     QDBusConnectionManager::instance()->setConnection(QLatin1String("QDBusServer-") + QString::number(reinterpret_cast<qulonglong>(newConnection), 16), newConnection);
310     serverConnection->serverConnectionNames << newConnection->name;
311 
312     // setPeer does the error handling for us
313     QDBusErrorInternal error;
314     newConnection->setPeer(connection, error);
315     newConnection->setDispatchEnabled(false);
316 
317     // this is a queued connection and will resume in the QDBusServer's thread
318     emit serverConnection->newServerConnection(newConnection);
319 
320     // we've disabled dispatching of events, so now we post an event to the
321     // QDBusServer's thread in order to enable it after the
322     // QDBusServer::newConnection() signal has been received by the
323     // application's code
324     newConnection->ref.ref();
325     QReadLocker serverLock(&serverConnection->lock);
326     QDBusConnectionDispatchEnabler *o = new QDBusConnectionDispatchEnabler(newConnection);
327     QTimer::singleShot(0, o, SLOT(execute()));
328     if (serverConnection->serverObject)
329         o->moveToThread(serverConnection->serverObject->thread());
330 }
331 
332 void QDBusConnectionPrivate::_q_newConnection(QDBusConnectionPrivate *newConnection)
333 {
334     Q_ASSERT(mode == ServerMode);
335     emit serverObject->newConnection(QDBusConnectionPrivate::q(newConnection));
336 }
337 
338 } // extern "C"
339 
340 static QByteArray buildMatchRule(const QString &service,
341                                  const QString &objectPath, const QString &interface,
342                                  const QString &member, const QDBusConnectionPrivate::ArgMatchRules &argMatch, const QString & /*signature*/)
343 {
344     QString result;
345     result += QLatin1String("type='signal',");
346     const auto keyValue = QLatin1String("%1='%2',");
347 
348     if (!service.isEmpty())
349         result += keyValue.arg(QLatin1String("sender"), service);
350     if (!objectPath.isEmpty())
351         result += keyValue.arg(QLatin1String("path"), objectPath);
352     if (!interface.isEmpty())
353         result += keyValue.arg(QLatin1String("interface"), interface);
354     if (!member.isEmpty())
355         result += keyValue.arg(QLatin1String("member"), member);
356 
357     // add the argument string-matching now
358     if (!argMatch.args.isEmpty()) {
359         const QString keyValue = QLatin1String("arg%1='%2',");
360         for (int i = 0; i < argMatch.args.count(); ++i)
361             if (!argMatch.args.at(i).isNull())
362                 result += keyValue.arg(i).arg(argMatch.args.at(i));
363     }
364     if (!argMatch.arg0namespace.isEmpty()) {
365         result += QLatin1String("arg0namespace='%1',").arg(argMatch.arg0namespace);
366     }
367 
368     result.chop(1);             // remove ending comma
369     return result.toLatin1();
370 }
371 
372 static bool findObject(const QDBusConnectionPrivate::ObjectTreeNode *root,
373                        const QString &fullpath, int &usedLength,
374                        QDBusConnectionPrivate::ObjectTreeNode &result)
375 {
376     if (!fullpath.compare(QLatin1String("/")) && root->obj) {
377         usedLength = 1;
378         result = *root;
379         return root;
380     }
381     int start = 0;
382     int length = fullpath.length();
383     if (fullpath.at(0) == QLatin1Char('/'))
384         start = 1;
385 
386     // walk the object tree
387     QDBusConnectionPrivate::ObjectTreeNode::DataList::ConstIterator node = root;
388     while (start < length && node) {
389         if (node->flags & QDBusConnection::ExportChildObjects)
390             break;
391         if ((node->flags & QDBusConnectionPrivate::VirtualObject) && (node->flags & QDBusConnection::SubPath))
392             break;
393         int end = fullpath.indexOf(QLatin1Char('/'), start);
394         end = (end == -1 ? length : end);
395         QStringRef pathComponent(&fullpath, start, end - start);
396 
397         QDBusConnectionPrivate::ObjectTreeNode::DataList::ConstIterator it =
398             std::lower_bound(node->children.constBegin(), node->children.constEnd(), pathComponent);
399         if (it != node->children.constEnd() && it->name == pathComponent)
400             // match
401             node = it;
402         else
403             node = 0;
404 
405         start = end + 1;
406     }
407 
408     // found our object
409     usedLength = (start > length ? length : start);
410     if (node) {
411         if (node->obj || !node->children.isEmpty())
412             result = *node;
413         else
414             // there really is no object here
415             // we're just looking at an unused space in the QVector
416             node = 0;
417     }
418     return node;
419 }
420 
421 static QObject *findChildObject(const QDBusConnectionPrivate::ObjectTreeNode *root,
422                                 const QString &fullpath, int start)
423 {
424     int length = fullpath.length();
425 
426     // any object in the tree can tell us to switch to its own object tree:
427     const QDBusConnectionPrivate::ObjectTreeNode *node = root;
428     if (node && node->flags & QDBusConnection::ExportChildObjects) {
429         QObject *obj = node->obj;
430 
431         while (obj) {
432             if (start >= length)
433                 // we're at the correct level
434                 return obj;
435 
436             int pos = fullpath.indexOf(QLatin1Char('/'), start);
437             pos = (pos == -1 ? length : pos);
438             QStringRef pathComponent(&fullpath, start, pos - start);
439 
440             const QObjectList children = obj->children();
441 
442             // find a child with the proper name
443             QObject *next = 0;
444             QObjectList::ConstIterator it = children.constBegin();
445             QObjectList::ConstIterator end = children.constEnd();
446             for ( ; it != end; ++it)
447                 if ((*it)->objectName() == pathComponent) {
448                     next = *it;
449                     break;
450                 }
451 
452             if (!next)
453                 break;
454 
455             obj = next;
456             start = pos + 1;
457         }
458     }
459 
460     // object not found
461     return 0;
462 }
463 
464 static QDBusConnectionPrivate::ArgMatchRules matchArgsForService(const QString &service, QDBusServiceWatcher::WatchMode mode)
465 {
466     QDBusConnectionPrivate::ArgMatchRules matchArgs;
467     if (service.endsWith(QLatin1Char('*'))) {
468         matchArgs.arg0namespace = service.chopped(1);
469         matchArgs.args << QString();
470     }
471     else
472         matchArgs.args << service;
473 
474     switch (mode) {
475     case QDBusServiceWatcher::WatchForOwnerChange:
476         break;
477 
478     case QDBusServiceWatcher::WatchForRegistration:
479         matchArgs.args << QString::fromLatin1("", 0);
480         break;
481 
482     case QDBusServiceWatcher::WatchForUnregistration:
483         matchArgs.args << QString() << QString::fromLatin1("", 0);
484         break;
485     }
486     return matchArgs;
487 }
488 
489 
490 extern Q_DBUS_EXPORT void qDBusAddSpyHook(QDBusSpyCallEvent::Hook);
491 void qDBusAddSpyHook(QDBusSpyCallEvent::Hook hook)
492 {
493     qDBusSpyHookList()->append(hook);
494 }
495 
496 QDBusSpyCallEvent::~QDBusSpyCallEvent()
497 {
498     // Reinsert the message into the processing queue for the connection.
499     // This is done in the destructor so the message is reinserted even if
500     // QCoreApplication is destroyed.
501     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(const_cast<QObject *>(sender()));
502     qDBusDebug() << d << "message spies done for" << msg;
503     emit d->spyHooksFinished(msg);
504 }
505 
506 void QDBusSpyCallEvent::placeMetaCall(QObject *)
507 {
508     invokeSpyHooks(msg, hooks, hookCount);
509 }
510 
511 inline void QDBusSpyCallEvent::invokeSpyHooks(const QDBusMessage &msg, const Hook *hooks, int hookCount)
512 {
513     // call the spy hook list
514     for (int i = 0; i < hookCount; ++i)
515         hooks[i](msg);
516 }
517 
518 extern "C" {
519 static DBusHandlerResult
520 qDBusSignalFilter(DBusConnection *connection, DBusMessage *message, void *data)
521 {
522     Q_ASSERT(data);
523     Q_UNUSED(connection);
524     QDBusConnectionPrivate *d = static_cast<QDBusConnectionPrivate *>(data);
525     if (d->mode == QDBusConnectionPrivate::InvalidMode)
526         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
527 
528     QDBusMessage amsg = QDBusMessagePrivate::fromDBusMessage(message, d->capabilities);
529     qDBusDebug() << d << "got message (signal):" << amsg;
530 
531     return d->handleMessage(amsg) ?
532         DBUS_HANDLER_RESULT_HANDLED :
533         DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
534 }
535 }
536 
537 bool QDBusConnectionPrivate::handleMessage(const QDBusMessage &amsg)
538 {
539     if (!ref.loadRelaxed())
540         return false;
541 
542     // local message are always delivered, regardless of filtering
543     // or whether the dispatcher is enabled
544     bool isLocal = QDBusMessagePrivate::isLocal(amsg);
545 
546     if (!dispatchEnabled && !isLocal) {
547         // queue messages only, we'll handle them later
548         qDBusDebug() << this << "delivery is suspended";
549         pendingMessages << amsg;
550         return amsg.type() == QDBusMessage::MethodCallMessage;
551     }
552 
553     switch (amsg.type()) {
554     case QDBusMessage::SignalMessage:
555         handleSignal(amsg);
556         // if there are any other filters in this DBusConnection,
557         // let them see the signal too
558         return false;
559     case QDBusMessage::MethodCallMessage:
560         // run it through the spy filters (if any) before the regular processing:
561         // a) if it's a local message, we're in the caller's thread, so invoke the filter directly
562         // b) if it's an external message, post to the main thread
563         if (Q_UNLIKELY(qDBusSpyHookList.exists()) && qApp) {
564             const QDBusSpyHookList &list = *qDBusSpyHookList;
565             if (isLocal) {
566                 Q_ASSERT(QThread::currentThread() != thread());
567                 qDBusDebug() << this << "invoking message spies directly";
568                 QDBusSpyCallEvent::invokeSpyHooks(amsg, list.constData(), list.size());
569             } else {
570                 qDBusDebug() << this << "invoking message spies via event";
571                 QCoreApplication::postEvent(qApp, new QDBusSpyCallEvent(this, QDBusConnection(this),
572                                                                         amsg, list.constData(), list.size()));
573 
574                 // we'll be called back, so return
575                 return true;
576             }
577         }
578 
579         handleObjectCall(amsg);
580         return true;
581     case QDBusMessage::ReplyMessage:
582     case QDBusMessage::ErrorMessage:
583     case QDBusMessage::InvalidMessage:
584         return false;           // we don't handle those here
585     }
586 
587     return false;
588 }
589 
590 static void huntAndDestroy(QObject *needle, QDBusConnectionPrivate::ObjectTreeNode &haystack)
591 {
592     for (auto &node : haystack.children)
593         huntAndDestroy(needle, node);
594 
595     auto isInactive = [](QDBusConnectionPrivate::ObjectTreeNode &node) { return !node.isActive(); };
596 
597     haystack.children.erase(std::remove_if(haystack.children.begin(), haystack.children.end(),
598                                            isInactive),
599                             haystack.children.end());
600 
601     if (needle == haystack.obj) {
602         haystack.obj = 0;
603         haystack.flags = 0;
604     }
605 }
606 
607 static void huntAndUnregister(const QVector<QStringRef> &pathComponents, int i, QDBusConnection::UnregisterMode mode,
608                               QDBusConnectionPrivate::ObjectTreeNode *node)
609 {
610     if (pathComponents.count() == i) {
611         // found it
612         node->obj = 0;
613         node->flags = 0;
614 
615         if (mode == QDBusConnection::UnregisterTree) {
616             // clear the sub-tree as well
617             node->children.clear();  // can't disconnect the objects because we really don't know if they can
618                             // be found somewhere else in the path too
619         }
620     } else {
621         // keep going
622         QDBusConnectionPrivate::ObjectTreeNode::DataList::Iterator end = node->children.end();
623         QDBusConnectionPrivate::ObjectTreeNode::DataList::Iterator it =
624             std::lower_bound(node->children.begin(), end, pathComponents.at(i));
625         if (it == end || it->name != pathComponents.at(i))
626             return;              // node not found
627 
628         huntAndUnregister(pathComponents, i + 1, mode, it);
629         if (!it->isActive())
630             node->children.erase(it);
631     }
632 }
633 
634 static void huntAndEmit(DBusConnection *connection, DBusMessage *msg,
635                         QObject *needle, const QDBusConnectionPrivate::ObjectTreeNode &haystack,
636                         bool isScriptable, bool isAdaptor, const QString &path = QString())
637 {
638     QDBusConnectionPrivate::ObjectTreeNode::DataList::ConstIterator it = haystack.children.constBegin();
639     QDBusConnectionPrivate::ObjectTreeNode::DataList::ConstIterator end = haystack.children.constEnd();
640     for ( ; it != end; ++it) {
641         if (it->isActive())
642             huntAndEmit(connection, msg, needle, *it, isScriptable, isAdaptor, path + QLatin1Char('/') + it->name);
643     }
644 
645     if (needle == haystack.obj) {
646         // is this a signal we should relay?
647         if (isAdaptor && (haystack.flags & QDBusConnection::ExportAdaptors) == 0)
648             return;             // no: it comes from an adaptor and we're not exporting adaptors
649         else if (!isAdaptor) {
650             int mask = isScriptable
651                        ? QDBusConnection::ExportScriptableSignals
652                        : QDBusConnection::ExportNonScriptableSignals;
653             if ((haystack.flags & mask) == 0)
654                 return;         // signal was not exported
655         }
656 
657         QByteArray p = path.toLatin1();
658         if (p.isEmpty())
659             p = "/";
660         qDBusDebug() << QThread::currentThread() << "emitting signal at" << p;
661         DBusMessage *msg2 = q_dbus_message_copy(msg);
662         q_dbus_message_set_path(msg2, p);
663         q_dbus_connection_send(connection, msg2, 0);
664         q_dbus_message_unref(msg2);
665     }
666 }
667 
668 static int findSlot(const QMetaObject *mo, const QByteArray &name, int flags,
669                     const QString &signature_, QVector<int> &metaTypes)
670 {
671     QByteArray msgSignature = signature_.toLatin1();
672 
673     for (int idx = mo->methodCount() - 1 ; idx >= QObject::staticMetaObject.methodCount(); --idx) {
674         QMetaMethod mm = mo->method(idx);
675 
676         // check access:
677         if (mm.access() != QMetaMethod::Public)
678             continue;
679 
680         // check type:
681         if (mm.methodType() != QMetaMethod::Slot && mm.methodType() != QMetaMethod::Method)
682             continue;
683 
684         // check name:
685         if (mm.name() != name)
686             continue;
687 
688         int returnType = mm.returnType();
689         bool isAsync = qDBusCheckAsyncTag(mm.tag());
690         bool isScriptable = mm.attributes() & QMetaMethod::Scriptable;
691 
692         // consistency check:
693         if (isAsync && returnType != QMetaType::Void)
694             continue;
695 
696         QString errorMsg;
697         int inputCount = qDBusParametersForMethod(mm, metaTypes, errorMsg);
698         if (inputCount == -1)
699             continue;           // problem parsing
700 
701         metaTypes[0] = returnType;
702         bool hasMessage = false;
703         if (inputCount > 0 &&
704             metaTypes.at(inputCount) == QDBusMetaTypeId::message()) {
705             // "no input parameters" is allowed as long as the message meta type is there
706             hasMessage = true;
707             --inputCount;
708         }
709 
710         // try to match the parameters
711         int i;
712         QByteArray reconstructedSignature;
713         for (i = 1; i <= inputCount; ++i) {
714             const char *typeSignature = QDBusMetaType::typeToSignature( metaTypes.at(i) );
715             if (!typeSignature)
716                 break;          // invalid
717 
718             reconstructedSignature += typeSignature;
719             if (!msgSignature.startsWith(reconstructedSignature))
720                 break;
721         }
722 
723         if (reconstructedSignature != msgSignature)
724             continue;           // we didn't match them all
725 
726         if (hasMessage)
727             ++i;
728 
729         // make sure that the output parameters have signatures too
730         if (returnType != QMetaType::UnknownType && returnType != QMetaType::Void && QDBusMetaType::typeToSignature(returnType) == 0)
731             continue;
732 
733         bool ok = true;
734         for (int j = i; ok && j < metaTypes.count(); ++j)
735             if (QDBusMetaType::typeToSignature(metaTypes.at(i)) == 0)
736                 ok = false;
737         if (!ok)
738             continue;
739 
740         // consistency check:
741         if (isAsync && metaTypes.count() > i + 1)
742             continue;
743 
744         if (mm.methodType() == QMetaMethod::Slot) {
745             if (isScriptable && (flags & QDBusConnection::ExportScriptableSlots) == 0)
746                 continue;           // scriptable slots not exported
747             if (!isScriptable && (flags & QDBusConnection::ExportNonScriptableSlots) == 0)
748                 continue;           // non-scriptable slots not exported
749         } else {
750             if (isScriptable && (flags & QDBusConnection::ExportScriptableInvokables) == 0)
751                 continue;           // scriptable invokables not exported
752             if (!isScriptable && (flags & QDBusConnection::ExportNonScriptableInvokables) == 0)
753                 continue;           // non-scriptable invokables not exported
754         }
755 
756         // if we got here, this slot matched
757         return idx;
758     }
759 
760     // no slot matched
761     return -1;
762 }
763 
764 /*!
765     \internal
766     Enables or disables the delivery of incoming method calls and signals. If
767     \a enable is true, this will also cause any queued, pending messages to be
768     delivered.
769  */
770 void QDBusConnectionPrivate::setDispatchEnabled(bool enable)
771 {
772     checkThread();
773     dispatchEnabled = enable;
774     if (enable)
775         emit dispatchStatusChanged();
776 }
777 
778 static QDBusCallDeliveryEvent * const DIRECT_DELIVERY = (QDBusCallDeliveryEvent *)1;
779 
780 QDBusCallDeliveryEvent* QDBusConnectionPrivate::prepareReply(QDBusConnectionPrivate *target,
781                                                              QObject *object, int idx,
782                                                              const QVector<int> &metaTypes,
783                                                              const QDBusMessage &msg)
784 {
785     Q_ASSERT(object);
786     Q_UNUSED(object);
787 
788     int n = metaTypes.count() - 1;
789     if (metaTypes[n] == QDBusMetaTypeId::message())
790         --n;
791 
792     if (msg.arguments().count() < n)
793         return 0;               // too few arguments
794 
795     // check that types match
796     for (int i = 0; i < n; ++i)
797         if (metaTypes.at(i + 1) != msg.arguments().at(i).userType() &&
798             msg.arguments().at(i).userType() != qMetaTypeId<QDBusArgument>())
799             return 0;           // no match
800 
801     // we can deliver
802     // prepare for the call
803     if (target == object)
804         return DIRECT_DELIVERY;
805     return new QDBusCallDeliveryEvent(QDBusConnection(target), idx, target, msg, metaTypes);
806 }
807 
808 void QDBusConnectionPrivate::activateSignal(const QDBusConnectionPrivate::SignalHook& hook,
809                                             const QDBusMessage &msg)
810 {
811     // This is called by QDBusConnectionPrivate::handleSignal to deliver a signal
812     // that was received from D-Bus
813     //
814     // Signals are delivered to slots if the parameters match
815     // Slots can have less parameters than there are on the message
816     // Slots can optionally have one final parameter that is a QDBusMessage
817     // Slots receive read-only copies of the message (i.e., pass by value or by const-ref)
818     QDBusCallDeliveryEvent *call = prepareReply(this, hook.obj, hook.midx, hook.params, msg);
819     if (call == DIRECT_DELIVERY) {
820         // short-circuit delivery
821         Q_ASSERT(this == hook.obj);
822         deliverCall(this, 0, msg, hook.params, hook.midx);
823         return;
824     }
825     if (call)
826         postEventToThread(ActivateSignalAction, hook.obj, call);
827 }
828 
829 bool QDBusConnectionPrivate::activateCall(QObject* object, int flags, const QDBusMessage &msg)
830 {
831     // This is called by QDBusConnectionPrivate::handleObjectCall to place a call
832     // to a slot on the object.
833     //
834     // The call is delivered to the first slot that matches the following conditions:
835     //  - has the same name as the message's target member
836     //  - ALL of the message's types are found in slot's parameter list
837     //  - optionally has one more parameter of type QDBusMessage
838     // If none match, then the slot of the same name as the message target and with
839     // the first type of QDBusMessage is delivered.
840     //
841     // The D-Bus specification requires that all MethodCall messages be replied to, unless the
842     // caller specifically waived this requirement. This means that we inspect if the user slot
843     // generated a reply and, if it didn't, we will. Obviously, if the user slot doesn't take a
844     // QDBusMessage parameter, it cannot generate a reply.
845     //
846     // When a return message is generated, the slot's return type, if any, will be placed
847     // in the message's first position. If there are non-const reference parameters to the
848     // slot, they must appear at the end and will be placed in the subsequent message
849     // positions.
850 
851     static const char cachePropertyName[] = "_qdbus_slotCache";
852 
853     if (!object)
854         return false;
855 
856     Q_ASSERT_X(QThread::currentThread() == object->thread(),
857                "QDBusConnection: internal threading error",
858                "function called for an object that is in another thread!!");
859 
860     QDBusSlotCache slotCache =
861         qvariant_cast<QDBusSlotCache>(object->property(cachePropertyName));
862     QString cacheKey = msg.member(), signature = msg.signature();
863     if (!signature.isEmpty()) {
864         cacheKey.reserve(cacheKey.length() + 1 + signature.length());
865         cacheKey += QLatin1Char('.');
866         cacheKey += signature;
867     }
868 
869     QDBusSlotCache::Hash::ConstIterator cacheIt = slotCache.hash.constFind(cacheKey);
870     while (cacheIt != slotCache.hash.constEnd() && cacheIt->flags != flags &&
871            cacheIt.key() == cacheKey)
872         ++cacheIt;
873     if (cacheIt == slotCache.hash.constEnd() || cacheIt.key() != cacheKey)
874     {
875         // not cached, analyze the meta object
876         const QMetaObject *mo = object->metaObject();
877         QByteArray memberName = msg.member().toUtf8();
878 
879         // find a slot that matches according to the rules above
880         QDBusSlotCache::Data slotData;
881         slotData.flags = flags;
882         slotData.slotIdx = ::findSlot(mo, memberName, flags, msg.signature(), slotData.metaTypes);
883         if (slotData.slotIdx == -1) {
884             // ### this is where we want to add the connection as an arg too
885             // try with no parameters, but with a QDBusMessage
886             slotData.slotIdx = ::findSlot(mo, memberName, flags, QString(), slotData.metaTypes);
887             if (slotData.metaTypes.count() != 2 ||
888                 slotData.metaTypes.at(1) != QDBusMetaTypeId::message()) {
889                 // not found
890                 // save the negative lookup
891                 slotData.slotIdx = -1;
892                 slotData.metaTypes.clear();
893                 slotCache.hash.insert(cacheKey, slotData);
894                 object->setProperty(cachePropertyName, QVariant::fromValue(slotCache));
895                 return false;
896             }
897         }
898 
899         // save to the cache
900         slotCache.hash.insert(cacheKey, slotData);
901         object->setProperty(cachePropertyName, QVariant::fromValue(slotCache));
902 
903         // found the slot to be called
904         deliverCall(object, flags, msg, slotData.metaTypes, slotData.slotIdx);
905         return true;
906     } else if (cacheIt->slotIdx == -1) {
907         // negative cache
908         return false;
909     } else {
910         // use the cache
911         deliverCall(object, flags, msg, cacheIt->metaTypes, cacheIt->slotIdx);
912         return true;
913     }
914     return false;
915 }
916 
917 void QDBusConnectionPrivate::deliverCall(QObject *object, int /*flags*/, const QDBusMessage &msg,
918                                          const QVector<int> &metaTypes, int slotIdx)
919 {
920     Q_ASSERT_X(!object || QThread::currentThread() == object->thread(),
921                "QDBusConnection: internal threading error",
922                "function called for an object that is in another thread!!");
923 
924     QVarLengthArray<void *, 10> params;
925     params.reserve(metaTypes.count());
926 
927     QVariantList auxParameters;
928     // let's create the parameter list
929 
930     // first one is the return type -- add it below
931     params.append(0);
932 
933     // add the input parameters
934     int i;
935     int pCount = qMin(msg.arguments().count(), metaTypes.count() - 1);
936     for (i = 1; i <= pCount; ++i) {
937         int id = metaTypes[i];
938         if (id == QDBusMetaTypeId::message())
939             break;
940 
941         const QVariant &arg = msg.arguments().at(i - 1);
942         if (arg.userType() == id)
943             // no conversion needed
944             params.append(const_cast<void *>(arg.constData()));
945         else if (arg.userType() == qMetaTypeId<QDBusArgument>()) {
946             // convert to what the function expects
947             void *null = 0;
948             auxParameters.append(QVariant(id, null));
949 
950             const QDBusArgument &in =
951                 *reinterpret_cast<const QDBusArgument *>(arg.constData());
952             QVariant &out = auxParameters[auxParameters.count() - 1];
953 
954             if (Q_UNLIKELY(!QDBusMetaType::demarshall(in, out.userType(), out.data())))
955                 qFatal("Internal error: demarshalling function for type '%s' (%d) failed!",
956                        out.typeName(), out.userType());
957 
958             params.append(const_cast<void *>(out.constData()));
959         } else {
960             qFatal("Internal error: got invalid meta type %d (%s) "
961                    "when trying to convert to meta type %d (%s)",
962                    arg.userType(), QMetaType::typeName(arg.userType()),
963                    id, QMetaType::typeName(id));
964         }
965     }
966 
967     if (metaTypes.count() > i && metaTypes[i] == QDBusMetaTypeId::message()) {
968         params.append(const_cast<void*>(static_cast<const void*>(&msg)));
969         ++i;
970     }
971 
972     // output arguments
973     const int numMetaTypes = metaTypes.count();
974     QVariantList outputArgs;
975     void *null = 0;
976     if (metaTypes[0] != QMetaType::Void && metaTypes[0] != QMetaType::UnknownType) {
977         outputArgs.reserve(numMetaTypes - i + 1);
978         QVariant arg(metaTypes[0], null);
979         outputArgs.append( arg );
980         params[0] = const_cast<void*>(outputArgs.at( outputArgs.count() - 1 ).constData());
981     } else {
982         outputArgs.reserve(numMetaTypes - i);
983     }
984 
985     for ( ; i < numMetaTypes; ++i) {
986         QVariant arg(metaTypes[i], null);
987         outputArgs.append( arg );
988         params.append(const_cast<void*>(outputArgs.at( outputArgs.count() - 1 ).constData()));
989     }
990 
991     // make call:
992     bool fail;
993     if (!object) {
994         fail = true;
995     } else {
996         // FIXME: save the old sender!
997         QDBusContextPrivate context(QDBusConnection(this), msg);
998         QDBusContextPrivate *old = QDBusContextPrivate::set(object, &context);
999 
1000         QPointer<QObject> ptr = object;
1001         fail = object->qt_metacall(QMetaObject::InvokeMetaMethod,
1002                                    slotIdx, params.data()) >= 0;
1003         // the object might be deleted in the slot
1004         if (!ptr.isNull())
1005             QDBusContextPrivate::set(object, old);
1006     }
1007 
1008     // do we create a reply? Only if the caller is waiting for a reply and one hasn't been sent
1009     // yet.
1010     if (msg.isReplyRequired() && !msg.isDelayedReply()) {
1011         if (!fail) {
1012             // normal reply
1013             qDBusDebug() << this << "Automatically sending reply:" << outputArgs;
1014             send(msg.createReply(outputArgs));
1015         } else {
1016             // generate internal error
1017             qWarning("Internal error: Failed to deliver message");
1018             send(msg.createErrorReply(QDBusError::InternalError,
1019                                       QLatin1String("Failed to deliver message")));
1020         }
1021     }
1022 
1023     return;
1024 }
1025 
1026 extern bool qDBusInitThreads();
1027 
1028 QDBusConnectionPrivate::QDBusConnectionPrivate(QObject *p)
1029     : QObject(p), ref(1), capabilities(0), mode(InvalidMode), busService(0),
1030       connection(0),
1031       rootNode(QString(QLatin1Char('/'))),
1032       anonymousAuthenticationAllowed(false),
1033       dispatchEnabled(true)
1034 {
1035     static const bool threads = q_dbus_threads_init_default();
1036     if (::isDebugging == -1)
1037        ::isDebugging = qEnvironmentVariableIntValue("QDBUS_DEBUG");
1038     Q_UNUSED(threads)
1039 
1040 #ifdef QDBUS_THREAD_DEBUG
1041     if (::isDebugging > 1)
1042         qdbusThreadDebug = qdbusDefaultThreadDebug;
1043 #endif
1044 
1045     QDBusMetaTypeId::init();
1046     connect(this, &QDBusConnectionPrivate::dispatchStatusChanged,
1047             this, &QDBusConnectionPrivate::doDispatch, Qt::QueuedConnection);
1048     connect(this, &QDBusConnectionPrivate::spyHooksFinished,
1049             this, &QDBusConnectionPrivate::handleObjectCall, Qt::QueuedConnection);
1050     connect(this, &QDBusConnectionPrivate::messageNeedsSending,
1051             this, &QDBusConnectionPrivate::sendInternal);
1052     connect(this, &QDBusConnectionPrivate::signalNeedsConnecting,
1053             this, &QDBusConnectionPrivate::addSignalHook, Qt::BlockingQueuedConnection);
1054     connect(this, &QDBusConnectionPrivate::signalNeedsDisconnecting,
1055             this, &QDBusConnectionPrivate::removeSignalHook, Qt::BlockingQueuedConnection);
1056 
1057     rootNode.flags = 0;
1058 
1059     // prepopulate watchedServices:
1060     // we know that the owner of org.freedesktop.DBus is itself
1061     watchedServices.insert(QDBusUtil::dbusService(), WatchedServiceData(QDBusUtil::dbusService(), 1));
1062 
1063     // prepopulate matchRefCounts:
1064     // we know that org.freedesktop.DBus will never change owners
1065     matchRefCounts.insert("type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0='org.freedesktop.DBus'", 1);
1066 }
1067 
1068 QDBusConnectionPrivate::~QDBusConnectionPrivate()
1069 {
1070     if (thread() && thread() != QThread::currentThread())
1071         qWarning("QDBusConnection(name=\"%s\")'s last reference in not in its creation thread! "
1072                  "Timer and socket errors will follow and the program will probably crash",
1073                  qPrintable(name));
1074 
1075     auto lastMode = mode; // reset on connection close
1076     closeConnection();
1077     qDeleteAll(cachedMetaObjects);
1078 
1079     if (lastMode == ClientMode || lastMode == PeerMode) {
1080         // the bus service object holds a reference back to us;
1081         // we need to destroy it before we finish destroying ourselves
1082         Q_ASSERT(ref.loadRelaxed() == 0);
1083         QObject *obj = (QObject *)busService;
1084         if (obj) {
1085             disconnect(obj, nullptr, this, nullptr);
1086             delete obj;
1087         }
1088         if (connection)
1089             q_dbus_connection_unref(connection);
1090         connection = 0;
1091     } else if (lastMode == ServerMode) {
1092         if (server)
1093             q_dbus_server_unref(server);
1094         server = 0;
1095     }
1096 }
1097 
1098 void QDBusConnectionPrivate::collectAllObjects(QDBusConnectionPrivate::ObjectTreeNode &haystack,
1099                                                QSet<QObject *> &set)
1100 {
1101     QDBusConnectionPrivate::ObjectTreeNode::DataList::Iterator it = haystack.children.begin();
1102 
1103     while (it != haystack.children.end()) {
1104         collectAllObjects(*it, set);
1105         it++;
1106     }
1107 
1108     if (haystack.obj)
1109         set.insert(haystack.obj);
1110 }
1111 
1112 void QDBusConnectionPrivate::closeConnection()
1113 {
1114     QDBusWriteLocker locker(CloseConnectionAction, this);
1115     qDBusDebug() << this << "Disconnected";
1116     ConnectionMode oldMode = mode;
1117     mode = InvalidMode; // prevent reentrancy
1118     baseService.clear();
1119 
1120     if (oldMode == ServerMode && server) {
1121         q_dbus_server_disconnect(server);
1122         q_dbus_server_free_data_slot(&server_slot);
1123     }
1124 
1125     if (oldMode == ClientMode || oldMode == PeerMode) {
1126         if (connection) {
1127             q_dbus_connection_close(connection);
1128             // send the "close" message
1129             while (q_dbus_connection_dispatch(connection) == DBUS_DISPATCH_DATA_REMAINS)
1130                 ;
1131         }
1132     }
1133 
1134     qDeleteAll(pendingCalls);
1135 
1136     // Disconnect all signals from signal hooks and from the object tree to
1137     // avoid QObject::destroyed being sent to dbus daemon thread which has
1138     // already quit. We need to make sure we disconnect exactly once per
1139     // object, because if we tried a second time, we might be hitting a
1140     // dangling pointer.
1141     QSet<QObject *> allObjects;
1142     collectAllObjects(rootNode, allObjects);
1143     SignalHookHash::const_iterator sit = signalHooks.constBegin();
1144     while (sit != signalHooks.constEnd()) {
1145         allObjects.insert(sit.value().obj);
1146         ++sit;
1147     }
1148 
1149     // now disconnect ourselves
1150     QSet<QObject *>::const_iterator oit = allObjects.constBegin();
1151     while (oit != allObjects.constEnd()) {
1152         (*oit)->disconnect(this);
1153         ++oit;
1154     }
1155 }
1156 
1157 void QDBusConnectionPrivate::handleDBusDisconnection()
1158 {
1159     while (!pendingCalls.isEmpty())
1160         processFinishedCall(pendingCalls.first());
1161 }
1162 
1163 void QDBusConnectionPrivate::checkThread()
1164 {
1165     Q_ASSERT(thread() == QDBusConnectionManager::instance());
1166     Q_ASSERT(QThread::currentThread() == thread());
1167 }
1168 
1169 bool QDBusConnectionPrivate::handleError(const QDBusErrorInternal &error)
1170 {
1171     if (!error)
1172         return false;           // no error
1173 
1174     //lock.lockForWrite();
1175     lastError = error;
1176     //lock.unlock();
1177     return true;
1178 }
1179 
1180 void QDBusConnectionPrivate::timerEvent(QTimerEvent *e)
1181 {
1182     {
1183         DBusTimeout *timeout = timeouts.value(e->timerId(), 0);
1184         if (timeout)
1185             q_dbus_timeout_handle(timeout);
1186     }
1187 
1188     doDispatch();
1189 }
1190 
1191 void QDBusConnectionPrivate::doDispatch()
1192 {
1193     if (mode == ClientMode || mode == PeerMode) {
1194         while (q_dbus_connection_dispatch(connection) == DBUS_DISPATCH_DATA_REMAINS) ;
1195         if (dispatchEnabled && !pendingMessages.isEmpty()) {
1196             // dispatch previously queued messages
1197             PendingMessageList::Iterator it = pendingMessages.begin();
1198             PendingMessageList::Iterator end = pendingMessages.end();
1199             for ( ; it != end; ++it) {
1200                 qDBusDebug() << this << "dequeueing message" << *it;
1201                 handleMessage(std::move(*it));
1202             }
1203             pendingMessages.clear();
1204         }
1205     }
1206 }
1207 
1208 void QDBusConnectionPrivate::socketRead(int fd)
1209 {
1210     WatcherHash::ConstIterator it = watchers.constFind(fd);
1211     while (it != watchers.constEnd() && it.key() == fd) {
1212         if (it->watch && it->read && it->read->isEnabled()) {
1213             if (!q_dbus_watch_handle(it.value().watch, DBUS_WATCH_READABLE))
1214                 qDebug("OUT OF MEM");
1215             break;
1216         }
1217         ++it;
1218     }
1219     doDispatch();
1220 }
1221 
1222 void QDBusConnectionPrivate::socketWrite(int fd)
1223 {
1224     WatcherHash::ConstIterator it = watchers.constFind(fd);
1225     while (it != watchers.constEnd() && it.key() == fd) {
1226         if (it->watch && it->write && it->write->isEnabled()) {
1227             if (!q_dbus_watch_handle(it.value().watch, DBUS_WATCH_WRITABLE))
1228                 qDebug("OUT OF MEM");
1229             break;
1230         }
1231         ++it;
1232     }
1233 }
1234 
1235 void QDBusConnectionPrivate::objectDestroyed(QObject *obj)
1236 {
1237     QDBusWriteLocker locker(ObjectDestroyedAction, this);
1238     huntAndDestroy(obj, rootNode);
1239 
1240     SignalHookHash::iterator sit = signalHooks.begin();
1241     while (sit != signalHooks.end()) {
1242         if (static_cast<QObject *>(sit.value().obj) == obj)
1243             sit = removeSignalHookNoLock(sit);
1244         else
1245             ++sit;
1246     }
1247 
1248     obj->disconnect(this);
1249 }
1250 
1251 void QDBusConnectionPrivate::relaySignal(QObject *obj, const QMetaObject *mo, int signalId,
1252                                          const QVariantList &args)
1253 {
1254     QString interface = qDBusInterfaceFromMetaObject(mo);
1255 
1256     QMetaMethod mm = mo->method(signalId);
1257     QByteArray memberName = mm.name();
1258 
1259     // check if it's scriptable
1260     bool isScriptable = mm.attributes() & QMetaMethod::Scriptable;
1261     bool isAdaptor = false;
1262     for ( ; mo; mo = mo->superClass())
1263         if (mo == &QDBusAbstractAdaptor::staticMetaObject) {
1264             isAdaptor = true;
1265             break;
1266         }
1267 
1268     checkThread();
1269     QDBusReadLocker locker(RelaySignalAction, this);
1270     QDBusMessage message = QDBusMessage::createSignal(QLatin1String("/"), interface,
1271                                                       QLatin1String(memberName));
1272     QDBusMessagePrivate::setParametersValidated(message, true);
1273     message.setArguments(args);
1274     QDBusError error;
1275     DBusMessage *msg = QDBusMessagePrivate::toDBusMessage(message, capabilities, &error);
1276     if (!msg) {
1277         qWarning("QDBusConnection: Could not emit signal %s.%s: %s", qPrintable(interface), memberName.constData(),
1278                  qPrintable(error.message()));
1279         lastError = error;
1280         return;
1281     }
1282 
1283     //qDBusDebug() << "Emitting signal" << message;
1284     //qDBusDebug() << "for paths:";
1285     q_dbus_message_set_no_reply(msg, true); // the reply would not be delivered to anything
1286     huntAndEmit(connection, msg, obj, rootNode, isScriptable, isAdaptor);
1287     q_dbus_message_unref(msg);
1288 }
1289 
1290 void QDBusConnectionPrivate::serviceOwnerChangedNoLock(const QString &name,
1291                                                        const QString &oldOwner, const QString &newOwner)
1292 {
1293     Q_UNUSED(oldOwner);
1294 //    QDBusWriteLocker locker(UpdateSignalHookOwnerAction, this);
1295     WatchedServicesHash::Iterator it = watchedServices.find(name);
1296     if (it == watchedServices.end())
1297         return;
1298     if (oldOwner != it->owner)
1299         qWarning("QDBusConnection: name '%s' had owner '%s' but we thought it was '%s'",
1300                  qPrintable(name), qPrintable(oldOwner), qPrintable(it->owner));
1301 
1302     qDBusDebug() << this << "Updating name" << name << "from" << oldOwner << "to" << newOwner;
1303     it->owner = newOwner;
1304 }
1305 
1306 int QDBusConnectionPrivate::findSlot(QObject* obj, const QByteArray &normalizedName,
1307                                      QVector<int> &params)
1308 {
1309     int midx = obj->metaObject()->indexOfMethod(normalizedName);
1310     if (midx == -1)
1311         return -1;
1312 
1313     QString errorMsg;
1314     int inputCount = qDBusParametersForMethod(obj->metaObject()->method(midx), params, errorMsg);
1315     if ( inputCount == -1 || inputCount + 1 != params.count() )
1316         return -1;              // failed to parse or invalid arguments or output arguments
1317 
1318     return midx;
1319 }
1320 
1321 bool QDBusConnectionPrivate::prepareHook(QDBusConnectionPrivate::SignalHook &hook, QString &key,
1322                                          const QString &service,
1323                                          const QString &path, const QString &interface, const QString &name,
1324                                          const ArgMatchRules &argMatch,
1325                                          QObject *receiver, const char *signal, int minMIdx,
1326                                          bool buildSignature)
1327 {
1328     QByteArray normalizedName = signal + 1;
1329     hook.midx = findSlot(receiver, signal + 1, hook.params);
1330     if (hook.midx == -1) {
1331         normalizedName = QMetaObject::normalizedSignature(signal + 1);
1332         hook.midx = findSlot(receiver, normalizedName, hook.params);
1333     }
1334     if (hook.midx < minMIdx) {
1335         return false;
1336     }
1337 
1338     hook.service = service;
1339     hook.path = path;
1340     hook.obj = receiver;
1341     hook.argumentMatch = argMatch;
1342 
1343     // build the D-Bus signal name and signature
1344     // This should not happen for QDBusConnection::connect, use buildSignature here, since
1345     // QDBusConnection::connect passes false and everything else uses true
1346     QString mname = name;
1347     if (buildSignature && mname.isNull()) {
1348         normalizedName.truncate(normalizedName.indexOf('('));
1349         mname = QString::fromUtf8(normalizedName);
1350     }
1351     key = mname;
1352     key.reserve(interface.length() + 1 + mname.length());
1353     key += QLatin1Char(':');
1354     key += interface;
1355 
1356     if (buildSignature) {
1357         hook.signature.clear();
1358         for (int i = 1; i < hook.params.count(); ++i)
1359             if (hook.params.at(i) != QDBusMetaTypeId::message())
1360                 hook.signature += QLatin1String( QDBusMetaType::typeToSignature( hook.params.at(i) ) );
1361     }
1362 
1363     hook.matchRule = buildMatchRule(service, path, interface, mname, argMatch, hook.signature);
1364     return true;                // connect to this signal
1365 }
1366 
1367 void QDBusConnectionPrivate::sendError(const QDBusMessage &msg, QDBusError::ErrorType code)
1368 {
1369     if (code == QDBusError::UnknownMethod) {
1370         QString interfaceMsg;
1371         if (msg.interface().isEmpty())
1372             interfaceMsg = QLatin1String("any interface");
1373         else
1374             interfaceMsg = QLatin1String("interface '%1'").arg(msg.interface());
1375 
1376         send(msg.createErrorReply(code,
1377                                   QLatin1String("No such method '%1' in %2 at object path '%3' "
1378                                                 "(signature '%4')")
1379                                   .arg(msg.member(), interfaceMsg, msg.path(), msg.signature())));
1380     } else if (code == QDBusError::UnknownInterface) {
1381         send(msg.createErrorReply(QDBusError::UnknownInterface,
1382                                   QLatin1String("No such interface '%1' at object path '%2'")
1383                                   .arg(msg.interface(), msg.path())));
1384     } else if (code == QDBusError::UnknownObject) {
1385         send(msg.createErrorReply(QDBusError::UnknownObject,
1386                                   QLatin1String("No such object path '%1'").arg(msg.path())));
1387     }
1388 }
1389 
1390 bool QDBusConnectionPrivate::activateInternalFilters(const ObjectTreeNode &node,
1391                                                      const QDBusMessage &msg)
1392 {
1393     // object may be null
1394     const QString interface = msg.interface();
1395 
1396     if (interface.isEmpty() || interface == QDBusUtil::dbusInterfaceIntrospectable()) {
1397         if (msg.member() == QLatin1String("Introspect") && msg.signature().isEmpty()) {
1398             //qDebug() << "QDBusConnectionPrivate::activateInternalFilters introspect" << msg.d_ptr->msg;
1399             QDBusMessage reply = msg.createReply(qDBusIntrospectObject(node, msg.path()));
1400             send(reply);
1401             return true;
1402         }
1403 
1404         if (!interface.isEmpty()) {
1405             sendError(msg, QDBusError::UnknownMethod);
1406             return true;
1407         }
1408     }
1409 
1410     if (node.obj && (interface.isEmpty() ||
1411                      interface == QDBusUtil::dbusInterfaceProperties())) {
1412         //qDebug() << "QDBusConnectionPrivate::activateInternalFilters properties" << msg.d_ptr->msg;
1413         if (msg.member() == QLatin1String("Get") && msg.signature() == QLatin1String("ss")) {
1414             QDBusMessage reply = qDBusPropertyGet(node, msg);
1415             send(reply);
1416             return true;
1417         } else if (msg.member() == QLatin1String("Set") && msg.signature() == QLatin1String("ssv")) {
1418             QDBusMessage reply = qDBusPropertySet(node, msg);
1419             send(reply);
1420             return true;
1421         } else if (msg.member() == QLatin1String("GetAll") && msg.signature() == QLatin1String("s")) {
1422             QDBusMessage reply = qDBusPropertyGetAll(node, msg);
1423             send(reply);
1424             return true;
1425         }
1426 
1427         if (!interface.isEmpty()) {
1428             sendError(msg, QDBusError::UnknownMethod);
1429             return true;
1430         }
1431     }
1432 
1433     return false;
1434 }
1435 
1436 void QDBusConnectionPrivate::activateObject(ObjectTreeNode &node, const QDBusMessage &msg,
1437                                             int pathStartPos)
1438 {
1439     // This is called by QDBusConnectionPrivate::handleObjectCall to place a call to a slot
1440     // on the object.
1441     //
1442     // The call is routed through the adaptor sub-objects if we have any
1443 
1444     // object may be null
1445 
1446     if (node.flags & QDBusConnectionPrivate::VirtualObject) {
1447         if (node.treeNode->handleMessage(msg, q(this))) {
1448             return;
1449         } else {
1450             if (activateInternalFilters(node, msg))
1451                 return;
1452         }
1453     }
1454 
1455     if (pathStartPos != msg.path().length()) {
1456         node.flags &= ~QDBusConnection::ExportAllSignals;
1457         node.obj = findChildObject(&node, msg.path(), pathStartPos);
1458         if (!node.obj) {
1459             sendError(msg, QDBusError::UnknownObject);
1460             return;
1461         }
1462     }
1463 
1464     QDBusAdaptorConnector *connector;
1465     if (node.flags & QDBusConnection::ExportAdaptors &&
1466         (connector = qDBusFindAdaptorConnector(node.obj))) {
1467         int newflags = node.flags | QDBusConnection::ExportAllSlots;
1468 
1469         if (msg.interface().isEmpty()) {
1470             // place the call in all interfaces
1471             // let the first one that handles it to work
1472             QDBusAdaptorConnector::AdaptorMap::ConstIterator it =
1473                 connector->adaptors.constBegin();
1474             QDBusAdaptorConnector::AdaptorMap::ConstIterator end =
1475                 connector->adaptors.constEnd();
1476 
1477             for ( ; it != end; ++it)
1478                 if (activateCall(it->adaptor, newflags, msg))
1479                     return;
1480         } else {
1481             // check if we have an interface matching the name that was asked:
1482             QDBusAdaptorConnector::AdaptorMap::ConstIterator it;
1483             it = std::lower_bound(connector->adaptors.constBegin(), connector->adaptors.constEnd(),
1484                                   msg.interface());
1485             if (it != connector->adaptors.constEnd() && msg.interface() == QLatin1String(it->interface)) {
1486                 if (!activateCall(it->adaptor, newflags, msg))
1487                     sendError(msg, QDBusError::UnknownMethod);
1488                 return;
1489             }
1490         }
1491     }
1492 
1493     // no adaptors matched or were exported
1494     // try our standard filters
1495     if (activateInternalFilters(node, msg))
1496         return;                 // internal filters have already run or an error has been sent
1497 
1498     // try the object itself:
1499     if (node.flags & (QDBusConnection::ExportScriptableSlots|QDBusConnection::ExportNonScriptableSlots) ||
1500         node.flags & (QDBusConnection::ExportScriptableInvokables|QDBusConnection::ExportNonScriptableInvokables)) {
1501         bool interfaceFound = true;
1502         if (!msg.interface().isEmpty()) {
1503             if (!node.interfaceName.isEmpty())
1504                 interfaceFound = msg.interface() == node.interfaceName;
1505             else
1506                 interfaceFound = qDBusInterfaceInObject(node.obj, msg.interface());
1507         }
1508 
1509         if (interfaceFound) {
1510             if (!activateCall(node.obj, node.flags, msg))
1511                 sendError(msg, QDBusError::UnknownMethod);
1512             return;
1513         }
1514     }
1515 
1516     // nothing matched, send an error code
1517     if (msg.interface().isEmpty())
1518         sendError(msg, QDBusError::UnknownMethod);
1519     else
1520         sendError(msg, QDBusError::UnknownInterface);
1521 }
1522 
1523 void QDBusConnectionPrivate::handleObjectCall(const QDBusMessage &msg)
1524 {
1525     // if the msg is external, we were called from inside doDispatch
1526     // that means the dispatchLock mutex is locked
1527     // must not call out to user code in that case
1528     //
1529     // however, if the message is internal, handleMessage was called directly
1530     // (user's thread) and no lock is in place. We can therefore call out to
1531     // user code, if necessary.
1532     ObjectTreeNode result;
1533     int usedLength;
1534     QThread *objThread = 0;
1535     QSemaphore sem;
1536     bool semWait;
1537 
1538     {
1539         QDBusReadLocker locker(HandleObjectCallAction, this);
1540         if (!findObject(&rootNode, msg.path(), usedLength, result)) {
1541             // qDebug("Call failed: no object found at %s", qPrintable(msg.path()));
1542             sendError(msg, QDBusError::UnknownObject);
1543             return;
1544         }
1545 
1546         if (!result.obj) {
1547             // no object -> no threading issues
1548             // it's either going to be an error, or an internal filter
1549             activateObject(result, msg, usedLength);
1550             return;
1551         }
1552 
1553         objThread = result.obj->thread();
1554         if (!objThread) {
1555             send(msg.createErrorReply(QDBusError::InternalError,
1556                                       QLatin1String("Object '%1' (at path '%2')"
1557                                                     " has no thread. Cannot deliver message.")
1558                                       .arg(result.obj->objectName(), msg.path())));
1559             return;
1560         }
1561 
1562         if (!QDBusMessagePrivate::isLocal(msg)) {
1563             // external incoming message
1564             // post it and forget
1565             postEventToThread(HandleObjectCallPostEventAction, result.obj,
1566                               new QDBusActivateObjectEvent(QDBusConnection(this), this, result,
1567                                                            usedLength, msg));
1568             return;
1569         } else if (objThread != QThread::currentThread()) {
1570             // looped-back message, targeting another thread:
1571             // synchronize with it
1572             postEventToThread(HandleObjectCallPostEventAction, result.obj,
1573                               new QDBusActivateObjectEvent(QDBusConnection(this), this, result,
1574                                                            usedLength, msg, &sem));
1575             semWait = true;
1576         } else {
1577             // looped-back message, targeting current thread
1578             semWait = false;
1579         }
1580     } // release the lock
1581 
1582     if (semWait)
1583         SEM_ACQUIRE(HandleObjectCallSemaphoreAction, sem);
1584     else
1585         activateObject(result, msg, usedLength);
1586 }
1587 
1588 QDBusActivateObjectEvent::~QDBusActivateObjectEvent()
1589 {
1590     if (!handled) {
1591         // we're being destroyed without delivering
1592         // it means the object was deleted between posting and delivering
1593         QDBusConnectionPrivate *that = QDBusConnectionPrivate::d(connection);
1594         that->sendError(message, QDBusError::UnknownObject);
1595     }
1596 
1597     // semaphore releasing happens in ~QMetaCallEvent
1598 }
1599 
1600 void QDBusActivateObjectEvent::placeMetaCall(QObject *)
1601 {
1602     QDBusConnectionPrivate *that = QDBusConnectionPrivate::d(connection);
1603 
1604     QDBusLockerBase::reportThreadAction(HandleObjectCallPostEventAction,
1605                                         QDBusLockerBase::BeforeDeliver, that);
1606     that->activateObject(node, message, pathStartPos);
1607     QDBusLockerBase::reportThreadAction(HandleObjectCallPostEventAction,
1608                                         QDBusLockerBase::AfterDeliver, that);
1609 
1610     handled = true;
1611 }
1612 
1613 void QDBusConnectionPrivate::handleSignal(const QString &key, const QDBusMessage& msg)
1614 {
1615     SignalHookHash::const_iterator it = signalHooks.constFind(key);
1616     SignalHookHash::const_iterator end = signalHooks.constEnd();
1617     //qDebug("looking for: %s", path.toLocal8Bit().constData());
1618     //qDBusDebug() << signalHooks.keys();
1619     for ( ; it != end && it.key() == key; ++it) {
1620         const SignalHook &hook = it.value();
1621         if (!hook.service.isEmpty()) {
1622             QString owner = watchedServices.value(hook.service, WatchedServiceData(hook.service)).owner;
1623             if (owner != msg.service())
1624                 continue;
1625         }
1626         if (!hook.path.isEmpty() && hook.path != msg.path())
1627             continue;
1628         if (!hook.signature.isEmpty() && hook.signature != msg.signature())
1629             continue;
1630         if (hook.signature.isEmpty() && !hook.signature.isNull() && !msg.signature().isEmpty())
1631             continue;
1632         if (!hook.argumentMatch.args.isEmpty()) {
1633             const QVariantList arguments = msg.arguments();
1634             if (hook.argumentMatch.args.size() > arguments.size())
1635                 continue;
1636 
1637             bool matched = true;
1638             for (int i = 0; i < hook.argumentMatch.args.size(); ++i) {
1639                 const QString &param = hook.argumentMatch.args.at(i);
1640                 if (param.isNull())
1641                     continue;   // don't try to match against this
1642                 if (param == arguments.at(i).toString())
1643                     continue;   // matched
1644                 matched = false;
1645                 break;
1646             }
1647             if (!matched)
1648                 continue;
1649         }
1650         if (!hook.argumentMatch.arg0namespace.isEmpty()) {
1651             const QVariantList arguments = msg.arguments();
1652             if (arguments.size() < 1)
1653                 continue;
1654             const QString param = arguments.at(0).toString();
1655             if (param != hook.argumentMatch.arg0namespace
1656                 && !param.startsWith(hook.argumentMatch.arg0namespace + QLatin1Char('.')))
1657                 continue;
1658         }
1659         activateSignal(hook, msg);
1660     }
1661 }
1662 
1663 void QDBusConnectionPrivate::handleSignal(const QDBusMessage& msg)
1664 {
1665     // We call handlesignal(QString, QDBusMessage) three times:
1666     //  one with member:interface
1667     //  one with member:
1668     //  one with :interface
1669     // This allows us to match signals with wildcards on member or interface
1670     // (but not both)
1671 
1672     QString key = msg.member();
1673     key.reserve(key.length() + 1 + msg.interface().length());
1674     key += QLatin1Char(':');
1675     key += msg.interface();
1676 
1677     QDBusReadLocker locker(HandleSignalAction, this);
1678     handleSignal(key, msg);                  // one try
1679 
1680     key.truncate(msg.member().length() + 1); // keep the ':'
1681     handleSignal(key, msg);                  // second try
1682 
1683     key = QLatin1Char(':');
1684     key += msg.interface();
1685     handleSignal(key, msg);                  // third try
1686 }
1687 
1688 void QDBusConnectionPrivate::watchForDBusDisconnection()
1689 {
1690     SignalHook hook;
1691     // Initialize the hook for Disconnected signal
1692     hook.service.clear(); // org.freedesktop.DBus.Local.Disconnected uses empty service name
1693     hook.path = QDBusUtil::dbusPathLocal();
1694     hook.obj = this;
1695     hook.params << QMetaType::Void;
1696     hook.midx = staticMetaObject.indexOfSlot("handleDBusDisconnection()");
1697     Q_ASSERT(hook.midx != -1);
1698     signalHooks.insert(QLatin1String("Disconnected:" DBUS_INTERFACE_LOCAL), hook);
1699 }
1700 
1701 void QDBusConnectionPrivate::setServer(QDBusServer *object, DBusServer *s, const QDBusErrorInternal &error)
1702 {
1703     mode = ServerMode;
1704     serverObject = object;
1705     object->d = this;
1706     if (!s) {
1707         handleError(error);
1708         return;
1709     }
1710 
1711     server = s;
1712 
1713     dbus_bool_t data_allocated = q_dbus_server_allocate_data_slot(&server_slot);
1714     if (data_allocated && server_slot < 0)
1715         return;
1716 
1717     dbus_bool_t watch_functions_set = q_dbus_server_set_watch_functions(server,
1718                                                                       qDBusAddWatch,
1719                                                                       qDBusRemoveWatch,
1720                                                                       qDBusToggleWatch,
1721                                                                       this, 0);
1722     //qDebug() << "watch_functions_set" << watch_functions_set;
1723     Q_UNUSED(watch_functions_set);
1724 
1725     dbus_bool_t time_functions_set = q_dbus_server_set_timeout_functions(server,
1726                                                                        qDBusAddTimeout,
1727                                                                        qDBusRemoveTimeout,
1728                                                                        qDBusToggleTimeout,
1729                                                                        this, 0);
1730     //qDebug() << "time_functions_set" << time_functions_set;
1731     Q_UNUSED(time_functions_set);
1732 
1733     q_dbus_server_set_new_connection_function(server, qDBusNewConnection, this, 0);
1734 
1735     dbus_bool_t data_set = q_dbus_server_set_data(server, server_slot, this, 0);
1736     //qDebug() << "data_set" << data_set;
1737     Q_UNUSED(data_set);
1738 }
1739 
1740 static QDBusConnection::ConnectionCapabilities connectionCapabilies(DBusConnection *connection)
1741 {
1742     QDBusConnection::ConnectionCapabilities result = 0;
1743     typedef dbus_bool_t (*can_send_type_t)(DBusConnection *, int);
1744     static can_send_type_t can_send_type = 0;
1745 
1746 #if defined(QT_LINKED_LIBDBUS)
1747 # if DBUS_VERSION-0 >= 0x010400
1748     can_send_type = dbus_connection_can_send_type;
1749 # endif
1750 #elif QT_CONFIG(library)
1751     // run-time check if the next functions are available
1752     can_send_type = (can_send_type_t)qdbus_resolve_conditionally("dbus_connection_can_send_type");
1753 #endif
1754 
1755 #ifndef DBUS_TYPE_UNIX_FD
1756 # define DBUS_TYPE_UNIX_FD int('h')
1757 #endif
1758     if (can_send_type && can_send_type(connection, DBUS_TYPE_UNIX_FD))
1759         result |= QDBusConnection::UnixFileDescriptorPassing;
1760 
1761     return result;
1762 }
1763 
1764 void QDBusConnectionPrivate::setPeer(DBusConnection *c, const QDBusErrorInternal &error)
1765 {
1766     mode = PeerMode;
1767     if (!c) {
1768         handleError(error);
1769         return;
1770     }
1771 
1772     connection = c;
1773 
1774     q_dbus_connection_set_exit_on_disconnect(connection, false);
1775     q_dbus_connection_set_watch_functions(connection,
1776                                         qDBusAddWatch,
1777                                         qDBusRemoveWatch,
1778                                         qDBusToggleWatch,
1779                                         this, 0);
1780     q_dbus_connection_set_timeout_functions(connection,
1781                                           qDBusAddTimeout,
1782                                           qDBusRemoveTimeout,
1783                                           qDBusToggleTimeout,
1784                                           this, 0);
1785     q_dbus_connection_set_dispatch_status_function(connection, qDBusUpdateDispatchStatus, this, 0);
1786     q_dbus_connection_add_filter(connection,
1787                                qDBusSignalFilter,
1788                                this, 0);
1789 
1790     watchForDBusDisconnection();
1791 
1792     QMetaObject::invokeMethod(this, "doDispatch", Qt::QueuedConnection);
1793 
1794     while (!q_dbus_connection_get_is_authenticated(connection) && q_dbus_connection_read_write(connection, -1)) {};
1795     capabilities = connectionCapabilies(connection);
1796 }
1797 
1798 void QDBusConnectionPrivate::setConnection(DBusConnection *dbc, const QDBusErrorInternal &error)
1799 {
1800     mode = ClientMode;
1801     if (!dbc) {
1802         handleError(error);
1803         return;
1804     }
1805 
1806     connection = dbc;
1807 
1808     const char *service = q_dbus_bus_get_unique_name(connection);
1809     Q_ASSERT(service);
1810     baseService = QString::fromUtf8(service);
1811     capabilities = connectionCapabilies(connection);
1812 
1813     q_dbus_connection_set_exit_on_disconnect(connection, false);
1814     q_dbus_connection_set_watch_functions(connection, qDBusAddWatch, qDBusRemoveWatch,
1815                                           qDBusToggleWatch, this, 0);
1816     q_dbus_connection_set_timeout_functions(connection, qDBusAddTimeout, qDBusRemoveTimeout,
1817                                             qDBusToggleTimeout, this, 0);
1818     q_dbus_connection_set_dispatch_status_function(connection, qDBusUpdateDispatchStatus, this, 0);
1819     q_dbus_connection_add_filter(connection, qDBusSignalFilter, this, 0);
1820 
1821     // Initialize the hooks for the NameAcquired and NameLost signals
1822     // we don't use connectSignal here because we don't need the rules to be sent to the bus
1823     // the bus will always send us these two signals
1824     SignalHook hook;
1825     hook.service = QDBusUtil::dbusService();
1826     hook.path.clear(); // no matching
1827     hook.obj = this;
1828     hook.params << QMetaType::Void << QVariant::String; // both functions take a QString as parameter and return void
1829 
1830     hook.midx = staticMetaObject.indexOfSlot("registerServiceNoLock(QString)");
1831     Q_ASSERT(hook.midx != -1);
1832     signalHooks.insert(QLatin1String("NameAcquired:" DBUS_INTERFACE_DBUS), hook);
1833 
1834     hook.midx = staticMetaObject.indexOfSlot("unregisterServiceNoLock(QString)");
1835     Q_ASSERT(hook.midx != -1);
1836     signalHooks.insert(QLatin1String("NameLost:" DBUS_INTERFACE_DBUS), hook);
1837 
1838     // And initialize the hook for the NameOwnerChanged signal;
1839     // we don't use connectSignal here because the rules are added by connectSignal on a per-need basis
1840     hook.params.clear();
1841     hook.params.reserve(4);
1842     hook.params << QMetaType::Void << QVariant::String << QVariant::String << QVariant::String;
1843     hook.midx = staticMetaObject.indexOfSlot("serviceOwnerChangedNoLock(QString,QString,QString)");
1844     Q_ASSERT(hook.midx != -1);
1845     signalHooks.insert(QLatin1String("NameOwnerChanged:" DBUS_INTERFACE_DBUS), hook);
1846 
1847     watchForDBusDisconnection();
1848 
1849     qDBusDebug() << this << ": connected successfully";
1850 
1851     // schedule a dispatch:
1852     QMetaObject::invokeMethod(this, "doDispatch", Qt::QueuedConnection);
1853 }
1854 
1855 extern "C"{
1856 static void qDBusResultReceived(DBusPendingCall *pending, void *user_data)
1857 {
1858     QDBusPendingCallPrivate *call = reinterpret_cast<QDBusPendingCallPrivate *>(user_data);
1859     Q_ASSERT(call->pending == pending);
1860     Q_UNUSED(pending);
1861     QDBusConnectionPrivate::processFinishedCall(call);
1862 }
1863 }
1864 
1865 void QDBusConnectionPrivate::processFinishedCall(QDBusPendingCallPrivate *call)
1866 {
1867     QDBusConnectionPrivate *connection = const_cast<QDBusConnectionPrivate *>(call->connection);
1868 
1869     auto locker = qt_unique_lock(call->mutex);
1870 
1871     connection->pendingCalls.removeOne(call);
1872 
1873     QDBusMessage &msg = call->replyMessage;
1874     if (call->pending) {
1875         // when processFinishedCall is called and pending call is not completed,
1876         // it means we received disconnected signal from libdbus
1877         if (q_dbus_pending_call_get_completed(call->pending)) {
1878             // decode the message
1879             DBusMessage *reply = q_dbus_pending_call_steal_reply(call->pending);
1880             msg = QDBusMessagePrivate::fromDBusMessage(reply, connection->capabilities);
1881             q_dbus_message_unref(reply);
1882         } else {
1883             msg = QDBusMessage::createError(QDBusError::Disconnected, QDBusUtil::disconnectedErrorMessage());
1884         }
1885     }
1886     qDBusDebug() << connection << "got message reply:" << msg;
1887 
1888     // Check if the reply has the expected signature
1889     call->checkReceivedSignature();
1890 
1891     if (!call->receiver.isNull() && call->methodIdx != -1 && msg.type() == QDBusMessage::ReplyMessage) {
1892         // Deliver the return values of a remote function call.
1893         //
1894         // There is only one connection and it is specified by idx
1895         // The slot must have the same parameter types that the message does
1896         // The slot may have less parameters than the message
1897         // The slot may optionally have one final parameter that is QDBusMessage
1898         // The slot receives read-only copies of the message (i.e., pass by value or by const-ref)
1899 
1900         QDBusCallDeliveryEvent *e = prepareReply(connection, call->receiver, call->methodIdx,
1901                                                  call->metaTypes, msg);
1902         if (e)
1903             connection->postEventToThread(MessageResultReceivedAction, call->receiver, e);
1904         else
1905             qDBusDebug("Deliver failed!");
1906     }
1907 
1908     if (call->pending) {
1909         q_dbus_pending_call_unref(call->pending);
1910         call->pending = 0;
1911     }
1912 
1913     // Are there any watchers?
1914     if (call->watcherHelper)
1915         call->watcherHelper->emitSignals(msg, call->sentMessage);
1916 
1917     call->waitForFinishedCondition.wakeAll();
1918     locker.unlock();
1919 
1920     if (msg.type() == QDBusMessage::ErrorMessage)
1921         emit connection->callWithCallbackFailed(QDBusError(msg), call->sentMessage);
1922 
1923     if (!call->ref.deref())
1924         delete call;
1925 }
1926 
1927 bool QDBusConnectionPrivate::send(const QDBusMessage& message)
1928 {
1929     if (QDBusMessagePrivate::isLocal(message))
1930         return true;            // don't send; the reply will be retrieved by the caller
1931                                 // through the d_ptr->localReply link
1932 
1933     QDBusError error;
1934     DBusMessage *msg = QDBusMessagePrivate::toDBusMessage(message, capabilities, &error);
1935     if (!msg) {
1936         if (message.type() == QDBusMessage::MethodCallMessage)
1937             qWarning("QDBusConnection: error: could not send message to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s",
1938                      qPrintable(message.service()), qPrintable(message.path()),
1939                      qPrintable(message.interface()), qPrintable(message.member()),
1940                      qPrintable(error.message()));
1941         else if (message.type() == QDBusMessage::SignalMessage)
1942             qWarning("QDBusConnection: error: could not send signal to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s",
1943                      qPrintable(message.service()),
1944                      qPrintable(message.path()), qPrintable(message.interface()),
1945                      qPrintable(message.member()),
1946                      qPrintable(error.message()));
1947         else
1948             qWarning("QDBusConnection: error: could not send %s message to service \"%s\": %s",
1949                      message.type() == QDBusMessage::ReplyMessage ? "reply" :
1950                      message.type() == QDBusMessage::ErrorMessage ? "error" :
1951                      "invalid", qPrintable(message.service()),
1952                      qPrintable(error.message()));
1953         lastError = error;
1954         return false;
1955     }
1956 
1957     q_dbus_message_set_no_reply(msg, true); // the reply would not be delivered to anything
1958     qDBusDebug() << this << "sending message (no reply):" << message;
1959     emit messageNeedsSending(nullptr, msg);
1960     return true;
1961 }
1962 
1963 // small helper to note long running blocking dbus calls.
1964 // these are generally a sign of fragile software (too long a call can either
1965 // lead to bad user experience, if it's running on the GUI thread for instance)
1966 // or break completely under load (hitting the call timeout).
1967 //
1968 // as a result, this is something we want to watch for.
1969 class QDBusBlockingCallWatcher
1970 {
1971 public:
1972     QDBusBlockingCallWatcher(const QDBusMessage &message)
1973         : m_message(message), m_maxCallTimeoutMs(0)
1974     {
1975 #if defined(QT_NO_DEBUG)
1976         // when in a release build, we default these to off.
1977         // this means that we only affect code that explicitly enables the warning.
1978         static int mainThreadWarningAmount = -1;
1979         static int otherThreadWarningAmount = -1;
1980 #else
1981         static int mainThreadWarningAmount = 200;
1982         static int otherThreadWarningAmount = 500;
1983 #endif
1984         static bool initializedAmounts = false;
1985         static QBasicMutex initializeMutex;
1986         auto locker = qt_unique_lock(initializeMutex);
1987 
1988         if (!initializedAmounts) {
1989             int tmp = 0;
1990             QByteArray env;
1991             bool ok = true;
1992 
1993             env = qgetenv("Q_DBUS_BLOCKING_CALL_MAIN_THREAD_WARNING_MS");
1994             if (!env.isEmpty()) {
1995                 tmp = env.toInt(&ok);
1996                 if (ok)
1997                     mainThreadWarningAmount = tmp;
1998                 else
1999                     qWarning("QDBusBlockingCallWatcher: Q_DBUS_BLOCKING_CALL_MAIN_THREAD_WARNING_MS must be an integer; value ignored");
2000             }
2001 
2002             env = qgetenv("Q_DBUS_BLOCKING_CALL_OTHER_THREAD_WARNING_MS");
2003             if (!env.isEmpty()) {
2004                 tmp = env.toInt(&ok);
2005                 if (ok)
2006                     otherThreadWarningAmount = tmp;
2007                 else
2008                     qWarning("QDBusBlockingCallWatcher: Q_DBUS_BLOCKING_CALL_OTHER_THREAD_WARNING_MS must be an integer; value ignored");
2009             }
2010 
2011             initializedAmounts = true;
2012         }
2013 
2014         locker.unlock();
2015 
2016         // if this call is running on the main thread, we have a much lower
2017         // tolerance for delay because any long-term delay will wreck user
2018         // interactivity.
2019         if (qApp && qApp->thread() == QThread::currentThread())
2020             m_maxCallTimeoutMs = mainThreadWarningAmount;
2021         else
2022             m_maxCallTimeoutMs = otherThreadWarningAmount;
2023 
2024         m_callTimer.start();
2025     }
2026 
2027     ~QDBusBlockingCallWatcher()
2028     {
2029         if (m_maxCallTimeoutMs < 0)
2030             return; // disabled
2031 
2032         if (m_callTimer.elapsed() >= m_maxCallTimeoutMs) {
2033             qWarning("QDBusConnection: warning: blocking call took a long time (%d ms, max for this thread is %d ms) to service \"%s\" path \"%s\" interface \"%s\" member \"%s\"",
2034                      int(m_callTimer.elapsed()), m_maxCallTimeoutMs,
2035                      qPrintable(m_message.service()), qPrintable(m_message.path()),
2036                      qPrintable(m_message.interface()), qPrintable(m_message.member()));
2037         }
2038     }
2039 
2040 private:
2041     QDBusMessage m_message;
2042     int m_maxCallTimeoutMs;
2043     QElapsedTimer m_callTimer;
2044 };
2045 
2046 
2047 QDBusMessage QDBusConnectionPrivate::sendWithReply(const QDBusMessage &message,
2048                                                    int sendMode, int timeout)
2049 {
2050     QDBusBlockingCallWatcher watcher(message);
2051 
2052     QDBusPendingCallPrivate *pcall = sendWithReplyAsync(message, 0, 0, 0, timeout);
2053     Q_ASSERT(pcall);
2054 
2055     if (pcall->replyMessage.type() == QDBusMessage::InvalidMessage) {
2056         // need to wait for the reply
2057         if (sendMode == QDBus::BlockWithGui) {
2058             pcall->watcherHelper = new QDBusPendingCallWatcherHelper;
2059             QEventLoop loop;
2060             loop.connect(pcall->watcherHelper, &QDBusPendingCallWatcherHelper::reply, &loop, &QEventLoop::quit);
2061             loop.connect(pcall->watcherHelper, &QDBusPendingCallWatcherHelper::error, &loop, &QEventLoop::quit);
2062 
2063             // enter the event loop and wait for a reply
2064             loop.exec(QEventLoop::ExcludeUserInputEvents | QEventLoop::WaitForMoreEvents);
2065         } else {
2066             pcall->waitForFinished();
2067         }
2068     }
2069 
2070     QDBusMessage reply = pcall->replyMessage;
2071     lastError = QDBusError(reply);      // set or clear error
2072 
2073     if (!pcall->ref.deref())
2074         delete pcall;
2075     return reply;
2076 }
2077 
2078 QDBusMessage QDBusConnectionPrivate::sendWithReplyLocal(const QDBusMessage &message)
2079 {
2080     qDBusDebug() << this << "sending message via local-loop:" << message;
2081 
2082     QDBusMessage localCallMsg = QDBusMessagePrivate::makeLocal(*this, message);
2083     bool handled = handleMessage(localCallMsg);
2084 
2085     if (!handled) {
2086         QString interface = message.interface();
2087         if (interface.isEmpty())
2088             interface = QLatin1String("<no-interface>");
2089         return QDBusMessage::createError(QDBusError::InternalError,
2090                                          QLatin1String("Internal error trying to call %1.%2 at %3 (signature '%4'")
2091                                          .arg(interface, message.member(),
2092                                               message.path(), message.signature()));
2093     }
2094 
2095     // if the message was handled, there might be a reply
2096     QDBusMessage localReplyMsg = QDBusMessagePrivate::makeLocalReply(*this, localCallMsg);
2097     if (localReplyMsg.type() == QDBusMessage::InvalidMessage) {
2098         qWarning("QDBusConnection: cannot call local method '%s' at object %s (with signature '%s') "
2099                  "on blocking mode", qPrintable(message.member()), qPrintable(message.path()),
2100                  qPrintable(message.signature()));
2101         return QDBusMessage::createError(
2102             QDBusError(QDBusError::InternalError,
2103                        QLatin1String("local-loop message cannot have delayed replies")));
2104     }
2105 
2106     // there is a reply
2107     qDBusDebug() << this << "got message via local-loop:" << localReplyMsg;
2108     return localReplyMsg;
2109 }
2110 
2111 QDBusPendingCallPrivate *QDBusConnectionPrivate::sendWithReplyAsync(const QDBusMessage &message,
2112                                                                     QObject *receiver, const char *returnMethod,
2113                                                                     const char *errorMethod, int timeout)
2114 {
2115     QDBusPendingCallPrivate *pcall = new QDBusPendingCallPrivate(message, this);
2116     bool isLoopback;
2117     if ((isLoopback = isServiceRegisteredByThread(message.service()))) {
2118         // special case for local calls
2119         pcall->replyMessage = sendWithReplyLocal(message);
2120     }
2121 
2122     if (receiver && returnMethod)
2123         pcall->setReplyCallback(receiver, returnMethod);
2124 
2125     if (errorMethod) {
2126         pcall->watcherHelper = new QDBusPendingCallWatcherHelper;
2127         connect(pcall->watcherHelper, SIGNAL(error(QDBusError,QDBusMessage)), receiver, errorMethod,
2128                 Qt::QueuedConnection);
2129         pcall->watcherHelper->moveToThread(thread());
2130     }
2131 
2132     if ((receiver && returnMethod) || errorMethod) {
2133        // no one waiting, will delete pcall in processFinishedCall()
2134        pcall->ref.storeRelaxed(1);
2135     } else {
2136        // set double ref to prevent race between processFinishedCall() and ref counting
2137        // by QDBusPendingCall::QExplicitlySharedDataPointer<QDBusPendingCallPrivate>
2138        pcall->ref.storeRelaxed(2);
2139     }
2140 
2141     if (isLoopback) {
2142         // a loopback call
2143         processFinishedCall(pcall);
2144         return pcall;
2145     }
2146 
2147     QDBusError error;
2148     DBusMessage *msg = QDBusMessagePrivate::toDBusMessage(message, capabilities, &error);
2149     if (!msg) {
2150         qWarning("QDBusConnection: error: could not send message to service \"%s\" path \"%s\" interface \"%s\" member \"%s\": %s",
2151                  qPrintable(message.service()), qPrintable(message.path()),
2152                  qPrintable(message.interface()), qPrintable(message.member()),
2153                  qPrintable(error.message()));
2154         pcall->replyMessage = QDBusMessage::createError(error);
2155         lastError = error;
2156         processFinishedCall(pcall);
2157     } else {
2158         qDBusDebug() << this << "sending message:" << message;
2159         emit messageNeedsSending(pcall, msg, timeout);
2160     }
2161     return pcall;
2162 }
2163 
2164 void QDBusConnectionPrivate::sendInternal(QDBusPendingCallPrivate *pcall, void *message, int timeout)
2165 {
2166     QDBusError error;
2167     DBusPendingCall *pending = 0;
2168     DBusMessage *msg = static_cast<DBusMessage *>(message);
2169     bool isNoReply = !pcall;
2170     Q_ASSERT(isNoReply == !!q_dbus_message_get_no_reply(msg));
2171 
2172     checkThread();
2173 
2174     if (isNoReply && q_dbus_connection_send(connection, msg, nullptr)) {
2175         // success
2176     } else if (!isNoReply && q_dbus_connection_send_with_reply(connection, msg, &pending, timeout)) {
2177         if (pending) {
2178             q_dbus_message_unref(msg);
2179 
2180             pcall->pending = pending;
2181             q_dbus_pending_call_set_notify(pending, qDBusResultReceived, pcall, 0);
2182 
2183             // DBus won't notify us when a peer disconnects or server terminates so we need to track these ourselves
2184             if (mode == QDBusConnectionPrivate::PeerMode || mode == QDBusConnectionPrivate::ClientMode)
2185                 pendingCalls.append(pcall);
2186 
2187             return;
2188         } else {
2189             // we're probably disconnected at this point
2190             lastError = error = QDBusError(QDBusError::Disconnected, QDBusUtil::disconnectedErrorMessage());
2191         }
2192     } else {
2193         lastError = error = QDBusError(QDBusError::NoMemory, QStringLiteral("Out of memory"));
2194     }
2195 
2196     q_dbus_message_unref(msg);
2197     if (pcall) {
2198         pcall->replyMessage = QDBusMessage::createError(error);
2199         processFinishedCall(pcall);
2200     }
2201 }
2202 
2203 
2204 bool QDBusConnectionPrivate::connectSignal(const QString &service,
2205                                            const QString &path, const QString &interface, const QString &name,
2206                                            const QStringList &argumentMatch, const QString &signature,
2207                                            QObject *receiver, const char *slot)
2208 {
2209     ArgMatchRules rules;
2210     rules.args = argumentMatch;
2211     return connectSignal(service, path, interface, name, rules, signature, receiver, slot);
2212 }
2213 
2214 bool QDBusConnectionPrivate::connectSignal(const QString &service,
2215                                            const QString &path, const QString &interface, const QString &name,
2216                                            const ArgMatchRules &argumentMatch, const QString &signature,
2217                                            QObject *receiver, const char *slot)
2218 {
2219     // check the slot
2220     QDBusConnectionPrivate::SignalHook hook;
2221     QString key;
2222 
2223     hook.signature = signature;
2224     if (!prepareHook(hook, key, service, path, interface, name, argumentMatch, receiver, slot, 0, false))
2225         return false;           // don't connect
2226 
2227     Q_ASSERT(thread() != QThread::currentThread());
2228     return emit signalNeedsConnecting(key, hook);
2229 }
2230 
2231 bool QDBusConnectionPrivate::addSignalHook(const QString &key, const SignalHook &hook)
2232 {
2233     QDBusWriteLocker locker(ConnectAction, this);
2234 
2235     // avoid duplicating:
2236     QDBusConnectionPrivate::SignalHookHash::ConstIterator it = signalHooks.constFind(key);
2237     QDBusConnectionPrivate::SignalHookHash::ConstIterator end = signalHooks.constEnd();
2238     for ( ; it != end && it.key() == key; ++it) {
2239         const QDBusConnectionPrivate::SignalHook &entry = it.value();
2240         if (entry.service == hook.service &&
2241             entry.path == hook.path &&
2242             entry.signature == hook.signature &&
2243             entry.obj == hook.obj &&
2244             entry.midx == hook.midx &&
2245             entry.argumentMatch == hook.argumentMatch) {
2246             // no need to compare the parameters if it's the same slot
2247             return false;     // already there
2248         }
2249     }
2250 
2251     signalHooks.insertMulti(key, hook);
2252     connect(hook.obj, &QObject::destroyed, this, &QDBusConnectionPrivate::objectDestroyed,
2253             Qt::ConnectionType(Qt::BlockingQueuedConnection | Qt::UniqueConnection));
2254 
2255     MatchRefCountHash::iterator mit = matchRefCounts.find(hook.matchRule);
2256 
2257     if (mit != matchRefCounts.end()) { // Match already present
2258         mit.value() = mit.value() + 1;
2259         return true;
2260     }
2261 
2262     matchRefCounts.insert(hook.matchRule, 1);
2263 
2264     if (connection) {
2265         if (mode != QDBusConnectionPrivate::PeerMode) {
2266             qDBusDebug() << this << "Adding rule:" << hook.matchRule;
2267             q_dbus_bus_add_match(connection, hook.matchRule, NULL);
2268 
2269             // Successfully connected the signal
2270             // Do we need to watch for this name?
2271             if (shouldWatchService(hook.service)) {
2272                 WatchedServicesHash::mapped_type &data = watchedServices[hook.service];
2273                 if (++data.refcount == 1) {
2274                     // we need to watch for this service changing
2275                     ArgMatchRules rules;
2276                     rules.args << hook.service;
2277                     q_dbus_bus_add_match(connection,
2278                                          buildMatchRule(QDBusUtil::dbusService(), QString(), QDBusUtil::dbusInterface(),
2279                                                         QDBusUtil::nameOwnerChanged(), rules, QString()),
2280                                          NULL);
2281                     data.owner = getNameOwnerNoCache(hook.service);
2282                     qDBusDebug() << this << "Watching service" << hook.service << "for owner changes (current owner:"
2283                                  << data.owner << ")";
2284                 }
2285             }
2286         }
2287     }
2288     return true;
2289 }
2290 
2291 bool QDBusConnectionPrivate::disconnectSignal(const QString &service,
2292                                            const QString &path, const QString &interface, const QString &name,
2293                                            const QStringList &argumentMatch, const QString &signature,
2294                                            QObject *receiver, const char *slot)
2295 {
2296     ArgMatchRules rules;
2297     rules.args = argumentMatch;
2298     return disconnectSignal(service, path, interface, name, rules, signature, receiver, slot);
2299 }
2300 
2301 bool QDBusConnectionPrivate::disconnectSignal(const QString &service,
2302                                               const QString &path, const QString &interface, const QString &name,
2303                                               const ArgMatchRules &argumentMatch, const QString &signature,
2304                                               QObject *receiver, const char *slot)
2305 {
2306     // check the slot
2307     QDBusConnectionPrivate::SignalHook hook;
2308     QString key;
2309     QString name2 = name;
2310     if (name2.isNull())
2311         name2.detach();
2312 
2313     hook.signature = signature;
2314     if (!prepareHook(hook, key, service, path, interface, name, argumentMatch, receiver, slot, 0, false))
2315         return false;           // don't disconnect
2316 
2317     Q_ASSERT(thread() != QThread::currentThread());
2318     return emit signalNeedsDisconnecting(key, hook);
2319 }
2320 
2321 bool QDBusConnectionPrivate::removeSignalHook(const QString &key, const SignalHook &hook)
2322 {
2323     // remove it from our list:
2324     QDBusWriteLocker locker(ConnectAction, this);
2325     QDBusConnectionPrivate::SignalHookHash::Iterator it = signalHooks.find(key);
2326     QDBusConnectionPrivate::SignalHookHash::Iterator end = signalHooks.end();
2327     for ( ; it != end && it.key() == key; ++it) {
2328         const QDBusConnectionPrivate::SignalHook &entry = it.value();
2329         if (entry.service == hook.service &&
2330             entry.path == hook.path &&
2331             entry.signature == hook.signature &&
2332             entry.obj == hook.obj &&
2333             entry.midx == hook.midx &&
2334             entry.argumentMatch.args == hook.argumentMatch.args) {
2335             // no need to compare the parameters if it's the same slot
2336             removeSignalHookNoLock(it);
2337             return true;        // it was there
2338         }
2339     }
2340 
2341     // the slot was not found
2342     return false;
2343 }
2344 
2345 QDBusConnectionPrivate::SignalHookHash::Iterator
2346 QDBusConnectionPrivate::removeSignalHookNoLock(SignalHookHash::Iterator it)
2347 {
2348     const SignalHook &hook = it.value();
2349 
2350     bool erase = false;
2351     MatchRefCountHash::iterator i = matchRefCounts.find(hook.matchRule);
2352     if (i == matchRefCounts.end()) {
2353         qWarning("QDBusConnectionPrivate::disconnectSignal: MatchRule not found in matchRefCounts!!");
2354     } else {
2355         if (i.value() == 1) {
2356             erase = true;
2357             matchRefCounts.erase(i);
2358         }
2359         else {
2360             i.value() = i.value() - 1;
2361         }
2362     }
2363 
2364     // we don't care about errors here
2365     if (connection && erase) {
2366         if (mode != QDBusConnectionPrivate::PeerMode) {
2367             qDBusDebug() << this << "Removing rule:" << hook.matchRule;
2368             q_dbus_bus_remove_match(connection, hook.matchRule, NULL);
2369 
2370             // Successfully disconnected the signal
2371             // Were we watching for this name?
2372             WatchedServicesHash::Iterator sit = watchedServices.find(hook.service);
2373             if (sit != watchedServices.end()) {
2374                 if (--sit.value().refcount == 0) {
2375                     watchedServices.erase(sit);
2376                     ArgMatchRules rules;
2377                     rules.args << hook.service;
2378                     q_dbus_bus_remove_match(connection,
2379                                             buildMatchRule(QDBusUtil::dbusService(), QString(), QDBusUtil::dbusInterface(),
2380                                                            QDBusUtil::nameOwnerChanged(), rules, QString()),
2381                                             NULL);
2382                 }
2383             }
2384         }
2385 
2386     }
2387 
2388     return signalHooks.erase(it);
2389 }
2390 
2391 void QDBusConnectionPrivate::registerObject(const ObjectTreeNode *node)
2392 {
2393     connect(node->obj, &QObject::destroyed, this, &QDBusConnectionPrivate::objectDestroyed,
2394             Qt::ConnectionType(Qt::BlockingQueuedConnection | Qt::UniqueConnection));
2395 
2396     if (node->flags & (QDBusConnection::ExportAdaptors
2397                        | QDBusConnection::ExportScriptableSignals
2398                        | QDBusConnection::ExportNonScriptableSignals)) {
2399         QDBusAdaptorConnector *connector = qDBusCreateAdaptorConnector(node->obj);
2400 
2401         if (node->flags & (QDBusConnection::ExportScriptableSignals
2402                            | QDBusConnection::ExportNonScriptableSignals)) {
2403             connector->disconnectAllSignals(node->obj);
2404             connector->connectAllSignals(node->obj);
2405         }
2406 
2407         connect(connector, SIGNAL(relaySignal(QObject*,const QMetaObject*,int,QVariantList)),
2408                 this, SLOT(relaySignal(QObject*,const QMetaObject*,int,QVariantList)),
2409                 Qt::ConnectionType(Qt::QueuedConnection | Qt::UniqueConnection));
2410     }
2411 }
2412 
2413 void QDBusConnectionPrivate::unregisterObject(const QString &path, QDBusConnection::UnregisterMode mode)
2414 {
2415     QDBusConnectionPrivate::ObjectTreeNode *node = &rootNode;
2416     QVector<QStringRef> pathComponents;
2417     int i;
2418     if (path == QLatin1String("/")) {
2419         i = 0;
2420     } else {
2421         pathComponents = path.splitRef(QLatin1Char('/'));
2422         i = 1;
2423     }
2424 
2425     huntAndUnregister(pathComponents, i, mode, node);
2426 }
2427 
2428 void QDBusConnectionPrivate::connectRelay(const QString &service,
2429                                           const QString &path, const QString &interface,
2430                                           QDBusAbstractInterface *receiver,
2431                                           const QMetaMethod &signal)
2432 {
2433     // this function is called by QDBusAbstractInterface when one of its signals is connected
2434     // we set up a relay from D-Bus into it
2435     SignalHook hook;
2436     QString key;
2437 
2438     QByteArray sig;
2439     sig.append(QSIGNAL_CODE + '0');
2440     sig.append(signal.methodSignature());
2441     if (!prepareHook(hook, key, service, path, interface, QString(), ArgMatchRules(), receiver, sig,
2442                      QDBusAbstractInterface::staticMetaObject.methodCount(), true))
2443         return;                 // don't connect
2444 
2445     Q_ASSERT(thread() != QThread::currentThread());
2446     emit signalNeedsConnecting(key, hook);
2447 }
2448 
2449 void QDBusConnectionPrivate::disconnectRelay(const QString &service,
2450                                              const QString &path, const QString &interface,
2451                                              QDBusAbstractInterface *receiver,
2452                                              const QMetaMethod &signal)
2453 {
2454     // this function is called by QDBusAbstractInterface when one of its signals is disconnected
2455     // we remove relay from D-Bus into it
2456     SignalHook hook;
2457     QString key;
2458 
2459     QByteArray sig;
2460     sig.append(QSIGNAL_CODE + '0');
2461     sig.append(signal.methodSignature());
2462     if (!prepareHook(hook, key, service, path, interface, QString(), ArgMatchRules(), receiver, sig,
2463                      QDBusAbstractInterface::staticMetaObject.methodCount(), true))
2464         return;                 // don't disconnect
2465 
2466     Q_ASSERT(thread() != QThread::currentThread());
2467     emit signalNeedsDisconnecting(key, hook);
2468 }
2469 
2470 bool QDBusConnectionPrivate::shouldWatchService(const QString &service)
2471 {
2472     // we don't have to watch anything in peer mode
2473     if (mode != ClientMode)
2474         return false;
2475     // we don't have to watch wildcard services (empty strings)
2476     if (service.isEmpty())
2477         return false;
2478     // we don't have to watch the bus driver
2479     if (service == QDBusUtil::dbusService())
2480         return false;
2481     return true;
2482 }
2483 
2484 /*!
2485     Sets up a watch rule for service \a service for the change described by
2486     mode \a mode. When the change happens, slot \a member in object \a obj will
2487     be called.
2488 
2489     The caller should call QDBusConnectionPrivate::shouldWatchService() before
2490     calling this function to check whether the service needs to be watched at
2491     all. Failing to do so may add rules that are never activated.
2492 */
2493 void QDBusConnectionPrivate::watchService(const QString &service, QDBusServiceWatcher::WatchMode mode, QObject *obj, const char *member)
2494 {
2495     ArgMatchRules matchArgs = matchArgsForService(service, mode);
2496     connectSignal(QDBusUtil::dbusService(), QString(), QDBusUtil::dbusInterface(), QDBusUtil::nameOwnerChanged(),
2497                   matchArgs, QString(), obj, member);
2498 }
2499 
2500 /*!
2501     Removes a watch rule set up by QDBusConnectionPrivate::watchService(). The
2502     arguments to this function must be the same as the ones for that function.
2503 
2504     Sets up a watch rule for service \a service for the change described by
2505     mode \a mode. When the change happens, slot \a member in object \a obj will
2506     be called.
2507 */
2508 void QDBusConnectionPrivate::unwatchService(const QString &service, QDBusServiceWatcher::WatchMode mode, QObject *obj, const char *member)
2509 {
2510     ArgMatchRules matchArgs = matchArgsForService(service, mode);
2511     disconnectSignal(QDBusUtil::dbusService(), QString(), QDBusUtil::dbusInterface(), QDBusUtil::nameOwnerChanged(),
2512                      matchArgs, QString(), obj, member);
2513 }
2514 
2515 QString QDBusConnectionPrivate::getNameOwner(const QString& serviceName)
2516 {
2517     if (QDBusUtil::isValidUniqueConnectionName(serviceName))
2518         return serviceName;
2519     if (!connection)
2520         return QString();
2521 
2522     {
2523         // acquire a read lock for the cache
2524         QReadLocker locker(&lock);
2525         WatchedServicesHash::ConstIterator it = watchedServices.constFind(serviceName);
2526         if (it != watchedServices.constEnd())
2527             return it->owner;
2528     }
2529 
2530     // not cached
2531     return getNameOwnerNoCache(serviceName);
2532 }
2533 
2534 QString QDBusConnectionPrivate::getNameOwnerNoCache(const QString &serviceName)
2535 {
2536     QDBusMessage msg = QDBusMessage::createMethodCall(QDBusUtil::dbusService(),
2537             QDBusUtil::dbusPath(), QDBusUtil::dbusInterface(),
2538             QStringLiteral("GetNameOwner"));
2539     QDBusMessagePrivate::setParametersValidated(msg, true);
2540     msg << serviceName;
2541 
2542     QDBusPendingCallPrivate *pcall = sendWithReplyAsync(msg, nullptr, nullptr, nullptr);
2543     if (thread() == QThread::currentThread()) {
2544         // this function may be called in our own thread and
2545         // QDBusPendingCallPrivate::waitForFinished() would deadlock there
2546         q_dbus_pending_call_block(pcall->pending);
2547     }
2548     pcall->waitForFinished();
2549     msg = pcall->replyMessage;
2550 
2551     if (!pcall->ref.deref())
2552         delete pcall;
2553 
2554     if (msg.type() == QDBusMessage::ReplyMessage)
2555         return msg.arguments().at(0).toString();
2556     return QString();
2557 }
2558 
2559 QDBusMetaObject *
2560 QDBusConnectionPrivate::findMetaObject(const QString &service, const QString &path,
2561                                        const QString &interface, QDBusError &error)
2562 {
2563     // service must be a unique connection name
2564     if (!interface.isEmpty()) {
2565         QDBusReadLocker locker(FindMetaObject1Action, this);
2566         QDBusMetaObject *mo = cachedMetaObjects.value(interface, 0);
2567         if (mo)
2568             return mo;
2569     }
2570 
2571     // introspect the target object
2572     QDBusMessage msg = QDBusMessage::createMethodCall(service, path,
2573                                                 QDBusUtil::dbusInterfaceIntrospectable(),
2574                                                 QStringLiteral("Introspect"));
2575     QDBusMessagePrivate::setParametersValidated(msg, true);
2576 
2577     QDBusMessage reply = sendWithReply(msg, QDBus::Block);
2578 
2579     // it doesn't exist yet, we have to create it
2580     QDBusWriteLocker locker(FindMetaObject2Action, this);
2581     QDBusMetaObject *mo = 0;
2582     if (!interface.isEmpty())
2583         mo = cachedMetaObjects.value(interface, 0);
2584     if (mo)
2585         // maybe it got created when we switched from read to write lock
2586         return mo;
2587 
2588     QString xml;
2589     if (reply.type() == QDBusMessage::ReplyMessage) {
2590         if (reply.signature() == QLatin1String("s"))
2591             // fetch the XML description
2592             xml = reply.arguments().at(0).toString();
2593     } else {
2594         error = QDBusError(reply);
2595         lastError = error;
2596         if (reply.type() != QDBusMessage::ErrorMessage || error.type() != QDBusError::UnknownMethod)
2597             return 0; // error
2598     }
2599 
2600     // release the lock and return
2601     QDBusMetaObject *result = QDBusMetaObject::createMetaObject(interface, xml,
2602                                                                 cachedMetaObjects, error);
2603     lastError = error;
2604     return result;
2605 }
2606 
2607 void QDBusConnectionPrivate::registerService(const QString &serviceName)
2608 {
2609     QDBusWriteLocker locker(RegisterServiceAction, this);
2610     registerServiceNoLock(serviceName);
2611 }
2612 
2613 void QDBusConnectionPrivate::registerServiceNoLock(const QString &serviceName)
2614 {
2615     serviceNames.append(serviceName);
2616 }
2617 
2618 void QDBusConnectionPrivate::unregisterService(const QString &serviceName)
2619 {
2620     QDBusWriteLocker locker(UnregisterServiceAction, this);
2621     unregisterServiceNoLock(serviceName);
2622 }
2623 
2624 void QDBusConnectionPrivate::unregisterServiceNoLock(const QString &serviceName)
2625 {
2626     serviceNames.removeAll(serviceName);
2627 }
2628 
2629 bool QDBusConnectionPrivate::isServiceRegisteredByThread(const QString &serviceName)
2630 {
2631     if (!serviceName.isEmpty() && serviceName == baseService)
2632         return true;
2633     if (serviceName == QDBusUtil::dbusService())
2634         return false;
2635 
2636     QDBusReadLocker locker(UnregisterServiceAction, this);
2637     return serviceNames.contains(serviceName);
2638 }
2639 
2640 void QDBusConnectionPrivate::postEventToThread(int action, QObject *object, QEvent *ev)
2641 {
2642     QDBusLockerBase::reportThreadAction(action, QDBusLockerBase::BeforePost, this);
2643     QCoreApplication::postEvent(object, ev);
2644     QDBusLockerBase::reportThreadAction(action, QDBusLockerBase::AfterPost, this);
2645 }
2646 
2647 QT_END_NAMESPACE
2648 
2649 #endif // QT_NO_DBUS
