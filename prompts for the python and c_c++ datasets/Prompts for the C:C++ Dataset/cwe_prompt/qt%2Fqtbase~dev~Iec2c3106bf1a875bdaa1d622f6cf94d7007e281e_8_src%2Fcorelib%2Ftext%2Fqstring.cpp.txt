Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 The Qt Company Ltd.
4 ** Copyright (C) 2018 Intel Corporation.
5 ** Copyright (C) 2019 Mail.ru Group.
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qstringlist.h"
43 #if QT_CONFIG(regularexpression)
44 #include "qregularexpression.h"
45 #endif
46 #include "qunicodetables_p.h"
47 #include <private/qstringconverter_p.h>
48 #include "qlocale_tools_p.h"
49 #include "private/qsimd_p.h"
50 #include <qnumeric.h>
51 #include <qdatastream.h>
52 #include <qlist.h>
53 #include "qlocale.h"
54 #include "qlocale_p.h"
55 #include "qstringbuilder.h"
56 #include "qstringmatcher.h"
57 #include "qvarlengtharray.h"
58 #include "qdebug.h"
59 #include "qendian.h"
60 #include "qcollator.h"
61 
62 #ifdef Q_OS_MAC
63 #include <private/qcore_mac_p.h>
64 #endif
65 
66 #include <private/qfunctions_p.h>
67 
68 #include <limits.h>
69 #include <string.h>
70 #include <stdlib.h>
71 #include <stdio.h>
72 #include <stdarg.h>
73 #include <wchar.h>
74 
75 #include "qchar.cpp"
76 #include "qstringmatcher.cpp"
77 #include "qstringiterator_p.h"
78 #include "qstringalgorithms_p.h"
79 #include "qthreadstorage.h"
80 
81 #ifdef Q_OS_WIN
82 #  include <qt_windows.h>
83 #endif
84 
85 #ifdef truncate
86 #  undef truncate
87 #endif
88 
89 #ifndef LLONG_MAX
90 #define LLONG_MAX qint64_C(9223372036854775807)
91 #endif
92 #ifndef LLONG_MIN
93 #define LLONG_MIN (-LLONG_MAX - qint64_C(1))
94 #endif
95 #ifndef ULLONG_MAX
96 #define ULLONG_MAX quint64_C(18446744073709551615)
97 #endif
98 
99 #define IS_RAW_DATA(d) ((d.d)->flags & QArrayData::RawDataType)
100 
101 QT_BEGIN_NAMESPACE
102 
103 template <typename T, typename Cmp = std::less<>>
104 static constexpr bool points_into_range(const T *p, const T *b, const T *e, Cmp less = {}) noexcept
105 {
106     return !less(p, b) && less(p, e);
107 }
108 
109 const char16_t QString::_empty = 0;
110 
111 /*
112  * Note on the use of SIMD in qstring.cpp:
113  *
114  * Several operations with strings are improved with the use of SIMD code,
115  * since they are repetitive. For MIPS, we have hand-written assembly code
116  * outside of qstring.cpp targeting MIPS DSP and MIPS DSPr2. For ARM and for
117  * x86, we can only use intrinsics and therefore everything is contained in
118  * qstring.cpp. We need to use intrinsics only for those platforms due to the
119  * different compilers and toolchains used, which have different syntax for
120  * assembly sources.
121  *
122  * ** SSE notes: **
123  *
124  * Whenever multiple alternatives are equivalent or near so, we prefer the one
125  * using instructions from SSE2, since SSE2 is guaranteed to be enabled for all
126  * 64-bit builds and we enable it for 32-bit builds by default. Use of higher
127  * SSE versions should be done when there is a clear performance benefit and
128  * requires fallback code to SSE2, if it exists.
129  *
130  * Performance measurement in the past shows that most strings are short in
131  * size and, therefore, do not benefit from alignment prologues. That is,
132  * trying to find a 16-byte-aligned boundary to operate on is often more
133  * expensive than executing the unaligned operation directly. In addition, note
134  * that the QString private data is designed so that the data is stored on
135  * 16-byte boundaries if the system malloc() returns 16-byte aligned pointers
136  * on its own (64-bit glibc on Linux does; 32-bit glibc on Linux returns them
137  * 50% of the time), so skipping the alignment prologue is actually optimizing
138  * for the common case.
139  */
140 
141 #if defined(__mips_dsp)
142 // From qstring_mips_dsp_asm.S
143 extern "C" void qt_fromlatin1_mips_asm_unroll4 (char16_t*, const char*, uint);
144 extern "C" void qt_fromlatin1_mips_asm_unroll8 (char16_t*, const char*, uint);
145 extern "C" void qt_toLatin1_mips_dsp_asm(uchar *dst, const char16_t *src, int length);
146 #endif
147 
148 // internal
149 qsizetype qFindStringBoyerMoore(QStringView haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs);
150 static inline qsizetype qFindChar(QStringView str, QChar ch, qsizetype from, Qt::CaseSensitivity cs) noexcept;
151 template <typename Haystack>
152 static inline qsizetype qLastIndexOf(Haystack haystack, QChar needle, qsizetype from, Qt::CaseSensitivity cs) noexcept;
153 template <>
154 inline qsizetype qLastIndexOf(QString haystack, QChar needle,
155                               qsizetype from, Qt::CaseSensitivity cs) noexcept = delete; // unwanted, would detach
156 
157 static inline bool qt_starts_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs);
158 static inline bool qt_starts_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs);
159 static inline bool qt_starts_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs);
160 static inline bool qt_ends_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs);
161 static inline bool qt_ends_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs);
162 static inline bool qt_ends_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs);
163 
164 #if defined(__SSE2__) && defined(Q_CC_GNU) && !defined(Q_CC_INTEL)
165 // We may overrun the buffer, but that's a false positive:
166 // this won't crash nor produce incorrect results
167 __attribute__((__no_sanitize_address__))
168 #endif
169 qsizetype QtPrivate::qustrlen(const char16_t *str) noexcept
170 {
171     qsizetype result = 0;
172 
173 #if defined(__SSE2__) && !(defined(__SANITIZE_ADDRESS__) || QT_HAS_FEATURE(address_sanitizer))
174     // find the 16-byte alignment immediately prior or equal to str
175     quintptr misalignment = quintptr(str) & 0xf;
176     Q_ASSERT((misalignment & 1) == 0);
177     const char16_t *ptr = str - (misalignment / 2);
178 
179     // load 16 bytes and see if we have a null
180     // (aligned loads can never segfault)
181     const __m128i zeroes = _mm_setzero_si128();
182     __m128i data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
183     __m128i comparison = _mm_cmpeq_epi16(data, zeroes);
184     quint32 mask = _mm_movemask_epi8(comparison);
185 
186     // ignore the result prior to the beginning of str
187     mask >>= misalignment;
188 
189     // Have we found something in the first block? Need to handle it now
190     // because of the left shift above.
191     if (mask)
192         return qCountTrailingZeroBits(quint32(mask)) / 2;
193 
194     do {
195         ptr += 8;
196         data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
197 
198         comparison = _mm_cmpeq_epi16(data, zeroes);
199         mask = _mm_movemask_epi8(comparison);
200     } while (mask == 0);
201 
202     // found a null
203     uint idx = qCountTrailingZeroBits(quint32(mask));
204     return ptr - str + idx / 2;
205 #endif
206 
207     if (sizeof(wchar_t) == sizeof(char16_t))
208         return wcslen(reinterpret_cast<const wchar_t *>(str));
209 
210     while (*str++)
211         ++result;
212     return result;
213 }
214 
215 #if !defined(__OPTIMIZE_SIZE__)
216 namespace {
217 template <uint MaxCount> struct UnrollTailLoop
218 {
219     template <typename RetType, typename Functor1, typename Functor2, typename Number>
220     static inline RetType exec(Number count, RetType returnIfExited, Functor1 loopCheck, Functor2 returnIfFailed, Number i = 0)
221     {
222         /* equivalent to:
223          *   while (count--) {
224          *       if (loopCheck(i))
225          *           return returnIfFailed(i);
226          *   }
227          *   return returnIfExited;
228          */
229 
230         if (!count)
231             return returnIfExited;
232 
233         bool check = loopCheck(i);
234         if (check)
235             return returnIfFailed(i);
236 
237         return UnrollTailLoop<MaxCount - 1>::exec(count - 1, returnIfExited, loopCheck, returnIfFailed, i + 1);
238     }
239 
240     template <typename Functor, typename Number>
241     static inline void exec(Number count, Functor code)
242     {
243         /* equivalent to:
244          *   for (Number i = 0; i < count; ++i)
245          *       code(i);
246          */
247         exec(count, 0, [=](Number i) -> bool { code(i); return false; }, [](Number) { return 0; });
248     }
249 };
250 template <> template <typename RetType, typename Functor1, typename Functor2, typename Number>
251 inline RetType UnrollTailLoop<0>::exec(Number, RetType returnIfExited, Functor1, Functor2, Number)
252 {
253     return returnIfExited;
254 }
255 }
256 #endif
257 
258 /*!
259  * \internal
260  *
261  * Searches for character \a c in the string \a str and returns a pointer to
262  * it. Unlike strchr() and wcschr() (but like glibc's strchrnul()), if the
263  * character is not found, this function returns a pointer to the end of the
264  * string -- that is, \c{str.end()}.
265  */
266 const char16_t *QtPrivate::qustrchr(QStringView str, char16_t c) noexcept
267 {
268     const char16_t *n = str.utf16();
269     const char16_t *e = n + str.size();
270 
271 #ifdef __SSE2__
272     bool loops = true;
273     // Using the PMOVMSKB instruction, we get two bits for each character
274     // we compare.
275 #  if defined(__AVX2__) && !defined(__OPTIMIZE_SIZE__)
276     // we're going to read n[0..15] (32 bytes)
277     __m256i mch256 = _mm256_set1_epi32(c | (c << 16));
278     for (const char16_t *next = n + 16; next <= e; n = next, next += 16) {
279         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(n));
280         __m256i result = _mm256_cmpeq_epi16(data, mch256);
281         uint mask = uint(_mm256_movemask_epi8(result));
282         if (mask) {
283             uint idx = qCountTrailingZeroBits(mask);
284             return n + idx / 2;
285         }
286     }
287     loops = false;
288     __m128i mch = _mm256_castsi256_si128(mch256);
289 #  else
290     __m128i mch = _mm_set1_epi32(c | (c << 16));
291 #  endif
292 
293     auto hasMatch = [mch, &n](__m128i data, ushort validityMask) {
294         __m128i result = _mm_cmpeq_epi16(data, mch);
295         uint mask = uint(_mm_movemask_epi8(result));
296         if ((mask & validityMask) == 0)
297             return false;
298         uint idx = qCountTrailingZeroBits(mask);
299         n += idx / 2;
300         return true;
301     };
302 
303     // we're going to read n[0..7] (16 bytes)
304     for (const char16_t *next = n + 8; next <= e; n = next, next += 8) {
305         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(n));
306         if (hasMatch(data, 0xffff))
307             return n;
308 
309         if (!loops) {
310             n += 8;
311             break;
312         }
313     }
314 
315 #  if !defined(__OPTIMIZE_SIZE__)
316     // we're going to read n[0..3] (8 bytes)
317     if (e - n > 3) {
318         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(n));
319         if (hasMatch(data, 0xff))
320             return n;
321 
322         n += 4;
323     }
324 
325     return UnrollTailLoop<3>::exec(e - n, e,
326                                    [=](int i) { return n[i] == c; },
327                                    [=](int i) { return n + i; });
328 #  endif
329 #elif defined(__ARM_NEON__) && defined(Q_PROCESSOR_ARM_64) // vaddv is only available on Aarch64
330     const uint16x8_t vmask = { 1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7 };
331     const uint16x8_t ch_vec = vdupq_n_u16(c);
332     for (const char16_t *next = n + 8; next <= e; n = next, next += 8) {
333         uint16x8_t data = vld1q_u16(reinterpret_cast<const uint16_t *>(n));
334         uint mask = vaddvq_u16(vandq_u16(vceqq_u16(data, ch_vec), vmask));
335         if (ushort(mask)) {
336             // found a match
337             return n + qCountTrailingZeroBits(mask);
338         }
339     }
340 #endif // aarch64
341 
342     --n;
343     while (++n != e)
344         if (*n == c)
345             return n;
346 
347     return n;
348 }
349 
350 #ifdef __SSE2__
351 // Scans from \a ptr to \a end until \a maskval is non-zero. Returns true if
352 // the no non-zero was found. Returns false and updates \a ptr to point to the
353 // first 16-bit word that has any bit set (note: if the input is 8-bit, \a ptr
354 // may be updated to one byte short).
355 static bool simdTestMask(const char *&ptr, const char *end, quint32 maskval)
356 {
357     auto updatePtr = [&](uint result) {
358         // found a character matching the mask
359         uint idx = qCountTrailingZeroBits(~result);
360         ptr += idx;
361         return false;
362     };
363 
364 #  if defined(__SSE4_1__)
365     __m128i mask;
366     auto updatePtrSimd = [&](__m128i data) {
367         __m128i masked = _mm_and_si128(mask, data);
368         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
369         uint result = _mm_movemask_epi8(comparison);
370         return updatePtr(result);
371     };
372 
373 #    if defined(__AVX2__)
374     // AVX2 implementation: test 32 bytes at a time
375     const __m256i mask256 = _mm256_broadcastd_epi32(_mm_cvtsi32_si128(maskval));
376     while (ptr + 32 <= end) {
377         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr));
378         if (!_mm256_testz_si256(mask256, data)) {
379             // found a character matching the mask
380             __m256i masked256 = _mm256_and_si256(mask256, data);
381             __m256i comparison256 = _mm256_cmpeq_epi16(masked256, _mm256_setzero_si256());
382             return updatePtr(_mm256_movemask_epi8(comparison256));
383         }
384         ptr += 32;
385     }
386 
387     mask = _mm256_castsi256_si128(mask256);
388 #    else
389     // SSE 4.1 implementation: test 32 bytes at a time (two 16-byte
390     // comparisons, unrolled)
391     mask = _mm_set1_epi32(maskval);
392     while (ptr + 32 <= end) {
393         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
394         __m128i data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr + 16));
395         if (!_mm_testz_si128(mask, data1))
396             return updatePtrSimd(data1);
397 
398         ptr += 16;
399         if (!_mm_testz_si128(mask, data2))
400             return updatePtrSimd(data2);
401         ptr += 16;
402     }
403 #    endif
404 
405     // AVX2 and SSE4.1: final 16-byte comparison
406     if (ptr + 16 <= end) {
407         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
408         if (!_mm_testz_si128(mask, data1))
409             return updatePtrSimd(data1);
410         ptr += 16;
411     }
412 
413     // and final 8-byte comparison
414     if (ptr + 8 <= end) {
415         __m128i data1 = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
416         if (!_mm_testz_si128(mask, data1))
417             return updatePtrSimd(data1);
418         ptr += 8;
419     }
420 
421 #  else
422     // SSE2 implementation: test 16 bytes at a time.
423     const __m128i mask = _mm_set1_epi32(maskval);
424     while (ptr + 16 <= end) {
425         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
426         __m128i masked = _mm_and_si128(mask, data);
427         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
428         quint16 result = _mm_movemask_epi8(comparison);
429         if (result != 0xffff)
430             return updatePtr(result);
431         ptr += 16;
432     }
433 
434     // and one 8-byte comparison
435     if (ptr + 8 <= end) {
436         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
437         __m128i masked = _mm_and_si128(mask, data);
438         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
439         quint8 result = _mm_movemask_epi8(comparison);
440         if (result != 0xff)
441             return updatePtr(result);
442         ptr += 8;
443     }
444 #  endif
445 
446     return true;
447 }
448 
449 static Q_ALWAYS_INLINE __m128i mm_load8_zero_extend(const void *ptr)
450 {
451     const __m128i *dataptr = static_cast<const __m128i *>(ptr);
452 #if defined(__SSE4_1__)
453     // use a MOVQ followed by PMOVZXBW
454     // if AVX2 is present, these should combine into a single VPMOVZXBW instruction
455     __m128i data = _mm_loadl_epi64(dataptr);
456     return _mm_cvtepu8_epi16(data);
457 #  else
458     // use MOVQ followed by PUNPCKLBW
459     __m128i data = _mm_loadl_epi64(dataptr);
460     return _mm_unpacklo_epi8(data, _mm_setzero_si128());
461 #  endif
462 }
463 #endif
464 
465 // Note: ptr on output may be off by one and point to a preceding US-ASCII
466 // character. Usually harmless.
467 bool qt_is_ascii(const char *&ptr, const char *end) noexcept
468 {
469 #if defined(__SSE2__)
470     // Testing for the high bit can be done efficiently with just PMOVMSKB
471 #  if defined(__AVX2__)
472     while (ptr + 32 <= end) {
473         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr));
474         quint32 mask = _mm256_movemask_epi8(data);
475         if (mask) {
476             uint idx = qCountTrailingZeroBits(mask);
477             ptr += idx;
478             return false;
479         }
480         ptr += 32;
481     }
482 #  endif
483     while (ptr + 16 <= end) {
484         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
485         quint32 mask = _mm_movemask_epi8(data);
486         if (mask) {
487             uint idx = qCountTrailingZeroBits(mask);
488             ptr += idx;
489             return false;
490         }
491         ptr += 16;
492     }
493     if (ptr + 8 <= end) {
494         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
495         quint8 mask = _mm_movemask_epi8(data);
496         if (mask) {
497             uint idx = qCountTrailingZeroBits(mask);
498             ptr += idx;
499             return false;
500         }
501         ptr += 8;
502     }
503 #endif
504 
505     while (ptr + 4 <= end) {
506         quint32 data = qFromUnaligned<quint32>(ptr);
507         if (data &= 0x80808080U) {
508 #if Q_BYTE_ORDER == Q_BIG_ENDIAN
509             uint idx = qCountLeadingZeroBits(data);
510 #else
511             uint idx = qCountTrailingZeroBits(data);
512 #endif
513             ptr += idx / 8;
514             return false;
515         }
516         ptr += 4;
517     }
518 
519     while (ptr != end) {
520         if (quint8(*ptr) & 0x80)
521             return false;
522         ++ptr;
523     }
524     return true;
525 }
526 
527 bool QtPrivate::isAscii(QLatin1String s) noexcept
528 {
529     const char *ptr = s.begin();
530     const char *end = s.end();
531 
532     return qt_is_ascii(ptr, end);
533 }
534 
535 static bool isAscii(const QChar *&ptr, const QChar *end)
536 {
537 #ifdef __SSE2__
538     const char *ptr8 = reinterpret_cast<const char *>(ptr);
539     const char *end8 = reinterpret_cast<const char *>(end);
540     bool ok = simdTestMask(ptr8, end8, 0xff80ff80);
541     ptr = reinterpret_cast<const QChar *>(ptr8);
542     if (!ok)
543         return false;
544 #endif
545 
546     while (ptr != end) {
547         if (ptr->unicode() & 0xff80)
548             return false;
549         ++ptr;
550     }
551     return true;
552 }
553 
554 bool QtPrivate::isAscii(QStringView s) noexcept
555 {
556     const QChar *ptr = s.begin();
557     const QChar *end = s.end();
558 
559     return isAscii(ptr, end);
560 }
561 
562 bool QtPrivate::isLatin1(QStringView s) noexcept
563 {
564     const QChar *ptr = s.begin();
565     const QChar *end = s.end();
566 
567 #if defined(__SSE4_1__)
568     const char *ptr8 = reinterpret_cast<const char *>(ptr);
569     const char *end8 = reinterpret_cast<const char *>(end);
570     if (!simdTestMask(ptr8, end8, 0xff00ff00))
571         return false;
572     ptr = reinterpret_cast<const QChar *>(ptr8);
573 #elif defined(__SSE2__)
574     // Testing if every other byte is non-zero can be done efficiently by
575     // using PUNPCKHBW (unpack high order bytes) and comparing that to zero.
576     while (ptr + 32 < end) {
577         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
578         __m128i data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr + 16));
579         __m128i high = _mm_unpackhi_epi8(data1, data2);
580         __m128i comparison = _mm_cmpeq_epi16(high, _mm_setzero_si128());
581         if (_mm_movemask_epi8(comparison))
582             return false;
583         ptr += 16;
584     }
585     if (ptr + 16 < end) {
586         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
587         __m128i high = _mm_unpackhi_epi8(data1, data1);
588         __m128i comparison = _mm_cmpeq_epi16(high, _mm_setzero_si128());
589         if (_mm_movemask_epi8(comparison))
590             return false;
591     }
592 #endif
593 
594     while (ptr != end) {
595         if ((*ptr++).unicode() > 0xff)
596             return false;
597     }
598     return true;
599 }
600 
601 bool QtPrivate::isValidUtf16(QStringView s) noexcept
602 {
603     Q_CONSTEXPR char32_t InvalidCodePoint = UINT_MAX;
604 
605     QStringIterator i(s);
606     while (i.hasNext()) {
607         const char32_t c = i.next(InvalidCodePoint);
608         if (c == InvalidCodePoint)
609             return false;
610     }
611 
612     return true;
613 }
614 
615 // conversion between Latin 1 and UTF-16
616 Q_CORE_EXPORT void qt_from_latin1(char16_t *dst, const char *str, size_t size) noexcept
617 {
618     /* SIMD:
619      * Unpacking with SSE has been shown to improve performance on recent CPUs
620      * The same method gives no improvement with NEON. On Aarch64, clang will do the vectorization
621      * itself in exactly the same way as one would do it with intrinsics.
622      */
623 #if defined(__SSE2__)
624     const char *e = str + size;
625     qptrdiff offset = 0;
626 
627     // we're going to read str[offset..offset+15] (16 bytes)
628     for ( ; str + offset + 15 < e; offset += 16) {
629         const __m128i chunk = _mm_loadu_si128((const __m128i*)(str + offset)); // load
630 #ifdef __AVX2__
631         // zero extend to an YMM register
632         const __m256i extended = _mm256_cvtepu8_epi16(chunk);
633 
634         // store
635         _mm256_storeu_si256((__m256i*)(dst + offset), extended);
636 #else
637         const __m128i nullMask = _mm_set1_epi32(0);
638 
639         // unpack the first 8 bytes, padding with zeros
640         const __m128i firstHalf = _mm_unpacklo_epi8(chunk, nullMask);
641         _mm_storeu_si128((__m128i*)(dst + offset), firstHalf); // store
642 
643         // unpack the last 8 bytes, padding with zeros
644         const __m128i secondHalf = _mm_unpackhi_epi8 (chunk, nullMask);
645         _mm_storeu_si128((__m128i*)(dst + offset + 8), secondHalf); // store
646 #endif
647     }
648 
649     // we're going to read str[offset..offset+7] (8 bytes)
650     if (str + offset + 7 < e) {
651         const __m128i unpacked = mm_load8_zero_extend(str + offset);
652         _mm_storeu_si128(reinterpret_cast<__m128i *>(dst + offset), unpacked);
653         offset += 8;
654     }
655 
656     size = size % 8;
657     dst += offset;
658     str += offset;
659 #  if !defined(__OPTIMIZE_SIZE__)
660     return UnrollTailLoop<7>::exec(int(size), [=](int i) { dst[i] = (uchar)str[i]; });
661 #  endif
662 #endif
663 #if defined(__mips_dsp)
664     if (size > 20)
665         qt_fromlatin1_mips_asm_unroll8(dst, str, size);
666     else
667         qt_fromlatin1_mips_asm_unroll4(dst, str, size);
668 #else
669     while (size--)
670         *dst++ = (uchar)*str++;
671 #endif
672 }
673 
674 template <bool Checked>
675 static void qt_to_latin1_internal(uchar *dst, const char16_t *src, qsizetype length)
676 {
677 #if defined(__SSE2__)
678     uchar *e = dst + length;
679     qptrdiff offset = 0;
680 
681 #  ifdef __AVX2__
682     const __m256i questionMark256 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128('?'));
683     const __m256i outOfRange256 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128(0x100));
684     const __m128i questionMark = _mm256_castsi256_si128(questionMark256);
685     const __m128i outOfRange = _mm256_castsi256_si128(outOfRange256);
686 #  else
687     const __m128i questionMark = _mm_set1_epi16('?');
688     const __m128i outOfRange = _mm_set1_epi16(0x100);
689 #  endif
690 
691     auto mergeQuestionMarks = [=](__m128i chunk) {
692         // SSE has no compare instruction for unsigned comparison.
693 # ifdef __SSE4_1__
694         // We use an unsigned uc = qMin(uc, 0x100) and then compare for equality.
695         chunk = _mm_min_epu16(chunk, outOfRange);
696         const __m128i offLimitMask = _mm_cmpeq_epi16(chunk, outOfRange);
697         chunk = _mm_blendv_epi8(chunk, questionMark, offLimitMask);
698 # else
699         // The variables must be shiffted + 0x8000 to be compared
700         const __m128i signedBitOffset = _mm_set1_epi16(short(0x8000));
701         const __m128i thresholdMask = _mm_set1_epi16(short(0xff + 0x8000));
702 
703         const __m128i signedChunk = _mm_add_epi16(chunk, signedBitOffset);
704         const __m128i offLimitMask = _mm_cmpgt_epi16(signedChunk, thresholdMask);
705 
706         // offLimitQuestionMark contains '?' for each 16 bits that was off-limit
707         // the 16 bits that were correct contains zeros
708         const __m128i offLimitQuestionMark = _mm_and_si128(offLimitMask, questionMark);
709 
710         // correctBytes contains the bytes that were in limit
711         // the 16 bits that were off limits contains zeros
712         const __m128i correctBytes = _mm_andnot_si128(offLimitMask, chunk);
713 
714         // merge offLimitQuestionMark and correctBytes to have the result
715         chunk = _mm_or_si128(correctBytes, offLimitQuestionMark);
716 
717         Q_UNUSED(outOfRange);
718 # endif
719         return chunk;
720     };
721 
722     // we're going to write to dst[offset..offset+15] (16 bytes)
723     for ( ; dst + offset + 15 < e; offset += 16) {
724 #  if defined(__AVX2__)
725         __m256i chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(src + offset));
726         if (Checked) {
727             // See mergeQuestionMarks lambda above for details
728             chunk = _mm256_min_epu16(chunk, outOfRange256);
729             const __m256i offLimitMask = _mm256_cmpeq_epi16(chunk, outOfRange256);
730             chunk = _mm256_blendv_epi8(chunk, questionMark256, offLimitMask);
731         }
732 
733         const __m128i chunk2 = _mm256_extracti128_si256(chunk, 1);
734         const __m128i chunk1 = _mm256_castsi256_si128(chunk);
735 #  else
736         __m128i chunk1 = _mm_loadu_si128((const __m128i*)(src + offset)); // load
737         if (Checked)
738             chunk1 = mergeQuestionMarks(chunk1);
739 
740         __m128i chunk2 = _mm_loadu_si128((const __m128i*)(src + offset + 8)); // load
741         if (Checked)
742             chunk2 = mergeQuestionMarks(chunk2);
743 #  endif
744 
745         // pack the two vector to 16 x 8bits elements
746         const __m128i result = _mm_packus_epi16(chunk1, chunk2);
747         _mm_storeu_si128((__m128i*)(dst + offset), result); // store
748     }
749 
750 #  if !defined(__OPTIMIZE_SIZE__)
751     // we're going to write to dst[offset..offset+7] (8 bytes)
752     if (dst + offset + 7 < e) {
753         __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i *>(src + offset));
754         if (Checked)
755             chunk = mergeQuestionMarks(chunk);
756 
757         // pack, where the upper half is ignored
758         const __m128i result = _mm_packus_epi16(chunk, chunk);
759         _mm_storel_epi64(reinterpret_cast<__m128i *>(dst + offset), result);
760         offset += 8;
761     }
762 
763     // we're going to write to dst[offset..offset+3] (4 bytes)
764     if (dst + offset + 3 < e) {
765         __m128i chunk = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(src + offset));
766         if (Checked)
767             chunk = mergeQuestionMarks(chunk);
768 
769         // pack, we'll the upper three quarters
770         const __m128i result = _mm_packus_epi16(chunk, chunk);
771         qToUnaligned(_mm_cvtsi128_si32(result), dst + offset);
772         offset += 4;
773     }
774 
775     length = length % 4;
776 #  else
777     length = length % 16;
778 #  endif // optimize size
779 
780     // advance dst, src for tail processing
781     dst += offset;
782     src += offset;
783 
784 #  if !defined(__OPTIMIZE_SIZE__)
785     return UnrollTailLoop<3>::exec(length, [=](int i) {
786         if (Checked)
787             dst[i] = (src[i]>0xff) ? '?' : (uchar) src[i];
788         else
789             dst[i] = src[i];
790     });
791 #  endif
792 #elif defined(__ARM_NEON__)
793     // Refer to the documentation of the SSE2 implementation
794     // this use eactly the same method as for SSE except:
795     // 1) neon has unsigned comparison
796     // 2) packing is done to 64 bits (8 x 8bits component).
797     if (length >= 16) {
798         const int chunkCount = length >> 3; // divided by 8
799         const uint16x8_t questionMark = vdupq_n_u16('?'); // set
800         const uint16x8_t thresholdMask = vdupq_n_u16(0xff); // set
801         for (int i = 0; i < chunkCount; ++i) {
802             uint16x8_t chunk = vld1q_u16((uint16_t *)src); // load
803             src += 8;
804 
805             if (Checked) {
806                 const uint16x8_t offLimitMask = vcgtq_u16(chunk, thresholdMask); // chunk > thresholdMask
807                 const uint16x8_t offLimitQuestionMark = vandq_u16(offLimitMask, questionMark); // offLimitMask & questionMark
808                 const uint16x8_t correctBytes = vbicq_u16(chunk, offLimitMask); // !offLimitMask & chunk
809                 chunk = vorrq_u16(correctBytes, offLimitQuestionMark); // correctBytes | offLimitQuestionMark
810             }
811             const uint8x8_t result = vmovn_u16(chunk); // narrowing move->packing
812             vst1_u8(dst, result); // store
813             dst += 8;
814         }
815         length = length % 8;
816     }
817 #endif
818 #if defined(__mips_dsp)
819     qt_toLatin1_mips_dsp_asm(dst, src, length);
820 #else
821     while (length--) {
822         if (Checked)
823             *dst++ = (*src>0xff) ? '?' : (uchar) *src;
824         else
825             *dst++ = *src;
826         ++src;
827     }
828 #endif
829 }
830 
831 static void qt_to_latin1(uchar *dst, const char16_t *src, qsizetype length)
832 {
833     qt_to_latin1_internal<true>(dst, src, length);
834 }
835 
836 void qt_to_latin1_unchecked(uchar *dst, const char16_t *src, qsizetype length)
837 {
838     qt_to_latin1_internal<false>(dst, src, length);
839 }
840 
841 // Unicode case-insensitive comparison
842 static int ucstricmp(const QChar *a, const QChar *ae, const QChar *b, const QChar *be)
843 {
844     if (a == b)
845         return (ae - be);
846 
847     const QChar *e = ae;
848     if (be - b < ae - a)
849         e = a + (be - b);
850 
851     char32_t alast = 0;
852     char32_t blast = 0;
853     while (a < e) {
854 //         qDebug() << Qt::hex << alast << blast;
855 //         qDebug() << Qt::hex << "*a=" << *a << "alast=" << alast << "folded=" << foldCase (*a, alast);
856 //         qDebug() << Qt::hex << "*b=" << *b << "blast=" << blast << "folded=" << foldCase (*b, blast);
857         int diff = foldCase(a->unicode(), alast) - foldCase(b->unicode(), blast);
858         if ((diff))
859             return diff;
860         ++a;
861         ++b;
862     }
863     if (a == ae) {
864         if (b == be)
865             return 0;
866         return -1;
867     }
868     return 1;
869 }
870 
871 // Case-insensitive comparison between a Unicode string and a QLatin1String
872 static int ucstricmp(const QChar *a, const QChar *ae, const char *b, const char *be)
873 {
874     auto e = ae;
875     if (be - b < ae - a)
876         e = a + (be - b);
877 
878     while (a < e) {
879         int diff = foldCase(a->unicode()) - foldCase(char16_t{uchar(*b)});
880         if ((diff))
881             return diff;
882         ++a;
883         ++b;
884     }
885     if (a == ae) {
886         if (b == be)
887             return 0;
888         return -1;
889     }
890     return 1;
891 }
892 
893 #if defined(__mips_dsp)
894 // From qstring_mips_dsp_asm.S
895 extern "C" int qt_ucstrncmp_mips_dsp_asm(const char16_t *a,
896                                          const char16_t *b,
897                                          unsigned len);
898 #endif
899 
900 // Unicode case-sensitive compare two same-sized strings
901 static int ucstrncmp(const QChar *a, const QChar *b, size_t l)
902 {
903 #ifdef __OPTIMIZE_SIZE__
904     const QChar *end = a + l;
905     while (a < end) {
906         if (int diff = (int)a->unicode() - (int)b->unicode())
907             return diff;
908         ++a;
909         ++b;
910     }
911     return 0;
912 #else
913 #if defined(__mips_dsp)
914     static_assert(sizeof(uint) == sizeof(size_t));
915     if (l >= 8) {
916         return qt_ucstrncmp_mips_dsp_asm(reinterpret_cast<const char16_t*>(a),
917                                          reinterpret_cast<const char16_t*>(b),
918                                          l);
919     }
920 #endif // __mips_dsp
921 #ifdef __SSE2__
922     const QChar *end = a + l;
923     qptrdiff offset = 0;
924 
925     // Using the PMOVMSKB instruction, we get two bits for each character
926     // we compare.
927     int retval;
928     auto isDifferent = [a, b, &offset, &retval](__m128i a_data, __m128i b_data) {
929         __m128i result = _mm_cmpeq_epi16(a_data, b_data);
930         uint mask = ~uint(_mm_movemask_epi8(result));
931         if (ushort(mask) == 0)
932             return false;
933         uint idx = qCountTrailingZeroBits(mask);
934         retval = a[offset + idx / 2].unicode() - b[offset + idx / 2].unicode();
935         return true;
936     };
937 
938     // we're going to read a[0..15] and b[0..15] (32 bytes)
939     for ( ; end - a >= offset + 16; offset += 16) {
940 #ifdef __AVX2__
941         __m256i a_data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(a + offset));
942         __m256i b_data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(b + offset));
943         __m256i result = _mm256_cmpeq_epi16(a_data, b_data);
944         uint mask = _mm256_movemask_epi8(result);
945 #else
946         __m128i a_data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset));
947         __m128i a_data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset + 8));
948         __m128i b_data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset));
949         __m128i b_data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset + 8));
950         __m128i result1 = _mm_cmpeq_epi16(a_data1, b_data1);
951         __m128i result2 = _mm_cmpeq_epi16(a_data2, b_data2);
952         uint mask = _mm_movemask_epi8(result1) | (_mm_movemask_epi8(result2) << 16);
953 #endif
954         mask = ~mask;
955         if (mask) {
956             // found a different character
957             uint idx = qCountTrailingZeroBits(mask);
958             return a[offset + idx / 2].unicode() - b[offset + idx / 2].unicode();
959         }
960     }
961 
962     // we're going to read a[0..7] and b[0..7] (16 bytes)
963     if (end - a >= offset + 8) {
964         __m128i a_data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset));
965         __m128i b_data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset));
966         if (isDifferent(a_data, b_data))
967             return retval;
968 
969         offset += 8;
970     }
971 
972     // we're going to read a[0..3] and b[0..3] (8 bytes)
973     if (end - a >= offset + 4) {
974         __m128i a_data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(a + offset));
975         __m128i b_data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(b + offset));
976         if (isDifferent(a_data, b_data))
977             return retval;
978 
979         offset += 4;
980     }
981 
982     // reset l
983     l &= 3;
984 
985     const auto lambda = [=](size_t i) -> int {
986         return a[offset + i].unicode() - b[offset + i].unicode();
987     };
988     return UnrollTailLoop<3>::exec(l, 0, lambda, lambda);
989 #endif
990 #if defined(__ARM_NEON__) && defined(Q_PROCESSOR_ARM_64) // vaddv is only available on Aarch64
991     if (l >= 8) {
992         const QChar *end = a + l;
993         const uint16x8_t mask = { 1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7 };
994         while (end - a > 7) {
995             uint16x8_t da = vld1q_u16(reinterpret_cast<const uint16_t *>(a));
996             uint16x8_t db = vld1q_u16(reinterpret_cast<const uint16_t *>(b));
997 
998             uint8_t r = ~(uint8_t)vaddvq_u16(vandq_u16(vceqq_u16(da, db), mask));
999             if (r) {
1000                 // found a different QChar
1001                 uint idx = qCountTrailingZeroBits(r);
1002                 return (int)a[idx].unicode() - (int)b[idx].unicode();
1003             }
1004             a += 8;
1005             b += 8;
1006         }
1007         l &= 7;
1008     }
1009     const auto lambda = [=](size_t i) -> int {
1010         return a[i].unicode() - b[i].unicode();
1011     };
1012     return UnrollTailLoop<7>::exec(l, 0, lambda, lambda);
1013 #endif // __ARM_NEON__
1014     if (!l)
1015         return 0;
1016 
1017     // check alignment
1018     if ((reinterpret_cast<quintptr>(a) & 2) == (reinterpret_cast<quintptr>(b) & 2)) {
1019         // both addresses have the same alignment
1020         if (reinterpret_cast<quintptr>(a) & 2) {
1021             // both addresses are not aligned to 4-bytes boundaries
1022             // compare the first character
1023             if (*a != *b)
1024                 return a->unicode() - b->unicode();
1025             --l;
1026             ++a;
1027             ++b;
1028 
1029             // now both addresses are 4-bytes aligned
1030         }
1031 
1032         // both addresses are 4-bytes aligned
1033         // do a fast 32-bit comparison
1034         const quint32 *da = reinterpret_cast<const quint32 *>(a);
1035         const quint32 *db = reinterpret_cast<const quint32 *>(b);
1036         const quint32 *e = da + (l >> 1);
1037         for ( ; da != e; ++da, ++db) {
1038             if (*da != *db) {
1039                 a = reinterpret_cast<const QChar *>(da);
1040                 b = reinterpret_cast<const QChar *>(db);
1041                 if (*a != *b)
1042                     return a->unicode() - b->unicode();
1043                 return a[1].unicode() - b[1].unicode();
1044             }
1045         }
1046 
1047         // do we have a tail?
1048         a = reinterpret_cast<const QChar *>(da);
1049         b = reinterpret_cast<const QChar *>(db);
1050         return (l & 1) ? a->unicode() - b->unicode() : 0;
1051     } else {
1052         // one of the addresses isn't 4-byte aligned but the other is
1053         const QChar *e = a + l;
1054         for ( ; a != e; ++a, ++b) {
1055             if (*a != *b)
1056                 return a->unicode() - b->unicode();
1057         }
1058     }
1059     return 0;
1060 #endif
1061 }
1062 
1063 static int ucstrncmp(const QChar *a, const uchar *c, size_t l)
1064 {
1065     const char16_t *uc = reinterpret_cast<const char16_t *>(a);
1066     const char16_t *e = uc + l;
1067 
1068 #ifdef __SSE2__
1069     __m128i nullmask = _mm_setzero_si128();
1070     qptrdiff offset = 0;
1071 
1072 #  if !defined(__OPTIMIZE_SIZE__)
1073     // Using the PMOVMSKB instruction, we get two bits for each character
1074     // we compare.
1075     int retval;
1076     auto isDifferent = [uc, c, &offset, &retval](__m128i a_data, __m128i b_data) {
1077         __m128i result = _mm_cmpeq_epi16(a_data, b_data);
1078         uint mask = ~uint(_mm_movemask_epi8(result));
1079         if (ushort(mask) == 0)
1080             return false;
1081         uint idx = qCountTrailingZeroBits(mask);
1082         retval = uc[offset + idx / 2] - c[offset + idx / 2];
1083         return true;
1084     };
1085 #  endif
1086 
1087     // we're going to read uc[offset..offset+15] (32 bytes)
1088     // and c[offset..offset+15] (16 bytes)
1089     for ( ; uc + offset + 15 < e; offset += 16) {
1090         // similar to fromLatin1_helper:
1091         // load 16 bytes of Latin 1 data
1092         __m128i chunk = _mm_loadu_si128((const __m128i*)(c + offset));
1093 
1094 #  ifdef __AVX2__
1095         // expand Latin 1 data via zero extension
1096         __m256i ldata = _mm256_cvtepu8_epi16(chunk);
1097 
1098         // load UTF-16 data and compare
1099         __m256i ucdata = _mm256_loadu_si256((const __m256i*)(uc + offset));
1100         __m256i result = _mm256_cmpeq_epi16(ldata, ucdata);
1101 
1102         uint mask = ~_mm256_movemask_epi8(result);
1103 #  else
1104         // expand via unpacking
1105         __m128i firstHalf = _mm_unpacklo_epi8(chunk, nullmask);
1106         __m128i secondHalf = _mm_unpackhi_epi8(chunk, nullmask);
1107 
1108         // load UTF-16 data and compare
1109         __m128i ucdata1 = _mm_loadu_si128((const __m128i*)(uc + offset));
1110         __m128i ucdata2 = _mm_loadu_si128((const __m128i*)(uc + offset + 8));
1111         __m128i result1 = _mm_cmpeq_epi16(firstHalf, ucdata1);
1112         __m128i result2 = _mm_cmpeq_epi16(secondHalf, ucdata2);
1113 
1114         uint mask = ~(_mm_movemask_epi8(result1) | _mm_movemask_epi8(result2) << 16);
1115 #  endif
1116         if (mask) {
1117             // found a different character
1118             uint idx = qCountTrailingZeroBits(mask);
1119             return uc[offset + idx / 2] - c[offset + idx / 2];
1120         }
1121     }
1122 
1123 #  if !defined(__OPTIMIZE_SIZE__)
1124     // we'll read uc[offset..offset+7] (16 bytes) and c[offset..offset+7] (8 bytes)
1125     if (uc + offset + 7 < e) {
1126         // same, but we're using an 8-byte load
1127         __m128i secondHalf = mm_load8_zero_extend(c + offset);
1128 
1129         __m128i ucdata = _mm_loadu_si128((const __m128i*)(uc + offset));
1130         if (isDifferent(ucdata, secondHalf))
1131             return retval;
1132 
1133         // still matched
1134         offset += 8;
1135     }
1136 
1137     enum { MaxTailLength = 3 };
1138     // we'll read uc[offset..offset+3] (8 bytes) and c[offset..offset+3] (4 bytes)
1139     if (uc + offset + 3 < e) {
1140         __m128i chunk = _mm_cvtsi32_si128(qFromUnaligned<int>(c + offset));
1141         __m128i secondHalf = _mm_unpacklo_epi8(chunk, nullmask);
1142 
1143         __m128i ucdata = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(uc + offset));
1144         if (isDifferent(ucdata, secondHalf))
1145             return retval;
1146 
1147         // still matched
1148         offset += 4;
1149     }
1150 #  endif // optimize size
1151 
1152     // reset uc and c
1153     uc += offset;
1154     c += offset;
1155 
1156 #  if !defined(__OPTIMIZE_SIZE__)
1157     const auto lambda = [=](size_t i) { return uc[i] - char16_t(c[i]); };
1158     return UnrollTailLoop<MaxTailLength>::exec(e - uc, 0, lambda, lambda);
1159 #  endif
1160 #endif
1161 
1162     while (uc < e) {
1163         int diff = *uc - *c;
1164         if (diff)
1165             return diff;
1166         uc++, c++;
1167     }
1168 
1169     return 0;
1170 }
1171 
1172 template <typename Number>
1173 Q_DECL_CONSTEXPR int lencmp(Number lhs, Number rhs) noexcept
1174 {
1175     return lhs == rhs ? 0 :
1176            lhs >  rhs ? 1 :
1177            /* else */  -1 ;
1178 }
1179 
1180 // Unicode case-sensitive comparison
1181 static int ucstrcmp(const QChar *a, size_t alen, const QChar *b, size_t blen)
1182 {
1183     if (a == b && alen == blen)
1184         return 0;
1185     const size_t l = qMin(alen, blen);
1186     int cmp = ucstrncmp(a, b, l);
1187     return cmp ? cmp : lencmp(alen, blen);
1188 }
1189 
1190 static int ucstrcmp(const QChar *a, size_t alen, const char *b, size_t blen)
1191 {
1192     const size_t l = qMin(alen, blen);
1193     const int cmp = ucstrncmp(a, reinterpret_cast<const uchar*>(b), l);
1194     return cmp ? cmp : lencmp(alen, blen);
1195 }
1196 
1197 static int latin1nicmp(const char *lhsChar, qsizetype lSize, const char *rhsChar, qsizetype rSize)
1198 {
1199     constexpr uchar latin1Lower[256] = {
1200         0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
1201         0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
1202         0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
1203         0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
1204         0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
1205         0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
1206         0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
1207         0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
1208         0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
1209         0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
1210         0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
1211         0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
1212         // 0xd7 (multiplication sign) and 0xdf (sz ligature) complicate life
1213         0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
1214         0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xd7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xdf,
1215         0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
1216         0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
1217     };
1218     // We're called with QLatin1String's .data() and .size():
1219     Q_ASSERT(lSize >= 0 && rSize >= 0);
1220     if (!lSize)
1221         return rSize ? -1 : 0;
1222     if (!rSize)
1223         return 1;
1224     const qsizetype size = std::min(lSize, rSize);
1225 
1226     const uchar *lhs = reinterpret_cast<const uchar *>(lhsChar);
1227     const uchar *rhs = reinterpret_cast<const uchar *>(rhsChar);
1228     Q_ASSERT(lhs && rhs); // since both lSize and rSize are positive
1229     for (qsizetype i = 0; i < size; i++) {
1230         Q_ASSERT(lhs[i] && rhs[i]);
1231         if (int res = latin1Lower[lhs[i]] - latin1Lower[rhs[i]])
1232             return res;
1233     }
1234     return lencmp(lSize, rSize);
1235 }
1236 
1237 static int qt_compare_strings(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1238 {
1239     if (cs == Qt::CaseSensitive)
1240         return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size());
1241     else
1242         return ucstricmp(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
1243 }
1244 
1245 static int qt_compare_strings(QStringView lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1246 {
1247     if (cs == Qt::CaseSensitive)
1248         return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size());
1249     else
1250         return ucstricmp(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
1251 }
1252 
1253 static int qt_compare_strings(QLatin1String lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1254 {
1255     return -qt_compare_strings(rhs, lhs, cs);
1256 }
1257 
1258 static int qt_compare_strings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1259 {
1260     if (lhs.isEmpty())
1261         return lencmp(0, rhs.size());
1262     if (cs == Qt::CaseInsensitive)
1263         return latin1nicmp(lhs.data(), lhs.size(), rhs.data(), rhs.size());
1264     const auto l = std::min(lhs.size(), rhs.size());
1265     int r = qstrncmp(lhs.data(), rhs.data(), l);
1266     return r ? r : lencmp(lhs.size(), rhs.size());
1267 }
1268 
1269 /*!
1270     \relates QStringView
1271     \internal
1272     \since 5.10
1273 
1274     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1275 
1276     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1277     otherwise the comparison is case-insensitive.
1278 
1279     Case-sensitive comparison is based exclusively on the numeric Unicode values
1280     of the characters and is very fast, but is not what a human would expect.
1281     Consider sorting user-visible strings with QString::localeAwareCompare().
1282 
1283     \sa {Comparing Strings}
1284 */
1285 int QtPrivate::compareStrings(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1286 {
1287     return qt_compare_strings(lhs, rhs, cs);
1288 }
1289 
1290 /*!
1291     \relates QStringView
1292     \internal
1293     \since 5.10
1294     \overload
1295 
1296     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1297 
1298     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1299     otherwise the comparison is case-insensitive.
1300 
1301     Case-sensitive comparison is based exclusively on the numeric Unicode values
1302     of the characters and is very fast, but is not what a human would expect.
1303     Consider sorting user-visible strings with QString::localeAwareCompare().
1304 
1305     \sa {Comparing Strings}
1306 */
1307 int QtPrivate::compareStrings(QStringView lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1308 {
1309     return qt_compare_strings(lhs, rhs, cs);
1310 }
1311 
1312 /*!
1313     \relates QStringView
1314     \internal
1315     \since 5.10
1316     \overload
1317 
1318     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1319 
1320     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1321     otherwise the comparison is case-insensitive.
1322 
1323     Case-sensitive comparison is based exclusively on the numeric Unicode values
1324     of the characters and is very fast, but is not what a human would expect.
1325     Consider sorting user-visible strings with QString::localeAwareCompare().
1326 
1327     \sa {Comparing Strings}
1328 */
1329 int QtPrivate::compareStrings(QLatin1String lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1330 {
1331     return qt_compare_strings(lhs, rhs, cs);
1332 }
1333 
1334 /*!
1335     \relates QStringView
1336     \internal
1337     \since 5.10
1338     \overload
1339 
1340     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1341 
1342     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1343     otherwise the comparison is case-insensitive.
1344 
1345     Case-sensitive comparison is based exclusively on the numeric Latin-1 values
1346     of the characters and is very fast, but is not what a human would expect.
1347     Consider sorting user-visible strings with QString::localeAwareCompare().
1348 
1349     \sa {Comparing Strings}
1350 */
1351 int QtPrivate::compareStrings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1352 {
1353     return qt_compare_strings(lhs, rhs, cs);
1354 }
1355 
1356 #define REHASH(a) \
1357     if (sl_minus_1 < sizeof(std::size_t) * CHAR_BIT)  \
1358         hashHaystack -= std::size_t(a) << sl_minus_1; \
1359     hashHaystack <<= 1
1360 
1361 inline bool qIsUpper(char ch)
1362 {
1363     return ch >= 'A' && ch <= 'Z';
1364 }
1365 
1366 inline bool qIsDigit(char ch)
1367 {
1368     return ch >= '0' && ch <= '9';
1369 }
1370 
1371 inline char qToLower(char ch)
1372 {
1373     if (ch >= 'A' && ch <= 'Z')
1374         return ch - 'A' + 'a';
1375     else
1376         return ch;
1377 }
1378 
1379 
1380 /*!
1381   \macro QT_RESTRICTED_CAST_FROM_ASCII
1382   \relates QString
1383 
1384   Defining this macro disables most automatic conversions from source
1385   literals and 8-bit data to unicode QStrings, but allows the use of
1386   the \c{QChar(char)} and \c{QString(const char (&ch)[N]} constructors,
1387   and the \c{QString::operator=(const char (&ch)[N])} assignment operator
1388   giving most of the type-safety benefits of \c QT_NO_CAST_FROM_ASCII
1389   but does not require user code to wrap character and string literals
1390   with QLatin1Char, QLatin1String or similar.
1391 
1392   Using this macro together with source strings outside the 7-bit range,
1393   non-literals, or literals with embedded NUL characters is undefined.
1394 
1395   \sa QT_NO_CAST_FROM_ASCII, QT_NO_CAST_TO_ASCII
1396 */
1397 
1398 /*!
1399   \macro QT_NO_CAST_FROM_ASCII
1400   \relates QString
1401 
1402   Disables automatic conversions from 8-bit strings (char *) to unicode QStrings
1403 
1404   \sa QT_NO_CAST_TO_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, QT_NO_CAST_FROM_BYTEARRAY
1405 */
1406 
1407 /*!
1408   \macro QT_NO_CAST_TO_ASCII
1409   \relates QString
1410 
1411   disables automatic conversion from QString to 8-bit strings (char *)
1412 
1413   \sa QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, QT_NO_CAST_FROM_BYTEARRAY
1414 */
1415 
1416 /*!
1417   \macro QT_ASCII_CAST_WARNINGS
1418   \internal
1419   \relates QString
1420 
1421   This macro can be defined to force a warning whenever a function is
1422   called that automatically converts between unicode and 8-bit encodings.
1423 
1424   Note: This only works for compilers that support warnings for
1425   deprecated API.
1426 
1427   \sa QT_NO_CAST_TO_ASCII, QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII
1428 */
1429 
1430 /*!
1431     \class QString
1432     \inmodule QtCore
1433     \reentrant
1434 
1435     \brief The QString class provides a Unicode character string.
1436 
1437     \ingroup tools
1438     \ingroup shared
1439     \ingroup string-processing
1440 
1441     QString stores a string of 16-bit \l{QChar}s, where each QChar
1442     corresponds to one UTF-16 code unit. (Unicode characters
1443     with code values above 65535 are stored using surrogate pairs,
1444     i.e., two consecutive \l{QChar}s.)
1445 
1446     \l{Unicode} is an international standard that supports most of the
1447     writing systems in use today. It is a superset of US-ASCII (ANSI
1448     X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1
1449     characters are available at the same code positions.
1450 
1451     Behind the scenes, QString uses \l{implicit sharing}
1452     (copy-on-write) to reduce memory usage and to avoid the needless
1453     copying of data. This also helps reduce the inherent overhead of
1454     storing 16-bit characters instead of 8-bit characters.
1455 
1456     In addition to QString, Qt also provides the QByteArray class to
1457     store raw bytes and traditional 8-bit '\\0'-terminated strings.
1458     For most purposes, QString is the class you want to use. It is
1459     used throughout the Qt API, and the Unicode support ensures that
1460     your applications will be easy to translate if you want to expand
1461     your application's market at some point. The two main cases where
1462     QByteArray is appropriate are when you need to store raw binary
1463     data, and when memory conservation is critical (like in embedded
1464     systems).
1465 
1466     \tableofcontents
1467 
1468     \section1 Initializing a String
1469 
1470     One way to initialize a QString is simply to pass a \c{const char
1471     *} to its constructor. For example, the following code creates a
1472     QString of size 5 containing the data "Hello":
1473 
1474     \snippet qstring/main.cpp 0
1475 
1476     QString converts the \c{const char *} data into Unicode using the
1477     fromUtf8() function.
1478 
1479     In all of the QString functions that take \c{const char *}
1480     parameters, the \c{const char *} is interpreted as a classic
1481     C-style '\\0'-terminated string encoded in UTF-8. It is legal for
1482     the \c{const char *} parameter to be \nullptr.
1483 
1484     You can also provide string data as an array of \l{QChar}s:
1485 
1486     \snippet qstring/main.cpp 1
1487 
1488     QString makes a deep copy of the QChar data, so you can modify it
1489     later without experiencing side effects. (If for performance
1490     reasons you don't want to take a deep copy of the character data,
1491     use QString::fromRawData() instead.)
1492 
1493     Another approach is to set the size of the string using resize()
1494     and to initialize the data character per character. QString uses
1495     0-based indexes, just like C++ arrays. To access the character at
1496     a particular index position, you can use \l operator[](). On
1497     non-const strings, \l operator[]() returns a reference to a
1498     character that can be used on the left side of an assignment. For
1499     example:
1500 
1501     \snippet qstring/main.cpp 2
1502 
1503     For read-only access, an alternative syntax is to use the at()
1504     function:
1505 
1506     \snippet qstring/main.cpp 3
1507 
1508     The at() function can be faster than \l operator[](), because it
1509     never causes a \l{deep copy} to occur. Alternatively, use the
1510     left(), right(), or mid() functions to extract several characters
1511     at a time.
1512 
1513     A QString can embed '\\0' characters (QChar::Null). The size()
1514     function always returns the size of the whole string, including
1515     embedded '\\0' characters.
1516 
1517     After a call to the resize() function, newly allocated characters
1518     have undefined values. To set all the characters in the string to
1519     a particular value, use the fill() function.
1520 
1521     QString provides dozens of overloads designed to simplify string
1522     usage. For example, if you want to compare a QString with a string
1523     literal, you can write code like this and it will work as expected:
1524 
1525     \snippet qstring/main.cpp 4
1526 
1527     You can also pass string literals to functions that take QStrings
1528     as arguments, invoking the QString(const char *)
1529     constructor. Similarly, you can pass a QString to a function that
1530     takes a \c{const char *} argument using the \l qPrintable() macro
1531     which returns the given QString as a \c{const char *}. This is
1532     equivalent to calling <QString>.toLocal8Bit().constData().
1533 
1534     \section1 Manipulating String Data
1535 
1536     QString provides the following basic functions for modifying the
1537     character data: append(), prepend(), insert(), replace(), and
1538     remove(). For example:
1539 
1540     \snippet qstring/main.cpp 5
1541 
1542     If you are building a QString gradually and know in advance
1543     approximately how many characters the QString will contain, you
1544     can call reserve(), asking QString to preallocate a certain amount
1545     of memory. You can also call capacity() to find out how much
1546     memory QString actually allocated.
1547 
1548     The replace() and remove() functions' first two arguments are the
1549     position from which to start erasing and the number of characters
1550     that should be erased.  If you want to replace all occurrences of
1551     a particular substring with another, use one of the two-parameter
1552     replace() overloads.
1553 
1554     A frequent requirement is to remove whitespace characters from a
1555     string ('\\n', '\\t', ' ', etc.). If you want to remove whitespace
1556     from both ends of a QString, use the trimmed() function. If you
1557     want to remove whitespace from both ends and replace multiple
1558     consecutive whitespaces with a single space character within the
1559     string, use simplified().
1560 
1561     If you want to find all occurrences of a particular character or
1562     substring in a QString, use the indexOf() or lastIndexOf()
1563     functions. The former searches forward starting from a given index
1564     position, the latter searches backward. Both return the index
1565     position of the character or substring if they find it; otherwise,
1566     they return -1.  For example, here is a typical loop that finds all
1567     occurrences of a particular substring:
1568 
1569     \snippet qstring/main.cpp 6
1570 
1571     QString provides many functions for converting numbers into
1572     strings and strings into numbers. See the arg() functions, the
1573     setNum() functions, the number() static functions, and the
1574     toInt(), toDouble(), and similar functions.
1575 
1576     To get an upper- or lowercase version of a string use toUpper() or
1577     toLower().
1578 
1579     Lists of strings are handled by the QStringList class. You can
1580     split a string into a list of strings using the split() function,
1581     and join a list of strings into a single string with an optional
1582     separator using QStringList::join(). You can obtain a list of
1583     strings from a string list that contain a particular substring or
1584     that match a particular QRegularExpression using the QStringList::filter()
1585     function.
1586 
1587     \section1 Querying String Data
1588 
1589     If you want to see if a QString starts or ends with a particular
1590     substring use startsWith() or endsWith(). If you simply want to
1591     check whether a QString contains a particular character or
1592     substring, use the contains() function. If you want to find out
1593     how many times a particular character or substring occurs in the
1594     string, use count().
1595 
1596     To obtain a pointer to the actual character data, call data() or
1597     constData(). These functions return a pointer to the beginning of
1598     the QChar data. The pointer is guaranteed to remain valid until a
1599     non-const function is called on the QString.
1600 
1601     \section2 Comparing Strings
1602 
1603     QStrings can be compared using overloaded operators such as \l
1604     operator<(), \l operator<=(), \l operator==(), \l operator>=(),
1605     and so on.  Note that the comparison is based exclusively on the
1606     numeric Unicode values of the characters. It is very fast, but is
1607     not what a human would expect; the QString::localeAwareCompare()
1608     function is usually a better choice for sorting user-interface
1609     strings, when such a comparison is available.
1610 
1611     On Unix-like platforms (including Linux, \macos and iOS), when Qt
1612     is linked with the ICU library (which it usually is), its
1613     locale-aware sorting is used.  Otherwise, on \macos and iOS, \l
1614     localeAwareCompare() compares according the "Order for sorted
1615     lists" setting in the International preferences panel. On other
1616     Unix-like systems without ICU, the comparison falls back to the
1617     system library's \c strcoll(), falling back when it considers
1618     strings equal to QString's (locale-unaware) comparison, described
1619     above,
1620 
1621     \section1 Converting Between encoded strings data and QString
1622 
1623     QString provides the following three functions that return a
1624     \c{const char *} version of the string as QByteArray: toUtf8(),
1625     toLatin1(), and toLocal8Bit().
1626 
1627     \list
1628     \li toLatin1() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.
1629     \li toUtf8() returns a UTF-8 encoded 8-bit string. UTF-8 is a
1630        superset of US-ASCII (ANSI X3.4-1986) that supports the entire
1631        Unicode character set through multibyte sequences.
1632     \li toLocal8Bit() returns an 8-bit string using the system's local
1633        encoding. This is the same as toUtf8() on Unix systems.
1634     \endlist
1635 
1636     To convert from one of these encodings, QString provides
1637     fromLatin1(), fromUtf8(), and fromLocal8Bit(). Other
1638     encodings are supported through the QStringEncoder and QStringDecoder
1639     classes.
1640 
1641     As mentioned above, QString provides a lot of functions and
1642     operators that make it easy to interoperate with \c{const char *}
1643     strings. But this functionality is a double-edged sword: It makes
1644     QString more convenient to use if all strings are US-ASCII or
1645     Latin-1, but there is always the risk that an implicit conversion
1646     from or to \c{const char *} is done using the wrong 8-bit
1647     encoding. To minimize these risks, you can turn off these implicit
1648     conversions by defining the following two preprocessor symbols:
1649 
1650     \list
1651     \li \c QT_NO_CAST_FROM_ASCII disables automatic conversions from
1652        C string literals and pointers to Unicode.
1653     \li \c QT_RESTRICTED_CAST_FROM_ASCII allows automatic conversions
1654        from C characters and character arrays, but disables automatic
1655        conversions from character pointers to Unicode.
1656     \li \c QT_NO_CAST_TO_ASCII disables automatic conversion from QString
1657        to C strings.
1658     \endlist
1659 
1660     One way to define these preprocessor symbols globally for your
1661     application is to add the following entry to your \l {Creating Project Files}{qmake project file}:
1662 
1663     \snippet code/src_corelib_text_qstring.cpp 0
1664 
1665     You then need to explicitly call fromUtf8(), fromLatin1(),
1666     or fromLocal8Bit() to construct a QString from an
1667     8-bit string, or use the lightweight QLatin1String class, for
1668     example:
1669 
1670     \snippet code/src_corelib_text_qstring.cpp 1
1671 
1672     Similarly, you must call toLatin1(), toUtf8(), or
1673     toLocal8Bit() explicitly to convert the QString to an 8-bit
1674     string.
1675 
1676     \table 100 %
1677     \header
1678     \li Note for C Programmers
1679 
1680     \row
1681     \li
1682     Due to C++'s type system and the fact that QString is
1683     \l{implicitly shared}, QStrings may be treated like \c{int}s or
1684     other basic types. For example:
1685 
1686     \snippet qstring/main.cpp 7
1687 
1688     The \c result variable, is a normal variable allocated on the
1689     stack. When \c return is called, and because we're returning by
1690     value, the copy constructor is called and a copy of the string is
1691     returned. No actual copying takes place thanks to the implicit
1692     sharing.
1693 
1694     \endtable
1695 
1696     \section1 Distinction Between Null and Empty Strings
1697 
1698     For historical reasons, QString distinguishes between a null
1699     string and an empty string. A \e null string is a string that is
1700     initialized using QString's default constructor or by passing
1701     (const char *)0 to the constructor. An \e empty string is any
1702     string with size 0. A null string is always empty, but an empty
1703     string isn't necessarily null:
1704 
1705     \snippet qstring/main.cpp 8
1706 
1707     All functions except isNull() treat null strings the same as empty
1708     strings. For example, toUtf8().constData() returns a valid pointer
1709     (\e not nullptr) to a '\\0' character for a null string. We
1710     recommend that you always use the isEmpty() function and avoid isNull().
1711 
1712     \section1 Argument Formats
1713 
1714     In member functions where an argument \e format can be specified
1715     (e.g., arg(), number()), the argument \e format can be one of the
1716     following:
1717 
1718     \table
1719     \header \li Format \li Meaning
1720     \row \li \c e \li format as [-]9.9e[+|-]999
1721     \row \li \c E \li format as [-]9.9E[+|-]999
1722     \row \li \c f \li format as [-]9.9
1723     \row \li \c g \li use \c e or \c f format, whichever is the most concise
1724     \row \li \c G \li use \c E or \c f format, whichever is the most concise
1725     \endtable
1726 
1727     A \e precision is also specified with the argument \e format. For
1728     the 'e', 'E', and 'f' formats, the \e precision represents the
1729     number of digits \e after the decimal point. For the 'g' and 'G'
1730     formats, the \e precision represents the maximum number of
1731     significant digits (trailing zeroes are omitted).
1732 
1733     \section1 More Efficient String Construction
1734 
1735     Many strings are known at compile time. But the trivial
1736     constructor QString("Hello"), will copy the contents of the string,
1737     treating the contents as Latin-1. To avoid this one can use the
1738     QStringLiteral macro to directly create the required data at compile
1739     time. Constructing a QString out of the literal does then not cause
1740     any overhead at runtime.
1741 
1742     A slightly less efficient way is to use QLatin1String. This class wraps
1743     a C string literal, precalculates it length at compile time and can
1744     then be used for faster comparison with QStrings and conversion to
1745     QStrings than a regular C string literal.
1746 
1747     Using the QString \c{'+'} operator, it is easy to construct a
1748     complex string from multiple substrings. You will often write code
1749     like this:
1750 
1751     \snippet qstring/stringbuilder.cpp 0
1752 
1753     There is nothing wrong with either of these string constructions,
1754     but there are a few hidden inefficiencies. Beginning with Qt 4.6,
1755     you can eliminate them.
1756 
1757     First, multiple uses of the \c{'+'} operator usually means
1758     multiple memory allocations. When concatenating \e{n} substrings,
1759     where \e{n > 2}, there can be as many as \e{n - 1} calls to the
1760     memory allocator.
1761 
1762     In 4.6, an internal template class \c{QStringBuilder} has been
1763     added along with a few helper functions. This class is marked
1764     internal and does not appear in the documentation, because you
1765     aren't meant to instantiate it in your code. Its use will be
1766     automatic, as described below. The class is found in
1767     \c {src/corelib/tools/qstringbuilder.cpp} if you want to have a
1768     look at it.
1769 
1770     \c{QStringBuilder} uses expression templates and reimplements the
1771     \c{'%'} operator so that when you use \c{'%'} for string
1772     concatenation instead of \c{'+'}, multiple substring
1773     concatenations will be postponed until the final result is about
1774     to be assigned to a QString. At this point, the amount of memory
1775     required for the final result is known. The memory allocator is
1776     then called \e{once} to get the required space, and the substrings
1777     are copied into it one by one.
1778 
1779     Additional efficiency is gained by inlining and reduced reference
1780     counting (the QString created from a \c{QStringBuilder} typically
1781     has a ref count of 1, whereas QString::append() needs an extra
1782     test).
1783 
1784     There are two ways you can access this improved method of string
1785     construction. The straightforward way is to include
1786     \c{QStringBuilder} wherever you want to use it, and use the
1787     \c{'%'} operator instead of \c{'+'} when concatenating strings:
1788 
1789     \snippet qstring/stringbuilder.cpp 5
1790 
1791     A more global approach which is the most convenient but
1792     not entirely source compatible, is to this define in your
1793     .pro file:
1794 
1795     \snippet qstring/stringbuilder.cpp 3
1796 
1797     and the \c{'+'} will automatically be performed as the
1798     \c{QStringBuilder} \c{'%'} everywhere.
1799 
1800     \section1 Maximum size and out-of-memory conditions
1801 
1802     In case memory allocation fails, QString will throw a \c std::bad_alloc
1803     exception. Out of memory conditions in the Qt containers are the only case
1804     where Qt will throw exceptions.
1805 
1806     Note that the operating system may impose further limits on applications
1807     holding a lot of allocated memory, especially large, contiguous blocks.
1808     Such considerations, the configuration of such behavior or any mitigation
1809     are outside the scope of the Qt API.
1810 
1811     \sa fromRawData(), QChar, QLatin1String, QByteArray, QStringRef
1812 */
1813 
1814 /*! \typedef QString::ConstIterator
1815 
1816     Qt-style synonym for QString::const_iterator.
1817 */
1818 
1819 /*! \typedef QString::Iterator
1820 
1821     Qt-style synonym for QString::iterator.
1822 */
1823 
1824 /*! \typedef QString::const_iterator
1825 
1826     \sa QString::iterator
1827 */
1828 
1829 /*! \typedef QString::iterator
1830 
1831     \sa QString::const_iterator
1832 */
1833 
1834 /*! \typedef QString::const_reverse_iterator
1835     \since 5.6
1836 
1837     \sa QString::reverse_iterator, QString::const_iterator
1838 */
1839 
1840 /*! \typedef QString::reverse_iterator
1841     \since 5.6
1842 
1843     \sa QString::const_reverse_iterator, QString::iterator
1844 */
1845 
1846 /*!
1847     \typedef QString::size_type
1848 */
1849 
1850 /*!
1851     \typedef QString::difference_type
1852 */
1853 
1854 /*!
1855     \typedef QString::const_reference
1856 */
1857 /*!
1858     \typedef QString::reference
1859 */
1860 
1861 /*!
1862     \typedef QString::const_pointer
1863 
1864     The QString::const_pointer typedef provides an STL-style
1865     const pointer to a QString element (QChar).
1866 */
1867 /*!
1868     \typedef QString::pointer
1869 
1870     The QString::const_pointer typedef provides an STL-style
1871     pointer to a QString element (QChar).
1872 */
1873 
1874 /*!
1875     \typedef QString::value_type
1876 */
1877 
1878 /*! \fn QString::iterator QString::begin()
1879 
1880     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first character in
1881     the string.
1882 
1883     \sa constBegin(), end()
1884 */
1885 
1886 /*! \fn QString::const_iterator QString::begin() const
1887 
1888     \overload begin()
1889 */
1890 
1891 /*! \fn QString::const_iterator QString::cbegin() const
1892     \since 5.0
1893 
1894     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character
1895     in the string.
1896 
1897     \sa begin(), cend()
1898 */
1899 
1900 /*! \fn QString::const_iterator QString::constBegin() const
1901 
1902     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character
1903     in the string.
1904 
1905     \sa begin(), constEnd()
1906 */
1907 
1908 /*! \fn QString::iterator QString::end()
1909 
1910     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary character
1911     after the last character in the string.
1912 
1913     \sa begin(), constEnd()
1914 */
1915 
1916 /*! \fn QString::const_iterator QString::end() const
1917 
1918     \overload end()
1919 */
1920 
1921 /*! \fn QString::const_iterator QString::cend() const
1922     \since 5.0
1923 
1924     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1925     character after the last character in the list.
1926 
1927     \sa cbegin(), end()
1928 */
1929 
1930 /*! \fn QString::const_iterator QString::constEnd() const
1931 
1932     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1933     character after the last character in the list.
1934 
1935     \sa constBegin(), end()
1936 */
1937 
1938 /*! \fn QString::reverse_iterator QString::rbegin()
1939     \since 5.6
1940 
1941     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
1942     character in the string, in reverse order.
1943 
1944     \sa begin(), crbegin(), rend()
1945 */
1946 
1947 /*! \fn QString::const_reverse_iterator QString::rbegin() const
1948     \since 5.6
1949     \overload
1950 */
1951 
1952 /*! \fn QString::const_reverse_iterator QString::crbegin() const
1953     \since 5.6
1954 
1955     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
1956     character in the string, in reverse order.
1957 
1958     \sa begin(), rbegin(), rend()
1959 */
1960 
1961 /*! \fn QString::reverse_iterator QString::rend()
1962     \since 5.6
1963 
1964     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past
1965     the last character in the string, in reverse order.
1966 
1967     \sa end(), crend(), rbegin()
1968 */
1969 
1970 /*! \fn QString::const_reverse_iterator QString::rend() const
1971     \since 5.6
1972     \overload
1973 */
1974 
1975 /*! \fn QString::const_reverse_iterator QString::crend() const
1976     \since 5.6
1977 
1978     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to one
1979     past the last character in the string, in reverse order.
1980 
1981     \sa end(), rend(), rbegin()
1982 */
1983 
1984 /*!
1985     \fn QString::QString()
1986 
1987     Constructs a null string. Null strings are also empty.
1988 
1989     \sa isEmpty()
1990 */
1991 
1992 /*!
1993     \fn QString::QString(QString &&other)
1994 
1995     Move-constructs a QString instance, making it point at the same
1996     object that \a other was pointing to.
1997 
1998     \since 5.2
1999 */
2000 
2001 /*! \fn QString::QString(const char *str)
2002 
2003     Constructs a string initialized with the 8-bit string \a str. The
2004     given const char pointer is converted to Unicode using the
2005     fromUtf8() function.
2006 
2007     You can disable this constructor by defining \c
2008     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2009     can be useful if you want to ensure that all user-visible strings
2010     go through QObject::tr(), for example.
2011 
2012     \note Defining \c QT_RESTRICTED_CAST_FROM_ASCII also disables
2013     this constructor, but enables a \c{QString(const char (&ch)[N])}
2014     constructor instead. Using non-literal input, or input with
2015     embedded NUL characters, or non-7-bit characters is undefined
2016     in this case.
2017 
2018     \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII
2019 */
2020 
2021 /*! \fn QString QString::fromStdString(const std::string &str)
2022 
2023     Returns a copy of the \a str string. The given string is converted
2024     to Unicode using the fromUtf8() function.
2025 
2026     \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QByteArray::fromStdString()
2027 */
2028 
2029 /*! \fn QString QString::fromStdWString(const std::wstring &str)
2030 
2031     Returns a copy of the \a str string. The given string is assumed
2032     to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g. on
2033     windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix
2034     systems).
2035 
2036     \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), fromStdU16String(), fromStdU32String()
2037 */
2038 
2039 /*! \fn QString QString::fromWCharArray(const wchar_t *string, qsizetype size)
2040     \since 4.2
2041 
2042     Returns a copy of the \a string, where the encoding of \a string depends on
2043     the size of wchar. If wchar is 4 bytes, the \a string is interpreted as UCS-4,
2044     if wchar is 2 bytes it is interpreted as UTF-16.
2045 
2046     If \a size is -1 (default), the \a string has to be \\0'-terminated.
2047 
2048     \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), fromStdWString()
2049 */
2050 
2051 /*! \fn std::wstring QString::toStdWString() const
2052 
2053     Returns a std::wstring object with the data contained in this
2054     QString. The std::wstring is encoded in utf16 on platforms where
2055     wchar_t is 2 bytes wide (e.g. windows) and in ucs4 on platforms
2056     where wchar_t is 4 bytes wide (most Unix systems).
2057 
2058     This method is mostly useful to pass a QString to a function
2059     that accepts a std::wstring object.
2060 
2061     \sa utf16(), toLatin1(), toUtf8(), toLocal8Bit(), toStdU16String(), toStdU32String()
2062 */
2063 
2064 qsizetype QString::toUcs4_helper(const ushort *uc, qsizetype length, uint *out)
2065 {
2066     qsizetype count = 0;
2067 
2068     QStringIterator i(QStringView(uc, length));
2069     while (i.hasNext())
2070         out[count++] = i.next();
2071 
2072     return count;
2073 }
2074 
2075 /*! \fn QString::toWCharArray(wchar_t *array) const
2076   \since 4.2
2077 
2078   Fills the \a array with the data contained in this QString object.
2079   The array is encoded in UTF-16 on platforms where
2080   wchar_t is 2 bytes wide (e.g. windows) and in UCS-4 on platforms
2081   where wchar_t is 4 bytes wide (most Unix systems).
2082 
2083   \a array has to be allocated by the caller and contain enough space to
2084   hold the complete string (allocating the array with the same length as the
2085   string is always sufficient).
2086 
2087   This function returns the actual length of the string in \a array.
2088 
2089   \note This function does not append a null character to the array.
2090 
2091   \sa utf16(), toUcs4(), toLatin1(), toUtf8(), toLocal8Bit(), toStdWString(), QStringView::toWCharArray()
2092 */
2093 
2094 /*! \fn QString::QString(const QString &other)
2095 
2096     Constructs a copy of \a other.
2097 
2098     This operation takes \l{constant time}, because QString is
2099     \l{implicitly shared}. This makes returning a QString from a
2100     function very fast. If a shared instance is modified, it will be
2101     copied (copy-on-write), and that takes \l{linear time}.
2102 
2103     \sa operator=()
2104 */
2105 
2106 /*!
2107     Constructs a string initialized with the first \a size characters
2108     of the QChar array \a unicode.
2109 
2110     If \a unicode is 0, a null string is constructed.
2111 
2112     If \a size is negative, \a unicode is assumed to point to a \\0'-terminated
2113     array and its length is determined dynamically. The terminating
2114     null character is not considered part of the string.
2115 
2116     QString makes a deep copy of the string data. The unicode data is copied as
2117     is and the Byte Order Mark is preserved if present.
2118 
2119     \sa fromRawData()
2120 */
2121 QString::QString(const QChar *unicode, qsizetype size)
2122 {
2123     if (!unicode) {
2124         d.clear();
2125     } else {
2126         if (size < 0) {
2127             size = 0;
2128             while (!unicode[size].isNull())
2129                 ++size;
2130         }
2131         if (!size) {
2132             d = DataPointer::fromRawData(&_empty, 0);
2133         } else {
2134             d = DataPointer(Data::allocate(size + 1), size);
2135             memcpy(d.data(), unicode, size * sizeof(QChar));
2136             d.data()[size] = '\0';
2137         }
2138     }
2139 }
2140 
2141 /*!
2142     Constructs a string of the given \a size with every character set
2143     to \a ch.
2144 
2145     \sa fill()
2146 */
2147 QString::QString(qsizetype size, QChar ch)
2148 {
2149     if (size <= 0) {
2150         d = DataPointer::fromRawData(&_empty, 0);
2151     } else {
2152         d = DataPointer(Data::allocate(size + 1), size);
2153         d.data()[size] = '\0';
2154         char16_t *i = d.data() + size;
2155         char16_t *b = d.data();
2156         const char16_t value = ch.unicode();
2157         while (i != b)
2158            *--i = value;
2159     }
2160 }
2161 
2162 /*! \fn QString::QString(qsizetype size, Qt::Initialization)
2163   \internal
2164 
2165   Constructs a string of the given \a size without initializing the
2166   characters. This is only used in \c QStringBuilder::toString().
2167 */
2168 QString::QString(qsizetype size, Qt::Initialization)
2169 {
2170     d = DataPointer(Data::allocate(size + 1), size);
2171     d.data()[size] = '\0';
2172 }
2173 
2174 /*! \fn QString::QString(QLatin1String str)
2175 
2176     Constructs a copy of the Latin-1 string \a str.
2177 
2178     \sa fromLatin1()
2179 */
2180 
2181 /*!
2182     Constructs a string of size 1 containing the character \a ch.
2183 */
2184 QString::QString(QChar ch)
2185 {
2186     d = DataPointer(Data::allocate(2), 1);
2187     d.data()[0] = ch.unicode();
2188     d.data()[1] = '\0';
2189 }
2190 
2191 /*! \fn QString::QString(const QByteArray &ba)
2192 
2193     Constructs a string initialized with the byte array \a ba. The
2194     given byte array is converted to Unicode using fromUtf8(). Stops
2195     copying at the first 0 character, otherwise copies the entire byte
2196     array.
2197 
2198     You can disable this constructor by defining \c
2199     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2200     can be useful if you want to ensure that all user-visible strings
2201     go through QObject::tr(), for example.
2202 
2203     \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QT_NO_CAST_FROM_ASCII
2204 */
2205 
2206 /*! \fn QString::QString(const Null &)
2207     \internal
2208 */
2209 
2210 /*! \fn QString::QString(QStringPrivate)
2211     \internal
2212 */
2213 
2214 /*! \fn QString &QString::operator=(const QString::Null &)
2215     \internal
2216 */
2217 
2218 /*!
2219   \fn QString::~QString()
2220 
2221     Destroys the string.
2222 */
2223 
2224 
2225 /*! \fn void QString::swap(QString &other)
2226     \since 4.8
2227 
2228     Swaps string \a other with this string. This operation is very fast and
2229     never fails.
2230 */
2231 
2232 /*! \fn void QString::detach()
2233 
2234     \internal
2235 */
2236 
2237 /*! \fn bool QString::isDetached() const
2238 
2239     \internal
2240 */
2241 
2242 /*! \fn bool QString::isSharedWith(const QString &other) const
2243 
2244     \internal
2245 */
2246 
2247 /*!
2248     Sets the size of the string to \a size characters.
2249 
2250     If \a size is greater than the current size, the string is
2251     extended to make it \a size characters long with the extra
2252     characters added to the end. The new characters are uninitialized.
2253 
2254     If \a size is less than the current size, characters are removed
2255     from the end.
2256 
2257     Example:
2258 
2259     \snippet qstring/main.cpp 45
2260 
2261     If you want to append a certain number of identical characters to
2262     the string, use the \l {QString::}{resize(int, QChar)} overload.
2263 
2264     If you want to expand the string so that it reaches a certain
2265     width and fill the new positions with a particular character, use
2266     the leftJustified() function:
2267 
2268     If \a size is negative, it is equivalent to passing zero.
2269 
2270     \snippet qstring/main.cpp 47
2271 
2272     \sa truncate(), reserve()
2273 */
2274 
2275 void QString::resize(qsizetype size)
2276 {
2277     if (size < 0)
2278         size = 0;
2279 
2280     if (d->needsDetach() || size > capacity())
2281         reallocData(size_t(size) + 1u, true);
2282     d.size = size;
2283     if (d->allocatedCapacity())
2284         d.data()[size] = 0;
2285 }
2286 
2287 /*!
2288     \overload
2289     \since 5.7
2290 
2291     Unlike \l {QString::}{resize(int)}, this overload
2292     initializes the new characters to \a fillChar:
2293 
2294     \snippet qstring/main.cpp 46
2295 */
2296 
2297 void QString::resize(qsizetype size, QChar fillChar)
2298 {
2299     const qsizetype oldSize = length();
2300     resize(size);
2301     const qsizetype difference = length() - oldSize;
2302     if (difference > 0)
2303         std::fill_n(d.data() + oldSize, difference, fillChar.unicode());
2304 }
2305 
2306 /*! \fn qsizetype QString::capacity() const
2307 
2308     Returns the maximum number of characters that can be stored in
2309     the string without forcing a reallocation.
2310 
2311     The sole purpose of this function is to provide a means of fine
2312     tuning QString's memory usage. In general, you will rarely ever
2313     need to call this function. If you want to know how many
2314     characters are in the string, call size().
2315 
2316     \note a statically allocated string will report a capacity of 0,
2317     even if it's not empty.
2318 
2319     \sa reserve(), squeeze()
2320 */
2321 
2322 /*!
2323     \fn void QString::reserve(qsizetype size)
2324 
2325     Attempts to allocate memory for at least \a size characters. If
2326     you know in advance how large the string will be, you can call
2327     this function, and if you resize the string often you are likely
2328     to get better performance. If \a size is an underestimate, the
2329     worst that will happen is that the QString will be a bit slower.
2330 
2331     The sole purpose of this function is to provide a means of fine
2332     tuning QString's memory usage. In general, you will rarely ever
2333     need to call this function. If you want to change the size of the
2334     string, call resize().
2335 
2336     This function is useful for code that needs to build up a long
2337     string and wants to avoid repeated reallocation. In this example,
2338     we want to add to the string until some condition is \c true, and
2339     we're fairly sure that size is large enough to make a call to
2340     reserve() worthwhile:
2341 
2342     \snippet qstring/main.cpp 44
2343 
2344     \sa squeeze(), capacity()
2345 */
2346 
2347 /*!
2348     \fn void QString::squeeze()
2349 
2350     Releases any memory not required to store the character data.
2351 
2352     The sole purpose of this function is to provide a means of fine
2353     tuning QString's memory usage. In general, you will rarely ever
2354     need to call this function.
2355 
2356     \sa reserve(), capacity()
2357 */
2358 
2359 void QString::reallocData(size_t alloc, bool grow)
2360 {
2361     auto allocOptions = d->detachFlags();
2362     if (grow)
2363         allocOptions |= QArrayData::GrowsForward;
2364 
2365     if (d->needsDetach()) {
2366         DataPointer dd(Data::allocate(alloc, allocOptions), qMin(qsizetype(alloc) - 1, d.size));
2367         ::memcpy(dd.data(), d.data(), dd.size * sizeof(QChar));
2368         dd.data()[dd.size] = 0;
2369         d = dd;
2370     } else {
2371         d->reallocate(alloc, allocOptions);
2372     }
2373 }
2374 
2375 /*! \fn void QString::clear()
2376 
2377     Clears the contents of the string and makes it null.
2378 
2379     \sa resize(), isNull()
2380 */
2381 
2382 /*! \fn QString &QString::operator=(const QString &other)
2383 
2384     Assigns \a other to this string and returns a reference to this
2385     string.
2386 */
2387 
2388 QString &QString::operator=(const QString &other) noexcept
2389 {
2390     d = other.d;
2391     return *this;
2392 }
2393 
2394 /*!
2395     \fn QString &QString::operator=(QString &&other)
2396 
2397     Move-assigns \a other to this QString instance.
2398 
2399     \since 5.2
2400 */
2401 
2402 /*! \fn QString &QString::operator=(QLatin1String str)
2403 
2404     \overload operator=()
2405 
2406     Assigns the Latin-1 string \a str to this string.
2407 */
2408 QString &QString::operator=(QLatin1String other)
2409 {
2410     if (isDetached() && other.size() <= capacity()) { // assumes d->alloc == 0 -> !isDetached() (sharedNull)
2411         d.size = other.size();
2412         d.data()[other.size()] = 0;
2413         qt_from_latin1(d.data(), other.latin1(), other.size());
2414     } else {
2415         *this = fromLatin1(other.latin1(), other.size());
2416     }
2417     return *this;
2418 }
2419 
2420 /*! \fn QString &QString::operator=(const QByteArray &ba)
2421 
2422     \overload operator=()
2423 
2424     Assigns \a ba to this string. The byte array is converted to Unicode
2425     using the fromUtf8() function. This function stops conversion at the
2426     first NUL character found, or the end of the \a ba byte array.
2427 
2428     You can disable this operator by defining \c
2429     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2430     can be useful if you want to ensure that all user-visible strings
2431     go through QObject::tr(), for example.
2432 
2433     \sa QT_NO_CAST_FROM_ASCII
2434 */
2435 
2436 /*! \fn QString &QString::operator=(const char *str)
2437 
2438     \overload operator=()
2439 
2440     Assigns \a str to this string. The const char pointer is converted
2441     to Unicode using the fromUtf8() function.
2442 
2443     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
2444     or \c QT_RESTRICTED_CAST_FROM_ASCII when you compile your applications.
2445     This can be useful if you want to ensure that all user-visible strings
2446     go through QObject::tr(), for example.
2447 
2448     \sa QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII
2449 */
2450 
2451 /*!
2452     \overload operator=()
2453 
2454     Sets the string to contain the single character \a ch.
2455 */
2456 QString &QString::operator=(QChar ch)
2457 {
2458     if (isDetached() && capacity() >= 1) { // assumes d->alloc == 0 -> !isDetached() (sharedNull)
2459         // re-use existing capacity:
2460         d.data()[0] = ch.unicode();
2461         d.data()[1] = 0;
2462         d.size = 1;
2463     } else {
2464         operator=(QString(ch));
2465     }
2466     return *this;
2467 }
2468 
2469 /*!
2470      \fn QString& QString::insert(qsizetype position, const QString &str)
2471 
2472     Inserts the string \a str at the given index \a position and
2473     returns a reference to this string.
2474 
2475     Example:
2476 
2477     \snippet qstring/main.cpp 26
2478 
2479     If the given \a position is greater than size(), the array is
2480     first extended using resize().
2481 
2482     \sa append(), prepend(), replace(), remove()
2483 */
2484 
2485 /*!
2486     \fn QString& QString::insert(qsizetype position, QStringView str)
2487     \since 6.0
2488     \overload insert()
2489 
2490     Inserts the string view \a str at the given index \a position and
2491     returns a reference to this string.
2492 
2493     If the given \a position is greater than size(), the array is
2494     first extended using resize().
2495 */
2496 
2497 
2498 /*!
2499     \fn QString& QString::insert(qsizetype position, const char *str)
2500     \since 5.5
2501     \overload insert()
2502 
2503     Inserts the C string \a str at the given index \a position and
2504     returns a reference to this string.
2505 
2506     If the given \a position is greater than size(), the array is
2507     first extended using resize().
2508 
2509     This function is not available when \c QT_NO_CAST_FROM_ASCII is
2510     defined.
2511 
2512     \sa QT_NO_CAST_FROM_ASCII
2513 */
2514 
2515 
2516 /*!
2517     \fn QString& QString::insert(qsizetype position, const QByteArray &str)
2518     \since 5.5
2519     \overload insert()
2520 
2521     Inserts the byte array \a str at the given index \a position and
2522     returns a reference to this string.
2523 
2524     If the given \a position is greater than size(), the array is
2525     first extended using resize().
2526 
2527     This function is not available when \c QT_NO_CAST_FROM_ASCII is
2528     defined.
2529 
2530     \sa QT_NO_CAST_FROM_ASCII
2531 */
2532 
2533 
2534 /*!
2535     \fn QString &QString::insert(qsizetype position, QLatin1String str)
2536     \overload insert()
2537 
2538     Inserts the Latin-1 string \a str at the given index \a position.
2539 */
2540 QString &QString::insert(qsizetype i, QLatin1String str)
2541 {
2542     const char *s = str.latin1();
2543     if (i < 0 || !s || !(*s))
2544         return *this;
2545 
2546     qsizetype len = str.size();
2547     if (Q_UNLIKELY(i > size()))
2548         resize(i + len, QLatin1Char(' '));
2549     else
2550         resize(size() + len);
2551 
2552     ::memmove(d.data() + i + len, d.data() + i, (d.size - i - len) * sizeof(QChar));
2553     qt_from_latin1(d.data() + i, s, size_t(len));
2554     return *this;
2555 }
2556 
2557 /*!
2558     \fn QString& QString::insert(qsizetype position, const QChar *unicode, qsizetype size)
2559     \overload insert()
2560 
2561     Inserts the first \a size characters of the QChar array \a unicode
2562     at the given index \a position in the string.
2563 */
2564 QString& QString::insert(qsizetype i, const QChar *unicode, qsizetype size)
2565 {
2566     if (i < 0 || size <= 0)
2567         return *this;
2568 
2569     const auto s = reinterpret_cast<const char16_t *>(unicode);
2570     if (points_into_range(s, d.data(), d.data() + d.size))
2571         return insert(i, QStringView{QVarLengthArray(s, s + size)});
2572 
2573     if (Q_UNLIKELY(i > d.size))
2574         resize(i + size, QLatin1Char(' '));
2575     else
2576         resize(d.size + size);
2577 
2578     ::memmove(d.data() + i + size, d.data() + i, (d.size - i - size) * sizeof(QChar));
2579     memcpy(d.data() + i, s, size * sizeof(QChar));
2580     return *this;
2581 }
2582 
2583 /*!
2584     \fn QString& QString::insert(qsizetype position, QChar ch)
2585     \overload insert()
2586 
2587     Inserts \a ch at the given index \a position in the string.
2588 */
2589 
2590 QString& QString::insert(qsizetype i, QChar ch)
2591 {
2592     if (i < 0)
2593         i += d.size;
2594     if (i < 0)
2595         return *this;
2596     if (Q_UNLIKELY(i > size()))
2597         resize(i + 1, QLatin1Char(' '));
2598     else
2599         resize(d.size + 1);
2600     ::memmove(d.data() + i + 1, d.data() + i, (d.size - i - 1) * sizeof(QChar));
2601     d.data()[i] = ch.unicode();
2602     return *this;
2603 }
2604 
2605 /*!
2606     Appends the string \a str onto the end of this string.
2607 
2608     Example:
2609 
2610     \snippet qstring/main.cpp 9
2611 
2612     This is the same as using the insert() function:
2613 
2614     \snippet qstring/main.cpp 10
2615 
2616     The append() function is typically very fast (\l{constant time}),
2617     because QString preallocates extra space at the end of the string
2618     data so it can grow without reallocating the entire string each
2619     time.
2620 
2621     \sa operator+=(), prepend(), insert()
2622 */
2623 QString &QString::append(const QString &str)
2624 {
2625     if (!str.isNull()) {
2626         if (isNull()) {
2627             operator=(str);
2628         } else {
2629             if (d->needsDetach() || size() + str.size() > capacity())
2630                 reallocData(size_t(size() + str.size()) + 1u, true);
2631             memcpy(d.data() + d.size, str.d.data(), str.d.size * sizeof(QChar));
2632             d.size += str.d.size;
2633             d.data()[d.size] = '\0';
2634         }
2635     }
2636     return *this;
2637 }
2638 
2639 /*!
2640   \overload append()
2641   \since 5.0
2642 
2643   Appends \a len characters from the QChar array \a str to this string.
2644 */
2645 QString &QString::append(const QChar *str, qsizetype len)
2646 {
2647     if (str && len > 0) {
2648         if (d->needsDetach() || size() + len > capacity())
2649             reallocData(size_t(size() + len) + 1u, true);
2650         memcpy(d.data() + d.size, str, len * sizeof(QChar));
2651         d.size += len;
2652         d.data()[d.size] = '\0';
2653     }
2654     return *this;
2655 }
2656 
2657 /*!
2658   \overload append()
2659 
2660   Appends the Latin-1 string \a str to this string.
2661 */
2662 QString &QString::append(QLatin1String str)
2663 {
2664     const char *s = str.latin1();
2665     if (s) {
2666         qsizetype len = str.size();
2667         if (d->needsDetach() || size() + len > capacity())
2668             reallocData(size_t(size() + len) + 1u, true);
2669         char16_t *i = d.data() + d.size;
2670         qt_from_latin1(i, s, size_t(len));
2671         i[len] = '\0';
2672         d.size += len;
2673     }
2674     return *this;
2675 }
2676 
2677 /*! \fn QString &QString::append(const QByteArray &ba)
2678 
2679     \overload append()
2680 
2681     Appends the byte array \a ba to this string. The given byte array
2682     is converted to Unicode using the fromUtf8() function.
2683 
2684     You can disable this function by defining \c QT_NO_CAST_FROM_ASCII
2685     when you compile your applications. This can be useful if you want
2686     to ensure that all user-visible strings go through QObject::tr(),
2687     for example.
2688 
2689     \sa QT_NO_CAST_FROM_ASCII
2690 */
2691 
2692 /*! \fn QString &QString::append(const char *str)
2693 
2694     \overload append()
2695 
2696     Appends the string \a str to this string. The given const char
2697     pointer is converted to Unicode using the fromUtf8() function.
2698 
2699     You can disable this function by defining \c QT_NO_CAST_FROM_ASCII
2700     when you compile your applications. This can be useful if you want
2701     to ensure that all user-visible strings go through QObject::tr(),
2702     for example.
2703 
2704     \sa QT_NO_CAST_FROM_ASCII
2705 */
2706 
2707 /*!
2708     \overload append()
2709 
2710     Appends the character \a ch to this string.
2711 */
2712 QString &QString::append(QChar ch)
2713 {
2714     if (d->needsDetach() || size() + 1 > capacity())
2715         reallocData(d.size + 2u, true);
2716     d.data()[d.size++] = ch.unicode();
2717     d.data()[d.size] = '\0';
2718     return *this;
2719 }
2720 
2721 /*! \fn QString &QString::prepend(const QString &str)
2722 
2723     Prepends the string \a str to the beginning of this string and
2724     returns a reference to this string.
2725 
2726     Example:
2727 
2728     \snippet qstring/main.cpp 36
2729 
2730     \sa append(), insert()
2731 */
2732 
2733 /*! \fn QString &QString::prepend(QLatin1String str)
2734 
2735     \overload prepend()
2736 
2737     Prepends the Latin-1 string \a str to this string.
2738 */
2739 
2740 /*! \fn QString &QString::prepend(const QChar *str, qsizetype len)
2741     \since 5.5
2742     \overload prepend()
2743 
2744     Prepends \a len characters from the QChar array \a str to this string and
2745     returns a reference to this string.
2746 */
2747 
2748 /*! \fn QString &QString::prepend(QStringView str)
2749     \since 6.0
2750     \overload prepend()
2751 
2752     Prepends the string view \a str to the beginning of this string and
2753     returns a reference to this string.
2754 */
2755 
2756 /*! \fn QString &QString::prepend(const QByteArray &ba)
2757 
2758     \overload prepend()
2759 
2760     Prepends the byte array \a ba to this string. The byte array is
2761     converted to Unicode using the fromUtf8() function.
2762 
2763     You can disable this function by defining \c
2764     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2765     can be useful if you want to ensure that all user-visible strings
2766     go through QObject::tr(), for example.
2767 
2768     \sa QT_NO_CAST_FROM_ASCII
2769 */
2770 
2771 /*! \fn QString &QString::prepend(const char *str)
2772 
2773     \overload prepend()
2774 
2775     Prepends the string \a str to this string. The const char pointer
2776     is converted to Unicode using the fromUtf8() function.
2777 
2778     You can disable this function by defining \c
2779     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2780     can be useful if you want to ensure that all user-visible strings
2781     go through QObject::tr(), for example.
2782 
2783     \sa QT_NO_CAST_FROM_ASCII
2784 */
2785 
2786 /*! \fn QString &QString::prepend(QChar ch)
2787 
2788     \overload prepend()
2789 
2790     Prepends the character \a ch to this string.
2791 */
2792 
2793 /*!
2794   \fn QString &QString::remove(qsizetype position, qsizetype n)
2795 
2796   Removes \a n characters from the string, starting at the given \a
2797   position index, and returns a reference to the string.
2798 
2799   If the specified \a position index is within the string, but \a
2800   position + \a n is beyond the end of the string, the string is
2801   truncated at the specified \a position.
2802 
2803   \snippet qstring/main.cpp 37
2804 
2805   \sa insert(), replace()
2806 */
2807 QString &QString::remove(qsizetype pos, qsizetype len)
2808 {
2809     if (pos < 0)  // count from end of string
2810         pos += size();
2811     if (size_t(pos) >= size_t(size())) {
2812         // range problems
2813     } else if (len >= size() - pos) {
2814         resize(pos); // truncate
2815     } else if (len > 0) {
2816         detach();
2817         memmove(d.data() + pos, d.data() + pos + len,
2818                 (d.size - pos - len + 1) * sizeof(QChar));
2819         d.size -= len;
2820     }
2821     return *this;
2822 }
2823 
2824 template<typename T>
2825 static void removeStringImpl(QString &s, const T &needle, Qt::CaseSensitivity cs)
2826 {
2827     const auto needleSize = needle.size();
2828     if (!needleSize)
2829         return;
2830 
2831     // avoid detach if nothing to do:
2832     qsizetype i = s.indexOf(needle, 0, cs);
2833     if (i < 0)
2834         return;
2835 
2836     const auto beg = s.begin(); // detaches
2837     auto dst = beg + i;
2838     auto src = beg + i + needleSize;
2839     const auto end = s.end();
2840     // loop invariant: [beg, dst[ is partial result
2841     //                 [src, end[ still to be checked for needles
2842     while (src < end) {
2843         const auto i = s.indexOf(needle, src - beg, cs);
2844         const auto hit = i == -1 ? end : beg + i;
2845         const auto skipped = hit - src;
2846         memmove(dst, src, skipped * sizeof(QChar));
2847         dst += skipped;
2848         src = hit + needleSize;
2849     }
2850     s.truncate(dst - beg);
2851 }
2852 
2853 /*!
2854   Removes every occurrence of the given \a str string in this
2855   string, and returns a reference to this string.
2856 
2857   If \a cs is Qt::CaseSensitive (default), the search is
2858   case sensitive; otherwise the search is case insensitive.
2859 
2860   This is the same as \c replace(str, "", cs).
2861 
2862   \sa replace()
2863 */
2864 QString &QString::remove(const QString &str, Qt::CaseSensitivity cs)
2865 {
2866     const auto s = str.d.data();
2867     if (points_into_range(s, d.data(), d.data() + d.size))
2868         removeStringImpl(*this, QStringView{QVarLengthArray(s, s + str.size())}, cs);
2869     else
2870         removeStringImpl(*this, qToStringViewIgnoringNull(str), cs);
2871     return *this;
2872 }
2873 
2874 /*!
2875   \since 5.11
2876   \overload
2877 
2878   Removes every occurrence of the given \a str string in this
2879   string, and returns a reference to this string.
2880 
2881   If \a cs is Qt::CaseSensitive (default), the search is
2882   case sensitive; otherwise the search is case insensitive.
2883 
2884   This is the same as \c replace(str, "", cs).
2885 
2886   \sa replace()
2887 */
2888 QString &QString::remove(QLatin1String str, Qt::CaseSensitivity cs)
2889 {
2890     removeStringImpl(*this, str, cs);
2891     return *this;
2892 }
2893 
2894 /*!
2895   Removes every occurrence of the character \a ch in this string, and
2896   returns a reference to this string.
2897 
2898   If \a cs is Qt::CaseSensitive (default), the search is case
2899   sensitive; otherwise the search is case insensitive.
2900 
2901   Example:
2902 
2903   \snippet qstring/main.cpp 38
2904 
2905   This is the same as \c replace(ch, "", cs).
2906 
2907   \sa replace()
2908 */
2909 QString &QString::remove(QChar ch, Qt::CaseSensitivity cs)
2910 {
2911     const qsizetype idx = indexOf(ch, 0, cs);
2912     if (idx != -1) {
2913         const auto first = begin(); // implicit detach()
2914         auto last = end();
2915         if (cs == Qt::CaseSensitive) {
2916             last = std::remove(first + idx, last, ch);
2917         } else {
2918             const QChar c = ch.toCaseFolded();
2919             auto caseInsensEqual = [c](QChar x) {
2920                 return c == x.toCaseFolded();
2921             };
2922             last = std::remove_if(first + idx, last, caseInsensEqual);
2923         }
2924         resize(last - first);
2925     }
2926     return *this;
2927 }
2928 
2929 /*!
2930   \fn QString &QString::remove(const QRegularExpression &re)
2931   \since 5.0
2932 
2933   Removes every occurrence of the regular expression \a re in the
2934   string, and returns a reference to the string. For example:
2935 
2936   \snippet qstring/main.cpp 96
2937 
2938   \sa indexOf(), lastIndexOf(), replace()
2939 */
2940 
2941 /*!
2942   \fn QString &QString::replace(qsizetype position, qsizetype n, const QString &after)
2943 
2944   Replaces \a n characters beginning at index \a position with
2945   the string \a after and returns a reference to this string.
2946 
2947   \note If the specified \a position index is within the string,
2948   but \a position + \a n goes outside the strings range,
2949   then \a n will be adjusted to stop at the end of the string.
2950 
2951   Example:
2952 
2953   \snippet qstring/main.cpp 40
2954 
2955   \sa insert(), remove()
2956 */
2957 QString &QString::replace(qsizetype pos, qsizetype len, const QString &after)
2958 {
2959     return replace(pos, len, after.constData(), after.length());
2960 }
2961 
2962 /*!
2963   \fn QString &QString::replace(qsizetype position, qsizetype n, const QChar *unicode, qsizetype size)
2964   \overload replace()
2965   Replaces \a n characters beginning at index \a position with the
2966   first \a size characters of the QChar array \a unicode and returns a
2967   reference to this string.
2968 */
2969 QString &QString::replace(qsizetype pos, qsizetype len, const QChar *unicode, qsizetype size)
2970 {
2971     if (size_t(pos) > size_t(this->size()))
2972         return *this;
2973     if (len > this->size() - pos)
2974         len = this->size() - pos;
2975 
2976     size_t index = pos;
2977     replace_helper(&index, 1, len, unicode, size);
2978     return *this;
2979 }
2980 
2981 /*!
2982   \fn QString &QString::replace(qsizetype position, qsizetype n, QChar after)
2983   \overload replace()
2984 
2985   Replaces \a n characters beginning at index \a position with the
2986   character \a after and returns a reference to this string.
2987 */
2988 QString &QString::replace(qsizetype pos, qsizetype len, QChar after)
2989 {
2990     return replace(pos, len, &after, 1);
2991 }
2992 
2993 /*!
2994   \overload replace()
2995   Replaces every occurrence of the string \a before with the string \a
2996   after and returns a reference to this string.
2997 
2998   If \a cs is Qt::CaseSensitive (default), the search is case
2999   sensitive; otherwise the search is case insensitive.
3000 
3001   Example:
3002 
3003   \snippet qstring/main.cpp 41
3004 
3005   \note The replacement text is not rescanned after it is inserted.
3006 
3007   Example:
3008 
3009   \snippet qstring/main.cpp 86
3010 */
3011 QString &QString::replace(const QString &before, const QString &after, Qt::CaseSensitivity cs)
3012 {
3013     return replace(before.constData(), before.size(), after.constData(), after.size(), cs);
3014 }
3015 
3016 namespace { // helpers for replace and its helper:
3017 QChar *textCopy(const QChar *start, qsizetype len)
3018 {
3019     const size_t size = len * sizeof(QChar);
3020     QChar *const copy = static_cast<QChar *>(::malloc(size));
3021     Q_CHECK_PTR(copy);
3022     ::memcpy(copy, start, size);
3023     return copy;
3024 }
3025 
3026 static bool pointsIntoRange(const QChar *ptr, const char16_t *base, qsizetype len)
3027 {
3028     const QChar *const start = reinterpret_cast<const QChar *>(base);
3029     const std::less<const QChar *> less;
3030     return !less(ptr, start) && less(ptr, start + len);
3031 }
3032 } // end namespace
3033 
3034 /*!
3035   \internal
3036  */
3037 void QString::replace_helper(size_t *indices, qsizetype nIndices, qsizetype blen, const QChar *after, qsizetype alen)
3038 {
3039     // Copy after if it lies inside our own d.b area (which we could
3040     // possibly invalidate via a realloc or modify by replacement).
3041     QChar *afterBuffer = nullptr;
3042     if (pointsIntoRange(after, d.data(), d.size)) // Use copy in place of vulnerable original:
3043         after = afterBuffer = textCopy(after, alen);
3044 
3045     QT_TRY {
3046         if (blen == alen) {
3047             // replace in place
3048             detach();
3049             for (qsizetype i = 0; i < nIndices; ++i)
3050                 memcpy(d.data() + indices[i], after, alen * sizeof(QChar));
3051         } else if (alen < blen) {
3052             // replace from front
3053             detach();
3054             size_t to = indices[0];
3055             if (alen)
3056                 memcpy(d.data()+to, after, alen*sizeof(QChar));
3057             to += alen;
3058             size_t movestart = indices[0] + blen;
3059             for (qsizetype i = 1; i < nIndices; ++i) {
3060                 qsizetype msize = indices[i] - movestart;
3061                 if (msize > 0) {
3062                     memmove(d.data() + to, d.data() + movestart, msize * sizeof(QChar));
3063                     to += msize;
3064                 }
3065                 if (alen) {
3066                     memcpy(d.data() + to, after, alen * sizeof(QChar));
3067                     to += alen;
3068                 }
3069                 movestart = indices[i] + blen;
3070             }
3071             qsizetype msize = d.size - movestart;
3072             if (msize > 0)
3073                 memmove(d.data() + to, d.data() + movestart, msize * sizeof(QChar));
3074             resize(d.size - nIndices*(blen-alen));
3075         } else {
3076             // replace from back
3077             qsizetype adjust = nIndices*(alen-blen);
3078             qsizetype newLen = d.size + adjust;
3079             qsizetype moveend = d.size;
3080             resize(newLen);
3081 
3082             while (nIndices) {
3083                 --nIndices;
3084                 qsizetype movestart = indices[nIndices] + blen;
3085                 qsizetype insertstart = indices[nIndices] + nIndices*(alen-blen);
3086                 qsizetype moveto = insertstart + alen;
3087                 memmove(d.data() + moveto, d.data() + movestart,
3088                         (moveend - movestart)*sizeof(QChar));
3089                 memcpy(d.data() + insertstart, after, alen * sizeof(QChar));
3090                 moveend = movestart-blen;
3091             }
3092         }
3093     } QT_CATCH(const std::bad_alloc &) {
3094         ::free(afterBuffer);
3095         QT_RETHROW;
3096     }
3097     ::free(afterBuffer);
3098 }
3099 
3100 /*!
3101   \since 4.5
3102   \overload replace()
3103 
3104   Replaces each occurrence in this string of the first \a blen
3105   characters of \a before with the first \a alen characters of \a
3106   after and returns a reference to this string.
3107 
3108   If \a cs is Qt::CaseSensitive (default), the search is case
3109   sensitive; otherwise the search is case insensitive.
3110 */
3111 QString &QString::replace(const QChar *before, qsizetype blen,
3112                           const QChar *after, qsizetype alen,
3113                           Qt::CaseSensitivity cs)
3114 {
3115     if (d.size == 0) {
3116         if (blen)
3117             return *this;
3118     } else {
3119         if (cs == Qt::CaseSensitive && before == after && blen == alen)
3120             return *this;
3121     }
3122     if (alen == 0 && blen == 0)
3123         return *this;
3124 
3125     QStringMatcher matcher(before, blen, cs);
3126     QChar *beforeBuffer = nullptr, *afterBuffer = nullptr;
3127 
3128     qsizetype index = 0;
3129     while (1) {
3130         size_t indices[1024];
3131         size_t pos = 0;
3132         while (pos < 1024) {
3133             index = matcher.indexIn(*this, index);
3134             if (index == -1)
3135                 break;
3136             indices[pos++] = index;
3137             if (blen) // Step over before:
3138                 index += blen;
3139             else // Only count one instance of empty between any two characters:
3140                 index++;
3141         }
3142         if (!pos) // Nothing to replace
3143             break;
3144 
3145         if (Q_UNLIKELY(index != -1)) {
3146             /*
3147               We're about to change data, that before and after might point
3148               into, and we'll need that data for our next batch of indices.
3149             */
3150             if (!afterBuffer && pointsIntoRange(after, d.data(), d.size))
3151                 after = afterBuffer = textCopy(after, alen);
3152 
3153             if (!beforeBuffer && pointsIntoRange(before, d.data(), d.size)) {
3154                 beforeBuffer = textCopy(before, blen);
3155                 matcher = QStringMatcher(beforeBuffer, blen, cs);
3156             }
3157         }
3158 
3159         replace_helper(indices, pos, blen, after, alen);
3160 
3161         if (Q_LIKELY(index == -1)) // Nothing left to replace
3162             break;
3163         // The call to replace_helper just moved what index points at:
3164         index += pos*(alen-blen);
3165     }
3166     ::free(afterBuffer);
3167     ::free(beforeBuffer);
3168 
3169     return *this;
3170 }
3171 
3172 /*!
3173   \overload replace()
3174   Replaces every occurrence of the character \a ch in the string with
3175   \a after and returns a reference to this string.
3176 
3177   If \a cs is Qt::CaseSensitive (default), the search is case
3178   sensitive; otherwise the search is case insensitive.
3179 */
3180 QString& QString::replace(QChar ch, const QString &after, Qt::CaseSensitivity cs)
3181 {
3182     if (after.size() == 0)
3183         return remove(ch, cs);
3184 
3185     if (after.size() == 1)
3186         return replace(ch, after.front(), cs);
3187 
3188     if (size() == 0)
3189         return *this;
3190 
3191     char16_t cc = (cs == Qt::CaseSensitive ? ch.unicode() : ch.toCaseFolded().unicode());
3192 
3193     qsizetype index = 0;
3194     while (1) {
3195         size_t indices[1024];
3196         size_t pos = 0;
3197         if (cs == Qt::CaseSensitive) {
3198             while (pos < 1024 && index < size()) {
3199                 if (d.data()[index] == cc)
3200                     indices[pos++] = index;
3201                 index++;
3202             }
3203         } else {
3204             while (pos < 1024 && index < size()) {
3205                 if (QChar::toCaseFolded(d.data()[index]) == cc)
3206                     indices[pos++] = index;
3207                 index++;
3208             }
3209         }
3210         if (!pos) // Nothing to replace
3211             break;
3212 
3213         replace_helper(indices, pos, 1, after.constData(), after.size());
3214 
3215         if (Q_LIKELY(index == -1)) // Nothing left to replace
3216             break;
3217         // The call to replace_helper just moved what index points at:
3218         index += pos*(after.size() - 1);
3219     }
3220     return *this;
3221 }
3222 
3223 /*!
3224   \overload replace()
3225   Replaces every occurrence of the character \a before with the
3226   character \a after and returns a reference to this string.
3227 
3228   If \a cs is Qt::CaseSensitive (default), the search is case
3229   sensitive; otherwise the search is case insensitive.
3230 */
3231 QString& QString::replace(QChar before, QChar after, Qt::CaseSensitivity cs)
3232 {
3233     if (d.size) {
3234         const qsizetype idx = indexOf(before, 0, cs);
3235         if (idx != -1) {
3236             detach();
3237             const char16_t a = after.unicode();
3238             char16_t *i = d.data();
3239             char16_t *const e = i + d.size;
3240             i += idx;
3241             *i = a;
3242             if (cs == Qt::CaseSensitive) {
3243                 const char16_t b = before.unicode();
3244                 while (++i != e) {
3245                     if (*i == b)
3246                         *i = a;
3247                 }
3248             } else {
3249                 const char16_t b = foldCase(before.unicode());
3250                 while (++i != e) {
3251                     if (foldCase(*i) == b)
3252                         *i = a;
3253                 }
3254             }
3255         }
3256     }
3257     return *this;
3258 }
3259 
3260 /*!
3261   \since 4.5
3262   \overload replace()
3263 
3264   Replaces every occurrence of the string \a before with the string \a
3265   after and returns a reference to this string.
3266 
3267   If \a cs is Qt::CaseSensitive (default), the search is case
3268   sensitive; otherwise the search is case insensitive.
3269 
3270   \note The text is not rescanned after a replacement.
3271 */
3272 QString &QString::replace(QLatin1String before, QLatin1String after, Qt::CaseSensitivity cs)
3273 {
3274     qsizetype alen = after.size();
3275     qsizetype blen = before.size();
3276     QVarLengthArray<char16_t> a(alen);
3277     QVarLengthArray<char16_t> b(blen);
3278     qt_from_latin1(a.data(), after.latin1(), alen);
3279     qt_from_latin1(b.data(), before.latin1(), blen);
3280     return replace((const QChar *)b.data(), blen, (const QChar *)a.data(), alen, cs);
3281 }
3282 
3283 /*!
3284   \since 4.5
3285   \overload replace()
3286 
3287   Replaces every occurrence of the string \a before with the string \a
3288   after and returns a reference to this string.
3289 
3290   If \a cs is Qt::CaseSensitive (default), the search is case
3291   sensitive; otherwise the search is case insensitive.
3292 
3293   \note The text is not rescanned after a replacement.
3294 */
3295 QString &QString::replace(QLatin1String before, const QString &after, Qt::CaseSensitivity cs)
3296 {
3297     qsizetype blen = before.size();
3298     QVarLengthArray<char16_t> b(blen);
3299     qt_from_latin1(b.data(), before.latin1(), blen);
3300     return replace((const QChar *)b.data(), blen, after.constData(), after.d.size, cs);
3301 }
3302 
3303 /*!
3304   \since 4.5
3305   \overload replace()
3306 
3307   Replaces every occurrence of the string \a before with the string \a
3308   after and returns a reference to this string.
3309 
3310   If \a cs is Qt::CaseSensitive (default), the search is case
3311   sensitive; otherwise the search is case insensitive.
3312 
3313   \note The text is not rescanned after a replacement.
3314 */
3315 QString &QString::replace(const QString &before, QLatin1String after, Qt::CaseSensitivity cs)
3316 {
3317     qsizetype alen = after.size();
3318     QVarLengthArray<char16_t> a(alen);
3319     qt_from_latin1(a.data(), after.latin1(), alen);
3320     return replace(before.constData(), before.d.size, (const QChar *)a.data(), alen, cs);
3321 }
3322 
3323 /*!
3324   \since 4.5
3325   \overload replace()
3326 
3327   Replaces every occurrence of the character \a c with the string \a
3328   after and returns a reference to this string.
3329 
3330   If \a cs is Qt::CaseSensitive (default), the search is case
3331   sensitive; otherwise the search is case insensitive.
3332 
3333   \note The text is not rescanned after a replacement.
3334 */
3335 QString &QString::replace(QChar c, QLatin1String after, Qt::CaseSensitivity cs)
3336 {
3337     qsizetype alen = after.size();
3338     QVarLengthArray<char16_t> a(alen);
3339     qt_from_latin1(a.data(), after.latin1(), alen);
3340     return replace(&c, 1, (const QChar *)a.data(), alen, cs);
3341 }
3342 
3343 
3344 /*!
3345   \relates QString
3346   Returns \c true if string \a s1 is equal to string \a s2; otherwise
3347   returns \c false.
3348 
3349   \sa {Comparing Strings}
3350 */
3351 bool operator==(const QString &s1, const QString &s2) noexcept
3352 {
3353     if (s1.d.size != s2.d.size)
3354         return false;
3355 
3356     return qt_compare_strings(s1, s2, Qt::CaseSensitive) == 0;
3357 }
3358 
3359 /*!
3360     \overload operator==()
3361     Returns \c true if this string is equal to \a other; otherwise
3362     returns \c false.
3363 */
3364 bool QString::operator==(QLatin1String other) const noexcept
3365 {
3366     if (size() != other.size())
3367         return false;
3368 
3369     return qt_compare_strings(*this, other, Qt::CaseSensitive) == 0;
3370 }
3371 
3372 /*! \fn bool QString::operator==(const QByteArray &other) const
3373 
3374     \overload operator==()
3375 
3376     The \a other byte array is converted to a QString using the
3377     fromUtf8() function. This function stops conversion at the
3378     first NUL character found, or the end of the byte array.
3379 
3380     You can disable this operator by defining \c
3381     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3382     can be useful if you want to ensure that all user-visible strings
3383     go through QObject::tr(), for example.
3384 
3385     Returns \c true if this string is lexically equal to the parameter
3386     string \a other. Otherwise returns \c false.
3387 
3388     \sa QT_NO_CAST_FROM_ASCII
3389 */
3390 
3391 /*! \fn bool QString::operator==(const char *other) const
3392 
3393     \overload operator==()
3394 
3395     The \a other const char pointer is converted to a QString using
3396     the fromUtf8() function.
3397 
3398     You can disable this operator by defining \c
3399     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3400     can be useful if you want to ensure that all user-visible strings
3401     go through QObject::tr(), for example.
3402 
3403     \sa QT_NO_CAST_FROM_ASCII
3404 */
3405 
3406 /*!
3407    \relates QString
3408     Returns \c true if string \a s1 is lexically less than string
3409     \a s2; otherwise returns \c false.
3410 
3411     \sa {Comparing Strings}
3412 */
3413 bool operator<(const QString &s1, const QString &s2) noexcept
3414 {
3415     return qt_compare_strings(s1, s2, Qt::CaseSensitive) < 0;
3416 }
3417 
3418 /*!
3419    \overload operator<()
3420 
3421     Returns \c true if this string is lexically less than the parameter
3422     string called \a other; otherwise returns \c false.
3423 */
3424 bool QString::operator<(QLatin1String other) const noexcept
3425 {
3426     return qt_compare_strings(*this, other, Qt::CaseSensitive) < 0;
3427 }
3428 
3429 /*! \fn bool QString::operator<(const QByteArray &other) const
3430 
3431     \overload operator<()
3432 
3433     The \a other byte array is converted to a QString using the
3434     fromUtf8() function. If any NUL characters ('\\0') are embedded
3435     in the byte array, they will be included in the transformation.
3436 
3437     You can disable this operator by defining \c
3438     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3439     can be useful if you want to ensure that all user-visible strings
3440     go through QObject::tr(), for example.
3441 
3442     \sa QT_NO_CAST_FROM_ASCII
3443 */
3444 
3445 /*! \fn bool QString::operator<(const char *other) const
3446 
3447     Returns \c true if this string is lexically less than string \a other.
3448     Otherwise returns \c false.
3449 
3450     \overload operator<()
3451 
3452     The \a other const char pointer is converted to a QString using
3453     the fromUtf8() function.
3454 
3455     You can disable this operator by defining \c
3456     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3457     can be useful if you want to ensure that all user-visible strings
3458     go through QObject::tr(), for example.
3459 
3460     \sa QT_NO_CAST_FROM_ASCII
3461 */
3462 
3463 /*! \fn bool operator<=(const QString &s1, const QString &s2)
3464 
3465     \relates QString
3466 
3467     Returns \c true if string \a s1 is lexically less than or equal to
3468     string \a s2; otherwise returns \c false.
3469 
3470     \sa {Comparing Strings}
3471 */
3472 
3473 /*! \fn bool QString::operator<=(QLatin1String other) const
3474 
3475     Returns \c true if this string is lexically less than or equal to
3476     parameter string \a other. Otherwise returns \c false.
3477 
3478     \overload operator<=()
3479 */
3480 
3481 /*! \fn bool QString::operator<=(const QByteArray &other) const
3482 
3483     \overload operator<=()
3484 
3485     The \a other byte array is converted to a QString using the
3486     fromUtf8() function. If any NUL characters ('\\0') are embedded
3487     in the byte array, they will be included in the transformation.
3488 
3489     You can disable this operator by defining \c
3490     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3491     can be useful if you want to ensure that all user-visible strings
3492     go through QObject::tr(), for example.
3493 
3494     \sa QT_NO_CAST_FROM_ASCII
3495 */
3496 
3497 /*! \fn bool QString::operator<=(const char *other) const
3498 
3499     \overload operator<=()
3500 
3501     The \a other const char pointer is converted to a QString using
3502     the fromUtf8() function.
3503 
3504     You can disable this operator by defining \c
3505     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3506     can be useful if you want to ensure that all user-visible strings
3507     go through QObject::tr(), for example.
3508 
3509     \sa QT_NO_CAST_FROM_ASCII
3510 */
3511 
3512 /*! \fn bool operator>(const QString &s1, const QString &s2)
3513     \relates QString
3514 
3515     Returns \c true if string \a s1 is lexically greater than string \a s2;
3516     otherwise returns \c false.
3517 
3518     \sa {Comparing Strings}
3519 */
3520 
3521 /*!
3522    \overload operator>()
3523 
3524     Returns \c true if this string is lexically greater than the parameter
3525     string \a other; otherwise returns \c false.
3526 */
3527 bool QString::operator>(QLatin1String other) const noexcept
3528 {
3529     return qt_compare_strings(*this, other, Qt::CaseSensitive) > 0;
3530 }
3531 
3532 /*! \fn bool QString::operator>(const QByteArray &other) const
3533 
3534     \overload operator>()
3535 
3536     The \a other byte array is converted to a QString using the
3537     fromUtf8() function. If any NUL characters ('\\0') are embedded
3538     in the byte array, they will be included in the transformation.
3539 
3540     You can disable this operator by defining \c
3541     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3542     can be useful if you want to ensure that all user-visible strings
3543     go through QObject::tr(), for example.
3544 
3545     \sa QT_NO_CAST_FROM_ASCII
3546 */
3547 
3548 /*! \fn bool QString::operator>(const char *other) const
3549 
3550     \overload operator>()
3551 
3552     The \a other const char pointer is converted to a QString using
3553     the fromUtf8() function.
3554 
3555     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3556     when you compile your applications. This can be useful if you want
3557     to ensure that all user-visible strings go through QObject::tr(),
3558     for example.
3559 
3560     \sa QT_NO_CAST_FROM_ASCII
3561 */
3562 
3563 /*! \fn bool operator>=(const QString &s1, const QString &s2)
3564     \relates QString
3565 
3566     Returns \c true if string \a s1 is lexically greater than or equal to
3567     string \a s2; otherwise returns \c false.
3568 
3569     \sa {Comparing Strings}
3570 */
3571 
3572 /*! \fn bool QString::operator>=(QLatin1String other) const
3573 
3574     Returns \c true if this string is lexically greater than or equal to parameter
3575     string \a other. Otherwise returns \c false.
3576 
3577     \overload operator>=()
3578 */
3579 
3580 /*! \fn bool QString::operator>=(const QByteArray &other) const
3581 
3582     \overload operator>=()
3583 
3584     The \a other byte array is converted to a QString using the
3585     fromUtf8() function. If any NUL characters ('\\0') are embedded in
3586     the byte array, they will be included in the transformation.
3587 
3588     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3589     when you compile your applications. This can be useful if you want
3590     to ensure that all user-visible strings go through QObject::tr(),
3591     for example.
3592 
3593     \sa QT_NO_CAST_FROM_ASCII
3594 */
3595 
3596 /*! \fn bool QString::operator>=(const char *other) const
3597 
3598     \overload operator>=()
3599 
3600     The \a other const char pointer is converted to a QString using
3601     the fromUtf8() function.
3602 
3603     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3604     when you compile your applications. This can be useful if you want
3605     to ensure that all user-visible strings go through QObject::tr(),
3606     for example.
3607 
3608     \sa QT_NO_CAST_FROM_ASCII
3609 */
3610 
3611 /*! \fn bool operator!=(const QString &s1, const QString &s2)
3612     \relates QString
3613 
3614     Returns \c true if string \a s1 is not equal to string \a s2;
3615     otherwise returns \c false.
3616 
3617     \sa {Comparing Strings}
3618 */
3619 
3620 /*! \fn bool QString::operator!=(QLatin1String other) const
3621 
3622     Returns \c true if this string is not equal to parameter string \a other.
3623     Otherwise returns \c false.
3624 
3625     \overload operator!=()
3626 */
3627 
3628 /*! \fn bool QString::operator!=(const QByteArray &other) const
3629 
3630     \overload operator!=()
3631 
3632     The \a other byte array is converted to a QString using the
3633     fromUtf8() function. If any NUL characters ('\\0') are embedded
3634     in the byte array, they will be included in the transformation.
3635 
3636     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3637     when you compile your applications. This can be useful if you want
3638     to ensure that all user-visible strings go through QObject::tr(),
3639     for example.
3640 
3641     \sa QT_NO_CAST_FROM_ASCII
3642 */
3643 
3644 /*! \fn bool QString::operator!=(const char *other) const
3645 
3646     \overload operator!=()
3647 
3648     The \a other const char pointer is converted to a QString using
3649     the fromUtf8() function.
3650 
3651     You can disable this operator by defining \c
3652     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3653     can be useful if you want to ensure that all user-visible strings
3654     go through QObject::tr(), for example.
3655 
3656     \sa QT_NO_CAST_FROM_ASCII
3657 */
3658 
3659 #if QT_STRINGVIEW_LEVEL < 2
3660 /*!
3661   Returns the index position of the first occurrence of the string \a
3662   str in this string, searching forward from index position \a
3663   from. Returns -1 if \a str is not found.
3664 
3665   If \a cs is Qt::CaseSensitive (default), the search is case
3666   sensitive; otherwise the search is case insensitive.
3667 
3668   Example:
3669 
3670   \snippet qstring/main.cpp 24
3671 
3672   If \a from is -1, the search starts at the last character; if it is
3673   -2, at the next to last character and so on.
3674 
3675   \sa lastIndexOf(), contains(), count()
3676 */
3677 qsizetype QString::indexOf(const QString &str, qsizetype from, Qt::CaseSensitivity cs) const
3678 {
3679     return QtPrivate::findString(QStringView(unicode(), length()), from, QStringView(str.unicode(), str.length()), cs);
3680 }
3681 #endif  // QT_STRINGVIEW_LEVEL < 2
3682 
3683 /*!
3684     \fn qsizetype QString::indexOf(QStringView str, qsizetype from, Qt::CaseSensitivity cs) const
3685     \since 5.14
3686     \overload indexOf()
3687 
3688     Returns the index position of the first occurrence of the string view \a str
3689     in this string, searching forward from index position \a from.
3690     Returns -1 if \a str is not found.
3691 
3692     If \a cs is Qt::CaseSensitive (default), the search is case
3693     sensitive; otherwise the search is case insensitive.
3694 
3695     If \a from is -1, the search starts at the last character; if it is
3696     -2, at the next to last character and so on.
3697 
3698     \sa QStringView::indexOf(), lastIndexOf(), contains(), count()
3699 */
3700 
3701 /*!
3702   \since 4.5
3703   Returns the index position of the first occurrence of the string \a
3704   str in this string, searching forward from index position \a
3705   from. Returns -1 if \a str is not found.
3706 
3707   If \a cs is Qt::CaseSensitive (default), the search is case
3708   sensitive; otherwise the search is case insensitive.
3709 
3710   Example:
3711 
3712   \snippet qstring/main.cpp 24
3713 
3714   If \a from is -1, the search starts at the last character; if it is
3715   -2, at the next to last character and so on.
3716 
3717   \sa lastIndexOf(), contains(), count()
3718 */
3719 
3720 qsizetype QString::indexOf(QLatin1String str, qsizetype from, Qt::CaseSensitivity cs) const
3721 {
3722     return QtPrivate::findString(QStringView(unicode(), size()), from, str, cs);
3723 }
3724 
3725 /*!
3726     \overload indexOf()
3727 
3728     Returns the index position of the first occurrence of the
3729     character \a ch in the string, searching forward from index
3730     position \a from. Returns -1 if \a ch could not be found.
3731 */
3732 qsizetype QString::indexOf(QChar ch, qsizetype from, Qt::CaseSensitivity cs) const
3733 {
3734     return qFindChar(QStringView(unicode(), length()), ch, from, cs);
3735 }
3736 
3737 #if QT_STRINGVIEW_LEVEL < 2
3738 /*!
3739   Returns the index position of the last occurrence of the string \a
3740   str in this string, searching backward from index position \a
3741   from. If \a from is -1 (default), the search starts at the last
3742   character; if \a from is -2, at the next to last character and so
3743   on. Returns -1 if \a str is not found.
3744 
3745   If \a cs is Qt::CaseSensitive (default), the search is case
3746   sensitive; otherwise the search is case insensitive.
3747 
3748   Example:
3749 
3750   \snippet qstring/main.cpp 29
3751 
3752   \sa indexOf(), contains(), count()
3753 */
3754 qsizetype QString::lastIndexOf(const QString &str, qsizetype from, Qt::CaseSensitivity cs) const
3755 {
3756     return QtPrivate::lastIndexOf(QStringView(*this), from, str, cs);
3757 }
3758 
3759 #endif // QT_STRINGVIEW_LEVEL < 2
3760 
3761 /*!
3762   \since 4.5
3763   \overload lastIndexOf()
3764 
3765   Returns the index position of the last occurrence of the string \a
3766   str in this string, searching backward from index position \a
3767   from. If \a from is -1 (default), the search starts at the last
3768   character; if \a from is -2, at the next to last character and so
3769   on. Returns -1 if \a str is not found.
3770 
3771   If \a cs is Qt::CaseSensitive (default), the search is case
3772   sensitive; otherwise the search is case insensitive.
3773 
3774   Example:
3775 
3776   \snippet qstring/main.cpp 29
3777 
3778   \sa indexOf(), contains(), count()
3779 */
3780 qsizetype QString::lastIndexOf(QLatin1String str, qsizetype from, Qt::CaseSensitivity cs) const
3781 {
3782     return QtPrivate::lastIndexOf(*this, from, str, cs);
3783 }
3784 
3785 /*!
3786   \overload lastIndexOf()
3787 
3788   Returns the index position of the last occurrence of the character
3789   \a ch, searching backward from position \a from.
3790 */
3791 qsizetype QString::lastIndexOf(QChar ch, qsizetype from, Qt::CaseSensitivity cs) const
3792 {
3793     return qLastIndexOf(QStringView(*this), ch, from, cs);
3794 }
3795 
3796 /*!
3797   \fn qsizetype QString::lastIndexOf(QStringView str, qsizetype from, Qt::CaseSensitivity cs) const
3798   \since 5.14
3799   \overload lastIndexOf()
3800 
3801   Returns the index position of the last occurrence of the string view \a
3802   str in this string, searching backward from index position \a
3803   from. If \a from is -1 (default), the search starts at the last
3804   character; if \a from is -2, at the next to last character and so
3805   on. Returns -1 if \a str is not found.
3806 
3807   If \a cs is Qt::CaseSensitive (default), the search is case
3808   sensitive; otherwise the search is case insensitive.
3809 
3810   \sa indexOf(), contains(), count()
3811 */
3812 
3813 
3814 #if QT_CONFIG(regularexpression)
3815 struct QStringCapture
3816 {
3817     qsizetype pos;
3818     qsizetype len;
3819     int no;
3820 };
3821 Q_DECLARE_TYPEINFO(QStringCapture, Q_PRIMITIVE_TYPE);
3822 
3823 /*!
3824   \overload replace()
3825   \since 5.0
3826 
3827   Replaces every occurrence of the regular expression \a re in the
3828   string with \a after. Returns a reference to the string. For
3829   example:
3830 
3831   \snippet qstring/main.cpp 87
3832 
3833   For regular expressions containing capturing groups,
3834   occurrences of \b{\\1}, \b{\\2}, ..., in \a after are replaced
3835   with the string captured by the corresponding capturing group.
3836 
3837   \snippet qstring/main.cpp 88
3838 
3839   \sa indexOf(), lastIndexOf(), remove(), QRegularExpression, QRegularExpressionMatch
3840 */
3841 QString &QString::replace(const QRegularExpression &re, const QString &after)
3842 {
3843     if (!re.isValid()) {
3844         qWarning("QString::replace: invalid QRegularExpression object");
3845         return *this;
3846     }
3847 
3848     const QString copy(*this);
3849     QRegularExpressionMatchIterator iterator = re.globalMatch(copy);
3850     if (!iterator.hasNext()) // no matches at all
3851         return *this;
3852 
3853     reallocData(size_t(d.size) + 1u);
3854 
3855     qsizetype numCaptures = re.captureCount();
3856 
3857     // 1. build the backreferences list, holding where the backreferences
3858     // are in the replacement string
3859     QList<QStringCapture> backReferences;
3860     const qsizetype al = after.length();
3861     const QChar *ac = after.unicode();
3862 
3863     for (qsizetype i = 0; i < al - 1; i++) {
3864         if (ac[i] == QLatin1Char('\\')) {
3865             int no = ac[i + 1].digitValue();
3866             if (no > 0 && no <= numCaptures) {
3867                 QStringCapture backReference;
3868                 backReference.pos = i;
3869                 backReference.len = 2;
3870 
3871                 if (i < al - 2) {
3872                     int secondDigit = ac[i + 2].digitValue();
3873                     if (secondDigit != -1 && ((no * 10) + secondDigit) <= numCaptures) {
3874                         no = (no * 10) + secondDigit;
3875                         ++backReference.len;
3876                     }
3877                 }
3878 
3879                 backReference.no = no;
3880                 backReferences.append(backReference);
3881             }
3882         }
3883     }
3884 
3885     // 2. iterate on the matches. For every match, copy in chunks
3886     // - the part before the match
3887     // - the after string, with the proper replacements for the backreferences
3888 
3889     qsizetype newLength = 0; // length of the new string, with all the replacements
3890     qsizetype lastEnd = 0;
3891     QList<QStringRef> chunks;
3892     while (iterator.hasNext()) {
3893         QRegularExpressionMatch match = iterator.next();
3894         qsizetype len;
3895         // add the part before the match
3896         len = match.capturedStart() - lastEnd;
3897         if (len > 0) {
3898             chunks << copy.midRef(lastEnd, len);
3899             newLength += len;
3900         }
3901 
3902         lastEnd = 0;
3903         // add the after string, with replacements for the backreferences
3904         for (const QStringCapture &backReference : qAsConst(backReferences)) {
3905             // part of "after" before the backreference
3906             len = backReference.pos - lastEnd;
3907             if (len > 0) {
3908                 chunks << after.midRef(lastEnd, len);
3909                 newLength += len;
3910             }
3911 
3912             // backreference itself
3913             len = match.capturedLength(backReference.no);
3914             if (len > 0) {
3915                 chunks << copy.midRef(match.capturedStart(backReference.no), len);
3916                 newLength += len;
3917             }
3918 
3919             lastEnd = backReference.pos + backReference.len;
3920         }
3921 
3922         // add the last part of the after string
3923         len = after.length() - lastEnd;
3924         if (len > 0) {
3925             chunks << after.midRef(lastEnd, len);
3926             newLength += len;
3927         }
3928 
3929         lastEnd = match.capturedEnd();
3930     }
3931 
3932     // 3. trailing string after the last match
3933     if (copy.length() > lastEnd) {
3934         chunks << copy.midRef(lastEnd);
3935         newLength += copy.length() - lastEnd;
3936     }
3937 
3938     // 4. assemble the chunks together
3939     resize(newLength);
3940     qsizetype i = 0;
3941     QChar *uc = data();
3942     for (const QStringRef &chunk : qAsConst(chunks)) {
3943         qsizetype len = chunk.length();
3944         memcpy(uc + i, chunk.unicode(), len * sizeof(QChar));
3945         i += len;
3946     }
3947 
3948     return *this;
3949 }
3950 #endif // QT_CONFIG(regularexpression)
3951 
3952 /*!
3953     Returns the number of (potentially overlapping) occurrences of
3954     the string \a str in this string.
3955 
3956     If \a cs is Qt::CaseSensitive (default), the search is
3957     case sensitive; otherwise the search is case insensitive.
3958 
3959     \sa contains(), indexOf()
3960 */
3961 
3962 qsizetype QString::count(const QString &str, Qt::CaseSensitivity cs) const
3963 {
3964     return QtPrivate::count(QStringView(unicode(), size()), QStringView(str.unicode(), str.size()), cs);
3965 }
3966 
3967 /*!
3968     \overload count()
3969 
3970     Returns the number of occurrences of character \a ch in the string.
3971 
3972     If \a cs is Qt::CaseSensitive (default), the search is
3973     case sensitive; otherwise the search is case insensitive.
3974 
3975     \sa contains(), indexOf()
3976 */
3977 
3978 qsizetype QString::count(QChar ch, Qt::CaseSensitivity cs) const
3979 {
3980     return QtPrivate::count(QStringView(unicode(), size()), ch, cs);
3981 }
3982 
3983 /*!
3984     \since 6.0
3985     \overload count()
3986     Returns the number of (potentially overlapping) occurrences of the
3987     string reference \a str in this string.
3988 
3989     If \a cs is Qt::CaseSensitive (default), the search is
3990     case sensitive; otherwise the search is case insensitive.
3991 
3992     \sa contains(), indexOf()
3993 */
3994 qsizetype QString::count(QStringView str, Qt::CaseSensitivity cs) const
3995 {
3996     return QtPrivate::count(*this, str, cs);
3997 }
3998 
3999 #if QT_STRINGVIEW_LEVEL < 2
4000 /*! \fn bool QString::contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4001 
4002     Returns \c true if this string contains an occurrence of the string
4003     \a str; otherwise returns \c false.
4004 
4005     If \a cs is Qt::CaseSensitive (default), the search is
4006     case sensitive; otherwise the search is case insensitive.
4007 
4008     Example:
4009     \snippet qstring/main.cpp 17
4010 
4011     \sa indexOf(), count()
4012 */
4013 #endif // QT_STRINGVIEW_LEVEL < 2
4014 
4015 /*! \fn bool QString::contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4016     \since 5.3
4017 
4018     \overload contains()
4019 
4020     Returns \c true if this string contains an occurrence of the latin-1 string
4021     \a str; otherwise returns \c false.
4022 */
4023 
4024 /*! \fn bool QString::contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4025 
4026     \overload contains()
4027 
4028     Returns \c true if this string contains an occurrence of the
4029     character \a ch; otherwise returns \c false.
4030 */
4031 
4032 /*! \fn bool QString::contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4033     \since 5.14
4034     \overload contains()
4035 
4036     Returns \c true if this string contains an occurrence of the string view
4037     \a str; otherwise returns \c false.
4038 
4039     If \a cs is Qt::CaseSensitive (default), the search is
4040     case sensitive; otherwise the search is case insensitive.
4041 
4042     \sa indexOf(), count()
4043 */
4044 
4045 #if QT_CONFIG(regularexpression)
4046 /*!
4047     \since 5.5
4048 
4049     Returns the index position of the first match of the regular
4050     expression \a re in the string, searching forward from index
4051     position \a from. Returns -1 if \a re didn't match anywhere.
4052 
4053     If the match is successful and \a rmatch is not \nullptr, it also
4054     writes the results of the match into the QRegularExpressionMatch object
4055     pointed to by \a rmatch.
4056 
4057     Example:
4058 
4059     \snippet qstring/main.cpp 93
4060 */
4061 qsizetype QString::indexOf(const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch) const
4062 {
4063     if (!re.isValid()) {
4064         qWarning("QString::indexOf: invalid QRegularExpression object");
4065         return -1;
4066     }
4067 
4068     QRegularExpressionMatch match = re.match(*this, from);
4069     if (match.hasMatch()) {
4070         const qsizetype ret = match.capturedStart();
4071         if (rmatch)
4072             *rmatch = std::move(match);
4073         return ret;
4074     }
4075 
4076     return -1;
4077 }
4078 
4079 /*!
4080     \since 5.5
4081 
4082     Returns the index position of the last match of the regular
4083     expression \a re in the string, which starts before the index
4084     position \a from. Returns -1 if \a re didn't match anywhere.
4085 
4086     If the match is successful and \a rmatch is not \nullptr, it also
4087     writes the results of the match into the QRegularExpressionMatch object
4088     pointed to by \a rmatch.
4089 
4090     Example:
4091 
4092     \snippet qstring/main.cpp 94
4093 */
4094 qsizetype QString::lastIndexOf(const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch) const
4095 {
4096     if (!re.isValid()) {
4097         qWarning("QString::lastIndexOf: invalid QRegularExpression object");
4098         return -1;
4099     }
4100 
4101     qsizetype endpos = (from < 0) ? (size() + from + 1) : (from + 1);
4102     QRegularExpressionMatchIterator iterator = re.globalMatch(*this);
4103     qsizetype lastIndex = -1;
4104     while (iterator.hasNext()) {
4105         QRegularExpressionMatch match = iterator.next();
4106         qsizetype start = match.capturedStart();
4107         if (start < endpos) {
4108             lastIndex = start;
4109             if (rmatch)
4110                 *rmatch = std::move(match);
4111         } else {
4112             break;
4113         }
4114     }
4115 
4116     return lastIndex;
4117 }
4118 
4119 /*!
4120     \since 5.1
4121 
4122     Returns \c true if the regular expression \a re matches somewhere in this
4123     string; otherwise returns \c false.
4124 
4125     If the match is successful and \a rmatch is not \nullptr, it also
4126     writes the results of the match into the QRegularExpressionMatch object
4127     pointed to by \a rmatch.
4128 
4129     \sa QRegularExpression::match()
4130 */
4131 
4132 bool QString::contains(const QRegularExpression &re, QRegularExpressionMatch *rmatch) const
4133 {
4134     if (!re.isValid()) {
4135         qWarning("QString::contains: invalid QRegularExpression object");
4136         return false;
4137     }
4138     QRegularExpressionMatch m = re.match(*this);
4139     bool hasMatch = m.hasMatch();
4140     if (hasMatch && rmatch)
4141         *rmatch = std::move(m);
4142     return hasMatch;
4143 }
4144 
4145 /*!
4146     \overload count()
4147     \since 5.0
4148 
4149     Returns the number of times the regular expression \a re matches
4150     in the string.
4151 
4152     This function counts overlapping matches, so in the example
4153     below, there are four instances of "ana" or "ama":
4154 
4155     \snippet qstring/main.cpp 95
4156 */
4157 qsizetype QString::count(const QRegularExpression &re) const
4158 {
4159     if (!re.isValid()) {
4160         qWarning("QString::count: invalid QRegularExpression object");
4161         return 0;
4162     }
4163     qsizetype count = 0;
4164     qsizetype index = -1;
4165     qsizetype len = length();
4166     while (index < len - 1) {
4167         QRegularExpressionMatch match = re.match(*this, index + 1);
4168         if (!match.hasMatch())
4169             break;
4170         index = match.capturedStart();
4171         count++;
4172     }
4173     return count;
4174 }
4175 #endif // QT_CONFIG(regularexpression)
4176 
4177 /*! \fn qsizetype QString::count() const
4178 
4179     \overload count()
4180 
4181     Same as size().
4182 */
4183 
4184 
4185 /*!
4186     \enum QString::SectionFlag
4187 
4188     This enum specifies flags that can be used to affect various
4189     aspects of the section() function's behavior with respect to
4190     separators and empty fields.
4191 
4192     \value SectionDefault Empty fields are counted, leading and
4193     trailing separators are not included, and the separator is
4194     compared case sensitively.
4195 
4196     \value SectionSkipEmpty Treat empty fields as if they don't exist,
4197     i.e. they are not considered as far as \e start and \e end are
4198     concerned.
4199 
4200     \value SectionIncludeLeadingSep Include the leading separator (if
4201     any) in the result string.
4202 
4203     \value SectionIncludeTrailingSep Include the trailing separator
4204     (if any) in the result string.
4205 
4206     \value SectionCaseInsensitiveSeps Compare the separator
4207     case-insensitively.
4208 
4209     \sa section()
4210 */
4211 
4212 /*!
4213     \fn QString QString::section(QChar sep, qsizetype start, qsizetype end = -1, SectionFlags flags) const
4214 
4215     This function returns a section of the string.
4216 
4217     This string is treated as a sequence of fields separated by the
4218     character, \a sep. The returned string consists of the fields from
4219     position \a start to position \a end inclusive. If \a end is not
4220     specified, all fields from position \a start to the end of the
4221     string are included. Fields are numbered 0, 1, 2, etc., counting
4222     from the left, and -1, -2, etc., counting from right to left.
4223 
4224     The \a flags argument can be used to affect some aspects of the
4225     function's behavior, e.g. whether to be case sensitive, whether
4226     to skip empty fields and how to deal with leading and trailing
4227     separators; see \l{SectionFlags}.
4228 
4229     \snippet qstring/main.cpp 52
4230 
4231     If \a start or \a end is negative, we count fields from the right
4232     of the string, the right-most field being -1, the one from
4233     right-most field being -2, and so on.
4234 
4235     \snippet qstring/main.cpp 53
4236 
4237     \sa split()
4238 */
4239 
4240 /*!
4241     \overload section()
4242 
4243     \snippet qstring/main.cpp 51
4244     \snippet qstring/main.cpp 54
4245 
4246     \sa split()
4247 */
4248 
4249 QString QString::section(const QString &sep, qsizetype start, qsizetype end, SectionFlags flags) const
4250 {
4251     const QList<QStringRef> sections = splitRef(
4252             sep, Qt::KeepEmptyParts, (flags & SectionCaseInsensitiveSeps) ? Qt::CaseInsensitive : Qt::CaseSensitive);
4253     const qsizetype sectionsSize = sections.size();
4254     if (!(flags & SectionSkipEmpty)) {
4255         if (start < 0)
4256             start += sectionsSize;
4257         if (end < 0)
4258             end += sectionsSize;
4259     } else {
4260         qsizetype skip = 0;
4261         for (qsizetype k = 0; k < sectionsSize; ++k) {
4262             if (sections.at(k).isEmpty())
4263                 skip++;
4264         }
4265         if (start < 0)
4266             start += sectionsSize - skip;
4267         if (end < 0)
4268             end += sectionsSize - skip;
4269     }
4270     if (start >= sectionsSize || end < 0 || start > end)
4271         return QString();
4272 
4273     QString ret;
4274     qsizetype first_i = start, last_i = end;
4275     for (qsizetype x = 0, i = 0; x <= end && i < sectionsSize; ++i) {
4276         const QStringRef &section = sections.at(i);
4277         const bool empty = section.isEmpty();
4278         if (x >= start) {
4279             if(x == start)
4280                 first_i = i;
4281             if(x == end)
4282                 last_i = i;
4283             if (x > start && i > 0)
4284                 ret += sep;
4285             ret += section;
4286         }
4287         if (!empty || !(flags & SectionSkipEmpty))
4288             x++;
4289     }
4290     if ((flags & SectionIncludeLeadingSep) && first_i > 0)
4291         ret.prepend(sep);
4292     if ((flags & SectionIncludeTrailingSep) && last_i < sectionsSize - 1)
4293         ret += sep;
4294     return ret;
4295 }
4296 
4297 #if !(defined(QT_NO_REGEXP) && !QT_CONFIG(regularexpression))
4298 class qt_section_chunk {
4299 public:
4300     qt_section_chunk() {}
4301     qt_section_chunk(qsizetype l, QStringRef s) : length(l), string(std::move(s)) {}
4302     qsizetype length;
4303     QStringRef string;
4304 };
4305 Q_DECLARE_TYPEINFO(qt_section_chunk, Q_MOVABLE_TYPE);
4306 
4307 static QString extractSections(const QList<qt_section_chunk> &sections, qsizetype start, qsizetype end,
4308                                QString::SectionFlags flags)
4309 {
4310     const qsizetype sectionsSize = sections.size();
4311 
4312     if (!(flags & QString::SectionSkipEmpty)) {
4313         if (start < 0)
4314             start += sectionsSize;
4315         if (end < 0)
4316             end += sectionsSize;
4317     } else {
4318         qsizetype skip = 0;
4319         for (qsizetype k = 0; k < sectionsSize; ++k) {
4320             const qt_section_chunk &section = sections.at(k);
4321             if (section.length == section.string.length())
4322                 skip++;
4323         }
4324         if (start < 0)
4325             start += sectionsSize - skip;
4326         if (end < 0)
4327             end += sectionsSize - skip;
4328     }
4329     if (start >= sectionsSize || end < 0 || start > end)
4330         return QString();
4331 
4332     QString ret;
4333     qsizetype x = 0;
4334     qsizetype first_i = start, last_i = end;
4335     for (qsizetype i = 0; x <= end && i < sectionsSize; ++i) {
4336         const qt_section_chunk &section = sections.at(i);
4337         const bool empty = (section.length == section.string.length());
4338         if (x >= start) {
4339             if (x == start)
4340                 first_i = i;
4341             if (x == end)
4342                 last_i = i;
4343             if (x != start)
4344                 ret += section.string;
4345             else
4346                 ret += section.string.mid(section.length);
4347         }
4348         if (!empty || !(flags & QString::SectionSkipEmpty))
4349             x++;
4350     }
4351 
4352     if ((flags & QString::SectionIncludeLeadingSep) && first_i >= 0) {
4353         const qt_section_chunk &section = sections.at(first_i);
4354         ret.prepend(section.string.left(section.length));
4355     }
4356 
4357     if ((flags & QString::SectionIncludeTrailingSep)
4358         && last_i < sectionsSize - 1) {
4359         const qt_section_chunk &section = sections.at(last_i+1);
4360         ret += section.string.left(section.length);
4361     }
4362 
4363     return ret;
4364 }
4365 #endif
4366 
4367 #if QT_CONFIG(regularexpression)
4368 /*!
4369     \overload section()
4370     \since 5.0
4371 
4372     This string is treated as a sequence of fields separated by the
4373     regular expression, \a re.
4374 
4375     \snippet qstring/main.cpp 89
4376 
4377     \warning Using this QRegularExpression version is much more expensive than
4378     the overloaded string and character versions.
4379 
4380     \sa split(), simplified()
4381 */
4382 QString QString::section(const QRegularExpression &re, qsizetype start, qsizetype end, SectionFlags flags) const
4383 {
4384     if (!re.isValid()) {
4385         qWarning("QString::section: invalid QRegularExpression object");
4386         return QString();
4387     }
4388 
4389     const QChar *uc = unicode();
4390     if (!uc)
4391         return QString();
4392 
4393     QRegularExpression sep(re);
4394     if (flags & SectionCaseInsensitiveSeps)
4395         sep.setPatternOptions(sep.patternOptions() | QRegularExpression::CaseInsensitiveOption);
4396 
4397     QList<qt_section_chunk> sections;
4398     qsizetype n = length(), m = 0, last_m = 0, last_len = 0;
4399     QRegularExpressionMatchIterator iterator = sep.globalMatch(*this);
4400     while (iterator.hasNext()) {
4401         QRegularExpressionMatch match = iterator.next();
4402         m = match.capturedStart();
4403         sections.append(qt_section_chunk(last_len, QStringRef(this, last_m, m - last_m)));
4404         last_m = m;
4405         last_len = match.capturedLength();
4406     }
4407     sections.append(qt_section_chunk(last_len, QStringRef(this, last_m, n - last_m)));
4408 
4409     return extractSections(sections, start, end, flags);
4410 }
4411 #endif // QT_CONFIG(regularexpression)
4412 
4413 /*!
4414     Returns a substring that contains the \a n leftmost characters
4415     of the string.
4416 
4417     \obsolete Use first() instead in new code.
4418 
4419     The entire string is returned if \a n is greater than or equal
4420     to size(), or less than zero.
4421 
4422     \snippet qstring/main.cpp 31
4423 
4424     \sa first(), last(), startsWith(), chopped(), chop(), truncate()
4425 */
4426 QString QString::left(qsizetype n)  const
4427 {
4428     if (size_t(n) >= size_t(size()))
4429         return *this;
4430     return QString((const QChar*) d.data(), n);
4431 }
4432 
4433 /*!
4434     Returns a substring that contains the \a n rightmost characters
4435     of the string.
4436 
4437     \obsolete Use last() instead in new code.
4438 
4439     The entire string is returned if \a n is greater than or equal
4440     to size(), or less than zero.
4441 
4442     \snippet qstring/main.cpp 48
4443 
4444     \sa endsWith(), last(), first(), sliced(), chopped(), chop(), truncate()
4445 */
4446 QString QString::right(qsizetype n) const
4447 {
4448     if (size_t(n) >= size_t(size()))
4449         return *this;
4450     return QString(constData() + size() - n, n);
4451 }
4452 
4453 /*!
4454     Returns a string that contains \a n characters of this string,
4455     starting at the specified \a position index.
4456 
4457     \obsolete Use sliced() instead in new code.
4458 
4459     Returns a null string if the \a position index exceeds the
4460     length of the string. If there are less than \a n characters
4461     available in the string starting at the given \a position, or if
4462     \a n is -1 (default), the function returns all characters that
4463     are available from the specified \a position.
4464 
4465     Example:
4466 
4467     \snippet qstring/main.cpp 34
4468 
4469     \sa first(), last(), sliced(), chopped(), chop(), truncate()
4470 */
4471 
4472 QString QString::mid(qsizetype position, qsizetype n) const
4473 {
4474     qsizetype p = position;
4475     qsizetype l = n;
4476     using namespace QtPrivate;
4477     switch (QContainerImplHelper::mid(size(), &p, &l)) {
4478     case QContainerImplHelper::Null:
4479         return QString();
4480     case QContainerImplHelper::Empty:
4481         return QString(DataPointer::fromRawData(&_empty, 0));
4482     case QContainerImplHelper::Full:
4483         return *this;
4484     case QContainerImplHelper::Subset:
4485         return QString(constData() + p, l);
4486     }
4487     Q_UNREACHABLE();
4488     return QString();
4489 }
4490 
4491 /*!
4492     \fn QString QString::first(qsizetype n) const
4493     \since 6.0
4494 
4495     Returns a string that contains the first \a n characters
4496     of this string.
4497 
4498     \note The behavior is undefined when \a n < 0 or \a n > size().
4499 
4500     \sa last(), sliced(), startsWith(), chopped(), chop(), truncate()
4501 */
4502 
4503 /*!
4504     \fn QString QString::last(qsizetype n) const
4505     \since 6.0
4506 
4507     Returns the string that contains the last \a n characters of this string.
4508 
4509     \note The behavior is undefined when \a n < 0 or \a n > size().
4510 
4511     \sa first(), sliced(), endsWith(), chopped(), chop(), truncate()
4512 */
4513 
4514 /*!
4515     \fn QString QString::sliced(qsizetype pos, qsizetype n) const
4516     \since 6.0
4517 
4518     Returns a string that contains \a n characters of this string,
4519     starting at position \a pos.
4520 
4521     \note The behavior is undefined when \a pos < 0, \a n < 0,
4522     or \a pos + \a n > size().
4523 
4524     \sa first(), last(), chopped(), chop(), truncate()
4525 */
4526 
4527 /*!
4528     \fn QString QString::sliced(qsizetype pos) const
4529     \since 6.0
4530     \overload
4531 
4532     Returns a string that contains the portion of this string starting at
4533     position \a pos and extending to its end.
4534 
4535     \note The behavior is undefined when \a pos < 0 or \a pos > size().
4536 
4537     \sa first(), last(), sliced(), chopped(), chop(), truncate()
4538 */
4539 
4540 /*!
4541     \fn QString QString::chopped(qsizetype len) const
4542     \since 5.10
4543 
4544     Returns a string that contains the size() - \a len leftmost characters
4545     of this string.
4546 
4547     \note The behavior is undefined if \a len is negative or greater than size().
4548 
4549     \sa endsWith(), left(), right(), mid(), chop(), truncate()
4550 */
4551 
4552 #if QT_STRINGVIEW_LEVEL < 2
4553 /*!
4554     Returns \c true if the string starts with \a s; otherwise returns
4555     \c false.
4556 
4557     If \a cs is Qt::CaseSensitive (default), the search is
4558     case sensitive; otherwise the search is case insensitive.
4559 
4560     \snippet qstring/main.cpp 65
4561 
4562     \sa endsWith()
4563 */
4564 bool QString::startsWith(const QString& s, Qt::CaseSensitivity cs) const
4565 {
4566     return qt_starts_with(*this, s, cs);
4567 }
4568 #endif
4569 
4570 /*!
4571   \overload startsWith()
4572  */
4573 bool QString::startsWith(QLatin1String s, Qt::CaseSensitivity cs) const
4574 {
4575     return qt_starts_with(*this, s, cs);
4576 }
4577 
4578 /*!
4579   \overload startsWith()
4580 
4581   Returns \c true if the string starts with \a c; otherwise returns
4582   \c false.
4583 */
4584 bool QString::startsWith(QChar c, Qt::CaseSensitivity cs) const
4585 {
4586     return qt_starts_with(*this, c, cs);
4587 }
4588 
4589 /*!
4590     \fn bool QString::startsWith(QStringView str, Qt::CaseSensitivity cs) const
4591     \since 5.10
4592     \overload
4593 
4594     Returns \c true if the string starts with the string-view \a str;
4595     otherwise returns \c false.
4596 
4597     If \a cs is Qt::CaseSensitive (default), the search is case-sensitive;
4598     otherwise the search is case insensitive.
4599 
4600     \sa endsWith()
4601 */
4602 
4603 #if QT_STRINGVIEW_LEVEL < 2
4604 /*!
4605     Returns \c true if the string ends with \a s; otherwise returns
4606     \c false.
4607 
4608     If \a cs is Qt::CaseSensitive (default), the search is case
4609     sensitive; otherwise the search is case insensitive.
4610 
4611     \snippet qstring/main.cpp 20
4612 
4613     \sa startsWith()
4614 */
4615 bool QString::endsWith(const QString &s, Qt::CaseSensitivity cs) const
4616 {
4617     return qt_ends_with(*this, s, cs);
4618 }
4619 #endif // QT_STRINGVIEW_LEVEL < 2
4620 
4621 /*!
4622     \fn bool QString::endsWith(QStringView str, Qt::CaseSensitivity cs) const
4623     \since 5.10
4624     \overload endsWith()
4625     Returns \c true if the string ends with the string view \a str;
4626     otherwise returns \c false.
4627 
4628     If \a cs is Qt::CaseSensitive (default), the search is case
4629     sensitive; otherwise the search is case insensitive.
4630 
4631     \sa startsWith()
4632 */
4633 
4634 /*!
4635     \overload endsWith()
4636 */
4637 bool QString::endsWith(QLatin1String s, Qt::CaseSensitivity cs) const
4638 {
4639     return qt_ends_with(*this, s, cs);
4640 }
4641 
4642 /*!
4643   Returns \c true if the string ends with \a c; otherwise returns
4644   \c false.
4645 
4646   \overload endsWith()
4647  */
4648 bool QString::endsWith(QChar c, Qt::CaseSensitivity cs) const
4649 {
4650     return qt_ends_with(*this, c, cs);
4651 }
4652 
4653 /*!
4654     Returns \c true if the string is uppercase, that is, it's identical
4655     to its toUpper() folding.
4656 
4657     Note that this does \e not mean that the string does not contain
4658     lowercase letters (some lowercase letters do not have a uppercase
4659     folding; they are left unchanged by toUpper()).
4660     For more information, refer to the Unicode standard, section 3.13.
4661 
4662     \since 5.12
4663 
4664     \sa QChar::toUpper(), isLower()
4665 */
4666 bool QString::isUpper() const
4667 {
4668     QStringIterator it(*this);
4669 
4670     while (it.hasNext()) {
4671         const char32_t uc = it.nextUnchecked();
4672         if (uc > QChar::LastValidCodePoint || qGetProp(uc)->cases[QUnicodeTables::UpperCase].diff)
4673             return false;
4674     }
4675 
4676     return true;
4677 }
4678 
4679 /*!
4680     Returns \c true if the string is lowercase, that is, it's identical
4681     to its toLower() folding.
4682 
4683     Note that this does \e not mean that the string does not contain
4684     uppercase letters (some uppercase letters do not have a lowercase
4685     folding; they are left unchanged by toLower()).
4686     For more information, refer to the Unicode standard, section 3.13.
4687 
4688     \since 5.12
4689 
4690     \sa QChar::toLower(), isUpper()
4691  */
4692 bool QString::isLower() const
4693 {
4694     QStringIterator it(*this);
4695 
4696     while (it.hasNext()) {
4697         const char32_t uc = it.nextUnchecked();
4698         if (uc > QChar::LastValidCodePoint || qGetProp(uc)->cases[QUnicodeTables::LowerCase].diff)
4699             return false;
4700     }
4701 
4702     return true;
4703 }
4704 
4705 static QByteArray qt_convert_to_latin1(QStringView string);
4706 
4707 QByteArray QString::toLatin1_helper(const QString &string)
4708 {
4709     return qt_convert_to_latin1(string);
4710 }
4711 
4712 /*!
4713     \since 5.10
4714     \internal
4715     \relates QStringView
4716 
4717     Returns a Latin-1 representation of \a string as a QByteArray.
4718 
4719     The behavior is undefined if \a string contains non-Latin1 characters.
4720 
4721     \sa QString::toLatin1(), QStringView::toLatin1(), QtPrivate::convertToUtf8(),
4722     QtPrivate::convertToLocal8Bit(), QtPrivate::convertToUcs4()
4723 */
4724 QByteArray QtPrivate::convertToLatin1(QStringView string)
4725 {
4726     return qt_convert_to_latin1(string);
4727 }
4728 
4729 static QByteArray qt_convert_to_latin1(QStringView string)
4730 {
4731     if (Q_UNLIKELY(string.isNull()))
4732         return QByteArray();
4733 
4734     QByteArray ba(string.length(), Qt::Uninitialized);
4735 
4736     // since we own the only copy, we're going to const_cast the constData;
4737     // that avoids an unnecessary call to detach() and expansion code that will never get used
4738     qt_to_latin1(reinterpret_cast<uchar *>(const_cast<char *>(ba.constData())),
4739                  string.utf16(), string.size());
4740     return ba;
4741 }
4742 
4743 QByteArray QString::toLatin1_helper_inplace(QString &s)
4744 {
4745     if (!s.isDetached())
4746         return qt_convert_to_latin1(s);
4747 
4748     // We can return our own buffer to the caller.
4749     // Conversion to Latin-1 always shrinks the buffer by half.
4750     const char16_t *data = s.d.data();
4751     qsizetype length = s.d.size;
4752 
4753     // Move the d pointer over to the bytearray.
4754     // Kids, avert your eyes. Don't try this at home.
4755 
4756     // this relies on the fact that we use QArrayData for everything behind the scenes which has the same layout
4757     static_assert(sizeof(QByteArray::DataPointer) == sizeof(QString::DataPointer), "sizes have to be equal");
4758     QByteArray::DataPointer ba_d(reinterpret_cast<QByteArray::Data *>(s.d.d_ptr()), reinterpret_cast<char *>(s.d.data()), length);
4759     ba_d.ref();
4760     s.clear();
4761 
4762     char *ddata = ba_d.data();
4763 
4764     // multiply the allocated capacity by sizeof(char16_t)
4765     ba_d.d_ptr()->alloc *= sizeof(char16_t);
4766 
4767     // do the in-place conversion
4768     qt_to_latin1(reinterpret_cast<uchar *>(ddata), data, length);
4769     ddata[length] = '\0';
4770     return QByteArray(ba_d);
4771 }
4772 
4773 /*!
4774     \fn QByteArray QString::toLatin1() const
4775 
4776     Returns a Latin-1 representation of the string as a QByteArray.
4777 
4778     The returned byte array is undefined if the string contains non-Latin1
4779     characters. Those characters may be suppressed or replaced with a
4780     question mark.
4781 
4782     \sa fromLatin1(), toUtf8(), toLocal8Bit(), QStringEncoder
4783 */
4784 
4785 static QByteArray qt_convert_to_local_8bit(QStringView string);
4786 
4787 /*!
4788     \fn QByteArray QString::toLocal8Bit() const
4789 
4790     Returns the local 8-bit representation of the string as a
4791     QByteArray. The returned byte array is undefined if the string
4792     contains characters not supported by the local 8-bit encoding.
4793 
4794     On Unix systems this is equivalen to toUtf8(), on Windows the systems
4795     current code page is being used.
4796 
4797     If this string contains any characters that cannot be encoded in the
4798     locale, the returned byte array is undefined. Those characters may be
4799     suppressed or replaced by another.
4800 
4801     \sa fromLocal8Bit(), toLatin1(), toUtf8(), QStringEncoder
4802 */
4803 
4804 QByteArray QString::toLocal8Bit_helper(const QChar *data, qsizetype size)
4805 {
4806     return qt_convert_to_local_8bit(QStringView(data, size));
4807 }
4808 
4809 static QByteArray qt_convert_to_local_8bit(QStringView string)
4810 {
4811     if (string.isNull())
4812         return QByteArray();
4813     QStringEncoder fromUtf16(QStringEncoder::System, QStringEncoder::Flag::Stateless);
4814     return fromUtf16(string);
4815 }
4816 
4817 /*!
4818     \since 5.10
4819     \internal
4820     \relates QStringView
4821 
4822     Returns a local 8-bit representation of \a string as a QByteArray.
4823 
4824     On Unix systems this is equivalen to toUtf8(), on Windows the systems
4825     current code page is being used.
4826 
4827     The behavior is undefined if \a string contains characters not
4828     supported by the locale's 8-bit encoding.
4829 
4830     \sa QString::toLocal8Bit(), QStringView::toLocal8Bit()
4831 */
4832 QByteArray QtPrivate::convertToLocal8Bit(QStringView string)
4833 {
4834     return qt_convert_to_local_8bit(string);
4835 }
4836 
4837 static QByteArray qt_convert_to_utf8(QStringView str);
4838 
4839 /*!
4840     \fn QByteArray QString::toUtf8() const
4841 
4842     Returns a UTF-8 representation of the string as a QByteArray.
4843 
4844     UTF-8 is a Unicode codec and can represent all characters in a Unicode
4845     string like QString.
4846 
4847     \sa fromUtf8(), toLatin1(), toLocal8Bit(), QStringEncoder
4848 */
4849 
4850 QByteArray QString::toUtf8_helper(const QString &str)
4851 {
4852     return qt_convert_to_utf8(str);
4853 }
4854 
4855 static QByteArray qt_convert_to_utf8(QStringView str)
4856 {
4857     if (str.isNull())
4858         return QByteArray();
4859 
4860     return QUtf8::convertFromUnicode(str.data(), str.length());
4861 }
4862 
4863 /*!
4864     \since 5.10
4865     \internal
4866     \relates QStringView
4867 
4868     Returns a UTF-8 representation of \a string as a QByteArray.
4869 
4870     UTF-8 is a Unicode codec and can represent all characters in a Unicode
4871     string like QStringView.
4872 
4873     \sa QString::toUtf8(), QStringView::toUtf8()
4874 */
4875 QByteArray QtPrivate::convertToUtf8(QStringView string)
4876 {
4877     return qt_convert_to_utf8(string);
4878 }
4879 
4880 static QList<uint> qt_convert_to_ucs4(QStringView string);
4881 
4882 /*!
4883     \since 4.2
4884 
4885     Returns a UCS-4/UTF-32 representation of the string as a QList<uint>.
4886 
4887     UCS-4 is a Unicode codec and therefore it is lossless. All characters from
4888     this string will be encoded in UCS-4. Any invalid sequence of code units in
4889     this string is replaced by the Unicode's replacement character
4890     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
4891 
4892     The returned list is not \\0'-terminated.
4893 
4894     \sa fromUtf8(), toUtf8(), toLatin1(), toLocal8Bit(), QStringEncoder, fromUcs4(), toWCharArray()
4895 */
4896 QList<uint> QString::toUcs4() const
4897 {
4898     return qt_convert_to_ucs4(*this);
4899 }
4900 
4901 static QList<uint> qt_convert_to_ucs4(QStringView string)
4902 {
4903     QList<uint> v(string.length());
4904     uint *a = const_cast<uint*>(v.constData());
4905     QStringIterator it(string);
4906     while (it.hasNext())
4907         *a++ = it.next();
4908     v.resize(a - v.constData());
4909     return v;
4910 }
4911 
4912 /*!
4913     \since 5.10
4914     \internal
4915     \relates QStringView
4916 
4917     Returns a UCS-4/UTF-32 representation of \a string as a QList<uint>.
4918 
4919     UCS-4 is a Unicode codec and therefore it is lossless. All characters from
4920     this string will be encoded in UCS-4. Any invalid sequence of code units in
4921     this string is replaced by the Unicode's replacement character
4922     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
4923 
4924     The returned list is not \\0'-terminated.
4925 
4926     \sa QString::toUcs4(), QStringView::toUcs4(), QtPrivate::convertToLatin1(),
4927     QtPrivate::convertToLocal8Bit(), QtPrivate::convertToUtf8()
4928 */
4929 QList<uint> QtPrivate::convertToUcs4(QStringView string)
4930 {
4931     return qt_convert_to_ucs4(string);
4932 }
4933 
4934 QString::DataPointer QString::fromLatin1_helper(const char *str, qsizetype size)
4935 {
4936     DataPointer d;
4937     if (!str) {
4938         // nothing to do
4939     } else if (size == 0 || (!*str && size < 0)) {
4940         d = DataPointer::fromRawData(&_empty, 0);
4941     } else {
4942         if (size < 0)
4943             size = qstrlen(str);
4944         d = DataPointer(Data::allocate(size + 1), size);
4945         d.data()[size] = '\0';
4946         char16_t *dst = d.data();
4947 
4948         qt_from_latin1(dst, str, size_t(size));
4949     }
4950     return d;
4951 }
4952 
4953 /*! \fn QString QString::fromLatin1(const char *str, qsizetype size)
4954     Returns a QString initialized with the first \a size characters
4955     of the Latin-1 string \a str.
4956 
4957     If \a size is -1 (default), it is taken to be strlen(\a
4958     str).
4959 
4960     \sa toLatin1(), fromUtf8(), fromLocal8Bit()
4961 */
4962 
4963 /*!
4964     \fn QString QString::fromLatin1(const QByteArray &str)
4965     \overload
4966     \since 5.0
4967 
4968     Returns a QString initialized with the Latin-1 string \a str.
4969 */
4970 
4971 /*! \fn QString QString::fromLocal8Bit(const char *str, qsizetype size)
4972     Returns a QString initialized with the first \a size characters
4973     of the 8-bit string \a str.
4974 
4975     If \a size is -1 (default), it is taken to be strlen(\a
4976     str).
4977 
4978     On Unix systems this is equivalen to fromUtf8(), on Windows the systems
4979     current code page is being used.
4980 
4981     \sa toLocal8Bit(), fromLatin1(), fromUtf8()
4982 */
4983 
4984 /*!
4985     \fn QString QString::fromLocal8Bit(const QByteArray &str)
4986     \overload
4987     \since 5.0
4988 
4989     Returns a QString initialized with the 8-bit string \a str.
4990 */
4991 QString QString::fromLocal8Bit_helper(const char *str, qsizetype size)
4992 {
4993     if (!str)
4994         return QString();
4995     if (size < 0)
4996         size = qstrlen(str);
4997     if (size == 0)
4998         return QString(DataPointer::fromRawData(&_empty, 0));
4999     QStringDecoder toUtf16(QStringDecoder::System, QStringDecoder::Flag::Stateless);
5000     return toUtf16(str, size);
5001 }
5002 
5003 /*! \fn QString QString::fromUtf8(const char *str, qsizetype size)
5004     Returns a QString initialized with the first \a size bytes
5005     of the UTF-8 string \a str.
5006 
5007     If \a size is -1 (default), it is taken to be strlen(\a
5008     str).
5009 
5010     UTF-8 is a Unicode codec and can represent all characters in a Unicode
5011     string like QString. However, invalid sequences are possible with UTF-8
5012     and, if any such are found, they will be replaced with one or more
5013     "replacement characters", or suppressed. These include non-Unicode
5014     sequences, non-characters, overlong sequences or surrogate codepoints
5015     encoded into UTF-8.
5016 
5017     This function can be used to process incoming data incrementally as long as
5018     all UTF-8 characters are terminated within the incoming data. Any
5019     unterminated characters at the end of the string will be replaced or
5020     suppressed. In order to do stateful decoding, please use \l QStringDecoder.
5021 
5022     \sa toUtf8(), fromLatin1(), fromLocal8Bit()
5023 */
5024 
5025 /*!
5026     \fn QString QString::fromUtf8(const char8_t *str, qsizetype size)
5027     \overload
5028     \since 6.0
5029 
5030     This overload is only available when compiling in C++20 mode.
5031 */
5032 
5033 /*!
5034     \fn QString QString::fromUtf8(const QByteArray &str)
5035     \overload
5036     \since 5.0
5037 
5038     Returns a QString initialized with the UTF-8 string \a str.
5039 */
5040 QString QString::fromUtf8_helper(const char *str, qsizetype size)
5041 {
5042     if (!str)
5043         return QString();
5044 
5045     Q_ASSERT(size != -1);
5046     return QUtf8::convertToUnicode(str, size);
5047 }
5048 
5049 /*!
5050     \since 5.3
5051     Returns a QString initialized with the first \a size characters
5052     of the Unicode string \a unicode (ISO-10646-UTF-16 encoded).
5053 
5054     If \a size is -1 (default), \a unicode must be \\0'-terminated.
5055 
5056     This function checks for a Byte Order Mark (BOM). If it is missing,
5057     host byte order is assumed.
5058 
5059     This function is slow compared to the other Unicode conversions.
5060     Use QString(const QChar *, int) or QString(const QChar *) if possible.
5061 
5062     QString makes a deep copy of the Unicode data.
5063 
5064     \sa utf16(), setUtf16(), fromStdU16String()
5065 */
5066 QString QString::fromUtf16(const char16_t *unicode, qsizetype size)
5067 {
5068     if (!unicode)
5069         return QString();
5070     if (size < 0) {
5071         size = 0;
5072         while (unicode[size] != 0)
5073             ++size;
5074     }
5075     QStringDecoder toUtf16(QStringDecoder::Utf16, QStringDecoder::Flag::Stateless);
5076     return toUtf16(reinterpret_cast<const char *>(unicode), size*2);
5077 }
5078 
5079 /*!
5080     \fn QString QString::fromUtf16(const ushort *str, qsizetype size)
5081     \obsolete
5082 
5083     Use the \c char16_t overload.
5084 */
5085 
5086 /*!
5087     \fn QString QString::fromUcs4(const uint *str, qsizetype size)
5088     \since 4.2
5089     \obsolete
5090 
5091     Use the \c char32_t overload instead.
5092 */
5093 
5094 /*!
5095     \since 5.3
5096 
5097     Returns a QString initialized with the first \a size characters
5098     of the Unicode string \a unicode (ISO-10646-UCS-4 encoded).
5099 
5100     If \a size is -1 (default), \a unicode must be \\0'-terminated.
5101 
5102     \sa toUcs4(), fromUtf16(), utf16(), setUtf16(), fromWCharArray(), fromStdU32String()
5103 */
5104 QString QString::fromUcs4(const char32_t *unicode, qsizetype size)
5105 {
5106     if (!unicode)
5107         return QString();
5108     if (size < 0) {
5109         size = 0;
5110         while (unicode[size] != 0)
5111             ++size;
5112     }
5113     QStringDecoder toUtf16(QStringDecoder::Utf32, QStringDecoder::Flag::Stateless);
5114     return toUtf16(reinterpret_cast<const char *>(unicode), size*4);
5115 }
5116 
5117 
5118 /*!
5119     Resizes the string to \a size characters and copies \a unicode
5120     into the string.
5121 
5122     If \a unicode is 0, nothing is copied, but the string is still
5123     resized to \a size.
5124 
5125     \sa unicode(), setUtf16()
5126 */
5127 QString& QString::setUnicode(const QChar *unicode, qsizetype size)
5128 {
5129      resize(size);
5130      if (unicode && size)
5131          memcpy(d.data(), unicode, size * sizeof(QChar));
5132      return *this;
5133 }
5134 
5135 /*!
5136     \fn QString &QString::setUtf16(const ushort *unicode, qsizetype size)
5137 
5138     Resizes the string to \a size characters and copies \a unicode
5139     into the string.
5140 
5141     If \a unicode is 0, nothing is copied, but the string is still
5142     resized to \a size.
5143 
5144     Note that unlike fromUtf16(), this function does not consider BOMs and
5145     possibly differing byte ordering.
5146 
5147     \sa utf16(), setUnicode()
5148 */
5149 
5150 /*!
5151     \fn QString QString::simplified() const
5152 
5153     Returns a string that has whitespace removed from the start
5154     and the end, and that has each sequence of internal whitespace
5155     replaced with a single space.
5156 
5157     Whitespace means any character for which QChar::isSpace() returns
5158     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5159     '\\f', '\\r', and ' '.
5160 
5161     Example:
5162 
5163     \snippet qstring/main.cpp 57
5164 
5165     \sa trimmed()
5166 */
5167 QString QString::simplified_helper(const QString &str)
5168 {
5169     return QStringAlgorithms<const QString>::simplified_helper(str);
5170 }
5171 
5172 QString QString::simplified_helper(QString &str)
5173 {
5174     return QStringAlgorithms<QString>::simplified_helper(str);
5175 }
5176 
5177 namespace {
5178     template <typename StringView>
5179     StringView qt_trimmed(StringView s) noexcept
5180     {
5181         auto begin = s.begin();
5182         auto end = s.end();
5183         QStringAlgorithms<const StringView>::trimmed_helper_positions(begin, end);
5184         return StringView{begin, end};
5185     }
5186 }
5187 
5188 /*!
5189     \fn QStringView QtPrivate::trimmed(QStringView s)
5190     \fn QLatin1String QtPrivate::trimmed(QLatin1String s)
5191     \internal
5192     \relates QStringView
5193     \since 5.10
5194 
5195     Returns \a s with whitespace removed from the start and the end.
5196 
5197     Whitespace means any character for which QChar::isSpace() returns
5198     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5199     '\\f', '\\r', and ' '.
5200 
5201     \sa QString::trimmed(), QStringView::trimmed(), QLatin1String::trimmed()
5202 */
5203 QStringView QtPrivate::trimmed(QStringView s) noexcept
5204 {
5205     return qt_trimmed(s);
5206 }
5207 
5208 QLatin1String QtPrivate::trimmed(QLatin1String s) noexcept
5209 {
5210     return qt_trimmed(s);
5211 }
5212 
5213 /*!
5214     \fn QString QString::trimmed() const
5215 
5216     Returns a string that has whitespace removed from the start and
5217     the end.
5218 
5219     Whitespace means any character for which QChar::isSpace() returns
5220     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5221     '\\f', '\\r', and ' '.
5222 
5223     Example:
5224 
5225     \snippet qstring/main.cpp 82
5226 
5227     Unlike simplified(), trimmed() leaves internal whitespace alone.
5228 
5229     \sa simplified()
5230 */
5231 QString QString::trimmed_helper(const QString &str)
5232 {
5233     return QStringAlgorithms<const QString>::trimmed_helper(str);
5234 }
5235 
5236 QString QString::trimmed_helper(QString &str)
5237 {
5238     return QStringAlgorithms<QString>::trimmed_helper(str);
5239 }
5240 
5241 /*! \fn const QChar QString::at(qsizetype position) const
5242 
5243     Returns the character at the given index \a position in the
5244     string.
5245 
5246     The \a position must be a valid index position in the string
5247     (i.e., 0 <= \a position < size()).
5248 
5249     \sa operator[]()
5250 */
5251 
5252 /*!
5253     \fn QChar &QString::operator[](qsizetype position)
5254 
5255     Returns the character at the specified \a position in the string as a
5256     modifiable reference.
5257 
5258     Example:
5259 
5260     \snippet qstring/main.cpp 85
5261 
5262     \sa at()
5263 */
5264 
5265 /*!
5266     \fn const QChar QString::operator[](qsizetype position) const
5267 
5268     \overload operator[]()
5269 */
5270 
5271 /*!
5272     \fn QChar QString::front() const
5273     \since 5.10
5274 
5275     Returns the first character in the string.
5276     Same as \c{at(0)}.
5277 
5278     This function is provided for STL compatibility.
5279 
5280     \warning Calling this function on an empty string constitutes
5281     undefined behavior.
5282 
5283     \sa back(), at(), operator[]()
5284 */
5285 
5286 /*!
5287     \fn QChar QString::back() const
5288     \since 5.10
5289 
5290     Returns the last character in the string.
5291     Same as \c{at(size() - 1)}.
5292 
5293     This function is provided for STL compatibility.
5294 
5295     \warning Calling this function on an empty string constitutes
5296     undefined behavior.
5297 
5298     \sa front(), at(), operator[]()
5299 */
5300 
5301 /*!
5302     \fn QChar &QString::front()
5303     \since 5.10
5304 
5305     Returns a reference to the first character in the string.
5306     Same as \c{operator[](0)}.
5307 
5308     This function is provided for STL compatibility.
5309 
5310     \warning Calling this function on an empty string constitutes
5311     undefined behavior.
5312 
5313     \sa back(), at(), operator[]()
5314 */
5315 
5316 /*!
5317     \fn QChar &QString::back()
5318     \since 5.10
5319 
5320     Returns a reference to the last character in the string.
5321     Same as \c{operator[](size() - 1)}.
5322 
5323     This function is provided for STL compatibility.
5324 
5325     \warning Calling this function on an empty string constitutes
5326     undefined behavior.
5327 
5328     \sa front(), at(), operator[]()
5329 */
5330 
5331 /*!
5332     \fn void QString::truncate(qsizetype position)
5333 
5334     Truncates the string at the given \a position index.
5335 
5336     If the specified \a position index is beyond the end of the
5337     string, nothing happens.
5338 
5339     Example:
5340 
5341     \snippet qstring/main.cpp 83
5342 
5343     If \a position is negative, it is equivalent to passing zero.
5344 
5345     \sa chop(), resize(), left(), QStringRef::truncate()
5346 */
5347 
5348 void QString::truncate(qsizetype pos)
5349 {
5350     if (pos < size())
5351         resize(pos);
5352 }
5353 
5354 
5355 /*!
5356     Removes \a n characters from the end of the string.
5357 
5358     If \a n is greater than or equal to size(), the result is an
5359     empty string; if \a n is negative, it is equivalent to passing zero.
5360 
5361     Example:
5362     \snippet qstring/main.cpp 15
5363 
5364     If you want to remove characters from the \e beginning of the
5365     string, use remove() instead.
5366 
5367     \sa truncate(), resize(), remove(), QStringRef::chop()
5368 */
5369 void QString::chop(qsizetype n)
5370 {
5371     if (n > 0)
5372         resize(d.size - n);
5373 }
5374 
5375 /*!
5376     Sets every character in the string to character \a ch. If \a size
5377     is different from -1 (default), the string is resized to \a
5378     size beforehand.
5379 
5380     Example:
5381 
5382     \snippet qstring/main.cpp 21
5383 
5384     \sa resize()
5385 */
5386 
5387 QString& QString::fill(QChar ch, qsizetype size)
5388 {
5389     resize(size < 0 ? d.size : size);
5390     if (d.size) {
5391         QChar *i = (QChar*)d.data() + d.size;
5392         QChar *b = (QChar*)d.data();
5393         while (i != b)
5394            *--i = ch;
5395     }
5396     return *this;
5397 }
5398 
5399 /*!
5400     \fn qsizetype QString::length() const
5401 
5402     Returns the number of characters in this string.  Equivalent to
5403     size().
5404 
5405     \sa resize()
5406 */
5407 
5408 /*!
5409     \fn qsizetype QString::size() const
5410 
5411     Returns the number of characters in this string.
5412 
5413     The last character in the string is at position size() - 1.
5414 
5415     Example:
5416     \snippet qstring/main.cpp 58
5417 
5418     \sa isEmpty(), resize()
5419 */
5420 
5421 /*! \fn bool QString::isNull() const
5422 
5423     Returns \c true if this string is null; otherwise returns \c false.
5424 
5425     Example:
5426 
5427     \snippet qstring/main.cpp 28
5428 
5429     Qt makes a distinction between null strings and empty strings for
5430     historical reasons. For most applications, what matters is
5431     whether or not a string contains any data, and this can be
5432     determined using the isEmpty() function.
5433 
5434     \sa isEmpty()
5435 */
5436 
5437 /*! \fn bool QString::isEmpty() const
5438 
5439     Returns \c true if the string has no characters; otherwise returns
5440     \c false.
5441 
5442     Example:
5443 
5444     \snippet qstring/main.cpp 27
5445 
5446     \sa size()
5447 */
5448 
5449 /*! \fn QString &QString::operator+=(const QString &other)
5450 
5451     Appends the string \a other onto the end of this string and
5452     returns a reference to this string.
5453 
5454     Example:
5455 
5456     \snippet qstring/main.cpp 84
5457 
5458     This operation is typically very fast (\l{constant time}),
5459     because QString preallocates extra space at the end of the string
5460     data so it can grow without reallocating the entire string each
5461     time.
5462 
5463     \sa append(), prepend()
5464 */
5465 
5466 /*! \fn QString &QString::operator+=(QLatin1String str)
5467 
5468     \overload operator+=()
5469 
5470     Appends the Latin-1 string \a str to this string.
5471 */
5472 
5473 /*! \fn QString &QString::operator+=(const QByteArray &ba)
5474 
5475     \overload operator+=()
5476 
5477     Appends the byte array \a ba to this string. The byte array is converted
5478     to Unicode using the fromUtf8() function. If any NUL characters ('\\0')
5479     are embedded in the \a ba byte array, they will be included in the
5480     transformation.
5481 
5482     You can disable this function by defining \c
5483     QT_NO_CAST_FROM_ASCII when you compile your applications. This
5484     can be useful if you want to ensure that all user-visible strings
5485     go through QObject::tr(), for example.
5486 
5487     \sa QT_NO_CAST_FROM_ASCII
5488 */
5489 
5490 /*! \fn QString &QString::operator+=(const char *str)
5491 
5492     \overload operator+=()
5493 
5494     Appends the string \a str to this string. The const char pointer
5495     is converted to Unicode using the fromUtf8() function.
5496 
5497     You can disable this function by defining \c QT_NO_CAST_FROM_ASCII
5498     when you compile your applications. This can be useful if you want
5499     to ensure that all user-visible strings go through QObject::tr(),
5500     for example.
5501 
5502     \sa QT_NO_CAST_FROM_ASCII
5503 */
5504 
5505 /*! \fn QString &QString::operator+=(QStringView str)
5506     \since 6.0
5507     \overload operator+=()
5508 
5509     Appends the string view \a str to this string.
5510 */
5511 
5512 /*! \fn QString &QString::operator+=(QChar ch)
5513 
5514     \overload operator+=()
5515 
5516     Appends the character \a ch to the string.
5517 */
5518 
5519 /*!
5520     \fn bool operator==(const char *s1, const QString &s2)
5521 
5522     \overload  operator==()
5523     \relates QString
5524 
5525     Returns \c true if \a s1 is equal to \a s2; otherwise returns \c false.
5526     Note that no string is equal to \a s1 being 0.
5527 
5528     Equivalent to \c {s1 != 0 && compare(s1, s2) == 0}.
5529 */
5530 
5531 /*!
5532     \fn bool operator!=(const char *s1, const QString &s2)
5533     \relates QString
5534 
5535     Returns \c true if \a s1 is not equal to \a s2; otherwise returns
5536     \c false.
5537 
5538     For \a s1 != 0, this is equivalent to \c {compare(} \a s1, \a s2
5539     \c {) != 0}. Note that no string is equal to \a s1 being 0.
5540 */
5541 
5542 /*!
5543     \fn bool operator<(const char *s1, const QString &s2)
5544     \relates QString
5545 
5546     Returns \c true if \a s1 is lexically less than \a s2; otherwise
5547     returns \c false.  For \a s1 != 0, this is equivalent to \c
5548     {compare(s1, s2) < 0}.
5549 
5550     \sa {Comparing Strings}
5551 */
5552 
5553 /*!
5554     \fn bool operator<=(const char *s1, const QString &s2)
5555     \relates QString
5556 
5557     Returns \c true if \a s1 is lexically less than or equal to \a s2;
5558     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c
5559     {compare(s1, s2) <= 0}.
5560 
5561     \sa {Comparing Strings}
5562 */
5563 
5564 /*!
5565     \fn bool operator>(const char *s1, const QString &s2)
5566     \relates QString
5567 
5568     Returns \c true if \a s1 is lexically greater than \a s2; otherwise
5569     returns \c false.  Equivalent to \c {compare(s1, s2) > 0}.
5570 
5571     \sa {Comparing Strings}
5572 */
5573 
5574 /*!
5575     \fn bool operator>=(const char *s1, const QString &s2)
5576     \relates QString
5577 
5578     Returns \c true if \a s1 is lexically greater than or equal to \a s2;
5579     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c
5580     {compare(s1, s2) >= 0}.
5581 
5582     \sa {Comparing Strings}
5583 */
5584 
5585 /*!
5586     \fn const QString operator+(const QString &s1, const QString &s2)
5587     \relates QString
5588 
5589     Returns a string which is the result of concatenating \a s1 and \a
5590     s2.
5591 */
5592 
5593 /*!
5594     \fn const QString operator+(const QString &s1, const char *s2)
5595     \relates QString
5596 
5597     Returns a string which is the result of concatenating \a s1 and \a
5598     s2 (\a s2 is converted to Unicode using the QString::fromUtf8()
5599     function).
5600 
5601     \sa QString::fromUtf8()
5602 */
5603 
5604 /*!
5605     \fn const QString operator+(const char *s1, const QString &s2)
5606     \relates QString
5607 
5608     Returns a string which is the result of concatenating \a s1 and \a
5609     s2 (\a s1 is converted to Unicode using the QString::fromUtf8()
5610     function).
5611 
5612     \sa QString::fromUtf8()
5613 */
5614 
5615 /*!
5616     \fn int QString::compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs)
5617     \since 4.2
5618 
5619     Compares \a s1 with \a s2 and returns an integer less than, equal
5620     to, or greater than zero if \a s1 is less than, equal to, or
5621     greater than \a s2.
5622 
5623     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
5624     otherwise the comparison is case insensitive.
5625 
5626     Case sensitive comparison is based exclusively on the numeric
5627     Unicode values of the characters and is very fast, but is not what
5628     a human would expect.  Consider sorting user-visible strings with
5629     localeAwareCompare().
5630 
5631     \snippet qstring/main.cpp 16
5632 
5633     \sa operator==(), operator<(), operator>(), {Comparing Strings}
5634 */
5635 
5636 /*!
5637     \fn int QString::compare(const QString &s1, QLatin1String s2, Qt::CaseSensitivity cs)
5638     \since 4.2
5639     \overload compare()
5640 
5641     Performs a comparison of \a s1 and \a s2, using the case
5642     sensitivity setting \a cs.
5643 */
5644 
5645 /*!
5646     \fn int QString::compare(QLatin1String s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
5647 
5648     \since 4.2
5649     \overload compare()
5650 
5651     Performs a comparison of \a s1 and \a s2, using the case
5652     sensitivity setting \a cs.
5653 */
5654 
5655 /*!
5656     \fn int QString::compare(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
5657 
5658     \since 5.12
5659     \overload compare()
5660 
5661     Performs a comparison of this with \a s, using the case
5662     sensitivity setting \a cs.
5663 */
5664 
5665 /*!
5666     \fn int QString::compare(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
5667 
5668     \since 5.14
5669     \overload compare()
5670 
5671     Performs a comparison of this with \a ch, using the case
5672     sensitivity setting \a cs.
5673 */
5674 
5675 #if QT_STRINGVIEW_LEVEL < 2
5676 /*!
5677     \overload compare()
5678     \since 4.2
5679 
5680     Lexically compares this string with the \a other string and
5681     returns an integer less than, equal to, or greater than zero if
5682     this string is less than, equal to, or greater than the other
5683     string.
5684 
5685     Same as compare(*this, \a other, \a cs).
5686 */
5687 int QString::compare(const QString &other, Qt::CaseSensitivity cs) const noexcept
5688 {
5689     return qt_compare_strings(*this, other, cs);
5690 }
5691 #endif
5692 
5693 /*!
5694     \internal
5695     \since 4.5
5696 */
5697 int QString::compare_helper(const QChar *data1, qsizetype length1, const QChar *data2, qsizetype length2,
5698                             Qt::CaseSensitivity cs) noexcept
5699 {
5700     Q_ASSERT(length1 >= 0);
5701     Q_ASSERT(length2 >= 0);
5702     Q_ASSERT(data1 || length1 == 0);
5703     Q_ASSERT(data2 || length2 == 0);
5704     return qt_compare_strings(QStringView(data1, length1), QStringView(data2, length2), cs);
5705 }
5706 
5707 /*!
5708     \overload compare()
5709     \since 4.2
5710 
5711     Same as compare(*this, \a other, \a cs).
5712 */
5713 int QString::compare(QLatin1String other, Qt::CaseSensitivity cs) const noexcept
5714 {
5715     return qt_compare_strings(*this, other, cs);
5716 }
5717 
5718 /*!
5719     \internal
5720     \since 5.0
5721 */
5722 int QString::compare_helper(const QChar *data1, qsizetype length1, const char *data2, qsizetype length2,
5723                             Qt::CaseSensitivity cs)
5724 {
5725     Q_ASSERT(length1 >= 0);
5726     Q_ASSERT(data1 || length1 == 0);
5727     if (!data2)
5728         return length1;
5729     if (Q_UNLIKELY(length2 < 0))
5730         length2 = qsizetype(strlen(data2));
5731     // ### make me nothrow in all cases
5732     QVarLengthArray<ushort> s2(length2);
5733     const auto beg = reinterpret_cast<QChar *>(s2.data());
5734     const auto end = QUtf8::convertToUnicode(beg, data2, length2);
5735     return qt_compare_strings(QStringView(data1, length1), QStringView(beg, end - beg), cs);
5736 }
5737 
5738 /*!
5739   \fn int QString::compare(const QString &s1, QStringView s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
5740   \overload compare()
5741 */
5742 
5743 /*!
5744   \fn int QString::compare(QStringView s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
5745   \overload compare()
5746 */
5747 
5748 /*!
5749     \internal
5750     \since 4.5
5751 */
5752 int QString::compare_helper(const QChar *data1, qsizetype length1, QLatin1String s2,
5753                             Qt::CaseSensitivity cs) noexcept
5754 {
5755     Q_ASSERT(length1 >= 0);
5756     Q_ASSERT(data1 || length1 == 0);
5757     return qt_compare_strings(QStringView(data1, length1), s2, cs);
5758 }
5759 
5760 /*!
5761     \fn int QString::localeAwareCompare(const QString & s1, const QString & s2)
5762 
5763     Compares \a s1 with \a s2 and returns an integer less than, equal
5764     to, or greater than zero if \a s1 is less than, equal to, or
5765     greater than \a s2.
5766 
5767     The comparison is performed in a locale- and also
5768     platform-dependent manner. Use this function to present sorted
5769     lists of strings to the user.
5770 
5771     \sa compare(), QLocale, {Comparing Strings}
5772 */
5773 
5774 /*!
5775     \fn int QString::localeAwareCompare(QStringView other) const
5776     \since 6.0
5777     \overload localeAwareCompare()
5778 
5779     Compares this string with the \a other string and returns an
5780     integer less than, equal to, or greater than zero if this string
5781     is less than, equal to, or greater than the \a other string.
5782 
5783     The comparison is performed in a locale- and also
5784     platform-dependent manner. Use this function to present sorted
5785     lists of strings to the user.
5786 
5787     Same as \c {localeAwareCompare(*this, other)}.
5788 
5789     \sa {Comparing Strings}
5790 */
5791 
5792 /*!
5793     \fn int QString::localeAwareCompare(QStringView s1, QStringView s2)
5794     \since 6.0
5795     \overload localeAwareCompare()
5796 
5797     Compares \a s1 with \a s2 and returns an integer less than, equal
5798     to, or greater than zero if \a s1 is less than, equal to, or
5799     greater than \a s2.
5800 
5801     The comparison is performed in a locale- and also
5802     platform-dependent manner. Use this function to present sorted
5803     lists of strings to the user.
5804 
5805     \sa {Comparing Strings}
5806 */
5807 
5808 
5809 #if !defined(CSTR_LESS_THAN)
5810 #define CSTR_LESS_THAN    1
5811 #define CSTR_EQUAL        2
5812 #define CSTR_GREATER_THAN 3
5813 #endif
5814 
5815 /*!
5816     \overload localeAwareCompare()
5817 
5818     Compares this string with the \a other string and returns an
5819     integer less than, equal to, or greater than zero if this string
5820     is less than, equal to, or greater than the \a other string.
5821 
5822     The comparison is performed in a locale- and also
5823     platform-dependent manner. Use this function to present sorted
5824     lists of strings to the user.
5825 
5826     Same as \c {localeAwareCompare(*this, other)}.
5827 
5828     \sa {Comparing Strings}
5829 */
5830 int QString::localeAwareCompare(const QString &other) const
5831 {
5832     return localeAwareCompare_helper(constData(), length(), other.constData(), other.length());
5833 }
5834 
5835 #if QT_CONFIG(icu)
5836 Q_GLOBAL_STATIC(QThreadStorage<QCollator>, defaultCollator)
5837 #endif
5838 
5839 /*!
5840     \internal
5841     \since 4.5
5842 */
5843 int QString::localeAwareCompare_helper(const QChar *data1, qsizetype length1,
5844                                        const QChar *data2, qsizetype length2)
5845 {
5846     Q_ASSERT(length1 >= 0);
5847     Q_ASSERT(data1 || length1 == 0);
5848     Q_ASSERT(length2 >= 0);
5849     Q_ASSERT(data2 || length2 == 0);
5850 
5851     // do the right thing for null and empty
5852     if (length1 == 0 || length2 == 0)
5853         return qt_compare_strings(QStringView(data1, length1), QStringView(data2, length2),
5854                                Qt::CaseSensitive);
5855 
5856 #if QT_CONFIG(icu)
5857     if (!defaultCollator()->hasLocalData())
5858         defaultCollator()->setLocalData(QCollator());
5859     return defaultCollator()->localData().compare(data1, length1, data2, length2);
5860 #else
5861     const QString lhs = QString::fromRawData(data1, length1).normalized(QString::NormalizationForm_C);
5862     const QString rhs = QString::fromRawData(data2, length2).normalized(QString::NormalizationForm_C);
5863 #  if defined(Q_OS_WIN)
5864     int res = CompareStringEx(LOCALE_NAME_USER_DEFAULT, 0, (LPWSTR)lhs.constData(), lhs.length(), (LPWSTR)rhs.constData(), rhs.length(), NULL, NULL, 0);
5865 
5866     switch (res) {
5867     case CSTR_LESS_THAN:
5868         return -1;
5869     case CSTR_GREATER_THAN:
5870         return 1;
5871     default:
5872         return 0;
5873     }
5874 #  elif defined (Q_OS_DARWIN)
5875     // Use CFStringCompare for comparing strings on Mac. This makes Qt order
5876     // strings the same way as native applications do, and also respects
5877     // the "Order for sorted lists" setting in the International preferences
5878     // panel.
5879     const CFStringRef thisString =
5880         CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
5881             reinterpret_cast<const UniChar *>(lhs.constData()), lhs.length(), kCFAllocatorNull);
5882     const CFStringRef otherString =
5883         CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
5884             reinterpret_cast<const UniChar *>(rhs.constData()), rhs.length(), kCFAllocatorNull);
5885 
5886     const int result = CFStringCompare(thisString, otherString, kCFCompareLocalized);
5887     CFRelease(thisString);
5888     CFRelease(otherString);
5889     return result;
5890 #  elif defined(Q_OS_UNIX)
5891     // declared in <string.h>
5892     int delta = strcoll(lhs.toLocal8Bit().constData(), rhs.toLocal8Bit().constData());
5893     if (delta == 0)
5894         delta = qt_compare_strings(lhs, rhs, Qt::CaseSensitive);
5895     return delta;
5896 #  else
5897 #     error "This case shouldn't happen"
5898     return qt_compare_strings(lhs, rhs, Qt::CaseSensitive);
5899 #  endif
5900 #endif // !QT_CONFIG(icu)
5901 }
5902 
5903 
5904 /*!
5905     \fn const QChar *QString::unicode() const
5906 
5907     Returns a Unicode representation of the string.
5908     The result remains valid until the string is modified.
5909 
5910     \note The returned string may not be '\\0'-terminated.
5911     Use size() to determine the length of the array.
5912 
5913     \sa utf16(), fromRawData()
5914 */
5915 
5916 /*!
5917     \fn const ushort *QString::utf16() const
5918 
5919     Returns the QString as a '\\0\'-terminated array of unsigned
5920     shorts. The result remains valid until the string is modified.
5921 
5922     The returned string is in host byte order.
5923 
5924     \sa unicode()
5925 */
5926 
5927 const ushort *QString::utf16() const
5928 {
5929     if (!d->isMutable()) {
5930         // ensure '\0'-termination for ::fromRawData strings
5931         const_cast<QString*>(this)->reallocData(size_t(d.size) + 1u);
5932     }
5933     return reinterpret_cast<const ushort *>(d.data());
5934 }
5935 
5936 /*!
5937     Returns a string of size \a width that contains this string
5938     padded by the \a fill character.
5939 
5940     If \a truncate is \c false and the size() of the string is more than
5941     \a width, then the returned string is a copy of the string.
5942 
5943     \snippet qstring/main.cpp 32
5944 
5945     If \a truncate is \c true and the size() of the string is more than
5946     \a width, then any characters in a copy of the string after
5947     position \a width are removed, and the copy is returned.
5948 
5949     \snippet qstring/main.cpp 33
5950 
5951     \sa rightJustified()
5952 */
5953 
5954 QString QString::leftJustified(qsizetype width, QChar fill, bool truncate) const
5955 {
5956     QString result;
5957     qsizetype len = length();
5958     qsizetype padlen = width - len;
5959     if (padlen > 0) {
5960         result.resize(len+padlen);
5961         if (len)
5962             memcpy(result.d.data(), d.data(), sizeof(QChar)*len);
5963         QChar *uc = (QChar*)result.d.data() + len;
5964         while (padlen--)
5965            * uc++ = fill;
5966     } else {
5967         if (truncate)
5968             result = left(width);
5969         else
5970             result = *this;
5971     }
5972     return result;
5973 }
5974 
5975 /*!
5976     Returns a string of size() \a width that contains the \a fill
5977     character followed by the string. For example:
5978 
5979     \snippet qstring/main.cpp 49
5980 
5981     If \a truncate is \c false and the size() of the string is more than
5982     \a width, then the returned string is a copy of the string.
5983 
5984     If \a truncate is true and the size() of the string is more than
5985     \a width, then the resulting string is truncated at position \a
5986     width.
5987 
5988     \snippet qstring/main.cpp 50
5989 
5990     \sa leftJustified()
5991 */
5992 
5993 QString QString::rightJustified(qsizetype width, QChar fill, bool truncate) const
5994 {
5995     QString result;
5996     qsizetype len = length();
5997     qsizetype padlen = width - len;
5998     if (padlen > 0) {
5999         result.resize(len+padlen);
6000         QChar *uc = (QChar*)result.d.data();
6001         while (padlen--)
6002            * uc++ = fill;
6003         if (len)
6004           memcpy(static_cast<void *>(uc), static_cast<const void *>(d.data()), sizeof(QChar)*len);
6005     } else {
6006         if (truncate)
6007             result = left(width);
6008         else
6009             result = *this;
6010     }
6011     return result;
6012 }
6013 
6014 /*!
6015     \fn QString QString::toLower() const
6016 
6017     Returns a lowercase copy of the string.
6018 
6019     \snippet qstring/main.cpp 75
6020 
6021     The case conversion will always happen in the 'C' locale. For locale dependent
6022     case folding use QLocale::toLower()
6023 
6024     \sa toUpper(), QLocale::toLower()
6025 */
6026 
6027 namespace QUnicodeTables {
6028 /*
6029     \internal
6030     Converts the \a str string starting from the position pointed to by the \a
6031     it iterator, using the Unicode case traits \c Traits, and returns the
6032     result. The input string must not be empty (the convertCase function below
6033     guarantees that).
6034 
6035     The string type \c{T} is also a template and is either \c{const QString} or
6036     \c{QString}. This function can do both copy-conversion and in-place
6037     conversion depending on the state of the \a str parameter:
6038     \list
6039        \li \c{T} is \c{const QString}: copy-convert
6040        \li \c{T} is \c{QString} and its refcount != 1: copy-convert
6041        \li \c{T} is \c{QString} and its refcount == 1: in-place convert
6042     \endlist
6043 
6044     In copy-convert mode, the local variable \c{s} is detached from the input
6045     \a str. In the in-place convert mode, \a str is in moved-from state (which
6046     this function requires to be a valid, empty string) and \c{s} contains the
6047     only copy of the string, without reallocation (thus, \a it is still valid).
6048 
6049     There is one pathological case left: when the in-place conversion needs to
6050     reallocate memory to grow the buffer. In that case, we need to adjust the \a
6051     it pointer.
6052  */
6053 template <typename T>
6054 Q_NEVER_INLINE
6055 static QString detachAndConvertCase(T &str, QStringIterator it, QUnicodeTables::Case which)
6056 {
6057     Q_ASSERT(!str.isEmpty());
6058     QString s = std::move(str);             // will copy if T is const QString
6059     QChar *pp = s.begin() + it.index(); // will detach if necessary
6060 
6061     do {
6062         const auto raw = it.nextUnchecked();
6063         if (raw > QChar::LastValidCodePoint) {
6064             // Replace invalid surrogate pair:
6065             *pp++ = u'\ufffd';
6066             continue;
6067         }
6068         const auto folded = fullConvertCase(raw, which);
6069         if (Q_UNLIKELY(folded.size() > 1)) {
6070             if (folded.chars[0] == *pp && folded.size() == 2) {
6071                 // special case: only second actually changed (e.g. surrogate pairs),
6072                 // avoid slow case
6073                 ++pp;
6074                 *pp++ = folded.chars[1];
6075             } else {
6076                 // slow path: the string is growing
6077                 qsizetype inpos = it.index() - 1;
6078                 qsizetype outpos = pp - s.constBegin();
6079 
6080                 s.replace(outpos, 1, reinterpret_cast<const QChar *>(folded.data()), folded.size());
6081                 pp = const_cast<QChar *>(s.constBegin()) + outpos + folded.size();
6082 
6083                 // do we need to adjust the input iterator too?
6084                 // if it is pointing to s's data, str is empty
6085                 if (str.isEmpty())
6086                     it = QStringIterator(s.constBegin(), inpos + folded.size(), s.constEnd());
6087             }
6088         } else {
6089             *pp++ = folded.chars[0];
6090         }
6091     } while (it.hasNext());
6092 
6093     return s;
6094 }
6095 
6096 template <typename T>
6097 static QString convertCase(T &str, QUnicodeTables::Case which)
6098 {
6099     const QChar *p = str.constBegin();
6100     const QChar *e = p + str.size();
6101 
6102     // this avoids out of bounds check in the loop
6103     while (e != p && e[-1].isHighSurrogate())
6104         --e;
6105 
6106     QStringIterator it(p, e);
6107     while (it.hasNext()) {
6108         const char32_t uc = it.nextUnchecked();
6109         if (uc <= QChar::LastValidCodePoint && qGetProp(uc)->cases[which].diff) {
6110             it.recedeUnchecked();
6111             return detachAndConvertCase(str, it, which);
6112         }
6113     }
6114     return std::move(str);
6115 }
6116 } // namespace QUnicodeTables
6117 
6118 QString QString::toLower_helper(const QString &str)
6119 {
6120     return QUnicodeTables::convertCase(str, QUnicodeTables::LowerCase);
6121 }
6122 
6123 QString QString::toLower_helper(QString &str)
6124 {
6125     return QUnicodeTables::convertCase(str, QUnicodeTables::LowerCase);
6126 }
6127 
6128 /*!
6129     \fn QString QString::toCaseFolded() const
6130 
6131     Returns the case folded equivalent of the string. For most Unicode
6132     characters this is the same as toLower().
6133 */
6134 
6135 QString QString::toCaseFolded_helper(const QString &str)
6136 {
6137     return QUnicodeTables::convertCase(str, QUnicodeTables::CaseFold);
6138 }
6139 
6140 QString QString::toCaseFolded_helper(QString &str)
6141 {
6142     return QUnicodeTables::convertCase(str, QUnicodeTables::CaseFold);
6143 }
6144 
6145 /*!
6146     \fn QString QString::toUpper() const
6147 
6148     Returns an uppercase copy of the string.
6149 
6150     \snippet qstring/main.cpp 81
6151 
6152     The case conversion will always happen in the 'C' locale. For locale dependent
6153     case folding use QLocale::toUpper()
6154 
6155     \sa toLower(), QLocale::toLower()
6156 */
6157 
6158 QString QString::toUpper_helper(const QString &str)
6159 {
6160     return QUnicodeTables::convertCase(str, QUnicodeTables::UpperCase);
6161 }
6162 
6163 QString QString::toUpper_helper(QString &str)
6164 {
6165     return QUnicodeTables::convertCase(str, QUnicodeTables::UpperCase);
6166 }
6167 
6168 // ### Qt 6: Consider whether this function shouldn't be removed See task 202871.
6169 /*!
6170     \since 5.5
6171 
6172     Safely builds a formatted string from the format string \a cformat
6173     and an arbitrary list of arguments.
6174 
6175     The format string supports the conversion specifiers, length modifiers,
6176     and flags provided by printf() in the standard C++ library. The \a cformat
6177     string and \c{%s} arguments must be UTF-8 encoded.
6178 
6179     \note The \c{%lc} escape sequence expects a unicode character of type
6180     \c char16_t, or \c ushort (as returned by QChar::unicode()).
6181     The \c{%ls} escape sequence expects a pointer to a zero-terminated array
6182     of unicode characters of type \c char16_t, or ushort (as returned by
6183     QString::utf16()). This is at odds with the printf() in the standard C++
6184     library, which defines \c {%lc} to print a wchar_t and \c{%ls} to print
6185     a \c{wchar_t*}, and might also produce compiler warnings on platforms
6186     where the size of \c {wchar_t} is not 16 bits.
6187 
6188     \warning We do not recommend using QString::asprintf() in new Qt
6189     code. Instead, consider using QTextStream or arg(), both of
6190     which support Unicode strings seamlessly and are type-safe.
6191     Here is an example that uses QTextStream:
6192 
6193     \snippet qstring/main.cpp 64
6194 
6195     For \l {QObject::tr()}{translations}, especially if the strings
6196     contains more than one escape sequence, you should consider using
6197     the arg() function instead. This allows the order of the
6198     replacements to be controlled by the translator.
6199 
6200     \sa arg()
6201 */
6202 
6203 QString QString::asprintf(const char *cformat, ...)
6204 {
6205     va_list ap;
6206     va_start(ap, cformat);
6207     const QString s = vasprintf(cformat, ap);
6208     va_end(ap);
6209     return s;
6210 }
6211 
6212 static void append_utf8(QString &qs, const char *cs, int len)
6213 {
6214     const int oldSize = qs.size();
6215     qs.resize(oldSize + len);
6216     const QChar *newEnd = QUtf8::convertToUnicode(qs.data() + oldSize, cs, len);
6217     qs.resize(newEnd - qs.constData());
6218 }
6219 
6220 static uint parse_flag_characters(const char * &c) noexcept
6221 {
6222     uint flags = QLocaleData::ZeroPadExponent;
6223     while (true) {
6224         switch (*c) {
6225         case '#':
6226             flags |= QLocaleData::ShowBase | QLocaleData::AddTrailingZeroes
6227                     | QLocaleData::ForcePoint;
6228             break;
6229         case '0': flags |= QLocaleData::ZeroPadded; break;
6230         case '-': flags |= QLocaleData::LeftAdjusted; break;
6231         case ' ': flags |= QLocaleData::BlankBeforePositive; break;
6232         case '+': flags |= QLocaleData::AlwaysShowSign; break;
6233         case '\'': flags |= QLocaleData::GroupDigits; break;
6234         default: return flags;
6235         }
6236         ++c;
6237     }
6238 }
6239 
6240 static int parse_field_width(const char * &c)
6241 {
6242     Q_ASSERT(qIsDigit(*c));
6243 
6244     // can't be negative - started with a digit
6245     // contains at least one digit
6246     const char *endp;
6247     bool ok;
6248     const qulonglong result = qstrtoull(c, &endp, 10, &ok);
6249     c = endp;
6250     while (qIsDigit(*c)) // preserve Qt 5.5 behavior of consuming all digits, no matter how many
6251         ++c;
6252     return ok && result < qulonglong(std::numeric_limits<int>::max()) ? int(result) : 0;
6253 }
6254 
6255 enum LengthMod { lm_none, lm_hh, lm_h, lm_l, lm_ll, lm_L, lm_j, lm_z, lm_t };
6256 
6257 static inline bool can_consume(const char * &c, char ch) noexcept
6258 {
6259     if (*c == ch) {
6260         ++c;
6261         return true;
6262     }
6263     return false;
6264 }
6265 
6266 static LengthMod parse_length_modifier(const char * &c) noexcept
6267 {
6268     switch (*c++) {
6269     case 'h': return can_consume(c, 'h') ? lm_hh : lm_h;
6270     case 'l': return can_consume(c, 'l') ? lm_ll : lm_l;
6271     case 'L': return lm_L;
6272     case 'j': return lm_j;
6273     case 'z':
6274     case 'Z': return lm_z;
6275     case 't': return lm_t;
6276     }
6277     --c; // don't consume *c - it wasn't a flag
6278     return lm_none;
6279 }
6280 
6281 /*!
6282     \fn QString QString::vasprintf(const char *cformat, va_list ap)
6283     \since 5.5
6284 
6285     Equivalent method to asprintf(), but takes a va_list \a ap
6286     instead a list of variable arguments. See the asprintf()
6287     documentation for an explanation of \a cformat.
6288 
6289     This method does not call the va_end macro, the caller
6290     is responsible to call va_end on \a ap.
6291 
6292     \sa asprintf()
6293 */
6294 
6295 QString QString::vasprintf(const char *cformat, va_list ap)
6296 {
6297     if (!cformat || !*cformat) {
6298         // Qt 1.x compat
6299         return fromLatin1("");
6300     }
6301 
6302     // Parse cformat
6303 
6304     QString result;
6305     const char *c = cformat;
6306     for (;;) {
6307         // Copy non-escape chars to result
6308         const char *cb = c;
6309         while (*c != '\0' && *c != '%')
6310             c++;
6311         append_utf8(result, cb, qsizetype(c - cb));
6312 
6313         if (*c == '\0')
6314             break;
6315 
6316         // Found '%'
6317         const char *escape_start = c;
6318         ++c;
6319 
6320         if (*c == '\0') {
6321             result.append(QLatin1Char('%')); // a % at the end of the string - treat as non-escape text
6322             break;
6323         }
6324         if (*c == '%') {
6325             result.append(QLatin1Char('%')); // %%
6326             ++c;
6327             continue;
6328         }
6329 
6330         uint flags = parse_flag_characters(c);
6331 
6332         if (*c == '\0') {
6333             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6334             break;
6335         }
6336 
6337         // Parse field width
6338         int width = -1; // -1 means unspecified
6339         if (qIsDigit(*c)) {
6340             width = parse_field_width(c);
6341         } else if (*c == '*') { // can't parse this in another function, not portably, at least
6342             width = va_arg(ap, int);
6343             if (width < 0)
6344                 width = -1; // treat all negative numbers as unspecified
6345             ++c;
6346         }
6347 
6348         if (*c == '\0') {
6349             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6350             break;
6351         }
6352 
6353         // Parse precision
6354         int precision = -1; // -1 means unspecified
6355         if (*c == '.') {
6356             ++c;
6357             if (qIsDigit(*c)) {
6358                 precision = parse_field_width(c);
6359             } else if (*c == '*') { // can't parse this in another function, not portably, at least
6360                 precision = va_arg(ap, int);
6361                 if (precision < 0)
6362                     precision = -1; // treat all negative numbers as unspecified
6363                 ++c;
6364             }
6365         }
6366 
6367         if (*c == '\0') {
6368             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6369             break;
6370         }
6371 
6372         const LengthMod length_mod = parse_length_modifier(c);
6373 
6374         if (*c == '\0') {
6375             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6376             break;
6377         }
6378 
6379         // Parse the conversion specifier and do the conversion
6380         QString subst;
6381         switch (*c) {
6382             case 'd':
6383             case 'i': {
6384                 qint64 i;
6385                 switch (length_mod) {
6386                     case lm_none: i = va_arg(ap, int); break;
6387                     case lm_hh: i = va_arg(ap, int); break;
6388                     case lm_h: i = va_arg(ap, int); break;
6389                     case lm_l: i = va_arg(ap, long int); break;
6390                     case lm_ll: i = va_arg(ap, qint64); break;
6391                     case lm_j: i = va_arg(ap, long int); break;
6392                     case lm_z: i = va_arg(ap, size_t); break;
6393                     case lm_t: i = va_arg(ap, int); break;
6394                     default: i = 0; break;
6395                 }
6396                 subst = QLocaleData::c()->longLongToString(i, precision, 10, width, flags);
6397                 ++c;
6398                 break;
6399             }
6400             case 'o':
6401             case 'u':
6402             case 'x':
6403             case 'X': {
6404                 quint64 u;
6405                 switch (length_mod) {
6406                     case lm_none: u = va_arg(ap, uint); break;
6407                     case lm_hh: u = va_arg(ap, uint); break;
6408                     case lm_h: u = va_arg(ap, uint); break;
6409                     case lm_l: u = va_arg(ap, ulong); break;
6410                     case lm_ll: u = va_arg(ap, quint64); break;
6411                     case lm_z: u = va_arg(ap, size_t); break;
6412                     default: u = 0; break;
6413                 }
6414 
6415                 if (qIsUpper(*c))
6416                     flags |= QLocaleData::CapitalEorX;
6417 
6418                 int base = 10;
6419                 switch (qToLower(*c)) {
6420                     case 'o':
6421                         base = 8; break;
6422                     case 'u':
6423                         base = 10; break;
6424                     case 'x':
6425                         base = 16; break;
6426                     default: break;
6427                 }
6428                 subst = QLocaleData::c()->unsLongLongToString(u, precision, base, width, flags);
6429                 ++c;
6430                 break;
6431             }
6432             case 'E':
6433             case 'e':
6434             case 'F':
6435             case 'f':
6436             case 'G':
6437             case 'g':
6438             case 'A':
6439             case 'a': {
6440                 double d;
6441                 if (length_mod == lm_L)
6442                     d = va_arg(ap, long double); // not supported - converted to a double
6443                 else
6444                     d = va_arg(ap, double);
6445 
6446                 if (qIsUpper(*c))
6447                     flags |= QLocaleData::CapitalEorX;
6448 
6449                 QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
6450                 switch (qToLower(*c)) {
6451                     case 'e': form = QLocaleData::DFExponent; break;
6452                     case 'a':                             // not supported - decimal form used instead
6453                     case 'f': form = QLocaleData::DFDecimal; break;
6454                     case 'g': form = QLocaleData::DFSignificantDigits; break;
6455                     default: break;
6456                 }
6457                 subst = QLocaleData::c()->doubleToString(d, precision, form, width, flags);
6458                 ++c;
6459                 break;
6460             }
6461             case 'c': {
6462                 if (length_mod == lm_l)
6463                     subst = QChar::fromUcs2(va_arg(ap, int));
6464                 else
6465                     subst = QLatin1Char((uchar) va_arg(ap, int));
6466                 ++c;
6467                 break;
6468             }
6469             case 's': {
6470                 if (length_mod == lm_l) {
6471                     const ushort *buff = va_arg(ap, const ushort*);
6472                     const ushort *ch = buff;
6473                     while (*ch != 0)
6474                         ++ch;
6475                     subst.setUtf16(buff, ch - buff);
6476                 } else
6477                     subst = QString::fromUtf8(va_arg(ap, const char*));
6478                 if (precision != -1)
6479                     subst.truncate(precision);
6480                 ++c;
6481                 break;
6482             }
6483             case 'p': {
6484                 void *arg = va_arg(ap, void*);
6485                 const quint64 i = reinterpret_cast<quintptr>(arg);
6486                 flags |= QLocaleData::ShowBase;
6487                 subst = QLocaleData::c()->unsLongLongToString(i, precision, 16, width, flags);
6488                 ++c;
6489                 break;
6490             }
6491             case 'n':
6492                 switch (length_mod) {
6493                     case lm_hh: {
6494                         signed char *n = va_arg(ap, signed char*);
6495                         *n = result.length();
6496                         break;
6497                     }
6498                     case lm_h: {
6499                         short int *n = va_arg(ap, short int*);
6500                         *n = result.length();
6501                             break;
6502                     }
6503                     case lm_l: {
6504                         long int *n = va_arg(ap, long int*);
6505                         *n = result.length();
6506                         break;
6507                     }
6508                     case lm_ll: {
6509                         qint64 *n = va_arg(ap, qint64*);
6510                         *n = result.length();
6511                         break;
6512                     }
6513                     default: {
6514                         int *n = va_arg(ap, int*);
6515                         *n = result.length();
6516                         break;
6517                     }
6518                 }
6519                 ++c;
6520                 break;
6521 
6522             default: // bad escape, treat as non-escape text
6523                 for (const char *cc = escape_start; cc != c; ++cc)
6524                     result.append(QLatin1Char(*cc));
6525                 continue;
6526         }
6527 
6528         if (flags & QLocaleData::LeftAdjusted)
6529             result.append(subst.leftJustified(width));
6530         else
6531             result.append(subst.rightJustified(width));
6532     }
6533 
6534     return result;
6535 }
6536 
6537 /*!
6538     Returns the string converted to a \c{long long} using base \a
6539     base, which is 10 by default and must be between 2 and 36, or 0.
6540     Returns 0 if the conversion fails.
6541 
6542     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6543     to \c false, and success by setting *\a{ok} to \c true.
6544 
6545     If \a base is 0, the C language convention is used: If the string
6546     begins with "0x", base 16 is used; if the string begins with "0",
6547     base 8 is used; otherwise, base 10 is used.
6548 
6549     The string conversion will always happen in the 'C' locale. For locale
6550     dependent conversion use QLocale::toLongLong()
6551 
6552     Example:
6553 
6554     \snippet qstring/main.cpp 74
6555 
6556     This function ignores leading and trailing whitespace.
6557 
6558     \sa number(), toULongLong(), toInt(), QLocale::toLongLong()
6559 */
6560 
6561 qint64 QString::toLongLong(bool *ok, int base) const
6562 {
6563     return toIntegral_helper<qlonglong>(*this, ok, base);
6564 }
6565 
6566 qlonglong QString::toIntegral_helper(QStringView string, bool *ok, int base)
6567 {
6568 #if defined(QT_CHECK_RANGE)
6569     if (base != 0 && (base < 2 || base > 36)) {
6570         qWarning("QString::toULongLong: Invalid base (%d)", base);
6571         base = 10;
6572     }
6573 #endif
6574 
6575     return QLocaleData::c()->stringToLongLong(string, base, ok, QLocale::RejectGroupSeparator);
6576 }
6577 
6578 
6579 /*!
6580     Returns the string converted to an \c{unsigned long long} using base \a
6581     base, which is 10 by default and must be between 2 and 36, or 0.
6582     Returns 0 if the conversion fails.
6583 
6584     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6585     to \c false, and success by setting *\a{ok} to \c true.
6586 
6587     If \a base is 0, the C language convention is used: If the string
6588     begins with "0x", base 16 is used; if the string begins with "0",
6589     base 8 is used; otherwise, base 10 is used.
6590 
6591     The string conversion will always happen in the 'C' locale. For locale
6592     dependent conversion use QLocale::toULongLong()
6593 
6594     Example:
6595 
6596     \snippet qstring/main.cpp 79
6597 
6598     This function ignores leading and trailing whitespace.
6599 
6600     \sa number(), toLongLong(), QLocale::toULongLong()
6601 */
6602 
6603 quint64 QString::toULongLong(bool *ok, int base) const
6604 {
6605     return toIntegral_helper<qulonglong>(*this, ok, base);
6606 }
6607 
6608 qulonglong QString::toIntegral_helper(QStringView string, bool *ok, uint base)
6609 {
6610 #if defined(QT_CHECK_RANGE)
6611     if (base != 0 && (base < 2 || base > 36)) {
6612         qWarning("QString::toULongLong: Invalid base (%d)", base);
6613         base = 10;
6614     }
6615 #endif
6616 
6617     return QLocaleData::c()->stringToUnsLongLong(string, base, ok, QLocale::RejectGroupSeparator);
6618 }
6619 
6620 /*!
6621     \fn long QString::toLong(bool *ok, int base) const
6622 
6623     Returns the string converted to a \c long using base \a
6624     base, which is 10 by default and must be between 2 and 36, or 0.
6625     Returns 0 if the conversion fails.
6626 
6627     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6628     to \c false, and success by setting *\a{ok} to \c true.
6629 
6630     If \a base is 0, the C language convention is used: If the string
6631     begins with "0x", base 16 is used; if the string begins with "0",
6632     base 8 is used; otherwise, base 10 is used.
6633 
6634     The string conversion will always happen in the 'C' locale. For locale
6635     dependent conversion use QLocale::toLongLong()
6636 
6637     Example:
6638 
6639     \snippet qstring/main.cpp 73
6640 
6641     This function ignores leading and trailing whitespace.
6642 
6643     \sa number(), toULong(), toInt(), QLocale::toInt()
6644 */
6645 
6646 long QString::toLong(bool *ok, int base) const
6647 {
6648     return toIntegral_helper<long>(*this, ok, base);
6649 }
6650 
6651 /*!
6652     \fn ulong QString::toULong(bool *ok, int base) const
6653 
6654     Returns the string converted to an \c{unsigned long} using base \a
6655     base, which is 10 by default and must be between 2 and 36, or 0.
6656     Returns 0 if the conversion fails.
6657 
6658     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6659     to \c false, and success by setting *\a{ok} to \c true.
6660 
6661     If \a base is 0, the C language convention is used: If the string
6662     begins with "0x", base 16 is used; if the string begins with "0",
6663     base 8 is used; otherwise, base 10 is used.
6664 
6665     The string conversion will always happen in the 'C' locale. For locale
6666     dependent conversion use QLocale::toULongLong()
6667 
6668     Example:
6669 
6670     \snippet qstring/main.cpp 78
6671 
6672     This function ignores leading and trailing whitespace.
6673 
6674     \sa number(), QLocale::toUInt()
6675 */
6676 
6677 ulong QString::toULong(bool *ok, int base) const
6678 {
6679     return toIntegral_helper<ulong>(*this, ok, base);
6680 }
6681 
6682 
6683 /*!
6684     Returns the string converted to an \c int using base \a
6685     base, which is 10 by default and must be between 2 and 36, or 0.
6686     Returns 0 if the conversion fails.
6687 
6688     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6689     to \c false, and success by setting *\a{ok} to \c true.
6690 
6691     If \a base is 0, the C language convention is used: If the string
6692     begins with "0x", base 16 is used; if the string begins with "0",
6693     base 8 is used; otherwise, base 10 is used.
6694 
6695     The string conversion will always happen in the 'C' locale. For locale
6696     dependent conversion use QLocale::toInt()
6697 
6698     Example:
6699 
6700     \snippet qstring/main.cpp 72
6701 
6702     This function ignores leading and trailing whitespace.
6703 
6704     \sa number(), toUInt(), toDouble(), QLocale::toInt()
6705 */
6706 
6707 int QString::toInt(bool *ok, int base) const
6708 {
6709     return toIntegral_helper<int>(*this, ok, base);
6710 }
6711 
6712 /*!
6713     Returns the string converted to an \c{unsigned int} using base \a
6714     base, which is 10 by default and must be between 2 and 36, or 0.
6715     Returns 0 if the conversion fails.
6716 
6717     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6718     to \c false, and success by setting *\a{ok} to \c true.
6719 
6720     If \a base is 0, the C language convention is used: If the string
6721     begins with "0x", base 16 is used; if the string begins with "0",
6722     base 8 is used; otherwise, base 10 is used.
6723 
6724     The string conversion will always happen in the 'C' locale. For locale
6725     dependent conversion use QLocale::toUInt()
6726 
6727     Example:
6728 
6729     \snippet qstring/main.cpp 77
6730 
6731     This function ignores leading and trailing whitespace.
6732 
6733     \sa number(), toInt(), QLocale::toUInt()
6734 */
6735 
6736 uint QString::toUInt(bool *ok, int base) const
6737 {
6738     return toIntegral_helper<uint>(*this, ok, base);
6739 }
6740 
6741 /*!
6742     Returns the string converted to a \c short using base \a
6743     base, which is 10 by default and must be between 2 and 36, or 0.
6744     Returns 0 if the conversion fails.
6745 
6746     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6747     to \c false, and success by setting *\a{ok} to \c true.
6748 
6749     If \a base is 0, the C language convention is used: If the string
6750     begins with "0x", base 16 is used; if the string begins with "0",
6751     base 8 is used; otherwise, base 10 is used.
6752 
6753     The string conversion will always happen in the 'C' locale. For locale
6754     dependent conversion use QLocale::toShort()
6755 
6756     Example:
6757 
6758     \snippet qstring/main.cpp 76
6759 
6760     This function ignores leading and trailing whitespace.
6761 
6762     \sa number(), toUShort(), toInt(), QLocale::toShort()
6763 */
6764 
6765 short QString::toShort(bool *ok, int base) const
6766 {
6767     return toIntegral_helper<short>(*this, ok, base);
6768 }
6769 
6770 /*!
6771     Returns the string converted to an \c{unsigned short} using base \a
6772     base, which is 10 by default and must be between 2 and 36, or 0.
6773     Returns 0 if the conversion fails.
6774 
6775     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6776     to \c false, and success by setting *\a{ok} to \c true.
6777 
6778     If \a base is 0, the C language convention is used: If the string
6779     begins with "0x", base 16 is used; if the string begins with "0",
6780     base 8 is used; otherwise, base 10 is used.
6781 
6782     The string conversion will always happen in the 'C' locale. For locale
6783     dependent conversion use QLocale::toUShort()
6784 
6785     Example:
6786 
6787     \snippet qstring/main.cpp 80
6788 
6789     This function ignores leading and trailing whitespace.
6790 
6791     \sa number(), toShort(), QLocale::toUShort()
6792 */
6793 
6794 ushort QString::toUShort(bool *ok, int base) const
6795 {
6796     return toIntegral_helper<ushort>(*this, ok, base);
6797 }
6798 
6799 
6800 /*!
6801     Returns the string converted to a \c double value.
6802 
6803     Returns an infinity if the conversion overflows or 0.0 if the
6804     conversion fails for other reasons (e.g. underflow).
6805 
6806     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6807     to \c false, and success by setting *\a{ok} to \c true.
6808 
6809     \snippet qstring/main.cpp 66
6810 
6811     \warning The QString content may only contain valid numerical characters
6812     which includes the plus/minus sign, the character e used in scientific
6813     notation, and the decimal point. Including the unit or additional characters
6814     leads to a conversion error.
6815 
6816     \snippet qstring/main.cpp 67
6817 
6818     The string conversion will always happen in the 'C' locale. For locale
6819     dependent conversion use QLocale::toDouble()
6820 
6821     \snippet qstring/main.cpp 68
6822 
6823     For historical reasons, this function does not handle
6824     thousands group separators. If you need to convert such numbers,
6825     use QLocale::toDouble().
6826 
6827     \snippet qstring/main.cpp 69
6828 
6829     This function ignores leading and trailing whitespace.
6830 
6831     \sa number(), QLocale::setDefault(), QLocale::toDouble(), trimmed()
6832 */
6833 
6834 double QString::toDouble(bool *ok) const
6835 {
6836     return QLocaleData::c()->stringToDouble(*this, ok, QLocale::RejectGroupSeparator);
6837 }
6838 
6839 /*!
6840     Returns the string converted to a \c float value.
6841 
6842     Returns an infinity if the conversion overflows or 0.0 if the
6843     conversion fails for other reasons (e.g. underflow).
6844 
6845     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6846     to \c false, and success by setting *\a{ok} to \c true.
6847 
6848     \warning The QString content may only contain valid numerical characters
6849     which includes the plus/minus sign, the character e used in scientific
6850     notation, and the decimal point. Including the unit or additional characters
6851     leads to a conversion error.
6852 
6853     The string conversion will always happen in the 'C' locale. For locale
6854     dependent conversion use QLocale::toFloat()
6855 
6856     For historical reasons, this function does not handle
6857     thousands group separators. If you need to convert such numbers,
6858     use QLocale::toFloat().
6859 
6860     Example:
6861 
6862     \snippet qstring/main.cpp 71
6863 
6864     This function ignores leading and trailing whitespace.
6865 
6866     \sa number(), toDouble(), toInt(), QLocale::toFloat(), trimmed()
6867 */
6868 
6869 float QString::toFloat(bool *ok) const
6870 {
6871     return QLocaleData::convertDoubleToFloat(toDouble(ok), ok);
6872 }
6873 
6874 /*! \fn QString &QString::setNum(int n, int base)
6875 
6876     Sets the string to the printed value of \a n in the specified \a
6877     base, and returns a reference to the string.
6878 
6879     The base is 10 by default and must be between 2 and 36. For bases
6880     other than 10, \a n is treated as an unsigned integer.
6881 
6882     \snippet qstring/main.cpp 56
6883 
6884    The formatting always uses QLocale::C, i.e., English/UnitedStates.
6885    To get a localized string representation of a number, use
6886    QLocale::toString() with the appropriate locale.
6887 
6888    \sa number()
6889 */
6890 
6891 /*! \fn QString &QString::setNum(uint n, int base)
6892 
6893     \overload
6894 */
6895 
6896 /*! \fn QString &QString::setNum(long n, int base)
6897 
6898     \overload
6899 */
6900 
6901 /*! \fn QString &QString::setNum(ulong n, int base)
6902 
6903     \overload
6904 */
6905 
6906 /*!
6907     \overload
6908 */
6909 QString &QString::setNum(qlonglong n, int base)
6910 {
6911     return *this = number(n, base);
6912 }
6913 
6914 /*!
6915     \overload
6916 */
6917 QString &QString::setNum(qulonglong n, int base)
6918 {
6919     return *this = number(n, base);
6920 }
6921 
6922 /*! \fn QString &QString::setNum(short n, int base)
6923 
6924     \overload
6925 */
6926 
6927 /*! \fn QString &QString::setNum(ushort n, int base)
6928 
6929     \overload
6930 */
6931 
6932 /*!
6933     \fn QString &QString::setNum(double n, char format, int precision)
6934     \overload
6935 
6936     Sets the string to the printed value of \a n, formatted according
6937     to the given \a format and \a precision, and returns a reference
6938     to the string.
6939 
6940     The \a format can be 'e', 'E', 'f', 'g' or 'G' (see
6941     \l{Argument Formats} for an explanation of the formats).
6942 
6943     The formatting always uses QLocale::C, i.e., English/UnitedStates.
6944     To get a localized string representation of a number, use
6945     QLocale::toString() with the appropriate locale.
6946 
6947     \sa number()
6948 */
6949 
6950 QString &QString::setNum(double n, char f, int prec)
6951 {
6952     return *this = number(n, f, prec);
6953 }
6954 
6955 /*!
6956     \fn QString &QString::setNum(float n, char format, int precision)
6957     \overload
6958 
6959     Sets the string to the printed value of \a n, formatted according
6960     to the given \a format and \a precision, and returns a reference
6961     to the string.
6962 
6963     The formatting always uses QLocale::C, i.e., English/UnitedStates.
6964     To get a localized string representation of a number, use
6965     QLocale::toString() with the appropriate locale.
6966 
6967     \sa number()
6968 */
6969 
6970 
6971 /*!
6972     \fn QString QString::number(long n, int base)
6973 
6974     Returns a string equivalent of the number \a n according to the
6975     specified \a base.
6976 
6977     The base is 10 by default and must be between 2
6978     and 36. For bases other than 10, \a n is treated as an
6979     unsigned integer.
6980 
6981     The formatting always uses QLocale::C, i.e., English/UnitedStates.
6982     To get a localized string representation of a number, use
6983     QLocale::toString() with the appropriate locale.
6984 
6985     \snippet qstring/main.cpp 35
6986 
6987     \sa setNum()
6988 */
6989 
6990 QString QString::number(long n, int base)
6991 {
6992     return number(qlonglong(n), base);
6993 }
6994 
6995 /*!
6996   \fn QString QString::number(ulong n, int base)
6997 
6998     \overload
6999 */
7000 QString QString::number(ulong n, int base)
7001 {
7002     return number(qulonglong(n), base);
7003 }
7004 
7005 /*!
7006     \overload
7007 */
7008 QString QString::number(int n, int base)
7009 {
7010     return number(qlonglong(n), base);
7011 }
7012 
7013 /*!
7014     \overload
7015 */
7016 QString QString::number(uint n, int base)
7017 {
7018     return number(qulonglong(n), base);
7019 }
7020 
7021 /*!
7022     \overload
7023 */
7024 QString QString::number(qlonglong n, int base)
7025 {
7026 #if defined(QT_CHECK_RANGE)
7027     if (base < 2 || base > 36) {
7028         qWarning("QString::setNum: Invalid base (%d)", base);
7029         base = 10;
7030     }
7031 #endif
7032     return QLocaleData::c()->longLongToString(n, -1, base);
7033 }
7034 
7035 /*!
7036     \overload
7037 */
7038 QString QString::number(qulonglong n, int base)
7039 {
7040 #if defined(QT_CHECK_RANGE)
7041     if (base < 2 || base > 36) {
7042         qWarning("QString::setNum: Invalid base (%d)", base);
7043         base = 10;
7044     }
7045 #endif
7046     return QLocaleData::c()->unsLongLongToString(n, -1, base);
7047 }
7048 
7049 
7050 /*!
7051     \fn QString QString::number(double n, char format, int precision)
7052 
7053     Returns a string equivalent of the number \a n, formatted
7054     according to the specified \a format and \a precision. See
7055     \l{Argument Formats} for details.
7056 
7057     Unlike QLocale::toString(), this function does not honor the
7058     user's locale settings.
7059 
7060     \sa setNum(), QLocale::toString()
7061 */
7062 QString QString::number(double n, char f, int prec)
7063 {
7064     QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
7065     uint flags = QLocaleData::ZeroPadExponent;
7066 
7067     if (qIsUpper(f))
7068         flags |= QLocaleData::CapitalEorX;
7069 
7070     switch (qToLower(f)) {
7071         case 'f':
7072             form = QLocaleData::DFDecimal;
7073             break;
7074         case 'e':
7075             form = QLocaleData::DFExponent;
7076             break;
7077         case 'g':
7078             form = QLocaleData::DFSignificantDigits;
7079             break;
7080         default:
7081 #if defined(QT_CHECK_RANGE)
7082             qWarning("QString::setNum: Invalid format char '%c'", f);
7083 #endif
7084             break;
7085     }
7086 
7087     return QLocaleData::c()->doubleToString(n, prec, form, -1, flags);
7088 }
7089 
7090 namespace {
7091 template<class ResultList, class StringSource>
7092 static ResultList splitString(const StringSource &source, QStringView sep,
7093                               Qt::SplitBehavior behavior, Qt::CaseSensitivity cs)
7094 {
7095     ResultList list;
7096     typename StringSource::size_type start = 0;
7097     typename StringSource::size_type end;
7098     typename StringSource::size_type extra = 0;
7099     while ((end = QtPrivate::findString(QStringView(source.constData(), source.size()), start + extra, sep, cs)) != -1) {
7100         if (start != end || behavior == Qt::KeepEmptyParts)
7101             list.append(source.mid(start, end - start));
7102         start = end + sep.size();
7103         extra = (sep.size() == 0 ? 1 : 0);
7104     }
7105     if (start != source.size() || behavior == Qt::KeepEmptyParts)
7106         list.append(source.mid(start));
7107     return list;
7108 }
7109 
7110 } // namespace
7111 
7112 /*!
7113     Splits the string into substrings wherever \a sep occurs, and
7114     returns the list of those strings. If \a sep does not match
7115     anywhere in the string, split() returns a single-element list
7116     containing this string.
7117 
7118     \a cs specifies whether \a sep should be matched case
7119     sensitively or case insensitively.
7120 
7121     If \a behavior is QString::SkipEmptyParts, empty entries don't
7122     appear in the result. By default, empty entries are kept.
7123 
7124     Example:
7125 
7126     \snippet qstring/main.cpp 62
7127 
7128     If \a sep is empty, split() returns an empty string, followed
7129     by each of the string's characters, followed by another empty string:
7130 
7131     \snippet qstring/main.cpp 62-empty
7132 
7133     To understand this behavior, recall that the empty string matches
7134     everywhere, so the above is qualitatively the same as:
7135 
7136     \snippet qstring/main.cpp 62-slashes
7137 
7138     \sa QStringList::join(), section()
7139 
7140     \since 5.14
7141 */
7142 QStringList QString::split(const QString &sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7143 {
7144     return splitString<QStringList>(*this, sep, behavior, cs);
7145 }
7146 
7147 /*!
7148     Splits the string into substring references wherever \a sep occurs, and
7149     returns the list of those strings.
7150 
7151     See QString::split() for how \a sep, \a behavior and \a cs interact to form
7152     the result.
7153 
7154     \note All references are valid as long this string is alive. Destroying this
7155     string will cause all references to be dangling pointers.
7156 
7157     \since 5.14
7158     \sa QStringRef split()
7159 */
7160 QList<QStringRef> QString::splitRef(const QString &sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7161 {
7162     return splitString<QList<QStringRef>>(QStringRef(this), sep, behavior, cs);
7163 }
7164 
7165 /*!
7166     \overload
7167     \since 5.14
7168 */
7169 QStringList QString::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7170 {
7171     return splitString<QStringList>(*this, QStringView(&sep, 1), behavior, cs);
7172 }
7173 
7174 /*!
7175     \overload
7176     \since 5.14
7177 */
7178 QList<QStringRef> QString::splitRef(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7179 {
7180     return splitString<QList<QStringRef>>(QStringRef(this), QStringView(&sep, 1), behavior, cs);
7181 }
7182 
7183 /*!
7184     Splits the string into substrings references wherever \a sep occurs, and
7185     returns the list of those strings.
7186 
7187     See QString::split() for how \a sep, \a behavior and \a cs interact to form
7188     the result.
7189 
7190     \note All references are valid as long this string is alive. Destroying this
7191     string will cause all references to be dangling pointers.
7192 
7193     \since 5.14
7194 */
7195 QList<QStringRef> QStringRef::split(const QString &sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7196 {
7197     return splitString<QList<QStringRef>>(*this, sep, behavior, cs);
7198 }
7199 
7200 /*!
7201     \overload
7202     \since 5.14
7203 */
7204 QList<QStringRef> QStringRef::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7205 {
7206     return splitString<QList<QStringRef>>(*this, QStringView(&sep, 1), behavior, cs);
7207 }
7208 
7209 /*!
7210     \fn QList<QStringView> QStringView::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7211     \fn QList<QStringView> QStringView::split(QStringView sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7212 
7213 
7214     Splits the string into substring references wherever \a sep occurs, and
7215     returns the list of those strings.
7216 
7217     See QString::split() for how \a sep, \a behavior and \a cs interact to form
7218     the result.
7219 
7220     \note All references are valid as long this string is alive. Destroying this
7221     string will cause all references to be dangling pointers.
7222 
7223     \since 6.0
7224 */
7225 QList<QStringView> QStringView::split(QStringView sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7226 {
7227     return splitString<QList<QStringView>>(QStringView(*this), sep, behavior, cs);
7228 }
7229 
7230 QList<QStringView> QStringView::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7231 {
7232     return split(QStringView(&sep, 1), behavior, cs);
7233 }
7234 
7235 #if QT_CONFIG(regularexpression)
7236 namespace {
7237 template<class ResultList, typename String>
7238 static ResultList splitString(const String &source, const QRegularExpression &re,
7239                               Qt::SplitBehavior behavior)
7240 {
7241     ResultList list;
7242     if (!re.isValid()) {
7243         qWarning("QString::split: invalid QRegularExpression object");
7244         return list;
7245     }
7246 
7247     qsizetype start = 0;
7248     qsizetype end = 0;
7249     QRegularExpressionMatchIterator iterator = re.globalMatch(source);
7250     while (iterator.hasNext()) {
7251         QRegularExpressionMatch match = iterator.next();
7252         end = match.capturedStart();
7253         if (start != end || behavior == Qt::KeepEmptyParts)
7254             list.append(source.mid(start, end - start));
7255         start = match.capturedEnd();
7256     }
7257 
7258     if (start != source.size() || behavior == Qt::KeepEmptyParts)
7259         list.append(source.mid(start));
7260 
7261     return list;
7262 }
7263 } // namespace
7264 
7265 /*!
7266     \overload
7267     \since 5.14
7268 
7269     Splits the string into substrings wherever the regular expression
7270     \a re matches, and returns the list of those strings. If \a re
7271     does not match anywhere in the string, split() returns a
7272     single-element list containing this string.
7273 
7274     Here is an example where we extract the words in a sentence
7275     using one or more whitespace characters as the separator:
7276 
7277     \snippet qstring/main.cpp 90
7278 
7279     Here is a similar example, but this time we use any sequence of
7280     non-word characters as the separator:
7281 
7282     \snippet qstring/main.cpp 91
7283 
7284     Here is a third example where we use a zero-length assertion,
7285     \b{\\b} (word boundary), to split the string into an
7286     alternating sequence of non-word and word tokens:
7287 
7288     \snippet qstring/main.cpp 92
7289 
7290     \sa QStringList::join(), section()
7291 */
7292 QStringList QString::split(const QRegularExpression &re, Qt::SplitBehavior behavior) const
7293 {
7294     return splitString<QStringList>(*this, re, behavior);
7295 }
7296 
7297 /*!
7298     \overload
7299     \since 5.14
7300 
7301     Splits the string into substring references wherever the regular expression
7302     \a re matches, and returns the list of those strings. If \a re
7303     does not match anywhere in the string, splitRef() returns a
7304     single-element list containing this string reference.
7305 
7306     \note All references are valid as long this string is alive. Destroying this
7307     string will cause all references to be dangling pointers.
7308 
7309     \sa split() QStringRef
7310 */
7311 QList<QStringRef> QString::splitRef(const QRegularExpression &re, Qt::SplitBehavior behavior) const
7312 {
7313     return splitString<QList<QStringRef>>(QStringRef(this), re, behavior);
7314 }
7315 
7316 /*!
7317     \since 6.0
7318 
7319     Splits the string into substring views wherever the regular expression
7320     \a re matches, and returns the list of those strings. If \a re
7321     does not match anywhere in the string, splitRef() returns a
7322     single-element list containing this string reference.
7323 
7324     \note All references are valid as long this string is alive. Destroying this
7325     string will cause all references to be dangling pointers.
7326 
7327     \sa split() QStringRef
7328 */
7329 QList<QStringView> QStringView::split(const QRegularExpression &re, Qt::SplitBehavior behavior) const
7330 {
7331     return splitString<QList<QStringView>>(*this, re, behavior);
7332 }
7333 
7334 #endif // QT_CONFIG(regularexpression)
7335 
7336 /*!
7337     \enum QString::NormalizationForm
7338 
7339     This enum describes the various normalized forms of Unicode text.
7340 
7341     \value NormalizationForm_D  Canonical Decomposition
7342     \value NormalizationForm_C  Canonical Decomposition followed by Canonical Composition
7343     \value NormalizationForm_KD  Compatibility Decomposition
7344     \value NormalizationForm_KC  Compatibility Decomposition followed by Canonical Composition
7345 
7346     \sa normalized(),
7347         {http://www.unicode.org/reports/tr15/}{Unicode Standard Annex #15}
7348 */
7349 
7350 /*!
7351     \since 4.5
7352 
7353     Returns a copy of this string repeated the specified number of \a times.
7354 
7355     If \a times is less than 1, an empty string is returned.
7356 
7357     Example:
7358 
7359     \snippet code/src_corelib_text_qstring.cpp 8
7360 */
7361 QString QString::repeated(qsizetype times) const
7362 {
7363     if (d.size == 0)
7364         return *this;
7365 
7366     if (times <= 1) {
7367         if (times == 1)
7368             return *this;
7369         return QString();
7370     }
7371 
7372     const qsizetype resultSize = times * d.size;
7373 
7374     QString result;
7375     result.reserve(resultSize);
7376     if (result.capacity() != resultSize)
7377         return QString(); // not enough memory
7378 
7379     memcpy(result.d.data(), d.data(), d.size * sizeof(QChar));
7380 
7381     qsizetype sizeSoFar = d.size;
7382     char16_t *end = result.d.data() + sizeSoFar;
7383 
7384     const qsizetype halfResultSize = resultSize >> 1;
7385     while (sizeSoFar <= halfResultSize) {
7386         memcpy(end, result.d.data(), sizeSoFar * sizeof(QChar));
7387         end += sizeSoFar;
7388         sizeSoFar <<= 1;
7389     }
7390     memcpy(end, result.d.data(), (resultSize - sizeSoFar) * sizeof(QChar));
7391     result.d.data()[resultSize] = '\0';
7392     result.d.size = resultSize;
7393     return result;
7394 }
7395 
7396 void qt_string_normalize(QString *data, QString::NormalizationForm mode, QChar::UnicodeVersion version, qsizetype from)
7397 {
7398     const QChar *p = data->constData() + from;
7399     if (isAscii(p, p + data->length() - from))
7400         return;
7401     if (p > data->constData() + from)
7402         from = p - data->constData() - 1;   // need one before the non-ASCII to perform NFC
7403 
7404     if (version == QChar::Unicode_Unassigned) {
7405         version = QChar::currentUnicodeVersion();
7406     } else if (int(version) <= NormalizationCorrectionsVersionMax) {
7407         const QString &s = *data;
7408         QChar *d = nullptr;
7409         for (int i = 0; i < NumNormalizationCorrections; ++i) {
7410             const NormalizationCorrection &n = uc_normalization_corrections[i];
7411             if (n.version > version) {
7412                 qsizetype pos = from;
7413                 if (QChar::requiresSurrogates(n.ucs4)) {
7414                     char16_t ucs4High = QChar::highSurrogate(n.ucs4);
7415                     char16_t ucs4Low = QChar::lowSurrogate(n.ucs4);
7416                     char16_t oldHigh = QChar::highSurrogate(n.old_mapping);
7417                     char16_t oldLow = QChar::lowSurrogate(n.old_mapping);
7418                     while (pos < s.length() - 1) {
7419                         if (s.at(pos).unicode() == ucs4High && s.at(pos + 1).unicode() == ucs4Low) {
7420                             if (!d)
7421                                 d = data->data();
7422                             d[pos] = QChar(oldHigh);
7423                             d[++pos] = QChar(oldLow);
7424                         }
7425                         ++pos;
7426                     }
7427                 } else {
7428                     while (pos < s.length()) {
7429                         if (s.at(pos).unicode() == n.ucs4) {
7430                             if (!d)
7431                                 d = data->data();
7432                             d[pos] = QChar(n.old_mapping);
7433                         }
7434                         ++pos;
7435                     }
7436                 }
7437             }
7438         }
7439     }
7440 
7441     if (normalizationQuickCheckHelper(data, mode, from, &from))
7442         return;
7443 
7444     decomposeHelper(data, mode < QString::NormalizationForm_KD, version, from);
7445 
7446     canonicalOrderHelper(data, version, from);
7447 
7448     if (mode == QString::NormalizationForm_D || mode == QString::NormalizationForm_KD)
7449         return;
7450 
7451     composeHelper(data, version, from);
7452 }
7453 
7454 /*!
7455     Returns the string in the given Unicode normalization \a mode,
7456     according to the given \a version of the Unicode standard.
7457 */
7458 QString QString::normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version) const
7459 {
7460     QString copy = *this;
7461     qt_string_normalize(&copy, mode, version, 0);
7462     return copy;
7463 }
7464 
7465 
7466 struct ArgEscapeData
7467 {
7468     int min_escape;            // lowest escape sequence number
7469     int occurrences;           // number of occurrences of the lowest escape sequence number
7470     int locale_occurrences;    // number of occurrences of the lowest escape sequence number that
7471                                // contain 'L'
7472     int escape_len;            // total length of escape sequences which will be replaced
7473 };
7474 
7475 static ArgEscapeData findArgEscapes(QStringView s)
7476 {
7477     const QChar *uc_begin = s.begin();
7478     const QChar *uc_end = s.end();
7479 
7480     ArgEscapeData d;
7481 
7482     d.min_escape = INT_MAX;
7483     d.occurrences = 0;
7484     d.escape_len = 0;
7485     d.locale_occurrences = 0;
7486 
7487     const QChar *c = uc_begin;
7488     while (c != uc_end) {
7489         while (c != uc_end && c->unicode() != '%')
7490             ++c;
7491 
7492         if (c == uc_end)
7493             break;
7494         const QChar *escape_start = c;
7495         if (++c == uc_end)
7496             break;
7497 
7498         bool locale_arg = false;
7499         if (c->unicode() == 'L') {
7500             locale_arg = true;
7501             if (++c == uc_end)
7502                 break;
7503         }
7504 
7505         int escape = c->digitValue();
7506         if (escape == -1)
7507             continue;
7508 
7509         ++c;
7510 
7511         if (c != uc_end) {
7512             int next_escape = c->digitValue();
7513             if (next_escape != -1) {
7514                 escape = (10 * escape) + next_escape;
7515                 ++c;
7516             }
7517         }
7518 
7519         if (escape > d.min_escape)
7520             continue;
7521 
7522         if (escape < d.min_escape) {
7523             d.min_escape = escape;
7524             d.occurrences = 0;
7525             d.escape_len = 0;
7526             d.locale_occurrences = 0;
7527         }
7528 
7529         ++d.occurrences;
7530         if (locale_arg)
7531             ++d.locale_occurrences;
7532         d.escape_len += c - escape_start;
7533     }
7534     return d;
7535 }
7536 
7537 static QString replaceArgEscapes(QStringView s, const ArgEscapeData &d, int field_width,
7538                                  QStringView arg, QStringView larg, QChar fillChar)
7539 {
7540     const QChar *uc_begin = s.begin();
7541     const QChar *uc_end = s.end();
7542 
7543     int abs_field_width = qAbs(field_width);
7544     qsizetype result_len = s.length()
7545                      - d.escape_len
7546                      + (d.occurrences - d.locale_occurrences)
7547                      *qMax(abs_field_width, arg.length())
7548                      + d.locale_occurrences
7549                      *qMax(abs_field_width, larg.length());
7550 
7551     QString result(result_len, Qt::Uninitialized);
7552     QChar *result_buff = (QChar*) result.unicode();
7553 
7554     QChar *rc = result_buff;
7555     const QChar *c = uc_begin;
7556     int repl_cnt = 0;
7557     while (c != uc_end) {
7558         /* We don't have to check if we run off the end of the string with c,
7559            because as long as d.occurrences > 0 we KNOW there are valid escape
7560            sequences. */
7561 
7562         const QChar *text_start = c;
7563 
7564         while (c->unicode() != '%')
7565             ++c;
7566 
7567         const QChar *escape_start = c++;
7568 
7569         bool locale_arg = false;
7570         if (c->unicode() == 'L') {
7571             locale_arg = true;
7572             ++c;
7573         }
7574 
7575         int escape = c->digitValue();
7576         if (escape != -1) {
7577             if (c + 1 != uc_end && (c + 1)->digitValue() != -1) {
7578                 escape = (10 * escape) + (c + 1)->digitValue();
7579                 ++c;
7580             }
7581         }
7582 
7583         if (escape != d.min_escape) {
7584             memcpy(rc, text_start, (c - text_start)*sizeof(QChar));
7585             rc += c - text_start;
7586         }
7587         else {
7588             ++c;
7589 
7590             memcpy(rc, text_start, (escape_start - text_start)*sizeof(QChar));
7591             rc += escape_start - text_start;
7592 
7593             uint pad_chars;
7594             if (locale_arg)
7595                 pad_chars = qMax(abs_field_width, larg.length()) - larg.length();
7596             else
7597                 pad_chars = qMax(abs_field_width, arg.length()) - arg.length();
7598 
7599             if (field_width > 0) { // left padded
7600                 for (uint i = 0; i < pad_chars; ++i)
7601                     *rc++ = fillChar;
7602             }
7603 
7604             if (locale_arg) {
7605                 memcpy(rc, larg.data(), larg.length()*sizeof(QChar));
7606                 rc += larg.length();
7607             }
7608             else {
7609                 memcpy(rc, arg.data(), arg.length()*sizeof(QChar));
7610                 rc += arg.length();
7611             }
7612 
7613             if (field_width < 0) { // right padded
7614                 for (uint i = 0; i < pad_chars; ++i)
7615                     *rc++ = fillChar;
7616             }
7617 
7618             if (++repl_cnt == d.occurrences) {
7619                 memcpy(rc, c, (uc_end - c)*sizeof(QChar));
7620                 rc += uc_end - c;
7621                 Q_ASSERT(rc - result_buff == result_len);
7622                 c = uc_end;
7623             }
7624         }
7625     }
7626     Q_ASSERT(rc == result_buff + result_len);
7627 
7628     return result;
7629 }
7630 
7631 #if QT_STRINGVIEW_LEVEL < 2
7632 /*!
7633   Returns a copy of this string with the lowest numbered place marker
7634   replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7635 
7636   \a fieldWidth specifies the minimum amount of space that argument \a
7637   a shall occupy. If \a a requires less space than \a fieldWidth, it
7638   is padded to \a fieldWidth with character \a fillChar.  A positive
7639   \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7640   produces left-aligned text.
7641 
7642   This example shows how we might create a \c status string for
7643   reporting progress while processing a list of files:
7644 
7645   \snippet qstring/main.cpp 11
7646 
7647   First, \c arg(i) replaces \c %1. Then \c arg(total) replaces \c
7648   %2. Finally, \c arg(fileName) replaces \c %3.
7649 
7650   One advantage of using arg() over asprintf() is that the order of the
7651   numbered place markers can change, if the application's strings are
7652   translated into other languages, but each arg() will still replace
7653   the lowest numbered unreplaced place marker, no matter where it
7654   appears. Also, if place marker \c %i appears more than once in the
7655   string, the arg() replaces all of them.
7656 
7657   If there is no unreplaced place marker remaining, a warning message
7658   is output and the result is undefined. Place marker numbers must be
7659   in the range 1 to 99.
7660 */
7661 QString QString::arg(const QString &a, int fieldWidth, QChar fillChar) const
7662 {
7663     return arg(qToStringViewIgnoringNull(a), fieldWidth, fillChar);
7664 }
7665 #endif // QT_STRINGVIEW_LEVEL < 2
7666 
7667 /*!
7668     \overload
7669     \since 5.10
7670 
7671     Returns a copy of this string with the lowest-numbered place-marker
7672     replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7673 
7674     \a fieldWidth specifies the minimum amount of space that \a a
7675     shall occupy. If \a a requires less space than \a fieldWidth, it
7676     is padded to \a fieldWidth with character \a fillChar.  A positive
7677     \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7678     produces left-aligned text.
7679 
7680     This example shows how we might create a \c status string for
7681     reporting progress while processing a list of files:
7682 
7683     \snippet qstring/main.cpp 11-qstringview
7684 
7685     First, \c arg(i) replaces \c %1. Then \c arg(total) replaces \c
7686     %2. Finally, \c arg(fileName) replaces \c %3.
7687 
7688     One advantage of using arg() over asprintf() is that the order of the
7689     numbered place markers can change, if the application's strings are
7690     translated into other languages, but each arg() will still replace
7691     the lowest-numbered unreplaced place-marker, no matter where it
7692     appears. Also, if place-marker \c %i appears more than once in the
7693     string, arg() replaces all of them.
7694 
7695     If there is no unreplaced place-marker remaining, a warning message
7696     is printed and the result is undefined. Place-marker numbers must be
7697     in the range 1 to 99.
7698 */
7699 QString QString::arg(QStringView a, int fieldWidth, QChar fillChar) const
7700 {
7701     ArgEscapeData d = findArgEscapes(*this);
7702 
7703     if (Q_UNLIKELY(d.occurrences == 0)) {
7704         qWarning("QString::arg: Argument missing: %ls, %ls", qUtf16Printable(*this),
7705                   qUtf16Printable(a.toString()));
7706         return *this;
7707     }
7708     return replaceArgEscapes(*this, d, fieldWidth, a, a, fillChar);
7709 }
7710 
7711 /*!
7712     \overload
7713     \since 5.10
7714 
7715     Returns a copy of this string with the lowest-numbered place-marker
7716     replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7717 
7718     \a fieldWidth specifies the minimum amount of space that \a a
7719     shall occupy. If \a a requires less space than \a fieldWidth, it
7720     is padded to \a fieldWidth with character \a fillChar.  A positive
7721     \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7722     produces left-aligned text.
7723 
7724     One advantage of using arg() over asprintf() is that the order of the
7725     numbered place markers can change, if the application's strings are
7726     translated into other languages, but each arg() will still replace
7727     the lowest-numbered unreplaced place-marker, no matter where it
7728     appears. Also, if place-marker \c %i appears more than once in the
7729     string, arg() replaces all of them.
7730 
7731     If there is no unreplaced place-marker remaining, a warning message
7732     is printed and the result is undefined. Place-marker numbers must be
7733     in the range 1 to 99.
7734 */
7735 QString QString::arg(QLatin1String a, int fieldWidth, QChar fillChar) const
7736 {
7737     QVarLengthArray<char16_t> utf16(a.size());
7738     qt_from_latin1(utf16.data(), a.data(), a.size());
7739     return arg(QStringView(utf16.data(), utf16.size()), fieldWidth, fillChar);
7740 }
7741 
7742 /*!
7743   \fn QString QString::arg(const QString& a1, const QString& a2) const
7744   \overload arg()
7745 
7746   This is the same as \c {str.arg(a1).arg(a2)}, except that the
7747   strings \a a1 and \a a2 are replaced in one pass. This can make a
7748   difference if \a a1 contains e.g. \c{%1}:
7749 
7750   \snippet qstring/main.cpp 13
7751 
7752   A similar problem occurs when the numbered place markers are not
7753   white space separated:
7754 
7755   \snippet qstring/main.cpp 12
7756   \snippet qstring/main.cpp 97
7757 
7758   Let's look at the substitutions:
7759   \list
7760   \li First, \c Hello replaces \c {%1} so the string becomes \c {"Hello%3%2"}.
7761   \li Then, \c 20 replaces \c {%2} so the string becomes \c {"Hello%320"}.
7762   \li Since the maximum numbered place marker value is 99, \c 50 replaces \c {%32}.
7763   \endlist
7764   Thus the string finally becomes \c {"Hello500"}.
7765 
7766   In such cases, the following yields the expected results:
7767 
7768   \snippet qstring/main.cpp 12
7769   \snippet qstring/main.cpp 98
7770 */
7771 
7772 /*!
7773   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3) const
7774   \overload arg()
7775 
7776   This is the same as calling \c str.arg(a1).arg(a2).arg(a3), except
7777   that the strings \a a1, \a a2 and \a a3 are replaced in one pass.
7778 */
7779 
7780 /*!
7781   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4) const
7782   \overload arg()
7783 
7784   This is the same as calling \c
7785   {str.arg(a1).arg(a2).arg(a3).arg(a4)}, except that the strings \a
7786   a1, \a a2, \a a3 and \a a4 are replaced in one pass.
7787 */
7788 
7789 /*!
7790   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5) const
7791   \overload arg()
7792 
7793   This is the same as calling \c
7794   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)}, except that the strings
7795   \a a1, \a a2, \a a3, \a a4, and \a a5 are replaced in one pass.
7796 */
7797 
7798 /*!
7799   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6) const
7800   \overload arg()
7801 
7802   This is the same as calling \c
7803   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))}, except that
7804   the strings \a a1, \a a2, \a a3, \a a4, \a a5, and \a a6 are
7805   replaced in one pass.
7806 */
7807 
7808 /*!
7809   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7) const
7810   \overload arg()
7811 
7812   This is the same as calling \c
7813   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)},
7814   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6,
7815   and \a a7 are replaced in one pass.
7816 */
7817 
7818 /*!
7819   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7, const QString& a8) const
7820   \overload arg()
7821 
7822   This is the same as calling \c
7823   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)},
7824   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6, \a
7825   a7, and \a a8 are replaced in one pass.
7826 */
7827 
7828 /*!
7829   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7, const QString& a8, const QString& a9) const
7830   \overload arg()
7831 
7832   This is the same as calling \c
7833   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)},
7834   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6, \a
7835   a7, \a a8, and \a a9 are replaced in one pass.
7836 */
7837 
7838 /*! \fn QString QString::arg(int a, int fieldWidth, int base, QChar fillChar) const
7839   \overload arg()
7840 
7841   The \a a argument is expressed in base \a base, which is 10 by
7842   default and must be between 2 and 36. For bases other than 10, \a a
7843   is treated as an unsigned integer.
7844 
7845   \a fieldWidth specifies the minimum amount of space that \a a is
7846   padded to and filled with the character \a fillChar. A positive
7847   value produces right-aligned text; a negative value produces
7848   left-aligned text.
7849 
7850   The '%' can be followed by an 'L', in which case the sequence is
7851   replaced with a localized representation of \a a. The conversion
7852   uses the default locale, set by QLocale::setDefault(). If no default
7853   locale was specified, the "C" locale is used. The 'L' flag is
7854   ignored if \a base is not 10.
7855 
7856   \snippet qstring/main.cpp 12
7857   \snippet qstring/main.cpp 14
7858 
7859   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7860   used. For negative numbers, zero padding might appear before the
7861   minus sign.
7862 */
7863 
7864 /*! \fn QString QString::arg(uint a, int fieldWidth, int base, QChar fillChar) const
7865   \overload arg()
7866 
7867   The \a base argument specifies the base to use when converting the
7868   integer \a a into a string. The base must be between 2 and 36.
7869 
7870   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7871   used. For negative numbers, zero padding might appear before the
7872   minus sign.
7873 */
7874 
7875 /*! \fn QString QString::arg(long a, int fieldWidth, int base, QChar fillChar) const
7876   \overload arg()
7877 
7878   \a fieldWidth specifies the minimum amount of space that \a a is
7879   padded to and filled with the character \a fillChar. A positive
7880   value produces right-aligned text; a negative value produces
7881   left-aligned text.
7882 
7883   The \a a argument is expressed in the given \a base, which is 10 by
7884   default and must be between 2 and 36.
7885 
7886   The '%' can be followed by an 'L', in which case the sequence is
7887   replaced with a localized representation of \a a. The conversion
7888   uses the default locale. The default locale is determined from the
7889   system's locale settings at application startup. It can be changed
7890   using QLocale::setDefault(). The 'L' flag is ignored if \a base is
7891   not 10.
7892 
7893   \snippet qstring/main.cpp 12
7894   \snippet qstring/main.cpp 14
7895 
7896   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7897   used. For negative numbers, zero padding might appear before the
7898   minus sign.
7899 */
7900 
7901 /*! \fn QString QString::arg(ulong a, int fieldWidth, int base, QChar fillChar) const
7902   \overload arg()
7903 
7904   \a fieldWidth specifies the minimum amount of space that \a a is
7905   padded to and filled with the character \a fillChar. A positive
7906   value produces right-aligned text; a negative value produces
7907   left-aligned text.
7908 
7909   The \a base argument specifies the base to use when converting the
7910   integer \a a to a string. The base must be between 2 and 36, with 8
7911   giving octal, 10 decimal, and 16 hexadecimal numbers.
7912 
7913   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7914   used. For negative numbers, zero padding might appear before the
7915   minus sign.
7916 */
7917 
7918 /*!
7919   \overload arg()
7920 
7921   \a fieldWidth specifies the minimum amount of space that \a a is
7922   padded to and filled with the character \a fillChar. A positive
7923   value produces right-aligned text; a negative value produces
7924   left-aligned text.
7925 
7926   The \a base argument specifies the base to use when converting the
7927   integer \a a into a string. The base must be between 2 and 36, with
7928   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
7929 
7930   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7931   used. For negative numbers, zero padding might appear before the
7932   minus sign.
7933 */
7934 QString QString::arg(qlonglong a, int fieldWidth, int base, QChar fillChar) const
7935 {
7936     ArgEscapeData d = findArgEscapes(*this);
7937 
7938     if (d.occurrences == 0) {
7939         qWarning() << "QString::arg: Argument missing:" << *this << ',' << a;
7940         return *this;
7941     }
7942 
7943     unsigned flags = QLocaleData::NoFlags;
7944     if (fillChar == QLatin1Char('0'))
7945         flags = QLocaleData::ZeroPadded;
7946 
7947     QString arg;
7948     if (d.occurrences > d.locale_occurrences)
7949         arg = QLocaleData::c()->longLongToString(a, -1, base, fieldWidth, flags);
7950 
7951     QString locale_arg;
7952     if (d.locale_occurrences > 0) {
7953         QLocale locale;
7954         if (!(locale.numberOptions() & QLocale::OmitGroupSeparator))
7955             flags |= QLocaleData::GroupDigits;
7956         locale_arg = locale.d->m_data->longLongToString(a, -1, base, fieldWidth, flags);
7957     }
7958 
7959     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
7960 }
7961 
7962 /*!
7963   \overload arg()
7964 
7965   \a fieldWidth specifies the minimum amount of space that \a a is
7966   padded to and filled with the character \a fillChar. A positive
7967   value produces right-aligned text; a negative value produces
7968   left-aligned text.
7969 
7970   The \a base argument specifies the base to use when converting the
7971   integer \a a into a string. \a base must be between 2 and 36, with 8
7972   giving octal, 10 decimal, and 16 hexadecimal numbers.
7973 
7974   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7975   used. For negative numbers, zero padding might appear before the
7976   minus sign.
7977 */
7978 QString QString::arg(qulonglong a, int fieldWidth, int base, QChar fillChar) const
7979 {
7980     ArgEscapeData d = findArgEscapes(*this);
7981 
7982     if (d.occurrences == 0) {
7983         qWarning() << "QString::arg: Argument missing:" << *this << ',' << a;
7984         return *this;
7985     }
7986 
7987     unsigned flags = QLocaleData::NoFlags;
7988     if (fillChar == QLatin1Char('0'))
7989         flags = QLocaleData::ZeroPadded;
7990 
7991     QString arg;
7992     if (d.occurrences > d.locale_occurrences)
7993         arg = QLocaleData::c()->unsLongLongToString(a, -1, base, fieldWidth, flags);
7994 
7995     QString locale_arg;
7996     if (d.locale_occurrences > 0) {
7997         QLocale locale;
7998         if (!(locale.numberOptions() & QLocale::OmitGroupSeparator))
7999             flags |= QLocaleData::GroupDigits;
8000         locale_arg = locale.d->m_data->unsLongLongToString(a, -1, base, fieldWidth, flags);
8001     }
8002 
8003     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8004 }
8005 
8006 /*!
8007   \overload arg()
8008 
8009   \fn QString QString::arg(short a, int fieldWidth, int base, QChar fillChar) const
8010 
8011   \a fieldWidth specifies the minimum amount of space that \a a is
8012   padded to and filled with the character \a fillChar. A positive
8013   value produces right-aligned text; a negative value produces
8014   left-aligned text.
8015 
8016   The \a base argument specifies the base to use when converting the
8017   integer \a a into a string. The base must be between 2 and 36, with
8018   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
8019 
8020   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8021   used. For negative numbers, zero padding might appear before the
8022   minus sign.
8023 */
8024 
8025 /*!
8026   \fn QString QString::arg(ushort a, int fieldWidth, int base, QChar fillChar) const
8027   \overload arg()
8028 
8029   \a fieldWidth specifies the minimum amount of space that \a a is
8030   padded to and filled with the character \a fillChar. A positive
8031   value produces right-aligned text; a negative value produces
8032   left-aligned text.
8033 
8034   The \a base argument specifies the base to use when converting the
8035   integer \a a into a string. The base must be between 2 and 36, with
8036   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
8037 
8038   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8039   used. For negative numbers, zero padding might appear before the
8040   minus sign.
8041 */
8042 
8043 /*!
8044     \overload arg()
8045 */
8046 QString QString::arg(QChar a, int fieldWidth, QChar fillChar) const
8047 {
8048     return arg(QStringView{&a, 1}, fieldWidth, fillChar);
8049 }
8050 
8051 /*!
8052   \overload arg()
8053 
8054   The \a a argument is interpreted as a Latin-1 character.
8055 */
8056 QString QString::arg(char a, int fieldWidth, QChar fillChar) const
8057 {
8058     return arg(QLatin1Char(a), fieldWidth, fillChar);
8059 }
8060 
8061 /*!
8062   \fn QString QString::arg(double a, int fieldWidth, char format, int precision, QChar fillChar) const
8063   \overload arg()
8064 
8065   Argument \a a is formatted according to the specified \a format and
8066   \a precision. See \l{Argument Formats} for details.
8067 
8068   \a fieldWidth specifies the minimum amount of space that \a a is
8069   padded to and filled with the character \a fillChar.  A positive
8070   value produces right-aligned text; a negative value produces
8071   left-aligned text.
8072 
8073   \snippet code/src_corelib_text_qstring.cpp 2
8074 
8075   The '%' can be followed by an 'L', in which case the sequence is
8076   replaced with a localized representation of \a a. The conversion
8077   uses the default locale, set by QLocale::setDefault(). If no
8078   default locale was specified, the "C" locale is used.
8079 
8080   If \a fillChar is '0' (the number 0, ASCII 48), this function will
8081   use the locale's zero to pad. For negative numbers, the zero padding
8082   will probably appear before the minus sign.
8083 
8084   \sa QLocale::toString()
8085 */
8086 QString QString::arg(double a, int fieldWidth, char fmt, int prec, QChar fillChar) const
8087 {
8088     ArgEscapeData d = findArgEscapes(*this);
8089 
8090     if (d.occurrences == 0) {
8091         qWarning("QString::arg: Argument missing: %s, %g", toLocal8Bit().data(), a);
8092         return *this;
8093     }
8094 
8095     unsigned flags = QLocaleData::NoFlags;
8096     if (fillChar == QLatin1Char('0'))
8097         flags |= QLocaleData::ZeroPadded;
8098 
8099     if (qIsUpper(fmt))
8100         flags |= QLocaleData::CapitalEorX;
8101 
8102     QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
8103     switch (qToLower(fmt)) {
8104     case 'f':
8105         form = QLocaleData::DFDecimal;
8106         break;
8107     case 'e':
8108         form = QLocaleData::DFExponent;
8109         break;
8110     case 'g':
8111         form = QLocaleData::DFSignificantDigits;
8112         break;
8113     default:
8114 #if defined(QT_CHECK_RANGE)
8115         qWarning("QString::arg: Invalid format char '%c'", fmt);
8116 #endif
8117         break;
8118     }
8119 
8120     QString arg;
8121     if (d.occurrences > d.locale_occurrences)
8122         arg = QLocaleData::c()->doubleToString(a, prec, form, fieldWidth, flags | QLocaleData::ZeroPadExponent);
8123 
8124     QString locale_arg;
8125     if (d.locale_occurrences > 0) {
8126         QLocale locale;
8127 
8128         const QLocale::NumberOptions numberOptions = locale.numberOptions();
8129         if (!(numberOptions & QLocale::OmitGroupSeparator))
8130             flags |= QLocaleData::GroupDigits;
8131         if (!(numberOptions & QLocale::OmitLeadingZeroInExponent))
8132             flags |= QLocaleData::ZeroPadExponent;
8133         if (numberOptions & QLocale::IncludeTrailingZeroesAfterDot)
8134             flags |= QLocaleData::AddTrailingZeroes;
8135         locale_arg = locale.d->m_data->doubleToString(a, prec, form, fieldWidth, flags);
8136     }
8137 
8138     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8139 }
8140 
8141 static inline char16_t to_unicode(const QChar c) { return c.unicode(); }
8142 static inline char16_t to_unicode(const char c) { return QLatin1Char{c}.unicode(); }
8143 
8144 template <typename Char>
8145 static int getEscape(const Char *uc, qsizetype *pos, qsizetype len, int maxNumber = 999)
8146 {
8147     int i = *pos;
8148     ++i;
8149     if (i < len && uc[i] == QLatin1Char('L'))
8150         ++i;
8151     if (i < len) {
8152         int escape = to_unicode(uc[i]) - '0';
8153         if (uint(escape) >= 10U)
8154             return -1;
8155         ++i;
8156         while (i < len) {
8157             int digit = to_unicode(uc[i]) - '0';
8158             if (uint(digit) >= 10U)
8159                 break;
8160             escape = (escape * 10) + digit;
8161             ++i;
8162         }
8163         if (escape <= maxNumber) {
8164             *pos = i;
8165             return escape;
8166         }
8167     }
8168     return -1;
8169 }
8170 
8171 /*
8172     Algorithm for multiArg:
8173 
8174     1. Parse the string as a sequence of verbatim text and placeholders (%L?\d{,3}).
8175        The L is parsed and accepted for compatibility with non-multi-arg, but since
8176        multiArg only accepts strings as replacements, the localization request can
8177        be safely ignored.
8178     2. The result of step (1) is a list of (string-ref,int)-tuples. The string-ref
8179        either points at text to be copied verbatim (in which case the int is -1),
8180        or, initially, at the textual representation of the placeholder. In that case,
8181        the int contains the numerical number as parsed from the placeholder.
8182     3. Next, collect all the non-negative ints found, sort them in ascending order and
8183        remove duplicates.
8184        3a. If the result has more entires than multiArg() was given replacement strings,
8185            we have found placeholders we can't satisfy with replacement strings. That is
8186            fine (there could be another .arg() call coming after this one), so just
8187            truncate the result to the number of actual multiArg() replacement strings.
8188        3b. If the result has less entries than multiArg() was given replacement strings,
8189            the string is missing placeholders. This is an error that the user should be
8190            warned about.
8191     4. The result of step (3) is a mapping from the index of any replacement string to
8192        placeholder number. This is the wrong way around, but since placeholder
8193        numbers could get as large as 999, while we typically don't have more than 9
8194        replacement strings, we trade 4K of sparsely-used memory for doing a reverse lookup
8195        each time we need to map a placeholder number to a replacement string index
8196        (that's a linear search; but still *much* faster than using an associative container).
8197     5. Next, for each of the tuples found in step (1), do the following:
8198        5a. If the int is negative, do nothing.
8199        5b. Otherwise, if the int is found in the result of step (3) at index I, replace
8200            the string-ref with a string-ref for the (complete) I'th replacement string.
8201        5c. Otherwise, do nothing.
8202     6. Concatenate all string refs into a single result string.
8203 */
8204 
8205 namespace {
8206 struct Part
8207 {
8208     Part() = default; // for QVarLengthArray; do not use
8209     Q_DECL_CONSTEXPR Part(QStringView s, int num = -1)
8210         : tag{QtPrivate::ArgBase::U16}, number{num}, data{s.utf16()}, size{s.size()} {}
8211     Q_DECL_CONSTEXPR Part(QLatin1String s, int num = -1)
8212         : tag{QtPrivate::ArgBase::L1}, number{num}, data{s.data()}, size{s.size()} {}
8213 
8214     void reset(QStringView s) noexcept { *this = {s, number}; }
8215     void reset(QLatin1String s) noexcept { *this = {s, number}; }
8216 
8217     QtPrivate::ArgBase::Tag tag;
8218     int number;
8219     const void *data;
8220     qsizetype size;
8221 };
8222 } // unnamed namespace
8223 
8224 Q_DECLARE_TYPEINFO(Part, Q_PRIMITIVE_TYPE);
8225 
8226 namespace {
8227 
8228 enum { ExpectedParts = 32 };
8229 
8230 typedef QVarLengthArray<Part, ExpectedParts> ParseResult;
8231 typedef QVarLengthArray<int, ExpectedParts/2> ArgIndexToPlaceholderMap;
8232 
8233 template <typename StringView>
8234 static ParseResult parseMultiArgFormatString(StringView s)
8235 {
8236     ParseResult result;
8237 
8238     const auto uc = s.data();
8239     const auto len = s.size();
8240     const auto end = len - 1;
8241     qsizetype i = 0;
8242     qsizetype last = 0;
8243 
8244     while (i < end) {
8245         if (uc[i] == QLatin1Char('%')) {
8246             qsizetype percent = i;
8247             int number = getEscape(uc, &i, len);
8248             if (number != -1) {
8249                 if (last != percent)
8250                     result.push_back(Part{s.mid(last, percent - last)}); // literal text (incl. failed placeholders)
8251                 result.push_back(Part{s.mid(percent, i - percent), number});  // parsed placeholder
8252                 last = i;
8253                 continue;
8254             }
8255         }
8256         ++i;
8257     }
8258 
8259     if (last < len)
8260         result.push_back(Part{s.mid(last, len - last)}); // trailing literal text
8261 
8262     return result;
8263 }
8264 
8265 static ArgIndexToPlaceholderMap makeArgIndexToPlaceholderMap(const ParseResult &parts)
8266 {
8267     ArgIndexToPlaceholderMap result;
8268 
8269     for (Part part : parts) {
8270         if (part.number >= 0)
8271             result.push_back(part.number);
8272     }
8273 
8274     std::sort(result.begin(), result.end());
8275     result.erase(std::unique(result.begin(), result.end()),
8276                  result.end());
8277 
8278     return result;
8279 }
8280 
8281 static qsizetype resolveStringRefsAndReturnTotalSize(ParseResult &parts, const ArgIndexToPlaceholderMap &argIndexToPlaceholderMap, const QtPrivate::ArgBase *args[])
8282 {
8283     using namespace QtPrivate;
8284     qsizetype totalSize = 0;
8285     for (Part &part : parts) {
8286         if (part.number != -1) {
8287             const auto it = std::find(argIndexToPlaceholderMap.begin(), argIndexToPlaceholderMap.end(), part.number);
8288             if (it != argIndexToPlaceholderMap.end()) {
8289                 const auto &arg = *args[it - argIndexToPlaceholderMap.begin()];
8290                 switch (arg.tag) {
8291                 case ArgBase::L1:
8292                     part.reset(static_cast<const QLatin1StringArg&>(arg).string);
8293                     break;
8294                 case ArgBase::U8:
8295                     Q_UNREACHABLE(); // waiting for QUtf8String...
8296                     break;
8297                 case ArgBase::U16:
8298                     part.reset(static_cast<const QStringViewArg&>(arg).string);
8299                     break;
8300                 }
8301             }
8302         }
8303         totalSize += part.size;
8304     }
8305     return totalSize;
8306 }
8307 
8308 } // unnamed namespace
8309 
8310 Q_ALWAYS_INLINE QString to_string(QLatin1String s) noexcept { return s; }
8311 Q_ALWAYS_INLINE QString to_string(QStringView s) noexcept { return s.toString(); }
8312 
8313 template <typename StringView>
8314 static QString argToQStringImpl(StringView pattern, size_t numArgs, const QtPrivate::ArgBase **args)
8315 {
8316     // Step 1-2 above
8317     ParseResult parts = parseMultiArgFormatString(pattern);
8318 
8319     // 3-4
8320     ArgIndexToPlaceholderMap argIndexToPlaceholderMap = makeArgIndexToPlaceholderMap(parts);
8321 
8322     if (static_cast<size_t>(argIndexToPlaceholderMap.size()) > numArgs) // 3a
8323         argIndexToPlaceholderMap.resize(qsizetype(numArgs));
8324     else if (Q_UNLIKELY(static_cast<size_t>(argIndexToPlaceholderMap.size()) < numArgs)) // 3b
8325         qWarning("QString::arg: %d argument(s) missing in %ls",
8326                  int(numArgs - argIndexToPlaceholderMap.size()), qUtf16Printable(to_string(pattern)));
8327 
8328     // 5
8329     const qsizetype totalSize = resolveStringRefsAndReturnTotalSize(parts, argIndexToPlaceholderMap, args);
8330 
8331     // 6:
8332     QString result(totalSize, Qt::Uninitialized);
8333     auto out = const_cast<QChar*>(result.constData());
8334 
8335     for (Part part : parts) {
8336         switch (part.tag) {
8337         case QtPrivate::ArgBase::L1:
8338             if (part.size) {
8339                 qt_from_latin1(reinterpret_cast<char16_t*>(out),
8340                                reinterpret_cast<const char*>(part.data), part.size);
8341             }
8342             break;
8343         case QtPrivate::ArgBase::U8:
8344             Q_UNREACHABLE(); // waiting for QUtf8String
8345             break;
8346         case QtPrivate::ArgBase::U16:
8347             if (part.size)
8348                 memcpy(out, part.data, part.size * sizeof(QChar));
8349             break;
8350         }
8351         out += part.size;
8352     }
8353 
8354     return result;
8355 }
8356 
8357 QString QtPrivate::argToQString(QStringView pattern, size_t n, const ArgBase **args)
8358 {
8359     return argToQStringImpl(pattern, n, args);
8360 }
8361 
8362 QString QtPrivate::argToQString(QLatin1String pattern, size_t n, const ArgBase **args)
8363 {
8364     return argToQStringImpl(pattern, n, args);
8365 }
8366 
8367 /*! \fn bool QString::isSimpleText() const
8368 
8369     \internal
8370 */
8371 bool QString::isSimpleText() const
8372 {
8373     const char16_t *p = d.data();
8374     const char16_t * const end = p + d.size;
8375     while (p < end) {
8376         char16_t uc = *p;
8377         // sort out regions of complex text formatting
8378         if (uc > 0x058f && (uc < 0x1100 || uc > 0xfb0f)) {
8379             return false;
8380         }
8381         p++;
8382     }
8383 
8384     return true;
8385 }
8386 
8387 /*! \fn bool QString::isRightToLeft() const
8388 
8389     Returns \c true if the string is read right to left.
8390 
8391     \sa QStringRef::isRightToLeft()
8392 */
8393 bool QString::isRightToLeft() const
8394 {
8395     return QtPrivate::isRightToLeft(QStringView(*this));
8396 }
8397 
8398 /*!
8399     \fn bool QString::isValidUtf16() const noexcept
8400     \since 5.15
8401 
8402     Returns \c true if the string contains valid UTF-16 encoded data,
8403     or \c false otherwise.
8404 
8405     Note that this function does not perform any special validation of the
8406     data; it merely checks if it can be successfully decoded from UTF-16.
8407     The data is assumed to be in host byte order; the presence of a BOM
8408     is meaningless.
8409 
8410     \sa QStringView::isValidUtf16()
8411 */
8412 
8413 /*! \fn QChar *QString::data()
8414 
8415     Returns a pointer to the data stored in the QString. The pointer
8416     can be used to access and modify the characters that compose the
8417     string.
8418 
8419     Unlike constData() and unicode(), the returned data is always
8420     '\\0'-terminated.
8421 
8422     Example:
8423 
8424     \snippet qstring/main.cpp 19
8425 
8426     Note that the pointer remains valid only as long as the string is
8427     not modified by other means. For read-only access, constData() is
8428     faster because it never causes a \l{deep copy} to occur.
8429 
8430     \sa constData(), operator[]()
8431 */
8432 
8433 /*! \fn const QChar *QString::data() const
8434 
8435     \overload
8436 
8437     \note The returned string may not be '\\0'-terminated.
8438     Use size() to determine the length of the array.
8439 
8440     \sa fromRawData()
8441 */
8442 
8443 /*! \fn const QChar *QString::constData() const
8444 
8445     Returns a pointer to the data stored in the QString. The pointer
8446     can be used to access the characters that compose the string.
8447 
8448     Note that the pointer remains valid only as long as the string is
8449     not modified.
8450 
8451     \note The returned string may not be '\\0'-terminated.
8452     Use size() to determine the length of the array.
8453 
8454     \sa data(), operator[](), fromRawData()
8455 */
8456 
8457 /*! \fn void QString::push_front(const QString &other)
8458 
8459     This function is provided for STL compatibility, prepending the
8460     given \a other string to the beginning of this string. It is
8461     equivalent to \c prepend(other).
8462 
8463     \sa prepend()
8464 */
8465 
8466 /*! \fn void QString::push_front(QChar ch)
8467 
8468     \overload
8469 
8470     Prepends the given \a ch character to the beginning of this string.
8471 */
8472 
8473 /*! \fn void QString::push_back(const QString &other)
8474 
8475     This function is provided for STL compatibility, appending the
8476     given \a other string onto the end of this string. It is
8477     equivalent to \c append(other).
8478 
8479     \sa append()
8480 */
8481 
8482 /*! \fn void QString::push_back(QChar ch)
8483 
8484     \overload
8485 
8486     Appends the given \a ch character onto the end of this string.
8487 */
8488 
8489 /*! \fn void QString::shrink_to_fit()
8490     \since 5.10
8491 
8492     This function is provided for STL compatibility. It is
8493     equivalent to squeeze().
8494 
8495     \sa squeeze()
8496 */
8497 
8498 /*!
8499     \fn std::string QString::toStdString() const
8500 
8501     Returns a std::string object with the data contained in this
8502     QString. The Unicode data is converted into 8-bit characters using
8503     the toUtf8() function.
8504 
8505     This method is mostly useful to pass a QString to a function
8506     that accepts a std::string object.
8507 
8508     \sa toLatin1(), toUtf8(), toLocal8Bit(), QByteArray::toStdString()
8509 */
8510 
8511 /*!
8512     Constructs a QString that uses the first \a size Unicode characters
8513     in the array \a unicode. The data in \a unicode is \e not
8514     copied. The caller must be able to guarantee that \a unicode will
8515     not be deleted or modified as long as the QString (or an
8516     unmodified copy of it) exists.
8517 
8518     Any attempts to modify the QString or copies of it will cause it
8519     to create a deep copy of the data, ensuring that the raw data
8520     isn't modified.
8521 
8522     Here is an example of how we can use a QRegularExpression on raw data in
8523     memory without requiring to copy the data into a QString:
8524 
8525     \snippet qstring/main.cpp 22
8526     \snippet qstring/main.cpp 23
8527 
8528     \warning A string created with fromRawData() is \e not
8529     '\\0'-terminated, unless the raw data contains a '\\0' character
8530     at position \a size. This means unicode() will \e not return a
8531     '\\0'-terminated string (although utf16() does, at the cost of
8532     copying the raw data).
8533 
8534     \sa fromUtf16(), setRawData()
8535 */
8536 QString QString::fromRawData(const QChar *unicode, qsizetype size)
8537 {
8538     return QString(DataPointer::fromRawData(const_cast<char16_t *>(reinterpret_cast<const char16_t *>(unicode)), size));
8539 }
8540 
8541 /*!
8542     \since 4.7
8543 
8544     Resets the QString to use the first \a size Unicode characters
8545     in the array \a unicode. The data in \a unicode is \e not
8546     copied. The caller must be able to guarantee that \a unicode will
8547     not be deleted or modified as long as the QString (or an
8548     unmodified copy of it) exists.
8549 
8550     This function can be used instead of fromRawData() to re-use
8551     existings QString objects to save memory re-allocations.
8552 
8553     \sa fromRawData()
8554 */
8555 QString &QString::setRawData(const QChar *unicode, qsizetype size)
8556 {
8557     if (!unicode || !size) {
8558         clear();
8559     }
8560     *this = fromRawData(unicode, size);
8561     return *this;
8562 }
8563 
8564 /*! \fn QString QString::fromStdU16String(const std::u16string &str)
8565     \since 5.5
8566 
8567     Returns a copy of the \a str string. The given string is assumed
8568     to be encoded in UTF-16.
8569 
8570     \sa fromUtf16(), fromStdWString(), fromStdU32String()
8571 */
8572 
8573 /*!
8574     \fn std::u16string QString::toStdU16String() const
8575     \since 5.5
8576 
8577     Returns a std::u16string object with the data contained in this
8578     QString. The Unicode data is the same as returned by the utf16()
8579     method.
8580 
8581     \sa utf16(), toStdWString(), toStdU32String()
8582 */
8583 
8584 /*! \fn QString QString::fromStdU32String(const std::u32string &str)
8585     \since 5.5
8586 
8587     Returns a copy of the \a str string. The given string is assumed
8588     to be encoded in UCS-4.
8589 
8590     \sa fromUcs4(), fromStdWString(), fromStdU16String()
8591 */
8592 
8593 /*!
8594     \fn std::u32string QString::toStdU32String() const
8595     \since 5.5
8596 
8597     Returns a std::u32string object with the data contained in this
8598     QString. The Unicode data is the same as returned by the toUcs4()
8599     method.
8600 
8601     \sa toUcs4(), toStdWString(), toStdU16String()
8602 */
8603 
8604 /*! \class QLatin1String
8605     \inmodule QtCore
8606     \brief The QLatin1String class provides a thin wrapper around an US-ASCII/Latin-1 encoded string literal.
8607 
8608     \ingroup string-processing
8609     \reentrant
8610 
8611     Many of QString's member functions are overloaded to accept
8612     \c{const char *} instead of QString. This includes the copy
8613     constructor, the assignment operator, the comparison operators,
8614     and various other functions such as \l{QString::insert()}{insert()}, \l{QString::replace()}{replace()},
8615     and \l{QString::indexOf()}{indexOf()}. These functions
8616     are usually optimized to avoid constructing a QString object for
8617     the \c{const char *} data. For example, assuming \c str is a
8618     QString,
8619 
8620     \snippet code/src_corelib_text_qstring.cpp 3
8621 
8622     is much faster than
8623 
8624     \snippet code/src_corelib_text_qstring.cpp 4
8625 
8626     because it doesn't construct four temporary QString objects and
8627     make a deep copy of the character data.
8628 
8629     Applications that define \c QT_NO_CAST_FROM_ASCII (as explained
8630     in the QString documentation) don't have access to QString's
8631     \c{const char *} API. To provide an efficient way of specifying
8632     constant Latin-1 strings, Qt provides the QLatin1String, which is
8633     just a very thin wrapper around a \c{const char *}. Using
8634     QLatin1String, the example code above becomes
8635 
8636     \snippet code/src_corelib_text_qstring.cpp 5
8637 
8638     This is a bit longer to type, but it provides exactly the same
8639     benefits as the first version of the code, and is faster than
8640     converting the Latin-1 strings using QString::fromLatin1().
8641 
8642     Thanks to the QString(QLatin1String) constructor,
8643     QLatin1String can be used everywhere a QString is expected. For
8644     example:
8645 
8646     \snippet code/src_corelib_text_qstring.cpp 6
8647 
8648     \note If the function you're calling with a QLatin1String
8649     argument isn't actually overloaded to take QLatin1String, the
8650     implicit conversion to QString will trigger a memory allocation,
8651     which is usually what you want to avoid by using QLatin1String
8652     in the first place. In those cases, using QStringLiteral may be
8653     the better option.
8654 
8655     \sa QString, QLatin1Char, {QStringLiteral()}{QStringLiteral}, QT_NO_CAST_FROM_ASCII
8656 */
8657 
8658 /*!
8659     \typedef QLatin1String::value_type
8660     \since 5.10
8661 
8662     Alias for \c{const char}. Provided for compatibility with the STL.
8663 */
8664 
8665 /*!
8666     \typedef QLatin1String::difference_type
8667     \since 5.10
8668 
8669     Alias for \c{qsizetype}. Provided for compatibility with the STL.
8670 */
8671 
8672 /*!
8673     \typedef QLatin1String::size_type
8674     \since 5.10
8675 
8676     Alias for \c{qsizetype}. Provided for compatibility with the STL.
8677 */
8678 
8679 /*!
8680     \typedef QLatin1String::reference
8681     \since 5.10
8682 
8683     Alias for \c{value_type &}. Provided for compatibility with the STL.
8684 */
8685 
8686 /*!
8687     \typedef QLatin1String::const_reference
8688     \since 5.11
8689 
8690     Alias for \c{reference}. Provided for compatibility with the STL.
8691 */
8692 
8693 /*!
8694     \typedef QLatin1String::iterator
8695     \since 5.10
8696 
8697     QLatin1String does not support mutable iterators, so this is the same
8698     as const_iterator.
8699 
8700     \sa const_iterator, reverse_iterator
8701 */
8702 
8703 /*!
8704     \typedef QLatin1String::const_iterator
8705     \since 5.10
8706 
8707     \sa iterator, const_reverse_iterator
8708 */
8709 
8710 /*!
8711     \typedef QLatin1String::reverse_iterator
8712     \since 5.10
8713 
8714     QLatin1String does not support mutable reverse iterators, so this is the
8715     same as const_reverse_iterator.
8716 
8717     \sa const_reverse_iterator, iterator
8718 */
8719 
8720 /*!
8721     \typedef QLatin1String::const_reverse_iterator
8722     \since 5.10
8723 
8724     \sa reverse_iterator, const_iterator
8725 */
8726 
8727 /*! \fn QLatin1String::QLatin1String()
8728     \since 5.6
8729 
8730     Constructs a QLatin1String object that stores a nullptr.
8731 */
8732 
8733 /*! \fn QLatin1String::QLatin1String(const char *str)
8734 
8735     Constructs a QLatin1String object that stores \a str.
8736 
8737     The string data is \e not copied. The caller must be able to
8738     guarantee that \a str will not be deleted or modified as long as
8739     the QLatin1String object exists.
8740 
8741     \sa latin1()
8742 */
8743 
8744 /*! \fn QLatin1String::QLatin1String(const char *str, int size)
8745 
8746     Constructs a QLatin1String object that stores \a str with \a size.
8747 
8748     The string data is \e not copied. The caller must be able to
8749     guarantee that \a str will not be deleted or modified as long as
8750     the QLatin1String object exists.
8751 
8752     \sa latin1()
8753 */
8754 
8755 /*!
8756     \fn QLatin1String::QLatin1String(const char *first, const char *last)
8757     \since 5.10
8758 
8759     Constructs a QLatin1String object that stores \a first with length
8760     (\a last - \a first).
8761 
8762     The range \c{[first,last)} must remain valid for the lifetime of
8763     this Latin-1 string object.
8764 
8765     Passing \nullptr as \a first is safe if \a last is \nullptr,
8766     too, and results in a null Latin-1 string.
8767 
8768     The behavior is undefined if \a last precedes \a first, \a first
8769     is \nullptr and \a last is not, or if \c{last - first >
8770     INT_MAX}.
8771 */
8772 
8773 /*! \fn QLatin1String::QLatin1String(const QByteArray &str)
8774 
8775     Constructs a QLatin1String object that stores \a str.
8776 
8777     The string data is \e not copied. The caller must be able to
8778     guarantee that \a str will not be deleted or modified as long as
8779     the QLatin1String object exists.
8780 
8781     \sa latin1()
8782 */
8783 
8784 /*!
8785     \fn QLatin1String::toString() const
8786     \since 6.0
8787 
8788     Converts this Latin-1 string into a QString. Equivalent to
8789     \code
8790     return QString(*this);
8791     \endcode
8792 */
8793 
8794 /*! \fn const char *QLatin1String::latin1() const
8795 
8796     Returns the Latin-1 string stored in this object.
8797 */
8798 
8799 /*! \fn const char *QLatin1String::data() const
8800 
8801     Returns the Latin-1 string stored in this object.
8802 */
8803 
8804 /*! \fn int QLatin1String::size() const
8805 
8806     Returns the size of the Latin-1 string stored in this object.
8807 */
8808 
8809 /*! \fn bool QLatin1String::isNull() const
8810     \since 5.10
8811 
8812     Returns whether the Latin-1 string stored in this object is null
8813     (\c{data() == nullptr}) or not.
8814 
8815     \sa isEmpty(), data()
8816 */
8817 
8818 /*! \fn bool QLatin1String::isEmpty() const
8819     \since 5.10
8820 
8821     Returns whether the Latin-1 string stored in this object is empty
8822     (\c{size() == 0}) or not.
8823 
8824     \sa isNull(), size()
8825 */
8826 
8827 /*! \fn QLatin1Char QLatin1String::at(int pos) const
8828     \since 5.8
8829 
8830     Returns the character at position \a pos in this object.
8831 
8832     \note This function performs no error checking.
8833     The behavior is undefined when \a pos < 0 or \a pos >= size().
8834 
8835     \sa operator[]()
8836 */
8837 
8838 /*! \fn QLatin1Char QLatin1String::operator[](int pos) const
8839     \since 5.8
8840 
8841     Returns the character at position \a pos in this object.
8842 
8843     \note This function performs no error checking.
8844     The behavior is undefined when \a pos < 0 or \a pos >= size().
8845 
8846     \sa at()
8847 */
8848 
8849 /*!
8850     \fn QLatin1Char QLatin1String::front() const
8851     \since 5.10
8852 
8853     Returns the first character in the string.
8854     Same as \c{at(0)}.
8855 
8856     This function is provided for STL compatibility.
8857 
8858     \warning Calling this function on an empty string constitutes
8859     undefined behavior.
8860 
8861     \sa back(), at(), operator[]()
8862 */
8863 
8864 /*!
8865     \fn QLatin1Char QLatin1String::back() const
8866     \since 5.10
8867 
8868     Returns the last character in the string.
8869     Same as \c{at(size() - 1)}.
8870 
8871     This function is provided for STL compatibility.
8872 
8873     \warning Calling this function on an empty string constitutes
8874     undefined behavior.
8875 
8876     \sa front(), at(), operator[]()
8877 */
8878 
8879 /*!
8880     \fn int QLatin1String::compare(QStringView str, Qt::CaseSensitivity cs) const
8881     \fn int QLatin1String::compare(QLatin1String l1, Qt::CaseSensitivity cs) const
8882     \fn int QLatin1String::compare(QChar ch) const
8883     \fn int QLatin1String::compare(QChar ch, Qt::CaseSensitivity cs) const
8884     \since 5.14
8885 
8886     Returns an integer that compares to zero as this Latin-1 string compares to the
8887     string-view \a str, Latin-1 string \a l1, or character \a ch, respectively.
8888 
8889     If \a cs is Qt::CaseSensitive (the default), the comparison is case sensitive;
8890     otherwise the comparison is case-insensitive.
8891 
8892     \sa operator==(), operator<(), operator>()
8893 */
8894 
8895 
8896 /*!
8897     \fn bool QLatin1String::startsWith(QStringView str, Qt::CaseSensitivity cs) const
8898     \since 5.10
8899     \fn bool QLatin1String::startsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
8900     \since 5.10
8901     \fn bool QLatin1String::startsWith(QChar ch) const
8902     \since 5.10
8903     \fn bool QLatin1String::startsWith(QChar ch, Qt::CaseSensitivity cs) const
8904     \since 5.10
8905 
8906     Returns \c true if this Latin-1 string starts with string-view \a str,
8907     Latin-1 string \a l1, or character \a ch, respectively;
8908     otherwise returns \c false.
8909 
8910     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
8911     otherwise the search is case-insensitive.
8912 
8913     \sa endsWith()
8914 */
8915 
8916 /*!
8917     \fn bool QLatin1String::endsWith(QStringView str, Qt::CaseSensitivity cs) const
8918     \since 5.10
8919     \fn bool QLatin1String::endsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
8920     \since 5.10
8921     \fn bool QLatin1String::endsWith(QChar ch) const
8922     \since 5.10
8923     \fn bool QLatin1String::endsWith(QChar ch, Qt::CaseSensitivity cs) const
8924     \since 5.10
8925 
8926     Returns \c true if this Latin-1 string ends with string-view \a str,
8927     Latin-1 string \a l1, or character \a ch, respectively;
8928     otherwise returns \c false.
8929 
8930     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
8931     otherwise the search is case-insensitive.
8932 
8933     \sa startsWith()
8934 */
8935 
8936 /*!
8937     \fn int QLatin1String::indexOf(QStringView str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
8938     \fn int QLatin1String::indexOf(QLatin1String l1, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
8939     \fn int QLatin1String::indexOf(QChar c, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
8940     \since 5.14
8941 
8942     Returns the index position of the first occurrence of the string-view \a str,
8943     Latin-1 string \a l1, or character \a ch, respectively, in this Latin-1 string,
8944     searching forward from index position \a from. Returns -1 if \a str is not found.
8945 
8946     If \a cs is Qt::CaseSensitive (default), the search is case
8947     sensitive; otherwise the search is case insensitive.
8948 
8949     If \a from is -1, the search starts at the last character; if it is
8950     -2, at the next to last character and so on.
8951 
8952     \sa QString::indexOf()
8953 */
8954 
8955 /*!
8956     \fn bool QLatin1String::contains(QStringView str, Qt::CaseSensitivity cs) const
8957     \fn bool QLatin1String::contains(QLatin1String l1, Qt::CaseSensitivity cs) const
8958     \fn bool QLatin1String::contains(QChar c, Qt::CaseSensitivity cs) const
8959     \since 5.14
8960 
8961     Returns \c true if this Latin-1 string contains an occurrence of the string-view
8962     \a str, Latin-1 string \a l1, or character \a ch; otherwise returns \c false.
8963 
8964     If \a cs is Qt::CaseSensitive (the default), the search is
8965     case-sensitive; otherwise the search is case-insensitive.
8966 
8967     \sa indexOf(), QStringView::contains(), QStringView::indexOf(), QString::indexOf()
8968 */
8969 
8970 /*!
8971     \fn int QLatin1String::lastIndexOf(QStringView str, int from, Qt::CaseSensitivity cs) const
8972     \fn int QLatin1String::lastIndexOf(QLatin1String l1, int from, Qt::CaseSensitivity cs) const
8973     \fn int QLatin1String::lastIndexOf(QChar c, int from, Qt::CaseSensitivity cs) const
8974     \since 5.14
8975 
8976     Returns the index position of the last occurrence of the string-view \a str,
8977     Latin-1 string \a l1, or character \a ch, respectively, in this Latin-1 string,
8978     searching backward from index position \a from. If \a from is -1 (default),
8979     the search starts at the last character; if \a from is -2, at the next to last
8980     character and so on. Returns -1 if \a str is not found.
8981 
8982     If \a cs is Qt::CaseSensitive (default), the search is case
8983     sensitive; otherwise the search is case insensitive.
8984 
8985     \sa indexOf(), QStringView::lastIndexOf(), QStringView::indexOf(), QString::indexOf()
8986 */
8987 
8988 /*!
8989     \fn QLatin1String::const_iterator QLatin1String::begin() const
8990     \since 5.10
8991 
8992     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character in
8993     the string.
8994 
8995     This function is provided for STL compatibility.
8996 
8997     \sa end(), cbegin(), rbegin(), data()
8998 */
8999 
9000 /*!
9001     \fn QLatin1String::const_iterator QLatin1String::cbegin() const
9002     \since 5.10
9003 
9004     Same as begin().
9005 
9006     This function is provided for STL compatibility.
9007 
9008     \sa cend(), begin(), crbegin(), data()
9009 */
9010 
9011 /*!
9012     \fn QLatin1String::const_iterator QLatin1String::end() const
9013     \since 5.10
9014 
9015     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
9016     character after the last character in the list.
9017 
9018     This function is provided for STL compatibility.
9019 
9020     \sa begin(), cend(), rend()
9021 */
9022 
9023 /*! \fn QLatin1String::const_iterator QLatin1String::cend() const
9024     \since 5.10
9025 
9026     Same as end().
9027 
9028     This function is provided for STL compatibility.
9029 
9030     \sa cbegin(), end(), crend()
9031 */
9032 
9033 /*!
9034     \fn QLatin1String::const_reverse_iterator QLatin1String::rbegin() const
9035     \since 5.10
9036 
9037     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
9038     character in the string, in reverse order.
9039 
9040     This function is provided for STL compatibility.
9041 
9042     \sa rend(), crbegin(), begin()
9043 */
9044 
9045 /*!
9046     \fn QLatin1String::const_reverse_iterator QLatin1String::crbegin() const
9047     \since 5.10
9048 
9049     Same as rbegin().
9050 
9051     This function is provided for STL compatibility.
9052 
9053     \sa crend(), rbegin(), cbegin()
9054 */
9055 
9056 /*!
9057     \fn QLatin1String::const_reverse_iterator QLatin1String::rend() const
9058     \since 5.10
9059 
9060     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past
9061     the last character in the string, in reverse order.
9062 
9063     This function is provided for STL compatibility.
9064 
9065     \sa rbegin(), crend(), end()
9066 */
9067 
9068 /*!
9069     \fn QLatin1String::const_reverse_iterator QLatin1String::crend() const
9070     \since 5.10
9071 
9072     Same as rend().
9073 
9074     This function is provided for STL compatibility.
9075 
9076     \sa crbegin(), rend(), cend()
9077 */
9078 
9079 /*! \fn QLatin1String QLatin1String::mid(int start, int length) const
9080     \since 5.8
9081 
9082     Returns the substring of length \a length starting at position
9083     \a start in this object.
9084 
9085     Returns a null string if the \a start index exceeds the
9086     length of the string. If there are less than \a length characters
9087     available in the string starting at \a start, or if
9088     \a length is negative (default), the function returns all characters
9089     that are available from \a start.
9090 
9091     \sa left(), right(), chopped(), chop(), truncate()
9092 */
9093 
9094 /*! \fn QLatin1String QLatin1String::left(int length) const
9095     \since 5.8
9096 
9097     Returns the substring of length \a length starting at position
9098     0 in this object.
9099 
9100     The entire string is returned if \a length is greater than or equal
9101     to size(), or less than zero.
9102 
9103     \sa mid(), right(), chopped(), chop(), truncate()
9104 */
9105 
9106 /*! \fn QLatin1String QLatin1String::right(int length) const
9107     \since 5.8
9108 
9109     Returns the substring of length \a length starting at position
9110     size() - \a length in this object.
9111 
9112     The entire string is returned if \a length is greater than or equal
9113     to size(), or less than zero.
9114 
9115     \sa mid(), left(), chopped(), chop(), truncate()
9116 */
9117 
9118 /*!
9119     \fn QLatin1String QLatin1String::chopped(int length) const
9120     \since 5.10
9121 
9122     Returns the substring of length size() - \a length starting at the
9123     beginning of this object.
9124 
9125     Same as \c{left(size() - length)}.
9126 
9127     \note The behavior is undefined when \a length < 0 or \a length > size().
9128 
9129     \sa mid(), left(), right(), chop(), truncate()
9130 */
9131 
9132 /*!
9133     \fn void QLatin1String::truncate(int length)
9134     \since 5.10
9135 
9136     Truncates this string to length \a length.
9137 
9138     Same as \c{*this = left(length)}.
9139 
9140     \note The behavior is undefined when \a length < 0 or \a length > size().
9141 
9142     \sa mid(), left(), right(), chopped(), chop()
9143 */
9144 
9145 /*!
9146     \fn void QLatin1String::chop(int length)
9147     \since 5.10
9148 
9149     Truncates this string by \a length characters.
9150 
9151     Same as \c{*this = left(size() - length)}.
9152 
9153     \note The behavior is undefined when \a length < 0 or \a length > size().
9154 
9155     \sa mid(), left(), right(), chopped(), truncate()
9156 */
9157 
9158 /*!
9159     \fn QLatin1String QLatin1String::trimmed() const
9160     \since 5.10
9161 
9162     Strips leading and trailing whitespace and returns the result.
9163 
9164     Whitespace means any character for which QChar::isSpace() returns
9165     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
9166     '\\f', '\\r', and ' '.
9167 */
9168 
9169 /*! \fn bool QLatin1String::operator==(const QString &other) const
9170 
9171     Returns \c true if this string is equal to string \a other;
9172     otherwise returns \c false.
9173 
9174     \sa {Comparing Strings}
9175 */
9176 
9177 /*!
9178     \fn bool QLatin1String::operator==(const char *other) const
9179     \since 4.3
9180     \overload
9181 
9182     The \a other const char pointer is converted to a QString using
9183     the QString::fromUtf8() function.
9184 
9185     You can disable this operator by defining \c
9186     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9187     can be useful if you want to ensure that all user-visible strings
9188     go through QObject::tr(), for example.
9189 
9190     \sa QT_NO_CAST_FROM_ASCII
9191 */
9192 
9193 /*!
9194     \fn bool QLatin1String::operator==(const QByteArray &other) const
9195     \since 5.0
9196     \overload
9197 
9198     The \a other byte array is converted to a QString using
9199     the QString::fromUtf8() function.
9200 
9201     You can disable this operator by defining \c
9202     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9203     can be useful if you want to ensure that all user-visible strings
9204     go through QObject::tr(), for example.
9205 
9206     \sa QT_NO_CAST_FROM_ASCII
9207 */
9208 
9209 /*! \fn bool QLatin1String::operator!=(const QString &other) const
9210 
9211     Returns \c true if this string is not equal to string \a other;
9212     otherwise returns \c false.
9213 
9214     \sa {Comparing Strings}
9215 */
9216 
9217 /*!
9218     \fn bool QLatin1String::operator!=(const char *other) const
9219     \since 4.3
9220     \overload operator!=()
9221 
9222     The \a other const char pointer is converted to a QString using
9223     the QString::fromUtf8() function.
9224 
9225     You can disable this operator by defining \c
9226     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9227     can be useful if you want to ensure that all user-visible strings
9228     go through QObject::tr(), for example.
9229 
9230     \sa QT_NO_CAST_FROM_ASCII
9231 */
9232 
9233 /*!
9234     \fn bool QLatin1String::operator!=(const QByteArray &other) const
9235     \since 5.0
9236     \overload operator!=()
9237 
9238     The \a other byte array is converted to a QString using
9239     the QString::fromUtf8() function.
9240 
9241     You can disable this operator by defining \c
9242     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9243     can be useful if you want to ensure that all user-visible strings
9244     go through QObject::tr(), for example.
9245 
9246     \sa QT_NO_CAST_FROM_ASCII
9247 */
9248 
9249 /*!
9250     \fn bool QLatin1String::operator>(const QString &other) const
9251 
9252     Returns \c true if this string is lexically greater than string \a
9253     other; otherwise returns \c false.
9254 
9255     \sa {Comparing Strings}
9256 */
9257 
9258 /*!
9259     \fn bool QLatin1String::operator>(const char *other) const
9260     \since 4.3
9261     \overload
9262 
9263     The \a other const char pointer is converted to a QString using
9264     the QString::fromUtf8() function.
9265 
9266     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
9267     when you compile your applications. This can be useful if you want
9268     to ensure that all user-visible strings go through QObject::tr(),
9269     for example.
9270 
9271     \sa QT_NO_CAST_FROM_ASCII
9272 */
9273 
9274 /*!
9275     \fn bool QLatin1String::operator>(const QByteArray &other) const
9276     \since 5.0
9277     \overload
9278 
9279     The \a other const char pointer is converted to a QString using
9280     the QString::fromUtf8() function.
9281 
9282     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
9283     when you compile your applications. This can be useful if you want
9284     to ensure that all user-visible strings go through QObject::tr(),
9285     for example.
9286 
9287     \sa QT_NO_CAST_FROM_ASCII
9288 */
9289 
9290 /*!
9291     \fn bool QLatin1String::operator<(const QString &other) const
9292 
9293     Returns \c true if this string is lexically less than the \a other
9294     string; otherwise returns \c false.
9295 
9296     \sa {Comparing Strings}
9297 */
9298 
9299 /*!
9300     \fn bool QLatin1String::operator<(const char *other) const
9301     \since 4.3
9302     \overload
9303 
9304     The \a other const char pointer is converted to a QString using
9305     the QString::fromUtf8() function.
9306 
9307     You can disable this operator by defining \c
9308     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9309     can be useful if you want to ensure that all user-visible strings
9310     go through QObject::tr(), for example.
9311 
9312     \sa QT_NO_CAST_FROM_ASCII
9313 */
9314 
9315 /*!
9316     \fn bool QLatin1String::operator<(const QByteArray &other) const
9317     \since 5.0
9318     \overload
9319 
9320     The \a other const char pointer is converted to a QString using
9321     the QString::fromUtf8() function.
9322 
9323     You can disable this operator by defining \c
9324     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9325     can be useful if you want to ensure that all user-visible strings
9326     go through QObject::tr(), for example.
9327 
9328     \sa QT_NO_CAST_FROM_ASCII
9329 */
9330 
9331 /*!
9332     \fn bool QLatin1String::operator>=(const QString &other) const
9333 
9334     Returns \c true if this string is lexically greater than or equal
9335     to string \a other; otherwise returns \c false.
9336 
9337     \sa {Comparing Strings}
9338 */
9339 
9340 /*!
9341     \fn bool QLatin1String::operator>=(const char *other) const
9342     \since 4.3
9343     \overload
9344 
9345     The \a other const char pointer is converted to a QString using
9346     the QString::fromUtf8() function.
9347 
9348     You can disable this operator by defining \c
9349     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9350     can be useful if you want to ensure that all user-visible strings
9351     go through QObject::tr(), for example.
9352 
9353     \sa QT_NO_CAST_FROM_ASCII
9354 */
9355 
9356 /*!
9357     \fn bool QLatin1String::operator>=(const QByteArray &other) const
9358     \since 5.0
9359     \overload
9360 
9361     The \a other array is converted to a QString using
9362     the QString::fromUtf8() function.
9363 
9364     You can disable this operator by defining \c
9365     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9366     can be useful if you want to ensure that all user-visible strings
9367     go through QObject::tr(), for example.
9368 
9369     \sa QT_NO_CAST_FROM_ASCII
9370 */
9371 
9372 /*! \fn bool QLatin1String::operator<=(const QString &other) const
9373 
9374     Returns \c true if this string is lexically less than or equal
9375     to string \a other; otherwise returns \c false.
9376 
9377     \sa {Comparing Strings}
9378 */
9379 
9380 /*!
9381     \fn bool QLatin1String::operator<=(const char *other) const
9382     \since 4.3
9383     \overload
9384 
9385     The \a other const char pointer is converted to a QString using
9386     the QString::fromUtf8() function.
9387 
9388     You can disable this operator by defining \c
9389     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9390     can be useful if you want to ensure that all user-visible strings
9391     go through QObject::tr(), for example.
9392 
9393     \sa QT_NO_CAST_FROM_ASCII
9394 */
9395 
9396 /*!
9397     \fn bool QLatin1String::operator<=(const QByteArray &other) const
9398     \since 5.0
9399     \overload
9400 
9401     The \a other array is converted to a QString using
9402     the QString::fromUtf8() function.
9403 
9404     You can disable this operator by defining \c
9405     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9406     can be useful if you want to ensure that all user-visible strings
9407     go through QObject::tr(), for example.
9408 
9409     \sa QT_NO_CAST_FROM_ASCII
9410 */
9411 
9412 
9413 /*! \fn bool operator==(QLatin1String s1, QLatin1String s2)
9414    \relates QLatin1String
9415 
9416    Returns \c true if string \a s1 is lexically equal to string \a s2; otherwise
9417    returns \c false.
9418 */
9419 /*! \fn bool operator!=(QLatin1String s1, QLatin1String s2)
9420    \relates QLatin1String
9421 
9422    Returns \c true if string \a s1 is lexically unequal to string \a s2; otherwise
9423    returns \c false.
9424 */
9425 /*! \fn bool operator<(QLatin1String s1, QLatin1String s2)
9426    \relates QLatin1String
9427 
9428    Returns \c true if string \a s1 is lexically smaller than string \a s2; otherwise
9429    returns \c false.
9430 */
9431 /*! \fn bool operator<=(QLatin1String s1, QLatin1String s2)
9432    \relates QLatin1String
9433 
9434    Returns \c true if string \a s1 is lexically smaller than or equal to string \a s2; otherwise
9435    returns \c false.
9436 */
9437 /*! \fn bool operator>(QLatin1String s1, QLatin1String s2)
9438    \relates QLatin1String
9439 
9440    Returns \c true if string \a s1 is lexically greater than string \a s2; otherwise
9441    returns \c false.
9442 */
9443 /*! \fn bool operator>=(QLatin1String s1, QLatin1String s2)
9444    \relates QLatin1String
9445 
9446    Returns \c true if string \a s1 is lexically greater than or equal to
9447    string \a s2; otherwise returns \c false.
9448 */
9449 
9450 
9451 #if !defined(QT_NO_DATASTREAM) || (defined(QT_BOOTSTRAPPED) && !defined(QT_BUILD_QMAKE))
9452 /*!
9453     \fn QDataStream &operator<<(QDataStream &stream, const QString &string)
9454     \relates QString
9455 
9456     Writes the given \a string to the specified \a stream.
9457 
9458     \sa {Serializing Qt Data Types}
9459 */
9460 
9461 QDataStream &operator<<(QDataStream &out, const QString &str)
9462 {
9463     if (out.version() == 1) {
9464         out << str.toLatin1();
9465     } else {
9466         if (!str.isNull() || out.version() < 3) {
9467             if ((out.byteOrder() == QDataStream::BigEndian) == (QSysInfo::ByteOrder == QSysInfo::BigEndian)) {
9468                 out.writeBytes(reinterpret_cast<const char *>(str.unicode()), size_t(sizeof(QChar) * str.length()));
9469             } else {
9470                 QVarLengthArray<char16_t> buffer(str.length());
9471                 qbswap<sizeof(char16_t)>(str.constData(), str.length(), buffer.data());
9472                 out.writeBytes(reinterpret_cast<const char *>(buffer.data()), size_t(sizeof(char16_t) * buffer.size()));
9473             }
9474         } else {
9475             // write null marker
9476             out << (quint32)0xffffffff;
9477         }
9478     }
9479     return out;
9480 }
9481 
9482 /*!
9483     \fn QDataStream &operator>>(QDataStream &stream, QString &string)
9484     \relates QString
9485 
9486     Reads a string from the specified \a stream into the given \a string.
9487 
9488     \sa {Serializing Qt Data Types}
9489 */
9490 
9491 QDataStream &operator>>(QDataStream &in, QString &str)
9492 {
9493     if (in.version() == 1) {
9494         QByteArray l;
9495         in >> l;
9496         str = QString::fromLatin1(l);
9497     } else {
9498         quint32 bytes = 0;
9499         in >> bytes;                                  // read size of string
9500         if (bytes == 0xffffffff) {                    // null string
9501             str.clear();
9502         } else if (bytes > 0) {                       // not empty
9503             if (bytes & 0x1) {
9504                 str.clear();
9505                 in.setStatus(QDataStream::ReadCorruptData);
9506                 return in;
9507             }
9508 
9509             const quint32 Step = 1024 * 1024;
9510             quint32 len = bytes / 2;
9511             quint32 allocated = 0;
9512 
9513             while (allocated < len) {
9514                 int blockSize = qMin(Step, len - allocated);
9515                 str.resize(allocated + blockSize);
9516                 if (in.readRawData(reinterpret_cast<char *>(str.data()) + allocated * 2,
9517                                    blockSize * 2) != blockSize * 2) {
9518                     str.clear();
9519                     in.setStatus(QDataStream::ReadPastEnd);
9520                     return in;
9521                 }
9522                 allocated += blockSize;
9523             }
9524 
9525             if ((in.byteOrder() == QDataStream::BigEndian)
9526                     != (QSysInfo::ByteOrder == QSysInfo::BigEndian)) {
9527                 char16_t *data = reinterpret_cast<char16_t *>(str.data());
9528                 qbswap<sizeof(*data)>(data, len, data);
9529             }
9530         } else {
9531             str = QString(QLatin1String(""));
9532         }
9533     }
9534     return in;
9535 }
9536 #endif // QT_NO_DATASTREAM
9537 
9538 
9539 
9540 
9541 /*!
9542     \class QStringRef
9543     \inmodule QtCore
9544     \since 4.3
9545     \brief The QStringRef class provides a thin wrapper around QString substrings.
9546     \reentrant
9547     \ingroup tools
9548     \ingroup string-processing
9549 
9550     QStringRef provides a read-only subset of the QString API.
9551 
9552     A string reference explicitly references a portion of a string()
9553     with a given size(), starting at a specific position(). Calling
9554     toString() returns a copy of the data as a real QString instance.
9555 
9556     This class is designed to improve the performance of substring
9557     handling when manipulating substrings obtained from existing QString
9558     instances. QStringRef avoids the memory allocation and reference
9559     counting overhead of a standard QString by simply referencing a
9560     part of the original string. This can prove to be advantageous in
9561     low level code, such as that used in a parser, at the expense of
9562     potentially more complex code.
9563 
9564     For most users, there are no semantic benefits to using QStringRef
9565     instead of QString since QStringRef requires attention to be paid
9566     to memory management issues, potentially making code more complex
9567     to write and maintain.
9568 
9569     \warning A QStringRef is only valid as long as the referenced
9570     string exists. If the original string is deleted, the string
9571     reference points to an invalid memory location.
9572 
9573     We suggest that you only use this class in stable code where profiling
9574     has clearly identified that performance improvements can be made by
9575     replacing standard string operations with the optimized substring
9576     handling provided by this class.
9577 
9578     \sa {Implicitly Shared Classes}
9579 */
9580 
9581 /*!
9582     \typedef QStringRef::size_type
9583     \internal
9584 */
9585 
9586 /*!
9587     \typedef QStringRef::value_type
9588     \internal
9589 */
9590 
9591 /*!
9592     \typedef QStringRef::const_pointer
9593     \internal
9594 */
9595 
9596 /*!
9597     \typedef QStringRef::const_reference
9598     \internal
9599 */
9600 
9601 /*!
9602     \typedef QStringRef::const_iterator
9603     \since 5.4
9604 
9605     \sa QStringRef::const_reverse_iterator
9606 */
9607 
9608 /*!
9609     \typedef QStringRef::const_reverse_iterator
9610     \since 5.7
9611 
9612     \sa QStringRef::const_iterator
9613 */
9614 
9615 /*!
9616  \fn QStringRef::QStringRef()
9617 
9618  Constructs an empty string reference.
9619 */
9620 
9621 /*! \fn QStringRef::QStringRef(const QString *string, int position, int length)
9622 
9623 Constructs a string reference to the range of characters in the given
9624 \a string specified by the starting \a position and \a length in characters.
9625 
9626 \warning This function exists to improve performance as much as possible,
9627 and performs no bounds checking. For program correctness, \a position and
9628 \a length must describe a valid substring of \a string.
9629 
9630 This means that the starting \a position must be positive or 0 and smaller
9631 than \a string's length, and \a length must be positive or 0 but smaller than
9632 the string's length minus the starting \a position;
9633 i.e, 0 <= position < string->length() and
9634 0 <= length <= string->length() - position must both be satisfied.
9635 */
9636 
9637 /*! \fn QStringRef::QStringRef(const QString *string)
9638 
9639 Constructs a string reference to the given \a string.
9640 */
9641 
9642 /*! \fn QStringRef::QStringRef(const QStringRef &other)
9643 
9644 Constructs a copy of the \a other string reference.
9645  */
9646 /*!
9647 \fn QStringRef::~QStringRef()
9648 
9649 Destroys the string reference.
9650 
9651 Since this class is only used to refer to string data, and does not take
9652 ownership of it, no memory is freed when instances are destroyed.
9653 */
9654 
9655 /*!
9656     \fn int QStringRef::position() const
9657 
9658     Returns the starting position in the referenced string that is referred to
9659     by the string reference.
9660 
9661     \sa size(), string()
9662 */
9663 
9664 /*!
9665     \fn int QStringRef::size() const
9666 
9667     Returns the number of characters referred to by the string reference.
9668     Equivalent to length() and count().
9669 
9670     \sa position(), string()
9671 */
9672 /*!
9673     \fn int QStringRef::count() const
9674     Returns the number of characters referred to by the string reference.
9675     Equivalent to size() and length().
9676 
9677     \sa position(), string()
9678 */
9679 /*!
9680     \fn int QStringRef::length() const
9681     Returns the number of characters referred to by the string reference.
9682     Equivalent to size() and count().
9683 
9684     \sa position(), string()
9685 */
9686 
9687 
9688 /*!
9689     \fn bool QStringRef::isEmpty() const
9690 
9691     Returns \c true if the string reference has no characters; otherwise returns
9692     \c false.
9693 
9694     A string reference is empty if its size is zero.
9695 
9696     \sa size()
9697 */
9698 
9699 /*!
9700     \fn bool QStringRef::isNull() const
9701 
9702     Returns \c true if this string reference does not reference a string or if
9703     the string it references is null (i.e. QString::isNull() is true).
9704 
9705     \sa size()
9706 */
9707 
9708 /*!
9709     \fn const QString *QStringRef::string() const
9710 
9711     Returns a pointer to the string referred to by the string reference, or
9712     0 if it does not reference a string.
9713 
9714     \sa unicode()
9715 */
9716 
9717 
9718 /*!
9719     \fn const QChar *QStringRef::unicode() const
9720 
9721     Returns a Unicode representation of the string reference. Since
9722     the data stems directly from the referenced string, it is not
9723     \\0'-terminated unless the string reference includes the string's
9724     null terminator.
9725 
9726     \sa string()
9727 */
9728 
9729 /*!
9730     \fn const QChar *QStringRef::data() const
9731 
9732     Same as unicode().
9733 */
9734 
9735 /*!
9736     \fn const QChar *QStringRef::constData() const
9737 
9738     Same as unicode().
9739 */
9740 
9741 /*!
9742     \fn QStringRef::const_iterator QStringRef::begin() const
9743     \since 5.4
9744 
9745     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character in
9746     the string.
9747 
9748     \sa cbegin(), constBegin(), end(), constEnd(), rbegin(), rend()
9749 */
9750 
9751 /*!
9752     \fn QStringRef::const_iterator QStringRef::cbegin() const
9753     \since 5.4
9754 
9755     Same as begin().
9756 
9757     \sa begin(), constBegin(), cend(), constEnd(), rbegin(), rend()
9758 */
9759 
9760 /*!
9761     \fn QStringRef::const_iterator QStringRef::constBegin() const
9762     \since 5.9
9763 
9764     Same as begin().
9765 
9766     \sa begin(), cend(), constEnd(), rbegin(), rend()
9767 */
9768 
9769 /*!
9770     \fn QStringRef::const_iterator QStringRef::end() const
9771     \since 5.4
9772 
9773     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
9774     character after the last character in the list.
9775 
9776     \sa cbegin(), constBegin(), end(), constEnd(), rbegin(), rend()
9777 */
9778 
9779 /*! \fn QStringRef::const_iterator QStringRef::cend() const
9780     \since 5.4
9781 
9782     Same as end().
9783 
9784     \sa end(), constEnd(), cbegin(), constBegin(), rbegin(), rend()
9785 */
9786 
9787 /*! \fn QStringRef::const_iterator QStringRef::constEnd() const
9788     \since 5.9
9789 
9790     Same as end().
9791 
9792     \sa end(), cend(), cbegin(), constBegin(), rbegin(), rend()
9793 */
9794 
9795 /*!
9796     \fn QStringRef::const_reverse_iterator QStringRef::rbegin() const
9797     \since 5.7
9798 
9799     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
9800     character in the string, in reverse order.
9801 
9802     \sa begin(), crbegin(), rend()
9803 */
9804 
9805 /*!
9806     \fn QStringRef::const_reverse_iterator QStringRef::crbegin() const
9807     \since 5.7
9808 
9809     Same as rbegin().
9810 
9811     \sa begin(), rbegin(), rend()
9812 */
9813 
9814 /*!
9815     \fn QStringRef::const_reverse_iterator QStringRef::rend() const
9816     \since 5.7
9817 
9818     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past
9819     the last character in the string, in reverse order.
9820 
9821     \sa end(), crend(), rbegin()
9822 */
9823 
9824 
9825 /*!
9826     \fn QStringRef::const_reverse_iterator QStringRef::crend() const
9827     \since 5.7
9828 
9829     Same as rend().
9830 
9831     \sa end(), rend(), rbegin()
9832 */
9833 
9834 /*!
9835     Returns a copy of the string reference as a QString object.
9836 
9837     If the string reference is not a complete reference of the string
9838     (meaning that position() is 0 and size() equals string()->size()),
9839     this function will allocate a new string to return.
9840 
9841     \sa string()
9842 */
9843 
9844 QString QStringRef::toString() const {
9845     if (isNull())
9846         return QString();
9847     if (m_size && m_position == 0 && m_size == m_string->size())
9848         return *m_string;
9849     return QString(m_string->unicode() + m_position, m_size);
9850 }
9851 
9852 
9853 /*! \relates QStringRef
9854 
9855    Returns \c true if string reference \a s1 is lexically equal to string reference \a s2; otherwise
9856    returns \c false.
9857 */
9858 bool operator==(const QStringRef &s1,const QStringRef &s2) noexcept
9859 {
9860     return s1.size() == s2.size() && qt_compare_strings(s1, s2, Qt::CaseSensitive) == 0;
9861 }
9862 
9863 /*! \relates QStringRef
9864 
9865    Returns \c true if string \a s1 is lexically equal to string reference \a s2; otherwise
9866    returns \c false.
9867 */
9868 bool operator==(const QString &s1,const QStringRef &s2) noexcept
9869 {
9870     return s1.size() == s2.size() && qt_compare_strings(s1, s2, Qt::CaseSensitive) == 0;
9871 }
9872 
9873 /*! \relates QStringRef
9874 
9875    Returns \c true if string  \a s1 is lexically equal to string reference \a s2; otherwise
9876    returns \c false.
9877 */
9878 bool operator==(QLatin1String s1, const QStringRef &s2) noexcept
9879 {
9880     if (s1.size() != s2.size())
9881         return false;
9882 
9883     return qt_compare_strings(s2, s1, Qt::CaseSensitive) == 0;
9884 }
9885 
9886 /*!
9887    \relates QStringRef
9888 
9889     Returns \c true if string reference \a s1 is lexically less than
9890     string reference \a s2; otherwise returns \c false.
9891 
9892     \sa {Comparing Strings}
9893 */
9894 bool operator<(const QStringRef &s1,const QStringRef &s2) noexcept
9895 {
9896     return qt_compare_strings(s1, s2, Qt::CaseSensitive) < 0;
9897 }
9898 
9899 /*!\fn bool operator<=(const QStringRef &s1,const QStringRef &s2)
9900 
9901    \relates QStringRef
9902 
9903     Returns \c true if string reference \a s1 is lexically less than
9904     or equal to string reference \a s2; otherwise returns \c false.
9905 
9906     \sa {Comparing Strings}
9907 */
9908 
9909 /*!\fn bool operator>=(const QStringRef &s1,const QStringRef &s2)
9910 
9911    \relates QStringRef
9912 
9913     Returns \c true if string reference \a s1 is lexically greater than
9914     or equal to string reference \a s2; otherwise returns \c false.
9915 
9916     \sa {Comparing Strings}
9917 */
9918 
9919 /*!\fn bool operator>(const QStringRef &s1,const QStringRef &s2)
9920 
9921    \relates QStringRef
9922 
9923     Returns \c true if string reference \a s1 is lexically greater than
9924     string reference \a s2; otherwise returns \c false.
9925 
9926     \sa {Comparing Strings}
9927 */
9928 
9929 
9930 /*!
9931     \fn const QChar QStringRef::at(int position) const
9932 
9933     Returns the character at the given index \a position in the
9934     string reference.
9935 
9936     The \a position must be a valid index position in the string
9937     (i.e., 0 <= \a position < size()).
9938 */
9939 
9940 /*!
9941     \fn QChar QStringRef::operator[](int position) const
9942     \since 5.7
9943 
9944     Returns the character at the given index \a position in the
9945     string reference.
9946 
9947     The \a position must be a valid index position in the string
9948     reference (i.e., 0 <= \a position < size()).
9949 
9950     \sa at()
9951 */
9952 
9953 /*!
9954     \fn QChar QStringRef::front() const
9955     \since 5.10
9956 
9957     Returns the first character in the string.
9958     Same as \c{at(0)}.
9959 
9960     This function is provided for STL compatibility.
9961 
9962     \warning Calling this function on an empty string constitutes
9963     undefined behavior.
9964 
9965     \sa back(), at(), operator[]()
9966 */
9967 
9968 /*!
9969     \fn QChar QStringRef::back() const
9970     \since 5.10
9971 
9972     Returns the last character in the string.
9973     Same as \c{at(size() - 1)}.
9974 
9975     This function is provided for STL compatibility.
9976 
9977     \warning Calling this function on an empty string constitutes
9978     undefined behavior.
9979 
9980     \sa front(), at(), operator[]()
9981 */
9982 
9983 /*!
9984     \fn void QStringRef::clear()
9985 
9986     Clears the contents of the string reference by making it null and empty.
9987 
9988     \sa isEmpty(), isNull()
9989 */
9990 
9991 /*!
9992     \fn QStringRef &QStringRef::operator=(const QStringRef &other)
9993 
9994     Assigns the \a other string reference to this string reference, and
9995     returns the result.
9996 */
9997 
9998 /*!
9999     \fn QStringRef &QStringRef::operator=(const QString *string)
10000 
10001     Constructs a string reference to the given \a string and assigns it to
10002     this string reference, returning the result.
10003 */
10004 
10005 /*!
10006     \fn bool QStringRef::operator==(const char * s) const
10007 
10008     \overload operator==()
10009 
10010     The \a s byte array is converted to a QStringRef using the
10011     fromUtf8() function. This function stops conversion at the
10012     first NUL character found, or the end of the byte array.
10013 
10014     You can disable this operator by defining \c
10015     QT_NO_CAST_FROM_ASCII when you compile your applications. This
10016     can be useful if you want to ensure that all user-visible strings
10017     go through QObject::tr(), for example.
10018 
10019     Returns \c true if this string is lexically equal to the parameter
10020     string \a s. Otherwise returns \c false.
10021 
10022     \sa QT_NO_CAST_FROM_ASCII
10023 */
10024 
10025 /*!
10026     \fn bool QStringRef::operator!=(const char * s) const
10027 
10028     \overload operator!=()
10029 
10030     The \a s const char pointer is converted to a QStringRef using
10031     the fromUtf8() function.
10032 
10033     You can disable this operator by defining \c
10034     QT_NO_CAST_FROM_ASCII when you compile your applications. This
10035     can be useful if you want to ensure that all user-visible strings
10036     go through QObject::tr(), for example.
10037 
10038     Returns \c true if this string is not lexically equal to the parameter
10039     string \a s. Otherwise returns \c false.
10040 
10041     \sa QT_NO_CAST_FROM_ASCII
10042 */
10043 
10044 /*!
10045     \fn bool QStringRef::operator<(const char * s) const
10046 
10047     \overload operator<()
10048 
10049     The \a s const char pointer is converted to a QStringRef using
10050     the fromUtf8() function.
10051 
10052     You can disable this operator by defining \c
10053     QT_NO_CAST_FROM_ASCII when you compile your applications. This
10054     can be useful if you want to ensure that all user-visible strings
10055     go through QObject::tr(), for example.
10056 
10057     Returns \c true if this string is lexically smaller than the parameter
10058     string \a s. Otherwise returns \c false.
10059 
10060     \sa QT_NO_CAST_FROM_ASCII
10061 */
10062 
10063 /*!
10064     \fn bool QStringRef::operator<=(const char * s) const
10065 
10066     \overload operator<=()
10067 
10068     The \a s const char pointer is converted to a QStringRef using
10069     the fromUtf8() function.
10070 
10071     You can disable this operator by defining \c
10072     QT_NO_CAST_FROM_ASCII when you compile your applications. This
10073     can be useful if you want to ensure that all user-visible strings
10074     go through QObject::tr(), for example.
10075 
10076     Returns \c true if this string is lexically smaller than or equal to the parameter
10077     string \a s. Otherwise returns \c false.
10078 
10079     \sa QT_NO_CAST_FROM_ASCII
10080 */
10081 
10082 /*!
10083     \fn bool QStringRef::operator>(const char * s) const
10084 
10085 
10086     \overload operator>()
10087 
10088     The \a s const char pointer is converted to a QStringRef using
10089     the fromUtf8() function.
10090 
10091     You can disable this operator by defining \c
10092     QT_NO_CAST_FROM_ASCII when you compile your applications. This
10093     can be useful if you want to ensure that all user-visible strings
10094     go through QObject::tr(), for example.
10095 
10096     Returns \c true if this string is lexically greater than the parameter
10097     string \a s. Otherwise returns \c false.
10098 
10099     \sa QT_NO_CAST_FROM_ASCII
10100 */
10101 
10102 /*!
10103     \fn bool QStringRef::operator>= (const char * s) const
10104 
10105     \overload operator>=()
10106 
10107     The \a s const char pointer is converted to a QStringRef using
10108     the fromUtf8() function.
10109 
10110     You can disable this operator by defining \c
10111     QT_NO_CAST_FROM_ASCII when you compile your applications. This
10112     can be useful if you want to ensure that all user-visible strings
10113     go through QObject::tr(), for example.
10114 
10115     Returns \c true if this string is lexically greater than or equal to the
10116     parameter string \a s. Otherwise returns \c false.
10117 
10118     \sa QT_NO_CAST_FROM_ASCII
10119 */
10120 /*!
10121     \typedef QString::Data
10122     \internal
10123 */
10124 
10125 /*!
10126     \typedef QString::DataPtr
10127     \internal
10128 */
10129 
10130 /*!
10131     \fn DataPtr & QString::data_ptr()
10132     \internal
10133 */
10134 
10135 
10136 
10137 /*!  Appends the string reference to \a string, and returns a new
10138 reference to the combined string data.
10139  */
10140 QStringRef QStringRef::appendTo(QString *string) const
10141 {
10142     if (!string)
10143         return QStringRef();
10144     int pos = string->size();
10145     string->insert(pos, unicode(), size());
10146     return QStringRef(string, pos, size());
10147 }
10148 
10149 /*!
10150     \fn int QStringRef::compare(const QStringRef &s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
10151     \since 4.5
10152 
10153     Compares the string \a s1 with the string \a s2 and returns an
10154     integer less than, equal to, or greater than zero if \a s1
10155     is less than, equal to, or greater than \a s2.
10156 
10157     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10158     otherwise the comparison is case insensitive.
10159 */
10160 
10161 /*!
10162     \fn int QStringRef::compare(const QStringRef &s1, const QStringRef &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
10163     \since 4.5
10164     \overload
10165 
10166     Compares the string \a s1 with the string \a s2 and returns an
10167     integer less than, equal to, or greater than zero if \a s1
10168     is less than, equal to, or greater than \a s2.
10169 
10170     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10171     otherwise the comparison is case insensitive.
10172 */
10173 
10174 /*!
10175     \fn int QStringRef::compare(const QStringRef &s1, QLatin1String s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
10176     \since 4.5
10177     \overload
10178 
10179     Compares the string \a s1 with the string \a s2 and returns an
10180     integer less than, equal to, or greater than zero if \a s1
10181     is less than, equal to, or greater than \a s2.
10182 
10183     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10184     otherwise the comparison is case insensitive.
10185 */
10186 
10187 /*!
10188     \overload
10189     \fn int QStringRef::compare(const QString &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10190     \since 4.5
10191 
10192     Compares this string with the \a other string and returns an
10193     integer less than, equal to, or greater than zero if this string
10194     is less than, equal to, or greater than the \a other string.
10195 
10196     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10197     otherwise the comparison is case insensitive.
10198 
10199     Equivalent to \c {compare(*this, other, cs)}.
10200 */
10201 
10202 /*!
10203     \overload
10204     \fn int QStringRef::compare(const QStringRef &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10205     \since 4.5
10206 
10207     Compares this string with the \a other string and returns an
10208     integer less than, equal to, or greater than zero if this string
10209     is less than, equal to, or greater than the \a other string.
10210 
10211     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10212     otherwise the comparison is case insensitive.
10213 
10214     Equivalent to \c {compare(*this, other, cs)}.
10215 */
10216 
10217 /*!
10218     \overload
10219     \fn int QStringRef::compare(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10220     \since 5.14
10221 
10222     Compares this string with \a ch and returns an
10223     integer less than, equal to, or greater than zero if this string
10224     is less than, equal to, or greater than \a ch, interpreted as a string of length one.
10225 
10226     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10227     otherwise the comparison is case insensitive.
10228 */
10229 
10230 /*!
10231     \overload
10232     \fn int QStringRef::compare(QLatin1String other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10233     \since 4.5
10234 
10235     Compares this string with the \a other string and returns an
10236     integer less than, equal to, or greater than zero if this string
10237     is less than, equal to, or greater than the \a other string.
10238 
10239     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10240     otherwise the comparison is case insensitive.
10241 
10242     Equivalent to \c {compare(*this, other, cs)}.
10243 */
10244 
10245 /*!
10246     \overload
10247     \fn int QStringRef::compare(const QByteArray &other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10248     \since 5.8
10249 
10250     Compares this string with \a other and returns an
10251     integer less than, equal to, or greater than zero if this string
10252     is less than, equal to, or greater than the \a other byte array,
10253     interpreted as a UTF-8 sequence.
10254 
10255     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
10256     otherwise the comparison is case insensitive.
10257 
10258     Equivalent to \c {compare(*this, other, cs)}.
10259 */
10260 
10261 /*!
10262     \fn int QStringRef::localeAwareCompare(const QStringRef &s1, const QString & s2)
10263     \since 4.5
10264 
10265     Compares \a s1 with \a s2 and returns an integer less than, equal
10266     to, or greater than zero if \a s1 is less than, equal to, or
10267     greater than \a s2.
10268 
10269     The comparison is performed in a locale- and also
10270     platform-dependent manner. Use this function to present sorted
10271     lists of strings to the user.
10272 
10273     \sa compare(), QLocale, {Comparing Strings}
10274 */
10275 
10276 /*!
10277     \fn int QStringRef::localeAwareCompare(const QStringRef &s1, const QStringRef & s2)
10278     \since 4.5
10279     \overload
10280 
10281     Compares \a s1 with \a s2 and returns an integer less than, equal
10282     to, or greater than zero if \a s1 is less than, equal to, or
10283     greater than \a s2.
10284 
10285     The comparison is performed in a locale- and also
10286     platform-dependent manner. Use this function to present sorted
10287     lists of strings to the user.
10288 
10289     \sa {Comparing Strings}
10290 */
10291 
10292 /*!
10293     \fn int QStringRef::localeAwareCompare(const QString &other) const
10294     \since 4.5
10295     \overload
10296 
10297     Compares this string with the \a other string and returns an
10298     integer less than, equal to, or greater than zero if this string
10299     is less than, equal to, or greater than the \a other string.
10300 
10301     The comparison is performed in a locale- and also
10302     platform-dependent manner. Use this function to present sorted
10303     lists of strings to the user.
10304 
10305     \sa {Comparing Strings}
10306 */
10307 
10308 /*!
10309     \fn int QStringRef::localeAwareCompare(const QStringRef &other) const
10310     \since 4.5
10311     \overload
10312 
10313     Compares this string with the \a other string and returns an
10314     integer less than, equal to, or greater than zero if this string
10315     is less than, equal to, or greater than the \a other string.
10316 
10317     The comparison is performed in a locale- and also
10318     platform-dependent manner. Use this function to present sorted
10319     lists of strings to the user.
10320 
10321     \sa {Comparing Strings}
10322 */
10323 
10324 /*!
10325     \fn QString &QString::append(QStringView str)
10326     \since 6.0
10327 
10328     Appends the given string view \a str to this string and returns the result.
10329 */
10330 
10331 /*!
10332     \fn QStringRef::left(int n) const
10333     \since 5.2
10334 
10335     Returns a substring reference to the \a n leftmost characters
10336     of the string.
10337 
10338     If \a n is greater than or equal to size(), or less than zero,
10339     a reference to the entire string is returned.
10340 
10341     \sa right(), mid(), startsWith(), chopped(), chop(), truncate()
10342 */
10343 QStringRef QStringRef::left(int n) const
10344 {
10345     if (size_t(n) >= size_t(m_size))
10346         return *this;
10347     return QStringRef(m_string, m_position, n);
10348 }
10349 
10350 /*!
10351     \since 4.4
10352 
10353     Returns a substring reference to the \a n leftmost characters
10354     of the string.
10355 
10356     If \a n is greater than or equal to size(), or less than zero,
10357     a reference to the entire string is returned.
10358 
10359     \snippet qstring/main.cpp leftRef
10360 
10361     \sa left(), rightRef(), midRef(), startsWith()
10362 */
10363 QStringRef QString::leftRef(int n)  const
10364 {
10365     return QStringRef(this).left(n);
10366 }
10367 
10368 /*!
10369     \fn QStringRef::right(int n) const
10370     \since 5.2
10371 
10372     Returns a substring reference to the \a n rightmost characters
10373     of the string.
10374 
10375     If \a n is greater than or equal to size(), or less than zero,
10376     a reference to the entire string is returned.
10377 
10378     \sa left(), mid(), endsWith(), chopped(), chop(), truncate()
10379 */
10380 QStringRef QStringRef::right(int n) const
10381 {
10382     if (size_t(n) >= size_t(m_size))
10383         return *this;
10384     return QStringRef(m_string, m_size - n + m_position, n);
10385 }
10386 
10387 /*!
10388     \since 4.4
10389 
10390     Returns a substring reference to the \a n rightmost characters
10391     of the string.
10392 
10393     If \a n is greater than or equal to size(), or less than zero,
10394     a reference to the entire string is returned.
10395 
10396     \snippet qstring/main.cpp rightRef
10397 
10398     \sa right(), leftRef(), midRef(), endsWith()
10399 */
10400 QStringRef QString::rightRef(int n) const
10401 {
10402     return QStringRef(this).right(n);
10403 }
10404 
10405 /*!
10406     \fn QStringRef QStringRef::mid(int position, int n = -1) const
10407     \since 5.2
10408 
10409     Returns a substring reference to \a n characters of this string,
10410     starting at the specified \a position.
10411 
10412     If the \a position exceeds the length of the string, a null
10413     reference is returned.
10414 
10415     If there are less than \a n characters available in the string,
10416     starting at the given \a position, or if \a n is -1 (default), the
10417     function returns all characters from the specified \a position
10418     onwards.
10419 
10420     \sa left(), right(), chopped(), chop(), truncate()
10421 */
10422 QStringRef QStringRef::mid(int pos, int n) const
10423 {
10424     qsizetype p = pos;
10425     qsizetype l = n;
10426     using namespace QtPrivate;
10427     switch (QContainerImplHelper::mid(m_size, &p, &l)) {
10428     case QContainerImplHelper::Null:
10429         return QStringRef();
10430     case QContainerImplHelper::Empty:
10431         return QStringRef(m_string, 0, 0);
10432     case QContainerImplHelper::Full:
10433         return *this;
10434     case QContainerImplHelper::Subset:
10435         return QStringRef(m_string, p + m_position, l);
10436     }
10437     Q_UNREACHABLE();
10438     return QStringRef();
10439 }
10440 
10441 /*!
10442     \fn QStringRef QStringRef::chopped(int len) const
10443     \since 5.10
10444 
10445     Returns a substring reference to the size() - \a len leftmost characters
10446     of this string.
10447 
10448     \note The behavior is undefined if \a len is negative or greater than size().
10449 
10450     \sa endsWith(), left(), right(), mid(), chop(), truncate()
10451 */
10452 
10453 /*!
10454     \since 4.4
10455 
10456     Returns a substring reference to \a n characters of this string,
10457     starting at the specified \a position.
10458 
10459     If the \a position exceeds the length of the string, a null
10460     reference is returned.
10461 
10462     If there are less than \a n characters available in the string,
10463     starting at the given \a position, or if \a n is -1 (default), the
10464     function returns all characters from the specified \a position
10465     onwards.
10466 
10467     Example:
10468 
10469     \snippet qstring/main.cpp midRef
10470 
10471     \sa mid(), leftRef(), rightRef()
10472 */
10473 QStringRef QString::midRef(int position, int n) const
10474 {
10475     return QStringRef(this).mid(position, n);
10476 }
10477 
10478 /*!
10479     \fn void QStringRef::truncate(int position)
10480     \since 5.6
10481 
10482     Truncates the string at the given \a position index.
10483 
10484     If the specified \a position index is beyond the end of the
10485     string, nothing happens.
10486 
10487     If \a position is negative, it is equivalent to passing zero.
10488 
10489     \sa QString::truncate()
10490 */
10491 
10492 /*!
10493     \fn void QStringRef::chop(int n)
10494     \since 5.8
10495 
10496     Removes \a n characters from the end of the string.
10497 
10498     If \a n is greater than or equal to size(), the result is an
10499     empty string; if \a n is negative, it is equivalent to passing zero.
10500 
10501     \sa QString::chop(), truncate()
10502 */
10503 
10504 #if QT_STRINGVIEW_LEVEL < 2
10505 /*!
10506   \since 4.8
10507 
10508   Returns the index position of the first occurrence of the string \a
10509   str in this string reference, searching forward from index position
10510   \a from. Returns -1 if \a str is not found.
10511 
10512   If \a cs is Qt::CaseSensitive (default), the search is case
10513   sensitive; otherwise the search is case insensitive.
10514 
10515   If \a from is -1, the search starts at the last character; if it is
10516   -2, at the next to last character and so on.
10517 
10518   \sa QString::indexOf(), lastIndexOf(), contains(), count()
10519 */
10520 int QStringRef::indexOf(const QString &str, int from, Qt::CaseSensitivity cs) const
10521 {
10522     // ### Qt6: qsizetype
10523     return int(QtPrivate::findString(QStringView(unicode(), length()), from, QStringView(str.unicode(), str.length()), cs));
10524 }
10525 #endif // QT_STRINGVIEW_LEVEL < 2
10526 
10527 /*!
10528     \fn int QStringRef::indexOf(QStringView str, int from, Qt::CaseSensitivity cs) const
10529     \since 5.14
10530     \overload indexOf()
10531 
10532     Returns the index position of the first occurrence of the string view \a str
10533     in this string reference, searching forward from index position \a from.
10534     Returns -1 if \a str is not found.
10535 
10536     If \a cs is Qt::CaseSensitive (default), the search is case
10537     sensitive; otherwise the search is case insensitive.
10538 
10539     If \a from is -1, the search starts at the last character; if it is
10540     -2, at the next to last character and so on.
10541 
10542     \sa QString::indexOf(), QStringView::indexOf(), lastIndexOf(), contains(), count()
10543 */
10544 
10545 /*!
10546     \since 4.8
10547     \overload indexOf()
10548 
10549     Returns the index position of the first occurrence of the
10550     character \a ch in the string reference, searching forward from
10551     index position \a from. Returns -1 if \a ch could not be found.
10552 
10553     \sa QString::indexOf(), lastIndexOf(), contains(), count()
10554 */
10555 int QStringRef::indexOf(QChar ch, int from, Qt::CaseSensitivity cs) const
10556 {
10557     // ### Qt6: qsizetype
10558     return int(qFindChar(QStringView(unicode(), length()), ch, from, cs));
10559 }
10560 
10561 /*!
10562   \since 4.8
10563 
10564   Returns the index position of the first occurrence of the string \a
10565   str in this string reference, searching forward from index position
10566   \a from. Returns -1 if \a str is not found.
10567 
10568   If \a cs is Qt::CaseSensitive (default), the search is case
10569   sensitive; otherwise the search is case insensitive.
10570 
10571   If \a from is -1, the search starts at the last character; if it is
10572   -2, at the next to last character and so on.
10573 
10574   \sa QString::indexOf(), lastIndexOf(), contains(), count()
10575 */
10576 int QStringRef::indexOf(QLatin1String str, int from, Qt::CaseSensitivity cs) const
10577 {
10578     // ### Qt6: qsizetype
10579     return int(QtPrivate::findString(QStringView(unicode(), size()), from, str, cs));
10580 }
10581 
10582 #if QT_STRINGVIEW_LEVEL < 2
10583 /*!
10584     \since 4.8
10585 
10586     \overload indexOf()
10587 
10588     Returns the index position of the first occurrence of the string
10589     reference \a str in this string reference, searching forward from
10590     index position \a from. Returns -1 if \a str is not found.
10591 
10592     If \a cs is Qt::CaseSensitive (default), the search is case
10593     sensitive; otherwise the search is case insensitive.
10594 
10595     \sa QString::indexOf(), lastIndexOf(), contains(), count()
10596 */
10597 int QStringRef::indexOf(const QStringRef &str, int from, Qt::CaseSensitivity cs) const
10598 {
10599     // ### Qt6: qsizetype
10600     return int(QtPrivate::findString(QStringView(unicode(), size()), from, QStringView(str.unicode(), str.size()), cs));
10601 }
10602 #endif // QT_STRINGVIEW_LEVEL < 2
10603 
10604 /*!
10605   \since 4.8
10606 
10607   Returns the index position of the last occurrence of the string \a
10608   str in this string reference, searching backward from index position
10609   \a from. If \a from is -1 (default), the search starts at the last
10610   character; if \a from is -2, at the next to last character and so
10611   on. Returns -1 if \a str is not found.
10612 
10613   If \a cs is Qt::CaseSensitive (default), the search is case
10614   sensitive; otherwise the search is case insensitive.
10615 
10616   \sa QString::lastIndexOf(), indexOf(), contains(), count()
10617 */
10618 int QStringRef::lastIndexOf(const QString &str, int from, Qt::CaseSensitivity cs) const
10619 {
10620     // ### Qt6: qsizetype
10621     return int(QtPrivate::lastIndexOf(*this, from, str, cs));
10622 }
10623 
10624 /*!
10625   \since 4.8
10626   \overload lastIndexOf()
10627 
10628   Returns the index position of the last occurrence of the character
10629   \a ch, searching backward from position \a from.
10630 
10631   \sa QString::lastIndexOf(), indexOf(), contains(), count()
10632 */
10633 int QStringRef::lastIndexOf(QChar ch, int from, Qt::CaseSensitivity cs) const
10634 {
10635     // ### Qt6: qsizetype
10636     return int(qLastIndexOf(*this, ch, from, cs));
10637 }
10638 
10639 /*!
10640   \since 4.8
10641   \overload lastIndexOf()
10642 
10643   Returns the index position of the last occurrence of the string \a
10644   str in this string reference, searching backward from index position
10645   \a from. If \a from is -1 (default), the search starts at the last
10646   character; if \a from is -2, at the next to last character and so
10647   on. Returns -1 if \a str is not found.
10648 
10649   If \a cs is Qt::CaseSensitive (default), the search is case
10650   sensitive; otherwise the search is case insensitive.
10651 
10652   \sa QString::lastIndexOf(), indexOf(), contains(), count()
10653 */
10654 int QStringRef::lastIndexOf(QLatin1String str, int from, Qt::CaseSensitivity cs) const
10655 {
10656     // ### Qt6: qsizetype
10657     return int(QtPrivate::lastIndexOf(*this, from, str, cs));
10658 }
10659 
10660 /*!
10661   \since 4.8
10662   \overload lastIndexOf()
10663 
10664   Returns the index position of the last occurrence of the string
10665   reference \a str in this string reference, searching backward from
10666   index position \a from. If \a from is -1 (default), the search
10667   starts at the last character; if \a from is -2, at the next to last
10668   character and so on. Returns -1 if \a str is not found.
10669 
10670   If \a cs is Qt::CaseSensitive (default), the search is case
10671   sensitive; otherwise the search is case insensitive.
10672 
10673   \sa QString::lastIndexOf(), indexOf(), contains(), count()
10674 */
10675 int QStringRef::lastIndexOf(const QStringRef &str, int from, Qt::CaseSensitivity cs) const
10676 {
10677     // ### Qt6: qsizetype
10678     return int(QtPrivate::lastIndexOf(*this, from, str, cs));
10679 }
10680 
10681 /*!
10682   \fn int QStringRef::lastIndexOf(QStringView str, int from, Qt::CaseSensitivity cs) const
10683   \since 5.14
10684   \overload lastIndexOf()
10685 
10686   Returns the index position of the last occurrence of the string view \a
10687   str in this string, searching backward from index position \a
10688   from. If \a from is -1 (default), the search starts at the last
10689   character; if \a from is -2, at the next to last character and so
10690   on. Returns -1 if \a str is not found.
10691 
10692   If \a cs is Qt::CaseSensitive (default), the search is case
10693   sensitive; otherwise the search is case insensitive.
10694 
10695   \sa indexOf(), contains(), count()
10696 */
10697 
10698 /*!
10699     \since 4.8
10700     Returns the number of (potentially overlapping) occurrences of
10701     the string \a str in this string reference.
10702 
10703     If \a cs is Qt::CaseSensitive (default), the search is
10704     case sensitive; otherwise the search is case insensitive.
10705 
10706     \sa QString::count(), contains(), indexOf()
10707 */
10708 int QStringRef::count(const QString &str, Qt::CaseSensitivity cs) const
10709 {
10710     // ### Qt6: qsizetype
10711     return int(QtPrivate::count(QStringView(unicode(), size()), QStringView(str.unicode(), str.size()), cs));
10712 }
10713 
10714 /*!
10715     \since 4.8
10716     \overload count()
10717 
10718     Returns the number of occurrences of the character \a ch in the
10719     string reference.
10720 
10721     If \a cs is Qt::CaseSensitive (default), the search is
10722     case sensitive; otherwise the search is case insensitive.
10723 
10724     \sa QString::count(), contains(), indexOf()
10725 */
10726 int QStringRef::count(QChar ch, Qt::CaseSensitivity cs) const
10727 {
10728     // ### Qt6: qsizetype
10729     return int(QtPrivate::count(QStringView(unicode(), size()), ch, cs));
10730 }
10731 
10732 /*!
10733     \since 4.8
10734     \overload count()
10735 
10736     Returns the number of (potentially overlapping) occurrences of the
10737     string reference \a str in this string reference.
10738 
10739     If \a cs is Qt::CaseSensitive (default), the search is
10740     case sensitive; otherwise the search is case insensitive.
10741 
10742     \sa QString::count(), contains(), indexOf()
10743 */
10744 int QStringRef::count(const QStringRef &str, Qt::CaseSensitivity cs) const
10745 {
10746     // ### Qt6: qsizetype
10747     return int(QtPrivate::count(QStringView(unicode(), size()), QStringView(str.unicode(), str.size()), cs));
10748 }
10749 
10750 /*!
10751     \since 5.9
10752 
10753     Returns \c true if the string is read right to left.
10754 
10755     \sa QString::isRightToLeft()
10756 */
10757 bool QStringRef::isRightToLeft() const
10758 {
10759     return QtPrivate::isRightToLeft(QStringView(unicode(), size()));
10760 }
10761 
10762 /*!
10763     \since 5.11
10764     \internal
10765     \relates QStringView
10766 
10767     Returns \c true if the string is read right to left.
10768 
10769     \sa QString::isRightToLeft()
10770 */
10771 bool QtPrivate::isRightToLeft(QStringView string) noexcept
10772 {
10773     const char16_t *p = string.utf16();
10774     const char16_t * const end = p + string.size();
10775     int isolateLevel = 0;
10776     while (p < end) {
10777         uint ucs4 = *p;
10778         if (QChar::isHighSurrogate(ucs4) && p < end - 1) {
10779             char16_t low = p[1];
10780             if (QChar::isLowSurrogate(low)) {
10781                 ucs4 = QChar::surrogateToUcs4(ucs4, low);
10782                 ++p;
10783             }
10784         }
10785         switch (QChar::direction(ucs4))
10786         {
10787         case QChar::DirRLI:
10788         case QChar::DirLRI:
10789         case QChar::DirFSI:
10790             ++isolateLevel;
10791             break;
10792         case QChar::DirPDI:
10793             if (isolateLevel)
10794                 --isolateLevel;
10795             break;
10796         case QChar::DirL:
10797             if (isolateLevel)
10798                 break;
10799             return false;
10800         case QChar::DirR:
10801         case QChar::DirAL:
10802             if (isolateLevel)
10803                 break;
10804             return true;
10805         default:
10806             break;
10807         }
10808         ++p;
10809     }
10810     return false;
10811 }
10812 
10813 /*!
10814     \since 4.8
10815 
10816     Returns \c true if the string reference starts with \a str; otherwise
10817     returns \c false.
10818 
10819     If \a cs is Qt::CaseSensitive (default), the search is
10820     case sensitive; otherwise the search is case insensitive.
10821 
10822     \sa QString::startsWith(), endsWith()
10823 */
10824 bool QStringRef::startsWith(const QString &str, Qt::CaseSensitivity cs) const
10825 {
10826     return qt_starts_with(*this, str, cs);
10827 }
10828 
10829 /*!
10830     \since 4.8
10831     \overload startsWith()
10832     \sa QString::startsWith(), endsWith()
10833 */
10834 bool QStringRef::startsWith(QLatin1String str, Qt::CaseSensitivity cs) const
10835 {
10836     return qt_starts_with(*this, str, cs);
10837 }
10838 
10839 /*!
10840     \fn bool QStringRef::startsWith(QStringView str, Qt::CaseSensitivity cs) const
10841     \since 5.10
10842     \overload startsWith()
10843     \sa QString::startsWith(), endsWith()
10844 */
10845 
10846 /*!
10847     \since 4.8
10848     \overload startsWith()
10849     \sa QString::startsWith(), endsWith()
10850 */
10851 bool QStringRef::startsWith(const QStringRef &str, Qt::CaseSensitivity cs) const
10852 {
10853     return qt_starts_with(*this, str, cs);
10854 }
10855 
10856 /*!
10857     \since 4.8
10858     \overload startsWith()
10859 
10860     Returns \c true if the string reference starts with \a ch; otherwise
10861     returns \c false.
10862 
10863     If \a cs is Qt::CaseSensitive (default), the search is case
10864     sensitive; otherwise the search is case insensitive.
10865 
10866     \sa QString::startsWith(), endsWith()
10867 */
10868 bool QStringRef::startsWith(QChar ch, Qt::CaseSensitivity cs) const
10869 {
10870     return qt_starts_with(*this, ch, cs);
10871 }
10872 
10873 /*!
10874     \since 4.8
10875     Returns \c true if the string reference ends with \a str; otherwise
10876     returns \c false.
10877 
10878     If \a cs is Qt::CaseSensitive (default), the search is case
10879     sensitive; otherwise the search is case insensitive.
10880 
10881     \sa QString::endsWith(), startsWith()
10882 */
10883 bool QStringRef::endsWith(const QString &str, Qt::CaseSensitivity cs) const
10884 {
10885     return qt_ends_with(*this, str, cs);
10886 }
10887 
10888 /*!
10889     \since 4.8
10890     \overload endsWith()
10891 
10892     Returns \c true if the string reference ends with \a ch; otherwise
10893     returns \c false.
10894 
10895     If \a cs is Qt::CaseSensitive (default), the search is case
10896     sensitive; otherwise the search is case insensitive.
10897 
10898     \sa QString::endsWith(), endsWith()
10899 */
10900 bool QStringRef::endsWith(QChar ch, Qt::CaseSensitivity cs) const
10901 {
10902     return qt_ends_with(*this, ch, cs);
10903 }
10904 
10905 /*!
10906     \since 4.8
10907     \overload endsWith()
10908     \sa QString::endsWith(), endsWith()
10909 */
10910 bool QStringRef::endsWith(QLatin1String str, Qt::CaseSensitivity cs) const
10911 {
10912     return qt_ends_with(*this, str, cs);
10913 }
10914 
10915 /*!
10916     \fn bool QStringRef::endsWith(QStringView str, Qt::CaseSensitivity cs) const
10917     \since 5.10
10918     \overload endsWith()
10919     \sa QString::endsWith(), startsWith()
10920 */
10921 
10922 /*!
10923     \since 4.8
10924     \overload endsWith()
10925     \sa QString::endsWith(), endsWith()
10926 */
10927 bool QStringRef::endsWith(const QStringRef &str, Qt::CaseSensitivity cs) const
10928 {
10929     return qt_ends_with(*this, str, cs);
10930 }
10931 
10932 #if QT_STRINGVIEW_LEVEL < 2
10933 /*! \fn bool QStringRef::contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10934 
10935     \since 4.8
10936     Returns \c true if this string reference contains an occurrence of
10937     the string \a str; otherwise returns \c false.
10938 
10939     If \a cs is Qt::CaseSensitive (default), the search is
10940     case sensitive; otherwise the search is case insensitive.
10941 
10942     \sa indexOf(), count()
10943 */
10944 #endif // QT_STRINGVIEW_LEVEL < 2
10945 
10946 /*! \fn bool QStringRef::contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10947 
10948     \overload contains()
10949     \since 4.8
10950 
10951     Returns \c true if this string contains an occurrence of the
10952     character \a ch; otherwise returns \c false.
10953 
10954     If \a cs is Qt::CaseSensitive (default), the search is
10955     case sensitive; otherwise the search is case insensitive.
10956 
10957 */
10958 
10959 #if QT_STRINGVIEW_LEVEL < 2
10960 /*! \fn bool QStringRef::contains(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10961     \overload contains()
10962     \since 4.8
10963 
10964     Returns \c true if this string reference contains an occurrence of
10965     the string reference \a str; otherwise returns \c false.
10966 
10967     If \a cs is Qt::CaseSensitive (default), the search is
10968     case sensitive; otherwise the search is case insensitive.
10969 
10970     \sa indexOf(), count()
10971 */
10972 #endif // QT_STRINGVIEW_LEVEL < 2
10973 
10974 /*! \fn bool QStringRef::contains(QLatin1String str, Qt::CaseSensitivity cs) const
10975     \since 4.8
10976     \overload contains()
10977 
10978     Returns \c true if this string reference contains an occurrence of
10979     the string \a str; otherwise returns \c false.
10980 
10981     If \a cs is Qt::CaseSensitive (default), the search is
10982     case sensitive; otherwise the search is case insensitive.
10983 
10984     \sa indexOf(), count()
10985 */
10986 
10987 /*! \fn bool QStringRef::contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
10988     \since 5.14
10989     \overload contains()
10990 
10991     Returns \c true if this string reference contains an occurrence of
10992     the string view \a str; otherwise returns \c false.
10993 
10994     If \a cs is Qt::CaseSensitive (default), the search is
10995     case sensitive; otherwise the search is case insensitive.
10996 
10997     \sa indexOf(), count()
10998 */
10999 
11000 qsizetype QtPrivate::count(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
11001 {
11002     qsizetype num = 0;
11003     qsizetype i = -1;
11004     if (haystack.size() > 500 && needle.size() > 5) {
11005         QStringMatcher matcher(needle, cs);
11006         while ((i = matcher.indexIn(haystack, i + 1)) != -1)
11007             ++num;
11008     } else {
11009         while ((i = QtPrivate::findString(haystack, i + 1, needle, cs)) != -1)
11010             ++num;
11011     }
11012     return num;
11013 }
11014 
11015 qsizetype QtPrivate::count(QStringView haystack, QChar ch, Qt::CaseSensitivity cs) noexcept
11016 {
11017     qsizetype num = 0;
11018     if (cs == Qt::CaseSensitive) {
11019         for (QChar c : haystack) {
11020             if (c == ch)
11021                 ++num;
11022         }
11023     } else {
11024         ch = foldCase(ch);
11025         for (QChar c : haystack) {
11026             if (foldCase(c) == ch)
11027                 ++num;
11028         }
11029     }
11030     return num;
11031 }
11032 
11033 template <typename Haystack, typename Needle>
11034 bool qt_starts_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) noexcept
11035 {
11036     if (haystack.isNull())
11037         return needle.isNull(); // historical behavior, consider changing in ### Qt 6.
11038     const auto haystackLen = haystack.size();
11039     const auto needleLen = needle.size();
11040     if (haystackLen == 0)
11041         return needleLen == 0;
11042     if (needleLen > haystackLen)
11043         return false;
11044 
11045     return qt_compare_strings(haystack.left(needleLen), needle, cs) == 0;
11046 }
11047 
11048 static inline bool qt_starts_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
11049 {
11050     return qt_starts_with_impl(haystack, needle, cs);
11051 }
11052 
11053 static inline bool qt_starts_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
11054 {
11055     return qt_starts_with_impl(haystack, needle, cs);
11056 }
11057 
11058 static inline bool qt_starts_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
11059 {
11060     return haystack.size()
11061            && (cs == Qt::CaseSensitive ? haystack.front() == needle
11062                                        : foldCase(haystack.front()) == foldCase(needle));
11063 }
11064 
11065 /*!
11066     \fn bool QtPrivate::startsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
11067     \since 5.10
11068     \fn bool QtPrivate::startsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
11069     \since 5.10
11070     \fn bool QtPrivate::startsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs)
11071     \since 5.10
11072     \fn bool QtPrivate::startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs)
11073     \since 5.10
11074     \internal
11075     \relates QStringView
11076 
11077     Returns \c true if \a haystack starts with \a needle,
11078     otherwise returns \c false.
11079 
11080     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
11081     otherwise the search is case-insensitive.
11082 
11083     \sa QtPrivate::endsWith(), QString::endsWith(), QStringView::endsWith(), QLatin1String::endsWith()
11084 */
11085 
11086 bool QtPrivate::startsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
11087 {
11088     return qt_starts_with_impl(haystack, needle, cs);
11089 }
11090 
11091 bool QtPrivate::startsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11092 {
11093     return qt_starts_with_impl(haystack, needle, cs);
11094 }
11095 
11096 bool QtPrivate::startsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
11097 {
11098     return qt_starts_with_impl(haystack, needle, cs);
11099 }
11100 
11101 bool QtPrivate::startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11102 {
11103     return qt_starts_with_impl(haystack, needle, cs);
11104 }
11105 
11106 template <typename Haystack, typename Needle>
11107 bool qt_ends_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) noexcept
11108 {
11109     if (haystack.isNull())
11110         return needle.isNull(); // historical behavior, consider changing in ### Qt 6.
11111     const auto haystackLen = haystack.size();
11112     const auto needleLen = needle.size();
11113     if (haystackLen == 0)
11114         return needleLen == 0;
11115     if (haystackLen < needleLen)
11116         return false;
11117 
11118     return qt_compare_strings(haystack.right(needleLen), needle, cs) == 0;
11119 }
11120 
11121 static inline bool qt_ends_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
11122 {
11123     return qt_ends_with_impl(haystack, needle, cs);
11124 }
11125 
11126 static inline bool qt_ends_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
11127 {
11128     return qt_ends_with_impl(haystack, needle, cs);
11129 }
11130 
11131 static inline bool qt_ends_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
11132 {
11133     return haystack.size()
11134            && (cs == Qt::CaseSensitive ? haystack.back() == needle
11135                                        : foldCase(haystack.back()) == foldCase(needle));
11136 }
11137 
11138 /*!
11139     \fn bool QtPrivate::endsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
11140     \since 5.10
11141     \fn bool QtPrivate::endsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
11142     \since 5.10
11143     \fn bool QtPrivate::endsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs)
11144     \since 5.10
11145     \fn bool QtPrivate::endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs)
11146     \since 5.10
11147     \internal
11148     \relates QStringView
11149 
11150     Returns \c true if \a haystack ends with \a needle,
11151     otherwise returns \c false.
11152 
11153     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
11154     otherwise the search is case-insensitive.
11155 
11156     \sa QtPrivate::startsWith(), QString::endsWith(), QStringView::endsWith(), QLatin1String::endsWith()
11157 */
11158 
11159 bool QtPrivate::endsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
11160 {
11161     return qt_ends_with_impl(haystack, needle, cs);
11162 }
11163 
11164 bool QtPrivate::endsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11165 {
11166     return qt_ends_with_impl(haystack, needle, cs);
11167 }
11168 
11169 bool QtPrivate::endsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
11170 {
11171     return qt_ends_with_impl(haystack, needle, cs);
11172 }
11173 
11174 bool QtPrivate::endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11175 {
11176     return qt_ends_with_impl(haystack, needle, cs);
11177 }
11178 
11179 namespace {
11180 template <typename Pointer>
11181 char32_t foldCaseHelper(Pointer ch, Pointer start) = delete;
11182 
11183 template <>
11184 char32_t foldCaseHelper<const QChar*>(const QChar* ch, const QChar* start)
11185 {
11186     return foldCase(reinterpret_cast<const char16_t*>(ch),
11187                     reinterpret_cast<const char16_t*>(start));
11188 }
11189 
11190 template <>
11191 char32_t foldCaseHelper<const char*>(const char* ch, const char*)
11192 {
11193     return foldCase(char16_t(uchar(*ch)));
11194 }
11195 
11196 template <typename T>
11197 char16_t valueTypeToUtf16(T t) = delete;
11198 
11199 template <>
11200 char16_t valueTypeToUtf16<QChar>(QChar t)
11201 {
11202     return t.unicode();
11203 }
11204 
11205 template <>
11206 char16_t valueTypeToUtf16<char>(char t)
11207 {
11208     return char16_t{uchar(t)};
11209 }
11210 }
11211 
11212 /*!
11213     \internal
11214 
11215     Returns the index position of the first occurrence of the
11216     character \a ch in the string given by \a str and \a len,
11217     searching forward from index
11218     position \a from. Returns -1 if \a ch could not be found.
11219 */
11220 
11221 static inline qsizetype qFindChar(QStringView str, QChar ch, qsizetype from, Qt::CaseSensitivity cs) noexcept
11222 {
11223     if (from < 0)
11224         from = qMax(from + str.size(), qsizetype(0));
11225     if (from < str.size()) {
11226         const char16_t *s = str.utf16();
11227         char16_t c = ch.unicode();
11228         const char16_t *n = s + from;
11229         const char16_t *e = s + str.size();
11230         if (cs == Qt::CaseSensitive) {
11231             n = QtPrivate::qustrchr(QStringView(n, e), c);
11232             if (n != e)
11233                 return n - s;
11234         } else {
11235             c = foldCase(c);
11236             --n;
11237             while (++n != e)
11238                 if (foldCase(*n) == c)
11239                     return n - s;
11240         }
11241     }
11242     return -1;
11243 }
11244 
11245 qsizetype QtPrivate::findString(QStringView haystack0, qsizetype from, QStringView needle0, Qt::CaseSensitivity cs) noexcept
11246 {
11247     const qsizetype l = haystack0.size();
11248     const qsizetype sl = needle0.size();
11249     if (from < 0)
11250         from += l;
11251     if (std::size_t(sl + from) > std::size_t(l))
11252         return -1;
11253     if (!sl)
11254         return from;
11255     if (!l)
11256         return -1;
11257 
11258     if (sl == 1)
11259         return qFindChar(haystack0, needle0[0], from, cs);
11260 
11261     /*
11262         We use the Boyer-Moore algorithm in cases where the overhead
11263         for the skip table should pay off, otherwise we use a simple
11264         hash function.
11265     */
11266     if (l > 500 && sl > 5)
11267         return qFindStringBoyerMoore(haystack0, from, needle0, cs);
11268 
11269     auto sv = [sl](const char16_t *v) { return QStringView(v, sl); };
11270     /*
11271         We use some hashing for efficiency's sake. Instead of
11272         comparing strings, we compare the hash value of str with that
11273         of a part of this QString. Only if that matches, we call
11274         qt_string_compare().
11275     */
11276     const char16_t *needle = needle0.utf16();
11277     const char16_t *haystack = haystack0.utf16() + from;
11278     const char16_t *end = haystack0.utf16() + (l - sl);
11279     const std::size_t sl_minus_1 = sl - 1;
11280     std::size_t hashNeedle = 0, hashHaystack = 0;
11281     qsizetype idx;
11282 
11283     if (cs == Qt::CaseSensitive) {
11284         for (idx = 0; idx < sl; ++idx) {
11285             hashNeedle = ((hashNeedle<<1) + needle[idx]);
11286             hashHaystack = ((hashHaystack<<1) + haystack[idx]);
11287         }
11288         hashHaystack -= haystack[sl_minus_1];
11289 
11290         while (haystack <= end) {
11291             hashHaystack += haystack[sl_minus_1];
11292             if (hashHaystack == hashNeedle
11293                  && qt_compare_strings(needle0, sv(haystack), Qt::CaseSensitive) == 0)
11294                 return haystack - haystack0.utf16();
11295 
11296             REHASH(*haystack);
11297             ++haystack;
11298         }
11299     } else {
11300         const char16_t *haystack_start = haystack0.utf16();
11301         for (idx = 0; idx < sl; ++idx) {
11302             hashNeedle = (hashNeedle<<1) + foldCase(needle + idx, needle);
11303             hashHaystack = (hashHaystack<<1) + foldCase(haystack + idx, haystack_start);
11304         }
11305         hashHaystack -= foldCase(haystack + sl_minus_1, haystack_start);
11306 
11307         while (haystack <= end) {
11308             hashHaystack += foldCase(haystack + sl_minus_1, haystack_start);
11309             if (hashHaystack == hashNeedle
11310                  && qt_compare_strings(needle0, sv(haystack), Qt::CaseInsensitive) == 0)
11311                 return haystack - haystack0.utf16();
11312 
11313             REHASH(foldCase(haystack, haystack_start));
11314             ++haystack;
11315         }
11316     }
11317     return -1;
11318 }
11319 
11320 template <typename Haystack>
11321 static inline qsizetype qLastIndexOf(Haystack haystack, QChar needle,
11322                                      qsizetype from, Qt::CaseSensitivity cs) noexcept
11323 {
11324     if (from < 0)
11325         from += haystack.size();
11326     if (std::size_t(from) >= std::size_t(haystack.size()))
11327         return -1;
11328     if (from >= 0) {
11329         char16_t c = needle.unicode();
11330         const auto b = haystack.data();
11331         auto n = b + from;
11332         if (cs == Qt::CaseSensitive) {
11333             for (; n >= b; --n)
11334                 if (valueTypeToUtf16(*n) == c)
11335                     return n - b;
11336         } else {
11337             c = foldCase(c);
11338             for (; n >= b; --n)
11339                 if (foldCase(valueTypeToUtf16(*n)) == c)
11340                     return n - b;
11341         }
11342     }
11343     return -1;
11344 }
11345 
11346 template<typename Haystack, typename Needle>
11347 static qsizetype qLastIndexOf(Haystack haystack0, qsizetype from,
11348                               Needle needle0, Qt::CaseSensitivity cs) noexcept
11349 {
11350     const qsizetype sl = needle0.size();
11351     if (sl == 1)
11352         return qLastIndexOf(haystack0, needle0.front(), from, cs);
11353 
11354     const qsizetype l = haystack0.size();
11355     if (from < 0)
11356         from += l;
11357     if (from == l && sl == 0)
11358         return from;
11359     const qsizetype delta = l - sl;
11360     if (std::size_t(from) >= std::size_t(l) || delta < 0)
11361         return -1;
11362     if (from > delta)
11363         from = delta;
11364 
11365     auto sv = [sl](const typename Haystack::value_type *v) { return Haystack(v, sl); };
11366 
11367     auto haystack = haystack0.data();
11368     const auto needle = needle0.data();
11369     const auto *end = haystack;
11370     haystack += from;
11371     const std::size_t sl_minus_1 = sl - 1;
11372     const auto *n = needle + sl_minus_1;
11373     const auto *h = haystack + sl_minus_1;
11374     std::size_t hashNeedle = 0, hashHaystack = 0;
11375     qsizetype idx;
11376 
11377     if (cs == Qt::CaseSensitive) {
11378         for (idx = 0; idx < sl; ++idx) {
11379             hashNeedle = (hashNeedle << 1) + valueTypeToUtf16(*(n - idx));
11380             hashHaystack = (hashHaystack << 1) + valueTypeToUtf16(*(h - idx));
11381         }
11382         hashHaystack -= valueTypeToUtf16(*haystack);
11383 
11384         while (haystack >= end) {
11385             hashHaystack += valueTypeToUtf16(*haystack);
11386             if (hashHaystack == hashNeedle
11387                  && qt_compare_strings(needle0, sv(haystack), Qt::CaseSensitive) == 0)
11388                 return haystack - end;
11389             --haystack;
11390             REHASH(valueTypeToUtf16(haystack[sl]));
11391         }
11392     } else {
11393         for (idx = 0; idx < sl; ++idx) {
11394             hashNeedle = (hashNeedle << 1) + foldCaseHelper(n - idx, needle);
11395             hashHaystack = (hashHaystack << 1) + foldCaseHelper(h - idx, end);
11396         }
11397         hashHaystack -= foldCaseHelper(haystack, end);
11398 
11399         while (haystack >= end) {
11400             hashHaystack += foldCaseHelper(haystack, end);
11401             if (hashHaystack == hashNeedle
11402                  && qt_compare_strings(sv(haystack), needle0, Qt::CaseInsensitive) == 0)
11403                 return haystack - end;
11404             --haystack;
11405             REHASH(foldCaseHelper(haystack + sl, end));
11406         }
11407     }
11408     return -1;
11409 }
11410 
11411 qsizetype QtPrivate::findString(QStringView haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11412 {
11413     if (haystack.size() < needle.size())
11414         return -1;
11415 
11416     QVarLengthArray<char16_t> s(needle.size());
11417     qt_from_latin1(s.data(), needle.latin1(), needle.size());
11418     return QtPrivate::findString(haystack, from, QStringView(reinterpret_cast<const QChar*>(s.constData()), s.size()), cs);
11419 }
11420 
11421 qsizetype QtPrivate::findString(QLatin1String haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
11422 {
11423     if (haystack.size() < needle.size())
11424         return -1;
11425 
11426     QVarLengthArray<char16_t> s(haystack.size());
11427     qt_from_latin1(s.data(), haystack.latin1(), haystack.size());
11428     return QtPrivate::findString(QStringView(reinterpret_cast<const QChar*>(s.constData()), s.size()), from, needle, cs);
11429 }
11430 
11431 qsizetype QtPrivate::findString(QLatin1String haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11432 {
11433     if (haystack.size() < needle.size())
11434         return -1;
11435 
11436     QVarLengthArray<char16_t> h(haystack.size());
11437     qt_from_latin1(h.data(), haystack.latin1(), haystack.size());
11438     QVarLengthArray<char16_t> n(needle.size());
11439     qt_from_latin1(n.data(), needle.latin1(), needle.size());
11440     return QtPrivate::findString(QStringView(reinterpret_cast<const QChar*>(h.constData()), h.size()), from,
11441                                  QStringView(reinterpret_cast<const QChar*>(n.constData()), n.size()), cs);
11442 }
11443 
11444 qsizetype QtPrivate::lastIndexOf(QStringView haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
11445 {
11446     return qLastIndexOf(haystack, from, needle, cs);
11447 }
11448 
11449 qsizetype QtPrivate::lastIndexOf(QStringView haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11450 {
11451     return qLastIndexOf(haystack, from, needle, cs);
11452 }
11453 
11454 qsizetype QtPrivate::lastIndexOf(QLatin1String haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
11455 {
11456     return qLastIndexOf(haystack, from, needle, cs);
11457 }
11458 
11459 qsizetype QtPrivate::lastIndexOf(QLatin1String haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
11460 {
11461     return qLastIndexOf(haystack, from, needle, cs);
11462 }
11463 
11464 /*!
11465     \since 4.8
11466 
11467     Returns a Latin-1 representation of the string as a QByteArray.
11468 
11469     The returned byte array is undefined if the string contains non-Latin1
11470     characters. Those characters may be suppressed or replaced with a
11471     question mark.
11472 
11473     \sa toUtf8(), toLocal8Bit(), QStringEncoder
11474 */
11475 QByteArray QStringRef::toLatin1() const
11476 {
11477     return qt_convert_to_latin1(*this);
11478 }
11479 
11480 /*!
11481     \since 4.8
11482 
11483     Returns the local 8-bit representation of the string as a
11484     QByteArray. The returned byte array is undefined if the string
11485     contains characters not supported by the local 8-bit encoding.
11486 
11487     On Unix systems this is equivalen to toUtf8(), on Windows the systems
11488     current code page is being used.
11489 
11490     If this string contains any characters that cannot be encoded in the
11491     locale, the returned byte array is undefined. Those characters may be
11492     suppressed or replaced by another.
11493 
11494     \sa toLatin1(), toUtf8(), QStringEncoder
11495 */
11496 QByteArray QStringRef::toLocal8Bit() const
11497 {
11498     return qt_convert_to_local_8bit(*this);
11499 }
11500 
11501 /*!
11502     \since 4.8
11503 
11504     Returns a UTF-8 representation of the string as a QByteArray.
11505 
11506     UTF-8 is a Unicode codec and can represent all characters in a Unicode
11507     string like QString.
11508 
11509     \sa toLatin1(), toLocal8Bit(), QStringEncoder
11510 */
11511 QByteArray QStringRef::toUtf8() const
11512 {
11513     return qt_convert_to_utf8(*this);
11514 }
11515 
11516 /*!
11517     \since 4.8
11518 
11519     Returns a UCS-4/UTF-32 representation of the string as a QList<uint>.
11520 
11521     UCS-4 is a Unicode codec and therefore it is lossless. All characters from
11522     this string will be encoded in UCS-4. Any invalid sequence of code units in
11523     this string is replaced by the Unicode's replacement character
11524     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
11525 
11526     The returned list is not \\0'-terminated.
11527 
11528     \sa toUtf8(), toLatin1(), toLocal8Bit(), QStringEncoder
11529 */
11530 QList<uint> QStringRef::toUcs4() const
11531 {
11532     return qt_convert_to_ucs4(*this);
11533 }
11534 
11535 /*!
11536     Returns a string that has whitespace removed from the start and
11537     the end.
11538 
11539     Whitespace means any character for which QChar::isSpace() returns
11540     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
11541     '\\f', '\\r', and ' '.
11542 
11543     Unlike QString::simplified(), trimmed() leaves internal whitespace alone.
11544 
11545     \since 5.1
11546 
11547     \sa QString::trimmed()
11548 */
11549 QStringRef QStringRef::trimmed() const
11550 {
11551     const QChar *begin = cbegin();
11552     const QChar *end = cend();
11553     QStringAlgorithms<const QStringRef>::trimmed_helper_positions(begin, end);
11554     if (begin == cbegin() && end == cend())
11555         return *this;
11556     int position = m_position + (begin - cbegin());
11557     return QStringRef(m_string, position, end - begin);
11558 }
11559 
11560 /*!
11561     Returns the string converted to a \c{long long} using base \a
11562     base, which is 10 by default and must be between 2 and 36, or 0.
11563     Returns 0 if the conversion fails.
11564 
11565     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11566     to \c false, and success by setting *\a{ok} to \c true.
11567 
11568     If \a base is 0, the C language convention is used: If the string
11569     begins with "0x", base 16 is used; if the string begins with "0",
11570     base 8 is used; otherwise, base 10 is used.
11571 
11572     The string conversion will always happen in the 'C' locale. For locale
11573     dependent conversion use QLocale::toLongLong()
11574 
11575     \sa QString::toLongLong()
11576 
11577     \since 5.1
11578 */
11579 
11580 qint64 QStringRef::toLongLong(bool *ok, int base) const
11581 {
11582     return QString::toIntegral_helper<qint64>(*this, ok, base);
11583 }
11584 
11585 /*!
11586     Returns the string converted to an \c{unsigned long long} using base \a
11587     base, which is 10 by default and must be between 2 and 36, or 0.
11588     Returns 0 if the conversion fails.
11589 
11590     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11591     to \c false, and success by setting *\a{ok} to \c true.
11592 
11593     If \a base is 0, the C language convention is used: If the string
11594     begins with "0x", base 16 is used; if the string begins with "0",
11595     base 8 is used; otherwise, base 10 is used.
11596 
11597     The string conversion will always happen in the 'C' locale. For locale
11598     dependent conversion use QLocale::toULongLong()
11599 
11600     \sa QString::toULongLong()
11601 
11602     \since 5.1
11603 */
11604 
11605 quint64 QStringRef::toULongLong(bool *ok, int base) const
11606 {
11607     return QString::toIntegral_helper<quint64>(*this, ok, base);
11608 }
11609 
11610 /*!
11611     \fn long QStringRef::toLong(bool *ok, int base) const
11612 
11613     Returns the string converted to a \c long using base \a
11614     base, which is 10 by default and must be between 2 and 36, or 0.
11615     Returns 0 if the conversion fails.
11616 
11617     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11618     to \c false, and success by setting *\a{ok} to \c true.
11619 
11620     If \a base is 0, the C language convention is used: If the string
11621     begins with "0x", base 16 is used; if the string begins with "0",
11622     base 8 is used; otherwise, base 10 is used.
11623 
11624     The string conversion will always happen in the 'C' locale. For locale
11625     dependent conversion use QLocale::toLong()
11626 
11627     \sa QString::toLong()
11628 
11629     \since 5.1
11630 */
11631 
11632 long QStringRef::toLong(bool *ok, int base) const
11633 {
11634     return QString::toIntegral_helper<long>(*this, ok, base);
11635 }
11636 
11637 /*!
11638     \fn ulong QStringRef::toULong(bool *ok, int base) const
11639 
11640     Returns the string converted to an \c{unsigned long} using base \a
11641     base, which is 10 by default and must be between 2 and 36, or 0.
11642     Returns 0 if the conversion fails.
11643 
11644     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11645     to \c false, and success by setting *\a{ok} to \c true.
11646 
11647     If \a base is 0, the C language convention is used: If the string
11648     begins with "0x", base 16 is used; if the string begins with "0",
11649     base 8 is used; otherwise, base 10 is used.
11650 
11651     The string conversion will always happen in the 'C' locale. For locale
11652     dependent conversion use QLocale::toULongLong()
11653 
11654     \sa QString::toULong()
11655 
11656     \since 5.1
11657 */
11658 
11659 ulong QStringRef::toULong(bool *ok, int base) const
11660 {
11661     return QString::toIntegral_helper<ulong>(*this, ok, base);
11662 }
11663 
11664 
11665 /*!
11666     Returns the string converted to an \c int using base \a
11667     base, which is 10 by default and must be between 2 and 36, or 0.
11668     Returns 0 if the conversion fails.
11669 
11670     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11671     to \c false, and success by setting *\a{ok} to \c true.
11672 
11673     If \a base is 0, the C language convention is used: If the string
11674     begins with "0x", base 16 is used; if the string begins with "0",
11675     base 8 is used; otherwise, base 10 is used.
11676 
11677     The string conversion will always happen in the 'C' locale. For locale
11678     dependent conversion use QLocale::toInt()
11679 
11680     \sa QString::toInt()
11681 
11682     \since 5.1
11683 */
11684 
11685 int QStringRef::toInt(bool *ok, int base) const
11686 {
11687     return QString::toIntegral_helper<int>(*this, ok, base);
11688 }
11689 
11690 /*!
11691     Returns the string converted to an \c{unsigned int} using base \a
11692     base, which is 10 by default and must be between 2 and 36, or 0.
11693     Returns 0 if the conversion fails.
11694 
11695     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11696     to \c false, and success by setting *\a{ok} to \c true.
11697 
11698     If \a base is 0, the C language convention is used: If the string
11699     begins with "0x", base 16 is used; if the string begins with "0",
11700     base 8 is used; otherwise, base 10 is used.
11701 
11702     The string conversion will always happen in the 'C' locale. For locale
11703     dependent conversion use QLocale::toUInt()
11704 
11705     \sa QString::toUInt()
11706 
11707     \since 5.1
11708 */
11709 
11710 uint QStringRef::toUInt(bool *ok, int base) const
11711 {
11712     return QString::toIntegral_helper<uint>(*this, ok, base);
11713 }
11714 
11715 /*!
11716     Returns the string converted to a \c short using base \a
11717     base, which is 10 by default and must be between 2 and 36, or 0.
11718     Returns 0 if the conversion fails.
11719 
11720     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11721     to \c false, and success by setting *\a{ok} to \c true.
11722 
11723     If \a base is 0, the C language convention is used: If the string
11724     begins with "0x", base 16 is used; if the string begins with "0",
11725     base 8 is used; otherwise, base 10 is used.
11726 
11727     The string conversion will always happen in the 'C' locale. For locale
11728     dependent conversion use QLocale::toShort()
11729 
11730     \sa QString::toShort()
11731 
11732     \since 5.1
11733 */
11734 
11735 short QStringRef::toShort(bool *ok, int base) const
11736 {
11737     return QString::toIntegral_helper<short>(*this, ok, base);
11738 }
11739 
11740 /*!
11741     Returns the string converted to an \c{unsigned short} using base \a
11742     base, which is 10 by default and must be between 2 and 36, or 0.
11743     Returns 0 if the conversion fails.
11744 
11745     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11746     to \c false, and success by setting *\a{ok} to \c true.
11747 
11748     If \a base is 0, the C language convention is used: If the string
11749     begins with "0x", base 16 is used; if the string begins with "0",
11750     base 8 is used; otherwise, base 10 is used.
11751 
11752     The string conversion will always happen in the 'C' locale. For locale
11753     dependent conversion use QLocale::toUShort()
11754 
11755     \sa QString::toUShort()
11756 
11757     \since 5.1
11758 */
11759 
11760 ushort QStringRef::toUShort(bool *ok, int base) const
11761 {
11762     return QString::toIntegral_helper<ushort>(*this, ok, base);
11763 }
11764 
11765 
11766 /*!
11767     Returns the string converted to a \c double value.
11768 
11769     Returns an infinity if the conversion overflows or 0.0 if the
11770     conversion fails for other reasons (e.g. underflow).
11771 
11772     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11773     to \c false, and success by setting *\a{ok} to \c true.
11774 
11775     The string conversion will always happen in the 'C' locale. For locale
11776     dependent conversion use QLocale::toDouble()
11777 
11778     For historic reasons, this function does not handle
11779     thousands group separators. If you need to convert such numbers,
11780     use QLocale::toDouble().
11781 
11782     \sa QString::toDouble()
11783 
11784     \since 5.1
11785 */
11786 
11787 double QStringRef::toDouble(bool *ok) const
11788 {
11789     return QLocaleData::c()->stringToDouble(*this, ok, QLocale::RejectGroupSeparator);
11790 }
11791 
11792 /*!
11793     Returns the string converted to a \c float value.
11794 
11795     Returns an infinity if the conversion overflows or 0.0 if the
11796     conversion fails for other reasons (e.g. underflow).
11797 
11798     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
11799     to \c false, and success by setting *\a{ok} to \c true.
11800 
11801     The string conversion will always happen in the 'C' locale. For locale
11802     dependent conversion use QLocale::toFloat()
11803 
11804     \sa QString::toFloat()
11805 
11806     \since 5.1
11807 */
11808 
11809 float QStringRef::toFloat(bool *ok) const
11810 {
11811     return QLocaleData::convertDoubleToFloat(toDouble(ok), ok);
11812 }
11813 
11814 /*!
11815     \since 5.0
11816 
11817     Converts a plain text string to an HTML string with
11818     HTML metacharacters \c{<}, \c{>}, \c{&}, and \c{"} replaced by HTML
11819     entities.
11820 
11821     Example:
11822 
11823     \snippet code/src_corelib_text_qstring.cpp 7
11824 */
11825 QString QString::toHtmlEscaped() const
11826 {
11827     QString rich;
11828     const int len = length();
11829     rich.reserve(qsizetype(len * 1.1));
11830     for (int i = 0; i < len; ++i) {
11831         if (at(i) == QLatin1Char('<'))
11832             rich += QLatin1String("&lt;");
11833         else if (at(i) == QLatin1Char('>'))
11834             rich += QLatin1String("&gt;");
11835         else if (at(i) == QLatin1Char('&'))
11836             rich += QLatin1String("&amp;");
11837         else if (at(i) == QLatin1Char('"'))
11838             rich += QLatin1String("&quot;");
11839         else
11840             rich += at(i);
11841     }
11842     rich.squeeze();
11843     return rich;
11844 }
11845 
11846 /*!
11847   \macro QStringLiteral(str)
11848   \relates QString
11849 
11850   The macro generates the data for a QString out of the string literal \a str
11851   at compile time. Creating a QString from it is free in this case, and the
11852   generated string data is stored in the read-only segment of the compiled
11853   object file.
11854 
11855   If you have code that looks like this:
11856 
11857   \snippet code/src_corelib_text_qstring.cpp 9
11858 
11859   then a temporary QString will be created to be passed as the \c{hasAttribute}
11860   function parameter. This can be quite expensive, as it involves a memory
11861   allocation and the copy/conversion of the data into QString's internal
11862   encoding.
11863 
11864   This cost can be avoided by using QStringLiteral instead:
11865 
11866   \snippet code/src_corelib_text_qstring.cpp 10
11867 
11868   In this case, QString's internal data will be generated at compile time; no
11869   conversion or allocation will occur at runtime.
11870 
11871   Using QStringLiteral instead of a double quoted plain C++ string literal can
11872   significantly speed up creation of QString instances from data known at
11873   compile time.
11874 
11875   \note QLatin1String can still be more efficient than QStringLiteral
11876   when the string is passed to a function that has an overload taking
11877   QLatin1String and this overload avoids conversion to QString.  For
11878   instance, QString::operator==() can compare to a QLatin1String
11879   directly:
11880 
11881   \snippet code/src_corelib_text_qstring.cpp 11
11882 
11883   \note Some compilers have bugs encoding strings containing characters outside
11884   the US-ASCII character set. Make sure you prefix your string with \c{u} in
11885   those cases. It is optional otherwise.
11886 
11887   \sa QByteArrayLiteral
11888 */
11889 
11890 /*!
11891     \internal
11892  */
11893 void QAbstractConcatenable::appendLatin1To(const char *a, int len, QChar *out) noexcept
11894 {
11895     qt_from_latin1(reinterpret_cast<char16_t *>(out), a, size_t(len));
11896 }
11897 
11898 double QStringView::toDouble(bool *ok) const
11899 {
11900     return QLocaleData::c()->stringToDouble(*this, ok, QLocale::RejectGroupSeparator);
11901 }
11902 
11903 float QStringView::toFloat(bool *ok) const
11904 {
11905     return QLocaleData::convertDoubleToFloat(toDouble(ok), ok);
11906 }
11907 
11908 QT_END_NAMESPACE
