Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2015 The Qt Company Ltd.
4 ** Contact: http://www.qt.io/licensing/
5 **
6 ** This file is part of the plugins of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL21$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see http://www.qt.io/terms-conditions. For further
15 ** information use the contact form at http://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 2.1 or version 3 as published by the Free
20 ** Software Foundation and appearing in the file LICENSE.LGPLv21 and
21 ** LICENSE.LGPLv3 included in the packaging of this file. Please review the
22 ** following information to ensure the GNU Lesser General Public License
23 ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
24 ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
25 **
26 ** As a special exception, The Qt Company gives you certain additional
27 ** rights. These rights are described in The Qt Company LGPL Exception
28 ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
29 **
30 ** $QT_END_LICENSE$
31 **
32 ****************************************************************************/
33 
34 #include <QtGui/private/qguiapplication_p.h>
35 #include <QtCore/QDebug>
36 
37 #include "qxcbconnection.h"
38 #include "qxcbkeyboard.h"
39 #include "qxcbscreen.h"
40 #include "qxcbwindow.h"
41 #include "qxcbclipboard.h"
42 #include "qxcbdrag.h"
43 #include "qxcbwmsupport.h"
44 #include "qxcbnativeinterface.h"
45 #include "qxcbintegration.h"
46 #include "qxcbsystemtraytracker.h"
47 #include "qxcbglintegrationfactory.h"
48 #include "qxcbglintegration.h"
49 
50 #include <QSocketNotifier>
51 #include <QAbstractEventDispatcher>
52 #include <QTimer>
53 #include <QByteArray>
54 #include <QScopedPointer>
55 
56 #include <algorithm>
57 
58 #include <stdio.h>
59 #include <errno.h>
60 #include <xcb/shm.h>
61 #include <xcb/sync.h>
62 #include <xcb/xfixes.h>
63 
64 #ifdef XCB_USE_XLIB
65 #include <X11/Xlib.h>
66 #include <X11/Xlib-xcb.h>
67 #include <X11/Xlibint.h>
68 #include <X11/Xutil.h>
69 #endif
70 
71 #if defined(XCB_USE_XINPUT2)
72 #include <X11/extensions/XI2proto.h>
73 #endif
74 
75 #ifdef XCB_USE_RENDER
76 #include <xcb/render.h>
77 #endif
78 
79 #if defined(Q_CC_GNU) && defined(Q_OF_ELF)
80 static xcb_generic_event_t *local_xcb_poll_for_queued_event(xcb_connection_t *c)
81     __attribute__((weakref("xcb_poll_for_queued_event")));
82 
83 static inline void checkXcbPollForQueuedEvent()
84 { }
85 #else
86 #include <dlfcn.h>
87 typedef xcb_generic_event_t * (*XcbPollForQueuedEventFunctionPointer)(xcb_connection_t *c);
88 static XcbPollForQueuedEventFunctionPointer local_xcb_poll_for_queued_event;
89 
90 static inline void checkXcbPollForQueuedEvent()
91 {
92 #ifdef RTLD_DEFAULT
93     local_xcb_poll_for_queued_event = (XcbPollForQueuedEventFunctionPointer)dlsym(RTLD_DEFAULT, "xcb_poll_for_queued_event");
94 #endif
95 }
96 #endif
97 
98 QT_BEGIN_NAMESPACE
99 
100 Q_LOGGING_CATEGORY(lcQpaXInput, "qt.qpa.input")
101 Q_LOGGING_CATEGORY(lcQpaXInputDevices, "qt.qpa.input.devices")
102 Q_LOGGING_CATEGORY(lcQpaScreen, "qt.qpa.screen")
103 
104 // this event type was added in libxcb 1.10,
105 // but we support also older version
106 #ifndef XCB_GE_GENERIC
107 #define XCB_GE_GENERIC 35
108 #endif
109 
110 // Starting from the xcb version 1.9.3 struct xcb_ge_event_t has changed:
111 // - "pad0" became "extension"
112 // - "pad1" and "pad" became "pad0"
113 // New and old version of this struct share the following fields:
114 typedef struct qt_xcb_ge_event_t {
115     uint8_t  response_type;
116     uint8_t  extension;
117     uint16_t sequence;
118     uint32_t length;
119     uint16_t event_type;
120 } qt_xcb_ge_event_t;
121 
122 static inline bool isXIEvent(xcb_generic_event_t *event, int opCode)
123 {
124     qt_xcb_ge_event_t *e = (qt_xcb_ge_event_t *)event;
125     return e->extension == opCode;
126 }
127 
128 #ifdef XCB_USE_XLIB
129 static const char * const xcbConnectionErrors[] = {
130     "No error", /* Error 0 */
131     "I/O error", /* XCB_CONN_ERROR */
132     "Unsupported extension used", /* XCB_CONN_CLOSED_EXT_NOTSUPPORTED */
133     "Out of memory", /* XCB_CONN_CLOSED_MEM_INSUFFICIENT */
134     "Maximum allowed requested length exceeded", /* XCB_CONN_CLOSED_REQ_LEN_EXCEED */
135     "Failed to parse display string", /* XCB_CONN_CLOSED_PARSE_ERR */
136     "No such screen on display", /* XCB_CONN_CLOSED_INVALID_SCREEN */
137     "Error during FD passing" /* XCB_CONN_CLOSED_FDPASSING_FAILED */
138 };
139 
140 static int nullErrorHandler(Display *, XErrorEvent *)
141 {
142     return 0;
143 }
144 
145 static int ioErrorHandler(Display *dpy)
146 {
147     xcb_connection_t *conn = XGetXCBConnection(dpy);
148     if (conn != NULL) {
149         /* Print a message with a textual description of the error */
150         int code = xcb_connection_has_error(conn);
151         const char *str = "Unknown error";
152         int arrayLength = sizeof(xcbConnectionErrors) / sizeof(xcbConnectionErrors[0]);
153         if (code >= 0 && code < arrayLength)
154             str = xcbConnectionErrors[code];
155 
156         qWarning("The X11 connection broke: %s (code %d)", str, code);
157     }
158     return _XDefaultIOError(dpy);
159 }
160 #endif
161 
162 QXcbScreen* QXcbConnection::findScreenForCrtc(xcb_window_t rootWindow, xcb_randr_crtc_t crtc)
163 {
164     foreach (QXcbScreen *screen, m_screens) {
165         if (screen->root() == rootWindow && screen->crtc() == crtc)
166             return screen;
167     }
168 
169     return 0;
170 }
171 
172 QXcbScreen* QXcbConnection::findScreenForOutput(xcb_window_t rootWindow, xcb_randr_output_t output)
173 {
174     foreach (QXcbScreen *screen, m_screens) {
175         if (screen->root() == rootWindow && screen->output() == output)
176             return screen;
177     }
178 
179     return 0;
180 }
181 
182 QXcbVirtualDesktop* QXcbConnection::virtualDesktopForRootWindow(xcb_window_t rootWindow)
183 {
184     foreach (QXcbVirtualDesktop *virtualDesktop, m_virtualDesktops) {
185         if (virtualDesktop->screen()->root == rootWindow)
186             return virtualDesktop;
187     }
188 
189     return 0;
190 }
191 
192 /*!
193     \brief Synchronizes the screen list, adds new screens, removes deleted ones
194 */
195 void QXcbConnection::updateScreens(const xcb_randr_notify_event_t *event)
196 {
197     if (event->subCode == XCB_RANDR_NOTIFY_CRTC_CHANGE) {
198         xcb_randr_crtc_change_t crtc = event->u.cc;
199         QXcbVirtualDesktop *virtualDesktop = virtualDesktopForRootWindow(crtc.window);
200         if (!virtualDesktop)
201             // Not for us
202             return;
203 
204         QXcbScreen *screen = findScreenForCrtc(crtc.window, crtc.crtc);
205         qCDebug(lcQpaScreen) << "QXcbConnection: XCB_RANDR_NOTIFY_CRTC_CHANGE:" << crtc.crtc
206                              << "mode" << crtc.mode << "relevant screen" << screen;
207         // Only update geometry when there's a valid mode on the CRTC
208         // CRTC with node mode could mean that output has been disabled, and we'll
209         // get RRNotifyOutputChange notification for that.
210         if (screen && crtc.mode) {
211             screen->updateGeometry(QRect(crtc.x, crtc.y, crtc.width, crtc.height), crtc.rotation);
212             if (screen->mode() != crtc.mode)
213                 screen->updateRefreshRate(crtc.mode);
214         }
215 
216     } else if (event->subCode == XCB_RANDR_NOTIFY_OUTPUT_CHANGE) {
217         xcb_randr_output_change_t output = event->u.oc;
218         QXcbVirtualDesktop *virtualDesktop = virtualDesktopForRootWindow(output.window);
219         if (!virtualDesktop)
220             // Not for us
221             return;
222 
223         QXcbScreen *screen = findScreenForOutput(output.window, output.output);
224         qCDebug(lcQpaScreen) << "QXcbConnection: XCB_RANDR_NOTIFY_OUTPUT_CHANGE:" << output.output;
225 
226         if (screen && output.connection == XCB_RANDR_CONNECTION_DISCONNECTED) {
227             qCDebug(lcQpaScreen) << "screen" << screen->name() << "has been disconnected";
228             destroyScreen(screen);
229         } else if (!screen && output.connection == XCB_RANDR_CONNECTION_CONNECTED) {
230             // New XRandR output is available and it's enabled
231             if (output.crtc != XCB_NONE && output.mode != XCB_NONE) {
232                 xcb_randr_get_output_info_cookie_t outputInfoCookie =
233                     xcb_randr_get_output_info(xcb_connection(), output.output, output.config_timestamp);
234                 QScopedPointer<xcb_randr_get_output_info_reply_t, QScopedPointerPodDeleter> outputInfo(
235                     xcb_randr_get_output_info_reply(xcb_connection(), outputInfoCookie, NULL));
236 
237                 // Find a fake screen
238                 foreach (QPlatformScreen *scr, virtualDesktop->screens()) {
239                     QXcbScreen *xcbScreen = (QXcbScreen *)scr;
240                     if (xcbScreen->output() == XCB_NONE) {
241                         screen = xcbScreen;
242                         break;
243                     }
244                 }
245 
246                 if (screen) {
247                     QString nameWas = screen->name();
248                     // Transform the fake screen into a physical screen
249                     screen->setOutput(output.output, outputInfo.data());
250                     updateScreen(screen, output);
251                     qCDebug(lcQpaScreen) << "output" << screen->name()
252                                          << "is connected and enabled; was fake:" << nameWas;
253                 } else {
254                     screen = createScreen(virtualDesktop, output, outputInfo.data());
255                     qCDebug(lcQpaScreen) << "output" << screen->name() << "is connected and enabled";
256                 }
257             }
258         } else if (screen) {
259             if (output.crtc == XCB_NONE && output.mode == XCB_NONE) {
260                 // Screen has been disabled
261                 xcb_randr_get_output_info_cookie_t outputInfoCookie =
262                     xcb_randr_get_output_info(xcb_connection(), output.output, output.config_timestamp);
263                 QScopedPointer<xcb_randr_get_output_info_reply_t, QScopedPointerPodDeleter> outputInfo(
264                     xcb_randr_get_output_info_reply(xcb_connection(), outputInfoCookie, NULL));
265                 if (outputInfo->crtc == XCB_NONE) {
266                     qCDebug(lcQpaScreen) << "output" << screen->name() << "has been disabled";
267                     destroyScreen(screen);
268                 } else {
269                     qCDebug(lcQpaScreen) << "output" << screen->name() << "has been temporarily disabled for the mode switch";
270                     // Reset crtc to skip RRCrtcChangeNotify events,
271                     // because they may be invalid in the middle of the mode switch
272                     screen->setCrtc(XCB_NONE);
273                 }
274             } else {
275                 updateScreen(screen, output);
276                 qCDebug(lcQpaScreen) << "output has changed" << screen;
277             }
278         }
279 
280         qCDebug(lcQpaScreen) << "primary output is" << m_screens.first()->name();
281     }
282 }
283 
284 bool QXcbConnection::checkOutputIsPrimary(xcb_window_t rootWindow, xcb_randr_output_t output)
285 {
286     xcb_generic_error_t *error = 0;
287     xcb_randr_get_output_primary_cookie_t primaryCookie =
288         xcb_randr_get_output_primary(xcb_connection(), rootWindow);
289     QScopedPointer<xcb_randr_get_output_primary_reply_t, QScopedPointerPodDeleter> primary (
290         xcb_randr_get_output_primary_reply(xcb_connection(), primaryCookie, &error));
291     if (!primary || error) {
292         qWarning("failed to get the primary output of the screen");
293         free(error);
294         error = NULL;
295     }
296     const bool isPrimary = primary ? (primary->output == output) : false;
297 
298     return isPrimary;
299 }
300 
301 void QXcbConnection::updateScreen(QXcbScreen *screen, const xcb_randr_output_change_t &outputChange)
302 {
303     screen->setCrtc(outputChange.crtc); // Set the new crtc, because it can be invalid
304     screen->updateGeometry(outputChange.config_timestamp);
305     if (screen->mode() != outputChange.mode)
306         screen->updateRefreshRate(outputChange.mode);
307     // Only screen which belongs to the primary virtual desktop can be a primary screen
308     if (screen->screenNumber() == m_primaryScreenNumber) {
309         if (!screen->isPrimary() && checkOutputIsPrimary(outputChange.window, outputChange.output)) {
310             screen->setPrimary(true);
311 
312             // If the screen became primary, reshuffle the order in QGuiApplicationPrivate
313             const int idx = m_screens.indexOf(screen);
314             if (idx > 0) {
315                 m_screens.first()->setPrimary(false);
316                 m_screens.swap(0, idx);
317             }
318             screen->virtualDesktop()->setPrimaryScreen(screen);
319             QXcbIntegration::instance()->setPrimaryScreen(screen);
320         }
321     }
322 }
323 
324 QXcbScreen *QXcbConnection::createScreen(QXcbVirtualDesktop *virtualDesktop,
325                                          const xcb_randr_output_change_t &outputChange,
326                                          xcb_randr_get_output_info_reply_t *outputInfo)
327 {
328     QXcbScreen *screen = new QXcbScreen(this, virtualDesktop, outputChange.output, outputInfo);
329     // Only screen which belongs to the primary virtual desktop can be a primary screen
330     if (screen->screenNumber() == m_primaryScreenNumber)
331         screen->setPrimary(checkOutputIsPrimary(outputChange.window, outputChange.output));
332 
333     if (screen->isPrimary()) {
334         if (!m_screens.isEmpty())
335             m_screens.first()->setPrimary(false);
336 
337         m_screens.prepend(screen);
338     } else {
339         m_screens.append(screen);
340     }
341     virtualDesktop->addScreen(screen);
342     QXcbIntegration::instance()->screenAdded(screen, screen->isPrimary());
343 
344     return screen;
345 }
346 
347 void QXcbConnection::destroyScreen(QXcbScreen *screen)
348 {
349     QXcbVirtualDesktop *virtualDesktop = screen->virtualDesktop();
350     if (virtualDesktop->screens().count() == 1) {
351         // If there are no other screens on the same virtual desktop,
352         // then transform the physical screen into a fake screen.
353         const QString nameWas = screen->name();
354         screen->setOutput(XCB_NONE, Q_NULLPTR);
355         qCDebug(lcQpaScreen) << "transformed" << nameWas << "to fake" << screen;
356     } else {
357         // There is more than one screen on the same virtual desktop, remove the screen
358         m_screens.removeOne(screen);
359         virtualDesktop->removeScreen(screen);
360 
361         // When primary screen is removed, set the new primary screen
362         // which belongs to the primary virtual desktop.
363         if (screen->isPrimary()) {
364             QXcbScreen *newPrimary = (QXcbScreen *)virtualDesktop->screens().at(0);
365             newPrimary->setPrimary(true);
366             const int idx = m_screens.indexOf(newPrimary);
367             if (idx > 0)
368                 m_screens.swap(0, idx);
369             QXcbIntegration::instance()->setPrimaryScreen(newPrimary);
370         }
371 
372         QXcbIntegration::instance()->destroyScreen(screen);
373     }
374 }
375 
376 void QXcbConnection::initializeScreens()
377 {
378     xcb_screen_iterator_t it = xcb_setup_roots_iterator(m_setup);
379     int xcbScreenNumber = 0;    // screen number in the xcb sense
380     QXcbScreen *primaryScreen = Q_NULLPTR;
381     while (it.rem) {
382         // Each "screen" in xcb terminology is a virtual desktop,
383         // potentially a collection of separate juxtaposed monitors.
384         // But we want a separate QScreen for each output (e.g. DVI-I-1, VGA-1, etc.)
385         // which will become virtual siblings.
386         xcb_screen_t *xcbScreen = it.data;
387         QXcbVirtualDesktop *virtualDesktop = new QXcbVirtualDesktop(this, xcbScreen, xcbScreenNumber);
388         m_virtualDesktops.append(virtualDesktop);
389         if (has_randr_extension) {
390             xcb_generic_error_t *error = NULL;
391             // RRGetScreenResourcesCurrent is fast but it may return nothing if the
392             // configuration is not initialized wrt to the hardware. We should call
393             // RRGetScreenResources in this case.
394             QScopedPointer<xcb_randr_get_screen_resources_reply_t, QScopedPointerPodDeleter> resources;
395             xcb_randr_get_screen_resources_current_cookie_t resourcesCookie =
396                 xcb_randr_get_screen_resources_current(xcb_connection(), xcbScreen->root);
397             QScopedPointer<xcb_randr_get_screen_resources_current_reply_t, QScopedPointerPodDeleter> resources_current(
398                     xcb_randr_get_screen_resources_current_reply(xcb_connection(), resourcesCookie, &error));
399             if (!resources_current || error) {
400                 qWarning("failed to get the current screen resources");
401                 free(error);
402             } else {
403                 xcb_timestamp_t timestamp;
404                 xcb_randr_output_t *outputs = Q_NULLPTR;
405                 int outputCount = xcb_randr_get_screen_resources_current_outputs_length(resources_current.data());
406                 if (outputCount) {
407                     timestamp = resources_current->config_timestamp;
408                     outputs = xcb_randr_get_screen_resources_current_outputs(resources_current.data());
409                 } else {
410                     xcb_randr_get_screen_resources_cookie_t resourcesCookie =
411                         xcb_randr_get_screen_resources(xcb_connection(), xcbScreen->root);
412                     resources.reset(xcb_randr_get_screen_resources_reply(xcb_connection(), resourcesCookie, &error));
413                     if (!resources || error) {
414                         qWarning("failed to get the screen resources");
415                         free(error);
416                     } else {
417                         timestamp = resources->config_timestamp;
418                         outputCount = xcb_randr_get_screen_resources_outputs_length(resources.data());
419                         outputs = xcb_randr_get_screen_resources_outputs(resources.data());
420                     }
421                 }
422 
423                 if (outputCount) {
424                     xcb_randr_get_output_primary_cookie_t primaryCookie =
425                         xcb_randr_get_output_primary(xcb_connection(), xcbScreen->root);
426                     QScopedPointer<xcb_randr_get_output_primary_reply_t, QScopedPointerPodDeleter> primary(
427                             xcb_randr_get_output_primary_reply(xcb_connection(), primaryCookie, &error));
428                     if (!primary || error) {
429                         qWarning("failed to get the primary output of the screen");
430                         free(error);
431                     } else {
432                         QList<QPlatformScreen *> siblings;
433                         for (int i = 0; i < outputCount; i++) {
434                             QScopedPointer<xcb_randr_get_output_info_reply_t, QScopedPointerPodDeleter> output(
435                                     xcb_randr_get_output_info_reply(xcb_connection(),
436                                         xcb_randr_get_output_info_unchecked(xcb_connection(), outputs[i], timestamp), NULL));
437 
438                             // Invalid, disconnected or disabled output
439                             if (output == NULL)
440                                 continue;
441 
442                             if (output->connection != XCB_RANDR_CONNECTION_CONNECTED) {
443                                 qCDebug(lcQpaScreen, "Output %s is not connected", qPrintable(
444                                             QString::fromUtf8((const char*)xcb_randr_get_output_info_name(output.data()),
445                                                               xcb_randr_get_output_info_name_length(output.data()))));
446                                 continue;
447                             }
448 
449                             if (output->crtc == XCB_NONE) {
450                                 qCDebug(lcQpaScreen, "Output %s is not enabled", qPrintable(
451                                             QString::fromUtf8((const char*)xcb_randr_get_output_info_name(output.data()),
452                                                               xcb_randr_get_output_info_name_length(output.data()))));
453                                 continue;
454                             }
455 
456                             QXcbScreen *screen = new QXcbScreen(this, virtualDesktop, outputs[i], output.data());
457                             siblings << screen;
458                             m_screens << screen;
459 
460                             // There can be multiple outputs per screen, use either
461                             // the first or an exact match.  An exact match isn't
462                             // always available if primary->output is XCB_NONE
463                             // or currently disconnected output.
464                             if (m_primaryScreenNumber == xcbScreenNumber) {
465                                 if (!primaryScreen || (primary && outputs[i] == primary->output)) {
466                                     if (primaryScreen)
467                                         primaryScreen->setPrimary(false);
468                                     primaryScreen = screen;
469                                     primaryScreen->setPrimary(true);
470                                     siblings.prepend(siblings.takeLast());
471                                 }
472                             }
473                         }
474                         virtualDesktop->setScreens(siblings);
475                     }
476                 }
477             }
478         }
479         if (virtualDesktop->screens().isEmpty()) {
480             // If there are no XRandR outputs or XRandR extension is missing,
481             // then create a fake/legacy screen.
482             QXcbScreen *screen = new QXcbScreen(this, virtualDesktop, XCB_NONE, Q_NULLPTR);
483             qCDebug(lcQpaScreen) << "created fake screen" << screen;
484             m_screens << screen;
485             if (m_primaryScreenNumber == xcbScreenNumber) {
486                 primaryScreen = screen;
487                 primaryScreen->setPrimary(true);
488             }
489             virtualDesktop->addScreen(screen);
490         }
491         xcb_screen_next(&it);
492         ++xcbScreenNumber;
493     } // for each xcb screen
494 
495     foreach (QXcbVirtualDesktop *virtualDesktop, m_virtualDesktops)
496         virtualDesktop->subscribeToXFixesSelectionNotify();
497 
498     if (m_virtualDesktops.isEmpty()) {
499         qFatal("QXcbConnection: no screens available");
500     } else {
501         // Ensure the primary screen is first on the list
502         if (primaryScreen) {
503             if (m_screens.first() != primaryScreen) {
504                 m_screens.removeOne(primaryScreen);
505                 m_screens.prepend(primaryScreen);
506             }
507         }
508 
509         // Push the screens to QGuiApplication
510         foreach (QXcbScreen *screen, m_screens) {
511             qCDebug(lcQpaScreen) << "adding" << screen << "(Primary:" << screen->isPrimary() << ")";
512             QXcbIntegration::instance()->screenAdded(screen, screen->isPrimary());
513         }
514 
515         qCDebug(lcQpaScreen) << "primary output is" << m_screens.first()->name();
516     }
517 }
518 
519 QXcbConnection::QXcbConnection(QXcbNativeInterface *nativeInterface, bool canGrabServer, xcb_visualid_t defaultVisualId, const char *displayName)
520     : m_connection(0)
521     , m_canGrabServer(canGrabServer)
522     , m_defaultVisualId(defaultVisualId)
523     , m_primaryScreenNumber(0)
524     , m_displayName(displayName ? QByteArray(displayName) : qgetenv("DISPLAY"))
525     , m_nativeInterface(nativeInterface)
526 #ifdef XCB_USE_XLIB
527     , m_xlib_display(0)
528 #endif
529     , xfixes_first_event(0)
530     , xrandr_first_event(0)
531     , xkb_first_event(0)
532     , has_shape_extension(false)
533     , has_randr_extension(false)
534     , has_input_shape(false)
535     , has_xkb(false)
536     , m_buttons(0)
537     , m_focusWindow(0)
538     , m_clientLeader(0)
539     , m_systemTrayTracker(0)
540     , m_glIntegration(Q_NULLPTR)
541     , m_xiGrab(false)
542     , m_qtSelectionOwner(0)
543 {
544 #ifdef XCB_USE_XLIB
545     Display *dpy = XOpenDisplay(m_displayName.constData());
546     if (dpy) {
547         m_primaryScreenNumber = DefaultScreen(dpy);
548         m_connection = XGetXCBConnection(dpy);
549         XSetEventQueueOwner(dpy, XCBOwnsEventQueue);
550         XSetErrorHandler(nullErrorHandler);
551         XSetIOErrorHandler(ioErrorHandler);
552         m_xlib_display = dpy;
553     }
554 #else
555     m_connection = xcb_connect(m_displayName.constData(), &m_primaryScreenNumber);
556 #endif //XCB_USE_XLIB
557 
558     if (Q_UNLIKELY(!m_connection || xcb_connection_has_error(m_connection)))
559         qFatal("QXcbConnection: Could not connect to display %s", m_displayName.constData());
560 
561 
562     m_reader = new QXcbEventReader(this);
563     m_reader->start();
564 
565     xcb_extension_t *extensions[] = {
566         &xcb_shm_id, &xcb_xfixes_id, &xcb_randr_id, &xcb_shape_id, &xcb_sync_id,
567 #ifndef QT_NO_XKB
568         &xcb_xkb_id,
569 #endif
570 #ifdef XCB_USE_RENDER
571         &xcb_render_id,
572 #endif
573         0
574     };
575 
576     for (xcb_extension_t **ext_it = extensions; *ext_it; ++ext_it)
577         xcb_prefetch_extension_data (m_connection, *ext_it);
578 
579     m_setup = xcb_get_setup(xcb_connection());
580 
581     initializeAllAtoms();
582 
583     m_time = XCB_CURRENT_TIME;
584     m_netWmUserTime = XCB_CURRENT_TIME;
585 
586     initializeXRandr();
587     initializeXFixes();
588     initializeScreens();
589 
590     initializeXRender();
591     m_xi2Enabled = false;
592 #if defined(XCB_USE_XINPUT2)
593     initializeXInput2();
594 #endif
595     initializeXShape();
596     initializeXKB();
597 
598     m_wmSupport.reset(new QXcbWMSupport(this));
599     m_keyboard = new QXcbKeyboard(this);
600 #ifndef QT_NO_CLIPBOARD
601     m_clipboard = new QXcbClipboard(this);
602 #endif
603 #ifndef QT_NO_DRAGANDDROP
604     m_drag = new QXcbDrag(this);
605 #endif
606 
607     m_startupId = qgetenv("DESKTOP_STARTUP_ID");
608     if (!m_startupId.isNull())
609         qunsetenv("DESKTOP_STARTUP_ID");
610 
611 
612     QStringList glIntegrationNames;
613     glIntegrationNames << QStringLiteral("xcb_glx") << QStringLiteral("xcb_egl");
614     QString glIntegrationName = QString::fromLocal8Bit(qgetenv("QT_XCB_GL_INTEGRATION"));
615     if (!glIntegrationName.isEmpty()) {
616         qCDebug(QT_XCB_GLINTEGRATION) << "QT_XCB_GL_INTEGRATION is set to" << glIntegrationName;
617         if (glIntegrationName != QStringLiteral("none")) {
618             glIntegrationNames.removeAll(glIntegrationName);
619             glIntegrationNames.prepend(glIntegrationName);
620         } else {
621             glIntegrationNames.clear();
622         }
623     }
624 
625     qCDebug(QT_XCB_GLINTEGRATION) << "Choosing xcb gl-integration based on following priority\n" << glIntegrationNames;
626     for (int i = 0; i < glIntegrationNames.size() && !m_glIntegration; i++) {
627         m_glIntegration = QXcbGlIntegrationFactory::create(glIntegrationNames.at(i));
628         if (m_glIntegration && !m_glIntegration->initialize(this)) {
629             qCDebug(QT_XCB_GLINTEGRATION) << "Failed to initialize xcb gl-integration" << glIntegrationNames.at(i);
630             delete m_glIntegration;
631             m_glIntegration = Q_NULLPTR;
632         }
633     }
634     if (!m_glIntegration)
635         qCDebug(QT_XCB_GLINTEGRATION) << "Failed to create xcb gl-integration";
636 
637     sync();
638 }
639 
640 QXcbConnection::~QXcbConnection()
641 {
642 #ifndef QT_NO_CLIPBOARD
643     delete m_clipboard;
644 #endif
645 #ifndef QT_NO_DRAGANDDROP
646     delete m_drag;
647 #endif
648 
649 #if defined(XCB_USE_XINPUT2)
650     finalizeXInput2();
651 #endif
652 
653     if (m_reader->isRunning()) {
654         sendConnectionEvent(QXcbAtom::_QT_CLOSE_CONNECTION);
655         m_reader->wait();
656     }
657 
658     delete m_reader;
659 
660     QXcbIntegration *integration = QXcbIntegration::instance();
661     // Delete screens in reverse order to avoid crash in case of multiple screens
662     while (!m_screens.isEmpty())
663         integration->destroyScreen(m_screens.takeLast());
664 
665     while (!m_virtualDesktops.isEmpty())
666         delete m_virtualDesktops.takeLast();
667 
668     delete m_glIntegration;
669 
670 #ifdef XCB_USE_XLIB
671     XCloseDisplay((Display *)m_xlib_display);
672 #else
673     xcb_disconnect(xcb_connection());
674 #endif
675 
676     delete m_keyboard;
677 }
678 
679 QXcbScreen *QXcbConnection::primaryScreen() const
680 {
681     if (!m_screens.isEmpty()) {
682         Q_ASSERT(m_screens.first()->screenNumber() == primaryScreenNumber());
683         return m_screens.first();
684     }
685 
686     return Q_NULLPTR;
687 }
688 
689 void QXcbConnection::addWindowEventListener(xcb_window_t id, QXcbWindowEventListener *eventListener)
690 {
691     m_mapper.insert(id, eventListener);
692 }
693 
694 void QXcbConnection::removeWindowEventListener(xcb_window_t id)
695 {
696     m_mapper.remove(id);
697 }
698 
699 QXcbWindowEventListener *QXcbConnection::windowEventListenerFromId(xcb_window_t id)
700 {
701     return m_mapper.value(id, 0);
702 }
703 
704 QXcbWindow *QXcbConnection::platformWindowFromId(xcb_window_t id)
705 {
706     QXcbWindowEventListener *listener = m_mapper.value(id, 0);
707     if (listener)
708         return listener->toWindow();
709     return 0;
710 }
711 
712 #define HANDLE_PLATFORM_WINDOW_EVENT(event_t, windowMember, handler) \
713 { \
714     event_t *e = (event_t *)event; \
715     if (QXcbWindowEventListener *eventListener = windowEventListenerFromId(e->windowMember))  { \
716         handled = eventListener->handleGenericEvent(event, &result); \
717         if (!handled) \
718             eventListener->handler(e); \
719     } \
720 } \
721 break;
722 
723 #define HANDLE_KEYBOARD_EVENT(event_t, handler) \
724 { \
725     event_t *e = (event_t *)event; \
726     if (QXcbWindowEventListener *eventListener = windowEventListenerFromId(e->event)) { \
727         handled = eventListener->handleGenericEvent(event, &result); \
728         if (!handled) \
729             m_keyboard->handler(e); \
730     } \
731 } \
732 break;
733 
734 //#define XCB_EVENT_DEBUG
735 
736 void printXcbEvent(const char *message, xcb_generic_event_t *event)
737 {
738 #ifdef XCB_EVENT_DEBUG
739 #define PRINT_XCB_EVENT(ev) \
740     case ev: \
741         qDebug("QXcbConnection: %s: %d - %s - sequence: %d", message, int(ev), #ev, event->sequence); \
742         break;
743 
744     switch (event->response_type & ~0x80) {
745     PRINT_XCB_EVENT(XCB_KEY_PRESS);
746     PRINT_XCB_EVENT(XCB_KEY_RELEASE);
747     PRINT_XCB_EVENT(XCB_BUTTON_PRESS);
748     PRINT_XCB_EVENT(XCB_BUTTON_RELEASE);
749     PRINT_XCB_EVENT(XCB_MOTION_NOTIFY);
750     PRINT_XCB_EVENT(XCB_ENTER_NOTIFY);
751     PRINT_XCB_EVENT(XCB_LEAVE_NOTIFY);
752     PRINT_XCB_EVENT(XCB_FOCUS_IN);
753     PRINT_XCB_EVENT(XCB_FOCUS_OUT);
754     PRINT_XCB_EVENT(XCB_KEYMAP_NOTIFY);
755     PRINT_XCB_EVENT(XCB_EXPOSE);
756     PRINT_XCB_EVENT(XCB_GRAPHICS_EXPOSURE);
757     PRINT_XCB_EVENT(XCB_NO_EXPOSURE);
758     PRINT_XCB_EVENT(XCB_VISIBILITY_NOTIFY);
759     PRINT_XCB_EVENT(XCB_CREATE_NOTIFY);
760     PRINT_XCB_EVENT(XCB_DESTROY_NOTIFY);
761     PRINT_XCB_EVENT(XCB_UNMAP_NOTIFY);
762     PRINT_XCB_EVENT(XCB_MAP_NOTIFY);
763     PRINT_XCB_EVENT(XCB_MAP_REQUEST);
764     PRINT_XCB_EVENT(XCB_REPARENT_NOTIFY);
765     PRINT_XCB_EVENT(XCB_CONFIGURE_NOTIFY);
766     PRINT_XCB_EVENT(XCB_CONFIGURE_REQUEST);
767     PRINT_XCB_EVENT(XCB_GRAVITY_NOTIFY);
768     PRINT_XCB_EVENT(XCB_RESIZE_REQUEST);
769     PRINT_XCB_EVENT(XCB_CIRCULATE_NOTIFY);
770     PRINT_XCB_EVENT(XCB_CIRCULATE_REQUEST);
771     PRINT_XCB_EVENT(XCB_PROPERTY_NOTIFY);
772     PRINT_XCB_EVENT(XCB_SELECTION_CLEAR);
773     PRINT_XCB_EVENT(XCB_SELECTION_REQUEST);
774     PRINT_XCB_EVENT(XCB_SELECTION_NOTIFY);
775     PRINT_XCB_EVENT(XCB_COLORMAP_NOTIFY);
776     PRINT_XCB_EVENT(XCB_CLIENT_MESSAGE);
777     PRINT_XCB_EVENT(XCB_MAPPING_NOTIFY);
778     PRINT_XCB_EVENT(XCB_GE_GENERIC);
779     default:
780         qDebug("QXcbConnection: %s: unknown event - response_type: %d - sequence: %d", message, int(event->response_type & ~0x80), int(event->sequence));
781     }
782 #else
783     Q_UNUSED(message);
784     Q_UNUSED(event);
785 #endif
786 }
787 
788 const char *xcb_errors[] =
789 {
790     "Success",
791     "BadRequest",
792     "BadValue",
793     "BadWindow",
794     "BadPixmap",
795     "BadAtom",
796     "BadCursor",
797     "BadFont",
798     "BadMatch",
799     "BadDrawable",
800     "BadAccess",
801     "BadAlloc",
802     "BadColor",
803     "BadGC",
804     "BadIDChoice",
805     "BadName",
806     "BadLength",
807     "BadImplementation",
808     "Unknown"
809 };
810 
811 const char *xcb_protocol_request_codes[] =
812 {
813     "Null",
814     "CreateWindow",
815     "ChangeWindowAttributes",
816     "GetWindowAttributes",
817     "DestroyWindow",
818     "DestroySubwindows",
819     "ChangeSaveSet",
820     "ReparentWindow",
821     "MapWindow",
822     "MapSubwindows",
823     "UnmapWindow",
824     "UnmapSubwindows",
825     "ConfigureWindow",
826     "CirculateWindow",
827     "GetGeometry",
828     "QueryTree",
829     "InternAtom",
830     "GetAtomName",
831     "ChangeProperty",
832     "DeleteProperty",
833     "GetProperty",
834     "ListProperties",
835     "SetSelectionOwner",
836     "GetSelectionOwner",
837     "ConvertSelection",
838     "SendEvent",
839     "GrabPointer",
840     "UngrabPointer",
841     "GrabButton",
842     "UngrabButton",
843     "ChangeActivePointerGrab",
844     "GrabKeyboard",
845     "UngrabKeyboard",
846     "GrabKey",
847     "UngrabKey",
848     "AllowEvents",
849     "GrabServer",
850     "UngrabServer",
851     "QueryPointer",
852     "GetMotionEvents",
853     "TranslateCoords",
854     "WarpPointer",
855     "SetInputFocus",
856     "GetInputFocus",
857     "QueryKeymap",
858     "OpenFont",
859     "CloseFont",
860     "QueryFont",
861     "QueryTextExtents",
862     "ListFonts",
863     "ListFontsWithInfo",
864     "SetFontPath",
865     "GetFontPath",
866     "CreatePixmap",
867     "FreePixmap",
868     "CreateGC",
869     "ChangeGC",
870     "CopyGC",
871     "SetDashes",
872     "SetClipRectangles",
873     "FreeGC",
874     "ClearArea",
875     "CopyArea",
876     "CopyPlane",
877     "PolyPoint",
878     "PolyLine",
879     "PolySegment",
880     "PolyRectangle",
881     "PolyArc",
882     "FillPoly",
883     "PolyFillRectangle",
884     "PolyFillArc",
885     "PutImage",
886     "GetImage",
887     "PolyText8",
888     "PolyText16",
889     "ImageText8",
890     "ImageText16",
891     "CreateColormap",
892     "FreeColormap",
893     "CopyColormapAndFree",
894     "InstallColormap",
895     "UninstallColormap",
896     "ListInstalledColormaps",
897     "AllocColor",
898     "AllocNamedColor",
899     "AllocColorCells",
900     "AllocColorPlanes",
901     "FreeColors",
902     "StoreColors",
903     "StoreNamedColor",
904     "QueryColors",
905     "LookupColor",
906     "CreateCursor",
907     "CreateGlyphCursor",
908     "FreeCursor",
909     "RecolorCursor",
910     "QueryBestSize",
911     "QueryExtension",
912     "ListExtensions",
913     "ChangeKeyboardMapping",
914     "GetKeyboardMapping",
915     "ChangeKeyboardControl",
916     "GetKeyboardControl",
917     "Bell",
918     "ChangePointerControl",
919     "GetPointerControl",
920     "SetScreenSaver",
921     "GetScreenSaver",
922     "ChangeHosts",
923     "ListHosts",
924     "SetAccessControl",
925     "SetCloseDownMode",
926     "KillClient",
927     "RotateProperties",
928     "ForceScreenSaver",
929     "SetPointerMapping",
930     "GetPointerMapping",
931     "SetModifierMapping",
932     "GetModifierMapping",
933     "Unknown"
934 };
935 
936 #ifdef Q_XCB_DEBUG
937 void QXcbConnection::log(const char *file, int line, int sequence)
938 {
939     QMutexLocker locker(&m_callLogMutex);
940     CallInfo info;
941     info.sequence = sequence;
942     info.file = file;
943     info.line = line;
944     m_callLog << info;
945 }
946 #endif
947 
948 void QXcbConnection::handleXcbError(xcb_generic_error_t *error)
949 {
950     long result = 0;
951     QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();
952     if (dispatcher && dispatcher->filterNativeEvent(m_nativeInterface->genericEventFilterType(), error, &result))
953         return;
954 
955     uint clamped_error_code = qMin<uint>(error->error_code, (sizeof(xcb_errors) / sizeof(xcb_errors[0])) - 1);
956     uint clamped_major_code = qMin<uint>(error->major_code, (sizeof(xcb_protocol_request_codes) / sizeof(xcb_protocol_request_codes[0])) - 1);
957 
958     qWarning("QXcbConnection: XCB error: %d (%s), sequence: %d, resource id: %d, major code: %d (%s), minor code: %d",
959            int(error->error_code), xcb_errors[clamped_error_code],
960            int(error->sequence), int(error->resource_id),
961            int(error->major_code), xcb_protocol_request_codes[clamped_major_code],
962            int(error->minor_code));
963 #ifdef Q_XCB_DEBUG
964     QMutexLocker locker(&m_callLogMutex);
965     int i = 0;
966     for (; i < m_callLog.size(); ++i) {
967         if (m_callLog.at(i).sequence == error->sequence) {
968             qDebug("Caused by: %s:%d", m_callLog.at(i).file.constData(), m_callLog.at(i).line);
969             break;
970         } else if (m_callLog.at(i).sequence > error->sequence) {
971             qDebug("Caused some time before: %s:%d", m_callLog.at(i).file.constData(),
972                    m_callLog.at(i).line);
973             if (i > 0)
974                 qDebug("and after: %s:%d", m_callLog.at(i-1).file.constData(),
975                        m_callLog.at(i-1).line);
976             break;
977         }
978     }
979     if (i == m_callLog.size() && !m_callLog.isEmpty())
980         qDebug("Caused some time after: %s:%d", m_callLog.first().file.constData(),
981                m_callLog.first().line);
982 #endif
983 }
984 
985 static Qt::MouseButtons translateMouseButtons(int s)
986 {
987     Qt::MouseButtons ret = 0;
988     if (s & XCB_BUTTON_MASK_1)
989         ret |= Qt::LeftButton;
990     if (s & XCB_BUTTON_MASK_2)
991         ret |= Qt::MidButton;
992     if (s & XCB_BUTTON_MASK_3)
993         ret |= Qt::RightButton;
994     return ret;
995 }
996 
997 Qt::MouseButton QXcbConnection::translateMouseButton(xcb_button_t s)
998 {
999     switch (s) {
1000     case 1: return Qt::LeftButton;
1001     case 2: return Qt::MidButton;
1002     case 3: return Qt::RightButton;
1003     // Button values 4-7 were already handled as Wheel events, and won't occur here.
1004     case 8: return Qt::BackButton;      // Also known as Qt::ExtraButton1
1005     case 9: return Qt::ForwardButton;   // Also known as Qt::ExtraButton2
1006     case 10: return Qt::ExtraButton3;
1007     case 11: return Qt::ExtraButton4;
1008     case 12: return Qt::ExtraButton5;
1009     case 13: return Qt::ExtraButton6;
1010     case 14: return Qt::ExtraButton7;
1011     case 15: return Qt::ExtraButton8;
1012     case 16: return Qt::ExtraButton9;
1013     case 17: return Qt::ExtraButton10;
1014     case 18: return Qt::ExtraButton11;
1015     case 19: return Qt::ExtraButton12;
1016     case 20: return Qt::ExtraButton13;
1017     case 21: return Qt::ExtraButton14;
1018     case 22: return Qt::ExtraButton15;
1019     case 23: return Qt::ExtraButton16;
1020     case 24: return Qt::ExtraButton17;
1021     case 25: return Qt::ExtraButton18;
1022     case 26: return Qt::ExtraButton19;
1023     case 27: return Qt::ExtraButton20;
1024     case 28: return Qt::ExtraButton21;
1025     case 29: return Qt::ExtraButton22;
1026     case 30: return Qt::ExtraButton23;
1027     case 31: return Qt::ExtraButton24;
1028     default: return Qt::NoButton;
1029     }
1030 }
1031 
1032 #ifndef QT_NO_XKB
1033 namespace {
1034     typedef union {
1035         /* All XKB events share these fields. */
1036         struct {
1037             uint8_t response_type;
1038             uint8_t xkbType;
1039             uint16_t sequence;
1040             xcb_timestamp_t time;
1041             uint8_t deviceID;
1042         } any;
1043         xcb_xkb_new_keyboard_notify_event_t new_keyboard_notify;
1044         xcb_xkb_map_notify_event_t map_notify;
1045         xcb_xkb_state_notify_event_t state_notify;
1046     } _xkb_event;
1047 }
1048 #endif
1049 
1050 void QXcbConnection::handleXcbEvent(xcb_generic_event_t *event)
1051 {
1052 #ifdef Q_XCB_DEBUG
1053     {
1054         QMutexLocker locker(&m_callLogMutex);
1055         int i = 0;
1056         for (; i < m_callLog.size(); ++i)
1057             if (m_callLog.at(i).sequence >= event->sequence)
1058                 break;
1059         m_callLog.remove(0, i);
1060     }
1061 #endif
1062 
1063     long result = 0;
1064     QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();
1065     bool handled = dispatcher && dispatcher->filterNativeEvent(m_nativeInterface->genericEventFilterType(), event, &result);
1066 
1067     uint response_type = event->response_type & ~0x80;
1068 
1069     if (!handled) {
1070         switch (response_type) {
1071         case XCB_EXPOSE:
1072             HANDLE_PLATFORM_WINDOW_EVENT(xcb_expose_event_t, window, handleExposeEvent);
1073 
1074         // press/release/motion is only delivered here when XI 2.2+ is _not_ in use
1075         case XCB_BUTTON_PRESS: {
1076             xcb_button_press_event_t *ev = (xcb_button_press_event_t *)event;
1077             m_keyboard->updateXKBStateFromCore(ev->state);
1078             // the event explicitly contains the state of the three first buttons,
1079             // the rest we need to manage ourselves
1080             m_buttons = (m_buttons & ~0x7) | translateMouseButtons(ev->state);
1081             m_buttons |= translateMouseButton(ev->detail);
1082             qCDebug(lcQpaXInput, "legacy mouse press, button %d state %X", ev->detail, static_cast<unsigned int>(m_buttons));
1083             HANDLE_PLATFORM_WINDOW_EVENT(xcb_button_press_event_t, event, handleButtonPressEvent);
1084         }
1085         case XCB_BUTTON_RELEASE: {
1086             xcb_button_release_event_t *ev = (xcb_button_release_event_t *)event;
1087             m_keyboard->updateXKBStateFromCore(ev->state);
1088             m_buttons = (m_buttons & ~0x7) | translateMouseButtons(ev->state);
1089             m_buttons &= ~translateMouseButton(ev->detail);
1090             qCDebug(lcQpaXInput, "legacy mouse release, button %d state %X", ev->detail, static_cast<unsigned int>(m_buttons));
1091             HANDLE_PLATFORM_WINDOW_EVENT(xcb_button_release_event_t, event, handleButtonReleaseEvent);
1092         }
1093         case XCB_MOTION_NOTIFY: {
1094             xcb_motion_notify_event_t *ev = (xcb_motion_notify_event_t *)event;
1095             m_keyboard->updateXKBStateFromCore(ev->state);
1096             m_buttons = (m_buttons & ~0x7) | translateMouseButtons(ev->state);
1097             qCDebug(lcQpaXInput, "legacy mouse move %d,%d button %d state %X", ev->event_x, ev->event_y,
1098                     ev->detail, static_cast<unsigned int>(m_buttons));
1099             HANDLE_PLATFORM_WINDOW_EVENT(xcb_motion_notify_event_t, event, handleMotionNotifyEvent);
1100         }
1101 
1102         case XCB_CONFIGURE_NOTIFY:
1103             HANDLE_PLATFORM_WINDOW_EVENT(xcb_configure_notify_event_t, event, handleConfigureNotifyEvent);
1104         case XCB_MAP_NOTIFY:
1105             HANDLE_PLATFORM_WINDOW_EVENT(xcb_map_notify_event_t, event, handleMapNotifyEvent);
1106         case XCB_UNMAP_NOTIFY:
1107             HANDLE_PLATFORM_WINDOW_EVENT(xcb_unmap_notify_event_t, event, handleUnmapNotifyEvent);
1108         case XCB_DESTROY_NOTIFY:
1109             HANDLE_PLATFORM_WINDOW_EVENT(xcb_destroy_notify_event_t, event, handleDestroyNotifyEvent);
1110         case XCB_CLIENT_MESSAGE:
1111             handleClientMessageEvent((xcb_client_message_event_t *)event);
1112             break;
1113         case XCB_ENTER_NOTIFY:
1114             HANDLE_PLATFORM_WINDOW_EVENT(xcb_enter_notify_event_t, event, handleEnterNotifyEvent);
1115         case XCB_LEAVE_NOTIFY:
1116             m_keyboard->updateXKBStateFromCore(((xcb_leave_notify_event_t *)event)->state);
1117             HANDLE_PLATFORM_WINDOW_EVENT(xcb_leave_notify_event_t, event, handleLeaveNotifyEvent);
1118         case XCB_FOCUS_IN:
1119             HANDLE_PLATFORM_WINDOW_EVENT(xcb_focus_in_event_t, event, handleFocusInEvent);
1120         case XCB_FOCUS_OUT:
1121             HANDLE_PLATFORM_WINDOW_EVENT(xcb_focus_out_event_t, event, handleFocusOutEvent);
1122         case XCB_KEY_PRESS:
1123         {
1124             xcb_key_press_event_t *kp = (xcb_key_press_event_t *)event;
1125             m_keyboard->updateXKBStateFromCore(kp->state);
1126             setTime(kp->time);
1127             HANDLE_KEYBOARD_EVENT(xcb_key_press_event_t, handleKeyPressEvent);
1128         }
1129         case XCB_KEY_RELEASE:
1130             m_keyboard->updateXKBStateFromCore(((xcb_key_release_event_t *)event)->state);
1131             HANDLE_KEYBOARD_EVENT(xcb_key_release_event_t, handleKeyReleaseEvent);
1132         case XCB_MAPPING_NOTIFY:
1133             m_keyboard->handleMappingNotifyEvent((xcb_mapping_notify_event_t *)event);
1134             break;
1135         case XCB_SELECTION_REQUEST:
1136         {
1137             xcb_selection_request_event_t *sr = (xcb_selection_request_event_t *)event;
1138 #ifndef QT_NO_DRAGANDDROP
1139             if (sr->selection == atom(QXcbAtom::XdndSelection))
1140                 m_drag->handleSelectionRequest(sr);
1141             else
1142 #endif
1143             {
1144 #ifndef QT_NO_CLIPBOARD
1145                 m_clipboard->handleSelectionRequest(sr);
1146 #endif
1147             }
1148             break;
1149         }
1150         case XCB_SELECTION_CLEAR:
1151             setTime(((xcb_selection_clear_event_t *)event)->time);
1152 #ifndef QT_NO_CLIPBOARD
1153             m_clipboard->handleSelectionClearRequest((xcb_selection_clear_event_t *)event);
1154 #endif
1155             handled = true;
1156             break;
1157         case XCB_SELECTION_NOTIFY:
1158             setTime(((xcb_selection_notify_event_t *)event)->time);
1159             handled = false;
1160             break;
1161         case XCB_PROPERTY_NOTIFY:
1162         {
1163             xcb_property_notify_event_t *pn = (xcb_property_notify_event_t *)event;
1164             if (pn->atom == atom(QXcbAtom::_NET_WORKAREA)) {
1165                 QXcbVirtualDesktop *virtualDesktop = virtualDesktopForRootWindow(pn->window);
1166                 if (virtualDesktop)
1167                     virtualDesktop->updateWorkArea();
1168             } else {
1169                 HANDLE_PLATFORM_WINDOW_EVENT(xcb_property_notify_event_t, window, handlePropertyNotifyEvent);
1170             }
1171             break;
1172         }
1173 #if defined(XCB_USE_XINPUT2)
1174         case XCB_GE_GENERIC:
1175             // Here the windowEventListener is invoked from xi2HandleEvent()
1176             if (m_xi2Enabled && isXIEvent(event, m_xiOpCode))
1177                 xi2HandleEvent(reinterpret_cast<xcb_ge_event_t *>(event));
1178             break;
1179 #endif
1180         default:
1181             handled = false;
1182             break;
1183         }
1184     }
1185 
1186     if (!handled) {
1187         if (response_type == xfixes_first_event + XCB_XFIXES_SELECTION_NOTIFY) {
1188             xcb_xfixes_selection_notify_event_t *notify_event = (xcb_xfixes_selection_notify_event_t *)event;
1189             setTime(notify_event->timestamp);
1190 #ifndef QT_NO_CLIPBOARD
1191             m_clipboard->handleXFixesSelectionRequest(notify_event);
1192 #endif
1193             foreach (QXcbVirtualDesktop *virtualDesktop, m_virtualDesktops)
1194                 virtualDesktop->handleXFixesSelectionNotify(notify_event);
1195 
1196             handled = true;
1197         } else if (has_randr_extension && response_type == xrandr_first_event + XCB_RANDR_NOTIFY) {
1198             updateScreens((xcb_randr_notify_event_t *)event);
1199             handled = true;
1200         } else if (has_randr_extension && response_type == xrandr_first_event + XCB_RANDR_SCREEN_CHANGE_NOTIFY) {
1201             xcb_randr_screen_change_notify_event_t *change_event = (xcb_randr_screen_change_notify_event_t *)event;
1202             foreach (QXcbScreen *s, m_screens) {
1203                 if (s->root() == change_event->root )
1204                     s->handleScreenChange(change_event);
1205             }
1206             handled = true;
1207 #ifndef QT_NO_XKB
1208         } else if (response_type == xkb_first_event) { // https://bugs.freedesktop.org/show_bug.cgi?id=51295
1209             _xkb_event *xkb_event = reinterpret_cast<_xkb_event *>(event);
1210             if (xkb_event->any.deviceID == m_keyboard->coreDeviceId()) {
1211                 switch (xkb_event->any.xkbType) {
1212                     // XkbNewKkdNotify and XkbMapNotify together capture all sorts of keymap
1213                     // updates (e.g. xmodmap, xkbcomp, setxkbmap), with minimal redundent recompilations.
1214                     case XCB_XKB_STATE_NOTIFY:
1215                         m_keyboard->updateXKBState(&xkb_event->state_notify);
1216                         handled = true;
1217                         break;
1218                     case XCB_XKB_MAP_NOTIFY:
1219                         m_keyboard->handleMappingNotifyEvent(&xkb_event->map_notify);
1220                         handled = true;
1221                         break;
1222                     case XCB_XKB_NEW_KEYBOARD_NOTIFY: {
1223                         xcb_xkb_new_keyboard_notify_event_t *ev = &xkb_event->new_keyboard_notify;
1224                         if (ev->changed & XCB_XKB_NKN_DETAIL_KEYCODES)
1225                             m_keyboard->updateKeymap();
1226                         break;
1227                     }
1228                     default:
1229                         break;
1230                 }
1231             }
1232 #endif
1233         }
1234     }
1235 
1236     if (!handled && m_glIntegration)
1237         handled = m_glIntegration->handleXcbEvent(event, response_type);
1238 
1239     if (handled)
1240         printXcbEvent("Handled XCB event", event);
1241     else
1242         printXcbEvent("Unhandled XCB event", event);
1243 }
1244 
1245 void QXcbConnection::addPeekFunc(PeekFunc f)
1246 {
1247     m_peekFuncs.append(f);
1248 }
1249 
1250 QXcbEventReader::QXcbEventReader(QXcbConnection *connection)
1251     : m_connection(connection)
1252     , m_mainThreadAccessedEventQueue(false)
1253 {
1254     checkXcbPollForQueuedEvent();
1255 }
1256 
1257 void QXcbEventReader::start()
1258 {
1259     if (local_xcb_poll_for_queued_event) {
1260         connect(this, SIGNAL(eventPending()), m_connection, SLOT(processXcbEvents()), Qt::QueuedConnection);
1261         connect(this, SIGNAL(finished()), m_connection, SLOT(processXcbEvents()));
1262         QThread::start();
1263     } else {
1264         // Must be done after we have an event-dispatcher. By posting a method invocation
1265         // we are sure that by the time the method is called we have an event-dispatcher.
1266         QMetaObject::invokeMethod(this, "registerForEvents", Qt::QueuedConnection);
1267     }
1268 }
1269 
1270 void QXcbEventReader::registerForEvents()
1271 {
1272     QSocketNotifier *notifier = new QSocketNotifier(xcb_get_file_descriptor(m_connection->xcb_connection()), QSocketNotifier::Read, this);
1273     connect(notifier, SIGNAL(activated(int)), m_connection, SLOT(processXcbEvents()));
1274 
1275     QAbstractEventDispatcher *dispatcher = QGuiApplicationPrivate::eventDispatcher;
1276     connect(dispatcher, SIGNAL(aboutToBlock()), m_connection, SLOT(processXcbEvents()));
1277     connect(dispatcher, SIGNAL(awake()), m_connection, SLOT(processXcbEvents()));
1278 }
1279 
1280 void QXcbEventReader::registerEventDispatcher(QAbstractEventDispatcher *dispatcher)
1281 {
1282     // flush the xcb connection before the EventDispatcher is going to block
1283     // In the non-threaded case processXcbEvents is called before going to block,
1284     // which flushes the connection.
1285     if (local_xcb_poll_for_queued_event)
1286         connect(dispatcher, SIGNAL(aboutToBlock()), m_connection, SLOT(flush()));
1287 }
1288 
1289 void QXcbEventReader::run()
1290 {
1291     xcb_generic_event_t *event;
1292     while (m_connection && (event = xcb_wait_for_event(m_connection->xcb_connection()))) {
1293         m_mutex.lock();
1294         addEvent(event);
1295         while (m_connection && (event = local_xcb_poll_for_queued_event(m_connection->xcb_connection())))
1296             addEvent(event);
1297         m_mutex.unlock();
1298         emit eventPending();
1299     }
1300 
1301     m_mutex.lock();
1302     for (int i = 0; i < m_events.size(); ++i)
1303         free(m_events.at(i));
1304     m_events.clear();
1305     m_mutex.unlock();
1306 }
1307 
1308 void QXcbEventReader::addEvent(xcb_generic_event_t *event)
1309 {
1310     if ((event->response_type & ~0x80) == XCB_CLIENT_MESSAGE
1311         && ((xcb_client_message_event_t *)event)->type == m_connection->atom(QXcbAtom::_QT_CLOSE_CONNECTION))
1312         m_connection = 0;
1313     m_events << event;
1314 }
1315 
1316 QXcbEventArray *QXcbEventReader::lock(bool calledFromPeeker)
1317 {
1318     m_mutex.lock();
1319     if (!calledFromPeeker)
1320         m_mainThreadAccessedEventQueue = true;
1321     if (!local_xcb_poll_for_queued_event) {
1322         while (xcb_generic_event_t *event = xcb_poll_for_event(m_connection->xcb_connection()))
1323             m_events << event;
1324     }
1325     return &m_events;
1326 }
1327 
1328 void QXcbEventReader::unlock(bool calledFromPeeker)
1329 {
1330     m_mutex.unlock();
1331     if (calledFromPeeker)
1332         m_mainThreadAccessedEventQueue = false;
1333 }
1334 
1335 void QXcbConnection::setFocusWindow(QXcbWindow *w)
1336 {
1337     m_focusWindow = w;
1338 }
1339 
1340 void QXcbConnection::grabServer()
1341 {
1342     if (m_canGrabServer)
1343         xcb_grab_server(m_connection);
1344 }
1345 
1346 void QXcbConnection::ungrabServer()
1347 {
1348     if (m_canGrabServer)
1349         xcb_ungrab_server(m_connection);
1350 }
1351 
1352 void QXcbConnection::sendConnectionEvent(QXcbAtom::Atom a, uint id)
1353 {
1354     xcb_client_message_event_t event;
1355     memset(&event, 0, sizeof(event));
1356 
1357     const xcb_window_t eventListener = xcb_generate_id(m_connection);
1358     xcb_screen_iterator_t it = xcb_setup_roots_iterator(m_setup);
1359     xcb_screen_t *screen = it.data;
1360     Q_XCB_CALL(xcb_create_window(m_connection, XCB_COPY_FROM_PARENT,
1361                                  eventListener, screen->root,
1362                                  0, 0, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY,
1363                                  screen->root_visual, 0, 0));
1364 
1365     event.response_type = XCB_CLIENT_MESSAGE;
1366     event.format = 32;
1367     event.sequence = 0;
1368     event.window = eventListener;
1369     event.type = atom(a);
1370     event.data.data32[0] = id;
1371 
1372     Q_XCB_CALL(xcb_send_event(xcb_connection(), false, eventListener, XCB_EVENT_MASK_NO_EVENT, (const char *)&event));
1373     Q_XCB_CALL(xcb_destroy_window(m_connection, eventListener));
1374     xcb_flush(xcb_connection());
1375 }
1376 
1377 namespace
1378 {
1379     class PropertyNotifyEvent {
1380     public:
1381         PropertyNotifyEvent(xcb_window_t win, xcb_atom_t property)
1382             : window(win), type(XCB_PROPERTY_NOTIFY), atom(property) {}
1383         xcb_window_t window;
1384         int type;
1385         xcb_atom_t atom;
1386         bool checkEvent(xcb_generic_event_t *event) const {
1387             if (!event)
1388                 return false;
1389             if ((event->response_type & ~0x80) != type) {
1390                 return false;
1391             } else {
1392                 xcb_property_notify_event_t *pn = (xcb_property_notify_event_t *)event;
1393                 if ((pn->window == window) && (pn->atom == atom))
1394                     return true;
1395             }
1396             return false;
1397         }
1398     };
1399 }
1400 
1401 xcb_timestamp_t QXcbConnection::getTimestamp()
1402 {
1403     // send a dummy event to myself to get the timestamp from X server.
1404     xcb_window_t root_win = rootWindow();
1405     xcb_change_property(xcb_connection(), XCB_PROP_MODE_APPEND, root_win, atom(QXcbAtom::CLIP_TEMPORARY),
1406                         XCB_ATOM_INTEGER, 32, 0, NULL);
1407 
1408     connection()->flush();
1409     PropertyNotifyEvent checker(root_win, atom(QXcbAtom::CLIP_TEMPORARY));
1410 
1411     xcb_generic_event_t *event = 0;
1412     // lets keep this inside a loop to avoid a possible race condition, where
1413     // reader thread has not yet had the time to acquire the mutex in order
1414     // to add the new set of events to its event queue
1415     while (!event) {
1416         connection()->sync();
1417         event = checkEvent(checker);
1418     }
1419 
1420     xcb_property_notify_event_t *pn = (xcb_property_notify_event_t *)event;
1421     xcb_timestamp_t timestamp = pn->time;
1422     free(event);
1423 
1424     xcb_delete_property(xcb_connection(), root_win, atom(QXcbAtom::CLIP_TEMPORARY));
1425 
1426     return timestamp;
1427 }
1428 
1429 xcb_window_t QXcbConnection::getSelectionOwner(xcb_atom_t atom) const
1430 {
1431     xcb_connection_t *c = xcb_connection();
1432     xcb_get_selection_owner_cookie_t cookie = xcb_get_selection_owner(c, atom);
1433     xcb_get_selection_owner_reply_t *reply;
1434     reply = xcb_get_selection_owner_reply(c, cookie, 0);
1435     xcb_window_t win = reply->owner;
1436     free(reply);
1437     return win;
1438 }
1439 
1440 xcb_window_t QXcbConnection::getQtSelectionOwner()
1441 {
1442     if (!m_qtSelectionOwner) {
1443         xcb_screen_t *xcbScreen = primaryVirtualDesktop()->screen();
1444         int x = 0, y = 0, w = 3, h = 3;
1445         m_qtSelectionOwner = xcb_generate_id(xcb_connection());
1446         Q_XCB_CALL(xcb_create_window(xcb_connection(),
1447                                      XCB_COPY_FROM_PARENT,               // depth -- same as root
1448                                      m_qtSelectionOwner,                 // window id
1449                                      xcbScreen->root,                    // parent window id
1450                                      x, y, w, h,
1451                                      0,                                  // border width
1452                                      XCB_WINDOW_CLASS_INPUT_OUTPUT,      // window class
1453                                      xcbScreen->root_visual,             // visual
1454                                      0,                                  // value mask
1455                                      0));                                // value list
1456     }
1457     return m_qtSelectionOwner;
1458 }
1459 
1460 xcb_window_t QXcbConnection::rootWindow()
1461 {
1462     QXcbScreen *s = primaryScreen();
1463     return s ? s->root() : 0;
1464 }
1465 
1466 xcb_window_t QXcbConnection::clientLeader()
1467 {
1468     if (m_clientLeader == 0) {
1469         m_clientLeader = xcb_generate_id(xcb_connection());
1470         QXcbScreen *screen = primaryScreen();
1471         Q_XCB_CALL(xcb_create_window(xcb_connection(),
1472                                      XCB_COPY_FROM_PARENT,
1473                                      m_clientLeader,
1474                                      screen->root(),
1475                                      0, 0, 1, 1,
1476                                      0,
1477                                      XCB_WINDOW_CLASS_INPUT_OUTPUT,
1478                                      screen->screen()->root_visual,
1479                                      0, 0));
1480 #ifndef QT_NO_DEBUG
1481         QByteArray ba("Qt client leader window");
1482         Q_XCB_CALL(xcb_change_property(xcb_connection(),
1483                                        XCB_PROP_MODE_REPLACE,
1484                                        m_clientLeader,
1485                                        atom(QXcbAtom::_NET_WM_NAME),
1486                                        atom(QXcbAtom::UTF8_STRING),
1487                                        8,
1488                                        ba.length(),
1489                                        ba.constData()));
1490 #endif
1491         Q_XCB_CALL(xcb_change_property(xcb_connection(),
1492                                        XCB_PROP_MODE_REPLACE,
1493                                        m_clientLeader,
1494                                        atom(QXcbAtom::WM_CLIENT_LEADER),
1495                                        XCB_ATOM_WINDOW,
1496                                        32,
1497                                        1,
1498                                        &m_clientLeader));
1499 
1500 #if !defined(QT_NO_SESSIONMANAGER) && defined(XCB_USE_SM)
1501         // If we are session managed, inform the window manager about it
1502         QByteArray session = qGuiApp->sessionId().toLatin1();
1503         if (!session.isEmpty()) {
1504             Q_XCB_CALL(xcb_change_property(xcb_connection(),
1505                                            XCB_PROP_MODE_REPLACE,
1506                                            m_clientLeader,
1507                                            atom(QXcbAtom::SM_CLIENT_ID),
1508                                            XCB_ATOM_STRING,
1509                                            8,
1510                                            session.length(),
1511                                            session.constData()));
1512         }
1513 #endif
1514     }
1515     return m_clientLeader;
1516 }
1517 
1518 #ifdef XCB_USE_XLIB
1519 void *QXcbConnection::xlib_display() const
1520 {
1521     return m_xlib_display;
1522 }
1523 
1524 void *QXcbConnection::createVisualInfoForDefaultVisualId() const
1525 {
1526     if (m_defaultVisualId == UINT_MAX)
1527         return 0;
1528     XVisualInfo info;
1529     memset(&info, 0, sizeof info);
1530     info.visualid = m_defaultVisualId;
1531 
1532     int count = 0;
1533     XVisualInfo *retVisual = XGetVisualInfo(DISPLAY_FROM_XCB(this), VisualIDMask, &info, &count);
1534     Q_ASSERT(count < 2);
1535     return retVisual;
1536 }
1537 
1538 #endif
1539 
1540 bool QXcbConnection::peekEventQueue(PeekQueueFunc peekFunction, bool fromStart, bool remove)
1541 {
1542     bool isQueued = false;
1543     QXcbEventArray *eventqueue = m_reader->lock(true);
1544     int i;
1545     if (fromStart) {
1546         i = 0;
1547     } else {
1548         static int prevSize = 0;
1549         i = m_reader->mainThreadAccessedEventQueue() ? 0 : prevSize;
1550         prevSize = eventqueue->size();
1551     }
1552 
1553     for (; i < eventqueue->size(); ++i) {
1554         xcb_generic_event_t *event = eventqueue->at(i);
1555         if (!event)
1556             continue;
1557         isQueued = peekFunction(event);
1558         if (isQueued) {
1559             if (remove) {
1560                 free(event);
1561                 (*eventqueue)[i] = 0;
1562             }
1563             break;
1564         }
1565     }
1566 
1567     m_reader->unlock(true);
1568     return isQueued;
1569 }
1570 
1571 #if defined(XCB_USE_XINPUT2)
1572 // it is safe to cast XI_* events here as long as we are only touching the first 32 bytes,
1573 // after that position event needs memmove, see xi2PrepareXIGenericDeviceEvent
1574 static inline bool isXIType(xcb_generic_event_t *event, int opCode, uint16_t type)
1575 {
1576     if (!isXIEvent(event, opCode))
1577         return false;
1578 
1579     xXIGenericDeviceEvent *xiEvent = reinterpret_cast<xXIGenericDeviceEvent *>(event);
1580     return xiEvent->evtype == type;
1581 }
1582 #endif
1583 static inline bool isValid(xcb_generic_event_t *event)
1584 {
1585     return event && (event->response_type & ~0x80);
1586 }
1587 
1588 /*! \internal
1589 
1590     Compresses events of the same type to avoid swamping the event queue.
1591     If event compression is not desired there are several options what developers can do:
1592 
1593     1) Write responsive applications. We drop events that have been buffered in the event
1594        queue while waiting on unresponsive GUI thread.
1595     2) Use QAbstractNativeEventFilter to get all events from X connection. This is not optimal
1596        because it requires working with native event types.
1597     3) Or add public API to Qt for disabling event compression QTBUG-44964
1598 
1599 */
1600 bool QXcbConnection::compressEvent(xcb_generic_event_t *event, int currentIndex, QXcbEventArray *eventqueue) const
1601 {
1602     uint responseType = event->response_type & ~0x80;
1603     int nextIndex = currentIndex + 1;
1604 
1605     if (responseType == XCB_MOTION_NOTIFY) {
1606         // compress XCB_MOTION_NOTIFY notify events
1607         for (int j = nextIndex; j < eventqueue->size(); ++j) {
1608             xcb_generic_event_t *next = eventqueue->at(j);
1609             if (!isValid(next))
1610                 continue;
1611             if (next->response_type == XCB_MOTION_NOTIFY)
1612                 return true;
1613         }
1614         return false;
1615     }
1616 #if defined(XCB_USE_XINPUT2)
1617     // compress XI_* events
1618     if (responseType == XCB_GE_GENERIC) {
1619         if (!m_xi2Enabled)
1620             return false;
1621 
1622         // compress XI_Motion
1623         if (isXIType(event, m_xiOpCode, XI_Motion)) {
1624             for (int j = nextIndex; j < eventqueue->size(); ++j) {
1625                 xcb_generic_event_t *next = eventqueue->at(j);
1626                 if (!isValid(next))
1627                     continue;
1628                 if (isXIType(next, m_xiOpCode, XI_Motion))
1629                     return true;
1630             }
1631             return false;
1632         }
1633 #ifdef XCB_USE_XINPUT22
1634         // compress XI_TouchUpdate for the same touch point id
1635         if (isXIType(event, m_xiOpCode, XI_TouchUpdate)) {
1636             xXIDeviceEvent *xiDeviceEvent = reinterpret_cast<xXIDeviceEvent *>(event);
1637             uint32_t id = xiDeviceEvent->detail % INT_MAX;
1638             for (int j = nextIndex; j < eventqueue->size(); ++j) {
1639                 xcb_generic_event_t *next = eventqueue->at(j);
1640                 if (!isValid(next))
1641                     continue;
1642                 if (isXIType(next, m_xiOpCode, XI_TouchUpdate)) {
1643                     xXIDeviceEvent *xiDeviceNextEvent = reinterpret_cast<xXIDeviceEvent *>(next);
1644                     if (id == xiDeviceNextEvent->detail % INT_MAX)
1645                         return true;
1646                 }
1647             }
1648             return false;
1649         }
1650 #endif
1651         return false;
1652     }
1653 #endif
1654     if (responseType == XCB_CONFIGURE_NOTIFY) {
1655         // compress multiple configure notify events for the same window
1656         for (int j = nextIndex; j < eventqueue->size(); ++j) {
1657             xcb_generic_event_t *next = eventqueue->at(j);
1658             if (isValid(next) && next->response_type == XCB_CONFIGURE_NOTIFY
1659                 && ((xcb_configure_notify_event_t *)next)->event == ((xcb_configure_notify_event_t*)event)->event)
1660             {
1661                 return true;
1662             }
1663         }
1664         return false;
1665     }
1666 
1667     return false;
1668 }
1669 
1670 void QXcbConnection::processXcbEvents()
1671 {
1672     int connection_error = xcb_connection_has_error(xcb_connection());
1673     if (connection_error) {
1674         qWarning("The X11 connection broke (error %d). Did the X11 server die?", connection_error);
1675         exit(1);
1676     }
1677 
1678     QXcbEventArray *eventqueue = m_reader->lock();
1679 
1680     for (int i = 0; i < eventqueue->size(); ++i) {
1681         xcb_generic_event_t *event = eventqueue->at(i);
1682         if (!event)
1683             continue;
1684         QScopedPointer<xcb_generic_event_t, QScopedPointerPodDeleter> eventGuard(event);
1685         (*eventqueue)[i] = 0;
1686 
1687         if (!(event->response_type & ~0x80)) {
1688             handleXcbError((xcb_generic_error_t *)event);
1689             continue;
1690         }
1691 
1692         if (compressEvent(event, i, eventqueue))
1693             continue;
1694 
1695         bool accepted = false;
1696         if (clipboard()->processIncr())
1697             clipboard()->incrTransactionPeeker(event, accepted);
1698         if (accepted)
1699             continue;
1700 
1701         QVector<PeekFunc>::iterator it = m_peekFuncs.begin();
1702         while (it != m_peekFuncs.end()) {
1703             // These callbacks return true if the event is what they were
1704             // waiting for, remove them from the list in that case.
1705             if ((*it)(this, event))
1706                 it = m_peekFuncs.erase(it);
1707             else
1708                 ++it;
1709         }
1710         m_reader->unlock();
1711         handleXcbEvent(event);
1712         m_reader->lock();
1713     }
1714 
1715     eventqueue->clear();
1716 
1717     m_reader->unlock();
1718 
1719     // Indicate with a null event that the event the callbacks are waiting for
1720     // is not in the queue currently.
1721     Q_FOREACH (PeekFunc f, m_peekFuncs)
1722         f(this, 0);
1723     m_peekFuncs.clear();
1724 
1725     xcb_flush(xcb_connection());
1726 }
1727 
1728 void QXcbConnection::handleClientMessageEvent(const xcb_client_message_event_t *event)
1729 {
1730     if (event->format != 32)
1731         return;
1732 
1733 #ifndef QT_NO_DRAGANDDROP
1734     if (event->type == atom(QXcbAtom::XdndStatus)) {
1735         drag()->handleStatus(event);
1736     } else if (event->type == atom(QXcbAtom::XdndFinished)) {
1737         drag()->handleFinished(event);
1738     }
1739 #endif
1740     if (m_systemTrayTracker && event->type == atom(QXcbAtom::MANAGER))
1741         m_systemTrayTracker->notifyManagerClientMessageEvent(event);
1742 
1743     QXcbWindow *window = platformWindowFromId(event->window);
1744     if (!window)
1745         return;
1746 
1747     window->handleClientMessageEvent(event);
1748 }
1749 
1750 xcb_generic_event_t *QXcbConnection::checkEvent(int type)
1751 {
1752     QXcbEventArray *eventqueue = m_reader->lock();
1753 
1754     for (int i = 0; i < eventqueue->size(); ++i) {
1755         xcb_generic_event_t *event = eventqueue->at(i);
1756         if (event && event->response_type == type) {
1757             (*eventqueue)[i] = 0;
1758             m_reader->unlock();
1759             return event;
1760         }
1761     }
1762 
1763     m_reader->unlock();
1764 
1765     return 0;
1766 }
1767 
1768 static const char * xcb_atomnames = {
1769     // window-manager <-> client protocols
1770     "WM_PROTOCOLS\0"
1771     "WM_DELETE_WINDOW\0"
1772     "WM_TAKE_FOCUS\0"
1773     "_NET_WM_PING\0"
1774     "_NET_WM_CONTEXT_HELP\0"
1775     "_NET_WM_SYNC_REQUEST\0"
1776     "_NET_WM_SYNC_REQUEST_COUNTER\0"
1777     "MANAGER\0"
1778     "_NET_SYSTEM_TRAY_OPCODE\0"
1779 
1780     // ICCCM window state
1781     "WM_STATE\0"
1782     "WM_CHANGE_STATE\0"
1783     "WM_CLASS\0"
1784     "WM_NAME\0"
1785 
1786     // Session management
1787     "WM_CLIENT_LEADER\0"
1788     "WM_WINDOW_ROLE\0"
1789     "SM_CLIENT_ID\0"
1790 
1791     // Clipboard
1792     "CLIPBOARD\0"
1793     "INCR\0"
1794     "TARGETS\0"
1795     "MULTIPLE\0"
1796     "TIMESTAMP\0"
1797     "SAVE_TARGETS\0"
1798     "CLIP_TEMPORARY\0"
1799     "_QT_SELECTION\0"
1800     "_QT_CLIPBOARD_SENTINEL\0"
1801     "_QT_SELECTION_SENTINEL\0"
1802     "CLIPBOARD_MANAGER\0"
1803 
1804     "RESOURCE_MANAGER\0"
1805 
1806     "_XSETROOT_ID\0"
1807 
1808     "_QT_SCROLL_DONE\0"
1809     "_QT_INPUT_ENCODING\0"
1810 
1811     "_QT_CLOSE_CONNECTION\0"
1812 
1813     "_MOTIF_WM_HINTS\0"
1814 
1815     "DTWM_IS_RUNNING\0"
1816     "ENLIGHTENMENT_DESKTOP\0"
1817     "_DT_SAVE_MODE\0"
1818     "_SGI_DESKS_MANAGER\0"
1819 
1820     // EWMH (aka NETWM)
1821     "_NET_SUPPORTED\0"
1822     "_NET_VIRTUAL_ROOTS\0"
1823     "_NET_WORKAREA\0"
1824 
1825     "_NET_MOVERESIZE_WINDOW\0"
1826     "_NET_WM_MOVERESIZE\0"
1827 
1828     "_NET_WM_NAME\0"
1829     "_NET_WM_ICON_NAME\0"
1830     "_NET_WM_ICON\0"
1831 
1832     "_NET_WM_PID\0"
1833 
1834     "_NET_WM_WINDOW_OPACITY\0"
1835 
1836     "_NET_WM_STATE\0"
1837     "_NET_WM_STATE_ABOVE\0"
1838     "_NET_WM_STATE_BELOW\0"
1839     "_NET_WM_STATE_FULLSCREEN\0"
1840     "_NET_WM_STATE_MAXIMIZED_HORZ\0"
1841     "_NET_WM_STATE_MAXIMIZED_VERT\0"
1842     "_NET_WM_STATE_MODAL\0"
1843     "_NET_WM_STATE_STAYS_ON_TOP\0"
1844     "_NET_WM_STATE_DEMANDS_ATTENTION\0"
1845 
1846     "_NET_WM_USER_TIME\0"
1847     "_NET_WM_USER_TIME_WINDOW\0"
1848     "_NET_WM_FULL_PLACEMENT\0"
1849 
1850     "_NET_WM_WINDOW_TYPE\0"
1851     "_NET_WM_WINDOW_TYPE_DESKTOP\0"
1852     "_NET_WM_WINDOW_TYPE_DOCK\0"
1853     "_NET_WM_WINDOW_TYPE_TOOLBAR\0"
1854     "_NET_WM_WINDOW_TYPE_MENU\0"
1855     "_NET_WM_WINDOW_TYPE_UTILITY\0"
1856     "_NET_WM_WINDOW_TYPE_SPLASH\0"
1857     "_NET_WM_WINDOW_TYPE_DIALOG\0"
1858     "_NET_WM_WINDOW_TYPE_DROPDOWN_MENU\0"
1859     "_NET_WM_WINDOW_TYPE_POPUP_MENU\0"
1860     "_NET_WM_WINDOW_TYPE_TOOLTIP\0"
1861     "_NET_WM_WINDOW_TYPE_NOTIFICATION\0"
1862     "_NET_WM_WINDOW_TYPE_COMBO\0"
1863     "_NET_WM_WINDOW_TYPE_DND\0"
1864     "_NET_WM_WINDOW_TYPE_NORMAL\0"
1865     "_KDE_NET_WM_WINDOW_TYPE_OVERRIDE\0"
1866 
1867     "_KDE_NET_WM_FRAME_STRUT\0"
1868     "_NET_FRAME_EXTENTS\0"
1869 
1870     "_NET_STARTUP_INFO\0"
1871     "_NET_STARTUP_INFO_BEGIN\0"
1872 
1873     "_NET_SUPPORTING_WM_CHECK\0"
1874 
1875     "_NET_WM_CM_S0\0"
1876 
1877     "_NET_SYSTEM_TRAY_VISUAL\0"
1878 
1879     "_NET_ACTIVE_WINDOW\0"
1880 
1881     // Property formats
1882     "TEXT\0"
1883     "UTF8_STRING\0"
1884     "CARDINAL\0"
1885 
1886     // xdnd
1887     "XdndEnter\0"
1888     "XdndPosition\0"
1889     "XdndStatus\0"
1890     "XdndLeave\0"
1891     "XdndDrop\0"
1892     "XdndFinished\0"
1893     "XdndTypeList\0"
1894     "XdndActionList\0"
1895 
1896     "XdndSelection\0"
1897 
1898     "XdndAware\0"
1899     "XdndProxy\0"
1900 
1901     "XdndActionCopy\0"
1902     "XdndActionLink\0"
1903     "XdndActionMove\0"
1904     "XdndActionPrivate\0"
1905 
1906     // Motif DND
1907     "_MOTIF_DRAG_AND_DROP_MESSAGE\0"
1908     "_MOTIF_DRAG_INITIATOR_INFO\0"
1909     "_MOTIF_DRAG_RECEIVER_INFO\0"
1910     "_MOTIF_DRAG_WINDOW\0"
1911     "_MOTIF_DRAG_TARGETS\0"
1912 
1913     "XmTRANSFER_SUCCESS\0"
1914     "XmTRANSFER_FAILURE\0"
1915 
1916     // Xkb
1917     "_XKB_RULES_NAMES\0"
1918 
1919     // XEMBED
1920     "_XEMBED\0"
1921     "_XEMBED_INFO\0"
1922 
1923     // XInput2
1924     "Button Left\0"
1925     "Button Middle\0"
1926     "Button Right\0"
1927     "Button Wheel Up\0"
1928     "Button Wheel Down\0"
1929     "Button Horiz Wheel Left\0"
1930     "Button Horiz Wheel Right\0"
1931     "Abs MT Position X\0"
1932     "Abs MT Position Y\0"
1933     "Abs MT Touch Major\0"
1934     "Abs MT Touch Minor\0"
1935     "Abs MT Pressure\0"
1936     "Abs MT Tracking ID\0"
1937     "Max Contacts\0"
1938     "Rel X\0"
1939     "Rel Y\0"
1940     // XInput2 tablet
1941     "Abs X\0"
1942     "Abs Y\0"
1943     "Abs Pressure\0"
1944     "Abs Tilt X\0"
1945     "Abs Tilt Y\0"
1946     "Abs Wheel\0"
1947     "Abs Distance\0"
1948     "Wacom Serial IDs\0"
1949     "INTEGER\0"
1950     "Rel Horiz Wheel\0"
1951     "Rel Vert Wheel\0"
1952     "Rel Horiz Scroll\0"
1953     "Rel Vert Scroll\0"
1954     "_XSETTINGS_SETTINGS\0"
1955     "_COMPIZ_DECOR_PENDING\0"
1956     "_COMPIZ_DECOR_REQUEST\0"
1957     "_COMPIZ_DECOR_DELETE_PIXMAP\0"
1958     "_COMPIZ_TOOLKIT_ACTION\0" // \0\0 terminates loop.
1959 };
1960 
1961 QXcbAtom::Atom QXcbConnection::qatom(xcb_atom_t xatom) const
1962 {
1963     return static_cast<QXcbAtom::Atom>(std::find(m_allAtoms, m_allAtoms + QXcbAtom::NAtoms, xatom) - m_allAtoms);
1964 }
1965 
1966 void QXcbConnection::initializeAllAtoms() {
1967     const char *names[QXcbAtom::NAtoms];
1968     const char *ptr = xcb_atomnames;
1969 
1970     int i = 0;
1971     while (*ptr) {
1972         names[i++] = ptr;
1973         while (*ptr)
1974             ++ptr;
1975         ++ptr;
1976     }
1977 
1978     Q_ASSERT(i == QXcbAtom::NPredefinedAtoms);
1979 
1980     QByteArray settings_atom_name("_QT_SETTINGS_TIMESTAMP_");
1981     settings_atom_name += m_displayName;
1982     names[i++] = settings_atom_name;
1983 
1984     xcb_intern_atom_cookie_t cookies[QXcbAtom::NAtoms];
1985 
1986     Q_ASSERT(i == QXcbAtom::NAtoms);
1987     for (i = 0; i < QXcbAtom::NAtoms; ++i)
1988         cookies[i] = xcb_intern_atom(xcb_connection(), false, strlen(names[i]), names[i]);
1989 
1990     for (i = 0; i < QXcbAtom::NAtoms; ++i) {
1991         xcb_intern_atom_reply_t *reply = xcb_intern_atom_reply(xcb_connection(), cookies[i], 0);
1992         m_allAtoms[i] = reply->atom;
1993         free(reply);
1994     }
1995 }
1996 
1997 xcb_atom_t QXcbConnection::internAtom(const char *name)
1998 {
1999     if (!name || *name == 0)
2000         return XCB_NONE;
2001 
2002     xcb_intern_atom_cookie_t cookie = xcb_intern_atom(xcb_connection(), false, strlen(name), name);
2003     xcb_intern_atom_reply_t *reply = xcb_intern_atom_reply(xcb_connection(), cookie, 0);
2004     int atom = reply->atom;
2005     free(reply);
2006     return atom;
2007 }
2008 
2009 QByteArray QXcbConnection::atomName(xcb_atom_t atom)
2010 {
2011     if (!atom)
2012         return QByteArray();
2013 
2014     xcb_generic_error_t *error = 0;
2015     xcb_get_atom_name_cookie_t cookie = Q_XCB_CALL(xcb_get_atom_name(xcb_connection(), atom));
2016     xcb_get_atom_name_reply_t *reply = xcb_get_atom_name_reply(xcb_connection(), cookie, &error);
2017     if (error) {
2018         qWarning() << "QXcbConnection::atomName: bad Atom" << atom;
2019         free(error);
2020     }
2021     if (reply) {
2022         QByteArray result(xcb_get_atom_name_name(reply), xcb_get_atom_name_name_length(reply));
2023         free(reply);
2024         return result;
2025     }
2026     return QByteArray();
2027 }
2028 
2029 const xcb_format_t *QXcbConnection::formatForDepth(uint8_t depth) const
2030 {
2031     xcb_format_iterator_t iterator =
2032         xcb_setup_pixmap_formats_iterator(m_setup);
2033 
2034     while (iterator.rem) {
2035         xcb_format_t *format = iterator.data;
2036         if (format->depth == depth)
2037             return format;
2038         xcb_format_next(&iterator);
2039     }
2040 
2041     return 0;
2042 }
2043 
2044 void QXcbConnection::sync()
2045 {
2046     // from xcb_aux_sync
2047     xcb_get_input_focus_cookie_t cookie = Q_XCB_CALL(xcb_get_input_focus(xcb_connection()));
2048     free(xcb_get_input_focus_reply(xcb_connection(), cookie, 0));
2049 }
2050 
2051 void QXcbConnection::initializeXFixes()
2052 {
2053     xcb_generic_error_t *error = 0;
2054     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_xfixes_id);
2055     if (!reply || !reply->present)
2056         return;
2057 
2058     xfixes_first_event = reply->first_event;
2059     xcb_xfixes_query_version_cookie_t xfixes_query_cookie = xcb_xfixes_query_version(m_connection,
2060                                                                                      XCB_XFIXES_MAJOR_VERSION,
2061                                                                                      XCB_XFIXES_MINOR_VERSION);
2062     xcb_xfixes_query_version_reply_t *xfixes_query = xcb_xfixes_query_version_reply (m_connection,
2063                                                                                      xfixes_query_cookie, &error);
2064     if (!xfixes_query || error || xfixes_query->major_version < 2) {
2065         qWarning("QXcbConnection: Failed to initialize XFixes");
2066         free(error);
2067         xfixes_first_event = 0;
2068     }
2069     free(xfixes_query);
2070 }
2071 
2072 void QXcbConnection::initializeXRender()
2073 {
2074 #ifdef XCB_USE_RENDER
2075     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_render_id);
2076     if (!reply || !reply->present)
2077         return;
2078 
2079     xcb_generic_error_t *error = 0;
2080     xcb_render_query_version_cookie_t xrender_query_cookie = xcb_render_query_version(m_connection,
2081                                                                                       XCB_RENDER_MAJOR_VERSION,
2082                                                                                       XCB_RENDER_MINOR_VERSION);
2083     xcb_render_query_version_reply_t *xrender_query = xcb_render_query_version_reply(m_connection,
2084                                                                                      xrender_query_cookie, &error);
2085     if (!xrender_query || error || (xrender_query->major_version == 0 && xrender_query->minor_version < 5)) {
2086         qWarning("QXcbConnection: Failed to initialize XRender");
2087         free(error);
2088     }
2089     free(xrender_query);
2090 #endif
2091 }
2092 
2093 void QXcbConnection::initializeXRandr()
2094 {
2095     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_randr_id);
2096     if (!reply || !reply->present)
2097         return;
2098 
2099     xrandr_first_event = reply->first_event;
2100 
2101     xcb_generic_error_t *error = 0;
2102     xcb_randr_query_version_cookie_t xrandr_query_cookie = xcb_randr_query_version(m_connection,
2103                                                                                    XCB_RANDR_MAJOR_VERSION,
2104                                                                                    XCB_RANDR_MINOR_VERSION);
2105 
2106     has_randr_extension = true;
2107 
2108     xcb_randr_query_version_reply_t *xrandr_query = xcb_randr_query_version_reply(m_connection,
2109                                                                                   xrandr_query_cookie, &error);
2110     if (!xrandr_query || error || (xrandr_query->major_version < 1 || (xrandr_query->major_version == 1 && xrandr_query->minor_version < 2))) {
2111         qWarning("QXcbConnection: Failed to initialize XRandr");
2112         free(error);
2113         has_randr_extension = false;
2114     }
2115     free(xrandr_query);
2116 
2117     xcb_screen_iterator_t rootIter = xcb_setup_roots_iterator(m_setup);
2118     for (; rootIter.rem; xcb_screen_next(&rootIter)) {
2119         xcb_randr_select_input(xcb_connection(),
2120             rootIter.data->root,
2121             XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE |
2122             XCB_RANDR_NOTIFY_MASK_OUTPUT_CHANGE |
2123             XCB_RANDR_NOTIFY_MASK_CRTC_CHANGE |
2124             XCB_RANDR_NOTIFY_MASK_OUTPUT_PROPERTY
2125         );
2126     }
2127 }
2128 
2129 void QXcbConnection::initializeXShape()
2130 {
2131     const xcb_query_extension_reply_t *xshape_reply = xcb_get_extension_data(m_connection, &xcb_shape_id);
2132     if (!xshape_reply || !xshape_reply->present)
2133         return;
2134 
2135     has_shape_extension = true;
2136     xcb_shape_query_version_cookie_t cookie = xcb_shape_query_version(m_connection);
2137     xcb_shape_query_version_reply_t *shape_query = xcb_shape_query_version_reply(m_connection,
2138                                                                                  cookie, NULL);
2139     if (!shape_query) {
2140         qWarning("QXcbConnection: Failed to initialize SHAPE extension");
2141     } else if (shape_query->major_version > 1 || (shape_query->major_version == 1 && shape_query->minor_version >= 1)) {
2142         // The input shape is the only thing added in SHAPE 1.1
2143         has_input_shape = true;
2144     }
2145     free(shape_query);
2146 }
2147 
2148 void QXcbConnection::initializeXKB()
2149 {
2150 #ifndef QT_NO_XKB
2151     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_xkb_id);
2152     if (!reply || !reply->present) {
2153         qWarning() << "Qt: XKEYBOARD extension not present on the X server.";
2154         xkb_first_event = 0;
2155         return;
2156     }
2157     xkb_first_event = reply->first_event;
2158 
2159     xcb_connection_t *c = connection()->xcb_connection();
2160     xcb_xkb_use_extension_cookie_t xkb_query_cookie;
2161     xcb_xkb_use_extension_reply_t *xkb_query;
2162 
2163     xkb_query_cookie = xcb_xkb_use_extension(c, XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION);
2164     xkb_query = xcb_xkb_use_extension_reply(c, xkb_query_cookie, 0);
2165 
2166     if (!xkb_query) {
2167         qWarning("Qt: Failed to initialize XKB extension");
2168         return;
2169     } else if (!xkb_query->supported) {
2170         qWarning("Qt: Unsupported XKB version (We want %d %d, but X server has %d %d)",
2171                  XCB_XKB_MAJOR_VERSION, XCB_XKB_MINOR_VERSION,
2172                  xkb_query->serverMajor, xkb_query->serverMinor);
2173         free(xkb_query);
2174         return;
2175     }
2176 
2177     has_xkb = true;
2178     free(xkb_query);
2179 
2180     const uint16_t required_map_parts = (XCB_XKB_MAP_PART_KEY_TYPES |
2181         XCB_XKB_MAP_PART_KEY_SYMS |
2182         XCB_XKB_MAP_PART_MODIFIER_MAP |
2183         XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS |
2184         XCB_XKB_MAP_PART_KEY_ACTIONS |
2185         XCB_XKB_MAP_PART_KEY_BEHAVIORS |
2186         XCB_XKB_MAP_PART_VIRTUAL_MODS |
2187         XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP);
2188 
2189     const uint16_t required_events = (XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY |
2190         XCB_XKB_EVENT_TYPE_MAP_NOTIFY |
2191         XCB_XKB_EVENT_TYPE_STATE_NOTIFY);
2192 
2193     // XKB events are reported to all interested clients without regard
2194     // to the current keyboard input focus or grab state
2195     xcb_void_cookie_t select = xcb_xkb_select_events_checked(c,
2196                        XCB_XKB_ID_USE_CORE_KBD,
2197                        required_events,
2198                        0,
2199                        required_events,
2200                        required_map_parts,
2201                        required_map_parts,
2202                        0);
2203 
2204     xcb_generic_error_t *error = xcb_request_check(c, select);
2205     if (error) {
2206         free(error);
2207         qWarning() << "Qt: failed to select notify events from xcb-xkb";
2208         return;
2209     }
2210 #endif
2211 }
2212 
2213 bool QXcbConnection::xi2MouseEvents() const
2214 {
2215     static bool mouseViaXI2 = !qEnvironmentVariableIsSet("QT_XCB_NO_XI2_MOUSE");
2216     return mouseViaXI2;
2217 }
2218 
2219 #if defined(XCB_USE_XINPUT2)
2220 static int xi2ValuatorOffset(unsigned char *maskPtr, int maskLen, int number)
2221 {
2222     int offset = 0;
2223     for (int i = 0; i < maskLen; i++) {
2224         if (number < 8) {
2225             if ((maskPtr[i] & (1 << number)) == 0)
2226                 return -1;
2227         }
2228         for (int j = 0; j < 8; j++) {
2229             if (j == number)
2230                 return offset;
2231             if (maskPtr[i] & (1 << j))
2232                 offset++;
2233         }
2234         number -= 8;
2235     }
2236     return -1;
2237 }
2238 
2239 bool QXcbConnection::xi2GetValuatorValueIfSet(void *event, int valuatorNum, double *value)
2240 {
2241     xXIDeviceEvent *xideviceevent = static_cast<xXIDeviceEvent *>(event);
2242     unsigned char *buttonsMaskAddr = (unsigned char*)&xideviceevent[1];
2243     unsigned char *valuatorsMaskAddr = buttonsMaskAddr + xideviceevent->buttons_len * 4;
2244     FP3232 *valuatorsValuesAddr = (FP3232*)(valuatorsMaskAddr + xideviceevent->valuators_len * 4);
2245 
2246     int valuatorOffset = xi2ValuatorOffset(valuatorsMaskAddr, xideviceevent->valuators_len, valuatorNum);
2247     if (valuatorOffset < 0)
2248         return false;
2249 
2250     *value = valuatorsValuesAddr[valuatorOffset].integral;
2251     *value += ((double)valuatorsValuesAddr[valuatorOffset].frac / (1 << 16) / (1 << 16));
2252     return true;
2253 }
2254 
2255 void QXcbConnection::xi2PrepareXIGenericDeviceEvent(xcb_ge_event_t *event)
2256 {
2257     // xcb event structs contain stuff that wasn't on the wire, the full_sequence field
2258     // adds an extra 4 bytes and generic events cookie data is on the wire right after the standard 32 bytes.
2259     // Move this data back to have the same layout in memory as it was on the wire
2260     // and allow casting, overwriting the full_sequence field.
2261     memmove((char*) event + 32, (char*) event + 36, event->length * 4);
2262 }
2263 #endif // defined(XCB_USE_XINPUT2)
2264 
2265 QXcbSystemTrayTracker *QXcbConnection::systemTrayTracker() const
2266 {
2267     if (!m_systemTrayTracker) {
2268         QXcbConnection *self = const_cast<QXcbConnection *>(this);
2269         if ((self->m_systemTrayTracker = QXcbSystemTrayTracker::create(self))) {
2270             connect(m_systemTrayTracker, SIGNAL(systemTrayWindowChanged(QScreen*)),
2271                     QGuiApplication::platformNativeInterface(), SIGNAL(systemTrayWindowChanged(QScreen*)));
2272         }
2273     }
2274     return m_systemTrayTracker;
2275 }
2276 
2277 bool QXcbConnection::xEmbedSystemTrayAvailable()
2278 {
2279     if (!QGuiApplicationPrivate::platformIntegration())
2280         return false;
2281     QXcbConnection *connection = static_cast<QXcbIntegration *>(QGuiApplicationPrivate::platformIntegration())->defaultConnection();
2282     return connection->systemTrayTracker();
2283 }
2284 
2285 bool QXcbConnection::xEmbedSystemTrayVisualHasAlphaChannel()
2286 {
2287     if (!QGuiApplicationPrivate::platformIntegration())
2288         return false;
2289     QXcbConnection *connection = static_cast<QXcbIntegration *>(QGuiApplicationPrivate::platformIntegration())->defaultConnection();
2290     return connection->systemTrayTracker() && connection->systemTrayTracker()->visualHasAlphaChannel();
2291 }
2292 
2293 bool QXcbConnection::event(QEvent *e)
2294 {
2295     if (e->type() == QEvent::User + 1) {
2296         QXcbSyncWindowRequest *ev = static_cast<QXcbSyncWindowRequest *>(e);
2297         QXcbWindow *w = ev->window();
2298         if (w) {
2299             w->updateSyncRequestCounter();
2300             ev->invalidate();
2301         }
2302         return true;
2303     }
2304     return QObject::event(e);
2305 }
2306 
2307 void QXcbSyncWindowRequest::invalidate()
2308 {
2309     if (m_window) {
2310         m_window->clearSyncWindowRequest();
2311         m_window = 0;
2312     }
2313 }
2314 
2315 QXcbConnectionGrabber::QXcbConnectionGrabber(QXcbConnection *connection)
2316     :m_connection(connection)
2317 {
2318     connection->grabServer();
2319 }
2320 
2321 QXcbConnectionGrabber::~QXcbConnectionGrabber()
2322 {
2323     if (m_connection)
2324         m_connection->ungrabServer();
2325 }
2326 
2327 void QXcbConnectionGrabber::release()
2328 {
2329     if (m_connection) {
2330         m_connection->ungrabServer();
2331         m_connection = 0;
2332     }
2333 }
2334 
2335 QT_END_NAMESPACE
