Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 Intel Corporation.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qdeadlinetimer.h"
41 #include "qdeadlinetimer_p.h"
42 #include "qnumeric_p.h"
43 
44 QT_BEGIN_NAMESPACE
45 
46 namespace {
47     class TimeReference
48     {
49         enum : qint64 {
50             kilo = 1000,
51             mega = kilo * 1000,
52             giga = mega * 1000
53         };
54         enum : unsigned {
55             umega = 1000 * 1000,
56             ugiga = mega * 1000
57         };
58     public:
59         inline TimeReference(qint64 = 0, unsigned = 0);
60         inline void updateTimer(qint64 &, unsigned &);
61 
62         inline bool addNanoseconds(qint64);
63         inline bool addMilliseconds(qint64);
64         bool addSecsAndNSecs(qint64, qint64);
65 
66         inline bool subtract(const qint64, const unsigned);
67 
68         inline bool toMilliseconds(qint64 *) const;
69         inline bool toNanoseconds(qint64 *) const;
70 
71     private:
72         bool adjust(const qint64, const unsigned, qint64 = 0);
73 
74     private:
75         qint64 secs;
76         unsigned nsecs;
77     };
78 }
79 
80 inline TimeReference::TimeReference(qint64 t1, unsigned t2)
81     : secs(t1), nsecs(t2)
82 {
83 }
84 
85 inline void TimeReference::updateTimer(qint64 &t1, unsigned &t2)
86 {
87     t1 = secs;
88     t2 = nsecs;
89 }
90 
91 #if defined(Q_OS_UNIX) && !defined(Q_OS_DARWIN)
92 inline bool TimeReference::addNanoseconds(qint64 arg)
93 {
94     return addSecsAndNSecs(arg / giga, arg % giga);
95 }
96 
97 inline bool TimeReference::addMilliseconds(qint64 arg)
98 {
99     return addSecsAndNSecs(arg / kilo, (arg % kilo) * mega);
100 }
101 
102 /*!
103  * \internal
104  *
105  * Adds \a t1 addSecs seconds and \a addNSecs nanoseconds to the
106  * time reference. The arguments are normalized to seconds (qint64)
107  * and nanoseconds (unsigned) before the actual calculation is
108  * delegated to adjust(). If the nanoseconds are negative the
109  * owed second used for the normalization is passed on to adjust()
110  * as third argument.
111  *
112  * Returns true if operation was successful, false on over|underflow
113  */
114 bool TimeReference::addSecsAndNSecs(qint64 addSecs, qint64 addNSecs)
115 {
116     // Normalize the arguments
117     if (qAbs(addNSecs) >= giga) {
118         if (add_overflow<qint64>(addSecs, addNSecs / giga, &addSecs))
119             return false;
120 
121         addNSecs %= giga;
122     }
123 
124     if (addNSecs < 0)
125         return adjust(addSecs, ugiga - unsigned(-addNSecs), -1);
126 
127     return adjust(addSecs, unsigned(addNSecs));
128 }
129 
130 /*!
131  * \internal
132  *
133  * Adds \a t1 seconds and \a t2 nanoseconds to the internal members.
134  * Takes into account the additional \a carrySeconds we may owe or need to carry over.
135  *
136  * Returns true if operation was successful, false on over|underflow
137  */
138 bool TimeReference::adjust(const qint64 t1, const unsigned t2, qint64 carrySeconds)
139 {
140     Q_STATIC_ASSERT(QDeadlineTimerNanosecondsInT2);
141     nsecs += t2;
142     if (nsecs >= ugiga) {
143         nsecs -= ugiga;
144         carrySeconds++;
145     }
146 
147     return !add_overflow<qint64>(secs, t1, &secs) && !add_overflow<qint64>(secs, carrySeconds, &secs);
148 }
149 
150 /*!
151  * \internal
152  *
153  * Subtracts \a t1 seconds and \a t2 nanoseconds from the time reference.
154  * When normalizing the nanoseconds to a positive number the owed seconds is
155  * passed as third argument to adjust() as the seconds may over|underflow
156  * if we do the calculation directly. There is little sense to check the
157  * seconds for over|underflow here in case we are going to need to carry
158  * over a second _after_ we add the nanoseconds.
159  *
160  * Returns true if operation was successful, false on over|underflow
161  */
162 inline bool TimeReference::subtract(const qint64 t1, const unsigned t2)
163 {
164     Q_ASSERT(t2 < ugiga);
165     return adjust(-t1, ugiga - t2, -1);
166 }
167 
168 /*!
169  * \internal
170  *
171  * Converts the time reference to milliseconds.
172  *
173  * Checks are done without making use of mul_overflow because it may
174  * not be implemented on some 32bit platforms.
175  *
176  * Returns true if operation was successful, false on over|underflow
177  */
178 inline bool TimeReference::toMilliseconds(qint64 *result) const
179 {
180     static constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / kilo;
181     static constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / kilo;
182     if (secs > maxSeconds || secs < minSeconds)
183         return false;
184 
185     return !add_overflow<qint64>(secs * kilo, nsecs / umega, result);
186 }
187 
188 /*!
189  * \internal
190  *
191  * Converts the time reference to nanoseconds.
192  *
193  * Checks are done without making use of mul_overflow because it may
194  * not be implemented on some 32bit platforms.
195  *
196  * Returns true if operation was successful, false on over|underflow
197  */
198 inline bool TimeReference::toNanoseconds(qint64 *result) const
199 {
200     static constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / giga;
201     static constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / giga;
202     if (secs > maxSeconds || secs < minSeconds)
203         return false;
204 
205     return !add_overflow<qint64>(secs * giga, nsecs, result);
206 }
207 #else
208 inline bool TimeReference::addNanoseconds(qint64 arg)
209 {
210     return adjust(arg, 0);
211 }
212 
213 inline bool TimeReference::addMilliseconds(qint64 arg)
214 {
215     static constexpr qint64 maxMilliseconds = std::numeric_limits<qint64>::max() / mega;
216     if (qAbs(arg) > maxMilliseconds)
217         return false;
218 
219     return addNanoseconds(arg * mega);
220 }
221 
222 inline bool TimeReference::addSecsAndNSecs(qint64 addSecs, qint64 addNSecs)
223 {
224     static constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / giga;
225     static constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / giga;
226     if (addSecs > maxSeconds || addSecs < minSeconds || add_overflow<qint64>(addSecs * giga, addNSecs, &addNSecs))
227         return false;
228 
229     return addNanoseconds(addNSecs);
230 }
231 
232 
233 bool TimeReference::adjust(const qint64 t1, const unsigned t2, bool owed)
234 {
235     Q_STATIC_ASSERT(!QDeadlineTimerNanosecondsInT2);
236     Q_UNUSED(t2);
237     Q_UNUSED(owed);
238 
239     return !add_overflow<qint64>(secs, t1, &secs);
240 }
241 
242 inline bool TimeReference::subtract(const qint64 t1, const unsigned t2)
243 {
244     Q_UNUSED(t2);
245 
246     return addNanoseconds(-t1);
247 }
248 
249 inline bool TimeReference::toMilliseconds(qint64 *result) const
250 {
251     *result = secs / mega;
252     return true;
253 }
254 
255 inline bool TimeReference::toNanoseconds(qint64 *result) const
256 {
257     *result = secs;
258     return true;
259 }
260 #endif
261 
262 /*!
263     \class QDeadlineTimer
264     \inmodule QtCore
265     \brief The QDeadlineTimer class marks a deadline in the future.
266     \since 5.8
267 
268     \reentrant
269     \ingroup tools
270 
271     The QDeadlineTimer class is usually used to calculate future deadlines and
272     verify whether the deadline has expired. QDeadlineTimer can also be used
273     for deadlines without expiration ("forever"). It forms a counterpart to
274     QElapsedTimer, which calculates how much time has elapsed since
275     QElapsedTimer::start() was called.
276 
277     QDeadlineTimer provides a more convenient API compared to
278     QElapsedTimer::hasExpired().
279 
280     The typical use-case for the class is to create a QDeadlineTimer before the
281     operation in question is started, and then use remainingTime() or
282     hasExpired() to determine whether to continue trying the operation.
283     QDeadlineTimer objects can be passed to functions being called to execute
284     this operation so they know how long to still operate.
285 
286     \code
287     void executeOperation(int msecs)
288     {
289         QDeadlineTimer deadline(msecs);
290         do {
291             if (readFromDevice(deadline.remainingTime())
292                 break;
293             waitForReadyRead(deadline);
294         } while (!deadline.hasExpired());
295     }
296     \endcode
297 
298     Many QDeadlineTimer functions deal with time out values, which all are
299     measured in milliseconds. There are two special values, the same as many
300     other Qt functions named \c{waitFor} or similar:
301 
302     \list
303       \li 0: no time left, expired
304       \li -1: infinite time left, timer never expires
305     \endlist
306 
307     \section1 Reference Clocks
308 
309     QDeadlineTimer will use the same clock as QElapsedTimer (see
310     QElapsedTimer::clockType() and QElapsedTimer::isMonotonic()).
311 
312     \section1 Timer types
313 
314     Like QTimer, QDeadlineTimer can select among different levels of coarseness
315     on the timers. You can select precise timing by passing Qt::PreciseTimer to
316     the functions that set of change the timer, or you can select coarse timing
317     by passing Qt::CoarseTimer. Qt::VeryCoarseTimer is currently interpreted
318     the same way as Qt::CoarseTimer.
319 
320     This feature is dependent on support from the operating system: if the OS
321     does not support a coarse timer functionality, then QDeadlineTimer will
322     behave like Qt::PreciseTimer was passed.
323 
324     QDeadlineTimer defaults to Qt::CoarseTimer because on operating systems
325     that do support coarse timing, making timing calls to that clock source is
326     often much more efficient. The level of coarseness depends on the
327     operating system, but should be in the order of a couple of milliseconds.
328 
329     \section1 \c{std::chrono} Compatibility
330 
331     QDeadlineTimer is compatible with the \c{std::chrono} API from C++11 and
332     can be constructed from or compared to both \c{std::chrono::duration} and
333     \c{std::chrono::time_point} objects. In addition, it is fully compatible
334     with the time literals from C++14, which allow one to write code as:
335 
336     \code
337         using namespace std::chrono;
338         using namespace std::chrono_literals;
339 
340         QDeadlineTimer deadline(30s);
341         device->waitForReadyRead(deadline);
342         if (deadline.remainingTime<nanoseconds>() > 300ms)
343             cleanup();
344     \endcode
345 
346     As can be seen in the example above, QDeadlineTimer offers a templated
347     version of remainingTime() and deadline() that can be used to return
348     \c{std::chrono} objects.
349 
350     Note that comparing to \c{time_point} is not as efficient as comparing to
351     \c{duration}, since QDeadlineTimer may need to convert from its own
352     internal clock source to the clock source used by the \c{time_point} object.
353     Also note that, due to this conversion, the deadlines will not be precise,
354     so the following code is not expected to compare equally:
355 
356     \code
357         using namespace std::chrono;
358         using namespace std::chrono_literals;
359         auto now = steady_clock::now();
360         QDeadlineTimer deadline(now + 1s);
361         Q_ASSERT(deadline == now + 1s);
362     \endcode
363 
364     \sa QTime, QTimer, QDeadlineTimer, Qt::TimerType
365 */
366 
367 /*!
368     \enum QDeadlineTimer::ForeverConstant
369 
370     \value Forever      Used when creating a QDeadlineTimer to indicate the
371                         deadline should not expire
372 */
373 
374 /*!
375     \fn QDeadlineTimer::QDeadlineTimer(Qt::TimerType timerType)
376 
377     Constructs an expired QDeadlineTimer object. For this object,
378     remainingTime() will return 0.
379 
380     The timer type \a timerType may be ignored, since the timer is already
381     expired. Similarly, for optimization purposes, this function will not
382     attempt to obtain the current time and will use a value known to be in the
383     past. Therefore, deadline() may return an unexpected value and this object
384     cannot be used in calculation of how long it is overdue. If that
385     functionality is required, use QDeadlineTimer::current().
386 
387     \sa hasExpired(), remainingTime(), Qt::TimerType, current()
388 */
389 
390 /*!
391     \fn QDeadlineTimer::QDeadlineTimer(ForeverConstant, Qt::TimerType timerType)
392 
393     QDeadlineTimer objects created with ForeverConstant never expire.
394     For such objects, remainingTime() will return -1, deadline() will return the
395     maximum value, and isForever() will return true.
396 
397     The timer type \a timerType may be ignored, since the timer is already
398     expired.
399 
400     \sa ForeverConstant, hasExpired(), isForever(), remainingTime(), timerType()
401 */
402 
403 /*!
404     Constructs a QDeadlineTimer object with an expiry time of \a msecs msecs
405     from the moment of the creation of this object, if msecs is positive. If \a
406     msecs is zero, this QDeadlineTimer will be marked as expired, causing
407     remainingTime() to return zero and deadline() to return an indeterminate
408     time point in the past. If \a msecs is -1, the timer will be set it to
409     never expire, causing remainingTime() to return -1 and deadline() to return
410     the maximum value.
411 
412     The QDeadlineTimer object will be constructed with the specified timer \a type.
413 
414     For optimization purposes, if \a msecs is zero, this function may skip
415     obtaining the current time and may instead use a value known to be in the
416     past. If that happens, deadline() may return an unexpected value and this
417     object cannot be used in calculation of how long it is overdue. If that
418     functionality is required, use QDeadlineTimer::current() and add time to
419     it.
420 
421     \sa hasExpired(), isForever(), remainingTime(), setRemainingTime()
422 */
423 QDeadlineTimer::QDeadlineTimer(qint64 msecs, Qt::TimerType type) Q_DECL_NOTHROW
424     : t2(0)
425 {
426     setRemainingTime(msecs, type);
427 }
428 
429 /*!
430     \fn template <class Clock, class Duration> QDeadlineTimer::QDeadlineTimer(std::chrono::time_point<Clock, Duration> deadline, Qt::TimerType type)
431 
432     Constructs a QDeadlineTimer object with a deadline at \a deadline time
433     point, converting from the clock source \c{Clock} to Qt's internal clock
434     source (see QElapsedTimer::clockType()).
435 
436     If \a deadline is in the past, this QDeadlineTimer object is set to
437     expired, whereas if \a deadline is equal to \c{Duration::max()}, then this
438     object is set to never expire.
439 
440     The QDeadlineTimer object will be constructed with the specified timer \a type.
441 
442     \sa hasExpired(), isForever(), remainingTime(), setDeadline()
443 */
444 
445 /*!
446     \fn template <class Rep, class Period> QDeadlineTimer::QDeadlineTimer(std::chrono::duration<Rep, Period> remaining, Qt::TimerType type)
447 
448     Constructs a QDeadlineTimer object with a remaining time of \a remaining.
449     If \a remaining is zero or negative, this QDeadlineTimer object will be
450     mark as expired, whereas if \a remaining is equal to \c{duration::max()},
451     the object will be set to never expire.
452 
453     The QDeadlineTimer object will be constructed with the specified timer \a type.
454 
455     This constructor can be used with C++14's user-defined literals for time, such as in:
456 
457     \code
458         using namespace std::chrono_literals;
459         QDeadlineTimer deadline(250ms);
460     \endcode
461 
462     For optimization purposes, if \a remaining is zero or negative, this
463     function may skip obtaining the current time and may instead use a value
464     known to be in the past. If that happens, deadline() may return an
465     unexpected value and this object cannot be used in calculation of how long
466     it is overdue. If that functionality is required, use
467     QDeadlineTimer::current() and add time to it.
468 
469     \sa hasExpired(), isForever(), remainingTime(), setRemainingTime()
470 */
471 
472 /*!
473     \fn template <class Clock, class Duration> void QDeadlineTimer::setDeadline(std::chrono::time_point<Clock, Duration> deadline, Qt::TimerType type)
474 
475     Sets this QDeadlineTimer to the deadline marked by \a deadline time
476     point, converting from the clock source \c{Clock} to Qt's internal clock
477     source (see QElapsedTimer::clockType()).
478 
479     If \a deadline is in the past, this QDeadlineTimer object is set to
480     expired, whereas if \a deadline is equal to \c{Duration::max()}, then this
481     object is set to never expire.
482 
483     The timer type for this QDeadlineTimer object will be set to the specified \a type.
484 
485     \sa hasExpired(), isForever(), remainingTime(),
486 */
487 
488 /*!
489     Sets the remaining time for this QDeadlineTimer object to \a msecs
490     milliseconds from now, if \a msecs has a positive value. If \a msecs is
491     zero, this QDeadlineTimer object will be marked as expired, whereas a value
492     of -1 will set it to never expire.
493 
494     The timer type for this QDeadlineTimer object will be set to the specified \a timerType.
495 
496     \sa setPreciseRemainingTime(), hasExpired(), isForever(), remainingTime()
497 */
498 void QDeadlineTimer::setRemainingTime(qint64 msecs, Qt::TimerType timerType) Q_DECL_NOTHROW
499 {
500     if (msecs == -1) {
501         *this = QDeadlineTimer(Forever, timerType);
502         return;
503     }
504 
505     *this = current(timerType);
506 
507     TimeReference ref(t1, t2);
508     if (!ref.addMilliseconds(msecs)) {
509         *this = QDeadlineTimer(Forever, timerType);
510         return;
511     }
512     ref.updateTimer(t1, t2);
513 }
514 
515 /*!
516     Sets the remaining time for this QDeadlineTimer object to \a secs seconds
517     plus \a nsecs nanoseconds from now, if \a secs has a positive value. If \a
518     secs is -1, this QDeadlineTimer will be set it to never expire. If both
519     parameters are zero, this QDeadlineTimer will be marked as expired.
520 
521     The timer type for this QDeadlineTimer object will be set to the specified
522     \a timerType.
523 
524     \sa setRemainingTime(), hasExpired(), isForever(), remainingTime()
525 */
526 void QDeadlineTimer::setPreciseRemainingTime(qint64 secs, qint64 nsecs, Qt::TimerType timerType) Q_DECL_NOTHROW
527 {
528     if (secs == -1) {
529         *this = QDeadlineTimer(Forever, timerType);
530         return;
531     }
532 
533     *this = current(timerType);
534     TimeReference ref(t1, t2);
535     if (!ref.addSecsAndNSecs(secs, nsecs)) {
536         *this = QDeadlineTimer(Forever, timerType);
537         return;
538     }
539     ref.updateTimer(t1, t2);
540 }
541 
542 /*!
543     \overload
544     \fn template <class Rep, class Period> void QDeadlineTimer::setRemainingTime(std::chrono::duration<Rep, Period> remaining, Qt::TimerType type)
545 
546     Sets the remaining time for this QDeadlineTimer object to \a remaining. If
547     \a remaining is zero or negative, this QDeadlineTimer object will be mark
548     as expired, whereas if \a remaining is equal to \c{duration::max()}, the
549     object will be set to never expire.
550 
551     The timer type for this QDeadlineTimer object will be set to the specified \a type.
552 
553     This function can be used with C++14's user-defined literals for time, such as in:
554 
555     \code
556         using namespace std::chrono_literals;
557         deadline.setRemainingTime(250ms);
558     \endcode
559 
560     \note Qt detects the necessary C++14 compiler support by way of the feature
561     test recommendations from
562     \l{https://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations}
563     {C++ Committee's Standing Document 6}.
564 
565     \sa setDeadline(), remainingTime(), hasExpired(), isForever()
566 */
567 
568 /*!
569     \fn bool QDeadlineTimer::isForever() const
570 
571     Returns true if this QDeadlineTimer object never expires, false otherwise.
572     For timers that never expire, remainingTime() always returns -1 and
573     deadline() returns the maximum value.
574 
575     \sa ForeverConstant, hasExpired(), remainingTime()
576 */
577 
578 /*!
579     Returns true if this QDeadlineTimer object has expired, false if there
580     remains time left. For objects that have expired, remainingTime() will
581     return zero and deadline() will return a time point in the past.
582 
583     QDeadlineTimer objects created with the \l {ForeverConstant} never expire
584     and this function always returns false for them.
585 
586     \sa isForever(), remainingTime()
587 */
588 bool QDeadlineTimer::hasExpired() const Q_DECL_NOTHROW
589 {
590     if (isForever())
591         return false;
592     return *this <= current(timerType());
593 }
594 
595 /*!
596     \fn Qt::TimerType QDeadlineTimer::timerType() const
597 
598     Returns the timer type is active for this object.
599 
600     \sa setTimerType()
601 */
602 
603 /*!
604     Changes the timer type for this object to \a timerType.
605 
606     The behavior for each possible value of \a timerType is operating-system
607     dependent. Qt::PreciseTimer will use the most precise timer that Qt can
608     find, with resolution of 1 millisecond or better, whereas QDeadlineTimer
609     will try to use a more coarse timer for Qt::CoarseTimer and
610     Qt::VeryCoarseTimer.
611 
612     \sa Qt::TimerType
613  */
614 void QDeadlineTimer::setTimerType(Qt::TimerType timerType)
615 {
616     type = timerType;
617 }
618 
619 /*!
620     Returns the remaining time in this QDeadlineTimer object in milliseconds.
621     If the timer has already expired, this function will return zero and it is
622     not possible to obtain the amount of time overdue with this function (to do
623     that, see deadline()). If the timer was set to never expire, this function
624     returns -1.
625 
626     This function is suitable for use in Qt APIs that take a millisecond
627     timeout, such as the many \l QIODevice \c waitFor functions or the timed
628     lock functions in \l QMutex, \l QWaitCondition, \l QSemaphore, or
629     \l QReadWriteLock. For example:
630 
631     \code
632         mutex.tryLock(deadline.remainingTime());
633     \endcode
634 
635     \sa remainingTimeNSecs(), isForever(), hasExpired()
636 */
637 qint64 QDeadlineTimer::remainingTime() const Q_DECL_NOTHROW
638 {
639     if (isForever())
640         return -1;
641 
642     QDeadlineTimer now = current(timerType());
643     TimeReference ref(t1, t2);
644 
645     qint64 msecs;
646     if (!ref.subtract(now.t1, now.t2) || !ref.toMilliseconds(&msecs))
647         return 0;
648 
649     return msecs < 0 ? 0 : msecs;
650 }
651 
652 /*!
653     Returns the remaining time in this QDeadlineTimer object in nanoseconds. If
654     the timer has already expired, this function will return zero and it is not
655     possible to obtain the amount of time overdue with this function. If the
656     timer was set to never expire, this function returns -1.
657 
658     \sa remainingTime(), isForever(), hasExpired()
659 */
660 qint64 QDeadlineTimer::remainingTimeNSecs() const Q_DECL_NOTHROW
661 {
662     if (isForever())
663         return -1;
664     qint64 raw = rawRemainingTimeNSecs();
665     return raw < 0 ? 0 : raw;
666 }
667 
668 /*!
669     \internal
670     Same as remainingTimeNSecs, but may return negative remaining times. Does
671     not deal with Forever. In case of underflow the result is saturated to
672     the minimum possible value.
673 */
674 qint64 QDeadlineTimer::rawRemainingTimeNSecs() const Q_DECL_NOTHROW
675 {
676     QDeadlineTimer now = current(timerType());
677     TimeReference ref(t1, t2);
678 
679     qint64 nsecs;
680     if (!ref.subtract(now.t1, now.t2) || !ref.toNanoseconds(&nsecs))
681         return std::numeric_limits<qint64>::min();
682 
683     return nsecs;
684 }
685 
686 /*!
687     Returns the absolute time point for the deadline stored in QDeadlineTimer
688     object, calculated in milliseconds relative to the reference clock, the
689     same as QElapsedTimer::msecsSinceReference(). The value will be in the past
690     if this QDeadlineTimer has expired.
691 
692     If this QDeadlineTimer never expires, this function returns
693     \c{std::numeric_limits<qint64>::max()}.
694 
695     This function can be used to calculate the amount of time a timer is
696     overdue, by subtracting QDeadlineTimer::current() or
697     QElapsedTimer::msecsSinceReference(), as in the following example:
698 
699     \code
700         qint64 realTimeLeft = deadline.deadline();
701         if (realTimeLeft != (std::numeric_limits<qint64>::max)()) {
702             realTimeLeft -= QDeadlineTimer::current().deadline();
703             // or:
704             //QElapsedTimer timer;
705             //timer.start();
706             //realTimeLeft -= timer.msecsSinceReference();
707         }
708     \endcode
709 
710     \note Timers that were created as expired have an indetermine time point in
711     the past as their deadline, so the above calculation may not work.
712 
713     \sa remainingTime(), deadlineNSecs(), setDeadline()
714 */
715 qint64 QDeadlineTimer::deadline() const Q_DECL_NOTHROW
716 {
717     if (isForever())
718         return std::numeric_limits<qint64>::max();
719 
720     qint64 result;
721     return TimeReference(t1, t2).toMilliseconds(&result) ? result : std::numeric_limits<qint64>::max();
722 }
723 
724 /*!
725     Returns the absolute time point for the deadline stored in QDeadlineTimer
726     object, calculated in nanoseconds relative to the reference clock, the
727     same as QElapsedTimer::msecsSinceReference(). The value will be in the past
728     if this QDeadlineTimer has expired.
729 
730     If this QDeadlineTimer never expires or the number of nanoseconds until the
731     deadline can't be accommodated in the return type, this function returns
732     \c{std::numeric_limits<qint64>::max()}.
733 
734     This function can be used to calculate the amount of time a timer is
735     overdue, by subtracting QDeadlineTimer::current(), as in the following
736     example:
737 
738     \code
739         qint64 realTimeLeft = deadline.deadlineNSecs();
740         if (realTimeLeft != std::numeric_limits<qint64>::max())
741             realTimeLeft -= QDeadlineTimer::current().deadlineNSecs();
742     \endcode
743 
744     \note Timers that were created as expired have an indetermine time point in
745     the past as their deadline, so the above calculation may not work.
746 
747     \sa remainingTime(), deadlineNSecs()
748 */
749 qint64 QDeadlineTimer::deadlineNSecs() const Q_DECL_NOTHROW
750 {
751     if (isForever())
752         return std::numeric_limits<qint64>::max();
753 
754     qint64 result;
755     return TimeReference(t1, t2).toNanoseconds(&result) ? result : std::numeric_limits<qint64>::max();
756 }
757 
758 /*!
759     Sets the deadline for this QDeadlineTimer object to be the \a msecs
760     absolute time point, counted in milliseconds since the reference clock (the
761     same as QElapsedTimer::msecsSinceReference()), and the timer type to \a
762     timerType. If the value is in the past, this QDeadlineTimer will be marked
763     as expired.
764 
765     If \a msecs is \c{std::numeric_limits<qint64>::max()} or the deadline is
766     beyond a representable point in the future, this QDeadlineTimer will be set
767     to never expire.
768 
769     \sa setPreciseDeadline(), deadline(), deadlineNSecs(), setRemainingTime()
770 */
771 void QDeadlineTimer::setDeadline(qint64 msecs, Qt::TimerType timerType) Q_DECL_NOTHROW
772 {
773     type = timerType;
774 
775     TimeReference ref;
776     if (msecs == std::numeric_limits<qint64>::max() || !ref.addMilliseconds(msecs)) {
777         *this = QDeadlineTimer(Forever, timerType);
778         return;
779     }
780     ref.updateTimer(t1, t2);
781 }
782 
783 /*!
784     Sets the deadline for this QDeadlineTimer object to be \a secs seconds and
785     \a nsecs nanoseconds since the reference clock epoch (the same as
786     QElapsedTimer::msecsSinceReference()), and the timer type to \a timerType.
787     If the value is in the past, this QDeadlineTimer will be marked as expired.
788 
789     If \a secs or \a nsecs is \c{std::numeric_limits<qint64>::max()}, this
790     QDeadlineTimer will be set to never expire. If \a nsecs is more than 1
791     billion nanoseconds (1 second), then \a secs will be adjusted accordingly.
792 
793     \sa setDeadline(), deadline(), deadlineNSecs(), setRemainingTime()
794 */
795 void QDeadlineTimer::setPreciseDeadline(qint64 secs, qint64 nsecs, Qt::TimerType timerType) Q_DECL_NOTHROW
796 {
797     type = timerType;
798 
799     TimeReference ref(secs);
800     if (!ref.addNanoseconds(nsecs)) {
801         *this = QDeadlineTimer(Forever, timerType);
802         return;
803     }
804     ref.updateTimer(t1, t2);
805 }
806 
807 /*!
808     Returns a QDeadlineTimer object whose deadline is extended from \a dt's
809     deadline by \a nsecs nanoseconds. If \a dt was set to never expire, this
810     function returns a QDeadlineTimer that will not expire either.
811 
812     \note if \a dt was created as expired, its deadline is indeterminate and
813     adding an amount of time may or may not cause it to become unexpired.
814 */
815 QDeadlineTimer QDeadlineTimer::addNSecs(QDeadlineTimer dt, qint64 nsecs) Q_DECL_NOTHROW
816 {
817     if (dt.isForever())
818         return dt;
819 
820     TimeReference ref(dt.t1, dt.t2);
821     if (!ref.addNanoseconds(nsecs))
822         return QDeadlineTimer(Forever, dt.timerType());
823     ref.updateTimer(dt.t1, dt.t2);
824 
825     return dt;
826 }
827 
828 /*!
829     \fn QDeadlineTimer QDeadlineTimer::current(Qt::TimerType timerType)
830 
831     Returns a QDeadlineTimer that is expired but is guaranteed to contain the
832     current time. Objects created by this function can participate in the
833     calculation of how long a timer is overdue, using the deadline() function.
834 
835     The QDeadlineTimer object will be constructed with the specified \a timerType.
836 */
837 
838 /*!
839     \fn bool operator==(QDeadlineTimer d1, QDeadlineTimer d2)
840     \relates QDeadlineTimer
841 
842     Returns true if the deadline on \a d1 and the deadline in \a d2 are the
843     same, false otherwise. The timer type used to create the two deadlines is
844     ignored. This function is equivalent to:
845 
846     \code
847         return d1.deadlineNSecs() == d2.deadlineNSecs();
848     \endcode
849 
850     \note comparing QDeadlineTimer objects with different timer types is
851     not supported and may result in unpredictable behavior.
852 */
853 
854 /*!
855     \fn bool operator!=(QDeadlineTimer d1, QDeadlineTimer d2)
856     \relates QDeadlineTimer
857 
858     Returns true if the deadline on \a d1 and the deadline in \a d2 are
859     diferent, false otherwise. The timer type used to create the two deadlines
860     is ignored. This function is equivalent to:
861 
862     \code
863         return d1.deadlineNSecs() != d2.deadlineNSecs();
864     \endcode
865 
866     \note comparing QDeadlineTimer objects with different timer types is
867     not supported and may result in unpredictable behavior.
868 */
869 
870 /*!
871     \fn bool operator<(QDeadlineTimer d1, QDeadlineTimer d2)
872     \relates QDeadlineTimer
873 
874     Returns true if the deadline on \a d1 is earlier than the deadline in \a
875     d2, false otherwise. The timer type used to create the two deadlines is
876     ignored. This function is equivalent to:
877 
878     \code
879         return d1.deadlineNSecs() < d2.deadlineNSecs();
880     \endcode
881 
882     \note comparing QDeadlineTimer objects with different timer types is
883     not supported and may result in unpredictable behavior.
884 */
885 
886 /*!
887     \fn bool operator<=(QDeadlineTimer d1, QDeadlineTimer d2)
888     \relates QDeadlineTimer
889 
890     Returns true if the deadline on \a d1 is earlier than or the same as the
891     deadline in \a d2, false otherwise. The timer type used to create the two
892     deadlines is ignored. This function is equivalent to:
893 
894     \code
895         return d1.deadlineNSecs() <= d2.deadlineNSecs();
896     \endcode
897 
898     \note comparing QDeadlineTimer objects with different timer types is
899     not supported and may result in unpredictable behavior.
900 */
901 
902 /*!
903     \fn bool operator>(QDeadlineTimer d1, QDeadlineTimer d2)
904     \relates QDeadlineTimer
905 
906     Returns true if the deadline on \a d1 is later than the deadline in \a
907     d2, false otherwise. The timer type used to create the two deadlines is
908     ignored. This function is equivalent to:
909 
910     \code
911         return d1.deadlineNSecs() > d2.deadlineNSecs();
912     \endcode
913 
914     \note comparing QDeadlineTimer objects with different timer types is
915     not supported and may result in unpredictable behavior.
916 */
917 
918 /*!
919     \fn bool operator>=(QDeadlineTimer d1, QDeadlineTimer d2)
920     \relates QDeadlineTimer
921 
922     Returns true if the deadline on \a d1 is later than or the same as the
923     deadline in \a d2, false otherwise. The timer type used to create the two
924     deadlines is ignored. This function is equivalent to:
925 
926     \code
927         return d1.deadlineNSecs() >= d2.deadlineNSecs();
928     \endcode
929 
930     \note comparing QDeadlineTimer objects with different timer types is
931     not supported and may result in unpredictable behavior.
932 */
933 
934 /*!
935     \fn QDeadlineTimer operator+(QDeadlineTimer dt, qint64 msecs)
936     \relates QDeadlineTimer
937 
938     Returns a QDeadlineTimer object whose deadline is \a msecs later than the
939     deadline stored in \a dt. If \a dt is set to never expire, this function
940     returns a QDeadlineTimer that does not expire either.
941 
942     To add times of precision greater than 1 millisecond, use addNSecs().
943 */
944 
945 QDeadlineTimer operator+(QDeadlineTimer dt, qint64 msecs)
946 {
947     if (dt.isForever())
948         return dt;
949 
950     TimeReference ref(dt.t1, dt.t2);
951     if (!ref.addMilliseconds(msecs))
952         return QDeadlineTimer(QDeadlineTimer::Forever, Qt::TimerType(dt.type));
953     ref.updateTimer(dt.t1, dt.t2);
954 
955     return dt;
956 }
957 
958 /*!
959     \fn QDeadlineTimer operator+(qint64 msecs, QDeadlineTimer dt)
960     \relates QDeadlineTimer
961 
962     Returns a QDeadlineTimer object whose deadline is \a msecs later than the
963     deadline stored in \a dt. If \a dt is set to never expire, this function
964     returns a QDeadlineTimer that does not expire either.
965 
966     To add times of precision greater than 1 millisecond, use addNSecs().
967 */
968 
969 /*!
970     \fn QDeadlineTimer operator-(QDeadlineTimer dt, qint64 msecs)
971     \relates QDeadlineTimer
972 
973     Returns a QDeadlineTimer object whose deadline is \a msecs before the
974     deadline stored in \a dt. If \a dt is set to never expire, this function
975     returns a QDeadlineTimer that does not expire either.
976 
977     To subtract times of precision greater than 1 millisecond, use addNSecs().
978 */
979 
980 /*!
981     \fn QDeadlineTimer &QDeadlineTimer::operator+=(qint64 msecs)
982 
983     Extends this QDeadlineTimer object by \a msecs milliseconds and returns
984     itself. If this object is set to never expire, this function does nothing.
985 
986     To add times of precision greater than 1 millisecond, use addNSecs().
987 */
988 
989 /*!
990     \fn QDeadlineTimer &QDeadlineTimer::operator-=(qint64 msecs)
991 
992     Shortens this QDeadlineTimer object by \a msecs milliseconds and returns
993     itself. If this object is set to never expire, this function does nothing.
994 
995     To subtract times of precision greater than 1 millisecond, use addNSecs().
996 */
997 
998 /*!
999   \fn void QDeadlineTimer::swap(QDeadlineTimer &other)
1000 
1001   Swaps this deadline timer with the \a other deadline timer.
1002  */
1003 
1004 /*!
1005   \fn template <class Clock, class Duration> QDeadlineTimer & QDeadlineTimer::operator=(std::chrono::time_point<Clock, Duration> deadline_)
1006 
1007   Assigns \a deadline_ to this deadline timer.
1008  */
1009 
1010 /*!
1011   \fn template <class Rep, class Period> QDeadlineTimer & QDeadlineTimer::operator=(std::chrono::duration<Rep, Period> remaining)
1012 
1013   Sets this deadline timer to the \a remaining time.
1014  */
1015 
1016 /*!
1017   \fn std::chrono::nanoseconds QDeadlineTimer::remainingTimeAsDuration() const
1018 
1019   Returns the time remaining before the deadline.
1020  */
1021 
1022 // the rest of the functions are in qelapsedtimer_xxx.cpp
1023 
1024 QT_END_NAMESPACE
