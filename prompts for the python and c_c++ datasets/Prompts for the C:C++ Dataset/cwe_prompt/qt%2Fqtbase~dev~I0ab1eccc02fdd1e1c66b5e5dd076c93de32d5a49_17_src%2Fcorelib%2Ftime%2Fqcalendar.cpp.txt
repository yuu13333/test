Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 #include "qcalendar.h"
40 #include "qcalendarbackend_p.h"
41 #include "qgregoriancalendar_p.h"
42 #ifndef QT_BOOTSTRAPPED
43 #include "qjuliancalendar_p.h"
44 #include "qmilankoviccalendar_p.h"
45 #endif
46 #if QT_CONFIG(jalalicalendar)
47 #include "qjalalicalendar_p.h"
48 #endif
49 #if QT_CONFIG(islamiccivilcalendar)
50 #include "qislamiccivilcalendar_p.h"
51 #endif
52 
53 #include "qatomic.h"
54 #include "qdatetime.h"
55 #include "qcalendarmath_p.h"
56 #include <qhash.h>
57 #include <qreadwritelock.h>
58 #include <qdebug.h>
59 
60 #include <vector>
61 
62 QT_BEGIN_NAMESPACE
63 
64 namespace {
65 
66 struct CalendarName : public QString
67 {
68     CalendarName(const QString &name) : QString(name) {}
69 };
70 
71 inline bool operator==(const CalendarName &u, const CalendarName &v)
72 {
73     return u.compare(v, Qt::CaseInsensitive) == 0;
74 }
75 
76 inline size_t qHash(const CalendarName &key, size_t seed = 0) noexcept
77 {
78     return qHash(key.toLower(), seed);
79 }
80 
81 } // anonymous namespace
82 
83 namespace QtPrivate {
84 
85 class QCalendarRegistry
86 {
87     /*!
88         \internal
89         Lock protecting the registry from concurrent modification.
90     */
91     QReadWriteLock lock;
92 
93     /*!
94         \internal
95         Vector containing all registered backends.
96 
97         The indices 0 to QCalendar::System::Last inclusive are allocated
98         for system backends and always present (but may be null).
99     */
100     std::vector<QCalendarBackend *> byId;
101 
102     /*!
103         \internal
104         Backends registered by name.
105 
106         Each backend may be registered with several names associated with it.
107         The names are case-insensitive.
108     */
109     QHash<CalendarName, QCalendarBackend *> byName;
110 
111     /*!
112         \internal
113         Pointer to the Gregorian backend for faster lockless access to it.
114 
115         This pointer may be null if the Gregorian backend is not yet registered.
116         This pointer may only be set once and only when write lock is held on
117         the registry.
118     */
119     QAtomicPointer<const QCalendarBackend> gregorianCalendar = nullptr;
120 
121     enum : int { Unpopulated, Populated };
122     /*!
123         \internal
124         Fast way to check whether the standard calendars were populated.
125 
126         The status should only be changed while the write lock is held.
127     */
128     QAtomicInt status = Unpopulated;
129 
130     void ensurePopulated();
131     QCalendarBackend *registerSystemBackendLockHeld(QCalendar::System system);
132     void registerBackendLockHeld(QCalendarBackend *backend, const QStringList &names,
133                                  QCalendar::System system);
134 
135 public:
136     QCalendarRegistry() { byId.resize(int(QCalendar::System::Last) + 1); }
137 
138     void registerUserBackend(QCalendarBackend *backend, const QStringList &names);
139 
140     QStringList availableCalendars();
141 
142     /*!
143         \internal
144         Returns backend for Gregorian calendar.
145 
146         The backend is returned without locking the registry if possible.
147     */
148     const QCalendarBackend *gregorian()
149     {
150         const QCalendarBackend *backend = gregorianCalendar.loadAcquire();
151         if (Q_LIKELY(backend != nullptr))
152             return backend;
153         return fromEnum(QCalendar::System::Gregorian);
154     }
155 
156     /*!
157         \internal
158         Returns \a true if the argument matches the registered Gregorian backend.
159 
160         \a backend should not be null.
161     */
162     bool isGregorian(const QCalendarBackend *backend) const
163     {
164         return backend == gregorianCalendar.loadRelaxed();
165     }
166 
167     const QCalendarBackend *fromName(QAnyStringView name);
168     const QCalendarBackend *fromIndex(size_t index);
169     const QCalendarBackend *fromEnum(QCalendar::System system);
170 
171     QStringList backendNames(const QCalendarBackend *backend);
172 };
173 
174 /*!
175     \internal
176     Registers a user backend.
177 
178     If \a system is QCalendar::System::User, a new unique ID is allocated;
179     otherwise, \a system must be a member of the QCalendar::System enumeration
180     and the \a calendar is registered with that as its ID. The registry takes
181     ownership of the \a backend.
182 
183     The names of the backend are also registered. Duplicate names are ignored
184     for user backends, but cause assertion (when enabled) for system backends.
185 
186     It is an error to pass a backend that is already registered.
187 
188     \a backend should be fully initialized. It becomes available to other
189     threads before this function returns.
190 */
191 void QCalendarRegistry::registerUserBackend(QCalendarBackend *backend, const QStringList &names)
192 {
193     Q_ASSERT(!backend->calendarId().isValid());
194 
195     ensurePopulated();
196 
197     QWriteLocker locker(&lock);
198     registerBackendLockHeld(backend, names, QCalendar::System::User);
199 }
200 
201 /*!
202     \internal
203     Ensures each \c{enum}-available calendar has been instantiated.
204 
205     This arranges for each system backend to be registered; it only does anything on
206     its first call, which ensures that name-based lookups can always find all
207     the calendars available via the \c enum.
208 */
209 void QCalendarRegistry::ensurePopulated()
210 {
211     if (Q_LIKELY(status.loadAcquire() != Unpopulated))
212         return;
213 
214     QWriteLocker locker(&lock);
215     if (status.loadAcquire() != Unpopulated)
216         return;
217 
218     for (int i = 0; i <= int(QCalendar::System::Last); ++i) {
219         if (byId[i] == nullptr)
220             registerSystemBackendLockHeld(QCalendar::System(i));
221     }
222 
223 #if defined(QT_FORCE_ASSERTS) || !defined(QT_NO_DEBUG)
224     auto oldValue = status.fetchAndStoreRelease(Populated);
225     Q_ASSERT(oldValue == Unpopulated);
226 #else
227     status.storeRelease(Populated);
228 #endif
229 }
230 
231 /*!
232     \internal
233     Helper functions for system backend registration.
234 
235     This function must be called with write lock held on the registry.
236 
237     \sa registerSystemBackend
238 */
239 QCalendarBackend *QCalendarRegistry::registerSystemBackendLockHeld(QCalendar::System system)
240 {
241     Q_ASSERT(system != QCalendar::System::User);
242 
243     QCalendarBackend *backend = nullptr;
244     QStringList names;
245 
246     switch (system) {
247     case QCalendar::System::Gregorian:
248         backend = new QGregorianCalendar;
249         names = QGregorianCalendar::nameList();
250         break;
251 #ifndef QT_BOOTSTRAPPED
252     case QCalendar::System::Julian:
253         backend = new QJulianCalendar;
254         names = QJulianCalendar::nameList();
255         break;
256     case QCalendar::System::Milankovic:
257         backend = new QMilankovicCalendar;
258         names = QMilankovicCalendar::nameList();
259         break;
260 #endif
261 #if QT_CONFIG(jalalicalendar)
262     case QCalendar::System::Jalali:
263         backend = new QJalaliCalendar;
264         names = QJalaliCalendar::nameList();
265         break;
266 #endif
267 #if QT_CONFIG(islamiccivilcalendar)
268     case QCalendar::System::IslamicCivil:
269         backend = new QIslamicCivilCalendar;
270         names = QIslamicCivilCalendar::nameList();
271         break;
272 #else // When highest-numbered system isn't enabled, ensure we have a case for Last:
273     case QCalendar::System::Last:
274 #endif
275     case QCalendar::System::User:
276         Q_UNREACHABLE();
277     }
278     if (!backend)
279         return nullptr;
280 
281     registerBackendLockHeld(backend, names, system);
282     Q_ASSERT(backend == byId[size_t(system)]);
283 
284     return backend;
285 }
286 
287 /*!
288     \internal
289     Helper function for backend registration.
290 
291     This function must be called with write lock held on the registry.
292 
293     \sa registerBackend
294 */
295 void QCalendarRegistry::registerBackendLockHeld(QCalendarBackend *backend, const QStringList &names,
296                                                 QCalendar::System system)
297 {
298     Q_ASSERT(!backend->calendarId().isValid());
299 
300     auto index = size_t(system);
301 
302     // Note: it is important to update the calendar ID before making
303     // the calendar available for queries.
304     if (system == QCalendar::System::User) {
305         backend->setIndex(byId.size());
306         byId.push_back(backend);
307     } else if (byId[index] == nullptr) {
308         backend->setIndex(index);
309         if (system == QCalendar::System::Gregorian) {
310 #if defined(QT_FORCE_ASSERTS) || !defined(QT_NO_DEBUG)
311             auto oldValue = gregorianCalendar.fetchAndStoreRelease(backend);
312             Q_ASSERT(oldValue == nullptr);
313 #else
314             gregorianCalendar.storeRelease(backend);
315 #endif
316         }
317 
318         Q_ASSERT(byId.size() > index);
319         Q_ASSERT(byId[index] == nullptr);
320         byId[index] = backend;
321     }
322 
323     // Register any names.
324     for (const auto &name : names) {
325         if (byName.contains(name)) {
326             Q_ASSERT(system == QCalendar::System::User);
327             qWarning() << "Cannot register name" << name << "(already in use).";
328         } else {
329             byName[name] = backend;
330         }
331     }
332 }
333 
334 /*!
335     Returns a list of names of the available calendar systems. Any
336     QCalendarBackend sub-class must be registered before being exposed to Date
337     and Time APIs.
338 
339     \sa fromName()
340 */
341 QStringList QCalendarRegistry::availableCalendars()
342 {
343     ensurePopulated();
344 
345     QReadLocker locker(&lock);
346     return QStringList(byName.keyBegin(), byName.keyEnd());
347 }
348 
349 /*!
350     \internal
351     Returns a pointer to a named calendar backend.
352 
353     If the given \a name is present in availableCalendars(), the backend
354     matching it is returned; otherwise, \c nullptr is returned. Matching of
355     names ignores case. Note that this does not provoke construction of a
356     calendar backend, other than those available via \l fromEnum(): it will only
357     return ones that have been instantiated (and not yet destroyed) by some
358     other means.
359 
360     \sa availableCalendars(), fromEnum(), fromIndex()
361 */
362 const QCalendarBackend *QCalendarRegistry::fromName(QAnyStringView name)
363 {
364     ensurePopulated();
365 
366     QReadLocker locker(&lock);
367     return byName.value(name.toString(), nullptr);
368 }
369 
370 /*!
371     \internal
372     Returns a pointer to a calendar backend, specified by index.
373 
374     If a calendar with ID \a index is known to the calendar registry, the backend
375     with this ID is returned; otherwise, \c nullptr is returned. Note that this
376     does not provoke construction of a calendar backend, other than those
377     available via \l fromEnum(): it will only return ones that have been
378     instantiated (and not yet destroyed) by some other means.
379 
380     \sa fromEnum(), calendarId()
381 */
382 const QCalendarBackend *QCalendarRegistry::fromIndex(size_t index)
383 {
384     {
385         QReadLocker locker(&lock);
386 
387         if (index >= byId.size())
388             return nullptr;
389 
390         if (auto backend = byId[index])
391             return backend;
392     }
393 
394     if (index <= size_t(QCalendar::System::Last))
395         return fromEnum(QCalendar::System(index));
396 
397     return nullptr;
398 }
399 
400 /*!
401     \internal
402     Returns a pointer to a calendar backend, specified by \c enum.
403 
404     This will instantiate the indicated calendar (which will enable fromName()
405     to return it subsequently), but only for the Qt-supported calendars for
406     which (where relevant) the appropriate feature has been enabled.
407 
408     \a system should be a member of \a QCalendar::System other than
409     \a QCalendar::System::User.
410 
411     \sa fromName(), fromId()
412 */
413 const QCalendarBackend *QCalendarRegistry::fromEnum(QCalendar::System system)
414 {
415     Q_ASSERT(system <= QCalendar::System::Last);
416     auto index = size_t(system);
417 
418     {
419         QReadLocker locker(&lock);
420         Q_ASSERT(byId.size() > index);
421         if (auto backend = byId[index])
422             return backend;
423     }
424 
425     QWriteLocker locker(&lock);
426 
427     // Check if the backend was registered after releasing the read lock above.
428     if (auto backend = byId[index])
429         return backend;
430 
431     return registerSystemBackendLockHeld(system);
432 }
433 
434 /*!
435     Returns list of names \a backend was registered with.
436 */
437 QStringList QCalendarRegistry::backendNames(const QCalendarBackend *backend)
438 {
439     QStringList l;
440 
441     QHashIterator<CalendarName, QCalendarBackend *> i(byName);
442     while (i.findNext(const_cast<QCalendarBackend *>(backend)))
443         l.push_back(i.key());
444 
445     return l;
446 }
447 
448 } // namespace QtPrivate
449 
450 Q_GLOBAL_STATIC(QtPrivate::QCalendarRegistry, calendarRegistry);
451 
452 /*!
453     \since 5.14
454 
455     \class QCalendarBackend
456     \inmodule QtCore
457     \internal
458     \reentrant
459     \brief The QCalendarBackend class provides basic calendaring functions.
460 
461     QCalendarBackend provides the base class on which all calendar types are
462     implemented. The backend must be registered before it is available via
463     QCalendar API. The registration for system backends is arranged by
464     the calendar registry. User backends may be registered using the
465     \c registerUserBackend() method.
466 
467     A backend may also be registered by one or more names. Registering with the
468     name used by CLDR (the Unicode consortium's Common Locale Data Repository)
469     is recommended, particularly when interacting with third-party software.
470     Once a backend is registered for a name, QCalendar can be constructed using
471     that name to select the backend.
472 
473     Each built-in backend has a distinct primary name and all built-in backends
474     are instantiated before any custom backend is registered, to prevent custom
475     backends with conflicting names from replacing built-in backends.
476 
477     Each calendar backend must inherit from QCalendarBackend and implement its
478     pure virtual methods. It may also override some other virtual methods, as
479     needed.
480 
481     Most backends are pure code, with only one data element (this base-classe's
482     \c m_id). Such backends should normally be implemented as singletons.
483 
484     The backends may be used by multiple threads simultaneously, the virtual
485     methods must be implemented in a \l {thread-safe} way.
486 
487     \section1 Instantiating backends
488 
489     Backends may be defined by third-party, plugin or user code. When such
490     custom backends are registered they shall be alloced a unique ID, by
491     which client code may access it. A custom backend instance can have no names
492     if access by name is not needed, or impractical (e.g. because the backend
493     is not a singleton and constructing names for each instance would not make
494     sense). If a custom backend has names that are already registered for
495     another backend, those names are ignored.
496 
497     A backend class that has instance variables as well as code may be
498     instantiated many times, each with a distinct set of names, to implement
499     distinct backends - presumably variants on some parameterized calendar.
500     Each instance is then a distinct backend. A pure code backend class shall
501     typically only be instantiated once, as it is only capable of representing
502     one backend.
503 
504     Each backend should be instantiated exactly once, on the heap (using the C++
505     \c new operator), so that the registry can take ownership of it after
506     registration.
507 
508     Built-in backends, identified by \c QCalendar::System values other than
509     \c{User}, should only be registered by \c{QCalendarRegistry::fromEnum()};
510     no other code should ever register one, this guarantees that such a backend
511     will be a singleton.
512 
513     The shareable base-classes for backends, QRomanCalendar and QHijriCalendar,
514     are not themselves identified by QCalendar::System and may be used as
515     base-classes for custom calendar backends, but cannot be instantiated
516     themselves.
517 
518     \sa calendarId(), QDate, QDateTime, QDateEdit,
519         QDateTimeEdit, QCalendarWidget
520 */
521 
522 /*!
523     Destroys the calendar backend.
524 
525     Each calendar backend, once instantiated and successfully registered by ID,
526     shall exist for the lifetime of the program. Destroying a
527     successfully-registered backend otherwise may leave existing QCalendar
528     instances referencing the destroyed calendar, with undefined results.
529 
530     If a backend has not been registered it may safely be deleted.
531 
532     \sa calendarId()
533 */
534 QCalendarBackend::~QCalendarBackend()
535 {
536 }
537 
538 /*!
539     \fn QString QCalendarBackend::name() const
540     Returns the primary name of the calendar.
541  */
542 
543 /*!
544     Returns list of names this backend was registered with.
545 */
546 QStringList QCalendarBackend::names() const
547 {
548     if (Q_UNLIKELY(calendarRegistry.isDestroyed()))
549         return {};
550 
551     return calendarRegistry->backendNames(this);
552 }
553 
554 /*!
555     Set the internal index of the backed to the specified value.
556 
557     This method exists to allow QCalendarRegistry to update the backend ID
558     after registration without exposing it in public API for QCalendar.
559  */
560 void QCalendarBackend::setIndex(size_t index)
561 {
562     Q_ASSERT(!m_id.isValid());
563     m_id.id = index;
564 }
565 
566 /*!
567     Register this backend as a user backend.
568 
569     The backend should not already be registered. This method should only be
570     called on on objects that are completely initialized because they become
571     available to other threads immediately. In particular, it is not a good
572     idea to call this function in constructors of classes that may be derived.
573 
574     Returns the new ID assigned to this backend. If its isValid() is \c true,
575     the calendar registry has taken ownership of the object; this ID can then
576     be used to create \c QCalendar instances. Otherwise, registration failed
577     and the caller is responsible for destruction of the backend, which shall
578     not be available for use by \c QCalendar. Failure should normally only
579     happen if registration is attempted during program termination.
580 */
581 QCalendar::SystemId QCalendarBackend::registerUserBackend(const QStringList &names)
582 {
583     Q_ASSERT(!m_id.isValid());
584 
585     if (Q_LIKELY(!calendarRegistry.isDestroyed()))
586         calendarRegistry->registerUserBackend(this, names);
587 
588     return m_id;
589 }
590 
591 bool QCalendarBackend::isGregorian() const
592 {
593     if (Q_UNLIKELY(calendarRegistry.isDestroyed()))
594         return false;
595 
596     return calendarRegistry->isGregorian(this);
597 }
598 
599 /*!
600     \since 6.2
601     \fn QCalendar::SystemId QCalendarBackend::calendarId() const
602 
603     Each backend is allocated an ID when successfully registered. A backend whose
604     calendarId() has isValid() \c{false} has not been registered; it also cannot
605     be used, as it is not known to any of the available ways to create a QCalendar.
606 
607     \sa calendarSystem(), fromId()
608 */
609 
610 /*!
611     The calendar system of this calendar.
612 
613     \sa fromEnum(), calendarId()
614 */
615 QCalendar::System QCalendarBackend::calendarSystem() const
616 {
617     return m_id.isInEnum() ? QCalendar::System(m_id.index()) : QCalendar::System::User;
618 }
619 
620 /*!
621     The primary name of this calendar.
622 
623     The calendar may also be known by some aliases. A calendar instantiated by
624     name may use such an alias, in which case its name() need not match the
625     alias by which it was instantiated.
626 */
627 QString QCalendar::name() const
628 {
629     return d ? d->name() : QString();
630 }
631 
632 // date queries
633 /*!
634    \fn int QCalendarBackend::daysInMonth(int month, int year) const
635 
636    Returns number of days in the month number \a month, in year \a year.
637 
638    An implementation should return 0 if the given year had no such month. If
639    year is QCalendar::Unspecified, return the usual number of days for the
640    month, in those years that include it.
641 
642    Calendars with intercallary days may represent these as extra days of the
643    preceding month, or as short months separate from the usual ones. In the
644    former case, daysInMonth(month, year) should be the number of ordinary days
645    in the month, although \c{isDateValid(year, month, day)} might return \c true
646    for some larger values of \c day.
647 
648    \sa daysInYear(), monthsInYear(), minimumDaysInMonth(), maximumDaysInMonth()
649 */
650 
651 // properties of the calendar
652 
653 /*!
654     \fn bool QCalendarBackend::isLeapYear(int year) const
655 
656     Returns \c true if the specified \a year is a leap year for this calendar.
657 
658     \sa daysInYear(), isDateValid()
659 */
660 
661 /*!
662     \fn bool QCalendarBackend::isLunar() const
663 
664     Returns \c true if this calendar is a lunar calendar. Otherwise returns \c
665     false.
666 
667     A lunar calendar is a calendar based upon the monthly cycles of the Moon's
668     phases (synodic months). This contrasts with solar calendars, whose annual
669     cycles are based only upon the solar year.
670 
671     \sa isLuniSolar(), isSolar(), isProleptic()
672 */
673 
674 /*!
675     \fn bool QCalendarBackend::isLuniSolar() const
676 
677     Returns \c true if this calendar is a lunisolar calendar. Otherwise returns
678     \c false.
679 
680     A lunisolar calendar is a calendar whose date indicates both the moon phase
681     and the time of the solar year.
682 
683     \sa isLunar(), isSolar(), isProleptic()
684 */
685 
686 /*!
687     \fn bool QCalendarBackend::isSolar() const
688 
689     Returns \c true if this calendar is a solar calendar. Otherwise returns
690     \c false.
691 
692     A solar calendar is a calendar whose dates indicate the season or almost
693     equivalently the apparent position of the sun relative to the fixed stars.
694     The Gregorian calendar, widely accepted as standard in the world,
695     is an example of solar calendar.
696 
697     \sa isLuniSolar(), isLunar(), isProleptic()
698 */
699 
700 /*!
701     Returns the total number of days in the year number \a year.
702     Returns zero if there is no such year in this calendar.
703 
704     This base implementation returns 366 for leap years and 365 for ordinary
705     years.
706 
707     \sa monthsInYear(), daysInMonth(), isLeapYear()
708 */
709 int QCalendarBackend::daysInYear(int year) const
710 {
711     return monthsInYear(year) ? isLeapYear(year) ? 366 : 365 : 0;
712 }
713 
714 /*!
715     Returns the total number of months in the year number \a year.
716     Returns zero if there is no such year in this calendar.
717 
718     This base implementation returns 12 for any valid year.
719 
720     \sa daysInYear(), maximumMonthsInYear(), isDateValid()
721 */
722 int QCalendarBackend::monthsInYear(int year) const
723 {
724     return year > 0 || (year < 0 ? isProleptic() : hasYearZero()) ? 12 : 0;
725 }
726 
727 /*!
728     Returns \c true if the date specified by \a year, \a month, and \a day is
729     valid for this calendar; otherwise returns \c false. For example,
730     the date 2018-04-19 is valid for the Gregorian calendar, but 2018-16-19 and
731     2018-04-38 are invalid.
732 
733     Calendars with intercallary days may represent these as extra days of the
734     preceding month or as short months separate from the usual ones. In the
735     former case, a \a day value greater than \c{daysInMonth(\a{month},
736     \a{year})} may be valid.
737 
738     \sa daysInMonth(), monthsInYear()
739 */
740 bool QCalendarBackend::isDateValid(int year, int month, int day) const
741 {
742     return day > 0 && day <= daysInMonth(month, year);
743 }
744 
745 /*!
746     Returns \c true if this calendar is a proleptic calendar. Otherwise returns
747     \c false.
748 
749     A proleptic calendar results from allowing negative year numbers to indicate
750     years before the nominal start of the calendar system.
751 
752     \sa isLuniSolar(), isSolar(), isLunar(), hasYearZero()
753 */
754 
755 bool QCalendarBackend::isProleptic() const
756 {
757     return true;
758 }
759 
760 /*!
761     Returns \c true if year number \c 0 is considered a valid year in this
762     calendar. Otherwise returns \c false.
763 
764     \sa isDateValid(), isProleptic()
765 */
766 
767 bool QCalendarBackend::hasYearZero() const
768 {
769     return false;
770 }
771 
772 /*!
773     Returns the maximum number of days in a month for any year.
774 
775     This base implementation returns 31, as this is a common case.
776 
777     For calendars with intercallary days, although daysInMonth() doesn't include
778     the intercallary days in its count for an individual month,
779     maximumDaysInMonth() should include intercallary days, so that it is the
780     maximum value of \c day for which \c{isDateValid(year, month, day)} can be
781     true.
782 
783     \sa maximumMonthsInYear(), daysInMonth()
784 */
785 int QCalendarBackend::maximumDaysInMonth() const
786 {
787     return 31;
788 }
789 
790 /*!
791     Returns the minimum number of days in any valid month of any valid year.
792 
793     This base implementation returns 29, as this is a common case.
794 
795     \sa maximumMonthsInYear(), daysInMonth()
796 */
797 int QCalendarBackend::minimumDaysInMonth() const
798 {
799     return 29;
800 }
801 
802 /*!
803     Returns the maximum number of months possible in any year.
804 
805     This base implementation returns 12, as this is a common case.
806 
807     \sa maximumDaysInMonth(), monthsInYear()
808 */
809 int QCalendarBackend::maximumMonthsInYear() const
810 {
811     return 12;
812 }
813 
814 // Julian day number calculations
815 
816 /*!
817     \fn bool QCalendarBackend::dateToJulianDay(int year, int month, int day, qint64 *jd) const
818 
819     Computes the Julian day number corresponding to the specified \a year, \a
820     month, and \a day. Returns true and sets \a jd if there is such a date in
821     this calendar; otherwise, returns false.
822 
823     \sa QCalendar::partsFromDate(), julianDayToDate()
824 */
825 
826 /*!
827     \fn QCalendar::YearMonthDay QCalendarBackend::julianDayToDate(qint64 jd) const
828 
829     Computes the year, month, and day in this calendar for the given Julian day
830     number \a jd. If the given day falls outside this calendar's scope
831     (e.g. before the start-date of a non-proleptic calendar), the returned
832     structure's isValid() is false; otherwise, its year, month, and day fields
833     provide this calendar's description of the date.
834 
835     \sa QCalendar::dateFromParts(), dateToJulianDay()
836 */
837 
838 /*!
839    Returns the day of the week for the given Julian Day Number \a jd.
840 
841    This is 1 for Monday through 7 for Sunday.
842 
843    Calendars with intercallary days may return larger values for these
844    intercallary days. They should avoid using 0 for any special purpose (it is
845    already used in QDate::dayOfWeek() to mean an invalid date). The calendar
846    should treat the numbers used as an \c enum, whose values need not be
847    contiguous, nor need they follow closely from the 1 through 7 of the usual
848    returns. It suffices that weekDayName() can recognize each such number as
849    identifying a distinct name, that it returns to identify the particular
850    intercallary day.
851 
852    This base implementation uses the day-numbering that various calendars have
853    borrowed off the Hebrew calendar.
854 
855    \sa weekDayName(), standaloneWeekDayName(), QDate::dayOfWeek()
856  */
857 int QCalendarBackend::dayOfWeek(qint64 jd) const
858 {
859     return QRoundingDown::qMod(jd, 7) + 1;
860 }
861 
862 // Month and week-day name look-ups (implemented in qlocale.cpp):
863 /*!
864     \fn QString QCalendarBackend::monthName(const QLocale &locale, int month, int year,
865                                             QLocale::FormatType format) const
866 
867     Returns the name of the specified \a month in the given \a year for the
868     chosen \a locale, using the given \a format to determine how complete the
869     name is.
870 
871     If \a year is Unspecified, return the name for the month that usually has
872     this number within a typical year. Calendars with a leap month that isn't
873     always the last may need to take account of the year to map the month number
874     to the particular year's month with that number.
875 
876     \note Backends for which CLDR provides data can configure the default
877     implementation of the two month name look-up methods by arranging for
878     localeMonthIndexData() and localeMonthData() to provide access to the CLDR
879     data (see cldr2qlocalexml.py, qlocalexml2cpp.py and existing backends).
880     Conversely, backends that override both month name look-up methods need not
881     return anything meaningful from localeMonthIndexData() or localeMonthData().
882 
883     \sa standaloneMonthName(), QLocale::monthName()
884 */
885 
886 /*!
887     \fn QString QCalendarBackend::standaloneMonthName(const QLocale &locale, int month, int year
888                                                       QLocale::FormatType format) const
889 
890     Returns the standalone name of the specified \a month in the chosen \a
891     locale, using the specified \a format to determine how complete the name is.
892 
893     If \a year is Unspecified, return the standalone name for the month that
894     usually has this number within a typical year. Calendars with a leap month
895     that isn't always the last may need to take account of the year to map the
896     month number to the particular year's month with that number.
897 
898     \sa monthName(), QLocale::standaloneMonthName()
899 */
900 
901 /*!
902     \fn QString QCalendarBackend::weekDayName(const QLocale &locale, int day,
903                                               QLocale::FormatType format) const
904 
905     Returns the name of the specified \a day of the week in the chosen \a
906     locale, using the specified \a format to determine how complete the name is.
907 
908     The base implementation handles \a day values from 1 to 7 using the day
909     names CLDR provides, which are suitable for calendards that use the same
910     (Hebrew-derived) week as the Gregorian calendar.
911 
912     Calendars whose dayOfWeek() returns a value outside the range from 1 to 7
913     need to reimplement this method to handle such extra week-day values. They
914     can assume that \a day is a value returned by the same calendar's
915     dayOfWeek().
916 
917     \sa dayOfWeek(), standaloneWeekDayName(), QLocale::dayName()
918 */
919 
920 /*!
921     \fn QString QCalendarBackend::standaloneWeekDayName(const QLocale &locale, int day,
922                                                         QLocale::FormatType format) const
923 
924     Returns the standalone name of the specified \a day of the week in the
925     chosen \a locale, using the specified \a format to determine how complete
926     the name is.
927 
928     The base implementation handles \a day values from 1 to 7 using the
929     standalone day names CLDR provides, which are suitable for calendards that
930     use the same (Hebrew-derived) week as the Gregorian calendar.
931 
932     Calendars whose dayOfWeek() returns a value outside the range from 1 to 7
933     need to reimplement this method to handle such extra week-day values. They
934     can assume that \a day is a value returned by the same calendar's
935     dayOfWeek().
936 
937     \sa dayOfWeek(), weekDayName(), QLocale::standaloneDayName()
938 */
939 
940 /*!
941     \fn QString QCalendarBackend::dateTimeToString(QStringView format, const QDateTime &datetime,
942                                                    QDate dateOnly, QTime timeOnly,
943                                                    const QLocale &locale) const
944 
945     Returns a string representing a given date, time or date-time.
946 
947     If \a datetime is specified and valid, it is used and both date and time
948     format tokens are converted to appropriate representations of the parts of
949     the datetime. Otherwise, if \a dateOnly is valid, only date format tokens
950     are converted; else, if \a timeOnly is valid, only time format tokens are
951     converted. If none are valid, an empty string is returned.
952 
953     The specified \a locale influences how some format tokens are converted; for
954     example, when substituting day and month names and their short-forms. For
955     the supported formatting tokens, see QDate::toString() and
956     QTime::toString(). As described above, the provided date, time and date-time
957     determine which of these tokens are recognized: where these appear in \a
958     format they are replaced by data. Any text in \a format not recognized as a
959     format token is copied verbatim into the result string.
960 
961     \sa QDate::toString(), QTime::toString(), QDateTime::toString()
962 */
963 // End of methods implemented in qlocale.cpp
964 
965 /*!
966     Returns a list of names of the available calendar systems. Any
967     QCalendarBackend sub-class must be registered before being exposed to Date
968     and Time APIs.
969 
970     \sa fromName()
971 */
972 QStringList QCalendarBackend::availableCalendars()
973 {
974     if (Q_UNLIKELY(calendarRegistry.isDestroyed()))
975         return {};
976 
977     return calendarRegistry->availableCalendars();
978 }
979 
980 /*!
981     \internal
982     Returns a pointer to a named calendar backend.
983 
984     If the given \a name is present in availableCalendars(), the backend
985     matching it is returned; otherwise, \c nullptr is returned. Matching of
986     names ignores case. Note that this does not provoke construction of a
987     calendar backend, other than those available via \l fromEnum(): it will only
988     return ones that have been instantiated (and not yet destroyed) by some
989     other means.
990 
991     \sa availableCalendars(), fromEnum(), fromId()
992 */
993 const QCalendarBackend *QCalendarBackend::fromName(QAnyStringView name)
994 {
995     if (Q_UNLIKELY(calendarRegistry.isDestroyed()))
996         return nullptr;
997 
998     return calendarRegistry->fromName(name);
999 }
1000 
1001 /*!
1002     \internal
1003     Returns a pointer to a calendar backend, specified by ID.
1004 
1005     If a calendar with ID \a id is known to the calendar registry, the backend
1006     with this ID is returned; otherwise, \c nullptr is returned. Note that this
1007     does not provoke construction of a calendar backend, other than those
1008     available via \l fromEnum(): it will only return ones that have been
1009     instantiated (and not yet destroyed) by some other means.
1010 
1011     \sa fromEnum(), calendarId()
1012 */
1013 const QCalendarBackend *QCalendarBackend::fromId(QCalendar::SystemId id)
1014 {
1015     if (Q_UNLIKELY(calendarRegistry.isDestroyed() || !id.isValid()))
1016         return nullptr;
1017 
1018     return calendarRegistry->fromIndex(id.index());
1019 }
1020 
1021 /*!
1022     \internal
1023     Returns a pointer to a calendar backend, specified by \c enum.
1024 
1025     This will instantiate the indicated calendar (which will enable fromName()
1026     to return it subsequently), but only for the Qt-supported calendars for
1027     which (where relevant) the appropriate feature has been enabled.
1028 
1029     \sa fromName(), fromId()
1030 */
1031 const QCalendarBackend *QCalendarBackend::fromEnum(QCalendar::System system)
1032 {
1033     if (Q_UNLIKELY(calendarRegistry.isDestroyed() || system == QCalendar::System::User))
1034         return nullptr;
1035 
1036     return calendarRegistry->fromEnum(system);
1037 }
1038 
1039 /*!
1040     \internal
1041     Returns backend for Gregorian calendar.
1042 
1043     The backend is returned without locking the registry if possible.
1044 */
1045 const QCalendarBackend *QCalendarBackend::gregorian()
1046 {
1047     if (Q_UNLIKELY(calendarRegistry.isDestroyed()))
1048         return nullptr;
1049 
1050     return calendarRegistry->gregorian();
1051 }
1052 
1053 /*!
1054     \since 5.14
1055 
1056     \class QCalendar
1057     \inmodule QtCore
1058     \reentrant
1059     \brief The QCalendar class describes calendar systems.
1060 
1061     A QCalendar object maps a year, month, and day-number to a specific day
1062     (ultimately identified by its Julian day number), using the rules of a
1063     particular system.
1064 
1065     The default QCalendar() is a proleptic Gregorian calendar, which has no year
1066     zero. Other calendars may be supported by enabling suitable features or
1067     loading plugins. Calendars supported as features can be constructed by
1068     passing the QCalendar::System enumeration to the constructor. All supported
1069     calendars may be constructed by name, once they have been constructed. (Thus
1070     plugins instantiate their calendar backend to register it.) Built-in
1071     backends, accessible via QCalendar::System, are also always available by
1072     name. Calendars using custom backends may also be constructed using a unique
1073     ID allocated to the backend on construction.
1074 
1075     A QCalendar value is immutable.
1076 
1077     \sa QDate, QDateTime
1078 */
1079 
1080 /*!
1081     \enum QCalendar::System
1082 
1083     This enumerated type is used to specify a choice of calendar system.
1084 
1085     \value Gregorian The default calendar, used internationally.
1086     \value Julian An ancient Roman calendar.
1087     \value Milankovic A revised Julian calendar used by some Orthodox churches.
1088     \value Jalali The Solar Hijri calendar (also called Persian).
1089     \value IslamicCivil The (tabular) Islamic Civil calendar.
1090     \omitvalue Last
1091     \omitvalue User
1092 
1093     \sa QCalendar, QCalendar::SystemId
1094 */
1095 
1096 /*!
1097     \class QCalendar::SystemId
1098     \since 6.2
1099 
1100     This is an opaque type used to identify custom calendar implementations. The
1101     only supported source for values of this type is the backend's \c
1102     calendarId() method. A value of this type whose isValid() is false does not
1103     identify a successfully-registered backend. The only valid consumer of
1104     values of this type is a QCalendar constructor, which will only produce a
1105     valid QCalendar instance if the ID passed to it is valid.
1106 
1107     \sa QCalendar, QCalendar::System
1108 */
1109 
1110 /*!
1111     \fn QCalendar::SystemId::isValid()
1112 
1113     Returns true if this is a valid calendar implementation identifier, else
1114     false.
1115 
1116     \sa QCalendar
1117 */
1118 
1119 /*!
1120     \internal
1121     \fn QCalendar::SystemId::SystemId()
1122 
1123     Constructs an invalid calendar system identifier.
1124 */
1125 
1126 /*!
1127     \internal
1128     \fn QCalendar::SystemId::index()
1129 
1130     Returns the internal representation of the identifier.
1131 */
1132 
1133 /*!
1134     \fn QCalendar::QCalendar()
1135     \fn QCalendar::QCalendar(QCalendar::System system)
1136     \fn QCalendar::QCalendar(QLatin1String name)
1137     \fn QCalendar::QCalendar(QStringView name)
1138 
1139     Constructs a calendar object.
1140 
1141     The choice of calendar to use may be indicated by \a system, using the
1142     enumeration QCalendar::System, or by \a name, using a string (either Unicode
1143     or Latin 1). Construction by name may depend on an instance of the given
1144     calendar being constructed by other means first. With no argument, the
1145     default constructor returns the Gregorian calendar.
1146 
1147     \sa QCalendar, System, isValid()
1148 */
1149 
1150 QCalendar::QCalendar()
1151     : d(QCalendarBackend::gregorian())
1152 {
1153     Q_ASSERT(!d || d->calendarId().isValid());
1154 }
1155 
1156 QCalendar::QCalendar(QCalendar::System system)
1157     : d(QCalendarBackend::fromEnum(system))
1158 {
1159     // If system is valid, we should get a valid d for that system.
1160     Q_ASSERT(!d || (uint(system) > uint(QCalendar::System::Last))
1161              || (d->calendarId().index() == size_t(system)));
1162 }
1163 
1164 /*!
1165   \overload
1166   \since 6.2
1167 
1168   Constructs a calendar object.
1169 
1170   When using a custom calendar implementation, its backend is allocated a unique
1171   ID when created; passing that as \a id to this constructor will get a
1172   QCalendar using that backend. This can be useful when the backend is not
1173   registered by name.
1174 */
1175 QCalendar::QCalendar(QCalendar::SystemId id)
1176     : d(QCalendarBackend::fromId(id))
1177 {
1178     Q_ASSERT(!d || d->calendarId().index() == id.index());
1179 }
1180 
1181 QCalendar::QCalendar(QLatin1String name)
1182     : d(QCalendarBackend::fromName(name))
1183 {
1184     Q_ASSERT(!d || d->calendarId().isValid());
1185 }
1186 
1187 QCalendar::QCalendar(QStringView name)
1188     : d(QCalendarBackend::fromName(name))
1189 {
1190     Q_ASSERT(!d || d->calendarId().isValid());
1191 }
1192 
1193 /*!
1194     \fn bool QCalendar::isValid() const
1195 
1196     Returns true if this is a valid calendar object.
1197 
1198     Constructing a calendar with an unrecognised calendar name may result in an
1199     invalid object. Use this method to check after creating a calendar by name.
1200 */
1201 
1202 // Date queries:
1203 
1204 /*!
1205     Returns the number of days in the given \a month of the given \a year.
1206 
1207     Months are numbered consecutively, starting with 1 for the first month of
1208     each year. If \a year is \c Unspecified (its default, if not passed), the
1209     month's length in a normal year is returned.
1210 
1211     \sa maximumDaysInMonth(), minimumDaysInMonth()
1212 */
1213 int QCalendar::daysInMonth(int month, int year) const
1214 {
1215     return d ? d->daysInMonth(month, year) : 0;
1216 }
1217 
1218 /*!
1219     Returns the number of days in the given \a year.
1220 
1221     Handling of \c Unspecified as \a year is undefined.
1222 */
1223 int QCalendar::daysInYear(int year) const
1224 {
1225     return d ? d->daysInYear(year) : 0;
1226 }
1227 
1228 /*!
1229     Returns the number of months in the given \a year.
1230 
1231     If \a year is \c Unspecified, returns the maximum number of months in a
1232     year.
1233 
1234     \sa maximumMonthsInYear()
1235 */
1236 int QCalendar::monthsInYear(int year) const
1237 {
1238     return d ? year == Unspecified ? d->maximumMonthsInYear() : d->monthsInYear(year) : 0;
1239 }
1240 
1241 /*!
1242     Returns \c true precisely if the given \a year, \a month, and \a day specify
1243     a valid date in this calendar.
1244 
1245     Usually this means 1 <= month <= monthsInYear(year) and 1 <= day <=
1246     daysInMonth(month, year). However, calendars with intercallary days or
1247     months may complicate that.
1248 */
1249 bool QCalendar::isDateValid(int year, int month, int day) const
1250 {
1251     return d && d->isDateValid(year, month, day);
1252 }
1253 
1254 // properties of the calendar
1255 
1256 /*!
1257     Returns \c true if this calendar object is the Gregorian calendar object
1258     used as default calendar by other Qt APIs, e.g. in QDate.
1259 */
1260 bool QCalendar::isGregorian() const
1261 {
1262     return d && d->isGregorian();
1263 }
1264 
1265 /*!
1266     Returns \c true if the given \a year is a leap year.
1267 
1268     Since the year is not a whole number of days long, some years are longer
1269     than others. The difference may be a whole month or just a single day; the
1270     details vary between calendars.
1271 
1272     \sa isDateValid()
1273 */
1274 bool QCalendar::isLeapYear(int year) const
1275 {
1276     return d && d->isLeapYear(year);
1277 }
1278 
1279 /*!
1280     Returns \c true if this calendar is a lunar calendar.
1281 
1282     A lunar calendar is one based primarily on the phases of the moon.
1283 */
1284 bool QCalendar::isLunar() const
1285 {
1286     return d && d->isLunar();
1287 }
1288 
1289 /*!
1290     Returns \c true if this calendar is luni-solar.
1291 
1292     A luni-solar calendar expresses the phases of the moon but adapts itself to
1293     also keep track of the Sun's varying position in the sky, relative to the
1294     fixed stars.
1295 */
1296 bool QCalendar::isLuniSolar() const
1297 {
1298     return d && d->isLuniSolar();
1299 }
1300 
1301 /*!
1302     Returns \c true if this calendar is solar.
1303 
1304     A solar calendar is based primarily on the Sun's varying position in the
1305     sky, relative to the fixed stars.
1306 */
1307 bool QCalendar::isSolar() const
1308 {
1309     return d && d->isSolar();
1310 }
1311 
1312 /*!
1313     Returns \c true if this calendar is proleptic.
1314 
1315     A proleptic calendar is able to describe years arbitrarily long before its
1316     first. These are represented by negative year numbers and possibly by a year
1317     zero.
1318 
1319     \sa hasYearZero()
1320 */
1321 bool QCalendar::isProleptic() const
1322 {
1323     return d && d->isProleptic();
1324 }
1325 
1326 /*!
1327     Returns \c true if this calendar has a year zero.
1328 
1329     A calendar may represent years from its first year onwards but provide no
1330     way to describe years before its first; such a calendar has no year zero and
1331     is not proleptic.
1332 
1333     A calendar which represents years before its first may number these years
1334     simply by following the usual integer counting, so that the year before the
1335     first is year zero, with negative-numbered years preceding this; such a
1336     calendar is proleptic and has a year zero. A calendar might also have a year
1337     zero (for example, the year of some great event, with subsequent years being
1338     the first year after that event, the second year after, and so on) without
1339     describing years before its year zero. Such a calendar would have a year
1340     zero without being proleptic.
1341 
1342     Some calendars, however, represent years before their first by an alternate
1343     numbering; for example, the proleptic Gregorian calendar's first year is 1
1344     CE and the year before it is 1 BCE, preceded by 2 BCE and so on. In this
1345     case, we use negative year numbers for this alternate numbering, with year
1346     -1 as the year before year 1, year -2 as the year before year -1 and so
1347     on. Such a calendar is proleptic but has no year zero.
1348 
1349     \sa isProleptic()
1350 */
1351 bool QCalendar::hasYearZero() const
1352 {
1353     return d && d->hasYearZero();
1354 }
1355 
1356 /*!
1357     Returns the number of days in the longest month in the calendar, in any year.
1358 
1359     \sa daysInMonth(), minimumDaysInMonth()
1360 */
1361 int QCalendar::maximumDaysInMonth() const
1362 {
1363     return d ? d->maximumDaysInMonth() : 0;
1364 }
1365 
1366 /*!
1367     Returns the number of days in the shortest month in the calendar, in any year.
1368 
1369     \sa daysInMonth(), maximumDaysInMonth()
1370 */
1371 int QCalendar::minimumDaysInMonth() const
1372 {
1373     return d ? d->minimumDaysInMonth() : 0;
1374 }
1375 
1376 /*!
1377     Returns the largest number of months that any year may contain.
1378 
1379     \sa monthName(), standaloneMonthName(), monthsInYear()
1380 */
1381 int QCalendar::maximumMonthsInYear() const
1382 {
1383     return d ? d->maximumMonthsInYear() : 0;
1384 }
1385 
1386 // Julian Day conversions:
1387 
1388 /*!
1389     \fn QDate QCalendar::dateFromParts(int year, int month, int day) const
1390     \fn QDate QCalendar::dateFromParts(const QCalendar::YearMonthDay &parts) const
1391 
1392     Converts a year, month, and day to a QDate.
1393 
1394     The \a year, \a month, and \a day may be passed as separate numbers or
1395     packaged together as the members of \a parts. Returns a QDate with the given
1396     year, month, and day of the month in this calendar, if there is one.
1397     Otherwise, including the case where any of the values is
1398     QCalendar::Unspecified, returns a QDate whose isNull() is true.
1399 
1400     \sa isDateValid(), partsFromDate()
1401 */
1402 QDate QCalendar::dateFromParts(int year, int month, int day) const
1403 {
1404     qint64 jd;
1405     return d && d->dateToJulianDay(year, month, day, &jd)
1406         ? QDate::fromJulianDay(jd) : QDate();
1407 }
1408 
1409 QDate QCalendar::dateFromParts(const QCalendar::YearMonthDay &parts) const
1410 {
1411     return parts.isValid() ? dateFromParts(parts.year, parts.month, parts.day) : QDate();
1412 }
1413 
1414 /*!
1415     Converts a QDate to a year, month, and day of the month.
1416 
1417     The returned structure's isValid() shall be false if the calendar is unable
1418     to represent the given \a date. Otherwise its year, month, and day
1419     members record the so-named parts of its representation.
1420 
1421     \sa dateFromParts(), isProleptic(), hasYearZero()
1422 */
1423 QCalendar::YearMonthDay QCalendar::partsFromDate(QDate date) const
1424 {
1425     return d && date.isValid() ? d->julianDayToDate(date.toJulianDay()) : YearMonthDay();
1426 }
1427 
1428 /*!
1429     Returns the day of the week number for the given \a date.
1430 
1431     Returns zero if the calendar is unable to represent the indicated date.
1432     Returns 1 for Monday through 7 for Sunday. Calendars with intercallary days
1433     may use other numbers to represent these.
1434 
1435     \sa partsFromDate(), Qt::DayOfWeek
1436 */
1437 int QCalendar::dayOfWeek(QDate date) const
1438 {
1439     return d && date.isValid() ? d->dayOfWeek(date.toJulianDay()) : 0;
1440 }
1441 
1442 // Locale data access
1443 
1444 /*!
1445     Returns a suitably localised name for a month.
1446 
1447     The month is indicated by a number, with \a month = 1 meaning the first
1448     month of the year and subsequent months numbered accordingly. Returns an
1449     empty string if the \a month number is unrecognized.
1450 
1451     The \a year may be Unspecified, in which case the mapping from numbers to
1452     names for a typical year's months should be used. Some calendars have leap
1453     months that aren't always at the end of the year; their mapping of month
1454     numbers to names may then depend on the placement of a leap month. Thus the
1455     year should normally be specified, if known.
1456 
1457     The name is returned in the form that would normally be used in a full date,
1458     in the specified \a locale; the \a format determines how fully it shall be
1459     expressed (i.e. to what extent it is abbreviated).
1460 
1461     \sa standaloneMonthName(), maximumMonthsInYear(), dateTimeToString()
1462 */
1463 QString QCalendar::monthName(const QLocale &locale, int month, int year,
1464                              QLocale::FormatType format) const
1465 {
1466     const int maxMonth = year == Unspecified ? maximumMonthsInYear() : monthsInYear(year);
1467     if (!d || month < 1 || month > maxMonth)
1468         return QString();
1469 
1470     return d->monthName(locale, month, year, format);
1471 }
1472 
1473 /*!
1474     Returns a suitably localised standalone name for a month.
1475 
1476     The month is indicated by a number, with \a month = 1 meaning the first
1477     month of the year and subsequent months numbered accordingly. Returns an
1478     empty string if the \a month number is unrecognized.
1479 
1480     The \a year may be Unspecified, in which case the mapping from numbers to
1481     names for a typical year's months should be used. Some calendars have leap
1482     months that aren't always at the end of the year; their mapping of month
1483     numbers to names may then depend on the placement of a leap month. Thus the
1484     year should normally be specified, if known.
1485 
1486     The name is returned in the form that would be used in isolation in the
1487     specified \a locale; the \a format determines how fully it shall be
1488     expressed (i.e. to what extent it is abbreviated).
1489 
1490     \sa monthName(), maximumMonthsInYear(), dateTimeToString()
1491 */
1492 QString QCalendar::standaloneMonthName(const QLocale &locale, int month, int year,
1493                                        QLocale::FormatType format) const
1494 {
1495     const int maxMonth = year == Unspecified ? maximumMonthsInYear() : monthsInYear(year);
1496     if (!d || month < 1 || month > maxMonth)
1497         return QString();
1498 
1499     return d->standaloneMonthName(locale, month, year, format);
1500 }
1501 
1502 /*!
1503     Returns a suitably localised name for a day of the week.
1504 
1505     The days of the week are numbered from 1 for Monday through 7 for
1506     Sunday. Some calendars may support higher numbers for other days
1507     (e.g. intercallary days, that are not part of any week). Returns an empty
1508     string if the \a day number is unrecognized.
1509 
1510     The name is returned in the form that would normally be used in a full date,
1511     in the specified \a locale; the \a format determines how fully it shall be
1512     expressed (i.e. to what extent it is abbreviated).
1513 
1514     \sa standaloneWeekDayName(), dayOfWeek()
1515 */
1516 QString QCalendar::weekDayName(const QLocale &locale, int day,
1517                                QLocale::FormatType format) const
1518 {
1519     return d ? d->weekDayName(locale, day, format) : QString();
1520 }
1521 
1522 /*!
1523     Returns a suitably localised standalone name for a day of the week.
1524 
1525     The days of the week are numbered from 1 for Monday through 7 for
1526     Sunday. Some calendars may support higher numbers for other days
1527     (e.g. intercallary days, that are not part of any week). Returns an empty
1528     string if the \a day number is unrecognized.
1529 
1530     The name is returned in the form that would be used in isolation (for
1531     example as a column heading in a calendar's tabular display of a month with
1532     successive weeks as rows) in the specified \a locale; the \a format
1533     determines how fully it shall be expressed (i.e. to what extent it is
1534     abbreviated).
1535 
1536     \sa weekDayName(), dayOfWeek()
1537 */
1538 QString QCalendar::standaloneWeekDayName(const QLocale &locale, int day,
1539                                          QLocale::FormatType format) const
1540 {
1541     return d ? d->standaloneWeekDayName(locale, day, format) : QString();
1542 }
1543 
1544 /*!
1545     Returns a string representing a given date, time or date-time.
1546 
1547     If \a datetime is valid, it is represented and format specifiers for both
1548     date and time fields are recognized; otherwise, if \a dateOnly is valid, it
1549     is represented and only format specifiers for date fields are recognized;
1550     finally, if \a timeOnly is valid, it is represented and only format
1551     specifiers for time fields are recognized. If none of these is valid, an
1552     empty string is returned.
1553 
1554     See QDate::toString and QTime::toString() for the supported field
1555     specifiers.  Characters in \a format that are recognized as field specifiers
1556     are replaced by text representing appropriate data from the date and/or time
1557     being represented. The texts to represent them may depend on the \a locale
1558     specified. Other charagers in \a format are copied verbatim into the
1559     returned string.
1560 
1561     \sa monthName(), weekDayName(), QDate::toString(), QTime::toString()
1562 */
1563 QString QCalendar::dateTimeToString(QStringView format, const QDateTime &datetime,
1564                                     QDate dateOnly, QTime timeOnly,
1565                                     const QLocale &locale) const
1566 {
1567     return d ? d->dateTimeToString(format, datetime, dateOnly, timeOnly, locale) : QString();
1568 }
1569 
1570 /*!
1571     Returns a list of names of the available calendar systems.
1572 
1573     These may be supplied by plugins or other code linked into an application,
1574     in addition to the ones provided by Qt, some of which are controlled by
1575     features.
1576 */
1577 QStringList QCalendar::availableCalendars()
1578 {
1579     return QCalendarBackend::availableCalendars();
1580 }
1581 
1582 QT_END_NAMESPACE
