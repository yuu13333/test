Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtGui module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qcssparser_p.h"
41 
42 #include <qdebug.h>
43 #include <qicon.h>
44 #include <qcolor.h>
45 #include <qfont.h>
46 #include <qfileinfo.h>
47 #include <qfontmetrics.h>
48 #include <qbrush.h>
49 #include <qimagereader.h>
50 
51 #include <algorithm>
52 
53 #ifndef QT_NO_CSSPARSER
54 
55 QT_BEGIN_NAMESPACE
56 
57 #include "qcssscanner.cpp"
58 
59 using namespace QCss;
60 
61 struct QCssKnownValue
62 {
63     const char name[28];
64     quint64 id;
65 };
66 
67 static const QCssKnownValue properties[NumProperties - 1] = {
68     { "-qt-background-role", QtBackgroundRole },
69     { "-qt-block-indent", QtBlockIndent },
70     { "-qt-fg-texture-cachekey", QtForegroundTextureCacheKey },
71     { "-qt-line-height-type", QtLineHeightType },
72     { "-qt-list-indent", QtListIndent },
73     { "-qt-list-number-prefix", QtListNumberPrefix },
74     { "-qt-list-number-suffix", QtListNumberSuffix },
75     { "-qt-paragraph-type", QtParagraphType },
76     { "-qt-style-features", QtStyleFeatures },
77     { "-qt-table-type", QtTableType },
78     { "-qt-user-state", QtUserState },
79     { "alternate-background-color", QtAlternateBackground },
80     { "background", Background },
81     { "background-attachment", BackgroundAttachment },
82     { "background-clip", BackgroundClip },
83     { "background-color", BackgroundColor },
84     { "background-image", BackgroundImage },
85     { "background-origin", BackgroundOrigin },
86     { "background-position", BackgroundPosition },
87     { "background-repeat", BackgroundRepeat },
88     { "border", Border },
89     { "border-bottom", BorderBottom },
90     { "border-bottom-color", BorderBottomColor },
91     { "border-bottom-left-radius", BorderBottomLeftRadius },
92     { "border-bottom-right-radius", BorderBottomRightRadius },
93     { "border-bottom-style", BorderBottomStyle },
94     { "border-bottom-width", BorderBottomWidth },
95     { "border-collapse", BorderCollapse },
96     { "border-color", BorderColor },
97     { "border-image", BorderImage },
98     { "border-left", BorderLeft },
99     { "border-left-color", BorderLeftColor },
100     { "border-left-style", BorderLeftStyle },
101     { "border-left-width", BorderLeftWidth },
102     { "border-radius", BorderRadius },
103     { "border-right", BorderRight },
104     { "border-right-color", BorderRightColor },
105     { "border-right-style", BorderRightStyle },
106     { "border-right-width", BorderRightWidth },
107     { "border-style", BorderStyles },
108     { "border-top", BorderTop },
109     { "border-top-color", BorderTopColor },
110     { "border-top-left-radius", BorderTopLeftRadius },
111     { "border-top-right-radius", BorderTopRightRadius },
112     { "border-top-style", BorderTopStyle },
113     { "border-top-width", BorderTopWidth },
114     { "border-width", BorderWidth },
115     { "bottom", Bottom },
116     { "color", Color },
117     { "float", Float },
118     { "font", Font },
119     { "font-family", FontFamily },
120     { "font-kerning", FontKerning },
121     { "font-size", FontSize },
122     { "font-style", FontStyle },
123     { "font-variant", FontVariant },
124     { "font-weight", FontWeight },
125     { "height", Height },
126     { "icon", QtIcon },
127     { "image", QtImage },
128     { "image-position", QtImageAlignment },
129     { "left", Left },
130     { "line-height", LineHeight },
131     { "list-style", ListStyle },
132     { "list-style-type", ListStyleType },
133     { "margin" , Margin },
134     { "margin-bottom", MarginBottom },
135     { "margin-left", MarginLeft },
136     { "margin-right", MarginRight },
137     { "margin-top", MarginTop },
138     { "max-height", MaximumHeight },
139     { "max-width", MaximumWidth },
140     { "min-height", MinimumHeight },
141     { "min-width", MinimumWidth },
142     { "outline", Outline },
143     { "outline-bottom-left-radius", OutlineBottomLeftRadius },
144     { "outline-bottom-right-radius", OutlineBottomRightRadius },
145     { "outline-color", OutlineColor },
146     { "outline-offset", OutlineOffset },
147     { "outline-radius", OutlineRadius },
148     { "outline-style", OutlineStyle },
149     { "outline-top-left-radius", OutlineTopLeftRadius },
150     { "outline-top-right-radius", OutlineTopRightRadius },
151     { "outline-width", OutlineWidth },
152     { "padding", Padding },
153     { "padding-bottom", PaddingBottom },
154     { "padding-left", PaddingLeft },
155     { "padding-right", PaddingRight },
156     { "padding-top", PaddingTop },
157     { "page-break-after", PageBreakAfter },
158     { "page-break-before", PageBreakBefore },
159     { "position", Position },
160     { "right", Right },
161     { "selection-background-color", QtSelectionBackground },
162     { "selection-color", QtSelectionForeground },
163     { "spacing", QtSpacing },
164     { "subcontrol-origin", QtOrigin },
165     { "subcontrol-position", QtPosition },
166     { "text-align", TextAlignment },
167     { "text-decoration", TextDecoration },
168     { "text-indent", TextIndent },
169     { "text-transform", TextTransform },
170     { "text-underline-style", TextUnderlineStyle },
171     { "top", Top },
172     { "vertical-align", VerticalAlignment },
173     { "white-space", Whitespace },
174     { "width", Width }
175 };
176 
177 static const QCssKnownValue values[NumKnownValues - 1] = {
178     { "active", Value_Active },
179     { "alternate-base", Value_AlternateBase },
180     { "always", Value_Always },
181     { "auto", Value_Auto },
182     { "base", Value_Base },
183     { "bold", Value_Bold },
184     { "bottom", Value_Bottom },
185     { "bright-text", Value_BrightText },
186     { "button", Value_Button },
187     { "button-text", Value_ButtonText },
188     { "center", Value_Center },
189     { "circle", Value_Circle },
190     { "dark", Value_Dark },
191     { "dashed", Value_Dashed },
192     { "decimal", Value_Decimal },
193     { "disabled", Value_Disabled },
194     { "disc", Value_Disc },
195     { "dot-dash", Value_DotDash },
196     { "dot-dot-dash", Value_DotDotDash },
197     { "dotted", Value_Dotted },
198     { "double", Value_Double },
199     { "groove", Value_Groove },
200     { "highlight", Value_Highlight },
201     { "highlighted-text", Value_HighlightedText },
202     { "inset", Value_Inset },
203     { "italic", Value_Italic },
204     { "large", Value_Large },
205     { "left", Value_Left },
206     { "light", Value_Light },
207     { "line-through", Value_LineThrough },
208     { "link", Value_Link },
209     { "link-visited", Value_LinkVisited },
210     { "lower-alpha", Value_LowerAlpha },
211     { "lower-roman", Value_LowerRoman },
212     { "lowercase", Value_Lowercase },
213     { "medium", Value_Medium },
214     { "mid", Value_Mid },
215     { "middle", Value_Middle },
216     { "midlight", Value_Midlight },
217     { "native", Value_Native },
218     { "none", Value_None },
219     { "normal", Value_Normal },
220     { "nowrap", Value_NoWrap },
221     { "oblique", Value_Oblique },
222     { "off", Value_Off },
223     { "on", Value_On },
224     { "outset", Value_Outset },
225     { "overline", Value_Overline },
226     { "pre", Value_Pre },
227     { "pre-line", Value_PreLine },
228     { "pre-wrap", Value_PreWrap },
229     { "ridge", Value_Ridge },
230     { "right", Value_Right },
231     { "selected", Value_Selected },
232     { "shadow", Value_Shadow },
233     { "small" , Value_Small },
234     { "small-caps", Value_SmallCaps },
235     { "solid", Value_Solid },
236     { "square", Value_Square },
237     { "sub", Value_Sub },
238     { "super", Value_Super },
239     { "text", Value_Text },
240     { "top", Value_Top },
241     { "transparent", Value_Transparent },
242     { "underline", Value_Underline },
243     { "upper-alpha", Value_UpperAlpha },
244     { "upper-roman", Value_UpperRoman },
245     { "uppercase", Value_Uppercase },
246     { "wave", Value_Wave },
247     { "window", Value_Window },
248     { "window-text", Value_WindowText },
249     { "x-large", Value_XLarge },
250     { "xx-large", Value_XXLarge }
251 };
252 
253 //Map id to strings as they appears in the 'values' array above
254 static const short indexOfId[NumKnownValues] = { 0, 41, 48, 42, 49, 50, 55, 35, 26, 71, 72, 25, 43, 5, 64, 48,
255     29, 59, 60, 27, 52, 62, 6, 10, 39, 56, 19, 13, 17, 18, 20, 21, 51, 24, 46, 68, 37, 3, 2, 40, 63, 16,
256     11, 58, 14, 32, 65, 33, 66, 56, 67, 34, 70, 8, 28, 38, 12, 36, 61, 7, 9, 4, 69, 54, 22, 23, 30, 31,
257     1, 15, 0, 53, 45, 44 };
258 
259 QString Value::toString() const
260 {
261     if (type == KnownIdentifier) {
262         return QLatin1String(values[indexOfId[variant.toInt()]].name);
263     } else {
264         return variant.toString();
265     }
266 }
267 
268 static const QCssKnownValue pseudos[NumPseudos - 1] = {
269     { "active", PseudoClass_Active },
270     { "adjoins-item", PseudoClass_Item },
271     { "alternate", PseudoClass_Alternate },
272     { "bottom", PseudoClass_Bottom },
273     { "checked", PseudoClass_Checked },
274     { "closable", PseudoClass_Closable },
275     { "closed", PseudoClass_Closed },
276     { "default", PseudoClass_Default },
277     { "disabled", PseudoClass_Disabled },
278     { "edit-focus", PseudoClass_EditFocus },
279     { "editable", PseudoClass_Editable },
280     { "enabled", PseudoClass_Enabled },
281     { "exclusive", PseudoClass_Exclusive },
282     { "first", PseudoClass_First },
283     { "flat", PseudoClass_Flat },
284     { "floatable", PseudoClass_Floatable },
285     { "focus", PseudoClass_Focus },
286     { "has-children", PseudoClass_Children },
287     { "has-siblings", PseudoClass_Sibling },
288     { "horizontal", PseudoClass_Horizontal },
289     { "hover", PseudoClass_Hover },
290     { "indeterminate" , PseudoClass_Indeterminate },
291     { "last", PseudoClass_Last },
292     { "left", PseudoClass_Left },
293     { "maximized", PseudoClass_Maximized },
294     { "middle", PseudoClass_Middle },
295     { "minimized", PseudoClass_Minimized },
296     { "movable", PseudoClass_Movable },
297     { "next-selected", PseudoClass_NextSelected },
298     { "no-frame", PseudoClass_Frameless },
299     { "non-exclusive", PseudoClass_NonExclusive },
300     { "off", PseudoClass_Unchecked },
301     { "on", PseudoClass_Checked },
302     { "only-one", PseudoClass_OnlyOne },
303     { "open", PseudoClass_Open },
304     { "pressed", PseudoClass_Pressed },
305     { "previous-selected", PseudoClass_PreviousSelected },
306     { "read-only", PseudoClass_ReadOnly },
307     { "right", PseudoClass_Right },
308     { "selected", PseudoClass_Selected },
309     { "top", PseudoClass_Top },
310     { "unchecked" , PseudoClass_Unchecked },
311     { "vertical", PseudoClass_Vertical },
312     { "window", PseudoClass_Window }
313 };
314 
315 static const QCssKnownValue origins[NumKnownOrigins - 1] = {
316     { "border", Origin_Border },
317     { "content", Origin_Content },
318     { "margin", Origin_Margin }, // not in css
319     { "padding", Origin_Padding }
320 };
321 
322 static const QCssKnownValue repeats[NumKnownRepeats - 1] = {
323     { "no-repeat", Repeat_None },
324     { "repeat-x", Repeat_X },
325     { "repeat-xy", Repeat_XY },
326     { "repeat-y", Repeat_Y }
327 };
328 
329 static const QCssKnownValue tileModes[NumKnownTileModes - 1] = {
330     { "repeat", TileMode_Repeat },
331     { "round", TileMode_Round },
332     { "stretch", TileMode_Stretch },
333 };
334 
335 static const QCssKnownValue positions[NumKnownPositionModes - 1] = {
336     { "absolute", PositionMode_Absolute },
337     { "fixed", PositionMode_Fixed },
338     { "relative", PositionMode_Relative },
339     { "static", PositionMode_Static }
340 };
341 
342 static const QCssKnownValue attachments[NumKnownAttachments - 1] = {
343     { "fixed", Attachment_Fixed },
344     { "scroll", Attachment_Scroll }
345 };
346 
347 static const QCssKnownValue styleFeatures[NumKnownStyleFeatures - 1] = {
348     { "background-color", StyleFeature_BackgroundColor },
349     { "background-gradient", StyleFeature_BackgroundGradient },
350     { "none", StyleFeature_None }
351 };
352 
353 static bool operator<(const QString &name, const QCssKnownValue &prop)
354 {
355     return QString::compare(name, QLatin1String(prop.name), Qt::CaseInsensitive) < 0;
356 }
357 
358 static bool operator<(const QCssKnownValue &prop, const QString &name)
359 {
360     return QString::compare(QLatin1String(prop.name), name, Qt::CaseInsensitive) < 0;
361 }
362 
363 static quint64 findKnownValue(const QString &name, const QCssKnownValue *start, int numValues)
364 {
365     const QCssKnownValue *end = start + numValues - 1;
366     const QCssKnownValue *prop = std::lower_bound(start, end, name);
367     if ((prop == end) || (name < *prop))
368         return 0;
369     return prop->id;
370 }
371 
372 static inline bool isInheritable(Property propertyId)
373 {
374     switch (propertyId) {
375     case Font:
376     case FontKerning:
377     case FontFamily:
378     case FontSize:
379     case FontStyle:
380     case FontWeight:
381     case TextIndent:
382     case Whitespace:
383     case ListStyleType:
384     case ListStyle:
385     case TextAlignment:
386     case FontVariant:
387     case TextTransform:
388     case LineHeight:
389         return true;
390     default:
391         break;
392     }
393     return false;
394 }
395 
396 ///////////////////////////////////////////////////////////////////////////////
397 // Value Extractor
398 ValueExtractor::ValueExtractor(const QVector<Declaration> &decls, const QPalette &pal)
399 : declarations(decls), adjustment(0), fontExtracted(false), pal(pal)
400 {
401 }
402 
403 LengthData ValueExtractor::lengthValue(const Value& v)
404 {
405     const QString str = v.variant.toString();
406     QStringRef s(&str);
407     LengthData data;
408     data.unit = LengthData::None;
409     if (s.endsWith(QLatin1String("px"), Qt::CaseInsensitive))
410         data.unit = LengthData::Px;
411     else if (s.endsWith(QLatin1String("ex"), Qt::CaseInsensitive))
412         data.unit = LengthData::Ex;
413     else if (s.endsWith(QLatin1String("em"), Qt::CaseInsensitive))
414         data.unit = LengthData::Em;
415 
416     if (data.unit != LengthData::None)
417         s.chop(2);
418 
419     // raised lower limit due to the implementation of qRound()
420     data.number = qBound(double(INT_MIN)+0.1, s.toDouble(), double(INT_MAX));
421     return data;
422 }
423 
424 static int lengthValueFromData(const LengthData& data, const QFont& f)
425 {
426     if (data.unit == LengthData::Ex)
427         return qRound(QFontMetrics(f).xHeight() * data.number);
428     else if (data.unit == LengthData::Em)
429         return qRound(QFontMetrics(f).height() * data.number);
430     return qRound(data.number);
431 }
432 
433 int ValueExtractor::lengthValue(const Declaration &decl)
434 {
435     if (decl.d->parsed.isValid())
436         return  lengthValueFromData(qvariant_cast<LengthData>(decl.d->parsed), f);
437     if (decl.d->values.count() < 1)
438         return 0;
439     LengthData data = lengthValue(decl.d->values.at(0));
440     decl.d->parsed = QVariant::fromValue<LengthData>(data);
441     return lengthValueFromData(data,f);
442 }
443 
444 void ValueExtractor::lengthValues(const Declaration &decl, int *m)
445 {
446     if (decl.d->parsed.isValid()) {
447         QList<QVariant> v = decl.d->parsed.toList();
448         Q_ASSERT(v.size() == 4);
449         for (int i = 0; i < 4; i++)
450             m[i] = lengthValueFromData(qvariant_cast<LengthData>(v.at(i)), f);
451         return;
452     }
453 
454     LengthData datas[4];
455     int i;
456     for (i = 0; i < qMin(decl.d->values.count(), 4); i++)
457         datas[i] = lengthValue(decl.d->values[i]);
458 
459     if (i == 0) {
460         LengthData zero = {0.0, LengthData::None};
461         datas[0] = datas[1] = datas[2] = datas[3] = zero;
462     } else if (i == 1) {
463         datas[3] = datas[2] = datas[1] = datas[0];
464     } else if (i == 2) {
465         datas[2] = datas[0];
466         datas[3] = datas[1];
467     } else if (i == 3) {
468         datas[3] = datas[1];
469     }
470 
471     QList<QVariant> v;
472     v.reserve(4);
473     for (i = 0; i < 4; i++) {
474         v += QVariant::fromValue<LengthData>(datas[i]);
475         m[i] = lengthValueFromData(datas[i], f);
476     }
477     decl.d->parsed = v;
478 }
479 
480 bool ValueExtractor::extractGeometry(int *w, int *h, int *minw, int *minh, int *maxw, int *maxh)
481 {
482     extractFont();
483     bool hit = false;
484     for (int i = 0; i < declarations.count(); i++) {
485         const Declaration &decl = declarations.at(i);
486         switch (decl.d->propertyId) {
487         case Width: *w = lengthValue(decl); break;
488         case Height: *h = lengthValue(decl); break;
489         case MinimumWidth: *minw = lengthValue(decl); break;
490         case MinimumHeight: *minh = lengthValue(decl); break;
491         case MaximumWidth: *maxw = lengthValue(decl); break;
492         case MaximumHeight: *maxh = lengthValue(decl); break;
493         default: continue;
494         }
495         hit = true;
496     }
497 
498     return hit;
499 }
500 
501 bool ValueExtractor::extractPosition(int *left, int *top, int *right, int *bottom, QCss::Origin *origin,
502                                      Qt::Alignment *position, QCss::PositionMode *mode, Qt::Alignment *textAlignment)
503 {
504     extractFont();
505     bool hit = false;
506     for (int i = 0; i < declarations.count(); i++) {
507         const Declaration &decl = declarations.at(i);
508         switch (decl.d->propertyId) {
509         case Left: *left = lengthValue(decl); break;
510         case Top: *top = lengthValue(decl); break;
511         case Right: *right = lengthValue(decl); break;
512         case Bottom: *bottom = lengthValue(decl); break;
513         case QtOrigin: *origin = decl.originValue(); break;
514         case QtPosition: *position = decl.alignmentValue(); break;
515         case TextAlignment: *textAlignment = decl.alignmentValue(); break;
516         case Position: *mode = decl.positionValue(); break;
517         default: continue;
518         }
519         hit = true;
520     }
521 
522     return hit;
523 }
524 
525 bool ValueExtractor::extractBox(int *margins, int *paddings, int *spacing)
526 {
527     extractFont();
528     bool hit = false;
529     for (int i = 0; i < declarations.count(); i++) {
530         const Declaration &decl = declarations.at(i);
531         switch (decl.d->propertyId) {
532         case PaddingLeft: paddings[LeftEdge] = lengthValue(decl); break;
533         case PaddingRight: paddings[RightEdge] = lengthValue(decl); break;
534         case PaddingTop: paddings[TopEdge] = lengthValue(decl); break;
535         case PaddingBottom: paddings[BottomEdge] = lengthValue(decl); break;
536         case Padding: lengthValues(decl, paddings); break;
537 
538         case MarginLeft: margins[LeftEdge] = lengthValue(decl); break;
539         case MarginRight: margins[RightEdge] = lengthValue(decl); break;
540         case MarginTop: margins[TopEdge] = lengthValue(decl); break;
541         case MarginBottom: margins[BottomEdge] = lengthValue(decl); break;
542         case Margin: lengthValues(decl, margins); break;
543         case QtSpacing: if (spacing) *spacing = lengthValue(decl); break;
544 
545         default: continue;
546         }
547         hit = true;
548     }
549 
550     return hit;
551 }
552 
553 int ValueExtractor::extractStyleFeatures()
554 {
555     int features = StyleFeature_None;
556     for (int i = 0; i < declarations.count(); i++) {
557         const Declaration &decl = declarations.at(i);
558         if (decl.d->propertyId == QtStyleFeatures)
559             features = decl.styleFeaturesValue();
560     }
561     return features;
562 }
563 
564 QSize ValueExtractor::sizeValue(const Declaration &decl)
565 {
566     if (decl.d->parsed.isValid()) {
567         QList<QVariant> v = decl.d->parsed.toList();
568         return QSize(lengthValueFromData(qvariant_cast<LengthData>(v.at(0)), f),
569                      lengthValueFromData(qvariant_cast<LengthData>(v.at(1)), f));
570     }
571 
572     LengthData x[2] = { {0, LengthData::None }, {0, LengthData::None} };
573     if (decl.d->values.count() > 0)
574         x[0] = lengthValue(decl.d->values.at(0));
575     if (decl.d->values.count() > 1)
576         x[1] = lengthValue(decl.d->values.at(1));
577     else
578         x[1] = x[0];
579     QList<QVariant> v;
580     v << QVariant::fromValue<LengthData>(x[0]) << QVariant::fromValue<LengthData>(x[1]);
581     decl.d->parsed = v;
582     return QSize(lengthValueFromData(x[0], f), lengthValueFromData(x[1], f));
583 }
584 
585 void ValueExtractor::sizeValues(const Declaration &decl, QSize *radii)
586 {
587     radii[0] = sizeValue(decl);
588     for (int i = 1; i < 4; i++)
589         radii[i] = radii[0];
590 }
591 
592 bool ValueExtractor::extractBorder(int *borders, QBrush *colors, BorderStyle *styles,
593                                    QSize *radii)
594 {
595     extractFont();
596     bool hit = false;
597     for (int i = 0; i < declarations.count(); i++) {
598         const Declaration &decl = declarations.at(i);
599         switch (decl.d->propertyId) {
600         case BorderLeftWidth: borders[LeftEdge] = lengthValue(decl); break;
601         case BorderRightWidth: borders[RightEdge] = lengthValue(decl); break;
602         case BorderTopWidth: borders[TopEdge] = lengthValue(decl); break;
603         case BorderBottomWidth: borders[BottomEdge] = lengthValue(decl); break;
604         case BorderWidth: lengthValues(decl, borders); break;
605 
606         case BorderLeftColor: colors[LeftEdge] = decl.brushValue(pal); break;
607         case BorderRightColor: colors[RightEdge] = decl.brushValue(pal); break;
608         case BorderTopColor: colors[TopEdge] = decl.brushValue(pal); break;
609         case BorderBottomColor: colors[BottomEdge] = decl.brushValue(pal); break;
610         case BorderColor: decl.brushValues(colors, pal); break;
611 
612         case BorderTopStyle: styles[TopEdge] = decl.styleValue(); break;
613         case BorderBottomStyle: styles[BottomEdge] = decl.styleValue(); break;
614         case BorderLeftStyle: styles[LeftEdge] = decl.styleValue(); break;
615         case BorderRightStyle: styles[RightEdge] = decl.styleValue(); break;
616         case BorderStyles:  decl.styleValues(styles); break;
617 
618         case BorderTopLeftRadius: radii[0] = sizeValue(decl); break;
619         case BorderTopRightRadius: radii[1] = sizeValue(decl); break;
620         case BorderBottomLeftRadius: radii[2] = sizeValue(decl); break;
621         case BorderBottomRightRadius: radii[3] = sizeValue(decl); break;
622         case BorderRadius: sizeValues(decl, radii); break;
623 
624         case BorderLeft:
625             borderValue(decl, &borders[LeftEdge], &styles[LeftEdge], &colors[LeftEdge]);
626             break;
627         case BorderTop:
628             borderValue(decl, &borders[TopEdge], &styles[TopEdge], &colors[TopEdge]);
629             break;
630         case BorderRight:
631             borderValue(decl, &borders[RightEdge], &styles[RightEdge], &colors[RightEdge]);
632             break;
633         case BorderBottom:
634             borderValue(decl, &borders[BottomEdge], &styles[BottomEdge], &colors[BottomEdge]);
635             break;
636         case Border:
637             borderValue(decl, &borders[LeftEdge], &styles[LeftEdge], &colors[LeftEdge]);
638             borders[TopEdge] = borders[RightEdge] = borders[BottomEdge] = borders[LeftEdge];
639             styles[TopEdge] = styles[RightEdge] = styles[BottomEdge] = styles[LeftEdge];
640             colors[TopEdge] = colors[RightEdge] = colors[BottomEdge] = colors[LeftEdge];
641             break;
642 
643         default: continue;
644         }
645         hit = true;
646     }
647 
648     return hit;
649 }
650 
651 bool ValueExtractor::extractOutline(int *borders, QBrush *colors, BorderStyle *styles,
652                                    QSize *radii, int *offsets)
653 {
654     extractFont();
655     bool hit = false;
656     for (int i = 0; i < declarations.count(); i++) {
657         const Declaration &decl = declarations.at(i);
658         switch (decl.d->propertyId) {
659         case OutlineWidth: lengthValues(decl, borders); break;
660         case OutlineColor: decl.brushValues(colors, pal); break;
661         case OutlineStyle:  decl.styleValues(styles); break;
662 
663         case OutlineTopLeftRadius: radii[0] = sizeValue(decl); break;
664         case OutlineTopRightRadius: radii[1] = sizeValue(decl); break;
665         case OutlineBottomLeftRadius: radii[2] = sizeValue(decl); break;
666         case OutlineBottomRightRadius: radii[3] = sizeValue(decl); break;
667         case OutlineRadius: sizeValues(decl, radii); break;
668         case OutlineOffset: lengthValues(decl, offsets); break;
669 
670         case Outline:
671             borderValue(decl, &borders[LeftEdge], &styles[LeftEdge], &colors[LeftEdge]);
672             borders[TopEdge] = borders[RightEdge] = borders[BottomEdge] = borders[LeftEdge];
673             styles[TopEdge] = styles[RightEdge] = styles[BottomEdge] = styles[LeftEdge];
674             colors[TopEdge] = colors[RightEdge] = colors[BottomEdge] = colors[LeftEdge];
675             break;
676 
677         default: continue;
678         }
679         hit = true;
680     }
681 
682     return hit;
683 }
684 
685 static Qt::Alignment parseAlignment(const QCss::Value *values, int count)
686 {
687     Qt::Alignment a[2] = { { }, { } };
688     for (int i = 0; i < qMin(2, count); i++) {
689         if (values[i].type != Value::KnownIdentifier)
690             break;
691         switch (values[i].variant.toInt()) {
692         case Value_Left: a[i] = Qt::AlignLeft; break;
693         case Value_Right: a[i] = Qt::AlignRight; break;
694         case Value_Top: a[i] = Qt::AlignTop; break;
695         case Value_Bottom: a[i] = Qt::AlignBottom; break;
696         case Value_Center: a[i] = Qt::AlignCenter; break;
697         default: break;
698         }
699     }
700 
701     if (a[0] == Qt::AlignCenter && a[1] != 0 && a[1] != Qt::AlignCenter)
702         a[0] = (a[1] == Qt::AlignLeft || a[1] == Qt::AlignRight) ? Qt::AlignVCenter : Qt::AlignHCenter;
703     if ((a[1] == 0 || a[1] == Qt::AlignCenter) && a[0] != Qt::AlignCenter)
704         a[1] = (a[0] == Qt::AlignLeft || a[0] == Qt::AlignRight) ? Qt::AlignVCenter : Qt::AlignHCenter;
705     return a[0] | a[1];
706 }
707 
708 static ColorData parseColorValue(QCss::Value v)
709 {
710     if (v.type == Value::Identifier || v.type == Value::String) {
711         v.variant.convert(QMetaType::QColor);
712         v.type = Value::Color;
713     }
714 
715     if (v.type == Value::Color)
716         return qvariant_cast<QColor>(v.variant);
717 
718     if (v.type == Value::KnownIdentifier && v.variant.toInt() == Value_Transparent)
719         return QColor(Qt::transparent);
720 
721     if (v.type != Value::Function)
722         return ColorData();
723 
724     QStringList lst = v.variant.toStringList();
725     if (lst.count() != 2)
726         return ColorData();
727 
728     const QString &identifier = lst.at(0);
729     if ((identifier.compare(QLatin1String("palette"), Qt::CaseInsensitive)) == 0) {
730         int role = findKnownValue(lst.at(1).trimmed(), values, NumKnownValues);
731         if (role >= Value_FirstColorRole && role <= Value_LastColorRole)
732             return (QPalette::ColorRole)(role-Value_FirstColorRole);
733 
734         return ColorData();
735     }
736 
737     const bool rgb = identifier.startsWith(QLatin1String("rgb"));
738     const bool hsv = !rgb && identifier.startsWith(QLatin1String("hsv"));
739     const bool hsl = !rgb && !hsv && identifier.startsWith(QLatin1String("hsl"));
740 
741     if (!rgb && !hsv && !hsl)
742         return ColorData();
743 
744     const bool hasAlpha = identifier.size() == 4 && identifier.at(3) == QLatin1Char('a');
745     if (identifier.size() > 3 && !hasAlpha)
746         return ColorData();
747 
748     Parser p(lst.at(1));
749     if (!p.testExpr())
750         return ColorData();
751 
752     QVector<QCss::Value> colorDigits;
753     if (!p.parseExpr(&colorDigits))
754         return ColorData();
755     const int tokenCount = colorDigits.count();
756 
757     for (int i = 0; i < qMin(tokenCount, 7); i += 2) {
758         if (colorDigits.at(i).type == Value::Percentage) {
759             const qreal maxRange = (rgb || i != 0) ? 255. : 359.;
760             colorDigits[i].variant = colorDigits.at(i).variant.toReal() * (maxRange / 100.);
761             colorDigits[i].type = Value::Number;
762         } else if (colorDigits.at(i).type != Value::Number) {
763             return ColorData();
764         }
765     }
766 
767 
768     if (tokenCount < 5)
769         return ColorData();
770 
771     // ### Qt6: replace this with a check and return invalid color when token count does not match
772     if (hasAlpha && tokenCount != 7)
773         qWarning("QCssParser::parseColorValue: Specified color with alpha value but no alpha given: '%s'", qPrintable(lst.join(QLatin1Char(' '))));
774     if (!hasAlpha && tokenCount != 5)
775         qWarning("QCssParser::parseColorValue: Specified color without alpha value but alpha given: '%s'", qPrintable(lst.join(QLatin1Char(' '))));
776 
777     int v1 = colorDigits.at(0).variant.toInt();
778     int v2 = colorDigits.at(2).variant.toInt();
779     int v3 = colorDigits.at(4).variant.toInt();
780     int alpha = 255;
781     if (tokenCount == 7) {
782         int alphaValue = colorDigits.at(6).variant.toInt();
783         if (alphaValue <= 1)
784             alpha = colorDigits.at(6).variant.toReal() * 255.;
785         else
786             alpha = alphaValue;
787     }
788 
789     if (rgb)
790         return QColor::fromRgb(v1, v2, v3, alpha);
791     if (hsv)
792         return QColor::fromHsv(v1, v2, v3, alpha);
793     return QColor::fromHsl(v1, v2, v3, alpha);
794 }
795 
796 static QColor colorFromData(const ColorData& c, const QPalette &pal)
797 {
798     if (c.type == ColorData::Color) {
799         return c.color;
800     } else if (c.type == ColorData::Role) {
801         return pal.color(c.role);
802     }
803     return QColor();
804 }
805 
806 static BrushData parseBrushValue(const QCss::Value &v, const QPalette &pal)
807 {
808     ColorData c = parseColorValue(v);
809     if (c.type == ColorData::Color) {
810         return QBrush(c.color);
811     } else if (c.type == ColorData::Role) {
812         return c.role;
813     }
814 
815     if (v.type != Value::Function)
816         return BrushData();
817 
818     QStringList lst = v.variant.toStringList();
819     if (lst.count() != 2)
820         return BrushData();
821 
822     QStringList gradFuncs;
823     gradFuncs << QLatin1String("qlineargradient") << QLatin1String("qradialgradient") << QLatin1String("qconicalgradient") << QLatin1String("qgradient");
824     int gradType = -1;
825 
826     if ((gradType = gradFuncs.indexOf(lst.at(0).toLower())) == -1)
827         return BrushData();
828 
829     QHash<QString, qreal> vars;
830     QVector<QGradientStop> stops;
831 
832     int spread = -1;
833     QStringList spreads;
834     spreads << QLatin1String("pad") << QLatin1String("reflect") << QLatin1String("repeat");
835 
836     bool dependsOnThePalette = false;
837     Parser parser(lst.at(1));
838     while (parser.hasNext()) {
839         parser.skipSpace();
840         if (!parser.test(IDENT))
841             return BrushData();
842         QString attr = parser.lexem();
843         parser.skipSpace();
844         if (!parser.test(COLON))
845             return BrushData();
846         parser.skipSpace();
847         if (attr.compare(QLatin1String("stop"), Qt::CaseInsensitive) == 0) {
848             QCss::Value stop, color;
849             parser.next();
850             if (!parser.parseTerm(&stop)) return BrushData();
851             parser.skipSpace();
852             parser.next();
853             if (!parser.parseTerm(&color)) return BrushData();
854             ColorData cd = parseColorValue(color);
855             if(cd.type == ColorData::Role)
856                 dependsOnThePalette = true;
857             stops.append(QGradientStop(stop.variant.toReal(), colorFromData(cd, pal)));
858         } else {
859             parser.next();
860             QCss::Value value;
861             (void)parser.parseTerm(&value);
862             if (attr.compare(QLatin1String("spread"), Qt::CaseInsensitive) == 0) {
863                 spread = spreads.indexOf(value.variant.toString());
864             } else {
865                 vars[attr] = value.variant.toReal();
866             }
867         }
868         parser.skipSpace();
869         (void)parser.test(COMMA);
870     }
871 
872     if (gradType == 0) {
873         QLinearGradient lg(vars.value(QLatin1String("x1")), vars.value(QLatin1String("y1")),
874                            vars.value(QLatin1String("x2")), vars.value(QLatin1String("y2")));
875         lg.setCoordinateMode(QGradient::ObjectBoundingMode);
876         lg.setStops(stops);
877         if (spread != -1)
878             lg.setSpread(QGradient::Spread(spread));
879         BrushData bd = QBrush(lg);
880         if (dependsOnThePalette)
881             bd.type = BrushData::DependsOnThePalette;
882         return bd;
883     }
884 
885     if (gradType == 1) {
886         QRadialGradient rg(vars.value(QLatin1String("cx")), vars.value(QLatin1String("cy")),
887                            vars.value(QLatin1String("radius")), vars.value(QLatin1String("fx")),
888                            vars.value(QLatin1String("fy")));
889         rg.setCoordinateMode(QGradient::ObjectBoundingMode);
890         rg.setStops(stops);
891         if (spread != -1)
892             rg.setSpread(QGradient::Spread(spread));
893         BrushData bd = QBrush(rg);
894         if (dependsOnThePalette)
895             bd.type = BrushData::DependsOnThePalette;
896         return bd;
897     }
898 
899     if (gradType == 2) {
900         QConicalGradient cg(vars.value(QLatin1String("cx")), vars.value(QLatin1String("cy")),
901                             vars.value(QLatin1String("angle")));
902         cg.setCoordinateMode(QGradient::ObjectBoundingMode);
903         cg.setStops(stops);
904         if (spread != -1)
905             cg.setSpread(QGradient::Spread(spread));
906         BrushData bd = QBrush(cg);
907         if (dependsOnThePalette)
908             bd.type = BrushData::DependsOnThePalette;
909         return bd;
910     }
911 
912     return BrushData();
913 }
914 
915 static QBrush brushFromData(const BrushData& c, const QPalette &pal)
916 {
917     if (c.type == BrushData::Role) {
918         return pal.color(c.role);
919     } else {
920         return c.brush;
921     }
922 }
923 
924 static BorderStyle parseStyleValue(const QCss::Value &v)
925 {
926     if (v.type == Value::KnownIdentifier) {
927         switch (v.variant.toInt()) {
928         case Value_None:
929             return BorderStyle_None;
930         case Value_Dotted:
931             return BorderStyle_Dotted;
932         case Value_Dashed:
933             return BorderStyle_Dashed;
934         case Value_Solid:
935             return BorderStyle_Solid;
936         case Value_Double:
937             return BorderStyle_Double;
938         case Value_DotDash:
939             return BorderStyle_DotDash;
940         case Value_DotDotDash:
941             return BorderStyle_DotDotDash;
942         case Value_Groove:
943             return BorderStyle_Groove;
944         case Value_Ridge:
945             return BorderStyle_Ridge;
946         case Value_Inset:
947             return BorderStyle_Inset;
948         case Value_Outset:
949             return BorderStyle_Outset;
950         case Value_Native:
951             return BorderStyle_Native;
952         default:
953             break;
954         }
955     }
956 
957     return BorderStyle_Unknown;
958 }
959 
960 void ValueExtractor::borderValue(const Declaration &decl, int *width, QCss::BorderStyle *style, QBrush *color)
961 {
962     if (decl.d->parsed.isValid()) {
963         BorderData data = qvariant_cast<BorderData>(decl.d->parsed);
964         *width = lengthValueFromData(data.width, f);
965         *style = data.style;
966         *color = data.color.type != BrushData::Invalid ? brushFromData(data.color, pal) : QBrush(QColor());
967         return;
968     }
969 
970     *width = 0;
971     *style = BorderStyle_None;
972     *color = QColor();
973 
974     if (decl.d->values.isEmpty())
975         return;
976 
977     BorderData data;
978     data.width.number = 0;
979     data.width.unit = LengthData::None;
980     data.style = BorderStyle_None;
981 
982     int i = 0;
983     if (decl.d->values.at(i).type == Value::Length || decl.d->values.at(i).type == Value::Number) {
984         data.width = lengthValue(decl.d->values.at(i));
985         *width = lengthValueFromData(data.width, f);
986         if (++i >= decl.d->values.count()) {
987             decl.d->parsed = QVariant::fromValue<BorderData>(data);
988             return;
989         }
990     }
991 
992     data.style = parseStyleValue(decl.d->values.at(i));
993     if (data.style != BorderStyle_Unknown) {
994         *style = data.style;
995         if (++i >= decl.d->values.count()) {
996             decl.d->parsed = QVariant::fromValue<BorderData>(data);
997             return;
998         }
999     } else {
1000         data.style = BorderStyle_None;
1001     }
1002 
1003      data.color = parseBrushValue(decl.d->values.at(i), pal);
1004      *color = brushFromData(data.color, pal);
1005      if (data.color.type != BrushData::DependsOnThePalette)
1006          decl.d->parsed = QVariant::fromValue<BorderData>(data);
1007 }
1008 
1009 static void parseShorthandBackgroundProperty(const QVector<QCss::Value> &values, BrushData *brush, QString *image, Repeat *repeat, Qt::Alignment *alignment, const QPalette &pal)
1010 {
1011     *brush = BrushData();
1012     *image = QString();
1013     *repeat = Repeat_XY;
1014     *alignment = Qt::AlignTop | Qt::AlignLeft;
1015 
1016     for (int i = 0; i < values.count(); ++i) {
1017         const QCss::Value &v = values.at(i);
1018         if (v.type == Value::Uri) {
1019             *image = v.variant.toString();
1020             continue;
1021         } else if (v.type == Value::KnownIdentifier && v.variant.toInt() == Value_None) {
1022             *image = QString();
1023             continue;
1024         } else if (v.type == Value::KnownIdentifier && v.variant.toInt() == Value_Transparent) {
1025             *brush = QBrush(Qt::transparent);
1026         }
1027 
1028         Repeat repeatAttempt = static_cast<Repeat>(findKnownValue(v.variant.toString(),
1029                                                    repeats, NumKnownRepeats));
1030         if (repeatAttempt != Repeat_Unknown) {
1031             *repeat = repeatAttempt;
1032             continue;
1033         }
1034 
1035         if (v.type == Value::KnownIdentifier) {
1036             const int start = i;
1037             int count = 1;
1038             if (i < values.count() - 1
1039                 && values.at(i + 1).type == Value::KnownIdentifier) {
1040                 ++i;
1041                 ++count;
1042             }
1043             Qt::Alignment a = parseAlignment(values.constData() + start, count);
1044             if (int(a) != 0) {
1045                 *alignment = a;
1046                 continue;
1047             }
1048             i -= count - 1;
1049         }
1050 
1051         *brush = parseBrushValue(v, pal);
1052     }
1053 }
1054 
1055 bool ValueExtractor::extractBackground(QBrush *brush, QString *image, Repeat *repeat,
1056                                        Qt::Alignment *alignment, Origin *origin, Attachment *attachment,
1057                                        Origin *clip)
1058 {
1059     bool hit = false;
1060     for (int i = 0; i < declarations.count(); ++i) {
1061         const Declaration &decl = declarations.at(i);
1062         if (decl.d->values.isEmpty())
1063             continue;
1064         const QCss::Value &val = decl.d->values.at(0);
1065         switch (decl.d->propertyId) {
1066             case BackgroundColor:
1067                     *brush = decl.brushValue();
1068                 break;
1069             case BackgroundImage:
1070                 if (val.type == Value::Uri)
1071                     *image = val.variant.toString();
1072                 break;
1073             case BackgroundRepeat:
1074                 if (decl.d->parsed.isValid()) {
1075                     *repeat = static_cast<Repeat>(decl.d->parsed.toInt());
1076                 } else {
1077                     *repeat = static_cast<Repeat>(findKnownValue(val.variant.toString(),
1078                                                   repeats, NumKnownRepeats));
1079                     decl.d->parsed = *repeat;
1080                 }
1081                 break;
1082             case BackgroundPosition:
1083                 *alignment = decl.alignmentValue();
1084                 break;
1085             case BackgroundOrigin:
1086                 *origin = decl.originValue();
1087                 break;
1088             case BackgroundClip:
1089                 *clip = decl.originValue();
1090                 break;
1091             case Background:
1092                 if (decl.d->parsed.isValid()) {
1093                     BackgroundData data = qvariant_cast<BackgroundData>(decl.d->parsed);
1094                     *brush = brushFromData(data.brush, pal);
1095                     *image = data.image;
1096                     *repeat = data.repeat;
1097                     *alignment = data.alignment;
1098                 } else {
1099                     BrushData brushData;
1100                     parseShorthandBackgroundProperty(decl.d->values, &brushData, image, repeat, alignment, pal);
1101                     *brush = brushFromData(brushData, pal);
1102                     if (brushData.type != BrushData::DependsOnThePalette) {
1103                         BackgroundData data = { brushData, *image, *repeat, *alignment };
1104                         decl.d->parsed = QVariant::fromValue<BackgroundData>(data);
1105                     }
1106                 }
1107                 break;
1108             case BackgroundAttachment:
1109                 *attachment = decl.attachmentValue();
1110                 break;
1111             default: continue;
1112         }
1113         hit = true;
1114     }
1115     return hit;
1116 }
1117 
1118 static bool setFontSizeFromValue(QCss::Value value, QFont *font, int *fontSizeAdjustment)
1119 {
1120     if (value.type == Value::KnownIdentifier) {
1121         bool valid = true;
1122         switch (value.variant.toInt()) {
1123             case Value_Small: *fontSizeAdjustment = -1; break;
1124             case Value_Medium: *fontSizeAdjustment = 0; break;
1125             case Value_Large: *fontSizeAdjustment = 1; break;
1126             case Value_XLarge: *fontSizeAdjustment = 2; break;
1127             case Value_XXLarge: *fontSizeAdjustment = 3; break;
1128             default: valid = false; break;
1129         }
1130         return valid;
1131     }
1132     if (value.type != Value::Length)
1133         return false;
1134 
1135     bool valid = false;
1136     QString s = value.variant.toString();
1137     if (s.endsWith(QLatin1String("pt"), Qt::CaseInsensitive)) {
1138         s.chop(2);
1139         value.variant = s;
1140         if (value.variant.convert((QVariant::Type)qMetaTypeId<qreal>())) {
1141             font->setPointSizeF(value.variant.toReal());
1142             valid = true;
1143         }
1144     } else if (s.endsWith(QLatin1String("px"), Qt::CaseInsensitive)) {
1145         s.chop(2);
1146         value.variant = s;
1147         if (value.variant.convert(QMetaType::Int)) {
1148             font->setPixelSize(value.variant.toInt());
1149             valid = true;
1150         }
1151     }
1152     return valid;
1153 }
1154 
1155 static bool setFontStyleFromValue(const QCss::Value &value, QFont *font)
1156 {
1157     if (value.type != Value::KnownIdentifier)
1158         return false ;
1159     switch (value.variant.toInt()) {
1160         case Value_Normal: font->setStyle(QFont::StyleNormal); return true;
1161         case Value_Italic: font->setStyle(QFont::StyleItalic); return true;
1162         case Value_Oblique: font->setStyle(QFont::StyleOblique); return true;
1163         default: break;
1164     }
1165     return false;
1166 }
1167 
1168 static bool setFontKerningFromValue(const QCss::Value &value, QFont *font)
1169 {
1170     if (value.type != Value::KnownIdentifier)
1171         return false ;
1172     switch (value.variant.toInt()) {
1173         case Value_Normal: font->setKerning(true); return true;
1174         case Value_None: font->setKerning(false); return true;
1175         case Value_Auto: return true;
1176         default: break;
1177     }
1178     return false;
1179 }
1180 
1181 static bool setFontWeightFromValue(const QCss::Value &value, QFont *font)
1182 {
1183     if (value.type == Value::KnownIdentifier) {
1184         switch (value.variant.toInt()) {
1185             case Value_Normal: font->setWeight(QFont::Normal); return true;
1186             case Value_Bold: font->setWeight(QFont::Bold); return true;
1187             default: break;
1188         }
1189         return false;
1190     }
1191     if (value.type != Value::Number)
1192         return false;
1193     font->setWeight(qMin(value.variant.toInt() / 8, 99));
1194     return true;
1195 }
1196 
1197 /** \internal
1198  * parse the font family from the values (starting from index \a start)
1199  * and set it the \a font
1200  * The function returns \c true if a family was extracted.
1201  */
1202 static bool setFontFamilyFromValues(const QVector<QCss::Value> &values, QFont *font, int start = 0)
1203 {
1204     QString family;
1205     QStringList families;
1206     bool shouldAddSpace = false;
1207     for (int i = start; i < values.count(); ++i) {
1208         const QCss::Value &v = values.at(i);
1209         if (v.type == Value::TermOperatorComma) {
1210             families << family;
1211             family.clear();
1212             shouldAddSpace = false;
1213             continue;
1214         }
1215         const QString str = v.variant.toString();
1216         if (str.isEmpty())
1217             break;
1218         if (shouldAddSpace)
1219             family += QLatin1Char(' ');
1220         family += str;
1221         shouldAddSpace = true;
1222     }
1223     if (!family.isEmpty())
1224         families << family;
1225     if (families.isEmpty())
1226         return false;
1227     font->setFamily(families.at(0));
1228     font->setFamilies(families);
1229     return true;
1230 }
1231 
1232 static void setTextDecorationFromValues(const QVector<QCss::Value> &values, QFont *font)
1233 {
1234     for (int i = 0; i < values.count(); ++i) {
1235         if (values.at(i).type != Value::KnownIdentifier)
1236             continue;
1237         switch (values.at(i).variant.toInt()) {
1238             case Value_Underline: font->setUnderline(true); break;
1239             case Value_Overline: font->setOverline(true); break;
1240             case Value_LineThrough: font->setStrikeOut(true); break;
1241             case Value_None:
1242                 font->setUnderline(false);
1243                 font->setOverline(false);
1244                 font->setStrikeOut(false);
1245                 break;
1246             default: break;
1247         }
1248     }
1249 }
1250 
1251 static void parseShorthandFontProperty(const QVector<QCss::Value> &values, QFont *font, int *fontSizeAdjustment)
1252 {
1253     font->setStyle(QFont::StyleNormal);
1254     font->setWeight(QFont::Normal);
1255     *fontSizeAdjustment = -255;
1256 
1257     int i = 0;
1258     while (i < values.count()) {
1259         if (setFontStyleFromValue(values.at(i), font)
1260             || setFontWeightFromValue(values.at(i), font))
1261             ++i;
1262         else
1263             break;
1264     }
1265 
1266     if (i < values.count()) {
1267         setFontSizeFromValue(values.at(i), font, fontSizeAdjustment);
1268         ++i;
1269     }
1270 
1271     if (i < values.count()) {
1272         setFontFamilyFromValues(values, font, i);
1273     }
1274 }
1275 
1276 static void setFontVariantFromValue(const QCss::Value &value, QFont *font)
1277 {
1278     if (value.type == Value::KnownIdentifier) {
1279         switch (value.variant.toInt()) {
1280             case Value_Normal: font->setCapitalization(QFont::MixedCase); break;
1281             case Value_SmallCaps: font->setCapitalization(QFont::SmallCaps); break;
1282             default: break;
1283         }
1284     }
1285 }
1286 
1287 static void setTextTransformFromValue(const QCss::Value &value, QFont *font)
1288 {
1289     if (value.type == Value::KnownIdentifier) {
1290         switch (value.variant.toInt()) {
1291             case Value_None: font->setCapitalization(QFont::MixedCase); break;
1292             case Value_Uppercase: font->setCapitalization(QFont::AllUppercase); break;
1293             case Value_Lowercase: font->setCapitalization(QFont::AllLowercase); break;
1294             default: break;
1295         }
1296     }
1297 }
1298 
1299 bool ValueExtractor::extractFont(QFont *font, int *fontSizeAdjustment)
1300 {
1301     if (fontExtracted) {
1302         *font = f;
1303         *fontSizeAdjustment = adjustment;
1304         return fontExtracted == 1;
1305     }
1306 
1307     bool hit = false;
1308     for (int i = 0; i < declarations.count(); ++i) {
1309         const Declaration &decl = declarations.at(i);
1310         if (decl.d->values.isEmpty())
1311             continue;
1312         const QCss::Value &val = decl.d->values.at(0);
1313         switch (decl.d->propertyId) {
1314             case FontSize: setFontSizeFromValue(val, font, fontSizeAdjustment); break;
1315             case FontStyle: setFontStyleFromValue(val, font); break;
1316             case FontWeight: setFontWeightFromValue(val, font); break;
1317             case FontFamily: setFontFamilyFromValues(decl.d->values, font); break;
1318             case FontKerning: setFontKerningFromValue(val, font); break;
1319             case TextDecoration: setTextDecorationFromValues(decl.d->values, font); break;
1320             case Font: parseShorthandFontProperty(decl.d->values, font, fontSizeAdjustment); break;
1321             case FontVariant: setFontVariantFromValue(val, font); break;
1322             case TextTransform: setTextTransformFromValue(val, font); break;
1323             default: continue;
1324         }
1325         hit = true;
1326     }
1327 
1328     f = *font;
1329     adjustment = *fontSizeAdjustment;
1330     fontExtracted = hit ? 1 : 2;
1331     return hit;
1332 }
1333 
1334 bool ValueExtractor::extractPalette(QBrush *fg, QBrush *sfg, QBrush *sbg, QBrush *abg)
1335 {
1336     bool hit = false;
1337     for (int i = 0; i < declarations.count(); ++i) {
1338         const Declaration &decl = declarations.at(i);
1339         switch (decl.d->propertyId) {
1340         case Color: *fg = decl.brushValue(pal); break;
1341         case QtSelectionForeground: *sfg = decl.brushValue(pal); break;
1342         case QtSelectionBackground: *sbg = decl.brushValue(pal); break;
1343         case QtAlternateBackground: *abg = decl.brushValue(pal); break;
1344         default: continue;
1345         }
1346         hit = true;
1347     }
1348     return hit;
1349 }
1350 
1351 void ValueExtractor::extractFont()
1352 {
1353     if (fontExtracted)
1354         return;
1355     int dummy = -255;
1356     extractFont(&f, &dummy);
1357 }
1358 
1359 bool ValueExtractor::extractImage(QIcon *icon, Qt::Alignment *a, QSize *size)
1360 {
1361     bool hit = false;
1362     for (int i = 0; i < declarations.count(); ++i) {
1363         const Declaration &decl = declarations.at(i);
1364         switch (decl.d->propertyId) {
1365         case QtImage:
1366             *icon = decl.iconValue();
1367             if (decl.d->values.count() > 0 && decl.d->values.at(0).type == Value::Uri) {
1368                 // try to pull just the size from the image...
1369                 QImageReader imageReader(decl.d->values.at(0).variant.toString());
1370                 if ((*size = imageReader.size()).isNull()) {
1371                     // but we'll have to load the whole image if the
1372                     // format doesn't support just reading the size
1373                     *size = imageReader.read().size();
1374                 }
1375             }
1376             break;
1377         case QtImageAlignment: *a = decl.alignmentValue();  break;
1378         default: continue;
1379         }
1380         hit = true;
1381     }
1382     return hit;
1383 }
1384 
1385 bool ValueExtractor::extractIcon(QIcon *icon, QSize *size)
1386 {
1387     // Find last declaration that specifies an icon
1388     const auto declaration = std::find_if(
1389                 declarations.rbegin(), declarations.rend(),
1390                 [](const Declaration &decl) { return decl.d->propertyId == QtIcon; });
1391     if (declaration == declarations.rend())
1392         return false;
1393 
1394     *icon = declaration->iconValue();
1395 
1396     // If the value contains a URI, try to get the size of the icon
1397     if (declaration->d->values.isEmpty())
1398         return true;
1399 
1400     const auto &propertyValue = declaration->d->values.constFirst();
1401     if (propertyValue.type != Value::Uri)
1402         return true;
1403 
1404     // First try to read just the size from the image without loading it
1405     const QString url(propertyValue.variant.toString());
1406     QImageReader imageReader(url);
1407     *size = imageReader.size();
1408     if (!size->isNull())
1409         return true;
1410 
1411     // Get the size by loading the image instead
1412     *size = imageReader.read().size();
1413     return true;
1414 }
1415 
1416 ///////////////////////////////////////////////////////////////////////////////
1417 // Declaration
1418 QColor Declaration::colorValue(const QPalette &pal) const
1419 {
1420     if (d->values.count() != 1)
1421         return QColor();
1422 
1423     if (d->parsed.isValid()) {
1424         if (d->parsed.userType() == QMetaType::QColor)
1425             return qvariant_cast<QColor>(d->parsed);
1426         if (d->parsed.userType() == QMetaType::Int)
1427             return pal.color((QPalette::ColorRole)(d->parsed.toInt()));
1428     }
1429 
1430     ColorData color = parseColorValue(d->values.at(0));
1431     if(color.type == ColorData::Role) {
1432         d->parsed = QVariant::fromValue<int>(color.role);
1433         return pal.color((QPalette::ColorRole)(color.role));
1434     } else {
1435         d->parsed = QVariant::fromValue<QColor>(color.color);
1436         return color.color;
1437     }
1438 }
1439 
1440 QBrush Declaration::brushValue(const QPalette &pal) const
1441 {
1442     if (d->values.count() != 1)
1443         return QBrush();
1444 
1445     if (d->parsed.isValid()) {
1446         if (d->parsed.userType() == QMetaType::QBrush)
1447             return qvariant_cast<QBrush>(d->parsed);
1448         if (d->parsed.userType() == QMetaType::Int)
1449             return pal.color((QPalette::ColorRole)(d->parsed.toInt()));
1450     }
1451 
1452     BrushData data = parseBrushValue(d->values.at(0), pal);
1453 
1454     if(data.type == BrushData::Role) {
1455         d->parsed = QVariant::fromValue<int>(data.role);
1456         return pal.color((QPalette::ColorRole)(data.role));
1457     } else {
1458         if (data.type != BrushData::DependsOnThePalette)
1459             d->parsed = QVariant::fromValue<QBrush>(data.brush);
1460         return data.brush;
1461     }
1462 }
1463 
1464 void Declaration::brushValues(QBrush *c, const QPalette &pal) const
1465 {
1466     int needParse = 0x1f; // bits 0..3 say if we should parse the corresponding value.
1467                           // the bit 4 say we need to update d->parsed
1468     int i = 0;
1469     if (d->parsed.isValid()) {
1470         needParse = 0;
1471         QList<QVariant> v = d->parsed.toList();
1472         for (i = 0; i < qMin(v.count(), 4); i++) {
1473             if (v.at(i).userType() == QMetaType::QBrush) {
1474                 c[i] = qvariant_cast<QBrush>(v.at(i));
1475             } else if (v.at(i).userType() == QMetaType::Int) {
1476                 c[i] = pal.color((QPalette::ColorRole)(v.at(i).toInt()));
1477             } else {
1478                 needParse |= (1<<i);
1479             }
1480         }
1481     }
1482     if (needParse != 0) {
1483         QList<QVariant> v;
1484         for (i = 0; i < qMin(d->values.count(), 4); i++) {
1485             if (!(needParse & (1<<i)))
1486                 continue;
1487             BrushData data = parseBrushValue(d->values.at(i), pal);
1488             if(data.type == BrushData::Role) {
1489                 v += QVariant::fromValue<int>(data.role);
1490                 c[i] = pal.color((QPalette::ColorRole)(data.role));
1491             } else {
1492                 if (data.type != BrushData::DependsOnThePalette) {
1493                     v += QVariant::fromValue<QBrush>(data.brush);
1494                 } else {
1495                     v += QVariant();
1496                 }
1497                 c[i] = data.brush;
1498             }
1499         }
1500         if (needParse & 0x10)
1501             d->parsed = v;
1502     }
1503     if (i == 0) c[0] = c[1] = c[2] = c[3] = QBrush();
1504     else if (i == 1) c[3] = c[2] = c[1] = c[0];
1505     else if (i == 2) c[2] = c[0], c[3] = c[1];
1506     else if (i == 3) c[3] = c[1];
1507 }
1508 
1509 bool Declaration::realValue(qreal *real, const char *unit) const
1510 {
1511     if (d->values.count() != 1)
1512         return false;
1513     const Value &v = d->values.at(0);
1514     if (unit && v.type != Value::Length)
1515         return false;
1516     const QString str = v.variant.toString();
1517     QStringRef s(&str);
1518     if (unit) {
1519         const QLatin1String unitStr(unit);
1520         if (!s.endsWith(unitStr, Qt::CaseInsensitive))
1521             return false;
1522         s.chop(unitStr.size());
1523     }
1524     bool ok = false;
1525     qreal val = s.toDouble(&ok);
1526     if (ok)
1527         *real = val;
1528     return ok;
1529 }
1530 
1531 static bool intValueHelper(const QCss::Value &v, int *i, const char *unit)
1532 {
1533     if (unit && v.type != Value::Length)
1534         return false;
1535     const QString str = v.variant.toString();
1536     QStringRef s(&str);
1537     if (unit) {
1538         const QLatin1String unitStr(unit);
1539         if (!s.endsWith(unitStr, Qt::CaseInsensitive))
1540             return false;
1541         s.chop(unitStr.size());
1542     }
1543     bool ok = false;
1544     int val = s.toInt(&ok);
1545     if (ok)
1546         *i = val;
1547     return ok;
1548 }
1549 
1550 bool Declaration::intValue(int *i, const char *unit) const
1551 {
1552     if (d->values.count() != 1)
1553         return false;
1554     return intValueHelper(d->values.at(0), i, unit);
1555 }
1556 
1557 QSize Declaration::sizeValue() const
1558 {
1559     if (d->parsed.isValid())
1560         return qvariant_cast<QSize>(d->parsed);
1561 
1562     int x[2] = { 0, 0 };
1563     if (d->values.count() > 0)
1564         intValueHelper(d->values.at(0), &x[0], "px");
1565     if (d->values.count() > 1)
1566         intValueHelper(d->values.at(1), &x[1], "px");
1567     else
1568         x[1] = x[0];
1569     QSize size(x[0], x[1]);
1570     d->parsed = QVariant::fromValue<QSize>(size);
1571     return size;
1572 }
1573 
1574 QRect Declaration::rectValue() const
1575 {
1576     if (d->values.count() != 1)
1577         return QRect();
1578 
1579     if (d->parsed.isValid())
1580         return qvariant_cast<QRect>(d->parsed);
1581 
1582     const QCss::Value &v = d->values.at(0);
1583     if (v.type != Value::Function)
1584         return QRect();
1585     const QStringList func = v.variant.toStringList();
1586     if (func.count() != 2 || func.at(0).compare(QLatin1String("rect")) != 0)
1587         return QRect();
1588     const auto args = func[1].splitRef(QLatin1Char(' '), Qt::SkipEmptyParts);
1589     if (args.count() != 4)
1590         return QRect();
1591     QRect rect(args[0].toInt(), args[1].toInt(), args[2].toInt(), args[3].toInt());
1592     d->parsed = QVariant::fromValue<QRect>(rect);
1593     return rect;
1594 }
1595 
1596 void Declaration::colorValues(QColor *c, const QPalette &pal) const
1597 {
1598     int i;
1599     if (d->parsed.isValid()) {
1600         QList<QVariant> v = d->parsed.toList();
1601         for (i = 0; i < qMin(d->values.count(), 4); i++) {
1602             if (v.at(i).userType() == QMetaType::QColor) {
1603                 c[i] = qvariant_cast<QColor>(v.at(i));
1604             } else {
1605                 c[i] = pal.color((QPalette::ColorRole)(v.at(i).toInt()));
1606             }
1607         }
1608     } else {
1609         QList<QVariant> v;
1610         for (i = 0; i < qMin(d->values.count(), 4); i++) {
1611             ColorData color = parseColorValue(d->values.at(i));
1612             if(color.type == ColorData::Role) {
1613                 v += QVariant::fromValue<int>(color.role);
1614                 c[i] = pal.color((QPalette::ColorRole)(color.role));
1615             } else {
1616                 v += QVariant::fromValue<QColor>(color.color);
1617                 c[i] = color.color;
1618             }
1619         }
1620         d->parsed = v;
1621     }
1622 
1623     if (i == 0) c[0] = c[1] = c[2] = c[3] = QColor();
1624     else if (i == 1) c[3] = c[2] = c[1] = c[0];
1625     else if (i == 2) c[2] = c[0], c[3] = c[1];
1626     else if (i == 3) c[3] = c[1];
1627 }
1628 
1629 BorderStyle Declaration::styleValue() const
1630 {
1631     if (d->values.count() != 1)
1632         return BorderStyle_None;
1633     return parseStyleValue(d->values.at(0));
1634 }
1635 
1636 void Declaration::styleValues(BorderStyle *s) const
1637 {
1638     int i;
1639     for (i = 0; i < qMin(d->values.count(), 4); i++)
1640         s[i] = parseStyleValue(d->values.at(i));
1641     if (i == 0) s[0] = s[1] = s[2] = s[3] = BorderStyle_None;
1642     else if (i == 1) s[3] = s[2] = s[1] = s[0];
1643     else if (i == 2) s[2] = s[0], s[3] = s[1];
1644     else if (i == 3) s[3] = s[1];
1645 }
1646 
1647 Repeat Declaration::repeatValue() const
1648 {
1649     if (d->parsed.isValid())
1650         return static_cast<Repeat>(d->parsed.toInt());
1651     if (d->values.count() != 1)
1652         return Repeat_Unknown;
1653     int v = findKnownValue(d->values.at(0).variant.toString(),
1654                    repeats, NumKnownRepeats);
1655     d->parsed = v;
1656     return static_cast<Repeat>(v);
1657 }
1658 
1659 Origin Declaration::originValue() const
1660 {
1661     if (d->parsed.isValid())
1662         return static_cast<Origin>(d->parsed.toInt());
1663     if (d->values.count() != 1)
1664         return Origin_Unknown;
1665     int v = findKnownValue(d->values.at(0).variant.toString(),
1666                                origins, NumKnownOrigins);
1667     d->parsed = v;
1668     return static_cast<Origin>(v);
1669 }
1670 
1671 PositionMode Declaration::positionValue() const
1672 {
1673     if (d->parsed.isValid())
1674         return static_cast<PositionMode>(d->parsed.toInt());
1675     if (d->values.count() != 1)
1676         return PositionMode_Unknown;
1677     int v = findKnownValue(d->values.at(0).variant.toString(),
1678                            positions, NumKnownPositionModes);
1679     d->parsed = v;
1680     return static_cast<PositionMode>(v);
1681 }
1682 
1683 Attachment Declaration::attachmentValue() const
1684 {
1685     if (d->parsed.isValid())
1686         return static_cast<Attachment>(d->parsed.toInt());
1687     if (d->values.count() != 1)
1688         return Attachment_Unknown;
1689     int v = findKnownValue(d->values.at(0).variant.toString(),
1690                            attachments, NumKnownAttachments);
1691     d->parsed = v;
1692     return static_cast<Attachment>(v);
1693 }
1694 
1695 int Declaration::styleFeaturesValue() const
1696 {
1697     Q_ASSERT(d->propertyId == QtStyleFeatures);
1698     if (d->parsed.isValid())
1699         return d->parsed.toInt();
1700     int features = StyleFeature_None;
1701     for (int i = 0; i < d->values.count(); i++) {
1702         features |= static_cast<int>(findKnownValue(d->values.value(i).variant.toString(),
1703                                      styleFeatures, NumKnownStyleFeatures));
1704     }
1705     d->parsed = features;
1706     return features;
1707 }
1708 
1709 QString Declaration::uriValue() const
1710 {
1711     if (d->values.isEmpty() || d->values.at(0).type != Value::Uri)
1712         return QString();
1713     return d->values.at(0).variant.toString();
1714 }
1715 
1716 Qt::Alignment Declaration::alignmentValue() const
1717 {
1718     if (d->parsed.isValid())
1719         return Qt::Alignment(d->parsed.toInt());
1720     if (d->values.isEmpty() || d->values.count() > 2)
1721         return Qt::AlignLeft | Qt::AlignTop;
1722 
1723     Qt::Alignment v = parseAlignment(d->values.constData(), d->values.count());
1724     d->parsed = int(v);
1725     return v;
1726 }
1727 
1728 void Declaration::borderImageValue(QString *image, int *cuts,
1729                                    TileMode *h, TileMode *v) const
1730 {
1731     const DeclarationData *d = this->d.data(); // make it const and shadow d
1732     *image = uriValue();
1733     for (int i = 0; i < 4; i++)
1734         cuts[i] = -1;
1735     *h = *v = TileMode_Stretch;
1736 
1737     if (d->values.count() < 2)
1738         return;
1739 
1740     if (d->values.at(1).type == Value::Number) { // cuts!
1741         int i;
1742         for (i = 0; i < qMin(d->values.count()-1, 4); i++) {
1743             const Value& v = d->values.at(i+1);
1744             if (v.type != Value::Number)
1745                 break;
1746             cuts[i] = v.variant.toString().toInt();
1747         }
1748         if (i == 0) cuts[0] = cuts[1] = cuts[2] = cuts[3] = 0;
1749         else if (i == 1) cuts[3] = cuts[2] = cuts[1] = cuts[0];
1750         else if (i == 2) cuts[2] = cuts[0], cuts[3] = cuts[1];
1751         else if (i == 3) cuts[3] = cuts[1];
1752     }
1753 
1754     if (d->values.last().type == Value::Identifier) {
1755         *v = static_cast<TileMode>(findKnownValue(d->values.last().variant.toString(),
1756                                       tileModes, NumKnownTileModes));
1757     }
1758     if (d->values[d->values.count() - 2].type == Value::Identifier) {
1759         *h = static_cast<TileMode>
1760                 (findKnownValue(d->values[d->values.count()-2].variant.toString(),
1761                                         tileModes, NumKnownTileModes));
1762     } else
1763         *h = *v;
1764 }
1765 
1766 bool Declaration::borderCollapseValue() const
1767 {
1768     if (d->values.count() != 1)
1769         return false;
1770     else
1771         return d->values.at(0).toString() == QLatin1String("collapse");
1772 }
1773 
1774 QIcon Declaration::iconValue() const
1775 {
1776     if (d->parsed.isValid())
1777         return qvariant_cast<QIcon>(d->parsed);
1778 
1779     QIcon icon;
1780     for (int i = 0; i < d->values.count();) {
1781         const Value &value = d->values.at(i++);
1782         if (value.type != Value::Uri)
1783             break;
1784         QString uri = value.variant.toString();
1785         QIcon::Mode mode = QIcon::Normal;
1786         QIcon::State state = QIcon::Off;
1787         for (int j = 0; j < 2; j++) {
1788             if (i != d->values.count() && d->values.at(i).type == Value::KnownIdentifier) {
1789                 switch (d->values.at(i).variant.toInt()) {
1790                 case Value_Disabled: mode = QIcon::Disabled; break;
1791                 case Value_Active: mode = QIcon::Active; break;
1792                 case Value_Selected: mode = QIcon::Selected; break;
1793                 case Value_Normal: mode = QIcon::Normal; break;
1794                 case Value_On: state = QIcon::On; break;
1795                 case Value_Off: state = QIcon::Off; break;
1796                 default: break;
1797                 }
1798                 ++i;
1799             } else {
1800                 break;
1801             }
1802         }
1803 
1804         // QIcon is soo broken
1805         if (icon.isNull())
1806             icon = QIcon(uri);
1807         else
1808             icon.addPixmap(uri, mode, state);
1809 
1810         if (i == d->values.count())
1811             break;
1812 
1813         if (d->values.at(i).type == Value::TermOperatorComma)
1814             i++;
1815     }
1816 
1817     d->parsed = QVariant::fromValue<QIcon>(icon);
1818     return icon;
1819 }
1820 
1821 ///////////////////////////////////////////////////////////////////////////////
1822 // Selector
1823 int Selector::specificity() const
1824 {
1825     int val = 0;
1826     for (int i = 0; i < basicSelectors.count(); ++i) {
1827         const BasicSelector &sel = basicSelectors.at(i);
1828         if (!sel.elementName.isEmpty())
1829             val += 1;
1830 
1831         val += (sel.pseudos.count() + sel.attributeSelectors.count()) * 0x10;
1832         val += sel.ids.count() * 0x100;
1833     }
1834     return val;
1835 }
1836 
1837 QString Selector::pseudoElement() const
1838 {
1839     const BasicSelector& bs = basicSelectors.last();
1840     if (!bs.pseudos.isEmpty() && bs.pseudos.at(0).type == PseudoClass_Unknown)
1841         return bs.pseudos.at(0).name;
1842     return QString();
1843 }
1844 
1845 quint64 Selector::pseudoClass(quint64 *negated) const
1846 {
1847     const BasicSelector& bs = basicSelectors.last();
1848     if (bs.pseudos.isEmpty())
1849         return PseudoClass_Unspecified;
1850     quint64 pc = PseudoClass_Unknown;
1851     for (int i = !pseudoElement().isEmpty(); i < bs.pseudos.count(); i++) {
1852         const Pseudo &pseudo = bs.pseudos.at(i);
1853         if (pseudo.type == PseudoClass_Unknown)
1854             return PseudoClass_Unknown;
1855         if (!pseudo.negated)
1856             pc |= pseudo.type;
1857         else if (negated)
1858             *negated |= pseudo.type;
1859     }
1860     return pc;
1861 }
1862 
1863 ///////////////////////////////////////////////////////////////////////////////
1864 // StyleSheet
1865 void StyleSheet::buildIndexes(Qt::CaseSensitivity nameCaseSensitivity)
1866 {
1867     QVector<StyleRule> universals;
1868     for (int i = 0; i < styleRules.count(); ++i) {
1869         const StyleRule &rule = styleRules.at(i);
1870         QVector<Selector> universalsSelectors;
1871         for (int j = 0; j < rule.selectors.count(); ++j) {
1872             const Selector& selector = rule.selectors.at(j);
1873 
1874             if (selector.basicSelectors.isEmpty())
1875                 continue;
1876 
1877             if (selector.basicSelectors.at(0).relationToNext == BasicSelector::NoRelation) {
1878                 if (selector.basicSelectors.count() != 1)
1879                     continue;
1880             } else if (selector.basicSelectors.count() <= 1) {
1881                 continue;
1882             }
1883 
1884             const BasicSelector &sel = selector.basicSelectors.at(selector.basicSelectors.count() - 1);
1885 
1886             if (!sel.ids.isEmpty()) {
1887                 StyleRule nr;
1888                 nr.selectors += selector;
1889                 nr.declarations = rule.declarations;
1890                 nr.order = i;
1891                 idIndex.insert(sel.ids.at(0), nr);
1892             } else if (!sel.elementName.isEmpty()) {
1893                 StyleRule nr;
1894                 nr.selectors += selector;
1895                 nr.declarations = rule.declarations;
1896                 nr.order = i;
1897                 QString name = sel.elementName;
1898                 if (nameCaseSensitivity == Qt::CaseInsensitive)
1899                     name = std::move(name).toLower();
1900                 nameIndex.insert(name, nr);
1901             } else {
1902                 universalsSelectors += selector;
1903             }
1904         }
1905         if (!universalsSelectors.isEmpty()) {
1906             StyleRule nr;
1907             nr.selectors = universalsSelectors;
1908             nr.declarations = rule.declarations;
1909             nr.order = i;
1910             universals << nr;
1911         }
1912     }
1913     styleRules = universals;
1914 }
1915 
1916 ///////////////////////////////////////////////////////////////////////////////
1917 // StyleSelector
1918 StyleSelector::~StyleSelector()
1919 {
1920 }
1921 
1922 bool StyleSelector::nodeNameEquals(NodePtr node, const QString& nodeName) const
1923 {
1924     return nodeNames(node).contains(nodeName, nameCaseSensitivity);
1925 }
1926 
1927 QStringList StyleSelector::nodeIds(NodePtr node) const
1928 {
1929     return QStringList(attribute(node, QLatin1String("id")));
1930 }
1931 
1932 bool StyleSelector::selectorMatches(const Selector &selector, NodePtr node)
1933 {
1934     if (selector.basicSelectors.isEmpty())
1935         return false;
1936 
1937     if (selector.basicSelectors.at(0).relationToNext == BasicSelector::NoRelation) {
1938         if (selector.basicSelectors.count() != 1)
1939             return false;
1940         return basicSelectorMatches(selector.basicSelectors.at(0), node);
1941     }
1942     if (selector.basicSelectors.count() <= 1)
1943         return false;
1944 
1945     int i = selector.basicSelectors.count() - 1;
1946     node = duplicateNode(node);
1947     bool match = true;
1948 
1949     BasicSelector sel = selector.basicSelectors.at(i);
1950     do {
1951         match = basicSelectorMatches(sel, node);
1952         if (!match) {
1953             if (i == selector.basicSelectors.count() - 1) // first element must always match!
1954                 break;
1955             if (sel.relationToNext != BasicSelector::MatchNextSelectorIfAncestor &&
1956                 sel.relationToNext != BasicSelector::MatchNextSelectorIfIndirectAdjecent)
1957                 break;
1958         }
1959 
1960         if (match || (sel.relationToNext != BasicSelector::MatchNextSelectorIfAncestor &&
1961                       sel.relationToNext != BasicSelector::MatchNextSelectorIfIndirectAdjecent))
1962             --i;
1963 
1964         if (i < 0)
1965             break;
1966 
1967         sel = selector.basicSelectors.at(i);
1968         if (sel.relationToNext == BasicSelector::MatchNextSelectorIfAncestor
1969             || sel.relationToNext == BasicSelector::MatchNextSelectorIfParent) {
1970 
1971             NodePtr nextParent = parentNode(node);
1972             freeNode(node);
1973             node = nextParent;
1974         } else if (sel.relationToNext == BasicSelector::MatchNextSelectorIfDirectAdjecent
1975                   || sel.relationToNext == BasicSelector::MatchNextSelectorIfIndirectAdjecent) {
1976             NodePtr previousSibling = previousSiblingNode(node);
1977             freeNode(node);
1978             node = previousSibling;
1979         }
1980         if (isNullNode(node)) {
1981             match = false;
1982             break;
1983         }
1984    } while (i >= 0 && (match || sel.relationToNext == BasicSelector::MatchNextSelectorIfAncestor
1985                              || sel.relationToNext == BasicSelector::MatchNextSelectorIfIndirectAdjecent));
1986 
1987     freeNode(node);
1988 
1989     return match;
1990 }
1991 
1992 bool StyleSelector::basicSelectorMatches(const BasicSelector &sel, NodePtr node)
1993 {
1994     if (!sel.attributeSelectors.isEmpty()) {
1995         if (!hasAttributes(node))
1996             return false;
1997 
1998         for (int i = 0; i < sel.attributeSelectors.count(); ++i) {
1999             const QCss::AttributeSelector &a = sel.attributeSelectors.at(i);
2000 
2001             const QString attrValue = attribute(node, a.name);
2002             if (attrValue.isNull())
2003                 return false;
2004 
2005             switch (a.valueMatchCriterium) {
2006             case QCss::AttributeSelector::NoMatch:
2007                 break;
2008             case QCss::AttributeSelector::MatchEqual:
2009                 if (attrValue != a.value)
2010                     return false;
2011                 break;
2012             case QCss::AttributeSelector::MatchIncludes: {
2013                 const auto lst = attrValue.splitRef(QLatin1Char(' '));
2014                 if (!lst.contains(QStringRef(&a.value)))
2015                     return false;
2016                 break;
2017             }
2018             case QCss::AttributeSelector::MatchDashMatch: {
2019                 const QString dashPrefix = a.value + QLatin1Char('-');
2020                 if (attrValue != a.value && !attrValue.startsWith(dashPrefix))
2021                     return false;
2022                 break;
2023             }
2024             case QCss::AttributeSelector::MatchBeginsWith:
2025                 if (!attrValue.startsWith(a.value))
2026                     return false;
2027                 break;
2028             case QCss::AttributeSelector::MatchEndsWith:
2029                 if (!attrValue.endsWith(a.value))
2030                     return false;
2031                 break;
2032             case QCss::AttributeSelector::MatchContains:
2033                 if (!attrValue.contains(a.value))
2034                     return false;
2035                 break;
2036             }
2037         }
2038     }
2039 
2040     if (!sel.elementName.isEmpty()
2041         && !nodeNameEquals(node, sel.elementName))
2042             return false;
2043 
2044     if (!sel.ids.isEmpty()
2045         && sel.ids != nodeIds(node))
2046             return false;
2047 
2048     return true;
2049 }
2050 
2051 void StyleSelector::matchRule(NodePtr node, const StyleRule &rule, StyleSheetOrigin origin,
2052                                int depth, QMultiMap<uint, StyleRule> *weightedRules)
2053 {
2054     for (int j = 0; j < rule.selectors.count(); ++j) {
2055         const Selector& selector = rule.selectors.at(j);
2056         if (selectorMatches(selector, node)) {
2057             uint weight = rule.order
2058                         + selector.specificity() *0x100
2059                         + (uint(origin) + depth)*0x100000;
2060             StyleRule newRule = rule;
2061             if(rule.selectors.count() > 1) {
2062                 newRule.selectors.resize(1);
2063                 newRule.selectors[0] = selector;
2064             }
2065             //We might have rules with the same weight if they came from a rule with several selectors
2066             weightedRules->insert(weight, newRule);
2067         }
2068     }
2069 }
2070 
2071 // Returns style rules that are in ascending order of specificity
2072 // Each of the StyleRule returned will contain exactly one Selector
2073 QVector<StyleRule> StyleSelector::styleRulesForNode(NodePtr node)
2074 {
2075     QVector<StyleRule> rules;
2076     if (styleSheets.isEmpty())
2077         return rules;
2078 
2079     QMultiMap<uint, StyleRule> weightedRules; // (spec, rule) that will be sorted below
2080 
2081     //prune using indexed stylesheet
2082     for (int sheetIdx = 0; sheetIdx < styleSheets.count(); ++sheetIdx) {
2083         const StyleSheet &styleSheet = styleSheets.at(sheetIdx);
2084         for (int i = 0; i < styleSheet.styleRules.count(); ++i) {
2085             matchRule(node, styleSheet.styleRules.at(i), styleSheet.origin, styleSheet.depth, &weightedRules);
2086         }
2087 
2088         if (!styleSheet.idIndex.isEmpty()) {
2089             QStringList ids = nodeIds(node);
2090             for (int i = 0; i < ids.count(); i++) {
2091                 const QString &key = ids.at(i);
2092                 QMultiHash<QString, StyleRule>::const_iterator it = styleSheet.idIndex.constFind(key);
2093                 while (it != styleSheet.idIndex.constEnd() && it.key() == key) {
2094                     matchRule(node, it.value(), styleSheet.origin, styleSheet.depth, &weightedRules);
2095                     ++it;
2096                 }
2097             }
2098         }
2099         if (!styleSheet.nameIndex.isEmpty()) {
2100             QStringList names = nodeNames(node);
2101             for (int i = 0; i < names.count(); i++) {
2102                 QString name = names.at(i);
2103                 if (nameCaseSensitivity == Qt::CaseInsensitive)
2104                     name = std::move(name).toLower();
2105                 QMultiHash<QString, StyleRule>::const_iterator it = styleSheet.nameIndex.constFind(name);
2106                 while (it != styleSheet.nameIndex.constEnd() && it.key() == name) {
2107                     matchRule(node, it.value(), styleSheet.origin, styleSheet.depth, &weightedRules);
2108                     ++it;
2109                 }
2110             }
2111         }
2112         if (!medium.isEmpty()) {
2113             for (int i = 0; i < styleSheet.mediaRules.count(); ++i) {
2114                 if (styleSheet.mediaRules.at(i).media.contains(medium, Qt::CaseInsensitive)) {
2115                     for (int j = 0; j < styleSheet.mediaRules.at(i).styleRules.count(); ++j) {
2116                         matchRule(node, styleSheet.mediaRules.at(i).styleRules.at(j), styleSheet.origin,
2117                                styleSheet.depth, &weightedRules);
2118                     }
2119                 }
2120             }
2121         }
2122     }
2123 
2124     rules.reserve(weightedRules.count());
2125     QMap<uint, StyleRule>::const_iterator it = weightedRules.constBegin();
2126     for ( ; it != weightedRules.constEnd() ; ++it)
2127         rules += *it;
2128 
2129     return rules;
2130 }
2131 
2132 // for qtexthtmlparser which requires just the declarations with Enabled state
2133 // and without pseudo elements
2134 QVector<Declaration> StyleSelector::declarationsForNode(NodePtr node, const char *extraPseudo)
2135 {
2136     QVector<Declaration> decls;
2137     QVector<StyleRule> rules = styleRulesForNode(node);
2138     for (int i = 0; i < rules.count(); i++) {
2139         const Selector& selector = rules.at(i).selectors.at(0);
2140         const QString pseudoElement = selector.pseudoElement();
2141 
2142         if (extraPseudo && pseudoElement == QLatin1String(extraPseudo)) {
2143             decls += rules.at(i).declarations;
2144             continue;
2145         }
2146 
2147         if (!pseudoElement.isEmpty()) // skip rules with pseudo elements
2148             continue;
2149         quint64 pseudoClass = selector.pseudoClass();
2150         if (pseudoClass == PseudoClass_Enabled || pseudoClass == PseudoClass_Unspecified)
2151             decls += rules.at(i).declarations;
2152     }
2153     return decls;
2154 }
2155 
2156 static inline bool isHexDigit(const char c)
2157 {
2158     return (c >= '0' && c <= '9')
2159            || (c >= 'a' && c <= 'f')
2160            || (c >= 'A' && c <= 'F')
2161            ;
2162 }
2163 
2164 QString Scanner::preprocess(const QString &input, bool *hasEscapeSequences)
2165 {
2166     QString output = input;
2167 
2168     if (hasEscapeSequences)
2169         *hasEscapeSequences = false;
2170 
2171     int i = 0;
2172     while (i < output.size()) {
2173         if (output.at(i) == QLatin1Char('\\')) {
2174 
2175             ++i;
2176             // test for unicode hex escape
2177             int hexCount = 0;
2178             const int hexStart = i;
2179             while (i < output.size()
2180                    && isHexDigit(output.at(i).toLatin1())
2181                    && hexCount < 7) {
2182                 ++hexCount;
2183                 ++i;
2184             }
2185             if (hexCount == 0) {
2186                 if (hasEscapeSequences)
2187                     *hasEscapeSequences = true;
2188                 continue;
2189             }
2190 
2191             hexCount = qMin(hexCount, 6);
2192             bool ok = false;
2193             ushort code = output.midRef(hexStart, hexCount).toUShort(&ok, 16);
2194             if (ok) {
2195                 output.replace(hexStart - 1, hexCount + 1, QChar(code));
2196                 i = hexStart;
2197             } else {
2198                 i = hexStart;
2199             }
2200         } else {
2201             ++i;
2202         }
2203     }
2204     return output;
2205 }
2206 
2207 int QCssScanner_Generated::handleCommentStart()
2208 {
2209     while (pos < input.size() - 1) {
2210         if (input.at(pos) == QLatin1Char('*')
2211             && input.at(pos + 1) == QLatin1Char('/')) {
2212             pos += 2;
2213             break;
2214         }
2215         ++pos;
2216     }
2217     return S;
2218 }
2219 
2220 void Scanner::scan(const QString &preprocessedInput, QVector<Symbol> *symbols)
2221 {
2222     QCssScanner_Generated scanner(preprocessedInput);
2223     Symbol sym;
2224     int tok = scanner.lex();
2225     while (tok != -1) {
2226         sym.token = static_cast<QCss::TokenType>(tok);
2227         sym.text = scanner.input;
2228         sym.start = scanner.lexemStart;
2229         sym.len = scanner.lexemLength;
2230         symbols->append(sym);
2231         tok = scanner.lex();
2232     }
2233 }
2234 
2235 QString Symbol::lexem() const
2236 {
2237     QString result;
2238     if (len > 0)
2239         result.reserve(len);
2240     for (int i = 0; i < len; ++i) {
2241         if (text.at(start + i) == QLatin1Char('\\') && i < len - 1)
2242             ++i;
2243         result += text.at(start + i);
2244     }
2245     return result;
2246 }
2247 
2248 Parser::Parser(const QString &css, bool isFile)
2249 {
2250     init(css, isFile);
2251 }
2252 
2253 Parser::Parser()
2254 {
2255     index = 0;
2256     errorIndex = -1;
2257     hasEscapeSequences = false;
2258 }
2259 
2260 void Parser::init(const QString &css, bool isFile)
2261 {
2262     QString styleSheet = css;
2263     if (isFile) {
2264         QFile file(css);
2265         if (file.open(QFile::ReadOnly)) {
2266             sourcePath = QFileInfo(styleSheet).absolutePath() + QLatin1Char('/');
2267             QTextStream stream(&file);
2268             styleSheet = stream.readAll();
2269         } else {
2270             qWarning() << "QCss::Parser - Failed to load file " << css;
2271             styleSheet.clear();
2272         }
2273     } else {
2274         sourcePath.clear();
2275     }
2276 
2277     hasEscapeSequences = false;
2278     symbols.clear();
2279     symbols.reserve(8);
2280     Scanner::scan(Scanner::preprocess(styleSheet, &hasEscapeSequences), &symbols);
2281     index = 0;
2282     errorIndex = -1;
2283 }
2284 
2285 bool Parser::parse(StyleSheet *styleSheet, Qt::CaseSensitivity nameCaseSensitivity)
2286 {
2287     if (testTokenAndEndsWith(ATKEYWORD_SYM, QLatin1String("charset"))) {
2288         while (test(S) || test(CDO) || test(CDC)) {}
2289         if (!next(STRING)) return false;
2290         if (!next(SEMICOLON)) return false;
2291     }
2292 
2293     while (test(S) || test(CDO) || test(CDC)) {}
2294 
2295     while (testImport()) {
2296         ImportRule rule;
2297         if (!parseImport(&rule)) return false;
2298         styleSheet->importRules.append(rule);
2299         while (test(S) || test(CDO) || test(CDC)) {}
2300     }
2301 
2302     do {
2303         if (testMedia()) {
2304             MediaRule rule;
2305             if (!parseMedia(&rule)) return false;
2306             styleSheet->mediaRules.append(rule);
2307         } else if (testPage()) {
2308             PageRule rule;
2309             if (!parsePage(&rule)) return false;
2310             styleSheet->pageRules.append(rule);
2311         } else if (testRuleset()) {
2312             StyleRule rule;
2313             if (!parseRuleset(&rule)) return false;
2314             styleSheet->styleRules.append(rule);
2315         } else if (test(ATKEYWORD_SYM)) {
2316             if (!until(RBRACE)) return false;
2317         } else if (hasNext()) {
2318             return false;
2319         }
2320         while (test(S) || test(CDO) || test(CDC)) {}
2321     } while (hasNext());
2322     styleSheet->buildIndexes(nameCaseSensitivity);
2323     return true;
2324 }
2325 
2326 Symbol Parser::errorSymbol()
2327 {
2328     if (errorIndex == -1) return Symbol();
2329     return symbols.at(errorIndex);
2330 }
2331 
2332 static inline void removeOptionalQuotes(QString *str)
2333 {
2334     if (!str->startsWith(QLatin1Char('\''))
2335         && !str->startsWith(QLatin1Char('\"')))
2336         return;
2337     str->remove(0, 1);
2338     str->chop(1);
2339 }
2340 
2341 bool Parser::parseImport(ImportRule *importRule)
2342 {
2343     skipSpace();
2344 
2345     if (test(STRING)) {
2346         importRule->href = lexem();
2347     } else {
2348         if (!testAndParseUri(&importRule->href)) return false;
2349     }
2350     removeOptionalQuotes(&importRule->href);
2351 
2352     skipSpace();
2353 
2354     if (testMedium()) {
2355         if (!parseMedium(&importRule->media)) return false;
2356 
2357         while (test(COMMA)) {
2358             skipSpace();
2359             if (!parseNextMedium(&importRule->media)) return false;
2360         }
2361     }
2362 
2363     if (!next(SEMICOLON)) return false;
2364 
2365     skipSpace();
2366     return true;
2367 }
2368 
2369 bool Parser::parseMedia(MediaRule *mediaRule)
2370 {
2371     do {
2372         skipSpace();
2373         if (!parseNextMedium(&mediaRule->media)) return false;
2374     } while (test(COMMA));
2375 
2376     if (!next(LBRACE)) return false;
2377     skipSpace();
2378 
2379     while (testRuleset()) {
2380         StyleRule rule;
2381         if (!parseRuleset(&rule)) return false;
2382         mediaRule->styleRules.append(rule);
2383     }
2384 
2385     if (!next(RBRACE)) return false;
2386     skipSpace();
2387     return true;
2388 }
2389 
2390 bool Parser::parseMedium(QStringList *media)
2391 {
2392     media->append(lexem());
2393     skipSpace();
2394     return true;
2395 }
2396 
2397 bool Parser::parsePage(PageRule *pageRule)
2398 {
2399     skipSpace();
2400 
2401     if (testPseudoPage())
2402         if (!parsePseudoPage(&pageRule->selector)) return false;
2403 
2404     skipSpace();
2405     if (!next(LBRACE)) return false;
2406 
2407     do {
2408         skipSpace();
2409         Declaration decl;
2410         if (!parseNextDeclaration(&decl)) return false;
2411         if (!decl.isEmpty())
2412             pageRule->declarations.append(decl);
2413     } while (test(SEMICOLON));
2414 
2415     if (!next(RBRACE)) return false;
2416     skipSpace();
2417     return true;
2418 }
2419 
2420 bool Parser::parsePseudoPage(QString *selector)
2421 {
2422     if (!next(IDENT)) return false;
2423     *selector = lexem();
2424     return true;
2425 }
2426 
2427 bool Parser::parseNextOperator(Value *value)
2428 {
2429     if (!hasNext()) return true;
2430     switch (next()) {
2431         case SLASH: value->type = Value::TermOperatorSlash; skipSpace(); break;
2432         case COMMA: value->type = Value::TermOperatorComma; skipSpace(); break;
2433         default: prev(); break;
2434     }
2435     return true;
2436 }
2437 
2438 bool Parser::parseCombinator(BasicSelector::Relation *relation)
2439 {
2440     *relation = BasicSelector::NoRelation;
2441     if (lookup() == S) {
2442         *relation = BasicSelector::MatchNextSelectorIfAncestor;
2443         skipSpace();
2444     } else {
2445         prev();
2446     }
2447     if (test(PLUS)) {
2448         *relation = BasicSelector::MatchNextSelectorIfDirectAdjecent;
2449     } else if (test(GREATER)) {
2450         *relation = BasicSelector::MatchNextSelectorIfParent;
2451     } else if (test(TILDE)) {
2452         *relation = BasicSelector::MatchNextSelectorIfIndirectAdjecent;
2453     }
2454     skipSpace();
2455     return true;
2456 }
2457 
2458 bool Parser::parseProperty(Declaration *decl)
2459 {
2460     decl->d->property = lexem();
2461     decl->d->propertyId = static_cast<Property>(findKnownValue(decl->d->property, properties, NumProperties));
2462     decl->d->inheritable = isInheritable(decl->d->propertyId);
2463     skipSpace();
2464     return true;
2465 }
2466 
2467 bool Parser::parseRuleset(StyleRule *styleRule)
2468 {
2469     Selector sel;
2470     if (!parseSelector(&sel)) return false;
2471     styleRule->selectors.append(sel);
2472 
2473     while (test(COMMA)) {
2474         skipSpace();
2475         Selector sel;
2476         if (!parseNextSelector(&sel)) return false;
2477         styleRule->selectors.append(sel);
2478     }
2479 
2480     skipSpace();
2481     if (!next(LBRACE)) return false;
2482     const int declarationStart = index;
2483 
2484     do {
2485         skipSpace();
2486         Declaration decl;
2487         const int rewind = index;
2488         if (!parseNextDeclaration(&decl)) {
2489             index = rewind;
2490             const bool foundSemicolon = until(SEMICOLON);
2491             const int semicolonIndex = index;
2492 
2493             index = declarationStart;
2494             const bool foundRBrace = until(RBRACE);
2495 
2496             if (foundSemicolon && semicolonIndex < index) {
2497                 decl = Declaration();
2498                 index = semicolonIndex - 1;
2499             } else {
2500                 skipSpace();
2501                 return foundRBrace;
2502             }
2503         }
2504         if (!decl.isEmpty())
2505             styleRule->declarations.append(decl);
2506     } while (test(SEMICOLON));
2507 
2508     if (!next(RBRACE)) return false;
2509     skipSpace();
2510     return true;
2511 }
2512 
2513 bool Parser::parseSelector(Selector *sel)
2514 {
2515     BasicSelector basicSel;
2516     if (!parseSimpleSelector(&basicSel)) return false;
2517     while (testCombinator()) {
2518         if (!parseCombinator(&basicSel.relationToNext)) return false;
2519 
2520         if (!testSimpleSelector()) break;
2521         sel->basicSelectors.append(basicSel);
2522 
2523         basicSel = BasicSelector();
2524         if (!parseSimpleSelector(&basicSel)) return false;
2525     }
2526     sel->basicSelectors.append(basicSel);
2527     return true;
2528 }
2529 
2530 bool Parser::parseSimpleSelector(BasicSelector *basicSel)
2531 {
2532     int minCount = 0;
2533     if (lookupElementName()) {
2534         if (!parseElementName(&basicSel->elementName)) return false;
2535     } else {
2536         prev();
2537         minCount = 1;
2538     }
2539     bool onceMore;
2540     int count = 0;
2541     do {
2542         onceMore = false;
2543         if (test(HASH)) {
2544             QString theid = lexem();
2545             // chop off leading #
2546             theid.remove(0, 1);
2547             basicSel->ids.append(theid);
2548             onceMore = true;
2549         } else if (testClass()) {
2550             onceMore = true;
2551             AttributeSelector a;
2552             a.name = QLatin1String("class");
2553             a.valueMatchCriterium = AttributeSelector::MatchIncludes;
2554             if (!parseClass(&a.value)) return false;
2555             basicSel->attributeSelectors.append(a);
2556         } else if (testAttrib()) {
2557             onceMore = true;
2558             AttributeSelector a;
2559             if (!parseAttrib(&a)) return false;
2560             basicSel->attributeSelectors.append(a);
2561         } else if (testPseudo()) {
2562             onceMore = true;
2563             Pseudo ps;
2564             if (!parsePseudo(&ps)) return false;
2565             basicSel->pseudos.append(ps);
2566         }
2567         if (onceMore) ++count;
2568     } while (onceMore);
2569     return count >= minCount;
2570 }
2571 
2572 bool Parser::parseClass(QString *name)
2573 {
2574     if (!next(IDENT)) return false;
2575     *name = lexem();
2576     return true;
2577 }
2578 
2579 bool Parser::parseElementName(QString *name)
2580 {
2581     switch (lookup()) {
2582         case STAR: name->clear(); break;
2583         case IDENT: *name = lexem(); break;
2584         default: return false;
2585     }
2586     return true;
2587 }
2588 
2589 bool Parser::parseAttrib(AttributeSelector *attr)
2590 {
2591     skipSpace();
2592     if (!next(IDENT)) return false;
2593     attr->name = lexem();
2594     skipSpace();
2595 
2596     if (test(EQUAL)) {
2597         attr->valueMatchCriterium = AttributeSelector::MatchEqual;
2598     } else if (test(INCLUDES)) {
2599         attr->valueMatchCriterium = AttributeSelector::MatchIncludes;
2600     } else if (test(DASHMATCH)) {
2601         attr->valueMatchCriterium = AttributeSelector::MatchDashMatch;
2602     } else if (test(BEGINSWITH)) {
2603         attr->valueMatchCriterium = AttributeSelector::MatchBeginsWith;
2604     } else if (test(ENDSWITH)) {
2605         attr->valueMatchCriterium = AttributeSelector::MatchEndsWith;
2606     } else if (test(CONTAINS)) {
2607         attr->valueMatchCriterium = AttributeSelector::MatchContains;
2608     } else {
2609         return next(RBRACKET);
2610     }
2611 
2612     skipSpace();
2613 
2614     if (!test(IDENT) && !test(STRING)) return false;
2615     attr->value = unquotedLexem();
2616 
2617     skipSpace();
2618     return next(RBRACKET);
2619 }
2620 
2621 bool Parser::parsePseudo(Pseudo *pseudo)
2622 {
2623     (void)test(COLON);
2624     pseudo->negated = test(EXCLAMATION_SYM);
2625     if (test(IDENT)) {
2626         pseudo->name = lexem();
2627         pseudo->type = static_cast<quint64>(findKnownValue(pseudo->name, pseudos, NumPseudos));
2628         return true;
2629     }
2630     if (!next(FUNCTION)) return false;
2631     pseudo->function = lexem();
2632     // chop off trailing parenthesis
2633     pseudo->function.chop(1);
2634     skipSpace();
2635     if (!test(IDENT)) return false;
2636     pseudo->name = lexem();
2637     skipSpace();
2638     return next(RPAREN);
2639 }
2640 
2641 bool Parser::parseNextDeclaration(Declaration *decl)
2642 {
2643     if (!testProperty())
2644         return true; // not an error!
2645     if (!parseProperty(decl)) return false;
2646     if (!next(COLON)) return false;
2647     skipSpace();
2648     if (!parseNextExpr(&decl->d->values)) return false;
2649     if (testPrio())
2650         if (!parsePrio(decl)) return false;
2651     return true;
2652 }
2653 
2654 bool Parser::testPrio()
2655 {
2656     const int rewind = index;
2657     if (!test(EXCLAMATION_SYM)) return false;
2658     skipSpace();
2659     if (!test(IDENT)) {
2660         index = rewind;
2661         return false;
2662     }
2663     if (lexem().compare(QLatin1String("important"), Qt::CaseInsensitive) != 0) {
2664         index = rewind;
2665         return false;
2666     }
2667     return true;
2668 }
2669 
2670 bool Parser::parsePrio(Declaration *declaration)
2671 {
2672     declaration->d->important = true;
2673     skipSpace();
2674     return true;
2675 }
2676 
2677 bool Parser::parseExpr(QVector<Value> *values)
2678 {
2679     Value val;
2680     if (!parseTerm(&val)) return false;
2681     values->append(val);
2682     bool onceMore;
2683     do {
2684         onceMore = false;
2685         val = Value();
2686         if (!parseNextOperator(&val)) return false;
2687         if (val.type != QCss::Value::Unknown)
2688             values->append(val);
2689         if (testTerm()) {
2690             onceMore = true;
2691             val = Value();
2692             if (!parseTerm(&val)) return false;
2693             values->append(val);
2694         }
2695     } while (onceMore);
2696     return true;
2697 }
2698 
2699 bool Parser::testTerm()
2700 {
2701     return test(PLUS) || test(MINUS)
2702            || test(NUMBER)
2703            || test(PERCENTAGE)
2704            || test(LENGTH)
2705            || test(STRING)
2706            || test(IDENT)
2707            || testHexColor()
2708            || testFunction();
2709 }
2710 
2711 bool Parser::parseTerm(Value *value)
2712 {
2713     QString str = lexem();
2714     bool haveUnary = false;
2715     if (lookup() == PLUS || lookup() == MINUS) {
2716         haveUnary = true;
2717         if (!hasNext()) return false;
2718         next();
2719         str += lexem();
2720     }
2721 
2722     value->variant = str;
2723     value->type = QCss::Value::String;
2724     switch (lookup()) {
2725         case NUMBER:
2726             value->type = Value::Number;
2727             value->variant.convert(QMetaType::Double);
2728             break;
2729         case PERCENTAGE:
2730             value->type = Value::Percentage;
2731             str.chop(1); // strip off %
2732             value->variant = str;
2733             break;
2734         case LENGTH:
2735             value->type = Value::Length;
2736             break;
2737 
2738         case STRING:
2739             if (haveUnary) return false;
2740             value->type = Value::String;
2741             str.chop(1);
2742             str.remove(0, 1);
2743             value->variant = str;
2744             break;
2745         case IDENT: {
2746             if (haveUnary) return false;
2747             value->type = Value::Identifier;
2748             const int theid = findKnownValue(str, values, NumKnownValues);
2749             if (theid != 0) {
2750                 value->type = Value::KnownIdentifier;
2751                 value->variant = theid;
2752             }
2753             break;
2754         }
2755         default: {
2756             if (haveUnary) return false;
2757             prev();
2758             if (testHexColor()) {
2759                 QColor col;
2760                 if (!parseHexColor(&col)) return false;
2761                 value->type = Value::Color;
2762                 value->variant = col;
2763             } else if (testFunction()) {
2764                 QString name, args;
2765                 if (!parseFunction(&name, &args)) return false;
2766                 if (name == QLatin1String("url")) {
2767                     value->type = Value::Uri;
2768                     removeOptionalQuotes(&args);
2769                     if (QFileInfo(args).isRelative() && !sourcePath.isEmpty()) {
2770                         args.prepend(sourcePath);
2771                     }
2772                     value->variant = args;
2773                 } else {
2774                     value->type = Value::Function;
2775                     value->variant = QStringList() << name << args;
2776                 }
2777             } else {
2778                 return recordError();
2779             }
2780             return true;
2781         }
2782     }
2783     skipSpace();
2784     return true;
2785 }
2786 
2787 bool Parser::parseFunction(QString *name, QString *args)
2788 {
2789     *name = lexem();
2790     name->chop(1);
2791     // until(RPAREN) needs FUNCTION token at index-1 to work properly
2792     int start = index;
2793     skipSpace();
2794     std::swap(start, index);
2795     if (!until(RPAREN)) return false;
2796     for (int i = start; i < index - 1; ++i)
2797         args->append(symbols.at(i).lexem());
2798     /*
2799     if (!nextExpr(&arguments)) return false;
2800     if (!next(RPAREN)) return false;
2801     */
2802     skipSpace();
2803     return true;
2804 }
2805 
2806 bool Parser::parseHexColor(QColor *col)
2807 {
2808     col->setNamedColor(lexem());
2809     if (!col->isValid()) {
2810         qWarning("QCssParser::parseHexColor: Unknown color name '%s'",lexem().toLatin1().constData());
2811         return false;
2812     }
2813     skipSpace();
2814     return true;
2815 }
2816 
2817 bool Parser::testAndParseUri(QString *uri)
2818 {
2819     const int rewind = index;
2820     if (!testFunction()) return false;
2821 
2822     QString name, args;
2823     if (!parseFunction(&name, &args)) {
2824         index = rewind;
2825         return false;
2826     }
2827     if (name.compare(QLatin1String("url"), Qt::CaseInsensitive) != 0) {
2828         index = rewind;
2829         return false;
2830     }
2831     *uri = args;
2832     removeOptionalQuotes(uri);
2833     return true;
2834 }
2835 
2836 bool Parser::testSimpleSelector()
2837 {
2838     return testElementName()
2839            || (test(HASH))
2840            || testClass()
2841            || testAttrib()
2842            || testPseudo();
2843 }
2844 
2845 bool Parser::next(QCss::TokenType t)
2846 {
2847     if (hasNext() && next() == t)
2848         return true;
2849     return recordError();
2850 }
2851 
2852 bool Parser::test(QCss::TokenType t)
2853 {
2854     if (index >= symbols.count())
2855         return false;
2856     if (symbols.at(index).token == t) {
2857         ++index;
2858         return true;
2859     }
2860     return false;
2861 }
2862 
2863 QString Parser::unquotedLexem() const
2864 {
2865     QString s = lexem();
2866     if (lookup() == STRING) {
2867         s.chop(1);
2868         s.remove(0, 1);
2869     }
2870     return s;
2871 }
2872 
2873 QString Parser::lexemUntil(QCss::TokenType t)
2874 {
2875     QString lexem;
2876     while (hasNext() && next() != t)
2877         lexem += symbol().lexem();
2878     return lexem;
2879 }
2880 
2881 bool Parser::until(QCss::TokenType target, QCss::TokenType target2)
2882 {
2883     int braceCount = 0;
2884     int brackCount = 0;
2885     int parenCount = 0;
2886     if (index) {
2887         switch(symbols.at(index-1).token) {
2888         case LBRACE: ++braceCount; break;
2889         case LBRACKET: ++brackCount; break;
2890         case FUNCTION:
2891         case LPAREN: ++parenCount; break;
2892         default: ;
2893         }
2894     }
2895     while (index < symbols.size()) {
2896         QCss::TokenType t = symbols.at(index++).token;
2897         switch (t) {
2898         case LBRACE: ++braceCount; break;
2899         case RBRACE: --braceCount; break;
2900         case LBRACKET: ++brackCount; break;
2901         case RBRACKET: --brackCount; break;
2902         case FUNCTION:
2903         case LPAREN: ++parenCount; break;
2904         case RPAREN: --parenCount; break;
2905         default: break;
2906         }
2907         if ((t == target || (target2 != NONE && t == target2))
2908             && braceCount <= 0
2909             && brackCount <= 0
2910             && parenCount <= 0)
2911             return true;
2912 
2913         if (braceCount < 0 || brackCount < 0 || parenCount < 0) {
2914             --index;
2915             break;
2916         }
2917     }
2918     return false;
2919 }
2920 
2921 bool Parser::testTokenAndEndsWith(QCss::TokenType t, QLatin1String str)
2922 {
2923     if (!test(t)) return false;
2924     if (!lexem().endsWith(str, Qt::CaseInsensitive)) {
2925         prev();
2926         return false;
2927     }
2928     return true;
2929 }
2930 
2931 QT_END_NAMESPACE
2932 #endif // QT_NO_CSSPARSER
