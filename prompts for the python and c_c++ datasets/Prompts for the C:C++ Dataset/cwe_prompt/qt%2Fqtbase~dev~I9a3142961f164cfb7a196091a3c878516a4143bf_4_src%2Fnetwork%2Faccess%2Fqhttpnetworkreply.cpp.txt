Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtNetwork module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qhttpnetworkreply_p.h"
41 #include "qhttpnetworkconnection_p.h"
42 
43 #ifndef QT_NO_SSL
44 #    include <QtNetwork/qsslkey.h>
45 #    include <QtNetwork/qsslcipher.h>
46 #    include <QtNetwork/qsslconfiguration.h>
47 #endif
48 
49 #ifndef QT_NO_COMPRESS
50 #include <zlib.h>
51 #endif
52 
53 #if QT_CONFIG(brotli)
54 #include <brotli/decode.h>
55 #endif
56 
57 #if QT_CONFIG(zstd)
58 #include <zstd.h>
59 #endif
60 
61 QT_BEGIN_NAMESPACE
62 
63 QHttpNetworkReply::QHttpNetworkReply(const QUrl &url, QObject *parent)
64     : QObject(*new QHttpNetworkReplyPrivate(url), parent)
65 {
66 }
67 
68 QHttpNetworkReply::~QHttpNetworkReply()
69 {
70     Q_D(QHttpNetworkReply);
71     if (d->connection) {
72         d->connection->d_func()->removeReply(this);
73     }
74 
75 #ifndef QT_NO_COMPRESS
76     if (d->autoDecompress && d->isCompressed() && d->inflateStrm)
77         inflateEnd(d->inflateStrm);
78 #endif
79 }
80 
81 QUrl QHttpNetworkReply::url() const
82 {
83     return d_func()->url;
84 }
85 void QHttpNetworkReply::setUrl(const QUrl &url)
86 {
87     Q_D(QHttpNetworkReply);
88     d->url = url;
89 }
90 
91 QUrl QHttpNetworkReply::redirectUrl() const
92 {
93     return d_func()->redirectUrl;
94 }
95 
96 void QHttpNetworkReply::setRedirectUrl(const QUrl &url)
97 {
98     Q_D(QHttpNetworkReply);
99     d->redirectUrl = url;
100 }
101 
102 bool QHttpNetworkReply::isHttpRedirect(int statusCode)
103 {
104     return (statusCode == 301 || statusCode == 302 || statusCode == 303
105             || statusCode == 305 || statusCode == 307 || statusCode == 308);
106 }
107 
108 qint64 QHttpNetworkReply::contentLength() const
109 {
110     return d_func()->contentLength();
111 }
112 
113 void QHttpNetworkReply::setContentLength(qint64 length)
114 {
115     Q_D(QHttpNetworkReply);
116     d->setContentLength(length);
117 }
118 
119 QList<QPair<QByteArray, QByteArray> > QHttpNetworkReply::header() const
120 {
121     return d_func()->fields;
122 }
123 
124 QByteArray QHttpNetworkReply::headerField(const QByteArray &name, const QByteArray &defaultValue) const
125 {
126     return d_func()->headerField(name, defaultValue);
127 }
128 
129 void QHttpNetworkReply::setHeaderField(const QByteArray &name, const QByteArray &data)
130 {
131     Q_D(QHttpNetworkReply);
132     d->setHeaderField(name, data);
133 }
134 
135 void QHttpNetworkReply::parseHeader(const QByteArray &header)
136 {
137     Q_D(QHttpNetworkReply);
138     d->parseHeader(header);
139 }
140 
141 QHttpNetworkRequest QHttpNetworkReply::request() const
142 {
143     return d_func()->request;
144 }
145 
146 void QHttpNetworkReply::setRequest(const QHttpNetworkRequest &request)
147 {
148     Q_D(QHttpNetworkReply);
149     d->request = request;
150     d->ssl = request.isSsl();
151 }
152 
153 int QHttpNetworkReply::statusCode() const
154 {
155     return d_func()->statusCode;
156 }
157 
158 void QHttpNetworkReply::setStatusCode(int code)
159 {
160     Q_D(QHttpNetworkReply);
161     d->statusCode = code;
162 }
163 
164 QString QHttpNetworkReply::errorString() const
165 {
166     return d_func()->errorString;
167 }
168 
169 QNetworkReply::NetworkError QHttpNetworkReply::errorCode() const
170 {
171     return d_func()->httpErrorCode;
172 }
173 
174 QString QHttpNetworkReply::reasonPhrase() const
175 {
176     return d_func()->reasonPhrase;
177 }
178 
179 void QHttpNetworkReply::setErrorString(const QString &error)
180 {
181     Q_D(QHttpNetworkReply);
182     d->errorString = error;
183 }
184 
185 int QHttpNetworkReply::majorVersion() const
186 {
187     return d_func()->majorVersion;
188 }
189 
190 int QHttpNetworkReply::minorVersion() const
191 {
192     return d_func()->minorVersion;
193 }
194 
195 qint64 QHttpNetworkReply::bytesAvailable() const
196 {
197     Q_D(const QHttpNetworkReply);
198     if (d->connection)
199         return d->connection->d_func()->uncompressedBytesAvailable(*this);
200     else
201         return -1;
202 }
203 
204 qint64 QHttpNetworkReply::bytesAvailableNextBlock() const
205 {
206     Q_D(const QHttpNetworkReply);
207     if (d->connection)
208         return d->connection->d_func()->uncompressedBytesAvailableNextBlock(*this);
209     else
210         return -1;
211 }
212 
213 bool QHttpNetworkReply::readAnyAvailable() const
214 {
215     Q_D(const QHttpNetworkReply);
216     return (d->responseData.bufferCount() > 0);
217 }
218 
219 QByteArray QHttpNetworkReply::readAny()
220 {
221     Q_D(QHttpNetworkReply);
222     if (d->responseData.bufferCount() == 0)
223         return QByteArray();
224 
225     // we'll take the last buffer, so schedule another read from http
226     if (d->downstreamLimited && d->responseData.bufferCount() == 1 && !isFinished())
227         d->connection->d_func()->readMoreLater(this);
228     return d->responseData.read();
229 }
230 
231 QByteArray QHttpNetworkReply::readAll()
232 {
233     Q_D(QHttpNetworkReply);
234     return d->responseData.readAll();
235 }
236 
237 QByteArray QHttpNetworkReply::read(qint64 amount)
238 {
239     Q_D(QHttpNetworkReply);
240     return d->responseData.read(amount);
241 }
242 
243 
244 qint64 QHttpNetworkReply::sizeNextBlock()
245 {
246     Q_D(QHttpNetworkReply);
247     return d->responseData.sizeNextBlock();
248 }
249 
250 void QHttpNetworkReply::setDownstreamLimited(bool dsl)
251 {
252     Q_D(QHttpNetworkReply);
253     d->downstreamLimited = dsl;
254     d->connection->d_func()->readMoreLater(this);
255 }
256 
257 void QHttpNetworkReply::setReadBufferSize(qint64 size)
258 {
259     Q_D(QHttpNetworkReply);
260     d->readBufferMaxSize = size;
261 }
262 
263 bool QHttpNetworkReply::supportsUserProvidedDownloadBuffer()
264 {
265     Q_D(QHttpNetworkReply);
266     return (!d->isChunked() && !d->autoDecompress && d->bodyLength > 0 && d->statusCode == 200);
267 }
268 
269 void QHttpNetworkReply::setUserProvidedDownloadBuffer(char* b)
270 {
271     Q_D(QHttpNetworkReply);
272     if (supportsUserProvidedDownloadBuffer())
273         d->userProvidedDownloadBuffer = b;
274 }
275 
276 char* QHttpNetworkReply::userProvidedDownloadBuffer()
277 {
278     Q_D(QHttpNetworkReply);
279     return d->userProvidedDownloadBuffer;
280 }
281 
282 void QHttpNetworkReply::abort()
283 {
284     Q_D(QHttpNetworkReply);
285     d->state = QHttpNetworkReplyPrivate::Aborted;
286 }
287 
288 bool QHttpNetworkReply::isAborted() const
289 {
290     return d_func()->state == QHttpNetworkReplyPrivate::Aborted;
291 }
292 
293 bool QHttpNetworkReply::isFinished() const
294 {
295     return d_func()->state == QHttpNetworkReplyPrivate::AllDoneState;
296 }
297 
298 bool QHttpNetworkReply::isPipeliningUsed() const
299 {
300     return d_func()->pipeliningUsed;
301 }
302 
303 bool QHttpNetworkReply::isHttp2Used() const
304 {
305     return d_func()->h2Used;
306 }
307 
308 void QHttpNetworkReply::setHttp2WasUsed(bool h2)
309 {
310     d_func()->h2Used = h2;
311 }
312 
313 qint64 QHttpNetworkReply::removedContentLength() const
314 {
315     return d_func()->removedContentLength;
316 }
317 
318 bool QHttpNetworkReply::isRedirecting() const
319 {
320     return d_func()->isRedirecting();
321 }
322 
323 QHttpNetworkConnection* QHttpNetworkReply::connection()
324 {
325     return d_func()->connection;
326 }
327 
328 
329 QHttpNetworkReplyPrivate::QHttpNetworkReplyPrivate(const QUrl &newUrl)
330     : QHttpNetworkHeaderPrivate(newUrl)
331     , state(NothingDoneState)
332     , ssl(false)
333     , statusCode(100),
334       majorVersion(0), minorVersion(0), bodyLength(0), contentRead(0), totalProgress(0),
335       chunkedTransferEncoding(false),
336       connectionCloseEnabled(true),
337       forceConnectionCloseEnabled(false),
338       lastChunkRead(false),
339       currentChunkSize(0), currentChunkRead(0), readBufferMaxSize(0),
340       totallyUploadedData(0),
341       removedContentLength(-1),
342       connection(nullptr),
343       autoDecompress(false), responseData(), requestIsPrepared(false)
344       ,pipeliningUsed(false), h2Used(false), downstreamLimited(false)
345       ,userProvidedDownloadBuffer(nullptr)
346 #ifndef QT_NO_COMPRESS
347       ,inflateStrm(nullptr)
348 #endif
349 #if QT_CONFIG(brotli)
350       ,brotliDecoderState(nullptr)
351 #endif
352 #if QT_CONFIG(zstd)
353       ,zstdStream(nullptr)
354 #endif
355 
356 {
357     QString scheme = newUrl.scheme();
358     if (scheme == QLatin1String("preconnect-http")
359             || scheme == QLatin1String("preconnect-https"))
360         // make sure we do not close the socket after preconnecting
361         connectionCloseEnabled = false;
362 }
363 
364 QHttpNetworkReplyPrivate::~QHttpNetworkReplyPrivate()
365 {
366 #ifndef QT_NO_COMPRESS
367     if (inflateStrm)
368         delete inflateStrm;
369 #endif
370 #if QT_CONFIG(brotli)
371     if (brotliDecoderState)
372         BrotliDecoderDestroyInstance(brotliDecoderState);
373 #endif
374 #if QT_CONFIG(zstd)
375     if (zstdStream)
376         ZSTD_freeDStream(zstdStream);
377 #endif
378 }
379 
380 void QHttpNetworkReplyPrivate::clearHttpLayerInformation()
381 {
382     state = NothingDoneState;
383     statusCode = 100;
384     bodyLength = 0;
385     contentRead = 0;
386     totalProgress = 0;
387     currentChunkSize = 0;
388     currentChunkRead = 0;
389     lastChunkRead = false;
390     connectionCloseEnabled = true;
391 #ifndef QT_NO_COMPRESS
392     if (autoDecompress && inflateStrm)
393         inflateEnd(inflateStrm);
394 #endif
395 #if QT_CONFIG(brotli)
396     if (autoDecompress && brotliDecoderState)
397         BrotliDecoderDestroyInstance(brotliDecoderState);
398 #endif
399 #if QT_CONFIG(zstd)
400     if (autoDecompress && zstdStream)
401         ZSTD_freeDStream(zstdStream);
402 #endif
403     fields.clear();
404 }
405 
406 // TODO: Isn't everything HTTP layer related? We don't need to set connection and connectionChannel to 0 at all
407 void QHttpNetworkReplyPrivate::clear()
408 {
409     connection = nullptr;
410     connectionChannel = nullptr;
411     autoDecompress = false;
412     clearHttpLayerInformation();
413 }
414 
415 // QHttpNetworkReplyPrivate
416 qint64 QHttpNetworkReplyPrivate::bytesAvailable() const
417 {
418     return (state != ReadingDataState ? 0 : fragment.size());
419 }
420 
421 bool QHttpNetworkReplyPrivate::isCompressed()
422 {
423     QByteArray encoding = headerField("content-encoding");
424     return encoding.compare("gzip", Qt::CaseInsensitive) == 0 ||
425             encoding.compare("deflate", Qt::CaseInsensitive) == 0 ||
426             encoding.compare("br", Qt::CaseInsensitive) == 0 ||
427             encoding.compare("zstd", Qt::CaseInsensitive) == 0;
428 }
429 
430 void QHttpNetworkReplyPrivate::removeAutoDecompressHeader()
431 {
432     // The header "Content-Encoding  = gzip" is retained.
433     // Content-Length is removed since the actual one sent by the server is for compressed data
434     QByteArray name("content-length");
435     QList<QPair<QByteArray, QByteArray> >::Iterator it = fields.begin(),
436                                                    end = fields.end();
437     while (it != end) {
438         if (name.compare(it->first, Qt::CaseInsensitive) == 0) {
439             removedContentLength = strtoull(it->second.constData(), nullptr, 0);
440             fields.erase(it);
441             break;
442         }
443         ++it;
444     }
445 }
446 
447 bool QHttpNetworkReplyPrivate::findChallenge(bool forProxy, QByteArray &challenge) const
448 {
449     challenge.clear();
450     // find out the type of authentication protocol requested.
451     QByteArray header = forProxy ? "proxy-authenticate" : "www-authenticate";
452     // pick the best protocol (has to match parsing in QAuthenticatorPrivate)
453     QList<QByteArray> challenges = headerFieldValues(header);
454     for (int i = 0; i<challenges.size(); i++) {
455         QByteArray line = challenges.at(i);
456         // todo use qstrincmp
457         if (!line.toLower().startsWith("negotiate"))
458             challenge = line;
459     }
460     return !challenge.isEmpty();
461 }
462 
463 QAuthenticatorPrivate::Method QHttpNetworkReplyPrivate::authenticationMethod(bool isProxy) const
464 {
465     // The logic is same as the one used in void QAuthenticatorPrivate::parseHttpResponse()
466     QAuthenticatorPrivate::Method method = QAuthenticatorPrivate::None;
467     QByteArray header = isProxy ? "proxy-authenticate" : "www-authenticate";
468     QList<QByteArray> challenges = headerFieldValues(header);
469     for (int i = 0; i<challenges.size(); i++) {
470         QByteArray line = challenges.at(i).trimmed().toLower();
471         if (method < QAuthenticatorPrivate::Basic
472             && line.startsWith("basic")) {
473             method = QAuthenticatorPrivate::Basic;
474         } else if (method < QAuthenticatorPrivate::Ntlm
475             && line.startsWith("ntlm")) {
476             method = QAuthenticatorPrivate::Ntlm;
477         } else if (method < QAuthenticatorPrivate::DigestMd5
478             && line.startsWith("digest")) {
479             method = QAuthenticatorPrivate::DigestMd5;
480         } else if (method < QAuthenticatorPrivate::Negotiate
481             && line.startsWith("negotiate")) {
482             method = QAuthenticatorPrivate::Negotiate;
483         }
484     }
485     return method;
486 }
487 
488 qint64 QHttpNetworkReplyPrivate::readStatus(QAbstractSocket *socket)
489 {
490     if (fragment.isEmpty()) {
491         // reserve bytes for the status line. This is better than always append() which reallocs the byte array
492         fragment.reserve(32);
493     }
494 
495     qint64 bytes = 0;
496     char c;
497     qint64 haveRead = 0;
498 
499     do {
500         haveRead = socket->read(&c, 1);
501         if (haveRead == -1)
502             return -1; // unexpected EOF
503         else if (haveRead == 0)
504             break; // read more later
505         else if (haveRead == 1 && fragment.size() == 0 && (c == 11 || c == '\n' || c == '\r' || c == ' ' || c == 31))
506             continue; // Ignore all whitespace that was trailing froma previous request on that socket
507 
508         bytes++;
509 
510         // allow both CRLF & LF (only) line endings
511         if (c == '\n') {
512             // remove the CR at the end
513             if (fragment.endsWith('\r')) {
514                 fragment.truncate(fragment.length()-1);
515             }
516             bool ok = parseStatus(fragment);
517             state = ReadingHeaderState;
518             fragment.clear();
519             if (!ok) {
520                 return -1;
521             }
522             break;
523         } else {
524             fragment.append(c);
525         }
526 
527         // is this a valid reply?
528         if (fragment.length() == 5 && !fragment.startsWith("HTTP/")) {
529             fragment.clear();
530             return -1;
531         }
532     } while (haveRead == 1);
533 
534     return bytes;
535 }
536 
537 bool QHttpNetworkReplyPrivate::parseStatus(const QByteArray &status)
538 {
539     // from RFC 2616:
540     //        Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
541     //        HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
542     // that makes: 'HTTP/n.n xxx Message'
543     // byte count:  0123456789012
544 
545     static const int minLength = 11;
546     static const int dotPos = 6;
547     static const int spacePos = 8;
548     static const char httpMagic[] = "HTTP/";
549 
550     if (status.length() < minLength
551         || !status.startsWith(httpMagic)
552         || status.at(dotPos) != '.'
553         || status.at(spacePos) != ' ') {
554         // I don't know how to parse this status line
555         return false;
556     }
557 
558     // optimize for the valid case: defer checking until the end
559     majorVersion = status.at(dotPos - 1) - '0';
560     minorVersion = status.at(dotPos + 1) - '0';
561 
562     int i = spacePos;
563     int j = status.indexOf(' ', i + 1); // j == -1 || at(j) == ' ' so j+1 == 0 && j+1 <= length()
564     const QByteArray code = status.mid(i + 1, j - i - 1);
565 
566     bool ok;
567     statusCode = code.toInt(&ok);
568     reasonPhrase = QString::fromLatin1(status.constData() + j + 1);
569 
570     return ok && uint(majorVersion) <= 9 && uint(minorVersion) <= 9;
571 }
572 
573 qint64 QHttpNetworkReplyPrivate::readHeader(QAbstractSocket *socket)
574 {
575     if (fragment.isEmpty()) {
576         // according to http://dev.opera.com/articles/view/mama-http-headers/ the average size of the header
577         // block is 381 bytes.
578         // reserve bytes. This is better than always append() which reallocs the byte array.
579         fragment.reserve(512);
580     }
581 
582     qint64 bytes = 0;
583     char c = 0;
584     bool allHeaders = false;
585     qint64 haveRead = 0;
586     do {
587         haveRead = socket->read(&c, 1);
588         if (haveRead == 0) {
589             // read more later
590             break;
591         } else if (haveRead == -1) {
592             // connection broke down
593             return -1;
594         } else {
595             fragment.append(c);
596             bytes++;
597 
598             if (c == '\n') {
599                 // check for possible header endings. As per HTTP rfc,
600                 // the header endings will be marked by CRLFCRLF. But
601                 // we will allow CRLFCRLF, CRLFLF, LFCRLF, LFLF
602                 if (fragment.endsWith("\n\r\n")
603                     || fragment.endsWith("\n\n"))
604                     allHeaders = true;
605 
606                 // there is another case: We have no headers. Then the fragment equals just the line ending
607                 if ((fragment.length() == 2 && fragment.endsWith("\r\n"))
608                     || (fragment.length() == 1 && fragment.endsWith("\n")))
609                     allHeaders = true;
610             }
611         }
612     } while (!allHeaders && haveRead > 0);
613 
614     // we received all headers now parse them
615     if (allHeaders) {
616         parseHeader(fragment);
617         state = ReadingDataState;
618         fragment.clear(); // next fragment
619         bodyLength = contentLength(); // cache the length
620 
621         // cache isChunked() since it is called often
622         chunkedTransferEncoding = headerField("transfer-encoding").toLower().contains("chunked");
623 
624         // cache isConnectionCloseEnabled since it is called often
625         QByteArray connectionHeaderField = headerField("connection");
626         // check for explicit indication of close or the implicit connection close of HTTP/1.0
627         connectionCloseEnabled = (connectionHeaderField.toLower().contains("close") ||
628             headerField("proxy-connection").toLower().contains("close")) ||
629             (majorVersion == 1 && minorVersion == 0 &&
630             (connectionHeaderField.isEmpty() && !headerField("proxy-connection").toLower().contains("keep-alive")));
631 
632 #ifndef QT_NO_COMPRESS
633         if (autoDecompress && isCompressed()) {
634             // allocate inflate state
635             if (!inflateStrm)
636                 inflateStrm = new z_stream;
637             int ret = initializeInflateStream();
638             if (ret != Z_OK)
639                 return -1;
640         }
641 #endif
642 
643     }
644     return bytes;
645 }
646 
647 void QHttpNetworkReplyPrivate::parseHeader(const QByteArray &header)
648 {
649     // see rfc2616, sec 4 for information about HTTP/1.1 headers.
650     // allows relaxed parsing here, accepts both CRLF & LF line endings
651     int i = 0;
652     while (i < header.count()) {
653         int j = header.indexOf(':', i); // field-name
654         if (j == -1)
655             break;
656         const QByteArray field = header.mid(i, j - i).trimmed();
657         j++;
658         // any number of LWS is allowed before and after the value
659         QByteArray value;
660         do {
661             i = header.indexOf('\n', j);
662             if (i == -1)
663                 break;
664             if (!value.isEmpty())
665                 value += ' ';
666             // check if we have CRLF or only LF
667             bool hasCR = (i && header[i-1] == '\r');
668             int length = i -(hasCR ? 1: 0) - j;
669             value += header.mid(j, length).trimmed();
670             j = ++i;
671         } while (i < header.count() && (header.at(i) == ' ' || header.at(i) == '\t'));
672         if (i == -1)
673             break; // something is wrong
674 
675         fields.append(qMakePair(field, value));
676     }
677 }
678 
679 bool QHttpNetworkReplyPrivate::isChunked()
680 {
681     return chunkedTransferEncoding;
682 }
683 
684 bool QHttpNetworkReplyPrivate::isConnectionCloseEnabled()
685 {
686     return connectionCloseEnabled || forceConnectionCloseEnabled;
687 }
688 
689 // note this function can only be used for non-chunked, non-compressed with
690 // known content length
691 qint64 QHttpNetworkReplyPrivate::readBodyVeryFast(QAbstractSocket *socket, char *b)
692 {
693     // This first read is to flush the buffer inside the socket
694     qint64 haveRead = 0;
695     haveRead = socket->read(b, bodyLength - contentRead);
696     if (haveRead == -1) {
697         return -1;
698     }
699     contentRead += haveRead;
700 
701     if (contentRead == bodyLength) {
702         state = AllDoneState;
703     }
704 
705     return haveRead;
706 }
707 
708 // note this function can only be used for non-chunked, non-compressed with
709 // known content length
710 qint64 QHttpNetworkReplyPrivate::readBodyFast(QAbstractSocket *socket, QByteDataBuffer *rb)
711 {
712 
713     qint64 toBeRead = qMin(socket->bytesAvailable(), bodyLength - contentRead);
714     if (readBufferMaxSize)
715         toBeRead = qMin(toBeRead, readBufferMaxSize);
716 
717     if (!toBeRead)
718         return 0;
719 
720     QByteArray bd;
721     bd.resize(toBeRead);
722     qint64 haveRead = socket->read(bd.data(), toBeRead);
723     if (haveRead == -1) {
724         bd.clear();
725         return 0; // ### error checking here;
726     }
727     bd.resize(haveRead);
728 
729     rb->append(bd);
730 
731     if (contentRead + haveRead == bodyLength) {
732         state = AllDoneState;
733     }
734 
735     contentRead += haveRead;
736     return haveRead;
737 }
738 
739 
740 qint64 QHttpNetworkReplyPrivate::readBody(QAbstractSocket *socket, QByteDataBuffer *out)
741 {
742     qint64 bytes = 0;
743 
744 #ifndef QT_NO_COMPRESS
745     // for gzip we'll allocate a temporary one that we then decompress
746     QByteDataBuffer *tempOutDataBuffer = (autoDecompress ? new QByteDataBuffer : out);
747 #else
748     QByteDataBuffer *tempOutDataBuffer = out;
749 #endif
750 
751 
752     if (isChunked()) {
753         // chunked transfer encoding (rfc 2616, sec 3.6)
754         bytes += readReplyBodyChunked(socket, tempOutDataBuffer);
755     } else if (bodyLength > 0) {
756         // we have a Content-Length
757         bytes += readReplyBodyRaw(socket, tempOutDataBuffer, bodyLength - contentRead);
758         if (contentRead + bytes == bodyLength)
759             state = AllDoneState;
760     } else {
761         // no content length. just read what's possible
762         bytes += readReplyBodyRaw(socket, tempOutDataBuffer, socket->bytesAvailable());
763     }
764 
765     // This is true if there is compressed encoding and we're supposed to use it.
766     if (autoDecompress) {
767 #if QT_CONFIG(brotli)
768         if (headerField("content-encoding").compare("br", Qt::CaseInsensitive) == 0) {
769             qint64 uncompressRet = uncompressBodyBrotliData(tempOutDataBuffer, out);
770             delete tempOutDataBuffer;
771             if (uncompressRet < 0)
772                 return -1;
773         }
774 #  if QT_CONFIG(zstd) || !defined(QT_NO_COMPRESS)
775         else
776 #  endif
777 #endif // brotli
778 #if QT_CONFIG(zstd)
779         if (headerField("content-encoding").compare("zstd", Qt::CaseInsensitive) == 0) {
780             qint64 uncompressRet = uncompressBodyZstdData(tempOutDataBuffer, out);
781             delete tempOutDataBuffer;
782             if (uncompressRet < 0)
783                 return -1;
784         }
785 #  if !defined(QT_NO_COMPRESS)
786         else
787 #  endif
788 #endif // zstd
789 #ifndef QT_NO_COMPRESS
790         {
791             qint64 uncompressRet = uncompressBodyData(tempOutDataBuffer, out);
792             delete tempOutDataBuffer;
793             if (uncompressRet < 0)
794                 return -1;
795         }
796 #endif
797     }
798 
799     contentRead += bytes;
800     return bytes;
801 }
802 
803 #ifndef QT_NO_COMPRESS
804 int QHttpNetworkReplyPrivate::initializeInflateStream()
805 {
806     Q_ASSERT(inflateStrm);
807 
808     inflateStrm->zalloc = Z_NULL;
809     inflateStrm->zfree = Z_NULL;
810     inflateStrm->opaque = Z_NULL;
811     inflateStrm->avail_in = 0;
812     inflateStrm->next_in = Z_NULL;
813     // "windowBits can also be greater than 15 for optional gzip decoding.
814     // Add 32 to windowBits to enable zlib and gzip decoding with automatic header detection"
815     // http://www.zlib.net/manual.html
816     int ret = inflateInit2(inflateStrm, MAX_WBITS+32);
817     Q_ASSERT(ret == Z_OK);
818     return ret;
819 }
820 
821 qint64 QHttpNetworkReplyPrivate::uncompressBodyData(QByteDataBuffer *in, QByteDataBuffer *out)
822 {
823     if (!inflateStrm) { // happens when called from the SPDY protocol handler
824         inflateStrm = new z_stream;
825         initializeInflateStream();
826     }
827 
828     if (!inflateStrm)
829         return -1;
830 
831     bool triedRawDeflate = false;
832     for (int i = 0; i < in->bufferCount(); i++) {
833         QByteArray &bIn = (*in)[i];
834 
835         inflateStrm->avail_in = bIn.size();
836         inflateStrm->next_in = reinterpret_cast<Bytef*>(bIn.data());
837 
838         do {
839             QByteArray bOut;
840             // make a wild guess about the uncompressed size.
841             bOut.reserve(inflateStrm->avail_in * 3 + 512);
842             inflateStrm->avail_out = bOut.capacity();
843             inflateStrm->next_out = reinterpret_cast<Bytef*>(bOut.data());
844 
845             int ret = inflate(inflateStrm, Z_NO_FLUSH);
846             //All negative return codes are errors, in the context of HTTP compression, Z_NEED_DICT is also an error.
847             // in the case where we get Z_DATA_ERROR this could be because we received raw deflate compressed data.
848             if (ret == Z_DATA_ERROR && !triedRawDeflate) {
849                 inflateEnd(inflateStrm);
850                 triedRawDeflate = true;
851                 inflateStrm->zalloc = Z_NULL;
852                 inflateStrm->zfree = Z_NULL;
853                 inflateStrm->opaque = Z_NULL;
854                 inflateStrm->avail_in = 0;
855                 inflateStrm->next_in = Z_NULL;
856                 int ret = inflateInit2(inflateStrm, -MAX_WBITS);
857                 if (ret != Z_OK) {
858                     return -1;
859                 } else {
860                     inflateStrm->avail_in = bIn.size();
861                     inflateStrm->next_in = reinterpret_cast<Bytef*>(bIn.data());
862                     continue;
863                 }
864             } else if (ret < 0 || ret == Z_NEED_DICT) {
865                 return -1;
866             }
867             bOut.resize(bOut.capacity() - inflateStrm->avail_out);
868             out->append(bOut);
869             if (ret == Z_STREAM_END)
870                 return out->byteAmount();
871         } while (inflateStrm->avail_in > 0);
872     }
873 
874     return out->byteAmount();
875 }
876 #endif
877 
878 #if QT_CONFIG(brotli)
879 qint64 QHttpNetworkReplyPrivate::uncompressBodyBrotliData(QByteDataBuffer *in, QByteDataBuffer *out)
880 {
881     if (!brotliDecoderState) {
882         brotliDecoderState = BrotliDecoderCreateInstance(nullptr, nullptr, nullptr);
883         if (!brotliDecoderState) {
884             return -1;
885         }
886     }
887     if (!in->byteAmount())
888         return 0;
889 
890     auto appendToOutput = [](QByteDataBuffer *out, QByteArray &&a, size_t unusedSize) {
891         a.chop(QByteArray::size_type(unusedSize));
892         a.shrink_to_fit();
893         out->append(std::move(a));
894     };
895 
896     QByteArray decoded(16 * 1024, Qt::Uninitialized);
897     size_t remainingSize = decoded.size();
898     uint8_t *decodedPtr = reinterpret_cast<uint8_t *>(decoded.data());
899     qint64 bytesDecoded = 0;
900     for (int i = 0; i < in->bufferCount(); i++) {
901         const QByteArray &encoded = (*in)[i];
902         const uint8_t *encodedPtr = reinterpret_cast<const uint8_t *>(encoded.data());
903         size_t encodedBytesRemaining = encoded.size();
904         while (encodedBytesRemaining > 0) {
905             size_t prevBytesRemaining = encodedBytesRemaining;
906             BrotliDecoderResult result =
907                     BrotliDecoderDecompressStream(brotliDecoderState, &encodedBytesRemaining, &encodedPtr,
908                                                   &remainingSize, &decodedPtr, nullptr);
909             bytesDecoded += prevBytesRemaining - encodedBytesRemaining;
910 
911             switch (result) {
912             case BROTLI_DECODER_RESULT_ERROR:
913                 return -1;
914             case BROTLI_DECODER_RESULT_SUCCESS:
915                 appendToOutput(out, std::move(decoded), remainingSize);
916                 BrotliDecoderDestroyInstance(brotliDecoderState);
917                 brotliDecoderState = nullptr;
918                 return out->byteAmount(); // done!
919             case BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT:
920                 if (i == in->bufferCount() - 1) // Last buffer, we need to wait for more data!
921                     appendToOutput(out, std::move(decoded), remainingSize);
922                 break;
923             case BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT:
924                 appendToOutput(out, std::move(decoded), remainingSize);
925 
926                 // Some data is leftover inside the brotli decoder, loop until we've taken it all
927                 // out
928                 while (true) {
929                     size_t size = 0;
930                     const uint8_t *data = BrotliDecoderTakeOutput(brotliDecoderState, &size);
931                     if (!size || !data)
932                         break;
933                     decoded = QByteArray { QByteArray::size_type(size), Qt::Uninitialized };
934                     memcpy(decoded.data(), data, size);
935                     appendToOutput(out, std::move(decoded), 0);
936                 }
937 
938                 if (encodedBytesRemaining == 0 && i == in->bufferCount() - 1)
939                     return out->byteAmount();
940                 // Create a new byte array to decode more data
941                 decoded = QByteArray(16 * 1024, Qt::Uninitialized);
942                 remainingSize = decoded.size();
943                 decodedPtr = reinterpret_cast<uint8_t *>(decoded.data());
944                 break;
945             }
946         }
947     }
948     return out->byteAmount();
949 }
950 #endif
951 
952 #if QT_CONFIG(zstd)
953 qint64 QHttpNetworkReplyPrivate::uncompressBodyZstdData(QByteDataBuffer *in, QByteDataBuffer *out)
954 {
955     if (!zstdStream) {
956         zstdStream = ZSTD_createDStream();
957         if (!zstdStream)
958             return -1;
959         ZSTD_initDStream(zstdStream);
960     }
961 
962     QByteArray decoded(QByteArray::size_type(16 * 1024), Qt::Uninitialized);
963 
964     ZSTD_outBuffer outBuf {
965         decoded.data(),
966         size_t(decoded.size()),
967         0
968     };
969 
970     for (int i = 0; i < in->bufferCount(); ++i) {
971         const QByteArray &encoded = (*in)[i];
972         ZSTD_inBuffer inBuf {
973             encoded.data(),
974             size_t(encoded.size()),
975             0
976         };
977 
978         bool dataLeftover = false;
979         while (inBuf.pos < inBuf.size || dataLeftover) {
980             dataLeftover = false;
981             size_t retValue = ZSTD_decompressStream(zstdStream, &outBuf, &inBuf);
982             if (ZSTD_isError(retValue)) {
983                 return -1;
984             } else if (retValue >= 0) {
985                 decoded.resize(QByteArray::size_type(outBuf.pos));
986                 out->append(std::move(decoded));
987                 if (retValue > 0) {
988                     decoded = QByteArray(QByteArray::size_type(16 * 1024), Qt::Uninitialized);
989                     // if pos == size then there may be data left over in internal buffers
990                     dataLeftover = outBuf.pos == outBuf.size;
991                     outBuf.dst = decoded.data();
992                     outBuf.size = decoded.size();
993                     outBuf.pos = 0;
994                 }
995             }
996         }
997         Q_ASSERT(inBuf.pos == inBuf.size);
998     }
999     return out->byteAmount();
1000 }
1001 #endif
1002 
1003 qint64 QHttpNetworkReplyPrivate::readReplyBodyRaw(QAbstractSocket *socket, QByteDataBuffer *out, qint64 size)
1004 {
1005     // FIXME get rid of this function and just use readBodyFast and give it socket->bytesAvailable()
1006     qint64 bytes = 0;
1007     Q_ASSERT(socket);
1008     Q_ASSERT(out);
1009 
1010     int toBeRead = qMin<qint64>(128*1024, qMin<qint64>(size, socket->bytesAvailable()));
1011 
1012     if (readBufferMaxSize)
1013         toBeRead = qMin<qint64>(toBeRead, readBufferMaxSize);
1014 
1015     while (toBeRead > 0) {
1016         QByteArray byteData;
1017         byteData.resize(toBeRead);
1018         qint64 haveRead = socket->read(byteData.data(), byteData.size());
1019         if (haveRead <= 0) {
1020             // ### error checking here
1021             byteData.clear();
1022             return bytes;
1023         }
1024 
1025         byteData.resize(haveRead);
1026         out->append(byteData);
1027         bytes += haveRead;
1028         size -= haveRead;
1029 
1030         toBeRead = qMin<qint64>(128*1024, qMin<qint64>(size, socket->bytesAvailable()));
1031     }
1032     return bytes;
1033 
1034 }
1035 
1036 qint64 QHttpNetworkReplyPrivate::readReplyBodyChunked(QAbstractSocket *socket, QByteDataBuffer *out)
1037 {
1038     qint64 bytes = 0;
1039     while (socket->bytesAvailable()) {
1040 
1041         if (readBufferMaxSize && (bytes > readBufferMaxSize))
1042             break;
1043 
1044         if (!lastChunkRead && currentChunkRead >= currentChunkSize) {
1045             // For the first chunk and when we're done with a chunk
1046             currentChunkSize = 0;
1047             currentChunkRead = 0;
1048             if (bytes) {
1049                 // After a chunk
1050                 char crlf[2];
1051                 // read the "\r\n" after the chunk
1052                 qint64 haveRead = socket->read(crlf, 2);
1053                 // FIXME: This code is slightly broken and not optimal. What if the 2 bytes are not available yet?!
1054                 // For nice reasons (the toLong in getChunkSize accepting \n at the beginning
1055                 // it right now still works, but we should definitely fix this.
1056 
1057                 if (haveRead != 2)
1058                     return bytes; // FIXME
1059                 bytes += haveRead;
1060             }
1061             // Note that chunk size gets stored in currentChunkSize, what is returned is the bytes read
1062             bytes += getChunkSize(socket, &currentChunkSize);
1063             if (currentChunkSize == -1)
1064                 break;
1065         }
1066         // if the chunk size is 0, end of the stream
1067         if (currentChunkSize == 0 || lastChunkRead) {
1068             lastChunkRead = true;
1069             // try to read the "\r\n" after the chunk
1070             char crlf[2];
1071             qint64 haveRead = socket->read(crlf, 2);
1072             if (haveRead > 0)
1073                 bytes += haveRead;
1074 
1075             if ((haveRead == 2 && crlf[0] == '\r' && crlf[1] == '\n') || (haveRead == 1 && crlf[0] == '\n'))
1076                 state = AllDoneState;
1077             else if (haveRead == 1 && crlf[0] == '\r')
1078                 break; // Still waiting for the last \n
1079             else if (haveRead > 0) {
1080                 // If we read something else then CRLF, we need to close the channel.
1081                 forceConnectionCloseEnabled = true;
1082                 state = AllDoneState;
1083             }
1084             break;
1085         }
1086 
1087         // otherwise, try to begin reading this chunk / to read what is missing for this chunk
1088         qint64 haveRead = readReplyBodyRaw (socket, out, currentChunkSize - currentChunkRead);
1089         currentChunkRead += haveRead;
1090         bytes += haveRead;
1091 
1092         // ### error checking here
1093 
1094     }
1095     return bytes;
1096 }
1097 
1098 qint64 QHttpNetworkReplyPrivate::getChunkSize(QAbstractSocket *socket, qint64 *chunkSize)
1099 {
1100     qint64 bytes = 0;
1101     char crlf[2];
1102     *chunkSize = -1;
1103 
1104     int bytesAvailable = socket->bytesAvailable();
1105     // FIXME rewrite to permanent loop without bytesAvailable
1106     while (bytesAvailable > bytes) {
1107         qint64 sniffedBytes = socket->peek(crlf, 2);
1108         int fragmentSize = fragment.size();
1109 
1110         // check the next two bytes for a "\r\n", skip blank lines
1111         if ((fragmentSize && sniffedBytes == 2 && crlf[0] == '\r' && crlf[1] == '\n')
1112            ||(fragmentSize > 1 && fragment.endsWith('\r')  && crlf[0] == '\n'))
1113         {
1114             bytes += socket->read(crlf, 1);     // read the \r or \n
1115             if (crlf[0] == '\r')
1116                 bytes += socket->read(crlf, 1); // read the \n
1117             bool ok = false;
1118             // ignore the chunk-extension
1119             fragment = fragment.mid(0, fragment.indexOf(';')).trimmed();
1120             *chunkSize = fragment.toLong(&ok, 16);
1121             fragment.clear();
1122             break; // size done
1123         } else {
1124             // read the fragment to the buffer
1125             char c = 0;
1126             qint64 haveRead = socket->read(&c, 1);
1127             if (haveRead < 0) {
1128                 return -1; // FIXME
1129             }
1130             bytes += haveRead;
1131             fragment.append(c);
1132         }
1133     }
1134 
1135     return bytes;
1136 }
1137 
1138 bool QHttpNetworkReplyPrivate::isRedirecting() const
1139 {
1140     // We're in the process of redirecting - if the HTTP status code says so and
1141     // followRedirect is switched on
1142     return (QHttpNetworkReply::isHttpRedirect(statusCode)
1143             && request.isFollowRedirects());
1144 }
1145 
1146 bool QHttpNetworkReplyPrivate::shouldEmitSignals()
1147 {
1148     // for 401 & 407 don't emit the data signals. Content along with these
1149     // responses are sent only if the authentication fails.
1150     return (statusCode != 401 && statusCode != 407);
1151 }
1152 
1153 bool QHttpNetworkReplyPrivate::expectContent()
1154 {
1155     // check whether we can expect content after the headers (rfc 2616, sec4.4)
1156     if ((statusCode >= 100 && statusCode < 200)
1157         || statusCode == 204 || statusCode == 304)
1158         return false;
1159     if (request.operation() == QHttpNetworkRequest::Head)
1160         return false; // no body expected for HEAD request
1161     qint64 expectedContentLength = contentLength();
1162     if (expectedContentLength == 0)
1163         return false;
1164     if (expectedContentLength == -1 && bodyLength == 0) {
1165         // The content-length header was stripped, but its value was 0.
1166         // This would be the case for an explicitly zero-length compressed response.
1167         return false;
1168     }
1169     return true;
1170 }
1171 
1172 void QHttpNetworkReplyPrivate::eraseData()
1173 {
1174     compressedData.clear();
1175     responseData.clear();
1176 }
1177 
1178 
1179 // SSL support below
1180 #ifndef QT_NO_SSL
1181 
1182 QSslConfiguration QHttpNetworkReply::sslConfiguration() const
1183 {
1184     Q_D(const QHttpNetworkReply);
1185 
1186     if (!d->connectionChannel)
1187         return QSslConfiguration();
1188 
1189     QSslSocket *sslSocket = qobject_cast<QSslSocket*>(d->connectionChannel->socket);
1190     if (!sslSocket)
1191         return QSslConfiguration();
1192 
1193     return sslSocket->sslConfiguration();
1194 }
1195 
1196 void QHttpNetworkReply::setSslConfiguration(const QSslConfiguration &config)
1197 {
1198     Q_D(QHttpNetworkReply);
1199     if (d->connection)
1200         d->connection->setSslConfiguration(config);
1201 }
1202 
1203 void QHttpNetworkReply::ignoreSslErrors()
1204 {
1205     Q_D(QHttpNetworkReply);
1206     if (d->connection)
1207         d->connection->ignoreSslErrors();
1208 }
1209 
1210 void QHttpNetworkReply::ignoreSslErrors(const QList<QSslError> &errors)
1211 {
1212     Q_D(QHttpNetworkReply);
1213     if (d->connection)
1214         d->connection->ignoreSslErrors(errors);
1215 }
1216 
1217 
1218 #endif //QT_NO_SSL
1219 
1220 
1221 QT_END_NAMESPACE
