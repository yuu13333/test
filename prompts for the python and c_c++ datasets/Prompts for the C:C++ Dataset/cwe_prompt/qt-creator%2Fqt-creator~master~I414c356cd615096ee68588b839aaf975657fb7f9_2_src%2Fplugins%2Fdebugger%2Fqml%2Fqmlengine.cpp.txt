Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "qmlengine.h"
27 
28 #include "interactiveinterpreter.h"
29 #include "qmlinspectoragent.h"
30 #include "qmlv8debuggerclientconstants.h"
31 #include "qmlengineutils.h"
32 
33 #include <debugger/breakhandler.h>
34 #include <debugger/debuggeractions.h>
35 #include <debugger/debuggercore.h>
36 #include <debugger/debuggerinternalconstants.h>
37 #include <debugger/debuggerruncontrol.h>
38 #include <debugger/debuggertooltipmanager.h>
39 #include <debugger/sourcefileshandler.h>
40 #include <debugger/stackhandler.h>
41 #include <debugger/threaddata.h>
42 #include <debugger/watchhandler.h>
43 #include <debugger/watchwindow.h>
44 #include <debugger/console/console.h>
45 
46 #include <coreplugin/editormanager/editormanager.h>
47 #include <coreplugin/helpmanager.h>
48 #include <coreplugin/icore.h>
49 
50 #include <projectexplorer/applicationlauncher.h>
51 #include <projectexplorer/runnables.h>
52 
53 #include <qmljseditor/qmljseditorconstants.h>
54 #include <qmljs/qmljsmodelmanagerinterface.h>
55 #include <qmldebug/qpacketprotocol.h>
56 
57 #include <texteditor/textdocument.h>
58 #include <texteditor/texteditor.h>
59 
60 #include <utils/treemodel.h>
61 #include <utils/basetreeview.h>
62 #include <utils/qtcassert.h>
63 
64 #include <QDebug>
65 #include <QDir>
66 #include <QDockWidget>
67 #include <QFileInfo>
68 #include <QJsonArray>
69 #include <QJsonDocument>
70 #include <QJsonObject>
71 #include <QMessageBox>
72 #include <QPlainTextEdit>
73 #include <QTimer>
74 
75 #include <memory.h>
76 
77 #define DEBUG_QML 0
78 #if DEBUG_QML
79 #   define SDEBUG(s) qDebug() << s
80 #else
81 #   define SDEBUG(s)
82 #endif
83 # define XSDEBUG(s) qDebug() << s
84 
85 #define CB(callback) [this](const QVariantMap &r) { callback(r); }
86 
87 using namespace Core;
88 using namespace ProjectExplorer;
89 using namespace QmlDebug;
90 using namespace QmlJS;
91 using namespace TextEditor;
92 using namespace Utils;
93 
94 namespace Debugger {
95 namespace Internal {
96 
97 enum Exceptions
98 {
99     NoExceptions,
100     UncaughtExceptions,
101     AllExceptions
102 };
103 
104 enum StepAction
105 {
106     Continue,
107     StepIn,
108     StepOut,
109     Next
110 };
111 
112 struct QmlV8ObjectData
113 {
114     int handle = -1;
115     int expectedProperties = -1;
116     QString name;
117     QString type;
118     QVariant value;
119     QVariantList properties;
120 
121     bool hasChildren() const
122     {
123         return expectedProperties > 0 || !properties.isEmpty();
124     }
125 };
126 
127 typedef std::function<void(const QVariantMap &)> QmlCallback;
128 
129 struct LookupData
130 {
131     QString iname;
132     QString name;
133     QString exp;
134 };
135 
136 typedef QHash<int, LookupData> LookupItems; // id -> (iname, exp)
137 
138 class QmlEnginePrivate : public QmlDebugClient
139 {
140 public:
141     QmlEnginePrivate(QmlEngine *engine_, QmlDebugConnection *connection_)
142         : QmlDebugClient("V8Debugger", connection_),
143           engine(engine_),
144           inspectorAgent(engine, connection_),
145           connection(connection_)
146     {}
147 
148     void messageReceived(const QByteArray &data);
149     void stateChanged(State state);
150 
151     void continueDebugging(StepAction stepAction);
152 
153     void evaluate(const QString expr, qint64 context, const QmlCallback &cb);
154     void lookup(const LookupItems &items);
155     void backtrace();
156     void updateLocals();
157     void scope(int number, int frameNumber = -1);
158     void scripts(int types = 4, const QList<int> ids = QList<int>(),
159                  bool includeSource = false, const QVariant filter = QVariant());
160 
161     void setBreakpoint(const QString type, const QString target,
162                        bool enabled = true,int line = 0, int column = 0,
163                        const QString condition = QString(), int ignoreCount = -1);
164     void clearBreakpoint(int breakpoint);
165     void setExceptionBreak(Exceptions type, bool enabled = false);
166 
167     void flushSendBuffer();
168 
169     void handleBacktrace(const QVariantMap &response);
170     void handleLookup(const QVariantMap &response);
171     void handleExecuteDebuggerCommand(const QVariantMap &response);
172     void handleEvaluateExpression(const QVariantMap &response, const QString &iname, const QString &expr);
173     void handleFrame(const QVariantMap &response);
174     void handleScope(const QVariantMap &response);
175     void handleVersion(const QVariantMap &response);
176     StackFrame extractStackFrame(const QVariant &bodyVal);
177 
178     bool canEvaluateScript(const QString &script);
179     void updateScriptSource(const QString &fileName, int lineOffset, int columnOffset, const QString &source);
180 
181     void runCommand(const DebuggerCommand &command, const QmlCallback &cb = QmlCallback());
182     void runDirectCommand(const QString &type, const QByteArray &msg = QByteArray());
183 
184     void clearRefs() { refVals.clear(); }
185     void memorizeRefs(const QVariant &refs);
186     QmlV8ObjectData extractData(const QVariant &data) const;
187     void insertSubItems(WatchItem *parent, const QVariantList &properties);
188     void checkForFinishedUpdate();
189     ConsoleItem *constructLogItemTree(const QmlV8ObjectData &objectData);
190 
191     void filterApplicationMessage(ProjectExplorer::RunControl *runControl,
192                                   const QString &msg, Utils::OutputFormat format)
193     {
194         if (runControl != engine->runControl())
195             return;
196         if (format == StdErrFormatSameLine
197                 || format == StdOutFormatSameLine
198                 || format == DebugFormat)
199             outputParser.processOutput(msg);
200     }
201 
202 public:
203     QHash<int, QmlV8ObjectData> refVals; // The mapping of target object handles to retrieved values.
204     int sequence = -1;
205     QmlEngine *engine;
206     QHash<BreakpointModelId, int> breakpoints;
207     QHash<int, BreakpointModelId> breakpointsSync;
208     QList<int> breakpointsTemp;
209 
210     LookupItems currentlyLookingUp; // Id -> inames
211 
212     //Cache
213     QList<int> currentFrameScopes;
214     QHash<int, int> stackIndexLookup;
215 
216     StepAction previousStepAction = Continue;
217 
218     QList<QByteArray> sendBuffer;
219 
220     QHash<QString, QTextDocument*> sourceDocuments;
221     QHash<QString, QWeakPointer<BaseTextEditor> > sourceEditors;
222     InteractiveInterpreter interpreter;
223     ApplicationLauncher applicationLauncher;
224     QmlInspectorAgent inspectorAgent;
225     QmlOutputParser outputParser;
226 
227     QTimer noDebugOutputTimer;
228     QList<quint32> queryIds;
229     bool retryOnConnectFail = false;
230     bool automaticConnect = false;
231     bool unpausedEvaluate = false;
232     bool contextEvaluate = false;
233 
234     QTimer connectionTimer;
235     QmlDebug::QmlDebugConnection *connection;
236     QmlDebug::QDebugMessageClient *msgClient = 0;
237 
238     QHash<int, QmlCallback> callbackForToken;
239     QMetaObject::Connection startupMessageFilterConnection;
240 
241 private:
242     ConsoleItem *constructLogItemTree(const QmlV8ObjectData &objectData, QList<int> &seenHandles);
243     void constructChildLogItems(ConsoleItem *item, const QmlV8ObjectData &objectData,
244                              QList<int> &seenHandles);
245 };
246 
247 static void updateDocument(IDocument *document, const QTextDocument *textDocument)
248 {
249     if (auto baseTextDocument = qobject_cast<TextDocument *>(document))
250         baseTextDocument->document()->setPlainText(textDocument->toPlainText());
251 }
252 
253 
254 ///////////////////////////////////////////////////////////////////////
255 //
256 // QmlEngine
257 //
258 ///////////////////////////////////////////////////////////////////////
259 
260 QmlEngine::QmlEngine(const DebuggerRunParameters &startParameters, DebuggerEngine *masterEngine)
261   : DebuggerEngine(startParameters),
262     d(new QmlEnginePrivate(this, new QmlDebugConnection(this)))
263 {
264     setObjectName("QmlEngine");
265 
266     if (masterEngine)
267         setMasterEngine(masterEngine);
268 
269     connect(runTool(), &DebuggerRunTool::stateChanged,
270             this, &QmlEngine::updateCurrentContext);
271     connect(stackHandler(), &StackHandler::stackChanged,
272             this, &QmlEngine::updateCurrentContext);
273     connect(stackHandler(), &StackHandler::currentIndexChanged,
274             this, &QmlEngine::updateCurrentContext);
275     connect(inspectorView(), &WatchTreeView::currentIndexChanged,
276             this, &QmlEngine::updateCurrentContext);
277 
278     connect(&d->applicationLauncher, &ApplicationLauncher::processExited,
279             this, &QmlEngine::disconnected);
280     connect(&d->applicationLauncher, &ApplicationLauncher::appendMessage,
281             this, &QmlEngine::appendMessage);
282     connect(&d->applicationLauncher, &ApplicationLauncher::processStarted,
283             this, &QmlEngine::handleLauncherStarted);
284 
285     d->outputParser.setNoOutputText(ApplicationLauncher::msgWinCannotRetrieveDebuggingOutput());
286     connect(&d->outputParser, &QmlOutputParser::waitingForConnectionOnPort,
287             this, &QmlEngine::beginConnection);
288     connect(&d->outputParser, &QmlOutputParser::noOutputMessage,
289             this, [this] { tryToConnect(); });
290     connect(&d->outputParser, &QmlOutputParser::errorMessage,
291             this, &QmlEngine::appStartupFailed);
292 
293     // Only wait 8 seconds for the 'Waiting for connection' on application output,
294     // then just try to connect (application output might be redirected / blocked)
295     d->noDebugOutputTimer.setSingleShot(true);
296     d->noDebugOutputTimer.setInterval(8000);
297     connect(&d->noDebugOutputTimer, &QTimer::timeout,
298             this, [this] { tryToConnect(); });
299 
300     // we won't get any debug output
301     if (startParameters.useTerminal) {
302         d->noDebugOutputTimer.setInterval(0);
303         d->retryOnConnectFail = true;
304         d->automaticConnect = true;
305     }
306 
307     debuggerConsole()->setScriptEvaluator([this](const QString &expr) {
308         executeDebuggerCommand(expr, QmlLanguage);
309     });
310 
311     d->connectionTimer.setInterval(4000);
312     d->connectionTimer.setSingleShot(true);
313     connect(&d->connectionTimer, &QTimer::timeout,
314             this, &QmlEngine::checkConnectionState);
315 
316     connect(d->connection, &QmlDebugConnection::logStateChange,
317             this, &QmlEngine::showConnectionStateMessage);
318     connect(d->connection, &QmlDebugConnection::logError, this,
319             [this](const QString &error) { showMessage("QML Debugger: " + error, LogWarning); });
320 
321     connect(d->connection, &QmlDebugConnection::connectionFailed,
322             this, &QmlEngine::connectionFailed);
323     connect(d->connection, &QmlDebugConnection::connected,
324             &d->connectionTimer, &QTimer::stop);
325     connect(d->connection, &QmlDebugConnection::connected,
326             this, &QmlEngine::connectionEstablished);
327     connect(d->connection, &QmlDebugConnection::disconnected,
328             this, &QmlEngine::disconnected);
329 
330     d->msgClient = new QDebugMessageClient(d->connection);
331     connect(d->msgClient, &QDebugMessageClient::newState,
332             this, [this](QmlDebugClient::State state) {
333         logServiceStateChange(d->msgClient->name(), d->msgClient->serviceVersion(), state);
334     });
335 
336     connect(d->msgClient, &QDebugMessageClient::message,
337             this, &appendDebugOutput);
338 
339     d->startupMessageFilterConnection = connect(
340                 runControl(), &RunControl::appendMessageRequested,
341                 d, &QmlEnginePrivate::filterApplicationMessage);
342 }
343 
344 QmlEngine::~QmlEngine()
345 {
346     QSet<IDocument *> documentsToClose;
347 
348     QHash<QString, QWeakPointer<BaseTextEditor> >::iterator iter;
349     for (iter = d->sourceEditors.begin(); iter != d->sourceEditors.end(); ++iter) {
350         QWeakPointer<BaseTextEditor> textEditPtr = iter.value();
351         if (textEditPtr)
352             documentsToClose << textEditPtr.data()->document();
353     }
354     EditorManager::closeDocuments(documentsToClose.toList());
355 
356     delete d;
357 }
358 
359 void QmlEngine::setupInferior()
360 {
361     QTC_ASSERT(state() == InferiorSetupRequested, qDebug() << state());
362 
363     notifyInferiorSetupOk();
364 
365     if (d->automaticConnect)
366         beginConnection();
367 }
368 
369 void QmlEngine::handleLauncherStarted()
370 {
371     // FIXME: The QmlEngine never calls notifyInferiorPid() triggering the
372     // raising, so do it here manually for now.
373     runControl()->bringApplicationToForeground();
374     d->noDebugOutputTimer.start();
375 }
376 
377 void QmlEngine::appendMessage(const QString &msg, Utils::OutputFormat /* format */)
378 {
379     showMessage(msg, AppOutput); // FIXME: Redirect to RunControl
380 }
381 
382 void QmlEngine::connectionEstablished()
383 {
384     attemptBreakpointSynchronization();
385 
386     if (state() == EngineRunRequested)
387         notifyEngineRunAndInferiorRunOk();
388 }
389 
390 void QmlEngine::tryToConnect(Utils::Port port)
391 {
392     showMessage("QML Debugger: No application output received in time, trying to connect ...", LogStatus);
393     d->retryOnConnectFail = true;
394     if (state() == EngineRunRequested) {
395         if (isSlaveEngine()) {
396             // Probably cpp is being debugged and hence we did not get the output yet.
397             if (!masterEngine()->isDying())
398                 beginConnection(port);
399             else
400                 appStartupFailed(tr("No application output received in time"));
401         } else {
402             beginConnection(port);
403         }
404     } else {
405         d->automaticConnect = true;
406     }
407 }
408 
409 void QmlEngine::beginConnection(Utils::Port port)
410 {
411     d->noDebugOutputTimer.stop();
412 
413     if (state() != EngineRunRequested && d->retryOnConnectFail)
414         return;
415 
416     QTC_ASSERT(state() == EngineRunRequested, return);
417 
418     QString host = runParameters().qmlServer.host;
419     // Use localhost as default
420     if (host.isEmpty())
421         host = "localhost";
422 
423     /*
424      * Let plugin-specific code override the port printed by the application. This is necessary
425      * in the case of port forwarding, when the port the application listens on is not the same that
426      * we want to connect to.
427      * NOTE: It is still necessary to wait for the output in that case, because otherwise we cannot
428      * be sure that the port is already open. The usual method of trying to connect repeatedly
429      * will not work, because the intermediate port is already open. So the connection
430      * will be accepted on that port but the forwarding to the target port will fail and
431      * the connection will be closed again (instead of returning the "connection refused"
432      * error that we expect).
433      */
434     if (runParameters().qmlServer.port.isValid())
435         port = runParameters().qmlServer.port;
436 
437     if (!d->connection || d->connection->isConnected())
438         return;
439 
440     d->connection->connectToHost(host, port.number());
441 
442     //A timeout to check the connection state
443     d->connectionTimer.start();
444 }
445 
446 void QmlEngine::connectionStartupFailed()
447 {
448     if (d->retryOnConnectFail) {
449         // retry after 3 seconds ...
450         QTimer::singleShot(3000, this, [this] { beginConnection(); });
451         return;
452     }
453 
454     QMessageBox *infoBox = new QMessageBox(ICore::mainWindow());
455     infoBox->setIcon(QMessageBox::Critical);
456     infoBox->setWindowTitle(tr("Qt Creator"));
457     infoBox->setText(tr("Could not connect to the in-process QML debugger."
458                         "\nDo you want to retry?"));
459     infoBox->setStandardButtons(QMessageBox::Retry | QMessageBox::Cancel |
460                                 QMessageBox::Help);
461     infoBox->setDefaultButton(QMessageBox::Retry);
462     infoBox->setModal(true);
463 
464     connect(infoBox, &QDialog::finished,
465             this, &QmlEngine::errorMessageBoxFinished);
466 
467     infoBox->show();
468 }
469 
470 void QmlEngine::appStartupFailed(const QString &errorMessage)
471 {
472     QString error = tr("Could not connect to the in-process QML debugger. %1").arg(errorMessage);
473 
474     if (isMasterEngine()) {
475         QMessageBox *infoBox = new QMessageBox(ICore::mainWindow());
476         infoBox->setIcon(QMessageBox::Critical);
477         infoBox->setWindowTitle(tr("Qt Creator"));
478         infoBox->setText(error);
479         infoBox->setStandardButtons(QMessageBox::Ok | QMessageBox::Help);
480         infoBox->setDefaultButton(QMessageBox::Ok);
481         connect(infoBox, &QDialog::finished,
482                 this, &QmlEngine::errorMessageBoxFinished);
483         infoBox->show();
484     } else {
485         debuggerConsole()->printItem(ConsoleItem::WarningType, error);
486     }
487 
488     notifyEngineRunFailed();
489 }
490 
491 void QmlEngine::errorMessageBoxFinished(int result)
492 {
493     switch (result) {
494     case QMessageBox::Retry: {
495         beginConnection();
496         break;
497     }
498     case QMessageBox::Help: {
499         HelpManager::handleHelpRequest("qthelp://org.qt-project.qtcreator/doc/creator-debugging-qml.html");
500         // fall through
501     }
502     default:
503         if (state() == InferiorRunOk) {
504             notifyInferiorSpontaneousStop();
505             notifyInferiorIll();
506         } else if (state() == EngineRunRequested) {
507             notifyEngineRunFailed();
508         }
509         break;
510     }
511 }
512 
513 void QmlEngine::gotoLocation(const Location &location)
514 {
515     const QString fileName = location.fileName();
516     if (QUrl(fileName).isLocalFile()) {
517         // internal file from source files -> show generated .js
518         QTC_ASSERT(d->sourceDocuments.contains(fileName), return);
519 
520         QString titlePattern = tr("JS Source for %1").arg(fileName);
521         //Check if there are open documents with the same title
522         foreach (IDocument *document, DocumentModel::openedDocuments()) {
523             if (document->displayName() == titlePattern) {
524                 EditorManager::activateEditorForDocument(document);
525                 return;
526             }
527         }
528         IEditor *editor = EditorManager::openEditorWithContents(
529                     QmlJSEditor::Constants::C_QMLJSEDITOR_ID, &titlePattern);
530         if (editor) {
531             editor->document()->setProperty(Constants::OPENED_BY_DEBUGGER, true);
532             if (auto plainTextEdit = qobject_cast<QPlainTextEdit *>(editor->widget()))
533                 plainTextEdit->setReadOnly(true);
534             updateDocument(editor->document(), d->sourceDocuments.value(fileName));
535         }
536     } else {
537         DebuggerEngine::gotoLocation(location);
538     }
539 }
540 
541 void QmlEngine::closeConnection()
542 {
543     if (d->connectionTimer.isActive()) {
544         d->connectionTimer.stop();
545     } else {
546         if (d->connection)
547             d->connection->close();
548     }
549 }
550 
551 void QmlEngine::runEngine()
552 {
553     QTC_ASSERT(state() == EngineRunRequested, qDebug() << state());
554 
555     if (!isSlaveEngine()) {
556         if (runParameters().startMode == AttachToRemoteServer)
557             d->noDebugOutputTimer.start();
558         else if (runParameters().startMode == AttachToRemoteProcess)
559             beginConnection();
560         else
561             startApplicationLauncher();
562     } else {
563         d->noDebugOutputTimer.start();
564     }
565 }
566 
567 void QmlEngine::startApplicationLauncher()
568 {
569     if (!d->applicationLauncher.isRunning()) {
570         StandardRunnable runnable = runParameters().inferior;
571         appendMessage(tr("Starting %1 %2").arg(
572                           QDir::toNativeSeparators(runnable.executable),
573                           runnable.commandLineArguments) + '\n',
574                       Utils::NormalMessageFormat);
575         d->applicationLauncher.start(runnable);
576     }
577 }
578 
579 void QmlEngine::stopApplicationLauncher()
580 {
581     if (d->applicationLauncher.isRunning()) {
582         disconnect(&d->applicationLauncher, &ApplicationLauncher::processExited,
583                    this, &QmlEngine::disconnected);
584         d->applicationLauncher.stop();
585     }
586 }
587 
588 void QmlEngine::notifyEngineRemoteSetupFinished(const RemoteSetupResult &result)
589 {
590     QObject::disconnect(d->startupMessageFilterConnection);
591     DebuggerEngine::notifyEngineRemoteSetupFinished(result);
592 
593     if (result.success) {
594         if (result.qmlServerPort.isValid())
595             runParameters().qmlServer.port = result.qmlServerPort;
596 
597         switch (state()) {
598         case InferiorSetupOk:
599             // FIXME: This is not a legal transition, but we need to
600             // get to EngineSetupOk somehow from InferiorSetupOk.
601             // fallthrough. QTCREATORBUG-14089.
602         case EngineSetupRequested:
603             notifyEngineSetupOk();
604             break;
605         case EngineSetupOk:
606         case EngineRunRequested:
607             // QTCREATORBUG-17718: On Android while doing debugging in mixed mode, the QML debug engine
608             // sometimes reports EngineSetupOK after the EngineRunRequested thus overwriting the state
609             // which eventually results into app to waiting for the QML engine connection.
610             // Skipping the EngineSetupOK in aforementioned case.
611             // Nothing to do here. The setup is already done.
612             break;
613         default:
614             QTC_ASSERT(false, qDebug() << "Unexpected state" << state());
615         }
616 
617         // The remote setup can take while especialy with mixed debugging.
618         // Just waiting for 8 seconds is not enough. Increase the timeout
619         // to 60 s
620         // In case we get an output the d->outputParser will start the connection.
621         d->noDebugOutputTimer.setInterval(60000);
622     } else {
623         if (isMasterEngine())
624             QMessageBox::critical(ICore::dialogParent(), tr("Failed to start application"),
625                                   tr("Application startup failed: %1").arg(result.reason));
626         notifyEngineSetupFailed();
627     }
628 }
629 
630 void QmlEngine::notifyEngineRemoteServerRunning(const QString &serverChannel, int pid)
631 {
632     bool ok = false;
633     quint16 qmlPort = serverChannel.toUInt(&ok);
634     if (ok)
635         runParameters().qmlServer.port = Utils::Port(qmlPort);
636     else
637         qWarning() << tr("QML debugging port not set: Unable to convert %1 to unsigned int.").arg(serverChannel);
638 
639     DebuggerEngine::notifyEngineRemoteServerRunning(serverChannel, pid);
640     notifyEngineSetupOk();
641 
642     // The remote setup can take a while especially with mixed debugging.
643     // Just waiting for 8 seconds is not enough. Increase the timeout to 60 s.
644     // In case we get an output the d->outputParser will start the connection.
645     d->noDebugOutputTimer.setInterval(60000);
646 }
647 
648 void QmlEngine::shutdownInferior()
649 {
650     // End session.
651     //    { "seq"     : <number>,
652     //      "type"    : "request",
653     //      "command" : "disconnect",
654     //    }
655     d->runCommand({DISCONNECT});
656 
657     if (isSlaveEngine())
658         resetLocation();
659     stopApplicationLauncher();
660     closeConnection();
661 
662     notifyInferiorShutdownOk();
663 }
664 
665 void QmlEngine::shutdownEngine()
666 {
667     clearExceptionSelection();
668 
669     debuggerConsole()->setScriptEvaluator(ScriptEvaluator());
670     d->noDebugOutputTimer.stop();
671 
672    // double check (ill engine?):
673     stopApplicationLauncher();
674 
675     notifyEngineShutdownOk();
676     if (!isSlaveEngine())
677         showMessage(QString(), StatusBar);
678 }
679 
680 void QmlEngine::setupEngine()
681 {
682     if (runParameters().remoteSetupNeeded) {
683         // we need to get the port first
684         notifyEngineRequestRemoteSetup();
685     } else {
686         notifyEngineSetupOk();
687     }
688 }
689 
690 void QmlEngine::continueInferior()
691 {
692     QTC_ASSERT(state() == InferiorStopOk, qDebug() << state());
693     clearExceptionSelection();
694     d->continueDebugging(Continue);
695     resetLocation();
696     notifyInferiorRunRequested();
697     notifyInferiorRunOk();
698 }
699 
700 void QmlEngine::interruptInferior()
701 {
702     showMessage(INTERRUPT, LogInput);
703     d->runDirectCommand(INTERRUPT);
704     showStatusMessage(tr("Waiting for JavaScript engine to interrupt on next statement."));
705 }
706 
707 void QmlEngine::executeStep()
708 {
709     clearExceptionSelection();
710     d->continueDebugging(StepIn);
711     notifyInferiorRunRequested();
712     notifyInferiorRunOk();
713 }
714 
715 void QmlEngine::executeStepI()
716 {
717     clearExceptionSelection();
718     d->continueDebugging(StepIn);
719     notifyInferiorRunRequested();
720     notifyInferiorRunOk();
721 }
722 
723 void QmlEngine::executeStepOut()
724 {
725     clearExceptionSelection();
726     d->continueDebugging(StepOut);
727     notifyInferiorRunRequested();
728     notifyInferiorRunOk();
729 }
730 
731 void QmlEngine::executeNext()
732 {
733     clearExceptionSelection();
734     d->continueDebugging(Next);
735     notifyInferiorRunRequested();
736     notifyInferiorRunOk();
737 }
738 
739 void QmlEngine::executeNextI()
740 {
741     executeNext();
742 }
743 
744 void QmlEngine::executeRunToLine(const ContextData &data)
745 {
746     QTC_ASSERT(state() == InferiorStopOk, qDebug() << state());
747     showStatusMessage(tr("Run to line %1 (%2) requested...").arg(data.lineNumber).arg(data.fileName), 5000);
748     d->setBreakpoint(SCRIPTREGEXP, data.fileName, true, data.lineNumber);
749     clearExceptionSelection();
750     d->continueDebugging(Continue);
751 
752     notifyInferiorRunRequested();
753     notifyInferiorRunOk();
754 }
755 
756 void QmlEngine::executeRunToFunction(const QString &functionName)
757 {
758     Q_UNUSED(functionName)
759     XSDEBUG("FIXME:  QmlEngine::executeRunToFunction()");
760 }
761 
762 void QmlEngine::executeJumpToLine(const ContextData &data)
763 {
764     Q_UNUSED(data)
765     XSDEBUG("FIXME:  QmlEngine::executeJumpToLine()");
766 }
767 
768 void QmlEngine::activateFrame(int index)
769 {
770     if (state() != InferiorStopOk && state() != InferiorUnrunnable)
771         return;
772 
773     stackHandler()->setCurrentIndex(index);
774     gotoLocation(stackHandler()->frames().value(index));
775 
776     d->updateLocals();
777 }
778 
779 void QmlEngine::selectThread(ThreadId threadId)
780 {
781     Q_UNUSED(threadId)
782 }
783 
784 void QmlEngine::insertBreakpoint(Breakpoint bp)
785 {
786     BreakpointState state = bp.state();
787     QTC_ASSERT(state == BreakpointInsertRequested, qDebug() << bp << this << state);
788     bp.notifyBreakpointInsertProceeding();
789 
790     const BreakpointParameters &params = bp.parameters();
791     if (params.type == BreakpointAtJavaScriptThrow) {
792         BreakpointResponse br = bp.response();
793         br.pending = false;
794         bp.setResponse(br);
795         bp.notifyBreakpointInsertOk();
796         d->setExceptionBreak(AllExceptions, params.enabled);
797 
798     } else if (params.type == BreakpointByFileAndLine) {
799         d->setBreakpoint(SCRIPTREGEXP, params.fileName,
800                          params.enabled, params.lineNumber, 0,
801                          params.condition, params.ignoreCount);
802 
803     } else if (params.type == BreakpointOnQmlSignalEmit) {
804         d->setBreakpoint(EVENT, params.functionName, params.enabled);
805         BreakpointResponse br = bp.response();
806         br.pending = false;
807         bp.setResponse(br);
808         bp.notifyBreakpointInsertOk();
809     }
810 
811     d->breakpointsSync.insert(d->sequence, bp.id());
812 }
813 
814 void QmlEngine::resetLocation()
815 {
816     DebuggerEngine::resetLocation();
817     d->currentlyLookingUp.clear();
818 }
819 
820 void QmlEngine::removeBreakpoint(Breakpoint bp)
821 {
822     const BreakpointParameters &params = bp.parameters();
823 
824     BreakpointState state = bp.state();
825     QTC_ASSERT(state == BreakpointRemoveRequested, qDebug() << bp << this << state);
826     bp.notifyBreakpointRemoveProceeding();
827 
828     int breakpoint = d->breakpoints.value(bp.id());
829     d->breakpoints.remove(bp.id());
830 
831     if (params.type == BreakpointAtJavaScriptThrow)
832         d->setExceptionBreak(AllExceptions);
833     else if (params.type == BreakpointOnQmlSignalEmit)
834         d->setBreakpoint(EVENT, params.functionName, false);
835     else
836         d->clearBreakpoint(breakpoint);
837 
838     if (bp.state() == BreakpointRemoveProceeding)
839         bp.notifyBreakpointRemoveOk();
840 }
841 
842 void QmlEngine::changeBreakpoint(Breakpoint bp)
843 {
844     BreakpointState state = bp.state();
845     QTC_ASSERT(state == BreakpointChangeRequested, qDebug() << bp << this << state);
846     bp.notifyBreakpointChangeProceeding();
847 
848     const BreakpointParameters &params = bp.parameters();
849 
850     BreakpointResponse br = bp.response();
851     if (params.type == BreakpointAtJavaScriptThrow) {
852         d->setExceptionBreak(AllExceptions, params.enabled);
853         br.enabled = params.enabled;
854         bp.setResponse(br);
855     } else if (params.type == BreakpointOnQmlSignalEmit) {
856         d->setBreakpoint(EVENT, params.functionName, params.enabled);
857         br.enabled = params.enabled;
858         bp.setResponse(br);
859     } else {
860         //V8 supports only minimalistic changes in breakpoint
861         //Remove the breakpoint and add again
862         bp.notifyBreakpointChangeOk();
863         bp.removeBreakpoint();
864         BreakHandler *handler = d->engine->breakHandler();
865         handler->appendBreakpoint(params);
866     }
867 
868     if (bp.state() == BreakpointChangeProceeding)
869         bp.notifyBreakpointChangeOk();
870 }
871 
872 void QmlEngine::attemptBreakpointSynchronization()
873 {
874     if (!stateAcceptsBreakpointChanges()) {
875         showMessage("BREAKPOINT SYNCHRONIZATION NOT POSSIBLE IN CURRENT STATE");
876         return;
877     }
878 
879     BreakHandler *handler = breakHandler();
880 
881     DebuggerEngine *bpOwner = isSlaveEngine() ? masterEngine() : this;
882     foreach (Breakpoint bp, handler->unclaimedBreakpoints()) {
883         // Take ownership of the breakpoint. Requests insertion.
884         if (acceptsBreakpoint(bp))
885             bp.setEngine(bpOwner);
886     }
887 
888     foreach (Breakpoint bp, handler->engineBreakpoints(bpOwner)) {
889         switch (bp.state()) {
890         case BreakpointNew:
891             // Should not happen once claimed.
892             QTC_CHECK(false);
893             continue;
894         case BreakpointInsertRequested:
895             insertBreakpoint(bp);
896             continue;
897         case BreakpointChangeRequested:
898             changeBreakpoint(bp);
899             continue;
900         case BreakpointRemoveRequested:
901             removeBreakpoint(bp);
902             continue;
903         case BreakpointChangeProceeding:
904         case BreakpointInsertProceeding:
905         case BreakpointRemoveProceeding:
906         case BreakpointInserted:
907         case BreakpointDead:
908             continue;
909         }
910         QTC_ASSERT(false, qDebug() << "UNKNOWN STATE"  << bp << state());
911     }
912 
913     DebuggerEngine::attemptBreakpointSynchronization();
914 }
915 
916 bool QmlEngine::acceptsBreakpoint(Breakpoint bp) const
917 {
918     if (!bp.parameters().isCppBreakpoint())
919             return true;
920 
921     //If it is a Cpp Breakpoint query if the type can be also handled by the debugger client
922     //TODO: enable setting of breakpoints before start of debug session
923     //For now, the event breakpoint can be set after the activeDebuggerClient is known
924     //This is because the older client does not support BreakpointOnQmlSignalHandler
925     BreakpointType type = bp.type();
926     return type == BreakpointOnQmlSignalEmit
927             || type == BreakpointByFileAndLine
928             || type == BreakpointAtJavaScriptThrow;
929 }
930 
931 void QmlEngine::loadSymbols(const QString &moduleName)
932 {
933     Q_UNUSED(moduleName)
934 }
935 
936 void QmlEngine::loadAllSymbols()
937 {
938 }
939 
940 void QmlEngine::reloadModules()
941 {
942 }
943 
944 void QmlEngine::reloadSourceFiles()
945 {
946     d->scripts(4, QList<int>(), true, QVariant());
947 }
948 
949 void QmlEngine::updateAll()
950 {
951     d->updateLocals();
952 }
953 
954 void QmlEngine::requestModuleSymbols(const QString &moduleName)
955 {
956     Q_UNUSED(moduleName)
957 }
958 
959 bool QmlEngine::canHandleToolTip(const DebuggerToolTipContext &) const
960 {
961     // This is processed by QML inspector, which has dependencies to
962     // the qml js editor. Makes life easier.
963     // FIXME: Except that there isn't any attached.
964     return true;
965 }
966 
967 void QmlEngine::assignValueInDebugger(WatchItem *item,
968     const QString &expression, const QVariant &value)
969 {
970     if (!expression.isEmpty()) {
971         if (item->isInspect()) {
972             d->inspectorAgent.assignValue(item, expression, value);
973         } else {
974             StackHandler *handler = stackHandler();
975             QString exp = QString("%1 = %2;").arg(expression).arg(value.toString());
976             if (handler->isContentsValid() && handler->currentFrame().isUsable()) {
977                 d->evaluate(exp, -1, [this](const QVariantMap &) { d->updateLocals(); });
978             } else {
979                 showMessage(QString("Cannot evaluate %1 in current stack frame")
980                             .arg(expression), ConsoleOutput);
981             }
982         }
983     }
984 }
985 
986 void QmlEngine::expandItem(const QString &iname)
987 {
988     const WatchItem *item = watchHandler()->findItem(iname);
989     QTC_ASSERT(item, return);
990 
991     if (item->isInspect()) {
992         d->inspectorAgent.updateWatchData(*item);
993     } else {
994         LookupItems items;
995         items.insert(int(item->id), {item->iname, item->name, item->exp});
996         d->lookup(items);
997     }
998 }
999 
1000 void QmlEngine::updateItem(const QString &iname)
1001 {
1002     const WatchItem *item = watchHandler()->findItem(iname);
1003     QTC_ASSERT(item, return);
1004 
1005     if (state() == InferiorStopOk) {
1006         // The Qt side Q_ASSERTs otherwise. So postpone the evaluation,
1007         // it will be triggered from from upateLocals() later.
1008         QString exp = item->exp;
1009         d->evaluate(exp, -1, [this, iname, exp](const QVariantMap &response) {
1010             d->handleEvaluateExpression(response, iname, exp);
1011         });
1012     }
1013 }
1014 
1015 void QmlEngine::selectWatchData(const QString &iname)
1016 {
1017     const WatchItem *item = watchHandler()->findItem(iname);
1018     if (item && item->isInspect())
1019         d->inspectorAgent.watchDataSelected(item->id);
1020 }
1021 
1022 bool compareConsoleItems(const ConsoleItem *a, const ConsoleItem *b)
1023 {
1024     if (a == 0)
1025         return true;
1026     if (b == 0)
1027         return false;
1028     return a->text() < b->text();
1029 }
1030 
1031 static ConsoleItem *constructLogItemTree(const QVariant &result,
1032                                          const QString &key = QString())
1033 {
1034     bool sorted = boolSetting(SortStructMembers);
1035     if (!result.isValid())
1036         return 0;
1037 
1038     QString text;
1039     ConsoleItem *item = 0;
1040     if (result.type() == QVariant::Map) {
1041         if (key.isEmpty())
1042             text = "Object";
1043         else
1044             text = key + " : Object";
1045 
1046         QMap<QString, QVariant> resultMap = result.toMap();
1047         QVarLengthArray<ConsoleItem *> children(resultMap.size());
1048         QMapIterator<QString, QVariant> i(result.toMap());
1049         auto it = children.begin();
1050         while (i.hasNext()) {
1051             i.next();
1052             *(it++) = constructLogItemTree(i.value(), i.key());
1053         }
1054 
1055         // Sort before inserting as ConsoleItem::sortChildren causes a whole cascade of changes we
1056         // may not want to handle here.
1057         if (sorted)
1058             std::sort(children.begin(), children.end(), compareConsoleItems);
1059 
1060         item = new ConsoleItem(ConsoleItem::DefaultType, text);
1061         foreach (ConsoleItem *child, children) {
1062             if (child)
1063                 item->appendChild(child);
1064         }
1065 
1066     } else if (result.type() == QVariant::List) {
1067         if (key.isEmpty())
1068             text = "List";
1069         else
1070             text = QString("[%1] : List").arg(key);
1071 
1072         QVariantList resultList = result.toList();
1073         QVarLengthArray<ConsoleItem *> children(resultList.size());
1074         for (int i = 0; i < resultList.count(); i++)
1075             children[i] = constructLogItemTree(resultList.at(i), QString::number(i));
1076 
1077         if (sorted)
1078             std::sort(children.begin(), children.end(), compareConsoleItems);
1079 
1080         item = new ConsoleItem(ConsoleItem::DefaultType, text);
1081         foreach (ConsoleItem *child, children) {
1082             if (child)
1083                 item->appendChild(child);
1084         }
1085     } else if (result.canConvert(QVariant::String)) {
1086         item = new ConsoleItem(ConsoleItem::DefaultType, result.toString());
1087     } else {
1088         item = new ConsoleItem(ConsoleItem::DefaultType, "Unknown Value");
1089     }
1090 
1091     return item;
1092 }
1093 
1094 void QmlEngine::expressionEvaluated(quint32 queryId, const QVariant &result)
1095 {
1096     if (d->queryIds.contains(queryId)) {
1097         d->queryIds.removeOne(queryId);
1098         if (ConsoleItem *item = constructLogItemTree(result))
1099             debuggerConsole()->printItem(item);
1100     }
1101 }
1102 
1103 bool QmlEngine::hasCapability(unsigned cap) const
1104 {
1105     return cap & (AddWatcherCapability
1106             | AddWatcherWhileRunningCapability
1107             | RunToLineCapability);
1108     /*ReverseSteppingCapability | SnapshotCapability
1109         | AutoDerefPointersCapability | DisassemblerCapability
1110         | RegisterCapability | ShowMemoryCapability
1111         | JumpToLineCapability | ReloadModuleCapability
1112         | ReloadModuleSymbolsCapability | BreakOnThrowAndCatchCapability
1113         | ReturnFromFunctionCapability
1114         | CreateFullBacktraceCapability
1115         | WatchpointCapability
1116         | AddWatcherCapability;*/
1117 }
1118 
1119 void QmlEngine::quitDebugger()
1120 {
1121     d->noDebugOutputTimer.stop();
1122     d->automaticConnect = false;
1123     d->retryOnConnectFail = false;
1124     shutdownInferior();
1125 }
1126 
1127 void QmlEngine::doUpdateLocals(const UpdateParameters &params)
1128 {
1129     Q_UNUSED(params);
1130     d->updateLocals();
1131 }
1132 
1133 void QmlEngine::disconnected()
1134 {
1135     showMessage(tr("QML Debugger disconnected."), StatusBar);
1136     notifyInferiorExited();
1137 }
1138 
1139 void QmlEngine::updateCurrentContext()
1140 {
1141     QString context;
1142     switch (state()) {
1143     case InferiorStopOk:
1144         context = stackHandler()->currentFrame().function;
1145         break;
1146     case InferiorRunOk:
1147         if (d->contextEvaluate || !d->unpausedEvaluate) {
1148             // !unpausedEvaluate means we are using the old QQmlEngineDebugService which understands
1149             // context. contextEvaluate means the V4 debug service can handle context.
1150             QModelIndex currentIndex = inspectorView()->currentIndex();
1151             const WatchItem *currentData = watchHandler()->watchItem(currentIndex);
1152             if (!currentData)
1153                 return;
1154             const WatchItem *parentData = watchHandler()->watchItem(currentIndex.parent());
1155             const WatchItem *grandParentData = watchHandler()->watchItem(currentIndex.parent().parent());
1156             if (currentData->id != parentData->id)
1157                 context = currentData->name;
1158             else if (parentData->id != grandParentData->id)
1159                 context = parentData->name;
1160             else
1161                 context = grandParentData->name;
1162         }
1163         break;
1164     default:
1165         // No context. Clear the label
1166         debuggerConsole()->setContext(QString());
1167         return;
1168     }
1169 
1170     debuggerConsole()->setContext(tr("Context:") + QLatin1Char(' ')
1171                                   + (context.isEmpty() ? tr("Global QML Context") : context));
1172 }
1173 
1174 void QmlEngine::executeDebuggerCommand(const QString &command, DebuggerLanguages languages)
1175 {
1176     if (!(languages & QmlLanguage))
1177         return;
1178 
1179     if (state() == InferiorStopOk) {
1180         StackHandler *handler = stackHandler();
1181         if (handler->isContentsValid() && handler->currentFrame().isUsable()) {
1182             d->evaluate(command, -1, CB(d->handleExecuteDebuggerCommand));
1183         } else {
1184             // Paused but no stack? Something is wrong
1185             d->engine->showMessage(QString("Cannot evaluate %1. The stack trace is broken.").arg(command),
1186                                    ConsoleOutput);
1187         }
1188     } else {
1189         QModelIndex currentIndex = inspectorView()->currentIndex();
1190         qint64 contextId = watchHandler()->watchItem(currentIndex)->id;
1191 
1192         if (d->unpausedEvaluate) {
1193             d->evaluate(command, contextId, CB(d->handleExecuteDebuggerCommand));
1194         } else {
1195             quint32 queryId = d->inspectorAgent.queryExpressionResult(contextId, command);
1196             if (queryId) {
1197                 d->queryIds.append(queryId);
1198             } else {
1199                 d->engine->showMessage("The application has to be stopped in a breakpoint in order to"
1200                                        " evaluate expressions", ConsoleOutput);
1201             }
1202         }
1203     }
1204 }
1205 
1206 void QmlEnginePrivate::updateScriptSource(const QString &fileName, int lineOffset, int columnOffset,
1207                                           const QString &source)
1208 {
1209     QTextDocument *document = 0;
1210     if (sourceDocuments.contains(fileName)) {
1211         document = sourceDocuments.value(fileName);
1212     } else {
1213         document = new QTextDocument(this);
1214         sourceDocuments.insert(fileName, document);
1215     }
1216 
1217     // We're getting an unordered set of snippets that can even interleave
1218     // Therefore we've to carefully update the existing document
1219 
1220     QTextCursor cursor(document);
1221     for (int i = 0; i < lineOffset; ++i) {
1222         if (!cursor.movePosition(QTextCursor::NextBlock))
1223             cursor.insertBlock();
1224     }
1225     QTC_CHECK(cursor.blockNumber() == lineOffset);
1226 
1227     for (int i = 0; i < columnOffset; ++i) {
1228         if (!cursor.movePosition(QTextCursor::NextCharacter))
1229             cursor.insertText(" ");
1230     }
1231     QTC_CHECK(cursor.positionInBlock() == columnOffset);
1232 
1233     QStringList lines = source.split('\n');
1234     foreach (QString line, lines) {
1235         if (line.endsWith('\r'))
1236             line.remove(line.size() -1, 1);
1237 
1238         // line already there?
1239         QTextCursor existingCursor(cursor);
1240         existingCursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
1241         if (existingCursor.selectedText() != line)
1242             cursor.insertText(line);
1243 
1244         if (!cursor.movePosition(QTextCursor::NextBlock))
1245             cursor.insertBlock();
1246     }
1247 
1248     //update open editors
1249     QString titlePattern = QCoreApplication::translate("QmlEngine", "JS Source for %1").arg(fileName);
1250     //Check if there are open editors with the same title
1251     foreach (IDocument *doc, DocumentModel::openedDocuments()) {
1252         if (doc->displayName() == titlePattern) {
1253             updateDocument(doc, document);
1254             break;
1255         }
1256     }
1257 }
1258 
1259 bool QmlEnginePrivate::canEvaluateScript(const QString &script)
1260 {
1261     interpreter.clearText();
1262     interpreter.appendText(script);
1263     return interpreter.canEvaluate();
1264 }
1265 
1266 void QmlEngine::connectionFailed()
1267 {
1268     // this is only an error if we are already connected and something goes wrong.
1269     if (isConnected()) {
1270         showMessage(tr("QML Debugger: Connection failed."), StatusBar);
1271 
1272         if (!isSlaveEngine()) { // normal flow for slave engine when gdb exits
1273             notifyInferiorSpontaneousStop();
1274             notifyInferiorIll();
1275         }
1276     } else {
1277         d->connectionTimer.stop();
1278         connectionStartupFailed();
1279     }
1280 }
1281 
1282 void QmlEngine::checkConnectionState()
1283 {
1284     if (!isConnected()) {
1285         closeConnection();
1286         connectionStartupFailed();
1287     }
1288 }
1289 
1290 bool QmlEngine::isConnected() const
1291 {
1292     return d->connection->isConnected();
1293 }
1294 
1295 void QmlEngine::showConnectionStateMessage(const QString &message)
1296 {
1297     showMessage("QML Debugger: " + message, LogStatus);
1298 }
1299 
1300 void QmlEngine::logServiceStateChange(const QString &service, float version,
1301                                       QmlDebugClient::State newState)
1302 {
1303     switch (newState) {
1304     case QmlDebugClient::Unavailable: {
1305         showConnectionStateMessage(QString("Status of \"%1\" Version: %2 changed to 'unavailable'.").
1306                                    arg(service).arg(version));
1307         break;
1308     }
1309     case QmlDebugClient::Enabled: {
1310         showConnectionStateMessage(QString("Status of \"%1\" Version: %2 changed to 'enabled'.").
1311                                     arg(service).arg(version));
1312         break;
1313     }
1314 
1315     case QmlDebugClient::NotConnected: {
1316         showConnectionStateMessage(QString("Status of \"%1\" Version: %2 changed to 'not connected'.").
1317                                     arg(service).arg(version));
1318         break;
1319     }
1320     }
1321 }
1322 
1323 void QmlEngine::logServiceActivity(const QString &service, const QString &logMessage)
1324 {
1325     showMessage(service + ' ' + logMessage, LogDebug);
1326 }
1327 
1328 void QmlEnginePrivate::continueDebugging(StepAction action)
1329 {
1330     //    { "seq"       : <number>,
1331     //      "type"      : "request",
1332     //      "command"   : "continue",
1333     //      "arguments" : { "stepaction" : <"in", "next" or "out">,
1334     //                      "stepcount"  : <number of steps (default 1)>
1335     //                    }
1336     //    }
1337 
1338     DebuggerCommand cmd(CONTINEDEBUGGING);
1339 
1340     if (action == StepIn)
1341         cmd.arg(STEPACTION, IN);
1342     else if (action == StepOut)
1343         cmd.arg(STEPACTION, OUT);
1344     else if (action == Next)
1345         cmd.arg(STEPACTION, NEXT);
1346 
1347     runCommand(cmd);
1348 
1349     previousStepAction = action;
1350 }
1351 
1352 void QmlEnginePrivate::evaluate(const QString expr, qint64 context, const QmlCallback &cb)
1353 {
1354     //    { "seq"       : <number>,
1355     //      "type"      : "request",
1356     //      "command"   : "evaluate",
1357     //      "arguments" : { "expression"    : <expression to evaluate>,
1358     //                      "frame"         : <number>,
1359     //                      "global"        : <boolean>,
1360     //                      "disable_break" : <boolean>,
1361     //                      "context"       : <object id>
1362     //                    }
1363     //    }
1364 
1365     // The Qt side Q_ASSERTs otherwise. So ignore the request and hope
1366     // it will be repeated soon enough (which it will, e.g. in updateLocals)
1367     QTC_ASSERT(unpausedEvaluate || engine->state() == InferiorStopOk, return);
1368 
1369     DebuggerCommand cmd(EVALUATE);
1370 
1371     cmd.arg(EXPRESSION, expr);
1372     StackHandler *handler = engine->stackHandler();
1373     if (handler->currentFrame().isUsable())
1374         cmd.arg(FRAME, handler->currentIndex());
1375 
1376     if (context >= 0)
1377         cmd.arg(CONTEXT, context);
1378 
1379     runCommand(cmd, cb);
1380 }
1381 
1382 void QmlEnginePrivate::handleEvaluateExpression(const QVariantMap &response,
1383                                                 const QString &iname,
1384                                                 const QString &exp)
1385 {
1386     //    { "seq"         : <number>,
1387     //      "type"        : "response",
1388     //      "request_seq" : <number>,
1389     //      "command"     : "evaluate",
1390     //      "body"        : ...
1391     //      "running"     : <is the VM running after sending this response>
1392     //      "success"     : true
1393     //    }
1394 
1395     QVariant bodyVal = response.value(BODY).toMap();
1396     QmlV8ObjectData body = extractData(bodyVal);
1397     WatchHandler *watchHandler = engine->watchHandler();
1398 
1399     auto item = new WatchItem;
1400     item->iname = iname;
1401     item->name = exp;
1402     item->exp = exp;
1403     item->id = body.handle;
1404     bool success = response.value("success").toBool();
1405     if (success) {
1406         item->type = body.type;
1407         item->value = body.value.toString();
1408         item->setHasChildren(body.hasChildren());
1409     } else {
1410         //Do not set type since it is unknown
1411         item->setError(body.value.toString());
1412     }
1413     insertSubItems(item, body.properties);
1414     watchHandler->insertItem(item);
1415     watchHandler->updateWatchersWindow();
1416 }
1417 
1418 void QmlEnginePrivate::lookup(const LookupItems &items)
1419 {
1420     //    { "seq"       : <number>,
1421     //      "type"      : "request",
1422     //      "command"   : "lookup",
1423     //      "arguments" : { "handles"       : <array of handles>,
1424     //                      "includeSource" : <boolean indicating whether
1425     //                                          the source will be included when
1426     //                                          script objects are returned>,
1427     //                    }
1428     //    }
1429 
1430     if (items.isEmpty())
1431         return;
1432 
1433     QList<int> handles;
1434     for (auto it = items.begin(); it != items.end(); ++it) {
1435         const int handle = it.key();
1436         if (!currentlyLookingUp.contains(handle)) {
1437             currentlyLookingUp.insert(handle, it.value());
1438             handles.append(handle);
1439         }
1440     }
1441 
1442     DebuggerCommand cmd(LOOKUP);
1443     cmd.arg(HANDLES, handles);
1444     runCommand(cmd, CB(handleLookup));
1445 }
1446 
1447 void QmlEnginePrivate::backtrace()
1448 {
1449     //    { "seq"       : <number>,
1450     //      "type"      : "request",
1451     //      "command"   : "backtrace",
1452     //      "arguments" : { "fromFrame" : <number>
1453     //                      "toFrame" : <number>
1454     //                      "bottom" : <boolean, set to true if the bottom of the
1455     //                          stack is requested>
1456     //                    }
1457     //    }
1458 
1459     DebuggerCommand cmd(BACKTRACE);
1460     runCommand(cmd, CB(handleBacktrace));
1461 }
1462 
1463 void QmlEnginePrivate::updateLocals()
1464 {
1465     //    { "seq"       : <number>,
1466     //      "type"      : "request",
1467     //      "command"   : "frame",
1468     //      "arguments" : { "number" : <frame number> }
1469     //    }
1470 
1471     DebuggerCommand cmd(FRAME);
1472     cmd.arg(NUMBER, stackIndexLookup.value(engine->stackHandler()->currentIndex()));
1473     runCommand(cmd, CB(handleFrame));
1474 }
1475 
1476 void QmlEnginePrivate::scope(int number, int frameNumber)
1477 {
1478     //    { "seq"       : <number>,
1479     //      "type"      : "request",
1480     //      "command"   : "scope",
1481     //      "arguments" : { "number" : <scope number>
1482     //                      "frameNumber" : <frame number, optional uses selected
1483     //                                      frame if missing>
1484     //                    }
1485     //    }
1486 
1487     DebuggerCommand cmd(SCOPE);
1488     cmd.arg(NUMBER, number);
1489     if (frameNumber != -1)
1490         cmd.arg(FRAMENUMBER, frameNumber);
1491 
1492     runCommand(cmd, CB(handleScope));
1493 }
1494 
1495 void QmlEnginePrivate::scripts(int types, const QList<int> ids, bool includeSource,
1496                                const QVariant filter)
1497 {
1498     //    { "seq"       : <number>,
1499     //      "type"      : "request",
1500     //      "command"   : "scripts",
1501     //      "arguments" : { "types"         : <types of scripts to retrieve
1502     //                                           set bit 0 for native scripts
1503     //                                           set bit 1 for extension scripts
1504     //                                           set bit 2 for normal scripts
1505     //                                         (default is 4 for normal scripts)>
1506     //                      "ids"           : <array of id's of scripts to return. If this is not specified all scripts are requrned>
1507     //                      "includeSource" : <boolean indicating whether the source code should be included for the scripts returned>
1508     //                      "filter"        : <string or number: filter string or script id.
1509     //                                         If a number is specified, then only the script with the same number as its script id will be retrieved.
1510     //                                         If a string is specified, then only scripts whose names contain the filter string will be retrieved.>
1511     //                    }
1512     //    }
1513 
1514     DebuggerCommand cmd(SCRIPTS);
1515     cmd.arg(TYPES, types);
1516 
1517     if (ids.count())
1518         cmd.arg(IDS, ids);
1519 
1520     if (includeSource)
1521         cmd.arg(INCLUDESOURCE, includeSource);
1522 
1523     if (filter.type() == QVariant::String)
1524         cmd.arg(FILTER, filter.toString());
1525     else if (filter.type() == QVariant::Int)
1526         cmd.arg(FILTER, filter.toInt());
1527     else
1528         QTC_CHECK(!filter.isValid());
1529 
1530     runCommand(cmd);
1531 }
1532 
1533 void QmlEnginePrivate::setBreakpoint(const QString type, const QString target,
1534                                      bool enabled, int line, int column,
1535                                      const QString condition, int ignoreCount)
1536 {
1537     //    { "seq"       : <number>,
1538     //      "type"      : "request",
1539     //      "command"   : "setbreakpoint",
1540     //      "arguments" : { "type"        : <"function" or "script" or "scriptId" or "scriptRegExp">
1541     //                      "target"      : <function expression or script identification>
1542     //                      "line"        : <line in script or function>
1543     //                      "column"      : <character position within the line>
1544     //                      "enabled"     : <initial enabled state. True or false, default is true>
1545     //                      "condition"   : <string with break point condition>
1546     //                      "ignoreCount" : <number specifying the number of break point hits to ignore, default value is 0>
1547     //                    }
1548     //    }
1549     if (type == EVENT) {
1550         QPacket rs(connection->currentDataStreamVersion());
1551         rs <<  target.toUtf8() << enabled;
1552         engine->showMessage(QString("%1 %2 %3")
1553                             .arg(BREAKONSIGNAL, target, QLatin1String(enabled ? "enabled" : "disabled")), LogInput);
1554         runDirectCommand(BREAKONSIGNAL, rs.data());
1555 
1556     } else {
1557         DebuggerCommand cmd(SETBREAKPOINT);
1558         cmd.arg(TYPE, type);
1559         cmd.arg(ENABLED, enabled);
1560 
1561         if (type == SCRIPTREGEXP)
1562             cmd.arg(TARGET, Utils::FileName::fromString(target).fileName());
1563         else
1564             cmd.arg(TARGET, target);
1565 
1566         if (line)
1567             cmd.arg(LINE, line - 1);
1568         if (column)
1569             cmd.arg(COLUMN, column - 1);
1570         if (!condition.isEmpty())
1571             cmd.arg(CONDITION, condition);
1572         if (ignoreCount != -1)
1573             cmd.arg(IGNORECOUNT, ignoreCount);
1574 
1575         runCommand(cmd);
1576     }
1577 }
1578 
1579 void QmlEnginePrivate::clearBreakpoint(int breakpoint)
1580 {
1581     //    { "seq"       : <number>,
1582     //      "type"      : "request",
1583     //      "command"   : "clearbreakpoint",
1584     //      "arguments" : { "breakpoint" : <number of the break point to clear>
1585     //                    }
1586     //    }
1587 
1588     DebuggerCommand cmd(CLEARBREAKPOINT);
1589     cmd.arg(BREAKPOINT, breakpoint);
1590     runCommand(cmd);
1591 }
1592 
1593 void QmlEnginePrivate::setExceptionBreak(Exceptions type, bool enabled)
1594 {
1595     //    { "seq"       : <number>,
1596     //      "type"      : "request",
1597     //      "command"   : "setexceptionbreak",
1598     //      "arguments" : { "type"    : <string: "all", or "uncaught">,
1599     //                      "enabled" : <optional bool: enables the break type if true>
1600     //                    }
1601     //    }
1602 
1603     DebuggerCommand cmd(SETEXCEPTIONBREAK);
1604     if (type == AllExceptions)
1605         cmd.arg(TYPE, ALL);
1606 
1607     //Not Supported:
1608     // else if (type == UncaughtExceptions)
1609     //    cmd.args(TYPE, UNCAUGHT);
1610 
1611     if (enabled)
1612         cmd.arg(ENABLED, enabled);
1613 
1614     runCommand(cmd);
1615 }
1616 
1617 QmlV8ObjectData QmlEnginePrivate::extractData(const QVariant &data) const
1618 {
1619     //    { "handle" : <handle>,
1620     //      "type"   : <"undefined", "null", "boolean", "number", "string", "object", "function" or "frame">
1621     //    }
1622 
1623     //    {"handle":<handle>,"type":"undefined"}
1624 
1625     //    {"handle":<handle>,"type":"null"}
1626 
1627     //    { "handle":<handle>,
1628     //      "type"  : <"boolean", "number" or "string">
1629     //      "value" : <JSON encoded value>
1630     //    }
1631 
1632     //    {"handle":7,"type":"boolean","value":true}
1633 
1634     //    {"handle":8,"type":"number","value":42}
1635 
1636     //    { "handle"              : <handle>,
1637     //      "type"                : "object",
1638     //      "className"           : <Class name, ECMA-262 property [[Class]]>,
1639     //      "constructorFunction" : {"ref":<handle>},
1640     //      "protoObject"         : {"ref":<handle>},
1641     //      "prototypeObject"     : {"ref":<handle>},
1642     //      "properties" : [ {"name" : <name>,
1643     //                        "ref"  : <handle>
1644     //                       },
1645     //                       ...
1646     //                     ]
1647     //    }
1648 
1649     //        { "handle" : <handle>,
1650     //          "type"                : "function",
1651     //          "className"           : "Function",
1652     //          "constructorFunction" : {"ref":<handle>},
1653     //          "protoObject"         : {"ref":<handle>},
1654     //          "prototypeObject"     : {"ref":<handle>},
1655     //          "name"                : <function name>,
1656     //          "inferredName"        : <inferred function name for anonymous functions>
1657     //          "source"              : <function source>,
1658     //          "script"              : <reference to function script>,
1659     //          "scriptId"            : <id of function script>,
1660     //          "position"            : <function begin position in script>,
1661     //          "line"                : <function begin source line in script>,
1662     //          "column"              : <function begin source column in script>,
1663     //          "properties" : [ {"name" : <name>,
1664     //                            "ref"  : <handle>
1665     //                           },
1666     //                           ...
1667     //                         ]
1668     //        }
1669 
1670     QmlV8ObjectData objectData;
1671     const QVariantMap dataMap = data.toMap();
1672 
1673     objectData.name = dataMap.value(NAME).toString();
1674 
1675     QString type = dataMap.value(TYPE).toString();
1676     objectData.handle = dataMap.value(HANDLE).toInt();
1677 
1678     if (type == "undefined") {
1679         objectData.type = "undefined";
1680         objectData.value = "undefined";
1681 
1682     } else if (type == "null") { // Deprecated. typeof(null) == "object" in JavaScript
1683         objectData.type = "object";
1684         objectData.value = "null";
1685 
1686     } else if (type == "boolean") {
1687         objectData.type = "boolean";
1688         objectData.value = dataMap.value(VALUE);
1689 
1690     } else if (type == "number") {
1691         objectData.type = "number";
1692         objectData.value = dataMap.value(VALUE);
1693 
1694     } else if (type == "string") {
1695         QLatin1Char quote('"');
1696         objectData.type = "string";
1697         objectData.value = QString(quote + dataMap.value(VALUE).toString() + quote);
1698 
1699     } else if (type == "object") {
1700         objectData.type = "object";
1701         // ignore "className": it doesn't make any sense.
1702 
1703         if (dataMap.contains("value")) {
1704             QVariant value = dataMap.value("value");
1705             // The QVariant representation of null has changed across various Qt versions
1706             // 5.6, 5.7: QVariant::Invalid
1707             // 5.8: isValid(), !isNull(), type() == 51; only typeName() is unique: "std::nullptr_t"
1708             // 5.9: isValid(), isNull(); We can then use isNull()
1709             if (!value.isValid() || value.isNull()
1710                     || strcmp(value.typeName(), "std::nullptr_t") == 0) {
1711                 objectData.value = "null"; // Yes, null is an object.
1712             } else if (value.isValid()) {
1713                 objectData.expectedProperties = value.toInt();
1714             }
1715         }
1716 
1717         if (dataMap.contains("properties"))
1718             objectData.properties = dataMap.value("properties").toList();
1719     } else if (type == "function") {
1720         objectData.type = "function";
1721         objectData.value = dataMap.value(NAME);
1722         objectData.properties = dataMap.value("properties").toList();
1723         QVariant value = dataMap.value("value");
1724         if (value.isValid())
1725             objectData.expectedProperties = value.toInt();
1726 
1727     } else if (type == "script") {
1728         objectData.type = "script";
1729         objectData.value = dataMap.value(NAME);
1730     }
1731 
1732     if (dataMap.contains(REF)) {
1733         objectData.handle = dataMap.value(REF).toInt();
1734         if (refVals.contains(objectData.handle)) {
1735             QmlV8ObjectData data = refVals.value(objectData.handle);
1736             if (objectData.type.isEmpty())
1737                 objectData.type = data.type;
1738             if (!objectData.value.isValid())
1739                 objectData.value = data.value;
1740             if (objectData.properties.isEmpty())
1741                 objectData.properties = data.properties;
1742             if (objectData.expectedProperties < 0)
1743                 objectData.expectedProperties = data.expectedProperties;
1744         }
1745     }
1746 
1747     return objectData;
1748 }
1749 
1750 void QmlEnginePrivate::runCommand(const DebuggerCommand &command, const QmlCallback &cb)
1751 {
1752     QJsonObject object;
1753     object.insert("seq", ++sequence);
1754     object.insert("type", "request");
1755     object.insert("command", command.function);
1756     object.insert("arguments", command.args);
1757     if (cb)
1758         callbackForToken[sequence] = cb;
1759 
1760     runDirectCommand(V8REQUEST, QJsonDocument(object).toJson(QJsonDocument::Compact));
1761 }
1762 
1763 void QmlEnginePrivate::runDirectCommand(const QString &type, const QByteArray &msg)
1764 {
1765     // Leave item as variable, serialization depends on it.
1766     QByteArray cmd = V8DEBUG;
1767 
1768     engine->showMessage(QString("%1 %2").arg(type, QString::fromLatin1(msg)), LogInput);
1769 
1770     QPacket rs(connection->currentDataStreamVersion());
1771     rs << cmd << type.toLatin1() << msg;
1772 
1773     if (state() == Enabled)
1774         sendMessage(rs.data());
1775     else
1776         sendBuffer.append(rs.data());
1777 }
1778 
1779 void QmlEnginePrivate::memorizeRefs(const QVariant &refs)
1780 {
1781     if (refs.isValid()) {
1782         foreach (const QVariant &ref, refs.toList()) {
1783             const QVariantMap refData = ref.toMap();
1784             int handle = refData.value(HANDLE).toInt();
1785             refVals[handle] = extractData(refData);
1786         }
1787     }
1788 }
1789 
1790 void QmlEnginePrivate::messageReceived(const QByteArray &data)
1791 {
1792     QPacket ds(connection->currentDataStreamVersion(), data);
1793     QByteArray command;
1794     ds >> command;
1795 
1796     if (command == V8DEBUG) {
1797         QByteArray type;
1798         QByteArray response;
1799         ds >> type >> response;
1800 
1801         engine->showMessage(QLatin1String(type), LogOutput);
1802         if (type == CONNECT) {
1803             //debugging session started
1804 
1805         } else if (type == INTERRUPT) {
1806             //debug break requested
1807 
1808         } else if (type == BREAKONSIGNAL) {
1809             //break on signal handler requested
1810 
1811         } else if (type == V8MESSAGE) {
1812             SDEBUG(response);
1813             engine->showMessage(QString(V8MESSAGE) + ' ' + QString::fromLatin1(response), LogOutput);
1814 
1815             const QVariantMap resp = QJsonDocument::fromJson(response).toVariant().toMap();
1816 
1817             const QString type = resp.value(TYPE).toString();
1818 
1819             if (type == "response") {
1820 
1821                 const QString debugCommand(resp.value(COMMAND).toString());
1822 
1823                 memorizeRefs(resp.value(REFS));
1824 
1825                 bool success = resp.value("success").toBool();
1826                 if (!success) {
1827                     SDEBUG("Request was unsuccessful");
1828                 }
1829 
1830                 int requestSeq = resp.value("request_seq").toInt();
1831                 if (callbackForToken.contains(requestSeq)) {
1832                     callbackForToken[requestSeq](resp);
1833 
1834                 } else if (debugCommand == DISCONNECT) {
1835                     //debugging session ended
1836 
1837                 } else if (debugCommand == CONTINEDEBUGGING) {
1838                     //do nothing, wait for next break
1839 
1840                 } else if (debugCommand == SETBREAKPOINT) {
1841                     //                { "seq"         : <number>,
1842                     //                  "type"        : "response",
1843                     //                  "request_seq" : <number>,
1844                     //                  "command"     : "setbreakpoint",
1845                     //                  "body"        : { "type"       : <"function" or "script">
1846                     //                                    "breakpoint" : <break point number of the new break point>
1847                     //                                  }
1848                     //                  "running"     : <is the VM running after sending this response>
1849                     //                  "success"     : true
1850                     //                }
1851 
1852                     int seq = resp.value("request_seq").toInt();
1853                     const QVariantMap breakpointData = resp.value(BODY).toMap();
1854                     int index = breakpointData.value("breakpoint").toInt();
1855 
1856                     if (breakpointsSync.contains(seq)) {
1857                         BreakpointModelId id = breakpointsSync.take(seq);
1858                         breakpoints.insert(id, index);
1859 
1860                         //Is actual position info present? Then breakpoint was
1861                         //accepted
1862                         const QVariantList actualLocations =
1863                                 breakpointData.value("actual_locations").toList();
1864                         if (actualLocations.count()) {
1865                             //The breakpoint requested line should be same as
1866                             //actual line
1867                             BreakHandler *handler = engine->breakHandler();
1868                             Breakpoint bp = handler->breakpointById(id);
1869                             if (bp.state() != BreakpointInserted) {
1870                                 BreakpointResponse br = bp.response();
1871                                 br.lineNumber = breakpointData.value("line").toInt() + 1;
1872                                 br.pending = false;
1873                                 bp.setResponse(br);
1874                                 bp.notifyBreakpointInsertOk();
1875                             }
1876                         }
1877 
1878 
1879                     } else {
1880                         breakpointsTemp.append(index);
1881                     }
1882 
1883 
1884                 } else if (debugCommand == CLEARBREAKPOINT) {
1885                     // DO NOTHING
1886 
1887                 } else if (debugCommand == SETEXCEPTIONBREAK) {
1888                     //                { "seq"               : <number>,
1889                     //                  "type"              : "response",
1890                     //                  "request_seq" : <number>,
1891                     //                  "command"     : "setexceptionbreak",
1892                     //                  "body"        : { "type"    : <string: "all" or "uncaught" corresponding to the request.>,
1893                     //                                    "enabled" : <bool: true if the break type is currently enabled as a result of the request>
1894                     //                                  }
1895                     //                  "running"     : true
1896                     //                  "success"     : true
1897                     //                }
1898 
1899 
1900                 } else if (debugCommand == SCRIPTS) {
1901                     //                { "seq"         : <number>,
1902                     //                  "type"        : "response",
1903                     //                  "request_seq" : <number>,
1904                     //                  "command"     : "scripts",
1905                     //                  "body"        : [ { "name"             : <name of the script>,
1906                     //                                      "id"               : <id of the script>
1907                     //                                      "lineOffset"       : <line offset within the containing resource>
1908                     //                                      "columnOffset"     : <column offset within the containing resource>
1909                     //                                      "lineCount"        : <number of lines in the script>
1910                     //                                      "data"             : <optional data object added through the API>
1911                     //                                      "source"           : <source of the script if includeSource was specified in the request>
1912                     //                                      "sourceStart"      : <first 80 characters of the script if includeSource was not specified in the request>
1913                     //                                      "sourceLength"     : <total length of the script in characters>
1914                     //                                      "scriptType"       : <script type (see request for values)>
1915                     //                                      "compilationType"  : < How was this script compiled:
1916                     //                                                               0 if script was compiled through the API
1917                     //                                                               1 if script was compiled through eval
1918                     //                                                            >
1919                     //                                      "evalFromScript"   : <if "compilationType" is 1 this is the script from where eval was called>
1920                     //                                      "evalFromLocation" : { line   : < if "compilationType" is 1 this is the line in the script from where eval was called>
1921                     //                                                             column : < if "compilationType" is 1 this is the column in the script from where eval was called>
1922                     //                                  ]
1923                     //                  "running"     : <is the VM running after sending this response>
1924                     //                  "success"     : true
1925                     //                }
1926 
1927                     if (success) {
1928                         const QVariantList body = resp.value(BODY).toList();
1929 
1930                         QStringList sourceFiles;
1931                         for (int i = 0; i < body.size(); ++i) {
1932                             const QVariantMap entryMap = body.at(i).toMap();
1933                             const int lineOffset = entryMap.value("lineOffset").toInt();
1934                             const int columnOffset = entryMap.value("columnOffset").toInt();
1935                             const QString name = entryMap.value("name").toString();
1936                             const QString source = entryMap.value("source").toString();
1937 
1938                             if (name.isEmpty())
1939                                 continue;
1940 
1941                             if (!sourceFiles.contains(name))
1942                                 sourceFiles << name;
1943 
1944                             updateScriptSource(name, lineOffset, columnOffset, source);
1945                         }
1946 
1947                         QMap<QString,QString> files;
1948                         foreach (const QString &file, sourceFiles) {
1949                             QString shortName = file;
1950                             QString fullName = engine->toFileInProject(file);
1951                             files.insert(shortName, fullName);
1952                         }
1953 
1954                         engine->sourceFilesHandler()->setSourceFiles(files);
1955                         //update open editors
1956                     }
1957                 } else {
1958                     // DO NOTHING
1959                 }
1960 
1961             } else if (type == EVENT) {
1962                 const QString eventType(resp.value(EVENT).toString());
1963 
1964                 if (eventType == "break") {
1965 
1966                     clearRefs();
1967                     const QVariantMap breakData = resp.value(BODY).toMap();
1968                     const QString invocationText = breakData.value("invocationText").toString();
1969                     const QString scriptUrl = breakData.value("script").toMap().value("name").toString();
1970                     const QString sourceLineText = breakData.value("sourceLineText").toString();
1971 
1972                     bool inferiorStop = true;
1973 
1974                     QList<int> v8BreakpointIds;
1975                     {
1976                         const QVariantList v8BreakpointIdList = breakData.value("breakpoints").toList();
1977                         foreach (const QVariant &breakpointId, v8BreakpointIdList)
1978                             v8BreakpointIds << breakpointId.toInt();
1979                     }
1980 
1981                     if (!v8BreakpointIds.isEmpty() && invocationText.startsWith("[anonymous]()")
1982                             && scriptUrl.endsWith(".qml")
1983                             && sourceLineText.trimmed().startsWith('(')) {
1984 
1985                         // we hit most likely the anonymous wrapper function automatically generated for bindings
1986                         // -> relocate the breakpoint to column: 1 and continue
1987 
1988                         int newColumn = sourceLineText.indexOf('(') + 1;
1989                         BreakHandler *handler = engine->breakHandler();
1990 
1991                         foreach (int v8Id, v8BreakpointIds) {
1992                             const BreakpointModelId id = breakpoints.key(v8Id);
1993                             Breakpoint bp = handler->breakpointById(id);
1994                             if (bp.isValid()) {
1995                                 const BreakpointParameters &params = bp.parameters();
1996 
1997                                 clearBreakpoint(v8Id);
1998                                 setBreakpoint(SCRIPTREGEXP,
1999                                               params.fileName,
2000                                               params.enabled,
2001                                               params.lineNumber,
2002                                               newColumn,
2003                                               params.condition,
2004                                               params.ignoreCount);
2005                                 breakpointsSync.insert(sequence, id);
2006                             }
2007                         }
2008                         continueDebugging(Continue);
2009                         inferiorStop = false;
2010                     }
2011 
2012                     //Skip debug break if this is an internal function
2013                     if (sourceLineText == INTERNAL_FUNCTION) {
2014                         continueDebugging(previousStepAction);
2015                         inferiorStop = false;
2016                     }
2017 
2018                     if (inferiorStop) {
2019                         //Update breakpoint data
2020                         BreakHandler *handler = engine->breakHandler();
2021                         foreach (int v8Id, v8BreakpointIds) {
2022                             const BreakpointModelId id = breakpoints.key(v8Id);
2023                             Breakpoint bp = handler->breakpointById(id);
2024                             if (bp) {
2025                                 BreakpointResponse br = bp.response();
2026                                 if (br.functionName.isEmpty()) {
2027                                     br.functionName = invocationText;
2028                                     bp.setResponse(br);
2029                                 }
2030                                 if (bp.state() != BreakpointInserted) {
2031                                     br.lineNumber = breakData.value("sourceLine").toInt() + 1;
2032                                     br.pending = false;
2033                                     bp.setResponse(br);
2034                                     bp.notifyBreakpointInsertOk();
2035                                 }
2036                             }
2037                         }
2038 
2039                         if (engine->state() == InferiorRunOk) {
2040                             foreach (const QVariant &breakpointId, v8BreakpointIds) {
2041                                 if (breakpointsTemp.contains(breakpointId.toInt()))
2042                                     clearBreakpoint(breakpointId.toInt());
2043                             }
2044                             engine->notifyInferiorSpontaneousStop();
2045                             backtrace();
2046                         } else if (engine->state() == InferiorStopRequested) {
2047                             engine->notifyInferiorStopOk();
2048                             backtrace();
2049                         }
2050                     }
2051 
2052                 } else if (eventType == "exception") {
2053                     const QVariantMap body = resp.value(BODY).toMap();
2054                     int lineNumber = body.value("sourceLine").toInt() + 1;
2055 
2056                     const QVariantMap script = body.value("script").toMap();
2057                     QUrl fileUrl(script.value(NAME).toString());
2058                     QString filePath = engine->toFileInProject(fileUrl);
2059 
2060                     const QVariantMap exception = body.value("exception").toMap();
2061                     QString errorMessage = exception.value("text").toString();
2062 
2063                     QStringList messages = highlightExceptionCode(lineNumber, filePath, errorMessage);
2064                     foreach (const QString msg, messages)
2065                         engine->showMessage(msg, ConsoleOutput);
2066 
2067                     if (engine->state() == InferiorRunOk) {
2068                         engine->notifyInferiorSpontaneousStop();
2069                         backtrace();
2070                     }
2071 
2072                     if (engine->state() == InferiorStopOk)
2073                         backtrace();
2074 
2075                 } else if (eventType == "afterCompile") {
2076                     //Currently break point relocation is disabled.
2077                     //Uncomment the line below when it will be enabled.
2078 //                    listBreakpoints();
2079                 }
2080 
2081                 //Sometimes we do not get event type!
2082                 //This is most probably due to a wrong eval expression.
2083                 //Redirect output to console.
2084                 if (eventType.isEmpty()) {
2085                     debuggerConsole()->printItem(new ConsoleItem(
2086                                                      ConsoleItem::ErrorType,
2087                                                      resp.value(MESSAGE).toString()));
2088                 }
2089 
2090             } //EVENT
2091         } //V8MESSAGE
2092 
2093     } else {
2094         //DO NOTHING
2095     }
2096 }
2097 
2098 void QmlEnginePrivate::handleBacktrace(const QVariantMap &response)
2099 {
2100     //    { "seq"         : <number>,
2101     //      "type"        : "response",
2102     //      "request_seq" : <number>,
2103     //      "command"     : "backtrace",
2104     //      "body"        : { "fromFrame" : <number>
2105     //                        "toFrame" : <number>
2106     //                        "totalFrames" : <number>
2107     //                        "frames" : <array of frames - see frame request for details>
2108     //                      }
2109     //      "running"     : <is the VM running after sending this response>
2110     //      "success"     : true
2111     //    }
2112 
2113     const QVariantMap body = response.value(BODY).toMap();
2114     const QVariantList frames = body.value("frames").toList();
2115 
2116     int fromFrameIndex = body.value("fromFrame").toInt();
2117 
2118     QTC_ASSERT(0 == fromFrameIndex, return);
2119 
2120     StackHandler *stackHandler = engine->stackHandler();
2121     StackFrames stackFrames;
2122     int i = 0;
2123     stackIndexLookup.clear();
2124     foreach (const QVariant &frame, frames) {
2125         StackFrame stackFrame = extractStackFrame(frame);
2126         if (stackFrame.level.isEmpty())
2127             continue;
2128         stackIndexLookup.insert(i, stackFrame.level.toInt());
2129         stackFrames << stackFrame;
2130         i++;
2131     }
2132     stackHandler->setFrames(stackFrames);
2133     stackHandler->setCurrentIndex(0);
2134 
2135     updateLocals();
2136 }
2137 
2138 StackFrame QmlEnginePrivate::extractStackFrame(const QVariant &bodyVal)
2139 {
2140     //    { "seq"         : <number>,
2141     //      "type"        : "response",
2142     //      "request_seq" : <number>,
2143     //      "command"     : "frame",
2144     //      "body"        : { "index"          : <frame number>,
2145     //                        "receiver"       : <frame receiver>,
2146     //                        "func"           : <function invoked>,
2147     //                        "script"         : <script for the function>,
2148     //                        "constructCall"  : <boolean indicating whether the function was called as constructor>,
2149     //                        "debuggerFrame"  : <boolean indicating whether this is an internal debugger frame>,
2150     //                        "arguments"      : [ { name: <name of the argument - missing of anonymous argument>,
2151     //                                               value: <value of the argument>
2152     //                                             },
2153     //                                             ... <the array contains all the arguments>
2154     //                                           ],
2155     //                        "locals"         : [ { name: <name of the local variable>,
2156     //                                               value: <value of the local variable>
2157     //                                             },
2158     //                                             ... <the array contains all the locals>
2159     //                                           ],
2160     //                        "position"       : <source position>,
2161     //                        "line"           : <source line>,
2162     //                        "column"         : <source column within the line>,
2163     //                        "sourceLineText" : <text for current source line>,
2164     //                        "scopes"         : [ <array of scopes, see scope request below for format> ],
2165 
2166     //                      }
2167     //      "running"     : <is the VM running after sending this response>
2168     //      "success"     : true
2169     //    }
2170 
2171     const QVariantMap body = bodyVal.toMap();
2172 
2173     StackFrame stackFrame;
2174     stackFrame.level = body.value("index").toString();
2175     //Do not insert the frame corresponding to the internal function
2176     if (body.value("sourceLineText") == INTERNAL_FUNCTION) {
2177         stackFrame.level.clear();
2178         return stackFrame;
2179     }
2180 
2181     auto extractString = [this](const QVariant &item) {
2182         return ((item.type() == QVariant::String) ? item : extractData(item).value).toString();
2183     };
2184 
2185     stackFrame.function = extractString(body.value("func"));
2186     if (stackFrame.function.isEmpty())
2187         stackFrame.function = QCoreApplication::translate("QmlEngine", "Anonymous Function");
2188     stackFrame.file = engine->toFileInProject(extractString(body.value("script")));
2189     stackFrame.usable = QFileInfo(stackFrame.file).isReadable();
2190     stackFrame.receiver = extractString(body.value("receiver"));
2191     stackFrame.line = body.value("line").toInt() + 1;
2192 
2193     return stackFrame;
2194 }
2195 
2196 void QmlEnginePrivate::handleFrame(const QVariantMap &response)
2197 {
2198     //    { "seq"         : <number>,
2199     //      "type"        : "response",
2200     //      "request_seq" : <number>,
2201     //      "command"     : "frame",
2202     //      "body"        : { "index"          : <frame number>,
2203     //                        "receiver"       : <frame receiver>,
2204     //                        "func"           : <function invoked>,
2205     //                        "script"         : <script for the function>,
2206     //                        "constructCall"  : <boolean indicating whether the function was called as constructor>,
2207     //                        "debuggerFrame"  : <boolean indicating whether this is an internal debugger frame>,
2208     //                        "arguments"      : [ { name: <name of the argument - missing of anonymous argument>,
2209     //                                               value: <value of the argument>
2210     //                                             },
2211     //                                             ... <the array contains all the arguments>
2212     //                                           ],
2213     //                        "locals"         : [ { name: <name of the local variable>,
2214     //                                               value: <value of the local variable>
2215     //                                             },
2216     //                                             ... <the array contains all the locals>
2217     //                                           ],
2218     //                        "position"       : <source position>,
2219     //                        "line"           : <source line>,
2220     //                        "column"         : <source column within the line>,
2221     //                        "sourceLineText" : <text for current source line>,
2222     //                        "scopes"         : [ <array of scopes, see scope request below for format> ],
2223 
2224     //                      }
2225     //      "running"     : <is the VM running after sending this response>
2226     //      "success"     : true
2227     //    }
2228     QVariantMap body = response.value(BODY).toMap();
2229 
2230     StackHandler *stackHandler = engine->stackHandler();
2231     WatchHandler * watchHandler = engine->watchHandler();
2232     watchHandler->notifyUpdateStarted();
2233 
2234     const int frameIndex = stackHandler->currentIndex();
2235     if (frameIndex < 0)
2236         return;
2237     const StackFrame frame = stackHandler->currentFrame();
2238     if (!frame.isUsable())
2239         return;
2240 
2241     // Always add a "this" variable
2242     {
2243         QString iname = "local.this";
2244         QString exp = "this";
2245         QmlV8ObjectData objectData = extractData(body.value("receiver"));
2246 
2247         auto item = new WatchItem;
2248         item->iname = iname;
2249         item->name = exp;
2250         item->id = objectData.handle;
2251         item->type = objectData.type;
2252         item->value = objectData.value.toString();
2253         item->setHasChildren(objectData.hasChildren());
2254         // In case of global object, we do not get children
2255         // Set children nevertheless and query later.
2256         if (item->value == "global") {
2257             item->setHasChildren(true);
2258             item->id = 0;
2259         }
2260         watchHandler->insertItem(item);
2261         evaluate(exp, -1, [this, iname, exp](const QVariantMap &response) {
2262             handleEvaluateExpression(response, iname, exp);
2263         });
2264     }
2265 
2266     currentFrameScopes.clear();
2267     const QVariantList scopes = body.value("scopes").toList();
2268     foreach (const QVariant &scope, scopes) {
2269         //Do not query for global types (0)
2270         //Showing global properties increases clutter.
2271         if (scope.toMap().value("type").toInt() == 0)
2272             continue;
2273         int scopeIndex = scope.toMap().value("index").toInt();
2274         currentFrameScopes.append(scopeIndex);
2275         this->scope(scopeIndex);
2276     }
2277     engine->gotoLocation(stackHandler->currentFrame());
2278 
2279     // Send watchers list
2280     if (stackHandler->isContentsValid() && stackHandler->currentFrame().isUsable()) {
2281         QStringList watchers = watchHandler->watchedExpressions();
2282         foreach (const QString &exp, watchers) {
2283             const QString iname = watchHandler->watcherName(exp);
2284             evaluate(exp, -1, [this, iname, exp](const QVariantMap &response) {
2285                 handleEvaluateExpression(response, iname, exp);
2286             });
2287         }
2288     }
2289 }
2290 
2291 void QmlEnginePrivate::handleScope(const QVariantMap &response)
2292 {
2293     //    { "seq"         : <number>,
2294     //      "type"        : "response",
2295     //      "request_seq" : <number>,
2296     //      "command"     : "scope",
2297     //      "body"        : { "index"      : <index of this scope in the scope chain. Index 0 is the top scope
2298     //                                        and the global scope will always have the highest index for a
2299     //                                        frame>,
2300     //                        "frameIndex" : <index of the frame>,
2301     //                        "type"       : <type of the scope:
2302     //                                         0: Global
2303     //                                         1: Local
2304     //                                         2: With
2305     //                                         3: Closure
2306     //                                         4: Catch >,
2307     //                        "object"     : <the scope object defining the content of the scope.
2308     //                                        For local and closure scopes this is transient objects,
2309     //                                        which has a negative handle value>
2310     //                      }
2311     //      "running"     : <is the VM running after sending this response>
2312     //      "success"     : true
2313     //    }
2314     QVariantMap bodyMap = response.value(BODY).toMap();
2315 
2316     //Check if the frameIndex is same as current Stack Index
2317     StackHandler *stackHandler = engine->stackHandler();
2318     if (bodyMap.value("frameIndex").toInt() != stackHandler->currentIndex())
2319         return;
2320 
2321     QmlV8ObjectData objectData = extractData(bodyMap.value("object"));
2322 
2323     LookupItems itemsToLookup;
2324     foreach (const QVariant &property, objectData.properties) {
2325         QmlV8ObjectData localData = extractData(property);
2326         std::unique_ptr<WatchItem> item(new WatchItem);
2327         item->exp = localData.name;
2328         //Check for v8 specific local data
2329         if (item->exp.startsWith('.') || item->exp.isEmpty())
2330             continue;
2331 
2332         item->name = item->exp;
2333         item->iname = "local." + item->exp;
2334         item->id = localData.handle;
2335         item->type = localData.type;
2336         item->value = localData.value.toString();
2337         item->setHasChildren(localData.hasChildren());
2338 
2339         if (localData.value.isValid() || item->wantsChildren || localData.expectedProperties == 0) {
2340             engine->watchHandler()->insertItem(item.release());
2341         } else {
2342             itemsToLookup.insert(int(item->id), {item->iname, item->name, item->exp});
2343         }
2344     }
2345     lookup(itemsToLookup);
2346     checkForFinishedUpdate();
2347 }
2348 
2349 void QmlEnginePrivate::checkForFinishedUpdate()
2350 {
2351     if (currentlyLookingUp.isEmpty())
2352         engine->watchHandler()->notifyUpdateFinished();
2353 }
2354 
2355 ConsoleItem *QmlEnginePrivate::constructLogItemTree(const QmlV8ObjectData &objectData)
2356 {
2357     QList<int> handles;
2358     return constructLogItemTree(objectData, handles);
2359 }
2360 
2361 void QmlEnginePrivate::constructChildLogItems(ConsoleItem *item, const QmlV8ObjectData &objectData,
2362                                               QList<int> &seenHandles)
2363 {
2364     // We cannot sort the children after attaching them to the parent as that would cause layout
2365     // changes, invalidating cached indices. So we presort them before inserting.
2366     QVarLengthArray<ConsoleItem *> children(objectData.properties.size());
2367     auto it = children.begin();
2368     foreach (const QVariant &property, objectData.properties)
2369         *(it++) = constructLogItemTree(extractData(property), seenHandles);
2370 
2371     if (boolSetting(SortStructMembers))
2372         std::sort(children.begin(), children.end(), compareConsoleItems);
2373 
2374     foreach (ConsoleItem *child, children)
2375         item->appendChild(child);
2376 }
2377 
2378 ConsoleItem *QmlEnginePrivate::constructLogItemTree(const QmlV8ObjectData &objectData,
2379                                                     QList<int> &seenHandles)
2380 {
2381     QString text;
2382     if (objectData.value.isValid()) {
2383         text = objectData.value.toString();
2384     } else if (!objectData.type.isEmpty()) {
2385         text = objectData.type;
2386     } else {
2387         int handle = objectData.handle;
2388         ConsoleItem *item = new ConsoleItem(ConsoleItem::DefaultType,
2389                                             objectData.name,
2390                                             [this, handle](ConsoleItem *item)
2391         {
2392             DebuggerCommand cmd(LOOKUP);
2393             cmd.arg(HANDLES, QList<int>() << handle);
2394             runCommand(cmd, [this, item, handle](const QVariantMap &response) {
2395                 const QVariantMap body = response.value(BODY).toMap();
2396                 QStringList handlesList = body.keys();
2397                 foreach (const QString &handleString, handlesList) {
2398                     if (handle != handleString.toInt())
2399                         continue;
2400 
2401                     QmlV8ObjectData objectData = extractData(body.value(handleString));
2402 
2403                     // keep original name, if possible
2404                     QString name = item->expression();
2405                     if (name.isEmpty())
2406                         name = objectData.name;
2407 
2408                     QString value = objectData.value.isValid() ?
2409                                 objectData.value.toString() : objectData.type;
2410 
2411                     // We can do setData() and cause dataChanged() here, but only because this
2412                     // callback is executed after fetchMore() has returned.
2413                     item->model()->setData(item->index(),
2414                                            QString("%1: %2").arg(name, value),
2415                                            ConsoleItem::ExpressionRole);
2416 
2417                     QList<int> newHandles;
2418                     constructChildLogItems(item, objectData, newHandles);
2419 
2420                     break;
2421                 }
2422             });
2423         });
2424         return item;
2425     }
2426 
2427     if (!objectData.name.isEmpty())
2428         text = QString("%1: %2").arg(objectData.name, text);
2429 
2430     if (objectData.properties.isEmpty())
2431         return new ConsoleItem(ConsoleItem::DefaultType, text);
2432 
2433     if (seenHandles.contains(objectData.handle)) {
2434         ConsoleItem *item = new ConsoleItem(ConsoleItem::DefaultType, text,
2435                                             [this, objectData](ConsoleItem *item)
2436         {
2437             QList<int> newHandles;
2438             constructChildLogItems(item, objectData, newHandles);
2439         });
2440         return item;
2441     }
2442 
2443     seenHandles.append(objectData.handle);
2444     ConsoleItem *item = new ConsoleItem(ConsoleItem::DefaultType, text);
2445     constructChildLogItems(item, objectData, seenHandles);
2446     seenHandles.removeLast();
2447 
2448     return item;
2449 }
2450 
2451 void QmlEnginePrivate::insertSubItems(WatchItem *parent, const QVariantList &properties)
2452 {
2453     QTC_ASSERT(parent, return);
2454     LookupItems itemsToLookup;
2455 
2456     const QSet<QString> expandedINames = engine->watchHandler()->expandedINames();
2457     foreach (const QVariant &property, properties) {
2458         QmlV8ObjectData propertyData = extractData(property);
2459         std::unique_ptr<WatchItem> item(new WatchItem);
2460         item->name = propertyData.name;
2461 
2462         // Check for v8 specific local data
2463         if (item->name.startsWith('.') || item->name.isEmpty())
2464             continue;
2465         if (parent->type == "object") {
2466             if (parent->value == "Array")
2467                 item->exp = parent->exp + '[' + item->name + ']';
2468             else if (parent->value == "Object")
2469                 item->exp = parent->exp + '.' + item->name;
2470         } else {
2471             item->exp = item->name;
2472         }
2473 
2474         item->iname = parent->iname + '.' + item->name;
2475         item->id = propertyData.handle;
2476         item->type = propertyData.type;
2477         item->value = propertyData.value.toString();
2478         if (item->type.isEmpty() || expandedINames.contains(item->iname))
2479             itemsToLookup.insert(propertyData.handle, {item->iname, item->name, item->exp});
2480         item->setHasChildren(propertyData.hasChildren());
2481         parent->appendChild(item.release());
2482     }
2483 
2484     if (boolSetting(SortStructMembers)) {
2485         parent->sortChildren([](const WatchItem *item1, const WatchItem *item2) {
2486             return item1->name < item2->name;
2487         });
2488     }
2489 
2490     lookup(itemsToLookup);
2491 }
2492 
2493 void QmlEnginePrivate::handleExecuteDebuggerCommand(const QVariantMap &response)
2494 {
2495     auto it = response.constFind(SUCCESS);
2496     if (it != response.constEnd() && it.value().toBool()) {
2497         debuggerConsole()->printItem(constructLogItemTree(extractData(response.value(BODY))));
2498 
2499         // Update the locals
2500         foreach (int index, currentFrameScopes)
2501             scope(index);
2502     } else {
2503         debuggerConsole()->printItem(new ConsoleItem(ConsoleItem::ErrorType,
2504                                                      response.value(MESSAGE).toString()));
2505     }
2506 }
2507 
2508 void QmlEnginePrivate::handleLookup(const QVariantMap &response)
2509 {
2510     //    { "seq"         : <number>,
2511     //      "type"        : "response",
2512     //      "request_seq" : <number>,
2513     //      "command"     : "lookup",
2514     //      "body"        : <array of serialized objects indexed using their handle>
2515     //      "running"     : <is the VM running after sending this response>
2516     //      "success"     : true
2517     //    }
2518     const QVariantMap body = response.value(BODY).toMap();
2519 
2520     QStringList handlesList = body.keys();
2521     foreach (const QString &handleString, handlesList) {
2522         int handle = handleString.toInt();
2523         QmlV8ObjectData bodyObjectData = extractData(body.value(handleString));
2524         QList<LookupData> vals = currentlyLookingUp.values(handle);
2525         currentlyLookingUp.remove(handle);
2526         foreach (const LookupData &res, vals) {
2527             auto item = new WatchItem;
2528             item->exp = res.exp;
2529             item->iname = res.iname;
2530             item->name = res.name;
2531             item->id = handle;
2532 
2533             item->type = bodyObjectData.type;
2534             item->value = bodyObjectData.value.toString();
2535 
2536             item->setHasChildren(bodyObjectData.hasChildren());
2537             insertSubItems(item, bodyObjectData.properties);
2538 
2539             engine->watchHandler()->insertItem(item);
2540         }
2541     }
2542     checkForFinishedUpdate();
2543 }
2544 
2545 void QmlEnginePrivate::stateChanged(State state)
2546 {
2547     engine->logServiceStateChange(name(), serviceVersion(), state);
2548 
2549     if (state == QmlDebugClient::Enabled) {
2550         /// Start session.
2551         flushSendBuffer();
2552         QJsonObject parameters;
2553         parameters.insert("redundantRefs", false);
2554         parameters.insert("namesAsObjects", false);
2555         runDirectCommand(CONNECT, QJsonDocument(parameters).toJson());
2556         runCommand({VERSION}, CB(handleVersion));
2557     }
2558 }
2559 
2560 void QmlEnginePrivate::handleVersion(const QVariantMap &response)
2561 {
2562     unpausedEvaluate = response.value(BODY).toMap().value("UnpausedEvaluate", false).toBool();
2563     contextEvaluate = response.value(BODY).toMap().value("ContextEvaluate", false).toBool();
2564 }
2565 
2566 void QmlEnginePrivate::flushSendBuffer()
2567 {
2568     QTC_ASSERT(state() == Enabled, return);
2569     foreach (const QByteArray &msg, sendBuffer)
2570         sendMessage(msg);
2571     sendBuffer.clear();
2572 }
2573 
2574 DebuggerEngine *createQmlEngine(const DebuggerRunParameters &sp)
2575 {
2576     return new QmlEngine(sp);
2577 }
2578 
2579 } // Internal
2580 } // Debugger
