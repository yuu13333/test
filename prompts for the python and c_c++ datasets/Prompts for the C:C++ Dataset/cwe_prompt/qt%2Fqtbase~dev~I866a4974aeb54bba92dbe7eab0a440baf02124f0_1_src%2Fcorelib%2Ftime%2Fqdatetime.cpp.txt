Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qplatformdefs.h"
42 #include "private/qdatetime_p.h"
43 #if QT_CONFIG(datetimeparser)
44 #include "private/qdatetimeparser_p.h"
45 #endif
46 
47 #include "qdatastream.h"
48 #include "qset.h"
49 #include "qlocale.h"
50 #include "qdatetime.h"
51 #if QT_CONFIG(timezone)
52 #include "qtimezoneprivate_p.h"
53 #endif
54 #include "qdebug.h"
55 #ifndef Q_OS_WIN
56 #include <locale.h>
57 #endif
58 
59 #include <cmath>
60 #ifdef Q_CC_MINGW
61 #  include <unistd.h> // Define _POSIX_THREAD_SAFE_FUNCTIONS to obtain localtime_r()
62 #endif
63 #include <time.h>
64 #ifdef Q_OS_WIN
65 #  include <qt_windows.h>
66 #endif
67 
68 #if defined(Q_OS_MAC)
69 #include <private/qcore_mac_p.h>
70 #endif
71 
72 #include "qcalendar.h"
73 #include "qgregoriancalendar_p.h"
74 
75 QT_BEGIN_NAMESPACE
76 
77 /*****************************************************************************
78   Date/Time Constants
79  *****************************************************************************/
80 
81 enum {
82     SECS_PER_DAY = 86400,
83     MSECS_PER_DAY = 86400000,
84     SECS_PER_HOUR = 3600,
85     MSECS_PER_HOUR = 3600000,
86     SECS_PER_MIN = 60,
87     MSECS_PER_MIN = 60000,
88     TIME_T_MAX = 2145916799,  // int maximum 2037-12-31T23:59:59 UTC
89     JULIAN_DAY_FOR_EPOCH = 2440588 // result of julianDayFromDate(1970, 1, 1)
90 };
91 
92 /*****************************************************************************
93   QDate static helper functions
94  *****************************************************************************/
95 
96 static inline QDate fixedDate(QCalendar::YearMonthDay &&parts, QCalendar cal)
97 {
98     if ((parts.year < 0 && !cal.isProleptic()) || (parts.year == 0 && !cal.hasYearZero()))
99         return QDate();
100 
101     parts.day = qMin(parts.day, cal.daysInMonth(parts.month, parts.year));
102     return cal.dateFromParts(parts);
103 }
104 
105 static inline QDate fixedDate(QCalendar::YearMonthDay &&parts)
106 {
107     if (parts.year) {
108         parts.day = qMin(parts.day, QGregorianCalendar::monthLength(parts.month, parts.year));
109         qint64 jd;
110         if (QGregorianCalendar::julianFromParts(parts.year, parts.month, parts.day, &jd))
111             return QDate::fromJulianDay(jd);
112     }
113     return QDate();
114 }
115 
116 /*****************************************************************************
117   Date/Time formatting helper functions
118  *****************************************************************************/
119 
120 #if QT_CONFIG(textdate)
121 static const char qt_shortMonthNames[][4] = {
122     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
123     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
124 };
125 
126 static int fromShortMonthName(QStringView monthName)
127 {
128     for (unsigned int i = 0; i < sizeof(qt_shortMonthNames) / sizeof(qt_shortMonthNames[0]); ++i) {
129         if (monthName == QLatin1String(qt_shortMonthNames[i], 3))
130             return i + 1;
131     }
132     return -1;
133 }
134 #endif // textdate
135 
136 #if QT_CONFIG(datestring) // depends on, so implies, textdate
137 struct ParsedRfcDateTime {
138     QDate date;
139     QTime time;
140     int utcOffset;
141 };
142 
143 static int shortDayFromName(QStringView name)
144 {
145     const char16_t shortDayNames[] = u"MonTueWedThuFriSatSun";
146     for (int i = 0; i < 7; i++) {
147         if (name == QStringView(shortDayNames + 3 * i, 3))
148             return i + 1;
149     }
150     return 0;
151 }
152 
153 static ParsedRfcDateTime rfcDateImpl(const QString &s)
154 {
155     // Matches "[ddd,] dd MMM yyyy[ hh:mm[:ss]] [±hhmm]" - correct RFC 822, 2822, 5322 format -
156     // or           "ddd MMM dd[ hh:mm:ss] yyyy [±hhmm]" - permissive RFC 850, 1036 (read only)
157     ParsedRfcDateTime result;
158 
159     auto words = QStringView{s}.split(QLatin1Char(' '), Qt::SkipEmptyParts);
160     if (words.size() < 3 || words.size() > 6)
161         return result;
162     const QChar colon(QLatin1Char(':'));
163     const QLocale C = QLocale::c();
164     bool ok = true;
165     QDate date;
166 
167     const auto isShortName = [](QStringView name) {
168         return (name.length() == 3 && name.at(0).isUpper()
169                 && name.at(1).isLower() && name.at(2).isLower());
170     };
171 
172     /* Reject entirely (return) if the string is malformed; however, if the date
173      * is merely invalid, (break, so as to) go on to parsing of the time.
174      */
175     int yearIndex;
176     do { // "loop" so that we can use break on merely invalid, but "right shape" date.
177         QStringView dayName;
178         bool rfcX22 = true;
179         if (words.at(0).endsWith(QLatin1Char(','))) {
180             dayName = words.takeFirst().chopped(1);
181         } else if (!words.at(0).at(0).isDigit()) {
182             dayName = words.takeFirst();
183             rfcX22 = false;
184         } // else: dayName is not specified (so we can only be RFC *22)
185         if (words.size() < 3 || words.size() > 5)
186             return result;
187 
188         // Don't break before setting yearIndex.
189         int dayIndex, monthIndex;
190         if (rfcX22) {
191             // dd MMM yyyy [hh:mm[:ss]] [±hhmm]
192             dayIndex = 0;
193             monthIndex = 1;
194             yearIndex = 2;
195         } else {
196             // MMM dd[ hh:mm:ss] yyyy [±hhmm]
197             dayIndex = 1;
198             monthIndex = 0;
199             yearIndex = words.size() > 3 && words.at(2).contains(colon) ? 3 : 2;
200         }
201 
202         int dayOfWeek = 0;
203         if (!dayName.isEmpty()) {
204             if (!isShortName(dayName))
205                 return result;
206             dayOfWeek = shortDayFromName(dayName);
207             if (!dayOfWeek)
208                 break;
209         }
210 
211         const int day = words.at(dayIndex).toInt(&ok);
212         if (!ok)
213             return result;
214         const int year = words.at(yearIndex).toInt(&ok);
215         if (!ok)
216             return result;
217         const QStringView monthName = words.at(monthIndex);
218         if (!isShortName(monthName))
219             return result;
220         int month = fromShortMonthName(monthName);
221         if (month < 0)
222             break;
223 
224         date = QDate(year, month, day);
225         if (dayOfWeek && date.dayOfWeek() != dayOfWeek)
226             date = QDate();
227     } while (false);
228     words.remove(yearIndex);
229     words.remove(0, 2); // month and day-of-month, in some order
230 
231     // Time: [hh:mm[:ss]]
232     QTime time;
233     if (words.size() && words.at(0).contains(colon)) {
234         const QStringView when = words.takeFirst();
235         if (when.at(2) != colon || (when.size() == 8 ? when.at(5) != colon : when.size() > 5))
236             return result;
237         const int hour = C.toInt(when.left(2), &ok);
238         if (!ok)
239             return result;
240         const int minute = C.toInt(when.mid(3, 2), &ok);
241         if (!ok)
242             return result;
243         const auto secs = when.size() == 8 ? C.toInt(when.right(2), &ok) : 0;
244         if (!ok)
245             return result;
246         time = QTime(hour, minute, secs);
247     }
248 
249     // Offset: [±hhmm]
250     int offset = 0;
251     if (words.size()) {
252         const QStringView zone = words.takeFirst();
253         if (words.size() || !(zone.size() == 3 || zone.size() == 5))
254             return result;
255         bool negate = false;
256         if (zone.at(0) == QLatin1Char('-'))
257             negate = true;
258         else if (zone.at(0) != QLatin1Char('+'))
259             return result;
260         const int hour = C.toInt(zone.mid(1, 2), &ok);
261         if (!ok)
262             return result;
263         const auto minute = zone.size() > 3 ? C.toInt(zone.mid(3, 2), &ok) : 0;
264         if (!ok)
265             return result;
266         offset = (hour * 60 + minute) * 60;
267         if (negate)
268             offset = -offset;
269     }
270 
271     result.date = date;
272     result.time = time;
273     result.utcOffset = offset;
274     return result;
275 }
276 #endif // datestring
277 
278 // Return offset in [+-]HH:mm format
279 static QString toOffsetString(Qt::DateFormat format, int offset)
280 {
281     return QString::asprintf("%c%02d%s%02d",
282                              offset >= 0 ? '+' : '-',
283                              qAbs(offset) / SECS_PER_HOUR,
284                              // Qt::ISODate puts : between the hours and minutes, but Qt:TextDate does not:
285                              format == Qt::TextDate ? "" : ":",
286                              (qAbs(offset) / 60) % 60);
287 }
288 
289 #if QT_CONFIG(datestring)
290 // Parse offset in [+-]HH[[:]mm] format
291 static int fromOffsetString(QStringView offsetString, bool *valid) noexcept
292 {
293     *valid = false;
294 
295     const int size = offsetString.size();
296     if (size < 2 || size > 6)
297         return 0;
298 
299     // sign will be +1 for a positive and -1 for a negative offset
300     int sign;
301 
302     // First char must be + or -
303     const QChar signChar = offsetString.at(0);
304     if (signChar == QLatin1Char('+'))
305         sign = 1;
306     else if (signChar == QLatin1Char('-'))
307         sign = -1;
308     else
309         return 0;
310 
311     // Split the hour and minute parts
312     const QStringView time = offsetString.mid(1);
313     qsizetype hhLen = time.indexOf(QLatin1Char(':'));
314     qsizetype mmIndex;
315     if (hhLen == -1)
316         mmIndex = hhLen = 2; // [+-]HHmm or [+-]HH format
317     else
318         mmIndex = hhLen + 1;
319 
320     const QLocale C = QLocale::c();
321     const QStringView hhRef = time.left(qMin(hhLen, time.size()));
322     bool ok = false;
323     const int hour = C.toInt(hhRef, &ok);
324     if (!ok)
325         return 0;
326 
327     const QStringView mmRef = time.mid(qMin(mmIndex, time.size()));
328     const int minute = mmRef.isEmpty() ? 0 : C.toInt(mmRef, &ok);
329     if (!ok || minute < 0 || minute > 59)
330         return 0;
331 
332     *valid = true;
333     return sign * ((hour * 60) + minute) * 60;
334 }
335 #endif // datestring
336 
337 /*****************************************************************************
338   QDate member functions
339  *****************************************************************************/
340 
341 /*!
342     \class QDate
343     \inmodule QtCore
344     \reentrant
345     \brief The QDate class provides date functions.
346 
347     A QDate object represents a particular day, regardless of calendar, locale
348     or other settings used when creating it or supplied by the system.  It can
349     report the year, month and day of the month that represent the day with
350     respect to the proleptic Gregorian calendar or any calendar supplied as a
351     QCalendar object. QDate objects should be passed by value rather than by
352     reference to const.
353 
354     A QDate object is typically created by giving the year, month, and day
355     numbers explicitly. Note that QDate interprets year numbers less than 100 as
356     presented, i.e., as years 1 through 99, without adding any offset. The
357     static function currentDate() creates a QDate object containing the date
358     read from the system clock. An explicit date can also be set using
359     setDate(). The fromString() function returns a QDate given a string and a
360     date format which is used to interpret the date within the string.
361 
362     The year(), month(), and day() functions provide access to the year, month,
363     and day numbers. When more than one of these values is needed, it is more
364     efficient to call QCalendar::partsFromDate(), to save repeating (potentially
365     expensive) calendrical calculations.
366 
367     Also, dayOfWeek() and dayOfYear() functions are provided. The same
368     information is provided in textual format by toString(). QLocale can map the
369     day numbers to names, QCalendar can map month numbers to names.
370 
371     QDate provides a full set of operators to compare two QDate
372     objects where smaller means earlier, and larger means later.
373 
374     You can increment (or decrement) a date by a given number of days
375     using addDays(). Similarly you can use addMonths() and addYears().
376     The daysTo() function returns the number of days between two
377     dates.
378 
379     The daysInMonth() and daysInYear() functions return how many days there are
380     in this date's month and year, respectively. The isLeapYear() function
381     indicates whether a date is in a leap year. QCalendar can also supply this
382     information, in some cases more conveniently.
383 
384     \section1 Remarks
385 
386     \note All conversion to and from string formats is done using the C locale.
387     For localized conversions, see QLocale.
388 
389     In the Gregorian calendar, there is no year 0. Dates in that year are
390     considered invalid. The year -1 is the year "1 before Christ" or "1 before
391     common era." The day before 1 January 1 CE, QDate(1, 1, 1), is 31 December
392     1 BCE, QDate(-1, 12, 31). Various other calendars behave similarly; see
393     QCalendar::hasYearZero().
394 
395     \section2 Range of Valid Dates
396 
397     Dates are stored internally as a Julian Day number, an integer count of
398     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian
399     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).
400     As well as being an efficient and accurate way of storing an absolute date,
401     it is suitable for converting a date into other calendar systems such as
402     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using
403     QDate::toJulianDay() and can be set using QDate::fromJulianDay().
404 
405     The range of Julian Day numbers that QDate can represent is, for technical
406     reasons, limited to between -784350574879 and 784354017364, which means from
407     before 2 billion BCE to after 2 billion CE. This is more than seven times as
408     wide as the range of dates a QDateTime can represent.
409 
410     \sa QTime, QDateTime, QCalendar, QDateTime::YearRange, QDateEdit, QDateTimeEdit, QCalendarWidget
411 */
412 
413 /*!
414     \fn QDate::QDate()
415 
416     Constructs a null date. Null dates are invalid.
417 
418     \sa isNull(), isValid()
419 */
420 
421 /*!
422     Constructs a date with year \a y, month \a m and day \a d.
423 
424     The date is understood in terms of the Gregorian calendar. If the specified
425     date is invalid, the date is not set and isValid() returns \c false.
426 
427     \warning Years 1 to 99 are interpreted as is. Year 0 is invalid.
428 
429     \sa isValid(), QCalendar::dateFromParts()
430 */
431 
432 QDate::QDate(int y, int m, int d)
433 {
434     if (!QGregorianCalendar::julianFromParts(y, m, d, &jd))
435         jd = nullJd();
436 }
437 
438 QDate::QDate(int y, int m, int d, QCalendar cal)
439 {
440     *this = cal.dateFromParts(y, m, d);
441 }
442 
443 /*!
444     \fn bool QDate::isNull() const
445 
446     Returns \c true if the date is null; otherwise returns \c false. A null
447     date is invalid.
448 
449     \note The behavior of this function is equivalent to isValid().
450 
451     \sa isValid()
452 */
453 
454 /*!
455     \fn bool QDate::isValid() const
456 
457     Returns \c true if this date is valid; otherwise returns \c false.
458 
459     \sa isNull(), QCalendar::isDateValid()
460 */
461 
462 /*!
463     Returns the year of this date.
464 
465     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
466 
467     Returns 0 if the date is invalid. For some calendars, dates before their
468     first year may all be invalid.
469 
470     If using a calendar which has a year 0, check using isValid() if the return
471     is 0. Such calendars use negative year numbers in the obvious way, with
472     year 1 preceded by year 0, in turn preceded by year -1 and so on.
473 
474     Some calendars, despite having no year 0, have a conventional numbering of
475     the years before their first year, counting backwards from 1. For example,
476     in the proleptic Gregorian calendar, successive years before 1 CE (the first
477     year) are identified as 1 BCE, 2 BCE, 3 BCE and so on. For such calendars,
478     negative year numbers are used to indicate these years before year 1, with
479     -1 indicating the year before 1.
480 
481     \sa month(), day(), QCalendar::hasYearZero(), QCalendar::isProleptic(), QCalendar::partsFromDate()
482 */
483 
484 int QDate::year(QCalendar cal) const
485 {
486     if (isValid()) {
487         const auto parts = cal.partsFromDate(*this);
488         if (parts.isValid())
489             return parts.year;
490     }
491     return 0;
492 }
493 
494 /*!
495   \overload
496  */
497 
498 int QDate::year() const
499 {
500     if (isValid()) {
501         const auto parts = QGregorianCalendar::partsFromJulian(jd);
502         if (parts.isValid())
503             return parts.year;
504     }
505     return 0;
506 }
507 
508 /*!
509     Returns the month-number for the date.
510 
511     Numbers the months of the year starting with 1 for the first. Uses \a cal
512     as calendar if supplied, else the Gregorian calendar, for which the month
513     numbering is as follows:
514 
515     \list
516     \li 1 = "January"
517     \li 2 = "February"
518     \li 3 = "March"
519     \li 4 = "April"
520     \li 5 = "May"
521     \li 6 = "June"
522     \li 7 = "July"
523     \li 8 = "August"
524     \li 9 = "September"
525     \li 10 = "October"
526     \li 11 = "November"
527     \li 12 = "December"
528     \endlist
529 
530     Returns 0 if the date is invalid. Note that some calendars may have more
531     than 12 months in some years.
532 
533     \sa year(), day(), QCalendar::partsFromDate()
534 */
535 
536 int QDate::month(QCalendar cal) const
537 {
538     if (isValid()) {
539         const auto parts = cal.partsFromDate(*this);
540         if (parts.isValid())
541             return parts.month;
542     }
543     return 0;
544 }
545 
546 /*!
547   \overload
548  */
549 
550 int QDate::month() const
551 {
552     if (isValid()) {
553         const auto parts = QGregorianCalendar::partsFromJulian(jd);
554         if (parts.isValid())
555             return parts.month;
556     }
557     return 0;
558 }
559 
560 /*!
561     Returns the day of the month for this date.
562 
563     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
564     the return ranges from 1 to 31). Returns 0 if the date is invalid.
565 
566     \sa year(), month(), dayOfWeek(), QCalendar::partsFromDate()
567 */
568 
569 int QDate::day(QCalendar cal) const
570 {
571     if (isValid()) {
572         const auto parts = cal.partsFromDate(*this);
573         if (parts.isValid())
574             return parts.day;
575     }
576     return 0;
577 }
578 
579 /*!
580   \overload
581  */
582 
583 int QDate::day() const
584 {
585     if (isValid()) {
586         const auto parts = QGregorianCalendar::partsFromJulian(jd);
587         if (parts.isValid())
588             return parts.day;
589     }
590     return 0;
591 }
592 
593 /*!
594     Returns the weekday (1 = Monday to 7 = Sunday) for this date.
595 
596     Uses \a cal as calendar if supplied, else the Gregorian calendar. Returns 0
597     if the date is invalid. Some calendars may give special meaning
598     (e.g. intercallary days) to values greater than 7.
599 
600     \sa day(), dayOfYear(), QCalendar::dayOfWeek(), Qt::DayOfWeek
601 */
602 
603 int QDate::dayOfWeek(QCalendar cal) const
604 {
605     if (isNull())
606         return 0;
607 
608     return cal.dayOfWeek(*this);
609 }
610 
611 /*!
612   \overload
613  */
614 
615 int QDate::dayOfWeek() const
616 {
617     return isValid() ? QGregorianCalendar::weekDayOfJulian(jd) : 0;
618 }
619 
620 /*!
621     Returns the day of the year (1 for the first day) for this date.
622 
623     Uses \a cal as calendar if supplied, else the Gregorian calendar.
624     Returns 0 if either the date or the first day of its year is invalid.
625 
626     \sa day(), dayOfWeek(), QCalendar::daysInYear()
627 */
628 
629 int QDate::dayOfYear(QCalendar cal) const
630 {
631     if (isValid()) {
632         QDate firstDay = cal.dateFromParts(year(cal), 1, 1);
633         if (firstDay.isValid())
634             return firstDay.daysTo(*this) + 1;
635     }
636     return 0;
637 }
638 
639 /*!
640   \overload
641  */
642 
643 int QDate::dayOfYear() const
644 {
645     if (isValid()) {
646         qint64 first;
647         if (QGregorianCalendar::julianFromParts(year(), 1, 1, &first))
648             return jd - first + 1;
649     }
650     return 0;
651 }
652 
653 /*!
654     Returns the number of days in the month for this date.
655 
656     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
657     the result ranges from 28 to 31). Returns 0 if the date is invalid.
658 
659     \sa day(), daysInYear(), QCalendar::daysInMonth(),
660         QCalendar::maximumDaysInMonth(), QCalendar::minimumDaysInMonth()
661 */
662 
663 int QDate::daysInMonth(QCalendar cal) const
664 {
665     if (isValid()) {
666         const auto parts = cal.partsFromDate(*this);
667         if (parts.isValid())
668             return cal.daysInMonth(parts.month, parts.year);
669     }
670     return 0;
671 }
672 
673 /*!
674   \overload
675  */
676 
677 int QDate::daysInMonth() const
678 {
679     if (isValid()) {
680         const auto parts = QGregorianCalendar::partsFromJulian(jd);
681         if (parts.isValid())
682             return QGregorianCalendar::monthLength(parts.month, parts.year);
683     }
684     return 0;
685 }
686 
687 /*!
688     Returns the number of days in the year for this date.
689 
690     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
691     the result is 365 or 366). Returns 0 if the date is invalid.
692 
693     \sa day(), daysInMonth(), QCalendar::daysInYear(), QCalendar::maximumMonthsInYear()
694 */
695 
696 int QDate::daysInYear(QCalendar cal) const
697 {
698     if (isNull())
699         return 0;
700 
701     return cal.daysInYear(year(cal));
702 }
703 
704 /*!
705   \overload
706  */
707 
708 int QDate::daysInYear() const
709 {
710     return isValid() ? QGregorianCalendar::leapTest(year()) ? 366 : 365 : 0;
711 }
712 
713 /*!
714     Returns the ISO 8601 week number (1 to 53).
715 
716     Returns 0 if the date is invalid. Otherwise, returns the week number for the
717     date. If \a yearNumber is not \nullptr (its default), stores the year as
718     *\a{yearNumber}.
719 
720     In accordance with ISO 8601, each week falls in the year to which most of
721     its days belong, in the Gregorian calendar. As ISO 8601's week starts on
722     Monday, this is the year in which the week's Thursday falls. Most years have
723     52 weeks, but some have 53.
724 
725     \note *\a{yearNumber} is not always the same as year(). For example, 1
726     January 2000 has week number 52 in the year 1999, and 31 December
727     2002 has week number 1 in the year 2003.
728 
729     \sa isValid()
730 */
731 
732 int QDate::weekNumber(int *yearNumber) const
733 {
734     if (!isValid())
735         return 0;
736 
737     // This could be replaced by use of QIso8601Calendar, once we implement it.
738     // The Thursday of the same week determines our answer:
739     QDate thursday(addDays(4 - dayOfWeek()));
740     int year = thursday.year();
741     // Week n's Thurs's DOY has 1 <= DOY - 7*(n-1) < 8, so 0 <= DOY + 6 - 7*n < 7:
742     int week = (thursday.dayOfYear() + 6) / 7;
743 
744     if (yearNumber)
745         *yearNumber = year;
746     return week;
747 }
748 
749 static bool inDateTimeRange(qint64 jd, bool start)
750 {
751     using Bounds = std::numeric_limits<qint64>;
752     if (jd < Bounds::min() + JULIAN_DAY_FOR_EPOCH)
753         return false;
754     jd -= JULIAN_DAY_FOR_EPOCH;
755     const qint64 maxDay = Bounds::max() / MSECS_PER_DAY;
756     const qint64 minDay = Bounds::min() / MSECS_PER_DAY - 1;
757     // (Divisions rounded towards zero, as MSECS_PER_DAY has factors other than two.)
758     // Range includes start of last day and end of first:
759     if (start)
760         return jd > minDay && jd <= maxDay;
761     return jd >= minDay && jd < maxDay;
762 }
763 
764 static QDateTime toEarliest(QDate day, const QDateTime &form)
765 {
766     const Qt::TimeSpec spec = form.timeSpec();
767     const int offset = (spec == Qt::OffsetFromUTC) ? form.offsetFromUtc() : 0;
768 #if QT_CONFIG(timezone)
769     QTimeZone zone;
770     if (spec == Qt::TimeZone)
771         zone = form.timeZone();
772 #endif
773     auto moment = [=](QTime time) {
774         switch (spec) {
775         case Qt::OffsetFromUTC: return QDateTime(day, time, spec, offset);
776 #if QT_CONFIG(timezone)
777         case Qt::TimeZone: return QDateTime(day, time, zone);
778 #endif
779         default: return QDateTime(day, time, spec);
780         }
781     };
782     // Longest routine time-zone transition is 2 hours:
783     QDateTime when = moment(QTime(2, 0));
784     if (!when.isValid()) {
785         // Noon should be safe ...
786         when = moment(QTime(12, 0));
787         if (!when.isValid()) {
788             // ... unless it's a 24-hour jump (moving the date-line)
789             when = moment(QTime(23, 59, 59, 999));
790             if (!when.isValid())
791                 return QDateTime();
792         }
793     }
794     int high = when.time().msecsSinceStartOfDay() / 60000;
795     int low = 0;
796     // Binary chop to the right minute
797     while (high > low + 1) {
798         int mid = (high + low) / 2;
799         QDateTime probe = moment(QTime(mid / 60, mid % 60));
800         if (probe.isValid() && probe.date() == day) {
801             high = mid;
802             when = probe;
803         } else {
804             low = mid;
805         }
806     }
807     return when;
808 }
809 
810 /*!
811     \since 5.14
812     \fn QDateTime QDate::startOfDay(Qt::TimeSpec spec, int offsetSeconds) const
813     \fn QDateTime QDate::startOfDay(const QTimeZone &zone) const
814 
815     Returns the start-moment of the day.  Usually, this shall be midnight at the
816     start of the day: however, if a time-zone transition causes the given date
817     to skip over that midnight (e.g. a DST spring-forward skipping from the end
818     of the previous day to 01:00 of the new day), the actual earliest time in
819     the day is returned.  This can only arise when the start-moment is specified
820     in terms of a time-zone (by passing its QTimeZone as \a zone) or in terms of
821     local time (by passing Qt::LocalTime as \a spec; this is its default).
822 
823     The \a offsetSeconds is ignored unless \a spec is Qt::OffsetFromUTC, when it
824     gives the implied zone's offset from UTC.  As UTC and such zones have no
825     transitions, the start of the day is QTime(0, 0) in these cases.
826 
827     In the rare case of a date that was entirely skipped (this happens when a
828     zone east of the international date-line switches to being west of it), the
829     return shall be invalid.  Passing Qt::TimeZone as \a spec (instead of
830     passing a QTimeZone) or passing an invalid time-zone as \a zone will also
831     produce an invalid result, as shall dates that start outside the range
832     representable by QDateTime.
833 
834     \sa endOfDay()
835 */
836 QDateTime QDate::startOfDay(Qt::TimeSpec spec, int offsetSeconds) const
837 {
838     if (!inDateTimeRange(jd, true))
839         return QDateTime();
840 
841     switch (spec) {
842     case Qt::TimeZone: // should pass a QTimeZone instead of Qt::TimeZone
843         qWarning() << "Called QDate::startOfDay(Qt::TimeZone) on" << *this;
844         return QDateTime();
845     case Qt::OffsetFromUTC:
846     case Qt::UTC:
847         return QDateTime(*this, QTime(0, 0), spec, offsetSeconds);
848 
849     case Qt::LocalTime:
850         if (offsetSeconds)
851             qWarning("Ignoring offset (%d seconds) passed with Qt::LocalTime", offsetSeconds);
852         break;
853     }
854     QDateTime when(*this, QTime(0, 0), spec);
855     if (!when.isValid())
856         when = toEarliest(*this, when);
857 
858     return when.isValid() ? when : QDateTime();
859 }
860 
861 #if QT_CONFIG(timezone)
862 /*!
863   \overload
864   \since 5.14
865 */
866 QDateTime QDate::startOfDay(const QTimeZone &zone) const
867 {
868     if (!inDateTimeRange(jd, true) || !zone.isValid())
869         return QDateTime();
870 
871     QDateTime when(*this, QTime(0, 0), zone);
872     if (when.isValid())
873         return when;
874 
875     // The start of the day must have fallen in a spring-forward's gap; find the spring-forward:
876     if (zone.hasTransitions()) {
877         QTimeZone::OffsetData tran = zone.previousTransition(QDateTime(*this, QTime(23, 59, 59, 999), zone));
878         const QDateTime &at = tran.atUtc.toTimeZone(zone);
879         if (at.isValid() && at.date() == *this)
880             return at;
881     }
882 
883     when = toEarliest(*this, when);
884     return when.isValid() ? when : QDateTime();
885 }
886 #endif // timezone
887 
888 static QDateTime toLatest(QDate day, const QDateTime &form)
889 {
890     const Qt::TimeSpec spec = form.timeSpec();
891     const int offset = (spec == Qt::OffsetFromUTC) ? form.offsetFromUtc() : 0;
892 #if QT_CONFIG(timezone)
893     QTimeZone zone;
894     if (spec == Qt::TimeZone)
895         zone = form.timeZone();
896 #endif
897     auto moment = [=](QTime time) {
898         switch (spec) {
899         case Qt::OffsetFromUTC: return QDateTime(day, time, spec, offset);
900 #if QT_CONFIG(timezone)
901         case Qt::TimeZone: return QDateTime(day, time, zone);
902 #endif
903         default: return QDateTime(day, time, spec);
904         }
905     };
906     // Longest routine time-zone transition is 2 hours:
907     QDateTime when = moment(QTime(21, 59, 59, 999));
908     if (!when.isValid()) {
909         // Noon should be safe ...
910         when = moment(QTime(12, 0));
911         if (!when.isValid()) {
912             // ... unless it's a 24-hour jump (moving the date-line)
913             when = moment(QTime(0, 0));
914             if (!when.isValid())
915                 return QDateTime();
916         }
917     }
918     int high = 24 * 60;
919     int low = when.time().msecsSinceStartOfDay() / 60000;
920     // Binary chop to the right minute
921     while (high > low + 1) {
922         int mid = (high + low) / 2;
923         QDateTime probe = moment(QTime(mid / 60, mid % 60, 59, 999));
924         if (probe.isValid() && probe.date() == day) {
925             low = mid;
926             when = probe;
927         } else {
928             high = mid;
929         }
930     }
931     return when;
932 }
933 
934 /*!
935     \since 5.14
936     \fn QDateTime QDate::endOfDay(Qt::TimeSpec spec, int offsetSeconds) const
937     \fn QDateTime QDate::endOfDay(const QTimeZone &zone) const
938 
939     Returns the end-moment of the day.  Usually, this is one millisecond before
940     the midnight at the end of the day: however, if a time-zone transition
941     causes the given date to skip over that midnight (e.g. a DST spring-forward
942     skipping from just before 23:00 to the start of the next day), the actual
943     latest time in the day is returned.  This can only arise when the
944     start-moment is specified in terms of a time-zone (by passing its QTimeZone
945     as \a zone) or in terms of local time (by passing Qt::LocalTime as \a spec;
946     this is its default).
947 
948     The \a offsetSeconds is ignored unless \a spec is Qt::OffsetFromUTC, when it
949     gives the implied zone's offset from UTC.  As UTC and such zones have no
950     transitions, the end of the day is QTime(23, 59, 59, 999) in these cases.
951 
952     In the rare case of a date that was entirely skipped (this happens when a
953     zone east of the international date-line switches to being west of it), the
954     return shall be invalid.  Passing Qt::TimeZone as \a spec (instead of
955     passing a QTimeZone) will also produce an invalid result, as shall dates
956     that end outside the range representable by QDateTime.
957 
958     \sa startOfDay()
959 */
960 QDateTime QDate::endOfDay(Qt::TimeSpec spec, int offsetSeconds) const
961 {
962     if (!inDateTimeRange(jd, false))
963         return QDateTime();
964 
965     switch (spec) {
966     case Qt::TimeZone: // should pass a QTimeZone instead of Qt::TimeZone
967         qWarning() << "Called QDate::endOfDay(Qt::TimeZone) on" << *this;
968         return QDateTime();
969     case Qt::UTC:
970     case Qt::OffsetFromUTC:
971         return QDateTime(*this, QTime(23, 59, 59, 999), spec, offsetSeconds);
972 
973     case Qt::LocalTime:
974         if (offsetSeconds)
975             qWarning("Ignoring offset (%d seconds) passed with Qt::LocalTime", offsetSeconds);
976         break;
977     }
978     QDateTime when(*this, QTime(23, 59, 59, 999), spec);
979     if (!when.isValid())
980         when = toLatest(*this, when);
981     return when.isValid() ? when : QDateTime();
982 }
983 
984 #if QT_CONFIG(timezone)
985 /*!
986   \overload
987   \since 5.14
988 */
989 QDateTime QDate::endOfDay(const QTimeZone &zone) const
990 {
991     if (!inDateTimeRange(jd, false) || !zone.isValid())
992         return QDateTime();
993 
994     QDateTime when(*this, QTime(23, 59, 59, 999), zone);
995     if (when.isValid())
996         return when;
997 
998     // The end of the day must have fallen in a spring-forward's gap; find the spring-forward:
999     if (zone.hasTransitions()) {
1000         QTimeZone::OffsetData tran = zone.nextTransition(QDateTime(*this, QTime(0, 0), zone));
1001         const QDateTime &at = tran.atUtc.toTimeZone(zone);
1002         if (at.isValid() && at.date() == *this)
1003             return at;
1004     }
1005 
1006     when = toLatest(*this, when);
1007     return when.isValid() ? when : QDateTime();
1008 }
1009 #endif // timezone
1010 
1011 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1012 
1013 static QString toStringTextDate(QDate date)
1014 {
1015     if (date.isValid()) {
1016         QCalendar cal; // Always Gregorian
1017         const auto parts = cal.partsFromDate(date);
1018         if (parts.isValid()) {
1019             const QLatin1Char sp(' ');
1020             return QLocale::c().dayName(cal.dayOfWeek(date), QLocale::ShortFormat) + sp
1021                 + cal.monthName(QLocale::c(), parts.month, parts.year, QLocale::ShortFormat)
1022                 + sp + QString::number(parts.day) + sp + QString::number(parts.year);
1023         }
1024     }
1025     return QString();
1026 }
1027 
1028 static QString toStringIsoDate(QDate date)
1029 {
1030     const auto parts = QCalendar().partsFromDate(date);
1031     if (parts.isValid() && parts.year >= 0 && parts.year <= 9999)
1032         return QString::asprintf("%04d-%02d-%02d", parts.year, parts.month, parts.day);
1033     return QString();
1034 }
1035 
1036 /*!
1037     \overload
1038 
1039     Returns the date as a string. The \a format parameter determines the format
1040     of the string.
1041 
1042     If the \a format is Qt::TextDate, the string is formatted in the default
1043     way. The day and month names will be in English. An example of this
1044     formatting is "Sat May 20 1995". For localized formatting, see
1045     \l{QLocale::toString()}.
1046 
1047     If the \a format is Qt::ISODate, the string format corresponds
1048     to the ISO 8601 extended specification for representations of
1049     dates and times, taking the form yyyy-MM-dd, where yyyy is the
1050     year, MM is the month of the year (between 01 and 12), and dd is
1051     the day of the month between 01 and 31.
1052 
1053     If the \a format is Qt::RFC2822Date, the string is formatted in
1054     an \l{RFC 2822} compatible way. An example of this formatting is
1055     "20 May 1995".
1056 
1057     If the date is invalid, an empty string will be returned.
1058 
1059     \warning The Qt::ISODate format is only valid for years in the
1060     range 0 to 9999.
1061 
1062     \sa fromString(), QLocale::toString()
1063 */
1064 QString QDate::toString(Qt::DateFormat format) const
1065 {
1066     if (!isValid())
1067         return QString();
1068 
1069     switch (format) {
1070     case Qt::RFC2822Date:
1071         return QLocale::c().toString(*this, u"dd MMM yyyy");
1072     default:
1073     case Qt::TextDate:
1074         return toStringTextDate(*this);
1075     case Qt::ISODate:
1076     case Qt::ISODateWithMs:
1077         // No calendar dependence
1078         return toStringIsoDate(*this);
1079     }
1080 }
1081 
1082 /*!
1083     \fn QString QDate::toString(const QString &format, QCalendar cal) const
1084     \fn QString QDate::toString(QStringView format, QCalendar cal) const
1085 
1086     Returns the date as a string. The \a format parameter determines the format
1087     of the result string. If \a cal is supplied, it determines the calendar used
1088     to represent the date; it defaults to Gregorian.
1089 
1090     These expressions may be used:
1091 
1092     \table
1093     \header \li Expression \li Output
1094     \row \li d \li The day as a number without a leading zero (1 to 31)
1095     \row \li dd \li The day as a number with a leading zero (01 to 31)
1096     \row \li ddd \li The abbreviated day name ('Mon' to 'Sun').
1097     \row \li dddd \li The long day name ('Monday' to 'Sunday').
1098     \row \li M \li The month as a number without a leading zero (1 to 12)
1099     \row \li MM \li The month as a number with a leading zero (01 to 12)
1100     \row \li MMM \li The abbreviated month name ('Jan' to 'Dec').
1101     \row \li MMMM \li The long month name ('January' to 'December').
1102     \row \li yy \li The year as a two digit number (00 to 99)
1103     \row \li yyyy \li The year as a four digit number. If the year is negative,
1104             a minus sign is prepended, making five characters.
1105     \endtable
1106 
1107     Any sequence of characters enclosed in single quotes will be included
1108     verbatim in the output string (stripped of the quotes), even if it contains
1109     formatting characters. Two consecutive single quotes ("''") are replaced by
1110     a single quote in the output. All other characters in the format string are
1111     included verbatim in the output string.
1112 
1113     Formats without separators (e.g. "ddMM") are supported but must be used with
1114     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
1115     produces "212" it could mean either the 2nd of December or the 21st of
1116     February).
1117 
1118     Example format strings (assuming that the QDate is the 20 July
1119     1969):
1120 
1121     \table
1122     \header \li Format            \li Result
1123     \row    \li dd.MM.yyyy        \li 20.07.1969
1124     \row    \li ddd MMMM d yy     \li Sun July 20 69
1125     \row    \li 'The day is' dddd \li The day is Sunday
1126     \endtable
1127 
1128     If the datetime is invalid, an empty string will be returned.
1129 
1130     \note If localized month and day names are desired, please switch to using
1131     QLocale::system().toString() as QDate methods shall change to use English (C
1132     locale) names at Qt 6.
1133 
1134     \sa fromString(), QDateTime::toString(), QTime::toString(), QLocale::toString()
1135 
1136 */
1137 QString QDate::toString(QStringView format, QCalendar cal) const
1138 {
1139     return QLocale::c().toString(*this, format, cal);
1140 }
1141 
1142 #if QT_STRINGVIEW_LEVEL < 2
1143 QString QDate::toString(const QString &format, QCalendar cal) const
1144 {
1145     return toString(qToStringViewIgnoringNull(format), cal);
1146 }
1147 #endif
1148 
1149 #endif // datestring
1150 
1151 /*!
1152     \since 4.2
1153 
1154     Sets this to represent the date, in the Gregorian calendar, with the given
1155     \a year, \a month and \a day numbers. Returns true if the resulting date is
1156     valid, otherwise it sets this to represent an invalid date and returns
1157     false.
1158 
1159     \sa isValid(), QCalendar::dateFromParts()
1160 */
1161 bool QDate::setDate(int year, int month, int day)
1162 {
1163     if (QGregorianCalendar::julianFromParts(year, month, day, &jd))
1164         return true;
1165 
1166     jd = nullJd();
1167     return false;
1168 }
1169 
1170 /*!
1171     \since 5.14
1172 
1173     Sets this to represent the date, in the given calendar \a cal, with the
1174     given \a year, \a month and \a day numbers. Returns true if the resulting
1175     date is valid, otherwise it sets this to represent an invalid date and
1176     returns false.
1177 
1178     \sa isValid(), QCalendar::dateFromParts()
1179 */
1180 
1181 bool QDate::setDate(int year, int month, int day, QCalendar cal)
1182 {
1183     *this = QDate(year, month, day, cal);
1184     return isValid();
1185 }
1186 
1187 /*!
1188     \since 4.5
1189 
1190     Extracts the date's year, month, and day, and assigns them to
1191     *\a year, *\a month, and *\a day. The pointers may be null.
1192 
1193     Returns 0 if the date is invalid.
1194 
1195     \note In Qt versions prior to 5.7, this function is marked as non-\c{const}.
1196 
1197     \sa year(), month(), day(), isValid(), QCalendar::partsFromDate()
1198 */
1199 void QDate::getDate(int *year, int *month, int *day) const
1200 {
1201     QCalendar::YearMonthDay parts; // invalid by default
1202     if (isValid())
1203         parts = QGregorianCalendar::partsFromJulian(jd);
1204 
1205     const bool ok = parts.isValid();
1206     if (year)
1207         *year = ok ? parts.year : 0;
1208     if (month)
1209         *month = ok ? parts.month : 0;
1210     if (day)
1211         *day = ok ? parts.day : 0;
1212 }
1213 
1214 /*!
1215     Returns a QDate object containing a date \a ndays later than the
1216     date of this object (or earlier if \a ndays is negative).
1217 
1218     Returns a null date if the current date is invalid or the new date is
1219     out of range.
1220 
1221     \sa addMonths(), addYears(), daysTo()
1222 */
1223 
1224 QDate QDate::addDays(qint64 ndays) const
1225 {
1226     if (isNull())
1227         return QDate();
1228 
1229     // Due to limits on minJd() and maxJd() we know that any overflow
1230     // will be invalid and caught by fromJulianDay().
1231     return fromJulianDay(jd + ndays);
1232 }
1233 
1234 /*!
1235     Returns a QDate object containing a date \a nmonths later than the
1236     date of this object (or earlier if \a nmonths is negative).
1237 
1238     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
1239 
1240     \note If the ending day/month combination does not exist in the resulting
1241     month/year, this function will return a date that is the latest valid date
1242     in the selected month.
1243 
1244     \sa addDays(), addYears()
1245 */
1246 
1247 QDate QDate::addMonths(int nmonths, QCalendar cal) const
1248 {
1249     if (!isValid())
1250         return QDate();
1251 
1252     if (nmonths == 0)
1253         return *this;
1254 
1255     auto parts = cal.partsFromDate(*this);
1256 
1257     if (!parts.isValid())
1258         return QDate();
1259     Q_ASSERT(parts.year || cal.hasYearZero());
1260 
1261     parts.month += nmonths;
1262     while (parts.month <= 0) {
1263         if (--parts.year || cal.hasYearZero())
1264             parts.month += cal.monthsInYear(parts.year);
1265     }
1266     int count = cal.monthsInYear(parts.year);
1267     while (parts.month > count) {
1268         parts.month -= count;
1269         count = (++parts.year || cal.hasYearZero()) ? cal.monthsInYear(parts.year) : 0;
1270     }
1271 
1272     return fixedDate(std::move(parts), cal);
1273 }
1274 
1275 /*!
1276   \overload
1277 */
1278 
1279 QDate QDate::addMonths(int nmonths) const
1280 {
1281     if (isNull())
1282         return QDate();
1283 
1284     if (nmonths == 0)
1285         return *this;
1286 
1287     auto parts = QGregorianCalendar::partsFromJulian(jd);
1288 
1289     if (!parts.isValid())
1290         return QDate();
1291     Q_ASSERT(parts.year);
1292 
1293     parts.month += nmonths;
1294     while (parts.month <= 0) {
1295         if (--parts.year) // skip over year 0
1296             parts.month += 12;
1297     }
1298     while (parts.month > 12) {
1299         parts.month -= 12;
1300         if (!++parts.year) // skip over year 0
1301             ++parts.year;
1302     }
1303 
1304     return fixedDate(std::move(parts));
1305 }
1306 
1307 /*!
1308     Returns a QDate object containing a date \a nyears later than the
1309     date of this object (or earlier if \a nyears is negative).
1310 
1311     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
1312 
1313     \note If the ending day/month combination does not exist in the resulting
1314     year (e.g., for the Gregorian calendar, if the date was Feb 29 and the final
1315     year is not a leap year), this function will return a date that is the
1316     latest valid date in the given month (in the example, Feb 28).
1317 
1318     \sa addDays(), addMonths()
1319 */
1320 
1321 QDate QDate::addYears(int nyears, QCalendar cal) const
1322 {
1323     if (!isValid())
1324         return QDate();
1325 
1326     auto parts = cal.partsFromDate(*this);
1327     if (!parts.isValid())
1328         return QDate();
1329 
1330     int old_y = parts.year;
1331     parts.year += nyears;
1332 
1333     // If we just crossed (or hit) a missing year zero, adjust year by +/- 1:
1334     if (!cal.hasYearZero() && ((old_y > 0) != (parts.year > 0) || !parts.year))
1335         parts.year += nyears > 0 ? +1 : -1;
1336 
1337     return fixedDate(std::move(parts), cal);
1338 }
1339 
1340 /*!
1341     \overload
1342 */
1343 
1344 QDate QDate::addYears(int nyears) const
1345 {
1346     if (isNull())
1347         return QDate();
1348 
1349     auto parts = QGregorianCalendar::partsFromJulian(jd);
1350     if (!parts.isValid())
1351         return QDate();
1352 
1353     int old_y = parts.year;
1354     parts.year += nyears;
1355 
1356     // If we just crossed (or hit) a missing year zero, adjust year by +/- 1:
1357     if ((old_y > 0) != (parts.year > 0) || !parts.year)
1358         parts.year += nyears > 0 ? +1 : -1;
1359 
1360     return fixedDate(std::move(parts));
1361 }
1362 
1363 /*!
1364     Returns the number of days from this date to \a d (which is
1365     negative if \a d is earlier than this date).
1366 
1367     Returns 0 if either date is invalid.
1368 
1369     Example:
1370     \snippet code/src_corelib_time_qdatetime.cpp 0
1371 
1372     \sa addDays()
1373 */
1374 
1375 qint64 QDate::daysTo(QDate d) const
1376 {
1377     if (isNull() || d.isNull())
1378         return 0;
1379 
1380     // Due to limits on minJd() and maxJd() we know this will never overflow
1381     return d.jd - jd;
1382 }
1383 
1384 
1385 /*!
1386     \fn bool QDate::operator==(QDate d) const
1387 
1388     Returns \c true if this date and \a d represent the same day, otherwise
1389     \c false.
1390 */
1391 
1392 /*!
1393     \fn bool QDate::operator!=(QDate d) const
1394 
1395     Returns \c true if this date is different from \a d; otherwise
1396     returns \c false.
1397 
1398     \sa operator==()
1399 */
1400 
1401 /*!
1402     \fn bool QDate::operator<(QDate d) const
1403 
1404     Returns \c true if this date is earlier than \a d; otherwise returns
1405     false.
1406 */
1407 
1408 /*!
1409     \fn bool QDate::operator<=(QDate d) const
1410 
1411     Returns \c true if this date is earlier than or equal to \a d;
1412     otherwise returns \c false.
1413 */
1414 
1415 /*!
1416     \fn bool QDate::operator>(QDate d) const
1417 
1418     Returns \c true if this date is later than \a d; otherwise returns
1419     false.
1420 */
1421 
1422 /*!
1423     \fn bool QDate::operator>=(QDate d) const
1424 
1425     Returns \c true if this date is later than or equal to \a d;
1426     otherwise returns \c false.
1427 */
1428 
1429 /*!
1430     \fn QDate::currentDate()
1431     Returns the current date, as reported by the system clock.
1432 
1433     \sa QTime::currentTime(), QDateTime::currentDateTime()
1434 */
1435 
1436 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1437 namespace {
1438 
1439 struct ParsedInt { int value = 0; bool ok = false; };
1440 
1441 /*
1442     /internal
1443 
1444     Read an int that must be the whole text.  QStringView ::toInt() will ignore
1445     spaces happily; but ISO date format should not.
1446 */
1447 ParsedInt readInt(QStringView text)
1448 {
1449     ParsedInt result;
1450     for (const auto &ch : text) {
1451         if (ch.isSpace())
1452             return result;
1453     }
1454     result.value = QLocale::c().toInt(text, &result.ok);
1455     return result;
1456 }
1457 
1458 }
1459 
1460 /*!
1461     Returns the QDate represented by the \a string, using the
1462     \a format given, or an invalid date if the string cannot be
1463     parsed.
1464 
1465     Note for Qt::TextDate: only English month names (e.g. "Jan" in short form or
1466     "January" in long form) are recognized.
1467 
1468     \sa toString(), QLocale::toDate()
1469 */
1470 
1471 QDate QDate::fromString(const QString &string, Qt::DateFormat format)
1472 {
1473     if (string.isEmpty())
1474         return QDate();
1475 
1476     switch (format) {
1477     case Qt::RFC2822Date:
1478         return rfcDateImpl(string).date;
1479     default:
1480     case Qt::TextDate: {
1481         auto parts = QStringView{string}.split(QLatin1Char(' '), Qt::SkipEmptyParts);
1482 
1483         if (parts.count() != 4)
1484             return QDate();
1485 
1486         bool ok = false;
1487         int year = parts.at(3).toInt(&ok);
1488         int day = ok ? parts.at(2).toInt(&ok) : 0;
1489         if (!ok || !day)
1490             return QDate();
1491 
1492         const int month = fromShortMonthName(parts.at(1));
1493         if (month == -1) // Month name matches no English or localised name.
1494             return QDate();
1495 
1496         return QDate(year, month, day);
1497         }
1498     case Qt::ISODate:
1499         // Semi-strict parsing, must be long enough and have punctuators as separators
1500         if (string.size() >= 10 && string.at(4).isPunct() && string.at(7).isPunct()
1501                 && (string.size() == 10 || !string.at(10).isDigit())) {
1502             QStringView view(string);
1503             const ParsedInt year = readInt(view.mid(0, 4));
1504             const ParsedInt month = readInt(view.mid(5, 2));
1505             const ParsedInt day = readInt(view.mid(8, 2));
1506             if (year.ok && year.value > 0 && year.value <= 9999 && month.ok && day.ok)
1507                 return QDate(year.value, month.value, day.value);
1508         }
1509         break;
1510     }
1511     return QDate();
1512 }
1513 
1514 /*!
1515     \fn QDate QDate::fromString(const QString &string, const QString &format, QCalendar cal)
1516 
1517     Returns the QDate represented by the \a string, using the \a
1518     format given, or an invalid date if the string cannot be parsed.
1519 
1520     Uses \a cal as calendar if supplied, else the Gregorian calendar. Ranges of
1521     values in the format descriptions below are for the latter; they may be
1522     different for other calendars.
1523 
1524     These expressions may be used for the format:
1525 
1526     \table
1527     \header \li Expression \li Output
1528     \row \li d \li The day as a number without a leading zero (1 to 31)
1529     \row \li dd \li The day as a number with a leading zero (01 to 31)
1530     \row \li ddd \li The abbreviated day name ('Mon' to 'Sun').
1531     \row \li dddd \li The long day name ('Monday' to 'Sunday').
1532     \row \li M \li The month as a number without a leading zero (1 to 12)
1533     \row \li MM \li The month as a number with a leading zero (01 to 12)
1534     \row \li MMM \li The abbreviated month name ('Jan' to 'Dec').
1535     \row \li MMMM \li The long month name ('January' to 'December').
1536     \row \li yy \li The year as a two digit number (00 to 99)
1537     \row \li yyyy \li The year as a four digit number, possibly plus a leading
1538              minus sign for negative years.
1539     \endtable
1540 
1541     \note Unlike the other version of this function, day and month names must
1542     be given in the user's local language. It is only possible to use the English
1543     names if the user's language is English.
1544 
1545     All other input characters will be treated as text. Any non-empty sequence
1546     of characters enclosed in single quotes will also be treated (stripped of
1547     the quotes) as text and not be interpreted as expressions. For example:
1548 
1549     \snippet code/src_corelib_time_qdatetime.cpp 1
1550 
1551     If the format is not satisfied, an invalid QDate is returned. The
1552     expressions that don't expect leading zeroes (d, M) will be
1553     greedy. This means that they will use two digits even if this
1554     will put them outside the accepted range of values and leaves too
1555     few digits for other sections. For example, the following format
1556     string could have meant January 30 but the M will grab two
1557     digits, resulting in an invalid date:
1558 
1559     \snippet code/src_corelib_time_qdatetime.cpp 2
1560 
1561     For any field that is not represented in the format the following
1562     defaults are used:
1563 
1564     \table
1565     \header \li Field  \li Default value
1566     \row    \li Year   \li 1900
1567     \row    \li Month  \li 1
1568     \row    \li Day    \li 1
1569     \endtable
1570 
1571     The following examples demonstrate the default values:
1572 
1573     \snippet code/src_corelib_time_qdatetime.cpp 3
1574 
1575     \note If localized month and day names are used, please switch to using
1576     QLocale::system().toDate() as QDate methods shall change to only recognize
1577     English (C locale) names at Qt 6.
1578 
1579     \sa toString(), QDateTime::fromString(), QTime::fromString(),
1580         QLocale::toDate()
1581 */
1582 
1583 QDate QDate::fromString(const QString &string, const QString &format, QCalendar cal)
1584 {
1585     QDate date;
1586 #if QT_CONFIG(datetimeparser)
1587     QDateTimeParser dt(QMetaType::QDate, QDateTimeParser::FromString, cal);
1588     dt.setDefaultLocale(QLocale::c());
1589     if (dt.parseFormat(format))
1590         dt.fromString(string, &date, nullptr);
1591 #else
1592     Q_UNUSED(string);
1593     Q_UNUSED(format);
1594     Q_UNUSED(cal);
1595 #endif
1596     return date;
1597 }
1598 #endif // datestring
1599 
1600 /*!
1601     \overload
1602 
1603     Returns \c true if the specified date (\a year, \a month, and \a day) is
1604     valid in the Gregorian calendar; otherwise returns \c false.
1605 
1606     Example:
1607     \snippet code/src_corelib_time_qdatetime.cpp 4
1608 
1609     \sa isNull(), setDate(), QCalendar::isDateValid()
1610 */
1611 
1612 bool QDate::isValid(int year, int month, int day)
1613 {
1614     return QGregorianCalendar::validParts(year, month, day);
1615 }
1616 
1617 /*!
1618     \fn bool QDate::isLeapYear(int year)
1619 
1620     Returns \c true if the specified \a year is a leap year in the Gregorian
1621     calendar; otherwise returns \c false.
1622 
1623     \sa QCalendar::isLeapYear()
1624 */
1625 
1626 bool QDate::isLeapYear(int y)
1627 {
1628     return QGregorianCalendar::leapTest(y);
1629 }
1630 
1631 /*! \fn static QDate QDate::fromJulianDay(qint64 jd)
1632 
1633     Converts the Julian day \a jd to a QDate.
1634 
1635     \sa toJulianDay()
1636 */
1637 
1638 /*! \fn int QDate::toJulianDay() const
1639 
1640     Converts the date to a Julian day.
1641 
1642     \sa fromJulianDay()
1643 */
1644 
1645 /*****************************************************************************
1646   QTime member functions
1647  *****************************************************************************/
1648 
1649 /*!
1650     \class QTime
1651     \inmodule QtCore
1652     \reentrant
1653 
1654     \brief The QTime class provides clock time functions.
1655 
1656     A QTime object contains a clock time, which it can express as the numbers of
1657     hours, minutes, seconds, and milliseconds since midnight. It provides
1658     functions for comparing times and for manipulating a time by adding a number
1659     of milliseconds. QTime objects should be passed by value rather than by
1660     reference to const.
1661 
1662     QTime uses the 24-hour clock format; it has no concept of AM/PM.
1663     Unlike QDateTime, QTime knows nothing about time zones or
1664     daylight-saving time (DST).
1665 
1666     A QTime object is typically created either by giving the number of hours,
1667     minutes, seconds, and milliseconds explicitly, or by using the static
1668     function currentTime(), which creates a QTime object that represents the
1669     system's local time.
1670 
1671     The hour(), minute(), second(), and msec() functions provide
1672     access to the number of hours, minutes, seconds, and milliseconds
1673     of the time. The same information is provided in textual format by
1674     the toString() function.
1675 
1676     The addSecs() and addMSecs() functions provide the time a given
1677     number of seconds or milliseconds later than a given time.
1678     Correspondingly, the number of seconds or milliseconds
1679     between two times can be found using secsTo() or msecsTo().
1680 
1681     QTime provides a full set of operators to compare two QTime
1682     objects; an earlier time is considered smaller than a later one;
1683     if A.msecsTo(B) is positive, then A < B.
1684 
1685     QTime objects can also be created from a text representation using
1686     fromString() and converted to a string representation using toString(). All
1687     conversion to and from string formats is done using the C locale.  For
1688     localized conversions, see QLocale.
1689 
1690     \sa QDate, QDateTime
1691 */
1692 
1693 /*!
1694     \fn QTime::QTime()
1695 
1696     Constructs a null time object. For a null time, isNull() returns \c true and
1697     isValid() returns \c false. If you need a zero time, use QTime(0, 0).  For
1698     the start of a day, see QDate::startOfDay().
1699 
1700     \sa isNull(), isValid()
1701 */
1702 
1703 /*!
1704     Constructs a time with hour \a h, minute \a m, seconds \a s and
1705     milliseconds \a ms.
1706 
1707     \a h must be in the range 0 to 23, \a m and \a s must be in the
1708     range 0 to 59, and \a ms must be in the range 0 to 999.
1709 
1710     \sa isValid()
1711 */
1712 
1713 QTime::QTime(int h, int m, int s, int ms)
1714 {
1715     setHMS(h, m, s, ms);
1716 }
1717 
1718 
1719 /*!
1720     \fn bool QTime::isNull() const
1721 
1722     Returns \c true if the time is null (i.e., the QTime object was
1723     constructed using the default constructor); otherwise returns
1724     false. A null time is also an invalid time.
1725 
1726     \sa isValid()
1727 */
1728 
1729 /*!
1730     Returns \c true if the time is valid; otherwise returns \c false. For example,
1731     the time 23:30:55.746 is valid, but 24:12:30 is invalid.
1732 
1733     \sa isNull()
1734 */
1735 
1736 bool QTime::isValid() const
1737 {
1738     return mds > NullTime && mds < MSECS_PER_DAY;
1739 }
1740 
1741 
1742 /*!
1743     Returns the hour part (0 to 23) of the time.
1744 
1745     Returns -1 if the time is invalid.
1746 
1747     \sa minute(), second(), msec()
1748 */
1749 
1750 int QTime::hour() const
1751 {
1752     if (!isValid())
1753         return -1;
1754 
1755     return ds() / MSECS_PER_HOUR;
1756 }
1757 
1758 /*!
1759     Returns the minute part (0 to 59) of the time.
1760 
1761     Returns -1 if the time is invalid.
1762 
1763     \sa hour(), second(), msec()
1764 */
1765 
1766 int QTime::minute() const
1767 {
1768     if (!isValid())
1769         return -1;
1770 
1771     return (ds() % MSECS_PER_HOUR) / MSECS_PER_MIN;
1772 }
1773 
1774 /*!
1775     Returns the second part (0 to 59) of the time.
1776 
1777     Returns -1 if the time is invalid.
1778 
1779     \sa hour(), minute(), msec()
1780 */
1781 
1782 int QTime::second() const
1783 {
1784     if (!isValid())
1785         return -1;
1786 
1787     return (ds() / 1000)%SECS_PER_MIN;
1788 }
1789 
1790 /*!
1791     Returns the millisecond part (0 to 999) of the time.
1792 
1793     Returns -1 if the time is invalid.
1794 
1795     \sa hour(), minute(), second()
1796 */
1797 
1798 int QTime::msec() const
1799 {
1800     if (!isValid())
1801         return -1;
1802 
1803     return ds() % 1000;
1804 }
1805 
1806 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1807 /*!
1808     \overload
1809 
1810     Returns the time as a string. The \a format parameter determines
1811     the format of the string.
1812 
1813     If \a format is Qt::TextDate, the string format is HH:mm:ss;
1814     e.g. 1 second before midnight would be "23:59:59".
1815 
1816     If \a format is Qt::ISODate, the string format corresponds to the
1817     ISO 8601 extended specification for representations of dates,
1818     represented by HH:mm:ss. To include milliseconds in the ISO 8601
1819     date, use the \a format Qt::ISODateWithMs, which corresponds to
1820     HH:mm:ss.zzz.
1821 
1822     If the \a format is Qt::RFC2822Date, the string is formatted in
1823     an \l{RFC 2822} compatible way. An example of this formatting is
1824     "23:59:20".
1825 
1826     If the time is invalid, an empty string will be returned.
1827 
1828     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1829 */
1830 
1831 QString QTime::toString(Qt::DateFormat format) const
1832 {
1833     if (!isValid())
1834         return QString();
1835 
1836     switch (format) {
1837     case Qt::ISODateWithMs:
1838         return QString::asprintf("%02d:%02d:%02d.%03d", hour(), minute(), second(), msec());
1839     case Qt::RFC2822Date:
1840     case Qt::ISODate:
1841     case Qt::TextDate:
1842     default:
1843         return QString::asprintf("%02d:%02d:%02d", hour(), minute(), second());
1844     }
1845 }
1846 
1847 /*!
1848     \fn QString QTime::toString(const QString &format) const
1849     \fn QString QTime::toString(QStringView format) const
1850 
1851     Returns the time as a string. The \a format parameter determines
1852     the format of the result string.
1853 
1854     These expressions may be used:
1855 
1856     \table
1857     \header \li Expression \li Output
1858     \row \li h
1859          \li The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
1860     \row \li hh
1861          \li The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
1862     \row \li H
1863          \li The hour without a leading zero (0 to 23, even with AM/PM display)
1864     \row \li HH
1865          \li The hour with a leading zero (00 to 23, even with AM/PM display)
1866     \row \li m \li The minute without a leading zero (0 to 59)
1867     \row \li mm \li The minute with a leading zero (00 to 59)
1868     \row \li s \li The whole second, without any leading zero (0 to 59)
1869     \row \li ss \li The whole second, with a leading zero where applicable (00 to 59)
1870     \row \li z \li The fractional part of the second, to go after a decimal
1871                 point, without trailing zeroes (0 to 999).  Thus "\c{s.z}"
1872                 reports the seconds to full available (millisecond) precision
1873                 without trailing zeroes.
1874     \row \li zzz \li The fractional part of the second, to millisecond
1875                 precision, including trailing zeroes where applicable (000 to 999).
1876     \row \li AP or A
1877          \li Use AM/PM display. \e A/AP will be replaced by an upper-case
1878              version of either QLocale::amText() or QLocale::pmText().
1879     \row \li ap or a
1880          \li Use am/pm display. \e a/ap will be replaced by a lower-case version
1881              of either QLocale::amText() or QLocale::pmText().
1882     \row \li t \li The timezone (for example "CEST")
1883     \endtable
1884 
1885     Any non-empty sequence of characters enclosed in single quotes will be
1886     included verbatim in the output string (stripped of the quotes), even if it
1887     contains formatting characters. Two consecutive single quotes ("''") are
1888     replaced by a single quote in the output. All other characters in the format
1889     string are included verbatim in the output string.
1890 
1891     Formats without separators (e.g. "ddMM") are supported but must be used with
1892     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
1893     produces "212" it could mean either the 2nd of December or the 21st of
1894     February).
1895 
1896     Example format strings (assuming that the QTime is 14:13:09.042 and the system
1897     locale is \c{en_US})
1898 
1899     \table
1900     \header \li Format \li Result
1901     \row \li hh:mm:ss.zzz \li 14:13:09.042
1902     \row \li h:m:s ap     \li 2:13:9 pm
1903     \row \li H:m:s a      \li 14:13:9 pm
1904     \endtable
1905 
1906     If the time is invalid, an empty string will be returned.
1907     If \a format is empty, the default format "hh:mm:ss" is used.
1908 
1909     \note If localized forms of am or pm (the AP, ap, A or a formats) are
1910     desired, please switch to using QLocale::system().toString() as QTime
1911     methods shall change to use English (C locale) at Qt 6.
1912 
1913     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1914 */
1915 QString QTime::toString(QStringView format) const
1916 {
1917     return QLocale::c().toString(*this, format);
1918 }
1919 
1920 #if QT_STRINGVIEW_VERSION < 2
1921 QString QTime::toString(const QString &format) const
1922 {
1923     return toString(qToStringViewIgnoringNull(format));
1924 }
1925 #endif
1926 
1927 #endif // datestring
1928 
1929 /*!
1930     Sets the time to hour \a h, minute \a m, seconds \a s and
1931     milliseconds \a ms.
1932 
1933     \a h must be in the range 0 to 23, \a m and \a s must be in the
1934     range 0 to 59, and \a ms must be in the range 0 to 999.
1935     Returns \c true if the set time is valid; otherwise returns \c false.
1936 
1937     \sa isValid()
1938 */
1939 
1940 bool QTime::setHMS(int h, int m, int s, int ms)
1941 {
1942     if (!isValid(h,m,s,ms)) {
1943         mds = NullTime;                // make this invalid
1944         return false;
1945     }
1946     mds = (h*SECS_PER_HOUR + m*SECS_PER_MIN + s)*1000 + ms;
1947     return true;
1948 }
1949 
1950 /*!
1951     Returns a QTime object containing a time \a s seconds later
1952     than the time of this object (or earlier if \a s is negative).
1953 
1954     Note that the time will wrap if it passes midnight.
1955 
1956     Returns a null time if this time is invalid.
1957 
1958     Example:
1959 
1960     \snippet code/src_corelib_time_qdatetime.cpp 5
1961 
1962     \sa addMSecs(), secsTo(), QDateTime::addSecs()
1963 */
1964 
1965 QTime QTime::addSecs(int s) const
1966 {
1967     s %= SECS_PER_DAY;
1968     return addMSecs(s * 1000);
1969 }
1970 
1971 /*!
1972     Returns the number of seconds from this time to \a t.
1973     If \a t is earlier than this time, the number of seconds returned
1974     is negative.
1975 
1976     Because QTime measures time within a day and there are 86400
1977     seconds in a day, the result is always between -86400 and 86400.
1978 
1979     secsTo() does not take into account any milliseconds.
1980 
1981     Returns 0 if either time is invalid.
1982 
1983     \sa addSecs(), QDateTime::secsTo()
1984 */
1985 
1986 int QTime::secsTo(QTime t) const
1987 {
1988     if (!isValid() || !t.isValid())
1989         return 0;
1990 
1991     // Truncate milliseconds as we do not want to consider them.
1992     int ourSeconds = ds() / 1000;
1993     int theirSeconds = t.ds() / 1000;
1994     return theirSeconds - ourSeconds;
1995 }
1996 
1997 /*!
1998     Returns a QTime object containing a time \a ms milliseconds later
1999     than the time of this object (or earlier if \a ms is negative).
2000 
2001     Note that the time will wrap if it passes midnight. See addSecs()
2002     for an example.
2003 
2004     Returns a null time if this time is invalid.
2005 
2006     \sa addSecs(), msecsTo(), QDateTime::addMSecs()
2007 */
2008 
2009 QTime QTime::addMSecs(int ms) const
2010 {
2011     QTime t;
2012     if (isValid()) {
2013         if (ms < 0) {
2014             // %,/ not well-defined for -ve, so always work with +ve.
2015             int negdays = (MSECS_PER_DAY - ms) / MSECS_PER_DAY;
2016             t.mds = (ds() + ms + negdays * MSECS_PER_DAY) % MSECS_PER_DAY;
2017         } else {
2018             t.mds = (ds() + ms) % MSECS_PER_DAY;
2019         }
2020     }
2021     return t;
2022 }
2023 
2024 /*!
2025     Returns the number of milliseconds from this time to \a t.
2026     If \a t is earlier than this time, the number of milliseconds returned
2027     is negative.
2028 
2029     Because QTime measures time within a day and there are 86400
2030     seconds in a day, the result is always between -86400000 and
2031     86400000 ms.
2032 
2033     Returns 0 if either time is invalid.
2034 
2035     \sa secsTo(), addMSecs(), QDateTime::msecsTo()
2036 */
2037 
2038 int QTime::msecsTo(QTime t) const
2039 {
2040     if (!isValid() || !t.isValid())
2041         return 0;
2042     return t.ds() - ds();
2043 }
2044 
2045 
2046 /*!
2047     \fn bool QTime::operator==(QTime t) const
2048 
2049     Returns \c true if this time is equal to \a t; otherwise returns \c false.
2050 */
2051 
2052 /*!
2053     \fn bool QTime::operator!=(QTime t) const
2054 
2055     Returns \c true if this time is different from \a t; otherwise returns \c false.
2056 */
2057 
2058 /*!
2059     \fn bool QTime::operator<(QTime t) const
2060 
2061     Returns \c true if this time is earlier than \a t; otherwise returns \c false.
2062 */
2063 
2064 /*!
2065     \fn bool QTime::operator<=(QTime t) const
2066 
2067     Returns \c true if this time is earlier than or equal to \a t;
2068     otherwise returns \c false.
2069 */
2070 
2071 /*!
2072     \fn bool QTime::operator>(QTime t) const
2073 
2074     Returns \c true if this time is later than \a t; otherwise returns \c false.
2075 */
2076 
2077 /*!
2078     \fn bool QTime::operator>=(QTime t) const
2079 
2080     Returns \c true if this time is later than or equal to \a t;
2081     otherwise returns \c false.
2082 */
2083 
2084 /*!
2085     \fn QTime QTime::fromMSecsSinceStartOfDay(int msecs)
2086 
2087     Returns a new QTime instance with the time set to the number of \a msecs
2088     since the start of the day, i.e. since 00:00:00.
2089 
2090     If \a msecs falls outside the valid range an invalid QTime will be returned.
2091 
2092     \sa msecsSinceStartOfDay()
2093 */
2094 
2095 /*!
2096     \fn int QTime::msecsSinceStartOfDay() const
2097 
2098     Returns the number of msecs since the start of the day, i.e. since 00:00:00.
2099 
2100     \sa fromMSecsSinceStartOfDay()
2101 */
2102 
2103 /*!
2104     \fn QTime::currentTime()
2105 
2106     Returns the current time as reported by the system clock.
2107 
2108     Note that the accuracy depends on the accuracy of the underlying
2109     operating system; not all systems provide 1-millisecond accuracy.
2110 
2111     Furthermore, currentTime() only increases within each day; it shall drop by
2112     24 hours each time midnight passes; and, beside this, changes in it may not
2113     correspond to elapsed time, if a daylight-saving transition intervenes.
2114 
2115     \sa QDateTime::currentDateTime(), QDateTime::currentDateTimeUtc()
2116 */
2117 
2118 #if QT_CONFIG(datestring) // depends on, so implies, textdate
2119 
2120 static QTime fromIsoTimeString(QStringView string, Qt::DateFormat format, bool *isMidnight24)
2121 {
2122     if (isMidnight24)
2123         *isMidnight24 = false;
2124 
2125     const int size = string.size();
2126     if (size < 5 || string.at(2) != QLatin1Char(':'))
2127         return QTime();
2128 
2129     ParsedInt hour = readInt(string.mid(0, 2));
2130     ParsedInt minute = readInt(string.mid(3, 2));
2131     if (!hour.ok || !minute.ok)
2132         return QTime();
2133     // FIXME: ISO 8601 allows [,.]\d+ after hour, just as it does after minute
2134 
2135     int second = 0;
2136     int msec = 0;
2137 
2138     if (size == 5) {
2139         // HH:mm format
2140         second = 0;
2141         msec = 0;
2142     } else if (string.at(5) == QLatin1Char(',') || string.at(5) == QLatin1Char('.')) {
2143         if (format == Qt::TextDate)
2144             return QTime();
2145         // ISODate HH:mm.ssssss format
2146         // We only want 5 digits worth of fraction of minute. This follows the existing
2147         // behavior that determines how milliseconds are read; 4 millisecond digits are
2148         // read and then rounded to 3. If we read at most 5 digits for fraction of minute,
2149         // the maximum amount of millisecond digits it will expand to once converted to
2150         // seconds is 4. E.g. 12:34,99999 will expand to 12:34:59.9994. The milliseconds
2151         // will then be rounded up AND clamped to 999.
2152 
2153         const QStringView minuteFractionStr = string.mid(6, qMin(qsizetype(5), string.size() - 6));
2154         const ParsedInt parsed = readInt(minuteFractionStr);
2155         if (!parsed.ok)
2156             return QTime();
2157         const float secondWithMs
2158             = double(parsed.value) * 60 / (std::pow(double(10), minuteFractionStr.size()));
2159 
2160         second = std::floor(secondWithMs);
2161         const float secondFraction = secondWithMs - second;
2162         msec = qMin(qRound(secondFraction * 1000.0), 999);
2163     } else if (string.at(5) == QLatin1Char(':')) {
2164         // HH:mm:ss or HH:mm:ss.zzz
2165         const ParsedInt parsed = readInt(string.mid(6, qMin(qsizetype(2), string.size() - 6)));
2166         if (!parsed.ok)
2167             return QTime();
2168         second = parsed.value;
2169         if (size <= 8) {
2170             // No fractional part to read
2171         } else if (string.at(8) == QLatin1Char(',') || string.at(8) == QLatin1Char('.')) {
2172             QStringView msecStr(string.mid(9, qMin(qsizetype(4), string.size() - 9)));
2173             bool ok = true;
2174             // Can't use readInt() here, as we *do* allow trailing space - but not leading:
2175             if (!msecStr.isEmpty() && !msecStr.at(0).isDigit())
2176                 return QTime();
2177             msecStr = msecStr.trimmed();
2178             int msecInt = msecStr.isEmpty() ? 0 : QLocale::c().toInt(msecStr, &ok);
2179             if (!ok)
2180                 return QTime();
2181             const double secondFraction(msecInt / (std::pow(double(10), msecStr.size())));
2182             msec = qMin(qRound(secondFraction * 1000.0), 999);
2183         } else {
2184 #if QT_VERSION >= QT_VERSION_CHECK(6,0,0) // behavior change
2185             // Stray cruft after date-time: tolerate trailing space, but nothing else.
2186             for (const auto &ch : string.mid(8)) {
2187                 if (!ch.isSpace())
2188                     return QTime();
2189             }
2190 #endif
2191         }
2192     } else {
2193         return QTime();
2194     }
2195 
2196     const bool isISODate = format == Qt::ISODate || format == Qt::ISODateWithMs;
2197     if (isISODate && hour.value == 24 && minute.value == 0 && second == 0 && msec == 0) {
2198         if (isMidnight24)
2199             *isMidnight24 = true;
2200         hour.value = 0;
2201     }
2202 
2203     return QTime(hour.value, minute.value, second, msec);
2204 }
2205 
2206 /*!
2207     Returns the time represented in the \a string as a QTime using the
2208     \a format given, or an invalid time if this is not possible.
2209 
2210     \sa toString(), QLocale::toTime()
2211 */
2212 QTime QTime::fromString(const QString &string, Qt::DateFormat format)
2213 {
2214     if (string.isEmpty())
2215         return QTime();
2216 
2217     switch (format) {
2218     case Qt::RFC2822Date:
2219         return rfcDateImpl(string).time;
2220     case Qt::ISODate:
2221     case Qt::ISODateWithMs:
2222     case Qt::TextDate:
2223     default:
2224         return fromIsoTimeString(QStringView(string), format, nullptr);
2225     }
2226 }
2227 
2228 /*!
2229     Returns the QTime represented by the \a string, using the \a
2230     format given, or an invalid time if the string cannot be parsed.
2231 
2232     These expressions may be used for the format:
2233 
2234     \table
2235     \header \li Expression \li Output
2236     \row \li h
2237          \li The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
2238     \row \li hh
2239          \li The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
2240     \row \li H
2241          \li The hour without a leading zero (0 to 23, even with AM/PM display)
2242     \row \li HH
2243          \li The hour with a leading zero (00 to 23, even with AM/PM display)
2244     \row \li m \li The minute without a leading zero (0 to 59)
2245     \row \li mm \li The minute with a leading zero (00 to 59)
2246     \row \li s \li The whole second, without any leading zero (0 to 59)
2247     \row \li ss \li The whole second, with a leading zero where applicable (00 to 59)
2248     \row \li z \li The fractional part of the second, to go after a decimal
2249                 point, without trailing zeroes (0 to 999).  Thus "\c{s.z}"
2250                 reports the seconds to full available (millisecond) precision
2251                 without trailing zeroes.
2252     \row \li zzz \li The fractional part of the second, to millisecond
2253                 precision, including trailing zeroes where applicable (000 to 999).
2254     \row \li AP or A
2255          \li Interpret as an AM/PM time. \e A/AP will match an upper-case
2256              version of either QLocale::amText() or QLocale::pmText().
2257     \row \li ap or a
2258          \li Interpret as an am/pm time. \e a/ap will match a lower-case version
2259              of either QLocale::amText() or QLocale::pmText().
2260     \endtable
2261 
2262     All other input characters will be treated as text. Any non-empty sequence
2263     of characters enclosed in single quotes will also be treated (stripped of
2264     the quotes) as text and not be interpreted as expressions.
2265 
2266     \snippet code/src_corelib_time_qdatetime.cpp 6
2267 
2268     If the format is not satisfied, an invalid QTime is returned.
2269     Expressions that do not expect leading zeroes to be given (h, m, s
2270     and z) are greedy. This means that they will use two digits even if
2271     this puts them outside the range of accepted values and leaves too
2272     few digits for other sections. For example, the following string
2273     could have meant 00:07:10, but the m will grab two digits, resulting
2274     in an invalid time:
2275 
2276     \snippet code/src_corelib_time_qdatetime.cpp 7
2277 
2278     Any field that is not represented in the format will be set to zero.
2279     For example:
2280 
2281     \snippet code/src_corelib_time_qdatetime.cpp 8
2282 
2283     \note If localized forms of am or pm (the AP, ap, A or a formats) are used,
2284     please switch to using QLocale::system().toTime() as QTime methods shall
2285     change to only recognize English (C locale) at Qt 6.
2286 
2287     \sa toString(), QDateTime::fromString(), QDate::fromString(),
2288     QLocale::toTime()
2289 */
2290 
2291 QTime QTime::fromString(const QString &string, const QString &format)
2292 {
2293     QTime time;
2294 #if QT_CONFIG(datetimeparser)
2295     QDateTimeParser dt(QMetaType::QTime, QDateTimeParser::FromString, QCalendar());
2296     dt.setDefaultLocale(QLocale::c());
2297     if (dt.parseFormat(format))
2298         dt.fromString(string, nullptr, &time);
2299 #else
2300     Q_UNUSED(string);
2301     Q_UNUSED(format);
2302 #endif
2303     return time;
2304 }
2305 
2306 #endif // datestring
2307 
2308 
2309 /*!
2310     \overload
2311 
2312     Returns \c true if the specified time is valid; otherwise returns
2313     false.
2314 
2315     The time is valid if \a h is in the range 0 to 23, \a m and
2316     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.
2317 
2318     Example:
2319 
2320     \snippet code/src_corelib_time_qdatetime.cpp 9
2321 */
2322 
2323 bool QTime::isValid(int h, int m, int s, int ms)
2324 {
2325     return (uint)h < 24 && (uint)m < 60 && (uint)s < 60 && (uint)ms < 1000;
2326 }
2327 
2328 /*****************************************************************************
2329   QDateTime static helper functions
2330  *****************************************************************************/
2331 
2332 // get the types from QDateTime (through QDateTimePrivate)
2333 typedef QDateTimePrivate::QDateTimeShortData ShortData;
2334 typedef QDateTimePrivate::QDateTimeData QDateTimeData;
2335 
2336 // Returns the platform variant of timezone, i.e. the standard time offset
2337 // The timezone external variable is documented as always holding the
2338 // Standard Time offset as seconds west of Greenwich, i.e. UTC+01:00 is -3600
2339 // Note this may not be historicaly accurate.
2340 // Relies on tzset, mktime, or localtime having been called to populate timezone
2341 static int qt_timezone()
2342 {
2343 #if defined(_MSC_VER)
2344         long offset;
2345         _get_timezone(&offset);
2346         return offset;
2347 #elif defined(Q_OS_BSD4) && !defined(Q_OS_DARWIN)
2348         time_t clock = time(NULL);
2349         struct tm t;
2350         localtime_r(&clock, &t);
2351         // QTBUG-36080 Workaround for systems without the POSIX timezone
2352         // variable. This solution is not very efficient but fixing it is up to
2353         // the libc implementations.
2354         //
2355         // tm_gmtoff has some important differences compared to the timezone
2356         // variable:
2357         // - It returns the number of seconds east of UTC, and we want the
2358         //   number of seconds west of UTC.
2359         // - It also takes DST into account, so we need to adjust it to always
2360         //   get the Standard Time offset.
2361         return -t.tm_gmtoff + (t.tm_isdst ? (long)SECS_PER_HOUR : 0L);
2362 #elif defined(Q_OS_INTEGRITY) || defined(Q_OS_RTEMS)
2363         return 0;
2364 #else
2365         return timezone;
2366 #endif // Q_OS_WIN
2367 }
2368 
2369 // Returns the tzname, assume tzset has been called already
2370 static QString qt_tzname(QDateTimePrivate::DaylightStatus daylightStatus)
2371 {
2372     int isDst = (daylightStatus == QDateTimePrivate::DaylightTime) ? 1 : 0;
2373 #if defined(Q_CC_MSVC)
2374     size_t s = 0;
2375     char name[512];
2376     if (_get_tzname(&s, name, 512, isDst))
2377         return QString();
2378     return QString::fromLocal8Bit(name);
2379 #else
2380     return QString::fromLocal8Bit(tzname[isDst]);
2381 #endif // Q_OS_WIN
2382 }
2383 
2384 #if QT_CONFIG(datetimeparser)
2385 /*
2386   \internal
2387   Implemented here to share qt_tzname()
2388 */
2389 int QDateTimeParser::startsWithLocalTimeZone(QStringView name)
2390 {
2391     QDateTimePrivate::DaylightStatus zones[2] = {
2392         QDateTimePrivate::StandardTime,
2393         QDateTimePrivate::DaylightTime
2394     };
2395     for (const auto z : zones) {
2396         QString zone(qt_tzname(z));
2397         if (name.startsWith(zone))
2398             return zone.size();
2399     }
2400     return 0;
2401 }
2402 #endif // datetimeparser
2403 
2404 // Calls the platform variant of mktime for the given date, time and daylightStatus,
2405 // and updates the date, time, daylightStatus and abbreviation with the returned values
2406 // If the date falls outside the 1970 to 2037 range supported by mktime / time_t
2407 // then null date/time will be returned, you should adjust the date first if
2408 // you need a guaranteed result.
2409 static qint64 qt_mktime(QDate *date, QTime *time, QDateTimePrivate::DaylightStatus *daylightStatus,
2410                         QString *abbreviation, bool *ok = nullptr)
2411 {
2412     const qint64 msec = time->msec();
2413     int yy, mm, dd;
2414     date->getDate(&yy, &mm, &dd);
2415 
2416     // All other platforms provide standard C library time functions
2417     tm local;
2418     memset(&local, 0, sizeof(local)); // tm_[wy]day plus any non-standard fields
2419     local.tm_sec = time->second();
2420     local.tm_min = time->minute();
2421     local.tm_hour = time->hour();
2422     local.tm_mday = dd;
2423     local.tm_mon = mm - 1;
2424     local.tm_year = yy - 1900;
2425     local.tm_isdst = daylightStatus ? int(*daylightStatus) : -1;
2426 
2427 #if defined(Q_OS_WIN)
2428     int hh = local.tm_hour;
2429 #endif // Q_OS_WIN
2430     time_t secsSinceEpoch = qMkTime(&local);
2431     if (secsSinceEpoch != time_t(-1)) {
2432         *date = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2433         *time = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2434 #if defined(Q_OS_WIN)
2435         // Windows mktime for the missing hour subtracts 1 hour from the time
2436         // instead of adding 1 hour.  If time differs and is standard time then
2437         // this has happened, so add 2 hours to the time and 1 hour to the msecs
2438         if (local.tm_isdst == 0 && local.tm_hour != hh) {
2439             if (time->hour() >= 22)
2440                 *date = date->addDays(1);
2441             *time = time->addSecs(2 * SECS_PER_HOUR);
2442             secsSinceEpoch += SECS_PER_HOUR;
2443             local.tm_isdst = 1;
2444         }
2445 #endif // Q_OS_WIN
2446         if (local.tm_isdst > 0) {
2447             if (daylightStatus)
2448                 *daylightStatus = QDateTimePrivate::DaylightTime;
2449             if (abbreviation)
2450                 *abbreviation = qt_tzname(QDateTimePrivate::DaylightTime);
2451         } else {
2452             if (daylightStatus) {
2453                 *daylightStatus = (local.tm_isdst == 0
2454                                    ? QDateTimePrivate::StandardTime
2455                                    : QDateTimePrivate::UnknownDaylightTime);
2456             }
2457             if (abbreviation)
2458                 *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2459         }
2460     } else if (yy == 1969 && mm == 12 && dd == 31
2461                && time->second() == MSECS_PER_DAY - 1) {
2462         // There was, of course, a last second in 1969, at time_t(-1); we won't
2463         // rescue it if it's not in normalised form, and we don't know its DST
2464         // status (unless we did already), but let's not wantonly declare it
2465         // invalid.
2466     } else {
2467         *date = QDate();
2468         *time = QTime();
2469         if (daylightStatus)
2470             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2471         if (abbreviation)
2472             *abbreviation = QString();
2473         if (ok)
2474             *ok = false;
2475         return 0;
2476     }
2477     if (ok)
2478         *ok = true;
2479 
2480     return qint64(secsSinceEpoch) * 1000 + msec;
2481 }
2482 
2483 // Calls the platform variant of localtime for the given msecs, and updates
2484 // the date, time, and DST status with the returned values.
2485 static bool qt_localtime(qint64 msecsSinceEpoch, QDate *localDate, QTime *localTime,
2486                          QDateTimePrivate::DaylightStatus *daylightStatus)
2487 {
2488     const time_t secsSinceEpoch = msecsSinceEpoch / 1000;
2489     const int msec = msecsSinceEpoch % 1000;
2490 
2491     tm local;
2492     bool valid = false;
2493 
2494     // localtime() is specified to work as if it called tzset().
2495     // localtime_r() does not have this constraint, so make an explicit call.
2496     // The explicit call should also request the timezone info be re-parsed.
2497     qTzSet();
2498 #if QT_CONFIG(thread) && defined(_POSIX_THREAD_SAFE_FUNCTIONS)
2499     // Use the reentrant version of localtime() where available
2500     // as is thread-safe and doesn't use a shared static data area
2501     if (tm *res = localtime_r(&secsSinceEpoch, &local)) {
2502         Q_ASSERT(res == &local);
2503         valid = true;
2504     }
2505 #elif defined(Q_CC_MSVC)
2506     if (!_localtime64_s(&local, &secsSinceEpoch))
2507         valid = true;
2508 #else
2509     // Returns shared static data which may be overwritten at any time
2510     // So copy the result asap
2511     if (tm *res = localtime(&secsSinceEpoch)) {
2512         local = *res;
2513         valid = true;
2514     }
2515 #endif
2516     if (valid) {
2517         *localDate = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2518         *localTime = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2519         if (daylightStatus) {
2520             if (local.tm_isdst > 0)
2521                 *daylightStatus = QDateTimePrivate::DaylightTime;
2522             else if (local.tm_isdst < 0)
2523                 *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2524             else
2525                 *daylightStatus = QDateTimePrivate::StandardTime;
2526         }
2527         return true;
2528     } else {
2529         *localDate = QDate();
2530         *localTime = QTime();
2531         if (daylightStatus)
2532             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2533         return false;
2534     }
2535 }
2536 
2537 // Converts an msecs value into a date and time
2538 static void msecsToTime(qint64 msecs, QDate *date, QTime *time)
2539 {
2540     qint64 jd = JULIAN_DAY_FOR_EPOCH;
2541     qint64 ds = 0;
2542 
2543     if (msecs >= MSECS_PER_DAY || msecs <= -MSECS_PER_DAY) {
2544         jd += msecs / MSECS_PER_DAY;
2545         msecs %= MSECS_PER_DAY;
2546     }
2547 
2548     if (msecs < 0) {
2549         ds = MSECS_PER_DAY - msecs - 1;
2550         jd -= ds / MSECS_PER_DAY;
2551         ds = ds % MSECS_PER_DAY;
2552         ds = MSECS_PER_DAY - ds - 1;
2553     } else {
2554         ds = msecs;
2555     }
2556 
2557     if (date)
2558         *date = QDate::fromJulianDay(jd);
2559     if (time)
2560         *time = QTime::fromMSecsSinceStartOfDay(ds);
2561 }
2562 
2563 // Converts a date/time value into msecs
2564 static qint64 timeToMSecs(QDate date, QTime time)
2565 {
2566     return ((date.toJulianDay() - JULIAN_DAY_FOR_EPOCH) * MSECS_PER_DAY)
2567            + time.msecsSinceStartOfDay();
2568 }
2569 
2570 // Convert an MSecs Since Epoch into Local Time
2571 static bool epochMSecsToLocalTime(qint64 msecs, QDate *localDate, QTime *localTime,
2572                                   QDateTimePrivate::DaylightStatus *daylightStatus = nullptr)
2573 {
2574     if (msecs < 0) {
2575         // Docs state any LocalTime before 1970-01-01 will *not* have any Daylight Time applied
2576         // Instead just use the standard offset from UTC to convert to UTC time
2577         qTzSet();
2578         msecsToTime(msecs - qt_timezone() * 1000, localDate, localTime);
2579         if (daylightStatus)
2580             *daylightStatus = QDateTimePrivate::StandardTime;
2581         return true;
2582     } else if (msecs > (qint64(TIME_T_MAX) * 1000)) {
2583         // Docs state any LocalTime after 2037-12-31 *will* have any DST applied
2584         // but this may fall outside the supported time_t range, so need to fake it.
2585         // Use existing method to fake the conversion, but this is deeply flawed as it may
2586         // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2587         // TODO Use QTimeZone when available to apply the future rule correctly
2588         QDate utcDate;
2589         QTime utcTime;
2590         msecsToTime(msecs, &utcDate, &utcTime);
2591         int year, month, day;
2592         utcDate.getDate(&year, &month, &day);
2593         // 2037 is not a leap year, so make sure date isn't Feb 29
2594         if (month == 2 && day == 29)
2595             --day;
2596         QDate fakeDate(2037, month, day);
2597         qint64 fakeMsecs = QDateTime(fakeDate, utcTime, Qt::UTC).toMSecsSinceEpoch();
2598         bool res = qt_localtime(fakeMsecs, localDate, localTime, daylightStatus);
2599         *localDate = localDate->addDays(fakeDate.daysTo(utcDate));
2600         return res;
2601     } else {
2602         // Falls inside time_t suported range so can use localtime
2603         return qt_localtime(msecs, localDate, localTime, daylightStatus);
2604     }
2605 }
2606 
2607 // Convert a LocalTime expressed in local msecs encoding and the corresponding
2608 // DST status into a UTC epoch msecs. Optionally populate the returned
2609 // values from mktime for the adjusted local date and time.
2610 static qint64 localMSecsToEpochMSecs(qint64 localMsecs,
2611                                      QDateTimePrivate::DaylightStatus *daylightStatus,
2612                                      QDate *localDate = nullptr, QTime *localTime = nullptr,
2613                                      QString *abbreviation = nullptr)
2614 {
2615     QDate dt;
2616     QTime tm;
2617     msecsToTime(localMsecs, &dt, &tm);
2618 
2619     const qint64 msecsMax = qint64(TIME_T_MAX) * 1000;
2620 
2621     if (localMsecs <= qint64(MSECS_PER_DAY)) {
2622 
2623         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
2624 
2625         // First, if localMsecs is within +/- 1 day of minimum time_t try mktime in case it does
2626         // fall after minimum and needs proper DST conversion
2627         if (localMsecs >= -qint64(MSECS_PER_DAY)) {
2628             bool valid;
2629             qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation, &valid);
2630             if (valid && utcMsecs >= 0) {
2631                 // mktime worked and falls in valid range, so use it
2632                 if (localDate)
2633                     *localDate = dt;
2634                 if (localTime)
2635                     *localTime = tm;
2636                 return utcMsecs;
2637             }
2638         } else {
2639             // If we don't call mktime then need to call tzset to get offset
2640             qTzSet();
2641         }
2642         // Time is clearly before 1970-01-01 so just use standard offset to convert
2643         qint64 utcMsecs = localMsecs + qt_timezone() * 1000;
2644         if (localDate || localTime)
2645             msecsToTime(localMsecs, localDate, localTime);
2646         if (daylightStatus)
2647             *daylightStatus = QDateTimePrivate::StandardTime;
2648         if (abbreviation)
2649             *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2650         return utcMsecs;
2651 
2652     } else if (localMsecs >= msecsMax - MSECS_PER_DAY) {
2653 
2654         // Docs state any LocalTime after 2037-12-31 *will* have any DST applied
2655         // but this may fall outside the supported time_t range, so need to fake it.
2656 
2657         // First, if localMsecs is within +/- 1 day of maximum time_t try mktime in case it does
2658         // fall before maximum and can use proper DST conversion
2659         if (localMsecs <= msecsMax + MSECS_PER_DAY) {
2660             bool valid;
2661             qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation, &valid);
2662             if (valid && utcMsecs <= msecsMax) {
2663                 // mktime worked and falls in valid range, so use it
2664                 if (localDate)
2665                     *localDate = dt;
2666                 if (localTime)
2667                     *localTime = tm;
2668                 return utcMsecs;
2669             }
2670         }
2671         // Use existing method to fake the conversion, but this is deeply flawed as it may
2672         // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2673         // TODO Use QTimeZone when available to apply the future rule correctly
2674         int year, month, day;
2675         dt.getDate(&year, &month, &day);
2676         // 2037 is not a leap year, so make sure date isn't Feb 29
2677         if (month == 2 && day == 29)
2678             --day;
2679         QDate fakeDate(2037, month, day);
2680         qint64 fakeDiff = fakeDate.daysTo(dt);
2681         qint64 utcMsecs = qt_mktime(&fakeDate, &tm, daylightStatus, abbreviation);
2682         if (localDate)
2683             *localDate = fakeDate.addDays(fakeDiff);
2684         if (localTime)
2685             *localTime = tm;
2686         QDate utcDate;
2687         QTime utcTime;
2688         msecsToTime(utcMsecs, &utcDate, &utcTime);
2689         utcDate = utcDate.addDays(fakeDiff);
2690         utcMsecs = timeToMSecs(utcDate, utcTime);
2691         return utcMsecs;
2692 
2693     } else {
2694 
2695         // Clearly falls inside 1970-2037 suported range so can use mktime
2696         qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation);
2697         if (localDate)
2698             *localDate = dt;
2699         if (localTime)
2700             *localTime = tm;
2701         return utcMsecs;
2702 
2703     }
2704 }
2705 
2706 static inline bool specCanBeSmall(Qt::TimeSpec spec)
2707 {
2708     return spec == Qt::LocalTime || spec == Qt::UTC;
2709 }
2710 
2711 static inline bool msecsCanBeSmall(qint64 msecs)
2712 {
2713     if (!QDateTimeData::CanBeSmall)
2714         return false;
2715 
2716     ShortData sd;
2717     sd.msecs = qintptr(msecs);
2718     return sd.msecs == msecs;
2719 }
2720 
2721 static Q_DECL_CONSTEXPR inline
2722 QDateTimePrivate::StatusFlags mergeSpec(QDateTimePrivate::StatusFlags status, Qt::TimeSpec spec)
2723 {
2724     return QDateTimePrivate::StatusFlags((status & ~QDateTimePrivate::TimeSpecMask) |
2725                                          (int(spec) << QDateTimePrivate::TimeSpecShift));
2726 }
2727 
2728 static Q_DECL_CONSTEXPR inline Qt::TimeSpec extractSpec(QDateTimePrivate::StatusFlags status)
2729 {
2730     return Qt::TimeSpec((status & QDateTimePrivate::TimeSpecMask) >> QDateTimePrivate::TimeSpecShift);
2731 }
2732 
2733 // Set the Daylight Status if LocalTime set via msecs
2734 static Q_DECL_RELAXED_CONSTEXPR inline QDateTimePrivate::StatusFlags
2735 mergeDaylightStatus(QDateTimePrivate::StatusFlags sf, QDateTimePrivate::DaylightStatus status)
2736 {
2737     sf &= ~QDateTimePrivate::DaylightMask;
2738     if (status == QDateTimePrivate::DaylightTime) {
2739         sf |= QDateTimePrivate::SetToDaylightTime;
2740     } else if (status == QDateTimePrivate::StandardTime) {
2741         sf |= QDateTimePrivate::SetToStandardTime;
2742     }
2743     return sf;
2744 }
2745 
2746 // Get the DST Status if LocalTime set via msecs
2747 static Q_DECL_RELAXED_CONSTEXPR inline
2748 QDateTimePrivate::DaylightStatus extractDaylightStatus(QDateTimePrivate::StatusFlags status)
2749 {
2750     if (status & QDateTimePrivate::SetToDaylightTime)
2751         return QDateTimePrivate::DaylightTime;
2752     if (status & QDateTimePrivate::SetToStandardTime)
2753         return QDateTimePrivate::StandardTime;
2754     return QDateTimePrivate::UnknownDaylightTime;
2755 }
2756 
2757 static inline qint64 getMSecs(const QDateTimeData &d)
2758 {
2759     if (d.isShort()) {
2760         // same as, but producing better code
2761         //return d.data.msecs;
2762         return qintptr(d.d) >> 8;
2763     }
2764     return d->m_msecs;
2765 }
2766 
2767 static inline QDateTimePrivate::StatusFlags getStatus(const QDateTimeData &d)
2768 {
2769     if (d.isShort()) {
2770         // same as, but producing better code
2771         //return StatusFlag(d.data.status);
2772         return QDateTimePrivate::StatusFlag(qintptr(d.d) & 0xFF);
2773     }
2774     return d->m_status;
2775 }
2776 
2777 static inline Qt::TimeSpec getSpec(const QDateTimeData &d)
2778 {
2779     return extractSpec(getStatus(d));
2780 }
2781 
2782 #if QT_CONFIG(timezone)
2783 void QDateTimePrivate::setUtcOffsetByTZ(qint64 atMSecsSinceEpoch)
2784 {
2785     m_offsetFromUtc = m_timeZone.d->offsetFromUtc(atMSecsSinceEpoch);
2786 }
2787 #endif
2788 
2789 // Refresh the LocalTime validity and offset
2790 static void refreshDateTime(QDateTimeData &d)
2791 {
2792     auto status = getStatus(d);
2793     const auto spec = extractSpec(status);
2794     const qint64 msecs = getMSecs(d);
2795     qint64 epochMSecs = 0;
2796     QDate testDate;
2797     QTime testTime;
2798     Q_ASSERT(spec == Qt::TimeZone || spec == Qt::LocalTime);
2799 
2800 #if QT_CONFIG(timezone)
2801     // If not valid time zone then is invalid
2802     if (spec == Qt::TimeZone) {
2803         if (!d->m_timeZone.isValid()) {
2804             status &= ~QDateTimePrivate::ValidDateTime;
2805         } else {
2806             epochMSecs = QDateTimePrivate::zoneMSecsToEpochMSecs(msecs, d->m_timeZone, extractDaylightStatus(status), &testDate, &testTime);
2807             d->setUtcOffsetByTZ(epochMSecs);
2808         }
2809     }
2810 #endif // timezone
2811 
2812     // If not valid date and time then is invalid
2813     if (!(status & QDateTimePrivate::ValidDate) || !(status & QDateTimePrivate::ValidTime)) {
2814         status &= ~QDateTimePrivate::ValidDateTime;
2815         if (status & QDateTimePrivate::ShortData) {
2816             d.data.status = status;
2817         } else {
2818             d->m_status = status;
2819             d->m_offsetFromUtc = 0;
2820         }
2821         return;
2822     }
2823 
2824     // We have a valid date and time and a Qt::LocalTime or Qt::TimeZone that needs calculating
2825     // LocalTime and TimeZone might fall into a "missing" DST transition hour
2826     // Calling toEpochMSecs will adjust the returned date/time if it does
2827     if (spec == Qt::LocalTime) {
2828         auto dstStatus = extractDaylightStatus(status);
2829         epochMSecs = localMSecsToEpochMSecs(msecs, &dstStatus, &testDate, &testTime);
2830         status = mergeDaylightStatus(status, dstStatus);
2831     }
2832     int offsetFromUtc = 0;
2833     if (timeToMSecs(testDate, testTime) == msecs) {
2834         status |= QDateTimePrivate::ValidDateTime;
2835         // Cache the offset to use in offsetFromUtc()
2836         offsetFromUtc = (msecs - epochMSecs) / 1000;
2837     } else {
2838         status &= ~QDateTimePrivate::ValidDateTime;
2839     }
2840 
2841     if (status & QDateTimePrivate::ShortData) {
2842         d.data.status = status;
2843     } else {
2844         d->m_status = status;
2845         d->m_offsetFromUtc = offsetFromUtc;
2846     }
2847 }
2848 
2849 // Check the UTC / offsetFromUTC validity
2850 static void checkValidDateTime(QDateTimeData &d)
2851 {
2852     auto status = getStatus(d);
2853     auto spec = extractSpec(status);
2854     switch (spec) {
2855     case Qt::OffsetFromUTC:
2856     case Qt::UTC:
2857         // for these, a valid date and a valid time imply a valid QDateTime
2858         if ((status & QDateTimePrivate::ValidDate) && (status & QDateTimePrivate::ValidTime))
2859             status |= QDateTimePrivate::ValidDateTime;
2860         else
2861             status &= ~QDateTimePrivate::ValidDateTime;
2862         if (status & QDateTimePrivate::ShortData)
2863             d.data.status = status;
2864         else
2865             d->m_status = status;
2866         break;
2867     case Qt::TimeZone:
2868     case Qt::LocalTime:
2869         // for these, we need to check whether the timezone is valid and whether
2870         // the time is valid in that timezone. Expensive, but no other option.
2871         refreshDateTime(d);
2872         break;
2873     }
2874 }
2875 
2876 static void setTimeSpec(QDateTimeData &d, Qt::TimeSpec spec, int offsetSeconds)
2877 {
2878     auto status = getStatus(d);
2879     status &= ~(QDateTimePrivate::ValidDateTime | QDateTimePrivate::DaylightMask |
2880                 QDateTimePrivate::TimeSpecMask);
2881 
2882     switch (spec) {
2883     case Qt::OffsetFromUTC:
2884         if (offsetSeconds == 0)
2885             spec = Qt::UTC;
2886         break;
2887     case Qt::TimeZone:
2888         qWarning("Using TimeZone in setTimeSpec() is unsupported"); // Use system time zone instead
2889         spec = Qt::LocalTime;
2890         Q_FALLTHROUGH();
2891     case Qt::UTC:
2892     case Qt::LocalTime:
2893         offsetSeconds = 0;
2894         break;
2895     }
2896 
2897     status = mergeSpec(status, spec);
2898     if (d.isShort() && offsetSeconds == 0) {
2899         d.data.status = status;
2900     } else {
2901         d.detach();
2902         d->m_status = status & ~QDateTimePrivate::ShortData;
2903         d->m_offsetFromUtc = offsetSeconds;
2904 #if QT_CONFIG(timezone)
2905         d->m_timeZone = QTimeZone();
2906 #endif // timezone
2907     }
2908 }
2909 
2910 static bool isRepresentable(qint64 days, int ds)
2911 {
2912     using Bounds = std::numeric_limits<qint64>;
2913     constexpr qint64 early = (Bounds::min)() / MSECS_PER_DAY;
2914     constexpr qint64 late = (Bounds::max)() / MSECS_PER_DAY;
2915     // Require min() <= days * MSECS_PER_DAY +ds <= max();
2916     // can assume 0 <= ds < MSECS_PER_DAY (but don't have to)
2917     if (days < early + 1) {
2918         if (ds > 0) {
2919             ++days;
2920             ds -= MSECS_PER_DAY;
2921         }
2922         return days >= early && days * MSECS_PER_DAY - (Bounds::min)() >= -ds;
2923     }
2924     if (days > late - 1) {
2925         if (ds < 0) {
2926             --days;
2927             ds += MSECS_PER_DAY;
2928         }
2929         return days <= late && (Bounds::max)() - days * MSECS_PER_DAY >= ds;
2930     }
2931     return true;
2932 }
2933 
2934 static void setDateTime(QDateTimeData &d, QDate date, QTime time)
2935 {
2936     // If the date is valid and the time is not we set time to 00:00:00
2937     QTime useTime = time;
2938     if (!useTime.isValid() && date.isValid())
2939         useTime = QTime::fromMSecsSinceStartOfDay(0);
2940 
2941     QDateTimePrivate::StatusFlags newStatus = { };
2942 
2943     // Set date value and status
2944     qint64 days = 0;
2945     if (date.isValid()) {
2946         days = date.toJulianDay() - JULIAN_DAY_FOR_EPOCH;
2947         newStatus = QDateTimePrivate::ValidDate;
2948     }
2949 
2950     // Set time value and status
2951     int ds = 0;
2952     if (useTime.isValid()) {
2953         ds = useTime.msecsSinceStartOfDay();
2954         newStatus |= QDateTimePrivate::ValidTime;
2955     }
2956 
2957     // Check in representable range:
2958     qint64 msecs = 0;
2959     if (!isRepresentable(days, ds)) {
2960         newStatus = QDateTimePrivate::StatusFlags{};
2961     } else {
2962         // Set msecs serial value
2963         msecs = days * MSECS_PER_DAY + ds;
2964         if (d.isShort()) {
2965             // let's see if we can keep this short
2966             if (msecsCanBeSmall(msecs)) {
2967                 // yes, we can
2968                 d.data.msecs = qintptr(msecs);
2969                 d.data.status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
2970                 d.data.status |= newStatus;
2971             } else {
2972                 // nope...
2973                 d.detach();
2974             }
2975         }
2976     }
2977 
2978     if (!d.isShort()) {
2979         d.detach();
2980         d->m_msecs = msecs;
2981         d->m_status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
2982         d->m_status |= newStatus;
2983     }
2984 
2985     // Set if date and time are valid
2986     checkValidDateTime(d);
2987 }
2988 
2989 static QPair<QDate, QTime> getDateTime(const QDateTimeData &d)
2990 {
2991     QPair<QDate, QTime> result;
2992     qint64 msecs = getMSecs(d);
2993     auto status = getStatus(d);
2994     msecsToTime(msecs, &result.first, &result.second);
2995 
2996     if (!status.testFlag(QDateTimePrivate::ValidDate))
2997         result.first = QDate();
2998 
2999     if (!status.testFlag(QDateTimePrivate::ValidTime))
3000         result.second = QTime();
3001 
3002     return result;
3003 }
3004 
3005 /*****************************************************************************
3006   QDateTime::Data member functions
3007  *****************************************************************************/
3008 
3009 inline QDateTime::Data::Data()
3010 {
3011     // default-constructed data has a special exception:
3012     // it can be small even if CanBeSmall == false
3013     // (optimization so we don't allocate memory in the default constructor)
3014     quintptr value = quintptr(mergeSpec(QDateTimePrivate::ShortData, Qt::LocalTime));
3015     d = reinterpret_cast<QDateTimePrivate *>(value);
3016 }
3017 
3018 inline QDateTime::Data::Data(Qt::TimeSpec spec)
3019 {
3020     if (CanBeSmall && Q_LIKELY(specCanBeSmall(spec))) {
3021         d = reinterpret_cast<QDateTimePrivate *>(quintptr(mergeSpec(QDateTimePrivate::ShortData, spec)));
3022     } else {
3023         // the structure is too small, we need to detach
3024         d = new QDateTimePrivate;
3025         d->ref.ref();
3026         d->m_status = mergeSpec({}, spec);
3027     }
3028 }
3029 
3030 inline QDateTime::Data::Data(const Data &other)
3031     : d(other.d)
3032 {
3033     if (!isShort()) {
3034         // check if we could shrink
3035         if (specCanBeSmall(extractSpec(d->m_status)) && msecsCanBeSmall(d->m_msecs)) {
3036             ShortData sd;
3037             sd.msecs = qintptr(d->m_msecs);
3038             sd.status = d->m_status | QDateTimePrivate::ShortData;
3039             data = sd;
3040         } else {
3041             // no, have to keep it big
3042             d->ref.ref();
3043         }
3044     }
3045 }
3046 
3047 inline QDateTime::Data::Data(Data &&other)
3048     : d(other.d)
3049 {
3050     // reset the other to a short state
3051     Data dummy;
3052     Q_ASSERT(dummy.isShort());
3053     other.d = dummy.d;
3054 }
3055 
3056 inline QDateTime::Data &QDateTime::Data::operator=(const Data &other)
3057 {
3058     if (d == other.d)
3059         return *this;
3060 
3061     auto x = d;
3062     d = other.d;
3063     if (!other.isShort()) {
3064         // check if we could shrink
3065         if (specCanBeSmall(extractSpec(other.d->m_status)) && msecsCanBeSmall(other.d->m_msecs)) {
3066             ShortData sd;
3067             sd.msecs = qintptr(other.d->m_msecs);
3068             sd.status = other.d->m_status | QDateTimePrivate::ShortData;
3069             data = sd;
3070         } else {
3071             // no, have to keep it big
3072             other.d->ref.ref();
3073         }
3074     }
3075 
3076     if (!(quintptr(x) & QDateTimePrivate::ShortData) && !x->ref.deref())
3077         delete x;
3078     return *this;
3079 }
3080 
3081 inline QDateTime::Data::~Data()
3082 {
3083     if (!isShort() && !d->ref.deref())
3084         delete d;
3085 }
3086 
3087 inline bool QDateTime::Data::isShort() const
3088 {
3089     bool b = quintptr(d) & QDateTimePrivate::ShortData;
3090 
3091     // sanity check:
3092     Q_ASSERT(b || (d->m_status & QDateTimePrivate::ShortData) == 0);
3093 
3094     // even if CanBeSmall = false, we have short data for a default-constructed
3095     // QDateTime object. But it's unlikely.
3096     if (CanBeSmall)
3097         return Q_LIKELY(b);
3098     return Q_UNLIKELY(b);
3099 }
3100 
3101 inline void QDateTime::Data::detach()
3102 {
3103     QDateTimePrivate *x;
3104     bool wasShort = isShort();
3105     if (wasShort) {
3106         // force enlarging
3107         x = new QDateTimePrivate;
3108         x->m_status = QDateTimePrivate::StatusFlag(data.status & ~QDateTimePrivate::ShortData);
3109         x->m_msecs = data.msecs;
3110     } else {
3111         if (d->ref.loadRelaxed() == 1)
3112             return;
3113 
3114         x = new QDateTimePrivate(*d);
3115     }
3116 
3117     x->ref.storeRelaxed(1);
3118     if (!wasShort && !d->ref.deref())
3119         delete d;
3120     d = x;
3121 }
3122 
3123 inline const QDateTimePrivate *QDateTime::Data::operator->() const
3124 {
3125     Q_ASSERT(!isShort());
3126     return d;
3127 }
3128 
3129 inline QDateTimePrivate *QDateTime::Data::operator->()
3130 {
3131     // should we attempt to detach here?
3132     Q_ASSERT(!isShort());
3133     Q_ASSERT(d->ref.loadRelaxed() == 1);
3134     return d;
3135 }
3136 
3137 /*****************************************************************************
3138   QDateTimePrivate member functions
3139  *****************************************************************************/
3140 
3141 Q_NEVER_INLINE
3142 QDateTime::Data QDateTimePrivate::create(QDate toDate, QTime toTime, Qt::TimeSpec toSpec,
3143                                          int offsetSeconds)
3144 {
3145     QDateTime::Data result(toSpec);
3146     setTimeSpec(result, toSpec, offsetSeconds);
3147     setDateTime(result, toDate, toTime);
3148     return result;
3149 }
3150 
3151 #if QT_CONFIG(timezone)
3152 inline QDateTime::Data QDateTimePrivate::create(QDate toDate, QTime toTime,
3153                                                 const QTimeZone &toTimeZone)
3154 {
3155     QDateTime::Data result(Qt::TimeZone);
3156     Q_ASSERT(!result.isShort());
3157 
3158     result.d->m_status = mergeSpec(result.d->m_status, Qt::TimeZone);
3159     result.d->m_timeZone = toTimeZone;
3160     setDateTime(result, toDate, toTime);
3161     return result;
3162 }
3163 
3164 // Convert a TimeZone time expressed in zone msecs encoding into a UTC epoch msecs
3165 // DST transitions are disambiguated by hint.
3166 inline qint64 QDateTimePrivate::zoneMSecsToEpochMSecs(qint64 zoneMSecs, const QTimeZone &zone,
3167                                                       DaylightStatus hint,
3168                                                       QDate *zoneDate, QTime *zoneTime)
3169 {
3170     Q_ASSERT(zone.isValid());
3171     // Get the effective data from QTimeZone
3172     QTimeZonePrivate::Data data = zone.d->dataForLocalTime(zoneMSecs, int(hint));
3173     // Docs state any time before 1970-01-01 will *not* have any DST applied
3174     // but all affected times afterwards will have DST applied.
3175     if (data.atMSecsSinceEpoch < 0) {
3176         msecsToTime(zoneMSecs, zoneDate, zoneTime);
3177         return zoneMSecs - data.standardTimeOffset * 1000;
3178     } else {
3179         msecsToTime(data.atMSecsSinceEpoch + data.offsetFromUtc * 1000, zoneDate, zoneTime);
3180         return data.atMSecsSinceEpoch;
3181     }
3182 }
3183 #endif // timezone
3184 
3185 /*****************************************************************************
3186   QDateTime member functions
3187  *****************************************************************************/
3188 
3189 /*!
3190     \class QDateTime
3191     \inmodule QtCore
3192     \ingroup shared
3193     \reentrant
3194     \brief The QDateTime class provides date and time functions.
3195 
3196 
3197     A QDateTime object encodes a calendar date and a clock time (a
3198     "datetime"). It combines features of the QDate and QTime classes.
3199     It can read the current datetime from the system clock. It
3200     provides functions for comparing datetimes and for manipulating a
3201     datetime by adding a number of seconds, days, months, or years.
3202 
3203     QDateTime can describe datetimes with respect to \l{Qt::LocalTime}{local
3204     time}, to \l{Qt::UTC}{UTC}, to a specified \l{Qt::OffsetFromUTC}{offset from
3205     UTC} or to a specified \l{Qt::TimeZone}{time zone}, in conjunction with the
3206     QTimeZone class. For example, a time zone of "Europe/Berlin" will apply the
3207     daylight-saving rules as used in Germany since 1970. In contrast, an offset
3208     from UTC of +3600 seconds is one hour ahead of UTC (usually written in ISO
3209     standard notation as "UTC+01:00"), with no daylight-saving offset or
3210     changes. When using either local time or a specified time zone, time-zone
3211     transitions such as the starts and ends of daylight-saving time (DST; but
3212     see below) are taken into account. The choice of system used to represent a
3213     datetime is described as its "timespec".
3214 
3215     A QDateTime object is typically created either by giving a date and time
3216     explicitly in the constructor, or by using a static function such as
3217     currentDateTime() or fromMSecsSinceEpoch(). The date and time can be changed
3218     with setDate() and setTime(). A datetime can also be set using the
3219     setMSecsSinceEpoch() function that takes the time, in milliseconds, since
3220     00:00:00 on January 1, 1970. The fromString() function returns a QDateTime,
3221     given a string and a date format used to interpret the date within the
3222     string.
3223 
3224     QDateTime::currentDateTime() returns a QDateTime that expresses the current
3225     time with respect to local time. QDateTime::currentDateTimeUtc() returns a
3226     QDateTime that expresses the current time with respect to UTC.
3227 
3228     The date() and time() functions provide access to the date and
3229     time parts of the datetime. The same information is provided in
3230     textual format by the toString() function.
3231 
3232     QDateTime provides a full set of operators to compare two
3233     QDateTime objects, where smaller means earlier and larger means
3234     later.
3235 
3236     You can increment (or decrement) a datetime by a given number of
3237     milliseconds using addMSecs(), seconds using addSecs(), or days using
3238     addDays(). Similarly, you can use addMonths() and addYears(). The daysTo()
3239     function returns the number of days between two datetimes, secsTo() returns
3240     the number of seconds between two datetimes, and msecsTo() returns the
3241     number of milliseconds between two datetimes. These operations are aware of
3242     daylight-saving time (DST) and other time-zone transitions, where
3243     applicable.
3244 
3245     Use toTimeSpec() to express a datetime in local time or UTC,
3246     toOffsetFromUtc() to express in terms of an offset from UTC, or toTimeZone()
3247     to express it with respect to a general time zone. You can use timeSpec() to
3248     find out what time-spec a QDateTime object stores its time relative to. When
3249     that is Qt::TimeZone, you can use timeZone() to find out which zone it is
3250     using.
3251 
3252     \note QDateTime does not account for leap seconds.
3253 
3254     \section1 Remarks
3255 
3256     \note All conversion to and from string formats is done using the C locale.
3257     For localized conversions, see QLocale.
3258 
3259     \note There is no year 0 in the Gregorian calendar. Dates in that year are
3260     considered invalid. The year -1 is the year "1 before Christ" or "1 before
3261     common era." The day before 1 January 1 CE is 31 December 1 BCE.
3262 
3263     \section2 Range of Valid Dates
3264 
3265     The range of values that QDateTime can represent is dependent on the
3266     internal storage implementation. QDateTime is currently stored in a qint64
3267     as a serial msecs value encoding the date and time. This restricts the date
3268     range to about +/- 292 million years, compared to the QDate range of +/- 2
3269     billion years. Care must be taken when creating a QDateTime with extreme
3270     values that you do not overflow the storage. The exact range of supported
3271     values varies depending on the Qt::TimeSpec and time zone.
3272 
3273     \section2 Use of Timezones
3274 
3275     QDateTime uses the system's time zone information to determine the current
3276     local time zone and its offset from UTC. If the system is not configured
3277     correctly or not up-to-date, QDateTime will give wrong results.
3278 
3279     QDateTime likewise uses system-provided information to determine the offsets
3280     of other timezones from UTC. If this information is incomplete or out of
3281     date, QDateTime will give wrong results. See the QTimeZone documentation for
3282     more details.
3283 
3284     On modern Unix systems, this means QDateTime usually has accurate
3285     information about historical transitions (including DST, see below) whenever
3286     possible. On Windows, where the system doesn't support historical timezone
3287     data, historical accuracy is not maintained with respect to timezone
3288     transitions, notably including DST.
3289 
3290     \section2 Daylight-Saving Time (DST)
3291 
3292     QDateTime takes into account transitions between Standard Time and
3293     Daylight-Saving Time. For example, if the transition is at 2am and the clock
3294     goes forward to 3am, then there is a "missing" hour from 02:00:00 to
3295     02:59:59.999 which QDateTime considers to be invalid. Any date arithmetic
3296     performed will take this missing hour into account and return a valid
3297     result. For example, adding one minute to 01:59:59 will get 03:00:00.
3298 
3299     The range of valid dates taking DST into account is 1970-01-01 to the
3300     present, and rules are in place for handling DST correctly until 2037-12-31,
3301     but these could change. For dates after 2037, QDateTime makes a \e{best
3302     guess} using the rules for year 2037, but we can't guarantee accuracy;
3303     indeed, for \e{any} future date, the time-zone may change its rules before
3304     that date comes around. For dates before 1970, QDateTime doesn't take DST
3305     changes into account, even if the system's time zone database provides that
3306     information, although it does take into account changes to the time-zone's
3307     standard offset, where this information is available.
3308 
3309     \section2 Offsets From UTC
3310 
3311     There is no explicit size restriction on an offset from UTC, but there is an
3312     implicit limit imposed when using the toString() and fromString() methods
3313     which use a [+|-]hh:mm format, effectively limiting the range to +/- 99
3314     hours and 59 minutes and whole minutes only. Note that currently no time
3315     zone lies outside the range of +/- 14 hours.
3316 
3317     \sa QDate, QTime, QDateTimeEdit, QTimeZone
3318 */
3319 
3320 /*!
3321     \since 5.14
3322     \enum QDateTime::YearRange
3323 
3324     This enumerated type describes the range of years (in the Gregorian
3325     calendar) representable by QDateTime:
3326 
3327     \value First The later parts of this year are representable
3328     \value Last The earlier parts of this year are representable
3329 
3330     All dates strictly between these two years are also representable.
3331     Note, however, that the Gregorian Calendar has no year zero.
3332 
3333     \note QDate can describe dates in a wider range of years.  For most
3334     purposes, this makes little difference, as the range of years that QDateTime
3335     can support reaches 292 million years either side of 1970.
3336 
3337     \sa isValid(), QDate
3338 */
3339 
3340 /*!
3341     Constructs a null datetime (i.e. null date and null time). A null
3342     datetime is invalid, since the date is invalid.
3343 
3344     \sa isValid()
3345 */
3346 QDateTime::QDateTime() noexcept(Data::CanBeSmall)
3347 {
3348 }
3349 
3350 /*!
3351     Constructs a datetime with the given \a date and \a time, using
3352     the time specification defined by \a spec and \a offsetSeconds seconds.
3353 
3354     If \a date is valid and \a time is not, the time will be set to midnight.
3355 
3356     If the \a spec is not Qt::OffsetFromUTC then \a offsetSeconds will be ignored.
3357 
3358     If the \a spec is Qt::OffsetFromUTC and \a offsetSeconds is 0 then the
3359     timeSpec() will be set to Qt::UTC, i.e. an offset of 0 seconds.
3360 
3361     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3362     i.e. the current system time zone.  To create a Qt::TimeZone datetime
3363     use the correct constructor.
3364 */
3365 
3366 QDateTime::QDateTime(QDate date, QTime time, Qt::TimeSpec spec, int offsetSeconds)
3367          : d(QDateTimePrivate::create(date, time, spec, offsetSeconds))
3368 {
3369 }
3370 
3371 #if QT_CONFIG(timezone)
3372 /*!
3373     \since 5.2
3374 
3375     Constructs a datetime with the given \a date and \a time, using
3376     the Time Zone specified by \a timeZone.
3377 
3378     If \a date is valid and \a time is not, the time will be set to 00:00:00.
3379 
3380     If \a timeZone is invalid then the datetime will be invalid.
3381 */
3382 
3383 QDateTime::QDateTime(QDate date, QTime time, const QTimeZone &timeZone)
3384     : d(QDateTimePrivate::create(date, time, timeZone))
3385 {
3386 }
3387 #endif // timezone
3388 
3389 /*!
3390     Constructs a copy of the \a other datetime.
3391 */
3392 QDateTime::QDateTime(const QDateTime &other) noexcept
3393     : d(other.d)
3394 {
3395 }
3396 
3397 /*!
3398     \since 5.8
3399     Moves the content of the temporary \a other datetime to this object and
3400     leaves \a other in an unspecified (but proper) state.
3401 */
3402 QDateTime::QDateTime(QDateTime &&other) noexcept
3403     : d(std::move(other.d))
3404 {
3405 }
3406 
3407 /*!
3408     Destroys the datetime.
3409 */
3410 QDateTime::~QDateTime()
3411 {
3412 }
3413 
3414 /*!
3415     Makes a copy of the \a other datetime and returns a reference to the
3416     copy.
3417 */
3418 
3419 QDateTime &QDateTime::operator=(const QDateTime &other) noexcept
3420 {
3421     d = other.d;
3422     return *this;
3423 }
3424 /*!
3425     \fn void QDateTime::swap(QDateTime &other)
3426     \since 5.0
3427 
3428     Swaps this datetime with \a other. This operation is very fast
3429     and never fails.
3430 */
3431 
3432 /*!
3433     Returns \c true if both the date and the time are null; otherwise
3434     returns \c false. A null datetime is invalid.
3435 
3436     \sa QDate::isNull(), QTime::isNull(), isValid()
3437 */
3438 
3439 bool QDateTime::isNull() const
3440 {
3441     auto status = getStatus(d);
3442     return !status.testFlag(QDateTimePrivate::ValidDate) &&
3443             !status.testFlag(QDateTimePrivate::ValidTime);
3444 }
3445 
3446 /*!
3447     Returns \c true if both the date and the time are valid and they are valid in
3448     the current Qt::TimeSpec, otherwise returns \c false.
3449 
3450     If the timeSpec() is Qt::LocalTime or Qt::TimeZone then the date and time are
3451     checked to see if they fall in the Standard Time to Daylight-Saving Time transition
3452     hour, i.e. if the transition is at 2am and the clock goes forward to 3am
3453     then the time from 02:00:00 to 02:59:59.999 is considered to be invalid.
3454 
3455     \sa QDateTime::YearRange, QDate::isValid(), QTime::isValid()
3456 */
3457 
3458 bool QDateTime::isValid() const
3459 {
3460     auto status = getStatus(d);
3461     return status & QDateTimePrivate::ValidDateTime;
3462 }
3463 
3464 /*!
3465     Returns the date part of the datetime.
3466 
3467     \sa setDate(), time(), timeSpec()
3468 */
3469 
3470 QDate QDateTime::date() const
3471 {
3472     auto status = getStatus(d);
3473     if (!status.testFlag(QDateTimePrivate::ValidDate))
3474         return QDate();
3475     QDate dt;
3476     msecsToTime(getMSecs(d), &dt, nullptr);
3477     return dt;
3478 }
3479 
3480 /*!
3481     Returns the time part of the datetime.
3482 
3483     \sa setTime(), date(), timeSpec()
3484 */
3485 
3486 QTime QDateTime::time() const
3487 {
3488     auto status = getStatus(d);
3489     if (!status.testFlag(QDateTimePrivate::ValidTime))
3490         return QTime();
3491     QTime tm;
3492     msecsToTime(getMSecs(d), nullptr, &tm);
3493     return tm;
3494 }
3495 
3496 /*!
3497     Returns the time specification of the datetime.
3498 
3499     \sa setTimeSpec(), date(), time(), Qt::TimeSpec
3500 */
3501 
3502 Qt::TimeSpec QDateTime::timeSpec() const
3503 {
3504     return getSpec(d);
3505 }
3506 
3507 #if QT_CONFIG(timezone)
3508 /*!
3509     \since 5.2
3510 
3511     Returns the time zone of the datetime.
3512 
3513     If the timeSpec() is Qt::LocalTime then an instance of the current system
3514     time zone will be returned. Note however that if you copy this time zone
3515     the instance will not remain in sync if the system time zone changes.
3516 
3517     \sa setTimeZone(), Qt::TimeSpec
3518 */
3519 
3520 QTimeZone QDateTime::timeZone() const
3521 {
3522     switch (getSpec(d)) {
3523     case Qt::UTC:
3524         return QTimeZone::utc();
3525     case Qt::OffsetFromUTC:
3526         return QTimeZone(d->m_offsetFromUtc);
3527     case Qt::TimeZone:
3528         if (d->m_timeZone.isValid())
3529             return d->m_timeZone;
3530         break;
3531     case Qt::LocalTime:
3532         return QTimeZone::systemTimeZone();
3533     }
3534     return QTimeZone();
3535 }
3536 #endif // timezone
3537 
3538 /*!
3539     \since 5.2
3540 
3541     Returns this date-time's Offset From UTC in seconds.
3542 
3543     The result depends on timeSpec():
3544     \list
3545     \li \c Qt::UTC The offset is 0.
3546     \li \c Qt::OffsetFromUTC The offset is the value originally set.
3547     \li \c Qt::LocalTime The local time's offset from UTC is returned.
3548     \li \c Qt::TimeZone The offset used by the time-zone is returned.
3549     \endlist
3550 
3551     For the last two, the offset at this date and time will be returned, taking
3552     account of Daylight-Saving Offset unless the date precedes the start of
3553     1970. The offset is the difference between the local time or time in the
3554     given time-zone and UTC time; it is positive in time-zones ahead of UTC
3555     (East of The Prime Meridian), negative for those behind UTC (West of The
3556     Prime Meridian).
3557 
3558     \sa setOffsetFromUtc()
3559 */
3560 
3561 int QDateTime::offsetFromUtc() const
3562 {
3563     if (!d.isShort())
3564         return d->m_offsetFromUtc;
3565     if (!isValid())
3566         return 0;
3567 
3568     auto spec = getSpec(d);
3569     if (spec == Qt::LocalTime) {
3570         // we didn't cache the value, so we need to calculate it now...
3571         qint64 msecs = getMSecs(d);
3572         return (msecs - toMSecsSinceEpoch()) / 1000;
3573     }
3574 
3575     Q_ASSERT(spec == Qt::UTC);
3576     return 0;
3577 }
3578 
3579 /*!
3580     \since 5.2
3581 
3582     Returns the Time Zone Abbreviation for the datetime.
3583 
3584     If the timeSpec() is Qt::UTC this will be "UTC".
3585 
3586     If the timeSpec() is Qt::OffsetFromUTC this will be in the format
3587     "UTC[+-]00:00".
3588 
3589     If the timeSpec() is Qt::LocalTime then the host system is queried for the
3590     correct abbreviation.
3591 
3592     Note that abbreviations may or may not be localized.
3593 
3594     Note too that the abbreviation is not guaranteed to be a unique value,
3595     i.e. different time zones may have the same abbreviation.
3596 
3597     \sa timeSpec()
3598 */
3599 
3600 QString QDateTime::timeZoneAbbreviation() const
3601 {
3602     if (!isValid())
3603         return QString();
3604 
3605     switch (getSpec(d)) {
3606     case Qt::UTC:
3607         return QLatin1String("UTC");
3608     case Qt::OffsetFromUTC:
3609         return QLatin1String("UTC") + toOffsetString(Qt::ISODate, d->m_offsetFromUtc);
3610     case Qt::TimeZone:
3611 #if !QT_CONFIG(timezone)
3612         break;
3613 #else
3614         Q_ASSERT(d->m_timeZone.isValid());
3615         return d->m_timeZone.d->abbreviation(toMSecsSinceEpoch());
3616 #endif // timezone
3617     case Qt::LocalTime:  {
3618         QString abbrev;
3619         auto status = extractDaylightStatus(getStatus(d));
3620         localMSecsToEpochMSecs(getMSecs(d), &status, nullptr, nullptr, &abbrev);
3621         return abbrev;
3622         }
3623     }
3624     return QString();
3625 }
3626 
3627 /*!
3628     \since 5.2
3629 
3630     Returns if this datetime falls in Daylight-Saving Time.
3631 
3632     If the Qt::TimeSpec is not Qt::LocalTime or Qt::TimeZone then will always
3633     return false.
3634 
3635     \sa timeSpec()
3636 */
3637 
3638 bool QDateTime::isDaylightTime() const
3639 {
3640     if (!isValid())
3641         return false;
3642 
3643     switch (getSpec(d)) {
3644     case Qt::UTC:
3645     case Qt::OffsetFromUTC:
3646         return false;
3647     case Qt::TimeZone:
3648 #if !QT_CONFIG(timezone)
3649         break;
3650 #else
3651         Q_ASSERT(d->m_timeZone.isValid());
3652         return d->m_timeZone.d->isDaylightTime(toMSecsSinceEpoch());
3653 #endif // timezone
3654     case Qt::LocalTime: {
3655         auto status = extractDaylightStatus(getStatus(d));
3656         if (status == QDateTimePrivate::UnknownDaylightTime)
3657             localMSecsToEpochMSecs(getMSecs(d), &status);
3658         return (status == QDateTimePrivate::DaylightTime);
3659         }
3660     }
3661     return false;
3662 }
3663 
3664 /*!
3665     Sets the date part of this datetime to \a date. If no time is set yet, it
3666     is set to midnight. If \a date is invalid, this QDateTime becomes invalid.
3667 
3668     \sa date(), setTime(), setTimeSpec()
3669 */
3670 
3671 void QDateTime::setDate(QDate date)
3672 {
3673     setDateTime(d, date, time());
3674 }
3675 
3676 /*!
3677     Sets the time part of this datetime to \a time. If \a time is not valid,
3678     this function sets it to midnight. Therefore, it's possible to clear any
3679     set time in a QDateTime by setting it to a default QTime:
3680 
3681     \code
3682         QDateTime dt = QDateTime::currentDateTime();
3683         dt.setTime(QTime());
3684     \endcode
3685 
3686     \sa time(), setDate(), setTimeSpec()
3687 */
3688 
3689 void QDateTime::setTime(QTime time)
3690 {
3691     setDateTime(d, date(), time);
3692 }
3693 
3694 /*!
3695     Sets the time specification used in this datetime to \a spec.
3696     The datetime will refer to a different point in time.
3697 
3698     If \a spec is Qt::OffsetFromUTC then the timeSpec() will be set
3699     to Qt::UTC, i.e. an effective offset of 0.
3700 
3701     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3702     i.e. the current system time zone.
3703 
3704     Example:
3705     \snippet code/src_corelib_time_qdatetime.cpp 19
3706 
3707     \sa timeSpec(), setDate(), setTime(), setTimeZone(), Qt::TimeSpec
3708 */
3709 
3710 void QDateTime::setTimeSpec(Qt::TimeSpec spec)
3711 {
3712     QT_PREPEND_NAMESPACE(setTimeSpec(d, spec, 0));
3713     checkValidDateTime(d);
3714 }
3715 
3716 /*!
3717     \since 5.2
3718 
3719     Sets the timeSpec() to Qt::OffsetFromUTC and the offset to \a offsetSeconds.
3720     The datetime will refer to a different point in time.
3721 
3722     The maximum and minimum offset is 14 positive or negative hours.  If
3723     \a offsetSeconds is larger or smaller than that, then the result is
3724     undefined.
3725 
3726     If \a offsetSeconds is 0 then the timeSpec() will be set to Qt::UTC.
3727 
3728     \sa isValid(), offsetFromUtc()
3729 */
3730 
3731 void QDateTime::setOffsetFromUtc(int offsetSeconds)
3732 {
3733     QT_PREPEND_NAMESPACE(setTimeSpec(d, Qt::OffsetFromUTC, offsetSeconds));
3734     checkValidDateTime(d);
3735 }
3736 
3737 #if QT_CONFIG(timezone)
3738 /*!
3739     \since 5.2
3740 
3741     Sets the time zone used in this datetime to \a toZone.
3742     The datetime will refer to a different point in time.
3743 
3744     If \a toZone is invalid then the datetime will be invalid.
3745 
3746     \sa timeZone(), Qt::TimeSpec
3747 */
3748 
3749 void QDateTime::setTimeZone(const QTimeZone &toZone)
3750 {
3751     d.detach();         // always detach
3752     d->m_status = mergeSpec(d->m_status, Qt::TimeZone);
3753     d->m_offsetFromUtc = 0;
3754     d->m_timeZone = toZone;
3755     refreshDateTime(d);
3756 }
3757 #endif // timezone
3758 
3759 /*!
3760     \since 4.7
3761 
3762     Returns the datetime as the number of milliseconds that have passed
3763     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3764 
3765     On systems that do not support time zones, this function will
3766     behave as if local time were Qt::UTC.
3767 
3768     The behavior for this function is undefined if the datetime stored in
3769     this object is not valid. However, for all valid dates, this function
3770     returns a unique value.
3771 
3772     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3773 */
3774 qint64 QDateTime::toMSecsSinceEpoch() const
3775 {
3776     // Note: QDateTimeParser relies on this producing a useful result, even when
3777     // !isValid(), at least when the invalidity is a time in a fall-back (that
3778     // we'll have adjusted to lie outside it, but marked invalid because it's
3779     // not what was asked for). Other things may be doing similar.
3780     switch (getSpec(d)) {
3781     case Qt::UTC:
3782         return getMSecs(d);
3783 
3784     case Qt::OffsetFromUTC:
3785         return d->m_msecs - (d->m_offsetFromUtc * 1000);
3786 
3787     case Qt::LocalTime: {
3788         // recalculate the local timezone
3789         auto status = extractDaylightStatus(getStatus(d));
3790         return localMSecsToEpochMSecs(getMSecs(d), &status);
3791     }
3792 
3793     case Qt::TimeZone:
3794 #if QT_CONFIG(timezone)
3795         if (d->m_timeZone.isValid()) {
3796             return QDateTimePrivate::zoneMSecsToEpochMSecs(d->m_msecs, d->m_timeZone,
3797                                                            extractDaylightStatus(getStatus(d)));
3798         }
3799 #endif
3800         return 0;
3801     }
3802     Q_UNREACHABLE();
3803     return 0;
3804 }
3805 
3806 /*!
3807     \since 5.8
3808 
3809     Returns the datetime as the number of seconds that have passed since
3810     1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3811 
3812     On systems that do not support time zones, this function will
3813     behave as if local time were Qt::UTC.
3814 
3815     The behavior for this function is undefined if the datetime stored in
3816     this object is not valid. However, for all valid dates, this function
3817     returns a unique value.
3818 
3819     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3820 */
3821 qint64 QDateTime::toSecsSinceEpoch() const
3822 {
3823     return toMSecsSinceEpoch() / 1000;
3824 }
3825 
3826 /*!
3827     \since 4.7
3828 
3829     Sets the date and time given the number of milliseconds \a msecs that have
3830     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3831     (Qt::UTC). On systems that do not support time zones this function
3832     will behave as if local time were Qt::UTC.
3833 
3834     Note that passing the minimum of \c qint64
3835     (\c{std::numeric_limits<qint64>::min()}) to \a msecs will result in
3836     undefined behavior.
3837 
3838     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3839 */
3840 void QDateTime::setMSecsSinceEpoch(qint64 msecs)
3841 {
3842     const auto spec = getSpec(d);
3843     auto status = getStatus(d);
3844 
3845     status &= ~QDateTimePrivate::ValidityMask;
3846     switch (spec) {
3847     case Qt::UTC:
3848         status = status
3849                     | QDateTimePrivate::ValidDate
3850                     | QDateTimePrivate::ValidTime
3851                     | QDateTimePrivate::ValidDateTime;
3852         break;
3853     case Qt::OffsetFromUTC:
3854         msecs = msecs + (d->m_offsetFromUtc * 1000);
3855         status = status
3856                     | QDateTimePrivate::ValidDate
3857                     | QDateTimePrivate::ValidTime
3858                     | QDateTimePrivate::ValidDateTime;
3859         break;
3860     case Qt::TimeZone:
3861         Q_ASSERT(!d.isShort());
3862 #if QT_CONFIG(timezone)
3863         d.detach();
3864         if (!d->m_timeZone.isValid())
3865             break;
3866         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
3867         // but all affected times afterwards will have DST applied.
3868         if (msecs >= 0) {
3869             status = mergeDaylightStatus(status,
3870                                          d->m_timeZone.d->isDaylightTime(msecs)
3871                                          ? QDateTimePrivate::DaylightTime
3872                                          : QDateTimePrivate::StandardTime);
3873             d->m_offsetFromUtc = d->m_timeZone.d->offsetFromUtc(msecs);
3874         } else {
3875             status = mergeDaylightStatus(status, QDateTimePrivate::StandardTime);
3876             d->m_offsetFromUtc = d->m_timeZone.d->standardTimeOffset(msecs);
3877         }
3878         {
3879             using Bounds = std::numeric_limits<qint64>;
3880             const qint64 offsetMillis = d->m_offsetFromUtc * 1000;
3881             if (offsetMillis < 0
3882                 ? msecs >= (Bounds::min)() - offsetMillis
3883                 : msecs <= (Bounds::max)() - offsetMillis) {
3884                 msecs += offsetMillis;
3885                 status = status
3886                         | QDateTimePrivate::ValidDate
3887                         | QDateTimePrivate::ValidTime
3888                         | QDateTimePrivate::ValidDateTime;
3889             }
3890         }
3891 #endif // timezone
3892         break;
3893     case Qt::LocalTime: {
3894         QDate dt;
3895         QTime tm;
3896         QDateTimePrivate::DaylightStatus dstStatus;
3897         epochMSecsToLocalTime(msecs, &dt, &tm, &dstStatus);
3898         setDateTime(d, dt, tm);
3899         msecs = getMSecs(d);
3900         status = mergeDaylightStatus(getStatus(d), dstStatus);
3901         break;
3902         }
3903     }
3904 
3905     if (msecsCanBeSmall(msecs) && d.isShort()) {
3906         // we can keep short
3907         d.data.msecs = qintptr(msecs);
3908         d.data.status = status;
3909     } else {
3910         d.detach();
3911         d->m_status = status & ~QDateTimePrivate::ShortData;
3912         d->m_msecs = msecs;
3913     }
3914 
3915     if (spec == Qt::LocalTime || spec == Qt::TimeZone)
3916         refreshDateTime(d);
3917 }
3918 
3919 /*!
3920     \since 5.8
3921 
3922     Sets the date and time given the number of seconds \a secs that have
3923     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3924     (Qt::UTC). On systems that do not support time zones this function
3925     will behave as if local time were Qt::UTC.
3926 
3927     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3928 */
3929 void QDateTime::setSecsSinceEpoch(qint64 secs)
3930 {
3931     setMSecsSinceEpoch(secs * 1000);
3932 }
3933 
3934 #if QT_CONFIG(datestring) // depends on, so implies, textdate
3935 /*!
3936     \overload
3937 
3938     Returns the datetime as a string in the \a format given.
3939 
3940     If the \a format is Qt::TextDate, the string is formatted in the default
3941     way. The day and month names will be in English. An example of this
3942     formatting is "Wed May 20 03:40:13 1998". For localized formatting, see
3943     \l{QLocale::toString()}.
3944 
3945     If the \a format is Qt::ISODate, the string format corresponds
3946     to the ISO 8601 extended specification for representations of
3947     dates and times, taking the form yyyy-MM-ddTHH:mm:ss[Z|[+|-]HH:mm],
3948     depending on the timeSpec() of the QDateTime. If the timeSpec()
3949     is Qt::UTC, Z will be appended to the string; if the timeSpec() is
3950     Qt::OffsetFromUTC, the offset in hours and minutes from UTC will
3951     be appended to the string. To include milliseconds in the ISO 8601
3952     date, use the \a format Qt::ISODateWithMs, which corresponds to
3953     yyyy-MM-ddTHH:mm:ss.zzz[Z|[+|-]HH:mm].
3954 
3955     If the \a format is Qt::RFC2822Date, the string is formatted
3956     following \l{RFC 2822}.
3957 
3958     If the datetime is invalid, an empty string will be returned.
3959 
3960     \warning The Qt::ISODate format is only valid for years in the
3961     range 0 to 9999.
3962 
3963     \sa fromString(), QDate::toString(), QTime::toString(),
3964     QLocale::toString()
3965 */
3966 QString QDateTime::toString(Qt::DateFormat format) const
3967 {
3968     QString buf;
3969     if (!isValid())
3970         return buf;
3971 
3972     switch (format) {
3973     case Qt::RFC2822Date:
3974         buf = QLocale::c().toString(*this, u"dd MMM yyyy hh:mm:ss ");
3975         buf += toOffsetString(Qt::TextDate, offsetFromUtc());
3976         return buf;
3977     default:
3978     case Qt::TextDate: {
3979         const QPair<QDate, QTime> p = getDateTime(d);
3980         buf = toStringTextDate(p.first);
3981         // Insert time between date's day and year:
3982         buf.insert(buf.lastIndexOf(QLatin1Char(' ')),
3983                    QLatin1Char(' ') + p.second.toString(Qt::TextDate));
3984         // Append zone/offset indicator, as appropriate:
3985         switch (timeSpec()) {
3986         case Qt::LocalTime:
3987             break;
3988 #if QT_CONFIG(timezone)
3989         case Qt::TimeZone:
3990             buf += QLatin1Char(' ') + d->m_timeZone.abbreviation(*this);
3991             break;
3992 #endif
3993         default:
3994             buf += QLatin1String(" GMT");
3995             if (getSpec(d) == Qt::OffsetFromUTC)
3996                 buf += toOffsetString(Qt::TextDate, offsetFromUtc());
3997         }
3998         return buf;
3999     }
4000     case Qt::ISODate:
4001     case Qt::ISODateWithMs: {
4002         const QPair<QDate, QTime> p = getDateTime(d);
4003         buf = toStringIsoDate(p.first);
4004         if (buf.isEmpty())
4005             return QString();   // failed to convert
4006         buf += QLatin1Char('T') + p.second.toString(format);
4007         switch (getSpec(d)) {
4008         case Qt::UTC:
4009             buf += QLatin1Char('Z');
4010             break;
4011         case Qt::OffsetFromUTC:
4012 #if QT_CONFIG(timezone)
4013         case Qt::TimeZone:
4014 #endif
4015             buf += toOffsetString(Qt::ISODate, offsetFromUtc());
4016             break;
4017         default:
4018             break;
4019         }
4020         return buf;
4021     }
4022     }
4023 }
4024 
4025 /*!
4026     \fn QString QDateTime::toString(const QString &format, QCalendar cal) const
4027     \fn QString QDateTime::toString(QStringView format, QCalendar cal) const
4028 
4029     Returns the datetime as a string. The \a format parameter determines the
4030     format of the result string. If \a cal is supplied, it determines the calendar
4031     used to represent the date; it defaults to Gregorian. See QTime::toString()
4032     and QDate::toString() for the supported specifiers for time and date,
4033     respectively.
4034 
4035     Any sequence of characters enclosed in single quotes will be included
4036     verbatim in the output string (stripped of the quotes), even if it contains
4037     formatting characters. Two consecutive single quotes ("''") are replaced by
4038     a single quote in the output. All other characters in the format string are
4039     included verbatim in the output string.
4040 
4041     Formats without separators (e.g. "ddMM") are supported but must be used with
4042     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
4043     produces "212" it could mean either the 2nd of December or the 21st of
4044     February).
4045 
4046     Example format strings (assumed that the QDateTime is 21 May 2001
4047     14:13:09.120):
4048 
4049     \table
4050     \header \li Format       \li Result
4051     \row \li dd.MM.yyyy      \li 21.05.2001
4052     \row \li ddd MMMM d yy   \li Tue May 21 01
4053     \row \li hh:mm:ss.zzz    \li 14:13:09.120
4054     \row \li hh:mm:ss.z      \li 14:13:09.12
4055     \row \li h:m:s ap        \li 2:13:9 pm
4056     \endtable
4057 
4058     If the datetime is invalid, an empty string will be returned.
4059 
4060     \note If localized month and day names are desired, please switch to using
4061     QLocale::system().toString() as QDateTime methods shall change to use
4062     English (C locale) names at Qt 6.
4063 
4064     \sa fromString(), QDate::toString(), QTime::toString(), QLocale::toString()
4065 */
4066 QString QDateTime::toString(QStringView format, QCalendar cal) const
4067 {
4068     return QLocale::c().toString(*this, format, cal);
4069 }
4070 
4071 # if QT_STRINGVIEW_LEVEL < 2
4072 QString QDateTime::toString(const QString &format, QCalendar cal) const
4073 {
4074     return toString(qToStringViewIgnoringNull(format), cal);
4075 }
4076 # endif
4077 #endif // datestring
4078 
4079 static inline void massageAdjustedDateTime(const QDateTimeData &d, QDate *date, QTime *time)
4080 {
4081     /*
4082       If we have just adjusted to a day with a DST transition, our given time
4083       may lie in the transition hour (either missing or duplicated).  For any
4084       other time, telling mktime (deep in the bowels of localMSecsToEpochMSecs)
4085       we don't know its DST-ness will produce no adjustment (just a decision as
4086       to its DST-ness); but for a time in spring's missing hour it'll adjust the
4087       time while picking a DST-ness.  (Handling of autumn is trickier, as either
4088       DST-ness is valid, without adjusting the time.  We might want to propagate
4089       the daylight status in that case, but it's hard to do so without breaking
4090       (far more common) other cases; and it makes little difference, as the two
4091       answers do then differ only in DST-ness.)
4092     */
4093     auto spec = getSpec(d);
4094     if (spec == Qt::LocalTime) {
4095         QDateTimePrivate::DaylightStatus status = QDateTimePrivate::UnknownDaylightTime;
4096         localMSecsToEpochMSecs(timeToMSecs(*date, *time), &status, date, time);
4097 #if QT_CONFIG(timezone)
4098     } else if (spec == Qt::TimeZone && d->m_timeZone.isValid()) {
4099         QDateTimePrivate::zoneMSecsToEpochMSecs(timeToMSecs(*date, *time),
4100                                                 d->m_timeZone,
4101                                                 QDateTimePrivate::UnknownDaylightTime,
4102                                                 date, time);
4103 #endif // timezone
4104     }
4105 }
4106 
4107 /*!
4108     Returns a QDateTime object containing a datetime \a ndays days
4109     later than the datetime of this object (or earlier if \a ndays is
4110     negative).
4111 
4112     If the timeSpec() is Qt::LocalTime and the resulting
4113     date and time fall in the Standard Time to Daylight-Saving Time transition
4114     hour then the result will be adjusted accordingly, i.e. if the transition
4115     is at 2am and the clock goes forward to 3am and the result falls between
4116     2am and 3am then the result will be adjusted to fall after 3am.
4117 
4118     \sa daysTo(), addMonths(), addYears(), addSecs()
4119 */
4120 
4121 QDateTime QDateTime::addDays(qint64 ndays) const
4122 {
4123     QDateTime dt(*this);
4124     QPair<QDate, QTime> p = getDateTime(d);
4125     QDate &date = p.first;
4126     QTime &time = p.second;
4127     date = date.addDays(ndays);
4128     massageAdjustedDateTime(dt.d, &date, &time);
4129     setDateTime(dt.d, date, time);
4130     return dt;
4131 }
4132 
4133 /*!
4134     Returns a QDateTime object containing a datetime \a nmonths months
4135     later than the datetime of this object (or earlier if \a nmonths
4136     is negative).
4137 
4138     If the timeSpec() is Qt::LocalTime and the resulting
4139     date and time fall in the Standard Time to Daylight-Saving Time transition
4140     hour then the result will be adjusted accordingly, i.e. if the transition
4141     is at 2am and the clock goes forward to 3am and the result falls between
4142     2am and 3am then the result will be adjusted to fall after 3am.
4143 
4144     \sa daysTo(), addDays(), addYears(), addSecs()
4145 */
4146 
4147 QDateTime QDateTime::addMonths(int nmonths) const
4148 {
4149     QDateTime dt(*this);
4150     QPair<QDate, QTime> p = getDateTime(d);
4151     QDate &date = p.first;
4152     QTime &time = p.second;
4153     date = date.addMonths(nmonths);
4154     massageAdjustedDateTime(dt.d, &date, &time);
4155     setDateTime(dt.d, date, time);
4156     return dt;
4157 }
4158 
4159 /*!
4160     Returns a QDateTime object containing a datetime \a nyears years
4161     later than the datetime of this object (or earlier if \a nyears is
4162     negative).
4163 
4164     If the timeSpec() is Qt::LocalTime and the resulting
4165     date and time fall in the Standard Time to Daylight-Saving Time transition
4166     hour then the result will be adjusted accordingly, i.e. if the transition
4167     is at 2am and the clock goes forward to 3am and the result falls between
4168     2am and 3am then the result will be adjusted to fall after 3am.
4169 
4170     \sa daysTo(), addDays(), addMonths(), addSecs()
4171 */
4172 
4173 QDateTime QDateTime::addYears(int nyears) const
4174 {
4175     QDateTime dt(*this);
4176     QPair<QDate, QTime> p = getDateTime(d);
4177     QDate &date = p.first;
4178     QTime &time = p.second;
4179     date = date.addYears(nyears);
4180     massageAdjustedDateTime(dt.d, &date, &time);
4181     setDateTime(dt.d, date, time);
4182     return dt;
4183 }
4184 
4185 /*!
4186     Returns a QDateTime object containing a datetime \a s seconds
4187     later than the datetime of this object (or earlier if \a s is
4188     negative).
4189 
4190     If this datetime is invalid, an invalid datetime will be returned.
4191 
4192     \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears()
4193 */
4194 
4195 QDateTime QDateTime::addSecs(qint64 s) const
4196 {
4197     return addMSecs(s * 1000);
4198 }
4199 
4200 /*!
4201     Returns a QDateTime object containing a datetime \a msecs miliseconds
4202     later than the datetime of this object (or earlier if \a msecs is
4203     negative).
4204 
4205     If this datetime is invalid, an invalid datetime will be returned.
4206 
4207     \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears()
4208 */
4209 QDateTime QDateTime::addMSecs(qint64 msecs) const
4210 {
4211     if (!isValid())
4212         return QDateTime();
4213 
4214     QDateTime dt(*this);
4215     auto spec = getSpec(d);
4216     if (spec == Qt::LocalTime || spec == Qt::TimeZone) {
4217         // Convert to real UTC first in case crosses DST transition
4218         dt.setMSecsSinceEpoch(toMSecsSinceEpoch() + msecs);
4219     } else {
4220         // No need to convert, just add on
4221         if (d.isShort()) {
4222             // need to check if we need to enlarge first
4223             msecs += dt.d.data.msecs;
4224             if (msecsCanBeSmall(msecs)) {
4225                 dt.d.data.msecs = qintptr(msecs);
4226             } else {
4227                 dt.d.detach();
4228                 dt.d->m_msecs = msecs;
4229             }
4230         } else {
4231             dt.d.detach();
4232             dt.d->m_msecs += msecs;
4233         }
4234     }
4235     return dt;
4236 }
4237 
4238 /*!
4239     Returns the number of days from this datetime to the \a other
4240     datetime. The number of days is counted as the number of times
4241     midnight is reached between this datetime to the \a other
4242     datetime. This means that a 10 minute difference from 23:55 to
4243     0:05 the next day counts as one day.
4244 
4245     If the \a other datetime is earlier than this datetime,
4246     the value returned is negative.
4247 
4248     Example:
4249     \snippet code/src_corelib_time_qdatetime.cpp 15
4250 
4251     \sa addDays(), secsTo(), msecsTo()
4252 */
4253 
4254 qint64 QDateTime::daysTo(const QDateTime &other) const
4255 {
4256     return date().daysTo(other.date());
4257 }
4258 
4259 /*!
4260     Returns the number of seconds from this datetime to the \a other
4261     datetime. If the \a other datetime is earlier than this datetime,
4262     the value returned is negative.
4263 
4264     Before performing the comparison, the two datetimes are converted
4265     to Qt::UTC to ensure that the result is correct if daylight-saving
4266     (DST) applies to one of the two datetimes but not the other.
4267 
4268     Returns 0 if either datetime is invalid.
4269 
4270     Example:
4271     \snippet code/src_corelib_time_qdatetime.cpp 11
4272 
4273     \sa addSecs(), daysTo(), QTime::secsTo()
4274 */
4275 
4276 qint64 QDateTime::secsTo(const QDateTime &other) const
4277 {
4278     return (msecsTo(other) / 1000);
4279 }
4280 
4281 /*!
4282     Returns the number of milliseconds from this datetime to the \a other
4283     datetime. If the \a other datetime is earlier than this datetime,
4284     the value returned is negative.
4285 
4286     Before performing the comparison, the two datetimes are converted
4287     to Qt::UTC to ensure that the result is correct if daylight-saving
4288     (DST) applies to one of the two datetimes and but not the other.
4289 
4290     Returns 0 if either datetime is invalid.
4291 
4292     \sa addMSecs(), daysTo(), QTime::msecsTo()
4293 */
4294 
4295 qint64 QDateTime::msecsTo(const QDateTime &other) const
4296 {
4297     if (!isValid() || !other.isValid())
4298         return 0;
4299 
4300     return other.toMSecsSinceEpoch() - toMSecsSinceEpoch();
4301 }
4302 
4303 /*!
4304     Returns a copy of this datetime converted to the given time
4305     \a spec.
4306 
4307     If \a spec is Qt::OffsetFromUTC then it is set to Qt::UTC.  To set to a
4308     spec of Qt::OffsetFromUTC use toOffsetFromUtc().
4309 
4310     If \a spec is Qt::TimeZone then it is set to Qt::LocalTime,
4311     i.e. the local Time Zone.
4312 
4313     Example:
4314     \snippet code/src_corelib_time_qdatetime.cpp 16
4315 
4316     \sa timeSpec(), toTimeZone(), toOffsetFromUtc()
4317 */
4318 
4319 QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const
4320 {
4321     if (getSpec(d) == spec && (spec == Qt::UTC || spec == Qt::LocalTime))
4322         return *this;
4323 
4324     if (!isValid()) {
4325         QDateTime ret = *this;
4326         ret.setTimeSpec(spec);
4327         return ret;
4328     }
4329 
4330     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), spec, 0);
4331 }
4332 
4333 /*!
4334     \since 5.2
4335 
4336     \fn QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4337 
4338     Returns a copy of this datetime converted to a spec of Qt::OffsetFromUTC
4339     with the given \a offsetSeconds.
4340 
4341     If the \a offsetSeconds equals 0 then a UTC datetime will be returned
4342 
4343     \sa setOffsetFromUtc(), offsetFromUtc(), toTimeSpec()
4344 */
4345 
4346 QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4347 {
4348     if (getSpec(d) == Qt::OffsetFromUTC
4349             && d->m_offsetFromUtc == offsetSeconds)
4350         return *this;
4351 
4352     if (!isValid()) {
4353         QDateTime ret = *this;
4354         ret.setOffsetFromUtc(offsetSeconds);
4355         return ret;
4356     }
4357 
4358     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), Qt::OffsetFromUTC, offsetSeconds);
4359 }
4360 
4361 #if QT_CONFIG(timezone)
4362 /*!
4363     \since 5.2
4364 
4365     Returns a copy of this datetime converted to the given \a timeZone
4366 
4367     \sa timeZone(), toTimeSpec()
4368 */
4369 
4370 QDateTime QDateTime::toTimeZone(const QTimeZone &timeZone) const
4371 {
4372     if (getSpec(d) == Qt::TimeZone && d->m_timeZone == timeZone)
4373         return *this;
4374 
4375     if (!isValid()) {
4376         QDateTime ret = *this;
4377         ret.setTimeZone(timeZone);
4378         return ret;
4379     }
4380 
4381     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), timeZone);
4382 }
4383 #endif // timezone
4384 
4385 /*!
4386     Returns \c true if this datetime is equal to the \a other datetime;
4387     otherwise returns \c false.
4388 
4389     Since 5.14, all invalid datetimes are equal to one another and differ from
4390     all other datetimes.
4391 
4392     \sa operator!=()
4393 */
4394 
4395 bool QDateTime::operator==(const QDateTime &other) const
4396 {
4397     if (!isValid())
4398         return !other.isValid();
4399     if (!other.isValid())
4400         return false;
4401 
4402     if (getSpec(d) == Qt::LocalTime && getStatus(d) == getStatus(other.d))
4403         return getMSecs(d) == getMSecs(other.d);
4404 
4405     // Convert to UTC and compare
4406     return toMSecsSinceEpoch() == other.toMSecsSinceEpoch();
4407 }
4408 
4409 /*!
4410     \fn bool QDateTime::operator!=(const QDateTime &other) const
4411 
4412     Returns \c true if this datetime is different from the \a other
4413     datetime; otherwise returns \c false.
4414 
4415     Two datetimes are different if either the date, the time, or the time zone
4416     components are different. Since 5.14, any invalid datetime is less than all
4417     valid datetimes.
4418 
4419     \sa operator==()
4420 */
4421 
4422 /*!
4423     Returns \c true if this datetime is earlier than the \a other
4424     datetime; otherwise returns \c false.
4425 */
4426 
4427 bool QDateTime::operator<(const QDateTime &other) const
4428 {
4429     if (!isValid())
4430         return other.isValid();
4431     if (!other.isValid())
4432         return false;
4433 
4434     if (getSpec(d) == Qt::LocalTime && getStatus(d) == getStatus(other.d))
4435         return getMSecs(d) < getMSecs(other.d);
4436 
4437     // Convert to UTC and compare
4438     return toMSecsSinceEpoch() < other.toMSecsSinceEpoch();
4439 }
4440 
4441 /*!
4442     \fn bool QDateTime::operator<=(const QDateTime &other) const
4443 
4444     Returns \c true if this datetime is earlier than or equal to the
4445     \a other datetime; otherwise returns \c false.
4446 */
4447 
4448 /*!
4449     \fn bool QDateTime::operator>(const QDateTime &other) const
4450 
4451     Returns \c true if this datetime is later than the \a other datetime;
4452     otherwise returns \c false.
4453 */
4454 
4455 /*!
4456     \fn bool QDateTime::operator>=(const QDateTime &other) const
4457 
4458     Returns \c true if this datetime is later than or equal to the
4459     \a other datetime; otherwise returns \c false.
4460 */
4461 
4462 /*!
4463     \fn QDateTime QDateTime::currentDateTime()
4464     Returns the current datetime, as reported by the system clock, in
4465     the local time zone.
4466 
4467     \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4468 */
4469 
4470 /*!
4471     \fn QDateTime QDateTime::currentDateTimeUtc()
4472     \since 4.7
4473     Returns the current datetime, as reported by the system clock, in
4474     UTC.
4475 
4476     \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4477 */
4478 
4479 /*!
4480     \fn qint64 QDateTime::currentMSecsSinceEpoch()
4481     \since 4.7
4482 
4483     Returns the number of milliseconds since 1970-01-01T00:00:00 Universal
4484     Coordinated Time. This number is like the POSIX time_t variable, but
4485     expressed in milliseconds instead.
4486 
4487     \sa currentDateTime(), currentDateTimeUtc(), toTimeSpec()
4488 */
4489 
4490 /*!
4491     \fn qint64 QDateTime::currentSecsSinceEpoch()
4492     \since 5.8
4493 
4494     Returns the number of seconds since 1970-01-01T00:00:00 Universal
4495     Coordinated Time.
4496 
4497     \sa currentMSecsSinceEpoch()
4498 */
4499 
4500 #if defined(Q_OS_WIN)
4501 static inline uint msecsFromDecomposed(int hour, int minute, int sec, int msec = 0)
4502 {
4503     return MSECS_PER_HOUR * hour + MSECS_PER_MIN * minute + 1000 * sec + msec;
4504 }
4505 
4506 QDate QDate::currentDate()
4507 {
4508     SYSTEMTIME st;
4509     memset(&st, 0, sizeof(SYSTEMTIME));
4510     GetLocalTime(&st);
4511     return QDate(st.wYear, st.wMonth, st.wDay);
4512 }
4513 
4514 QTime QTime::currentTime()
4515 {
4516     QTime ct;
4517     SYSTEMTIME st;
4518     memset(&st, 0, sizeof(SYSTEMTIME));
4519     GetLocalTime(&st);
4520     ct.setHMS(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4521     return ct;
4522 }
4523 
4524 QDateTime QDateTime::currentDateTime()
4525 {
4526     QTime t;
4527     SYSTEMTIME st;
4528     memset(&st, 0, sizeof(SYSTEMTIME));
4529     GetLocalTime(&st);
4530     QDate d(st.wYear, st.wMonth, st.wDay);
4531     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4532     return QDateTime(d, t);
4533 }
4534 
4535 QDateTime QDateTime::currentDateTimeUtc()
4536 {
4537     QTime t;
4538     SYSTEMTIME st;
4539     memset(&st, 0, sizeof(SYSTEMTIME));
4540     GetSystemTime(&st);
4541     QDate d(st.wYear, st.wMonth, st.wDay);
4542     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4543     return QDateTime(d, t, Qt::UTC);
4544 }
4545 
4546 qint64 QDateTime::currentMSecsSinceEpoch() noexcept
4547 {
4548     SYSTEMTIME st;
4549     memset(&st, 0, sizeof(SYSTEMTIME));
4550     GetSystemTime(&st);
4551     const qint64 daysAfterEpoch = QDate(1970, 1, 1).daysTo(QDate(st.wYear, st.wMonth, st.wDay));
4552 
4553     return msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds) +
4554            daysAfterEpoch * Q_INT64_C(86400000);
4555 }
4556 
4557 qint64 QDateTime::currentSecsSinceEpoch() noexcept
4558 {
4559     SYSTEMTIME st;
4560     memset(&st, 0, sizeof(SYSTEMTIME));
4561     GetSystemTime(&st);
4562     const qint64 daysAfterEpoch = QDate(1970, 1, 1).daysTo(QDate(st.wYear, st.wMonth, st.wDay));
4563 
4564     return st.wHour * SECS_PER_HOUR + st.wMinute * SECS_PER_MIN + st.wSecond +
4565            daysAfterEpoch * Q_INT64_C(86400);
4566 }
4567 
4568 #elif defined(Q_OS_UNIX)
4569 QDate QDate::currentDate()
4570 {
4571     return QDateTime::currentDateTime().date();
4572 }
4573 
4574 QTime QTime::currentTime()
4575 {
4576     return QDateTime::currentDateTime().time();
4577 }
4578 
4579 QDateTime QDateTime::currentDateTime()
4580 {
4581     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::LocalTime);
4582 }
4583 
4584 QDateTime QDateTime::currentDateTimeUtc()
4585 {
4586     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::UTC);
4587 }
4588 
4589 qint64 QDateTime::currentMSecsSinceEpoch() noexcept
4590 {
4591     // posix compliant system
4592     // we have milliseconds
4593     struct timeval tv;
4594     gettimeofday(&tv, nullptr);
4595     return qint64(tv.tv_sec) * Q_INT64_C(1000) + tv.tv_usec / 1000;
4596 }
4597 
4598 qint64 QDateTime::currentSecsSinceEpoch() noexcept
4599 {
4600     struct timeval tv;
4601     gettimeofday(&tv, nullptr);
4602     return qint64(tv.tv_sec);
4603 }
4604 #else
4605 #error "What system is this?"
4606 #endif
4607 
4608 /*!
4609   Returns a datetime whose date and time are the number of milliseconds \a msecs
4610   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4611   Time (Qt::UTC) and converted to the given \a spec.
4612 
4613   Note that there are possible values for \a msecs that lie outside the valid
4614   range of QDateTime, both negative and positive. The behavior of this
4615   function is undefined for those values.
4616 
4617   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4618   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4619   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4620 
4621   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4622   i.e. the current system time zone.
4623 
4624   \sa toMSecsSinceEpoch(), setMSecsSinceEpoch()
4625 */
4626 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, Qt::TimeSpec spec, int offsetSeconds)
4627 {
4628     QDateTime dt;
4629     QT_PREPEND_NAMESPACE(setTimeSpec(dt.d, spec, offsetSeconds));
4630     dt.setMSecsSinceEpoch(msecs);
4631     return dt;
4632 }
4633 
4634 /*!
4635   \since 5.8
4636 
4637   Returns a datetime whose date and time are the number of seconds \a secs
4638   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4639   Time (Qt::UTC) and converted to the given \a spec.
4640 
4641   Note that there are possible values for \a secs that lie outside the valid
4642   range of QDateTime, both negative and positive. The behavior of this
4643   function is undefined for those values.
4644 
4645   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4646   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4647   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4648 
4649   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4650   i.e. the current system time zone.
4651 
4652   \sa toSecsSinceEpoch(), setSecsSinceEpoch()
4653 */
4654 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, Qt::TimeSpec spec, int offsetSeconds)
4655 {
4656     constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / 1000;
4657     constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / 1000;
4658     if (secs > maxSeconds || secs < minSeconds)
4659         return QDateTime(); // Would {und,ov}erflow
4660     return fromMSecsSinceEpoch(secs * 1000, spec, offsetSeconds);
4661 }
4662 
4663 #if QT_CONFIG(timezone)
4664 /*!
4665     \since 5.2
4666 
4667     Returns a datetime whose date and time are the number of milliseconds \a msecs
4668     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4669     Time (Qt::UTC) and with the given \a timeZone.
4670 
4671     \sa fromSecsSinceEpoch()
4672 */
4673 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, const QTimeZone &timeZone)
4674 {
4675     QDateTime dt;
4676     dt.setTimeZone(timeZone);
4677     if (timeZone.isValid())
4678         dt.setMSecsSinceEpoch(msecs);
4679     return dt;
4680 }
4681 
4682 /*!
4683     \since 5.8
4684 
4685     Returns a datetime whose date and time are the number of seconds \a secs
4686     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4687     Time (Qt::UTC) and with the given \a timeZone.
4688 
4689     \sa fromMSecsSinceEpoch()
4690 */
4691 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, const QTimeZone &timeZone)
4692 {
4693     constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / 1000;
4694     constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / 1000;
4695     if (secs > maxSeconds || secs < minSeconds)
4696         return QDateTime(); // Would {und,ov}erflow
4697     return fromMSecsSinceEpoch(secs * 1000, timeZone);
4698 }
4699 #endif
4700 
4701 #if QT_CONFIG(datestring) // depends on, so implies, textdate
4702 
4703 /*!
4704     Returns the QDateTime represented by the \a string, using the
4705     \a format given, or an invalid datetime if this is not possible.
4706 
4707     Note for Qt::TextDate: only English short month names (e.g. "Jan" in short
4708     form or "January" in long form) are recognized.
4709 
4710     \sa toString(), QLocale::toDateTime()
4711 */
4712 QDateTime QDateTime::fromString(const QString &string, Qt::DateFormat format)
4713 {
4714     if (string.isEmpty())
4715         return QDateTime();
4716 
4717     switch (format) {
4718     case Qt::RFC2822Date: {
4719         const ParsedRfcDateTime rfc = rfcDateImpl(string);
4720 
4721         if (!rfc.date.isValid() || !rfc.time.isValid())
4722             return QDateTime();
4723 
4724         QDateTime dateTime(rfc.date, rfc.time, Qt::UTC);
4725         dateTime.setOffsetFromUtc(rfc.utcOffset);
4726         return dateTime;
4727     }
4728     case Qt::ISODate:
4729     case Qt::ISODateWithMs: {
4730         const int size = string.size();
4731         if (size < 10)
4732             return QDateTime();
4733 
4734         QDate date = QDate::fromString(string.left(10), Qt::ISODate);
4735         if (!date.isValid())
4736             return QDateTime();
4737         if (size == 10)
4738             return date.startOfDay();
4739 
4740         Qt::TimeSpec spec = Qt::LocalTime;
4741         QStringView isoString = QStringView(string).mid(10); // trim "yyyy-MM-dd"
4742 
4743         // Must be left with T (or space) and at least one digit for the hour:
4744         if (isoString.size() < 2
4745             || !(isoString.startsWith(QLatin1Char('T'), Qt::CaseInsensitive)
4746                  // RFC 3339 (section 5.6) allows a space here.  (It actually
4747                  // allows any separator one considers more readable, merely
4748                  // giving space as an example - but let's not go wild !)
4749                  || isoString.startsWith(QLatin1Char(' ')))) {
4750             return QDateTime();
4751         }
4752         isoString = isoString.mid(1); // trim 'T' (or space)
4753 
4754         int offset = 0;
4755         // Check end of string for Time Zone definition, either Z for UTC or [+-]HH:mm for Offset
4756         if (isoString.endsWith(QLatin1Char('Z'), Qt::CaseInsensitive)) {
4757             spec = Qt::UTC;
4758             isoString.chop(1); // trim 'Z'
4759         } else {
4760             // the loop below is faster but functionally equal to:
4761             // const int signIndex = isoString.indexOf(QRegulargExpression(QStringLiteral("[+-]")));
4762             int signIndex = isoString.size() - 1;
4763             Q_ASSERT(signIndex >= 0);
4764             bool found = false;
4765             {
4766                 const QChar plus = QLatin1Char('+');
4767                 const QChar minus = QLatin1Char('-');
4768                 do {
4769                     QChar character(isoString.at(signIndex));
4770                     found = character == plus || character == minus;
4771                 } while (!found && --signIndex >= 0);
4772             }
4773 
4774             if (found) {
4775                 bool ok;
4776                 offset = fromOffsetString(isoString.mid(signIndex), &ok);
4777                 if (!ok)
4778                     return QDateTime();
4779                 isoString = isoString.left(signIndex);
4780                 spec = Qt::OffsetFromUTC;
4781             }
4782         }
4783 
4784         // Might be end of day (24:00, including variants), which QTime considers invalid.
4785         // ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
4786         bool isMidnight24 = false;
4787         QTime time = fromIsoTimeString(isoString, format, &isMidnight24);
4788         if (!time.isValid())
4789             return QDateTime();
4790         if (isMidnight24)
4791             date = date.addDays(1);
4792         return QDateTime(date, time, spec, offset);
4793     }
4794     case Qt::TextDate: {
4795         QList<QStringView> parts = QStringView { string }.split(QLatin1Char(' '), Qt::SkipEmptyParts);
4796 
4797         if ((parts.count() < 5) || (parts.count() > 6))
4798             return QDateTime();
4799 
4800         // Accept "Sun Dec 1 13:02:00 1974" and "Sun 1. Dec 13:02:00 1974"
4801 
4802         // Year and time can be in either order.
4803         // Guess which by looking for ':' in the time
4804         int yearPart = 3;
4805         int timePart = 3;
4806         if (parts.at(3).contains(QLatin1Char(':')))
4807             yearPart = 4;
4808         else if (parts.at(4).contains(QLatin1Char(':')))
4809             timePart = 4;
4810         else
4811             return QDateTime();
4812 
4813         int month = 0;
4814         int day = 0;
4815         bool ok = false;
4816 
4817         int year = parts.at(yearPart).toInt(&ok);
4818         if (!ok || year == 0)
4819             return QDateTime();
4820 
4821         // Next try month then day
4822         month = fromShortMonthName(parts.at(1));
4823         if (month)
4824             day = parts.at(2).toInt(&ok);
4825 
4826         // If failed, try day then month
4827         if (!ok || !month || !day) {
4828             month = fromShortMonthName(parts.at(2));
4829             if (month) {
4830                 QStringView  dayStr = parts.at(1);
4831                 if (dayStr.endsWith(QLatin1Char('.'))) {
4832                     dayStr = dayStr.left(dayStr.size() - 1);
4833                     day = dayStr.toInt(&ok);
4834                 }
4835             }
4836         }
4837 
4838         // If both failed, give up
4839         if (!ok || !month || !day)
4840             return QDateTime();
4841 
4842         QDate date(year, month, day);
4843         if (!date.isValid())
4844             return QDateTime();
4845 
4846         // ### fixme, use QStringView::tokenize() when available
4847         QList<QStringView> timeParts = parts.at(timePart).split(QLatin1Char(':'));
4848         if (timeParts.count() < 2 || timeParts.count() > 3)
4849             return QDateTime();
4850 
4851         int hour = timeParts.at(0).toInt(&ok);
4852         if (!ok)
4853             return QDateTime();
4854 
4855         int minute = timeParts.at(1).toInt(&ok);
4856         if (!ok)
4857             return QDateTime();
4858 
4859         int second = 0;
4860         int millisecond = 0;
4861         if (timeParts.count() > 2) {
4862             // ### fixme, use QStringView::tokenize() when available
4863             const QList<QStringView> secondParts = timeParts.at(2).split(QLatin1Char('.'));
4864             if (secondParts.size() > 2) {
4865                 return QDateTime();
4866             }
4867 
4868             second = secondParts.first().toInt(&ok);
4869             if (!ok) {
4870                 return QDateTime();
4871             }
4872 
4873             if (secondParts.size() > 1) {
4874                 millisecond = secondParts.last().toInt(&ok);
4875                 if (!ok) {
4876                     return QDateTime();
4877                 }
4878             }
4879         }
4880 
4881         QTime time(hour, minute, second, millisecond);
4882         if (!time.isValid())
4883             return QDateTime();
4884 
4885         if (parts.count() == 5)
4886             return QDateTime(date, time, Qt::LocalTime);
4887 
4888         QStringView tz = parts.at(5);
4889         if (!tz.startsWith(QLatin1String("GMT"), Qt::CaseInsensitive))
4890             return QDateTime();
4891         tz = tz.mid(3);
4892         if (!tz.isEmpty()) {
4893             int offset = fromOffsetString(tz, &ok);
4894             if (!ok)
4895                 return QDateTime();
4896             return QDateTime(date, time, Qt::OffsetFromUTC, offset);
4897         } else {
4898             return QDateTime(date, time, Qt::UTC);
4899         }
4900     }
4901     }
4902 
4903     return QDateTime();
4904 }
4905 
4906 /*!
4907     Returns the QDateTime represented by the \a string, using the \a
4908     format given, or an invalid datetime if the string cannot be parsed.
4909 
4910     Uses the calendar \a cal if supplied, else Gregorian.
4911 
4912     In addition to the expressions, recognized in the format string to represent
4913     parts of the date and time, by QDate::fromString() and QTime::fromString(),
4914     this method supports:
4915 
4916     \table
4917     \header \li Expression \li Output
4918     \row \li t \li the timezone (for example "CEST")
4919     \endtable
4920 
4921     All other input characters will be treated as text. Any non-empty sequence
4922     of characters enclosed in single quotes will also be treated (stripped of
4923     the quotes) as text and not be interpreted as expressions.
4924 
4925     \snippet code/src_corelib_time_qdatetime.cpp 12
4926 
4927     If the format is not satisfied, an invalid QDateTime is returned.
4928     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be
4929     greedy. This means that they will use two digits even if this will
4930     put them outside the range and/or leave too few digits for other
4931     sections.
4932 
4933     \snippet code/src_corelib_time_qdatetime.cpp 13
4934 
4935     This could have meant 1 January 00:30.00 but the M will grab
4936     two digits.
4937 
4938     Incorrectly specified fields of the \a string will cause an invalid
4939     QDateTime to be returned. For example, consider the following code,
4940     where the two digit year 12 is read as 1912 (see the table below for all
4941     field defaults); the resulting datetime is invalid because 23 April 1912
4942     was a Tuesday, not a Monday:
4943 
4944     \snippet code/src_corelib_time_qdatetime.cpp 20
4945 
4946     The correct code is:
4947 
4948     \snippet code/src_corelib_time_qdatetime.cpp 21
4949 
4950     For any field that is not represented in the format, the following
4951     defaults are used:
4952 
4953     \table
4954     \header \li Field  \li Default value
4955     \row    \li Year   \li 1900
4956     \row    \li Month  \li 1 (January)
4957     \row    \li Day    \li 1
4958     \row    \li Hour   \li 0
4959     \row    \li Minute \li 0
4960     \row    \li Second \li 0
4961     \endtable
4962 
4963     For example:
4964 
4965     \snippet code/src_corelib_time_qdatetime.cpp 14
4966 
4967     \note If localized month and day names are used, please switch to using
4968     QLocale::system().toDateTime() as QDateTime methods shall change to only
4969     recognize English (C locale) names at Qt 6.
4970 
4971     \sa toString(), QDate::fromString(), QTime::fromString(),
4972     QLocale::toDateTime()
4973 */
4974 
4975 QDateTime QDateTime::fromString(const QString &string, const QString &format, QCalendar cal)
4976 {
4977 #if QT_CONFIG(datetimeparser)
4978     QDateTime datetime;
4979 
4980     QDateTimeParser dt(QMetaType::QDateTime, QDateTimeParser::FromString, cal);
4981     dt.setDefaultLocale(QLocale::c());
4982     if (dt.parseFormat(format) && dt.fromString(string, &datetime))
4983         return datetime;
4984 #else
4985     Q_UNUSED(string);
4986     Q_UNUSED(format);
4987     Q_UNUSED(cal);
4988 #endif
4989     return QDateTime();
4990 }
4991 
4992 #endif // datestring
4993 /*!
4994     \fn QDateTime QDateTime::toLocalTime() const
4995 
4996     Returns a datetime containing the date and time information in
4997     this datetime, but specified using the Qt::LocalTime definition.
4998 
4999     Example:
5000 
5001     \snippet code/src_corelib_time_qdatetime.cpp 17
5002 
5003     \sa toTimeSpec()
5004 */
5005 
5006 /*!
5007     \fn QDateTime QDateTime::toUTC() const
5008 
5009     Returns a datetime containing the date and time information in
5010     this datetime, but specified using the Qt::UTC definition.
5011 
5012     Example:
5013 
5014     \snippet code/src_corelib_time_qdatetime.cpp 18
5015 
5016     \sa toTimeSpec()
5017 */
5018 
5019 /*****************************************************************************
5020   Date/time stream functions
5021  *****************************************************************************/
5022 
5023 #ifndef QT_NO_DATASTREAM
5024 /*!
5025     \relates QDate
5026 
5027     Writes the \a date to stream \a out.
5028 
5029     \sa {Serializing Qt Data Types}
5030 */
5031 
5032 QDataStream &operator<<(QDataStream &out, QDate date)
5033 {
5034     if (out.version() < QDataStream::Qt_5_0)
5035         return out << quint32(date.jd);
5036     else
5037         return out << qint64(date.jd);
5038 }
5039 
5040 /*!
5041     \relates QDate
5042 
5043     Reads a date from stream \a in into the \a date.
5044 
5045     \sa {Serializing Qt Data Types}
5046 */
5047 
5048 QDataStream &operator>>(QDataStream &in, QDate &date)
5049 {
5050     if (in.version() < QDataStream::Qt_5_0) {
5051         quint32 jd;
5052         in >> jd;
5053         // Older versions consider 0 an invalid jd.
5054         date.jd = (jd != 0 ? jd : QDate::nullJd());
5055     } else {
5056         qint64 jd;
5057         in >> jd;
5058         date.jd = jd;
5059     }
5060 
5061     return in;
5062 }
5063 
5064 /*!
5065     \relates QTime
5066 
5067     Writes \a time to stream \a out.
5068 
5069     \sa {Serializing Qt Data Types}
5070 */
5071 
5072 QDataStream &operator<<(QDataStream &out, QTime time)
5073 {
5074     if (out.version() >= QDataStream::Qt_4_0) {
5075         return out << quint32(time.mds);
5076     } else {
5077         // Qt3 had no support for reading -1, QTime() was valid and serialized as 0
5078         return out << quint32(time.isNull() ? 0 : time.mds);
5079     }
5080 }
5081 
5082 /*!
5083     \relates QTime
5084 
5085     Reads a time from stream \a in into the given \a time.
5086 
5087     \sa {Serializing Qt Data Types}
5088 */
5089 
5090 QDataStream &operator>>(QDataStream &in, QTime &time)
5091 {
5092     quint32 ds;
5093     in >> ds;
5094     if (in.version() >= QDataStream::Qt_4_0) {
5095         time.mds = int(ds);
5096     } else {
5097         // Qt3 would write 0 for a null time
5098         time.mds = (ds == 0) ? QTime::NullTime : int(ds);
5099     }
5100     return in;
5101 }
5102 
5103 /*!
5104     \relates QDateTime
5105 
5106     Writes \a dateTime to the \a out stream.
5107 
5108     \sa {Serializing Qt Data Types}
5109 */
5110 QDataStream &operator<<(QDataStream &out, const QDateTime &dateTime)
5111 {
5112     QPair<QDate, QTime> dateAndTime;
5113 
5114     if (out.version() >= QDataStream::Qt_5_2) {
5115 
5116         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5117         dateAndTime = getDateTime(dateTime.d);
5118         out << dateAndTime << qint8(dateTime.timeSpec());
5119         if (dateTime.timeSpec() == Qt::OffsetFromUTC)
5120             out << qint32(dateTime.offsetFromUtc());
5121 #if QT_CONFIG(timezone)
5122         else if (dateTime.timeSpec() == Qt::TimeZone)
5123             out << dateTime.timeZone();
5124 #endif // timezone
5125 
5126     } else if (out.version() == QDataStream::Qt_5_0) {
5127 
5128         // In Qt 5.0 we incorrectly serialised all datetimes as UTC.
5129         // This approach is wrong and should not be used again; it breaks
5130         // the guarantee that a deserialised local datetime is the same time
5131         // of day, regardless of which timezone it was serialised in.
5132         dateAndTime = getDateTime((dateTime.isValid() ? dateTime.toUTC() : dateTime).d);
5133         out << dateAndTime << qint8(dateTime.timeSpec());
5134 
5135     } else if (out.version() >= QDataStream::Qt_4_0) {
5136 
5137         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5138         dateAndTime = getDateTime(dateTime.d);
5139         out << dateAndTime;
5140         switch (dateTime.timeSpec()) {
5141         case Qt::UTC:
5142             out << (qint8)QDateTimePrivate::UTC;
5143             break;
5144         case Qt::OffsetFromUTC:
5145             out << (qint8)QDateTimePrivate::OffsetFromUTC;
5146             break;
5147         case Qt::TimeZone:
5148             out << (qint8)QDateTimePrivate::TimeZone;
5149             break;
5150         case Qt::LocalTime:
5151             out << (qint8)QDateTimePrivate::LocalUnknown;
5152             break;
5153         }
5154 
5155     } else { // version < QDataStream::Qt_4_0
5156 
5157         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5158         dateAndTime = getDateTime(dateTime.d);
5159         out << dateAndTime;
5160 
5161     }
5162 
5163     return out;
5164 }
5165 
5166 /*!
5167     \relates QDateTime
5168 
5169     Reads a datetime from the stream \a in into \a dateTime.
5170 
5171     \sa {Serializing Qt Data Types}
5172 */
5173 
5174 QDataStream &operator>>(QDataStream &in, QDateTime &dateTime)
5175 {
5176     QDate dt;
5177     QTime tm;
5178     qint8 ts = 0;
5179     Qt::TimeSpec spec = Qt::LocalTime;
5180     qint32 offset = 0;
5181 #if QT_CONFIG(timezone)
5182     QTimeZone tz;
5183 #endif // timezone
5184 
5185     if (in.version() >= QDataStream::Qt_5_2) {
5186 
5187         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5188         in >> dt >> tm >> ts;
5189         spec = static_cast<Qt::TimeSpec>(ts);
5190         if (spec == Qt::OffsetFromUTC) {
5191             in >> offset;
5192             dateTime = QDateTime(dt, tm, spec, offset);
5193 #if QT_CONFIG(timezone)
5194         } else if (spec == Qt::TimeZone) {
5195             in >> tz;
5196             dateTime = QDateTime(dt, tm, tz);
5197 #endif // timezone
5198         } else {
5199             dateTime = QDateTime(dt, tm, spec);
5200         }
5201 
5202     } else if (in.version() == QDataStream::Qt_5_0) {
5203 
5204         // In Qt 5.0 we incorrectly serialised all datetimes as UTC
5205         in >> dt >> tm >> ts;
5206         spec = static_cast<Qt::TimeSpec>(ts);
5207         dateTime = QDateTime(dt, tm, Qt::UTC);
5208         dateTime = dateTime.toTimeSpec(spec);
5209 
5210     } else if (in.version() >= QDataStream::Qt_4_0) {
5211 
5212         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5213         in >> dt >> tm >> ts;
5214         switch ((QDateTimePrivate::Spec)ts) {
5215         case QDateTimePrivate::UTC:
5216             spec = Qt::UTC;
5217             break;
5218         case QDateTimePrivate::OffsetFromUTC:
5219             spec = Qt::OffsetFromUTC;
5220             break;
5221         case QDateTimePrivate::TimeZone:
5222             spec = Qt::TimeZone;
5223 #if QT_CONFIG(timezone)
5224             // FIXME: need to use a different constructor !
5225 #endif
5226             break;
5227         case QDateTimePrivate::LocalUnknown:
5228         case QDateTimePrivate::LocalStandard:
5229         case QDateTimePrivate::LocalDST:
5230             spec = Qt::LocalTime;
5231             break;
5232         }
5233         dateTime = QDateTime(dt, tm, spec, offset);
5234 
5235     } else { // version < QDataStream::Qt_4_0
5236 
5237         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5238         in >> dt >> tm;
5239         dateTime = QDateTime(dt, tm, spec, offset);
5240 
5241     }
5242 
5243     return in;
5244 }
5245 #endif // QT_NO_DATASTREAM
5246 
5247 /*****************************************************************************
5248   Date / Time Debug Streams
5249 *****************************************************************************/
5250 
5251 #if !defined(QT_NO_DEBUG_STREAM) && QT_CONFIG(datestring)
5252 QDebug operator<<(QDebug dbg, QDate date)
5253 {
5254     QDebugStateSaver saver(dbg);
5255     dbg.nospace() << "QDate(";
5256     if (date.isValid())
5257         dbg.nospace() << date.toString(Qt::ISODate);
5258     else
5259         dbg.nospace() << "Invalid";
5260     dbg.nospace() << ')';
5261     return dbg;
5262 }
5263 
5264 QDebug operator<<(QDebug dbg, QTime time)
5265 {
5266     QDebugStateSaver saver(dbg);
5267     dbg.nospace() << "QTime(";
5268     if (time.isValid())
5269         dbg.nospace() << time.toString(u"HH:mm:ss.zzz");
5270     else
5271         dbg.nospace() << "Invalid";
5272     dbg.nospace() << ')';
5273     return dbg;
5274 }
5275 
5276 QDebug operator<<(QDebug dbg, const QDateTime &date)
5277 {
5278     QDebugStateSaver saver(dbg);
5279     dbg.nospace() << "QDateTime(";
5280     if (date.isValid()) {
5281         const Qt::TimeSpec ts = date.timeSpec();
5282         dbg.noquote() << date.toString(u"yyyy-MM-dd HH:mm:ss.zzz t")
5283                       << ' ' << ts;
5284         switch (ts) {
5285         case Qt::UTC:
5286             break;
5287         case Qt::OffsetFromUTC:
5288             dbg.space() << date.offsetFromUtc() << 's';
5289             break;
5290         case Qt::TimeZone:
5291 #if QT_CONFIG(timezone)
5292             dbg.space() << date.timeZone().id();
5293 #endif // timezone
5294             break;
5295         case Qt::LocalTime:
5296             break;
5297         }
5298     } else {
5299         dbg.nospace() << "Invalid";
5300     }
5301     return dbg.nospace() << ')';
5302 }
5303 #endif // debug_stream && datestring
5304 
5305 /*! \fn size_t qHash(const QDateTime &key, size_t seed = 0)
5306     \relates QHash
5307     \since 5.0
5308 
5309     Returns the hash value for the \a key, using \a seed to seed the calculation.
5310 */
5311 size_t qHash(const QDateTime &key, size_t seed)
5312 {
5313     // Use to toMSecsSinceEpoch instead of individual qHash functions for
5314     // QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
5315     // to the same timezone. If we don't, qHash would return different hashes for
5316     // two QDateTimes that are equivalent once converted to the same timezone.
5317     return key.isValid() ? qHash(key.toMSecsSinceEpoch(), seed) : seed;
5318 }
5319 
5320 /*! \fn size_t qHash(QDate key, size_t seed = 0)
5321     \relates QHash
5322     \since 5.0
5323 
5324     Returns the hash value for the \a key, using \a seed to seed the calculation.
5325 */
5326 size_t qHash(QDate key, size_t seed) noexcept
5327 {
5328     return qHash(key.toJulianDay(), seed);
5329 }
5330 
5331 /*! \fn size_t qHash(QTime key, size_t seed = 0)
5332     \relates QHash
5333     \since 5.0
5334 
5335     Returns the hash value for the \a key, using \a seed to seed the calculation.
5336 */
5337 size_t qHash(QTime key, size_t seed) noexcept
5338 {
5339     return qHash(key.msecsSinceStartOfDay(), seed);
5340 }
5341 
5342 QT_END_NAMESPACE
