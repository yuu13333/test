Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qproperty.h"
41 #include "qproperty_p.h"
42 
43 #include <qscopedvaluerollback.h>
44 
45 QT_BEGIN_NAMESPACE
46 
47 using namespace QtPrivate;
48 
49 void QPropertyBasePointer::addObserver(QPropertyObserver *observer)
50 {
51     if (auto *binding = bindingPtr()) {
52         observer->prev = &binding->firstObserver.ptr;
53         observer->next = binding->firstObserver.ptr;
54         if (observer->next)
55             observer->next->prev = &observer->next;
56         binding->firstObserver.ptr = observer;
57     } else {
58         auto firstObserver = reinterpret_cast<QPropertyObserver*>(ptr->d_ptr & ~QPropertyBase::FlagMask);
59         observer->prev = reinterpret_cast<QPropertyObserver**>(&ptr->d_ptr);
60         observer->next = firstObserver;
61         if (observer->next)
62             observer->next->prev = &observer->next;
63     }
64     setFirstObserver(observer);
65 }
66 
67 QPropertyBindingPrivate::~QPropertyBindingPrivate()
68 {
69     if (firstObserver)
70         firstObserver.unlink();
71     if (!hasStaticObserver)
72         inlineDependencyObservers.~ObserverArray(); // Explicit because of union.
73 }
74 
75 void QPropertyBindingPrivate::unlinkAndDeref()
76 {
77     propertyDataPtr = nullptr;
78     if (!ref.deref())
79         delete this;
80 }
81 
82 void QPropertyBindingPrivate::markDirtyAndNotifyObservers()
83 {
84     if (dirty)
85         return;
86     dirty = true;
87     if (firstObserver)
88         firstObserver.notify(this, propertyDataPtr);
89     if (hasStaticObserver)
90         staticObserverCallback(staticObserver, propertyDataPtr);
91 }
92 
93 bool QPropertyBindingPrivate::evaluateIfDirtyAndReturnTrueIfValueChanged()
94 {
95     if (!dirty)
96         return false;
97 
98     if (updating) {
99         error = QPropertyBindingError(QPropertyBindingError::BindingLoop);
100         return false;
101     }
102 
103     /*
104      * Evaluating the binding might lead to the binding being broken. This can
105      * cause ref to reach zero at the end of the function.  However, the
106      * updateGuard's destructor will then still trigger, trying to set the
107      * updating bool to its old value
108      * To prevent this, we create a QPropertyBindingPrivatePtr which ensures
109      * that the object is still alive when updateGuard's dtor runs.
110      */
111     QPropertyBindingPrivatePtr keepAlive {this};
112     QScopedValueRollback<bool> updateGuard(updating, true);
113 
114     BindingEvaluationState evaluationFrame(this);
115 
116     bool changed = false;
117 
118     if (hasStaticObserver && staticGuardCallback) {
119         changed = staticGuardCallback(metaType, propertyDataPtr, evaluationFunction, staticObserver);
120     } else {
121         changed = evaluationFunction(metaType, propertyDataPtr);
122     }
123 
124     dirty = false;
125     return changed;
126 }
127 
128 QUntypedPropertyBinding::QUntypedPropertyBinding() = default;
129 
130 QUntypedPropertyBinding::QUntypedPropertyBinding(const QMetaType &metaType, QUntypedPropertyBinding::BindingEvaluationFunction function,
131                                                  const QPropertyBindingSourceLocation &location)
132 {
133     d = new QPropertyBindingPrivate(metaType, std::move(function), std::move(location));
134 }
135 
136 QUntypedPropertyBinding::QUntypedPropertyBinding(QUntypedPropertyBinding &&other)
137     : d(std::move(other.d))
138 {
139 }
140 
141 QUntypedPropertyBinding::QUntypedPropertyBinding(const QUntypedPropertyBinding &other)
142     : d(other.d)
143 {
144 }
145 
146 QUntypedPropertyBinding &QUntypedPropertyBinding::operator=(const QUntypedPropertyBinding &other)
147 {
148     d = other.d;
149     return *this;
150 }
151 
152 QUntypedPropertyBinding &QUntypedPropertyBinding::operator=(QUntypedPropertyBinding &&other)
153 {
154     d = std::move(other.d);
155     return *this;
156 }
157 
158 QUntypedPropertyBinding::QUntypedPropertyBinding(QPropertyBindingPrivate *priv)
159     : d(priv)
160 {
161 }
162 
163 QUntypedPropertyBinding::~QUntypedPropertyBinding()
164 {
165 }
166 
167 bool QUntypedPropertyBinding::isNull() const
168 {
169     return !d;
170 }
171 
172 QPropertyBindingError QUntypedPropertyBinding::error() const
173 {
174     if (!d)
175         return QPropertyBindingError();
176     return d->bindingError();
177 }
178 
179 QMetaType QUntypedPropertyBinding::valueMetaType() const
180 {
181     if (!d)
182         return QMetaType();
183     return d->valueMetaType();
184 }
185 
186 QPropertyBase::QPropertyBase(QPropertyBase &&other, void *propertyDataPtr)
187 {
188     std::swap(d_ptr, other.d_ptr);
189     QPropertyBasePointer d{this};
190     d.setFirstObserver(nullptr);
191     if (auto binding = d.bindingPtr())
192         binding->setProperty(propertyDataPtr);
193 }
194 
195 void QPropertyBase::moveAssign(QPropertyBase &&other, void *propertyDataPtr)
196 {
197     if (&other == this)
198         return;
199 
200     QPropertyBasePointer d{this};
201     auto observer = d.firstObserver();
202     d.setFirstObserver(nullptr);
203 
204     if (auto binding = d.bindingPtr()) {
205         binding->unlinkAndDeref();
206         d_ptr &= FlagMask;
207     }
208 
209     std::swap(d_ptr, other.d_ptr);
210 
211     if (auto binding = d.bindingPtr())
212         binding->setProperty(propertyDataPtr);
213 
214     d.setFirstObserver(observer.ptr);
215 
216     // The caller will have to notify observers.
217 }
218 
219 QPropertyBase::~QPropertyBase()
220 {
221     QPropertyBasePointer d{this};
222     for (auto observer = d.firstObserver(); observer;) {
223         auto next = observer.nextObserver();
224         observer.unlink();
225         observer = next;
226     }
227     if (auto binding = d.bindingPtr())
228         binding->unlinkAndDeref();
229 }
230 
231 QUntypedPropertyBinding QPropertyBase::setBinding(const QUntypedPropertyBinding &binding,
232                                                   void *propertyDataPtr,
233                                                   void *staticObserver,
234                                                   QPropertyObserverCallback staticObserverCallback,
235                                                   QtPrivate::QPropertyGuardFunction guardCallback)
236 {
237     QPropertyBindingPrivatePtr oldBinding;
238     QPropertyBindingPrivatePtr newBinding = binding.d;
239 
240     QPropertyBasePointer d{this};
241     QPropertyObserverPointer observer;
242 
243     if (auto *existingBinding = d.bindingPtr()) {
244         if (existingBinding == newBinding.data())
245             return QUntypedPropertyBinding(oldBinding.data());
246         oldBinding = QPropertyBindingPrivatePtr(existingBinding);
247         observer = oldBinding->takeObservers();
248         oldBinding->unlinkAndDeref();
249         d_ptr &= FlagMask;
250     } else {
251         observer = d.firstObserver();
252     }
253 
254     if (newBinding) {
255         newBinding.data()->ref.ref();
256         d_ptr = (d_ptr & FlagMask) | reinterpret_cast<quintptr>(newBinding.data());
257         d_ptr |= BindingBit;
258         newBinding->setDirty(true);
259         newBinding->setProperty(propertyDataPtr);
260         if (observer)
261             newBinding->prependObserver(observer);
262         newBinding->setStaticObserver(staticObserver, staticObserverCallback, guardCallback);
263     } else if (observer) {
264         d.setObservers(observer.ptr);
265     } else {
266         d_ptr &= ~QPropertyBase::BindingBit;
267     }
268 
269     return QUntypedPropertyBinding(oldBinding.data());
270 }
271 
272 QPropertyBindingPrivate *QPropertyBase::binding()
273 {
274     QPropertyBasePointer d{this};
275     if (auto binding = d.bindingPtr())
276         return binding;
277     return nullptr;
278 }
279 
280 static thread_local BindingEvaluationState *currentBindingEvaluationState = nullptr;
281 
282 BindingEvaluationState::BindingEvaluationState(QPropertyBindingPrivate *binding)
283     : binding(binding)
284 {
285     // store a pointer to the currentBindingEvaluationState to avoid a TLS lookup in
286     // the destructor (as these come with a non zero cost)
287     currentState = &currentBindingEvaluationState;
288     previousState = *currentState;
289     *currentState = this;
290     binding->clearDependencyObservers();
291 }
292 
293 BindingEvaluationState::~BindingEvaluationState()
294 {
295     *currentState = previousState;
296 }
297 
298 QPropertyBindingPrivate *QPropertyBindingPrivate::currentlyEvaluatingBinding()
299 {
300     return currentBindingEvaluationState ? currentBindingEvaluationState->binding : nullptr;
301 }
302 
303 void QPropertyBase::evaluateIfDirty()
304 {
305     QPropertyBasePointer d{this};
306     QPropertyBindingPrivate *binding = d.bindingPtr();
307     if (!binding)
308         return;
309     binding->evaluateIfDirtyAndReturnTrueIfValueChanged();
310 }
311 
312 void QPropertyBase::removeBinding()
313 {
314     QPropertyBasePointer d{this};
315 
316     if (auto *existingBinding = d.bindingPtr()) {
317         auto observer = existingBinding->takeObservers();
318         d_ptr &= ExtraBit;
319         if (observer)
320             d.setObservers(observer.ptr);
321         existingBinding->unlinkAndDeref();
322     }
323 }
324 
325 void QPropertyBase::registerWithCurrentlyEvaluatingBinding() const
326 {
327     auto currentState = currentBindingEvaluationState;
328     if (!currentState)
329         return;
330 
331     QPropertyBasePointer d{this};
332 
333     QPropertyObserverPointer dependencyObserver = currentState->binding->allocateDependencyObserver();
334     dependencyObserver.setBindingToMarkDirty(currentState->binding);
335     dependencyObserver.observeProperty(d);
336 }
337 
338 void QPropertyBase::notifyObservers(void *propertyDataPtr)
339 {
340     QPropertyBasePointer d{this};
341     if (QPropertyObserverPointer observer = d.firstObserver())
342         observer.notify(d.bindingPtr(), propertyDataPtr);
343 }
344 
345 int QPropertyBasePointer::observerCount() const
346 {
347     int count = 0;
348     for (auto observer = firstObserver(); observer; observer = observer.nextObserver())
349         ++count;
350     return count;
351 }
352 
353 QPropertyObserver::QPropertyObserver(void (*callback)(QPropertyObserver *, void *))
354 {
355     QPropertyObserverPointer d{this};
356     d.setChangeHandler(callback);
357 }
358 
359 QPropertyObserver::QPropertyObserver(void *aliasedPropertyPtr)
360 {
361     QPropertyObserverPointer d{this};
362     d.setAliasedProperty(aliasedPropertyPtr);
363 }
364 
365 void QPropertyObserver::setSource(QPropertyBase &property)
366 {
367     QPropertyObserverPointer d{this};
368     QPropertyBasePointer propPrivate{&property};
369     d.observeProperty(propPrivate);
370 }
371 
372 
373 QPropertyObserver::~QPropertyObserver()
374 {
375     QPropertyObserverPointer d{this};
376     d.unlink();
377 }
378 
379 QPropertyObserver::QPropertyObserver(QPropertyObserver &&other)
380 {
381     std::swap(bindingToMarkDirty, other.bindingToMarkDirty);
382     std::swap(next, other.next);
383     std::swap(prev, other.prev);
384     if (next)
385         next->prev = &next;
386     if (prev)
387         prev.setPointer(this);
388 }
389 
390 QPropertyObserver &QPropertyObserver::operator=(QPropertyObserver &&other)
391 {
392     if (this == &other)
393         return *this;
394 
395     QPropertyObserverPointer d{this};
396     d.unlink();
397     bindingToMarkDirty = nullptr;
398 
399     std::swap(bindingToMarkDirty, other.bindingToMarkDirty);
400     std::swap(next, other.next);
401     std::swap(prev, other.prev);
402     if (next)
403         next->prev = &next;
404     if (prev)
405         prev.setPointer(this);
406 
407     return *this;
408 }
409 
410 void QPropertyObserverPointer::unlink()
411 {
412     if (ptr->next.tag() & QPropertyObserver::ObserverNotifiesAlias)
413         ptr->aliasedPropertyPtr = 0;
414     if (ptr->next)
415         ptr->next->prev = ptr->prev;
416     if (ptr->prev)
417         ptr->prev.setPointer(ptr->next.data());
418     ptr->next = nullptr;
419     ptr->prev.clear();
420 }
421 
422 void QPropertyObserverPointer::setChangeHandler(void (*changeHandler)(QPropertyObserver *, void *))
423 {
424     ptr->changeHandler = changeHandler;
425     ptr->next.setTag(QPropertyObserver::ObserverNotifiesChangeHandler);
426 }
427 
428 void QPropertyObserverPointer::setAliasedProperty(void *propertyPtr)
429 {
430     ptr->aliasedPropertyPtr = quintptr(propertyPtr);
431     ptr->next.setTag(QPropertyObserver::ObserverNotifiesAlias);
432 }
433 
434 void QPropertyObserverPointer::setBindingToMarkDirty(QPropertyBindingPrivate *binding)
435 {
436     ptr->bindingToMarkDirty = binding;
437     ptr->next.setTag(QPropertyObserver::ObserverNotifiesBinding);
438 }
439 
440 void QPropertyObserverPointer::notify(QPropertyBindingPrivate *triggeringBinding, void *propertyDataPtr)
441 {
442     bool knownIfPropertyChanged = false;
443     bool propertyChanged = true;
444 
445     auto observer = const_cast<QPropertyObserver*>(ptr);
446     while (observer) {
447         auto * const next = observer->next.data();
448         switch (observer->next.tag()) {
449         case QPropertyObserver::ObserverNotifiesChangeHandler:
450             if (!knownIfPropertyChanged && triggeringBinding) {
451                 knownIfPropertyChanged = true;
452 
453                 propertyChanged = triggeringBinding->evaluateIfDirtyAndReturnTrueIfValueChanged();
454             }
455             if (!propertyChanged)
456                 return;
457 
458             if (auto handlerToCall = std::exchange(observer->changeHandler, nullptr)) {
459                 handlerToCall(observer, propertyDataPtr);
460                 observer->changeHandler = handlerToCall;
461             }
462             break;
463         case QPropertyObserver::ObserverNotifiesBinding:
464             if (observer->bindingToMarkDirty)
465                 observer->bindingToMarkDirty->markDirtyAndNotifyObservers();
466             break;
467         case QPropertyObserver::ObserverNotifiesAlias:
468             break;
469         }
470         observer = next;
471     }
472 }
473 
474 void QPropertyObserverPointer::observeProperty(QPropertyBasePointer property)
475 {
476     if (ptr->prev)
477         unlink();
478     property.addObserver(ptr);
479 }
480 
481 QPropertyBindingError::QPropertyBindingError()
482 {
483 }
484 
485 QPropertyBindingError::QPropertyBindingError(Type type, const QString &description)
486 {
487     if (type != NoError) {
488         d = new QPropertyBindingErrorPrivate;
489         d->type = type;
490         d->description = description;
491     }
492 }
493 
494 QPropertyBindingError::QPropertyBindingError(const QPropertyBindingError &other)
495     : d(other.d)
496 {
497 }
498 
499 QPropertyBindingError &QPropertyBindingError::operator=(const QPropertyBindingError &other)
500 {
501     d = other.d;
502     return *this;
503 }
504 
505 QPropertyBindingError::QPropertyBindingError(QPropertyBindingError &&other)
506     : d(std::move(other.d))
507 {
508 }
509 
510 QPropertyBindingError &QPropertyBindingError::operator=(QPropertyBindingError &&other)
511 {
512     d = std::move(other.d);
513     return *this;
514 }
515 
516 QPropertyBindingError::~QPropertyBindingError()
517 {
518 }
519 
520 QPropertyBindingError::Type QPropertyBindingError::type() const
521 {
522     if (!d)
523         return QPropertyBindingError::NoError;
524     return d->type;
525 }
526 
527 QString QPropertyBindingError::description() const
528 {
529     if (!d)
530         return QString();
531     return d->description;
532 }
533 
534 /*!
535   \class QProperty
536   \inmodule QtCore
537   \brief The QProperty class is a template class that enables automatic property bindings.
538 
539   \ingroup tools
540 
541   QProperty\<T\> is a generic container that holds an instance of T. You can assign
542   a value to it and you can read it via the value() function or the T conversion
543   operator. You can also tie the property to an expression that computes the value
544   dynamically, the binding expression. It is represented as a C++ lambda and
545   can be used to express relationships between different properties in your
546   application.
547 
548   The binding expression computes the value by reading other QProperty values.
549   Behind the scenes this dependency is tracked. Whenever a change in any property's
550   dependency is detected, the binding expression is re-evaluated and the new
551   result is applied to the property. This happens lazily, by marking the binding
552   as dirty and evaluating it only when the property's value is requested. For example:
553 
554   \code
555     QProperty<QString> firstname("John");
556     QProperty<QString> lastname("Smith");
557     QProperty<int> age(41);
558 
559     QProperty<QString> fullname;
560     fullname.setBinding([&]() { return firstname.value() + " " + lastname.value() + " age:" + QString::number(age.value()); });
561 
562     qDebug() << fullname.value(); // Prints "John Smith age: 41"
563 
564     firstname = "Emma"; // Marks binding expression as dirty
565 
566     qDebug() << fullname.value(); // Re-evaluates the binding expression and prints "Emma Smith age: 41"
567 
568     // Birthday is coming up
569     age.setValue(age.value() + 1);
570 
571     qDebug() << fullname.value(); // Re-evaluates the binding expression and prints "Emma Smith age: 42"
572   \endcode
573 
574   When a new value is assigned to the \c firstname property, the binding
575   expression for \c fullname is marked as dirty. So when the last \c qDebug() statement
576   tries to read the name value of the \c fullname property, the expression is
577   evaluated again, \c firstname() will be called again and return the new value.
578 
579   Since bindings are C++ lambda expressions, they may do anything that's possible
580   in C++. This includes calling other functions. If those functions access values
581   held by QProperty, they automatically become dependencies to the binding.
582 
583   Binding expressions may use properties of any type, so in the above example the age
584   is an integer and folded into the string value using conversion to integer, but
585   the dependency is fully tracked.
586 
587   \section1 Tracking properties
588 
589   Sometimes the relationships between properties cannot be expressed using
590   bindings. Instead you may need to run custom code whenever the value of a property
591   changes and instead of assigning the value to another property, pass it to
592   other parts of your application. For example writing data into a network socket
593   or printing debug output. QProperty provides two mechanisms for tracking.
594 
595   You can register for a callback function to be called whenever the value of
596   a property changes, by using onValueChanged(). If you want the callback to also
597   be called for the current value of the property, register your callback using
598   subscribe() instead.
599 */
600 
601 /*!
602   \fn template <typename T> QProperty<T>::QProperty()
603 
604   Constructs a property with a default constructed instance of T.
605 */
606 
607 /*!
608   \fn template <typename T> explicit QProperty<T>::QProperty(const T &initialValue)
609 
610   Constructs a property with the provided \a initialValue.
611 */
612 
613 /*!
614   \fn template <typename T> explicit QProperty<T>::QProperty(T &&initialValue)
615 
616   Move-Constructs a property with the provided \a initialValue.
617 */
618 
619 /*!
620   \fn template <typename T> QProperty<T>::QProperty(QProperty<T> &&other)
621 
622   Move-constructs a QProperty instance, making it point at the same object that
623   \a other was pointing to.
624 */
625 
626 /*!
627   \fn template <typename T> QProperty<T> &QProperty<T>::operator=(QProperty &&other)
628 
629   Move-assigns \a other to this QProperty instance.
630 */
631 
632 /*!
633   \fn template <typename T> QProperty<T>::QProperty(const QPropertyBinding<T> &binding)
634 
635   Constructs a property that is tied to the provided \a binding expression. The
636   first time the property value is read, the binding is evaluated. Whenever a
637   dependency of the binding changes, the binding will be re-evaluated the next
638   time the value of this property is read.
639 */
640 
641 /*!
642   \fn template <typename T> template <typename Functor> QProperty<T>::QProperty(Functor &&f)
643 
644   Constructs a property that is tied to the provided binding expression \a f. The
645   first time the property value is read, the binding is evaluated. Whenever a
646   dependency of the binding changes, the binding will be re-evaluated the next
647   time the value of this property is read.
648 */
649 
650 /*!
651   \fn template <typename T> QProperty<T>::~QProperty()
652 
653   Destroys the property.
654 */
655 
656 /*!
657   \fn template <typename T> T QProperty<T>::value() const
658 
659   Returns the value of the property. This may evaluate a binding expression that
660   is tied to this property, before returning the value.
661 */
662 
663 /*!
664   \fn template <typename T> QProperty<T>::operator T() const
665 
666   Returns the value of the property. This may evaluate a binding expression that
667   is tied to this property, before returning the value.
668 */
669 
670 /*!
671   \fn template <typename T> void QProperty<T>::setValue(const T &newValue)
672 
673   Assigns \a newValue to this property and removes the property's associated
674   binding, if present.
675 */
676 
677 /*!
678   \fn template <typename T> void QProperty<T>::setValue(T &&newValue)
679   \overload
680 
681   Assigns \a newValue to this property and removes the property's associated
682   binding, if present.
683 */
684 
685 /*!
686   \fn template <typename T> QProperty<T> &QProperty<T>::operator=(const T &newValue)
687 
688   Assigns \a newValue to this property and returns a reference to this QProperty.
689 */
690 
691 /*!
692   \fn template <typename T> QProperty<T> &QProperty<T>::operator=(T &&newValue)
693   \overload
694 
695   Assigns \a newValue to this property and returns a reference to this QProperty.
696 */
697 
698 /*!
699   \fn template <typename T> QProperty<T> &QProperty<T>::operator=(const QPropertyBinding<T> &newBinding)
700 
701   Associates the value of this property with the provided \a newBinding
702   expression and returns a reference to this property. The first time the
703   property value is read, the binding is evaluated. Whenever a dependency of the
704   binding changes, the binding will be re-evaluated the next time the value of
705   this property is read.
706 */
707 
708 /*!
709   \fn template <typename T> QPropertyBinding<T> QProperty<T>::setBinding(const QPropertyBinding<T> &newBinding)
710 
711   Associates the value of this property with the provided \a newBinding
712   expression and returns the previously associated binding. The first time the
713   property value is read, the binding is evaluated. Whenever a dependency of the
714   binding changes, the binding will be re-evaluated the next time the value of
715   this property is read.
716 */
717 
718 /*!
719   \fn template <typename T> template <typename Functor> QPropertyBinding<T> QProperty<T>::setBinding(Functor f)
720   \overload
721 
722   Associates the value of this property with the provided functor \a f and
723   returns the previously associated binding. The first time the property value
724   is read, the binding is evaluated by invoking the call operator () of \a f.
725   Whenever a dependency of the binding changes, the binding will be re-evaluated
726   the next time the value of this property is read.
727 */
728 
729 /*!
730   \fn template <typename T> QPropertyBinding<T> QProperty<T>::setBinding(QPropertyBinding<T> &&newBinding)
731   \overload
732 
733   Associates the value of this property with the provided \a newBinding
734   expression and returns the previously associated binding. The first time the
735   property value is read, the binding is evaluated. Whenever a dependency of the
736   binding changes, the binding will be re-evaluated the next time the value of
737   this property is read.
738 */
739 
740 /*!
741   \fn template <typename T> QPropertyBinding<T> bool QProperty<T>::setBinding(const QUntypedPropertyBinding &newBinding)
742   \overload
743 
744   Associates the value of this property with the provided \a newBinding
745   expression. The first time the property value is read, the binding is evaluated.
746   Whenever a dependency of the binding changes, the binding will be re-evaluated
747   the next time the value of this property is read.
748 
749   Returns true if the type of this property is the same as the type the binding
750   function returns; false otherwise.
751 */
752 
753 /*!
754   \fn template <typename T> QPropertyBinding<T> QProperty<T>::binding() const
755 
756   Returns the binding expression that is associated with this property. A
757   default constructed QPropertyBinding<T> will be returned if no such
758   association exists.
759 */
760 
761 /*!
762   \fn template <typename T> QPropertyBinding<T> QProperty<T>::takeBinding()
763 
764   Disassociates the binding expression from this property and returns it. After
765   calling this function, the value of the property will only change if you
766   assign a new value to it, or when a new binding is set.
767 */
768 
769 /*!
770   \fn template <typename T> template <typename Functor> QPropertyChangeHandler<T, Functor> QProperty<T>::onValueChanged(Functor f)
771 
772   Registers the given functor \a f as a callback that shall be called whenever
773   the value of the property changes.
774 
775   The callback \a f is expected to be a type that has a plain call operator () without any
776   parameters. This means that you can provide a C++ lambda expression, an std::function
777   or even a custom struct with a call operator.
778 
779   The returned property change handler object keeps track of the registration. When it
780   goes out of scope, the callback is de-registered.
781 */
782 
783 /*!
784   \fn template <typename T> template <typename Functor> QPropertyChangeHandler<T, Functor> QProperty<T>::subscribe(Functor f)
785 
786   Subscribes the given functor \a f as a callback that is called immediately and whenever
787   the value of the property changes in the future.
788 
789   The callback \a f is expected to be a type that has a plain call operator () without any
790   parameters. This means that you can provide a C++ lambda expression, an std::function
791   or even a custom struct with a call operator.
792 
793   The returned property change handler object keeps track of the subscription. When it
794   goes out of scope, the callback is unsubscribed.
795 */
796 
797 /*!
798   \fn template <typename T> QtPrivate::QPropertyBase &QProperty<T>::propertyBase() const
799   \internal
800 */
801 
802 
803 /*!
804   \class QNotifiedProperty
805   \inmodule QtCore
806   \brief The QNotifiedProperty class is a template class that enables automatic property bindings
807          and invokes a callback function on the surrounding class when the value changes.
808 
809   \ingroup tools
810 
811   QNotifiedProperty\<T, Callback\> is a generic container that holds an
812   instance of T and behaves mostly like \l QProperty. The extra template
813   parameter is used to identify the surrounding class and a member function of
814   that class. The member function will be called whenever the value held by the
815   property changes.
816 
817   You can use QNotifiedProperty to port code that uses Q_PROPERTY. The getter
818   and setter are trivial to adapt for accessing a \l QProperty rather than the
819   plain value. In order to invoke the change signal on property changes, use
820   QNotifiedProperty and pass the change signal as callback.
821 
822   \code
823     class MyClass : public QObject
824     {
825         \Q_OBJECT
826         // Replacing: Q_PROPERTY(int x READ x WRITE setX NOTIFY xChanged)
827     public:
828         int x() const { return xProp; }
829         void setX(int x) { xProp = x; }
830 
831     signals:
832         void xChanged();
833 
834     private:
835         // Now you can set bindings on xProp and use it in other bindings.
836         QNotifiedProperty<int, &MyClass::xChanged> xProp;
837     };
838   \endcode
839 */
840 
841 /*!
842   \fn template <typename T, typename Class, void(Class::*Callback)()> QNotifiedProperty<T, Callback>::QNotifiedProperty()
843 
844   Constructs a property with a default constructed instance of T.
845 */
846 
847 /*!
848   \fn template <typename T, typename Class, void(Class::*Callback)()> explicit QNotifiedProperty<T, Callback>::QNotifiedProperty(const T &initialValue)
849 
850   Constructs a property with the provided \a initialValue.
851 */
852 
853 /*!
854   \fn template <typename T, typename Class, void(Class::*Callback)()> explicit QNotifiedProperty<T, Callback>::QNotifiedProperty(T &&initialValue)
855 
856   Move-Constructs a property with the provided \a initialValue.
857 */
858 
859 /*!
860   \fn template <typename T, typename Class, void(Class::*Callback)()> QNotifiedProperty<T, Callback>::QNotifiedProperty(Class *owner, const QPropertyBinding<T> &binding)
861 
862   Constructs a property that is tied to the provided \a binding expression. The
863   first time the property value is read, the binding is evaluated. Whenever a
864   dependency of the binding changes, the binding will be re-evaluated the next
865   time the value of this property is read. When the property value changes \a
866   owner is notified via the Callback function.
867 */
868 
869 /*!
870   \fn template <typename T, typename Class, void(Class::*Callback)()> QNotifiedProperty<T, Callback>::QNotifiedProperty(Class *owner, QPropertyBinding<T> &&binding)
871 
872   Constructs a property that is tied to the provided \a binding expression. The
873   first time the property value is read, the binding is evaluated. Whenever a
874   dependency of the binding changes, the binding will be re-evaluated the next
875   time the value of this property is read. When the property value changes \a
876   owner is notified via the Callback function.
877 */
878 
879 
880 /*!
881   \fn template <typename T, typename Class, void(Class::*Callback)()> template <typename Functor> QNotifiedProperty<T, Callback>::QNotifiedProperty(Class *owner, Functor &&f)
882 
883   Constructs a property that is tied to the provided binding expression \a f. The
884   first time the property value is read, the binding is evaluated. Whenever a
885   dependency of the binding changes, the binding will be re-evaluated the next
886   time the value of this property is read. When the property value changes \a
887   owner is notified via the Callback function.
888 */
889 
890 /*!
891   \fn template <typename T, typename Class, void(Class::*Callback)()> QNotifiedProperty<T, Callback>::~QNotifiedProperty()
892 
893   Destroys the property.
894 */
895 
896 /*!
897   \fn template <typename T, typename Class, void(Class::*Callback)()> T QNotifiedProperty<T, Callback>::value() const
898 
899   Returns the value of the property. This may evaluate a binding expression that
900   is tied to this property, before returning the value.
901 */
902 
903 /*!
904   \fn template <typename T, typename Class, void(Class::*Callback)()> QNotifiedProperty<T, Callback>::operator T() const
905 
906   Returns the value of the property. This may evaluate a binding expression that
907   is tied to this property, before returning the value.
908 */
909 
910 /*!
911   \fn template <typename T, typename Class, void(Class::*Callback)()> void QNotifiedProperty<T, Callback>::setValue(Class *owner, const T &newValue)
912 
913   Assigns \a newValue to this property and removes the property's associated
914   binding, if present. If the property value changes as a result, calls the
915   Callback function on \a owner.
916 */
917 
918 /*!
919   \fn template <typename T, typename Class, void(Class::*Callback)()> void QNotifiedProperty<T, Callback>::setValue(Class *owner, T &&newValue)
920   \overload
921 
922   Assigns \a newValue to this property and removes the property's associated
923   binding, if present. If the property value changes as a result, calls the
924   Callback function on \a owner.
925 */
926 
927 /*!
928   \fn template <typename T, typename Class, void(Class::*Callback)()> QPropertyBinding<T> QNotifiedProperty<T, Callback>::setBinding(Class *owner, const QPropertyBinding<T> &newBinding)
929 
930   Associates the value of this property with the provided \a newBinding
931   expression and returns the previously associated binding. The first time the
932   property value is read, the binding is evaluated. Whenever a dependency of the
933   binding changes, the binding will be re-evaluated the next time the value of
934   this property is read. When the property value changes \a owner is notified
935   via the Callback function.
936 */
937 
938 /*!
939   \fn template <typename T, typename Class, void(Class::*Callback)()> template <typename Functor> QPropertyBinding<T> QNotifiedProperty<T, Callback>::setBinding(Class *owner, Functor f)
940   \overload
941 
942   Associates the value of this property with the provided functor \a f and
943   returns the previously associated binding. The first time the property value
944   is read, the binding is evaluated by invoking the call operator () of \a f.
945   Whenever a dependency of the binding changes, the binding will be re-evaluated
946   the next time the value of this property is read. When the property value
947   changes \a owner is notified via the Callback function.
948 */
949 
950 /*!
951   \fn template <typename T, typename Class, void(Class::*Callback)()> QPropertyBinding<T> QNotifiedProperty<T, Callback>::setBinding(Class *owner, QPropertyBinding<T> &&newBinding)
952   \overload
953 
954   Associates the value of this property with the provided \a newBinding
955   expression and returns the previously associated binding. The first time the
956   property value is read, the binding is evaluated. Whenever a dependency of the
957   binding changes, the binding will be re-evaluated the next time the value of
958   this property is read. When the property value changes \a owner is notified
959   via the Callback function.
960 */
961 
962 /*!
963   \fn template <typename T, typename Class, void(Class::*Callback)()> QPropertyBinding<T> bool QNotifiedProperty<T, Callback>::setBinding(Class *owner, const QUntypedPropertyBinding &newBinding)
964   \overload
965 
966   Associates the value of this property with the provided \a newBinding
967   expression. The first time the property value is read, the binding is evaluated.
968   Whenever a dependency of the binding changes, the binding will be re-evaluated
969   the next time the value of this property is read. When the property value
970   changes \a owner is notified via the Callback function.
971 
972   Returns true if the type of this property is the same as the type the binding
973   function returns; false otherwise.
974 */
975 
976 /*!
977   \fn template <typename T, typename Class, void(Class::*Callback)()> bool QNotifiedProperty<T, Callback>::hasBinding() const
978 
979   Returns true if the property is associated with a binding; false otherwise.
980 */
981 
982 
983 /*!
984   \fn template <typename T, typename Class, void(Class::*Callback)()> QPropertyBinding<T> QNotifiedProperty<T, Callback>::binding() const
985 
986   Returns the binding expression that is associated with this property. A
987   default constructed QPropertyBinding<T> will be returned if no such
988   association exists.
989 */
990 
991 /*!
992   \fn template <typename T, typename Class, void(Class::*Callback)()> QPropertyBinding<T> QNotifiedProperty<T, Callback>::takeBinding()
993 
994   Disassociates the binding expression from this property and returns it. After
995   calling this function, the value of the property will only change if you
996   assign a new value to it, or when a new binding is set.
997 */
998 
999 /*!
1000   \fn template <typename T, typename Class, void(Class::*Callback)()> template <typename Functor> QPropertyChangeHandler<T, Functor> QNotifiedProperty<T, Callback>::onValueChanged(Functor f)
1001 
1002   Registers the given functor \a f as a callback that shall be called whenever
1003   the value of the property changes.
1004 
1005   The callback \a f is expected to be a type that has a plain call operator () without any
1006   parameters. This means that you can provide a C++ lambda expression, an std::function
1007   or even a custom struct with a call operator.
1008 
1009   The returned property change handler object keeps track of the registration. When it
1010   goes out of scope, the callback is de-registered.
1011 */
1012 
1013 /*!
1014   \fn template <typename T, typename Class, void(Class::*Callback)()> template <typename Functor> QPropertyChangeHandler<T, Functor> QNotifiedProperty<T, Callback>::subscribe(Functor f)
1015 
1016   Subscribes the given functor \a f as a callback that is called immediately and whenever
1017   the value of the property changes in the future.
1018 
1019   The callback \a f is expected to be a type that has a plain call operator () without any
1020   parameters. This means that you can provide a C++ lambda expression, an std::function
1021   or even a custom struct with a call operator.
1022 
1023   The returned property change handler object keeps track of the subscription. When it
1024   goes out of scope, the callback is unsubscribed.
1025 */
1026 
1027 /*!
1028   \fn template <typename T> QtPrivate::QPropertyBase &QNotifiedProperty<T, Callback>::propertyBase() const
1029   \internal
1030 */
1031 
1032 
1033 /*!
1034   \class QPropertyChangeHandler
1035   \inmodule QtCore
1036   \brief The QPropertyChangeHandler class controls the lifecycle of change callback installed on a QProperty.
1037 
1038   \ingroup tools
1039 
1040   QPropertyChangeHandler\<PropertyType, Functor\> is created when registering a
1041   callback on a QProperty to listen to changes to the property's value, using QProperty::onValueChanged
1042   and QProperty::subscribe. As long as the change handler is alive, the callback remains installed.
1043 
1044   A handler instance can be transferred between C++ scopes using move semantics.
1045 */
1046 
1047 /*!
1048   \class QPropertyAlias
1049   \inmodule QtCore
1050   \brief The QPropertyAlias class is a safe alias for a QProperty with same template parameter.
1051 
1052   \ingroup tools
1053 
1054   QPropertyAlias\<T\> wraps a pointer to a QProperty\<T\> and automatically
1055   invalidates itself when the QProperty\<T\> is destroyed. It forwards all
1056   method invocations to the wrapped property. For example:
1057 
1058   \code
1059     QProperty<QString> *name = new QProperty<QString>("John");
1060     QProperty<int> age(41);
1061 
1062     QPropertyAlias<QString> nameAlias(name);
1063     QPropertyAlias<int> ageAlias(&age);
1064 
1065     QPropertyAlias<QString> fullname;
1066     fullname.setBinding([&]() { return nameAlias.value() + " age:" + QString::number(ageAlias.value()); });
1067 
1068     qDebug() << fullname.value(); // Prints "Smith age: 41"
1069 
1070     *name = "Emma"; // Marks binding expression as dirty
1071 
1072     qDebug() << fullname.value(); // Re-evaluates the binding expression and prints "Emma age: 41"
1073 
1074     // Birthday is coming up
1075     ageAlias.setValue(age.value() + 1); // Writes the age property through the alias
1076 
1077     qDebug() << fullname.value(); // Re-evaluates the binding expression and prints "Emma age: 42"
1078 
1079     delete name; // Leaves the alias in an invalid, but accessible state
1080     nameAlias.setValue("Eve"); // Ignored: nameAlias carries a default-constructed QString now
1081 
1082     ageAlias.setValue(92);
1083     qDebug() << fullname.value(); // Re-evaluates the binding expression and prints " age: 92"
1084   \endcode
1085 */
1086 
1087 /*!
1088   \fn template <typename T> QPropertyAlias<T>::QPropertyAlias(QProperty<T> *property)
1089 
1090   Constructs a property alias for the given \a property.
1091 */
1092 
1093 /*!
1094   \fn template <typename T> explicit QPropertyAlias<T>::QPropertyAlias(QPropertyAlias<T> *alias)
1095 
1096   Constructs a property alias for the property aliased by \a alias.
1097 */
1098 
1099 /*!
1100   \fn template <typename T> T QPropertyAlias<T>::value() const
1101 
1102   Returns the value of the aliased property. This may evaluate a binding
1103   expression that is tied to the property, before returning the value.
1104 */
1105 
1106 /*!
1107   \fn template <typename T> QPropertyAlias<T>::operator T() const
1108 
1109   Returns the value of the aliased property. This may evaluate a binding
1110   expression that is tied to the property, before returning the value.
1111 */
1112 
1113 /*!
1114   \fn template <typename T> void QPropertyAlias<T>::setValue(const T &newValue)
1115 
1116   Assigns \a newValue to the aliased property and removes the property's
1117   associated binding, if present.
1118 */
1119 
1120 /*!
1121   \fn template <typename T> void QPropertyAlias<T>::setValue(T &&newValue)
1122   \overload
1123 
1124   Assigns \a newValue to the aliased property and removes the property's
1125   associated binding, if present.
1126 */
1127 
1128 /*!
1129   \fn template <typename T> QPropertyAlias<T> &QPropertyAlias<T>::operator=(const T &newValue)
1130 
1131   Assigns \a newValue to the aliased property and returns a reference to this
1132   QPropertyAlias.
1133 */
1134 
1135 /*!
1136   \fn template <typename T> QPropertyAlias<T> &QPropertyAlias<T>::operator=(T &&newValue)
1137   \overload
1138 
1139   Assigns \a newValue to the aliased property and returns a reference to this
1140   QPropertyAlias.
1141 */
1142 
1143 /*!
1144   \fn template <typename T> QPropertyAlias<T> &QPropertyAlias<T>::operator=(const QPropertyBinding<T> &newBinding)
1145   \overload
1146 
1147   Associates the value of the aliased property with the provided \a newBinding
1148   expression and returns a reference to this alias. The first time the
1149   property value is read, either from the property itself or from any alias, the
1150   binding is evaluated. Whenever a dependency of the binding changes, the
1151   binding will be re-evaluated the next time the value of this property is read.
1152 */
1153 
1154 /*!
1155   \fn template <typename T> QPropertyBinding<T> QPropertyAlias<T>::setBinding(const QPropertyBinding<T> &newBinding)
1156 
1157   Associates the value of the aliased property with the provided \a newBinding
1158   expression and returns any previous binding the associated with the aliased
1159   property. The first time the property value is read, either from the property
1160   itself or from any alias, the binding is evaluated. Whenever a dependency of
1161   the binding changes, the binding will be re-evaluated the next time the value
1162   of this property is read.
1163 
1164   Returns any previous binding associated with the property, or a
1165   default-constructed QPropertyBinding<T>.
1166 */
1167 
1168 /*!
1169   \fn template <typename T> QPropertyBinding<T> QPropertyAlias<T>::setBinding(QPropertyBinding<T> &&newBinding)
1170   \overload
1171 
1172   Associates the value of the aliased property with the provided \a newBinding
1173   expression and returns any previous binding the associated with the aliased
1174   property. The first time the property value is read, either from the property
1175   itself or from any alias, the binding is evaluated. Whenever a dependency of
1176   the binding changes, the binding will be re-evaluated the next time the value
1177   of this property is read.
1178 
1179   Returns any previous binding associated with the property, or a
1180   default-constructed QPropertyBinding<T>.
1181 */
1182 
1183 /*!
1184   \fn template <typename T> QPropertyBinding<T> bool QPropertyAlias<T>::setBinding(const QUntypedPropertyBinding &newBinding)
1185   \overload
1186 
1187   Associates the value of the aliased property with the provided \a newBinding
1188   expression. The first time the property value is read, either from the
1189   property itself or from any alias, the binding is evaluated. Whenever a
1190   dependency of the binding changes, the binding will be re-evaluated the next
1191   time the value of this property is read.
1192 
1193   Returns true if the type of this property is the same as the type the binding
1194   function returns; false otherwise.
1195 */
1196 
1197 /*!
1198   \fn template <typename T> template <typename Functor> QPropertyBinding<T> setBinding(Functor f)
1199   \overload
1200 
1201   Associates the value of the aliased property with the provided functor \a f
1202   expression. The first time the property value is read, either from the
1203   property itself or from any alias, the binding is evaluated. Whenever a
1204   dependency of the binding changes, the binding will be re-evaluated the next
1205   time the value of this property is read.
1206 
1207   Returns any previous binding associated with the property, or a
1208   default-constructed QPropertyBinding<T>.
1209 */
1210 
1211 /*!
1212   \fn template <typename T> bool QPropertyAlias<T>::hasBinding() const
1213 
1214   Returns true if the aliased property is associated with a binding; false
1215   otherwise.
1216 */
1217 
1218 /*!
1219   \fn template <typename T> QPropertyBinding<T> QPropertyAlias<T>::binding() const
1220 
1221   Returns the binding expression that is associated with the aliased property. A
1222   default constructed QPropertyBinding<T> will be returned if no such
1223   association exists.
1224 */
1225 
1226 /*!
1227   \fn template <typename T> QPropertyBinding<T> QPropertyAlias<T>::takeBinding()
1228 
1229   Disassociates the binding expression from the aliased property and returns it.
1230   After calling this function, the value of the property will only change if
1231   you assign a new value to it, or when a new binding is set.
1232 */
1233 
1234 /*!
1235   \fn template <typename T> template <typename Functor> QPropertyChangeHandler<T, Functor> QPropertyAlias<T>::onValueChanged(Functor f)
1236 
1237   Registers the given functor \a f as a callback that shall be called whenever
1238   the value of the aliased property changes.
1239 
1240   The callback \a f is expected to be a type that has a plain call operator () without any
1241   parameters. This means that you can provide a C++ lambda expression, an std::function
1242   or even a custom struct with a call operator.
1243 
1244   The returned property change handler object keeps track of the registration. When it
1245   goes out of scope, the callback is de-registered.
1246 */
1247 
1248 /*!
1249   \fn template <typename T> template <typename Functor> QPropertyChangeHandler<T, Functor> QPropertyAlias<T>::subscribe(Functor f)
1250 
1251   Subscribes the given functor \a f as a callback that is called immediately and whenever
1252   the value of the aliased property changes in the future.
1253 
1254   The callback \a f is expected to be a type that has a plain call operator () without any
1255   parameters. This means that you can provide a C++ lambda expression, an std::function
1256   or even a custom struct with a call operator.
1257 
1258   The returned property change handler object keeps track of the subscription. When it
1259   goes out of scope, the callback is unsubscribed.
1260 */
1261 
1262 /*!
1263   \fn template <typename T> bool QPropertyAlias<T>::isValid() const
1264 
1265   Returns true if the aliased property still exists; false otherwise.
1266 
1267   If the aliased property doesn't exist, all other method calls are ignored.
1268 */
1269 
1270 struct QBindingStorageData
1271 {
1272     size_t size = 0;
1273     size_t used = 0;
1274     // Pair[] pairs;
1275 };
1276 
1277 struct QBindingStoragePrivate
1278 {
1279     struct Pair {
1280         void *data;
1281         QPropertyBase bindingData;
1282     };
1283     static_assert(alignof(Pair) == alignof(void *));
1284     static_assert(alignof(size_t) == alignof(void *));
1285 
1286     QBindingStorageData *&d;
1287 
1288     static inline Pair *pairs(QBindingStorageData *dd) {
1289         Q_ASSERT(dd);
1290         return reinterpret_cast<Pair *>(dd + 1);
1291     }
1292     void reallocate(size_t newSize)
1293     {
1294         Q_ASSERT(!d || newSize > d->size);
1295         size_t allocSize = sizeof(QBindingStorageData) + newSize*sizeof(Pair);
1296         void *nd = malloc(allocSize);
1297         memset(nd, 0, allocSize);
1298         QBindingStorageData *newData = new (nd) QBindingStorageData;
1299         newData->size = newSize;
1300         if (!d) {
1301             d = newData;
1302             return;
1303         }
1304         newData->used = d->used;
1305         Pair *p = pairs(d);
1306         for (size_t i = 0; i < d->size; ++i) {
1307             if (p->data) {
1308                 Pair *pp = pairs(newData);
1309                 size_t index = qHash(p->data);
1310                 while (pp[index].data) {
1311                     ++index;
1312                     if (index == newData->size)
1313                         index = 0;
1314                 }
1315                 new (pp + index) Pair{p->data, QPropertyBase(std::move(p->bindingData), p->data)};
1316             }
1317             ++p;
1318         }
1319         // data has been moved, no need to call destructors on old Pairs
1320         free(d);
1321         d = newData;
1322     }
1323 
1324     QBindingStoragePrivate(QBindingStorageData *&_d) : d(_d) {}
1325 
1326     QPropertyBase *get(void *data)
1327     {
1328         if (!d)
1329             return nullptr;
1330         Q_ASSERT((d->size & (d->size - 1)) == 0); // size is a power of two
1331         size_t index = qHash(data) & (d->size - 1);
1332         Pair *p = pairs(d);
1333         while (p[index].data) {
1334             if (p[index].data == data)
1335                 return &p[index].bindingData;
1336             ++index;
1337             if (index == d->size)
1338                 index = 0;
1339         }
1340         return nullptr;
1341     }
1342     QPropertyBase *getAndCreate(void *data)
1343     {
1344         if (!d)
1345             reallocate(8);
1346         else if (d->used*2 >= d->size)
1347             reallocate(d->size*2);
1348         Q_ASSERT((d->size & (d->size - 1)) == 0); // size is a power of two
1349         size_t index = qHash(data) & (d->size - 1);
1350         Pair *p = pairs(d);
1351         while (p[index].data) {
1352             if (p[index].data == data)
1353                 return &p[index].bindingData;
1354             ++index;
1355             if (index == d->size)
1356                 index = 0;
1357         }
1358         ++d->used;
1359         new (p + index) Pair{data, QPropertyBase()};
1360         return &p[index].bindingData;
1361     }
1362 
1363     void destroy()
1364     {
1365         Pair *p = pairs(d);
1366         for (size_t i = 0; i < d->size; ++i) {
1367             if (p->data)
1368                 p->~Pair();
1369             ++p;
1370         }
1371         free(d);
1372     }
1373 };
1374 
1375 QBindingStorage::~QBindingStorage()
1376 {
1377     QBindingStoragePrivate(d).destroy();
1378 }
1379 
1380 void QBindingStorage::maybeUpdateBindingAndRegister(void *data)
1381 {
1382     auto storage = QPropertyBindingPrivate::currentlyEvaluatingBinding() ?
1383                 QBindingStoragePrivate(d).getAndCreate(data) :
1384                 QBindingStoragePrivate(d).get(data);
1385     if (!storage)
1386         return;
1387     if (auto *binding = storage->binding())
1388         binding->evaluateIfDirtyAndReturnTrueIfValueChanged();
1389     storage->registerWithCurrentlyEvaluatingBinding();
1390 }
1391 
1392 void QBindingStorage::removeBinding(void *data)
1393 {
1394     auto storage = QBindingStoragePrivate(d).get(data);
1395     if (!storage)
1396         return;
1397     storage->removeBinding();
1398 }
1399 
1400 QUntypedPropertyBinding QBindingStorage::setBinding(void *data, const QUntypedPropertyBinding &binding, QPropertyObserverCallback staticObserverCallback)
1401 {
1402     auto storage = QBindingStoragePrivate(d).getAndCreate(data);
1403     return storage->setBinding(binding, data, data, staticObserverCallback);
1404 }
1405 
1406 QUntypedPropertyBinding QBindingStorage::binding(void *data) const
1407 {
1408     auto storage = QBindingStoragePrivate(d).get(data);
1409     return QUntypedPropertyBinding(storage ? storage->binding() : nullptr);
1410 }
1411 
1412 void QBindingStorage::notifyObservers(void *data)
1413 {
1414     auto storage = QBindingStoragePrivate(d).get(data);
1415     if (!storage)
1416         return;
1417     storage->notifyObservers(data);
1418 }
1419 
1420 QPropertyBase *QBindingStorage::propertyBase(void *data, bool create)
1421 {
1422     auto storage = create ?
1423                 QBindingStoragePrivate(d).getAndCreate(data) :
1424                 QBindingStoragePrivate(d).get(data);
1425     return storage;
1426 }
1427 
1428 
1429 QT_END_NAMESPACE
