Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 /*!
42     \class QUrl
43     \inmodule QtCore
44 
45     \brief The QUrl class provides a convenient interface for working
46     with URLs.
47 
48     \reentrant
49     \ingroup io
50     \ingroup network
51     \ingroup shared
52 
53 
54     It can parse and construct URLs in both encoded and unencoded
55     form. QUrl also has support for internationalized domain names
56     (IDNs).
57 
58     The most common way to use QUrl is to initialize it via the
59     constructor by passing a QString. Otherwise, setUrl() can also
60     be used.
61 
62     URLs can be represented in two forms: encoded or unencoded. The
63     unencoded representation is suitable for showing to users, but
64     the encoded representation is typically what you would send to
65     a web server. For example, the unencoded URL
66     "http://b√ºhler.example.com/List of applicants.xml"
67     would be sent to the server as
68     "http://xn--bhler-kva.example.com/List%20of%20applicants.xml".
69 
70     A URL can also be constructed piece by piece by calling
71     setScheme(), setUserName(), setPassword(), setHost(), setPort(),
72     setPath(), setQuery() and setFragment(). Some convenience
73     functions are also available: setAuthority() sets the user name,
74     password, host and port. setUserInfo() sets the user name and
75     password at once.
76 
77     Call isValid() to check if the URL is valid. This can be done at any point
78     during the constructing of a URL. If isValid() returns \c false, you should
79     clear() the URL before proceeding, or start over by parsing a new URL with
80     setUrl().
81 
82     Constructing a query is particularly convenient through the use of the \l
83     QUrlQuery class and its methods QUrlQuery::setQueryItems(),
84     QUrlQuery::addQueryItem() and QUrlQuery::removeQueryItem(). Use
85     QUrlQuery::setQueryDelimiters() to customize the delimiters used for
86     generating the query string.
87 
88     For the convenience of generating encoded URL strings or query
89     strings, there are two static functions called
90     fromPercentEncoding() and toPercentEncoding() which deal with
91     percent encoding and decoding of QString objects.
92 
93     fromLocalFile() constructs a QUrl by parsing a local
94     file path. toLocalFile() converts a URL to a local file path.
95 
96     The human readable representation of the URL is fetched with
97     toString(). This representation is appropriate for displaying a
98     URL to a user in unencoded form. The encoded form however, as
99     returned by toEncoded(), is for internal use, passing to web
100     servers, mail clients and so on. Both forms are technically correct
101     and represent the same URL unambiguously -- in fact, passing either
102     form to QUrl's constructor or to setUrl() will yield the same QUrl
103     object.
104 
105     QUrl conforms to the URI specification from
106     \l{RFC 3986} (Uniform Resource Identifier: Generic Syntax), and includes
107     scheme extensions from \l{RFC 1738} (Uniform Resource Locators). Case
108     folding rules in QUrl conform to \l{RFC 3491} (Nameprep: A Stringprep
109     Profile for Internationalized Domain Names (IDN)). It is also compatible with the
110     \l{http://freedesktop.org/wiki/Specifications/file-uri-spec/}{file URI specification}
111     from freedesktop.org, provided that the locale encodes file names using
112     UTF-8 (required by IDN).
113 
114     \section2 Relative URLs vs Relative Paths
115 
116     Calling isRelative() will return whether or not the URL is relative.
117     A relative URL has no \l {scheme}. For example:
118 
119     \snippet code/src_corelib_io_qurl.cpp 8
120 
121     Notice that a URL can be absolute while containing a relative path, and
122     vice versa:
123 
124     \snippet code/src_corelib_io_qurl.cpp 9
125 
126     A relative URL can be resolved by passing it as an argument to resolved(),
127     which returns an absolute URL. isParentOf() is used for determining whether
128     one URL is a parent of another.
129 
130     \section2 Error checking
131 
132     QUrl is capable of detecting many errors in URLs while parsing it or when
133     components of the URL are set with individual setter methods (like
134     setScheme(), setHost() or setPath()). If the parsing or setter function is
135     successful, any previously recorded error conditions will be discarded.
136 
137     By default, QUrl setter methods operate in QUrl::TolerantMode, which means
138     they accept some common mistakes and mis-representation of data. An
139     alternate method of parsing is QUrl::StrictMode, which applies further
140     checks. See QUrl::ParsingMode for a description of the difference of the
141     parsing modes.
142 
143     QUrl only checks for conformance with the URL specification. It does not
144     try to verify that high-level protocol URLs are in the format they are
145     expected to be by handlers elsewhere. For example, the following URIs are
146     all considered valid by QUrl, even if they do not make sense when used:
147 
148     \list
149       \li "http:/filename.html"
150       \li "mailto://example.com"
151     \endlist
152 
153     When the parser encounters an error, it signals the event by making
154     isValid() return false and toString() / toEncoded() return an empty string.
155     If it is necessary to show the user the reason why the URL failed to parse,
156     the error condition can be obtained from QUrl by calling errorString().
157     Note that this message is highly technical and may not make sense to
158     end-users.
159 
160     QUrl is capable of recording only one error condition. If more than one
161     error is found, it is undefined which error is reported.
162 
163     \section2 Character Conversions
164 
165     Follow these rules to avoid erroneous character conversion when
166     dealing with URLs and strings:
167 
168     \list
169     \li When creating a QString to contain a URL from a QByteArray or a
170        char*, always use QString::fromUtf8().
171     \endlist
172 */
173 
174 /*!
175     \enum QUrl::ParsingMode
176 
177     The parsing mode controls the way QUrl parses strings.
178 
179     \value TolerantMode QUrl will try to correct some common errors in URLs.
180                         This mode is useful for parsing URLs coming from sources
181                         not known to be strictly standards-conforming.
182 
183     \value StrictMode Only valid URLs are accepted. This mode is useful for
184                       general URL validation.
185 
186     \value DecodedMode QUrl will interpret the URL component in the fully-decoded form,
187                        where percent characters stand for themselves, not as the beginning
188                        of a percent-encoded sequence. This mode is only valid for the
189                        setters setting components of a URL; it is not permitted in
190                        the QUrl constructor, in fromEncoded() or in setUrl().
191                        For more information on this mode, see the documentation for
192                        \l {QUrl::ComponentFormattingOption}{QUrl::FullyDecoded}.
193 
194     In TolerantMode, the parser has the following behaviour:
195 
196     \list
197 
198     \li Spaces and "%20": unencoded space characters will be accepted and will
199     be treated as equivalent to "%20".
200 
201     \li Single "%" characters: Any occurrences of a percent character "%" not
202     followed by exactly two hexadecimal characters (e.g., "13% coverage.html")
203     will be replaced by "%25". Note that one lone "%" character will trigger
204     the correction mode for all percent characters.
205 
206     \li Reserved and unreserved characters: An encoded URL should only
207     contain a few characters as literals; all other characters should
208     be percent-encoded. In TolerantMode, these characters will be
209     accepted if they are found in the URL:
210             space / double-quote / "<" / ">" / "\" /
211             "^" / "`" / "{" / "|" / "}"
212     Those same characters can be decoded again by passing QUrl::DecodeReserved
213     to toString() or toEncoded(). In the getters of individual components,
214     those characters are often returned in decoded form.
215 
216     \endlist
217 
218     When in StrictMode, if a parsing error is found, isValid() will return \c
219     false and errorString() will return a message describing the error.
220     If more than one error is detected, it is undefined which error gets
221     reported.
222 
223     Note that TolerantMode is not usually enough for parsing user input, which
224     often contains more errors and expectations than the parser can deal with.
225     When dealing with data coming directly from the user -- as opposed to data
226     coming from data-transfer sources, such as other programs -- it is
227     recommended to use fromUserInput().
228 
229     \sa fromUserInput(), setUrl(), toString(), toEncoded(), QUrl::FormattingOptions
230 */
231 
232 /*!
233     \enum QUrl::UrlFormattingOption
234 
235     The formatting options define how the URL is formatted when written out
236     as text.
237 
238     \value None The format of the URL is unchanged.
239     \value RemoveScheme  The scheme is removed from the URL.
240     \value RemovePassword  Any password in the URL is removed.
241     \value RemoveUserInfo  Any user information in the URL is removed.
242     \value RemovePort      Any specified port is removed from the URL.
243     \value RemoveAuthority
244     \value RemovePath   The URL's path is removed, leaving only the scheme,
245                         host address, and port (if present).
246     \value RemoveQuery  The query part of the URL (following a '?' character)
247                         is removed.
248     \value RemoveFragment
249     \value RemoveFilename The filename (i.e. everything after the last '/' in the path) is removed.
250             The trailing '/' is kept, unless StripTrailingSlash is set.
251             Only valid if RemovePath is not set.
252     \value PreferLocalFile If the URL is a local file according to isLocalFile()
253      and contains no query or fragment, a local file path is returned.
254     \value StripTrailingSlash  The trailing slash is removed from the path, if one is present.
255     \value NormalizePathSegments  Modifies the path to remove redundant directory separators,
256              and to resolve "."s and ".."s (as far as possible). For non-local paths, adjacent
257              slashes are preserved.
258 
259     Note that the case folding rules in \l{RFC 3491}{Nameprep}, which QUrl
260     conforms to, require host names to always be converted to lower case,
261     regardless of the Qt::FormattingOptions used.
262 
263     The options from QUrl::ComponentFormattingOptions are also possible.
264 
265     \sa QUrl::ComponentFormattingOptions
266 */
267 
268 /*!
269     \enum QUrl::ComponentFormattingOption
270     \since 5.0
271 
272     The component formatting options define how the components of an URL will
273     be formatted when written out as text. They can be combined with the
274     options from QUrl::FormattingOptions when used in toString() and
275     toEncoded().
276 
277     \value PrettyDecoded   The component is returned in a "pretty form", with
278                            most percent-encoded characters decoded. The exact
279                            behavior of PrettyDecoded varies from component to
280                            component and may also change from Qt release to Qt
281                            release. This is the default.
282 
283     \value EncodeSpaces    Leave space characters in their encoded form ("%20").
284 
285     \value EncodeUnicode   Leave non-US-ASCII characters encoded in their UTF-8
286                            percent-encoded form (e.g., "%C3%A9" for the U+00E9
287                            codepoint, LATIN SMALL LETTER E WITH ACUTE).
288 
289     \value EncodeDelimiters Leave certain delimiters in their encoded form, as
290                             would appear in the URL when the full URL is
291                             represented as text. The delimiters are affected
292                             by this option change from component to component.
293                             This flag has no effect in toString() or toEncoded().
294 
295     \value EncodeReserved  Leave US-ASCII characters not permitted in the URL by
296                            the specification in their encoded form. This is the
297                            default on toString() and toEncoded().
298 
299     \value DecodeReserved  Decode the US-ASCII characters that the URL specification
300                            does not allow to appear in the URL. This is the
301                            default on the getters of individual components.
302 
303     \value FullyEncoded    Leave all characters in their properly-encoded form,
304                            as this component would appear as part of a URL. When
305                            used with toString(), this produces a fully-compliant
306                            URL in QString form, exactly equal to the result of
307                            toEncoded()
308 
309     \value FullyDecoded    Attempt to decode as much as possible. For individual
310                            components of the URL, this decodes every percent
311                            encoding sequence, including control characters (U+0000
312                            to U+001F) and UTF-8 sequences found in percent-encoded form.
313                            Use of this mode may cause data loss, see below for more information.
314 
315     The values of EncodeReserved and DecodeReserved should not be used together
316     in one call. The behavior is undefined if that happens. They are provided
317     as separate values because the behavior of the "pretty mode" with regards
318     to reserved characters is different on certain components and specially on
319     the full URL.
320 
321     \section2 Full decoding
322 
323     The FullyDecoded mode is similar to the behavior of the functions returning
324     QString in Qt 4.x, in that every character represents itself and never has
325     any special meaning. This is true even for the percent character ('%'),
326     which should be interpreted to mean a literal percent, not the beginning of
327     a percent-encoded sequence. The same actual character, in all other
328     decoding modes, is represented by the sequence "%25".
329 
330     Whenever re-applying data obtained with QUrl::FullyDecoded into a QUrl,
331     care must be taken to use the QUrl::DecodedMode parameter to the setters
332     (like setPath() and setUserName()). Failure to do so may cause
333     re-interpretation of the percent character ('%') as the beginning of a
334     percent-encoded sequence.
335 
336     This mode is quite useful when portions of a URL are used in a non-URL
337     context. For example, to extract the username, password or file paths in an
338     FTP client application, the FullyDecoded mode should be used.
339 
340     This mode should be used with care, since there are two conditions that
341     cannot be reliably represented in the returned QString. They are:
342 
343     \list
344       \li \b{Non-UTF-8 sequences:} URLs may contain sequences of
345       percent-encoded characters that do not form valid UTF-8 sequences. Since
346       URLs need to be decoded using UTF-8, any decoder failure will result in
347       the QString containing one or more replacement characters where the
348       sequence existed.
349 
350       \li \b{Encoded delimiters:} URLs are also allowed to make a distinction
351       between a delimiter found in its literal form and its equivalent in
352       percent-encoded form. This is most commonly found in the query, but is
353       permitted in most parts of the URL.
354     \endlist
355 
356     The following example illustrates the problem:
357 
358     \snippet code/src_corelib_io_qurl.cpp 10
359 
360     If the two URLs were used via HTTP GET, the interpretation by the web
361     server would probably be different. In the first case, it would interpret
362     as one parameter, with a key of "q" and value "a+=b&c". In the second
363     case, it would probably interpret as two parameters, one with a key of "q"
364     and value "a =b", and the second with a key "c" and no value.
365 
366     \sa QUrl::FormattingOptions
367 */
368 
369 /*!
370     \enum QUrl::UserInputResolutionOption
371     \since 5.4
372 
373     The user input resolution options define how fromUserInput() should
374     interpret strings that could either be a relative path or the short
375     form of a HTTP URL. For instance \c{file.pl} can be either a local file
376     or the URL \c{http://file.pl}.
377 
378     \value DefaultResolution  The default resolution mechanism is to check
379                               whether a local file exists, in the working
380                               directory given to fromUserInput, and only
381                               return a local path in that case. Otherwise a URL
382                               is assumed.
383     \value AssumeLocalFile    This option makes fromUserInput() always return
384                               a local path unless the input contains a scheme, such as
385                               \c{http://file.pl}. This is useful for applications
386                               such as text editors, which are able to create
387                               the file if it doesn't exist.
388 
389     \sa fromUserInput()
390 */
391 
392 /*!
393     \enum  QUrl::AceProcessingOption
394     \since 6.3
395 
396     The ACE processing options control the way URLs are transformed to and from
397     ASCII-Compatible Encoding.
398 
399     \value IgnoreIDNWhitelist         Ignore the IDN whitelist when converting URLs
400                                       to Unicode.
401     \value AceTransitionalProcessing  Use transitional processing described in UTS #46.
402                                       This allows better compatibility with IDNA 2003
403                                       specification.
404 
405     The default is to use nontransitional processing and to allow non-ASCII
406     characters only inside URLs whose top-level domains are listed in the IDN whitelist.
407 
408     \sa toAce(), fromAce(), idnWhitelist()
409 */
410 
411 /*!
412     \fn QUrl::QUrl(QUrl &&other)
413 
414     Move-constructs a QUrl instance, making it point at the same
415     object that \a other was pointing to.
416 
417     \since 5.2
418 */
419 
420 /*!
421     \fn QUrl &QUrl::operator=(QUrl &&other)
422 
423     Move-assigns \a other to this QUrl instance.
424 
425     \since 5.2
426 */
427 
428 #include "qurl.h"
429 #include "qurl_p.h"
430 #include "qplatformdefs.h"
431 #include "qstring.h"
432 #include "qstringlist.h"
433 #include "qdebug.h"
434 #include "qhash.h"
435 #include "qdatastream.h"
436 #include "private/qipaddress_p.h"
437 #include "qurlquery.h"
438 #include "private/qdir_p.h"
439 
440 QT_BEGIN_NAMESPACE
441 
442 // in qstring.cpp:
443 void qt_from_latin1(char16_t *dst, const char *str, size_t size) noexcept;
444 
445 inline static bool isHex(char c)
446 {
447     c |= 0x20;
448     return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');
449 }
450 
451 static inline QString ftpScheme()
452 {
453     return QStringLiteral("ftp");
454 }
455 
456 static inline QString fileScheme()
457 {
458     return QStringLiteral("file");
459 }
460 
461 static inline QString webDavScheme()
462 {
463     return QStringLiteral("webdavs");
464 }
465 
466 static inline QString webDavSslTag()
467 {
468     return QStringLiteral("@SSL");
469 }
470 
471 
472 
473 inline QUrlPrivate::QUrlPrivate()
474     : ref(1), port(-1),
475       sectionIsPresent(0),
476       flags(0)
477 {
478 }
479 
480 inline QUrlPrivate::QUrlPrivate(const QUrlPrivate &copy)
481     : ref(1), port(copy.port),
482       scheme(copy.scheme),
483       userName(copy.userName),
484       password(copy.password),
485       host(copy.host),
486       path(copy.path),
487       query(copy.query),
488       fragment(copy.fragment),
489       errorOrContext(std::make_unique<Error>()),
490       sectionIsPresent(copy.sectionIsPresent),
491       flags(copy.flags),
492       hasContext(copy.hasContext)
493 {
494     if (copy.hasContext) {
495         errorOrContext.error.~unique_ptr();
496         errorOrContext.context = copy.errorOrContext.context;
497     } else if (copy.hasError()) {
498         errorOrContext.error = std::make_unique<Error>(*copy.error());
499     }
500 }
501 
502 inline QUrlPrivate::~QUrlPrivate() {
503     if (hasContext)
504         errorOrContext.context.~QUrl();
505     else
506         errorOrContext.error.~unique_ptr();
507 }
508 
509 
510 inline void QUrlPrivate::clearError()
511 {
512     if (hasError())
513         errorOrContext.error.reset();
514 }
515 
516 inline void QUrlPrivate::setError(ErrorCode errorCode, const QString &source, int supplement)
517 {
518     if (hasError()) {
519         // don't overwrite an error set in a previous section during parsing
520         return;
521     }
522     // but do overwrite any context we might have;
523     // once we are invalid it does not matter anymore
524     if (hasContext)
525         errorOrContext.context.~QUrl();
526     Error error;
527     error.code = errorCode;
528     error.source = source;
529     error.position = supplement;
530     errorOrContext.error = std::make_unique<Error>(std::move(error));
531 }
532 
533 // From RFC 3986, Appendix A Collected ABNF for URI
534 //    URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
535 //[...]
536 //    scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
537 //
538 //    authority     = [ userinfo "@" ] host [ ":" port ]
539 //    userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
540 //    host          = IP-literal / IPv4address / reg-name
541 //    port          = *DIGIT
542 //[...]
543 //    reg-name      = *( unreserved / pct-encoded / sub-delims )
544 //[..]
545 //    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
546 //
547 //    query         = *( pchar / "/" / "?" )
548 //
549 //    fragment      = *( pchar / "/" / "?" )
550 //
551 //    pct-encoded   = "%" HEXDIG HEXDIG
552 //
553 //    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
554 //    reserved      = gen-delims / sub-delims
555 //    gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
556 //    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
557 //                  / "*" / "+" / "," / ";" / "="
558 // the path component has a complex ABNF that basically boils down to
559 // slash-separated segments of "pchar"
560 
561 // The above is the strict definition of the URL components and we mostly
562 // adhere to it, with few exceptions. QUrl obeys the following behavior:
563 //  - percent-encoding sequences always use uppercase HEXDIG;
564 //  - unreserved characters are *always* decoded, no exceptions;
565 //  - the space character and bytes with the high bit set are controlled by
566 //    the EncodeSpaces and EncodeUnicode bits;
567 //  - control characters, the percent sign itself, and bytes with the high
568 //    bit set that don't form valid UTF-8 sequences are always encoded,
569 //    except in FullyDecoded mode;
570 //  - sub-delims are always left alone, except in FullyDecoded mode;
571 //  - gen-delim change behavior depending on which section of the URL (or
572 //    the entire URL) we're looking at; see below;
573 //  - characters not mentioned above, like "<", and ">", are usually
574 //    decoded in individual sections of the URL, but encoded when the full
575 //    URL is put together (we can change on subjective definition of
576 //    "pretty").
577 //
578 // The behavior for the delimiters bears some explanation. The spec says in
579 // section 2.2:
580 //     URIs that differ in the replacement of a reserved character with its
581 //     corresponding percent-encoded octet are not equivalent.
582 // (note: QUrl API mistakenly uses the "reserved" term, so we will refer to
583 // them here as "delimiters").
584 //
585 // For that reason, we cannot encode delimiters found in decoded form and we
586 // cannot decode the ones found in encoded form if that would change the
587 // interpretation. Conversely, we *can* perform the transformation if it would
588 // not change the interpretation. From the last component of a URL to the first,
589 // here are the gen-delims we can unambiguously transform when the field is
590 // taken in isolation:
591 //  - fragment: none, since it's the last
592 //  - query: "#" is unambiguous
593 //  - path: "#" and "?" are unambiguous
594 //  - host: completely special but never ambiguous, see setHost() below.
595 //  - password: the "#", "?", "/", "[", "]" and "@" characters are unambiguous
596 //  - username: the "#", "?", "/", "[", "]", "@", and ":" characters are unambiguous
597 //  - scheme: doesn't accept any delimiter, see setScheme() below.
598 //
599 // Internally, QUrl stores each component in the format that corresponds to the
600 // default mode (PrettyDecoded). It deviates from the "strict" FullyEncoded
601 // mode in the following way:
602 //  - spaces are decoded
603 //  - valid UTF-8 sequences are decoded
604 //  - gen-delims that can be unambiguously transformed are decoded
605 //  - characters controlled by DecodeReserved are often decoded, though this behavior
606 //    can change depending on the subjective definition of "pretty"
607 //
608 // Note that the list of gen-delims that we can transform is different for the
609 // user info (user name + password) and the authority (user info + host +
610 // port).
611 
612 
613 // list the recoding table modifications to be used with the recodeFromUser and
614 // appendToUser functions, according to the rules above. Spaces and UTF-8
615 // sequences are handled outside the tables.
616 
617 // the encodedXXX tables are run with the delimiters set to "leave" by default;
618 // the decodedXXX tables are run with the delimiters set to "decode" by default
619 // (except for the query, which doesn't use these functions)
620 
621 namespace {
622 template <typename T> constexpr ushort decode(T x) noexcept { return ushort(x); }
623 template <typename T> constexpr ushort leave(T x) noexcept { return ushort(0x100 | x); }
624 template <typename T> constexpr ushort encode(T x) noexcept { return ushort(0x200 | x); }
625 }
626 
627 static const ushort userNameInIsolation[] = {
628     decode(':'), // 0
629     decode('@'), // 1
630     decode(']'), // 2
631     decode('['), // 3
632     decode('/'), // 4
633     decode('?'), // 5
634     decode('#'), // 6
635 
636     decode('"'), // 7
637     decode('<'),
638     decode('>'),
639     decode('^'),
640     decode('\\'),
641     decode('|'),
642     decode('{'),
643     decode('}'),
644     0
645 };
646 static const ushort * const passwordInIsolation = userNameInIsolation + 1;
647 static const ushort * const pathInIsolation = userNameInIsolation + 5;
648 static const ushort * const queryInIsolation = userNameInIsolation + 6;
649 static const ushort * const fragmentInIsolation = userNameInIsolation + 7;
650 
651 static const ushort userNameInUserInfo[] =  {
652     encode(':'), // 0
653     decode('@'), // 1
654     decode(']'), // 2
655     decode('['), // 3
656     decode('/'), // 4
657     decode('?'), // 5
658     decode('#'), // 6
659 
660     decode('"'), // 7
661     decode('<'),
662     decode('>'),
663     decode('^'),
664     decode('\\'),
665     decode('|'),
666     decode('{'),
667     decode('}'),
668     0
669 };
670 static const ushort * const passwordInUserInfo = userNameInUserInfo + 1;
671 
672 static const ushort userNameInAuthority[] = {
673     encode(':'), // 0
674     encode('@'), // 1
675     encode(']'), // 2
676     encode('['), // 3
677     decode('/'), // 4
678     decode('?'), // 5
679     decode('#'), // 6
680 
681     decode('"'), // 7
682     decode('<'),
683     decode('>'),
684     decode('^'),
685     decode('\\'),
686     decode('|'),
687     decode('{'),
688     decode('}'),
689     0
690 };
691 static const ushort * const passwordInAuthority = userNameInAuthority + 1;
692 
693 static const ushort userNameInUrl[] = {
694     encode(':'), // 0
695     encode('@'), // 1
696     encode(']'), // 2
697     encode('['), // 3
698     encode('/'), // 4
699     encode('?'), // 5
700     encode('#'), // 6
701 
702     // no need to list encode(x) for the other characters
703     0
704 };
705 static const ushort * const passwordInUrl = userNameInUrl + 1;
706 static const ushort * const pathInUrl = userNameInUrl + 5;
707 static const ushort * const queryInUrl = userNameInUrl + 6;
708 static const ushort * const fragmentInUrl = userNameInUrl + 6;
709 
710 static inline void parseDecodedComponent(QString &data)
711 {
712     data.replace(QLatin1Char('%'), QLatin1String("%25"));
713 }
714 
715 static inline QString
716 recodeFromUser(const QString &input, const ushort *actions, int from, int to)
717 {
718     QString output;
719     const QChar *begin = input.constData() + from;
720     const QChar *end = input.constData() + to;
721     if (qt_urlRecode(output, QStringView{begin, end}, {}, actions))
722         return output;
723 
724     return input.mid(from, to - from);
725 }
726 
727 // appendXXXX functions: copy from the internal form to the external, user form.
728 // the internal value is stored in its PrettyDecoded form, so that case is easy.
729 static inline void appendToUser(QString &appendTo, QStringView value, QUrl::FormattingOptions options,
730                                 const ushort *actions)
731 {
732     // Test ComponentFormattingOptions, ignore FormattingOptions.
733     if ((options & 0xFFFF0000) == QUrl::PrettyDecoded) {
734         appendTo += value;
735         return;
736     }
737 
738     if (!qt_urlRecode(appendTo, value, options, actions))
739         appendTo += value;
740 }
741 
742 inline void QUrlPrivate::appendAuthority(QString &appendTo, QUrl::FormattingOptions options, Section appendingTo) const
743 {
744     if ((options & QUrl::RemoveUserInfo) != QUrl::RemoveUserInfo) {
745         appendUserInfo(appendTo, options, appendingTo);
746 
747         // add '@' only if we added anything
748         if (hasUserName() || (hasPassword() && (options & QUrl::RemovePassword) == 0))
749             appendTo += QLatin1Char('@');
750     }
751     appendHost(appendTo, options);
752     if (!(options & QUrl::RemovePort) && port != -1)
753         appendTo += QLatin1Char(':') + QString::number(port);
754 }
755 
756 inline void QUrlPrivate::appendUserInfo(QString &appendTo, QUrl::FormattingOptions options, Section appendingTo) const
757 {
758     if (Q_LIKELY(!hasUserInfo()))
759         return;
760 
761     const ushort *userNameActions;
762     const ushort *passwordActions;
763     if (options & QUrl::EncodeDelimiters) {
764         userNameActions = userNameInUrl;
765         passwordActions = passwordInUrl;
766     } else {
767         switch (appendingTo) {
768         case UserInfo:
769             userNameActions = userNameInUserInfo;
770             passwordActions = passwordInUserInfo;
771             break;
772 
773         case Authority:
774             userNameActions = userNameInAuthority;
775             passwordActions = passwordInAuthority;
776             break;
777 
778         case FullUrl:
779             userNameActions = userNameInUrl;
780             passwordActions = passwordInUrl;
781             break;
782 
783         default:
784             // can't happen
785             Q_UNREACHABLE();
786             break;
787         }
788     }
789 
790     if (!qt_urlRecode(appendTo, userName, options, userNameActions))
791         appendTo += userName;
792     if (options & QUrl::RemovePassword || !hasPassword()) {
793         return;
794     } else {
795         appendTo += QLatin1Char(':');
796         if (!qt_urlRecode(appendTo, password, options, passwordActions))
797             appendTo += password;
798     }
799 }
800 
801 inline void QUrlPrivate::appendUserName(QString &appendTo, QUrl::FormattingOptions options) const
802 {
803     // only called from QUrl::userName()
804     appendToUser(appendTo, userName, options,
805                  options & QUrl::EncodeDelimiters ? userNameInUrl : userNameInIsolation);
806 }
807 
808 inline void QUrlPrivate::appendPassword(QString &appendTo, QUrl::FormattingOptions options) const
809 {
810     // only called from QUrl::password()
811     appendToUser(appendTo, password, options,
812                  options & QUrl::EncodeDelimiters ? passwordInUrl : passwordInIsolation);
813 }
814 
815 inline void QUrlPrivate::appendPath(QString &appendTo, QUrl::FormattingOptions options, Section appendingTo) const
816 {
817     QString thePath = path;
818     if (options & QUrl::NormalizePathSegments) {
819         thePath = qt_normalizePathSegments(path, isLocalFile() ? QDirPrivate::DefaultNormalization : QDirPrivate::RemotePath);
820     }
821 
822     QStringView thePathView(thePath);
823     if (options & QUrl::RemoveFilename) {
824         const int slash = path.lastIndexOf(QLatin1Char('/'));
825         if (slash == -1)
826             return;
827         thePathView = QStringView{path}.left(slash + 1);
828     }
829     // check if we need to remove trailing slashes
830     if (options & QUrl::StripTrailingSlash) {
831         while (thePathView.length() > 1 && thePathView.endsWith(QLatin1Char('/')))
832             thePathView.chop(1);
833     }
834 
835     appendToUser(appendTo, thePathView, options,
836                  appendingTo == FullUrl || options & QUrl::EncodeDelimiters ? pathInUrl : pathInIsolation);
837 }
838 
839 inline void QUrlPrivate::appendFragment(QString &appendTo, QUrl::FormattingOptions options, Section appendingTo) const
840 {
841     appendToUser(appendTo, fragment, options,
842                  options & QUrl::EncodeDelimiters ? fragmentInUrl :
843                  appendingTo == FullUrl ? nullptr : fragmentInIsolation);
844 }
845 
846 inline void QUrlPrivate::appendQuery(QString &appendTo, QUrl::FormattingOptions options, Section appendingTo) const
847 {
848     appendToUser(appendTo, query, options,
849                  appendingTo == FullUrl || options & QUrl::EncodeDelimiters ? queryInUrl : queryInIsolation);
850 }
851 
852 // setXXX functions
853 
854 inline bool QUrlPrivate::setScheme(const QString &value, int len, bool doSetError)
855 {
856     // schemes are strictly RFC-compliant:
857     //    scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
858     // we also lowercase the scheme
859 
860     // schemes in URLs are not allowed to be empty, but they can be in
861     // "Relative URIs" which QUrl also supports. QUrl::setScheme does
862     // not call us with len == 0, so this can only be from parse()
863     scheme.clear();
864     if (len == 0)
865         return false;
866 
867     sectionIsPresent |= Scheme;
868 
869     // validate it:
870     int needsLowercasing = -1;
871     const ushort *p = value.utf16();
872     for (int i = 0; i < len; ++i) {
873         if (p[i] >= 'a' && p[i] <= 'z')
874             continue;
875         if (p[i] >= 'A' && p[i] <= 'Z') {
876             needsLowercasing = i;
877             continue;
878         }
879         if (i) {
880             if (p[i] >= '0' && p[i] <= '9')
881                 continue;
882             if (p[i] == '+' || p[i] == '-' || p[i] == '.')
883                 continue;
884         }
885 
886         // found something else
887         // don't call setError needlessly:
888         // if we've been called from parse(), it will try to recover
889         if (doSetError)
890             setError(InvalidSchemeError, value, i);
891         return false;
892     }
893 
894     scheme = value.left(len);
895 
896     if (needsLowercasing != -1) {
897         // schemes are ASCII only, so we don't need the full Unicode toLower
898         QChar *schemeData = scheme.data(); // force detaching here
899         for (int i = needsLowercasing; i >= 0; --i) {
900             ushort c = schemeData[i].unicode();
901             if (c >= 'A' && c <= 'Z')
902                 schemeData[i] = QChar(c + 0x20);
903         }
904     }
905 
906     // did we set to the file protocol?
907     if (scheme == fileScheme()
908 #ifdef Q_OS_WIN
909         || scheme == webDavScheme()
910 #endif
911        ) {
912         flags |= IsLocalFile;
913     } else {
914         flags &= ~IsLocalFile;
915     }
916     return true;
917 }
918 
919 inline void QUrlPrivate::setAuthority(const QString &auth, int from, int end, QUrl::ParsingMode mode)
920 {
921     sectionIsPresent &= ~Authority;
922     sectionIsPresent |= Host;
923     port = -1;
924 
925     // we never actually _loop_
926     while (from != end) {
927         int userInfoIndex = auth.indexOf(QLatin1Char('@'), from);
928         if (uint(userInfoIndex) < uint(end)) {
929             setUserInfo(auth, from, userInfoIndex);
930             if (mode == QUrl::StrictMode && !validateComponent(UserInfo, auth, from, userInfoIndex))
931                 break;
932             from = userInfoIndex + 1;
933         }
934 
935         int colonIndex = auth.lastIndexOf(QLatin1Char(':'), end - 1);
936         if (colonIndex < from)
937             colonIndex = -1;
938 
939         if (uint(colonIndex) < uint(end)) {
940             if (auth.at(from).unicode() == '[') {
941                 // check if colonIndex isn't inside the "[...]" part
942                 int closingBracket = auth.indexOf(QLatin1Char(']'), from);
943                 if (uint(closingBracket) > uint(colonIndex))
944                     colonIndex = -1;
945             }
946         }
947 
948         if (uint(colonIndex) < uint(end) - 1) {
949             // found a colon with digits after it
950             unsigned long x = 0;
951             for (int i = colonIndex + 1; i < end; ++i) {
952                 ushort c = auth.at(i).unicode();
953                 if (c >= '0' && c <= '9') {
954                     x *= 10;
955                     x += c - '0';
956                 } else {
957                     x = ulong(-1); // x != ushort(x)
958                     break;
959                 }
960             }
961             if (x == ushort(x)) {
962                 port = ushort(x);
963             } else {
964                 setError(InvalidPortError, auth, colonIndex + 1);
965                 if (mode == QUrl::StrictMode)
966                     break;
967             }
968         }
969 
970         setHost(auth, from, qMin<uint>(end, colonIndex), mode);
971         if (mode == QUrl::StrictMode && !validateComponent(Host, auth, from, qMin<uint>(end, colonIndex))) {
972             // clear host too
973             sectionIsPresent &= ~Authority;
974             break;
975         }
976 
977         // success
978         return;
979     }
980     // clear all sections but host
981     sectionIsPresent &= ~Authority | Host;
982     userName.clear();
983     password.clear();
984     host.clear();
985     port = -1;
986 }
987 
988 inline void QUrlPrivate::setUserInfo(const QString &userInfo, int from, int end)
989 {
990     int delimIndex = userInfo.indexOf(QLatin1Char(':'), from);
991     setUserName(userInfo, from, qMin<uint>(delimIndex, end));
992 
993     if (uint(delimIndex) >= uint(end)) {
994         password.clear();
995         sectionIsPresent &= ~Password;
996     } else {
997         setPassword(userInfo, delimIndex + 1, end);
998     }
999 }
1000 
1001 inline void QUrlPrivate::setUserName(const QString &value, int from, int end)
1002 {
1003     sectionIsPresent |= UserName;
1004     userName = recodeFromUser(value, userNameInIsolation, from, end);
1005 }
1006 
1007 inline void QUrlPrivate::setPassword(const QString &value, int from, int end)
1008 {
1009     sectionIsPresent |= Password;
1010     password = recodeFromUser(value, passwordInIsolation, from, end);
1011 }
1012 
1013 inline void QUrlPrivate::setPath(const QString &value, int from, int end)
1014 {
1015     // sectionIsPresent |= Path; // not used, save some cycles
1016     path = recodeFromUser(value, pathInIsolation, from, end);
1017 }
1018 
1019 inline void QUrlPrivate::setFragment(const QString &value, int from, int end)
1020 {
1021     sectionIsPresent |= Fragment;
1022     fragment = recodeFromUser(value, fragmentInIsolation, from, end);
1023 }
1024 
1025 inline void QUrlPrivate::setQuery(const QString &value, int from, int iend)
1026 {
1027     sectionIsPresent |= Query;
1028     query = recodeFromUser(value, queryInIsolation, from, iend);
1029 }
1030 
1031 // Host handling
1032 // The RFC says the host is:
1033 //    host          = IP-literal / IPv4address / reg-name
1034 //    IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
1035 //    IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
1036 //  [a strict definition of IPv6Address and IPv4Address]
1037 //     reg-name      = *( unreserved / pct-encoded / sub-delims )
1038 //
1039 // We deviate from the standard in all but IPvFuture. For IPvFuture we accept
1040 // and store only exactly what the RFC says we should. No percent-encoding is
1041 // permitted in this field, so Unicode characters and space aren't either.
1042 //
1043 // For IPv4 addresses, we accept broken addresses like inet_aton does (that is,
1044 // less than three dots). However, we correct the address to the proper form
1045 // and store the corrected address. After correction, we comply to the RFC and
1046 // it's exclusively composed of unreserved characters.
1047 //
1048 // For IPv6 addresses, we accept addresses including trailing (embedded) IPv4
1049 // addresses, the so-called v4-compat and v4-mapped addresses. We also store
1050 // those addresses like that in the hostname field, which violates the spec.
1051 // IPv6 hosts are stored with the square brackets in the QString. It also
1052 // requires no transformation in any way.
1053 //
1054 // As for registered names, it's the other way around: we accept only valid
1055 // hostnames as specified by STD 3 and IDNA. That means everything we accept is
1056 // valid in the RFC definition above, but there are many valid reg-names
1057 // according to the RFC that we do not accept in the name of security. Since we
1058 // do accept IDNA, reg-names are subject to ACE encoding and decoding, which is
1059 // specified by the DecodeUnicode flag. The hostname is stored in its Unicode form.
1060 
1061 inline void QUrlPrivate::appendHost(QString &appendTo, QUrl::FormattingOptions options) const
1062 {
1063     if (host.isEmpty())
1064         return;
1065     if (host.at(0).unicode() == '[') {
1066         // IPv6 addresses might contain a zone-id which needs to be recoded
1067         if (options != 0)
1068             if (qt_urlRecode(appendTo, host, options, nullptr))
1069                 return;
1070         appendTo += host;
1071     } else {
1072         // this is either an IPv4Address or a reg-name
1073         // if it is a reg-name, it is already stored in Unicode form
1074         if (options & QUrl::EncodeUnicode && !(options & 0x4000000))
1075             appendTo += qt_ACE_do(host, ToAceOnly, AllowLeadingDot, {});
1076         else
1077             appendTo += host;
1078     }
1079 }
1080 
1081 // the whole IPvFuture is passed and parsed here, including brackets;
1082 // returns null if the parsing was successful, or the QChar of the first failure
1083 static const QChar *parseIpFuture(QString &host, const QChar *begin, const QChar *end, QUrl::ParsingMode mode)
1084 {
1085     //    IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
1086     static const char acceptable[] =
1087             "!$&'()*+,;=" // sub-delims
1088             ":"           // ":"
1089             "-._~";       // unreserved
1090 
1091     // the brackets and the "v" have been checked
1092     const QChar *const origBegin = begin;
1093     if (begin[3].unicode() != '.')
1094         return &begin[3];
1095     if ((begin[2].unicode() >= 'A' && begin[2].unicode() <= 'F') ||
1096             (begin[2].unicode() >= 'a' && begin[2].unicode() <= 'f') ||
1097             (begin[2].unicode() >= '0' && begin[2].unicode() <= '9')) {
1098         // this is so unlikely that we'll just go down the slow path
1099         // decode the whole string, skipping the "[vH." and "]" which we already know to be there
1100         host += QStringView(begin, 4);
1101 
1102         // uppercase the version, if necessary
1103         if (begin[2].unicode() >= 'a')
1104             host[host.length() - 2] = QChar{begin[2].unicode() - 0x20};
1105 
1106         begin += 4;
1107         --end;
1108 
1109         QString decoded;
1110         if (mode == QUrl::TolerantMode && qt_urlRecode(decoded, QStringView{begin, end}, QUrl::FullyDecoded, nullptr)) {
1111             begin = decoded.constBegin();
1112             end = decoded.constEnd();
1113         }
1114 
1115         for ( ; begin != end; ++begin) {
1116             if (begin->unicode() >= 'A' && begin->unicode() <= 'Z')
1117                 host += *begin;
1118             else if (begin->unicode() >= 'a' && begin->unicode() <= 'z')
1119                 host += *begin;
1120             else if (begin->unicode() >= '0' && begin->unicode() <= '9')
1121                 host += *begin;
1122             else if (begin->unicode() < 0x80 && strchr(acceptable, begin->unicode()) != nullptr)
1123                 host += *begin;
1124             else
1125                 return decoded.isEmpty() ? begin : &origBegin[2];
1126         }
1127         host += QLatin1Char(']');
1128         return nullptr;
1129     }
1130     return &origBegin[2];
1131 }
1132 
1133 // ONLY the IPv6 address is parsed here, WITHOUT the brackets
1134 static const QChar *parseIp6(QString &host, const QChar *begin, const QChar *end, QUrl::ParsingMode mode)
1135 {
1136     QStringView decoded(begin, end);
1137     QString decodedBuffer;
1138     if (mode == QUrl::TolerantMode) {
1139         // this struct is kept in automatic storage because it's only 4 bytes
1140         const ushort decodeColon[] = { decode(':'), 0 };
1141         if (qt_urlRecode(decodedBuffer, decoded, QUrl::ComponentFormattingOption::PrettyDecoded, decodeColon))
1142             decoded = decodedBuffer;
1143     }
1144 
1145     const QStringView zoneIdIdentifier(u"%25");
1146     QIPAddressUtils::IPv6Address address;
1147     QStringView zoneId;
1148 
1149     int zoneIdPosition = decoded.indexOf(zoneIdIdentifier);
1150     if ((zoneIdPosition != -1) && (decoded.lastIndexOf(zoneIdIdentifier) == zoneIdPosition)) {
1151         zoneId = decoded.mid(zoneIdPosition + zoneIdIdentifier.size());
1152         decoded.truncate(zoneIdPosition);
1153 
1154         // was there anything after the zone ID separator?
1155         if (zoneId.isEmpty())
1156             return end;
1157     }
1158 
1159     // did the address become empty after removing the zone ID?
1160     // (it might have always been empty)
1161     if (decoded.isEmpty())
1162         return end;
1163 
1164     const QChar *ret = QIPAddressUtils::parseIp6(address, decoded.constBegin(), decoded.constEnd());
1165     if (ret)
1166         return begin + (ret - decoded.constBegin());
1167 
1168     host.reserve(host.size() + (end - begin) + 2);  // +2 for the brackets
1169     host += QLatin1Char('[');
1170     QIPAddressUtils::toString(host, address);
1171 
1172     if (!zoneId.isEmpty()) {
1173         host += zoneIdIdentifier;
1174         host += zoneId;
1175     }
1176     host += QLatin1Char(']');
1177     return nullptr;
1178 }
1179 
1180 inline bool QUrlPrivate::setHost(const QString &value, int from, int iend, QUrl::ParsingMode mode)
1181 {
1182     const QChar *begin = value.constData() + from;
1183     const QChar *end = value.constData() + iend;
1184 
1185     const int len = end - begin;
1186     host.clear();
1187     sectionIsPresent |= Host;
1188     if (len == 0)
1189         return true;
1190 
1191     if (begin[0].unicode() == '[') {
1192         // IPv6Address or IPvFuture
1193         // smallest IPv6 address is      "[::]"   (len = 4)
1194         // smallest IPvFuture address is "[v7.X]" (len = 6)
1195         if (end[-1].unicode() != ']') {
1196             setError(HostMissingEndBracket, value);
1197             return false;
1198         }
1199 
1200         if (len > 5 && begin[1].unicode() == 'v') {
1201             const QChar *c = parseIpFuture(host, begin, end, mode);
1202             if (c)
1203                 setError(InvalidIPvFutureError, value, c - value.constData());
1204             return !c;
1205         } else if (begin[1].unicode() == 'v') {
1206             setError(InvalidIPvFutureError, value, from);
1207         }
1208 
1209         const QChar *c = parseIp6(host, begin + 1, end - 1, mode);
1210         if (!c)
1211             return true;
1212 
1213         if (c == end - 1)
1214             setError(InvalidIPv6AddressError, value, from);
1215         else
1216             setError(InvalidCharacterInIPv6Error, value, c - value.constData());
1217         return false;
1218     }
1219 
1220     // check if it's an IPv4 address
1221     QIPAddressUtils::IPv4Address ip4;
1222     if (QIPAddressUtils::parseIp4(ip4, begin, end)) {
1223         // yes, it was
1224         QIPAddressUtils::toString(host, ip4);
1225         return true;
1226     }
1227 
1228     // This is probably a reg-name.
1229     // But it can also be an encoded string that, when decoded becomes one
1230     // of the types above.
1231     //
1232     // Two types of encoding are possible:
1233     //  percent encoding (e.g., "%31%30%2E%30%2E%30%2E%31" -> "10.0.0.1")
1234     //  Unicode encoding (some non-ASCII characters case-fold to digits
1235     //                    when nameprepping is done)
1236     //
1237     // The qt_ACE_do function below does IDNA normalization and the STD3 check.
1238     // That means a Unicode string may become an IPv4 address, but it cannot
1239     // produce a '[' or a '%'.
1240 
1241     // check for percent-encoding first
1242     QString s;
1243     if (mode == QUrl::TolerantMode && qt_urlRecode(s, QStringView{begin, end}, { }, nullptr)) {
1244         // something was decoded
1245         // anything encoded left?
1246         int pos = s.indexOf(QChar(0x25)); // '%'
1247         if (pos != -1) {
1248             setError(InvalidRegNameError, s, pos);
1249             return false;
1250         }
1251 
1252         // recurse
1253         return setHost(s, 0, s.length(), QUrl::StrictMode);
1254     }
1255 
1256     s = qt_ACE_do(value.mid(from, iend - from), NormalizeAce, ForbidLeadingDot, {});
1257     if (s.isEmpty()) {
1258         setError(InvalidRegNameError, value);
1259         return false;
1260     }
1261 
1262     // check IPv4 again
1263     if (QIPAddressUtils::parseIp4(ip4, s.constBegin(), s.constEnd())) {
1264         QIPAddressUtils::toString(host, ip4);
1265     } else {
1266         host = s;
1267     }
1268     return true;
1269 }
1270 
1271 inline void QUrlPrivate::parse(const QString &url, QUrl::ParsingMode parsingMode)
1272 {
1273     //   URI-reference = URI / relative-ref
1274     //   URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
1275     //   relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
1276     //   hier-part     = "//" authority path-abempty
1277     //                 / other path types
1278     //   relative-part = "//" authority path-abempty
1279     //                 /  other path types here
1280 
1281     sectionIsPresent = 0;
1282     flags = 0;
1283     clearError();
1284 
1285     // find the important delimiters
1286     int colon = -1;
1287     int question = -1;
1288     int hash = -1;
1289     const int len = url.length();
1290     const QChar *const begin = url.constData();
1291     const ushort *const data = reinterpret_cast<const ushort *>(begin);
1292 
1293     for (int i = 0; i < len; ++i) {
1294         uint uc = data[i];
1295         if (uc == '#' && hash == -1) {
1296             hash = i;
1297 
1298             // nothing more to be found
1299             break;
1300         }
1301 
1302         if (question == -1) {
1303             if (uc == ':' && colon == -1)
1304                 colon = i;
1305             else if (uc == '?')
1306                 question = i;
1307         }
1308     }
1309 
1310     // check if we have a scheme
1311     int hierStart;
1312     if (colon != -1 && setScheme(url, colon, /* don't set error */ false)) {
1313         hierStart = colon + 1;
1314     } else {
1315         // recover from a failed scheme: it might not have been a scheme at all
1316         scheme.clear();
1317         sectionIsPresent = 0;
1318         hierStart = 0;
1319     }
1320 
1321     int pathStart;
1322     int hierEnd = qMin<uint>(qMin<uint>(question, hash), len);
1323     if (hierEnd - hierStart >= 2 && data[hierStart] == '/' && data[hierStart + 1] == '/') {
1324         // we have an authority, it ends at the first slash after these
1325         int authorityEnd = hierEnd;
1326         for (int i = hierStart + 2; i < authorityEnd ; ++i) {
1327             if (data[i] == '/') {
1328                 authorityEnd = i;
1329                 break;
1330             }
1331         }
1332 
1333         setAuthority(url, hierStart + 2, authorityEnd, parsingMode);
1334 
1335         // even if we failed to set the authority properly, let's try to recover
1336         pathStart = authorityEnd;
1337         setPath(url, pathStart, hierEnd);
1338     } else {
1339         userName.clear();
1340         password.clear();
1341         host.clear();
1342         port = -1;
1343         pathStart = hierStart;
1344 
1345         if (hierStart < hierEnd)
1346             setPath(url, hierStart, hierEnd);
1347         else
1348             path.clear();
1349     }
1350 
1351     if (uint(question) < uint(hash))
1352         setQuery(url, question + 1, qMin<uint>(hash, len));
1353 
1354     if (hash != -1)
1355         setFragment(url, hash + 1, len);
1356 
1357     if (hasError() || parsingMode == QUrl::TolerantMode)
1358         return;
1359 
1360     // The parsing so far was partially tolerant of errors, except for the
1361     // scheme parser (which is always strict) and the authority (which was
1362     // executed in strict mode).
1363     // If we haven't found any errors so far, continue the strict-mode parsing
1364     // from the path component onwards.
1365 
1366     if (!validateComponent(Path, url, pathStart, hierEnd))
1367         return;
1368     if (uint(question) < uint(hash) && !validateComponent(Query, url, question + 1, qMin<uint>(hash, len)))
1369         return;
1370     if (hash != -1)
1371         validateComponent(Fragment, url, hash + 1, len);
1372 }
1373 
1374 QString QUrlPrivate::toLocalFile(QUrl::FormattingOptions options) const
1375 {
1376     QString tmp;
1377     QString ourPath;
1378     appendPath(ourPath, options, QUrlPrivate::Path);
1379 
1380     // magic for shared drive on windows
1381     if (!host.isEmpty()) {
1382         tmp = QLatin1String("//") + host;
1383 #ifdef Q_OS_WIN // QTBUG-42346, WebDAV is visible as local file on Windows only.
1384         if (scheme == webDavScheme())
1385             tmp += webDavSslTag();
1386 #endif
1387         if (!ourPath.isEmpty() && !ourPath.startsWith(QLatin1Char('/')))
1388             tmp += QLatin1Char('/');
1389         tmp += ourPath;
1390     } else {
1391         tmp = ourPath;
1392 #ifdef Q_OS_WIN
1393         // magic for drives on windows
1394         if (ourPath.length() > 2 && ourPath.at(0) == QLatin1Char('/') && ourPath.at(2) == QLatin1Char(':'))
1395             tmp.remove(0, 1);
1396 #endif
1397     }
1398     return tmp;
1399 }
1400 
1401 /*
1402     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.3: Merge paths
1403 
1404     Returns a merge of the current path with the relative path passed
1405     as argument.
1406 
1407     Note: \a relativePath is relative (does not start with '/').
1408 */
1409 inline QString QUrlPrivate::mergePaths(const QString &relativePath) const
1410 {
1411     // If the base URI has a defined authority component and an empty
1412     // path, then return a string consisting of "/" concatenated with
1413     // the reference's path; otherwise,
1414     if (!host.isEmpty() && path.isEmpty())
1415         return QLatin1Char('/') + relativePath;
1416 
1417     // Return a string consisting of the reference's path component
1418     // appended to all but the last segment of the base URI's path
1419     // (i.e., excluding any characters after the right-most "/" in the
1420     // base URI path, or excluding the entire base URI path if it does
1421     // not contain any "/" characters).
1422     QString newPath;
1423     if (!path.contains(QLatin1Char('/')))
1424         newPath = relativePath;
1425     else
1426         newPath = QStringView{path}.left(path.lastIndexOf(QLatin1Char('/')) + 1) + relativePath;
1427 
1428     return newPath;
1429 }
1430 
1431 /*
1432     From http://www.ietf.org/rfc/rfc3986.txt, 5.2.4: Remove dot segments
1433 
1434     Removes unnecessary ../ and ./ from the path. Used for normalizing
1435     the URL.
1436 */
1437 static void removeDotsFromPath(QString *path)
1438 {
1439     // The input buffer is initialized with the now-appended path
1440     // components and the output buffer is initialized to the empty
1441     // string.
1442     QChar *out = path->data();
1443     const QChar *in = out;
1444     const QChar *end = out + path->size();
1445 
1446     // If the input buffer consists only of
1447     // "." or "..", then remove that from the input
1448     // buffer;
1449     if (path->size() == 1 && in[0].unicode() == '.')
1450         ++in;
1451     else if (path->size() == 2 && in[0].unicode() == '.' && in[1].unicode() == '.')
1452         in += 2;
1453     // While the input buffer is not empty, loop:
1454     while (in < end) {
1455 
1456         // otherwise, if the input buffer begins with a prefix of "../" or "./",
1457         // then remove that prefix from the input buffer;
1458         if (path->size() >= 2 && in[0].unicode() == '.' && in[1].unicode() == '/')
1459             in += 2;
1460         else if (path->size() >= 3 && in[0].unicode() == '.'
1461                  && in[1].unicode() == '.' && in[2].unicode() == '/')
1462             in += 3;
1463 
1464         // otherwise, if the input buffer begins with a prefix of
1465         // "/./" or "/.", where "." is a complete path segment,
1466         // then replace that prefix with "/" in the input buffer;
1467         if (in <= end - 3 && in[0].unicode() == '/' && in[1].unicode() == '.'
1468                 && in[2].unicode() == '/') {
1469             in += 2;
1470             continue;
1471         } else if (in == end - 2 && in[0].unicode() == '/' && in[1].unicode() == '.') {
1472             *out++ = QLatin1Char('/');
1473             in += 2;
1474             break;
1475         }
1476 
1477         // otherwise, if the input buffer begins with a prefix
1478         // of "/../" or "/..", where ".." is a complete path
1479         // segment, then replace that prefix with "/" in the
1480         // input buffer and remove the last //segment and its
1481         // preceding "/" (if any) from the output buffer;
1482         if (in <= end - 4 && in[0].unicode() == '/' && in[1].unicode() == '.'
1483                 && in[2].unicode() == '.' && in[3].unicode() == '/') {
1484             while (out > path->constData() && (--out)->unicode() != '/')
1485                 ;
1486             if (out == path->constData() && out->unicode() != '/')
1487                 ++in;
1488             in += 3;
1489             continue;
1490         } else if (in == end - 3 && in[0].unicode() == '/' && in[1].unicode() == '.'
1491                    && in[2].unicode() == '.') {
1492             while (out > path->constData() && (--out)->unicode() != '/')
1493                 ;
1494             if (out->unicode() == '/')
1495                 ++out;
1496             in += 3;
1497             break;
1498         }
1499 
1500         // otherwise move the first path segment in
1501         // the input buffer to the end of the output
1502         // buffer, including the initial "/" character
1503         // (if any) and any subsequent characters up
1504         // to, but not including, the next "/"
1505         // character or the end of the input buffer.
1506         *out++ = *in++;
1507         while (in < end && in->unicode() != '/')
1508             *out++ = *in++;
1509     }
1510     path->truncate(out - path->constData());
1511 }
1512 
1513 inline QUrlPrivate::ErrorCode QUrlPrivate::validityError(QString *source, int *position) const
1514 {
1515     Q_ASSERT(!source == !position);
1516     if (hasError()) {
1517         if (source) {
1518             *source = error()->source;
1519             *position = error()->position;
1520         }
1521         return error()->code;
1522     }
1523 
1524     // There are three more cases of invalid URLs that QUrl recognizes and they
1525     // are only possible with constructed URLs (setXXX methods), not with
1526     // parsing. Therefore, they are tested here.
1527     //
1528     // Two cases are a non-empty path that doesn't start with a slash and:
1529     //  - with an authority
1530     //  - without an authority, without scheme but the path with a colon before
1531     //    the first slash
1532     // The third case is an empty authority and a non-empty path that starts
1533     // with "//".
1534     // Those cases are considered invalid because toString() would produce a URL
1535     // that wouldn't be parsed back to the same QUrl.
1536 
1537     if (path.isEmpty())
1538         return NoError;
1539     if (path.at(0) == QLatin1Char('/')) {
1540         if (hasAuthority() || path.length() == 1 || path.at(1) != QLatin1Char('/'))
1541             return NoError;
1542         if (source) {
1543             *source = path;
1544             *position = 0;
1545         }
1546         return AuthorityAbsentAndPathIsDoubleSlash;
1547     }
1548 
1549     if (sectionIsPresent & QUrlPrivate::Host) {
1550         if (source) {
1551             *source = path;
1552             *position = 0;
1553         }
1554         return AuthorityPresentAndPathIsRelative;
1555     }
1556     if (sectionIsPresent & QUrlPrivate::Scheme)
1557         return NoError;
1558 
1559     // check for a path of "text:text/"
1560     for (int i = 0; i < path.length(); ++i) {
1561         ushort c = path.at(i).unicode();
1562         if (c == '/') {
1563             // found the slash before the colon
1564             return NoError;
1565         }
1566         if (c == ':') {
1567             // found the colon before the slash, it's invalid
1568             if (source) {
1569                 *source = path;
1570                 *position = i;
1571             }
1572             return RelativeUrlPathContainsColonBeforeSlash;
1573         }
1574     }
1575     return NoError;
1576 }
1577 
1578 bool QUrlPrivate::validateComponent(QUrlPrivate::Section section, const QString &input,
1579                                     int begin, int end)
1580 {
1581     // What we need to look out for, that the regular parser tolerates:
1582     //  - percent signs not followed by two hex digits
1583     //  - forbidden characters, which should always appear encoded
1584     //    '"' / '<' / '>' / '\' / '^' / '`' / '{' / '|' / '}' / BKSP
1585     //    control characters
1586     //  - delimiters not allowed in certain positions
1587     //    . scheme: parser is already strict
1588     //    . user info: gen-delims except ":" disallowed ("/" / "?" / "#" / "[" / "]" / "@")
1589     //    . host: parser is stricter than the standard
1590     //    . port: parser is stricter than the standard
1591     //    . path: all delimiters allowed
1592     //    . fragment: all delimiters allowed
1593     //    . query: all delimiters allowed
1594     static const char forbidden[] = "\"<>\\^`{|}\x7F";
1595     static const char forbiddenUserInfo[] = ":/?#[]@";
1596 
1597     Q_ASSERT(section != Authority && section != Hierarchy && section != FullUrl);
1598 
1599     const ushort *const data = reinterpret_cast<const ushort *>(input.constData());
1600     for (uint i = uint(begin); i < uint(end); ++i) {
1601         uint uc = data[i];
1602         if (uc >= 0x80)
1603             continue;
1604 
1605         bool error = false;
1606         if ((uc == '%' && (uint(end) < i + 2 || !isHex(data[i + 1]) || !isHex(data[i + 2])))
1607                 || uc <= 0x20 || strchr(forbidden, uc)) {
1608             // found an error
1609             error = true;
1610         } else if (section & UserInfo) {
1611             if (section == UserInfo && strchr(forbiddenUserInfo + 1, uc))
1612                 error = true;
1613             else if (section != UserInfo && strchr(forbiddenUserInfo, uc))
1614                 error = true;
1615         }
1616 
1617         if (!error)
1618             continue;
1619 
1620         ErrorCode errorCode = ErrorCode(int(section) << 8);
1621         if (section == UserInfo) {
1622             // is it the user name or the password?
1623             errorCode = InvalidUserNameError;
1624             for (uint j = uint(begin); j < i; ++j)
1625                 if (data[j] == ':') {
1626                     errorCode = InvalidPasswordError;
1627                     break;
1628                 }
1629         }
1630 
1631         setError(errorCode, input, i);
1632         return false;
1633     }
1634 
1635     // no errors
1636     return true;
1637 }
1638 
1639 #if 0
1640 inline void QUrlPrivate::validate() const
1641 {
1642     QUrlPrivate *that = (QUrlPrivate *)this;
1643     that->encodedOriginal = that->toEncoded(); // may detach
1644     parse(ParseOnly);
1645 
1646     QURL_SETFLAG(that->stateFlags, Validated);
1647 
1648     if (!isValid)
1649         return;
1650 
1651     QString auth = authority(); // causes the non-encoded forms to be valid
1652 
1653     // authority() calls canonicalHost() which sets this
1654     if (!isHostValid)
1655         return;
1656 
1657     if (scheme == QLatin1String("mailto")) {
1658         if (!host.isEmpty() || port != -1 || !userName.isEmpty() || !password.isEmpty()) {
1659             that->isValid = false;
1660             that->errorInfo.setParams(0, QT_TRANSLATE_NOOP(QUrl, "expected empty host, username,"
1661                                                            "port and password"),
1662                                       0, 0);
1663         }
1664     } else if (scheme == ftpScheme() || scheme == httpScheme()) {
1665         if (host.isEmpty() && !(path.isEmpty() && encodedPath.isEmpty())) {
1666             that->isValid = false;
1667             that->errorInfo.setParams(0, QT_TRANSLATE_NOOP(QUrl, "the host is empty, but not the path"),
1668                                       0, 0);
1669         }
1670     }
1671 }
1672 #endif
1673 
1674 /*!
1675     \macro QT_NO_URL_CAST_FROM_STRING
1676     \relates QUrl
1677 
1678     Disables automatic conversions from QString (or char *) to QUrl.
1679 
1680     Compiling your code with this define is useful when you have a lot of
1681     code that uses QString for file names and you wish to convert it to
1682     use QUrl for network transparency. In any code that uses QUrl, it can
1683     help avoid missing QUrl::resolved() calls, and other misuses of
1684     QString to QUrl conversions.
1685 
1686     \oldcode
1687         url = filename; // probably not what you want
1688     \newcode
1689         url = QUrl::fromLocalFile(filename);
1690         url = baseurl.resolved(QUrl(filename));
1691     \endcode
1692 
1693     \sa QT_NO_CAST_FROM_ASCII
1694 */
1695 
1696 
1697 /*!
1698     Constructs a URL by parsing \a url. QUrl will automatically percent encode
1699     all characters that are not allowed in a URL and decode the percent-encoded
1700     sequences that represent an unreserved character (letters, digits, hyphens,
1701     underscores, dots and tildes). All other characters are left in their
1702     original forms.
1703 
1704     Parses the \a url using the parser mode \a parsingMode. In TolerantMode
1705     (the default), QUrl will correct certain mistakes, notably the presence of
1706     a percent character ('%') not followed by two hexadecimal digits, and it
1707     will accept any character in any position. In StrictMode, encoding mistakes
1708     will not be tolerated and QUrl will also check that certain forbidden
1709     characters are not present in unencoded form. If an error is detected in
1710     StrictMode, isValid() will return false. The parsing mode DecodedMode is not
1711     permitted in this context.
1712 
1713     Example:
1714 
1715     \snippet code/src_corelib_io_qurl.cpp 0
1716 
1717     To construct a URL from an encoded string, you can also use fromEncoded():
1718 
1719     \snippet code/src_corelib_io_qurl.cpp 1
1720 
1721     Both functions are equivalent and, in Qt 5, both functions accept encoded
1722     data. Usually, the choice of the QUrl constructor or setUrl() versus
1723     fromEncoded() will depend on the source data: the constructor and setUrl()
1724     take a QString, whereas fromEncoded takes a QByteArray.
1725 
1726     \sa setUrl(), fromEncoded(), TolerantMode
1727 */
1728 QUrl::QUrl(const QString &url, ParsingMode parsingMode) : d(nullptr)
1729 {
1730     setUrl(url, parsingMode);
1731 }
1732 
1733 /*!
1734     Constructs an empty QUrl object.
1735 */
1736 QUrl::QUrl() : d(nullptr)
1737 {
1738 }
1739 
1740 /*!
1741     Constructs a copy of \a other.
1742 */
1743 QUrl::QUrl(const QUrl &other) : d(other.d)
1744 {
1745     if (d)
1746         d->ref.ref();
1747 }
1748 
1749 /*!
1750     Destructor; called immediately before the object is deleted.
1751 */
1752 QUrl::~QUrl()
1753 {
1754     if (d && !d->ref.deref())
1755         delete d;
1756 }
1757 
1758 /*!
1759     Returns \c true if the URL is non-empty and valid; otherwise returns \c false.
1760 
1761     The URL is run through a conformance test. Every part of the URL
1762     must conform to the standard encoding rules of the URI standard
1763     for the URL to be reported as valid.
1764 
1765     \snippet code/src_corelib_io_qurl.cpp 2
1766 */
1767 bool QUrl::isValid() const
1768 {
1769     if (isEmpty()) {
1770         // also catches d == nullptr
1771         return false;
1772     }
1773     return d->validityError() == QUrlPrivate::NoError;
1774 }
1775 
1776 /*!
1777     Returns \c true if the URL has no data; otherwise returns \c false.
1778 
1779     \sa clear()
1780 */
1781 bool QUrl::isEmpty() const
1782 {
1783     if (!d) return true;
1784     return d->isEmpty();
1785 }
1786 
1787 /*!
1788     Resets the content of the QUrl. After calling this function, the
1789     QUrl is equal to one that has been constructed with the default
1790     empty constructor.
1791 
1792     \sa isEmpty()
1793 */
1794 void QUrl::clear()
1795 {
1796     if (d && !d->ref.deref())
1797         delete d;
1798     d = nullptr;
1799 }
1800 
1801 /*!
1802     Parses \a url and sets this object to that value. QUrl will automatically
1803     percent encode all characters that are not allowed in a URL and decode the
1804     percent-encoded sequences that represent an unreserved character (letters,
1805     digits, hyphens, underscores, dots and tildes). All other characters are
1806     left in their original forms.
1807 
1808     Parses the \a url using the parser mode \a parsingMode. In TolerantMode
1809     (the default), QUrl will correct certain mistakes, notably the presence of
1810     a percent character ('%') not followed by two hexadecimal digits, and it
1811     will accept any character in any position. In StrictMode, encoding mistakes
1812     will not be tolerated and QUrl will also check that certain forbidden
1813     characters are not present in unencoded form. If an error is detected in
1814     StrictMode, isValid() will return false. The parsing mode DecodedMode is
1815     not permitted in this context and will produce a run-time warning.
1816 
1817     \sa url(), toString()
1818 */
1819 void QUrl::setUrl(const QString &url, ParsingMode parsingMode)
1820 {
1821     if (parsingMode == DecodedMode) {
1822         qWarning("QUrl: QUrl::DecodedMode is not permitted when parsing a full URL");
1823     } else {
1824         detach();
1825         d->parse(url, parsingMode);
1826     }
1827 }
1828 
1829 /*!
1830     Sets the scheme of the URL to \a scheme. As a scheme can only
1831     contain ASCII characters, no conversion or decoding is done on the
1832     input. It must also start with an ASCII letter.
1833 
1834     The scheme describes the type (or protocol) of the URL. It's
1835     represented by one or more ASCII characters at the start the URL.
1836 
1837     A scheme is strictly \l {http://www.ietf.org/rfc/rfc3986.txt} {RFC 3986}-compliant:
1838         \tt {scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )}
1839 
1840     The following example shows a URL where the scheme is "ftp":
1841 
1842     \image qurl-authority2.png
1843 
1844     To set the scheme, the following call is used:
1845     \snippet code/src_corelib_io_qurl.cpp 11
1846 
1847     The scheme can also be empty, in which case the URL is interpreted
1848     as relative.
1849 
1850     \sa scheme(), isRelative()
1851 */
1852 void QUrl::setScheme(const QString &scheme)
1853 {
1854     detach();
1855     d->clearError();
1856     if (scheme.isEmpty()) {
1857         // schemes are not allowed to be empty
1858         d->sectionIsPresent &= ~QUrlPrivate::Scheme;
1859         d->flags &= ~QUrlPrivate::IsLocalFile;
1860         d->scheme.clear();
1861     } else {
1862         d->setScheme(scheme, scheme.length(), /* do set error */ true);
1863     }
1864 }
1865 
1866 /*!
1867     Returns the scheme of the URL. If an empty string is returned,
1868     this means the scheme is undefined and the URL is then relative.
1869 
1870     The scheme can only contain US-ASCII letters or digits, which means it
1871     cannot contain any character that would otherwise require encoding.
1872     Additionally, schemes are always returned in lowercase form.
1873 
1874     \sa setScheme(), isRelative()
1875 */
1876 QString QUrl::scheme() const
1877 {
1878     if (!d) return QString();
1879 
1880     return d->scheme;
1881 }
1882 
1883 /*!
1884     Sets the authority of the URL to \a authority.
1885 
1886     The authority of a URL is the combination of user info, a host
1887     name and a port. All of these elements are optional; an empty
1888     authority is therefore valid.
1889 
1890     The user info and host are separated by a '@', and the host and
1891     port are separated by a ':'. If the user info is empty, the '@'
1892     must be omitted; although a stray ':' is permitted if the port is
1893     empty.
1894 
1895     The following example shows a valid authority string:
1896 
1897     \image qurl-authority.png
1898 
1899     The \a authority data is interpreted according to \a mode: in StrictMode,
1900     any '%' characters must be followed by exactly two hexadecimal characters
1901     and some characters (including space) are not allowed in undecoded form. In
1902     TolerantMode (the default), all characters are accepted in undecoded form
1903     and the tolerant parser will correct stray '%' not followed by two hex
1904     characters.
1905 
1906     This function does not allow \a mode to be QUrl::DecodedMode. To set fully
1907     decoded data, call setUserName(), setPassword(), setHost() and setPort()
1908     individually.
1909 
1910     \sa setUserInfo(), setHost(), setPort()
1911 */
1912 void QUrl::setAuthority(const QString &authority, ParsingMode mode)
1913 {
1914     detach();
1915     d->clearError();
1916 
1917     if (mode == DecodedMode) {
1918         qWarning("QUrl::setAuthority(): QUrl::DecodedMode is not permitted in this function");
1919         return;
1920     }
1921 
1922     d->setAuthority(authority, 0, authority.length(), mode);
1923     if (authority.isNull()) {
1924         // QUrlPrivate::setAuthority cleared almost everything
1925         // but it leaves the Host bit set
1926         d->sectionIsPresent &= ~QUrlPrivate::Authority;
1927     }
1928 }
1929 
1930 /*!
1931     Returns the authority of the URL if it is defined; otherwise
1932     an empty string is returned.
1933 
1934     This function returns an unambiguous value, which may contain that
1935     characters still percent-encoded, plus some control sequences not
1936     representable in decoded form in QString.
1937 
1938     The \a options argument controls how to format the user info component. The
1939     value of QUrl::FullyDecoded is not permitted in this function. If you need
1940     to obtain fully decoded data, call userName(), password(), host() and
1941     port() individually.
1942 
1943     \sa setAuthority(), userInfo(), userName(), password(), host(), port()
1944 */
1945 QString QUrl::authority(ComponentFormattingOptions options) const
1946 {
1947     QString result;
1948     if (!d)
1949         return result;
1950 
1951     if (options == QUrl::FullyDecoded) {
1952         qWarning("QUrl::authority(): QUrl::FullyDecoded is not permitted in this function");
1953         return result;
1954     }
1955 
1956     d->appendAuthority(result, options, QUrlPrivate::Authority);
1957     return result;
1958 }
1959 
1960 /*!
1961     Sets the user info of the URL to \a userInfo. The user info is an
1962     optional part of the authority of the URL, as described in
1963     setAuthority().
1964 
1965     The user info consists of a user name and optionally a password,
1966     separated by a ':'. If the password is empty, the colon must be
1967     omitted. The following example shows a valid user info string:
1968 
1969     \image qurl-authority3.png
1970 
1971     The \a userInfo data is interpreted according to \a mode: in StrictMode,
1972     any '%' characters must be followed by exactly two hexadecimal characters
1973     and some characters (including space) are not allowed in undecoded form. In
1974     TolerantMode (the default), all characters are accepted in undecoded form
1975     and the tolerant parser will correct stray '%' not followed by two hex
1976     characters.
1977 
1978     This function does not allow \a mode to be QUrl::DecodedMode. To set fully
1979     decoded data, call setUserName() and setPassword() individually.
1980 
1981     \sa userInfo(), setUserName(), setPassword(), setAuthority()
1982 */
1983 void QUrl::setUserInfo(const QString &userInfo, ParsingMode mode)
1984 {
1985     detach();
1986     d->clearError();
1987     QString trimmed = userInfo.trimmed();
1988     if (mode == DecodedMode) {
1989         qWarning("QUrl::setUserInfo(): QUrl::DecodedMode is not permitted in this function");
1990         return;
1991     }
1992 
1993     d->setUserInfo(trimmed, 0, trimmed.length());
1994     if (userInfo.isNull()) {
1995         // QUrlPrivate::setUserInfo cleared almost everything
1996         // but it leaves the UserName bit set
1997         d->sectionIsPresent &= ~QUrlPrivate::UserInfo;
1998     } else if (mode == StrictMode && !d->validateComponent(QUrlPrivate::UserInfo, userInfo)) {
1999         d->sectionIsPresent &= ~QUrlPrivate::UserInfo;
2000         d->userName.clear();
2001         d->password.clear();
2002     }
2003 }
2004 
2005 /*!
2006     Returns the user info of the URL, or an empty string if the user
2007     info is undefined.
2008 
2009     This function returns an unambiguous value, which may contain that
2010     characters still percent-encoded, plus some control sequences not
2011     representable in decoded form in QString.
2012 
2013     The \a options argument controls how to format the user info component. The
2014     value of QUrl::FullyDecoded is not permitted in this function. If you need
2015     to obtain fully decoded data, call userName() and password() individually.
2016 
2017     \sa setUserInfo(), userName(), password(), authority()
2018 */
2019 QString QUrl::userInfo(ComponentFormattingOptions options) const
2020 {
2021     QString result;
2022     if (!d)
2023         return result;
2024 
2025     if (options == QUrl::FullyDecoded) {
2026         qWarning("QUrl::userInfo(): QUrl::FullyDecoded is not permitted in this function");
2027         return result;
2028     }
2029 
2030     d->appendUserInfo(result, options, QUrlPrivate::UserInfo);
2031     return result;
2032 }
2033 
2034 /*!
2035     Sets the URL's user name to \a userName. The \a userName is part
2036     of the user info element in the authority of the URL, as described
2037     in setUserInfo().
2038 
2039     The \a userName data is interpreted according to \a mode: in StrictMode,
2040     any '%' characters must be followed by exactly two hexadecimal characters
2041     and some characters (including space) are not allowed in undecoded form. In
2042     TolerantMode (the default), all characters are accepted in undecoded form
2043     and the tolerant parser will correct stray '%' not followed by two hex
2044     characters. In DecodedMode, '%' stand for themselves and encoded characters
2045     are not possible.
2046 
2047     QUrl::DecodedMode should be used when setting the user name from a data
2048     source which is not a URL, such as a password dialog shown to the user or
2049     with a user name obtained by calling userName() with the QUrl::FullyDecoded
2050     formatting option.
2051 
2052     \sa userName(), setUserInfo()
2053 */
2054 void QUrl::setUserName(const QString &userName, ParsingMode mode)
2055 {
2056     detach();
2057     d->clearError();
2058 
2059     QString data = userName;
2060     if (mode == DecodedMode) {
2061         parseDecodedComponent(data);
2062         mode = TolerantMode;
2063     }
2064 
2065     d->setUserName(data, 0, data.length());
2066     if (userName.isNull())
2067         d->sectionIsPresent &= ~QUrlPrivate::UserName;
2068     else if (mode == StrictMode && !d->validateComponent(QUrlPrivate::UserName, userName))
2069         d->userName.clear();
2070 }
2071 
2072 /*!
2073     Returns the user name of the URL if it is defined; otherwise
2074     an empty string is returned.
2075 
2076     The \a options argument controls how to format the user name component. All
2077     values produce an unambiguous result. With QUrl::FullyDecoded, all
2078     percent-encoded sequences are decoded; otherwise, the returned value may
2079     contain some percent-encoded sequences for some control sequences not
2080     representable in decoded form in QString.
2081 
2082     Note that QUrl::FullyDecoded may cause data loss if those non-representable
2083     sequences are present. It is recommended to use that value when the result
2084     will be used in a non-URL context, such as setting in QAuthenticator or
2085     negotiating a login.
2086 
2087     \sa setUserName(), userInfo()
2088 */
2089 QString QUrl::userName(ComponentFormattingOptions options) const
2090 {
2091     QString result;
2092     if (d)
2093         d->appendUserName(result, options);
2094     return result;
2095 }
2096 
2097 /*!
2098     Sets the URL's password to \a password. The \a password is part of
2099     the user info element in the authority of the URL, as described in
2100     setUserInfo().
2101 
2102     The \a password data is interpreted according to \a mode: in StrictMode,
2103     any '%' characters must be followed by exactly two hexadecimal characters
2104     and some characters (including space) are not allowed in undecoded form. In
2105     TolerantMode, all characters are accepted in undecoded form and the
2106     tolerant parser will correct stray '%' not followed by two hex characters.
2107     In DecodedMode, '%' stand for themselves and encoded characters are not
2108     possible.
2109 
2110     QUrl::DecodedMode should be used when setting the password from a data
2111     source which is not a URL, such as a password dialog shown to the user or
2112     with a password obtained by calling password() with the QUrl::FullyDecoded
2113     formatting option.
2114 
2115     \sa password(), setUserInfo()
2116 */
2117 void QUrl::setPassword(const QString &password, ParsingMode mode)
2118 {
2119     detach();
2120     d->clearError();
2121 
2122     QString data = password;
2123     if (mode == DecodedMode) {
2124         parseDecodedComponent(data);
2125         mode = TolerantMode;
2126     }
2127 
2128     d->setPassword(data, 0, data.length());
2129     if (password.isNull())
2130         d->sectionIsPresent &= ~QUrlPrivate::Password;
2131     else if (mode == StrictMode && !d->validateComponent(QUrlPrivate::Password, password))
2132         d->password.clear();
2133 }
2134 
2135 /*!
2136     Returns the password of the URL if it is defined; otherwise
2137     an empty string is returned.
2138 
2139     The \a options argument controls how to format the user name component. All
2140     values produce an unambiguous result. With QUrl::FullyDecoded, all
2141     percent-encoded sequences are decoded; otherwise, the returned value may
2142     contain some percent-encoded sequences for some control sequences not
2143     representable in decoded form in QString.
2144 
2145     Note that QUrl::FullyDecoded may cause data loss if those non-representable
2146     sequences are present. It is recommended to use that value when the result
2147     will be used in a non-URL context, such as setting in QAuthenticator or
2148     negotiating a login.
2149 
2150     \sa setPassword()
2151 */
2152 QString QUrl::password(ComponentFormattingOptions options) const
2153 {
2154     QString result;
2155     if (d)
2156         d->appendPassword(result, options);
2157     return result;
2158 }
2159 
2160 /*!
2161     Sets the host of the URL to \a host. The host is part of the
2162     authority.
2163 
2164     The \a host data is interpreted according to \a mode: in StrictMode,
2165     any '%' characters must be followed by exactly two hexadecimal characters
2166     and some characters (including space) are not allowed in undecoded form. In
2167     TolerantMode, all characters are accepted in undecoded form and the
2168     tolerant parser will correct stray '%' not followed by two hex characters.
2169     In DecodedMode, '%' stand for themselves and encoded characters are not
2170     possible.
2171 
2172     Note that, in all cases, the result of the parsing must be a valid hostname
2173     according to STD 3 rules, as modified by the Internationalized Resource
2174     Identifiers specification (RFC 3987). Invalid hostnames are not permitted
2175     and will cause isValid() to become false.
2176 
2177     \sa host(), setAuthority()
2178 */
2179 void QUrl::setHost(const QString &host, ParsingMode mode)
2180 {
2181     detach();
2182     d->clearError();
2183 
2184     QString data = host;
2185     if (mode == DecodedMode) {
2186         parseDecodedComponent(data);
2187         mode = TolerantMode;
2188     }
2189 
2190     if (d->setHost(data, 0, data.length(), mode)) {
2191         if (host.isNull())
2192             d->sectionIsPresent &= ~QUrlPrivate::Host;
2193     } else if (!data.startsWith(QLatin1Char('['))) {
2194         // setHost failed, it might be IPv6 or IPvFuture in need of bracketing
2195         Q_ASSERT(d->error());
2196 
2197         data.prepend(QLatin1Char('['));
2198         data.append(QLatin1Char(']'));
2199         if (!d->setHost(data, 0, data.length(), mode)) {
2200             // failed again
2201             if (data.contains(QLatin1Char(':'))) {
2202                 // source data contains ':', so it's an IPv6 error
2203                 d->error()->code = QUrlPrivate::InvalidIPv6AddressError;
2204             }
2205         } else {
2206             // succeeded
2207             d->clearError();
2208         }
2209     }
2210 }
2211 
2212 /*!
2213     Returns the host of the URL if it is defined; otherwise
2214     an empty string is returned.
2215 
2216     The \a options argument controls how the hostname will be formatted. The
2217     QUrl::EncodeUnicode option will cause this function to return the hostname
2218     in the ASCII-Compatible Encoding (ACE) form, which is suitable for use in
2219     channels that are not 8-bit clean or that require the legacy hostname (such
2220     as DNS requests or in HTTP request headers). If that flag is not present,
2221     this function returns the International Domain Name (IDN) in Unicode form,
2222     according to the list of permissible top-level domains (see
2223     idnWhitelist()).
2224 
2225     All other flags are ignored. Host names cannot contain control or percent
2226     characters, so the returned value can be considered fully decoded.
2227 
2228     \sa setHost(), idnWhitelist(), setIdnWhitelist(), authority()
2229 */
2230 QString QUrl::host(ComponentFormattingOptions options) const
2231 {
2232     QString result;
2233     if (d) {
2234         d->appendHost(result, options);
2235         if (result.startsWith(QLatin1Char('[')))
2236             result = result.mid(1, result.length() - 2);
2237     }
2238     return result;
2239 }
2240 
2241 /*!
2242     Sets the port of the URL to \a port. The port is part of the
2243     authority of the URL, as described in setAuthority().
2244 
2245     \a port must be between 0 and 65535 inclusive. Setting the
2246     port to -1 indicates that the port is unspecified.
2247 */
2248 void QUrl::setPort(int port)
2249 {
2250     detach();
2251     d->clearError();
2252 
2253     if (port < -1 || port > 65535) {
2254         d->setError(QUrlPrivate::InvalidPortError, QString::number(port), 0);
2255         port = -1;
2256     }
2257 
2258     d->port = port;
2259     if (port != -1)
2260         d->sectionIsPresent |= QUrlPrivate::Host;
2261 }
2262 
2263 /*!
2264     \since 4.1
2265 
2266     Returns the port of the URL, or \a defaultPort if the port is
2267     unspecified.
2268 
2269     Example:
2270 
2271     \snippet code/src_corelib_io_qurl.cpp 3
2272 */
2273 int QUrl::port(int defaultPort) const
2274 {
2275     if (!d) return defaultPort;
2276     return d->port == -1 ? defaultPort : d->port;
2277 }
2278 
2279 /*!
2280     Sets the path of the URL to \a path. The path is the part of the
2281     URL that comes after the authority but before the query string.
2282 
2283     \image qurl-ftppath.png
2284 
2285     For non-hierarchical schemes, the path will be everything
2286     following the scheme declaration, as in the following example:
2287 
2288     \image qurl-mailtopath.png
2289 
2290     The \a path data is interpreted according to \a mode: in StrictMode,
2291     any '%' characters must be followed by exactly two hexadecimal characters
2292     and some characters (including space) are not allowed in undecoded form. In
2293     TolerantMode, all characters are accepted in undecoded form and the
2294     tolerant parser will correct stray '%' not followed by two hex characters.
2295     In DecodedMode, '%' stand for themselves and encoded characters are not
2296     possible.
2297 
2298     QUrl::DecodedMode should be used when setting the path from a data source
2299     which is not a URL, such as a dialog shown to the user or with a path
2300     obtained by calling path() with the QUrl::FullyDecoded formatting option.
2301 
2302     \sa path()
2303 */
2304 void QUrl::setPath(const QString &path, ParsingMode mode)
2305 {
2306     detach();
2307     d->clearError();
2308 
2309     QString data = path;
2310     if (mode == DecodedMode) {
2311         parseDecodedComponent(data);
2312         mode = TolerantMode;
2313     }
2314 
2315     d->setPath(data, 0, data.length());
2316 
2317     // optimized out, since there is no path delimiter
2318 //    if (path.isNull())
2319 //        d->sectionIsPresent &= ~QUrlPrivate::Path;
2320 //    else
2321     if (mode == StrictMode && !d->validateComponent(QUrlPrivate::Path, path))
2322         d->path.clear();
2323 }
2324 
2325 /*!
2326     Returns the path of the URL.
2327 
2328     \snippet code/src_corelib_io_qurl.cpp 12
2329 
2330     The \a options argument controls how to format the path component. All
2331     values produce an unambiguous result. With QUrl::FullyDecoded, all
2332     percent-encoded sequences are decoded; otherwise, the returned value may
2333     contain some percent-encoded sequences for some control sequences not
2334     representable in decoded form in QString.
2335 
2336     Note that QUrl::FullyDecoded may cause data loss if those non-representable
2337     sequences are present. It is recommended to use that value when the result
2338     will be used in a non-URL context, such as sending to an FTP server.
2339 
2340     An example of data loss is when you have non-Unicode percent-encoded sequences
2341     and use FullyDecoded (the default):
2342 
2343     \snippet code/src_corelib_io_qurl.cpp 13
2344 
2345     In this example, there will be some level of data loss because the \c %FF cannot
2346     be converted.
2347 
2348     Data loss can also occur when the path contains sub-delimiters (such as \c +):
2349 
2350     \snippet code/src_corelib_io_qurl.cpp 14
2351 
2352     Other decoding examples:
2353 
2354     \snippet code/src_corelib_io_qurl.cpp 15
2355 
2356     \sa setPath()
2357 */
2358 QString QUrl::path(ComponentFormattingOptions options) const
2359 {
2360     QString result;
2361     if (d)
2362         d->appendPath(result, options, QUrlPrivate::Path);
2363     return result;
2364 }
2365 
2366 /*!
2367     \since 5.2
2368 
2369     Returns the name of the file, excluding the directory path.
2370 
2371     Note that, if this QUrl object is given a path ending in a slash, the name of the file is considered empty.
2372 
2373     If the path doesn't contain any slash, it is fully returned as the fileName.
2374 
2375     Example:
2376 
2377     \snippet code/src_corelib_io_qurl.cpp 7
2378 
2379     The \a options argument controls how to format the file name component. All
2380     values produce an unambiguous result. With QUrl::FullyDecoded, all
2381     percent-encoded sequences are decoded; otherwise, the returned value may
2382     contain some percent-encoded sequences for some control sequences not
2383     representable in decoded form in QString.
2384 
2385     \sa path()
2386 */
2387 QString QUrl::fileName(ComponentFormattingOptions options) const
2388 {
2389     const QString ourPath = path(options);
2390     const int slash = ourPath.lastIndexOf(QLatin1Char('/'));
2391     if (slash == -1)
2392         return ourPath;
2393     return ourPath.mid(slash + 1);
2394 }
2395 
2396 /*!
2397     \since 4.2
2398 
2399     Returns \c true if this URL contains a Query (i.e., if ? was seen on it).
2400 
2401     \sa setQuery(), query(), hasFragment()
2402 */
2403 bool QUrl::hasQuery() const
2404 {
2405     if (!d) return false;
2406     return d->hasQuery();
2407 }
2408 
2409 /*!
2410     Sets the query string of the URL to \a query.
2411 
2412     This function is useful if you need to pass a query string that
2413     does not fit into the key-value pattern, or that uses a different
2414     scheme for encoding special characters than what is suggested by
2415     QUrl.
2416 
2417     Passing a value of QString() to \a query (a null QString) unsets
2418     the query completely. However, passing a value of QString("")
2419     will set the query to an empty value, as if the original URL
2420     had a lone "?".
2421 
2422     The \a query data is interpreted according to \a mode: in StrictMode,
2423     any '%' characters must be followed by exactly two hexadecimal characters
2424     and some characters (including space) are not allowed in undecoded form. In
2425     TolerantMode, all characters are accepted in undecoded form and the
2426     tolerant parser will correct stray '%' not followed by two hex characters.
2427     In DecodedMode, '%' stand for themselves and encoded characters are not
2428     possible.
2429 
2430     Query strings often contain percent-encoded sequences, so use of
2431     DecodedMode is discouraged. One special sequence to be aware of is that of
2432     the plus character ('+'). QUrl does not convert spaces to plus characters,
2433     even though HTML forms posted by web browsers do. In order to represent an
2434     actual plus character in a query, the sequence "%2B" is usually used. This
2435     function will leave "%2B" sequences untouched in TolerantMode or
2436     StrictMode.
2437 
2438     \sa query(), hasQuery()
2439 */
2440 void QUrl::setQuery(const QString &query, ParsingMode mode)
2441 {
2442     detach();
2443     d->clearError();
2444 
2445     QString data = query;
2446     if (mode == DecodedMode) {
2447         parseDecodedComponent(data);
2448         mode = TolerantMode;
2449     }
2450 
2451     d->setQuery(data, 0, data.length());
2452     if (query.isNull())
2453         d->sectionIsPresent &= ~QUrlPrivate::Query;
2454     else if (mode == StrictMode && !d->validateComponent(QUrlPrivate::Query, query))
2455         d->query.clear();
2456 }
2457 
2458 /*!
2459     \overload
2460     \since 5.0
2461     Sets the query string of the URL to \a query.
2462 
2463     This function reconstructs the query string from the QUrlQuery object and
2464     sets on this QUrl object. This function does not have parsing parameters
2465     because the QUrlQuery contains data that is already parsed.
2466 
2467     \sa query(), hasQuery()
2468 */
2469 void QUrl::setQuery(const QUrlQuery &query)
2470 {
2471     detach();
2472     d->clearError();
2473 
2474     // we know the data is in the right format
2475     d->query = query.toString();
2476     if (query.isEmpty())
2477         d->sectionIsPresent &= ~QUrlPrivate::Query;
2478     else
2479         d->sectionIsPresent |= QUrlPrivate::Query;
2480 }
2481 
2482 /*!
2483     Returns the query string of the URL if there's a query string, or an empty
2484     result if not. To determine if the parsed URL contained a query string, use
2485     hasQuery().
2486 
2487     The \a options argument controls how to format the query component. All
2488     values produce an unambiguous result. With QUrl::FullyDecoded, all
2489     percent-encoded sequences are decoded; otherwise, the returned value may
2490     contain some percent-encoded sequences for some control sequences not
2491     representable in decoded form in QString.
2492 
2493     Note that use of QUrl::FullyDecoded in queries is discouraged, as queries
2494     often contain data that is supposed to remain percent-encoded, including
2495     the use of the "%2B" sequence to represent a plus character ('+').
2496 
2497     \sa setQuery(), hasQuery()
2498 */
2499 QString QUrl::query(ComponentFormattingOptions options) const
2500 {
2501     QString result;
2502     if (d) {
2503         d->appendQuery(result, options, QUrlPrivate::Query);
2504         if (d->hasQuery() && result.isNull())
2505             result.detach();
2506     }
2507     return result;
2508 }
2509 
2510 /*!
2511     Sets the fragment of the URL to \a fragment. The fragment is the
2512     last part of the URL, represented by a '#' followed by a string of
2513     characters. It is typically used in HTTP for referring to a
2514     certain link or point on a page:
2515 
2516     \image qurl-fragment.png
2517 
2518     The fragment is sometimes also referred to as the URL "reference".
2519 
2520     Passing an argument of QString() (a null QString) will unset the fragment.
2521     Passing an argument of QString("") (an empty but not null QString) will set the
2522     fragment to an empty string (as if the original URL had a lone "#").
2523 
2524     The \a fragment data is interpreted according to \a mode: in StrictMode,
2525     any '%' characters must be followed by exactly two hexadecimal characters
2526     and some characters (including space) are not allowed in undecoded form. In
2527     TolerantMode, all characters are accepted in undecoded form and the
2528     tolerant parser will correct stray '%' not followed by two hex characters.
2529     In DecodedMode, '%' stand for themselves and encoded characters are not
2530     possible.
2531 
2532     QUrl::DecodedMode should be used when setting the fragment from a data
2533     source which is not a URL or with a fragment obtained by calling
2534     fragment() with the QUrl::FullyDecoded formatting option.
2535 
2536     \sa fragment(), hasFragment()
2537 */
2538 void QUrl::setFragment(const QString &fragment, ParsingMode mode)
2539 {
2540     detach();
2541     d->clearError();
2542 
2543     QString data = fragment;
2544     if (mode == DecodedMode) {
2545         parseDecodedComponent(data);
2546         mode = TolerantMode;
2547     }
2548 
2549     d->setFragment(data, 0, data.length());
2550     if (fragment.isNull())
2551         d->sectionIsPresent &= ~QUrlPrivate::Fragment;
2552     else if (mode == StrictMode && !d->validateComponent(QUrlPrivate::Fragment, fragment))
2553         d->fragment.clear();
2554 }
2555 
2556 /*!
2557     Returns the fragment of the URL. To determine if the parsed URL contained a
2558     fragment, use hasFragment().
2559 
2560     The \a options argument controls how to format the fragment component. All
2561     values produce an unambiguous result. With QUrl::FullyDecoded, all
2562     percent-encoded sequences are decoded; otherwise, the returned value may
2563     contain some percent-encoded sequences for some control sequences not
2564     representable in decoded form in QString.
2565 
2566     Note that QUrl::FullyDecoded may cause data loss if those non-representable
2567     sequences are present. It is recommended to use that value when the result
2568     will be used in a non-URL context.
2569 
2570     \sa setFragment(), hasFragment()
2571 */
2572 QString QUrl::fragment(ComponentFormattingOptions options) const
2573 {
2574     QString result;
2575     if (d) {
2576         d->appendFragment(result, options, QUrlPrivate::Fragment);
2577         if (d->hasFragment() && result.isNull())
2578             result.detach();
2579     }
2580     return result;
2581 }
2582 
2583 /*!
2584     \since 4.2
2585 
2586     Returns \c true if this URL contains a fragment (i.e., if # was seen on it).
2587 
2588     \sa fragment(), setFragment()
2589 */
2590 bool QUrl::hasFragment() const
2591 {
2592     if (!d) return false;
2593     return d->hasFragment();
2594 }
2595 
2596 /*!
2597     Returns the result of the merge of this URL with \a relative. This
2598     URL is used as a base to convert \a relative to an absolute URL.
2599 
2600     If \a relative is not a relative URL, this function will return \a
2601     relative directly. Otherwise, the paths of the two URLs are
2602     merged, and the new URL returned has the scheme and authority of
2603     the base URL, but with the merged path, as in the following
2604     example:
2605 
2606     \snippet code/src_corelib_io_qurl.cpp 5
2607 
2608     Calling resolved() with ".." returns a QUrl whose directory is
2609     one level higher than the original. Similarly, calling resolved()
2610     with "../.." removes two levels from the path. If \a relative is
2611     "/", the path becomes "/".
2612 
2613     \sa isRelative()
2614 */
2615 QUrl QUrl::resolved(const QUrl &relative) const
2616 {
2617     if (!d) return relative;
2618     if (!relative.d) return *this;
2619 
2620     QUrl t;
2621     if (!relative.d->scheme.isEmpty()) {
2622         t = relative;
2623         t.detach();
2624     } else {
2625         if (relative.d->hasAuthority()) {
2626             t = relative;
2627             t.detach();
2628         } else {
2629             t.d = new QUrlPrivate;
2630 
2631             // copy the authority
2632             t.d->userName = d->userName;
2633             t.d->password = d->password;
2634             t.d->host = d->host;
2635             t.d->port = d->port;
2636             t.d->sectionIsPresent = d->sectionIsPresent & QUrlPrivate::Authority;
2637 
2638             if (relative.d->path.isEmpty()) {
2639                 t.d->path = d->path;
2640                 if (relative.d->hasQuery()) {
2641                     t.d->query = relative.d->query;
2642                     t.d->sectionIsPresent |= QUrlPrivate::Query;
2643                 } else if (d->hasQuery()) {
2644                     t.d->query = d->query;
2645                     t.d->sectionIsPresent |= QUrlPrivate::Query;
2646                 }
2647             } else {
2648                 t.d->path = relative.d->path.startsWith(QLatin1Char('/'))
2649                             ? relative.d->path
2650                             : d->mergePaths(relative.d->path);
2651                 if (relative.d->hasQuery()) {
2652                     t.d->query = relative.d->query;
2653                     t.d->sectionIsPresent |= QUrlPrivate::Query;
2654                 }
2655             }
2656         }
2657         t.d->scheme = d->scheme;
2658         if (d->hasScheme())
2659             t.d->sectionIsPresent |= QUrlPrivate::Scheme;
2660         else
2661             t.d->sectionIsPresent &= ~QUrlPrivate::Scheme;
2662         t.d->flags |= d->flags & QUrlPrivate::IsLocalFile;
2663     }
2664     t.d->fragment = relative.d->fragment;
2665     if (relative.d->hasFragment())
2666         t.d->sectionIsPresent |= QUrlPrivate::Fragment;
2667     else
2668         t.d->sectionIsPresent &= ~QUrlPrivate::Fragment;
2669 
2670     removeDotsFromPath(&t.d->path);
2671 
2672 #if defined(QURL_DEBUG)
2673     qDebug("QUrl(\"%ls\").resolved(\"%ls\") = \"%ls\"",
2674            qUtf16Printable(url()),
2675            qUtf16Printable(relative.url()),
2676            qUtf16Printable(t.url()));
2677 #endif
2678     return t;
2679 }
2680 
2681 /*!
2682     Returns \c true if the URL is relative; otherwise returns \c false. A URL is
2683     relative reference if its scheme is undefined; this function is therefore
2684     equivalent to calling scheme().isEmpty().
2685 
2686     Relative references are defined in RFC 3986 section 4.2.
2687 
2688     \sa {Relative URLs vs Relative Paths}
2689 */
2690 bool QUrl::isRelative() const
2691 {
2692     if (!d) return true;
2693     return !d->hasScheme();
2694 }
2695 
2696 /*!
2697     Returns a string representation of the URL. The output can be customized by
2698     passing flags with \a options. The option QUrl::FullyDecoded is not
2699     permitted in this function since it would generate ambiguous data.
2700 
2701     The resulting QString can be passed back to a QUrl later on.
2702 
2703     Synonym for toString(options).
2704 
2705     \sa FormattingOptions, toEncoded(), toString()
2706 */
2707 QString QUrl::url(FormattingOptions options) const
2708 {
2709     return toString(options);
2710 }
2711 
2712 /*!
2713     Returns a string representation of the URL. The output can be customized by
2714     passing flags with \a options. The option QUrl::FullyDecoded is not
2715     permitted in this function since it would generate ambiguous data.
2716 
2717     The default formatting option is \l{QUrl::FormattingOptions}{PrettyDecoded}.
2718 
2719     \sa FormattingOptions, url(), setUrl()
2720 */
2721 QString QUrl::toString(FormattingOptions options) const
2722 {
2723     QString url;
2724     if (!isValid()) {
2725         // also catches isEmpty()
2726         return url;
2727     }
2728     if ((options & QUrl::FullyDecoded) == QUrl::FullyDecoded) {
2729         qWarning("QUrl: QUrl::FullyDecoded is not permitted when reconstructing the full URL");
2730         options &= ~QUrl::FullyDecoded;
2731         //options |= QUrl::PrettyDecoded; // no-op, value is 0
2732     }
2733 
2734     // return just the path if:
2735     //  - QUrl::PreferLocalFile is passed
2736     //  - QUrl::RemovePath isn't passed (rather stupid if the user did...)
2737     //  - there's no query or fragment to return
2738     //    that is, either they aren't present, or we're removing them
2739     //  - it's a local file
2740     if (options.testFlag(QUrl::PreferLocalFile) && !options.testFlag(QUrl::RemovePath)
2741             && (!d->hasQuery() || options.testFlag(QUrl::RemoveQuery))
2742             && (!d->hasFragment() || options.testFlag(QUrl::RemoveFragment))
2743             && isLocalFile()) {
2744         url = d->toLocalFile(options | QUrl::FullyDecoded);
2745         return url;
2746     }
2747 
2748     // for the full URL, we consider that the reserved characters are prettier if encoded
2749     if (options & DecodeReserved)
2750         options &= ~EncodeReserved;
2751     else
2752         options |= EncodeReserved;
2753 
2754     if (!(options & QUrl::RemoveScheme) && d->hasScheme())
2755         url += d->scheme + QLatin1Char(':');
2756 
2757     bool pathIsAbsolute = d->path.startsWith(QLatin1Char('/'));
2758     if (!((options & QUrl::RemoveAuthority) == QUrl::RemoveAuthority) && d->hasAuthority()) {
2759         url += QLatin1String("//");
2760         d->appendAuthority(url, options, QUrlPrivate::FullUrl);
2761     } else if (isLocalFile() && pathIsAbsolute) {
2762         // Comply with the XDG file URI spec, which requires triple slashes.
2763         url += QLatin1String("//");
2764     }
2765 
2766     if (!(options & QUrl::RemovePath))
2767         d->appendPath(url, options, QUrlPrivate::FullUrl);
2768 
2769     if (!(options & QUrl::RemoveQuery) && d->hasQuery()) {
2770         url += QLatin1Char('?');
2771         d->appendQuery(url, options, QUrlPrivate::FullUrl);
2772     }
2773     if (!(options & QUrl::RemoveFragment) && d->hasFragment()) {
2774         url += QLatin1Char('#');
2775         d->appendFragment(url, options, QUrlPrivate::FullUrl);
2776     }
2777 
2778     return url;
2779 }
2780 
2781 /*!
2782     \since 5.0
2783 
2784     Returns a human-displayable string representation of the URL.
2785     The output can be customized by passing flags with \a options.
2786     The option RemovePassword is always enabled, since passwords
2787     should never be shown back to users.
2788 
2789     With the default options, the resulting QString can be passed back
2790     to a QUrl later on, but any password that was present initially will
2791     be lost.
2792 
2793     \sa FormattingOptions, toEncoded(), toString()
2794 */
2795 
2796 QString QUrl::toDisplayString(FormattingOptions options) const
2797 {
2798     return toString(options | RemovePassword);
2799 }
2800 
2801 /*!
2802     \since 5.2
2803 
2804     Returns an adjusted version of the URL.
2805     The output can be customized by passing flags with \a options.
2806 
2807     The encoding options from QUrl::ComponentFormattingOption don't make
2808     much sense for this method, nor does QUrl::PreferLocalFile.
2809 
2810     This is always equivalent to QUrl(url.toString(options)).
2811 
2812     \sa FormattingOptions, toEncoded(), toString()
2813 */
2814 QUrl QUrl::adjusted(QUrl::FormattingOptions options) const
2815 {
2816     if (!isValid()) {
2817         // also catches isEmpty()
2818         return QUrl();
2819     }
2820     QUrl that = *this;
2821     if (options & RemoveScheme)
2822         that.setScheme(QString());
2823     if ((options & RemoveAuthority) == RemoveAuthority) {
2824         that.setAuthority(QString());
2825     } else {
2826         if ((options & RemoveUserInfo) == RemoveUserInfo)
2827             that.setUserInfo(QString());
2828         else if (options & RemovePassword)
2829             that.setPassword(QString());
2830         if (options & RemovePort)
2831             that.setPort(-1);
2832     }
2833     if (options & RemoveQuery)
2834         that.setQuery(QString());
2835     if (options & RemoveFragment)
2836         that.setFragment(QString());
2837     if (options & RemovePath) {
2838         that.setPath(QString());
2839     } else if (options & (StripTrailingSlash | RemoveFilename | NormalizePathSegments)) {
2840         that.detach();
2841         QString path;
2842         d->appendPath(path, options | FullyEncoded, QUrlPrivate::Path);
2843         that.d->setPath(path, 0, path.length());
2844     }
2845     return that;
2846 }
2847 
2848 /*!
2849     Returns the encoded representation of the URL if it's valid;
2850     otherwise an empty QByteArray is returned. The output can be
2851     customized by passing flags with \a options.
2852 
2853     The user info, path and fragment are all converted to UTF-8, and
2854     all non-ASCII characters are then percent encoded. The host name
2855     is encoded using Punycode.
2856 */
2857 QByteArray QUrl::toEncoded(FormattingOptions options) const
2858 {
2859     options &= ~(FullyDecoded | FullyEncoded);
2860     return toString(options | FullyEncoded).toLatin1();
2861 }
2862 
2863 /*!
2864     \fn QUrl QUrl::fromEncoded(const QByteArray &input, ParsingMode parsingMode)
2865 
2866     Parses \a input and returns the corresponding QUrl. \a input is
2867     assumed to be in encoded form, containing only ASCII characters.
2868 
2869     Parses the URL using \a parsingMode. See setUrl() for more information on
2870     this parameter. QUrl::DecodedMode is not permitted in this context.
2871 
2872     \sa toEncoded(), setUrl()
2873 */
2874 QUrl QUrl::fromEncoded(const QByteArray &input, ParsingMode mode)
2875 {
2876     return QUrl(QString::fromUtf8(input.constData(), input.size()), mode);
2877 }
2878 
2879 /*!
2880     Returns a decoded copy of \a input. \a input is first decoded from
2881     percent encoding, then converted from UTF-8 to unicode.
2882 
2883     \note Given invalid input (such as a string containing the sequence "%G5",
2884     which is not a valid hexadecimal number) the output will be invalid as
2885     well. As an example: the sequence "%G5" could be decoded to 'W'.
2886 */
2887 QString QUrl::fromPercentEncoding(const QByteArray &input)
2888 {
2889     QByteArray ba = QByteArray::fromPercentEncoding(input);
2890     return QString::fromUtf8(ba, ba.size());
2891 }
2892 
2893 /*!
2894     Returns an encoded copy of \a input. \a input is first converted
2895     to UTF-8, and all ASCII-characters that are not in the unreserved group
2896     are percent encoded. To prevent characters from being percent encoded
2897     pass them to \a exclude. To force characters to be percent encoded pass
2898     them to \a include.
2899 
2900     Unreserved is defined as:
2901        \tt {ALPHA / DIGIT / "-" / "." / "_" / "~"}
2902 
2903     \snippet code/src_corelib_io_qurl.cpp 6
2904 */
2905 QByteArray QUrl::toPercentEncoding(const QString &input, const QByteArray &exclude, const QByteArray &include)
2906 {
2907     return input.toUtf8().toPercentEncoding(exclude, include);
2908 }
2909 
2910 /*!
2911     \since 6.3
2912 
2913     Returns the Unicode form of the given domain name
2914     \a domain, which is encoded in the ASCII Compatible Encoding (ACE).
2915     The output can be customized by passing flags with \a options.
2916     The result of this function is considered equivalent to \a domain.
2917 
2918     If the value in \a domain cannot be encoded, it will be converted
2919     to QString and returned.
2920 
2921     The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491
2922     and RFC 3492 and updated by the Unicode Technical Standard #46. It is part
2923     of the Internationalizing Domain Names in Applications (IDNA) specification,
2924     which allows for domain names (like \c "example.com") to be written using
2925     non-US-ASCII characters.
2926 */
2927 QString QUrl::fromAce(const QByteArray &domain, QUrl::AceProcessingOptions options)
2928 {
2929     return qt_ACE_do(QString::fromLatin1(domain), NormalizeAce,
2930                      ForbidLeadingDot /*FIXME: make configurable*/, options);
2931 }
2932 
2933 #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0)
2934 /*!
2935     \since 4.2
2936     \overload
2937 */
2938 QString QUrl::fromAce(const QByteArray &domain)
2939 {
2940     return fromAce(domain, {});
2941 }
2942 #endif
2943 
2944 /*!
2945     \since 6.3
2946 
2947     Returns the ASCII Compatible Encoding of the given domain name \a domain.
2948     The output can be customized by passing flags with \a options.
2949     The result of this function is considered equivalent to \a domain.
2950 
2951     The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491
2952     and RFC 3492 and updated by the Unicode Technical Standard #46. It is part
2953     of the Internationalizing Domain Names in Applications (IDNA) specification,
2954     which allows for domain names (like \c "example.com") to be written using
2955     non-US-ASCII characters.
2956 
2957     This function returns an empty QByteArray if \a domain is not a valid
2958     hostname. Note, in particular, that IPv6 literals are not valid domain
2959     names.
2960 */
2961 QByteArray QUrl::toAce(const QString &domain, AceProcessingOptions options)
2962 {
2963     return qt_ACE_do(domain, ToAceOnly, ForbidLeadingDot /*FIXME: make configurable*/, options)
2964             .toLatin1();
2965 }
2966 
2967 #if QT_VERSION < QT_VERSION_CHECK(7, 0, 0)
2968 /*!
2969     \since 4.2
2970     \overload
2971 */
2972 QByteArray QUrl::toAce(const QString &domain)
2973 {
2974     return toAce(domain, {});
2975 }
2976 #endif
2977 
2978 /*!
2979     \internal
2980 
2981     Returns \c true if this URL is "less than" the given \a url. This
2982     provides a means of ordering URLs.
2983 */
2984 bool QUrl::operator <(const QUrl &url) const
2985 {
2986     if (!d || !url.d) {
2987         bool thisIsEmpty = !d || d->isEmpty();
2988         bool thatIsEmpty = !url.d || url.d->isEmpty();
2989 
2990         // sort an empty URL first
2991         return thisIsEmpty && !thatIsEmpty;
2992     }
2993 
2994     int cmp;
2995     cmp = d->scheme.compare(url.d->scheme);
2996     if (cmp != 0)
2997         return cmp < 0;
2998 
2999     cmp = d->userName.compare(url.d->userName);
3000     if (cmp != 0)
3001         return cmp < 0;
3002 
3003     cmp = d->password.compare(url.d->password);
3004     if (cmp != 0)
3005         return cmp < 0;
3006 
3007     cmp = d->host.compare(url.d->host);
3008     if (cmp != 0)
3009         return cmp < 0;
3010 
3011     if (d->port != url.d->port)
3012         return d->port < url.d->port;
3013 
3014     cmp = d->path.compare(url.d->path);
3015     if (cmp != 0)
3016         return cmp < 0;
3017 
3018     if (d->hasQuery() != url.d->hasQuery())
3019         return url.d->hasQuery();
3020 
3021     cmp = d->query.compare(url.d->query);
3022     if (cmp != 0)
3023         return cmp < 0;
3024 
3025     if (d->hasFragment() != url.d->hasFragment())
3026         return url.d->hasFragment();
3027 
3028     cmp = d->fragment.compare(url.d->fragment);
3029     return cmp < 0;
3030 }
3031 
3032 /*!
3033     Returns \c true if this URL and the given \a url are equal;
3034     otherwise returns \c false.
3035 
3036     \sa matches()
3037 */
3038 bool QUrl::operator ==(const QUrl &url) const
3039 {
3040     if (!d && !url.d)
3041         return true;
3042     if (!d)
3043         return url.d->isEmpty();
3044     if (!url.d)
3045         return d->isEmpty();
3046 
3047     // First, compare which sections are present, since it speeds up the
3048     // processing considerably. We just have to ignore the host-is-present flag
3049     // for local files (the "file" protocol), due to the requirements of the
3050     // XDG file URI specification.
3051     int mask = QUrlPrivate::FullUrl;
3052     if (isLocalFile())
3053         mask &= ~QUrlPrivate::Host;
3054     return (d->sectionIsPresent & mask) == (url.d->sectionIsPresent & mask) &&
3055             d->scheme == url.d->scheme &&
3056             d->userName == url.d->userName &&
3057             d->password == url.d->password &&
3058             d->host == url.d->host &&
3059             d->port == url.d->port &&
3060             d->path == url.d->path &&
3061             d->query == url.d->query &&
3062             d->fragment == url.d->fragment;
3063 }
3064 
3065 /*!
3066     \since 5.2
3067 
3068     Returns \c true if this URL and the given \a url are equal after
3069     applying \a options to both; otherwise returns \c false.
3070 
3071     This is equivalent to calling adjusted(options) on both URLs
3072     and comparing the resulting urls, but faster.
3073 
3074 */
3075 bool QUrl::matches(const QUrl &url, FormattingOptions options) const
3076 {
3077     if (!d && !url.d)
3078         return true;
3079     if (!d)
3080         return url.d->isEmpty();
3081     if (!url.d)
3082         return d->isEmpty();
3083 
3084     // First, compare which sections are present, since it speeds up the
3085     // processing considerably. We just have to ignore the host-is-present flag
3086     // for local files (the "file" protocol), due to the requirements of the
3087     // XDG file URI specification.
3088     int mask = QUrlPrivate::FullUrl;
3089     if (isLocalFile())
3090         mask &= ~QUrlPrivate::Host;
3091 
3092     if (options.testFlag(QUrl::RemoveScheme))
3093         mask &= ~QUrlPrivate::Scheme;
3094     else if (d->scheme != url.d->scheme)
3095         return false;
3096 
3097     if (options.testFlag(QUrl::RemovePassword))
3098         mask &= ~QUrlPrivate::Password;
3099     else if (d->password != url.d->password)
3100         return false;
3101 
3102     if (options.testFlag(QUrl::RemoveUserInfo))
3103         mask &= ~QUrlPrivate::UserName;
3104     else if (d->userName != url.d->userName)
3105         return false;
3106 
3107     if (options.testFlag(QUrl::RemovePort))
3108         mask &= ~QUrlPrivate::Port;
3109     else if (d->port != url.d->port)
3110         return false;
3111 
3112     if (options.testFlag(QUrl::RemoveAuthority))
3113         mask &= ~QUrlPrivate::Host;
3114     else if (d->host != url.d->host)
3115         return false;
3116 
3117     if (options.testFlag(QUrl::RemoveQuery))
3118         mask &= ~QUrlPrivate::Query;
3119     else if (d->query != url.d->query)
3120         return false;
3121 
3122     if (options.testFlag(QUrl::RemoveFragment))
3123         mask &= ~QUrlPrivate::Fragment;
3124     else if (d->fragment != url.d->fragment)
3125         return false;
3126 
3127     if ((d->sectionIsPresent & mask) != (url.d->sectionIsPresent & mask))
3128         return false;
3129 
3130     if (options.testFlag(QUrl::RemovePath))
3131         return true;
3132 
3133     // Compare paths, after applying path-related options
3134     QString path1;
3135     d->appendPath(path1, options, QUrlPrivate::Path);
3136     QString path2;
3137     url.d->appendPath(path2, options, QUrlPrivate::Path);
3138     return path1 == path2;
3139 }
3140 
3141 /*!
3142     Returns \c true if this URL and the given \a url are not equal;
3143     otherwise returns \c false.
3144 
3145     \sa matches()
3146 */
3147 bool QUrl::operator !=(const QUrl &url) const
3148 {
3149     return !(*this == url);
3150 }
3151 
3152 /*!
3153     Assigns the specified \a url to this object.
3154 */
3155 QUrl &QUrl::operator =(const QUrl &url)
3156 {
3157     if (!d) {
3158         if (url.d) {
3159             url.d->ref.ref();
3160             d = url.d;
3161         }
3162     } else {
3163         if (url.d)
3164             qAtomicAssign(d, url.d);
3165         else
3166             clear();
3167     }
3168     return *this;
3169 }
3170 
3171 /*!
3172     Assigns the specified \a url to this object.
3173 */
3174 QUrl &QUrl::operator =(const QString &url)
3175 {
3176     if (url.isEmpty()) {
3177         clear();
3178     } else {
3179         detach();
3180         d->parse(url, TolerantMode);
3181     }
3182     return *this;
3183 }
3184 
3185 /*!
3186     \fn void QUrl::swap(QUrl &other)
3187     \since 4.8
3188 
3189     Swaps URL \a other with this URL. This operation is very
3190     fast and never fails.
3191 */
3192 
3193 /*!
3194     \internal
3195 
3196     Forces a detach.
3197 */
3198 void QUrl::detach()
3199 {
3200     if (!d)
3201         d = new QUrlPrivate;
3202     else
3203         qAtomicDetach(d);
3204 }
3205 
3206 /*!
3207     \internal
3208 */
3209 bool QUrl::isDetached() const
3210 {
3211     return !d || d->ref.loadRelaxed() == 1;
3212 }
3213 
3214 static QString fromNativeSeparators(const QString &pathName)
3215 {
3216 #if defined(Q_OS_WIN)
3217     QString result(pathName);
3218     const QChar nativeSeparator = u'\\';
3219     auto i = result.indexOf(nativeSeparator);
3220     if (i != -1) {
3221         QChar * const data = result.data();
3222         const auto length = result.length();
3223         for (; i < length; ++i) {
3224             if (data[i] == nativeSeparator)
3225                 data[i] = u'/';
3226         }
3227     }
3228     return result;
3229 #else
3230     return pathName;
3231 #endif
3232 }
3233 
3234 /*!
3235     Returns a QUrl representation of \a localFile, interpreted as a local
3236     file. This function accepts paths separated by slashes as well as the
3237     native separator for this platform.
3238 
3239     This function also accepts paths with a doubled leading slash (or
3240     backslash) to indicate a remote file, as in
3241     "//servername/path/to/file.txt". Note that only certain platforms can
3242     actually open this file using QFile::open().
3243 
3244     An empty \a localFile leads to an empty URL (since Qt 5.4).
3245 
3246     \snippet code/src_corelib_io_qurl.cpp 16
3247 
3248     In the first line in snippet above, a file URL is constructed from a
3249     local, relative path. A file URL with a relative path only makes sense
3250     if there is a base URL to resolve it against. For example:
3251 
3252     \snippet code/src_corelib_io_qurl.cpp 17
3253 
3254     To resolve such a URL, it's necessary to remove the scheme beforehand:
3255 
3256     \snippet code/src_corelib_io_qurl.cpp 18
3257 
3258     For this reason, it is better to use a relative URL (that is, no scheme)
3259     for relative file paths:
3260 
3261     \snippet code/src_corelib_io_qurl.cpp 19
3262 
3263     \sa toLocalFile(), isLocalFile(), QDir::toNativeSeparators()
3264 */
3265 QUrl QUrl::fromLocalFile(const QString &localFile)
3266 {
3267     QUrl url;
3268     if (localFile.isEmpty())
3269         return url;
3270     QString scheme = fileScheme();
3271     QString deslashified = fromNativeSeparators(localFile);
3272 
3273     // magic for drives on windows
3274     if (deslashified.length() > 1 && deslashified.at(1) == QLatin1Char(':') && deslashified.at(0) != QLatin1Char('/')) {
3275         deslashified.prepend(QLatin1Char('/'));
3276     } else if (deslashified.startsWith(QLatin1String("//"))) {
3277         // magic for shared drive on windows
3278         int indexOfPath = deslashified.indexOf(QLatin1Char('/'), 2);
3279         QStringView hostSpec = QStringView{deslashified}.mid(2, indexOfPath - 2);
3280         // Check for Windows-specific WebDAV specification: "//host@SSL/path".
3281         if (hostSpec.endsWith(webDavSslTag(), Qt::CaseInsensitive)) {
3282             hostSpec.truncate(hostSpec.size() - 4);
3283             scheme = webDavScheme();
3284         }
3285 
3286         // hosts can't be IPv6 addresses without [], so we can use QUrlPrivate::setHost
3287         url.detach();
3288         if (!url.d->setHost(hostSpec.toString(), 0, hostSpec.size(), StrictMode)) {
3289             if (url.d->error()->code != QUrlPrivate::InvalidRegNameError)
3290                 return url;
3291 
3292             // Path hostname is not a valid URL host, so set it entirely in the path
3293             // (by leaving deslashified unchanged)
3294         } else if (indexOfPath > 2) {
3295             deslashified = deslashified.right(deslashified.length() - indexOfPath);
3296         } else {
3297             deslashified.clear();
3298         }
3299     }
3300 
3301     url.setScheme(scheme);
3302     url.setPath(deslashified, DecodedMode);
3303     return url;
3304 }
3305 
3306 /*!
3307     Returns the path of this URL formatted as a local file path. The path
3308     returned will use forward slashes, even if it was originally created
3309     from one with backslashes.
3310 
3311     If this URL contains a non-empty hostname, it will be encoded in the
3312     returned value in the form found on SMB networks (for example,
3313     "//servername/path/to/file.txt").
3314 
3315     \snippet code/src_corelib_io_qurl.cpp 20
3316 
3317     Note: if the path component of this URL contains a non-UTF-8 binary
3318     sequence (such as %80), the behaviour of this function is undefined.
3319 
3320     \sa fromLocalFile(), isLocalFile()
3321 */
3322 QString QUrl::toLocalFile() const
3323 {
3324     // the call to isLocalFile() also ensures that we're parsed
3325     if (!isLocalFile())
3326         return QString();
3327 
3328     return d->toLocalFile(QUrl::FullyDecoded);
3329 }
3330 
3331 /*!
3332     \since 4.8
3333     Returns \c true if this URL is pointing to a local file path. A URL is a
3334     local file path if the scheme is "file".
3335 
3336     Note that this function considers URLs with hostnames to be local file
3337     paths, even if the eventual file path cannot be opened with
3338     QFile::open().
3339 
3340     \sa fromLocalFile(), toLocalFile()
3341 */
3342 bool QUrl::isLocalFile() const
3343 {
3344     return d && d->isLocalFile();
3345 }
3346 
3347 /*!
3348     Returns \c true if this URL is a parent of \a childUrl. \a childUrl is a child
3349     of this URL if the two URLs share the same scheme and authority,
3350     and this URL's path is a parent of the path of \a childUrl.
3351 */
3352 bool QUrl::isParentOf(const QUrl &childUrl) const
3353 {
3354     QString childPath = childUrl.path();
3355 
3356     if (!d)
3357         return ((childUrl.scheme().isEmpty())
3358             && (childUrl.authority().isEmpty())
3359             && childPath.length() > 0 && childPath.at(0) == QLatin1Char('/'));
3360 
3361     QString ourPath = path();
3362 
3363     return ((childUrl.scheme().isEmpty() || d->scheme == childUrl.scheme())
3364             && (childUrl.authority().isEmpty() || authority() == childUrl.authority())
3365             &&  childPath.startsWith(ourPath)
3366             && ((ourPath.endsWith(QLatin1Char('/')) && childPath.length() > ourPath.length())
3367                 || (!ourPath.endsWith(QLatin1Char('/'))
3368                     && childPath.length() > ourPath.length() && childPath.at(ourPath.length()) == QLatin1Char('/'))));
3369 }
3370 
3371 
3372 #ifndef QT_NO_DATASTREAM
3373 /*! \relates QUrl
3374 
3375     Writes url \a url to the stream \a out and returns a reference
3376     to the stream.
3377 
3378     \sa{Serializing Qt Data Types}{Format of the QDataStream operators}
3379 */
3380 QDataStream &operator<<(QDataStream &out, const QUrl &url)
3381 {
3382     QByteArray u;
3383     if (url.isValid())
3384         u = url.toEncoded();
3385     out << u;
3386     return out;
3387 }
3388 
3389 /*! \relates QUrl
3390 
3391     Reads a url into \a url from the stream \a in and returns a
3392     reference to the stream.
3393 
3394     \sa{Serializing Qt Data Types}{Format of the QDataStream operators}
3395 */
3396 QDataStream &operator>>(QDataStream &in, QUrl &url)
3397 {
3398     QByteArray u;
3399     in >> u;
3400     url.setUrl(QString::fromLatin1(u));
3401     return in;
3402 }
3403 #endif // QT_NO_DATASTREAM
3404 
3405 #ifndef QT_NO_DEBUG_STREAM
3406 QDebug operator<<(QDebug d, const QUrl &url)
3407 {
3408     QDebugStateSaver saver(d);
3409     d.nospace() << "QUrl(" << url.toDisplayString() << ')';
3410     return d;
3411 }
3412 #endif
3413 
3414 static QString errorMessage(QUrlPrivate::ErrorCode errorCode, const QString &errorSource, int errorPosition)
3415 {
3416     QChar c = uint(errorPosition) < uint(errorSource.length()) ?
3417                 errorSource.at(errorPosition) : QChar(QChar::Null);
3418 
3419     switch (errorCode) {
3420     case QUrlPrivate::NoError:
3421         Q_ASSERT_X(false, "QUrl::errorString",
3422                    "Impossible: QUrl::errorString should have treated this condition");
3423         Q_UNREACHABLE();
3424         return QString();
3425 
3426     case QUrlPrivate::InvalidSchemeError: {
3427         auto msg = QLatin1String("Invalid scheme (character '%1' not permitted)");
3428         return msg.arg(c);
3429     }
3430 
3431     case QUrlPrivate::InvalidUserNameError:
3432         return QLatin1String("Invalid user name (character '%1' not permitted)")
3433                 .arg(c);
3434 
3435     case QUrlPrivate::InvalidPasswordError:
3436         return QLatin1String("Invalid password (character '%1' not permitted)")
3437                 .arg(c);
3438 
3439     case QUrlPrivate::InvalidRegNameError:
3440         if (errorPosition != -1)
3441             return QLatin1String("Invalid hostname (character '%1' not permitted)")
3442                     .arg(c);
3443         else
3444             return QStringLiteral("Invalid hostname (contains invalid characters)");
3445     case QUrlPrivate::InvalidIPv4AddressError:
3446         return QString(); // doesn't happen yet
3447     case QUrlPrivate::InvalidIPv6AddressError:
3448         return QStringLiteral("Invalid IPv6 address");
3449     case QUrlPrivate::InvalidCharacterInIPv6Error:
3450         return QLatin1String("Invalid IPv6 address (character '%1' not permitted)").arg(c);
3451     case QUrlPrivate::InvalidIPvFutureError:
3452         return QLatin1String("Invalid IPvFuture address (character '%1' not permitted)").arg(c);
3453     case QUrlPrivate::HostMissingEndBracket:
3454         return QStringLiteral("Expected ']' to match '[' in hostname");
3455 
3456     case QUrlPrivate::InvalidPortError:
3457         return QStringLiteral("Invalid port or port number out of range");
3458     case QUrlPrivate::PortEmptyError:
3459         return QStringLiteral("Port field was empty");
3460 
3461     case QUrlPrivate::InvalidPathError:
3462         return QLatin1String("Invalid path (character '%1' not permitted)")
3463                 .arg(c);
3464 
3465     case QUrlPrivate::InvalidQueryError:
3466         return QLatin1String("Invalid query (character '%1' not permitted)")
3467                 .arg(c);
3468 
3469     case QUrlPrivate::InvalidFragmentError:
3470         return QLatin1String("Invalid fragment (character '%1' not permitted)")
3471                 .arg(c);
3472 
3473     case QUrlPrivate::AuthorityPresentAndPathIsRelative:
3474         return QStringLiteral("Path component is relative and authority is present");
3475     case QUrlPrivate::AuthorityAbsentAndPathIsDoubleSlash:
3476         return QStringLiteral("Path component starts with '//' and authority is absent");
3477     case QUrlPrivate::RelativeUrlPathContainsColonBeforeSlash:
3478         return QStringLiteral("Relative URL's path component contains ':' before any '/'");
3479     }
3480 
3481     Q_ASSERT_X(false, "QUrl::errorString", "Cannot happen, unknown error");
3482     Q_UNREACHABLE();
3483     return QString();
3484 }
3485 
3486 static inline void appendComponentIfPresent(QString &msg, bool present, const char *componentName,
3487                                             const QString &component)
3488 {
3489     if (present) {
3490         msg += QLatin1String(componentName);
3491         msg += QLatin1Char('"');
3492         msg += component;
3493         msg += QLatin1String("\",");
3494     }
3495 }
3496 
3497 /*!
3498     \since 4.2
3499 
3500     Returns an error message if the last operation that modified this QUrl
3501     object ran into a parsing error. If no error was detected, this function
3502     returns an empty string and isValid() returns \c true.
3503 
3504     The error message returned by this function is technical in nature and may
3505     not be understood by end users. It is mostly useful to developers trying to
3506     understand why QUrl will not accept some input.
3507 
3508     \sa QUrl::ParsingMode
3509 */
3510 QString QUrl::errorString() const
3511 {
3512     QString msg;
3513     if (!d)
3514         return msg;
3515 
3516     QString errorSource;
3517     int errorPosition = 0;
3518     QUrlPrivate::ErrorCode errorCode = d->validityError(&errorSource, &errorPosition);
3519     if (errorCode == QUrlPrivate::NoError)
3520         return msg;
3521 
3522     msg += errorMessage(errorCode, errorSource, errorPosition);
3523     msg += QLatin1String("; source was \"");
3524     msg += errorSource;
3525     msg += QLatin1String("\";");
3526     appendComponentIfPresent(msg, d->sectionIsPresent & QUrlPrivate::Scheme,
3527                              " scheme = ", d->scheme);
3528     appendComponentIfPresent(msg, d->sectionIsPresent & QUrlPrivate::UserInfo,
3529                              " userinfo = ", userInfo());
3530     appendComponentIfPresent(msg, d->sectionIsPresent & QUrlPrivate::Host,
3531                              " host = ", d->host);
3532     appendComponentIfPresent(msg, d->port != -1,
3533                              " port = ", QString::number(d->port));
3534     appendComponentIfPresent(msg, !d->path.isEmpty(),
3535                              " path = ", d->path);
3536     appendComponentIfPresent(msg, d->sectionIsPresent & QUrlPrivate::Query,
3537                              " query = ", d->query);
3538     appendComponentIfPresent(msg, d->sectionIsPresent & QUrlPrivate::Fragment,
3539                              " fragment = ", d->fragment);
3540     if (msg.endsWith(QLatin1Char(',')))
3541         msg.chop(1);
3542     return msg;
3543 }
3544 
3545 /*!
3546     \since 5.1
3547 
3548     Converts a list of \a urls into a list of QString objects, using toString(\a options).
3549 */
3550 QStringList QUrl::toStringList(const QList<QUrl> &urls, FormattingOptions options)
3551 {
3552     QStringList lst;
3553     lst.reserve(urls.size());
3554     for (const QUrl &url : urls)
3555         lst.append(url.toString(options));
3556     return lst;
3557 
3558 }
3559 
3560 /*!
3561     \since 5.1
3562 
3563     Converts a list of strings representing \a urls into a list of urls, using QUrl(str, \a mode).
3564     Note that this means all strings must be urls, not for instance local paths.
3565 */
3566 QList<QUrl> QUrl::fromStringList(const QStringList &urls, ParsingMode mode)
3567 {
3568     QList<QUrl> lst;
3569     lst.reserve(urls.size());
3570     for (const QString &str : urls)
3571         lst.append(QUrl(str, mode));
3572     return lst;
3573 }
3574 
3575 /*!
3576     \typedef QUrl::DataPtr
3577     \internal
3578 */
3579 
3580 /*!
3581     \fn DataPtr &QUrl::data_ptr()
3582     \internal
3583 */
3584 
3585 /*!
3586     Returns the hash value for the \a url. If specified, \a seed is used to
3587     initialize the hash.
3588 
3589     \relates QHash
3590     \since 5.0
3591 */
3592 size_t qHash(const QUrl &url, size_t seed) noexcept
3593 {
3594     if (!url.d)
3595         return qHash(-1, seed); // the hash of an unset port (-1)
3596 
3597     return qHash(url.d->scheme) ^
3598             qHash(url.d->userName) ^
3599             qHash(url.d->password) ^
3600             qHash(url.d->host) ^
3601             qHash(url.d->port, seed) ^
3602             qHash(url.d->path) ^
3603             qHash(url.d->query) ^
3604             qHash(url.d->fragment);
3605 }
3606 
3607 static QUrl adjustFtpPath(QUrl url)
3608 {
3609     if (url.scheme() == ftpScheme()) {
3610         QString path = url.path(QUrl::PrettyDecoded);
3611         if (path.startsWith(QLatin1String("//")))
3612             url.setPath(QLatin1String("/%2F") + QStringView{path}.mid(2), QUrl::TolerantMode);
3613     }
3614     return url;
3615 }
3616 
3617 static bool isIp6(const QString &text)
3618 {
3619     QIPAddressUtils::IPv6Address address;
3620     return !text.isEmpty() && QIPAddressUtils::parseIp6(address, text.begin(), text.end()) == nullptr;
3621 }
3622 
3623 /*!
3624     Returns a valid URL from a user supplied \a userInput string if one can be
3625     deduced. In the case that is not possible, an invalid QUrl() is returned.
3626 
3627     This allows the user to input a URL or a local file path in the form of a plain
3628     string. This string can be manually typed into a location bar, obtained from
3629     the clipboard, or passed in via command line arguments.
3630 
3631     When the string is not already a valid URL, a best guess is performed,
3632     making various assumptions.
3633 
3634     In the case the string corresponds to a valid file path on the system,
3635     a file:// URL is constructed, using QUrl::fromLocalFile().
3636 
3637     If that is not the case, an attempt is made to turn the string into a
3638     http:// or ftp:// URL. The latter in the case the string starts with
3639     'ftp'. The result is then passed through QUrl's tolerant parser, and
3640     in the case or success, a valid QUrl is returned, or else a QUrl().
3641 
3642     \section1 Examples:
3643 
3644     \list
3645     \li qt-project.org becomes http://qt-project.org
3646     \li ftp.qt-project.org becomes ftp://ftp.qt-project.org
3647     \li hostname becomes http://hostname
3648     \li /home/user/test.html becomes file:///home/user/test.html
3649     \endlist
3650 
3651     In order to be able to handle relative paths, this method takes an optional
3652     \a workingDirectory path. This is especially useful when handling command
3653     line arguments.
3654     If \a workingDirectory is empty, no handling of relative paths will be done.
3655 
3656     By default, an input string that looks like a relative path will only be treated
3657     as such if the file actually exists in the given working directory.
3658     If the application can handle files that don't exist yet, it should pass the
3659     flag AssumeLocalFile in \a options.
3660 
3661     \since 5.4
3662 */
3663 QUrl QUrl::fromUserInput(const QString &userInput, const QString &workingDirectory,
3664                          UserInputResolutionOptions options)
3665 {
3666     QString trimmedString = userInput.trimmed();
3667 
3668     if (trimmedString.isEmpty())
3669         return QUrl();
3670 
3671     // Check for IPv6 addresses, since a path starting with ":" is absolute (a resource)
3672     // and IPv6 addresses can start with "c:" too
3673     if (isIp6(trimmedString)) {
3674         QUrl url;
3675         url.setHost(trimmedString);
3676         url.setScheme(QStringLiteral("http"));
3677         return url;
3678     }
3679 
3680     const QUrl url = QUrl(trimmedString, QUrl::TolerantMode);
3681 
3682     // Check for a relative path
3683     if (!workingDirectory.isEmpty()) {
3684         const QFileInfo fileInfo(QDir(workingDirectory), userInput);
3685         if (fileInfo.exists())
3686             return QUrl::fromLocalFile(fileInfo.absoluteFilePath());
3687 
3688         // Check both QUrl::isRelative (to detect full URLs) and QDir::isAbsolutePath (since on Windows drive letters can be interpreted as schemes)
3689         if ((options & AssumeLocalFile) && url.isRelative() && !QDir::isAbsolutePath(userInput))
3690             return QUrl::fromLocalFile(fileInfo.absoluteFilePath());
3691     }
3692 
3693     // Check first for files, since on Windows drive letters can be interpretted as schemes
3694     if (QDir::isAbsolutePath(trimmedString))
3695         return QUrl::fromLocalFile(trimmedString);
3696 
3697     QUrl urlPrepended = QUrl(QLatin1String("http://") + trimmedString, QUrl::TolerantMode);
3698 
3699     // Check the most common case of a valid url with a scheme
3700     // We check if the port would be valid by adding the scheme to handle the case host:port
3701     // where the host would be interpretted as the scheme
3702     if (url.isValid()
3703         && !url.scheme().isEmpty()
3704         && urlPrepended.port() == -1)
3705         return adjustFtpPath(url);
3706 
3707     // Else, try the prepended one and adjust the scheme from the host name
3708     if (urlPrepended.isValid() && (!urlPrepended.host().isEmpty() || !urlPrepended.path().isEmpty())) {
3709         int dotIndex = trimmedString.indexOf(QLatin1Char('.'));
3710         const QStringView hostscheme = QStringView{trimmedString}.left(dotIndex);
3711         if (hostscheme.compare(ftpScheme(), Qt::CaseInsensitive) == 0)
3712             urlPrepended.setScheme(ftpScheme());
3713         return adjustFtpPath(urlPrepended);
3714     }
3715 
3716     return QUrl();
3717 }
3718 
3719 
3720 QUrl QUrlPrivate::contextUrl() const
3721 {
3722     if (hasContext)
3723         return errorOrContext.context;
3724     return QUrl {};
3725 }
3726 
3727 void QUrlPrivate::setContextUrl(const QUrl &url)
3728 {
3729     if (hasError())
3730         return;
3731     if (!hasContext)
3732         errorOrContext.error.~unique_ptr();
3733     hasContext = true;
3734     errorOrContext.context = url;
3735 }
3736 
3737 QT_END_NAMESPACE
