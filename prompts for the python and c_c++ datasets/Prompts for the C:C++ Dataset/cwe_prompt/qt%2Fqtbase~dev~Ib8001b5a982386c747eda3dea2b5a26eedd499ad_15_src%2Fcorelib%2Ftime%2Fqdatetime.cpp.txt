Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qplatformdefs.h"
42 #include "qdatetime.h"
43 
44 #include "qcalendar.h"
45 #include "qdatastream.h"
46 #include "qdebug.h"
47 #include "qset.h"
48 #include "qlocale.h"
49 
50 #include "private/qdatetime_p.h"
51 #if QT_CONFIG(datetimeparser)
52 #include "private/qdatetimeparser_p.h"
53 #endif
54 #ifdef Q_OS_DARWIN
55 #include "private/qcore_mac_p.h"
56 #endif
57 #include "private/qgregoriancalendar_p.h"
58 #include "private/qnumeric_p.h"
59 #include "private/qstringiterator_p.h"
60 #if QT_CONFIG(timezone)
61 #include "private/qtimezoneprivate_p.h"
62 #endif
63 
64 #include <cmath>
65 #ifdef Q_OS_WIN
66 #  include <qt_windows.h>
67 #endif
68 #include <time.h>
69 #ifdef Q_CC_MINGW
70 #  include <unistd.h> // Define _POSIX_THREAD_SAFE_FUNCTIONS to obtain localtime_r()
71 #endif
72 
73 QT_BEGIN_NAMESPACE
74 
75 /*****************************************************************************
76   Date/Time Constants
77  *****************************************************************************/
78 
79 enum : qint64 {
80     SECS_PER_DAY = 86400,
81     MSECS_PER_DAY = 86400000,
82     SECS_PER_HOUR = 3600,
83     MSECS_PER_HOUR = 3600000,
84     SECS_PER_MIN = 60,
85     MSECS_PER_MIN = 60000,
86     MSECS_PER_SEC = 1000,
87     TIME_T_MAX = std::numeric_limits<time_t>::max(),
88     JULIAN_DAY_FOR_EPOCH = 2440588 // result of julianDayFromDate(1970, 1, 1)
89 };
90 
91 /*****************************************************************************
92   QDate static helper functions
93  *****************************************************************************/
94 
95 static inline QDate fixedDate(QCalendar::YearMonthDay &&parts, QCalendar cal)
96 {
97     if ((parts.year < 0 && !cal.isProleptic()) || (parts.year == 0 && !cal.hasYearZero()))
98         return QDate();
99 
100     parts.day = qMin(parts.day, cal.daysInMonth(parts.month, parts.year));
101     return cal.dateFromParts(parts);
102 }
103 
104 static inline QDate fixedDate(QCalendar::YearMonthDay &&parts)
105 {
106     if (parts.year) {
107         parts.day = qMin(parts.day, QGregorianCalendar::monthLength(parts.month, parts.year));
108         qint64 jd;
109         if (QGregorianCalendar::julianFromParts(parts.year, parts.month, parts.day, &jd))
110             return QDate::fromJulianDay(jd);
111     }
112     return QDate();
113 }
114 
115 /*****************************************************************************
116   Date/Time formatting helper functions
117  *****************************************************************************/
118 
119 #if QT_CONFIG(textdate)
120 static const char qt_shortMonthNames[][4] = {
121     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
122     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
123 };
124 
125 static int fromShortMonthName(QStringView monthName)
126 {
127     for (unsigned int i = 0; i < sizeof(qt_shortMonthNames) / sizeof(qt_shortMonthNames[0]); ++i) {
128         if (monthName == QLatin1String(qt_shortMonthNames[i], 3))
129             return i + 1;
130     }
131     return -1;
132 }
133 #endif // textdate
134 
135 #if QT_CONFIG(datestring) // depends on, so implies, textdate
136 struct ParsedRfcDateTime {
137     QDate date;
138     QTime time;
139     int utcOffset;
140 };
141 
142 static int shortDayFromName(QStringView name)
143 {
144     const char16_t shortDayNames[] = u"MonTueWedThuFriSatSun";
145     for (int i = 0; i < 7; i++) {
146         if (name == QStringView(shortDayNames + 3 * i, 3))
147             return i + 1;
148     }
149     return 0;
150 }
151 
152 static ParsedRfcDateTime rfcDateImpl(QStringView s)
153 {
154     // Matches "[ddd,] dd MMM yyyy[ hh:mm[:ss]] [±hhmm]" - correct RFC 822, 2822, 5322 format -
155     // or           "ddd MMM dd[ hh:mm:ss] yyyy [±hhmm]" - permissive RFC 850, 1036 (read only)
156     ParsedRfcDateTime result;
157 
158     auto words = QStringView{s}.split(u' ', Qt::SkipEmptyParts);
159     if (words.size() < 3 || words.size() > 6)
160         return result;
161     const QChar colon(u':');
162     bool ok = true;
163     QDate date;
164 
165     const auto isShortName = [](QStringView name) {
166         return (name.length() == 3 && name[0].isUpper()
167                 && name[1].isLower() && name[2].isLower());
168     };
169 
170     /* Reject entirely (return) if the string is malformed; however, if the date
171      * is merely invalid, (break, so as to) go on to parsing of the time.
172      */
173     int yearIndex;
174     do { // "loop" so that we can use break on merely invalid, but "right shape" date.
175         QStringView dayName;
176         bool rfcX22 = true;
177         if (words.at(0).endsWith(u',')) {
178             dayName = words.takeFirst().chopped(1);
179         } else if (!words.at(0)[0].isDigit()) {
180             dayName = words.takeFirst();
181             rfcX22 = false;
182         } // else: dayName is not specified (so we can only be RFC *22)
183         if (words.size() < 3 || words.size() > 5)
184             return result;
185 
186         // Don't break before setting yearIndex.
187         int dayIndex, monthIndex;
188         if (rfcX22) {
189             // dd MMM yyyy [hh:mm[:ss]] [±hhmm]
190             dayIndex = 0;
191             monthIndex = 1;
192             yearIndex = 2;
193         } else {
194             // MMM dd[ hh:mm:ss] yyyy [±hhmm]
195             dayIndex = 1;
196             monthIndex = 0;
197             yearIndex = words.size() > 3 && words.at(2).contains(colon) ? 3 : 2;
198         }
199 
200         int dayOfWeek = 0;
201         if (!dayName.isEmpty()) {
202             if (!isShortName(dayName))
203                 return result;
204             dayOfWeek = shortDayFromName(dayName);
205             if (!dayOfWeek)
206                 break;
207         }
208 
209         const int day = words.at(dayIndex).toInt(&ok);
210         if (!ok)
211             return result;
212         const int year = words.at(yearIndex).toInt(&ok);
213         if (!ok)
214             return result;
215         const QStringView monthName = words.at(monthIndex);
216         if (!isShortName(monthName))
217             return result;
218         int month = fromShortMonthName(monthName);
219         if (month < 0)
220             break;
221 
222         date = QDate(year, month, day);
223         if (dayOfWeek && date.dayOfWeek() != dayOfWeek)
224             date = QDate();
225     } while (false);
226     words.remove(yearIndex);
227     words.remove(0, 2); // month and day-of-month, in some order
228 
229     // Time: [hh:mm[:ss]]
230     QTime time;
231     if (words.size() && words.at(0).contains(colon)) {
232         const QStringView when = words.takeFirst();
233         if (when.size() < 5 || when[2] != colon
234             || (when.size() == 8 ? when[5] != colon : when.size() > 5)) {
235             return result;
236         }
237         const int hour = when.first(2).toInt(&ok);
238         if (!ok)
239             return result;
240         const int minute = when.sliced(3, 2).toInt(&ok);
241         if (!ok)
242             return result;
243         const auto secs = when.size() == 8 ? when.last(2).toInt(&ok) : 0;
244         if (!ok)
245             return result;
246         time = QTime(hour, minute, secs);
247     }
248 
249     // Offset: [±hh[mm]]
250     int offset = 0;
251     if (words.size()) {
252         const QStringView zone = words.takeFirst();
253         if (words.size() || !(zone.size() == 3 || zone.size() == 5))
254             return result;
255         bool negate = false;
256         if (zone[0] == u'-')
257             negate = true;
258         else if (zone[0] != u'+')
259             return result;
260         const int hour = zone.sliced(1, 2).toInt(&ok);
261         if (!ok)
262             return result;
263         const auto minute = zone.size() == 5 ? zone.last(2).toInt(&ok) : 0;
264         if (!ok)
265             return result;
266         offset = (hour * 60 + minute) * 60;
267         if (negate)
268             offset = -offset;
269     }
270 
271     result.date = date;
272     result.time = time;
273     result.utcOffset = offset;
274     return result;
275 }
276 #endif // datestring
277 
278 // Return offset in [+-]HH:mm format
279 static QString toOffsetString(Qt::DateFormat format, int offset)
280 {
281     return QString::asprintf("%c%02d%s%02d",
282                              offset >= 0 ? '+' : '-',
283                              qAbs(offset) / int(SECS_PER_HOUR),
284                              // Qt::ISODate puts : between the hours and minutes, but Qt:TextDate does not:
285                              format == Qt::TextDate ? "" : ":",
286                              (qAbs(offset) / 60) % 60);
287 }
288 
289 #if QT_CONFIG(datestring)
290 // Parse offset in [+-]HH[[:]mm] format
291 static int fromOffsetString(QStringView offsetString, bool *valid) noexcept
292 {
293     *valid = false;
294 
295     const int size = offsetString.size();
296     if (size < 2 || size > 6)
297         return 0;
298 
299     // sign will be +1 for a positive and -1 for a negative offset
300     int sign;
301 
302     // First char must be + or -
303     const QChar signChar = offsetString[0];
304     if (signChar == u'+')
305         sign = 1;
306     else if (signChar == u'-')
307         sign = -1;
308     else
309         return 0;
310 
311     // Split the hour and minute parts
312     const QStringView time = offsetString.sliced(1);
313     qsizetype hhLen = time.indexOf(u':');
314     qsizetype mmIndex;
315     if (hhLen == -1)
316         mmIndex = hhLen = 2; // [+-]HHmm or [+-]HH format
317     else
318         mmIndex = hhLen + 1;
319 
320     const QStringView hhRef = time.first(qMin(hhLen, time.size()));
321     bool ok = false;
322     const int hour = hhRef.toInt(&ok);
323     if (!ok || hour > 23) // More generous than QTimeZone::MaxUtcOffsetSecs
324         return 0;
325 
326     const QStringView mmRef = time.sliced(qMin(mmIndex, time.size()));
327     const int minute = mmRef.isEmpty() ? 0 : mmRef.toInt(&ok);
328     if (!ok || minute < 0 || minute > 59)
329         return 0;
330 
331     *valid = true;
332     return sign * ((hour * 60) + minute) * 60;
333 }
334 #endif // datestring
335 
336 /*****************************************************************************
337   QDate member functions
338  *****************************************************************************/
339 
340 /*!
341     \class QDate
342     \inmodule QtCore
343     \reentrant
344     \brief The QDate class provides date functions.
345 
346     A QDate object represents a particular day, regardless of calendar, locale
347     or other settings used when creating it or supplied by the system.  It can
348     report the year, month and day of the month that represent the day with
349     respect to the proleptic Gregorian calendar or any calendar supplied as a
350     QCalendar object. QDate objects should be passed by value rather than by
351     reference to const; they simply package \c qint64.
352 
353     A QDate object is typically created by giving the year, month, and day
354     numbers explicitly. Note that QDate interprets year numbers less than 100 as
355     presented, i.e., as years 1 through 99, without adding any offset. The
356     static function currentDate() creates a QDate object containing the date
357     read from the system clock. An explicit date can also be set using
358     setDate(). The fromString() function returns a QDate given a string and a
359     date format which is used to interpret the date within the string.
360 
361     The year(), month(), and day() functions provide access to the year, month,
362     and day numbers. When more than one of these values is needed, it is more
363     efficient to call QCalendar::partsFromDate(), to save repeating (potentially
364     expensive) calendrical calculations.
365 
366     Also, dayOfWeek() and dayOfYear() functions are provided. The same
367     information is provided in textual format by toString(). QLocale can map the
368     day numbers to names, QCalendar can map month numbers to names.
369 
370     QDate provides a full set of operators to compare two QDate
371     objects where smaller means earlier, and larger means later.
372 
373     You can increment (or decrement) a date by a given number of days
374     using addDays(). Similarly you can use addMonths() and addYears().
375     The daysTo() function returns the number of days between two
376     dates.
377 
378     The daysInMonth() and daysInYear() functions return how many days there are
379     in this date's month and year, respectively. The isLeapYear() function
380     indicates whether a date is in a leap year. QCalendar can also supply this
381     information, in some cases more conveniently.
382 
383     \section1 Remarks
384 
385     \note All conversion to and from string formats is done using the C locale.
386     For localized conversions, see QLocale.
387 
388     In the Gregorian calendar, there is no year 0. Dates in that year are
389     considered invalid. The year -1 is the year "1 before Christ" or "1 before
390     common era." The day before 1 January 1 CE, QDate(1, 1, 1), is 31 December
391     1 BCE, QDate(-1, 12, 31). Various other calendars behave similarly; see
392     QCalendar::hasYearZero().
393 
394     \section2 Range of Valid Dates
395 
396     Dates are stored internally as a Julian Day number, an integer count of
397     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian
398     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).
399     As well as being an efficient and accurate way of storing an absolute date,
400     it is suitable for converting a date into other calendar systems such as
401     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using
402     QDate::toJulianDay() and can be set using QDate::fromJulianDay().
403 
404     The range of Julian Day numbers that QDate can represent is, for technical
405     reasons, limited to between -784350574879 and 784354017364, which means from
406     before 2 billion BCE to after 2 billion CE. This is more than seven times as
407     wide as the range of dates a QDateTime can represent.
408 
409     \sa QTime, QDateTime, QCalendar, QDateTime::YearRange, QDateEdit, QDateTimeEdit, QCalendarWidget
410 */
411 
412 /*!
413     \fn QDate::QDate()
414 
415     Constructs a null date. Null dates are invalid.
416 
417     \sa isNull(), isValid()
418 */
419 
420 /*!
421     Constructs a date with year \a y, month \a m and day \a d.
422 
423     The date is understood in terms of the Gregorian calendar. If the specified
424     date is invalid, the date is not set and isValid() returns \c false.
425 
426     \warning Years 1 to 99 are interpreted as is. Year 0 is invalid.
427 
428     \sa isValid(), QCalendar::dateFromParts()
429 */
430 
431 QDate::QDate(int y, int m, int d)
432 {
433     if (!QGregorianCalendar::julianFromParts(y, m, d, &jd))
434         jd = nullJd();
435 }
436 
437 QDate::QDate(int y, int m, int d, QCalendar cal)
438 {
439     *this = cal.dateFromParts(y, m, d);
440 }
441 
442 /*!
443     \fn bool QDate::isNull() const
444 
445     Returns \c true if the date is null; otherwise returns \c false. A null
446     date is invalid.
447 
448     \note The behavior of this function is equivalent to isValid().
449 
450     \sa isValid()
451 */
452 
453 /*!
454     \fn bool QDate::isValid() const
455 
456     Returns \c true if this date is valid; otherwise returns \c false.
457 
458     \sa isNull(), QCalendar::isDateValid()
459 */
460 
461 /*!
462     Returns the year of this date.
463 
464     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
465 
466     Returns 0 if the date is invalid. For some calendars, dates before their
467     first year may all be invalid.
468 
469     If using a calendar which has a year 0, check using isValid() if the return
470     is 0. Such calendars use negative year numbers in the obvious way, with
471     year 1 preceded by year 0, in turn preceded by year -1 and so on.
472 
473     Some calendars, despite having no year 0, have a conventional numbering of
474     the years before their first year, counting backwards from 1. For example,
475     in the proleptic Gregorian calendar, successive years before 1 CE (the first
476     year) are identified as 1 BCE, 2 BCE, 3 BCE and so on. For such calendars,
477     negative year numbers are used to indicate these years before year 1, with
478     -1 indicating the year before 1.
479 
480     \sa month(), day(), QCalendar::hasYearZero(), QCalendar::isProleptic(), QCalendar::partsFromDate()
481 */
482 
483 int QDate::year(QCalendar cal) const
484 {
485     if (isValid()) {
486         const auto parts = cal.partsFromDate(*this);
487         if (parts.isValid())
488             return parts.year;
489     }
490     return 0;
491 }
492 
493 /*!
494   \overload
495  */
496 
497 int QDate::year() const
498 {
499     if (isValid()) {
500         const auto parts = QGregorianCalendar::partsFromJulian(jd);
501         if (parts.isValid())
502             return parts.year;
503     }
504     return 0;
505 }
506 
507 /*!
508     Returns the month-number for the date.
509 
510     Numbers the months of the year starting with 1 for the first. Uses \a cal
511     as calendar if supplied, else the Gregorian calendar, for which the month
512     numbering is as follows:
513 
514     \list
515     \li 1 = "January"
516     \li 2 = "February"
517     \li 3 = "March"
518     \li 4 = "April"
519     \li 5 = "May"
520     \li 6 = "June"
521     \li 7 = "July"
522     \li 8 = "August"
523     \li 9 = "September"
524     \li 10 = "October"
525     \li 11 = "November"
526     \li 12 = "December"
527     \endlist
528 
529     Returns 0 if the date is invalid. Note that some calendars may have more
530     than 12 months in some years.
531 
532     \sa year(), day(), QCalendar::partsFromDate()
533 */
534 
535 int QDate::month(QCalendar cal) const
536 {
537     if (isValid()) {
538         const auto parts = cal.partsFromDate(*this);
539         if (parts.isValid())
540             return parts.month;
541     }
542     return 0;
543 }
544 
545 /*!
546   \overload
547  */
548 
549 int QDate::month() const
550 {
551     if (isValid()) {
552         const auto parts = QGregorianCalendar::partsFromJulian(jd);
553         if (parts.isValid())
554             return parts.month;
555     }
556     return 0;
557 }
558 
559 /*!
560     Returns the day of the month for this date.
561 
562     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
563     the return ranges from 1 to 31). Returns 0 if the date is invalid.
564 
565     \sa year(), month(), dayOfWeek(), QCalendar::partsFromDate()
566 */
567 
568 int QDate::day(QCalendar cal) const
569 {
570     if (isValid()) {
571         const auto parts = cal.partsFromDate(*this);
572         if (parts.isValid())
573             return parts.day;
574     }
575     return 0;
576 }
577 
578 /*!
579   \overload
580  */
581 
582 int QDate::day() const
583 {
584     if (isValid()) {
585         const auto parts = QGregorianCalendar::partsFromJulian(jd);
586         if (parts.isValid())
587             return parts.day;
588     }
589     return 0;
590 }
591 
592 /*!
593     Returns the weekday (1 = Monday to 7 = Sunday) for this date.
594 
595     Uses \a cal as calendar if supplied, else the Gregorian calendar. Returns 0
596     if the date is invalid. Some calendars may give special meaning
597     (e.g. intercallary days) to values greater than 7.
598 
599     \sa day(), dayOfYear(), QCalendar::dayOfWeek(), Qt::DayOfWeek
600 */
601 
602 int QDate::dayOfWeek(QCalendar cal) const
603 {
604     if (isNull())
605         return 0;
606 
607     return cal.dayOfWeek(*this);
608 }
609 
610 /*!
611   \overload
612  */
613 
614 int QDate::dayOfWeek() const
615 {
616     return isValid() ? QGregorianCalendar::weekDayOfJulian(jd) : 0;
617 }
618 
619 /*!
620     Returns the day of the year (1 for the first day) for this date.
621 
622     Uses \a cal as calendar if supplied, else the Gregorian calendar.
623     Returns 0 if either the date or the first day of its year is invalid.
624 
625     \sa day(), dayOfWeek(), QCalendar::daysInYear()
626 */
627 
628 int QDate::dayOfYear(QCalendar cal) const
629 {
630     if (isValid()) {
631         QDate firstDay = cal.dateFromParts(year(cal), 1, 1);
632         if (firstDay.isValid())
633             return firstDay.daysTo(*this) + 1;
634     }
635     return 0;
636 }
637 
638 /*!
639   \overload
640  */
641 
642 int QDate::dayOfYear() const
643 {
644     if (isValid()) {
645         qint64 first;
646         if (QGregorianCalendar::julianFromParts(year(), 1, 1, &first))
647             return jd - first + 1;
648     }
649     return 0;
650 }
651 
652 /*!
653     Returns the number of days in the month for this date.
654 
655     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
656     the result ranges from 28 to 31). Returns 0 if the date is invalid.
657 
658     \sa day(), daysInYear(), QCalendar::daysInMonth(),
659         QCalendar::maximumDaysInMonth(), QCalendar::minimumDaysInMonth()
660 */
661 
662 int QDate::daysInMonth(QCalendar cal) const
663 {
664     if (isValid()) {
665         const auto parts = cal.partsFromDate(*this);
666         if (parts.isValid())
667             return cal.daysInMonth(parts.month, parts.year);
668     }
669     return 0;
670 }
671 
672 /*!
673   \overload
674  */
675 
676 int QDate::daysInMonth() const
677 {
678     if (isValid()) {
679         const auto parts = QGregorianCalendar::partsFromJulian(jd);
680         if (parts.isValid())
681             return QGregorianCalendar::monthLength(parts.month, parts.year);
682     }
683     return 0;
684 }
685 
686 /*!
687     Returns the number of days in the year for this date.
688 
689     Uses \a cal as calendar if supplied, else the Gregorian calendar (for which
690     the result is 365 or 366). Returns 0 if the date is invalid.
691 
692     \sa day(), daysInMonth(), QCalendar::daysInYear(), QCalendar::maximumMonthsInYear()
693 */
694 
695 int QDate::daysInYear(QCalendar cal) const
696 {
697     if (isNull())
698         return 0;
699 
700     return cal.daysInYear(year(cal));
701 }
702 
703 /*!
704   \overload
705  */
706 
707 int QDate::daysInYear() const
708 {
709     return isValid() ? QGregorianCalendar::leapTest(year()) ? 366 : 365 : 0;
710 }
711 
712 /*!
713     Returns the ISO 8601 week number (1 to 53).
714 
715     Returns 0 if the date is invalid. Otherwise, returns the week number for the
716     date. If \a yearNumber is not \nullptr (its default), stores the year as
717     *\a{yearNumber}.
718 
719     In accordance with ISO 8601, each week falls in the year to which most of
720     its days belong, in the Gregorian calendar. As ISO 8601's week starts on
721     Monday, this is the year in which the week's Thursday falls. Most years have
722     52 weeks, but some have 53.
723 
724     \note *\a{yearNumber} is not always the same as year(). For example, 1
725     January 2000 has week number 52 in the year 1999, and 31 December
726     2002 has week number 1 in the year 2003.
727 
728     \sa isValid()
729 */
730 
731 int QDate::weekNumber(int *yearNumber) const
732 {
733     if (!isValid())
734         return 0;
735 
736     // This could be replaced by use of QIso8601Calendar, once we implement it.
737     // The Thursday of the same week determines our answer:
738     QDate thursday(addDays(4 - dayOfWeek()));
739     int year = thursday.year();
740     // Week n's Thurs's DOY has 1 <= DOY - 7*(n-1) < 8, so 0 <= DOY + 6 - 7*n < 7:
741     int week = (thursday.dayOfYear() + 6) / 7;
742 
743     if (yearNumber)
744         *yearNumber = year;
745     return week;
746 }
747 
748 static bool inDateTimeRange(qint64 jd, bool start)
749 {
750     using Bounds = std::numeric_limits<qint64>;
751     if (jd < Bounds::min() + JULIAN_DAY_FOR_EPOCH)
752         return false;
753     jd -= JULIAN_DAY_FOR_EPOCH;
754     const qint64 maxDay = Bounds::max() / MSECS_PER_DAY;
755     const qint64 minDay = Bounds::min() / MSECS_PER_DAY - 1;
756     // (Divisions rounded towards zero, as MSECS_PER_DAY has factors other than two.)
757     // Range includes start of last day and end of first:
758     if (start)
759         return jd > minDay && jd <= maxDay;
760     return jd >= minDay && jd < maxDay;
761 }
762 
763 static QDateTime toEarliest(QDate day, const QDateTime &form)
764 {
765     const Qt::TimeSpec spec = form.timeSpec();
766     const int offset = (spec == Qt::OffsetFromUTC) ? form.offsetFromUtc() : 0;
767 #if QT_CONFIG(timezone)
768     QTimeZone zone;
769     if (spec == Qt::TimeZone)
770         zone = form.timeZone();
771 #endif
772     auto moment = [=](QTime time) {
773         switch (spec) {
774         case Qt::OffsetFromUTC: return QDateTime(day, time, spec, offset);
775 #if QT_CONFIG(timezone)
776         case Qt::TimeZone: return QDateTime(day, time, zone);
777 #endif
778         default: return QDateTime(day, time, spec);
779         }
780     };
781     // Longest routine time-zone transition is 2 hours:
782     QDateTime when = moment(QTime(2, 0));
783     if (!when.isValid()) {
784         // Noon should be safe ...
785         when = moment(QTime(12, 0));
786         if (!when.isValid()) {
787             // ... unless it's a 24-hour jump (moving the date-line)
788             when = moment(QTime(23, 59, 59, 999));
789             if (!when.isValid())
790                 return QDateTime();
791         }
792     }
793     int high = when.time().msecsSinceStartOfDay() / 60000;
794     int low = 0;
795     // Binary chop to the right minute
796     while (high > low + 1) {
797         int mid = (high + low) / 2;
798         QDateTime probe = moment(QTime(mid / 60, mid % 60));
799         if (probe.isValid() && probe.date() == day) {
800             high = mid;
801             when = probe;
802         } else {
803             low = mid;
804         }
805     }
806     return when;
807 }
808 
809 /*!
810     \since 5.14
811     \fn QDateTime QDate::startOfDay(Qt::TimeSpec spec, int offsetSeconds) const
812     \fn QDateTime QDate::startOfDay(const QTimeZone &zone) const
813 
814     Returns the start-moment of the day.  Usually, this shall be midnight at the
815     start of the day: however, if a time-zone transition causes the given date
816     to skip over that midnight (e.g. a DST spring-forward skipping from the end
817     of the previous day to 01:00 of the new day), the actual earliest time in
818     the day is returned.  This can only arise when the start-moment is specified
819     in terms of a time-zone (by passing its QTimeZone as \a zone) or in terms of
820     local time (by passing Qt::LocalTime as \a spec; this is its default).
821 
822     The \a offsetSeconds is ignored unless \a spec is Qt::OffsetFromUTC, when it
823     gives the implied zone's offset from UTC.  As UTC and such zones have no
824     transitions, the start of the day is QTime(0, 0) in these cases.
825 
826     In the rare case of a date that was entirely skipped (this happens when a
827     zone east of the international date-line switches to being west of it), the
828     return shall be invalid.  Passing Qt::TimeZone as \a spec (instead of
829     passing a QTimeZone) or passing an invalid time-zone as \a zone will also
830     produce an invalid result, as shall dates that start outside the range
831     representable by QDateTime.
832 
833     \sa endOfDay()
834 */
835 QDateTime QDate::startOfDay(Qt::TimeSpec spec, int offsetSeconds) const
836 {
837     if (!inDateTimeRange(jd, true))
838         return QDateTime();
839 
840     switch (spec) {
841     case Qt::TimeZone: // should pass a QTimeZone instead of Qt::TimeZone
842         qWarning() << "Called QDate::startOfDay(Qt::TimeZone) on" << *this;
843         return QDateTime();
844     case Qt::OffsetFromUTC:
845     case Qt::UTC:
846         return QDateTime(*this, QTime(0, 0), spec, offsetSeconds);
847 
848     case Qt::LocalTime:
849         if (offsetSeconds)
850             qWarning("Ignoring offset (%d seconds) passed with Qt::LocalTime", offsetSeconds);
851         break;
852     }
853     QDateTime when(*this, QTime(0, 0), spec);
854     if (!when.isValid())
855         when = toEarliest(*this, when);
856 
857     return when.isValid() ? when : QDateTime();
858 }
859 
860 #if QT_CONFIG(timezone)
861 /*!
862   \overload
863   \since 5.14
864 */
865 QDateTime QDate::startOfDay(const QTimeZone &zone) const
866 {
867     if (!inDateTimeRange(jd, true) || !zone.isValid())
868         return QDateTime();
869 
870     QDateTime when(*this, QTime(0, 0), zone);
871     if (when.isValid())
872         return when;
873 
874     // The start of the day must have fallen in a spring-forward's gap; find the spring-forward:
875     if (zone.hasTransitions()) {
876         QTimeZone::OffsetData tran
877             // There's unlikely to be another transition before noon tomorrow.
878             // However, the whole of today may have been skipped !
879             = zone.previousTransition(QDateTime(addDays(1), QTime(12, 0), zone));
880         const QDateTime &at = tran.atUtc.toTimeZone(zone);
881         if (at.isValid() && at.date() == *this)
882             return at;
883     }
884 
885     when = toEarliest(*this, when);
886     return when.isValid() ? when : QDateTime();
887 }
888 #endif // timezone
889 
890 static QDateTime toLatest(QDate day, const QDateTime &form)
891 {
892     const Qt::TimeSpec spec = form.timeSpec();
893     const int offset = (spec == Qt::OffsetFromUTC) ? form.offsetFromUtc() : 0;
894 #if QT_CONFIG(timezone)
895     QTimeZone zone;
896     if (spec == Qt::TimeZone)
897         zone = form.timeZone();
898 #endif
899     auto moment = [=](QTime time) {
900         switch (spec) {
901         case Qt::OffsetFromUTC: return QDateTime(day, time, spec, offset);
902 #if QT_CONFIG(timezone)
903         case Qt::TimeZone: return QDateTime(day, time, zone);
904 #endif
905         default: return QDateTime(day, time, spec);
906         }
907     };
908     // Longest routine time-zone transition is 2 hours:
909     QDateTime when = moment(QTime(21, 59, 59, 999));
910     if (!when.isValid()) {
911         // Noon should be safe ...
912         when = moment(QTime(12, 0));
913         if (!when.isValid()) {
914             // ... unless it's a 24-hour jump (moving the date-line)
915             when = moment(QTime(0, 0));
916             if (!when.isValid())
917                 return QDateTime();
918         }
919     }
920     int high = 24 * 60;
921     int low = when.time().msecsSinceStartOfDay() / 60000;
922     // Binary chop to the right minute
923     while (high > low + 1) {
924         int mid = (high + low) / 2;
925         QDateTime probe = moment(QTime(mid / 60, mid % 60, 59, 999));
926         if (probe.isValid() && probe.date() == day) {
927             low = mid;
928             when = probe;
929         } else {
930             high = mid;
931         }
932     }
933     return when;
934 }
935 
936 /*!
937     \since 5.14
938     \fn QDateTime QDate::endOfDay(Qt::TimeSpec spec, int offsetSeconds) const
939     \fn QDateTime QDate::endOfDay(const QTimeZone &zone) const
940 
941     Returns the end-moment of the day.  Usually, this is one millisecond before
942     the midnight at the end of the day: however, if a time-zone transition
943     causes the given date to skip over that midnight (e.g. a DST spring-forward
944     skipping from just before 23:00 to the start of the next day), the actual
945     latest time in the day is returned.  This can only arise when the
946     start-moment is specified in terms of a time-zone (by passing its QTimeZone
947     as \a zone) or in terms of local time (by passing Qt::LocalTime as \a spec;
948     this is its default).
949 
950     The \a offsetSeconds is ignored unless \a spec is Qt::OffsetFromUTC, when it
951     gives the implied zone's offset from UTC.  As UTC and such zones have no
952     transitions, the end of the day is QTime(23, 59, 59, 999) in these cases.
953 
954     In the rare case of a date that was entirely skipped (this happens when a
955     zone east of the international date-line switches to being west of it), the
956     return shall be invalid.  Passing Qt::TimeZone as \a spec (instead of
957     passing a QTimeZone) will also produce an invalid result, as shall dates
958     that end outside the range representable by QDateTime.
959 
960     \sa startOfDay()
961 */
962 QDateTime QDate::endOfDay(Qt::TimeSpec spec, int offsetSeconds) const
963 {
964     if (!inDateTimeRange(jd, false))
965         return QDateTime();
966 
967     switch (spec) {
968     case Qt::TimeZone: // should pass a QTimeZone instead of Qt::TimeZone
969         qWarning() << "Called QDate::endOfDay(Qt::TimeZone) on" << *this;
970         return QDateTime();
971     case Qt::UTC:
972     case Qt::OffsetFromUTC:
973         return QDateTime(*this, QTime(23, 59, 59, 999), spec, offsetSeconds);
974 
975     case Qt::LocalTime:
976         if (offsetSeconds)
977             qWarning("Ignoring offset (%d seconds) passed with Qt::LocalTime", offsetSeconds);
978         break;
979     }
980     QDateTime when(*this, QTime(23, 59, 59, 999), spec);
981     if (!when.isValid())
982         when = toLatest(*this, when);
983     return when.isValid() ? when : QDateTime();
984 }
985 
986 #if QT_CONFIG(timezone)
987 /*!
988   \overload
989   \since 5.14
990 */
991 QDateTime QDate::endOfDay(const QTimeZone &zone) const
992 {
993     if (!inDateTimeRange(jd, false) || !zone.isValid())
994         return QDateTime();
995 
996     QDateTime when(*this, QTime(23, 59, 59, 999), zone);
997     if (when.isValid())
998         return when;
999 
1000     // The end of the day must have fallen in a spring-forward's gap; find the spring-forward:
1001     if (zone.hasTransitions()) {
1002         QTimeZone::OffsetData tran
1003             // It's unlikely there's been another transition since yesterday noon.
1004             // However, the whole of today may have been skipped !
1005             = zone.nextTransition(QDateTime(addDays(-1), QTime(12, 0), zone));
1006         const QDateTime &at = tran.atUtc.toTimeZone(zone);
1007         if (at.isValid() && at.date() == *this)
1008             return at;
1009     }
1010 
1011     when = toLatest(*this, when);
1012     return when.isValid() ? when : QDateTime();
1013 }
1014 #endif // timezone
1015 
1016 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1017 
1018 static QString toStringTextDate(QDate date)
1019 {
1020     if (date.isValid()) {
1021         QCalendar cal; // Always Gregorian
1022         const auto parts = cal.partsFromDate(date);
1023         if (parts.isValid()) {
1024             const QLatin1Char sp(' ');
1025             return QLocale::c().dayName(cal.dayOfWeek(date), QLocale::ShortFormat) + sp
1026                 + cal.monthName(QLocale::c(), parts.month, parts.year, QLocale::ShortFormat)
1027                 // Documented to use 4-digit year
1028                 + sp + QString::asprintf("%d %04d", parts.day, parts.year);
1029         }
1030     }
1031     return QString();
1032 }
1033 
1034 static QString toStringIsoDate(QDate date)
1035 {
1036     const auto parts = QCalendar().partsFromDate(date);
1037     if (parts.isValid() && parts.year >= 0 && parts.year <= 9999)
1038         return QString::asprintf("%04d-%02d-%02d", parts.year, parts.month, parts.day);
1039     return QString();
1040 }
1041 
1042 /*!
1043     \overload
1044 
1045     Returns the date as a string. The \a format parameter determines the format
1046     of the string.
1047 
1048     If the \a format is Qt::TextDate, the string is formatted in the default
1049     way. The day and month names will be in English. An example of this
1050     formatting is "Sat May 20 1995". For localized formatting, see
1051     \l{QLocale::toString()}.
1052 
1053     If the \a format is Qt::ISODate, the string format corresponds
1054     to the ISO 8601 extended specification for representations of
1055     dates and times, taking the form yyyy-MM-dd, where yyyy is the
1056     year, MM is the month of the year (between 01 and 12), and dd is
1057     the day of the month between 01 and 31.
1058 
1059     If the \a format is Qt::RFC2822Date, the string is formatted in
1060     an \l{RFC 2822} compatible way. An example of this formatting is
1061     "20 May 1995".
1062 
1063     If the date is invalid, an empty string will be returned.
1064 
1065     \warning The Qt::ISODate format is only valid for years in the
1066     range 0 to 9999.
1067 
1068     \sa fromString(), QLocale::toString()
1069 */
1070 QString QDate::toString(Qt::DateFormat format) const
1071 {
1072     if (!isValid())
1073         return QString();
1074 
1075     switch (format) {
1076     case Qt::RFC2822Date:
1077         return QLocale::c().toString(*this, u"dd MMM yyyy");
1078     default:
1079     case Qt::TextDate:
1080         return toStringTextDate(*this);
1081     case Qt::ISODate:
1082     case Qt::ISODateWithMs:
1083         // No calendar dependence
1084         return toStringIsoDate(*this);
1085     }
1086 }
1087 
1088 /*!
1089     \fn QString QDate::toString(const QString &format, QCalendar cal) const
1090     \fn QString QDate::toString(QStringView format, QCalendar cal) const
1091 
1092     Returns the date as a string. The \a format parameter determines the format
1093     of the result string. If \a cal is supplied, it determines the calendar used
1094     to represent the date; it defaults to Gregorian.
1095 
1096     These expressions may be used:
1097 
1098     \table
1099     \header \li Expression \li Output
1100     \row \li d \li The day as a number without a leading zero (1 to 31)
1101     \row \li dd \li The day as a number with a leading zero (01 to 31)
1102     \row \li ddd \li The abbreviated day name ('Mon' to 'Sun').
1103     \row \li dddd \li The long day name ('Monday' to 'Sunday').
1104     \row \li M \li The month as a number without a leading zero (1 to 12)
1105     \row \li MM \li The month as a number with a leading zero (01 to 12)
1106     \row \li MMM \li The abbreviated month name ('Jan' to 'Dec').
1107     \row \li MMMM \li The long month name ('January' to 'December').
1108     \row \li yy \li The year as a two digit number (00 to 99)
1109     \row \li yyyy \li The year as a four digit number. If the year is negative,
1110             a minus sign is prepended, making five characters.
1111     \endtable
1112 
1113     Any sequence of characters enclosed in single quotes will be included
1114     verbatim in the output string (stripped of the quotes), even if it contains
1115     formatting characters. Two consecutive single quotes ("''") are replaced by
1116     a single quote in the output. All other characters in the format string are
1117     included verbatim in the output string.
1118 
1119     Formats without separators (e.g. "ddMM") are supported but must be used with
1120     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
1121     produces "212" it could mean either the 2nd of December or the 21st of
1122     February).
1123 
1124     Example format strings (assuming that the QDate is the 20 July
1125     1969):
1126 
1127     \table
1128     \header \li Format            \li Result
1129     \row    \li dd.MM.yyyy        \li 20.07.1969
1130     \row    \li ddd MMMM d yy     \li Sun July 20 69
1131     \row    \li 'The day is' dddd \li The day is Sunday
1132     \endtable
1133 
1134     If the datetime is invalid, an empty string will be returned.
1135 
1136     \note Day and month names are given in English (C locale).
1137     If localized month and day names are desired, use
1138     QLocale::system().toString().
1139 
1140     \sa fromString(), QDateTime::toString(), QTime::toString(), QLocale::toString()
1141 
1142 */
1143 QString QDate::toString(QStringView format, QCalendar cal) const
1144 {
1145     return QLocale::c().toString(*this, format, cal);
1146 }
1147 #endif // datestring
1148 
1149 /*!
1150     \since 4.2
1151 
1152     Sets this to represent the date, in the Gregorian calendar, with the given
1153     \a year, \a month and \a day numbers. Returns true if the resulting date is
1154     valid, otherwise it sets this to represent an invalid date and returns
1155     false.
1156 
1157     \sa isValid(), QCalendar::dateFromParts()
1158 */
1159 bool QDate::setDate(int year, int month, int day)
1160 {
1161     if (QGregorianCalendar::julianFromParts(year, month, day, &jd))
1162         return true;
1163 
1164     jd = nullJd();
1165     return false;
1166 }
1167 
1168 /*!
1169     \since 5.14
1170 
1171     Sets this to represent the date, in the given calendar \a cal, with the
1172     given \a year, \a month and \a day numbers. Returns true if the resulting
1173     date is valid, otherwise it sets this to represent an invalid date and
1174     returns false.
1175 
1176     \sa isValid(), QCalendar::dateFromParts()
1177 */
1178 
1179 bool QDate::setDate(int year, int month, int day, QCalendar cal)
1180 {
1181     *this = QDate(year, month, day, cal);
1182     return isValid();
1183 }
1184 
1185 /*!
1186     \since 4.5
1187 
1188     Extracts the date's year, month, and day, and assigns them to
1189     *\a year, *\a month, and *\a day. The pointers may be null.
1190 
1191     Returns 0 if the date is invalid.
1192 
1193     \note In Qt versions prior to 5.7, this function is marked as non-\c{const}.
1194 
1195     \sa year(), month(), day(), isValid(), QCalendar::partsFromDate()
1196 */
1197 void QDate::getDate(int *year, int *month, int *day) const
1198 {
1199     QCalendar::YearMonthDay parts; // invalid by default
1200     if (isValid())
1201         parts = QGregorianCalendar::partsFromJulian(jd);
1202 
1203     const bool ok = parts.isValid();
1204     if (year)
1205         *year = ok ? parts.year : 0;
1206     if (month)
1207         *month = ok ? parts.month : 0;
1208     if (day)
1209         *day = ok ? parts.day : 0;
1210 }
1211 
1212 /*!
1213     Returns a QDate object containing a date \a ndays later than the
1214     date of this object (or earlier if \a ndays is negative).
1215 
1216     Returns a null date if the current date is invalid or the new date is
1217     out of range.
1218 
1219     \sa addMonths(), addYears(), daysTo()
1220 */
1221 
1222 QDate QDate::addDays(qint64 ndays) const
1223 {
1224     if (isNull())
1225         return QDate();
1226 
1227     // Due to limits on minJd() and maxJd() we know that any overflow
1228     // will be invalid and caught by fromJulianDay().
1229     return fromJulianDay(jd + ndays);
1230 }
1231 
1232 /*!
1233     Returns a QDate object containing a date \a nmonths later than the
1234     date of this object (or earlier if \a nmonths is negative).
1235 
1236     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
1237 
1238     \note If the ending day/month combination does not exist in the resulting
1239     month/year, this function will return a date that is the latest valid date
1240     in the selected month.
1241 
1242     \sa addDays(), addYears()
1243 */
1244 
1245 QDate QDate::addMonths(int nmonths, QCalendar cal) const
1246 {
1247     if (!isValid())
1248         return QDate();
1249 
1250     if (nmonths == 0)
1251         return *this;
1252 
1253     auto parts = cal.partsFromDate(*this);
1254 
1255     if (!parts.isValid())
1256         return QDate();
1257     Q_ASSERT(parts.year || cal.hasYearZero());
1258 
1259     parts.month += nmonths;
1260     while (parts.month <= 0) {
1261         if (--parts.year || cal.hasYearZero())
1262             parts.month += cal.monthsInYear(parts.year);
1263     }
1264     int count = cal.monthsInYear(parts.year);
1265     while (parts.month > count) {
1266         parts.month -= count;
1267         count = (++parts.year || cal.hasYearZero()) ? cal.monthsInYear(parts.year) : 0;
1268     }
1269 
1270     return fixedDate(std::move(parts), cal);
1271 }
1272 
1273 /*!
1274   \overload
1275 */
1276 
1277 QDate QDate::addMonths(int nmonths) const
1278 {
1279     if (isNull())
1280         return QDate();
1281 
1282     if (nmonths == 0)
1283         return *this;
1284 
1285     auto parts = QGregorianCalendar::partsFromJulian(jd);
1286 
1287     if (!parts.isValid())
1288         return QDate();
1289     Q_ASSERT(parts.year);
1290 
1291     parts.month += nmonths;
1292     while (parts.month <= 0) {
1293         if (--parts.year) // skip over year 0
1294             parts.month += 12;
1295     }
1296     while (parts.month > 12) {
1297         parts.month -= 12;
1298         if (!++parts.year) // skip over year 0
1299             ++parts.year;
1300     }
1301 
1302     return fixedDate(std::move(parts));
1303 }
1304 
1305 /*!
1306     Returns a QDate object containing a date \a nyears later than the
1307     date of this object (or earlier if \a nyears is negative).
1308 
1309     Uses \a cal as calendar, if supplied, else the Gregorian calendar.
1310 
1311     \note If the ending day/month combination does not exist in the resulting
1312     year (e.g., for the Gregorian calendar, if the date was Feb 29 and the final
1313     year is not a leap year), this function will return a date that is the
1314     latest valid date in the given month (in the example, Feb 28).
1315 
1316     \sa addDays(), addMonths()
1317 */
1318 
1319 QDate QDate::addYears(int nyears, QCalendar cal) const
1320 {
1321     if (!isValid())
1322         return QDate();
1323 
1324     auto parts = cal.partsFromDate(*this);
1325     if (!parts.isValid())
1326         return QDate();
1327 
1328     int old_y = parts.year;
1329     parts.year += nyears;
1330 
1331     // If we just crossed (or hit) a missing year zero, adjust year by +/- 1:
1332     if (!cal.hasYearZero() && ((old_y > 0) != (parts.year > 0) || !parts.year))
1333         parts.year += nyears > 0 ? +1 : -1;
1334 
1335     return fixedDate(std::move(parts), cal);
1336 }
1337 
1338 /*!
1339     \overload
1340 */
1341 
1342 QDate QDate::addYears(int nyears) const
1343 {
1344     if (isNull())
1345         return QDate();
1346 
1347     auto parts = QGregorianCalendar::partsFromJulian(jd);
1348     if (!parts.isValid())
1349         return QDate();
1350 
1351     int old_y = parts.year;
1352     parts.year += nyears;
1353 
1354     // If we just crossed (or hit) a missing year zero, adjust year by +/- 1:
1355     if ((old_y > 0) != (parts.year > 0) || !parts.year)
1356         parts.year += nyears > 0 ? +1 : -1;
1357 
1358     return fixedDate(std::move(parts));
1359 }
1360 
1361 /*!
1362     Returns the number of days from this date to \a d (which is
1363     negative if \a d is earlier than this date).
1364 
1365     Returns 0 if either date is invalid.
1366 
1367     Example:
1368     \snippet code/src_corelib_time_qdatetime.cpp 0
1369 
1370     \sa addDays()
1371 */
1372 
1373 qint64 QDate::daysTo(QDate d) const
1374 {
1375     if (isNull() || d.isNull())
1376         return 0;
1377 
1378     // Due to limits on minJd() and maxJd() we know this will never overflow
1379     return d.jd - jd;
1380 }
1381 
1382 
1383 /*!
1384     \fn bool QDate::operator==(QDate lhs, QDate rhs)
1385 
1386     Returns \c true if \a lhs and \a rhs represent the same day, otherwise
1387     \c false.
1388 */
1389 
1390 /*!
1391     \fn bool QDate::operator!=(QDate lhs, QDate rhs)
1392 
1393     Returns \c true if \a lhs and \a rhs represent distinct days; otherwise
1394     returns \c false.
1395 
1396     \sa operator==()
1397 */
1398 
1399 /*!
1400     \fn bool QDate::operator<(QDate lhs, QDate rhs)
1401 
1402     Returns \c true if \a lhs is earlier than \a rhs; otherwise returns \c false.
1403 */
1404 
1405 /*!
1406     \fn bool QDate::operator<=(QDate lhs, QDate rhs)
1407 
1408     Returns \c true if \a lhs is earlier than or equal to \a rhs;
1409     otherwise returns \c false.
1410 */
1411 
1412 /*!
1413     \fn bool QDate::operator>(QDate lhs, QDate rhs)
1414 
1415     Returns \c true if \a lhs is later than \a rhs; otherwise returns \c false.
1416 */
1417 
1418 /*!
1419     \fn bool QDate::operator>=(QDate lhs, QDate rhs)
1420 
1421     Returns \c true if \a lhs is later than or equal to \a rhs;
1422     otherwise returns \c false.
1423 */
1424 
1425 /*!
1426     \fn QDate::currentDate()
1427     Returns the current date, as reported by the system clock.
1428 
1429     \sa QTime::currentTime(), QDateTime::currentDateTime()
1430 */
1431 
1432 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1433 namespace {
1434 
1435 struct ParsedInt { qulonglong value = 0; bool ok = false; };
1436 
1437 /*
1438     /internal
1439 
1440     Read a whole number that must be the whole text.  QStringView::toULongLong()
1441     will happily ignore spaces and accept signs; but various date formats'
1442     fields (e.g. all in ISO) should not.
1443 */
1444 ParsedInt readInt(QStringView text)
1445 {
1446     ParsedInt result;
1447     for (QStringIterator it(text); it.hasNext();) {
1448         if (!QChar::isDigit(it.next()))
1449             return result;
1450     }
1451     result.value = text.toULongLong(&result.ok);
1452     return result;
1453 }
1454 
1455 }
1456 
1457 /*!
1458     \fn QDate QDate::fromString(const QString &string, Qt::DateFormat format)
1459 
1460     Returns the QDate represented by the \a string, using the
1461     \a format given, or an invalid date if the string cannot be
1462     parsed.
1463 
1464     Note for Qt::TextDate: only English month names (e.g. "Jan" in short form or
1465     "January" in long form) are recognized.
1466 
1467     \sa toString(), QLocale::toDate()
1468 */
1469 
1470 /*!
1471     \overload
1472     \since 6.0
1473 */
1474 QDate QDate::fromString(QStringView string, Qt::DateFormat format)
1475 {
1476     if (string.isEmpty())
1477         return QDate();
1478 
1479     switch (format) {
1480     case Qt::RFC2822Date:
1481         return rfcDateImpl(string).date;
1482     default:
1483     case Qt::TextDate: {
1484         // Documented as "ddd MMM d yyyy"
1485         auto parts = string.split(u' ', Qt::SkipEmptyParts);
1486 
1487         if (parts.count() != 4)
1488             return QDate();
1489 
1490         bool ok = false;
1491         int year = parts.at(3).toInt(&ok);
1492         int day = ok ? parts.at(2).toInt(&ok) : 0;
1493         if (!ok || !day)
1494             return QDate();
1495 
1496         const int month = fromShortMonthName(parts.at(1));
1497         if (month == -1) // Month name matches no English or localised name.
1498             return QDate();
1499 
1500         return QDate(year, month, day);
1501         }
1502     case Qt::ISODate:
1503         // Semi-strict parsing, must be long enough and have punctuators as separators
1504         if (string.size() >= 10 && string.at(4).isPunct() && string.at(7).isPunct()
1505                 && (string.size() == 10 || !string.at(10).isDigit())) {
1506             const ParsedInt year = readInt(string.first(4));
1507             const ParsedInt month = readInt(string.sliced(5, 2));
1508             const ParsedInt day = readInt(string.sliced(8, 2));
1509             if (year.ok && year.value > 0 && year.value <= 9999 && month.ok && day.ok)
1510                 return QDate(year.value, month.value, day.value);
1511         }
1512         break;
1513     }
1514     return QDate();
1515 }
1516 
1517 /*!
1518     \fn QDate QDate::fromString(const QString &string, const QString &format, QCalendar cal)
1519 
1520     Returns the QDate represented by the \a string, using the \a
1521     format given, or an invalid date if the string cannot be parsed.
1522 
1523     Uses \a cal as calendar if supplied, else the Gregorian calendar. Ranges of
1524     values in the format descriptions below are for the latter; they may be
1525     different for other calendars.
1526 
1527     These expressions may be used for the format:
1528 
1529     \table
1530     \header \li Expression \li Output
1531     \row \li d \li The day as a number without a leading zero (1 to 31)
1532     \row \li dd \li The day as a number with a leading zero (01 to 31)
1533     \row \li ddd \li The abbreviated day name ('Mon' to 'Sun').
1534     \row \li dddd \li The long day name ('Monday' to 'Sunday').
1535     \row \li M \li The month as a number without a leading zero (1 to 12)
1536     \row \li MM \li The month as a number with a leading zero (01 to 12)
1537     \row \li MMM \li The abbreviated month name ('Jan' to 'Dec').
1538     \row \li MMMM \li The long month name ('January' to 'December').
1539     \row \li yy \li The year as a two digit number (00 to 99)
1540     \row \li yyyy \li The year as a four digit number, possibly plus a leading
1541              minus sign for negative years.
1542     \endtable
1543 
1544     \note Day and month names must be given in English (C locale).
1545     If localized month and day names are used, use
1546     QLocale::system().toDate().
1547 
1548     All other input characters will be treated as text. Any non-empty sequence
1549     of characters enclosed in single quotes will also be treated (stripped of
1550     the quotes) as text and not be interpreted as expressions. For example:
1551 
1552     \snippet code/src_corelib_time_qdatetime.cpp 1
1553 
1554     If the format is not satisfied, an invalid QDate is returned. The
1555     expressions that don't expect leading zeroes (d, M) will be
1556     greedy. This means that they will use two digits even if this
1557     will put them outside the accepted range of values and leaves too
1558     few digits for other sections. For example, the following format
1559     string could have meant January 30 but the M will grab two
1560     digits, resulting in an invalid date:
1561 
1562     \snippet code/src_corelib_time_qdatetime.cpp 2
1563 
1564     For any field that is not represented in the format the following
1565     defaults are used:
1566 
1567     \table
1568     \header \li Field  \li Default value
1569     \row    \li Year   \li 1900
1570     \row    \li Month  \li 1 (January)
1571     \row    \li Day    \li 1
1572     \endtable
1573 
1574     The following examples demonstrate the default values:
1575 
1576     \snippet code/src_corelib_time_qdatetime.cpp 3
1577 
1578     \sa toString(), QDateTime::fromString(), QTime::fromString(),
1579         QLocale::toDate()
1580 */
1581 
1582 /*!
1583     \fn QDate QDate::fromString(QStringView string, QStringView format, QCalendar cal)
1584     \overload
1585     \since 6.0
1586 */
1587 
1588 /*!
1589     \overload
1590     \since 6.0
1591 */
1592 QDate QDate::fromString(const QString &string, QStringView format, QCalendar cal)
1593 {
1594     QDate date;
1595 #if QT_CONFIG(datetimeparser)
1596     QDateTimeParser dt(QMetaType::QDate, QDateTimeParser::FromString, cal);
1597     dt.setDefaultLocale(QLocale::c());
1598     if (dt.parseFormat(format))
1599         dt.fromString(string, &date, nullptr);
1600 #else
1601     Q_UNUSED(string);
1602     Q_UNUSED(format);
1603     Q_UNUSED(cal);
1604 #endif
1605     return date;
1606 }
1607 #endif // datestring
1608 
1609 /*!
1610     \overload
1611 
1612     Returns \c true if the specified date (\a year, \a month, and \a day) is
1613     valid in the Gregorian calendar; otherwise returns \c false.
1614 
1615     Example:
1616     \snippet code/src_corelib_time_qdatetime.cpp 4
1617 
1618     \sa isNull(), setDate(), QCalendar::isDateValid()
1619 */
1620 
1621 bool QDate::isValid(int year, int month, int day)
1622 {
1623     return QGregorianCalendar::validParts(year, month, day);
1624 }
1625 
1626 /*!
1627     \fn bool QDate::isLeapYear(int year)
1628 
1629     Returns \c true if the specified \a year is a leap year in the Gregorian
1630     calendar; otherwise returns \c false.
1631 
1632     \sa QCalendar::isLeapYear()
1633 */
1634 
1635 bool QDate::isLeapYear(int y)
1636 {
1637     return QGregorianCalendar::leapTest(y);
1638 }
1639 
1640 /*! \fn static QDate QDate::fromJulianDay(qint64 jd)
1641 
1642     Converts the Julian day \a jd to a QDate.
1643 
1644     \sa toJulianDay()
1645 */
1646 
1647 /*! \fn int QDate::toJulianDay() const
1648 
1649     Converts the date to a Julian day.
1650 
1651     \sa fromJulianDay()
1652 */
1653 
1654 /*****************************************************************************
1655   QTime member functions
1656  *****************************************************************************/
1657 
1658 /*!
1659     \class QTime
1660     \inmodule QtCore
1661     \reentrant
1662 
1663     \brief The QTime class provides clock time functions.
1664 
1665     A QTime object contains a clock time, which it can express as the numbers of
1666     hours, minutes, seconds, and milliseconds since midnight. It provides
1667     functions for comparing times and for manipulating a time by adding a number
1668     of milliseconds. QTime objects should be passed by value rather than by
1669     reference to const; they simply package \c int.
1670 
1671     QTime uses the 24-hour clock format; it has no concept of AM/PM.
1672     Unlike QDateTime, QTime knows nothing about time zones or
1673     daylight-saving time (DST).
1674 
1675     A QTime object is typically created either by giving the number of hours,
1676     minutes, seconds, and milliseconds explicitly, or by using the static
1677     function currentTime(), which creates a QTime object that represents the
1678     system's local time.
1679 
1680     The hour(), minute(), second(), and msec() functions provide
1681     access to the number of hours, minutes, seconds, and milliseconds
1682     of the time. The same information is provided in textual format by
1683     the toString() function.
1684 
1685     The addSecs() and addMSecs() functions provide the time a given
1686     number of seconds or milliseconds later than a given time.
1687     Correspondingly, the number of seconds or milliseconds
1688     between two times can be found using secsTo() or msecsTo().
1689 
1690     QTime provides a full set of operators to compare two QTime
1691     objects; an earlier time is considered smaller than a later one;
1692     if A.msecsTo(B) is positive, then A < B.
1693 
1694     QTime objects can also be created from a text representation using
1695     fromString() and converted to a string representation using toString(). All
1696     conversion to and from string formats is done using the C locale.  For
1697     localized conversions, see QLocale.
1698 
1699     \sa QDate, QDateTime
1700 */
1701 
1702 /*!
1703     \fn QTime::QTime()
1704 
1705     Constructs a null time object. For a null time, isNull() returns \c true and
1706     isValid() returns \c false. If you need a zero time, use QTime(0, 0).  For
1707     the start of a day, see QDate::startOfDay().
1708 
1709     \sa isNull(), isValid()
1710 */
1711 
1712 /*!
1713     Constructs a time with hour \a h, minute \a m, seconds \a s and
1714     milliseconds \a ms.
1715 
1716     \a h must be in the range 0 to 23, \a m and \a s must be in the
1717     range 0 to 59, and \a ms must be in the range 0 to 999.
1718 
1719     \sa isValid()
1720 */
1721 
1722 QTime::QTime(int h, int m, int s, int ms)
1723 {
1724     setHMS(h, m, s, ms);
1725 }
1726 
1727 
1728 /*!
1729     \fn bool QTime::isNull() const
1730 
1731     Returns \c true if the time is null (i.e., the QTime object was
1732     constructed using the default constructor); otherwise returns
1733     false. A null time is also an invalid time.
1734 
1735     \sa isValid()
1736 */
1737 
1738 /*!
1739     Returns \c true if the time is valid; otherwise returns \c false. For example,
1740     the time 23:30:55.746 is valid, but 24:12:30 is invalid.
1741 
1742     \sa isNull()
1743 */
1744 
1745 bool QTime::isValid() const
1746 {
1747     return mds > NullTime && mds < MSECS_PER_DAY;
1748 }
1749 
1750 
1751 /*!
1752     Returns the hour part (0 to 23) of the time.
1753 
1754     Returns -1 if the time is invalid.
1755 
1756     \sa minute(), second(), msec()
1757 */
1758 
1759 int QTime::hour() const
1760 {
1761     if (!isValid())
1762         return -1;
1763 
1764     return ds() / MSECS_PER_HOUR;
1765 }
1766 
1767 /*!
1768     Returns the minute part (0 to 59) of the time.
1769 
1770     Returns -1 if the time is invalid.
1771 
1772     \sa hour(), second(), msec()
1773 */
1774 
1775 int QTime::minute() const
1776 {
1777     if (!isValid())
1778         return -1;
1779 
1780     return (ds() % MSECS_PER_HOUR) / MSECS_PER_MIN;
1781 }
1782 
1783 /*!
1784     Returns the second part (0 to 59) of the time.
1785 
1786     Returns -1 if the time is invalid.
1787 
1788     \sa hour(), minute(), msec()
1789 */
1790 
1791 int QTime::second() const
1792 {
1793     if (!isValid())
1794         return -1;
1795 
1796     return (ds() / MSECS_PER_SEC) % SECS_PER_MIN;
1797 }
1798 
1799 /*!
1800     Returns the millisecond part (0 to 999) of the time.
1801 
1802     Returns -1 if the time is invalid.
1803 
1804     \sa hour(), minute(), second()
1805 */
1806 
1807 int QTime::msec() const
1808 {
1809     if (!isValid())
1810         return -1;
1811 
1812     return ds() % MSECS_PER_SEC;
1813 }
1814 
1815 #if QT_CONFIG(datestring) // depends on, so implies, textdate
1816 /*!
1817     \overload
1818 
1819     Returns the time as a string. The \a format parameter determines
1820     the format of the string.
1821 
1822     If \a format is Qt::TextDate, the string format is HH:mm:ss;
1823     e.g. 1 second before midnight would be "23:59:59".
1824 
1825     If \a format is Qt::ISODate, the string format corresponds to the
1826     ISO 8601 extended specification for representations of dates,
1827     represented by HH:mm:ss. To include milliseconds in the ISO 8601
1828     date, use the \a format Qt::ISODateWithMs, which corresponds to
1829     HH:mm:ss.zzz.
1830 
1831     If the \a format is Qt::RFC2822Date, the string is formatted in
1832     an \l{RFC 2822} compatible way. An example of this formatting is
1833     "23:59:20".
1834 
1835     If the time is invalid, an empty string will be returned.
1836 
1837     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1838 */
1839 
1840 QString QTime::toString(Qt::DateFormat format) const
1841 {
1842     if (!isValid())
1843         return QString();
1844 
1845     switch (format) {
1846     case Qt::ISODateWithMs:
1847         return QString::asprintf("%02d:%02d:%02d.%03d", hour(), minute(), second(), msec());
1848     case Qt::RFC2822Date:
1849     case Qt::ISODate:
1850     case Qt::TextDate:
1851     default:
1852         return QString::asprintf("%02d:%02d:%02d", hour(), minute(), second());
1853     }
1854 }
1855 
1856 /*!
1857     \fn QString QTime::toString(const QString &format) const
1858     \fn QString QTime::toString(QStringView format) const
1859 
1860     Returns the time as a string. The \a format parameter determines
1861     the format of the result string.
1862 
1863     These expressions may be used:
1864 
1865     \table
1866     \header \li Expression \li Output
1867     \row \li h
1868          \li The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
1869     \row \li hh
1870          \li The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
1871     \row \li H
1872          \li The hour without a leading zero (0 to 23, even with AM/PM display)
1873     \row \li HH
1874          \li The hour with a leading zero (00 to 23, even with AM/PM display)
1875     \row \li m \li The minute without a leading zero (0 to 59)
1876     \row \li mm \li The minute with a leading zero (00 to 59)
1877     \row \li s \li The whole second, without any leading zero (0 to 59)
1878     \row \li ss \li The whole second, with a leading zero where applicable (00 to 59)
1879     \row \li z \li The fractional part of the second, to go after a decimal
1880                 point, without trailing zeroes (0 to 999).  Thus "\c{s.z}"
1881                 reports the seconds to full available (millisecond) precision
1882                 without trailing zeroes.
1883     \row \li zzz \li The fractional part of the second, to millisecond
1884                 precision, including trailing zeroes where applicable (000 to 999).
1885     \row \li AP or A
1886          \li Use AM/PM display. \e A/AP will be replaced by 'AM' or 'PM'
1887     \row \li ap or a
1888          \li Use am/pm display. \e a/ap will be replaced by 'am' or 'pm'
1889     \row \li t \li The timezone (for example "CEST")
1890     \endtable
1891 
1892     Any non-empty sequence of characters enclosed in single quotes will be
1893     included verbatim in the output string (stripped of the quotes), even if it
1894     contains formatting characters. Two consecutive single quotes ("''") are
1895     replaced by a single quote in the output. All other characters in the format
1896     string are included verbatim in the output string.
1897 
1898     Formats without separators (e.g. "ddMM") are supported but must be used with
1899     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
1900     produces "212" it could mean either the 2nd of December or the 21st of
1901     February).
1902 
1903     Example format strings (assuming that the QTime is 14:13:09.042 and the system
1904     locale is \c{en_US})
1905 
1906     \table
1907     \header \li Format \li Result
1908     \row \li hh:mm:ss.zzz \li 14:13:09.042
1909     \row \li h:m:s ap     \li 2:13:9 pm
1910     \row \li H:m:s a      \li 14:13:9 pm
1911     \endtable
1912 
1913     If the time is invalid, an empty string will be returned.
1914 
1915     \note If localized forms of am or pm (the AP, ap, A or a formats) are
1916     desired, please use QLocale::system().toString().
1917 
1918     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1919 */
1920 QString QTime::toString(QStringView format) const
1921 {
1922     return QLocale::c().toString(*this, format);
1923 }
1924 #endif // datestring
1925 
1926 /*!
1927     Sets the time to hour \a h, minute \a m, seconds \a s and
1928     milliseconds \a ms.
1929 
1930     \a h must be in the range 0 to 23, \a m and \a s must be in the
1931     range 0 to 59, and \a ms must be in the range 0 to 999.
1932     Returns \c true if the set time is valid; otherwise returns \c false.
1933 
1934     \sa isValid()
1935 */
1936 
1937 bool QTime::setHMS(int h, int m, int s, int ms)
1938 {
1939     if (!isValid(h,m,s,ms)) {
1940         mds = NullTime;                // make this invalid
1941         return false;
1942     }
1943     mds = (h * SECS_PER_HOUR + m * SECS_PER_MIN + s) * MSECS_PER_SEC + ms;
1944     return true;
1945 }
1946 
1947 /*!
1948     Returns a QTime object containing a time \a s seconds later
1949     than the time of this object (or earlier if \a s is negative).
1950 
1951     Note that the time will wrap if it passes midnight.
1952 
1953     Returns a null time if this time is invalid.
1954 
1955     Example:
1956 
1957     \snippet code/src_corelib_time_qdatetime.cpp 5
1958 
1959     \sa addMSecs(), secsTo(), QDateTime::addSecs()
1960 */
1961 
1962 QTime QTime::addSecs(int s) const
1963 {
1964     s %= SECS_PER_DAY;
1965     return addMSecs(s * MSECS_PER_SEC);
1966 }
1967 
1968 /*!
1969     Returns the number of seconds from this time to \a t.
1970     If \a t is earlier than this time, the number of seconds returned
1971     is negative.
1972 
1973     Because QTime measures time within a day and there are 86400
1974     seconds in a day, the result is always between -86400 and 86400.
1975 
1976     secsTo() does not take into account any milliseconds.
1977 
1978     Returns 0 if either time is invalid.
1979 
1980     \sa addSecs(), QDateTime::secsTo()
1981 */
1982 
1983 int QTime::secsTo(QTime t) const
1984 {
1985     if (!isValid() || !t.isValid())
1986         return 0;
1987 
1988     // Truncate milliseconds as we do not want to consider them.
1989     int ourSeconds = ds() / MSECS_PER_SEC;
1990     int theirSeconds = t.ds() / MSECS_PER_SEC;
1991     return theirSeconds - ourSeconds;
1992 }
1993 
1994 /*!
1995     Returns a QTime object containing a time \a ms milliseconds later
1996     than the time of this object (or earlier if \a ms is negative).
1997 
1998     Note that the time will wrap if it passes midnight. See addSecs()
1999     for an example.
2000 
2001     Returns a null time if this time is invalid.
2002 
2003     \sa addSecs(), msecsTo(), QDateTime::addMSecs()
2004 */
2005 
2006 QTime QTime::addMSecs(int ms) const
2007 {
2008     QTime t;
2009     if (isValid()) {
2010         if (ms < 0) {
2011             // %,/ not well-defined for -ve, so always work with +ve.
2012             int negdays = (MSECS_PER_DAY - ms) / MSECS_PER_DAY;
2013             t.mds = (ds() + ms + negdays * MSECS_PER_DAY) % MSECS_PER_DAY;
2014         } else {
2015             t.mds = (ds() + ms) % MSECS_PER_DAY;
2016         }
2017     }
2018     return t;
2019 }
2020 
2021 /*!
2022     Returns the number of milliseconds from this time to \a t.
2023     If \a t is earlier than this time, the number of milliseconds returned
2024     is negative.
2025 
2026     Because QTime measures time within a day and there are 86400
2027     seconds in a day, the result is always between -86400000 and
2028     86400000 ms.
2029 
2030     Returns 0 if either time is invalid.
2031 
2032     \sa secsTo(), addMSecs(), QDateTime::msecsTo()
2033 */
2034 
2035 int QTime::msecsTo(QTime t) const
2036 {
2037     if (!isValid() || !t.isValid())
2038         return 0;
2039     return t.ds() - ds();
2040 }
2041 
2042 
2043 /*!
2044     \fn bool QTime::operator==(QTime lhs, QTime rhs)
2045 
2046     Returns \c true if \a lhs is equal to \a rhs; otherwise returns \c false.
2047 */
2048 
2049 /*!
2050     \fn bool QTime::operator!=(QTime lhs, QTime rhs)
2051 
2052     Returns \c true if \a lhs is different from \a rhs; otherwise returns \c false.
2053 */
2054 
2055 /*!
2056     \fn bool QTime::operator<(QTime lhs, QTime rhs)
2057 
2058     Returns \c true if \a lhs is earlier than \a rhs; otherwise returns \c false.
2059 */
2060 
2061 /*!
2062     \fn bool QTime::operator<=(QTime lhs, QTime rhs)
2063 
2064     Returns \c true if \a lhs is earlier than or equal to \a rhs;
2065     otherwise returns \c false.
2066 */
2067 
2068 /*!
2069     \fn bool QTime::operator>(QTime lhs, QTime rhs)
2070 
2071     Returns \c true if \a lhs is later than \a rhs; otherwise returns \c false.
2072 */
2073 
2074 /*!
2075     \fn bool QTime::operator>=(QTime lhs, QTime rhs)
2076 
2077     Returns \c true if \a lhs is later than or equal to \a rhs;
2078     otherwise returns \c false.
2079 */
2080 
2081 /*!
2082     \fn QTime QTime::fromMSecsSinceStartOfDay(int msecs)
2083 
2084     Returns a new QTime instance with the time set to the number of \a msecs
2085     since the start of the day, i.e. since 00:00:00.
2086 
2087     If \a msecs falls outside the valid range an invalid QTime will be returned.
2088 
2089     \sa msecsSinceStartOfDay()
2090 */
2091 
2092 /*!
2093     \fn int QTime::msecsSinceStartOfDay() const
2094 
2095     Returns the number of msecs since the start of the day, i.e. since 00:00:00.
2096 
2097     \sa fromMSecsSinceStartOfDay()
2098 */
2099 
2100 /*!
2101     \fn QTime::currentTime()
2102 
2103     Returns the current time as reported by the system clock.
2104 
2105     Note that the accuracy depends on the accuracy of the underlying
2106     operating system; not all systems provide 1-millisecond accuracy.
2107 
2108     Furthermore, currentTime() only increases within each day; it shall drop by
2109     24 hours each time midnight passes; and, beside this, changes in it may not
2110     correspond to elapsed time, if a daylight-saving transition intervenes.
2111 
2112     \sa QDateTime::currentDateTime(), QDateTime::currentDateTimeUtc()
2113 */
2114 
2115 #if QT_CONFIG(datestring) // depends on, so implies, textdate
2116 
2117 static QTime fromIsoTimeString(QStringView string, Qt::DateFormat format, bool *isMidnight24)
2118 {
2119     Q_ASSERT(format == Qt::TextDate || format == Qt::ISODate || format == Qt::ISODateWithMs);
2120     if (isMidnight24)
2121         *isMidnight24 = false;
2122     // Match /\d\d(:\d\d(:\d\d)?)?([,.]\d+)?/ as "HH[:mm[:ss]][.zzz]"
2123     // The fractional part, if present, is in the same units as the field it follows.
2124     // TextDate restricts fractional parts to the seconds field.
2125 
2126     QStringView tail;
2127     const int dot = string.indexOf(u'.'), comma = string.indexOf(u',');
2128     if (dot != -1) {
2129         tail = string.sliced(dot + 1);
2130         if (tail.indexOf(u'.') != -1) // Forbid second dot:
2131             return QTime();
2132         string = string.first(dot);
2133     } else if (comma != -1) {
2134         tail = string.sliced(comma + 1);
2135         string = string.first(comma);
2136     }
2137     if (tail.indexOf(u',') != -1) // Forbid comma after first dot-or-comma:
2138         return QTime();
2139 
2140     const ParsedInt frac = readInt(tail);
2141     // There must be *some* digits in a fractional part; and it must be all digits:
2142     if (tail.isEmpty() ? dot != -1 || comma != -1 : !frac.ok)
2143         return QTime();
2144     Q_ASSERT(frac.ok ^ tail.isEmpty());
2145     double fraction = frac.ok ? frac.value * std::pow(0.1, tail.size()) : 0.0;
2146 
2147     const int size = string.size();
2148     if (size < 2 || size > 8)
2149         return QTime();
2150 
2151     ParsedInt hour = readInt(string.first(2));
2152     if (!hour.ok || hour.value > (format == Qt::TextDate ? 23 : 24))
2153         return QTime();
2154 
2155     ParsedInt minute;
2156     if (string.size() > 2) {
2157         if (string[2] == u':' && string.size() > 4)
2158             minute = readInt(string.sliced(3, 2));
2159         if (!minute.ok || minute.value >= 60)
2160             return QTime();
2161     } else if (format == Qt::TextDate) { // Requires minutes
2162         return QTime();
2163     } else if (frac.ok) {
2164         Q_ASSERT(!(fraction < 0.0) && fraction < 1.0);
2165         fraction *= 60;
2166         minute.value = qulonglong(fraction);
2167         fraction -= minute.value;
2168     }
2169 
2170     ParsedInt second;
2171     if (string.size() > 5) {
2172         if (string[5] == u':' && string.size() == 8)
2173             second = readInt(string.sliced(6, 2));
2174         if (!second.ok || second.value >= 60)
2175             return QTime();
2176     } else if (frac.ok) {
2177         if (format == Qt::TextDate) // Doesn't allow fraction of minutes
2178             return QTime();
2179         Q_ASSERT(!(fraction < 0.0) && fraction < 1.0);
2180         fraction *= 60;
2181         second.value = qulonglong(fraction);
2182         fraction -= second.value;
2183     }
2184 
2185     Q_ASSERT(!(fraction < 0.0) && fraction < 1.0);
2186     // Round millis to nearest (unlike minutes and seconds, rounded down):
2187     int msec = frac.ok ? qRound(MSECS_PER_SEC * fraction) : 0;
2188     // But handle overflow gracefully:
2189     if (msec == MSECS_PER_SEC) {
2190         // If we can (when data were otherwise valid) validly propagate overflow
2191         // into other fields, do so:
2192         if (isMidnight24 || hour.value < 23 || minute.value < 59 || second.value < 59) {
2193             msec = 0;
2194             if (++second.value == 60) {
2195                 second.value = 0;
2196                 if (++minute.value == 60) {
2197                     minute.value = 0;
2198                     ++hour.value;
2199                     // May need to propagate further via isMidnight24, see below
2200                 }
2201             }
2202         } else {
2203             // QTime::fromString() or Qt::TextDate: rounding up would cause
2204             // 23:59:59.999... to become invalid; clip to 999 ms instead:
2205             msec = MSECS_PER_SEC - 1;
2206         }
2207     }
2208 
2209     // For ISO date format, 24:0:0 means 0:0:0 on the next day:
2210     if (hour.value == 24 && minute.value == 0 && second.value == 0 && msec == 0) {
2211         Q_ASSERT(format != Qt::TextDate); // It clipped hour at 23, above.
2212         if (isMidnight24)
2213             *isMidnight24 = true;
2214         hour.value = 0;
2215     }
2216 
2217     return QTime(hour.value, minute.value, second.value, msec);
2218 }
2219 
2220 /*!
2221     \fn QTime QTime::fromString(const QString &string, Qt::DateFormat format)
2222 
2223     Returns the time represented in the \a string as a QTime using the
2224     \a format given, or an invalid time if this is not possible.
2225 
2226     \sa toString(), QLocale::toTime()
2227 */
2228 
2229 /*!
2230     \overload
2231     \since 6.0
2232 */
2233 QTime QTime::fromString(QStringView string, Qt::DateFormat format)
2234 {
2235     if (string.isEmpty())
2236         return QTime();
2237 
2238     switch (format) {
2239     case Qt::RFC2822Date:
2240         return rfcDateImpl(string).time;
2241     case Qt::ISODate:
2242     case Qt::ISODateWithMs:
2243     case Qt::TextDate:
2244     default:
2245         return fromIsoTimeString(string, format, nullptr);
2246     }
2247 }
2248 
2249 /*!
2250     \fn QTime QTime::fromString(const QString &string, const QString &format)
2251 
2252     Returns the QTime represented by the \a string, using the \a
2253     format given, or an invalid time if the string cannot be parsed.
2254 
2255     These expressions may be used for the format:
2256 
2257     \table
2258     \header \li Expression \li Output
2259     \row \li h
2260          \li The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
2261     \row \li hh
2262          \li The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
2263     \row \li H
2264          \li The hour without a leading zero (0 to 23, even with AM/PM display)
2265     \row \li HH
2266          \li The hour with a leading zero (00 to 23, even with AM/PM display)
2267     \row \li m \li The minute without a leading zero (0 to 59)
2268     \row \li mm \li The minute with a leading zero (00 to 59)
2269     \row \li s \li The whole second, without any leading zero (0 to 59)
2270     \row \li ss \li The whole second, with a leading zero where applicable (00 to 59)
2271     \row \li z \li The fractional part of the second, to go after a decimal
2272                 point, without trailing zeroes (0 to 999).  Thus "\c{s.z}"
2273                 reports the seconds to full available (millisecond) precision
2274                 without trailing zeroes.
2275     \row \li zzz \li The fractional part of the second, to millisecond
2276                 precision, including trailing zeroes where applicable (000 to 999).
2277     \row \li AP or A
2278          \li Interpret as an AM/PM time. \e A/AP will match 'AM' or 'PM'.
2279     \row \li ap or a
2280          \li Interpret as an am/pm time. \e a/ap will match 'am' or 'pm'.
2281     \endtable
2282 
2283     All other input characters will be treated as text. Any non-empty sequence
2284     of characters enclosed in single quotes will also be treated (stripped of
2285     the quotes) as text and not be interpreted as expressions.
2286 
2287     \snippet code/src_corelib_time_qdatetime.cpp 6
2288 
2289     If the format is not satisfied, an invalid QTime is returned.
2290     Expressions that do not expect leading zeroes to be given (h, m, s
2291     and z) are greedy. This means that they will use two digits (or three, for z) even if
2292     this puts them outside the range of accepted values and leaves too
2293     few digits for other sections. For example, the following string
2294     could have meant 00:07:10, but the m will grab two digits, resulting
2295     in an invalid time:
2296 
2297     \snippet code/src_corelib_time_qdatetime.cpp 7
2298 
2299     Any field that is not represented in the format will be set to zero.
2300     For example:
2301 
2302     \snippet code/src_corelib_time_qdatetime.cpp 8
2303 
2304     \note If localized forms of am or pm (the AP, ap, A or a formats) are used,
2305     please use QLocale::system().toTime().
2306 
2307     \sa toString(), QDateTime::fromString(), QDate::fromString(),
2308     QLocale::toTime()
2309 */
2310 
2311 /*!
2312     \fn QTime QTime::fromString(QStringView string, QStringView format)
2313     \overload
2314     \since 6.0
2315 */
2316 
2317 /*!
2318     \overload
2319     \since 6.0
2320 */
2321 QTime QTime::fromString(const QString &string, QStringView format)
2322 {
2323     QTime time;
2324 #if QT_CONFIG(datetimeparser)
2325     QDateTimeParser dt(QMetaType::QTime, QDateTimeParser::FromString, QCalendar());
2326     dt.setDefaultLocale(QLocale::c());
2327     if (dt.parseFormat(format))
2328         dt.fromString(string, nullptr, &time);
2329 #else
2330     Q_UNUSED(string);
2331     Q_UNUSED(format);
2332 #endif
2333     return time;
2334 }
2335 #endif // datestring
2336 
2337 
2338 /*!
2339     \overload
2340 
2341     Returns \c true if the specified time is valid; otherwise returns
2342     false.
2343 
2344     The time is valid if \a h is in the range 0 to 23, \a m and
2345     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.
2346 
2347     Example:
2348 
2349     \snippet code/src_corelib_time_qdatetime.cpp 9
2350 */
2351 
2352 bool QTime::isValid(int h, int m, int s, int ms)
2353 {
2354     return uint(h) < 24 && uint(m) < 60 && uint(s) < SECS_PER_MIN && uint(ms) < MSECS_PER_SEC;
2355 }
2356 
2357 /*****************************************************************************
2358   QDateTime static helper functions
2359  *****************************************************************************/
2360 
2361 // get the types from QDateTime (through QDateTimePrivate)
2362 typedef QDateTimePrivate::QDateTimeShortData ShortData;
2363 typedef QDateTimePrivate::QDateTimeData QDateTimeData;
2364 
2365 // Returns the platform variant of timezone, i.e. the standard time offset
2366 // The timezone external variable is documented as always holding the
2367 // Standard Time offset as seconds west of Greenwich, i.e. UTC+01:00 is -3600
2368 // Note this may not be historicaly accurate.
2369 // Relies on tzset, mktime, or localtime having been called to populate timezone
2370 static int qt_timezone()
2371 {
2372 #if defined(_MSC_VER)
2373         long offset;
2374         _get_timezone(&offset);
2375         return offset;
2376 #elif defined(Q_OS_BSD4) && !defined(Q_OS_DARWIN)
2377         time_t clock = time(NULL);
2378         struct tm t;
2379         localtime_r(&clock, &t);
2380         // QTBUG-36080 Workaround for systems without the POSIX timezone
2381         // variable. This solution is not very efficient but fixing it is up to
2382         // the libc implementations.
2383         //
2384         // tm_gmtoff has some important differences compared to the timezone
2385         // variable:
2386         // - It returns the number of seconds east of UTC, and we want the
2387         //   number of seconds west of UTC.
2388         // - It also takes DST into account, so we need to adjust it to always
2389         //   get the Standard Time offset.
2390         return -t.tm_gmtoff + (t.tm_isdst ? (long)SECS_PER_HOUR : 0L);
2391 #elif defined(Q_OS_INTEGRITY) || defined(Q_OS_RTEMS)
2392         return 0;
2393 #else
2394         return timezone;
2395 #endif // Q_OS_WIN
2396 }
2397 
2398 // Returns the tzname, assume tzset has been called already
2399 static QString qt_tzname(QDateTimePrivate::DaylightStatus daylightStatus)
2400 {
2401     int isDst = (daylightStatus == QDateTimePrivate::DaylightTime) ? 1 : 0;
2402 #if defined(Q_CC_MSVC)
2403     size_t s = 0;
2404     char name[512];
2405     if (_get_tzname(&s, name, 512, isDst))
2406         return QString();
2407     return QString::fromLocal8Bit(name);
2408 #else
2409     return QString::fromLocal8Bit(tzname[isDst]);
2410 #endif // Q_OS_WIN
2411 }
2412 
2413 #if QT_CONFIG(datetimeparser)
2414 /*
2415   \internal
2416   Implemented here to share qt_tzname()
2417 */
2418 int QDateTimeParser::startsWithLocalTimeZone(QStringView name)
2419 {
2420     QDateTimePrivate::DaylightStatus zones[2] = {
2421         QDateTimePrivate::StandardTime,
2422         QDateTimePrivate::DaylightTime
2423     };
2424     for (const auto z : zones) {
2425         QString zone(qt_tzname(z));
2426         if (name.startsWith(zone))
2427             return zone.size();
2428     }
2429     return 0;
2430 }
2431 #endif // datetimeparser
2432 
2433 // Calls the platform variant of mktime for the given date, time and
2434 // daylightStatus, and updates the date, time, daylightStatus and abbreviation
2435 // with the returned values. If the date falls outside the time_t range
2436 // supported by mktime, then date/time will not be updated and *ok is set false.
2437 static qint64 qt_mktime(QDate *date, QTime *time, QDateTimePrivate::DaylightStatus *daylightStatus,
2438                         QString *abbreviation, bool *ok)
2439 {
2440     Q_ASSERT(ok);
2441     qint64 msec = time->msec();
2442     int yy, mm, dd;
2443     date->getDate(&yy, &mm, &dd);
2444 
2445     // All other platforms provide standard C library time functions
2446     tm local;
2447     memset(&local, 0, sizeof(local)); // tm_[wy]day plus any non-standard fields
2448     local.tm_sec = time->second();
2449     local.tm_min = time->minute();
2450     local.tm_hour = time->hour();
2451     local.tm_mday = dd;
2452     local.tm_mon = mm - 1;
2453     local.tm_year = yy - 1900;
2454     local.tm_isdst = daylightStatus ? int(*daylightStatus) : -1;
2455 
2456 #if defined(Q_OS_WIN)
2457     int hh = local.tm_hour;
2458 #endif // Q_OS_WIN
2459     time_t secsSinceEpoch = qMkTime(&local);
2460     // That can fail if we thought we knew DST-ness, but were wrong:
2461     if (secsSinceEpoch == time_t(-1) && local.tm_isdst >= 0) {
2462         local.tm_isdst = -1;
2463         secsSinceEpoch = qMkTime(&local);
2464     }
2465 
2466     if (secsSinceEpoch != time_t(-1)) {
2467         *date = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2468         *time = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2469 #if defined(Q_OS_WIN)
2470         // Windows mktime for the missing hour subtracts 1 hour from the time
2471         // instead of adding 1 hour.  If time differs and is standard time then
2472         // this has happened, so add 2 hours to the time and 1 hour to the msecs
2473         if (local.tm_isdst == 0 && local.tm_hour != hh) {
2474             if (time->hour() >= 22)
2475                 *date = date->addDays(1);
2476             *time = time->addSecs(2 * SECS_PER_HOUR);
2477             secsSinceEpoch += SECS_PER_HOUR;
2478             local.tm_isdst = 1;
2479         }
2480 #endif // Q_OS_WIN
2481         if (local.tm_isdst > 0) {
2482             if (daylightStatus)
2483                 *daylightStatus = QDateTimePrivate::DaylightTime;
2484             if (abbreviation)
2485                 *abbreviation = qt_tzname(QDateTimePrivate::DaylightTime);
2486         } else {
2487             if (daylightStatus) {
2488                 *daylightStatus = (local.tm_isdst == 0
2489                                    ? QDateTimePrivate::StandardTime
2490                                    : QDateTimePrivate::UnknownDaylightTime);
2491             }
2492             if (abbreviation)
2493                 *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2494         }
2495     } else if (yy == 1969 && mm == 12 && dd == 31
2496                && QTime(0, 0).secsTo(*time) == SECS_PER_DAY - 1) {
2497         // There was, of course, a last second in 1969, at time_t(-1); we won't
2498         // rescue it if it's not in normalised form, and we don't know its DST
2499         // status (unless we did already), but let's not wantonly declare it
2500         // invalid.
2501     } else {
2502         *date = QDate();
2503         *time = QTime();
2504         if (daylightStatus)
2505             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2506         if (abbreviation)
2507             *abbreviation = QString();
2508         *ok = false;
2509         return 0;
2510     }
2511     if (secsSinceEpoch < 0 && msec > 0) {
2512         secsSinceEpoch++;
2513         msec -= MSECS_PER_SEC;
2514     }
2515     qint64 millis;
2516     const bool overflow =
2517         mul_overflow(qint64(secsSinceEpoch),
2518                      std::integral_constant<qint64, MSECS_PER_SEC>(), &millis)
2519         || add_overflow(millis, msec, &msec);
2520     *ok = !overflow;
2521 
2522     return msec;
2523 }
2524 
2525 // Calls the platform variant of localtime for the given msecs, and updates
2526 // the date, time, and DST status with the returned values.
2527 static bool qt_localtime(qint64 msecsSinceEpoch, QDate *localDate, QTime *localTime,
2528                          QDateTimePrivate::DaylightStatus *daylightStatus)
2529 {
2530     const time_t secsSinceEpoch = msecsSinceEpoch / MSECS_PER_SEC;
2531     const int msec = msecsSinceEpoch % MSECS_PER_SEC;
2532 
2533     tm local;
2534     bool valid = false;
2535 
2536     // localtime() is specified to work as if it called tzset().
2537     // localtime_r() does not have this constraint, so make an explicit call.
2538     // The explicit call should also request the timezone info be re-parsed.
2539     qTzSet();
2540 #if QT_CONFIG(thread) && defined(_POSIX_THREAD_SAFE_FUNCTIONS)
2541     // Use the reentrant version of localtime() where available
2542     // as is thread-safe and doesn't use a shared static data area
2543     if (tm *res = localtime_r(&secsSinceEpoch, &local)) {
2544         Q_ASSERT(res == &local);
2545         valid = true;
2546     }
2547 #elif defined(Q_CC_MSVC)
2548     if (!_localtime64_s(&local, &secsSinceEpoch))
2549         valid = true;
2550 #else
2551     // Returns shared static data which may be overwritten at any time
2552     // So copy the result asap
2553     if (tm *res = localtime(&secsSinceEpoch)) {
2554         local = *res;
2555         valid = true;
2556     }
2557 #endif
2558     if (valid) {
2559         *localDate = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2560         *localTime = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2561         if (daylightStatus) {
2562             if (local.tm_isdst > 0)
2563                 *daylightStatus = QDateTimePrivate::DaylightTime;
2564             else if (local.tm_isdst < 0)
2565                 *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2566             else
2567                 *daylightStatus = QDateTimePrivate::StandardTime;
2568         }
2569         return true;
2570     } else {
2571         *localDate = QDate();
2572         *localTime = QTime();
2573         if (daylightStatus)
2574             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2575         return false;
2576     }
2577 }
2578 
2579 // Converts an msecs value into a date and time
2580 static void msecsToTime(qint64 msecs, QDate *date, QTime *time)
2581 {
2582     qint64 jd = JULIAN_DAY_FOR_EPOCH;
2583     qint64 ds = 0;
2584 
2585     if (msecs >= MSECS_PER_DAY || msecs <= -MSECS_PER_DAY) {
2586         jd += msecs / MSECS_PER_DAY;
2587         msecs %= MSECS_PER_DAY;
2588     }
2589 
2590     if (msecs < 0) {
2591         ds = MSECS_PER_DAY - msecs - 1;
2592         jd -= ds / MSECS_PER_DAY;
2593         ds = ds % MSECS_PER_DAY;
2594         ds = MSECS_PER_DAY - ds - 1;
2595     } else {
2596         ds = msecs;
2597     }
2598 
2599     if (date)
2600         *date = QDate::fromJulianDay(jd);
2601     if (time)
2602         *time = QTime::fromMSecsSinceStartOfDay(ds);
2603 }
2604 
2605 // Converts a date/time value into msecs
2606 static qint64 timeToMSecs(QDate date, QTime time)
2607 {
2608     return ((date.toJulianDay() - JULIAN_DAY_FOR_EPOCH) * MSECS_PER_DAY)
2609            + time.msecsSinceStartOfDay();
2610 }
2611 
2612 /*!
2613     \internal
2614     Tests whether system functions can handle a given time.
2615 
2616     On MS-systems (where time_t is 64-bit by default), the system functions only
2617     work for dates up to the end of year 3000 (for mktime(); for _localtime64_s
2618     it's 18 days later, but we ignore that here).  On Unix the supported range
2619     is as many seconds after the epoch as time_t can represent.
2620 
2621     This second-range is then mapped to a millisecond range; if \a slack is
2622     passed, the range is extended by this many milliseconds at each end. The
2623     function returns true precisely if \a millis is within the resulting range.
2624 */
2625 static inline bool millisInSystemRange(qint64 millis, qint64 slack = 0)
2626 {
2627 #ifdef Q_OS_WIN
2628     const qint64 msecsMax = Q_INT64_C(32535215999999);
2629     return millis <= msecsMax + slack;
2630 #else
2631     if constexpr (std::numeric_limits<qint64>::max() / MSECS_PER_SEC > TIME_T_MAX) {
2632         const qint64 msecsMax = TIME_T_MAX * MSECS_PER_SEC;
2633         return millis <= msecsMax + slack;
2634     } else {
2635         return true;
2636     }
2637 #endif
2638 }
2639 
2640 // Convert an MSecs Since Epoch into Local Time
2641 static bool epochMSecsToLocalTime(qint64 msecs, QDate *localDate, QTime *localTime,
2642                                   QDateTimePrivate::DaylightStatus *daylightStatus = nullptr)
2643 {
2644     if (msecs < 0) {
2645         // Docs state any LocalTime before 1970-01-01 will *not* have any Daylight Time applied
2646         // Instead just use the standard offset from UTC to convert to UTC time
2647         qTzSet();
2648         msecsToTime(msecs - qt_timezone() * MSECS_PER_SEC, localDate, localTime);
2649         if (daylightStatus)
2650             *daylightStatus = QDateTimePrivate::StandardTime;
2651         return true;
2652     }
2653 
2654     if (!millisInSystemRange(msecs)) {
2655         // Docs state any LocalTime after 2038-01-18 *will* have any DST applied.
2656         // When this falls outside the supported range, we need to fake it.
2657         // Use existing method to fake the conversion, but this is deeply flawed as it may
2658         // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2659         // TODO Use QTimeZone when available to apply the future rule correctly
2660         QDate utcDate;
2661         QTime utcTime;
2662         msecsToTime(msecs, &utcDate, &utcTime);
2663         int year, month, day;
2664         utcDate.getDate(&year, &month, &day);
2665         // 2037 is not a leap year, so make sure date isn't Feb 29
2666         if (month == 2 && day == 29)
2667             --day;
2668         QDate fakeDate(2037, month, day);
2669         qint64 fakeMsecs = QDateTime(fakeDate, utcTime, Qt::UTC).toMSecsSinceEpoch();
2670         bool res = qt_localtime(fakeMsecs, localDate, localTime, daylightStatus);
2671         *localDate = localDate->addDays(fakeDate.daysTo(utcDate));
2672         return res;
2673     }
2674 
2675     // Falls inside time_t supported range so can use localtime
2676     return qt_localtime(msecs, localDate, localTime, daylightStatus);
2677 }
2678 
2679 // Convert a LocalTime expressed in local msecs encoding and the corresponding
2680 // DST status into a UTC epoch msecs. Optionally populate the returned
2681 // values from mktime for the adjusted local date and time.
2682 static qint64 localMSecsToEpochMSecs(qint64 localMsecs,
2683                                      QDateTimePrivate::DaylightStatus *daylightStatus,
2684                                      QDate *localDate = nullptr, QTime *localTime = nullptr,
2685                                      QString *abbreviation = nullptr)
2686 {
2687     QDate dt;
2688     QTime tm;
2689     msecsToTime(localMsecs, &dt, &tm);
2690 
2691     // First, if localMsecs is within +/- 1 day of viable range, try mktime() in
2692     // case it does fall in the range and gets proper DST conversion:
2693     if (localMsecs >= -MSECS_PER_DAY && millisInSystemRange(localMsecs, MSECS_PER_DAY)) {
2694         bool valid;
2695         const qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation, &valid);
2696         if (valid && utcMsecs >= 0 && millisInSystemRange(utcMsecs)) {
2697             // mktime worked and falls in valid range, so use it
2698             if (localDate)
2699                 *localDate = dt;
2700             if (localTime)
2701                 *localTime = tm;
2702             return utcMsecs;
2703         }
2704         // Restore dt and tm, after qt_mktime() stomped them:
2705         msecsToTime(localMsecs, &dt, &tm);
2706     } else {
2707         // If we don't call mktime then we need to call tzset to set up local zone data:
2708         qTzSet();
2709     }
2710 
2711     if (localMsecs <= MSECS_PER_DAY) {
2712         // Would have been caught above if after UTC epoch, so is before.
2713         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
2714         // Time is clearly before 1970-01-01 so just use standard offset to convert
2715         const qint64 utcMsecs = localMsecs + qt_timezone() * MSECS_PER_SEC;
2716         if (localDate || localTime)
2717             msecsToTime(localMsecs, localDate, localTime);
2718         if (daylightStatus)
2719             *daylightStatus = QDateTimePrivate::StandardTime;
2720         if (abbreviation)
2721             *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2722         return utcMsecs;
2723     }
2724 
2725     // Otherwise, after the end of the system range.
2726     // Use existing method to fake the conversion, but this is deeply flawed as it may
2727     // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2728     // TODO Use QTimeZone when available to apply the future rule correctly
2729     int year, month, day;
2730     dt.getDate(&year, &month, &day);
2731     // 2037 is not a leap year, so make sure date isn't Feb 29
2732     if (month == 2 && day == 29)
2733         --day;
2734     bool ok;
2735     QDate fakeDate(2037, month, day);
2736     const qint64 fakeDiff = fakeDate.daysTo(dt);
2737     const qint64 utcMsecs = qt_mktime(&fakeDate, &tm, daylightStatus, abbreviation, &ok);
2738     Q_ASSERT(ok);
2739     if (localDate)
2740         *localDate = fakeDate.addDays(fakeDiff);
2741     if (localTime)
2742         *localTime = tm;
2743     QDate utcDate;
2744     QTime utcTime;
2745     msecsToTime(utcMsecs, &utcDate, &utcTime);
2746     return timeToMSecs(utcDate.addDays(fakeDiff), utcTime);
2747 }
2748 
2749 static inline bool specCanBeSmall(Qt::TimeSpec spec)
2750 {
2751     return spec == Qt::LocalTime || spec == Qt::UTC;
2752 }
2753 
2754 static inline bool msecsCanBeSmall(qint64 msecs)
2755 {
2756     if (!QDateTimeData::CanBeSmall)
2757         return false;
2758 
2759     ShortData sd;
2760     sd.msecs = qintptr(msecs);
2761     return sd.msecs == msecs;
2762 }
2763 
2764 static constexpr inline
2765 QDateTimePrivate::StatusFlags mergeSpec(QDateTimePrivate::StatusFlags status, Qt::TimeSpec spec)
2766 {
2767     return QDateTimePrivate::StatusFlags((status & ~QDateTimePrivate::TimeSpecMask) |
2768                                          (int(spec) << QDateTimePrivate::TimeSpecShift));
2769 }
2770 
2771 static constexpr inline Qt::TimeSpec extractSpec(QDateTimePrivate::StatusFlags status)
2772 {
2773     return Qt::TimeSpec((status & QDateTimePrivate::TimeSpecMask) >> QDateTimePrivate::TimeSpecShift);
2774 }
2775 
2776 // Set the Daylight Status if LocalTime set via msecs
2777 static constexpr inline QDateTimePrivate::StatusFlags
2778 mergeDaylightStatus(QDateTimePrivate::StatusFlags sf, QDateTimePrivate::DaylightStatus status)
2779 {
2780     sf &= ~QDateTimePrivate::DaylightMask;
2781     if (status == QDateTimePrivate::DaylightTime) {
2782         sf |= QDateTimePrivate::SetToDaylightTime;
2783     } else if (status == QDateTimePrivate::StandardTime) {
2784         sf |= QDateTimePrivate::SetToStandardTime;
2785     }
2786     return sf;
2787 }
2788 
2789 // Get the DST Status if LocalTime set via msecs
2790 static constexpr inline
2791 QDateTimePrivate::DaylightStatus extractDaylightStatus(QDateTimePrivate::StatusFlags status)
2792 {
2793     if (status & QDateTimePrivate::SetToDaylightTime)
2794         return QDateTimePrivate::DaylightTime;
2795     if (status & QDateTimePrivate::SetToStandardTime)
2796         return QDateTimePrivate::StandardTime;
2797     return QDateTimePrivate::UnknownDaylightTime;
2798 }
2799 
2800 static inline qint64 getMSecs(const QDateTimeData &d)
2801 {
2802     if (d.isShort()) {
2803         // same as, but producing better code
2804         //return d.data.msecs;
2805         return qintptr(d.d) >> 8;
2806     }
2807     return d->m_msecs;
2808 }
2809 
2810 static inline QDateTimePrivate::StatusFlags getStatus(const QDateTimeData &d)
2811 {
2812     if (d.isShort()) {
2813         // same as, but producing better code
2814         //return StatusFlag(d.data.status);
2815         return QDateTimePrivate::StatusFlag(qintptr(d.d) & 0xFF);
2816     }
2817     return d->m_status;
2818 }
2819 
2820 static inline Qt::TimeSpec getSpec(const QDateTimeData &d)
2821 {
2822     return extractSpec(getStatus(d));
2823 }
2824 
2825 /* True if we *can cheaply determine* that a and b use the same offset.
2826    If they use different offsets or it would be expensive to find out, false.
2827    Calls to toMSecsSinceEpoch() are expensive, for these purposes.
2828    See QDateTime's comparison operators.
2829 */
2830 static inline bool usesSameOffset(const QDateTimeData &a, const QDateTimeData &b)
2831 {
2832     const auto status = getStatus(a);
2833     if (status != getStatus(b))
2834         return false;
2835     // Status includes DST-ness, so we now know they match in it.
2836 
2837     switch (extractSpec(status)) {
2838     case Qt::LocalTime:
2839     case Qt::UTC:
2840         return true;
2841 
2842     case Qt::TimeZone:
2843         /* TimeZone always determines its offset during construction of the
2844            private data. Even if we're in different zones, what matters is the
2845            offset actually in effect at the specific time. (DST can cause things
2846            with the same time-zone to use different offsets, but we already
2847            checked their DSTs match.) */
2848     case Qt::OffsetFromUTC: // always knows its offset, which is all that matters.
2849         Q_ASSERT(!a.isShort() && !b.isShort());
2850         return a->m_offsetFromUtc == b->m_offsetFromUtc;
2851     }
2852     Q_UNREACHABLE();
2853     return false;
2854 }
2855 
2856 // Refresh the LocalTime or TimeZone validity and offset
2857 static void refreshZonedDateTime(QDateTimeData &d, Qt::TimeSpec spec)
2858 {
2859     Q_ASSERT(spec == Qt::TimeZone || spec == Qt::LocalTime);
2860     auto status = getStatus(d);
2861     Q_ASSERT(extractSpec(status) == spec);
2862     int offsetFromUtc = 0;
2863 
2864     // If not valid date and time then is invalid
2865     if (!(status & QDateTimePrivate::ValidDate) || !(status & QDateTimePrivate::ValidTime)) {
2866         status &= ~QDateTimePrivate::ValidDateTime;
2867     } else {
2868         // We have a valid date and time and a Qt::LocalTime or Qt::TimeZone that needs calculating
2869         // LocalTime and TimeZone might fall into a "missing" DST transition hour
2870         // Calling toEpochMSecs will adjust the returned date/time if it does
2871         const qint64 msecs = getMSecs(d);
2872         qint64 epochMSecs = 0;
2873         QDate testDate;
2874         QTime testTime;
2875         auto dstStatus = extractDaylightStatus(status);
2876         if (spec == Qt::LocalTime) {
2877             epochMSecs = localMSecsToEpochMSecs(msecs, &dstStatus, &testDate, &testTime);
2878 #if QT_CONFIG(timezone)
2879         // else spec == Qt::TimeZone, so check zone is valid:
2880         } else if (d->m_timeZone.isValid()) {
2881             epochMSecs = QDateTimePrivate::zoneMSecsToEpochMSecs(
2882                 msecs, d->m_timeZone, dstStatus, &testDate, &testTime);
2883 #endif // timezone
2884         } // else: testDate, testTime haven't been set, so are invalid.
2885         const bool ok = testDate.isValid() && testTime.isValid();
2886         // Cache the offset to use in offsetFromUtc() &c., even if the next
2887         // check marks invalid; this lets fromMSecsSinceEpoch() give a useful
2888         // fallback for times in spring-forward gaps.
2889         if (ok)
2890             offsetFromUtc = (msecs - epochMSecs) / MSECS_PER_SEC;
2891         Q_ASSERT(offsetFromUtc >= -SECS_PER_DAY && offsetFromUtc <= SECS_PER_DAY);
2892         if (ok && timeToMSecs(testDate, testTime) == msecs) {
2893             status = mergeDaylightStatus(status, dstStatus);
2894             status |= QDateTimePrivate::ValidDateTime;
2895         } else {
2896             status &= ~QDateTimePrivate::ValidDateTime;
2897         }
2898     }
2899 
2900     if (status & QDateTimePrivate::ShortData) {
2901         d.data.status = status;
2902     } else {
2903         d->m_status = status;
2904         d->m_offsetFromUtc = offsetFromUtc;
2905     }
2906 }
2907 
2908 // Check the UTC / offsetFromUTC validity
2909 static void refreshSimpleDateTime(QDateTimeData &d)
2910 {
2911     auto status = getStatus(d);
2912     Q_ASSERT(extractSpec(status) == Qt::UTC || extractSpec(status) == Qt::OffsetFromUTC);
2913     if ((status & QDateTimePrivate::ValidDate) && (status & QDateTimePrivate::ValidTime))
2914         status |= QDateTimePrivate::ValidDateTime;
2915     else
2916         status &= ~QDateTimePrivate::ValidDateTime;
2917 
2918     if (status & QDateTimePrivate::ShortData)
2919         d.data.status = status;
2920     else
2921         d->m_status = status;
2922 }
2923 
2924 // Clean up and set status after assorted set-up or reworking:
2925 static void checkValidDateTime(QDateTimeData &d)
2926 {
2927     auto status = getStatus(d);
2928     auto spec = extractSpec(status);
2929     switch (spec) {
2930     case Qt::OffsetFromUTC:
2931     case Qt::UTC:
2932         // for these, a valid date and a valid time imply a valid QDateTime
2933         refreshSimpleDateTime(d);
2934         break;
2935     case Qt::TimeZone:
2936     case Qt::LocalTime:
2937         // for these, we need to check whether the timezone is valid and whether
2938         // the time is valid in that timezone. Expensive, but no other option.
2939         refreshZonedDateTime(d, spec);
2940         break;
2941     }
2942 }
2943 
2944 // Caller needs to refresh after calling this
2945 static void setTimeSpec(QDateTimeData &d, Qt::TimeSpec spec, int offsetSeconds)
2946 {
2947     auto status = getStatus(d);
2948     status &= ~(uint(QDateTimePrivate::ValidDateTime) | uint(QDateTimePrivate::DaylightMask) |
2949                 uint(QDateTimePrivate::TimeSpecMask));
2950 
2951     switch (spec) {
2952     case Qt::OffsetFromUTC:
2953         if (offsetSeconds == 0)
2954             spec = Qt::UTC;
2955         break;
2956     case Qt::TimeZone:
2957         qWarning("Using TimeZone in setTimeSpec() is unsupported"); // Use system time zone instead
2958         spec = Qt::LocalTime;
2959         Q_FALLTHROUGH();
2960     case Qt::UTC:
2961     case Qt::LocalTime:
2962         offsetSeconds = 0;
2963         break;
2964     }
2965 
2966     status = mergeSpec(status, spec);
2967     if (d.isShort() && offsetSeconds == 0) {
2968         d.data.status = status;
2969     } else {
2970         d.detach();
2971         d->m_status = status & ~QDateTimePrivate::ShortData;
2972         d->m_offsetFromUtc = offsetSeconds;
2973 #if QT_CONFIG(timezone)
2974         d->m_timeZone = QTimeZone();
2975 #endif // timezone
2976     }
2977 }
2978 
2979 static void setDateTime(QDateTimeData &d, QDate date, QTime time)
2980 {
2981     // If the date is valid and the time is not we set time to 00:00:00
2982     QTime useTime = time;
2983     if (!useTime.isValid() && date.isValid())
2984         useTime = QTime::fromMSecsSinceStartOfDay(0);
2985 
2986     QDateTimePrivate::StatusFlags newStatus = { };
2987 
2988     // Set date value and status
2989     qint64 days = 0;
2990     if (date.isValid()) {
2991         days = date.toJulianDay() - JULIAN_DAY_FOR_EPOCH;
2992         newStatus = QDateTimePrivate::ValidDate;
2993     }
2994 
2995     // Set time value and status
2996     int ds = 0;
2997     if (useTime.isValid()) {
2998         ds = useTime.msecsSinceStartOfDay();
2999         newStatus |= QDateTimePrivate::ValidTime;
3000     }
3001     Q_ASSERT(ds < MSECS_PER_DAY);
3002     // Only the later parts of the very first day are representable - its start
3003     // would overflow - so get ds the same side of 0 as days:
3004     if (days < 0 && ds > 0) {
3005         days++;
3006         ds -= MSECS_PER_DAY;
3007     }
3008 
3009     // Check in representable range:
3010     qint64 msecs = 0;
3011     if (mul_overflow(days, std::integral_constant<qint64, MSECS_PER_DAY>(), &msecs)
3012         || add_overflow(msecs, qint64(ds), &msecs)) {
3013         newStatus = QDateTimePrivate::StatusFlags{};
3014     } else if (d.isShort()) {
3015         // let's see if we can keep this short
3016         if (msecsCanBeSmall(msecs)) {
3017             // yes, we can
3018             d.data.msecs = qintptr(msecs);
3019             d.data.status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
3020             d.data.status |= newStatus;
3021         } else {
3022             // nope...
3023             d.detach();
3024         }
3025     }
3026     if (!d.isShort()) {
3027         d.detach();
3028         d->m_msecs = msecs;
3029         d->m_status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
3030         d->m_status |= newStatus;
3031     }
3032 }
3033 
3034 static QPair<QDate, QTime> getDateTime(const QDateTimeData &d)
3035 {
3036     QPair<QDate, QTime> result;
3037     qint64 msecs = getMSecs(d);
3038     auto status = getStatus(d);
3039     msecsToTime(msecs, &result.first, &result.second);
3040 
3041     if (!status.testFlag(QDateTimePrivate::ValidDate))
3042         result.first = QDate();
3043 
3044     if (!status.testFlag(QDateTimePrivate::ValidTime))
3045         result.second = QTime();
3046 
3047     return result;
3048 }
3049 
3050 /*****************************************************************************
3051   QDateTime::Data member functions
3052  *****************************************************************************/
3053 
3054 inline QDateTime::Data::Data() noexcept
3055 {
3056     // default-constructed data has a special exception:
3057     // it can be small even if CanBeSmall == false
3058     // (optimization so we don't allocate memory in the default constructor)
3059     quintptr value = quintptr(mergeSpec(QDateTimePrivate::ShortData, Qt::LocalTime));
3060     d = reinterpret_cast<QDateTimePrivate *>(value);
3061 }
3062 
3063 inline QDateTime::Data::Data(Qt::TimeSpec spec)
3064 {
3065     if (CanBeSmall && Q_LIKELY(specCanBeSmall(spec))) {
3066         d = reinterpret_cast<QDateTimePrivate *>(quintptr(mergeSpec(QDateTimePrivate::ShortData, spec)));
3067     } else {
3068         // the structure is too small, we need to detach
3069         d = new QDateTimePrivate;
3070         d->ref.ref();
3071         d->m_status = mergeSpec({}, spec);
3072     }
3073 }
3074 
3075 inline QDateTime::Data::Data(const Data &other)
3076     : d(other.d)
3077 {
3078     if (!isShort()) {
3079         // check if we could shrink
3080         if (specCanBeSmall(extractSpec(d->m_status)) && msecsCanBeSmall(d->m_msecs)) {
3081             ShortData sd;
3082             sd.msecs = qintptr(d->m_msecs);
3083             sd.status = d->m_status | QDateTimePrivate::ShortData;
3084             data = sd;
3085         } else {
3086             // no, have to keep it big
3087             d->ref.ref();
3088         }
3089     }
3090 }
3091 
3092 inline QDateTime::Data::Data(Data &&other)
3093     : d(other.d)
3094 {
3095     // reset the other to a short state
3096     Data dummy;
3097     Q_ASSERT(dummy.isShort());
3098     other.d = dummy.d;
3099 }
3100 
3101 inline QDateTime::Data &QDateTime::Data::operator=(const Data &other)
3102 {
3103     if (d == other.d)
3104         return *this;
3105 
3106     auto x = d;
3107     d = other.d;
3108     if (!other.isShort()) {
3109         // check if we could shrink
3110         if (specCanBeSmall(extractSpec(other.d->m_status)) && msecsCanBeSmall(other.d->m_msecs)) {
3111             ShortData sd;
3112             sd.msecs = qintptr(other.d->m_msecs);
3113             sd.status = other.d->m_status | QDateTimePrivate::ShortData;
3114             data = sd;
3115         } else {
3116             // no, have to keep it big
3117             other.d->ref.ref();
3118         }
3119     }
3120 
3121     if (!(quintptr(x) & QDateTimePrivate::ShortData) && !x->ref.deref())
3122         delete x;
3123     return *this;
3124 }
3125 
3126 inline QDateTime::Data::~Data()
3127 {
3128     if (!isShort() && !d->ref.deref())
3129         delete d;
3130 }
3131 
3132 inline bool QDateTime::Data::isShort() const
3133 {
3134     bool b = quintptr(d) & QDateTimePrivate::ShortData;
3135 
3136     // sanity check:
3137     Q_ASSERT(b || (d->m_status & QDateTimePrivate::ShortData) == 0);
3138 
3139     // even if CanBeSmall = false, we have short data for a default-constructed
3140     // QDateTime object. But it's unlikely.
3141     if (CanBeSmall)
3142         return Q_LIKELY(b);
3143     return Q_UNLIKELY(b);
3144 }
3145 
3146 inline void QDateTime::Data::detach()
3147 {
3148     QDateTimePrivate *x;
3149     bool wasShort = isShort();
3150     if (wasShort) {
3151         // force enlarging
3152         x = new QDateTimePrivate;
3153         x->m_status = QDateTimePrivate::StatusFlag(data.status & ~QDateTimePrivate::ShortData);
3154         x->m_msecs = data.msecs;
3155     } else {
3156         if (d->ref.loadRelaxed() == 1)
3157             return;
3158 
3159         x = new QDateTimePrivate(*d);
3160     }
3161 
3162     x->ref.storeRelaxed(1);
3163     if (!wasShort && !d->ref.deref())
3164         delete d;
3165     d = x;
3166 }
3167 
3168 inline const QDateTimePrivate *QDateTime::Data::operator->() const
3169 {
3170     Q_ASSERT(!isShort());
3171     return d;
3172 }
3173 
3174 inline QDateTimePrivate *QDateTime::Data::operator->()
3175 {
3176     // should we attempt to detach here?
3177     Q_ASSERT(!isShort());
3178     Q_ASSERT(d->ref.loadRelaxed() == 1);
3179     return d;
3180 }
3181 
3182 /*****************************************************************************
3183   QDateTimePrivate member functions
3184  *****************************************************************************/
3185 
3186 Q_NEVER_INLINE
3187 QDateTime::Data QDateTimePrivate::create(QDate toDate, QTime toTime, Qt::TimeSpec toSpec,
3188                                          int offsetSeconds)
3189 {
3190     QDateTime::Data result(toSpec);
3191     setTimeSpec(result, toSpec, offsetSeconds);
3192     setDateTime(result, toDate, toTime);
3193     if (toSpec == Qt::OffsetFromUTC || toSpec == Qt::UTC)
3194         refreshSimpleDateTime(result);
3195     else
3196         refreshZonedDateTime(result, Qt::LocalTime);
3197     return result;
3198 }
3199 
3200 #if QT_CONFIG(timezone)
3201 inline QDateTime::Data QDateTimePrivate::create(QDate toDate, QTime toTime,
3202                                                 const QTimeZone &toTimeZone)
3203 {
3204     QDateTime::Data result(Qt::TimeZone);
3205     Q_ASSERT(!result.isShort());
3206 
3207     result.d->m_status = mergeSpec(result.d->m_status, Qt::TimeZone);
3208     result.d->m_timeZone = toTimeZone;
3209     setDateTime(result, toDate, toTime);
3210     refreshZonedDateTime(result, Qt::TimeZone);
3211     return result;
3212 }
3213 
3214 // Convert a TimeZone time expressed in zone msecs encoding into a UTC epoch msecs
3215 // DST transitions are disambiguated by hint.
3216 inline qint64 QDateTimePrivate::zoneMSecsToEpochMSecs(qint64 zoneMSecs, const QTimeZone &zone,
3217                                                       DaylightStatus hint,
3218                                                       QDate *zoneDate, QTime *zoneTime)
3219 {
3220     Q_ASSERT(zone.isValid());
3221     // Get the effective data from QTimeZone
3222     QTimeZonePrivate::Data data = zone.d->dataForLocalTime(zoneMSecs, int(hint));
3223     Q_ASSERT(zone.d->offsetFromUtc(data.atMSecsSinceEpoch) == data.offsetFromUtc);
3224     Q_ASSERT(([data](qint64 offset) {
3225                 return offset == data.offsetFromUtc
3226                     // When zoneMSecs falls in a spring-forward's gap:
3227                     || offset == data.standardTimeOffset
3228                     // When it falls in the gap leading into double-DST:
3229                     || offset == 2 * data.standardTimeOffset
3230                     // When it falls in a skipped day (Pacific date-line crossings):
3231                     || (data.offsetFromUtc - offset) % SECS_PER_DAY == 0;
3232                     })((zoneMSecs - data.atMSecsSinceEpoch) / MSECS_PER_SEC));
3233     // Docs state any time before 1970-01-01 will *not* have any DST applied
3234     // but all affected times afterwards will have DST applied.
3235     if (data.atMSecsSinceEpoch < 0) {
3236         msecsToTime(zoneMSecs, zoneDate, zoneTime);
3237         return zoneMSecs - data.standardTimeOffset * MSECS_PER_SEC;
3238     } else {
3239         msecsToTime(data.atMSecsSinceEpoch + data.offsetFromUtc * MSECS_PER_SEC,
3240                     zoneDate, zoneTime);
3241         return data.atMSecsSinceEpoch;
3242     }
3243 }
3244 #endif // timezone
3245 
3246 /*****************************************************************************
3247   QDateTime member functions
3248  *****************************************************************************/
3249 
3250 /*!
3251     \class QDateTime
3252     \inmodule QtCore
3253     \ingroup shared
3254     \reentrant
3255     \brief The QDateTime class provides date and time functions.
3256 
3257 
3258     A QDateTime object encodes a calendar date and a clock time (a
3259     "datetime"). It combines features of the QDate and QTime classes.
3260     It can read the current datetime from the system clock. It
3261     provides functions for comparing datetimes and for manipulating a
3262     datetime by adding a number of seconds, days, months, or years.
3263 
3264     QDateTime can describe datetimes with respect to \l{Qt::LocalTime}{local
3265     time}, to \l{Qt::UTC}{UTC}, to a specified \l{Qt::OffsetFromUTC}{offset from
3266     UTC} or to a specified \l{Qt::TimeZone}{time zone}, in conjunction with the
3267     QTimeZone class. For example, a time zone of "Europe/Berlin" will apply the
3268     daylight-saving rules as used in Germany since 1970. In contrast, an offset
3269     from UTC of +3600 seconds is one hour ahead of UTC (usually written in ISO
3270     standard notation as "UTC+01:00"), with no daylight-saving offset or
3271     changes. When using either local time or a specified time zone, time-zone
3272     transitions such as the starts and ends of daylight-saving time (DST; but
3273     see below) are taken into account. The choice of system used to represent a
3274     datetime is described as its "timespec".
3275 
3276     A QDateTime object is typically created either by giving a date and time
3277     explicitly in the constructor, or by using a static function such as
3278     currentDateTime() or fromMSecsSinceEpoch(). The date and time can be changed
3279     with setDate() and setTime(). A datetime can also be set using the
3280     setMSecsSinceEpoch() function that takes the time, in milliseconds, since
3281     00:00:00 on January 1, 1970. The fromString() function returns a QDateTime,
3282     given a string and a date format used to interpret the date within the
3283     string.
3284 
3285     QDateTime::currentDateTime() returns a QDateTime that expresses the current
3286     time with respect to local time. QDateTime::currentDateTimeUtc() returns a
3287     QDateTime that expresses the current time with respect to UTC.
3288 
3289     The date() and time() functions provide access to the date and
3290     time parts of the datetime. The same information is provided in
3291     textual format by the toString() function.
3292 
3293     QDateTime provides a full set of operators to compare two
3294     QDateTime objects, where smaller means earlier and larger means
3295     later.
3296 
3297     You can increment (or decrement) a datetime by a given number of
3298     milliseconds using addMSecs(), seconds using addSecs(), or days using
3299     addDays(). Similarly, you can use addMonths() and addYears(). The daysTo()
3300     function returns the number of days between two datetimes, secsTo() returns
3301     the number of seconds between two datetimes, and msecsTo() returns the
3302     number of milliseconds between two datetimes. These operations are aware of
3303     daylight-saving time (DST) and other time-zone transitions, where
3304     applicable.
3305 
3306     Use toTimeSpec() to express a datetime in local time or UTC,
3307     toOffsetFromUtc() to express in terms of an offset from UTC, or toTimeZone()
3308     to express it with respect to a general time zone. You can use timeSpec() to
3309     find out what time-spec a QDateTime object stores its time relative to. When
3310     that is Qt::TimeZone, you can use timeZone() to find out which zone it is
3311     using.
3312 
3313     \note QDateTime does not account for leap seconds.
3314 
3315     \section1 Remarks
3316 
3317     \note All conversion to and from string formats is done using the C locale.
3318     For localized conversions, see QLocale.
3319 
3320     \note There is no year 0 in the Gregorian calendar. Dates in that year are
3321     considered invalid. The year -1 is the year "1 before Christ" or "1 before
3322     common era." The day before 1 January 1 CE is 31 December 1 BCE.
3323 
3324     \section2 Range of Valid Dates
3325 
3326     The range of values that QDateTime can represent is dependent on the
3327     internal storage implementation. QDateTime is currently stored in a qint64
3328     as a serial msecs value encoding the date and time. This restricts the date
3329     range to about +/- 292 million years, compared to the QDate range of +/- 2
3330     billion years. Care must be taken when creating a QDateTime with extreme
3331     values that you do not overflow the storage. The exact range of supported
3332     values varies depending on the Qt::TimeSpec and time zone.
3333 
3334     \section2 Use of Timezones
3335 
3336     QDateTime uses the system's time zone information to determine the current
3337     local time zone and its offset from UTC. If the system is not configured
3338     correctly or not up-to-date, QDateTime will give wrong results.
3339 
3340     QDateTime likewise uses system-provided information to determine the offsets
3341     of other timezones from UTC. If this information is incomplete or out of
3342     date, QDateTime will give wrong results. See the QTimeZone documentation for
3343     more details.
3344 
3345     On modern Unix systems, this means QDateTime usually has accurate
3346     information about historical transitions (including DST, see below) whenever
3347     possible. On Windows, where the system doesn't support historical timezone
3348     data, historical accuracy is not maintained with respect to timezone
3349     transitions, notably including DST.
3350 
3351     \section2 Daylight-Saving Time (DST)
3352 
3353     QDateTime takes into account transitions between Standard Time and
3354     Daylight-Saving Time. For example, if the transition is at 2am and the clock
3355     goes forward to 3am, then there is a "missing" hour from 02:00:00 to
3356     02:59:59.999 which QDateTime considers to be invalid. Any date arithmetic
3357     performed will take this missing hour into account and return a valid
3358     result. For example, adding one minute to 01:59:59 will get 03:00:00.
3359 
3360     The range of valid dates taking DST into account is 1970-01-01 to the
3361     present, and rules are in place for handling DST correctly until 2038-01-18
3362     (or the end of the \c time_t range, if this is later). For dates after the
3363     end of this range, QDateTime makes a \e{best guess} using the rules for year
3364     2037, but we can't guarantee accuracy; indeed, for \e{any} future date, the
3365     time-zone may change its rules before that date comes around. For dates
3366     before 1970, QDateTime uses the current abbreviation and offset of local
3367     time's standad time.
3368 
3369     \section2 Offsets From UTC
3370 
3371     There is no explicit size restriction on an offset from UTC, but there is an
3372     implicit limit imposed when using the toString() and fromString() methods
3373     which use a [+|-]hh:mm format, effectively limiting the range to +/- 99
3374     hours and 59 minutes and whole minutes only. Note that currently no time
3375     zone lies outside the range of +/- 14 hours.
3376 
3377     \sa QDate, QTime, QDateTimeEdit, QTimeZone
3378 */
3379 
3380 /*!
3381     \since 5.14
3382     \enum QDateTime::YearRange
3383 
3384     This enumerated type describes the range of years (in the Gregorian
3385     calendar) representable by QDateTime:
3386 
3387     \value First The later parts of this year are representable
3388     \value Last The earlier parts of this year are representable
3389 
3390     All dates strictly between these two years are also representable.
3391     Note, however, that the Gregorian Calendar has no year zero.
3392 
3393     \note QDate can describe dates in a wider range of years.  For most
3394     purposes, this makes little difference, as the range of years that QDateTime
3395     can support reaches 292 million years either side of 1970.
3396 
3397     \sa isValid(), QDate
3398 */
3399 
3400 /*!
3401     Constructs a null datetime.
3402 
3403     A null datetime is invalid, since its date and time are invalid.
3404 
3405     \sa isValid()
3406 */
3407 QDateTime::QDateTime() noexcept
3408 {
3409 }
3410 
3411 /*!
3412     Constructs a datetime with the given \a date and \a time, using
3413     the time specification defined by \a spec and \a offsetSeconds seconds.
3414 
3415     If \a date is valid and \a time is not, the time will be set to midnight.
3416 
3417     If the \a spec is not Qt::OffsetFromUTC then \a offsetSeconds will be ignored.
3418 
3419     If the \a spec is Qt::OffsetFromUTC and \a offsetSeconds is 0 then the
3420     timeSpec() will be set to Qt::UTC, i.e. an offset of 0 seconds.
3421 
3422     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3423     i.e. the current system time zone.  To create a Qt::TimeZone datetime
3424     use the correct constructor.
3425 */
3426 
3427 QDateTime::QDateTime(QDate date, QTime time, Qt::TimeSpec spec, int offsetSeconds)
3428          : d(QDateTimePrivate::create(date, time, spec, offsetSeconds))
3429 {
3430 }
3431 
3432 #if QT_CONFIG(timezone)
3433 /*!
3434     \since 5.2
3435 
3436     Constructs a datetime with the given \a date and \a time, using
3437     the Time Zone specified by \a timeZone.
3438 
3439     If \a date is valid and \a time is not, the time will be set to 00:00:00.
3440 
3441     If \a timeZone is invalid then the datetime will be invalid.
3442 */
3443 
3444 QDateTime::QDateTime(QDate date, QTime time, const QTimeZone &timeZone)
3445     : d(QDateTimePrivate::create(date, time, timeZone))
3446 {
3447 }
3448 #endif // timezone
3449 
3450 /*!
3451     Constructs a copy of the \a other datetime.
3452 */
3453 QDateTime::QDateTime(const QDateTime &other) noexcept
3454     : d(other.d)
3455 {
3456 }
3457 
3458 /*!
3459     \since 5.8
3460     Moves the content of the temporary \a other datetime to this object and
3461     leaves \a other in an unspecified (but proper) state.
3462 */
3463 QDateTime::QDateTime(QDateTime &&other) noexcept
3464     : d(std::move(other.d))
3465 {
3466 }
3467 
3468 /*!
3469     Destroys the datetime.
3470 */
3471 QDateTime::~QDateTime()
3472 {
3473 }
3474 
3475 /*!
3476     Makes a copy of the \a other datetime and returns a reference to the
3477     copy.
3478 */
3479 
3480 QDateTime &QDateTime::operator=(const QDateTime &other) noexcept
3481 {
3482     d = other.d;
3483     return *this;
3484 }
3485 /*!
3486     \fn void QDateTime::swap(QDateTime &other)
3487     \since 5.0
3488 
3489     Swaps this datetime with \a other. This operation is very fast
3490     and never fails.
3491 */
3492 
3493 /*!
3494     Returns \c true if both the date and the time are null; otherwise
3495     returns \c false. A null datetime is invalid.
3496 
3497     \sa QDate::isNull(), QTime::isNull(), isValid()
3498 */
3499 
3500 bool QDateTime::isNull() const
3501 {
3502     auto status = getStatus(d);
3503     return !status.testFlag(QDateTimePrivate::ValidDate) &&
3504             !status.testFlag(QDateTimePrivate::ValidTime);
3505 }
3506 
3507 /*!
3508     Returns \c true if both the date and the time are valid and they are valid in
3509     the current Qt::TimeSpec, otherwise returns \c false.
3510 
3511     If the timeSpec() is Qt::LocalTime or Qt::TimeZone then the date and time are
3512     checked to see if they fall in the Standard Time to Daylight-Saving Time transition
3513     hour, i.e. if the transition is at 2am and the clock goes forward to 3am
3514     then the time from 02:00:00 to 02:59:59.999 is considered to be invalid.
3515 
3516     \sa QDateTime::YearRange, QDate::isValid(), QTime::isValid()
3517 */
3518 
3519 bool QDateTime::isValid() const
3520 {
3521     auto status = getStatus(d);
3522     return status & QDateTimePrivate::ValidDateTime;
3523 }
3524 
3525 /*!
3526     Returns the date part of the datetime.
3527 
3528     \sa setDate(), time(), timeSpec()
3529 */
3530 
3531 QDate QDateTime::date() const
3532 {
3533     auto status = getStatus(d);
3534     if (!status.testFlag(QDateTimePrivate::ValidDate))
3535         return QDate();
3536     QDate dt;
3537     msecsToTime(getMSecs(d), &dt, nullptr);
3538     return dt;
3539 }
3540 
3541 /*!
3542     Returns the time part of the datetime.
3543 
3544     \sa setTime(), date(), timeSpec()
3545 */
3546 
3547 QTime QDateTime::time() const
3548 {
3549     auto status = getStatus(d);
3550     if (!status.testFlag(QDateTimePrivate::ValidTime))
3551         return QTime();
3552     QTime tm;
3553     msecsToTime(getMSecs(d), nullptr, &tm);
3554     return tm;
3555 }
3556 
3557 /*!
3558     Returns the time specification of the datetime.
3559 
3560     \sa setTimeSpec(), date(), time(), Qt::TimeSpec
3561 */
3562 
3563 Qt::TimeSpec QDateTime::timeSpec() const
3564 {
3565     return getSpec(d);
3566 }
3567 
3568 #if QT_CONFIG(timezone)
3569 /*!
3570     \since 5.2
3571 
3572     Returns the time zone of the datetime.
3573 
3574     If the timeSpec() is Qt::LocalTime then an instance of the current system
3575     time zone will be returned. Note however that if you copy this time zone
3576     the instance will not remain in sync if the system time zone changes.
3577 
3578     \sa setTimeZone(), Qt::TimeSpec
3579 */
3580 
3581 QTimeZone QDateTime::timeZone() const
3582 {
3583     switch (getSpec(d)) {
3584     case Qt::UTC:
3585         return QTimeZone::utc();
3586     case Qt::OffsetFromUTC:
3587         return QTimeZone(d->m_offsetFromUtc);
3588     case Qt::TimeZone:
3589         if (d->m_timeZone.isValid())
3590             return d->m_timeZone;
3591         break;
3592     case Qt::LocalTime:
3593         return QTimeZone::systemTimeZone();
3594     }
3595     return QTimeZone();
3596 }
3597 #endif // timezone
3598 
3599 /*!
3600     \since 5.2
3601 
3602     Returns this date-time's Offset From UTC in seconds.
3603 
3604     The result depends on timeSpec():
3605     \list
3606     \li \c Qt::UTC The offset is 0.
3607     \li \c Qt::OffsetFromUTC The offset is the value originally set.
3608     \li \c Qt::LocalTime The local time's offset from UTC is returned.
3609     \li \c Qt::TimeZone The offset used by the time-zone is returned.
3610     \endlist
3611 
3612     For the last two, the offset at this date and time will be returned, taking
3613     account of Daylight-Saving Offset unless the date precedes the start of
3614     1970. The offset is the difference between the local time or time in the
3615     given time-zone and UTC time; it is positive in time-zones ahead of UTC
3616     (East of The Prime Meridian), negative for those behind UTC (West of The
3617     Prime Meridian).
3618 
3619     \sa setOffsetFromUtc()
3620 */
3621 
3622 int QDateTime::offsetFromUtc() const
3623 {
3624     if (!d.isShort())
3625         return d->m_offsetFromUtc;
3626     if (!isValid())
3627         return 0;
3628 
3629     auto spec = getSpec(d);
3630     if (spec == Qt::LocalTime) {
3631         // we didn't cache the value, so we need to calculate it now...
3632         qint64 msecs = getMSecs(d);
3633         return (msecs - toMSecsSinceEpoch()) / MSECS_PER_SEC;
3634     }
3635 
3636     Q_ASSERT(spec == Qt::UTC);
3637     return 0;
3638 }
3639 
3640 /*!
3641     \since 5.2
3642 
3643     Returns the Time Zone Abbreviation for this datetime.
3644 
3645     The returned string depends on timeSpec():
3646 
3647     \list
3648     \li For Qt::UTC it is "UTC".
3649     \li For Qt::OffsetFromUTC it will be in the format "UTC[+-]00:00".
3650     \li For Qt::LocalTime, the host system is queried.
3651     \li For Qt::TimeZone, the associated QTimeZone object is queried.
3652     \endlist
3653 
3654     \note The abbreviation is not guaranteed to be unique, i.e. different time
3655     zones may have the same abbreviation. For Qt::LocalTime and Qt::TimeZone,
3656     when returned by the host system, the abbreviation may be localized.
3657 
3658     \sa timeSpec(), QTimeZone::abbreviation()
3659 */
3660 
3661 QString QDateTime::timeZoneAbbreviation() const
3662 {
3663     if (!isValid())
3664         return QString();
3665 
3666     switch (getSpec(d)) {
3667     case Qt::UTC:
3668         return QLatin1String("UTC");
3669     case Qt::OffsetFromUTC:
3670         return QLatin1String("UTC") + toOffsetString(Qt::ISODate, d->m_offsetFromUtc);
3671     case Qt::TimeZone:
3672 #if !QT_CONFIG(timezone)
3673         break;
3674 #else
3675         Q_ASSERT(d->m_timeZone.isValid());
3676         return d->m_timeZone.abbreviation(*this);
3677 #endif // timezone
3678     case Qt::LocalTime:  {
3679         QString abbrev;
3680         auto status = extractDaylightStatus(getStatus(d));
3681         localMSecsToEpochMSecs(getMSecs(d), &status, nullptr, nullptr, &abbrev);
3682         return abbrev;
3683         }
3684     }
3685     return QString();
3686 }
3687 
3688 /*!
3689     \since 5.2
3690 
3691     Returns if this datetime falls in Daylight-Saving Time.
3692 
3693     If the Qt::TimeSpec is not Qt::LocalTime or Qt::TimeZone then will always
3694     return false.
3695 
3696     \sa timeSpec()
3697 */
3698 
3699 bool QDateTime::isDaylightTime() const
3700 {
3701     if (!isValid())
3702         return false;
3703 
3704     switch (getSpec(d)) {
3705     case Qt::UTC:
3706     case Qt::OffsetFromUTC:
3707         return false;
3708     case Qt::TimeZone:
3709 #if !QT_CONFIG(timezone)
3710         break;
3711 #else
3712         Q_ASSERT(d->m_timeZone.isValid());
3713         return d->m_timeZone.d->isDaylightTime(toMSecsSinceEpoch());
3714 #endif // timezone
3715     case Qt::LocalTime: {
3716         auto status = extractDaylightStatus(getStatus(d));
3717         if (status == QDateTimePrivate::UnknownDaylightTime)
3718             localMSecsToEpochMSecs(getMSecs(d), &status);
3719         return (status == QDateTimePrivate::DaylightTime);
3720         }
3721     }
3722     return false;
3723 }
3724 
3725 /*!
3726     Sets the date part of this datetime to \a date. If no time is set yet, it
3727     is set to midnight. If \a date is invalid, this QDateTime becomes invalid.
3728 
3729     \sa date(), setTime(), setTimeSpec()
3730 */
3731 
3732 void QDateTime::setDate(QDate date)
3733 {
3734     setDateTime(d, date, time());
3735     checkValidDateTime(d);
3736 }
3737 
3738 /*!
3739     Sets the time part of this datetime to \a time. If \a time is not valid,
3740     this function sets it to midnight. Therefore, it's possible to clear any
3741     set time in a QDateTime by setting it to a default QTime:
3742 
3743     \code
3744         QDateTime dt = QDateTime::currentDateTime();
3745         dt.setTime(QTime());
3746     \endcode
3747 
3748     \sa time(), setDate(), setTimeSpec()
3749 */
3750 
3751 void QDateTime::setTime(QTime time)
3752 {
3753     setDateTime(d, date(), time);
3754     checkValidDateTime(d);
3755 }
3756 
3757 /*!
3758     Sets the time specification used in this datetime to \a spec.
3759     The datetime will refer to a different point in time.
3760 
3761     If \a spec is Qt::OffsetFromUTC then the timeSpec() will be set
3762     to Qt::UTC, i.e. an effective offset of 0.
3763 
3764     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3765     i.e. the current system time zone.
3766 
3767     Example:
3768     \snippet code/src_corelib_time_qdatetime.cpp 19
3769 
3770     \sa timeSpec(), setDate(), setTime(), setTimeZone(), Qt::TimeSpec
3771 */
3772 
3773 void QDateTime::setTimeSpec(Qt::TimeSpec spec)
3774 {
3775     QT_PREPEND_NAMESPACE(setTimeSpec(d, spec, 0));
3776     if (spec == Qt::OffsetFromUTC || spec == Qt::UTC)
3777         refreshSimpleDateTime(d);
3778     else
3779         refreshZonedDateTime(d, Qt::LocalTime);
3780 }
3781 
3782 /*!
3783     \since 5.2
3784 
3785     Sets the timeSpec() to Qt::OffsetFromUTC and the offset to \a offsetSeconds.
3786     The datetime will refer to a different point in time.
3787 
3788     The maximum and minimum offset is 14 positive or negative hours.  If
3789     \a offsetSeconds is larger or smaller than that, then the result is
3790     undefined.
3791 
3792     If \a offsetSeconds is 0 then the timeSpec() will be set to Qt::UTC.
3793 
3794     \sa isValid(), offsetFromUtc()
3795 */
3796 
3797 void QDateTime::setOffsetFromUtc(int offsetSeconds)
3798 {
3799     QT_PREPEND_NAMESPACE(setTimeSpec(d, Qt::OffsetFromUTC, offsetSeconds));
3800     refreshSimpleDateTime(d);
3801 }
3802 
3803 #if QT_CONFIG(timezone)
3804 /*!
3805     \since 5.2
3806 
3807     Sets the time zone used in this datetime to \a toZone.
3808     The datetime will refer to a different point in time.
3809 
3810     If \a toZone is invalid then the datetime will be invalid.
3811 
3812     \sa timeZone(), Qt::TimeSpec
3813 */
3814 
3815 void QDateTime::setTimeZone(const QTimeZone &toZone)
3816 {
3817     d.detach();         // always detach
3818     d->m_status = mergeSpec(d->m_status, Qt::TimeZone);
3819     d->m_offsetFromUtc = 0;
3820     d->m_timeZone = toZone;
3821     refreshZonedDateTime(d, Qt::TimeZone);
3822 }
3823 #endif // timezone
3824 
3825 /*!
3826     \since 4.7
3827 
3828     Returns the datetime as the number of milliseconds that have passed
3829     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3830 
3831     On systems that do not support time zones, this function will
3832     behave as if local time were Qt::UTC.
3833 
3834     The behavior for this function is undefined if the datetime stored in
3835     this object is not valid. However, for all valid dates, this function
3836     returns a unique value.
3837 
3838     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3839 */
3840 qint64 QDateTime::toMSecsSinceEpoch() const
3841 {
3842     // Note: QDateTimeParser relies on this producing a useful result, even when
3843     // !isValid(), at least when the invalidity is a time in a fall-back (that
3844     // we'll have adjusted to lie outside it, but marked invalid because it's
3845     // not what was asked for). Other things may be doing similar.
3846     switch (getSpec(d)) {
3847     case Qt::UTC:
3848         return getMSecs(d);
3849 
3850     case Qt::OffsetFromUTC:
3851         Q_ASSERT(!d.isShort());
3852         return d->m_msecs - d->m_offsetFromUtc * MSECS_PER_SEC;
3853 
3854     case Qt::LocalTime: {
3855         // recalculate the local timezone
3856         auto status = extractDaylightStatus(getStatus(d));
3857         // If short, use offset saved by refreshZonedDateTime() on creation:
3858         if (!d.isShort())
3859             return d->m_msecs - d->m_offsetFromUtc * MSECS_PER_SEC;
3860         // Offset from UTC not recorded: need to recompute.
3861         return localMSecsToEpochMSecs(getMSecs(d), &status);
3862     }
3863 
3864     case Qt::TimeZone:
3865         Q_ASSERT(!d.isShort());
3866 #if QT_CONFIG(timezone)
3867         // Use offset refreshZonedDateTime() saved on creation:
3868         if (d->m_timeZone.isValid())
3869             return d->m_msecs - d->m_offsetFromUtc * MSECS_PER_SEC;
3870 #endif
3871         return 0;
3872     }
3873     Q_UNREACHABLE();
3874     return 0;
3875 }
3876 
3877 /*!
3878     \since 5.8
3879 
3880     Returns the datetime as the number of seconds that have passed since
3881     1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3882 
3883     On systems that do not support time zones, this function will
3884     behave as if local time were Qt::UTC.
3885 
3886     The behavior for this function is undefined if the datetime stored in
3887     this object is not valid. However, for all valid dates, this function
3888     returns a unique value.
3889 
3890     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3891 */
3892 qint64 QDateTime::toSecsSinceEpoch() const
3893 {
3894     return toMSecsSinceEpoch() / MSECS_PER_SEC;
3895 }
3896 
3897 /*!
3898     \since 4.7
3899 
3900     Sets the date and time given the number of milliseconds \a msecs that have
3901     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3902     (Qt::UTC). On systems that do not support time zones this function
3903     will behave as if local time were Qt::UTC.
3904 
3905     Note that passing the minimum of \c qint64
3906     (\c{std::numeric_limits<qint64>::min()}) to \a msecs will result in
3907     undefined behavior.
3908 
3909     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3910 */
3911 void QDateTime::setMSecsSinceEpoch(qint64 msecs)
3912 {
3913     auto status = getStatus(d);
3914     const auto spec = extractSpec(status);
3915 
3916     status &= ~QDateTimePrivate::ValidityMask;
3917     switch (spec) {
3918     case Qt::UTC:
3919         status |= QDateTimePrivate::ValidWhenMask;
3920         break;
3921     case Qt::OffsetFromUTC:
3922         msecs += d->m_offsetFromUtc * MSECS_PER_SEC;
3923         status |= QDateTimePrivate::ValidWhenMask;
3924         break;
3925     case Qt::TimeZone:
3926         Q_ASSERT(!d.isShort());
3927 #if QT_CONFIG(timezone)
3928         d.detach();
3929         if (!d->m_timeZone.isValid())
3930             break;
3931         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
3932         // but all affected times afterwards will have DST applied.
3933         if (msecs >= 0) {
3934             status = mergeDaylightStatus(status,
3935                                          d->m_timeZone.d->isDaylightTime(msecs)
3936                                          ? QDateTimePrivate::DaylightTime
3937                                          : QDateTimePrivate::StandardTime);
3938             d->m_offsetFromUtc = d->m_timeZone.d->offsetFromUtc(msecs);
3939         } else {
3940             status = mergeDaylightStatus(status, QDateTimePrivate::StandardTime);
3941             d->m_offsetFromUtc = d->m_timeZone.d->standardTimeOffset(msecs);
3942         }
3943         // NB: cast to qint64 here is important to make sure a matching
3944         // add_overflow is found, GCC 7.5.0 fails without this cast
3945         if (!add_overflow(msecs, qint64(d->m_offsetFromUtc * MSECS_PER_SEC), &msecs))
3946             status |= QDateTimePrivate::ValidWhenMask;
3947 #endif // timezone
3948         break;
3949     case Qt::LocalTime: {
3950         QDate dt;
3951         QTime tm;
3952         QDateTimePrivate::DaylightStatus dstStatus;
3953         epochMSecsToLocalTime(msecs, &dt, &tm, &dstStatus);
3954         setDateTime(d, dt, tm);
3955         refreshZonedDateTime(d, spec); // FIXME: we do this again, below
3956         msecs = getMSecs(d);
3957         status = mergeDaylightStatus(getStatus(d), dstStatus);
3958         break;
3959         }
3960     }
3961 
3962     if (msecsCanBeSmall(msecs) && d.isShort()) {
3963         // we can keep short
3964         d.data.msecs = qintptr(msecs);
3965         d.data.status = status;
3966     } else {
3967         d.detach();
3968         d->m_status = status & ~QDateTimePrivate::ShortData;
3969         d->m_msecs = msecs;
3970     }
3971 
3972     if (spec == Qt::LocalTime || spec == Qt::TimeZone) {
3973         refreshZonedDateTime(d, spec);
3974         Q_ASSERT((d.isShort() ? d.data.msecs : d->m_msecs) == msecs);
3975     }
3976 }
3977 
3978 /*!
3979     \since 5.8
3980 
3981     Sets the date and time given the number of seconds \a secs that have
3982     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3983     (Qt::UTC). On systems that do not support time zones this function
3984     will behave as if local time were Qt::UTC.
3985 
3986     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3987 */
3988 void QDateTime::setSecsSinceEpoch(qint64 secs)
3989 {
3990     qint64 msecs;
3991     if (!mul_overflow(secs, std::integral_constant<qint64, MSECS_PER_SEC>(), &msecs)) {
3992         setMSecsSinceEpoch(msecs);
3993     } else if (d.isShort()) {
3994         d.data.status &= ~QDateTimePrivate::ValidWhenMask;
3995     } else {
3996         d.detach();
3997         d->m_status &= ~QDateTimePrivate::ValidWhenMask;
3998     }
3999 }
4000 
4001 #if QT_CONFIG(datestring) // depends on, so implies, textdate
4002 /*!
4003     \overload
4004 
4005     Returns the datetime as a string in the \a format given.
4006 
4007     If the \a format is Qt::TextDate, the string is formatted in the default
4008     way. The day and month names will be in English. An example of this
4009     formatting is "Wed May 20 03:40:13 1998". For localized formatting, see
4010     \l{QLocale::toString()}.
4011 
4012     If the \a format is Qt::ISODate, the string format corresponds
4013     to the ISO 8601 extended specification for representations of
4014     dates and times, taking the form yyyy-MM-ddTHH:mm:ss[Z|[+|-]HH:mm],
4015     depending on the timeSpec() of the QDateTime. If the timeSpec()
4016     is Qt::UTC, Z will be appended to the string; if the timeSpec() is
4017     Qt::OffsetFromUTC, the offset in hours and minutes from UTC will
4018     be appended to the string. To include milliseconds in the ISO 8601
4019     date, use the \a format Qt::ISODateWithMs, which corresponds to
4020     yyyy-MM-ddTHH:mm:ss.zzz[Z|[+|-]HH:mm].
4021 
4022     If the \a format is Qt::RFC2822Date, the string is formatted
4023     following \l{RFC 2822}.
4024 
4025     If the datetime is invalid, an empty string will be returned.
4026 
4027     \warning The Qt::ISODate format is only valid for years in the
4028     range 0 to 9999.
4029 
4030     \sa fromString(), QDate::toString(), QTime::toString(),
4031     QLocale::toString()
4032 */
4033 QString QDateTime::toString(Qt::DateFormat format) const
4034 {
4035     QString buf;
4036     if (!isValid())
4037         return buf;
4038 
4039     switch (format) {
4040     case Qt::RFC2822Date:
4041         buf = QLocale::c().toString(*this, u"dd MMM yyyy hh:mm:ss ");
4042         buf += toOffsetString(Qt::TextDate, offsetFromUtc());
4043         return buf;
4044     default:
4045     case Qt::TextDate: {
4046         const QPair<QDate, QTime> p = getDateTime(d);
4047         buf = toStringTextDate(p.first);
4048         // Insert time between date's day and year:
4049         buf.insert(buf.lastIndexOf(u' '),
4050                    u' ' + p.second.toString(Qt::TextDate));
4051         // Append zone/offset indicator, as appropriate:
4052         switch (timeSpec()) {
4053         case Qt::LocalTime:
4054             break;
4055 #if QT_CONFIG(timezone)
4056         case Qt::TimeZone:
4057             buf += u' ' + d->m_timeZone.displayName(
4058                 *this, QTimeZone::OffsetName, QLocale::c());
4059             break;
4060 #endif
4061         default:
4062 #if 0 // ### Qt 7 GMT: use UTC instead, see qnamespace.qdoc documentation
4063             buf += QLatin1String(" UTC");
4064 #else
4065             buf += QLatin1String(" GMT");
4066 #endif
4067             if (getSpec(d) == Qt::OffsetFromUTC)
4068                 buf += toOffsetString(Qt::TextDate, offsetFromUtc());
4069         }
4070         return buf;
4071     }
4072     case Qt::ISODate:
4073     case Qt::ISODateWithMs: {
4074         const QPair<QDate, QTime> p = getDateTime(d);
4075         buf = toStringIsoDate(p.first);
4076         if (buf.isEmpty())
4077             return QString();   // failed to convert
4078         buf += u'T' + p.second.toString(format);
4079         switch (getSpec(d)) {
4080         case Qt::UTC:
4081             buf += u'Z';
4082             break;
4083         case Qt::OffsetFromUTC:
4084 #if QT_CONFIG(timezone)
4085         case Qt::TimeZone:
4086 #endif
4087             buf += toOffsetString(Qt::ISODate, offsetFromUtc());
4088             break;
4089         default:
4090             break;
4091         }
4092         return buf;
4093     }
4094     }
4095 }
4096 
4097 /*!
4098     \fn QString QDateTime::toString(const QString &format, QCalendar cal) const
4099     \fn QString QDateTime::toString(QStringView format, QCalendar cal) const
4100 
4101     Returns the datetime as a string. The \a format parameter determines the
4102     format of the result string. If \a cal is supplied, it determines the calendar
4103     used to represent the date; it defaults to Gregorian. See QTime::toString()
4104     and QDate::toString() for the supported specifiers for time and date,
4105     respectively.
4106 
4107     Any sequence of characters enclosed in single quotes will be included
4108     verbatim in the output string (stripped of the quotes), even if it contains
4109     formatting characters. Two consecutive single quotes ("''") are replaced by
4110     a single quote in the output. All other characters in the format string are
4111     included verbatim in the output string.
4112 
4113     Formats without separators (e.g. "ddMM") are supported but must be used with
4114     care, as the resulting strings aren't always reliably readable (e.g. if "dM"
4115     produces "212" it could mean either the 2nd of December or the 21st of
4116     February).
4117 
4118     Example format strings (assumed that the QDateTime is 21 May 2001
4119     14:13:09.120):
4120 
4121     \table
4122     \header \li Format       \li Result
4123     \row \li dd.MM.yyyy      \li 21.05.2001
4124     \row \li ddd MMMM d yy   \li Tue May 21 01
4125     \row \li hh:mm:ss.zzz    \li 14:13:09.120
4126     \row \li hh:mm:ss.z      \li 14:13:09.12
4127     \row \li h:m:s ap        \li 2:13:9 pm
4128     \endtable
4129 
4130     If the datetime is invalid, an empty string will be returned.
4131 
4132     \note Day and month names as well as AM/PM indication are given in English (C locale).
4133     If localized month and day names and localized forms of AM/PM are used, use
4134     QLocale::system().toDateTime().
4135 
4136     \sa fromString(), QDate::toString(), QTime::toString(), QLocale::toString()
4137 */
4138 QString QDateTime::toString(QStringView format, QCalendar cal) const
4139 {
4140     return QLocale::c().toString(*this, format, cal);
4141 }
4142 #endif // datestring
4143 
4144 static inline void massageAdjustedDateTime(QDateTimeData &d, QDate date, QTime time)
4145 {
4146     /*
4147       If we have just adjusted to a day with a DST transition, our given time
4148       may lie in the transition hour (either missing or duplicated).  For any
4149       other time, telling mktime (deep in the bowels of localMSecsToEpochMSecs)
4150       we don't know its DST-ness will produce no adjustment (just a decision as
4151       to its DST-ness); but for a time in spring's missing hour it'll adjust the
4152       time while picking a DST-ness.  (Handling of autumn is trickier, as either
4153       DST-ness is valid, without adjusting the time.  We might want to propagate
4154       the daylight status in that case, but it's hard to do so without breaking
4155       (far more common) other cases; and it makes little difference, as the two
4156       answers do then differ only in DST-ness.)
4157     */
4158     auto spec = getSpec(d);
4159     if (spec == Qt::LocalTime) {
4160         QDateTimePrivate::DaylightStatus status = QDateTimePrivate::UnknownDaylightTime;
4161         localMSecsToEpochMSecs(timeToMSecs(date, time), &status, &date, &time);
4162 #if QT_CONFIG(timezone)
4163     } else if (spec == Qt::TimeZone && d->m_timeZone.isValid()) {
4164         QDateTimePrivate::zoneMSecsToEpochMSecs(timeToMSecs(date, time),
4165                                                 d->m_timeZone,
4166                                                 QDateTimePrivate::UnknownDaylightTime,
4167                                                 &date, &time);
4168 #endif // timezone
4169     }
4170     setDateTime(d, date, time);
4171     checkValidDateTime(d);
4172 }
4173 
4174 /*!
4175     Returns a QDateTime object containing a datetime \a ndays days
4176     later than the datetime of this object (or earlier if \a ndays is
4177     negative).
4178 
4179     If the timeSpec() is Qt::LocalTime and the resulting
4180     date and time fall in the Standard Time to Daylight-Saving Time transition
4181     hour then the result will be adjusted accordingly, i.e. if the transition
4182     is at 2am and the clock goes forward to 3am and the result falls between
4183     2am and 3am then the result will be adjusted to fall after 3am.
4184 
4185     \sa daysTo(), addMonths(), addYears(), addSecs()
4186 */
4187 
4188 QDateTime QDateTime::addDays(qint64 ndays) const
4189 {
4190     if (isNull())
4191         return QDateTime();
4192 
4193     QDateTime dt(*this);
4194     QPair<QDate, QTime> p = getDateTime(d);
4195     massageAdjustedDateTime(dt.d, p.first.addDays(ndays), p.second);
4196     return dt;
4197 }
4198 
4199 /*!
4200     Returns a QDateTime object containing a datetime \a nmonths months
4201     later than the datetime of this object (or earlier if \a nmonths
4202     is negative).
4203 
4204     If the timeSpec() is Qt::LocalTime and the resulting
4205     date and time fall in the Standard Time to Daylight-Saving Time transition
4206     hour then the result will be adjusted accordingly, i.e. if the transition
4207     is at 2am and the clock goes forward to 3am and the result falls between
4208     2am and 3am then the result will be adjusted to fall after 3am.
4209 
4210     \sa daysTo(), addDays(), addYears(), addSecs()
4211 */
4212 
4213 QDateTime QDateTime::addMonths(int nmonths) const
4214 {
4215     if (isNull())
4216         return QDateTime();
4217 
4218     QDateTime dt(*this);
4219     QPair<QDate, QTime> p = getDateTime(d);
4220     massageAdjustedDateTime(dt.d, p.first.addMonths(nmonths), p.second);
4221     return dt;
4222 }
4223 
4224 /*!
4225     Returns a QDateTime object containing a datetime \a nyears years
4226     later than the datetime of this object (or earlier if \a nyears is
4227     negative).
4228 
4229     If the timeSpec() is Qt::LocalTime and the resulting
4230     date and time fall in the Standard Time to Daylight-Saving Time transition
4231     hour then the result will be adjusted accordingly, i.e. if the transition
4232     is at 2am and the clock goes forward to 3am and the result falls between
4233     2am and 3am then the result will be adjusted to fall after 3am.
4234 
4235     \sa daysTo(), addDays(), addMonths(), addSecs()
4236 */
4237 
4238 QDateTime QDateTime::addYears(int nyears) const
4239 {
4240     if (isNull())
4241         return QDateTime();
4242 
4243     QDateTime dt(*this);
4244     QPair<QDate, QTime> p = getDateTime(d);
4245     massageAdjustedDateTime(dt.d, p.first.addYears(nyears), p.second);
4246     return dt;
4247 }
4248 
4249 /*!
4250     Returns a QDateTime object containing a datetime \a s seconds
4251     later than the datetime of this object (or earlier if \a s is
4252     negative).
4253 
4254     If this datetime is invalid, an invalid datetime will be returned.
4255 
4256     \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears()
4257 */
4258 
4259 QDateTime QDateTime::addSecs(qint64 s) const
4260 {
4261     qint64 msecs;
4262     if (mul_overflow(s, std::integral_constant<qint64, MSECS_PER_SEC>(), &msecs))
4263         return QDateTime();
4264     return addMSecs(msecs);
4265 }
4266 
4267 /*!
4268     Returns a QDateTime object containing a datetime \a msecs miliseconds
4269     later than the datetime of this object (or earlier if \a msecs is
4270     negative).
4271 
4272     If this datetime is invalid, an invalid datetime will be returned.
4273 
4274     \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears()
4275 */
4276 QDateTime QDateTime::addMSecs(qint64 msecs) const
4277 {
4278     if (!isValid())
4279         return QDateTime();
4280 
4281     QDateTime dt(*this);
4282     switch (getSpec(d)) {
4283     case Qt::LocalTime:
4284     case Qt::TimeZone:
4285         // Convert to real UTC first in case this crosses a DST transition:
4286         if (!add_overflow(toMSecsSinceEpoch(), msecs, &msecs)) {
4287             dt.setMSecsSinceEpoch(msecs);
4288         } else if (dt.d.isShort()) {
4289             dt.d.data.status &= ~QDateTimePrivate::ValidWhenMask;
4290         } else {
4291             dt.d.detach();
4292             dt.d->m_status &= ~QDateTimePrivate::ValidWhenMask;
4293         }
4294         break;
4295     case Qt::UTC:
4296     case Qt::OffsetFromUTC:
4297         // No need to convert, just add on
4298         if (add_overflow(getMSecs(d), msecs, &msecs)) {
4299             if (dt.d.isShort()) {
4300                 dt.d.data.status &= ~QDateTimePrivate::ValidWhenMask;
4301             } else {
4302                 dt.d.detach();
4303                 dt.d->m_status &= ~QDateTimePrivate::ValidWhenMask;
4304             }
4305         } else if (d.isShort()) {
4306             // need to check if we need to enlarge first
4307             if (msecsCanBeSmall(msecs)) {
4308                 dt.d.data.msecs = qintptr(msecs);
4309             } else {
4310                 dt.d.detach();
4311                 dt.d->m_msecs = msecs;
4312             }
4313         } else {
4314             dt.d.detach();
4315             dt.d->m_msecs = msecs;
4316         }
4317         break;
4318     }
4319     return dt;
4320 }
4321 
4322 /*!
4323     Returns the number of days from this datetime to the \a other
4324     datetime. The number of days is counted as the number of times
4325     midnight is reached between this datetime to the \a other
4326     datetime. This means that a 10 minute difference from 23:55 to
4327     0:05 the next day counts as one day.
4328 
4329     If the \a other datetime is earlier than this datetime,
4330     the value returned is negative.
4331 
4332     Example:
4333     \snippet code/src_corelib_time_qdatetime.cpp 15
4334 
4335     \sa addDays(), secsTo(), msecsTo()
4336 */
4337 
4338 qint64 QDateTime::daysTo(const QDateTime &other) const
4339 {
4340     return date().daysTo(other.date());
4341 }
4342 
4343 /*!
4344     Returns the number of seconds from this datetime to the \a other
4345     datetime. If the \a other datetime is earlier than this datetime,
4346     the value returned is negative.
4347 
4348     Before performing the comparison, the two datetimes are converted
4349     to Qt::UTC to ensure that the result is correct if daylight-saving
4350     (DST) applies to one of the two datetimes but not the other.
4351 
4352     Returns 0 if either datetime is invalid.
4353 
4354     Example:
4355     \snippet code/src_corelib_time_qdatetime.cpp 11
4356 
4357     \sa addSecs(), daysTo(), QTime::secsTo()
4358 */
4359 
4360 qint64 QDateTime::secsTo(const QDateTime &other) const
4361 {
4362     return msecsTo(other) / MSECS_PER_SEC;
4363 }
4364 
4365 /*!
4366     Returns the number of milliseconds from this datetime to the \a other
4367     datetime. If the \a other datetime is earlier than this datetime,
4368     the value returned is negative.
4369 
4370     Before performing the comparison, the two datetimes are converted
4371     to Qt::UTC to ensure that the result is correct if daylight-saving
4372     (DST) applies to one of the two datetimes and but not the other.
4373 
4374     Returns 0 if either datetime is invalid.
4375 
4376     \sa addMSecs(), daysTo(), QTime::msecsTo()
4377 */
4378 
4379 qint64 QDateTime::msecsTo(const QDateTime &other) const
4380 {
4381     if (!isValid() || !other.isValid())
4382         return 0;
4383 
4384     return other.toMSecsSinceEpoch() - toMSecsSinceEpoch();
4385 }
4386 
4387 /*!
4388     Returns a copy of this datetime converted to the given time
4389     \a spec.
4390 
4391     If \a spec is Qt::OffsetFromUTC then it is set to Qt::UTC.  To set to a
4392     spec of Qt::OffsetFromUTC use toOffsetFromUtc().
4393 
4394     If \a spec is Qt::TimeZone then it is set to Qt::LocalTime,
4395     i.e. the local Time Zone.
4396 
4397     Example:
4398     \snippet code/src_corelib_time_qdatetime.cpp 16
4399 
4400     \sa timeSpec(), toTimeZone(), toOffsetFromUtc()
4401 */
4402 
4403 QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const
4404 {
4405     if (getSpec(d) == spec && (spec == Qt::UTC || spec == Qt::LocalTime))
4406         return *this;
4407 
4408     if (!isValid()) {
4409         QDateTime ret = *this;
4410         ret.setTimeSpec(spec);
4411         return ret;
4412     }
4413 
4414     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), spec, 0);
4415 }
4416 
4417 /*!
4418     \since 5.2
4419 
4420     \fn QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4421 
4422     Returns a copy of this datetime converted to a spec of Qt::OffsetFromUTC
4423     with the given \a offsetSeconds.
4424 
4425     If the \a offsetSeconds equals 0 then a UTC datetime will be returned
4426 
4427     \sa setOffsetFromUtc(), offsetFromUtc(), toTimeSpec()
4428 */
4429 
4430 QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4431 {
4432     if (getSpec(d) == Qt::OffsetFromUTC
4433             && d->m_offsetFromUtc == offsetSeconds)
4434         return *this;
4435 
4436     if (!isValid()) {
4437         QDateTime ret = *this;
4438         ret.setOffsetFromUtc(offsetSeconds);
4439         return ret;
4440     }
4441 
4442     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), Qt::OffsetFromUTC, offsetSeconds);
4443 }
4444 
4445 #if QT_CONFIG(timezone)
4446 /*!
4447     \since 5.2
4448 
4449     Returns a copy of this datetime converted to the given \a timeZone
4450 
4451     \sa timeZone(), toTimeSpec()
4452 */
4453 
4454 QDateTime QDateTime::toTimeZone(const QTimeZone &timeZone) const
4455 {
4456     if (getSpec(d) == Qt::TimeZone && d->m_timeZone == timeZone)
4457         return *this;
4458 
4459     if (!isValid()) {
4460         QDateTime ret = *this;
4461         ret.setTimeZone(timeZone);
4462         return ret;
4463     }
4464 
4465     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), timeZone);
4466 }
4467 #endif // timezone
4468 
4469 /*!
4470     \internal
4471     Returns \c true if this datetime is equal to the \a other datetime;
4472     otherwise returns \c false.
4473 
4474     \sa precedes(), operator==()
4475 */
4476 
4477 bool QDateTime::equals(const QDateTime &other) const
4478 {
4479     if (!isValid())
4480         return !other.isValid();
4481     if (!other.isValid())
4482         return false;
4483 
4484     if (usesSameOffset(d, other.d))
4485         return getMSecs(d) == getMSecs(other.d);
4486 
4487     // Convert to UTC and compare
4488     return toMSecsSinceEpoch() == other.toMSecsSinceEpoch();
4489 }
4490 
4491 /*!
4492     \fn bool QDateTime::operator==(const QDateTime &lhs, const QDateTime &rhs)
4493 
4494     Returns \c true if \a lhs is the same as \a rhs; otherwise returns \c false.
4495 
4496     Two datetimes are different if either the date, the time, or the time zone
4497     components are different. Since 5.14, all invalid datetime are equal (and
4498     less than all valid datetimes).
4499 
4500     \sa operator!=(), operator<(), operator<=(), operator>(), operator>=()
4501 */
4502 
4503 /*!
4504     \fn bool QDateTime::operator!=(const QDateTime &lhs, const QDateTime &rhs)
4505 
4506     Returns \c true if \a lhs is different from \a rhs; otherwise returns \c
4507     false.
4508 
4509     Two datetimes are different if either the date, the time, or the time zone
4510     components are different. Since 5.14, all invalid datetime are equal (and
4511     less than all valid datetimes).
4512 
4513     \sa operator==()
4514 */
4515 
4516 /*!
4517     \internal
4518     Returns \c true if \a lhs is earlier than the \a rhs
4519     datetime; otherwise returns \c false.
4520 
4521     \sa equals(), operator<()
4522 */
4523 
4524 bool QDateTime::precedes(const QDateTime &other) const
4525 {
4526     if (!isValid())
4527         return other.isValid();
4528     if (!other.isValid())
4529         return false;
4530 
4531     if (usesSameOffset(d, other.d))
4532         return getMSecs(d) < getMSecs(other.d);
4533 
4534     // Convert to UTC and compare
4535     return toMSecsSinceEpoch() < other.toMSecsSinceEpoch();
4536 }
4537 
4538 /*!
4539     \fn bool QDateTime::operator<(const QDateTime &lhs, const QDateTime &rhs)
4540 
4541     Returns \c true if \a lhs is earlier than \a rhs;
4542     otherwise returns \c false.
4543 
4544     \sa operator==()
4545 */
4546 
4547 /*!
4548     \fn bool QDateTime::operator<=(const QDateTime &lhs, const QDateTime &rhs)
4549 
4550     Returns \c true if \a lhs is earlier than or equal to \a rhs; otherwise
4551     returns \c false.
4552 
4553     \sa operator==()
4554 */
4555 
4556 /*!
4557     \fn bool QDateTime::operator>(const QDateTime &lhs, const QDateTime &rhs)
4558 
4559     Returns \c true if \a lhs is later than \a rhs; otherwise returns \c false.
4560 
4561     \sa operator==()
4562 */
4563 
4564 /*!
4565     \fn bool QDateTime::operator>=(const QDateTime &lhs, const QDateTime &rhs)
4566 
4567     Returns \c true if \a lhs is later than or equal to \a rhs;
4568     otherwise returns \c false.
4569 
4570     \sa operator==()
4571 */
4572 
4573 /*!
4574     \fn QDateTime QDateTime::currentDateTime()
4575     Returns the current datetime, as reported by the system clock, in
4576     the local time zone.
4577 
4578     \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4579 */
4580 
4581 /*!
4582     \fn QDateTime QDateTime::currentDateTimeUtc()
4583     \since 4.7
4584     Returns the current datetime, as reported by the system clock, in
4585     UTC.
4586 
4587     \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4588 */
4589 
4590 /*!
4591     \fn qint64 QDateTime::currentMSecsSinceEpoch()
4592     \since 4.7
4593 
4594     Returns the number of milliseconds since 1970-01-01T00:00:00 Universal
4595     Coordinated Time. This number is like the POSIX time_t variable, but
4596     expressed in milliseconds instead.
4597 
4598     \sa currentDateTime(), currentDateTimeUtc(), toTimeSpec()
4599 */
4600 
4601 /*!
4602     \fn qint64 QDateTime::currentSecsSinceEpoch()
4603     \since 5.8
4604 
4605     Returns the number of seconds since 1970-01-01T00:00:00 Universal
4606     Coordinated Time.
4607 
4608     \sa currentMSecsSinceEpoch()
4609 */
4610 
4611 #if defined(Q_OS_WIN)
4612 static inline uint msecsFromDecomposed(int hour, int minute, int sec, int msec = 0)
4613 {
4614     return MSECS_PER_HOUR * hour + MSECS_PER_MIN * minute + MSECS_PER_SEC * sec + msec;
4615 }
4616 
4617 QDate QDate::currentDate()
4618 {
4619     SYSTEMTIME st;
4620     memset(&st, 0, sizeof(SYSTEMTIME));
4621     GetLocalTime(&st);
4622     return QDate(st.wYear, st.wMonth, st.wDay);
4623 }
4624 
4625 QTime QTime::currentTime()
4626 {
4627     QTime ct;
4628     SYSTEMTIME st;
4629     memset(&st, 0, sizeof(SYSTEMTIME));
4630     GetLocalTime(&st);
4631     ct.setHMS(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4632     return ct;
4633 }
4634 
4635 QDateTime QDateTime::currentDateTime()
4636 {
4637     QTime t;
4638     SYSTEMTIME st;
4639     memset(&st, 0, sizeof(SYSTEMTIME));
4640     GetLocalTime(&st);
4641     QDate d(st.wYear, st.wMonth, st.wDay);
4642     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4643     return QDateTime(d, t);
4644 }
4645 
4646 QDateTime QDateTime::currentDateTimeUtc()
4647 {
4648     QTime t;
4649     SYSTEMTIME st;
4650     memset(&st, 0, sizeof(SYSTEMTIME));
4651     GetSystemTime(&st);
4652     QDate d(st.wYear, st.wMonth, st.wDay);
4653     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4654     return QDateTime(d, t, Qt::UTC);
4655 }
4656 
4657 qint64 QDateTime::currentMSecsSinceEpoch() noexcept
4658 {
4659     SYSTEMTIME st;
4660     memset(&st, 0, sizeof(SYSTEMTIME));
4661     GetSystemTime(&st);
4662     const qint64 daysAfterEpoch = QDate(1970, 1, 1).daysTo(QDate(st.wYear, st.wMonth, st.wDay));
4663 
4664     return msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds) +
4665            daysAfterEpoch * MSECS_PER_DAY;
4666 }
4667 
4668 qint64 QDateTime::currentSecsSinceEpoch() noexcept
4669 {
4670     SYSTEMTIME st;
4671     memset(&st, 0, sizeof(SYSTEMTIME));
4672     GetSystemTime(&st);
4673     const qint64 daysAfterEpoch = QDate(1970, 1, 1).daysTo(QDate(st.wYear, st.wMonth, st.wDay));
4674 
4675     return st.wHour * SECS_PER_HOUR + st.wMinute * SECS_PER_MIN + st.wSecond +
4676            daysAfterEpoch * SECS_PER_DAY;
4677 }
4678 
4679 #elif defined(Q_OS_UNIX)
4680 QDate QDate::currentDate()
4681 {
4682     return QDateTime::currentDateTime().date();
4683 }
4684 
4685 QTime QTime::currentTime()
4686 {
4687     return QDateTime::currentDateTime().time();
4688 }
4689 
4690 QDateTime QDateTime::currentDateTime()
4691 {
4692     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::LocalTime);
4693 }
4694 
4695 QDateTime QDateTime::currentDateTimeUtc()
4696 {
4697     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::UTC);
4698 }
4699 
4700 qint64 QDateTime::currentMSecsSinceEpoch() noexcept
4701 {
4702     // posix compliant system
4703     // we have milliseconds
4704     struct timeval tv;
4705     gettimeofday(&tv, nullptr);
4706     return tv.tv_sec * MSECS_PER_SEC + tv.tv_usec / 1000;
4707 }
4708 
4709 qint64 QDateTime::currentSecsSinceEpoch() noexcept
4710 {
4711     struct timeval tv;
4712     gettimeofday(&tv, nullptr);
4713     return tv.tv_sec;
4714 }
4715 #else
4716 #error "What system is this?"
4717 #endif
4718 
4719 /*!
4720   Returns a datetime whose date and time are the number of milliseconds \a msecs
4721   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4722   Time (Qt::UTC) and converted to the given \a spec.
4723 
4724   Note that there are possible values for \a msecs that lie outside the valid
4725   range of QDateTime, both negative and positive. The behavior of this
4726   function is undefined for those values.
4727 
4728   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4729   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4730   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4731 
4732   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4733   i.e. the current system time zone.
4734 
4735   \sa toMSecsSinceEpoch(), setMSecsSinceEpoch()
4736 */
4737 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, Qt::TimeSpec spec, int offsetSeconds)
4738 {
4739     QDateTime dt;
4740     QT_PREPEND_NAMESPACE(setTimeSpec(dt.d, spec, offsetSeconds));
4741     dt.setMSecsSinceEpoch(msecs);
4742     return dt;
4743 }
4744 
4745 /*!
4746   \since 5.8
4747 
4748   Returns a datetime whose date and time are the number of seconds \a secs
4749   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4750   Time (Qt::UTC) and converted to the given \a spec.
4751 
4752   Note that there are possible values for \a secs that lie outside the valid
4753   range of QDateTime, both negative and positive. The behavior of this
4754   function is undefined for those values.
4755 
4756   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4757   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4758   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4759 
4760   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4761   i.e. the current system time zone.
4762 
4763   \sa toSecsSinceEpoch(), setSecsSinceEpoch()
4764 */
4765 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, Qt::TimeSpec spec, int offsetSeconds)
4766 {
4767     constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / MSECS_PER_SEC;
4768     constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / MSECS_PER_SEC;
4769     if (secs > maxSeconds || secs < minSeconds)
4770         return QDateTime(); // Would {und,ov}erflow
4771     return fromMSecsSinceEpoch(secs * MSECS_PER_SEC, spec, offsetSeconds);
4772 }
4773 
4774 #if QT_CONFIG(timezone)
4775 /*!
4776     \since 5.2
4777 
4778     Returns a datetime whose date and time are the number of milliseconds \a msecs
4779     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4780     Time (Qt::UTC) and with the given \a timeZone.
4781 
4782     \sa fromSecsSinceEpoch()
4783 */
4784 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, const QTimeZone &timeZone)
4785 {
4786     QDateTime dt;
4787     dt.setTimeZone(timeZone);
4788     if (timeZone.isValid())
4789         dt.setMSecsSinceEpoch(msecs);
4790     return dt;
4791 }
4792 
4793 /*!
4794     \since 5.8
4795 
4796     Returns a datetime whose date and time are the number of seconds \a secs
4797     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4798     Time (Qt::UTC) and with the given \a timeZone.
4799 
4800     \sa fromMSecsSinceEpoch()
4801 */
4802 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, const QTimeZone &timeZone)
4803 {
4804     constexpr qint64 maxSeconds = std::numeric_limits<qint64>::max() / MSECS_PER_SEC;
4805     constexpr qint64 minSeconds = std::numeric_limits<qint64>::min() / MSECS_PER_SEC;
4806     if (secs > maxSeconds || secs < minSeconds)
4807         return QDateTime(); // Would {und,ov}erflow
4808     return fromMSecsSinceEpoch(secs * MSECS_PER_SEC, timeZone);
4809 }
4810 #endif
4811 
4812 #if QT_CONFIG(datestring) // depends on, so implies, textdate
4813 
4814 /*!
4815     \fn QDateTime QDateTime::fromString(const QString &string, Qt::DateFormat format)
4816 
4817     Returns the QDateTime represented by the \a string, using the
4818     \a format given, or an invalid datetime if this is not possible.
4819 
4820     Note for Qt::TextDate: only English short month names (e.g. "Jan" in short
4821     form or "January" in long form) are recognized.
4822 
4823     \sa toString(), QLocale::toDateTime()
4824 */
4825 
4826 /*!
4827     \overload
4828     \since 6.0
4829 */
4830 QDateTime QDateTime::fromString(QStringView string, Qt::DateFormat format)
4831 {
4832     if (string.isEmpty())
4833         return QDateTime();
4834 
4835     switch (format) {
4836     case Qt::RFC2822Date: {
4837         const ParsedRfcDateTime rfc = rfcDateImpl(string);
4838 
4839         if (!rfc.date.isValid() || !rfc.time.isValid())
4840             return QDateTime();
4841 
4842         QDateTime dateTime(rfc.date, rfc.time, Qt::UTC);
4843         dateTime.setOffsetFromUtc(rfc.utcOffset);
4844         return dateTime;
4845     }
4846     case Qt::ISODate:
4847     case Qt::ISODateWithMs: {
4848         const int size = string.size();
4849         if (size < 10)
4850             return QDateTime();
4851 
4852         QDate date = QDate::fromString(string.first(10), Qt::ISODate);
4853         if (!date.isValid())
4854             return QDateTime();
4855         if (size == 10)
4856             return date.startOfDay();
4857 
4858         Qt::TimeSpec spec = Qt::LocalTime;
4859         QStringView isoString = string.sliced(10); // trim "yyyy-MM-dd"
4860 
4861         // Must be left with T (or space) and at least one digit for the hour:
4862         if (isoString.size() < 2
4863             || !(isoString.startsWith(u'T', Qt::CaseInsensitive)
4864                  // RFC 3339 (section 5.6) allows a space here.  (It actually
4865                  // allows any separator one considers more readable, merely
4866                  // giving space as an example - but let's not go wild !)
4867                  || isoString.startsWith(u' '))) {
4868             return QDateTime();
4869         }
4870         isoString = isoString.sliced(1); // trim 'T' (or space)
4871 
4872         int offset = 0;
4873         // Check end of string for Time Zone definition, either Z for UTC or [+-]HH:mm for Offset
4874         if (isoString.endsWith(u'Z', Qt::CaseInsensitive)) {
4875             spec = Qt::UTC;
4876             isoString.chop(1); // trim 'Z'
4877         } else {
4878             // the loop below is faster but functionally equal to:
4879             // const int signIndex = isoString.indexOf(QRegulargExpression(QStringLiteral("[+-]")));
4880             int signIndex = isoString.size() - 1;
4881             Q_ASSERT(signIndex >= 0);
4882             bool found = false;
4883             do {
4884                 QChar character(isoString[signIndex]);
4885                 found = character == u'+' || character == u'-';
4886             } while (!found && --signIndex >= 0);
4887 
4888             if (found) {
4889                 bool ok;
4890                 offset = fromOffsetString(isoString.sliced(signIndex), &ok);
4891                 if (!ok)
4892                     return QDateTime();
4893                 isoString = isoString.first(signIndex);
4894                 spec = Qt::OffsetFromUTC;
4895             }
4896         }
4897 
4898         // Might be end of day (24:00, including variants), which QTime considers invalid.
4899         // ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
4900         bool isMidnight24 = false;
4901         QTime time = fromIsoTimeString(isoString, format, &isMidnight24);
4902         if (!time.isValid())
4903             return QDateTime();
4904         if (isMidnight24) // time is 0:0, but we want the start of next day:
4905             return date.addDays(1).startOfDay(spec, offset);
4906         return QDateTime(date, time, spec, offset);
4907     }
4908     case Qt::TextDate: {
4909         QList<QStringView> parts = string.split(u' ', Qt::SkipEmptyParts);
4910 
4911         // Documented as "ddd MMM d HH:mm:ss yyyy" with optional offset-suffix;
4912         // and allow time either before or after year.
4913         if (parts.count() < 5 || parts.count() > 6)
4914             return QDateTime();
4915 
4916         // Year and time can be in either order.
4917         // Guess which by looking for ':' in the time
4918         int yearPart = 3;
4919         int timePart = 3;
4920         if (parts.at(3).contains(u':'))
4921             yearPart = 4;
4922         else if (parts.at(4).contains(u':'))
4923             timePart = 4;
4924         else
4925             return QDateTime();
4926 
4927         bool ok = false;
4928         int day = parts.at(2).toInt(&ok);
4929         int year = ok ? parts.at(yearPart).toInt(&ok) : 0;
4930         int month = fromShortMonthName(parts.at(1));
4931         if (!ok || year == 0 || day == 0 || month < 1)
4932             return QDateTime();
4933 
4934         const QDate date(year, month, day);
4935         if (!date.isValid())
4936             return QDateTime();
4937 
4938         const QTime time = fromIsoTimeString(parts.at(timePart), format, nullptr);
4939         if (!time.isValid())
4940             return QDateTime();
4941 
4942         if (parts.count() == 5)
4943             return QDateTime(date, time, Qt::LocalTime);
4944 
4945         QStringView tz = parts.at(5);
4946         if (tz.startsWith(QLatin1String("UTC"))
4947             // GMT has long been deprecated as an alias for UTC.
4948             || tz.startsWith(QLatin1String("GMT"), Qt::CaseInsensitive)) {
4949             tz = tz.sliced(3);
4950             if (tz.isEmpty())
4951                 return QDateTime(date, time, Qt::UTC);
4952 
4953             int offset = fromOffsetString(tz, &ok);
4954             return ok ? QDateTime(date, time, Qt::OffsetFromUTC, offset) : QDateTime();
4955         }
4956         return QDateTime();
4957     }
4958     }
4959 
4960     return QDateTime();
4961 }
4962 
4963 /*!
4964     \fn QDateTime QDateTime::fromString(const QString &string, const QString &format, QCalendar cal)
4965 
4966     Returns the QDateTime represented by the \a string, using the \a
4967     format given, or an invalid datetime if the string cannot be parsed.
4968 
4969     Uses the calendar \a cal if supplied, else Gregorian.
4970 
4971     In addition to the expressions, recognized in the format string to represent
4972     parts of the date and time, by QDate::fromString() and QTime::fromString(),
4973     this method supports:
4974 
4975     \table
4976     \header \li Expression \li Output
4977     \row \li t \li the timezone (for example "CEST")
4978     \endtable
4979 
4980     If no 't' format specifier is present, the system's local time-zone is used.
4981     For the defaults of all other fields, see QDate::fromString() and QTime::fromString().
4982 
4983     For example:
4984 
4985     \snippet code/src_corelib_time_qdatetime.cpp 14
4986 
4987     All other input characters will be treated as text. Any non-empty sequence
4988     of characters enclosed in single quotes will also be treated (stripped of
4989     the quotes) as text and not be interpreted as expressions.
4990 
4991     \snippet code/src_corelib_time_qdatetime.cpp 12
4992 
4993     If the format is not satisfied, an invalid QDateTime is returned.  If the
4994     format is satisfied but \a string represents an invalid date-time (e.g. in a
4995     gap skipped by a time-zone transition), an invalid QDateTime is returned,
4996     whose toMSecsSinceEpoch() represents a near-by date-time that is
4997     valid. Passing that to fromMSecsSinceEpoch() will produce a valid date-time
4998     that isn't faithfully represented by the string parsed.
4999 
5000     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be
5001     greedy. This means that they will use two digits (or three, for z) even if this will
5002     put them outside the range and/or leave too few digits for other
5003     sections.
5004 
5005     \snippet code/src_corelib_time_qdatetime.cpp 13
5006 
5007     This could have meant 1 January 00:30.00 but the M will grab
5008     two digits.
5009 
5010     Incorrectly specified fields of the \a string will cause an invalid
5011     QDateTime to be returned. For example, consider the following code,
5012     where the two digit year 12 is read as 1912 (see the table below for all
5013     field defaults); the resulting datetime is invalid because 23 April 1912
5014     was a Tuesday, not a Monday:
5015 
5016     \snippet code/src_corelib_time_qdatetime.cpp 20
5017 
5018     The correct code is:
5019 
5020     \snippet code/src_corelib_time_qdatetime.cpp 21
5021 
5022     \note Day and month names as well as AM/PM indication must be given in English (C locale).
5023     If localized month and day names and localized forms of AM/PM are used, use
5024     QLocale::system().toDateTime().
5025 
5026     \sa toString(), QDate::fromString(), QTime::fromString(),
5027     QLocale::toDateTime()
5028 */
5029 
5030 /*!
5031     \fn QDateTime QDateTime::fromString(QStringView string, QStringView format, QCalendar cal)
5032     \overload
5033     \since 6.0
5034 */
5035 
5036 /*!
5037     \overload
5038     \since 6.0
5039 */
5040 QDateTime QDateTime::fromString(const QString &string, QStringView format, QCalendar cal)
5041 {
5042 #if QT_CONFIG(datetimeparser)
5043     QDateTime datetime;
5044 
5045     QDateTimeParser dt(QMetaType::QDateTime, QDateTimeParser::FromString, cal);
5046     dt.setDefaultLocale(QLocale::c());
5047     if (dt.parseFormat(format) && (dt.fromString(string, &datetime) || !datetime.isValid()))
5048         return datetime;
5049 #else
5050     Q_UNUSED(string);
5051     Q_UNUSED(format);
5052     Q_UNUSED(cal);
5053 #endif
5054     return QDateTime();
5055 }
5056 
5057 #endif // datestring
5058 /*!
5059     \fn QDateTime QDateTime::toLocalTime() const
5060 
5061     Returns a datetime containing the date and time information in
5062     this datetime, but specified using the Qt::LocalTime definition.
5063 
5064     Example:
5065 
5066     \snippet code/src_corelib_time_qdatetime.cpp 17
5067 
5068     \sa toTimeSpec()
5069 */
5070 
5071 /*!
5072     \fn QDateTime QDateTime::toUTC() const
5073 
5074     Returns a datetime containing the date and time information in
5075     this datetime, but specified using the Qt::UTC definition.
5076 
5077     Example:
5078 
5079     \snippet code/src_corelib_time_qdatetime.cpp 18
5080 
5081     \sa toTimeSpec()
5082 */
5083 
5084 /*****************************************************************************
5085   Date/time stream functions
5086  *****************************************************************************/
5087 
5088 #ifndef QT_NO_DATASTREAM
5089 /*!
5090     \relates QDate
5091 
5092     Writes the \a date to stream \a out.
5093 
5094     \sa {Serializing Qt Data Types}
5095 */
5096 
5097 QDataStream &operator<<(QDataStream &out, QDate date)
5098 {
5099     if (out.version() < QDataStream::Qt_5_0)
5100         return out << quint32(date.jd);
5101     else
5102         return out << qint64(date.jd);
5103 }
5104 
5105 /*!
5106     \relates QDate
5107 
5108     Reads a date from stream \a in into the \a date.
5109 
5110     \sa {Serializing Qt Data Types}
5111 */
5112 
5113 QDataStream &operator>>(QDataStream &in, QDate &date)
5114 {
5115     if (in.version() < QDataStream::Qt_5_0) {
5116         quint32 jd;
5117         in >> jd;
5118         // Older versions consider 0 an invalid jd.
5119         date.jd = (jd != 0 ? jd : QDate::nullJd());
5120     } else {
5121         qint64 jd;
5122         in >> jd;
5123         date.jd = jd;
5124     }
5125 
5126     return in;
5127 }
5128 
5129 /*!
5130     \relates QTime
5131 
5132     Writes \a time to stream \a out.
5133 
5134     \sa {Serializing Qt Data Types}
5135 */
5136 
5137 QDataStream &operator<<(QDataStream &out, QTime time)
5138 {
5139     if (out.version() >= QDataStream::Qt_4_0) {
5140         return out << quint32(time.mds);
5141     } else {
5142         // Qt3 had no support for reading -1, QTime() was valid and serialized as 0
5143         return out << quint32(time.isNull() ? 0 : time.mds);
5144     }
5145 }
5146 
5147 /*!
5148     \relates QTime
5149 
5150     Reads a time from stream \a in into the given \a time.
5151 
5152     \sa {Serializing Qt Data Types}
5153 */
5154 
5155 QDataStream &operator>>(QDataStream &in, QTime &time)
5156 {
5157     quint32 ds;
5158     in >> ds;
5159     if (in.version() >= QDataStream::Qt_4_0) {
5160         time.mds = int(ds);
5161     } else {
5162         // Qt3 would write 0 for a null time
5163         time.mds = (ds == 0) ? QTime::NullTime : int(ds);
5164     }
5165     return in;
5166 }
5167 
5168 /*!
5169     \relates QDateTime
5170 
5171     Writes \a dateTime to the \a out stream.
5172 
5173     \sa {Serializing Qt Data Types}
5174 */
5175 QDataStream &operator<<(QDataStream &out, const QDateTime &dateTime)
5176 {
5177     QPair<QDate, QTime> dateAndTime;
5178 
5179     if (out.version() >= QDataStream::Qt_5_2) {
5180 
5181         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5182         dateAndTime = getDateTime(dateTime.d);
5183         out << dateAndTime << qint8(dateTime.timeSpec());
5184         if (dateTime.timeSpec() == Qt::OffsetFromUTC)
5185             out << qint32(dateTime.offsetFromUtc());
5186 #if QT_CONFIG(timezone)
5187         else if (dateTime.timeSpec() == Qt::TimeZone)
5188             out << dateTime.timeZone();
5189 #endif // timezone
5190 
5191     } else if (out.version() == QDataStream::Qt_5_0) {
5192 
5193         // In Qt 5.0 we incorrectly serialised all datetimes as UTC.
5194         // This approach is wrong and should not be used again; it breaks
5195         // the guarantee that a deserialised local datetime is the same time
5196         // of day, regardless of which timezone it was serialised in.
5197         dateAndTime = getDateTime((dateTime.isValid() ? dateTime.toUTC() : dateTime).d);
5198         out << dateAndTime << qint8(dateTime.timeSpec());
5199 
5200     } else if (out.version() >= QDataStream::Qt_4_0) {
5201 
5202         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5203         dateAndTime = getDateTime(dateTime.d);
5204         out << dateAndTime;
5205         switch (dateTime.timeSpec()) {
5206         case Qt::UTC:
5207             out << (qint8)QDateTimePrivate::UTC;
5208             break;
5209         case Qt::OffsetFromUTC:
5210             out << (qint8)QDateTimePrivate::OffsetFromUTC;
5211             break;
5212         case Qt::TimeZone:
5213             out << (qint8)QDateTimePrivate::TimeZone;
5214             break;
5215         case Qt::LocalTime:
5216             out << (qint8)QDateTimePrivate::LocalUnknown;
5217             break;
5218         }
5219 
5220     } else { // version < QDataStream::Qt_4_0
5221 
5222         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5223         dateAndTime = getDateTime(dateTime.d);
5224         out << dateAndTime;
5225 
5226     }
5227 
5228     return out;
5229 }
5230 
5231 /*!
5232     \relates QDateTime
5233 
5234     Reads a datetime from the stream \a in into \a dateTime.
5235 
5236     \sa {Serializing Qt Data Types}
5237 */
5238 
5239 QDataStream &operator>>(QDataStream &in, QDateTime &dateTime)
5240 {
5241     QDate dt;
5242     QTime tm;
5243     qint8 ts = 0;
5244     Qt::TimeSpec spec = Qt::LocalTime;
5245     qint32 offset = 0;
5246 #if QT_CONFIG(timezone)
5247     QTimeZone tz;
5248 #endif // timezone
5249 
5250     if (in.version() >= QDataStream::Qt_5_2) {
5251 
5252         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5253         in >> dt >> tm >> ts;
5254         spec = static_cast<Qt::TimeSpec>(ts);
5255         if (spec == Qt::OffsetFromUTC) {
5256             in >> offset;
5257             dateTime = QDateTime(dt, tm, spec, offset);
5258 #if QT_CONFIG(timezone)
5259         } else if (spec == Qt::TimeZone) {
5260             in >> tz;
5261             dateTime = QDateTime(dt, tm, tz);
5262 #endif // timezone
5263         } else {
5264             dateTime = QDateTime(dt, tm, spec);
5265         }
5266 
5267     } else if (in.version() == QDataStream::Qt_5_0) {
5268 
5269         // In Qt 5.0 we incorrectly serialised all datetimes as UTC
5270         in >> dt >> tm >> ts;
5271         spec = static_cast<Qt::TimeSpec>(ts);
5272         dateTime = QDateTime(dt, tm, Qt::UTC);
5273         dateTime = dateTime.toTimeSpec(spec);
5274 
5275     } else if (in.version() >= QDataStream::Qt_4_0) {
5276 
5277         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5278         in >> dt >> tm >> ts;
5279         switch ((QDateTimePrivate::Spec)ts) {
5280         case QDateTimePrivate::UTC:
5281             spec = Qt::UTC;
5282             break;
5283         case QDateTimePrivate::OffsetFromUTC:
5284             spec = Qt::OffsetFromUTC;
5285             break;
5286         case QDateTimePrivate::TimeZone:
5287             spec = Qt::TimeZone;
5288 #if QT_CONFIG(timezone)
5289             // FIXME: need to use a different constructor !
5290 #endif
5291             break;
5292         case QDateTimePrivate::LocalUnknown:
5293         case QDateTimePrivate::LocalStandard:
5294         case QDateTimePrivate::LocalDST:
5295             spec = Qt::LocalTime;
5296             break;
5297         }
5298         dateTime = QDateTime(dt, tm, spec, offset);
5299 
5300     } else { // version < QDataStream::Qt_4_0
5301 
5302         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5303         in >> dt >> tm;
5304         dateTime = QDateTime(dt, tm, spec, offset);
5305 
5306     }
5307 
5308     return in;
5309 }
5310 #endif // QT_NO_DATASTREAM
5311 
5312 /*****************************************************************************
5313   Date / Time Debug Streams
5314 *****************************************************************************/
5315 
5316 #if !defined(QT_NO_DEBUG_STREAM) && QT_CONFIG(datestring)
5317 QDebug operator<<(QDebug dbg, QDate date)
5318 {
5319     QDebugStateSaver saver(dbg);
5320     dbg.nospace() << "QDate(";
5321     if (date.isValid())
5322         dbg.nospace() << date.toString(Qt::ISODate);
5323     else
5324         dbg.nospace() << "Invalid";
5325     dbg.nospace() << ')';
5326     return dbg;
5327 }
5328 
5329 QDebug operator<<(QDebug dbg, QTime time)
5330 {
5331     QDebugStateSaver saver(dbg);
5332     dbg.nospace() << "QTime(";
5333     if (time.isValid())
5334         dbg.nospace() << time.toString(u"HH:mm:ss.zzz");
5335     else
5336         dbg.nospace() << "Invalid";
5337     dbg.nospace() << ')';
5338     return dbg;
5339 }
5340 
5341 QDebug operator<<(QDebug dbg, const QDateTime &date)
5342 {
5343     QDebugStateSaver saver(dbg);
5344     dbg.nospace() << "QDateTime(";
5345     if (date.isValid()) {
5346         const Qt::TimeSpec ts = date.timeSpec();
5347         dbg.noquote() << date.toString(u"yyyy-MM-dd HH:mm:ss.zzz t")
5348                       << ' ' << ts;
5349         switch (ts) {
5350         case Qt::UTC:
5351             break;
5352         case Qt::OffsetFromUTC:
5353             dbg.space() << date.offsetFromUtc() << 's';
5354             break;
5355         case Qt::TimeZone:
5356 #if QT_CONFIG(timezone)
5357             dbg.space() << date.timeZone().id();
5358 #endif // timezone
5359             break;
5360         case Qt::LocalTime:
5361             break;
5362         }
5363     } else {
5364         dbg.nospace() << "Invalid";
5365     }
5366     return dbg.nospace() << ')';
5367 }
5368 #endif // debug_stream && datestring
5369 
5370 /*! \fn size_t qHash(const QDateTime &key, size_t seed = 0)
5371     \relates QHash
5372     \since 5.0
5373 
5374     Returns the hash value for the \a key, using \a seed to seed the calculation.
5375 */
5376 size_t qHash(const QDateTime &key, size_t seed)
5377 {
5378     // Use to toMSecsSinceEpoch instead of individual qHash functions for
5379     // QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
5380     // to the same timezone. If we don't, qHash would return different hashes for
5381     // two QDateTimes that are equivalent once converted to the same timezone.
5382     return key.isValid() ? qHash(key.toMSecsSinceEpoch(), seed) : seed;
5383 }
5384 
5385 /*! \fn size_t qHash(QDate key, size_t seed = 0)
5386     \relates QHash
5387     \since 5.0
5388 
5389     Returns the hash value for the \a key, using \a seed to seed the calculation.
5390 */
5391 size_t qHash(QDate key, size_t seed) noexcept
5392 {
5393     return qHash(key.toJulianDay(), seed);
5394 }
5395 
5396 /*! \fn size_t qHash(QTime key, size_t seed = 0)
5397     \relates QHash
5398     \since 5.0
5399 
5400     Returns the hash value for the \a key, using \a seed to seed the calculation.
5401 */
5402 size_t qHash(QTime key, size_t seed) noexcept
5403 {
5404     return qHash(key.msecsSinceStartOfDay(), seed);
5405 }
5406 
5407 QT_END_NAMESPACE
