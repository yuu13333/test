Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "cppquickfixes.h"
27 
28 #include "baseeditordocumentprocessor.h"
29 #include "cppcodestylesettings.h"
30 #include "cppeditorconstants.h"
31 #include "cppeditordocument.h"
32 #include "cppeditorwidget.h"
33 #include "cppfunctiondecldeflink.h"
34 #include "cppinsertvirtualmethods.h"
35 #include "cpplocatorfilter.h"
36 #include "cpppointerdeclarationformatter.h"
37 #include "cppquickfixassistant.h"
38 #include "cppquickfixprojectsettings.h"
39 #include "cpprefactoringchanges.h"
40 #include "cpptoolsreuse.h"
41 #include "cppvirtualfunctionassistprovider.h"
42 #include "includeutils.h"
43 #include "insertionpointlocator.h"
44 #include "symbolfinder.h"
45 
46 #include <coreplugin/icore.h>
47 #include <coreplugin/messagebox.h>
48 
49 #include <cplusplus/ASTPath.h>
50 #include <cplusplus/CPlusPlusForwardDeclarations.h>
51 #include <cplusplus/CppRewriter.h>
52 #include <cplusplus/TypeOfExpression.h>
53 #include <cplusplus/TypePrettyPrinter.h>
54 
55 #include <extensionsystem/pluginmanager.h>
56 
57 #include <projectexplorer/projectnodes.h>
58 #include <projectexplorer/projecttree.h>
59 #include <projectexplorer/session.h>
60 
61 #include <utils/algorithm.h>
62 #include <utils/basetreeview.h>
63 #include <utils/fancylineedit.h>
64 #include <utils/fileutils.h>
65 #include <utils/qtcassert.h>
66 #include <utils/treemodel.h>
67 
68 #ifdef WITH_TESTS
69 #include <QAbstractItemModelTester>
70 #endif
71 #include <QApplication>
72 #include <QCheckBox>
73 #include <QComboBox>
74 #include <QDialog>
75 #include <QDialogButtonBox>
76 #include <QDir>
77 #include <QFileInfo>
78 #include <QFormLayout>
79 #include <QGridLayout>
80 #include <QHash>
81 #include <QHeaderView>
82 #include <QInputDialog>
83 #include <QMimeData>
84 #include <QPair>
85 #include <QProxyStyle>
86 #include <QPushButton>
87 #include <QRegularExpression>
88 #include <QSharedPointer>
89 #include <QStack>
90 #include <QStyledItemDelegate>
91 #include <QTableView>
92 #include <QTextCodec>
93 #include <QTextCursor>
94 #include <QVBoxLayout>
95 
96 #include <bitset>
97 #include <cctype>
98 #include <functional>
99 #include <limits>
100 #include <vector>
101 
102 using namespace CPlusPlus;
103 using namespace TextEditor;
104 using Utils::ChangeSet;
105 
106 namespace CppEditor {
107 
108 static QList<CppQuickFixFactory *> g_cppQuickFixFactories;
109 
110 CppQuickFixFactory::CppQuickFixFactory()
111 {
112     g_cppQuickFixFactories.append(this);
113 }
114 
115 CppQuickFixFactory::~CppQuickFixFactory()
116 {
117     g_cppQuickFixFactories.removeOne(this);
118 }
119 
120 const QList<CppQuickFixFactory *> &CppQuickFixFactory::cppQuickFixFactories()
121 {
122     return g_cppQuickFixFactories;
123 }
124 
125 namespace Internal {
126 
127 QString inlinePrefix(const QString &targetFile, const std::function<bool()> &extraCondition = {})
128 {
129     if (ProjectFile::isHeader(ProjectFile::classify(targetFile))
130             && (!extraCondition || extraCondition())) {
131         return "inline ";
132     }
133     return {};
134 }
135 
136 // In the following anonymous namespace all functions are collected, which could be of interest for
137 // different quick fixes.
138 namespace {
139 
140 enum DefPos {
141     DefPosInsideClass,
142     DefPosOutsideClass,
143     DefPosImplementationFile
144 };
145 
146 
147 inline bool isQtStringLiteral(const QByteArray &id)
148 {
149     return id == "QLatin1String" || id == "QLatin1Literal" || id == "QStringLiteral";
150 }
151 
152 inline bool isQtStringTranslation(const QByteArray &id)
153 {
154     return id == "tr" || id == "trUtf8" || id == "translate" || id == "QT_TRANSLATE_NOOP";
155 }
156 
157 Class *isMemberFunction(const LookupContext &context, Function *function)
158 {
159     QTC_ASSERT(function, return nullptr);
160 
161     Scope *enclosingScope = function->enclosingScope();
162     while (!(enclosingScope->isNamespace() || enclosingScope->isClass()))
163         enclosingScope = enclosingScope->enclosingScope();
164     QTC_ASSERT(enclosingScope != nullptr, return nullptr);
165 
166     const Name *functionName = function->name();
167     if (!functionName)
168         return nullptr;
169 
170     if (!functionName->isQualifiedNameId())
171         return nullptr; // trying to add a declaration for a global function
172 
173     const QualifiedNameId *q = functionName->asQualifiedNameId();
174     if (!q->base())
175         return nullptr;
176 
177     if (ClassOrNamespace *binding = context.lookupType(q->base(), enclosingScope)) {
178         foreach (Symbol *s, binding->symbols()) {
179             if (Class *matchingClass = s->asClass())
180                 return matchingClass;
181         }
182     }
183 
184     return nullptr;
185 }
186 
187 Namespace *isNamespaceFunction(const LookupContext &context, Function *function)
188 {
189     QTC_ASSERT(function, return nullptr);
190     if (isMemberFunction(context, function))
191         return nullptr;
192 
193     Scope *enclosingScope = function->enclosingScope();
194     while (!(enclosingScope->isNamespace() || enclosingScope->isClass()))
195         enclosingScope = enclosingScope->enclosingScope();
196     QTC_ASSERT(enclosingScope != nullptr, return nullptr);
197 
198     const Name *functionName = function->name();
199     if (!functionName)
200         return nullptr;
201 
202     // global namespace
203     if (!functionName->isQualifiedNameId()) {
204         foreach (Symbol *s, context.globalNamespace()->symbols()) {
205             if (Namespace *matchingNamespace = s->asNamespace())
206                 return matchingNamespace;
207         }
208         return nullptr;
209     }
210 
211     const QualifiedNameId *q = functionName->asQualifiedNameId();
212     if (!q->base())
213         return nullptr;
214 
215     if (ClassOrNamespace *binding = context.lookupType(q->base(), enclosingScope)) {
216         foreach (Symbol *s, binding->symbols()) {
217             if (Namespace *matchingNamespace = s->asNamespace())
218                 return matchingNamespace;
219         }
220     }
221 
222     return nullptr;
223 }
224 
225 // Given include is e.g. "afile.h" or <afile.h> (quotes/angle brackets included!).
226 void insertNewIncludeDirective(const QString &include, CppRefactoringFilePtr file,
227                                const Document::Ptr &cppDocument)
228 {
229     // Find optimal position
230     using namespace IncludeUtils;
231     LineForNewIncludeDirective finder(file->document(), cppDocument,
232                                       LineForNewIncludeDirective::IgnoreMocIncludes,
233                                       LineForNewIncludeDirective::AutoDetect);
234     unsigned newLinesToPrepend = 0;
235     unsigned newLinesToAppend = 0;
236     const int insertLine = finder(include, &newLinesToPrepend, &newLinesToAppend);
237     QTC_ASSERT(insertLine >= 1, return);
238     const int insertPosition = file->position(insertLine, 1);
239     QTC_ASSERT(insertPosition >= 0, return);
240 
241     // Construct text to insert
242     const QString includeLine = QLatin1String("#include ") + include + QLatin1Char('\n');
243     QString prependedNewLines, appendedNewLines;
244     while (newLinesToAppend--)
245         appendedNewLines += QLatin1String("\n");
246     while (newLinesToPrepend--)
247         prependedNewLines += QLatin1String("\n");
248     const QString textToInsert = prependedNewLines + includeLine + appendedNewLines;
249 
250     // Insert
251     ChangeSet changes;
252     changes.insert(insertPosition, textToInsert);
253     file->setChangeSet(changes);
254     file->apply();
255 }
256 
257 bool nameIncludesOperatorName(const Name *name)
258 {
259     return name->isOperatorNameId()
260         || (name->isQualifiedNameId() && name->asQualifiedNameId()->name()->isOperatorNameId());
261 }
262 
263 QString memberBaseName(const QString &name)
264 {
265     const auto validName = [](const QString &name) {
266         return !name.isEmpty() && !name.at(0).isDigit();
267     };
268     QString baseName = name;
269 
270     CppQuickFixSettings *settings = CppQuickFixProjectsSettings::getQuickFixSettings(
271         ProjectExplorer::ProjectTree::currentProject());
272     const QString &nameTemplate = settings->memberVariableNameTemplate;
273     const QString prefix = nameTemplate.left(nameTemplate.indexOf('<'));
274     const QString postfix = nameTemplate.mid(nameTemplate.lastIndexOf('>') + 1);
275     if (name.startsWith(prefix) && name.endsWith(postfix)) {
276         const QString base = name.mid(prefix.length(), name.length() - postfix.length());
277         if (validName(base))
278             return base;
279     }
280 
281     // Remove leading and trailing "_"
282     while (baseName.startsWith(QLatin1Char('_')))
283         baseName.remove(0, 1);
284     while (baseName.endsWith(QLatin1Char('_')))
285         baseName.chop(1);
286     if (baseName != name && validName(baseName))
287         return baseName;
288 
289     // If no leading/trailing "_": remove "m_" and "m" prefix
290     if (baseName.startsWith(QLatin1String("m_"))) {
291         baseName.remove(0, 2);
292     } else if (baseName.startsWith(QLatin1Char('m')) && baseName.length() > 1
293                && baseName.at(1).isUpper()) {
294         baseName.remove(0, 1);
295         baseName[0] = baseName.at(0).toLower();
296     }
297 
298     return validName(baseName) ? baseName : name;
299 }
300 
301 // Returns a non-null value if and only if the cursor is on the name of a (proper) class
302 // declaration or at some place inside the body of a class declaration that does not
303 // correspond to an AST of its own, i.e. on "empty space".
304 ClassSpecifierAST *astForClassOperations(const CppQuickFixInterface &interface)
305 {
306     const QList<AST *> &path = interface.path();
307     if (path.isEmpty())
308         return nullptr;
309     if (const auto classSpec = path.last()->asClassSpecifier()) // Cursor inside class decl?
310         return classSpec;
311 
312     // Cursor on a class name?
313     if (path.size() < 2)
314         return nullptr;
315     const SimpleNameAST * const nameAST = path.at(path.size() - 1)->asSimpleName();
316     if (!nameAST || !interface.isCursorOn(nameAST))
317        return nullptr;
318     if (const auto classSpec = path.at(path.size() - 2)->asClassSpecifier())
319         return classSpec;
320     return nullptr;
321 }
322 
323 } // anonymous namespace
324 
325 namespace {
326 
327 class InverseLogicalComparisonOp: public CppQuickFixOperation
328 {
329 public:
330     InverseLogicalComparisonOp(const CppQuickFixInterface &interface,
331                                int priority,
332                                BinaryExpressionAST *binary,
333                                Kind invertToken)
334         : CppQuickFixOperation(interface, priority)
335         , binary(binary)
336     {
337         Token tok;
338         tok.f.kind = invertToken;
339         replacement = QLatin1String(tok.spell());
340 
341         // check for enclosing nested expression
342         if (priority - 1 >= 0)
343             nested = interface.path()[priority - 1]->asNestedExpression();
344 
345         // check for ! before parentheses
346         if (nested && priority - 2 >= 0) {
347             negation = interface.path()[priority - 2]->asUnaryExpression();
348             if (negation && !interface.currentFile()->tokenAt(negation->unary_op_token).is(T_EXCLAIM))
349                 negation = nullptr;
350         }
351     }
352 
353     QString description() const override
354     {
355         return QApplication::translate("CppEditor::QuickFix", "Rewrite Using %1").arg(replacement);
356     }
357 
358     void perform() override
359     {
360         CppRefactoringChanges refactoring(snapshot());
361         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
362 
363         ChangeSet changes;
364         if (negation) {
365             // can't remove parentheses since that might break precedence
366             changes.remove(currentFile->range(negation->unary_op_token));
367         } else if (nested) {
368             changes.insert(currentFile->startOf(nested), QLatin1String("!"));
369         } else {
370             changes.insert(currentFile->startOf(binary), QLatin1String("!("));
371             changes.insert(currentFile->endOf(binary), QLatin1String(")"));
372         }
373         changes.replace(currentFile->range(binary->binary_op_token), replacement);
374         currentFile->setChangeSet(changes);
375         currentFile->apply();
376     }
377 
378 private:
379     BinaryExpressionAST *binary = nullptr;
380     NestedExpressionAST *nested = nullptr;
381     UnaryExpressionAST *negation = nullptr;
382 
383     QString replacement;
384 };
385 
386 } // anonymous namespace
387 
388 void InverseLogicalComparison::match(const CppQuickFixInterface &interface,
389                                      QuickFixOperations &result)
390 {
391     CppRefactoringFilePtr file = interface.currentFile();
392 
393     const QList<AST *> &path = interface.path();
394     if (path.isEmpty())
395         return;
396     int index = path.size() - 1;
397     BinaryExpressionAST *binary = path.at(index)->asBinaryExpression();
398     if (!binary)
399         return;
400     if (!interface.isCursorOn(binary->binary_op_token))
401         return;
402 
403     Kind invertToken;
404     switch (file->tokenAt(binary->binary_op_token).kind()) {
405     case T_LESS_EQUAL:
406         invertToken = T_GREATER;
407         break;
408     case T_LESS:
409         invertToken = T_GREATER_EQUAL;
410         break;
411     case T_GREATER:
412         invertToken = T_LESS_EQUAL;
413         break;
414     case T_GREATER_EQUAL:
415         invertToken = T_LESS;
416         break;
417     case T_EQUAL_EQUAL:
418         invertToken = T_EXCLAIM_EQUAL;
419         break;
420     case T_EXCLAIM_EQUAL:
421         invertToken = T_EQUAL_EQUAL;
422         break;
423     default:
424         return;
425     }
426 
427     result << new InverseLogicalComparisonOp(interface, index, binary, invertToken);
428 }
429 
430 namespace {
431 
432 class FlipLogicalOperandsOp: public CppQuickFixOperation
433 {
434 public:
435     FlipLogicalOperandsOp(const CppQuickFixInterface &interface, int priority,
436                           BinaryExpressionAST *binary, QString replacement)
437         : CppQuickFixOperation(interface)
438         , binary(binary)
439         , replacement(replacement)
440     {
441         setPriority(priority);
442     }
443 
444     QString description() const override
445     {
446         if (replacement.isEmpty())
447             return QApplication::translate("CppEditor::QuickFix", "Swap Operands");
448         else
449             return QApplication::translate("CppEditor::QuickFix", "Rewrite Using %1").arg(replacement);
450     }
451 
452     void perform() override
453     {
454         CppRefactoringChanges refactoring(snapshot());
455         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
456 
457         ChangeSet changes;
458         changes.flip(currentFile->range(binary->left_expression),
459                      currentFile->range(binary->right_expression));
460         if (!replacement.isEmpty())
461             changes.replace(currentFile->range(binary->binary_op_token), replacement);
462 
463         currentFile->setChangeSet(changes);
464         currentFile->apply();
465     }
466 
467 private:
468     BinaryExpressionAST *binary;
469     QString replacement;
470 };
471 
472 } // anonymous namespace
473 
474 void FlipLogicalOperands::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
475 {
476     const QList<AST *> &path = interface.path();
477     if (path.isEmpty())
478         return;
479     CppRefactoringFilePtr file = interface.currentFile();
480 
481     int index = path.size() - 1;
482     BinaryExpressionAST *binary = path.at(index)->asBinaryExpression();
483     if (!binary)
484         return;
485     if (!interface.isCursorOn(binary->binary_op_token))
486         return;
487 
488     Kind flipToken;
489     switch (file->tokenAt(binary->binary_op_token).kind()) {
490     case T_LESS_EQUAL:
491         flipToken = T_GREATER_EQUAL;
492         break;
493     case T_LESS:
494         flipToken = T_GREATER;
495         break;
496     case T_GREATER:
497         flipToken = T_LESS;
498         break;
499     case T_GREATER_EQUAL:
500         flipToken = T_LESS_EQUAL;
501         break;
502     case T_EQUAL_EQUAL:
503     case T_EXCLAIM_EQUAL:
504     case T_AMPER_AMPER:
505     case T_PIPE_PIPE:
506         flipToken = T_EOF_SYMBOL;
507         break;
508     default:
509         return;
510     }
511 
512     QString replacement;
513     if (flipToken != T_EOF_SYMBOL) {
514         Token tok;
515         tok.f.kind = flipToken;
516         replacement = QLatin1String(tok.spell());
517     }
518 
519     result << new FlipLogicalOperandsOp(interface, index, binary, replacement);
520 }
521 
522 namespace {
523 
524 class RewriteLogicalAndOp: public CppQuickFixOperation
525 {
526 public:
527     QSharedPointer<ASTPatternBuilder> mk;
528     UnaryExpressionAST *left;
529     UnaryExpressionAST *right;
530     BinaryExpressionAST *pattern;
531 
532     RewriteLogicalAndOp(const CppQuickFixInterface &interface)
533         : CppQuickFixOperation(interface)
534         , mk(new ASTPatternBuilder)
535     {
536         left = mk->UnaryExpression();
537         right = mk->UnaryExpression();
538         pattern = mk->BinaryExpression(left, right);
539     }
540 
541     void perform() override
542     {
543         CppRefactoringChanges refactoring(snapshot());
544         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
545 
546         ChangeSet changes;
547         changes.replace(currentFile->range(pattern->binary_op_token), QLatin1String("||"));
548         changes.remove(currentFile->range(left->unary_op_token));
549         changes.remove(currentFile->range(right->unary_op_token));
550         const int start = currentFile->startOf(pattern);
551         const int end = currentFile->endOf(pattern);
552         changes.insert(start, QLatin1String("!("));
553         changes.insert(end, QLatin1String(")"));
554 
555         currentFile->setChangeSet(changes);
556         currentFile->appendIndentRange(currentFile->range(pattern));
557         currentFile->apply();
558     }
559 };
560 
561 } // anonymous namespace
562 
563 void RewriteLogicalAnd::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
564 {
565     BinaryExpressionAST *expression = nullptr;
566     const QList<AST *> &path = interface.path();
567     CppRefactoringFilePtr file = interface.currentFile();
568 
569     int index = path.size() - 1;
570     for (; index != -1; --index) {
571         expression = path.at(index)->asBinaryExpression();
572         if (expression)
573             break;
574     }
575 
576     if (!expression)
577         return;
578 
579     if (!interface.isCursorOn(expression->binary_op_token))
580         return;
581 
582     QSharedPointer<RewriteLogicalAndOp> op(new RewriteLogicalAndOp(interface));
583 
584     ASTMatcher matcher;
585 
586     if (expression->match(op->pattern, &matcher) &&
587             file->tokenAt(op->pattern->binary_op_token).is(T_AMPER_AMPER) &&
588             file->tokenAt(op->left->unary_op_token).is(T_EXCLAIM) &&
589             file->tokenAt(op->right->unary_op_token).is(T_EXCLAIM)) {
590         op->setDescription(QApplication::translate("CppEditor::QuickFix",
591                                                    "Rewrite Condition Using ||"));
592         op->setPriority(index);
593         result.append(op);
594     }
595 }
596 
597 static bool checkDeclarationForSplit(SimpleDeclarationAST *declaration)
598 {
599     if (!declaration->semicolon_token)
600         return false;
601 
602     if (!declaration->decl_specifier_list)
603         return false;
604 
605     for (SpecifierListAST *it = declaration->decl_specifier_list; it; it = it->next) {
606         SpecifierAST *specifier = it->value;
607         if (specifier->asEnumSpecifier() || specifier->asClassSpecifier())
608             return false;
609     }
610 
611     return declaration->declarator_list && declaration->declarator_list->next;
612 }
613 
614 namespace {
615 
616 class SplitSimpleDeclarationOp: public CppQuickFixOperation
617 {
618 public:
619     SplitSimpleDeclarationOp(const CppQuickFixInterface &interface, int priority,
620                              SimpleDeclarationAST *decl)
621         : CppQuickFixOperation(interface, priority)
622         , declaration(decl)
623     {
624         setDescription(QApplication::translate("CppEditor::QuickFix",
625                                                "Split Declaration"));
626     }
627 
628     void perform() override
629     {
630         CppRefactoringChanges refactoring(snapshot());
631         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
632 
633         ChangeSet changes;
634 
635         SpecifierListAST *specifiers = declaration->decl_specifier_list;
636         int declSpecifiersStart = currentFile->startOf(specifiers->firstToken());
637         int declSpecifiersEnd = currentFile->endOf(specifiers->lastToken() - 1);
638         int insertPos = currentFile->endOf(declaration->semicolon_token);
639 
640         DeclaratorAST *prevDeclarator = declaration->declarator_list->value;
641 
642         for (DeclaratorListAST *it = declaration->declarator_list->next; it; it = it->next) {
643             DeclaratorAST *declarator = it->value;
644 
645             changes.insert(insertPos, QLatin1String("\n"));
646             changes.copy(declSpecifiersStart, declSpecifiersEnd, insertPos);
647             changes.insert(insertPos, QLatin1String(" "));
648             changes.move(currentFile->range(declarator), insertPos);
649             changes.insert(insertPos, QLatin1String(";"));
650 
651             const int prevDeclEnd = currentFile->endOf(prevDeclarator);
652             changes.remove(prevDeclEnd, currentFile->startOf(declarator));
653 
654             prevDeclarator = declarator;
655         }
656 
657         currentFile->setChangeSet(changes);
658         currentFile->appendIndentRange(currentFile->range(declaration));
659         currentFile->apply();
660     }
661 
662 private:
663     SimpleDeclarationAST *declaration;
664 };
665 
666 } // anonymous namespace
667 
668 void SplitSimpleDeclaration::match(const CppQuickFixInterface &interface,
669                                    QuickFixOperations &result)
670 {
671     CoreDeclaratorAST *core_declarator = nullptr;
672     const QList<AST *> &path = interface.path();
673     CppRefactoringFilePtr file = interface.currentFile();
674     const int cursorPosition = file->cursor().selectionStart();
675 
676     for (int index = path.size() - 1; index != -1; --index) {
677         AST *node = path.at(index);
678 
679         if (CoreDeclaratorAST *coreDecl = node->asCoreDeclarator()) {
680             core_declarator = coreDecl;
681         } else if (SimpleDeclarationAST *simpleDecl = node->asSimpleDeclaration()) {
682             if (checkDeclarationForSplit(simpleDecl)) {
683                 SimpleDeclarationAST *declaration = simpleDecl;
684 
685                 const int startOfDeclSpecifier = file->startOf(declaration->decl_specifier_list->firstToken());
686                 const int endOfDeclSpecifier = file->endOf(declaration->decl_specifier_list->lastToken() - 1);
687 
688                 if (cursorPosition >= startOfDeclSpecifier && cursorPosition <= endOfDeclSpecifier) {
689                     // the AST node under cursor is a specifier.
690                     result << new SplitSimpleDeclarationOp(interface, index, declaration);
691                     return;
692                 }
693 
694                 if (core_declarator && interface.isCursorOn(core_declarator)) {
695                     // got a core-declarator under the text cursor.
696                     result << new SplitSimpleDeclarationOp(interface, index, declaration);
697                     return;
698                 }
699             }
700 
701             return;
702         }
703     }
704 }
705 
706 namespace {
707 
708 class AddBracesToIfOp: public CppQuickFixOperation
709 {
710 public:
711     AddBracesToIfOp(const CppQuickFixInterface &interface, int priority,
712                     const IfStatementAST *statement)
713         : CppQuickFixOperation(interface, priority)
714         , _statement(statement)
715     {
716         setDescription(QApplication::translate("CppEditor::QuickFix", "Add Curly Braces"));
717     }
718 
719     void perform() override
720     {
721         CppRefactoringChanges refactoring(snapshot());
722         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
723 
724         ChangeSet changes;
725 
726         const int start = currentFile->endOf(_statement->rparen_token);
727         changes.insert(start, QLatin1String(" {"));
728 
729         const int end = currentFile->endOf(_statement->statement->lastToken() - 1);
730         changes.insert(end, QLatin1String("\n}"));
731 
732         currentFile->setChangeSet(changes);
733         currentFile->appendIndentRange(ChangeSet::Range(start, end));
734         currentFile->apply();
735     }
736 
737 private:
738     const IfStatementAST * const _statement;
739 };
740 
741 } // anonymous namespace
742 
743 void AddBracesToIf::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
744 {
745     const QList<AST *> &path = interface.path();
746     if (path.isEmpty())
747         return;
748 
749     // show when we're on the 'if' of an if statement
750     int index = path.size() - 1;
751     IfStatementAST *ifStatement = path.at(index)->asIfStatement();
752     if (ifStatement && interface.isCursorOn(ifStatement->if_token) && ifStatement->statement
753         && !ifStatement->statement->asCompoundStatement()) {
754         result << new AddBracesToIfOp(interface, index, ifStatement);
755         return;
756     }
757 
758     // or if we're on the statement contained in the if
759     // ### This may not be such a good idea, consider nested ifs...
760     for (; index != -1; --index) {
761         IfStatementAST *ifStatement = path.at(index)->asIfStatement();
762         if (ifStatement && ifStatement->statement
763             && interface.isCursorOn(ifStatement->statement)
764             && !ifStatement->statement->asCompoundStatement()) {
765             result << new AddBracesToIfOp(interface, index, ifStatement);
766             return;
767         }
768     }
769 
770     // ### This could very well be extended to the else branch
771     // and other nodes entirely.
772 }
773 
774 namespace {
775 
776 class MoveDeclarationOutOfIfOp: public CppQuickFixOperation
777 {
778 public:
779     MoveDeclarationOutOfIfOp(const CppQuickFixInterface &interface)
780         : CppQuickFixOperation(interface)
781     {
782         setDescription(QApplication::translate("CppEditor::QuickFix",
783                                                "Move Declaration out of Condition"));
784 
785         reset();
786     }
787 
788     void reset()
789     {
790         condition = mk.Condition();
791         pattern = mk.IfStatement(condition);
792     }
793 
794     void perform() override
795     {
796         CppRefactoringChanges refactoring(snapshot());
797         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
798 
799         ChangeSet changes;
800 
801         changes.copy(currentFile->range(core), currentFile->startOf(condition));
802 
803         int insertPos = currentFile->startOf(pattern);
804         changes.move(currentFile->range(condition), insertPos);
805         changes.insert(insertPos, QLatin1String(";\n"));
806 
807         currentFile->setChangeSet(changes);
808         currentFile->appendIndentRange(currentFile->range(pattern));
809         currentFile->apply();
810     }
811 
812     ASTMatcher matcher;
813     ASTPatternBuilder mk;
814     ConditionAST *condition = nullptr;
815     IfStatementAST *pattern = nullptr;
816     CoreDeclaratorAST *core = nullptr;
817 };
818 
819 } // anonymous namespace
820 
821 void MoveDeclarationOutOfIf::match(const CppQuickFixInterface &interface,
822                                    QuickFixOperations &result)
823 {
824     const QList<AST *> &path = interface.path();
825     using Ptr = QSharedPointer<MoveDeclarationOutOfIfOp>;
826     Ptr op(new MoveDeclarationOutOfIfOp(interface));
827 
828     int index = path.size() - 1;
829     for (; index != -1; --index) {
830         if (IfStatementAST *statement = path.at(index)->asIfStatement()) {
831             if (statement->match(op->pattern, &op->matcher) && op->condition->declarator) {
832                 DeclaratorAST *declarator = op->condition->declarator;
833                 op->core = declarator->core_declarator;
834                 if (!op->core)
835                     return;
836 
837                 if (interface.isCursorOn(op->core)) {
838                     op->setPriority(index);
839                     result.append(op);
840                     return;
841                 }
842 
843                 op->reset();
844             }
845         }
846     }
847 }
848 
849 namespace {
850 
851 class MoveDeclarationOutOfWhileOp: public CppQuickFixOperation
852 {
853 public:
854     MoveDeclarationOutOfWhileOp(const CppQuickFixInterface &interface)
855         : CppQuickFixOperation(interface)
856     {
857         setDescription(QApplication::translate("CppEditor::QuickFix",
858                                                "Move Declaration out of Condition"));
859         reset();
860     }
861 
862     void reset()
863     {
864         condition = mk.Condition();
865         pattern = mk.WhileStatement(condition);
866     }
867 
868     void perform() override
869     {
870         CppRefactoringChanges refactoring(snapshot());
871         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
872 
873         ChangeSet changes;
874 
875         changes.insert(currentFile->startOf(condition), QLatin1String("("));
876         changes.insert(currentFile->endOf(condition), QLatin1String(") != 0"));
877 
878         int insertPos = currentFile->startOf(pattern);
879         const int conditionStart = currentFile->startOf(condition);
880         changes.move(conditionStart, currentFile->startOf(core), insertPos);
881         changes.copy(currentFile->range(core), insertPos);
882         changes.insert(insertPos, QLatin1String(";\n"));
883 
884         currentFile->setChangeSet(changes);
885         currentFile->appendIndentRange(currentFile->range(pattern));
886         currentFile->apply();
887     }
888 
889     ASTMatcher matcher;
890     ASTPatternBuilder mk;
891     ConditionAST *condition = nullptr;
892     WhileStatementAST *pattern = nullptr;
893     CoreDeclaratorAST *core = nullptr;
894 };
895 
896 } // anonymous namespace
897 
898 void MoveDeclarationOutOfWhile::match(const CppQuickFixInterface &interface,
899                                       QuickFixOperations &result)
900 {
901     const QList<AST *> &path = interface.path();
902     QSharedPointer<MoveDeclarationOutOfWhileOp> op(new MoveDeclarationOutOfWhileOp(interface));
903 
904     int index = path.size() - 1;
905     for (; index != -1; --index) {
906         if (WhileStatementAST *statement = path.at(index)->asWhileStatement()) {
907             if (statement->match(op->pattern, &op->matcher) && op->condition->declarator) {
908                 DeclaratorAST *declarator = op->condition->declarator;
909                 op->core = declarator->core_declarator;
910 
911                 if (!op->core)
912                     return;
913 
914                 if (!declarator->equal_token)
915                     return;
916 
917                 if (!declarator->initializer)
918                     return;
919 
920                 if (interface.isCursorOn(op->core)) {
921                     op->setPriority(index);
922                     result.append(op);
923                     return;
924                 }
925 
926                 op->reset();
927             }
928         }
929     }
930 }
931 
932 namespace {
933 
934 class SplitIfStatementOp: public CppQuickFixOperation
935 {
936 public:
937     SplitIfStatementOp(const CppQuickFixInterface &interface, int priority,
938                        IfStatementAST *pattern, BinaryExpressionAST *condition)
939         : CppQuickFixOperation(interface, priority)
940         , pattern(pattern)
941         , condition(condition)
942     {
943         setDescription(QApplication::translate("CppEditor::QuickFix",
944                                                "Split if Statement"));
945     }
946 
947     void perform() override
948     {
949         CppRefactoringChanges refactoring(snapshot());
950         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
951 
952         const Token binaryToken = currentFile->tokenAt(condition->binary_op_token);
953 
954         if (binaryToken.is(T_AMPER_AMPER))
955             splitAndCondition(currentFile);
956         else
957             splitOrCondition(currentFile);
958     }
959 
960     void splitAndCondition(CppRefactoringFilePtr currentFile) const
961     {
962         ChangeSet changes;
963 
964         int startPos = currentFile->startOf(pattern);
965         changes.insert(startPos, QLatin1String("if ("));
966         changes.move(currentFile->range(condition->left_expression), startPos);
967         changes.insert(startPos, QLatin1String(") {\n"));
968 
969         const int lExprEnd = currentFile->endOf(condition->left_expression);
970         changes.remove(lExprEnd, currentFile->startOf(condition->right_expression));
971         changes.insert(currentFile->endOf(pattern), QLatin1String("\n}"));
972 
973         currentFile->setChangeSet(changes);
974         currentFile->appendIndentRange(currentFile->range(pattern));
975         currentFile->apply();
976     }
977 
978     void splitOrCondition(CppRefactoringFilePtr currentFile) const
979     {
980         ChangeSet changes;
981 
982         StatementAST *ifTrueStatement = pattern->statement;
983         CompoundStatementAST *compoundStatement = ifTrueStatement->asCompoundStatement();
984 
985         int insertPos = currentFile->endOf(ifTrueStatement);
986         if (compoundStatement)
987             changes.insert(insertPos, QLatin1String(" "));
988         else
989             changes.insert(insertPos, QLatin1String("\n"));
990         changes.insert(insertPos, QLatin1String("else if ("));
991 
992         const int rExprStart = currentFile->startOf(condition->right_expression);
993         changes.move(rExprStart, currentFile->startOf(pattern->rparen_token), insertPos);
994         changes.insert(insertPos, QLatin1String(")"));
995 
996         const int rParenEnd = currentFile->endOf(pattern->rparen_token);
997         changes.copy(rParenEnd, currentFile->endOf(pattern->statement), insertPos);
998 
999         const int lExprEnd = currentFile->endOf(condition->left_expression);
1000         changes.remove(lExprEnd, currentFile->startOf(condition->right_expression));
1001 
1002         currentFile->setChangeSet(changes);
1003         currentFile->appendIndentRange(currentFile->range(pattern));
1004         currentFile->apply();
1005     }
1006 
1007 private:
1008     IfStatementAST *pattern;
1009     BinaryExpressionAST *condition;
1010 };
1011 
1012 } // anonymous namespace
1013 
1014 void SplitIfStatement::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
1015 {
1016     IfStatementAST *pattern = nullptr;
1017     const QList<AST *> &path = interface.path();
1018 
1019     int index = path.size() - 1;
1020     for (; index != -1; --index) {
1021         AST *node = path.at(index);
1022         if (IfStatementAST *stmt = node->asIfStatement()) {
1023             pattern = stmt;
1024             break;
1025         }
1026     }
1027 
1028     if (!pattern || !pattern->statement)
1029         return;
1030 
1031     unsigned splitKind = 0;
1032     for (++index; index < path.size(); ++index) {
1033         AST *node = path.at(index);
1034         BinaryExpressionAST *condition = node->asBinaryExpression();
1035         if (!condition)
1036             return;
1037 
1038         Token binaryToken = interface.currentFile()->tokenAt(condition->binary_op_token);
1039 
1040         // only accept a chain of ||s or &&s - no mixing
1041         if (!splitKind) {
1042             splitKind = binaryToken.kind();
1043             if (splitKind != T_AMPER_AMPER && splitKind != T_PIPE_PIPE)
1044                 return;
1045             // we can't reliably split &&s in ifs with an else branch
1046             if (splitKind == T_AMPER_AMPER && pattern->else_statement)
1047                 return;
1048         } else if (splitKind != binaryToken.kind()) {
1049             return;
1050         }
1051 
1052         if (interface.isCursorOn(condition->binary_op_token)) {
1053             result << new SplitIfStatementOp(interface, index, pattern, condition);
1054             return;
1055         }
1056     }
1057 }
1058 
1059 /* Analze a string/character literal like "x", QLatin1String("x") and return the literal
1060  * (StringLiteral or NumericLiteral for characters) and its type
1061  * and the enclosing function (QLatin1String, tr...) */
1062 
1063 enum StringLiteralType { TypeString, TypeObjCString, TypeChar, TypeNone };
1064 
1065 enum ActionFlags {
1066     EncloseInQLatin1CharAction = 0x1,
1067     EncloseInQLatin1StringAction = 0x2,
1068     EncloseInQStringLiteralAction = 0x4,
1069     EncloseActionMask = EncloseInQLatin1CharAction
1070     | EncloseInQLatin1StringAction | EncloseInQStringLiteralAction,
1071     TranslateTrAction = 0x8,
1072     TranslateQCoreApplicationAction = 0x10,
1073     TranslateNoopAction = 0x20,
1074     TranslationMask = TranslateTrAction
1075     | TranslateQCoreApplicationAction | TranslateNoopAction,
1076     RemoveObjectiveCAction = 0x40,
1077     ConvertEscapeSequencesToCharAction = 0x100,
1078     ConvertEscapeSequencesToStringAction = 0x200,
1079     SingleQuoteAction = 0x400,
1080     DoubleQuoteAction = 0x800
1081 };
1082 
1083 
1084 /* Convert single-character string literals into character literals with some
1085  * special cases "a" --> 'a', "'" --> '\'', "\n" --> '\n', "\"" --> '"'. */
1086 static QByteArray stringToCharEscapeSequences(const QByteArray &content)
1087 {
1088     if (content.size() == 1)
1089         return content.at(0) == '\'' ? QByteArray("\\'") : content;
1090     if (content.size() == 2 && content.at(0) == '\\')
1091         return content == "\\\"" ? QByteArray(1, '"') : content;
1092     return QByteArray();
1093 }
1094 
1095 /* Convert character literal into a string literal with some special cases
1096  * 'a' -> "a", '\n' -> "\n", '\'' --> "'", '"' --> "\"". */
1097 static QByteArray charToStringEscapeSequences(const QByteArray &content)
1098 {
1099     if (content.size() == 1)
1100         return content.at(0) == '"' ? QByteArray("\\\"") : content;
1101     if (content.size() == 2)
1102         return content == "\\'" ? QByteArray("'") : content;
1103     return QByteArray();
1104 }
1105 
1106 static QString msgQtStringLiteralDescription(const QString &replacement)
1107 {
1108     return QApplication::translate("CppEditor::QuickFix", "Enclose in %1(...)").arg(replacement);
1109 }
1110 
1111 static QString stringLiteralReplacement(unsigned actions)
1112 {
1113     if (actions & EncloseInQLatin1CharAction)
1114         return QLatin1String("QLatin1Char");
1115     if (actions & EncloseInQLatin1StringAction)
1116         return QLatin1String("QLatin1String");
1117     if (actions & EncloseInQStringLiteralAction)
1118         return QLatin1String("QStringLiteral");
1119     if (actions & TranslateTrAction)
1120         return QLatin1String("tr");
1121     if (actions & TranslateQCoreApplicationAction)
1122         return QLatin1String("QCoreApplication::translate");
1123     if (actions & TranslateNoopAction)
1124         return QLatin1String("QT_TRANSLATE_NOOP");
1125     return QString();
1126 }
1127 
1128 static ExpressionAST *analyzeStringLiteral(const QList<AST *> &path,
1129                                            const CppRefactoringFilePtr &file, StringLiteralType *type,
1130                                            QByteArray *enclosingFunction = nullptr,
1131                                            CallAST **enclosingFunctionCall = nullptr)
1132 {
1133     *type = TypeNone;
1134     if (enclosingFunction)
1135         enclosingFunction->clear();
1136     if (enclosingFunctionCall)
1137         *enclosingFunctionCall = nullptr;
1138 
1139     if (path.isEmpty())
1140         return nullptr;
1141 
1142     ExpressionAST *literal = path.last()->asExpression();
1143     if (literal) {
1144         if (literal->asStringLiteral()) {
1145             // Check for Objective C string (@"bla")
1146             const QChar firstChar = file->charAt(file->startOf(literal));
1147             *type = firstChar == QLatin1Char('@') ? TypeObjCString : TypeString;
1148         } else if (NumericLiteralAST *numericLiteral = literal->asNumericLiteral()) {
1149             // character ('c') constants are numeric.
1150             if (file->tokenAt(numericLiteral->literal_token).is(T_CHAR_LITERAL))
1151                 *type = TypeChar;
1152         }
1153     }
1154 
1155     if (*type != TypeNone && enclosingFunction && path.size() > 1) {
1156         if (CallAST *call = path.at(path.size() - 2)->asCall()) {
1157             if (call->base_expression) {
1158                 if (IdExpressionAST *idExpr = call->base_expression->asIdExpression()) {
1159                     if (SimpleNameAST *functionName = idExpr->name->asSimpleName()) {
1160                         *enclosingFunction = file->tokenAt(functionName->identifier_token).identifier->chars();
1161                         if (enclosingFunctionCall)
1162                             *enclosingFunctionCall = call;
1163                     }
1164                 }
1165             }
1166         }
1167     }
1168     return literal;
1169 }
1170 
1171 namespace {
1172 
1173 /// Operation performs the operations of type ActionFlags passed in as actions.
1174 class WrapStringLiteralOp : public CppQuickFixOperation
1175 {
1176 public:
1177     WrapStringLiteralOp(const CppQuickFixInterface &interface, int priority,
1178                         unsigned actions, const QString &description, ExpressionAST *literal,
1179                         const QString &translationContext = QString())
1180         : CppQuickFixOperation(interface, priority), m_actions(actions), m_literal(literal),
1181           m_translationContext(translationContext)
1182     {
1183         setDescription(description);
1184     }
1185 
1186     void perform() override
1187     {
1188         CppRefactoringChanges refactoring(snapshot());
1189         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
1190 
1191         ChangeSet changes;
1192 
1193         const int startPos = currentFile->startOf(m_literal);
1194         const int endPos = currentFile->endOf(m_literal);
1195 
1196         // kill leading '@'. No need to adapt endPos, that is done by ChangeSet
1197         if (m_actions & RemoveObjectiveCAction)
1198             changes.remove(startPos, startPos + 1);
1199 
1200         // Fix quotes
1201         if (m_actions & (SingleQuoteAction | DoubleQuoteAction)) {
1202             const QString newQuote((m_actions & SingleQuoteAction)
1203                                    ? QLatin1Char('\'') : QLatin1Char('"'));
1204             changes.replace(startPos, startPos + 1, newQuote);
1205             changes.replace(endPos - 1, endPos, newQuote);
1206         }
1207 
1208         // Convert single character strings into character constants
1209         if (m_actions & ConvertEscapeSequencesToCharAction) {
1210             StringLiteralAST *stringLiteral = m_literal->asStringLiteral();
1211             QTC_ASSERT(stringLiteral, return ;);
1212             const QByteArray oldContents(currentFile->tokenAt(stringLiteral->literal_token).identifier->chars());
1213             const QByteArray newContents = stringToCharEscapeSequences(oldContents);
1214             QTC_ASSERT(!newContents.isEmpty(), return ;);
1215             if (oldContents != newContents)
1216                 changes.replace(startPos + 1, endPos -1, QString::fromLatin1(newContents));
1217         }
1218 
1219         // Convert character constants into strings constants
1220         if (m_actions & ConvertEscapeSequencesToStringAction) {
1221             NumericLiteralAST *charLiteral = m_literal->asNumericLiteral(); // char 'c' constants are numerical.
1222             QTC_ASSERT(charLiteral, return ;);
1223             const QByteArray oldContents(currentFile->tokenAt(charLiteral->literal_token).identifier->chars());
1224             const QByteArray newContents = charToStringEscapeSequences(oldContents);
1225             QTC_ASSERT(!newContents.isEmpty(), return ;);
1226             if (oldContents != newContents)
1227                 changes.replace(startPos + 1, endPos -1, QString::fromLatin1(newContents));
1228         }
1229 
1230         // Enclose in literal or translation function, macro.
1231         if (m_actions & (EncloseActionMask | TranslationMask)) {
1232             changes.insert(endPos, QString(QLatin1Char(')')));
1233             QString leading = stringLiteralReplacement(m_actions);
1234             leading += QLatin1Char('(');
1235             if (m_actions
1236                     & (TranslateQCoreApplicationAction | TranslateNoopAction)) {
1237                 leading += QLatin1Char('"');
1238                 leading += m_translationContext;
1239                 leading += QLatin1String("\", ");
1240             }
1241             changes.insert(startPos, leading);
1242         }
1243 
1244         currentFile->setChangeSet(changes);
1245         currentFile->apply();
1246     }
1247 
1248 private:
1249     const unsigned m_actions;
1250     ExpressionAST *m_literal;
1251     const QString m_translationContext;
1252 };
1253 
1254 } // anonymous namespace
1255 
1256 void WrapStringLiteral::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
1257 {
1258     StringLiteralType type = TypeNone;
1259     QByteArray enclosingFunction;
1260     const QList<AST *> &path = interface.path();
1261     CppRefactoringFilePtr file = interface.currentFile();
1262     ExpressionAST *literal = analyzeStringLiteral(path, file, &type, &enclosingFunction);
1263     if (!literal || type == TypeNone)
1264         return;
1265     if ((type == TypeChar && enclosingFunction == "QLatin1Char")
1266         || isQtStringLiteral(enclosingFunction)
1267         || isQtStringTranslation(enclosingFunction))
1268         return;
1269 
1270     const int priority = path.size() - 1; // very high priority
1271     if (type == TypeChar) {
1272         unsigned actions = EncloseInQLatin1CharAction;
1273         QString description = msgQtStringLiteralDescription(stringLiteralReplacement(actions));
1274         result << new WrapStringLiteralOp(interface, priority, actions, description, literal);
1275         if (NumericLiteralAST *charLiteral = literal->asNumericLiteral()) {
1276             const QByteArray contents(file->tokenAt(charLiteral->literal_token).identifier->chars());
1277             if (!charToStringEscapeSequences(contents).isEmpty()) {
1278                 actions = DoubleQuoteAction | ConvertEscapeSequencesToStringAction;
1279                 description = QApplication::translate("CppEditor::QuickFix",
1280                               "Convert to String Literal");
1281                 result << new WrapStringLiteralOp(interface, priority, actions,
1282                                                   description, literal);
1283             }
1284         }
1285     } else {
1286         const unsigned objectiveCActions = type == TypeObjCString ?
1287                                            unsigned(RemoveObjectiveCAction) : 0u;
1288         unsigned actions = 0;
1289         if (StringLiteralAST *stringLiteral = literal->asStringLiteral()) {
1290             const QByteArray contents(file->tokenAt(stringLiteral->literal_token).identifier->chars());
1291             if (!stringToCharEscapeSequences(contents).isEmpty()) {
1292                 actions = EncloseInQLatin1CharAction | SingleQuoteAction
1293                           | ConvertEscapeSequencesToCharAction | objectiveCActions;
1294                 QString description = QApplication::translate("CppEditor::QuickFix",
1295                                       "Convert to Character Literal and Enclose in QLatin1Char(...)");
1296                 result << new WrapStringLiteralOp(interface, priority, actions,
1297                                                   description, literal);
1298                 actions &= ~EncloseInQLatin1CharAction;
1299                 description = QApplication::translate("CppEditor::QuickFix",
1300                               "Convert to Character Literal");
1301                 result << new WrapStringLiteralOp(interface, priority, actions,
1302                                                   description, literal);
1303             }
1304         }
1305         actions = EncloseInQLatin1StringAction | objectiveCActions;
1306         result << new WrapStringLiteralOp(interface, priority, actions,
1307                                           msgQtStringLiteralDescription(stringLiteralReplacement(actions)), literal);
1308         actions = EncloseInQStringLiteralAction | objectiveCActions;
1309         result << new WrapStringLiteralOp(interface, priority, actions,
1310                                           msgQtStringLiteralDescription(stringLiteralReplacement(actions)), literal);
1311     }
1312 }
1313 
1314 void TranslateStringLiteral::match(const CppQuickFixInterface &interface,
1315                                    QuickFixOperations &result)
1316 {
1317     // Initialize
1318     StringLiteralType type = TypeNone;
1319     QByteArray enclosingFunction;
1320     const QList<AST *> &path = interface.path();
1321     CppRefactoringFilePtr file = interface.currentFile();
1322     ExpressionAST *literal = analyzeStringLiteral(path, file, &type, &enclosingFunction);
1323     if (!literal || type != TypeString
1324        || isQtStringLiteral(enclosingFunction) || isQtStringTranslation(enclosingFunction))
1325         return;
1326 
1327     QString trContext;
1328 
1329     QSharedPointer<Control> control = interface.context().bindings()->control();
1330     const Name *trName = control->identifier("tr");
1331 
1332     // Check whether we are in a function:
1333     const QString description = QApplication::translate("CppEditor::QuickFix", "Mark as Translatable");
1334     for (int i = path.size() - 1; i >= 0; --i) {
1335         if (FunctionDefinitionAST *definition = path.at(i)->asFunctionDefinition()) {
1336             Function *function = definition->symbol;
1337             ClassOrNamespace *b = interface.context().lookupType(function);
1338             if (b) {
1339                 // Do we have a tr function?
1340                 foreach (const LookupItem &r, b->find(trName)) {
1341                     Symbol *s = r.declaration();
1342                     if (s->type()->isFunctionType()) {
1343                         // no context required for tr
1344                         result << new WrapStringLiteralOp(interface, path.size() - 1,
1345                                                           TranslateTrAction,
1346                                                           description, literal);
1347                         return;
1348                     }
1349                 }
1350             }
1351             // We need to do a QCA::translate, so we need a context.
1352             // Use fully qualified class name:
1353             Overview oo;
1354             foreach (const Name *n, LookupContext::path(function)) {
1355                 if (!trContext.isEmpty())
1356                     trContext.append(QLatin1String("::"));
1357                 trContext.append(oo.prettyName(n));
1358             }
1359             // ... or global if none available!
1360             if (trContext.isEmpty())
1361                 trContext = QLatin1String("GLOBAL");
1362             result << new WrapStringLiteralOp(interface, path.size() - 1,
1363                                               TranslateQCoreApplicationAction,
1364                                               description, literal, trContext);
1365             return;
1366         }
1367     }
1368 
1369     // We need to use Q_TRANSLATE_NOOP
1370     result << new WrapStringLiteralOp(interface, path.size() - 1,
1371                                       TranslateNoopAction,
1372                                       description, literal, trContext);
1373 }
1374 
1375 namespace {
1376 
1377 class ConvertCStringToNSStringOp: public CppQuickFixOperation
1378 {
1379 public:
1380     ConvertCStringToNSStringOp(const CppQuickFixInterface &interface, int priority,
1381                                StringLiteralAST *stringLiteral, CallAST *qlatin1Call)
1382         : CppQuickFixOperation(interface, priority)
1383         , stringLiteral(stringLiteral)
1384         , qlatin1Call(qlatin1Call)
1385     {
1386         setDescription(QApplication::translate("CppEditor::QuickFix",
1387                                                "Convert to Objective-C String Literal"));
1388     }
1389 
1390     void perform() override
1391     {
1392         CppRefactoringChanges refactoring(snapshot());
1393         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
1394 
1395         ChangeSet changes;
1396 
1397         if (qlatin1Call) {
1398             changes.replace(currentFile->startOf(qlatin1Call), currentFile->startOf(stringLiteral),
1399                             QLatin1String("@"));
1400             changes.remove(currentFile->endOf(stringLiteral), currentFile->endOf(qlatin1Call));
1401         } else {
1402             changes.insert(currentFile->startOf(stringLiteral), QLatin1String("@"));
1403         }
1404 
1405         currentFile->setChangeSet(changes);
1406         currentFile->apply();
1407     }
1408 
1409 private:
1410     StringLiteralAST *stringLiteral;
1411     CallAST *qlatin1Call;
1412 };
1413 
1414 } // anonymous namespace
1415 
1416 void ConvertCStringToNSString::match(const CppQuickFixInterface &interface,
1417                                      QuickFixOperations &result)
1418 {
1419     CppRefactoringFilePtr file = interface.currentFile();
1420 
1421     if (!interface.editor()->cppEditorDocument()->isObjCEnabled())
1422         return;
1423 
1424     StringLiteralType type = TypeNone;
1425     QByteArray enclosingFunction;
1426     CallAST *qlatin1Call;
1427     const QList<AST *> &path = interface.path();
1428     ExpressionAST *literal = analyzeStringLiteral(path, file, &type, &enclosingFunction,
1429                                                   &qlatin1Call);
1430     if (!literal || type != TypeString)
1431         return;
1432     if (!isQtStringLiteral(enclosingFunction))
1433         qlatin1Call = nullptr;
1434 
1435     result << new ConvertCStringToNSStringOp(interface, path.size() - 1, literal->asStringLiteral(),
1436                                              qlatin1Call);
1437 }
1438 
1439 namespace {
1440 
1441 class ConvertNumericLiteralOp: public CppQuickFixOperation
1442 {
1443 public:
1444     ConvertNumericLiteralOp(const CppQuickFixInterface &interface, int start, int end,
1445                             const QString &replacement)
1446         : CppQuickFixOperation(interface)
1447         , start(start)
1448         , end(end)
1449         , replacement(replacement)
1450     {}
1451 
1452     void perform() override
1453     {
1454         CppRefactoringChanges refactoring(snapshot());
1455         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
1456 
1457         ChangeSet changes;
1458         changes.replace(start, end, replacement);
1459         currentFile->setChangeSet(changes);
1460         currentFile->apply();
1461     }
1462 
1463 private:
1464     int start, end;
1465     QString replacement;
1466 };
1467 
1468 } // anonymous namespace
1469 
1470 void ConvertNumericLiteral::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
1471 {
1472     const QList<AST *> &path = interface.path();
1473     CppRefactoringFilePtr file = interface.currentFile();
1474 
1475     if (path.isEmpty())
1476         return;
1477 
1478     NumericLiteralAST *literal = path.last()->asNumericLiteral();
1479 
1480     if (!literal)
1481         return;
1482 
1483     Token token = file->tokenAt(literal->asNumericLiteral()->literal_token);
1484     if (!token.is(T_NUMERIC_LITERAL))
1485         return;
1486     const NumericLiteral *numeric = token.number;
1487     if (numeric->isDouble() || numeric->isFloat())
1488         return;
1489 
1490     // remove trailing L or U and stuff
1491     const char * const spell = numeric->chars();
1492     int numberLength = numeric->size();
1493     while (numberLength > 0 && !std::isxdigit(spell[numberLength - 1]))
1494         --numberLength;
1495     if (numberLength < 1)
1496         return;
1497 
1498     // convert to number
1499     bool valid;
1500     ulong value = 0;
1501     const QString x = QString::fromUtf8(spell).left(numberLength);
1502     if (x.startsWith("0b", Qt::CaseInsensitive))
1503         value = x.mid(2).toULong(&valid, 2);
1504     else
1505         value = x.toULong(&valid, 0);
1506 
1507     if (!valid)
1508         return;
1509 
1510     const int priority = path.size() - 1; // very high priority
1511     const int start = file->startOf(literal);
1512     const char * const str = numeric->chars();
1513 
1514     const bool isBinary = numberLength > 2 && str[0] == '0' && tolower(str[1]) == 'b';
1515     const bool isOctal = numberLength >= 2 && str[0] == '0' && str[1] >= '0' && str[1] <= '7';
1516     const bool isDecimal = !(isBinary || isOctal || numeric->isHex());
1517 
1518     if (!numeric->isHex()) {
1519         /*
1520           Convert integer literal to hex representation.
1521           Replace
1522             0b100000
1523             32
1524             040
1525           With
1526             0x20
1527 
1528         */
1529         const QString replacement = QString::asprintf("0x%lX", value);
1530         auto op = new ConvertNumericLiteralOp(interface, start, start + numberLength, replacement);
1531         op->setDescription(QApplication::translate("CppEditor::QuickFix", "Convert to Hexadecimal"));
1532         op->setPriority(priority);
1533         result << op;
1534     }
1535 
1536     if (!isOctal) {
1537         /*
1538           Convert integer literal to octal representation.
1539           Replace
1540             0b100000
1541             32
1542             0x20
1543           With
1544             040
1545         */
1546         const QString replacement = QString::asprintf("0%lo", value);
1547         auto op = new ConvertNumericLiteralOp(interface, start, start + numberLength, replacement);
1548         op->setDescription(QApplication::translate("CppEditor::QuickFix", "Convert to Octal"));
1549         op->setPriority(priority);
1550         result << op;
1551     }
1552 
1553     if (!isDecimal) {
1554         /*
1555           Convert integer literal to decimal representation.
1556           Replace
1557             0b100000
1558             0x20
1559             040
1560            With
1561             32
1562         */
1563         const QString replacement = QString::asprintf("%lu", value);
1564         auto op = new ConvertNumericLiteralOp(interface, start, start + numberLength, replacement);
1565         op->setDescription(QApplication::translate("CppEditor::QuickFix", "Convert to Decimal"));
1566         op->setPriority(priority);
1567         result << op;
1568     }
1569 
1570     if (!isBinary) {
1571         /*
1572           Convert integer literal to binary representation.
1573           Replace
1574             32
1575             0x20
1576             040
1577           With
1578             0b100000
1579         */
1580         QString replacement = "0b";
1581         if (value == 0) {
1582             replacement.append('0');
1583         } else {
1584             std::bitset<std::numeric_limits<decltype (value)>::digits> b(value);
1585             QRegularExpression re("^[0]*");
1586             replacement.append(QString::fromStdString(b.to_string()).remove(re));
1587         }
1588         auto op = new ConvertNumericLiteralOp(interface, start, start + numberLength, replacement);
1589         op->setDescription(QApplication::translate("CppEditor::QuickFix", "Convert to Binary"));
1590         op->setPriority(priority);
1591         result << op;
1592     }
1593 }
1594 
1595 namespace {
1596 
1597 class AddLocalDeclarationOp: public CppQuickFixOperation
1598 {
1599 public:
1600     AddLocalDeclarationOp(const CppQuickFixInterface &interface,
1601                           int priority,
1602                           const BinaryExpressionAST *binaryAST,
1603                           const SimpleNameAST *simpleNameAST)
1604         : CppQuickFixOperation(interface, priority)
1605         , binaryAST(binaryAST)
1606         , simpleNameAST(simpleNameAST)
1607     {
1608         setDescription(QApplication::translate("CppEditor::QuickFix", "Add Local Declaration"));
1609     }
1610 
1611     void perform() override
1612     {
1613         CppRefactoringChanges refactoring(snapshot());
1614         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
1615 
1616         TypeOfExpression typeOfExpression;
1617         typeOfExpression.init(semanticInfo().doc, snapshot(), context().bindings());
1618         Scope *scope = currentFile->scopeAt(binaryAST->firstToken());
1619         const QList<LookupItem> result =
1620                 typeOfExpression(currentFile->textOf(binaryAST->right_expression).toUtf8(),
1621                                  scope,
1622                                  TypeOfExpression::Preprocess);
1623 
1624         if (!result.isEmpty()) {
1625             SubstitutionEnvironment env;
1626             env.setContext(context());
1627             env.switchScope(result.first().scope());
1628             ClassOrNamespace *con = typeOfExpression.context().lookupType(scope);
1629             if (!con)
1630                 con = typeOfExpression.context().globalNamespace();
1631             UseMinimalNames q(con);
1632             env.enter(&q);
1633 
1634             Control *control = context().bindings()->control().data();
1635             FullySpecifiedType tn = rewriteType(result.first().type(), &env, control);
1636 
1637             Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
1638             QString ty = oo.prettyType(tn, simpleNameAST->name);
1639             if (!ty.isEmpty()) {
1640                 ChangeSet changes;
1641                 changes.replace(currentFile->startOf(binaryAST),
1642                                 currentFile->endOf(simpleNameAST),
1643                                 ty);
1644                 currentFile->setChangeSet(changes);
1645                 currentFile->apply();
1646             }
1647         }
1648     }
1649 
1650 private:
1651     const BinaryExpressionAST *binaryAST;
1652     const SimpleNameAST *simpleNameAST;
1653 };
1654 
1655 } // anonymous namespace
1656 
1657 void AddLocalDeclaration::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
1658 {
1659     const QList<AST *> &path = interface.path();
1660     CppRefactoringFilePtr file = interface.currentFile();
1661 
1662     for (int index = path.size() - 1; index != -1; --index) {
1663         if (BinaryExpressionAST *binary = path.at(index)->asBinaryExpression()) {
1664             if (binary->left_expression && binary->right_expression
1665                     && file->tokenAt(binary->binary_op_token).is(T_EQUAL)) {
1666                 IdExpressionAST *idExpr = binary->left_expression->asIdExpression();
1667                 if (interface.isCursorOn(binary->left_expression) && idExpr
1668                         && idExpr->name->asSimpleName() != nullptr) {
1669                     SimpleNameAST *nameAST = idExpr->name->asSimpleName();
1670                     const QList<LookupItem> results = interface.context().lookup(nameAST->name, file->scopeAt(nameAST->firstToken()));
1671                     Declaration *decl = nullptr;
1672                     foreach (const LookupItem &r, results) {
1673                         if (!r.declaration())
1674                             continue;
1675                         if (Declaration *d = r.declaration()->asDeclaration()) {
1676                             if (!d->type()->isFunctionType()) {
1677                                 decl = d;
1678                                 break;
1679                             }
1680                         }
1681                     }
1682 
1683                     if (!decl) {
1684                         result << new AddLocalDeclarationOp(interface, index, binary, nameAST);
1685                         return;
1686                     }
1687                 }
1688             }
1689         }
1690     }
1691 }
1692 
1693 namespace {
1694 
1695 class ConvertToCamelCaseOp: public CppQuickFixOperation
1696 {
1697 public:
1698     ConvertToCamelCaseOp(const CppQuickFixInterface &interface, const QString &name,
1699                          const AST *nameAst, bool test)
1700         : CppQuickFixOperation(interface, -1)
1701         , m_name(name)
1702         , m_nameAst(nameAst)
1703         , m_isAllUpper(name.isUpper())
1704         , m_test(test)
1705     {
1706         setDescription(QApplication::translate("CppEditor::QuickFix", "Convert to Camel Case"));
1707     }
1708 
1709     void perform() override
1710     {
1711         CppRefactoringChanges refactoring(snapshot());
1712         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
1713 
1714         QString newName = m_isAllUpper ? m_name.toLower() : m_name;
1715         for (int i = 1; i < newName.length(); ++i) {
1716             const QChar c = newName.at(i);
1717             if (c.isUpper() && m_isAllUpper) {
1718                 newName[i] = c.toLower();
1719             } else if (i < newName.length() - 1 && isConvertibleUnderscore(newName, i)) {
1720                 newName.remove(i, 1);
1721                 newName[i] = newName.at(i).toUpper();
1722             }
1723         }
1724         if (m_test) {
1725             ChangeSet changeSet;
1726             changeSet.replace(currentFile->range(m_nameAst), newName);
1727             currentFile->setChangeSet(changeSet);
1728             currentFile->apply();
1729         } else {
1730             editor()->renameUsages(newName);
1731         }
1732     }
1733 
1734     static bool isConvertibleUnderscore(const QString &name, int pos)
1735     {
1736         return name.at(pos) == QLatin1Char('_') && name.at(pos+1).isLetter()
1737                 && !(pos == 1 && name.at(0) == QLatin1Char('m'));
1738     }
1739 
1740 private:
1741     const QString m_name;
1742     const AST * const m_nameAst;
1743     const bool m_isAllUpper;
1744     const bool m_test;
1745 };
1746 
1747 } // anonymous namespace
1748 
1749 void ConvertToCamelCase::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
1750 {
1751     const QList<AST *> &path = interface.path();
1752 
1753     if (path.isEmpty())
1754         return;
1755 
1756     AST * const ast = path.last();
1757     const Name *name = nullptr;
1758     const AST *astForName = nullptr;
1759     if (const NameAST * const nameAst = ast->asName()) {
1760         if (nameAst->name && nameAst->name->asNameId()) {
1761             astForName = nameAst;
1762             name = nameAst->name;
1763         }
1764     } else if (const NamespaceAST * const namespaceAst = ast->asNamespace()) {
1765         astForName = namespaceAst;
1766         name = namespaceAst->symbol->name();
1767     }
1768 
1769     if (!name)
1770         return;
1771 
1772     QString nameString = QString::fromUtf8(name->identifier()->chars());
1773     if (nameString.length() < 3)
1774         return;
1775     for (int i = 1; i < nameString.length() - 1; ++i) {
1776         if (ConvertToCamelCaseOp::isConvertibleUnderscore(nameString, i)) {
1777             result << new ConvertToCamelCaseOp(interface, nameString, astForName, m_test);
1778             return;
1779         }
1780     }
1781 }
1782 
1783 AddIncludeForUndefinedIdentifierOp::AddIncludeForUndefinedIdentifierOp(
1784         const CppQuickFixInterface &interface, int priority, const QString &include)
1785     : CppQuickFixOperation(interface, priority)
1786     , m_include(include)
1787 {
1788     setDescription(QApplication::translate("CppEditor::QuickFix", "Add #include %1").arg(m_include));
1789 }
1790 
1791 void AddIncludeForUndefinedIdentifierOp::perform()
1792 {
1793     CppRefactoringChanges refactoring(snapshot());
1794     CppRefactoringFilePtr file = refactoring.file(filePath());
1795 
1796     insertNewIncludeDirective(m_include, file, semanticInfo().doc);
1797 }
1798 
1799 AddForwardDeclForUndefinedIdentifierOp::AddForwardDeclForUndefinedIdentifierOp(
1800         const CppQuickFixInterface &interface,
1801         int priority,
1802         const QString &fqClassName,
1803         int symbolPos)
1804     : CppQuickFixOperation(interface, priority), m_className(fqClassName), m_symbolPos(symbolPos)
1805 {
1806     setDescription(QApplication::translate("CppEditor::QuickFix",
1807                                            "Add forward declaration for %1").arg(m_className));
1808 }
1809 
1810 void AddForwardDeclForUndefinedIdentifierOp::perform()
1811 {
1812     const QStringList parts = m_className.split("::");
1813     QTC_ASSERT(!parts.isEmpty(), return);
1814     const QStringList namespaces = parts.mid(0, parts.length() - 1);
1815 
1816     CppRefactoringChanges refactoring(snapshot());
1817     CppRefactoringFilePtr file = refactoring.file(filePath());
1818 
1819     NSVisitor visitor(file.data(), namespaces, m_symbolPos);
1820     visitor.accept(file->cppDocument()->translationUnit()->ast());
1821     const auto stringToInsert = [&visitor, symbol = parts.last()] {
1822         QString s = "\n";
1823         for (const QString &ns : visitor.remainingNamespaces())
1824             s += "namespace " + ns + " { ";
1825         s += "class " + symbol + ';';
1826         for (int i = 0; i < visitor.remainingNamespaces().size(); ++i)
1827             s += " }";
1828         return s;
1829     };
1830 
1831     int insertPos = 0;
1832 
1833     // Find the position to insert:
1834     //   If we have a matching namespace, we do the insertion there.
1835     //   If we don't have a matching namespace, but there is another namespace in the file,
1836     //   we assume that to be a good position for our insertion.
1837     //   Otherwise, do the insertion after the last include that comes before the use of the symbol.
1838     //   If there is no such include, do the insertion before the first token.
1839     if (visitor.enclosingNamespace()) {
1840         insertPos = file->startOf(visitor.enclosingNamespace()->linkage_body) + 1;
1841     } else if (visitor.firstNamespace()) {
1842         insertPos = file->startOf(visitor.firstNamespace());
1843     } else {
1844         const QTextCursor tc = file->document()->find(
1845                     QRegularExpression("^\\s*#include .*$"),
1846                     m_symbolPos,
1847                     QTextDocument::FindBackward | QTextDocument::FindCaseSensitively);
1848         if (!tc.isNull())
1849             insertPos = tc.position() + 1;
1850         else if (visitor.firstToken())
1851             insertPos = file->startOf(visitor.firstToken());
1852     }
1853 
1854     QString insertion = stringToInsert();
1855     if (file->charAt(insertPos - 1) != QChar::ParagraphSeparator)
1856         insertion.prepend('\n');
1857     if (file->charAt(insertPos) != QChar::ParagraphSeparator)
1858         insertion.append('\n');
1859     ChangeSet s;
1860     s.insert(insertPos, insertion);
1861     file->setChangeSet(s);
1862     file->apply();
1863 }
1864 
1865 namespace {
1866 
1867 QString findShortestInclude(const QString currentDocumentFilePath,
1868                             const QString candidateFilePath,
1869                             const ProjectExplorer::HeaderPaths &headerPaths)
1870 {
1871     QString result;
1872 
1873     const QFileInfo fileInfo(candidateFilePath);
1874 
1875     if (fileInfo.path() == QFileInfo(currentDocumentFilePath).path()) {
1876         result = QLatin1Char('"') + fileInfo.fileName() + QLatin1Char('"');
1877     } else {
1878         foreach (const ProjectExplorer::HeaderPath &headerPath, headerPaths) {
1879             if (!candidateFilePath.startsWith(headerPath.path))
1880                 continue;
1881             QString relativePath = candidateFilePath.mid(headerPath.path.size());
1882             if (!relativePath.isEmpty() && relativePath.at(0) == QLatin1Char('/'))
1883                 relativePath = relativePath.mid(1);
1884             if (result.isEmpty() || relativePath.size() + 2 < result.size())
1885                 result = QLatin1Char('<') + relativePath + QLatin1Char('>');
1886         }
1887     }
1888 
1889     return result;
1890 }
1891 
1892 QString findMatchingInclude(const QString &className,
1893                             const ProjectExplorer::HeaderPaths &headerPaths)
1894 {
1895     const QStringList candidateFileNames{className, className + ".h", className + ".hpp",
1896                 className.toLower(), className.toLower() + ".h", className.toLower() + ".hpp"};
1897     for (const QString &fileName : candidateFileNames) {
1898         for (const ProjectExplorer::HeaderPath &headerPath : headerPaths) {
1899             const QString headerPathCandidate = headerPath.path + QLatin1Char('/') + fileName;
1900             const QFileInfo fileInfo(headerPathCandidate);
1901             if (fileInfo.exists() && fileInfo.isFile())
1902                 return '<' + fileName + '>';
1903         }
1904     }
1905     return {};
1906 }
1907 
1908 ProjectExplorer::HeaderPaths relevantHeaderPaths(const QString &filePath)
1909 {
1910     ProjectExplorer::HeaderPaths headerPaths;
1911 
1912     CppModelManager *modelManager = CppModelManager::instance();
1913     const QList<ProjectPart::ConstPtr> projectParts = modelManager->projectPart(filePath);
1914     if (projectParts.isEmpty()) { // Not part of any project, better use all include paths than none
1915         headerPaths += modelManager->headerPaths();
1916     } else {
1917         foreach (const ProjectPart::ConstPtr &part, projectParts)
1918             headerPaths += part->headerPaths;
1919     }
1920 
1921     return headerPaths;
1922 }
1923 
1924 NameAST *nameUnderCursor(const QList<AST *> &path)
1925 {
1926     if (path.isEmpty())
1927         return nullptr;
1928 
1929     NameAST *nameAst = nullptr;
1930     for (int i = path.size() - 1; i >= 0; --i) {
1931         AST * const ast = path.at(i);
1932         if (SimpleNameAST *simpleName = ast->asSimpleName()) {
1933             nameAst = simpleName;
1934         } else if (TemplateIdAST *templateId = ast->asTemplateId()) {
1935             nameAst = templateId;
1936         } else if (nameAst && ast->asNamedTypeSpecifier()) {
1937             break; // Stop at "Foo" for "N::Bar<@Foo>"
1938         } else if (QualifiedNameAST *qualifiedName = ast->asQualifiedName()) {
1939             nameAst = qualifiedName;
1940             break;
1941         }
1942     }
1943 
1944     return nameAst;
1945 }
1946 
1947 enum class LookupResult { Declared, ForwardDeclared, NotDeclared };
1948 LookupResult lookUpDefinition(const CppQuickFixInterface &interface, const NameAST *nameAst)
1949 {
1950     QTC_ASSERT(nameAst && nameAst->name, return LookupResult::NotDeclared);
1951 
1952     // Find the enclosing scope
1953     int line, column;
1954     const Document::Ptr doc = interface.semanticInfo().doc;
1955     doc->translationUnit()->getTokenStartPosition(nameAst->firstToken(), &line, &column);
1956     Scope *scope = doc->scopeAt(line, column);
1957     if (!scope)
1958         return LookupResult::NotDeclared;
1959 
1960     // Try to find the class/template definition
1961     const Name *name = nameAst->name;
1962     const QList<LookupItem> results = interface.context().lookup(name, scope);
1963     foreach (const LookupItem &item, results) {
1964         if (Symbol *declaration = item.declaration()) {
1965             if (declaration->isClass())
1966                 return LookupResult::Declared;
1967             if (declaration->isForwardClassDeclaration())
1968                 return LookupResult::ForwardDeclared;
1969             if (Template *templ = declaration->asTemplate()) {
1970                 if (Symbol *declaration = templ->declaration()) {
1971                     if (declaration->isClass())
1972                         return LookupResult::Declared;
1973                     if (declaration->isForwardClassDeclaration())
1974                         return LookupResult::ForwardDeclared;
1975                 }
1976             }
1977             return LookupResult::Declared;
1978         }
1979     }
1980 
1981     return LookupResult::NotDeclared;
1982 }
1983 
1984 QString templateNameAsString(const TemplateNameId *templateName)
1985 {
1986     const Identifier *id = templateName->identifier();
1987     return QString::fromUtf8(id->chars(), id->size());
1988 }
1989 
1990 Snapshot forwardingHeaders(const CppQuickFixInterface &interface)
1991 {
1992     Snapshot result;
1993 
1994     foreach (Document::Ptr doc, interface.snapshot()) {
1995         if (doc->globalSymbolCount() == 0 && doc->resolvedIncludes().size() == 1)
1996             result.insert(doc);
1997     }
1998 
1999     return result;
2000 }
2001 
2002 bool matchName(const Name *name, QList<Core::LocatorFilterEntry> *matches, QString *className) {
2003     if (!name)
2004         return false;
2005 
2006     QString simpleName;
2007     if (Core::ILocatorFilter *classesFilter = CppModelManager::instance()->classesFilter()) {
2008         QFutureInterface<Core::LocatorFilterEntry> dummy;
2009 
2010         const Overview oo;
2011         if (const QualifiedNameId *qualifiedName = name->asQualifiedNameId()) {
2012             const Name *name = qualifiedName->name();
2013             if (const TemplateNameId *templateName = name->asTemplateNameId()) {
2014                 *className = templateNameAsString(templateName);
2015             } else {
2016                 simpleName = oo.prettyName(name);
2017                 *className = simpleName;
2018                 *matches = classesFilter->matchesFor(dummy, *className);
2019                 if (matches->empty()) {
2020                     if (const Name *name = qualifiedName->base()) {
2021                         if (const TemplateNameId *templateName = name->asTemplateNameId())
2022                             *className = templateNameAsString(templateName);
2023                         else
2024                             *className = oo.prettyName(name);
2025                     }
2026                 }
2027             }
2028         } else if (const TemplateNameId *templateName = name->asTemplateNameId()) {
2029             *className = templateNameAsString(templateName);
2030         } else {
2031             *className = oo.prettyName(name);
2032         }
2033 
2034         if (matches->empty())
2035             *matches = classesFilter->matchesFor(dummy, *className);
2036         if (matches->empty() && !simpleName.isEmpty())
2037             *className = simpleName;
2038     }
2039 
2040     return !matches->empty();
2041 }
2042 
2043 } // anonymous namespace
2044 
2045 void AddIncludeForUndefinedIdentifier::match(const CppQuickFixInterface &interface,
2046                                              QuickFixOperations &result)
2047 {
2048     const NameAST *nameAst = nameUnderCursor(interface.path());
2049     if (!nameAst || !nameAst->name)
2050         return;
2051 
2052     const LookupResult lookupResult = lookUpDefinition(interface, nameAst);
2053     if (lookupResult == LookupResult::Declared)
2054         return;
2055 
2056     QString className;
2057     QList<Core::LocatorFilterEntry> matches;
2058     const QString currentDocumentFilePath = interface.semanticInfo().doc->fileName();
2059     const ProjectExplorer::HeaderPaths headerPaths = relevantHeaderPaths(currentDocumentFilePath);
2060     QList<Utils::FilePath> headers;
2061 
2062     // Find an include file through the locator
2063     if (matchName(nameAst->name, &matches, &className)) {
2064         QList<IndexItem::Ptr> indexItems;
2065         const Snapshot forwardHeaders = forwardingHeaders(interface);
2066         foreach (const Core::LocatorFilterEntry &entry, matches) {
2067             IndexItem::Ptr info = entry.internalData.value<IndexItem::Ptr>();
2068             if (!info || info->symbolName() != className)
2069                 continue;
2070             indexItems << info;
2071 
2072             Snapshot localForwardHeaders = forwardHeaders;
2073             localForwardHeaders.insert(interface.snapshot().document(info->fileName()));
2074             Utils::FilePaths headerAndItsForwardingHeaders;
2075             headerAndItsForwardingHeaders << Utils::FilePath::fromString(info->fileName());
2076             headerAndItsForwardingHeaders += localForwardHeaders.filesDependingOn(info->fileName());
2077 
2078             foreach (const Utils::FilePath &header, headerAndItsForwardingHeaders) {
2079                 const QString include = findShortestInclude(currentDocumentFilePath,
2080                                                             header.toString(),
2081                                                             headerPaths);
2082                 if (include.size() > 2) {
2083                     const QString headerFileName = Utils::FilePath::fromString(info->fileName()).fileName();
2084                     QTC_ASSERT(!headerFileName.isEmpty(), break);
2085 
2086                     int priority = 0;
2087                     if (headerFileName == className)
2088                         priority = 2;
2089                     else if (headerFileName.at(1).isUpper())
2090                         priority = 1;
2091 
2092                     result << new AddIncludeForUndefinedIdentifierOp(interface, priority,
2093                                                                      include);
2094                     headers << header;
2095                 }
2096             }
2097         }
2098 
2099         if (lookupResult == LookupResult::NotDeclared && indexItems.size() == 1) {
2100             QString qualifiedName = Overview().prettyName(nameAst->name);
2101             if (qualifiedName.startsWith("::"))
2102                 qualifiedName.remove(0, 2);
2103             if (indexItems.first()->scopedSymbolName().endsWith(qualifiedName)) {
2104                 const ProjectExplorer::Node * const node = ProjectExplorer::ProjectTree
2105                         ::nodeForFile(interface.filePath());
2106                 ProjectExplorer::FileType fileType = node && node->asFileNode()
2107                         ? node->asFileNode()->fileType() : ProjectExplorer::FileType::Unknown;
2108                 if (fileType == ProjectExplorer::FileType::Unknown
2109                         && ProjectFile::isHeader(ProjectFile::classify(interface.filePath().toString()))) {
2110                     fileType = ProjectExplorer::FileType::Header;
2111                 }
2112                 if (fileType == ProjectExplorer::FileType::Header) {
2113                     result << new AddForwardDeclForUndefinedIdentifierOp(
2114                                   interface, 0, indexItems.first()->scopedSymbolName(),
2115                                   interface.currentFile()->startOf(nameAst));
2116                 }
2117             }
2118         }
2119     }
2120 
2121     if (className.isEmpty())
2122         return;
2123 
2124     // Fallback: Check the include paths for files that look like candidates
2125     //           for the given name.
2126     if (!Utils::contains(headers,
2127             [&className](const Utils::FilePath &fp) { return fp.fileName() == className; })) {
2128         const QString include = findMatchingInclude(className, headerPaths);
2129         const auto matcher = [&include](const QuickFixOperation::Ptr &o) {
2130             const auto includeOp = o.dynamicCast<AddIncludeForUndefinedIdentifierOp>();
2131             return includeOp && includeOp->include() == include;
2132         };
2133         if (!include.isEmpty() && !Utils::contains(result, matcher))
2134             result << new AddIncludeForUndefinedIdentifierOp(interface, 1, include);
2135     }
2136 }
2137 
2138 namespace {
2139 
2140 class RearrangeParamDeclarationListOp: public CppQuickFixOperation
2141 {
2142 public:
2143     enum Target { TargetPrevious, TargetNext };
2144 
2145     RearrangeParamDeclarationListOp(const CppQuickFixInterface &interface, AST *currentParam,
2146                                     AST *targetParam, Target target)
2147         : CppQuickFixOperation(interface)
2148         , m_currentParam(currentParam)
2149         , m_targetParam(targetParam)
2150     {
2151         QString targetString;
2152         if (target == TargetPrevious)
2153             targetString = QApplication::translate("CppEditor::QuickFix",
2154                                                    "Switch with Previous Parameter");
2155         else
2156             targetString = QApplication::translate("CppEditor::QuickFix",
2157                                                    "Switch with Next Parameter");
2158         setDescription(targetString);
2159     }
2160 
2161     void perform() override
2162     {
2163         CppRefactoringChanges refactoring(snapshot());
2164         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
2165 
2166         int targetEndPos = currentFile->endOf(m_targetParam);
2167         ChangeSet changes;
2168         changes.flip(currentFile->startOf(m_currentParam), currentFile->endOf(m_currentParam),
2169                      currentFile->startOf(m_targetParam), targetEndPos);
2170         currentFile->setChangeSet(changes);
2171         currentFile->setOpenEditor(false, targetEndPos);
2172         currentFile->apply();
2173     }
2174 
2175 private:
2176     AST *m_currentParam;
2177     AST *m_targetParam;
2178 };
2179 
2180 } // anonymous namespace
2181 
2182 void RearrangeParamDeclarationList::match(const CppQuickFixInterface &interface,
2183                                           QuickFixOperations &result)
2184 {
2185     const QList<AST *> path = interface.path();
2186 
2187     ParameterDeclarationAST *paramDecl = nullptr;
2188     int index = path.size() - 1;
2189     for (; index != -1; --index) {
2190         paramDecl = path.at(index)->asParameterDeclaration();
2191         if (paramDecl)
2192             break;
2193     }
2194 
2195     if (index < 1)
2196         return;
2197 
2198     ParameterDeclarationClauseAST *paramDeclClause = path.at(index-1)->asParameterDeclarationClause();
2199     QTC_ASSERT(paramDeclClause && paramDeclClause->parameter_declaration_list, return);
2200 
2201     ParameterDeclarationListAST *paramListNode = paramDeclClause->parameter_declaration_list;
2202     ParameterDeclarationListAST *prevParamListNode = nullptr;
2203     while (paramListNode) {
2204         if (paramDecl == paramListNode->value)
2205             break;
2206         prevParamListNode = paramListNode;
2207         paramListNode = paramListNode->next;
2208     }
2209 
2210     if (!paramListNode)
2211         return;
2212 
2213     if (prevParamListNode)
2214         result << new RearrangeParamDeclarationListOp(interface, paramListNode->value,
2215                                                       prevParamListNode->value, RearrangeParamDeclarationListOp::TargetPrevious);
2216     if (paramListNode->next)
2217         result << new RearrangeParamDeclarationListOp(interface, paramListNode->value,
2218                                                       paramListNode->next->value, RearrangeParamDeclarationListOp::TargetNext);
2219 }
2220 
2221 namespace {
2222 
2223 class ReformatPointerDeclarationOp: public CppQuickFixOperation
2224 {
2225 public:
2226     ReformatPointerDeclarationOp(const CppQuickFixInterface &interface, const ChangeSet change)
2227         : CppQuickFixOperation(interface)
2228         , m_change(change)
2229     {
2230         QString description;
2231         if (m_change.operationList().size() == 1) {
2232             description = QApplication::translate("CppEditor::QuickFix",
2233                 "Reformat to \"%1\"").arg(m_change.operationList().constFirst().text);
2234         } else { // > 1
2235             description = QApplication::translate("CppEditor::QuickFix",
2236                 "Reformat Pointers or References");
2237         }
2238         setDescription(description);
2239     }
2240 
2241     void perform() override
2242     {
2243         CppRefactoringChanges refactoring(snapshot());
2244         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
2245         currentFile->setChangeSet(m_change);
2246         currentFile->apply();
2247     }
2248 
2249 private:
2250     ChangeSet m_change;
2251 };
2252 
2253 /// Filter the results of ASTPath.
2254 /// The resulting list contains the supported AST types only once.
2255 /// For this, the results of ASTPath are iterated in reverse order.
2256 class ReformatPointerDeclarationASTPathResultsFilter
2257 {
2258 public:
2259     QList<AST*> filter(const QList<AST*> &astPathList)
2260     {
2261         QList<AST*> filtered;
2262 
2263         for (int i = astPathList.size() - 1; i >= 0; --i) {
2264             AST *ast = astPathList.at(i);
2265 
2266             if (!m_hasSimpleDeclaration && ast->asSimpleDeclaration()) {
2267                 m_hasSimpleDeclaration = true;
2268                 filtered.append(ast);
2269             } else if (!m_hasFunctionDefinition && ast->asFunctionDefinition()) {
2270                 m_hasFunctionDefinition = true;
2271                 filtered.append(ast);
2272             } else if (!m_hasParameterDeclaration && ast->asParameterDeclaration()) {
2273                 m_hasParameterDeclaration = true;
2274                 filtered.append(ast);
2275             } else if (!m_hasIfStatement && ast->asIfStatement()) {
2276                 m_hasIfStatement = true;
2277                 filtered.append(ast);
2278             } else if (!m_hasWhileStatement && ast->asWhileStatement()) {
2279                 m_hasWhileStatement = true;
2280                 filtered.append(ast);
2281             } else if (!m_hasForStatement && ast->asForStatement()) {
2282                 m_hasForStatement = true;
2283                 filtered.append(ast);
2284             } else if (!m_hasForeachStatement && ast->asForeachStatement()) {
2285                 m_hasForeachStatement = true;
2286                 filtered.append(ast);
2287             }
2288         }
2289 
2290         return filtered;
2291     }
2292 
2293 private:
2294     bool m_hasSimpleDeclaration = false;
2295     bool m_hasFunctionDefinition = false;
2296     bool m_hasParameterDeclaration = false;
2297     bool m_hasIfStatement = false;
2298     bool m_hasWhileStatement = false;
2299     bool m_hasForStatement = false;
2300     bool m_hasForeachStatement = false;
2301 };
2302 
2303 } // anonymous namespace
2304 
2305 void ReformatPointerDeclaration::match(const CppQuickFixInterface &interface,
2306                                        QuickFixOperations &result)
2307 {
2308     const QList<AST *> &path = interface.path();
2309     CppRefactoringFilePtr file = interface.currentFile();
2310 
2311     Overview overview = CppCodeStyleSettings::currentProjectCodeStyleOverview();
2312     overview.showArgumentNames = true;
2313     overview.showReturnTypes = true;
2314 
2315     const QTextCursor cursor = file->cursor();
2316     ChangeSet change;
2317     PointerDeclarationFormatter formatter(file, overview,
2318         PointerDeclarationFormatter::RespectCursor);
2319 
2320     if (cursor.hasSelection()) {
2321         // This will no work always as expected since this function is only called if
2322         // interface-path() is not empty. If the user selects the whole document via
2323         // ctrl-a and there is an empty line in the end, then the cursor is not on
2324         // any AST and therefore no quick fix will be triggered.
2325         change = formatter.format(file->cppDocument()->translationUnit()->ast());
2326         if (!change.isEmpty())
2327             result << new ReformatPointerDeclarationOp(interface, change);
2328     } else {
2329         const QList<AST *> suitableASTs
2330             = ReformatPointerDeclarationASTPathResultsFilter().filter(path);
2331         foreach (AST *ast, suitableASTs) {
2332             change = formatter.format(ast);
2333             if (!change.isEmpty()) {
2334                 result << new ReformatPointerDeclarationOp(interface, change);
2335                 return;
2336             }
2337         }
2338     }
2339 }
2340 
2341 namespace {
2342 
2343 class CaseStatementCollector : public ASTVisitor
2344 {
2345 public:
2346     CaseStatementCollector(Document::Ptr document, const Snapshot &snapshot,
2347                            Scope *scope)
2348         : ASTVisitor(document->translationUnit()),
2349         document(document),
2350         scope(scope)
2351     {
2352         typeOfExpression.init(document, snapshot);
2353     }
2354 
2355     QStringList operator ()(AST *ast)
2356     {
2357         values.clear();
2358         foundCaseStatementLevel = false;
2359         accept(ast);
2360         return values;
2361     }
2362 
2363     bool preVisit(AST *ast) override {
2364         if (CaseStatementAST *cs = ast->asCaseStatement()) {
2365             foundCaseStatementLevel = true;
2366             if (ExpressionAST *csExpression = cs->expression) {
2367                 if (ExpressionAST *expression = csExpression->asIdExpression()) {
2368                     QList<LookupItem> candidates = typeOfExpression(expression, document, scope);
2369                     if (!candidates.isEmpty() && candidates.first().declaration()) {
2370                         Symbol *decl = candidates.first().declaration();
2371                         values << prettyPrint.prettyName(LookupContext::fullyQualifiedName(decl));
2372                     }
2373                 }
2374             }
2375             return true;
2376         } else if (foundCaseStatementLevel) {
2377             return false;
2378         }
2379         return true;
2380     }
2381 
2382     Overview prettyPrint;
2383     bool foundCaseStatementLevel = false;
2384     QStringList values;
2385     TypeOfExpression typeOfExpression;
2386     Document::Ptr document;
2387     Scope *scope;
2388 };
2389 
2390 class CompleteSwitchCaseStatementOp: public CppQuickFixOperation
2391 {
2392 public:
2393     CompleteSwitchCaseStatementOp(const CppQuickFixInterface &interface,
2394               int priority, CompoundStatementAST *compoundStatement, const QStringList &values)
2395         : CppQuickFixOperation(interface, priority)
2396         , compoundStatement(compoundStatement)
2397         , values(values)
2398     {
2399         setDescription(QApplication::translate("CppEditor::QuickFix",
2400                                                "Complete Switch Statement"));
2401     }
2402 
2403     void perform() override
2404     {
2405         CppRefactoringChanges refactoring(snapshot());
2406         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
2407 
2408         ChangeSet changes;
2409         int start = currentFile->endOf(compoundStatement->lbrace_token);
2410         changes.insert(start, QLatin1String("\ncase ")
2411                        + values.join(QLatin1String(":\nbreak;\ncase "))
2412                        + QLatin1String(":\nbreak;"));
2413         currentFile->setChangeSet(changes);
2414         currentFile->appendIndentRange(ChangeSet::Range(start, start + 1));
2415         currentFile->apply();
2416     }
2417 
2418     CompoundStatementAST *compoundStatement;
2419     QStringList values;
2420 };
2421 
2422 static Enum *findEnum(const QList<LookupItem> &results, const LookupContext &ctxt)
2423 {
2424     foreach (const LookupItem &result, results) {
2425         const FullySpecifiedType fst = result.type();
2426 
2427         Type *type = result.declaration() ? result.declaration()->type().type()
2428                                           : fst.type();
2429 
2430         if (!type)
2431             continue;
2432         if (Enum *e = type->asEnumType())
2433             return e;
2434         if (const NamedType *namedType = type->asNamedType()) {
2435             if (ClassOrNamespace *con = ctxt.lookupType(namedType->name(), result.scope())) {
2436                 QList<Enum *> enums = con->unscopedEnums();
2437                 const QList<Symbol *> symbols = con->symbols();
2438                 for (Symbol * const s : symbols) {
2439                     if (const auto e = s->asEnum())
2440                         enums << e;
2441                 }
2442                 const Name *referenceName = namedType->name();
2443                 if (const QualifiedNameId *qualifiedName = referenceName->asQualifiedNameId())
2444                     referenceName = qualifiedName->name();
2445                 foreach (Enum *e, enums) {
2446                     if (const Name *candidateName = e->name()) {
2447                         if (candidateName->match(referenceName))
2448                             return e;
2449                     }
2450                 }
2451             }
2452         }
2453     }
2454 
2455     return nullptr;
2456 }
2457 
2458 Enum *conditionEnum(const CppQuickFixInterface &interface, SwitchStatementAST *statement)
2459 {
2460     Block *block = statement->symbol;
2461     Scope *scope = interface.semanticInfo().doc->scopeAt(block->line(), block->column());
2462     TypeOfExpression typeOfExpression;
2463     typeOfExpression.setExpandTemplates(true);
2464     typeOfExpression.init(interface.semanticInfo().doc, interface.snapshot());
2465     const QList<LookupItem> results = typeOfExpression(statement->condition,
2466                                                        interface.semanticInfo().doc,
2467                                                        scope);
2468 
2469     return findEnum(results, typeOfExpression.context());
2470 }
2471 
2472 } // anonymous namespace
2473 
2474 void CompleteSwitchCaseStatement::match(const CppQuickFixInterface &interface,
2475                                         QuickFixOperations &result)
2476 {
2477     const QList<AST *> &path = interface.path();
2478 
2479     if (path.isEmpty())
2480         return;
2481 
2482     // look for switch statement
2483     for (int depth = path.size() - 1; depth >= 0; --depth) {
2484         AST *ast = path.at(depth);
2485         SwitchStatementAST *switchStatement = ast->asSwitchStatement();
2486         if (switchStatement) {
2487             if (!switchStatement->statement || !switchStatement->symbol)
2488                 return;
2489             CompoundStatementAST *compoundStatement = switchStatement->statement->asCompoundStatement();
2490             if (!compoundStatement) // we ignore pathologic case "switch (t) case A: ;"
2491                 return;
2492             // look if the condition's type is an enum
2493             if (Enum *e = conditionEnum(interface, switchStatement)) {
2494                 // check the possible enum values
2495                 QStringList values;
2496                 Overview prettyPrint;
2497                 for (int i = 0; i < e->memberCount(); ++i) {
2498                     if (Declaration *decl = e->memberAt(i)->asDeclaration())
2499                         values << prettyPrint.prettyName(LookupContext::fullyQualifiedName(decl));
2500                 }
2501                 // Get the used values
2502                 Block *block = switchStatement->symbol;
2503                 CaseStatementCollector caseValues(interface.semanticInfo().doc, interface.snapshot(),
2504                                                   interface.semanticInfo().doc->scopeAt(block->line(), block->column()));
2505                 QStringList usedValues = caseValues(switchStatement);
2506                 // save the values that would be added
2507                 foreach (const QString &usedValue, usedValues)
2508                     values.removeAll(usedValue);
2509                 if (!values.isEmpty())
2510                     result << new CompleteSwitchCaseStatementOp(interface, depth,
2511                                                                 compoundStatement, values);
2512                 return;
2513             }
2514 
2515             return;
2516         }
2517     }
2518 }
2519 
2520 namespace {
2521 
2522 class InsertDeclOperation: public CppQuickFixOperation
2523 {
2524 public:
2525     InsertDeclOperation(const CppQuickFixInterface &interface,
2526                         const QString &targetFileName, const Class *targetSymbol,
2527                         InsertionPointLocator::AccessSpec xsSpec, const QString &decl, int priority)
2528         : CppQuickFixOperation(interface, priority)
2529         , m_targetFileName(targetFileName)
2530         , m_targetSymbol(targetSymbol)
2531         , m_xsSpec(xsSpec)
2532         , m_decl(decl)
2533     {
2534         setDescription(QCoreApplication::translate("CppEditor::InsertDeclOperation",
2535                                                    "Add %1 Declaration")
2536                        .arg(InsertionPointLocator::accessSpecToString(xsSpec)));
2537     }
2538 
2539     void perform() override
2540     {
2541         CppRefactoringChanges refactoring(snapshot());
2542 
2543         InsertionPointLocator locator(refactoring);
2544         const InsertionLocation loc = locator.methodDeclarationInClass(
2545                     m_targetFileName, m_targetSymbol, m_xsSpec);
2546         QTC_ASSERT(loc.isValid(), return);
2547 
2548         CppRefactoringFilePtr targetFile = refactoring.file(
2549             Utils::FilePath::fromString(m_targetFileName));
2550         int targetPosition1 = targetFile->position(loc.line(), loc.column());
2551         int targetPosition2 = qMax(0, targetFile->position(loc.line(), 1) - 1);
2552 
2553         ChangeSet target;
2554         target.insert(targetPosition1, loc.prefix() + m_decl);
2555         targetFile->setChangeSet(target);
2556         targetFile->appendIndentRange(ChangeSet::Range(targetPosition2, targetPosition1));
2557         targetFile->setOpenEditor(true, targetPosition1);
2558         targetFile->apply();
2559     }
2560 
2561     static QString generateDeclaration(const Function *function);
2562 
2563 private:
2564     QString m_targetFileName;
2565     const Class *m_targetSymbol;
2566     InsertionPointLocator::AccessSpec m_xsSpec;
2567     QString m_decl;
2568 };
2569 
2570 class DeclOperationFactory
2571 {
2572 public:
2573     DeclOperationFactory(const CppQuickFixInterface &interface, const QString &fileName,
2574                          const Class *matchingClass, const QString &decl)
2575         : m_interface(interface)
2576         , m_fileName(fileName)
2577         , m_matchingClass(matchingClass)
2578         , m_decl(decl)
2579     {}
2580 
2581     QuickFixOperation *operator()(InsertionPointLocator::AccessSpec xsSpec, int priority)
2582     {
2583         return new InsertDeclOperation(m_interface, m_fileName, m_matchingClass, xsSpec, m_decl, priority);
2584     }
2585 
2586 private:
2587     const CppQuickFixInterface &m_interface;
2588     const QString &m_fileName;
2589     const Class *m_matchingClass;
2590     const QString &m_decl;
2591 };
2592 
2593 } // anonymous namespace
2594 
2595 void InsertDeclFromDef::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
2596 {
2597     const QList<AST *> &path = interface.path();
2598     CppRefactoringFilePtr file = interface.currentFile();
2599 
2600     FunctionDefinitionAST *funDef = nullptr;
2601     int idx = 0;
2602     for (; idx < path.size(); ++idx) {
2603         AST *node = path.at(idx);
2604         if (idx > 1) {
2605             if (DeclaratorIdAST *declId = node->asDeclaratorId()) {
2606                 if (file->isCursorOn(declId)) {
2607                     if (FunctionDefinitionAST *candidate = path.at(idx - 2)->asFunctionDefinition()) {
2608                         funDef = candidate;
2609                         break;
2610                     }
2611                 }
2612             }
2613         }
2614 
2615         if (node->asClassSpecifier())
2616             return;
2617     }
2618 
2619     if (!funDef || !funDef->symbol)
2620         return;
2621 
2622     Function *fun = funDef->symbol;
2623     if (Class *matchingClass = isMemberFunction(interface.context(), fun)) {
2624         const QualifiedNameId *qName = fun->name()->asQualifiedNameId();
2625         for (Symbol *symbol = matchingClass->find(qName->identifier());
2626              symbol; symbol = symbol->next()) {
2627             Symbol *s = symbol;
2628             if (fun->enclosingScope()->isTemplate()) {
2629                 if (const Template *templ = s->type()->asTemplateType()) {
2630                     if (Symbol *decl = templ->declaration()) {
2631                         if (decl->type()->isFunctionType())
2632                             s = decl;
2633                     }
2634                 }
2635             }
2636             if (!s->name()
2637                     || !qName->identifier()->match(s->identifier())
2638                     || !s->type()->isFunctionType())
2639                 continue;
2640 
2641             if (s->type().match(fun->type())) {
2642                 // Declaration exists.
2643                 return;
2644             }
2645         }
2646         QString fileName = QString::fromUtf8(matchingClass->fileName(),
2647                                              matchingClass->fileNameLength());
2648         const QString decl = InsertDeclOperation::generateDeclaration(fun);
2649 
2650         // Add several possible insertion locations for declaration
2651         DeclOperationFactory operation(interface, fileName, matchingClass, decl);
2652 
2653         result << operation(InsertionPointLocator::Public, 5)
2654             << operation(InsertionPointLocator::PublicSlot, 4)
2655             << operation(InsertionPointLocator::Protected, 3)
2656             << operation(InsertionPointLocator::ProtectedSlot, 2)
2657             << operation(InsertionPointLocator::Private, 1)
2658             << operation(InsertionPointLocator::PrivateSlot, 0);
2659     }
2660 }
2661 
2662 QString InsertDeclOperation::generateDeclaration(const Function *function)
2663 {
2664     Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
2665     oo.showFunctionSignatures = true;
2666     oo.showReturnTypes = true;
2667     oo.showArgumentNames = true;
2668     oo.showEnclosingTemplate = true;
2669 
2670     QString decl;
2671     decl += oo.prettyType(function->type(), function->unqualifiedName());
2672     decl += QLatin1String(";\n");
2673 
2674     return decl;
2675 }
2676 
2677 namespace {
2678 
2679 class InsertDefOperation: public CppQuickFixOperation
2680 {
2681 public:
2682     // Make sure that either loc is valid or targetFileName is not empty.
2683     InsertDefOperation(const CppQuickFixInterface &interface,
2684                        Declaration *decl, DeclaratorAST *declAST, const InsertionLocation &loc,
2685                        const DefPos defpos, const QString &targetFileName = QString(),
2686                        bool freeFunction = false)
2687         : CppQuickFixOperation(interface, 0)
2688         , m_decl(decl)
2689         , m_declAST(declAST)
2690         , m_loc(loc)
2691         , m_defpos(defpos)
2692         , m_targetFileName(targetFileName)
2693     {
2694         if (m_defpos == DefPosImplementationFile) {
2695             const QString declFile = QString::fromUtf8(decl->fileName(), decl->fileNameLength());
2696             const QDir dir = QFileInfo(declFile).dir();
2697             setPriority(2);
2698             setDescription(QCoreApplication::translate("CppEditor::InsertDefOperation",
2699                                                        "Add Definition in %1")
2700                            .arg(dir.relativeFilePath(m_loc.isValid() ? m_loc.fileName()
2701                                                                      : m_targetFileName)));
2702         } else if (freeFunction) {
2703             setDescription(QCoreApplication::translate("CppEditor::InsertDefOperation",
2704                                                        "Add Definition Here"));
2705         } else if (m_defpos == DefPosInsideClass) {
2706             setDescription(QCoreApplication::translate("CppEditor::InsertDefOperation",
2707                                                        "Add Definition Inside Class"));
2708         } else if (m_defpos == DefPosOutsideClass) {
2709             setPriority(1);
2710             setDescription(QCoreApplication::translate("CppEditor::InsertDefOperation",
2711                                                        "Add Definition Outside Class"));
2712         }
2713     }
2714 
2715     static void insertDefinition(
2716             const CppQuickFixOperation *op,
2717             InsertionLocation loc,
2718             DefPos defPos,
2719             DeclaratorAST *declAST,
2720             Declaration *decl,
2721             const QString &targetFilePath,
2722             ChangeSet *changeSet = nullptr,
2723             QList<ChangeSet::Range> *indentRanges = nullptr)
2724     {
2725         CppRefactoringChanges refactoring(op->snapshot());
2726         if (!loc.isValid())
2727             loc = insertLocationForMethodDefinition(decl, true, NamespaceHandling::Ignore,
2728                                                       refactoring, targetFilePath);
2729         QTC_ASSERT(loc.isValid(), return);
2730 
2731         CppRefactoringFilePtr targetFile = refactoring.file(
2732             Utils::FilePath::fromString(loc.fileName()));
2733         Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
2734         oo.showFunctionSignatures = true;
2735         oo.showReturnTypes = true;
2736         oo.showArgumentNames = true;
2737         oo.showEnclosingTemplate = true;
2738 
2739         // What we really want is to show template parameters for the class, but not for the
2740         // function, but we cannot express that. This is an approximation that will work
2741         // as long as either the surrounding class or the function is not a template.
2742         oo.showTemplateParameters = decl->enclosingClass()
2743                 && decl->enclosingClass()->enclosingTemplate();
2744 
2745         if (defPos == DefPosInsideClass) {
2746             const int targetPos = targetFile->position(loc.line(), loc.column());
2747             ChangeSet localChangeSet;
2748             ChangeSet * const target = changeSet ? changeSet : &localChangeSet;
2749             target->replace(targetPos - 1, targetPos, QLatin1String("\n {\n\n}")); // replace ';'
2750             const ChangeSet::Range indentRange(targetPos, targetPos + 4);
2751             if (indentRanges)
2752                 indentRanges->append(indentRange);
2753             else
2754                 targetFile->appendIndentRange(indentRange);
2755 
2756             if (!changeSet) {
2757                 targetFile->setChangeSet(*target);
2758                 targetFile->setOpenEditor(true, targetPos);
2759                 targetFile->apply();
2760 
2761                 // Move cursor inside definition
2762                 QTextCursor c = targetFile->cursor();
2763                 c.setPosition(targetPos);
2764                 c.movePosition(QTextCursor::Down);
2765                 c.movePosition(QTextCursor::EndOfLine);
2766                 op->editor()->setTextCursor(c);
2767             }
2768         } else {
2769             // make target lookup context
2770             Document::Ptr targetDoc = targetFile->cppDocument();
2771             Scope *targetScope = targetDoc->scopeAt(loc.line(), loc.column());
2772 
2773             // Correct scope in case of a function try-block. See QTCREATORBUG-14661.
2774             if (targetScope && targetScope->asBlock()) {
2775                 if (Class * const enclosingClass = targetScope->enclosingClass())
2776                     targetScope = enclosingClass;
2777                 else
2778                     targetScope = targetScope->enclosingNamespace();
2779             }
2780 
2781             LookupContext targetContext(targetDoc, op->snapshot());
2782             ClassOrNamespace *targetCoN = targetContext.lookupType(targetScope);
2783             if (!targetCoN)
2784                 targetCoN = targetContext.globalNamespace();
2785 
2786             // setup rewriting to get minimally qualified names
2787             SubstitutionEnvironment env;
2788             env.setContext(op->context());
2789             env.switchScope(decl->enclosingScope());
2790             UseMinimalNames q(targetCoN);
2791             env.enter(&q);
2792             Control *control = op->context().bindings()->control().data();
2793 
2794             // rewrite the function type
2795             const FullySpecifiedType tn = rewriteType(decl->type(), &env, control);
2796 
2797             // rewrite the function name
2798             if (nameIncludesOperatorName(decl->name())) {
2799                 CppRefactoringFilePtr file = refactoring.file(op->filePath());
2800                 const QString operatorNameText = file->textOf(declAST->core_declarator);
2801                 oo.includeWhiteSpaceInOperatorName = operatorNameText.contains(QLatin1Char(' '));
2802             }
2803             const QString name = oo.prettyName(LookupContext::minimalName(decl, targetCoN,
2804                                                                           control));
2805             const QString defText = inlinePrefix(
2806                         targetFilePath, [defPos] { return defPos == DefPosOutsideClass; })
2807                     + oo.prettyType(tn, name)
2808                     + QLatin1String("\n{\n\n}");
2809 
2810             const int targetPos = targetFile->position(loc.line(), loc.column());
2811             const int targetPos2 = qMax(0, targetFile->position(loc.line(), 1) - 1);
2812 
2813             ChangeSet localChangeSet;
2814             ChangeSet * const target = changeSet ? changeSet : &localChangeSet;
2815             target->insert(targetPos,  loc.prefix() + defText + loc.suffix());
2816             const ChangeSet::Range indentRange(targetPos2, targetPos);
2817             if (indentRanges)
2818                 indentRanges->append(indentRange);
2819             else
2820                 targetFile->appendIndentRange(indentRange);
2821 
2822             if (!changeSet) {
2823                 targetFile->setChangeSet(*target);
2824                 targetFile->setOpenEditor(true, targetPos);
2825                 targetFile->apply();
2826 
2827                 // Move cursor inside definition
2828                 QTextCursor c = targetFile->cursor();
2829                 c.setPosition(targetPos);
2830                 c.movePosition(QTextCursor::Down, QTextCursor::MoveAnchor,
2831                                loc.prefix().count(QLatin1String("\n")) + 2);
2832                 c.movePosition(QTextCursor::EndOfLine);
2833                 if (defPos == DefPosImplementationFile) {
2834                     if (targetFile->editor())
2835                         targetFile->editor()->setTextCursor(c);
2836                 } else {
2837                     op->editor()->setTextCursor(c);
2838                 }
2839             }
2840         }
2841     }
2842 
2843 private:
2844     void perform() override
2845     {
2846         insertDefinition(this, m_loc, m_defpos, m_declAST, m_decl, m_targetFileName);
2847     }
2848 
2849     Declaration *m_decl;
2850     DeclaratorAST *m_declAST;
2851     InsertionLocation m_loc;
2852     const DefPos m_defpos;
2853     const QString m_targetFileName;
2854 };
2855 
2856 } // anonymous namespace
2857 
2858 void InsertDefFromDecl::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
2859 {
2860     const QList<AST *> &path = interface.path();
2861 
2862     int idx = path.size() - 1;
2863     for (; idx >= 0; --idx) {
2864         AST *node = path.at(idx);
2865         if (SimpleDeclarationAST *simpleDecl = node->asSimpleDeclaration()) {
2866             if (idx > 0 && path.at(idx - 1)->asStatement())
2867                 return;
2868             if (simpleDecl->symbols && !simpleDecl->symbols->next) {
2869                 if (Symbol *symbol = simpleDecl->symbols->value) {
2870                     if (Declaration *decl = symbol->asDeclaration()) {
2871                         if (Function *func = decl->type()->asFunctionType()) {
2872                             if (func->isSignal() || func->isPureVirtual() || func->isFriend())
2873                                 return;
2874 
2875                             // Check if there is already a definition
2876                             SymbolFinder symbolFinder;
2877                             if (symbolFinder.findMatchingDefinition(decl, interface.snapshot(),
2878                                                                     true)) {
2879                                 return;
2880                             }
2881 
2882                             // Insert Position: Implementation File
2883                             DeclaratorAST *declAST = simpleDecl->declarator_list->value;
2884                             InsertDefOperation *op = nullptr;
2885                             ProjectFile::Kind kind = ProjectFile::classify(interface.filePath().toString());
2886                             const bool isHeaderFile = ProjectFile::isHeader(kind);
2887                             if (isHeaderFile) {
2888                                 CppRefactoringChanges refactoring(interface.snapshot());
2889                                 InsertionPointLocator locator(refactoring);
2890                                 // find appropriate implementation file, but do not use this
2891                                 // location, because insertLocationForMethodDefinition() should
2892                                 // be used in perform() to get consistent insert positions.
2893                                 foreach (const InsertionLocation &location,
2894                                          locator.methodDefinition(decl, false, QString())) {
2895                                     if (!location.isValid())
2896                                         continue;
2897 
2898                                     const QString fileName = location.fileName();
2899                                     if (ProjectFile::isHeader(ProjectFile::classify(fileName))) {
2900                                         const QString source
2901                                                 = correspondingHeaderOrSource(fileName);
2902                                         if (!source.isEmpty()) {
2903                                             op = new InsertDefOperation(interface, decl, declAST,
2904                                                                         InsertionLocation(),
2905                                                                         DefPosImplementationFile,
2906                                                                         source);
2907                                         }
2908                                     } else {
2909                                         op = new InsertDefOperation(interface, decl, declAST,
2910                                                                     InsertionLocation(),
2911                                                                     DefPosImplementationFile,
2912                                                                     fileName);
2913                                     }
2914 
2915                                     if (op)
2916                                         result << op;
2917                                     break;
2918                                 }
2919                             }
2920 
2921                             // Determine if we are dealing with a free function
2922                             const bool isFreeFunction = func->enclosingClass() == nullptr;
2923 
2924                             // Insert Position: Outside Class
2925                             if (!isFreeFunction) {
2926                                 result << new InsertDefOperation(interface, decl, declAST,
2927                                                                  InsertionLocation(),
2928                                                                  DefPosOutsideClass,
2929                                                                  interface.filePath().toString());
2930                             }
2931 
2932                             // Insert Position: Inside Class
2933                             // Determine insert location direct after the declaration.
2934                             int line, column;
2935                             const CppRefactoringFilePtr file = interface.currentFile();
2936                             file->lineAndColumn(file->endOf(simpleDecl), &line, &column);
2937                             const InsertionLocation loc
2938                                     = InsertionLocation(interface.filePath().toString(), QString(),
2939                                                         QString(), line, column);
2940                             result << new InsertDefOperation(interface, decl, declAST, loc,
2941                                                              DefPosInsideClass, QString(),
2942                                                              isFreeFunction);
2943 
2944                             return;
2945                         }
2946                     }
2947                 }
2948             }
2949             break;
2950         }
2951     }
2952 }
2953 
2954 class InsertMemberFromInitializationOp : public CppQuickFixOperation
2955 {
2956 public:
2957     InsertMemberFromInitializationOp(
2958             const CppQuickFixInterface &interface,
2959             const Class *theClass,
2960             const QString &member,
2961             const QString &type)
2962         : CppQuickFixOperation(interface), m_class(theClass), m_member(member), m_type(type)
2963     {
2964         setDescription(QCoreApplication::translate("CppEditor::Quickfix",
2965                                                    "Add Class Member \"%1\"").arg(m_member));
2966     }
2967 
2968 private:
2969     void perform() override
2970     {
2971         QString type = m_type;
2972         if (type.isEmpty()) {
2973             type = QInputDialog::getText(
2974                         Core::ICore::dialogParent(),
2975                         QCoreApplication::translate("CppEditor::Quickfix","Provide the type"),
2976                         QCoreApplication::translate("CppEditor::Quickfix","Data type:"),
2977                         QLineEdit::Normal);
2978         }
2979         if (type.isEmpty())
2980             return;
2981 
2982         const CppRefactoringChanges refactoring(snapshot());
2983         const InsertionPointLocator locator(refactoring);
2984         const QString filePath = QString::fromUtf8(m_class->fileName());
2985         const InsertionLocation loc = locator.methodDeclarationInClass(
2986                     filePath, m_class, InsertionPointLocator::Private);
2987         QTC_ASSERT(loc.isValid(), return);
2988 
2989         CppRefactoringFilePtr targetFile = refactoring.file(Utils::FilePath::fromString(filePath));
2990         const int targetPosition1 = targetFile->position(loc.line(), loc.column());
2991         const int targetPosition2 = qMax(0, targetFile->position(loc.line(), 1) - 1);
2992         ChangeSet target;
2993         target.insert(targetPosition1, loc.prefix() + type + ' ' + m_member + ";\n");
2994         targetFile->setChangeSet(target);
2995         targetFile->appendIndentRange(ChangeSet::Range(targetPosition2, targetPosition1));
2996         targetFile->apply();
2997     }
2998 
2999     const Class * const m_class;
3000     const QString m_member;
3001     const QString m_type;
3002 };
3003 
3004 void InsertMemberFromInitialization::match(const CppQuickFixInterface &interface,
3005                                            QuickFixOperations &result)
3006 {
3007     // First check whether we are on a member initialization.
3008     const QList<AST *> path = interface.path();
3009     const int size = path.size();
3010     if (size < 4)
3011         return;
3012     const SimpleNameAST * const name = path.at(size - 1)->asSimpleName();
3013     if (!name)
3014         return;
3015     const MemInitializerAST * const memInitializer = path.at(size - 2)->asMemInitializer();
3016     if (!memInitializer)
3017         return;
3018     if (!path.at(size - 3)->asCtorInitializer())
3019         return;
3020     const FunctionDefinitionAST * ctor = path.at(size - 4)->asFunctionDefinition();
3021     if (!ctor)
3022         return;
3023 
3024     // Now find the class.
3025     const Class *theClass = nullptr;
3026     if (size > 4) {
3027         const ClassSpecifierAST * const classSpec = path.at(size - 5)->asClassSpecifier();
3028         if (classSpec) // Inline constructor. We get the class directly.
3029             theClass = classSpec->symbol;
3030     }
3031     if (!theClass) {
3032         // Out-of-line constructor. We need to find the class.
3033         SymbolFinder finder;
3034         const QList<Declaration *> matches = finder.findMatchingDeclaration(
3035                     LookupContext(interface.currentFile()->cppDocument(), interface.snapshot()),
3036                     ctor->symbol);
3037         if (!matches.isEmpty())
3038             theClass = matches.first()->enclosingClass();
3039     }
3040 
3041     if (!theClass)
3042         return;
3043 
3044     // Check whether the member exists already.
3045     if (theClass->find(interface.currentFile()->cppDocument()->translationUnit()->identifier(
3046                            name->identifier_token))) {
3047         return;
3048     }
3049 
3050     const QString type = getType(interface, memInitializer, ctor);
3051     const Identifier * const memberId = interface.currentFile()->cppDocument()
3052             ->translationUnit()->identifier(name->identifier_token);
3053     const QString member = QString::fromUtf8(memberId->chars(), memberId->size());
3054 
3055     result << new InsertMemberFromInitializationOp(interface, theClass, member, type);
3056 }
3057 
3058 QString InsertMemberFromInitialization::getType(
3059         const CppQuickFixInterface &interface,
3060         const MemInitializerAST *memInitializer,
3061         const FunctionDefinitionAST *ctor) const
3062 {
3063     // Try to deduce the type: If the initialization expression is just a name
3064     // (e.g. a constructor argument) or a function call, we don't bother the user.
3065     if (!memInitializer->expression)
3066         return {};
3067     const ExpressionListParenAST * const lParenAst
3068             = memInitializer->expression->asExpressionListParen();
3069     if (!lParenAst || !lParenAst->expression_list || !lParenAst->expression_list->value)
3070         return {};
3071     const IdExpressionAST *idExpr = lParenAst->expression_list->value->asIdExpression();
3072     if (!idExpr) { // Not a variable, so check for function call.
3073         const CallAST * const call = lParenAst->expression_list->value->asCall();
3074         if (!call || !call->base_expression)
3075             return {};
3076         idExpr = call->base_expression->asIdExpression();
3077     }
3078     if (!idExpr || !idExpr->name)
3079         return {};
3080 
3081     LookupContext context(interface.currentFile()->cppDocument(), interface.snapshot());
3082     const QList<LookupItem> matches = context.lookup(idExpr->name->name, ctor->symbol);
3083     if (matches.isEmpty())
3084         return {};
3085     Overview o = CppCodeStyleSettings::currentProjectCodeStyleOverview();
3086     TypePrettyPrinter tpp(&o);
3087     FullySpecifiedType type = matches.first().type();
3088     if (!type.type())
3089         return {};
3090     const Function * const funcType = type.type()->asFunctionType();
3091     if (funcType)
3092         type = funcType->returnType();
3093     return tpp(type);
3094 }
3095 
3096 class MemberFunctionImplSetting
3097 {
3098 public:
3099     Symbol *func = nullptr;
3100     DefPos defPos = DefPosImplementationFile;
3101 };
3102 using MemberFunctionImplSettings = QList<MemberFunctionImplSetting>;
3103 
3104 class AddImplementationsDialog : public QDialog
3105 {
3106     Q_DECLARE_TR_FUNCTIONS(AddImplementationsDialog)
3107 public:
3108     AddImplementationsDialog(const QList<Symbol *> &candidates, const Utils::FilePath &implFile)
3109         : QDialog(Core::ICore::dialogParent()), m_candidates(candidates)
3110     {
3111         setWindowTitle(tr("Member Function Implementations"));
3112 
3113         const auto defaultImplTargetComboBox = new QComboBox;
3114         QStringList implTargetStrings{tr("None"), tr("Inline"), tr("Outside Class")};
3115         if (!implFile.isEmpty())
3116             implTargetStrings.append(implFile.fileName());
3117         defaultImplTargetComboBox->insertItems(0, implTargetStrings);
3118         connect(defaultImplTargetComboBox, qOverload<int>(&QComboBox::currentIndexChanged), this,
3119                 [this](int index) {
3120             for (int i = 0; i < m_implTargetBoxes.size(); ++i) {
3121                 if (!m_candidates.at(i)->type()->asFunctionType()->isPureVirtual())
3122                     static_cast<QComboBox *>(m_implTargetBoxes.at(i))->setCurrentIndex(index);
3123             }
3124         });
3125         const auto defaultImplTargetLayout = new QHBoxLayout;
3126         defaultImplTargetLayout->addWidget(new QLabel(tr("Default implementation location:")));
3127         defaultImplTargetLayout->addWidget(defaultImplTargetComboBox);
3128 
3129         const auto candidatesLayout = new QGridLayout;
3130         Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
3131         oo.showFunctionSignatures = true;
3132         oo.showReturnTypes = true;
3133         for (int i = 0; i < m_candidates.size(); ++i) {
3134             const Function * const func = m_candidates.at(i)->type()->asFunctionType();
3135             QTC_ASSERT(func, continue);
3136             const auto implTargetComboBox = new QComboBox;
3137             m_implTargetBoxes.append(implTargetComboBox);
3138             implTargetComboBox->insertItems(0, implTargetStrings);
3139             if (func->isPureVirtual())
3140                 implTargetComboBox->setCurrentIndex(0);
3141             candidatesLayout->addWidget(new QLabel(oo.prettyType(func->type(), func->name())),
3142                                         i, 0);
3143             candidatesLayout->addWidget(implTargetComboBox, i, 1);
3144         }
3145 
3146         const auto buttonBox
3147                 = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
3148         connect(buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
3149         connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);
3150 
3151         defaultImplTargetComboBox->setCurrentIndex(implTargetStrings.size() - 1);
3152         const auto mainLayout = new QVBoxLayout(this);
3153         mainLayout->addLayout(defaultImplTargetLayout);
3154         const auto separator = new QFrame();
3155         separator->setFrameShape(QFrame::HLine);
3156         mainLayout->addWidget(separator);
3157         mainLayout->addLayout(candidatesLayout);
3158         mainLayout->addWidget(buttonBox);
3159     }
3160 
3161     MemberFunctionImplSettings settings() const
3162     {
3163         QTC_ASSERT(m_candidates.size() == m_implTargetBoxes.size(), return {});
3164         MemberFunctionImplSettings settings;
3165         for (int i = 0; i < m_candidates.size(); ++i) {
3166             MemberFunctionImplSetting setting;
3167             const int index = m_implTargetBoxes.at(i)->currentIndex();
3168             const bool addImplementation = index != 0;
3169             if (!addImplementation)
3170                 continue;
3171             setting.func = m_candidates.at(i);
3172             setting.defPos = static_cast<DefPos>(index - 1);
3173             settings << setting;
3174         }
3175         return settings;
3176     }
3177 
3178 private:
3179     const QList<Symbol *> m_candidates;
3180     QList<QComboBox *> m_implTargetBoxes;
3181 };
3182 
3183 class InsertDefsOperation: public CppQuickFixOperation
3184 {
3185 public:
3186     InsertDefsOperation(const CppQuickFixInterface &interface)
3187         : CppQuickFixOperation(interface)
3188     {
3189         setDescription(CppQuickFixFactory::tr("Create Implementations for Member Functions"));
3190 
3191         m_classAST = astForClassOperations(interface);
3192         if (!m_classAST)
3193             return;
3194         const Class * const theClass = m_classAST->symbol;
3195         if (!theClass)
3196             return;
3197 
3198         // Collect all member functions.
3199         for (auto it = theClass->memberBegin(); it != theClass->memberEnd(); ++it) {
3200             Symbol * const s = *it;
3201             if (!s->identifier() || !s->type() || !s->isDeclaration() || s->asFunction())
3202                 continue;
3203             Function * const func = s->type()->asFunctionType();
3204             if (!func || func->isSignal() || func->isFriend())
3205                 continue;
3206             Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
3207             oo.showFunctionSignatures = true;
3208             if (magicQObjectFunctions().contains(oo.prettyName(func->name())))
3209                 continue;
3210             m_declarations << s;
3211         }
3212     }
3213 
3214     bool isApplicable() const { return !m_declarations.isEmpty(); }
3215     void setMode(InsertDefsFromDecls::Mode mode) { m_mode = mode; }
3216 
3217 private:
3218     void perform() override
3219     {
3220         QList<Symbol *> unimplemented;
3221         SymbolFinder symbolFinder;
3222         for (Symbol * const s : qAsConst(m_declarations)) {
3223             if (!symbolFinder.findMatchingDefinition(s, snapshot()))
3224                 unimplemented << s;
3225         }
3226         if (unimplemented.isEmpty())
3227             return;
3228 
3229         CppRefactoringChanges refactoring(snapshot());
3230         const bool isHeaderFile = ProjectFile::isHeader(ProjectFile::classify(filePath().toString()));
3231         QString cppFile; // Only set if the class is defined in a header file.
3232         if (isHeaderFile) {
3233             InsertionPointLocator locator(refactoring);
3234             for (const InsertionLocation &location
3235                  : locator.methodDefinition(unimplemented.first(), false, {})) {
3236                 if (!location.isValid())
3237                     continue;
3238                 const QString fileName = location.fileName();
3239                 if (ProjectFile::isHeader(ProjectFile::classify(fileName))) {
3240                     const QString source = correspondingHeaderOrSource(fileName);
3241                     if (!source.isEmpty())
3242                         cppFile = source;
3243                 } else {
3244                     cppFile = fileName;
3245                 }
3246                 break;
3247             }
3248         }
3249 
3250         MemberFunctionImplSettings settings;
3251         switch (m_mode) {
3252         case InsertDefsFromDecls::Mode::User: {
3253             AddImplementationsDialog dlg(unimplemented, Utils::FilePath::fromString(cppFile));
3254             if (dlg.exec() == QDialog::Accepted)
3255                 settings = dlg.settings();
3256             break;
3257         }
3258         case InsertDefsFromDecls::Mode::Alternating: {
3259             int defPos = DefPosImplementationFile;
3260             const auto incDefPos = [&defPos] {
3261                 defPos = (defPos + 1) % (DefPosImplementationFile + 2);
3262             };
3263             for (Symbol * const func : qAsConst(unimplemented)) {
3264                 incDefPos();
3265                 if (defPos > DefPosImplementationFile)
3266                     continue;
3267                 MemberFunctionImplSetting setting;
3268                 setting.func = func;
3269                 setting.defPos = static_cast<DefPos>(defPos);
3270                 settings << setting;
3271             }
3272             break;
3273         }
3274         case InsertDefsFromDecls::Mode::Off:
3275             break;
3276         }
3277 
3278         if (settings.isEmpty())
3279             return;
3280 
3281         class DeclFinder : public ASTVisitor
3282         {
3283         public:
3284             DeclFinder(const CppRefactoringFile *file, const Symbol *func)
3285                 : ASTVisitor(file->cppDocument()->translationUnit()), m_func(func) {}
3286 
3287             SimpleDeclarationAST *decl() const { return m_decl; }
3288 
3289         private:
3290             bool visit(SimpleDeclarationAST *decl) override
3291             {
3292                 if (m_decl)
3293                     return false;
3294                 if (decl->symbols && decl->symbols->value == m_func)
3295                     m_decl = decl;
3296                 return !m_decl;
3297             }
3298 
3299             const Symbol * const m_func;
3300             SimpleDeclarationAST *m_decl = nullptr;
3301         };
3302 
3303         QHash<QString, QPair<ChangeSet, QList<ChangeSet::Range>>> changeSets;
3304         for (const MemberFunctionImplSetting &setting : qAsConst(settings)) {
3305             DeclFinder finder(currentFile().data(), setting.func);
3306             finder.accept(m_classAST);
3307             QTC_ASSERT(finder.decl(), continue);
3308             InsertionLocation loc;
3309             const QString targetFilePath = setting.defPos == DefPosImplementationFile
3310                     ? cppFile : filePath().toString();
3311             QTC_ASSERT(!targetFilePath.isEmpty(), continue);
3312             if (setting.defPos == DefPosInsideClass) {
3313                 int line, column;
3314                 currentFile()->lineAndColumn(currentFile()->endOf(finder.decl()), &line, &column);
3315                 loc = InsertionLocation(filePath().toString(), QString(), QString(), line, column);
3316             }
3317             auto &changeSet = changeSets[targetFilePath];
3318             InsertDefOperation::insertDefinition(
3319                         this, loc, setting.defPos, finder.decl()->declarator_list->value,
3320                         setting.func->asDeclaration(),targetFilePath,
3321                         &changeSet.first, &changeSet.second);
3322         }
3323         for (auto it = changeSets.cbegin(); it != changeSets.cend(); ++it) {
3324             const CppRefactoringFilePtr file = refactoring.file(
3325                 Utils::FilePath::fromString(it.key()));
3326             for (const ChangeSet::Range &r : it.value().second)
3327                 file->appendIndentRange(r);
3328             file->setChangeSet(it.value().first);
3329             file->apply();
3330         }
3331     }
3332 
3333     ClassSpecifierAST *m_classAST = nullptr;
3334     InsertDefsFromDecls::Mode m_mode;
3335     QList<Symbol *> m_declarations;
3336 };
3337 
3338 
3339 void InsertDefsFromDecls::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
3340 {
3341     const auto op = QSharedPointer<InsertDefsOperation>::create(interface);
3342     op->setMode(m_mode);
3343     if (op->isApplicable())
3344         result << op;
3345 }
3346 
3347 namespace {
3348 
3349 Utils::optional<FullySpecifiedType> getFirstTemplateParameter(const Name *name)
3350 {
3351     if (const QualifiedNameId *qualifiedName = name->asQualifiedNameId())
3352         return getFirstTemplateParameter(qualifiedName->name());
3353 
3354     if (const TemplateNameId *templateName = name->asTemplateNameId()) {
3355         if (templateName->templateArgumentCount() > 0)
3356             return templateName->templateArgumentAt(0).type();
3357     }
3358     return {};
3359 }
3360 
3361 Utils::optional<FullySpecifiedType> getFirstTemplateParameter(Type *type)
3362 {
3363     if (NamedType *namedType = type->asNamedType())
3364         return getFirstTemplateParameter(namedType->name());
3365 
3366     return {};
3367 }
3368 
3369 Utils::optional<FullySpecifiedType> getFirstTemplateParameter(FullySpecifiedType type)
3370 {
3371     return getFirstTemplateParameter(type.type());
3372 }
3373 
3374 QString symbolAtDifferentLocation(const CppQuickFixInterface &interface,
3375                                   Symbol *symbol,
3376                                   const CppRefactoringFilePtr &targetFile,
3377                                   InsertionLocation targetLocation)
3378 {
3379     QTC_ASSERT(symbol, return QString());
3380     Scope *scopeAtInsertPos = targetFile->cppDocument()->scopeAt(targetLocation.line(),
3381                                                                  targetLocation.column());
3382 
3383     LookupContext cppContext(targetFile->cppDocument(), interface.snapshot());
3384     ClassOrNamespace *cppCoN = cppContext.lookupType(scopeAtInsertPos);
3385     if (!cppCoN)
3386         cppCoN = cppContext.globalNamespace();
3387     SubstitutionEnvironment env;
3388     env.setContext(interface.context());
3389     env.switchScope(symbol->enclosingScope());
3390     UseMinimalNames q(cppCoN);
3391     env.enter(&q);
3392     Control *control = interface.context().bindings()->control().data();
3393     Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
3394     return oo.prettyName(LookupContext::minimalName(symbol, cppCoN, control));
3395 }
3396 
3397 FullySpecifiedType typeAtDifferentLocation(const CppQuickFixInterface &interface,
3398                                            FullySpecifiedType type,
3399                                            Scope *originalScope,
3400                                            const CppRefactoringFilePtr &targetFile,
3401                                            InsertionLocation targetLocation,
3402                                            const QStringList &newNamespaceNamesAtLoc = {})
3403 {
3404     Scope *scopeAtInsertPos = targetFile->cppDocument()->scopeAt(targetLocation.line(),
3405                                                                  targetLocation.column());
3406     for (const QString &nsName : newNamespaceNamesAtLoc) {
3407         const QByteArray utf8Name = nsName.toUtf8();
3408         Control *control = targetFile->cppDocument()->control();
3409         const Name *name = control->identifier(utf8Name.data(), utf8Name.size());
3410         Namespace *ns = control->newNamespace(0, name);
3411         ns->setEnclosingScope(scopeAtInsertPos);
3412         scopeAtInsertPos = ns;
3413     }
3414     LookupContext cppContext(targetFile->cppDocument(), interface.snapshot());
3415     ClassOrNamespace *cppCoN = cppContext.lookupType(scopeAtInsertPos);
3416     if (!cppCoN)
3417         cppCoN = cppContext.globalNamespace();
3418     SubstitutionEnvironment env;
3419     env.setContext(interface.context());
3420     env.switchScope(originalScope);
3421     UseMinimalNames q(cppCoN);
3422     env.enter(&q);
3423     Control *control = interface.context().bindings()->control().data();
3424     return rewriteType(type, &env, control);
3425 }
3426 
3427 struct ExistingGetterSetterData
3428 {
3429     Class *clazz = nullptr;
3430     Declaration *declarationSymbol = nullptr;
3431     QString getterName;
3432     QString setterName;
3433     QString resetName;
3434     QString signalName;
3435     QString qPropertyName;
3436     QString memberVariableName;
3437     Document::Ptr doc;
3438 
3439     int computePossibleFlags() const;
3440 };
3441 
3442 class GetterSetterRefactoringHelper
3443 {
3444 public:
3445     GetterSetterRefactoringHelper(CppQuickFixOperation *operation,
3446                                   const QString &fileName,
3447                                   Class *clazz)
3448         : m_operation(operation)
3449         , m_changes(m_operation->snapshot())
3450         , m_locator(m_changes)
3451         , m_headerFile(m_changes.file(Utils::FilePath::fromString(fileName)))
3452         , m_sourceFile([&] {
3453             QString cppFileName = correspondingHeaderOrSource(fileName, &m_isHeaderHeaderFile);
3454             if (!m_isHeaderHeaderFile || !QFile::exists(cppFileName)) {
3455                 // there is no "source" file
3456                 return m_headerFile;
3457             } else {
3458                 return m_changes.file(Utils::FilePath::fromString(cppFileName));
3459             }
3460         }())
3461         , m_class(clazz)
3462     {}
3463 
3464     void performGeneration(ExistingGetterSetterData data, int generationFlags);
3465 
3466     void applyChanges()
3467     {
3468         const auto classLayout = {
3469             InsertionPointLocator::Public,
3470             InsertionPointLocator::PublicSlot,
3471             InsertionPointLocator::Signals,
3472             InsertionPointLocator::Protected,
3473             InsertionPointLocator::ProtectedSlot,
3474             InsertionPointLocator::PrivateSlot,
3475             InsertionPointLocator::Private,
3476         };
3477         for (auto spec : classLayout) {
3478             const auto iter = m_headerFileCode.find(spec);
3479             if (iter != m_headerFileCode.end()) {
3480                 const InsertionLocation loc = headerLocationFor(spec);
3481                 m_headerFile->setOpenEditor(true, m_headerFile->position(loc.line(), loc.column()));
3482                 insertAndIndent(m_headerFile, loc, *iter);
3483             }
3484         }
3485         if (!m_sourceFileCode.isEmpty() && m_sourceFileInsertionPoint.isValid()) {
3486             m_sourceFile->setOpenEditor(true, m_sourceFile->position(
3487                                             m_sourceFileInsertionPoint.line(),
3488                                             m_sourceFileInsertionPoint.column()));
3489             insertAndIndent(m_sourceFile, m_sourceFileInsertionPoint, m_sourceFileCode);
3490         }
3491 
3492         if (!m_headerFileChangeSet.isEmpty()) {
3493             m_headerFile->setChangeSet(m_headerFileChangeSet);
3494             m_headerFile->apply();
3495         }
3496         if (!m_sourceFileChangeSet.isEmpty()) {
3497             m_sourceFile->setChangeSet(m_sourceFileChangeSet);
3498             m_sourceFile->apply();
3499         }
3500     }
3501 
3502     bool hasSourceFile() const { return m_headerFile != m_sourceFile; }
3503     bool isHeaderHeaderFile() const { return m_isHeaderHeaderFile; }
3504 
3505 protected:
3506     void insertAndIndent(const RefactoringFilePtr &file,
3507                          const InsertionLocation &loc,
3508                          const QString &text)
3509     {
3510         int targetPosition1 = file->position(loc.line(), loc.column());
3511         int targetPosition2 = qMax(0, file->position(loc.line(), 1) - 1);
3512         ChangeSet &changeSet = file == m_headerFile ? m_headerFileChangeSet : m_sourceFileChangeSet;
3513         changeSet.insert(targetPosition1, loc.prefix() + text + loc.suffix());
3514         file->appendIndentRange(ChangeSet::Range(targetPosition2, targetPosition1));
3515     }
3516 
3517     FullySpecifiedType makeConstRef(FullySpecifiedType type)
3518     {
3519         type.setConst(true);
3520         return m_operation->currentFile()->cppDocument()->control()->referenceType(type, false);
3521     }
3522 
3523     FullySpecifiedType addConstToReference(FullySpecifiedType type)
3524     {
3525         if (ReferenceType *ref = type.type()->asReferenceType()) {
3526             FullySpecifiedType elemType = ref->elementType();
3527             if (elemType.isConst())
3528                 return type;
3529             elemType.setConst(true);
3530             return m_operation->currentFile()->cppDocument()->control()->referenceType(elemType,
3531                                                                                        false);
3532         }
3533         return type;
3534     }
3535 
3536     QString symbolAt(Symbol *symbol,
3537                      const CppRefactoringFilePtr &targetFile,
3538                      InsertionLocation targetLocation)
3539     {
3540         return symbolAtDifferentLocation(*m_operation, symbol, targetFile, targetLocation);
3541     }
3542 
3543     FullySpecifiedType typeAt(FullySpecifiedType type,
3544                               Scope *originalScope,
3545                               const CppRefactoringFilePtr &targetFile,
3546                               InsertionLocation targetLocation,
3547                               const QStringList &newNamespaceNamesAtLoc = {})
3548     {
3549         return typeAtDifferentLocation(*m_operation,
3550                                        type,
3551                                        originalScope,
3552                                        targetFile,
3553                                        targetLocation,
3554                                        newNamespaceNamesAtLoc);
3555     }
3556 
3557     /**
3558      * @brief checks if the type in the enclosing scope in the header is a value type
3559      * @param type a type in the m_headerFile
3560      * @param enclosingScope the enclosing scope
3561      * @param customValueType if not nullptr set to true when value type comes
3562      * from CppQuickFixSettings::isValueType
3563      * @return true if it is a pointer, enum, integer, floating point, reference, custom value type
3564      */
3565     bool isValueType(FullySpecifiedType type, Scope *enclosingScope, bool *customValueType = nullptr)
3566     {
3567         if (customValueType)
3568             *customValueType = false;
3569         // a type is a value type if it is one of the following
3570         const auto isTypeValueType = [](const FullySpecifiedType &t) {
3571             return t->isPointerType() || t->isEnumType() || t->isIntegerType() || t->isFloatType()
3572                    || t->isReferenceType();
3573         };
3574         if (type->isNamedType()) {
3575             // we need a recursive search and a lookup context
3576             LookupContext context(m_headerFile->cppDocument(), m_changes.snapshot());
3577             auto isValueType = [settings = m_settings,
3578                                 &customValueType,
3579                                 &context,
3580                                 &isTypeValueType](const Name *name,
3581                                                   Scope *scope,
3582                                                   auto &isValueType) mutable -> bool {
3583                 // maybe the type is a custom value type by name
3584                 if (const Identifier *id = name->identifier()) {
3585                     if (settings->isValueType(QString::fromUtf8(id->chars(), id->size()))) {
3586                         if (customValueType)
3587                             *customValueType = true;
3588                         return true;
3589                     }
3590                 }
3591                 // search for the type declaration
3592                 QList<LookupItem> localLookup = context.lookup(name, scope);
3593                 for (auto &&i : localLookup) {
3594                     if (isTypeValueType(i.type()))
3595                         return true;
3596                     if (i.type()->isNamedType()) { // check if we have to search recursively
3597                         const Name *newName = i.type()->asNamedType()->name();
3598                         Scope *newScope = i.declaration()->enclosingScope();
3599                         if (Matcher::match(newName, name)
3600                                 && Matcher::match(newScope->name(), scope->name())) {
3601                             continue; // we have found the start location of the search
3602                         }
3603                         return isValueType(newName, newScope, isValueType);
3604                     }
3605                     return false;
3606                 }
3607                 return false;
3608             };
3609             // start recursion
3610             return isValueType(type->asNamedType()->name(), enclosingScope, isValueType);
3611         }
3612         return isTypeValueType(type);
3613     }
3614 
3615     bool isValueType(Symbol *symbol, bool *customValueType = nullptr)
3616     {
3617         return isValueType(symbol->type(), symbol->enclosingScope(), customValueType);
3618     }
3619 
3620     void addHeaderCode(InsertionPointLocator::AccessSpec spec, QString code)
3621     {
3622         QString &existing = m_headerFileCode[spec];
3623         existing += code;
3624         if (!existing.endsWith('\n'))
3625             existing += '\n';
3626     }
3627 
3628     InsertionLocation headerLocationFor(InsertionPointLocator::AccessSpec spec)
3629     {
3630         const auto insertionPoint = m_headerInsertionPoints.find(spec);
3631         if (insertionPoint != m_headerInsertionPoints.end())
3632             return *insertionPoint;
3633         const InsertionLocation loc = m_locator.methodDeclarationInClass(
3634                     m_headerFile->filePath().toString(), m_class, spec,
3635                     InsertionPointLocator::ForceAccessSpec::Yes);
3636         m_headerInsertionPoints.insert(spec, loc);
3637         return loc;
3638     }
3639 
3640     InsertionLocation sourceLocationFor(Symbol *symbol, QStringList *insertedNamespaces = nullptr)
3641     {
3642         if (m_sourceFileInsertionPoint.isValid())
3643             return m_sourceFileInsertionPoint;
3644         m_sourceFileInsertionPoint
3645             = insertLocationForMethodDefinition(symbol,
3646                                                 false,
3647                                                 m_settings->createMissingNamespacesinCppFile()
3648                                                     ? NamespaceHandling::CreateMissing
3649                                                     : NamespaceHandling::Ignore,
3650                                                 m_changes,
3651                                                 m_sourceFile->filePath().toString(),
3652                                                 insertedNamespaces);
3653         if (m_settings->addUsingNamespaceinCppFile()) {
3654             // check if we have to insert a using namespace ...
3655             auto requiredNamespaces = getNamespaceNames(
3656                 symbol->isClass() ? symbol : symbol->enclosingClass());
3657             NSCheckerVisitor visitor(m_sourceFile.get(),
3658                                      requiredNamespaces,
3659                                      m_sourceFile->position(m_sourceFileInsertionPoint.line(),
3660                                                             m_sourceFileInsertionPoint.column()));
3661             visitor.accept(m_sourceFile->cppDocument()->translationUnit()->ast());
3662             if (insertedNamespaces)
3663                 insertedNamespaces->clear();
3664             if (auto rns = visitor.remainingNamespaces(); !rns.empty()) {
3665                 QString ns = "using namespace ";
3666                 for (auto &n : rns) {
3667                     if (!n.isEmpty()) { // we have to ignore unnamed namespaces
3668                         ns += n;
3669                         ns += "::";
3670                         if (insertedNamespaces)
3671                             insertedNamespaces->append(n);
3672                     }
3673                 }
3674                 ns.resize(ns.size() - 2); // remove last '::'
3675                 ns += ";\n";
3676                 const auto &loc = m_sourceFileInsertionPoint;
3677                 m_sourceFileInsertionPoint = InsertionLocation(loc.fileName(),
3678                                                                loc.prefix() + ns,
3679                                                                loc.suffix(),
3680                                                                loc.line(),
3681                                                                loc.column());
3682             }
3683         }
3684         return m_sourceFileInsertionPoint;
3685     }
3686 
3687     void addSourceFileCode(QString code)
3688     {
3689         while (!m_sourceFileCode.isEmpty() && !m_sourceFileCode.endsWith("\n\n"))
3690             m_sourceFileCode += '\n';
3691         m_sourceFileCode += code;
3692     }
3693 
3694 protected:
3695     CppQuickFixOperation *const m_operation;
3696     const CppRefactoringChanges m_changes;
3697     const InsertionPointLocator m_locator;
3698     const CppRefactoringFilePtr m_headerFile;
3699     const CppRefactoringFilePtr m_sourceFile;
3700     CppQuickFixSettings *const m_settings = CppQuickFixProjectsSettings::getQuickFixSettings(
3701         ProjectExplorer::ProjectTree::currentProject());
3702     Class *const m_class;
3703 
3704 private:
3705     ChangeSet m_headerFileChangeSet;
3706     ChangeSet m_sourceFileChangeSet;
3707     QMap<InsertionPointLocator::AccessSpec, InsertionLocation> m_headerInsertionPoints;
3708     InsertionLocation m_sourceFileInsertionPoint;
3709     QString m_sourceFileCode;
3710     QMap<InsertionPointLocator::AccessSpec, QString> m_headerFileCode;
3711     bool m_isHeaderHeaderFile; // the "header" (where the class is defined) can be a source file
3712 };
3713 
3714 class GenerateGetterSetterOp : public CppQuickFixOperation
3715 {
3716 public:
3717     enum GenerateFlag {
3718         GenerateGetter = 1 << 0,
3719         GenerateSetter = 1 << 1,
3720         GenerateSignal = 1 << 2,
3721         GenerateMemberVariable = 1 << 3,
3722         GenerateReset = 1 << 4,
3723         GenerateProperty = 1 << 5,
3724         GenerateConstantProperty = 1 << 6,
3725         HaveExistingQProperty = 1 << 7,
3726     };
3727 
3728     GenerateGetterSetterOp(const CppQuickFixInterface &interface,
3729                            ExistingGetterSetterData data,
3730                            int generateFlags,
3731                            int priority,
3732                            const QString &description)
3733         : CppQuickFixOperation(interface)
3734         , m_generateFlags(generateFlags)
3735         , m_data(data)
3736     {
3737         setDescription(description);
3738         setPriority(priority);
3739     }
3740 
3741     static void generateQuickFixes(QuickFixOperations &results,
3742                                    const CppQuickFixInterface &interface,
3743                                    const ExistingGetterSetterData &data,
3744                                    const int possibleFlags)
3745     {
3746         // flags can have the value HaveExistingQProperty or a combination of all other values
3747         // of the enum 'GenerateFlag'
3748         int p = 0;
3749         if (possibleFlags & HaveExistingQProperty) {
3750             const auto desc = CppQuickFixFactory::tr("Generate Missing Q_PROPERTY Members");
3751             results << new GenerateGetterSetterOp(interface, data, possibleFlags, ++p, desc);
3752         } else {
3753             if (possibleFlags & GenerateSetter) {
3754                 const auto desc = CppQuickFixFactory::tr("Generate Setter");
3755                 results << new GenerateGetterSetterOp(interface, data, GenerateSetter, ++p, desc);
3756             }
3757             if (possibleFlags & GenerateGetter) {
3758                 const auto desc = CppQuickFixFactory::tr("Generate Getter");
3759                 results << new GenerateGetterSetterOp(interface, data, GenerateGetter, ++p, desc);
3760             }
3761             if (possibleFlags & GenerateGetter && possibleFlags & GenerateSetter) {
3762                 const auto desc = CppQuickFixFactory::tr("Generate Getter and Setter");
3763                 const auto flags = GenerateGetter | GenerateSetter;
3764                 results << new GenerateGetterSetterOp(interface, data, flags, ++p, desc);
3765             }
3766 
3767             if (possibleFlags & GenerateConstantProperty) {
3768                 const auto desc = CppQuickFixFactory::tr(
3769                     "Generate Constant Q_PROPERTY and Missing Members");
3770                 const auto flags = possibleFlags & ~(GenerateSetter | GenerateSignal | GenerateReset);
3771                 results << new GenerateGetterSetterOp(interface, data, flags, ++p, desc);
3772             }
3773             if (possibleFlags & GenerateProperty) {
3774                 if (possibleFlags & GenerateReset) {
3775                     const auto desc = CppQuickFixFactory::tr(
3776                         "Generate Q_PROPERTY and Missing Members with Reset Function");
3777                     const auto flags = possibleFlags & ~GenerateConstantProperty;
3778                     results << new GenerateGetterSetterOp(interface, data, flags, ++p, desc);
3779                 }
3780                 const auto desc = CppQuickFixFactory::tr("Generate Q_PROPERTY and Missing Members");
3781                 const auto flags = possibleFlags & ~GenerateConstantProperty & ~GenerateReset;
3782                 results << new GenerateGetterSetterOp(interface, data, flags, ++p, desc);
3783             }
3784         }
3785     }
3786 
3787     void perform() override
3788     {
3789         GetterSetterRefactoringHelper helper(this,
3790                                              currentFile()->filePath().toString(),
3791                                              m_data.clazz);
3792         helper.performGeneration(m_data, m_generateFlags);
3793         helper.applyChanges();
3794     }
3795 
3796 private:
3797     int m_generateFlags;
3798     ExistingGetterSetterData m_data;
3799 };
3800 
3801 int ExistingGetterSetterData::computePossibleFlags() const
3802 {
3803     const bool isConst = declarationSymbol->type().isConst();
3804     const bool isStatic = declarationSymbol->type().isStatic();
3805     using Flag = GenerateGetterSetterOp::GenerateFlag;
3806     int generateFlags = 0;
3807     if (getterName.isEmpty())
3808         generateFlags |= Flag::GenerateGetter;
3809     if (!isConst) {
3810         if (resetName.isEmpty())
3811             generateFlags |= Flag::GenerateReset;
3812         if (!isStatic && signalName.isEmpty() && setterName.isEmpty())
3813             generateFlags |= Flag::GenerateSignal;
3814         if (setterName.isEmpty())
3815             generateFlags |= Flag::GenerateSetter;
3816     }
3817     if (!isStatic) {
3818         const bool hasSignal = !signalName.isEmpty() || generateFlags & Flag::GenerateSignal;
3819         if (!isConst && hasSignal)
3820             generateFlags |= Flag::GenerateProperty;
3821     }
3822     if (setterName.isEmpty() && signalName.isEmpty())
3823         generateFlags |= Flag::GenerateConstantProperty;
3824     return generateFlags;
3825 }
3826 
3827 void GetterSetterRefactoringHelper::performGeneration(ExistingGetterSetterData data, int generateFlags)
3828 {
3829     using Flag = GenerateGetterSetterOp::GenerateFlag;
3830 
3831     if (generateFlags & Flag::GenerateGetter && data.getterName.isEmpty()) {
3832         data.getterName = m_settings->getGetterName(data.qPropertyName);
3833         if (data.getterName == data.memberVariableName) {
3834             data.getterName = "get" + data.memberVariableName.left(1).toUpper()
3835                               + data.memberVariableName.mid(1);
3836         }
3837     }
3838     if (generateFlags & Flag::GenerateSetter && data.setterName.isEmpty())
3839         data.setterName = m_settings->getSetterName(data.qPropertyName);
3840     if (generateFlags & Flag::GenerateSignal && data.signalName.isEmpty())
3841         data.signalName = m_settings->getSignalName(data.qPropertyName);
3842     if (generateFlags & Flag::GenerateReset && data.resetName.isEmpty())
3843         data.resetName = m_settings->getResetName(data.qPropertyName);
3844 
3845     FullySpecifiedType memberVariableType = data.declarationSymbol->type();
3846     memberVariableType.setConst(false);
3847     const bool isMemberVariableStatic = memberVariableType.isStatic();
3848     memberVariableType.setStatic(false);
3849     Overview overview = CppCodeStyleSettings::currentProjectCodeStyleOverview();
3850     overview.showTemplateParameters = false;
3851     // TODO does not work with using. e.g. 'using foo = std::unique_ptr<int>'
3852     // TODO must be fully qualified
3853     auto getSetTemplate = m_settings->findGetterSetterTemplate(overview.prettyType(memberVariableType));
3854     overview.showTemplateParameters = true;
3855 
3856     // Ok... - If a type is a Named type we have to search recusive for the real type
3857     const bool isValueType = this->isValueType(memberVariableType,
3858                                                data.declarationSymbol->enclosingScope());
3859     const FullySpecifiedType parameterType = isValueType ? memberVariableType
3860                                                          : makeConstRef(memberVariableType);
3861 
3862     QString baseName = memberBaseName(data.memberVariableName);
3863     if (baseName.isEmpty())
3864         baseName = data.memberVariableName;
3865 
3866     const QString parameterName = m_settings->getSetterParameterName(baseName);
3867     if (parameterName == data.memberVariableName)
3868         data.memberVariableName = "this->" + data.memberVariableName;
3869 
3870     getSetTemplate.replacePlaceholders(data.memberVariableName, parameterName);
3871 
3872     using Pattern = CppQuickFixSettings::GetterSetterTemplate;
3873     Utils::optional<FullySpecifiedType> returnTypeTemplateParameter;
3874     if (getSetTemplate.returnTypeTemplate.has_value()) {
3875         QString returnTypeTemplate = getSetTemplate.returnTypeTemplate.value();
3876         if (returnTypeTemplate.contains(Pattern::TEMPLATE_PARAMETER_PATTERN)) {
3877             returnTypeTemplateParameter = getFirstTemplateParameter(data.declarationSymbol->type());
3878             if (!returnTypeTemplateParameter.has_value())
3879                 return; // Maybe report error to the user
3880         }
3881     }
3882     const FullySpecifiedType returnTypeHeader = [&] {
3883         if (!getSetTemplate.returnTypeTemplate.has_value())
3884             return parameterType;
3885         QString typeTemplate = getSetTemplate.returnTypeTemplate.value();
3886         if (returnTypeTemplateParameter.has_value())
3887             typeTemplate.replace(Pattern::TEMPLATE_PARAMETER_PATTERN,
3888                                  overview.prettyType(returnTypeTemplateParameter.value()));
3889         if (typeTemplate.contains(Pattern::TYPE_PATTERN))
3890             typeTemplate.replace(Pattern::TYPE_PATTERN,
3891                                  overview.prettyType(data.declarationSymbol->type()));
3892         Control *control = m_operation->currentFile()->cppDocument()->control();
3893         std::string utf8TypeName = typeTemplate.toUtf8().toStdString();
3894         return FullySpecifiedType(control->namedType(control->identifier(utf8TypeName.c_str())));
3895     }();
3896 
3897     // getter declaration
3898     if (generateFlags & Flag::GenerateGetter) {
3899         // maybe we added 'this->' to memberVariableName because of a collision with parameterName
3900         // but here the 'this->' is not needed
3901         const QString returnExpression = QString{getSetTemplate.returnExpression}.replace("this->",
3902                                                                                           "");
3903         QString getterInClassDeclaration = overview.prettyType(returnTypeHeader, data.getterName)
3904                                            + QLatin1String("()");
3905         if (isMemberVariableStatic)
3906             getterInClassDeclaration.prepend(QLatin1String("static "));
3907         else
3908             getterInClassDeclaration += QLatin1String(" const");
3909         getterInClassDeclaration.prepend(m_settings->getterAttributes + QLatin1Char(' '));
3910 
3911         auto getterLocation = m_settings->determineGetterLocation(1);
3912         // if we have an anonymous class we must add code inside the class
3913         if (data.clazz->name()->isAnonymousNameId())
3914             getterLocation = CppQuickFixSettings::FunctionLocation::InsideClass;
3915 
3916         if (getterLocation == CppQuickFixSettings::FunctionLocation::InsideClass) {
3917             getterInClassDeclaration += QLatin1String("\n{\nreturn ") + returnExpression
3918                                         + QLatin1String(";\n}\n");
3919         } else {
3920             getterInClassDeclaration += QLatin1String(";\n");
3921         }
3922         addHeaderCode(InsertionPointLocator::Public, getterInClassDeclaration);
3923         if (getterLocation == CppQuickFixSettings::FunctionLocation::CppFile && !hasSourceFile())
3924             getterLocation = CppQuickFixSettings::FunctionLocation::OutsideClass;
3925 
3926         if (getterLocation != CppQuickFixSettings::FunctionLocation::InsideClass) {
3927             const auto getReturnTypeAt = [&](CppRefactoringFilePtr targetFile,
3928                                              InsertionLocation targetLoc) {
3929                 if (getSetTemplate.returnTypeTemplate.has_value()) {
3930                     QString returnType = getSetTemplate.returnTypeTemplate.value();
3931                     if (returnTypeTemplateParameter.has_value()) {
3932                         const QString templateTypeName = overview.prettyType(typeAt(
3933                             returnTypeTemplateParameter.value(), data.clazz, targetFile, targetLoc));
3934                         returnType.replace(Pattern::TEMPLATE_PARAMETER_PATTERN, templateTypeName);
3935                     }
3936                     if (returnType.contains(Pattern::TYPE_PATTERN)) {
3937                         const QString declarationType = overview.prettyType(
3938                             typeAt(memberVariableType, data.clazz, targetFile, targetLoc));
3939                         returnType.replace(Pattern::TYPE_PATTERN, declarationType);
3940                     }
3941                     Control *control = m_operation->currentFile()->cppDocument()->control();
3942                     std::string utf8String = returnType.toUtf8().toStdString();
3943                     return FullySpecifiedType(
3944                         control->namedType(control->identifier(utf8String.c_str())));
3945                 } else {
3946                     FullySpecifiedType returnType = typeAt(memberVariableType,
3947                                                            data.clazz,
3948                                                            targetFile,
3949                                                            targetLoc);
3950                     if (!isValueType)
3951                         return makeConstRef(returnType);
3952                     return returnType;
3953                 }
3954             };
3955             const QString constSpec = isMemberVariableStatic ? QLatin1String("")
3956                                                              : QLatin1String(" const");
3957             if (getterLocation == CppQuickFixSettings::FunctionLocation::CppFile) {
3958                 InsertionLocation loc = sourceLocationFor(data.declarationSymbol);
3959                 FullySpecifiedType returnType;
3960                 QString clazz;
3961                 if (m_settings->rewriteTypesinCppFile()) {
3962                     returnType = getReturnTypeAt(m_sourceFile, loc);
3963                     clazz = symbolAt(data.clazz, m_sourceFile, loc);
3964                 } else {
3965                     returnType = returnTypeHeader;
3966                     const Identifier *identifier = data.clazz->name()->identifier();
3967                     clazz = QString::fromUtf8(identifier->chars(), identifier->size());
3968                 }
3969                 const QString code = overview.prettyType(returnType, clazz + "::" + data.getterName)
3970                                      + "()" + constSpec + "\n{\nreturn " + returnExpression + ";\n}";
3971                 addSourceFileCode(code);
3972             } else if (getterLocation == CppQuickFixSettings::FunctionLocation::OutsideClass) {
3973                 InsertionLocation loc
3974                     = insertLocationForMethodDefinition(data.declarationSymbol,
3975                                                         false,
3976                                                         NamespaceHandling::Ignore,
3977                                                         m_changes,
3978                                                         m_headerFile->filePath().toString());
3979                 const FullySpecifiedType returnType = getReturnTypeAt(m_headerFile, loc);
3980                 const QString clazz = symbolAt(data.clazz, m_headerFile, loc);
3981                 QString code = overview.prettyType(returnType, clazz + "::" + data.getterName)
3982                                + "()" + constSpec + "\n{\nreturn " + returnExpression + ";\n}";
3983                 if (m_isHeaderHeaderFile)
3984                     code.prepend("inline ");
3985                 insertAndIndent(m_headerFile, loc, code);
3986             }
3987         }
3988     }
3989 
3990     // setter declaration
3991     InsertionPointLocator::AccessSpec setterAccessSpec = InsertionPointLocator::Public;
3992     if (m_settings->setterAsSlot) {
3993         const QByteArray connectName = "connect";
3994         const Identifier connectId(connectName.data(), connectName.size());
3995         const QList<LookupItem> items = m_operation->context().lookup(&connectId, data.clazz);
3996         for (const LookupItem &item : items) {
3997             if (item.declaration() && item.declaration()->enclosingClass()
3998                     && overview.prettyName(item.declaration()->enclosingClass()->name())
3999                     == "QObject") {
4000                 setterAccessSpec = InsertionPointLocator::PublicSlot;
4001                 break;
4002             }
4003         }
4004     }
4005     const auto createSetterBodyWithSignal = [this, &getSetTemplate, &data] {
4006         QString body;
4007         QTextStream setter(&body);
4008         setter << "if (" << getSetTemplate.equalComparison << ")\nreturn;\n";
4009 
4010         setter << getSetTemplate.assignment << ";\n";
4011         if (m_settings->signalWithNewValue)
4012             setter << "emit " << data.signalName << "(" << getSetTemplate.returnExpression << ");\n";
4013         else
4014             setter << "emit " << data.signalName << "();\n";
4015 
4016         return body;
4017     };
4018     if (generateFlags & Flag::GenerateSetter) {
4019         QString headerDeclaration = "void " + data.setterName + '('
4020                                     + overview.prettyType(addConstToReference(parameterType),
4021                                                           parameterName)
4022                                     + ")";
4023         if (isMemberVariableStatic)
4024             headerDeclaration.prepend("static ");
4025         QString body = "\n{\n";
4026         if (data.signalName.isEmpty())
4027             body += getSetTemplate.assignment + ";\n";
4028         else
4029             body += createSetterBodyWithSignal();
4030 
4031         body += "}";
4032 
4033         auto setterLocation = m_settings->determineSetterLocation(body.count('\n') - 2);
4034         // if we have an anonymous class we must add code inside the class
4035         if (data.clazz->name()->isAnonymousNameId())
4036             setterLocation = CppQuickFixSettings::FunctionLocation::InsideClass;
4037 
4038         if (setterLocation == CppQuickFixSettings::FunctionLocation::CppFile && !hasSourceFile())
4039             setterLocation = CppQuickFixSettings::FunctionLocation::OutsideClass;
4040 
4041         if (setterLocation == CppQuickFixSettings::FunctionLocation::InsideClass) {
4042             headerDeclaration += body;
4043         } else {
4044             headerDeclaration += ";\n";
4045             if (setterLocation == CppQuickFixSettings::FunctionLocation::CppFile) {
4046                 InsertionLocation loc = sourceLocationFor(data.declarationSymbol);
4047                 QString clazz;
4048                 FullySpecifiedType newParameterType = parameterType;
4049                 if (m_settings->rewriteTypesinCppFile()) {
4050                     newParameterType = typeAt(memberVariableType, data.clazz, m_sourceFile, loc);
4051                     if (!isValueType)
4052                         newParameterType = makeConstRef(newParameterType);
4053                     clazz = symbolAt(data.clazz, m_sourceFile, loc);
4054                 } else {
4055                     const Identifier *identifier = data.clazz->name()->identifier();
4056                     clazz = QString::fromUtf8(identifier->chars(), identifier->size());
4057                 }
4058                 newParameterType = addConstToReference(newParameterType);
4059                 const QString code = "void " + clazz + "::" + data.setterName + '('
4060                                      + overview.prettyType(newParameterType, parameterName) + ')'
4061                                      + body;
4062                 addSourceFileCode(code);
4063             } else if (setterLocation == CppQuickFixSettings::FunctionLocation::OutsideClass) {
4064                 InsertionLocation loc
4065                     = insertLocationForMethodDefinition(data.declarationSymbol,
4066                                                         false,
4067                                                         NamespaceHandling::Ignore,
4068                                                         m_changes,
4069                                                         m_headerFile->filePath().toString());
4070 
4071                 FullySpecifiedType newParameterType = typeAt(data.declarationSymbol->type(),
4072                                                              data.clazz,
4073                                                              m_headerFile,
4074                                                              loc);
4075                 if (!isValueType)
4076                     newParameterType = makeConstRef(newParameterType);
4077                 newParameterType = addConstToReference(newParameterType);
4078                 QString clazz = symbolAt(data.clazz, m_headerFile, loc);
4079 
4080                 QString code = "void " + clazz + "::" + data.setterName + '('
4081                                + overview.prettyType(newParameterType, parameterName) + ')' + body;
4082                 if (m_isHeaderHeaderFile)
4083                     code.prepend("inline ");
4084                 insertAndIndent(m_headerFile, loc, code);
4085             }
4086         }
4087         addHeaderCode(setterAccessSpec, headerDeclaration);
4088     }
4089 
4090     // reset declaration
4091     if (generateFlags & Flag::GenerateReset) {
4092         QString headerDeclaration = "void " + data.resetName + "()";
4093         if (isMemberVariableStatic)
4094             headerDeclaration.prepend("static ");
4095         QString body = "\n{\n";
4096         if (!data.setterName.isEmpty()) {
4097             body += data.setterName + "({}); // TODO: Adapt to use your actual default value\n";
4098         } else {
4099             body += "static $TYPE defaultValue{}; "
4100                     "// TODO: Adapt to use your actual default value\n";
4101             if (data.signalName.isEmpty())
4102                 body += getSetTemplate.assignment + ";\n";
4103             else
4104                 body += createSetterBodyWithSignal();
4105         }
4106         body += "}";
4107 
4108         // the template use <parameterName> as new value name, but we want to use 'defaultValue'
4109         body.replace(QRegularExpression("\\b" + parameterName + "\\b"), "defaultValue");
4110         // body.count('\n') - 2 : do not count the 2 at start
4111         auto resetLocation = m_settings->determineSetterLocation(body.count('\n') - 2);
4112         // if we have an anonymous class we must add code inside the class
4113         if (data.clazz->name()->isAnonymousNameId())
4114             resetLocation = CppQuickFixSettings::FunctionLocation::InsideClass;
4115 
4116         if (resetLocation == CppQuickFixSettings::FunctionLocation::CppFile && !hasSourceFile())
4117             resetLocation = CppQuickFixSettings::FunctionLocation::OutsideClass;
4118 
4119         if (resetLocation == CppQuickFixSettings::FunctionLocation::InsideClass) {
4120             headerDeclaration += body.replace("$TYPE", overview.prettyType(memberVariableType));
4121         } else {
4122             headerDeclaration += ";\n";
4123             if (resetLocation == CppQuickFixSettings::FunctionLocation::CppFile) {
4124                 const InsertionLocation loc = sourceLocationFor(data.declarationSymbol);
4125                 QString clazz;
4126                 FullySpecifiedType type = memberVariableType;
4127                 if (m_settings->rewriteTypesinCppFile()) {
4128                     type = typeAt(memberVariableType, data.clazz, m_sourceFile, loc);
4129                     clazz = symbolAt(data.clazz, m_sourceFile, loc);
4130                 } else {
4131                     const Identifier *identifier = data.clazz->name()->identifier();
4132                     clazz = QString::fromUtf8(identifier->chars(), identifier->size());
4133                 }
4134                 const QString code = "void " + clazz + "::" + data.resetName + "()"
4135                                      + body.replace("$TYPE", overview.prettyType(type));
4136                 addSourceFileCode(code);
4137             } else if (resetLocation == CppQuickFixSettings::FunctionLocation::OutsideClass) {
4138                 const InsertionLocation loc = insertLocationForMethodDefinition(
4139                     data.declarationSymbol,
4140                     false,
4141                     NamespaceHandling::Ignore,
4142                     m_changes,
4143                     m_headerFile->filePath().toString());
4144                 const FullySpecifiedType type = typeAt(data.declarationSymbol->type(),
4145                                                        data.clazz,
4146                                                        m_headerFile,
4147                                                        loc);
4148                 const QString clazz = symbolAt(data.clazz, m_headerFile, loc);
4149                 QString code = "void " + clazz + "::" + data.resetName + "()"
4150                                + body.replace("$TYPE", overview.prettyType(type));
4151                 if (m_isHeaderHeaderFile)
4152                     code.prepend("inline ");
4153                 insertAndIndent(m_headerFile, loc, code);
4154             }
4155         }
4156         addHeaderCode(setterAccessSpec, headerDeclaration);
4157     }
4158 
4159     // signal declaration
4160     if (generateFlags & Flag::GenerateSignal) {
4161         const auto &parameter = overview.prettyType(returnTypeHeader, data.qPropertyName);
4162         const QString newValue = m_settings->signalWithNewValue ? parameter : QString();
4163         const QString declaration = QString("void %1(%2);\n").arg(data.signalName, newValue);
4164         addHeaderCode(InsertionPointLocator::Signals, declaration);
4165     }
4166 
4167     // member variable
4168     if (generateFlags & Flag::GenerateMemberVariable) {
4169         const QString storageDeclaration = overview.prettyType(memberVariableType,
4170                                                                data.memberVariableName)
4171                                            + QLatin1String(";\n");
4172         addHeaderCode(InsertionPointLocator::Private, storageDeclaration);
4173     }
4174 
4175     // Q_PROPERTY
4176     if (generateFlags & Flag::GenerateProperty || generateFlags & Flag::GenerateConstantProperty) {
4177         // Use the returnTypeHeader as base because of custom types in getSetTemplates.
4178         // Remove const reference from type.
4179         FullySpecifiedType type = returnTypeHeader;
4180         if (ReferenceType *ref = type.type()->asReferenceType())
4181             type = ref->elementType();
4182         type.setConst(false);
4183 
4184         QString propertyDeclaration = QLatin1String("Q_PROPERTY(")
4185                                       + overview.prettyType(type,
4186                                                             memberBaseName(data.memberVariableName));
4187         bool needMember = false;
4188         if (data.getterName.isEmpty())
4189             needMember = true;
4190         else
4191             propertyDeclaration += QLatin1String(" READ ") + data.getterName;
4192         if (generateFlags & Flag::GenerateConstantProperty) {
4193             if (needMember)
4194                 propertyDeclaration += QLatin1String(" MEMBER ") + data.memberVariableName;
4195             propertyDeclaration.append(QLatin1String(" CONSTANT"));
4196         } else {
4197             if (data.setterName.isEmpty()) {
4198                 needMember = true;
4199             } else if (!getSetTemplate.returnTypeTemplate.has_value()) {
4200                 // if the return type of the getter and then Q_PROPERTY is different than
4201                 // the setter type, we should not add WRITE to the Q_PROPERTY
4202                 propertyDeclaration.append(QLatin1String(" WRITE ")).append(data.setterName);
4203             }
4204             if (needMember)
4205                 propertyDeclaration += QLatin1String(" MEMBER ") + data.memberVariableName;
4206             if (!data.resetName.isEmpty())
4207                 propertyDeclaration += QLatin1String(" RESET ") + data.resetName;
4208             propertyDeclaration.append(QLatin1String(" NOTIFY ")).append(data.signalName);
4209         }
4210 
4211         propertyDeclaration.append(QLatin1String(")\n"));
4212         addHeaderCode(InsertionPointLocator::Private, propertyDeclaration);
4213     }
4214 }
4215 
4216 QStringList toStringList(const QList<Symbol *> names)
4217 {
4218     QStringList list;
4219     list.reserve(names.size());
4220     for (const auto symbol : names) {
4221         const Identifier *const id = symbol->identifier();
4222         list << QString::fromUtf8(id->chars(), id->size());
4223     }
4224     return list;
4225 }
4226 
4227 void findExistingFunctions(ExistingGetterSetterData &existing, QStringList memberFunctionNames)
4228 {
4229     const CppQuickFixSettings *settings = CppQuickFixProjectsSettings::getQuickFixSettings(
4230         ProjectExplorer::ProjectTree::currentProject());
4231     const QString lowerBaseName = memberBaseName(existing.memberVariableName).toLower();
4232     const QStringList getterNames{lowerBaseName,
4233                                   "get_" + lowerBaseName,
4234                                   "get" + lowerBaseName,
4235                                   "is_" + lowerBaseName,
4236                                   "is" + lowerBaseName,
4237                                   settings->getGetterName(lowerBaseName)};
4238     const QStringList setterNames{"set_" + lowerBaseName,
4239                                   "set" + lowerBaseName,
4240                                   settings->getSetterName(lowerBaseName)};
4241     const QStringList resetNames{"reset_" + lowerBaseName,
4242                                  "reset" + lowerBaseName,
4243                                  settings->getResetName(lowerBaseName)};
4244     const QStringList signalNames{lowerBaseName + "_changed",
4245                                   lowerBaseName + "changed",
4246                                   settings->getSignalName(lowerBaseName)};
4247     for (const auto &memberFunctionName : memberFunctionNames) {
4248         const QString lowerName = memberFunctionName.toLower();
4249         if (getterNames.contains(lowerName))
4250             existing.getterName = memberFunctionName;
4251         else if (setterNames.contains(lowerName))
4252             existing.setterName = memberFunctionName;
4253         else if (resetNames.contains(lowerName))
4254             existing.resetName = memberFunctionName;
4255         else if (signalNames.contains(lowerName))
4256             existing.signalName = memberFunctionName;
4257     }
4258 }
4259 
4260 QList<Symbol *> getMemberFunctions(const Class *clazz)
4261 {
4262     QList<Symbol *> memberFunctions;
4263     for (auto it = clazz->memberBegin(); it != clazz->memberEnd(); ++it) {
4264         Symbol *const s = *it;
4265         if (!s->identifier() || !s->type())
4266             continue;
4267         if ((s->isDeclaration() && s->type()->asFunctionType()) || s->asFunction())
4268             memberFunctions << s;
4269     }
4270     return memberFunctions;
4271 }
4272 
4273 } // anonymous namespace
4274 
4275 void GenerateGetterSetter::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
4276 {
4277     ExistingGetterSetterData existing;
4278 
4279     const QList<AST *> &path = interface.path();
4280     // We expect something like
4281     // [0] TranslationUnitAST
4282     // [1] NamespaceAST
4283     // [2] LinkageBodyAST
4284     // [3] SimpleDeclarationAST
4285     // [4] ClassSpecifierAST
4286     // [5] SimpleDeclarationAST
4287     // [6] DeclaratorAST
4288     // [7] DeclaratorIdAST
4289     // [8] SimpleNameAST
4290 
4291     const int n = path.size();
4292     if (n < 6)
4293         return;
4294 
4295     int i = 1;
4296     const auto variableNameAST = path.at(n - i++)->asSimpleName();
4297     const auto declaratorId = path.at(n - i++)->asDeclaratorId();
4298     // DeclaratorAST might be preceded by PointerAST, e.g. for the case
4299     // "class C { char *@s; };", where '@' denotes the text cursor position.
4300     auto declarator = path.at(n - i++)->asDeclarator();
4301     if (!declarator) {
4302         --i;
4303         if (path.at(n - i++)->asPointer()) {
4304             if (n < 7)
4305                 return;
4306             declarator = path.at(n - i++)->asDeclarator();
4307         }
4308     }
4309     const auto variableDecl = path.at(n - i++)->asSimpleDeclaration();
4310     const auto classSpecifier = path.at(n - i++)->asClassSpecifier();
4311     const auto classDecl = path.at(n - i++)->asSimpleDeclaration();
4312 
4313     if (!(variableNameAST && declaratorId && variableDecl && classSpecifier && classDecl))
4314         return;
4315 
4316     // Do not get triggered on member functconstions and arrays
4317     if (declarator->postfix_declarator_list) {
4318         return;
4319     }
4320 
4321     // Construct getter and setter names
4322     const Name *variableName = variableNameAST->name;
4323     if (!variableName) {
4324         return;
4325     }
4326     const Identifier *variableId = variableName->identifier();
4327     if (!variableId) {
4328         return;
4329     }
4330     existing.memberVariableName = QString::fromUtf8(variableId->chars(), variableId->size());
4331 
4332     // Find the right symbol (for typeName) in the simple declaration
4333     Symbol *symbol = nullptr;
4334     const List<Symbol *> *symbols = variableDecl->symbols;
4335     QTC_ASSERT(symbols, return );
4336     for (; symbols; symbols = symbols->next) {
4337         Symbol *s = symbols->value;
4338         if (const Name *name = s->name()) {
4339             if (const Identifier *id = name->identifier()) {
4340                 const QString symbolName = QString::fromUtf8(id->chars(), id->size());
4341                 if (symbolName == existing.memberVariableName) {
4342                     symbol = s;
4343                     break;
4344                 }
4345             }
4346         }
4347     }
4348     if (!symbol) {
4349         // no type can be determined
4350         return;
4351     }
4352     if (!symbol->isDeclaration()) {
4353         return;
4354     }
4355     existing.declarationSymbol = symbol->asDeclaration();
4356 
4357     existing.clazz = classSpecifier->symbol;
4358     if (!existing.clazz)
4359         return;
4360 
4361     auto file = interface.currentFile();
4362     // check if a Q_PROPERTY exist
4363     const QString baseName = memberBaseName(existing.memberVariableName);
4364     // eg: we have 'int m_test' and now 'Q_PROPERTY(int foo WRITE setTest MEMBER m_test NOTIFY tChanged)'
4365     for (auto it = classSpecifier->member_specifier_list; it; it = it->next) {
4366         if (it->value->asQtPropertyDeclaration()) {
4367             auto propDecl = it->value->asQtPropertyDeclaration();
4368             // iterator over 'READ ...', ...
4369             auto p = propDecl->property_declaration_item_list;
4370             // first check, if we have a MEMBER and the member is equal to the baseName
4371             for (; p; p = p->next) {
4372                 const char *tokenString = file->tokenAt(p->value->item_name_token).spell();
4373                 if (!qstrcmp(tokenString, "MEMBER")) {
4374                     if (baseName == file->textOf(p->value->expression))
4375                         return;
4376                 }
4377             }
4378             // no MEMBER, but maybe the property name is the same
4379             const QString propertyName = file->textOf(propDecl->property_name);
4380             // we compare the baseName. e.g. 'test' instead of 'm_test'
4381             if (propertyName == baseName)
4382                 return; // TODO Maybe offer quick fix "Add missing Q_PROPERTY Members"
4383         }
4384     }
4385 
4386     findExistingFunctions(existing, toStringList(getMemberFunctions(existing.clazz)));
4387     existing.qPropertyName = memberBaseName(existing.memberVariableName);
4388 
4389     const int possibleFlags = existing.computePossibleFlags();
4390     GenerateGetterSetterOp::generateQuickFixes(result, interface, existing, possibleFlags);
4391 }
4392 
4393 class MemberInfo
4394 {
4395 public:
4396     MemberInfo(ExistingGetterSetterData data, int possibleFlags)
4397         : data(data)
4398         , possibleFlags(possibleFlags)
4399     {}
4400 
4401     ExistingGetterSetterData data;
4402     int possibleFlags;
4403     int requestedFlags = 0;
4404 };
4405 using GetterSetterCandidates = std::vector<MemberInfo>;
4406 
4407 class CandidateTreeItem : public Utils::TreeItem
4408 {
4409 public:
4410     enum Column {
4411         NameColumn,
4412         GetterColumn,
4413         SetterColumn,
4414         SignalColumn,
4415         ResetColumn,
4416         QPropertyColumn,
4417         ConstantQPropertyColumn
4418     };
4419     using Flag = GenerateGetterSetterOp::GenerateFlag;
4420     constexpr static Flag ColumnFlag[] = {
4421         static_cast<Flag>(-1),
4422         Flag::GenerateGetter,
4423         Flag::GenerateSetter,
4424         Flag::GenerateSignal,
4425         Flag::GenerateReset,
4426         Flag::GenerateProperty,
4427         Flag::GenerateConstantProperty,
4428     };
4429 
4430     CandidateTreeItem(MemberInfo *memberInfo)
4431         : m_memberInfo(memberInfo)
4432     {}
4433 
4434 private:
4435     QVariant data(int column, int role) const override
4436     {
4437         if (role == Qt::DisplayRole && column == NameColumn)
4438             return m_memberInfo->data.memberVariableName;
4439         if (role == Qt::CheckStateRole && column > 0
4440             && column <= static_cast<int>(std::size(ColumnFlag))) {
4441             return m_memberInfo->requestedFlags & ColumnFlag[column] ? Qt::Checked : Qt::Unchecked;
4442         }
4443         return {};
4444     }
4445 
4446     bool setData(int column, const QVariant &data, int role) override
4447     {
4448         if (column < 1 || column > static_cast<int>(std::size(ColumnFlag)))
4449             return false;
4450         if (role != Qt::CheckStateRole)
4451             return false;
4452         if (!(m_memberInfo->possibleFlags & ColumnFlag[column]))
4453             return false;
4454         const bool nowChecked = data.toInt() == Qt::Checked;
4455         if (nowChecked)
4456             m_memberInfo->requestedFlags |= ColumnFlag[column];
4457         else
4458             m_memberInfo->requestedFlags &= ~ColumnFlag[column];
4459 
4460         if (nowChecked) {
4461             if (column == QPropertyColumn) {
4462                 m_memberInfo->requestedFlags |= Flag::GenerateGetter;
4463                 m_memberInfo->requestedFlags |= Flag::GenerateSetter;
4464                 m_memberInfo->requestedFlags |= Flag::GenerateSignal;
4465                 m_memberInfo->requestedFlags &= ~Flag::GenerateConstantProperty;
4466             } else if (column == ConstantQPropertyColumn) {
4467                 m_memberInfo->requestedFlags |= Flag::GenerateGetter;
4468                 m_memberInfo->requestedFlags &= ~Flag::GenerateSetter;
4469                 m_memberInfo->requestedFlags &= ~Flag::GenerateSignal;
4470                 m_memberInfo->requestedFlags &= ~Flag::GenerateReset;
4471                 m_memberInfo->requestedFlags &= ~Flag::GenerateProperty;
4472             } else if (column == SetterColumn || column == SignalColumn || column == ResetColumn) {
4473                 m_memberInfo->requestedFlags &= ~Flag::GenerateConstantProperty;
4474             }
4475         } else {
4476             if (column == SignalColumn)
4477                 m_memberInfo->requestedFlags &= ~Flag::GenerateProperty;
4478         }
4479         for (int i = 0; i < 16; ++i) {
4480             const bool allowed = m_memberInfo->possibleFlags & (1 << i);
4481             if (!allowed)
4482                 m_memberInfo->requestedFlags &= ~(1 << i); // clear bit
4483         }
4484         update();
4485         return true;
4486     }
4487 
4488     Qt::ItemFlags flags(int column) const override
4489     {
4490         if (column == NameColumn)
4491             return Qt::ItemIsEnabled;
4492         if (column < 1 || column > static_cast<int>(std::size(ColumnFlag)))
4493             return {};
4494         if (m_memberInfo->possibleFlags & ColumnFlag[column])
4495             return Qt::ItemIsEnabled | Qt::ItemIsUserCheckable;
4496         return {};
4497     }
4498 
4499     MemberInfo *const m_memberInfo;
4500 };
4501 
4502 class GenerateGettersSettersDialog : public QDialog
4503 {
4504     Q_DECLARE_TR_FUNCTIONS(GenerateGettersSettersDialog)
4505 public:
4506     GenerateGettersSettersDialog(const GetterSetterCandidates &candidates)
4507         : QDialog()
4508         , m_candidates(candidates)
4509     {
4510         using Flags = GenerateGetterSetterOp::GenerateFlag;
4511         setWindowTitle(tr("Getters and Setters"));
4512         const auto model = new Utils::TreeModel<Utils::TreeItem, CandidateTreeItem>(this);
4513         model->setHeader(QStringList({
4514             tr("Member"),
4515             tr("Getter"),
4516             tr("Setter"),
4517             tr("Signal"),
4518             tr("Reset"),
4519             tr("QProperty"),
4520             tr("Constant QProperty"),
4521         }));
4522         for (MemberInfo &candidate : m_candidates)
4523             model->rootItem()->appendChild(new CandidateTreeItem(&candidate));
4524         const auto view = new Utils::BaseTreeView(this);
4525         view->setModel(model);
4526         int optimalWidth = 0;
4527         for (int i = 0; i < model->columnCount(QModelIndex{}); ++i) {
4528             view->resizeColumnToContents(i);
4529             optimalWidth += view->columnWidth(i);
4530         }
4531 
4532         const auto buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
4533         connect(buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
4534         connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);
4535 
4536         const auto setCheckStateForAll = [model](int column, int checkState) {
4537             for (int i = 0; i < model->rowCount(); ++i)
4538                 model->setData(model->index(i, column), checkState, Qt::CheckStateRole);
4539         };
4540         const auto preventPartiallyChecked = [](QCheckBox *checkbox) {
4541             if (checkbox->checkState() == Qt::PartiallyChecked)
4542                 checkbox->setCheckState(Qt::Checked);
4543         };
4544         using Column = CandidateTreeItem::Column;
4545         const auto createConnections = [=](QCheckBox *checkbox, Column column) {
4546             connect(checkbox, &QCheckBox::stateChanged, [setCheckStateForAll, column](int state) {
4547                 if (state != Qt::PartiallyChecked)
4548                     setCheckStateForAll(column, state);
4549             });
4550             connect(checkbox, &QCheckBox::clicked, this, [checkbox, preventPartiallyChecked] {
4551                 preventPartiallyChecked(checkbox);
4552             });
4553         };
4554         std::array<QCheckBox *, 4> checkBoxes = {};
4555         constexpr Column CheckBoxColumn[4] = {Column::GetterColumn,
4556                                               Column::SetterColumn,
4557                                               Column::SignalColumn,
4558                                               Column::QPropertyColumn};
4559         static_assert(std::size(CheckBoxColumn) == checkBoxes.size(),
4560                       "Must contain the same number of elements");
4561         for (std::size_t i = 0; i < checkBoxes.size(); ++i) {
4562             if (Utils::anyOf(candidates, [i, CheckBoxColumn](const MemberInfo &mi) {
4563                     return mi.possibleFlags & CandidateTreeItem::ColumnFlag[CheckBoxColumn[i]];
4564                 })) {
4565                 const Column column = CheckBoxColumn[i];
4566                 if (column == Column::GetterColumn)
4567                     checkBoxes[i] = new QCheckBox(tr("Create getters for all members"));
4568                 else if (column == Column::SetterColumn)
4569                     checkBoxes[i] = new QCheckBox(tr("Create setters for all members"));
4570                 else if (column == Column::SignalColumn)
4571                     checkBoxes[i] = new QCheckBox(tr("Create signals for all members"));
4572                 else if (column == Column::QPropertyColumn)
4573                     checkBoxes[i] = new QCheckBox(tr("Create Q_PROPERTY for all members"));
4574 
4575                 createConnections(checkBoxes[i], column);
4576             }
4577         }
4578         connect(model, &QAbstractItemModel::dataChanged, this, [this, checkBoxes, CheckBoxColumn] {
4579             const auto countExisting = [this](Flags flag) {
4580                 return Utils::count(m_candidates, [flag](const MemberInfo &mi) {
4581                     return !(mi.possibleFlags & flag);
4582                 });
4583             };
4584             const auto countRequested = [this](Flags flag) {
4585                 return Utils::count(m_candidates, [flag](const MemberInfo &mi) {
4586                     return mi.requestedFlags & flag;
4587                 });
4588             };
4589             const auto countToState = [this](int requestedCount, int alreadyExistsCount) {
4590                 if (requestedCount == 0)
4591                     return Qt::Unchecked;
4592                 if (int(m_candidates.size()) - requestedCount == alreadyExistsCount)
4593                     return Qt::Checked;
4594                 return Qt::PartiallyChecked;
4595             };
4596             for (std::size_t i = 0; i < checkBoxes.size(); ++i) {
4597                 if (checkBoxes[i]) {
4598                     const Flags flag = CandidateTreeItem::ColumnFlag[CheckBoxColumn[i]];
4599                     checkBoxes[i]->setCheckState(
4600                         countToState(countRequested(flag), countExisting(flag)));
4601                 }
4602             }
4603         });
4604 
4605         const auto mainLayout = new QVBoxLayout(this);
4606         mainLayout->addWidget(new QLabel(tr("Select the getters and setters "
4607                                             "to be created.")));
4608         for (auto checkBox : checkBoxes) {
4609             if (checkBox)
4610                 mainLayout->addWidget(checkBox);
4611         }
4612         mainLayout->addWidget(view);
4613         mainLayout->addWidget(buttonBox);
4614         int left, right;
4615         mainLayout->getContentsMargins(&left, nullptr, &right, nullptr);
4616         optimalWidth += left + right;
4617         resize(optimalWidth, mainLayout->sizeHint().height());
4618     }
4619 
4620     GetterSetterCandidates candidates() const { return m_candidates; }
4621 
4622 private:
4623     GetterSetterCandidates m_candidates;
4624 };
4625 
4626 class GenerateGettersSettersOperation : public CppQuickFixOperation
4627 {
4628 public:
4629     GenerateGettersSettersOperation(const CppQuickFixInterface &interface)
4630         : CppQuickFixOperation(interface)
4631     {
4632         setDescription(CppQuickFixFactory::tr("Create Getter and Setter Member Functions"));
4633 
4634         m_classAST = astForClassOperations(interface);
4635         if (!m_classAST)
4636             return;
4637         Class * const theClass = m_classAST->symbol;
4638         if (!theClass)
4639             return;
4640 
4641         // Go through all data members and try to find out whether they have getters and/or setters.
4642         QList<Symbol *> dataMembers;
4643         QList<Symbol *> memberFunctions;
4644         for (auto it = theClass->memberBegin(); it != theClass->memberEnd(); ++it) {
4645             Symbol *const s = *it;
4646             if (!s->identifier() || !s->type() || s->type().isTypedef())
4647                 continue;
4648             if ((s->isDeclaration() && s->type()->asFunctionType()) || s->asFunction())
4649                 memberFunctions << s;
4650             else if (s->isDeclaration() && (s->isPrivate() || s->isProtected()))
4651                 dataMembers << s;
4652         }
4653 
4654         auto file = interface.currentFile();
4655         QStringList qPropertyNames; // name after MEMBER or name of the property
4656         for (auto it = m_classAST->member_specifier_list; it; it = it->next) {
4657             if (it->value->asQtPropertyDeclaration()) {
4658                 auto propDecl = it->value->asQtPropertyDeclaration();
4659                 // iterator over 'READ ...', ... and check if we have a MEMBER
4660                 for (auto p = propDecl->property_declaration_item_list; p; p = p->next) {
4661                     const char *tokenString = file->tokenAt(p->value->item_name_token).spell();
4662                     if (!qstrcmp(tokenString, "MEMBER"))
4663                         qPropertyNames << file->textOf(p->value->expression);
4664                 }
4665                 // no MEMBER, but maybe the property name is the same
4666                 qPropertyNames << file->textOf(propDecl->property_name);
4667             }
4668         }
4669         const QStringList memberFunctionsAsStrings = toStringList(memberFunctions);
4670 
4671         for (Symbol *const member : qAsConst(dataMembers)) {
4672             ExistingGetterSetterData existing;
4673             existing.memberVariableName = QString::fromUtf8(member->identifier()->chars(),
4674                                                             member->identifier()->size());
4675             existing.declarationSymbol = member->asDeclaration();
4676             existing.clazz = theClass;
4677 
4678             // check if a Q_PROPERTY exist
4679             const QString baseName = memberBaseName(existing.memberVariableName);
4680             if (qPropertyNames.contains(baseName)
4681                 || qPropertyNames.contains(existing.memberVariableName))
4682                 continue;
4683 
4684             findExistingFunctions(existing, memberFunctionsAsStrings);
4685             existing.qPropertyName = baseName;
4686 
4687             int possibleFlags = existing.computePossibleFlags();
4688             if (possibleFlags == 0)
4689                 continue;
4690             m_candidates.emplace_back(existing, possibleFlags);
4691         }
4692     }
4693 
4694     GetterSetterCandidates candidates() const { return m_candidates; }
4695     bool isApplicable() const { return !m_candidates.empty(); }
4696 
4697     void setGetterSetterData(const GetterSetterCandidates &data)
4698     {
4699         m_candidates = data;
4700         m_hasData = true;
4701     }
4702 
4703 private:
4704     void perform() override
4705     {
4706         if (!m_hasData) {
4707             GenerateGettersSettersDialog dlg(m_candidates);
4708             if (dlg.exec() == QDialog::Rejected)
4709                 return;
4710             m_candidates = dlg.candidates();
4711         }
4712         if (m_candidates.empty())
4713             return;
4714         GetterSetterRefactoringHelper helper(this,
4715                                              currentFile()->filePath().toString(),
4716                                              m_candidates.front().data.clazz);
4717         for (MemberInfo &mi : m_candidates) {
4718             if (mi.requestedFlags != 0) {
4719                 helper.performGeneration(mi.data, mi.requestedFlags);
4720             }
4721         }
4722         helper.applyChanges();
4723     }
4724 
4725     GetterSetterCandidates m_candidates;
4726     const ClassSpecifierAST *m_classAST = nullptr;
4727     bool m_hasData = false;
4728 };
4729 
4730 void GenerateGettersSettersForClass::match(const CppQuickFixInterface &interface,
4731                                            QuickFixOperations &result)
4732 {
4733     const auto op = QSharedPointer<GenerateGettersSettersOperation>::create(interface);
4734     if (!op->isApplicable())
4735         return;
4736     if (m_test) {
4737         GetterSetterCandidates candidates = op->candidates();
4738         for (MemberInfo &mi : candidates) {
4739             mi.requestedFlags = mi.possibleFlags;
4740             using Flag = GenerateGetterSetterOp::GenerateFlag;
4741             mi.requestedFlags &= ~Flag::GenerateConstantProperty;
4742         }
4743         op->setGetterSetterData(candidates);
4744     }
4745     result << op;
4746 }
4747 
4748 
4749 namespace {
4750 
4751 class ExtractFunctionOptions
4752 {
4753 public:
4754     static bool isValidFunctionName(const QString &name)
4755     {
4756         return !name.isEmpty() && isValidIdentifier(name);
4757     }
4758 
4759     bool hasValidFunctionName() const
4760     {
4761         return isValidFunctionName(funcName);
4762     }
4763 
4764     QString funcName;
4765     InsertionPointLocator::AccessSpec access = InsertionPointLocator::Public;
4766 };
4767 
4768 class ExtractFunctionOperation : public CppQuickFixOperation
4769 {
4770 public:
4771     ExtractFunctionOperation(const CppQuickFixInterface &interface,
4772                     int extractionStart,
4773                     int extractionEnd,
4774                     FunctionDefinitionAST *refFuncDef,
4775                     Symbol *funcReturn,
4776                     QList<QPair<QString, QString> > relevantDecls,
4777                     ExtractFunction::FunctionNameGetter functionNameGetter
4778                              = ExtractFunction::FunctionNameGetter())
4779         : CppQuickFixOperation(interface)
4780         , m_extractionStart(extractionStart)
4781         , m_extractionEnd(extractionEnd)
4782         , m_refFuncDef(refFuncDef)
4783         , m_funcReturn(funcReturn)
4784         , m_relevantDecls(relevantDecls)
4785         , m_functionNameGetter(functionNameGetter)
4786     {
4787         setDescription(QCoreApplication::translate("QuickFix::ExtractFunction", "Extract Function"));
4788     }
4789 
4790     void perform() override
4791     {
4792         QTC_ASSERT(!m_funcReturn || !m_relevantDecls.isEmpty(), return);
4793         CppRefactoringChanges refactoring(snapshot());
4794         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
4795 
4796         ExtractFunctionOptions options;
4797         if (m_functionNameGetter)
4798             options.funcName = m_functionNameGetter();
4799         else
4800             options = getOptions();
4801 
4802         if (!options.hasValidFunctionName())
4803             return;
4804         const QString &funcName = options.funcName;
4805 
4806         Function *refFunc = m_refFuncDef->symbol;
4807 
4808         // We don't need to rewrite the type for declarations made inside the reference function,
4809         // since their scope will remain the same. Then we preserve the original spelling style.
4810         // However, we must do so for the return type in the definition.
4811         SubstitutionEnvironment env;
4812         env.setContext(context());
4813         env.switchScope(refFunc);
4814         ClassOrNamespace *targetCoN = context().lookupType(refFunc->enclosingScope());
4815         if (!targetCoN)
4816             targetCoN = context().globalNamespace();
4817         UseMinimalNames subs(targetCoN);
4818         env.enter(&subs);
4819 
4820         Overview printer = CppCodeStyleSettings::currentProjectCodeStyleOverview();
4821         Control *control = context().bindings()->control().data();
4822         QString funcDef;
4823         QString funcDecl; // We generate a declaration only in the case of a member function.
4824         QString funcCall;
4825 
4826         Class *matchingClass = isMemberFunction(context(), refFunc);
4827 
4828         // Write return type.
4829         if (!m_funcReturn) {
4830             funcDef.append(QLatin1String("void "));
4831             if (matchingClass)
4832                 funcDecl.append(QLatin1String("void "));
4833         } else {
4834             const FullySpecifiedType &fullType = rewriteType(m_funcReturn->type(), &env, control);
4835             funcDef.append(printer.prettyType(fullType) + QLatin1Char(' '));
4836             funcDecl.append(printer.prettyType(m_funcReturn->type()) + QLatin1Char(' '));
4837         }
4838 
4839         // Write class qualification, if any.
4840         if (matchingClass) {
4841             const Scope *current = matchingClass;
4842             QVector<const Name *> classes{matchingClass->name()};
4843             while (current->enclosingScope()->asClass()) {
4844                 current = current->enclosingScope()->asClass();
4845                 classes.prepend(current->name());
4846             }
4847             while (current->enclosingScope() && current->enclosingScope()->asNamespace()) {
4848                 current = current->enclosingScope()->asNamespace();
4849                 if (current->name())
4850                     classes.prepend(current->name());
4851             }
4852             for (const Name *n : classes) {
4853                 const Name *name = rewriteName(n, &env, control);
4854                 funcDef.append(printer.prettyName(name));
4855                 funcDef.append(QLatin1String("::"));
4856             }
4857         }
4858 
4859         // Write the extracted function itself and its call.
4860         funcDef.append(funcName);
4861         if (matchingClass)
4862             funcDecl.append(funcName);
4863         funcCall.append(funcName);
4864         funcDef.append(QLatin1Char('('));
4865         if (matchingClass)
4866             funcDecl.append(QLatin1Char('('));
4867         funcCall.append(QLatin1Char('('));
4868         for (int i = m_funcReturn ? 1 : 0; i < m_relevantDecls.length(); ++i) {
4869             QPair<QString, QString> p = m_relevantDecls.at(i);
4870             funcCall.append(p.first);
4871             funcDef.append(p.second);
4872             if (matchingClass)
4873                 funcDecl.append(p.second);
4874             if (i < m_relevantDecls.length() - 1) {
4875                 funcCall.append(QLatin1String(", "));
4876                 funcDef.append(QLatin1String(", "));
4877                 if (matchingClass)
4878                     funcDecl.append(QLatin1String(", "));
4879             }
4880         }
4881         funcDef.append(QLatin1Char(')'));
4882         if (matchingClass)
4883             funcDecl.append(QLatin1Char(')'));
4884         funcCall.append(QLatin1Char(')'));
4885         if (refFunc->isConst()) {
4886             funcDef.append(QLatin1String(" const"));
4887             funcDecl.append(QLatin1String(" const"));
4888         }
4889         funcDef.append(QLatin1String("\n{"));
4890         if (matchingClass)
4891             funcDecl.append(QLatin1String(";\n"));
4892         if (m_funcReturn) {
4893             funcDef.append(QLatin1String("\nreturn ")
4894                         + m_relevantDecls.at(0).first
4895                         + QLatin1Char(';'));
4896             funcCall.prepend(m_relevantDecls.at(0).second + QLatin1String(" = "));
4897         }
4898         funcDef.append(QLatin1String("\n}\n\n"));
4899         funcDef.replace(QChar::ParagraphSeparator, QLatin1String("\n"));
4900         funcDef.prepend(inlinePrefix(currentFile->filePath().toString()));
4901         funcCall.append(QLatin1Char(';'));
4902 
4903         // Get starting indentation from original code.
4904         int indentedExtractionStart = m_extractionStart;
4905         QChar current = currentFile->document()->characterAt(indentedExtractionStart - 1);
4906         while (current == QLatin1Char(' ') || current == QLatin1Char('\t')) {
4907             --indentedExtractionStart;
4908             current = currentFile->document()->characterAt(indentedExtractionStart - 1);
4909         }
4910         QString extract = currentFile->textOf(indentedExtractionStart, m_extractionEnd);
4911         extract.replace(QChar::ParagraphSeparator, QLatin1String("\n"));
4912         if (!extract.endsWith(QLatin1Char('\n')) && m_funcReturn)
4913             extract.append(QLatin1Char('\n'));
4914 
4915         // Since we need an indent range and a nested reindent range (based on the original
4916         // formatting) it's simpler to have two different change sets.
4917         ChangeSet change;
4918         int position = currentFile->startOf(m_refFuncDef);
4919         change.insert(position, funcDef);
4920         change.replace(m_extractionStart, m_extractionEnd, funcCall);
4921         currentFile->setChangeSet(change);
4922         currentFile->appendIndentRange(ChangeSet::Range(position, position + 1));
4923         currentFile->apply();
4924 
4925         QTextCursor tc = currentFile->document()->find(QLatin1String("{"), position);
4926         QTC_ASSERT(tc.hasSelection(), return);
4927         position = tc.selectionEnd() + 1;
4928         change.clear();
4929         change.insert(position, extract + '\n');
4930         currentFile->setChangeSet(change);
4931         currentFile->appendReindentRange(ChangeSet::Range(position, position + 1));
4932         currentFile->apply();
4933 
4934         // Write declaration, if necessary.
4935         if (matchingClass) {
4936             InsertionPointLocator locator(refactoring);
4937             const QString fileName = QLatin1String(matchingClass->fileName());
4938             const InsertionLocation &location =
4939                     locator.methodDeclarationInClass(fileName, matchingClass, options.access);
4940             CppRefactoringFilePtr declFile = refactoring.file(Utils::FilePath::fromString(fileName));
4941             change.clear();
4942             position = declFile->position(location.line(), location.column());
4943             change.insert(position, location.prefix() + funcDecl + location.suffix());
4944             declFile->setChangeSet(change);
4945             declFile->appendIndentRange(ChangeSet::Range(position, position + 1));
4946             declFile->apply();
4947         }
4948     }
4949 
4950     ExtractFunctionOptions getOptions() const
4951     {
4952         QDialog dlg(Core::ICore::dialogParent());
4953         dlg.setWindowTitle(QCoreApplication::translate("QuickFix::ExtractFunction",
4954                                                        "Extract Function Refactoring"));
4955         auto layout = new QFormLayout(&dlg);
4956 
4957         auto funcNameEdit = new Utils::FancyLineEdit;
4958         funcNameEdit->setValidationFunction([](Utils::FancyLineEdit *edit, QString *) {
4959             return ExtractFunctionOptions::isValidFunctionName(edit->text());
4960         });
4961         layout->addRow(QCoreApplication::translate("QuickFix::ExtractFunction",
4962                                                    "Function name"), funcNameEdit);
4963 
4964         auto accessCombo = new QComboBox;
4965         accessCombo->addItem(
4966                     InsertionPointLocator::accessSpecToString(InsertionPointLocator::Public),
4967                     InsertionPointLocator::Public);
4968         accessCombo->addItem(
4969                     InsertionPointLocator::accessSpecToString(InsertionPointLocator::PublicSlot),
4970                     InsertionPointLocator::PublicSlot);
4971         accessCombo->addItem(
4972                     InsertionPointLocator::accessSpecToString(InsertionPointLocator::Protected),
4973                     InsertionPointLocator::Protected);
4974         accessCombo->addItem(
4975                     InsertionPointLocator::accessSpecToString(InsertionPointLocator::ProtectedSlot),
4976                     InsertionPointLocator::ProtectedSlot);
4977         accessCombo->addItem(
4978                     InsertionPointLocator::accessSpecToString(InsertionPointLocator::Private),
4979                     InsertionPointLocator::Private);
4980         accessCombo->addItem(
4981                     InsertionPointLocator::accessSpecToString(InsertionPointLocator::PrivateSlot),
4982                     InsertionPointLocator::PrivateSlot);
4983         layout->addRow(QCoreApplication::translate("QuickFix::ExtractFunction",
4984                                                    "Access"), accessCombo);
4985 
4986         auto buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
4987         QObject::connect(buttonBox, &QDialogButtonBox::accepted, &dlg, &QDialog::accept);
4988         QObject::connect(buttonBox, &QDialogButtonBox::rejected, &dlg, &QDialog::reject);
4989         QPushButton *ok = buttonBox->button(QDialogButtonBox::Ok);
4990         ok->setEnabled(false);
4991         QObject::connect(funcNameEdit, &Utils::FancyLineEdit::validChanged,
4992                          ok, &QPushButton::setEnabled);
4993         layout->addWidget(buttonBox);
4994 
4995         if (dlg.exec() == QDialog::Accepted) {
4996             ExtractFunctionOptions options;
4997             options.funcName = funcNameEdit->text();
4998             options.access = static_cast<InsertionPointLocator::AccessSpec>(accessCombo->
4999                                                                            currentData().toInt());
5000             return options;
5001         }
5002         return ExtractFunctionOptions();
5003     }
5004 
5005     int m_extractionStart;
5006     int m_extractionEnd;
5007     FunctionDefinitionAST *m_refFuncDef;
5008     Symbol *m_funcReturn;
5009     QList<QPair<QString, QString> > m_relevantDecls;
5010     ExtractFunction::FunctionNameGetter m_functionNameGetter;
5011 };
5012 
5013 QPair<QString, QString> assembleDeclarationData(const QString &specifiers, DeclaratorAST *decltr,
5014                                                 const CppRefactoringFilePtr &file,
5015                                                 const Overview &printer)
5016 {
5017     QTC_ASSERT(decltr, return (QPair<QString, QString>()));
5018     if (decltr->core_declarator
5019             && decltr->core_declarator->asDeclaratorId()
5020             && decltr->core_declarator->asDeclaratorId()->name) {
5021         QString decltrText = file->textOf(file->startOf(decltr),
5022                                           file->endOf(decltr->core_declarator));
5023         if (!decltrText.isEmpty()) {
5024             const QString &name = printer.prettyName(
5025                     decltr->core_declarator->asDeclaratorId()->name->name);
5026             QString completeDecl = specifiers;
5027             if (!decltrText.contains(QLatin1Char(' ')))
5028                 completeDecl.append(QLatin1Char(' ') + decltrText);
5029             else
5030                 completeDecl.append(decltrText);
5031             return qMakePair(name, completeDecl);
5032         }
5033     }
5034     return QPair<QString, QString>();
5035 }
5036 
5037 class FunctionExtractionAnalyser : public ASTVisitor
5038 {
5039 public:
5040     FunctionExtractionAnalyser(TranslationUnit *unit,
5041                                const int selStart,
5042                                const int selEnd,
5043                                const CppRefactoringFilePtr &file,
5044                                const Overview &printer)
5045         : ASTVisitor(unit)
5046         , m_done(false)
5047         , m_failed(false)
5048         , m_selStart(selStart)
5049         , m_selEnd(selEnd)
5050         , m_extractionStart(0)
5051         , m_extractionEnd(0)
5052         , m_file(file)
5053         , m_printer(printer)
5054     {}
5055 
5056     bool operator()(FunctionDefinitionAST *refFunDef)
5057     {
5058         accept(refFunDef);
5059 
5060         if (!m_failed && m_extractionStart == m_extractionEnd)
5061             m_failed = true;
5062 
5063         return !m_failed;
5064     }
5065 
5066     bool preVisit(AST *) override
5067     {
5068         return !m_done;
5069     }
5070 
5071     void statement(StatementAST *stmt)
5072     {
5073         if (!stmt)
5074             return;
5075 
5076         const int stmtStart = m_file->startOf(stmt);
5077         const int stmtEnd = m_file->endOf(stmt);
5078 
5079         if (stmtStart >= m_selEnd
5080                 || (m_extractionStart && stmtEnd > m_selEnd)) {
5081             m_done = true;
5082             return;
5083         }
5084 
5085         if (stmtStart >= m_selStart && !m_extractionStart)
5086             m_extractionStart = stmtStart;
5087         if (stmtEnd > m_extractionEnd && m_extractionStart)
5088             m_extractionEnd = stmtEnd;
5089 
5090         accept(stmt);
5091     }
5092 
5093     bool visit(CaseStatementAST *stmt) override
5094     {
5095         statement(stmt->statement);
5096         return false;
5097     }
5098 
5099     bool visit(CompoundStatementAST *stmt) override
5100     {
5101         for (StatementListAST *it = stmt->statement_list; it; it = it->next) {
5102             statement(it->value);
5103             if (m_done)
5104                 break;
5105         }
5106         return false;
5107     }
5108 
5109     bool visit(DoStatementAST *stmt) override
5110     {
5111         statement(stmt->statement);
5112         return false;
5113     }
5114 
5115     bool visit(ForeachStatementAST *stmt) override
5116     {
5117         statement(stmt->statement);
5118         return false;
5119     }
5120 
5121     bool visit(RangeBasedForStatementAST *stmt) override
5122     {
5123         statement(stmt->statement);
5124         return false;
5125     }
5126 
5127     bool visit(ForStatementAST *stmt) override
5128     {
5129         statement(stmt->initializer);
5130         if (!m_done)
5131             statement(stmt->statement);
5132         return false;
5133     }
5134 
5135     bool visit(IfStatementAST *stmt) override
5136     {
5137         statement(stmt->statement);
5138         if (!m_done)
5139             statement(stmt->else_statement);
5140         return false;
5141     }
5142 
5143     bool visit(TryBlockStatementAST *stmt) override
5144     {
5145         statement(stmt->statement);
5146         for (CatchClauseListAST *it = stmt->catch_clause_list; it; it = it->next) {
5147             statement(it->value);
5148             if (m_done)
5149                 break;
5150         }
5151         return false;
5152     }
5153 
5154     bool visit(WhileStatementAST *stmt) override
5155     {
5156         statement(stmt->statement);
5157         return false;
5158     }
5159 
5160     bool visit(DeclarationStatementAST *declStmt) override
5161     {
5162         // We need to collect the declarations we see before the extraction or even inside it.
5163         // They might need to be used as either a parameter or return value. Actually, we could
5164         // still obtain their types from the local uses, but it's good to preserve the original
5165         // typing style.
5166         if (declStmt
5167                 && declStmt->declaration
5168                 && declStmt->declaration->asSimpleDeclaration()) {
5169             SimpleDeclarationAST *simpleDecl = declStmt->declaration->asSimpleDeclaration();
5170             if (simpleDecl->decl_specifier_list
5171                     && simpleDecl->declarator_list) {
5172                 const QString &specifiers =
5173                         m_file->textOf(m_file->startOf(simpleDecl),
5174                                      m_file->endOf(simpleDecl->decl_specifier_list->lastValue()));
5175                 for (DeclaratorListAST *decltrList = simpleDecl->declarator_list;
5176                      decltrList;
5177                      decltrList = decltrList->next) {
5178                     const QPair<QString, QString> p =
5179                         assembleDeclarationData(specifiers, decltrList->value, m_file, m_printer);
5180                     if (!p.first.isEmpty())
5181                         m_knownDecls.insert(p.first, p.second);
5182                 }
5183             }
5184         }
5185 
5186         return false;
5187     }
5188 
5189     bool visit(ReturnStatementAST *) override
5190     {
5191         if (m_extractionStart) {
5192             m_done = true;
5193             m_failed = true;
5194         }
5195 
5196         return false;
5197     }
5198 
5199     bool m_done;
5200     bool m_failed;
5201     const int m_selStart;
5202     const int m_selEnd;
5203     int m_extractionStart;
5204     int m_extractionEnd;
5205     QHash<QString, QString> m_knownDecls;
5206     CppRefactoringFilePtr m_file;
5207     const Overview &m_printer;
5208 };
5209 
5210 } // anonymous namespace
5211 
5212 ExtractFunction::ExtractFunction(FunctionNameGetter functionNameGetter)
5213     : m_functionNameGetter(functionNameGetter)
5214 {
5215 }
5216 
5217 void ExtractFunction::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
5218 {
5219     CppRefactoringFilePtr file = interface.currentFile();
5220 
5221     QTextCursor cursor = file->cursor();
5222     if (!cursor.hasSelection())
5223         return;
5224 
5225     const QList<AST *> &path = interface.path();
5226     FunctionDefinitionAST *refFuncDef = nullptr; // The "reference" function, which we will extract from.
5227     for (int i = path.size() - 1; i >= 0; --i) {
5228         refFuncDef = path.at(i)->asFunctionDefinition();
5229         if (refFuncDef)
5230             break;
5231     }
5232 
5233     if (!refFuncDef
5234             || !refFuncDef->function_body
5235             || !refFuncDef->function_body->asCompoundStatement()
5236             || !refFuncDef->function_body->asCompoundStatement()->statement_list
5237             || !refFuncDef->symbol
5238             || !refFuncDef->symbol->name()
5239             || refFuncDef->symbol->enclosingScope()->isTemplate() /* TODO: Templates... */) {
5240         return;
5241     }
5242 
5243     // Adjust selection ends.
5244     int selStart = cursor.selectionStart();
5245     int selEnd = cursor.selectionEnd();
5246     if (selStart > selEnd)
5247         std::swap(selStart, selEnd);
5248 
5249     Overview printer;
5250 
5251     // Analyze the content to be extracted, which consists of determining the statements
5252     // which are complete and collecting the declarations seen.
5253     FunctionExtractionAnalyser analyser(interface.semanticInfo().doc->translationUnit(),
5254                                         selStart, selEnd,
5255                                         file,
5256                                         printer);
5257     if (!analyser(refFuncDef))
5258         return;
5259 
5260     // We also need to collect the declarations of the parameters from the reference function.
5261     QSet<QString> refFuncParams;
5262     if (refFuncDef->declarator->postfix_declarator_list
5263             && refFuncDef->declarator->postfix_declarator_list->value
5264             && refFuncDef->declarator->postfix_declarator_list->value->asFunctionDeclarator()) {
5265         FunctionDeclaratorAST *funcDecltr =
5266             refFuncDef->declarator->postfix_declarator_list->value->asFunctionDeclarator();
5267         if (funcDecltr->parameter_declaration_clause
5268                 && funcDecltr->parameter_declaration_clause->parameter_declaration_list) {
5269             for (ParameterDeclarationListAST *it =
5270                     funcDecltr->parameter_declaration_clause->parameter_declaration_list;
5271                  it;
5272                  it = it->next) {
5273                 ParameterDeclarationAST *paramDecl = it->value->asParameterDeclaration();
5274                 if (paramDecl->declarator) {
5275                     const QString &specifiers =
5276                             file->textOf(file->startOf(paramDecl),
5277                                          file->endOf(paramDecl->type_specifier_list->lastValue()));
5278                     const QPair<QString, QString> &p =
5279                             assembleDeclarationData(specifiers, paramDecl->declarator,
5280                                                     file, printer);
5281                     if (!p.first.isEmpty()) {
5282                         analyser.m_knownDecls.insert(p.first, p.second);
5283                         refFuncParams.insert(p.first);
5284                     }
5285                 }
5286             }
5287         }
5288     }
5289 
5290     // Identify what would be parameters for the new function and its return value, if any.
5291     Symbol *funcReturn = nullptr;
5292     QList<QPair<QString, QString> > relevantDecls;
5293     const SemanticInfo::LocalUseMap localUses = interface.semanticInfo().localUses;
5294     for (auto it = localUses.cbegin(), end = localUses.cend(); it != end; ++it) {
5295         bool usedBeforeExtraction = false;
5296         bool usedAfterExtraction = false;
5297         bool usedInsideExtraction = false;
5298         const QList<SemanticInfo::Use> &uses = it.value();
5299         foreach (const SemanticInfo::Use &use, uses) {
5300             if (use.isInvalid())
5301                 continue;
5302 
5303             const int position = file->position(use.line, use.column);
5304             if (position < analyser.m_extractionStart)
5305                 usedBeforeExtraction = true;
5306             else if (position >= analyser.m_extractionEnd)
5307                 usedAfterExtraction = true;
5308             else
5309                 usedInsideExtraction = true;
5310         }
5311 
5312         const QString &name = printer.prettyName(it.key()->name());
5313 
5314         if ((usedBeforeExtraction && usedInsideExtraction)
5315                 || (usedInsideExtraction && refFuncParams.contains(name))) {
5316             QTC_ASSERT(analyser.m_knownDecls.contains(name), return);
5317             relevantDecls.append(qMakePair(name, analyser.m_knownDecls.value(name)));
5318         }
5319 
5320         // We assume that the first use of a local corresponds to its declaration.
5321         if (usedInsideExtraction && usedAfterExtraction && !usedBeforeExtraction) {
5322             if (!funcReturn) {
5323                 QTC_ASSERT(analyser.m_knownDecls.contains(name), return);
5324                 // The return, if any, is stored as the first item in the list.
5325                 relevantDecls.prepend(qMakePair(name, analyser.m_knownDecls.value(name)));
5326                 funcReturn = it.key();
5327             } else {
5328                 // Would require multiple returns. (Unless we do fancy things, as pointed below.)
5329                 return;
5330             }
5331         }
5332     }
5333 
5334     // The current implementation doesn't try to be too smart since it preserves the original form
5335     // of the declarations. This might be or not the desired effect. An improvement would be to
5336     // let the user somehow customize the function interface.
5337     result << new ExtractFunctionOperation(interface,
5338                                            analyser.m_extractionStart,
5339                                            analyser.m_extractionEnd,
5340                                            refFuncDef, funcReturn, relevantDecls,
5341                                            m_functionNameGetter);
5342 }
5343 
5344 namespace {
5345 
5346 struct ReplaceLiteralsResult
5347 {
5348     Token token;
5349     QString literalText;
5350 };
5351 
5352 template <class T>
5353 class ReplaceLiterals : private ASTVisitor
5354 {
5355 public:
5356     ReplaceLiterals(const CppRefactoringFilePtr &file, ChangeSet *changes, T *literal)
5357         : ASTVisitor(file->cppDocument()->translationUnit()), m_file(file), m_changes(changes),
5358           m_literal(literal)
5359     {
5360         m_result.token = m_file->tokenAt(literal->firstToken());
5361         m_literalTokenText = m_result.token.spell();
5362         m_result.literalText = QLatin1String(m_literalTokenText);
5363         if (m_result.token.isCharLiteral()) {
5364             m_result.literalText.prepend(QLatin1Char('\''));
5365             m_result.literalText.append(QLatin1Char('\''));
5366             if (m_result.token.kind() == T_WIDE_CHAR_LITERAL)
5367                 m_result.literalText.prepend(QLatin1Char('L'));
5368             else if (m_result.token.kind() == T_UTF16_CHAR_LITERAL)
5369                 m_result.literalText.prepend(QLatin1Char('u'));
5370             else if (m_result.token.kind() == T_UTF32_CHAR_LITERAL)
5371                 m_result.literalText.prepend(QLatin1Char('U'));
5372         } else if (m_result.token.isStringLiteral()) {
5373             m_result.literalText.prepend(QLatin1Char('"'));
5374             m_result.literalText.append(QLatin1Char('"'));
5375             if (m_result.token.kind() == T_WIDE_STRING_LITERAL)
5376                 m_result.literalText.prepend(QLatin1Char('L'));
5377             else if (m_result.token.kind() == T_UTF16_STRING_LITERAL)
5378                 m_result.literalText.prepend(QLatin1Char('u'));
5379             else if (m_result.token.kind() == T_UTF32_STRING_LITERAL)
5380                 m_result.literalText.prepend(QLatin1Char('U'));
5381         }
5382     }
5383 
5384     ReplaceLiteralsResult apply(AST *ast)
5385     {
5386         ast->accept(this);
5387         return m_result;
5388     }
5389 
5390 private:
5391     bool visit(T *ast) override
5392     {
5393         if (ast != m_literal
5394                 && strcmp(m_file->tokenAt(ast->firstToken()).spell(), m_literalTokenText) != 0) {
5395             return true;
5396         }
5397         int start, end;
5398         m_file->startAndEndOf(ast->firstToken(), &start, &end);
5399         m_changes->replace(start, end, QLatin1String("newParameter"));
5400         return true;
5401     }
5402 
5403     const CppRefactoringFilePtr &m_file;
5404     ChangeSet *m_changes;
5405     T *m_literal;
5406     const char *m_literalTokenText;
5407     ReplaceLiteralsResult m_result;
5408 };
5409 
5410 class ExtractLiteralAsParameterOp : public CppQuickFixOperation
5411 {
5412 public:
5413     ExtractLiteralAsParameterOp(const CppQuickFixInterface &interface, int priority,
5414                                 ExpressionAST *literal, FunctionDefinitionAST *function)
5415         : CppQuickFixOperation(interface, priority),
5416           m_literal(literal),
5417           m_functionDefinition(function)
5418     {
5419         setDescription(QApplication::translate("CppEditor::QuickFix",
5420                                                "Extract Constant as Function Parameter"));
5421     }
5422 
5423     struct FoundDeclaration
5424     {
5425         FunctionDeclaratorAST *ast = nullptr;
5426         CppRefactoringFilePtr file;
5427     };
5428 
5429     FoundDeclaration findDeclaration(const CppRefactoringChanges &refactoring,
5430                                      FunctionDefinitionAST *ast)
5431     {
5432         FoundDeclaration result;
5433         Function *func = ast->symbol;
5434         QString declFileName;
5435         if (Class *matchingClass = isMemberFunction(context(), func)) {
5436             // Dealing with member functions
5437             const QualifiedNameId *qName = func->name()->asQualifiedNameId();
5438             for (Symbol *s = matchingClass->find(qName->identifier()); s; s = s->next()) {
5439                 if (!s->name()
5440                         || !qName->identifier()->match(s->identifier())
5441                         || !s->type()->isFunctionType()
5442                         || !s->type().match(func->type())
5443                         || s->isFunction()) {
5444                     continue;
5445                 }
5446 
5447                 declFileName = QString::fromUtf8(matchingClass->fileName(),
5448                                                  matchingClass->fileNameLength());
5449 
5450                 result.file = refactoring.file(Utils::FilePath::fromString(declFileName));
5451                 ASTPath astPath(result.file->cppDocument());
5452                 const QList<AST *> path = astPath(s->line(), s->column());
5453                 SimpleDeclarationAST *simpleDecl = nullptr;
5454                 for (AST *node : path) {
5455                     simpleDecl = node->asSimpleDeclaration();
5456                     if (simpleDecl) {
5457                         if (simpleDecl->symbols && !simpleDecl->symbols->next) {
5458                             result.ast = functionDeclarator(simpleDecl);
5459                             return result;
5460                         }
5461                     }
5462                 }
5463 
5464                 if (simpleDecl)
5465                     break;
5466             }
5467         } else if (Namespace *matchingNamespace = isNamespaceFunction(context(), func)) {
5468             // Dealing with free functions and inline member functions.
5469             bool isHeaderFile;
5470             declFileName = correspondingHeaderOrSource(filePath().toString(), &isHeaderFile);
5471             if (!QFile::exists(declFileName))
5472                 return FoundDeclaration();
5473             result.file = refactoring.file(Utils::FilePath::fromString(declFileName));
5474             if (!result.file)
5475                 return FoundDeclaration();
5476             const LookupContext lc(result.file->cppDocument(), snapshot());
5477             const QList<LookupItem> candidates = lc.lookup(func->name(), matchingNamespace);
5478             for (const LookupItem &candidate : candidates) {
5479                 if (Symbol *s = candidate.declaration()) {
5480                     if (s->asDeclaration()) {
5481                         ASTPath astPath(result.file->cppDocument());
5482                         const QList<AST *> path = astPath(s->line(), s->column());
5483                         for (AST *node : path) {
5484                             SimpleDeclarationAST *simpleDecl = node->asSimpleDeclaration();
5485                             if (simpleDecl) {
5486                                 result.ast = functionDeclarator(simpleDecl);
5487                                 return result;
5488                             }
5489                         }
5490                     }
5491                 }
5492             }
5493         }
5494         return result;
5495     }
5496 
5497     void perform() override
5498     {
5499         FunctionDeclaratorAST *functionDeclaratorOfDefinition
5500                 = functionDeclarator(m_functionDefinition);
5501         const CppRefactoringChanges refactoring(snapshot());
5502         const CppRefactoringFilePtr currentFile = refactoring.file(filePath());
5503         deduceTypeNameOfLiteral(currentFile->cppDocument());
5504 
5505         ChangeSet changes;
5506         if (NumericLiteralAST *concreteLiteral = m_literal->asNumericLiteral()) {
5507             m_literalInfo = ReplaceLiterals<NumericLiteralAST>(currentFile, &changes,
5508                                                                concreteLiteral)
5509                     .apply(m_functionDefinition->function_body);
5510         } else if (StringLiteralAST *concreteLiteral = m_literal->asStringLiteral()) {
5511             m_literalInfo = ReplaceLiterals<StringLiteralAST>(currentFile, &changes,
5512                                                               concreteLiteral)
5513                     .apply(m_functionDefinition->function_body);
5514         } else if (BoolLiteralAST *concreteLiteral = m_literal->asBoolLiteral()) {
5515             m_literalInfo = ReplaceLiterals<BoolLiteralAST>(currentFile, &changes,
5516                                                             concreteLiteral)
5517                     .apply(m_functionDefinition->function_body);
5518         }
5519         const FoundDeclaration functionDeclaration
5520                 = findDeclaration(refactoring, m_functionDefinition);
5521         appendFunctionParameter(functionDeclaratorOfDefinition, currentFile, &changes,
5522                 !functionDeclaration.ast);
5523         if (functionDeclaration.ast) {
5524             if (currentFile->filePath() != functionDeclaration.file->filePath()) {
5525                 ChangeSet declChanges;
5526                 appendFunctionParameter(functionDeclaration.ast, functionDeclaration.file, &declChanges,
5527                                         true);
5528                 functionDeclaration.file->setChangeSet(declChanges);
5529                 functionDeclaration.file->apply();
5530             } else {
5531                 appendFunctionParameter(functionDeclaration.ast, currentFile, &changes,
5532                                         true);
5533             }
5534         }
5535         currentFile->setChangeSet(changes);
5536         currentFile->apply();
5537         QTextCursor c = currentFile->cursor();
5538         c.setPosition(c.position() - parameterName().length());
5539         editor()->setTextCursor(c);
5540         editor()->renameSymbolUnderCursor();
5541     }
5542 
5543 private:
5544     bool hasParameters(FunctionDeclaratorAST *ast) const
5545     {
5546         return ast->parameter_declaration_clause
5547                 && ast->parameter_declaration_clause->parameter_declaration_list
5548                 && ast->parameter_declaration_clause->parameter_declaration_list->value;
5549     }
5550 
5551     void deduceTypeNameOfLiteral(const Document::Ptr &document)
5552     {
5553         TypeOfExpression typeOfExpression;
5554         typeOfExpression.init(document, snapshot());
5555         Overview overview;
5556         Scope *scope = m_functionDefinition->symbol->enclosingScope();
5557         const QList<LookupItem> items = typeOfExpression(m_literal, document, scope);
5558         if (!items.isEmpty())
5559             m_typeName = overview.prettyType(items.first().type());
5560     }
5561 
5562     static QString parameterName() { return QLatin1String("newParameter"); }
5563 
5564     QString parameterDeclarationTextToInsert(FunctionDeclaratorAST *ast) const
5565     {
5566         QString str;
5567         if (hasParameters(ast))
5568             str = QLatin1String(", ");
5569         str += m_typeName;
5570         if (!m_typeName.endsWith(QLatin1Char('*')))
5571                 str += QLatin1Char(' ');
5572         str += parameterName();
5573         return str;
5574     }
5575 
5576     FunctionDeclaratorAST *functionDeclarator(SimpleDeclarationAST *ast) const
5577     {
5578         for (DeclaratorListAST *decls = ast->declarator_list; decls; decls = decls->next) {
5579             FunctionDeclaratorAST * const functionDeclaratorAST = functionDeclarator(decls->value);
5580             if (functionDeclaratorAST)
5581                 return functionDeclaratorAST;
5582         }
5583         return nullptr;
5584     }
5585 
5586     FunctionDeclaratorAST *functionDeclarator(DeclaratorAST *ast) const
5587     {
5588         for (PostfixDeclaratorListAST *pds = ast->postfix_declarator_list; pds; pds = pds->next) {
5589             FunctionDeclaratorAST *funcdecl = pds->value->asFunctionDeclarator();
5590             if (funcdecl)
5591                 return funcdecl;
5592         }
5593         return nullptr;
5594     }
5595 
5596     FunctionDeclaratorAST *functionDeclarator(FunctionDefinitionAST *ast) const
5597     {
5598         return functionDeclarator(ast->declarator);
5599     }
5600 
5601     void appendFunctionParameter(FunctionDeclaratorAST *ast, const CppRefactoringFileConstPtr &file,
5602                ChangeSet *changes, bool addDefaultValue)
5603     {
5604         if (!ast)
5605             return;
5606         if (m_declarationInsertionString.isEmpty())
5607             m_declarationInsertionString = parameterDeclarationTextToInsert(ast);
5608         QString insertion = m_declarationInsertionString;
5609         if (addDefaultValue)
5610             insertion += QLatin1String(" = ") + m_literalInfo.literalText;
5611         changes->insert(file->startOf(ast->rparen_token), insertion);
5612     }
5613 
5614     ExpressionAST *m_literal;
5615     FunctionDefinitionAST *m_functionDefinition;
5616     QString m_typeName;
5617     QString m_declarationInsertionString;
5618     ReplaceLiteralsResult m_literalInfo;
5619 };
5620 
5621 } // anonymous namespace
5622 
5623 void ExtractLiteralAsParameter::match(const CppQuickFixInterface &interface,
5624         QuickFixOperations &result)
5625 {
5626     const QList<AST *> &path = interface.path();
5627     if (path.count() < 2)
5628         return;
5629 
5630     AST * const lastAst = path.last();
5631     ExpressionAST *literal;
5632     if (!((literal = lastAst->asNumericLiteral())
5633           || (literal = lastAst->asStringLiteral())
5634           || (literal = lastAst->asBoolLiteral()))) {
5635             return;
5636     }
5637 
5638     FunctionDefinitionAST *function;
5639     int i = path.count() - 2;
5640     while (!(function = path.at(i)->asFunctionDefinition())) {
5641         // Ignore literals in lambda expressions for now.
5642         if (path.at(i)->asLambdaExpression())
5643             return;
5644         if (--i < 0)
5645             return;
5646     }
5647 
5648     PostfixDeclaratorListAST * const declaratorList = function->declarator->postfix_declarator_list;
5649     if (!declaratorList)
5650         return;
5651     if (FunctionDeclaratorAST *declarator = declaratorList->value->asFunctionDeclarator()) {
5652         if (declarator->parameter_declaration_clause
5653                 && declarator->parameter_declaration_clause->dot_dot_dot_token) {
5654             // Do not handle functions with ellipsis parameter.
5655             return;
5656         }
5657     }
5658 
5659     const int priority = path.size() - 1;
5660     result << new ExtractLiteralAsParameterOp(interface, priority, literal, function);
5661 }
5662 
5663 namespace {
5664 
5665 class ConvertFromAndToPointerOp : public CppQuickFixOperation
5666 {
5667 public:
5668     enum Mode { FromPointer, FromVariable, FromReference };
5669 
5670     ConvertFromAndToPointerOp(const CppQuickFixInterface &interface, int priority, Mode mode,
5671                               bool isAutoDeclaration,
5672                               const SimpleDeclarationAST *simpleDeclaration,
5673                               const DeclaratorAST *declaratorAST,
5674                               const SimpleNameAST *identifierAST,
5675                               Symbol *symbol)
5676         : CppQuickFixOperation(interface, priority)
5677         , m_mode(mode)
5678         , m_isAutoDeclaration(isAutoDeclaration)
5679         , m_simpleDeclaration(simpleDeclaration)
5680         , m_declaratorAST(declaratorAST)
5681         , m_identifierAST(identifierAST)
5682         , m_symbol(symbol)
5683         , m_refactoring(snapshot())
5684         , m_file(m_refactoring.file(filePath()))
5685         , m_document(interface.semanticInfo().doc)
5686     {
5687         setDescription(
5688                 mode == FromPointer
5689                 ? CppQuickFixFactory::tr("Convert to Stack Variable")
5690                 : CppQuickFixFactory::tr("Convert to Pointer"));
5691     }
5692 
5693     void perform() override
5694     {
5695         ChangeSet changes;
5696 
5697         switch (m_mode) {
5698         case FromPointer:
5699             removePointerOperator(changes);
5700             convertToStackVariable(changes);
5701             break;
5702         case FromReference:
5703             removeReferenceOperator(changes);
5704             Q_FALLTHROUGH();
5705         case FromVariable:
5706             convertToPointer(changes);
5707             break;
5708         }
5709 
5710         m_file->setChangeSet(changes);
5711         m_file->apply();
5712     }
5713 
5714 private:
5715     void removePointerOperator(ChangeSet &changes) const
5716     {
5717         if (!m_declaratorAST->ptr_operator_list)
5718             return;
5719         PointerAST *ptrAST = m_declaratorAST->ptr_operator_list->value->asPointer();
5720         QTC_ASSERT(ptrAST, return);
5721         const int pos = m_file->startOf(ptrAST->star_token);
5722         changes.remove(pos, pos + 1);
5723     }
5724 
5725     void removeReferenceOperator(ChangeSet &changes) const
5726     {
5727         ReferenceAST *refAST = m_declaratorAST->ptr_operator_list->value->asReference();
5728         QTC_ASSERT(refAST, return);
5729         const int pos = m_file->startOf(refAST->reference_token);
5730         changes.remove(pos, pos + 1);
5731     }
5732 
5733     void removeNewExpression(ChangeSet &changes, NewExpressionAST *newExprAST) const
5734     {
5735         ExpressionListAST *exprlist = nullptr;
5736         if (newExprAST->new_initializer) {
5737             if (ExpressionListParenAST *ast = newExprAST->new_initializer->asExpressionListParen())
5738                 exprlist = ast->expression_list;
5739             else if (BracedInitializerAST *ast = newExprAST->new_initializer->asBracedInitializer())
5740                 exprlist = ast->expression_list;
5741         }
5742 
5743         if (exprlist) {
5744             // remove 'new' keyword and type before initializer
5745             changes.remove(m_file->startOf(newExprAST->new_token),
5746                            m_file->startOf(newExprAST->new_initializer));
5747 
5748             changes.remove(m_file->endOf(m_declaratorAST->equal_token - 1),
5749                            m_file->startOf(m_declaratorAST->equal_token + 1));
5750         } else {
5751             // remove the whole new expression
5752             changes.remove(m_file->endOf(m_identifierAST->firstToken()),
5753                            m_file->startOf(newExprAST->lastToken()));
5754         }
5755     }
5756 
5757     void removeNewKeyword(ChangeSet &changes, NewExpressionAST *newExprAST) const
5758     {
5759         // remove 'new' keyword before initializer
5760         changes.remove(m_file->startOf(newExprAST->new_token),
5761                        m_file->startOf(newExprAST->new_type_id));
5762     }
5763 
5764     void convertToStackVariable(ChangeSet &changes) const
5765     {
5766         // Handle the initializer.
5767         if (m_declaratorAST->initializer) {
5768             if (NewExpressionAST *newExpression = m_declaratorAST->initializer->asNewExpression()) {
5769                 if (m_isAutoDeclaration) {
5770                     if (!newExpression->new_initializer)
5771                         changes.insert(m_file->endOf(newExpression), QStringLiteral("()"));
5772                     removeNewKeyword(changes, newExpression);
5773                 } else {
5774                     removeNewExpression(changes, newExpression);
5775                 }
5776             }
5777         }
5778 
5779         // Fix all occurrences of the identifier in this function.
5780         ASTPath astPath(m_document);
5781         foreach (const SemanticInfo::Use &use, semanticInfo().localUses.value(m_symbol)) {
5782             const QList<AST *> path = astPath(use.line, use.column);
5783             AST *idAST = path.last();
5784             bool declarationFound = false;
5785             bool starFound = false;
5786             int ampersandPos = 0;
5787             bool memberAccess = false;
5788             bool deleteCall = false;
5789 
5790             for (int i = path.count() - 2; i >= 0; --i) {
5791                 if (path.at(i) == m_declaratorAST) {
5792                     declarationFound = true;
5793                     break;
5794                 }
5795                 if (MemberAccessAST *memberAccessAST = path.at(i)->asMemberAccess()) {
5796                     if (m_file->tokenAt(memberAccessAST->access_token).kind() != T_ARROW)
5797                         continue;
5798                     int pos = m_file->startOf(memberAccessAST->access_token);
5799                     changes.replace(pos, pos + 2, QLatin1String("."));
5800                     memberAccess = true;
5801                     break;
5802                 } else if (DeleteExpressionAST *deleteAST = path.at(i)->asDeleteExpression()) {
5803                     const int pos = m_file->startOf(deleteAST->delete_token);
5804                     changes.insert(pos, QLatin1String("// "));
5805                     deleteCall = true;
5806                     break;
5807                 } else if (UnaryExpressionAST *unaryExprAST = path.at(i)->asUnaryExpression()) {
5808                     const Token tk = m_file->tokenAt(unaryExprAST->unary_op_token);
5809                     if (tk.kind() == T_STAR) {
5810                         if (!starFound) {
5811                             int pos = m_file->startOf(unaryExprAST->unary_op_token);
5812                             changes.remove(pos, pos + 1);
5813                         }
5814                         starFound = true;
5815                     } else if (tk.kind() == T_AMPER) {
5816                         ampersandPos = m_file->startOf(unaryExprAST->unary_op_token);
5817                     }
5818                 } else if (PointerAST *ptrAST = path.at(i)->asPointer()) {
5819                     if (!starFound) {
5820                         const int pos = m_file->startOf(ptrAST->star_token);
5821                         changes.remove(pos, pos);
5822                     }
5823                     starFound = true;
5824                 } else if (path.at(i)->asFunctionDefinition()) {
5825                     break;
5826                 }
5827             }
5828             if (!declarationFound && !starFound && !memberAccess && !deleteCall) {
5829                 if (ampersandPos) {
5830                     changes.insert(ampersandPos, QLatin1String("&("));
5831                     changes.insert(m_file->endOf(idAST->firstToken()), QLatin1String(")"));
5832                 } else {
5833                     changes.insert(m_file->startOf(idAST), QLatin1String("&"));
5834                 }
5835             }
5836         }
5837     }
5838 
5839     QString typeNameOfDeclaration() const
5840     {
5841         if (!m_simpleDeclaration
5842                 || !m_simpleDeclaration->decl_specifier_list
5843                 || !m_simpleDeclaration->decl_specifier_list->value) {
5844             return QString();
5845         }
5846         NamedTypeSpecifierAST *namedType
5847                 = m_simpleDeclaration->decl_specifier_list->value->asNamedTypeSpecifier();
5848         if (!namedType)
5849             return QString();
5850 
5851         Overview overview;
5852         return overview.prettyName(namedType->name->name);
5853     }
5854 
5855     void insertNewExpression(ChangeSet &changes, ExpressionAST *ast) const
5856     {
5857         const QString typeName = typeNameOfDeclaration();
5858         if (CallAST *callAST = ast->asCall()) {
5859             if (typeName.isEmpty()) {
5860                 changes.insert(m_file->startOf(callAST), QLatin1String("new "));
5861             } else {
5862                 changes.insert(m_file->startOf(callAST),
5863                                QLatin1String("new ") + typeName + QLatin1Char('('));
5864                 changes.insert(m_file->startOf(callAST->lastToken()), QLatin1String(")"));
5865             }
5866         } else {
5867             if (typeName.isEmpty())
5868                 return;
5869             changes.insert(m_file->startOf(ast), QLatin1String(" = new ") + typeName);
5870         }
5871     }
5872 
5873     void insertNewExpression(ChangeSet &changes) const
5874     {
5875         const QString typeName = typeNameOfDeclaration();
5876         if (typeName.isEmpty())
5877             return;
5878         changes.insert(m_file->endOf(m_identifierAST->firstToken()),
5879                        QLatin1String(" = new ") + typeName);
5880     }
5881 
5882     void convertToPointer(ChangeSet &changes) const
5883     {
5884         // Handle initializer.
5885         if (m_declaratorAST->initializer) {
5886             if (IdExpressionAST *idExprAST = m_declaratorAST->initializer->asIdExpression()) {
5887                 changes.insert(m_file->startOf(idExprAST), QLatin1String("&"));
5888             } else if (CallAST *callAST = m_declaratorAST->initializer->asCall()) {
5889                 insertNewExpression(changes, callAST);
5890             } else if (ExpressionListParenAST *exprListAST = m_declaratorAST->initializer
5891                                                                  ->asExpressionListParen()) {
5892                 insertNewExpression(changes, exprListAST);
5893             } else if (BracedInitializerAST *bracedInitializerAST = m_declaratorAST->initializer
5894                                                                         ->asBracedInitializer()) {
5895                 insertNewExpression(changes, bracedInitializerAST);
5896             }
5897         } else {
5898             insertNewExpression(changes);
5899         }
5900 
5901         // Fix all occurrences of the identifier in this function.
5902         ASTPath astPath(m_document);
5903         foreach (const SemanticInfo::Use &use, semanticInfo().localUses.value(m_symbol)) {
5904             const QList<AST *> path = astPath(use.line, use.column);
5905             AST *idAST = path.last();
5906             bool insertStar = true;
5907             for (int i = path.count() - 2; i >= 0; --i) {
5908                 if (m_isAutoDeclaration && path.at(i) == m_declaratorAST) {
5909                     insertStar = false;
5910                     break;
5911                 }
5912                 if (MemberAccessAST *memberAccessAST = path.at(i)->asMemberAccess()) {
5913                     const int pos = m_file->startOf(memberAccessAST->access_token);
5914                     changes.replace(pos, pos + 1, QLatin1String("->"));
5915                     insertStar = false;
5916                     break;
5917                 } else if (UnaryExpressionAST *unaryExprAST = path.at(i)->asUnaryExpression()) {
5918                     if (m_file->tokenAt(unaryExprAST->unary_op_token).kind() == T_AMPER) {
5919                         const int pos = m_file->startOf(unaryExprAST->unary_op_token);
5920                         changes.remove(pos, pos + 1);
5921                         insertStar = false;
5922                         break;
5923                     }
5924                 } else if (path.at(i)->asFunctionDefinition()) {
5925                     break;
5926                 }
5927             }
5928             if (insertStar)
5929                 changes.insert(m_file->startOf(idAST), QLatin1String("*"));
5930         }
5931     }
5932 
5933     const Mode m_mode;
5934     const bool m_isAutoDeclaration;
5935     const SimpleDeclarationAST * const m_simpleDeclaration;
5936     const DeclaratorAST * const m_declaratorAST;
5937     const SimpleNameAST * const m_identifierAST;
5938     Symbol * const m_symbol;
5939     const CppRefactoringChanges m_refactoring;
5940     const CppRefactoringFilePtr m_file;
5941     const Document::Ptr m_document;
5942 };
5943 
5944 } // anonymous namespace
5945 
5946 void ConvertFromAndToPointer::match(const CppQuickFixInterface &interface,
5947                                     QuickFixOperations &result)
5948 {
5949     const QList<AST *> &path = interface.path();
5950     if (path.count() < 2)
5951         return;
5952     SimpleNameAST *identifier = path.last()->asSimpleName();
5953     if (!identifier)
5954         return;
5955     SimpleDeclarationAST *simpleDeclaration = nullptr;
5956     DeclaratorAST *declarator = nullptr;
5957     bool isFunctionLocal = false;
5958     bool isClassLocal = false;
5959     ConvertFromAndToPointerOp::Mode mode = ConvertFromAndToPointerOp::FromVariable;
5960     for (int i = path.count() - 2; i >= 0; --i) {
5961         AST *ast = path.at(i);
5962         if (!declarator && (declarator = ast->asDeclarator()))
5963             continue;
5964         if (!simpleDeclaration && (simpleDeclaration = ast->asSimpleDeclaration()))
5965             continue;
5966         if (declarator && simpleDeclaration) {
5967             if (ast->asClassSpecifier()) {
5968                 isClassLocal = true;
5969             } else if (ast->asFunctionDefinition() && !isClassLocal) {
5970                 isFunctionLocal = true;
5971                 break;
5972             }
5973         }
5974     }
5975     if (!isFunctionLocal || !simpleDeclaration || !declarator)
5976         return;
5977 
5978     Symbol *symbol = nullptr;
5979     for (List<Symbol *> *lst = simpleDeclaration->symbols; lst; lst = lst->next) {
5980         if (lst->value->name() == identifier->name) {
5981             symbol = lst->value;
5982             break;
5983         }
5984     }
5985     if (!symbol)
5986         return;
5987 
5988     bool isAutoDeclaration = false;
5989     if (symbol->storage() == Symbol::Auto) {
5990         // For auto variables we must deduce the type from the initializer.
5991         if (!declarator->initializer)
5992             return;
5993 
5994         isAutoDeclaration = true;
5995         TypeOfExpression typeOfExpression;
5996         typeOfExpression.init(interface.semanticInfo().doc, interface.snapshot());
5997         typeOfExpression.setExpandTemplates(true);
5998         CppRefactoringFilePtr file = interface.currentFile();
5999         Scope *scope = file->scopeAt(declarator->firstToken());
6000         QList<LookupItem> result = typeOfExpression(file->textOf(declarator->initializer).toUtf8(),
6001                                                     scope, TypeOfExpression::Preprocess);
6002         if (!result.isEmpty() && result.first().type()->isPointerType())
6003             mode = ConvertFromAndToPointerOp::FromPointer;
6004     } else if (declarator->ptr_operator_list) {
6005         for (PtrOperatorListAST *ops = declarator->ptr_operator_list; ops; ops = ops->next) {
6006             if (ops != declarator->ptr_operator_list) {
6007                 // Bail out on more complex pointer types (e.g. pointer of pointer,
6008                 // or reference of pointer).
6009                 return;
6010             }
6011             if (ops->value->asPointer())
6012                 mode = ConvertFromAndToPointerOp::FromPointer;
6013             else if (ops->value->asReference())
6014                 mode = ConvertFromAndToPointerOp::FromReference;
6015         }
6016     }
6017 
6018     const int priority = path.size() - 1;
6019     result << new ConvertFromAndToPointerOp(interface, priority, mode, isAutoDeclaration,
6020                                             simpleDeclaration, declarator, identifier, symbol);
6021 }
6022 
6023 namespace {
6024 
6025 void extractNames(const CppRefactoringFilePtr &file,
6026                   QtPropertyDeclarationAST *qtPropertyDeclaration,
6027                   ExistingGetterSetterData &data)
6028 {
6029     QtPropertyDeclarationItemListAST *it = qtPropertyDeclaration->property_declaration_item_list;
6030     for (; it; it = it->next) {
6031         const char *tokenString = file->tokenAt(it->value->item_name_token).spell();
6032         if (!qstrcmp(tokenString, "READ")) {
6033             data.getterName = file->textOf(it->value->expression);
6034         } else if (!qstrcmp(tokenString, "WRITE")) {
6035             data.setterName = file->textOf(it->value->expression);
6036         } else if (!qstrcmp(tokenString, "RESET")) {
6037             data.resetName = file->textOf(it->value->expression);
6038         } else if (!qstrcmp(tokenString, "NOTIFY")) {
6039             data.signalName = file->textOf(it->value->expression);
6040         } else if (!qstrcmp(tokenString, "MEMBER")) {
6041             data.memberVariableName = file->textOf(it->value->expression);
6042         }
6043     }
6044 }
6045 
6046 } // anonymous namespace
6047 
6048 void InsertQtPropertyMembers::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
6049 {
6050     using Flag = GenerateGetterSetterOp::GenerateFlag;
6051     ExistingGetterSetterData existing;
6052     // check for Q_PROPERTY
6053 
6054     const QList<AST *> &path = interface.path();
6055     if (path.isEmpty())
6056         return;
6057 
6058     AST *const ast = path.last();
6059     QtPropertyDeclarationAST *qtPropertyDeclaration = ast->asQtPropertyDeclaration();
6060     if (!qtPropertyDeclaration || !qtPropertyDeclaration->type_id)
6061         return;
6062 
6063     ClassSpecifierAST *klass = nullptr;
6064     for (int i = path.size() - 2; i >= 0; --i) {
6065         klass = path.at(i)->asClassSpecifier();
6066         if (klass)
6067             break;
6068     }
6069     if (!klass)
6070         return;
6071     existing.clazz = klass->symbol;
6072 
6073     CppRefactoringFilePtr file = interface.currentFile();
6074     const QString propertyName = file->textOf(qtPropertyDeclaration->property_name);
6075     existing.qPropertyName = propertyName;
6076     extractNames(file, qtPropertyDeclaration, existing);
6077 
6078     Control *control = interface.currentFile()->cppDocument()->control();
6079 
6080     existing.declarationSymbol = control->newDeclaration(ast->firstToken(),
6081                                                          qtPropertyDeclaration->property_name->name);
6082     existing.declarationSymbol->setVisibility(Symbol::Private);
6083     existing.declarationSymbol->setEnclosingScope(existing.clazz);
6084 
6085     {
6086         // create a 'right' Type Object
6087         // if we have Q_PROPERTY(int test ...) then we only get a NamedType for 'int', but we want
6088         // a IntegerType. So create a new dummy file with a dummy declaration to get the right
6089         // object
6090         QByteArray type = file->textOf(qtPropertyDeclaration->type_id).toUtf8();
6091         QByteArray newSource = file->document()
6092                                    ->toPlainText()
6093                                    .insert(file->startOf(qtPropertyDeclaration),
6094                                            QString::fromUtf8(type + " __dummy;\n"))
6095                                    .toUtf8();
6096 
6097         Document::Ptr doc = interface.snapshot().preprocessedDocument(newSource, "___quickfix.h");
6098         if (!doc->parse(Document::ParseTranlationUnit))
6099             return;
6100         doc->check();
6101         class TypeFinder : public ASTVisitor
6102         {
6103         public:
6104             FullySpecifiedType type;
6105             TypeFinder(TranslationUnit *u)
6106                 : ASTVisitor(u)
6107             {}
6108             bool visit(SimpleDeclarationAST *ast) override
6109             {
6110                 if (ast->symbols && !ast->symbols->next) {
6111                     const Name *name = ast->symbols->value->name();
6112                     if (name && name->asNameId() && name->asNameId()->identifier()) {
6113                         const Identifier *id = name->asNameId()->identifier();
6114                         if (QString::fromUtf8(id->chars(), id->size()) == "__dummy")
6115                             type = ast->symbols->value->type();
6116                     }
6117                 }
6118                 return true;
6119             }
6120         };
6121         TypeFinder finder(doc->translationUnit());
6122         finder.accept(doc->translationUnit()->ast());
6123         if (finder.type.type()->isUndefinedType())
6124             return;
6125         existing.declarationSymbol->setType(finder.type);
6126         existing.doc = doc; // to hold type
6127     }
6128     // check which methods are already there
6129     const bool haveFixMemberVariableName = !existing.memberVariableName.isEmpty();
6130     int generateFlags = Flag::GenerateMemberVariable;
6131     if (!existing.resetName.isEmpty())
6132         generateFlags |= Flag::GenerateReset;
6133     if (!existing.setterName.isEmpty())
6134         generateFlags |= Flag::GenerateSetter;
6135     if (!existing.getterName.isEmpty())
6136         generateFlags |= Flag::GenerateGetter;
6137     if (!existing.signalName.isEmpty())
6138         generateFlags |= Flag::GenerateSignal;
6139     Overview overview;
6140     for (int i = 0; i < existing.clazz->memberCount(); ++i) {
6141         Symbol *member = existing.clazz->memberAt(i);
6142         FullySpecifiedType type = member->type();
6143         if (member->asFunction() || (type.isValid() && type->asFunctionType())) {
6144             const QString name = overview.prettyName(member->name());
6145             if (name == existing.getterName)
6146                 generateFlags &= ~Flag::GenerateGetter;
6147             else if (name == existing.setterName)
6148                 generateFlags &= ~Flag::GenerateSetter;
6149             else if (name == existing.resetName)
6150                 generateFlags &= ~Flag::GenerateReset;
6151             else if (name == existing.signalName)
6152                 generateFlags &= ~Flag::GenerateSignal;
6153         } else if (member->asDeclaration()) {
6154             const QString name = overview.prettyName(member->name());
6155             if (haveFixMemberVariableName) {
6156                 if (name == existing.memberVariableName) {
6157                     generateFlags &= ~Flag::GenerateMemberVariable;
6158                 }
6159             } else {
6160                 const QString baseName = memberBaseName(name);
6161                 if (existing.qPropertyName == baseName) {
6162                     existing.memberVariableName = name;
6163                     generateFlags &= ~Flag::GenerateMemberVariable;
6164                 }
6165             }
6166         }
6167     }
6168     if (generateFlags & Flag::GenerateMemberVariable) {
6169         CppQuickFixSettings *settings = CppQuickFixProjectsSettings::getQuickFixSettings(
6170             ProjectExplorer::ProjectTree::currentProject());
6171         existing.memberVariableName = settings->getMemberVariableName(existing.qPropertyName);
6172     }
6173     if (generateFlags == 0) {
6174         // everything is already there
6175         return;
6176     }
6177     generateFlags |= Flag::HaveExistingQProperty;
6178     GenerateGetterSetterOp::generateQuickFixes(result, interface, existing, generateFlags);
6179 }
6180 
6181 namespace {
6182 
6183 class ApplyDeclDefLinkOperation : public CppQuickFixOperation
6184 {
6185 public:
6186     explicit ApplyDeclDefLinkOperation(const CppQuickFixInterface &interface,
6187             const QSharedPointer<FunctionDeclDefLink> &link)
6188         : CppQuickFixOperation(interface, 100)
6189         , m_link(link)
6190     {}
6191 
6192     void perform() override
6193     {
6194         if (editor()->declDefLink() == m_link)
6195             editor()->applyDeclDefLinkChanges(/*don't jump*/false);
6196     }
6197 
6198 protected:
6199     virtual void performChanges(const CppRefactoringFilePtr &, const CppRefactoringChanges &)
6200     { /* never called since perform is overridden */ }
6201 
6202 private:
6203     QSharedPointer<FunctionDeclDefLink> m_link;
6204 };
6205 
6206 } // anonymous namespace
6207 
6208 void ApplyDeclDefLinkChanges::match(const CppQuickFixInterface &interface,
6209                                     QuickFixOperations &result)
6210 {
6211     QSharedPointer<FunctionDeclDefLink> link = interface.editor()->declDefLink();
6212     if (!link || !link->isMarkerVisible())
6213         return;
6214 
6215     auto op = new ApplyDeclDefLinkOperation(interface, link);
6216     op->setDescription(FunctionDeclDefLink::tr("Apply Function Signature Changes"));
6217     result << op;
6218 }
6219 
6220 namespace {
6221 
6222 QString definitionSignature(const CppQuickFixInterface *assist,
6223                             FunctionDefinitionAST *functionDefinitionAST,
6224                             CppRefactoringFilePtr &baseFile,
6225                             CppRefactoringFilePtr &targetFile,
6226                             Scope *scope)
6227 {
6228     QTC_ASSERT(assist, return QString());
6229     QTC_ASSERT(functionDefinitionAST, return QString());
6230     QTC_ASSERT(scope, return QString());
6231     Function *func = functionDefinitionAST->symbol;
6232     QTC_ASSERT(func, return QString());
6233 
6234     LookupContext cppContext(targetFile->cppDocument(), assist->snapshot());
6235     ClassOrNamespace *cppCoN = cppContext.lookupType(scope);
6236     if (!cppCoN)
6237         cppCoN = cppContext.globalNamespace();
6238     SubstitutionEnvironment env;
6239     env.setContext(assist->context());
6240     env.switchScope(func->enclosingScope());
6241     UseMinimalNames q(cppCoN);
6242     env.enter(&q);
6243     Control *control = assist->context().bindings()->control().data();
6244     Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
6245     oo.showFunctionSignatures = true;
6246     oo.showReturnTypes = true;
6247     oo.showArgumentNames = true;
6248     oo.showEnclosingTemplate = true;
6249     oo.showTemplateParameters = true;
6250     oo.trailingReturnType = functionDefinitionAST->declarator
6251             && functionDefinitionAST->declarator->postfix_declarator_list
6252             && functionDefinitionAST->declarator->postfix_declarator_list->value
6253             && functionDefinitionAST->declarator->postfix_declarator_list
6254                     ->value->asFunctionDeclarator()
6255             && functionDefinitionAST->declarator->postfix_declarator_list
6256                     ->value->asFunctionDeclarator()->trailing_return_type;
6257     const Name *name = func->name();
6258     if (name && nameIncludesOperatorName(name)) {
6259         CoreDeclaratorAST *coreDeclarator = functionDefinitionAST->declarator->core_declarator;
6260         const QString operatorNameText = baseFile->textOf(coreDeclarator);
6261         oo.includeWhiteSpaceInOperatorName = operatorNameText.contains(QLatin1Char(' '));
6262     }
6263     const QString nameText = oo.prettyName(LookupContext::minimalName(func, cppCoN, control));
6264     const FullySpecifiedType tn = rewriteType(func->type(), &env, control);
6265 
6266     return oo.prettyType(tn, nameText);
6267 }
6268 
6269 class MoveFuncDefRefactoringHelper
6270 {
6271 public:
6272     enum MoveType {
6273         MoveOutside,
6274         MoveToCppFile,
6275         MoveOutsideMemberToCppFile
6276     };
6277 
6278     MoveFuncDefRefactoringHelper(CppQuickFixOperation *operation, MoveType type,
6279                                  const QString &fromFile, const QString &toFile)
6280         : m_operation(operation), m_type(type), m_changes(m_operation->snapshot())
6281     {
6282         m_fromFile = m_changes.file(Utils::FilePath::fromString(fromFile));
6283         m_toFile = (m_type == MoveOutside) ? m_fromFile
6284                                            : m_changes.file(Utils::FilePath::fromString(toFile));
6285     }
6286 
6287     void performMove(FunctionDefinitionAST *funcAST)
6288     {
6289         // Determine file, insert position and scope
6290         InsertionLocation l = insertLocationForMethodDefinition(
6291                     funcAST->symbol, false, NamespaceHandling::Ignore,
6292                     m_changes, m_toFile->filePath().toString());
6293         const QString prefix = l.prefix();
6294         const QString suffix = l.suffix();
6295         const int insertPos = m_toFile->position(l.line(), l.column());
6296         Scope *scopeAtInsertPos = m_toFile->cppDocument()->scopeAt(l.line(), l.column());
6297 
6298         // construct definition
6299         const QString funcDec = inlinePrefix(
6300                     m_toFile->filePath().toString(), [this] { return m_type == MoveOutside; })
6301                 + definitionSignature(m_operation, funcAST, m_fromFile, m_toFile,
6302                                       scopeAtInsertPos);
6303         QString funcDef = prefix + funcDec;
6304         const int startPosition = m_fromFile->endOf(funcAST->declarator);
6305         const int endPosition = m_fromFile->endOf(funcAST);
6306         funcDef += m_fromFile->textOf(startPosition, endPosition);
6307         funcDef += suffix;
6308 
6309         // insert definition at new position
6310         m_toFileChangeSet.insert(insertPos, funcDef);
6311         m_toFile->appendIndentRange(ChangeSet::Range(insertPos, insertPos + funcDef.size()));
6312         m_toFile->setOpenEditor(true, insertPos);
6313 
6314         // remove definition from fromFile
6315         if (m_type == MoveOutsideMemberToCppFile) {
6316             m_fromFileChangeSet.remove(m_fromFile->range(funcAST));
6317         } else {
6318             QString textFuncDecl = m_fromFile->textOf(funcAST);
6319             textFuncDecl.truncate(startPosition - m_fromFile->startOf(funcAST));
6320             if (textFuncDecl.left(7) == QLatin1String("inline "))
6321                 textFuncDecl = textFuncDecl.mid(7);
6322             else
6323                 textFuncDecl.replace(" inline ", QLatin1String(" "));
6324             textFuncDecl = textFuncDecl.trimmed() + QLatin1Char(';');
6325             m_fromFileChangeSet.replace(m_fromFile->range(funcAST), textFuncDecl);
6326         }
6327     }
6328 
6329     void applyChanges()
6330     {
6331         if (!m_toFileChangeSet.isEmpty()) {
6332             m_toFile->setChangeSet(m_toFileChangeSet);
6333             m_toFile->apply();
6334         }
6335         if (!m_fromFileChangeSet.isEmpty()) {
6336             m_fromFile->setChangeSet(m_fromFileChangeSet);
6337             m_fromFile->apply();
6338         }
6339     }
6340 
6341 private:
6342     CppQuickFixOperation *m_operation;
6343     MoveType m_type;
6344     CppRefactoringChanges m_changes;
6345     CppRefactoringFilePtr m_fromFile;
6346     CppRefactoringFilePtr m_toFile;
6347     ChangeSet m_fromFileChangeSet;
6348     ChangeSet m_toFileChangeSet;
6349 };
6350 
6351 class MoveFuncDefOutsideOp : public CppQuickFixOperation
6352 {
6353 public:
6354     MoveFuncDefOutsideOp(const CppQuickFixInterface &interface,
6355                          MoveFuncDefRefactoringHelper::MoveType type,
6356                          FunctionDefinitionAST *funcDef, const QString &cppFileName)
6357         : CppQuickFixOperation(interface, 0)
6358         , m_funcDef(funcDef)
6359         , m_type(type)
6360         , m_cppFileName(cppFileName)
6361         , m_headerFileName(QString::fromUtf8(funcDef->symbol->fileName(),
6362                                              funcDef->symbol->fileNameLength()))
6363     {
6364         if (m_type == MoveFuncDefRefactoringHelper::MoveOutside) {
6365             setDescription(QCoreApplication::translate("CppEditor::QuickFix",
6366                                                        "Move Definition Outside Class"));
6367         } else {
6368             const QDir dir = QFileInfo(m_headerFileName).dir();
6369             setDescription(QCoreApplication::translate("CppEditor::QuickFix",
6370                                                        "Move Definition to %1")
6371                            .arg(dir.relativeFilePath(m_cppFileName)));
6372         }
6373     }
6374 
6375     void perform() override
6376     {
6377         MoveFuncDefRefactoringHelper helper(this, m_type, m_headerFileName, m_cppFileName);
6378         helper.performMove(m_funcDef);
6379         helper.applyChanges();
6380     }
6381 
6382 private:
6383     FunctionDefinitionAST *m_funcDef;
6384     MoveFuncDefRefactoringHelper::MoveType m_type;
6385     const QString m_cppFileName;
6386     const QString m_headerFileName;
6387 };
6388 
6389 } // anonymous namespace
6390 
6391 void MoveFuncDefOutside::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
6392 {
6393     const QList<AST *> &path = interface.path();
6394     SimpleDeclarationAST *classAST = nullptr;
6395     FunctionDefinitionAST *funcAST = nullptr;
6396     bool moveOutsideMemberDefinition = false;
6397 
6398     const int pathSize = path.size();
6399     for (int idx = 1; idx < pathSize; ++idx) {
6400         if ((funcAST = path.at(idx)->asFunctionDefinition())) {
6401             // check cursor position
6402             if (idx != pathSize - 1  // Do not allow "void a() @ {..."
6403                     && funcAST->function_body
6404                     && !interface.isCursorOn(funcAST->function_body)) {
6405                 if (path.at(idx - 1)->asTranslationUnit()) { // normal function
6406                     if (idx + 3 < pathSize && path.at(idx + 3)->asQualifiedName()) // Outside member
6407                         moveOutsideMemberDefinition = true;                        // definition
6408                     break;
6409                 }
6410 
6411                 if (idx > 1) {
6412                     if ((classAST = path.at(idx - 2)->asSimpleDeclaration())) // member function
6413                         break;
6414                     if (path.at(idx - 2)->asNamespace())  // normal function in namespace
6415                         break;
6416                 }
6417             }
6418             funcAST = nullptr;
6419         }
6420     }
6421 
6422     if (!funcAST || !funcAST->symbol)
6423         return;
6424 
6425     bool isHeaderFile = false;
6426     const QString cppFileName = correspondingHeaderOrSource(interface.filePath().toString(),
6427                                                             &isHeaderFile);
6428 
6429     if (isHeaderFile && !cppFileName.isEmpty()) {
6430         const MoveFuncDefRefactoringHelper::MoveType type = moveOutsideMemberDefinition
6431                 ? MoveFuncDefRefactoringHelper::MoveOutsideMemberToCppFile
6432                 : MoveFuncDefRefactoringHelper::MoveToCppFile;
6433         result << new MoveFuncDefOutsideOp(interface, type, funcAST, cppFileName);
6434     }
6435 
6436     if (classAST)
6437         result << new MoveFuncDefOutsideOp(interface, MoveFuncDefRefactoringHelper::MoveOutside,
6438                                            funcAST, QLatin1String(""));
6439 
6440     return;
6441 }
6442 
6443 namespace {
6444 
6445 class MoveAllFuncDefOutsideOp : public CppQuickFixOperation
6446 {
6447 public:
6448     MoveAllFuncDefOutsideOp(const CppQuickFixInterface &interface,
6449                             MoveFuncDefRefactoringHelper::MoveType type,
6450                             ClassSpecifierAST *classDef, const QString &cppFileName)
6451         : CppQuickFixOperation(interface, 0)
6452         , m_type(type)
6453         , m_classDef(classDef)
6454         , m_cppFileName(cppFileName)
6455         , m_headerFileName(QString::fromUtf8(classDef->symbol->fileName(),
6456                                              classDef->symbol->fileNameLength()))
6457     {
6458         if (m_type == MoveFuncDefRefactoringHelper::MoveOutside) {
6459             setDescription(QCoreApplication::translate("CppEditor::QuickFix", "Move All Function "
6460                                                        "Definitions Outside Class"));
6461         } else {
6462             const QDir dir = QFileInfo(m_headerFileName).dir();
6463             setDescription(QCoreApplication::translate("CppEditor::QuickFix",
6464                                                        "Move All Function Definitions to %1")
6465                            .arg(dir.relativeFilePath(m_cppFileName)));
6466         }
6467     }
6468 
6469     void perform() override
6470     {
6471         MoveFuncDefRefactoringHelper helper(this, m_type, m_headerFileName, m_cppFileName);
6472         for (DeclarationListAST *it = m_classDef->member_specifier_list; it; it = it->next) {
6473             if (FunctionDefinitionAST *funcAST = it->value->asFunctionDefinition()) {
6474                 if (funcAST->symbol && !funcAST->symbol->isGenerated())
6475                     helper.performMove(funcAST);
6476             }
6477         }
6478         helper.applyChanges();
6479     }
6480 
6481 private:
6482     MoveFuncDefRefactoringHelper::MoveType m_type;
6483     ClassSpecifierAST *m_classDef;
6484     const QString m_cppFileName;
6485     const QString m_headerFileName;
6486 };
6487 
6488 } // anonymous namespace
6489 
6490 void MoveAllFuncDefOutside::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
6491 {
6492     ClassSpecifierAST * const classAST = astForClassOperations(interface);
6493     if (!classAST)
6494         return;
6495 
6496     // Determine if the class has at least one function definition
6497     bool classContainsFunctions = false;
6498     for (DeclarationListAST *it = classAST->member_specifier_list; it; it = it->next) {
6499         if (FunctionDefinitionAST *funcAST = it->value->asFunctionDefinition()) {
6500             if (funcAST->symbol && !funcAST->symbol->isGenerated()) {
6501                 classContainsFunctions = true;
6502                 break;
6503             }
6504         }
6505     }
6506     if (!classContainsFunctions)
6507         return;
6508 
6509     bool isHeaderFile = false;
6510     const QString cppFileName = correspondingHeaderOrSource(interface.filePath().toString(),
6511                                                             &isHeaderFile);
6512     if (isHeaderFile && !cppFileName.isEmpty()) {
6513         result << new MoveAllFuncDefOutsideOp(interface,
6514                                               MoveFuncDefRefactoringHelper::MoveToCppFile,
6515                                               classAST, cppFileName);
6516     }
6517     result << new MoveAllFuncDefOutsideOp(interface, MoveFuncDefRefactoringHelper::MoveOutside,
6518                                           classAST, QLatin1String(""));
6519 }
6520 
6521 namespace {
6522 
6523 class MoveFuncDefToDeclOp : public CppQuickFixOperation
6524 {
6525 public:
6526     MoveFuncDefToDeclOp(const CppQuickFixInterface &interface,
6527                         const QString &fromFileName, const QString &toFileName,
6528                         FunctionDefinitionAST *funcDef, const QString &declText,
6529                         const ChangeSet::Range &fromRange,
6530                         const ChangeSet::Range &toRange)
6531         : CppQuickFixOperation(interface, 0)
6532         , m_fromFileName(fromFileName)
6533         , m_toFileName(toFileName)
6534         , m_funcAST(funcDef)
6535         , m_declarationText(declText)
6536         , m_fromRange(fromRange)
6537         , m_toRange(toRange)
6538     {
6539         if (m_toFileName == m_fromFileName) {
6540             setDescription(QCoreApplication::translate("CppEditor::QuickFix",
6541                                                        "Move Definition to Class"));
6542         } else {
6543             const QDir dir = QFileInfo(m_fromFileName).dir();
6544             setDescription(QCoreApplication::translate("CppEditor::QuickFix",
6545                                                        "Move Definition to %1")
6546                            .arg(dir.relativeFilePath(m_toFileName)));
6547         }
6548     }
6549 
6550     void perform() override
6551     {
6552         CppRefactoringChanges refactoring(snapshot());
6553         CppRefactoringFilePtr fromFile = refactoring.file(Utils::FilePath::fromString(m_fromFileName));
6554         CppRefactoringFilePtr toFile = refactoring.file(Utils::FilePath::fromString(m_toFileName));
6555 
6556         const QString wholeFunctionText = m_declarationText
6557                 + fromFile->textOf(fromFile->endOf(m_funcAST->declarator),
6558                                    fromFile->endOf(m_funcAST->function_body));
6559 
6560         // Replace declaration with function and delete old definition
6561         ChangeSet toTarget;
6562         toTarget.replace(m_toRange, wholeFunctionText);
6563         if (m_toFileName == m_fromFileName)
6564             toTarget.remove(m_fromRange);
6565         toFile->setChangeSet(toTarget);
6566         toFile->appendIndentRange(m_toRange);
6567         toFile->setOpenEditor(true, m_toRange.start);
6568         toFile->apply();
6569         if (m_toFileName != m_fromFileName) {
6570             ChangeSet fromTarget;
6571             fromTarget.remove(m_fromRange);
6572             fromFile->setChangeSet(fromTarget);
6573             fromFile->apply();
6574         }
6575     }
6576 
6577 private:
6578     const QString m_fromFileName;
6579     const QString m_toFileName;
6580     FunctionDefinitionAST *m_funcAST;
6581     const QString m_declarationText;
6582     const ChangeSet::Range m_fromRange;
6583     const ChangeSet::Range m_toRange;
6584 };
6585 
6586 } // anonymous namespace
6587 
6588 void MoveFuncDefToDecl::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
6589 {
6590     const QList<AST *> &path = interface.path();
6591     AST *completeDefAST = nullptr;
6592     FunctionDefinitionAST *funcAST = nullptr;
6593 
6594     const int pathSize = path.size();
6595     for (int idx = 1; idx < pathSize; ++idx) {
6596         if ((funcAST = path.at(idx)->asFunctionDefinition())) {
6597             AST *enclosingAST = path.at(idx - 1);
6598             if (enclosingAST->asClassSpecifier())
6599                 return;
6600 
6601             // check cursor position
6602             if (idx != pathSize - 1  // Do not allow "void a() @ {..."
6603                     && funcAST->function_body
6604                     && !interface.isCursorOn(funcAST->function_body)) {
6605                 completeDefAST = enclosingAST->asTemplateDeclaration() ? enclosingAST : funcAST;
6606                 break;
6607             }
6608             funcAST = nullptr;
6609         }
6610     }
6611 
6612     if (!funcAST || !funcAST->symbol)
6613         return;
6614 
6615     const CppRefactoringChanges refactoring(interface.snapshot());
6616     const CppRefactoringFilePtr defFile = refactoring.file(interface.filePath());
6617     const ChangeSet::Range defRange = defFile->range(completeDefAST);
6618 
6619     // Determine declaration (file, range, text);
6620     QString declFileName;
6621     ChangeSet::Range declRange;
6622     QString declText;
6623 
6624     Function *func = funcAST->symbol;
6625     if (Class *matchingClass = isMemberFunction(interface.context(), func)) {
6626         // Dealing with member functions
6627         const QualifiedNameId *qName = func->name()->asQualifiedNameId();
6628         for (Symbol *symbol = matchingClass->find(qName->identifier());
6629              symbol; symbol = symbol->next()) {
6630             Symbol *s = symbol;
6631             if (func->enclosingScope()->isTemplate()) {
6632                 if (const Template *templ = s->type()->asTemplateType()) {
6633                     if (Symbol *decl = templ->declaration()) {
6634                         if (decl->type()->isFunctionType())
6635                                 s = decl;
6636                     }
6637                 }
6638             }
6639             if (!s->name()
6640                     || !qName->identifier()->match(s->identifier())
6641                     || !s->type()->isFunctionType()
6642                     || !s->type().match(func->type())
6643                     || s->isFunction()) {
6644                 continue;
6645             }
6646 
6647             declFileName = QString::fromUtf8(matchingClass->fileName(),
6648                                              matchingClass->fileNameLength());
6649 
6650             const CppRefactoringFilePtr declFile = refactoring.file(Utils::FilePath::fromString(declFileName));
6651             ASTPath astPath(declFile->cppDocument());
6652             const QList<AST *> path = astPath(s->line(), s->column());
6653             for (int idx = path.size() - 1; idx > 0; --idx) {
6654                 AST *node = path.at(idx);
6655                 if (SimpleDeclarationAST *simpleDecl = node->asSimpleDeclaration()) {
6656                     if (simpleDecl->symbols && !simpleDecl->symbols->next) {
6657                         declRange = declFile->range(simpleDecl);
6658                         declText = declFile->textOf(simpleDecl);
6659                         declText.remove(-1, 1); // remove ';' from declaration text
6660                         break;
6661                     }
6662                 }
6663             }
6664 
6665             if (!declText.isEmpty())
6666                 break;
6667         }
6668     } else if (Namespace *matchingNamespace = isNamespaceFunction(interface.context(), func)) {
6669         // Dealing with free functions
6670         bool isHeaderFile = false;
6671         declFileName = correspondingHeaderOrSource(interface.filePath().toString(), &isHeaderFile);
6672         if (isHeaderFile)
6673             return;
6674 
6675         const CppRefactoringFilePtr declFile = refactoring.file(
6676             Utils::FilePath::fromString(declFileName));
6677         const LookupContext lc(declFile->cppDocument(), interface.snapshot());
6678         const QList<LookupItem> candidates = lc.lookup(func->name(), matchingNamespace);
6679         for (const LookupItem &candidate : candidates) {
6680             if (Symbol *s = candidate.declaration()) {
6681                 if (s->asDeclaration()) {
6682                     ASTPath astPath(declFile->cppDocument());
6683                     const QList<AST *> path = astPath(s->line(), s->column());
6684                     for (AST *node : path) {
6685                         if (SimpleDeclarationAST *simpleDecl = node->asSimpleDeclaration()) {
6686                             declRange = declFile->range(simpleDecl);
6687                             declText = declFile->textOf(simpleDecl);
6688                             declText.remove(-1, 1); // remove ';' from declaration text
6689                             break;
6690                         }
6691                     }
6692                 }
6693             }
6694 
6695             if (!declText.isEmpty()) {
6696                 declText.prepend(inlinePrefix(declFileName));
6697                 break;
6698             }
6699         }
6700     }
6701 
6702     if (!declFileName.isEmpty() && !declText.isEmpty())
6703         result << new MoveFuncDefToDeclOp(interface,
6704                                           interface.filePath().toString(),
6705                                           declFileName,
6706                                           funcAST, declText,
6707                                           defRange, declRange);
6708 }
6709 
6710 namespace {
6711 
6712 class AssignToLocalVariableOperation : public CppQuickFixOperation
6713 {
6714 public:
6715     explicit AssignToLocalVariableOperation(const CppQuickFixInterface &interface,
6716                                             const int insertPos, const AST *ast, const Name *name)
6717         : CppQuickFixOperation(interface)
6718         , m_insertPos(insertPos)
6719         , m_ast(ast)
6720         , m_name(name)
6721     {
6722         setDescription(QApplication::translate("CppEditor::QuickFix", "Assign to Local Variable"));
6723     }
6724 
6725     void perform() override
6726     {
6727         CppRefactoringChanges refactoring(snapshot());
6728         CppRefactoringFilePtr file = refactoring.file(filePath());
6729 
6730         // Determine return type and new variable name
6731         TypeOfExpression typeOfExpression;
6732         typeOfExpression.init(semanticInfo().doc, snapshot(),
6733                               context().bindings());
6734         typeOfExpression.setExpandTemplates(true);
6735         Scope *scope = file->scopeAt(m_ast->firstToken());
6736         const QList<LookupItem> result = typeOfExpression(file->textOf(m_ast).toUtf8(),
6737                                                           scope, TypeOfExpression::Preprocess);
6738 
6739         if (!result.isEmpty()) {
6740             SubstitutionEnvironment env;
6741             env.setContext(context());
6742             env.switchScope(result.first().scope());
6743             ClassOrNamespace *con = typeOfExpression.context().lookupType(scope);
6744             if (!con)
6745                 con = typeOfExpression.context().globalNamespace();
6746             UseMinimalNames q(con);
6747             env.enter(&q);
6748 
6749             Control *control = context().bindings()->control().data();
6750             FullySpecifiedType type = rewriteType(result.first().type(), &env, control);
6751 
6752             Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
6753             QString originalName = oo.prettyName(m_name);
6754             QString newName = originalName;
6755             if (newName.startsWith(QLatin1String("get"), Qt::CaseInsensitive)
6756                     && newName.length() > 3
6757                     && newName.at(3).isUpper()) {
6758                 newName.remove(0, 3);
6759                 newName.replace(0, 1, newName.at(0).toLower());
6760             } else if (newName.startsWith(QLatin1String("to"), Qt::CaseInsensitive)
6761                        && newName.length() > 2
6762                        && newName.at(2).isUpper()) {
6763                 newName.remove(0, 2);
6764                 newName.replace(0, 1, newName.at(0).toLower());
6765             } else {
6766                 newName.replace(0, 1, newName.at(0).toUpper());
6767                 newName.prepend(QLatin1String("local"));
6768             }
6769 
6770             const int nameLength = originalName.length();
6771             QString tempType = oo.prettyType(type, m_name);
6772             const QString insertString = tempType.replace(
6773                         tempType.length() - nameLength, nameLength, newName + QLatin1String(" = "));
6774             if (!tempType.isEmpty()) {
6775                 ChangeSet changes;
6776                 changes.insert(m_insertPos, insertString);
6777                 file->setChangeSet(changes);
6778                 file->apply();
6779 
6780                 // move cursor to new variable name
6781                 QTextCursor c = file->cursor();
6782                 c.setPosition(m_insertPos + insertString.length() - newName.length() - 3);
6783                 c.movePosition(QTextCursor::EndOfWord, QTextCursor::KeepAnchor);
6784                 editor()->setTextCursor(c);
6785             }
6786         }
6787     }
6788 
6789 private:
6790     const int m_insertPos;
6791     const AST *m_ast;
6792     const Name *m_name;
6793 };
6794 
6795 } // anonymous namespace
6796 
6797 void AssignToLocalVariable::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
6798 {
6799     const QList<AST *> &path = interface.path();
6800     AST *outerAST = nullptr;
6801     SimpleNameAST *nameAST = nullptr;
6802 
6803     for (int i = path.size() - 3; i >= 0; --i) {
6804         if (CallAST *callAST = path.at(i)->asCall()) {
6805             if (!interface.isCursorOn(callAST))
6806                 return;
6807             if (i - 2 >= 0) {
6808                 const int idx = i - 2;
6809                 if (path.at(idx)->asSimpleDeclaration())
6810                     return;
6811                 if (path.at(idx)->asExpressionStatement())
6812                     return;
6813                 if (path.at(idx)->asMemInitializer())
6814                     return;
6815                 if (path.at(idx)->asCall()) { // Fallback if we have a->b()->c()...
6816                     --i;
6817                     continue;
6818                 }
6819             }
6820             for (int a = i - 1; a > 0; --a) {
6821                 if (path.at(a)->asBinaryExpression())
6822                     return;
6823                 if (path.at(a)->asReturnStatement())
6824                     return;
6825                 if (path.at(a)->asCall())
6826                     return;
6827             }
6828 
6829             if (MemberAccessAST *member = path.at(i + 1)->asMemberAccess()) { // member
6830                 if (NameAST *name = member->member_name)
6831                     nameAST = name->asSimpleName();
6832             } else if (QualifiedNameAST *qname = path.at(i + 2)->asQualifiedName()) { // static or
6833                 nameAST = qname->unqualified_name->asSimpleName();                    // func in ns
6834             } else { // normal
6835                 nameAST = path.at(i + 2)->asSimpleName();
6836             }
6837 
6838             if (nameAST) {
6839                 outerAST = callAST;
6840                 break;
6841             }
6842         } else if (NewExpressionAST *newexp = path.at(i)->asNewExpression()) {
6843             if (!interface.isCursorOn(newexp))
6844                 return;
6845             if (i - 2 >= 0) {
6846                 const int idx = i - 2;
6847                 if (path.at(idx)->asSimpleDeclaration())
6848                     return;
6849                 if (path.at(idx)->asExpressionStatement())
6850                     return;
6851                 if (path.at(idx)->asMemInitializer())
6852                     return;
6853             }
6854             for (int a = i - 1; a > 0; --a) {
6855                 if (path.at(a)->asReturnStatement())
6856                     return;
6857                 if (path.at(a)->asCall())
6858                     return;
6859             }
6860 
6861             if (NamedTypeSpecifierAST *ts = path.at(i + 2)->asNamedTypeSpecifier()) {
6862                 nameAST = ts->name->asSimpleName();
6863                 outerAST = newexp;
6864                 break;
6865             }
6866         }
6867     }
6868 
6869     if (outerAST && nameAST) {
6870         const CppRefactoringFilePtr file = interface.currentFile();
6871         QList<LookupItem> items;
6872         TypeOfExpression typeOfExpression;
6873         typeOfExpression.init(interface.semanticInfo().doc, interface.snapshot(),
6874                               interface.context().bindings());
6875         typeOfExpression.setExpandTemplates(true);
6876 
6877         // If items are empty, AssignToLocalVariableOperation will fail.
6878         items = typeOfExpression(file->textOf(outerAST).toUtf8(),
6879                                  file->scopeAt(outerAST->firstToken()),
6880                                  TypeOfExpression::Preprocess);
6881         if (items.isEmpty())
6882             return;
6883 
6884         if (CallAST *callAST = outerAST->asCall()) {
6885             items = typeOfExpression(file->textOf(callAST->base_expression).toUtf8(),
6886                                      file->scopeAt(callAST->base_expression->firstToken()),
6887                                      TypeOfExpression::Preprocess);
6888         } else {
6889             items = typeOfExpression(file->textOf(nameAST).toUtf8(),
6890                                      file->scopeAt(nameAST->firstToken()),
6891                                      TypeOfExpression::Preprocess);
6892         }
6893 
6894         foreach (const LookupItem &item, items) {
6895             if (!item.declaration())
6896                 continue;
6897 
6898             if (Function *func = item.declaration()->asFunction()) {
6899                 if (func->isSignal() || func->returnType()->isVoidType())
6900                     return;
6901             } else if (Declaration *dec = item.declaration()->asDeclaration()) {
6902                 if (Function *func = dec->type()->asFunctionType()) {
6903                     if (func->isSignal() || func->returnType()->isVoidType())
6904                       return;
6905                 }
6906             }
6907 
6908             const Name *name = nameAST->name;
6909             const int insertPos = interface.currentFile()->startOf(outerAST);
6910             result << new AssignToLocalVariableOperation(interface, insertPos, outerAST, name);
6911             return;
6912         }
6913     }
6914 }
6915 
6916 namespace {
6917 
6918 class OptimizeForLoopOperation: public CppQuickFixOperation
6919 {
6920 public:
6921     OptimizeForLoopOperation(const CppQuickFixInterface &interface, const ForStatementAST *forAst,
6922                              const bool optimizePostcrement, const ExpressionAST *expression,
6923                              const FullySpecifiedType &type)
6924         : CppQuickFixOperation(interface)
6925         , m_forAst(forAst)
6926         , m_optimizePostcrement(optimizePostcrement)
6927         , m_expression(expression)
6928         , m_type(type)
6929     {
6930         setDescription(QApplication::translate("CppEditor::QuickFix", "Optimize for-Loop"));
6931     }
6932 
6933     void perform() override
6934     {
6935         QTC_ASSERT(m_forAst, return);
6936 
6937         const Utils::FilePath filePath = currentFile()->filePath();
6938         const CppRefactoringChanges refactoring(snapshot());
6939         const CppRefactoringFilePtr file = refactoring.file(filePath);
6940         ChangeSet change;
6941 
6942         // Optimize post (in|de)crement operator to pre (in|de)crement operator
6943         if (m_optimizePostcrement && m_forAst->expression) {
6944             PostIncrDecrAST *incrdecr = m_forAst->expression->asPostIncrDecr();
6945             if (incrdecr && incrdecr->base_expression && incrdecr->incr_decr_token) {
6946                 change.flip(file->range(incrdecr->base_expression),
6947                             file->range(incrdecr->incr_decr_token));
6948             }
6949         }
6950 
6951         // Optimize Condition
6952         int renamePos = -1;
6953         if (m_expression) {
6954             QString varName = QLatin1String("total");
6955 
6956             if (file->textOf(m_forAst->initializer).length() == 1) {
6957                 Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
6958                 const QString typeAndName = oo.prettyType(m_type, varName);
6959                 renamePos = file->endOf(m_forAst->initializer) - 1 + typeAndName.length();
6960                 change.insert(file->endOf(m_forAst->initializer) - 1, // "-1" because of ";"
6961                               typeAndName + QLatin1String(" = ") + file->textOf(m_expression));
6962             } else {
6963                 // Check if varName is already used
6964                 if (DeclarationStatementAST *ds = m_forAst->initializer->asDeclarationStatement()) {
6965                     if (DeclarationAST *decl = ds->declaration) {
6966                         if (SimpleDeclarationAST *sdecl = decl->asSimpleDeclaration()) {
6967                             for (;;) {
6968                                 bool match = false;
6969                                 for (DeclaratorListAST *it = sdecl->declarator_list; it;
6970                                      it = it->next) {
6971                                     if (file->textOf(it->value->core_declarator) == varName) {
6972                                         varName += QLatin1Char('X');
6973                                         match = true;
6974                                         break;
6975                                     }
6976                                 }
6977                                 if (!match)
6978                                     break;
6979                             }
6980                         }
6981                     }
6982                 }
6983 
6984                 renamePos = file->endOf(m_forAst->initializer) + 1;
6985                 change.insert(file->endOf(m_forAst->initializer) - 1, // "-1" because of ";"
6986                               QLatin1String(", ") + varName + QLatin1String(" = ")
6987                               + file->textOf(m_expression));
6988             }
6989 
6990             ChangeSet::Range exprRange(file->startOf(m_expression), file->endOf(m_expression));
6991             change.replace(exprRange, varName);
6992         }
6993 
6994         file->setChangeSet(change);
6995         file->apply();
6996 
6997         // Select variable name and trigger symbol rename
6998         if (renamePos != -1) {
6999             QTextCursor c = file->cursor();
7000             c.setPosition(renamePos);
7001             editor()->setTextCursor(c);
7002             editor()->renameSymbolUnderCursor();
7003             c.select(QTextCursor::WordUnderCursor);
7004             editor()->setTextCursor(c);
7005         }
7006     }
7007 
7008 private:
7009     const ForStatementAST *m_forAst;
7010     const bool m_optimizePostcrement;
7011     const ExpressionAST *m_expression;
7012     const FullySpecifiedType m_type;
7013 };
7014 
7015 } // anonymous namespace
7016 
7017 void OptimizeForLoop::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
7018 {
7019     const QList<AST *> path = interface.path();
7020     ForStatementAST *forAst = nullptr;
7021     if (!path.isEmpty())
7022         forAst = path.last()->asForStatement();
7023     if (!forAst || !interface.isCursorOn(forAst))
7024         return;
7025 
7026     // Check for optimizing a postcrement
7027     const CppRefactoringFilePtr file = interface.currentFile();
7028     bool optimizePostcrement = false;
7029     if (forAst->expression) {
7030         if (PostIncrDecrAST *incrdecr = forAst->expression->asPostIncrDecr()) {
7031             const Token t = file->tokenAt(incrdecr->incr_decr_token);
7032             if (t.is(T_PLUS_PLUS) || t.is(T_MINUS_MINUS))
7033                 optimizePostcrement = true;
7034         }
7035     }
7036 
7037     // Check for optimizing condition
7038     bool optimizeCondition = false;
7039     FullySpecifiedType conditionType;
7040     ExpressionAST *conditionExpression = nullptr;
7041     if (forAst->initializer && forAst->condition) {
7042         if (BinaryExpressionAST *binary = forAst->condition->asBinaryExpression()) {
7043             // Get the expression against which we should evaluate
7044             IdExpressionAST *conditionId = binary->left_expression->asIdExpression();
7045             if (conditionId) {
7046                 conditionExpression = binary->right_expression;
7047             } else {
7048                 conditionId = binary->right_expression->asIdExpression();
7049                 conditionExpression = binary->left_expression;
7050             }
7051 
7052             if (conditionId && conditionExpression
7053                     && !(conditionExpression->asNumericLiteral()
7054                          || conditionExpression->asStringLiteral()
7055                          || conditionExpression->asIdExpression()
7056                          || conditionExpression->asUnaryExpression())) {
7057                 // Determine type of for initializer
7058                 FullySpecifiedType initializerType;
7059                 if (DeclarationStatementAST *stmt = forAst->initializer->asDeclarationStatement()) {
7060                     if (stmt->declaration) {
7061                         if (SimpleDeclarationAST *decl = stmt->declaration->asSimpleDeclaration()) {
7062                             if (decl->symbols) {
7063                                 if (Symbol *symbol = decl->symbols->value)
7064                                     initializerType = symbol->type();
7065                             }
7066                         }
7067                     }
7068                 }
7069 
7070                 // Determine type of for condition
7071                 TypeOfExpression typeOfExpression;
7072                 typeOfExpression.init(interface.semanticInfo().doc, interface.snapshot(),
7073                                       interface.context().bindings());
7074                 typeOfExpression.setExpandTemplates(true);
7075                 Scope *scope = file->scopeAt(conditionId->firstToken());
7076                 const QList<LookupItem> conditionItems = typeOfExpression(
7077                             conditionId, interface.semanticInfo().doc, scope);
7078                 if (!conditionItems.isEmpty())
7079                     conditionType = conditionItems.first().type();
7080 
7081                 if (conditionType.isValid()
7082                         && (file->textOf(forAst->initializer) == QLatin1String(";")
7083                             || initializerType == conditionType)) {
7084                     optimizeCondition = true;
7085                 }
7086             }
7087         }
7088     }
7089 
7090     if (optimizePostcrement || optimizeCondition) {
7091         result << new OptimizeForLoopOperation(interface, forAst, optimizePostcrement,
7092                                                optimizeCondition ? conditionExpression : nullptr,
7093                                                conditionType);
7094     }
7095 }
7096 
7097 namespace {
7098 
7099 class EscapeStringLiteralOperation: public CppQuickFixOperation
7100 {
7101 public:
7102     EscapeStringLiteralOperation(const CppQuickFixInterface &interface,
7103                                  ExpressionAST *literal, bool escape)
7104         : CppQuickFixOperation(interface)
7105         , m_literal(literal)
7106         , m_escape(escape)
7107     {
7108         if (m_escape) {
7109             setDescription(QApplication::translate("CppEditor::QuickFix",
7110                                                    "Escape String Literal as UTF-8"));
7111         } else {
7112             setDescription(QApplication::translate("CppEditor::QuickFix",
7113                                                    "Unescape String Literal as UTF-8"));
7114         }
7115     }
7116 
7117 private:
7118     static inline bool isDigit(quint8 ch, int base)
7119     {
7120         if (base == 8)
7121             return ch >= '0' && ch < '8';
7122         if (base == 16)
7123             return isxdigit(ch);
7124         return false;
7125     }
7126 
7127     static QByteArrayList escapeString(const QByteArray &contents)
7128     {
7129         QByteArrayList newContents;
7130         QByteArray chunk;
7131         bool wasEscaped = false;
7132         for (const quint8 c : contents) {
7133             const bool needsEscape = !isascii(c) || !isprint(c);
7134             if (!needsEscape && wasEscaped && std::isxdigit(c) && !chunk.isEmpty()) {
7135                 newContents << chunk;
7136                 chunk.clear();
7137             }
7138             if (needsEscape)
7139                 chunk += QByteArray("\\x") + QByteArray::number(c, 16).rightJustified(2, '0');
7140             else
7141                 chunk += c;
7142             wasEscaped = needsEscape;
7143         }
7144         if (!chunk.isEmpty())
7145             newContents << chunk;
7146         return newContents;
7147     }
7148 
7149     static QByteArray unescapeString(const QByteArray &contents)
7150     {
7151         QByteArray newContents;
7152         const int len = contents.length();
7153         for (int i = 0; i < len; ++i) {
7154             quint8 c = contents.at(i);
7155             if (c == '\\' && i < len - 1) {
7156                 int idx = i + 1;
7157                 quint8 ch = contents.at(idx);
7158                 int base = 0;
7159                 int maxlen = 0;
7160                 if (isDigit(ch, 8)) {
7161                     base = 8;
7162                     maxlen = 3;
7163                 } else if ((ch == 'x' || ch == 'X') && idx < len - 1) {
7164                     base = 16;
7165                     maxlen = 2;
7166                     ch = contents.at(++idx);
7167                 }
7168                 if (base > 0) {
7169                     QByteArray buf;
7170                     while (isDigit(ch, base) && idx < len && buf.length() < maxlen) {
7171                         buf += ch;
7172                         ++idx;
7173                         if (idx == len)
7174                             break;
7175                         ch = contents.at(idx);
7176                     }
7177                     if (!buf.isEmpty()) {
7178                         bool ok;
7179                         uint value = buf.toUInt(&ok, base);
7180                         // Don't unescape isascii() && !isprint()
7181                         if (ok && (!isascii(value) || isprint(value))) {
7182                             newContents += value;
7183                             i = idx - 1;
7184                             continue;
7185                         }
7186                     }
7187                 }
7188                 newContents += c;
7189                 c = contents.at(++i);
7190             }
7191             newContents += c;
7192         }
7193         return newContents;
7194     }
7195 
7196     // QuickFixOperation interface
7197 public:
7198     void perform() override
7199     {
7200         CppRefactoringChanges refactoring(snapshot());
7201         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
7202 
7203         const int startPos = currentFile->startOf(m_literal);
7204         const int endPos = currentFile->endOf(m_literal);
7205 
7206         StringLiteralAST *stringLiteral = m_literal->asStringLiteral();
7207         QTC_ASSERT(stringLiteral, return);
7208         const QByteArray oldContents(currentFile->tokenAt(stringLiteral->literal_token).
7209                                      identifier->chars());
7210         QByteArrayList newContents;
7211         if (m_escape)
7212             newContents = escapeString(oldContents);
7213         else
7214             newContents = {unescapeString(oldContents)};
7215 
7216         if (newContents.isEmpty()
7217                 || (newContents.size() == 1 && newContents.first() == oldContents)) {
7218             return;
7219         }
7220 
7221         QTextCodec *utf8codec = QTextCodec::codecForName("UTF-8");
7222         QScopedPointer<QTextDecoder> decoder(utf8codec->makeDecoder());
7223         ChangeSet changes;
7224 
7225         bool replace = true;
7226         for (const QByteArray &chunk : qAsConst(newContents)) {
7227             const QString str = decoder->toUnicode(chunk);
7228             const QByteArray utf8buf = str.toUtf8();
7229             if (!utf8codec->canEncode(str) || chunk != utf8buf)
7230                 return;
7231             if (replace)
7232                 changes.replace(startPos + 1, endPos - 1, str);
7233             else
7234                 changes.insert(endPos, "\"" + str + "\"");
7235             replace = false;
7236         }
7237         currentFile->setChangeSet(changes);
7238         currentFile->apply();
7239     }
7240 
7241 private:
7242     ExpressionAST *m_literal;
7243     bool m_escape;
7244 };
7245 
7246 } // anonymous namespace
7247 
7248 void EscapeStringLiteral::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
7249 {
7250     const QList<AST *> &path = interface.path();
7251     if (path.isEmpty())
7252         return;
7253 
7254     AST * const lastAst = path.last();
7255     ExpressionAST *literal = lastAst->asStringLiteral();
7256     if (!literal)
7257         return;
7258 
7259     StringLiteralAST *stringLiteral = literal->asStringLiteral();
7260     CppRefactoringFilePtr file = interface.currentFile();
7261     const QByteArray contents(file->tokenAt(stringLiteral->literal_token).identifier->chars());
7262 
7263     bool canEscape = false;
7264     bool canUnescape = false;
7265     for (int i = 0; i < contents.length(); ++i) {
7266         quint8 c = contents.at(i);
7267         if (!isascii(c) || !isprint(c)) {
7268             canEscape = true;
7269         } else if (c == '\\' && i < contents.length() - 1) {
7270             c = contents.at(++i);
7271             if ((c >= '0' && c < '8') || c == 'x' || c == 'X')
7272                 canUnescape = true;
7273         }
7274     }
7275 
7276     if (canEscape)
7277         result << new EscapeStringLiteralOperation(interface, literal, true);
7278 
7279     if (canUnescape)
7280         result << new EscapeStringLiteralOperation(interface, literal, false);
7281 }
7282 
7283 
7284 namespace {
7285 
7286 class ConvertQt4ConnectOperation: public CppQuickFixOperation
7287 {
7288 public:
7289     ConvertQt4ConnectOperation(const CppQuickFixInterface &interface, const ChangeSet &changes)
7290         : CppQuickFixOperation(interface, 1), m_changes(changes)
7291     {
7292         setDescription(QApplication::translate("CppEditor::QuickFix",
7293                                                "Convert connect() to Qt 5 Style"));
7294     }
7295 
7296 private:
7297     void perform() override
7298     {
7299         CppRefactoringChanges refactoring(snapshot());
7300         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
7301         currentFile->setChangeSet(m_changes);
7302         currentFile->apply();
7303     }
7304 
7305     const ChangeSet m_changes;
7306 };
7307 
7308 Symbol *skipForwardDeclarations(const QList<Symbol *> &symbols)
7309 {
7310     foreach (Symbol *symbol, symbols) {
7311         if (!symbol->type()->isForwardClassDeclarationType())
7312             return symbol;
7313     }
7314 
7315     return nullptr;
7316 }
7317 
7318 bool findRawAccessFunction(Class *klass, PointerType *pointerType, QString *objAccessFunction)
7319 {
7320     QList<Function *> candidates;
7321     for (auto it = klass->memberBegin(), end = klass->memberEnd(); it != end; ++it) {
7322         if (Function *func = (*it)->asFunction()) {
7323             const Name *funcName = func->name();
7324             if (!funcName->isOperatorNameId()
7325                     && !funcName->isConversionNameId()
7326                     && func->returnType().type() == pointerType
7327                     && func->isConst()
7328                     && func->argumentCount() == 0) {
7329                 candidates << func;
7330             }
7331         }
7332     }
7333     const Name *funcName = nullptr;
7334     switch (candidates.size()) {
7335     case 0:
7336         return false;
7337     case 1:
7338         funcName = candidates.first()->name();
7339         break;
7340     default:
7341         // Multiple candidates - prefer a function named data
7342         foreach (Function *func, candidates) {
7343             if (!strcmp(func->name()->identifier()->chars(), "data")) {
7344                 funcName = func->name();
7345                 break;
7346             }
7347         }
7348         if (!funcName)
7349             funcName = candidates.first()->name();
7350     }
7351     const Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
7352     *objAccessFunction = QLatin1Char('.') + oo.prettyName(funcName) + QLatin1String("()");
7353     return true;
7354 }
7355 
7356 PointerType *determineConvertedType(NamedType *namedType, const LookupContext &context,
7357                                     Scope *scope, QString *objAccessFunction)
7358 {
7359     if (!namedType)
7360         return nullptr;
7361     if (ClassOrNamespace *binding = context.lookupType(namedType->name(), scope)) {
7362         if (Symbol *objectClassSymbol = skipForwardDeclarations(binding->symbols())) {
7363             if (Class *klass = objectClassSymbol->asClass()) {
7364                 for (auto it = klass->memberBegin(), end = klass->memberEnd(); it != end; ++it) {
7365                     if (Function *func = (*it)->asFunction()) {
7366                         if (const ConversionNameId *conversionName =
7367                                 func->name()->asConversionNameId()) {
7368                             if (PointerType *type = conversionName->type()->asPointerType()) {
7369                                 if (findRawAccessFunction(klass, type, objAccessFunction))
7370                                     return type;
7371                             }
7372                         }
7373                     }
7374                 }
7375             }
7376         }
7377     }
7378 
7379     return nullptr;
7380 }
7381 
7382 Class *senderOrReceiverClass(const CppQuickFixInterface &interface,
7383                              const CppRefactoringFilePtr &file,
7384                              const ExpressionAST *objectPointerAST,
7385                              Scope *objectPointerScope,
7386                              QString *objAccessFunction)
7387 {
7388     const LookupContext &context = interface.context();
7389 
7390     QByteArray objectPointerExpression;
7391     if (objectPointerAST)
7392         objectPointerExpression = file->textOf(objectPointerAST).toUtf8();
7393     else
7394         objectPointerExpression = "this";
7395 
7396     TypeOfExpression toe;
7397     toe.setExpandTemplates(true);
7398     toe.init(interface.semanticInfo().doc, interface.snapshot(), context.bindings());
7399     const QList<LookupItem> objectPointerExpressions = toe(objectPointerExpression,
7400                                                            objectPointerScope, TypeOfExpression::Preprocess);
7401     QTC_ASSERT(!objectPointerExpressions.isEmpty(), return nullptr);
7402 
7403     Type *objectPointerTypeBase = objectPointerExpressions.first().type().type();
7404     QTC_ASSERT(objectPointerTypeBase, return nullptr);
7405 
7406     PointerType *objectPointerType = objectPointerTypeBase->asPointerType();
7407     if (!objectPointerType) {
7408         objectPointerType = determineConvertedType(objectPointerTypeBase->asNamedType(), context,
7409                                                objectPointerScope, objAccessFunction);
7410     }
7411     QTC_ASSERT(objectPointerType, return nullptr);
7412 
7413     Type *objectTypeBase = objectPointerType->elementType().type(); // Dereference
7414     QTC_ASSERT(objectTypeBase, return nullptr);
7415 
7416     NamedType *objectType = objectTypeBase->asNamedType();
7417     QTC_ASSERT(objectType, return nullptr);
7418 
7419     ClassOrNamespace *objectClassCON = context.lookupType(objectType->name(), objectPointerScope);
7420     if (!objectClassCON) {
7421         objectClassCON = objectPointerExpressions.first().binding();
7422         QTC_ASSERT(objectClassCON, return nullptr);
7423     }
7424     QTC_ASSERT(!objectClassCON->symbols().isEmpty(), return nullptr);
7425 
7426     Symbol *objectClassSymbol = skipForwardDeclarations(objectClassCON->symbols());
7427     QTC_ASSERT(objectClassSymbol, return nullptr);
7428 
7429     return objectClassSymbol->asClass();
7430 }
7431 
7432 bool findConnectReplacement(const CppQuickFixInterface &interface,
7433                             const ExpressionAST *objectPointerAST,
7434                             const QtMethodAST *methodAST,
7435                             const CppRefactoringFilePtr &file,
7436                             QString *replacement,
7437                             QString *objAccessFunction)
7438 {
7439     // Get name of method
7440     if (!methodAST->declarator || !methodAST->declarator->core_declarator)
7441         return false;
7442 
7443     DeclaratorIdAST *methodDeclIdAST = methodAST->declarator->core_declarator->asDeclaratorId();
7444     if (!methodDeclIdAST)
7445         return false;
7446 
7447     NameAST *methodNameAST = methodDeclIdAST->name;
7448     if (!methodNameAST)
7449         return false;
7450 
7451     // Lookup object pointer type
7452     Scope *scope = file->scopeAt(methodAST->firstToken());
7453     Class *objectClass = senderOrReceiverClass(interface, file, objectPointerAST, scope,
7454                                                objAccessFunction);
7455     QTC_ASSERT(objectClass, return false);
7456 
7457     // Look up member function in call, including base class members.
7458     const LookupContext &context = interface.context();
7459     const QList<LookupItem> methodResults = context.lookup(methodNameAST->name, objectClass);
7460     if (methodResults.isEmpty())
7461         return false; // Maybe mis-spelled signal/slot name
7462 
7463     Scope *baseClassScope = methodResults.at(0).scope(); // FIXME: Handle overloads
7464     QTC_ASSERT(baseClassScope, return false);
7465 
7466     Class *classOfMethod = baseClassScope->asClass(); // Declaration point of signal/slot
7467     QTC_ASSERT(classOfMethod, return false);
7468 
7469     Symbol *method = methodResults.at(0).declaration();
7470     QTC_ASSERT(method, return false);
7471 
7472     // Minimize qualification
7473     Control *control = context.bindings()->control().data();
7474     ClassOrNamespace *functionCON = context.lookupParent(scope);
7475     const Name *shortName = LookupContext::minimalName(method, functionCON, control);
7476     if (!shortName->asQualifiedNameId())
7477         shortName = control->qualifiedNameId(classOfMethod->name(), shortName);
7478 
7479     const Overview oo = CppCodeStyleSettings::currentProjectCodeStyleOverview();
7480     *replacement = QLatin1Char('&') + oo.prettyName(shortName);
7481     return true;
7482 }
7483 
7484 bool onConnectOrDisconnectCall(AST *ast, const ExpressionListAST **arguments)
7485 {
7486     if (!ast)
7487         return false;
7488 
7489     CallAST *call = ast->asCall();
7490     if (!call)
7491         return false;
7492 
7493     if (!call->base_expression)
7494         return false;
7495 
7496     const IdExpressionAST *idExpr = call->base_expression->asIdExpression();
7497     if (!idExpr || !idExpr->name || !idExpr->name->name)
7498         return false;
7499 
7500     const ExpressionListAST *args = call->expression_list;
7501     if (!arguments)
7502         return false;
7503 
7504     const Identifier *id = idExpr->name->name->identifier();
7505     if (!id)
7506         return false;
7507 
7508     const QByteArray name(id->chars(), id->size());
7509     if (name != "connect" && name != "disconnect")
7510         return false;
7511 
7512     if (arguments)
7513         *arguments = args;
7514     return true;
7515 }
7516 
7517 // Might modify arg* output arguments even if false is returned.
7518 bool collectConnectArguments(const ExpressionListAST *arguments,
7519                              const ExpressionAST **arg1, const QtMethodAST **arg2,
7520                              const ExpressionAST **arg3, const QtMethodAST **arg4)
7521 {
7522     if (!arguments || !arg1 || !arg2 || !arg3 || !arg4)
7523         return false;
7524 
7525     *arg1 = arguments->value;
7526     arguments = arguments->next;
7527     if (!arg1 || !arguments)
7528         return false;
7529 
7530     *arg2 = arguments->value->asQtMethod();
7531     arguments = arguments->next;
7532     if (!*arg2 || !arguments)
7533         return false;
7534 
7535     *arg3 = arguments->value;
7536     if (!*arg3)
7537         return false;
7538 
7539     // Take care of three-arg version, with 'this' receiver.
7540     if (QtMethodAST *receiverMethod = arguments->value->asQtMethod()) {
7541         *arg3 = nullptr; // Means 'this'
7542         *arg4 = receiverMethod;
7543         return true;
7544     }
7545 
7546     arguments = arguments->next;
7547     if (!arguments)
7548         return false;
7549 
7550     *arg4 = arguments->value->asQtMethod();
7551     if (!*arg4)
7552         return false;
7553 
7554     return true;
7555 }
7556 
7557 } // anonynomous namespace
7558 
7559 void ConvertQt4Connect::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
7560 {
7561     const QList<AST *> &path = interface.path();
7562 
7563     for (int i = path.size(); --i >= 0; ) {
7564         const ExpressionListAST *arguments;
7565         if (!onConnectOrDisconnectCall(path.at(i), &arguments))
7566             continue;
7567 
7568         const ExpressionAST *arg1, *arg3;
7569         const QtMethodAST *arg2, *arg4;
7570         if (!collectConnectArguments(arguments, &arg1, &arg2, &arg3, &arg4))
7571             continue;
7572 
7573         const CppRefactoringFilePtr file = interface.currentFile();
7574 
7575         QString newSignal;
7576         QString senderAccessFunc;
7577         if (!findConnectReplacement(interface, arg1, arg2, file, &newSignal, &senderAccessFunc))
7578             continue;
7579 
7580         QString newMethod;
7581         QString receiverAccessFunc;
7582         if (!findConnectReplacement(interface, arg3, arg4, file, &newMethod, &receiverAccessFunc))
7583             continue;
7584 
7585         ChangeSet changes;
7586         changes.replace(file->endOf(arg1), file->endOf(arg1), senderAccessFunc);
7587         changes.replace(file->startOf(arg2), file->endOf(arg2), newSignal);
7588         if (!arg3)
7589             newMethod.prepend(QLatin1String("this, "));
7590         else
7591             changes.replace(file->endOf(arg3), file->endOf(arg3), receiverAccessFunc);
7592         changes.replace(file->startOf(arg4), file->endOf(arg4), newMethod);
7593 
7594         result << new ConvertQt4ConnectOperation(interface, changes);
7595         return;
7596     }
7597 }
7598 
7599 void ExtraRefactoringOperations::match(const CppQuickFixInterface &interface,
7600                                        QuickFixOperations &result)
7601 {
7602     const auto processor = CppModelManager::cppEditorDocumentProcessor(
7603                 interface.filePath().toString());
7604     if (processor) {
7605         const auto clangFixItOperations = processor->extraRefactoringOperations(interface);
7606         result.append(clangFixItOperations);
7607     }
7608 }
7609 
7610 namespace {
7611 
7612 /**
7613  * @brief The NameCounter class counts the parts of a name. E.g. 2 for std::vector or 1 for variant
7614  */
7615 class NameCounter : private NameVisitor
7616 {
7617 public:
7618     int count(const Name *name)
7619     {
7620         counter = 0;
7621         accept(name);
7622         return counter;
7623     }
7624 
7625 private:
7626     void visit(const Identifier *) override { ++counter; }
7627     void visit(const DestructorNameId *) override { ++counter; }
7628     void visit(const TemplateNameId *) override { ++counter; }
7629     void visit(const QualifiedNameId *name) override
7630     {
7631         if (name->base())
7632             accept(name->base());
7633         accept(name->name());
7634     }
7635     int counter;
7636 };
7637 
7638 /**
7639  * @brief getBaseName returns the base name of a qualified name or nullptr.
7640  * E.g.: foo::bar => foo; bar => bar
7641  * @param name The Name, maybe qualified
7642  * @return The base name of the qualified name or nullptr
7643  */
7644 const Identifier *getBaseName(const Name *name)
7645 {
7646     class GetBaseName : public NameVisitor
7647     {
7648         void visit(const Identifier *name) override { baseName = name; }
7649         void visit(const QualifiedNameId *name) override
7650         {
7651             if (name->base())
7652                 accept(name->base());
7653             else
7654                 accept(name->name());
7655         }
7656 
7657     public:
7658         const Identifier *baseName = nullptr;
7659     };
7660     GetBaseName getter;
7661     getter.accept(name);
7662     return getter.baseName;
7663 }
7664 
7665 /**
7666  * @brief countNames counts the parts of the Name.
7667  * E.g. if the name is std::vector, the function returns 2, if the name is variant, returns 1
7668  * @param name The name that should be counted
7669  * @return the number of parts of the name
7670  */
7671 int countNames(const Name *name)
7672 {
7673     return NameCounter{}.count(name);
7674 }
7675 
7676 /**
7677  * @brief removeLine removes the whole line in which the ast node is located if there are otherwise only whitespaces
7678  * @param file The file in which the AST node is located
7679  * @param ast The ast node
7680  * @param changeSet The ChangeSet of the file
7681  */
7682 void removeLine(const CppRefactoringFile *file, AST *ast, ChangeSet &changeSet)
7683 {
7684     RefactoringFile::Range range = file->range(ast);
7685     --range.start;
7686     while (range.start >= 0) {
7687         QChar current = file->charAt(range.start);
7688         if (!current.isSpace()) {
7689             ++range.start;
7690             break;
7691         }
7692         if (current == QChar::ParagraphSeparator)
7693             break;
7694         --range.start;
7695     }
7696     range.start = std::max(0, range.start);
7697     while (range.end < file->document()->characterCount()) {
7698         QChar current = file->charAt(range.end);
7699         if (!current.isSpace())
7700             break;
7701         if (current == QChar::ParagraphSeparator)
7702             break;
7703         ++range.end;
7704     }
7705     range.end = std::min(file->document()->characterCount(), range.end);
7706     const bool newLineStart = file->charAt(range.start) == QChar::ParagraphSeparator;
7707     const bool newLineEnd = file->charAt(range.end) == QChar::ParagraphSeparator;
7708     if (!newLineEnd && newLineStart)
7709         ++range.start;
7710     changeSet.remove(range);
7711 }
7712 
7713 /**
7714  * @brief The RemoveNamespaceVisitor class removes a using namespace and rewrites all types that
7715  * are in the namespace if needed
7716  */
7717 class RemoveNamespaceVisitor : public ASTVisitor
7718 {
7719 public:
7720     constexpr static int SearchGlobalUsingDirectivePos = std::numeric_limits<int>::max();
7721     RemoveNamespaceVisitor(const CppRefactoringFile *file,
7722                            const Snapshot &snapshot,
7723                            const Name *namespace_,
7724                            int symbolPos,
7725                            bool removeAllAtGlobalScope)
7726         : ASTVisitor(file->cppDocument()->translationUnit())
7727         , m_file(file)
7728         , m_snapshot(snapshot)
7729         , m_namespace(namespace_)
7730         , m_missingNamespace(toString(namespace_) + "::")
7731         , m_context(m_file->cppDocument(), m_snapshot)
7732         , m_symbolPos(symbolPos)
7733         , m_removeAllAtGlobalScope(removeAllAtGlobalScope)
7734 
7735     {}
7736 
7737     const ChangeSet &getChanges() { return m_changeSet; }
7738 
7739     /**
7740      * @brief isGlobalUsingNamespace return true if the using namespace that should be removed
7741      * is not scoped and other files that include this file will also use the using namespace
7742      * @return true if using namespace statement is global and not scoped, false otherwise
7743      */
7744     bool isGlobalUsingNamespace() const { return m_parentNode == nullptr; }
7745 
7746     /**
7747      * @brief foundGlobalUsingNamespace return true if removeAllAtGlobalScope is false and
7748      * another using namespace is found at the global scope, so that other files that include this
7749      * file don't have to be processed
7750      * @return true if there was a 'global' second using namespace in this file and
7751      * removeAllAtGlobalScope is false
7752      */
7753     bool foundGlobalUsingNamespace() const { return m_foundNamespace; }
7754 
7755 private:
7756     bool preVisit(AST *ast) override
7757     {
7758         if (!m_start) {
7759             if (ast->asTranslationUnit())
7760                 return true;
7761             if (UsingDirectiveAST *usingDirective = ast->asUsingDirective()) {
7762                 if (nameEqual(usingDirective->name->name, m_namespace)) {
7763                     if (m_symbolPos == SearchGlobalUsingDirectivePos) {
7764                         // we have found a global using directive, so lets start
7765                         m_start = true;
7766                         removeLine(m_file, ast, m_changeSet);
7767                         return false;
7768                     }
7769                     // ignore the using namespace that should be removed
7770                     if (m_file->endOf(ast) != m_symbolPos) {
7771                         if (m_removeAllAtGlobalScope)
7772                             removeLine(m_file, ast, m_changeSet);
7773                         else
7774                             m_done = true;
7775                     }
7776                 }
7777             }
7778             // if the end of the ast is before we should start, we are not interested in the node
7779             if (m_file->endOf(ast) <= m_symbolPos)
7780                 return false;
7781 
7782             if (m_file->startOf(ast) > m_symbolPos)
7783                 m_start = true;
7784         }
7785         return !m_foundNamespace && !m_done;
7786     }
7787 
7788     bool visit(NamespaceAST *ast) override
7789     {
7790         if (m_start && nameEqual(m_namespace, ast->symbol->name()))
7791             return false;
7792 
7793         return m_start;
7794     }
7795 
7796     // scopes for using namespace statements:
7797     bool visit(LinkageBodyAST *ast) override { return visitNamespaceScope(ast); }
7798     bool visit(CompoundStatementAST *ast) override { return visitNamespaceScope(ast); }
7799     bool visitNamespaceScope(AST *ast)
7800     {
7801         ++m_namespaceScopeCounter;
7802         if (!m_start)
7803             m_parentNode = ast;
7804         return true;
7805     }
7806 
7807     void endVisit(LinkageBodyAST *ast) override { endVisitNamespaceScope(ast); }
7808     void endVisit(CompoundStatementAST *ast) override { endVisitNamespaceScope(ast); }
7809     void endVisitNamespaceScope(AST *ast)
7810     {
7811         --m_namespaceScopeCounter;
7812         m_foundNamespace = false;
7813         // if we exit the scope of the using namespace we are done
7814         if (ast == m_parentNode)
7815             m_done = true;
7816     }
7817 
7818     bool visit(UsingDirectiveAST *ast) override
7819     {
7820         if (nameEqual(ast->name->name, m_namespace)) {
7821             if (m_removeAllAtGlobalScope && m_namespaceScopeCounter == 0)
7822                 removeLine(m_file, ast, m_changeSet);
7823             else
7824                 m_foundNamespace = true;
7825             return false;
7826         }
7827         return handleAstWithLongestName(ast);
7828     }
7829 
7830     bool visit(DeclaratorIdAST *ast) override
7831     {
7832         // e.g. we have the following code and get the following Lookup items:
7833         // namespace test {
7834         //   struct foo { // 1. item with test::foo
7835         //     foo();     // 2. item with test::foo::foo
7836         //   };
7837         // }
7838         // using namespace foo;
7839         // foo::foo() { ... } // 3. item with foo::foo
7840         // Our current name is foo::foo so we have to match with the 2. item / longest name
7841         return handleAstWithLongestName(ast);
7842     }
7843 
7844     template<typename AST>
7845     bool handleAstWithLongestName(AST *ast)
7846     {
7847         if (m_start) {
7848             Scope *scope = m_file->scopeAt(ast->firstToken());
7849             const QList<LookupItem> localLookup = m_context.lookup(ast->name->name, scope);
7850             QList<const Name *> longestName;
7851             for (const LookupItem &item : localLookup) {
7852                 QList<const Name *> names
7853                     = m_context.fullyQualifiedName(item.declaration(),
7854                                                    LookupContext::HideInlineNamespaces);
7855                 if (names.length() > longestName.length())
7856                     longestName = names;
7857             }
7858             const int currentNameCount = countNames(ast->name->name);
7859             const bool needNew = needMissingNamespaces(std::move(longestName), currentNameCount);
7860             if (needNew)
7861                 insertMissingNamespace(ast);
7862         }
7863         return false;
7864     }
7865 
7866     bool visit(NamedTypeSpecifierAST *ast) override { return handleAstWithName(ast); }
7867 
7868     bool visit(IdExpressionAST *ast) override { return handleAstWithName(ast); }
7869 
7870     template<typename AST>
7871     bool handleAstWithName(AST *ast)
7872     {
7873         if (m_start) {
7874             Scope *scope = m_file->scopeAt(ast->firstToken());
7875             const Name *wantToLookup = ast->name->name;
7876             // first check if the base name is a typedef. Consider the following example:
7877             // using namespace std;
7878             // using vec = std::vector<int>;
7879             // vec::iterator it; // we have to lookup 'vec' and not iterator (would result in
7880             //   std::vector<int>::iterator => std::vec::iterator, which is wrong)
7881             const Name *baseName = getBaseName(wantToLookup);
7882             QList<LookupItem> typedefCandidates = m_context.lookup(baseName, scope);
7883             if (!typedefCandidates.isEmpty()) {
7884                 if (typedefCandidates.front().declaration()->isTypedef())
7885                     wantToLookup = baseName;
7886             }
7887 
7888             const QList<LookupItem> lookups = m_context.lookup(wantToLookup, scope);
7889             if (!lookups.empty()) {
7890                 QList<const Name *> fullName
7891                     = m_context.fullyQualifiedName(lookups.first().declaration(),
7892                                                    LookupContext::HideInlineNamespaces);
7893                 const int currentNameCount = countNames(wantToLookup);
7894                 const bool needNamespace = needMissingNamespaces(std::move(fullName),
7895                                                                  currentNameCount);
7896                 if (needNamespace)
7897                     insertMissingNamespace(ast);
7898             }
7899         }
7900         return true;
7901     }
7902 
7903     template<typename AST>
7904     void insertMissingNamespace(AST *ast)
7905     {
7906         DestructorNameAST *destructorName = ast->name->asDestructorName();
7907         if (destructorName)
7908             m_changeSet.insert(m_file->startOf(destructorName->unqualified_name), m_missingNamespace);
7909         else
7910             m_changeSet.insert(m_file->startOf(ast->name), m_missingNamespace);
7911     }
7912 
7913     bool needMissingNamespaces(QList<const Name *> &&fullName, int currentNameCount)
7914     {
7915         if (currentNameCount > fullName.length())
7916             return false;
7917 
7918         // eg. fullName = std::vector, currentName = vector => result should be std
7919         fullName.erase(fullName.end() - currentNameCount, fullName.end());
7920         if (fullName.empty())
7921             return false;
7922         return nameEqual(m_namespace, fullName.last());
7923     }
7924 
7925     static bool nameEqual(const Name *name1, const Name *name2)
7926     {
7927         return Matcher::match(name1, name2);
7928     }
7929 
7930     QString toString(const Name *id)
7931     {
7932         const Identifier *identifier = id->asNameId();
7933         QTC_ASSERT(identifier, return {});
7934         return QString::fromUtf8(identifier->chars(), identifier->size());
7935     }
7936 
7937     const CppRefactoringFile *const m_file;
7938     const Snapshot &m_snapshot;
7939 
7940     const Name *m_namespace;          // the name of the namespace that should be removed
7941     const QString m_missingNamespace; // that should be added if a type was using the namespace
7942     LookupContext m_context;
7943     ChangeSet m_changeSet;
7944     const int m_symbolPos; // the end position of the start symbol
7945     bool m_done = false;
7946     bool m_start = false;
7947     // true if a using namespace was found at a scope and the scope should be left
7948     bool m_foundNamespace = false;
7949     bool m_removeAllAtGlobalScope;
7950     // the scope where the using namespace that should be removed is valid
7951     AST *m_parentNode = nullptr;
7952     int m_namespaceScopeCounter = 0;
7953 };
7954 
7955 class RemoveUsingNamespaceOperation : public CppQuickFixOperation
7956 {
7957     struct Node
7958     {
7959         Document::Ptr document;
7960         bool hasGlobalUsingDirective = false;
7961         int unprocessedParents;
7962         std::vector<std::reference_wrapper<Node>> includes;
7963         std::vector<std::reference_wrapper<Node>> includedBy;
7964         Node() = default;
7965         Node(const Node &) = delete;
7966         Node(Node &&) = delete;
7967     };
7968 
7969 public:
7970     RemoveUsingNamespaceOperation(const CppQuickFixInterface &interface,
7971                                   UsingDirectiveAST *usingDirective,
7972                                   bool removeAllAtGlobalScope)
7973         : CppQuickFixOperation(interface, 1)
7974         , m_usingDirective(usingDirective)
7975         , m_removeAllAtGlobalScope(removeAllAtGlobalScope)
7976     {
7977         const QString name = Overview{}.prettyName(usingDirective->name->name);
7978         if (m_removeAllAtGlobalScope) {
7979             setDescription(QApplication::translate(
7980                                "CppEditor::QuickFix",
7981                                "Remove All Occurrences of \"using namespace %1\" in Global Scope "
7982                                "and Adjust Type Names Accordingly")
7983                                .arg(name));
7984         } else {
7985             setDescription(QApplication::translate("CppEditor::QuickFix",
7986                                                    "Remove \"using namespace %1\" and "
7987                                                    "Adjust Type Names Accordingly")
7988                                .arg(name));
7989         }
7990     }
7991 
7992 private:
7993     std::map<Utils::FilePath, Node> buildIncludeGraph(CppRefactoringChanges &refactoring)
7994     {
7995         using namespace ProjectExplorer;
7996         using namespace Utils;
7997 
7998         const Snapshot &s = refactoring.snapshot();
7999         std::map<Utils::FilePath, Node> includeGraph;
8000 
8001         auto handleFile = [&](const FilePath &filePath, Document::Ptr doc, auto shouldHandle) {
8002             Node &node = includeGraph[filePath];
8003             node.document = doc;
8004             for (const Document::Include &include : doc->resolvedIncludes()) {
8005                 const auto filePath = FilePath::fromString(include.resolvedFileName());
8006                 if (shouldHandle(filePath)) {
8007                     Node &includedNode = includeGraph[filePath];
8008                     includedNode.includedBy.push_back(node);
8009                     node.includes.push_back(includedNode);
8010                 }
8011             }
8012         };
8013 
8014         if (const Project *project = SessionManager::projectForFile(filePath())) {
8015             const FilePaths files = project->files(ProjectExplorer::Project::SourceFiles);
8016             QSet<FilePath> projectFiles(files.begin(), files.end());
8017             for (const auto &file : files) {
8018                 const Document::Ptr doc = s.document(file);
8019                 if (!doc)
8020                     continue;
8021                 handleFile(file, doc, [&](const FilePath &file) {
8022                     return projectFiles.contains(file);
8023                 });
8024             }
8025         } else {
8026             for (auto i = s.begin(); i != s.end(); ++i) {
8027                 if (ProjectFile::classify(i.key().toString()) != ProjectFile::Unsupported) {
8028                     handleFile(i.key(), i.value(), [](const FilePath &file) {
8029                         return ProjectFile::classify(file.toString()) != ProjectFile::Unsupported;
8030                     });
8031                 }
8032             }
8033         }
8034         for (auto &[_, node] : includeGraph) {
8035             Q_UNUSED(_)
8036             node.unprocessedParents = static_cast<int>(node.includes.size());
8037         }
8038         return includeGraph;
8039     }
8040 
8041     void removeAllUsingsAtGlobalScope(CppRefactoringChanges &refactoring)
8042     {
8043         auto includeGraph = buildIncludeGraph(refactoring);
8044         std::vector<std::reference_wrapper<Node>> nodesWithProcessedParents;
8045         for (auto &[_, node] : includeGraph) {
8046             Q_UNUSED(_)
8047             if (!node.unprocessedParents)
8048                 nodesWithProcessedParents.push_back(node);
8049         }
8050         while (!nodesWithProcessedParents.empty()) {
8051             Node &node = nodesWithProcessedParents.back();
8052             nodesWithProcessedParents.pop_back();
8053             CppRefactoringFilePtr file = refactoring.file(
8054                 Utils::FilePath::fromString(node.document->fileName()));
8055             const bool parentHasUsing = Utils::anyOf(node.includes, &Node::hasGlobalUsingDirective);
8056             const int startPos = parentHasUsing
8057                                      ? 0
8058                                      : RemoveNamespaceVisitor::SearchGlobalUsingDirectivePos;
8059             const bool noGlobalUsing = refactorFile(file, refactoring.snapshot(), startPos);
8060             node.hasGlobalUsingDirective = !noGlobalUsing || parentHasUsing;
8061 
8062             for (Node &subNode : node.includedBy) {
8063                 --subNode.unprocessedParents;
8064                 if (subNode.unprocessedParents == 0)
8065                     nodesWithProcessedParents.push_back(subNode);
8066             }
8067         }
8068     }
8069 
8070     void perform() override
8071     {
8072         CppRefactoringChanges refactoring(snapshot());
8073         CppRefactoringFilePtr currentFile = refactoring.file(filePath());
8074         if (m_removeAllAtGlobalScope) {
8075             removeAllUsingsAtGlobalScope(refactoring);
8076         } else if (refactorFile(currentFile,
8077                                 refactoring.snapshot(),
8078                                 currentFile->endOf(m_usingDirective),
8079                                 true)) {
8080             processIncludes(refactoring, filePath().toString());
8081         }
8082 
8083         for (auto &file : qAsConst(m_changes))
8084             file->apply();
8085     }
8086 
8087     /**
8088      * @brief refactorFile remove using namespace xyz in the given file and rewrite types
8089      * @param file The file that should be processed
8090      * @param snapshot The snapshot to work on
8091      * @param startSymbol start processing after this index
8092      * @param removeUsing if the using directive is in this file, remove it
8093      * @return true if the using statement is global and there is no other global using namespace
8094      */
8095     bool refactorFile(CppRefactoringFilePtr &file,
8096                       const Snapshot &snapshot,
8097                       int startSymbol,
8098                       bool removeUsing = false)
8099     {
8100         RemoveNamespaceVisitor visitor(file.get(),
8101                                        snapshot,
8102                                        m_usingDirective->name->name,
8103                                        startSymbol,
8104                                        m_removeAllAtGlobalScope);
8105         visitor.accept(file->cppDocument()->translationUnit()->ast());
8106         Utils::ChangeSet changes = visitor.getChanges();
8107         if (removeUsing)
8108             removeLine(file.get(), m_usingDirective, changes);
8109         if (!changes.isEmpty()) {
8110             file->setChangeSet(changes);
8111             // apply changes at the end, otherwise the symbol finder will fail to resolve symbols if
8112             // the using namespace is missing
8113             m_changes.insert(file);
8114         }
8115         return visitor.isGlobalUsingNamespace() && !visitor.foundGlobalUsingNamespace();
8116     }
8117 
8118     void processIncludes(CppRefactoringChanges &refactoring, const QString &fileName)
8119     {
8120         QList<Snapshot::IncludeLocation>
8121             includeLocationsOfDocument = refactoring.snapshot().includeLocationsOfDocument(fileName);
8122         for (Snapshot::IncludeLocation &loc : includeLocationsOfDocument) {
8123             if (m_processed.contains(loc.first))
8124                 continue;
8125 
8126             CppRefactoringFilePtr file = refactoring.file(
8127                 Utils::FilePath::fromString(loc.first->fileName()));
8128             const bool noGlobalUsing = refactorFile(file,
8129                                                     refactoring.snapshot(),
8130                                                     file->position(loc.second, 1));
8131             m_processed.insert(loc.first);
8132             if (noGlobalUsing)
8133                 processIncludes(refactoring, loc.first->fileName());
8134         }
8135     }
8136 
8137     QSet<Document::Ptr> m_processed;
8138     QSet<CppRefactoringFilePtr> m_changes;
8139 
8140     UsingDirectiveAST *m_usingDirective;
8141     bool m_removeAllAtGlobalScope;
8142 };
8143 } // namespace
8144 
8145 void RemoveUsingNamespace::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
8146 {
8147     const QList<AST *> &path = interface.path();
8148     // We expect something like
8149     // [0] TranslationUnitAST
8150     // ...
8151     // [] UsingDirectiveAST : if activated at 'using namespace'
8152     // [] NameAST (optional): if activated at the name e.g. 'std'
8153     int n = path.size() - 1;
8154     if (n <= 0)
8155         return;
8156     if (path.last()->asName())
8157         --n;
8158     UsingDirectiveAST *usingDirective = path.at(n)->asUsingDirective();
8159     if (usingDirective && usingDirective->name->name->isNameId()) {
8160         result << new RemoveUsingNamespaceOperation(interface, usingDirective, false);
8161         const bool isHeader = ProjectFile::isHeader(ProjectFile::classify(interface.filePath().toString()));
8162         if (isHeader && path.at(n - 1)->asTranslationUnit()) // using namespace at global scope
8163             result << new RemoveUsingNamespaceOperation(interface, usingDirective, true);
8164     }
8165 }
8166 
8167 namespace {
8168 
8169 struct ParentClassConstructorInfo;
8170 
8171 class ConstructorMemberInfo
8172 {
8173 public:
8174     ConstructorMemberInfo(const QString &name, Symbol *symbol, int numberOfMember)
8175         : memberVariableName(name)
8176         , parameterName(memberBaseName(name))
8177         , symbol(symbol)
8178         , type(symbol->type())
8179         , numberOfMember(numberOfMember)
8180     {}
8181     ConstructorMemberInfo(const QString &memberName,
8182                           const QString &paramName,
8183                           const QString &defaultValue,
8184                           Symbol *symbol,
8185                           const ParentClassConstructorInfo *parentClassConstructor)
8186         : parentClassConstructor(parentClassConstructor)
8187         , memberVariableName(memberName)
8188         , parameterName(paramName)
8189         , defaultValue(defaultValue)
8190         , init(defaultValue.isEmpty())
8191         , symbol(symbol)
8192         , type(symbol->type())
8193     {}
8194     const ParentClassConstructorInfo *parentClassConstructor = nullptr;
8195     QString memberVariableName;
8196     QString parameterName;
8197     QString defaultValue;
8198     bool init = true;
8199     bool customValueType; // for the generation later
8200     Symbol *symbol; // for the right type later
8201     FullySpecifiedType type;
8202     int numberOfMember; // first member, second member, ...
8203 };
8204 
8205 class ConstructorParams : public QAbstractTableModel
8206 {
8207     Q_OBJECT
8208     std::list<ConstructorMemberInfo> candidates;
8209     std::vector<ConstructorMemberInfo *> infos;
8210 
8211     void validateOrder()
8212     {
8213         // parameters with default values must be at the end
8214         bool foundWithDefault = false;
8215         for (auto info : infos) {
8216             if (info->init) {
8217                 if (foundWithDefault && info->defaultValue.isEmpty()) {
8218                     emit validOrder(false);
8219                     return;
8220                 }
8221                 foundWithDefault |= !info->defaultValue.isEmpty();
8222             }
8223         }
8224         emit validOrder(true);
8225     }
8226 
8227 public:
8228     enum Column { ShouldInitColumn, MemberNameColumn, ParameterNameColumn, DefaultValueColumn };
8229     template<typename... _Args>
8230     void emplaceBackParameter(_Args &&...__args)
8231     {
8232         candidates.emplace_back(std::forward<_Args>(__args)...);
8233         infos.push_back(&candidates.back());
8234     }
8235     const std::vector<ConstructorMemberInfo *> &getInfos() const { return infos; }
8236     void addRow(ConstructorMemberInfo *info)
8237     {
8238         beginInsertRows({}, rowCount(), rowCount());
8239         infos.push_back(info);
8240         endInsertRows();
8241         validateOrder();
8242     }
8243     void removeRow(ConstructorMemberInfo *info)
8244     {
8245         for (auto iter = infos.begin(); iter != infos.end(); ++iter) {
8246             if (*iter == info) {
8247                 const auto index = iter - infos.begin();
8248                 beginRemoveRows({}, index, index);
8249                 infos.erase(iter);
8250                 endRemoveRows();
8251                 validateOrder();
8252                 return;
8253             }
8254         }
8255     }
8256 
8257     int selectedCount() const
8258     {
8259         return Utils::count(infos, [](const ConstructorMemberInfo *mi) {
8260             return mi->init && !mi->parentClassConstructor;
8261         });
8262     }
8263     int memberCount() const
8264     {
8265         return Utils::count(infos, [](const ConstructorMemberInfo *mi) {
8266             return !mi->parentClassConstructor;
8267         });
8268     }
8269 
8270     int rowCount(const QModelIndex & /*parent*/ = {}) const override { return int(infos.size()); }
8271     int columnCount(const QModelIndex & /*parent*/ = {}) const override { return 4; }
8272     QVariant data(const QModelIndex &index, int role) const override
8273     {
8274         if (index.row() < 0 || index.row() >= rowCount())
8275             return {};
8276         if (role == Qt::CheckStateRole && index.column() == ShouldInitColumn
8277             && !infos[index.row()]->parentClassConstructor)
8278             return infos[index.row()]->init ? Qt::Checked : Qt::Unchecked;
8279         if (role == Qt::DisplayRole && index.column() == MemberNameColumn)
8280             return infos[index.row()]->memberVariableName;
8281         if ((role == Qt::DisplayRole || role == Qt::EditRole)
8282             && index.column() == ParameterNameColumn)
8283             return infos[index.row()]->parameterName;
8284         if ((role == Qt::DisplayRole || role == Qt::EditRole)
8285             && index.column() == DefaultValueColumn)
8286             return infos[index.row()]->defaultValue;
8287         if ((role == Qt::ToolTipRole) && index.column() > 0)
8288             return Overview{}.prettyType(infos[index.row()]->symbol->type());
8289         return {};
8290     }
8291     bool setData(const QModelIndex &index, const QVariant &value, int role) override
8292     {
8293         if (index.column() == ShouldInitColumn && role == Qt::CheckStateRole) {
8294             if (infos[index.row()]->parentClassConstructor)
8295                 return false;
8296             infos[index.row()]->init = value.toInt() == Qt::Checked;
8297             emit dataChanged(this->index(index.row(), 0), this->index(index.row(), columnCount()));
8298             validateOrder();
8299             return true;
8300         }
8301         if (index.column() == ParameterNameColumn && role == Qt::EditRole) {
8302             infos[index.row()]->parameterName = value.toString();
8303             return true;
8304         }
8305         if (index.column() == DefaultValueColumn && role == Qt::EditRole) {
8306             infos[index.row()]->defaultValue = value.toString();
8307             validateOrder();
8308             return true;
8309         }
8310         return false;
8311     }
8312     Qt::DropActions supportedDropActions() const override { return Qt::MoveAction; }
8313     Qt::ItemFlags flags(const QModelIndex &index) const override
8314     {
8315         if (!index.isValid())
8316             return Qt::ItemIsSelectable | Qt::ItemIsDropEnabled;
8317 
8318         Qt::ItemFlags f{};
8319         if (infos[index.row()]->init) {
8320             f |= Qt::ItemIsDragEnabled;
8321             f |= Qt::ItemIsSelectable;
8322         }
8323 
8324         if (index.column() == ShouldInitColumn && !infos[index.row()]->parentClassConstructor)
8325             return f | Qt::ItemIsEnabled | Qt::ItemIsUserCheckable;
8326         if (!infos[index.row()]->init)
8327             return f;
8328         if (index.column() == MemberNameColumn)
8329             return f | Qt::ItemIsEnabled;
8330         if (index.column() == ParameterNameColumn || index.column() == DefaultValueColumn)
8331             return f | Qt::ItemIsEnabled | Qt::ItemIsEditable;
8332         return {};
8333     }
8334 
8335     QVariant headerData(int section, Qt::Orientation orientation, int role) const override
8336     {
8337         if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
8338             switch (section) {
8339             case ShouldInitColumn:
8340                 return tr("Initialize in Constructor");
8341             case MemberNameColumn:
8342                 return tr("Member Name");
8343             case ParameterNameColumn:
8344                 return tr("Parameter Name");
8345             case DefaultValueColumn:
8346                 return tr("Default Value");
8347             }
8348         }
8349         return {};
8350     }
8351     bool dropMimeData(const QMimeData *data,
8352                       Qt::DropAction /*action*/,
8353                       int row,
8354                       int /*column*/,
8355                       const QModelIndex & /*parent*/) override
8356     {
8357         if (row == -1)
8358             row = rowCount();
8359         bool ok;
8360         int sourceRow = data->data("application/x-qabstractitemmodeldatalist").toInt(&ok);
8361         if (ok) {
8362             if (sourceRow == row || row == sourceRow + 1)
8363                 return false;
8364             beginMoveRows({}, sourceRow, sourceRow, {}, row);
8365             infos.insert(infos.begin() + row, infos.at(sourceRow));
8366             if (row < sourceRow)
8367                 ++sourceRow;
8368             infos.erase(infos.begin() + sourceRow);
8369             validateOrder();
8370             return true;
8371         }
8372         return false;
8373     }
8374 
8375     QMimeData *mimeData(const QModelIndexList &indexes) const override
8376     {
8377         for (const auto &i : indexes) {
8378             if (!i.isValid())
8379                 continue;
8380             auto data = new QMimeData();
8381             data->setData("application/x-qabstractitemmodeldatalist",
8382                           QString::number(i.row()).toLatin1());
8383             return data;
8384         }
8385         return nullptr;
8386     }
8387 
8388     class TableViewStyle : public QProxyStyle
8389     {
8390     public:
8391         TableViewStyle(QStyle *style)
8392             : QProxyStyle(style)
8393         {}
8394 
8395         void drawPrimitive(PrimitiveElement element,
8396                            const QStyleOption *option,
8397                            QPainter *painter,
8398                            const QWidget *widget) const override
8399         {
8400             if (element == QStyle::PE_IndicatorItemViewItemDrop && !option->rect.isNull()) {
8401                 QStyleOption opt(*option);
8402                 opt.rect.setLeft(0);
8403                 if (widget)
8404                     opt.rect.setRight(widget->width());
8405                 QProxyStyle::drawPrimitive(element, &opt, painter, widget);
8406                 return;
8407             }
8408             QProxyStyle::drawPrimitive(element, option, painter, widget);
8409         }
8410     };
8411 signals:
8412     void validOrder(bool valid);
8413 };
8414 
8415 class TopMarginDelegate : public QStyledItemDelegate
8416 {
8417 public:
8418     TopMarginDelegate(QObject *parent = nullptr)
8419         : QStyledItemDelegate(parent)
8420     {}
8421 
8422     void paint(QPainter *painter,
8423                const QStyleOptionViewItem &option,
8424                const QModelIndex &index) const override
8425     {
8426         Q_ASSERT(index.isValid());
8427         QStyleOptionViewItem opt = option;
8428         initStyleOption(&opt, index);
8429         const QWidget *widget = option.widget;
8430         QStyle *style = widget ? widget->style() : QApplication::style();
8431         if (opt.rect.height() > 20)
8432             opt.rect.adjust(0, 5, 0, 0);
8433         style->drawControl(QStyle::CE_ItemViewItem, &opt, painter, widget);
8434     }
8435 };
8436 
8437 struct ParentClassConstructorParameter : public ConstructorMemberInfo
8438 {
8439     QString originalDefaultValue;
8440     QString declaration; // displayed in the treeView
8441     ParentClassConstructorParameter(const QString &name,
8442                                     const QString &defaultValue,
8443                                     Symbol *symbol,
8444                                     const ParentClassConstructorInfo *parentClassConstructor);
8445 
8446     ParentClassConstructorParameter(const ParentClassConstructorParameter &) = delete;
8447     ParentClassConstructorParameter(ParentClassConstructorParameter &&) = default;
8448 };
8449 
8450 struct ParentClassConstructorInfo
8451 {
8452     ParentClassConstructorInfo(const QString &name, ConstructorParams &model)
8453         : className(name)
8454         , model(model)
8455     {}
8456     bool useInConstructor = false;
8457     const QString className;
8458     QString declaration;
8459     std::vector<ParentClassConstructorParameter> parameters;
8460     ConstructorParams &model;
8461 
8462     ParentClassConstructorInfo(const ParentClassConstructorInfo &) = delete;
8463     ParentClassConstructorInfo(ParentClassConstructorInfo &&) = default;
8464 
8465     void addParameter(ParentClassConstructorParameter &param) { model.addRow(&param); }
8466     void removeParameter(ParentClassConstructorParameter &param) { model.removeRow(&param); }
8467     void removeAllParameters()
8468     {
8469         for (auto &param : parameters)
8470             model.removeRow(&param);
8471     }
8472 };
8473 
8474 ParentClassConstructorParameter::ParentClassConstructorParameter(
8475     const QString &name,
8476     const QString &defaultValue,
8477     Symbol *symbol,
8478     const ParentClassConstructorInfo *parentClassConstructor)
8479     : ConstructorMemberInfo(parentClassConstructor->className + "::" + name,
8480                             name,
8481                             defaultValue,
8482                             symbol,
8483                             parentClassConstructor)
8484     , originalDefaultValue(defaultValue)
8485     , declaration(Overview{}.prettyType(symbol->type(), name)
8486                   + (defaultValue.isEmpty() ? QString{} : " = " + defaultValue))
8487 {}
8488 
8489 using ParentClassConstructors = std::vector<ParentClassConstructorInfo>;
8490 
8491 class ParentClassesModel : public QAbstractItemModel
8492 {
8493     ParentClassConstructors &constructors;
8494 
8495 public:
8496     ParentClassesModel(QObject *parent, ParentClassConstructors &constructors)
8497         : QAbstractItemModel(parent)
8498         , constructors(constructors)
8499     {}
8500     QModelIndex index(int row, int column, const QModelIndex &parent = {}) const override
8501     {
8502         if (!parent.isValid())
8503             return createIndex(row, column, nullptr);
8504         if (parent.internalPointer())
8505             return {};
8506         auto index = createIndex(row, column, &constructors.at(parent.row()));
8507         return index;
8508     }
8509     QModelIndex parent(const QModelIndex &index) const override
8510     {
8511         if (!index.isValid())
8512             return {};
8513         auto *parent = static_cast<ParentClassConstructorInfo *>(index.internalPointer());
8514         if (!parent)
8515             return {};
8516         int i = 0;
8517         for (const auto &info : constructors) {
8518             if (&info == parent)
8519                 return createIndex(i, 0, nullptr);
8520             ++i;
8521         }
8522         return {};
8523     }
8524     int rowCount(const QModelIndex &parent = {}) const override
8525     {
8526         if (!parent.isValid())
8527             return static_cast<int>(constructors.size());
8528         auto info = static_cast<ParentClassConstructorInfo *>(parent.internalPointer());
8529         if (!info)
8530             return static_cast<int>(constructors.at(parent.row()).parameters.size());
8531         return 0;
8532     }
8533     int columnCount(const QModelIndex & /*parent*/ = {}) const override { return 1; }
8534     QVariant data(const QModelIndex &index, int role) const override
8535     {
8536         if (!index.isValid())
8537             return {};
8538         auto info = static_cast<ParentClassConstructorInfo *>(index.internalPointer());
8539 
8540         if (info) {
8541             const auto &parameter = info->parameters.at(index.row());
8542             if (role == Qt::CheckStateRole)
8543                 return parameter.init ? Qt::Checked : Qt::Unchecked;
8544             if (role == Qt::DisplayRole)
8545                 return parameter.declaration;
8546             return {};
8547         }
8548         const auto &constructor = constructors.at(index.row());
8549         if (role == Qt::CheckStateRole)
8550             return constructor.useInConstructor ? Qt::PartiallyChecked : Qt::Unchecked;
8551         if (role == Qt::DisplayRole)
8552             return constructor.declaration;
8553 
8554         // Highlight the selected items
8555         if (role == Qt::FontRole && constructor.useInConstructor) {
8556             QFont font = QApplication::font();
8557             font.setBold(true);
8558             return font;
8559         }
8560         // Create a margin between sets of constructors for base classes
8561         if (role == Qt::SizeHintRole && index.row() > 0
8562             && constructor.className != constructors.at(index.row() - 1).className) {
8563             return QSize(-1, 25);
8564         }
8565         return {};
8566     }
8567     bool setData(const QModelIndex &index, const QVariant &value, int /*role*/) override
8568     {
8569         if (index.isValid() && index.column() == 0) {
8570             auto info = static_cast<ParentClassConstructorInfo *>(index.internalPointer());
8571             if (info) {
8572                 const bool nowUse = value.toBool();
8573                 auto &param = info->parameters.at(index.row());
8574                 param.init = nowUse;
8575                 if (nowUse)
8576                     info->addParameter(param);
8577                 else
8578                     info->removeParameter(param);
8579                 return true;
8580             }
8581             auto &newConstructor = constructors.at(index.row());
8582             // You have to select a base class constructor
8583             if (newConstructor.useInConstructor)
8584                 return false;
8585             auto c = std::find_if(constructors.begin(), constructors.end(), [&](const auto &c) {
8586                 return c.className == newConstructor.className && c.useInConstructor;
8587             });
8588             QTC_ASSERT(c == constructors.end(), return false;);
8589             c->useInConstructor = false;
8590             newConstructor.useInConstructor = true;
8591             emit dataChanged(this->index(index.row(), 0), this->index(index.row(), columnCount()));
8592             auto parentIndex = this->index(index.row(), 0);
8593             emit dataChanged(this->index(0, 0, parentIndex),
8594                              this->index(rowCount(parentIndex), columnCount()));
8595             const int oldIndex = c - constructors.begin();
8596             emit dataChanged(this->index(oldIndex, 0), this->index(oldIndex, columnCount()));
8597             parentIndex = this->index(oldIndex, 0);
8598             emit dataChanged(this->index(0, 0, parentIndex),
8599                              this->index(rowCount(parentIndex), columnCount()));
8600             // update other table
8601             c->removeAllParameters();
8602             for (auto &p : newConstructor.parameters)
8603                 if (p.init)
8604                     newConstructor.addParameter(p);
8605             return true;
8606         }
8607         return false;
8608     }
8609     QVariant headerData(int section, Qt::Orientation orientation, int role) const override
8610     {
8611         if (orientation == Qt::Horizontal && role == Qt::DisplayRole) {
8612             switch (section) {
8613             case 0:
8614                 return CppQuickFixFactory::tr("Base Class Constructors");
8615             }
8616         }
8617         return {};
8618     }
8619     Qt::ItemFlags flags(const QModelIndex &index) const override
8620     {
8621         if (index.isValid()) {
8622             Qt::ItemFlags f;
8623             auto info = static_cast<ParentClassConstructorInfo *>(index.internalPointer());
8624             if (!info || info->useInConstructor) {
8625                 f |= Qt::ItemIsEnabled;
8626             }
8627             f |= Qt::ItemIsUserCheckable;
8628 
8629             return f;
8630         }
8631         return {};
8632     }
8633 };
8634 
8635 class GenerateConstructorDialog : public QDialog
8636 {
8637     Q_DECLARE_TR_FUNCTIONS(GenerateConstructorDialog)
8638 public:
8639     GenerateConstructorDialog(ConstructorParams *constructorParamsModel,
8640                               ParentClassConstructors &constructors)
8641     {
8642         setWindowTitle(tr("Constructor"));
8643 
8644         const auto treeModel = new ParentClassesModel(this, constructors);
8645         const auto treeView = new QTreeView(this);
8646         treeView->setModel(treeModel);
8647         treeView->setItemDelegate(new TopMarginDelegate(this));
8648         treeView->expandAll();
8649 
8650         const auto view = new QTableView(this);
8651         view->setModel(constructorParamsModel);
8652         int optimalWidth = 0;
8653         for (int i = 0; i < constructorParamsModel->columnCount(QModelIndex{}); ++i) {
8654             view->resizeColumnToContents(i);
8655             optimalWidth += view->columnWidth(i);
8656         }
8657         view->resizeRowsToContents();
8658         view->verticalHeader()->setDefaultSectionSize(view->rowHeight(0));
8659         view->setSelectionBehavior(QAbstractItemView::SelectRows);
8660         view->setSelectionMode(QAbstractItemView::SingleSelection);
8661         view->setDragEnabled(true);
8662         view->setDropIndicatorShown(true);
8663         view->setDefaultDropAction(Qt::MoveAction);
8664         view->setDragDropMode(QAbstractItemView::InternalMove);
8665         view->setDragDropOverwriteMode(false);
8666         view->horizontalHeader()->setStretchLastSection(true);
8667         view->setStyle(new ConstructorParams::TableViewStyle(view->style()));
8668 
8669         const auto buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
8670         connect(buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
8671         connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);
8672 
8673         const auto errorLabel = new QLabel(
8674             tr("Parameters without default value must come before parameters with default value."));
8675         errorLabel->setStyleSheet("color: #ff0000");
8676         errorLabel->setVisible(false);
8677         QSizePolicy labelSizePolicy = errorLabel->sizePolicy();
8678         labelSizePolicy.setRetainSizeWhenHidden(true);
8679         errorLabel->setSizePolicy(labelSizePolicy);
8680         connect(constructorParamsModel,
8681                 &ConstructorParams::validOrder,
8682                 [=, button = buttonBox->button(QDialogButtonBox::Ok)](bool valid) {
8683                     button->setEnabled(valid);
8684                     errorLabel->setVisible(!valid);
8685                 });
8686 
8687         // setup select all/none checkbox
8688         QCheckBox *const checkBox = new QCheckBox(tr("Initialize all members"));
8689         checkBox->setChecked(true);
8690         connect(checkBox, &QCheckBox::stateChanged, [model = constructorParamsModel](int state) {
8691             if (state != Qt::PartiallyChecked) {
8692                 for (int i = 0; i < model->rowCount(); ++i)
8693                     model->setData(model->index(i, ConstructorParams::ShouldInitColumn),
8694                                    state,
8695                                    Qt::CheckStateRole);
8696             }
8697         });
8698         connect(checkBox, &QCheckBox::clicked, this, [checkBox] {
8699             if (checkBox->checkState() == Qt::PartiallyChecked)
8700                 checkBox->setCheckState(Qt::Checked);
8701         });
8702         connect(constructorParamsModel,
8703                 &QAbstractItemModel::dataChanged,
8704                 this,
8705                 [model = constructorParamsModel, checkBox] {
8706                     const auto state = [model, selectedCount = model->selectedCount()]() {
8707                         if (selectedCount == 0)
8708                             return Qt::Unchecked;
8709                         if (static_cast<int>(model->memberCount() == selectedCount))
8710                             return Qt::Checked;
8711                         return Qt::PartiallyChecked;
8712                     }();
8713                     checkBox->setCheckState(state);
8714                 });
8715 
8716         using A = InsertionPointLocator::AccessSpec;
8717         auto accessCombo = new QComboBox;
8718         connect(accessCombo, qOverload<int>(&QComboBox::currentIndexChanged), [this, accessCombo]() {
8719             const auto data = accessCombo->currentData();
8720             m_accessSpec = static_cast<A>(data.toInt());
8721         });
8722         for (auto a : {A::Public, A::Protected, A::Private})
8723             accessCombo->addItem(InsertionPointLocator::accessSpecToString(a), a);
8724         const auto row = new QHBoxLayout();
8725         row->addWidget(new QLabel(tr("Access") + ":"));
8726         row->addWidget(accessCombo);
8727         row->addSpacerItem(new QSpacerItem(1, 1, QSizePolicy::Expanding, QSizePolicy::Minimum));
8728 
8729         const auto mainLayout = new QVBoxLayout(this);
8730         mainLayout->addWidget(
8731             new QLabel(tr("Select the members to be initialized in the constructor.\n"
8732                           "Use drag and drop to change the order of the parameters.")));
8733         mainLayout->addLayout(row);
8734         mainLayout->addWidget(checkBox);
8735         mainLayout->addWidget(view);
8736         mainLayout->addWidget(treeView);
8737         mainLayout->addWidget(errorLabel);
8738         mainLayout->addWidget(buttonBox);
8739         int left, right;
8740         mainLayout->getContentsMargins(&left, nullptr, &right, nullptr);
8741         optimalWidth += left + right;
8742         resize(optimalWidth, mainLayout->sizeHint().height());
8743     }
8744 
8745     InsertionPointLocator::AccessSpec accessSpec() const { return m_accessSpec; }
8746 
8747 private:
8748     InsertionPointLocator::AccessSpec m_accessSpec;
8749 };
8750 
8751 class GenerateConstructorOperation : public CppQuickFixOperation
8752 {
8753 public:
8754     GenerateConstructorOperation(const CppQuickFixInterface &interface)
8755         : CppQuickFixOperation(interface)
8756     {
8757         setDescription(CppQuickFixFactory::tr("Generate Constructor"));
8758 
8759         m_classAST = astForClassOperations(interface);
8760         if (!m_classAST)
8761             return;
8762         Class *const theClass = m_classAST->symbol;
8763         if (!theClass)
8764             return;
8765 
8766         // Go through all members and find member variable declarations
8767         int memberCounter = 0;
8768         for (auto it = theClass->memberBegin(); it != theClass->memberEnd(); ++it) {
8769             Symbol *const s = *it;
8770             if (!s->identifier() || !s->type() || s->type().isTypedef())
8771                 continue;
8772             if ((s->isDeclaration() && s->type()->asFunctionType()) || s->asFunction())
8773                 continue;
8774             if (s->isDeclaration() && (s->isPrivate() || s->isProtected()) && !s->isStatic()) {
8775                 const auto name = QString::fromUtf8(s->identifier()->chars(),
8776                                                     s->identifier()->size());
8777                 parameterModel.emplaceBackParameter(name, s, memberCounter++);
8778             }
8779         }
8780         Overview o = CppCodeStyleSettings::currentProjectCodeStyleOverview();
8781         o.showArgumentNames = true;
8782         o.showReturnTypes = true;
8783         o.showDefaultArguments = true;
8784         o.showTemplateParameters = true;
8785         o.showFunctionSignatures = true;
8786         LookupContext context(currentFile()->cppDocument(), interface.snapshot());
8787         for (BaseClass *bc : theClass->baseClasses()) {
8788             const QString className = o.prettyName(bc->name());
8789 
8790             ClassOrNamespace *localLookupType = context.lookupType(bc);
8791             QList<LookupItem> localLookup = localLookupType->lookup(bc->name());
8792             for (auto &li : localLookup) {
8793                 Symbol *d = li.declaration();
8794                 if (!d->asClass())
8795                     continue;
8796                 for (auto i = d->asClass()->memberBegin(); i != d->asClass()->memberEnd(); ++i) {
8797                     Symbol *s = *i;
8798                     if (s->isProtected() || s->isPublic()) {
8799                         if (s->name()->match(d->name())) {
8800                             // we have found a constructor
8801                             Function *func = s->type().type()->asFunctionType();
8802                             if (!func)
8803                                 continue;
8804                             const bool isFirst = parentClassConstructors.empty()
8805                                                  || parentClassConstructors.back().className
8806                                                         != className;
8807                             parentClassConstructors.emplace_back(className, parameterModel);
8808                             ParentClassConstructorInfo &constructor = parentClassConstructors.back();
8809                             constructor.declaration = className + o.prettyType(func->type());
8810                             constructor.declaration.replace("std::__1::__get_nullptr_t()",
8811                                                             "nullptr");
8812                             constructor.useInConstructor = isFirst;
8813                             for (auto arg = func->memberBegin(); arg != func->memberEnd(); ++arg) {
8814                                 Symbol *param = *arg;
8815                                 Argument *argument = param->asArgument();
8816                                 if (!argument) // can also be a block
8817                                     continue;
8818                                 const QString name = o.prettyName(param->name());
8819                                 const StringLiteral *ini = argument->initializer();
8820                                 QString defaultValue;
8821                                 if (ini)
8822                                     defaultValue = QString::fromUtf8(ini->chars(), ini->size())
8823                                                        .replace("std::__1::__get_nullptr_t()",
8824                                                                 "nullptr");
8825                                 constructor.parameters.emplace_back(name,
8826                                                                     defaultValue,
8827                                                                     param,
8828                                                                     &constructor);
8829                                 // do not show constructors like QObject(QObjectPrivate & dd, ...)
8830                                 ReferenceType *ref = param->type()->asReferenceType();
8831                                 if (ref && name == "dd") {
8832                                     auto type = o.prettyType(ref->elementType());
8833                                     if (type.startsWith("Q") && type.endsWith("Private")) {
8834                                         parentClassConstructors.pop_back();
8835                                         break;
8836                                     }
8837                                 }
8838                             }
8839                         }
8840                     }
8841                 }
8842             }
8843         }
8844 
8845         // add params to parameter lists
8846         for (auto &c : parentClassConstructors)
8847             if (c.useInConstructor)
8848                 for (auto &p : c.parameters)
8849                     if (p.init)
8850                         c.addParameter(p);
8851     }
8852 
8853     bool isApplicable() const
8854     {
8855         return parameterModel.rowCount() > 0
8856                || Utils::anyOf(parentClassConstructors,
8857                                [](const auto &parent) { return !parent.parameters.empty(); });
8858     }
8859 
8860     void setTest(bool isTest = true) { m_test = isTest; }
8861 
8862 private:
8863     void perform() override
8864     {
8865         auto infos = parameterModel.getInfos();
8866 
8867         InsertionPointLocator::AccessSpec accessSpec = InsertionPointLocator::Public;
8868         if (!m_test) {
8869             GenerateConstructorDialog dlg(&parameterModel, parentClassConstructors);
8870             if (dlg.exec() == QDialog::Rejected)
8871                 return;
8872             accessSpec = dlg.accessSpec();
8873             infos = parameterModel.getInfos();
8874         } else {
8875 #ifdef WITH_TESTS
8876             ParentClassesModel model(nullptr, parentClassConstructors);
8877             QAbstractItemModelTester tester(&model);
8878 #endif
8879             if (infos.size() >= 3) {
8880                 // if we are testing and have 3 or more members => change the order
8881                 // move first element to the back
8882                 infos.push_back(infos[0]);
8883                 infos.erase(infos.begin());
8884             }
8885             for (auto info : infos) {
8886                 if (info->memberVariableName.startsWith("di_"))
8887                     info->defaultValue = "42";
8888             }
8889             for (auto &c : parentClassConstructors) {
8890                 if (c.useInConstructor) {
8891                     for (auto &p : c.parameters) {
8892                         if (!p.init && p.parameterName.startsWith("use_")) {
8893                             infos.push_back(&p);
8894                             p.init = true;
8895                         }
8896                     }
8897                 }
8898             }
8899         }
8900         if (infos.empty())
8901             return;
8902         struct GenerateConstructorRefactoringHelper : public GetterSetterRefactoringHelper
8903         {
8904             const ClassSpecifierAST *m_classAST;
8905             InsertionPointLocator::AccessSpec m_accessSpec;
8906             GenerateConstructorRefactoringHelper(CppQuickFixOperation *operation,
8907                                                  const QString &fileName,
8908                                                  Class *clazz,
8909                                                  const ClassSpecifierAST *classAST,
8910                                                  InsertionPointLocator::AccessSpec accessSpec)
8911                 : GetterSetterRefactoringHelper(operation, fileName, clazz)
8912                 , m_classAST(classAST)
8913                 , m_accessSpec(accessSpec)
8914             {}
8915             void generateConstructor(std::vector<ConstructorMemberInfo *> members,
8916                                      const ParentClassConstructors &parentClassConstructors)
8917             {
8918                 auto constructorLocation = m_settings->determineSetterLocation(int(members.size()));
8919                 if (constructorLocation == CppQuickFixSettings::FunctionLocation::CppFile
8920                     && !hasSourceFile())
8921                     constructorLocation = CppQuickFixSettings::FunctionLocation::OutsideClass;
8922 
8923                 Overview overview = CppCodeStyleSettings::currentProjectCodeStyleOverview();
8924                 overview.showTemplateParameters = true;
8925 
8926                 InsertionLocation implLoc;
8927                 QString implCode;
8928                 CppRefactoringFilePtr implFile;
8929                 QString className = overview.prettyName(m_class->name());
8930                 QStringList insertedNamespaces;
8931                 if (constructorLocation == CppQuickFixSettings::FunctionLocation::CppFile) {
8932                     implLoc = sourceLocationFor(m_class, &insertedNamespaces);
8933                     implFile = m_sourceFile;
8934                     QString clazz = overview.prettyName(m_class->name());
8935                     if (m_settings->rewriteTypesinCppFile())
8936                         implCode = symbolAt(m_class, m_sourceFile, implLoc);
8937                     else
8938                         implCode = className;
8939                     implCode += "::" + className + "(";
8940                 } else if (constructorLocation
8941                            == CppQuickFixSettings::FunctionLocation::OutsideClass) {
8942                     implLoc = insertLocationForMethodDefinition(m_class,
8943                                                                 false,
8944                                                                 NamespaceHandling::Ignore,
8945                                                                 m_changes,
8946                                                                 m_headerFile->filePath().toString(),
8947                                                                 &insertedNamespaces);
8948                     implFile = m_headerFile;
8949                     implCode = symbolAt(m_class, m_headerFile, implLoc);
8950                     implCode += "::" + className + "(";
8951                 }
8952 
8953                 QString inClassDeclaration = overview.prettyName(m_class->name()) + "(";
8954                 QString constructorBody = members.empty() ? QString(") {}") : QString(") : ");
8955                 for (auto &member : members) {
8956                     if (isValueType(member->symbol, &member->customValueType))
8957                         member->type.setConst(false);
8958                     else
8959                         member->type = makeConstRef(member->type);
8960 
8961                     inClassDeclaration += overview.prettyType(member->type, member->parameterName);
8962                     if (!member->defaultValue.isEmpty())
8963                         inClassDeclaration += " = " + member->defaultValue;
8964                     inClassDeclaration += ", ";
8965                     QString param = member->parameterName;
8966                     if (implFile) {
8967                         FullySpecifiedType type = typeAt(member->type,
8968                                                          m_class,
8969                                                          implFile,
8970                                                          implLoc,
8971                                                          insertedNamespaces);
8972                         implCode += overview.prettyType(type, member->parameterName) + ", ";
8973                     }
8974                 }
8975                 Utils::sort(members, &ConstructorMemberInfo::numberOfMember);
8976                 // first, do the base classes
8977                 for (const auto &parent : parentClassConstructors) {
8978                     if (!parent.useInConstructor)
8979                         continue;
8980                     // Check if we really need a constructor
8981                     if (Utils::anyOf(parent.parameters, [](const auto &param) {
8982                             return param.init || param.originalDefaultValue.isEmpty();
8983                         })) {
8984                         int defaultAtEndCount = 0;
8985                         for (auto i = parent.parameters.crbegin(); i != parent.parameters.crend();
8986                              ++i) {
8987                             if (i->init || i->originalDefaultValue.isEmpty())
8988                                 break;
8989                             ++defaultAtEndCount;
8990                         }
8991                         const int numberOfParameters = static_cast<int>(parent.parameters.size())
8992                                                        - defaultAtEndCount;
8993                         constructorBody += parent.className + "(";
8994                         int counter = 0;
8995                         for (const auto &param : parent.parameters) {
8996                             if (++counter > numberOfParameters)
8997                                 break;
8998                             if (param.init) {
8999                                 if (param.customValueType)
9000                                     constructorBody += "std::move(" + param.parameterName + ')';
9001                                 else
9002                                     constructorBody += param.parameterName;
9003                             } else if (!param.originalDefaultValue.isEmpty())
9004                                 constructorBody += param.originalDefaultValue;
9005                             else
9006                                 constructorBody += "/* insert value */";
9007                             constructorBody += ", ";
9008                         }
9009                         constructorBody.resize(constructorBody.length() - 2);
9010                         constructorBody += "),\n";
9011                     }
9012                 }
9013                 for (auto &member : members) {
9014                     if (member->parentClassConstructor)
9015                         continue;
9016                     QString param = member->parameterName;
9017                     if (member->customValueType)
9018                         param = "std::move(" + member->parameterName + ')';
9019                     constructorBody += member->memberVariableName + '(' + param + "),\n";
9020                 }
9021                 if (!members.empty()) {
9022                     inClassDeclaration.resize(inClassDeclaration.length() - 2);
9023                     constructorBody.remove(constructorBody.length() - 2, 1); // ..),\n => ..)\n
9024                     constructorBody += "{}";
9025                     if (!implCode.isEmpty())
9026                         implCode.resize(implCode.length() - 2);
9027                 }
9028                 implCode += constructorBody;
9029 
9030                 if (constructorLocation == CppQuickFixSettings::FunctionLocation::InsideClass)
9031                     inClassDeclaration += constructorBody;
9032                 else
9033                     inClassDeclaration += QLatin1String(");");
9034 
9035                 TranslationUnit *tu = m_headerFile->cppDocument()->translationUnit();
9036                 insertAndIndent(m_headerFile,
9037                                 m_locator.constructorDeclarationInClass(tu,
9038                                                                         m_classAST,
9039                                                                         m_accessSpec,
9040                                                                         int(members.size())),
9041                                 inClassDeclaration);
9042 
9043                 if (constructorLocation == CppQuickFixSettings::FunctionLocation::CppFile) {
9044                     addSourceFileCode(implCode);
9045                 } else if (constructorLocation
9046                            == CppQuickFixSettings::FunctionLocation::OutsideClass) {
9047                     if (isHeaderHeaderFile())
9048                         implCode.prepend("inline ");
9049                     insertAndIndent(m_headerFile, implLoc, implCode);
9050                 }
9051             }
9052         };
9053         GenerateConstructorRefactoringHelper helper(this,
9054                                                     currentFile()->filePath().toString(),
9055                                                     m_classAST->symbol,
9056                                                     m_classAST,
9057                                                     accessSpec);
9058 
9059         auto members = Utils::filtered(infos, [](const auto mi) {
9060             return mi->init || mi->parentClassConstructor;
9061         });
9062         helper.generateConstructor(std::move(members), parentClassConstructors);
9063         helper.applyChanges();
9064     }
9065 
9066     ConstructorParams parameterModel;
9067     ParentClassConstructors parentClassConstructors;
9068     const ClassSpecifierAST *m_classAST = nullptr;
9069     bool m_test = false;
9070 };
9071 } // namespace
9072 void GenerateConstructor::match(const CppQuickFixInterface &interface, QuickFixOperations &result)
9073 {
9074     const auto op = QSharedPointer<GenerateConstructorOperation>::create(interface);
9075     if (!op->isApplicable())
9076         return;
9077     op->setTest(m_test);
9078     result << op;
9079 }
9080 
9081 void createCppQuickFixes()
9082 {
9083     new AddIncludeForUndefinedIdentifier;
9084 
9085     new FlipLogicalOperands;
9086     new InverseLogicalComparison;
9087     new RewriteLogicalAnd;
9088 
9089     new ConvertToCamelCase;
9090 
9091     new ConvertCStringToNSString;
9092     new ConvertNumericLiteral;
9093     new TranslateStringLiteral;
9094     new WrapStringLiteral;
9095 
9096     new MoveDeclarationOutOfIf;
9097     new MoveDeclarationOutOfWhile;
9098 
9099     new SplitIfStatement;
9100     new SplitSimpleDeclaration;
9101 
9102     new AddLocalDeclaration;
9103     new AddBracesToIf;
9104     new RearrangeParamDeclarationList;
9105     new ReformatPointerDeclaration;
9106 
9107     new CompleteSwitchCaseStatement;
9108     new InsertQtPropertyMembers;
9109     new ConvertQt4Connect;
9110 
9111     new ApplyDeclDefLinkChanges;
9112     new ConvertFromAndToPointer;
9113     new ExtractFunction;
9114     new ExtractLiteralAsParameter;
9115     new GenerateGetterSetter;
9116     new GenerateGettersSettersForClass;
9117     new InsertDeclFromDef;
9118     new InsertDefFromDecl;
9119     new InsertMemberFromInitialization;
9120     new InsertDefsFromDecls;
9121 
9122     new MoveFuncDefOutside;
9123     new MoveAllFuncDefOutside;
9124     new MoveFuncDefToDecl;
9125 
9126     new AssignToLocalVariable;
9127 
9128     new InsertVirtualMethods;
9129 
9130     new OptimizeForLoop;
9131 
9132     new EscapeStringLiteral;
9133 
9134     new ExtraRefactoringOperations;
9135 
9136     new RemoveUsingNamespace;
9137     new GenerateConstructor;
9138 }
9139 
9140 void destroyCppQuickFixes()
9141 {
9142     for (int i = g_cppQuickFixFactories.size(); --i >= 0; )
9143         delete g_cppQuickFixFactories.at(i);
9144 }
9145 
9146 } // namespace Internal
9147 } // namespace CppEditor
9148 
9149 #include "cppquickfixes.moc"
