Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2015 The Qt Company Ltd.
4 ** Contact: http://www.qt.io/licensing/
5 **
6 ** This file is part of the QtWidgets module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL21$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see http://www.qt.io/terms-conditions. For further
15 ** information use the contact form at http://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 2.1 or version 3 as published by the Free
20 ** Software Foundation and appearing in the file LICENSE.LGPLv21 and
21 ** LICENSE.LGPLv3 included in the packaging of this file. Please review the
22 ** following information to ensure the GNU Lesser General Public License
23 ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
24 ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
25 **
26 ** As a special exception, The Qt Company gives you certain additional
27 ** rights. These rights are described in The Qt Company LGPL Exception
28 ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
29 **
30 ** $QT_END_LICENSE$
31 **
32 ****************************************************************************/
33 
34 #include "qheaderview.h"
35 
36 #ifndef QT_NO_ITEMVIEWS
37 #include <qbitarray.h>
38 #include <qbrush.h>
39 #include <qdebug.h>
40 #include <qevent.h>
41 #include <qpainter.h>
42 #include <qscrollbar.h>
43 #include <qtooltip.h>
44 #include <qwhatsthis.h>
45 #include <qstyle.h>
46 #include <qstyleoption.h>
47 #include <qvector.h>
48 #include <qapplication.h>
49 #include <qvarlengtharray.h>
50 #include <qabstractitemdelegate.h>
51 #include <qvariant.h>
52 #include <private/qheaderview_p.h>
53 #include <private/qabstractitemmodel_p.h>
54 
55 #ifndef QT_NO_DATASTREAM
56 #include <qdatastream.h>
57 #endif
58 
59 QT_BEGIN_NAMESPACE
60 
61 #ifndef QT_NO_DATASTREAM
62 QDataStream &operator<<(QDataStream &out, const QHeaderViewPrivate::SectionItem &section)
63 {
64     section.write(out);
65     return out;
66 }
67 
68 QDataStream &operator>>(QDataStream &in, QHeaderViewPrivate::SectionItem &section)
69 {
70     section.read(in);
71     return in;
72 }
73 #endif // QT_NO_DATASTREAM
74 
75 static const int maxSizeSection = 1048575; // since section size is in a bitfield (uint 20). See qheaderview_p.h
76                                            // if this is changed then the docs in maximumSectionSize should be changed.
77 
78 /*!
79     \class QHeaderView
80 
81     \brief The QHeaderView class provides a header row or header column for
82     item views.
83 
84     \ingroup model-view
85     \inmodule QtWidgets
86 
87     A QHeaderView displays the headers used in item views such as the
88     QTableView and QTreeView classes. It takes the place of Qt3's \c QHeader
89     class previously used for the same purpose, but uses the Qt's model/view
90     architecture for consistency with the item view classes.
91 
92     The QHeaderView class is one of the \l{Model/View Classes} and is part of
93     Qt's \l{Model/View Programming}{model/view framework}.
94 
95     The header gets the data for each section from the model using the
96     QAbstractItemModel::headerData() function. You can set the data by using
97     QAbstractItemModel::setHeaderData().
98 
99     Each header has an orientation() and a number of sections, given by the
100     count() function. A section refers to a part of the header - either a row
101     or a column, depending on the orientation.
102 
103     Sections can be moved and resized using moveSection() and resizeSection();
104     they can also be hidden and shown with hideSection() and showSection().
105 
106     Each section of a header is described by a section ID, specified by its
107     section(), and can be located at a particular visualIndex() in the header.
108     A section can have a sort indicator set with setSortIndicator(); this
109     indicates whether the items in the associated item view will be sorted in
110     the order given by the section.
111 
112     For a horizontal header the section is equivalent to a column in the model,
113     and for a vertical header the section is equivalent to a row in the model.
114 
115     \section1 Moving Header Sections
116 
117     A header can be fixed in place, or made movable with setSectionsMovable(). It can
118     be made clickable with setSectionsClickable(), and has resizing behavior in
119     accordance with setSectionResizeMode().
120 
121     \note Double-clicking on a header to resize a section only applies for
122     visible rows.
123 
124     A header will emit sectionMoved() if the user moves a section,
125     sectionResized() if the user resizes a section, and sectionClicked() as
126     well as sectionHandleDoubleClicked() in response to mouse clicks. A header
127     will also emit sectionCountChanged().
128 
129     You can identify a section using the logicalIndex() and logicalIndexAt()
130     functions, or by its index position, using the visualIndex() and
131     visualIndexAt() functions. The visual index will change if a section is
132     moved, but the logical index will not change.
133 
134     \section1 Appearance
135 
136     QTableWidget and QTableView create default headers. If you want
137     the headers to be visible, you can use \l{QFrame::}{setVisible()}.
138 
139     Not all \l{Qt::}{ItemDataRole}s will have an effect on a
140     QHeaderView. If you need to draw other roles, you can subclass
141     QHeaderView and reimplement \l{QHeaderView::}{paintEvent()}.
142     QHeaderView respects the following item data roles:
143     \l{Qt::}{TextAlignmentRole}, \l{Qt::}{DisplayRole},
144     \l{Qt::}{FontRole}, \l{Qt::}{DecorationRole},
145     \l{Qt::}{ForegroundRole}, and \l{Qt::}{BackgroundRole}.
146 
147     \note Each header renders the data for each section itself, and does not
148     rely on a delegate. As a result, calling a header's setItemDelegate()
149     function will have no effect.
150 
151     \sa {Model/View Programming}, QListView, QTableView, QTreeView
152 */
153 
154 /*!
155     \enum QHeaderView::ResizeMode
156 
157     The resize mode specifies the behavior of the header sections. It can be
158     set on the entire header view or on individual sections using
159     setSectionResizeMode().
160 
161     \value Interactive The user can resize the section. The section can also be
162            resized programmatically using resizeSection().  The section size
163            defaults to \l defaultSectionSize. (See also
164            \l cascadingSectionResizes.)
165 
166     \value Fixed The user cannot resize the section. The section can only be
167            resized programmatically using resizeSection(). The section size
168            defaults to \l defaultSectionSize.
169 
170     \value Stretch QHeaderView will automatically resize the section to fill
171            the available space. The size cannot be changed by the user or
172            programmatically.
173 
174     \value ResizeToContents QHeaderView will automatically resize the section
175            to its optimal size based on the contents of the entire column or
176            row. The size cannot be changed by the user or programmatically.
177            (This value was introduced in 4.2)
178 
179     The following values are obsolete:
180     \value Custom Use Fixed instead.
181 
182     \sa setResizeMode(), setSectionResizeMode(), stretchLastSection, minimumSectionSize
183 */
184 
185 /*!
186     \fn void QHeaderView::sectionMoved(int logicalIndex, int oldVisualIndex,
187     int newVisualIndex)
188 
189     This signal is emitted when a section is moved. The section's logical index
190     is specified by \a logicalIndex, the old index by \a oldVisualIndex, and
191     the new index position by \a newVisualIndex.
192 
193     \sa moveSection()
194 */
195 
196 /*!
197     \fn void QHeaderView::sectionResized(int logicalIndex, int oldSize,
198     int newSize)
199 
200     This signal is emitted when a section is resized. The section's logical
201     number is specified by \a logicalIndex, the old size by \a oldSize, and the
202     new size by \a newSize.
203 
204     \sa resizeSection()
205 */
206 
207 /*!
208     \fn void QHeaderView::sectionPressed(int logicalIndex)
209 
210     This signal is emitted when a section is pressed. The section's logical
211     index is specified by \a logicalIndex.
212 
213     \sa setSectionsClickable()
214 */
215 
216 /*!
217     \fn void QHeaderView::sectionClicked(int logicalIndex)
218 
219     This signal is emitted when a section is clicked. The section's logical
220     index is specified by \a logicalIndex.
221 
222     Note that the sectionPressed signal will also be emitted.
223 
224     \sa setSectionsClickable(), sectionPressed()
225 */
226 
227 /*!
228     \fn void QHeaderView::sectionEntered(int logicalIndex)
229     \since 4.3
230 
231     This signal is emitted when the cursor moves over the section and the left
232     mouse button is pressed. The section's logical index is specified by
233     \a logicalIndex.
234 
235     \sa setSectionsClickable(), sectionPressed()
236 */
237 
238 /*!
239     \fn void QHeaderView::sectionDoubleClicked(int logicalIndex)
240 
241     This signal is emitted when a section is double-clicked. The section's
242     logical index is specified by \a logicalIndex.
243 
244     \sa setSectionsClickable()
245 */
246 
247 /*!
248     \fn void QHeaderView::sectionCountChanged(int oldCount, int newCount)
249 
250     This signal is emitted when the number of sections changes, i.e., when
251     sections are added or deleted. The original count is specified by
252     \a oldCount, and the new count by \a newCount.
253 
254     \sa count(), length(), headerDataChanged()
255 */
256 
257 /*!
258     \fn void QHeaderView::sectionHandleDoubleClicked(int logicalIndex)
259 
260     This signal is emitted when a section is double-clicked. The section's
261     logical index is specified by \a logicalIndex.
262 
263     \sa setSectionsClickable()
264 */
265 
266 /*!
267     \fn void QHeaderView::sortIndicatorChanged(int logicalIndex,
268     Qt::SortOrder order)
269     \since 4.3
270 
271     This signal is emitted when the section containing the sort indicator or
272     the order indicated is changed. The section's logical index is specified
273     by \a logicalIndex and the sort order is specified by \a order.
274 
275     \sa setSortIndicator()
276 */
277 
278 /*!
279     \fn void QHeaderView::geometriesChanged()
280     \since 4.2
281 
282     This signal is emitted when the header's geometries have changed.
283 */
284 
285 /*!
286     \property QHeaderView::highlightSections
287     \brief whether the sections containing selected items are highlighted
288 
289     By default, this property is \c false.
290 */
291 
292 /*!
293     Creates a new generic header with the given \a orientation and \a parent.
294 */
295 QHeaderView::QHeaderView(Qt::Orientation orientation, QWidget *parent)
296     : QAbstractItemView(*new QHeaderViewPrivate, parent)
297 {
298     Q_D(QHeaderView);
299     d->setDefaultValues(orientation);
300     initialize();
301 }
302 
303 /*!
304   \internal
305 */
306 QHeaderView::QHeaderView(QHeaderViewPrivate &dd,
307                          Qt::Orientation orientation, QWidget *parent)
308     : QAbstractItemView(dd, parent)
309 {
310     Q_D(QHeaderView);
311     d->setDefaultValues(orientation);
312     initialize();
313 }
314 
315 /*!
316   Destroys the header.
317 */
318 
319 QHeaderView::~QHeaderView()
320 {
321 }
322 
323 /*!
324   \internal
325 */
326 void QHeaderView::initialize()
327 {
328     Q_D(QHeaderView);
329     setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
330     setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
331     setFrameStyle(NoFrame);
332     setFocusPolicy(Qt::NoFocus);
333     d->viewport->setMouseTracking(true);
334     d->viewport->setBackgroundRole(QPalette::Button);
335     d->textElideMode = Qt::ElideNone;
336     delete d->itemDelegate;
337 }
338 
339 /*!
340   \reimp
341 */
342 void QHeaderView::setModel(QAbstractItemModel *model)
343 {
344     if (model == this->model())
345         return;
346     Q_D(QHeaderView);
347     d->persistentHiddenSections.clear();
348     if (d->model && d->model != QAbstractItemModelPrivate::staticEmptyModel()) {
349     if (d->orientation == Qt::Horizontal) {
350         QObject::disconnect(d->model, SIGNAL(columnsInserted(QModelIndex,int,int)),
351                             this, SLOT(sectionsInserted(QModelIndex,int,int)));
352         QObject::disconnect(d->model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
353                             this, SLOT(sectionsAboutToBeRemoved(QModelIndex,int,int)));
354         QObject::disconnect(d->model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
355                             this, SLOT(_q_sectionsRemoved(QModelIndex,int,int)));
356         QObject::disconnect(d->model, SIGNAL(columnsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
357                             this, SLOT(_q_layoutAboutToBeChanged()));
358     } else {
359         QObject::disconnect(d->model, SIGNAL(rowsInserted(QModelIndex,int,int)),
360                             this, SLOT(sectionsInserted(QModelIndex,int,int)));
361         QObject::disconnect(d->model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
362                             this, SLOT(sectionsAboutToBeRemoved(QModelIndex,int,int)));
363         QObject::disconnect(d->model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
364                             this, SLOT(_q_sectionsRemoved(QModelIndex,int,int)));
365         QObject::disconnect(d->model, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
366                             this, SLOT(_q_layoutAboutToBeChanged()));
367     }
368     QObject::disconnect(d->model, SIGNAL(headerDataChanged(Qt::Orientation,int,int)),
369                         this, SLOT(headerDataChanged(Qt::Orientation,int,int)));
370     QObject::disconnect(d->model, SIGNAL(layoutAboutToBeChanged()),
371                         this, SLOT(_q_layoutAboutToBeChanged()));
372     }
373 
374     if (model && model != QAbstractItemModelPrivate::staticEmptyModel()) {
375         if (d->orientation == Qt::Horizontal) {
376             QObject::connect(model, SIGNAL(columnsInserted(QModelIndex,int,int)),
377                              this, SLOT(sectionsInserted(QModelIndex,int,int)));
378             QObject::connect(model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
379                              this, SLOT(sectionsAboutToBeRemoved(QModelIndex,int,int)));
380             QObject::connect(model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
381                              this, SLOT(_q_sectionsRemoved(QModelIndex,int,int)));
382             QObject::connect(model, SIGNAL(columnsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
383                              this, SLOT(_q_layoutAboutToBeChanged()));
384         } else {
385             QObject::connect(model, SIGNAL(rowsInserted(QModelIndex,int,int)),
386                              this, SLOT(sectionsInserted(QModelIndex,int,int)));
387             QObject::connect(model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
388                              this, SLOT(sectionsAboutToBeRemoved(QModelIndex,int,int)));
389             QObject::connect(model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
390                              this, SLOT(_q_sectionsRemoved(QModelIndex,int,int)));
391             QObject::connect(model, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
392                              this, SLOT(_q_layoutAboutToBeChanged()));
393         }
394         QObject::connect(model, SIGNAL(headerDataChanged(Qt::Orientation,int,int)),
395                          this, SLOT(headerDataChanged(Qt::Orientation,int,int)));
396         QObject::connect(model, SIGNAL(layoutAboutToBeChanged()),
397                          this, SLOT(_q_layoutAboutToBeChanged()));
398     }
399 
400     d->state = QHeaderViewPrivate::NoClear;
401     QAbstractItemView::setModel(model);
402     d->state = QHeaderViewPrivate::NoState;
403 
404     // Users want to set sizes and modes before the widget is shown.
405     // Thus, we have to initialize when the model is set,
406     // and not lazily like we do in the other views.
407     initializeSections();
408 }
409 
410 /*!
411     Returns the orientation of the header.
412 
413     \sa Qt::Orientation
414 */
415 
416 Qt::Orientation QHeaderView::orientation() const
417 {
418     Q_D(const QHeaderView);
419     return d->orientation;
420 }
421 
422 /*!
423     Returns the offset of the header: this is the header's left-most (or
424     top-most for vertical headers) visible pixel.
425 
426     \sa setOffset()
427 */
428 
429 int QHeaderView::offset() const
430 {
431     Q_D(const QHeaderView);
432     return d->offset;
433 }
434 
435 /*!
436     \fn void QHeaderView::setOffset(int offset)
437 
438     Sets the header's offset to \a offset.
439 
440     \sa offset(), length()
441 */
442 
443 void QHeaderView::setOffset(int newOffset)
444 {
445     Q_D(QHeaderView);
446     if (d->offset == (int)newOffset)
447         return;
448     int ndelta = d->offset - newOffset;
449     d->offset = newOffset;
450     if (d->orientation == Qt::Horizontal)
451         d->viewport->scroll(isRightToLeft() ? -ndelta : ndelta, 0);
452     else
453         d->viewport->scroll(0, ndelta);
454     if (d->state == QHeaderViewPrivate::ResizeSection && !d->preventCursorChangeInSetOffset) {
455         QPoint cursorPos = QCursor::pos();
456         if (d->orientation == Qt::Horizontal)
457             QCursor::setPos(cursorPos.x() + ndelta, cursorPos.y());
458         else
459             QCursor::setPos(cursorPos.x(), cursorPos.y() + ndelta);
460         d->firstPos += ndelta;
461         d->lastPos += ndelta;
462     }
463 }
464 
465 /*!
466     \since 4.2
467     Sets the offset to the start of the section at the given \a visualSectionNumber.
468     \a visualSectionNumber is the actual visible section when hiddenSections are
469     not considered. That is not always the same as visualIndex().
470 
471     \sa setOffset(), sectionPosition()
472 */
473 void QHeaderView::setOffsetToSectionPosition(int visualSectionNumber)
474 {
475     Q_D(QHeaderView);
476     if (visualSectionNumber > -1 && visualSectionNumber < d->sectionCount()) {
477         int position = d->headerSectionPosition(d->adjustedVisualIndex(visualSectionNumber));
478         setOffset(position);
479     }
480 }
481 
482 /*!
483     \since 4.2
484     Sets the offset to make the last section visible.
485 
486     \sa setOffset(), sectionPosition(), setOffsetToSectionPosition()
487 */
488 void QHeaderView::setOffsetToLastSection()
489 {
490     Q_D(const QHeaderView);
491     int size = (d->orientation == Qt::Horizontal ? viewport()->width() : viewport()->height());
492     int position = length() - size;
493     setOffset(position);
494 }
495 
496 /*!
497     Returns the length along the orientation of the header.
498 
499     \sa sizeHint(), setSectionResizeMode(), offset()
500 */
501 
502 int QHeaderView::length() const
503 {
504     Q_D(const QHeaderView);
505     d->executePostedLayout();
506     d->executePostedResize();
507     //Q_ASSERT(d->headerLength() == d->length);
508     return d->length;
509 }
510 
511 /*!
512     Returns a suitable size hint for this header.
513 
514     \sa sectionSizeHint()
515 */
516 
517 QSize QHeaderView::sizeHint() const
518 {
519     Q_D(const QHeaderView);
520     if (d->cachedSizeHint.isValid())
521         return d->cachedSizeHint;
522     d->cachedSizeHint = QSize(0, 0); //reinitialize the cached size hint
523     const int sectionCount = count();
524 
525     // get size hint for the first n sections
526     int i = 0;
527     for (int checked = 0; checked < 100 && i < sectionCount; ++i) {
528         if (isSectionHidden(i))
529             continue;
530         checked++;
531         QSize hint = sectionSizeFromContents(i);
532         d->cachedSizeHint = d->cachedSizeHint.expandedTo(hint);
533     }
534     // get size hint for the last n sections
535     i = qMax(i, sectionCount - 100 );
536     for (int j = sectionCount - 1, checked = 0; j >= i && checked < 100; --j) {
537         if (isSectionHidden(j))
538             continue;
539         checked++;
540         QSize hint = sectionSizeFromContents(j);
541         d->cachedSizeHint = d->cachedSizeHint.expandedTo(hint);
542     }
543     return d->cachedSizeHint;
544 }
545 
546 /*!
547     \reimp
548 */
549 
550 void QHeaderView::setVisible(bool v)
551 {
552     bool actualChange = (v != isVisible());
553     QAbstractItemView::setVisible(v);
554     if (actualChange) {
555         QAbstractScrollArea *parent = qobject_cast<QAbstractScrollArea*>(parentWidget());
556         if (parent)
557             parent->updateGeometry();
558     }
559 }
560 
561 
562 /*!
563     Returns a suitable size hint for the section specified by \a logicalIndex.
564 
565     \sa sizeHint(), defaultSectionSize(), minimumSectionSize(), maximumSectionSize()
566     Qt::SizeHintRole
567 */
568 
569 int QHeaderView::sectionSizeHint(int logicalIndex) const
570 {
571     Q_D(const QHeaderView);
572     if (isSectionHidden(logicalIndex))
573         return 0;
574     if (logicalIndex < 0 || logicalIndex >= count())
575         return -1;
576     QSize size;
577     QVariant value = d->model->headerData(logicalIndex, d->orientation, Qt::SizeHintRole);
578     if (value.isValid())
579         size = qvariant_cast<QSize>(value);
580     else
581         size = sectionSizeFromContents(logicalIndex);
582     int hint = d->orientation == Qt::Horizontal ? size.width() : size.height();
583     return qBound(minimumSectionSize(), hint, maximumSectionSize());
584 }
585 
586 /*!
587     Returns the visual index of the section that covers the given \a position
588     in the viewport.
589 
590     \sa logicalIndexAt()
591 */
592 
593 int QHeaderView::visualIndexAt(int position) const
594 {
595     Q_D(const QHeaderView);
596     int vposition = position;
597     d->executePostedLayout();
598     d->executePostedResize();
599     const int count = d->sectionCount();
600     if (count < 1)
601         return -1;
602 
603     if (d->reverse())
604         vposition = d->viewport->width() - vposition;
605     vposition += d->offset;
606 
607     if (vposition > d->length)
608         return -1;
609     int visual = d->headerVisualIndexAt(vposition);
610     if (visual < 0)
611         return -1;
612 
613     while (d->isVisualIndexHidden(visual)){
614         ++visual;
615         if (visual >= count)
616             return -1;
617     }
618     return visual;
619 }
620 
621 /*!
622     Returns the section that covers the given \a position in the viewport.
623 
624     \sa visualIndexAt(), isSectionHidden()
625 */
626 
627 int QHeaderView::logicalIndexAt(int position) const
628 {
629     const int visual = visualIndexAt(position);
630     if (visual > -1)
631         return logicalIndex(visual);
632     return -1;
633 }
634 
635 /*!
636     Returns the width (or height for vertical headers) of the given
637     \a logicalIndex.
638 
639     \sa length(), setSectionResizeMode(), defaultSectionSize()
640 */
641 
642 int QHeaderView::sectionSize(int logicalIndex) const
643 {
644     Q_D(const QHeaderView);
645     if (isSectionHidden(logicalIndex))
646         return 0;
647     if (logicalIndex < 0 || logicalIndex >= count())
648         return 0;
649     int visual = visualIndex(logicalIndex);
650     if (visual == -1)
651         return 0;
652     d->executePostedResize();
653     return d->headerSectionSize(visual);
654 }
655 
656 /*!
657 
658     Returns the section position of the given \a logicalIndex, or -1
659     if the section is hidden. The position is measured in pixels from
660     the first visible item's top-left corner to the top-left corner of
661     the item with \a logicalIndex. The measurement is along the x-axis
662     for horizontal headers and along the y-axis for vertical headers.
663 
664     \sa sectionViewportPosition()
665 */
666 
667 int QHeaderView::sectionPosition(int logicalIndex) const
668 {
669     Q_D(const QHeaderView);
670     int visual = visualIndex(logicalIndex);
671     // in some cases users may change the selections
672     // before we have a chance to do the layout
673     if (visual == -1)
674         return -1;
675     d->executePostedResize();
676     return d->headerSectionPosition(visual);
677 }
678 
679 /*!
680     Returns the section viewport position of the given \a logicalIndex.
681 
682     If the section is hidden, the return value is undefined.
683 
684     \sa sectionPosition(), isSectionHidden()
685 */
686 
687 int QHeaderView::sectionViewportPosition(int logicalIndex) const
688 {
689     Q_D(const QHeaderView);
690     if (logicalIndex >= count())
691         return -1;
692     int position = sectionPosition(logicalIndex);
693     if (position < 0)
694         return position; // the section was hidden
695     int offsetPosition = position - d->offset;
696     if (d->reverse())
697         return d->viewport->width() - (offsetPosition + sectionSize(logicalIndex));
698     return offsetPosition;
699 }
700 
701 /*!
702     \fn int QHeaderView::logicalIndexAt(int x, int y) const
703 
704     Returns the logical index of the section at the given coordinate. If the
705     header is horizontal \a x will be used, otherwise \a y will be used to
706     find the logical index.
707 */
708 
709 /*!
710     \fn int QHeaderView::logicalIndexAt(const QPoint &pos) const
711 
712     Returns the logical index of the section at the position given in \a pos.
713     If the header is horizontal the x-coordinate will be used, otherwise the
714     y-coordinate will be used to find the logical index.
715 
716     \sa sectionPosition()
717 */
718 
719 template<typename Container>
720 static void qMoveRange(Container& c,
721                typename Container::size_type rangeStart,
722                typename Container::size_type rangeEnd,
723                typename Container::size_type targetPosition)
724 {
725     Q_ASSERT(targetPosition <= c.size());
726     Q_ASSERT(targetPosition < rangeStart || targetPosition >= rangeEnd);
727 
728     const bool forwardMove = targetPosition > rangeStart;
729     typename Container::size_type first = std::min(rangeStart, targetPosition);
730     typename Container::size_type mid = forwardMove ? rangeEnd : rangeStart;
731     typename Container::size_type last = forwardMove ? targetPosition + 1 : rangeEnd;
732     std::rotate(c.begin() + first, c.begin() + mid, c.begin() + last);
733 }
734 
735 /*!
736     Moves the section at visual index \a from to occupy visual index \a to.
737 
738     \sa sectionsMoved()
739 */
740 
741 void QHeaderView::moveSection(int from, int to)
742 {
743     Q_D(QHeaderView);
744 
745     d->executePostedLayout();
746     if (from < 0 || from >= d->sectionCount() || to < 0 || to >= d->sectionCount())
747         return;
748 
749     if (from == to) {
750         int logical = logicalIndex(from);
751         Q_ASSERT(logical != -1);
752         updateSection(logical);
753         return;
754     }
755 
756     if (stretchLastSection() &&  to == d->lastVisibleVisualIndex())
757         d->lastSectionSize = sectionSize(from);
758 
759     d->initializeIndexMapping();
760 
761     int *visualIndices = d->visualIndices.data();
762     int *logicalIndices = d->logicalIndices.data();
763     int logical = logicalIndices[from];
764     int visual = from;
765 
766     if (to > from) {
767         while (visual < to) {
768             visualIndices[logicalIndices[visual + 1]] = visual;
769             logicalIndices[visual] = logicalIndices[visual + 1];
770             ++visual;
771         }
772     } else {
773         while (visual > to) {
774             visualIndices[logicalIndices[visual - 1]] = visual;
775             logicalIndices[visual] = logicalIndices[visual - 1];
776             --visual;
777         }
778     }
779     visualIndices[logical] = to;
780     logicalIndices[to] = logical;
781 
782     qMoveRange(d->sectionItems, from, from + 1, to);
783 
784     d->sectionStartposRecalc = true;
785 
786     if (d->hasAutoResizeSections())
787         d->doDelayedResizeSections();
788     d->viewport->update();
789 
790     emit sectionMoved(logical, from, to);
791 }
792 
793 /*!
794     \since 4.2
795     Swaps the section at visual index \a first with the section at visual
796     index \a second.
797 
798     \sa moveSection()
799 */
800 void QHeaderView::swapSections(int first, int second)
801 {
802     Q_D(QHeaderView);
803 
804     if (first == second)
805         return;
806     d->executePostedLayout();
807     if (first < 0 || first >= d->sectionCount() || second < 0 || second >= d->sectionCount())
808         return;
809 
810     int firstSize = d->headerSectionSize(first);
811     ResizeMode firstMode = d->headerSectionResizeMode(first);
812     int firstLogical = d->logicalIndex(first);
813 
814     int secondSize = d->headerSectionSize(second);
815     ResizeMode secondMode = d->headerSectionResizeMode(second);
816     int secondLogical = d->logicalIndex(second);
817 
818     if (d->state == QHeaderViewPrivate::ResizeSection)
819         d->preventCursorChangeInSetOffset = true;
820 
821     d->createSectionItems(second, second, firstSize, firstMode);
822     d->createSectionItems(first, first, secondSize, secondMode);
823 
824     d->initializeIndexMapping();
825 
826     d->visualIndices[firstLogical] = second;
827     d->logicalIndices[second] = firstLogical;
828 
829     d->visualIndices[secondLogical] = first;
830     d->logicalIndices[first] = secondLogical;
831 
832     if (!d->hiddenSectionSize.isEmpty()) {
833         bool firstHidden = d->isVisualIndexHidden(first);
834         bool secondHidden = d->isVisualIndexHidden(second);
835         d->setVisualIndexHidden(first, secondHidden);
836         d->setVisualIndexHidden(second, firstHidden);
837     }
838 
839     d->viewport->update();
840     emit sectionMoved(firstLogical, first, second);
841     emit sectionMoved(secondLogical, second, first);
842 }
843 
844 /*!
845     \fn void QHeaderView::resizeSection(int logicalIndex, int size)
846 
847     Resizes the section specified by \a logicalIndex to \a size measured in
848     pixels. The size parameter must be a value larger or equal to zero. A
849     size equal to zero is however not recommended. In that situation hideSection
850     should be used instead.
851 
852     \sa sectionResized(), resizeMode(), sectionSize(), hideSection()
853 */
854 
855 void QHeaderView::resizeSection(int logical, int size)
856 {
857     Q_D(QHeaderView);
858     if (logical < 0 || logical >= count() || size < 0 || size > maxSizeSection)
859         return;
860 
861     if (isSectionHidden(logical)) {
862         d->hiddenSectionSize.insert(logical, size);
863         return;
864     }
865 
866     int visual = visualIndex(logical);
867     if (visual == -1)
868         return;
869 
870     if (d->state == QHeaderViewPrivate::ResizeSection && !d->cascadingResizing && logical != d->section)
871         d->preventCursorChangeInSetOffset = true;
872 
873     int oldSize = d->headerSectionSize(visual);
874     if (oldSize == size)
875         return;
876 
877     d->executePostedLayout();
878     d->invalidateCachedSizeHint();
879 
880     if (stretchLastSection() && visual == d->lastVisibleVisualIndex())
881         d->lastSectionSize = size;
882 
883     d->createSectionItems(visual, visual, size, d->headerSectionResizeMode(visual));
884 
885     if (!updatesEnabled()) {
886         if (d->hasAutoResizeSections())
887             d->doDelayedResizeSections();
888         emit sectionResized(logical, oldSize, size);
889         return;
890     }
891 
892     int w = d->viewport->width();
893     int h = d->viewport->height();
894     int pos = sectionViewportPosition(logical);
895     QRect r;
896     if (d->orientation == Qt::Horizontal)
897         if (isRightToLeft())
898             r.setRect(0, 0, pos + size, h);
899         else
900             r.setRect(pos, 0, w - pos, h);
901     else
902         r.setRect(0, pos, w, h - pos);
903 
904     if (d->hasAutoResizeSections()) {
905         d->doDelayedResizeSections();
906         r = d->viewport->rect();
907     }
908 
909     // If the parent is a QAbstractScrollArea with QAbstractScrollArea::AdjustToContents
910     // then we want to change the geometry on that widget. Not doing it at once can/will
911     // cause scrollbars flicker as they would be shown at first but then removed.
912     // In the same situation it will also allow shrinking the whole view when stretchLastSection is set
913     // (It is default on QTreeViews - and it wouldn't shrink since the last stretch was made before the
914     // viewport was resized)
915 
916     QAbstractScrollArea *parent = qobject_cast<QAbstractScrollArea *>(parentWidget());
917     if (parent && parent->sizeAdjustPolicy() == QAbstractScrollArea::AdjustToContents)
918         parent->updateGeometry();
919 
920     d->viewport->update(r.normalized());
921     emit sectionResized(logical, oldSize, size);
922 }
923 
924 /*!
925     Resizes the sections according to the given \a mode, ignoring the current
926     resize mode.
927 
928     \sa resizeMode(), sectionResized()
929 */
930 
931 void QHeaderView::resizeSections(QHeaderView::ResizeMode mode)
932 {
933     Q_D(QHeaderView);
934     d->resizeSections(mode, true);
935 }
936 
937 /*!
938     \fn void QHeaderView::hideSection(int logicalIndex)
939     Hides the section specified by \a logicalIndex.
940 
941     \sa showSection(), isSectionHidden(), hiddenSectionCount(),
942     setSectionHidden()
943 */
944 
945 /*!
946     \fn void QHeaderView::showSection(int logicalIndex)
947     Shows the section specified by \a logicalIndex.
948 
949     \sa hideSection(), isSectionHidden(), hiddenSectionCount(),
950     setSectionHidden()
951 */
952 
953 /*!
954     Returns \c true if the section specified by \a logicalIndex is explicitly
955     hidden from the user; otherwise returns \c false.
956 
957     \sa hideSection(), showSection(), setSectionHidden(), hiddenSectionCount()
958 */
959 
960 bool QHeaderView::isSectionHidden(int logicalIndex) const
961 {
962     Q_D(const QHeaderView);
963     d->executePostedLayout();
964     if (d->hiddenSectionSize.isEmpty() || logicalIndex < 0 || logicalIndex >= d->sectionCount())
965         return false;
966     int visual = visualIndex(logicalIndex);
967     Q_ASSERT(visual != -1);
968     return d->isVisualIndexHidden(visual);
969 }
970 
971 /*!
972     \since 4.1
973 
974     Returns the number of sections in the header that has been hidden.
975 
976     \sa setSectionHidden(), isSectionHidden()
977 */
978 int QHeaderView::hiddenSectionCount() const
979 {
980     Q_D(const QHeaderView);
981     return d->hiddenSectionSize.count();
982 }
983 
984 /*!
985   If \a hide is true the section specified by \a logicalIndex is hidden;
986   otherwise the section is shown.
987 
988   \sa isSectionHidden(), hiddenSectionCount()
989 */
990 
991 void QHeaderView::setSectionHidden(int logicalIndex, bool hide)
992 {
993     Q_D(QHeaderView);
994     if (logicalIndex < 0 || logicalIndex >= count())
995         return;
996 
997     d->executePostedLayout();
998     int visual = visualIndex(logicalIndex);
999     Q_ASSERT(visual != -1);
1000     if (hide == d->isVisualIndexHidden(visual))
1001         return;
1002     if (hide) {
1003         int size = d->headerSectionSize(visual);
1004         if (!d->hasAutoResizeSections())
1005             resizeSection(logicalIndex, 0);
1006         d->hiddenSectionSize.insert(logicalIndex, size);
1007         d->setVisualIndexHidden(visual, true);
1008         if (d->hasAutoResizeSections())
1009             d->doDelayedResizeSections();
1010     } else {
1011         int size = d->hiddenSectionSize.value(logicalIndex, d->defaultSectionSize);
1012         d->hiddenSectionSize.remove(logicalIndex);
1013         d->setVisualIndexHidden(visual, false);
1014         resizeSection(logicalIndex, size);
1015     }
1016 }
1017 
1018 /*!
1019     Returns the number of sections in the header.
1020 
1021     \sa sectionCountChanged(), length()
1022 */
1023 
1024 int QHeaderView::count() const
1025 {
1026     Q_D(const QHeaderView);
1027     //Q_ASSERT(d->sectionCount == d->headerSectionCount());
1028     // ### this may affect the lazy layout
1029     d->executePostedLayout();
1030     return d->modelSectionCount();
1031 }
1032 
1033 /*!
1034     Returns the visual index position of the section specified by the given
1035     \a logicalIndex, or -1 otherwise.
1036 
1037     Hidden sections still have valid visual indexes.
1038 
1039     \sa logicalIndex()
1040 */
1041 
1042 int QHeaderView::visualIndex(int logicalIndex) const
1043 {
1044     Q_D(const QHeaderView);
1045     if (logicalIndex < 0)
1046         return -1;
1047     d->executePostedLayout();
1048     if (d->visualIndices.isEmpty()) { // nothing has been moved, so we have no mapping
1049         if (logicalIndex < d->sectionCount())
1050             return logicalIndex;
1051     } else if (logicalIndex < d->visualIndices.count()) {
1052         int visual = d->visualIndices.at(logicalIndex);
1053         Q_ASSERT(visual < d->sectionCount());
1054         return visual;
1055     }
1056     return -1;
1057 }
1058 
1059 /*!
1060     Returns the logicalIndex for the section at the given \a visualIndex
1061     position, or -1 if visualIndex < 0 or visualIndex >= QHeaderView::count().
1062 
1063     Note that the visualIndex is not affected by hidden sections.
1064 
1065     \sa visualIndex(), sectionPosition()
1066 */
1067 
1068 int QHeaderView::logicalIndex(int visualIndex) const
1069 {
1070     Q_D(const QHeaderView);
1071     if (visualIndex < 0 || visualIndex >= d->sectionCount())
1072         return -1;
1073     return d->logicalIndex(visualIndex);
1074 }
1075 
1076 /*!
1077     \since 5.0
1078 
1079     If \a movable is true, the header may be moved by the user; otherwise it
1080     is fixed in place.
1081 
1082     \sa sectionsMovable(), sectionMoved()
1083 */
1084 
1085 void QHeaderView::setSectionsMovable(bool movable)
1086 {
1087     Q_D(QHeaderView);
1088     d->movableSections = movable;
1089 }
1090 
1091 // ### Qt 6 - remove this obsolete function
1092 /*!
1093     \obsolete
1094     \fn void QHeaderView::setMovable(bool movable)
1095 
1096     Use setSectionsMovable instead.
1097 
1098     \sa setSectionsMovable()
1099 */
1100 
1101 /*!
1102     \since 5.0
1103 
1104     Returns \c true if the header can be moved by the user; otherwise returns
1105     false.
1106 
1107     \sa setSectionsMovable()
1108 */
1109 
1110 bool QHeaderView::sectionsMovable() const
1111 {
1112     Q_D(const QHeaderView);
1113     return d->movableSections;
1114 }
1115 
1116 // ### Qt 6 - remove this obsolete function
1117 /*!
1118     \obsolete
1119     \fn bool QHeaderView::isMovable() const
1120 
1121     Use sectionsMovable instead.
1122 
1123     \sa sectionsMovable()
1124 */
1125 
1126 /*!
1127     \since 5.0
1128 
1129     If \a clickable is true, the header will respond to single clicks.
1130 
1131     \sa sectionsClickable(), sectionClicked(), sectionPressed(),
1132     setSortIndicatorShown()
1133 */
1134 
1135 void QHeaderView::setSectionsClickable(bool clickable)
1136 {
1137     Q_D(QHeaderView);
1138     d->clickableSections = clickable;
1139 }
1140 
1141 // ### Qt 6 - remove this obsolete function
1142 /*!
1143     \obsolete
1144     \fn void QHeaderView::setClickable(bool clickable)
1145 
1146     Use setSectionsClickable instead.
1147 
1148     \sa setSectionsClickable()
1149 */
1150 
1151 /*!
1152     \since 5.0
1153 
1154     Returns \c true if the header is clickable; otherwise returns \c false. A
1155     clickable header could be set up to allow the user to change the
1156     representation of the data in the view related to the header.
1157 
1158     \sa setSectionsClickable()
1159 */
1160 
1161 bool QHeaderView::sectionsClickable() const
1162 {
1163     Q_D(const QHeaderView);
1164     return d->clickableSections;
1165 }
1166 
1167 // ### Qt 6 - remove this obsolete function
1168 /*!
1169     \obsolete
1170     \fn bool QHeaderView::isClickable() const
1171 
1172     Use sectionsClickable instead.
1173 
1174     \sa sectionsClickable()
1175 */
1176 
1177 void QHeaderView::setHighlightSections(bool highlight)
1178 {
1179     Q_D(QHeaderView);
1180     d->highlightSelected = highlight;
1181 }
1182 
1183 bool QHeaderView::highlightSections() const
1184 {
1185     Q_D(const QHeaderView);
1186     return d->highlightSelected;
1187 }
1188 
1189 /*!
1190     \since 5.0
1191 
1192     Sets the constraints on how the header can be resized to those described
1193     by the given \a mode.
1194 
1195     \sa resizeMode(), length(), sectionResized()
1196 */
1197 
1198 void QHeaderView::setSectionResizeMode(ResizeMode mode)
1199 {
1200     Q_D(QHeaderView);
1201     initializeSections();
1202     d->stretchSections = (mode == Stretch ? count() : 0);
1203     d->contentsSections =  (mode == ResizeToContents ? count() : 0);
1204     d->setGlobalHeaderResizeMode(mode);
1205     if (d->hasAutoResizeSections())
1206         d->doDelayedResizeSections(); // section sizes may change as a result of the new mode
1207 }
1208 
1209 /*!
1210     \since 5.0
1211 
1212     Sets the constraints on how the section specified by \a logicalIndex in
1213     the header can be resized to those described by the given \a mode. The logical
1214     index should exist at the time this function is called.
1215 
1216     \note This setting will be ignored for the last section if the stretchLastSection
1217     property is set to true. This is the default for the horizontal headers provided
1218     by QTreeView.
1219 
1220     \sa setStretchLastSection(), resizeContentsPrecision()
1221 */
1222 
1223 void QHeaderView::setSectionResizeMode(int logicalIndex, ResizeMode mode)
1224 {
1225     Q_D(QHeaderView);
1226     int visual = visualIndex(logicalIndex);
1227     Q_ASSERT(visual != -1);
1228 
1229     ResizeMode old = d->headerSectionResizeMode(visual);
1230     d->setHeaderSectionResizeMode(visual, mode);
1231 
1232     if (mode == Stretch && old != Stretch)
1233         ++d->stretchSections;
1234     else if (mode == ResizeToContents && old != ResizeToContents)
1235         ++d->contentsSections;
1236     else if (mode != Stretch && old == Stretch)
1237         --d->stretchSections;
1238     else if (mode != ResizeToContents && old == ResizeToContents)
1239         --d->contentsSections;
1240 
1241     if (d->hasAutoResizeSections() && d->state == QHeaderViewPrivate::NoState)
1242         d->doDelayedResizeSections(); // section sizes may change as a result of the new mode
1243 }
1244 
1245 // ### Qt 6 - remove this obsolete function
1246 /*!
1247     \overload
1248     \obsolete
1249     \fn void QHeaderView::setResizeMode(int logicalIndex, ResizeMode mode)
1250 
1251     Use setSectionResizeMode instead.
1252 
1253     \sa setSectionResizeMode()
1254 */
1255 
1256 /*!
1257     \obsolete
1258     \fn void QHeaderView::setResizeMode(ResizeMode mode)
1259 
1260     Use setSectionResizeMode instead.
1261 
1262     \sa setSectionResizeMode()
1263 */
1264 
1265 /*!
1266     \since 5.0
1267 
1268     Returns the resize mode that applies to the section specified by the given
1269     \a logicalIndex.
1270 
1271     \sa setSectionResizeMode()
1272 */
1273 
1274 QHeaderView::ResizeMode QHeaderView::sectionResizeMode(int logicalIndex) const
1275 {
1276     Q_D(const QHeaderView);
1277     int visual = visualIndex(logicalIndex);
1278     if (visual == -1)
1279         return Fixed; //the default value
1280     return d->headerSectionResizeMode(visual);
1281 }
1282 
1283 /*!
1284    \since 5.2
1285    Sets how precise QHeaderView should calculate the size when ResizeToContents is used.
1286    A low value will provide a less accurate but fast auto resize while a higher
1287    value will provide a more accurate resize that however can be slow.
1288 
1289    The number \a precision specifies how many sections that should be consider
1290    when calculating the preferred size.
1291 
1292    The default value is 1000 meaning that a horizontal column with auto-resize will look
1293    at maximum 1000 rows on calculating when doing an auto resize.
1294 
1295    Special value 0 means that it will look at only the visible area.
1296    Special value -1 will imply looking at all elements.
1297 
1298    This value is used in QTableView::sizeHintForColumn(), QTableView::sizeHintForRow()
1299    and QTreeView::sizeHintForColumn(). Reimplementing these functions can make this
1300    function not having an effect.
1301 
1302     \sa resizeContentsPrecision(), setSectionResizeMode(), resizeSections(), QTableView::sizeHintForColumn(), QTableView::sizeHintForRow(), QTreeView::sizeHintForColumn()
1303 */
1304 
1305 void QHeaderView::setResizeContentsPrecision(int precision)
1306 {
1307     Q_D(QHeaderView);
1308     d->resizeContentsPrecision = precision;
1309 }
1310 
1311 /*!
1312   \since 5.2
1313   Returns how precise QHeaderView will calculate on ResizeToContents.
1314 
1315   \sa setResizeContentsPrecision(), setSectionResizeMode()
1316 
1317 */
1318 
1319 int QHeaderView::resizeContentsPrecision() const
1320 {
1321     Q_D(const QHeaderView);
1322     return d->resizeContentsPrecision;
1323 }
1324 
1325 // ### Qt 6 - remove this obsolete function
1326 /*!
1327     \obsolete
1328     \fn QHeaderView::ResizeMode QHeaderView::resizeMode(int logicalIndex) const
1329 
1330     Use sectionResizeMode instead.
1331 
1332     \sa sectionResizeMode()
1333 */
1334 
1335 /*!
1336     \since 4.1
1337 
1338     Returns the number of sections that are set to resize mode stretch. In
1339     views, this can be used to see if the headerview needs to resize the
1340     sections when the view's geometry changes.
1341 
1342     \sa stretchLastSection, resizeMode()
1343 */
1344 
1345 int QHeaderView::stretchSectionCount() const
1346 {
1347     Q_D(const QHeaderView);
1348     return d->stretchSections;
1349 }
1350 
1351 /*!
1352   \property QHeaderView::showSortIndicator
1353   \brief whether the sort indicator is shown
1354 
1355   By default, this property is \c false.
1356 
1357   \sa setSectionsClickable()
1358 */
1359 
1360 void QHeaderView::setSortIndicatorShown(bool show)
1361 {
1362     Q_D(QHeaderView);
1363     if (d->sortIndicatorShown == show)
1364         return;
1365 
1366     d->sortIndicatorShown = show;
1367 
1368     if (sortIndicatorSection() < 0 || sortIndicatorSection() > count())
1369         return;
1370 
1371     if (d->headerSectionResizeMode(sortIndicatorSection()) == ResizeToContents)
1372         resizeSections();
1373 
1374     d->viewport->update();
1375 }
1376 
1377 bool QHeaderView::isSortIndicatorShown() const
1378 {
1379     Q_D(const QHeaderView);
1380     return d->sortIndicatorShown;
1381 }
1382 
1383 /*!
1384     Sets the sort indicator for the section specified by the given
1385     \a logicalIndex in the direction specified by \a order, and removes the
1386     sort indicator from any other section that was showing it.
1387 
1388     \a logicalIndex may be -1, in which case no sort indicator will be shown
1389     and the model will return to its natural, unsorted order. Note that not
1390     all models support this and may even crash in this case.
1391 
1392     \sa sortIndicatorSection(), sortIndicatorOrder()
1393 */
1394 
1395 void QHeaderView::setSortIndicator(int logicalIndex, Qt::SortOrder order)
1396 {
1397     Q_D(QHeaderView);
1398 
1399     // This is so that people can set the position of the sort indicator before the fill the model
1400     int old = d->sortIndicatorSection;
1401     if (old == logicalIndex && order == d->sortIndicatorOrder)
1402         return;
1403     d->sortIndicatorSection = logicalIndex;
1404     d->sortIndicatorOrder = order;
1405 
1406     if (logicalIndex >= d->sectionCount()) {
1407         emit sortIndicatorChanged(logicalIndex, order);
1408         return; // nothing to do
1409     }
1410 
1411     if (old != logicalIndex
1412         && ((logicalIndex >= 0 && sectionResizeMode(logicalIndex) == ResizeToContents)
1413             || old >= d->sectionCount() || (old >= 0 && sectionResizeMode(old) == ResizeToContents))) {
1414         resizeSections();
1415         d->viewport->update();
1416     } else {
1417         if (old >= 0 && old != logicalIndex)
1418             updateSection(old);
1419         if (logicalIndex >= 0)
1420             updateSection(logicalIndex);
1421     }
1422 
1423     emit sortIndicatorChanged(logicalIndex, order);
1424 }
1425 
1426 /*!
1427     Returns the logical index of the section that has a sort indicator.
1428     By default this is section 0.
1429 
1430     \sa setSortIndicator(), sortIndicatorOrder(), setSortIndicatorShown()
1431 */
1432 
1433 int QHeaderView::sortIndicatorSection() const
1434 {
1435     Q_D(const QHeaderView);
1436     return d->sortIndicatorSection;
1437 }
1438 
1439 /*!
1440     Returns the order for the sort indicator. If no section has a sort
1441     indicator the return value of this function is undefined.
1442 
1443     \sa setSortIndicator(), sortIndicatorSection()
1444 */
1445 
1446 Qt::SortOrder QHeaderView::sortIndicatorOrder() const
1447 {
1448     Q_D(const QHeaderView);
1449     return d->sortIndicatorOrder;
1450 }
1451 
1452 /*!
1453     \property QHeaderView::stretchLastSection
1454     \brief whether the last visible section in the header takes up all the
1455     available space
1456 
1457     The default value is false.
1458 
1459     \note The horizontal headers provided by QTreeView are configured with this
1460     property set to true, ensuring that the view does not waste any of the
1461     space assigned to it for its header. If this value is set to true, this
1462     property will override the resize mode set on the last section in the
1463     header.
1464 
1465     \sa setSectionResizeMode()
1466 */
1467 bool QHeaderView::stretchLastSection() const
1468 {
1469     Q_D(const QHeaderView);
1470     return d->stretchLastSection;
1471 }
1472 
1473 void QHeaderView::setStretchLastSection(bool stretch)
1474 {
1475     Q_D(QHeaderView);
1476     if (d->stretchLastSection == stretch)
1477         return;
1478     d->stretchLastSection = stretch;
1479     if (d->state != QHeaderViewPrivate::NoState)
1480         return;
1481     if (stretch)
1482         resizeSections();
1483     else if (count())
1484         resizeSection(count() - 1, d->defaultSectionSize);
1485 }
1486 
1487 /*!
1488     \since 4.2
1489     \property QHeaderView::cascadingSectionResizes
1490     \brief whether interactive resizing will be cascaded to the following
1491     sections once the section being resized by the user has reached its
1492     minimum size
1493 
1494     This property only affects sections that have \l Interactive as their
1495     resize mode.
1496 
1497     The default value is false.
1498 
1499     \sa setSectionResizeMode()
1500 */
1501 bool QHeaderView::cascadingSectionResizes() const
1502 {
1503     Q_D(const QHeaderView);
1504     return d->cascadingResizing;
1505 }
1506 
1507 void QHeaderView::setCascadingSectionResizes(bool enable)
1508 {
1509     Q_D(QHeaderView);
1510     d->cascadingResizing = enable;
1511 }
1512 
1513 /*!
1514     \property QHeaderView::defaultSectionSize
1515     \brief the default size of the header sections before resizing.
1516 
1517     This property only affects sections that have \l Interactive or \l Fixed
1518     as their resize mode.
1519 
1520     By default, the value of this property is style dependent.
1521     Thus, when the style changes, this property updates from it.
1522     Calling setDefaultSectionSize() stops the updates, calling
1523     resetDefaultSectionSize() will restore default behavior.
1524 
1525     \sa setSectionResizeMode(), minimumSectionSize
1526 */
1527 int QHeaderView::defaultSectionSize() const
1528 {
1529     Q_D(const QHeaderView);
1530     return d->defaultSectionSize;
1531 }
1532 
1533 void QHeaderView::setDefaultSectionSize(int size)
1534 {
1535     Q_D(QHeaderView);
1536     if (size < 0 || size > maxSizeSection)
1537         return;
1538     d->setDefaultSectionSize(size);
1539 }
1540 
1541 void QHeaderView::resetDefaultSectionSize()
1542 {
1543     Q_D(QHeaderView);
1544     if (d->customDefaultSectionSize) {
1545         d->updateDefaultSectionSizeFromStyle();
1546         d->customDefaultSectionSize = false;
1547     }
1548 }
1549 
1550 /*!
1551     \since 4.2
1552     \property QHeaderView::minimumSectionSize
1553     \brief the minimum size of the header sections.
1554 
1555     The minimum section size is the smallest section size allowed. If the
1556     minimum section size is set to -1, QHeaderView will use the maximum of
1557     the \l{QApplication::globalStrut()}{global strut} or the
1558     \l{fontMetrics()}{font metrics} size.
1559 
1560     This property is honored by all \l{ResizeMode}{resize modes}.
1561 
1562     \sa setSectionResizeMode(), defaultSectionSize
1563 */
1564 int QHeaderView::minimumSectionSize() const
1565 {
1566     Q_D(const QHeaderView);
1567     if (d->minimumSectionSize == -1) {
1568         QSize strut = QApplication::globalStrut();
1569         int margin = 2 * style()->pixelMetric(QStyle::PM_HeaderMargin, 0, this);
1570         if (d->orientation == Qt::Horizontal)
1571             return qMax(strut.width(), (fontMetrics().maxWidth() + margin));
1572         return qMax(strut.height(), (fontMetrics().height() + margin));
1573     }
1574     return d->minimumSectionSize;
1575 }
1576 
1577 void QHeaderView::setMinimumSectionSize(int size)
1578 {
1579     Q_D(QHeaderView);
1580     if (size < -1 || size > maxSizeSection)
1581         return;
1582     d->minimumSectionSize = size;
1583     if (d->minimumSectionSize > maximumSectionSize())
1584         d->maximumSectionSize = size;
1585 }
1586 
1587 /*!
1588     \since 5.2
1589     \property QHeaderView::maximumSectionSize
1590     \brief the maximum size of the header sections.
1591 
1592     The maximum section size is the largest section size allowed.
1593     The default value for this property is 1048575, which is also the largest
1594     possible size for a section. Setting maximum to -1 will reset the value to
1595     the largest section size.
1596 
1597     With exception of stretch this property is honored by all \l{ResizeMode}{resize modes}
1598 
1599     \sa setSectionResizeMode(), defaultSectionSize
1600 */
1601 int QHeaderView::maximumSectionSize() const
1602 {
1603     Q_D(const QHeaderView);
1604     if (d->maximumSectionSize == -1)
1605         return maxSizeSection;
1606     return d->maximumSectionSize;
1607 }
1608 
1609 void QHeaderView::setMaximumSectionSize(int size)
1610 {
1611     Q_D(QHeaderView);
1612     if (size == -1) {
1613         d->maximumSectionSize = maxSizeSection;
1614         return;
1615     }
1616     if (size < 0 || size > maxSizeSection)
1617         return;
1618     if (minimumSectionSize() > size)
1619         d->minimumSectionSize = size;
1620 
1621     d->maximumSectionSize = size;
1622 }
1623 
1624 
1625 /*!
1626     \since 4.1
1627     \property QHeaderView::defaultAlignment
1628     \brief the default alignment of the text in each header section
1629 */
1630 
1631 Qt::Alignment QHeaderView::defaultAlignment() const
1632 {
1633     Q_D(const QHeaderView);
1634     return d->defaultAlignment;
1635 }
1636 
1637 void QHeaderView::setDefaultAlignment(Qt::Alignment alignment)
1638 {
1639     Q_D(QHeaderView);
1640     if (d->defaultAlignment == alignment)
1641         return;
1642 
1643     d->defaultAlignment = alignment;
1644     d->viewport->update();
1645 }
1646 
1647 /*!
1648     \internal
1649 */
1650 void QHeaderView::doItemsLayout()
1651 {
1652     initializeSections();
1653     QAbstractItemView::doItemsLayout();
1654 }
1655 
1656 /*!
1657     Returns \c true if sections in the header has been moved; otherwise returns
1658     false;
1659 
1660     \sa moveSection()
1661 */
1662 bool QHeaderView::sectionsMoved() const
1663 {
1664     Q_D(const QHeaderView);
1665     return !d->visualIndices.isEmpty();
1666 }
1667 
1668 /*!
1669     \since 4.1
1670 
1671     Returns \c true if sections in the header has been hidden; otherwise returns
1672     false;
1673 
1674     \sa setSectionHidden()
1675 */
1676 bool QHeaderView::sectionsHidden() const
1677 {
1678     Q_D(const QHeaderView);
1679     return !d->hiddenSectionSize.isEmpty();
1680 }
1681 
1682 #ifndef QT_NO_DATASTREAM
1683 /*!
1684     \since 4.3
1685 
1686     Saves the current state of this header view.
1687 
1688     To restore the saved state, pass the return value to restoreState().
1689 
1690     \sa restoreState()
1691 */
1692 QByteArray QHeaderView::saveState() const
1693 {
1694     Q_D(const QHeaderView);
1695     QByteArray data;
1696     QDataStream stream(&data, QIODevice::WriteOnly);
1697     stream << QHeaderViewPrivate::VersionMarker;
1698     stream << 0; // current version is 0
1699     d->write(stream);
1700     return data;
1701 }
1702 
1703 /*!
1704     \since 4.3
1705     Restores the \a state of this header view.
1706     This function returns \c true if the state was restored; otherwise returns
1707     false.
1708 
1709     \sa saveState()
1710 */
1711 bool QHeaderView::restoreState(const QByteArray &state)
1712 {
1713     Q_D(QHeaderView);
1714     if (state.isEmpty())
1715         return false;
1716     QByteArray data = state;
1717     QDataStream stream(&data, QIODevice::ReadOnly);
1718     int marker;
1719     int ver;
1720     stream >> marker;
1721     stream >> ver;
1722     if (stream.status() != QDataStream::Ok
1723         || marker != QHeaderViewPrivate::VersionMarker
1724         || ver != 0) // current version is 0
1725         return false;
1726 
1727     if (d->read(stream)) {
1728         emit sortIndicatorChanged(d->sortIndicatorSection, d->sortIndicatorOrder );
1729         d->viewport->update();
1730         return true;
1731     }
1732     return false;
1733 }
1734 #endif // QT_NO_DATASTREAM
1735 
1736 /*!
1737   \reimp
1738 */
1739 void QHeaderView::reset()
1740 {
1741     QAbstractItemView::reset();
1742     // it would be correct to call clear, but some apps rely
1743     // on the header keeping the sections, even after calling reset
1744     //d->clear();
1745     initializeSections();
1746 }
1747 
1748 /*!
1749     Updates the changed header sections with the given \a orientation, from
1750     \a logicalFirst to \a logicalLast inclusive.
1751 */
1752 void QHeaderView::headerDataChanged(Qt::Orientation orientation, int logicalFirst, int logicalLast)
1753 {
1754     Q_D(QHeaderView);
1755     if (d->orientation != orientation)
1756         return;
1757 
1758     if (logicalFirst < 0 || logicalLast < 0 || logicalFirst >= count() || logicalLast >= count())
1759         return;
1760 
1761     d->invalidateCachedSizeHint();
1762 
1763     int firstVisualIndex = INT_MAX, lastVisualIndex = -1;
1764 
1765     for (int section = logicalFirst; section <= logicalLast; ++section) {
1766         const int visual = visualIndex(section);
1767         firstVisualIndex = qMin(firstVisualIndex, visual);
1768         lastVisualIndex =  qMax(lastVisualIndex,  visual);
1769     }
1770 
1771     d->executePostedResize();
1772     const int first = d->headerSectionPosition(firstVisualIndex),
1773               last = d->headerSectionPosition(lastVisualIndex)
1774                         + d->headerSectionSize(lastVisualIndex);
1775 
1776     if (orientation == Qt::Horizontal) {
1777         d->viewport->update(first, 0, last - first, d->viewport->height());
1778     } else {
1779         d->viewport->update(0, first, d->viewport->width(), last - first);
1780     }
1781 }
1782 
1783 /*!
1784     \internal
1785     \since 4.2
1786 
1787     Updates the section specified by the given \a logicalIndex.
1788 */
1789 
1790 void QHeaderView::updateSection(int logicalIndex)
1791 {
1792     Q_D(QHeaderView);
1793     if (d->orientation == Qt::Horizontal)
1794         d->viewport->update(QRect(sectionViewportPosition(logicalIndex),
1795                                   0, sectionSize(logicalIndex), d->viewport->height()));
1796     else
1797         d->viewport->update(QRect(0, sectionViewportPosition(logicalIndex),
1798                                   d->viewport->width(), sectionSize(logicalIndex)));
1799 }
1800 
1801 /*!
1802     Resizes the sections according to their size hints. Normally, you do not
1803     have to call this function.
1804 */
1805 
1806 void QHeaderView::resizeSections()
1807 {
1808     Q_D(QHeaderView);
1809     if (d->hasAutoResizeSections())
1810         d->resizeSections(Interactive, false); // no global resize mode
1811 }
1812 
1813 /*!
1814     This slot is called when sections are inserted into the \a parent.
1815     \a logicalFirst and \a logicalLast indices signify where the new sections
1816     were inserted.
1817 
1818     If only one section is inserted, \a logicalFirst and \a logicalLast will
1819     be the same.
1820 */
1821 
1822 void QHeaderView::sectionsInserted(const QModelIndex &parent,
1823                                    int logicalFirst, int logicalLast)
1824 {
1825     Q_D(QHeaderView);
1826     if (parent != d->root)
1827         return; // we only handle changes in the root level
1828     int oldCount = d->sectionCount();
1829 
1830     d->invalidateCachedSizeHint();
1831 
1832     if (d->state == QHeaderViewPrivate::ResizeSection)
1833         d->preventCursorChangeInSetOffset = true;
1834 
1835     // add the new sections
1836     int insertAt = logicalFirst;
1837     int insertCount = logicalLast - logicalFirst + 1;
1838 
1839     QHeaderViewPrivate::SectionItem section(d->defaultSectionSize, d->globalResizeMode);
1840     d->sectionStartposRecalc = true;
1841 
1842     if (d->sectionItems.isEmpty() || insertAt >= d->sectionItems.count()) {
1843         int insertLength = d->defaultSectionSize * insertCount;
1844         d->length += insertLength;
1845         d->sectionItems.insert(d->sectionItems.count(), insertCount, section); // append
1846     } else {
1847         // separate them out into their own sections
1848         int insertLength = d->defaultSectionSize * insertCount;
1849         d->length += insertLength;
1850         d->sectionItems.insert(insertAt, insertCount, section);
1851     }
1852 
1853     // update sorting column
1854     if (d->sortIndicatorSection >= logicalFirst)
1855         d->sortIndicatorSection += insertCount;
1856 
1857     // update resize mode section counts
1858     if (d->globalResizeMode == Stretch)
1859         d->stretchSections = d->sectionCount();
1860     else if (d->globalResizeMode == ResizeToContents)
1861         d->contentsSections = d->sectionCount();
1862 
1863     // clear selection cache
1864     d->sectionSelected.clear();
1865 
1866     // update mapping
1867     if (!d->visualIndices.isEmpty() && !d->logicalIndices.isEmpty()) {
1868         Q_ASSERT(d->visualIndices.count() == d->logicalIndices.count());
1869         int mappingCount = d->visualIndices.count();
1870         for (int i = 0; i < mappingCount; ++i) {
1871             if (d->visualIndices.at(i) >= logicalFirst)
1872                d->visualIndices[i] += insertCount;
1873             if (d->logicalIndices.at(i) >= logicalFirst)
1874                 d->logicalIndices[i] += insertCount;
1875         }
1876         for (int j = logicalFirst; j <= logicalLast; ++j) {
1877             d->visualIndices.insert(j, j);
1878             d->logicalIndices.insert(j, j);
1879         }
1880     }
1881 
1882     // insert sections into hiddenSectionSize
1883     QHash<int, int> newHiddenSectionSize; // from logical index to section size
1884     for (QHash<int, int>::const_iterator it = d->hiddenSectionSize.cbegin(),
1885          end = d->hiddenSectionSize.cend(); it != end; ++it) {
1886         const int oldIndex = it.key();
1887         const int newIndex = (oldIndex < logicalFirst) ? oldIndex : oldIndex + insertCount;
1888         newHiddenSectionSize[newIndex] = it.value();
1889     }
1890     d->hiddenSectionSize.swap(newHiddenSectionSize);
1891 
1892     d->doDelayedResizeSections();
1893     emit sectionCountChanged(oldCount, count());
1894 
1895     // if the new sections were not updated by resizing, we need to update now
1896     if (!d->hasAutoResizeSections())
1897         d->viewport->update();
1898 }
1899 
1900 /*!
1901     This slot is called when sections are removed from the \a parent.
1902     \a logicalFirst and \a logicalLast signify where the sections were removed.
1903 
1904     If only one section is removed, \a logicalFirst and \a logicalLast will
1905     be the same.
1906 */
1907 
1908 void QHeaderView::sectionsAboutToBeRemoved(const QModelIndex &parent,
1909                                            int logicalFirst, int logicalLast)
1910 {
1911     Q_UNUSED(parent);
1912     Q_UNUSED(logicalFirst);
1913     Q_UNUSED(logicalLast);
1914 }
1915 
1916 void QHeaderViewPrivate::updateHiddenSections(int logicalFirst, int logicalLast)
1917 {
1918     Q_Q(QHeaderView);
1919     const int changeCount = logicalLast - logicalFirst + 1;
1920 
1921     // remove sections from hiddenSectionSize
1922     QHash<int, int> newHiddenSectionSize; // from logical index to section size
1923     for (int i = 0; i < logicalFirst; ++i)
1924         if (q->isSectionHidden(i))
1925             newHiddenSectionSize[i] = hiddenSectionSize[i];
1926     for (int j = logicalLast + 1; j < sectionCount(); ++j)
1927         if (q->isSectionHidden(j))
1928             newHiddenSectionSize[j - changeCount] = hiddenSectionSize[j];
1929     hiddenSectionSize = newHiddenSectionSize;
1930 }
1931 
1932 void QHeaderViewPrivate::_q_sectionsRemoved(const QModelIndex &parent,
1933                                             int logicalFirst, int logicalLast)
1934 {
1935     Q_Q(QHeaderView);
1936     if (parent != root)
1937         return; // we only handle changes in the root level
1938     if (qMin(logicalFirst, logicalLast) < 0
1939         || qMax(logicalLast, logicalFirst) >= sectionCount())
1940         return;
1941     int oldCount = q->count();
1942     int changeCount = logicalLast - logicalFirst + 1;
1943 
1944     if (state == QHeaderViewPrivate::ResizeSection)
1945         preventCursorChangeInSetOffset = true;
1946 
1947     updateHiddenSections(logicalFirst, logicalLast);
1948 
1949     if (visualIndices.isEmpty() && logicalIndices.isEmpty()) {
1950         //Q_ASSERT(headerSectionCount() == sectionCount);
1951         removeSectionsFromSectionItems(logicalFirst, logicalLast);
1952     } else {
1953         if (logicalFirst == logicalLast) { // Remove just one index.
1954             int l = logicalFirst;
1955             int visual = visualIndices.at(l);
1956             Q_ASSERT(sectionCount() == logicalIndices.count());
1957             for (int v = 0; v < sectionCount(); ++v) {
1958                 if (v > visual) {
1959                     int logical = logicalIndices.at(v);
1960                     --(visualIndices[logical]);
1961                 }
1962                 if (logicalIndex(v) > l) // no need to move the positions before l
1963                     --(logicalIndices[v]);
1964             }
1965             logicalIndices.remove(visual);
1966             visualIndices.remove(l);
1967             //Q_ASSERT(headerSectionCount() == sectionCount);
1968             removeSectionsFromSectionItems(visual, visual);
1969         } else {
1970             sectionStartposRecalc = true; // We will need to recalc positions after removing items
1971             for (int u = 0; u < sectionItems.count(); ++u)  // Store section info
1972                 sectionItems.at(u).tmpLogIdx = logicalIndices.at(u);
1973             for (int v = sectionItems.count() - 1; v >= 0; --v) {  // Remove the sections
1974                 if (logicalFirst <= sectionItems.at(v).tmpLogIdx && sectionItems.at(v).tmpLogIdx <= logicalLast)
1975                     removeSectionsFromSectionItems(v, v);
1976             }
1977             visualIndices.resize(sectionItems.count());
1978             logicalIndices.resize(sectionItems.count());
1979             int* visual_data = visualIndices.data();
1980             int* logical_data = logicalIndices.data();
1981             for (int w = 0; w < sectionItems.count(); ++w) { // Restore visual and logical indexes
1982                 int logindex = sectionItems.at(w).tmpLogIdx;
1983                 if (logindex > logicalFirst)
1984                     logindex -= changeCount;
1985                 visual_data[logindex] = w;
1986                 logical_data[w] = logindex;
1987             }
1988         }
1989         // ### handle sectionSelection (sectionHidden is handled by updateHiddenSections)
1990     }
1991 
1992     // update sorting column
1993     if (sortIndicatorSection >= logicalFirst) {
1994         if (sortIndicatorSection <= logicalLast)
1995             sortIndicatorSection = -1;
1996         else
1997             sortIndicatorSection -= changeCount;
1998     }
1999 
2000     // if we only have the last section (the "end" position) left, the header is empty
2001     if (sectionCount() <= 0)
2002         clear();
2003     invalidateCachedSizeHint();
2004     emit q->sectionCountChanged(oldCount, q->count());
2005     viewport->update();
2006 }
2007 
2008 void QHeaderViewPrivate::_q_layoutAboutToBeChanged()
2009 {
2010     //if there is no row/column we can't have mapping for columns
2011     //because no QModelIndex in the model would be valid
2012     // ### this is far from being bullet-proof and we would need a real system to
2013     // ### map columns or rows persistently
2014     if ((orientation == Qt::Horizontal && model->rowCount(root) == 0)
2015         || model->columnCount(root) == 0)
2016         return;
2017 
2018     if (hiddenSectionSize.count() == 0)
2019         return;
2020 
2021     for (int i = 0; i < sectionItems.count(); ++i)
2022         if (isVisualIndexHidden(i)) // ### note that we are using column or row 0
2023             persistentHiddenSections.append(orientation == Qt::Horizontal
2024                                             ? model->index(0, logicalIndex(i), root)
2025                                             : model->index(logicalIndex(i), 0, root));
2026 }
2027 
2028 void QHeaderViewPrivate::_q_layoutChanged()
2029 {
2030     Q_Q(QHeaderView);
2031     viewport->update();
2032     if (persistentHiddenSections.isEmpty() || modelIsEmpty()) {
2033         if (modelSectionCount() != sectionCount())
2034             q->initializeSections();
2035         persistentHiddenSections.clear();
2036         return;
2037     }
2038 
2039     QBitArray oldSectionHidden = sectionsHiddenToBitVector();
2040     oldSectionHidden.resize(sectionItems.size());
2041     bool sectionCountChanged = false;
2042 
2043     for (int i = 0; i < persistentHiddenSections.count(); ++i) {
2044         QModelIndex index = persistentHiddenSections.at(i);
2045         if (index.isValid()) {
2046             const int logical = (orientation == Qt::Horizontal
2047                                  ? index.column()
2048                                  : index.row());
2049             q->setSectionHidden(logical, true);
2050             oldSectionHidden.setBit(logical, false);
2051         } else if (!sectionCountChanged && (modelSectionCount() != sectionCount())) {
2052             sectionCountChanged = true;
2053             break;
2054         }
2055     }
2056     persistentHiddenSections.clear();
2057 
2058     for (int i = 0; i < oldSectionHidden.count(); ++i) {
2059         if (oldSectionHidden.testBit(i))
2060             q->setSectionHidden(i, false);
2061     }
2062 
2063     // the number of sections changed; we need to reread the state of the model
2064     if (sectionCountChanged)
2065         q->initializeSections();
2066 }
2067 
2068 /*!
2069   \internal
2070 */
2071 
2072 void QHeaderView::initializeSections()
2073 {
2074     Q_D(QHeaderView);
2075     const int oldCount = d->sectionCount();
2076     const int newCount = d->modelSectionCount();
2077     if (newCount <= 0) {
2078             d->clear();
2079             emit sectionCountChanged(oldCount, 0);
2080     } else if (newCount != oldCount) {
2081         const int min = qBound(0, oldCount, newCount - 1);
2082         initializeSections(min, newCount - 1);
2083         if (stretchLastSection()) // we've already gotten the size hint
2084             d->lastSectionSize = sectionSize(logicalIndex(d->sectionCount() - 1));
2085 
2086         //make sure we update the hidden sections
2087         if (newCount < oldCount)
2088             d->updateHiddenSections(0, newCount-1);
2089     }
2090 }
2091 
2092 /*!
2093     \internal
2094 */
2095 
2096 void QHeaderView::initializeSections(int start, int end)
2097 {
2098     Q_D(QHeaderView);
2099 
2100     Q_ASSERT(start >= 0);
2101     Q_ASSERT(end >= 0);
2102 
2103     d->invalidateCachedSizeHint();
2104     int oldCount = d->sectionCount();
2105 
2106     if (end + 1 < d->sectionCount()) {
2107         int newCount = end + 1;
2108         d->removeSectionsFromSectionItems(newCount, d->sectionCount() - 1);
2109         if (!d->hiddenSectionSize.isEmpty()) {
2110             if (oldCount - newCount > d->hiddenSectionSize.count()) {
2111                 for (int i = end + 1; i < d->sectionCount(); ++i)
2112                     d->hiddenSectionSize.remove(i);
2113             } else {
2114                 QHash<int, int>::iterator it = d->hiddenSectionSize.begin();
2115                 while (it != d->hiddenSectionSize.end()) {
2116                     if (it.key() > end)
2117                         it = d->hiddenSectionSize.erase(it);
2118                     else
2119                         ++it;
2120                 }
2121             }
2122         }
2123     }
2124 
2125     int newSectionCount = end + 1;
2126 
2127     if (!d->logicalIndices.isEmpty()) {
2128         if (oldCount <= newSectionCount) {
2129             d->logicalIndices.resize(newSectionCount);
2130             d->visualIndices.resize(newSectionCount);
2131             for (int i = oldCount; i < newSectionCount; ++i) {
2132                 d->logicalIndices[i] = i;
2133                 d->visualIndices[i] = i;
2134             }
2135         } else {
2136             int j = 0;
2137             for (int i = 0; i < oldCount; ++i) {
2138                 int v = d->logicalIndices.at(i);
2139                 if (v < newSectionCount) {
2140                     d->logicalIndices[j] = v;
2141                     d->visualIndices[v] = j;
2142                     j++;
2143                 }
2144             }
2145             d->logicalIndices.resize(newSectionCount);
2146             d->visualIndices.resize(newSectionCount);
2147         }
2148     }
2149 
2150     if (d->globalResizeMode == Stretch)
2151         d->stretchSections = newSectionCount;
2152     else if (d->globalResizeMode == ResizeToContents)
2153          d->contentsSections = newSectionCount;
2154 
2155     if (newSectionCount > oldCount)
2156         d->createSectionItems(start, end, (end - start + 1) * d->defaultSectionSize, d->globalResizeMode);
2157     //Q_ASSERT(d->headerLength() == d->length);
2158 
2159     if (d->sectionCount() != oldCount)
2160         emit sectionCountChanged(oldCount,  d->sectionCount());
2161     d->viewport->update();
2162 }
2163 
2164 /*!
2165   \reimp
2166 */
2167 
2168 void QHeaderView::currentChanged(const QModelIndex &current, const QModelIndex &old)
2169 {
2170     Q_D(QHeaderView);
2171 
2172     if (d->orientation == Qt::Horizontal && current.column() != old.column()) {
2173         if (old.isValid() && old.parent() == d->root)
2174             d->viewport->update(QRect(sectionViewportPosition(old.column()), 0,
2175                                     sectionSize(old.column()), d->viewport->height()));
2176         if (current.isValid() && current.parent() == d->root)
2177             d->viewport->update(QRect(sectionViewportPosition(current.column()), 0,
2178                                     sectionSize(current.column()), d->viewport->height()));
2179     } else if (d->orientation == Qt::Vertical && current.row() != old.row()) {
2180         if (old.isValid() && old.parent() == d->root)
2181             d->viewport->update(QRect(0, sectionViewportPosition(old.row()),
2182                                     d->viewport->width(), sectionSize(old.row())));
2183         if (current.isValid() && current.parent() == d->root)
2184             d->viewport->update(QRect(0, sectionViewportPosition(current.row()),
2185                                     d->viewport->width(), sectionSize(current.row())));
2186     }
2187 }
2188 
2189 
2190 /*!
2191   \reimp
2192 */
2193 
2194 bool QHeaderView::event(QEvent *e)
2195 {
2196     Q_D(QHeaderView);
2197     switch (e->type()) {
2198     case QEvent::HoverEnter: {
2199         QHoverEvent *he = static_cast<QHoverEvent*>(e);
2200         d->hover = logicalIndexAt(he->pos());
2201         if (d->hover != -1)
2202             updateSection(d->hover);
2203         break; }
2204     case QEvent::Leave:
2205     case QEvent::HoverLeave: {
2206         if (d->hover != -1)
2207             updateSection(d->hover);
2208         d->hover = -1;
2209         break; }
2210     case QEvent::HoverMove: {
2211         QHoverEvent *he = static_cast<QHoverEvent*>(e);
2212         int oldHover = d->hover;
2213         d->hover = logicalIndexAt(he->pos());
2214         if (d->hover != oldHover) {
2215             if (oldHover != -1)
2216                 updateSection(oldHover);
2217             if (d->hover != -1)
2218                 updateSection(d->hover);
2219         }
2220         break; }
2221     case QEvent::Timer: {
2222         QTimerEvent *te = static_cast<QTimerEvent*>(e);
2223         if (te->timerId() == d->delayedResize.timerId()) {
2224             d->delayedResize.stop();
2225             resizeSections();
2226         }
2227         break; }
2228     case QEvent::StyleChange:
2229         if (!d->customDefaultSectionSize)
2230             d->updateDefaultSectionSizeFromStyle();
2231         break;
2232     default:
2233         break;
2234     }
2235     return QAbstractItemView::event(e);
2236 }
2237 
2238 /*!
2239   \reimp
2240 */
2241 
2242 void QHeaderView::paintEvent(QPaintEvent *e)
2243 {
2244     Q_D(QHeaderView);
2245 
2246     if (count() == 0)
2247         return;
2248 
2249     QPainter painter(d->viewport);
2250     const QPoint offset = d->scrollDelayOffset;
2251     QRect translatedEventRect = e->rect();
2252     translatedEventRect.translate(offset);
2253 
2254     int start = -1;
2255     int end = -1;
2256     if (d->orientation == Qt::Horizontal) {
2257         start = visualIndexAt(translatedEventRect.left());
2258         end = visualIndexAt(translatedEventRect.right());
2259     } else {
2260         start = visualIndexAt(translatedEventRect.top());
2261         end = visualIndexAt(translatedEventRect.bottom());
2262     }
2263 
2264     if (d->reverse()) {
2265         start = (start == -1 ? count() - 1 : start);
2266         end = (end == -1 ? 0 : end);
2267     } else {
2268         start = (start == -1 ? 0 : start);
2269         end = (end == -1 ? count() - 1 : end);
2270     }
2271 
2272     int tmp = start;
2273     start = qMin(start, end);
2274     end = qMax(tmp, end);
2275 
2276     d->prepareSectionSelected(); // clear and resize the bit array
2277 
2278     QRect currentSectionRect;
2279     int logical;
2280     const int width = d->viewport->width();
2281     const int height = d->viewport->height();
2282     for (int i = start; i <= end; ++i) {
2283         if (d->isVisualIndexHidden(i))
2284             continue;
2285         painter.save();
2286         logical = logicalIndex(i);
2287         if (d->orientation == Qt::Horizontal) {
2288             currentSectionRect.setRect(sectionViewportPosition(logical), 0, sectionSize(logical), height);
2289         } else {
2290             currentSectionRect.setRect(0, sectionViewportPosition(logical), width, sectionSize(logical));
2291         }
2292         currentSectionRect.translate(offset);
2293 
2294         QVariant variant = d->model->headerData(logical, d->orientation,
2295                                                 Qt::FontRole);
2296         if (variant.isValid() && variant.canConvert<QFont>()) {
2297             QFont sectionFont = qvariant_cast<QFont>(variant);
2298             painter.setFont(sectionFont);
2299         }
2300         paintSection(&painter, currentSectionRect, logical);
2301         painter.restore();
2302     }
2303 
2304     QStyleOption opt;
2305     opt.init(this);
2306     // Paint the area beyond where there are indexes
2307     if (d->reverse()) {
2308         opt.state |= QStyle::State_Horizontal;
2309         if (currentSectionRect.left() > translatedEventRect.left()) {
2310             opt.rect = QRect(translatedEventRect.left(), 0,
2311                              currentSectionRect.left() - translatedEventRect.left(), height);
2312             style()->drawControl(QStyle::CE_HeaderEmptyArea, &opt, &painter, this);
2313         }
2314     } else if (currentSectionRect.right() < translatedEventRect.right()) {
2315         // paint to the right
2316         opt.state |= QStyle::State_Horizontal;
2317         opt.rect = QRect(currentSectionRect.right() + 1, 0,
2318                          translatedEventRect.right() - currentSectionRect.right(), height);
2319         style()->drawControl(QStyle::CE_HeaderEmptyArea, &opt, &painter, this);
2320     } else if (currentSectionRect.bottom() < translatedEventRect.bottom()) {
2321         // paint the bottom section
2322         opt.state &= ~QStyle::State_Horizontal;
2323         opt.rect = QRect(0, currentSectionRect.bottom() + 1,
2324                          width, height - currentSectionRect.bottom() - 1);
2325         style()->drawControl(QStyle::CE_HeaderEmptyArea, &opt, &painter, this);
2326     }
2327 
2328 #if 0
2329     // ### visualize sections
2330     for (int a = 0, i = 0; i < d->sectionItems.count(); ++i) {
2331         QColor color((i & 4 ? 255 : 0), (i & 2 ? 255 : 0), (i & 1 ? 255 : 0));
2332         if (d->orientation == Qt::Horizontal)
2333             painter.fillRect(a - d->offset, 0, d->sectionItems.at(i).size, 4, color);
2334         else
2335             painter.fillRect(0, a - d->offset, 4, d->sectionItems.at(i).size, color);
2336         a += d->sectionItems.at(i).size;
2337     }
2338 
2339 #endif
2340 }
2341 
2342 /*!
2343   \reimp
2344 */
2345 
2346 void QHeaderView::mousePressEvent(QMouseEvent *e)
2347 {
2348     Q_D(QHeaderView);
2349     if (d->state != QHeaderViewPrivate::NoState || e->button() != Qt::LeftButton)
2350         return;
2351     int pos = d->orientation == Qt::Horizontal ? e->x() : e->y();
2352     int handle = d->sectionHandleAt(pos);
2353     d->originalSize = -1; // clear the stored original size
2354     if (handle == -1) {
2355         d->pressed = logicalIndexAt(pos);
2356         if (d->clickableSections)
2357             emit sectionPressed(d->pressed);
2358 
2359         bool acceptMoveSection = d->movableSections;
2360         if (acceptMoveSection && d->pressed == 0 && !d->allowUserMoveOfSection0)
2361             acceptMoveSection = false; // Do not allow moving the tree nod
2362 
2363         if (acceptMoveSection) {
2364             d->section = d->target = d->pressed;
2365             if (d->section == -1)
2366                 return;
2367             d->state = QHeaderViewPrivate::MoveSection;
2368             d->setupSectionIndicator(d->section, pos);
2369         } else if (d->clickableSections && d->pressed != -1) {
2370             updateSection(d->pressed);
2371             d->state = QHeaderViewPrivate::SelectSections;
2372         }
2373     } else if (sectionResizeMode(handle) == Interactive) {
2374         d->originalSize = sectionSize(handle);
2375         d->state = QHeaderViewPrivate::ResizeSection;
2376         d->section = handle;
2377         d->preventCursorChangeInSetOffset = false;
2378     }
2379 
2380     d->firstPos = pos;
2381     d->lastPos = pos;
2382 
2383     d->clearCascadingSections();
2384 }
2385 
2386 /*!
2387   \reimp
2388 */
2389 
2390 void QHeaderView::mouseMoveEvent(QMouseEvent *e)
2391 {
2392     Q_D(QHeaderView);
2393     int pos = d->orientation == Qt::Horizontal ? e->x() : e->y();
2394     if (pos < 0 && d->state != QHeaderViewPrivate::SelectSections)
2395         return;
2396     if (e->buttons() == Qt::NoButton) {
2397 #if !defined(Q_DEAD_CODE_FROM_QT4_MAC)
2398         // Under Cocoa, when the mouse button is released, may include an extra
2399         // simulated mouse moved event. The state of the buttons when this event
2400         // is generated is already "no button" and the code below gets executed
2401         // just before the mouseReleaseEvent and resets the state. This prevents
2402         // column dragging from working. So this code is disabled under Cocoa.
2403         d->state = QHeaderViewPrivate::NoState;
2404         d->pressed = -1;
2405 #endif
2406     }
2407     switch (d->state) {
2408         case QHeaderViewPrivate::ResizeSection: {
2409             Q_ASSERT(d->originalSize != -1);
2410             if (d->cascadingResizing) {
2411                 int delta = d->reverse() ? d->lastPos - pos : pos - d->lastPos;
2412                 int visual = visualIndex(d->section);
2413                 d->cascadingResize(visual, d->headerSectionSize(visual) + delta);
2414             } else {
2415                 int delta = d->reverse() ? d->firstPos - pos : pos - d->firstPos;
2416                 int newsize = qBound(minimumSectionSize(), d->originalSize + delta, maximumSectionSize());
2417                 resizeSection(d->section, newsize);
2418             }
2419             d->lastPos = pos;
2420             return;
2421         }
2422         case QHeaderViewPrivate::MoveSection: {
2423             if (d->shouldAutoScroll(e->pos()))
2424                 d->startAutoScroll();
2425             if (qAbs(pos - d->firstPos) >= QApplication::startDragDistance()
2426                 || !d->sectionIndicator->isHidden()) {
2427                 int visual = visualIndexAt(pos);
2428                 if (visual == -1)
2429                     return;
2430                 if (visual == 0 && logicalIndex(0) == 0 && !d->allowUserMoveOfSection0)
2431                     return;
2432 
2433                 int posThreshold = d->headerSectionPosition(visual) - d->offset + d->headerSectionSize(visual) / 2;
2434                 int moving = visualIndex(d->section);
2435                 if (visual < moving) {
2436                     if (pos < posThreshold)
2437                         d->target = d->logicalIndex(visual);
2438                     else
2439                         d->target = d->logicalIndex(visual + 1);
2440                 } else if (visual > moving) {
2441                     if (pos > posThreshold)
2442                         d->target = d->logicalIndex(visual);
2443                     else
2444                         d->target = d->logicalIndex(visual - 1);
2445                 } else {
2446                     d->target = d->section;
2447                 }
2448                 d->updateSectionIndicator(d->section, pos);
2449             }
2450             return;
2451         }
2452         case QHeaderViewPrivate::SelectSections: {
2453             int logical = logicalIndexAt(qMax(-d->offset, pos));
2454             if (logical == -1 && pos > 0)
2455                 logical = logicalIndex(d->lastVisibleVisualIndex());
2456             if (logical == d->pressed)
2457                 return; // nothing to do
2458             else if (d->pressed != -1)
2459                 updateSection(d->pressed);
2460             d->pressed = logical;
2461             if (d->clickableSections && logical != -1) {
2462                 emit sectionEntered(d->pressed);
2463                 updateSection(d->pressed);
2464             }
2465             return;
2466         }
2467         case QHeaderViewPrivate::NoState: {
2468 #ifndef QT_NO_CURSOR
2469             int handle = d->sectionHandleAt(pos);
2470             bool hasCursor = testAttribute(Qt::WA_SetCursor);
2471             if (handle != -1 && (sectionResizeMode(handle) == Interactive)) {
2472                 if (!hasCursor)
2473                     setCursor(d->orientation == Qt::Horizontal ? Qt::SplitHCursor : Qt::SplitVCursor);
2474             } else if (hasCursor) {
2475                 unsetCursor();
2476             }
2477 #endif
2478             return;
2479         }
2480         default:
2481             break;
2482     }
2483 }
2484 
2485 /*!
2486   \reimp
2487 */
2488 
2489 void QHeaderView::mouseReleaseEvent(QMouseEvent *e)
2490 {
2491     Q_D(QHeaderView);
2492     int pos = d->orientation == Qt::Horizontal ? e->x() : e->y();
2493     switch (d->state) {
2494     case QHeaderViewPrivate::MoveSection:
2495         if (!d->sectionIndicator->isHidden()) { // moving
2496             int from = visualIndex(d->section);
2497             Q_ASSERT(from != -1);
2498             int to = visualIndex(d->target);
2499             Q_ASSERT(to != -1);
2500             moveSection(from, to);
2501             d->section = d->target = -1;
2502             d->updateSectionIndicator(d->section, pos);
2503             break;
2504         } // not moving
2505     case QHeaderViewPrivate::SelectSections:
2506         if (!d->clickableSections) {
2507             int section = logicalIndexAt(pos);
2508             updateSection(section);
2509         }
2510         // fall through
2511     case QHeaderViewPrivate::NoState:
2512         if (d->clickableSections) {
2513             int section = logicalIndexAt(pos);
2514             if (section != -1 && section == d->pressed) {
2515                 d->flipSortIndicator(section);
2516                 emit sectionClicked(section);
2517             }
2518             if (d->pressed != -1)
2519                 updateSection(d->pressed);
2520         }
2521         break;
2522     case QHeaderViewPrivate::ResizeSection:
2523         d->originalSize = -1;
2524         d->clearCascadingSections();
2525         break;
2526     default:
2527         break;
2528     }
2529     d->state = QHeaderViewPrivate::NoState;
2530     d->pressed = -1;
2531 }
2532 
2533 /*!
2534   \reimp
2535 */
2536 
2537 void QHeaderView::mouseDoubleClickEvent(QMouseEvent *e)
2538 {
2539     Q_D(QHeaderView);
2540     int pos = d->orientation == Qt::Horizontal ? e->x() : e->y();
2541     int handle = d->sectionHandleAt(pos);
2542     if (handle > -1 && sectionResizeMode(handle) == Interactive) {
2543         emit sectionHandleDoubleClicked(handle);
2544 #ifndef QT_NO_CURSOR
2545         Qt::CursorShape splitCursor = (d->orientation == Qt::Horizontal)
2546                                       ? Qt::SplitHCursor : Qt::SplitVCursor;
2547         if (cursor().shape() == splitCursor) {
2548             // signal handlers may have changed the section size
2549             handle = d->sectionHandleAt(pos);
2550             if (!(handle > -1 && sectionResizeMode(handle) == Interactive))
2551                 setCursor(Qt::ArrowCursor);
2552         }
2553 #endif
2554     } else {
2555         emit sectionDoubleClicked(logicalIndexAt(e->pos()));
2556     }
2557 }
2558 
2559 /*!
2560   \reimp
2561 */
2562 
2563 bool QHeaderView::viewportEvent(QEvent *e)
2564 {
2565     Q_D(QHeaderView);
2566     switch (e->type()) {
2567 #ifndef QT_NO_TOOLTIP
2568     case QEvent::ToolTip: {
2569         QHelpEvent *he = static_cast<QHelpEvent*>(e);
2570         int logical = logicalIndexAt(he->pos());
2571         if (logical != -1) {
2572             QVariant variant = d->model->headerData(logical, d->orientation, Qt::ToolTipRole);
2573             if (variant.isValid()) {
2574                 QToolTip::showText(he->globalPos(), variant.toString(), this);
2575                 return true;
2576             }
2577         }
2578         break; }
2579 #endif
2580 #ifndef QT_NO_WHATSTHIS
2581     case QEvent::QueryWhatsThis: {
2582         QHelpEvent *he = static_cast<QHelpEvent*>(e);
2583         int logical = logicalIndexAt(he->pos());
2584         if (logical != -1
2585             && d->model->headerData(logical, d->orientation, Qt::WhatsThisRole).isValid())
2586             return true;
2587         break; }
2588     case QEvent::WhatsThis: {
2589         QHelpEvent *he = static_cast<QHelpEvent*>(e);
2590         int logical = logicalIndexAt(he->pos());
2591         if (logical != -1) {
2592              QVariant whatsthis = d->model->headerData(logical, d->orientation,
2593                                                       Qt::WhatsThisRole);
2594              if (whatsthis.isValid()) {
2595                  QWhatsThis::showText(he->globalPos(), whatsthis.toString(), this);
2596                  return true;
2597              }
2598         }
2599         break; }
2600 #endif // QT_NO_WHATSTHIS
2601 #ifndef QT_NO_STATUSTIP
2602     case QEvent::StatusTip: {
2603         QHelpEvent *he = static_cast<QHelpEvent*>(e);
2604         int logical = logicalIndexAt(he->pos());
2605         if (logical != -1) {
2606             QString statustip = d->model->headerData(logical, d->orientation,
2607                                                     Qt::StatusTipRole).toString();
2608             if (!statustip.isEmpty())
2609                 setStatusTip(statustip);
2610         }
2611         return true; }
2612 #endif // QT_NO_STATUSTIP
2613     case QEvent::FontChange:
2614     case QEvent::StyleChange:
2615         d->invalidateCachedSizeHint();
2616         // Fall through
2617     case QEvent::Hide:
2618     case QEvent::Show: {
2619         QAbstractScrollArea *parent = qobject_cast<QAbstractScrollArea *>(parentWidget());
2620         if (parent && parent->isVisible()) // Only resize if we have a visible parent
2621             resizeSections();
2622         emit geometriesChanged();
2623         break;}
2624     case QEvent::ContextMenu: {
2625         d->state = QHeaderViewPrivate::NoState;
2626         d->pressed = d->section = d->target = -1;
2627         d->updateSectionIndicator(d->section, -1);
2628         break; }
2629     case QEvent::Wheel: {
2630         QAbstractScrollArea *asa = qobject_cast<QAbstractScrollArea *>(parentWidget());
2631         if (asa)
2632             return QApplication::sendEvent(asa->viewport(), e);
2633         break; }
2634     default:
2635         break;
2636     }
2637     return QAbstractItemView::viewportEvent(e);
2638 }
2639 
2640 /*!
2641     Paints the section specified by the given \a logicalIndex, using the given
2642     \a painter and \a rect.
2643 
2644     Normally, you do not have to call this function.
2645 */
2646 
2647 void QHeaderView::paintSection(QPainter *painter, const QRect &rect, int logicalIndex) const
2648 {
2649     Q_D(const QHeaderView);
2650     if (!rect.isValid())
2651         return;
2652     // get the state of the section
2653     QStyleOptionHeader opt;
2654     initStyleOption(&opt);
2655     QStyle::State state = QStyle::State_None;
2656     if (isEnabled())
2657         state |= QStyle::State_Enabled;
2658     if (window()->isActiveWindow())
2659         state |= QStyle::State_Active;
2660     if (d->clickableSections) {
2661         if (logicalIndex == d->hover)
2662             state |= QStyle::State_MouseOver;
2663         if (logicalIndex == d->pressed)
2664             state |= QStyle::State_Sunken;
2665         else if (d->highlightSelected) {
2666             if (d->sectionIntersectsSelection(logicalIndex))
2667                 state |= QStyle::State_On;
2668             if (d->isSectionSelected(logicalIndex))
2669                 state |= QStyle::State_Sunken;
2670         }
2671 
2672     }
2673     if (isSortIndicatorShown() && sortIndicatorSection() == logicalIndex)
2674         opt.sortIndicator = (sortIndicatorOrder() == Qt::AscendingOrder)
2675                             ? QStyleOptionHeader::SortDown : QStyleOptionHeader::SortUp;
2676 
2677     // setup the style options structure
2678     QVariant textAlignment = d->model->headerData(logicalIndex, d->orientation,
2679                                                   Qt::TextAlignmentRole);
2680     opt.rect = rect;
2681     opt.section = logicalIndex;
2682     opt.state |= state;
2683     opt.textAlignment = Qt::Alignment(textAlignment.isValid()
2684                                       ? Qt::Alignment(textAlignment.toInt())
2685                                       : d->defaultAlignment);
2686 
2687     opt.iconAlignment = Qt::AlignVCenter;
2688     opt.text = d->model->headerData(logicalIndex, d->orientation,
2689                                     Qt::DisplayRole).toString();
2690 
2691     int margin = 2 * style()->pixelMetric(QStyle::PM_HeaderMargin, 0, this);
2692 
2693     const Qt::Alignment headerArrowAlignment = static_cast<Qt::Alignment>(style()->styleHint(QStyle::SH_Header_ArrowAlignment, 0, this));
2694     const bool isHeaderArrowOnTheSide = headerArrowAlignment & Qt::AlignVCenter;
2695     if (isSortIndicatorShown() && sortIndicatorSection() == logicalIndex && isHeaderArrowOnTheSide)
2696         margin += style()->pixelMetric(QStyle::PM_HeaderMarkSize, 0, this);
2697 
2698     if (d->textElideMode != Qt::ElideNone)
2699         opt.text = opt.fontMetrics.elidedText(opt.text, d->textElideMode , rect.width() - margin);
2700 
2701     QVariant variant = d->model->headerData(logicalIndex, d->orientation,
2702                                     Qt::DecorationRole);
2703     opt.icon = qvariant_cast<QIcon>(variant);
2704     if (opt.icon.isNull())
2705         opt.icon = qvariant_cast<QPixmap>(variant);
2706     QVariant foregroundBrush = d->model->headerData(logicalIndex, d->orientation,
2707                                                     Qt::ForegroundRole);
2708     if (foregroundBrush.canConvert<QBrush>())
2709         opt.palette.setBrush(QPalette::ButtonText, qvariant_cast<QBrush>(foregroundBrush));
2710 
2711     QPointF oldBO = painter->brushOrigin();
2712     QVariant backgroundBrush = d->model->headerData(logicalIndex, d->orientation,
2713                                                     Qt::BackgroundRole);
2714     if (backgroundBrush.canConvert<QBrush>()) {
2715         opt.palette.setBrush(QPalette::Button, qvariant_cast<QBrush>(backgroundBrush));
2716         opt.palette.setBrush(QPalette::Window, qvariant_cast<QBrush>(backgroundBrush));
2717         painter->setBrushOrigin(opt.rect.topLeft());
2718     }
2719 
2720     // the section position
2721     int visual = visualIndex(logicalIndex);
2722     Q_ASSERT(visual != -1);
2723     bool first = d->isFirstVisibleSection(visual);
2724     bool last = d->isLastVisibleSection(visual);
2725     if (first && last)
2726         opt.position = QStyleOptionHeader::OnlyOneSection;
2727     else if (first)
2728         opt.position = QStyleOptionHeader::Beginning;
2729     else if (last)
2730         opt.position = QStyleOptionHeader::End;
2731     else
2732         opt.position = QStyleOptionHeader::Middle;
2733     opt.orientation = d->orientation;
2734     // the selected position
2735     bool previousSelected = d->isSectionSelected(this->logicalIndex(visual - 1));
2736     bool nextSelected =  d->isSectionSelected(this->logicalIndex(visual + 1));
2737     if (previousSelected && nextSelected)
2738         opt.selectedPosition = QStyleOptionHeader::NextAndPreviousAreSelected;
2739     else if (previousSelected)
2740         opt.selectedPosition = QStyleOptionHeader::PreviousIsSelected;
2741     else if (nextSelected)
2742         opt.selectedPosition = QStyleOptionHeader::NextIsSelected;
2743     else
2744         opt.selectedPosition = QStyleOptionHeader::NotAdjacent;
2745     // draw the section
2746     style()->drawControl(QStyle::CE_Header, &opt, painter, this);
2747 
2748     painter->setBrushOrigin(oldBO);
2749 }
2750 
2751 /*!
2752     Returns the size of the contents of the section specified by the given
2753     \a logicalIndex.
2754 
2755     \sa defaultSectionSize()
2756 */
2757 
2758 QSize QHeaderView::sectionSizeFromContents(int logicalIndex) const
2759 {
2760     Q_D(const QHeaderView);
2761     Q_ASSERT(logicalIndex >= 0);
2762 
2763     ensurePolished();
2764 
2765     // use SizeHintRole
2766     QVariant variant = d->model->headerData(logicalIndex, d->orientation, Qt::SizeHintRole);
2767     if (variant.isValid())
2768         return qvariant_cast<QSize>(variant);
2769 
2770     // otherwise use the contents
2771     QStyleOptionHeader opt;
2772     initStyleOption(&opt);
2773     opt.section = logicalIndex;
2774     QVariant var = d->model->headerData(logicalIndex, d->orientation,
2775                                             Qt::FontRole);
2776     QFont fnt;
2777     if (var.isValid() && var.canConvert<QFont>())
2778         fnt = qvariant_cast<QFont>(var);
2779     else
2780         fnt = font();
2781     fnt.setBold(true);
2782     opt.fontMetrics = QFontMetrics(fnt);
2783     opt.text = d->model->headerData(logicalIndex, d->orientation,
2784                                     Qt::DisplayRole).toString();
2785     variant = d->model->headerData(logicalIndex, d->orientation, Qt::DecorationRole);
2786     opt.icon = qvariant_cast<QIcon>(variant);
2787     if (opt.icon.isNull())
2788         opt.icon = qvariant_cast<QPixmap>(variant);
2789     if (isSortIndicatorShown())
2790         opt.sortIndicator = QStyleOptionHeader::SortDown;
2791     return style()->sizeFromContents(QStyle::CT_HeaderSection, &opt, QSize(), this);
2792 }
2793 
2794 /*!
2795     Returns the horizontal offset of the header. This is 0 for vertical
2796     headers.
2797 
2798     \sa offset()
2799 */
2800 
2801 int QHeaderView::horizontalOffset() const
2802 {
2803     Q_D(const QHeaderView);
2804     if (d->orientation == Qt::Horizontal)
2805         return d->offset;
2806     return 0;
2807 }
2808 
2809 /*!
2810     Returns the vertical offset of the header. This is 0 for horizontal
2811     headers.
2812 
2813     \sa offset()
2814 */
2815 
2816 int QHeaderView::verticalOffset() const
2817 {
2818     Q_D(const QHeaderView);
2819     if (d->orientation == Qt::Vertical)
2820         return d->offset;
2821     return 0;
2822 }
2823 
2824 /*!
2825     \reimp
2826     \internal
2827 */
2828 
2829 void QHeaderView::updateGeometries()
2830 {
2831     Q_D(QHeaderView);
2832     d->layoutChildren();
2833     if (d->hasAutoResizeSections())
2834         d->doDelayedResizeSections();
2835 }
2836 
2837 /*!
2838     \reimp
2839     \internal
2840 */
2841 
2842 void QHeaderView::scrollContentsBy(int dx, int dy)
2843 {
2844     Q_D(QHeaderView);
2845     d->scrollDirtyRegion(dx, dy);
2846 }
2847 
2848 /*!
2849     \reimp
2850     \internal
2851 */
2852 void QHeaderView::dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight, const QVector<int> &)
2853 {
2854     Q_D(QHeaderView);
2855     d->invalidateCachedSizeHint();
2856     if (d->hasAutoResizeSections()) {
2857         bool resizeRequired = d->globalResizeMode == ResizeToContents;
2858         int first = orientation() == Qt::Horizontal ? topLeft.column() : topLeft.row();
2859         int last = orientation() == Qt::Horizontal ? bottomRight.column() : bottomRight.row();
2860         for (int i = first; i <= last && !resizeRequired; ++i)
2861             resizeRequired = (sectionResizeMode(i) == ResizeToContents);
2862         if (resizeRequired)
2863             d->doDelayedResizeSections();
2864     }
2865 }
2866 
2867 /*!
2868     \reimp
2869     \internal
2870 
2871     Empty implementation because the header doesn't show QModelIndex items.
2872 */
2873 void QHeaderView::rowsInserted(const QModelIndex &, int, int)
2874 {
2875     // do nothing
2876 }
2877 
2878 /*!
2879     \reimp
2880     \internal
2881 
2882     Empty implementation because the header doesn't show QModelIndex items.
2883 */
2884 
2885 QRect QHeaderView::visualRect(const QModelIndex &) const
2886 {
2887     return QRect();
2888 }
2889 
2890 /*!
2891     \reimp
2892     \internal
2893 
2894     Empty implementation because the header doesn't show QModelIndex items.
2895 */
2896 
2897 void QHeaderView::scrollTo(const QModelIndex &, ScrollHint)
2898 {
2899     // do nothing - the header only displays sections
2900 }
2901 
2902 /*!
2903     \reimp
2904     \internal
2905 
2906     Empty implementation because the header doesn't show QModelIndex items.
2907 */
2908 
2909 QModelIndex QHeaderView::indexAt(const QPoint &) const
2910 {
2911     return QModelIndex();
2912 }
2913 
2914 /*!
2915     \reimp
2916     \internal
2917 
2918     Empty implementation because the header doesn't show QModelIndex items.
2919 */
2920 
2921 bool QHeaderView::isIndexHidden(const QModelIndex &) const
2922 {
2923     return true; // the header view has no items, just sections
2924 }
2925 
2926 /*!
2927     \reimp
2928     \internal
2929 
2930     Empty implementation because the header doesn't show QModelIndex items.
2931 */
2932 
2933 QModelIndex QHeaderView::moveCursor(CursorAction, Qt::KeyboardModifiers)
2934 {
2935     return QModelIndex();
2936 }
2937 
2938 /*!
2939     \reimp
2940 
2941     Selects the items in the given \a rect according to the specified
2942     \a flags.
2943 
2944     The base class implementation does nothing.
2945 */
2946 
2947 void QHeaderView::setSelection(const QRect&, QItemSelectionModel::SelectionFlags)
2948 {
2949     // do nothing
2950 }
2951 
2952 /*!
2953     \internal
2954 */
2955 
2956 QRegion QHeaderView::visualRegionForSelection(const QItemSelection &selection) const
2957 {
2958     Q_D(const QHeaderView);
2959     const int max = d->modelSectionCount();
2960 
2961     if (d->orientation == Qt::Horizontal) {
2962         int logicalLeft = max;
2963         int logicalRight = 0;
2964 
2965         if (d->visualIndices.empty()) {
2966             // If no reordered sections, skip redundant visual-to-logical transformations
2967             for (int i = 0; i < selection.count(); ++i) {
2968                 const QItemSelectionRange &r = selection.at(i);
2969                 if (r.parent().isValid() || !r.isValid())
2970                     continue; // we only know about toplevel items and we don't want invalid ranges
2971                 if (r.left() < logicalLeft)
2972                     logicalLeft = r.left();
2973                 if (r.right() > logicalRight)
2974                     logicalRight = r.right();
2975             }
2976         } else {
2977             int left = max;
2978             int right = 0;
2979             for (int i = 0; i < selection.count(); ++i) {
2980                 const QItemSelectionRange &r = selection.at(i);
2981                 if (r.parent().isValid() || !r.isValid())
2982                     continue; // we only know about toplevel items and we don't want invalid ranges
2983                 for (int k = r.left(); k <= r.right(); ++k) {
2984                     int visual = visualIndex(k);
2985                     if (visual == -1)   // in some cases users may change the selections
2986                         continue;       // before we have a chance to do the layout
2987                     if (visual < left)
2988                         left = visual;
2989                     if (visual > right)
2990                         right = visual;
2991                 }
2992             }
2993             logicalLeft = logicalIndex(left);
2994             logicalRight = logicalIndex(right);
2995         }
2996 
2997         if (logicalLeft < 0  || logicalLeft >= count() ||
2998             logicalRight < 0 || logicalRight >= count())
2999             return QRegion();
3000 
3001         int leftPos = sectionViewportPosition(logicalLeft);
3002         int rightPos = sectionViewportPosition(logicalRight);
3003         rightPos += sectionSize(logicalRight);
3004         return QRect(leftPos, 0, rightPos - leftPos, height());
3005     }
3006     // orientation() == Qt::Vertical
3007     int logicalTop = max;
3008     int logicalBottom = 0;
3009 
3010     if (d->visualIndices.empty()) {
3011         // If no reordered sections, skip redundant visual-to-logical transformations
3012         for (int i = 0; i < selection.count(); ++i) {
3013             const QItemSelectionRange &r = selection.at(i);
3014             if (r.parent().isValid() || !r.isValid())
3015                 continue; // we only know about toplevel items and we don't want invalid ranges
3016             if (r.top() < logicalTop)
3017                 logicalTop = r.top();
3018             if (r.bottom() > logicalBottom)
3019                 logicalBottom = r.bottom();
3020         }
3021     } else {
3022         int top = max;
3023         int bottom = 0;
3024 
3025         for (int i = 0; i < selection.count(); ++i) {
3026             const QItemSelectionRange &r = selection.at(i);
3027             if (r.parent().isValid() || !r.isValid())
3028                 continue; // we only know about toplevel items and we don't want invalid ranges
3029             for (int k = r.top(); k <= r.bottom(); ++k) {
3030                 int visual = visualIndex(k);
3031                 if (visual == -1)   // in some cases users may change the selections
3032                     continue;       // before we have a chance to do the layout
3033                 if (visual < top)
3034                     top = visual;
3035                 if (visual > bottom)
3036                     bottom = visual;
3037             }
3038         }
3039 
3040         logicalTop = logicalIndex(top);
3041         logicalBottom = logicalIndex(bottom);
3042     }
3043 
3044     if (logicalTop < 0 || logicalTop >= count() ||
3045         logicalBottom < 0 || logicalBottom >= count())
3046         return QRegion();
3047 
3048     int topPos = sectionViewportPosition(logicalTop);
3049     int bottomPos = sectionViewportPosition(logicalBottom) + sectionSize(logicalBottom);
3050 
3051     return QRect(0, topPos, width(), bottomPos - topPos);
3052 }
3053 
3054 
3055 // private implementation
3056 
3057 int QHeaderViewPrivate::sectionHandleAt(int position)
3058 {
3059     Q_Q(QHeaderView);
3060     int visual = q->visualIndexAt(position);
3061     if (visual == -1)
3062         return -1;
3063     int log = logicalIndex(visual);
3064     int pos = q->sectionViewportPosition(log);
3065     int grip = q->style()->pixelMetric(QStyle::PM_HeaderGripMargin, 0, q);
3066 
3067     bool atLeft = position < pos + grip;
3068     bool atRight = (position > pos + q->sectionSize(log) - grip);
3069     if (reverse())
3070         qSwap(atLeft, atRight);
3071 
3072     if (atLeft) {
3073         //grip at the beginning of the section
3074         while(visual > -1) {
3075             int logical = q->logicalIndex(--visual);
3076             if (!q->isSectionHidden(logical))
3077                 return logical;
3078         }
3079     } else if (atRight) {
3080         //grip at the end of the section
3081         return log;
3082     }
3083     return -1;
3084 }
3085 
3086 void QHeaderViewPrivate::setupSectionIndicator(int section, int position)
3087 {
3088     Q_Q(QHeaderView);
3089     if (!sectionIndicator) {
3090         sectionIndicator = new QLabel(viewport);
3091     }
3092 
3093     int w, h;
3094     int p = q->sectionViewportPosition(section);
3095     if (orientation == Qt::Horizontal) {
3096         w = q->sectionSize(section);
3097         h = viewport->height();
3098     } else {
3099         w = viewport->width();
3100         h = q->sectionSize(section);
3101     }
3102     sectionIndicator->resize(w, h);
3103 
3104     QPixmap pm(w, h);
3105     pm.fill(QColor(0, 0, 0, 45));
3106     QRect rect(0, 0, w, h);
3107 
3108     QPainter painter(&pm);
3109     painter.setOpacity(0.75);
3110     q->paintSection(&painter, rect, section);
3111     painter.end();
3112 
3113     sectionIndicator->setPixmap(pm);
3114     sectionIndicatorOffset = position - qMax(p, 0);
3115 }
3116 
3117 void QHeaderViewPrivate::updateSectionIndicator(int section, int position)
3118 {
3119     if (!sectionIndicator)
3120         return;
3121 
3122     if (section == -1 || target == -1) {
3123         sectionIndicator->hide();
3124         return;
3125     }
3126 
3127     if (orientation == Qt::Horizontal)
3128         sectionIndicator->move(position - sectionIndicatorOffset, 0);
3129     else
3130         sectionIndicator->move(0, position - sectionIndicatorOffset);
3131 
3132     sectionIndicator->show();
3133 }
3134 
3135 /*!
3136     Initialize \a option with the values from this QHeaderView. This method is
3137     useful for subclasses when they need a QStyleOptionHeader, but do not want
3138     to fill in all the information themselves.
3139 
3140     \sa QStyleOption::initFrom()
3141 */
3142 void QHeaderView::initStyleOption(QStyleOptionHeader *option) const
3143 {
3144     Q_D(const QHeaderView);
3145     option->initFrom(this);
3146     option->state = QStyle::State_None | QStyle::State_Raised;
3147     option->orientation = d->orientation;
3148     if (d->orientation == Qt::Horizontal)
3149         option->state |= QStyle::State_Horizontal;
3150     if (isEnabled())
3151         option->state |= QStyle::State_Enabled;
3152     option->section = 0;
3153 }
3154 
3155 bool QHeaderViewPrivate::isSectionSelected(int section) const
3156 {
3157     int i = section * 2;
3158     if (i < 0 || i >= sectionSelected.count())
3159         return false;
3160     if (sectionSelected.testBit(i)) // if the value was cached
3161         return sectionSelected.testBit(i + 1);
3162     bool s = false;
3163     if (orientation == Qt::Horizontal)
3164         s = isColumnSelected(section);
3165     else
3166         s = isRowSelected(section);
3167     sectionSelected.setBit(i + 1, s); // selection state
3168     sectionSelected.setBit(i, true); // cache state
3169     return s;
3170 }
3171 
3172 bool QHeaderViewPrivate::isFirstVisibleSection(int section) const
3173 {
3174     if (sectionStartposRecalc)
3175         recalcSectionStartPos();
3176     const SectionItem &item = sectionItems.at(section);
3177     return item.size > 0 && item.calculated_startpos == 0;
3178 }
3179 
3180 bool QHeaderViewPrivate::isLastVisibleSection(int section) const
3181 {
3182     if (sectionStartposRecalc)
3183         recalcSectionStartPos();
3184     const SectionItem &item = sectionItems.at(section);
3185     return item.size > 0 && item.calculatedEndPos() == length;
3186 }
3187 
3188 /*!
3189     \internal
3190     Returns the last visible (ie. not hidden) visual index
3191 */
3192 int QHeaderViewPrivate::lastVisibleVisualIndex() const
3193 {
3194     Q_Q(const QHeaderView);
3195     for (int visual = q->count()-1; visual >= 0; --visual) {
3196         if (!q->isSectionHidden(q->logicalIndex(visual)))
3197             return visual;
3198     }
3199 
3200     //default value if no section is actually visible
3201     return -1;
3202 }
3203 
3204 /*!
3205     \internal
3206     Go through and resize all of the sections applying stretchLastSection,
3207     manual stretches, sizes, and useGlobalMode.
3208 
3209     The different resize modes are:
3210     Interactive - the user decides the size
3211     Stretch - take up whatever space is left
3212     Fixed - the size is set programmatically outside the header
3213     ResizeToContentes - the size is set based on the contents of the row or column in the parent view
3214 
3215     The resize mode will not affect the last section if stretchLastSection is true.
3216 */
3217 void QHeaderViewPrivate::resizeSections(QHeaderView::ResizeMode globalMode, bool useGlobalMode)
3218 {
3219     Q_Q(QHeaderView);
3220     //stop the timer in case it is delayed
3221     delayedResize.stop();
3222 
3223     executePostedLayout();
3224     if (sectionCount() == 0)
3225         return;
3226 
3227     if (resizeRecursionBlock)
3228         return;
3229     resizeRecursionBlock = true;
3230 
3231     invalidateCachedSizeHint();
3232 
3233     const int lastVisibleSection = lastVisibleVisualIndex();
3234 
3235     // find stretchLastSection if we have it
3236     int stretchSection = -1;
3237     if (stretchLastSection && !useGlobalMode)
3238         stretchSection = lastVisibleVisualIndex();
3239 
3240     // count up the number of stretched sections and how much space left for them
3241     int lengthToStretch = (orientation == Qt::Horizontal ? viewport->width() : viewport->height());
3242     int numberOfStretchedSections = 0;
3243     QList<int> section_sizes;
3244     for (int i = 0; i < sectionCount(); ++i) {
3245         if (isVisualIndexHidden(i))
3246             continue;
3247 
3248         QHeaderView::ResizeMode resizeMode;
3249         if (useGlobalMode && (i != stretchSection))
3250             resizeMode = globalMode;
3251         else
3252             resizeMode = (i == stretchSection ? QHeaderView::Stretch : headerSectionResizeMode(i));
3253 
3254         if (resizeMode == QHeaderView::Stretch) {
3255             ++numberOfStretchedSections;
3256             section_sizes.append(headerSectionSize(i));
3257             continue;
3258         }
3259 
3260         // because it isn't stretch, determine its width and remove that from lengthToStretch
3261         int sectionSize = 0;
3262         if (resizeMode == QHeaderView::Interactive || resizeMode == QHeaderView::Fixed) {
3263             sectionSize = headerSectionSize(i);
3264         } else { // resizeMode == QHeaderView::ResizeToContents
3265             int logicalIndex = q->logicalIndex(i);
3266             sectionSize = qMax(viewSectionSizeHint(logicalIndex),
3267                                q->sectionSizeHint(logicalIndex));
3268             if (sectionSize > q->maximumSectionSize())
3269                 sectionSize = q->maximumSectionSize();
3270         }
3271         section_sizes.append(sectionSize);
3272         lengthToStretch -= sectionSize;
3273     }
3274 
3275     // calculate the new length for all of the stretched sections
3276     int stretchSectionLength = -1;
3277     int pixelReminder = 0;
3278     if (numberOfStretchedSections > 0 && lengthToStretch > 0) { // we have room to stretch in
3279         int hintLengthForEveryStretchedSection = lengthToStretch / numberOfStretchedSections;
3280         stretchSectionLength = qMax(hintLengthForEveryStretchedSection, q->minimumSectionSize());
3281         pixelReminder = lengthToStretch % numberOfStretchedSections;
3282     }
3283 
3284     // ### The code below would be nicer if it was cleaned up a bit (since spans has been replaced with items)
3285     int spanStartSection = 0;
3286     int previousSectionLength = 0;
3287 
3288     QHeaderView::ResizeMode previousSectionResizeMode = QHeaderView::Interactive;
3289 
3290     // resize each section along the total length
3291     for (int i = 0; i < sectionCount(); ++i) {
3292         int oldSectionLength = headerSectionSize(i);
3293         int newSectionLength = -1;
3294         QHeaderView::ResizeMode newSectionResizeMode = headerSectionResizeMode(i);
3295 
3296         if (isVisualIndexHidden(i)) {
3297             newSectionLength = 0;
3298         } else {
3299             QHeaderView::ResizeMode resizeMode;
3300             if (useGlobalMode)
3301                 resizeMode = globalMode;
3302             else
3303                 resizeMode = (i == stretchSection
3304                               ? QHeaderView::Stretch
3305                               : newSectionResizeMode);
3306             if (resizeMode == QHeaderView::Stretch && stretchSectionLength != -1) {
3307                 if (i == lastVisibleSection)
3308                     newSectionLength = qMax(stretchSectionLength, lastSectionSize);
3309                 else
3310                     newSectionLength = stretchSectionLength;
3311                 if (pixelReminder > 0) {
3312                     newSectionLength += 1;
3313                     --pixelReminder;
3314                 }
3315                 section_sizes.removeFirst();
3316             } else {
3317                 newSectionLength = section_sizes.front();
3318                 section_sizes.removeFirst();
3319             }
3320         }
3321 
3322         //Q_ASSERT(newSectionLength > 0);
3323         if ((previousSectionResizeMode != newSectionResizeMode
3324             || previousSectionLength != newSectionLength) && i > 0) {
3325             int spanLength = (i - spanStartSection) * previousSectionLength;
3326             createSectionItems(spanStartSection, i - 1, spanLength, previousSectionResizeMode);
3327             //Q_ASSERT(headerLength() == length);
3328             spanStartSection = i;
3329         }
3330 
3331         if (newSectionLength != oldSectionLength)
3332             emit q->sectionResized(logicalIndex(i), oldSectionLength, newSectionLength);
3333 
3334         previousSectionLength = newSectionLength;
3335         previousSectionResizeMode = newSectionResizeMode;
3336     }
3337 
3338     createSectionItems(spanStartSection, sectionCount() - 1,
3339                       (sectionCount() - spanStartSection) * previousSectionLength,
3340                       previousSectionResizeMode);
3341     //Q_ASSERT(headerLength() == length);
3342     resizeRecursionBlock = false;
3343     viewport->update();
3344 }
3345 
3346 void QHeaderViewPrivate::createSectionItems(int start, int end, int size, QHeaderView::ResizeMode mode)
3347 {
3348     int sizePerSection = size / (end - start + 1);
3349     if (end >= sectionItems.count()) {
3350         sectionItems.resize(end + 1);
3351         sectionStartposRecalc = true;
3352     }
3353     SectionItem *sectiondata = sectionItems.data();
3354     for (int i = start; i <= end; ++i) {
3355         length += (sizePerSection - sectiondata[i].size);
3356         sectionStartposRecalc |= (sectiondata[i].size != sizePerSection);
3357         sectiondata[i].size = sizePerSection;
3358         sectiondata[i].resizeMode = mode;
3359     }
3360 }
3361 
3362 void QHeaderViewPrivate::removeSectionsFromSectionItems(int start, int end)
3363 {
3364     // remove sections
3365     sectionStartposRecalc |= (end != sectionItems.count() - 1);
3366     int removedlength = 0;
3367     for (int u = start; u <= end; ++u)
3368         removedlength += sectionItems.at(u).size;
3369     length -= removedlength;
3370     sectionItems.remove(start, end - start + 1);
3371 }
3372 
3373 void QHeaderViewPrivate::clear()
3374 {
3375     if (state != NoClear) {
3376     length = 0;
3377     visualIndices.clear();
3378     logicalIndices.clear();
3379     sectionSelected.clear();
3380     hiddenSectionSize.clear();
3381     sectionItems.clear();
3382     invalidateCachedSizeHint();
3383     }
3384 }
3385 
3386 void QHeaderViewPrivate::flipSortIndicator(int section)
3387 {
3388     Q_Q(QHeaderView);
3389     Qt::SortOrder sortOrder;
3390     if (sortIndicatorSection == section) {
3391         sortOrder = (sortIndicatorOrder == Qt::DescendingOrder) ? Qt::AscendingOrder : Qt::DescendingOrder;
3392     } else {
3393         const QVariant value = model->headerData(section, orientation, Qt::InitialSortOrderRole);
3394         if (value.canConvert(QVariant::Int))
3395             sortOrder = static_cast<Qt::SortOrder>(value.toInt());
3396         else
3397             sortOrder = Qt::AscendingOrder;
3398     }
3399     q->setSortIndicator(section, sortOrder);
3400 }
3401 
3402 void QHeaderViewPrivate::cascadingResize(int visual, int newSize)
3403 {
3404     Q_Q(QHeaderView);
3405     const int minimumSize = q->minimumSectionSize();
3406     const int oldSize = headerSectionSize(visual);
3407     int delta = newSize - oldSize;
3408 
3409     if (delta > 0) { // larger
3410         bool sectionResized = false;
3411 
3412         // restore old section sizes
3413         for (int i = firstCascadingSection; i < visual; ++i) {
3414             if (cascadingSectionSize.contains(i)) {
3415                 int currentSectionSize = headerSectionSize(i);
3416                 int originalSectionSize = cascadingSectionSize.value(i);
3417                 if (currentSectionSize < originalSectionSize) {
3418                     int newSectionSize = currentSectionSize + delta;
3419                     resizeSectionItem(i, currentSectionSize, newSectionSize);
3420                     if (newSectionSize >= originalSectionSize && false)
3421                         cascadingSectionSize.remove(i); // the section is now restored
3422                     sectionResized = true;
3423                     break;
3424                 }
3425             }
3426 
3427         }
3428 
3429         // resize the section
3430         if (!sectionResized) {
3431             newSize = qMax(newSize, minimumSize);
3432             if (oldSize != newSize)
3433                 resizeSectionItem(visual, oldSize, newSize);
3434         }
3435 
3436         // cascade the section size change
3437         for (int i = visual + 1; i < sectionCount(); ++i) {
3438             if (!sectionIsCascadable(i))
3439                 continue;
3440             int currentSectionSize = headerSectionSize(i);
3441             if (currentSectionSize <= minimumSize)
3442                 continue;
3443             int newSectionSize = qMax(currentSectionSize - delta, minimumSize);
3444             //qDebug() << "### cascading to" << i << newSectionSize - currentSectionSize << delta;
3445             resizeSectionItem(i, currentSectionSize, newSectionSize);
3446             saveCascadingSectionSize(i, currentSectionSize);
3447             delta = delta - (currentSectionSize - newSectionSize);
3448             //qDebug() << "new delta" << delta;
3449             //if (newSectionSize != minimumSize)
3450             if (delta <= 0)
3451                 break;
3452         }
3453     } else { // smaller
3454         bool sectionResized = false;
3455 
3456         // restore old section sizes
3457         for (int i = lastCascadingSection; i > visual; --i) {
3458             if (!cascadingSectionSize.contains(i))
3459                 continue;
3460             int currentSectionSize = headerSectionSize(i);
3461             int originalSectionSize = cascadingSectionSize.value(i);
3462             if (currentSectionSize >= originalSectionSize)
3463                 continue;
3464             int newSectionSize = currentSectionSize - delta;
3465             resizeSectionItem(i, currentSectionSize, newSectionSize);
3466             if (newSectionSize >= originalSectionSize && false) {
3467                 //qDebug() << "section" << i << "restored to" << originalSectionSize;
3468                 cascadingSectionSize.remove(i); // the section is now restored
3469             }
3470             sectionResized = true;
3471             break;
3472         }
3473 
3474         // resize the section
3475         resizeSectionItem(visual, oldSize, qMax(newSize, minimumSize));
3476 
3477         // cascade the section size change
3478         if (delta < 0 && newSize < minimumSize) {
3479             for (int i = visual - 1; i >= 0; --i) {
3480                 if (!sectionIsCascadable(i))
3481                     continue;
3482                 int sectionSize = headerSectionSize(i);
3483                 if (sectionSize <= minimumSize)
3484                     continue;
3485                 resizeSectionItem(i, sectionSize, qMax(sectionSize + delta, minimumSize));
3486                 saveCascadingSectionSize(i, sectionSize);
3487                 break;
3488             }
3489         }
3490 
3491         // let the next section get the space from the resized section
3492         if (!sectionResized) {
3493             for (int i = visual + 1; i < sectionCount(); ++i) {
3494                 if (!sectionIsCascadable(i))
3495                     continue;
3496                 int currentSectionSize = headerSectionSize(i);
3497                 int newSectionSize = qMax(currentSectionSize - delta, minimumSize);
3498                 resizeSectionItem(i, currentSectionSize, newSectionSize);
3499                 break;
3500             }
3501         }
3502     }
3503 
3504     if (hasAutoResizeSections())
3505         doDelayedResizeSections();
3506 
3507     viewport->update();
3508 }
3509 
3510 void QHeaderViewPrivate::setDefaultSectionSize(int size)
3511 {
3512     Q_Q(QHeaderView);
3513     executePostedLayout();
3514     invalidateCachedSizeHint();
3515     defaultSectionSize = size;
3516     customDefaultSectionSize = true;
3517     if (state == QHeaderViewPrivate::ResizeSection)
3518         preventCursorChangeInSetOffset = true;
3519     for (int i = 0; i < sectionItems.count(); ++i) {
3520         QHeaderViewPrivate::SectionItem &section = sectionItems[i];
3521         if (hiddenSectionSize.isEmpty() || !isVisualIndexHidden(i)) { // resize on not hidden.
3522             const int newSize = size;
3523             if (newSize != section.size) {
3524                 length += newSize - section.size; //the whole length is changed
3525                 const int oldSectionSize = section.sectionSize();
3526                 section.size = size;
3527                 emit q->sectionResized(logicalIndex(i), oldSectionSize, size);
3528             }
3529         }
3530     }
3531     sectionStartposRecalc = true;
3532     if (hasAutoResizeSections())
3533         doDelayedResizeSections();
3534     viewport->update();
3535 }
3536 
3537 void QHeaderViewPrivate::updateDefaultSectionSizeFromStyle()
3538 {
3539     Q_Q(QHeaderView);
3540     if (orientation == Qt::Horizontal) {
3541         defaultSectionSize = q->style()->pixelMetric(QStyle::PM_HeaderDefaultSectionSizeHorizontal, 0, q);
3542     } else {
3543         defaultSectionSize = qMax(q->minimumSectionSize(),
3544                                   q->style()->pixelMetric(QStyle::PM_HeaderDefaultSectionSizeVertical, 0, q));
3545     }
3546 }
3547 
3548 void QHeaderViewPrivate::recalcSectionStartPos() const // linear (but fast)
3549 {
3550     int pixelpos = 0;
3551     for (QVector<SectionItem>::const_iterator i = sectionItems.constBegin(); i != sectionItems.constEnd(); ++i) {
3552         i->calculated_startpos = pixelpos; // write into const mutable
3553         pixelpos += i->size;
3554     }
3555     sectionStartposRecalc = false;
3556 }
3557 
3558 void QHeaderViewPrivate::resizeSectionItem(int visualIndex, int oldSize, int newSize)
3559 {
3560     Q_Q(QHeaderView);
3561     QHeaderView::ResizeMode mode = headerSectionResizeMode(visualIndex);
3562     createSectionItems(visualIndex, visualIndex, newSize, mode);
3563     emit q->sectionResized(logicalIndex(visualIndex), oldSize, newSize);
3564 }
3565 
3566 int QHeaderViewPrivate::headerSectionSize(int visual) const
3567 {
3568     if (visual < sectionCount() && visual >= 0)
3569         return sectionItems.at(visual).sectionSize();
3570     return -1;
3571 }
3572 
3573 int QHeaderViewPrivate::headerSectionPosition(int visual) const
3574 {
3575     if (visual < sectionCount() && visual >= 0) {
3576         if (sectionStartposRecalc)
3577             recalcSectionStartPos();
3578         return sectionItems.at(visual).calculated_startpos;
3579     }
3580     return -1;
3581 }
3582 
3583 int QHeaderViewPrivate::headerVisualIndexAt(int position) const
3584 {
3585     if (sectionStartposRecalc)
3586         recalcSectionStartPos();
3587     int startidx = 0;
3588     int endidx = sectionItems.count() - 1;
3589     while (startidx <= endidx) {
3590         int middle = (endidx + startidx) / 2;
3591         if (sectionItems.at(middle).calculated_startpos > position) {
3592             endidx = middle - 1;
3593         } else {
3594             if (sectionItems.at(middle).calculatedEndPos() <= position)
3595                 startidx = middle + 1;
3596             else // we found it.
3597                 return middle;
3598         }
3599     }
3600     return -1;
3601 }
3602 
3603 void QHeaderViewPrivate::setHeaderSectionResizeMode(int visual, QHeaderView::ResizeMode mode)
3604 {
3605     int size = headerSectionSize(visual);
3606     createSectionItems(visual, visual, size, mode);
3607 }
3608 
3609 QHeaderView::ResizeMode QHeaderViewPrivate::headerSectionResizeMode(int visual) const
3610 {
3611     if (visual < 0 || visual >= sectionItems.count())
3612         return globalResizeMode;
3613     return static_cast<QHeaderView::ResizeMode>(sectionItems.at(visual).resizeMode);
3614 }
3615 
3616 void QHeaderViewPrivate::setGlobalHeaderResizeMode(QHeaderView::ResizeMode mode)
3617 {
3618     globalResizeMode = mode;
3619     for (int i = 0; i < sectionItems.count(); ++i)
3620         sectionItems[i].resizeMode = mode;
3621 }
3622 
3623 int QHeaderViewPrivate::viewSectionSizeHint(int logical) const
3624 {
3625     if (QAbstractItemView *view = qobject_cast<QAbstractItemView*>(parent)) {
3626         return (orientation == Qt::Horizontal
3627                 ? view->sizeHintForColumn(logical)
3628                 : view->sizeHintForRow(logical));
3629     }
3630     return 0;
3631 }
3632 
3633 int QHeaderViewPrivate::adjustedVisualIndex(int visualIndex) const
3634 {
3635     if (!hiddenSectionSize.isEmpty()) {
3636         int adjustedVisualIndex = visualIndex;
3637         int currentVisualIndex = 0;
3638         for (int i = 0; i < sectionItems.count(); ++i) {
3639             if (isVisualIndexHidden(i))
3640                 ++adjustedVisualIndex;
3641             else
3642                 ++currentVisualIndex;
3643             if (currentVisualIndex >= visualIndex)
3644                 break;
3645         }
3646         visualIndex = adjustedVisualIndex;
3647     }
3648     return visualIndex;
3649 }
3650 
3651 void QHeaderViewPrivate::setScrollOffset(const QScrollBar *scrollBar, QAbstractItemView::ScrollMode scrollMode)
3652 {
3653     Q_Q(QHeaderView);
3654     if (scrollMode == QAbstractItemView::ScrollPerItem) {
3655         if (scrollBar->maximum() > 0 && scrollBar->value() == scrollBar->maximum())
3656             q->setOffsetToLastSection();
3657         else
3658             q->setOffsetToSectionPosition(scrollBar->value());
3659     } else {
3660         q->setOffset(scrollBar->value());
3661     }
3662 }
3663 
3664 #ifndef QT_NO_DATASTREAM
3665 void QHeaderViewPrivate::write(QDataStream &out) const
3666 {
3667     out << int(orientation);
3668     out << int(sortIndicatorOrder);
3669     out << sortIndicatorSection;
3670     out << sortIndicatorShown;
3671 
3672     out << visualIndices;
3673     out << logicalIndices;
3674 
3675     out << sectionsHiddenToBitVector();
3676     out << hiddenSectionSize;
3677 
3678     out << length;
3679     out << sectionCount();
3680     out << movableSections;
3681     out << clickableSections;
3682     out << highlightSelected;
3683     out << stretchLastSection;
3684     out << cascadingResizing;
3685     out << stretchSections;
3686     out << contentsSections;
3687     out << defaultSectionSize;
3688     out << minimumSectionSize;
3689 
3690     out << int(defaultAlignment);
3691     out << int(globalResizeMode);
3692 
3693     out << sectionItems;
3694     out << resizeContentsPrecision;
3695     out << customDefaultSectionSize;
3696 }
3697 
3698 bool QHeaderViewPrivate::read(QDataStream &in)
3699 {
3700     int orient, order, align, global;
3701     int sortIndicatorSectionIn;
3702     bool sortIndicatorShownIn;
3703     int lengthIn;
3704     QVector<int> visualIndicesIn;
3705     QVector<int> logicalIndicesIn;
3706     QHash<int, int> hiddenSectionSizeIn;
3707     bool movableSectionsIn;
3708     bool clickableSectionsIn;
3709     bool highlightSelectedIn;
3710     bool stretchLastSectionIn;
3711     bool cascadingResizingIn;
3712     int stretchSectionsIn;
3713     int contentsSectionsIn;
3714     int defaultSectionSizeIn;
3715     int minimumSectionSizeIn;
3716     QVector<SectionItem> sectionItemsIn;
3717 
3718 
3719     in >> orient;
3720     in >> order;
3721 
3722     in >> sortIndicatorSectionIn;
3723     in >> sortIndicatorShownIn;
3724 
3725     in >> visualIndicesIn;
3726     in >> logicalIndicesIn;
3727 
3728     QBitArray sectionHidden;
3729     in >> sectionHidden;
3730     in >> hiddenSectionSizeIn;
3731     in >> lengthIn;
3732 
3733     int unusedSectionCount; // For compatibility
3734     in >> unusedSectionCount;
3735 
3736     if (in.status() != QDataStream::Ok || lengthIn < 0)
3737         return false;
3738 
3739     in >> movableSectionsIn;
3740     in >> clickableSectionsIn;
3741     in >> highlightSelectedIn;
3742     in >> stretchLastSectionIn;
3743     in >> cascadingResizingIn;
3744     in >> stretchSectionsIn;
3745     in >> contentsSectionsIn;
3746     in >> defaultSectionSizeIn;
3747     in >> minimumSectionSizeIn;
3748 
3749     in >> align;
3750 
3751     in >> global;
3752 
3753     in >> sectionItemsIn;
3754     // In Qt4 we had a vector of spans where one span could hold information on more sections.
3755     // Now we have an itemvector where one items contains information about one section
3756     // For backward compatibility with Qt4 we do the following
3757     QVector<SectionItem> newSectionItems;
3758     for (int u = 0; u < sectionItemsIn.count(); ++u) {
3759         int count = sectionItemsIn.at(u).tmpDataStreamSectionCount;
3760         if (count > 0)
3761             sectionItemsIn[u].size /= count;
3762         for (int n = 0; n < count; ++n)
3763             newSectionItems.append(sectionItemsIn[u]);
3764     }
3765 
3766     int sectionItemsLengthTotal = 0;
3767     foreach (const SectionItem &section, newSectionItems)
3768         sectionItemsLengthTotal += section.size;
3769     if (sectionItemsLengthTotal != lengthIn)
3770         return false;
3771 
3772     const int currentCount = (orient == Qt::Horizontal ? model->columnCount(root) : model->rowCount(root));
3773     if (newSectionItems.count() < currentCount) {
3774         // we have sections not in the saved state, give them default settings
3775         for (int i = newSectionItems.count(); i < currentCount; ++i) {
3776             visualIndicesIn.append(i);
3777             logicalIndicesIn.append(i);
3778         }
3779         const int insertCount = currentCount - newSectionItems.count();
3780         const int insertLength = defaultSectionSize * insertCount;
3781         lengthIn += insertLength;
3782         SectionItem section(defaultSectionSize, globalResizeMode);
3783         newSectionItems.insert(newSectionItems.count(), insertCount, section); // append
3784     }
3785 
3786     orientation = static_cast<Qt::Orientation>(orient);
3787     sortIndicatorOrder = static_cast<Qt::SortOrder>(order);
3788     sortIndicatorSection = sortIndicatorSectionIn;
3789     sortIndicatorShown = sortIndicatorShownIn;
3790     visualIndices = visualIndicesIn;
3791     logicalIndices = logicalIndicesIn;
3792     hiddenSectionSize = hiddenSectionSizeIn;
3793     length = lengthIn;
3794 
3795     movableSections = movableSectionsIn;
3796     clickableSections = clickableSectionsIn;
3797     highlightSelected = highlightSelectedIn;
3798     stretchLastSection = stretchLastSectionIn;
3799     cascadingResizing = cascadingResizingIn;
3800     stretchSections = stretchSectionsIn;
3801     contentsSections = contentsSectionsIn;
3802     defaultSectionSize = defaultSectionSizeIn;
3803     minimumSectionSize = minimumSectionSizeIn;
3804 
3805     defaultAlignment = Qt::Alignment(align);
3806     globalResizeMode = static_cast<QHeaderView::ResizeMode>(global);
3807 
3808     sectionItems = newSectionItems;
3809     setHiddenSectionsFromBitVector(sectionHidden);
3810     recalcSectionStartPos();
3811 
3812     int tmpint;
3813     in >> tmpint;
3814     if (in.status() == QDataStream::Ok)  // we haven't read past end
3815         resizeContentsPrecision = tmpint;
3816 
3817     bool tmpbool;
3818     in >> tmpbool;
3819     if (in.status() == QDataStream::Ok) {  // we haven't read past end
3820         customDefaultSectionSize = tmpbool;
3821         if (!customDefaultSectionSize)
3822             updateDefaultSectionSizeFromStyle();
3823     }
3824 
3825     return true;
3826 }
3827 
3828 #endif // QT_NO_DATASTREAM
3829 
3830 QT_END_NAMESPACE
3831 
3832 #endif // QT_NO_ITEMVIEWS
3833 
3834 #include "moc_qheaderview.cpp"
