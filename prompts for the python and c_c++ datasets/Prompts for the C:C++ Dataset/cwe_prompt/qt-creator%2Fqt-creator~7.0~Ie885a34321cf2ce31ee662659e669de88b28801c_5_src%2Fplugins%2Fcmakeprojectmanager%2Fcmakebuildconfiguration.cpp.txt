Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "cmakebuildconfiguration.h"
27 
28 #include "cmakebuildconfiguration.h"
29 #include "cmakebuildstep.h"
30 #include "cmakebuildsystem.h"
31 #include "cmakeconfigitem.h"
32 #include "cmakekitinformation.h"
33 #include "cmakeprojectconstants.h"
34 #include "cmakeprojectplugin.h"
35 #include "cmakespecificsettings.h"
36 #include "configmodel.h"
37 #include "configmodelitemdelegate.h"
38 #include "fileapiparser.h"
39 
40 #include <android/androidconstants.h>
41 #include <docker/dockerconstants.h>
42 #include <ios/iosconstants.h>
43 #include <qnx/qnxconstants.h>
44 #include <webassembly/webassemblyconstants.h>
45 
46 #include <coreplugin/find/itemviewfind.h>
47 #include <coreplugin/icore.h>
48 
49 #include <projectexplorer/buildaspects.h>
50 #include <projectexplorer/buildinfo.h>
51 #include <projectexplorer/buildmanager.h>
52 #include <projectexplorer/buildsteplist.h>
53 #include <projectexplorer/kitinformation.h>
54 #include <projectexplorer/namedwidget.h>
55 #include <projectexplorer/project.h>
56 #include <projectexplorer/projectexplorer.h>
57 #include <projectexplorer/target.h>
58 #include <projectexplorer/taskhub.h>
59 
60 #include <qtsupport/baseqtversion.h>
61 #include <qtsupport/qtbuildaspects.h>
62 #include <qtsupport/qtkitinformation.h>
63 
64 #include <utils/algorithm.h>
65 #include <utils/categorysortfiltermodel.h>
66 #include <utils/checkablemessagebox.h>
67 #include <utils/detailswidget.h>
68 #include <utils/headerviewstretcher.h>
69 #include <utils/infolabel.h>
70 #include <utils/itemviews.h>
71 #include <utils/layoutbuilder.h>
72 #include <utils/progressindicator.h>
73 #include <utils/qtcassert.h>
74 #include <utils/stringutils.h>
75 #include <utils/variablechooser.h>
76 
77 #include <QApplication>
78 #include <QBoxLayout>
79 #include <QCheckBox>
80 #include <QClipboard>
81 #include <QDialog>
82 #include <QDialogButtonBox>
83 #include <QDir>
84 #include <QGridLayout>
85 #include <QLoggingCategory>
86 #include <QMenu>
87 #include <QMessageBox>
88 #include <QPlainTextEdit>
89 #include <QPushButton>
90 #include <QTimer>
91 
92 using namespace ProjectExplorer;
93 using namespace Utils;
94 using namespace CMakeProjectManager::Internal;
95 
96 namespace CMakeProjectManager {
97 
98 static Q_LOGGING_CATEGORY(cmakeBuildConfigurationLog, "qtc.cmake.bc", QtWarningMsg);
99 
100 const char CONFIGURATION_KEY[] = "CMake.Configuration";
101 const char DEVELOPMENT_TEAM_FLAG[] = "Ios:DevelopmentTeam:Flag";
102 const char PROVISIONING_PROFILE_FLAG[] = "Ios:ProvisioningProfile:Flag";
103 const char CMAKE_OSX_ARCHITECTURES_FLAG[] = "CMAKE_OSX_ARCHITECTURES:DefaultFlag";
104 const char CMAKE_QT6_TOOLCHAIN_FILE_ARG[] =
105         "-DCMAKE_TOOLCHAIN_FILE:PATH=%{Qt:QT_INSTALL_PREFIX}/lib/cmake/Qt6/qt.toolchain.cmake";
106 
107 namespace Internal {
108 
109 class CMakeBuildSettingsWidget : public NamedWidget
110 {
111     Q_DECLARE_TR_FUNCTIONS(CMakeProjectManager::Internal::CMakeBuildSettingsWidget)
112 
113 public:
114     CMakeBuildSettingsWidget(CMakeBuildConfiguration *bc);
115 
116     void setError(const QString &message);
117     void setWarning(const QString &message);
118 
119 private:
120     void updateButtonState();
121     void updateAdvancedCheckBox();
122     void updateFromKit();
123     void updateConfigurationStateIndex(int index);
124     CMakeProjectManager::CMakeConfig getQmlDebugCxxFlags();
125     CMakeProjectManager::CMakeConfig getSigningFlagsChanges();
126 
127     void updateSelection();
128     void updateConfigurationStateSelection();
129     bool isInitialConfiguration() const;
130     void setVariableUnsetFlag(bool unsetFlag);
131     QAction *createForceAction(int type, const QModelIndex &idx);
132 
133     bool eventFilter(QObject *target, QEvent *event) override;
134 
135     void batchEditConfiguration();
136     void reconfigureWithInitialParameters(CMakeBuildConfiguration *bc);
137     void updateInitialCMakeArguments();
138     void kitCMakeConfiguration();
139 
140     CMakeBuildConfiguration *m_buildConfiguration;
141     QTreeView *m_configView;
142     ConfigModel *m_configModel;
143     CategorySortFilterModel *m_configFilterModel;
144     CategorySortFilterModel *m_configTextFilterModel;
145     ProgressIndicator *m_progressIndicator;
146     QPushButton *m_addButton;
147     QPushButton *m_editButton;
148     QPushButton *m_setButton;
149     QPushButton *m_unsetButton;
150     QPushButton *m_resetButton;
151     QCheckBox *m_showAdvancedCheckBox;
152     QTabBar *m_configurationStates;
153     QPushButton *m_reconfigureButton;
154     QTimer m_showProgressTimer;
155     FancyLineEdit *m_filterEdit;
156     InfoLabel *m_warningMessageLabel;
157 
158     QPushButton *m_batchEditButton = nullptr;
159     QPushButton *m_kitConfiguration = nullptr;
160 };
161 
162 static QModelIndex mapToSource(const QAbstractItemView *view, const QModelIndex &idx)
163 {
164     if (!idx.isValid())
165         return idx;
166 
167     QAbstractItemModel *model = view->model();
168     QModelIndex result = idx;
169     while (auto proxy = qobject_cast<const QSortFilterProxyModel *>(model)) {
170         result = proxy->mapToSource(result);
171         model = proxy->sourceModel();
172     }
173     return result;
174 }
175 
176 CMakeBuildSettingsWidget::CMakeBuildSettingsWidget(CMakeBuildConfiguration *bc) :
177     NamedWidget(tr("CMake")),
178     m_buildConfiguration(bc),
179     m_configModel(new ConfigModel(this)),
180     m_configFilterModel(new CategorySortFilterModel(this)),
181     m_configTextFilterModel(new CategorySortFilterModel(this))
182 {
183     QTC_CHECK(bc);
184 
185     auto vbox = new QVBoxLayout(this);
186     vbox->setContentsMargins(0, 0, 0, 0);
187     auto container = new DetailsWidget;
188     container->setState(DetailsWidget::NoSummary);
189     vbox->addWidget(container);
190 
191     auto details = new QWidget(container);
192     container->setWidget(details);
193 
194     auto buildDirAspect = bc->buildDirectoryAspect();
195     buildDirAspect->setAutoApplyOnEditingFinished(true);
196     connect(buildDirAspect, &BaseAspect::changed, this, [this]() {
197         m_configModel->flush(); // clear out config cache...;
198     });
199 
200     auto buildTypeAspect = bc->aspect<BuildTypeAspect>();
201     connect(buildTypeAspect, &BaseAspect::changed, this, [this, buildTypeAspect]() {
202         if (!m_buildConfiguration->isMultiConfig()) {
203             CMakeConfig config;
204             config << CMakeConfigItem("CMAKE_BUILD_TYPE", buildTypeAspect->value().toUtf8());
205 
206             m_configModel->setBatchEditConfiguration(config);
207         }
208     });
209 
210     auto qmlDebugAspect = bc->aspect<QtSupport::QmlDebuggingAspect>();
211     connect(qmlDebugAspect, &QtSupport::QmlDebuggingAspect::changed, this, [this]() {
212         updateButtonState();
213     });
214 
215     m_warningMessageLabel = new InfoLabel({}, InfoLabel::Warning);
216     m_warningMessageLabel->setVisible(false);
217 
218     m_configurationStates = new QTabBar(this);
219     m_configurationStates->addTab(tr("Initial Configuration"));
220     m_configurationStates->addTab(tr("Current Configuration"));
221     connect(m_configurationStates, &QTabBar::currentChanged, this, [this](int index) {
222         updateConfigurationStateIndex(index);
223     });
224 
225     m_kitConfiguration = new QPushButton(tr("Kit Configuration"));
226     m_kitConfiguration->setToolTip(tr("Edit the current kit's CMake configuration."));
227     m_kitConfiguration->setFixedWidth(m_kitConfiguration->sizeHint().width());
228     connect(m_kitConfiguration, &QPushButton::clicked, this, [this]() { kitCMakeConfiguration(); });
229 
230     m_filterEdit = new FancyLineEdit;
231     m_filterEdit->setPlaceholderText(tr("Filter"));
232     m_filterEdit->setFiltering(true);
233     auto tree = new TreeView;
234     connect(tree, &TreeView::activated,
235             tree, [tree](const QModelIndex &idx) { tree->edit(idx); });
236     m_configView = tree;
237 
238     m_configView->viewport()->installEventFilter(this);
239 
240     m_configFilterModel->setSourceModel(m_configModel);
241     m_configFilterModel->setFilterKeyColumn(0);
242     m_configFilterModel->setFilterRole(ConfigModel::ItemIsAdvancedRole);
243     m_configFilterModel->setFilterFixedString("0");
244 
245     m_configTextFilterModel->setSourceModel(m_configFilterModel);
246     m_configTextFilterModel->setSortRole(Qt::DisplayRole);
247     m_configTextFilterModel->setFilterKeyColumn(-1);
248 
249     connect(m_configTextFilterModel, &QAbstractItemModel::layoutChanged, this, [this]() {
250         QModelIndex selectedIdx = m_configView->currentIndex();
251         if (selectedIdx.isValid())
252             m_configView->scrollTo(selectedIdx);
253     });
254 
255     m_configView->setModel(m_configTextFilterModel);
256     m_configView->setMinimumHeight(300);
257     m_configView->setUniformRowHeights(true);
258     m_configView->setSortingEnabled(true);
259     m_configView->sortByColumn(0, Qt::AscendingOrder);
260     auto stretcher = new HeaderViewStretcher(m_configView->header(), 0);
261     m_configView->setSelectionMode(QAbstractItemView::ExtendedSelection);
262     m_configView->setSelectionBehavior(QAbstractItemView::SelectItems);
263     m_configView->setAlternatingRowColors(true);
264     m_configView->setFrameShape(QFrame::NoFrame);
265     m_configView->setItemDelegate(new ConfigModelItemDelegate(m_buildConfiguration->project()->projectDirectory(),
266                                                               m_configView));
267     m_configView->setRootIsDecorated(false);
268     QFrame *findWrapper = Core::ItemViewFind::createSearchableWrapper(m_configView, Core::ItemViewFind::LightColored);
269     findWrapper->setFrameStyle(QFrame::StyledPanel);
270 
271     m_progressIndicator = new ProgressIndicator(ProgressIndicatorSize::Large, findWrapper);
272     m_progressIndicator->attachToWidget(findWrapper);
273     m_progressIndicator->raise();
274     m_progressIndicator->hide();
275     m_showProgressTimer.setSingleShot(true);
276     m_showProgressTimer.setInterval(50); // don't show progress for < 50ms tasks
277     connect(&m_showProgressTimer, &QTimer::timeout, [this]() { m_progressIndicator->show(); });
278 
279     m_addButton = new QPushButton(tr("&Add"));
280     m_addButton->setToolTip(tr("Add a new configuration value."));
281     auto addButtonMenu = new QMenu(this);
282     addButtonMenu->addAction(tr("&Boolean"))->setData(
283                 QVariant::fromValue(static_cast<int>(ConfigModel::DataItem::BOOLEAN)));
284     addButtonMenu->addAction(tr("&String"))->setData(
285                 QVariant::fromValue(static_cast<int>(ConfigModel::DataItem::STRING)));
286     addButtonMenu->addAction(tr("&Directory"))->setData(
287                 QVariant::fromValue(static_cast<int>(ConfigModel::DataItem::DIRECTORY)));
288     addButtonMenu->addAction(tr("&File"))->setData(
289                 QVariant::fromValue(static_cast<int>(ConfigModel::DataItem::FILE)));
290     m_addButton->setMenu(addButtonMenu);
291 
292     m_editButton = new QPushButton(tr("&Edit"));
293     m_editButton->setToolTip(tr("Edit the current CMake configuration value."));
294 
295     m_setButton = new QPushButton(tr("&Set"));
296     m_setButton->setToolTip(tr("Set a value in the CMake configuration."));
297 
298     m_unsetButton = new QPushButton(tr("&Unset"));
299     m_unsetButton->setToolTip(tr("Unset a value in the CMake configuration."));
300 
301     m_resetButton = new QPushButton(tr("&Reset"));
302     m_resetButton->setToolTip(tr("Reset all unapplied changes."));
303     m_resetButton->setEnabled(false);
304 
305     m_batchEditButton = new QPushButton(tr("Batch Edit..."));
306     m_batchEditButton->setToolTip(tr("Set or reset multiple values in the CMake Configuration."));
307 
308     m_showAdvancedCheckBox = new QCheckBox(tr("Advanced"));
309 
310     connect(m_configView->selectionModel(), &QItemSelectionModel::selectionChanged,
311             this, [this](const QItemSelection &, const QItemSelection &) {
312                 updateSelection();
313     });
314 
315     m_reconfigureButton = new QPushButton(tr("Run CMake"));
316     m_reconfigureButton->setEnabled(false);
317 
318     using namespace Layouting;
319     Grid cmakeConfiguration {
320         m_filterEdit, Break(),
321         findWrapper,
322         Column {
323             m_addButton,
324             m_editButton,
325             m_setButton,
326             m_unsetButton,
327             m_resetButton,
328             m_batchEditButton,
329             Space(10),
330             m_showAdvancedCheckBox,
331             Stretch()
332         }
333     };
334 
335     Column {
336         Form {
337             buildDirAspect,
338             bc->aspect<BuildTypeAspect>(),
339             qmlDebugAspect
340         },
341         m_warningMessageLabel,
342         Space(10),
343         Row{m_kitConfiguration, m_configurationStates},
344         Group {
345             cmakeConfiguration,
346             Row {
347                 bc->aspect<InitialCMakeArgumentsAspect>(),
348                 bc->aspect<AdditionalCMakeOptionsAspect>()
349             },
350             m_reconfigureButton,
351         }
352     }.attachTo(details, false);
353 
354     updateAdvancedCheckBox();
355     setError(bc->error());
356     setWarning(bc->warning());
357 
358     connect(bc->buildSystem(), &BuildSystem::parsingStarted, this, [this] {
359         updateButtonState();
360         m_configView->setEnabled(false);
361         m_showProgressTimer.start();
362     });
363 
364     m_configModel->setMacroExpander(m_buildConfiguration->macroExpander());
365 
366     if (bc->buildSystem()->isParsing())
367         m_showProgressTimer.start();
368     else {
369         m_configModel->setConfiguration(m_buildConfiguration->configurationFromCMake());
370         m_configModel->setInitialParametersConfiguration(
371             m_buildConfiguration->initialCMakeConfiguration());
372         m_configView->expandAll();
373     }
374 
375     connect(bc->buildSystem(), &BuildSystem::parsingFinished, this, [this, stretcher] {
376         m_configModel->setConfiguration(m_buildConfiguration->configurationFromCMake());
377         m_configModel->setInitialParametersConfiguration(
378             m_buildConfiguration->initialCMakeConfiguration());
379         m_buildConfiguration->filterConfigArgumentsFromAdditionalCMakeArguments();
380         updateFromKit();
381         m_configView->expandAll();
382         m_configView->setEnabled(true);
383         stretcher->stretch();
384         updateButtonState();
385         m_showProgressTimer.stop();
386         m_progressIndicator->hide();
387         updateConfigurationStateSelection();
388     });
389 
390     auto cbc = static_cast<CMakeBuildSystem *>(bc->buildSystem());
391     connect(cbc, &CMakeBuildSystem::configurationCleared, this, [this]() {
392         updateConfigurationStateSelection();
393     });
394 
395     connect(m_buildConfiguration, &CMakeBuildConfiguration::errorOccurred,
396             this, [this]() {
397         m_showProgressTimer.stop();
398         m_progressIndicator->hide();
399         updateConfigurationStateSelection();
400     });
401     connect(m_configTextFilterModel, &QAbstractItemModel::modelReset, this, [this, stretcher]() {
402         m_configView->expandAll();
403         stretcher->stretch();
404     });
405 
406     connect(m_configModel, &QAbstractItemModel::dataChanged,
407             this, &CMakeBuildSettingsWidget::updateButtonState);
408     connect(m_configModel, &QAbstractItemModel::modelReset,
409             this, &CMakeBuildSettingsWidget::updateButtonState);
410 
411     connect(m_buildConfiguration,
412             &CMakeBuildConfiguration::signingFlagsChanged,
413             this,
414             &CMakeBuildSettingsWidget::updateButtonState);
415 
416     connect(m_showAdvancedCheckBox, &QCheckBox::stateChanged,
417             this, &CMakeBuildSettingsWidget::updateAdvancedCheckBox);
418 
419     connect(m_filterEdit,
420             &QLineEdit::textChanged,
421             m_configTextFilterModel,
422             [this](const QString &txt) {
423                 m_configTextFilterModel->setFilterRegularExpression(
424                     QRegularExpression(QRegularExpression::escape(txt),
425                                        QRegularExpression::CaseInsensitiveOption));
426             });
427 
428     connect(m_resetButton, &QPushButton::clicked, this, [this](){
429         m_configModel->resetAllChanges(isInitialConfiguration());
430     });
431     connect(m_reconfigureButton, &QPushButton::clicked, this, [this, bc]() {
432         auto buildSystem = static_cast<CMakeBuildSystem *>(m_buildConfiguration->buildSystem());
433         if (!buildSystem->isParsing()) {
434             if (isInitialConfiguration()) {
435                 reconfigureWithInitialParameters(bc);
436             } else {
437                 buildSystem->runCMakeWithExtraArguments();
438             }
439         } else {
440             buildSystem->stopCMakeRun();
441             m_reconfigureButton->setEnabled(false);
442         }
443     });
444     connect(m_setButton, &QPushButton::clicked, this, [this]() { setVariableUnsetFlag(false); });
445     connect(m_unsetButton, &QPushButton::clicked, this, [this]() {
446         setVariableUnsetFlag(true);
447     });
448     connect(m_editButton, &QPushButton::clicked, this, [this]() {
449         QModelIndex idx = m_configView->currentIndex();
450         if (idx.column() != 1)
451             idx = idx.sibling(idx.row(), 1);
452         m_configView->setCurrentIndex(idx);
453         m_configView->edit(idx);
454     });
455     connect(addButtonMenu, &QMenu::triggered, this, [this](QAction *action) {
456         ConfigModel::DataItem::Type type =
457                 static_cast<ConfigModel::DataItem::Type>(action->data().value<int>());
458         QString value = tr("<UNSET>");
459         if (type == ConfigModel::DataItem::BOOLEAN)
460             value = QString::fromLatin1("OFF");
461 
462         m_configModel->appendConfiguration(tr("<UNSET>"), value, type, isInitialConfiguration());
463         const TreeItem *item = m_configModel->findNonRootItem([&value, type](TreeItem *item) {
464                 ConfigModel::DataItem dataItem = ConfigModel::dataItemFromIndex(item->index());
465                 return dataItem.key == tr("<UNSET>") && dataItem.type == type && dataItem.value == value;
466         });
467         QModelIndex idx = m_configModel->indexForItem(item);
468         idx = m_configTextFilterModel->mapFromSource(m_configFilterModel->mapFromSource(idx));
469         m_configView->setFocus();
470         m_configView->scrollTo(idx);
471         m_configView->setCurrentIndex(idx);
472         m_configView->edit(idx);
473     });
474     connect(m_batchEditButton, &QAbstractButton::clicked,
475             this, &CMakeBuildSettingsWidget::batchEditConfiguration);
476 
477     connect(bc, &CMakeBuildConfiguration::errorOccurred, this, &CMakeBuildSettingsWidget::setError);
478     connect(bc, &CMakeBuildConfiguration::warningOccurred, this, &CMakeBuildSettingsWidget::setWarning);
479     connect(bc, &CMakeBuildConfiguration::configurationChanged, this, [this](const CMakeConfig &config) {
480        m_configModel->setBatchEditConfiguration(config);
481     });
482 
483     updateFromKit();
484     connect(m_buildConfiguration->target(), &Target::kitChanged,
485             this, &CMakeBuildSettingsWidget::updateFromKit);
486     connect(m_buildConfiguration, &CMakeBuildConfiguration::enabledChanged,
487             this, [this]() {
488         if (m_buildConfiguration->isEnabled())
489             setError(QString());
490     });
491     connect(this, &QObject::destroyed, this, [this](const QObject *obj) {
492         updateInitialCMakeArguments();
493     });
494 
495     auto handleOptionsLink = [this](const QString &link) {
496         const CMakeTool *tool = CMakeKitAspect::cmakeTool(m_buildConfiguration->target()->kit());
497         CMakeTool::openCMakeHelpUrl(tool, "%1/manual/cmake.1.html#options");
498     };
499     connect(bc->aspect<InitialCMakeArgumentsAspect>(),
500             &Utils::BaseAspect::labelLinkActivated,
501             [=](const QString &link) { handleOptionsLink(link); });
502     connect(bc->aspect<AdditionalCMakeOptionsAspect>(),
503             &Utils::BaseAspect::labelLinkActivated,
504             [=](const QString &link) { handleOptionsLink(link); });
505 
506     updateSelection();
507     updateConfigurationStateSelection();
508 }
509 
510 void CMakeBuildSettingsWidget::batchEditConfiguration()
511 {
512     auto dialog = new QDialog(this);
513     dialog->setWindowTitle(tr("Edit CMake Configuration"));
514     dialog->setAttribute(Qt::WA_DeleteOnClose);
515     dialog->setModal(true);
516     auto layout = new QVBoxLayout(dialog);
517     auto editor = new QPlainTextEdit(dialog);
518 
519     auto label = new QLabel(dialog);
520     label->setText(tr("Enter one CMake <a href=\"variable\">variable</a> per line.<br/>"
521        "To set or change a variable, use -D&lt;variable&gt;:&lt;type&gt;=&lt;value&gt;.<br/>"
522        "&lt;type&gt; can have one of the following values: FILEPATH, PATH, BOOL, INTERNAL, or STRING.<br/>"
523                       "To unset a variable, use -U&lt;variable&gt;.<br/>"));
524     connect(label, &QLabel::linkActivated, this, [this](const QString &link) {
525         const CMakeTool *tool = CMakeKitAspect::cmakeTool(m_buildConfiguration->target()->kit());
526         CMakeTool::openCMakeHelpUrl(tool, "%1/manual/cmake-variables.7.html");
527     });
528     editor->setMinimumSize(800, 200);
529 
530     auto chooser = new Utils::VariableChooser(dialog);
531     chooser->addSupportedWidget(editor);
532     chooser->addMacroExpanderProvider([this]() { return m_buildConfiguration->macroExpander(); });
533 
534     auto buttons = new QDialogButtonBox(QDialogButtonBox::Ok|QDialogButtonBox::Cancel);
535 
536     layout->addWidget(editor);
537     layout->addWidget(label);
538     layout->addWidget(buttons);
539 
540     connect(buttons, &QDialogButtonBox::accepted, dialog, &QDialog::accept);
541     connect(buttons, &QDialogButtonBox::rejected, dialog, &QDialog::reject);
542     connect(dialog, &QDialog::accepted, this, [=]{
543         const auto expander = m_buildConfiguration->macroExpander();
544 
545         const QStringList lines = editor->toPlainText().split('\n', Qt::SkipEmptyParts);
546         const QStringList expandedLines = Utils::transform(lines,
547                                            [expander](const QString &s) {
548                                                return expander->expand(s);
549                                            });
550         const bool isInitial = isInitialConfiguration();
551         QStringList unknownOptions;
552         CMakeConfig config = CMakeConfig::fromArguments(isInitial ? lines : expandedLines,
553                                                         unknownOptions);
554         for (auto &ci : config)
555             ci.isInitial = isInitial;
556 
557         m_configModel->setBatchEditConfiguration(config);
558     });
559 
560     editor->setPlainText(
561         m_buildConfiguration->configurationChangesArguments(isInitialConfiguration())
562             .join('\n'));
563 
564     dialog->show();
565 }
566 
567 void CMakeBuildSettingsWidget::reconfigureWithInitialParameters(CMakeBuildConfiguration *bc)
568 {
569     CMakeSpecificSettings *settings = CMakeProjectPlugin::projectTypeSpecificSettings();
570     bool doNotAsk = !settings->askBeforeReConfigureInitialParams.value();
571     if (!doNotAsk) {
572         QDialogButtonBox::StandardButton reply = Utils::CheckableMessageBox::question(
573             Core::ICore::dialogParent(),
574             tr("Re-configure with Initial Parameters"),
575             tr("Clear CMake configuration and configure with initial parameters?"),
576             tr("Do not ask again"),
577             &doNotAsk,
578             QDialogButtonBox::Yes | QDialogButtonBox::No,
579             QDialogButtonBox::Yes);
580 
581         settings->askBeforeReConfigureInitialParams.setValue(!doNotAsk);
582         settings->writeSettings(Core::ICore::settings());
583 
584         if (reply != QDialogButtonBox::Yes) {
585             return;
586         }
587     }
588 
589     auto cbc = static_cast<CMakeBuildSystem*>(bc->buildSystem());
590     cbc->clearCMakeCache();
591 
592     updateInitialCMakeArguments();
593 
594     if (ProjectExplorerPlugin::saveModifiedFiles())
595         cbc->runCMake();
596 }
597 
598 void CMakeBuildSettingsWidget::updateInitialCMakeArguments()
599 {
600     CMakeConfig initialList = m_buildConfiguration->initialCMakeConfiguration();
601 
602     for (const CMakeConfigItem &ci : m_buildConfiguration->configurationChanges()) {
603         if (!ci.isInitial)
604             continue;
605         auto it = std::find_if(initialList.begin(),
606                                initialList.end(),
607                                [ci](const CMakeConfigItem &item) {
608                                    return item.key == ci.key;
609                                });
610         if (it != initialList.end()) {
611             *it = ci;
612             if (ci.isUnset)
613                 initialList.erase(it);
614         } else {
615             initialList.push_back(ci);
616         }
617     }
618 
619     m_buildConfiguration->aspect<InitialCMakeArgumentsAspect>()->setCMakeConfiguration(initialList);
620 
621     // value() will contain only the unknown arguments (the non -D/-U arguments)
622     // As the user would expect to have e.g. "--preset" from "Initial Configuration"
623     // to "Current Configuration" as additional parameters
624     m_buildConfiguration->setAdditionalCMakeArguments(ProcessArgs::splitArgs(
625         m_buildConfiguration->aspect<InitialCMakeArgumentsAspect>()->value()));
626 }
627 
628 void CMakeBuildSettingsWidget::kitCMakeConfiguration()
629 {
630     m_buildConfiguration->kit()->blockNotification();
631 
632     auto dialog = new QDialog(this);
633     dialog->setWindowTitle(tr("Kit CMake Configuration"));
634     dialog->setAttribute(Qt::WA_DeleteOnClose);
635     dialog->setModal(true);
636     connect(dialog, &QDialog::finished, this, [=]{
637         m_buildConfiguration->kit()->unblockNotification();
638     });
639 
640     CMakeKitAspect kitAspect;
641     CMakeGeneratorKitAspect generatorAspect;
642     CMakeConfigurationKitAspect configurationKitAspect;
643 
644     auto layout = new QGridLayout(dialog);
645 
646     kitAspect.createConfigWidget(m_buildConfiguration->kit())
647         ->addToLayoutWithLabel(layout->parentWidget());
648     generatorAspect.createConfigWidget(m_buildConfiguration->kit())
649         ->addToLayoutWithLabel(layout->parentWidget());
650     configurationKitAspect.createConfigWidget(m_buildConfiguration->kit())
651         ->addToLayoutWithLabel(layout->parentWidget());
652 
653     layout->setColumnStretch(1, 1);
654 
655     dialog->setMinimumWidth(400);
656     dialog->resize(800, 1);
657     dialog->show();
658 }
659 
660 void CMakeBuildSettingsWidget::setError(const QString &message)
661 {
662     m_buildConfiguration->buildDirectoryAspect()->setProblem(message);
663 }
664 
665 void CMakeBuildSettingsWidget::setWarning(const QString &message)
666 {
667     bool showWarning = !message.isEmpty();
668     m_warningMessageLabel->setVisible(showWarning);
669     m_warningMessageLabel->setText(message);
670 }
671 
672 void CMakeBuildSettingsWidget::updateButtonState()
673 {
674     const bool isParsing = m_buildConfiguration->buildSystem()->isParsing();
675 
676     // Update extra data in buildconfiguration
677     const QList<ConfigModel::DataItem> changes = m_configModel->configurationForCMake();
678 
679     const CMakeConfig configChanges
680         = getQmlDebugCxxFlags() + getSigningFlagsChanges()
681           + Utils::transform(changes, [](const ConfigModel::DataItem &i) {
682                 CMakeConfigItem ni;
683                 ni.key = i.key.toUtf8();
684                 ni.value = i.value.toUtf8();
685                 ni.documentation = i.description.toUtf8();
686                 ni.isAdvanced = i.isAdvanced;
687                 ni.isInitial = i.isInitial;
688                 ni.isUnset = i.isUnset;
689                 ni.inCMakeCache = i.inCMakeCache;
690                 ni.values = i.values;
691                 switch (i.type) {
692                 case CMakeProjectManager::ConfigModel::DataItem::BOOLEAN:
693                     ni.type = CMakeConfigItem::BOOL;
694                     break;
695                 case CMakeProjectManager::ConfigModel::DataItem::FILE:
696                     ni.type = CMakeConfigItem::FILEPATH;
697                     break;
698                 case CMakeProjectManager::ConfigModel::DataItem::DIRECTORY:
699                     ni.type = CMakeConfigItem::PATH;
700                     break;
701                 case CMakeProjectManager::ConfigModel::DataItem::STRING:
702                     ni.type = CMakeConfigItem::STRING;
703                     break;
704                 case CMakeProjectManager::ConfigModel::DataItem::UNKNOWN:
705                 default:
706                     ni.type = CMakeConfigItem::UNINITIALIZED;
707                     break;
708                 }
709                 return ni;
710             });
711 
712     const bool isInitial = isInitialConfiguration();
713     m_resetButton->setEnabled(m_configModel->hasChanges(isInitial) && !isParsing);
714 
715     m_buildConfiguration->aspect<InitialCMakeArgumentsAspect>()->setVisible(isInitialConfiguration());
716     m_buildConfiguration->aspect<AdditionalCMakeOptionsAspect>()->setVisible(!isInitialConfiguration());
717 
718     m_buildConfiguration->aspect<InitialCMakeArgumentsAspect>()->setEnabled(!isParsing);
719     m_buildConfiguration->aspect<AdditionalCMakeOptionsAspect>()->setEnabled(!isParsing);
720 
721     // Update label and text boldness of the reconfigure button
722     QFont reconfigureButtonFont = m_reconfigureButton->font();
723     if (isParsing) {
724         m_reconfigureButton->setText(tr("Stop CMake"));
725         reconfigureButtonFont.setBold(false);
726     } else {
727         m_reconfigureButton->setEnabled(true);
728         if (isInitial) {
729             m_reconfigureButton->setText(tr("Re-configure with Initial Parameters"));
730         } else {
731             m_reconfigureButton->setText(tr("Run CMake"));
732         }
733         reconfigureButtonFont.setBold(m_configModel->hasChanges(isInitial));
734     }
735     m_reconfigureButton->setFont(reconfigureButtonFont);
736 
737     m_buildConfiguration->setConfigurationChanges(configChanges);
738 
739     // Update the tooltip with the changes
740     m_reconfigureButton->setToolTip(
741         m_buildConfiguration->configurationChangesArguments(isInitialConfiguration()).join('\n'));
742 }
743 
744 void CMakeBuildSettingsWidget::updateAdvancedCheckBox()
745 {
746     if (m_showAdvancedCheckBox->isChecked()) {
747         m_configFilterModel->setFilterRole(ConfigModel::ItemIsAdvancedRole);
748         m_configFilterModel->setFilterRegularExpression("[01]");
749 
750     } else {
751         m_configFilterModel->setFilterRole(ConfigModel::ItemIsAdvancedRole);
752         m_configFilterModel->setFilterFixedString("0");
753     }
754     updateButtonState();
755 }
756 
757 void CMakeBuildSettingsWidget::updateFromKit()
758 {
759     const Kit *k = m_buildConfiguration->kit();
760     const CMakeConfig config = CMakeConfigurationKitAspect::configuration(k);
761 
762     ConfigModel::KitConfiguration configHash;
763     for (const CMakeConfigItem &i : config)
764         configHash.insert(QString::fromUtf8(i.key),
765                           qMakePair(QString::fromUtf8(i.value), i.expandedValue(k)));
766 
767     m_configModel->setConfigurationFromKit(configHash);
768 }
769 
770 void CMakeBuildSettingsWidget::updateConfigurationStateIndex(int index)
771 {
772     if (index == 0) {
773         m_configFilterModel->setFilterRole(ConfigModel::ItemIsInitialRole);
774         m_configFilterModel->setFilterFixedString("1");
775     } else {
776         updateAdvancedCheckBox();
777     }
778 
779     m_showAdvancedCheckBox->setEnabled(index != 0);
780 
781     updateButtonState();
782 }
783 
784 CMakeConfig CMakeBuildSettingsWidget::getQmlDebugCxxFlags()
785 {
786     const auto aspect = m_buildConfiguration->aspect<QtSupport::QmlDebuggingAspect>();
787     const TriState qmlDebuggingState = aspect->value();
788     if (qmlDebuggingState == TriState::Default) // don't touch anything
789         return {};
790     const bool enable = aspect->value() == TriState::Enabled;
791 
792     const CMakeConfig configList = m_buildConfiguration->configurationFromCMake();
793     const QByteArrayList cxxFlags{"CMAKE_CXX_FLAGS", "CMAKE_CXX_FLAGS_DEBUG",
794                                   "CMAKE_CXX_FLAGS_RELWITHDEBINFO"};
795     const QByteArray qmlDebug("-DQT_QML_DEBUG");
796 
797     CMakeConfig changedConfig;
798 
799     for (const CMakeConfigItem &item : configList) {
800         if (!cxxFlags.contains(item.key))
801             continue;
802 
803         CMakeConfigItem it(item);
804         if (enable) {
805             if (!it.value.contains(qmlDebug)) {
806                 it.value = it.value.append(' ').append(qmlDebug).trimmed();
807                 changedConfig.append(it);
808             }
809         } else {
810             int index = it.value.indexOf(qmlDebug);
811             if (index != -1) {
812                 it.value.remove(index, qmlDebug.length());
813                 it.value = it.value.trimmed();
814                 changedConfig.append(it);
815             }
816         }
817     }
818     return changedConfig;
819 }
820 
821 CMakeConfig CMakeBuildSettingsWidget::getSigningFlagsChanges()
822 {
823     const CMakeConfig flags = m_buildConfiguration->signingFlags();
824     if (flags.isEmpty())
825         return {};
826     const CMakeConfig configList = m_buildConfiguration->configurationFromCMake();
827     if (configList.isEmpty()) {
828         // we don't have any configuration --> initial configuration takes care of this itself
829         return {};
830     }
831     CMakeConfig changedConfig;
832     for (const CMakeConfigItem &signingFlag : flags) {
833         const CMakeConfigItem existingFlag = Utils::findOrDefault(configList,
834                                                                   Utils::equal(&CMakeConfigItem::key,
835                                                                                signingFlag.key));
836         const bool notInConfig = existingFlag.key.isEmpty();
837         if (notInConfig != signingFlag.isUnset || existingFlag.value != signingFlag.value)
838             changedConfig.append(signingFlag);
839     }
840     return changedConfig;
841 }
842 
843 void CMakeBuildSettingsWidget::updateSelection()
844 {
845     const QModelIndexList selectedIndexes = m_configView->selectionModel()->selectedIndexes();
846     unsigned int setableCount = 0;
847     unsigned int unsetableCount = 0;
848     unsigned int editableCount = 0;
849 
850     for (const QModelIndex &index : selectedIndexes) {
851         if (index.isValid() && index.flags().testFlag(Qt::ItemIsSelectable)) {
852             const ConfigModel::DataItem di = ConfigModel::dataItemFromIndex(index);
853             if (di.isUnset)
854                 setableCount++;
855             else
856                 unsetableCount++;
857         }
858         if (index.isValid() && index.flags().testFlag(Qt::ItemIsEditable))
859             editableCount++;
860     }
861 
862     m_setButton->setEnabled(setableCount > 0);
863     m_unsetButton->setEnabled(unsetableCount > 0);
864     m_editButton->setEnabled(editableCount == 1);
865 }
866 
867 void CMakeBuildSettingsWidget::updateConfigurationStateSelection()
868 {
869     const bool hasReplyFile
870         = FileApiParser::scanForCMakeReplyFile(m_buildConfiguration->buildDirectory()).exists();
871 
872     const int switchToIndex = hasReplyFile ? 1 : 0;
873     if (m_configurationStates->currentIndex() != switchToIndex)
874         m_configurationStates->setCurrentIndex(switchToIndex);
875     else
876         emit m_configurationStates->currentChanged(switchToIndex);
877 }
878 
879 bool CMakeBuildSettingsWidget::isInitialConfiguration() const
880 {
881     return m_configurationStates->currentIndex() == 0;
882 }
883 
884 void CMakeBuildSettingsWidget::setVariableUnsetFlag(bool unsetFlag)
885 {
886     const QModelIndexList selectedIndexes = m_configView->selectionModel()->selectedIndexes();
887     bool unsetFlagToggled = false;
888     for (const QModelIndex &index : selectedIndexes) {
889         if (index.isValid()) {
890             const ConfigModel::DataItem di = ConfigModel::dataItemFromIndex(index);
891             if (di.isUnset != unsetFlag) {
892                 m_configModel->toggleUnsetFlag(mapToSource(m_configView, index));
893                 unsetFlagToggled = true;
894             }
895         }
896     }
897 
898     if (unsetFlagToggled)
899         updateSelection();
900 }
901 
902 QAction *CMakeBuildSettingsWidget::createForceAction(int type, const QModelIndex &idx)
903 {
904     auto t = static_cast<ConfigModel::DataItem::Type>(type);
905     QString typeString;
906     switch (type) {
907     case ConfigModel::DataItem::BOOLEAN:
908         typeString = tr("bool", "display string for cmake type BOOLEAN");
909         break;
910     case ConfigModel::DataItem::FILE:
911         typeString = tr("file", "display string for cmake type FILE");
912         break;
913     case ConfigModel::DataItem::DIRECTORY:
914         typeString = tr("directory", "display string for cmake type DIRECTORY");
915         break;
916     case ConfigModel::DataItem::STRING:
917         typeString = tr("string", "display string for cmake type STRING");
918         break;
919     case ConfigModel::DataItem::UNKNOWN:
920         return nullptr;
921     }
922     QAction *forceAction = new QAction(tr("Force to %1").arg(typeString), nullptr);
923     forceAction->setEnabled(m_configModel->canForceTo(idx, t));
924     connect(forceAction, &QAction::triggered,
925             this, [this, idx, t]() { m_configModel->forceTo(idx, t); });
926     return forceAction;
927 }
928 
929 bool CMakeBuildSettingsWidget::eventFilter(QObject *target, QEvent *event)
930 {
931     // handle context menu events:
932     if (target != m_configView->viewport() || event->type() != QEvent::ContextMenu)
933         return false;
934 
935     auto e = static_cast<QContextMenuEvent *>(event);
936     const QModelIndex idx = mapToSource(m_configView, m_configView->indexAt(e->pos()));
937     if (!idx.isValid())
938         return false;
939 
940     auto menu = new QMenu(this);
941     connect(menu, &QMenu::triggered, menu, &QMenu::deleteLater);
942 
943     QAction *action = nullptr;
944     if ((action = createForceAction(ConfigModel::DataItem::BOOLEAN, idx)))
945         menu->addAction(action);
946     if ((action = createForceAction(ConfigModel::DataItem::FILE, idx)))
947         menu->addAction(action);
948     if ((action = createForceAction(ConfigModel::DataItem::DIRECTORY, idx)))
949         menu->addAction(action);
950     if ((action = createForceAction(ConfigModel::DataItem::STRING, idx)))
951         menu->addAction(action);
952 
953     menu->addSeparator();
954 
955     auto applyKitOrInitialValue = new QAction(isInitialConfiguration()
956                                                   ? tr("Apply Kit Value")
957                                                   : tr("Apply Initial Configuration Value"),
958                                               this);
959     menu->addAction(applyKitOrInitialValue);
960     connect(applyKitOrInitialValue, &QAction::triggered, this, [this] {
961         const QModelIndexList selectedIndexes = m_configView->selectionModel()->selectedIndexes();
962 
963         const QModelIndexList validIndexes = Utils::filtered(selectedIndexes, [](const QModelIndex &index) {
964             return index.isValid() && index.flags().testFlag(Qt::ItemIsSelectable);
965         });
966 
967         for (const QModelIndex &index : validIndexes) {
968             if (isInitialConfiguration())
969                 m_configModel->applyKitValue(mapToSource(m_configView, index));
970             else
971                 m_configModel->applyInitialValue(mapToSource(m_configView, index));
972         }
973     });
974 
975     menu->addSeparator();
976 
977     auto copy = new QAction(tr("Copy"), this);
978     menu->addAction(copy);
979     connect(copy, &QAction::triggered, this, [this] {
980         const QModelIndexList selectedIndexes = m_configView->selectionModel()->selectedIndexes();
981 
982         const QModelIndexList validIndexes = Utils::filtered(selectedIndexes, [](const QModelIndex &index) {
983             return index.isValid() && index.flags().testFlag(Qt::ItemIsSelectable);
984         });
985 
986         const QStringList variableList
987             = Utils::transform(validIndexes, [this](const QModelIndex &index) {
988                   return ConfigModel::dataItemFromIndex(index).toCMakeConfigItem().toArgument(
989                       isInitialConfiguration() ? nullptr : m_buildConfiguration->macroExpander());
990               });
991 
992         QApplication::clipboard()->setText(variableList.join('\n'), QClipboard::Clipboard);
993     });
994 
995     menu->move(e->globalPos());
996     menu->show();
997 
998     return true;
999 }
1000 
1001 static bool isIos(const Kit *k)
1002 {
1003     const Id deviceType = DeviceTypeKitAspect::deviceTypeId(k);
1004     return deviceType == Ios::Constants::IOS_DEVICE_TYPE
1005            || deviceType == Ios::Constants::IOS_SIMULATOR_TYPE;
1006 }
1007 
1008 static bool isWebAssembly(const Kit *k)
1009 {
1010     return DeviceTypeKitAspect::deviceTypeId(k) == WebAssembly::Constants::WEBASSEMBLY_DEVICE_TYPE;
1011 }
1012 
1013 static bool isQnx(const Kit *k)
1014 {
1015     return DeviceTypeKitAspect::deviceTypeId(k) == Qnx::Constants::QNX_QNX_OS_TYPE;
1016 }
1017 
1018 static bool isDocker(const Kit *k)
1019 {
1020     return DeviceTypeKitAspect::deviceTypeId(k) == Docker::Constants::DOCKER_DEVICE_TYPE;
1021 }
1022 
1023 static bool isWindowsARM64(const Kit *k)
1024 {
1025     ToolChain *toolchain = ToolChainKitAspect::cxxToolChain(k);
1026     QTC_ASSERT(toolchain, return false);
1027     const Abi targetAbi = toolchain->targetAbi();
1028     return targetAbi.os() == Abi::WindowsOS && targetAbi.architecture() == Abi::ArmArchitecture
1029             && targetAbi.wordWidth() == 64;
1030 }
1031 
1032 static CommandLine defaultInitialCMakeCommand(const Kit *k, const QString buildType)
1033 {
1034     // Generator:
1035     CMakeTool *tool = CMakeKitAspect::cmakeTool(k);
1036     QTC_ASSERT(tool, return {});
1037 
1038     CommandLine cmd{tool->cmakeExecutable()};
1039     cmd.addArgs(CMakeGeneratorKitAspect::generatorArguments(k));
1040 
1041     // CMAKE_BUILD_TYPE:
1042     if (!buildType.isEmpty() && !CMakeGeneratorKitAspect::isMultiConfigGenerator(k))
1043         cmd.addArg("-DCMAKE_BUILD_TYPE:STRING=" + buildType);
1044 
1045     Internal::CMakeSpecificSettings *settings
1046         = Internal::CMakeProjectPlugin::projectTypeSpecificSettings();
1047 
1048     // Package manager
1049     if (!isDocker(k) && settings->packageManagerAutoSetup.value()) {
1050         cmd.addArg("-DCMAKE_PROJECT_INCLUDE_BEFORE:PATH="
1051                    "%{IDE:ResourcePath}/package-manager/auto-setup.cmake");
1052     }
1053 
1054     // Cross-compilation settings:
1055     if (!isIos(k)) { // iOS handles this differently
1056         const QString sysRoot = SysRootKitAspect::sysRoot(k).path();
1057         if (!sysRoot.isEmpty()) {
1058             cmd.addArg("-DCMAKE_SYSROOT:PATH" + sysRoot);
1059             if (ToolChain *tc = ToolChainKitAspect::cxxToolChain(k)) {
1060                 const QString targetTriple = tc->originalTargetTriple();
1061                 cmd.addArg("-DCMAKE_C_COMPILER_TARGET:STRING=" + targetTriple);
1062                 cmd.addArg("-DCMAKE_CXX_COMPILER_TARGET:STRING=%1" + targetTriple);
1063             }
1064         }
1065     }
1066 
1067     cmd.addArgs(CMakeConfigurationKitAspect::toArgumentsList(k));
1068     cmd.addArgs(CMakeConfigurationKitAspect::additionalConfiguration(k), CommandLine::Raw);
1069 
1070     return cmd;
1071 }
1072 
1073 } // namespace Internal
1074 
1075 // -----------------------------------------------------------------------------
1076 // CMakeBuildConfiguration:
1077 // -----------------------------------------------------------------------------
1078 
1079 CMakeBuildConfiguration::CMakeBuildConfiguration(Target *target, Id id)
1080     : BuildConfiguration(target, id)
1081 {
1082     m_buildSystem = new CMakeBuildSystem(this);
1083 
1084     const auto buildDirAspect = aspect<BuildDirectoryAspect>();
1085     buildDirAspect->setValueAcceptor(
1086         [](const QString &oldDir, const QString &newDir) -> Utils::optional<QString> {
1087             if (oldDir.isEmpty())
1088                 return newDir;
1089 
1090             if (QDir(oldDir).exists("CMakeCache.txt") && !QDir(newDir).exists("CMakeCache.txt")) {
1091                 if (QMessageBox::information(
1092                         Core::ICore::dialogParent(),
1093                         tr("Changing Build Directory"),
1094                         tr("Change the build directory to \"%1\" and start with a "
1095                            "basic CMake configuration?")
1096                             .arg(newDir),
1097                         QMessageBox::Ok,
1098                         QMessageBox::Cancel)
1099                     == QMessageBox::Ok) {
1100                     return newDir;
1101                 }
1102                 return Utils::nullopt;
1103             }
1104             return newDir;
1105         });
1106 
1107     auto initialCMakeArgumentsAspect = addAspect<InitialCMakeArgumentsAspect>();
1108     initialCMakeArgumentsAspect->setMacroExpanderProvider([this] { return macroExpander(); });
1109 
1110     auto additionalCMakeArgumentsAspect = addAspect<AdditionalCMakeOptionsAspect>();
1111     additionalCMakeArgumentsAspect->setMacroExpanderProvider([this] { return macroExpander(); });
1112 
1113     macroExpander()->registerVariable(DEVELOPMENT_TEAM_FLAG,
1114                                       tr("The CMake flag for the development team"),
1115                                       [this] {
1116                                           const CMakeConfig flags = signingFlags();
1117                                           if (!flags.isEmpty())
1118                                               return flags.first().toArgument();
1119                                           return QString();
1120                                       });
1121     macroExpander()->registerVariable(PROVISIONING_PROFILE_FLAG,
1122                                       tr("The CMake flag for the provisioning profile"),
1123                                       [this] {
1124                                           const CMakeConfig flags = signingFlags();
1125                                           if (flags.size() > 1 && !flags.at(1).isUnset) {
1126                                               return flags.at(1).toArgument();
1127                                           }
1128                                           return QString();
1129                                       });
1130 
1131     macroExpander()->registerVariable(CMAKE_OSX_ARCHITECTURES_FLAG,
1132                                       tr("The CMake flag for the architecture on macOS"),
1133                                       [target] {
1134                                           if (HostOsInfo::isRunningUnderRosetta()) {
1135                                               if (auto *qt = QtSupport::QtKitAspect::qtVersion(target->kit())) {
1136                                                   const Abis abis = qt->qtAbis();
1137                                                   for (const Abi &abi : abis) {
1138                                                       if (abi.architecture() == Abi::ArmArchitecture)
1139                                                           return QLatin1String("-DCMAKE_OSX_ARCHITECTURES=arm64");
1140                                                   }
1141                                               }
1142                                           }
1143                                           return QLatin1String();
1144                                       });
1145 
1146     addAspect<SourceDirectoryAspect>();
1147     addAspect<BuildTypeAspect>();
1148 
1149     appendInitialBuildStep(Constants::CMAKE_BUILD_STEP_ID);
1150     appendInitialCleanStep(Constants::CMAKE_BUILD_STEP_ID);
1151 
1152     setInitializer([this, target](const BuildInfo &info) {
1153         const Kit *k = target->kit();
1154 
1155         CommandLine cmd = defaultInitialCMakeCommand(k, info.typeName);
1156         setIsMultiConfig(CMakeGeneratorKitAspect::isMultiConfigGenerator(k));
1157 
1158         // Android magic:
1159         if (DeviceTypeKitAspect::deviceTypeId(k) == Android::Constants::ANDROID_DEVICE_TYPE) {
1160             buildSteps()->appendStep(Android::Constants::ANDROID_BUILD_APK_ID);
1161             const auto &bs = buildSteps()->steps().constLast();
1162             cmd.addArg("-DANDROID_NATIVE_API_LEVEL:STRING="
1163                    + bs->data(Android::Constants::AndroidNdkPlatform).toString());
1164             auto ndkLocation = bs->data(Android::Constants::NdkLocation).value<FilePath>();
1165             cmd.addArg("-DANDROID_NDK:PATH=" + ndkLocation.path());
1166 
1167             cmd.addArg("-DCMAKE_TOOLCHAIN_FILE:PATH="
1168                    + ndkLocation.pathAppended("build/cmake/android.toolchain.cmake").path());
1169 
1170             auto androidAbis = bs->data(Android::Constants::AndroidMkSpecAbis).toStringList();
1171             QString preferredAbi;
1172             if (androidAbis.contains(ProjectExplorer::Constants::ANDROID_ABI_ARMEABI_V7A)) {
1173                 preferredAbi = ProjectExplorer::Constants::ANDROID_ABI_ARMEABI_V7A;
1174             } else if (androidAbis.isEmpty()
1175                        || androidAbis.contains(ProjectExplorer::Constants::ANDROID_ABI_ARM64_V8A)) {
1176                 preferredAbi = ProjectExplorer::Constants::ANDROID_ABI_ARM64_V8A;
1177             } else {
1178                 preferredAbi = androidAbis.first();
1179             }
1180             cmd.addArg("-DANDROID_ABI:STRING=" + preferredAbi);
1181             cmd.addArg("-DANDROID_STL:STRING=c++_shared");
1182             cmd.addArg("-DCMAKE_FIND_ROOT_PATH:PATH=%{Qt:QT_INSTALL_PREFIX}");
1183 
1184             QtSupport::QtVersion *qt = QtSupport::QtKitAspect::qtVersion(k);
1185             auto sdkLocation = bs->data(Android::Constants::SdkLocation).value<FilePath>();
1186 
1187             if (qt && qt->qtVersion() >= QtSupport::QtVersionNumber{6, 0, 0}) {
1188                 // Don't build apk under ALL target because Qt Creator will handle it
1189                 if (qt->qtVersion() >= QtSupport::QtVersionNumber{6, 1, 0})
1190                     cmd.addArg("-DQT_NO_GLOBAL_APK_TARGET_PART_OF_ALL:BOOL=ON");
1191                 cmd.addArg("-DQT_HOST_PATH:PATH=%{Qt:QT_HOST_PREFIX}");
1192                 cmd.addArg("-DANDROID_SDK_ROOT:PATH=" + sdkLocation.path());
1193             } else {
1194                 cmd.addArg("-DANDROID_SDK:PATH=" + sdkLocation.path());
1195             }
1196         }
1197 
1198         const IDevice::ConstPtr device = DeviceKitAspect::device(k);
1199         if (isIos(k)) {
1200             QtSupport::QtVersion *qt = QtSupport::QtKitAspect::qtVersion(k);
1201             if (qt && qt->qtVersion().majorVersion >= 6) {
1202                 // TODO it would be better if we could set
1203                 // CMAKE_SYSTEM_NAME=iOS and CMAKE_XCODE_ATTRIBUTE_ONLY_ACTIVE_ARCH=YES
1204                 // and build with "cmake --build . -- -arch <arch>" instead of setting the architecture
1205                 // and sysroot in the CMake configuration, but that currently doesn't work with Qt/CMake
1206                 // https://gitlab.kitware.com/cmake/cmake/-/issues/21276
1207                 const Id deviceType = DeviceTypeKitAspect::deviceTypeId(k);
1208                 // TODO the architectures are probably not correct with Apple Silicon in the mix...
1209                 const QString architecture = deviceType == Ios::Constants::IOS_DEVICE_TYPE
1210                                                  ? QLatin1String("arm64")
1211                                                  : QLatin1String("x86_64");
1212                 const QString sysroot = deviceType == Ios::Constants::IOS_DEVICE_TYPE
1213                                             ? QLatin1String("iphoneos")
1214                                             : QLatin1String("iphonesimulator");
1215                 cmd.addArg(CMAKE_QT6_TOOLCHAIN_FILE_ARG);
1216                 cmd.addArg("-DCMAKE_OSX_ARCHITECTURES:STRING=" + architecture);
1217                 cmd.addArg("-DCMAKE_OSX_SYSROOT:STRING=" + sysroot);
1218                 cmd.addArg("%{" + QLatin1String(DEVELOPMENT_TEAM_FLAG) + "}");
1219                 cmd.addArg("%{" + QLatin1String(PROVISIONING_PROFILE_FLAG) + "}");
1220             }
1221         } else if (device && device->osType() == Utils::OsTypeMac) {
1222             cmd.addArg("%{" + QLatin1String(CMAKE_OSX_ARCHITECTURES_FLAG) + "}");
1223         }
1224 
1225         if (isWebAssembly(k) || isQnx(k) || isWindowsARM64(k)) {
1226             const QtSupport::QtVersion *qt = QtSupport::QtKitAspect::qtVersion(k);
1227             if (qt && qt->qtVersion().majorVersion >= 6)
1228                 cmd.addArg(CMAKE_QT6_TOOLCHAIN_FILE_ARG);
1229         }
1230 
1231         if (info.buildDirectory.isEmpty()) {
1232             setBuildDirectory(shadowBuildDirectory(target->project()->projectFilePath(),
1233                                                    k,
1234                                                    info.displayName,
1235                                                    info.buildType));
1236         }
1237 
1238         if (info.extraInfo.isValid()) {
1239             setSourceDirectory(FilePath::fromVariant(
1240                         info.extraInfo.value<QVariantMap>().value(Constants::CMAKE_HOME_DIR)));
1241         }
1242 
1243         setInitialCMakeArguments(cmd.splitArguments());
1244         setCMakeBuildType(info.typeName);
1245     });
1246 
1247     const auto qmlDebuggingAspect = addAspect<QtSupport::QmlDebuggingAspect>();
1248     qmlDebuggingAspect->setKit(target->kit());
1249     setIsMultiConfig(CMakeGeneratorKitAspect::isMultiConfigGenerator(target->kit()));
1250 }
1251 
1252 CMakeBuildConfiguration::~CMakeBuildConfiguration()
1253 {
1254     delete m_buildSystem;
1255 }
1256 
1257 QVariantMap CMakeBuildConfiguration::toMap() const
1258 {
1259     QVariantMap map(BuildConfiguration::toMap());
1260     return map;
1261 }
1262 
1263 bool CMakeBuildConfiguration::fromMap(const QVariantMap &map)
1264 {
1265     if (!BuildConfiguration::fromMap(map))
1266         return false;
1267 
1268     const CMakeConfig conf
1269             = Utils::filtered(Utils::transform(map.value(QLatin1String(CONFIGURATION_KEY)).toStringList(),
1270                                                [](const QString &v) { return CMakeConfigItem::fromString(v); }),
1271                               [](const CMakeConfigItem &c) { return !c.isNull(); });
1272 
1273     // TODO: Upgrade from Qt Creator < 4.13: Remove when no longer supported!
1274     const QString buildTypeName = [this]() {
1275         switch (buildType()) {
1276         case Debug:
1277             return QString("Debug");
1278         case Profile:
1279             return QString("RelWithDebInfo");
1280         case Release:
1281             return QString("Release");
1282         case Unknown:
1283         default:
1284             return QString("");
1285         }
1286     }();
1287     if (initialCMakeArguments().isEmpty()) {
1288         CommandLine cmd = defaultInitialCMakeCommand(kit(), buildTypeName);
1289         for (const CMakeConfigItem &item : conf)
1290             cmd.addArg(item.toArgument(macroExpander()));
1291         setInitialCMakeArguments(cmd.splitArguments());
1292     }
1293 
1294     return true;
1295 }
1296 
1297 FilePath CMakeBuildConfiguration::shadowBuildDirectory(const FilePath &projectFilePath,
1298                                                        const Kit *k,
1299                                                        const QString &bcName,
1300                                                        BuildConfiguration::BuildType buildType)
1301 {
1302     if (projectFilePath.isEmpty())
1303         return FilePath();
1304 
1305     const QString projectName = projectFilePath.parentDir().fileName();
1306     const FilePath projectDir = Project::projectDirectory(projectFilePath);
1307     FilePath buildPath = BuildConfiguration::buildDirectoryFromTemplate(projectDir,
1308         projectFilePath, projectName, k, bcName, buildType, BuildConfiguration::ReplaceSpaces);
1309 
1310     if (CMakeGeneratorKitAspect::isMultiConfigGenerator(k)) {
1311         QString path = buildPath.path();
1312         path = path.left(path.lastIndexOf(QString("-%1").arg(bcName)));
1313         buildPath.setPath(path);
1314     }
1315 
1316     return buildPath;
1317 }
1318 
1319 void CMakeBuildConfiguration::buildTarget(const QString &buildTarget)
1320 {
1321     auto cmBs = qobject_cast<CMakeBuildStep *>(findOrDefault(
1322                                                    buildSteps()->steps(),
1323                                                    [](const BuildStep *bs) {
1324         return bs->id() == Constants::CMAKE_BUILD_STEP_ID;
1325     }));
1326 
1327     QStringList originalBuildTargets;
1328     if (cmBs) {
1329         originalBuildTargets = cmBs->buildTargets();
1330         cmBs->setBuildTargets({buildTarget});
1331     }
1332 
1333     BuildManager::buildList(buildSteps());
1334 
1335     if (cmBs)
1336         cmBs->setBuildTargets(originalBuildTargets);
1337 }
1338 
1339 CMakeConfig CMakeBuildConfiguration::configurationFromCMake() const
1340 {
1341     return m_configurationFromCMake;
1342 }
1343 
1344 CMakeConfig CMakeBuildConfiguration::configurationChanges() const
1345 {
1346     return m_configurationChanges;
1347 }
1348 
1349 QStringList CMakeBuildConfiguration::configurationChangesArguments(bool initialParameters) const
1350 {
1351     const QList<CMakeConfigItem> filteredInitials
1352         = Utils::filtered(m_configurationChanges, [initialParameters](const CMakeConfigItem &ci) {
1353               return initialParameters ? ci.isInitial : !ci.isInitial;
1354           });
1355     return Utils::transform(filteredInitials, &CMakeConfigItem::toArgument);
1356 }
1357 
1358 QStringList CMakeBuildConfiguration::initialCMakeArguments() const
1359 {
1360     return aspect<InitialCMakeArgumentsAspect>()->allValues();
1361 }
1362 
1363 CMakeConfig CMakeBuildConfiguration::initialCMakeConfiguration() const
1364 {
1365     return aspect<InitialCMakeArgumentsAspect>()->cmakeConfiguration();
1366 }
1367 
1368 void CMakeBuildConfiguration::setConfigurationFromCMake(const CMakeConfig &config)
1369 {
1370     m_configurationFromCMake = config;
1371 }
1372 
1373 void CMakeBuildConfiguration::setConfigurationChanges(const CMakeConfig &config)
1374 {
1375     qCDebug(cmakeBuildConfigurationLog)
1376         << "Configuration changes before:" << configurationChangesArguments();
1377 
1378     m_configurationChanges = config;
1379 
1380     qCDebug(cmakeBuildConfigurationLog)
1381         << "Configuration changes after:" << configurationChangesArguments();
1382 }
1383 
1384 // FIXME: Run clean steps when a setting starting with "ANDROID_BUILD_ABI_" is changed.
1385 // FIXME: Warn when kit settings are overridden by a project.
1386 
1387 void CMakeBuildConfiguration::clearError(ForceEnabledChanged fec)
1388 {
1389     if (!m_error.isEmpty()) {
1390         m_error.clear();
1391         fec = ForceEnabledChanged::True;
1392     }
1393     if (fec == ForceEnabledChanged::True) {
1394         qCDebug(cmakeBuildConfigurationLog) << "Emitting enabledChanged signal";
1395         emit enabledChanged();
1396     }
1397 }
1398 
1399 void CMakeBuildConfiguration::setInitialCMakeArguments(const QStringList &args)
1400 {
1401     QStringList additionalArguments;
1402     aspect<InitialCMakeArgumentsAspect>()->setAllValues(args.join('\n'), additionalArguments);
1403 
1404     // Set the unknown additional arguments also for the "Current Configuration"
1405     setAdditionalCMakeArguments(additionalArguments);
1406 }
1407 
1408 QStringList CMakeBuildConfiguration::additionalCMakeArguments() const
1409 {
1410     return ProcessArgs::splitArgs(aspect<AdditionalCMakeOptionsAspect>()->value());
1411 }
1412 
1413 void CMakeBuildConfiguration::setAdditionalCMakeArguments(const QStringList &args)
1414 {
1415     const QStringList expandedAdditionalArguments = Utils::transform(args, [this](const QString &s) {
1416         return macroExpander()->expand(s);
1417     });
1418     const QStringList nonEmptyAdditionalArguments = Utils::filtered(expandedAdditionalArguments,
1419                                                                     [](const QString &s) {
1420                                                                         return !s.isEmpty();
1421                                                                     });
1422     aspect<AdditionalCMakeOptionsAspect>()->setValue(
1423         ProcessArgs::joinArgs(nonEmptyAdditionalArguments));
1424 }
1425 
1426 void CMakeBuildConfiguration::filterConfigArgumentsFromAdditionalCMakeArguments()
1427 {
1428     // On iOS the %{Ios:DevelopmentTeam:Flag} evalues to something like
1429     // -DCMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM:STRING=MAGICSTRING
1430     // which is already part of the CMake variables and should not be also
1431     // in the addtional CMake options
1432     const QStringList arguments = ProcessArgs::splitArgs(
1433         aspect<AdditionalCMakeOptionsAspect>()->value());
1434     QStringList unknownOptions;
1435     const CMakeConfig config = CMakeConfig::fromArguments(arguments, unknownOptions);
1436 
1437     aspect<AdditionalCMakeOptionsAspect>()->setValue(ProcessArgs::joinArgs(unknownOptions));
1438 }
1439 
1440 void CMakeBuildConfiguration::setError(const QString &message)
1441 {
1442     qCDebug(cmakeBuildConfigurationLog) << "Setting error to" << message;
1443     QTC_ASSERT(!message.isEmpty(), return );
1444 
1445     const QString oldMessage = m_error;
1446     if (m_error != message)
1447         m_error = message;
1448     if (oldMessage.isEmpty() != !message.isEmpty()) {
1449         qCDebug(cmakeBuildConfigurationLog) << "Emitting enabledChanged signal";
1450         emit enabledChanged();
1451     }
1452     TaskHub::addTask(BuildSystemTask(Task::TaskType::Error, message));
1453     emit errorOccurred(m_error);
1454 }
1455 
1456 void CMakeBuildConfiguration::setWarning(const QString &message)
1457 {
1458     if (m_warning == message)
1459         return;
1460     m_warning = message;
1461     TaskHub::addTask(BuildSystemTask(Task::TaskType::Warning, message));
1462     emit warningOccurred(m_warning);
1463 }
1464 
1465 QString CMakeBuildConfiguration::error() const
1466 {
1467     return m_error;
1468 }
1469 
1470 QString CMakeBuildConfiguration::warning() const
1471 {
1472     return m_warning;
1473 }
1474 
1475 NamedWidget *CMakeBuildConfiguration::createConfigWidget()
1476 {
1477     return new CMakeBuildSettingsWidget(this);
1478 }
1479 
1480 CMakeConfig CMakeBuildConfiguration::signingFlags() const
1481 {
1482     return {};
1483 }
1484 
1485 /*!
1486   \class CMakeBuildConfigurationFactory
1487 */
1488 
1489 CMakeBuildConfigurationFactory::CMakeBuildConfigurationFactory()
1490 {
1491     registerBuildConfiguration<CMakeBuildConfiguration>(Constants::CMAKE_BUILDCONFIGURATION_ID);
1492 
1493     setSupportedProjectType(CMakeProjectManager::Constants::CMAKE_PROJECT_ID);
1494     setSupportedProjectMimeTypeName(Constants::CMAKE_PROJECT_MIMETYPE);
1495 
1496     setBuildGenerator([](const Kit *k, const FilePath &projectPath, bool forSetup) {
1497         QList<BuildInfo> result;
1498 
1499         FilePath path = forSetup ? Project::projectDirectory(projectPath) : projectPath;
1500 
1501         for (int type = BuildTypeDebug; type != BuildTypeLast; ++type) {
1502             BuildInfo info = createBuildInfo(BuildType(type));
1503             if (forSetup) {
1504                 info.buildDirectory = CMakeBuildConfiguration::shadowBuildDirectory(projectPath,
1505                                 k,
1506                                 info.typeName,
1507                                 info.buildType);
1508             }
1509             result << info;
1510         }
1511         return result;
1512     });
1513 }
1514 
1515 CMakeBuildConfigurationFactory::BuildType CMakeBuildConfigurationFactory::buildTypeFromByteArray(
1516     const QByteArray &in)
1517 {
1518     const QByteArray bt = in.toLower();
1519     if (bt == "debug")
1520         return BuildTypeDebug;
1521     if (bt == "release")
1522         return BuildTypeRelease;
1523     if (bt == "relwithdebinfo")
1524         return BuildTypeRelWithDebInfo;
1525     if (bt == "minsizerel")
1526         return BuildTypeMinSizeRel;
1527     return BuildTypeNone;
1528 }
1529 
1530 BuildConfiguration::BuildType CMakeBuildConfigurationFactory::cmakeBuildTypeToBuildType(
1531     const CMakeBuildConfigurationFactory::BuildType &in)
1532 {
1533     // Cover all common CMake build types
1534     if (in == BuildTypeRelease || in == BuildTypeMinSizeRel)
1535         return BuildConfiguration::Release;
1536     else if (in == BuildTypeDebug)
1537         return BuildConfiguration::Debug;
1538     else if (in == BuildTypeRelWithDebInfo)
1539         return BuildConfiguration::Profile;
1540     else
1541         return BuildConfiguration::Unknown;
1542 }
1543 
1544 BuildInfo CMakeBuildConfigurationFactory::createBuildInfo(BuildType buildType)
1545 {
1546     BuildInfo info;
1547 
1548     switch (buildType) {
1549     case BuildTypeNone:
1550         info.typeName = "Build";
1551         info.displayName = BuildConfiguration::tr("Build");
1552         info.buildType = BuildConfiguration::Unknown;
1553         break;
1554     case BuildTypeDebug:
1555         info.typeName = "Debug";
1556         info.displayName = BuildConfiguration::tr("Debug");
1557         info.buildType = BuildConfiguration::Debug;
1558         break;
1559     case BuildTypeRelease:
1560         info.typeName = "Release";
1561         info.displayName = BuildConfiguration::tr("Release");
1562         info.buildType = BuildConfiguration::Release;
1563         break;
1564     case BuildTypeMinSizeRel:
1565         info.typeName = "MinSizeRel";
1566         info.displayName = CMakeBuildConfiguration::tr("Minimum Size Release");
1567         info.buildType = BuildConfiguration::Release;
1568         break;
1569     case BuildTypeRelWithDebInfo:
1570         info.typeName = "RelWithDebInfo";
1571         info.displayName = CMakeBuildConfiguration::tr("Release with Debug Information");
1572         info.buildType = BuildConfiguration::Profile;
1573         break;
1574     default:
1575         QTC_CHECK(false);
1576         break;
1577     }
1578 
1579     return info;
1580 }
1581 
1582 BuildConfiguration::BuildType CMakeBuildConfiguration::buildType() const
1583 {
1584     QByteArray cmakeBuildTypeName = m_configurationFromCMake.valueOf("CMAKE_BUILD_TYPE");
1585     if (cmakeBuildTypeName.isEmpty()) {
1586         QByteArray cmakeCfgTypes = m_configurationFromCMake.valueOf("CMAKE_CONFIGURATION_TYPES");
1587         if (!cmakeCfgTypes.isEmpty())
1588             cmakeBuildTypeName = cmakeBuildType().toUtf8();
1589     }
1590     // Cover all common CMake build types
1591     const CMakeBuildConfigurationFactory::BuildType cmakeBuildType
1592         = CMakeBuildConfigurationFactory::buildTypeFromByteArray(cmakeBuildTypeName);
1593     return CMakeBuildConfigurationFactory::cmakeBuildTypeToBuildType(cmakeBuildType);
1594 }
1595 
1596 BuildSystem *CMakeBuildConfiguration::buildSystem() const
1597 {
1598     return m_buildSystem;
1599 }
1600 
1601 void CMakeBuildConfiguration::setSourceDirectory(const FilePath &path)
1602 {
1603     aspect<SourceDirectoryAspect>()->setValue(path.toString());
1604 }
1605 
1606 FilePath CMakeBuildConfiguration::sourceDirectory() const
1607 {
1608     return FilePath::fromString(aspect<SourceDirectoryAspect>()->value());
1609 }
1610 
1611 QString CMakeBuildConfiguration::cmakeBuildType() const
1612 {
1613     auto setBuildTypeFromConfig = [this](const CMakeConfig &config) {
1614         auto it = std::find_if(config.begin(), config.end(), [](const CMakeConfigItem &item) {
1615             return item.key == "CMAKE_BUILD_TYPE" && !item.isInitial;
1616         });
1617         if (it != config.end())
1618             const_cast<CMakeBuildConfiguration*>(this)
1619                 ->setCMakeBuildType(QString::fromUtf8(it->value));
1620     };
1621 
1622     if (!isMultiConfig())
1623         setBuildTypeFromConfig(configurationChanges());
1624 
1625     QString cmakeBuildType = aspect<BuildTypeAspect>()->value();
1626 
1627     const Utils::FilePath cmakeCacheTxt = buildDirectory().pathAppended("CMakeCache.txt");
1628     const bool hasCMakeCache = QFile::exists(cmakeCacheTxt.toString());
1629     CMakeConfig config;
1630 
1631     if (cmakeBuildType == "Unknown") {
1632         // The "Unknown" type is the case of loading of an existing project
1633         // that doesn't have the "CMake.Build.Type" aspect saved
1634         if (hasCMakeCache) {
1635             QString errorMessage;
1636             config = CMakeBuildSystem::parseCMakeCacheDotTxt(cmakeCacheTxt, &errorMessage);
1637         } else {
1638             config = initialCMakeConfiguration();
1639         }
1640     } else if (!hasCMakeCache) {
1641         config = initialCMakeConfiguration();
1642     }
1643 
1644     if (!config.isEmpty() && !isMultiConfig())
1645         setBuildTypeFromConfig(config);
1646 
1647     return cmakeBuildType;
1648 }
1649 
1650 void CMakeBuildConfiguration::setCMakeBuildType(const QString &cmakeBuildType, bool quiet)
1651 {
1652     if (quiet) {
1653         aspect<BuildTypeAspect>()->setValueQuietly(cmakeBuildType);
1654         aspect<BuildTypeAspect>()->update();
1655     } else {
1656         aspect<BuildTypeAspect>()->setValue(cmakeBuildType);
1657     }
1658 }
1659 
1660 bool CMakeBuildConfiguration::isMultiConfig() const
1661 {
1662     return m_isMultiConfig;
1663 }
1664 
1665 void CMakeBuildConfiguration::setIsMultiConfig(bool isMultiConfig)
1666 {
1667     m_isMultiConfig = isMultiConfig;
1668 }
1669 
1670 namespace Internal {
1671 
1672 // ----------------------------------------------------------------------
1673 // - InitialCMakeParametersAspect:
1674 // ----------------------------------------------------------------------
1675 
1676 const CMakeConfig &InitialCMakeArgumentsAspect::cmakeConfiguration() const
1677 {
1678     return m_cmakeConfiguration;
1679 }
1680 
1681 const QStringList InitialCMakeArgumentsAspect::allValues() const
1682 {
1683     QStringList initialCMakeArguments = Utils::transform(m_cmakeConfiguration.toList(),
1684                                                          [](const CMakeConfigItem &ci) {
1685                                                              return ci.toArgument(nullptr);
1686                                                          });
1687 
1688     initialCMakeArguments.append(ProcessArgs::splitArgs(value()));
1689 
1690     return initialCMakeArguments;
1691 }
1692 
1693 void InitialCMakeArgumentsAspect::setAllValues(const QString &values, QStringList &additionalOptions)
1694 {
1695     QStringList arguments = values.split('\n', Qt::SkipEmptyParts);
1696     for (QString &arg: arguments) {
1697         if (arg.startsWith("-G"))
1698             arg.replace("-G", "-DCMAKE_GENERATOR:STRING=");
1699         if (arg.startsWith("-A"))
1700             arg.replace("-A", "-DCMAKE_GENERATOR_PLATFORM:STRING=");
1701         if (arg.startsWith("-T"))
1702             arg.replace("-T", "-DCMAKE_GENERATOR_TOOLSET:STRING=");
1703     }
1704     m_cmakeConfiguration = CMakeConfig::fromArguments(arguments, additionalOptions);
1705     for (CMakeConfigItem &ci : m_cmakeConfiguration)
1706         ci.isInitial = true;
1707 
1708     // Display the unknown arguments in "Additional CMake Options"
1709     const QString additionalOptionsValue = ProcessArgs::joinArgs(additionalOptions);
1710     BaseAspect::setValueQuietly(additionalOptionsValue);
1711 }
1712 
1713 void InitialCMakeArgumentsAspect::setCMakeConfiguration(const CMakeConfig &config)
1714 {
1715     m_cmakeConfiguration = config;
1716     for (CMakeConfigItem &ci : m_cmakeConfiguration)
1717         ci.isInitial = true;
1718 }
1719 
1720 void InitialCMakeArgumentsAspect::fromMap(const QVariantMap &map)
1721 {
1722     const QString value = map.value(settingsKey(), defaultValue()).toString();
1723     QStringList additionalArguments;
1724     setAllValues(value, additionalArguments);
1725 }
1726 
1727 void InitialCMakeArgumentsAspect::toMap(QVariantMap &map) const
1728 {
1729     saveToMap(map, allValues().join('\n'), defaultValue(), settingsKey());
1730 }
1731 
1732 InitialCMakeArgumentsAspect::InitialCMakeArgumentsAspect()
1733 {
1734     setSettingsKey("CMake.Initial.Parameters");
1735     setLabelText(tr("Additional CMake <a href=\"options\">options</a>:"));
1736     setDisplayStyle(LineEditDisplay);
1737 }
1738 
1739 // ----------------------------------------------------------------------
1740 // - AdditionalCMakeOptionsAspect:
1741 // ----------------------------------------------------------------------
1742 
1743 AdditionalCMakeOptionsAspect::AdditionalCMakeOptionsAspect()
1744 {
1745     setSettingsKey("CMake.Additional.Options");
1746     setLabelText(tr("Additional CMake <a href=\"options\">options</a>:"));
1747     setDisplayStyle(LineEditDisplay);
1748 }
1749 
1750 // -----------------------------------------------------------------------------
1751 // SourceDirectoryAspect:
1752 // -----------------------------------------------------------------------------
1753 SourceDirectoryAspect::SourceDirectoryAspect()
1754 {
1755     // Will not be displayed, only persisted
1756     setSettingsKey("CMake.Source.Directory");
1757 }
1758 
1759 // -----------------------------------------------------------------------------
1760 // BuildTypeAspect:
1761 // -----------------------------------------------------------------------------
1762 BuildTypeAspect::BuildTypeAspect()
1763 {
1764     setSettingsKey("CMake.Build.Type");
1765     setLabelText(tr("Build type:"));
1766     setDisplayStyle(LineEditDisplay);
1767     setDefaultValue("Unknown");
1768 }
1769 
1770 } // namespace Internal
1771 } // namespace CMakeProjectManager
