Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2014 Jeremy Lain√© <jeremy.laine@m4x.org>
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtNetwork module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qsslsocket.h"
41 
42 #include "qssl_p.h"
43 #include "qsslsocket_mac_p.h"
44 #include "qasn1element_p.h"
45 #include "qsslcertificate_p.h"
46 #include "qsslcipher_p.h"
47 #include "qsslkey_p.h"
48 
49 #include <QtCore/qmessageauthenticationcode.h>
50 #include <QtCore/qcryptographichash.h>
51 #include <QtCore/qdatastream.h>
52 #include <QtCore/qsysinfo.h>
53 #include <QtCore/qvector.h>
54 #include <QtCore/qmutex.h>
55 #include <QtCore/qdebug.h>
56 #include <QtCore/quuid.h>
57 #include <QtCore/qdir.h>
58 
59 #include <algorithm>
60 #include <cstddef>
61 #include <vector>
62 
63 #include <QtCore/private/qcore_mac_p.h>
64 
65 #ifdef Q_OS_OSX
66 #include <CoreServices/CoreServices.h>
67 #endif
68 
69 QT_BEGIN_NAMESPACE
70 
71 namespace
72 {
73 
74 const QString qtSecureTransportPassPhrase(QString::fromLatin1("foobar"));
75 
76 /*
77 
78 Custom keychain is needed only on macOS where SecPKCS12Import changes the default
79 keychain and where we see annoying pop-ups asking about accessing private key.
80 On iOS SecPKCS12Import does not have these problems.
81 
82 */
83 #ifdef Q_OS_MACOS
84 
85 struct CustomSecKeychain
86 {
87     CustomSecKeychain();
88     ~CustomSecKeychain();
89 
90     SecKeychainRef keychain = nullptr;
91     Q_DISABLE_COPY(CustomSecKeychain)
92 };
93 
94 CustomSecKeychain::CustomSecKeychain()
95 {
96     const auto uuid = QUuid::createUuid();
97     if (uuid.isNull()) {
98         qCWarning(lcSsl) << "Failed to create an unique keychain name";
99         return;
100     }
101 
102     QString uuidAsString(uuid.toString());
103     Q_ASSERT(uuidAsString.size() > 2);
104     // Cut '{' and '}':
105     uuidAsString = uuidAsString.mid(1, uuidAsString.size() - 2);
106 
107     QString keychainName(QDir::tempPath());
108     keychainName.append(QDir::separator());
109     keychainName += uuidAsString;
110     keychainName += QLatin1String(".keychain");
111     // SecKeychainCreate, pathName parameter:
112     //
113     // "A constant character string representing the POSIX path indicating where
114     // to store the keychain."
115     //
116     // Internally they seem to use std::string, but this does not really help.
117     // Fortunately, CFString has a convenient API.
118     QCFType<CFStringRef> cfName = keychainName.toCFString();
119     std::vector<char> posixPath;
120     // "Extracts the contents of a string as a NULL-terminated 8-bit string
121     // appropriate for passing to POSIX APIs."
122     posixPath.resize(CFStringGetMaximumSizeOfFileSystemRepresentation(cfName));
123     const auto ok = CFStringGetFileSystemRepresentation(cfName, &posixPath[0],
124                                                         CFIndex(posixPath.size()));
125     if (!ok) {
126         qCWarning(lcSsl) << "Failed to create an unique keychain name from"
127                          << "QDir::tempPath()";
128         return;
129     }
130 
131     const QByteArray passUtf8(qtSecureTransportPassPhrase.toUtf8());
132     const OSStatus status = SecKeychainCreate(&posixPath[0], passUtf8.size(),
133                                               passUtf8.constData(), FALSE, nullptr,
134                                               &keychain);
135     if (status != errSecSuccess || !keychain) {
136         qCWarning(lcSsl) << "SecKeychainCreate: failed to create a custom keychain";
137         if (keychain) {
138             SecKeychainDelete(keychain);
139             CFRelease(keychain);
140             keychain = nullptr;
141         }
142     }
143 
144 #ifdef QSSLSOCKET_DEBUG
145     if (keychain) {
146         qCDebug(lcSsl) << "Custom keychain with name" << keychainName << "was created"
147                        << "successfully";
148     }
149 #endif
150 }
151 
152 CustomSecKeychain::~CustomSecKeychain()
153 {
154     if (keychain) {
155         SecKeychainDelete(keychain);
156         CFRelease(keychain);
157     }
158 }
159 
160 Q_GLOBAL_STATIC(CustomSecKeychain, qtCustomKeychain)
161 
162 #endif // Q_OS_MACOS
163 
164 }
165 
166 
167 
168 static SSLContextRef qt_createSecureTransportContext(QSslSocket::SslMode mode)
169 {
170     const bool isServer = mode == QSslSocket::SslServerMode;
171     const SSLProtocolSide side = isServer ? kSSLServerSide : kSSLClientSide;
172     // We never use kSSLDatagramType, so it's kSSLStreamType unconditionally.
173     SSLContextRef context = SSLCreateContext(Q_NULLPTR, side, kSSLStreamType);
174     if (!context)
175         qCWarning(lcSsl) << "SSLCreateContext failed";
176     return context;
177 }
178 
179 static void qt_releaseSecureTransportContext(SSLContextRef context)
180 {
181     if (context)
182         CFRelease(context);
183 }
184 
185 QSecureTransportContext::QSecureTransportContext(SSLContextRef c)
186     : context(c)
187 {
188 }
189 
190 QSecureTransportContext::~QSecureTransportContext()
191 {
192     qt_releaseSecureTransportContext(context);
193 }
194 
195 QSecureTransportContext::operator SSLContextRef()const
196 {
197     return context;
198 }
199 
200 void QSecureTransportContext::reset(SSLContextRef newContext)
201 {
202     qt_releaseSecureTransportContext(context);
203     context = newContext;
204 }
205 
206 Q_GLOBAL_STATIC_WITH_ARGS(QMutex, qt_securetransport_mutex, (QMutex::Recursive))
207 
208 //#define QSSLSOCKET_DEBUG
209 
210 bool QSslSocketPrivate::s_libraryLoaded = false;
211 bool QSslSocketPrivate::s_loadedCiphersAndCerts = false;
212 bool QSslSocketPrivate::s_loadRootCertsOnDemand = false;
213 
214 
215 #if !defined(QT_PLATFORM_UIKIT) // dhparam is only used on macOS. (see the SSLSetDiffieHellmanParams call below)
216 static const uint8_t dhparam[] =
217     "\x30\x82\x01\x08\x02\x82\x01\x01\x00\x97\xea\xd0\x46\xf7\xae\xa7\x76\x80"
218     "\x9c\x74\x56\x98\xd8\x56\x97\x2b\x20\x6c\x77\xe2\x82\xbb\xc8\x84\xbe\xe7"
219     "\x63\xaf\xcc\x30\xd0\x67\x97\x7d\x1b\xab\x59\x30\xa9\x13\x67\x21\xd7\xd4"
220     "\x0e\x46\xcf\xe5\x80\xdf\xc9\xb9\xba\x54\x9b\x46\x2f\x3b\x45\xfc\x2f\xaf"
221     "\xad\xc0\x17\x56\xdd\x52\x42\x57\x45\x70\x14\xe5\xbe\x67\xaa\xde\x69\x75"
222     "\x30\x0d\xf9\xa2\xc4\x63\x4d\x7a\x39\xef\x14\x62\x18\x33\x44\xa1\xf9\xc1"
223     "\x52\xd1\xb6\x72\x21\x98\xf8\xab\x16\x1b\x7b\x37\x65\xe3\xc5\x11\x00\xf6"
224     "\x36\x1f\xd8\x5f\xd8\x9f\x43\xa8\xce\x9d\xbf\x5e\xd6\x2d\xfa\x0a\xc2\x01"
225     "\x54\xc2\xd9\x81\x54\x55\xb5\x26\xf8\x88\x37\xf5\xfe\xe0\xef\x4a\x34\x81"
226     "\xdc\x5a\xb3\x71\x46\x27\xe3\xcd\x24\xf6\x1b\xf1\xe2\x0f\xc2\xa1\x39\x53"
227     "\x5b\xc5\x38\x46\x8e\x67\x4c\xd9\xdd\xe4\x37\x06\x03\x16\xf1\x1d\x7a\xba"
228     "\x2d\xc1\xe4\x03\x1a\x58\xe5\x29\x5a\x29\x06\x69\x61\x7a\xd8\xa9\x05\x9f"
229     "\xc1\xa2\x45\x9c\x17\xad\x52\x69\x33\xdc\x18\x8d\x15\xa6\x5e\xcd\x94\xf4"
230     "\x45\xbb\x9f\xc2\x7b\x85\x00\x61\xb0\x1a\xdc\x3c\x86\xaa\x9f\x5c\x04\xb3"
231     "\x90\x0b\x35\x64\xff\xd9\xe3\xac\xf2\xf2\xeb\x3a\x63\x02\x01\x02";
232 #endif
233 
234 // No ioErr on iOS/tvOS/watchOS. (defined in MacErrors.h on macOS)
235 #if defined(QT_PLATFORM_UIKIT)
236 #  define ioErr -36
237 #endif
238 
239 static OSStatus _q_SSLRead(QTcpSocket *plainSocket, char *data, size_t *dataLength)
240 {
241     Q_ASSERT(plainSocket);
242     Q_ASSERT(data);
243     Q_ASSERT(dataLength);
244 
245     const qint64 bytes = plainSocket->read(data, *dataLength);
246 #ifdef QSSLSOCKET_DEBUG
247     qCDebug(lcSsl) << plainSocket << "read" << bytes;
248 #endif
249     if (bytes < 0) {
250         *dataLength = 0;
251         return ioErr;
252     }
253 
254     const OSStatus err = (size_t(bytes) < *dataLength) ? errSSLWouldBlock : noErr;
255     *dataLength = bytes;
256 
257     return err;
258 }
259 
260 static OSStatus _q_SSLWrite(QTcpSocket *plainSocket, const char *data, size_t *dataLength)
261 {
262     Q_ASSERT(plainSocket);
263     Q_ASSERT(data);
264     Q_ASSERT(dataLength);
265 
266     const qint64 bytes = plainSocket->write(data, *dataLength);
267 #ifdef QSSLSOCKET_DEBUG
268     qCDebug(lcSsl) << plainSocket << "write" << bytes;
269 #endif
270     if (bytes < 0) {
271         *dataLength = 0;
272         return ioErr;
273     }
274 
275     const OSStatus err = (size_t(bytes) < *dataLength) ? errSSLWouldBlock : noErr;
276     *dataLength = bytes;
277 
278     return err;
279 }
280 
281 void QSslSocketPrivate::ensureInitialized()
282 {
283     const QMutexLocker locker(qt_securetransport_mutex);
284     if (s_loadedCiphersAndCerts)
285         return;
286 
287     // We have to set it before setDefaultSupportedCiphers,
288     // since this function can trigger static (global)'s initialization
289     // and as a result - recursive ensureInitialized call
290     // from QSslCertificatePrivate's ctor.
291     s_loadedCiphersAndCerts = true;
292 
293     const QSecureTransportContext context(qt_createSecureTransportContext(QSslSocket::SslClientMode));
294     if (context) {
295         QList<QSslCipher> ciphers;
296         QList<QSslCipher> defaultCiphers;
297 
298         size_t numCiphers = 0;
299         // Fails only if any of parameters is null.
300         SSLGetNumberSupportedCiphers(context, &numCiphers);
301         QVector<SSLCipherSuite> cfCiphers(numCiphers);
302         // Fails only if any of parameter is null or number of ciphers is wrong.
303         SSLGetSupportedCiphers(context, cfCiphers.data(), &numCiphers);
304 
305         for (size_t i = 0; i < size_t(cfCiphers.size()); ++i) {
306             const QSslCipher ciph(QSslSocketBackendPrivate::QSslCipher_from_SSLCipherSuite(cfCiphers.at(i)));
307             if (!ciph.isNull()) {
308                 ciphers << ciph;
309                 if (ciph.usedBits() >= 128)
310                     defaultCiphers << ciph;
311             }
312         }
313 
314         setDefaultSupportedCiphers(ciphers);
315         setDefaultCiphers(defaultCiphers);
316 
317         if (!s_loadRootCertsOnDemand)
318             setDefaultCaCertificates(systemCaCertificates());
319     } else {
320         s_loadedCiphersAndCerts = false;
321     }
322 
323 }
324 
325 long QSslSocketPrivate::sslLibraryVersionNumber()
326 {
327     return 0;
328 }
329 
330 QString QSslSocketPrivate::sslLibraryVersionString()
331 {
332     return QLatin1String("Secure Transport, ") + QSysInfo::prettyProductName();
333 }
334 
335 long QSslSocketPrivate::sslLibraryBuildVersionNumber()
336 {
337     return 0;
338 }
339 
340 QString QSslSocketPrivate::sslLibraryBuildVersionString()
341 {
342     return sslLibraryVersionString();
343 }
344 
345 bool QSslSocketPrivate::supportsSsl()
346 {
347     return true;
348 }
349 
350 void QSslSocketPrivate::resetDefaultCiphers()
351 {
352     Q_UNIMPLEMENTED();
353 }
354 
355 void QSslSocketPrivate::resetDefaultEllipticCurves()
356 {
357     // No public API for this (?).
358     Q_UNIMPLEMENTED();
359 }
360 
361 QSslSocketBackendPrivate::QSslSocketBackendPrivate()
362     : context(Q_NULLPTR)
363 {
364 }
365 
366 QSslSocketBackendPrivate::~QSslSocketBackendPrivate()
367 {
368     destroySslContext();
369 }
370 
371 void QSslSocketBackendPrivate::continueHandshake()
372 {
373 #ifdef QSSLSOCKET_DEBUG
374     qCDebug(lcSsl) << plainSocket << "connection encrypted";
375 #endif
376     Q_Q(QSslSocket);
377     connectionEncrypted = true;
378     emit q->encrypted();
379     if (autoStartHandshake && pendingClose) {
380         pendingClose = false;
381         q->disconnectFromHost();
382     }
383 }
384 
385 void QSslSocketBackendPrivate::disconnected()
386 {
387     if (plainSocket->bytesAvailable() <= 0)
388         destroySslContext();
389     // If there is still buffered data in the plain socket, don't destroy the ssl context yet.
390     // It will be destroyed when the socket is deleted.
391 }
392 
393 void QSslSocketBackendPrivate::disconnectFromHost()
394 {
395     if (context) {
396         if (!shutdown) {
397             SSLClose(context);
398             shutdown = true;
399         }
400     }
401     plainSocket->disconnectFromHost();
402 }
403 
404 QSslCipher QSslSocketBackendPrivate::sessionCipher() const
405 {
406     SSLCipherSuite cipher = 0;
407     if (context && SSLGetNegotiatedCipher(context, &cipher) == noErr)
408         return QSslCipher_from_SSLCipherSuite(cipher);
409 
410     return QSslCipher();
411 }
412 
413 QSsl::SslProtocol QSslSocketBackendPrivate::sessionProtocol() const
414 {
415     if (!context)
416         return QSsl::UnknownProtocol;
417 
418     SSLProtocol protocol = kSSLProtocolUnknown;
419     const OSStatus err = SSLGetNegotiatedProtocolVersion(context, &protocol);
420     if (err != noErr) {
421         qCWarning(lcSsl) << "SSLGetNegotiatedProtocolVersion failed:" << err;
422         return QSsl::UnknownProtocol;
423     }
424 
425     switch (protocol) {
426     case kSSLProtocol2:
427         return QSsl::SslV2;
428     case kSSLProtocol3:
429         return QSsl::SslV3;
430     case kTLSProtocol1:
431         return QSsl::TlsV1_0;
432     case kTLSProtocol11:
433         return QSsl::TlsV1_1;
434     case kTLSProtocol12:
435         return QSsl::TlsV1_2;
436     default:
437         return QSsl::UnknownProtocol;
438     }
439 }
440 
441 void QSslSocketBackendPrivate::startClientEncryption()
442 {
443     if (!initSslContext()) {
444         // Error description/code were set, 'error' emitted
445         // by initSslContext, but OpenSSL socket also sets error
446         // emits a signal twice, so ...
447         setErrorAndEmit(QAbstractSocket::SslInternalError, QStringLiteral("Unable to init SSL Context"));
448         return;
449     }
450 
451     startHandshake();
452 }
453 
454 void QSslSocketBackendPrivate::startServerEncryption()
455 {
456     if (!initSslContext()) {
457         // Error description/code were set, 'error' emitted
458         // by initSslContext, but OpenSSL socket also sets error
459         // emits a signal twice, so ...
460         setErrorAndEmit(QAbstractSocket::SslInternalError, QStringLiteral("Unable to init SSL Context"));
461         return;
462     }
463 
464     startHandshake();
465 }
466 
467 void QSslSocketBackendPrivate::transmit()
468 {
469     Q_Q(QSslSocket);
470 
471     // If we don't have any SSL context, don't bother transmitting.
472     // Edit: if SSL session closed, don't bother either.
473     if (!context || shutdown)
474         return;
475 
476     if (!connectionEncrypted)
477         startHandshake();
478 
479     if (connectionEncrypted && !writeBuffer.isEmpty()) {
480         qint64 totalBytesWritten = 0;
481         while (writeBuffer.nextDataBlockSize() > 0 && context) {
482             const size_t nextDataBlockSize = writeBuffer.nextDataBlockSize();
483             size_t writtenBytes = 0;
484             const OSStatus err = SSLWrite(context, writeBuffer.readPointer(), nextDataBlockSize, &writtenBytes);
485 #ifdef QSSLSOCKET_DEBUG
486             qCDebug(lcSsl) << plainSocket << "SSLWrite returned" << err;
487 #endif
488             if (err != noErr && err != errSSLWouldBlock) {
489                 setErrorAndEmit(QAbstractSocket::SslInternalError,
490                                 QStringLiteral("SSLWrite failed: %1").arg(err));
491                 break;
492             }
493 
494             if (writtenBytes) {
495                 writeBuffer.free(writtenBytes);
496                 totalBytesWritten += writtenBytes;
497             }
498 
499             if (writtenBytes < nextDataBlockSize)
500                 break;
501         }
502 
503         if (totalBytesWritten > 0) {
504             // Don't emit bytesWritten() recursively.
505             if (!emittedBytesWritten) {
506                 emittedBytesWritten = true;
507                 emit q->bytesWritten(totalBytesWritten);
508                 emittedBytesWritten = false;
509             }
510             emit q->channelBytesWritten(0, totalBytesWritten);
511         }
512     }
513 
514     if (connectionEncrypted) {
515         QVarLengthArray<char, 4096> data;
516         while (context && (!readBufferMaxSize || buffer.size() < readBufferMaxSize)) {
517             size_t readBytes = 0;
518             data.resize(4096);
519             const OSStatus err = SSLRead(context, data.data(), data.size(), &readBytes);
520 #ifdef QSSLSOCKET_DEBUG
521             qCDebug(lcSsl) << plainSocket << "SSLRead returned" << err;
522 #endif
523             if (err == errSSLClosedGraceful) {
524                 shutdown = true; // the other side shut down, make sure we do not send shutdown ourselves
525                 setErrorAndEmit(QAbstractSocket::RemoteHostClosedError,
526                                 QSslSocket::tr("The TLS/SSL connection has been closed"));
527                 break;
528             } else if (err != noErr && err != errSSLWouldBlock) {
529                 setErrorAndEmit(QAbstractSocket::SslInternalError,
530                                 QStringLiteral("SSLRead failed: %1").arg(err));
531                 break;
532             }
533 
534             if (readBytes) {
535                 buffer.append(data.constData(), readBytes);
536                 if (readyReadEmittedPointer)
537                     *readyReadEmittedPointer = true;
538                 emit q->readyRead();
539                 emit q->channelReadyRead(0);
540             }
541 
542             if (err == errSSLWouldBlock)
543                 break;
544         }
545     }
546 }
547 
548 
549 QList<QSslError> (QSslSocketBackendPrivate::verify)(QList<QSslCertificate> certificateChain, const QString &hostName)
550 {
551     Q_UNIMPLEMENTED();
552     Q_UNUSED(certificateChain)
553     Q_UNUSED(hostName)
554 
555     QList<QSslError> errors;
556     errors << QSslError(QSslError::UnspecifiedError);
557 
558     return errors;
559 }
560 
561 bool QSslSocketBackendPrivate::importPkcs12(QIODevice *device,
562                          QSslKey *key, QSslCertificate *cert,
563                          QList<QSslCertificate> *caCertificates,
564                          const QByteArray &passPhrase)
565 {
566     Q_UNIMPLEMENTED();
567     Q_UNUSED(device)
568     Q_UNUSED(key)
569     Q_UNUSED(cert)
570     Q_UNUSED(caCertificates)
571     Q_UNUSED(passPhrase)
572     return false;
573 }
574 
575 QSslCipher QSslSocketBackendPrivate::QSslCipher_from_SSLCipherSuite(SSLCipherSuite cipher)
576 {
577     QSslCipher ciph;
578     switch (cipher) {
579     case SSL_RSA_WITH_NULL_MD5:
580         ciph.d->name = QLatin1String("NULL-MD5");
581         ciph.d->protocol = QSsl::SslV3;
582         break;
583     case SSL_RSA_WITH_NULL_SHA:
584         ciph.d->name = QLatin1String("NULL-SHA");
585         ciph.d->protocol = QSsl::SslV3;
586         break;
587     case SSL_RSA_WITH_RC4_128_MD5:
588         ciph.d->name = QLatin1String("RC4-MD5");
589         ciph.d->protocol = QSsl::SslV3;
590         break;
591     case SSL_RSA_WITH_RC4_128_SHA:
592         ciph.d->name = QLatin1String("RC4-SHA");
593         ciph.d->protocol = QSsl::SslV3;
594         break;
595 
596     case TLS_RSA_WITH_3DES_EDE_CBC_SHA:
597         ciph.d->name = QLatin1String("DES-CBC3-SHA");
598         break;
599     case TLS_RSA_WITH_AES_128_CBC_SHA:
600         ciph.d->name = QLatin1String("AES128-SHA");
601         break;
602     case TLS_RSA_WITH_AES_128_CBC_SHA256:
603         ciph.d->name = QLatin1String("AES128-SHA256");
604         break;
605     case TLS_RSA_WITH_AES_256_CBC_SHA:
606         ciph.d->name = QLatin1String("AES256-SHA");
607         break;
608     case TLS_RSA_WITH_AES_256_CBC_SHA256:
609         ciph.d->name = QLatin1String("AES256-SHA256");
610         break;
611 
612     case TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:
613         ciph.d->name = QLatin1String("DHE-RSA-DES-CBC3-SHA");
614         break;
615     case TLS_DHE_RSA_WITH_AES_128_CBC_SHA:
616         ciph.d->name = QLatin1String("DHE-RSA-AES128-SHA");
617         break;
618     case TLS_DHE_RSA_WITH_AES_128_CBC_SHA256:
619         ciph.d->name = QLatin1String("DHE-RSA-AES128-SHA256");
620         break;
621     case TLS_DHE_RSA_WITH_AES_256_CBC_SHA:
622         ciph.d->name = QLatin1String("DHE-RSA-AES256-SHA");
623         break;
624     case TLS_DHE_RSA_WITH_AES_256_CBC_SHA256:
625         ciph.d->name = QLatin1String("DHE-RSA-AES256-SHA256");
626         break;
627 
628     case TLS_ECDH_ECDSA_WITH_NULL_SHA:
629         ciph.d->name = QLatin1String("ECDH-ECDSA-NULL-SHA");
630         break;
631     case TLS_ECDH_ECDSA_WITH_RC4_128_SHA:
632         ciph.d->name = QLatin1String("ECDH-ECDSA-RC4-SHA");
633         break;
634     case TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:
635         ciph.d->name = QLatin1String("ECDH-ECDSA-DES-CBC3-SHA");
636         break;
637     case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:
638         ciph.d->name = QLatin1String("ECDH-ECDSA-AES128-SHA");
639         break;
640     case TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:
641         ciph.d->name = QLatin1String("ECDH-ECDSA-AES128-SHA256");
642         break;
643     case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:
644         ciph.d->name = QLatin1String("ECDH-ECDSA-AES256-SHA");
645         break;
646     case TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:
647         ciph.d->name = QLatin1String("ECDH-ECDSA-AES256-SHA384");
648         break;
649 
650     case TLS_ECDH_RSA_WITH_NULL_SHA:
651         ciph.d->name = QLatin1String("ECDH-RSA-NULL-SHA");
652         break;
653     case TLS_ECDH_RSA_WITH_RC4_128_SHA:
654         ciph.d->name = QLatin1String("ECDH-RSA-AES256-SHA");
655         break;
656     case TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:
657         ciph.d->name = QLatin1String("ECDH-RSA-DES-CBC3-SHA");
658         break;
659     case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:
660         ciph.d->name = QLatin1String("ECDH-RSA-AES128-SHA");
661         break;
662     case TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:
663         ciph.d->name = QLatin1String("ECDH-RSA-AES128-SHA256");
664         break;
665     case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:
666         ciph.d->name = QLatin1String("ECDH-RSA-AES256-SHA");
667         break;
668     case TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:
669         ciph.d->name = QLatin1String("ECDH-RSA-AES256-SHA384");
670         break;
671 
672     case TLS_ECDHE_ECDSA_WITH_NULL_SHA:
673         ciph.d->name = QLatin1String("ECDHE-ECDSA-NULL-SHA");
674         break;
675     case TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:
676         ciph.d->name = QLatin1String("ECDHE-ECDSA-RC4-SHA");
677         break;
678     case TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:
679         ciph.d->name = QLatin1String("ECDHE-ECDSA-DES-CBC3-SHA");
680         break;
681     case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:
682         ciph.d->name = QLatin1String("ECDHE-ECDSA-AES128-SHA");
683         break;
684     case TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:
685         ciph.d->name = QLatin1String("ECDHE-ECDSA-AES128-SHA256");
686         break;
687     case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:
688         ciph.d->name = QLatin1String("ECDHE-ECDSA-AES256-SHA");
689         break;
690     case TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:
691         ciph.d->name = QLatin1String("ECDHE-ECDSA-AES256-SHA384");
692         break;
693 
694     case TLS_ECDHE_RSA_WITH_NULL_SHA:
695         ciph.d->name = QLatin1String("ECDHE-RSA-NULL-SHA");
696         break;
697     case TLS_ECDHE_RSA_WITH_RC4_128_SHA:
698         ciph.d->name = QLatin1String("ECDHE-RSA-AES256-SHA");
699         break;
700     case TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:
701         ciph.d->name = QLatin1String("ECDHE-RSA-DES-CBC3-SHA");
702         break;
703     case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:
704         ciph.d->name = QLatin1String("ECDHE-RSA-AES128-SHA");
705         break;
706     case TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:
707         ciph.d->name = QLatin1String("ECDHE-RSA-AES128-SHA256");
708         break;
709     case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:
710         ciph.d->name = QLatin1String("ECDHE-RSA-AES256-SHA");
711         break;
712     case TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:
713         ciph.d->name = QLatin1String("ECDHE-RSA-AES256-SHA384");
714         break;
715     case TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:
716         ciph.d->name = QLatin1String("ECDHE-RSA-AES256-GCM-SHA384");
717         break;
718     default:
719         return ciph;
720     }
721     ciph.d->isNull = false;
722 
723     // protocol
724     if (ciph.d->protocol == QSsl::SslV3) {
725         ciph.d->protocolString = QLatin1String("SSLv3");
726     } else {
727         ciph.d->protocol = QSsl::TlsV1_2;
728         ciph.d->protocolString = QLatin1String("TLSv1.2");
729     }
730 
731     const auto bits = ciph.d->name.splitRef(QLatin1Char('-'));
732     if (bits.size() >= 2) {
733         if (bits.size() == 2 || bits.size() == 3) {
734             ciph.d->keyExchangeMethod = QLatin1String("RSA");
735         } else if (bits.front() == QLatin1String("DH") || bits.front() == QLatin1String("DHE")) {
736             ciph.d->keyExchangeMethod = QLatin1String("DH");
737         } else if (bits.front() == QLatin1String("ECDH") || bits.front() == QLatin1String("ECDHE")) {
738             ciph.d->keyExchangeMethod = QLatin1String("ECDH");
739         } else {
740             qCWarning(lcSsl) << "Unknown Kx" << ciph.d->name;
741         }
742 
743         if (bits.size() == 2 || bits.size() == 3) {
744             ciph.d->authenticationMethod = QLatin1String("RSA");
745         } else if (ciph.d->name.contains(QLatin1String("-ECDSA-"))) {
746             ciph.d->authenticationMethod = QLatin1String("ECDSA");
747         } else if (ciph.d->name.contains(QLatin1String("-RSA-"))) {
748             ciph.d->authenticationMethod = QLatin1String("RSA");
749         } else {
750             qCWarning(lcSsl) << "Unknown Au" << ciph.d->name;
751         }
752 
753         if (ciph.d->name.contains(QLatin1String("RC4-"))) {
754             ciph.d->encryptionMethod = QLatin1String("RC4(128)");
755             ciph.d->bits = 128;
756             ciph.d->supportedBits = 128;
757         } else if (ciph.d->name.contains(QLatin1String("DES-CBC3-"))) {
758             ciph.d->encryptionMethod = QLatin1String("3DES(168)");
759             ciph.d->bits = 168;
760             ciph.d->supportedBits = 168;
761         } else if (ciph.d->name.contains(QLatin1String("AES128-"))) {
762             ciph.d->encryptionMethod = QLatin1String("AES(128)");
763             ciph.d->bits = 128;
764             ciph.d->supportedBits = 128;
765         } else if (ciph.d->name.contains(QLatin1String("AES256-GCM"))) {
766             ciph.d->encryptionMethod = QLatin1String("AESGCM(256)");
767             ciph.d->bits = 256;
768             ciph.d->supportedBits = 256;
769         } else if (ciph.d->name.contains(QLatin1String("AES256-"))) {
770             ciph.d->encryptionMethod = QLatin1String("AES(256)");
771             ciph.d->bits = 256;
772             ciph.d->supportedBits = 256;
773         } else if (ciph.d->name.contains(QLatin1String("NULL-"))) {
774             ciph.d->encryptionMethod = QLatin1String("NULL");
775         } else {
776             qCWarning(lcSsl) << "Unknown Enc" << ciph.d->name;
777         }
778     }
779     return ciph;
780 }
781 
782 bool QSslSocketBackendPrivate::initSslContext()
783 {
784     Q_Q(QSslSocket);
785 
786     Q_ASSERT_X(!context, Q_FUNC_INFO, "invalid socket state, context is not null");
787     Q_ASSERT(plainSocket);
788 
789     context.reset(qt_createSecureTransportContext(mode));
790     if (!context) {
791         setErrorAndEmit(QAbstractSocket::SslInternalError, QStringLiteral("SSLCreateContext failed"));
792         return false;
793     }
794 
795     const OSStatus err = SSLSetIOFuncs(context, reinterpret_cast<SSLReadFunc>(&_q_SSLRead),
796                                        reinterpret_cast<SSLWriteFunc>(&_q_SSLWrite));
797     if (err != noErr) {
798         destroySslContext();
799         setErrorAndEmit(QAbstractSocket::SslInternalError,
800                         QStringLiteral("SSLSetIOFuncs failed: %1").arg(err));
801         return false;
802     }
803 
804     SSLSetConnection(context, plainSocket);
805 
806     if (mode == QSslSocket::SslServerMode
807         && !configuration.localCertificateChain.isEmpty()) {
808         QString errorDescription;
809         QAbstractSocket::SocketError errorCode = QAbstractSocket::UnknownSocketError;
810         if (!setSessionCertificate(errorDescription, errorCode)) {
811             destroySslContext();
812             setErrorAndEmit(errorCode, errorDescription);
813             return false;
814         }
815     }
816 
817     if (!setSessionProtocol()) {
818         destroySslContext();
819         setErrorAndEmit(QAbstractSocket::SslInternalError, QStringLiteral("Failed to set protocol version"));
820         return false;
821     }
822 
823     if (mode == QSslSocket::SslClientMode) {
824         // enable Server Name Indication (SNI)
825         QString tlsHostName(verificationPeerName.isEmpty() ? q->peerName() : verificationPeerName);
826         if (tlsHostName.isEmpty())
827             tlsHostName = hostName;
828 
829         const QByteArray ace(QUrl::toAce(tlsHostName));
830         SSLSetPeerDomainName(context, ace.data(), ace.size());
831         // tell SecureTransport we handle peer verification ourselves
832         OSStatus err = SSLSetSessionOption(context, kSSLSessionOptionBreakOnServerAuth, true);
833         if (err == noErr)
834             err = SSLSetSessionOption(context, kSSLSessionOptionBreakOnCertRequested, true);
835 
836         if (err != noErr) {
837             destroySslContext();
838             setErrorAndEmit(QSslSocket::SslInternalError,
839                      QStringLiteral("SSLSetSessionOption failed: %1").arg(err));
840             return false;
841         }
842         //
843     } else {
844         if (configuration.peerVerifyMode != QSslSocket::VerifyNone) {
845             // kAlwaysAuthenticate - always fails even if we set break on client auth.
846             OSStatus err = SSLSetClientSideAuthenticate(context, kTryAuthenticate);
847             if (err == noErr) {
848                 // We'd like to verify peer ourselves, otherwise handshake will
849                 // most probably fail before we can do anything.
850                 err = SSLSetSessionOption(context, kSSLSessionOptionBreakOnClientAuth, true);
851             }
852 
853             if (err != noErr) {
854                 destroySslContext();
855                 setErrorAndEmit(QAbstractSocket::SslInternalError,
856                          QStringLiteral("failed to set SSL context option in server mode: %1").arg(err));
857                 return false;
858             }
859         }
860 #if !defined(QT_PLATFORM_UIKIT)
861         // No SSLSetDiffieHellmanParams on iOS; calling it is optional according to docs.
862         SSLSetDiffieHellmanParams(context, dhparam, sizeof(dhparam));
863 #endif
864     }
865     return true;
866 }
867 
868 void QSslSocketBackendPrivate::destroySslContext()
869 {
870     context.reset(Q_NULLPTR);
871 }
872 
873 static QByteArray _q_makePkcs12(const QList<QSslCertificate> &certs, const QSslKey &key, const QString &passPhrase);
874 
875 
876 bool QSslSocketBackendPrivate::setSessionCertificate(QString &errorDescription, QAbstractSocket::SocketError &errorCode)
877 {
878     Q_ASSERT_X(context, Q_FUNC_INFO, "invalid SSL context (null)");
879 
880     QSslCertificate localCertificate;
881     if (!configuration.localCertificateChain.isEmpty())
882         localCertificate = configuration.localCertificateChain.at(0);
883 
884     if (!localCertificate.isNull()) {
885         // Require a private key as well.
886         if (configuration.privateKey.isNull()) {
887             errorCode = QAbstractSocket::SslInvalidUserDataError;
888             errorDescription = QStringLiteral("Cannot provide a certificate with no key");
889             return false;
890         }
891 
892         // import certificates and key
893         QCFType<CFDataRef> pkcs12 = _q_makePkcs12(configuration.localCertificateChain,
894                                                   configuration.privateKey,
895                                                   qtSecureTransportPassPhrase).toCFData();
896         QCFType<CFStringRef> password = qtSecureTransportPassPhrase.toCFString();
897         const void *keys[2] = { kSecImportExportPassphrase };
898         const void *values[2] = { password };
899         CFIndex nKeys = 1;
900 #ifdef Q_OS_MACOS
901         if (qtCustomKeychain()->keychain) {
902             nKeys = 2;
903             keys[1] = kSecImportExportKeychain;
904             values[1] = qtCustomKeychain()->keychain;
905         }
906 #endif
907         QCFType<CFDictionaryRef> options = CFDictionaryCreate(Q_NULLPTR, keys, values,
908                                                               nKeys, Q_NULLPTR, Q_NULLPTR);
909         CFArrayRef items = Q_NULLPTR;
910         OSStatus err = SecPKCS12Import(pkcs12, options, &items);
911         if (err != noErr) {
912 #ifdef QSSLSOCKET_DEBUG
913             qCWarning(lcSsl) << plainSocket
914                        << QStringLiteral("SecPKCS12Import failed: %1").arg(err);
915 #endif
916             errorCode = QAbstractSocket::SslInvalidUserDataError;
917             errorDescription = QStringLiteral("SecPKCS12Import failed: %1").arg(err);
918             return false;
919         }
920 
921         if (!CFArrayGetCount(items)) {
922 #ifdef QSSLSOCKET_DEBUG
923             qCWarning(lcSsl) << plainSocket << "SecPKCS12Import returned no items";
924 #endif
925             errorCode = QAbstractSocket::SslInvalidUserDataError;
926             errorDescription = QStringLiteral("SecPKCS12Import returned no items");
927             return false;
928         }
929 
930         CFDictionaryRef import = (CFDictionaryRef)CFArrayGetValueAtIndex(items, 0);
931         SecIdentityRef identity = (SecIdentityRef)CFDictionaryGetValue(import, kSecImportItemIdentity);
932         if (!identity) {
933 #ifdef QSSLSOCKET_DEBUG
934             qCWarning(lcSsl) << plainSocket << "SecPKCS12Import returned no identity";
935 #endif
936             errorCode = QAbstractSocket::SslInvalidUserDataError;
937             errorDescription = QStringLiteral("SecPKCS12Import returned no identity");
938             return false;
939         }
940 
941         QCFType<CFMutableArrayRef> certs = CFArrayCreateMutable(Q_NULLPTR, 0, &kCFTypeArrayCallBacks);
942         if (!certs) {
943             errorCode = QAbstractSocket::SslInternalError;
944             errorDescription = QStringLiteral("Failed to allocate certificates array");
945             return false;
946         }
947 
948         CFArrayAppendValue(certs, identity);
949 
950         QCFType<CFArrayRef> chain((CFArrayRef)CFDictionaryGetValue(import, kSecImportItemCertChain));
951         if (chain) {
952             for (CFIndex i = 1, e = CFArrayGetCount(chain); i < e; ++i)
953                 CFArrayAppendValue(certs, CFArrayGetValueAtIndex(chain, i));
954         }
955 
956         err = SSLSetCertificate(context, certs);
957         if (err != noErr) {
958 #ifdef QSSLSOCKET_DEBUG
959             qCWarning(lcSsl) << plainSocket
960                        << QStringLiteral("Cannot set certificate and key: %1").arg(err);
961 #endif
962             errorCode = QAbstractSocket::SslInvalidUserDataError;
963             errorDescription = QStringLiteral("Cannot set certificate and key: %1").arg(err);
964             return false;
965         }
966     }
967 
968     return true;
969 }
970 
971 bool QSslSocketBackendPrivate::setSessionProtocol()
972 {
973     Q_ASSERT_X(context, Q_FUNC_INFO, "invalid SSL context (null)");
974 
975     // QSsl::SslV2 == kSSLProtocol2 is disabled in Secure Transport and
976     // always fails with errSSLIllegalParam:
977     // if (version < MINIMUM_STREAM_VERSION || version > MAXIMUM_STREAM_VERSION)
978     //     return errSSLIllegalParam;
979     // where MINIMUM_STREAM_VERSION is SSL_Version_3_0, MAXIMUM_STREAM_VERSION is TLS_Version_1_2.
980     if (configuration.protocol == QSsl::SslV2) {
981         qCDebug(lcSsl) << "protocol QSsl::SslV2 is disabled";
982         return false;
983     }
984 
985     OSStatus err = noErr;
986 
987     if (configuration.protocol == QSsl::SslV3) {
988     #ifdef QSSLSOCKET_DEBUG
989         qCDebug(lcSsl) << plainSocket << "requesting : SSLv3";
990     #endif
991         err = SSLSetProtocolVersionMin(context, kSSLProtocol3);
992         if (err == noErr)
993             err = SSLSetProtocolVersionMax(context, kSSLProtocol3);
994     } else if (configuration.protocol == QSsl::TlsV1_0) {
995     #ifdef QSSLSOCKET_DEBUG
996         qCDebug(lcSsl) << plainSocket << "requesting : TLSv1.0";
997     #endif
998         err = SSLSetProtocolVersionMin(context, kTLSProtocol1);
999         if (err == noErr)
1000             err = SSLSetProtocolVersionMax(context, kTLSProtocol1);
1001     } else if (configuration.protocol == QSsl::TlsV1_1) {
1002     #ifdef QSSLSOCKET_DEBUG
1003         qCDebug(lcSsl) << plainSocket << "requesting : TLSv1.1";
1004     #endif
1005         err = SSLSetProtocolVersionMin(context, kTLSProtocol11);
1006         if (err == noErr)
1007             err = SSLSetProtocolVersionMax(context, kTLSProtocol11);
1008     } else if (configuration.protocol == QSsl::TlsV1_2) {
1009     #ifdef QSSLSOCKET_DEBUG
1010         qCDebug(lcSsl) << plainSocket << "requesting : TLSv1.2";
1011     #endif
1012         err = SSLSetProtocolVersionMin(context, kTLSProtocol12);
1013         if (err == noErr)
1014             err = SSLSetProtocolVersionMax(context, kTLSProtocol12);
1015     } else if (configuration.protocol == QSsl::AnyProtocol) {
1016     #ifdef QSSLSOCKET_DEBUG
1017         qCDebug(lcSsl) << plainSocket << "requesting : any";
1018     #endif
1019         // kSSLProtocol3, since kSSLProtocol2 is disabled:
1020         err = SSLSetProtocolVersionMin(context, kSSLProtocol3);
1021         if (err == noErr)
1022             err = SSLSetProtocolVersionMax(context, kTLSProtocol12);
1023     } else if (configuration.protocol == QSsl::TlsV1SslV3) {
1024     #ifdef QSSLSOCKET_DEBUG
1025         qCDebug(lcSsl) << plainSocket << "requesting : SSLv3 - TLSv1.2";
1026     #endif
1027         err = SSLSetProtocolVersionMin(context, kSSLProtocol3);
1028         if (err == noErr)
1029             err = SSLSetProtocolVersionMax(context, kTLSProtocol12);
1030     } else if (configuration.protocol == QSsl::SecureProtocols) {
1031     #ifdef QSSLSOCKET_DEBUG
1032         qCDebug(lcSsl) << plainSocket << "requesting : TLSv1 - TLSv1.2";
1033     #endif
1034         err = SSLSetProtocolVersionMin(context, kTLSProtocol1);
1035         if (err == noErr)
1036             err = SSLSetProtocolVersionMax(context, kTLSProtocol12);
1037     } else if (configuration.protocol == QSsl::TlsV1_0OrLater) {
1038     #ifdef QSSLSOCKET_DEBUG
1039         qCDebug(lcSsl) << plainSocket << "requesting : TLSv1 - TLSv1.2";
1040     #endif
1041         err = SSLSetProtocolVersionMin(context, kTLSProtocol1);
1042         if (err == noErr)
1043             err = SSLSetProtocolVersionMax(context, kTLSProtocol12);
1044     } else if (configuration.protocol == QSsl::TlsV1_1OrLater) {
1045     #ifdef QSSLSOCKET_DEBUG
1046         qCDebug(lcSsl) << plainSocket << "requesting : TLSv1.1 - TLSv1.2";
1047     #endif
1048         err = SSLSetProtocolVersionMin(context, kTLSProtocol11);
1049         if (err == noErr)
1050             err = SSLSetProtocolVersionMax(context, kTLSProtocol12);
1051     } else if (configuration.protocol == QSsl::TlsV1_2OrLater) {
1052     #ifdef QSSLSOCKET_DEBUG
1053         qCDebug(lcSsl) << plainSocket << "requesting : TLSv1.2";
1054     #endif
1055         err = SSLSetProtocolVersionMin(context, kTLSProtocol12);
1056         if (err == noErr)
1057             err = SSLSetProtocolVersionMax(context, kTLSProtocol12);
1058     } else {
1059     #ifdef QSSLSOCKET_DEBUG
1060         qCDebug(lcSsl) << plainSocket << "no protocol version found in the configuration";
1061     #endif
1062         return false;
1063     }
1064 
1065     return err == noErr;
1066 }
1067 
1068 bool QSslSocketBackendPrivate::canIgnoreTrustVerificationFailure() const
1069 {
1070     const QSslSocket::PeerVerifyMode verifyMode = configuration.peerVerifyMode;
1071     return mode == QSslSocket::SslServerMode
1072            && (verifyMode == QSslSocket::QueryPeer
1073                || verifyMode == QSslSocket::AutoVerifyPeer
1074                || verifyMode == QSslSocket::VerifyNone);
1075 }
1076 
1077 bool QSslSocketBackendPrivate::verifySessionProtocol() const
1078 {
1079     bool protocolOk = false;
1080     if (configuration.protocol == QSsl::AnyProtocol)
1081         protocolOk = true;
1082     else if (configuration.protocol == QSsl::TlsV1SslV3)
1083         protocolOk = (sessionProtocol() >= QSsl::SslV3);
1084     else if (configuration.protocol == QSsl::SecureProtocols)
1085         protocolOk = (sessionProtocol() >= QSsl::TlsV1_0);
1086     else
1087         protocolOk = (sessionProtocol() == configuration.protocol);
1088 
1089     return protocolOk;
1090 }
1091 
1092 bool QSslSocketBackendPrivate::verifyPeerTrust()
1093 {
1094     Q_Q(QSslSocket);
1095 
1096     const QSslSocket::PeerVerifyMode verifyMode = configuration.peerVerifyMode;
1097     const bool canIgnoreVerify = canIgnoreTrustVerificationFailure();
1098 
1099     Q_ASSERT_X(context, Q_FUNC_INFO, "invalid SSL context (null)");
1100     Q_ASSERT(plainSocket);
1101 
1102     QCFType<SecTrustRef> trust;
1103     OSStatus err = SSLCopyPeerTrust(context, &trust);
1104     // !trust - SSLCopyPeerTrust can return noErr but null trust.
1105     if (err != noErr || !trust) {
1106         if (!canIgnoreVerify) {
1107             setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
1108                      QStringLiteral("Failed to obtain peer trust: %1").arg(err));
1109             plainSocket->disconnectFromHost();
1110             return false;
1111         } else {
1112             return true;
1113         }
1114     }
1115 
1116     QList<QSslError> errors;
1117     // store certificates
1118     const int certCount = SecTrustGetCertificateCount(trust);
1119     // TODO: why this test depends on configuration.peerCertificateChain not being empty????
1120     if (configuration.peerCertificateChain.isEmpty()) {
1121         // Apple's docs say SetTrustEvaluate must be called before
1122         // SecTrustGetCertificateAtIndex, but this results
1123         // in 'kSecTrustResultRecoverableTrustFailure', so
1124         // here we just ignore 'res' (later we'll use SetAnchor etc.
1125         // and evaluate again).
1126         SecTrustResultType res = kSecTrustResultInvalid;
1127         err = SecTrustEvaluate(trust, &res);
1128         if (err != noErr) {
1129             // We can not ignore this, it's not even about trust verification
1130             // probably ...
1131             setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
1132                             QStringLiteral("SecTrustEvaluate failed: %1").arg(err));
1133             plainSocket->disconnectFromHost();
1134             return false;
1135         }
1136 
1137         for (int i = 0; i < certCount; ++i) {
1138             SecCertificateRef cert = SecTrustGetCertificateAtIndex(trust, i);
1139             QCFType<CFDataRef> derData = SecCertificateCopyData(cert);
1140             configuration.peerCertificateChain << QSslCertificate(QByteArray::fromCFData(derData), QSsl::Der);
1141         }
1142     }
1143 
1144     if (certCount > 0) {
1145         SecCertificateRef cert = SecTrustGetCertificateAtIndex(trust, 0);
1146         QCFType<CFDataRef> derData = SecCertificateCopyData(cert);
1147         configuration.peerCertificate = QSslCertificate(QByteArray::fromCFData(derData), QSsl::Der);
1148     }
1149 
1150     // check the whole chain for blacklisting (including root, as we check for subjectInfo and issuer)
1151     for (const QSslCertificate &cert : qAsConst(configuration.peerCertificateChain)) {
1152         if (QSslCertificatePrivate::isBlacklisted(cert) && !canIgnoreVerify) {
1153             const QSslError error(QSslError::CertificateBlacklisted, cert);
1154             errors << error;
1155             emit q->peerVerifyError(error);
1156             if (q->state() != QAbstractSocket::ConnectedState)
1157                 return false;
1158         }
1159     }
1160 
1161     const bool doVerifyPeer = verifyMode == QSslSocket::VerifyPeer
1162                               || (verifyMode == QSslSocket::AutoVerifyPeer
1163                                   && mode == QSslSocket::SslClientMode);
1164     // Check the peer certificate itself. First try the subject's common name
1165     // (CN) as a wildcard, then try all alternate subject name DNS entries the
1166     // same way.
1167     if (!configuration.peerCertificate.isNull()) {
1168         // but only if we're a client connecting to a server
1169         // if we're the server, don't check CN
1170         if (mode == QSslSocket::SslClientMode) {
1171             const QString peerName(verificationPeerName.isEmpty () ? q->peerName() : verificationPeerName);
1172             if (!isMatchingHostname(configuration.peerCertificate, peerName) && !canIgnoreVerify) {
1173                 // No matches in common names or alternate names.
1174                 const QSslError error(QSslError::HostNameMismatch, configuration.peerCertificate);
1175                 errors << error;
1176                 emit q->peerVerifyError(error);
1177                 if (q->state() != QAbstractSocket::ConnectedState)
1178                     return false;
1179             }
1180         }
1181     } else {
1182         // No peer certificate presented. Report as error if the socket
1183         // expected one.
1184         if (doVerifyPeer && !canIgnoreVerify) {
1185             const QSslError error(QSslError::NoPeerCertificate);
1186             errors << error;
1187             emit q->peerVerifyError(error);
1188             if (q->state() != QAbstractSocket::ConnectedState)
1189                 return false;
1190         }
1191     }
1192 
1193     // verify certificate chain
1194     QCFType<CFMutableArrayRef> certArray = CFArrayCreateMutable(NULL, 0, &kCFTypeArrayCallBacks);
1195     for (const QSslCertificate &cert : qAsConst(configuration.caCertificates)) {
1196         QCFType<CFDataRef> certData = cert.d->derData.toCFData();
1197         QCFType<SecCertificateRef> certRef = SecCertificateCreateWithData(NULL, certData);
1198         CFArrayAppendValue(certArray, certRef);
1199     }
1200     SecTrustSetAnchorCertificates(trust, certArray);
1201     SecTrustSetAnchorCertificatesOnly(trust, false);
1202 
1203     SecTrustResultType trustResult = kSecTrustResultInvalid;
1204     SecTrustEvaluate(trust, &trustResult);
1205     switch (trustResult) {
1206     case kSecTrustResultUnspecified:
1207     case kSecTrustResultProceed:
1208         break;
1209     default:
1210         if (!canIgnoreVerify) {
1211             const QSslError error(QSslError::CertificateUntrusted, configuration.peerCertificate);
1212             errors << error;
1213             emit q->peerVerifyError(error);
1214         }
1215     }
1216 
1217     // report errors
1218     if (!errors.isEmpty() && !canIgnoreVerify) {
1219         sslErrors = errors;
1220         // checkSslErrors unconditionally emits sslErrors:
1221         // a user's slot can abort/close/disconnect on this
1222         // signal, so we also test the socket's state:
1223         if (!checkSslErrors() || q->state() != QAbstractSocket::ConnectedState)
1224             return false;
1225     } else {
1226         sslErrors.clear();
1227     }
1228 
1229     return true;
1230 }
1231 
1232 /*
1233     Copied verbatim from qsslsocket_openssl.cpp
1234 */
1235 bool QSslSocketBackendPrivate::checkSslErrors()
1236 {
1237     Q_Q(QSslSocket);
1238     if (sslErrors.isEmpty())
1239         return true;
1240 
1241     emit q->sslErrors(sslErrors);
1242 
1243     const bool doVerifyPeer = configuration.peerVerifyMode == QSslSocket::VerifyPeer
1244                               || (configuration.peerVerifyMode == QSslSocket::AutoVerifyPeer
1245                               && mode == QSslSocket::SslClientMode);
1246     const bool doEmitSslError = !verifyErrorsHaveBeenIgnored();
1247     // check whether we need to emit an SSL handshake error
1248     if (doVerifyPeer && doEmitSslError) {
1249         if (q->pauseMode() & QAbstractSocket::PauseOnSslErrors) {
1250             pauseSocketNotifiers(q);
1251             paused = true;
1252         } else {
1253             setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
1254                             sslErrors.constFirst().errorString());
1255             plainSocket->disconnectFromHost();
1256         }
1257         return false;
1258     }
1259 
1260     return true;
1261 }
1262 
1263 bool QSslSocketBackendPrivate::startHandshake()
1264 {
1265     Q_ASSERT(context);
1266     Q_Q(QSslSocket);
1267 
1268     OSStatus err = SSLHandshake(context);
1269 #ifdef QSSLSOCKET_DEBUG
1270     qCDebug(lcSsl) << plainSocket << "SSLHandhake returned" << err;
1271 #endif
1272 
1273     if (err == errSSLWouldBlock) {
1274         // startHandshake has to be called again ... later.
1275         return false;
1276     } else if (err == errSSLServerAuthCompleted) {
1277         // errSSLServerAuthCompleted is a define for errSSLPeerAuthCompleted,
1278         // it works for both server/client modes.
1279         // In future we'll evaluate peer's trust at this point,
1280         // for now we just continue.
1281         // if (!verifyPeerTrust())
1282         //      ...
1283         return startHandshake();
1284     } else if (err == errSSLClientCertRequested) {
1285         Q_ASSERT(mode == QSslSocket::SslClientMode);
1286         QString errorDescription;
1287         QAbstractSocket::SocketError errorCode = QAbstractSocket::UnknownSocketError;
1288         // setSessionCertificate does not fail if we have no certificate.
1289         // Failure means a real error (invalid certificate, no private key, etc).
1290         if (!setSessionCertificate(errorDescription, errorCode)) {
1291             setErrorAndEmit(errorCode, errorDescription);
1292             return false;
1293         } else {
1294             // We try to resume a handshake, even if have no
1295             // local certificates ... (up to server to deal with our failure).
1296             return startHandshake();
1297         }
1298     } else if (err != errSecSuccess) {
1299         if (err == errSSLBadCert && canIgnoreTrustVerificationFailure()) {
1300             // We're on the server side and client did not provide any
1301             // certificate. This is the new 'nice' error returned by
1302             // Security Framework after it was recently updated.
1303             return startHandshake();
1304         }
1305 
1306         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
1307                         QStringLiteral("SSLHandshake failed: %1").arg(err));
1308         plainSocket->disconnectFromHost();
1309         return false;
1310     }
1311 
1312     // Connection aborted during handshake phase.
1313     if (q->state() != QAbstractSocket::ConnectedState) {
1314         qCDebug(lcSsl) << "connection aborted";
1315         return false;
1316     }
1317 
1318     // check protocol version ourselves, as Secure Transport does not enforce
1319     // the requested min / max versions.
1320     if (!verifySessionProtocol()) {
1321         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError, QStringLiteral("Protocol version mismatch"));
1322         plainSocket->disconnectFromHost();
1323         return false;
1324     }
1325 
1326     if (verifyPeerTrust()) {
1327         continueHandshake();
1328         return true;
1329     } else {
1330         return false;
1331     }
1332 }
1333 
1334 /*
1335     PKCS12 helpers.
1336 */
1337 
1338 static QAsn1Element wrap(quint8 type, const QAsn1Element &child)
1339 {
1340     QByteArray value;
1341     QDataStream stream(&value, QIODevice::WriteOnly);
1342     child.write(stream);
1343     return QAsn1Element(type, value);
1344 }
1345 
1346 static QAsn1Element _q_PKCS7_data(const QByteArray &data)
1347 {
1348     QVector<QAsn1Element> items;
1349     items << QAsn1Element::fromObjectId("1.2.840.113549.1.7.1");
1350     items << wrap(QAsn1Element::Context0Type,
1351                   QAsn1Element(QAsn1Element::OctetStringType, data));
1352     return QAsn1Element::fromVector(items);
1353 }
1354 
1355 /*!
1356     PKCS #12 key derivation.
1357 
1358     Some test vectors:
1359     http://www.drh-consultancy.demon.co.uk/test.txt
1360 */
1361 static QByteArray _q_PKCS12_keygen(char id, const QByteArray &salt, const QString &passPhrase, int n, int r)
1362 {
1363     const int u = 20;
1364     const int v = 64;
1365 
1366     // password formatting
1367     QByteArray passUnicode(passPhrase.size() * 2 + 2, '\0');
1368     char *p = passUnicode.data();
1369     for (int i = 0; i < passPhrase.size(); ++i) {
1370         quint16 ch = passPhrase[i].unicode();
1371         *(p++) = (ch & 0xff00) >> 8;
1372         *(p++) = (ch & 0xff);
1373     }
1374 
1375     // prepare I
1376     QByteArray D(64, id);
1377     QByteArray S, P;
1378     const int sSize = v * ((salt.size() + v - 1) / v);
1379     S.resize(sSize);
1380     for (int i = 0; i < sSize; ++i) {
1381         S[i] = salt[i % salt.size()];
1382     }
1383     const int pSize = v * ((passUnicode.size() + v - 1) / v);
1384     P.resize(pSize);
1385     for (int i = 0; i < pSize; ++i) {
1386         P[i] = passUnicode[i % passUnicode.size()];
1387     }
1388     QByteArray I = S + P;
1389 
1390     // apply hashing
1391     const int c = (n + u - 1) / u;
1392     QByteArray A;
1393     QByteArray B;
1394     B.resize(v);
1395     QCryptographicHash hash(QCryptographicHash::Sha1);
1396     for (int i = 0; i < c; ++i) {
1397         // hash r iterations
1398         QByteArray Ai = D + I;
1399         for (int j = 0; j < r; ++j) {
1400             hash.reset();
1401             hash.addData(Ai);
1402             Ai = hash.result();
1403         }
1404 
1405         for (int j = 0; j < v; ++j) {
1406             B[j] = Ai[j % u];
1407         }
1408 
1409         // modify I as Ij = (Ij + B + 1) modulo 2^v
1410         for (int p = 0; p < I.size(); p += v) {
1411             quint8 carry = 1;
1412             for (int j = v - 1; j >= 0; --j) {
1413                 quint16 v = quint8(I[p+j]) + quint8(B[j]) + carry;
1414                 I[p+j] = v & 0xff;
1415                 carry = (v & 0xff00) >> 8;
1416             }
1417         }
1418         A += Ai;
1419     }
1420     return A.left(n);
1421 }
1422 
1423 static QByteArray _q_PKCS12_salt()
1424 {
1425     QByteArray salt;
1426     salt.resize(8);
1427     for (int i = 0; i < salt.size(); ++i) {
1428         salt[i] = (qrand() & 0xff);
1429     }
1430     return salt;
1431 }
1432 
1433 static QByteArray _q_PKCS12_certBag(const QSslCertificate &cert)
1434 {
1435     QVector<QAsn1Element> items;
1436     items << QAsn1Element::fromObjectId("1.2.840.113549.1.12.10.1.3");
1437 
1438     // certificate
1439     QVector<QAsn1Element> certItems;
1440     certItems << QAsn1Element::fromObjectId("1.2.840.113549.1.9.22.1");
1441     certItems << wrap(QAsn1Element::Context0Type,
1442                       QAsn1Element(QAsn1Element::OctetStringType, cert.toDer()));
1443     items << wrap(QAsn1Element::Context0Type,
1444                   QAsn1Element::fromVector(certItems));
1445 
1446     // local key id
1447     const QByteArray localKeyId = cert.digest(QCryptographicHash::Sha1);
1448     QVector<QAsn1Element> idItems;
1449     idItems << QAsn1Element::fromObjectId("1.2.840.113549.1.9.21");
1450     idItems << wrap(QAsn1Element::SetType,
1451                     QAsn1Element(QAsn1Element::OctetStringType, localKeyId));
1452     items << wrap(QAsn1Element::SetType, QAsn1Element::fromVector(idItems));
1453 
1454     // dump
1455     QAsn1Element root = wrap(QAsn1Element::SequenceType, QAsn1Element::fromVector(items));
1456     QByteArray ba;
1457     QDataStream stream(&ba, QIODevice::WriteOnly);
1458     root.write(stream);
1459     return ba;
1460 }
1461 
1462 static QAsn1Element _q_PKCS12_key(const QSslKey &key)
1463 {
1464     Q_ASSERT(key.algorithm() == QSsl::Rsa || key.algorithm() == QSsl::Dsa);
1465 
1466     QVector<QAsn1Element> keyItems;
1467     keyItems << QAsn1Element::fromInteger(0);
1468     QVector<QAsn1Element> algoItems;
1469     if (key.algorithm() == QSsl::Rsa)
1470         algoItems << QAsn1Element::fromObjectId(RSA_ENCRYPTION_OID);
1471     else if (key.algorithm() == QSsl::Dsa)
1472         algoItems << QAsn1Element::fromObjectId(DSA_ENCRYPTION_OID);
1473     algoItems << QAsn1Element(QAsn1Element::NullType);
1474     keyItems << QAsn1Element::fromVector(algoItems);
1475     keyItems << QAsn1Element(QAsn1Element::OctetStringType, key.toDer());
1476     return QAsn1Element::fromVector(keyItems);
1477 }
1478 
1479 static QByteArray _q_PKCS12_shroudedKeyBag(const QSslKey &key, const QString &passPhrase, const QByteArray &localKeyId)
1480 {
1481     const int iterations = 2048;
1482     QByteArray salt = _q_PKCS12_salt();
1483     QByteArray cKey = _q_PKCS12_keygen(1, salt, passPhrase, 24, iterations);
1484     QByteArray cIv = _q_PKCS12_keygen(2, salt, passPhrase, 8, iterations);
1485 
1486     // prepare and encrypt data
1487     QByteArray plain;
1488     QDataStream plainStream(&plain, QIODevice::WriteOnly);
1489     _q_PKCS12_key(key).write(plainStream);
1490     QByteArray crypted = QSslKeyPrivate::encrypt(QSslKeyPrivate::DesEde3Cbc,
1491         plain, cKey, cIv);
1492 
1493     QVector<QAsn1Element> items;
1494     items << QAsn1Element::fromObjectId("1.2.840.113549.1.12.10.1.2");
1495 
1496     // key
1497     QVector<QAsn1Element> keyItems;
1498     QVector<QAsn1Element> algoItems;
1499     algoItems << QAsn1Element::fromObjectId("1.2.840.113549.1.12.1.3");
1500     QVector<QAsn1Element> paramItems;
1501     paramItems << QAsn1Element(QAsn1Element::OctetStringType, salt);
1502     paramItems << QAsn1Element::fromInteger(iterations);
1503     algoItems << QAsn1Element::fromVector(paramItems);
1504     keyItems << QAsn1Element::fromVector(algoItems);
1505     keyItems << QAsn1Element(QAsn1Element::OctetStringType, crypted);
1506     items << wrap(QAsn1Element::Context0Type,
1507                   QAsn1Element::fromVector(keyItems));
1508 
1509     // local key id
1510     QVector<QAsn1Element> idItems;
1511     idItems << QAsn1Element::fromObjectId("1.2.840.113549.1.9.21");
1512     idItems << wrap(QAsn1Element::SetType,
1513                     QAsn1Element(QAsn1Element::OctetStringType, localKeyId));
1514     items << wrap(QAsn1Element::SetType,
1515                   QAsn1Element::fromVector(idItems));
1516 
1517     // dump
1518     QAsn1Element root = wrap(QAsn1Element::SequenceType, QAsn1Element::fromVector(items));
1519     QByteArray ba;
1520     QDataStream stream(&ba, QIODevice::WriteOnly);
1521     root.write(stream);
1522     return ba;
1523 }
1524 
1525 static QByteArray _q_PKCS12_bag(const QList<QSslCertificate> &certs, const QSslKey &key, const QString &passPhrase)
1526 {
1527     QVector<QAsn1Element> items;
1528 
1529     // certs
1530     for (int i = 0; i < certs.size(); ++i)
1531         items << _q_PKCS7_data(_q_PKCS12_certBag(certs[i]));
1532 
1533     // key
1534     const QByteArray localKeyId = certs.first().digest(QCryptographicHash::Sha1);
1535     items << _q_PKCS7_data(_q_PKCS12_shroudedKeyBag(key, passPhrase, localKeyId));
1536 
1537     // dump
1538     QAsn1Element root = QAsn1Element::fromVector(items);
1539     QByteArray ba;
1540     QDataStream stream(&ba, QIODevice::WriteOnly);
1541     root.write(stream);
1542     return ba;
1543 }
1544 
1545 static QAsn1Element _q_PKCS12_mac(const QByteArray &data, const QString &passPhrase)
1546 {
1547     const int iterations = 2048;
1548 
1549     // salt generation
1550     QByteArray macSalt = _q_PKCS12_salt();
1551     QByteArray key = _q_PKCS12_keygen(3, macSalt, passPhrase, 20, iterations);
1552 
1553     // HMAC calculation
1554     QMessageAuthenticationCode hmac(QCryptographicHash::Sha1, key);
1555     hmac.addData(data);
1556 
1557     QVector<QAsn1Element> algoItems;
1558     algoItems << QAsn1Element::fromObjectId("1.3.14.3.2.26");
1559     algoItems << QAsn1Element(QAsn1Element::NullType);
1560 
1561     QVector<QAsn1Element> digestItems;
1562     digestItems << QAsn1Element::fromVector(algoItems);
1563     digestItems << QAsn1Element(QAsn1Element::OctetStringType, hmac.result());
1564 
1565     QVector<QAsn1Element> macItems;
1566     macItems << QAsn1Element::fromVector(digestItems);
1567     macItems << QAsn1Element(QAsn1Element::OctetStringType, macSalt);
1568     macItems << QAsn1Element::fromInteger(iterations);
1569     return QAsn1Element::fromVector(macItems);
1570 }
1571 
1572 QByteArray _q_makePkcs12(const QList<QSslCertificate> &certs, const QSslKey &key, const QString &passPhrase)
1573 {
1574     QVector<QAsn1Element> items;
1575 
1576     // version
1577     items << QAsn1Element::fromInteger(3);
1578 
1579     // auth safe
1580     const QByteArray data = _q_PKCS12_bag(certs, key, passPhrase);
1581     items << _q_PKCS7_data(data);
1582 
1583     // HMAC
1584     items << _q_PKCS12_mac(data, passPhrase);
1585 
1586     // dump
1587     QAsn1Element root = QAsn1Element::fromVector(items);
1588     QByteArray ba;
1589     QDataStream stream(&ba, QIODevice::WriteOnly);
1590     root.write(stream);
1591     return ba;
1592 }
1593 
1594 QT_END_NAMESPACE
