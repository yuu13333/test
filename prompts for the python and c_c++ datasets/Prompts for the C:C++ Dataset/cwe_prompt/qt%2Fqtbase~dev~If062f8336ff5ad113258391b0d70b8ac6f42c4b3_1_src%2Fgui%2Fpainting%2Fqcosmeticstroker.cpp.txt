Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtGui module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qcosmeticstroker_p.h"
41 #include "private/qpainterpath_p.h"
42 #include "private/qrgba64_p.h"
43 #include <qdebug.h>
44 
45 QT_BEGIN_NAMESPACE
46 
47 #if 0
48 inline QString capString(int caps)
49 {
50     QString str;
51     if (caps & QCosmeticStroker::CapBegin) {
52         str += "CapBegin ";
53     }
54     if (caps & QCosmeticStroker::CapEnd) {
55         str += "CapEnd ";
56     }
57     return str;
58 }
59 #endif
60 
61 #if Q_PROCESSOR_WORDSIZE == 8
62 typedef qint64 FDot16;
63 #else
64 typedef int FDot16;
65 #endif
66 
67 #define toF26Dot6(x) ((int)((x)*64.))
68 
69 static inline uint sourceOver(uint d, uint color)
70 {
71     return color + BYTE_MUL(d, qAlpha(~color));
72 }
73 
74 inline static FDot16 FDot16FixedDiv(int x, int y)
75 {
76 #if Q_PROCESSOR_WORDSIZE == 8
77     return FDot16(x) * (1<<16) / y;
78 #else
79     if (qAbs(x) > 0x7fff)
80         return qlonglong(x) * (1<<16) / y;
81     return x * (1<<16) / y;
82 #endif
83 }
84 
85 typedef void (*DrawPixel)(QCosmeticStroker *stroker, int x, int y, int coverage);
86 
87 namespace {
88 
89 struct Dasher {
90     QCosmeticStroker *stroker;
91     int *pattern;
92     int offset;
93     int dashIndex;
94     int dashOn;
95 
96     Dasher(QCosmeticStroker *s, bool reverse, int start, int stop)
97         : stroker(s)
98     {
99         int delta = stop - start;
100         if (reverse) {
101             pattern = stroker->reversePattern;
102             offset = stroker->patternLength - stroker->patternOffset - delta - ((start & 63) - 32);
103             dashOn = 0;
104         } else {
105             pattern = stroker->pattern;
106             offset = stroker->patternOffset - ((start & 63) - 32);
107             dashOn = 1;
108         }
109         if (stroker->patternLength) {
110             offset %= stroker->patternLength;
111             if (offset < 0)
112                 offset += stroker->patternLength;
113         }
114 
115         dashIndex = 0;
116         while (dashIndex < stroker->patternSize - 1 && offset>= pattern[dashIndex])
117             ++dashIndex;
118 
119 //        qDebug() << "   dasher" << offset/64. << reverse << dashIndex;
120         stroker->patternOffset += delta;
121         if (stroker->patternLength)
122             stroker->patternOffset %= stroker->patternLength;
123     }
124 
125     bool on() const {
126         return (dashIndex + dashOn) & 1;
127     }
128     void adjust() {
129         offset += 64;
130         if (offset >= pattern[dashIndex]) {
131             ++dashIndex;
132             dashIndex %= stroker->patternSize;
133         }
134         if (stroker->patternLength)
135             offset %= stroker->patternLength;
136 //        qDebug() << "dasher.adjust" << offset/64. << dashIndex;
137     }
138 };
139 
140 struct NoDasher {
141     NoDasher(QCosmeticStroker *, bool, int, int) {}
142     bool on() const { return true; }
143     void adjust(int = 0) {}
144 };
145 
146 };
147 
148 /*
149  * The return value is the result of the clipLine() call performed at the start
150  * of each of the two functions, aka "false" means completely outside the devices
151  * rect.
152  */
153 template<DrawPixel drawPixel, class Dasher>
154 static bool drawLine(QCosmeticStroker *stroker, qreal x1, qreal y1, qreal x2, qreal y2, int caps);
155 template<DrawPixel drawPixel, class Dasher>
156 static bool drawLineAA(QCosmeticStroker *stroker, qreal x1, qreal y1, qreal x2, qreal y2, int caps);
157 
158 inline void drawPixel(QCosmeticStroker *stroker, int x, int y, int coverage)
159 {
160     const QRect &cl = stroker->clip;
161     if (x < cl.x() || x > cl.right() || y < cl.y() || y > cl.bottom())
162         return;
163 
164     if (stroker->current_span > 0) {
165         const int lastx = stroker->spans[stroker->current_span-1].x + stroker->spans[stroker->current_span-1].len ;
166         const int lasty = stroker->spans[stroker->current_span-1].y;
167 
168         if (stroker->current_span == QCosmeticStroker::NSPANS || y < lasty || (y == lasty && x < lastx)) {
169             stroker->blend(stroker->current_span, stroker->spans, &stroker->state->penData);
170             stroker->current_span = 0;
171         }
172     }
173 
174     stroker->spans[stroker->current_span].x = x;
175     stroker->spans[stroker->current_span].len = 1;
176     stroker->spans[stroker->current_span].y = y;
177     stroker->spans[stroker->current_span].coverage = coverage*stroker->opacity >> 8;
178     ++stroker->current_span;
179 }
180 
181 inline void drawPixelARGB32(QCosmeticStroker *stroker, int x, int y, int coverage)
182 {
183     const QRect &cl = stroker->clip;
184     if (x < cl.x() || x > cl.right() || y < cl.y() || y > cl.bottom())
185         return;
186 
187     int offset = x + stroker->ppl*y;
188     uint c = BYTE_MUL(stroker->color, coverage);
189     stroker->pixels[offset] = sourceOver(stroker->pixels[offset], c);
190 }
191 
192 inline void drawPixelARGB32Opaque(QCosmeticStroker *stroker, int x, int y, int)
193 {
194     const QRect &cl = stroker->clip;
195     if (x < cl.x() || x > cl.right() || y < cl.y() || y > cl.bottom())
196         return;
197 
198     int offset = x + stroker->ppl*y;
199     stroker->pixels[offset] = sourceOver(stroker->pixels[offset], stroker->color);
200 }
201 
202 enum StrokeSelection {
203     Aliased = 0,
204     AntiAliased = 1,
205     Solid = 0,
206     Dashed = 2,
207     RegularDraw = 0,
208     FastDraw = 4
209 };
210 
211 static StrokeLine strokeLine(int strokeSelection)
212 {
213     StrokeLine stroke;
214 
215     switch (strokeSelection) {
216     case Aliased|Solid|RegularDraw:
217         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixel, NoDasher>;
218         break;
219     case Aliased|Solid|FastDraw:
220         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixelARGB32Opaque, NoDasher>;
221         break;
222     case Aliased|Dashed|RegularDraw:
223         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixel, Dasher>;
224         break;
225     case Aliased|Dashed|FastDraw:
226         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixelARGB32Opaque, Dasher>;
227         break;
228     case AntiAliased|Solid|RegularDraw:
229         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixel, NoDasher>;
230         break;
231     case AntiAliased|Solid|FastDraw:
232         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixelARGB32, NoDasher>;
233         break;
234     case AntiAliased|Dashed|RegularDraw:
235         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixel, Dasher>;
236         break;
237     case AntiAliased|Dashed|FastDraw:
238         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixelARGB32, Dasher>;
239         break;
240     default:
241         Q_ASSERT(false);
242         stroke = nullptr;
243     }
244     return stroke;
245 }
246 
247 void QCosmeticStroker::setup()
248 {
249     blend = state->penData.blend;
250     if (state->clip && state->clip->enabled && state->clip->hasRectClip && !state->clip->clipRect.isEmpty()) {
251         clip &= state->clip->clipRect;
252         blend = state->penData.unclipped_blend;
253     }
254 
255     int strokeSelection = 0;
256     if (blend == state->penData.unclipped_blend
257         && state->penData.type == QSpanData::Solid
258         && (state->penData.rasterBuffer->format == QImage::Format_ARGB32_Premultiplied
259             || state->penData.rasterBuffer->format == QImage::Format_RGB32)
260         && state->compositionMode() == QPainter::CompositionMode_SourceOver)
261         strokeSelection |= FastDraw;
262 
263     if (state->renderHints & QPainter::Antialiasing)
264         strokeSelection |= AntiAliased;
265 
266     const QList<qreal> &penPattern = state->lastPen.dashPattern();
267     if (penPattern.isEmpty()) {
268         Q_ASSERT(!pattern && !reversePattern);
269         pattern = nullptr;
270         reversePattern = nullptr;
271         patternLength = 0;
272         patternSize = 0;
273     } else {
274         pattern = (int *)malloc(penPattern.size()*sizeof(int));
275         reversePattern = (int *)malloc(penPattern.size()*sizeof(int));
276         patternSize = penPattern.size();
277 
278         patternLength = 0;
279         for (int i = 0; i < patternSize; ++i) {
280             patternLength += (int) qMax(1. , penPattern.at(i)*64.);
281             pattern[i] = patternLength;
282         }
283         patternLength = 0;
284         for (int i = 0; i < patternSize; ++i) {
285             patternLength += (int) qMax(1., penPattern.at(patternSize - 1 - i)*64.);
286             reversePattern[i] = patternLength;
287         }
288         strokeSelection |= Dashed;
289 //        qDebug() << "setup: size=" << patternSize << "length=" << patternLength/64.;
290     }
291 
292     stroke = strokeLine(strokeSelection);
293 
294     qreal width = state->lastPen.widthF();
295     if (width == 0)
296         opacity = 256;
297     else if (state->lastPen.isCosmetic())
298         opacity = (int) 256*width;
299     else
300         opacity = (int) 256*width*state->txscale;
301     opacity = qBound(0, opacity, 256);
302 
303     drawCaps = state->lastPen.capStyle() != Qt::FlatCap;
304 
305     if (strokeSelection & FastDraw) {
306         color = multiplyAlpha256(state->penData.solidColor, opacity).toArgb32();
307         QRasterBuffer *buffer = state->penData.rasterBuffer;
308         pixels = (uint *)buffer->buffer();
309         ppl = buffer->stride<quint32>();
310     }
311 
312     // line drawing produces different results with different clips, so
313     // we need to clip consistently when painting to the same device
314 
315     // setup FP clip bounds
316     xmin = deviceRect.left() - 1;
317     xmax = deviceRect.right() + 2;
318     ymin = deviceRect.top() - 1;
319     ymax = deviceRect.bottom() + 2;
320 
321     lastPixel.x = INT_MIN;
322     lastPixel.y = INT_MIN;
323 }
324 
325 // returns true if the whole line gets clipped away
326 bool QCosmeticStroker::clipLine(qreal &x1, qreal &y1, qreal &x2, qreal &y2)
327 {
328     // basic/rough clipping is done in floating point coordinates to avoid
329     // integer overflow problems.
330     if (x1 < xmin) {
331         if (x2 <= xmin)
332             goto clipped;
333         y1 += (y2 - y1)/(x2 - x1) * (xmin - x1);
334         x1 = xmin;
335     } else if (x1 > xmax) {
336         if (x2 >= xmax)
337             goto clipped;
338         y1 += (y2 - y1)/(x2 - x1) * (xmax - x1);
339         x1 = xmax;
340     }
341     if (x2 < xmin) {
342         lastPixel.x = INT_MIN;
343         y2 += (y2 - y1)/(x2 - x1) * (xmin - x2);
344         x2 = xmin;
345     } else if (x2 > xmax) {
346         lastPixel.x = INT_MIN;
347         y2 += (y2 - y1)/(x2 - x1) * (xmax - x2);
348         x2 = xmax;
349     }
350 
351     if (y1 < ymin) {
352         if (y2 <= ymin)
353             goto clipped;
354         x1 += (x2 - x1)/(y2 - y1) * (ymin - y1);
355         y1 = ymin;
356     } else if (y1 > ymax) {
357         if (y2 >= ymax)
358             goto clipped;
359         x1 += (x2 - x1)/(y2 - y1) * (ymax - y1);
360         y1 = ymax;
361     }
362     if (y2 < ymin) {
363         lastPixel.x = INT_MIN;
364         x2 += (x2 - x1)/(y2 - y1) * (ymin - y2);
365         y2 = ymin;
366     } else if (y2 > ymax) {
367         lastPixel.x = INT_MIN;
368         x2 += (x2 - x1)/(y2 - y1) * (ymax - y2);
369         y2 = ymax;
370     }
371 
372     return false;
373 
374   clipped:
375     lastPixel.x = INT_MIN;
376     return true;
377 }
378 
379 
380 void QCosmeticStroker::drawLine(const QPointF &p1, const QPointF &p2)
381 {
382     if (p1 == p2) {
383         drawPoints(&p1, 1);
384         return;
385     }
386 
387     QPointF start = p1 * state->matrix;
388     QPointF end = p2 * state->matrix;
389 
390     patternOffset = state->lastPen.dashOffset()*64;
391     lastPixel.x = INT_MIN;
392     lastPixel.y = INT_MIN;
393 
394     stroke(this, start.x(), start.y(), end.x(), end.y(), drawCaps ? CapBegin|CapEnd : 0);
395 
396     blend(current_span, spans, &state->penData);
397     current_span = 0;
398 }
399 
400 void QCosmeticStroker::drawPoints(const QPoint *points, int num)
401 {
402     const QPoint *end = points + num;
403     while (points < end) {
404         QPointF p = QPointF(*points) * state->matrix;
405         drawPixel(this, qRound(p.x()), qRound(p.y()), 255);
406         ++points;
407     }
408 
409     blend(current_span, spans, &state->penData);
410     current_span = 0;
411 }
412 
413 void QCosmeticStroker::drawPoints(const QPointF *points, int num)
414 {
415     const QPointF *end = points + num;
416     while (points < end) {
417         QPointF p = (*points) * state->matrix;
418         drawPixel(this, qRound(p.x()), qRound(p.y()), 255);
419         ++points;
420     }
421 
422     blend(current_span, spans, &state->penData);
423     current_span = 0;
424 }
425 
426 void QCosmeticStroker::calculateLastPoint(qreal rx1, qreal ry1, qreal rx2, qreal ry2)
427 {
428     // this is basically the same code as used in the aliased stroke method,
429     // but it only determines the direction and last point of a line
430     //
431     // This is being used to have proper dropout control for closed contours
432     // by calculating the direction and last pixel of the last segment in the contour.
433     // the info is then used to perform dropout control when drawing the first line segment
434     // of the contour
435     lastPixel.x = INT_MIN;
436     lastPixel.y = INT_MIN;
437 
438     if (clipLine(rx1, ry1, rx2, ry2))
439         return;
440 
441     int x1 = toF26Dot6(rx1);
442     int y1 = toF26Dot6(ry1);
443     int x2 = toF26Dot6(rx2);
444     int y2 = toF26Dot6(ry2);
445 
446     int dx = qAbs(x2 - x1);
447     int dy = qAbs(y2 - y1);
448 
449     if (dx < dy) {
450         // vertical
451         bool swapped = false;
452         if (y1 > y2) {
453             swapped = true;
454             qSwap(y1, y2);
455             qSwap(x1, x2);
456         }
457         FDot16 xinc = FDot16FixedDiv(x2 - x1, y2 - y1);
458         FDot16 x = FDot16(x1) * (1<<10);
459 
460         int y = (y1 + 32) >> 6;
461         int ys = (y2 + 32) >> 6;
462 
463         int round = (xinc > 0) ? 32 : 0;
464         if (y != ys) {
465             x += ((y * (1<<6)) + round - y1) * xinc >> 6;
466 
467             if (swapped) {
468                 lastPixel.x = x >> 16;
469                 lastPixel.y = y;
470                 lastDir = QCosmeticStroker::BottomToTop;
471             } else {
472                 lastPixel.x = (x + (ys - y - 1)*xinc) >> 16;
473                 lastPixel.y = ys - 1;
474                 lastDir = QCosmeticStroker::TopToBottom;
475             }
476             lastAxisAligned = qAbs(xinc) < (1 << 14);
477         }
478     } else {
479         // horizontal
480         if (!dx)
481             return;
482 
483         bool swapped = false;
484         if (x1 > x2) {
485             swapped = true;
486             qSwap(x1, x2);
487             qSwap(y1, y2);
488         }
489         FDot16 yinc = FDot16FixedDiv(y2 - y1, x2 - x1);
490         FDot16 y = FDot16(y1) * (1 << 10);
491 
492         int x = (x1 + 32) >> 6;
493         int xs = (x2 + 32) >> 6;
494 
495         int round = (yinc > 0) ? 32 : 0;
496         if (x != xs) {
497             y += ((x * (1<<6)) + round - x1) * yinc >> 6;
498 
499             if (swapped) {
500                 lastPixel.x = x;
501                 lastPixel.y = y >> 16;
502                 lastDir = QCosmeticStroker::RightToLeft;
503             } else {
504                 lastPixel.x = xs - 1;
505                 lastPixel.y = (y + (xs - x - 1)*yinc) >> 16;
506                 lastDir = QCosmeticStroker::LeftToRight;
507             }
508             lastAxisAligned = qAbs(yinc) < (1 << 14);
509         }
510     }
511 //    qDebug() << "   moveTo: setting last pixel to x/y dir" << lastPixel.x << lastPixel.y << lastDir;
512 }
513 
514 static inline const QPainterPath::ElementType *subPath(const QPainterPath::ElementType *t, const QPainterPath::ElementType *end,
515                                                  const qreal *points, bool *closed)
516 {
517     const QPainterPath::ElementType *start = t;
518     ++t;
519 
520     // find out if the subpath is closed
521     while (t < end) {
522         if (*t == QPainterPath::MoveToElement)
523             break;
524         ++t;
525     }
526 
527     int offset = t - start - 1;
528 //    qDebug() << "subpath" << offset << points[0] << points[1] << points[2*offset] << points[2*offset+1];
529     *closed = (points[0] == points[2*offset] && points[1] == points[2*offset + 1]);
530 
531     return t;
532 }
533 
534 void QCosmeticStroker::drawPath(const QVectorPath &path)
535 {
536 //    qDebug() << ">>>> drawpath" << path.convertToPainterPath()
537 //             << "antialiasing:" << (bool)(state->renderHints & QPainter::Antialiasing) << " implicit close:" << path.hasImplicitClose();
538     if (path.isEmpty())
539         return;
540 
541     const qreal *points = path.points();
542     const QPainterPath::ElementType *type = path.elements();
543 
544     if (type) {
545         const QPainterPath::ElementType *end = type + path.elementCount();
546 
547         while (type < end) {
548             Q_ASSERT(type == path.elements() || *type == QPainterPath::MoveToElement);
549 
550             QPointF p = QPointF(points[0], points[1]) * state->matrix;
551             patternOffset = state->lastPen.dashOffset()*64;
552             lastPixel.x = INT_MIN;
553             lastPixel.y = INT_MIN;
554 
555             bool closed;
556             const QPainterPath::ElementType *e = subPath(type, end, points, &closed);
557             if (closed) {
558                 const qreal *p = points + 2*(e-type);
559                 QPointF p1 = QPointF(p[-4], p[-3]) * state->matrix;
560                 QPointF p2 = QPointF(p[-2], p[-1]) * state->matrix;
561                 calculateLastPoint(p1.x(), p1.y(), p2.x(), p2.y());
562             }
563             int caps = (!closed && drawCaps) ? CapBegin : NoCaps;
564 //            qDebug() << "closed =" << closed << capString(caps);
565 
566             points += 2;
567             ++type;
568 
569             while (type < e) {
570                 QPointF p2 = QPointF(points[0], points[1]) * state->matrix;
571                 switch (*type) {
572                 case QPainterPath::MoveToElement:
573                     Q_ASSERT(!"Logic error");
574                     break;
575 
576                 case QPainterPath::LineToElement:
577                     if (!closed && drawCaps && type == e - 1)
578                         caps |= CapEnd;
579                     stroke(this, p.x(), p.y(), p2.x(), p2.y(), caps);
580                     p = p2;
581                     points += 2;
582                     ++type;
583                     break;
584 
585                 case QPainterPath::CurveToElement: {
586                     if (!closed && drawCaps && type == e - 3)
587                         caps |= CapEnd;
588                     QPointF p3 = QPointF(points[2], points[3]) * state->matrix;
589                     QPointF p4 = QPointF(points[4], points[5]) * state->matrix;
590                     renderCubic(p, p2, p3, p4, caps);
591                     p = p4;
592                     type += 3;
593                     points += 6;
594                     break;
595                 }
596                 case QPainterPath::CurveToDataElement:
597                     Q_ASSERT(!"QPainterPath::toSubpathPolygons(), bad element type");
598                     break;
599                 }
600                 caps = NoCaps;
601             }
602         }
603     } else { // !type, simple polygon
604         QPointF p = QPointF(points[0], points[1]) * state->matrix;
605         QPointF movedTo = p;
606         patternOffset = state->lastPen.dashOffset()*64;
607         lastPixel.x = INT_MIN;
608         lastPixel.y = INT_MIN;
609 
610         const qreal *begin = points;
611         const qreal *end = points + 2*path.elementCount();
612         // handle closed path case
613         bool closed = path.hasImplicitClose() || (points[0] == end[-2] && points[1] == end[-1]);
614         int caps = (!closed && drawCaps) ? CapBegin : NoCaps;
615         if (closed) {
616             QPointF p2;
617             if (points[0] == end[-2] && points[1] == end[-1] && path.elementCount() > 2)
618                 p2 = QPointF(end[-4], end[-3]) * state->matrix;
619             else
620                 p2 = QPointF(end[-2], end[-1]) * state->matrix;
621             calculateLastPoint(p2.x(), p2.y(), p.x(), p.y());
622         }
623 
624         bool fastPenAliased = (state->flags.fast_pen && !state->flags.antialiased);
625         points += 2;
626         while (points < end) {
627             QPointF p2 = QPointF(points[0], points[1]) * state->matrix;
628 
629             if (!closed && drawCaps && points == end - 2)
630                 caps |= CapEnd;
631 
632             bool moveNextStart = stroke(this, p.x(), p.y(), p2.x(), p2.y(), caps);
633 
634             /* fix for gaps in polylines with fastpen and aliased in a sequence
635                of points with small distances: if current point p2 has been dropped
636                out, keep last non dropped point p.
637 
638                However, if the line was completely outside the devicerect, we
639                still need to update p to avoid drawing the line after this one from
640                a bad starting position.
641             */
642             if (!fastPenAliased || moveNextStart || points == begin + 2 || points == end - 2)
643                 p = p2;
644             points += 2;
645             caps = NoCaps;
646         }
647         if (path.hasImplicitClose())
648             stroke(this, p.x(), p.y(), movedTo.x(), movedTo.y(), NoCaps);
649     }
650 
651 
652     blend(current_span, spans, &state->penData);
653     current_span = 0;
654 }
655 
656 void QCosmeticStroker::renderCubic(const QPointF &p1, const QPointF &p2, const QPointF &p3, const QPointF &p4, int caps)
657 {
658 //    qDebug() << ">>>> renderCubic" << p1 << p2 << p3 << p4 << capString(caps);
659     const int maxSubDivisions = 6;
660     PointF points[3*maxSubDivisions + 4];
661 
662     points[3].x = p1.x();
663     points[3].y = p1.y();
664     points[2].x = p2.x();
665     points[2].y = p2.y();
666     points[1].x = p3.x();
667     points[1].y = p3.y();
668     points[0].x = p4.x();
669     points[0].y = p4.y();
670 
671     PointF *p = points;
672     int level = maxSubDivisions;
673 
674     renderCubicSubdivision(p, level, caps);
675 }
676 
677 static void splitCubic(QCosmeticStroker::PointF *points)
678 {
679     const qreal half = .5;
680     qreal  a, b, c, d;
681 
682     points[6].x = points[3].x;
683     c = points[1].x;
684     d = points[2].x;
685     points[1].x = a = ( points[0].x + c ) * half;
686     points[5].x = b = ( points[3].x + d ) * half;
687     c = ( c + d ) * half;
688     points[2].x = a = ( a + c ) * half;
689     points[4].x = b = ( b + c ) * half;
690     points[3].x = ( a + b ) * half;
691 
692     points[6].y = points[3].y;
693     c = points[1].y;
694     d = points[2].y;
695     points[1].y = a = ( points[0].y + c ) * half;
696     points[5].y = b = ( points[3].y + d ) * half;
697     c = ( c + d ) * half;
698     points[2].y = a = ( a + c ) * half;
699     points[4].y = b = ( b + c ) * half;
700     points[3].y = ( a + b ) * half;
701 }
702 
703 void QCosmeticStroker::renderCubicSubdivision(QCosmeticStroker::PointF *points, int level, int caps)
704 {
705     if (level) {
706         qreal dx = points[3].x - points[0].x;
707         qreal dy = points[3].y - points[0].y;
708         qreal len = ((qreal).25) * (qAbs(dx) + qAbs(dy));
709 
710         if (qAbs(dx * (points[0].y - points[2].y) - dy * (points[0].x - points[2].x)) >= len ||
711             qAbs(dx * (points[0].y - points[1].y) - dy * (points[0].x - points[1].x)) >= len) {
712             splitCubic(points);
713 
714             --level;
715             renderCubicSubdivision(points + 3, level, caps & CapBegin);
716             renderCubicSubdivision(points, level, caps & CapEnd);
717             return;
718         }
719     }
720 
721     stroke(this, points[3].x, points[3].y, points[0].x, points[0].y, caps);
722 }
723 
724 static inline int swapCaps(int caps)
725 {
726     return ((caps & QCosmeticStroker::CapBegin) << 1) |
727            ((caps & QCosmeticStroker::CapEnd) >> 1);
728 }
729 
730 // adjust line by half a pixel
731 static inline void capAdjust(int caps, int &x1, int &x2, FDot16 &y, FDot16 yinc)
732 {
733     if (caps & QCosmeticStroker::CapBegin) {
734         x1 -= 32;
735         y -= yinc >> 1;
736     }
737     if (caps & QCosmeticStroker::CapEnd) {
738         x2 += 32;
739     }
740 }
741 
742 /*
743   The hard part about this is dropout control and avoiding douple drawing of points when
744   the drawing shifts from horizontal to vertical or back.
745   */
746 template<DrawPixel drawPixel, class Dasher>
747 static bool drawLine(QCosmeticStroker *stroker, qreal rx1, qreal ry1, qreal rx2, qreal ry2, int caps)
748 {
749     bool didDraw = qAbs(rx2 - rx1) + qAbs(ry2 - ry1) >= 1.0;
750 
751     if (stroker->clipLine(rx1, ry1, rx2, ry2))
752         return true;
753 
754     int x1 = toF26Dot6(rx1);
755     int y1 = toF26Dot6(ry1);
756     int x2 = toF26Dot6(rx2);
757     int y2 = toF26Dot6(ry2);
758 
759     int dx = qAbs(x2 - x1);
760     int dy = qAbs(y2 - y1);
761 
762     QCosmeticStroker::Point last = stroker->lastPixel;
763 
764 //    qDebug() << "stroke" << x1/64. << y1/64. << x2/64. << y2/64.;
765 
766     if (dx < dy) {
767         // vertical
768         QCosmeticStroker::Direction dir = QCosmeticStroker::TopToBottom;
769 
770         bool swapped = false;
771         if (y1 > y2) {
772             swapped = true;
773             qSwap(y1, y2);
774             qSwap(x1, x2);
775             caps = swapCaps(caps);
776             dir = QCosmeticStroker::BottomToTop;
777         }
778         FDot16 xinc = FDot16FixedDiv(x2 - x1, y2 - y1);
779         FDot16 x = FDot16(x1) * (1<<10);
780 
781         if ((stroker->lastDir ^ QCosmeticStroker::VerticalMask) == dir)
782             caps |= swapped ? QCosmeticStroker::CapEnd : QCosmeticStroker::CapBegin;
783 
784         capAdjust(caps, y1, y2, x, xinc);
785 
786         int y = (y1 + 32) >> 6;
787         int ys = (y2 + 32) >> 6;
788         int round = (xinc > 0) ? 32 : 0;
789 
790         // If capAdjust made us round away from what calculateLastPoint gave us,
791         // round back the other way so we start and end on the right point.
792         if ((caps & QCosmeticStroker::CapBegin) && stroker->lastPixel.y == y + 1)
793            y++;
794 
795         if (y != ys) {
796             x += ((y * (1<<6)) + round - y1) * xinc >> 6;
797 
798             // calculate first and last pixel and perform dropout control
799             QCosmeticStroker::Point first;
800             first.x = x >> 16;
801             first.y = y;
802             last.x = (x + (ys - y - 1)*xinc) >> 16;
803             last.y = ys - 1;
804             if (swapped)
805                 qSwap(first, last);
806 
807             bool axisAligned = qAbs(xinc) < (1 << 14);
808             if (stroker->lastPixel.x > INT_MIN) {
809                 if (first.x == stroker->lastPixel.x &&
810                     first.y == stroker->lastPixel.y) {
811                     // remove duplicated pixel
812                     if (swapped) {
813                         --ys;
814                     } else {
815                         ++y;
816                         x += xinc;
817                     }
818                 } else if (stroker->lastDir != dir &&
819                            (((axisAligned && stroker->lastAxisAligned) &&
820                              stroker->lastPixel.x != first.x && stroker->lastPixel.y != first.y) ||
821                             (qAbs(stroker->lastPixel.x - first.x) > 1 ||
822                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
823                     // have a missing pixel, insert it
824                     if (swapped) {
825                         ++ys;
826                     } else {
827                         --y;
828                         x -= xinc;
829                     }
830                 } else if (stroker->lastDir == dir &&
831                            ((qAbs(stroker->lastPixel.x - first.x) <= 1 &&
832                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
833                     x += xinc >> 1;
834                     if (swapped)
835                         last.x = (x >> 16);
836                     else
837                         last.x = (x + (ys - y - 1)*xinc) >> 16;
838                 }
839             }
840             stroker->lastDir = dir;
841             stroker->lastAxisAligned = axisAligned;
842 
843             Dasher dasher(stroker, swapped, y * (1<<6), ys * (1<<6));
844 
845             do {
846                 if (dasher.on())
847                     drawPixel(stroker, x >> 16, y, 255);
848                 dasher.adjust();
849                 x += xinc;
850             } while (++y < ys);
851             didDraw = true;
852         }
853     } else {
854         // horizontal
855         if (!dx)
856             return true;
857 
858         QCosmeticStroker::Direction dir = QCosmeticStroker::LeftToRight;
859 
860         bool swapped = false;
861         if (x1 > x2) {
862             swapped = true;
863             qSwap(x1, x2);
864             qSwap(y1, y2);
865             caps = swapCaps(caps);
866             dir = QCosmeticStroker::RightToLeft;
867         }
868         FDot16 yinc = FDot16FixedDiv(y2 - y1, x2 - x1);
869         FDot16 y = FDot16(y1) * (1<<10);
870 
871         if ((stroker->lastDir ^ QCosmeticStroker::HorizontalMask) == dir)
872             caps |= swapped ? QCosmeticStroker::CapEnd : QCosmeticStroker::CapBegin;
873 
874         capAdjust(caps, x1, x2, y, yinc);
875 
876         int x = (x1 + 32) >> 6;
877         int xs = (x2 + 32) >> 6;
878         int round = (yinc > 0) ? 32 : 0;
879 
880         // If capAdjust made us round away from what calculateLastPoint gave us,
881         // round back the other way so we start and end on the right point.
882         if ((caps & QCosmeticStroker::CapBegin) && stroker->lastPixel.x == x + 1)
883             x++;
884 
885         if (x != xs) {
886             y += ((x * (1<<6)) + round - x1) * yinc >> 6;
887 
888             // calculate first and last pixel to perform dropout control
889             QCosmeticStroker::Point first;
890             first.x = x;
891             first.y = y >> 16;
892             last.x = xs - 1;
893             last.y = (y + (xs - x - 1)*yinc) >> 16;
894             if (swapped)
895                 qSwap(first, last);
896 
897             bool axisAligned = qAbs(yinc) < (1 << 14);
898             if (stroker->lastPixel.x > INT_MIN) {
899                 if (first.x == stroker->lastPixel.x && first.y == stroker->lastPixel.y) {
900                     // remove duplicated pixel
901                     if (swapped) {
902                         --xs;
903                     } else {
904                         ++x;
905                         y += yinc;
906                     }
907                 } else if (stroker->lastDir != dir &&
908                            (((axisAligned && stroker->lastAxisAligned) &&
909                              stroker->lastPixel.x != first.x && stroker->lastPixel.y != first.y) ||
910                             (qAbs(stroker->lastPixel.x - first.x) > 1 ||
911                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
912                     // have a missing pixel, insert it
913                     if (swapped) {
914                         ++xs;
915                     } else {
916                         --x;
917                         y -= yinc;
918                     }
919                 } else if (stroker->lastDir == dir &&
920                            ((qAbs(stroker->lastPixel.x - first.x) <= 1 &&
921                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
922                     y += yinc >> 1;
923                     if (swapped)
924                         last.y = (y >> 16);
925                     else
926                         last.y = (y + (xs - x - 1)*yinc) >> 16;
927                 }
928             }
929             stroker->lastDir = dir;
930             stroker->lastAxisAligned = axisAligned;
931 
932             Dasher dasher(stroker, swapped, x * (1<<6), xs * (1<<6));
933 
934             do {
935                 if (dasher.on())
936                     drawPixel(stroker, x, y >> 16, 255);
937                 dasher.adjust();
938                 y += yinc;
939             } while (++x < xs);
940             didDraw = true;
941         }
942     }
943     stroker->lastPixel = last;
944     return didDraw;
945 }
946 
947 
948 template<DrawPixel drawPixel, class Dasher>
949 static bool drawLineAA(QCosmeticStroker *stroker, qreal rx1, qreal ry1, qreal rx2, qreal ry2, int caps)
950 {
951     if (stroker->clipLine(rx1, ry1, rx2, ry2))
952         return true;
953 
954     int x1 = toF26Dot6(rx1);
955     int y1 = toF26Dot6(ry1);
956     int x2 = toF26Dot6(rx2);
957     int y2 = toF26Dot6(ry2);
958 
959     int dx = x2 - x1;
960     int dy = y2 - y1;
961 
962     if (qAbs(dx) < qAbs(dy)) {
963         // vertical
964 
965         FDot16 xinc = FDot16FixedDiv(dx, dy);
966 
967         bool swapped = false;
968         if (y1 > y2) {
969             qSwap(y1, y2);
970             qSwap(x1, x2);
971             swapped = true;
972             caps = swapCaps(caps);
973         }
974 
975         FDot16 x = FDot16(x1 - 32) * (1<<10);
976         x -= ( ((y1 & 63) - 32)  * xinc ) >> 6;
977 
978         capAdjust(caps, y1, y2, x, xinc);
979 
980         Dasher dasher(stroker, swapped, y1, y2);
981 
982         int y = y1 >> 6;
983         int ys = y2 >> 6;
984 
985         int alphaStart, alphaEnd;
986         if (y == ys) {
987             alphaStart = y2 - y1;
988             Q_ASSERT(alphaStart >= 0 && alphaStart < 64);
989             alphaEnd = 0;
990         } else {
991             alphaStart = 64 - (y1 & 63);
992             alphaEnd = (y2 & 63);
993         }
994 //        qDebug() << "vertical" << x1/64. << y1/64. << x2/64. << y2/64.;
995 //        qDebug() << "          x=" << x << "dx=" << dx << "xi=" << (x>>16) << "xsi=" << ((x+(ys-y)*dx)>>16) << "y=" << y << "ys=" << ys;
996 
997         // draw first pixel
998         if (dasher.on()) {
999             uint alpha = (quint8)(x >> 8);
1000             drawPixel(stroker, x>>16, y, (255-alpha) * alphaStart >> 6);
1001             drawPixel(stroker, (x>>16) + 1, y, alpha * alphaStart >> 6);
1002         }
1003         dasher.adjust();
1004         x += xinc;
1005         ++y;
1006         if (y < ys) {
1007             do {
1008                 if (dasher.on()) {
1009                     uint alpha = (quint8)(x >> 8);
1010                     drawPixel(stroker, x>>16, y, (255-alpha));
1011                     drawPixel(stroker, (x>>16) + 1, y, alpha);
1012                 }
1013                 dasher.adjust();
1014                 x += xinc;
1015             } while (++y < ys);
1016         }
1017         // draw last pixel
1018         if (alphaEnd && dasher.on()) {
1019             uint alpha = (quint8)(x >> 8);
1020             drawPixel(stroker, x>>16, y, (255-alpha) * alphaEnd >> 6);
1021             drawPixel(stroker, (x>>16) + 1, y, alpha * alphaEnd >> 6);
1022         }
1023     } else {
1024         // horizontal
1025         if (!dx)
1026             return true;
1027 
1028         FDot16 yinc = FDot16FixedDiv(dy, dx);
1029 
1030         bool swapped = false;
1031         if (x1 > x2) {
1032             qSwap(x1, x2);
1033             qSwap(y1, y2);
1034             swapped = true;
1035             caps = swapCaps(caps);
1036         }
1037 
1038         FDot16 y = FDot16(y1 - 32) * (1<<10);
1039         y -= ( ((x1 & 63) - 32)  * yinc ) >> 6;
1040 
1041         capAdjust(caps, x1, x2, y, yinc);
1042 
1043         Dasher dasher(stroker, swapped, x1, x2);
1044 
1045         int x = x1 >> 6;
1046         int xs = x2 >> 6;
1047 
1048 //        qDebug() << "horizontal" << x1/64. << y1/64. << x2/64. << y2/64.;
1049 //        qDebug() << "          y=" << y << "dy=" << dy << "x=" << x << "xs=" << xs << "yi=" << (y>>16) << "ysi=" << ((y+(xs-x)*dy)>>16);
1050         int alphaStart, alphaEnd;
1051         if (x == xs) {
1052             alphaStart = x2 - x1;
1053             Q_ASSERT(alphaStart >= 0 && alphaStart < 64);
1054             alphaEnd = 0;
1055         } else {
1056             alphaStart = 64 - (x1 & 63);
1057             alphaEnd = (x2 & 63);
1058         }
1059 
1060         // draw first pixel
1061         if (dasher.on()) {
1062             uint alpha = (quint8)(y >> 8);
1063             drawPixel(stroker, x, y>>16, (255-alpha) * alphaStart >> 6);
1064             drawPixel(stroker, x, (y>>16) + 1, alpha * alphaStart >> 6);
1065         }
1066         dasher.adjust();
1067         y += yinc;
1068         ++x;
1069         // draw line
1070         if (x < xs) {
1071             do {
1072                 if (dasher.on()) {
1073                     uint alpha = (quint8)(y >> 8);
1074                     drawPixel(stroker, x, y>>16, (255-alpha));
1075                     drawPixel(stroker, x, (y>>16) + 1, alpha);
1076                 }
1077                 dasher.adjust();
1078                 y += yinc;
1079             } while (++x < xs);
1080         }
1081         // draw last pixel
1082         if (alphaEnd && dasher.on()) {
1083             uint alpha = (quint8)(y >> 8);
1084             drawPixel(stroker, x, y>>16, (255-alpha) * alphaEnd >> 6);
1085             drawPixel(stroker, x, (y>>16) + 1, alpha * alphaEnd >> 6);
1086         }
1087     }
1088     return true;
1089 }
1090 
1091 QT_END_NAMESPACE
