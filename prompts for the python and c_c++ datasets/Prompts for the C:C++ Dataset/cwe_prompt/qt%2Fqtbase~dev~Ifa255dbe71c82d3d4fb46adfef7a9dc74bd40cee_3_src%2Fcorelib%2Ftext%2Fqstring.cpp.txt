Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 The Qt Company Ltd.
4 ** Copyright (C) 2020 Intel Corporation.
5 ** Copyright (C) 2019 Mail.ru Group.
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qstringlist.h"
43 #if QT_CONFIG(regularexpression)
44 #include "qregularexpression.h"
45 #endif
46 #include "qunicodetables_p.h"
47 #include <private/qstringconverter_p.h>
48 #include "qlocale_tools_p.h"
49 #include "private/qsimd_p.h"
50 #include <qnumeric.h>
51 #include <qdatastream.h>
52 #include <qlist.h>
53 #include "qlocale.h"
54 #include "qlocale_p.h"
55 #include "qstringbuilder.h"
56 #include "qstringmatcher.h"
57 #include "qvarlengtharray.h"
58 #include "qdebug.h"
59 #include "qendian.h"
60 #include "qcollator.h"
61 
62 #ifdef Q_OS_MAC
63 #include <private/qcore_mac_p.h>
64 #endif
65 
66 #include <private/qfunctions_p.h>
67 
68 #include <limits.h>
69 #include <string.h>
70 #include <stdlib.h>
71 #include <stdio.h>
72 #include <stdarg.h>
73 #include <wchar.h>
74 
75 #include "qchar.cpp"
76 #include "qstringmatcher.cpp"
77 #include "qstringiterator_p.h"
78 #include "qstringalgorithms_p.h"
79 #include "qthreadstorage.h"
80 
81 #include "qbytearraymatcher.h" // Helper for comparison of QLatin1String
82 
83 #include <algorithm>
84 #include <functional>
85 
86 #ifdef Q_OS_WIN
87 #  include <qt_windows.h>
88 #endif
89 
90 #ifdef truncate
91 #  undef truncate
92 #endif
93 
94 #ifndef LLONG_MAX
95 #define LLONG_MAX qint64_C(9223372036854775807)
96 #endif
97 #ifndef LLONG_MIN
98 #define LLONG_MIN (-LLONG_MAX - qint64_C(1))
99 #endif
100 #ifndef ULLONG_MAX
101 #define ULLONG_MAX quint64_C(18446744073709551615)
102 #endif
103 
104 #define IS_RAW_DATA(d) ((d.d)->flags & QArrayData::RawDataType)
105 
106 QT_BEGIN_NAMESPACE
107 
108 const char16_t QString::_empty = 0;
109 
110 /*
111  * Note on the use of SIMD in qstring.cpp:
112  *
113  * Several operations with strings are improved with the use of SIMD code,
114  * since they are repetitive. For MIPS, we have hand-written assembly code
115  * outside of qstring.cpp targeting MIPS DSP and MIPS DSPr2. For ARM and for
116  * x86, we can only use intrinsics and therefore everything is contained in
117  * qstring.cpp. We need to use intrinsics only for those platforms due to the
118  * different compilers and toolchains used, which have different syntax for
119  * assembly sources.
120  *
121  * ** SSE notes: **
122  *
123  * Whenever multiple alternatives are equivalent or near so, we prefer the one
124  * using instructions from SSE2, since SSE2 is guaranteed to be enabled for all
125  * 64-bit builds and we enable it for 32-bit builds by default. Use of higher
126  * SSE versions should be done when there is a clear performance benefit and
127  * requires fallback code to SSE2, if it exists.
128  *
129  * Performance measurement in the past shows that most strings are short in
130  * size and, therefore, do not benefit from alignment prologues. That is,
131  * trying to find a 16-byte-aligned boundary to operate on is often more
132  * expensive than executing the unaligned operation directly. In addition, note
133  * that the QString private data is designed so that the data is stored on
134  * 16-byte boundaries if the system malloc() returns 16-byte aligned pointers
135  * on its own (64-bit glibc on Linux does; 32-bit glibc on Linux returns them
136  * 50% of the time), so skipping the alignment prologue is actually optimizing
137  * for the common case.
138  */
139 
140 #if defined(__mips_dsp)
141 // From qstring_mips_dsp_asm.S
142 extern "C" void qt_fromlatin1_mips_asm_unroll4 (char16_t*, const char*, uint);
143 extern "C" void qt_fromlatin1_mips_asm_unroll8 (char16_t*, const char*, uint);
144 extern "C" void qt_toLatin1_mips_dsp_asm(uchar *dst, const char16_t *src, int length);
145 #endif
146 
147 // internal
148 qsizetype qFindStringBoyerMoore(QStringView haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs);
149 static inline qsizetype qFindChar(QStringView str, QChar ch, qsizetype from, Qt::CaseSensitivity cs) noexcept;
150 template <typename Haystack>
151 static inline qsizetype qLastIndexOf(Haystack haystack, QChar needle, qsizetype from, Qt::CaseSensitivity cs) noexcept;
152 template <>
153 inline qsizetype qLastIndexOf(QString haystack, QChar needle,
154                               qsizetype from, Qt::CaseSensitivity cs) noexcept = delete; // unwanted, would detach
155 
156 static inline bool qt_starts_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs);
157 static inline bool qt_starts_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs);
158 static inline bool qt_starts_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs);
159 static inline bool qt_ends_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs);
160 static inline bool qt_ends_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs);
161 static inline bool qt_ends_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs);
162 
163 #if defined(__SSE2__) && defined(Q_CC_GNU) && !defined(Q_CC_INTEL)
164 #  if defined(__SANITIZE_ADDRESS__) && Q_CC_GNU < 800 && !defined(Q_CC_CLANG)
165 #     warning "The __attribute__ on below will likely cause a build failure with your GCC version. Your choices are:"
166 #     warning "1) disable ASan;"
167 #     warning "2) disable the optimized code in qustrlen (change __SSE2__ to anything else);"
168 #     warning "3) upgrade your compiler (preferred)."
169 #  endif
170 
171 // We may overrun the buffer, but that's a false positive:
172 // this won't crash nor produce incorrect results
173 __attribute__((__no_sanitize_address__))
174 #endif
175 qsizetype QtPrivate::qustrlen(const char16_t *str) noexcept
176 {
177     qsizetype result = 0;
178 
179 #if defined(__SSE2__) && !(defined(__SANITIZE_ADDRESS__) || __has_feature(address_sanitizer))
180     // find the 16-byte alignment immediately prior or equal to str
181     quintptr misalignment = quintptr(str) & 0xf;
182     Q_ASSERT((misalignment & 1) == 0);
183     const char16_t *ptr = str - (misalignment / 2);
184 
185     // load 16 bytes and see if we have a null
186     // (aligned loads can never segfault)
187     const __m128i zeroes = _mm_setzero_si128();
188     __m128i data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
189     __m128i comparison = _mm_cmpeq_epi16(data, zeroes);
190     quint32 mask = _mm_movemask_epi8(comparison);
191 
192     // ignore the result prior to the beginning of str
193     mask >>= misalignment;
194 
195     // Have we found something in the first block? Need to handle it now
196     // because of the left shift above.
197     if (mask)
198         return qCountTrailingZeroBits(quint32(mask)) / 2;
199 
200     do {
201         ptr += 8;
202         data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
203 
204         comparison = _mm_cmpeq_epi16(data, zeroes);
205         mask = _mm_movemask_epi8(comparison);
206     } while (mask == 0);
207 
208     // found a null
209     uint idx = qCountTrailingZeroBits(quint32(mask));
210     return ptr - str + idx / 2;
211 #endif
212 
213     if (sizeof(wchar_t) == sizeof(char16_t))
214         return wcslen(reinterpret_cast<const wchar_t *>(str));
215 
216     while (*str++)
217         ++result;
218     return result;
219 }
220 
221 #if !defined(__OPTIMIZE_SIZE__)
222 namespace {
223 template <uint MaxCount> struct UnrollTailLoop
224 {
225     template <typename RetType, typename Functor1, typename Functor2, typename Number>
226     static inline RetType exec(Number count, RetType returnIfExited, Functor1 loopCheck, Functor2 returnIfFailed, Number i = 0)
227     {
228         /* equivalent to:
229          *   while (count--) {
230          *       if (loopCheck(i))
231          *           return returnIfFailed(i);
232          *   }
233          *   return returnIfExited;
234          */
235 
236         if (!count)
237             return returnIfExited;
238 
239         bool check = loopCheck(i);
240         if (check)
241             return returnIfFailed(i);
242 
243         return UnrollTailLoop<MaxCount - 1>::exec(count - 1, returnIfExited, loopCheck, returnIfFailed, i + 1);
244     }
245 
246     template <typename Functor, typename Number>
247     static inline void exec(Number count, Functor code)
248     {
249         /* equivalent to:
250          *   for (Number i = 0; i < count; ++i)
251          *       code(i);
252          */
253         exec(count, 0, [=](Number i) -> bool { code(i); return false; }, [](Number) { return 0; });
254     }
255 };
256 template <> template <typename RetType, typename Functor1, typename Functor2, typename Number>
257 inline RetType UnrollTailLoop<0>::exec(Number, RetType returnIfExited, Functor1, Functor2, Number)
258 {
259     return returnIfExited;
260 }
261 }
262 #endif
263 
264 /*!
265  * \internal
266  *
267  * Searches for character \a c in the string \a str and returns a pointer to
268  * it. Unlike strchr() and wcschr() (but like glibc's strchrnul()), if the
269  * character is not found, this function returns a pointer to the end of the
270  * string -- that is, \c{str.end()}.
271  */
272 const char16_t *QtPrivate::qustrchr(QStringView str, char16_t c) noexcept
273 {
274     const char16_t *n = str.utf16();
275     const char16_t *e = n + str.size();
276 
277 #ifdef __SSE2__
278     bool loops = true;
279     // Using the PMOVMSKB instruction, we get two bits for each character
280     // we compare.
281 #  if defined(__AVX2__) && !defined(__OPTIMIZE_SIZE__)
282     // we're going to read n[0..15] (32 bytes)
283     __m256i mch256 = _mm256_set1_epi32(c | (c << 16));
284     for (const char16_t *next = n + 16; next <= e; n = next, next += 16) {
285         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(n));
286         __m256i result = _mm256_cmpeq_epi16(data, mch256);
287         uint mask = uint(_mm256_movemask_epi8(result));
288         if (mask) {
289             uint idx = qCountTrailingZeroBits(mask);
290             return n + idx / 2;
291         }
292     }
293     loops = false;
294     __m128i mch = _mm256_castsi256_si128(mch256);
295 #  else
296     __m128i mch = _mm_set1_epi32(c | (c << 16));
297 #  endif
298 
299     auto hasMatch = [mch, &n](__m128i data, ushort validityMask) {
300         __m128i result = _mm_cmpeq_epi16(data, mch);
301         uint mask = uint(_mm_movemask_epi8(result));
302         if ((mask & validityMask) == 0)
303             return false;
304         uint idx = qCountTrailingZeroBits(mask);
305         n += idx / 2;
306         return true;
307     };
308 
309     // we're going to read n[0..7] (16 bytes)
310     for (const char16_t *next = n + 8; next <= e; n = next, next += 8) {
311         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(n));
312         if (hasMatch(data, 0xffff))
313             return n;
314 
315         if (!loops) {
316             n += 8;
317             break;
318         }
319     }
320 
321 #  if !defined(__OPTIMIZE_SIZE__)
322     // we're going to read n[0..3] (8 bytes)
323     if (e - n > 3) {
324         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(n));
325         if (hasMatch(data, 0xff))
326             return n;
327 
328         n += 4;
329     }
330 
331     return UnrollTailLoop<3>::exec(e - n, e,
332                                    [=](int i) { return n[i] == c; },
333                                    [=](int i) { return n + i; });
334 #  endif
335 #elif defined(__ARM_NEON__)
336     const uint16x8_t vmask = { 1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7 };
337     const uint16x8_t ch_vec = vdupq_n_u16(c);
338     for (const char16_t *next = n + 8; next <= e; n = next, next += 8) {
339         uint16x8_t data = vld1q_u16(reinterpret_cast<const uint16_t *>(n));
340         uint mask = vaddvq_u16(vandq_u16(vceqq_u16(data, ch_vec), vmask));
341         if (ushort(mask)) {
342             // found a match
343             return n + qCountTrailingZeroBits(mask);
344         }
345     }
346 #endif // aarch64
347 
348     --n;
349     while (++n != e)
350         if (*n == c)
351             return n;
352 
353     return n;
354 }
355 
356 #ifdef __SSE2__
357 // Scans from \a ptr to \a end until \a maskval is non-zero. Returns true if
358 // the no non-zero was found. Returns false and updates \a ptr to point to the
359 // first 16-bit word that has any bit set (note: if the input is 8-bit, \a ptr
360 // may be updated to one byte short).
361 static bool simdTestMask(const char *&ptr, const char *end, quint32 maskval)
362 {
363     auto updatePtr = [&](uint result) {
364         // found a character matching the mask
365         uint idx = qCountTrailingZeroBits(~result);
366         ptr += idx;
367         return false;
368     };
369 
370 #  if defined(__SSE4_1__)
371     __m128i mask;
372     auto updatePtrSimd = [&](__m128i data) {
373         __m128i masked = _mm_and_si128(mask, data);
374         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
375         uint result = _mm_movemask_epi8(comparison);
376         return updatePtr(result);
377     };
378 
379 #    if defined(__AVX2__)
380     // AVX2 implementation: test 32 bytes at a time
381     const __m256i mask256 = _mm256_broadcastd_epi32(_mm_cvtsi32_si128(maskval));
382     while (ptr + 32 <= end) {
383         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr));
384         if (!_mm256_testz_si256(mask256, data)) {
385             // found a character matching the mask
386             __m256i masked256 = _mm256_and_si256(mask256, data);
387             __m256i comparison256 = _mm256_cmpeq_epi16(masked256, _mm256_setzero_si256());
388             return updatePtr(_mm256_movemask_epi8(comparison256));
389         }
390         ptr += 32;
391     }
392 
393     mask = _mm256_castsi256_si128(mask256);
394 #    else
395     // SSE 4.1 implementation: test 32 bytes at a time (two 16-byte
396     // comparisons, unrolled)
397     mask = _mm_set1_epi32(maskval);
398     while (ptr + 32 <= end) {
399         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
400         __m128i data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr + 16));
401         if (!_mm_testz_si128(mask, data1))
402             return updatePtrSimd(data1);
403 
404         ptr += 16;
405         if (!_mm_testz_si128(mask, data2))
406             return updatePtrSimd(data2);
407         ptr += 16;
408     }
409 #    endif
410 
411     // AVX2 and SSE4.1: final 16-byte comparison
412     if (ptr + 16 <= end) {
413         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
414         if (!_mm_testz_si128(mask, data1))
415             return updatePtrSimd(data1);
416         ptr += 16;
417     }
418 
419     // and final 8-byte comparison
420     if (ptr + 8 <= end) {
421         __m128i data1 = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
422         if (!_mm_testz_si128(mask, data1))
423             return updatePtrSimd(data1);
424         ptr += 8;
425     }
426 
427 #  else
428     // SSE2 implementation: test 16 bytes at a time.
429     const __m128i mask = _mm_set1_epi32(maskval);
430     while (ptr + 16 <= end) {
431         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
432         __m128i masked = _mm_and_si128(mask, data);
433         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
434         quint16 result = _mm_movemask_epi8(comparison);
435         if (result != 0xffff)
436             return updatePtr(result);
437         ptr += 16;
438     }
439 
440     // and one 8-byte comparison
441     if (ptr + 8 <= end) {
442         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
443         __m128i masked = _mm_and_si128(mask, data);
444         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
445         quint8 result = _mm_movemask_epi8(comparison);
446         if (result != 0xff)
447             return updatePtr(result);
448         ptr += 8;
449     }
450 #  endif
451 
452     return true;
453 }
454 
455 static Q_ALWAYS_INLINE __m128i mm_load8_zero_extend(const void *ptr)
456 {
457     const __m128i *dataptr = static_cast<const __m128i *>(ptr);
458 #if defined(__SSE4_1__)
459     // use a MOVQ followed by PMOVZXBW
460     // if AVX2 is present, these should combine into a single VPMOVZXBW instruction
461     __m128i data = _mm_loadl_epi64(dataptr);
462     return _mm_cvtepu8_epi16(data);
463 #  else
464     // use MOVQ followed by PUNPCKLBW
465     __m128i data = _mm_loadl_epi64(dataptr);
466     return _mm_unpacklo_epi8(data, _mm_setzero_si128());
467 #  endif
468 }
469 #endif
470 
471 // Note: ptr on output may be off by one and point to a preceding US-ASCII
472 // character. Usually harmless.
473 bool qt_is_ascii(const char *&ptr, const char *end) noexcept
474 {
475 #if defined(__SSE2__)
476     // Testing for the high bit can be done efficiently with just PMOVMSKB
477 #  if defined(__AVX2__)
478     while (ptr + 32 <= end) {
479         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr));
480         quint32 mask = _mm256_movemask_epi8(data);
481         if (mask) {
482             uint idx = qCountTrailingZeroBits(mask);
483             ptr += idx;
484             return false;
485         }
486         ptr += 32;
487     }
488 #  endif
489     while (ptr + 16 <= end) {
490         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
491         quint32 mask = _mm_movemask_epi8(data);
492         if (mask) {
493             uint idx = qCountTrailingZeroBits(mask);
494             ptr += idx;
495             return false;
496         }
497         ptr += 16;
498     }
499     if (ptr + 8 <= end) {
500         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
501         quint8 mask = _mm_movemask_epi8(data);
502         if (mask) {
503             uint idx = qCountTrailingZeroBits(mask);
504             ptr += idx;
505             return false;
506         }
507         ptr += 8;
508     }
509 #endif
510 
511     while (ptr + 4 <= end) {
512         quint32 data = qFromUnaligned<quint32>(ptr);
513         if (data &= 0x80808080U) {
514 #if Q_BYTE_ORDER == Q_BIG_ENDIAN
515             uint idx = qCountLeadingZeroBits(data);
516 #else
517             uint idx = qCountTrailingZeroBits(data);
518 #endif
519             ptr += idx / 8;
520             return false;
521         }
522         ptr += 4;
523     }
524 
525     while (ptr != end) {
526         if (quint8(*ptr) & 0x80)
527             return false;
528         ++ptr;
529     }
530     return true;
531 }
532 
533 bool QtPrivate::isAscii(QLatin1String s) noexcept
534 {
535     const char *ptr = s.begin();
536     const char *end = s.end();
537 
538     return qt_is_ascii(ptr, end);
539 }
540 
541 static bool isAscii(const QChar *&ptr, const QChar *end)
542 {
543 #ifdef __SSE2__
544     const char *ptr8 = reinterpret_cast<const char *>(ptr);
545     const char *end8 = reinterpret_cast<const char *>(end);
546     bool ok = simdTestMask(ptr8, end8, 0xff80ff80);
547     ptr = reinterpret_cast<const QChar *>(ptr8);
548     if (!ok)
549         return false;
550 #endif
551 
552     while (ptr != end) {
553         if (ptr->unicode() & 0xff80)
554             return false;
555         ++ptr;
556     }
557     return true;
558 }
559 
560 bool QtPrivate::isAscii(QStringView s) noexcept
561 {
562     const QChar *ptr = s.begin();
563     const QChar *end = s.end();
564 
565     return isAscii(ptr, end);
566 }
567 
568 bool QtPrivate::isLatin1(QStringView s) noexcept
569 {
570     const QChar *ptr = s.begin();
571     const QChar *end = s.end();
572 
573 #ifdef __SSE2__
574     const char *ptr8 = reinterpret_cast<const char *>(ptr);
575     const char *end8 = reinterpret_cast<const char *>(end);
576     if (!simdTestMask(ptr8, end8, 0xff00ff00))
577         return false;
578     ptr = reinterpret_cast<const QChar *>(ptr8);
579 #endif
580 
581     while (ptr != end) {
582         if ((*ptr++).unicode() > 0xff)
583             return false;
584     }
585     return true;
586 }
587 
588 bool QtPrivate::isValidUtf16(QStringView s) noexcept
589 {
590     constexpr char32_t InvalidCodePoint = UINT_MAX;
591 
592     QStringIterator i(s);
593     while (i.hasNext()) {
594         const char32_t c = i.next(InvalidCodePoint);
595         if (c == InvalidCodePoint)
596             return false;
597     }
598 
599     return true;
600 }
601 
602 // conversion between Latin 1 and UTF-16
603 Q_CORE_EXPORT void qt_from_latin1(char16_t *dst, const char *str, size_t size) noexcept
604 {
605     /* SIMD:
606      * Unpacking with SSE has been shown to improve performance on recent CPUs
607      * The same method gives no improvement with NEON. On Aarch64, clang will do the vectorization
608      * itself in exactly the same way as one would do it with intrinsics.
609      */
610 #if defined(__SSE2__)
611     const char *e = str + size;
612     qptrdiff offset = 0;
613 
614     // we're going to read str[offset..offset+15] (16 bytes)
615     for ( ; str + offset + 15 < e; offset += 16) {
616         const __m128i chunk = _mm_loadu_si128((const __m128i*)(str + offset)); // load
617 #ifdef __AVX2__
618         // zero extend to an YMM register
619         const __m256i extended = _mm256_cvtepu8_epi16(chunk);
620 
621         // store
622         _mm256_storeu_si256((__m256i*)(dst + offset), extended);
623 #else
624         const __m128i nullMask = _mm_set1_epi32(0);
625 
626         // unpack the first 8 bytes, padding with zeros
627         const __m128i firstHalf = _mm_unpacklo_epi8(chunk, nullMask);
628         _mm_storeu_si128((__m128i*)(dst + offset), firstHalf); // store
629 
630         // unpack the last 8 bytes, padding with zeros
631         const __m128i secondHalf = _mm_unpackhi_epi8 (chunk, nullMask);
632         _mm_storeu_si128((__m128i*)(dst + offset + 8), secondHalf); // store
633 #endif
634     }
635 
636     // we're going to read str[offset..offset+7] (8 bytes)
637     if (str + offset + 7 < e) {
638         const __m128i unpacked = mm_load8_zero_extend(str + offset);
639         _mm_storeu_si128(reinterpret_cast<__m128i *>(dst + offset), unpacked);
640         offset += 8;
641     }
642 
643     size = size % 8;
644     dst += offset;
645     str += offset;
646 #  if !defined(__OPTIMIZE_SIZE__)
647     return UnrollTailLoop<7>::exec(int(size), [=](int i) { dst[i] = (uchar)str[i]; });
648 #  endif
649 #endif
650 #if defined(__mips_dsp)
651     if (size > 20)
652         qt_fromlatin1_mips_asm_unroll8(dst, str, size);
653     else
654         qt_fromlatin1_mips_asm_unroll4(dst, str, size);
655 #else
656     while (size--)
657         *dst++ = (uchar)*str++;
658 #endif
659 }
660 
661 template <bool Checked>
662 static void qt_to_latin1_internal(uchar *dst, const char16_t *src, qsizetype length)
663 {
664 #if defined(__SSE2__)
665     uchar *e = dst + length;
666     qptrdiff offset = 0;
667 
668 #  ifdef __AVX2__
669     const __m256i questionMark256 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128('?'));
670     const __m256i outOfRange256 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128(0x100));
671     const __m128i questionMark = _mm256_castsi256_si128(questionMark256);
672     const __m128i outOfRange = _mm256_castsi256_si128(outOfRange256);
673 #  else
674     const __m128i questionMark = _mm_set1_epi16('?');
675     const __m128i outOfRange = _mm_set1_epi16(0x100);
676 #  endif
677 
678     auto mergeQuestionMarks = [=](__m128i chunk) {
679         // SSE has no compare instruction for unsigned comparison.
680 # ifdef __SSE4_1__
681         // We use an unsigned uc = qMin(uc, 0x100) and then compare for equality.
682         chunk = _mm_min_epu16(chunk, outOfRange);
683         const __m128i offLimitMask = _mm_cmpeq_epi16(chunk, outOfRange);
684         chunk = _mm_blendv_epi8(chunk, questionMark, offLimitMask);
685 # else
686         // The variables must be shiffted + 0x8000 to be compared
687         const __m128i signedBitOffset = _mm_set1_epi16(short(0x8000));
688         const __m128i thresholdMask = _mm_set1_epi16(short(0xff + 0x8000));
689 
690         const __m128i signedChunk = _mm_add_epi16(chunk, signedBitOffset);
691         const __m128i offLimitMask = _mm_cmpgt_epi16(signedChunk, thresholdMask);
692 
693         // offLimitQuestionMark contains '?' for each 16 bits that was off-limit
694         // the 16 bits that were correct contains zeros
695         const __m128i offLimitQuestionMark = _mm_and_si128(offLimitMask, questionMark);
696 
697         // correctBytes contains the bytes that were in limit
698         // the 16 bits that were off limits contains zeros
699         const __m128i correctBytes = _mm_andnot_si128(offLimitMask, chunk);
700 
701         // merge offLimitQuestionMark and correctBytes to have the result
702         chunk = _mm_or_si128(correctBytes, offLimitQuestionMark);
703 
704         Q_UNUSED(outOfRange);
705 # endif
706         return chunk;
707     };
708 
709     // we're going to write to dst[offset..offset+15] (16 bytes)
710     for ( ; dst + offset + 15 < e; offset += 16) {
711 #  if defined(__AVX2__)
712         __m256i chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(src + offset));
713         if (Checked) {
714             // See mergeQuestionMarks lambda above for details
715             chunk = _mm256_min_epu16(chunk, outOfRange256);
716             const __m256i offLimitMask = _mm256_cmpeq_epi16(chunk, outOfRange256);
717             chunk = _mm256_blendv_epi8(chunk, questionMark256, offLimitMask);
718         }
719 
720         const __m128i chunk2 = _mm256_extracti128_si256(chunk, 1);
721         const __m128i chunk1 = _mm256_castsi256_si128(chunk);
722 #  else
723         __m128i chunk1 = _mm_loadu_si128((const __m128i*)(src + offset)); // load
724         if (Checked)
725             chunk1 = mergeQuestionMarks(chunk1);
726 
727         __m128i chunk2 = _mm_loadu_si128((const __m128i*)(src + offset + 8)); // load
728         if (Checked)
729             chunk2 = mergeQuestionMarks(chunk2);
730 #  endif
731 
732         // pack the two vector to 16 x 8bits elements
733         const __m128i result = _mm_packus_epi16(chunk1, chunk2);
734         _mm_storeu_si128((__m128i*)(dst + offset), result); // store
735     }
736 
737 #  if !defined(__OPTIMIZE_SIZE__)
738     // we're going to write to dst[offset..offset+7] (8 bytes)
739     if (dst + offset + 7 < e) {
740         __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i *>(src + offset));
741         if (Checked)
742             chunk = mergeQuestionMarks(chunk);
743 
744         // pack, where the upper half is ignored
745         const __m128i result = _mm_packus_epi16(chunk, chunk);
746         _mm_storel_epi64(reinterpret_cast<__m128i *>(dst + offset), result);
747         offset += 8;
748     }
749 
750     // we're going to write to dst[offset..offset+3] (4 bytes)
751     if (dst + offset + 3 < e) {
752         __m128i chunk = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(src + offset));
753         if (Checked)
754             chunk = mergeQuestionMarks(chunk);
755 
756         // pack, we'll the upper three quarters
757         const __m128i result = _mm_packus_epi16(chunk, chunk);
758         qToUnaligned(_mm_cvtsi128_si32(result), dst + offset);
759         offset += 4;
760     }
761 
762     length = length % 4;
763 #  else
764     length = length % 16;
765 #  endif // optimize size
766 
767     // advance dst, src for tail processing
768     dst += offset;
769     src += offset;
770 
771 #  if !defined(__OPTIMIZE_SIZE__)
772     return UnrollTailLoop<3>::exec(length, [=](int i) {
773         if (Checked)
774             dst[i] = (src[i]>0xff) ? '?' : (uchar) src[i];
775         else
776             dst[i] = src[i];
777     });
778 #  endif
779 #elif defined(__ARM_NEON__)
780     // Refer to the documentation of the SSE2 implementation
781     // this use eactly the same method as for SSE except:
782     // 1) neon has unsigned comparison
783     // 2) packing is done to 64 bits (8 x 8bits component).
784     if (length >= 16) {
785         const int chunkCount = length >> 3; // divided by 8
786         const uint16x8_t questionMark = vdupq_n_u16('?'); // set
787         const uint16x8_t thresholdMask = vdupq_n_u16(0xff); // set
788         for (int i = 0; i < chunkCount; ++i) {
789             uint16x8_t chunk = vld1q_u16((uint16_t *)src); // load
790             src += 8;
791 
792             if (Checked) {
793                 const uint16x8_t offLimitMask = vcgtq_u16(chunk, thresholdMask); // chunk > thresholdMask
794                 const uint16x8_t offLimitQuestionMark = vandq_u16(offLimitMask, questionMark); // offLimitMask & questionMark
795                 const uint16x8_t correctBytes = vbicq_u16(chunk, offLimitMask); // !offLimitMask & chunk
796                 chunk = vorrq_u16(correctBytes, offLimitQuestionMark); // correctBytes | offLimitQuestionMark
797             }
798             const uint8x8_t result = vmovn_u16(chunk); // narrowing move->packing
799             vst1_u8(dst, result); // store
800             dst += 8;
801         }
802         length = length % 8;
803     }
804 #endif
805 #if defined(__mips_dsp)
806     qt_toLatin1_mips_dsp_asm(dst, src, length);
807 #else
808     while (length--) {
809         if (Checked)
810             *dst++ = (*src>0xff) ? '?' : (uchar) *src;
811         else
812             *dst++ = *src;
813         ++src;
814     }
815 #endif
816 }
817 
818 static void qt_to_latin1(uchar *dst, const char16_t *src, qsizetype length)
819 {
820     qt_to_latin1_internal<true>(dst, src, length);
821 }
822 
823 void qt_to_latin1_unchecked(uchar *dst, const char16_t *src, qsizetype length)
824 {
825     qt_to_latin1_internal<false>(dst, src, length);
826 }
827 
828 // Unicode case-insensitive comparison
829 static int ucstricmp(const QChar *a, const QChar *ae, const QChar *b, const QChar *be)
830 {
831     if (a == b)
832         return (ae - be);
833 
834     const QChar *e = ae;
835     if (be - b < ae - a)
836         e = a + (be - b);
837 
838     char32_t alast = 0;
839     char32_t blast = 0;
840     while (a < e) {
841 //         qDebug() << Qt::hex << alast << blast;
842 //         qDebug() << Qt::hex << "*a=" << *a << "alast=" << alast << "folded=" << foldCase (*a, alast);
843 //         qDebug() << Qt::hex << "*b=" << *b << "blast=" << blast << "folded=" << foldCase (*b, blast);
844         int diff = foldCase(a->unicode(), alast) - foldCase(b->unicode(), blast);
845         if ((diff))
846             return diff;
847         ++a;
848         ++b;
849     }
850     if (a == ae) {
851         if (b == be)
852             return 0;
853         return -1;
854     }
855     return 1;
856 }
857 
858 // Case-insensitive comparison between a Unicode string and a QLatin1String
859 static int ucstricmp(const QChar *a, const QChar *ae, const char *b, const char *be)
860 {
861     auto e = ae;
862     if (be - b < ae - a)
863         e = a + (be - b);
864 
865     while (a < e) {
866         int diff = foldCase(a->unicode()) - foldCase(char16_t{uchar(*b)});
867         if ((diff))
868             return diff;
869         ++a;
870         ++b;
871     }
872     if (a == ae) {
873         if (b == be)
874             return 0;
875         return -1;
876     }
877     return 1;
878 }
879 
880 // Case-insensitive comparison between a Unicode string and a UTF-8 string
881 static int ucstricmp8(const char *utf8, const char *utf8end, const QChar *utf16, const QChar *utf16end)
882 {
883     auto src1 = reinterpret_cast<const uchar *>(utf8);
884     auto end1 = reinterpret_cast<const uchar *>(utf8end);
885     QStringIterator src2(utf16, utf16end);
886 
887     while (src1 < end1 && src2.hasNext()) {
888         uint uc1 = 0;
889         uint *output = &uc1;
890         uchar b = *src1++;
891         int res = QUtf8Functions::fromUtf8<QUtf8BaseTraits>(b, output, src1, end1);
892         if (res < 0) {
893             // decoding error
894             uc1 = QChar::ReplacementCharacter;
895         } else {
896             uc1 = QChar::toCaseFolded(uc1);
897         }
898 
899         uint uc2 = QChar::toCaseFolded(src2.next());
900         int diff = uc1 - uc2;   // can't underflow
901         if (diff)
902             return diff;
903     }
904 
905     // the shorter string sorts first
906     return (end1 > src1) - int(src2.hasNext());
907 }
908 
909 #if defined(__mips_dsp)
910 // From qstring_mips_dsp_asm.S
911 extern "C" int qt_ucstrncmp_mips_dsp_asm(const char16_t *a,
912                                          const char16_t *b,
913                                          unsigned len);
914 #endif
915 
916 // Unicode case-sensitive compare two same-sized strings
917 static int ucstrncmp(const QChar *a, const QChar *b, size_t l)
918 {
919 #ifdef __OPTIMIZE_SIZE__
920     const QChar *end = a + l;
921     while (a < end) {
922         if (int diff = (int)a->unicode() - (int)b->unicode())
923             return diff;
924         ++a;
925         ++b;
926     }
927     return 0;
928 #else
929 #if defined(__mips_dsp)
930     static_assert(sizeof(uint) == sizeof(size_t));
931     if (l >= 8) {
932         return qt_ucstrncmp_mips_dsp_asm(reinterpret_cast<const char16_t*>(a),
933                                          reinterpret_cast<const char16_t*>(b),
934                                          l);
935     }
936 #endif // __mips_dsp
937 #ifdef __SSE2__
938     const QChar *end = a + l;
939     qptrdiff offset = 0;
940 
941     // Using the PMOVMSKB instruction, we get two bits for each character
942     // we compare.
943     int retval;
944     auto isDifferent = [a, b, &offset, &retval](__m128i a_data, __m128i b_data) {
945         __m128i result = _mm_cmpeq_epi16(a_data, b_data);
946         uint mask = ~uint(_mm_movemask_epi8(result));
947         if (ushort(mask) == 0)
948             return false;
949         uint idx = qCountTrailingZeroBits(mask);
950         retval = a[offset + idx / 2].unicode() - b[offset + idx / 2].unicode();
951         return true;
952     };
953 
954     // we're going to read a[0..15] and b[0..15] (32 bytes)
955     for ( ; end - a >= offset + 16; offset += 16) {
956 #ifdef __AVX2__
957         __m256i a_data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(a + offset));
958         __m256i b_data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(b + offset));
959         __m256i result = _mm256_cmpeq_epi16(a_data, b_data);
960         uint mask = _mm256_movemask_epi8(result);
961 #else
962         __m128i a_data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset));
963         __m128i a_data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset + 8));
964         __m128i b_data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset));
965         __m128i b_data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset + 8));
966         __m128i result1 = _mm_cmpeq_epi16(a_data1, b_data1);
967         __m128i result2 = _mm_cmpeq_epi16(a_data2, b_data2);
968         uint mask = _mm_movemask_epi8(result1) | (_mm_movemask_epi8(result2) << 16);
969 #endif
970         mask = ~mask;
971         if (mask) {
972             // found a different character
973             uint idx = qCountTrailingZeroBits(mask);
974             return a[offset + idx / 2].unicode() - b[offset + idx / 2].unicode();
975         }
976     }
977 
978     // we're going to read a[0..7] and b[0..7] (16 bytes)
979     if (end - a >= offset + 8) {
980         __m128i a_data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset));
981         __m128i b_data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset));
982         if (isDifferent(a_data, b_data))
983             return retval;
984 
985         offset += 8;
986     }
987 
988     // we're going to read a[0..3] and b[0..3] (8 bytes)
989     if (end - a >= offset + 4) {
990         __m128i a_data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(a + offset));
991         __m128i b_data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(b + offset));
992         if (isDifferent(a_data, b_data))
993             return retval;
994 
995         offset += 4;
996     }
997 
998     // reset l
999     l &= 3;
1000 
1001     const auto lambda = [=](size_t i) -> int {
1002         return a[offset + i].unicode() - b[offset + i].unicode();
1003     };
1004     return UnrollTailLoop<3>::exec(l, 0, lambda, lambda);
1005 #endif
1006 #ifdef __ARM_NEON__
1007     if (l >= 8) {
1008         const QChar *end = a + l;
1009         const uint16x8_t mask = { 1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7 };
1010         while (end - a > 7) {
1011             uint16x8_t da = vld1q_u16(reinterpret_cast<const uint16_t *>(a));
1012             uint16x8_t db = vld1q_u16(reinterpret_cast<const uint16_t *>(b));
1013 
1014             uint8_t r = ~(uint8_t)vaddvq_u16(vandq_u16(vceqq_u16(da, db), mask));
1015             if (r) {
1016                 // found a different QChar
1017                 uint idx = qCountTrailingZeroBits(r);
1018                 return (int)a[idx].unicode() - (int)b[idx].unicode();
1019             }
1020             a += 8;
1021             b += 8;
1022         }
1023         l &= 7;
1024     }
1025     const auto lambda = [=](size_t i) -> int {
1026         return a[i].unicode() - b[i].unicode();
1027     };
1028     return UnrollTailLoop<7>::exec(l, 0, lambda, lambda);
1029 #endif // __ARM_NEON__
1030     if (!l)
1031         return 0;
1032 
1033     // check alignment
1034     if ((reinterpret_cast<quintptr>(a) & 2) == (reinterpret_cast<quintptr>(b) & 2)) {
1035         // both addresses have the same alignment
1036         if (reinterpret_cast<quintptr>(a) & 2) {
1037             // both addresses are not aligned to 4-bytes boundaries
1038             // compare the first character
1039             if (*a != *b)
1040                 return a->unicode() - b->unicode();
1041             --l;
1042             ++a;
1043             ++b;
1044 
1045             // now both addresses are 4-bytes aligned
1046         }
1047 
1048         // both addresses are 4-bytes aligned
1049         // do a fast 32-bit comparison
1050         const quint32 *da = reinterpret_cast<const quint32 *>(a);
1051         const quint32 *db = reinterpret_cast<const quint32 *>(b);
1052         const quint32 *e = da + (l >> 1);
1053         for ( ; da != e; ++da, ++db) {
1054             if (*da != *db) {
1055                 a = reinterpret_cast<const QChar *>(da);
1056                 b = reinterpret_cast<const QChar *>(db);
1057                 if (*a != *b)
1058                     return a->unicode() - b->unicode();
1059                 return a[1].unicode() - b[1].unicode();
1060             }
1061         }
1062 
1063         // do we have a tail?
1064         a = reinterpret_cast<const QChar *>(da);
1065         b = reinterpret_cast<const QChar *>(db);
1066         return (l & 1) ? a->unicode() - b->unicode() : 0;
1067     } else {
1068         // one of the addresses isn't 4-byte aligned but the other is
1069         const QChar *e = a + l;
1070         for ( ; a != e; ++a, ++b) {
1071             if (*a != *b)
1072                 return a->unicode() - b->unicode();
1073         }
1074     }
1075     return 0;
1076 #endif
1077 }
1078 
1079 static int ucstrncmp(const QChar *a, const uchar *c, size_t l)
1080 {
1081     const char16_t *uc = reinterpret_cast<const char16_t *>(a);
1082     const char16_t *e = uc + l;
1083 
1084 #ifdef __SSE2__
1085     __m128i nullmask = _mm_setzero_si128();
1086     qptrdiff offset = 0;
1087 
1088 #  if !defined(__OPTIMIZE_SIZE__)
1089     // Using the PMOVMSKB instruction, we get two bits for each character
1090     // we compare.
1091     int retval;
1092     auto isDifferent = [uc, c, &offset, &retval](__m128i a_data, __m128i b_data) {
1093         __m128i result = _mm_cmpeq_epi16(a_data, b_data);
1094         uint mask = ~uint(_mm_movemask_epi8(result));
1095         if (ushort(mask) == 0)
1096             return false;
1097         uint idx = qCountTrailingZeroBits(mask);
1098         retval = uc[offset + idx / 2] - c[offset + idx / 2];
1099         return true;
1100     };
1101 #  endif
1102 
1103     // we're going to read uc[offset..offset+15] (32 bytes)
1104     // and c[offset..offset+15] (16 bytes)
1105     for ( ; uc + offset + 15 < e; offset += 16) {
1106         // similar to fromLatin1_helper:
1107         // load 16 bytes of Latin 1 data
1108         __m128i chunk = _mm_loadu_si128((const __m128i*)(c + offset));
1109 
1110 #  ifdef __AVX2__
1111         // expand Latin 1 data via zero extension
1112         __m256i ldata = _mm256_cvtepu8_epi16(chunk);
1113 
1114         // load UTF-16 data and compare
1115         __m256i ucdata = _mm256_loadu_si256((const __m256i*)(uc + offset));
1116         __m256i result = _mm256_cmpeq_epi16(ldata, ucdata);
1117 
1118         uint mask = ~_mm256_movemask_epi8(result);
1119 #  else
1120         // expand via unpacking
1121         __m128i firstHalf = _mm_unpacklo_epi8(chunk, nullmask);
1122         __m128i secondHalf = _mm_unpackhi_epi8(chunk, nullmask);
1123 
1124         // load UTF-16 data and compare
1125         __m128i ucdata1 = _mm_loadu_si128((const __m128i*)(uc + offset));
1126         __m128i ucdata2 = _mm_loadu_si128((const __m128i*)(uc + offset + 8));
1127         __m128i result1 = _mm_cmpeq_epi16(firstHalf, ucdata1);
1128         __m128i result2 = _mm_cmpeq_epi16(secondHalf, ucdata2);
1129 
1130         uint mask = ~(_mm_movemask_epi8(result1) | _mm_movemask_epi8(result2) << 16);
1131 #  endif
1132         if (mask) {
1133             // found a different character
1134             uint idx = qCountTrailingZeroBits(mask);
1135             return uc[offset + idx / 2] - c[offset + idx / 2];
1136         }
1137     }
1138 
1139 #  if !defined(__OPTIMIZE_SIZE__)
1140     // we'll read uc[offset..offset+7] (16 bytes) and c[offset..offset+7] (8 bytes)
1141     if (uc + offset + 7 < e) {
1142         // same, but we're using an 8-byte load
1143         __m128i secondHalf = mm_load8_zero_extend(c + offset);
1144 
1145         __m128i ucdata = _mm_loadu_si128((const __m128i*)(uc + offset));
1146         if (isDifferent(ucdata, secondHalf))
1147             return retval;
1148 
1149         // still matched
1150         offset += 8;
1151     }
1152 
1153     enum { MaxTailLength = 3 };
1154     // we'll read uc[offset..offset+3] (8 bytes) and c[offset..offset+3] (4 bytes)
1155     if (uc + offset + 3 < e) {
1156         __m128i chunk = _mm_cvtsi32_si128(qFromUnaligned<int>(c + offset));
1157         __m128i secondHalf = _mm_unpacklo_epi8(chunk, nullmask);
1158 
1159         __m128i ucdata = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(uc + offset));
1160         if (isDifferent(ucdata, secondHalf))
1161             return retval;
1162 
1163         // still matched
1164         offset += 4;
1165     }
1166 #  endif // optimize size
1167 
1168     // reset uc and c
1169     uc += offset;
1170     c += offset;
1171 
1172 #  if !defined(__OPTIMIZE_SIZE__)
1173     const auto lambda = [=](size_t i) { return uc[i] - char16_t(c[i]); };
1174     return UnrollTailLoop<MaxTailLength>::exec(e - uc, 0, lambda, lambda);
1175 #  endif
1176 #endif
1177 
1178     while (uc < e) {
1179         int diff = *uc - *c;
1180         if (diff)
1181             return diff;
1182         uc++, c++;
1183     }
1184 
1185     return 0;
1186 }
1187 
1188 constexpr int lencmp(qsizetype lhs, qsizetype rhs) noexcept
1189 {
1190     return lhs == rhs ? 0 :
1191            lhs >  rhs ? 1 :
1192            /* else */  -1 ;
1193 }
1194 
1195 // Unicode case-sensitive comparison
1196 static int ucstrcmp(const QChar *a, size_t alen, const QChar *b, size_t blen)
1197 {
1198     if (a == b && alen == blen)
1199         return 0;
1200     const size_t l = qMin(alen, blen);
1201     int cmp = ucstrncmp(a, b, l);
1202     return cmp ? cmp : lencmp(alen, blen);
1203 }
1204 
1205 static int ucstrcmp(const QChar *a, size_t alen, const char *b, size_t blen)
1206 {
1207     const size_t l = qMin(alen, blen);
1208     const int cmp = ucstrncmp(a, reinterpret_cast<const uchar*>(b), l);
1209     return cmp ? cmp : lencmp(alen, blen);
1210 }
1211 
1212 static constexpr uchar latin1Lower[256] = {
1213     0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
1214     0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
1215     0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
1216     0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
1217     0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
1218     0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
1219     0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
1220     0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
1221     0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
1222     0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
1223     0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
1224     0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
1225     // 0xd7 (multiplication sign) and 0xdf (sz ligature) complicate life
1226     0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
1227     0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xd7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xdf,
1228     0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
1229     0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
1230 };
1231 static int latin1nicmp(const char *lhsChar, qsizetype lSize, const char *rhsChar, qsizetype rSize)
1232 {
1233     // We're called with QLatin1String's .data() and .size():
1234     Q_ASSERT(lSize >= 0 && rSize >= 0);
1235     if (!lSize)
1236         return rSize ? -1 : 0;
1237     if (!rSize)
1238         return 1;
1239     const qsizetype size = std::min(lSize, rSize);
1240 
1241     const uchar *lhs = reinterpret_cast<const uchar *>(lhsChar);
1242     const uchar *rhs = reinterpret_cast<const uchar *>(rhsChar);
1243     Q_ASSERT(lhs && rhs); // since both lSize and rSize are positive
1244     for (qsizetype i = 0; i < size; i++) {
1245         if (int res = latin1Lower[lhs[i]] - latin1Lower[rhs[i]])
1246             return res;
1247     }
1248     return lencmp(lSize, rSize);
1249 }
1250 bool QtPrivate::equalStrings(QStringView lhs, QStringView rhs) noexcept
1251 {
1252     return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size()) == 0;
1253 }
1254 
1255 bool QtPrivate::equalStrings(QStringView lhs, QLatin1String rhs) noexcept
1256 {
1257     return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size()) == 0;
1258 }
1259 
1260 bool QtPrivate::equalStrings(QLatin1String lhs, QStringView rhs) noexcept
1261 {
1262     return QtPrivate::equalStrings(rhs, lhs);
1263 }
1264 
1265 bool QtPrivate::equalStrings(QLatin1String lhs, QLatin1String rhs) noexcept
1266 {
1267     return lhs.size() == rhs.size() && (!lhs.size() || qstrncmp(lhs.data(), rhs.data(), lhs.size()) == 0);
1268 }
1269 
1270 bool QtPrivate::equalStrings(QBasicUtf8StringView<false> lhs, QStringView rhs) noexcept
1271 {
1272     return QUtf8::compareUtf8(lhs, rhs) == 0;
1273 }
1274 
1275 bool QtPrivate::equalStrings(QStringView lhs, QBasicUtf8StringView<false> rhs) noexcept
1276 {
1277     return QtPrivate::equalStrings(rhs, lhs);
1278 }
1279 
1280 bool QtPrivate::equalStrings(QLatin1String lhs, QBasicUtf8StringView<false> rhs) noexcept
1281 {
1282     QString r = rhs.toString();
1283     return QtPrivate::equalStrings(lhs, r); // ### optimize!
1284 }
1285 
1286 bool QtPrivate::equalStrings(QBasicUtf8StringView<false> lhs, QLatin1String rhs) noexcept
1287 {
1288     return QtPrivate::equalStrings(rhs, lhs);
1289 }
1290 
1291 bool QtPrivate::equalStrings(QBasicUtf8StringView<false> lhs, QBasicUtf8StringView<false> rhs) noexcept
1292 {
1293     return lhs.size() == rhs.size() && (!lhs.size() || qstrncmp(lhs.data(), rhs.data(), lhs.size()) == 0);
1294 }
1295 
1296 bool QAnyStringView::equal(QAnyStringView lhs, QAnyStringView rhs) noexcept
1297 {
1298     if (lhs.size() != rhs.size() && lhs.isUtf8() == rhs.isUtf8())
1299         return false;
1300     return lhs.visit([rhs](auto lhs) {
1301         return rhs.visit([lhs](auto rhs) {
1302             return QtPrivate::equalStrings(lhs, rhs);
1303         });
1304     });
1305 }
1306 
1307 /*!
1308     \relates QStringView
1309     \internal
1310     \since 5.10
1311 
1312     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1313 
1314     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1315     otherwise the comparison is case-insensitive.
1316 
1317     Case-sensitive comparison is based exclusively on the numeric Unicode values
1318     of the characters and is very fast, but is not what a human would expect.
1319     Consider sorting user-visible strings with QString::localeAwareCompare().
1320 
1321     \sa {Comparing Strings}
1322 */
1323 int QtPrivate::compareStrings(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1324 {
1325     if (cs == Qt::CaseSensitive)
1326         return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size());
1327     return ucstricmp(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
1328 }
1329 
1330 /*!
1331     \relates QStringView
1332     \internal
1333     \since 5.10
1334     \overload
1335 
1336     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1337 
1338     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1339     otherwise the comparison is case-insensitive.
1340 
1341     Case-sensitive comparison is based exclusively on the numeric Unicode values
1342     of the characters and is very fast, but is not what a human would expect.
1343     Consider sorting user-visible strings with QString::localeAwareCompare().
1344 
1345     \sa {Comparing Strings}
1346 */
1347 int QtPrivate::compareStrings(QStringView lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1348 {
1349     if (cs == Qt::CaseSensitive)
1350         return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size());
1351     return ucstricmp(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
1352 }
1353 
1354 /*!
1355     \relates QStringView
1356     \internal
1357     \since 6.0
1358     \overload
1359 */
1360 int QtPrivate::compareStrings(QStringView lhs, QBasicUtf8StringView<false> rhs, Qt::CaseSensitivity cs) noexcept
1361 {
1362     return -compareStrings(rhs, lhs, cs);
1363 }
1364 
1365 /*!
1366     \relates QStringView
1367     \internal
1368     \since 5.10
1369     \overload
1370 */
1371 int QtPrivate::compareStrings(QLatin1String lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1372 {
1373     return -compareStrings(rhs, lhs, cs);
1374 }
1375 
1376 /*!
1377     \relates QStringView
1378     \internal
1379     \since 5.10
1380     \overload
1381 
1382     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1383 
1384     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1385     otherwise the comparison is case-insensitive.
1386 
1387     Case-sensitive comparison is based exclusively on the numeric Latin-1 values
1388     of the characters and is very fast, but is not what a human would expect.
1389     Consider sorting user-visible strings with QString::localeAwareCompare().
1390 
1391     \sa {Comparing Strings}
1392 */
1393 int QtPrivate::compareStrings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1394 {
1395     if (lhs.isEmpty())
1396         return lencmp(qsizetype(0), rhs.size());
1397     if (cs == Qt::CaseInsensitive)
1398         return latin1nicmp(lhs.data(), lhs.size(), rhs.data(), rhs.size());
1399     const auto l = std::min(lhs.size(), rhs.size());
1400     int r = qstrncmp(lhs.data(), rhs.data(), l);
1401     return r ? r : lencmp(lhs.size(), rhs.size());
1402 }
1403 
1404 /*!
1405     \relates QStringView
1406     \internal
1407     \since 6.0
1408     \overload
1409 */
1410 int QtPrivate::compareStrings(QLatin1String lhs, QBasicUtf8StringView<false> rhs, Qt::CaseSensitivity cs) noexcept
1411 {
1412     return compareStrings(lhs, rhs.toString(), cs); // ### optimize!
1413 }
1414 
1415 /*!
1416     \relates QStringView
1417     \internal
1418     \since 6.0
1419     \overload
1420 */
1421 int QtPrivate::compareStrings(QBasicUtf8StringView<false> lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1422 {
1423     if (cs == Qt::CaseSensitive)
1424         return QUtf8::compareUtf8(lhs, rhs);
1425     return ucstricmp8(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
1426 }
1427 
1428 /*!
1429     \relates QStringView
1430     \internal
1431     \since 6.0
1432     \overload
1433 */
1434 int QtPrivate::compareStrings(QBasicUtf8StringView<false> lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1435 {
1436     return -compareStrings(rhs, lhs, cs);
1437 }
1438 
1439 /*!
1440     \relates QStringView
1441     \internal
1442     \since 6.0
1443     \overload
1444 */
1445 int QtPrivate::compareStrings(QBasicUtf8StringView<false> lhs, QBasicUtf8StringView<false> rhs, Qt::CaseSensitivity cs) noexcept
1446 {
1447     if (lhs.isEmpty())
1448         return lencmp(0, rhs.size());
1449     if (cs == Qt::CaseInsensitive)
1450         return compareStrings(lhs.toString(), rhs.toString(), cs); // ### optimize!
1451     const auto l = std::min(lhs.size(), rhs.size());
1452     int r = qstrncmp(lhs.data(), rhs.data(), l);
1453     return r ? r : lencmp(lhs.size(), rhs.size());
1454 }
1455 
1456 int QAnyStringView::compare(QAnyStringView lhs, QAnyStringView rhs, Qt::CaseSensitivity cs) noexcept
1457 {
1458     return lhs.visit([rhs, cs](auto lhs) {
1459         return rhs.visit([lhs, cs](auto rhs) {
1460             return QtPrivate::compareStrings(lhs, rhs, cs);
1461         });
1462     });
1463 }
1464 
1465 #define REHASH(a) \
1466     if (sl_minus_1 < sizeof(std::size_t) * CHAR_BIT)  \
1467         hashHaystack -= std::size_t(a) << sl_minus_1; \
1468     hashHaystack <<= 1
1469 
1470 inline bool qIsUpper(char ch)
1471 {
1472     return ch >= 'A' && ch <= 'Z';
1473 }
1474 
1475 inline bool qIsDigit(char ch)
1476 {
1477     return ch >= '0' && ch <= '9';
1478 }
1479 
1480 inline char qToLower(char ch)
1481 {
1482     if (ch >= 'A' && ch <= 'Z')
1483         return ch - 'A' + 'a';
1484     else
1485         return ch;
1486 }
1487 
1488 
1489 /*!
1490   \macro QT_RESTRICTED_CAST_FROM_ASCII
1491   \relates QString
1492 
1493   Disables most automatic conversions from source literals and 8-bit data
1494   to unicode QStrings, but allows the use of
1495   the \c{QChar(char)} and \c{QString(const char (&ch)[N]} constructors,
1496   and the \c{QString::operator=(const char (&ch)[N])} assignment operator.
1497   This gives most of the type-safety benefits of \l QT_NO_CAST_FROM_ASCII
1498   but does not require user code to wrap character and string literals
1499   with QLatin1Char, QLatin1String or similar.
1500 
1501   Using this macro together with source strings outside the 7-bit range,
1502   non-literals, or literals with embedded NUL characters is undefined.
1503 
1504   \sa QT_NO_CAST_FROM_ASCII, QT_NO_CAST_TO_ASCII
1505 */
1506 
1507 /*!
1508   \macro QT_NO_CAST_FROM_ASCII
1509   \relates QString
1510   \relates QChar
1511 
1512   Disables automatic conversions from 8-bit strings (\c{char *}) to Unicode
1513   QStrings, as well as from 8-bit \c{char} types (\c{char} and
1514   \c{unsigned char}) to QChar.
1515 
1516   \sa QT_NO_CAST_TO_ASCII, QT_RESTRICTED_CAST_FROM_ASCII,
1517       QT_NO_CAST_FROM_BYTEARRAY
1518 */
1519 
1520 /*!
1521   \macro QT_NO_CAST_TO_ASCII
1522   \relates QString
1523 
1524   Disables automatic conversion from QString to 8-bit strings (\c{char *}).
1525 
1526   \sa QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII,
1527       QT_NO_CAST_FROM_BYTEARRAY
1528 */
1529 
1530 /*!
1531   \macro QT_ASCII_CAST_WARNINGS
1532   \internal
1533   \relates QString
1534 
1535   This macro can be defined to force a warning whenever a function is
1536   called that automatically converts between unicode and 8-bit encodings.
1537 
1538   Note: This only works for compilers that support warnings for
1539   deprecated API.
1540 
1541   \sa QT_NO_CAST_TO_ASCII, QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII
1542 */
1543 
1544 /*!
1545     \class QString
1546     \inmodule QtCore
1547     \reentrant
1548 
1549     \brief The QString class provides a Unicode character string.
1550 
1551     \ingroup tools
1552     \ingroup shared
1553     \ingroup string-processing
1554 
1555     QString stores a string of 16-bit \l{QChar}s, where each QChar
1556     corresponds to one UTF-16 code unit. (Unicode characters
1557     with code values above 65535 are stored using surrogate pairs,
1558     i.e., two consecutive \l{QChar}s.)
1559 
1560     \l{Unicode} is an international standard that supports most of the
1561     writing systems in use today. It is a superset of US-ASCII (ANSI
1562     X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1
1563     characters are available at the same code positions.
1564 
1565     Behind the scenes, QString uses \l{implicit sharing}
1566     (copy-on-write) to reduce memory usage and to avoid the needless
1567     copying of data. This also helps reduce the inherent overhead of
1568     storing 16-bit characters instead of 8-bit characters.
1569 
1570     In addition to QString, Qt also provides the QByteArray class to
1571     store raw bytes and traditional 8-bit '\\0'-terminated strings.
1572     For most purposes, QString is the class you want to use. It is
1573     used throughout the Qt API, and the Unicode support ensures that
1574     your applications will be easy to translate if you want to expand
1575     your application's market at some point. The two main cases where
1576     QByteArray is appropriate are when you need to store raw binary
1577     data, and when memory conservation is critical (like in embedded
1578     systems).
1579 
1580     \tableofcontents
1581 
1582     \section1 Initializing a String
1583 
1584     One way to initialize a QString is simply to pass a \c{const char
1585     *} to its constructor. For example, the following code creates a
1586     QString of size 5 containing the data "Hello":
1587 
1588     \snippet qstring/main.cpp 0
1589 
1590     QString converts the \c{const char *} data into Unicode using the
1591     fromUtf8() function.
1592 
1593     In all of the QString functions that take \c{const char *}
1594     parameters, the \c{const char *} is interpreted as a classic
1595     C-style '\\0'-terminated string encoded in UTF-8. It is legal for
1596     the \c{const char *} parameter to be \nullptr.
1597 
1598     You can also provide string data as an array of \l{QChar}s:
1599 
1600     \snippet qstring/main.cpp 1
1601 
1602     QString makes a deep copy of the QChar data, so you can modify it
1603     later without experiencing side effects. (If for performance
1604     reasons you don't want to take a deep copy of the character data,
1605     use QString::fromRawData() instead.)
1606 
1607     Another approach is to set the size of the string using resize()
1608     and to initialize the data character per character. QString uses
1609     0-based indexes, just like C++ arrays. To access the character at
1610     a particular index position, you can use \l operator[](). On
1611     non-\c{const} strings, \l operator[]() returns a reference to a
1612     character that can be used on the left side of an assignment. For
1613     example:
1614 
1615     \snippet qstring/main.cpp 2
1616 
1617     For read-only access, an alternative syntax is to use the at()
1618     function:
1619 
1620     \snippet qstring/main.cpp 3
1621 
1622     The at() function can be faster than \l operator[](), because it
1623     never causes a \l{deep copy} to occur. Alternatively, use the
1624     first(), last(), or sliced() functions to extract several characters
1625     at a time.
1626 
1627     A QString can embed '\\0' characters (QChar::Null). The size()
1628     function always returns the size of the whole string, including
1629     embedded '\\0' characters.
1630 
1631     After a call to the resize() function, newly allocated characters
1632     have undefined values. To set all the characters in the string to
1633     a particular value, use the fill() function.
1634 
1635     QString provides dozens of overloads designed to simplify string
1636     usage. For example, if you want to compare a QString with a string
1637     literal, you can write code like this and it will work as expected:
1638 
1639     \snippet qstring/main.cpp 4
1640 
1641     You can also pass string literals to functions that take QStrings
1642     as arguments, invoking the QString(const char *)
1643     constructor. Similarly, you can pass a QString to a function that
1644     takes a \c{const char *} argument using the \l qPrintable() macro
1645     which returns the given QString as a \c{const char *}. This is
1646     equivalent to calling <QString>.toLocal8Bit().constData().
1647 
1648     \section1 Manipulating String Data
1649 
1650     QString provides the following basic functions for modifying the
1651     character data: append(), prepend(), insert(), replace(), and
1652     remove(). For example:
1653 
1654     \snippet qstring/main.cpp 5
1655 
1656     In the above example the replace() function's first two arguments are the
1657     position from which to start replacing and the number of characters that
1658     should be replaced.
1659 
1660     When data-modifying functions increase the size of the string,
1661     they may lead to reallocation of memory for the QString object. When
1662     this happens, QString expands by more than it immediately needs so as
1663     to have space for further expansion without reallocation until the size
1664     of the string has greatly increased.
1665 
1666     The insert(), remove() and, when replacing a sub-string with one of
1667     different size, replace() functions can be slow (\l{linear time}) for
1668     large strings, because they require moving many characters in the string
1669     by at least one position in memory.
1670 
1671     If you are building a QString gradually and know in advance
1672     approximately how many characters the QString will contain, you
1673     can call reserve(), asking QString to preallocate a certain amount
1674     of memory. You can also call capacity() to find out how much
1675     memory the QString actually has allocated.
1676 
1677     QString provides \l{STL-style iterators} (QString::const_iterator and
1678     QString::iterator). In practice, iterators are handy when working with
1679     generic algorithms provided by the C++ standard library.
1680 
1681     \note Iterators over a QString, and references to individual characters
1682     within one, cannot be relied on to remain valid when any non-\c{const}
1683     method of the QString is called. Accessing such an iterator or reference
1684     after the call to a non-\c{const} method leads to undefined behavior. When
1685     stability for iterator-like functionality is required, you should use
1686     indexes instead of iterators as they are not tied to QString's internal
1687     state and thus do not get invalidated.
1688 
1689     \note Due to \l{implicit sharing}, the first non-\c{const} operator or
1690     function used on a given QString may cause it to, internally, perform a deep
1691     copy of its data. This invalidates all iterators over the string and
1692     references to individual characters within it. After the first non-\c{const}
1693     operator, operations that modify QString may completely (in case of
1694     reallocation) or partially invalidate iterators and references, but other
1695     methods (such as begin() or end()) will not. Accessing an iterator or
1696     reference after it has been invalidated leads to undefined behavior.
1697 
1698     A frequent requirement is to remove whitespace characters from a
1699     string ('\\n', '\\t', ' ', etc.). If you want to remove whitespace
1700     from both ends of a QString, use the trimmed() function. If you
1701     want to remove whitespace from both ends and replace multiple
1702     consecutive whitespaces with a single space character within the
1703     string, use simplified().
1704 
1705     If you want to find all occurrences of a particular character or
1706     substring in a QString, use the indexOf() or lastIndexOf()
1707     functions. The former searches forward starting from a given index
1708     position, the latter searches backward. Both return the index
1709     position of the character or substring if they find it; otherwise,
1710     they return -1.  For example, here is a typical loop that finds all
1711     occurrences of a particular substring:
1712 
1713     \snippet qstring/main.cpp 6
1714 
1715     QString provides many functions for converting numbers into
1716     strings and strings into numbers. See the arg() functions, the
1717     setNum() functions, the number() static functions, and the
1718     toInt(), toDouble(), and similar functions.
1719 
1720     To get an upper- or lowercase version of a string use toUpper() or
1721     toLower().
1722 
1723     Lists of strings are handled by the QStringList class. You can
1724     split a string into a list of strings using the split() function,
1725     and join a list of strings into a single string with an optional
1726     separator using QStringList::join(). You can obtain a list of
1727     strings from a string list that contain a particular substring or
1728     that match a particular QRegularExpression using the QStringList::filter()
1729     function.
1730 
1731     \section1 Querying String Data
1732 
1733     If you want to see if a QString starts or ends with a particular
1734     substring use startsWith() or endsWith(). If you simply want to
1735     check whether a QString contains a particular character or
1736     substring, use the contains() function. If you want to find out
1737     how many times a particular character or substring occurs in the
1738     string, use count().
1739 
1740     To obtain a pointer to the actual character data, call data() or
1741     constData(). These functions return a pointer to the beginning of
1742     the QChar data. The pointer is guaranteed to remain valid until a
1743     non-\c{const} function is called on the QString.
1744 
1745     \section2 Comparing Strings
1746 
1747     QStrings can be compared using overloaded operators such as \l
1748     operator<(), \l operator<=(), \l operator==(), \l operator>=(),
1749     and so on.  Note that the comparison is based exclusively on the
1750     numeric Unicode values of the characters. It is very fast, but is
1751     not what a human would expect; the QString::localeAwareCompare()
1752     function is usually a better choice for sorting user-interface
1753     strings, when such a comparison is available.
1754 
1755     On Unix-like platforms (including Linux, \macos and iOS), when Qt
1756     is linked with the ICU library (which it usually is), its
1757     locale-aware sorting is used.  Otherwise, on \macos and iOS, \l
1758     localeAwareCompare() compares according the "Order for sorted
1759     lists" setting in the International preferences panel. On other
1760     Unix-like systems without ICU, the comparison falls back to the
1761     system library's \c strcoll(),
1762 
1763     \section1 Converting Between Encoded Strings Data and QString
1764 
1765     QString provides the following three functions that return a
1766     \c{const char *} version of the string as QByteArray: toUtf8(),
1767     toLatin1(), and toLocal8Bit().
1768 
1769     \list
1770     \li toLatin1() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.
1771     \li toUtf8() returns a UTF-8 encoded 8-bit string. UTF-8 is a
1772        superset of US-ASCII (ANSI X3.4-1986) that supports the entire
1773        Unicode character set through multibyte sequences.
1774     \li toLocal8Bit() returns an 8-bit string using the system's local
1775        encoding. This is the same as toUtf8() on Unix systems.
1776     \endlist
1777 
1778     To convert from one of these encodings, QString provides
1779     fromLatin1(), fromUtf8(), and fromLocal8Bit(). Other
1780     encodings are supported through the QStringEncoder and QStringDecoder
1781     classes.
1782 
1783     As mentioned above, QString provides a lot of functions and
1784     operators that make it easy to interoperate with \c{const char *}
1785     strings. But this functionality is a double-edged sword: It makes
1786     QString more convenient to use if all strings are US-ASCII or
1787     Latin-1, but there is always the risk that an implicit conversion
1788     from or to \c{const char *} is done using the wrong 8-bit
1789     encoding. To minimize these risks, you can turn off these implicit
1790     conversions by defining some of the following preprocessor symbols:
1791 
1792     \list
1793     \li \l QT_NO_CAST_FROM_ASCII disables automatic conversions from
1794        C string literals and pointers to Unicode.
1795     \li \l QT_RESTRICTED_CAST_FROM_ASCII allows automatic conversions
1796        from C characters and character arrays, but disables automatic
1797        conversions from character pointers to Unicode.
1798     \li \l QT_NO_CAST_TO_ASCII disables automatic conversion from QString
1799        to C strings.
1800     \endlist
1801 
1802     You then need to explicitly call fromUtf8(), fromLatin1(),
1803     or fromLocal8Bit() to construct a QString from an
1804     8-bit string, or use the lightweight QLatin1String class, for
1805     example:
1806 
1807     \snippet code/src_corelib_text_qstring.cpp 1
1808 
1809     Similarly, you must call toLatin1(), toUtf8(), or
1810     toLocal8Bit() explicitly to convert the QString to an 8-bit
1811     string.
1812 
1813     \table 100 %
1814     \header
1815     \li Note for C Programmers
1816 
1817     \row
1818     \li
1819     Due to C++'s type system and the fact that QString is
1820     \l{implicitly shared}, QStrings may be treated like \c{int}s or
1821     other basic types. For example:
1822 
1823     \snippet qstring/main.cpp 7
1824 
1825     The \c result variable, is a normal variable allocated on the
1826     stack. When \c return is called, and because we're returning by
1827     value, the copy constructor is called and a copy of the string is
1828     returned. No actual copying takes place thanks to the implicit
1829     sharing.
1830 
1831     \endtable
1832 
1833     \section1 Distinction Between Null and Empty Strings
1834 
1835     For historical reasons, QString distinguishes between a null
1836     string and an empty string. A \e null string is a string that is
1837     initialized using QString's default constructor or by passing
1838     (\c{const char *})0 to the constructor. An \e empty string is any
1839     string with size 0. A null string is always empty, but an empty
1840     string isn't necessarily null:
1841 
1842     \snippet qstring/main.cpp 8
1843 
1844     All functions except isNull() treat null strings the same as empty
1845     strings. For example, toUtf8().constData() returns a valid pointer
1846     (\e not nullptr) to a '\\0' character for a null string. We
1847     recommend that you always use the isEmpty() function and avoid isNull().
1848 
1849     \section1 Argument Formats
1850 
1851     In member functions where an argument \e format can be specified
1852     (e.g., arg(), number()), the argument \e format can be one of the
1853     following:
1854 
1855     \table
1856     \header \li Format \li Meaning
1857     \row \li \c e \li format as [-]9.9e[+|-]999
1858     \row \li \c E \li format as [-]9.9E[+|-]999
1859     \row \li \c f \li format as [-]9.9
1860     \row \li \c g \li use \c e or \c f format, whichever is the most concise
1861     \row \li \c G \li use \c E or \c f format, whichever is the most concise
1862     \endtable
1863 
1864     A \e precision is also specified with the argument \e format. For
1865     the 'e', 'E', and 'f' formats, the \e precision represents the
1866     number of digits \e after the decimal point. For the 'g' and 'G'
1867     formats, the \e precision represents the maximum number of
1868     significant digits (trailing zeroes are omitted).
1869 
1870     \section1 More Efficient String Construction
1871 
1872     Many strings are known at compile time. But the trivial
1873     constructor QString("Hello"), will copy the contents of the string,
1874     treating the contents as Latin-1. To avoid this one can use the
1875     QStringLiteral macro to directly create the required data at compile
1876     time. Constructing a QString out of the literal does then not cause
1877     any overhead at runtime.
1878 
1879     A slightly less efficient way is to use QLatin1String. This class wraps
1880     a C string literal, precalculates it length at compile time and can
1881     then be used for faster comparison with QStrings and conversion to
1882     QStrings than a regular C string literal.
1883 
1884     Using the QString \c{'+'} operator, it is easy to construct a
1885     complex string from multiple substrings. You will often write code
1886     like this:
1887 
1888     \snippet qstring/stringbuilder.cpp 0
1889 
1890     There is nothing wrong with either of these string constructions,
1891     but there are a few hidden inefficiencies. Beginning with Qt 4.6,
1892     you can eliminate them.
1893 
1894     First, multiple uses of the \c{'+'} operator usually means
1895     multiple memory allocations. When concatenating \e{n} substrings,
1896     where \e{n > 2}, there can be as many as \e{n - 1} calls to the
1897     memory allocator.
1898 
1899     In 4.6, an internal template class \c{QStringBuilder} has been
1900     added along with a few helper functions. This class is marked
1901     internal and does not appear in the documentation, because you
1902     aren't meant to instantiate it in your code. Its use will be
1903     automatic, as described below. The class is found in
1904     \c {src/corelib/tools/qstringbuilder.cpp} if you want to have a
1905     look at it.
1906 
1907     \c{QStringBuilder} uses expression templates and reimplements the
1908     \c{'%'} operator so that when you use \c{'%'} for string
1909     concatenation instead of \c{'+'}, multiple substring
1910     concatenations will be postponed until the final result is about
1911     to be assigned to a QString. At this point, the amount of memory
1912     required for the final result is known. The memory allocator is
1913     then called \e{once} to get the required space, and the substrings
1914     are copied into it one by one.
1915 
1916     Additional efficiency is gained by inlining and reduced reference
1917     counting (the QString created from a \c{QStringBuilder} typically
1918     has a ref count of 1, whereas QString::append() needs an extra
1919     test).
1920 
1921     There are two ways you can access this improved method of string
1922     construction. The straightforward way is to include
1923     \c{QStringBuilder} wherever you want to use it, and use the
1924     \c{'%'} operator instead of \c{'+'} when concatenating strings:
1925 
1926     \snippet qstring/stringbuilder.cpp 5
1927 
1928     A more global approach which is the most convenient but
1929     not entirely source compatible, is to this define in your
1930     .pro file:
1931 
1932     \snippet qstring/stringbuilder.cpp 3
1933 
1934     and the \c{'+'} will automatically be performed as the
1935     \c{QStringBuilder} \c{'%'} everywhere.
1936 
1937     \section1 Maximum Size and Out-of-memory Conditions
1938 
1939     The maximum size of QString depends on the architecture. Most 64-bit
1940     systems can allocate more than 2 GB of memory, with a typical limit
1941     of 2^63 bytes. The actual value also depends on the overhead required for
1942     managing the data block. As a result, you can expect the maximum size
1943     of 2 GB minus overhead on 32-bit platforms, and 2^63 bytes minus overhead
1944     on 64-bit platforms. The number of elements that can be stored in a
1945     QString is this maximum size divided by the size of QChar.
1946 
1947     When memory allocation fails, QString throws a \c std::bad_alloc
1948     exception if the application was compiled with exception support.
1949     Out of memory conditions in Qt containers are the only case where Qt
1950     will throw exceptions. If exceptions are disabled, then running out of
1951     memory is undefined behavior.
1952 
1953     Note that the operating system may impose further limits on applications
1954     holding a lot of allocated memory, especially large, contiguous blocks.
1955     Such considerations, the configuration of such behavior or any mitigation
1956     are outside the scope of the Qt API.
1957 
1958     \sa fromRawData(), QChar, QStringView, QLatin1String, QByteArray
1959 */
1960 
1961 /*! \typedef QString::ConstIterator
1962 
1963     Qt-style synonym for QString::const_iterator.
1964 */
1965 
1966 /*! \typedef QString::Iterator
1967 
1968     Qt-style synonym for QString::iterator.
1969 */
1970 
1971 /*! \typedef QString::const_iterator
1972 
1973     \sa QString::iterator
1974 */
1975 
1976 /*! \typedef QString::iterator
1977 
1978     \sa QString::const_iterator
1979 */
1980 
1981 /*! \typedef QString::const_reverse_iterator
1982     \since 5.6
1983 
1984     \sa QString::reverse_iterator, QString::const_iterator
1985 */
1986 
1987 /*! \typedef QString::reverse_iterator
1988     \since 5.6
1989 
1990     \sa QString::const_reverse_iterator, QString::iterator
1991 */
1992 
1993 /*!
1994     \typedef QString::size_type
1995 */
1996 
1997 /*!
1998     \typedef QString::difference_type
1999 */
2000 
2001 /*!
2002     \typedef QString::const_reference
2003 */
2004 /*!
2005     \typedef QString::reference
2006 */
2007 
2008 /*!
2009     \typedef QString::const_pointer
2010 
2011     The QString::const_pointer typedef provides an STL-style
2012     const pointer to a QString element (QChar).
2013 */
2014 /*!
2015     \typedef QString::pointer
2016 
2017     The QString::pointer typedef provides an STL-style
2018     pointer to a QString element (QChar).
2019 */
2020 
2021 /*!
2022     \typedef QString::value_type
2023 */
2024 
2025 /*! \fn QString::iterator QString::begin()
2026 
2027     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the
2028     first character in the string.
2029 
2030 //! [iterator-invalidation-func-desc]
2031     \warning The returned iterator is invalidated on detachment or when the
2032     QString is modified.
2033 //! [iterator-invalidation-func-desc]
2034 
2035     \sa constBegin(), end()
2036 */
2037 
2038 /*! \fn QString::const_iterator QString::begin() const
2039 
2040     \overload begin()
2041 */
2042 
2043 /*! \fn QString::const_iterator QString::cbegin() const
2044     \since 5.0
2045 
2046     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the
2047     first character in the string.
2048 
2049     \include qstring.cpp iterator-invalidation-func-desc
2050 
2051     \sa begin(), cend()
2052 */
2053 
2054 /*! \fn QString::const_iterator QString::constBegin() const
2055 
2056     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the
2057     first character in the string.
2058 
2059     \include qstring.cpp iterator-invalidation-func-desc
2060 
2061     \sa begin(), constEnd()
2062 */
2063 
2064 /*! \fn QString::iterator QString::end()
2065 
2066     Returns an \l{STL-style iterators}{STL-style iterator} pointing just after
2067     the last character in the string.
2068 
2069     \include qstring.cpp iterator-invalidation-func-desc
2070 
2071     \sa begin(), constEnd()
2072 */
2073 
2074 /*! \fn QString::const_iterator QString::end() const
2075 
2076     \overload end()
2077 */
2078 
2079 /*! \fn QString::const_iterator QString::cend() const
2080     \since 5.0
2081 
2082     Returns a const \l{STL-style iterators}{STL-style iterator} pointing just
2083     after the last character in the string.
2084 
2085     \include qstring.cpp iterator-invalidation-func-desc
2086 
2087     \sa cbegin(), end()
2088 */
2089 
2090 /*! \fn QString::const_iterator QString::constEnd() const
2091 
2092     Returns a const \l{STL-style iterators}{STL-style iterator} pointing just
2093     after the last character in the string.
2094 
2095     \include qstring.cpp iterator-invalidation-func-desc
2096 
2097     \sa constBegin(), end()
2098 */
2099 
2100 /*! \fn QString::reverse_iterator QString::rbegin()
2101     \since 5.6
2102 
2103     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to
2104     the first character in the string, in reverse order.
2105 
2106     \include qstring.cpp iterator-invalidation-func-desc
2107 
2108     \sa begin(), crbegin(), rend()
2109 */
2110 
2111 /*! \fn QString::const_reverse_iterator QString::rbegin() const
2112     \since 5.6
2113     \overload
2114 */
2115 
2116 /*! \fn QString::const_reverse_iterator QString::crbegin() const
2117     \since 5.6
2118 
2119     Returns a const \l{STL-style iterators}{STL-style} reverse iterator
2120     pointing to the first character in the string, in reverse order.
2121 
2122     \include qstring.cpp iterator-invalidation-func-desc
2123 
2124     \sa begin(), rbegin(), rend()
2125 */
2126 
2127 /*! \fn QString::reverse_iterator QString::rend()
2128     \since 5.6
2129 
2130     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing just
2131     after the last character in the string, in reverse order.
2132 
2133     \include qstring.cpp iterator-invalidation-func-desc
2134 
2135     \sa end(), crend(), rbegin()
2136 */
2137 
2138 /*! \fn QString::const_reverse_iterator QString::rend() const
2139     \since 5.6
2140     \overload
2141 */
2142 
2143 /*! \fn QString::const_reverse_iterator QString::crend() const
2144     \since 5.6
2145 
2146     Returns a const \l{STL-style iterators}{STL-style} reverse iterator
2147     pointing just after the last character in the string, in reverse order.
2148 
2149     \include qstring.cpp iterator-invalidation-func-desc
2150 
2151     \sa end(), rend(), rbegin()
2152 */
2153 
2154 /*!
2155     \fn QString::QString()
2156 
2157     Constructs a null string. Null strings are also empty.
2158 
2159     \sa isEmpty()
2160 */
2161 
2162 /*!
2163     \fn QString::QString(QString &&other)
2164 
2165     Move-constructs a QString instance, making it point at the same
2166     object that \a other was pointing to.
2167 
2168     \since 5.2
2169 */
2170 
2171 /*! \fn QString::QString(const char *str)
2172 
2173     Constructs a string initialized with the 8-bit string \a str. The
2174     given const char pointer is converted to Unicode using the
2175     fromUtf8() function.
2176 
2177     You can disable this constructor by defining
2178     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
2179     can be useful if you want to ensure that all user-visible strings
2180     go through QObject::tr(), for example.
2181 
2182     \note Defining \l QT_RESTRICTED_CAST_FROM_ASCII also disables
2183     this constructor, but enables a \c{QString(const char (&ch)[N])}
2184     constructor instead. Using non-literal input, or input with
2185     embedded NUL characters, or non-7-bit characters is undefined
2186     in this case.
2187 
2188     \sa fromLatin1(), fromLocal8Bit(), fromUtf8()
2189 */
2190 
2191 /*! \fn QString::QString(const char8_t *str)
2192 
2193     Constructs a string initialized with the UTF-8 string \a str. The
2194     given const char8_t pointer is converted to Unicode using the
2195     fromUtf8() function.
2196 
2197     \since 6.1
2198     \sa fromLatin1(), fromLocal8Bit(), fromUtf8()
2199 */
2200 
2201 /*! \fn QString QString::fromStdString(const std::string &str)
2202 
2203     Returns a copy of the \a str string. The given string is converted
2204     to Unicode using the fromUtf8() function.
2205 
2206     \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QByteArray::fromStdString()
2207 */
2208 
2209 /*! \fn QString QString::fromStdWString(const std::wstring &str)
2210 
2211     Returns a copy of the \a str string. The given string is assumed
2212     to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g. on
2213     windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix
2214     systems).
2215 
2216     \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(),
2217         fromStdU16String(), fromStdU32String()
2218 */
2219 
2220 /*! \fn QString QString::fromWCharArray(const wchar_t *string, qsizetype size)
2221     \since 4.2
2222 
2223     Returns a copy of the \a string, where the encoding of \a string depends on
2224     the size of wchar. If wchar is 4 bytes, the \a string is interpreted as
2225     UCS-4, if wchar is 2 bytes it is interpreted as UTF-16.
2226 
2227     If \a size is -1 (default), the \a string must be '\\0'-terminated.
2228 
2229     \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(),
2230         fromStdWString()
2231 */
2232 
2233 /*! \fn std::wstring QString::toStdWString() const
2234 
2235     Returns a std::wstring object with the data contained in this
2236     QString. The std::wstring is encoded in utf16 on platforms where
2237     wchar_t is 2 bytes wide (e.g. windows) and in ucs4 on platforms
2238     where wchar_t is 4 bytes wide (most Unix systems).
2239 
2240     This method is mostly useful to pass a QString to a function
2241     that accepts a std::wstring object.
2242 
2243     \sa utf16(), toLatin1(), toUtf8(), toLocal8Bit(), toStdU16String(),
2244         toStdU32String()
2245 */
2246 
2247 qsizetype QString::toUcs4_helper(const ushort *uc, qsizetype length, uint *out)
2248 {
2249     qsizetype count = 0;
2250 
2251     QStringIterator i(QStringView(uc, length));
2252     while (i.hasNext())
2253         out[count++] = i.next();
2254 
2255     return count;
2256 }
2257 
2258 /*! \fn qsizetype QString::toWCharArray(wchar_t *array) const
2259   \since 4.2
2260 
2261   Fills the \a array with the data contained in this QString object.
2262   The array is encoded in UTF-16 on platforms where
2263   wchar_t is 2 bytes wide (e.g. windows) and in UCS-4 on platforms
2264   where wchar_t is 4 bytes wide (most Unix systems).
2265 
2266   \a array has to be allocated by the caller and contain enough space to
2267   hold the complete string (allocating the array with the same length as the
2268   string is always sufficient).
2269 
2270   This function returns the actual length of the string in \a array.
2271 
2272   \note This function does not append a null character to the array.
2273 
2274   \sa utf16(), toUcs4(), toLatin1(), toUtf8(), toLocal8Bit(), toStdWString(),
2275       QStringView::toWCharArray()
2276 */
2277 
2278 /*! \fn QString::QString(const QString &other)
2279 
2280     Constructs a copy of \a other.
2281 
2282     This operation takes \l{constant time}, because QString is
2283     \l{implicitly shared}. This makes returning a QString from a
2284     function very fast. If a shared instance is modified, it will be
2285     copied (copy-on-write), and that takes \l{linear time}.
2286 
2287     \sa operator=()
2288 */
2289 
2290 /*!
2291     Constructs a string initialized with the first \a size characters
2292     of the QChar array \a unicode.
2293 
2294     If \a unicode is 0, a null string is constructed.
2295 
2296     If \a size is negative, \a unicode is assumed to point to a \\0'-terminated
2297     array and its length is determined dynamically. The terminating
2298     null character is not considered part of the string.
2299 
2300     QString makes a deep copy of the string data. The unicode data is copied as
2301     is and the Byte Order Mark is preserved if present.
2302 
2303     \sa fromRawData()
2304 */
2305 QString::QString(const QChar *unicode, qsizetype size)
2306 {
2307     if (!unicode) {
2308         d.clear();
2309     } else {
2310         if (size < 0) {
2311             size = 0;
2312             while (!unicode[size].isNull())
2313                 ++size;
2314         }
2315         if (!size) {
2316             d = DataPointer::fromRawData(&_empty, 0);
2317         } else {
2318             d = DataPointer(Data::allocate(size), size);
2319             Q_CHECK_PTR(d.data());
2320             memcpy(d.data(), unicode, size * sizeof(QChar));
2321             d.data()[size] = '\0';
2322         }
2323     }
2324 }
2325 
2326 /*!
2327     Constructs a string of the given \a size with every character set
2328     to \a ch.
2329 
2330     \sa fill()
2331 */
2332 QString::QString(qsizetype size, QChar ch)
2333 {
2334     if (size <= 0) {
2335         d = DataPointer::fromRawData(&_empty, 0);
2336     } else {
2337         d = DataPointer(Data::allocate(size), size);
2338         Q_CHECK_PTR(d.data());
2339         d.data()[size] = '\0';
2340         char16_t *i = d.data() + size;
2341         char16_t *b = d.data();
2342         const char16_t value = ch.unicode();
2343         while (i != b)
2344            *--i = value;
2345     }
2346 }
2347 
2348 /*! \fn QString::QString(qsizetype size, Qt::Initialization)
2349   \internal
2350 
2351   Constructs a string of the given \a size without initializing the
2352   characters. This is only used in \c QStringBuilder::toString().
2353 */
2354 QString::QString(qsizetype size, Qt::Initialization)
2355 {
2356     if (size <= 0) {
2357         d = DataPointer::fromRawData(&_empty, 0);
2358     } else {
2359         d = DataPointer(Data::allocate(size), size);
2360         Q_CHECK_PTR(d.data());
2361         d.data()[size] = '\0';
2362     }
2363 }
2364 
2365 /*! \fn QString::QString(QLatin1String str)
2366 
2367     Constructs a copy of the Latin-1 string \a str.
2368 
2369     \sa fromLatin1()
2370 */
2371 
2372 /*!
2373     Constructs a string of size 1 containing the character \a ch.
2374 */
2375 QString::QString(QChar ch)
2376 {
2377     d = DataPointer(Data::allocate(1), 1);
2378     Q_CHECK_PTR(d.data());
2379     d.data()[0] = ch.unicode();
2380     d.data()[1] = '\0';
2381 }
2382 
2383 /*! \fn QString::QString(const QByteArray &ba)
2384 
2385     Constructs a string initialized with the byte array \a ba. The
2386     given byte array is converted to Unicode using fromUtf8(). Stops
2387     copying at the first 0 character, otherwise copies the entire byte
2388     array.
2389 
2390     You can disable this constructor by defining
2391     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
2392     can be useful if you want to ensure that all user-visible strings
2393     go through QObject::tr(), for example.
2394 
2395     \sa fromLatin1(), fromLocal8Bit(), fromUtf8()
2396 */
2397 
2398 /*! \fn QString::QString(const Null &)
2399     \internal
2400 */
2401 
2402 /*! \fn QString::QString(QStringPrivate)
2403     \internal
2404 */
2405 
2406 /*! \fn QString &QString::operator=(const QString::Null &)
2407     \internal
2408 */
2409 
2410 /*!
2411   \fn QString::~QString()
2412 
2413     Destroys the string.
2414 */
2415 
2416 
2417 /*! \fn void QString::swap(QString &other)
2418     \since 4.8
2419 
2420     Swaps string \a other with this string. This operation is very fast and
2421     never fails.
2422 */
2423 
2424 /*! \fn void QString::detach()
2425 
2426     \internal
2427 */
2428 
2429 /*! \fn bool QString::isDetached() const
2430 
2431     \internal
2432 */
2433 
2434 /*! \fn bool QString::isSharedWith(const QString &other) const
2435 
2436     \internal
2437 */
2438 
2439 /*!
2440     Sets the size of the string to \a size characters.
2441 
2442     If \a size is greater than the current size, the string is
2443     extended to make it \a size characters long with the extra
2444     characters added to the end. The new characters are uninitialized.
2445 
2446     If \a size is less than the current size, characters beyond position
2447     \a size are excluded from the string.
2448 
2449     \note While resize() will grow the capacity if needed, it never shrinks
2450     capacity. To shed excess capacity, use squeeze().
2451 
2452     Example:
2453 
2454     \snippet qstring/main.cpp 45
2455 
2456     If you want to append a certain number of identical characters to
2457     the string, use the \l {QString::}{resize(qsizetype, QChar)} overload.
2458 
2459     If you want to expand the string so that it reaches a certain
2460     width and fill the new positions with a particular character, use
2461     the leftJustified() function:
2462 
2463     If \a size is negative, it is equivalent to passing zero.
2464 
2465     \snippet qstring/main.cpp 47
2466 
2467     \sa truncate(), reserve(), squeeze()
2468 */
2469 
2470 void QString::resize(qsizetype size)
2471 {
2472     if (size < 0)
2473         size = 0;
2474 
2475     const auto capacityAtEnd = capacity() - d.freeSpaceAtBegin();
2476     if (d->needsDetach() || size > capacityAtEnd)
2477         reallocData(size, QArrayData::Grow);
2478     d.size = size;
2479     if (d->allocatedCapacity())
2480         d.data()[size] = 0;
2481 }
2482 
2483 /*!
2484     \overload
2485     \since 5.7
2486 
2487     Unlike \l {QString::}{resize(qsizetype)}, this overload
2488     initializes the new characters to \a fillChar:
2489 
2490     \snippet qstring/main.cpp 46
2491 */
2492 
2493 void QString::resize(qsizetype size, QChar fillChar)
2494 {
2495     const qsizetype oldSize = length();
2496     resize(size);
2497     const qsizetype difference = length() - oldSize;
2498     if (difference > 0)
2499         std::fill_n(d.data() + oldSize, difference, fillChar.unicode());
2500 }
2501 
2502 /*! \fn qsizetype QString::capacity() const
2503 
2504     Returns the maximum number of characters that can be stored in
2505     the string without forcing a reallocation.
2506 
2507     The sole purpose of this function is to provide a means of fine
2508     tuning QString's memory usage. In general, you will rarely ever
2509     need to call this function. If you want to know how many
2510     characters are in the string, call size().
2511 
2512     \note a statically allocated string will report a capacity of 0,
2513     even if it's not empty.
2514 
2515     \note The free space position in the allocated memory block is undefined. In
2516     other words, one should not assume that the free memory is always located
2517     after the initialized elements.
2518 
2519     \sa reserve(), squeeze()
2520 */
2521 
2522 /*!
2523     \fn void QString::reserve(qsizetype size)
2524 
2525     Ensures the string has space for at least \a size characters.
2526 
2527     If you know in advance how large the string will be, you can call this
2528     function to save repeated reallocation in the course of building it.
2529     This can improve performance when building a string incrementally.
2530     A long sequence of operations that add to a string may trigger several
2531     reallocations, the last of which may leave you with significantly more
2532     space than you really need, which is less efficient than doing a single
2533     allocation of the right size at the start.
2534 
2535     If in doubt about how much space shall be needed, it is usually better to
2536     use an upper bound as \a size, or a high estimate of the most likely size,
2537     if a strict upper bound would be much bigger than this. If \a size is an
2538     underestimate, the string will grow as needed once the reserved size is
2539     exceeded, which may lead to a larger allocation than your best overestimate
2540     would have and will slow the operation that triggers it.
2541 
2542     \warning reserve() reserves memory but does not change the size of the
2543     string. Accessing data beyond the end of the string is undefined behavior.
2544     If you need to access memory beyond the current end of the string,
2545     use resize().
2546 
2547     This function is useful for code that needs to build up a long
2548     string and wants to avoid repeated reallocation. In this example,
2549     we want to add to the string until some condition is \c true, and
2550     we're fairly sure that size is large enough to make a call to
2551     reserve() worthwhile:
2552 
2553     \snippet qstring/main.cpp 44
2554 
2555     \sa squeeze(), capacity(), resize()
2556 */
2557 
2558 /*!
2559     \fn void QString::squeeze()
2560 
2561     Releases any memory not required to store the character data.
2562 
2563     The sole purpose of this function is to provide a means of fine
2564     tuning QString's memory usage. In general, you will rarely ever
2565     need to call this function.
2566 
2567     \sa reserve(), capacity()
2568 */
2569 
2570 void QString::reallocData(qsizetype alloc, QArrayData::AllocationOption option)
2571 {
2572     if (!alloc) {
2573         d = DataPointer::fromRawData(&_empty, 0);
2574         return;
2575     }
2576 
2577     // don't use reallocate path when reducing capacity and there's free space
2578     // at the beginning: might shift data pointer outside of allocated space
2579     const bool cannotUseReallocate = d.freeSpaceAtBegin() > 0;
2580 
2581     if (d->needsDetach() || cannotUseReallocate) {
2582         DataPointer dd(Data::allocate(alloc, option), qMin(alloc, d.size));
2583         Q_CHECK_PTR(dd.data());
2584         if (dd.size > 0)
2585             ::memcpy(dd.data(), d.data(), dd.size * sizeof(QChar));
2586         dd.data()[dd.size] = 0;
2587         d = dd;
2588     } else {
2589         d->reallocate(alloc, option);
2590     }
2591 }
2592 
2593 void QString::reallocGrowData(qsizetype n)
2594 {
2595     if (!n)  // expected to always allocate
2596         n = 1;
2597 
2598     if (d->needsDetach()) {
2599         DataPointer dd(DataPointer::allocateGrow(d, n, QArrayData::GrowsAtEnd));
2600         Q_CHECK_PTR(dd.data());
2601         dd->copyAppend(d.data(), d.data() + d.size);
2602         dd.data()[dd.size] = 0;
2603         d = dd;
2604     } else {
2605         d->reallocate(d.constAllocatedCapacity() + n, QArrayData::Grow);
2606     }
2607 }
2608 
2609 /*! \fn void QString::clear()
2610 
2611     Clears the contents of the string and makes it null.
2612 
2613     \sa resize(), isNull()
2614 */
2615 
2616 /*! \fn QString &QString::operator=(const QString &other)
2617 
2618     Assigns \a other to this string and returns a reference to this
2619     string.
2620 */
2621 
2622 QString &QString::operator=(const QString &other) noexcept
2623 {
2624     d = other.d;
2625     return *this;
2626 }
2627 
2628 /*!
2629     \fn QString &QString::operator=(QString &&other)
2630 
2631     Move-assigns \a other to this QString instance.
2632 
2633     \since 5.2
2634 */
2635 
2636 /*! \fn QString &QString::operator=(QLatin1String str)
2637 
2638     \overload operator=()
2639 
2640     Assigns the Latin-1 string \a str to this string.
2641 */
2642 QString &QString::operator=(QLatin1String other)
2643 {
2644     const qsizetype capacityAtEnd = capacity() - d.freeSpaceAtBegin();
2645     if (isDetached() && other.size() <= capacityAtEnd) { // assumes d->alloc == 0 -> !isDetached() (sharedNull)
2646         d.size = other.size();
2647         d.data()[other.size()] = 0;
2648         qt_from_latin1(d.data(), other.latin1(), other.size());
2649     } else {
2650         *this = fromLatin1(other.latin1(), other.size());
2651     }
2652     return *this;
2653 }
2654 
2655 /*! \fn QString &QString::operator=(const QByteArray &ba)
2656 
2657     \overload operator=()
2658 
2659     Assigns \a ba to this string. The byte array is converted to Unicode
2660     using the fromUtf8() function. This function stops conversion at the
2661     first NUL character found, or the end of the \a ba byte array.
2662 
2663     You can disable this operator by defining
2664     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
2665     can be useful if you want to ensure that all user-visible strings
2666     go through QObject::tr(), for example.
2667 */
2668 
2669 /*! \fn QString &QString::operator=(const char *str)
2670 
2671     \overload operator=()
2672 
2673     Assigns \a str to this string. The const char pointer is converted
2674     to Unicode using the fromUtf8() function.
2675 
2676     You can disable this operator by defining \l QT_NO_CAST_FROM_ASCII
2677     or \l QT_RESTRICTED_CAST_FROM_ASCII when you compile your applications.
2678     This can be useful if you want to ensure that all user-visible strings
2679     go through QObject::tr(), for example.
2680 */
2681 
2682 /*!
2683     \overload operator=()
2684 
2685     Sets the string to contain the single character \a ch.
2686 */
2687 QString &QString::operator=(QChar ch)
2688 {
2689     const qsizetype capacityAtEnd = capacity() - d.freeSpaceAtBegin();
2690     if (isDetached() && capacityAtEnd >= 1) { // assumes d->alloc == 0 -> !isDetached() (sharedNull)
2691         // re-use existing capacity:
2692         d.data()[0] = ch.unicode();
2693         d.data()[1] = 0;
2694         d.size = 1;
2695     } else {
2696         operator=(QString(ch));
2697     }
2698     return *this;
2699 }
2700 
2701 /*!
2702      \fn QString& QString::insert(qsizetype position, const QString &str)
2703 
2704     Inserts the string \a str at the given index \a position and
2705     returns a reference to this string.
2706 
2707     Example:
2708 
2709     \snippet qstring/main.cpp 26
2710 
2711 //! [string-grow-at-insertion]
2712     This string grows to accommodate the insertion. If \a position is beyond
2713     the end of the string, space characters are appended to the string to reach
2714     this \a position, followed by \a str.
2715 //! [string-grow-at-insertion]
2716 
2717     \sa append(), prepend(), replace(), remove()
2718 */
2719 
2720 /*!
2721     \fn QString& QString::insert(qsizetype position, QStringView str)
2722     \since 6.0
2723     \overload insert()
2724 
2725     Inserts the string view \a str at the given index \a position and
2726     returns a reference to this string.
2727 
2728     \include qstring.cpp string-grow-at-insertion
2729 */
2730 
2731 
2732 /*!
2733     \fn QString& QString::insert(qsizetype position, const char *str)
2734     \since 5.5
2735     \overload insert()
2736 
2737     Inserts the C string \a str at the given index \a position and
2738     returns a reference to this string.
2739 
2740     \include qstring.cpp string-grow-at-insertion
2741 
2742     This function is not available when \l QT_NO_CAST_FROM_ASCII is
2743     defined.
2744 */
2745 
2746 
2747 /*!
2748     \fn QString& QString::insert(qsizetype position, const QByteArray &str)
2749     \since 5.5
2750     \overload insert()
2751 
2752     Interprets the contents of \a str as UTF-8, inserts the Unicode string
2753     it encodes at the given index \a position and returns a reference to
2754     this string.
2755 
2756     \include qstring.cpp string-grow-at-insertion
2757 
2758     This function is not available when \l QT_NO_CAST_FROM_ASCII is
2759     defined.
2760 */
2761 
2762 /*!
2763     \fn QString &QString::insert(qsizetype position, QLatin1String str)
2764     \overload insert()
2765 
2766     Inserts the Latin-1 string \a str at the given index \a position.
2767 
2768     \include qstring.cpp string-grow-at-insertion
2769 */
2770 QString &QString::insert(qsizetype i, QLatin1String str)
2771 {
2772     const char *s = str.latin1();
2773     if (i < 0 || !s || !(*s))
2774         return *this;
2775 
2776     qsizetype len = str.size();
2777     qsizetype difference = 0;
2778     if (Q_UNLIKELY(i > size()))
2779         difference = i - size();
2780     d.detachAndGrow(Data::GrowsAtEnd, difference + len, nullptr, nullptr);
2781     Q_CHECK_PTR(d.data());
2782     d->copyAppend(difference, u' ');
2783     d.size += len;
2784 
2785     ::memmove(d.data() + i + len, d.data() + i, (d.size - i - len) * sizeof(QChar));
2786     qt_from_latin1(d.data() + i, s, size_t(len));
2787     d.data()[d.size] = u'\0';
2788     return *this;
2789 }
2790 
2791 /*!
2792     \fn QString& QString::insert(qsizetype position, const QChar *unicode, qsizetype size)
2793     \overload insert()
2794 
2795     Inserts the first \a size characters of the QChar array \a unicode
2796     at the given index \a position in the string.
2797 
2798     This string grows to accommodate the insertion. If \a position is beyond
2799     the end of the string, space characters are appended to the string to reach
2800     this \a position, followed by \a size characters of the QChar array
2801     \a unicode.
2802 */
2803 QString& QString::insert(qsizetype i, const QChar *unicode, qsizetype size)
2804 {
2805     if (i < 0 || size <= 0)
2806         return *this;
2807 
2808     const char16_t *s = reinterpret_cast<const char16_t *>(unicode);
2809 
2810     // handle this specially, as QArrayDataOps::insert() doesn't handle out of
2811     // bounds positions
2812     if (i >= d->size) {
2813         // In case when data points into the range or is == *this, we need to
2814         // defer a call to free() so that it comes after we copied the data from
2815         // the old memory:
2816         DataPointer detached{};  // construction is free
2817         d.detachAndGrow(Data::GrowsAtEnd, (i - d.size) + size, &s, &detached);
2818         Q_CHECK_PTR(d.data());
2819         d->copyAppend(i - d->size, u' ');
2820         d->copyAppend(s, s + size);
2821         d.data()[d.size] = u'\0';
2822         return *this;
2823     }
2824 
2825     if (!d->needsDetach() && QtPrivate::q_points_into_range(s, d.data(), d.data() + d.size))
2826         return insert(i, QStringView{QVarLengthArray(s, s + size)});
2827 
2828     d->insert(i, s, size);
2829     d.data()[d.size] = u'\0';
2830     return *this;
2831 }
2832 
2833 /*!
2834     \fn QString& QString::insert(qsizetype position, QChar ch)
2835     \overload insert()
2836 
2837     Inserts \a ch at the given index \a position in the string.
2838 
2839     This string grows to accommodate the insertion. If \a position is beyond
2840     the end of the string, space characters are appended to the string to reach
2841     this \a position, followed by \a ch.
2842 */
2843 
2844 QString& QString::insert(qsizetype i, QChar ch)
2845 {
2846     if (i < 0)
2847         i += d.size;
2848     return insert(i, &ch, 1);
2849 }
2850 
2851 /*!
2852     Appends the string \a str onto the end of this string.
2853 
2854     Example:
2855 
2856     \snippet qstring/main.cpp 9
2857 
2858     This is the same as using the insert() function:
2859 
2860     \snippet qstring/main.cpp 10
2861 
2862     The append() function is typically very fast (\l{constant time}),
2863     because QString preallocates extra space at the end of the string
2864     data so it can grow without reallocating the entire string each
2865     time.
2866 
2867     \sa operator+=(), prepend(), insert()
2868 */
2869 QString &QString::append(const QString &str)
2870 {
2871     if (!str.isNull()) {
2872         if (isNull()) {
2873             operator=(str);
2874         } else if (str.size()) {
2875             append(str.constData(), str.size());
2876         }
2877     }
2878     return *this;
2879 }
2880 
2881 /*!
2882   \overload append()
2883   \since 5.0
2884 
2885   Appends \a len characters from the QChar array \a str to this string.
2886 */
2887 QString &QString::append(const QChar *str, qsizetype len)
2888 {
2889     if (str && len > 0) {
2890         static_assert(sizeof(QChar) == sizeof(char16_t), "Unexpected difference in sizes");
2891         // the following should be safe as QChar uses char16_t as underlying data
2892         const char16_t *char16String = reinterpret_cast<const char16_t *>(str);
2893         d->growAppend(char16String, char16String + len);
2894         d.data()[d.size] = u'\0';
2895     }
2896     return *this;
2897 }
2898 
2899 /*!
2900   \overload append()
2901 
2902   Appends the Latin-1 string \a str to this string.
2903 */
2904 QString &QString::append(QLatin1String str)
2905 {
2906     const char *s = str.latin1();
2907     const qsizetype len = str.size();
2908     if (s && len > 0) {
2909         d.detachAndGrow(Data::GrowsAtEnd, len, nullptr, nullptr);
2910         Q_CHECK_PTR(d.data());
2911         Q_ASSERT(len <= d->freeSpaceAtEnd());
2912         char16_t *i = d.data() + d.size;
2913         qt_from_latin1(i, s, size_t(len));
2914         d.size += len;
2915         d.data()[d.size] = '\0';
2916     } else if (d.isNull() && !str.isNull()) { // special case
2917         d = DataPointer::fromRawData(&_empty, 0);
2918     }
2919     return *this;
2920 }
2921 
2922 /*! \fn QString &QString::append(const QByteArray &ba)
2923 
2924     \overload append()
2925 
2926     Appends the byte array \a ba to this string. The given byte array
2927     is converted to Unicode using the fromUtf8() function.
2928 
2929     You can disable this function by defining \l QT_NO_CAST_FROM_ASCII
2930     when you compile your applications. This can be useful if you want
2931     to ensure that all user-visible strings go through QObject::tr(),
2932     for example.
2933 */
2934 
2935 /*! \fn QString &QString::append(const char *str)
2936 
2937     \overload append()
2938 
2939     Appends the string \a str to this string. The given const char
2940     pointer is converted to Unicode using the fromUtf8() function.
2941 
2942     You can disable this function by defining \l QT_NO_CAST_FROM_ASCII
2943     when you compile your applications. This can be useful if you want
2944     to ensure that all user-visible strings go through QObject::tr(),
2945     for example.
2946 */
2947 
2948 /*!
2949     \overload append()
2950 
2951     Appends the character \a ch to this string.
2952 */
2953 QString &QString::append(QChar ch)
2954 {
2955     d.detachAndGrow(QArrayData::GrowsAtEnd, 1, nullptr, nullptr);
2956     d->copyAppend(1, ch.unicode());
2957     d.data()[d.size] = '\0';
2958     return *this;
2959 }
2960 
2961 /*! \fn QString &QString::prepend(const QString &str)
2962 
2963     Prepends the string \a str to the beginning of this string and
2964     returns a reference to this string.
2965 
2966     This operation is typically very fast (\l{constant time}), because
2967     QString preallocates extra space at the beginning of the string data,
2968     so it can grow without reallocating the entire string each time.
2969 
2970     Example:
2971 
2972     \snippet qstring/main.cpp 36
2973 
2974     \sa append(), insert()
2975 */
2976 
2977 /*! \fn QString &QString::prepend(QLatin1String str)
2978 
2979     \overload prepend()
2980 
2981     Prepends the Latin-1 string \a str to this string.
2982 */
2983 
2984 /*! \fn QString &QString::prepend(const QChar *str, qsizetype len)
2985     \since 5.5
2986     \overload prepend()
2987 
2988     Prepends \a len characters from the QChar array \a str to this string and
2989     returns a reference to this string.
2990 */
2991 
2992 /*! \fn QString &QString::prepend(QStringView str)
2993     \since 6.0
2994     \overload prepend()
2995 
2996     Prepends the string view \a str to the beginning of this string and
2997     returns a reference to this string.
2998 */
2999 
3000 /*! \fn QString &QString::prepend(const QByteArray &ba)
3001 
3002     \overload prepend()
3003 
3004     Prepends the byte array \a ba to this string. The byte array is
3005     converted to Unicode using the fromUtf8() function.
3006 
3007     You can disable this function by defining
3008     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3009     can be useful if you want to ensure that all user-visible strings
3010     go through QObject::tr(), for example.
3011 */
3012 
3013 /*! \fn QString &QString::prepend(const char *str)
3014 
3015     \overload prepend()
3016 
3017     Prepends the string \a str to this string. The const char pointer
3018     is converted to Unicode using the fromUtf8() function.
3019 
3020     You can disable this function by defining
3021     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3022     can be useful if you want to ensure that all user-visible strings
3023     go through QObject::tr(), for example.
3024 */
3025 
3026 /*! \fn QString &QString::prepend(QChar ch)
3027 
3028     \overload prepend()
3029 
3030     Prepends the character \a ch to this string.
3031 */
3032 
3033 /*!
3034   \fn QString &QString::remove(qsizetype position, qsizetype n)
3035 
3036   Removes \a n characters from the string, starting at the given \a
3037   position index, and returns a reference to the string.
3038 
3039   If the specified \a position index is within the string, but \a
3040   position + \a n is beyond the end of the string, the string is
3041   truncated at the specified \a position.
3042 
3043   \snippet qstring/main.cpp 37
3044 
3045 //! [shrinking-erase]
3046   Element removal will preserve the string's capacity and not reduce the
3047   amount of allocated memory. To shed extra capacity and free as much memory
3048   as possible, call squeeze() after the last change to the string's size.
3049 //! [shrinking-erase]
3050 
3051   \sa insert(), replace()
3052 */
3053 QString &QString::remove(qsizetype pos, qsizetype len)
3054 {
3055     if (pos < 0)  // count from end of string
3056         pos += size();
3057     if (size_t(pos) >= size_t(size())) {
3058         // range problems
3059     } else if (len >= size() - pos) {
3060         resize(pos); // truncate
3061     } else if (len > 0) {
3062         detach();
3063         d->erase(d.begin() + pos, len);
3064         d.data()[d.size] = u'\0';
3065     }
3066     return *this;
3067 }
3068 
3069 template<typename T>
3070 static void removeStringImpl(QString &s, const T &needle, Qt::CaseSensitivity cs)
3071 {
3072     const auto needleSize = needle.size();
3073     if (!needleSize)
3074         return;
3075 
3076     // avoid detach if nothing to do:
3077     qsizetype i = s.indexOf(needle, 0, cs);
3078     if (i < 0)
3079         return;
3080 
3081     const auto beg = s.begin(); // detaches
3082     auto dst = beg + i;
3083     auto src = beg + i + needleSize;
3084     const auto end = s.end();
3085     // loop invariant: [beg, dst[ is partial result
3086     //                 [src, end[ still to be checked for needles
3087     while (src < end) {
3088         const auto i = s.indexOf(needle, src - beg, cs);
3089         const auto hit = i == -1 ? end : beg + i;
3090         const auto skipped = hit - src;
3091         memmove(dst, src, skipped * sizeof(QChar));
3092         dst += skipped;
3093         src = hit + needleSize;
3094     }
3095     s.truncate(dst - beg);
3096 }
3097 
3098 /*!
3099   Removes every occurrence of the given \a str string in this
3100   string, and returns a reference to this string.
3101 
3102   If \a cs is Qt::CaseSensitive (default), the search is
3103   case sensitive; otherwise the search is case insensitive.
3104 
3105   This is the same as \c replace(str, "", cs).
3106 
3107   \include qstring.cpp shrinking-erase
3108 
3109   \sa replace()
3110 */
3111 QString &QString::remove(const QString &str, Qt::CaseSensitivity cs)
3112 {
3113     const auto s = str.d.data();
3114     if (QtPrivate::q_points_into_range(s, d.data(), d.data() + d.size))
3115         removeStringImpl(*this, QStringView{QVarLengthArray(s, s + str.size())}, cs);
3116     else
3117         removeStringImpl(*this, qToStringViewIgnoringNull(str), cs);
3118     return *this;
3119 }
3120 
3121 /*!
3122   \since 5.11
3123   \overload
3124 
3125   Removes every occurrence of the given \a str string in this
3126   string, and returns a reference to this string.
3127 
3128   If \a cs is Qt::CaseSensitive (default), the search is
3129   case sensitive; otherwise the search is case insensitive.
3130 
3131   This is the same as \c replace(str, "", cs).
3132 
3133   \include qstring.cpp shrinking-erase
3134 
3135   \sa replace()
3136 */
3137 QString &QString::remove(QLatin1String str, Qt::CaseSensitivity cs)
3138 {
3139     removeStringImpl(*this, str, cs);
3140     return *this;
3141 }
3142 
3143 /*!
3144   Removes every occurrence of the character \a ch in this string, and
3145   returns a reference to this string.
3146 
3147   If \a cs is Qt::CaseSensitive (default), the search is case
3148   sensitive; otherwise the search is case insensitive.
3149 
3150   Example:
3151 
3152   \snippet qstring/main.cpp 38
3153 
3154   This is the same as \c replace(ch, "", cs).
3155 
3156   \include qstring.cpp shrinking-erase
3157 
3158   \sa replace()
3159 */
3160 QString &QString::remove(QChar ch, Qt::CaseSensitivity cs)
3161 {
3162     const qsizetype idx = indexOf(ch, 0, cs);
3163     if (idx != -1) {
3164         const auto first = begin(); // implicit detach()
3165         auto last = end();
3166         if (cs == Qt::CaseSensitive) {
3167             last = std::remove(first + idx, last, ch);
3168         } else {
3169             const QChar c = ch.toCaseFolded();
3170             auto caseInsensEqual = [c](QChar x) {
3171                 return c == x.toCaseFolded();
3172             };
3173             last = std::remove_if(first + idx, last, caseInsensEqual);
3174         }
3175         resize(last - first);
3176     }
3177     return *this;
3178 }
3179 
3180 /*!
3181   \fn QString &QString::remove(const QRegularExpression &re)
3182   \since 5.0
3183 
3184   Removes every occurrence of the regular expression \a re in the
3185   string, and returns a reference to the string. For example:
3186 
3187   \snippet qstring/main.cpp 96
3188 
3189   \include qstring.cpp shrinking-erase
3190 
3191   \sa indexOf(), lastIndexOf(), replace()
3192 */
3193 
3194 /*!
3195   \fn template <typename Predicate> QString &QString::removeIf(Predicate pred)
3196   \since 6.1
3197 
3198   Removes all elements for which the predicate \a pred returns true
3199   from the string. Returns a reference to the string.
3200 
3201   \sa remove()
3202 */
3203 
3204 /*!
3205   \fn QString &QString::replace(qsizetype position, qsizetype n, const QString &after)
3206 
3207   Replaces \a n characters beginning at index \a position with
3208   the string \a after and returns a reference to this string.
3209 
3210   \note If the specified \a position index is within the string,
3211   but \a position + \a n goes outside the strings range,
3212   then \a n will be adjusted to stop at the end of the string.
3213 
3214   Example:
3215 
3216   \snippet qstring/main.cpp 40
3217 
3218   \sa insert(), remove()
3219 */
3220 QString &QString::replace(qsizetype pos, qsizetype len, const QString &after)
3221 {
3222     return replace(pos, len, after.constData(), after.length());
3223 }
3224 
3225 /*!
3226   \fn QString &QString::replace(qsizetype position, qsizetype n, const QChar *unicode, qsizetype size)
3227   \overload replace()
3228   Replaces \a n characters beginning at index \a position with the
3229   first \a size characters of the QChar array \a unicode and returns a
3230   reference to this string.
3231 */
3232 QString &QString::replace(qsizetype pos, qsizetype len, const QChar *unicode, qsizetype size)
3233 {
3234     if (size_t(pos) > size_t(this->size()))
3235         return *this;
3236     if (len > this->size() - pos)
3237         len = this->size() - pos;
3238 
3239     size_t index = pos;
3240     replace_helper(&index, 1, len, unicode, size);
3241     return *this;
3242 }
3243 
3244 /*!
3245   \fn QString &QString::replace(qsizetype position, qsizetype n, QChar after)
3246   \overload replace()
3247 
3248   Replaces \a n characters beginning at index \a position with the
3249   character \a after and returns a reference to this string.
3250 */
3251 QString &QString::replace(qsizetype pos, qsizetype len, QChar after)
3252 {
3253     return replace(pos, len, &after, 1);
3254 }
3255 
3256 /*!
3257   \overload replace()
3258   Replaces every occurrence of the string \a before with the string \a
3259   after and returns a reference to this string.
3260 
3261   If \a cs is Qt::CaseSensitive (default), the search is case
3262   sensitive; otherwise the search is case insensitive.
3263 
3264   Example:
3265 
3266   \snippet qstring/main.cpp 41
3267 
3268   \note The replacement text is not rescanned after it is inserted.
3269 
3270   Example:
3271 
3272   \snippet qstring/main.cpp 86
3273 */
3274 QString &QString::replace(const QString &before, const QString &after, Qt::CaseSensitivity cs)
3275 {
3276     return replace(before.constData(), before.size(), after.constData(), after.size(), cs);
3277 }
3278 
3279 namespace { // helpers for replace and its helper:
3280 QChar *textCopy(const QChar *start, qsizetype len)
3281 {
3282     const size_t size = len * sizeof(QChar);
3283     QChar *const copy = static_cast<QChar *>(::malloc(size));
3284     Q_CHECK_PTR(copy);
3285     ::memcpy(copy, start, size);
3286     return copy;
3287 }
3288 
3289 static bool pointsIntoRange(const QChar *ptr, const char16_t *base, qsizetype len)
3290 {
3291     const QChar *const start = reinterpret_cast<const QChar *>(base);
3292     const std::less<const QChar *> less;
3293     return !less(ptr, start) && less(ptr, start + len);
3294 }
3295 } // end namespace
3296 
3297 /*!
3298   \internal
3299  */
3300 void QString::replace_helper(size_t *indices, qsizetype nIndices, qsizetype blen, const QChar *after, qsizetype alen)
3301 {
3302     // Copy after if it lies inside our own d.b area (which we could
3303     // possibly invalidate via a realloc or modify by replacement).
3304     QChar *afterBuffer = nullptr;
3305     if (pointsIntoRange(after, d.data(), d.size)) // Use copy in place of vulnerable original:
3306         after = afterBuffer = textCopy(after, alen);
3307 
3308     QT_TRY {
3309         if (blen == alen) {
3310             // replace in place
3311             detach();
3312             for (qsizetype i = 0; i < nIndices; ++i)
3313                 memcpy(d.data() + indices[i], after, alen * sizeof(QChar));
3314         } else if (alen < blen) {
3315             // replace from front
3316             detach();
3317             size_t to = indices[0];
3318             if (alen)
3319                 memcpy(d.data()+to, after, alen*sizeof(QChar));
3320             to += alen;
3321             size_t movestart = indices[0] + blen;
3322             for (qsizetype i = 1; i < nIndices; ++i) {
3323                 qsizetype msize = indices[i] - movestart;
3324                 if (msize > 0) {
3325                     memmove(d.data() + to, d.data() + movestart, msize * sizeof(QChar));
3326                     to += msize;
3327                 }
3328                 if (alen) {
3329                     memcpy(d.data() + to, after, alen * sizeof(QChar));
3330                     to += alen;
3331                 }
3332                 movestart = indices[i] + blen;
3333             }
3334             qsizetype msize = d.size - movestart;
3335             if (msize > 0)
3336                 memmove(d.data() + to, d.data() + movestart, msize * sizeof(QChar));
3337             resize(d.size - nIndices*(blen-alen));
3338         } else {
3339             // replace from back
3340             qsizetype adjust = nIndices*(alen-blen);
3341             qsizetype newLen = d.size + adjust;
3342             qsizetype moveend = d.size;
3343             resize(newLen);
3344 
3345             while (nIndices) {
3346                 --nIndices;
3347                 qsizetype movestart = indices[nIndices] + blen;
3348                 qsizetype insertstart = indices[nIndices] + nIndices*(alen-blen);
3349                 qsizetype moveto = insertstart + alen;
3350                 memmove(d.data() + moveto, d.data() + movestart,
3351                         (moveend - movestart)*sizeof(QChar));
3352                 memcpy(d.data() + insertstart, after, alen * sizeof(QChar));
3353                 moveend = movestart-blen;
3354             }
3355         }
3356     } QT_CATCH(const std::bad_alloc &) {
3357         ::free(afterBuffer);
3358         QT_RETHROW;
3359     }
3360     ::free(afterBuffer);
3361 }
3362 
3363 /*!
3364   \since 4.5
3365   \overload replace()
3366 
3367   Replaces each occurrence in this string of the first \a blen
3368   characters of \a before with the first \a alen characters of \a
3369   after and returns a reference to this string.
3370 
3371   If \a cs is Qt::CaseSensitive (default), the search is case
3372   sensitive; otherwise the search is case insensitive.
3373 */
3374 QString &QString::replace(const QChar *before, qsizetype blen,
3375                           const QChar *after, qsizetype alen,
3376                           Qt::CaseSensitivity cs)
3377 {
3378     if (d.size == 0) {
3379         if (blen)
3380             return *this;
3381     } else {
3382         if (cs == Qt::CaseSensitive && before == after && blen == alen)
3383             return *this;
3384     }
3385     if (alen == 0 && blen == 0)
3386         return *this;
3387 
3388     QStringMatcher matcher(before, blen, cs);
3389     QChar *beforeBuffer = nullptr, *afterBuffer = nullptr;
3390 
3391     qsizetype index = 0;
3392     while (1) {
3393         size_t indices[1024];
3394         size_t pos = 0;
3395         while (pos < 1024) {
3396             index = matcher.indexIn(*this, index);
3397             if (index == -1)
3398                 break;
3399             indices[pos++] = index;
3400             if (blen) // Step over before:
3401                 index += blen;
3402             else // Only count one instance of empty between any two characters:
3403                 index++;
3404         }
3405         if (!pos) // Nothing to replace
3406             break;
3407 
3408         if (Q_UNLIKELY(index != -1)) {
3409             /*
3410               We're about to change data, that before and after might point
3411               into, and we'll need that data for our next batch of indices.
3412             */
3413             if (!afterBuffer && pointsIntoRange(after, d.data(), d.size))
3414                 after = afterBuffer = textCopy(after, alen);
3415 
3416             if (!beforeBuffer && pointsIntoRange(before, d.data(), d.size)) {
3417                 beforeBuffer = textCopy(before, blen);
3418                 matcher = QStringMatcher(beforeBuffer, blen, cs);
3419             }
3420         }
3421 
3422         replace_helper(indices, pos, blen, after, alen);
3423 
3424         if (Q_LIKELY(index == -1)) // Nothing left to replace
3425             break;
3426         // The call to replace_helper just moved what index points at:
3427         index += pos*(alen-blen);
3428     }
3429     ::free(afterBuffer);
3430     ::free(beforeBuffer);
3431 
3432     return *this;
3433 }
3434 
3435 /*!
3436   \overload replace()
3437   Replaces every occurrence of the character \a ch in the string with
3438   \a after and returns a reference to this string.
3439 
3440   If \a cs is Qt::CaseSensitive (default), the search is case
3441   sensitive; otherwise the search is case insensitive.
3442 */
3443 QString& QString::replace(QChar ch, const QString &after, Qt::CaseSensitivity cs)
3444 {
3445     if (after.size() == 0)
3446         return remove(ch, cs);
3447 
3448     if (after.size() == 1)
3449         return replace(ch, after.front(), cs);
3450 
3451     if (size() == 0)
3452         return *this;
3453 
3454     char16_t cc = (cs == Qt::CaseSensitive ? ch.unicode() : ch.toCaseFolded().unicode());
3455 
3456     qsizetype index = 0;
3457     while (1) {
3458         size_t indices[1024];
3459         size_t pos = 0;
3460         if (cs == Qt::CaseSensitive) {
3461             while (pos < 1024 && index < size()) {
3462                 if (d.data()[index] == cc)
3463                     indices[pos++] = index;
3464                 index++;
3465             }
3466         } else {
3467             while (pos < 1024 && index < size()) {
3468                 if (QChar::toCaseFolded(d.data()[index]) == cc)
3469                     indices[pos++] = index;
3470                 index++;
3471             }
3472         }
3473         if (!pos) // Nothing to replace
3474             break;
3475 
3476         replace_helper(indices, pos, 1, after.constData(), after.size());
3477 
3478         if (Q_LIKELY(index == size())) // Nothing left to replace
3479             break;
3480         // The call to replace_helper just moved what index points at:
3481         index += pos*(after.size() - 1);
3482     }
3483     return *this;
3484 }
3485 
3486 /*!
3487   \overload replace()
3488   Replaces every occurrence of the character \a before with the
3489   character \a after and returns a reference to this string.
3490 
3491   If \a cs is Qt::CaseSensitive (default), the search is case
3492   sensitive; otherwise the search is case insensitive.
3493 */
3494 QString& QString::replace(QChar before, QChar after, Qt::CaseSensitivity cs)
3495 {
3496     if (d.size) {
3497         const qsizetype idx = indexOf(before, 0, cs);
3498         if (idx != -1) {
3499             detach();
3500             const char16_t a = after.unicode();
3501             char16_t *i = d.data();
3502             char16_t *const e = i + d.size;
3503             i += idx;
3504             *i = a;
3505             if (cs == Qt::CaseSensitive) {
3506                 const char16_t b = before.unicode();
3507                 while (++i != e) {
3508                     if (*i == b)
3509                         *i = a;
3510                 }
3511             } else {
3512                 const char16_t b = foldCase(before.unicode());
3513                 while (++i != e) {
3514                     if (foldCase(*i) == b)
3515                         *i = a;
3516                 }
3517             }
3518         }
3519     }
3520     return *this;
3521 }
3522 
3523 /*!
3524   \since 4.5
3525   \overload replace()
3526 
3527   Replaces every occurrence of the string \a before with the string \a
3528   after and returns a reference to this string.
3529 
3530   If \a cs is Qt::CaseSensitive (default), the search is case
3531   sensitive; otherwise the search is case insensitive.
3532 
3533   \note The text is not rescanned after a replacement.
3534 */
3535 QString &QString::replace(QLatin1String before, QLatin1String after, Qt::CaseSensitivity cs)
3536 {
3537     qsizetype alen = after.size();
3538     qsizetype blen = before.size();
3539     QVarLengthArray<char16_t> a(alen);
3540     QVarLengthArray<char16_t> b(blen);
3541     qt_from_latin1(a.data(), after.latin1(), alen);
3542     qt_from_latin1(b.data(), before.latin1(), blen);
3543     return replace((const QChar *)b.data(), blen, (const QChar *)a.data(), alen, cs);
3544 }
3545 
3546 /*!
3547   \since 4.5
3548   \overload replace()
3549 
3550   Replaces every occurrence of the string \a before with the string \a
3551   after and returns a reference to this string.
3552 
3553   If \a cs is Qt::CaseSensitive (default), the search is case
3554   sensitive; otherwise the search is case insensitive.
3555 
3556   \note The text is not rescanned after a replacement.
3557 */
3558 QString &QString::replace(QLatin1String before, const QString &after, Qt::CaseSensitivity cs)
3559 {
3560     qsizetype blen = before.size();
3561     QVarLengthArray<char16_t> b(blen);
3562     qt_from_latin1(b.data(), before.latin1(), blen);
3563     return replace((const QChar *)b.data(), blen, after.constData(), after.d.size, cs);
3564 }
3565 
3566 /*!
3567   \since 4.5
3568   \overload replace()
3569 
3570   Replaces every occurrence of the string \a before with the string \a
3571   after and returns a reference to this string.
3572 
3573   If \a cs is Qt::CaseSensitive (default), the search is case
3574   sensitive; otherwise the search is case insensitive.
3575 
3576   \note The text is not rescanned after a replacement.
3577 */
3578 QString &QString::replace(const QString &before, QLatin1String after, Qt::CaseSensitivity cs)
3579 {
3580     qsizetype alen = after.size();
3581     QVarLengthArray<char16_t> a(alen);
3582     qt_from_latin1(a.data(), after.latin1(), alen);
3583     return replace(before.constData(), before.d.size, (const QChar *)a.data(), alen, cs);
3584 }
3585 
3586 /*!
3587   \since 4.5
3588   \overload replace()
3589 
3590   Replaces every occurrence of the character \a c with the string \a
3591   after and returns a reference to this string.
3592 
3593   If \a cs is Qt::CaseSensitive (default), the search is case
3594   sensitive; otherwise the search is case insensitive.
3595 
3596   \note The text is not rescanned after a replacement.
3597 */
3598 QString &QString::replace(QChar c, QLatin1String after, Qt::CaseSensitivity cs)
3599 {
3600     qsizetype alen = after.size();
3601     QVarLengthArray<char16_t> a(alen);
3602     qt_from_latin1(a.data(), after.latin1(), alen);
3603     return replace(&c, 1, (const QChar *)a.data(), alen, cs);
3604 }
3605 
3606 
3607 /*!
3608     \fn bool QString::operator==(const QString &s1, const QString &s2)
3609     \overload operator==()
3610 
3611     Returns \c true if string \a s1 is equal to string \a s2; otherwise
3612     returns \c false.
3613 
3614     \sa {Comparing Strings}
3615 */
3616 
3617 /*!
3618     \fn bool QString::operator==(const QString &s1, QLatin1String s2)
3619 
3620     \overload operator==()
3621 
3622     Returns \c true if \a s1 is equal to \a s2; otherwise
3623     returns \c false.
3624 */
3625 
3626 /*!
3627     \fn bool QString::operator==(QLatin1String s1, const QString &s2)
3628 
3629     \overload operator==()
3630 
3631     Returns \c true if \a s1 is equal to \a s2; otherwise
3632     returns \c false.
3633 */
3634 
3635 /*! \fn bool QString::operator==(const QByteArray &other) const
3636 
3637     \overload operator==()
3638 
3639     The \a other byte array is converted to a QString using the
3640     fromUtf8() function. This function stops conversion at the
3641     first NUL character found, or the end of the byte array.
3642 
3643     You can disable this operator by defining
3644     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3645     can be useful if you want to ensure that all user-visible strings
3646     go through QObject::tr(), for example.
3647 
3648     Returns \c true if this string is lexically equal to the parameter
3649     string \a other. Otherwise returns \c false.
3650 */
3651 
3652 /*! \fn bool QString::operator==(const char *other) const
3653 
3654     \overload operator==()
3655 
3656     The \a other const char pointer is converted to a QString using
3657     the fromUtf8() function.
3658 
3659     You can disable this operator by defining
3660     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3661     can be useful if you want to ensure that all user-visible strings
3662     go through QObject::tr(), for example.
3663 */
3664 
3665 /*!
3666     \fn bool QString::operator<(const QString &s1, const QString &s2)
3667 
3668     \overload operator<()
3669 
3670     Returns \c true if string \a s1 is lexically less than string
3671     \a s2; otherwise returns \c false.
3672 
3673     \sa {Comparing Strings}
3674 */
3675 
3676 /*!
3677     \fn bool QString::operator<(const QString &s1, QLatin1String s2)
3678 
3679     \overload operator<()
3680 
3681     Returns \c true if \a s1 is lexically less than \a s2;
3682     otherwise returns \c false.
3683 */
3684 
3685 /*!
3686     \fn bool QString::operator<(QLatin1String s1, const QString &s2)
3687 
3688     \overload operator<()
3689 
3690     Returns \c true if \a s1 is lexically less than \a s2;
3691     otherwise returns \c false.
3692 */
3693 
3694 /*! \fn bool QString::operator<(const QByteArray &other) const
3695 
3696     \overload operator<()
3697 
3698     The \a other byte array is converted to a QString using the
3699     fromUtf8() function. If any NUL characters ('\\0') are embedded
3700     in the byte array, they will be included in the transformation.
3701 
3702     You can disable this operator
3703     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3704     can be useful if you want to ensure that all user-visible strings
3705     go through QObject::tr(), for example.
3706 */
3707 
3708 /*! \fn bool QString::operator<(const char *other) const
3709 
3710     Returns \c true if this string is lexically less than string \a other.
3711     Otherwise returns \c false.
3712 
3713     \overload operator<()
3714 
3715     The \a other const char pointer is converted to a QString using
3716     the fromUtf8() function.
3717 
3718     You can disable this operator by defining
3719     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3720     can be useful if you want to ensure that all user-visible strings
3721     go through QObject::tr(), for example.
3722 */
3723 
3724 /*! \fn bool QString::operator<=(const QString &s1, const QString &s2)
3725 
3726     Returns \c true if string \a s1 is lexically less than or equal to
3727     string \a s2; otherwise returns \c false.
3728 
3729     \sa {Comparing Strings}
3730 */
3731 
3732 /*!
3733     \fn bool QString::operator<=(const QString &s1, QLatin1String s2)
3734 
3735     \overload operator<=()
3736 
3737     Returns \c true if \a s1 is lexically less than or equal to \a s2;
3738     otherwise returns \c false.
3739 */
3740 
3741 /*!
3742     \fn bool QString::operator<=(QLatin1String s1, const QString &s2)
3743 
3744     \overload operator<=()
3745 
3746     Returns \c true if \a s1 is lexically less than or equal to \a s2;
3747     otherwise returns \c false.
3748 */
3749 
3750 /*! \fn bool QString::operator<=(const QByteArray &other) const
3751 
3752     \overload operator<=()
3753 
3754     The \a other byte array is converted to a QString using the
3755     fromUtf8() function. If any NUL characters ('\\0') are embedded
3756     in the byte array, they will be included in the transformation.
3757 
3758     You can disable this operator by defining
3759     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3760     can be useful if you want to ensure that all user-visible strings
3761     go through QObject::tr(), for example.
3762 */
3763 
3764 /*! \fn bool QString::operator<=(const char *other) const
3765 
3766     \overload operator<=()
3767 
3768     The \a other const char pointer is converted to a QString using
3769     the fromUtf8() function.
3770 
3771     You can disable this operator by defining
3772     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3773     can be useful if you want to ensure that all user-visible strings
3774     go through QObject::tr(), for example.
3775 */
3776 
3777 /*! \fn bool QString::operator>(const QString &s1, const QString &s2)
3778 
3779     Returns \c true if string \a s1 is lexically greater than string \a s2;
3780     otherwise returns \c false.
3781 
3782     \sa {Comparing Strings}
3783 */
3784 
3785 /*!
3786     \fn bool QString::operator>(const QString &s1, QLatin1String s2)
3787 
3788     \overload operator>()
3789 
3790     Returns \c true if \a s1 is lexically greater than \a s2;
3791     otherwise returns \c false.
3792 */
3793 
3794 /*!
3795     \fn bool QString::operator>(QLatin1String s1, const QString &s2)
3796 
3797     \overload operator>()
3798 
3799     Returns \c true if \a s1 is lexically greater than \a s2;
3800     otherwise returns \c false.
3801 */
3802 
3803 /*! \fn bool QString::operator>(const QByteArray &other) const
3804 
3805     \overload operator>()
3806 
3807     The \a other byte array is converted to a QString using the
3808     fromUtf8() function. If any NUL characters ('\\0') are embedded
3809     in the byte array, they will be included in the transformation.
3810 
3811     You can disable this operator by defining
3812     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3813     can be useful if you want to ensure that all user-visible strings
3814     go through QObject::tr(), for example.
3815 */
3816 
3817 /*! \fn bool QString::operator>(const char *other) const
3818 
3819     \overload operator>()
3820 
3821     The \a other const char pointer is converted to a QString using
3822     the fromUtf8() function.
3823 
3824     You can disable this operator by defining \l QT_NO_CAST_FROM_ASCII
3825     when you compile your applications. This can be useful if you want
3826     to ensure that all user-visible strings go through QObject::tr(),
3827     for example.
3828 */
3829 
3830 /*! \fn bool QString::operator>=(const QString &s1, const QString &s2)
3831 
3832     Returns \c true if string \a s1 is lexically greater than or equal to
3833     string \a s2; otherwise returns \c false.
3834 
3835     \sa {Comparing Strings}
3836 */
3837 
3838 /*!
3839     \fn bool QString::operator>=(const QString &s1, QLatin1String s2)
3840 
3841     \overload operator>=()
3842 
3843     Returns \c true if \a s1 is lexically greater than or equal to \a s2;
3844     otherwise returns \c false.
3845 */
3846 
3847 /*!
3848     \fn bool QString::operator>=(QLatin1String s1, const QString &s2)
3849 
3850     \overload operator>=()
3851 
3852     Returns \c true if \a s1 is lexically greater than or equal to \a s2;
3853     otherwise returns \c false.
3854 */
3855 
3856 /*! \fn bool QString::operator>=(const QByteArray &other) const
3857 
3858     \overload operator>=()
3859 
3860     The \a other byte array is converted to a QString using the
3861     fromUtf8() function. If any NUL characters ('\\0') are embedded in
3862     the byte array, they will be included in the transformation.
3863 
3864     You can disable this operator by defining \l QT_NO_CAST_FROM_ASCII
3865     when you compile your applications. This can be useful if you want
3866     to ensure that all user-visible strings go through QObject::tr(),
3867     for example.
3868 */
3869 
3870 /*! \fn bool QString::operator>=(const char *other) const
3871 
3872     \overload operator>=()
3873 
3874     The \a other const char pointer is converted to a QString using
3875     the fromUtf8() function.
3876 
3877     You can disable this operator by defining \l QT_NO_CAST_FROM_ASCII
3878     when you compile your applications. This can be useful if you want
3879     to ensure that all user-visible strings go through QObject::tr(),
3880     for example.
3881 */
3882 
3883 /*! \fn bool QString::operator!=(const QString &s1, const QString &s2)
3884 
3885     Returns \c true if string \a s1 is not equal to string \a s2;
3886     otherwise returns \c false.
3887 
3888     \sa {Comparing Strings}
3889 */
3890 
3891 /*! \fn bool QString::operator!=(const QString &s1, QLatin1String s2)
3892 
3893     Returns \c true if string \a s1 is not equal to string \a s2.
3894     Otherwise returns \c false.
3895 
3896     \overload operator!=()
3897 */
3898 
3899 /*! \fn bool QString::operator!=(const QByteArray &other) const
3900 
3901     \overload operator!=()
3902 
3903     The \a other byte array is converted to a QString using the
3904     fromUtf8() function. If any NUL characters ('\\0') are embedded
3905     in the byte array, they will be included in the transformation.
3906 
3907     You can disable this operator by defining \l QT_NO_CAST_FROM_ASCII
3908     when you compile your applications. This can be useful if you want
3909     to ensure that all user-visible strings go through QObject::tr(),
3910     for example.
3911 */
3912 
3913 /*! \fn bool QString::operator!=(const char *other) const
3914 
3915     \overload operator!=()
3916 
3917     The \a other const char pointer is converted to a QString using
3918     the fromUtf8() function.
3919 
3920     You can disable this operator by defining
3921     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
3922     can be useful if you want to ensure that all user-visible strings
3923     go through QObject::tr(), for example.
3924 */
3925 
3926 #if QT_STRINGVIEW_LEVEL < 2
3927 /*!
3928   Returns the index position of the first occurrence of the string \a
3929   str in this string, searching forward from index position \a
3930   from. Returns -1 if \a str is not found.
3931 
3932   If \a cs is Qt::CaseSensitive (default), the search is case
3933   sensitive; otherwise the search is case insensitive.
3934 
3935   Example:
3936 
3937   \snippet qstring/main.cpp 24
3938 
3939   If \a from is -1, the search starts at the last character; if it is
3940   -2, at the next to last character and so on.
3941 
3942   \sa lastIndexOf(), contains(), count()
3943 */
3944 qsizetype QString::indexOf(const QString &str, qsizetype from, Qt::CaseSensitivity cs) const
3945 {
3946     return QtPrivate::findString(QStringView(unicode(), length()), from, QStringView(str.unicode(), str.length()), cs);
3947 }
3948 #endif  // QT_STRINGVIEW_LEVEL < 2
3949 
3950 /*!
3951     \fn qsizetype QString::indexOf(QStringView str, qsizetype from, Qt::CaseSensitivity cs) const
3952     \since 5.14
3953     \overload indexOf()
3954 
3955     Returns the index position of the first occurrence of the string view \a str
3956     in this string, searching forward from index position \a from.
3957     Returns -1 if \a str is not found.
3958 
3959     If \a cs is Qt::CaseSensitive (default), the search is case
3960     sensitive; otherwise the search is case insensitive.
3961 
3962     If \a from is -1, the search starts at the last character; if it is
3963     -2, at the next to last character and so on.
3964 
3965     \sa QStringView::indexOf(), lastIndexOf(), contains(), count()
3966 */
3967 
3968 /*!
3969   \since 4.5
3970   Returns the index position of the first occurrence of the string \a
3971   str in this string, searching forward from index position \a
3972   from. Returns -1 if \a str is not found.
3973 
3974   If \a cs is Qt::CaseSensitive (default), the search is case
3975   sensitive; otherwise the search is case insensitive.
3976 
3977   Example:
3978 
3979   \snippet qstring/main.cpp 24
3980 
3981   If \a from is -1, the search starts at the last character; if it is
3982   -2, at the next to last character and so on.
3983 
3984   \sa lastIndexOf(), contains(), count()
3985 */
3986 
3987 qsizetype QString::indexOf(QLatin1String str, qsizetype from, Qt::CaseSensitivity cs) const
3988 {
3989     return QtPrivate::findString(QStringView(unicode(), size()), from, str, cs);
3990 }
3991 
3992 /*!
3993     \overload indexOf()
3994 
3995     Returns the index position of the first occurrence of the
3996     character \a ch in the string, searching forward from index
3997     position \a from. Returns -1 if \a ch could not be found.
3998 */
3999 qsizetype QString::indexOf(QChar ch, qsizetype from, Qt::CaseSensitivity cs) const
4000 {
4001     return qFindChar(QStringView(unicode(), length()), ch, from, cs);
4002 }
4003 
4004 #if QT_STRINGVIEW_LEVEL < 2
4005 /*!
4006   Returns the index position of the last occurrence of the string \a
4007   str in this string, searching backward from index position \a
4008   from. If \a from is -1 (default), the search starts at the last
4009   character; if \a from is -2, at the next to last character and so
4010   on. Returns -1 if \a str is not found.
4011 
4012   If \a cs is Qt::CaseSensitive (default), the search is case
4013   sensitive; otherwise the search is case insensitive.
4014 
4015   Example:
4016 
4017   \snippet qstring/main.cpp 29
4018 
4019   \sa indexOf(), contains(), count()
4020 */
4021 qsizetype QString::lastIndexOf(const QString &str, qsizetype from, Qt::CaseSensitivity cs) const
4022 {
4023     return QtPrivate::lastIndexOf(QStringView(*this), from, str, cs);
4024 }
4025 
4026 #endif // QT_STRINGVIEW_LEVEL < 2
4027 
4028 /*!
4029   \since 4.5
4030   \overload lastIndexOf()
4031 
4032   Returns the index position of the last occurrence of the string \a
4033   str in this string, searching backward from index position \a
4034   from. If \a from is -1 (default), the search starts at the last
4035   character; if \a from is -2, at the next to last character and so
4036   on. Returns -1 if \a str is not found.
4037 
4038   If \a cs is Qt::CaseSensitive (default), the search is case
4039   sensitive; otherwise the search is case insensitive.
4040 
4041   Example:
4042 
4043   \snippet qstring/main.cpp 29
4044 
4045   \sa indexOf(), contains(), count()
4046 */
4047 qsizetype QString::lastIndexOf(QLatin1String str, qsizetype from, Qt::CaseSensitivity cs) const
4048 {
4049     return QtPrivate::lastIndexOf(*this, from, str, cs);
4050 }
4051 
4052 /*!
4053   \overload lastIndexOf()
4054 
4055   Returns the index position of the last occurrence of the character
4056   \a ch, searching backward from position \a from.
4057 */
4058 qsizetype QString::lastIndexOf(QChar ch, qsizetype from, Qt::CaseSensitivity cs) const
4059 {
4060     return qLastIndexOf(QStringView(*this), ch, from, cs);
4061 }
4062 
4063 /*!
4064   \fn qsizetype QString::lastIndexOf(QStringView str, qsizetype from, Qt::CaseSensitivity cs) const
4065   \since 5.14
4066   \overload lastIndexOf()
4067 
4068   Returns the index position of the last occurrence of the string view \a
4069   str in this string, searching backward from index position \a
4070   from. If \a from is -1 (default), the search starts at the last
4071   character; if \a from is -2, at the next to last character and so
4072   on. Returns -1 if \a str is not found.
4073 
4074   If \a cs is Qt::CaseSensitive (default), the search is case
4075   sensitive; otherwise the search is case insensitive.
4076 
4077   \sa indexOf(), contains(), count()
4078 */
4079 
4080 
4081 #if QT_CONFIG(regularexpression)
4082 struct QStringCapture
4083 {
4084     qsizetype pos;
4085     qsizetype len;
4086     int no;
4087 };
4088 Q_DECLARE_TYPEINFO(QStringCapture, Q_PRIMITIVE_TYPE);
4089 
4090 /*!
4091   \overload replace()
4092   \since 5.0
4093 
4094   Replaces every occurrence of the regular expression \a re in the
4095   string with \a after. Returns a reference to the string. For
4096   example:
4097 
4098   \snippet qstring/main.cpp 87
4099 
4100   For regular expressions containing capturing groups,
4101   occurrences of \b{\\1}, \b{\\2}, ..., in \a after are replaced
4102   with the string captured by the corresponding capturing group.
4103 
4104   \snippet qstring/main.cpp 88
4105 
4106   \sa indexOf(), lastIndexOf(), remove(), QRegularExpression, QRegularExpressionMatch
4107 */
4108 QString &QString::replace(const QRegularExpression &re, const QString &after)
4109 {
4110     if (!re.isValid()) {
4111         qWarning("QString::replace: invalid QRegularExpression object");
4112         return *this;
4113     }
4114 
4115     const QString copy(*this);
4116     QRegularExpressionMatchIterator iterator = re.globalMatch(copy);
4117     if (!iterator.hasNext()) // no matches at all
4118         return *this;
4119 
4120     reallocData(d.size, QArrayData::KeepSize);
4121 
4122     qsizetype numCaptures = re.captureCount();
4123 
4124     // 1. build the backreferences list, holding where the backreferences
4125     // are in the replacement string
4126     QList<QStringCapture> backReferences;
4127     const qsizetype al = after.length();
4128     const QChar *ac = after.unicode();
4129 
4130     for (qsizetype i = 0; i < al - 1; i++) {
4131         if (ac[i] == QLatin1Char('\\')) {
4132             int no = ac[i + 1].digitValue();
4133             if (no > 0 && no <= numCaptures) {
4134                 QStringCapture backReference;
4135                 backReference.pos = i;
4136                 backReference.len = 2;
4137 
4138                 if (i < al - 2) {
4139                     int secondDigit = ac[i + 2].digitValue();
4140                     if (secondDigit != -1 && ((no * 10) + secondDigit) <= numCaptures) {
4141                         no = (no * 10) + secondDigit;
4142                         ++backReference.len;
4143                     }
4144                 }
4145 
4146                 backReference.no = no;
4147                 backReferences.append(backReference);
4148             }
4149         }
4150     }
4151 
4152     // 2. iterate on the matches. For every match, copy in chunks
4153     // - the part before the match
4154     // - the after string, with the proper replacements for the backreferences
4155 
4156     qsizetype newLength = 0; // length of the new string, with all the replacements
4157     qsizetype lastEnd = 0;
4158     QList<QStringView> chunks;
4159     const QStringView copyView{ copy }, afterView{ after };
4160     while (iterator.hasNext()) {
4161         QRegularExpressionMatch match = iterator.next();
4162         qsizetype len;
4163         // add the part before the match
4164         len = match.capturedStart() - lastEnd;
4165         if (len > 0) {
4166             chunks << copyView.mid(lastEnd, len);
4167             newLength += len;
4168         }
4169 
4170         lastEnd = 0;
4171         // add the after string, with replacements for the backreferences
4172         for (const QStringCapture &backReference : qAsConst(backReferences)) {
4173             // part of "after" before the backreference
4174             len = backReference.pos - lastEnd;
4175             if (len > 0) {
4176                 chunks << afterView.mid(lastEnd, len);
4177                 newLength += len;
4178             }
4179 
4180             // backreference itself
4181             len = match.capturedLength(backReference.no);
4182             if (len > 0) {
4183                 chunks << copyView.mid(match.capturedStart(backReference.no), len);
4184                 newLength += len;
4185             }
4186 
4187             lastEnd = backReference.pos + backReference.len;
4188         }
4189 
4190         // add the last part of the after string
4191         len = afterView.length() - lastEnd;
4192         if (len > 0) {
4193             chunks << afterView.mid(lastEnd, len);
4194             newLength += len;
4195         }
4196 
4197         lastEnd = match.capturedEnd();
4198     }
4199 
4200     // 3. trailing string after the last match
4201     if (copyView.length() > lastEnd) {
4202         chunks << copyView.mid(lastEnd);
4203         newLength += copyView.length() - lastEnd;
4204     }
4205 
4206     // 4. assemble the chunks together
4207     resize(newLength);
4208     qsizetype i = 0;
4209     QChar *uc = data();
4210     for (const QStringView &chunk : qAsConst(chunks)) {
4211         qsizetype len = chunk.length();
4212         memcpy(uc + i, chunk.constData(), len * sizeof(QChar));
4213         i += len;
4214     }
4215 
4216     return *this;
4217 }
4218 #endif // QT_CONFIG(regularexpression)
4219 
4220 /*!
4221     Returns the number of (potentially overlapping) occurrences of
4222     the string \a str in this string.
4223 
4224     If \a cs is Qt::CaseSensitive (default), the search is
4225     case sensitive; otherwise the search is case insensitive.
4226 
4227     \sa contains(), indexOf()
4228 */
4229 
4230 qsizetype QString::count(const QString &str, Qt::CaseSensitivity cs) const
4231 {
4232     return QtPrivate::count(QStringView(unicode(), size()), QStringView(str.unicode(), str.size()), cs);
4233 }
4234 
4235 /*!
4236     \overload count()
4237 
4238     Returns the number of occurrences of character \a ch in the string.
4239 
4240     If \a cs is Qt::CaseSensitive (default), the search is
4241     case sensitive; otherwise the search is case insensitive.
4242 
4243     \sa contains(), indexOf()
4244 */
4245 
4246 qsizetype QString::count(QChar ch, Qt::CaseSensitivity cs) const
4247 {
4248     return QtPrivate::count(QStringView(unicode(), size()), ch, cs);
4249 }
4250 
4251 /*!
4252     \since 6.0
4253     \overload count()
4254     Returns the number of (potentially overlapping) occurrences of the
4255     string view \a str in this string.
4256 
4257     If \a cs is Qt::CaseSensitive (default), the search is
4258     case sensitive; otherwise the search is case insensitive.
4259 
4260     \sa contains(), indexOf()
4261 */
4262 qsizetype QString::count(QStringView str, Qt::CaseSensitivity cs) const
4263 {
4264     return QtPrivate::count(*this, str, cs);
4265 }
4266 
4267 #if QT_STRINGVIEW_LEVEL < 2
4268 /*! \fn bool QString::contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4269 
4270     Returns \c true if this string contains an occurrence of the string
4271     \a str; otherwise returns \c false.
4272 
4273     If \a cs is Qt::CaseSensitive (default), the search is
4274     case sensitive; otherwise the search is case insensitive.
4275 
4276     Example:
4277     \snippet qstring/main.cpp 17
4278 
4279     \sa indexOf(), count()
4280 */
4281 #endif // QT_STRINGVIEW_LEVEL < 2
4282 
4283 /*! \fn bool QString::contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4284     \since 5.3
4285 
4286     \overload contains()
4287 
4288     Returns \c true if this string contains an occurrence of the latin-1 string
4289     \a str; otherwise returns \c false.
4290 */
4291 
4292 /*! \fn bool QString::contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4293 
4294     \overload contains()
4295 
4296     Returns \c true if this string contains an occurrence of the
4297     character \a ch; otherwise returns \c false.
4298 */
4299 
4300 /*! \fn bool QString::contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4301     \since 5.14
4302     \overload contains()
4303 
4304     Returns \c true if this string contains an occurrence of the string view
4305     \a str; otherwise returns \c false.
4306 
4307     If \a cs is Qt::CaseSensitive (default), the search is
4308     case sensitive; otherwise the search is case insensitive.
4309 
4310     \sa indexOf(), count()
4311 */
4312 
4313 #if QT_CONFIG(regularexpression)
4314 /*!
4315     \since 5.5
4316 
4317     Returns the index position of the first match of the regular
4318     expression \a re in the string, searching forward from index
4319     position \a from. Returns -1 if \a re didn't match anywhere.
4320 
4321     If the match is successful and \a rmatch is not \nullptr, it also
4322     writes the results of the match into the QRegularExpressionMatch object
4323     pointed to by \a rmatch.
4324 
4325     Example:
4326 
4327     \snippet qstring/main.cpp 93
4328 */
4329 qsizetype QString::indexOf(const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch) const
4330 {
4331     if (!re.isValid()) {
4332         qWarning("QString::indexOf: invalid QRegularExpression object");
4333         return -1;
4334     }
4335 
4336     QRegularExpressionMatch match = re.match(*this, from);
4337     if (match.hasMatch()) {
4338         const qsizetype ret = match.capturedStart();
4339         if (rmatch)
4340             *rmatch = std::move(match);
4341         return ret;
4342     }
4343 
4344     return -1;
4345 }
4346 
4347 /*!
4348     \since 5.5
4349 
4350     Returns the index position of the last match of the regular
4351     expression \a re in the string, which starts before the index
4352     position \a from. Returns -1 if \a re didn't match anywhere.
4353 
4354     If the match is successful and \a rmatch is not \nullptr, it also
4355     writes the results of the match into the QRegularExpressionMatch object
4356     pointed to by \a rmatch.
4357 
4358     Example:
4359 
4360     \snippet qstring/main.cpp 94
4361 
4362     \note Due to how the regular expression matching algorithm works,
4363     this function will actually match repeatedly from the beginning of
4364     the string until the position \a from is reached.
4365 */
4366 qsizetype QString::lastIndexOf(const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch) const
4367 {
4368     if (!re.isValid()) {
4369         qWarning("QString::lastIndexOf: invalid QRegularExpression object");
4370         return -1;
4371     }
4372 
4373     qsizetype endpos = (from < 0) ? (size() + from + 1) : (from);
4374     QRegularExpressionMatchIterator iterator = re.globalMatch(*this);
4375     qsizetype lastIndex = -1;
4376     while (iterator.hasNext()) {
4377         QRegularExpressionMatch match = iterator.next();
4378         qsizetype start = match.capturedStart();
4379         if (start <= endpos) {
4380             lastIndex = start;
4381             if (rmatch)
4382                 *rmatch = std::move(match);
4383         } else {
4384             break;
4385         }
4386     }
4387 
4388     return lastIndex;
4389 }
4390 
4391 /*!
4392     \since 5.1
4393 
4394     Returns \c true if the regular expression \a re matches somewhere in this
4395     string; otherwise returns \c false.
4396 
4397     If the match is successful and \a rmatch is not \nullptr, it also
4398     writes the results of the match into the QRegularExpressionMatch object
4399     pointed to by \a rmatch.
4400 
4401     \sa QRegularExpression::match()
4402 */
4403 
4404 bool QString::contains(const QRegularExpression &re, QRegularExpressionMatch *rmatch) const
4405 {
4406     if (!re.isValid()) {
4407         qWarning("QString::contains: invalid QRegularExpression object");
4408         return false;
4409     }
4410     QRegularExpressionMatch m = re.match(*this);
4411     bool hasMatch = m.hasMatch();
4412     if (hasMatch && rmatch)
4413         *rmatch = std::move(m);
4414     return hasMatch;
4415 }
4416 
4417 /*!
4418     \overload count()
4419     \since 5.0
4420 
4421     Returns the number of times the regular expression \a re matches
4422     in the string.
4423 
4424     For historical reasons, this function counts overlapping matches,
4425     so in the example below, there are four instances of "ana" or
4426     "ama":
4427 
4428     \snippet qstring/main.cpp 95
4429 
4430     This behavior is different from simply iterating over the matches
4431     in the string using QRegularExpressionMatchIterator.
4432 
4433     \sa QRegularExpression::globalMatch()
4434 */
4435 qsizetype QString::count(const QRegularExpression &re) const
4436 {
4437     if (!re.isValid()) {
4438         qWarning("QString::count: invalid QRegularExpression object");
4439         return 0;
4440     }
4441     qsizetype count = 0;
4442     qsizetype index = -1;
4443     qsizetype len = length();
4444     while (index <= len - 1) {
4445         QRegularExpressionMatch match = re.match(*this, index + 1);
4446         if (!match.hasMatch())
4447             break;
4448         index = match.capturedStart();
4449         count++;
4450     }
4451     return count;
4452 }
4453 #endif // QT_CONFIG(regularexpression)
4454 
4455 /*! \fn qsizetype QString::count() const
4456 
4457     \overload count()
4458 
4459     Same as size().
4460 */
4461 
4462 
4463 /*!
4464     \enum QString::SectionFlag
4465 
4466     This enum specifies flags that can be used to affect various
4467     aspects of the section() function's behavior with respect to
4468     separators and empty fields.
4469 
4470     \value SectionDefault Empty fields are counted, leading and
4471     trailing separators are not included, and the separator is
4472     compared case sensitively.
4473 
4474     \value SectionSkipEmpty Treat empty fields as if they don't exist,
4475     i.e. they are not considered as far as \e start and \e end are
4476     concerned.
4477 
4478     \value SectionIncludeLeadingSep Include the leading separator (if
4479     any) in the result string.
4480 
4481     \value SectionIncludeTrailingSep Include the trailing separator
4482     (if any) in the result string.
4483 
4484     \value SectionCaseInsensitiveSeps Compare the separator
4485     case-insensitively.
4486 
4487     \sa section()
4488 */
4489 
4490 /*!
4491     \fn QString QString::section(QChar sep, qsizetype start, qsizetype end = -1, SectionFlags flags) const
4492 
4493     This function returns a section of the string.
4494 
4495     This string is treated as a sequence of fields separated by the
4496     character, \a sep. The returned string consists of the fields from
4497     position \a start to position \a end inclusive. If \a end is not
4498     specified, all fields from position \a start to the end of the
4499     string are included. Fields are numbered 0, 1, 2, etc., counting
4500     from the left, and -1, -2, etc., counting from right to left.
4501 
4502     The \a flags argument can be used to affect some aspects of the
4503     function's behavior, e.g. whether to be case sensitive, whether
4504     to skip empty fields and how to deal with leading and trailing
4505     separators; see \l{SectionFlags}.
4506 
4507     \snippet qstring/main.cpp 52
4508 
4509     If \a start or \a end is negative, we count fields from the right
4510     of the string, the right-most field being -1, the one from
4511     right-most field being -2, and so on.
4512 
4513     \snippet qstring/main.cpp 53
4514 
4515     \sa split()
4516 */
4517 
4518 /*!
4519     \overload section()
4520 
4521     \snippet qstring/main.cpp 51
4522     \snippet qstring/main.cpp 54
4523 
4524     \sa split()
4525 */
4526 
4527 QString QString::section(const QString &sep, qsizetype start, qsizetype end, SectionFlags flags) const
4528 {
4529     const QList<QStringView> sections = QStringView{ *this }.split(
4530             sep, Qt::KeepEmptyParts, (flags & SectionCaseInsensitiveSeps) ? Qt::CaseInsensitive : Qt::CaseSensitive);
4531     const qsizetype sectionsSize = sections.size();
4532     if (!(flags & SectionSkipEmpty)) {
4533         if (start < 0)
4534             start += sectionsSize;
4535         if (end < 0)
4536             end += sectionsSize;
4537     } else {
4538         qsizetype skip = 0;
4539         for (qsizetype k = 0; k < sectionsSize; ++k) {
4540             if (sections.at(k).isEmpty())
4541                 skip++;
4542         }
4543         if (start < 0)
4544             start += sectionsSize - skip;
4545         if (end < 0)
4546             end += sectionsSize - skip;
4547     }
4548     if (start >= sectionsSize || end < 0 || start > end)
4549         return QString();
4550 
4551     QString ret;
4552     qsizetype first_i = start, last_i = end;
4553     for (qsizetype x = 0, i = 0; x <= end && i < sectionsSize; ++i) {
4554         const QStringView &section = sections.at(i);
4555         const bool empty = section.isEmpty();
4556         if (x >= start) {
4557             if (x == start)
4558                 first_i = i;
4559             if (x == end)
4560                 last_i = i;
4561             if (x > start && i > 0)
4562                 ret += sep;
4563             ret += section;
4564         }
4565         if (!empty || !(flags & SectionSkipEmpty))
4566             x++;
4567     }
4568     if ((flags & SectionIncludeLeadingSep) && first_i > 0)
4569         ret.prepend(sep);
4570     if ((flags & SectionIncludeTrailingSep) && last_i < sectionsSize - 1)
4571         ret += sep;
4572     return ret;
4573 }
4574 
4575 #if QT_CONFIG(regularexpression)
4576 class qt_section_chunk {
4577 public:
4578     qt_section_chunk() {}
4579     qt_section_chunk(qsizetype l, QStringView s) : length(l), string(std::move(s)) {}
4580     qsizetype length;
4581     QStringView string;
4582 };
4583 Q_DECLARE_TYPEINFO(qt_section_chunk, Q_RELOCATABLE_TYPE);
4584 
4585 static QString extractSections(const QList<qt_section_chunk> &sections, qsizetype start, qsizetype end,
4586                                QString::SectionFlags flags)
4587 {
4588     const qsizetype sectionsSize = sections.size();
4589 
4590     if (!(flags & QString::SectionSkipEmpty)) {
4591         if (start < 0)
4592             start += sectionsSize;
4593         if (end < 0)
4594             end += sectionsSize;
4595     } else {
4596         qsizetype skip = 0;
4597         for (qsizetype k = 0; k < sectionsSize; ++k) {
4598             const qt_section_chunk &section = sections.at(k);
4599             if (section.length == section.string.length())
4600                 skip++;
4601         }
4602         if (start < 0)
4603             start += sectionsSize - skip;
4604         if (end < 0)
4605             end += sectionsSize - skip;
4606     }
4607     if (start >= sectionsSize || end < 0 || start > end)
4608         return QString();
4609 
4610     QString ret;
4611     qsizetype x = 0;
4612     qsizetype first_i = start, last_i = end;
4613     for (qsizetype i = 0; x <= end && i < sectionsSize; ++i) {
4614         const qt_section_chunk &section = sections.at(i);
4615         const bool empty = (section.length == section.string.length());
4616         if (x >= start) {
4617             if (x == start)
4618                 first_i = i;
4619             if (x == end)
4620                 last_i = i;
4621             if (x != start)
4622                 ret += section.string;
4623             else
4624                 ret += section.string.mid(section.length);
4625         }
4626         if (!empty || !(flags & QString::SectionSkipEmpty))
4627             x++;
4628     }
4629 
4630     if ((flags & QString::SectionIncludeLeadingSep) && first_i >= 0) {
4631         const qt_section_chunk &section = sections.at(first_i);
4632         ret.prepend(section.string.left(section.length));
4633     }
4634 
4635     if ((flags & QString::SectionIncludeTrailingSep)
4636         && last_i < sectionsSize - 1) {
4637         const qt_section_chunk &section = sections.at(last_i+1);
4638         ret += section.string.left(section.length);
4639     }
4640 
4641     return ret;
4642 }
4643 
4644 /*!
4645     \overload section()
4646     \since 5.0
4647 
4648     This string is treated as a sequence of fields separated by the
4649     regular expression, \a re.
4650 
4651     \snippet qstring/main.cpp 89
4652 
4653     \warning Using this QRegularExpression version is much more expensive than
4654     the overloaded string and character versions.
4655 
4656     \sa split(), simplified()
4657 */
4658 QString QString::section(const QRegularExpression &re, qsizetype start, qsizetype end, SectionFlags flags) const
4659 {
4660     if (!re.isValid()) {
4661         qWarning("QString::section: invalid QRegularExpression object");
4662         return QString();
4663     }
4664 
4665     const QChar *uc = unicode();
4666     if (!uc)
4667         return QString();
4668 
4669     QRegularExpression sep(re);
4670     if (flags & SectionCaseInsensitiveSeps)
4671         sep.setPatternOptions(sep.patternOptions() | QRegularExpression::CaseInsensitiveOption);
4672 
4673     QList<qt_section_chunk> sections;
4674     qsizetype n = length(), m = 0, last_m = 0, last_len = 0;
4675     QRegularExpressionMatchIterator iterator = sep.globalMatch(*this);
4676     while (iterator.hasNext()) {
4677         QRegularExpressionMatch match = iterator.next();
4678         m = match.capturedStart();
4679         sections.append(qt_section_chunk(last_len, QStringView{ *this }.mid(last_m, m - last_m)));
4680         last_m = m;
4681         last_len = match.capturedLength();
4682     }
4683     sections.append(qt_section_chunk(last_len, QStringView{ *this }.mid(last_m, n - last_m)));
4684 
4685     return extractSections(sections, start, end, flags);
4686 }
4687 #endif // QT_CONFIG(regularexpression)
4688 
4689 /*!
4690     Returns a substring that contains the \a n leftmost characters
4691     of the string.
4692 
4693     If you know that \a n cannot be out of bounds, use first() instead in new
4694     code, because it is faster.
4695 
4696     The entire string is returned if \a n is greater than or equal
4697     to size(), or less than zero.
4698 
4699     \sa first(), last(), startsWith(), chopped(), chop(), truncate()
4700 */
4701 QString QString::left(qsizetype n)  const
4702 {
4703     if (size_t(n) >= size_t(size()))
4704         return *this;
4705     return QString((const QChar*) d.data(), n);
4706 }
4707 
4708 /*!
4709     Returns a substring that contains the \a n rightmost characters
4710     of the string.
4711 
4712     If you know that \a n cannot be out of bounds, use last() instead in new
4713     code, because it is faster.
4714 
4715     The entire string is returned if \a n is greater than or equal
4716     to size(), or less than zero.
4717 
4718     \sa endsWith(), last(), first(), sliced(), chopped(), chop(), truncate()
4719 */
4720 QString QString::right(qsizetype n) const
4721 {
4722     if (size_t(n) >= size_t(size()))
4723         return *this;
4724     return QString(constData() + size() - n, n);
4725 }
4726 
4727 /*!
4728     Returns a string that contains \a n characters of this string,
4729     starting at the specified \a position index.
4730 
4731     If you know that \a position and \a n cannot be out of bounds, use sliced()
4732     instead in new code, because it is faster.
4733 
4734     Returns a null string if the \a position index exceeds the
4735     length of the string. If there are less than \a n characters
4736     available in the string starting at the given \a position, or if
4737     \a n is -1 (default), the function returns all characters that
4738     are available from the specified \a position.
4739 
4740 
4741     \sa first(), last(), sliced(), chopped(), chop(), truncate()
4742 */
4743 
4744 QString QString::mid(qsizetype position, qsizetype n) const
4745 {
4746     qsizetype p = position;
4747     qsizetype l = n;
4748     using namespace QtPrivate;
4749     switch (QContainerImplHelper::mid(size(), &p, &l)) {
4750     case QContainerImplHelper::Null:
4751         return QString();
4752     case QContainerImplHelper::Empty:
4753         return QString(DataPointer::fromRawData(&_empty, 0));
4754     case QContainerImplHelper::Full:
4755         return *this;
4756     case QContainerImplHelper::Subset:
4757         return QString(constData() + p, l);
4758     }
4759     Q_UNREACHABLE();
4760     return QString();
4761 }
4762 
4763 /*!
4764     \fn QString QString::first(qsizetype n) const
4765     \since 6.0
4766 
4767     Returns a string that contains the first \a n characters
4768     of this string.
4769 
4770     \note The behavior is undefined when \a n < 0 or \a n > size().
4771 
4772     \snippet qstring/main.cpp 31
4773 
4774     \sa last(), sliced(), startsWith(), chopped(), chop(), truncate()
4775 */
4776 
4777 /*!
4778     \fn QString QString::last(qsizetype n) const
4779     \since 6.0
4780 
4781     Returns the string that contains the last \a n characters of this string.
4782 
4783     \note The behavior is undefined when \a n < 0 or \a n > size().
4784 
4785     \snippet qstring/main.cpp 48
4786 
4787     \sa first(), sliced(), endsWith(), chopped(), chop(), truncate()
4788 */
4789 
4790 /*!
4791     \fn QString QString::sliced(qsizetype pos, qsizetype n) const
4792     \since 6.0
4793 
4794     Returns a string that contains \a n characters of this string,
4795     starting at position \a pos.
4796 
4797     \note The behavior is undefined when \a pos < 0, \a n < 0,
4798     or \a pos + \a n > size().
4799 
4800     \snippet qstring/main.cpp 34
4801 
4802     \sa first(), last(), chopped(), chop(), truncate()
4803 */
4804 
4805 /*!
4806     \fn QString QString::sliced(qsizetype pos) const
4807     \since 6.0
4808     \overload
4809 
4810     Returns a string that contains the portion of this string starting at
4811     position \a pos and extending to its end.
4812 
4813     \note The behavior is undefined when \a pos < 0 or \a pos > size().
4814 
4815     \sa first(), last(), sliced(), chopped(), chop(), truncate()
4816 */
4817 
4818 /*!
4819     \fn QString QString::chopped(qsizetype len) const
4820     \since 5.10
4821 
4822     Returns a string that contains the size() - \a len leftmost characters
4823     of this string.
4824 
4825     \note The behavior is undefined if \a len is negative or greater than size().
4826 
4827     \sa endsWith(), first(), last(), sliced(), chop(), truncate()
4828 */
4829 
4830 #if QT_STRINGVIEW_LEVEL < 2
4831 /*!
4832     Returns \c true if the string starts with \a s; otherwise returns
4833     \c false.
4834 
4835     If \a cs is Qt::CaseSensitive (default), the search is
4836     case sensitive; otherwise the search is case insensitive.
4837 
4838     \snippet qstring/main.cpp 65
4839 
4840     \sa endsWith()
4841 */
4842 bool QString::startsWith(const QString& s, Qt::CaseSensitivity cs) const
4843 {
4844     return qt_starts_with(*this, s, cs);
4845 }
4846 #endif
4847 
4848 /*!
4849   \overload startsWith()
4850  */
4851 bool QString::startsWith(QLatin1String s, Qt::CaseSensitivity cs) const
4852 {
4853     return qt_starts_with(*this, s, cs);
4854 }
4855 
4856 /*!
4857   \overload startsWith()
4858 
4859   Returns \c true if the string starts with \a c; otherwise returns
4860   \c false.
4861 */
4862 bool QString::startsWith(QChar c, Qt::CaseSensitivity cs) const
4863 {
4864     return qt_starts_with(*this, c, cs);
4865 }
4866 
4867 /*!
4868     \fn bool QString::startsWith(QStringView str, Qt::CaseSensitivity cs) const
4869     \since 5.10
4870     \overload
4871 
4872     Returns \c true if the string starts with the string view \a str;
4873     otherwise returns \c false.
4874 
4875     If \a cs is Qt::CaseSensitive (default), the search is case-sensitive;
4876     otherwise the search is case insensitive.
4877 
4878     \sa endsWith()
4879 */
4880 
4881 #if QT_STRINGVIEW_LEVEL < 2
4882 /*!
4883     Returns \c true if the string ends with \a s; otherwise returns
4884     \c false.
4885 
4886     If \a cs is Qt::CaseSensitive (default), the search is case
4887     sensitive; otherwise the search is case insensitive.
4888 
4889     \snippet qstring/main.cpp 20
4890 
4891     \sa startsWith()
4892 */
4893 bool QString::endsWith(const QString &s, Qt::CaseSensitivity cs) const
4894 {
4895     return qt_ends_with(*this, s, cs);
4896 }
4897 #endif // QT_STRINGVIEW_LEVEL < 2
4898 
4899 /*!
4900     \fn bool QString::endsWith(QStringView str, Qt::CaseSensitivity cs) const
4901     \since 5.10
4902     \overload endsWith()
4903     Returns \c true if the string ends with the string view \a str;
4904     otherwise returns \c false.
4905 
4906     If \a cs is Qt::CaseSensitive (default), the search is case
4907     sensitive; otherwise the search is case insensitive.
4908 
4909     \sa startsWith()
4910 */
4911 
4912 /*!
4913     \overload endsWith()
4914 */
4915 bool QString::endsWith(QLatin1String s, Qt::CaseSensitivity cs) const
4916 {
4917     return qt_ends_with(*this, s, cs);
4918 }
4919 
4920 /*!
4921   Returns \c true if the string ends with \a c; otherwise returns
4922   \c false.
4923 
4924   \overload endsWith()
4925  */
4926 bool QString::endsWith(QChar c, Qt::CaseSensitivity cs) const
4927 {
4928     return qt_ends_with(*this, c, cs);
4929 }
4930 
4931 /*!
4932     Returns \c true if the string is uppercase, that is, it's identical
4933     to its toUpper() folding.
4934 
4935     Note that this does \e not mean that the string does not contain
4936     lowercase letters (some lowercase letters do not have a uppercase
4937     folding; they are left unchanged by toUpper()).
4938     For more information, refer to the Unicode standard, section 3.13.
4939 
4940     \since 5.12
4941 
4942     \sa QChar::toUpper(), isLower()
4943 */
4944 bool QString::isUpper() const
4945 {
4946     QStringIterator it(*this);
4947 
4948     while (it.hasNext()) {
4949         const char32_t uc = it.next();
4950         if (qGetProp(uc)->cases[QUnicodeTables::UpperCase].diff)
4951             return false;
4952     }
4953 
4954     return true;
4955 }
4956 
4957 /*!
4958     Returns \c true if the string is lowercase, that is, it's identical
4959     to its toLower() folding.
4960 
4961     Note that this does \e not mean that the string does not contain
4962     uppercase letters (some uppercase letters do not have a lowercase
4963     folding; they are left unchanged by toLower()).
4964     For more information, refer to the Unicode standard, section 3.13.
4965 
4966     \since 5.12
4967 
4968     \sa QChar::toLower(), isUpper()
4969  */
4970 bool QString::isLower() const
4971 {
4972     QStringIterator it(*this);
4973 
4974     while (it.hasNext()) {
4975         const char32_t uc = it.next();
4976         if (qGetProp(uc)->cases[QUnicodeTables::LowerCase].diff)
4977             return false;
4978     }
4979 
4980     return true;
4981 }
4982 
4983 static QByteArray qt_convert_to_latin1(QStringView string);
4984 
4985 QByteArray QString::toLatin1_helper(const QString &string)
4986 {
4987     return qt_convert_to_latin1(string);
4988 }
4989 
4990 /*!
4991     \since 6.0
4992     \internal
4993     \relates QAnyStringView
4994 
4995     Returns a UTF-16 representation of \a string as a QString.
4996 
4997     \sa QString::toLatin1(), QStringView::toLatin1(), QtPrivate::convertToUtf8(),
4998     QtPrivate::convertToLocal8Bit(), QtPrivate::convertToUcs4()
4999 */
5000 QString QtPrivate::convertToQString(QAnyStringView string)
5001 {
5002     return string.visit([] (auto string) { return string.toString(); });
5003 }
5004 
5005 /*!
5006     \since 5.10
5007     \internal
5008     \relates QStringView
5009 
5010     Returns a Latin-1 representation of \a string as a QByteArray.
5011 
5012     The behavior is undefined if \a string contains non-Latin1 characters.
5013 
5014     \sa QString::toLatin1(), QStringView::toLatin1(), QtPrivate::convertToUtf8(),
5015     QtPrivate::convertToLocal8Bit(), QtPrivate::convertToUcs4()
5016 */
5017 QByteArray QtPrivate::convertToLatin1(QStringView string)
5018 {
5019     return qt_convert_to_latin1(string);
5020 }
5021 
5022 static QByteArray qt_convert_to_latin1(QStringView string)
5023 {
5024     if (Q_UNLIKELY(string.isNull()))
5025         return QByteArray();
5026 
5027     QByteArray ba(string.length(), Qt::Uninitialized);
5028 
5029     // since we own the only copy, we're going to const_cast the constData;
5030     // that avoids an unnecessary call to detach() and expansion code that will never get used
5031     qt_to_latin1(reinterpret_cast<uchar *>(const_cast<char *>(ba.constData())),
5032                  string.utf16(), string.size());
5033     return ba;
5034 }
5035 
5036 QByteArray QString::toLatin1_helper_inplace(QString &s)
5037 {
5038     if (!s.isDetached())
5039         return qt_convert_to_latin1(s);
5040 
5041     // We can return our own buffer to the caller.
5042     // Conversion to Latin-1 always shrinks the buffer by half.
5043     const char16_t *data = s.d.data();
5044     qsizetype length = s.d.size;
5045 
5046     // Move the d pointer over to the bytearray.
5047     // Kids, avert your eyes. Don't try this at home.
5048 
5049     // this relies on the fact that we use QArrayData for everything behind the scenes which has the same layout
5050     static_assert(sizeof(QByteArray::DataPointer) == sizeof(QString::DataPointer), "sizes have to be equal");
5051     QByteArray::DataPointer ba_d(reinterpret_cast<QByteArray::Data *>(s.d.d_ptr()), reinterpret_cast<char *>(s.d.data()), length);
5052     ba_d.ref();
5053     s.clear();
5054 
5055     char *ddata = ba_d.data();
5056 
5057     // multiply the allocated capacity by sizeof(char16_t)
5058     ba_d.d_ptr()->alloc *= sizeof(char16_t);
5059 
5060     // do the in-place conversion
5061     qt_to_latin1(reinterpret_cast<uchar *>(ddata), data, length);
5062     ddata[length] = '\0';
5063     return QByteArray(ba_d);
5064 }
5065 
5066 /*!
5067     \fn QByteArray QString::toLatin1() const
5068 
5069     Returns a Latin-1 representation of the string as a QByteArray.
5070 
5071     The returned byte array is undefined if the string contains non-Latin1
5072     characters. Those characters may be suppressed or replaced with a
5073     question mark.
5074 
5075     \sa fromLatin1(), toUtf8(), toLocal8Bit(), QStringEncoder
5076 */
5077 
5078 static QByteArray qt_convert_to_local_8bit(QStringView string);
5079 
5080 /*!
5081     \fn QByteArray QString::toLocal8Bit() const
5082 
5083     Returns the local 8-bit representation of the string as a
5084     QByteArray. The returned byte array is undefined if the string
5085     contains characters not supported by the local 8-bit encoding.
5086 
5087     On Unix systems this is equivalen to toUtf8(), on Windows the systems
5088     current code page is being used.
5089 
5090     If this string contains any characters that cannot be encoded in the
5091     locale, the returned byte array is undefined. Those characters may be
5092     suppressed or replaced by another.
5093 
5094     \sa fromLocal8Bit(), toLatin1(), toUtf8(), QStringEncoder
5095 */
5096 
5097 QByteArray QString::toLocal8Bit_helper(const QChar *data, qsizetype size)
5098 {
5099     return qt_convert_to_local_8bit(QStringView(data, size));
5100 }
5101 
5102 static QByteArray qt_convert_to_local_8bit(QStringView string)
5103 {
5104     if (string.isNull())
5105         return QByteArray();
5106     QStringEncoder fromUtf16(QStringEncoder::System, QStringEncoder::Flag::Stateless);
5107     return fromUtf16(string);
5108 }
5109 
5110 /*!
5111     \since 5.10
5112     \internal
5113     \relates QStringView
5114 
5115     Returns a local 8-bit representation of \a string as a QByteArray.
5116 
5117     On Unix systems this is equivalen to toUtf8(), on Windows the systems
5118     current code page is being used.
5119 
5120     The behavior is undefined if \a string contains characters not
5121     supported by the locale's 8-bit encoding.
5122 
5123     \sa QString::toLocal8Bit(), QStringView::toLocal8Bit()
5124 */
5125 QByteArray QtPrivate::convertToLocal8Bit(QStringView string)
5126 {
5127     return qt_convert_to_local_8bit(string);
5128 }
5129 
5130 static QByteArray qt_convert_to_utf8(QStringView str);
5131 
5132 /*!
5133     \fn QByteArray QString::toUtf8() const
5134 
5135     Returns a UTF-8 representation of the string as a QByteArray.
5136 
5137     UTF-8 is a Unicode codec and can represent all characters in a Unicode
5138     string like QString.
5139 
5140     \sa fromUtf8(), toLatin1(), toLocal8Bit(), QStringEncoder
5141 */
5142 
5143 QByteArray QString::toUtf8_helper(const QString &str)
5144 {
5145     return qt_convert_to_utf8(str);
5146 }
5147 
5148 static QByteArray qt_convert_to_utf8(QStringView str)
5149 {
5150     if (str.isNull())
5151         return QByteArray();
5152 
5153     return QUtf8::convertFromUnicode(str);
5154 }
5155 
5156 /*!
5157     \since 5.10
5158     \internal
5159     \relates QStringView
5160 
5161     Returns a UTF-8 representation of \a string as a QByteArray.
5162 
5163     UTF-8 is a Unicode codec and can represent all characters in a Unicode
5164     string like QStringView.
5165 
5166     \sa QString::toUtf8(), QStringView::toUtf8()
5167 */
5168 QByteArray QtPrivate::convertToUtf8(QStringView string)
5169 {
5170     return qt_convert_to_utf8(string);
5171 }
5172 
5173 static QList<uint> qt_convert_to_ucs4(QStringView string);
5174 
5175 /*!
5176     \since 4.2
5177 
5178     Returns a UCS-4/UTF-32 representation of the string as a QList<uint>.
5179 
5180     UCS-4 is a Unicode codec and therefore it is lossless. All characters from
5181     this string will be encoded in UCS-4. Any invalid sequence of code units in
5182     this string is replaced by the Unicode's replacement character
5183     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
5184 
5185     The returned list is not \\0'-terminated.
5186 
5187     \sa fromUtf8(), toUtf8(), toLatin1(), toLocal8Bit(), QStringEncoder,
5188         fromUcs4(), toWCharArray()
5189 */
5190 QList<uint> QString::toUcs4() const
5191 {
5192     return qt_convert_to_ucs4(*this);
5193 }
5194 
5195 static QList<uint> qt_convert_to_ucs4(QStringView string)
5196 {
5197     QList<uint> v(string.length());
5198     uint *a = const_cast<uint*>(v.constData());
5199     QStringIterator it(string);
5200     while (it.hasNext())
5201         *a++ = it.next();
5202     v.resize(a - v.constData());
5203     return v;
5204 }
5205 
5206 /*!
5207     \since 5.10
5208     \internal
5209     \relates QStringView
5210 
5211     Returns a UCS-4/UTF-32 representation of \a string as a QList<uint>.
5212 
5213     UCS-4 is a Unicode codec and therefore it is lossless. All characters from
5214     this string will be encoded in UCS-4. Any invalid sequence of code units in
5215     this string is replaced by the Unicode's replacement character
5216     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
5217 
5218     The returned list is not \\0'-terminated.
5219 
5220     \sa QString::toUcs4(), QStringView::toUcs4(), QtPrivate::convertToLatin1(),
5221     QtPrivate::convertToLocal8Bit(), QtPrivate::convertToUtf8()
5222 */
5223 QList<uint> QtPrivate::convertToUcs4(QStringView string)
5224 {
5225     return qt_convert_to_ucs4(string);
5226 }
5227 
5228 /*!
5229     \fn QString QString::fromLatin1(QByteArrayView str)
5230     \overload
5231     \since 6.0
5232 
5233     Returns a QString initialized with the Latin-1 string \a str.
5234 */
5235 QString QString::fromLatin1(QByteArrayView ba)
5236 {
5237     DataPointer d;
5238     if (!ba.data()) {
5239         // nothing to do
5240     } else if (ba.size() == 0) {
5241         d = DataPointer::fromRawData(&_empty, 0);
5242     } else {
5243         d = DataPointer(Data::allocate(ba.size()), ba.size());
5244         Q_CHECK_PTR(d.data());
5245         d.data()[ba.size()] = '\0';
5246         char16_t *dst = d.data();
5247 
5248         qt_from_latin1(dst, ba.data(), size_t(ba.size()));
5249     }
5250     return QString(std::move(d));
5251 }
5252 
5253 /*!
5254     \fn QString QString::fromLatin1(const char *str, qsizetype size)
5255     Returns a QString initialized with the first \a size characters
5256     of the Latin-1 string \a str.
5257 
5258     If \a size is \c{-1}, \c{strlen(str)} is used instead.
5259 
5260     \sa toLatin1(), fromUtf8(), fromLocal8Bit()
5261 */
5262 
5263 /*!
5264     \fn QString QString::fromLatin1(const QByteArray &str)
5265     \overload
5266     \since 5.0
5267 
5268     Returns a QString initialized with the Latin-1 string \a str.
5269 */
5270 
5271 /*!
5272     \fn QString QString::fromLocal8Bit(const char *str, qsizetype size)
5273     Returns a QString initialized with the first \a size characters
5274     of the 8-bit string \a str.
5275 
5276     If \a size is \c{-1}, \c{strlen(str)} is used instead.
5277 
5278     On Unix systems this is equivalen to fromUtf8(), on Windows the systems
5279     current code page is being used.
5280 
5281     \sa toLocal8Bit(), fromLatin1(), fromUtf8()
5282 */
5283 
5284 /*!
5285     \fn QString QString::fromLocal8Bit(const QByteArray &str)
5286     \overload
5287     \since 5.0
5288 
5289     Returns a QString initialized with the 8-bit string \a str.
5290 */
5291 
5292 /*!
5293     \fn QString QString::fromLocal8Bit(QByteArrayView str)
5294     \overload
5295     \since 6.0
5296 
5297     Returns a QString initialized with the 8-bit string \a str.
5298 */
5299 QString QString::fromLocal8Bit(QByteArrayView ba)
5300 {
5301     if (ba.isNull())
5302         return QString();
5303     if (ba.isEmpty())
5304         return QString(DataPointer::fromRawData(&_empty, 0));
5305     QStringDecoder toUtf16(QStringDecoder::System, QStringDecoder::Flag::Stateless);
5306     return toUtf16(ba);
5307 }
5308 
5309 /*! \fn QString QString::fromUtf8(const char *str, qsizetype size)
5310     Returns a QString initialized with the first \a size bytes
5311     of the UTF-8 string \a str.
5312 
5313     If \a size is \c{-1}, \c{strlen(str)} is used instead.
5314 
5315     UTF-8 is a Unicode codec and can represent all characters in a Unicode
5316     string like QString. However, invalid sequences are possible with UTF-8
5317     and, if any such are found, they will be replaced with one or more
5318     "replacement characters", or suppressed. These include non-Unicode
5319     sequences, non-characters, overlong sequences or surrogate codepoints
5320     encoded into UTF-8.
5321 
5322     This function can be used to process incoming data incrementally as long as
5323     all UTF-8 characters are terminated within the incoming data. Any
5324     unterminated characters at the end of the string will be replaced or
5325     suppressed. In order to do stateful decoding, please use \l QStringDecoder.
5326 
5327     \sa toUtf8(), fromLatin1(), fromLocal8Bit()
5328 */
5329 
5330 /*!
5331     \fn QString QString::fromUtf8(const char8_t *str)
5332     \overload
5333     \since 6.1
5334 
5335     This overload is only available when compiling in C++20 mode.
5336 */
5337 
5338 /*!
5339     \fn QString QString::fromUtf8(const char8_t *str, qsizetype size)
5340     \overload
5341     \since 6.0
5342 
5343     This overload is only available when compiling in C++20 mode.
5344 */
5345 
5346 /*!
5347     \fn QString QString::fromUtf8(const QByteArray &str)
5348     \overload
5349     \since 5.0
5350 
5351     Returns a QString initialized with the UTF-8 string \a str.
5352 */
5353 
5354 /*!
5355     \fn QString QString::fromUtf8(QByteArrayView str)
5356     \overload
5357     \since 6.0
5358 
5359     Returns a QString initialized with the UTF-8 string \a str.
5360 */
5361 QString QString::fromUtf8(QByteArrayView ba)
5362 {
5363     if (ba.isNull())
5364         return QString();
5365     if (ba.isEmpty())
5366         return QString(DataPointer::fromRawData(&_empty, 0));
5367     return QUtf8::convertToUnicode(ba);
5368 }
5369 
5370 /*!
5371     \since 5.3
5372     Returns a QString initialized with the first \a size characters
5373     of the Unicode string \a unicode (ISO-10646-UTF-16 encoded).
5374 
5375     If \a size is -1 (default), \a unicode must be \\0'-terminated.
5376 
5377     This function checks for a Byte Order Mark (BOM). If it is missing,
5378     host byte order is assumed.
5379 
5380     This function is slow compared to the other Unicode conversions.
5381     Use QString(const QChar *, int) or QString(const QChar *) if possible.
5382 
5383     QString makes a deep copy of the Unicode data.
5384 
5385     \sa utf16(), setUtf16(), fromStdU16String()
5386 */
5387 QString QString::fromUtf16(const char16_t *unicode, qsizetype size)
5388 {
5389     if (!unicode)
5390         return QString();
5391     if (size < 0) {
5392         size = 0;
5393         while (unicode[size] != 0)
5394             ++size;
5395     }
5396     QStringDecoder toUtf16(QStringDecoder::Utf16, QStringDecoder::Flag::Stateless);
5397     return toUtf16(QByteArrayView(reinterpret_cast<const char *>(unicode), size * 2));
5398 }
5399 
5400 /*!
5401     \fn QString QString::fromUtf16(const ushort *str, qsizetype size)
5402     \deprecated
5403 
5404     Use the \c char16_t overload.
5405 */
5406 
5407 /*!
5408     \fn QString QString::fromUcs4(const uint *str, qsizetype size)
5409     \since 4.2
5410     \deprecated
5411 
5412     Use the \c char32_t overload instead.
5413 */
5414 
5415 /*!
5416     \since 5.3
5417 
5418     Returns a QString initialized with the first \a size characters
5419     of the Unicode string \a unicode (ISO-10646-UCS-4 encoded).
5420 
5421     If \a size is -1 (default), \a unicode must be \\0'-terminated.
5422 
5423     \sa toUcs4(), fromUtf16(), utf16(), setUtf16(), fromWCharArray(),
5424         fromStdU32String()
5425 */
5426 QString QString::fromUcs4(const char32_t *unicode, qsizetype size)
5427 {
5428     if (!unicode)
5429         return QString();
5430     if (size < 0) {
5431         size = 0;
5432         while (unicode[size] != 0)
5433             ++size;
5434     }
5435     QStringDecoder toUtf16(QStringDecoder::Utf32, QStringDecoder::Flag::Stateless);
5436     return toUtf16(QByteArrayView(reinterpret_cast<const char *>(unicode), size * 4));
5437 }
5438 
5439 
5440 /*!
5441     Resizes the string to \a size characters and copies \a unicode
5442     into the string.
5443 
5444     If \a unicode is \nullptr, nothing is copied, but the string is still
5445     resized to \a size.
5446 
5447     \sa unicode(), setUtf16()
5448 */
5449 QString& QString::setUnicode(const QChar *unicode, qsizetype size)
5450 {
5451      resize(size);
5452      if (unicode && size)
5453          memcpy(d.data(), unicode, size * sizeof(QChar));
5454      return *this;
5455 }
5456 
5457 /*!
5458     \fn QString &QString::setUtf16(const ushort *unicode, qsizetype size)
5459 
5460     Resizes the string to \a size characters and copies \a unicode
5461     into the string.
5462 
5463     If \a unicode is \nullptr, nothing is copied, but the string is still
5464     resized to \a size.
5465 
5466     Note that unlike fromUtf16(), this function does not consider BOMs and
5467     possibly differing byte ordering.
5468 
5469     \sa utf16(), setUnicode()
5470 */
5471 
5472 /*!
5473     \fn QString QString::simplified() const
5474 
5475     Returns a string that has whitespace removed from the start
5476     and the end, and that has each sequence of internal whitespace
5477     replaced with a single space.
5478 
5479     Whitespace means any character for which QChar::isSpace() returns
5480     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5481     '\\f', '\\r', and ' '.
5482 
5483     Example:
5484 
5485     \snippet qstring/main.cpp 57
5486 
5487     \sa trimmed()
5488 */
5489 QString QString::simplified_helper(const QString &str)
5490 {
5491     return QStringAlgorithms<const QString>::simplified_helper(str);
5492 }
5493 
5494 QString QString::simplified_helper(QString &str)
5495 {
5496     return QStringAlgorithms<QString>::simplified_helper(str);
5497 }
5498 
5499 namespace {
5500     template <typename StringView>
5501     StringView qt_trimmed(StringView s) noexcept
5502     {
5503         auto begin = s.begin();
5504         auto end = s.end();
5505         QStringAlgorithms<const StringView>::trimmed_helper_positions(begin, end);
5506         return StringView{begin, end};
5507     }
5508 }
5509 
5510 /*!
5511     \fn QStringView QtPrivate::trimmed(QStringView s)
5512     \fn QLatin1String QtPrivate::trimmed(QLatin1String s)
5513     \internal
5514     \relates QStringView
5515     \since 5.10
5516 
5517     Returns \a s with whitespace removed from the start and the end.
5518 
5519     Whitespace means any character for which QChar::isSpace() returns
5520     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5521     '\\f', '\\r', and ' '.
5522 
5523     \sa QString::trimmed(), QStringView::trimmed(), QLatin1String::trimmed()
5524 */
5525 QStringView QtPrivate::trimmed(QStringView s) noexcept
5526 {
5527     return qt_trimmed(s);
5528 }
5529 
5530 QLatin1String QtPrivate::trimmed(QLatin1String s) noexcept
5531 {
5532     return qt_trimmed(s);
5533 }
5534 
5535 /*!
5536     \fn QString QString::trimmed() const
5537 
5538     Returns a string that has whitespace removed from the start and
5539     the end.
5540 
5541     Whitespace means any character for which QChar::isSpace() returns
5542     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5543     '\\f', '\\r', and ' '.
5544 
5545     Example:
5546 
5547     \snippet qstring/main.cpp 82
5548 
5549     Unlike simplified(), trimmed() leaves internal whitespace alone.
5550 
5551     \sa simplified()
5552 */
5553 QString QString::trimmed_helper(const QString &str)
5554 {
5555     return QStringAlgorithms<const QString>::trimmed_helper(str);
5556 }
5557 
5558 QString QString::trimmed_helper(QString &str)
5559 {
5560     return QStringAlgorithms<QString>::trimmed_helper(str);
5561 }
5562 
5563 /*! \fn const QChar QString::at(qsizetype position) const
5564 
5565     Returns the character at the given index \a position in the
5566     string.
5567 
5568     The \a position must be a valid index position in the string
5569     (i.e., 0 <= \a position < size()).
5570 
5571     \sa operator[]()
5572 */
5573 
5574 /*!
5575     \fn QChar &QString::operator[](qsizetype position)
5576 
5577     Returns the character at the specified \a position in the string as a
5578     modifiable reference.
5579 
5580     Example:
5581 
5582     \snippet qstring/main.cpp 85
5583 
5584     \sa at()
5585 */
5586 
5587 /*!
5588     \fn const QChar QString::operator[](qsizetype position) const
5589 
5590     \overload operator[]()
5591 */
5592 
5593 /*!
5594     \fn QChar QString::front() const
5595     \since 5.10
5596 
5597     Returns the first character in the string.
5598     Same as \c{at(0)}.
5599 
5600     This function is provided for STL compatibility.
5601 
5602     \warning Calling this function on an empty string constitutes
5603     undefined behavior.
5604 
5605     \sa back(), at(), operator[]()
5606 */
5607 
5608 /*!
5609     \fn QChar QString::back() const
5610     \since 5.10
5611 
5612     Returns the last character in the string.
5613     Same as \c{at(size() - 1)}.
5614 
5615     This function is provided for STL compatibility.
5616 
5617     \warning Calling this function on an empty string constitutes
5618     undefined behavior.
5619 
5620     \sa front(), at(), operator[]()
5621 */
5622 
5623 /*!
5624     \fn QChar &QString::front()
5625     \since 5.10
5626 
5627     Returns a reference to the first character in the string.
5628     Same as \c{operator[](0)}.
5629 
5630     This function is provided for STL compatibility.
5631 
5632     \warning Calling this function on an empty string constitutes
5633     undefined behavior.
5634 
5635     \sa back(), at(), operator[]()
5636 */
5637 
5638 /*!
5639     \fn QChar &QString::back()
5640     \since 5.10
5641 
5642     Returns a reference to the last character in the string.
5643     Same as \c{operator[](size() - 1)}.
5644 
5645     This function is provided for STL compatibility.
5646 
5647     \warning Calling this function on an empty string constitutes
5648     undefined behavior.
5649 
5650     \sa front(), at(), operator[]()
5651 */
5652 
5653 /*!
5654     \fn void QString::truncate(qsizetype position)
5655 
5656     Truncates the string at the given \a position index.
5657 
5658     If the specified \a position index is beyond the end of the
5659     string, nothing happens.
5660 
5661     Example:
5662 
5663     \snippet qstring/main.cpp 83
5664 
5665     If \a position is negative, it is equivalent to passing zero.
5666 
5667     \sa chop(), resize(), first(), QStringView::truncate()
5668 */
5669 
5670 void QString::truncate(qsizetype pos)
5671 {
5672     if (pos < size())
5673         resize(pos);
5674 }
5675 
5676 
5677 /*!
5678     Removes \a n characters from the end of the string.
5679 
5680     If \a n is greater than or equal to size(), the result is an
5681     empty string; if \a n is negative, it is equivalent to passing zero.
5682 
5683     Example:
5684     \snippet qstring/main.cpp 15
5685 
5686     If you want to remove characters from the \e beginning of the
5687     string, use remove() instead.
5688 
5689     \sa truncate(), resize(), remove(), QStringView::chop()
5690 */
5691 void QString::chop(qsizetype n)
5692 {
5693     if (n > 0)
5694         resize(d.size - n);
5695 }
5696 
5697 /*!
5698     Sets every character in the string to character \a ch. If \a size
5699     is different from -1 (default), the string is resized to \a
5700     size beforehand.
5701 
5702     Example:
5703 
5704     \snippet qstring/main.cpp 21
5705 
5706     \sa resize()
5707 */
5708 
5709 QString& QString::fill(QChar ch, qsizetype size)
5710 {
5711     resize(size < 0 ? d.size : size);
5712     if (d.size) {
5713         QChar *i = (QChar*)d.data() + d.size;
5714         QChar *b = (QChar*)d.data();
5715         while (i != b)
5716            *--i = ch;
5717     }
5718     return *this;
5719 }
5720 
5721 /*!
5722     \fn qsizetype QString::length() const
5723 
5724     Returns the number of characters in this string.  Equivalent to
5725     size().
5726 
5727     \sa resize()
5728 */
5729 
5730 /*!
5731     \fn qsizetype QString::size() const
5732 
5733     Returns the number of characters in this string.
5734 
5735     The last character in the string is at position size() - 1.
5736 
5737     Example:
5738     \snippet qstring/main.cpp 58
5739 
5740     \sa isEmpty(), resize()
5741 */
5742 
5743 /*! \fn bool QString::isNull() const
5744 
5745     Returns \c true if this string is null; otherwise returns \c false.
5746 
5747     Example:
5748 
5749     \snippet qstring/main.cpp 28
5750 
5751     Qt makes a distinction between null strings and empty strings for
5752     historical reasons. For most applications, what matters is
5753     whether or not a string contains any data, and this can be
5754     determined using the isEmpty() function.
5755 
5756     \sa isEmpty()
5757 */
5758 
5759 /*! \fn bool QString::isEmpty() const
5760 
5761     Returns \c true if the string has no characters; otherwise returns
5762     \c false.
5763 
5764     Example:
5765 
5766     \snippet qstring/main.cpp 27
5767 
5768     \sa size()
5769 */
5770 
5771 /*! \fn QString &QString::operator+=(const QString &other)
5772 
5773     Appends the string \a other onto the end of this string and
5774     returns a reference to this string.
5775 
5776     Example:
5777 
5778     \snippet qstring/main.cpp 84
5779 
5780     This operation is typically very fast (\l{constant time}),
5781     because QString preallocates extra space at the end of the string
5782     data so it can grow without reallocating the entire string each
5783     time.
5784 
5785     \sa append(), prepend()
5786 */
5787 
5788 /*! \fn QString &QString::operator+=(QLatin1String str)
5789 
5790     \overload operator+=()
5791 
5792     Appends the Latin-1 string \a str to this string.
5793 */
5794 
5795 /*! \fn QString &QString::operator+=(const QByteArray &ba)
5796 
5797     \overload operator+=()
5798 
5799     Appends the byte array \a ba to this string. The byte array is converted
5800     to Unicode using the fromUtf8() function. If any NUL characters ('\\0')
5801     are embedded in the \a ba byte array, they will be included in the
5802     transformation.
5803 
5804     You can disable this function by defining
5805     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
5806     can be useful if you want to ensure that all user-visible strings
5807     go through QObject::tr(), for example.
5808 */
5809 
5810 /*! \fn QString &QString::operator+=(const char *str)
5811 
5812     \overload operator+=()
5813 
5814     Appends the string \a str to this string. The const char pointer
5815     is converted to Unicode using the fromUtf8() function.
5816 
5817     You can disable this function by defining \l QT_NO_CAST_FROM_ASCII
5818     when you compile your applications. This can be useful if you want
5819     to ensure that all user-visible strings go through QObject::tr(),
5820     for example.
5821 */
5822 
5823 /*! \fn QString &QString::operator+=(QStringView str)
5824     \since 6.0
5825     \overload operator+=()
5826 
5827     Appends the string view \a str to this string.
5828 */
5829 
5830 /*! \fn QString &QString::operator+=(QChar ch)
5831 
5832     \overload operator+=()
5833 
5834     Appends the character \a ch to the string.
5835 */
5836 
5837 /*!
5838     \fn bool QString::operator==(const char *s1, const QString &s2)
5839 
5840     \overload operator==()
5841 
5842     Returns \c true if \a s1 is equal to \a s2; otherwise returns \c false.
5843     Note that no string is equal to \a s1 being 0.
5844 
5845     Equivalent to \c {s1 != 0 && compare(s1, s2) == 0}.
5846 */
5847 
5848 /*!
5849     \fn bool QString::operator!=(const char *s1, const QString &s2)
5850 
5851     Returns \c true if \a s1 is not equal to \a s2; otherwise returns
5852     \c false.
5853 
5854     For \a s1 != 0, this is equivalent to \c {compare(} \a s1, \a s2
5855     \c {) != 0}. Note that no string is equal to \a s1 being 0.
5856 */
5857 
5858 /*!
5859     \fn bool QString::operator<(const char *s1, const QString &s2)
5860 
5861     Returns \c true if \a s1 is lexically less than \a s2; otherwise
5862     returns \c false.  For \a s1 != 0, this is equivalent to \c
5863     {compare(s1, s2) < 0}.
5864 
5865     \sa {Comparing Strings}
5866 */
5867 
5868 /*!
5869     \fn bool QString::operator<=(const char *s1, const QString &s2)
5870 
5871     Returns \c true if \a s1 is lexically less than or equal to \a s2;
5872     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c
5873     {compare(s1, s2) <= 0}.
5874 
5875     \sa {Comparing Strings}
5876 */
5877 
5878 /*!
5879     \fn bool QString::operator>(const char *s1, const QString &s2)
5880 
5881     Returns \c true if \a s1 is lexically greater than \a s2; otherwise
5882     returns \c false.  Equivalent to \c {compare(s1, s2) > 0}.
5883 
5884     \sa {Comparing Strings}
5885 */
5886 
5887 /*!
5888     \fn bool QString::operator>=(const char *s1, const QString &s2)
5889 
5890     Returns \c true if \a s1 is lexically greater than or equal to \a s2;
5891     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c
5892     {compare(s1, s2) >= 0}.
5893 
5894     \sa {Comparing Strings}
5895 */
5896 
5897 /*!
5898     \fn const QString operator+(const QString &s1, const QString &s2)
5899     \relates QString
5900 
5901     Returns a string which is the result of concatenating \a s1 and \a
5902     s2.
5903 */
5904 
5905 /*!
5906     \fn const QString operator+(const QString &s1, const char *s2)
5907     \relates QString
5908 
5909     Returns a string which is the result of concatenating \a s1 and \a
5910     s2 (\a s2 is converted to Unicode using the QString::fromUtf8()
5911     function).
5912 
5913     \sa QString::fromUtf8()
5914 */
5915 
5916 /*!
5917     \fn const QString operator+(const char *s1, const QString &s2)
5918     \relates QString
5919 
5920     Returns a string which is the result of concatenating \a s1 and \a
5921     s2 (\a s1 is converted to Unicode using the QString::fromUtf8()
5922     function).
5923 
5924     \sa QString::fromUtf8()
5925 */
5926 
5927 /*!
5928     \fn int QString::compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs)
5929     \since 4.2
5930 
5931     Compares \a s1 with \a s2 and returns an integer less than, equal
5932     to, or greater than zero if \a s1 is less than, equal to, or
5933     greater than \a s2.
5934 
5935     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
5936     otherwise the comparison is case insensitive.
5937 
5938     Case sensitive comparison is based exclusively on the numeric
5939     Unicode values of the characters and is very fast, but is not what
5940     a human would expect.  Consider sorting user-visible strings with
5941     localeAwareCompare().
5942 
5943     \snippet qstring/main.cpp 16
5944 
5945     \sa operator==(), operator<(), operator>(), {Comparing Strings}
5946 */
5947 
5948 /*!
5949     \fn int QString::compare(const QString &s1, QLatin1String s2, Qt::CaseSensitivity cs)
5950     \since 4.2
5951     \overload compare()
5952 
5953     Performs a comparison of \a s1 and \a s2, using the case
5954     sensitivity setting \a cs.
5955 */
5956 
5957 /*!
5958     \fn int QString::compare(QLatin1String s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
5959 
5960     \since 4.2
5961     \overload compare()
5962 
5963     Performs a comparison of \a s1 and \a s2, using the case
5964     sensitivity setting \a cs.
5965 */
5966 
5967 /*!
5968     \fn int QString::compare(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
5969 
5970     \since 5.12
5971     \overload compare()
5972 
5973     Performs a comparison of this with \a s, using the case
5974     sensitivity setting \a cs.
5975 */
5976 
5977 /*!
5978     \fn int QString::compare(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
5979 
5980     \since 5.14
5981     \overload compare()
5982 
5983     Performs a comparison of this with \a ch, using the case
5984     sensitivity setting \a cs.
5985 */
5986 
5987 #if QT_STRINGVIEW_LEVEL < 2
5988 /*!
5989     \overload compare()
5990     \since 4.2
5991 
5992     Lexically compares this string with the \a other string and
5993     returns an integer less than, equal to, or greater than zero if
5994     this string is less than, equal to, or greater than the other
5995     string.
5996 
5997     Same as compare(*this, \a other, \a cs).
5998 */
5999 int QString::compare(const QString &other, Qt::CaseSensitivity cs) const noexcept
6000 {
6001     return QtPrivate::compareStrings(*this, other, cs);
6002 }
6003 #endif
6004 
6005 /*!
6006     \internal
6007     \since 4.5
6008 */
6009 int QString::compare_helper(const QChar *data1, qsizetype length1, const QChar *data2, qsizetype length2,
6010                             Qt::CaseSensitivity cs) noexcept
6011 {
6012     Q_ASSERT(length1 >= 0);
6013     Q_ASSERT(length2 >= 0);
6014     Q_ASSERT(data1 || length1 == 0);
6015     Q_ASSERT(data2 || length2 == 0);
6016     return QtPrivate::compareStrings(QStringView(data1, length1), QStringView(data2, length2), cs);
6017 }
6018 
6019 /*!
6020     \overload compare()
6021     \since 4.2
6022 
6023     Same as compare(*this, \a other, \a cs).
6024 */
6025 int QString::compare(QLatin1String other, Qt::CaseSensitivity cs) const noexcept
6026 {
6027     return QtPrivate::compareStrings(*this, other, cs);
6028 }
6029 
6030 /*!
6031     \internal
6032     \since 5.0
6033 */
6034 int QString::compare_helper(const QChar *data1, qsizetype length1, const char *data2, qsizetype length2,
6035                             Qt::CaseSensitivity cs)
6036 {
6037     Q_ASSERT(length1 >= 0);
6038     Q_ASSERT(data1 || length1 == 0);
6039     if (!data2)
6040         return length1;
6041     if (Q_UNLIKELY(length2 < 0))
6042         length2 = qsizetype(strlen(data2));
6043     // ### make me nothrow in all cases
6044     QVarLengthArray<ushort> s2(length2);
6045     const auto beg = reinterpret_cast<QChar *>(s2.data());
6046     const auto end = QUtf8::convertToUnicode(beg, QByteArrayView(data2, length2));
6047     return QtPrivate::compareStrings(QStringView(data1, length1), QStringView(beg, end - beg), cs);
6048 }
6049 
6050 /*!
6051   \fn int QString::compare(const QString &s1, QStringView s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
6052   \overload compare()
6053 */
6054 
6055 /*!
6056   \fn int QString::compare(QStringView s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
6057   \overload compare()
6058 */
6059 
6060 /*!
6061     \internal
6062     \since 4.5
6063 */
6064 int QLatin1String::compare_helper(const QChar *data1, qsizetype length1, QLatin1String s2,
6065                                   Qt::CaseSensitivity cs) noexcept
6066 {
6067     Q_ASSERT(length1 >= 0);
6068     Q_ASSERT(data1 || length1 == 0);
6069     return QtPrivate::compareStrings(QStringView(data1, length1), s2, cs);
6070 }
6071 
6072 /*!
6073     \fn int QString::localeAwareCompare(const QString & s1, const QString & s2)
6074 
6075     Compares \a s1 with \a s2 and returns an integer less than, equal
6076     to, or greater than zero if \a s1 is less than, equal to, or
6077     greater than \a s2.
6078 
6079     The comparison is performed in a locale- and also
6080     platform-dependent manner. Use this function to present sorted
6081     lists of strings to the user.
6082 
6083     \sa compare(), QLocale, {Comparing Strings}
6084 */
6085 
6086 /*!
6087     \fn int QString::localeAwareCompare(QStringView other) const
6088     \since 6.0
6089     \overload localeAwareCompare()
6090 
6091     Compares this string with the \a other string and returns an
6092     integer less than, equal to, or greater than zero if this string
6093     is less than, equal to, or greater than the \a other string.
6094 
6095     The comparison is performed in a locale- and also
6096     platform-dependent manner. Use this function to present sorted
6097     lists of strings to the user.
6098 
6099     Same as \c {localeAwareCompare(*this, other)}.
6100 
6101     \sa {Comparing Strings}
6102 */
6103 
6104 /*!
6105     \fn int QString::localeAwareCompare(QStringView s1, QStringView s2)
6106     \since 6.0
6107     \overload localeAwareCompare()
6108 
6109     Compares \a s1 with \a s2 and returns an integer less than, equal
6110     to, or greater than zero if \a s1 is less than, equal to, or
6111     greater than \a s2.
6112 
6113     The comparison is performed in a locale- and also
6114     platform-dependent manner. Use this function to present sorted
6115     lists of strings to the user.
6116 
6117     \sa {Comparing Strings}
6118 */
6119 
6120 
6121 #if !defined(CSTR_LESS_THAN)
6122 #define CSTR_LESS_THAN    1
6123 #define CSTR_EQUAL        2
6124 #define CSTR_GREATER_THAN 3
6125 #endif
6126 
6127 /*!
6128     \overload localeAwareCompare()
6129 
6130     Compares this string with the \a other string and returns an
6131     integer less than, equal to, or greater than zero if this string
6132     is less than, equal to, or greater than the \a other string.
6133 
6134     The comparison is performed in a locale- and also
6135     platform-dependent manner. Use this function to present sorted
6136     lists of strings to the user.
6137 
6138     Same as \c {localeAwareCompare(*this, other)}.
6139 
6140     \sa {Comparing Strings}
6141 */
6142 int QString::localeAwareCompare(const QString &other) const
6143 {
6144     return localeAwareCompare_helper(constData(), length(), other.constData(), other.length());
6145 }
6146 
6147 #if QT_CONFIG(icu)
6148 Q_GLOBAL_STATIC(QThreadStorage<QCollator>, defaultCollator)
6149 #endif
6150 
6151 /*!
6152     \internal
6153     \since 4.5
6154 */
6155 int QString::localeAwareCompare_helper(const QChar *data1, qsizetype length1,
6156                                        const QChar *data2, qsizetype length2)
6157 {
6158     Q_ASSERT(length1 >= 0);
6159     Q_ASSERT(data1 || length1 == 0);
6160     Q_ASSERT(length2 >= 0);
6161     Q_ASSERT(data2 || length2 == 0);
6162 
6163     // do the right thing for null and empty
6164     if (length1 == 0 || length2 == 0)
6165         return QtPrivate::compareStrings(QStringView(data1, length1), QStringView(data2, length2),
6166                                Qt::CaseSensitive);
6167 
6168 #if QT_CONFIG(icu)
6169     if (!defaultCollator()->hasLocalData())
6170         defaultCollator()->setLocalData(QCollator());
6171     return defaultCollator()->localData().compare(data1, length1, data2, length2);
6172 #else
6173     const QString lhs = QString::fromRawData(data1, length1).normalized(QString::NormalizationForm_C);
6174     const QString rhs = QString::fromRawData(data2, length2).normalized(QString::NormalizationForm_C);
6175 #  if defined(Q_OS_WIN)
6176     int res = CompareStringEx(LOCALE_NAME_USER_DEFAULT, 0, (LPWSTR)lhs.constData(), lhs.length(), (LPWSTR)rhs.constData(), rhs.length(), NULL, NULL, 0);
6177 
6178     switch (res) {
6179     case CSTR_LESS_THAN:
6180         return -1;
6181     case CSTR_GREATER_THAN:
6182         return 1;
6183     default:
6184         return 0;
6185     }
6186 #  elif defined (Q_OS_DARWIN)
6187     // Use CFStringCompare for comparing strings on Mac. This makes Qt order
6188     // strings the same way as native applications do, and also respects
6189     // the "Order for sorted lists" setting in the International preferences
6190     // panel.
6191     const CFStringRef thisString =
6192         CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
6193             reinterpret_cast<const UniChar *>(lhs.constData()), lhs.length(), kCFAllocatorNull);
6194     const CFStringRef otherString =
6195         CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
6196             reinterpret_cast<const UniChar *>(rhs.constData()), rhs.length(), kCFAllocatorNull);
6197 
6198     const int result = CFStringCompare(thisString, otherString, kCFCompareLocalized);
6199     CFRelease(thisString);
6200     CFRelease(otherString);
6201     return result;
6202 #  elif defined(Q_OS_UNIX)
6203     // declared in <string.h> (no better than QtPrivate::compareStrings() on Android, sadly)
6204     return strcoll(lhs.toLocal8Bit().constData(), rhs.toLocal8Bit().constData());
6205 #  else
6206 #     error "This case shouldn't happen"
6207     return QtPrivate::compareStrings(lhs, rhs, Qt::CaseSensitive);
6208 #  endif
6209 #endif // !QT_CONFIG(icu)
6210 }
6211 
6212 
6213 /*!
6214     \fn const QChar *QString::unicode() const
6215 
6216     Returns a Unicode representation of the string.
6217     The result remains valid until the string is modified.
6218 
6219     \note The returned string may not be '\\0'-terminated.
6220     Use size() to determine the length of the array.
6221 
6222     \sa utf16(), fromRawData()
6223 */
6224 
6225 /*!
6226     \fn const ushort *QString::utf16() const
6227 
6228     Returns the QString as a '\\0\'-terminated array of unsigned
6229     shorts. The result remains valid until the string is modified.
6230 
6231     The returned string is in host byte order.
6232 
6233     \sa unicode()
6234 */
6235 
6236 const ushort *QString::utf16() const
6237 {
6238     if (!d->isMutable()) {
6239         // ensure '\0'-termination for ::fromRawData strings
6240         const_cast<QString*>(this)->reallocData(d.size, QArrayData::KeepSize);
6241     }
6242     return reinterpret_cast<const ushort *>(d.data());
6243 }
6244 
6245 /*!
6246     Returns a string of size \a width that contains this string
6247     padded by the \a fill character.
6248 
6249     If \a truncate is \c false and the size() of the string is more than
6250     \a width, then the returned string is a copy of the string.
6251 
6252     \snippet qstring/main.cpp 32
6253 
6254     If \a truncate is \c true and the size() of the string is more than
6255     \a width, then any characters in a copy of the string after
6256     position \a width are removed, and the copy is returned.
6257 
6258     \snippet qstring/main.cpp 33
6259 
6260     \sa rightJustified()
6261 */
6262 
6263 QString QString::leftJustified(qsizetype width, QChar fill, bool truncate) const
6264 {
6265     QString result;
6266     qsizetype len = length();
6267     qsizetype padlen = width - len;
6268     if (padlen > 0) {
6269         result.resize(len+padlen);
6270         if (len)
6271             memcpy(result.d.data(), d.data(), sizeof(QChar)*len);
6272         QChar *uc = (QChar*)result.d.data() + len;
6273         while (padlen--)
6274            * uc++ = fill;
6275     } else {
6276         if (truncate)
6277             result = left(width);
6278         else
6279             result = *this;
6280     }
6281     return result;
6282 }
6283 
6284 /*!
6285     Returns a string of size() \a width that contains the \a fill
6286     character followed by the string. For example:
6287 
6288     \snippet qstring/main.cpp 49
6289 
6290     If \a truncate is \c false and the size() of the string is more than
6291     \a width, then the returned string is a copy of the string.
6292 
6293     If \a truncate is true and the size() of the string is more than
6294     \a width, then the resulting string is truncated at position \a
6295     width.
6296 
6297     \snippet qstring/main.cpp 50
6298 
6299     \sa leftJustified()
6300 */
6301 
6302 QString QString::rightJustified(qsizetype width, QChar fill, bool truncate) const
6303 {
6304     QString result;
6305     qsizetype len = length();
6306     qsizetype padlen = width - len;
6307     if (padlen > 0) {
6308         result.resize(len+padlen);
6309         QChar *uc = (QChar*)result.d.data();
6310         while (padlen--)
6311            * uc++ = fill;
6312         if (len)
6313           memcpy(static_cast<void *>(uc), static_cast<const void *>(d.data()), sizeof(QChar)*len);
6314     } else {
6315         if (truncate)
6316             result = left(width);
6317         else
6318             result = *this;
6319     }
6320     return result;
6321 }
6322 
6323 /*!
6324     \fn QString QString::toLower() const
6325 
6326     Returns a lowercase copy of the string.
6327 
6328     \snippet qstring/main.cpp 75
6329 
6330     The case conversion will always happen in the 'C' locale. For
6331     locale-dependent case folding use QLocale::toLower()
6332 
6333     \sa toUpper(), QLocale::toLower()
6334 */
6335 
6336 namespace QUnicodeTables {
6337 /*
6338     \internal
6339     Converts the \a str string starting from the position pointed to by the \a
6340     it iterator, using the Unicode case traits \c Traits, and returns the
6341     result. The input string must not be empty (the convertCase function below
6342     guarantees that).
6343 
6344     The string type \c{T} is also a template and is either \c{const QString} or
6345     \c{QString}. This function can do both copy-conversion and in-place
6346     conversion depending on the state of the \a str parameter:
6347     \list
6348        \li \c{T} is \c{const QString}: copy-convert
6349        \li \c{T} is \c{QString} and its refcount != 1: copy-convert
6350        \li \c{T} is \c{QString} and its refcount == 1: in-place convert
6351     \endlist
6352 
6353     In copy-convert mode, the local variable \c{s} is detached from the input
6354     \a str. In the in-place convert mode, \a str is in moved-from state and
6355     \c{s} contains the only copy of the string, without reallocation (thus,
6356     \a it is still valid).
6357 
6358     There is one pathological case left: when the in-place conversion needs to
6359     reallocate memory to grow the buffer. In that case, we need to adjust the \a
6360     it pointer.
6361  */
6362 template <typename T>
6363 Q_NEVER_INLINE
6364 static QString detachAndConvertCase(T &str, QStringIterator it, QUnicodeTables::Case which)
6365 {
6366     Q_ASSERT(!str.isEmpty());
6367     QString s = std::move(str);         // will copy if T is const QString
6368     QChar *pp = s.begin() + it.index(); // will detach if necessary
6369 
6370     do {
6371         const auto folded = fullConvertCase(it.next(), which);
6372         if (Q_UNLIKELY(folded.size() > 1)) {
6373             if (folded.chars[0] == *pp && folded.size() == 2) {
6374                 // special case: only second actually changed (e.g. surrogate pairs),
6375                 // avoid slow case
6376                 ++pp;
6377                 *pp++ = folded.chars[1];
6378             } else {
6379                 // slow path: the string is growing
6380                 qsizetype inpos = it.index() - 1;
6381                 qsizetype outpos = pp - s.constBegin();
6382 
6383                 s.replace(outpos, 1, reinterpret_cast<const QChar *>(folded.data()), folded.size());
6384                 pp = const_cast<QChar *>(s.constBegin()) + outpos + folded.size();
6385 
6386                 // Adjust the input iterator if we are performing an in-place conversion
6387                 if constexpr (!std::is_const<T>::value)
6388                     it = QStringIterator(s.constBegin(), inpos + folded.size(), s.constEnd());
6389             }
6390         } else {
6391             *pp++ = folded.chars[0];
6392         }
6393     } while (it.hasNext());
6394 
6395     return s;
6396 }
6397 
6398 template <typename T>
6399 static QString convertCase(T &str, QUnicodeTables::Case which)
6400 {
6401     const QChar *p = str.constBegin();
6402     const QChar *e = p + str.size();
6403 
6404     // this avoids out of bounds check in the loop
6405     while (e != p && e[-1].isHighSurrogate())
6406         --e;
6407 
6408     QStringIterator it(p, e);
6409     while (it.hasNext()) {
6410         const char32_t uc = it.next();
6411         if (qGetProp(uc)->cases[which].diff) {
6412             it.recede();
6413             return detachAndConvertCase(str, it, which);
6414         }
6415     }
6416     return std::move(str);
6417 }
6418 } // namespace QUnicodeTables
6419 
6420 QString QString::toLower_helper(const QString &str)
6421 {
6422     return QUnicodeTables::convertCase(str, QUnicodeTables::LowerCase);
6423 }
6424 
6425 QString QString::toLower_helper(QString &str)
6426 {
6427     return QUnicodeTables::convertCase(str, QUnicodeTables::LowerCase);
6428 }
6429 
6430 /*!
6431     \fn QString QString::toCaseFolded() const
6432 
6433     Returns the case folded equivalent of the string. For most Unicode
6434     characters this is the same as toLower().
6435 */
6436 
6437 QString QString::toCaseFolded_helper(const QString &str)
6438 {
6439     return QUnicodeTables::convertCase(str, QUnicodeTables::CaseFold);
6440 }
6441 
6442 QString QString::toCaseFolded_helper(QString &str)
6443 {
6444     return QUnicodeTables::convertCase(str, QUnicodeTables::CaseFold);
6445 }
6446 
6447 /*!
6448     \fn QString QString::toUpper() const
6449 
6450     Returns an uppercase copy of the string.
6451 
6452     \snippet qstring/main.cpp 81
6453 
6454     The case conversion will always happen in the 'C' locale. For
6455     locale-dependent case folding use QLocale::toUpper()
6456 
6457     \sa toLower(), QLocale::toLower()
6458 */
6459 
6460 QString QString::toUpper_helper(const QString &str)
6461 {
6462     return QUnicodeTables::convertCase(str, QUnicodeTables::UpperCase);
6463 }
6464 
6465 QString QString::toUpper_helper(QString &str)
6466 {
6467     return QUnicodeTables::convertCase(str, QUnicodeTables::UpperCase);
6468 }
6469 
6470 /*!
6471     \since 5.5
6472 
6473     Safely builds a formatted string from the format string \a cformat
6474     and an arbitrary list of arguments.
6475 
6476     The format string supports the conversion specifiers, length modifiers,
6477     and flags provided by printf() in the standard C++ library. The \a cformat
6478     string and \c{%s} arguments must be UTF-8 encoded.
6479 
6480     \note The \c{%lc} escape sequence expects a unicode character of type
6481     \c char16_t, or \c ushort (as returned by QChar::unicode()).
6482     The \c{%ls} escape sequence expects a pointer to a zero-terminated array
6483     of unicode characters of type \c char16_t, or ushort (as returned by
6484     QString::utf16()). This is at odds with the printf() in the standard C++
6485     library, which defines \c {%lc} to print a wchar_t and \c{%ls} to print
6486     a \c{wchar_t*}, and might also produce compiler warnings on platforms
6487     where the size of \c {wchar_t} is not 16 bits.
6488 
6489     \warning We do not recommend using QString::asprintf() in new Qt
6490     code. Instead, consider using QTextStream or arg(), both of
6491     which support Unicode strings seamlessly and are type-safe.
6492     Here is an example that uses QTextStream:
6493 
6494     \snippet qstring/main.cpp 64
6495 
6496     For \l {QObject::tr()}{translations}, especially if the strings
6497     contains more than one escape sequence, you should consider using
6498     the arg() function instead. This allows the order of the
6499     replacements to be controlled by the translator.
6500 
6501     \sa arg()
6502 */
6503 
6504 QString QString::asprintf(const char *cformat, ...)
6505 {
6506     va_list ap;
6507     va_start(ap, cformat);
6508     const QString s = vasprintf(cformat, ap);
6509     va_end(ap);
6510     return s;
6511 }
6512 
6513 static void append_utf8(QString &qs, const char *cs, int len)
6514 {
6515     const int oldSize = qs.size();
6516     qs.resize(oldSize + len);
6517     const QChar *newEnd = QUtf8::convertToUnicode(qs.data() + oldSize, QByteArrayView(cs, len));
6518     qs.resize(newEnd - qs.constData());
6519 }
6520 
6521 static uint parse_flag_characters(const char * &c) noexcept
6522 {
6523     uint flags = QLocaleData::ZeroPadExponent;
6524     while (true) {
6525         switch (*c) {
6526         case '#':
6527             flags |= QLocaleData::ShowBase | QLocaleData::AddTrailingZeroes
6528                     | QLocaleData::ForcePoint;
6529             break;
6530         case '0': flags |= QLocaleData::ZeroPadded; break;
6531         case '-': flags |= QLocaleData::LeftAdjusted; break;
6532         case ' ': flags |= QLocaleData::BlankBeforePositive; break;
6533         case '+': flags |= QLocaleData::AlwaysShowSign; break;
6534         case '\'': flags |= QLocaleData::GroupDigits; break;
6535         default: return flags;
6536         }
6537         ++c;
6538     }
6539 }
6540 
6541 static int parse_field_width(const char * &c)
6542 {
6543     Q_ASSERT(qIsDigit(*c));
6544 
6545     // can't be negative - started with a digit
6546     // contains at least one digit
6547     const char *endp;
6548     bool ok;
6549     const qulonglong result = qstrtoull(c, &endp, 10, &ok);
6550     c = endp;
6551     while (qIsDigit(*c)) // preserve Qt 5.5 behavior of consuming all digits, no matter how many
6552         ++c;
6553     return ok && result < qulonglong(std::numeric_limits<int>::max()) ? int(result) : 0;
6554 }
6555 
6556 enum LengthMod { lm_none, lm_hh, lm_h, lm_l, lm_ll, lm_L, lm_j, lm_z, lm_t };
6557 
6558 static inline bool can_consume(const char * &c, char ch) noexcept
6559 {
6560     if (*c == ch) {
6561         ++c;
6562         return true;
6563     }
6564     return false;
6565 }
6566 
6567 static LengthMod parse_length_modifier(const char * &c) noexcept
6568 {
6569     switch (*c++) {
6570     case 'h': return can_consume(c, 'h') ? lm_hh : lm_h;
6571     case 'l': return can_consume(c, 'l') ? lm_ll : lm_l;
6572     case 'L': return lm_L;
6573     case 'j': return lm_j;
6574     case 'z':
6575     case 'Z': return lm_z;
6576     case 't': return lm_t;
6577     }
6578     --c; // don't consume *c - it wasn't a flag
6579     return lm_none;
6580 }
6581 
6582 /*!
6583     \fn QString QString::vasprintf(const char *cformat, va_list ap)
6584     \since 5.5
6585 
6586     Equivalent method to asprintf(), but takes a va_list \a ap
6587     instead a list of variable arguments. See the asprintf()
6588     documentation for an explanation of \a cformat.
6589 
6590     This method does not call the va_end macro, the caller
6591     is responsible to call va_end on \a ap.
6592 
6593     \sa asprintf()
6594 */
6595 
6596 QString QString::vasprintf(const char *cformat, va_list ap)
6597 {
6598     if (!cformat || !*cformat) {
6599         // Qt 1.x compat
6600         return fromLatin1("");
6601     }
6602 
6603     // Parse cformat
6604 
6605     QString result;
6606     const char *c = cformat;
6607     for (;;) {
6608         // Copy non-escape chars to result
6609         const char *cb = c;
6610         while (*c != '\0' && *c != '%')
6611             c++;
6612         append_utf8(result, cb, qsizetype(c - cb));
6613 
6614         if (*c == '\0')
6615             break;
6616 
6617         // Found '%'
6618         const char *escape_start = c;
6619         ++c;
6620 
6621         if (*c == '\0') {
6622             result.append(QLatin1Char('%')); // a % at the end of the string - treat as non-escape text
6623             break;
6624         }
6625         if (*c == '%') {
6626             result.append(QLatin1Char('%')); // %%
6627             ++c;
6628             continue;
6629         }
6630 
6631         uint flags = parse_flag_characters(c);
6632 
6633         if (*c == '\0') {
6634             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6635             break;
6636         }
6637 
6638         // Parse field width
6639         int width = -1; // -1 means unspecified
6640         if (qIsDigit(*c)) {
6641             width = parse_field_width(c);
6642         } else if (*c == '*') { // can't parse this in another function, not portably, at least
6643             width = va_arg(ap, int);
6644             if (width < 0)
6645                 width = -1; // treat all negative numbers as unspecified
6646             ++c;
6647         }
6648 
6649         if (*c == '\0') {
6650             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6651             break;
6652         }
6653 
6654         // Parse precision
6655         int precision = -1; // -1 means unspecified
6656         if (*c == '.') {
6657             ++c;
6658             if (qIsDigit(*c)) {
6659                 precision = parse_field_width(c);
6660             } else if (*c == '*') { // can't parse this in another function, not portably, at least
6661                 precision = va_arg(ap, int);
6662                 if (precision < 0)
6663                     precision = -1; // treat all negative numbers as unspecified
6664                 ++c;
6665             }
6666         }
6667 
6668         if (*c == '\0') {
6669             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6670             break;
6671         }
6672 
6673         const LengthMod length_mod = parse_length_modifier(c);
6674 
6675         if (*c == '\0') {
6676             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6677             break;
6678         }
6679 
6680         // Parse the conversion specifier and do the conversion
6681         QString subst;
6682         switch (*c) {
6683             case 'd':
6684             case 'i': {
6685                 qint64 i;
6686                 switch (length_mod) {
6687                     case lm_none: i = va_arg(ap, int); break;
6688                     case lm_hh: i = va_arg(ap, int); break;
6689                     case lm_h: i = va_arg(ap, int); break;
6690                     case lm_l: i = va_arg(ap, long int); break;
6691                     case lm_ll: i = va_arg(ap, qint64); break;
6692                     case lm_j: i = va_arg(ap, long int); break;
6693 
6694                     /* ptrdiff_t actually, but it should be the same for us */
6695                     case lm_z: i = va_arg(ap, qsizetype); break;
6696                     case lm_t: i = va_arg(ap, qsizetype); break;
6697                     default: i = 0; break;
6698                 }
6699                 subst = QLocaleData::c()->longLongToString(i, precision, 10, width, flags);
6700                 ++c;
6701                 break;
6702             }
6703             case 'o':
6704             case 'u':
6705             case 'x':
6706             case 'X': {
6707                 quint64 u;
6708                 switch (length_mod) {
6709                     case lm_none: u = va_arg(ap, uint); break;
6710                     case lm_hh: u = va_arg(ap, uint); break;
6711                     case lm_h: u = va_arg(ap, uint); break;
6712                     case lm_l: u = va_arg(ap, ulong); break;
6713                     case lm_ll: u = va_arg(ap, quint64); break;
6714                     case lm_t: u = va_arg(ap, size_t); break;
6715                     case lm_z: u = va_arg(ap, size_t); break;
6716                     default: u = 0; break;
6717                 }
6718 
6719                 if (qIsUpper(*c))
6720                     flags |= QLocaleData::CapitalEorX;
6721 
6722                 int base = 10;
6723                 switch (qToLower(*c)) {
6724                     case 'o':
6725                         base = 8; break;
6726                     case 'u':
6727                         base = 10; break;
6728                     case 'x':
6729                         base = 16; break;
6730                     default: break;
6731                 }
6732                 subst = QLocaleData::c()->unsLongLongToString(u, precision, base, width, flags);
6733                 ++c;
6734                 break;
6735             }
6736             case 'E':
6737             case 'e':
6738             case 'F':
6739             case 'f':
6740             case 'G':
6741             case 'g':
6742             case 'A':
6743             case 'a': {
6744                 double d;
6745                 if (length_mod == lm_L)
6746                     d = va_arg(ap, long double); // not supported - converted to a double
6747                 else
6748                     d = va_arg(ap, double);
6749 
6750                 if (qIsUpper(*c))
6751                     flags |= QLocaleData::CapitalEorX;
6752 
6753                 QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
6754                 switch (qToLower(*c)) {
6755                     case 'e': form = QLocaleData::DFExponent; break;
6756                     case 'a':                             // not supported - decimal form used instead
6757                     case 'f': form = QLocaleData::DFDecimal; break;
6758                     case 'g': form = QLocaleData::DFSignificantDigits; break;
6759                     default: break;
6760                 }
6761                 subst = QLocaleData::c()->doubleToString(d, precision, form, width, flags);
6762                 ++c;
6763                 break;
6764             }
6765             case 'c': {
6766                 if (length_mod == lm_l)
6767                     subst = QChar::fromUcs2(va_arg(ap, int));
6768                 else
6769                     subst = QLatin1Char((uchar) va_arg(ap, int));
6770                 ++c;
6771                 break;
6772             }
6773             case 's': {
6774                 if (length_mod == lm_l) {
6775                     const ushort *buff = va_arg(ap, const ushort*);
6776                     const ushort *ch = buff;
6777                     while (*ch != 0) {
6778                         ++ch;
6779                         if (--precision == 0)
6780                             break;
6781                     }
6782                     subst.setUtf16(buff, ch - buff);
6783                 } else if (precision == -1) {
6784                     subst = QString::fromUtf8(va_arg(ap, const char*));
6785                 } else {
6786                     const char *buff = va_arg(ap, const char*);
6787                     for (int i = 0; i < precision; ++i) {
6788                         if (buff[i] == 0)
6789                             precision = i;
6790                     }
6791                     subst = QString::fromUtf8(QByteArrayView(buff, precision));
6792                 }
6793                 ++c;
6794                 break;
6795             }
6796             case 'p': {
6797                 void *arg = va_arg(ap, void*);
6798                 const quint64 i = reinterpret_cast<quintptr>(arg);
6799                 flags |= QLocaleData::ShowBase;
6800                 subst = QLocaleData::c()->unsLongLongToString(i, precision, 16, width, flags);
6801                 ++c;
6802                 break;
6803             }
6804             case 'n':
6805                 switch (length_mod) {
6806                     case lm_hh: {
6807                         signed char *n = va_arg(ap, signed char*);
6808                         *n = result.length();
6809                         break;
6810                     }
6811                     case lm_h: {
6812                         short int *n = va_arg(ap, short int*);
6813                         *n = result.length();
6814                             break;
6815                     }
6816                     case lm_l: {
6817                         long int *n = va_arg(ap, long int*);
6818                         *n = result.length();
6819                         break;
6820                     }
6821                     case lm_ll: {
6822                         qint64 *n = va_arg(ap, qint64*);
6823                         *n = result.length();
6824                         break;
6825                     }
6826                     default: {
6827                         int *n = va_arg(ap, int*);
6828                         *n = result.length();
6829                         break;
6830                     }
6831                 }
6832                 ++c;
6833                 break;
6834 
6835             default: // bad escape, treat as non-escape text
6836                 for (const char *cc = escape_start; cc != c; ++cc)
6837                     result.append(QLatin1Char(*cc));
6838                 continue;
6839         }
6840 
6841         if (flags & QLocaleData::LeftAdjusted)
6842             result.append(subst.leftJustified(width));
6843         else
6844             result.append(subst.rightJustified(width));
6845     }
6846 
6847     return result;
6848 }
6849 
6850 /*!
6851     Returns the string converted to a \c{long long} using base \a
6852     base, which is 10 by default and must be between 2 and 36, or 0.
6853     Returns 0 if the conversion fails.
6854 
6855     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6856     to \c false, and success by setting *\a{ok} to \c true.
6857 
6858     If \a base is 0, the C language convention is used: If the string
6859     begins with "0x", base 16 is used; if the string begins with "0",
6860     base 8 is used; otherwise, base 10 is used.
6861 
6862     The string conversion will always happen in the 'C' locale. For
6863     locale-dependent conversion use QLocale::toLongLong()
6864 
6865     Example:
6866 
6867     \snippet qstring/main.cpp 74
6868 
6869     This function ignores leading and trailing whitespace.
6870 
6871     \sa number(), toULongLong(), toInt(), QLocale::toLongLong()
6872 */
6873 
6874 qint64 QString::toLongLong(bool *ok, int base) const
6875 {
6876     return toIntegral_helper<qlonglong>(*this, ok, base);
6877 }
6878 
6879 qlonglong QString::toIntegral_helper(QStringView string, bool *ok, int base)
6880 {
6881 #if defined(QT_CHECK_RANGE)
6882     if (base != 0 && (base < 2 || base > 36)) {
6883         qWarning("QString::toULongLong: Invalid base (%d)", base);
6884         base = 10;
6885     }
6886 #endif
6887 
6888     return QLocaleData::c()->stringToLongLong(string, base, ok, QLocale::RejectGroupSeparator);
6889 }
6890 
6891 
6892 /*!
6893     Returns the string converted to an \c{unsigned long long} using base \a
6894     base, which is 10 by default and must be between 2 and 36, or 0.
6895     Returns 0 if the conversion fails.
6896 
6897     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6898     to \c false, and success by setting *\a{ok} to \c true.
6899 
6900     If \a base is 0, the C language convention is used: If the string
6901     begins with "0x", base 16 is used; if the string begins with "0",
6902     base 8 is used; otherwise, base 10 is used.
6903 
6904     The string conversion will always happen in the 'C' locale. For
6905     locale-dependent conversion use QLocale::toULongLong()
6906 
6907     Example:
6908 
6909     \snippet qstring/main.cpp 79
6910 
6911     This function ignores leading and trailing whitespace.
6912 
6913     \sa number(), toLongLong(), QLocale::toULongLong()
6914 */
6915 
6916 quint64 QString::toULongLong(bool *ok, int base) const
6917 {
6918     return toIntegral_helper<qulonglong>(*this, ok, base);
6919 }
6920 
6921 qulonglong QString::toIntegral_helper(QStringView string, bool *ok, uint base)
6922 {
6923 #if defined(QT_CHECK_RANGE)
6924     if (base != 0 && (base < 2 || base > 36)) {
6925         qWarning("QString::toULongLong: Invalid base (%d)", base);
6926         base = 10;
6927     }
6928 #endif
6929 
6930     return QLocaleData::c()->stringToUnsLongLong(string, base, ok, QLocale::RejectGroupSeparator);
6931 }
6932 
6933 /*!
6934     \fn long QString::toLong(bool *ok, int base) const
6935 
6936     Returns the string converted to a \c long using base \a
6937     base, which is 10 by default and must be between 2 and 36, or 0.
6938     Returns 0 if the conversion fails.
6939 
6940     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6941     to \c false, and success by setting *\a{ok} to \c true.
6942 
6943     If \a base is 0, the C language convention is used: If the string
6944     begins with "0x", base 16 is used; if the string begins with "0",
6945     base 8 is used; otherwise, base 10 is used.
6946 
6947     The string conversion will always happen in the 'C' locale. For
6948     locale-dependent conversion use QLocale::toLongLong()
6949 
6950     Example:
6951 
6952     \snippet qstring/main.cpp 73
6953 
6954     This function ignores leading and trailing whitespace.
6955 
6956     \sa number(), toULong(), toInt(), QLocale::toInt()
6957 */
6958 
6959 /*!
6960     \fn ulong QString::toULong(bool *ok, int base) const
6961 
6962     Returns the string converted to an \c{unsigned long} using base \a
6963     base, which is 10 by default and must be between 2 and 36, or 0.
6964     Returns 0 if the conversion fails.
6965 
6966     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6967     to \c false, and success by setting *\a{ok} to \c true.
6968 
6969     If \a base is 0, the C language convention is used: If the string
6970     begins with "0x", base 16 is used; if the string begins with "0",
6971     base 8 is used; otherwise, base 10 is used.
6972 
6973     The string conversion will always happen in the 'C' locale. For
6974     locale-dependent conversion use QLocale::toULongLong()
6975 
6976     Example:
6977 
6978     \snippet qstring/main.cpp 78
6979 
6980     This function ignores leading and trailing whitespace.
6981 
6982     \sa number(), QLocale::toUInt()
6983 */
6984 
6985 /*!
6986     \fn int QString::toInt(bool *ok, int base) const
6987     Returns the string converted to an \c int using base \a
6988     base, which is 10 by default and must be between 2 and 36, or 0.
6989     Returns 0 if the conversion fails.
6990 
6991     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6992     to \c false, and success by setting *\a{ok} to \c true.
6993 
6994     If \a base is 0, the C language convention is used: If the string
6995     begins with "0x", base 16 is used; if the string begins with "0",
6996     base 8 is used; otherwise, base 10 is used.
6997 
6998     The string conversion will always happen in the 'C' locale. For
6999     locale-dependent conversion use QLocale::toInt()
7000 
7001     Example:
7002 
7003     \snippet qstring/main.cpp 72
7004 
7005     This function ignores leading and trailing whitespace.
7006 
7007     \sa number(), toUInt(), toDouble(), QLocale::toInt()
7008 */
7009 
7010 /*!
7011     \fn uint QString::toUInt(bool *ok, int base) const
7012     Returns the string converted to an \c{unsigned int} using base \a
7013     base, which is 10 by default and must be between 2 and 36, or 0.
7014     Returns 0 if the conversion fails.
7015 
7016     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
7017     to \c false, and success by setting *\a{ok} to \c true.
7018 
7019     If \a base is 0, the C language convention is used: If the string
7020     begins with "0x", base 16 is used; if the string begins with "0",
7021     base 8 is used; otherwise, base 10 is used.
7022 
7023     The string conversion will always happen in the 'C' locale. For
7024     locale-dependent conversion use QLocale::toUInt()
7025 
7026     Example:
7027 
7028     \snippet qstring/main.cpp 77
7029 
7030     This function ignores leading and trailing whitespace.
7031 
7032     \sa number(), toInt(), QLocale::toUInt()
7033 */
7034 
7035 /*!
7036     \fn short QString::toShort(bool *ok, int base) const
7037 
7038     Returns the string converted to a \c short using base \a
7039     base, which is 10 by default and must be between 2 and 36, or 0.
7040     Returns 0 if the conversion fails.
7041 
7042     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
7043     to \c false, and success by setting *\a{ok} to \c true.
7044 
7045     If \a base is 0, the C language convention is used: If the string
7046     begins with "0x", base 16 is used; if the string begins with "0",
7047     base 8 is used; otherwise, base 10 is used.
7048 
7049     The string conversion will always happen in the 'C' locale. For
7050     locale-dependent conversion use QLocale::toShort()
7051 
7052     Example:
7053 
7054     \snippet qstring/main.cpp 76
7055 
7056     This function ignores leading and trailing whitespace.
7057 
7058     \sa number(), toUShort(), toInt(), QLocale::toShort()
7059 */
7060 
7061 /*!
7062     \fn ushort QString::toUShort(bool *ok, int base) const
7063 
7064     Returns the string converted to an \c{unsigned short} using base \a
7065     base, which is 10 by default and must be between 2 and 36, or 0.
7066     Returns 0 if the conversion fails.
7067 
7068     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
7069     to \c false, and success by setting *\a{ok} to \c true.
7070 
7071     If \a base is 0, the C language convention is used: If the string
7072     begins with "0x", base 16 is used; if the string begins with "0",
7073     base 8 is used; otherwise, base 10 is used.
7074 
7075     The string conversion will always happen in the 'C' locale. For
7076     locale-dependent conversion use QLocale::toUShort()
7077 
7078     Example:
7079 
7080     \snippet qstring/main.cpp 80
7081 
7082     This function ignores leading and trailing whitespace.
7083 
7084     \sa number(), toShort(), QLocale::toUShort()
7085 */
7086 
7087 /*!
7088     Returns the string converted to a \c double value.
7089 
7090     Returns an infinity if the conversion overflows or 0.0 if the
7091     conversion fails for other reasons (e.g. underflow).
7092 
7093     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
7094     to \c false, and success by setting *\a{ok} to \c true.
7095 
7096     \snippet qstring/main.cpp 66
7097 
7098     \warning The QString content may only contain valid numerical characters
7099     which includes the plus/minus sign, the character e used in scientific
7100     notation, and the decimal point. Including the unit or additional characters
7101     leads to a conversion error.
7102 
7103     \snippet qstring/main.cpp 67
7104 
7105     The string conversion will always happen in the 'C' locale. For
7106     locale-dependent conversion use QLocale::toDouble()
7107 
7108     \snippet qstring/main.cpp 68
7109 
7110     For historical reasons, this function does not handle
7111     thousands group separators. If you need to convert such numbers,
7112     use QLocale::toDouble().
7113 
7114     \snippet qstring/main.cpp 69
7115 
7116     This function ignores leading and trailing whitespace.
7117 
7118     \sa number(), QLocale::setDefault(), QLocale::toDouble(), trimmed()
7119 */
7120 
7121 double QString::toDouble(bool *ok) const
7122 {
7123     return QLocaleData::c()->stringToDouble(*this, ok, QLocale::RejectGroupSeparator);
7124 }
7125 
7126 /*!
7127     Returns the string converted to a \c float value.
7128 
7129     Returns an infinity if the conversion overflows or 0.0 if the
7130     conversion fails for other reasons (e.g. underflow).
7131 
7132     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
7133     to \c false, and success by setting *\a{ok} to \c true.
7134 
7135     \warning The QString content may only contain valid numerical characters
7136     which includes the plus/minus sign, the character e used in scientific
7137     notation, and the decimal point. Including the unit or additional characters
7138     leads to a conversion error.
7139 
7140     The string conversion will always happen in the 'C' locale. For
7141     locale-dependent conversion use QLocale::toFloat()
7142 
7143     For historical reasons, this function does not handle
7144     thousands group separators. If you need to convert such numbers,
7145     use QLocale::toFloat().
7146 
7147     Example:
7148 
7149     \snippet qstring/main.cpp 71
7150 
7151     This function ignores leading and trailing whitespace.
7152 
7153     \sa number(), toDouble(), toInt(), QLocale::toFloat(), trimmed()
7154 */
7155 
7156 float QString::toFloat(bool *ok) const
7157 {
7158     return QLocaleData::convertDoubleToFloat(toDouble(ok), ok);
7159 }
7160 
7161 /*! \fn QString &QString::setNum(int n, int base)
7162 
7163     Sets the string to the printed value of \a n in the specified \a
7164     base, and returns a reference to the string.
7165 
7166     The base is 10 by default and must be between 2 and 36. For bases
7167     other than 10, \a n is treated as an unsigned integer.
7168 
7169     \snippet qstring/main.cpp 56
7170 
7171    The formatting always uses QLocale::C, i.e., English/UnitedStates.
7172    To get a localized string representation of a number, use
7173    QLocale::toString() with the appropriate locale.
7174 
7175    \sa number()
7176 */
7177 
7178 /*! \fn QString &QString::setNum(uint n, int base)
7179 
7180     \overload
7181 */
7182 
7183 /*! \fn QString &QString::setNum(long n, int base)
7184 
7185     \overload
7186 */
7187 
7188 /*! \fn QString &QString::setNum(ulong n, int base)
7189 
7190     \overload
7191 */
7192 
7193 /*!
7194     \overload
7195 */
7196 QString &QString::setNum(qlonglong n, int base)
7197 {
7198     return *this = number(n, base);
7199 }
7200 
7201 /*!
7202     \overload
7203 */
7204 QString &QString::setNum(qulonglong n, int base)
7205 {
7206     return *this = number(n, base);
7207 }
7208 
7209 /*! \fn QString &QString::setNum(short n, int base)
7210 
7211     \overload
7212 */
7213 
7214 /*! \fn QString &QString::setNum(ushort n, int base)
7215 
7216     \overload
7217 */
7218 
7219 /*!
7220     \fn QString &QString::setNum(double n, char format, int precision)
7221     \overload
7222 
7223     Sets the string to the printed value of \a n, formatted according
7224     to the given \a format and \a precision, and returns a reference
7225     to the string.
7226 
7227     The \a format can be 'e', 'E', 'f', 'g' or 'G' (see
7228     \l{Argument Formats} for an explanation of the formats).
7229 
7230     The formatting always uses QLocale::C, i.e., English/UnitedStates.
7231     To get a localized string representation of a number, use
7232     QLocale::toString() with the appropriate locale.
7233 
7234     \sa number()
7235 */
7236 
7237 QString &QString::setNum(double n, char f, int prec)
7238 {
7239     return *this = number(n, f, prec);
7240 }
7241 
7242 /*!
7243     \fn QString &QString::setNum(float n, char format, int precision)
7244     \overload
7245 
7246     Sets the string to the printed value of \a n, formatted according
7247     to the given \a format and \a precision, and returns a reference
7248     to the string.
7249 
7250     The formatting always uses QLocale::C, i.e., English/UnitedStates.
7251     To get a localized string representation of a number, use
7252     QLocale::toString() with the appropriate locale.
7253 
7254     \sa number()
7255 */
7256 
7257 
7258 /*!
7259     \fn QString QString::number(long n, int base)
7260 
7261     Returns a string equivalent of the number \a n according to the
7262     specified \a base.
7263 
7264     The base is 10 by default and must be between 2
7265     and 36. For bases other than 10, \a n is treated as an
7266     unsigned integer.
7267 
7268     The formatting always uses QLocale::C, i.e., English/UnitedStates.
7269     To get a localized string representation of a number, use
7270     QLocale::toString() with the appropriate locale.
7271 
7272     \snippet qstring/main.cpp 35
7273 
7274     \sa setNum()
7275 */
7276 
7277 QString QString::number(long n, int base)
7278 {
7279     return number(qlonglong(n), base);
7280 }
7281 
7282 /*!
7283   \fn QString QString::number(ulong n, int base)
7284 
7285     \overload
7286 */
7287 QString QString::number(ulong n, int base)
7288 {
7289     return number(qulonglong(n), base);
7290 }
7291 
7292 /*!
7293     \overload
7294 */
7295 QString QString::number(int n, int base)
7296 {
7297     return number(qlonglong(n), base);
7298 }
7299 
7300 /*!
7301     \overload
7302 */
7303 QString QString::number(uint n, int base)
7304 {
7305     return number(qulonglong(n), base);
7306 }
7307 
7308 /*!
7309     \overload
7310 */
7311 QString QString::number(qlonglong n, int base)
7312 {
7313 #if defined(QT_CHECK_RANGE)
7314     if (base < 2 || base > 36) {
7315         qWarning("QString::setNum: Invalid base (%d)", base);
7316         base = 10;
7317     }
7318 #endif
7319     return QLocaleData::c()->longLongToString(n, -1, base);
7320 }
7321 
7322 /*!
7323     \overload
7324 */
7325 QString QString::number(qulonglong n, int base)
7326 {
7327 #if defined(QT_CHECK_RANGE)
7328     if (base < 2 || base > 36) {
7329         qWarning("QString::setNum: Invalid base (%d)", base);
7330         base = 10;
7331     }
7332 #endif
7333     return QLocaleData::c()->unsLongLongToString(n, -1, base);
7334 }
7335 
7336 
7337 /*!
7338     \fn QString QString::number(double n, char format, int precision)
7339 
7340     Returns a string equivalent of the number \a n, formatted
7341     according to the specified \a format and \a precision. See
7342     \l{Argument Formats} for details.
7343 
7344     Unlike QLocale::toString(), this function does not honor the
7345     user's locale settings.
7346 
7347     \sa setNum(), QLocale::toString()
7348 */
7349 QString QString::number(double n, char f, int prec)
7350 {
7351     QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
7352     uint flags = QLocaleData::ZeroPadExponent;
7353 
7354     if (qIsUpper(f))
7355         flags |= QLocaleData::CapitalEorX;
7356 
7357     switch (qToLower(f)) {
7358         case 'f':
7359             form = QLocaleData::DFDecimal;
7360             break;
7361         case 'e':
7362             form = QLocaleData::DFExponent;
7363             break;
7364         case 'g':
7365             form = QLocaleData::DFSignificantDigits;
7366             break;
7367         default:
7368 #if defined(QT_CHECK_RANGE)
7369             qWarning("QString::setNum: Invalid format char '%c'", f);
7370 #endif
7371             break;
7372     }
7373 
7374     return QLocaleData::c()->doubleToString(n, prec, form, -1, flags);
7375 }
7376 
7377 namespace {
7378 template<class ResultList, class StringSource>
7379 static ResultList splitString(const StringSource &source, QStringView sep,
7380                               Qt::SplitBehavior behavior, Qt::CaseSensitivity cs)
7381 {
7382     ResultList list;
7383     typename StringSource::size_type start = 0;
7384     typename StringSource::size_type end;
7385     typename StringSource::size_type extra = 0;
7386     while ((end = QtPrivate::findString(QStringView(source.constData(), source.size()), start + extra, sep, cs)) != -1) {
7387         if (start != end || behavior == Qt::KeepEmptyParts)
7388             list.append(source.mid(start, end - start));
7389         start = end + sep.size();
7390         extra = (sep.size() == 0 ? 1 : 0);
7391     }
7392     if (start != source.size() || behavior == Qt::KeepEmptyParts)
7393         list.append(source.mid(start));
7394     return list;
7395 }
7396 
7397 } // namespace
7398 
7399 /*!
7400     Splits the string into substrings wherever \a sep occurs, and
7401     returns the list of those strings. If \a sep does not match
7402     anywhere in the string, split() returns a single-element list
7403     containing this string.
7404 
7405     \a cs specifies whether \a sep should be matched case
7406     sensitively or case insensitively.
7407 
7408     If \a behavior is Qt::SkipEmptyParts, empty entries don't
7409     appear in the result. By default, empty entries are kept.
7410 
7411     Example:
7412 
7413     \snippet qstring/main.cpp 62
7414 
7415     If \a sep is empty, split() returns an empty string, followed
7416     by each of the string's characters, followed by another empty string:
7417 
7418     \snippet qstring/main.cpp 62-empty
7419 
7420     To understand this behavior, recall that the empty string matches
7421     everywhere, so the above is qualitatively the same as:
7422 
7423     \snippet qstring/main.cpp 62-slashes
7424 
7425     \sa QStringList::join(), section()
7426 
7427     \since 5.14
7428 */
7429 QStringList QString::split(const QString &sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7430 {
7431     return splitString<QStringList>(*this, sep, behavior, cs);
7432 }
7433 
7434 /*!
7435     \overload
7436     \since 5.14
7437 */
7438 QStringList QString::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7439 {
7440     return splitString<QStringList>(*this, QStringView(&sep, 1), behavior, cs);
7441 }
7442 
7443 /*!
7444     \fn QList<QStringView> QStringView::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7445     \fn QList<QStringView> QStringView::split(QStringView sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7446 
7447 
7448     Splits the string into substring views wherever \a sep occurs, and
7449     returns the list of those string views.
7450 
7451     See QString::split() for how \a sep, \a behavior and \a cs interact to form
7452     the result.
7453 
7454     \note All views are valid as long as this string is. Destroying this
7455     string will cause all views to be dangling pointers.
7456 
7457     \since 6.0
7458 */
7459 QList<QStringView> QStringView::split(QStringView sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7460 {
7461     return splitString<QList<QStringView>>(QStringView(*this), sep, behavior, cs);
7462 }
7463 
7464 QList<QStringView> QStringView::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7465 {
7466     return split(QStringView(&sep, 1), behavior, cs);
7467 }
7468 
7469 #if QT_CONFIG(regularexpression)
7470 namespace {
7471 template<class ResultList, typename String>
7472 static ResultList splitString(const String &source, const QRegularExpression &re,
7473                               Qt::SplitBehavior behavior)
7474 {
7475     ResultList list;
7476     if (!re.isValid()) {
7477         qWarning("QString::split: invalid QRegularExpression object");
7478         return list;
7479     }
7480 
7481     qsizetype start = 0;
7482     qsizetype end = 0;
7483     QRegularExpressionMatchIterator iterator = re.globalMatch(source);
7484     while (iterator.hasNext()) {
7485         QRegularExpressionMatch match = iterator.next();
7486         end = match.capturedStart();
7487         if (start != end || behavior == Qt::KeepEmptyParts)
7488             list.append(source.mid(start, end - start));
7489         start = match.capturedEnd();
7490     }
7491 
7492     if (start != source.size() || behavior == Qt::KeepEmptyParts)
7493         list.append(source.mid(start));
7494 
7495     return list;
7496 }
7497 } // namespace
7498 
7499 /*!
7500     \overload
7501     \since 5.14
7502 
7503     Splits the string into substrings wherever the regular expression
7504     \a re matches, and returns the list of those strings. If \a re
7505     does not match anywhere in the string, split() returns a
7506     single-element list containing this string.
7507 
7508     Here is an example where we extract the words in a sentence
7509     using one or more whitespace characters as the separator:
7510 
7511     \snippet qstring/main.cpp 90
7512 
7513     Here is a similar example, but this time we use any sequence of
7514     non-word characters as the separator:
7515 
7516     \snippet qstring/main.cpp 91
7517 
7518     Here is a third example where we use a zero-length assertion,
7519     \b{\\b} (word boundary), to split the string into an
7520     alternating sequence of non-word and word tokens:
7521 
7522     \snippet qstring/main.cpp 92
7523 
7524     \sa QStringList::join(), section()
7525 */
7526 QStringList QString::split(const QRegularExpression &re, Qt::SplitBehavior behavior) const
7527 {
7528     return splitString<QStringList>(*this, re, behavior);
7529 }
7530 
7531 /*!
7532     \since 6.0
7533 
7534     Splits the string into substring views wherever the regular expression \a re
7535     matches, and returns the list of those strings. If \a re does not match
7536     anywhere in the string, split() returns a single-element list containing
7537     this string as view.
7538 
7539     \note The views in the returned list are sub-views of this view; as such,
7540     they reference the same data as it and only remain valid for as long as that
7541     data remains live.
7542 */
7543 QList<QStringView> QStringView::split(const QRegularExpression &re, Qt::SplitBehavior behavior) const
7544 {
7545     return splitString<QList<QStringView>>(*this, re, behavior);
7546 }
7547 
7548 #endif // QT_CONFIG(regularexpression)
7549 
7550 /*!
7551     \enum QString::NormalizationForm
7552 
7553     This enum describes the various normalized forms of Unicode text.
7554 
7555     \value NormalizationForm_D  Canonical Decomposition
7556     \value NormalizationForm_C  Canonical Decomposition followed by Canonical Composition
7557     \value NormalizationForm_KD  Compatibility Decomposition
7558     \value NormalizationForm_KC  Compatibility Decomposition followed by Canonical Composition
7559 
7560     \sa normalized(),
7561         {http://www.unicode.org/reports/tr15/}{Unicode Standard Annex #15}
7562 */
7563 
7564 /*!
7565     \since 4.5
7566 
7567     Returns a copy of this string repeated the specified number of \a times.
7568 
7569     If \a times is less than 1, an empty string is returned.
7570 
7571     Example:
7572 
7573     \snippet code/src_corelib_text_qstring.cpp 8
7574 */
7575 QString QString::repeated(qsizetype times) const
7576 {
7577     if (d.size == 0)
7578         return *this;
7579 
7580     if (times <= 1) {
7581         if (times == 1)
7582             return *this;
7583         return QString();
7584     }
7585 
7586     const qsizetype resultSize = times * d.size;
7587 
7588     QString result;
7589     result.reserve(resultSize);
7590     if (result.capacity() != resultSize)
7591         return QString(); // not enough memory
7592 
7593     memcpy(result.d.data(), d.data(), d.size * sizeof(QChar));
7594 
7595     qsizetype sizeSoFar = d.size;
7596     char16_t *end = result.d.data() + sizeSoFar;
7597 
7598     const qsizetype halfResultSize = resultSize >> 1;
7599     while (sizeSoFar <= halfResultSize) {
7600         memcpy(end, result.d.data(), sizeSoFar * sizeof(QChar));
7601         end += sizeSoFar;
7602         sizeSoFar <<= 1;
7603     }
7604     memcpy(end, result.d.data(), (resultSize - sizeSoFar) * sizeof(QChar));
7605     result.d.data()[resultSize] = '\0';
7606     result.d.size = resultSize;
7607     return result;
7608 }
7609 
7610 void qt_string_normalize(QString *data, QString::NormalizationForm mode, QChar::UnicodeVersion version, qsizetype from)
7611 {
7612     const QChar *p = data->constData() + from;
7613     if (isAscii(p, p + data->length() - from))
7614         return;
7615     if (p > data->constData() + from)
7616         from = p - data->constData() - 1;   // need one before the non-ASCII to perform NFC
7617 
7618     if (version == QChar::Unicode_Unassigned) {
7619         version = QChar::currentUnicodeVersion();
7620     } else if (int(version) <= NormalizationCorrectionsVersionMax) {
7621         const QString &s = *data;
7622         QChar *d = nullptr;
7623         for (int i = 0; i < NumNormalizationCorrections; ++i) {
7624             const NormalizationCorrection &n = uc_normalization_corrections[i];
7625             if (n.version > version) {
7626                 qsizetype pos = from;
7627                 if (QChar::requiresSurrogates(n.ucs4)) {
7628                     char16_t ucs4High = QChar::highSurrogate(n.ucs4);
7629                     char16_t ucs4Low = QChar::lowSurrogate(n.ucs4);
7630                     char16_t oldHigh = QChar::highSurrogate(n.old_mapping);
7631                     char16_t oldLow = QChar::lowSurrogate(n.old_mapping);
7632                     while (pos < s.length() - 1) {
7633                         if (s.at(pos).unicode() == ucs4High && s.at(pos + 1).unicode() == ucs4Low) {
7634                             if (!d)
7635                                 d = data->data();
7636                             d[pos] = QChar(oldHigh);
7637                             d[++pos] = QChar(oldLow);
7638                         }
7639                         ++pos;
7640                     }
7641                 } else {
7642                     while (pos < s.length()) {
7643                         if (s.at(pos).unicode() == n.ucs4) {
7644                             if (!d)
7645                                 d = data->data();
7646                             d[pos] = QChar(n.old_mapping);
7647                         }
7648                         ++pos;
7649                     }
7650                 }
7651             }
7652         }
7653     }
7654 
7655     if (normalizationQuickCheckHelper(data, mode, from, &from))
7656         return;
7657 
7658     decomposeHelper(data, mode < QString::NormalizationForm_KD, version, from);
7659 
7660     canonicalOrderHelper(data, version, from);
7661 
7662     if (mode == QString::NormalizationForm_D || mode == QString::NormalizationForm_KD)
7663         return;
7664 
7665     composeHelper(data, version, from);
7666 }
7667 
7668 /*!
7669     Returns the string in the given Unicode normalization \a mode,
7670     according to the given \a version of the Unicode standard.
7671 */
7672 QString QString::normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version) const
7673 {
7674     QString copy = *this;
7675     qt_string_normalize(&copy, mode, version, 0);
7676     return copy;
7677 }
7678 
7679 
7680 struct ArgEscapeData
7681 {
7682     int min_escape;            // lowest escape sequence number
7683     int occurrences;           // number of occurrences of the lowest escape sequence number
7684     int locale_occurrences;    // number of occurrences of the lowest escape sequence number that
7685                                // contain 'L'
7686     int escape_len;            // total length of escape sequences which will be replaced
7687 };
7688 
7689 static ArgEscapeData findArgEscapes(QStringView s)
7690 {
7691     const QChar *uc_begin = s.begin();
7692     const QChar *uc_end = s.end();
7693 
7694     ArgEscapeData d;
7695 
7696     d.min_escape = INT_MAX;
7697     d.occurrences = 0;
7698     d.escape_len = 0;
7699     d.locale_occurrences = 0;
7700 
7701     const QChar *c = uc_begin;
7702     while (c != uc_end) {
7703         while (c != uc_end && c->unicode() != '%')
7704             ++c;
7705 
7706         if (c == uc_end)
7707             break;
7708         const QChar *escape_start = c;
7709         if (++c == uc_end)
7710             break;
7711 
7712         bool locale_arg = false;
7713         if (c->unicode() == 'L') {
7714             locale_arg = true;
7715             if (++c == uc_end)
7716                 break;
7717         }
7718 
7719         int escape = c->digitValue();
7720         if (escape == -1)
7721             continue;
7722 
7723         ++c;
7724 
7725         if (c != uc_end) {
7726             int next_escape = c->digitValue();
7727             if (next_escape != -1) {
7728                 escape = (10 * escape) + next_escape;
7729                 ++c;
7730             }
7731         }
7732 
7733         if (escape > d.min_escape)
7734             continue;
7735 
7736         if (escape < d.min_escape) {
7737             d.min_escape = escape;
7738             d.occurrences = 0;
7739             d.escape_len = 0;
7740             d.locale_occurrences = 0;
7741         }
7742 
7743         ++d.occurrences;
7744         if (locale_arg)
7745             ++d.locale_occurrences;
7746         d.escape_len += c - escape_start;
7747     }
7748     return d;
7749 }
7750 
7751 static QString replaceArgEscapes(QStringView s, const ArgEscapeData &d, int field_width,
7752                                  QStringView arg, QStringView larg, QChar fillChar)
7753 {
7754     const QChar *uc_begin = s.begin();
7755     const QChar *uc_end = s.end();
7756 
7757     int abs_field_width = qAbs(field_width);
7758     qsizetype result_len = s.length()
7759                      - d.escape_len
7760                      + (d.occurrences - d.locale_occurrences)
7761                      *qMax(abs_field_width, arg.length())
7762                      + d.locale_occurrences
7763                      *qMax(abs_field_width, larg.length());
7764 
7765     QString result(result_len, Qt::Uninitialized);
7766     QChar *result_buff = const_cast<QChar *>(result.unicode());
7767 
7768     QChar *rc = result_buff;
7769     const QChar *c = uc_begin;
7770     int repl_cnt = 0;
7771     while (c != uc_end) {
7772         /* We don't have to check if we run off the end of the string with c,
7773            because as long as d.occurrences > 0 we KNOW there are valid escape
7774            sequences. */
7775 
7776         const QChar *text_start = c;
7777 
7778         while (c->unicode() != '%')
7779             ++c;
7780 
7781         const QChar *escape_start = c++;
7782 
7783         bool locale_arg = false;
7784         if (c->unicode() == 'L') {
7785             locale_arg = true;
7786             ++c;
7787         }
7788 
7789         int escape = c->digitValue();
7790         if (escape != -1) {
7791             if (c + 1 != uc_end && (c + 1)->digitValue() != -1) {
7792                 escape = (10 * escape) + (c + 1)->digitValue();
7793                 ++c;
7794             }
7795         }
7796 
7797         if (escape != d.min_escape) {
7798             memcpy(rc, text_start, (c - text_start)*sizeof(QChar));
7799             rc += c - text_start;
7800         }
7801         else {
7802             ++c;
7803 
7804             memcpy(rc, text_start, (escape_start - text_start)*sizeof(QChar));
7805             rc += escape_start - text_start;
7806 
7807             uint pad_chars;
7808             if (locale_arg)
7809                 pad_chars = qMax(abs_field_width, larg.length()) - larg.length();
7810             else
7811                 pad_chars = qMax(abs_field_width, arg.length()) - arg.length();
7812 
7813             if (field_width > 0) { // left padded
7814                 for (uint i = 0; i < pad_chars; ++i)
7815                     *rc++ = fillChar;
7816             }
7817 
7818             if (locale_arg) {
7819                 memcpy(rc, larg.data(), larg.length()*sizeof(QChar));
7820                 rc += larg.length();
7821             }
7822             else {
7823                 memcpy(rc, arg.data(), arg.length()*sizeof(QChar));
7824                 rc += arg.length();
7825             }
7826 
7827             if (field_width < 0) { // right padded
7828                 for (uint i = 0; i < pad_chars; ++i)
7829                     *rc++ = fillChar;
7830             }
7831 
7832             if (++repl_cnt == d.occurrences) {
7833                 memcpy(rc, c, (uc_end - c)*sizeof(QChar));
7834                 rc += uc_end - c;
7835                 Q_ASSERT(rc - result_buff == result_len);
7836                 c = uc_end;
7837             }
7838         }
7839     }
7840     Q_ASSERT(rc == result_buff + result_len);
7841 
7842     return result;
7843 }
7844 
7845 #if QT_STRINGVIEW_LEVEL < 2
7846 /*!
7847   Returns a copy of this string with the lowest numbered place marker
7848   replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7849 
7850   \a fieldWidth specifies the minimum amount of space that argument \a
7851   a shall occupy. If \a a requires less space than \a fieldWidth, it
7852   is padded to \a fieldWidth with character \a fillChar.  A positive
7853   \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7854   produces left-aligned text.
7855 
7856   This example shows how we might create a \c status string for
7857   reporting progress while processing a list of files:
7858 
7859   \snippet qstring/main.cpp 11
7860 
7861   First, \c arg(i) replaces \c %1. Then \c arg(total) replaces \c
7862   %2. Finally, \c arg(fileName) replaces \c %3.
7863 
7864   One advantage of using arg() over asprintf() is that the order of the
7865   numbered place markers can change, if the application's strings are
7866   translated into other languages, but each arg() will still replace
7867   the lowest numbered unreplaced place marker, no matter where it
7868   appears. Also, if place marker \c %i appears more than once in the
7869   string, the arg() replaces all of them.
7870 
7871   If there is no unreplaced place marker remaining, a warning message
7872   is output and the result is undefined. Place marker numbers must be
7873   in the range 1 to 99.
7874 */
7875 QString QString::arg(const QString &a, int fieldWidth, QChar fillChar) const
7876 {
7877     return arg(qToStringViewIgnoringNull(a), fieldWidth, fillChar);
7878 }
7879 #endif // QT_STRINGVIEW_LEVEL < 2
7880 
7881 /*!
7882     \overload
7883     \since 5.10
7884 
7885     Returns a copy of this string with the lowest-numbered place-marker
7886     replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7887 
7888     \a fieldWidth specifies the minimum amount of space that \a a
7889     shall occupy. If \a a requires less space than \a fieldWidth, it
7890     is padded to \a fieldWidth with character \a fillChar.  A positive
7891     \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7892     produces left-aligned text.
7893 
7894     This example shows how we might create a \c status string for
7895     reporting progress while processing a list of files:
7896 
7897     \snippet qstring/main.cpp 11-qstringview
7898 
7899     First, \c arg(i) replaces \c %1. Then \c arg(total) replaces \c
7900     %2. Finally, \c arg(fileName) replaces \c %3.
7901 
7902     One advantage of using arg() over asprintf() is that the order of the
7903     numbered place markers can change, if the application's strings are
7904     translated into other languages, but each arg() will still replace
7905     the lowest-numbered unreplaced place-marker, no matter where it
7906     appears. Also, if place-marker \c %i appears more than once in the
7907     string, arg() replaces all of them.
7908 
7909     If there is no unreplaced place-marker remaining, a warning message
7910     is printed and the result is undefined. Place-marker numbers must be
7911     in the range 1 to 99.
7912 */
7913 QString QString::arg(QStringView a, int fieldWidth, QChar fillChar) const
7914 {
7915     ArgEscapeData d = findArgEscapes(*this);
7916 
7917     if (Q_UNLIKELY(d.occurrences == 0)) {
7918         qWarning("QString::arg: Argument missing: %ls, %ls", qUtf16Printable(*this),
7919                   qUtf16Printable(a.toString()));
7920         return *this;
7921     }
7922     return replaceArgEscapes(*this, d, fieldWidth, a, a, fillChar);
7923 }
7924 
7925 /*!
7926     \overload
7927     \since 5.10
7928 
7929     Returns a copy of this string with the lowest-numbered place-marker
7930     replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7931 
7932     \a fieldWidth specifies the minimum amount of space that \a a
7933     shall occupy. If \a a requires less space than \a fieldWidth, it
7934     is padded to \a fieldWidth with character \a fillChar.  A positive
7935     \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7936     produces left-aligned text.
7937 
7938     One advantage of using arg() over asprintf() is that the order of the
7939     numbered place markers can change, if the application's strings are
7940     translated into other languages, but each arg() will still replace
7941     the lowest-numbered unreplaced place-marker, no matter where it
7942     appears. Also, if place-marker \c %i appears more than once in the
7943     string, arg() replaces all of them.
7944 
7945     If there is no unreplaced place-marker remaining, a warning message
7946     is printed and the result is undefined. Place-marker numbers must be
7947     in the range 1 to 99.
7948 */
7949 QString QString::arg(QLatin1String a, int fieldWidth, QChar fillChar) const
7950 {
7951     QVarLengthArray<char16_t> utf16(a.size());
7952     qt_from_latin1(utf16.data(), a.data(), a.size());
7953     return arg(QStringView(utf16.data(), utf16.size()), fieldWidth, fillChar);
7954 }
7955 
7956 /*! \fn QString QString::arg(int a, int fieldWidth, int base, QChar fillChar) const
7957   \overload arg()
7958 
7959   The \a a argument is expressed in base \a base, which is 10 by
7960   default and must be between 2 and 36. For bases other than 10, \a a
7961   is treated as an unsigned integer.
7962 
7963   \a fieldWidth specifies the minimum amount of space that \a a is
7964   padded to and filled with the character \a fillChar. A positive
7965   value produces right-aligned text; a negative value produces
7966   left-aligned text.
7967 
7968   The '%' can be followed by an 'L', in which case the sequence is
7969   replaced with a localized representation of \a a. The conversion
7970   uses the default locale, set by QLocale::setDefault(). If no default
7971   locale was specified, the "C" locale is used. The 'L' flag is
7972   ignored if \a base is not 10.
7973 
7974   \snippet qstring/main.cpp 12
7975   \snippet qstring/main.cpp 14
7976 
7977   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7978   used. For negative numbers, zero padding might appear before the
7979   minus sign.
7980 */
7981 
7982 /*! \fn QString QString::arg(uint a, int fieldWidth, int base, QChar fillChar) const
7983   \overload arg()
7984 
7985   The \a base argument specifies the base to use when converting the
7986   integer \a a into a string. The base must be between 2 and 36.
7987 
7988   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7989   used. For negative numbers, zero padding might appear before the
7990   minus sign.
7991 */
7992 
7993 /*! \fn QString QString::arg(long a, int fieldWidth, int base, QChar fillChar) const
7994   \overload arg()
7995 
7996   \a fieldWidth specifies the minimum amount of space that \a a is
7997   padded to and filled with the character \a fillChar. A positive
7998   value produces right-aligned text; a negative value produces
7999   left-aligned text.
8000 
8001   The \a a argument is expressed in the given \a base, which is 10 by
8002   default and must be between 2 and 36.
8003 
8004   The '%' can be followed by an 'L', in which case the sequence is
8005   replaced with a localized representation of \a a. The conversion
8006   uses the default locale. The default locale is determined from the
8007   system's locale settings at application startup. It can be changed
8008   using QLocale::setDefault(). The 'L' flag is ignored if \a base is
8009   not 10.
8010 
8011   \snippet qstring/main.cpp 12
8012   \snippet qstring/main.cpp 14
8013 
8014   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8015   used. For negative numbers, zero padding might appear before the
8016   minus sign.
8017 */
8018 
8019 /*! \fn QString QString::arg(ulong a, int fieldWidth, int base, QChar fillChar) const
8020   \overload arg()
8021 
8022   \a fieldWidth specifies the minimum amount of space that \a a is
8023   padded to and filled with the character \a fillChar. A positive
8024   value produces right-aligned text; a negative value produces
8025   left-aligned text.
8026 
8027   The \a base argument specifies the base to use when converting the
8028   integer \a a to a string. The base must be between 2 and 36, with 8
8029   giving octal, 10 decimal, and 16 hexadecimal numbers.
8030 
8031   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8032   used. For negative numbers, zero padding might appear before the
8033   minus sign.
8034 */
8035 
8036 /*!
8037   \overload arg()
8038 
8039   \a fieldWidth specifies the minimum amount of space that \a a is
8040   padded to and filled with the character \a fillChar. A positive
8041   value produces right-aligned text; a negative value produces
8042   left-aligned text.
8043 
8044   The \a base argument specifies the base to use when converting the
8045   integer \a a into a string. The base must be between 2 and 36, with
8046   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
8047 
8048   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8049   used. For negative numbers, zero padding might appear before the
8050   minus sign.
8051 */
8052 QString QString::arg(qlonglong a, int fieldWidth, int base, QChar fillChar) const
8053 {
8054     ArgEscapeData d = findArgEscapes(*this);
8055 
8056     if (d.occurrences == 0) {
8057         qWarning() << "QString::arg: Argument missing:" << *this << ',' << a;
8058         return *this;
8059     }
8060 
8061     unsigned flags = QLocaleData::NoFlags;
8062     if (fillChar == QLatin1Char('0'))
8063         flags = QLocaleData::ZeroPadded;
8064 
8065     QString arg;
8066     if (d.occurrences > d.locale_occurrences)
8067         arg = QLocaleData::c()->longLongToString(a, -1, base, fieldWidth, flags);
8068 
8069     QString locale_arg;
8070     if (d.locale_occurrences > 0) {
8071         QLocale locale;
8072         if (!(locale.numberOptions() & QLocale::OmitGroupSeparator))
8073             flags |= QLocaleData::GroupDigits;
8074         locale_arg = locale.d->m_data->longLongToString(a, -1, base, fieldWidth, flags);
8075     }
8076 
8077     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8078 }
8079 
8080 /*!
8081   \overload arg()
8082 
8083   \a fieldWidth specifies the minimum amount of space that \a a is
8084   padded to and filled with the character \a fillChar. A positive
8085   value produces right-aligned text; a negative value produces
8086   left-aligned text.
8087 
8088   The \a base argument specifies the base to use when converting the
8089   integer \a a into a string. \a base must be between 2 and 36, with 8
8090   giving octal, 10 decimal, and 16 hexadecimal numbers.
8091 
8092   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8093   used. For negative numbers, zero padding might appear before the
8094   minus sign.
8095 */
8096 QString QString::arg(qulonglong a, int fieldWidth, int base, QChar fillChar) const
8097 {
8098     ArgEscapeData d = findArgEscapes(*this);
8099 
8100     if (d.occurrences == 0) {
8101         qWarning() << "QString::arg: Argument missing:" << *this << ',' << a;
8102         return *this;
8103     }
8104 
8105     unsigned flags = QLocaleData::NoFlags;
8106     if (fillChar == QLatin1Char('0'))
8107         flags = QLocaleData::ZeroPadded;
8108 
8109     QString arg;
8110     if (d.occurrences > d.locale_occurrences)
8111         arg = QLocaleData::c()->unsLongLongToString(a, -1, base, fieldWidth, flags);
8112 
8113     QString locale_arg;
8114     if (d.locale_occurrences > 0) {
8115         QLocale locale;
8116         if (!(locale.numberOptions() & QLocale::OmitGroupSeparator))
8117             flags |= QLocaleData::GroupDigits;
8118         locale_arg = locale.d->m_data->unsLongLongToString(a, -1, base, fieldWidth, flags);
8119     }
8120 
8121     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8122 }
8123 
8124 /*!
8125   \overload arg()
8126 
8127   \fn QString QString::arg(short a, int fieldWidth, int base, QChar fillChar) const
8128 
8129   \a fieldWidth specifies the minimum amount of space that \a a is
8130   padded to and filled with the character \a fillChar. A positive
8131   value produces right-aligned text; a negative value produces
8132   left-aligned text.
8133 
8134   The \a base argument specifies the base to use when converting the
8135   integer \a a into a string. The base must be between 2 and 36, with
8136   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
8137 
8138   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8139   used. For negative numbers, zero padding might appear before the
8140   minus sign.
8141 */
8142 
8143 /*!
8144   \fn QString QString::arg(ushort a, int fieldWidth, int base, QChar fillChar) const
8145   \overload arg()
8146 
8147   \a fieldWidth specifies the minimum amount of space that \a a is
8148   padded to and filled with the character \a fillChar. A positive
8149   value produces right-aligned text; a negative value produces
8150   left-aligned text.
8151 
8152   The \a base argument specifies the base to use when converting the
8153   integer \a a into a string. The base must be between 2 and 36, with
8154   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
8155 
8156   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8157   used. For negative numbers, zero padding might appear before the
8158   minus sign.
8159 */
8160 
8161 /*!
8162     \overload arg()
8163 */
8164 QString QString::arg(QChar a, int fieldWidth, QChar fillChar) const
8165 {
8166     return arg(QStringView{&a, 1}, fieldWidth, fillChar);
8167 }
8168 
8169 /*!
8170   \overload arg()
8171 
8172   The \a a argument is interpreted as a Latin-1 character.
8173 */
8174 QString QString::arg(char a, int fieldWidth, QChar fillChar) const
8175 {
8176     return arg(QLatin1Char(a), fieldWidth, fillChar);
8177 }
8178 
8179 /*!
8180   \fn QString QString::arg(double a, int fieldWidth, char format, int precision, QChar fillChar) const
8181   \overload arg()
8182 
8183   Argument \a a is formatted according to the specified \a format and
8184   \a precision. See \l{Argument Formats} for details.
8185 
8186   \a fieldWidth specifies the minimum amount of space that \a a is
8187   padded to and filled with the character \a fillChar.  A positive
8188   value produces right-aligned text; a negative value produces
8189   left-aligned text.
8190 
8191   \snippet code/src_corelib_text_qstring.cpp 2
8192 
8193   The '%' can be followed by an 'L', in which case the sequence is
8194   replaced with a localized representation of \a a. The conversion
8195   uses the default locale, set by QLocale::setDefault(). If no
8196   default locale was specified, the "C" locale is used.
8197 
8198   If \a fillChar is '0' (the number 0, ASCII 48), this function will
8199   use the locale's zero to pad. For negative numbers, the zero padding
8200   will probably appear before the minus sign.
8201 
8202   \sa QLocale::toString()
8203 */
8204 QString QString::arg(double a, int fieldWidth, char fmt, int prec, QChar fillChar) const
8205 {
8206     ArgEscapeData d = findArgEscapes(*this);
8207 
8208     if (d.occurrences == 0) {
8209         qWarning("QString::arg: Argument missing: %s, %g", toLocal8Bit().data(), a);
8210         return *this;
8211     }
8212 
8213     unsigned flags = QLocaleData::NoFlags;
8214     if (fillChar == QLatin1Char('0'))
8215         flags |= QLocaleData::ZeroPadded;
8216 
8217     if (qIsUpper(fmt))
8218         flags |= QLocaleData::CapitalEorX;
8219 
8220     QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
8221     switch (qToLower(fmt)) {
8222     case 'f':
8223         form = QLocaleData::DFDecimal;
8224         break;
8225     case 'e':
8226         form = QLocaleData::DFExponent;
8227         break;
8228     case 'g':
8229         form = QLocaleData::DFSignificantDigits;
8230         break;
8231     default:
8232 #if defined(QT_CHECK_RANGE)
8233         qWarning("QString::arg: Invalid format char '%c'", fmt);
8234 #endif
8235         break;
8236     }
8237 
8238     QString arg;
8239     if (d.occurrences > d.locale_occurrences)
8240         arg = QLocaleData::c()->doubleToString(a, prec, form, fieldWidth, flags | QLocaleData::ZeroPadExponent);
8241 
8242     QString locale_arg;
8243     if (d.locale_occurrences > 0) {
8244         QLocale locale;
8245 
8246         const QLocale::NumberOptions numberOptions = locale.numberOptions();
8247         if (!(numberOptions & QLocale::OmitGroupSeparator))
8248             flags |= QLocaleData::GroupDigits;
8249         if (!(numberOptions & QLocale::OmitLeadingZeroInExponent))
8250             flags |= QLocaleData::ZeroPadExponent;
8251         if (numberOptions & QLocale::IncludeTrailingZeroesAfterDot)
8252             flags |= QLocaleData::AddTrailingZeroes;
8253         locale_arg = locale.d->m_data->doubleToString(a, prec, form, fieldWidth, flags);
8254     }
8255 
8256     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8257 }
8258 
8259 static inline char16_t to_unicode(const QChar c) { return c.unicode(); }
8260 static inline char16_t to_unicode(const char c) { return QLatin1Char{c}.unicode(); }
8261 
8262 template <typename Char>
8263 static int getEscape(const Char *uc, qsizetype *pos, qsizetype len, int maxNumber = 999)
8264 {
8265     int i = *pos;
8266     ++i;
8267     if (i < len && uc[i] == QLatin1Char('L'))
8268         ++i;
8269     if (i < len) {
8270         int escape = to_unicode(uc[i]) - '0';
8271         if (uint(escape) >= 10U)
8272             return -1;
8273         ++i;
8274         while (i < len) {
8275             int digit = to_unicode(uc[i]) - '0';
8276             if (uint(digit) >= 10U)
8277                 break;
8278             escape = (escape * 10) + digit;
8279             ++i;
8280         }
8281         if (escape <= maxNumber) {
8282             *pos = i;
8283             return escape;
8284         }
8285     }
8286     return -1;
8287 }
8288 
8289 /*
8290     Algorithm for multiArg:
8291 
8292     1. Parse the string as a sequence of verbatim text and placeholders (%L?\d{,3}).
8293        The L is parsed and accepted for compatibility with non-multi-arg, but since
8294        multiArg only accepts strings as replacements, the localization request can
8295        be safely ignored.
8296     2. The result of step (1) is a list of (string-ref,int)-tuples. The string-ref
8297        either points at text to be copied verbatim (in which case the int is -1),
8298        or, initially, at the textual representation of the placeholder. In that case,
8299        the int contains the numerical number as parsed from the placeholder.
8300     3. Next, collect all the non-negative ints found, sort them in ascending order and
8301        remove duplicates.
8302        3a. If the result has more entires than multiArg() was given replacement strings,
8303            we have found placeholders we can't satisfy with replacement strings. That is
8304            fine (there could be another .arg() call coming after this one), so just
8305            truncate the result to the number of actual multiArg() replacement strings.
8306        3b. If the result has less entries than multiArg() was given replacement strings,
8307            the string is missing placeholders. This is an error that the user should be
8308            warned about.
8309     4. The result of step (3) is a mapping from the index of any replacement string to
8310        placeholder number. This is the wrong way around, but since placeholder
8311        numbers could get as large as 999, while we typically don't have more than 9
8312        replacement strings, we trade 4K of sparsely-used memory for doing a reverse lookup
8313        each time we need to map a placeholder number to a replacement string index
8314        (that's a linear search; but still *much* faster than using an associative container).
8315     5. Next, for each of the tuples found in step (1), do the following:
8316        5a. If the int is negative, do nothing.
8317        5b. Otherwise, if the int is found in the result of step (3) at index I, replace
8318            the string-ref with a string-ref for the (complete) I'th replacement string.
8319        5c. Otherwise, do nothing.
8320     6. Concatenate all string refs into a single result string.
8321 */
8322 
8323 namespace {
8324 struct Part
8325 {
8326     Part() = default; // for QVarLengthArray; do not use
8327     constexpr Part(QStringView s, int num = -1)
8328         : tag{QtPrivate::ArgBase::U16}, number{num}, data{s.utf16()}, size{s.size()} {}
8329     constexpr Part(QLatin1String s, int num = -1)
8330         : tag{QtPrivate::ArgBase::L1}, number{num}, data{s.data()}, size{s.size()} {}
8331 
8332     void reset(QStringView s) noexcept { *this = {s, number}; }
8333     void reset(QLatin1String s) noexcept { *this = {s, number}; }
8334 
8335     QtPrivate::ArgBase::Tag tag;
8336     int number;
8337     const void *data;
8338     qsizetype size;
8339 };
8340 } // unnamed namespace
8341 
8342 Q_DECLARE_TYPEINFO(Part, Q_PRIMITIVE_TYPE);
8343 
8344 namespace {
8345 
8346 enum { ExpectedParts = 32 };
8347 
8348 typedef QVarLengthArray<Part, ExpectedParts> ParseResult;
8349 typedef QVarLengthArray<int, ExpectedParts/2> ArgIndexToPlaceholderMap;
8350 
8351 template <typename StringView>
8352 static ParseResult parseMultiArgFormatString(StringView s)
8353 {
8354     ParseResult result;
8355 
8356     const auto uc = s.data();
8357     const auto len = s.size();
8358     const auto end = len - 1;
8359     qsizetype i = 0;
8360     qsizetype last = 0;
8361 
8362     while (i < end) {
8363         if (uc[i] == QLatin1Char('%')) {
8364             qsizetype percent = i;
8365             int number = getEscape(uc, &i, len);
8366             if (number != -1) {
8367                 if (last != percent)
8368                     result.push_back(Part{s.mid(last, percent - last)}); // literal text (incl. failed placeholders)
8369                 result.push_back(Part{s.mid(percent, i - percent), number});  // parsed placeholder
8370                 last = i;
8371                 continue;
8372             }
8373         }
8374         ++i;
8375     }
8376 
8377     if (last < len)
8378         result.push_back(Part{s.mid(last, len - last)}); // trailing literal text
8379 
8380     return result;
8381 }
8382 
8383 static ArgIndexToPlaceholderMap makeArgIndexToPlaceholderMap(const ParseResult &parts)
8384 {
8385     ArgIndexToPlaceholderMap result;
8386 
8387     for (Part part : parts) {
8388         if (part.number >= 0)
8389             result.push_back(part.number);
8390     }
8391 
8392     std::sort(result.begin(), result.end());
8393     result.erase(std::unique(result.begin(), result.end()),
8394                  result.end());
8395 
8396     return result;
8397 }
8398 
8399 static qsizetype resolveStringRefsAndReturnTotalSize(ParseResult &parts, const ArgIndexToPlaceholderMap &argIndexToPlaceholderMap, const QtPrivate::ArgBase *args[])
8400 {
8401     using namespace QtPrivate;
8402     qsizetype totalSize = 0;
8403     for (Part &part : parts) {
8404         if (part.number != -1) {
8405             const auto it = std::find(argIndexToPlaceholderMap.begin(), argIndexToPlaceholderMap.end(), part.number);
8406             if (it != argIndexToPlaceholderMap.end()) {
8407                 const auto &arg = *args[it - argIndexToPlaceholderMap.begin()];
8408                 switch (arg.tag) {
8409                 case ArgBase::L1:
8410                     part.reset(static_cast<const QLatin1StringArg&>(arg).string);
8411                     break;
8412                 case ArgBase::U8:
8413                     Q_UNREACHABLE(); // waiting for QUtf8String...
8414                     break;
8415                 case ArgBase::U16:
8416                     part.reset(static_cast<const QStringViewArg&>(arg).string);
8417                     break;
8418                 }
8419             }
8420         }
8421         totalSize += part.size;
8422     }
8423     return totalSize;
8424 }
8425 
8426 } // unnamed namespace
8427 
8428 Q_ALWAYS_INLINE QString to_string(QLatin1String s) noexcept { return s; }
8429 Q_ALWAYS_INLINE QString to_string(QStringView s) noexcept { return s.toString(); }
8430 
8431 template <typename StringView>
8432 static QString argToQStringImpl(StringView pattern, size_t numArgs, const QtPrivate::ArgBase **args)
8433 {
8434     // Step 1-2 above
8435     ParseResult parts = parseMultiArgFormatString(pattern);
8436 
8437     // 3-4
8438     ArgIndexToPlaceholderMap argIndexToPlaceholderMap = makeArgIndexToPlaceholderMap(parts);
8439 
8440     if (static_cast<size_t>(argIndexToPlaceholderMap.size()) > numArgs) // 3a
8441         argIndexToPlaceholderMap.resize(qsizetype(numArgs));
8442     else if (Q_UNLIKELY(static_cast<size_t>(argIndexToPlaceholderMap.size()) < numArgs)) // 3b
8443         qWarning("QString::arg: %d argument(s) missing in %ls",
8444                  int(numArgs - argIndexToPlaceholderMap.size()), qUtf16Printable(to_string(pattern)));
8445 
8446     // 5
8447     const qsizetype totalSize = resolveStringRefsAndReturnTotalSize(parts, argIndexToPlaceholderMap, args);
8448 
8449     // 6:
8450     QString result(totalSize, Qt::Uninitialized);
8451     auto out = const_cast<QChar*>(result.constData());
8452 
8453     for (Part part : parts) {
8454         switch (part.tag) {
8455         case QtPrivate::ArgBase::L1:
8456             if (part.size) {
8457                 qt_from_latin1(reinterpret_cast<char16_t*>(out),
8458                                reinterpret_cast<const char*>(part.data), part.size);
8459             }
8460             break;
8461         case QtPrivate::ArgBase::U8:
8462             Q_UNREACHABLE(); // waiting for QUtf8String
8463             break;
8464         case QtPrivate::ArgBase::U16:
8465             if (part.size)
8466                 memcpy(out, part.data, part.size * sizeof(QChar));
8467             break;
8468         }
8469         out += part.size;
8470     }
8471 
8472     return result;
8473 }
8474 
8475 QString QtPrivate::argToQString(QStringView pattern, size_t n, const ArgBase **args)
8476 {
8477     return argToQStringImpl(pattern, n, args);
8478 }
8479 
8480 QString QtPrivate::argToQString(QLatin1String pattern, size_t n, const ArgBase **args)
8481 {
8482     return argToQStringImpl(pattern, n, args);
8483 }
8484 
8485 /*! \fn bool QString::isSimpleText() const
8486 
8487     \internal
8488 */
8489 bool QString::isSimpleText() const
8490 {
8491     const char16_t *p = d.data();
8492     const char16_t * const end = p + d.size;
8493     while (p < end) {
8494         char16_t uc = *p;
8495         // sort out regions of complex text formatting
8496         if (uc > 0x058f && (uc < 0x1100 || uc > 0xfb0f)) {
8497             return false;
8498         }
8499         p++;
8500     }
8501 
8502     return true;
8503 }
8504 
8505 /*! \fn bool QString::isRightToLeft() const
8506 
8507     Returns \c true if the string is read right to left.
8508 
8509     \sa QStringView::isRightToLeft()
8510 */
8511 bool QString::isRightToLeft() const
8512 {
8513     return QtPrivate::isRightToLeft(QStringView(*this));
8514 }
8515 
8516 /*!
8517     \fn bool QString::isValidUtf16() const noexcept
8518     \since 5.15
8519 
8520     Returns \c true if the string contains valid UTF-16 encoded data,
8521     or \c false otherwise.
8522 
8523     Note that this function does not perform any special validation of the
8524     data; it merely checks if it can be successfully decoded from UTF-16.
8525     The data is assumed to be in host byte order; the presence of a BOM
8526     is meaningless.
8527 
8528     \sa QStringView::isValidUtf16()
8529 */
8530 
8531 /*! \fn QChar *QString::data()
8532 
8533     Returns a pointer to the data stored in the QString. The pointer
8534     can be used to access and modify the characters that compose the
8535     string.
8536 
8537     Unlike constData() and unicode(), the returned data is always
8538     '\\0'-terminated.
8539 
8540     Example:
8541 
8542     \snippet qstring/main.cpp 19
8543 
8544     Note that the pointer remains valid only as long as the string is
8545     not modified by other means. For read-only access, constData() is
8546     faster because it never causes a \l{deep copy} to occur.
8547 
8548     \sa constData(), operator[]()
8549 */
8550 
8551 /*! \fn const QChar *QString::data() const
8552 
8553     \overload
8554 
8555     \note The returned string may not be '\\0'-terminated.
8556     Use size() to determine the length of the array.
8557 
8558     \sa fromRawData()
8559 */
8560 
8561 /*! \fn const QChar *QString::constData() const
8562 
8563     Returns a pointer to the data stored in the QString. The pointer
8564     can be used to access the characters that compose the string.
8565 
8566     Note that the pointer remains valid only as long as the string is
8567     not modified.
8568 
8569     \note The returned string may not be '\\0'-terminated.
8570     Use size() to determine the length of the array.
8571 
8572     \sa data(), operator[](), fromRawData()
8573 */
8574 
8575 /*! \fn void QString::push_front(const QString &other)
8576 
8577     This function is provided for STL compatibility, prepending the
8578     given \a other string to the beginning of this string. It is
8579     equivalent to \c prepend(other).
8580 
8581     \sa prepend()
8582 */
8583 
8584 /*! \fn void QString::push_front(QChar ch)
8585 
8586     \overload
8587 
8588     Prepends the given \a ch character to the beginning of this string.
8589 */
8590 
8591 /*! \fn void QString::push_back(const QString &other)
8592 
8593     This function is provided for STL compatibility, appending the
8594     given \a other string onto the end of this string. It is
8595     equivalent to \c append(other).
8596 
8597     \sa append()
8598 */
8599 
8600 /*! \fn void QString::push_back(QChar ch)
8601 
8602     \overload
8603 
8604     Appends the given \a ch character onto the end of this string.
8605 */
8606 
8607 /*!
8608     \since 6.1
8609 
8610     Removes from the string the characters in the half-open range
8611     [ \a first , \a last ). Returns an iterator to the character
8612     referred to by \a last before the erase.
8613 */
8614 QString::iterator QString::erase(QString::const_iterator first, QString::const_iterator last)
8615 {
8616     const auto start = std::distance(cbegin(), first);
8617     const auto len = std::distance(first, last);
8618     remove(start, len);
8619     return begin() + start;
8620 }
8621 
8622 /*! \fn void QString::shrink_to_fit()
8623     \since 5.10
8624 
8625     This function is provided for STL compatibility. It is
8626     equivalent to squeeze().
8627 
8628     \sa squeeze()
8629 */
8630 
8631 /*!
8632     \fn std::string QString::toStdString() const
8633 
8634     Returns a std::string object with the data contained in this
8635     QString. The Unicode data is converted into 8-bit characters using
8636     the toUtf8() function.
8637 
8638     This method is mostly useful to pass a QString to a function
8639     that accepts a std::string object.
8640 
8641     \sa toLatin1(), toUtf8(), toLocal8Bit(), QByteArray::toStdString()
8642 */
8643 
8644 /*!
8645     Constructs a QString that uses the first \a size Unicode characters
8646     in the array \a unicode. The data in \a unicode is \e not
8647     copied. The caller must be able to guarantee that \a unicode will
8648     not be deleted or modified as long as the QString (or an
8649     unmodified copy of it) exists.
8650 
8651     Any attempts to modify the QString or copies of it will cause it
8652     to create a deep copy of the data, ensuring that the raw data
8653     isn't modified.
8654 
8655     Here is an example of how we can use a QRegularExpression on raw data in
8656     memory without requiring to copy the data into a QString:
8657 
8658     \snippet qstring/main.cpp 22
8659     \snippet qstring/main.cpp 23
8660 
8661     \warning A string created with fromRawData() is \e not
8662     '\\0'-terminated, unless the raw data contains a '\\0' character
8663     at position \a size. This means unicode() will \e not return a
8664     '\\0'-terminated string (although utf16() does, at the cost of
8665     copying the raw data).
8666 
8667     \sa fromUtf16(), setRawData()
8668 */
8669 QString QString::fromRawData(const QChar *unicode, qsizetype size)
8670 {
8671     return QString(DataPointer::fromRawData(const_cast<char16_t *>(reinterpret_cast<const char16_t *>(unicode)), size));
8672 }
8673 
8674 /*!
8675     \since 4.7
8676 
8677     Resets the QString to use the first \a size Unicode characters
8678     in the array \a unicode. The data in \a unicode is \e not
8679     copied. The caller must be able to guarantee that \a unicode will
8680     not be deleted or modified as long as the QString (or an
8681     unmodified copy of it) exists.
8682 
8683     This function can be used instead of fromRawData() to re-use
8684     existings QString objects to save memory re-allocations.
8685 
8686     \sa fromRawData()
8687 */
8688 QString &QString::setRawData(const QChar *unicode, qsizetype size)
8689 {
8690     if (!unicode || !size) {
8691         clear();
8692     }
8693     *this = fromRawData(unicode, size);
8694     return *this;
8695 }
8696 
8697 /*! \fn QString QString::fromStdU16String(const std::u16string &str)
8698     \since 5.5
8699 
8700     Returns a copy of the \a str string. The given string is assumed
8701     to be encoded in UTF-16.
8702 
8703     \sa fromUtf16(), fromStdWString(), fromStdU32String()
8704 */
8705 
8706 /*!
8707     \fn std::u16string QString::toStdU16String() const
8708     \since 5.5
8709 
8710     Returns a std::u16string object with the data contained in this
8711     QString. The Unicode data is the same as returned by the utf16()
8712     method.
8713 
8714     \sa utf16(), toStdWString(), toStdU32String()
8715 */
8716 
8717 /*! \fn QString QString::fromStdU32String(const std::u32string &str)
8718     \since 5.5
8719 
8720     Returns a copy of the \a str string. The given string is assumed
8721     to be encoded in UCS-4.
8722 
8723     \sa fromUcs4(), fromStdWString(), fromStdU16String()
8724 */
8725 
8726 /*!
8727     \fn std::u32string QString::toStdU32String() const
8728     \since 5.5
8729 
8730     Returns a std::u32string object with the data contained in this
8731     QString. The Unicode data is the same as returned by the toUcs4()
8732     method.
8733 
8734     \sa toUcs4(), toStdWString(), toStdU16String()
8735 */
8736 
8737 /*! \class QLatin1String
8738     \inmodule QtCore
8739     \brief The QLatin1String class provides a thin wrapper around an US-ASCII/Latin-1 encoded string literal.
8740 
8741     \ingroup string-processing
8742     \reentrant
8743 
8744     Many of QString's member functions are overloaded to accept
8745     \c{const char *} instead of QString. This includes the copy
8746     constructor, the assignment operator, the comparison operators,
8747     and various other functions such as \l{QString::insert()}{insert()},
8748     \l{QString::replace()}{replace()}, and \l{QString::indexOf()}{indexOf()}.
8749     These functions are usually optimized to avoid constructing a
8750     QString object for the \c{const char *} data. For example,
8751     assuming \c str is a QString,
8752 
8753     \snippet code/src_corelib_text_qstring.cpp 3
8754 
8755     is much faster than
8756 
8757     \snippet code/src_corelib_text_qstring.cpp 4
8758 
8759     because it doesn't construct four temporary QString objects and
8760     make a deep copy of the character data.
8761 
8762     Applications that define \l QT_NO_CAST_FROM_ASCII (as explained
8763     in the QString documentation) don't have access to QString's
8764     \c{const char *} API. To provide an efficient way of specifying
8765     constant Latin-1 strings, Qt provides the QLatin1String, which is
8766     just a very thin wrapper around a \c{const char *}. Using
8767     QLatin1String, the example code above becomes
8768 
8769     \snippet code/src_corelib_text_qstring.cpp 5
8770 
8771     This is a bit longer to type, but it provides exactly the same
8772     benefits as the first version of the code, and is faster than
8773     converting the Latin-1 strings using QString::fromLatin1().
8774 
8775     Thanks to the QString(QLatin1String) constructor,
8776     QLatin1String can be used everywhere a QString is expected. For
8777     example:
8778 
8779     \snippet code/src_corelib_text_qstring.cpp 6
8780 
8781     \note If the function you're calling with a QLatin1String
8782     argument isn't actually overloaded to take QLatin1String, the
8783     implicit conversion to QString will trigger a memory allocation,
8784     which is usually what you want to avoid by using QLatin1String
8785     in the first place. In those cases, using QStringLiteral may be
8786     the better option.
8787 
8788     \sa QString, QLatin1Char, {QStringLiteral()}{QStringLiteral},
8789     QT_NO_CAST_FROM_ASCII
8790 */
8791 
8792 /*!
8793     \typedef QLatin1String::value_type
8794     \since 5.10
8795 
8796     Alias for \c{const char}. Provided for compatibility with the STL.
8797 */
8798 
8799 /*!
8800     \typedef QLatin1String::difference_type
8801     \since 5.10
8802 
8803     Alias for \c{qsizetype}. Provided for compatibility with the STL.
8804 */
8805 
8806 /*!
8807     \typedef QLatin1String::size_type
8808     \since 5.10
8809 
8810     Alias for \c{qsizetype}. Provided for compatibility with the STL.
8811 
8812     \note In version prior to Qt 6, this was an alias for \c{int},
8813     restricting the amount of data that could be held in a QLatin1String
8814     on 64-bit architectures.
8815 */
8816 
8817 /*!
8818     \typedef QLatin1String::reference
8819     \since 5.10
8820 
8821     Alias for \c{value_type &}. Provided for compatibility with the STL.
8822 */
8823 
8824 /*!
8825     \typedef QLatin1String::const_reference
8826     \since 5.11
8827 
8828     Alias for \c{reference}. Provided for compatibility with the STL.
8829 */
8830 
8831 /*!
8832     \typedef QLatin1String::iterator
8833     \since 5.10
8834 
8835     QLatin1String does not support mutable iterators, so this is the same
8836     as const_iterator.
8837 
8838     \sa const_iterator, reverse_iterator
8839 */
8840 
8841 /*!
8842     \typedef QLatin1String::const_iterator
8843     \since 5.10
8844 
8845     \sa iterator, const_reverse_iterator
8846 */
8847 
8848 /*!
8849     \typedef QLatin1String::reverse_iterator
8850     \since 5.10
8851 
8852     QLatin1String does not support mutable reverse iterators, so this is the
8853     same as const_reverse_iterator.
8854 
8855     \sa const_reverse_iterator, iterator
8856 */
8857 
8858 /*!
8859     \typedef QLatin1String::const_reverse_iterator
8860     \since 5.10
8861 
8862     \sa reverse_iterator, const_iterator
8863 */
8864 
8865 /*! \fn QLatin1String::QLatin1String()
8866     \since 5.6
8867 
8868     Constructs a QLatin1String object that stores a nullptr.
8869 */
8870 
8871 /*! \fn QLatin1String::QLatin1String(const char *str)
8872 
8873     Constructs a QLatin1String object that stores \a str.
8874 
8875     The string data is \e not copied. The caller must be able to
8876     guarantee that \a str will not be deleted or modified as long as
8877     the QLatin1String object exists.
8878 
8879     \sa latin1()
8880 */
8881 
8882 /*! \fn QLatin1String::QLatin1String(const char *str, qsizetype size)
8883 
8884     Constructs a QLatin1String object that stores \a str with \a size.
8885 
8886     The string data is \e not copied. The caller must be able to
8887     guarantee that \a str will not be deleted or modified as long as
8888     the QLatin1String object exists.
8889 
8890     \sa latin1()
8891 */
8892 
8893 /*!
8894     \fn QLatin1String::QLatin1String(const char *first, const char *last)
8895     \since 5.10
8896 
8897     Constructs a QLatin1String object that stores \a first with length
8898     (\a last - \a first).
8899 
8900     The range \c{[first,last)} must remain valid for the lifetime of
8901     this Latin-1 string object.
8902 
8903     Passing \nullptr as \a first is safe if \a last is \nullptr,
8904     too, and results in a null Latin-1 string.
8905 
8906     The behavior is undefined if \a last precedes \a first, \a first
8907     is \nullptr and \a last is not, or if \c{last - first >
8908     INT_MAX}.
8909 */
8910 
8911 /*! \fn QLatin1String::QLatin1String(const QByteArray &str)
8912 
8913     Constructs a QLatin1String object that stores \a str.
8914 
8915     The string data is \e not copied. The caller must be able to
8916     guarantee that \a str will not be deleted or modified as long as
8917     the QLatin1String object exists.
8918 
8919     \sa latin1()
8920 */
8921 
8922 /*! \fn QLatin1String::QLatin1String(QByteArrayView str)
8923     \since 6.3
8924 
8925     Constructs a QLatin1String object that stores \a str.
8926 
8927     The string data is \e not copied. The caller must be able to
8928     guarantee that the data which \a str is pointing to will not
8929     be deleted or modified as long as the QLatin1String object
8930     exists. The size is obtained from \a str as-is, without checking
8931     for a null-terminator.
8932 
8933     \sa latin1()
8934 */
8935 
8936 /*!
8937     \fn QString QLatin1String::toString() const
8938     \since 6.0
8939 
8940     Converts this Latin-1 string into a QString. Equivalent to
8941     \code
8942     return QString(*this);
8943     \endcode
8944 */
8945 
8946 /*! \fn const char *QLatin1String::latin1() const
8947 
8948     Returns the Latin-1 string stored in this object.
8949 */
8950 
8951 /*! \fn const char *QLatin1String::data() const
8952 
8953     Returns the Latin-1 string stored in this object.
8954 */
8955 
8956 /*! \fn qsizetype QLatin1String::size() const
8957 
8958     Returns the size of the Latin-1 string stored in this object.
8959 
8960     \note In version prior to Qt 6, this function returned \c{int},
8961     restricting the amount of data that could be held in a QLatin1String
8962     on 64-bit architectures.
8963 */
8964 
8965 /*! \fn bool QLatin1String::isNull() const
8966     \since 5.10
8967 
8968     Returns whether the Latin-1 string stored in this object is null
8969     (\c{data() == nullptr}) or not.
8970 
8971     \sa isEmpty(), data()
8972 */
8973 
8974 /*! \fn bool QLatin1String::isEmpty() const
8975     \since 5.10
8976 
8977     Returns whether the Latin-1 string stored in this object is empty
8978     (\c{size() == 0}) or not.
8979 
8980     \sa isNull(), size()
8981 */
8982 
8983 /*! \fn QLatin1Char QLatin1String::at(qsizetype pos) const
8984     \since 5.8
8985 
8986     Returns the character at position \a pos in this object.
8987 
8988     \note This function performs no error checking.
8989     The behavior is undefined when \a pos < 0 or \a pos >= size().
8990 
8991     \sa operator[]()
8992 */
8993 
8994 /*! \fn QLatin1Char QLatin1String::operator[](qsizetype pos) const
8995     \since 5.8
8996 
8997     Returns the character at position \a pos in this object.
8998 
8999     \note This function performs no error checking.
9000     The behavior is undefined when \a pos < 0 or \a pos >= size().
9001 
9002     \sa at()
9003 */
9004 
9005 /*!
9006     \fn QLatin1Char QLatin1String::front() const
9007     \since 5.10
9008 
9009     Returns the first character in the string.
9010     Same as \c{at(0)}.
9011 
9012     This function is provided for STL compatibility.
9013 
9014     \warning Calling this function on an empty string constitutes
9015     undefined behavior.
9016 
9017     \sa back(), at(), operator[]()
9018 */
9019 
9020 /*!
9021     \fn QLatin1Char QLatin1String::back() const
9022     \since 5.10
9023 
9024     Returns the last character in the string.
9025     Same as \c{at(size() - 1)}.
9026 
9027     This function is provided for STL compatibility.
9028 
9029     \warning Calling this function on an empty string constitutes
9030     undefined behavior.
9031 
9032     \sa front(), at(), operator[]()
9033 */
9034 
9035 /*!
9036     \fn int QLatin1String::compare(QStringView str, Qt::CaseSensitivity cs) const
9037     \fn int QLatin1String::compare(QLatin1String l1, Qt::CaseSensitivity cs) const
9038     \fn int QLatin1String::compare(QChar ch) const
9039     \fn int QLatin1String::compare(QChar ch, Qt::CaseSensitivity cs) const
9040     \since 5.14
9041 
9042     Returns an integer that compares to zero as this Latin-1 string compares to the
9043     string-view \a str, Latin-1 string \a l1, or character \a ch, respectively.
9044 
9045     If \a cs is Qt::CaseSensitive (the default), the comparison is case sensitive;
9046     otherwise the comparison is case-insensitive.
9047 
9048     \sa operator==(), operator<(), operator>()
9049 */
9050 
9051 /*!
9052     \fn int QLatin1String::compare(QLatin1Char ch, Qt::CaseSensitivity cs) const
9053     \since 6.3
9054     \overload
9055 */
9056 
9057 
9058 /*!
9059     \fn bool QLatin1String::startsWith(QStringView str, Qt::CaseSensitivity cs) const
9060     \since 5.10
9061     \fn bool QLatin1String::startsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
9062     \since 5.10
9063     \fn bool QLatin1String::startsWith(QChar ch) const
9064     \since 5.10
9065     \fn bool QLatin1String::startsWith(QChar ch, Qt::CaseSensitivity cs) const
9066     \since 5.10
9067 
9068     Returns \c true if this Latin-1 string starts with string-view \a str,
9069     Latin-1 string \a l1, or character \a ch, respectively;
9070     otherwise returns \c false.
9071 
9072     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
9073     otherwise the search is case-insensitive.
9074 
9075     \sa endsWith()
9076 */
9077 
9078 /*!
9079     \fn bool QLatin1String::startsWith(QLatin1Char ch, Qt::CaseSensitivity cs) const
9080     \since 6.3
9081     \overload
9082 */
9083 
9084 /*!
9085     \fn bool QLatin1String::endsWith(QStringView str, Qt::CaseSensitivity cs) const
9086     \since 5.10
9087     \fn bool QLatin1String::endsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
9088     \since 5.10
9089     \fn bool QLatin1String::endsWith(QChar ch) const
9090     \since 5.10
9091     \fn bool QLatin1String::endsWith(QChar ch, Qt::CaseSensitivity cs) const
9092     \since 5.10
9093 
9094     Returns \c true if this Latin-1 string ends with string-view \a str,
9095     Latin-1 string \a l1, or character \a ch, respectively;
9096     otherwise returns \c false.
9097 
9098     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
9099     otherwise the search is case-insensitive.
9100 
9101     \sa startsWith()
9102 */
9103 
9104 /*!
9105     \fn bool QLatin1String::endsWith(QLatin1Char ch, Qt::CaseSensitivity cs) const
9106     \since 6.3
9107     \overload
9108 */
9109 
9110 /*!
9111     \fn qsizetype QLatin1String::indexOf(QStringView str, qsizetype from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
9112     \fn qsizetype QLatin1String::indexOf(QLatin1String l1, qsizetype from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
9113     \fn qsizetype QLatin1String::indexOf(QChar c, qsizetype from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
9114     \since 5.14
9115 
9116     Returns the index position of the first occurrence of the string-view
9117     \a str, Latin-1 string \a l1, or character \a ch, respectively, in this
9118     Latin-1 string, searching forward from index position \a from.
9119     Returns -1 if \a str is not found.
9120 
9121     If \a cs is Qt::CaseSensitive (default), the search is case
9122     sensitive; otherwise the search is case insensitive.
9123 
9124     If \a from is -1, the search starts at the last character; if it is
9125     -2, at the next to last character and so on.
9126 
9127     \sa QString::indexOf()
9128 */
9129 
9130 /*!
9131     \fn qsizetype QLatin1String::indexOf(QLatin1Char ch, qsizetype from, Qt::CaseSensitivity cs) const
9132     \since 6.3
9133     \overload
9134 */
9135 
9136 /*!
9137     \fn bool QLatin1String::contains(QStringView str, Qt::CaseSensitivity cs) const
9138     \fn bool QLatin1String::contains(QLatin1String l1, Qt::CaseSensitivity cs) const
9139     \fn bool QLatin1String::contains(QChar c, Qt::CaseSensitivity cs) const
9140     \since 5.14
9141 
9142     Returns \c true if this Latin-1 string contains an occurrence of the
9143     string-view \a str, Latin-1 string \a l1, or character \a ch;
9144     otherwise returns \c false.
9145 
9146     If \a cs is Qt::CaseSensitive (the default), the search is
9147     case-sensitive; otherwise the search is case-insensitive.
9148 
9149     \sa indexOf(), QStringView::contains(), QStringView::indexOf(),
9150     QString::indexOf()
9151 */
9152 
9153 /*!
9154     \fn bool QLatin1String::contains(QLatin1Char ch, Qt::CaseSensitivity cs) const
9155     \since 6.3
9156     \overload
9157 */
9158 
9159 /*!
9160     \fn qsizetype QLatin1String::lastIndexOf(QStringView str, qsizetype from, Qt::CaseSensitivity cs) const
9161     \fn qsizetype QLatin1String::lastIndexOf(QLatin1String l1, qsizetype from, Qt::CaseSensitivity cs) const
9162     \fn qsizetype QLatin1String::lastIndexOf(QChar c, qsizetype from, Qt::CaseSensitivity cs) const
9163     \since 5.14
9164 
9165     Returns the index position of the last occurrence of the string-view \a str,
9166     Latin-1 string \a l1, or character \a ch, respectively, in this Latin-1
9167     string, searching backward from index position \a from.
9168     Returns -1 if \a str is not found.
9169 
9170     If \a from is -1 (default), the search starts at the last character;
9171     if \a from is -2, at the next to last character and so on.
9172 
9173     If \a cs is Qt::CaseSensitive (default), the search is case
9174     sensitive; otherwise the search is case insensitive.
9175 
9176     \sa indexOf(), QStringView::lastIndexOf(), QStringView::indexOf(),
9177     QString::indexOf()
9178 */
9179 
9180 /*!
9181     \fn qsizetype QLatin1String::lastIndexOf(QLatin1Char ch, qsizetype from, Qt::CaseSensitivity cs) const
9182     \since 6.3
9183     \overload
9184 */
9185 
9186 /*!
9187     \fn QLatin1String::const_iterator QLatin1String::begin() const
9188     \since 5.10
9189 
9190     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the
9191     first character in the string.
9192 
9193     This function is provided for STL compatibility.
9194 
9195     \sa end(), cbegin(), rbegin(), data()
9196 */
9197 
9198 /*!
9199     \fn QLatin1String::const_iterator QLatin1String::cbegin() const
9200     \since 5.10
9201 
9202     Same as begin().
9203 
9204     This function is provided for STL compatibility.
9205 
9206     \sa cend(), begin(), crbegin(), data()
9207 */
9208 
9209 /*!
9210     \fn QLatin1String::const_iterator QLatin1String::end() const
9211     \since 5.10
9212 
9213     Returns a const \l{STL-style iterators}{STL-style iterator} pointing just
9214     after the last character in the string.
9215 
9216     This function is provided for STL compatibility.
9217 
9218     \sa begin(), cend(), rend()
9219 */
9220 
9221 /*! \fn QLatin1String::const_iterator QLatin1String::cend() const
9222     \since 5.10
9223 
9224     Same as end().
9225 
9226     This function is provided for STL compatibility.
9227 
9228     \sa cbegin(), end(), crend()
9229 */
9230 
9231 /*!
9232     \fn QLatin1String::const_reverse_iterator QLatin1String::rbegin() const
9233     \since 5.10
9234 
9235     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing
9236     to the first character in the string, in reverse order.
9237 
9238     This function is provided for STL compatibility.
9239 
9240     \sa rend(), crbegin(), begin()
9241 */
9242 
9243 /*!
9244     \fn QLatin1String::const_reverse_iterator QLatin1String::crbegin() const
9245     \since 5.10
9246 
9247     Same as rbegin().
9248 
9249     This function is provided for STL compatibility.
9250 
9251     \sa crend(), rbegin(), cbegin()
9252 */
9253 
9254 /*!
9255     \fn QLatin1String::const_reverse_iterator QLatin1String::rend() const
9256     \since 5.10
9257 
9258     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing just
9259     after the last character in the string, in reverse order.
9260 
9261     This function is provided for STL compatibility.
9262 
9263     \sa rbegin(), crend(), end()
9264 */
9265 
9266 /*!
9267     \fn QLatin1String::const_reverse_iterator QLatin1String::crend() const
9268     \since 5.10
9269 
9270     Same as rend().
9271 
9272     This function is provided for STL compatibility.
9273 
9274     \sa crbegin(), rend(), cend()
9275 */
9276 
9277 /*!
9278     \fn QLatin1String QLatin1String::mid(qsizetype start, qsizetype length) const
9279     \since 5.8
9280 
9281     Returns the substring of length \a length starting at position
9282     \a start in this Latin-1 string.
9283 
9284     If you know that \a start and \a length cannot be out of bounds, use
9285     sliced() instead in new code, because it is faster.
9286 
9287     Returns an empty Latin-1 string if \a start exceeds the
9288     length of this Latin-1 string. If there are less than \a length characters
9289     available in this Latin-1 string starting at \a start, or if
9290     \a length is negative (default), the function returns all characters that
9291     are available from \a start.
9292 
9293     \sa first(), last(), sliced(), chopped(), chop(), truncate()
9294 */
9295 
9296 /*!
9297     \fn QLatin1String QLatin1String::left(qsizetype length) const
9298     \since 5.8
9299 
9300     If you know that \a length cannot be out of bounds, use first() instead in
9301     new code, because it is faster.
9302 
9303     Returns the substring of length \a length starting at position
9304     0 in this Latin-1 string.
9305 
9306     The entire Latin-1 string is returned if \a length is greater than or equal
9307     to size(), or less than zero.
9308 
9309     \sa first(), last(), sliced(), startsWith(), chopped(), chop(), truncate()
9310 */
9311 
9312 /*!
9313     \fn QLatin1String QLatin1String::right(qsizetype length) const
9314     \since 5.8
9315 
9316     If you know that \a length cannot be out of bounds, use last() instead in
9317     new code, because it is faster.
9318 
9319     Returns the substring of length \a length starting at position
9320     size() - \a length in this Latin-1 string.
9321 
9322     The entire Latin-1 string is returned if \a length is greater than or equal
9323     to size(), or less than zero.
9324 
9325     \sa first(), last(), sliced(), endsWith(), chopped(), chop(), truncate()
9326 */
9327 
9328 /*!
9329     \fn QLatin1String QLatin1String::first(qsizetype n) const
9330     \since 6.0
9331 
9332     Returns a Latin-1 string that contains the first \a n characters
9333     of this Latin-1 string.
9334 
9335     \note The behavior is undefined when \a n < 0 or \a n > size().
9336 
9337     \sa last(), startsWith(), chopped(), chop(), truncate()
9338 */
9339 
9340 /*!
9341     \fn QLatin1String QLatin1String::last(qsizetype n) const
9342     \since 6.0
9343 
9344     Returns a Latin-1 string that contains the last \a n characters
9345     of this Latin-1 string.
9346 
9347     \note The behavior is undefined when \a n < 0 or \a n > size().
9348 
9349     \sa first(), endsWith(), chopped(), chop(), truncate()
9350 */
9351 
9352 /*!
9353     \fn QLatin1String QLatin1String::sliced(qsizetype pos, qsizetype n) const
9354     \since 6.0
9355 
9356     Returns a Latin-1 string that points to \a n characters of this
9357     Latin-1 string, starting at position \a pos.
9358 
9359     \note The behavior is undefined when \a pos < 0, \a n < 0,
9360     or \c{pos + n > size()}.
9361 
9362     \sa first(), last(), chopped(), chop(), truncate()
9363 */
9364 
9365 /*!
9366     \fn QLatin1String QLatin1String::sliced(qsizetype pos) const
9367     \since 6.0
9368 
9369     Returns a Latin-1 string starting at position \a pos in this
9370     Latin-1 string, and extending to its end.
9371 
9372     \note The behavior is undefined when \a pos < 0 or \a pos > size().
9373 
9374     \sa first(), last(), chopped(), chop(), truncate()
9375 */
9376 
9377 /*!
9378     \fn QLatin1String QLatin1String::chopped(qsizetype length) const
9379     \since 5.10
9380 
9381     Returns the substring of length size() - \a length starting at the
9382     beginning of this object.
9383 
9384     Same as \c{left(size() - length)}.
9385 
9386     \note The behavior is undefined when \a length < 0 or \a length > size().
9387 
9388     \sa sliced(), first(), last(), chop(), truncate()
9389 */
9390 
9391 /*!
9392     \fn void QLatin1String::truncate(qsizetype length)
9393     \since 5.10
9394 
9395     Truncates this string to length \a length.
9396 
9397     Same as \c{*this = left(length)}.
9398 
9399     \note The behavior is undefined when \a length < 0 or \a length > size().
9400 
9401     \sa sliced(), first(), last(), chopped(), chop()
9402 */
9403 
9404 /*!
9405     \fn void QLatin1String::chop(qsizetype length)
9406     \since 5.10
9407 
9408     Truncates this string by \a length characters.
9409 
9410     Same as \c{*this = left(size() - length)}.
9411 
9412     \note The behavior is undefined when \a length < 0 or \a length > size().
9413 
9414     \sa sliced(), first(), last(), chopped(), truncate()
9415 */
9416 
9417 /*!
9418     \fn QLatin1String QLatin1String::trimmed() const
9419     \since 5.10
9420 
9421     Strips leading and trailing whitespace and returns the result.
9422 
9423     Whitespace means any character for which QChar::isSpace() returns
9424     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
9425     '\\f', '\\r', and ' '.
9426 */
9427 
9428 /*!
9429     \fn bool QLatin1String::operator==(const char *other) const
9430     \since 4.3
9431 
9432     Returns \c true if the string is equal to const char pointer \a other;
9433     otherwise returns \c false.
9434 
9435     The \a other const char pointer is converted to a QString using
9436     the QString::fromUtf8() function.
9437 
9438     You can disable this operator by defining
9439     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9440     can be useful if you want to ensure that all user-visible strings
9441     go through QObject::tr(), for example.
9442 
9443     \sa {Comparing Strings}
9444 */
9445 
9446 /*!
9447     \fn bool QLatin1String::operator==(const QByteArray &other) const
9448     \since 5.0
9449     \overload
9450 
9451     The \a other byte array is converted to a QString using
9452     the QString::fromUtf8() function.
9453 
9454     You can disable this operator by defining
9455     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9456     can be useful if you want to ensure that all user-visible strings
9457     go through QObject::tr(), for example.
9458 */
9459 
9460 /*!
9461     \fn bool QLatin1String::operator!=(const char *other) const
9462     \since 4.3
9463 
9464     Returns \c true if this string is not equal to const char pointer \a other;
9465     otherwise returns \c false.
9466 
9467     The \a other const char pointer is converted to a QString using
9468     the QString::fromUtf8() function.
9469 
9470     You can disable this operator by defining
9471     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9472     can be useful if you want to ensure that all user-visible strings
9473     go through QObject::tr(), for example.
9474 
9475     \sa {Comparing Strings}
9476 */
9477 
9478 /*!
9479     \fn bool QLatin1String::operator!=(const QByteArray &other) const
9480     \since 5.0
9481     \overload operator!=()
9482 
9483     The \a other byte array is converted to a QString using
9484     the QString::fromUtf8() function.
9485 
9486     You can disable this operator by defining
9487     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9488     can be useful if you want to ensure that all user-visible strings
9489     go through QObject::tr(), for example.
9490 */
9491 
9492 /*!
9493     \fn bool QLatin1String::operator>(const char *other) const
9494     \since 4.3
9495 
9496     Returns \c true if this string is lexically greater than const char pointer
9497     \a other; otherwise returns \c false.
9498 
9499     The \a other const char pointer is converted to a QString using
9500     the QString::fromUtf8() function.
9501 
9502     You can disable this operator by defining \l QT_NO_CAST_FROM_ASCII
9503     when you compile your applications. This can be useful if you want
9504     to ensure that all user-visible strings go through QObject::tr(),
9505     for example.
9506 
9507     \sa {Comparing Strings}
9508 */
9509 
9510 /*!
9511     \fn bool QLatin1String::operator>(const QByteArray &other) const
9512     \since 5.0
9513     \overload
9514 
9515     The \a other byte array is converted to a QString using
9516     the QString::fromUtf8() function.
9517 
9518     You can disable this operator by defining \l QT_NO_CAST_FROM_ASCII
9519     when you compile your applications. This can be useful if you want
9520     to ensure that all user-visible strings go through QObject::tr(),
9521     for example.
9522 */
9523 
9524 /*!
9525     \fn bool QLatin1String::operator<(const char *other) const
9526     \since 4.3
9527 
9528     Returns \c true if this string is lexically less than const char pointer
9529     \a other; otherwise returns \c false.
9530 
9531     The \a other const char pointer is converted to a QString using
9532     the QString::fromUtf8() function.
9533 
9534     You can disable this operator by defining
9535     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9536     can be useful if you want to ensure that all user-visible strings
9537     go through QObject::tr(), for example.
9538 
9539     \sa {Comparing Strings}
9540 */
9541 
9542 /*!
9543     \fn bool QLatin1String::operator<(const QByteArray &other) const
9544     \since 5.0
9545     \overload
9546 
9547     The \a other byte array is converted to a QString using
9548     the QString::fromUtf8() function.
9549 
9550     You can disable this operator by defining
9551     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9552     can be useful if you want to ensure that all user-visible strings
9553     go through QObject::tr(), for example.
9554 */
9555 
9556 /*!
9557     \fn bool QLatin1String::operator>=(const char *other) const
9558     \since 4.3
9559 
9560     Returns \c true if this string is lexically greater than or equal to
9561     const char pointer \a other; otherwise returns \c false.
9562 
9563     The \a other const char pointer is converted to a QString using
9564     the QString::fromUtf8() function.
9565 
9566     You can disable this operator by defining
9567     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9568     can be useful if you want to ensure that all user-visible strings
9569     go through QObject::tr(), for example.
9570 
9571     \sa {Comparing Strings}
9572 */
9573 
9574 /*!
9575     \fn bool QLatin1String::operator>=(const QByteArray &other) const
9576     \since 5.0
9577     \overload
9578 
9579     The \a other byte array is converted to a QString using
9580     the QString::fromUtf8() function.
9581 
9582     You can disable this operator by defining
9583     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9584     can be useful if you want to ensure that all user-visible strings
9585     go through QObject::tr(), for example.
9586 */
9587 
9588 /*!
9589     \fn bool QLatin1String::operator<=(const char *other) const
9590     \since 4.3
9591 
9592     Returns \c true if this string is lexically less than or equal to
9593     const char pointer \a other; otherwise returns \c false.
9594 
9595     The \a other const char pointer is converted to a QString using
9596     the QString::fromUtf8() function.
9597 
9598     You can disable this operator by defining
9599     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9600     can be useful if you want to ensure that all user-visible strings
9601     go through QObject::tr(), for example.
9602 
9603     \sa {Comparing Strings}
9604 */
9605 
9606 /*!
9607     \fn bool QLatin1String::operator<=(const QByteArray &other) const
9608     \since 5.0
9609     \overload
9610 
9611     The \a other byte array is converted to a QString using
9612     the QString::fromUtf8() function.
9613 
9614     You can disable this operator by defining
9615     \l QT_NO_CAST_FROM_ASCII when you compile your applications. This
9616     can be useful if you want to ensure that all user-visible strings
9617     go through QObject::tr(), for example.
9618 */
9619 
9620 /*! \fn bool QLatin1String::operator==(QLatin1String s1, QLatin1String s2)
9621 
9622     Returns \c true if string \a s1 is lexically equal to string \a s2;
9623     otherwise returns \c false.
9624 */
9625 /*! \fn bool QLatin1String::operator!=(QLatin1String s1, QLatin1String s2)
9626 
9627     Returns \c true if string \a s1 is lexically not equal to string \a s2;
9628     otherwise returns \c false.
9629 */
9630 /*! \fn bool QLatin1String::operator<(QLatin1String s1, QLatin1String s2)
9631 
9632     Returns \c true if string \a s1 is lexically less than string \a s2;
9633     otherwise returns \c false.
9634 */
9635 /*! \fn bool QLatin1String::operator<=(QLatin1String s1, QLatin1String s2)
9636 
9637     Returns \c true if string \a s1 is lexically less than or equal to
9638     string \a s2; otherwise returns \c false.
9639 */
9640 /*! \fn bool QLatin1String::operator>(QLatin1String s1, QLatin1String s2)
9641 
9642     Returns \c true if string \a s1 is lexically greater than string \a s2;
9643     otherwise returns \c false.
9644 */
9645 /*! \fn bool QLatin1String::operator>=(QLatin1String s1, QLatin1String s2)
9646 
9647     Returns \c true if string \a s1 is lexically greater than or equal
9648     to string \a s2; otherwise returns \c false.
9649 */
9650 
9651 /*! \fn bool QLatin1String::operator==(QChar ch, QLatin1String s)
9652 
9653     Returns \c true if char \a ch is lexically equal to string \a s;
9654     otherwise returns \c false.
9655 */
9656 /*! \fn bool QLatin1String::operator<(QChar ch, QLatin1String s)
9657 
9658     Returns \c true if char \a ch is lexically less than string \a s;
9659     otherwise returns \c false.
9660 */
9661 /*! \fn bool QLatin1String::operator>(QChar ch, QLatin1String s)
9662     Returns \c true if char \a ch is lexically greater than string \a s;
9663     otherwise returns \c false.
9664 */
9665 /*! \fn bool QLatin1String::operator!=(QChar ch, QLatin1String s)
9666 
9667     Returns \c true if char \a ch is lexically not equal to string \a s;
9668     otherwise returns \c false.
9669 */
9670 /*! \fn bool QLatin1String::operator<=(QChar ch, QLatin1String s)
9671 
9672     Returns \c true if char \a ch is lexically less than or equal to
9673     string \a s; otherwise returns \c false.
9674 */
9675 /*! \fn bool QLatin1String::operator>=(QChar ch, QLatin1String s)
9676 
9677     Returns \c true if char \a ch is lexically greater than or equal to
9678     string \a s; otherwise returns \c false.
9679 */
9680 
9681 /*! \fn bool QLatin1String::operator==(QLatin1String s, QChar ch)
9682 
9683     Returns \c true if string \a s is lexically equal to char \a ch;
9684     otherwise returns \c false.
9685 */
9686 /*! \fn bool QLatin1String::operator<(QLatin1String s, QChar ch)
9687 
9688     Returns \c true if string \a s is lexically less than char \a ch;
9689     otherwise returns \c false.
9690 */
9691 /*! \fn bool QLatin1String::operator>(QLatin1String s, QChar ch)
9692 
9693     Returns \c true if string \a s is lexically greater than char \a ch;
9694     otherwise returns \c false.
9695 */
9696 /*! \fn bool QLatin1String::operator!=(QLatin1String s, QChar ch)
9697 
9698     Returns \c true if string \a s is lexically not equal to char \a ch;
9699     otherwise returns \c false.
9700 */
9701 /*! \fn bool QLatin1String::operator<=(QLatin1String s, QChar ch)
9702 
9703     Returns \c true if string \a s is lexically less than or equal to
9704     char \a ch; otherwise returns \c false.
9705 */
9706 /*! \fn bool QLatin1String::operator>=(QLatin1String s, QChar ch)
9707 
9708     Returns \c true if string \a s is lexically greater than or equal to
9709     char \a ch; otherwise returns \c false.
9710 */
9711 
9712 /*! \fn bool QLatin1String::operator==(QStringView s1, QLatin1String s2)
9713 
9714     Returns \c true if string view \a s1 is lexically equal to string \a s2;
9715     otherwise returns \c false.
9716 */
9717 /*! \fn bool QLatin1String::operator<(QStringView s1, QLatin1String s2)
9718 
9719     Returns \c true if string view \a s1 is lexically less than string \a s2;
9720     otherwise returns \c false.
9721 */
9722 /*! \fn bool QLatin1String::operator>(QStringView s1, QLatin1String s2)
9723 
9724     Returns \c true if string view \a s1 is lexically greater than string \a s2;
9725     otherwise returns \c false.
9726 */
9727 /*! \fn bool QLatin1String::operator!=(QStringView s1, QLatin1String s2)
9728 
9729     Returns \c true if string view \a s1 is lexically not equal to string \a s2;
9730     otherwise returns \c false.
9731 */
9732 /*! \fn bool QLatin1String::operator<=(QStringView s1, QLatin1String s2)
9733 
9734     Returns \c true if string view \a s1 is lexically less than or equal to
9735     string \a s2; otherwise returns \c false.
9736 */
9737 /*! \fn bool QLatin1String::operator>=(QStringView s1, QLatin1String s2)
9738 
9739     Returns \c true if string view \a s1 is lexically greater than or equal to
9740     string \a s2; otherwise returns \c false.
9741 */
9742 
9743 /*! \fn bool QLatin1String::operator==(QLatin1String s1, QStringView s2)
9744 
9745     Returns \c true if string \a s1 is lexically equal to string view \a s2;
9746     otherwise returns \c false.
9747 */
9748 /*! \fn bool QLatin1String::operator<(QLatin1String s1, QStringView s2)
9749 
9750     Returns \c true if string \a s1 is lexically less than string view \a s2;
9751     otherwise returns \c false.
9752 */
9753 /*! \fn bool QLatin1String::operator>(QLatin1String s1, QStringView s2)
9754 
9755     Returns \c true if string \a s1 is lexically greater than string view \a s2;
9756     otherwise returns \c false.
9757 */
9758 /*! \fn bool QLatin1String::operator!=(QLatin1String s1, QStringView s2)
9759 
9760     Returns \c true if string \a s1 is lexically not equal to string view \a s2;
9761     otherwise returns \c false.
9762 */
9763 /*! \fn bool QLatin1String::operator<=(QLatin1String s1, QStringView s2)
9764 
9765     Returns \c true if string \a s1 is lexically less than or equal to
9766     string view \a s2; otherwise returns \c false.
9767 */
9768 /*! \fn bool QLatin1String::operator>=(QLatin1String s1, QStringView s2)
9769 
9770     Returns \c true if string \a s1 is lexically greater than or equal to
9771     string view \a s2; otherwise returns \c false.
9772 */
9773 
9774 /*! \fn bool QLatin1String::operator==(const char *s1, QLatin1String s2)
9775 
9776     Returns \c true if const char pointer \a s1 is lexically equal to
9777     string \a s2; otherwise returns \c false.
9778 */
9779 /*! \fn bool QLatin1String::operator<(const char *s1, QLatin1String s2)
9780 
9781     Returns \c true if const char pointer \a s1 is lexically less than
9782     string \a s2; otherwise returns \c false.
9783 */
9784 /*! \fn bool QLatin1String::operator>(const char *s1, QLatin1String s2)
9785 
9786     Returns \c true if const char pointer \a s1 is lexically greater than
9787     string \a s2; otherwise returns \c false.
9788 */
9789 /*! \fn bool QLatin1String::operator!=(const char *s1, QLatin1String s2)
9790 
9791     Returns \c true if const char pointer \a s1 is lexically not equal to
9792     string \a s2; otherwise returns \c false.
9793 */
9794 /*! \fn bool QLatin1String::operator<=(const char *s1, QLatin1String s2)
9795 
9796     Returns \c true if const char pointer \a s1 is lexically less than or
9797     equal to string \a s2; otherwise returns \c false.
9798 */
9799 /*! \fn bool QLatin1String::operator>=(const char *s1, QLatin1String s2)
9800 
9801     Returns \c true if const char pointer \a s1 is lexically greater than or
9802     equal to string \a s2; otherwise returns \c false.
9803 */
9804 
9805 #if !defined(QT_NO_DATASTREAM) || defined(QT_BOOTSTRAPPED)
9806 /*!
9807     \fn QDataStream &operator<<(QDataStream &stream, const QString &string)
9808     \relates QString
9809 
9810     Writes the given \a string to the specified \a stream.
9811 
9812     \sa {Serializing Qt Data Types}
9813 */
9814 
9815 QDataStream &operator<<(QDataStream &out, const QString &str)
9816 {
9817     if (out.version() == 1) {
9818         out << str.toLatin1();
9819     } else {
9820         if (!str.isNull() || out.version() < 3) {
9821             if ((out.byteOrder() == QDataStream::BigEndian) == (QSysInfo::ByteOrder == QSysInfo::BigEndian)) {
9822                 out.writeBytes(reinterpret_cast<const char *>(str.unicode()),
9823                                static_cast<uint>(sizeof(QChar) * str.length()));
9824             } else {
9825                 QVarLengthArray<char16_t> buffer(str.length());
9826                 qbswap<sizeof(char16_t)>(str.constData(), str.length(), buffer.data());
9827                 out.writeBytes(reinterpret_cast<const char *>(buffer.data()),
9828                                static_cast<uint>(sizeof(char16_t) * buffer.size()));
9829             }
9830         } else {
9831             // write null marker
9832             out << (quint32)0xffffffff;
9833         }
9834     }
9835     return out;
9836 }
9837 
9838 /*!
9839     \fn QDataStream &operator>>(QDataStream &stream, QString &string)
9840     \relates QString
9841 
9842     Reads a string from the specified \a stream into the given \a string.
9843 
9844     \sa {Serializing Qt Data Types}
9845 */
9846 
9847 QDataStream &operator>>(QDataStream &in, QString &str)
9848 {
9849     if (in.version() == 1) {
9850         QByteArray l;
9851         in >> l;
9852         str = QString::fromLatin1(l);
9853     } else {
9854         quint32 bytes = 0;
9855         in >> bytes;                                  // read size of string
9856         if (bytes == 0xffffffff) {                    // null string
9857             str.clear();
9858         } else if (bytes > 0) {                       // not empty
9859             if (bytes & 0x1) {
9860                 str.clear();
9861                 in.setStatus(QDataStream::ReadCorruptData);
9862                 return in;
9863             }
9864 
9865             const quint32 Step = 1024 * 1024;
9866             quint32 len = bytes / 2;
9867             quint32 allocated = 0;
9868 
9869             while (allocated < len) {
9870                 int blockSize = qMin(Step, len - allocated);
9871                 str.resize(allocated + blockSize);
9872                 if (in.readRawData(reinterpret_cast<char *>(str.data()) + allocated * 2,
9873                                    blockSize * 2) != blockSize * 2) {
9874                     str.clear();
9875                     in.setStatus(QDataStream::ReadPastEnd);
9876                     return in;
9877                 }
9878                 allocated += blockSize;
9879             }
9880 
9881             if ((in.byteOrder() == QDataStream::BigEndian)
9882                     != (QSysInfo::ByteOrder == QSysInfo::BigEndian)) {
9883                 char16_t *data = reinterpret_cast<char16_t *>(str.data());
9884                 qbswap<sizeof(*data)>(data, len, data);
9885             }
9886         } else {
9887             str = QString(QLatin1String(""));
9888         }
9889     }
9890     return in;
9891 }
9892 #endif // QT_NO_DATASTREAM
9893 
9894 /*!
9895     \typedef QString::Data
9896     \internal
9897 */
9898 
9899 /*!
9900     \typedef QString::DataPtr
9901     \internal
9902 */
9903 
9904 /*!
9905     \fn DataPtr & QString::data_ptr()
9906     \internal
9907 */
9908 
9909 /*!
9910     \since 5.11
9911     \internal
9912     \relates QStringView
9913 
9914     Returns \c true if the string is read right to left.
9915 
9916     \sa QString::isRightToLeft()
9917 */
9918 bool QtPrivate::isRightToLeft(QStringView string) noexcept
9919 {
9920     const char16_t *p = string.utf16();
9921     const char16_t * const end = p + string.size();
9922     int isolateLevel = 0;
9923     while (p < end) {
9924         uint ucs4 = *p;
9925         if (QChar::isHighSurrogate(ucs4) && p < end - 1) {
9926             char16_t low = p[1];
9927             if (QChar::isLowSurrogate(low)) {
9928                 ucs4 = QChar::surrogateToUcs4(ucs4, low);
9929                 ++p;
9930             }
9931         }
9932         switch (QChar::direction(ucs4))
9933         {
9934         case QChar::DirRLI:
9935         case QChar::DirLRI:
9936         case QChar::DirFSI:
9937             ++isolateLevel;
9938             break;
9939         case QChar::DirPDI:
9940             if (isolateLevel)
9941                 --isolateLevel;
9942             break;
9943         case QChar::DirL:
9944             if (isolateLevel)
9945                 break;
9946             return false;
9947         case QChar::DirR:
9948         case QChar::DirAL:
9949             if (isolateLevel)
9950                 break;
9951             return true;
9952         default:
9953             break;
9954         }
9955         ++p;
9956     }
9957     return false;
9958 }
9959 
9960 qsizetype QtPrivate::count(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
9961 {
9962     qsizetype num = 0;
9963     qsizetype i = -1;
9964     if (haystack.size() > 500 && needle.size() > 5) {
9965         QStringMatcher matcher(needle, cs);
9966         while ((i = matcher.indexIn(haystack, i + 1)) != -1)
9967             ++num;
9968     } else {
9969         while ((i = QtPrivate::findString(haystack, i + 1, needle, cs)) != -1)
9970             ++num;
9971     }
9972     return num;
9973 }
9974 
9975 qsizetype QtPrivate::count(QStringView haystack, QChar ch, Qt::CaseSensitivity cs) noexcept
9976 {
9977     qsizetype num = 0;
9978     if (cs == Qt::CaseSensitive) {
9979         for (QChar c : haystack) {
9980             if (c == ch)
9981                 ++num;
9982         }
9983     } else {
9984         ch = foldCase(ch);
9985         for (QChar c : haystack) {
9986             if (foldCase(c) == ch)
9987                 ++num;
9988         }
9989     }
9990     return num;
9991 }
9992 
9993 template <typename Haystack, typename Needle>
9994 bool qt_starts_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) noexcept
9995 {
9996     if (haystack.isNull())
9997         return needle.isNull();
9998     const auto haystackLen = haystack.size();
9999     const auto needleLen = needle.size();
10000     if (haystackLen == 0)
10001         return needleLen == 0;
10002     if (needleLen > haystackLen)
10003         return false;
10004 
10005     return QtPrivate::compareStrings(haystack.left(needleLen), needle, cs) == 0;
10006 }
10007 
10008 static inline bool qt_starts_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
10009 {
10010     return qt_starts_with_impl(haystack, needle, cs);
10011 }
10012 
10013 static inline bool qt_starts_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
10014 {
10015     return qt_starts_with_impl(haystack, needle, cs);
10016 }
10017 
10018 static inline bool qt_starts_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
10019 {
10020     return haystack.size()
10021            && (cs == Qt::CaseSensitive ? haystack.front() == needle
10022                                        : foldCase(haystack.front()) == foldCase(needle));
10023 }
10024 
10025 /*!
10026     \fn bool QtPrivate::startsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
10027     \since 5.10
10028     \fn bool QtPrivate::startsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
10029     \since 5.10
10030     \fn bool QtPrivate::startsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs)
10031     \since 5.10
10032     \fn bool QtPrivate::startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs)
10033     \since 5.10
10034     \internal
10035     \relates QStringView
10036 
10037     Returns \c true if \a haystack starts with \a needle,
10038     otherwise returns \c false.
10039 
10040     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
10041     otherwise the search is case-insensitive.
10042 
10043     \sa QtPrivate::endsWith(), QString::endsWith(), QStringView::endsWith(), QLatin1String::endsWith()
10044 */
10045 
10046 bool QtPrivate::startsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
10047 {
10048     return qt_starts_with_impl(haystack, needle, cs);
10049 }
10050 
10051 bool QtPrivate::startsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10052 {
10053     return qt_starts_with_impl(haystack, needle, cs);
10054 }
10055 
10056 bool QtPrivate::startsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
10057 {
10058     return qt_starts_with_impl(haystack, needle, cs);
10059 }
10060 
10061 bool QtPrivate::startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10062 {
10063     return qt_starts_with_impl(haystack, needle, cs);
10064 }
10065 
10066 template <typename Haystack, typename Needle>
10067 bool qt_ends_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) noexcept
10068 {
10069     if (haystack.isNull())
10070         return needle.isNull();
10071     const auto haystackLen = haystack.size();
10072     const auto needleLen = needle.size();
10073     if (haystackLen == 0)
10074         return needleLen == 0;
10075     if (haystackLen < needleLen)
10076         return false;
10077 
10078     return QtPrivate::compareStrings(haystack.right(needleLen), needle, cs) == 0;
10079 }
10080 
10081 static inline bool qt_ends_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
10082 {
10083     return qt_ends_with_impl(haystack, needle, cs);
10084 }
10085 
10086 static inline bool qt_ends_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
10087 {
10088     return qt_ends_with_impl(haystack, needle, cs);
10089 }
10090 
10091 static inline bool qt_ends_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
10092 {
10093     return haystack.size()
10094            && (cs == Qt::CaseSensitive ? haystack.back() == needle
10095                                        : foldCase(haystack.back()) == foldCase(needle));
10096 }
10097 
10098 /*!
10099     \fn bool QtPrivate::endsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
10100     \since 5.10
10101     \fn bool QtPrivate::endsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
10102     \since 5.10
10103     \fn bool QtPrivate::endsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs)
10104     \since 5.10
10105     \fn bool QtPrivate::endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs)
10106     \since 5.10
10107     \internal
10108     \relates QStringView
10109 
10110     Returns \c true if \a haystack ends with \a needle,
10111     otherwise returns \c false.
10112 
10113     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
10114     otherwise the search is case-insensitive.
10115 
10116     \sa QtPrivate::startsWith(), QString::endsWith(), QStringView::endsWith(), QLatin1String::endsWith()
10117 */
10118 
10119 bool QtPrivate::endsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
10120 {
10121     return qt_ends_with_impl(haystack, needle, cs);
10122 }
10123 
10124 bool QtPrivate::endsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10125 {
10126     return qt_ends_with_impl(haystack, needle, cs);
10127 }
10128 
10129 bool QtPrivate::endsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
10130 {
10131     return qt_ends_with_impl(haystack, needle, cs);
10132 }
10133 
10134 bool QtPrivate::endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10135 {
10136     return qt_ends_with_impl(haystack, needle, cs);
10137 }
10138 
10139 namespace {
10140 template <typename Pointer>
10141 char32_t foldCaseHelper(Pointer ch, Pointer start) = delete;
10142 
10143 template <>
10144 char32_t foldCaseHelper<const QChar*>(const QChar* ch, const QChar* start)
10145 {
10146     return foldCase(reinterpret_cast<const char16_t*>(ch),
10147                     reinterpret_cast<const char16_t*>(start));
10148 }
10149 
10150 template <>
10151 char32_t foldCaseHelper<const char*>(const char* ch, const char*)
10152 {
10153     return foldCase(char16_t(uchar(*ch)));
10154 }
10155 
10156 template <typename T>
10157 char16_t valueTypeToUtf16(T t) = delete;
10158 
10159 template <>
10160 char16_t valueTypeToUtf16<QChar>(QChar t)
10161 {
10162     return t.unicode();
10163 }
10164 
10165 template <>
10166 char16_t valueTypeToUtf16<char>(char t)
10167 {
10168     return char16_t{uchar(t)};
10169 }
10170 }
10171 
10172 /*!
10173     \internal
10174 
10175     Returns the index position of the first occurrence of the
10176     character \a ch in the string given by \a str and \a len,
10177     searching forward from index
10178     position \a from. Returns -1 if \a ch could not be found.
10179 */
10180 
10181 static inline qsizetype qFindChar(QStringView str, QChar ch, qsizetype from, Qt::CaseSensitivity cs) noexcept
10182 {
10183     if (-from > str.size())
10184         return -1;
10185     if (from < 0)
10186         from = qMax(from + str.size(), qsizetype(0));
10187     if (from < str.size()) {
10188         const char16_t *s = str.utf16();
10189         char16_t c = ch.unicode();
10190         const char16_t *n = s + from;
10191         const char16_t *e = s + str.size();
10192         if (cs == Qt::CaseSensitive) {
10193             n = QtPrivate::qustrchr(QStringView(n, e), c);
10194             if (n != e)
10195                 return n - s;
10196         } else {
10197             c = foldCase(c);
10198             --n;
10199             while (++n != e)
10200                 if (foldCase(*n) == c)
10201                     return n - s;
10202         }
10203     }
10204     return -1;
10205 }
10206 
10207 qsizetype QtPrivate::findString(QStringView haystack0, qsizetype from, QStringView needle0, Qt::CaseSensitivity cs) noexcept
10208 {
10209     const qsizetype l = haystack0.size();
10210     const qsizetype sl = needle0.size();
10211     if (from < 0)
10212         from += l;
10213     if (std::size_t(sl + from) > std::size_t(l))
10214         return -1;
10215     if (!sl)
10216         return from;
10217     if (!l)
10218         return -1;
10219 
10220     if (sl == 1)
10221         return qFindChar(haystack0, needle0[0], from, cs);
10222 
10223     /*
10224         We use the Boyer-Moore algorithm in cases where the overhead
10225         for the skip table should pay off, otherwise we use a simple
10226         hash function.
10227     */
10228     if (l > 500 && sl > 5)
10229         return qFindStringBoyerMoore(haystack0, from, needle0, cs);
10230 
10231     auto sv = [sl](const char16_t *v) { return QStringView(v, sl); };
10232     /*
10233         We use some hashing for efficiency's sake. Instead of
10234         comparing strings, we compare the hash value of str with that
10235         of a part of this QString. Only if that matches, we call
10236         qt_string_compare().
10237     */
10238     const char16_t *needle = needle0.utf16();
10239     const char16_t *haystack = haystack0.utf16() + from;
10240     const char16_t *end = haystack0.utf16() + (l - sl);
10241     const std::size_t sl_minus_1 = sl - 1;
10242     std::size_t hashNeedle = 0, hashHaystack = 0;
10243     qsizetype idx;
10244 
10245     if (cs == Qt::CaseSensitive) {
10246         for (idx = 0; idx < sl; ++idx) {
10247             hashNeedle = ((hashNeedle<<1) + needle[idx]);
10248             hashHaystack = ((hashHaystack<<1) + haystack[idx]);
10249         }
10250         hashHaystack -= haystack[sl_minus_1];
10251 
10252         while (haystack <= end) {
10253             hashHaystack += haystack[sl_minus_1];
10254             if (hashHaystack == hashNeedle
10255                  && QtPrivate::compareStrings(needle0, sv(haystack), Qt::CaseSensitive) == 0)
10256                 return haystack - haystack0.utf16();
10257 
10258             REHASH(*haystack);
10259             ++haystack;
10260         }
10261     } else {
10262         const char16_t *haystack_start = haystack0.utf16();
10263         for (idx = 0; idx < sl; ++idx) {
10264             hashNeedle = (hashNeedle<<1) + foldCase(needle + idx, needle);
10265             hashHaystack = (hashHaystack<<1) + foldCase(haystack + idx, haystack_start);
10266         }
10267         hashHaystack -= foldCase(haystack + sl_minus_1, haystack_start);
10268 
10269         while (haystack <= end) {
10270             hashHaystack += foldCase(haystack + sl_minus_1, haystack_start);
10271             if (hashHaystack == hashNeedle
10272                  && QtPrivate::compareStrings(needle0, sv(haystack), Qt::CaseInsensitive) == 0)
10273                 return haystack - haystack0.utf16();
10274 
10275             REHASH(foldCase(haystack, haystack_start));
10276             ++haystack;
10277         }
10278     }
10279     return -1;
10280 }
10281 
10282 template <typename Haystack>
10283 static inline qsizetype qLastIndexOf(Haystack haystack, QChar needle,
10284                                      qsizetype from, Qt::CaseSensitivity cs) noexcept
10285 {
10286     if (from < 0)
10287         from += haystack.size();
10288     if (std::size_t(from) >= std::size_t(haystack.size()))
10289         return -1;
10290     if (from >= 0) {
10291         char16_t c = needle.unicode();
10292         const auto b = haystack.data();
10293         auto n = b + from;
10294         if (cs == Qt::CaseSensitive) {
10295             for (; n >= b; --n)
10296                 if (valueTypeToUtf16(*n) == c)
10297                     return n - b;
10298         } else {
10299             c = foldCase(c);
10300             for (; n >= b; --n)
10301                 if (foldCase(valueTypeToUtf16(*n)) == c)
10302                     return n - b;
10303         }
10304     }
10305     return -1;
10306 }
10307 
10308 template<typename Haystack, typename Needle>
10309 static qsizetype qLastIndexOf(Haystack haystack0, qsizetype from,
10310                               Needle needle0, Qt::CaseSensitivity cs) noexcept
10311 {
10312     const qsizetype sl = needle0.size();
10313     if (sl == 1)
10314         return qLastIndexOf(haystack0, needle0.front(), from, cs);
10315 
10316     const qsizetype l = haystack0.size();
10317     if (from < 0)
10318         from += l;
10319     if (from == l && sl == 0)
10320         return from;
10321     const qsizetype delta = l - sl;
10322     if (std::size_t(from) >= std::size_t(l) || delta < 0)
10323         return -1;
10324     if (from > delta)
10325         from = delta;
10326 
10327     auto sv = [sl](const typename Haystack::value_type *v) { return Haystack(v, sl); };
10328 
10329     auto haystack = haystack0.data();
10330     const auto needle = needle0.data();
10331     const auto *end = haystack;
10332     haystack += from;
10333     const std::size_t sl_minus_1 = sl - 1;
10334     const auto *n = needle + sl_minus_1;
10335     const auto *h = haystack + sl_minus_1;
10336     std::size_t hashNeedle = 0, hashHaystack = 0;
10337     qsizetype idx;
10338 
10339     if (cs == Qt::CaseSensitive) {
10340         for (idx = 0; idx < sl; ++idx) {
10341             hashNeedle = (hashNeedle << 1) + valueTypeToUtf16(*(n - idx));
10342             hashHaystack = (hashHaystack << 1) + valueTypeToUtf16(*(h - idx));
10343         }
10344         hashHaystack -= valueTypeToUtf16(*haystack);
10345 
10346         while (haystack >= end) {
10347             hashHaystack += valueTypeToUtf16(*haystack);
10348             if (hashHaystack == hashNeedle
10349                  && QtPrivate::compareStrings(needle0, sv(haystack), Qt::CaseSensitive) == 0)
10350                 return haystack - end;
10351             --haystack;
10352             REHASH(valueTypeToUtf16(haystack[sl]));
10353         }
10354     } else {
10355         for (idx = 0; idx < sl; ++idx) {
10356             hashNeedle = (hashNeedle << 1) + foldCaseHelper(n - idx, needle);
10357             hashHaystack = (hashHaystack << 1) + foldCaseHelper(h - idx, end);
10358         }
10359         hashHaystack -= foldCaseHelper(haystack, end);
10360 
10361         while (haystack >= end) {
10362             hashHaystack += foldCaseHelper(haystack, end);
10363             if (hashHaystack == hashNeedle
10364                  && QtPrivate::compareStrings(sv(haystack), needle0, Qt::CaseInsensitive) == 0)
10365                 return haystack - end;
10366             --haystack;
10367             REHASH(foldCaseHelper(haystack + sl, end));
10368         }
10369     }
10370     return -1;
10371 }
10372 
10373 qsizetype QtPrivate::findString(QStringView haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10374 {
10375     if (haystack.size() < needle.size())
10376         return -1;
10377 
10378     QVarLengthArray<char16_t> s(needle.size());
10379     qt_from_latin1(s.data(), needle.latin1(), needle.size());
10380     return QtPrivate::findString(haystack, from, QStringView(reinterpret_cast<const QChar*>(s.constData()), s.size()), cs);
10381 }
10382 
10383 qsizetype QtPrivate::findString(QLatin1String haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
10384 {
10385     if (haystack.size() < needle.size())
10386         return -1;
10387 
10388     QVarLengthArray<char16_t> s(haystack.size());
10389     qt_from_latin1(s.data(), haystack.latin1(), haystack.size());
10390     return QtPrivate::findString(QStringView(reinterpret_cast<const QChar*>(s.constData()), s.size()), from, needle, cs);
10391 }
10392 
10393 qsizetype QtPrivate::findString(QLatin1String haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10394 {
10395     if (from < 0)
10396         from += haystack.size();
10397     if (from < 0)
10398         return -1;
10399     qsizetype adjustedSize = haystack.size() - from;
10400     if (adjustedSize < needle.size())
10401         return -1;
10402     if (needle.size() == 0)
10403         return from;
10404 
10405     if (cs == Qt::CaseSensitive) {
10406         const QByteArrayMatcher matcher(needle.data(), needle.size());
10407         return matcher.indexIn(haystack.data(), haystack.size(), from);
10408     }
10409 
10410     // If the needle is sufficiently small we simply iteratively search through
10411     // the haystack. When the needle is too long we use a boyer-moore searcher
10412     // from the standard library, if available. If it is not available then the
10413     // QLatin1Strings are converted to QString and compared as such. Though
10414     // initialization is slower the boyer-moore search it employs still makes up
10415     // for it when haystack and needle are sufficiently long.
10416     // The needle size was chosen by testing various lengths using the
10417     // qstringtokenizer benchmark with the
10418     // "tokenize_qlatin1string_qlatin1string" test.
10419 #ifdef Q_CC_MSVC
10420     const qsizetype threshold = 1;
10421 #else
10422     const qsizetype threshold = 13;
10423 #endif
10424     if (needle.size() <= threshold) {
10425         const auto begin = haystack.begin();
10426         const auto end = haystack.end() - needle.size() + 1;
10427         const uchar needle1 = latin1Lower[uchar(needle[0].toLatin1())];
10428         auto ciMatch = [needle1](const char ch) {
10429             return latin1Lower[uchar(ch)] == needle1;
10430         };
10431         const qsizetype nlen1 = needle.size() - 1;
10432         for (auto it = std::find_if(begin + from, end, ciMatch); it < end;
10433              it = std::find_if(it + 1, end, ciMatch)) {
10434             // In this comparison we skip the first character because we know it's a match
10435             if (!nlen1 || QLatin1String(it + 1, nlen1).compare(needle.sliced(1), cs) == 0)
10436                 return std::distance(begin, it);
10437         }
10438         return -1;
10439     }
10440 
10441 #if QT_CONFIG(cxx17_bm_searcher)
10442     const auto ciHasher = [](char a) { return latin1Lower[uchar(a)]; };
10443     const auto ciEqual = [](char a, char b) {
10444         return latin1Lower[uchar(a)] == latin1Lower[uchar(b)];
10445     };
10446     const auto it =
10447             std::search(haystack.begin() + from, haystack.end(),
10448                         std::boyer_moore_searcher(needle.begin(), needle.end(), ciHasher, ciEqual));
10449     return it == haystack.end() ? -1 : std::distance(haystack.begin(), it);
10450 #else
10451     QVarLengthArray<char16_t> h(adjustedSize);
10452     const auto begin = haystack.end() - adjustedSize;
10453     qt_from_latin1(h.data(), begin, adjustedSize);
10454     QVarLengthArray<char16_t> n(needle.size());
10455     qt_from_latin1(n.data(), needle.latin1(), needle.size());
10456     qsizetype res = QtPrivate::findString(QStringView(h.constData(), h.size()), 0,
10457                                           QStringView(n.constData(), n.size()), cs);
10458     if (res == -1)
10459         return -1;
10460     return res + std::distance(haystack.begin(), begin);
10461 #endif
10462 }
10463 
10464 qsizetype QtPrivate::lastIndexOf(QStringView haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
10465 {
10466     return qLastIndexOf(haystack, from, needle, cs);
10467 }
10468 
10469 qsizetype QtPrivate::lastIndexOf(QStringView haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10470 {
10471     return qLastIndexOf(haystack, from, needle, cs);
10472 }
10473 
10474 qsizetype QtPrivate::lastIndexOf(QLatin1String haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
10475 {
10476     return qLastIndexOf(haystack, from, needle, cs);
10477 }
10478 
10479 qsizetype QtPrivate::lastIndexOf(QLatin1String haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10480 {
10481     return qLastIndexOf(haystack, from, needle, cs);
10482 }
10483 
10484 #if QT_CONFIG(regularexpression)
10485 qsizetype QtPrivate::indexOf(QStringView haystack, const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch)
10486 {
10487     if (!re.isValid()) {
10488         qWarning("QStringView::indexOf: invalid QRegularExpression object");
10489         return -1;
10490     }
10491 
10492     QRegularExpressionMatch match = re.match(haystack, from);
10493     if (match.hasMatch()) {
10494         const qsizetype ret = match.capturedStart();
10495         if (rmatch)
10496             *rmatch = std::move(match);
10497         return ret;
10498     }
10499 
10500     return -1;
10501 }
10502 
10503 qsizetype QtPrivate::lastIndexOf(QStringView haystack, const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch)
10504 {
10505     if (!re.isValid()) {
10506         qWarning("QStringView::lastIndexOf: invalid QRegularExpression object");
10507         return -1;
10508     }
10509 
10510     qsizetype endpos = (from < 0) ? (haystack.size() + from + 1) : (from);
10511     QRegularExpressionMatchIterator iterator = re.globalMatch(haystack);
10512     qsizetype lastIndex = -1;
10513     while (iterator.hasNext()) {
10514         QRegularExpressionMatch match = iterator.next();
10515         qsizetype start = match.capturedStart();
10516         if (start <= endpos) {
10517             lastIndex = start;
10518             if (rmatch)
10519                 *rmatch = std::move(match);
10520         } else {
10521             break;
10522         }
10523     }
10524 
10525     return lastIndex;
10526 }
10527 
10528 bool QtPrivate::contains(QStringView haystack, const QRegularExpression &re, QRegularExpressionMatch *rmatch)
10529 {
10530     if (!re.isValid()) {
10531         qWarning("QStringView::contains: invalid QRegularExpression object");
10532         return false;
10533     }
10534     QRegularExpressionMatch m = re.match(haystack);
10535     bool hasMatch = m.hasMatch();
10536     if (hasMatch && rmatch)
10537         *rmatch = std::move(m);
10538     return hasMatch;
10539 }
10540 
10541 qsizetype QtPrivate::count(QStringView haystack, const QRegularExpression &re)
10542 {
10543     if (!re.isValid()) {
10544         qWarning("QStringView::count: invalid QRegularExpression object");
10545         return 0;
10546     }
10547     qsizetype count = 0;
10548     qsizetype index = -1;
10549     qsizetype len = haystack.length();
10550     while (index <= len - 1) {
10551         QRegularExpressionMatch match = re.match(haystack, index + 1);
10552         if (!match.hasMatch())
10553             break;
10554         index = match.capturedStart();
10555         count++;
10556     }
10557     return count;
10558 }
10559 
10560 #endif // QT_CONFIG(regularexpression)
10561 
10562 /*!
10563     \since 5.0
10564 
10565     Converts a plain text string to an HTML string with
10566     HTML metacharacters \c{<}, \c{>}, \c{&}, and \c{"} replaced by HTML
10567     entities.
10568 
10569     Example:
10570 
10571     \snippet code/src_corelib_text_qstring.cpp 7
10572 */
10573 QString QString::toHtmlEscaped() const
10574 {
10575     QString rich;
10576     const int len = length();
10577     rich.reserve(qsizetype(len * 1.1));
10578     for (int i = 0; i < len; ++i) {
10579         if (at(i) == QLatin1Char('<'))
10580             rich += QLatin1String("&lt;");
10581         else if (at(i) == QLatin1Char('>'))
10582             rich += QLatin1String("&gt;");
10583         else if (at(i) == QLatin1Char('&'))
10584             rich += QLatin1String("&amp;");
10585         else if (at(i) == QLatin1Char('"'))
10586             rich += QLatin1String("&quot;");
10587         else
10588             rich += at(i);
10589     }
10590     rich.squeeze();
10591     return rich;
10592 }
10593 
10594 /*!
10595   \macro QStringLiteral(str)
10596   \relates QString
10597 
10598   The macro generates the data for a QString out of the string literal \a str
10599   at compile time. Creating a QString from it is free in this case, and the
10600   generated string data is stored in the read-only segment of the compiled
10601   object file.
10602 
10603   If you have code that looks like this:
10604 
10605   \snippet code/src_corelib_text_qstring.cpp 9
10606 
10607   then a temporary QString will be created to be passed as the \c{hasAttribute}
10608   function parameter. This can be quite expensive, as it involves a memory
10609   allocation and the copy/conversion of the data into QString's internal
10610   encoding.
10611 
10612   This cost can be avoided by using QStringLiteral instead:
10613 
10614   \snippet code/src_corelib_text_qstring.cpp 10
10615 
10616   In this case, QString's internal data will be generated at compile time; no
10617   conversion or allocation will occur at runtime.
10618 
10619   Using QStringLiteral instead of a double quoted plain C++ string literal can
10620   significantly speed up creation of QString instances from data known at
10621   compile time.
10622 
10623   \note QLatin1String can still be more efficient than QStringLiteral
10624   when the string is passed to a function that has an overload taking
10625   QLatin1String and this overload avoids conversion to QString.  For
10626   instance, QString::operator==() can compare to a QLatin1String
10627   directly:
10628 
10629   \snippet code/src_corelib_text_qstring.cpp 11
10630 
10631   \note Some compilers have bugs encoding strings containing characters outside
10632   the US-ASCII character set. Make sure you prefix your string with \c{u} in
10633   those cases. It is optional otherwise.
10634 
10635   \sa QByteArrayLiteral
10636 */
10637 
10638 /*!
10639   \fn QtLiterals::operator""_qs(const char16_t *str, size_t size)
10640 
10641   \relates QString
10642   \since 6.2
10643 
10644   Literal operator that creates a QString out of the first \a size characters in
10645   the char16_t string literal \a str.
10646 
10647   The QString is created at compile time, and the generated string data is stored
10648   in the read-only segment of the compiled object file. Duplicate literals may
10649   share the same read-only memory. This functionality is interchangeable with
10650   QStringLiteral, but saves typing when many string literals are present in the
10651   code.
10652 
10653   The following code creates a QString:
10654   \code
10655   auto str = u"hello"_qs;
10656   \endcode
10657 
10658   \sa QStringLiteral, QtLiterals::operator""_qba(const char *str, size_t size)
10659 */
10660 
10661 /*!
10662     \internal
10663  */
10664 void QAbstractConcatenable::appendLatin1To(QLatin1String in, QChar *out) noexcept
10665 {
10666     qt_from_latin1(reinterpret_cast<char16_t *>(out), in.data(), size_t(in.size()));
10667 }
10668 
10669 double QStringView::toDouble(bool *ok) const
10670 {
10671     return QLocaleData::c()->stringToDouble(*this, ok, QLocale::RejectGroupSeparator);
10672 }
10673 
10674 float QStringView::toFloat(bool *ok) const
10675 {
10676     return QLocaleData::convertDoubleToFloat(toDouble(ok), ok);
10677 }
10678 
10679 /*!
10680   \fn template <typename T> qsizetype erase(QString &s, const T &t)
10681   \relates QString
10682   \since 6.1
10683 
10684   Removes all elements that compare equal to \a t from the
10685   string \a s. Returns the number of elements removed, if any.
10686 
10687   \sa erase_if
10688 */
10689 
10690 /*!
10691   \fn template <typename Predicate> qsizetype erase_if(QString &s, Predicate pred)
10692   \relates QString
10693   \since 6.1
10694 
10695   Removes all elements for which the predicate \a pred returns true
10696   from the string \a s. Returns the number of elements removed, if
10697   any.
10698 
10699   \sa erase
10700 */
10701 
10702 QT_END_NAMESPACE
