Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtGui module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qfontdatabase.h"
41 #include "qfontdatabase_p.h"
42 #include "qloggingcategory.h"
43 #include "qalgorithms.h"
44 #include "qguiapplication.h"
45 #include "qvarlengtharray.h" // here or earlier - workaround for VC++6
46 #include "qthread.h"
47 #include "qmutex.h"
48 #include "qfile.h"
49 #include "qfileinfo.h"
50 #include "qfontengine_p.h"
51 #include <qpa/qplatformintegration.h>
52 
53 #include <QtGui/private/qguiapplication_p.h>
54 #include <qpa/qplatformfontdatabase.h>
55 #include <qpa/qplatformtheme.h>
56 
57 #include <QtCore/qcache.h>
58 #include <QtCore/qmath.h>
59 
60 #include <stdlib.h>
61 #include <algorithm>
62 
63 #include <qtgui_tracepoints_p.h>
64 
65 #ifdef Q_OS_WIN
66 #include <QtGui/private/qwindowsfontdatabasebase_p.h>
67 #endif
68 
69 QT_BEGIN_NAMESPACE
70 
71 Q_LOGGING_CATEGORY(lcFontDb, "qt.text.font.db")
72 Q_LOGGING_CATEGORY(lcFontMatch, "qt.text.font.match")
73 
74 #define SMOOTH_SCALABLE 0xffff
75 
76 #if defined(QT_BUILD_INTERNAL)
77 bool qt_enable_test_font = false;
78 
79 Q_AUTOTEST_EXPORT void qt_setQtEnableTestFont(bool value)
80 {
81     qt_enable_test_font = value;
82 }
83 #endif
84 
85 static int getFontWeight(const QString &weightString)
86 {
87     QString s = weightString.toLower();
88 
89     // Order here is important. We want to match the common cases first, but we
90     // must also take care to acknowledge the cost of our tests.
91     //
92     // As a result, we test in two orders; the order of commonness, and the
93     // order of "expense".
94     //
95     // A simple string test is the cheapest, so let's do that first.
96     // Test in decreasing order of commonness
97     if (s == QLatin1String("normal") || s == QLatin1String("regular"))
98         return QFont::Normal;
99     if (s == QLatin1String("bold"))
100         return QFont::Bold;
101     if (s == QLatin1String("semibold") || s == QLatin1String("semi bold")
102             || s == QLatin1String("demibold") || s == QLatin1String("demi bold"))
103         return QFont::DemiBold;
104     if (s == QLatin1String("medium"))
105         return QFont::Medium;
106     if (s == QLatin1String("black"))
107         return QFont::Black;
108     if (s == QLatin1String("light"))
109         return QFont::Light;
110     if (s == QLatin1String("thin"))
111         return QFont::Thin;
112     const QStringView s2 = QStringView{s}.mid(2);
113     if (s.startsWith(QLatin1String("ex")) || s.startsWith(QLatin1String("ul"))) {
114             if (s2 == QLatin1String("tralight") || s == QLatin1String("tra light"))
115                 return QFont::ExtraLight;
116             if (s2 == QLatin1String("trabold") || s2 == QLatin1String("tra bold"))
117                 return QFont::ExtraBold;
118     }
119 
120     // Next up, let's see if contains() matches: slightly more expensive, but
121     // still fast enough.
122     if (s.contains(QLatin1String("bold"))) {
123         if (s.contains(QLatin1String("demi")))
124             return QFont::DemiBold;
125         return QFont::Bold;
126     }
127     if (s.contains(QLatin1String("thin")))
128         return QFont::Thin;
129     if (s.contains(QLatin1String("light")))
130         return QFont::Light;
131     if (s.contains(QLatin1String("black")))
132         return QFont::Black;
133 
134     // Now, we perform string translations & comparisons with those.
135     // These are (very) slow compared to simple string ops, so we do these last.
136     // As using translated values for such things is not very common, this should
137     // not be too bad.
138     if (s.compare(QCoreApplication::translate("QFontDatabase", "Normal", "The Normal or Regular font weight"), Qt::CaseInsensitive) == 0)
139         return QFont::Normal;
140     const QString translatedBold = QCoreApplication::translate("QFontDatabase", "Bold").toLower();
141     if (s == translatedBold)
142         return QFont::Bold;
143     if (s.compare(QCoreApplication::translate("QFontDatabase", "Demi Bold"), Qt::CaseInsensitive) == 0)
144         return QFont::DemiBold;
145     if (s.compare(QCoreApplication::translate("QFontDatabase", "Medium", "The Medium font weight"), Qt::CaseInsensitive) == 0)
146         return QFont::Medium;
147     if (s.compare(QCoreApplication::translate("QFontDatabase", "Black"), Qt::CaseInsensitive) == 0)
148         return QFont::Black;
149     const QString translatedLight = QCoreApplication::translate("QFontDatabase", "Light").toLower();
150     if (s == translatedLight)
151         return QFont::Light;
152     if (s.compare(QCoreApplication::translate("QFontDatabase", "Thin"), Qt::CaseInsensitive) == 0)
153         return QFont::Thin;
154     if (s.compare(QCoreApplication::translate("QFontDatabase", "Extra Light"), Qt::CaseInsensitive) == 0)
155         return QFont::ExtraLight;
156     if (s.compare(QCoreApplication::translate("QFontDatabase", "Extra Bold"), Qt::CaseInsensitive) == 0)
157         return QFont::ExtraBold;
158 
159     // And now the contains() checks for the translated strings.
160     //: The word for "Extra" as in "Extra Bold, Extra Thin" used as a pattern for string searches
161     const QString translatedExtra = QCoreApplication::translate("QFontDatabase", "Extra").toLower();
162     if (s.contains(translatedBold)) {
163         //: The word for "Demi" as in "Demi Bold" used as a pattern for string searches
164         QString translatedDemi = QCoreApplication::translate("QFontDatabase", "Demi").toLower();
165         if (s .contains(translatedDemi))
166             return QFont::DemiBold;
167         if (s.contains(translatedExtra))
168             return QFont::ExtraBold;
169         return QFont::Bold;
170     }
171 
172     if (s.contains(translatedLight)) {
173         if (s.contains(translatedExtra))
174             return QFont::ExtraLight;
175         return QFont::Light;
176     }
177     return QFont::Normal;
178 }
179 
180 
181 QtFontStyle::Key::Key(const QString &styleString)
182     : style(QFont::StyleNormal), weight(QFont::Normal), stretch(0)
183 {
184     weight = getFontWeight(styleString);
185 
186     if (!styleString.isEmpty()) {
187         // First the straightforward no-translation checks, these are fast.
188         if (styleString.contains(QLatin1String("Italic")))
189             style = QFont::StyleItalic;
190         else if (styleString.contains(QLatin1String("Oblique")))
191             style = QFont::StyleOblique;
192 
193         // Then the translation checks. These aren't as fast.
194         else if (styleString.contains(QCoreApplication::translate("QFontDatabase", "Italic")))
195             style = QFont::StyleItalic;
196         else if (styleString.contains(QCoreApplication::translate("QFontDatabase", "Oblique")))
197             style = QFont::StyleOblique;
198     }
199 }
200 
201 QtFontSize *QtFontStyle::pixelSize(unsigned short size, bool add)
202 {
203     for (int i = 0; i < count; i++) {
204         if (pixelSizes[i].pixelSize == size)
205             return pixelSizes + i;
206     }
207     if (!add)
208         return nullptr;
209 
210     if (!pixelSizes) {
211         // Most style have only one font size, we avoid waisting memory
212         QtFontSize *newPixelSizes = (QtFontSize *)malloc(sizeof(QtFontSize));
213         Q_CHECK_PTR(newPixelSizes);
214         pixelSizes = newPixelSizes;
215     } else if (!(count % 8) || count == 1) {
216         QtFontSize *newPixelSizes = (QtFontSize *)
217                      realloc(pixelSizes,
218                               (((count+8) >> 3) << 3) * sizeof(QtFontSize));
219         Q_CHECK_PTR(newPixelSizes);
220         pixelSizes = newPixelSizes;
221     }
222     pixelSizes[count].pixelSize = size;
223     pixelSizes[count].handle = nullptr;
224     return pixelSizes + (count++);
225 }
226 
227 QtFontStyle *QtFontFoundry::style(const QtFontStyle::Key &key, const QString &styleName, bool create)
228 {
229     int pos = 0;
230     for (; pos < count; pos++) {
231         bool hasStyleName = !styleName.isEmpty(); // search styleName first if available
232         if (hasStyleName && !styles[pos]->styleName.isEmpty()) {
233             if (styles[pos]->styleName == styleName)
234                 return styles[pos];
235         } else {
236             if (styles[pos]->key == key)
237                 return styles[pos];
238         }
239     }
240     if (!create)
241         return nullptr;
242 
243 //     qDebug("adding key (weight=%d, style=%d, oblique=%d stretch=%d) at %d", key.weight, key.style, key.oblique, key.stretch, pos);
244     if (!(count % 8)) {
245         QtFontStyle **newStyles = (QtFontStyle **)
246                  realloc(styles, (((count+8) >> 3) << 3) * sizeof(QtFontStyle *));
247         Q_CHECK_PTR(newStyles);
248         styles = newStyles;
249     }
250 
251     QtFontStyle *style = new QtFontStyle(key);
252     style->styleName = styleName;
253     styles[pos] = style;
254     count++;
255     return styles[pos];
256 }
257 
258 QtFontFoundry *QtFontFamily::foundry(const QString &f, bool create)
259 {
260     if (f.isNull() && count == 1)
261         return foundries[0];
262 
263     for (int i = 0; i < count; i++) {
264         if (foundries[i]->name.compare(f, Qt::CaseInsensitive) == 0)
265             return foundries[i];
266     }
267     if (!create)
268         return nullptr;
269 
270     if (!(count % 8)) {
271         QtFontFoundry **newFoundries = (QtFontFoundry **)
272                     realloc(foundries,
273                              (((count+8) >> 3) << 3) * sizeof(QtFontFoundry *));
274         Q_CHECK_PTR(newFoundries);
275         foundries = newFoundries;
276     }
277 
278     foundries[count] = new QtFontFoundry(f);
279     return foundries[count++];
280 }
281 
282 static inline bool equalsCaseInsensitive(const QString &a, const QString &b)
283 {
284     return a.size() == b.size() && a.compare(b, Qt::CaseInsensitive) == 0;
285 }
286 
287 bool QtFontFamily::matchesFamilyName(const QString &familyName) const
288 {
289     return equalsCaseInsensitive(name, familyName) || aliases.contains(familyName, Qt::CaseInsensitive);
290 }
291 
292 void QtFontFamily::ensurePopulated()
293 {
294     if (populated)
295         return;
296 
297     QGuiApplicationPrivate::platformIntegration()->fontDatabase()->populateFamily(name);
298     Q_ASSERT_X(populated, Q_FUNC_INFO, qPrintable(name));
299 }
300 
301 void QFontDatabasePrivate::invalidate()
302 {
303     QFontCache::instance()->clear();
304 
305     fallbacksCache.clear();
306     free();
307     QGuiApplicationPrivate::platformIntegration()->fontDatabase()->invalidate();
308     emit static_cast<QGuiApplication *>(QCoreApplication::instance())->fontDatabaseChanged();
309 }
310 
311 QtFontFamily *QFontDatabasePrivate::family(const QString &f, FamilyRequestFlags flags)
312 {
313     QtFontFamily *fam = nullptr;
314 
315     int low = 0;
316     int high = count;
317     int pos = count / 2;
318     int res = 1;
319     if (count) {
320         while ((res = families[pos]->name.compare(f, Qt::CaseInsensitive)) && pos != low) {
321             if (res > 0)
322                 high = pos;
323             else
324                 low = pos;
325             pos = (high + low) / 2;
326         }
327         if (!res)
328             fam = families[pos];
329     }
330 
331     if (!fam && (flags & EnsureCreated)) {
332         if (res < 0)
333             pos++;
334 
335         // qDebug() << "adding family " << f.toLatin1() << " at " << pos << " total=" << count;
336         if (!(count % 8)) {
337             QtFontFamily **newFamilies = (QtFontFamily **)
338                        realloc(families,
339                                 (((count+8) >> 3) << 3) * sizeof(QtFontFamily *));
340             Q_CHECK_PTR(newFamilies);
341             families = newFamilies;
342         }
343 
344         QtFontFamily *family = new QtFontFamily(f);
345         memmove(families + pos + 1, families + pos, (count-pos)*sizeof(QtFontFamily *));
346         families[pos] = family;
347         count++;
348 
349         fam = families[pos];
350     }
351 
352     if (fam && (flags & EnsurePopulated))
353         fam->ensurePopulated();
354 
355     return fam;
356 }
357 
358 
359 
360 static const int scriptForWritingSystem[] = {
361     QChar::Script_Common, // Any
362     QChar::Script_Latin, // Latin
363     QChar::Script_Greek, // Greek
364     QChar::Script_Cyrillic, // Cyrillic
365     QChar::Script_Armenian, // Armenian
366     QChar::Script_Hebrew, // Hebrew
367     QChar::Script_Arabic, // Arabic
368     QChar::Script_Syriac, // Syriac
369     QChar::Script_Thaana, // Thaana
370     QChar::Script_Devanagari, // Devanagari
371     QChar::Script_Bengali, // Bengali
372     QChar::Script_Gurmukhi, // Gurmukhi
373     QChar::Script_Gujarati, // Gujarati
374     QChar::Script_Oriya, // Oriya
375     QChar::Script_Tamil, // Tamil
376     QChar::Script_Telugu, // Telugu
377     QChar::Script_Kannada, // Kannada
378     QChar::Script_Malayalam, // Malayalam
379     QChar::Script_Sinhala, // Sinhala
380     QChar::Script_Thai, // Thai
381     QChar::Script_Lao, // Lao
382     QChar::Script_Tibetan, // Tibetan
383     QChar::Script_Myanmar, // Myanmar
384     QChar::Script_Georgian, // Georgian
385     QChar::Script_Khmer, // Khmer
386     QChar::Script_Han, // SimplifiedChinese
387     QChar::Script_Han, // TraditionalChinese
388     QChar::Script_Han, // Japanese
389     QChar::Script_Hangul, // Korean
390     QChar::Script_Latin, // Vietnamese
391     QChar::Script_Common, // Symbol
392     QChar::Script_Ogham,  // Ogham
393     QChar::Script_Runic, // Runic
394     QChar::Script_Nko // Nko
395 };
396 
397 static_assert(sizeof(scriptForWritingSystem) / sizeof(scriptForWritingSystem[0]) == QFontDatabase::WritingSystemsCount);
398 
399 Q_GUI_EXPORT int qt_script_for_writing_system(QFontDatabase::WritingSystem writingSystem)
400 {
401     return scriptForWritingSystem[writingSystem];
402 }
403 
404 
405 /*!
406     \internal
407 
408     Tests if the given family \a family supports writing system \a writingSystem,
409     including the special case for Han script mapping to several subsequent writing systems
410 */
411 static bool familySupportsWritingSystem(QtFontFamily *family, size_t writingSystem)
412 {
413     Q_ASSERT(family != nullptr);
414     Q_ASSERT(writingSystem != QFontDatabase::Any && writingSystem < QFontDatabase::WritingSystemsCount);
415 
416     size_t ws = writingSystem;
417     do {
418         if ((family->writingSystems[ws] & QtFontFamily::Supported) != 0)
419             return true;
420     } while (writingSystem >= QFontDatabase::SimplifiedChinese && writingSystem <= QFontDatabase::Japanese && ++ws <= QFontDatabase::Japanese);
421 
422     return false;
423 }
424 
425 Q_GUI_EXPORT QFontDatabase::WritingSystem qt_writing_system_for_script(int script)
426 {
427     return QFontDatabase::WritingSystem(std::find(scriptForWritingSystem,
428                                                   scriptForWritingSystem + QFontDatabase::WritingSystemsCount,
429                                                   script) - scriptForWritingSystem);
430 }
431 
432 /*!
433   \internal
434 
435   This makes sense of the font family name:
436 
437   if the family name contains a '[' and a ']', then we take the text
438   between the square brackets as the foundry, and the text before the
439   square brackets as the family (ie. "Arial [Monotype]")
440 */
441 static void parseFontName(const QString &name, QString &foundry, QString &family)
442 {
443     int i = name.indexOf(QLatin1Char('['));
444     int li = name.lastIndexOf(QLatin1Char(']'));
445     if (i >= 0 && li >= 0 && i < li) {
446         foundry = name.mid(i + 1, li - i - 1);
447         if (i > 0 && name[i - 1] == QLatin1Char(' '))
448             i--;
449         family = name.left(i);
450     } else {
451         foundry.clear();
452         family = name;
453     }
454 
455     // capitalize the family/foundry names
456     bool space = true;
457     QChar *s = family.data();
458     int len = family.length();
459     while(len--) {
460         if (space) *s = s->toUpper();
461         space = s->isSpace();
462         ++s;
463     }
464 
465     space = true;
466     s = foundry.data();
467     len = foundry.length();
468     while(len--) {
469         if (space) *s = s->toUpper();
470         space = s->isSpace();
471         ++s;
472     }
473 }
474 
475 
476 struct QtFontDesc
477 {
478     inline QtFontDesc() : family(nullptr), foundry(nullptr), style(nullptr), size(nullptr) {}
479     QtFontFamily *family;
480     QtFontFoundry *foundry;
481     QtFontStyle *style;
482     QtFontSize *size;
483 };
484 
485 static void initFontDef(const QtFontDesc &desc, const QFontDef &request, QFontDef *fontDef, bool multi)
486 {
487     QString family;
488     family = desc.family->name;
489     if (! desc.foundry->name.isEmpty() && desc.family->count > 1)
490         family += QLatin1String(" [") + desc.foundry->name + QLatin1Char(']');
491     fontDef->families = QStringList(family);
492 
493     if (desc.style->smoothScalable
494         || QGuiApplicationPrivate::platformIntegration()->fontDatabase()->fontsAlwaysScalable()
495         || (desc.style->bitmapScalable && (request.styleStrategy & QFont::PreferMatch))) {
496         fontDef->pixelSize = request.pixelSize;
497     } else {
498         fontDef->pixelSize = desc.size->pixelSize;
499     }
500     fontDef->pointSize     = request.pointSize;
501 
502     fontDef->styleHint     = request.styleHint;
503     fontDef->styleStrategy = request.styleStrategy;
504 
505     if (!multi)
506         fontDef->weight    = desc.style->key.weight;
507     if (!multi)
508         fontDef->style     = desc.style->key.style;
509     fontDef->fixedPitch    = desc.family->fixedPitch;
510     fontDef->ignorePitch   = false;
511 }
512 
513 static QStringList familyList(const QFontDef &req)
514 {
515     // list of families to try
516     QStringList family_list;
517 
518     family_list << req.families;
519     // append the substitute list for each family in family_list
520     for (int i = 0, size = family_list.size(); i < size; ++i)
521         family_list += QFont::substitutes(family_list.at(i));
522 
523     return family_list;
524 }
525 
526 Q_GLOBAL_STATIC(QRecursiveMutex, fontDatabaseMutex)
527 
528 // used in qguiapplication.cpp
529 void qt_cleanupFontDatabase()
530 {
531     auto *db = QFontDatabasePrivate::instance();
532     db->fallbacksCache.clear();
533     db->free();
534 }
535 
536 // used in qfont.cpp
537 QRecursiveMutex *qt_fontdatabase_mutex()
538 {
539     return fontDatabaseMutex();
540 }
541 
542 QFontDatabasePrivate *QFontDatabasePrivate::instance()
543 {
544     static QFontDatabasePrivate *instance = new QFontDatabasePrivate;
545     return instance;
546 }
547 
548 void qt_registerFont(const QString &familyName, const QString &stylename,
549                      const QString &foundryname, int weight,
550                      QFont::Style style, int stretch, bool antialiased,
551                      bool scalable, int pixelSize, bool fixedPitch,
552                      const QSupportedWritingSystems &writingSystems, void *handle)
553 {
554     auto *d = QFontDatabasePrivate::instance();
555     qCDebug(lcFontDb) << "Adding font: familyName" << familyName << "stylename" << stylename << "weight" << weight
556         << "style" << style << "pixelSize" << pixelSize << "antialiased" << antialiased << "fixed" << fixedPitch;
557     QtFontStyle::Key styleKey;
558     styleKey.style = style;
559     styleKey.weight = weight;
560     styleKey.stretch = stretch;
561     QtFontFamily *f = d->family(familyName, QFontDatabasePrivate::EnsureCreated);
562     f->fixedPitch = fixedPitch;
563 
564     for (int i = 0; i < QFontDatabase::WritingSystemsCount; ++i) {
565         if (writingSystems.supported(QFontDatabase::WritingSystem(i)))
566             f->writingSystems[i] = QtFontFamily::Supported;
567     }
568 
569     QtFontFoundry *foundry = f->foundry(foundryname, true);
570     QtFontStyle *fontStyle = foundry->style(styleKey, stylename, true);
571     fontStyle->smoothScalable = scalable;
572     fontStyle->antialiased = antialiased;
573     QtFontSize *size = fontStyle->pixelSize(pixelSize ? pixelSize : SMOOTH_SCALABLE, true);
574     if (size->handle) {
575         QPlatformIntegration *integration = QGuiApplicationPrivate::platformIntegration();
576         if (integration)
577             integration->fontDatabase()->releaseHandle(size->handle);
578     }
579     size->handle = handle;
580     f->populated = true;
581 }
582 
583 void qt_registerFontFamily(const QString &familyName)
584 {
585     // Create uninitialized/unpopulated family
586     QFontDatabasePrivate::instance()->family(familyName, QFontDatabasePrivate::EnsureCreated);
587 }
588 
589 void qt_registerAliasToFontFamily(const QString &familyName, const QString &alias)
590 {
591     if (alias.isEmpty())
592         return;
593 
594     auto *d = QFontDatabasePrivate::instance();
595     QtFontFamily *f = d->family(familyName, QFontDatabasePrivate::RequestFamily);
596     if (!f)
597         return;
598 
599     if (f->aliases.contains(alias, Qt::CaseInsensitive))
600         return;
601 
602     f->aliases.push_back(alias);
603 }
604 
605 QString qt_resolveFontFamilyAlias(const QString &alias)
606 {
607     if (!alias.isEmpty()) {
608         const auto *d = QFontDatabasePrivate::instance();
609         for (int i = 0; i < d->count; ++i)
610             if (d->families[i]->matchesFamilyName(alias))
611                 return d->families[i]->name;
612     }
613     return alias;
614 }
615 
616 bool qt_isFontFamilyPopulated(const QString &familyName)
617 {
618     auto *d = QFontDatabasePrivate::instance();
619     QtFontFamily *f = d->family(familyName, QFontDatabasePrivate::RequestFamily);
620     return f != nullptr && f->populated;
621 }
622 
623 /*!
624     Returns a list of alternative fonts for the specified \a family and
625     \a style and \a script using the \a styleHint given.
626 
627     Default implementation returns a list of fonts for which \a style and \a script support
628     has been reported during the font database population.
629 */
630 QStringList QPlatformFontDatabase::fallbacksForFamily(const QString &family, QFont::Style style, QFont::StyleHint styleHint, QChar::Script script) const
631 {
632     Q_UNUSED(family);
633     Q_UNUSED(styleHint);
634 
635     QStringList preferredFallbacks;
636     QStringList otherFallbacks;
637 
638     auto writingSystem = qt_writing_system_for_script(script);
639     if (writingSystem >= QFontDatabase::WritingSystemsCount)
640         writingSystem = QFontDatabase::Any;
641 
642     auto *db = QFontDatabasePrivate::instance();
643     for (int i = 0; i < db->count; ++i) {
644         QtFontFamily *f = db->families[i];
645 
646         f->ensurePopulated();
647 
648         if (writingSystem != QFontDatabase::Any && !familySupportsWritingSystem(f, writingSystem))
649             continue;
650 
651         for (int j = 0; j < f->count; ++j) {
652             QtFontFoundry *foundry = f->foundries[j];
653 
654             for (int k = 0; k < foundry->count; ++k) {
655                 QString name = foundry->name.isEmpty()
656                         ? f->name
657                         : f->name + QLatin1String(" [") + foundry->name + QLatin1Char(']');
658                 if (style == foundry->styles[k]->key.style)
659                     preferredFallbacks.append(name);
660                 else
661                     otherFallbacks.append(name);
662             }
663         }
664     }
665 
666     return preferredFallbacks + otherFallbacks;
667 }
668 
669 static void initializeDb();
670 
671 static QStringList fallbacksForFamily(const QString &family, QFont::Style style, QFont::StyleHint styleHint, QChar::Script script)
672 {
673     auto *db = QFontDatabasePrivate::instance();
674     if (!db->count)
675         initializeDb();
676 
677     const QtFontFallbacksCacheKey cacheKey = { family, style, styleHint, script };
678 
679     if (const QStringList *fallbacks = db->fallbacksCache.object(cacheKey))
680         return *fallbacks;
681 
682     // make sure that the db has all fallback families
683     QStringList retList = QGuiApplicationPrivate::platformIntegration()->fontDatabase()->fallbacksForFamily(family,style,styleHint,script);
684 
685     QStringList::iterator i;
686     for (i = retList.begin(); i != retList.end(); ++i) {
687         bool contains = false;
688         for (int j = 0; j < db->count; j++) {
689             if (db->families[j]->matchesFamilyName(*i)) {
690                 contains = true;
691                 break;
692             }
693         }
694         if (!contains) {
695             i = retList.erase(i);
696             --i;
697         }
698     }
699 
700     db->fallbacksCache.insert(cacheKey, new QStringList(retList));
701 
702     return retList;
703 }
704 
705 QStringList qt_fallbacksForFamily(const QString &family, QFont::Style style, QFont::StyleHint styleHint, QChar::Script script)
706 {
707     QMutexLocker locker(fontDatabaseMutex());
708     return fallbacksForFamily(family, style, styleHint, script);
709 }
710 
711 static void registerFont(QFontDatabasePrivate::ApplicationFont *fnt);
712 
713 static void initializeDb()
714 {
715     auto *db = QFontDatabasePrivate::instance();
716 
717     // init by asking for the platformfontdb for the first time or after invalidation
718     if (!db->count) {
719         QGuiApplicationPrivate::platformIntegration()->fontDatabase()->populateFontDatabase();
720         for (int i = 0; i < db->applicationFonts.count(); i++) {
721             if (!db->applicationFonts.at(i).properties.isEmpty())
722                 registerFont(&db->applicationFonts[i]);
723         }
724     }
725 }
726 
727 static inline void load(const QString & = QString(), int = -1)
728 {
729     // Only initialize the database if it has been cleared or not initialized yet
730     if (!QFontDatabasePrivate::instance()->count)
731         initializeDb();
732 }
733 
734 static
735 QFontEngine *loadSingleEngine(int script,
736                               const QFontDef &request,
737                               QtFontFamily *family, QtFontFoundry *foundry,
738                               QtFontStyle *style, QtFontSize *size)
739 {
740     Q_UNUSED(foundry);
741 
742     Q_ASSERT(size);
743     QPlatformFontDatabase *pfdb = QGuiApplicationPrivate::platformIntegration()->fontDatabase();
744     int pixelSize = size->pixelSize;
745     if (!pixelSize || (style->smoothScalable && pixelSize == SMOOTH_SCALABLE)
746         || pfdb->fontsAlwaysScalable()) {
747         pixelSize = request.pixelSize;
748     }
749 
750     QFontDef def = request;
751     def.pixelSize = pixelSize;
752 
753     QFontCache *fontCache = QFontCache::instance();
754 
755     QFontCache::Key key(def,script);
756     QFontEngine *engine = fontCache->findEngine(key);
757     if (!engine) {
758         const bool cacheForCommonScript = script != QChar::Script_Common
759                 && (family->writingSystems[QFontDatabase::Latin] & QtFontFamily::Supported) != 0;
760 
761         if (Q_LIKELY(cacheForCommonScript)) {
762             // fast path: check if engine was loaded for another script
763             key.script = QChar::Script_Common;
764             engine = fontCache->findEngine(key);
765             key.script = script;
766             if (engine) {
767                 // Also check for OpenType tables when using complex scripts
768                 if (Q_UNLIKELY(!engine->supportsScript(QChar::Script(script)))) {
769                     qWarning("  OpenType support missing for \"%s\", script %d",
770                              qPrintable(def.families.first()), script);
771                     return nullptr;
772                 }
773 
774                 engine->isSmoothlyScalable = style->smoothScalable;
775                 fontCache->insertEngine(key, engine);
776                 return engine;
777             }
778         }
779 
780         // To avoid synthesized stretch we need a matching stretch to be 100 after this point.
781         // If stretch didn't match exactly we need to calculate the new stretch factor.
782         // This only done if not matched by styleName.
783         if (style->key.stretch != 0 && request.stretch != 0
784             && (request.styleName.isEmpty() || request.styleName != style->styleName)) {
785             def.stretch = (request.stretch * 100 + style->key.stretch / 2) / style->key.stretch;
786         } else if (request.stretch == QFont::AnyStretch) {
787             def.stretch = 100;
788         }
789 
790         engine = pfdb->fontEngine(def, size->handle);
791         if (engine) {
792             // Also check for OpenType tables when using complex scripts
793             if (!engine->supportsScript(QChar::Script(script))) {
794                 qWarning("  OpenType support missing for \"%s\", script %d",
795                          +qPrintable(def.families.first()), script);
796                 if (engine->ref.loadRelaxed() == 0)
797                     delete engine;
798                 return nullptr;
799             }
800 
801             engine->isSmoothlyScalable = style->smoothScalable;
802             fontCache->insertEngine(key, engine);
803 
804             if (Q_LIKELY(cacheForCommonScript && !engine->symbol)) {
805                 // cache engine for Common script as well
806                 key.script = QChar::Script_Common;
807                 if (!fontCache->findEngine(key))
808                     fontCache->insertEngine(key, engine);
809             }
810         }
811     }
812     return engine;
813 }
814 
815 static
816 QFontEngine *loadEngine(int script, const QFontDef &request,
817                         QtFontFamily *family, QtFontFoundry *foundry,
818                         QtFontStyle *style, QtFontSize *size)
819 {
820     QFontEngine *engine = loadSingleEngine(script, request, family, foundry, style, size);
821 
822     if (engine && !(request.styleStrategy & QFont::NoFontMerging) && !engine->symbol) {
823         Q_TRACE(QFontDatabase_loadEngine, request.families, request.pointSize);
824 
825         QPlatformFontDatabase *pfdb = QGuiApplicationPrivate::platformIntegration()->fontDatabase();
826         QFontEngineMulti *pfMultiEngine = pfdb->fontEngineMulti(engine, QChar::Script(script));
827         if (!request.fallBackFamilies.isEmpty()) {
828             QStringList fallbacks = request.fallBackFamilies;
829 
830             QFont::StyleHint styleHint = QFont::StyleHint(request.styleHint);
831             if (styleHint == QFont::AnyStyle && request.fixedPitch)
832                 styleHint = QFont::TypeWriter;
833 
834             fallbacks += fallbacksForFamily(family->name, QFont::Style(style->key.style), styleHint, QChar::Script(script));
835 
836             pfMultiEngine->setFallbackFamiliesList(fallbacks);
837         }
838         engine = pfMultiEngine;
839 
840         // Cache Multi font engine as well in case we got the single
841         // font engine when we are actually looking for a Multi one
842         QFontCache::Key key(request, script, 1);
843         QFontCache::instance()->insertEngine(key, engine);
844     }
845 
846     return engine;
847 }
848 
849 QtFontStyle::~QtFontStyle()
850 {
851    while (count) {
852        // bitfield count-- in while condition does not work correctly in mwccsym2
853        count--;
854        QPlatformIntegration *integration = QGuiApplicationPrivate::platformIntegration();
855        if (integration)
856            integration->fontDatabase()->releaseHandle(pixelSizes[count].handle);
857    }
858 
859    free(pixelSizes);
860 }
861 
862 static void registerFont(QFontDatabasePrivate::ApplicationFont *fnt)
863 {
864     QGuiApplicationPrivate::platformIntegration()->fontDatabase()->addApplicationFont(fnt->data, fnt->fileName, fnt);
865 }
866 
867 static QtFontStyle *bestStyle(QtFontFoundry *foundry, const QtFontStyle::Key &styleKey,
868                               const QString &styleName = QString())
869 {
870     int best = 0;
871     int dist = 0xffff;
872 
873     for ( int i = 0; i < foundry->count; i++ ) {
874         QtFontStyle *style = foundry->styles[i];
875 
876         if (!styleName.isEmpty() && styleName == style->styleName) {
877             dist = 0;
878             best = i;
879             break;
880         }
881 
882         int d = qAbs( (int(styleKey.weight) - int(style->key.weight)) / 10 );
883 
884         if ( styleKey.stretch != 0 && style->key.stretch != 0 ) {
885             d += qAbs( styleKey.stretch - style->key.stretch );
886         }
887 
888         if (styleKey.style != style->key.style) {
889             if (styleKey.style != QFont::StyleNormal && style->key.style != QFont::StyleNormal)
890                 // one is italic, the other oblique
891                 d += 0x0001;
892             else
893                 d += 0x1000;
894         }
895 
896         if ( d < dist ) {
897             best = i;
898             dist = d;
899         }
900     }
901 
902     qCDebug(lcFontMatch,  "          best style has distance 0x%x", dist );
903     return foundry->styles[best];
904 }
905 
906 enum {
907     FamilyMismatch      = 0x800000,
908     ScriptMismatch      = 0x080000,
909     PitchMismatch       = 0x004000,
910     StyleMismatch       = 0x002000,
911     BitmapScaledPenalty = 0x001000
912 };
913 
914 static
915 unsigned int bestFoundry(int script, unsigned int score, int styleStrategy,
916                          const QtFontFamily *family, const QString &foundry_name,
917                          QtFontStyle::Key styleKey, int pixelSize, char pitch,
918                          QtFontDesc *desc, const QString &styleName = QString())
919 {
920     Q_UNUSED(script);
921     Q_UNUSED(pitch);
922 
923     desc->foundry = nullptr;
924     desc->style = nullptr;
925     desc->size = nullptr;
926 
927 
928     qCDebug(lcFontMatch, "  REMARK: looking for best foundry for family '%s' [%d]", family->name.toLatin1().constData(), family->count);
929 
930     for (int x = 0; x < family->count; ++x) {
931         QtFontFoundry *foundry = family->foundries[x];
932         if (!foundry_name.isEmpty() && foundry->name.compare(foundry_name, Qt::CaseInsensitive) != 0)
933             continue;
934 
935         qCDebug(lcFontMatch, "          looking for matching style in foundry '%s' %d",
936                  foundry->name.isEmpty() ? "-- none --" : foundry->name.toLatin1().constData(), foundry->count);
937 
938         QtFontStyle *style = bestStyle(foundry, styleKey, styleName);
939 
940         if (!style->smoothScalable && (styleStrategy & QFont::ForceOutline)) {
941             qCDebug(lcFontMatch, "            ForceOutline set, but not smoothly scalable");
942             continue;
943         }
944 
945         int px = -1;
946         QtFontSize *size = nullptr;
947 
948         // 1. see if we have an exact matching size
949         if (!(styleStrategy & QFont::ForceOutline)) {
950             size = style->pixelSize(pixelSize);
951             if (size) {
952                 qCDebug(lcFontMatch, "          found exact size match (%d pixels)", size->pixelSize);
953                 px = size->pixelSize;
954             }
955         }
956 
957         // 2. see if we have a smoothly scalable font
958         if (!size && style->smoothScalable && ! (styleStrategy & QFont::PreferBitmap)) {
959             size = style->pixelSize(SMOOTH_SCALABLE);
960             if (size) {
961                 qCDebug(lcFontMatch, "          found smoothly scalable font (%d pixels)", pixelSize);
962                 px = pixelSize;
963             }
964         }
965 
966         // 3. see if we have a bitmap scalable font
967         if (!size && style->bitmapScalable && (styleStrategy & QFont::PreferMatch)) {
968             size = style->pixelSize(0);
969             if (size) {
970                 qCDebug(lcFontMatch, "          found bitmap scalable font (%d pixels)", pixelSize);
971                 px = pixelSize;
972             }
973         }
974 
975 
976         // 4. find closest size match
977         if (! size) {
978             unsigned int distance = ~0u;
979             for (int x = 0; x < style->count; ++x) {
980 
981                 unsigned int d;
982                 if (style->pixelSizes[x].pixelSize < pixelSize) {
983                     // penalize sizes that are smaller than the
984                     // requested size, due to truncation from floating
985                     // point to integer conversions
986                     d = pixelSize - style->pixelSizes[x].pixelSize + 1;
987                 } else {
988                     d = style->pixelSizes[x].pixelSize - pixelSize;
989                 }
990 
991                 if (d < distance) {
992                     distance = d;
993                     size = style->pixelSizes + x;
994                     qCDebug(lcFontMatch, "          best size so far: %3d (%d)", size->pixelSize, pixelSize);
995                 }
996             }
997 
998             if (!size) {
999                 qCDebug(lcFontMatch, "          no size supports the script we want");
1000                 continue;
1001             }
1002 
1003             if (style->bitmapScalable && ! (styleStrategy & QFont::PreferQuality) &&
1004                 (distance * 10 / pixelSize) >= 2) {
1005                 // the closest size is not close enough, go ahead and
1006                 // use a bitmap scaled font
1007                 size = style->pixelSize(0);
1008                 px = pixelSize;
1009             } else {
1010                 px = size->pixelSize;
1011             }
1012         }
1013 
1014 
1015         unsigned int this_score = 0x0000;
1016 
1017         if (pitch != '*') {
1018             if ((pitch == 'm' && !family->fixedPitch)
1019                 || (pitch == 'p' && family->fixedPitch))
1020                 this_score |= PitchMismatch;
1021         }
1022         if (styleKey != style->key)
1023             this_score |= StyleMismatch;
1024         if (!style->smoothScalable && px != size->pixelSize) // bitmap scaled
1025             this_score |= BitmapScaledPenalty;
1026         if (px != pixelSize) // close, but not exact, size match
1027             this_score += qAbs(px - pixelSize);
1028 
1029         if (this_score < score) {
1030             qCDebug(lcFontMatch, "          found a match: score %x best score so far %x",
1031                      this_score, score);
1032 
1033             score = this_score;
1034             desc->foundry = foundry;
1035             desc->style = style;
1036             desc->size = size;
1037         } else {
1038             qCDebug(lcFontMatch, "          score %x no better than best %x", this_score, score);
1039         }
1040     }
1041 
1042     return score;
1043 }
1044 
1045 static bool matchFamilyName(const QString &familyName, QtFontFamily *f)
1046 {
1047     if (familyName.isEmpty())
1048         return true;
1049     return f->matchesFamilyName(familyName);
1050 }
1051 
1052 /*!
1053     \internal
1054 
1055     Tries to find the best match for a given request and family/foundry
1056 */
1057 static int match(int script,
1058                  const QFontDef &request,
1059                  const QString &family_name,
1060                  const QString &foundry_name,
1061                  QtFontDesc *desc,
1062                  const QList<int> &blacklistedFamilies,
1063                  unsigned int *resultingScore = nullptr)
1064 {
1065     int result = -1;
1066 
1067     QtFontStyle::Key styleKey;
1068     styleKey.style = request.style;
1069     styleKey.weight = request.weight;
1070     // Prefer a stretch closest to 100.
1071     styleKey.stretch = request.stretch ? request.stretch : 100;
1072     char pitch = request.ignorePitch ? '*' : request.fixedPitch ? 'm' : 'p';
1073 
1074 
1075     qCDebug(lcFontMatch, "QFontDatabase::match\n"
1076              "  request:\n"
1077              "    family: %s [%s], script: %d\n"
1078              "    styleName: %s\n"
1079              "    weight: %d, style: %d\n"
1080              "    stretch: %d\n"
1081              "    pixelSize: %g\n"
1082              "    pitch: %c",
1083              family_name.isEmpty() ? "-- first in script --" : family_name.toLatin1().constData(),
1084              foundry_name.isEmpty() ? "-- any --" : foundry_name.toLatin1().constData(), script,
1085              request.styleName.isEmpty() ? "-- any --" : request.styleName.toLatin1().constData(),
1086              request.weight, request.style, request.stretch, request.pixelSize, pitch);
1087 
1088     desc->family = nullptr;
1089     desc->foundry = nullptr;
1090     desc->style = nullptr;
1091     desc->size = nullptr;
1092 
1093     unsigned int score = ~0u;
1094 
1095     load(family_name, script);
1096 
1097     auto writingSystem = qt_writing_system_for_script(script);
1098     if (writingSystem >= QFontDatabase::WritingSystemsCount)
1099         writingSystem = QFontDatabase::Any;
1100 
1101     auto *db = QFontDatabasePrivate::instance();
1102     for (int x = 0; x < db->count; ++x) {
1103         if (blacklistedFamilies.contains(x))
1104             continue;
1105         QtFontDesc test;
1106         test.family = db->families[x];
1107 
1108         if (!matchFamilyName(family_name, test.family))
1109             continue;
1110         score &= ~FamilyMismatch;
1111 
1112         test.family->ensurePopulated();
1113 
1114         // Check if family is supported in the script we want
1115         if (writingSystem != QFontDatabase::Any && !familySupportsWritingSystem(test.family, writingSystem))
1116             continue;
1117         score &= ~ScriptMismatch;
1118 
1119         // as we know the script is supported, we can be sure
1120         // to find a matching font here.
1121         unsigned int newscore =
1122             bestFoundry(script, score, request.styleStrategy,
1123                         test.family, foundry_name, styleKey, request.pixelSize, pitch,
1124                         &test, request.styleName);
1125         if (test.foundry == nullptr && !foundry_name.isEmpty()) {
1126             // the specific foundry was not found, so look for
1127             // any foundry matching our requirements
1128             newscore = bestFoundry(script, score, request.styleStrategy, test.family,
1129                                    QString(), styleKey, request.pixelSize,
1130                                    pitch, &test, request.styleName);
1131         }
1132 
1133         if (newscore < score) {
1134             result = x;
1135             score = newscore;
1136             *desc = test;
1137         }
1138         if (newscore < 10) // xlfd instead of FT... just accept it
1139             break;
1140     }
1141 
1142     if (resultingScore != nullptr)
1143         *resultingScore = score;
1144 
1145     return result;
1146 }
1147 
1148 static QString styleStringHelper(int weight, QFont::Style style)
1149 {
1150     QString result;
1151     if (weight > QFont::Normal) {
1152         if (weight >= QFont::Black)
1153             result = QCoreApplication::translate("QFontDatabase", "Black");
1154         else if (weight >= QFont::ExtraBold)
1155             result = QCoreApplication::translate("QFontDatabase", "Extra Bold");
1156         else if (weight >= QFont::Bold)
1157             result = QCoreApplication::translate("QFontDatabase", "Bold");
1158         else if (weight >= QFont::DemiBold)
1159             result = QCoreApplication::translate("QFontDatabase", "Demi Bold");
1160         else if (weight >= QFont::Medium)
1161             result = QCoreApplication::translate("QFontDatabase", "Medium", "The Medium font weight");
1162     } else {
1163         if (weight <= QFont::Thin)
1164             result = QCoreApplication::translate("QFontDatabase", "Thin");
1165         else if (weight <= QFont::ExtraLight)
1166             result = QCoreApplication::translate("QFontDatabase", "Extra Light");
1167         else if (weight <= QFont::Light)
1168             result = QCoreApplication::translate("QFontDatabase", "Light");
1169     }
1170 
1171     if (style == QFont::StyleItalic)
1172         result += QLatin1Char(' ') + QCoreApplication::translate("QFontDatabase", "Italic");
1173     else if (style == QFont::StyleOblique)
1174         result += QLatin1Char(' ') + QCoreApplication::translate("QFontDatabase", "Oblique");
1175 
1176     if (result.isEmpty())
1177         result = QCoreApplication::translate("QFontDatabase", "Normal", "The Normal or Regular font weight");
1178 
1179     return result.simplified();
1180 }
1181 
1182 /*!
1183     Returns a string that describes the style of the \a font. For
1184     example, "Bold Italic", "Bold", "Italic" or "Normal". An empty
1185     string may be returned.
1186 */
1187 QString QFontDatabase::styleString(const QFont &font)
1188 {
1189     return font.styleName().isEmpty() ? styleStringHelper(font.weight(), font.style())
1190                                       : font.styleName();
1191 }
1192 
1193 /*!
1194     Returns a string that describes the style of the \a fontInfo. For
1195     example, "Bold Italic", "Bold", "Italic" or "Normal". An empty
1196     string may be returned.
1197 */
1198 QString QFontDatabase::styleString(const QFontInfo &fontInfo)
1199 {
1200     return fontInfo.styleName().isEmpty() ? styleStringHelper(fontInfo.weight(), fontInfo.style())
1201                                           : fontInfo.styleName();
1202 }
1203 
1204 
1205 /*!
1206     \class QFontDatabase
1207     \threadsafe
1208     \inmodule QtGui
1209 
1210     \brief The QFontDatabase class provides information about the fonts available in the underlying window system.
1211 
1212     \ingroup appearance
1213 
1214     The most common uses of this class are to query the database for
1215     the list of font families() and for the pointSizes() and styles()
1216     that are available for each family. An alternative to pointSizes()
1217     is smoothSizes() which returns the sizes at which a given family
1218     and style will look attractive.
1219 
1220     If the font family is available from two or more foundries the
1221     foundry name is included in the family name; for example:
1222     "Helvetica [Adobe]" and "Helvetica [Cronyx]". When you specify a
1223     family, you can either use the old hyphenated "foundry-family"
1224     format or the bracketed "family [foundry]" format; for example:
1225     "Cronyx-Helvetica" or "Helvetica [Cronyx]". If the family has a
1226     foundry it is always returned using the bracketed format, as is
1227     the case with the value returned by families().
1228 
1229     The font() function returns a QFont given a family, style and
1230     point size.
1231 
1232     A family and style combination can be checked to see if it is
1233     italic() or bold(), and to retrieve its weight(). Similarly we can
1234     call isBitmapScalable(), isSmoothlyScalable(), isScalable() and
1235     isFixedPitch().
1236 
1237     Use the styleString() to obtain a text version of a style.
1238 
1239     The QFontDatabase class provides some helper functions, for
1240     example, standardSizes(). You can retrieve the description of a
1241     writing system using writingSystemName(), and a sample of
1242     characters in a writing system with writingSystemSample().
1243 
1244     Example:
1245 
1246     \snippet qfontdatabase/qfontdatabase_snippets.cpp 0
1247 
1248     This example gets the list of font families, the list of
1249     styles for each family, and the point sizes that are available for
1250     each combination of family and style, displaying this information
1251     in a tree view.
1252 
1253     \sa QFont, QFontInfo, QFontMetrics, {Character Map Example}
1254 */
1255 
1256 /*!
1257     \fn QFontDatabase::QFontDatabase()
1258     \deprecated [6.0] Call the class methods as static functions instead.
1259 
1260     Creates a font database object.
1261 */
1262 
1263 /*!
1264     \enum QFontDatabase::WritingSystem
1265 
1266     \value Any
1267     \value Latin
1268     \value Greek
1269     \value Cyrillic
1270     \value Armenian
1271     \value Hebrew
1272     \value Arabic
1273     \value Syriac
1274     \value Thaana
1275     \value Devanagari
1276     \value Bengali
1277     \value Gurmukhi
1278     \value Gujarati
1279     \value Oriya
1280     \value Tamil
1281     \value Telugu
1282     \value Kannada
1283     \value Malayalam
1284     \value Sinhala
1285     \value Thai
1286     \value Lao
1287     \value Tibetan
1288     \value Myanmar
1289     \value Georgian
1290     \value Khmer
1291     \value SimplifiedChinese
1292     \value TraditionalChinese
1293     \value Japanese
1294     \value Korean
1295     \value Vietnamese
1296     \value Symbol
1297     \value Other (the same as Symbol)
1298     \value Ogham
1299     \value Runic
1300     \value Nko
1301 
1302     \omitvalue WritingSystemsCount
1303 */
1304 
1305 /*!
1306     \enum QFontDatabase::SystemFont
1307 
1308     \value GeneralFont              The default system font.
1309     \value FixedFont                The fixed font that the system recommends.
1310     \value TitleFont                The system standard font for titles.
1311     \value SmallestReadableFont     The smallest readable system font.
1312 
1313     \since 5.2
1314 */
1315 
1316 /*!
1317     \internal
1318 
1319     Initializes the font database if necessary and returns its
1320     pointer. Mutex lock must be held when calling this function.
1321 */
1322 QFontDatabasePrivate *QFontDatabasePrivate::ensureFontDatabase()
1323 {
1324     auto *d = QFontDatabasePrivate::instance();
1325     if (d->count == 0) {
1326         if (Q_UNLIKELY(qGuiApp == nullptr || QGuiApplicationPrivate::platformIntegration() == nullptr))
1327             qFatal("QFontDatabase: Must construct a QGuiApplication before accessing QFontDatabase");
1328 
1329         initializeDb();
1330     }
1331     return d;
1332 }
1333 
1334 /*!
1335     Returns a sorted list of the available writing systems. This is
1336     list generated from information about all installed fonts on the
1337     system.
1338 
1339     \sa families()
1340 */
1341 QList<QFontDatabase::WritingSystem> QFontDatabase::writingSystems()
1342 {
1343     QMutexLocker locker(fontDatabaseMutex());
1344     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1345 
1346     QT_PREPEND_NAMESPACE(load)();
1347 
1348     quint64 writingSystemsFound = 0;
1349     static_assert(WritingSystemsCount < 64);
1350 
1351     for (int i = 0; i < d->count; ++i) {
1352         QtFontFamily *family = d->families[i];
1353         family->ensurePopulated();
1354 
1355         if (family->count == 0)
1356             continue;
1357         for (uint x = Latin; x < uint(WritingSystemsCount); ++x) {
1358             if (family->writingSystems[x] & QtFontFamily::Supported)
1359                 writingSystemsFound |= quint64(1) << x;
1360         }
1361     }
1362 
1363     // mutex protection no longer needed - just working on local data now:
1364     locker.unlock();
1365 
1366     QList<WritingSystem> list;
1367     list.reserve(qPopulationCount(writingSystemsFound));
1368     for (uint x = Latin ; x < uint(WritingSystemsCount); ++x) {
1369         if (writingSystemsFound & (quint64(1) << x))
1370             list.push_back(WritingSystem(x));
1371     }
1372     return list;
1373 }
1374 
1375 
1376 /*!
1377     Returns a sorted list of the writing systems supported by a given
1378     font \a family.
1379 
1380     \sa families()
1381 */
1382 QList<QFontDatabase::WritingSystem> QFontDatabase::writingSystems(const QString &family)
1383 {
1384     QString familyName, foundryName;
1385     parseFontName(family, foundryName, familyName);
1386 
1387     QMutexLocker locker(fontDatabaseMutex());
1388     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1389 
1390     QT_PREPEND_NAMESPACE(load)();
1391 
1392     QList<WritingSystem> list;
1393     QtFontFamily *f = d->family(familyName);
1394     if (!f || f->count == 0)
1395         return list;
1396 
1397     for (int x = Latin; x < WritingSystemsCount; ++x) {
1398         const WritingSystem writingSystem = WritingSystem(x);
1399         if (f->writingSystems[writingSystem] & QtFontFamily::Supported)
1400             list.append(writingSystem);
1401     }
1402     return list;
1403 }
1404 
1405 
1406 /*!
1407     Returns a sorted list of the available font families which support
1408     the \a writingSystem.
1409 
1410     If a family exists in several foundries, the returned name for
1411     that font is in the form "family [foundry]". Examples: "Times
1412     [Adobe]", "Times [Cronyx]", "Palatino".
1413 
1414     \sa writingSystems()
1415 */
1416 QStringList QFontDatabase::families(WritingSystem writingSystem)
1417 {
1418     QMutexLocker locker(fontDatabaseMutex());
1419     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1420 
1421     QT_PREPEND_NAMESPACE(load)();
1422 
1423     QStringList flist;
1424     for (int i = 0; i < d->count; i++) {
1425         QtFontFamily *f = d->families[i];
1426         if (f->populated && f->count == 0)
1427             continue;
1428         if (writingSystem != Any) {
1429             f->ensurePopulated();
1430             if (f->writingSystems[writingSystem] != QtFontFamily::Supported)
1431                 continue;
1432         }
1433         if (!f->populated || f->count == 1) {
1434             flist.append(f->name);
1435         } else {
1436             for (int j = 0; j < f->count; j++) {
1437                 QString str = f->name;
1438                 QString foundry = f->foundries[j]->name;
1439                 if (!foundry.isEmpty()) {
1440                     str += QLatin1String(" [");
1441                     str += foundry;
1442                     str += QLatin1Char(']');
1443                 }
1444                 flist.append(str);
1445             }
1446         }
1447     }
1448     return flist;
1449 }
1450 
1451 /*!
1452     Returns a list of the styles available for the font family \a
1453     family. Some example styles: "Light", "Light Italic", "Bold",
1454     "Oblique", "Demi". The list may be empty.
1455 
1456     \sa families()
1457 */
1458 QStringList QFontDatabase::styles(const QString &family)
1459 {
1460     QString familyName, foundryName;
1461     parseFontName(family, foundryName, familyName);
1462 
1463     QMutexLocker locker(fontDatabaseMutex());
1464     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1465 
1466     QT_PREPEND_NAMESPACE(load)(familyName);
1467 
1468     QStringList l;
1469     QtFontFamily *f = d->family(familyName);
1470     if (!f)
1471         return l;
1472 
1473     QtFontFoundry allStyles(foundryName);
1474     for (int j = 0; j < f->count; j++) {
1475         QtFontFoundry *foundry = f->foundries[j];
1476         if (foundryName.isEmpty() || foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1477             for (int k = 0; k < foundry->count; k++) {
1478                 QtFontStyle::Key ke(foundry->styles[k]->key);
1479                 ke.stretch = 0;
1480                 allStyles.style(ke, foundry->styles[k]->styleName, true);
1481             }
1482         }
1483     }
1484 
1485     l.reserve(allStyles.count);
1486     for (int i = 0; i < allStyles.count; i++) {
1487         l.append(allStyles.styles[i]->styleName.isEmpty() ?
1488                  styleStringHelper(allStyles.styles[i]->key.weight,
1489                                    (QFont::Style)allStyles.styles[i]->key.style) :
1490                  allStyles.styles[i]->styleName);
1491     }
1492     return l;
1493 }
1494 
1495 /*!
1496     Returns \c true if the font that has family \a family and style \a
1497     style is fixed pitch; otherwise returns \c false.
1498 */
1499 
1500 bool QFontDatabase::isFixedPitch(const QString &family,
1501                                  const QString &style)
1502 {
1503     Q_UNUSED(style);
1504 
1505     QString familyName, foundryName;
1506     parseFontName(family, foundryName, familyName);
1507 
1508     QMutexLocker locker(fontDatabaseMutex());
1509     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1510 
1511     QT_PREPEND_NAMESPACE(load)(familyName);
1512 
1513     QtFontFamily *f = d->family(familyName);
1514     return (f && f->fixedPitch);
1515 }
1516 
1517 /*!
1518     Returns \c true if the font that has family \a family and style \a
1519     style is a scalable bitmap font; otherwise returns \c false. Scaling
1520     a bitmap font usually produces an unattractive hardly readable
1521     result, because the pixels of the font are scaled. If you need to
1522     scale a bitmap font it is better to scale it to one of the fixed
1523     sizes returned by smoothSizes().
1524 
1525     \sa isScalable(), isSmoothlyScalable()
1526 */
1527 bool QFontDatabase::isBitmapScalable(const QString &family,
1528                                       const QString &style)
1529 {
1530     bool bitmapScalable = false;
1531     QString familyName, foundryName;
1532     parseFontName(family, foundryName, familyName);
1533 
1534     QMutexLocker locker(fontDatabaseMutex());
1535     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1536 
1537     QT_PREPEND_NAMESPACE(load)(familyName);
1538 
1539     QtFontFamily *f = d->family(familyName);
1540     if (!f) return bitmapScalable;
1541 
1542     QtFontStyle::Key styleKey(style);
1543     for (int j = 0; j < f->count; j++) {
1544         QtFontFoundry *foundry = f->foundries[j];
1545         if (foundryName.isEmpty() || foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1546             for (int k = 0; k < foundry->count; k++)
1547                 if ((style.isEmpty() ||
1548                      foundry->styles[k]->styleName == style ||
1549                      foundry->styles[k]->key == styleKey)
1550                     && foundry->styles[k]->bitmapScalable && !foundry->styles[k]->smoothScalable) {
1551                     bitmapScalable = true;
1552                     goto end;
1553                 }
1554         }
1555     }
1556  end:
1557     return bitmapScalable;
1558 }
1559 
1560 
1561 /*!
1562     Returns \c true if the font that has family \a family and style \a
1563     style is smoothly scalable; otherwise returns \c false. If this
1564     function returns \c true, it's safe to scale this font to any size,
1565     and the result will always look attractive.
1566 
1567     \sa isScalable(), isBitmapScalable()
1568 */
1569 bool QFontDatabase::isSmoothlyScalable(const QString &family, const QString &style)
1570 {
1571     bool smoothScalable = false;
1572     QString familyName, foundryName;
1573     parseFontName(family, foundryName, familyName);
1574 
1575     QMutexLocker locker(fontDatabaseMutex());
1576     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1577 
1578     QT_PREPEND_NAMESPACE(load)(familyName);
1579 
1580     QtFontFamily *f = d->family(familyName);
1581     if (!f) {
1582         for (int i = 0; i < d->count; i++) {
1583             if (d->families[i]->matchesFamilyName(familyName)) {
1584                 f = d->families[i];
1585                 f->ensurePopulated();
1586                 break;
1587             }
1588         }
1589     }
1590     if (!f) return smoothScalable;
1591 
1592     const QtFontStyle::Key styleKey(style);
1593     for (int j = 0; j < f->count; j++) {
1594         QtFontFoundry *foundry = f->foundries[j];
1595         if (foundryName.isEmpty() || foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1596             for (int k = 0; k < foundry->count; k++) {
1597                 const QtFontStyle *fontStyle = foundry->styles[k];
1598                 smoothScalable =
1599                         fontStyle->smoothScalable
1600                         && ((style.isEmpty()
1601                              || fontStyle->styleName == style
1602                              || fontStyle->key == styleKey)
1603                             || (fontStyle->styleName.isEmpty()
1604                                 && style == styleStringHelper(fontStyle->key.weight,
1605                                                               QFont::Style(fontStyle->key.style))));
1606                 if (smoothScalable)
1607                     goto end;
1608             }
1609         }
1610     }
1611  end:
1612     return smoothScalable;
1613 }
1614 
1615 /*!
1616     Returns \c true if the font that has family \a family and style \a
1617     style is scalable; otherwise returns \c false.
1618 
1619     \sa isBitmapScalable(), isSmoothlyScalable()
1620 */
1621 bool  QFontDatabase::isScalable(const QString &family,
1622                                  const QString &style)
1623 {
1624     QMutexLocker locker(fontDatabaseMutex());
1625     if (isSmoothlyScalable(family, style))
1626         return true;
1627     return isBitmapScalable(family, style);
1628 }
1629 
1630 
1631 /*!
1632     Returns a list of the point sizes available for the font that has
1633     family \a family and style \a styleName. The list may be empty.
1634 
1635     \sa smoothSizes(), standardSizes()
1636 */
1637 QList<int> QFontDatabase::pointSizes(const QString &family,
1638                                      const QString &styleName)
1639 {
1640     if (QGuiApplicationPrivate::platformIntegration()->fontDatabase()->fontsAlwaysScalable())
1641         return standardSizes();
1642 
1643     bool smoothScalable = false;
1644     QString familyName, foundryName;
1645     parseFontName(family, foundryName, familyName);
1646 
1647     QMutexLocker locker(fontDatabaseMutex());
1648     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1649 
1650     QT_PREPEND_NAMESPACE(load)(familyName);
1651 
1652     QList<int> sizes;
1653 
1654     QtFontFamily *fam = d->family(familyName);
1655     if (!fam) return sizes;
1656 
1657 
1658     const int dpi = qt_defaultDpiY(); // embedded
1659 
1660     QtFontStyle::Key styleKey(styleName);
1661     for (int j = 0; j < fam->count; j++) {
1662         QtFontFoundry *foundry = fam->foundries[j];
1663         if (foundryName.isEmpty() || foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1664             QtFontStyle *style = foundry->style(styleKey, styleName);
1665             if (!style) continue;
1666 
1667             if (style->smoothScalable) {
1668                 smoothScalable = true;
1669                 goto end;
1670             }
1671             for (int l = 0; l < style->count; l++) {
1672                 const QtFontSize *size = style->pixelSizes + l;
1673 
1674                 if (size->pixelSize != 0 && size->pixelSize != SMOOTH_SCALABLE) {
1675                     const int pointSize = qRound(size->pixelSize * 72.0 / dpi);
1676                     if (! sizes.contains(pointSize))
1677                         sizes.append(pointSize);
1678                 }
1679             }
1680         }
1681     }
1682  end:
1683     if (smoothScalable)
1684         return standardSizes();
1685 
1686     std::sort(sizes.begin(), sizes.end());
1687     return sizes;
1688 }
1689 
1690 /*!
1691     Returns a QFont object that has family \a family, style \a style
1692     and point size \a pointSize. If no matching font could be created,
1693     a QFont object that uses the application's default font is
1694     returned.
1695 */
1696 QFont QFontDatabase::font(const QString &family, const QString &style,
1697                           int pointSize)
1698 {
1699     QString familyName, foundryName;
1700     parseFontName(family, foundryName, familyName);
1701     QMutexLocker locker(fontDatabaseMutex());
1702     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1703 
1704     QT_PREPEND_NAMESPACE(load)(familyName);
1705 
1706     QtFontFoundry allStyles(foundryName);
1707     QtFontFamily *f = d->family(familyName);
1708     if (!f) return QGuiApplication::font();
1709 
1710     for (int j = 0; j < f->count; j++) {
1711         QtFontFoundry *foundry = f->foundries[j];
1712         if (foundryName.isEmpty() || foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1713             for (int k = 0; k < foundry->count; k++)
1714                 allStyles.style(foundry->styles[k]->key, foundry->styles[k]->styleName, true);
1715         }
1716     }
1717 
1718     QtFontStyle::Key styleKey(style);
1719     QtFontStyle *s = bestStyle(&allStyles, styleKey, style);
1720 
1721     if (!s) // no styles found?
1722         return QGuiApplication::font();
1723 
1724     QFont fnt(QStringList{family}, pointSize, s->key.weight);
1725     fnt.setStyle((QFont::Style)s->key.style);
1726     if (!s->styleName.isEmpty())
1727         fnt.setStyleName(s->styleName);
1728     return fnt;
1729 }
1730 
1731 
1732 /*!
1733     Returns the point sizes of a font that has family \a family and
1734     style \a styleName that will look attractive. The list may be empty.
1735     For non-scalable fonts and bitmap scalable fonts, this function
1736     is equivalent to pointSizes().
1737 
1738   \sa pointSizes(), standardSizes()
1739 */
1740 QList<int> QFontDatabase::smoothSizes(const QString &family,
1741                                             const QString &styleName)
1742 {
1743     if (QGuiApplicationPrivate::platformIntegration()->fontDatabase()->fontsAlwaysScalable())
1744         return standardSizes();
1745 
1746     bool smoothScalable = false;
1747     QString familyName, foundryName;
1748     parseFontName(family, foundryName, familyName);
1749 
1750     QMutexLocker locker(fontDatabaseMutex());
1751     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1752 
1753     QT_PREPEND_NAMESPACE(load)(familyName);
1754 
1755     QList<int> sizes;
1756 
1757     QtFontFamily *fam = d->family(familyName);
1758     if (!fam)
1759         return sizes;
1760 
1761     const int dpi = qt_defaultDpiY(); // embedded
1762 
1763     QtFontStyle::Key styleKey(styleName);
1764     for (int j = 0; j < fam->count; j++) {
1765         QtFontFoundry *foundry = fam->foundries[j];
1766         if (foundryName.isEmpty() || foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1767             QtFontStyle *style = foundry->style(styleKey, styleName);
1768             if (!style) continue;
1769 
1770             if (style->smoothScalable) {
1771                 smoothScalable = true;
1772                 goto end;
1773             }
1774             for (int l = 0; l < style->count; l++) {
1775                 const QtFontSize *size = style->pixelSizes + l;
1776 
1777                 if (size->pixelSize != 0 && size->pixelSize != SMOOTH_SCALABLE) {
1778                     const int pointSize = qRound(size->pixelSize * 72.0 / dpi);
1779                     if (! sizes.contains(pointSize))
1780                         sizes.append(pointSize);
1781                 }
1782             }
1783         }
1784     }
1785  end:
1786     if (smoothScalable)
1787         return QFontDatabase::standardSizes();
1788 
1789     std::sort(sizes.begin(), sizes.end());
1790     return sizes;
1791 }
1792 
1793 
1794 /*!
1795     Returns a list of standard font sizes.
1796 
1797     \sa smoothSizes(), pointSizes()
1798 */
1799 QList<int> QFontDatabase::standardSizes()
1800 {
1801     return QGuiApplicationPrivate::platformIntegration()->fontDatabase()->standardSizes();
1802 }
1803 
1804 
1805 /*!
1806     Returns \c true if the font that has family \a family and style \a
1807     style is italic; otherwise returns \c false.
1808 
1809     \sa weight(), bold()
1810 */
1811 bool QFontDatabase::italic(const QString &family, const QString &style)
1812 {
1813     QString familyName, foundryName;
1814     parseFontName(family, foundryName, familyName);
1815 
1816     QMutexLocker locker(fontDatabaseMutex());
1817     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1818 
1819     QT_PREPEND_NAMESPACE(load)(familyName);
1820 
1821     QtFontFoundry allStyles(foundryName);
1822     QtFontFamily *f = d->family(familyName);
1823     if (!f) return false;
1824 
1825     for (int j = 0; j < f->count; j++) {
1826         QtFontFoundry *foundry = f->foundries[j];
1827         if (foundryName.isEmpty() || foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1828             for (int k = 0; k < foundry->count; k++)
1829                 allStyles.style(foundry->styles[k]->key, foundry->styles[k]->styleName, true);
1830         }
1831     }
1832 
1833     QtFontStyle::Key styleKey(style);
1834     QtFontStyle *s = allStyles.style(styleKey, style);
1835     return s && s->key.style == QFont::StyleItalic;
1836 }
1837 
1838 
1839 /*!
1840     Returns \c true if the font that has family \a family and style \a
1841     style is bold; otherwise returns \c false.
1842 
1843     \sa italic(), weight()
1844 */
1845 bool QFontDatabase::bold(const QString &family,
1846                           const QString &style)
1847 {
1848     QString familyName, foundryName;
1849     parseFontName(family, foundryName, familyName);
1850 
1851     QMutexLocker locker(fontDatabaseMutex());
1852     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1853 
1854     QT_PREPEND_NAMESPACE(load)(familyName);
1855 
1856     QtFontFoundry allStyles(foundryName);
1857     QtFontFamily *f = d->family(familyName);
1858     if (!f) return false;
1859 
1860     for (int j = 0; j < f->count; j++) {
1861         QtFontFoundry *foundry = f->foundries[j];
1862         if (foundryName.isEmpty() ||
1863             foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1864             for (int k = 0; k < foundry->count; k++)
1865                 allStyles.style(foundry->styles[k]->key, foundry->styles[k]->styleName, true);
1866         }
1867     }
1868 
1869     QtFontStyle::Key styleKey(style);
1870     QtFontStyle *s = allStyles.style(styleKey, style);
1871     return s && s->key.weight >= QFont::Bold;
1872 }
1873 
1874 
1875 /*!
1876     Returns the weight of the font that has family \a family and style
1877     \a style. If there is no such family and style combination,
1878     returns -1.
1879 
1880     \sa italic(), bold()
1881 */
1882 int QFontDatabase::weight(const QString &family,
1883                            const QString &style)
1884 {
1885     QString familyName, foundryName;
1886     parseFontName(family, foundryName, familyName);
1887 
1888     QMutexLocker locker(fontDatabaseMutex());
1889     QFontDatabasePrivate *d = QFontDatabasePrivate::ensureFontDatabase();
1890 
1891     QT_PREPEND_NAMESPACE(load)(familyName);
1892 
1893     QtFontFoundry allStyles(foundryName);
1894     QtFontFamily *f = d->family(familyName);
1895     if (!f) return -1;
1896 
1897     for (int j = 0; j < f->count; j++) {
1898         QtFontFoundry *foundry = f->foundries[j];
1899         if (foundryName.isEmpty() ||
1900             foundry->name.compare(foundryName, Qt::CaseInsensitive) == 0) {
1901             for (int k = 0; k < foundry->count; k++)
1902                 allStyles.style(foundry->styles[k]->key, foundry->styles[k]->styleName, true);
1903         }
1904     }
1905 
1906     QtFontStyle::Key styleKey(style);
1907     QtFontStyle *s = allStyles.style(styleKey, style);
1908     return s ? s->key.weight : -1;
1909 }
1910 
1911 
1912 /*! \internal */
1913 bool QFontDatabase::hasFamily(const QString &family)
1914 {
1915     QString parsedFamily, foundry;
1916     parseFontName(family, foundry, parsedFamily);
1917     const QString familyAlias = QFontDatabasePrivate::resolveFontFamilyAlias(parsedFamily);
1918     return families().contains(familyAlias, Qt::CaseInsensitive);
1919 }
1920 
1921 
1922 /*!
1923     \since 5.5
1924 
1925     Returns \c true if and only if the \a family font family is private.
1926 
1927     This happens, for instance, on \macos and iOS, where the system UI fonts are not
1928     accessible to the user. For completeness, QFontDatabase::families() returns all
1929     font families, including the private ones. You should use this function if you
1930     are developing a font selection control in order to keep private fonts hidden.
1931 
1932     \sa families()
1933 */
1934 bool QFontDatabase::isPrivateFamily(const QString &family)
1935 {
1936     return QGuiApplicationPrivate::platformIntegration()->fontDatabase()->isPrivateFontFamily(family);
1937 }
1938 
1939 
1940 /*!
1941     Returns the names the \a writingSystem (e.g. for displaying to the
1942     user in a dialog).
1943 */
1944 QString QFontDatabase::writingSystemName(WritingSystem writingSystem)
1945 {
1946     const char *name = nullptr;
1947     switch (writingSystem) {
1948     case Any:
1949         name = QT_TRANSLATE_NOOP("QFontDatabase", "Any");
1950         break;
1951     case Latin:
1952         name = QT_TRANSLATE_NOOP("QFontDatabase", "Latin");
1953         break;
1954     case Greek:
1955         name = QT_TRANSLATE_NOOP("QFontDatabase", "Greek");
1956         break;
1957     case Cyrillic:
1958         name = QT_TRANSLATE_NOOP("QFontDatabase", "Cyrillic");
1959         break;
1960     case Armenian:
1961         name = QT_TRANSLATE_NOOP("QFontDatabase", "Armenian");
1962         break;
1963     case Hebrew:
1964         name = QT_TRANSLATE_NOOP("QFontDatabase", "Hebrew");
1965         break;
1966     case Arabic:
1967         name = QT_TRANSLATE_NOOP("QFontDatabase", "Arabic");
1968         break;
1969     case Syriac:
1970         name = QT_TRANSLATE_NOOP("QFontDatabase", "Syriac");
1971         break;
1972     case Thaana:
1973         name = QT_TRANSLATE_NOOP("QFontDatabase", "Thaana");
1974         break;
1975     case Devanagari:
1976         name = QT_TRANSLATE_NOOP("QFontDatabase", "Devanagari");
1977         break;
1978     case Bengali:
1979         name = QT_TRANSLATE_NOOP("QFontDatabase", "Bengali");
1980         break;
1981     case Gurmukhi:
1982         name = QT_TRANSLATE_NOOP("QFontDatabase", "Gurmukhi");
1983         break;
1984     case Gujarati:
1985         name = QT_TRANSLATE_NOOP("QFontDatabase", "Gujarati");
1986         break;
1987     case Oriya:
1988         name = QT_TRANSLATE_NOOP("QFontDatabase", "Oriya");
1989         break;
1990     case Tamil:
1991         name = QT_TRANSLATE_NOOP("QFontDatabase", "Tamil");
1992         break;
1993     case Telugu:
1994         name = QT_TRANSLATE_NOOP("QFontDatabase", "Telugu");
1995         break;
1996     case Kannada:
1997         name = QT_TRANSLATE_NOOP("QFontDatabase", "Kannada");
1998         break;
1999     case Malayalam:
2000         name = QT_TRANSLATE_NOOP("QFontDatabase", "Malayalam");
2001         break;
2002     case Sinhala:
2003         name = QT_TRANSLATE_NOOP("QFontDatabase", "Sinhala");
2004         break;
2005     case Thai:
2006         name = QT_TRANSLATE_NOOP("QFontDatabase", "Thai");
2007         break;
2008     case Lao:
2009         name = QT_TRANSLATE_NOOP("QFontDatabase", "Lao");
2010         break;
2011     case Tibetan:
2012         name = QT_TRANSLATE_NOOP("QFontDatabase", "Tibetan");
2013         break;
2014     case Myanmar:
2015         name = QT_TRANSLATE_NOOP("QFontDatabase", "Myanmar");
2016         break;
2017     case Georgian:
2018         name = QT_TRANSLATE_NOOP("QFontDatabase", "Georgian");
2019         break;
2020     case Khmer:
2021         name = QT_TRANSLATE_NOOP("QFontDatabase", "Khmer");
2022         break;
2023     case SimplifiedChinese:
2024         name = QT_TRANSLATE_NOOP("QFontDatabase", "Simplified Chinese");
2025         break;
2026     case TraditionalChinese:
2027         name = QT_TRANSLATE_NOOP("QFontDatabase", "Traditional Chinese");
2028         break;
2029     case Japanese:
2030         name = QT_TRANSLATE_NOOP("QFontDatabase", "Japanese");
2031         break;
2032     case Korean:
2033         name = QT_TRANSLATE_NOOP("QFontDatabase", "Korean");
2034         break;
2035     case Vietnamese:
2036         name = QT_TRANSLATE_NOOP("QFontDatabase", "Vietnamese");
2037         break;
2038     case Symbol:
2039         name = QT_TRANSLATE_NOOP("QFontDatabase", "Symbol");
2040         break;
2041     case Ogham:
2042         name = QT_TRANSLATE_NOOP("QFontDatabase", "Ogham");
2043         break;
2044     case Runic:
2045         name = QT_TRANSLATE_NOOP("QFontDatabase", "Runic");
2046         break;
2047     case Nko:
2048         name = QT_TRANSLATE_NOOP("QFontDatabase", "N'Ko");
2049         break;
2050     default:
2051         Q_ASSERT_X(false, "QFontDatabase::writingSystemName", "invalid 'writingSystem' parameter");
2052         break;
2053     }
2054     return QCoreApplication::translate("QFontDatabase", name);
2055 }
2056 
2057 static QStringView writing_system_sample(QFontDatabase::WritingSystem writingSystem)
2058 {
2059     switch (writingSystem) {
2060     case QFontDatabase::Any:
2061     case QFontDatabase::Symbol:
2062         // show only ascii characters
2063         return u"AaBbzZ";
2064     case QFontDatabase::Latin:
2065         // This is cheating... we only show latin-1 characters so that we don't
2066         // end up loading lots of fonts - at least on X11...
2067         return u"Aa\x00C3\x00E1Zz";
2068     case QFontDatabase::Greek:
2069         return u"\x0393\x03B1\x03A9\x03C9";
2070     case QFontDatabase::Cyrillic:
2071         return u"\x0414\x0434\x0436\x044f";
2072     case QFontDatabase::Armenian:
2073         return u"\x053f\x054f\x056f\x057f";
2074     case QFontDatabase::Hebrew:
2075         return u"\x05D0\x05D1\x05D2\x05D3";
2076     case QFontDatabase::Arabic:
2077         return u"\x0623\x0628\x062C\x062F\x064A\x0629\x0020\x0639\x0631\x0628\x064A\x0629";
2078     case QFontDatabase::Syriac:
2079         return u"\x0715\x0725\x0716\x0726";
2080     case QFontDatabase::Thaana:
2081         return u"\x0784\x0794\x078c\x078d";
2082     case QFontDatabase::Devanagari:
2083         return u"\x0905\x0915\x0925\x0935";
2084     case QFontDatabase::Bengali:
2085         return u"\x0986\x0996\x09a6\x09b6";
2086     case QFontDatabase::Gurmukhi:
2087         return u"\x0a05\x0a15\x0a25\x0a35";
2088     case QFontDatabase::Gujarati:
2089         return u"\x0a85\x0a95\x0aa5\x0ab5";
2090     case QFontDatabase::Oriya:
2091         return u"\x0b06\x0b16\x0b2b\x0b36";
2092     case QFontDatabase::Tamil:
2093         return u"\x0b89\x0b99\x0ba9\x0bb9";
2094     case QFontDatabase::Telugu:
2095         return u"\x0c05\x0c15\x0c25\x0c35";
2096     case QFontDatabase::Kannada:
2097         return u"\x0c85\x0c95\x0ca5\x0cb5";
2098     case QFontDatabase::Malayalam:
2099         return u"\x0d05\x0d15\x0d25\x0d35";
2100     case QFontDatabase::Sinhala:
2101         return u"\x0d90\x0da0\x0db0\x0dc0";
2102     case QFontDatabase::Thai:
2103         return u"\x0e02\x0e12\x0e22\x0e32";
2104     case QFontDatabase::Lao:
2105         return u"\x0e8d\x0e9d\x0ead\x0ebd";
2106     case QFontDatabase::Tibetan:
2107         return u"\x0f00\x0f01\x0f02\x0f03";
2108     case QFontDatabase::Myanmar:
2109         return u"\x1000\x1001\x1002\x1003";
2110     case QFontDatabase::Georgian:
2111         return u"\x10a0\x10b0\x10c0\x10d0";
2112     case QFontDatabase::Khmer:
2113         return u"\x1780\x1790\x17b0\x17c0";
2114     case QFontDatabase::SimplifiedChinese:
2115         return u"\x4e2d\x6587\x8303\x4f8b";
2116     case QFontDatabase::TraditionalChinese:
2117         return u"\x4e2d\x6587\x7bc4\x4f8b";
2118     case QFontDatabase::Japanese:
2119         return u"\x30b5\x30f3\x30d7\x30eb\x3067\x3059";
2120     case QFontDatabase::Korean:
2121         return u"\xac00\xac11\xac1a\xac2f";
2122     case QFontDatabase::Vietnamese:
2123         return u"\x1ED7\x1ED9\x1ED1\x1ED3";
2124     case QFontDatabase::Ogham:
2125         return u"\x1681\x1682\x1683\x1684";
2126     case QFontDatabase::Runic:
2127         return u"\x16a0\x16a1\x16a2\x16a3";
2128     case QFontDatabase::Nko:
2129         return u"\x7ca\x7cb\x7cc\x7cd";
2130     default:
2131         return nullptr;
2132     }
2133 }
2134 
2135 /*!
2136     Returns a string with sample characters from \a writingSystem.
2137 */
2138 QString QFontDatabase::writingSystemSample(WritingSystem writingSystem)
2139 {
2140     return writing_system_sample(writingSystem).toString();
2141 }
2142 
2143 void QFontDatabasePrivate::parseFontName(const QString &name, QString &foundry, QString &family)
2144 {
2145     QT_PREPEND_NAMESPACE(parseFontName)(name, foundry, family);
2146 }
2147 
2148 // used from qfontengine_ft.cpp
2149 Q_GUI_EXPORT QByteArray qt_fontdata_from_index(int index)
2150 {
2151     QMutexLocker locker(fontDatabaseMutex());
2152     return QFontDatabasePrivate::instance()->applicationFonts.value(index).data;
2153 }
2154 
2155 int QFontDatabasePrivate::addAppFont(const QByteArray &fontData, const QString &fileName)
2156 {
2157     QFontDatabasePrivate::ApplicationFont font;
2158     font.data = fontData;
2159     font.fileName = fileName;
2160 
2161     Q_TRACE(QFontDatabasePrivate_addAppFont, fileName);
2162 
2163     int i;
2164     for (i = 0; i < applicationFonts.count(); ++i)
2165         if (applicationFonts.at(i).properties.isEmpty())
2166             break;
2167     if (i >= applicationFonts.count()) {
2168         applicationFonts.append(ApplicationFont());
2169         i = applicationFonts.count() - 1;
2170     }
2171 
2172     if (font.fileName.isEmpty() && !fontData.isEmpty())
2173         font.fileName = QLatin1String(":qmemoryfonts/") + QString::number(i);
2174 
2175     bool wasEmpty = QFontDatabasePrivate::instance()->count == 0;
2176     registerFont(&font);
2177     if (font.properties.isEmpty())
2178         return -1;
2179 
2180     applicationFonts[i] = font;
2181 
2182     // If the cache has not yet been populated, we need to reload the application font later
2183     if (wasEmpty)
2184         invalidate();
2185     else
2186         emit qApp->fontDatabaseChanged();
2187     return i;
2188 }
2189 
2190 bool QFontDatabasePrivate::isApplicationFont(const QString &fileName)
2191 {
2192     for (int i = 0; i < applicationFonts.count(); ++i)
2193         if (applicationFonts.at(i).fileName == fileName)
2194             return true;
2195     return false;
2196 }
2197 
2198 /*!
2199     \since 4.2
2200 
2201     Loads the font from the file specified by \a fileName and makes it available to
2202     the application. An ID is returned that can be used to remove the font again
2203     with removeApplicationFont() or to retrieve the list of family names contained
2204     in the font.
2205 
2206 //! [add-application-font-doc]
2207     The function returns -1 if the font could not be loaded.
2208 
2209     Currently only TrueType fonts, TrueType font collections, and OpenType fonts are
2210     supported.
2211 //! [add-application-font-doc]
2212 
2213     \sa addApplicationFontFromData(), applicationFontFamilies(), removeApplicationFont()
2214 */
2215 int QFontDatabase::addApplicationFont(const QString &fileName)
2216 {
2217     QByteArray data;
2218     if (!QFileInfo(fileName).isNativePath()) {
2219         QFile f(fileName);
2220         if (!f.open(QIODevice::ReadOnly))
2221             return -1;
2222 
2223         Q_TRACE(QFontDatabase_addApplicationFont, fileName);
2224 
2225         data = f.readAll();
2226     }
2227     QMutexLocker locker(fontDatabaseMutex());
2228     return QFontDatabasePrivate::instance()->addAppFont(data, fileName);
2229 }
2230 
2231 /*!
2232     \since 4.2
2233 
2234     Loads the font from binary data specified by \a fontData and makes it available to
2235     the application. An ID is returned that can be used to remove the font again
2236     with removeApplicationFont() or to retrieve the list of family names contained
2237     in the font.
2238 
2239     \include qfontdatabase.cpp add-application-font-doc
2240 
2241     \sa addApplicationFont(), applicationFontFamilies(), removeApplicationFont()
2242 */
2243 int QFontDatabase::addApplicationFontFromData(const QByteArray &fontData)
2244 {
2245     QMutexLocker locker(fontDatabaseMutex());
2246     return QFontDatabasePrivate::instance()->addAppFont(fontData, QString() /* fileName */);
2247 }
2248 
2249 /*!
2250     \since 4.2
2251 
2252     Returns a list of font families for the given application font identified by
2253     \a id.
2254 
2255     \sa addApplicationFont(), addApplicationFontFromData()
2256 */
2257 QStringList QFontDatabase::applicationFontFamilies(int id)
2258 {
2259     QMutexLocker locker(fontDatabaseMutex());
2260     auto *d = QFontDatabasePrivate::instance();
2261 
2262     QStringList ret;
2263     ret.reserve(d->applicationFonts.value(id).properties.size());
2264 
2265     for (const auto &properties : d->applicationFonts.value(id).properties)
2266         ret.append(properties.familyName);
2267 
2268     return ret;
2269 }
2270 
2271 /*!
2272     \since 5.2
2273 
2274     Returns the most adequate font for a given \a type case for proper integration
2275     with the system's look and feel.
2276 
2277     \sa QGuiApplication::font()
2278 */
2279 
2280 QFont QFontDatabase::systemFont(QFontDatabase::SystemFont type)
2281 {
2282     const QFont *font = nullptr;
2283     if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme()) {
2284         switch (type) {
2285             case GeneralFont:
2286                 font = theme->font(QPlatformTheme::SystemFont);
2287                 break;
2288             case FixedFont:
2289                 font = theme->font(QPlatformTheme::FixedFont);
2290                 break;
2291             case TitleFont:
2292                 font = theme->font(QPlatformTheme::TitleBarFont);
2293                 break;
2294             case SmallestReadableFont:
2295                 font = theme->font(QPlatformTheme::MiniFont);
2296                 break;
2297         }
2298     }
2299 
2300     if (font)
2301         return *font;
2302     else if (QPlatformIntegration *integration = QGuiApplicationPrivate::platformIntegration())
2303         return integration->fontDatabase()->defaultFont();
2304     else
2305         return QFont();
2306 }
2307 
2308 /*!
2309     \fn bool QFontDatabase::removeApplicationFont(int id)
2310     \since 4.2
2311 
2312     Removes the previously loaded application font identified by \a
2313     id. Returns \c true if unloading of the font succeeded; otherwise
2314     returns \c false.
2315 
2316     \sa removeAllApplicationFonts(), addApplicationFont(),
2317         addApplicationFontFromData()
2318 */
2319 bool QFontDatabase::removeApplicationFont(int handle)
2320 {
2321     QMutexLocker locker(fontDatabaseMutex());
2322 
2323     auto *db = QFontDatabasePrivate::instance();
2324     if (handle < 0 || handle >= db->applicationFonts.count())
2325         return false;
2326 
2327     db->applicationFonts[handle] = QFontDatabasePrivate::ApplicationFont();
2328 
2329     db->invalidate();
2330     return true;
2331 }
2332 
2333 /*!
2334     \fn bool QFontDatabase::removeAllApplicationFonts()
2335     \since 4.2
2336 
2337     Removes all application-local fonts previously added using addApplicationFont()
2338     and addApplicationFontFromData().
2339 
2340     Returns \c true if unloading of the fonts succeeded; otherwise
2341     returns \c false.
2342 
2343     \sa removeApplicationFont(), addApplicationFont(), addApplicationFontFromData()
2344 */
2345 bool QFontDatabase::removeAllApplicationFonts()
2346 {
2347     QMutexLocker locker(fontDatabaseMutex());
2348 
2349     auto *db = QFontDatabasePrivate::instance();
2350     if (!db || db->applicationFonts.isEmpty())
2351         return false;
2352 
2353     db->applicationFonts.clear();
2354     db->invalidate();
2355     return true;
2356 }
2357 
2358 /*!
2359     \internal
2360 */
2361 QFontEngine *QFontDatabasePrivate::findFont(const QFontDef &req,
2362                                             int script,
2363                                             bool preferScriptOverFamily)
2364 {
2365     QMutexLocker locker(fontDatabaseMutex());
2366 
2367     if (!QFontDatabasePrivate::instance()->count)
2368         initializeDb();
2369 
2370     QFontEngine *engine;
2371 
2372 #ifdef Q_OS_WIN
2373     const QFontDef request = static_cast<QWindowsFontDatabaseBase *>(
2374                                      QGuiApplicationPrivate::platformIntegration()->fontDatabase())
2375                                      ->sanitizeRequest(req);
2376 #else
2377     const QFontDef &request = req;
2378 #endif
2379 
2380 #if defined(QT_BUILD_INTERNAL)
2381     // For testing purpose only, emulates an exact-matching monospace font
2382     if (qt_enable_test_font && request.families.first() == QLatin1String("__Qt__Box__Engine__")) {
2383         engine = new QTestFontEngine(request.pixelSize);
2384         engine->fontDef = request;
2385         return engine;
2386     }
2387 #endif
2388 
2389     QFontCache *fontCache = QFontCache::instance();
2390 
2391     // Until we specifically asked not to, try looking for Multi font engine
2392     // first, the last '1' indicates that we want Multi font engine instead
2393     // of single ones
2394     bool multi = !(request.styleStrategy & QFont::NoFontMerging);
2395     QFontCache::Key key(request, script, multi ? 1 : 0);
2396     engine = fontCache->findEngine(key);
2397     if (engine) {
2398         qCDebug(lcFontMatch, "Cache hit level 1");
2399         return engine;
2400     }
2401 
2402     if (request.pixelSize > 0xffff) {
2403         // Stop absurd requests reaching the engines; pixel size is assumed to fit ushort
2404         qCDebug(lcFontMatch, "Rejecting request for pixel size %g2, returning box engine", double(request.pixelSize));
2405         return new QFontEngineBox(32); // not request.pixelSize, to avoid overflow/DOS
2406     }
2407 
2408     QString family_name, foundry_name;
2409     const QString requestFamily = request.families.at(0);
2410     parseFontName(requestFamily, foundry_name, family_name);
2411     QtFontDesc desc;
2412     QList<int> blackListed;
2413     unsigned int score = UINT_MAX;
2414     int index = match(multi ? QChar::Script_Common : script, request, family_name, foundry_name, &desc, blackListed, &score);
2415     if ((score & FamilyMismatch) && QGuiApplicationPrivate::platformIntegration()->fontDatabase()->populateFamilyAliases(family_name)) {
2416         // We populated family aliases (e.g. localized families), so try again
2417         index = match(multi ? QChar::Script_Common : script, request, family_name, foundry_name, &desc, blackListed);
2418     }
2419 
2420     // If we do not find a match and NoFontMerging is set, use the requested font even if it does
2421     // not support the script.
2422     //
2423     // (we do this at the end to prefer foundries that support the script if they exist)
2424     if (index < 0 && !multi && !preferScriptOverFamily)
2425         index = match(QChar::Script_Common, request, family_name, foundry_name, &desc, blackListed);
2426 
2427     if (index >= 0) {
2428         QFontDef fontDef = request;
2429         // Don't pass empty family names to the platform font database, since it will then invoke its own matching
2430         // and we will be out of sync with the matched font.
2431         if (fontDef.families.isEmpty())
2432             fontDef.families = QStringList(desc.family->name);
2433 
2434         engine = loadEngine(script, fontDef, desc.family, desc.foundry, desc.style, desc.size);
2435 
2436         if (engine)
2437             initFontDef(desc, request, &engine->fontDef, multi);
2438         else
2439             blackListed.append(index);
2440     } else {
2441         qCDebug(lcFontMatch, "  NO MATCH FOUND\n");
2442     }
2443 
2444     if (!engine) {
2445         if (!requestFamily.isEmpty()) {
2446             QFont::StyleHint styleHint = QFont::StyleHint(request.styleHint);
2447             if (styleHint == QFont::AnyStyle && request.fixedPitch)
2448                 styleHint = QFont::TypeWriter;
2449 
2450             QStringList fallbacks = request.fallBackFamilies
2451                                   + fallbacksForFamily(requestFamily,
2452                                                        QFont::Style(request.style),
2453                                                        styleHint,
2454                                                        QChar::Script(script));
2455             if (script > QChar::Script_Common)
2456                 fallbacks += QString(); // Find the first font matching the specified script.
2457 
2458             for (int i = 0; !engine && i < fallbacks.size(); i++) {
2459                 QFontDef def = request;
2460                 def.families = QStringList(fallbacks.at(i));
2461                 QFontCache::Key key(def, script, multi ? 1 : 0);
2462                 engine = fontCache->findEngine(key);
2463                 if (!engine) {
2464                     QtFontDesc desc;
2465                     do {
2466                         index = match(multi ? QChar::Script_Common : script, def, def.families.first(), QLatin1String(""), &desc, blackListed);
2467                         if (index >= 0) {
2468                             QFontDef loadDef = def;
2469                             if (loadDef.families.isEmpty())
2470                                 loadDef.families = QStringList(desc.family->name);
2471                             engine = loadEngine(script, loadDef, desc.family, desc.foundry, desc.style, desc.size);
2472                             if (engine)
2473                                 initFontDef(desc, loadDef, &engine->fontDef, multi);
2474                             else
2475                                 blackListed.append(index);
2476                         }
2477                     } while (index >= 0 && !engine);
2478                 }
2479             }
2480         }
2481 
2482         if (!engine)
2483             engine = new QFontEngineBox(request.pixelSize);
2484 
2485         qCDebug(lcFontMatch, "returning box engine");
2486     }
2487 
2488     return engine;
2489 }
2490 
2491 void QFontDatabasePrivate::load(const QFontPrivate *d, int script)
2492 {
2493     QFontDef req = d->request;
2494 
2495     if (req.pixelSize == -1) {
2496         req.pixelSize = std::floor(((req.pointSize * d->dpi) / 72) * 100 + 0.5) / 100;
2497         req.pixelSize = qRound(req.pixelSize);
2498     }
2499     if (req.pointSize < 0)
2500         req.pointSize = req.pixelSize*72.0/d->dpi;
2501 
2502     // respect the fallback families that might be passed through the request
2503     const QStringList fallBackFamilies = familyList(req);
2504 
2505     if (!d->engineData) {
2506         QFontCache *fontCache = QFontCache::instance();
2507         // look for the requested font in the engine data cache
2508         // note: fallBackFamilies are not respected in the EngineData cache key;
2509         //       join them with the primary selection family to avoid cache misses
2510         if (!d->request.families.isEmpty())
2511             req.families = fallBackFamilies;
2512 
2513         d->engineData = fontCache->findEngineData(req);
2514         if (!d->engineData) {
2515             // create a new one
2516             d->engineData = new QFontEngineData;
2517             fontCache->insertEngineData(req, d->engineData);
2518         }
2519         d->engineData->ref.ref();
2520     }
2521 
2522     // the cached engineData could have already loaded the engine we want
2523     if (d->engineData->engines[script])
2524         return;
2525 
2526     QFontEngine *fe = nullptr;
2527 
2528     Q_TRACE(QFontDatabase_load, req.families, req.pointSize);
2529 
2530     req.fallBackFamilies = fallBackFamilies;
2531     if (!req.fallBackFamilies.isEmpty())
2532         req.families = QStringList(req.fallBackFamilies.takeFirst());
2533 
2534     // list of families to try
2535     QStringList family_list;
2536 
2537     if (!req.families.isEmpty()) {
2538         // Add primary selection
2539         family_list << req.families.at(0);
2540 
2541         // add the default family
2542         auto families = QGuiApplication::font().families();
2543         if (!families.isEmpty()) {
2544             QString defaultFamily = families.first();
2545             if (! family_list.contains(defaultFamily))
2546                 family_list << defaultFamily;
2547         }
2548 
2549     }
2550 
2551     // null family means find the first font matching the specified script
2552     family_list << QString();
2553 
2554     QStringList::ConstIterator it = family_list.constBegin(), end = family_list.constEnd();
2555     for (; !fe && it != end; ++it) {
2556         req.families = QStringList(*it);
2557 
2558         fe = QFontDatabasePrivate::findFont(req, script);
2559         if (fe) {
2560             if (fe->type() == QFontEngine::Box && !req.families.at(0).isEmpty()) {
2561                 if (fe->ref.loadRelaxed() == 0)
2562                     delete fe;
2563                 fe = nullptr;
2564             } else {
2565                 if (d->dpi > 0)
2566                     fe->fontDef.pointSize = qreal(double((fe->fontDef.pixelSize * 72) / d->dpi));
2567             }
2568         }
2569 
2570         // No need to check requested fallback families again
2571         req.fallBackFamilies.clear();
2572     }
2573 
2574     Q_ASSERT(fe);
2575     if (fe->symbol || (d->request.styleStrategy & QFont::NoFontMerging)) {
2576         for (int i = 0; i < QChar::ScriptCount; ++i) {
2577             if (!d->engineData->engines[i]) {
2578                 d->engineData->engines[i] = fe;
2579                 fe->ref.ref();
2580             }
2581         }
2582     } else {
2583         d->engineData->engines[script] = fe;
2584         fe->ref.ref();
2585     }
2586 }
2587 
2588 QString QFontDatabasePrivate::resolveFontFamilyAlias(const QString &family)
2589 {
2590     return QGuiApplicationPrivate::platformIntegration()->fontDatabase()->resolveFontFamilyAlias(family);
2591 }
2592 
2593 Q_GUI_EXPORT QStringList qt_sort_families_by_writing_system(QChar::Script script, const QStringList &families)
2594 {
2595     size_t writingSystem = qt_writing_system_for_script(script);
2596     if (writingSystem == QFontDatabase::Any
2597             || writingSystem >= QFontDatabase::WritingSystemsCount) {
2598         return families;
2599     }
2600 
2601     auto *db = QFontDatabasePrivate::instance();
2602     QMultiMap<uint, QString> supported;
2603     for (int i = 0; i < families.size(); ++i) {
2604         const QString &family = families.at(i);
2605 
2606         QtFontFamily *testFamily = nullptr;
2607         for (int x = 0; x < db->count; ++x) {
2608             if (Q_UNLIKELY(matchFamilyName(family, db->families[x]))) {
2609                 testFamily = db->families[x];
2610                 testFamily->ensurePopulated();
2611                 break;
2612             }
2613         }
2614 
2615         uint order = i;
2616         if (testFamily == nullptr
2617               || !familySupportsWritingSystem(testFamily, writingSystem)) {
2618             order |= 1u << 31;
2619         }
2620 
2621         supported.insert(order, family);
2622     }
2623 
2624     return supported.values();
2625 }
2626 
2627 QT_END_NAMESPACE
2628 
