Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2019 The Qt Company Ltd.
4 ** Copyright (C) 2016 Jolla Ltd, author: <gunnar.sletta@jollamobile.com>
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the plugins module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qevdevtouchhandler_p.h"
42 #include "qoutputmapping_p.h"
43 #include <QStringList>
44 #include <QHash>
45 #include <QSocketNotifier>
46 #include <QGuiApplication>
47 #include <QLoggingCategory>
48 #include <QtCore/private/qcore_unix_p.h>
49 #include <QtGui/qpointingdevice.h>
50 #include <QtGui/private/qhighdpiscaling_p.h>
51 #include <QtGui/private/qguiapplication_p.h>
52 #include <QtGui/private/qpointingdevice_p.h>
53 
54 #include <mutex>
55 
56 #ifdef Q_OS_FREEBSD
57 #include <dev/evdev/input.h>
58 #else
59 #include <linux/input.h>
60 #endif
61 
62 #ifndef input_event_sec
63 #define input_event_sec time.tv_sec
64 #endif
65 
66 #ifndef input_event_usec
67 #define input_event_usec time.tv_usec
68 #endif
69 
70 #include <math.h>
71 
72 #if QT_CONFIG(mtdev)
73 extern "C" {
74 #include <mtdev.h>
75 }
76 #endif
77 
78 QT_BEGIN_NAMESPACE
79 
80 Q_LOGGING_CATEGORY(qLcEvdevTouch, "qt.qpa.input")
81 Q_LOGGING_CATEGORY(qLcEvents, "qt.qpa.input.events")
82 
83 /* android (and perhaps some other linux-derived stuff) don't define everything
84  * in linux/input.h, so we'll need to do that ourselves.
85  */
86 #ifndef ABS_MT_TOUCH_MAJOR
87 #define ABS_MT_TOUCH_MAJOR      0x30    /* Major axis of touching ellipse */
88 #endif
89 #ifndef ABS_MT_POSITION_X
90 #define ABS_MT_POSITION_X       0x35    /* Center X ellipse position */
91 #endif
92 #ifndef ABS_MT_POSITION_Y
93 #define ABS_MT_POSITION_Y       0x36    /* Center Y ellipse position */
94 #endif
95 #ifndef ABS_MT_SLOT
96 #define ABS_MT_SLOT 0x2f
97 #endif
98 #ifndef ABS_CNT
99 #define ABS_CNT                 (ABS_MAX+1)
100 #endif
101 #ifndef ABS_MT_TRACKING_ID
102 #define ABS_MT_TRACKING_ID      0x39    /* Unique ID of initiated contact */
103 #endif
104 #ifndef ABS_MT_PRESSURE
105 #define ABS_MT_PRESSURE         0x3a
106 #endif
107 #ifndef SYN_MT_REPORT
108 #define SYN_MT_REPORT           2
109 #endif
110 
111 class QEvdevTouchScreenData
112 {
113 public:
114     QEvdevTouchScreenData(QEvdevTouchScreenHandler *q_ptr, const QStringList &args);
115 
116     void processInputEvent(input_event *data);
117     void assignIds();
118 
119     QEvdevTouchScreenHandler *q;
120     int m_lastEventType;
121     QList<QWindowSystemInterface::TouchPoint> m_touchPoints;
122     QList<QWindowSystemInterface::TouchPoint> m_lastTouchPoints;
123 
124     struct Contact {
125         int trackingId = -1;
126         int x = 0;
127         int y = 0;
128         int maj = -1;
129         int pressure = 0;
130         QEventPoint::State state = QEventPoint::State::Pressed;
131     };
132     QHash<int, Contact> m_contacts; // The key is a tracking id for type A, slot number for type B.
133     QHash<int, Contact> m_lastContacts;
134     Contact m_currentData;
135     int m_currentSlot;
136 
137     double m_timeStamp;
138     double m_lastTimeStamp;
139 
140     int findClosestContact(const QHash<int, Contact> &contacts, int x, int y, int *dist);
141     void addTouchPoint(const Contact &contact, QEventPoint::States *combinedStates);
142     void reportPoints();
143     void loadMultiScreenMappings();
144 
145     QRect screenGeometry() const;
146 
147     int hw_range_x_min;
148     int hw_range_x_max;
149     int hw_range_y_min;
150     int hw_range_y_max;
151     int hw_pressure_min;
152     int hw_pressure_max;
153     QString hw_name;
154     QString deviceNode;
155     bool m_forceToActiveWindow;
156     bool m_typeB;
157     QTransform m_rotate;
158     bool m_singleTouch;
159     QString m_screenName;
160     mutable QPointer<QScreen> m_screen;
161 
162     // Touch filtering and prediction are part of the same thing. The default
163     // prediction is 0ms, but sensible results can be achieved by setting it
164     // to, for instance, 16ms.
165     // For filtering to work well, the QPA plugin should provide a dead-steady
166     // implementation of QPlatformWindow::requestUpdate().
167     bool m_filtered;
168     int m_prediction;
169 
170     // When filtering is enabled, protect the access to current and last
171     // timeStamp and touchPoints, as these are being read on the gui thread.
172     QMutex m_mutex;
173 };
174 
175 QEvdevTouchScreenData::QEvdevTouchScreenData(QEvdevTouchScreenHandler *q_ptr, const QStringList &args)
176     : q(q_ptr),
177       m_lastEventType(-1),
178       m_currentSlot(0),
179       m_timeStamp(0), m_lastTimeStamp(0),
180       hw_range_x_min(0), hw_range_x_max(0),
181       hw_range_y_min(0), hw_range_y_max(0),
182       hw_pressure_min(0), hw_pressure_max(0),
183       m_forceToActiveWindow(false), m_typeB(false), m_singleTouch(false),
184       m_filtered(false), m_prediction(0)
185 {
186     for (const QString &arg : args) {
187         if (arg == QStringLiteral("force_window"))
188             m_forceToActiveWindow = true;
189         else if (arg == QStringLiteral("filtered"))
190             m_filtered = true;
191         else if (arg.startsWith(QStringLiteral("prediction=")))
192             m_prediction = arg.mid(11).toInt();
193     }
194 }
195 
196 #define LONG_BITS (sizeof(long) << 3)
197 #define NUM_LONGS(bits) (((bits) + LONG_BITS - 1) / LONG_BITS)
198 
199 #if !QT_CONFIG(mtdev)
200 static inline bool testBit(long bit, const long *array)
201 {
202     return (array[bit / LONG_BITS] >> bit % LONG_BITS) & 1;
203 }
204 #endif
205 
206 QEvdevTouchScreenHandler::QEvdevTouchScreenHandler(const QString &device, const QString &spec, QObject *parent)
207     : QObject(parent), m_notify(nullptr), m_fd(-1), d(nullptr), m_device(nullptr)
208 #if QT_CONFIG(mtdev)
209       , m_mtdev(nullptr)
210 #endif
211 {
212     setObjectName(QLatin1String("Evdev Touch Handler"));
213 
214     const QStringList args = spec.split(QLatin1Char(':'));
215     int rotationAngle = 0;
216     bool invertx = false;
217     bool inverty = false;
218     for (int i = 0; i < args.count(); ++i) {
219         if (args.at(i).startsWith(QLatin1String("rotate"))) {
220             QString rotateArg = args.at(i).section(QLatin1Char('='), 1, 1);
221             bool ok;
222             uint argValue = rotateArg.toUInt(&ok);
223             if (ok) {
224                 switch (argValue) {
225                 case 90:
226                 case 180:
227                 case 270:
228                     rotationAngle = argValue;
229                 default:
230                     break;
231                 }
232             }
233         } else if (args.at(i) == QLatin1String("invertx")) {
234             invertx = true;
235         } else if (args.at(i) == QLatin1String("inverty")) {
236             inverty = true;
237         }
238     }
239 
240     qCDebug(qLcEvdevTouch, "evdevtouch: Using device %ls", qUtf16Printable(device));
241 
242     m_fd = QT_OPEN(device.toLocal8Bit().constData(), O_RDONLY | O_NDELAY, 0);
243 
244     if (m_fd >= 0) {
245         m_notify = new QSocketNotifier(m_fd, QSocketNotifier::Read, this);
246         connect(m_notify, &QSocketNotifier::activated, this, &QEvdevTouchScreenHandler::readData);
247     } else {
248         qErrnoWarning("evdevtouch: Cannot open input device %ls", qUtf16Printable(device));
249         return;
250     }
251 
252 #if QT_CONFIG(mtdev)
253     m_mtdev = static_cast<mtdev *>(calloc(1, sizeof(mtdev)));
254     int mtdeverr = mtdev_open(m_mtdev, m_fd);
255     if (mtdeverr) {
256         qWarning("evdevtouch: mtdev_open failed: %d", mtdeverr);
257         QT_CLOSE(m_fd);
258         free(m_mtdev);
259         return;
260     }
261 #endif
262 
263     d = new QEvdevTouchScreenData(this, args);
264 
265 #if QT_CONFIG(mtdev)
266     const char *mtdevStr = "(mtdev)";
267     d->m_typeB = true;
268 #else
269     const char *mtdevStr = "";
270     long absbits[NUM_LONGS(ABS_CNT)];
271     if (ioctl(m_fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits) >= 0) {
272         d->m_typeB = testBit(ABS_MT_SLOT, absbits);
273         d->m_singleTouch = !testBit(ABS_MT_POSITION_X, absbits);
274     }
275 #endif
276 
277     d->deviceNode = device;
278     qCDebug(qLcEvdevTouch,
279             "evdevtouch: %ls: Protocol type %c %s (%s), filtered=%s",
280             qUtf16Printable(d->deviceNode),
281             d->m_typeB ? 'B' : 'A', mtdevStr,
282             d->m_singleTouch ? "single" : "multi",
283             d->m_filtered ? "yes" : "no");
284     if (d->m_filtered)
285         qCDebug(qLcEvdevTouch, " - prediction=%d", d->m_prediction);
286 
287     input_absinfo absInfo;
288     memset(&absInfo, 0, sizeof(input_absinfo));
289     bool has_x_range = false, has_y_range = false;
290 
291     if (ioctl(m_fd, EVIOCGABS((d->m_singleTouch ? ABS_X : ABS_MT_POSITION_X)), &absInfo) >= 0) {
292         qCDebug(qLcEvdevTouch, "evdevtouch: %ls: min X: %d max X: %d", qUtf16Printable(device),
293                 absInfo.minimum, absInfo.maximum);
294         d->hw_range_x_min = absInfo.minimum;
295         d->hw_range_x_max = absInfo.maximum;
296         has_x_range = true;
297     }
298 
299     if (ioctl(m_fd, EVIOCGABS((d->m_singleTouch ? ABS_Y : ABS_MT_POSITION_Y)), &absInfo) >= 0) {
300         qCDebug(qLcEvdevTouch, "evdevtouch: %ls: min Y: %d max Y: %d", qUtf16Printable(device),
301                 absInfo.minimum, absInfo.maximum);
302         d->hw_range_y_min = absInfo.minimum;
303         d->hw_range_y_max = absInfo.maximum;
304         has_y_range = true;
305     }
306 
307     if (!has_x_range || !has_y_range)
308         qWarning("evdevtouch: %ls: Invalid ABS limits, behavior unspecified", qUtf16Printable(device));
309 
310     if (ioctl(m_fd, EVIOCGABS(ABS_PRESSURE), &absInfo) >= 0) {
311         qCDebug(qLcEvdevTouch, "evdevtouch: %ls: min pressure: %d max pressure: %d", qUtf16Printable(device),
312                 absInfo.minimum, absInfo.maximum);
313         if (absInfo.maximum > absInfo.minimum) {
314             d->hw_pressure_min = absInfo.minimum;
315             d->hw_pressure_max = absInfo.maximum;
316         }
317     }
318 
319     char name[1024];
320     if (ioctl(m_fd, EVIOCGNAME(sizeof(name) - 1), name) >= 0) {
321         d->hw_name = QString::fromLocal8Bit(name);
322         qCDebug(qLcEvdevTouch, "evdevtouch: %ls: device name: %s", qUtf16Printable(device), name);
323     }
324 
325     // Fix up the coordinate ranges for am335x in case the kernel driver does not have them fixed.
326     if (d->hw_name == QLatin1String("ti-tsc")) {
327         if (d->hw_range_x_min == 0 && d->hw_range_x_max == 4095) {
328             d->hw_range_x_min = 165;
329             d->hw_range_x_max = 4016;
330         }
331         if (d->hw_range_y_min == 0 && d->hw_range_y_max == 4095) {
332             d->hw_range_y_min = 220;
333             d->hw_range_y_max = 3907;
334         }
335         qCDebug(qLcEvdevTouch, "evdevtouch: found ti-tsc, overriding: min X: %d max X: %d min Y: %d max Y: %d",
336                 d->hw_range_x_min, d->hw_range_x_max, d->hw_range_y_min, d->hw_range_y_max);
337     }
338 
339     bool grabSuccess = !ioctl(m_fd, EVIOCGRAB, (void *) 1);
340     if (grabSuccess)
341         ioctl(m_fd, EVIOCGRAB, (void *) 0);
342     else
343         qWarning("evdevtouch: The device is grabbed by another process. No events will be read.");
344 
345     if (rotationAngle)
346         d->m_rotate = QTransform::fromTranslate(0.5, 0.5).rotate(rotationAngle).translate(-0.5, -0.5);
347 
348     if (invertx)
349         d->m_rotate *= QTransform::fromTranslate(0.5, 0.5).scale(-1.0, 1.0).translate(-0.5, -0.5);
350 
351     if (inverty)
352         d->m_rotate *= QTransform::fromTranslate(0.5, 0.5).scale(1.0, -1.0).translate(-0.5, -0.5);
353 
354     QOutputMapping *mapping = QOutputMapping::get();
355     if (mapping->load()) {
356         d->m_screenName = mapping->screenNameForDeviceNode(d->deviceNode);
357         if (!d->m_screenName.isEmpty())
358             qCDebug(qLcEvdevTouch, "evdevtouch: Mapping device %ls to screen %ls",
359                     qUtf16Printable(d->deviceNode), qUtf16Printable(d->m_screenName));
360     }
361 
362     registerPointingDevice();
363 }
364 
365 QEvdevTouchScreenHandler::~QEvdevTouchScreenHandler()
366 {
367 #if QT_CONFIG(mtdev)
368     if (m_mtdev) {
369         mtdev_close(m_mtdev);
370         free(m_mtdev);
371     }
372 #endif
373 
374     if (m_fd >= 0)
375         QT_CLOSE(m_fd);
376 
377     delete d;
378 
379     unregisterPointingDevice();
380 }
381 
382 bool QEvdevTouchScreenHandler::isFiltered() const
383 {
384     return d && d->m_filtered;
385 }
386 
387 QPointingDevice *QEvdevTouchScreenHandler::touchDevice() const
388 {
389     return m_device;
390 }
391 
392 void QEvdevTouchScreenHandler::readData()
393 {
394     ::input_event buffer[32];
395     int events = 0;
396 
397 #if QT_CONFIG(mtdev)
398     forever {
399         do {
400             events = mtdev_get(m_mtdev, m_fd, buffer, sizeof(buffer) / sizeof(::input_event));
401             // keep trying mtdev_get if we get interrupted. note that we do not
402             // (and should not) handle EAGAIN; EAGAIN means that reading would
403             // block and we'll get back here later to try again anyway.
404         } while (events == -1 && errno == EINTR);
405 
406         // 0 events is EOF, -1 means error, handle both in the same place
407         if (events <= 0)
408             goto err;
409 
410         // process our shiny new events
411         for (int i = 0; i < events; ++i)
412             d->processInputEvent(&buffer[i]);
413 
414         // and try to get more
415     }
416 #else
417     int n = 0;
418     for (; ;) {
419         events = QT_READ(m_fd, reinterpret_cast<char*>(buffer) + n, sizeof(buffer) - n);
420         if (events <= 0)
421             goto err;
422         n += events;
423         if (n % sizeof(::input_event) == 0)
424             break;
425     }
426 
427     n /= sizeof(::input_event);
428 
429     for (int i = 0; i < n; ++i)
430         d->processInputEvent(&buffer[i]);
431 #endif
432     return;
433 
434 err:
435     if (!events) {
436         qWarning("evdevtouch: Got EOF from input device");
437         return;
438     } else if (events < 0) {
439         if (errno != EINTR && errno != EAGAIN) {
440             qErrnoWarning("evdevtouch: Could not read from input device");
441             if (errno == ENODEV) { // device got disconnected -> stop reading
442                 delete m_notify;
443                 m_notify = nullptr;
444 
445                 QT_CLOSE(m_fd);
446                 m_fd = -1;
447 
448                 unregisterPointingDevice();
449             }
450             return;
451         }
452     }
453 }
454 
455 void QEvdevTouchScreenHandler::registerPointingDevice()
456 {
457     if (m_device)
458         return;
459 
460     static int id = 1;
461     QPointingDevice::Capabilities caps = QPointingDevice::Capability::Position | QPointingDevice::Capability::Area;
462     if (d->hw_pressure_max > d->hw_pressure_min)
463         caps.setFlag(QPointingDevice::Capability::Pressure);
464 
465     // TODO get evdev ID instead of an incremeting number; set USB ID too
466     m_device = new QPointingDevice(d->hw_name, id++,
467                                    QInputDevice::DeviceType::TouchScreen, QPointingDevice::PointerType::Finger,
468                                    caps, 16, 0);
469 
470     auto geom = d->screenGeometry();
471     if (!geom.isNull())
472         QPointingDevicePrivate::get(m_device)->setAvailableVirtualGeometry(geom);
473 
474     QWindowSystemInterface::registerInputDevice(m_device);
475 }
476 
477 void QEvdevTouchScreenHandler::unregisterPointingDevice()
478 {
479     if (QGuiApplication::instance()) {
480         m_device->deleteLater();
481     } else {
482         delete m_device;
483     }
484     m_device = nullptr;
485 }
486 
487 void QEvdevTouchScreenData::addTouchPoint(const Contact &contact, QEventPoint::States *combinedStates)
488 {
489     QWindowSystemInterface::TouchPoint tp;
490     tp.id = contact.trackingId;
491     tp.state = contact.state;
492     *combinedStates |= tp.state;
493 
494     // Store the HW coordinates for now, will be updated later.
495     tp.area = QRectF(0, 0, contact.maj, contact.maj);
496     tp.area.moveCenter(QPoint(contact.x, contact.y));
497     tp.pressure = contact.pressure;
498 
499     // Get a normalized position in range 0..1.
500     tp.normalPosition = QPointF((contact.x - hw_range_x_min) / qreal(hw_range_x_max - hw_range_x_min),
501                                 (contact.y - hw_range_y_min) / qreal(hw_range_y_max - hw_range_y_min));
502 
503     if (!m_rotate.isIdentity())
504         tp.normalPosition = m_rotate.map(tp.normalPosition);
505 
506     tp.rawPositions.append(QPointF(contact.x, contact.y));
507 
508     m_touchPoints.append(tp);
509 }
510 
511 void QEvdevTouchScreenData::processInputEvent(input_event *data)
512 {
513     if (data->type == EV_ABS) {
514 
515         if (data->code == ABS_MT_POSITION_X || (m_singleTouch && data->code == ABS_X)) {
516             m_currentData.x = qBound(hw_range_x_min, data->value, hw_range_x_max);
517             if (m_singleTouch)
518                 m_contacts[m_currentSlot].x = m_currentData.x;
519             if (m_typeB) {
520                 m_contacts[m_currentSlot].x = m_currentData.x;
521                 if (m_contacts[m_currentSlot].state == QEventPoint::State::Stationary)
522                     m_contacts[m_currentSlot].state = QEventPoint::State::Updated;
523             }
524         } else if (data->code == ABS_MT_POSITION_Y || (m_singleTouch && data->code == ABS_Y)) {
525             m_currentData.y = qBound(hw_range_y_min, data->value, hw_range_y_max);
526             if (m_singleTouch)
527                 m_contacts[m_currentSlot].y = m_currentData.y;
528             if (m_typeB) {
529                 m_contacts[m_currentSlot].y = m_currentData.y;
530                 if (m_contacts[m_currentSlot].state == QEventPoint::State::Stationary)
531                     m_contacts[m_currentSlot].state = QEventPoint::State::Updated;
532             }
533         } else if (data->code == ABS_MT_TRACKING_ID) {
534             m_currentData.trackingId = data->value;
535             if (m_typeB) {
536                 if (m_currentData.trackingId == -1) {
537                     m_contacts[m_currentSlot].state = QEventPoint::State::Released;
538                 } else {
539                     m_contacts[m_currentSlot].state = QEventPoint::State::Pressed;
540                     m_contacts[m_currentSlot].trackingId = m_currentData.trackingId;
541                 }
542             }
543         } else if (data->code == ABS_MT_TOUCH_MAJOR) {
544             m_currentData.maj = data->value;
545             if (data->value == 0)
546                 m_currentData.state = QEventPoint::State::Released;
547             if (m_typeB)
548                 m_contacts[m_currentSlot].maj = m_currentData.maj;
549         } else if (data->code == ABS_PRESSURE || data->code == ABS_MT_PRESSURE) {
550             if (Q_UNLIKELY(qLcEvents().isDebugEnabled()))
551                 qCDebug(qLcEvents, "EV_ABS code 0x%x: pressure %d; bounding to [%d,%d]",
552                         data->code, data->value, hw_pressure_min, hw_pressure_max);
553             m_currentData.pressure = qBound(hw_pressure_min, data->value, hw_pressure_max);
554             if (m_typeB || m_singleTouch)
555                 m_contacts[m_currentSlot].pressure = m_currentData.pressure;
556         } else if (data->code == ABS_MT_SLOT) {
557             m_currentSlot = data->value;
558         }
559 
560     } else if (data->type == EV_KEY && !m_typeB) {
561         if (data->code == BTN_TOUCH && data->value == 0)
562             m_contacts[m_currentSlot].state = QEventPoint::State::Released;
563     } else if (data->type == EV_SYN && data->code == SYN_MT_REPORT && m_lastEventType != EV_SYN) {
564 
565         // If there is no tracking id, one will be generated later.
566         // Until that use a temporary key.
567         int key = m_currentData.trackingId;
568         if (key == -1)
569             key = m_contacts.count();
570 
571         m_contacts.insert(key, m_currentData);
572         m_currentData = Contact();
573 
574     } else if (data->type == EV_SYN && data->code == SYN_REPORT) {
575 
576         // Ensure valid IDs even when the driver does not report ABS_MT_TRACKING_ID.
577         if (!m_contacts.isEmpty() && m_contacts.constBegin().value().trackingId == -1)
578             assignIds();
579 
580         std::unique_lock<QMutex> locker;
581         if (m_filtered)
582             locker = std::unique_lock<QMutex>{m_mutex};
583 
584         // update timestamps
585         m_lastTimeStamp = m_timeStamp;
586         m_timeStamp = data->input_event_sec + data->input_event_usec / 1000000.0;
587 
588         m_lastTouchPoints = m_touchPoints;
589         m_touchPoints.clear();
590         QEventPoint::States combinedStates;
591         bool hasPressure = false;
592 
593         for (auto it = m_contacts.begin(), end = m_contacts.end(); it != end; /*erasing*/) {
594             Contact &contact(it.value());
595 
596             if (!contact.state) {
597                 ++it;
598                 continue;
599             }
600 
601             int key = m_typeB ? it.key() : contact.trackingId;
602             if (!m_typeB && m_lastContacts.contains(key)) {
603                 const Contact &prev(m_lastContacts.value(key));
604                 if (contact.state == QEventPoint::State::Released) {
605                     // Copy over the previous values for released points, just in case.
606                     contact.x = prev.x;
607                     contact.y = prev.y;
608                     contact.maj = prev.maj;
609                 } else {
610                     contact.state = (prev.x == contact.x && prev.y == contact.y)
611                             ? QEventPoint::State::Stationary : QEventPoint::State::Updated;
612                 }
613             }
614 
615             // Avoid reporting a contact in released state more than once.
616             if (!m_typeB && contact.state == QEventPoint::State::Released
617                     && !m_lastContacts.contains(key)) {
618                 it = m_contacts.erase(it);
619                 continue;
620             }
621 
622             if (contact.pressure)
623                 hasPressure = true;
624 
625             addTouchPoint(contact, &combinedStates);
626             ++it;
627         }
628 
629         // Now look for contacts that have disappeared since the last sync.
630         for (auto it = m_lastContacts.begin(), end = m_lastContacts.end(); it != end; ++it) {
631             Contact &contact(it.value());
632             int key = m_typeB ? it.key() : contact.trackingId;
633             if (m_typeB) {
634                 if (contact.trackingId != m_contacts[key].trackingId && contact.state) {
635                     contact.state = QEventPoint::State::Released;
636                     addTouchPoint(contact, &combinedStates);
637                 }
638             } else {
639                 if (!m_contacts.contains(key)) {
640                     contact.state = QEventPoint::State::Released;
641                     addTouchPoint(contact, &combinedStates);
642                 }
643             }
644         }
645 
646         // Remove contacts that have just been reported as released.
647         for (auto it = m_contacts.begin(), end = m_contacts.end(); it != end; /*erasing*/) {
648             Contact &contact(it.value());
649 
650             if (!contact.state) {
651                 ++it;
652                 continue;
653             }
654 
655             if (contact.state == QEventPoint::State::Released) {
656                 if (m_typeB) {
657                     contact.state = QEventPoint::State::Unknown;
658                 } else {
659                     it = m_contacts.erase(it);
660                     continue;
661                 }
662             } else {
663                 contact.state = QEventPoint::State::Stationary;
664             }
665             ++it;
666         }
667 
668         m_lastContacts = m_contacts;
669         if (!m_typeB && !m_singleTouch)
670             m_contacts.clear();
671 
672 
673         if (!m_touchPoints.isEmpty() && (hasPressure || combinedStates != QEventPoint::State::Stationary))
674             reportPoints();
675     }
676 
677     m_lastEventType = data->type;
678 }
679 
680 int QEvdevTouchScreenData::findClosestContact(const QHash<int, Contact> &contacts, int x, int y, int *dist)
681 {
682     int minDist = -1, id = -1;
683     for (QHash<int, Contact>::const_iterator it = contacts.constBegin(), ite = contacts.constEnd();
684          it != ite; ++it) {
685         const Contact &contact(it.value());
686         int dx = x - contact.x;
687         int dy = y - contact.y;
688         int dist = dx * dx + dy * dy;
689         if (minDist == -1 || dist < minDist) {
690             minDist = dist;
691             id = contact.trackingId;
692         }
693     }
694     if (dist)
695         *dist = minDist;
696     return id;
697 }
698 
699 void QEvdevTouchScreenData::assignIds()
700 {
701     QHash<int, Contact> candidates = m_lastContacts, pending = m_contacts, newContacts;
702     int maxId = -1;
703     QHash<int, Contact>::iterator it, ite, bestMatch;
704     while (!pending.isEmpty() && !candidates.isEmpty()) {
705         int bestDist = -1, bestId = 0;
706         for (it = pending.begin(), ite = pending.end(); it != ite; ++it) {
707             int dist;
708             int id = findClosestContact(candidates, it->x, it->y, &dist);
709             if (id >= 0 && (bestDist == -1 || dist < bestDist)) {
710                 bestDist = dist;
711                 bestId = id;
712                 bestMatch = it;
713             }
714         }
715         if (bestDist >= 0) {
716             bestMatch->trackingId = bestId;
717             newContacts.insert(bestId, *bestMatch);
718             candidates.remove(bestId);
719             pending.erase(bestMatch);
720             if (bestId > maxId)
721                 maxId = bestId;
722         }
723     }
724     if (candidates.isEmpty()) {
725         for (it = pending.begin(), ite = pending.end(); it != ite; ++it) {
726             it->trackingId = ++maxId;
727             newContacts.insert(it->trackingId, *it);
728         }
729     }
730     m_contacts = newContacts;
731 }
732 
733 QRect QEvdevTouchScreenData::screenGeometry() const
734 {
735     if (m_forceToActiveWindow) {
736         QWindow *win = QGuiApplication::focusWindow();
737         return win ? QHighDpi::toNativeWindowGeometry(win->geometry(), win) : QRect();
738     }
739 
740     // Now it becomes tricky. Traditionally we picked the primaryScreen()
741     // and were done with it. But then, enter multiple screens, and
742     // suddenly it was all broken.
743     //
744     // For now we only support the display configuration of the KMS/DRM
745     // backends of eglfs. See QOutputMapping.
746     //
747     // The good news it that once winRect refers to the correct screen
748     // geometry in the full virtual desktop space, there is nothing else
749     // left to do since qguiapp will handle the rest.
750     QScreen *screen = QGuiApplication::primaryScreen();
751     if (!m_screenName.isEmpty()) {
752         if (!m_screen) {
753             const QList<QScreen *> screens = QGuiApplication::screens();
754             for (QScreen *s : screens) {
755                 if (s->name() == m_screenName) {
756                     m_screen = s;
757                     break;
758                 }
759             }
760         }
761         if (m_screen)
762             screen = m_screen;
763     }
764     return screen ? QHighDpi::toNativePixels(screen->geometry(), screen) : QRect();
765 }
766 
767 void QEvdevTouchScreenData::reportPoints()
768 {
769     QRect winRect = screenGeometry();
770     if (winRect.isNull())
771         return;
772 
773     const int hw_w = hw_range_x_max - hw_range_x_min;
774     const int hw_h = hw_range_y_max - hw_range_y_min;
775 
776     // Map the coordinates based on the normalized position. QPA expects 'area'
777     // to be in screen coordinates.
778     const int pointCount = m_touchPoints.count();
779     for (int i = 0; i < pointCount; ++i) {
780         QWindowSystemInterface::TouchPoint &tp(m_touchPoints[i]);
781 
782         // Generate a screen position that is always inside the active window
783         // or the primary screen.  Even though we report this as a QRectF, internally
784         // Qt uses QRect/QPoint so we need to bound the size to winRect.size() - QSize(1, 1)
785         const qreal wx = winRect.left() + tp.normalPosition.x() * (winRect.width() - 1);
786         const qreal wy = winRect.top() + tp.normalPosition.y() * (winRect.height() - 1);
787         const qreal sizeRatio = (winRect.width() + winRect.height()) / qreal(hw_w + hw_h);
788         if (tp.area.width() == -1) // touch major was not provided
789             tp.area = QRectF(0, 0, 8, 8);
790         else
791             tp.area = QRectF(0, 0, tp.area.width() * sizeRatio, tp.area.height() * sizeRatio);
792         tp.area.moveCenter(QPointF(wx, wy));
793 
794         // Calculate normalized pressure.
795         if (!hw_pressure_min && !hw_pressure_max)
796             tp.pressure = tp.state == QEventPoint::State::Released ? 0 : 1;
797         else
798             tp.pressure = (tp.pressure - hw_pressure_min) / qreal(hw_pressure_max - hw_pressure_min);
799 
800         if (Q_UNLIKELY(qLcEvents().isDebugEnabled()))
801             qCDebug(qLcEvents) << "reporting" << tp;
802     }
803 
804     // Let qguiapp pick the target window.
805     if (m_filtered)
806         emit q->touchPointsUpdated();
807     else
808         QWindowSystemInterface::handleTouchEvent(nullptr, q->touchDevice(), m_touchPoints);
809 }
810 
811 QEvdevTouchScreenHandlerThread::QEvdevTouchScreenHandlerThread(const QString &device, const QString &spec, QObject *parent)
812     : QDaemonThread(parent), m_device(device), m_spec(spec), m_handler(nullptr), m_touchDeviceRegistered(false)
813     , m_touchUpdatePending(false)
814     , m_filterWindow(nullptr)
815     , m_touchRate(-1)
816 {
817     start();
818 }
819 
820 QEvdevTouchScreenHandlerThread::~QEvdevTouchScreenHandlerThread()
821 {
822     quit();
823     wait();
824 }
825 
826 void QEvdevTouchScreenHandlerThread::run()
827 {
828     m_handler = new QEvdevTouchScreenHandler(m_device, m_spec);
829 
830     if (m_handler->isFiltered())
831         connect(m_handler, &QEvdevTouchScreenHandler::touchPointsUpdated, this, &QEvdevTouchScreenHandlerThread::scheduleTouchPointUpdate);
832 
833     // Report the registration to the parent thread by invoking the method asynchronously
834     QMetaObject::invokeMethod(this, "notifyTouchDeviceRegistered", Qt::QueuedConnection);
835 
836     exec();
837 
838     if (QGuiApplication::instance()) {
839         m_handler->moveToThread(QGuiApplication::instance()->thread());
840         m_handler->deleteLater();
841     } else {
842         delete m_handler;
843     }
844     m_handler = nullptr;
845 }
846 
847 bool QEvdevTouchScreenHandlerThread::isPointingDeviceRegistered() const
848 {
849     return m_touchDeviceRegistered;
850 }
851 
852 void QEvdevTouchScreenHandlerThread::notifyTouchDeviceRegistered()
853 {
854     m_touchDeviceRegistered = true;
855     emit touchDeviceRegistered();
856 }
857 
858 void QEvdevTouchScreenHandlerThread::scheduleTouchPointUpdate()
859 {
860     QWindow *window = QGuiApplication::focusWindow();
861     if (window != m_filterWindow) {
862         if (m_filterWindow)
863             m_filterWindow->removeEventFilter(this);
864         m_filterWindow = window;
865         if (m_filterWindow)
866             m_filterWindow->installEventFilter(this);
867     }
868     if (m_filterWindow) {
869         m_touchUpdatePending = true;
870         m_filterWindow->requestUpdate();
871     }
872 }
873 
874 bool QEvdevTouchScreenHandlerThread::eventFilter(QObject *object, QEvent *event)
875 {
876     if (m_touchUpdatePending && object == m_filterWindow && event->type() == QEvent::UpdateRequest) {
877         m_touchUpdatePending = false;
878         filterAndSendTouchPoints();
879     }
880     return false;
881 }
882 
883 void QEvdevTouchScreenHandlerThread::filterAndSendTouchPoints()
884 {
885     QRect winRect = m_handler->d->screenGeometry();
886     if (winRect.isNull())
887         return;
888 
889     float vsyncDelta = 1.0f / QGuiApplication::primaryScreen()->refreshRate();
890 
891     QHash<int, FilteredTouchPoint> filteredPoints;
892 
893     m_handler->d->m_mutex.lock();
894 
895     double time = m_handler->d->m_timeStamp;
896     double lastTime = m_handler->d->m_lastTimeStamp;
897     double touchDelta = time - lastTime;
898     if (m_touchRate < 0 || touchDelta > vsyncDelta) {
899         // We're at the very start, with nothing to go on, so make a guess
900         // that the touch rate will be somewhere in the range of half a vsync.
901         // This doesn't have to be accurate as we will calibrate it over time,
902         // but it gives us a better starting point so calibration will be
903         // slightly quicker. If, on the other hand, we already have an
904         // estimate, we'll leave it as is and keep it.
905         if (m_touchRate < 0)
906             m_touchRate = (1.0 / QGuiApplication::primaryScreen()->refreshRate()) / 2.0;
907 
908     } else {
909         // Update our estimate for the touch rate. We're making the assumption
910         // that this value will be mostly accurate with the occational bump,
911         // so we're weighting the existing value high compared to the update.
912         const double ratio = 0.9;
913         m_touchRate = sqrt(m_touchRate * m_touchRate * ratio + touchDelta * touchDelta * (1.0 - ratio));
914     }
915 
916     QList<QWindowSystemInterface::TouchPoint> points = m_handler->d->m_touchPoints;
917     QList<QWindowSystemInterface::TouchPoint> lastPoints = m_handler->d->m_lastTouchPoints;
918 
919     m_handler->d->m_mutex.unlock();
920 
921     for (int i=0; i<points.size(); ++i) {
922         QWindowSystemInterface::TouchPoint &tp = points[i];
923         QPointF pos = tp.normalPosition;
924         FilteredTouchPoint f;
925 
926         QWindowSystemInterface::TouchPoint ltp;
927         ltp.id = -1;
928         for (int j=0; j<lastPoints.size(); ++j) {
929             if (lastPoints.at(j).id == tp.id) {
930                 ltp = lastPoints.at(j);
931                 break;
932             }
933         }
934 
935         QPointF velocity;
936         if (lastTime != 0 && ltp.id >= 0)
937             velocity = (pos - ltp.normalPosition) / m_touchRate;
938         if (m_filteredPoints.contains(tp.id)) {
939             f = m_filteredPoints.take(tp.id);
940             f.x.update(pos.x(), velocity.x(), vsyncDelta);
941             f.y.update(pos.y(), velocity.y(), vsyncDelta);
942             pos = QPointF(f.x.position(), f.y.position());
943         } else {
944             f.x.initialize(pos.x(), velocity.x());
945             f.y.initialize(pos.y(), velocity.y());
946             // Make sure the first instance of a touch point we send has the
947             // 'pressed' state.
948             if (tp.state != QEventPoint::State::Pressed)
949                 tp.state = QEventPoint::State::Pressed;
950         }
951 
952         tp.velocity = QVector2D(f.x.velocity() * winRect.width(), f.y.velocity() * winRect.height());
953 
954         qreal filteredNormalizedX = f.x.position() + f.x.velocity() * m_handler->d->m_prediction / 1000.0;
955         qreal filteredNormalizedY = f.y.position() + f.y.velocity() * m_handler->d->m_prediction / 1000.0;
956 
957         // Clamp to the screen
958         tp.normalPosition = QPointF(qBound<qreal>(0, filteredNormalizedX, 1),
959                                     qBound<qreal>(0, filteredNormalizedY, 1));
960 
961         qreal x = winRect.x() + (tp.normalPosition.x() * (winRect.width() - 1));
962         qreal y = winRect.y() + (tp.normalPosition.y() * (winRect.height() - 1));
963 
964         tp.area.moveCenter(QPointF(x, y));
965 
966         // Store the touch point for later so we can release it if we've
967         // missed the actual release between our last update and this.
968         f.touchPoint = tp;
969 
970         // Don't store the point for future reference if it is a release.
971         if (tp.state != QEventPoint::State::Released)
972             filteredPoints[tp.id] = f;
973     }
974 
975     for (QHash<int, FilteredTouchPoint>::const_iterator it = m_filteredPoints.constBegin(), end = m_filteredPoints.constEnd(); it != end; ++it) {
976         const FilteredTouchPoint &f = it.value();
977         QWindowSystemInterface::TouchPoint tp = f.touchPoint;
978         tp.state = QEventPoint::State::Released;
979         tp.velocity = QVector2D();
980         points.append(tp);
981     }
982 
983     m_filteredPoints = filteredPoints;
984 
985     QWindowSystemInterface::handleTouchEvent(nullptr,
986                                              m_handler->touchDevice(),
987                                              points);
988 }
989 
990 
991 QT_END_NAMESPACE
