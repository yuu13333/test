Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2018 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 #include "qplatformdefs.h"
41 #include "qlibrary.h"
42 
43 #include "qfactoryloader_p.h"
44 #include "qlibrary_p.h"
45 #include <qstringlist.h>
46 #include <qfile.h>
47 #include <qfileinfo.h>
48 #include <qmutex.h>
49 #include <qmap.h>
50 #include <private/qcoreapplication_p.h>
51 #include <private/qsystemerror_p.h>
52 #ifdef Q_OS_MAC
53 #  include <private/qcore_mac_p.h>
54 #endif
55 #ifndef NO_ERRNO_H
56 #include <errno.h>
57 #endif // NO_ERROR_H
58 #include <qdebug.h>
59 #include <qvector.h>
60 #include <qdir.h>
61 #include <qendian.h>
62 #include <qjsondocument.h>
63 #include <qjsonvalue.h>
64 #include "qelfparser_p.h"
65 #include "qmachparser_p.h"
66 
67 #include <qtcore_tracepoints_p.h>
68 
69 QT_BEGIN_NAMESPACE
70 
71 #ifdef QT_NO_DEBUG
72 #  define QLIBRARY_AS_DEBUG false
73 #else
74 #  define QLIBRARY_AS_DEBUG true
75 #endif
76 
77 #if defined(Q_OS_UNIX) || (defined(Q_CC_MINGW) && !QT_CONFIG(debug_and_release))
78 // We don't use separate debug and release libs on UNIX, so we want
79 // to allow loading plugins, regardless of how they were built.
80 #  define QT_NO_DEBUG_PLUGIN_CHECK
81 #endif
82 
83 /*!
84     \class QLibrary
85     \inmodule QtCore
86     \reentrant
87     \brief The QLibrary class loads shared libraries at runtime.
88 
89 
90     \ingroup plugins
91 
92     An instance of a QLibrary object operates on a single shared
93     object file (which we call a "library", but is also known as a
94     "DLL"). A QLibrary provides access to the functionality in the
95     library in a platform independent way. You can either pass a file
96     name in the constructor, or set it explicitly with setFileName().
97     When loading the library, QLibrary searches in all the
98     system-specific library locations (e.g. \c LD_LIBRARY_PATH on
99     Unix), unless the file name has an absolute path.
100 
101     If the file name is an absolute path then an attempt is made to
102     load this path first. If the file cannot be found, QLibrary tries
103     the name with different platform-specific file prefixes, like
104     "lib" on Unix and Mac, and suffixes, like ".so" on Unix, ".dylib"
105     on the Mac, or ".dll" on Windows.
106 
107     If the file path is not absolute then QLibrary modifies the search
108     order to try the system-specific prefixes and suffixes first,
109     followed by the file path specified.
110 
111     This makes it possible to specify shared libraries that are only
112     identified by their basename (i.e. without their suffix), so the
113     same code will work on different operating systems yet still
114     minimise the number of attempts to find the library.
115 
116     The most important functions are load() to dynamically load the
117     library file, isLoaded() to check whether loading was successful,
118     and resolve() to resolve a symbol in the library. The resolve()
119     function implicitly tries to load the library if it has not been
120     loaded yet. Multiple instances of QLibrary can be used to access
121     the same physical library. Once loaded, libraries remain in memory
122     until the application terminates. You can attempt to unload a
123     library using unload(), but if other instances of QLibrary are
124     using the same library, the call will fail, and unloading will
125     only happen when every instance has called unload().
126 
127     A typical use of QLibrary is to resolve an exported symbol in a
128     library, and to call the C function that this symbol represents.
129     This is called "explicit linking" in contrast to "implicit
130     linking", which is done by the link step in the build process when
131     linking an executable against a library.
132 
133     The following code snippet loads a library, resolves the symbol
134     "mysymbol", and calls the function if everything succeeded. If
135     something goes wrong, e.g. the library file does not exist or the
136     symbol is not defined, the function pointer will be \nullptr and
137     won't be called.
138 
139     \snippet code/src_corelib_plugin_qlibrary.cpp 0
140 
141     The symbol must be exported as a C function from the library for
142     resolve() to work. This means that the function must be wrapped in
143     an \c{extern "C"} block if the library is compiled with a C++
144     compiler. On Windows, this also requires the use of a \c dllexport
145     macro; see resolve() for the details of how this is done. For
146     convenience, there is a static resolve() function which you can
147     use if you just want to call a function in a library without
148     explicitly loading the library first:
149 
150     \snippet code/src_corelib_plugin_qlibrary.cpp 1
151 
152     \sa QPluginLoader
153 */
154 
155 /*!
156     \enum QLibrary::LoadHint
157 
158     This enum describes the possible hints that can be used to change the way
159     libraries are handled when they are loaded. These values indicate how
160     symbols are resolved when libraries are loaded, and are specified using
161     the setLoadHints() function.
162 
163     \value ResolveAllSymbolsHint
164     Causes all symbols in a library to be resolved when it is loaded, not
165     simply when resolve() is called.
166     \value ExportExternalSymbolsHint
167     Exports unresolved and external symbols in the library so that they can be
168     resolved in other dynamically-loaded libraries loaded later.
169     \value LoadArchiveMemberHint
170     Allows the file name of the library to specify a particular object file
171     within an archive file.
172     If this hint is given, the filename of the library consists of
173     a path, which is a reference to an archive file, followed by
174     a reference to the archive member.
175     \value PreventUnloadHint
176     Prevents the library from being unloaded from the address space if close()
177     is called. The library's static variables are not reinitialized if open()
178     is called at a later time.
179     \value DeepBindHint
180     Instructs the linker to prefer definitions in the loaded library
181     over exported definitions in the loading application when resolving
182     external symbols in the loaded library. This option is only supported
183     on Linux.
184 
185     \sa loadHints
186 */
187 
188 
189 static qsizetype qt_find_pattern(const char *s, qsizetype s_len,
190                              const char *pattern, ulong p_len)
191 {
192     /*
193       we search from the end of the file because on the supported
194       systems, the read-only data/text segments are placed at the end
195       of the file.  HOWEVER, when building with debugging enabled, all
196       the debug symbols are placed AFTER the data/text segments.
197 
198       what does this mean?  when building in release mode, the search
199       is fast because the data we are looking for is at the end of the
200       file... when building in debug mode, the search is slower
201       because we have to skip over all the debugging symbols first
202     */
203 
204     if (!s || !pattern || qsizetype(p_len) > s_len)
205         return -1;
206 
207     size_t i, hs = 0, hp = 0, delta = s_len - p_len;
208 
209     for (i = 0; i < p_len; ++i) {
210         hs += s[delta + i];
211         hp += pattern[i];
212     }
213     i = delta;
214     for (;;) {
215         if (hs == hp && qstrncmp(s + i, pattern, p_len) == 0)
216             return i;   // can't overflow, by construction
217         if (i == 0)
218             break;
219         --i;
220         hs -= s[i + p_len];
221         hs += s[i];
222     }
223 
224     return -1;
225 }
226 
227 /*
228   This opens the specified library, mmaps it into memory, and searches
229   for the QT_PLUGIN_VERIFICATION_DATA.  The advantage of this approach is that
230   we can get the verification data without have to actually load the library.
231   This lets us detect mismatches more safely.
232 
233   Returns \c false if version information is not present, or if the
234                 information could not be read.
235   Returns  true if version information is present and successfully read.
236 */
237 static bool findPatternUnloaded(const QString &library, QLibraryPrivate *lib)
238 {
239     QFile file(library);
240     if (!file.open(QIODevice::ReadOnly)) {
241         if (lib)
242             lib->errorString = file.errorString();
243         if (qt_debug_component()) {
244             qWarning("%s: %ls", QFile::encodeName(library).constData(),
245                      qUtf16Printable(QSystemError::stdString()));
246         }
247         return false;
248     }
249 
250     // Files can be bigger than the virtual memory size on 32-bit systems, so
251     // we limit to 512 MB there. For 64-bit, we allow up to 2^40 bytes.
252     constexpr qint64 MaxMemoryMapSize =
253             Q_INT64_C(1) << (sizeof(qsizetype) > 4 ? 40 : 29);
254 
255     QByteArray data;
256     qsizetype fdlen = qMin(file.size(), MaxMemoryMapSize);
257     const char *filedata = reinterpret_cast<char *>(file.map(0, fdlen));
258 
259     if (filedata == 0) {
260         // Try reading the data into memory instead (up to 64 MB).
261         data = file.read(64 * 1024 * 1024);
262         filedata = data.constData();
263         fdlen = data.size();
264     }
265 
266     /*
267        ELF and Mach-O binaries with GCC have .qplugin sections.
268     */
269     bool hasMetaData = false;
270     qsizetype pos = 0;
271     char pattern[] = "qTMETADATA ";
272     pattern[0] = 'Q'; // Ensure the pattern "QTMETADATA" is not found in this library should QPluginLoader ever encounter it.
273     const ulong plen = qstrlen(pattern);
274 #if defined (Q_OF_ELF) && defined(Q_CC_GNU)
275     int r = QElfParser().parse(filedata, fdlen, library, lib, &pos, &fdlen);
276     if (r == QElfParser::Corrupt || r == QElfParser::NotElf) {
277             if (lib && qt_debug_component()) {
278                 qWarning("QElfParser: %ls", qUtf16Printable(lib->errorString));
279             }
280             return false;
281     } else if (r == QElfParser::QtMetaDataSection) {
282         qsizetype rel = qt_find_pattern(filedata + pos, fdlen, pattern, plen);
283         if (rel < 0)
284             pos = -1;
285         else
286             pos += rel;
287         hasMetaData = true;
288     }
289 #elif defined (Q_OF_MACH_O)
290     {
291         QString errorString;
292         int r = QMachOParser::parse(filedata, fdlen, library, &errorString, &pos, &fdlen);
293         if (r == QMachOParser::NotSuitable) {
294             if (qt_debug_component())
295                 qWarning("QMachOParser: %ls", qUtf16Printable(errorString));
296             if (lib)
297                 lib->errorString = errorString;
298             return false;
299         }
300         // even if the metadata section was not found, the Mach-O parser will
301         // at least return the boundaries of the right architecture
302         qsizetype rel = qt_find_pattern(filedata + pos, fdlen, pattern, plen);
303         if (rel < 0)
304             pos = -1;
305         else
306             pos += rel;
307         hasMetaData = true;
308     }
309 #else
310     pos = qt_find_pattern(filedata, fdlen, pattern, plen);
311     if (pos > 0)
312         hasMetaData = true;
313 #endif // defined(Q_OF_ELF) && defined(Q_CC_GNU)
314 
315     bool ret = false;
316 
317     if (pos >= 0 && hasMetaData) {
318         const char *data = filedata + pos;
319         QString errMsg;
320         QJsonDocument doc = qJsonFromRawLibraryMetaData(data, fdlen, &errMsg);
321         if (doc.isNull()) {
322             qWarning("Found invalid metadata in lib %ls: %ls",
323                      qUtf16Printable(library), qUtf16Printable(errMsg));
324         } else {
325             lib->metaData = doc.object();
326             if (qt_debug_component())
327                 qWarning("Found metadata in lib %s, metadata=\n%s\n",
328                          library.toLocal8Bit().constData(), doc.toJson().constData());
329             ret = !doc.isNull();
330         }
331     }
332 
333     if (!ret && lib)
334         lib->errorString = QLibrary::tr("Failed to extract plugin meta data from '%1'").arg(library);
335     file.close();
336     return ret;
337 }
338 
339 static void installCoverageTool(QLibraryPrivate *libPrivate)
340 {
341 #ifdef __COVERAGESCANNER__
342     /*
343       __COVERAGESCANNER__ is defined when Qt has been instrumented for code
344       coverage by TestCocoon. CoverageScanner is the name of the tool that
345       generates the code instrumentation.
346       This code is required here when code coverage analysis with TestCocoon
347       is enabled in order to allow the loading application to register the plugin
348       and then store its execution report. The execution report gathers information
349       about each part of the plugin's code that has been used when
350       the plugin was loaded by the launching application.
351       The execution report for the plugin will go to the same execution report
352       as the one defined for the application loading it.
353     */
354 
355     int ret = __coveragescanner_register_library(libPrivate->fileName.toLocal8Bit());
356 
357     if (qt_debug_component()) {
358         if (ret >= 0) {
359             qDebug("coverage data for %ls registered",
360                    qUtf16Printable(libPrivate->fileName));
361         } else {
362             qWarning("could not register %ls: error %d; coverage data may be incomplete",
363                      qUtf16Printable(libPrivate->fileName),
364                      ret);
365         }
366     }
367 #else
368     Q_UNUSED(libPrivate);
369 #endif
370 }
371 
372 class QLibraryStore
373 {
374 public:
375     inline ~QLibraryStore();
376     static inline QLibraryPrivate *findOrCreate(const QString &fileName, const QString &version, QLibrary::LoadHints loadHints);
377     static inline void releaseLibrary(QLibraryPrivate *lib);
378 
379     static inline void cleanup();
380 
381 private:
382     static inline QLibraryStore *instance();
383 
384     // all members and instance() are protected by qt_library_mutex
385     typedef QMap<QString, QLibraryPrivate*> LibraryMap;
386     LibraryMap libraryMap;
387 };
388 
389 static QBasicMutex qt_library_mutex;
390 static QLibraryStore *qt_library_data = 0;
391 static bool qt_library_data_once;
392 
393 QLibraryStore::~QLibraryStore()
394 {
395     qt_library_data = 0;
396 }
397 
398 inline void QLibraryStore::cleanup()
399 {
400     QLibraryStore *data = qt_library_data;
401     if (!data)
402         return;
403 
404     // find any libraries that are still loaded but have a no one attached to them
405     LibraryMap::Iterator it = data->libraryMap.begin();
406     for (; it != data->libraryMap.end(); ++it) {
407         QLibraryPrivate *lib = it.value();
408         if (lib->libraryRefCount.loadRelaxed() == 1) {
409             if (lib->libraryUnloadCount.loadRelaxed() > 0) {
410                 Q_ASSERT(lib->pHnd.loadRelaxed());
411                 lib->libraryUnloadCount.storeRelaxed(1);
412 #ifdef __GLIBC__
413                 // glibc has a bug in unloading from global destructors
414                 // see https://bugzilla.novell.com/show_bug.cgi?id=622977
415                 // and http://sourceware.org/bugzilla/show_bug.cgi?id=11941
416                 lib->unload(QLibraryPrivate::NoUnloadSys);
417 #else
418                 lib->unload();
419 #endif
420             }
421             delete lib;
422             it.value() = 0;
423         }
424     }
425 
426     if (qt_debug_component()) {
427         // dump all objects that remain
428         for (QLibraryPrivate *lib : qAsConst(data->libraryMap)) {
429             if (lib)
430                 qDebug() << "On QtCore unload," << lib->fileName << "was leaked, with"
431                          << lib->libraryRefCount.loadRelaxed() << "users";
432         }
433     }
434 
435     delete data;
436 }
437 
438 static void qlibraryCleanup()
439 {
440     QLibraryStore::cleanup();
441 }
442 Q_DESTRUCTOR_FUNCTION(qlibraryCleanup)
443 
444 // must be called with a locked mutex
445 QLibraryStore *QLibraryStore::instance()
446 {
447     if (Q_UNLIKELY(!qt_library_data_once && !qt_library_data)) {
448         // only create once per process lifetime
449         qt_library_data = new QLibraryStore;
450         qt_library_data_once = true;
451     }
452     return qt_library_data;
453 }
454 
455 inline QLibraryPrivate *QLibraryStore::findOrCreate(const QString &fileName, const QString &version,
456                                                     QLibrary::LoadHints loadHints)
457 {
458     QMutexLocker locker(&qt_library_mutex);
459     QLibraryStore *data = instance();
460 
461     // check if this library is already loaded
462     QLibraryPrivate *lib = 0;
463     if (Q_LIKELY(data)) {
464         lib = data->libraryMap.value(fileName);
465         if (lib)
466             lib->mergeLoadHints(loadHints);
467     }
468     if (!lib)
469         lib = new QLibraryPrivate(fileName, version, loadHints);
470 
471     // track this library
472     if (Q_LIKELY(data) && !fileName.isEmpty())
473         data->libraryMap.insert(fileName, lib);
474 
475     lib->libraryRefCount.ref();
476     return lib;
477 }
478 
479 inline void QLibraryStore::releaseLibrary(QLibraryPrivate *lib)
480 {
481     QMutexLocker locker(&qt_library_mutex);
482     QLibraryStore *data = instance();
483 
484     if (lib->libraryRefCount.deref()) {
485         // still in use
486         return;
487     }
488 
489     // no one else is using
490     Q_ASSERT(lib->libraryUnloadCount.loadRelaxed() == 0);
491 
492     if (Q_LIKELY(data) && !lib->fileName.isEmpty()) {
493         QLibraryPrivate *that = data->libraryMap.take(lib->fileName);
494         Q_ASSERT(lib == that);
495         Q_UNUSED(that);
496     }
497     delete lib;
498 }
499 
500 QLibraryPrivate::QLibraryPrivate(const QString &canonicalFileName, const QString &version, QLibrary::LoadHints loadHints)
501     : fileName(canonicalFileName), fullVersion(version), pluginState(MightBeAPlugin)
502 {
503     loadHintsInt.storeRelaxed(loadHints);
504     if (canonicalFileName.isEmpty())
505         errorString = QLibrary::tr("The shared library was not found.");
506 }
507 
508 QLibraryPrivate *QLibraryPrivate::findOrCreate(const QString &fileName, const QString &version,
509                                                QLibrary::LoadHints loadHints)
510 {
511     return QLibraryStore::findOrCreate(fileName, version, loadHints);
512 }
513 
514 QLibraryPrivate::~QLibraryPrivate()
515 {
516 }
517 
518 void QLibraryPrivate::mergeLoadHints(QLibrary::LoadHints lh)
519 {
520     // if the library is already loaded, we can't change the load hints
521     if (pHnd.loadRelaxed())
522         return;
523 
524     loadHintsInt.storeRelaxed(lh);
525 }
526 
527 QFunctionPointer QLibraryPrivate::resolve(const char *symbol)
528 {
529     if (!pHnd.loadRelaxed())
530         return 0;
531     return resolve_sys(symbol);
532 }
533 
534 void QLibraryPrivate::setLoadHints(QLibrary::LoadHints lh)
535 {
536     // this locks a global mutex
537     QMutexLocker lock(&qt_library_mutex);
538     mergeLoadHints(lh);
539 }
540 
541 QObject *QLibraryPrivate::pluginInstance()
542 {
543     // first, check if the instance is cached and hasn't been deleted
544     QObject *obj = (QMutexLocker(&mutex), inst.data());
545     if (obj)
546         return obj;
547 
548     // we need to call the plugin's factory functio. Is that cached?
549     // skip increasing the reference count (why? -Thiago)
550     QtPluginInstanceFunction factory = instanceFactory.loadAcquire();
551     if (!factory)
552         factory = loadPlugin();
553 
554     if (!factory)
555         return nullptr;
556 
557     obj = factory();
558 
559     // cache again
560     QMutexLocker locker(&mutex);
561     if (inst)
562         obj = inst;
563     else
564         inst = obj;
565     return obj;
566 }
567 
568 bool QLibraryPrivate::load()
569 {
570     if (pHnd.loadRelaxed()) {
571         libraryUnloadCount.ref();
572         return true;
573     }
574     if (fileName.isEmpty())
575         return false;
576 
577     Q_TRACE(QLibraryPrivate_load_entry, fileName);
578 
579     mutex.lock();
580     bool ret = load_sys();
581     mutex.unlock();
582     if (qt_debug_component()) {
583         if (ret) {
584             qDebug() << "loaded library" << fileName;
585         } else {
586             qDebug() << qUtf8Printable(errorString);
587         }
588     }
589     if (ret) {
590         //when loading a library we add a reference to it so that the QLibraryPrivate won't get deleted
591         //this allows to unload the library at a later time
592         libraryUnloadCount.ref();
593         libraryRefCount.ref();
594         installCoverageTool(this);
595     }
596 
597     Q_TRACE(QLibraryPrivate_load_exit, ret);
598 
599     return ret;
600 }
601 
602 bool QLibraryPrivate::unload(UnloadFlag flag)
603 {
604     if (!pHnd.loadRelaxed())
605         return false;
606     if (libraryUnloadCount.loadRelaxed() > 0 && !libraryUnloadCount.deref()) { // only unload if ALL QLibrary instance wanted to
607         // locking the mutex not necessary because we're the last instance
608         delete inst.data();
609         if (flag == NoUnloadSys || unload_sys()) {
610             if (qt_debug_component())
611                 qWarning() << "QLibraryPrivate::unload succeeded on" << fileName
612                            << (flag == NoUnloadSys ? "(faked)" : "");
613             //when the library is unloaded, we release the reference on it so that 'this'
614             //can get deleted
615             libraryRefCount.deref();
616             pHnd.storeRelaxed(nullptr);
617             instanceFactory.storeRelaxed(nullptr);
618             return true;
619         }
620     }
621 
622     return false;
623 }
624 
625 void QLibraryPrivate::release()
626 {
627     QLibraryStore::releaseLibrary(this);
628 }
629 
630 QtPluginInstanceFunction QLibraryPrivate::loadPlugin()
631 {
632     if (auto ptr = instanceFactory.loadAcquire()) {
633         libraryUnloadCount.ref();
634         return ptr;
635     }
636     if (pluginState == IsNotAPlugin)
637         return nullptr;
638     if (load()) {
639         auto ptr = reinterpret_cast<QtPluginInstanceFunction>(resolve("qt_plugin_instance"));
640         instanceFactory.storeRelease(ptr); // two threads may store the same value
641         return ptr;
642     }
643     if (qt_debug_component())
644         qWarning() << "QLibraryPrivate::loadPlugin failed on" << fileName << ":" << errorString;
645     pluginState = IsNotAPlugin;
646     return nullptr;
647 }
648 
649 /*!
650     Returns \c true if \a fileName has a valid suffix for a loadable
651     library; otherwise returns \c false.
652 
653     \table
654     \header \li Platform \li Valid suffixes
655     \row \li Windows     \li \c .dll, \c .DLL
656     \row \li Unix/Linux  \li \c .so
657     \row \li AIX  \li \c .a
658     \row \li HP-UX       \li \c .sl, \c .so (HP-UXi)
659     \row \li \macos and iOS   \li \c .dylib, \c .bundle, \c .so
660     \endtable
661 
662     Trailing versioning numbers on Unix are ignored.
663  */
664 bool QLibrary::isLibrary(const QString &fileName)
665 {
666 #if defined(Q_OS_WIN)
667     return fileName.endsWith(QLatin1String(".dll"), Qt::CaseInsensitive);
668 #else // Generic Unix
669     QString completeSuffix = QFileInfo(fileName).completeSuffix();
670     if (completeSuffix.isEmpty())
671         return false;
672     const QVector<QStringRef> suffixes = completeSuffix.splitRef(QLatin1Char('.'));
673     QStringList validSuffixList;
674 
675 # if defined(Q_OS_HPUX)
676 /*
677     See "HP-UX Linker and Libraries User's Guide", section "Link-time Differences between PA-RISC and IPF":
678     "In PA-RISC (PA-32 and PA-64) shared libraries are suffixed with .sl. In IPF (32-bit and 64-bit),
679     the shared libraries are suffixed with .so. For compatibility, the IPF linker also supports the .sl suffix."
680  */
681     validSuffixList << QLatin1String("sl");
682 #  if defined __ia64
683     validSuffixList << QLatin1String("so");
684 #  endif
685 # elif defined(Q_OS_AIX)
686     validSuffixList << QLatin1String("a") << QLatin1String("so");
687 # elif defined(Q_OS_DARWIN)
688     // On Apple platforms, dylib look like libmylib.1.0.0.dylib
689     if (suffixes.last() == QLatin1String("dylib"))
690         return true;
691 
692     validSuffixList << QLatin1String("so") << QLatin1String("bundle");
693 # elif defined(Q_OS_UNIX)
694     validSuffixList << QLatin1String("so");
695 # endif
696 
697     // Examples of valid library names:
698     //  libfoo.so
699     //  libfoo.so.0
700     //  libfoo.so.0.3
701     //  libfoo-0.3.so
702     //  libfoo-0.3.so.0.3.0
703 
704     int suffix;
705     int suffixPos = -1;
706     for (suffix = 0; suffix < validSuffixList.count() && suffixPos == -1; ++suffix)
707         suffixPos = suffixes.indexOf(QStringRef(&validSuffixList.at(suffix)));
708 
709     bool valid = suffixPos != -1;
710     for (int i = suffixPos + 1; i < suffixes.count() && valid; ++i)
711         if (i != suffixPos)
712             suffixes.at(i).toInt(&valid);
713     return valid;
714 #endif
715 }
716 
717 static bool qt_get_metadata(QLibraryPrivate *priv, QString *errMsg)
718 {
719 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
720     auto getMetaData = [](QFunctionPointer fptr) {
721         auto f = reinterpret_cast<const char * (*)()>(fptr);
722         return qMakePair<const char *, size_t>(f(), INT_MAX);
723     };
724 #else
725     auto getMetaData = [](QFunctionPointer fptr) {
726         auto f = reinterpret_cast<QPair<const char *, size_t> (*)()>(fptr);
727         return f();
728     };
729 #endif
730 
731     QFunctionPointer pfn = priv->resolve("qt_plugin_query_metadata");
732     if (!pfn)
733         return false;
734 
735     auto metaData = getMetaData(pfn);
736     QJsonDocument doc = qJsonFromRawLibraryMetaData(metaData.first, metaData.second, errMsg);
737     if (doc.isNull())
738         return false;
739     priv->metaData = doc.object();
740     return true;
741 }
742 
743 bool QLibraryPrivate::isPlugin()
744 {
745     if (pluginState == MightBeAPlugin)
746         updatePluginState();
747 
748     return pluginState == IsAPlugin;
749 }
750 
751 void QLibraryPrivate::updatePluginState()
752 {
753     QMutexLocker locker(&mutex);
754     errorString.clear();
755     if (pluginState != MightBeAPlugin)
756         return;
757 
758     bool success = false;
759 
760 #if defined(Q_OS_UNIX) && !defined(Q_OS_MAC)
761     if (fileName.endsWith(QLatin1String(".debug"))) {
762         // refuse to load a file that ends in .debug
763         // these are the debug symbols from the libraries
764         // the problem is that they are valid shared library files
765         // and dlopen is known to crash while opening them
766 
767         // pretend we didn't see the file
768         errorString = QLibrary::tr("The shared library was not found.");
769         pluginState = IsNotAPlugin;
770         return;
771     }
772 #endif
773 
774     if (!pHnd.loadRelaxed()) {
775         // scan for the plugin metadata without loading
776         success = findPatternUnloaded(fileName, this);
777     } else {
778         // library is already loaded (probably via QLibrary)
779         // simply get the target function and call it.
780         success = qt_get_metadata(this, &errorString);
781     }
782 
783     if (!success) {
784         if (errorString.isEmpty()){
785             if (fileName.isEmpty())
786                 errorString = QLibrary::tr("The shared library was not found.");
787             else
788                 errorString = QLibrary::tr("The file '%1' is not a valid Qt plugin.").arg(fileName);
789         }
790         pluginState = IsNotAPlugin;
791         return;
792     }
793 
794     pluginState = IsNotAPlugin; // be pessimistic
795 
796     uint qt_version = (uint)metaData.value(QLatin1String("version")).toDouble();
797     bool debug = metaData.value(QLatin1String("debug")).toBool();
798     if ((qt_version & 0x00ff00) > (QT_VERSION & 0x00ff00) || (qt_version & 0xff0000) != (QT_VERSION & 0xff0000)) {
799         if (qt_debug_component()) {
800             qWarning("In %s:\n"
801                  "  Plugin uses incompatible Qt library (%d.%d.%d) [%s]",
802                  QFile::encodeName(fileName).constData(),
803                  (qt_version&0xff0000) >> 16, (qt_version&0xff00) >> 8, qt_version&0xff,
804                  debug ? "debug" : "release");
805         }
806         errorString = QLibrary::tr("The plugin '%1' uses incompatible Qt library. (%2.%3.%4) [%5]")
807             .arg(fileName)
808             .arg((qt_version&0xff0000) >> 16)
809             .arg((qt_version&0xff00) >> 8)
810             .arg(qt_version&0xff)
811             .arg(debug ? QLatin1String("debug") : QLatin1String("release"));
812 #ifndef QT_NO_DEBUG_PLUGIN_CHECK
813     } else if(debug != QLIBRARY_AS_DEBUG) {
814         //don't issue a qWarning since we will hopefully find a non-debug? --Sam
815         errorString = QLibrary::tr("The plugin '%1' uses incompatible Qt library."
816                  " (Cannot mix debug and release libraries.)").arg(fileName);
817 #endif
818     } else {
819         pluginState = IsAPlugin;
820     }
821 }
822 
823 /*!
824     Loads the library and returns \c true if the library was loaded
825     successfully; otherwise returns \c false. Since resolve() always
826     calls this function before resolving any symbols it is not
827     necessary to call it explicitly. In some situations you might want
828     the library loaded in advance, in which case you would use this
829     function.
830 
831     \sa unload()
832 */
833 bool QLibrary::load()
834 {
835     if (!d)
836         return false;
837     if (did_load)
838         return d->pHnd.loadRelaxed();
839     did_load = true;
840     return d->load();
841 }
842 
843 /*!
844     Unloads the library and returns \c true if the library could be
845     unloaded; otherwise returns \c false.
846 
847     This happens automatically on application termination, so you
848     shouldn't normally need to call this function.
849 
850     If other instances of QLibrary are using the same library, the
851     call will fail, and unloading will only happen when every instance
852     has called unload().
853 
854     Note that on Mac OS X 10.3 (Panther), dynamic libraries cannot be unloaded.
855 
856     \sa resolve(), load()
857 */
858 bool QLibrary::unload()
859 {
860     if (did_load) {
861         did_load = false;
862         return d->unload();
863     }
864     return false;
865 }
866 
867 /*!
868     Returns \c true if the library is loaded; otherwise returns \c false.
869 
870     \sa load()
871  */
872 bool QLibrary::isLoaded() const
873 {
874     return d && d->pHnd.loadRelaxed();
875 }
876 
877 
878 /*!
879     Constructs a library with the given \a parent.
880  */
881 QLibrary::QLibrary(QObject *parent)
882     :QObject(parent), d(0), did_load(false)
883 {
884 }
885 
886 
887 /*!
888     Constructs a library object with the given \a parent that will
889     load the library specified by \a fileName.
890 
891     We recommend omitting the file's suffix in \a fileName, since
892     QLibrary will automatically look for the file with the appropriate
893     suffix in accordance with the platform, e.g. ".so" on Unix,
894     ".dylib" on \macos and iOS, and ".dll" on Windows. (See \l{fileName}.)
895  */
896 QLibrary::QLibrary(const QString& fileName, QObject *parent)
897     :QObject(parent), d(0), did_load(false)
898 {
899     setFileName(fileName);
900 }
901 
902 
903 /*!
904     Constructs a library object with the given \a parent that will
905     load the library specified by \a fileName and major version number \a verNum.
906     Currently, the version number is ignored on Windows.
907 
908     We recommend omitting the file's suffix in \a fileName, since
909     QLibrary will automatically look for the file with the appropriate
910     suffix in accordance with the platform, e.g. ".so" on Unix,
911     ".dylib" on \macos and iOS, and ".dll" on Windows. (See \l{fileName}.)
912 */
913 QLibrary::QLibrary(const QString& fileName, int verNum, QObject *parent)
914     :QObject(parent), d(0), did_load(false)
915 {
916     setFileNameAndVersion(fileName, verNum);
917 }
918 
919 /*!
920     Constructs a library object with the given \a parent that will
921     load the library specified by \a fileName and full version number \a version.
922     Currently, the version number is ignored on Windows.
923 
924     We recommend omitting the file's suffix in \a fileName, since
925     QLibrary will automatically look for the file with the appropriate
926     suffix in accordance with the platform, e.g. ".so" on Unix,
927     ".dylib" on \macos and iOS, and ".dll" on Windows. (See \l{fileName}.)
928  */
929 QLibrary::QLibrary(const QString& fileName, const QString &version, QObject *parent)
930     :QObject(parent), d(0), did_load(false)
931 {
932     setFileNameAndVersion(fileName, version);
933 }
934 
935 /*!
936     Destroys the QLibrary object.
937 
938     Unless unload() was called explicitly, the library stays in memory
939     until the application terminates.
940 
941     \sa isLoaded(), unload()
942 */
943 QLibrary::~QLibrary()
944 {
945     if (d)
946         d->release();
947 }
948 
949 
950 /*!
951     \property QLibrary::fileName
952     \brief the file name of the library
953 
954     We recommend omitting the file's suffix in the file name, since
955     QLibrary will automatically look for the file with the appropriate
956     suffix (see isLibrary()).
957 
958     When loading the library, QLibrary searches in all system-specific
959     library locations (for example, \c LD_LIBRARY_PATH on Unix), unless the
960     file name has an absolute path. After loading the library
961     successfully, fileName() returns the fully-qualified file name of
962     the library, including the full path to the library if one was given
963     in the constructor or passed to setFileName().
964 
965     For example, after successfully loading the "GL" library on Unix
966     platforms, fileName() will return "libGL.so". If the file name was
967     originally passed as "/usr/lib/libGL", fileName() will return
968     "/usr/lib/libGL.so".
969 */
970 
971 void QLibrary::setFileName(const QString &fileName)
972 {
973     QLibrary::LoadHints lh;
974     if (d) {
975         lh = d->loadHints();
976         d->release();
977         d = 0;
978         did_load = false;
979     }
980     d = QLibraryPrivate::findOrCreate(fileName, QString(), lh);
981 }
982 
983 QString QLibrary::fileName() const
984 {
985     if (d) {
986         QMutexLocker locker(&d->mutex);
987         return d->qualifiedFileName.isEmpty() ? d->fileName : d->qualifiedFileName;
988     }
989     return QString();
990 }
991 
992 /*!
993     \fn void QLibrary::setFileNameAndVersion(const QString &fileName, int versionNumber)
994 
995     Sets the fileName property and major version number to \a fileName
996     and \a versionNumber respectively.
997     The \a versionNumber is ignored on Windows.
998 
999     \sa setFileName()
1000 */
1001 void QLibrary::setFileNameAndVersion(const QString &fileName, int verNum)
1002 {
1003     QLibrary::LoadHints lh;
1004     if (d) {
1005         lh = d->loadHints();
1006         d->release();
1007         d = 0;
1008         did_load = false;
1009     }
1010     d = QLibraryPrivate::findOrCreate(fileName, verNum >= 0 ? QString::number(verNum) : QString(), lh);
1011 }
1012 
1013 /*!
1014     \since 4.4
1015 
1016     Sets the fileName property and full version number to \a fileName
1017     and \a version respectively.
1018     The \a version parameter is ignored on Windows.
1019 
1020     \sa setFileName()
1021 */
1022 void QLibrary::setFileNameAndVersion(const QString &fileName, const QString &version)
1023 {
1024     QLibrary::LoadHints lh;
1025     if (d) {
1026         lh = d->loadHints();
1027         d->release();
1028         d = 0;
1029         did_load = false;
1030     }
1031     d = QLibraryPrivate::findOrCreate(fileName, version, lh);
1032 }
1033 
1034 /*!
1035     Returns the address of the exported symbol \a symbol. The library is
1036     loaded if necessary. The function returns \nullptr if the symbol could
1037     not be resolved or if the library could not be loaded.
1038 
1039     Example:
1040     \snippet code/src_corelib_plugin_qlibrary.cpp 2
1041 
1042     The symbol must be exported as a C function from the library. This
1043     means that the function must be wrapped in an \c{extern "C"} if
1044     the library is compiled with a C++ compiler. On Windows you must
1045     also explicitly export the function from the DLL using the
1046     \c{__declspec(dllexport)} compiler directive, for example:
1047 
1048     \snippet code/src_corelib_plugin_qlibrary.cpp 3
1049 
1050     with \c MY_EXPORT defined as
1051 
1052     \snippet code/src_corelib_plugin_qlibrary.cpp 4
1053 */
1054 QFunctionPointer QLibrary::resolve(const char *symbol)
1055 {
1056     if (!isLoaded() && !load())
1057         return 0;
1058     return d->resolve(symbol);
1059 }
1060 
1061 /*!
1062     \overload
1063 
1064     Loads the library \a fileName and returns the address of the
1065     exported symbol \a symbol. Note that \a fileName should not
1066     include the platform-specific file suffix; (see \l{fileName}). The
1067     library remains loaded until the application exits.
1068 
1069     The function returns \nullptr if the symbol could not be resolved or if
1070     the library could not be loaded.
1071 
1072     \sa resolve()
1073 */
1074 QFunctionPointer QLibrary::resolve(const QString &fileName, const char *symbol)
1075 {
1076     QLibrary library(fileName);
1077     return library.resolve(symbol);
1078 }
1079 
1080 /*!
1081     \overload
1082 
1083     Loads the library \a fileName with major version number \a verNum and
1084     returns the address of the exported symbol \a symbol.
1085     Note that \a fileName should not include the platform-specific file suffix;
1086     (see \l{fileName}). The library remains loaded until the application exits.
1087     \a verNum is ignored on Windows.
1088 
1089     The function returns \nullptr if the symbol could not be resolved or if
1090     the library could not be loaded.
1091 
1092     \sa resolve()
1093 */
1094 QFunctionPointer QLibrary::resolve(const QString &fileName, int verNum, const char *symbol)
1095 {
1096     QLibrary library(fileName, verNum);
1097     return library.resolve(symbol);
1098 }
1099 
1100 /*!
1101     \overload
1102     \since 4.4
1103 
1104     Loads the library \a fileName with full version number \a version and
1105     returns the address of the exported symbol \a symbol.
1106     Note that \a fileName should not include the platform-specific file suffix;
1107     (see \l{fileName}). The library remains loaded until the application exits.
1108     \a version is ignored on Windows.
1109 
1110     The function returns \nullptr if the symbol could not be resolved or if
1111     the library could not be loaded.
1112 
1113     \sa resolve()
1114 */
1115 QFunctionPointer QLibrary::resolve(const QString &fileName, const QString &version, const char *symbol)
1116 {
1117     QLibrary library(fileName, version);
1118     return library.resolve(symbol);
1119 }
1120 
1121 /*!
1122     \since 4.2
1123 
1124     Returns a text string with the description of the last error that occurred.
1125     Currently, errorString will only be set if load(), unload() or resolve() for some reason fails.
1126 */
1127 QString QLibrary::errorString() const
1128 {
1129     QString str;
1130     if (d) {
1131         QMutexLocker locker(&d->mutex);
1132         str = d->errorString;
1133     }
1134     return str.isEmpty() ? tr("Unknown error") : d->errorString;
1135 }
1136 
1137 /*!
1138     \property QLibrary::loadHints
1139     \brief Give the load() function some hints on how it should behave.
1140 
1141     You can give some hints on how the symbols are resolved. Usually,
1142     the symbols are not resolved at load time, but resolved lazily,
1143     (that is, when resolve() is called). If you set the loadHints to
1144     ResolveAllSymbolsHint, then all symbols will be resolved at load time
1145     if the platform supports it.
1146 
1147     Setting ExportExternalSymbolsHint will make the external symbols in the
1148     library available for resolution in subsequent loaded libraries.
1149 
1150     If LoadArchiveMemberHint is set, the file name
1151     is composed of two components: A path which is a reference to an
1152     archive file followed by the second component which is the reference to
1153     the archive member. For instance, the fileName \c libGL.a(shr_64.o) will refer
1154     to the library \c shr_64.o in the archive file named \c libGL.a. This
1155     is only supported on the AIX platform.
1156 
1157     The interpretation of the load hints is platform dependent, and if
1158     you use it you are probably making some assumptions on which platform
1159     you are compiling for, so use them only if you understand the consequences
1160     of them.
1161 
1162     By default, none of these flags are set, so libraries will be loaded with
1163     lazy symbol resolution, and will not export external symbols for resolution
1164     in other dynamically-loaded libraries.
1165 
1166     \note Setting this property after the library has been loaded has no effect
1167     and loadHints() will not reflect those changes.
1168 
1169     \note This property is shared among all QLibrary instances that refer to
1170     the same library.
1171 */
1172 void QLibrary::setLoadHints(LoadHints hints)
1173 {
1174     if (!d) {
1175         d = QLibraryPrivate::findOrCreate(QString());   // ugly, but we need a d-ptr
1176         d->errorString.clear();
1177     }
1178     d->setLoadHints(hints);
1179 }
1180 
1181 QLibrary::LoadHints QLibrary::loadHints() const
1182 {
1183     return d ? d->loadHints() : QLibrary::LoadHints();
1184 }
1185 
1186 /* Internal, for debugging */
1187 bool qt_debug_component()
1188 {
1189     static int debug_env = QT_PREPEND_NAMESPACE(qEnvironmentVariableIntValue)("QT_DEBUG_PLUGINS");
1190     return debug_env != 0;
1191 }
1192 
1193 QT_END_NAMESPACE
1194 
1195 #include "moc_qlibrary.cpp"
