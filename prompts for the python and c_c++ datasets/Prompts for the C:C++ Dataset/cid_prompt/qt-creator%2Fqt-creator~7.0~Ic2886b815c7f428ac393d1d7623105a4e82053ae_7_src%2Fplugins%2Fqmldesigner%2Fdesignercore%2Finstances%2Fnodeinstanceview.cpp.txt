Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "nodeinstanceview.h"
27 
28 #include "abstractproperty.h"
29 #include "bindingproperty.h"
30 #include "captureddatacommand.h"
31 #include "changeauxiliarycommand.h"
32 #include "changebindingscommand.h"
33 #include "changefileurlcommand.h"
34 #include "changeidscommand.h"
35 #include "changelanguagecommand.h"
36 #include "changenodesourcecommand.h"
37 #include "changepreviewimagesizecommand.h"
38 #include "changeselectioncommand.h"
39 #include "changestatecommand.h"
40 #include "changevaluescommand.h"
41 #include "childrenchangedcommand.h"
42 #include "clearscenecommand.h"
43 #include "completecomponentcommand.h"
44 #include "componentcompletedcommand.h"
45 #include "connectionmanagerinterface.h"
46 #include "createinstancescommand.h"
47 #include "createscenecommand.h"
48 #include "debugoutputcommand.h"
49 #include "informationchangedcommand.h"
50 #include "inputeventcommand.h"
51 #include "nodeabstractproperty.h"
52 #include "nodeinstanceserverproxy.h"
53 #include "nodelistproperty.h"
54 #include "nodeproperty.h"
55 #include "pixmapchangedcommand.h"
56 #include "puppettocreatorcommand.h"
57 #include "qml3dnode.h"
58 #include "qmlchangeset.h"
59 #include "qmldesignerconstants.h"
60 #include "qmlstate.h"
61 #include "qmltimeline.h"
62 #include "qmltimelinekeyframegroup.h"
63 #include "qmlvisualnode.h"
64 #include "removeinstancescommand.h"
65 #include "removepropertiescommand.h"
66 #include "removesharedmemorycommand.h"
67 #include "reparentinstancescommand.h"
68 #include "scenecreatedcommand.h"
69 #include "statepreviewimagechangedcommand.h"
70 #include "tokencommand.h"
71 #include "update3dviewstatecommand.h"
72 #include "valueschangedcommand.h"
73 #include "variantproperty.h"
74 #include "view3dactioncommand.h"
75 #include "requestmodelnodepreviewimagecommand.h"
76 #include "nanotracecommand.h"
77 #include "nanotrace/nanotrace.h"
78 
79 #include <designersettings.h>
80 #include <metainfo.h>
81 #include <model.h>
82 #include <modelnode.h>
83 #include <nodehints.h>
84 #include <rewriterview.h>
85 #include <qmlitemnode.h>
86 
87 #ifndef QMLDESIGNER_TEST
88 #include <qmldesignerplugin.h>
89 #include <coreplugin/actionmanager/actionmanager.h>
90 #include <coreplugin/editormanager/editormanager.h>
91 #include <coreplugin/documentmanager.h>
92 #include <hdrimage.h>
93 #endif
94 
95 #include <coreplugin/messagemanager.h>
96 
97 #include <projectexplorer/kit.h>
98 #include <projectexplorer/target.h>
99 
100 #include <qmlprojectmanager/qmlmultilanguageaspect.h>
101 
102 #include <utils/algorithm.h>
103 #include <utils/qtcassert.h>
104 #include <utils/qtcprocess.h>
105 
106 #include <qtsupport/qtkitinformation.h>
107 
108 #include <QUrl>
109 #include <QMultiHash>
110 #include <QTimerEvent>
111 #include <QPicture>
112 #include <QPainter>
113 #include <QDirIterator>
114 #include <QFileSystemWatcher>
115 #include <QScopedPointer>
116 
117 enum {
118     debug = false
119 };
120 
121 /*!
122 \defgroup CoreInstance
123 */
124 /*!
125 \class QmlDesigner::NodeInstanceView
126 \ingroup CoreInstance
127     \brief The NodeInstanceView class is the central class to create and manage
128     instances of the ModelNode class.
129 
130     This view is used to instantiate the model nodes. Many abstract views hold a
131     node instance view to get values from the node instances.
132     For this purpose, this view can be rendered offscreen.
133 
134     \sa NodeInstance, ModelNode
135 */
136 
137 namespace QmlDesigner {
138 
139 /*!
140   Constructs a node instance view object as a child of \a parent. If \a parent
141   is destructed, this instance is destructed, too.
142 
143   The class will be rendered offscreen if not set otherwise.
144 
145     \sa ~NodeInstanceView, setRenderOffScreen()
146 */
147 NodeInstanceView::NodeInstanceView(ConnectionManagerInterface &connectionManager)
148     : m_connectionManager(connectionManager)
149     , m_baseStatePreviewImage(QSize(100, 100), QImage::Format_ARGB32)
150     , m_restartProcessTimerId(0)
151     , m_fileSystemWatcher(new QFileSystemWatcher(this))
152 {
153     m_baseStatePreviewImage.fill(0xFFFFFF);
154 
155     // Interval > 0 is used for QFileSystemWatcher related timers to allow all notifications
156     // related to a single event to be received before we act.
157     m_resetTimer.setSingleShot(true);
158     m_resetTimer.setInterval(100);
159     QObject::connect(&m_resetTimer, &QTimer::timeout, [this] {
160         resetPuppet();
161     });
162     m_updateWatcherTimer.setSingleShot(true);
163     m_updateWatcherTimer.setInterval(100);
164     QObject::connect(&m_updateWatcherTimer, &QTimer::timeout, [this] {
165         for (const auto &path : qAsConst(m_pendingUpdateDirs))
166             updateWatcher(path);
167         m_pendingUpdateDirs.clear();
168     });
169 
170     // Since generating qsb files is asynchronous and can trigger directory changes, which in turn
171     // can trigger qsb generation, compressing qsb generation is necessary to avoid a lot of
172     // unnecessary generation when project with multiple shaders is opened.
173     m_generateQsbFilesTimer.setSingleShot(true);
174     m_generateQsbFilesTimer.setInterval(100);
175     QObject::connect(&m_generateQsbFilesTimer, &QTimer::timeout, [this] {
176         handleShaderChanges();
177 
178         if (m_qsbPath.isEmpty() || m_remainingQsbTargets <= 0)
179             m_resetTimer.start();
180     });
181 
182     connect(m_fileSystemWatcher, &QFileSystemWatcher::directoryChanged,
183             [this](const QString &path) {
184         const QSet<QString> pendingDirs = m_pendingUpdateDirs;
185         for (const auto &pendingPath : pendingDirs) {
186             if (path.startsWith(pendingPath)) {
187                 // no need to add path, already handled by a pending parent path
188                 return;
189             } else if (pendingPath.startsWith(path)) {
190                 // Parent path to a pending path added, remove the pending path
191                 m_pendingUpdateDirs.remove(pendingPath);
192             }
193         }
194         m_pendingUpdateDirs.insert(path);
195         m_updateWatcherTimer.start();
196 
197     });
198     connect(m_fileSystemWatcher, &QFileSystemWatcher::fileChanged, [this](const QString &path) {
199         m_pendingQsbTargets.insert(path);
200         m_generateQsbFilesTimer.start();
201     });
202 
203     m_rotBlockTimer.setSingleShot(true);
204     m_rotBlockTimer.setInterval(0);
205     QObject::connect(&m_rotBlockTimer, &QTimer::timeout, this, &NodeInstanceView::updateRotationBlocks);
206 }
207 
208 
209 /*!
210     Destructs a node instance view object.
211 */
212 NodeInstanceView::~NodeInstanceView()
213 {
214     removeAllInstanceNodeRelationships();
215     m_currentTarget = nullptr;
216 }
217 
218 //\{
219 
220 bool static isSkippedRootNode(const ModelNode &node)
221 {
222     static const PropertyNameList skipList({"Qt.ListModel", "QtQuick.ListModel", "Qt.ListModel", "QtQuick.ListModel"});
223 
224     if (skipList.contains(node.type()))
225         return true;
226 
227     return false;
228 }
229 
230 
231 bool static isSkippedNode(const ModelNode &node)
232 {
233     static const PropertyNameList skipList({"QtQuick.XmlRole", "Qt.XmlRole", "QtQuick.ListElement", "Qt.ListElement"});
234 
235     if (skipList.contains(node.type()))
236         return true;
237 
238     return false;
239 }
240 
241 bool static parentTakesOverRendering(const ModelNode &modelNode)
242 {
243     if (!modelNode.isValid())
244         return false;
245 
246     ModelNode currentNode = modelNode;
247 
248     while (currentNode.hasParentProperty()) {
249         currentNode = currentNode.parentProperty().parentModelNode();
250         if (NodeHints::fromModelNode(currentNode).takesOverRenderingOfChildren())
251             return true;
252     }
253 
254     return false;
255 }
256 
257 /*!
258     Notifies the view that it was attached to \a model. For every model node in
259     the model, a NodeInstance will be created.
260 */
261 
262 void NodeInstanceView::modelAttached(Model *model)
263 {
264     AbstractView::modelAttached(model);
265     m_nodeInstanceServer = createNodeInstanceServerProxy();
266     m_lastCrashTime.start();
267     m_connectionManager.setCrashCallback(m_crashCallback);
268 
269     if (!isSkippedRootNode(rootModelNode())) {
270         m_nodeInstanceServer->createScene(createCreateSceneCommand());
271         m_nodeInstanceServer->changeSelection(createChangeSelectionCommand(model->selectedNodes(this)));
272     }
273 
274     ModelNode stateNode = currentStateNode();
275     if (stateNode.isValid() && stateNode.metaInfo().isSubclassOf("QtQuick.State", 1, 0)) {
276         NodeInstance newStateInstance = instanceForModelNode(stateNode);
277         activateState(newStateInstance);
278     }
279 
280     updateWatcher({});
281 }
282 
283 void NodeInstanceView::modelAboutToBeDetached(Model * model)
284 {
285     m_connectionManager.setCrashCallback({});
286 
287     m_nodeInstanceCache.insert(model,
288                                NodeInstanceCacheData(m_nodeInstanceHash, m_statePreviewImage));
289 
290     removeAllInstanceNodeRelationships();
291     if (m_nodeInstanceServer) {
292         m_nodeInstanceServer->clearScene(createClearSceneCommand());
293         m_nodeInstanceServer.reset();
294     }
295     m_statePreviewImage.clear();
296     m_baseStatePreviewImage = QImage();
297     removeAllInstanceNodeRelationships();
298     m_activeStateInstance = NodeInstance();
299     m_rootNodeInstance = NodeInstance();
300     AbstractView::modelAboutToBeDetached(model);
301     m_resetTimer.stop();
302     m_updateWatcherTimer.stop();
303     m_pendingUpdateDirs.clear();
304     m_fileSystemWatcher->removePaths(m_fileSystemWatcher->directories());
305     m_fileSystemWatcher->removePaths(m_fileSystemWatcher->files());
306 }
307 
308 void NodeInstanceView::handleCrash()
309 {
310     qint64 elaspsedTimeSinceLastCrash = m_lastCrashTime.restart();
311     qint64 forceRestartTime = 2000;
312 #ifdef QT_DEBUG
313     forceRestartTime = 4000;
314 #endif
315     if (elaspsedTimeSinceLastCrash > forceRestartTime)
316         restartProcess();
317     else
318         emitDocumentMessage(
319             ::QmlDesigner::NodeInstanceView::tr("Qt Quick emulation layer crashed."));
320 
321     emitCustomNotification(QStringLiteral("puppet crashed"));
322 }
323 
324 void NodeInstanceView::startPuppetTransaction()
325 {
326     /* We assume no transaction is active. */
327     QTC_ASSERT(!m_puppetTransaction.isValid(), return);
328     m_puppetTransaction = beginRewriterTransaction("NodeInstanceView::PuppetTransaction");
329 }
330 
331 void NodeInstanceView::endPuppetTransaction()
332 {
333     /* We assume a transaction is active. */
334     QTC_ASSERT(m_puppetTransaction.isValid(), return);
335 
336     /* Committing a transaction should not throw, but if there is
337      * an issue with rewriting we should show an error message, instead
338      * of simply crashing.
339      */
340 
341     try {
342         m_puppetTransaction.commit();
343     } catch (Exception &e) {
344         e.showException();
345     }
346 }
347 
348 
349 void NodeInstanceView::clearErrors()
350 {
351     for (NodeInstance &instance : instances()) {
352         instance.setError({});
353     }
354 }
355 
356 void NodeInstanceView::restartProcess()
357 {
358     clearErrors();
359     emitInstanceErrorChange({});
360     emitDocumentMessage({}, {});
361 
362     if (m_restartProcessTimerId)
363         killTimer(m_restartProcessTimerId);
364 
365     if (model()) {
366         m_nodeInstanceServer.reset();
367         m_nodeInstanceServer = createNodeInstanceServerProxy();
368 
369         if (!isSkippedRootNode(rootModelNode())) {
370             m_nodeInstanceServer->createScene(createCreateSceneCommand());
371             m_nodeInstanceServer->changeSelection(
372                 createChangeSelectionCommand(model()->selectedNodes(this)));
373         }
374 
375         ModelNode stateNode = currentStateNode();
376         if (stateNode.isValid() && stateNode.metaInfo().isSubclassOf("QtQuick.State", 1, 0)) {
377             NodeInstance newStateInstance = instanceForModelNode(stateNode);
378             activateState(newStateInstance);
379         }
380     }
381 
382     m_restartProcessTimerId = 0;
383 }
384 
385 void NodeInstanceView::delayedRestartProcess()
386 {
387     if (0 == m_restartProcessTimerId)
388         m_restartProcessTimerId = startTimer(100);
389 }
390 
391 void NodeInstanceView::nodeCreated(const ModelNode &createdNode)
392 {
393     NodeInstance instance = loadNode(createdNode);
394 
395     if (isSkippedNode(createdNode))
396         return;
397 
398     QList<VariantProperty> propertyList;
399     propertyList.append(createdNode.variantProperty("x"));
400     propertyList.append(createdNode.variantProperty("y"));
401     updatePosition(propertyList);
402 
403     m_nodeInstanceServer->createInstances(createCreateInstancesCommand({instance}));
404     m_nodeInstanceServer->changePropertyValues(
405         createChangeValueCommand(createdNode.variantProperties()));
406     m_nodeInstanceServer->completeComponent(createComponentCompleteCommand({instance}));
407 }
408 
409 /*! Notifies the view that \a removedNode will be removed.
410 */
411 void NodeInstanceView::nodeAboutToBeRemoved(const ModelNode &removedNode)
412 {
413     m_nodeInstanceServer->removeInstances(createRemoveInstancesCommand(removedNode));
414     m_nodeInstanceServer->removeSharedMemory(
415         createRemoveSharedMemoryCommand("Image", removedNode.internalId()));
416     removeInstanceAndSubInstances(removedNode);
417 }
418 
419 void NodeInstanceView::resetHorizontalAnchors(const ModelNode &modelNode)
420 {
421     QList<BindingProperty> bindingList;
422     QList<VariantProperty> valueList;
423 
424     if (modelNode.hasBindingProperty("x"))
425         bindingList.append(modelNode.bindingProperty("x"));
426     else if (modelNode.hasVariantProperty("x"))
427         valueList.append(modelNode.variantProperty("x"));
428 
429     if (modelNode.hasBindingProperty("width"))
430         bindingList.append(modelNode.bindingProperty("width"));
431     else if (modelNode.hasVariantProperty("width"))
432         valueList.append(modelNode.variantProperty("width"));
433 
434     if (!valueList.isEmpty())
435         m_nodeInstanceServer->changePropertyValues(createChangeValueCommand(valueList));
436 
437     if (!bindingList.isEmpty())
438         m_nodeInstanceServer->changePropertyBindings(createChangeBindingCommand(bindingList));
439 }
440 
441 void NodeInstanceView::resetVerticalAnchors(const ModelNode &modelNode)
442 {
443     QList<BindingProperty> bindingList;
444     QList<VariantProperty> valueList;
445 
446     if (modelNode.hasBindingProperty("x"))
447         bindingList.append(modelNode.bindingProperty("x"));
448     else if (modelNode.hasVariantProperty("y"))
449         valueList.append(modelNode.variantProperty("y"));
450 
451     if (modelNode.hasBindingProperty("height"))
452         bindingList.append(modelNode.bindingProperty("height"));
453     else if (modelNode.hasVariantProperty("height"))
454         valueList.append(modelNode.variantProperty("height"));
455 
456     if (!valueList.isEmpty())
457         m_nodeInstanceServer->changePropertyValues(createChangeValueCommand(valueList));
458 
459     if (!bindingList.isEmpty())
460         m_nodeInstanceServer->changePropertyBindings(createChangeBindingCommand(bindingList));
461 }
462 
463 void NodeInstanceView::propertiesAboutToBeRemoved(const QList<AbstractProperty>& propertyList)
464 {
465     QTC_ASSERT(m_nodeInstanceServer, return);
466 
467     QList<ModelNode> nodeList;
468     QList<AbstractProperty> nonNodePropertyList;
469 
470     foreach (const AbstractProperty &property, propertyList) {
471         if (property.isNodeAbstractProperty())
472             nodeList.append(property.toNodeAbstractProperty().allSubNodes());
473         else
474             nonNodePropertyList.append(property);
475     }
476 
477     RemoveInstancesCommand removeInstancesCommand = createRemoveInstancesCommand(nodeList);
478 
479     if (!removeInstancesCommand.instanceIds().isEmpty())
480         m_nodeInstanceServer->removeInstances(removeInstancesCommand);
481 
482     m_nodeInstanceServer->removeSharedMemory(createRemoveSharedMemoryCommand("Image", nodeList));
483     m_nodeInstanceServer->removeProperties(createRemovePropertiesCommand(nonNodePropertyList));
484 
485     foreach (const AbstractProperty &property, propertyList) {
486         const PropertyName &name = property.name();
487         if (name == "anchors.fill") {
488             resetHorizontalAnchors(property.parentModelNode());
489             resetVerticalAnchors(property.parentModelNode());
490         } else if (name == "anchors.centerIn") {
491             resetHorizontalAnchors(property.parentModelNode());
492             resetVerticalAnchors(property.parentModelNode());
493         } else if (name == "anchors.top") {
494             resetVerticalAnchors(property.parentModelNode());
495         } else if (name == "anchors.left") {
496             resetHorizontalAnchors(property.parentModelNode());
497         } else if (name == "anchors.right") {
498             resetHorizontalAnchors(property.parentModelNode());
499         } else if (name == "anchors.bottom") {
500             resetVerticalAnchors(property.parentModelNode());
501         } else if (name == "anchors.horizontalCenter") {
502             resetHorizontalAnchors(property.parentModelNode());
503         } else if (name == "anchors.verticalCenter") {
504             resetVerticalAnchors(property.parentModelNode());
505         } else if (name == "anchors.baseline") {
506             resetVerticalAnchors(property.parentModelNode());
507         } else {
508             maybeResetOnPropertyChange(name, property.parentModelNode(),
509                                        AbstractView::EmptyPropertiesRemoved);
510         }
511     }
512 
513     foreach (const ModelNode &node, nodeList)
514         removeInstanceNodeRelationship(node);
515 }
516 
517 void NodeInstanceView::removeInstanceAndSubInstances(const ModelNode &node)
518 {
519     foreach (const ModelNode &subNode, node.allSubModelNodes()) {
520         if (hasInstanceForModelNode(subNode))
521             removeInstanceNodeRelationship(subNode);
522     }
523 
524     if (hasInstanceForModelNode(node))
525         removeInstanceNodeRelationship(node);
526 }
527 
528 void NodeInstanceView::rootNodeTypeChanged(const QString &/*type*/, int /*majorVersion*/, int /*minorVersion*/)
529 {
530     restartProcess();
531 }
532 
533 void NodeInstanceView::nodeTypeChanged(const ModelNode &, const TypeName &, int, int)
534 {
535     restartProcess();
536 }
537 
538 void NodeInstanceView::bindingPropertiesChanged(const QList<BindingProperty>& propertyList,
539                                                 PropertyChangeFlags propertyChange)
540 {
541     QTC_ASSERT(m_nodeInstanceServer, return);
542     m_nodeInstanceServer->changePropertyBindings(createChangeBindingCommand(propertyList));
543 
544     for (const auto &property : propertyList)
545         maybeResetOnPropertyChange(property.name(), property.parentModelNode(), propertyChange);
546 }
547 
548 /*!
549     Notifies the view that abstract property values specified by \a propertyList
550     were changed for a model node.
551 
552     The property will be set for the node instance.
553 
554     \sa AbstractProperty, NodeInstance, ModelNode
555 */
556 
557 void NodeInstanceView::variantPropertiesChanged(const QList<VariantProperty>& propertyList,
558                                                 PropertyChangeFlags propertyChange)
559 {
560     QTC_ASSERT(m_nodeInstanceServer, return);
561     updatePosition(propertyList);
562     m_nodeInstanceServer->changePropertyValues(createChangeValueCommand(propertyList));
563 
564     for (const auto &property : propertyList)
565         maybeResetOnPropertyChange(property.name(), property.parentModelNode(), propertyChange);
566 }
567 /*!
568   Notifies the view that the property parent of the model node \a node has
569   changed from \a oldPropertyParent to \a newPropertyParent.
570 
571   \note Also the \c {ModelNode::childNodes()} list was changed. The
572   Node instance tree will be changed to reflect the model node tree change.
573 
574     \sa NodeInstance, ModelNode
575 */
576 
577 void NodeInstanceView::nodeReparented(const ModelNode &node, const NodeAbstractProperty &newPropertyParent, const NodeAbstractProperty &oldPropertyParent, AbstractView::PropertyChangeFlags /*propertyChange*/)
578 {
579     QTC_ASSERT(m_nodeInstanceServer, return);
580     if (!isSkippedNode(node)) {
581         updateChildren(newPropertyParent);
582         m_nodeInstanceServer->reparentInstances(
583             createReparentInstancesCommand(node, newPropertyParent, oldPropertyParent));
584 
585         // Reset puppet when particle emitter/affector is reparented to work around issue in
586         // autodetecting the particle system it belongs to. QTBUG-101157
587         // Reset is also needed when particle shapes are reparented. QTBUG-101882
588         if (((node.isSubclassOf("QtQuick.Particles3D.ParticleEmitter3D")
589               || node.isSubclassOf("QtQuick.Particles3D.Affector3D"))
590              && node.property("system").toBindingProperty().expression().isEmpty())
591             || node.isSubclassOf("QQuick3DParticleAbstractShape")) {
592             resetPuppet();
593         }
594     }
595 }
596 
597 void NodeInstanceView::fileUrlChanged(const QUrl &/*oldUrl*/, const QUrl &newUrl)
598 {
599     QTC_ASSERT(m_nodeInstanceServer, return);
600     m_nodeInstanceServer->changeFileUrl(createChangeFileUrlCommand(newUrl));
601 }
602 
603 void NodeInstanceView::nodeIdChanged(const ModelNode& node, const QString& /*newId*/, const QString &oldId)
604 {
605     QTC_ASSERT(m_nodeInstanceServer, return);
606 
607     if (hasInstanceForModelNode(node)) {
608         NodeInstance instance = instanceForModelNode(node);
609         m_nodeInstanceServer->changeIds(createChangeIdsCommand({instance}));
610         m_imageDataMap.remove(oldId);
611     }
612 }
613 
614 void NodeInstanceView::nodeOrderChanged(const NodeListProperty &listProperty)
615 {
616     QTC_ASSERT(m_nodeInstanceServer, return);
617     QVector<ReparentContainer> containerList;
618     PropertyName propertyName = listProperty.name();
619     qint32 containerInstanceId = -1;
620     ModelNode containerNode = listProperty.parentModelNode();
621     if (hasInstanceForModelNode(containerNode))
622         containerInstanceId = instanceForModelNode(containerNode).instanceId();
623 
624     foreach (const ModelNode &node, listProperty.toModelNodeList()) {
625         qint32 instanceId = -1;
626         if (hasInstanceForModelNode(node)) {
627             instanceId = instanceForModelNode(node).instanceId();
628             ReparentContainer container(instanceId, containerInstanceId, propertyName, containerInstanceId, propertyName);
629             containerList.append(container);
630         }
631     }
632 
633     m_nodeInstanceServer->reparentInstances(ReparentInstancesCommand(containerList));
634 }
635 
636 void NodeInstanceView::importsChanged(const QList<Import> &/*addedImports*/, const QList<Import> &/*removedImports*/)
637 {
638     restartProcess();
639 }
640 
641 void NodeInstanceView::auxiliaryDataChanged(const ModelNode &node,
642                                             const PropertyName &name,
643                                             const QVariant &value)
644 {
645     QTC_ASSERT(m_nodeInstanceServer, return);
646     const bool forceAuxChange = name == "invisible" || name == "locked" || name == "rotBlocked@Internal";
647     if (((node.isRootNode() && (name == "width" || name == "height")) || forceAuxChange)
648             || name.endsWith(PropertyName("@NodeInstance"))) {
649         if (hasInstanceForModelNode(node)) {
650             NodeInstance instance = instanceForModelNode(node);
651             if (value.isValid() || forceAuxChange) {
652                 PropertyValueContainer container{instance.instanceId(), name, value, TypeName()};
653                 m_nodeInstanceServer->changeAuxiliaryValues({{container}});
654             } else {
655                 if (node.hasVariantProperty(name)) {
656                     PropertyValueContainer container(instance.instanceId(), name, node.variantProperty(name).value(), TypeName());
657                     ChangeValuesCommand changeValueCommand({container});
658                     m_nodeInstanceServer->changePropertyValues(changeValueCommand);
659                 } else if (node.hasBindingProperty(name)) {
660                     PropertyBindingContainer container{instance.instanceId(), name, node.bindingProperty(name).expression(), TypeName()};
661                     m_nodeInstanceServer->changePropertyBindings({{container}});
662                 }
663             }
664         }
665     } else if (node.isRootNode() && name == "language@Internal") {
666         const QString languageAsString = value.toString();
667         if (auto multiLanguageAspect = QmlProjectManager::QmlMultiLanguageAspect::current(m_currentTarget))
668             multiLanguageAspect->setCurrentLocale(languageAsString);
669         m_nodeInstanceServer->changeLanguage({languageAsString});
670     } else if (node.isRootNode() && name == "previewSize@Internal") {
671         m_nodeInstanceServer->changePreviewImageSize(value.toSize());
672     }
673 }
674 
675 void NodeInstanceView::customNotification(const AbstractView *view, const QString &identifier, const QList<ModelNode> &, const QList<QVariant> &)
676 {
677     if (view && identifier == QStringLiteral("reset QmlPuppet"))
678         delayedRestartProcess();
679 }
680 
681 void NodeInstanceView::nodeSourceChanged(const ModelNode &node, const QString & newNodeSource)
682 {
683      QTC_ASSERT(m_nodeInstanceServer, return);
684      if (hasInstanceForModelNode(node)) {
685          NodeInstance instance = instanceForModelNode(node);
686          ChangeNodeSourceCommand changeNodeSourceCommand(instance.instanceId(), newNodeSource);
687          m_nodeInstanceServer->changeNodeSource(changeNodeSourceCommand);
688 
689          // Puppet doesn't deal with node source changes properly, so just reset the puppet for now
690          resetPuppet(); // TODO: Remove this once the issue is properly fixed (QDS-4955)
691      }
692 }
693 
694 void NodeInstanceView::capturedData(const CapturedDataCommand &) {}
695 
696 void NodeInstanceView::currentStateChanged(const ModelNode &node)
697 {
698     NodeInstance newStateInstance = instanceForModelNode(node);
699 
700     if (newStateInstance.isValid() && node.metaInfo().isSubclassOf("QtQuick.State", 1, 0))
701         nodeInstanceView()->activateState(newStateInstance);
702     else
703         nodeInstanceView()->activateBaseState();
704 }
705 
706 void NodeInstanceView::sceneCreated(const SceneCreatedCommand &) {}
707 
708 //\}
709 
710 void NodeInstanceView::removeAllInstanceNodeRelationships()
711 {
712     m_nodeInstanceHash.clear();
713 }
714 
715 /*!
716     Returns a list of all node instances.
717 
718     \sa NodeInstance
719 */
720 
721 QList<NodeInstance> NodeInstanceView::instances() const
722 {
723     return m_nodeInstanceHash.values();
724 }
725 
726 /*!
727     Returns the node instance for \a node, which must be valid.
728 
729     Returns an invalid node instance if no node instance for this model node
730     exists.
731 
732     \sa NodeInstance
733 */
734 NodeInstance NodeInstanceView::instanceForModelNode(const ModelNode &node) const
735 {
736     Q_ASSERT(node.isValid());
737     Q_ASSERT(m_nodeInstanceHash.contains(node));
738     Q_ASSERT(m_nodeInstanceHash.value(node).modelNode() == node);
739     return m_nodeInstanceHash.value(node);
740 }
741 
742 bool NodeInstanceView::hasInstanceForModelNode(const ModelNode &node) const
743 {
744     return m_nodeInstanceHash.contains(node);
745 }
746 
747 NodeInstance NodeInstanceView::instanceForId(qint32 id)
748 {
749     if (id < 0 || !hasModelNodeForInternalId(id))
750         return NodeInstance();
751 
752     return m_nodeInstanceHash.value(modelNodeForInternalId(id));
753 }
754 
755 bool NodeInstanceView::hasInstanceForId(qint32 id)
756 {
757     if (id < 0 || !hasModelNodeForInternalId(id))
758         return false;
759 
760     return m_nodeInstanceHash.contains(modelNodeForInternalId(id));
761 }
762 
763 
764 /*!
765     Returns the root node instance of this view.
766 
767     \sa NodeInstance
768 */
769 NodeInstance NodeInstanceView::rootNodeInstance() const
770 {
771     return m_rootNodeInstance;
772 }
773 
774 /*!
775     Returns the \a instance of this view.
776 
777   This can be the root node instance if it is specified in the QML file.
778 \code
779     QGraphicsView {
780          QGraphicsScene {
781              Item {}
782          }
783     }
784 \endcode
785 
786     If there is node view in the QML file:
787  \code
788 
789     Item {}
790 
791 \endcode
792     Then a new node instance for this QGraphicsView is
793     generated which is not the root instance of this node instance view.
794 
795     This is the way to get this QGraphicsView node instance.
796 
797     \sa NodeInstance
798 */
799 
800 
801 
802 void NodeInstanceView::insertInstanceRelationships(const NodeInstance &instance)
803 {
804     Q_ASSERT(instance.instanceId() >=0);
805     if (m_nodeInstanceHash.contains(instance.modelNode()))
806         return;
807 
808     m_nodeInstanceHash.insert(instance.modelNode(), instance);
809 }
810 
811 void NodeInstanceView::removeInstanceNodeRelationship(const ModelNode &node)
812 {
813     Q_ASSERT(m_nodeInstanceHash.contains(node));
814     NodeInstance instance = instanceForModelNode(node);
815     m_nodeInstanceHash.remove(node);
816     instance.makeInvalid();
817 }
818 
819 void NodeInstanceView::setStateInstance(const NodeInstance &stateInstance)
820 {
821     m_activeStateInstance = stateInstance;
822 }
823 
824 void NodeInstanceView::clearStateInstance()
825 {
826     m_activeStateInstance = NodeInstance();
827 }
828 
829 NodeInstance NodeInstanceView::activeStateInstance() const
830 {
831     return m_activeStateInstance;
832 }
833 
834 void NodeInstanceView::updateChildren(const NodeAbstractProperty &newPropertyParent)
835 {
836     QVector<ModelNode> childNodeVector = newPropertyParent.directSubNodes().toVector();
837 
838     qint32 parentInstanceId = newPropertyParent.parentModelNode().internalId();
839 
840     foreach (const ModelNode &childNode, childNodeVector) {
841         qint32 instanceId = childNode.internalId();
842         if (hasInstanceForId(instanceId)) {
843             NodeInstance instance = instanceForId(instanceId);
844             if (instance.directUpdates())
845                 instance.setParentId(parentInstanceId);
846         }
847     }
848 
849     if (!childNodeVector.isEmpty())
850         emitInstancesChildrenChanged(childNodeVector);
851 }
852 
853 void setXValue(NodeInstance &instance, const VariantProperty &variantProperty, QMultiHash<ModelNode, InformationName> &informationChangeHash)
854 {
855     instance.setX(variantProperty.value().toDouble());
856     informationChangeHash.insert(instance.modelNode(), Transform);
857 }
858 
859 void setYValue(NodeInstance &instance, const VariantProperty &variantProperty, QMultiHash<ModelNode, InformationName> &informationChangeHash)
860 {
861     instance.setY(variantProperty.value().toDouble());
862     informationChangeHash.insert(instance.modelNode(), Transform);
863 }
864 
865 
866 void NodeInstanceView::updatePosition(const QList<VariantProperty> &propertyList)
867 {
868     QMultiHash<ModelNode, InformationName> informationChangeHash;
869 
870     foreach (const VariantProperty &variantProperty, propertyList) {
871         if (variantProperty.name() == "x") {
872             const ModelNode modelNode = variantProperty.parentModelNode();
873             if (!currentState().isBaseState() && QmlPropertyChanges::isValidQmlPropertyChanges(modelNode)) {
874                 ModelNode targetModelNode = QmlPropertyChanges(modelNode).target();
875                 if (targetModelNode.isValid()) {
876                     NodeInstance instance = instanceForModelNode(targetModelNode);
877                     setXValue(instance, variantProperty, informationChangeHash);
878                 }
879             } else {
880                 NodeInstance instance = instanceForModelNode(modelNode);
881                 setXValue(instance, variantProperty, informationChangeHash);
882             }
883         } else if (variantProperty.name() == "y") {
884             const ModelNode modelNode = variantProperty.parentModelNode();
885             if (!currentState().isBaseState() && QmlPropertyChanges::isValidQmlPropertyChanges(modelNode)) {
886                 ModelNode targetModelNode = QmlPropertyChanges(modelNode).target();
887                 if (targetModelNode.isValid()) {
888                     NodeInstance instance = instanceForModelNode(targetModelNode);
889                     setYValue(instance, variantProperty, informationChangeHash);
890                 }
891             } else {
892                 NodeInstance instance = instanceForModelNode(modelNode);
893                 setYValue(instance, variantProperty, informationChangeHash);
894             }
895         } else if (currentTimeline().isValid()
896                    && variantProperty.name() == "value"
897                    &&  QmlTimelineKeyframeGroup::isValidKeyframe(variantProperty.parentModelNode())) {
898 
899             QmlTimelineKeyframeGroup frames = QmlTimelineKeyframeGroup::keyframeGroupForKeyframe(variantProperty.parentModelNode());
900 
901             if (frames.isValid() && frames.propertyName() == "x" && frames.target().isValid()) {
902 
903                 NodeInstance instance = instanceForModelNode(frames.target());
904                 setXValue(instance, variantProperty, informationChangeHash);
905             } else if (frames.isValid() && frames.propertyName() == "y" && frames.target().isValid()) {
906                 NodeInstance instance = instanceForModelNode(frames.target());
907                 setYValue(instance, variantProperty, informationChangeHash);
908             }
909 
910         }
911     }
912 
913     if (!informationChangeHash.isEmpty())
914         emitInstanceInformationsChange(informationChangeHash);
915 }
916 
917 NodeInstance NodeInstanceView::loadNode(const ModelNode &node)
918 {
919     NodeInstance instance(NodeInstance::create(node));
920 
921     insertInstanceRelationships(instance);
922 
923     if (node.isRootNode())
924         m_rootNodeInstance = instance;
925 
926     return instance;
927 }
928 
929 void NodeInstanceView::activateState(const NodeInstance &instance)
930 {
931     m_nodeInstanceServer->changeState(ChangeStateCommand(instance.instanceId()));
932 }
933 
934 void NodeInstanceView::activateBaseState()
935 {
936     m_nodeInstanceServer->changeState(ChangeStateCommand(-1));
937 }
938 
939 void NodeInstanceView::removeRecursiveChildRelationship(const ModelNode &removedNode)
940 {
941 //    if (hasInstanceForNode(removedNode)) {
942 //        instanceForNode(removedNode).setId(QString());
943 //    }
944 
945     foreach (const ModelNode &childNode, removedNode.directSubModelNodes())
946         removeRecursiveChildRelationship(childNode);
947 
948     removeInstanceNodeRelationship(removedNode);
949 }
950 
951 QRectF NodeInstanceView::sceneRect() const
952 {
953     if (rootNodeInstance().isValid())
954        return rootNodeInstance().boundingRect();
955 
956     return {};
957 }
958 
959 QList<ModelNode> filterNodesForSkipItems(const QList<ModelNode> &nodeList)
960 {
961     QList<ModelNode> filteredNodeList;
962     foreach (const ModelNode &node, nodeList) {
963         if (isSkippedNode(node))
964             continue;
965 
966         filteredNodeList.append(node);
967     }
968 
969     return filteredNodeList;
970 }
971 
972 CreateSceneCommand NodeInstanceView::createCreateSceneCommand()
973 {
974     QList<ModelNode> nodeList = allModelNodes();
975     QList<NodeInstance> instanceList;
976 
977     Utils::optional oldNodeInstanceHash = m_nodeInstanceCache.take(model());
978     if (oldNodeInstanceHash
979         && oldNodeInstanceHash->instances.value(rootModelNode()).isValid()) {
980         instanceList = loadInstancesFromCache(nodeList, oldNodeInstanceHash.value());
981     } else {
982         for (const ModelNode &node : std::as_const(nodeList)) {
983             NodeInstance instance = loadNode(node);
984             if (!isSkippedNode(node))
985                 instanceList.append(instance);
986         }
987     }
988 
989     clearErrors();
990 
991     nodeList = filterNodesForSkipItems(nodeList);
992 
993     QList<VariantProperty> variantPropertyList;
994     QList<BindingProperty> bindingPropertyList;
995 
996     QVector<PropertyValueContainer> auxiliaryContainerVector;
997     for (const ModelNode &node : std::as_const(nodeList)) {
998         variantPropertyList.append(node.variantProperties());
999         bindingPropertyList.append(node.bindingProperties());
1000         if (node.isValid() && hasInstanceForModelNode(node)) {
1001             NodeInstance instance = instanceForModelNode(node);
1002             const QHash<PropertyName, QVariant> aux = node.auxiliaryData();
1003             for (auto auxiliaryIterator = aux.cbegin(), end = aux.cend();
1004                       auxiliaryIterator != end;
1005                       ++auxiliaryIterator) {
1006                 PropertyValueContainer container(instance.instanceId(), auxiliaryIterator.key(), auxiliaryIterator.value(), TypeName());
1007                 auxiliaryContainerVector.append(container);
1008             }
1009         }
1010     }
1011 
1012     QVector<InstanceContainer> instanceContainerList;
1013     for (const NodeInstance &instance : std::as_const(instanceList)) {
1014         InstanceContainer::NodeSourceType nodeSourceType = static_cast<InstanceContainer::NodeSourceType>(instance.modelNode().nodeSourceType());
1015 
1016         InstanceContainer::NodeMetaType nodeMetaType = InstanceContainer::ObjectMetaType;
1017         if (instance.modelNode().metaInfo().isSubclassOf("QtQuick.Item"))
1018             nodeMetaType = InstanceContainer::ItemMetaType;
1019 
1020         InstanceContainer::NodeFlags nodeFlags;
1021 
1022         if (parentTakesOverRendering(instance.modelNode()))
1023             nodeFlags |= InstanceContainer::ParentTakesOverRendering;
1024 
1025         InstanceContainer container(instance.instanceId(),
1026                                     instance.modelNode().type(),
1027                                     instance.modelNode().majorVersion(),
1028                                     instance.modelNode().minorVersion(),
1029                                     instance.modelNode().metaInfo().componentFileName(),
1030                                     instance.modelNode().nodeSource(),
1031                                     nodeSourceType,
1032                                     nodeMetaType,
1033                                     nodeFlags);
1034 
1035         instanceContainerList.append(container);
1036     }
1037 
1038     QVector<ReparentContainer> reparentContainerList;
1039     for (const NodeInstance &instance : std::as_const(instanceList)) {
1040         if (instance.modelNode().hasParentProperty()) {
1041             NodeAbstractProperty parentProperty = instance.modelNode().parentProperty();
1042             ReparentContainer container(instance.instanceId(), -1, PropertyName(), instanceForModelNode(parentProperty.parentModelNode()).instanceId(), parentProperty.name());
1043             reparentContainerList.append(container);
1044         }
1045     }
1046 
1047     QVector<IdContainer> idContainerList;
1048     for (const NodeInstance &instance : std::as_const(instanceList)) {
1049         QString id = instance.modelNode().id();
1050         if (!id.isEmpty()) {
1051             IdContainer container(instance.instanceId(), id);
1052             idContainerList.append(container);
1053         }
1054     }
1055 
1056     QVector<PropertyValueContainer> valueContainerList;
1057     for (const VariantProperty &property : std::as_const(variantPropertyList)) {
1058         ModelNode node = property.parentModelNode();
1059         if (node.isValid() && hasInstanceForModelNode(node)) {
1060             NodeInstance instance = instanceForModelNode(node);
1061             PropertyValueContainer container(instance.instanceId(), property.name(), property.value(), property.dynamicTypeName());
1062             valueContainerList.append(container);
1063         }
1064     }
1065 
1066     QVector<PropertyBindingContainer> bindingContainerList;
1067     for (const BindingProperty &property : std::as_const(bindingPropertyList)) {
1068         ModelNode node = property.parentModelNode();
1069         if (node.isValid() && hasInstanceForModelNode(node)) {
1070             NodeInstance instance = instanceForModelNode(node);
1071             PropertyBindingContainer container(instance.instanceId(), property.name(), property.expression(), property.dynamicTypeName());
1072             bindingContainerList.append(container);
1073         }
1074     }
1075 
1076     QVector<AddImportContainer> importVector;
1077     for (const Import &import : model()->imports())
1078         importVector.append(AddImportContainer(import.url(), import.file(), import.version(), import.alias(), import.importPaths()));
1079 
1080     QVector<MockupTypeContainer> mockupTypesVector;
1081 
1082     for (const QmlTypeData &cppTypeData : model()->rewriterView()->getQMLTypes()) {
1083         const QString versionString = cppTypeData.versionString;
1084         int majorVersion = -1;
1085         int minorVersion = -1;
1086 
1087         if (versionString.contains(QStringLiteral("."))) {
1088             const QStringList splittedString = versionString.split(QStringLiteral("."));
1089             majorVersion = splittedString.constFirst().toInt();
1090             minorVersion = splittedString.constLast().toInt();
1091         }
1092 
1093         bool isItem = false;
1094 
1095         if (!cppTypeData.isSingleton) { /* Singletons only appear on the right hand sides of bindings and create just warnings. */
1096             const TypeName typeName = cppTypeData.typeName.toUtf8();
1097             const QString uri = cppTypeData.importUrl;
1098 
1099             NodeMetaInfo metaInfo = model()->metaInfo(uri.toUtf8() + "." + typeName);
1100 
1101             if (metaInfo.isValid())
1102                 isItem = metaInfo.isGraphicalItem();
1103 
1104             MockupTypeContainer mockupType(typeName, uri, majorVersion, minorVersion, isItem);
1105 
1106             mockupTypesVector.append(mockupType);
1107         } else { /* We need a type for the signleton import */
1108             const TypeName typeName = cppTypeData.typeName.toUtf8() + "Mockup";
1109             const QString uri = cppTypeData.importUrl;
1110 
1111             MockupTypeContainer mockupType(typeName, uri, majorVersion, minorVersion, isItem);
1112 
1113             mockupTypesVector.append(mockupType);
1114         }
1115     }
1116 
1117     QString lastUsedLanguage;
1118     if (auto multiLanguageAspect = QmlProjectManager::QmlMultiLanguageAspect::current(m_currentTarget))
1119         lastUsedLanguage = multiLanguageAspect->currentLocale();
1120 
1121     ModelNode stateNode = currentStateNode();
1122     qint32 stateInstanceId = 0;
1123     if (stateNode.isValid() && stateNode.metaInfo().isSubclassOf("QtQuick.State", 1, 0))
1124         stateInstanceId = stateNode.internalId();
1125 
1126     return CreateSceneCommand(instanceContainerList,
1127                               reparentContainerList,
1128                               idContainerList,
1129                               valueContainerList,
1130                               bindingContainerList,
1131                               auxiliaryContainerVector,
1132                               importVector,
1133                               mockupTypesVector,
1134                               model()->fileUrl(),
1135 #ifndef QMLDESIGNER_TEST
1136                               QUrl::fromLocalFile(QmlDesigner::DocumentManager::currentResourcePath()
1137                                                   .toFileInfo().absoluteFilePath()),
1138 #else
1139                               QUrl::fromLocalFile(QFileInfo(model()->fileUrl().toLocalFile()).absolutePath()),
1140 #endif
1141                               m_edit3DToolStates[model()->fileUrl()],
1142                               lastUsedLanguage,
1143                               stateInstanceId);
1144 }
1145 
1146 ClearSceneCommand NodeInstanceView::createClearSceneCommand() const
1147 {
1148     return {};
1149 }
1150 
1151 CompleteComponentCommand NodeInstanceView::createComponentCompleteCommand(const QList<NodeInstance> &instanceList) const
1152 {
1153     QVector<qint32> containerList;
1154     foreach (const NodeInstance &instance, instanceList) {
1155         if (instance.instanceId() >= 0)
1156             containerList.append(instance.instanceId());
1157     }
1158 
1159     return CompleteComponentCommand(containerList);
1160 }
1161 
1162 ComponentCompletedCommand NodeInstanceView::createComponentCompletedCommand(const QList<NodeInstance> &instanceList) const
1163 {
1164     QVector<qint32> containerList;
1165     foreach (const NodeInstance &instance, instanceList) {
1166         if (instance.instanceId() >= 0)
1167             containerList.append(instance.instanceId());
1168     }
1169 
1170     return ComponentCompletedCommand(containerList);
1171 }
1172 
1173 CreateInstancesCommand NodeInstanceView::createCreateInstancesCommand(const QList<NodeInstance> &instanceList) const
1174 {
1175     QVector<InstanceContainer> containerList;
1176     foreach (const NodeInstance &instance, instanceList) {
1177         InstanceContainer::NodeSourceType nodeSourceType = static_cast<InstanceContainer::NodeSourceType>(instance.modelNode().nodeSourceType());
1178 
1179         InstanceContainer::NodeMetaType nodeMetaType = InstanceContainer::ObjectMetaType;
1180         if (instance.modelNode().metaInfo().isSubclassOf("QtQuick.Item"))
1181             nodeMetaType = InstanceContainer::ItemMetaType;
1182 
1183         InstanceContainer::NodeFlags nodeFlags;
1184 
1185         if (parentTakesOverRendering(instance.modelNode()))
1186             nodeFlags |= InstanceContainer::ParentTakesOverRendering;
1187 
1188         InstanceContainer container(instance.instanceId(),
1189                                     instance.modelNode().type(),
1190                                     instance.modelNode().majorVersion(),
1191                                     instance.modelNode().minorVersion(),
1192                                     instance.modelNode().metaInfo().componentFileName(),
1193                                     instance.modelNode().nodeSource(),
1194                                     nodeSourceType,
1195                                     nodeMetaType,
1196                                     nodeFlags);
1197         containerList.append(container);
1198     }
1199 
1200     return CreateInstancesCommand(containerList);
1201 }
1202 
1203 ReparentInstancesCommand NodeInstanceView::createReparentInstancesCommand(const QList<NodeInstance> &instanceList) const
1204 {
1205     QVector<ReparentContainer> containerList;
1206     foreach (const NodeInstance &instance, instanceList) {
1207         if (instance.modelNode().hasParentProperty()) {
1208             NodeAbstractProperty parentProperty = instance.modelNode().parentProperty();
1209             ReparentContainer container(instance.instanceId(), -1, PropertyName(), instanceForModelNode(parentProperty.parentModelNode()).instanceId(), parentProperty.name());
1210             containerList.append(container);
1211         }
1212     }
1213 
1214     return ReparentInstancesCommand(containerList);
1215 }
1216 
1217 ReparentInstancesCommand NodeInstanceView::createReparentInstancesCommand(const ModelNode &node, const NodeAbstractProperty &newPropertyParent, const NodeAbstractProperty &oldPropertyParent) const
1218 {
1219     QVector<ReparentContainer> containerList;
1220 
1221     qint32 newParentInstanceId = -1;
1222     qint32 oldParentInstanceId = -1;
1223 
1224     if (newPropertyParent.isValid() && hasInstanceForModelNode(newPropertyParent.parentModelNode()))
1225         newParentInstanceId = instanceForModelNode(newPropertyParent.parentModelNode()).instanceId();
1226 
1227 
1228     if (oldPropertyParent.isValid() && hasInstanceForModelNode(oldPropertyParent.parentModelNode()))
1229         oldParentInstanceId = instanceForModelNode(oldPropertyParent.parentModelNode()).instanceId();
1230 
1231 
1232     ReparentContainer container(instanceForModelNode(node).instanceId(), oldParentInstanceId, oldPropertyParent.name(), newParentInstanceId, newPropertyParent.name());
1233 
1234     containerList.append(container);
1235 
1236     return ReparentInstancesCommand(containerList);
1237 }
1238 
1239 ChangeFileUrlCommand NodeInstanceView::createChangeFileUrlCommand(const QUrl &fileUrl) const
1240 {
1241     return {fileUrl};
1242 }
1243 
1244 ChangeValuesCommand NodeInstanceView::createChangeValueCommand(const QList<VariantProperty>& propertyList) const
1245 {
1246     QVector<PropertyValueContainer> containerList;
1247 
1248     const bool reflectionFlag = m_puppetTransaction.isValid() && (!currentTimeline().isValid() || !currentTimeline().isRecording());
1249 
1250     foreach (const VariantProperty &property, propertyList) {
1251         ModelNode node = property.parentModelNode();
1252         if (node.isValid() && hasInstanceForModelNode(node)) {
1253             NodeInstance instance = instanceForModelNode(node);
1254             PropertyValueContainer container(instance.instanceId(), property.name(), property.value(), property.dynamicTypeName());
1255             container.setReflectionFlag(reflectionFlag);
1256             containerList.append(container);
1257         }
1258 
1259     }
1260 
1261     return ChangeValuesCommand(containerList);
1262 }
1263 
1264 ChangeBindingsCommand NodeInstanceView::createChangeBindingCommand(const QList<BindingProperty> &propertyList) const
1265 {
1266     QVector<PropertyBindingContainer> containerList;
1267 
1268     for (const BindingProperty &property : propertyList) {
1269         ModelNode node = property.parentModelNode();
1270         if (node.isValid() && hasInstanceForModelNode(node)) {
1271             NodeInstance instance = instanceForModelNode(node);
1272             PropertyBindingContainer container(instance.instanceId(), property.name(), property.expression(), property.dynamicTypeName());
1273             containerList.append(container);
1274         }
1275 
1276     }
1277 
1278     return {containerList};
1279 }
1280 
1281 ChangeIdsCommand NodeInstanceView::createChangeIdsCommand(const QList<NodeInstance> &instanceList) const
1282 {
1283     QVector<IdContainer> containerList;
1284     for (const NodeInstance &instance : instanceList) {
1285         QString id = instance.modelNode().id();
1286         if (!id.isEmpty()) {
1287             IdContainer container(instance.instanceId(), id);
1288             containerList.append(container);
1289         }
1290     }
1291 
1292     return {containerList};
1293 }
1294 
1295 
1296 
1297 RemoveInstancesCommand NodeInstanceView::createRemoveInstancesCommand(const QList<ModelNode> &nodeList) const
1298 {
1299     QVector<qint32> idList;
1300     foreach (const ModelNode &node, nodeList) {
1301         if (node.isValid() && hasInstanceForModelNode(node)) {
1302             NodeInstance instance = instanceForModelNode(node);
1303 
1304             if (instance.instanceId() >= 0)
1305                 idList.append(instance.instanceId());
1306         }
1307     }
1308 
1309     return RemoveInstancesCommand(idList);
1310 }
1311 
1312 ChangeSelectionCommand NodeInstanceView::createChangeSelectionCommand(const QList<ModelNode> &nodeList) const
1313 {
1314     QVector<qint32> idList;
1315     foreach (const ModelNode &node, nodeList) {
1316         if (node.isValid() && hasInstanceForModelNode(node)) {
1317             NodeInstance instance = instanceForModelNode(node);
1318 
1319             if (instance.instanceId() >= 0)
1320                 idList.append(instance.instanceId());
1321         }
1322     }
1323 
1324     return ChangeSelectionCommand(idList);
1325 }
1326 
1327 RemoveInstancesCommand NodeInstanceView::createRemoveInstancesCommand(const ModelNode &node) const
1328 {
1329     QVector<qint32> idList;
1330 
1331     if (node.isValid() && hasInstanceForModelNode(node))
1332         idList.append(instanceForModelNode(node).instanceId());
1333 
1334     return RemoveInstancesCommand(idList);
1335 }
1336 
1337 RemovePropertiesCommand NodeInstanceView::createRemovePropertiesCommand(const QList<AbstractProperty> &propertyList) const
1338 {
1339     QVector<PropertyAbstractContainer> containerList;
1340 
1341     foreach (const AbstractProperty &property, propertyList) {
1342         ModelNode node = property.parentModelNode();
1343         if (node.isValid() && hasInstanceForModelNode(node)) {
1344             NodeInstance instance = instanceForModelNode(node);
1345             PropertyAbstractContainer container(instance.instanceId(), property.name(), property.dynamicTypeName());
1346             containerList.append(container);
1347         }
1348 
1349     }
1350 
1351     return RemovePropertiesCommand(containerList);
1352 }
1353 
1354 RemoveSharedMemoryCommand NodeInstanceView::createRemoveSharedMemoryCommand(const QString &sharedMemoryTypeName, quint32 keyNumber)
1355 {
1356     return RemoveSharedMemoryCommand(sharedMemoryTypeName, {static_cast<qint32>(keyNumber)});
1357 }
1358 
1359 RemoveSharedMemoryCommand NodeInstanceView::createRemoveSharedMemoryCommand(const QString &sharedMemoryTypeName, const QList<ModelNode> &nodeList)
1360 {
1361     QVector<qint32> keyNumberVector;
1362 
1363     foreach (const ModelNode &modelNode, nodeList)
1364         keyNumberVector.append(modelNode.internalId());
1365 
1366     return RemoveSharedMemoryCommand(sharedMemoryTypeName, keyNumberVector);
1367 }
1368 
1369 void NodeInstanceView::valuesChanged(const ValuesChangedCommand &command)
1370 {
1371     if (!model())
1372         return;
1373 
1374     QList<QPair<ModelNode, PropertyName> > valuePropertyChangeList;
1375 
1376     foreach (const PropertyValueContainer &container, command.valueChanges()) {
1377         if (hasInstanceForId(container.instanceId())) {
1378             NodeInstance instance = instanceForId(container.instanceId());
1379             if (instance.isValid()) {
1380                 instance.setProperty(container.name(), container.value());
1381                 valuePropertyChangeList.append({instance.modelNode(), container.name()});
1382             }
1383         }
1384     }
1385 
1386     m_nodeInstanceServer->removeSharedMemory(
1387         createRemoveSharedMemoryCommand(QStringLiteral("Values"), command.keyNumber()));
1388 
1389     if (!valuePropertyChangeList.isEmpty())
1390         emitInstancePropertyChange(valuePropertyChangeList);
1391 }
1392 
1393 void NodeInstanceView::valuesModified(const ValuesModifiedCommand &command)
1394 {
1395     if (!model())
1396         return;
1397 
1398     if (command.transactionOption == ValuesModifiedCommand::TransactionOption::Start)
1399         startPuppetTransaction();
1400 
1401     for (const PropertyValueContainer &container : command.valueChanges()) {
1402         if (hasInstanceForId(container.instanceId())) {
1403             NodeInstance instance = instanceForId(container.instanceId());
1404             if (instance.isValid()) {
1405                 QScopedPointer<QmlObjectNode> node {
1406                     QmlObjectNode::getQmlObjectNodeOfCorrectType(instance.modelNode())};
1407                 if (node->modelValue(container.name()) != container.value())
1408                     node->setVariantProperty(container.name(), container.value());
1409             }
1410         }
1411     }
1412 
1413     if (command.transactionOption == ValuesModifiedCommand::TransactionOption::End)
1414         endPuppetTransaction();
1415 }
1416 
1417 void NodeInstanceView::pixmapChanged(const PixmapChangedCommand &command)
1418 {
1419     if (!model())
1420         return;
1421 
1422     QSet<ModelNode> renderImageChangeSet;
1423 
1424     foreach (const ImageContainer &container, command.images()) {
1425         if (hasInstanceForId(container.instanceId())) {
1426             NodeInstance instance = instanceForId(container.instanceId());
1427             if (instance.isValid()) {
1428                 instance.setRenderPixmap(container.image());
1429                 renderImageChangeSet.insert(instance.modelNode());
1430             }
1431         }
1432     }
1433 
1434     m_nodeInstanceServer->benchmark(Q_FUNC_INFO + QString::number(renderImageChangeSet.count()));
1435 
1436     if (!renderImageChangeSet.isEmpty())
1437         emitInstancesRenderImageChanged(Utils::toList(renderImageChangeSet).toVector());
1438 }
1439 
1440 QMultiHash<ModelNode, InformationName> NodeInstanceView::informationChanged(const QVector<InformationContainer> &containerVector)
1441 {
1442     QMultiHash<ModelNode, InformationName> informationChangeHash;
1443 
1444     foreach (const InformationContainer &container, containerVector) {
1445         if (hasInstanceForId(container.instanceId())) {
1446             NodeInstance instance = instanceForId(container.instanceId());
1447             if (instance.isValid()) {
1448                 InformationName informationChange = instance.setInformation(container.name(), container.information(), container.secondInformation(), container.thirdInformation());
1449                 if (informationChange != NoInformationChange)
1450                     informationChangeHash.insert(instance.modelNode(), informationChange);
1451             }
1452         }
1453     }
1454 
1455     return informationChangeHash;
1456 }
1457 
1458 void NodeInstanceView::informationChanged(const InformationChangedCommand &command)
1459 {
1460     if (!model())
1461         return;
1462 
1463     QMultiHash<ModelNode, InformationName> informationChangeHash = informationChanged(command.informations());
1464 
1465     m_nodeInstanceServer->benchmark(Q_FUNC_INFO + QString::number(informationChangeHash.count()));
1466 
1467     if (!informationChangeHash.isEmpty())
1468         emitInstanceInformationsChange(informationChangeHash);
1469 }
1470 
1471 QImage NodeInstanceView::statePreviewImage(const ModelNode &stateNode) const
1472 {
1473     if (stateNode == rootModelNode())
1474         return m_baseStatePreviewImage;
1475 
1476     return m_statePreviewImage.value(stateNode);
1477 }
1478 
1479 void NodeInstanceView::setTarget(ProjectExplorer::Target *newTarget)
1480 {
1481     if (m_currentTarget != newTarget) {
1482         m_currentTarget = newTarget;
1483         if (m_currentTarget && m_currentTarget->kit()) {
1484             if (QtSupport::QtVersion *qtVer = QtSupport::QtKitAspect::qtVersion(m_currentTarget->kit())) {
1485                 m_qsbPath = qtVer->binPath().pathAppended("qsb").withExecutableSuffix();
1486                 if (!m_qsbPath.exists())
1487                     m_qsbPath.clear();
1488             }
1489         }
1490 
1491         m_generateQsbFilesTimer.stop();
1492         m_pendingQsbTargets.clear();
1493         m_remainingQsbTargets = 0;
1494         restartProcess();
1495     }
1496 }
1497 
1498 void NodeInstanceView::statePreviewImagesChanged(const StatePreviewImageChangedCommand &command)
1499 {
1500     if (!model())
1501       return;
1502 
1503   QVector<ModelNode> previewImageChangeVector;
1504 
1505   foreach (const ImageContainer &container, command.previews()) {
1506       if (container.keyNumber() == -1) {
1507           m_baseStatePreviewImage = container.image();
1508           if (!container.image().isNull())
1509               previewImageChangeVector.append(rootModelNode());
1510       } else if (hasInstanceForId(container.instanceId())) {
1511           ModelNode node = modelNodeForInternalId(container.instanceId());
1512           m_statePreviewImage.insert(node, container.image());
1513           if (!container.image().isNull())
1514               previewImageChangeVector.append(node);
1515       }
1516   }
1517 
1518   if (!previewImageChangeVector.isEmpty())
1519        emitInstancesPreviewImageChanged(previewImageChangeVector);
1520 }
1521 
1522 void NodeInstanceView::componentCompleted(const ComponentCompletedCommand &command)
1523 {
1524     if (!model())
1525         return;
1526 
1527     QVector<ModelNode> nodeVector;
1528 
1529     foreach (const qint32 &instanceId, command.instances()) {
1530         if (hasModelNodeForInternalId(instanceId))
1531             nodeVector.append(modelNodeForInternalId(instanceId));
1532     }
1533 
1534     m_nodeInstanceServer->benchmark(Q_FUNC_INFO + QString::number(nodeVector.count()));
1535 
1536     if (!nodeVector.isEmpty())
1537         emitInstancesCompleted(nodeVector);
1538 }
1539 
1540 void NodeInstanceView::childrenChanged(const ChildrenChangedCommand &command)
1541 {
1542      if (!model())
1543         return;
1544 
1545     QVector<ModelNode> childNodeVector;
1546 
1547     foreach (qint32 instanceId, command.childrenInstances()) {
1548         if (hasInstanceForId(instanceId)) {
1549             NodeInstance instance = instanceForId(instanceId);
1550             if (instance.parentId() == -1 || !instance.directUpdates())
1551                 instance.setParentId(command.parentInstanceId());
1552             childNodeVector.append(instance.modelNode());
1553         }
1554     }
1555 
1556     QMultiHash<ModelNode, InformationName> informationChangeHash = informationChanged(command.informations());
1557 
1558     if (!informationChangeHash.isEmpty())
1559         emitInstanceInformationsChange(informationChangeHash);
1560 
1561     if (!childNodeVector.isEmpty())
1562         emitInstancesChildrenChanged(childNodeVector);
1563 }
1564 
1565 void NodeInstanceView::token(const TokenCommand &command)
1566 {
1567     if (!model())
1568         return;
1569 
1570     QVector<ModelNode> nodeVector;
1571 
1572     foreach (const qint32 &instanceId, command.instances()) {
1573         if (hasModelNodeForInternalId(instanceId))
1574             nodeVector.append(modelNodeForInternalId(instanceId));
1575     }
1576 
1577     emitInstanceToken(command.tokenName(), command.tokenNumber(), nodeVector);
1578 }
1579 
1580 void NodeInstanceView::debugOutput(const DebugOutputCommand & command)
1581 {
1582     DocumentMessage error(::QmlDesigner::NodeInstanceView::tr("Qt Quick emulation layer crashed."));
1583     if (command.instanceIds().isEmpty()) {
1584         emitDocumentMessage(command.text());
1585     } else {
1586         QVector<qint32> instanceIdsWithChangedErrors;
1587         foreach (qint32 instanceId, command.instanceIds()) {
1588             NodeInstance instance = instanceForId(instanceId);
1589             if (instance.isValid()) {
1590                 if (instance.setError(command.text()))
1591                     instanceIdsWithChangedErrors.append(instanceId);
1592             } else {
1593                 emitDocumentMessage(command.text());
1594             }
1595         }
1596         emitInstanceErrorChange(instanceIdsWithChangedErrors);
1597     }
1598 }
1599 
1600 void NodeInstanceView::sendToken(const QString &token, int number, const QVector<ModelNode> &nodeVector)
1601 {
1602     QVector<qint32> instanceIdVector;
1603     foreach (const ModelNode &node, nodeVector)
1604         instanceIdVector.append(node.internalId());
1605 
1606     m_nodeInstanceServer->token(TokenCommand(token, number, instanceIdVector));
1607 }
1608 
1609 void NodeInstanceView::selectionChanged(const ChangeSelectionCommand &command)
1610 {
1611     clearSelectedModelNodes();
1612     foreach (const qint32 &instanceId, command.instanceIds()) {
1613         if (hasModelNodeForInternalId(instanceId))
1614             selectModelNode(modelNodeForInternalId(instanceId));
1615     }
1616 }
1617 
1618 void NodeInstanceView::handlePuppetToCreatorCommand(const PuppetToCreatorCommand &command)
1619 {
1620     if (command.type() == PuppetToCreatorCommand::Edit3DToolState) {
1621         if (m_nodeInstanceServer) {
1622             auto data = qvariant_cast<QVariantList>(command.data());
1623             if (data.size() == 3) {
1624                 QString qmlId = data[0].toString();
1625                 m_edit3DToolStates[model()->fileUrl()][qmlId].insert(data[1].toString(), data[2]);
1626             }
1627         }
1628     } else if (command.type() == PuppetToCreatorCommand::Render3DView) {
1629         ImageContainer container = qvariant_cast<ImageContainer>(command.data());
1630         if (!container.image().isNull())
1631             emitRenderImage3DChanged(container.image());
1632     } else if (command.type() == PuppetToCreatorCommand::ActiveSceneChanged) {
1633         const auto sceneState = qvariant_cast<QVariantMap>(command.data());
1634         emitUpdateActiveScene3D(sceneState);
1635     } else if (command.type() == PuppetToCreatorCommand::RenderModelNodePreviewImage) {
1636         ImageContainer container = qvariant_cast<ImageContainer>(command.data());
1637         QImage image = container.image();
1638         if (hasModelNodeForInternalId(container.instanceId()) && !image.isNull()) {
1639             auto node = modelNodeForInternalId(container.instanceId());
1640             if (node.isValid()) {
1641 #ifndef QMLDESIGNER_TEST
1642                 const double ratio = QmlDesignerPlugin::formEditorDevicePixelRatio();
1643 #else
1644                 const double ratio = 1;
1645 #endif
1646                 const int dim = Constants::MODELNODE_PREVIEW_IMAGE_DIMENSIONS * ratio;
1647                 if (image.height() != dim || image.width() != dim)
1648                     image = image.scaled(dim, dim, Qt::KeepAspectRatio);
1649                 image.setDevicePixelRatio(ratio);
1650                 updatePreviewImageForNode(node, image);
1651             }
1652         }
1653     } else if (command.type() == PuppetToCreatorCommand::Import3DSupport) {
1654         const QVariantMap supportMap = qvariant_cast<QVariantMap>(command.data());
1655         emitImport3DSupportChanged(supportMap);
1656     }
1657 }
1658 
1659 std::unique_ptr<NodeInstanceServerProxy> NodeInstanceView::createNodeInstanceServerProxy()
1660 {
1661     return std::make_unique<NodeInstanceServerProxy>(this, m_currentTarget, m_connectionManager);
1662 }
1663 
1664 void NodeInstanceView::selectedNodesChanged(const QList<ModelNode> &selectedNodeList,
1665                                             const QList<ModelNode> & /*lastSelectedNodeList*/)
1666 {
1667     m_nodeInstanceServer->changeSelection(createChangeSelectionCommand(selectedNodeList));
1668     m_rotBlockTimer.start();
1669 }
1670 
1671 void NodeInstanceView::sendInputEvent(QInputEvent *e) const
1672 {
1673     m_nodeInstanceServer->inputEvent(InputEventCommand(e));
1674 }
1675 
1676 void NodeInstanceView::view3DAction(const View3DActionCommand &command)
1677 {
1678     m_nodeInstanceServer->view3DAction(command);
1679 }
1680 
1681 void NodeInstanceView::requestModelNodePreviewImage(const ModelNode &node, const ModelNode &renderNode)
1682 {
1683     if (node.isValid()) {
1684         auto instance = instanceForModelNode(node);
1685         if (instance.isValid()) {
1686             qint32 renderItemId = -1;
1687             QString componentPath;
1688             if (renderNode.isValid()) {
1689                 auto renderInstance = instanceForModelNode(renderNode);
1690                 if (renderInstance.isValid())
1691                     renderItemId = renderInstance.instanceId();
1692                 if (renderNode.isComponent())
1693                     componentPath = renderNode.metaInfo().componentFileName();
1694             } else if (node.isComponent()) {
1695                 componentPath = node.metaInfo().componentFileName();
1696             }
1697 #ifndef QMLDESIGNER_TEST
1698                 const double ratio = QmlDesignerPlugin::formEditorDevicePixelRatio();
1699 #else
1700                 const double ratio = 1;
1701 #endif
1702             const int dim = Constants::MODELNODE_PREVIEW_IMAGE_DIMENSIONS * ratio;
1703             m_nodeInstanceServer->requestModelNodePreviewImage(
1704                         RequestModelNodePreviewImageCommand(instance.instanceId(), QSize(dim, dim),
1705                                                             componentPath, renderItemId));
1706         }
1707     }
1708 }
1709 
1710 void NodeInstanceView::edit3DViewResized(const QSize &size) const
1711 {
1712     m_nodeInstanceServer->update3DViewState(Update3dViewStateCommand(size));
1713 }
1714 
1715 void NodeInstanceView::timerEvent(QTimerEvent *event)
1716 {
1717     if (m_restartProcessTimerId == event->timerId())
1718         restartProcess();
1719 }
1720 
1721 QVariant NodeInstanceView::modelNodePreviewImageDataToVariant(const ModelNodePreviewImageData &imageData)
1722 {
1723     static const QPixmap placeHolder(":/navigator/icon/tooltip_placeholder.png");
1724 
1725     QVariantMap map;
1726     map.insert("type", imageData.type);
1727     if (imageData.pixmap.isNull())
1728         map.insert("pixmap", placeHolder);
1729     else
1730         map.insert("pixmap", QVariant::fromValue<QPixmap>(imageData.pixmap));
1731     map.insert("id", imageData.id);
1732     map.insert("info", imageData.info);
1733     return map;
1734 }
1735 
1736 QVariant NodeInstanceView::previewImageDataForImageNode(const ModelNode &modelNode)
1737 {
1738     if (!modelNode.isValid())
1739         return {};
1740 
1741     VariantProperty prop = modelNode.variantProperty("source");
1742     QString imageSource = prop.value().toString();
1743 
1744     ModelNodePreviewImageData imageData;
1745     imageData.id = modelNode.id();
1746     imageData.type = QString::fromLatin1(modelNode.type());
1747 #ifndef QMLDESIGNER_TEST
1748                 const double ratio = QmlDesignerPlugin::formEditorDevicePixelRatio();
1749 #else
1750                 const double ratio = 1;
1751 #endif
1752 
1753     if (imageSource.isEmpty() && modelNode.isSubclassOf("QtQuick3D.Texture")) {
1754         // Texture node may have sourceItem instead
1755         BindingProperty binding = modelNode.bindingProperty("sourceItem");
1756         if (binding.isValid()) {
1757             ModelNode boundNode = binding.resolveToModelNode();
1758             if (boundNode.isValid()) {
1759                 // If bound node is a component, fall back to component render mechanism, as
1760                 // QmlItemNode::instanceRenderPixmap() often includes unnecessary empty space
1761                 // for those
1762                 if (boundNode.isComponent()) {
1763                     return previewImageDataForGenericNode(modelNode, boundNode);
1764                 } else {
1765                     QmlItemNode itemNode(boundNode);
1766                     const int dim = Constants::MODELNODE_PREVIEW_IMAGE_DIMENSIONS * ratio;
1767                     imageData.pixmap = itemNode.instanceRenderPixmap().scaled(dim, dim, Qt::KeepAspectRatio);
1768                     imageData.pixmap.setDevicePixelRatio(ratio);
1769 
1770                 }
1771                 imageData.info = ::QmlDesigner::NodeInstanceView::tr("Source item: %1")
1772                                      .arg(boundNode.id());
1773             }
1774         }
1775     } else {
1776         if (imageSource.isEmpty() && modelNode.isComponent()) {
1777             // Image component has no custom source set, so fall back to component rendering to get
1778             // the default component image.
1779             return previewImageDataForGenericNode(modelNode, {});
1780         }
1781 
1782         QFileInfo imageFi(imageSource);
1783         if (imageFi.isRelative())
1784             imageSource = QFileInfo(modelNode.model()->fileUrl().toLocalFile()).dir().absoluteFilePath(imageSource);
1785 
1786         imageFi = QFileInfo(imageSource);
1787         QDateTime modified = imageFi.lastModified();
1788 
1789         bool reload = true;
1790         if (m_imageDataMap.contains(imageData.id)) {
1791             imageData = m_imageDataMap[imageData.id];
1792             if (modified == imageData.time)
1793                 reload = false;
1794         }
1795 
1796         if (reload) {
1797             QPixmap originalPixmap;
1798             if (modelNode.isSubclassOf("Qt.SafeRenderer.SafeRendererPicture")) {
1799                 QPicture picture;
1800                 picture.load(imageSource);
1801                 if (!picture.isNull()) {
1802                     QImage paintImage(picture.width(), picture.height(), QImage::Format_ARGB32);
1803                     paintImage.fill(Qt::transparent);
1804                     QPainter painter(&paintImage);
1805                     painter.drawPicture(0, 0, picture);
1806                     painter.end();
1807                     originalPixmap = QPixmap::fromImage(paintImage);
1808                 }
1809             } else {
1810 #ifndef QMLDESIGNER_TEST
1811                 if (imageFi.suffix() == "hdr")
1812                     originalPixmap = HdrImage{imageSource}.toPixmap();
1813                 else
1814 #endif
1815                     originalPixmap.load(imageSource);
1816             }
1817             if (!originalPixmap.isNull()) {
1818                 const int dim = Constants::MODELNODE_PREVIEW_IMAGE_DIMENSIONS * ratio;
1819                 imageData.pixmap = originalPixmap.scaled(dim, dim, Qt::KeepAspectRatio);
1820                 imageData.pixmap.setDevicePixelRatio(ratio);
1821 
1822                 double imgSize = double(imageFi.size());
1823                 static QStringList units({::QmlDesigner::NodeInstanceView::tr("B"),
1824                                           ::QmlDesigner::NodeInstanceView::tr("KB"),
1825                                           ::QmlDesigner::NodeInstanceView::tr("MB"),
1826                                           ::QmlDesigner::NodeInstanceView::tr("GB")});
1827                 int unitIndex = 0;
1828                 while (imgSize > 1024. && unitIndex < units.size() - 1) {
1829                     ++unitIndex;
1830                     imgSize /= 1024.;
1831                 }
1832                 imageData.info = QStringLiteral("%1 x %2\n%3%4 (%5)").arg(originalPixmap.width()).arg(originalPixmap.height())
1833                         .arg(QString::number(imgSize, 'g', 3)).arg(units[unitIndex]).arg(imageFi.suffix());
1834                 m_imageDataMap.insert(imageData.id, imageData);
1835             }
1836         }
1837     }
1838 
1839     return modelNodePreviewImageDataToVariant(imageData);
1840 }
1841 
1842 void NodeInstanceView::startNanotrace()
1843 {
1844     NANOTRACE_INIT("QmlDesigner", "MainThread", "nanotrace_qmldesigner.json");
1845     m_connectionManager.writeCommand(QVariant::fromValue(StartNanotraceCommand(QDir::currentPath())));
1846 }
1847 
1848 void NodeInstanceView::endNanotrace()
1849 {
1850     NANOTRACE_SHUTDOWN();
1851     m_connectionManager.writeCommand(QVariant::fromValue(EndNanotraceCommand()) );
1852 }
1853 
1854 QVariant NodeInstanceView::previewImageDataForGenericNode(const ModelNode &modelNode, const ModelNode &renderNode)
1855 {
1856     ModelNodePreviewImageData imageData;
1857 
1858     // We need puppet to generate the image, which needs to be asynchronous.
1859     // Until the image is ready, we show a placeholder
1860     const QString id = modelNode.id();
1861     if (m_imageDataMap.contains(id)) {
1862         imageData = m_imageDataMap[id];
1863     } else {
1864         imageData.type = QString::fromLatin1(modelNode.type());
1865         imageData.id = id;
1866         m_imageDataMap.insert(id, imageData);
1867     }
1868     requestModelNodePreviewImage(modelNode, renderNode);
1869 
1870     return modelNodePreviewImageDataToVariant(imageData);
1871 }
1872 
1873 void NodeInstanceView::updatePreviewImageForNode(const ModelNode &modelNode, const QImage &image)
1874 {
1875     QPixmap pixmap = QPixmap::fromImage(image);
1876     if (m_imageDataMap.contains(modelNode.id()))
1877         m_imageDataMap[modelNode.id()].pixmap = pixmap;
1878     emitModelNodelPreviewPixmapChanged(modelNode, pixmap);
1879 }
1880 
1881 void NodeInstanceView::updateWatcher(const QString &path)
1882 {
1883     QString rootPath;
1884     QStringList oldFiles;
1885     QStringList oldDirs;
1886     QStringList newFiles;
1887     QStringList newDirs;
1888 
1889     const QStringList files = m_fileSystemWatcher->files();
1890     const QStringList directories = m_fileSystemWatcher->directories();
1891     if (path.isEmpty()) {
1892         // Do full update
1893         rootPath = QFileInfo(model()->fileUrl().toLocalFile()).absolutePath();
1894         if (!directories.isEmpty())
1895             m_fileSystemWatcher->removePaths(directories);
1896         if (!files.isEmpty())
1897             m_fileSystemWatcher->removePaths(files);
1898     } else {
1899         rootPath = path;
1900         for (const auto &file : files) {
1901             if (file.startsWith(path))
1902                 oldFiles.append(file);
1903         }
1904         for (const auto &directory : directories) {
1905             if (directory.startsWith(path))
1906                 oldDirs.append(directory);
1907         }
1908     }
1909 
1910     newDirs.append(rootPath);
1911 
1912     QDirIterator dirIterator(rootPath, {}, QDir::Dirs | QDir::NoDotAndDotDot, QDirIterator::Subdirectories);
1913     while (dirIterator.hasNext())
1914         newDirs.append(dirIterator.next());
1915 
1916     // Common shader suffixes
1917     static const QStringList filterList {"*.frag", "*.vert",
1918                                          "*.glsl", "*.glslv", "*.glslf",
1919                                          "*.vsh","*.fsh"};
1920 
1921     QDirIterator fileIterator(rootPath, filterList, QDir::Files, QDirIterator::Subdirectories);
1922     while (fileIterator.hasNext())
1923         newFiles.append(fileIterator.next());
1924 
1925     if (oldDirs != newDirs) {
1926         if (!oldDirs.isEmpty())
1927             m_fileSystemWatcher->removePaths(oldDirs);
1928         if (!newDirs.isEmpty())
1929             m_fileSystemWatcher->addPaths(newDirs);
1930     }
1931 
1932     if (newFiles != oldFiles) {
1933         if (!oldFiles.isEmpty())
1934             m_fileSystemWatcher->removePaths(oldFiles);
1935         if (!newFiles.isEmpty())
1936             m_fileSystemWatcher->addPaths(newFiles);
1937 
1938         for (const auto &newFile : qAsConst(newFiles)) {
1939             if (!oldFiles.contains(newFile))
1940                 m_pendingQsbTargets.insert(newFile);
1941         }
1942 
1943         if (!m_pendingQsbTargets.isEmpty())
1944             m_generateQsbFilesTimer.start();
1945     }
1946 }
1947 
1948 void NodeInstanceView::handleQsbProcessExit(Utils::QtcProcess *qsbProcess, const QString &shader)
1949 {
1950     --m_remainingQsbTargets;
1951 
1952     QString errStr = qsbProcess->errorString();
1953     QByteArray stdErrStr = qsbProcess->readAllStandardError();
1954 
1955     if (!errStr.isEmpty() || !stdErrStr.isEmpty()) {
1956         Core::MessageManager::writeSilently(
1957             QCoreApplication::translate("QmlDesigner::NodeInstanceView",
1958                                         "Failed to generate QSB file for: %1")
1959                 .arg(shader));
1960         if (!errStr.isEmpty())
1961             Core::MessageManager::writeSilently(errStr);
1962         if (!stdErrStr.isEmpty())
1963             Core::MessageManager::writeSilently(QString::fromUtf8(stdErrStr));
1964     }
1965 
1966     if (m_remainingQsbTargets <= 0)
1967         m_resetTimer.start();
1968 
1969     delete qsbProcess;
1970 }
1971 
1972 void NodeInstanceView::handleShaderChanges()
1973 {
1974     m_remainingQsbTargets += m_pendingQsbTargets.size();
1975 
1976     for (const auto &shader : qAsConst(m_pendingQsbTargets)) {
1977         // Run qsb for changed shader file
1978         if (!m_qsbPath.isEmpty() && !shader.isEmpty()) {
1979             const Utils::FilePath sourceFile = Utils::FilePath::fromString(shader);
1980             const Utils::FilePath srcPath = sourceFile.absolutePath();
1981             const Utils::FilePath outPath = Utils::FilePath::fromString(shader + ".qsb");
1982 
1983             if (!sourceFile.exists() || (outPath.exists() && outPath.lastModified() > sourceFile.lastModified())) {
1984                 --m_remainingQsbTargets;
1985                 continue;
1986             }
1987 
1988             // Run QSB with same parameters as Qt build does
1989             // TODO: Parameters should be configurable (QDS-6590)
1990             const QStringList args = {"-s", "--glsl", "100 es,120,150", "--hlsl", "50", "--msl", "12",
1991                                       "-o", outPath.toString(), shader};
1992             auto qsbProcess = new Utils::QtcProcess;
1993             qsbProcess->setWorkingDirectory(srcPath);
1994             qsbProcess->setCommand({m_qsbPath, args});
1995             qsbProcess->start();
1996 
1997             if (!qsbProcess->waitForStarted()) {
1998                 handleQsbProcessExit(qsbProcess, shader);
1999                 continue;
2000             }
2001 
2002             if (qsbProcess->state() == QProcess::Running) {
2003                 connect(qsbProcess, &Utils::QtcProcess::finished,
2004                         [thisView = QPointer<NodeInstanceView>(this), qsbProcess, shader]() {
2005                     if (thisView)
2006                         thisView->handleQsbProcessExit(qsbProcess, shader);
2007                 });
2008             } else {
2009                 handleQsbProcessExit(qsbProcess, shader);
2010             }
2011         }
2012     }
2013 
2014     m_pendingQsbTargets.clear();
2015 }
2016 
2017 void NodeInstanceView::updateRotationBlocks()
2018 {
2019     if (!model())
2020         return;
2021 
2022     QList<ModelNode> qml3DNodes;
2023     QSet<ModelNode> rotationKeyframeTargets;
2024     bool groupsResolved = false;
2025     const PropertyName targetPropName {"target"};
2026     const PropertyName propertyPropName {"property"};
2027     const PropertyName rotationPropName {"rotation"};
2028     const QList<ModelNode> selectedNodes = selectedModelNodes();
2029     for (const auto &node : selectedNodes) {
2030         if (Qml3DNode::isValidQml3DNode(node)) {
2031             if (!groupsResolved) {
2032                 const QList<ModelNode> keyframeGroups = allModelNodesOfType("KeyframeGroup");
2033                 for (const auto &kfgNode : keyframeGroups) {
2034                     if (kfgNode.isValid()) {
2035                         VariantProperty varProp = kfgNode.variantProperty(propertyPropName);
2036                         if (varProp.isValid() && varProp.value().value<PropertyName>() == rotationPropName) {
2037                             BindingProperty bindProp = kfgNode.bindingProperty(targetPropName);
2038                             if (bindProp.isValid()) {
2039                                 ModelNode targetNode = bindProp.resolveToModelNode();
2040                                 if (Qml3DNode::isValidQml3DNode(targetNode))
2041                                     rotationKeyframeTargets.insert(targetNode);
2042                             }
2043                         }
2044                     }
2045                 }
2046                 groupsResolved = true;
2047             }
2048             qml3DNodes.append(node);
2049         }
2050     }
2051     if (!qml3DNodes.isEmpty()) {
2052         const PropertyName auxDataProp {"rotBlocked@Internal"};
2053         for (const auto &node : qAsConst(qml3DNodes)) {
2054             if (rotationKeyframeTargets.contains(node))
2055                 node.setAuxiliaryData(auxDataProp, true);
2056             else
2057                 node.setAuxiliaryData(auxDataProp, false);
2058         }
2059     }
2060 }
2061 
2062 void NodeInstanceView::maybeResetOnPropertyChange(const PropertyName &name, const ModelNode &node,
2063                                                   PropertyChangeFlags flags)
2064 {
2065     bool reset = false;
2066     if (flags & AbstractView::PropertiesAdded
2067             && name == "model" && (node.isSubclassOf("QtQuick.Repeater")
2068                                    || node.isSubclassOf("QtQuick3D.Repeater3D"))) {
2069         // TODO: This is a workaround for QTBUG-97583 (2D) and QTBUG-97586 (3D):
2070         //       Reset puppet when repeater model is first added, if there is already a delegate
2071         if (node.hasProperty("delegate"))
2072             reset = true;
2073     } else if (name == "shader" && node.isSubclassOf("QtQuick3D.Shader")) {
2074         reset = true;
2075     }
2076     if (reset)
2077         resetPuppet();
2078 }
2079 
2080 QList<NodeInstance> NodeInstanceView::loadInstancesFromCache(const QList<ModelNode> &nodeList,
2081                                                              const NodeInstanceCacheData &cache)
2082 {
2083     QList<NodeInstance> instanceList;
2084 
2085     auto previews = cache.previewImages;
2086     auto iterator = previews.begin();
2087     while (iterator != previews.end()) {
2088         if (iterator.key().isValid())
2089             m_statePreviewImage.insert(iterator.key(), iterator.value());
2090         iterator++;
2091     }
2092 
2093     for (const ModelNode &node : std::as_const(nodeList)) {
2094         NodeInstance instance = cache.instances.value(node);
2095         if (instance.isValid())
2096             insertInstanceRelationships(instance);
2097         else
2098             instance = loadNode(node);
2099 
2100         if (node.isRootNode())
2101             m_rootNodeInstance = instance;
2102         if (!isSkippedNode(node))
2103             instanceList.append(instanceForModelNode(node));
2104     }
2105 
2106     return instanceList;
2107 }
2108 } // namespace QmlDesigner
