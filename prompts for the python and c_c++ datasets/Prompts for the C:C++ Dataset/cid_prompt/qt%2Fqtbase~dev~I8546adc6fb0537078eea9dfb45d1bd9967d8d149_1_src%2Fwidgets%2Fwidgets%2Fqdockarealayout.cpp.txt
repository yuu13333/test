Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2015 Olivier Goffart <ogoffart@woboq.com>
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtWidgets module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "QtWidgets/qapplication.h"
42 #include "QtWidgets/qwidget.h"
43 #if QT_CONFIG(tabbar)
44 #include "QtWidgets/qtabbar.h"
45 #endif
46 #include "QtWidgets/qstyle.h"
47 #include "QtWidgets/qapplication.h"
48 #include "QtCore/qvariant.h"
49 #include "qdockarealayout_p.h"
50 #include "qdockwidget.h"
51 #include "qmainwindow.h"
52 #include "qwidgetanimator_p.h"
53 #include "qmainwindowlayout_p.h"
54 #include "qmenu_p.h"
55 #include "qdockwidget_p.h"
56 #include <private/qlayoutengine_p.h>
57 
58 #include <qpainter.h>
59 #include <qstyleoption.h>
60 
61 QT_BEGIN_NAMESPACE
62 
63 // qmainwindow.cpp
64 extern QMainWindowLayout *qt_mainwindow_layout(const QMainWindow *window);
65 
66 enum { StateFlagVisible = 1, StateFlagFloating = 2 };
67 
68 /******************************************************************************
69 ** QPlaceHolderItem
70 */
71 
72 QPlaceHolderItem::QPlaceHolderItem(QWidget *w)
73 {
74     objectName = w->objectName();
75     hidden = w->isHidden();
76     window = w->isWindow();
77     if (window)
78         topLevelRect = w->geometry();
79 }
80 
81 /******************************************************************************
82 ** QDockAreaLayoutItem
83 */
84 
85 QDockAreaLayoutItem::QDockAreaLayoutItem(QLayoutItem *_widgetItem)
86     : widgetItem(_widgetItem), subinfo(nullptr), placeHolderItem(nullptr), pos(0), size(-1), flags(NoFlags)
87 {
88 }
89 
90 QDockAreaLayoutItem::QDockAreaLayoutItem(QDockAreaLayoutInfo *_subinfo)
91     : widgetItem(nullptr), subinfo(_subinfo), placeHolderItem(nullptr), pos(0), size(-1), flags(NoFlags)
92 {
93 }
94 
95 QDockAreaLayoutItem::QDockAreaLayoutItem(QPlaceHolderItem *_placeHolderItem)
96     : widgetItem(nullptr), subinfo(nullptr), placeHolderItem(_placeHolderItem), pos(0), size(-1), flags(NoFlags)
97 {
98 }
99 
100 QDockAreaLayoutItem::QDockAreaLayoutItem(const QDockAreaLayoutItem &other)
101     : widgetItem(other.widgetItem), subinfo(nullptr), placeHolderItem(nullptr), pos(other.pos),
102         size(other.size), flags(other.flags)
103 {
104     if (other.subinfo != nullptr)
105         subinfo = new QDockAreaLayoutInfo(*other.subinfo);
106     else if (other.placeHolderItem != nullptr)
107         placeHolderItem = new QPlaceHolderItem(*other.placeHolderItem);
108 }
109 
110 QDockAreaLayoutItem::~QDockAreaLayoutItem()
111 {
112     delete subinfo;
113     delete placeHolderItem;
114 }
115 
116 bool QDockAreaLayoutItem::skip() const
117 {
118     if (placeHolderItem != nullptr)
119         return true;
120 
121     if (flags & GapItem)
122         return false;
123 
124     if (widgetItem != nullptr)
125         return widgetItem->isEmpty();
126 
127     if (subinfo != nullptr) {
128         for (int i = 0; i < subinfo->item_list.count(); ++i) {
129             if (!subinfo->item_list.at(i).skip())
130                 return false;
131         }
132     }
133 
134     return true;
135 }
136 
137 QSize QDockAreaLayoutItem::minimumSize() const
138 {
139     if (widgetItem)
140         return widgetItem->minimumSize().grownBy(widgetItem->widget()->contentsMargins());
141     if (subinfo != nullptr)
142         return subinfo->minimumSize();
143     return QSize(0, 0);
144 }
145 
146 QSize QDockAreaLayoutItem::maximumSize() const
147 {
148     if (widgetItem)
149         return widgetItem->maximumSize().grownBy(widgetItem->widget()->contentsMargins());
150     if (subinfo != nullptr)
151         return subinfo->maximumSize();
152     return QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
153 }
154 
155 bool QDockAreaLayoutItem::hasFixedSize(Qt::Orientation o) const
156 {
157     return perp(o, minimumSize()) == perp(o, maximumSize());
158 }
159 
160 bool QDockAreaLayoutItem::expansive(Qt::Orientation o) const
161 {
162     if ((flags & GapItem) || placeHolderItem != nullptr)
163         return false;
164     if (widgetItem != nullptr)
165         return ((widgetItem->expandingDirections() & o) == o);
166     if (subinfo != nullptr)
167         return subinfo->expansive(o);
168     return false;
169 }
170 
171 QSize QDockAreaLayoutItem::sizeHint() const
172 {
173     if (placeHolderItem != nullptr)
174         return QSize(0, 0);
175     if (widgetItem)
176         return widgetItem->sizeHint().grownBy(widgetItem->widget()->contentsMargins());
177     if (subinfo != nullptr)
178         return subinfo->sizeHint();
179     return QSize(-1, -1);
180 }
181 
182 QDockAreaLayoutItem
183     &QDockAreaLayoutItem::operator = (const QDockAreaLayoutItem &other)
184 {
185     if (this == &other)
186         return *this;
187 
188     widgetItem = other.widgetItem;
189     if (other.subinfo == nullptr)
190         subinfo = nullptr;
191     else
192         subinfo = new QDockAreaLayoutInfo(*other.subinfo);
193 
194     delete placeHolderItem;
195     if (other.placeHolderItem == nullptr)
196         placeHolderItem = nullptr;
197     else
198         placeHolderItem = new QPlaceHolderItem(*other.placeHolderItem);
199 
200     pos = other.pos;
201     size = other.size;
202     flags = other.flags;
203 
204     return *this;
205 }
206 
207 /******************************************************************************
208 ** QDockAreaLayoutInfo
209 */
210 
211 #if QT_CONFIG(tabbar)
212 static quintptr tabId(const QDockAreaLayoutItem &item)
213 {
214     if (item.widgetItem == nullptr)
215         return 0;
216     return reinterpret_cast<quintptr>(item.widgetItem->widget());
217 }
218 #endif
219 
220 static const int zero = 0;
221 
222 QDockAreaLayoutInfo::QDockAreaLayoutInfo()
223     : sep(&zero), dockPos(QInternal::LeftDock), o(Qt::Horizontal), mainWindow(nullptr)
224 #if QT_CONFIG(tabbar)
225     , tabbed(false), tabBar(nullptr), tabBarShape(QTabBar::RoundedSouth)
226 #endif
227 {
228 }
229 
230 QDockAreaLayoutInfo::QDockAreaLayoutInfo(const int *_sep, QInternal::DockPosition _dockPos,
231                                             Qt::Orientation _o, int tbshape,
232                                             QMainWindow *window)
233     : sep(_sep), dockPos(_dockPos), o(_o), mainWindow(window)
234 #if QT_CONFIG(tabbar)
235     , tabbed(false), tabBar(nullptr), tabBarShape(static_cast<QTabBar::Shape>(tbshape))
236 #endif
237 {
238 #if !QT_CONFIG(tabbar)
239     Q_UNUSED(tbshape);
240 #endif
241 }
242 
243 QSize QDockAreaLayoutInfo::size() const
244 {
245     return isEmpty() ? QSize(0, 0) : rect.size();
246 }
247 
248 void QDockAreaLayoutInfo::clear()
249 {
250     item_list.clear();
251     rect = QRect();
252 #if QT_CONFIG(tabbar)
253     tabbed = false;
254     tabBar = nullptr;
255 #endif
256 }
257 
258 bool QDockAreaLayoutInfo::isEmpty() const
259 {
260     return next(-1) == -1;
261 }
262 
263 bool QDockAreaLayoutInfo::onlyHasPlaceholders() const
264 {
265     for (const QDockAreaLayoutItem &item : item_list) {
266         if (!item.placeHolderItem)
267             return false;
268     }
269 
270     return true;
271 }
272 
273 QSize QDockAreaLayoutInfo::minimumSize() const
274 {
275     if (isEmpty())
276         return QSize(0, 0);
277 
278     int a = 0, b = 0;
279     bool first = true;
280     for (int i = 0; i < item_list.size(); ++i) {
281         const QDockAreaLayoutItem &item = item_list.at(i);
282         if (item.skip())
283             continue;
284 
285         QSize min_size = item.minimumSize();
286 #if QT_CONFIG(tabbar)
287         if (tabbed) {
288             a = qMax(a, pick(o, min_size));
289         } else
290 #endif
291         {
292             if (!first)
293                 a += *sep;
294             a += pick(o, min_size);
295         }
296         b = qMax(b, perp(o, min_size));
297 
298         first = false;
299     }
300 
301     QSize result;
302     rpick(o, result) = a;
303     rperp(o, result) = b;
304 
305 #if QT_CONFIG(tabbar)
306     QSize tbm = tabBarMinimumSize();
307     if (!tbm.isNull()) {
308         switch (tabBarShape) {
309             case QTabBar::RoundedNorth:
310             case QTabBar::RoundedSouth:
311             case QTabBar::TriangularNorth:
312             case QTabBar::TriangularSouth:
313                 result.rheight() += tbm.height();
314                 result.rwidth() = qMax(tbm.width(), result.width());
315                 break;
316             case QTabBar::RoundedEast:
317             case QTabBar::RoundedWest:
318             case QTabBar::TriangularEast:
319             case QTabBar::TriangularWest:
320                 result.rheight() = qMax(tbm.height(), result.height());
321                 result.rwidth() += tbm.width();
322                 break;
323             default:
324                 break;
325         }
326     }
327 #endif // QT_CONFIG(tabbar)
328 
329     return result;
330 }
331 
332 QSize QDockAreaLayoutInfo::maximumSize() const
333 {
334     if (isEmpty())
335         return QSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
336 
337     int a = 0, b = QWIDGETSIZE_MAX;
338 #if QT_CONFIG(tabbar)
339     if (tabbed)
340         a = QWIDGETSIZE_MAX;
341 #endif
342 
343     int min_perp = 0;
344 
345     bool first = true;
346     for (int i = 0; i < item_list.size(); ++i) {
347         const QDockAreaLayoutItem &item = item_list.at(i);
348         if (item.skip())
349             continue;
350 
351         QSize max_size = item.maximumSize();
352         min_perp = qMax(min_perp, perp(o, item.minimumSize()));
353 
354 #if QT_CONFIG(tabbar)
355         if (tabbed) {
356             a = qMin(a, pick(o, max_size));
357         } else
358 #endif
359         {
360             if (!first)
361                 a += *sep;
362             a += pick(o, max_size);
363         }
364         b = qMin(b, perp(o, max_size));
365 
366         a = qMin(a, int(QWIDGETSIZE_MAX));
367         b = qMin(b, int(QWIDGETSIZE_MAX));
368 
369         first = false;
370     }
371 
372     b = qMax(b, min_perp);
373 
374     QSize result;
375     rpick(o, result) = a;
376     rperp(o, result) = b;
377 
378 #if QT_CONFIG(tabbar)
379     QSize tbh = tabBarSizeHint();
380     if (!tbh.isNull()) {
381         switch (tabBarShape) {
382             case QTabBar::RoundedNorth:
383             case QTabBar::RoundedSouth:
384                 result.rheight() += tbh.height();
385                 break;
386             case QTabBar::RoundedEast:
387             case QTabBar::RoundedWest:
388                 result.rwidth() += tbh.width();
389                 break;
390             default:
391                 break;
392         }
393     }
394 #endif // QT_CONFIG(tabbar)
395 
396     return result;
397 }
398 
399 QSize QDockAreaLayoutInfo::sizeHint() const
400 {
401     if (isEmpty())
402         return QSize(0, 0);
403 
404     int a = 0, b = 0;
405     int min_perp = 0;
406     int max_perp = QWIDGETSIZE_MAX;
407     const QDockAreaLayoutItem *previous = nullptr;
408     for (int i = 0; i < item_list.size(); ++i) {
409         const QDockAreaLayoutItem &item = item_list.at(i);
410         if (item.skip())
411             continue;
412 
413         bool gap = item.flags & QDockAreaLayoutItem::GapItem;
414 
415         QSize size_hint = item.sizeHint();
416         min_perp = qMax(min_perp, perp(o, item.minimumSize()));
417         max_perp = qMin(max_perp, perp(o, item.maximumSize()));
418 
419 #if QT_CONFIG(tabbar)
420         if (tabbed) {
421             a = qMax(a, gap ? item.size : pick(o, size_hint));
422         } else
423 #endif
424         {
425             if (previous && !gap && !(previous->flags &  QDockAreaLayoutItem::GapItem)
426                 && !previous->hasFixedSize(o)) {
427                 a += *sep;
428             }
429             a += gap ? item.size : pick(o, size_hint);
430         }
431         b = qMax(b, perp(o, size_hint));
432 
433         previous = &item;
434     }
435 
436     max_perp = qMax(max_perp, min_perp);
437     b = qMax(b, min_perp);
438     b = qMin(b, max_perp);
439 
440     QSize result;
441     rpick(o, result) = a;
442     rperp(o, result) = b;
443 
444 #if QT_CONFIG(tabbar)
445     if (tabbed) {
446         QSize tbh = tabBarSizeHint();
447         switch (tabBarShape) {
448             case QTabBar::RoundedNorth:
449             case QTabBar::RoundedSouth:
450             case QTabBar::TriangularNorth:
451             case QTabBar::TriangularSouth:
452                 result.rheight() += tbh.height();
453                 result.rwidth() = qMax(tbh.width(), result.width());
454                 break;
455             case QTabBar::RoundedEast:
456             case QTabBar::RoundedWest:
457             case QTabBar::TriangularEast:
458             case QTabBar::TriangularWest:
459                 result.rheight() = qMax(tbh.height(), result.height());
460                 result.rwidth() += tbh.width();
461                 break;
462             default:
463                 break;
464         }
465     }
466 #endif // QT_CONFIG(tabbar)
467 
468     return result;
469 }
470 
471 bool QDockAreaLayoutInfo::expansive(Qt::Orientation o) const
472 {
473     for (int i = 0; i < item_list.size(); ++i) {
474         if (item_list.at(i).expansive(o))
475             return true;
476     }
477     return false;
478 }
479 
480 /* QDockAreaLayoutInfo::maximumSize() doesn't return the real max size. For example,
481    if the layout is empty, it returns QWIDGETSIZE_MAX. This is so that empty dock areas
482    don't constrain the size of the QMainWindow, but sometimes we really need to know the
483    maximum size. Also, these functions take into account widgets that want to keep their
484    size (f.ex. when they are hidden and then shown, they should not change size).
485 */
486 
487 static int realMinSize(const QDockAreaLayoutInfo &info)
488 {
489     int result = 0;
490     bool first = true;
491     for (int i = 0; i < info.item_list.size(); ++i) {
492         const QDockAreaLayoutItem &item = info.item_list.at(i);
493         if (item.skip())
494             continue;
495 
496         int min = 0;
497         if ((item.flags & QDockAreaLayoutItem::KeepSize) && item.size != -1)
498             min = item.size;
499         else
500             min = pick(info.o, item.minimumSize());
501 
502         if (!first)
503             result += *info.sep;
504         result += min;
505 
506         first = false;
507     }
508 
509     return result;
510 }
511 
512 static int realMaxSize(const QDockAreaLayoutInfo &info)
513 {
514     int result = 0;
515     bool first = true;
516     for (int i = 0; i < info.item_list.size(); ++i) {
517         const QDockAreaLayoutItem &item = info.item_list.at(i);
518         if (item.skip())
519             continue;
520 
521         int max = 0;
522         if ((item.flags & QDockAreaLayoutItem::KeepSize) && item.size != -1)
523             max = item.size;
524         else
525             max = pick(info.o, item.maximumSize());
526 
527         if (!first)
528             result += *info.sep;
529         result += max;
530 
531         if (result >= QWIDGETSIZE_MAX)
532             return QWIDGETSIZE_MAX;
533 
534         first = false;
535     }
536 
537     return result;
538 }
539 
540 void QDockAreaLayoutInfo::fitItems()
541 {
542 #if QT_CONFIG(tabbar)
543     if (tabbed) {
544         return;
545     }
546 #endif
547 
548     QList<QLayoutStruct> layout_struct_list(item_list.size() * 2);
549     int j = 0;
550 
551     int size = pick(o, rect.size());
552     int min_size = realMinSize(*this);
553     int max_size = realMaxSize(*this);
554     int last_index = -1;
555 
556     const QDockAreaLayoutItem *previous = nullptr;
557     for (int i = 0; i < item_list.size(); ++i) {
558         QDockAreaLayoutItem &item = item_list[i];
559         if (item.skip())
560             continue;
561 
562         bool gap = item.flags & QDockAreaLayoutItem::GapItem;
563         if (previous && !gap) {
564             if (!(previous->flags & QDockAreaLayoutItem::GapItem)) {
565                 QLayoutStruct &ls = layout_struct_list[j++];
566                 ls.init();
567                 ls.minimumSize = ls.maximumSize = ls.sizeHint = previous->hasFixedSize(o) ? 0 : *sep;
568                 ls.empty = false;
569             }
570         }
571 
572         if (item.flags & QDockAreaLayoutItem::KeepSize) {
573             // Check if the item can keep its size, without violating size constraints
574             // of other items.
575 
576             if (size < min_size) {
577                 // There is too little space to keep this widget's size
578                 item.flags &= ~QDockAreaLayoutItem::KeepSize;
579                 min_size -= item.size;
580                 min_size += pick(o, item.minimumSize());
581                 min_size = qMax(0, min_size);
582             } else if (size > max_size) {
583                 // There is too much space to keep this widget's size
584                 item.flags &= ~QDockAreaLayoutItem::KeepSize;
585                 max_size -= item.size;
586                 max_size += pick(o, item.maximumSize());
587                 max_size = qMin<int>(QWIDGETSIZE_MAX, max_size);
588             }
589         }
590 
591         last_index = j;
592         QLayoutStruct &ls = layout_struct_list[j++];
593         ls.init();
594         ls.empty = false;
595         if (item.flags & QDockAreaLayoutItem::KeepSize) {
596             ls.minimumSize = ls.maximumSize = ls.sizeHint = item.size;
597             ls.expansive = false;
598             ls.stretch = 0;
599         } else {
600             ls.maximumSize = pick(o, item.maximumSize());
601             ls.expansive = item.expansive(o);
602             ls.minimumSize = pick(o, item.minimumSize());
603             ls.sizeHint = item.size == -1 ? pick(o, item.sizeHint()) : item.size;
604             ls.stretch = ls.expansive ? ls.sizeHint : 0;
605         }
606 
607         item.flags &= ~QDockAreaLayoutItem::KeepSize;
608         previous = &item;
609     }
610     layout_struct_list.resize(j);
611 
612     // If there is more space than the widgets can take (due to maximum size constraints),
613     // we detect it here and stretch the last widget to take up the rest of the space.
614     if (size > max_size && last_index != -1) {
615         layout_struct_list[last_index].maximumSize = QWIDGETSIZE_MAX;
616         layout_struct_list[last_index].expansive = true;
617     }
618 
619     qGeomCalc(layout_struct_list, 0, j, pick(o, rect.topLeft()), size, 0);
620 
621     j = 0;
622     bool prev_gap = false;
623     bool first = true;
624     for (int i = 0; i < item_list.size(); ++i) {
625         QDockAreaLayoutItem &item = item_list[i];
626         if (item.skip())
627             continue;
628 
629         bool gap = item.flags & QDockAreaLayoutItem::GapItem;
630         if (!first && !gap && !prev_gap)
631             ++j;
632 
633         const QLayoutStruct &ls = layout_struct_list.at(j++);
634         item.size = ls.size;
635         item.pos = ls.pos;
636 
637         if (item.subinfo != nullptr) {
638             item.subinfo->rect = itemRect(i);
639             item.subinfo->fitItems();
640         }
641 
642         prev_gap = gap;
643         first = false;
644     }
645 }
646 
647 static QInternal::DockPosition dockPosHelper(const QRect &rect, const QPoint &_pos,
648                                         Qt::Orientation o,
649                                         bool nestingEnabled,
650                                         QDockAreaLayoutInfo::TabMode tabMode)
651 {
652     if (tabMode == QDockAreaLayoutInfo::ForceTabs)
653         return QInternal::DockCount;
654 
655     QPoint pos = _pos - rect.topLeft();
656 
657     int x = pos.x();
658     int y = pos.y();
659     int w = rect.width();
660     int h = rect.height();
661 
662     if (tabMode != QDockAreaLayoutInfo::NoTabs) {
663         // is it in the center?
664         if (nestingEnabled) {
665         /*             2/3
666                 +--------------+
667                 |              |
668                 |   CCCCCCCC   |
669            2/3  |   CCCCCCCC   |
670                 |   CCCCCCCC   |
671                 |              |
672                 +--------------+     */
673 
674             QRect center(w/6, h/6, 2*w/3, 2*h/3);
675             if (center.contains(pos))
676                 return QInternal::DockCount;
677         } else if (o == Qt::Horizontal) {
678         /*             2/3
679                 +--------------+
680                 |   CCCCCCCC   |
681                 |   CCCCCCCC   |
682                 |   CCCCCCCC   |
683                 |   CCCCCCCC   |
684                 |   CCCCCCCC   |
685                 +--------------+     */
686 
687             if (x > w/6 && x < w*5/6)
688                 return QInternal::DockCount;
689         } else {
690         /*
691                 +--------------+
692                 |              |
693            2/3  |CCCCCCCCCCCCCC|
694                 |CCCCCCCCCCCCCC|
695                 |              |
696                 +--------------+     */
697             if (y > h/6 && y < 5*h/6)
698                 return QInternal::DockCount;
699         }
700     }
701 
702     // not in the center. which edge?
703     if (nestingEnabled) {
704         if (o == Qt::Horizontal) {
705     /*       1/3  1/3 1/3
706             +------------+     (we've already ruled out the center)
707             |LLLLTTTTRRRR|
708             |LLLLTTTTRRRR|
709             |LLLLBBBBRRRR|
710             |LLLLBBBBRRRR|
711             +------------+    */
712 
713             if (x < w/3)
714                 return QInternal::LeftDock;
715             if (x > 2*w/3)
716                 return QInternal::RightDock;
717             if (y < h/2)
718                 return QInternal::TopDock;
719             return QInternal::BottomDock;
720         } else {
721     /*      +------------+     (we've already ruled out the center)
722         1/3 |TTTTTTTTTTTT|
723             |LLLLLLRRRRRR|
724         1/3 |LLLLLLRRRRRR|
725         1/3 |BBBBBBBBBBBB|
726             +------------+    */
727 
728             if (y < h/3)
729                 return QInternal::TopDock;
730             if (y > 2*h/3)
731                 return QInternal::BottomDock;
732             if (x < w/2)
733                 return QInternal::LeftDock;
734             return QInternal::RightDock;
735         }
736     } else {
737         if (o == Qt::Horizontal) {
738             return x < w/2
739                     ? QInternal::LeftDock
740                     : QInternal::RightDock;
741         } else {
742             return y < h/2
743                     ? QInternal::TopDock
744                     : QInternal::BottomDock;
745         }
746     }
747 }
748 
749 QList<int> QDockAreaLayoutInfo::gapIndex(const QPoint& _pos,
750                         bool nestingEnabled, TabMode tabMode) const
751 {
752     QList<int> result;
753     QRect item_rect;
754     int item_index = 0;
755 
756 #if QT_CONFIG(tabbar)
757     if (tabbed) {
758         item_rect = tabContentRect();
759     } else
760 #endif
761     {
762         int pos = pick(o, _pos);
763 
764         int last = -1;
765         for (int i = 0; i < item_list.size(); ++i) {
766             const QDockAreaLayoutItem &item = item_list.at(i);
767             if (item.skip())
768                 continue;
769 
770             last = i;
771 
772             if (item.pos + item.size < pos)
773                 continue;
774 
775             if (item.subinfo != nullptr
776 #if QT_CONFIG(tabbar)
777                 && !item.subinfo->tabbed
778 #endif
779                 ) {
780                 result = item.subinfo->gapIndex(_pos, nestingEnabled,
781                                                     tabMode);
782                 result.prepend(i);
783                 return result;
784             }
785 
786             item_rect = itemRect(i);
787             item_index = i;
788             break;
789         }
790 
791         if (item_rect.isNull()) {
792             result.append(last + 1);
793             return result;
794         }
795     }
796 
797     Q_ASSERT(!item_rect.isNull());
798 
799     QInternal::DockPosition dock_pos
800         = dockPosHelper(item_rect, _pos, o, nestingEnabled, tabMode);
801 
802     switch (dock_pos) {
803         case QInternal::LeftDock:
804             if (o == Qt::Horizontal)
805                 result << item_index;
806             else
807                 result << item_index << 0; // this subinfo doesn't exist yet, but insertGap()
808                                            // handles this by inserting it
809             break;
810         case QInternal::RightDock:
811             if (o == Qt::Horizontal)
812                 result << item_index + 1;
813             else
814                 result << item_index << 1;
815             break;
816         case QInternal::TopDock:
817             if (o == Qt::Horizontal)
818                 result << item_index << 0;
819             else
820                 result << item_index;
821             break;
822         case QInternal::BottomDock:
823             if (o == Qt::Horizontal)
824                 result << item_index << 1;
825             else
826                 result << item_index + 1;
827             break;
828         case  QInternal::DockCount:
829             result << (-item_index - 1) << 0;   // negative item_index means "on top of"
830                                                 // -item_index - 1, insertGap()
831                                                 // will insert a tabbed subinfo
832             break;
833         default:
834             break;
835     }
836 
837     return result;
838 }
839 
840 static inline int shrink(QLayoutStruct &ls, int delta)
841 {
842     if (ls.empty)
843         return 0;
844     int old_size = ls.size;
845     ls.size = qMax(ls.size - delta, ls.minimumSize);
846     return old_size - ls.size;
847 }
848 
849 static inline int grow(QLayoutStruct &ls, int delta)
850 {
851     if (ls.empty)
852         return 0;
853     int old_size = ls.size;
854     ls.size = qMin(ls.size + delta, ls.maximumSize);
855     return ls.size - old_size;
856 }
857 
858 static int separatorMoveHelper(QList<QLayoutStruct> &list, int index, int delta, int sep)
859 {
860     // adjust sizes
861     int pos = -1;
862     for (int i = 0; i < list.size(); ++i) {
863         const QLayoutStruct &ls = list.at(i);
864         if (!ls.empty) {
865             pos = ls.pos;
866             break;
867         }
868     }
869     if (pos == -1)
870         return 0;
871 
872     if (delta > 0) {
873         int growlimit = 0;
874         for (int i = 0; i<=index; ++i) {
875             const QLayoutStruct &ls = list.at(i);
876             if (ls.empty)
877                 continue;
878             if (ls.maximumSize == QLAYOUTSIZE_MAX) {
879                 growlimit = QLAYOUTSIZE_MAX;
880                 break;
881             }
882             growlimit += ls.maximumSize - ls.size;
883         }
884         if (delta > growlimit)
885             delta = growlimit;
886 
887         int d = 0;
888         for (int i = index + 1; d < delta && i < list.count(); ++i)
889             d += shrink(list[i], delta - d);
890         delta = d;
891         d = 0;
892         for (int i = index; d < delta && i >= 0; --i)
893             d += grow(list[i], delta - d);
894     } else if (delta < 0) {
895         int growlimit = 0;
896         for (int i = index + 1; i < list.count(); ++i) {
897             const QLayoutStruct &ls = list.at(i);
898             if (ls.empty)
899                 continue;
900             if (ls.maximumSize == QLAYOUTSIZE_MAX) {
901                 growlimit = QLAYOUTSIZE_MAX;
902                 break;
903             }
904             growlimit += ls.maximumSize - ls.size;
905         }
906         if (-delta > growlimit)
907             delta = -growlimit;
908 
909         int d = 0;
910         for (int i = index; d < -delta && i >= 0; --i)
911             d += shrink(list[i], -delta - d);
912         delta = -d;
913         d = 0;
914         for (int i = index + 1; d < -delta && i < list.count(); ++i)
915             d += grow(list[i], -delta - d);
916     }
917 
918     // adjust positions
919     bool first = true;
920     for (int i = 0; i < list.size(); ++i) {
921         QLayoutStruct &ls = list[i];
922         if (ls.empty) {
923             ls.pos = pos + (first ? 0 : sep);
924             continue;
925         }
926         if (!first)
927             pos += sep;
928         ls.pos = pos;
929         pos += ls.size;
930         first = false;
931     }
932 
933     return delta;
934 }
935 
936 int QDockAreaLayoutInfo::separatorMove(int index, int delta)
937 {
938 #if QT_CONFIG(tabbar)
939     Q_ASSERT(!tabbed);
940 #endif
941 
942     QList<QLayoutStruct> list(item_list.size());
943     for (int i = 0; i < list.size(); ++i) {
944         const QDockAreaLayoutItem &item = item_list.at(i);
945         QLayoutStruct &ls = list[i];
946         Q_ASSERT(!(item.flags & QDockAreaLayoutItem::GapItem));
947         if (item.skip()) {
948             ls.empty = true;
949         } else {
950             const int separatorSpace = item.hasFixedSize(o) ? 0 : *sep;
951             ls.empty = false;
952             ls.pos = item.pos;
953             ls.size = item.size + separatorSpace;
954             ls.minimumSize = pick(o, item.minimumSize()) + separatorSpace;
955             ls.maximumSize = pick(o, item.maximumSize()) + separatorSpace;
956 
957         }
958     }
959 
960     //the separator space has been added to the size, so we pass 0 as a parameter
961     delta = separatorMoveHelper(list, index, delta, 0 /*separator*/);
962 
963     for (int i = 0; i < list.size(); ++i) {
964         QDockAreaLayoutItem &item = item_list[i];
965         if (item.skip())
966             continue;
967         QLayoutStruct &ls = list[i];
968         const int separatorSpace = item.hasFixedSize(o) ? 0 : *sep;
969         item.size = ls.size - separatorSpace;
970         item.pos = ls.pos;
971         if (item.subinfo != nullptr) {
972             item.subinfo->rect = itemRect(i);
973             item.subinfo->fitItems();
974         }
975     }
976 
977     return delta;
978 }
979 
980 void QDockAreaLayoutInfo::unnest(int index)
981 {
982     QDockAreaLayoutItem &item = item_list[index];
983     if (item.subinfo == nullptr)
984         return;
985     if (item.subinfo->item_list.count() > 1)
986         return;
987 
988     if (item.subinfo->item_list.count() == 0) {
989         item_list.removeAt(index);
990     } else if (item.subinfo->item_list.count() == 1) {
991         QDockAreaLayoutItem &child = item.subinfo->item_list.first();
992         if (child.widgetItem != nullptr) {
993             item.widgetItem = child.widgetItem;
994             delete item.subinfo;
995             item.subinfo = nullptr;
996         } else if (child.subinfo != nullptr) {
997             QDockAreaLayoutInfo *tmp = item.subinfo;
998             item.subinfo = child.subinfo;
999             child.subinfo = nullptr;
1000             tmp->item_list.clear();
1001             delete tmp;
1002         }
1003     }
1004 }
1005 
1006 void QDockAreaLayoutInfo::remove(const QList<int> &path)
1007 {
1008     Q_ASSERT(!path.isEmpty());
1009 
1010     if (path.count() > 1) {
1011         const int index = path.first();
1012         QDockAreaLayoutItem &item = item_list[index];
1013         Q_ASSERT(item.subinfo != nullptr);
1014         item.subinfo->remove(path.mid(1));
1015         unnest(index);
1016     } else {
1017         int index = path.first();
1018         item_list.removeAt(index);
1019     }
1020 }
1021 
1022 QLayoutItem *QDockAreaLayoutInfo::plug(const QList<int> &path)
1023 {
1024     Q_ASSERT(!path.isEmpty());
1025 
1026     int index = path.first();
1027     if (index < 0)
1028         index = -index - 1;
1029 
1030     if (path.count() > 1) {
1031         QDockAreaLayoutItem &item = item_list[index];
1032         Q_ASSERT(item.subinfo != nullptr);
1033         return item.subinfo->plug(path.mid(1));
1034     }
1035 
1036     QDockAreaLayoutItem &item = item_list[index];
1037 
1038     Q_ASSERT(item.widgetItem != nullptr);
1039     Q_ASSERT(item.flags & QDockAreaLayoutItem::GapItem);
1040     item.flags &= ~QDockAreaLayoutItem::GapItem;
1041     return item.widgetItem;
1042 }
1043 
1044 QLayoutItem *QDockAreaLayoutInfo::unplug(const QList<int> &path)
1045 {
1046     Q_ASSERT(!path.isEmpty());
1047 
1048     const int index = path.first();
1049     if (path.count() > 1) {
1050         QDockAreaLayoutItem &item = item_list[index];
1051         Q_ASSERT(item.subinfo != nullptr);
1052         return item.subinfo->unplug(path.mid(1));
1053     }
1054 
1055     QDockAreaLayoutItem &item = item_list[index];
1056     int prev = this->prev(index);
1057     int next = this->next(index);
1058 
1059     Q_ASSERT(!(item.flags & QDockAreaLayoutItem::GapItem));
1060     item.flags |= QDockAreaLayoutItem::GapItem;
1061 
1062 #if QT_CONFIG(tabbar)
1063     if (tabbed) {
1064     } else
1065 #endif
1066     {
1067         if (prev != -1 && !(item_list.at(prev).flags & QDockAreaLayoutItem::GapItem)) {
1068             item.pos -= *sep;
1069             item.size += *sep;
1070         }
1071         if (next != -1 && !(item_list.at(next).flags & QDockAreaLayoutItem::GapItem))
1072             item.size += *sep;
1073     }
1074 
1075     return item.widgetItem;
1076 }
1077 
1078 #if QT_CONFIG(tabbar)
1079 
1080 quintptr QDockAreaLayoutInfo::currentTabId() const
1081 {
1082     if (!tabbed || tabBar == nullptr)
1083         return 0;
1084 
1085     int index = tabBar->currentIndex();
1086     if (index == -1)
1087         return 0;
1088 
1089     return qvariant_cast<quintptr>(tabBar->tabData(index));
1090 }
1091 
1092 void QDockAreaLayoutInfo::setCurrentTab(QWidget *widget)
1093 {
1094     setCurrentTabId(reinterpret_cast<quintptr>(widget));
1095 }
1096 
1097 void QDockAreaLayoutInfo::setCurrentTabId(quintptr id)
1098 {
1099     if (!tabbed || tabBar == nullptr)
1100         return;
1101 
1102     for (int i = 0; i < tabBar->count(); ++i) {
1103         if (qvariant_cast<quintptr>(tabBar->tabData(i)) == id) {
1104             tabBar->setCurrentIndex(i);
1105             return;
1106         }
1107     }
1108 }
1109 
1110 #endif // QT_CONFIG(tabbar)
1111 
1112 static QRect dockedGeometry(QWidget *widget)
1113 {
1114     int titleHeight = 0;
1115 
1116     QDockWidgetLayout *layout
1117         = qobject_cast<QDockWidgetLayout*>(widget->layout());
1118     if (layout && layout->nativeWindowDeco())
1119         titleHeight = layout->titleHeight();
1120 
1121     QRect result = widget->geometry();
1122     result.adjust(0, -titleHeight, 0, 0);
1123     return result;
1124 }
1125 
1126 bool QDockAreaLayoutInfo::insertGap(const QList<int> &path, QLayoutItem *dockWidgetItem)
1127 {
1128     Q_ASSERT(!path.isEmpty());
1129 
1130     bool insert_tabbed = false;
1131     int index = path.first();
1132     if (index < 0) {
1133         insert_tabbed = true;
1134         index = -index - 1;
1135     }
1136 
1137 //    dump(qDebug() << "insertGap() before:" << index << tabIndex, *this, QString());
1138 
1139     if (path.count() > 1) {
1140         QDockAreaLayoutItem &item = item_list[index];
1141 
1142         if (item.subinfo == nullptr
1143 #if QT_CONFIG(tabbar)
1144             || (item.subinfo->tabbed && !insert_tabbed)
1145 #endif
1146             ) {
1147 
1148             // this is not yet a nested layout - make it
1149 
1150             QDockAreaLayoutInfo *subinfo = item.subinfo;
1151             QLayoutItem *widgetItem = item.widgetItem;
1152             QPlaceHolderItem *placeHolderItem = item.placeHolderItem;
1153             QRect r = subinfo == nullptr ? widgetItem ? dockedGeometry(widgetItem->widget()) : placeHolderItem->topLevelRect : subinfo->rect;
1154 
1155             Qt::Orientation opposite = o == Qt::Horizontal ? Qt::Vertical : Qt::Horizontal;
1156 #if !QT_CONFIG(tabbar)
1157             const int tabBarShape = 0;
1158 #endif
1159             QDockAreaLayoutInfo *new_info
1160                 = new QDockAreaLayoutInfo(sep, dockPos, opposite, tabBarShape, mainWindow);
1161 
1162             //item become a new top-level
1163             item.subinfo = new_info;
1164             item.widgetItem = nullptr;
1165             item.placeHolderItem = nullptr;
1166 
1167             QDockAreaLayoutItem new_item
1168                 = widgetItem == nullptr
1169                     ? QDockAreaLayoutItem(subinfo)
1170                     : widgetItem ? QDockAreaLayoutItem(widgetItem) : QDockAreaLayoutItem(placeHolderItem);
1171             new_item.size = pick(opposite, r.size());
1172             new_item.pos = pick(opposite, r.topLeft());
1173             new_info->item_list.append(new_item);
1174 #if QT_CONFIG(tabbar)
1175             if (insert_tabbed) {
1176                 new_info->tabbed = true;
1177             }
1178 #endif
1179         }
1180 
1181         return item.subinfo->insertGap(path.mid(1), dockWidgetItem);
1182     }
1183 
1184     // create the gap item
1185     QDockAreaLayoutItem gap_item;
1186     gap_item.flags |= QDockAreaLayoutItem::GapItem;
1187     gap_item.widgetItem = dockWidgetItem;   // so minimumSize(), maximumSize() and
1188                                             // sizeHint() will work
1189 #if QT_CONFIG(tabbar)
1190     if (!tabbed)
1191 #endif
1192     {
1193         int prev = this->prev(index);
1194         int next = this->next(index - 1);
1195         // find out how much space we have in the layout
1196         int space = 0;
1197         if (isEmpty()) {
1198             // I am an empty dock area, therefore I am a top-level dock area.
1199             switch (dockPos) {
1200                 case QInternal::LeftDock:
1201                 case QInternal::RightDock:
1202                     if (o == Qt::Vertical) {
1203                         // the "size" is the height of the dock area (remember we are empty)
1204                         space = pick(Qt::Vertical, rect.size());
1205                     } else {
1206                         space = pick(Qt::Horizontal, dockWidgetItem->widget()->size());
1207                     }
1208                     break;
1209                 case QInternal::TopDock:
1210                 case QInternal::BottomDock:
1211                 default:
1212                     if (o == Qt::Horizontal) {
1213                         // the "size" is width of the dock area
1214                         space = pick(Qt::Horizontal, rect.size());
1215                     } else {
1216                         space = pick(Qt::Vertical, dockWidgetItem->widget()->size());
1217                     }
1218                     break;
1219             }
1220         } else {
1221             for (int i = 0; i < item_list.count(); ++i) {
1222                 const QDockAreaLayoutItem &item = item_list.at(i);
1223                 if (item.skip())
1224                     continue;
1225                 Q_ASSERT(!(item.flags & QDockAreaLayoutItem::GapItem));
1226                 space += item.size - pick(o, item.minimumSize());
1227             }
1228         }
1229 
1230         // find the actual size of the gap
1231         int gap_size = 0;
1232         int sep_size = 0;
1233         if (isEmpty()) {
1234             gap_size = space;
1235             sep_size = 0;
1236         } else {
1237             QRect r = dockedGeometry(dockWidgetItem->widget());
1238             gap_size = pick(o, r.size());
1239         if (prev != -1 && !(item_list.at(prev).flags & QDockAreaLayoutItem::GapItem))
1240                 sep_size += *sep;
1241             if (next != -1 && !(item_list.at(next).flags & QDockAreaLayoutItem::GapItem))
1242                 sep_size += *sep;
1243         }
1244         if (gap_size + sep_size > space)
1245             gap_size = pick(o, gap_item.minimumSize());
1246         gap_item.size = gap_size + sep_size;
1247     }
1248 
1249     // finally, insert the gap
1250     item_list.insert(index, gap_item);
1251 
1252 //    dump(qDebug() << "insertGap() after:" << index << tabIndex, *this, QString());
1253 
1254     return true;
1255 }
1256 
1257 QDockAreaLayoutInfo *QDockAreaLayoutInfo::info(QWidget *widget)
1258 {
1259     for (int i = 0; i < item_list.count(); ++i) {
1260         const QDockAreaLayoutItem &item = item_list.at(i);
1261         if (item.skip())
1262             continue;
1263 
1264 #if QT_CONFIG(tabbar)
1265         if (tabbed && widget == tabBar)
1266             return this;
1267 #endif
1268 
1269         if (item.widgetItem != nullptr && item.widgetItem->widget() == widget)
1270             return this;
1271 
1272         if (item.subinfo != nullptr) {
1273             if (QDockAreaLayoutInfo *result = item.subinfo->info(widget))
1274                 return result;
1275         }
1276     }
1277 
1278     return nullptr;
1279 }
1280 
1281 QDockAreaLayoutInfo *QDockAreaLayoutInfo::info(const QList<int> &path)
1282 {
1283     int index = path.first();
1284     if (index < 0)
1285         index = -index - 1;
1286     if (index >= item_list.count())
1287         return this;
1288     if (path.count() == 1 || item_list[index].subinfo == nullptr)
1289         return this;
1290     return item_list[index].subinfo->info(path.mid(1));
1291 }
1292 
1293 QRect QDockAreaLayoutInfo::itemRect(int index, bool isGap) const
1294 {
1295     const QDockAreaLayoutItem &item = item_list.at(index);
1296 
1297     if (item.skip())
1298         return QRect();
1299 
1300     if (isGap && !(item.flags & QDockAreaLayoutItem::GapItem))
1301         return QRect();
1302 
1303     QRect result;
1304 
1305 #if QT_CONFIG(tabbar)
1306     if (tabbed) {
1307         if (isGap || tabId(item) == currentTabId())
1308             result = tabContentRect();
1309     } else
1310 #endif
1311     {
1312         int pos = item.pos;
1313         int size = item.size;
1314 
1315         if (isGap) {
1316             int prev = this->prev(index);
1317             int next = this->next(index);
1318             if (prev != -1 && !(item_list.at(prev).flags & QDockAreaLayoutItem::GapItem)) {
1319                 pos += *sep;
1320                 size -= *sep;
1321             }
1322             if (next != -1 && !(item_list.at(next).flags & QDockAreaLayoutItem::GapItem))
1323                 size -= *sep;
1324         }
1325 
1326         QPoint p;
1327         rpick(o, p) = pos;
1328         rperp(o, p) = perp(o, rect.topLeft());
1329         QSize s;
1330         rpick(o, s) = size;
1331         rperp(o, s) = perp(o, rect.size());
1332         result = QRect(p, s);
1333     }
1334 
1335     return result;
1336 }
1337 
1338 QRect QDockAreaLayoutInfo::itemRect(const QList<int> &path) const
1339 {
1340     Q_ASSERT(!path.isEmpty());
1341 
1342     const int index = path.first();
1343     if (path.count() > 1) {
1344         const QDockAreaLayoutItem &item = item_list.at(index);
1345         Q_ASSERT(item.subinfo != nullptr);
1346         return item.subinfo->itemRect(path.mid(1));
1347     }
1348 
1349     return itemRect(index);
1350 }
1351 
1352 QRect QDockAreaLayoutInfo::separatorRect(int index) const
1353 {
1354 #if QT_CONFIG(tabbar)
1355     if (tabbed)
1356         return QRect();
1357 #endif
1358 
1359     const QDockAreaLayoutItem &item = item_list.at(index);
1360     if (item.skip())
1361         return QRect();
1362 
1363     QPoint pos = rect.topLeft();
1364     rpick(o, pos) = item.pos + item.size;
1365     QSize s = rect.size();
1366     rpick(o, s) = *sep;
1367 
1368     return QRect(pos, s);
1369 }
1370 
1371 QRect QDockAreaLayoutInfo::separatorRect(const QList<int> &path) const
1372 {
1373     Q_ASSERT(!path.isEmpty());
1374 
1375     const int index = path.first();
1376     if (path.count() > 1) {
1377         const QDockAreaLayoutItem &item = item_list.at(index);
1378         Q_ASSERT(item.subinfo != nullptr);
1379         return item.subinfo->separatorRect(path.mid(1));
1380     }
1381     return separatorRect(index);
1382 }
1383 
1384 QList<int> QDockAreaLayoutInfo::findSeparator(const QPoint &_pos) const
1385 {
1386 #if QT_CONFIG(tabbar)
1387     if (tabbed)
1388         return QList<int>();
1389 #endif
1390 
1391     int pos = pick(o, _pos);
1392 
1393     for (int i = 0; i < item_list.size(); ++i) {
1394         const QDockAreaLayoutItem &item = item_list.at(i);
1395         if (item.skip() || (item.flags & QDockAreaLayoutItem::GapItem))
1396             continue;
1397 
1398         if (item.pos + item.size > pos) {
1399             if (item.subinfo != nullptr) {
1400                 QList<int> result = item.subinfo->findSeparator(_pos);
1401                 if (!result.isEmpty()) {
1402                     result.prepend(i);
1403                     return result;
1404                 } else {
1405                     return QList<int>();
1406                 }
1407             }
1408         }
1409 
1410         int next = this->next(i);
1411         if (next == -1 || (item_list.at(next).flags & QDockAreaLayoutItem::GapItem))
1412             continue;
1413 
1414         QRect sepRect = separatorRect(i);
1415         if (!sepRect.isNull() && *sep == 1)
1416             sepRect.adjust(-2, -2, 2, 2);
1417         //we also make sure we don't find a separator that's not there
1418         if (sepRect.contains(_pos) && !item.hasFixedSize(o)) {
1419             return QList<int>() << i;
1420         }
1421 
1422     }
1423 
1424     return QList<int>();
1425 }
1426 
1427 QList<int> QDockAreaLayoutInfo::indexOfPlaceHolder(const QString &objectName) const
1428 {
1429     for (int i = 0; i < item_list.size(); ++i) {
1430         const QDockAreaLayoutItem &item = item_list.at(i);
1431 
1432         if (item.subinfo != nullptr) {
1433             QList<int> result = item.subinfo->indexOfPlaceHolder(objectName);
1434             if (!result.isEmpty()) {
1435                 result.prepend(i);
1436                 return result;
1437             }
1438             continue;
1439         }
1440 
1441         if (item.placeHolderItem != nullptr && item.placeHolderItem->objectName == objectName) {
1442             QList<int> result;
1443             result << i;
1444             return result;
1445         }
1446     }
1447 
1448     return QList<int>();
1449 }
1450 
1451 QList<int> QDockAreaLayoutInfo::indexOf(QWidget *widget) const
1452 {
1453     for (int i = 0; i < item_list.size(); ++i) {
1454         const QDockAreaLayoutItem &item = item_list.at(i);
1455 
1456         if (item.placeHolderItem != nullptr)
1457             continue;
1458 
1459         if (item.subinfo != nullptr) {
1460             QList<int> result = item.subinfo->indexOf(widget);
1461             if (!result.isEmpty()) {
1462                 result.prepend(i);
1463                 return result;
1464             }
1465             continue;
1466         }
1467 
1468         if (!(item.flags & QDockAreaLayoutItem::GapItem) && item.widgetItem && item.widgetItem->widget() == widget) {
1469             QList<int> result;
1470             result << i;
1471             return result;
1472         }
1473     }
1474 
1475     return QList<int>();
1476 }
1477 
1478 QMainWindowLayout *QDockAreaLayoutInfo::mainWindowLayout() const
1479 {
1480     QMainWindowLayout *result = qt_mainwindow_layout(mainWindow);
1481     Q_ASSERT(result != nullptr);
1482     return result;
1483 }
1484 
1485 bool QDockAreaLayoutInfo::hasFixedSize() const
1486 {
1487     return perp(o, minimumSize()) == perp(o, maximumSize());
1488 }
1489 
1490 /*! \internal
1491     Applies the layout and returns the activated QDockWidget or nullptr.
1492  */
1493 QDockWidget *QDockAreaLayoutInfo::apply(bool animate)
1494 {
1495     QWidgetAnimator &widgetAnimator = mainWindowLayout()->widgetAnimator;
1496 
1497 #if QT_CONFIG(tabbar)
1498     if (tabbed) {
1499         QRect tab_rect;
1500         QSize tbh = tabBarSizeHint();
1501 
1502         if (!tbh.isNull()) {
1503             switch (tabBarShape) {
1504                 case QTabBar::RoundedNorth:
1505                 case QTabBar::TriangularNorth:
1506                     tab_rect = QRect(rect.left(), rect.top(), rect.width(), tbh.height());
1507                     break;
1508                 case QTabBar::RoundedSouth:
1509                 case QTabBar::TriangularSouth:
1510                     tab_rect = QRect(rect.left(), rect.bottom() - tbh.height() + 1,
1511                                         rect.width(), tbh.height());
1512                     break;
1513                 case QTabBar::RoundedEast:
1514                 case QTabBar::TriangularEast:
1515                     tab_rect = QRect(rect.right() - tbh.width() + 1, rect.top(),
1516                                         tbh.width(), rect.height());
1517                     break;
1518                 case QTabBar::RoundedWest:
1519                 case QTabBar::TriangularWest:
1520                     tab_rect = QRect(rect.left(), rect.top(),
1521                                         tbh.width(), rect.height());
1522                     break;
1523                 default:
1524                     break;
1525             }
1526         }
1527 
1528         widgetAnimator.animate(tabBar, tab_rect, animate);
1529     }
1530 #endif // QT_CONFIG(tabbar)
1531 
1532     QDockWidget *activated = nullptr;
1533 
1534     for (int i = 0; i < item_list.size(); ++i) {
1535         QDockAreaLayoutItem &item = item_list[i];
1536 
1537         if (item.flags & QDockAreaLayoutItem::GapItem)
1538             continue;
1539 
1540         if (item.subinfo != nullptr) {
1541             item.subinfo->apply(animate);
1542             continue;
1543         }
1544 
1545         if (item.skip())
1546             continue;
1547 
1548         Q_ASSERT(item.widgetItem);
1549         QRect r = itemRect(i);
1550         QWidget *w = item.widgetItem->widget();
1551 
1552         QRect geo = w->geometry();
1553         widgetAnimator.animate(w, r, animate);
1554         if (!w->isHidden() && w->window()->isVisible()) {
1555             QDockWidget *dw = qobject_cast<QDockWidget*>(w);
1556             if (!r.isValid() && geo.right() >= 0 && geo.bottom() >= 0) {
1557                 dw->lower();
1558                 emit dw->visibilityChanged(false);
1559             } else if (r.isValid()
1560                         && (geo.right() < 0 || geo.bottom() < 0)) {
1561                 emit dw->visibilityChanged(true);
1562                 activated = dw;
1563             }
1564         }
1565     }
1566 #if QT_CONFIG(tabbar)
1567     if (*sep == 1)
1568         updateSeparatorWidgets();
1569 #endif // QT_CONFIG(tabbar)
1570 
1571     return activated;
1572 }
1573 
1574 static void paintSep(QPainter *p, QWidget *w, const QRect &r, Qt::Orientation o, bool mouse_over)
1575 {
1576     QStyleOption opt(0);
1577     opt.state = QStyle::State_None;
1578     if (w->isEnabled())
1579         opt.state |= QStyle::State_Enabled;
1580     if (o != Qt::Horizontal)
1581         opt.state |= QStyle::State_Horizontal;
1582     if (mouse_over)
1583         opt.state |= QStyle::State_MouseOver;
1584     opt.rect = r;
1585     opt.palette = w->palette();
1586 
1587     w->style()->drawPrimitive(QStyle::PE_IndicatorDockWidgetResizeHandle, &opt, p, w);
1588 }
1589 
1590 QRegion QDockAreaLayoutInfo::separatorRegion() const
1591 {
1592     QRegion result;
1593 
1594     if (isEmpty())
1595         return result;
1596 #if QT_CONFIG(tabbar)
1597     if (tabbed)
1598         return result;
1599 #endif
1600 
1601     for (int i = 0; i < item_list.count(); ++i) {
1602         const QDockAreaLayoutItem &item = item_list.at(i);
1603 
1604         if (item.skip())
1605             continue;
1606 
1607         int next = this->next(i);
1608 
1609         if (item.subinfo)
1610             result |= item.subinfo->separatorRegion();
1611 
1612         if (next == -1)
1613             break;
1614         result |= separatorRect(i);
1615     }
1616 
1617     return result;
1618 }
1619 
1620 void QDockAreaLayoutInfo::paintSeparators(QPainter *p, QWidget *widget,
1621                                                     const QRegion &clip,
1622                                                     const QPoint &mouse) const
1623 {
1624     if (isEmpty())
1625         return;
1626 #if QT_CONFIG(tabbar)
1627     if (tabbed)
1628         return;
1629 #endif
1630 
1631     for (int i = 0; i < item_list.count(); ++i) {
1632         const QDockAreaLayoutItem &item = item_list.at(i);
1633 
1634         if (item.skip())
1635             continue;
1636 
1637         int next = this->next(i);
1638         if ((item.flags & QDockAreaLayoutItem::GapItem)
1639                 || (next != -1 && (item_list.at(next).flags & QDockAreaLayoutItem::GapItem)))
1640             continue;
1641 
1642         if (item.subinfo) {
1643             if (clip.contains(item.subinfo->rect))
1644                 item.subinfo->paintSeparators(p, widget, clip, mouse);
1645         }
1646 
1647         if (next == -1)
1648             break;
1649         QRect r = separatorRect(i);
1650         if (clip.contains(r) && !item.hasFixedSize(o))
1651             paintSep(p, widget, r, o, r.contains(mouse));
1652     }
1653 }
1654 
1655 int QDockAreaLayoutInfo::next(int index) const
1656 {
1657     for (int i = index + 1; i < item_list.size(); ++i) {
1658         if (!item_list.at(i).skip())
1659             return i;
1660     }
1661     return -1;
1662 }
1663 
1664 int QDockAreaLayoutInfo::prev(int index) const
1665 {
1666     for (int i = index - 1; i >= 0; --i) {
1667         if (!item_list.at(i).skip())
1668             return i;
1669     }
1670     return -1;
1671 }
1672 
1673 #if QT_CONFIG(tabbar)
1674 void QDockAreaLayoutInfo::tab(int index, QLayoutItem *dockWidgetItem)
1675 {
1676     if (tabbed) {
1677         item_list.append(QDockAreaLayoutItem(dockWidgetItem));
1678         updateTabBar();
1679         setCurrentTab(dockWidgetItem->widget());
1680     } else {
1681         QDockAreaLayoutInfo *new_info
1682             = new QDockAreaLayoutInfo(sep, dockPos, o, tabBarShape, mainWindow);
1683         item_list[index].subinfo = new_info;
1684         new_info->item_list.append(QDockAreaLayoutItem(item_list.at(index).widgetItem));
1685         item_list[index].widgetItem = nullptr;
1686         new_info->item_list.append(QDockAreaLayoutItem(dockWidgetItem));
1687         new_info->tabbed = true;
1688         new_info->updateTabBar();
1689         new_info->setCurrentTab(dockWidgetItem->widget());
1690     }
1691 }
1692 #endif // QT_CONFIG(tabbar)
1693 
1694 void QDockAreaLayoutInfo::split(int index, Qt::Orientation orientation,
1695                                        QLayoutItem *dockWidgetItem)
1696 {
1697     if (orientation == o) {
1698         item_list.insert(index + 1, QDockAreaLayoutItem(dockWidgetItem));
1699     } else {
1700 #if !QT_CONFIG(tabbar)
1701         const int tabBarShape = 0;
1702 #endif
1703         QDockAreaLayoutInfo *new_info
1704             = new QDockAreaLayoutInfo(sep, dockPos, orientation, tabBarShape, mainWindow);
1705         item_list[index].subinfo = new_info;
1706         new_info->item_list.append(QDockAreaLayoutItem(item_list.at(index).widgetItem));
1707         item_list[index].widgetItem = nullptr;
1708         new_info->item_list.append(QDockAreaLayoutItem(dockWidgetItem));
1709     }
1710 }
1711 
1712 QDockAreaLayoutItem &QDockAreaLayoutInfo::item(const QList<int> &path)
1713 {
1714     Q_ASSERT(!path.isEmpty());
1715     const int index = path.first();
1716     if (path.count() > 1) {
1717         const QDockAreaLayoutItem &item = item_list[index];
1718         Q_ASSERT(item.subinfo != nullptr);
1719         return item.subinfo->item(path.mid(1));
1720     }
1721     return item_list[index];
1722 }
1723 
1724 QLayoutItem *QDockAreaLayoutInfo::itemAt(int *x, int index) const
1725 {
1726     for (int i = 0; i < item_list.count(); ++i) {
1727         const QDockAreaLayoutItem &item = item_list.at(i);
1728         if (item.placeHolderItem != nullptr)
1729             continue;
1730         if (item.subinfo) {
1731             if (QLayoutItem *ret = item.subinfo->itemAt(x, index))
1732                 return ret;
1733         } else if (item.widgetItem) {
1734             if ((*x)++ == index)
1735                 return item.widgetItem;
1736         }
1737     }
1738     return nullptr;
1739 }
1740 
1741 QLayoutItem *QDockAreaLayoutInfo::takeAt(int *x, int index)
1742 {
1743     for (int i = 0; i < item_list.count(); ++i) {
1744         QDockAreaLayoutItem &item = item_list[i];
1745         if (item.placeHolderItem != nullptr)
1746             continue;
1747         else if (item.subinfo) {
1748             if (QLayoutItem *ret = item.subinfo->takeAt(x, index)) {
1749                 unnest(i);
1750                 return ret;
1751             }
1752         } else if (item.widgetItem) {
1753             if ((*x)++ == index) {
1754                 item.placeHolderItem = new QPlaceHolderItem(item.widgetItem->widget());
1755                 QLayoutItem *ret = item.widgetItem;
1756                 item.widgetItem = nullptr;
1757                 if (item.size != -1)
1758                     item.flags |= QDockAreaLayoutItem::KeepSize;
1759                 return ret;
1760             }
1761         }
1762     }
1763     return nullptr;
1764 }
1765 
1766 void QDockAreaLayoutInfo::deleteAllLayoutItems()
1767 {
1768     for (int i = 0; i < item_list.count(); ++i) {
1769         QDockAreaLayoutItem &item= item_list[i];
1770         if (item.subinfo) {
1771             item.subinfo->deleteAllLayoutItems();
1772         } else {
1773             delete item.widgetItem;
1774             item.widgetItem = nullptr;
1775         }
1776     }
1777 }
1778 
1779 void QDockAreaLayoutInfo::saveState(QDataStream &stream) const
1780 {
1781 #if QT_CONFIG(tabbar)
1782     if (tabbed) {
1783         stream << (uchar) TabMarker;
1784 
1785         // write the index in item_list of the widget that's currently on top.
1786         quintptr id = currentTabId();
1787         int index = -1;
1788         for (int i = 0; i < item_list.count(); ++i) {
1789             if (tabId(item_list.at(i)) == id) {
1790                 index = i;
1791                 break;
1792             }
1793         }
1794         stream << index;
1795     } else
1796 #endif // QT_CONFIG(tabbar)
1797     {
1798         stream << (uchar) SequenceMarker;
1799     }
1800 
1801     stream << (uchar) o << int(item_list.count());
1802 
1803     for (int i = 0; i < item_list.count(); ++i) {
1804         const QDockAreaLayoutItem &item = item_list.at(i);
1805         if (item.widgetItem != nullptr) {
1806             stream << (uchar) WidgetMarker;
1807             QWidget *w = item.widgetItem->widget();
1808             QString name = w->objectName();
1809             if (Q_UNLIKELY(name.isEmpty())) {
1810                 qWarning("QMainWindow::saveState(): 'objectName' not set for QDockWidget %p '%ls;",
1811                          w, qUtf16Printable(w->windowTitle()));
1812             }
1813             stream << name;
1814 
1815             uchar flags = 0;
1816             if (!w->isHidden())
1817                 flags |= StateFlagVisible;
1818             if (w->isWindow())
1819                 flags |= StateFlagFloating;
1820             stream << flags;
1821 
1822             if (w->isWindow()) {
1823                 const QRect geometry = w->geometry();
1824                 stream << geometry.x() << geometry.y() << geometry.width() << geometry.height();
1825             } else {
1826                 stream << item.pos << item.size << pick(o, item.minimumSize())
1827                         << pick(o, item.maximumSize());
1828             }
1829         } else if (item.placeHolderItem != nullptr) {
1830             stream << (uchar) WidgetMarker;
1831             stream << item.placeHolderItem->objectName;
1832             uchar flags = 0;
1833             if (!item.placeHolderItem->hidden)
1834                 flags |= StateFlagVisible;
1835             if (item.placeHolderItem->window)
1836                 flags |= StateFlagFloating;
1837             stream << flags;
1838             if (item.placeHolderItem->window) {
1839                 QRect r = item.placeHolderItem->topLevelRect;
1840                 stream << r.x() << r.y() << r.width() << r.height();
1841             } else {
1842                 stream << item.pos << item.size << (int)0 << (int)0;
1843             }
1844         } else if (item.subinfo != nullptr) {
1845             stream << (uchar) SequenceMarker << item.pos << item.size << pick(o, item.minimumSize()) << pick(o, item.maximumSize());
1846             item.subinfo->saveState(stream);
1847         }
1848     }
1849 }
1850 
1851 static Qt::DockWidgetArea toDockWidgetArea(QInternal::DockPosition pos)
1852 {
1853     switch (pos) {
1854         case QInternal::LeftDock:   return Qt::LeftDockWidgetArea;
1855         case QInternal::RightDock:  return Qt::RightDockWidgetArea;
1856         case QInternal::TopDock:    return Qt::TopDockWidgetArea;
1857         case QInternal::BottomDock: return Qt::BottomDockWidgetArea;
1858         default: break;
1859     }
1860     return Qt::NoDockWidgetArea;
1861 }
1862 
1863 bool QDockAreaLayoutInfo::restoreState(QDataStream &stream, QList<QDockWidget*> &widgets, bool testing)
1864 {
1865     uchar marker;
1866     stream >> marker;
1867     if (marker != TabMarker && marker != SequenceMarker)
1868         return false;
1869 
1870 #if QT_CONFIG(tabbar)
1871     tabbed = marker == TabMarker;
1872 
1873     int index = -1;
1874     if (tabbed)
1875         stream >> index;
1876 #endif
1877 
1878     uchar orientation;
1879     stream >> orientation;
1880     o = static_cast<Qt::Orientation>(orientation);
1881 
1882     int cnt;
1883     stream >> cnt;
1884 
1885     for (int i = 0; i < cnt; ++i) {
1886         uchar nextMarker;
1887         stream >> nextMarker;
1888         if (nextMarker == WidgetMarker) {
1889             QString name;
1890             uchar flags;
1891             stream >> name >> flags;
1892             if (name.isEmpty()) {
1893                 int dummy;
1894                 stream >> dummy >> dummy >> dummy >> dummy;
1895                 continue;
1896             }
1897 
1898             QDockWidget *widget = nullptr;
1899             for (int j = 0; j < widgets.count(); ++j) {
1900                 if (widgets.at(j)->objectName() == name) {
1901                     widget = widgets.takeAt(j);
1902                     break;
1903                 }
1904             }
1905 
1906             if (widget == nullptr) {
1907                 QPlaceHolderItem *placeHolder = new QPlaceHolderItem;
1908                 QDockAreaLayoutItem item(placeHolder);
1909 
1910                 placeHolder->objectName = name;
1911                 placeHolder->window = flags & StateFlagFloating;
1912                 placeHolder->hidden = !(flags & StateFlagVisible);
1913                 if (placeHolder->window) {
1914                     int x, y, w, h;
1915                     stream >> x >> y >> w >> h;
1916                     placeHolder->topLevelRect = QRect(x, y, w, h);
1917                 } else {
1918                     int dummy;
1919                     stream >> item.pos >> item.size >> dummy >> dummy;
1920                 }
1921                 if (item.size != -1)
1922                     item.flags |= QDockAreaLayoutItem::KeepSize;
1923                 if (!testing)
1924                     item_list.append(item);
1925             } else {
1926                 QDockAreaLayoutItem item(new QDockWidgetItem(widget));
1927                 if (flags & StateFlagFloating) {
1928                     bool drawer = false;
1929 
1930                     if (!testing) {
1931                         widget->hide();
1932                         if (!drawer)
1933                             widget->setFloating(true);
1934                     }
1935 
1936                     int x, y, w, h;
1937                     stream >> x >> y >> w >> h;
1938 
1939                     if (!testing)
1940                         widget->setGeometry(QDockAreaLayout::constrainedRect(QRect(x, y, w, h), widget));
1941 
1942                     if (!testing) {
1943                         widget->setVisible(flags & StateFlagVisible);
1944                         item_list.append(item);
1945                     }
1946                 } else {
1947                     int dummy;
1948                     stream >> item.pos >> item.size >> dummy >> dummy;
1949                     if (!testing) {
1950                         item_list.append(item);
1951                         widget->setFloating(false);
1952                         widget->setVisible(flags & StateFlagVisible);
1953                         emit widget->dockLocationChanged(toDockWidgetArea(dockPos));
1954                     }
1955                 }
1956                 if (testing) {
1957                     //was it is not really added to the layout, we need to delete the object here
1958                     delete item.widgetItem;
1959                 }
1960             }
1961         } else if (nextMarker == SequenceMarker) {
1962             int dummy;
1963 #if !QT_CONFIG(tabbar)
1964             const int tabBarShape = 0;
1965 #endif
1966             QDockAreaLayoutItem item(new QDockAreaLayoutInfo(sep, dockPos, o,
1967                                                                 tabBarShape, mainWindow));
1968             stream >> item.pos >> item.size >> dummy >> dummy;
1969             //we need to make sure the element is in the list so the dock widget can eventually be docked correctly
1970             if (!testing)
1971                 item_list.append(item);
1972 
1973             //here we need to make sure we change the item in the item_list
1974             QDockAreaLayoutItem &lastItem = testing ? item : item_list.last();
1975 
1976             if (!lastItem.subinfo->restoreState(stream, widgets, testing))
1977                 return false;
1978 
1979         } else {
1980             return false;
1981         }
1982     }
1983 
1984 #if QT_CONFIG(tabbar)
1985     if (!testing && tabbed && index >= 0 && index < item_list.count()) {
1986         updateTabBar();
1987         setCurrentTabId(tabId(item_list.at(index)));
1988     }
1989     if (!testing && *sep == 1)
1990         updateSeparatorWidgets();
1991 #endif
1992 
1993     return true;
1994 }
1995 
1996 #if QT_CONFIG(tabbar)
1997 void QDockAreaLayoutInfo::updateSeparatorWidgets() const
1998 {
1999     if (tabbed) {
2000         separatorWidgets.clear();
2001         return;
2002     }
2003 
2004     int j = 0;
2005     for (int i = 0; i < item_list.count(); ++i) {
2006         const QDockAreaLayoutItem &item = item_list.at(i);
2007 
2008         if (item.skip())
2009             continue;
2010 
2011         int next = this->next(i);
2012         if ((item.flags & QDockAreaLayoutItem::GapItem)
2013                 || (next != -1 && (item_list.at(next).flags & QDockAreaLayoutItem::GapItem)))
2014             continue;
2015 
2016         if (item.subinfo) {
2017             item.subinfo->updateSeparatorWidgets();
2018         }
2019 
2020         if (next == -1)
2021             break;
2022 
2023         QWidget *sepWidget;
2024         if (j < separatorWidgets.size() && separatorWidgets.at(j)) {
2025             sepWidget = separatorWidgets.at(j);
2026         } else {
2027             sepWidget = mainWindowLayout()->getSeparatorWidget();
2028             separatorWidgets.append(sepWidget);
2029         }
2030         j++;
2031 
2032         sepWidget->raise();
2033 
2034         QRect sepRect = separatorRect(i).adjusted(-2, -2, 2, 2);
2035         sepWidget->setGeometry(sepRect);
2036         sepWidget->setMask( QRegion(separatorRect(i).translated( - sepRect.topLeft())));
2037         sepWidget->show();
2038     }
2039 
2040     for (int k = j; k < separatorWidgets.size(); ++k) {
2041         separatorWidgets[k]->hide();
2042     }
2043     separatorWidgets.resize(j);
2044     Q_ASSERT(separatorWidgets.size() == j);
2045 }
2046 
2047 /*! \internal
2048     reparent all the widgets contained in this layout portion to the
2049     specified parent. This is used to reparent dock widgets and tabbars
2050     to the floating window or the main window
2051  */
2052 void QDockAreaLayoutInfo::reparentWidgets(QWidget *parent)
2053 {
2054     if (tabBar)
2055         tabBar->setParent(parent);
2056 
2057     for (int i = 0; i < item_list.count(); ++i) {
2058         const QDockAreaLayoutItem &item = item_list.at(i);
2059         if (item.flags & QDockAreaLayoutItem::GapItem)
2060             continue;
2061         if (item.subinfo)
2062             item.subinfo->reparentWidgets(parent);
2063         if (item.widgetItem) {
2064             QWidget *w = item.widgetItem->widget();
2065             if (qobject_cast<QDockWidgetGroupWindow *>(w))
2066                 continue;
2067             if (w->parent() != parent) {
2068                 bool hidden = w->isHidden();
2069                 w->setParent(parent, w->windowFlags());
2070                 if (!hidden)
2071                     w->show();
2072             }
2073         }
2074     }
2075 }
2076 
2077 //returns whether the tabbar is visible or not
2078 bool QDockAreaLayoutInfo::updateTabBar() const
2079 {
2080     if (!tabbed)
2081         return false;
2082 
2083     QDockAreaLayoutInfo *that = const_cast<QDockAreaLayoutInfo*>(this);
2084 
2085     if (that->tabBar == nullptr) {
2086         that->tabBar = mainWindowLayout()->getTabBar();
2087         that->tabBar->setShape(static_cast<QTabBar::Shape>(tabBarShape));
2088         that->tabBar->setDrawBase(true);
2089     }
2090 
2091     const QSignalBlocker blocker(tabBar);
2092     bool gap = false;
2093 
2094     const quintptr oldCurrentId = currentTabId();
2095 
2096     int tab_idx = 0;
2097     for (int i = 0; i < item_list.count(); ++i) {
2098         const QDockAreaLayoutItem &item = item_list.at(i);
2099         if (item.skip())
2100             continue;
2101         if (item.flags & QDockAreaLayoutItem::GapItem) {
2102             gap = true;
2103             continue;
2104         }
2105         if (item.widgetItem == nullptr)
2106             continue;
2107 
2108         QDockWidget *dw = qobject_cast<QDockWidget*>(item.widgetItem->widget());
2109         QString title = dw->d_func()->fixedWindowTitle;
2110         quintptr id = tabId(item);
2111         if (tab_idx == tabBar->count()) {
2112             tabBar->insertTab(tab_idx, title);
2113 #if QT_CONFIG(tooltip)
2114             tabBar->setTabToolTip(tab_idx, title);
2115 #endif
2116             tabBar->setTabData(tab_idx, id);
2117         } else if (qvariant_cast<quintptr>(tabBar->tabData(tab_idx)) != id) {
2118             if (tab_idx + 1 < tabBar->count()
2119                     && qvariant_cast<quintptr>(tabBar->tabData(tab_idx + 1)) == id)
2120                 tabBar->removeTab(tab_idx);
2121             else {
2122                 tabBar->insertTab(tab_idx, title);
2123 #if QT_CONFIG(tooltip)
2124                 tabBar->setTabToolTip(tab_idx, title);
2125 #endif
2126                 tabBar->setTabData(tab_idx, id);
2127             }
2128         }
2129 
2130         if (title != tabBar->tabText(tab_idx)) {
2131             tabBar->setTabText(tab_idx, title);
2132 #if QT_CONFIG(tooltip)
2133             tabBar->setTabToolTip(tab_idx, title);
2134 #endif
2135         }
2136 
2137         ++tab_idx;
2138     }
2139 
2140     while (tab_idx < tabBar->count()) {
2141         tabBar->removeTab(tab_idx);
2142     }
2143 
2144     if (oldCurrentId > 0 && currentTabId() != oldCurrentId)
2145         that->setCurrentTabId(oldCurrentId);
2146 
2147     if (QDockWidgetGroupWindow *dwgw = qobject_cast<QDockWidgetGroupWindow *>(tabBar->parent()))
2148         dwgw->adjustFlags();
2149 
2150     //returns if the tabbar is visible or not
2151     return ( (gap ? 1 : 0) + tabBar->count()) > 1;
2152 }
2153 
2154 void QDockAreaLayoutInfo::setTabBarShape(int shape)
2155 {
2156     if (shape == tabBarShape)
2157         return;
2158     tabBarShape = shape;
2159     if (tabBar != nullptr)
2160         tabBar->setShape(static_cast<QTabBar::Shape>(shape));
2161 
2162     for (int i = 0; i < item_list.count(); ++i) {
2163         QDockAreaLayoutItem &item = item_list[i];
2164         if (item.subinfo != nullptr)
2165             item.subinfo->setTabBarShape(shape);
2166     }
2167 }
2168 
2169 QSize QDockAreaLayoutInfo::tabBarMinimumSize() const
2170 {
2171     if (!updateTabBar())
2172         return QSize(0, 0);
2173 
2174     return tabBar->minimumSizeHint();
2175 }
2176 
2177 QSize QDockAreaLayoutInfo::tabBarSizeHint() const
2178 {
2179     if (!updateTabBar())
2180         return QSize(0, 0);
2181 
2182     return tabBar->sizeHint();
2183 }
2184 
2185 QSet<QTabBar*> QDockAreaLayoutInfo::usedTabBars() const
2186 {
2187     QSet<QTabBar*> result;
2188 
2189     if (tabbed) {
2190         updateTabBar();
2191         result.insert(tabBar);
2192     }
2193 
2194     for (int i = 0; i < item_list.count(); ++i) {
2195         const QDockAreaLayoutItem &item = item_list.at(i);
2196         if (item.subinfo != nullptr)
2197             result += item.subinfo->usedTabBars();
2198     }
2199 
2200     return result;
2201 }
2202 
2203 // returns a set of all used separator widgets for this dockarelayout info
2204 // and all subinfos
2205 QSet<QWidget*> QDockAreaLayoutInfo::usedSeparatorWidgets() const
2206 {
2207     QSet<QWidget*> result;
2208     const int numSeparatorWidgets = separatorWidgets.count();
2209     result.reserve(numSeparatorWidgets);
2210 
2211     for (int i = 0; i < numSeparatorWidgets; ++i)
2212         result << separatorWidgets.at(i);
2213 
2214     for (int i = 0; i < item_list.count(); ++i) {
2215         const QDockAreaLayoutItem &item = item_list.at(i);
2216         if (item.subinfo != nullptr)
2217             result += item.subinfo->usedSeparatorWidgets();
2218     }
2219 
2220     return result;
2221 }
2222 
2223 QRect QDockAreaLayoutInfo::tabContentRect() const
2224 {
2225     if (!tabbed)
2226         return QRect();
2227 
2228     QRect result = rect;
2229     QSize tbh = tabBarSizeHint();
2230 
2231     if (!tbh.isNull()) {
2232         switch (tabBarShape) {
2233             case QTabBar::RoundedNorth:
2234             case QTabBar::TriangularNorth:
2235                 result.adjust(0, tbh.height(), 0, 0);
2236                 break;
2237             case QTabBar::RoundedSouth:
2238             case QTabBar::TriangularSouth:
2239                 result.adjust(0, 0, 0, -tbh.height());
2240                 break;
2241             case QTabBar::RoundedEast:
2242             case QTabBar::TriangularEast:
2243                 result.adjust(0, 0, -tbh.width(), 0);
2244                 break;
2245             case QTabBar::RoundedWest:
2246             case QTabBar::TriangularWest:
2247                 result.adjust(tbh.width(), 0, 0, 0);
2248                 break;
2249             default:
2250                 break;
2251         }
2252     }
2253 
2254     return result;
2255 }
2256 
2257 int QDockAreaLayoutInfo::tabIndexToListIndex(int tabIndex) const
2258 {
2259     Q_ASSERT(tabbed && tabBar);
2260     quintptr data = qvariant_cast<quintptr>(tabBar->tabData(tabIndex));
2261     for (int i = 0; i < item_list.count(); ++i) {
2262         if (tabId(item_list.at(i)) == data)
2263             return i;
2264     }
2265     return -1;
2266 }
2267 
2268 void QDockAreaLayoutInfo::moveTab(int from, int to)
2269 {
2270     item_list.move(tabIndexToListIndex(from), tabIndexToListIndex(to));
2271 }
2272 #endif // QT_CONFIG(tabbar)
2273 
2274 /******************************************************************************
2275 ** QDockAreaLayout
2276 */
2277 
2278 QDockAreaLayout::QDockAreaLayout(QMainWindow *win) : fallbackToSizeHints(true)
2279 {
2280     mainWindow = win;
2281     sep = win->style()->pixelMetric(QStyle::PM_DockWidgetSeparatorExtent, nullptr, win);
2282 #if QT_CONFIG(tabbar)
2283     const int tabShape = QTabBar::RoundedSouth;
2284 #else
2285     const int tabShape = 0;
2286 #endif
2287     docks[QInternal::LeftDock]
2288         = QDockAreaLayoutInfo(&sep, QInternal::LeftDock, Qt::Vertical, tabShape, win);
2289     docks[QInternal::RightDock]
2290         = QDockAreaLayoutInfo(&sep, QInternal::RightDock, Qt::Vertical, tabShape, win);
2291     docks[QInternal::TopDock]
2292         = QDockAreaLayoutInfo(&sep, QInternal::TopDock, Qt::Horizontal, tabShape, win);
2293     docks[QInternal::BottomDock]
2294         = QDockAreaLayoutInfo(&sep, QInternal::BottomDock, Qt::Horizontal, tabShape, win);
2295     centralWidgetItem = nullptr;
2296 
2297 
2298     corners[Qt::TopLeftCorner] = Qt::TopDockWidgetArea;
2299     corners[Qt::TopRightCorner] = Qt::TopDockWidgetArea;
2300     corners[Qt::BottomLeftCorner] = Qt::BottomDockWidgetArea;
2301     corners[Qt::BottomRightCorner] = Qt::BottomDockWidgetArea;
2302 }
2303 
2304 bool QDockAreaLayout::isValid() const
2305 {
2306     return rect.isValid();
2307 }
2308 
2309 void QDockAreaLayout::saveState(QDataStream &stream) const
2310 {
2311     stream << (uchar) DockWidgetStateMarker;
2312     int cnt = 0;
2313     for (int i = 0; i < QInternal::DockCount; ++i) {
2314         if (!docks[i].item_list.isEmpty())
2315             ++cnt;
2316     }
2317     stream << cnt;
2318     for (int i = 0; i < QInternal::DockCount; ++i) {
2319         if (docks[i].item_list.isEmpty())
2320             continue;
2321         stream << i << docks[i].rect.size();
2322         docks[i].saveState(stream);
2323     }
2324 
2325     stream << centralWidgetRect.size();
2326 
2327     for (int i = 0; i < 4; ++i)
2328         stream << static_cast<int>(corners[i]);
2329 }
2330 
2331 bool QDockAreaLayout::restoreState(QDataStream &stream, const QList<QDockWidget*> &_dockwidgets, bool testing)
2332 {
2333     QList<QDockWidget*> dockwidgets = _dockwidgets;
2334 
2335     int cnt;
2336     stream >> cnt;
2337     for (int i = 0; i < cnt; ++i) {
2338         int pos;
2339         stream >> pos;
2340         QSize size;
2341         stream >> size;
2342         if (!testing) {
2343             docks[pos].rect = QRect(QPoint(0, 0), size);
2344         }
2345         if (!docks[pos].restoreState(stream, dockwidgets, testing)) {
2346             stream.setStatus(QDataStream::ReadCorruptData);
2347             return false;
2348         }
2349     }
2350 
2351     QSize size;
2352     stream >> size;
2353     centralWidgetRect = QRect(QPoint(0, 0), size);
2354 
2355     bool ok = stream.status() == QDataStream::Ok;
2356 
2357     if (ok) {
2358         int cornerData[4];
2359         for (int i = 0; i < 4; ++i)
2360             stream >> cornerData[i];
2361         if (stream.status() == QDataStream::Ok) {
2362             for (int i = 0; i < 4; ++i)
2363                 corners[i] = static_cast<Qt::DockWidgetArea>(cornerData[i]);
2364         }
2365 
2366         if (!testing)
2367             fallbackToSizeHints = false;
2368     }
2369 
2370     return ok;
2371 }
2372 
2373 QList<int> QDockAreaLayout::indexOfPlaceHolder(const QString &objectName) const
2374 {
2375     for (int i = 0; i < QInternal::DockCount; ++i) {
2376         QList<int> result = docks[i].indexOfPlaceHolder(objectName);
2377         if (!result.isEmpty()) {
2378             result.prepend(i);
2379             return result;
2380         }
2381     }
2382     return QList<int>();
2383 }
2384 
2385 QList<int> QDockAreaLayout::indexOf(QWidget *dockWidget) const
2386 {
2387     for (int i = 0; i < QInternal::DockCount; ++i) {
2388         QList<int> result = docks[i].indexOf(dockWidget);
2389         if (!result.isEmpty()) {
2390             result.prepend(i);
2391             return result;
2392         }
2393     }
2394     return QList<int>();
2395 }
2396 
2397 QList<int> QDockAreaLayout::gapIndex(const QPoint &pos, bool disallowTabs) const
2398 {
2399     QMainWindow::DockOptions opts = mainWindow->dockOptions();
2400     bool nestingEnabled = opts & QMainWindow::AllowNestedDocks;
2401     QDockAreaLayoutInfo::TabMode tabMode = QDockAreaLayoutInfo::NoTabs;
2402 #if QT_CONFIG(tabbar)
2403     if (!disallowTabs) {
2404         if (opts & QMainWindow::AllowTabbedDocks || opts & QMainWindow::VerticalTabs)
2405             tabMode = QDockAreaLayoutInfo::AllowTabs;
2406         if (opts & QMainWindow::ForceTabbedDocks)
2407             tabMode = QDockAreaLayoutInfo::ForceTabs;
2408 
2409         if (tabMode == QDockAreaLayoutInfo::ForceTabs)
2410             nestingEnabled = false;
2411     }
2412 #endif
2413 
2414 
2415     for (int i = 0; i < QInternal::DockCount; ++i) {
2416         const QDockAreaLayoutInfo &info = docks[i];
2417 
2418         if (!info.isEmpty() && info.rect.contains(pos)) {
2419             QList<int> result
2420                 = docks[i].gapIndex(pos, nestingEnabled, tabMode);
2421             if (!result.isEmpty())
2422                 result.prepend(i);
2423             return result;
2424         }
2425     }
2426 
2427     for (int i = 0; i < QInternal::DockCount; ++i) {
2428         const QDockAreaLayoutInfo &info = docks[i];
2429 
2430         if (info.isEmpty()) {
2431             QRect r;
2432             switch (i) {
2433                 case QInternal::LeftDock:
2434                     r = QRect(rect.left(), rect.top(), EmptyDropAreaSize, rect.height());
2435                     break;
2436                 case QInternal::RightDock:
2437                     r = QRect(rect.right() - EmptyDropAreaSize, rect.top(),
2438                                 EmptyDropAreaSize, rect.height());
2439                     break;
2440                 case QInternal::TopDock:
2441                     r = QRect(rect.left(), rect.top(), rect.width(), EmptyDropAreaSize);
2442                     break;
2443                 case QInternal::BottomDock:
2444                     r = QRect(rect.left(), rect.bottom() - EmptyDropAreaSize,
2445                                 rect.width(), EmptyDropAreaSize);
2446                     break;
2447             }
2448             if (r.contains(pos)) {
2449                 if (opts & QMainWindow::ForceTabbedDocks && !info.item_list.isEmpty()) {
2450                     //in case of ForceTabbedDocks, we pass -1 in order to force the gap to be tabbed
2451                     //it mustn't be completely empty otherwise it won't work
2452                     return QList<int>() << i << -1 << 0;
2453                 } else {
2454                     return QList<int>() << i << 0;
2455                 }
2456             }
2457         }
2458     }
2459 
2460     return QList<int>();
2461 }
2462 
2463 QList<int> QDockAreaLayout::findSeparator(const QPoint &pos) const
2464 {
2465     QList<int> result;
2466     for (int i = 0; i < QInternal::DockCount; ++i) {
2467         const QDockAreaLayoutInfo &info = docks[i];
2468         if (info.isEmpty())
2469             continue;
2470         QRect rect = separatorRect(i);
2471         if (!rect.isNull() && sep == 1)
2472             rect.adjust(-2, -2, 2, 2);
2473         if (rect.contains(pos) && !info.hasFixedSize()) {
2474             result << i;
2475             break;
2476         } else if (info.rect.contains(pos)) {
2477             result = docks[i].findSeparator(pos);
2478             if (!result.isEmpty()) {
2479                 result.prepend(i);
2480                 break;
2481             }
2482         }
2483     }
2484 
2485     return result;
2486 }
2487 
2488 QDockAreaLayoutInfo *QDockAreaLayout::info(QWidget *widget)
2489 {
2490     for (int i = 0; i < QInternal::DockCount; ++i) {
2491         if (QDockAreaLayoutInfo *result = docks[i].info(widget))
2492             return result;
2493     }
2494 
2495     return nullptr;
2496 }
2497 
2498 QDockAreaLayoutInfo *QDockAreaLayout::info(const QList<int> &path)
2499 {
2500     Q_ASSERT(!path.isEmpty());
2501     const int index = path.first();
2502     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2503 
2504     if (path.count() == 1)
2505         return &docks[index];
2506 
2507     return docks[index].info(path.mid(1));
2508 }
2509 
2510 const QDockAreaLayoutInfo *QDockAreaLayout::info(const QList<int> &path) const
2511 {
2512     return const_cast<QDockAreaLayout*>(this)->info(path);
2513 }
2514 
2515 QDockAreaLayoutItem &QDockAreaLayout::item(const QList<int> &path)
2516 {
2517     Q_ASSERT(!path.isEmpty());
2518     const int index = path.first();
2519     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2520     return docks[index].item(path.mid(1));
2521 }
2522 
2523 QRect QDockAreaLayout::itemRect(const QList<int> &path) const
2524 {
2525     Q_ASSERT(!path.isEmpty());
2526     const int index = path.first();
2527     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2528     return docks[index].itemRect(path.mid(1));
2529 }
2530 
2531 QRect QDockAreaLayout::separatorRect(int index) const
2532 {
2533     const QDockAreaLayoutInfo &dock = docks[index];
2534     if (dock.isEmpty())
2535         return QRect();
2536     QRect r = dock.rect;
2537     switch (index) {
2538         case QInternal::LeftDock:
2539             return QRect(r.right() + 1, r.top(), sep, r.height());
2540         case QInternal::RightDock:
2541             return QRect(r.left() - sep, r.top(), sep, r.height());
2542         case QInternal::TopDock:
2543             return QRect(r.left(), r.bottom() + 1, r.width(), sep);
2544         case QInternal::BottomDock:
2545             return QRect(r.left(), r.top() - sep, r.width(), sep);
2546         default:
2547             break;
2548     }
2549     return QRect();
2550 }
2551 
2552 QRect QDockAreaLayout::separatorRect(const QList<int> &path) const
2553 {
2554     Q_ASSERT(!path.isEmpty());
2555 
2556     const int index = path.first();
2557     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2558 
2559     if (path.count() == 1)
2560         return separatorRect(index);
2561     else
2562         return docks[index].separatorRect(path.mid(1));
2563 }
2564 
2565 bool QDockAreaLayout::insertGap(const QList<int> &path, QLayoutItem *dockWidgetItem)
2566 {
2567     Q_ASSERT(!path.isEmpty());
2568     const int index = path.first();
2569     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2570     return docks[index].insertGap(path.mid(1), dockWidgetItem);
2571 }
2572 
2573 QLayoutItem *QDockAreaLayout::plug(const QList<int> &path)
2574 {
2575 #if QT_CONFIG(tabbar)
2576     Q_ASSERT(!path.isEmpty());
2577     const int index = path.first();
2578     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2579     QLayoutItem *item = docks[index].plug(path.mid(1));
2580     docks[index].reparentWidgets(mainWindow);
2581     return item;
2582 #else
2583     return nullptr;
2584 #endif
2585 }
2586 
2587 QLayoutItem *QDockAreaLayout::unplug(const QList<int> &path)
2588 {
2589     Q_ASSERT(!path.isEmpty());
2590     const int index = path.first();
2591     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2592     return docks[index].unplug(path.mid(1));
2593 }
2594 
2595 void QDockAreaLayout::remove(const QList<int> &path)
2596 {
2597     Q_ASSERT(!path.isEmpty());
2598     const int index = path.first();
2599     Q_ASSERT(index >= 0 && index < QInternal::DockCount);
2600     docks[index].remove(path.mid(1));
2601 }
2602 
2603 void QDockAreaLayout::removePlaceHolder(const QString &name)
2604 {
2605     QList<int> index = indexOfPlaceHolder(name);
2606     if (!index.isEmpty())
2607         remove(index);
2608     const auto groups =
2609             mainWindow->findChildren<QDockWidgetGroupWindow *>(QString(), Qt::FindDirectChildrenOnly);
2610     for (QDockWidgetGroupWindow *dwgw : groups) {
2611         index = dwgw->layoutInfo()->indexOfPlaceHolder(name);
2612         if (!index.isEmpty()) {
2613             dwgw->layoutInfo()->remove(index);
2614             dwgw->destroyOrHideIfEmpty();
2615         }
2616     }
2617 }
2618 
2619 static inline int qMax(int i1, int i2, int i3) { return qMax(i1, qMax(i2, i3)); }
2620 
2621 void QDockAreaLayout::getGrid(QList<QLayoutStruct> *_ver_struct_list,
2622                               QList<QLayoutStruct> *_hor_struct_list)
2623 {
2624     QSize center_hint(0, 0);
2625     QSize center_min(0, 0);
2626     QSize center_max(0, 0);
2627     const bool have_central = centralWidgetItem != nullptr && !centralWidgetItem->isEmpty();
2628     if (have_central) {
2629         center_hint = centralWidgetRect.size();
2630         if (!center_hint.isValid())
2631             center_hint = centralWidgetItem->sizeHint();
2632         center_min = centralWidgetItem->minimumSize();
2633         center_max = centralWidgetItem->maximumSize();
2634     }
2635 
2636     QRect center_rect = rect;
2637     if (!docks[QInternal::LeftDock].isEmpty())
2638         center_rect.setLeft(rect.left() + docks[QInternal::LeftDock].rect.width() + sep);
2639     if (!docks[QInternal::TopDock].isEmpty())
2640         center_rect.setTop(rect.top() + docks[QInternal::TopDock].rect.height() + sep);
2641     if (!docks[QInternal::RightDock].isEmpty())
2642         center_rect.setRight(rect.right() - docks[QInternal::RightDock].rect.width() - sep);
2643     if (!docks[QInternal::BottomDock].isEmpty())
2644         center_rect.setBottom(rect.bottom() - docks[QInternal::BottomDock].rect.height() - sep);
2645 
2646     QSize left_hint = docks[QInternal::LeftDock].size();
2647     if (left_hint.isNull() || fallbackToSizeHints)
2648         left_hint = docks[QInternal::LeftDock].sizeHint();
2649     QSize left_min = docks[QInternal::LeftDock].minimumSize();
2650     QSize left_max = docks[QInternal::LeftDock].maximumSize();
2651     left_hint = left_hint.boundedTo(left_max).expandedTo(left_min);
2652 
2653     QSize right_hint = docks[QInternal::RightDock].size();
2654     if (right_hint.isNull() || fallbackToSizeHints)
2655         right_hint = docks[QInternal::RightDock].sizeHint();
2656     QSize right_min = docks[QInternal::RightDock].minimumSize();
2657     QSize right_max = docks[QInternal::RightDock].maximumSize();
2658     right_hint = right_hint.boundedTo(right_max).expandedTo(right_min);
2659 
2660     QSize top_hint = docks[QInternal::TopDock].size();
2661     if (top_hint.isNull() || fallbackToSizeHints)
2662         top_hint = docks[QInternal::TopDock].sizeHint();
2663     QSize top_min = docks[QInternal::TopDock].minimumSize();
2664     QSize top_max = docks[QInternal::TopDock].maximumSize();
2665     top_hint = top_hint.boundedTo(top_max).expandedTo(top_min);
2666 
2667     QSize bottom_hint = docks[QInternal::BottomDock].size();
2668     if (bottom_hint.isNull() || fallbackToSizeHints)
2669         bottom_hint = docks[QInternal::BottomDock].sizeHint();
2670     QSize bottom_min = docks[QInternal::BottomDock].minimumSize();
2671     QSize bottom_max = docks[QInternal::BottomDock].maximumSize();
2672     bottom_hint = bottom_hint.boundedTo(bottom_max).expandedTo(bottom_min);
2673 
2674     if (_ver_struct_list != nullptr) {
2675         QList<QLayoutStruct> &ver_struct_list = *_ver_struct_list;
2676         ver_struct_list.resize(3);
2677 
2678         // top --------------------------------------------------
2679         ver_struct_list[0].init();
2680         ver_struct_list[0].stretch = 0;
2681         ver_struct_list[0].sizeHint = top_hint.height();
2682         ver_struct_list[0].minimumSize = top_min.height();
2683         ver_struct_list[0].maximumSize = top_max.height();
2684         ver_struct_list[0].expansive = false;
2685         ver_struct_list[0].empty = docks[QInternal::TopDock].isEmpty();
2686         ver_struct_list[0].pos = docks[QInternal::TopDock].rect.top();
2687         ver_struct_list[0].size = docks[QInternal::TopDock].rect.height();
2688 
2689         // center --------------------------------------------------
2690         ver_struct_list[1].init();
2691         ver_struct_list[1].stretch = center_hint.height();
2692 
2693         bool tl_significant = corners[Qt::TopLeftCorner] == Qt::TopDockWidgetArea
2694                                     || docks[QInternal::TopDock].isEmpty();
2695         bool bl_significant = corners[Qt::BottomLeftCorner] == Qt::BottomDockWidgetArea
2696                                     || docks[QInternal::BottomDock].isEmpty();
2697         bool tr_significant = corners[Qt::TopRightCorner] == Qt::TopDockWidgetArea
2698                                     || docks[QInternal::TopDock].isEmpty();
2699         bool br_significant = corners[Qt::BottomRightCorner] == Qt::BottomDockWidgetArea
2700                                     || docks[QInternal::BottomDock].isEmpty();
2701 
2702         int left = (tl_significant && bl_significant) ? left_hint.height() : 0;
2703         int right = (tr_significant && br_significant) ? right_hint.height() : 0;
2704         ver_struct_list[1].sizeHint = qMax(left, center_hint.height(), right);
2705 
2706         left = (tl_significant && bl_significant) ? left_min.height() : 0;
2707         right = (tr_significant && br_significant) ? right_min.height() : 0;
2708         ver_struct_list[1].minimumSize = qMax(left, center_min.height(), right);
2709         ver_struct_list[1].maximumSize = center_max.height();
2710         ver_struct_list[1].expansive = have_central;
2711         ver_struct_list[1].empty = docks[QInternal::LeftDock].isEmpty()
2712                                         && !have_central
2713                                         && docks[QInternal::RightDock].isEmpty();
2714         ver_struct_list[1].pos = center_rect.top();
2715         ver_struct_list[1].size = center_rect.height();
2716 
2717         // bottom --------------------------------------------------
2718         ver_struct_list[2].init();
2719         ver_struct_list[2].stretch = 0;
2720         ver_struct_list[2].sizeHint = bottom_hint.height();
2721         ver_struct_list[2].minimumSize = bottom_min.height();
2722         ver_struct_list[2].maximumSize = bottom_max.height();
2723         ver_struct_list[2].expansive = false;
2724         ver_struct_list[2].empty = docks[QInternal::BottomDock].isEmpty();
2725         ver_struct_list[2].pos = docks[QInternal::BottomDock].rect.top();
2726         ver_struct_list[2].size = docks[QInternal::BottomDock].rect.height();
2727 
2728         for (int i = 0; i < 3; ++i) {
2729             ver_struct_list[i].sizeHint
2730                 = qMax(ver_struct_list[i].sizeHint, ver_struct_list[i].minimumSize);
2731         }
2732         if (have_central && ver_struct_list[0].empty && ver_struct_list[2].empty)
2733             ver_struct_list[1].maximumSize = QWIDGETSIZE_MAX;
2734     }
2735 
2736     if (_hor_struct_list != nullptr) {
2737         QList<QLayoutStruct> &hor_struct_list = *_hor_struct_list;
2738         hor_struct_list.resize(3);
2739 
2740         // left --------------------------------------------------
2741         hor_struct_list[0].init();
2742         hor_struct_list[0].stretch = 0;
2743         hor_struct_list[0].sizeHint = left_hint.width();
2744         hor_struct_list[0].minimumSize = left_min.width();
2745         hor_struct_list[0].maximumSize = left_max.width();
2746         hor_struct_list[0].expansive = false;
2747         hor_struct_list[0].empty = docks[QInternal::LeftDock].isEmpty();
2748         hor_struct_list[0].pos = docks[QInternal::LeftDock].rect.left();
2749         hor_struct_list[0].size = docks[QInternal::LeftDock].rect.width();
2750 
2751         // center --------------------------------------------------
2752         hor_struct_list[1].init();
2753         hor_struct_list[1].stretch = center_hint.width();
2754 
2755         bool tl_significant = corners[Qt::TopLeftCorner] == Qt::LeftDockWidgetArea
2756                                     || docks[QInternal::LeftDock].isEmpty();
2757         bool tr_significant = corners[Qt::TopRightCorner] == Qt::RightDockWidgetArea
2758                                     || docks[QInternal::RightDock].isEmpty();
2759         bool bl_significant = corners[Qt::BottomLeftCorner] == Qt::LeftDockWidgetArea
2760                                     || docks[QInternal::LeftDock].isEmpty();
2761         bool br_significant = corners[Qt::BottomRightCorner] == Qt::RightDockWidgetArea
2762                                     || docks[QInternal::RightDock].isEmpty();
2763 
2764         int top = (tl_significant && tr_significant) ? top_hint.width() : 0;
2765         int bottom = (bl_significant && br_significant) ? bottom_hint.width() : 0;
2766         hor_struct_list[1].sizeHint = qMax(top, center_hint.width(), bottom);
2767 
2768         top = (tl_significant && tr_significant) ? top_min.width() : 0;
2769         bottom = (bl_significant && br_significant) ? bottom_min.width() : 0;
2770         hor_struct_list[1].minimumSize = qMax(top, center_min.width(), bottom);
2771 
2772         hor_struct_list[1].maximumSize = center_max.width();
2773         hor_struct_list[1].expansive = have_central;
2774         hor_struct_list[1].empty = !have_central;
2775         hor_struct_list[1].pos = center_rect.left();
2776         hor_struct_list[1].size = center_rect.width();
2777 
2778         // right --------------------------------------------------
2779         hor_struct_list[2].init();
2780         hor_struct_list[2].stretch = 0;
2781         hor_struct_list[2].sizeHint = right_hint.width();
2782         hor_struct_list[2].minimumSize = right_min.width();
2783         hor_struct_list[2].maximumSize = right_max.width();
2784         hor_struct_list[2].expansive = false;
2785         hor_struct_list[2].empty = docks[QInternal::RightDock].isEmpty();
2786         hor_struct_list[2].pos = docks[QInternal::RightDock].rect.left();
2787         hor_struct_list[2].size = docks[QInternal::RightDock].rect.width();
2788 
2789         for (int i = 0; i < 3; ++i) {
2790             hor_struct_list[i].sizeHint
2791                 = qMax(hor_struct_list[i].sizeHint, hor_struct_list[i].minimumSize);
2792         }
2793         if (have_central && hor_struct_list[0].empty && hor_struct_list[2].empty)
2794             hor_struct_list[1].maximumSize = QWIDGETSIZE_MAX;
2795 
2796     }
2797 }
2798 
2799 void QDockAreaLayout::setGrid(QList<QLayoutStruct> *ver_struct_list,
2800                               QList<QLayoutStruct> *hor_struct_list)
2801 {
2802 
2803     // top ---------------------------------------------------
2804 
2805     if (!docks[QInternal::TopDock].isEmpty()) {
2806         QRect r = docks[QInternal::TopDock].rect;
2807         if (hor_struct_list != nullptr) {
2808             r.setLeft(corners[Qt::TopLeftCorner] == Qt::TopDockWidgetArea
2809                 || docks[QInternal::LeftDock].isEmpty()
2810                 ? rect.left() : hor_struct_list->at(1).pos);
2811             r.setRight(corners[Qt::TopRightCorner] == Qt::TopDockWidgetArea
2812                 || docks[QInternal::RightDock].isEmpty()
2813                 ? rect.right() : hor_struct_list->at(2).pos - sep - 1);
2814         }
2815         if (ver_struct_list != nullptr) {
2816             r.setTop(rect.top());
2817             r.setBottom(ver_struct_list->at(1).pos - sep - 1);
2818         }
2819         docks[QInternal::TopDock].rect = r;
2820         docks[QInternal::TopDock].fitItems();
2821     }
2822 
2823     // bottom ---------------------------------------------------
2824 
2825     if (!docks[QInternal::BottomDock].isEmpty()) {
2826         QRect r = docks[QInternal::BottomDock].rect;
2827         if (hor_struct_list != nullptr) {
2828             r.setLeft(corners[Qt::BottomLeftCorner] == Qt::BottomDockWidgetArea
2829                         || docks[QInternal::LeftDock].isEmpty()
2830                             ? rect.left() : hor_struct_list->at(1).pos);
2831             r.setRight(corners[Qt::BottomRightCorner] == Qt::BottomDockWidgetArea
2832                         || docks[QInternal::RightDock].isEmpty()
2833                             ? rect.right() : hor_struct_list->at(2).pos - sep - 1);
2834         }
2835         if (ver_struct_list != nullptr) {
2836             r.setTop(ver_struct_list->at(2).pos);
2837             r.setBottom(rect.bottom());
2838         }
2839         docks[QInternal::BottomDock].rect = r;
2840         docks[QInternal::BottomDock].fitItems();
2841     }
2842 
2843     // left ---------------------------------------------------
2844 
2845     if (!docks[QInternal::LeftDock].isEmpty()) {
2846         QRect r = docks[QInternal::LeftDock].rect;
2847         if (hor_struct_list != nullptr) {
2848             r.setLeft(rect.left());
2849             r.setRight(hor_struct_list->at(1).pos - sep - 1);
2850         }
2851         if (ver_struct_list != nullptr) {
2852             r.setTop(corners[Qt::TopLeftCorner] == Qt::LeftDockWidgetArea
2853                 || docks[QInternal::TopDock].isEmpty()
2854                 ? rect.top() : ver_struct_list->at(1).pos);
2855             r.setBottom(corners[Qt::BottomLeftCorner] == Qt::LeftDockWidgetArea
2856                 || docks[QInternal::BottomDock].isEmpty()
2857                 ? rect.bottom() : ver_struct_list->at(2).pos - sep - 1);
2858         }
2859         docks[QInternal::LeftDock].rect = r;
2860         docks[QInternal::LeftDock].fitItems();
2861     }
2862 
2863     // right ---------------------------------------------------
2864 
2865     if (!docks[QInternal::RightDock].isEmpty()) {
2866         QRect r = docks[QInternal::RightDock].rect;
2867         if (hor_struct_list != nullptr) {
2868             r.setLeft(hor_struct_list->at(2).pos);
2869             r.setRight(rect.right());
2870         }
2871         if (ver_struct_list != nullptr) {
2872             r.setTop(corners[Qt::TopRightCorner] == Qt::RightDockWidgetArea
2873                         || docks[QInternal::TopDock].isEmpty()
2874                             ? rect.top() : ver_struct_list->at(1).pos);
2875             r.setBottom(corners[Qt::BottomRightCorner] == Qt::RightDockWidgetArea
2876                         || docks[QInternal::BottomDock].isEmpty()
2877                             ? rect.bottom() : ver_struct_list->at(2).pos - sep - 1);
2878         }
2879         docks[QInternal::RightDock].rect = r;
2880         docks[QInternal::RightDock].fitItems();
2881     }
2882 
2883     // center ---------------------------------------------------
2884 
2885     if (hor_struct_list != nullptr) {
2886         centralWidgetRect.setLeft(hor_struct_list->at(1).pos);
2887         centralWidgetRect.setWidth(hor_struct_list->at(1).size);
2888     }
2889     if (ver_struct_list != nullptr) {
2890         centralWidgetRect.setTop(ver_struct_list->at(1).pos);
2891         centralWidgetRect.setHeight(ver_struct_list->at(1).size);
2892     }
2893 }
2894 
2895 void QDockAreaLayout::fitLayout()
2896 {
2897     QList<QLayoutStruct> ver_struct_list(3);
2898     QList<QLayoutStruct> hor_struct_list(3);
2899     getGrid(&ver_struct_list, &hor_struct_list);
2900 
2901     qGeomCalc(ver_struct_list, 0, 3, rect.top(), rect.height(), sep);
2902     qGeomCalc(hor_struct_list, 0, 3, rect.left(), rect.width(), sep);
2903 
2904     setGrid(&ver_struct_list, &hor_struct_list);
2905 }
2906 
2907 void QDockAreaLayout::clear()
2908 {
2909     for (int i = 0; i < QInternal::DockCount; ++i)
2910         docks[i].clear();
2911 
2912     rect = QRect();
2913     centralWidgetRect = QRect();
2914 }
2915 
2916 QSize QDockAreaLayout::sizeHint() const
2917 {
2918     int left_sep = 0;
2919     int right_sep = 0;
2920     int top_sep = 0;
2921     int bottom_sep = 0;
2922 
2923     if (centralWidgetItem != nullptr) {
2924         left_sep = docks[QInternal::LeftDock].isEmpty() ? 0 : sep;
2925         right_sep = docks[QInternal::RightDock].isEmpty() ? 0 : sep;
2926         top_sep = docks[QInternal::TopDock].isEmpty() ? 0 : sep;
2927         bottom_sep = docks[QInternal::BottomDock].isEmpty() ? 0 : sep;
2928     }
2929 
2930     QSize left = docks[QInternal::LeftDock].sizeHint() + QSize(left_sep, 0);
2931     QSize right = docks[QInternal::RightDock].sizeHint() + QSize(right_sep, 0);
2932     QSize top = docks[QInternal::TopDock].sizeHint() + QSize(0, top_sep);
2933     QSize bottom = docks[QInternal::BottomDock].sizeHint() + QSize(0, bottom_sep);
2934     QSize center = centralWidgetItem == nullptr ? QSize(0, 0) : centralWidgetItem->sizeHint();
2935 
2936     int row1 = top.width();
2937     int row2 = left.width() + center.width() + right.width();
2938     int row3 = bottom.width();
2939     int col1 = left.height();
2940     int col2 = top.height() + center.height() + bottom.height();
2941     int col3 = right.height();
2942 
2943     if (corners[Qt::TopLeftCorner] == Qt::LeftDockWidgetArea)
2944         row1 += left.width();
2945     else
2946         col1 += top.height();
2947 
2948     if (corners[Qt::TopRightCorner] == Qt::RightDockWidgetArea)
2949         row1 += right.width();
2950     else
2951         col3 += top.height();
2952 
2953     if (corners[Qt::BottomLeftCorner] == Qt::LeftDockWidgetArea)
2954         row3 += left.width();
2955     else
2956         col1 += bottom.height();
2957 
2958     if (corners[Qt::BottomRightCorner] == Qt::RightDockWidgetArea)
2959         row3 += right.width();
2960     else
2961         col3 += bottom.height();
2962 
2963     return QSize(qMax(row1, row2, row3), qMax(col1, col2, col3));
2964 }
2965 
2966 QSize QDockAreaLayout::minimumSize() const
2967 {
2968     int left_sep = 0;
2969     int right_sep = 0;
2970     int top_sep = 0;
2971     int bottom_sep = 0;
2972 
2973     if (centralWidgetItem != nullptr) {
2974         left_sep = docks[QInternal::LeftDock].isEmpty() ? 0 : sep;
2975         right_sep = docks[QInternal::RightDock].isEmpty() ? 0 : sep;
2976         top_sep = docks[QInternal::TopDock].isEmpty() ? 0 : sep;
2977         bottom_sep = docks[QInternal::BottomDock].isEmpty() ? 0 : sep;
2978     }
2979 
2980     QSize left = docks[QInternal::LeftDock].minimumSize() + QSize(left_sep, 0);
2981     QSize right = docks[QInternal::RightDock].minimumSize() + QSize(right_sep, 0);
2982     QSize top = docks[QInternal::TopDock].minimumSize() + QSize(0, top_sep);
2983     QSize bottom = docks[QInternal::BottomDock].minimumSize() + QSize(0, bottom_sep);
2984     QSize center = centralWidgetItem == nullptr ? QSize(0, 0) : centralWidgetItem->minimumSize();
2985 
2986     int row1 = top.width();
2987     int row2 = left.width() + center.width() + right.width();
2988     int row3 = bottom.width();
2989     int col1 = left.height();
2990     int col2 = top.height() + center.height() + bottom.height();
2991     int col3 = right.height();
2992 
2993     if (corners[Qt::TopLeftCorner] == Qt::LeftDockWidgetArea)
2994         row1 += left.width();
2995     else
2996         col1 += top.height();
2997 
2998     if (corners[Qt::TopRightCorner] == Qt::RightDockWidgetArea)
2999         row1 += right.width();
3000     else
3001         col3 += top.height();
3002 
3003     if (corners[Qt::BottomLeftCorner] == Qt::LeftDockWidgetArea)
3004         row3 += left.width();
3005     else
3006         col1 += bottom.height();
3007 
3008     if (corners[Qt::BottomRightCorner] == Qt::RightDockWidgetArea)
3009         row3 += right.width();
3010     else
3011         col3 += bottom.height();
3012 
3013     return QSize(qMax(row1, row2, row3), qMax(col1, col2, col3));
3014 }
3015 
3016 /*! \internal
3017     Try to fit the given rectangle \a rect on the screen which contains
3018     the window \a widget.
3019     Used to compute the geometry of a dragged a dock widget that should
3020     be shown with \a rect, but needs to be visible on the screen
3021  */
3022 QRect QDockAreaLayout::constrainedRect(QRect rect, QWidget* widget)
3023 {
3024     QScreen *screen;
3025     if (QGuiApplication::primaryScreen()->virtualSiblings().size() > 1)
3026         screen = QGuiApplication::screenAt(rect.topLeft());
3027     else
3028         screen = widget->screen();
3029 
3030     const QRect screenRect = screen->geometry();
3031     if (screenRect.isValid()) {
3032         rect.setWidth(qMin(rect.width(), screenRect.width()));
3033         rect.setHeight(qMin(rect.height(), screenRect.height()));
3034         rect.moveLeft(qMax(rect.left(), screenRect.left()));
3035         rect.moveTop(qMax(rect.top(), screenRect.top()));
3036         rect.moveRight(qMin(rect.right(), screenRect.right()));
3037         rect.moveBottom(qMin(rect.bottom(), screenRect.bottom()));
3038     }
3039 
3040     return rect;
3041 }
3042 
3043 bool QDockAreaLayout::restoreDockWidget(QDockWidget *dockWidget)
3044 {
3045     QDockAreaLayoutItem *item = nullptr;
3046     const auto groups =
3047             mainWindow->findChildren<QDockWidgetGroupWindow *>(QString(), Qt::FindDirectChildrenOnly);
3048     for (QDockWidgetGroupWindow *dwgw : groups) {
3049         QList<int> index = dwgw->layoutInfo()->indexOfPlaceHolder(dockWidget->objectName());
3050         if (!index.isEmpty()) {
3051             dockWidget->setParent(dwgw);
3052             item = const_cast<QDockAreaLayoutItem *>(&dwgw->layoutInfo()->item(index));
3053             break;
3054         }
3055     }
3056     if (!item) {
3057         QList<int> index = indexOfPlaceHolder(dockWidget->objectName());
3058         if (index.isEmpty())
3059             return false;
3060         item = const_cast<QDockAreaLayoutItem *>(&this->item(index));
3061     }
3062 
3063     QPlaceHolderItem *placeHolder = item->placeHolderItem;
3064     Q_ASSERT(placeHolder != nullptr);
3065 
3066     item->widgetItem = new QDockWidgetItem(dockWidget);
3067 
3068     if (placeHolder->window) {
3069         const QRect r = constrainedRect(placeHolder->topLevelRect, dockWidget);
3070         dockWidget->d_func()->setWindowState(true, true, r);
3071     }
3072     dockWidget->setVisible(!placeHolder->hidden);
3073 
3074     item->placeHolderItem = nullptr;
3075     delete placeHolder;
3076 
3077     return true;
3078 }
3079 
3080 void QDockAreaLayout::addDockWidget(QInternal::DockPosition pos, QDockWidget *dockWidget,
3081                                              Qt::Orientation orientation)
3082 {
3083     QLayoutItem *dockWidgetItem = new QDockWidgetItem(dockWidget);
3084     QDockAreaLayoutInfo &info = docks[pos];
3085     if (orientation == info.o || info.item_list.count() <= 1) {
3086         // empty dock areas, or dock areas containing exactly one widget can have their orientation
3087         // switched.
3088         info.o = orientation;
3089 
3090         QDockAreaLayoutItem new_item(dockWidgetItem);
3091         info.item_list.append(new_item);
3092 #if QT_CONFIG(tabbar)
3093         if (info.tabbed && !new_item.skip()) {
3094             info.updateTabBar();
3095             info.setCurrentTabId(tabId(new_item));
3096         }
3097 #endif
3098     } else {
3099 #if QT_CONFIG(tabbar)
3100         int tbshape = info.tabBarShape;
3101 #else
3102         int tbshape = 0;
3103 #endif
3104         QDockAreaLayoutInfo new_info(&sep, pos, orientation, tbshape, mainWindow);
3105         new_info.item_list.append(QDockAreaLayoutItem(new QDockAreaLayoutInfo(info)));
3106         new_info.item_list.append(QDockAreaLayoutItem(dockWidgetItem));
3107         info = new_info;
3108     }
3109 
3110     removePlaceHolder(dockWidget->objectName());
3111 }
3112 
3113 #if QT_CONFIG(tabbar)
3114 void QDockAreaLayout::tabifyDockWidget(QDockWidget *first, QDockWidget *second)
3115 {
3116     const QList<int> path = indexOf(first);
3117     if (path.isEmpty())
3118         return;
3119 
3120     QDockAreaLayoutInfo *info = this->info(path);
3121     Q_ASSERT(info != nullptr);
3122     info->tab(path.last(), new QDockWidgetItem(second));
3123 
3124     removePlaceHolder(second->objectName());
3125 }
3126 #endif // QT_CONFIG(tabbar)
3127 
3128 void QDockAreaLayout::resizeDocks(const QList<QDockWidget *> &docks,
3129                                   const QList<int> &sizes, Qt::Orientation o)
3130 {
3131     if (Q_UNLIKELY(docks.count() != sizes.count())) {
3132         qWarning("QMainWidget::resizeDocks: size of the lists are not the same");
3133         return;
3134     }
3135     int count = docks.count();
3136     fallbackToSizeHints = false;
3137     for (int i = 0; i < count; ++i) {
3138         QList<int> path = indexOf(docks[i]);
3139         if (Q_UNLIKELY(path.isEmpty())) {
3140             qWarning("QMainWidget::resizeDocks: one QDockWidget is not part of the layout");
3141             continue;
3142         }
3143         int size = sizes[i];
3144         if (Q_UNLIKELY(size <= 0)) {
3145             qWarning("QMainWidget::resizeDocks: all sizes need to be larger than 0");
3146             size = 1;
3147         }
3148 
3149         while (path.size() > 1) {
3150             QDockAreaLayoutInfo *info = this->info(path);
3151 #if QT_CONFIG(tabbar)
3152             if (!info->tabbed && info->o == o) {
3153                 info->item_list[path.constLast()].size = size;
3154                 int totalSize = 0;
3155                 for (const QDockAreaLayoutItem &item : qAsConst(info->item_list)) {
3156                     if (!item.skip()) {
3157                         if (totalSize != 0)
3158                             totalSize += sep;
3159                         totalSize += item.size == -1 ? pick(o, item.sizeHint()) : item.size;
3160                     }
3161                 }
3162                 size = totalSize;
3163             }
3164 #endif // QT_CONFIG(tabbar)
3165             path.removeLast();
3166         }
3167 
3168         const int dockNum = path.constFirst();
3169         Q_ASSERT(dockNum < QInternal::DockCount);
3170         QRect &r = this->docks[dockNum].rect;
3171         QSize s = r.size();
3172         rpick(o, s) = size;
3173         r.setSize(s);
3174     }
3175 }
3176 
3177 void QDockAreaLayout::splitDockWidget(QDockWidget *after,
3178                                                QDockWidget *dockWidget,
3179                                                Qt::Orientation orientation)
3180 {
3181     const QList<int> path = indexOf(after);
3182     if (path.isEmpty())
3183         return;
3184 
3185     QDockAreaLayoutInfo *info = this->info(path);
3186     Q_ASSERT(info != nullptr);
3187     info->split(path.last(), orientation, new QDockWidgetItem(dockWidget));
3188 
3189     removePlaceHolder(dockWidget->objectName());
3190 }
3191 
3192 void QDockAreaLayout::apply(bool animate)
3193 {
3194     QWidgetAnimator &widgetAnimator = qt_mainwindow_layout(mainWindow)->widgetAnimator;
3195 
3196     for (int i = 0; i < QInternal::DockCount; ++i)
3197         docks[i].apply(animate);
3198     if (centralWidgetItem != nullptr && !centralWidgetItem->isEmpty()) {
3199         widgetAnimator.animate(centralWidgetItem->widget(), centralWidgetRect,
3200                                 animate);
3201     }
3202 #if QT_CONFIG(tabbar)
3203     if (sep == 1)
3204         updateSeparatorWidgets();
3205 #endif // QT_CONFIG(tabbar)
3206 }
3207 
3208 void QDockAreaLayout::paintSeparators(QPainter *p, QWidget *widget,
3209                                                 const QRegion &clip,
3210                                                 const QPoint &mouse) const
3211 {
3212     for (int i = 0; i < QInternal::DockCount; ++i) {
3213         const QDockAreaLayoutInfo &dock = docks[i];
3214         if (dock.isEmpty())
3215             continue;
3216         QRect r = separatorRect(i);
3217         if (clip.contains(r) && !dock.hasFixedSize()) {
3218             Qt::Orientation opposite = dock.o == Qt::Horizontal
3219                                         ? Qt::Vertical : Qt::Horizontal;
3220             paintSep(p, widget, r, opposite, r.contains(mouse));
3221         }
3222         if (clip.contains(dock.rect))
3223             dock.paintSeparators(p, widget, clip, mouse);
3224     }
3225 }
3226 
3227 QRegion QDockAreaLayout::separatorRegion() const
3228 {
3229     QRegion result;
3230 
3231     for (int i = 0; i < QInternal::DockCount; ++i) {
3232         const QDockAreaLayoutInfo &dock = docks[i];
3233         if (dock.isEmpty())
3234             continue;
3235         result |= separatorRect(i);
3236         result |= dock.separatorRegion();
3237     }
3238 
3239     return result;
3240 }
3241 
3242 int QDockAreaLayout::separatorMove(const QList<int> &separator, const QPoint &origin,
3243                                                 const QPoint &dest)
3244 {
3245     int delta = 0;
3246     int index = separator.last();
3247 
3248     if (separator.count() > 1) {
3249         QDockAreaLayoutInfo *info = this->info(separator);
3250         delta = pick(info->o, dest - origin);
3251         if (delta != 0)
3252             delta = info->separatorMove(index, delta);
3253         info->apply(false);
3254         return delta;
3255     }
3256 
3257     QList<QLayoutStruct> list;
3258 
3259     if (index == QInternal::LeftDock || index == QInternal::RightDock)
3260         getGrid(nullptr, &list);
3261     else
3262         getGrid(&list, nullptr);
3263 
3264     int sep_index = index == QInternal::LeftDock || index == QInternal::TopDock
3265                         ? 0 : 1;
3266     Qt::Orientation o = index == QInternal::LeftDock || index == QInternal::RightDock
3267                         ? Qt::Horizontal
3268                         : Qt::Vertical;
3269 
3270     delta = pick(o, dest - origin);
3271     delta = separatorMoveHelper(list, sep_index, delta, sep);
3272 
3273     fallbackToSizeHints = false;
3274 
3275     if (index == QInternal::LeftDock || index == QInternal::RightDock)
3276         setGrid(nullptr, &list);
3277     else
3278         setGrid(&list, nullptr);
3279 
3280     apply(false);
3281 
3282     return delta;
3283 }
3284 
3285 int QDockAreaLayoutInfo::separatorMove(const QList<int> &separator, const QPoint &origin,
3286                                        const QPoint &dest)
3287 {
3288     int delta = 0;
3289     int index = separator.last();
3290     QDockAreaLayoutInfo *info = this->info(separator);
3291     delta = pick(info->o, dest - origin);
3292     if (delta != 0)
3293         delta = info->separatorMove(index, delta);
3294     info->apply(false);
3295     return delta;
3296 }
3297 
3298 #if QT_CONFIG(tabbar)
3299 // Sets the correct positions for the separator widgets
3300 // Allocates new sepearator widgets with getSeparatorWidget
3301 void QDockAreaLayout::updateSeparatorWidgets() const
3302 {
3303     int j = 0;
3304 
3305     for (int i = 0; i < QInternal::DockCount; ++i) {
3306         const QDockAreaLayoutInfo &dock = docks[i];
3307         if (dock.isEmpty())
3308             continue;
3309 
3310         QWidget *sepWidget;
3311         if (j < separatorWidgets.size()) {
3312             sepWidget = separatorWidgets.at(j);
3313         } else {
3314             sepWidget = qt_mainwindow_layout(mainWindow)->getSeparatorWidget();
3315             separatorWidgets.append(sepWidget);
3316         }
3317         j++;
3318 
3319         sepWidget->raise();
3320 
3321         QRect sepRect = separatorRect(i).adjusted(-2, -2, 2, 2);
3322         sepWidget->setGeometry(sepRect);
3323         sepWidget->setMask( QRegion(separatorRect(i).translated( - sepRect.topLeft())));
3324         sepWidget->show();
3325     }
3326     for (int i = j; i < separatorWidgets.size(); ++i)
3327         separatorWidgets.at(i)->hide();
3328 
3329     separatorWidgets.resize(j);
3330 }
3331 #endif // QT_CONFIG(tabbar)
3332 
3333 QLayoutItem *QDockAreaLayout::itemAt(int *x, int index) const
3334 {
3335     Q_ASSERT(x != nullptr);
3336 
3337     for (int i = 0; i < QInternal::DockCount; ++i) {
3338         const QDockAreaLayoutInfo &dock = docks[i];
3339         if (QLayoutItem *ret = dock.itemAt(x, index))
3340             return ret;
3341     }
3342 
3343     if (centralWidgetItem && (*x)++ == index)
3344         return centralWidgetItem;
3345 
3346     return nullptr;
3347 }
3348 
3349 QLayoutItem *QDockAreaLayout::takeAt(int *x, int index)
3350 {
3351     Q_ASSERT(x != nullptr);
3352 
3353     for (int i = 0; i < QInternal::DockCount; ++i) {
3354         QDockAreaLayoutInfo &dock = docks[i];
3355         if (QLayoutItem *ret = dock.takeAt(x, index))
3356             return ret;
3357     }
3358 
3359     if (centralWidgetItem && (*x)++ == index) {
3360         QLayoutItem *ret = centralWidgetItem;
3361         centralWidgetItem = nullptr;
3362         return ret;
3363     }
3364 
3365     return nullptr;
3366 }
3367 
3368 void QDockAreaLayout::deleteAllLayoutItems()
3369 {
3370     for (int i = 0; i < QInternal::DockCount; ++i)
3371         docks[i].deleteAllLayoutItems();
3372 }
3373 
3374 #if QT_CONFIG(tabbar)
3375 QSet<QTabBar*> QDockAreaLayout::usedTabBars() const
3376 {
3377     QSet<QTabBar*> result;
3378     for (int i = 0; i < QInternal::DockCount; ++i) {
3379         const QDockAreaLayoutInfo &dock = docks[i];
3380         result += dock.usedTabBars();
3381     }
3382     return result;
3383 }
3384 
3385 // Returns the set of all used separator widgets
3386 QSet<QWidget*> QDockAreaLayout::usedSeparatorWidgets() const
3387 {
3388     QSet<QWidget*> result;
3389     const int numSeparators = separatorWidgets.count();
3390     result.reserve(numSeparators);
3391     for (int i = 0; i < numSeparators; ++i)
3392         result << separatorWidgets.at(i);
3393     for (int i = 0; i < QInternal::DockCount; ++i) {
3394         const QDockAreaLayoutInfo &dock = docks[i];
3395         result += dock.usedSeparatorWidgets();
3396     }
3397     return result;
3398 }
3399 #endif
3400 
3401 QRect QDockAreaLayout::gapRect(const QList<int> &path) const
3402 {
3403     const QDockAreaLayoutInfo *info = this->info(path);
3404     if (info == nullptr)
3405         return QRect();
3406     int index = path.last();
3407     if (index < 0 || index >= info->item_list.count())
3408         return QRect();
3409     return info->itemRect(index, true);
3410 }
3411 
3412 void QDockAreaLayout::keepSize(QDockWidget *w)
3413 {
3414     QList<int> path = indexOf(w);
3415     if (path.isEmpty())
3416         return;
3417     QDockAreaLayoutItem &item = this->item(path);
3418     if (item.size != -1)
3419         item.flags |= QDockAreaLayoutItem::KeepSize;
3420 }
3421 
3422 void QDockAreaLayout::styleChangedEvent()
3423 {
3424     sep = mainWindow->style()->pixelMetric(QStyle::PM_DockWidgetSeparatorExtent, nullptr, mainWindow);
3425     if (isValid())
3426         fitLayout();
3427 }
3428 
3429 QT_END_NAMESPACE
