Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 #include "qcalendar.h"
40 #include "qcalendarbackend_p.h"
41 #include "qgregoriancalendar_p.h"
42 #ifndef QT_BOOTSTRAPPED
43 #include "qjuliancalendar_p.h"
44 #include "qmilankoviccalendar_p.h"
45 #endif
46 #if QT_CONFIG(jalalicalendar)
47 #include "qjalalicalendar_p.h"
48 #endif
49 #if QT_CONFIG(islamiccivilcalendar)
50 #include "qislamiccivilcalendar_p.h"
51 #endif
52 
53 #include "qatomic.h"
54 #include "qdatetime.h"
55 #include "qcalendarmath_p.h"
56 #include <qhash.h>
57 #include <qreadwritelock.h>
58 #include <qdebug.h>
59 
60 #include <vector>
61 
62 QT_BEGIN_NAMESPACE
63 
64 namespace {
65 
66 struct CalendarName : public QString
67 {
68     CalendarName(const QString &name) : QString(name) {}
69 };
70 
71 inline bool operator==(const CalendarName &u, const CalendarName &v)
72 {
73     return u.compare(v, Qt::CaseInsensitive) == 0;
74 }
75 
76 inline size_t qHash(const CalendarName &key, size_t seed = 0) noexcept
77 {
78     return qHash(key.toLower(), seed);
79 }
80 
81 } // anonymous namespace
82 
83 namespace QtPrivate {
84 
85 class QCalendarRegistry
86 {
87     /*!
88         \internal
89         Lock protecting the registry from concurrent modification.
90     */
91     QReadWriteLock lock;
92 
93     /*!
94         \internal
95         Vector containing all registered backends.
96 
97         The indices 0 to QCalendar::System::Last inclusive are allocated
98         for system backends and always present (but may be null).
99     */
100     std::vector<QCalendarBackend::Ptr> byId;
101 
102     /*!
103         \internal
104         Backends registered by name.
105 
106         Each backend may be registered with several names associated with it.
107         The names are case-insensitive.
108     */
109     QHash<CalendarName, QCalendarBackend::Ptr> byName;
110 
111     /*!
112         \internal
113         Pointer to the Gregorian backend for faster lockless access to it.
114 
115         This pointer may be null if the Gregorian backend is not yet registered.
116         This pointer may only be set once and only when write lock is held on
117         the registry.
118     */
119     QCalendarBackend::Ptr gregorianCalendar;
120 
121     enum : int { Unpopulated, Populated };
122     /*!
123         \internal
124         Fast way to check whether the standard calendars were populated.
125 
126         The status should only be changed while the write lock is held.
127     */
128     QAtomicInt status = Unpopulated;
129 
130     void ensurePopulated();
131     QCalendarBackend::Ptr registerSystemBackendLockHeld(QCalendar::System system);
132     QCalendarBackend::Ptr registerBackendLockHeld(QCalendarBackend *backend,
133                                                   QCalendar::System system);
134 
135 public:
136     QCalendarRegistry() { byId.resize(int(QCalendar::System::Last) + 1); }
137 
138     void registerBackend(QCalendarBackend *backend, QCalendar::System system);
139 
140     QStringList availableCalendars();
141 
142     /*!
143         \internal
144         Returns backend for Gregorian calendar.
145 
146         The backend is returned without locking the registry if possible.
147     */
148     QCalendarBackend::Ptr gregorian()
149     {
150         if (Q_LIKELY(gregorianCalendar))
151             return gregorianCalendar;
152         return fromEnum(QCalendar::System::Gregorian);
153     }
154 
155     /*!
156         \internal
157         Returns \a true if the argument matches the registered Gregorian backend.
158 
159         \a backend should not be null.
160     */
161     bool isGregorian(const QCalendarBackend *backend) const { return backend == gregorianCalendar; }
162 
163     QCalendarBackend::Ptr fromName(QAnyStringView name);
164     QCalendarBackend::Ptr fromIndex(size_t index);
165     QCalendarBackend::Ptr fromEnum(QCalendar::System system);
166 };
167 
168 /*!
169     \internal
170     Registers a backend.
171 
172     If \a system is QCalendar::System::User, a new unique ID is allocated;
173     otherwise, \a system must be a member of the QCalendar::System enumeration
174     and the \a calendar is registered with that as its ID. The registry takes
175     ownership of the \a backend.
176 
177     The names of the backend are also registered. Duplicate names are ignored
178     for user backends, but cause assertion (when enabled) for system backends.
179 
180     It is an error to pass a backend that is already registered.
181 
182     \a backend should be fully initialized. It becomes available to other
183     threads before this function returns.
184 */
185 void QCalendarRegistry::registerBackend(QCalendarBackend *backend, QCalendar::System system)
186 {
187     Q_ASSERT(!backend->calendarId().isValid());
188 
189     // Register standard calendar names before user ones
190     if (system == QCalendar::System::User)
191         ensurePopulated();
192 
193     QWriteLocker locker(&lock);
194     registerBackendLockHeld(backend, system);
195 }
196 
197 /*!
198     \internal
199     Ensures each \c{enum}-available calendar has been instantiated.
200 
201     This arranges for each system backend to be registered; it only does anything on
202     its first call, which ensures that name-based lookups can always find all
203     the calendars available via the \c enum.
204 */
205 void QCalendarRegistry::ensurePopulated()
206 {
207     if (Q_LIKELY(status.loadAcquire() != Unpopulated))
208         return;
209 
210     QWriteLocker locker(&lock);
211     if (status.loadAcquire() != Unpopulated)
212         return;
213 
214     for (int i = 0; i <= int(QCalendar::System::Last); ++i) {
215         if (byId[i] == nullptr)
216             registerSystemBackendLockHeld(QCalendar::System(i));
217     }
218 
219 #if defined(QT_FORCE_ASSERTS) || !defined(QT_NO_DEBUG)
220     auto oldValue = status.fetchAndStoreRelease(Populated);
221     Q_ASSERT(oldValue == Unpopulated);
222 #else
223     status.storeRelease(Populated);
224 #endif
225 }
226 
227 /*!
228     \internal
229     Helper functions for system backend registration.
230 
231     This function must be called with write lock held on the registry.
232 
233     \sa registerSystemBackend
234 */
235 QCalendarBackend::Ptr QCalendarRegistry::registerSystemBackendLockHeld(QCalendar::System system)
236 {
237     Q_ASSERT(system != QCalendar::System::User);
238 
239     QCalendarBackend *backend = nullptr;
240 
241     switch (system) {
242     case QCalendar::System::Gregorian:
243         backend = new QGregorianCalendar;
244         break;
245 #ifndef QT_BOOTSTRAPPED
246     case QCalendar::System::Julian:
247         backend = new QJulianCalendar;
248         break;
249     case QCalendar::System::Milankovic:
250         backend = new QMilankovicCalendar;
251         break;
252 #endif
253 #if QT_CONFIG(jalalicalendar)
254     case QCalendar::System::Jalali:
255         backend = new QJalaliCalendar;
256         break;
257 #endif
258 #if QT_CONFIG(islamiccivilcalendar)
259     case QCalendar::System::IslamicCivil:
260         backend = new QIslamicCivilCalendar;
261         break;
262 #else // When highest-numbered system isn't enabled, ensure we have a case for Last:
263     case QCalendar::System::Last:
264 #endif
265     case QCalendar::System::User:
266         Q_UNREACHABLE();
267     }
268     if (!backend)
269         return nullptr;
270 
271     auto p = registerBackendLockHeld(backend, system);
272     Q_ASSERT(backend == byId[size_t(system)]);
273 
274     return p;
275 }
276 
277 /*!
278     \internal
279     Helper function for backend registration.
280 
281     This function must be called with write lock held on the registry.
282 
283     \sa registerBackend
284 */
285 QCalendarBackend::Ptr QCalendarRegistry::registerBackendLockHeld(QCalendarBackend *backend,
286                                                                  QCalendar::System system)
287 {
288     Q_ASSERT(!backend->calendarId().isValid());
289 
290     auto index = size_t(system);
291 
292     // Note: it is important to update the calendar ID before making
293     // the calendar available for queries.
294     QCalendarBackend::Ptr p(backend);
295 
296     if (system == QCalendar::System::User) {
297         backend->setIndex(byId.size());
298         byId.push_back(p);
299     } else if (byId[index] == nullptr) {
300         backend->setIndex(index);
301         if (system == QCalendar::System::Gregorian) {
302             Q_ASSERT(gregorianCalendar.isNull());
303             gregorianCalendar = p;
304         }
305 
306         Q_ASSERT(byId.size() > index);
307         Q_ASSERT(byId[index] == nullptr);
308         byId[index] = p;
309     }
310 
311     // Register any names.
312     for (const auto &name : backend->names()) {
313         if (byName.contains(name)) {
314             Q_ASSERT(system == QCalendar::System::User);
315             qWarning() << "Cannot register name" << name << "(already in use).";
316         } else {
317             byName[name] = p;
318         }
319     }
320 
321     return p;
322 }
323 
324 /*!
325     Returns a list of names of the available calendar systems. Any
326     QCalendarBackend sub-class must be registered before being exposed to Date
327     and Time APIs.
328 
329     \sa fromName()
330 */
331 QStringList QCalendarRegistry::availableCalendars()
332 {
333     ensurePopulated();
334 
335     QReadLocker locker(&lock);
336     return QStringList(byName.keyBegin(), byName.keyEnd());
337 }
338 
339 /*!
340     \internal
341     Returns a pointer to a named calendar backend.
342 
343     If the given \a name is present in availableCalendars(), the backend
344     matching it is returned; otherwise, \c nullptr is returned. Matching of
345     names ignores case. Note that this does not provoke construction of a
346     calendar backend, other than those available via \l fromEnum(): it will only
347     return ones that have been instantiated (and not yet destroyed) by some
348     other means.
349 
350     \sa availableCalendars(), fromEnum(), fromIndex()
351 */
352 QCalendarBackend::Ptr QCalendarRegistry::fromName(QAnyStringView name)
353 {
354     ensurePopulated();
355 
356     QReadLocker locker(&lock);
357     return byName.value(name.toString(), nullptr);
358 }
359 
360 /*!
361     \internal
362     Returns a pointer to a calendar backend, specified by index.
363 
364     If a calendar with ID \a index is known to the calendar registry, the backend
365     with this ID is returned; otherwise, \c nullptr is returned. Note that this
366     does not provoke construction of a calendar backend, other than those
367     available via \l fromEnum(): it will only return ones that have been
368     instantiated (and not yet destroyed) by some other means.
369 
370     \sa fromEnum(), calendarId()
371 */
372 QCalendarBackend::Ptr QCalendarRegistry::fromIndex(size_t index)
373 {
374     {
375         QReadLocker locker(&lock);
376 
377         if (index >= byId.size())
378             return nullptr;
379 
380         if (auto backend = byId[index])
381             return backend;
382     }
383 
384     if (index <= size_t(QCalendar::System::Last))
385         return fromEnum(QCalendar::System(index));
386 
387     return nullptr;
388 }
389 
390 /*!
391     \internal
392     Returns a pointer to a calendar backend, specified by \c enum.
393 
394     This will instantiate the indicated calendar (which will enable fromName()
395     to return it subsequently), but only for the Qt-supported calendars for
396     which (where relevant) the appropriate feature has been enabled.
397 
398     \a system should be a member of \a QCalendar::System other than
399     \a QCalendar::System::User.
400 
401     \sa fromName(), fromId()
402 */
403 QCalendarBackend::Ptr QCalendarRegistry::fromEnum(QCalendar::System system)
404 {
405     Q_ASSERT(system <= QCalendar::System::Last);
406     auto index = size_t(system);
407 
408     {
409         QReadLocker locker(&lock);
410         Q_ASSERT(byId.size() > index);
411         if (auto backend = byId[index])
412             return backend;
413     }
414 
415     QWriteLocker locker(&lock);
416 
417     // Check if the backend was registered after releasing the read lock above.
418     if (auto backend = byId[index])
419         return backend;
420 
421     return registerSystemBackendLockHeld(system);
422 }
423 
424 } // namespace QtPrivate
425 
426 Q_GLOBAL_STATIC(QtPrivate::QCalendarRegistry, calendarRegistry);
427 
428 /*!
429     \since 5.14
430 
431     \class QCalendarBackend
432     \inmodule QtCore
433     \internal
434     \reentrant
435     \brief The QCalendarBackend class provides basic calendaring functions.
436 
437     QCalendarBackend provides the base class on which all calendar types are
438     implemented. The backend must be registered before it is available via
439     QCalendar API. The registration for system backends is arranged by
440     the calendar registry. User backends may be registered using the
441     \c registerUserBackend() method.
442 
443     A backend may also be registered by one or more names. Registering with the
444     name used by CLDR (the Unicode consortium's Common Locale Data Repository)
445     is recommended, particularly when interacting with third-party software.
446     Once a backend is registered for a name, QCalendar can be constructed using
447     that name to select the backend.
448 
449     Each built-in backend has a distinct primary name and all built-in backends
450     are instantiated before any custom backend is registered, to prevent custom
451     backends with conflicting names from replacing built-in backends.
452 
453     Each calendar backend must inherit from QCalendarBackend and implement its
454     pure virtual methods. It may also override some other virtual methods, as
455     needed.
456 
457     Most backends are pure code, with only one data element (this base-classe's
458     \c m_id). Such backends should normally be implemented as singletons.
459 
460     The backends may be used by multiple threads simultaneously, the virtual
461     methods must be implemented in a \l {thread-safe} way.
462 
463     \section1 Instantiating backends
464 
465     Backends may be defined by third-party, plugin or user code. When such
466     custom backends are registered they shall be alloced a unique ID, by
467     which client code may access it. A custom backend instance can have no names
468     if access by name is not needed, or impractical (e.g. because the backend
469     is not a singleton and constructing names for each instance would not make
470     sense). If a custom backend has names that are already registered for
471     another backend, those names are ignored.
472 
473     A backend class that has instance variables as well as code may be
474     instantiated many times, each with a distinct set of names, to implement
475     distinct backends - presumably variants on some parameterized calendar.
476     Each instance is then a distinct backend. A pure code backend class shall
477     typically only be instantiated once, as it is only capable of representing
478     one backend.
479 
480     Each backend should be instantiated exactly once, on the heap (using the C++
481     \c new operator), so that the registry can take ownership of it after
482     registration.
483 
484     Built-in backends, identified by \c QCalendar::System values other than
485     \c{User}, should only be registered by \c{QCalendarRegistry::fromEnum()};
486     no other code should ever register one, this guarantees that such a backend
487     will be a singleton.
488 
489     The shareable base-classes for backends, QRomanCalendar and QHijriCalendar,
490     are not themselves identified by QCalendar::System and may be used as
491     base-classes for custom calendar backends, but cannot be instantiated
492     themselves.
493 
494     \sa calendarId(), QDate, QDateTime, QDateEdit,
495         QDateTimeEdit, QCalendarWidget
496 */
497 
498 /*!
499     Destroys the calendar backend.
500 
501     Each calendar backend, once instantiated and successfully registered by ID,
502     shall exist for the lifetime of the program. Destroying a
503     successfully-registered backend otherwise may leave existing QCalendar
504     instances referencing the destroyed calendar, with undefined results.
505 
506     If a backend has not been registered it may safely be deleted.
507 
508     \sa calendarId()
509 */
510 QCalendarBackend::~QCalendarBackend()
511 {
512 }
513 
514 /*!
515     Returns the primary name of the calendar.
516 
517     This is the first element returned by \a names() or an empty string if the
518     list is empty.
519  */
520 QString QCalendarBackend::name() const
521 {
522     return names().value(0, QString());
523 }
524 
525 /*!
526     Set the internal index of the backed to the specified value.
527 
528     This method exists to allow QCalendarRegistry to update the backend ID
529     after registration without exposing it in public API for QCalendar.
530  */
531 void QCalendarBackend::setIndex(size_t index)
532 {
533     Q_ASSERT(!m_id.isValid());
534     m_id.id = index;
535 }
536 
537 /*!
538     Register this backend as a user backend.
539 
540     The backend should not already be registered. This method should only be
541     called on on objects that are completely initialized because they become
542     available to other threads immediately. In particular, it is not a good
543     idea to call this function in constructors of classes that may be derived.
544 
545     Returns the new ID assigned to this backend. If its isValid() is \c true,
546     the calendar registry has taken ownership of the object; this ID can then
547     be used to create \c QCalendar instances. Otherwise, registration failed
548     and the caller is responsible for destruction of the backend, which shall
549     not be available for use by \c QCalendar. Failure should normally only
550     happen if registration is attempted during program termination.
551 */
552 QCalendar::SystemId QCalendarBackend::registerUserBackend()
553 {
554     Q_ASSERT(!m_id.isValid());
555 
556     if (!calendarRegistry.isDestroyed())
557         calendarRegistry->registerBackend(this, QCalendar::System::User);
558 
559     return m_id;
560 }
561 
562 bool QCalendarBackend::isGregorian() const
563 {
564     if (calendarRegistry.isDestroyed())
565         return false;
566 
567     return calendarRegistry->isGregorian(this);
568 }
569 
570 /*!
571     \since 6.2
572     \fn QCalendar::SystemId QCalendarBackend::calendarId() const
573 
574     Each backend is allocated an ID when successfully registered. A backend whose
575     calendarId() has isValid() \c{false} has not been registered; it also cannot
576     be used, as it is not known to any of the available ways to create a QCalendar.
577 
578     \sa calendarSystem(), fromId()
579 */
580 
581 /*!
582     The calendar system of this calendar.
583 
584     \sa fromEnum(), calendarId()
585 */
586 QCalendar::System QCalendarBackend::calendarSystem() const
587 {
588     return m_id.isInEnum() ? QCalendar::System(m_id.index()) : QCalendar::System::User;
589 }
590 
591 /*!
592     \fn QStringList QCalendarBackend::names() const;
593 
594     This virtual method can be overridden by each backend implementation
595     to return a list of names with which this backend should be registered.
596 
597     The default implementation returns an empty list meaning that the backend
598     will only be available by ID once registered.
599 */
600 
601 /*!
602     The primary name of this calendar.
603 
604     The calendar may also be known by some aliases. A calendar instantiated by
605     name may use such an alias, in which case its name() need not match the
606     alias by which it was instantiated.
607 */
608 QString QCalendar::name() const
609 {
610     return d ? d->name() : QString();
611 }
612 
613 // date queries
614 /*!
615    \fn int QCalendarBackend::daysInMonth(int month, int year) const
616 
617    Returns number of days in the month number \a month, in year \a year.
618 
619    An implementation should return 0 if the given year had no such month. If
620    year is QCalendar::Unspecified, return the usual number of days for the
621    month, in those years that include it.
622 
623    Calendars with intercallary days may represent these as extra days of the
624    preceding month, or as short months separate from the usual ones. In the
625    former case, daysInMonth(month, year) should be the number of ordinary days
626    in the month, although \c{isDateValid(year, month, day)} might return \c true
627    for some larger values of \c day.
628 
629    \sa daysInYear(), monthsInYear(), minimumDaysInMonth(), maximumDaysInMonth()
630 */
631 
632 // properties of the calendar
633 
634 /*!
635     \fn bool QCalendarBackend::isLeapYear(int year) const
636 
637     Returns \c true if the specified \a year is a leap year for this calendar.
638 
639     \sa daysInYear(), isDateValid()
640 */
641 
642 /*!
643     \fn bool QCalendarBackend::isLunar() const
644 
645     Returns \c true if this calendar is a lunar calendar. Otherwise returns \c
646     false.
647 
648     A lunar calendar is a calendar based upon the monthly cycles of the Moon's
649     phases (synodic months). This contrasts with solar calendars, whose annual
650     cycles are based only upon the solar year.
651 
652     \sa isLuniSolar(), isSolar(), isProleptic()
653 */
654 
655 /*!
656     \fn bool QCalendarBackend::isLuniSolar() const
657 
658     Returns \c true if this calendar is a lunisolar calendar. Otherwise returns
659     \c false.
660 
661     A lunisolar calendar is a calendar whose date indicates both the moon phase
662     and the time of the solar year.
663 
664     \sa isLunar(), isSolar(), isProleptic()
665 */
666 
667 /*!
668     \fn bool QCalendarBackend::isSolar() const
669 
670     Returns \c true if this calendar is a solar calendar. Otherwise returns
671     \c false.
672 
673     A solar calendar is a calendar whose dates indicate the season or almost
674     equivalently the apparent position of the sun relative to the fixed stars.
675     The Gregorian calendar, widely accepted as standard in the world,
676     is an example of solar calendar.
677 
678     \sa isLuniSolar(), isLunar(), isProleptic()
679 */
680 
681 /*!
682     Returns the total number of days in the year number \a year.
683     Returns zero if there is no such year in this calendar.
684 
685     This base implementation returns 366 for leap years and 365 for ordinary
686     years.
687 
688     \sa monthsInYear(), daysInMonth(), isLeapYear()
689 */
690 int QCalendarBackend::daysInYear(int year) const
691 {
692     return monthsInYear(year) ? isLeapYear(year) ? 366 : 365 : 0;
693 }
694 
695 /*!
696     Returns the total number of months in the year number \a year.
697     Returns zero if there is no such year in this calendar.
698 
699     This base implementation returns 12 for any valid year.
700 
701     \sa daysInYear(), maximumMonthsInYear(), isDateValid()
702 */
703 int QCalendarBackend::monthsInYear(int year) const
704 {
705     return year > 0 || (year < 0 ? isProleptic() : hasYearZero()) ? 12 : 0;
706 }
707 
708 /*!
709     Returns \c true if the date specified by \a year, \a month, and \a day is
710     valid for this calendar; otherwise returns \c false. For example,
711     the date 2018-04-19 is valid for the Gregorian calendar, but 2018-16-19 and
712     2018-04-38 are invalid.
713 
714     Calendars with intercallary days may represent these as extra days of the
715     preceding month or as short months separate from the usual ones. In the
716     former case, a \a day value greater than \c{daysInMonth(\a{month},
717     \a{year})} may be valid.
718 
719     \sa daysInMonth(), monthsInYear()
720 */
721 bool QCalendarBackend::isDateValid(int year, int month, int day) const
722 {
723     return day > 0 && day <= daysInMonth(month, year);
724 }
725 
726 /*!
727     Returns \c true if this calendar is a proleptic calendar. Otherwise returns
728     \c false.
729 
730     A proleptic calendar results from allowing negative year numbers to indicate
731     years before the nominal start of the calendar system.
732 
733     \sa isLuniSolar(), isSolar(), isLunar(), hasYearZero()
734 */
735 
736 bool QCalendarBackend::isProleptic() const
737 {
738     return true;
739 }
740 
741 /*!
742     Returns \c true if year number \c 0 is considered a valid year in this
743     calendar. Otherwise returns \c false.
744 
745     \sa isDateValid(), isProleptic()
746 */
747 
748 bool QCalendarBackend::hasYearZero() const
749 {
750     return false;
751 }
752 
753 /*!
754     Returns the maximum number of days in a month for any year.
755 
756     This base implementation returns 31, as this is a common case.
757 
758     For calendars with intercallary days, although daysInMonth() doesn't include
759     the intercallary days in its count for an individual month,
760     maximumDaysInMonth() should include intercallary days, so that it is the
761     maximum value of \c day for which \c{isDateValid(year, month, day)} can be
762     true.
763 
764     \sa maximumMonthsInYear(), daysInMonth()
765 */
766 int QCalendarBackend::maximumDaysInMonth() const
767 {
768     return 31;
769 }
770 
771 /*!
772     Returns the minimum number of days in any valid month of any valid year.
773 
774     This base implementation returns 29, as this is a common case.
775 
776     \sa maximumMonthsInYear(), daysInMonth()
777 */
778 int QCalendarBackend::minimumDaysInMonth() const
779 {
780     return 29;
781 }
782 
783 /*!
784     Returns the maximum number of months possible in any year.
785 
786     This base implementation returns 12, as this is a common case.
787 
788     \sa maximumDaysInMonth(), monthsInYear()
789 */
790 int QCalendarBackend::maximumMonthsInYear() const
791 {
792     return 12;
793 }
794 
795 // Julian day number calculations
796 
797 /*!
798     \fn bool QCalendarBackend::dateToJulianDay(int year, int month, int day, qint64 *jd) const
799 
800     Computes the Julian day number corresponding to the specified \a year, \a
801     month, and \a day. Returns true and sets \a jd if there is such a date in
802     this calendar; otherwise, returns false.
803 
804     \sa QCalendar::partsFromDate(), julianDayToDate()
805 */
806 
807 /*!
808     \fn QCalendar::YearMonthDay QCalendarBackend::julianDayToDate(qint64 jd) const
809 
810     Computes the year, month, and day in this calendar for the given Julian day
811     number \a jd. If the given day falls outside this calendar's scope
812     (e.g. before the start-date of a non-proleptic calendar), the returned
813     structure's isValid() is false; otherwise, its year, month, and day fields
814     provide this calendar's description of the date.
815 
816     \sa QCalendar::dateFromParts(), dateToJulianDay()
817 */
818 
819 /*!
820    Returns the day of the week for the given Julian Day Number \a jd.
821 
822    This is 1 for Monday through 7 for Sunday.
823 
824    Calendars with intercallary days may return larger values for these
825    intercallary days. They should avoid using 0 for any special purpose (it is
826    already used in QDate::dayOfWeek() to mean an invalid date). The calendar
827    should treat the numbers used as an \c enum, whose values need not be
828    contiguous, nor need they follow closely from the 1 through 7 of the usual
829    returns. It suffices that weekDayName() can recognize each such number as
830    identifying a distinct name, that it returns to identify the particular
831    intercallary day.
832 
833    This base implementation uses the day-numbering that various calendars have
834    borrowed off the Hebrew calendar.
835 
836    \sa weekDayName(), standaloneWeekDayName(), QDate::dayOfWeek()
837  */
838 int QCalendarBackend::dayOfWeek(qint64 jd) const
839 {
840     return QRoundingDown::qMod(jd, 7) + 1;
841 }
842 
843 // Month and week-day name look-ups (implemented in qlocale.cpp):
844 /*!
845     \fn QString QCalendarBackend::monthName(const QLocale &locale, int month, int year,
846                                             QLocale::FormatType format) const
847 
848     Returns the name of the specified \a month in the given \a year for the
849     chosen \a locale, using the given \a format to determine how complete the
850     name is.
851 
852     If \a year is Unspecified, return the name for the month that usually has
853     this number within a typical year. Calendars with a leap month that isn't
854     always the last may need to take account of the year to map the month number
855     to the particular year's month with that number.
856 
857     \note Backends for which CLDR provides data can configure the default
858     implementation of the two month name look-up methods by arranging for
859     localeMonthIndexData() and localeMonthData() to provide access to the CLDR
860     data (see cldr2qlocalexml.py, qlocalexml2cpp.py and existing backends).
861     Conversely, backends that override both month name look-up methods need not
862     return anything meaningful from localeMonthIndexData() or localeMonthData().
863 
864     \sa standaloneMonthName(), QLocale::monthName()
865 */
866 
867 /*!
868     \fn QString QCalendarBackend::standaloneMonthName(const QLocale &locale, int month, int year
869                                                       QLocale::FormatType format) const
870 
871     Returns the standalone name of the specified \a month in the chosen \a
872     locale, using the specified \a format to determine how complete the name is.
873 
874     If \a year is Unspecified, return the standalone name for the month that
875     usually has this number within a typical year. Calendars with a leap month
876     that isn't always the last may need to take account of the year to map the
877     month number to the particular year's month with that number.
878 
879     \sa monthName(), QLocale::standaloneMonthName()
880 */
881 
882 /*!
883     \fn QString QCalendarBackend::weekDayName(const QLocale &locale, int day,
884                                               QLocale::FormatType format) const
885 
886     Returns the name of the specified \a day of the week in the chosen \a
887     locale, using the specified \a format to determine how complete the name is.
888 
889     The base implementation handles \a day values from 1 to 7 using the day
890     names CLDR provides, which are suitable for calendards that use the same
891     (Hebrew-derived) week as the Gregorian calendar.
892 
893     Calendars whose dayOfWeek() returns a value outside the range from 1 to 7
894     need to reimplement this method to handle such extra week-day values. They
895     can assume that \a day is a value returned by the same calendar's
896     dayOfWeek().
897 
898     \sa dayOfWeek(), standaloneWeekDayName(), QLocale::dayName()
899 */
900 
901 /*!
902     \fn QString QCalendarBackend::standaloneWeekDayName(const QLocale &locale, int day,
903                                                         QLocale::FormatType format) const
904 
905     Returns the standalone name of the specified \a day of the week in the
906     chosen \a locale, using the specified \a format to determine how complete
907     the name is.
908 
909     The base implementation handles \a day values from 1 to 7 using the
910     standalone day names CLDR provides, which are suitable for calendards that
911     use the same (Hebrew-derived) week as the Gregorian calendar.
912 
913     Calendars whose dayOfWeek() returns a value outside the range from 1 to 7
914     need to reimplement this method to handle such extra week-day values. They
915     can assume that \a day is a value returned by the same calendar's
916     dayOfWeek().
917 
918     \sa dayOfWeek(), weekDayName(), QLocale::standaloneDayName()
919 */
920 
921 /*!
922     \fn QString QCalendarBackend::dateTimeToString(QStringView format, const QDateTime &datetime,
923                                                    QDate dateOnly, QTime timeOnly,
924                                                    const QLocale &locale) const
925 
926     Returns a string representing a given date, time or date-time.
927 
928     If \a datetime is specified and valid, it is used and both date and time
929     format tokens are converted to appropriate representations of the parts of
930     the datetime. Otherwise, if \a dateOnly is valid, only date format tokens
931     are converted; else, if \a timeOnly is valid, only time format tokens are
932     converted. If none are valid, an empty string is returned.
933 
934     The specified \a locale influences how some format tokens are converted; for
935     example, when substituting day and month names and their short-forms. For
936     the supported formatting tokens, see QDate::toString() and
937     QTime::toString(). As described above, the provided date, time and date-time
938     determine which of these tokens are recognized: where these appear in \a
939     format they are replaced by data. Any text in \a format not recognized as a
940     format token is copied verbatim into the result string.
941 
942     \sa QDate::toString(), QTime::toString(), QDateTime::toString()
943 */
944 // End of methods implemented in qlocale.cpp
945 
946 /*!
947     Returns a list of names of the available calendar systems. Any
948     QCalendarBackend sub-class must be registered before being exposed to Date
949     and Time APIs.
950 
951     \sa fromName()
952 */
953 QStringList QCalendarBackend::availableCalendars()
954 {
955     if (calendarRegistry.isDestroyed())
956         return {};
957 
958     return calendarRegistry->availableCalendars();
959 }
960 
961 /*!
962     \internal
963     Returns a pointer to a named calendar backend.
964 
965     If the given \a name is present in availableCalendars(), the backend
966     matching it is returned; otherwise, \c nullptr is returned. Matching of
967     names ignores case. Note that this does not provoke construction of a
968     calendar backend, other than those available via \l fromEnum(): it will only
969     return ones that have been instantiated (and not yet destroyed) by some
970     other means.
971 
972     \sa availableCalendars(), fromEnum(), fromId()
973 */
974 QCalendarBackend::Ptr QCalendarBackend::fromName(QAnyStringView name)
975 {
976     if (calendarRegistry.isDestroyed())
977         return nullptr;
978 
979     return calendarRegistry->fromName(name);
980 }
981 
982 /*!
983     \internal
984     Returns a pointer to a calendar backend, specified by ID.
985 
986     If a calendar with ID \a id is known to the calendar registry, the backend
987     with this ID is returned; otherwise, \c nullptr is returned. Note that this
988     does not provoke construction of a calendar backend, other than those
989     available via \l fromEnum(): it will only return ones that have been
990     instantiated (and not yet destroyed) by some other means.
991 
992     \sa fromEnum(), calendarId()
993 */
994 QCalendarBackend::Ptr QCalendarBackend::fromId(QCalendar::SystemId id)
995 {
996     if (calendarRegistry.isDestroyed() || !id.isValid())
997         return nullptr;
998 
999     return calendarRegistry->fromIndex(id.index());
1000 }
1001 
1002 /*!
1003     \internal
1004     Returns a pointer to a calendar backend, specified by \c enum.
1005 
1006     This will instantiate the indicated calendar (which will enable fromName()
1007     to return it subsequently), but only for the Qt-supported calendars for
1008     which (where relevant) the appropriate feature has been enabled.
1009 
1010     \sa fromName(), fromId()
1011 */
1012 QCalendarBackend::Ptr QCalendarBackend::fromEnum(QCalendar::System system)
1013 {
1014     if (calendarRegistry.isDestroyed() || system == QCalendar::System::User)
1015         return nullptr;
1016 
1017     return calendarRegistry->fromEnum(system);
1018 }
1019 
1020 /*!
1021     \internal
1022     Returns backend for Gregorian calendar.
1023 
1024     The backend is returned without locking the registry if possible.
1025 */
1026 QCalendarBackend::Ptr QCalendarBackend::gregorian()
1027 {
1028     if (calendarRegistry.isDestroyed())
1029         return nullptr;
1030 
1031     return calendarRegistry->gregorian();
1032 }
1033 
1034 /*!
1035     \since 5.14
1036 
1037     \class QCalendar
1038     \inmodule QtCore
1039     \reentrant
1040     \brief The QCalendar class describes calendar systems.
1041 
1042     A QCalendar object maps a year, month, and day-number to a specific day
1043     (ultimately identified by its Julian day number), using the rules of a
1044     particular system.
1045 
1046     The default QCalendar() is a proleptic Gregorian calendar, which has no year
1047     zero. Other calendars may be supported by enabling suitable features or
1048     loading plugins. Calendars supported as features can be constructed by
1049     passing the QCalendar::System enumeration to the constructor. All supported
1050     calendars may be constructed by name, once they have been constructed. (Thus
1051     plugins instantiate their calendar backend to register it.) Built-in
1052     backends, accessible via QCalendar::System, are also always available by
1053     name. Calendars using custom backends may also be constructed using a unique
1054     ID allocated to the backend on construction.
1055 
1056     A QCalendar value is immutable.
1057 
1058     \sa QDate, QDateTime
1059 */
1060 
1061 /*!
1062     \enum QCalendar::System
1063 
1064     This enumerated type is used to specify a choice of calendar system.
1065 
1066     \value Gregorian The default calendar, used internationally.
1067     \value Julian An ancient Roman calendar.
1068     \value Milankovic A revised Julian calendar used by some Orthodox churches.
1069     \value Jalali The Solar Hijri calendar (also called Persian).
1070     \value IslamicCivil The (tabular) Islamic Civil calendar.
1071     \omitvalue Last
1072     \omitvalue User
1073 
1074     \sa QCalendar, QCalendar::SystemId
1075 */
1076 
1077 /*!
1078     \class QCalendar::SystemId
1079     \since 6.2
1080 
1081     This is an opaque type used to identify custom calendar implementations. The
1082     only supported source for values of this type is the backend's \c
1083     calendarId() method. A value of this type whose isValid() is false does not
1084     identify a successfully-registered backend. The only valid consumer of
1085     values of this type is a QCalendar constructor, which will only produce a
1086     valid QCalendar instance if the ID passed to it is valid.
1087 
1088     \sa QCalendar, QCalendar::System
1089 */
1090 
1091 /*!
1092     \fn QCalendar::SystemId::isValid()
1093 
1094     Returns true if this is a valid calendar implementation identifier, else
1095     false.
1096 
1097     \sa QCalendar
1098 */
1099 
1100 /*!
1101     \internal
1102     \fn QCalendar::SystemId::SystemId()
1103 
1104     Constructs an invalid calendar system identifier.
1105 */
1106 
1107 /*!
1108     \internal
1109     \fn QCalendar::SystemId::index()
1110 
1111     Returns the internal representation of the identifier.
1112 */
1113 
1114 /*!
1115     \fn QCalendar::QCalendar()
1116     \fn QCalendar::QCalendar(QCalendar::System system)
1117     \fn QCalendar::QCalendar(QLatin1String name)
1118     \fn QCalendar::QCalendar(QStringView name)
1119 
1120     Constructs a calendar object.
1121 
1122     The choice of calendar to use may be indicated by \a system, using the
1123     enumeration QCalendar::System, or by \a name, using a string (either Unicode
1124     or Latin 1). Construction by name may depend on an instance of the given
1125     calendar being constructed by other means first. With no argument, the
1126     default constructor returns the Gregorian calendar.
1127 
1128     \sa QCalendar, System, isValid()
1129 */
1130 
1131 QCalendar::QCalendar()
1132     : d(QCalendarBackend::gregorian())
1133 {
1134     Q_ASSERT(!d || d->calendarId().isValid());
1135 }
1136 
1137 QCalendar::QCalendar(QCalendar::System system)
1138     : d(QCalendarBackend::fromEnum(system))
1139 {
1140     // If system is valid, we should get a valid d for that system.
1141     Q_ASSERT(!d || (uint(system) > uint(QCalendar::System::Last))
1142              || (d->calendarId().index() == size_t(system)));
1143 }
1144 
1145 /*!
1146   \overload
1147   \since 6.2
1148 
1149   Constructs a calendar object.
1150 
1151   When using a custom calendar implementation, its backend is allocated a unique
1152   ID when created; passing that as \a id to this constructor will get a
1153   QCalendar using that backend. This can be useful when the backend is not
1154   registered by name.
1155 */
1156 QCalendar::QCalendar(QCalendar::SystemId id)
1157     : d(QCalendarBackend::fromId(id))
1158 {
1159     Q_ASSERT(!d || d->calendarId().index() == id.index());
1160 }
1161 
1162 QCalendar::QCalendar(QLatin1String name)
1163     : d(QCalendarBackend::fromName(name))
1164 {
1165     Q_ASSERT(!d || d->calendarId().isValid());
1166 }
1167 
1168 QCalendar::QCalendar(QStringView name)
1169     : d(QCalendarBackend::fromName(name))
1170 {
1171     Q_ASSERT(!d || d->calendarId().isValid());
1172 }
1173 
1174 /*!
1175     \fn bool QCalendar::isValid() const
1176 
1177     Returns true if this is a valid calendar object.
1178 
1179     Constructing a calendar with an unrecognised calendar name may result in an
1180     invalid object. Use this method to check after creating a calendar by name.
1181 */
1182 
1183 // Date queries:
1184 
1185 /*!
1186     Returns the number of days in the given \a month of the given \a year.
1187 
1188     Months are numbered consecutively, starting with 1 for the first month of
1189     each year. If \a year is \c Unspecified (its default, if not passed), the
1190     month's length in a normal year is returned.
1191 
1192     \sa maximumDaysInMonth(), minimumDaysInMonth()
1193 */
1194 int QCalendar::daysInMonth(int month, int year) const
1195 {
1196     return d ? d->daysInMonth(month, year) : 0;
1197 }
1198 
1199 /*!
1200     Returns the number of days in the given \a year.
1201 
1202     Handling of \c Unspecified as \a year is undefined.
1203 */
1204 int QCalendar::daysInYear(int year) const
1205 {
1206     return d ? d->daysInYear(year) : 0;
1207 }
1208 
1209 /*!
1210     Returns the number of months in the given \a year.
1211 
1212     If \a year is \c Unspecified, returns the maximum number of months in a
1213     year.
1214 
1215     \sa maximumMonthsInYear()
1216 */
1217 int QCalendar::monthsInYear(int year) const
1218 {
1219     return d ? year == Unspecified ? d->maximumMonthsInYear() : d->monthsInYear(year) : 0;
1220 }
1221 
1222 /*!
1223     Returns \c true precisely if the given \a year, \a month, and \a day specify
1224     a valid date in this calendar.
1225 
1226     Usually this means 1 <= month <= monthsInYear(year) and 1 <= day <=
1227     daysInMonth(month, year). However, calendars with intercallary days or
1228     months may complicate that.
1229 */
1230 bool QCalendar::isDateValid(int year, int month, int day) const
1231 {
1232     return d && d->isDateValid(year, month, day);
1233 }
1234 
1235 // properties of the calendar
1236 
1237 /*!
1238     Returns \c true if this calendar object is the Gregorian calendar object
1239     used as default calendar by other Qt APIs, e.g. in QDate.
1240 */
1241 bool QCalendar::isGregorian() const
1242 {
1243     return d && d->isGregorian();
1244 }
1245 
1246 /*!
1247     Returns \c true if the given \a year is a leap year.
1248 
1249     Since the year is not a whole number of days long, some years are longer
1250     than others. The difference may be a whole month or just a single day; the
1251     details vary between calendars.
1252 
1253     \sa isDateValid()
1254 */
1255 bool QCalendar::isLeapYear(int year) const
1256 {
1257     return d && d->isLeapYear(year);
1258 }
1259 
1260 /*!
1261     Returns \c true if this calendar is a lunar calendar.
1262 
1263     A lunar calendar is one based primarily on the phases of the moon.
1264 */
1265 bool QCalendar::isLunar() const
1266 {
1267     return d && d->isLunar();
1268 }
1269 
1270 /*!
1271     Returns \c true if this calendar is luni-solar.
1272 
1273     A luni-solar calendar expresses the phases of the moon but adapts itself to
1274     also keep track of the Sun's varying position in the sky, relative to the
1275     fixed stars.
1276 */
1277 bool QCalendar::isLuniSolar() const
1278 {
1279     return d && d->isLuniSolar();
1280 }
1281 
1282 /*!
1283     Returns \c true if this calendar is solar.
1284 
1285     A solar calendar is based primarily on the Sun's varying position in the
1286     sky, relative to the fixed stars.
1287 */
1288 bool QCalendar::isSolar() const
1289 {
1290     return d && d->isSolar();
1291 }
1292 
1293 /*!
1294     Returns \c true if this calendar is proleptic.
1295 
1296     A proleptic calendar is able to describe years arbitrarily long before its
1297     first. These are represented by negative year numbers and possibly by a year
1298     zero.
1299 
1300     \sa hasYearZero()
1301 */
1302 bool QCalendar::isProleptic() const
1303 {
1304     return d && d->isProleptic();
1305 }
1306 
1307 /*!
1308     Returns \c true if this calendar has a year zero.
1309 
1310     A calendar may represent years from its first year onwards but provide no
1311     way to describe years before its first; such a calendar has no year zero and
1312     is not proleptic.
1313 
1314     A calendar which represents years before its first may number these years
1315     simply by following the usual integer counting, so that the year before the
1316     first is year zero, with negative-numbered years preceding this; such a
1317     calendar is proleptic and has a year zero. A calendar might also have a year
1318     zero (for example, the year of some great event, with subsequent years being
1319     the first year after that event, the second year after, and so on) without
1320     describing years before its year zero. Such a calendar would have a year
1321     zero without being proleptic.
1322 
1323     Some calendars, however, represent years before their first by an alternate
1324     numbering; for example, the proleptic Gregorian calendar's first year is 1
1325     CE and the year before it is 1 BCE, preceded by 2 BCE and so on. In this
1326     case, we use negative year numbers for this alternate numbering, with year
1327     -1 as the year before year 1, year -2 as the year before year -1 and so
1328     on. Such a calendar is proleptic but has no year zero.
1329 
1330     \sa isProleptic()
1331 */
1332 bool QCalendar::hasYearZero() const
1333 {
1334     return d && d->hasYearZero();
1335 }
1336 
1337 /*!
1338     Returns the number of days in the longest month in the calendar, in any year.
1339 
1340     \sa daysInMonth(), minimumDaysInMonth()
1341 */
1342 int QCalendar::maximumDaysInMonth() const
1343 {
1344     return d ? d->maximumDaysInMonth() : 0;
1345 }
1346 
1347 /*!
1348     Returns the number of days in the shortest month in the calendar, in any year.
1349 
1350     \sa daysInMonth(), maximumDaysInMonth()
1351 */
1352 int QCalendar::minimumDaysInMonth() const
1353 {
1354     return d ? d->minimumDaysInMonth() : 0;
1355 }
1356 
1357 /*!
1358     Returns the largest number of months that any year may contain.
1359 
1360     \sa monthName(), standaloneMonthName(), monthsInYear()
1361 */
1362 int QCalendar::maximumMonthsInYear() const
1363 {
1364     return d ? d->maximumMonthsInYear() : 0;
1365 }
1366 
1367 // Julian Day conversions:
1368 
1369 /*!
1370     \fn QDate QCalendar::dateFromParts(int year, int month, int day) const
1371     \fn QDate QCalendar::dateFromParts(const QCalendar::YearMonthDay &parts) const
1372 
1373     Converts a year, month, and day to a QDate.
1374 
1375     The \a year, \a month, and \a day may be passed as separate numbers or
1376     packaged together as the members of \a parts. Returns a QDate with the given
1377     year, month, and day of the month in this calendar, if there is one.
1378     Otherwise, including the case where any of the values is
1379     QCalendar::Unspecified, returns a QDate whose isNull() is true.
1380 
1381     \sa isDateValid(), partsFromDate()
1382 */
1383 QDate QCalendar::dateFromParts(int year, int month, int day) const
1384 {
1385     qint64 jd;
1386     return d && d->dateToJulianDay(year, month, day, &jd)
1387         ? QDate::fromJulianDay(jd) : QDate();
1388 }
1389 
1390 QDate QCalendar::dateFromParts(const QCalendar::YearMonthDay &parts) const
1391 {
1392     return parts.isValid() ? dateFromParts(parts.year, parts.month, parts.day) : QDate();
1393 }
1394 
1395 /*!
1396     Converts a QDate to a year, month, and day of the month.
1397 
1398     The returned structure's isValid() shall be false if the calendar is unable
1399     to represent the given \a date. Otherwise its year, month, and day
1400     members record the so-named parts of its representation.
1401 
1402     \sa dateFromParts(), isProleptic(), hasYearZero()
1403 */
1404 QCalendar::YearMonthDay QCalendar::partsFromDate(QDate date) const
1405 {
1406     return d && date.isValid() ? d->julianDayToDate(date.toJulianDay()) : YearMonthDay();
1407 }
1408 
1409 /*!
1410     Returns the day of the week number for the given \a date.
1411 
1412     Returns zero if the calendar is unable to represent the indicated date.
1413     Returns 1 for Monday through 7 for Sunday. Calendars with intercallary days
1414     may use other numbers to represent these.
1415 
1416     \sa partsFromDate(), Qt::DayOfWeek
1417 */
1418 int QCalendar::dayOfWeek(QDate date) const
1419 {
1420     return d && date.isValid() ? d->dayOfWeek(date.toJulianDay()) : 0;
1421 }
1422 
1423 // Locale data access
1424 
1425 /*!
1426     Returns a suitably localised name for a month.
1427 
1428     The month is indicated by a number, with \a month = 1 meaning the first
1429     month of the year and subsequent months numbered accordingly. Returns an
1430     empty string if the \a month number is unrecognized.
1431 
1432     The \a year may be Unspecified, in which case the mapping from numbers to
1433     names for a typical year's months should be used. Some calendars have leap
1434     months that aren't always at the end of the year; their mapping of month
1435     numbers to names may then depend on the placement of a leap month. Thus the
1436     year should normally be specified, if known.
1437 
1438     The name is returned in the form that would normally be used in a full date,
1439     in the specified \a locale; the \a format determines how fully it shall be
1440     expressed (i.e. to what extent it is abbreviated).
1441 
1442     \sa standaloneMonthName(), maximumMonthsInYear(), dateTimeToString()
1443 */
1444 QString QCalendar::monthName(const QLocale &locale, int month, int year,
1445                              QLocale::FormatType format) const
1446 {
1447     const int maxMonth = year == Unspecified ? maximumMonthsInYear() : monthsInYear(year);
1448     if (!d || month < 1 || month > maxMonth)
1449         return QString();
1450 
1451     return d->monthName(locale, month, year, format);
1452 }
1453 
1454 /*!
1455     Returns a suitably localised standalone name for a month.
1456 
1457     The month is indicated by a number, with \a month = 1 meaning the first
1458     month of the year and subsequent months numbered accordingly. Returns an
1459     empty string if the \a month number is unrecognized.
1460 
1461     The \a year may be Unspecified, in which case the mapping from numbers to
1462     names for a typical year's months should be used. Some calendars have leap
1463     months that aren't always at the end of the year; their mapping of month
1464     numbers to names may then depend on the placement of a leap month. Thus the
1465     year should normally be specified, if known.
1466 
1467     The name is returned in the form that would be used in isolation in the
1468     specified \a locale; the \a format determines how fully it shall be
1469     expressed (i.e. to what extent it is abbreviated).
1470 
1471     \sa monthName(), maximumMonthsInYear(), dateTimeToString()
1472 */
1473 QString QCalendar::standaloneMonthName(const QLocale &locale, int month, int year,
1474                                        QLocale::FormatType format) const
1475 {
1476     const int maxMonth = year == Unspecified ? maximumMonthsInYear() : monthsInYear(year);
1477     if (!d || month < 1 || month > maxMonth)
1478         return QString();
1479 
1480     return d->standaloneMonthName(locale, month, year, format);
1481 }
1482 
1483 /*!
1484     Returns a suitably localised name for a day of the week.
1485 
1486     The days of the week are numbered from 1 for Monday through 7 for
1487     Sunday. Some calendars may support higher numbers for other days
1488     (e.g. intercallary days, that are not part of any week). Returns an empty
1489     string if the \a day number is unrecognized.
1490 
1491     The name is returned in the form that would normally be used in a full date,
1492     in the specified \a locale; the \a format determines how fully it shall be
1493     expressed (i.e. to what extent it is abbreviated).
1494 
1495     \sa standaloneWeekDayName(), dayOfWeek()
1496 */
1497 QString QCalendar::weekDayName(const QLocale &locale, int day,
1498                                QLocale::FormatType format) const
1499 {
1500     return d ? d->weekDayName(locale, day, format) : QString();
1501 }
1502 
1503 /*!
1504     Returns a suitably localised standalone name for a day of the week.
1505 
1506     The days of the week are numbered from 1 for Monday through 7 for
1507     Sunday. Some calendars may support higher numbers for other days
1508     (e.g. intercallary days, that are not part of any week). Returns an empty
1509     string if the \a day number is unrecognized.
1510 
1511     The name is returned in the form that would be used in isolation (for
1512     example as a column heading in a calendar's tabular display of a month with
1513     successive weeks as rows) in the specified \a locale; the \a format
1514     determines how fully it shall be expressed (i.e. to what extent it is
1515     abbreviated).
1516 
1517     \sa weekDayName(), dayOfWeek()
1518 */
1519 QString QCalendar::standaloneWeekDayName(const QLocale &locale, int day,
1520                                          QLocale::FormatType format) const
1521 {
1522     return d ? d->standaloneWeekDayName(locale, day, format) : QString();
1523 }
1524 
1525 /*!
1526     Returns a string representing a given date, time or date-time.
1527 
1528     If \a datetime is valid, it is represented and format specifiers for both
1529     date and time fields are recognized; otherwise, if \a dateOnly is valid, it
1530     is represented and only format specifiers for date fields are recognized;
1531     finally, if \a timeOnly is valid, it is represented and only format
1532     specifiers for time fields are recognized. If none of these is valid, an
1533     empty string is returned.
1534 
1535     See QDate::toString and QTime::toString() for the supported field
1536     specifiers.  Characters in \a format that are recognized as field specifiers
1537     are replaced by text representing appropriate data from the date and/or time
1538     being represented. The texts to represent them may depend on the \a locale
1539     specified. Other charagers in \a format are copied verbatim into the
1540     returned string.
1541 
1542     \sa monthName(), weekDayName(), QDate::toString(), QTime::toString()
1543 */
1544 QString QCalendar::dateTimeToString(QStringView format, const QDateTime &datetime,
1545                                     QDate dateOnly, QTime timeOnly,
1546                                     const QLocale &locale) const
1547 {
1548     return d ? d->dateTimeToString(format, datetime, dateOnly, timeOnly, locale) : QString();
1549 }
1550 
1551 /*!
1552     Returns a list of names of the available calendar systems.
1553 
1554     These may be supplied by plugins or other code linked into an application,
1555     in addition to the ones provided by Qt, some of which are controlled by
1556     features.
1557 */
1558 QStringList QCalendar::availableCalendars()
1559 {
1560     return QCalendarBackend::availableCalendars();
1561 }
1562 
1563 QT_END_NAMESPACE
