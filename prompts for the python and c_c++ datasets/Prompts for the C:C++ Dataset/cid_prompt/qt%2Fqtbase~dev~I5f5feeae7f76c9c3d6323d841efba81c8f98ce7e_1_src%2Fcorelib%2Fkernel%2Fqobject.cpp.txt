Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2019 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Copyright (C) 2013 Olivier Goffart <ogoffart@woboq.com>
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qobject.h"
43 #include "qobject_p.h"
44 #include "qmetaobject_p.h"
45 
46 #include "qabstracteventdispatcher.h"
47 #include "qabstracteventdispatcher_p.h"
48 #include "qcoreapplication.h"
49 #include "qcoreapplication_p.h"
50 #include "qloggingcategory.h"
51 #include "qvariant.h"
52 #include "qmetaobject.h"
53 #if QT_CONFIG(regularexpression)
54 #  include <qregularexpression.h>
55 #endif
56 #include <qthread.h>
57 #include <private/qthread_p.h>
58 #include <qdebug.h>
59 #include <qpair.h>
60 #include <qvarlengtharray.h>
61 #include <qscopeguard.h>
62 #include <qset.h>
63 #if QT_CONFIG(thread)
64 #include <qsemaphore.h>
65 #endif
66 #include <qsharedpointer.h>
67 
68 #include <private/qorderedmutexlocker_p.h>
69 #include <private/qhooks_p.h>
70 #include <qtcore_tracepoints_p.h>
71 
72 #include <new>
73 
74 #include <ctype.h>
75 #include <limits.h>
76 
77 QT_BEGIN_NAMESPACE
78 
79 static int DIRECT_CONNECTION_ONLY = 0;
80 
81 Q_LOGGING_CATEGORY(lcConnections, "qt.core.qmetaobject.connectslotsbyname")
82 
83 Q_CORE_EXPORT QBasicAtomicPointer<QSignalSpyCallbackSet> qt_signal_spy_callback_set = Q_BASIC_ATOMIC_INITIALIZER(nullptr);
84 
85 void qt_register_signal_spy_callbacks(QSignalSpyCallbackSet *callback_set)
86 {
87     qt_signal_spy_callback_set.storeRelease(callback_set);
88 }
89 
90 QDynamicMetaObjectData::~QDynamicMetaObjectData()
91 {
92 }
93 
94 QAbstractDynamicMetaObject::~QAbstractDynamicMetaObject()
95 {
96 }
97 
98 static int *queuedConnectionTypes(const QList<QByteArray> &typeNames)
99 {
100     int *types = new int [typeNames.count() + 1];
101     Q_CHECK_PTR(types);
102     for (int i = 0; i < typeNames.count(); ++i) {
103         const QByteArray typeName = typeNames.at(i);
104         if (typeName.endsWith('*'))
105             types[i] = QMetaType::VoidStar;
106         else
107             types[i] = QMetaType::type(typeName);
108 
109         if (!types[i]) {
110             qWarning("QObject::connect: Cannot queue arguments of type '%s'\n"
111                      "(Make sure '%s' is registered using qRegisterMetaType().)",
112                      typeName.constData(), typeName.constData());
113             delete [] types;
114             return nullptr;
115         }
116     }
117     types[typeNames.count()] = 0;
118 
119     return types;
120 }
121 
122 static int *queuedConnectionTypes(const QArgumentType *argumentTypes, int argc)
123 {
124     QScopedArrayPointer<int> types(new int [argc + 1]);
125     for (int i = 0; i < argc; ++i) {
126         const QArgumentType &type = argumentTypes[i];
127         if (type.type())
128             types[i] = type.type();
129         else if (type.name().endsWith('*'))
130             types[i] = QMetaType::VoidStar;
131         else
132             types[i] = QMetaType::type(type.name());
133 
134         if (!types[i]) {
135             qWarning("QObject::connect: Cannot queue arguments of type '%s'\n"
136                      "(Make sure '%s' is registered using qRegisterMetaType().)",
137                      type.name().constData(), type.name().constData());
138             return nullptr;
139         }
140     }
141     types[argc] = 0;
142 
143     return types.take();
144 }
145 
146 static QBasicMutex _q_ObjectMutexPool[131];
147 
148 /**
149  * \internal
150  * mutex to be locked when accessing the connection lists or the senders list
151  */
152 static inline QBasicMutex *signalSlotLock(const QObject *o)
153 {
154     return &_q_ObjectMutexPool[uint(quintptr(o)) % sizeof(_q_ObjectMutexPool)/sizeof(QBasicMutex)];
155 }
156 
157 #if QT_VERSION < 0x60000
158 extern "C" Q_CORE_EXPORT void qt_addObject(QObject *)
159 {}
160 
161 extern "C" Q_CORE_EXPORT void qt_removeObject(QObject *)
162 {}
163 #endif
164 
165 void (*QAbstractDeclarativeData::destroyed)(QAbstractDeclarativeData *, QObject *) = nullptr;
166 void (*QAbstractDeclarativeData::parentChanged)(QAbstractDeclarativeData *, QObject *, QObject *) = nullptr;
167 void (*QAbstractDeclarativeData::signalEmitted)(QAbstractDeclarativeData *, QObject *, int, void **) = nullptr;
168 int  (*QAbstractDeclarativeData::receivers)(QAbstractDeclarativeData *, const QObject *, int) = nullptr;
169 bool (*QAbstractDeclarativeData::isSignalConnected)(QAbstractDeclarativeData *, const QObject *, int) = nullptr;
170 void (*QAbstractDeclarativeData::setWidgetParent)(QObject *, QObject *) = nullptr;
171 
172 /*!
173     \fn QObjectData::QObjectData()
174     \internal
175  */
176 
177 
178 QObjectData::~QObjectData() {}
179 
180 QMetaObject *QObjectData::dynamicMetaObject() const
181 {
182     return metaObject->toDynamicMetaObject(q_ptr);
183 }
184 
185 QObjectPrivate::QObjectPrivate(int version)
186     : threadData(nullptr), currentChildBeingDeleted(nullptr)
187 {
188     checkForIncompatibleLibraryVersion(version);
189 
190     // QObjectData initialization
191     q_ptr = nullptr;
192     parent = nullptr;                           // no parent yet. It is set by setParent()
193     isWidget = false;                           // assume not a widget object
194     blockSig = false;                           // not blocking signals
195     wasDeleted = false;                         // double-delete catcher
196     isDeletingChildren = false;                 // set by deleteChildren()
197     sendChildEvents = true;                     // if we should send ChildAdded and ChildRemoved events to parent
198     receiveChildEvents = true;
199     postedEvents = 0;
200     extraData = nullptr;
201     metaObject = nullptr;
202     isWindow = false;
203     deleteLaterCalled = false;
204 }
205 
206 QObjectPrivate::~QObjectPrivate()
207 {
208     auto thisThreadData = threadData.loadRelaxed();
209     if (extraData && !extraData->runningTimers.isEmpty()) {
210         if (Q_LIKELY(thisThreadData->thread.loadAcquire() == QThread::currentThread())) {
211             // unregister pending timers
212             if (thisThreadData->hasEventDispatcher())
213                 thisThreadData->eventDispatcher.loadRelaxed()->unregisterTimers(q_ptr);
214 
215             // release the timer ids back to the pool
216             for (int i = 0; i < extraData->runningTimers.size(); ++i)
217                 QAbstractEventDispatcherPrivate::releaseTimerId(extraData->runningTimers.at(i));
218         } else {
219             qWarning("QObject::~QObject: Timers cannot be stopped from another thread");
220         }
221     }
222 
223     if (postedEvents)
224         QCoreApplication::removePostedEvents(q_ptr, 0);
225 
226     thisThreadData->deref();
227 
228     if (metaObject) metaObject->objectDestroyed(q_ptr);
229 
230     delete extraData;
231 }
232 
233 /*!
234   \internal
235   For a given metaobject, compute the signal offset, and the method offset (including signals)
236 */
237 static void computeOffsets(const QMetaObject *metaobject, int *signalOffset, int *methodOffset)
238 {
239     *signalOffset = *methodOffset = 0;
240     const QMetaObject *m = metaobject->d.superdata;
241     while (m) {
242         const QMetaObjectPrivate *d = QMetaObjectPrivate::get(m);
243         *methodOffset += d->methodCount;
244         Q_ASSERT(d->revision >= 4);
245         *signalOffset += d->signalCount;
246         m = m->d.superdata;
247     }
248 }
249 
250 // Used by QAccessibleWidget
251 bool QObjectPrivate::isSender(const QObject *receiver, const char *signal) const
252 {
253     Q_Q(const QObject);
254     int signal_index = signalIndex(signal);
255     ConnectionData *cd = connections.loadRelaxed();
256     if (signal_index < 0 || !cd)
257         return false;
258     QBasicMutexLocker locker(signalSlotLock(q));
259     if (signal_index < cd->signalVectorCount()) {
260         const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
261 
262         while (c) {
263             if (c->receiver.loadRelaxed() == receiver)
264                 return true;
265             c = c->nextConnectionList.loadRelaxed();
266         }
267     }
268     return false;
269 }
270 
271 // Used by QAccessibleWidget
272 QObjectList QObjectPrivate::receiverList(const char *signal) const
273 {
274     QObjectList returnValue;
275     int signal_index = signalIndex(signal);
276     ConnectionData *cd = connections.loadRelaxed();
277     if (signal_index < 0 || !cd)
278         return returnValue;
279     if (signal_index < cd->signalVectorCount()) {
280         const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
281 
282         while (c) {
283             QObject *r = c->receiver.loadRelaxed();
284             if (r)
285                 returnValue << r;
286             c = c->nextConnectionList.loadRelaxed();
287         }
288     }
289     return returnValue;
290 }
291 
292 // Used by QAccessibleWidget
293 QObjectList QObjectPrivate::senderList() const
294 {
295     QObjectList returnValue;
296     ConnectionData *cd = connections.loadRelaxed();
297     if (cd) {
298         QBasicMutexLocker locker(signalSlotLock(q_func()));
299         for (Connection *c = cd->senders; c; c = c->next)
300             returnValue << c->sender;
301     }
302     return returnValue;
303 }
304 
305 /*!
306   \internal
307   Add the connection \a c to the list of connections of the sender's object
308   for the specified \a signal
309 
310   The signalSlotLock() of the sender and receiver must be locked while calling
311   this function
312 
313   Will also add the connection in the sender's list of the receiver.
314  */
315 void QObjectPrivate::addConnection(int signal, Connection *c)
316 {
317     Q_ASSERT(c->sender == q_ptr);
318     ensureConnectionData();
319     ConnectionData *cd = connections.loadRelaxed();
320     cd->resizeSignalVector(signal + 1);
321 
322     ConnectionList &connectionList = cd->connectionsForSignal(signal);
323     if (connectionList.last.loadRelaxed()) {
324         Q_ASSERT(connectionList.last.loadRelaxed()->receiver.loadRelaxed());
325         connectionList.last.loadRelaxed()->nextConnectionList.storeRelaxed(c);
326     } else {
327         connectionList.first.storeRelaxed(c);
328     }
329     c->id = ++cd->currentConnectionId;
330     c->prevConnectionList = connectionList.last.loadRelaxed();
331     connectionList.last.storeRelaxed(c);
332 
333     QObjectPrivate *rd = QObjectPrivate::get(c->receiver.loadRelaxed());
334     rd->ensureConnectionData();
335 
336     c->prev = &(rd->connections.loadRelaxed()->senders);
337     c->next = *c->prev;
338     *c->prev = c;
339     if (c->next)
340         c->next->prev = &c->next;
341 }
342 
343 void QObjectPrivate::ConnectionData::removeConnection(QObjectPrivate::Connection *c)
344 {
345     Q_ASSERT(c->receiver.loadRelaxed());
346     ConnectionList &connections = signalVector.loadRelaxed()->at(c->signal_index);
347     c->receiver.storeRelaxed(nullptr);
348     QThreadData *td = c->receiverThreadData.loadRelaxed();
349     if (td)
350         td->deref();
351     c->receiverThreadData.storeRelaxed(nullptr);
352 
353 #ifndef QT_NO_DEBUG
354     bool found = false;
355     for (Connection *cc = connections.first.loadRelaxed(); cc; cc = cc->nextConnectionList.loadRelaxed()) {
356         if (cc == c) {
357             found = true;
358             break;
359         }
360     }
361     Q_ASSERT(found);
362 #endif
363 
364     // remove from the senders linked list
365     *c->prev = c->next;
366     if (c->next)
367         c->next->prev = c->prev;
368     c->prev = nullptr;
369 
370     if (connections.first.loadRelaxed() == c)
371         connections.first.storeRelaxed(c->nextConnectionList.loadRelaxed());
372     if (connections.last.loadRelaxed() == c)
373         connections.last.storeRelaxed(c->prevConnectionList);
374     Q_ASSERT(signalVector.loadRelaxed()->at(c->signal_index).first.loadRelaxed() != c);
375     Q_ASSERT(signalVector.loadRelaxed()->at(c->signal_index).last.loadRelaxed() != c);
376 
377     // keep c->nextConnectionList intact, as it might still get accessed by activate
378     Connection *n = c->nextConnectionList.loadRelaxed();
379     if (n)
380         n->prevConnectionList = c->prevConnectionList;
381     if (c->prevConnectionList)
382         c->prevConnectionList->nextConnectionList.storeRelaxed(n);
383     c->prevConnectionList = nullptr;
384 
385     Q_ASSERT(c != orphaned.loadRelaxed());
386     // add c to orphanedConnections
387     c->nextInOrphanList = orphaned.loadRelaxed();
388     orphaned.storeRelaxed(c);
389 
390 #ifndef QT_NO_DEBUG
391     found = false;
392     for (Connection *cc = connections.first.loadRelaxed(); cc; cc = cc->nextConnectionList.loadRelaxed()) {
393         if (cc == c) {
394             found = true;
395             break;
396         }
397     }
398     Q_ASSERT(!found);
399 #endif
400 
401 }
402 
403 void QObjectPrivate::ConnectionData::cleanOrphanedConnectionsImpl(QObject *sender)
404 {
405     ConnectionOrSignalVector *c = nullptr;
406     {
407         QBasicMutexLocker l(signalSlotLock(sender));
408         if (ref.loadAcquire() > 1)
409             return;
410 
411         // Since ref == 1, no activate() is in process since we locked the mutex. That implies,
412         // that nothing can reference the orphaned connection objects anymore and they can
413         // be safely deleted
414         c = orphaned.loadRelaxed();
415         orphaned.storeRelaxed(nullptr);
416     }
417     deleteOrphaned(c);
418 }
419 
420 void QObjectPrivate::ConnectionData::deleteOrphaned(QObjectPrivate::ConnectionOrSignalVector *o)
421 {
422     while (o) {
423         QObjectPrivate::ConnectionOrSignalVector *next = nullptr;
424         if (SignalVector *v = ConnectionOrSignalVector::asSignalVector(o)) {
425             next = v->nextInOrphanList;
426             free(v);
427         } else {
428             QObjectPrivate::Connection *c = static_cast<Connection *>(o);
429             next = c->nextInOrphanList;
430             Q_ASSERT(!c->receiver.loadRelaxed());
431             Q_ASSERT(!c->prev);
432             c->freeSlotObject();
433             c->deref();
434         }
435         o = next;
436     }
437 }
438 
439 /*! \internal
440 
441   Returns \c true if the signal with index \a signal_index from object \a sender is connected.
442 
443   \a signal_index must be the index returned by QObjectPrivate::signalIndex;
444 */
445 bool QObjectPrivate::isSignalConnected(uint signalIndex, bool checkDeclarative) const
446 {
447     if (checkDeclarative && isDeclarativeSignalConnected(signalIndex))
448         return true;
449 
450     ConnectionData *cd = connections.loadRelaxed();
451     if (!cd)
452         return false;
453     SignalVector *signalVector = cd->signalVector.loadRelaxed();
454     if (!signalVector)
455         return false;
456 
457     if (signalVector->at(-1).first.loadRelaxed())
458         return true;
459 
460     if (signalIndex < uint(cd->signalVectorCount())) {
461         const QObjectPrivate::Connection *c = signalVector->at(signalIndex).first.loadRelaxed();
462         while (c) {
463             if (c->receiver.loadRelaxed())
464                 return true;
465             c = c->nextConnectionList.loadRelaxed();
466         }
467     }
468     return false;
469 }
470 
471 bool QObjectPrivate::maybeSignalConnected(uint signalIndex) const
472 {
473     ConnectionData *cd = connections.loadRelaxed();
474     if (!cd)
475         return false;
476     SignalVector *signalVector = cd->signalVector.loadRelaxed();
477     if (!signalVector)
478         return false;
479 
480     if (signalVector->at(-1).first.loadAcquire())
481         return true;
482 
483     if (signalIndex < uint(cd->signalVectorCount())) {
484         const QObjectPrivate::Connection *c = signalVector->at(signalIndex).first.loadAcquire();
485         return c != nullptr;
486     }
487     return false;
488 }
489 
490 /*!
491     \internal
492  */
493 QAbstractMetaCallEvent::~QAbstractMetaCallEvent()
494 {
495 #if QT_CONFIG(thread)
496     if (semaphore_)
497         semaphore_->release();
498 #endif
499 }
500 
501 /*!
502     \internal
503  */
504 inline void QMetaCallEvent::allocArgs()
505 {
506     if (!d.nargs_)
507         return;
508 
509     constexpr size_t each = sizeof(void*) + sizeof(int);
510     void *const memory = d.nargs_ * each > sizeof(prealloc_) ?
511         calloc(d.nargs_, each) : prealloc_;
512 
513     Q_CHECK_PTR(memory);
514     d.args_ = static_cast<void **>(memory);
515 }
516 
517 /*!
518     \internal
519 
520     Used for blocking queued connections, just passes \a args through without
521     allocating any memory.
522  */
523 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative,
524                                QObjectPrivate::StaticMetaCallFunction callFunction,
525                                const QObject *sender, int signalId,
526                                void **args, QSemaphore *semaphore)
527     : QAbstractMetaCallEvent(sender, signalId, semaphore),
528       d({nullptr, args, callFunction, 0, method_offset, method_relative}),
529       prealloc_()
530 {
531 }
532 
533 /*!
534     \internal
535 
536     Used for blocking queued connections, just passes \a args through without
537     allocating any memory.
538  */
539 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO,
540                                const QObject *sender, int signalId,
541                                void **args, QSemaphore *semaphore)
542     : QAbstractMetaCallEvent(sender, signalId, semaphore),
543       d({slotO, args, nullptr, 0, 0, ushort(-1)}),
544       prealloc_()
545 {
546     if (d.slotObj_)
547         d.slotObj_->ref();
548 }
549 
550 /*!
551     \internal
552 
553     Allocates memory for \a nargs; code creating an event needs to initialize
554     the void* and int arrays by accessing \a args() and \a types(), respectively.
555  */
556 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative,
557                                QObjectPrivate::StaticMetaCallFunction callFunction,
558                                const QObject *sender, int signalId,
559                                int nargs)
560     : QAbstractMetaCallEvent(sender, signalId),
561       d({nullptr, nullptr, callFunction, nargs, method_offset, method_relative}),
562       prealloc_()
563 {
564     allocArgs();
565 }
566 
567 /*!
568     \internal
569 
570     Allocates memory for \a nargs; code creating an event needs to initialize
571     the void* and int arrays by accessing \a args() and \a types(), respectively.
572  */
573 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO,
574                                const QObject *sender, int signalId,
575                                int nargs)
576     : QAbstractMetaCallEvent(sender, signalId),
577       d({slotO, nullptr, nullptr, nargs, 0, ushort(-1)}),
578       prealloc_()
579 {
580     if (d.slotObj_)
581         d.slotObj_->ref();
582     allocArgs();
583 }
584 
585 /*!
586     \internal
587  */
588 QMetaCallEvent::~QMetaCallEvent()
589 {
590     if (d.nargs_) {
591         int *typeIDs = types();
592         for (int i = 0; i < d.nargs_; ++i) {
593             if (typeIDs[i] && d.args_[i])
594                 QMetaType::destroy(typeIDs[i], d.args_[i]);
595         }
596         if (reinterpret_cast<void*>(d.args_) != reinterpret_cast<void*>(prealloc_))
597             free(d.args_);
598     }
599     if (d.slotObj_)
600         d.slotObj_->destroyIfLastRef();
601 }
602 
603 /*!
604     \internal
605  */
606 void QMetaCallEvent::placeMetaCall(QObject *object)
607 {
608     if (d.slotObj_) {
609         d.slotObj_->call(object, d.args_);
610     } else if (d.callFunction_ && d.method_offset_ <= object->metaObject()->methodOffset()) {
611         d.callFunction_(object, QMetaObject::InvokeMetaMethod, d.method_relative_, d.args_);
612     } else {
613         QMetaObject::metacall(object, QMetaObject::InvokeMetaMethod,
614                               d.method_offset_ + d.method_relative_, d.args_);
615     }
616 }
617 
618 /*!
619     \class QSignalBlocker
620     \brief Exception-safe wrapper around QObject::blockSignals().
621     \since 5.3
622     \ingroup objectmodel
623     \inmodule QtCore
624 
625     \reentrant
626 
627     QSignalBlocker can be used wherever you would otherwise use a
628     pair of calls to blockSignals(). It blocks signals in its
629     constructor and in the destructor it resets the state to what
630     it was before the constructor ran.
631 
632     \snippet code/src_corelib_kernel_qobject.cpp 53
633     is thus equivalent to
634     \snippet code/src_corelib_kernel_qobject.cpp 54
635 
636     except the code using QSignalBlocker is safe in the face of
637     exceptions.
638 
639     \sa QMutexLocker, QEventLoopLocker
640 */
641 
642 /*!
643     \fn QSignalBlocker::QSignalBlocker(QObject *object)
644 
645     Constructor. Calls \a{object}->blockSignals(true).
646 */
647 
648 /*!
649     \fn QSignalBlocker::QSignalBlocker(QObject &object)
650     \overload
651 
652     Calls \a{object}.blockSignals(true).
653 */
654 
655 /*!
656     \fn QSignalBlocker::QSignalBlocker(QSignalBlocker &&other)
657 
658     Move-constructs a signal blocker from \a other. \a other will have
659     a no-op destructor, while responsibility for restoring the
660     QObject::signalsBlocked() state is transferred to the new object.
661 */
662 
663 /*!
664     \fn QSignalBlocker &QSignalBlocker::operator=(QSignalBlocker &&other)
665 
666     Move-assigns this signal blocker from \a other. \a other will have
667     a no-op destructor, while responsibility for restoring the
668     QObject::signalsBlocked() state is transferred to this object.
669 
670     The object's signals this signal blocker was blocking prior to
671     being moved to, if any, are unblocked \e except in the case where
672     both instances block the same object's signals and \c *this is
673     unblocked while \a other is not, at the time of the move.
674 */
675 
676 /*!
677     \fn QSignalBlocker::~QSignalBlocker()
678 
679     Destructor. Restores the QObject::signalsBlocked() state to what it
680     was before the constructor ran, unless unblock() has been called
681     without a following reblock(), in which case it does nothing.
682 */
683 
684 /*!
685     \fn void QSignalBlocker::reblock()
686 
687     Re-blocks signals after a previous unblock().
688 
689     The numbers of reblock() and unblock() calls are not counted, so
690     every reblock() undoes any number of unblock() calls.
691 */
692 
693 /*!
694     \fn void QSignalBlocker::unblock()
695 
696     Temporarily restores the QObject::signalsBlocked() state to what
697     it was before this QSignalBlocker's constructor ran. To undo, use
698     reblock().
699 
700     The numbers of reblock() and unblock() calls are not counted, so
701     every unblock() undoes any number of reblock() calls.
702 */
703 
704 /*!
705     \class QObject
706     \inmodule QtCore
707     \brief The QObject class is the base class of all Qt objects.
708 
709     \ingroup objectmodel
710 
711     \reentrant
712 
713     QObject is the heart of the Qt \l{Object Model}. The central
714     feature in this model is a very powerful mechanism for seamless
715     object communication called \l{signals and slots}. You can
716     connect a signal to a slot with connect() and destroy the
717     connection with disconnect(). To avoid never ending notification
718     loops you can temporarily block signals with blockSignals(). The
719     protected functions connectNotify() and disconnectNotify() make
720     it possible to track connections.
721 
722     QObjects organize themselves in \l {Object Trees & Ownership}
723     {object trees}. When you create a QObject with another object as
724     parent, the object will automatically add itself to the parent's
725     children() list. The parent takes ownership of the object; i.e.,
726     it will automatically delete its children in its destructor. You
727     can look for an object by name and optionally type using
728     findChild() or findChildren().
729 
730     Every object has an objectName() and its class name can be found
731     via the corresponding metaObject() (see QMetaObject::className()).
732     You can determine whether the object's class inherits another
733     class in the QObject inheritance hierarchy by using the
734     inherits() function.
735 
736     When an object is deleted, it emits a destroyed() signal. You can
737     catch this signal to avoid dangling references to QObjects.
738 
739     QObjects can receive events through event() and filter the events
740     of other objects. See installEventFilter() and eventFilter() for
741     details. A convenience handler, childEvent(), can be reimplemented
742     to catch child events.
743 
744     Last but not least, QObject provides the basic timer support in
745     Qt; see QTimer for high-level support for timers.
746 
747     Notice that the Q_OBJECT macro is mandatory for any object that
748     implements signals, slots or properties. You also need to run the
749     \l{moc}{Meta Object Compiler} on the source file. We strongly
750     recommend the use of this macro in all subclasses of QObject
751     regardless of whether or not they actually use signals, slots and
752     properties, since failure to do so may lead certain functions to
753     exhibit strange behavior.
754 
755     All Qt widgets inherit QObject. The convenience function
756     isWidgetType() returns whether an object is actually a widget. It
757     is much faster than
758     \l{qobject_cast()}{qobject_cast}<QWidget *>(\e{obj}) or
759     \e{obj}->\l{inherits()}{inherits}("QWidget").
760 
761     Some QObject functions, e.g. children(), return a QObjectList.
762     QObjectList is a typedef for QList<QObject *>.
763 
764     \section1 Thread Affinity
765 
766     A QObject instance is said to have a \e{thread affinity}, or that
767     it \e{lives} in a certain thread. When a QObject receives a
768     \l{Qt::QueuedConnection}{queued signal} or a \l{The Event
769     System#Sending Events}{posted event}, the slot or event handler
770     will run in the thread that the object lives in.
771 
772     \note If a QObject has no thread affinity (that is, if thread()
773     returns zero), or if it lives in a thread that has no running event
774     loop, then it cannot receive queued signals or posted events.
775 
776     By default, a QObject lives in the thread in which it is created.
777     An object's thread affinity can be queried using thread() and
778     changed using moveToThread().
779 
780     All QObjects must live in the same thread as their parent. Consequently:
781 
782     \list
783     \li setParent() will fail if the two QObjects involved live in
784         different threads.
785     \li When a QObject is moved to another thread, all its children
786         will be automatically moved too.
787     \li moveToThread() will fail if the QObject has a parent.
788     \li If QObjects are created within QThread::run(), they cannot
789         become children of the QThread object because the QThread does
790         not live in the thread that calls QThread::run().
791     \endlist
792 
793     \note A QObject's member variables \e{do not} automatically become
794     its children. The parent-child relationship must be set by either
795     passing a pointer to the child's \l{QObject()}{constructor}, or by
796     calling setParent(). Without this step, the object's member variables
797     will remain in the old thread when moveToThread() is called.
798 
799     \target No copy constructor
800     \section1 No Copy Constructor or Assignment Operator
801 
802     QObject has neither a copy constructor nor an assignment operator.
803     This is by design. Actually, they are declared, but in a
804     \c{private} section with the macro Q_DISABLE_COPY(). In fact, all
805     Qt classes derived from QObject (direct or indirect) use this
806     macro to declare their copy constructor and assignment operator to
807     be private. The reasoning is found in the discussion on
808     \l{Identity vs Value} {Identity vs Value} on the Qt \l{Object
809     Model} page.
810 
811     The main consequence is that you should use pointers to QObject
812     (or to your QObject subclass) where you might otherwise be tempted
813     to use your QObject subclass as a value. For example, without a
814     copy constructor, you can't use a subclass of QObject as the value
815     to be stored in one of the container classes. You must store
816     pointers.
817 
818     \section1 Auto-Connection
819 
820     Qt's meta-object system provides a mechanism to automatically connect
821     signals and slots between QObject subclasses and their children. As long
822     as objects are defined with suitable object names, and slots follow a
823     simple naming convention, this connection can be performed at run-time
824     by the QMetaObject::connectSlotsByName() function.
825 
826     \l uic generates code that invokes this function to enable
827     auto-connection to be performed between widgets on forms created
828     with \e{Qt Designer}. More information about using auto-connection with \e{Qt Designer} is
829     given in the \l{Using a Designer UI File in Your Application} section of
830     the \e{Qt Designer} manual.
831 
832     \section1 Dynamic Properties
833 
834     From Qt 4.2, dynamic properties can be added to and removed from QObject
835     instances at run-time. Dynamic properties do not need to be declared at
836     compile-time, yet they provide the same advantages as static properties
837     and are manipulated using the same API - using property() to read them
838     and setProperty() to write them.
839 
840     From Qt 4.3, dynamic properties are supported by
841     \l{Qt Designer's Widget Editing Mode#The Property Editor}{Qt Designer},
842     and both standard Qt widgets and user-created forms can be given dynamic
843     properties.
844 
845     \section1 Internationalization (I18n)
846 
847     All QObject subclasses support Qt's translation features, making it possible
848     to translate an application's user interface into different languages.
849 
850     To make user-visible text translatable, it must be wrapped in calls to
851     the tr() function. This is explained in detail in the
852     \l{Writing Source Code for Translation} document.
853 
854     \sa QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY()
855     \sa {Object Trees & Ownership}
856 */
857 
858 /*****************************************************************************
859   QObject member functions
860  *****************************************************************************/
861 
862 // check the constructor's parent thread argument
863 static bool check_parent_thread(QObject *parent,
864                                 QThreadData *parentThreadData,
865                                 QThreadData *currentThreadData)
866 {
867     if (parent && parentThreadData != currentThreadData) {
868         QThread *parentThread = parentThreadData->thread.loadAcquire();
869         QThread *currentThread = currentThreadData->thread.loadAcquire();
870         qWarning("QObject: Cannot create children for a parent that is in a different thread.\n"
871                  "(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)",
872                  parent->metaObject()->className(),
873                  parent,
874                  parentThread ? parentThread->metaObject()->className() : "QThread",
875                  parentThread,
876                  currentThread ? currentThread->metaObject()->className() : "QThread",
877                  currentThread);
878         return false;
879     }
880     return true;
881 }
882 
883 /*!
884     Constructs an object with parent object \a parent.
885 
886     The parent of an object may be viewed as the object's owner. For
887     instance, a \l{QDialog}{dialog box} is the parent of the \uicontrol{OK}
888     and \uicontrol{Cancel} buttons it contains.
889 
890     The destructor of a parent object destroys all child objects.
891 
892     Setting \a parent to \nullptr constructs an object with no parent. If the
893     object is a widget, it will become a top-level window.
894 
895     \sa parent(), findChild(), findChildren()
896 */
897 
898 QObject::QObject(QObject *parent)
899     : QObject(*new QObjectPrivate, parent)
900 {
901 }
902 
903 /*!
904     \internal
905  */
906 QObject::QObject(QObjectPrivate &dd, QObject *parent)
907     : d_ptr(&dd)
908 {
909     Q_ASSERT_X(this != parent, Q_FUNC_INFO, "Cannot parent a QObject to itself");
910 
911     Q_D(QObject);
912     d_ptr->q_ptr = this;
913     auto threadData = (parent && !parent->thread()) ? parent->d_func()->threadData.loadRelaxed() : QThreadData::current();
914     threadData->ref();
915     d->threadData.storeRelaxed(threadData);
916     if (parent) {
917         QT_TRY {
918             if (!check_parent_thread(parent, parent ? parent->d_func()->threadData.loadRelaxed() : nullptr, threadData))
919                 parent = nullptr;
920             if (d->isWidget) {
921                 if (parent) {
922                     d->parent = parent;
923                     d->parent->d_func()->children.append(this);
924                 }
925                 // no events sent here, this is done at the end of the QWidget constructor
926             } else {
927                 setParent(parent);
928             }
929         } QT_CATCH(...) {
930             threadData->deref();
931             QT_RETHROW;
932         }
933     }
934 #if QT_VERSION < 0x60000
935     qt_addObject(this);
936 #endif
937     if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
938         reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
939     Q_TRACE(QObject_ctor, this);
940 }
941 
942 /*!
943     Destroys the object, deleting all its child objects.
944 
945     All signals to and from the object are automatically disconnected, and
946     any pending posted events for the object are removed from the event
947     queue. However, it is often safer to use deleteLater() rather than
948     deleting a QObject subclass directly.
949 
950     \warning All child objects are deleted. If any of these objects
951     are on the stack or global, sooner or later your program will
952     crash. We do not recommend holding pointers to child objects from
953     outside the parent. If you still do, the destroyed() signal gives
954     you an opportunity to detect when an object is destroyed.
955 
956     \warning Deleting a QObject while pending events are waiting to
957     be delivered can cause a crash. You must not delete the QObject
958     directly if it exists in a different thread than the one currently
959     executing. Use deleteLater() instead, which will cause the event
960     loop to delete the object after all pending events have been
961     delivered to it.
962 
963     \sa deleteLater()
964 */
965 
966 QObject::~QObject()
967 {
968     Q_D(QObject);
969     d->wasDeleted = true;
970     d->blockSig = 0; // unblock signals so we always emit destroyed()
971 
972     QtSharedPointer::ExternalRefCountData *sharedRefcount = d->sharedRefcount.loadRelaxed();
973     if (sharedRefcount) {
974         if (sharedRefcount->strongref.loadRelaxed() > 0) {
975             qWarning("QObject: shared QObject was deleted directly. The program is malformed and may crash.");
976             // but continue deleting, it's too late to stop anyway
977         }
978 
979         // indicate to all QWeakPointers that this QObject has now been deleted
980         sharedRefcount->strongref.storeRelaxed(0);
981         if (!sharedRefcount->weakref.deref())
982             delete sharedRefcount;
983     }
984 
985     if (!d->isWidget && d->isSignalConnected(0)) {
986         emit destroyed(this);
987     }
988 
989     if (d->declarativeData && QAbstractDeclarativeData::destroyed)
990         QAbstractDeclarativeData::destroyed(d->declarativeData, this);
991 
992     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
993     if (cd) {
994         if (cd->currentSender) {
995             cd->currentSender->receiverDeleted();
996             cd->currentSender = nullptr;
997         }
998 
999         QBasicMutex *signalSlotMutex = signalSlotLock(this);
1000         QBasicMutexLocker locker(signalSlotMutex);
1001 
1002         // disconnect all receivers
1003         int receiverCount = cd->signalVectorCount();
1004         for (int signal = -1; signal < receiverCount; ++signal) {
1005             QObjectPrivate::ConnectionList &connectionList = cd->connectionsForSignal(signal);
1006 
1007             while (QObjectPrivate::Connection *c = connectionList.first.loadRelaxed()) {
1008                 Q_ASSERT(c->receiver.loadAcquire());
1009 
1010                 QBasicMutex *m = signalSlotLock(c->receiver.loadRelaxed());
1011                 bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
1012                 if (c->receiver.loadAcquire()) {
1013                     cd->removeConnection(c);
1014                     Q_ASSERT(connectionList.first.loadRelaxed() != c);
1015                 }
1016                 if (needToUnlock)
1017                     m->unlock();
1018             }
1019         }
1020 
1021         /* Disconnect all senders:
1022          */
1023         while (QObjectPrivate::Connection *node = cd->senders) {
1024             Q_ASSERT(node->receiver.loadAcquire());
1025             QObject *sender = node->sender;
1026             // Send disconnectNotify before removing the connection from sender's connection list.
1027             // This ensures any eventual destructor of sender will block on getting receiver's lock
1028             // and not finish until we release it.
1029             sender->disconnectNotify(QMetaObjectPrivate::signal(sender->metaObject(), node->signal_index));
1030             QBasicMutex *m = signalSlotLock(sender);
1031             bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
1032             //the node has maybe been removed while the mutex was unlocked in relock?
1033             if (node != cd->senders) {
1034                 // We hold the wrong mutex
1035                 Q_ASSERT(needToUnlock);
1036                 m->unlock();
1037                 continue;
1038             }
1039 
1040             QObjectPrivate::ConnectionData *senderData = sender->d_func()->connections.loadRelaxed();
1041             Q_ASSERT(senderData);
1042 
1043             QtPrivate::QSlotObjectBase *slotObj = nullptr;
1044             if (node->isSlotObject) {
1045                 slotObj = node->slotObj;
1046                 node->isSlotObject = false;
1047             }
1048 
1049             senderData->removeConnection(node);
1050             if (needToUnlock)
1051                 m->unlock();
1052 
1053             if (slotObj) {
1054                 locker.unlock();
1055                 slotObj->destroyIfLastRef();
1056                 locker.relock();
1057             }
1058         }
1059 
1060         // invalidate all connections on the object and make sure
1061         // activate() will skip them
1062         cd->currentConnectionId.storeRelaxed(0);
1063     }
1064     if (cd && !cd->ref.deref())
1065         delete cd;
1066     d->connections.storeRelaxed(nullptr);
1067 
1068     if (!d->children.isEmpty())
1069         d->deleteChildren();
1070 
1071 #if QT_VERSION < 0x60000
1072     qt_removeObject(this);
1073 #endif
1074     if (Q_UNLIKELY(qtHookData[QHooks::RemoveQObject]))
1075         reinterpret_cast<QHooks::RemoveQObjectCallback>(qtHookData[QHooks::RemoveQObject])(this);
1076 
1077     Q_TRACE(QObject_dtor, this);
1078 
1079     if (d->parent)        // remove it from parent object
1080         d->setParent_helper(nullptr);
1081 }
1082 
1083 QObjectPrivate::Connection::~Connection()
1084 {
1085     if (ownArgumentTypes) {
1086         const int *v = argumentTypes.loadRelaxed();
1087         if (v != &DIRECT_CONNECTION_ONLY)
1088             delete [] v;
1089     }
1090     if (isSlotObject)
1091         slotObj->destroyIfLastRef();
1092 }
1093 
1094 
1095 /*!
1096     \fn const QMetaObject *QObject::metaObject() const
1097 
1098     Returns a pointer to the meta-object of this object.
1099 
1100     A meta-object contains information about a class that inherits
1101     QObject, e.g. class name, superclass name, properties, signals and
1102     slots. Every QObject subclass that contains the Q_OBJECT macro will have a
1103     meta-object.
1104 
1105     The meta-object information is required by the signal/slot
1106     connection mechanism and the property system. The inherits()
1107     function also makes use of the meta-object.
1108 
1109     If you have no pointer to an actual object instance but still
1110     want to access the meta-object of a class, you can use \l
1111     staticMetaObject.
1112 
1113     Example:
1114 
1115     \snippet code/src_corelib_kernel_qobject.cpp 1
1116 
1117     \sa staticMetaObject
1118 */
1119 
1120 /*!
1121     \variable QObject::staticMetaObject
1122 
1123     This variable stores the meta-object for the class.
1124 
1125     A meta-object contains information about a class that inherits
1126     QObject, e.g. class name, superclass name, properties, signals and
1127     slots. Every class that contains the Q_OBJECT macro will also have
1128     a meta-object.
1129 
1130     The meta-object information is required by the signal/slot
1131     connection mechanism and the property system. The inherits()
1132     function also makes use of the meta-object.
1133 
1134     If you have a pointer to an object, you can use metaObject() to
1135     retrieve the meta-object associated with that object.
1136 
1137     Example:
1138 
1139     \snippet code/src_corelib_kernel_qobject.cpp 2
1140 
1141     \sa metaObject()
1142 */
1143 
1144 /*!
1145     \fn template <class T> T qobject_cast(QObject *object)
1146     \fn template <class T> T qobject_cast(const QObject *object)
1147     \relates QObject
1148 
1149     Returns the given \a object cast to type T if the object is of type
1150     T (or of a subclass); otherwise returns \nullptr. If \a object is
1151     \nullptr then it will also return \nullptr.
1152 
1153     The class T must inherit (directly or indirectly) QObject and be
1154     declared with the \l Q_OBJECT macro.
1155 
1156     A class is considered to inherit itself.
1157 
1158     Example:
1159 
1160     \snippet code/src_corelib_kernel_qobject.cpp 3
1161 
1162     The qobject_cast() function behaves similarly to the standard C++
1163     \c dynamic_cast(), with the advantages that it doesn't require
1164     RTTI support and it works across dynamic library boundaries.
1165 
1166     qobject_cast() can also be used in conjunction with interfaces;
1167     see the \l{tools/plugandpaint/app}{Plug & Paint} example for details.
1168 
1169     \warning If T isn't declared with the Q_OBJECT macro, this
1170     function's return value is undefined.
1171 
1172     \sa QObject::inherits()
1173 */
1174 
1175 /*!
1176     \fn bool QObject::inherits(const char *className) const
1177 
1178     Returns \c true if this object is an instance of a class that
1179     inherits \a className or a QObject subclass that inherits \a
1180     className; otherwise returns \c false.
1181 
1182     A class is considered to inherit itself.
1183 
1184     Example:
1185 
1186     \snippet code/src_corelib_kernel_qobject.cpp 4
1187 
1188     If you need to determine whether an object is an instance of a particular
1189     class for the purpose of casting it, consider using qobject_cast<Type *>(object)
1190     instead.
1191 
1192     \sa metaObject(), qobject_cast()
1193 */
1194 
1195 /*!
1196     \property QObject::objectName
1197 
1198     \brief the name of this object
1199 
1200     You can find an object by name (and type) using findChild().
1201     You can find a set of objects with findChildren().
1202 
1203     \snippet code/src_corelib_kernel_qobject.cpp 5
1204 
1205     By default, this property contains an empty string.
1206 
1207     \sa metaObject(), QMetaObject::className()
1208 */
1209 
1210 QString QObject::objectName() const
1211 {
1212     Q_D(const QObject);
1213     return d->extraData ? d->extraData->objectName : QString();
1214 }
1215 
1216 /*
1217     Sets the object's name to \a name.
1218 */
1219 void QObject::setObjectName(const QString &name)
1220 {
1221     Q_D(QObject);
1222     if (!d->extraData)
1223         d->extraData = new QObjectPrivate::ExtraData;
1224 
1225     if (d->extraData->objectName != name) {
1226         d->extraData->objectName = name;
1227         emit objectNameChanged(d->extraData->objectName, QPrivateSignal());
1228     }
1229 }
1230 
1231 /*! \fn void QObject::objectNameChanged(const QString &objectName)
1232 
1233     This signal is emitted after the object's name has been changed. The new object name is passed as \a objectName.
1234 
1235     \sa QObject::objectName
1236 */
1237 
1238 /*!
1239     \fn bool QObject::isWidgetType() const
1240 
1241     Returns \c true if the object is a widget; otherwise returns \c false.
1242 
1243     Calling this function is equivalent to calling
1244     \c{inherits("QWidget")}, except that it is much faster.
1245 */
1246 
1247 /*!
1248     \fn bool QObject::isWindowType() const
1249 
1250     Returns \c true if the object is a window; otherwise returns \c false.
1251 
1252     Calling this function is equivalent to calling
1253     \c{inherits("QWindow")}, except that it is much faster.
1254 */
1255 
1256 /*!
1257     This virtual function receives events to an object and should
1258     return true if the event \a e was recognized and processed.
1259 
1260     The event() function can be reimplemented to customize the
1261     behavior of an object.
1262 
1263     Make sure you call the parent event class implementation
1264     for all the events you did not handle.
1265 
1266     Example:
1267 
1268     \snippet code/src_corelib_kernel_qobject.cpp 52
1269 
1270     \sa installEventFilter(), timerEvent(), QCoreApplication::sendEvent(),
1271     QCoreApplication::postEvent()
1272 */
1273 
1274 bool QObject::event(QEvent *e)
1275 {
1276     switch (e->type()) {
1277     case QEvent::Timer:
1278         timerEvent((QTimerEvent*)e);
1279         break;
1280 
1281     case QEvent::ChildAdded:
1282     case QEvent::ChildPolished:
1283     case QEvent::ChildRemoved:
1284         childEvent((QChildEvent*)e);
1285         break;
1286 
1287     case QEvent::DeferredDelete:
1288         qDeleteInEventHandler(this);
1289         break;
1290 
1291     case QEvent::MetaCall:
1292         {
1293             QAbstractMetaCallEvent *mce = static_cast<QAbstractMetaCallEvent*>(e);
1294 
1295             if (!d_func()->connections.loadRelaxed()) {
1296                 QBasicMutexLocker locker(signalSlotLock(this));
1297                 d_func()->ensureConnectionData();
1298             }
1299             QObjectPrivate::Sender sender(this, const_cast<QObject*>(mce->sender()), mce->signalId());
1300 
1301             mce->placeMetaCall(this);
1302             break;
1303         }
1304 
1305     case QEvent::ThreadChange: {
1306         Q_D(QObject);
1307         QThreadData *threadData = d->threadData.loadRelaxed();
1308         QAbstractEventDispatcher *eventDispatcher = threadData->eventDispatcher.loadRelaxed();
1309         if (eventDispatcher) {
1310             QList<QAbstractEventDispatcher::TimerInfo> timers = eventDispatcher->registeredTimers(this);
1311             if (!timers.isEmpty()) {
1312                 // do not to release our timer ids back to the pool (since the timer ids are moving to a new thread).
1313                 eventDispatcher->unregisterTimers(this);
1314                 QMetaObject::invokeMethod(this, "_q_reregisterTimers", Qt::QueuedConnection,
1315                                           Q_ARG(void*, (new QList<QAbstractEventDispatcher::TimerInfo>(timers))));
1316             }
1317         }
1318         break;
1319     }
1320 
1321     default:
1322         if (e->type() >= QEvent::User) {
1323             customEvent(e);
1324             break;
1325         }
1326         return false;
1327     }
1328     return true;
1329 }
1330 
1331 /*!
1332     \fn void QObject::timerEvent(QTimerEvent *event)
1333 
1334     This event handler can be reimplemented in a subclass to receive
1335     timer events for the object.
1336 
1337     QTimer provides a higher-level interface to the timer
1338     functionality, and also more general information about timers. The
1339     timer event is passed in the \a event parameter.
1340 
1341     \sa startTimer(), killTimer(), event()
1342 */
1343 
1344 void QObject::timerEvent(QTimerEvent *)
1345 {
1346 }
1347 
1348 
1349 /*!
1350     This event handler can be reimplemented in a subclass to receive
1351     child events. The event is passed in the \a event parameter.
1352 
1353     QEvent::ChildAdded and QEvent::ChildRemoved events are sent to
1354     objects when children are added or removed. In both cases you can
1355     only rely on the child being a QObject, or if isWidgetType()
1356     returns \c true, a QWidget. (This is because, in the
1357     \l{QEvent::ChildAdded}{ChildAdded} case, the child is not yet
1358     fully constructed, and in the \l{QEvent::ChildRemoved}{ChildRemoved}
1359     case it might have been destructed already).
1360 
1361     QEvent::ChildPolished events are sent to widgets when children
1362     are polished, or when polished children are added. If you receive
1363     a child polished event, the child's construction is usually
1364     completed. However, this is not guaranteed, and multiple polish
1365     events may be delivered during the execution of a widget's
1366     constructor.
1367 
1368     For every child widget, you receive one
1369     \l{QEvent::ChildAdded}{ChildAdded} event, zero or more
1370     \l{QEvent::ChildPolished}{ChildPolished} events, and one
1371     \l{QEvent::ChildRemoved}{ChildRemoved} event.
1372 
1373     The \l{QEvent::ChildPolished}{ChildPolished} event is omitted if
1374     a child is removed immediately after it is added. If a child is
1375     polished several times during construction and destruction, you
1376     may receive several child polished events for the same child,
1377     each time with a different virtual table.
1378 
1379     \sa event()
1380 */
1381 
1382 void QObject::childEvent(QChildEvent * /* event */)
1383 {
1384 }
1385 
1386 
1387 /*!
1388     This event handler can be reimplemented in a subclass to receive
1389     custom events. Custom events are user-defined events with a type
1390     value at least as large as the QEvent::User item of the
1391     QEvent::Type enum, and is typically a QEvent subclass. The event
1392     is passed in the \a event parameter.
1393 
1394     \sa event(), QEvent
1395 */
1396 void QObject::customEvent(QEvent * /* event */)
1397 {
1398 }
1399 
1400 
1401 
1402 /*!
1403     Filters events if this object has been installed as an event
1404     filter for the \a watched object.
1405 
1406     In your reimplementation of this function, if you want to filter
1407     the \a event out, i.e. stop it being handled further, return
1408     true; otherwise return false.
1409 
1410     Example:
1411     \snippet code/src_corelib_kernel_qobject.cpp 6
1412 
1413     Notice in the example above that unhandled events are passed to
1414     the base class's eventFilter() function, since the base class
1415     might have reimplemented eventFilter() for its own internal
1416     purposes.
1417 
1418     Some events, such as \l QEvent::ShortcutOverride must be explicitly
1419     accepted (by calling \l {QEvent::}{accept()} on them) in order to prevent
1420     propagation.
1421 
1422     \warning If you delete the receiver object in this function, be
1423     sure to return true. Otherwise, Qt will forward the event to the
1424     deleted object and the program might crash.
1425 
1426     \sa installEventFilter()
1427 */
1428 
1429 bool QObject::eventFilter(QObject * /* watched */, QEvent * /* event */)
1430 {
1431     return false;
1432 }
1433 
1434 /*!
1435     \fn bool QObject::signalsBlocked() const
1436 
1437     Returns \c true if signals are blocked; otherwise returns \c false.
1438 
1439     Signals are not blocked by default.
1440 
1441     \sa blockSignals(), QSignalBlocker
1442 */
1443 
1444 /*!
1445     If \a block is true, signals emitted by this object are blocked
1446     (i.e., emitting a signal will not invoke anything connected to it).
1447     If \a block is false, no such blocking will occur.
1448 
1449     The return value is the previous value of signalsBlocked().
1450 
1451     Note that the destroyed() signal will be emitted even if the signals
1452     for this object have been blocked.
1453 
1454     Signals emitted while being blocked are not buffered.
1455 
1456     \sa signalsBlocked(), QSignalBlocker
1457 */
1458 
1459 bool QObject::blockSignals(bool block) noexcept
1460 {
1461     Q_D(QObject);
1462     bool previous = d->blockSig;
1463     d->blockSig = block;
1464     return previous;
1465 }
1466 
1467 /*!
1468     Returns the thread in which the object lives.
1469 
1470     \sa moveToThread()
1471 */
1472 QThread *QObject::thread() const
1473 {
1474     return d_func()->threadData.loadRelaxed()->thread.loadAcquire();
1475 }
1476 
1477 /*!
1478     Changes the thread affinity for this object and its children. The
1479     object cannot be moved if it has a parent. Event processing will
1480     continue in the \a targetThread.
1481 
1482     To move an object to the main thread, use QApplication::instance()
1483     to retrieve a pointer to the current application, and then use
1484     QApplication::thread() to retrieve the thread in which the
1485     application lives. For example:
1486 
1487     \snippet code/src_corelib_kernel_qobject.cpp 7
1488 
1489     If \a targetThread is \nullptr, all event processing for this object
1490     and its children stops, as they are no longer associated with any
1491     thread.
1492 
1493     Note that all active timers for the object will be reset. The
1494     timers are first stopped in the current thread and restarted (with
1495     the same interval) in the \a targetThread. As a result, constantly
1496     moving an object between threads can postpone timer events
1497     indefinitely.
1498 
1499     A QEvent::ThreadChange event is sent to this object just before
1500     the thread affinity is changed. You can handle this event to
1501     perform any special processing. Note that any new events that are
1502     posted to this object will be handled in the \a targetThread,
1503     provided it is not \nullptr: when it is \nullptr, no event processing
1504     for this object or its children can happen, as they are no longer
1505     associated with any thread.
1506 
1507     \warning This function is \e not thread-safe; the current thread
1508     must be same as the current thread affinity. In other words, this
1509     function can only "push" an object from the current thread to
1510     another thread, it cannot "pull" an object from any arbitrary
1511     thread to the current thread. There is one exception to this rule
1512     however: objects with no thread affinity can be "pulled" to the
1513     current thread.
1514 
1515     \sa thread()
1516  */
1517 void QObject::moveToThread(QThread *targetThread)
1518 {
1519     Q_D(QObject);
1520 
1521     if (d->threadData.loadRelaxed()->thread.loadAcquire() == targetThread) {
1522         // object is already in this thread
1523         return;
1524     }
1525 
1526     if (d->parent != nullptr) {
1527         qWarning("QObject::moveToThread: Cannot move objects with a parent");
1528         return;
1529     }
1530     if (d->isWidget) {
1531         qWarning("QObject::moveToThread: Widgets cannot be moved to a new thread");
1532         return;
1533     }
1534 
1535     QThreadData *currentData = QThreadData::current();
1536     QThreadData *targetData = targetThread ? QThreadData::get2(targetThread) : nullptr;
1537     QThreadData *thisThreadData = d->threadData.loadRelaxed();
1538     if (!thisThreadData->thread.loadAcquire() && currentData == targetData) {
1539         // one exception to the rule: we allow moving objects with no thread affinity to the current thread
1540         currentData = d->threadData;
1541     } else if (thisThreadData != currentData) {
1542         qWarning("QObject::moveToThread: Current thread (%p) is not the object's thread (%p).\n"
1543                  "Cannot move to target thread (%p)\n",
1544                  currentData->thread.loadRelaxed(), thisThreadData->thread.loadRelaxed(), targetData ? targetData->thread.loadRelaxed() : nullptr);
1545 
1546 #ifdef Q_OS_MAC
1547         qWarning("You might be loading two sets of Qt binaries into the same process. "
1548                  "Check that all plugins are compiled against the right Qt binaries. Export "
1549                  "DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.");
1550 #endif
1551 
1552         return;
1553     }
1554 
1555     // prepare to move
1556     d->moveToThread_helper();
1557 
1558     if (!targetData)
1559         targetData = new QThreadData(0);
1560 
1561     // make sure nobody adds/removes connections to this object while we're moving it
1562     QMutexLocker l(signalSlotLock(this));
1563 
1564     QOrderedMutexLocker locker(&currentData->postEventList.mutex,
1565                                &targetData->postEventList.mutex);
1566 
1567     // keep currentData alive (since we've got it locked)
1568     currentData->ref();
1569 
1570     // move the object
1571     d_func()->setThreadData_helper(currentData, targetData);
1572 
1573     locker.unlock();
1574 
1575     // now currentData can commit suicide if it wants to
1576     currentData->deref();
1577 }
1578 
1579 void QObjectPrivate::moveToThread_helper()
1580 {
1581     Q_Q(QObject);
1582     QEvent e(QEvent::ThreadChange);
1583     QCoreApplication::sendEvent(q, &e);
1584     for (int i = 0; i < children.size(); ++i) {
1585         QObject *child = children.at(i);
1586         child->d_func()->moveToThread_helper();
1587     }
1588 }
1589 
1590 void QObjectPrivate::setThreadData_helper(QThreadData *currentData, QThreadData *targetData)
1591 {
1592     Q_Q(QObject);
1593 
1594     // move posted events
1595     int eventsMoved = 0;
1596     for (int i = 0; i < currentData->postEventList.size(); ++i) {
1597         const QPostEvent &pe = currentData->postEventList.at(i);
1598         if (!pe.event)
1599             continue;
1600         if (pe.receiver == q) {
1601             // move this post event to the targetList
1602             targetData->postEventList.addEvent(pe);
1603             const_cast<QPostEvent &>(pe).event = nullptr;
1604             ++eventsMoved;
1605         }
1606     }
1607     if (eventsMoved > 0 && targetData->hasEventDispatcher()) {
1608         targetData->canWait = false;
1609         targetData->eventDispatcher.loadRelaxed()->wakeUp();
1610     }
1611 
1612     // the current emitting thread shouldn't restore currentSender after calling moveToThread()
1613     ConnectionData *cd = connections.loadRelaxed();
1614     if (cd) {
1615         if (cd->currentSender) {
1616             cd->currentSender->receiverDeleted();
1617             cd->currentSender = nullptr;
1618         }
1619 
1620         // adjust the receiverThreadId values in the Connections
1621         if (cd) {
1622             auto *c = cd->senders;
1623             while (c) {
1624                 QObject *r = c->receiver.loadRelaxed();
1625                 if (r) {
1626                     Q_ASSERT(r == q);
1627                     targetData->ref();
1628                     QThreadData *old = c->receiverThreadData.loadRelaxed();
1629                     if (old)
1630                         old->deref();
1631                     c->receiverThreadData.storeRelaxed(targetData);
1632                 }
1633                 c = c->next;
1634             }
1635         }
1636 
1637     }
1638 
1639     // set new thread data
1640     targetData->ref();
1641     threadData.loadRelaxed()->deref();
1642 
1643     // synchronizes with loadAcquire e.g. in QCoreApplication::postEvent
1644     threadData.storeRelease(targetData);
1645 
1646     for (int i = 0; i < children.size(); ++i) {
1647         QObject *child = children.at(i);
1648         child->d_func()->setThreadData_helper(currentData, targetData);
1649     }
1650 }
1651 
1652 void QObjectPrivate::_q_reregisterTimers(void *pointer)
1653 {
1654     Q_Q(QObject);
1655     QList<QAbstractEventDispatcher::TimerInfo> *timerList = reinterpret_cast<QList<QAbstractEventDispatcher::TimerInfo> *>(pointer);
1656     QAbstractEventDispatcher *eventDispatcher = threadData.loadRelaxed()->eventDispatcher.loadRelaxed();
1657     for (int i = 0; i < timerList->size(); ++i) {
1658         const QAbstractEventDispatcher::TimerInfo &ti = timerList->at(i);
1659         eventDispatcher->registerTimer(ti.timerId, ti.interval, ti.timerType, q);
1660     }
1661     delete timerList;
1662 }
1663 
1664 
1665 //
1666 // The timer flag hasTimer is set when startTimer is called.
1667 // It is not reset when killing the timer because more than
1668 // one timer might be active.
1669 //
1670 
1671 /*!
1672     Starts a timer and returns a timer identifier, or returns zero if
1673     it could not start a timer.
1674 
1675     A timer event will occur every \a interval milliseconds until
1676     killTimer() is called. If \a interval is 0, then the timer event
1677     occurs once every time there are no more window system events to
1678     process.
1679 
1680     The virtual timerEvent() function is called with the QTimerEvent
1681     event parameter class when a timer event occurs. Reimplement this
1682     function to get timer events.
1683 
1684     If multiple timers are running, the QTimerEvent::timerId() can be
1685     used to find out which timer was activated.
1686 
1687     Example:
1688 
1689     \snippet code/src_corelib_kernel_qobject.cpp 8
1690 
1691     Note that QTimer's accuracy depends on the underlying operating system and
1692     hardware. The \a timerType argument allows you to customize the accuracy of
1693     the timer. See Qt::TimerType for information on the different timer types.
1694     Most platforms support an accuracy of 20 milliseconds; some provide more.
1695     If Qt is unable to deliver the requested number of timer events, it will
1696     silently discard some.
1697 
1698     The QTimer class provides a high-level programming interface with
1699     single-shot timers and timer signals instead of events. There is
1700     also a QBasicTimer class that is more lightweight than QTimer and
1701     less clumsy than using timer IDs directly.
1702 
1703     \sa timerEvent(), killTimer(), QTimer::singleShot()
1704 */
1705 
1706 int QObject::startTimer(int interval, Qt::TimerType timerType)
1707 {
1708     Q_D(QObject);
1709 
1710     if (Q_UNLIKELY(interval < 0)) {
1711         qWarning("QObject::startTimer: Timers cannot have negative intervals");
1712         return 0;
1713     }
1714 
1715     auto thisThreadData = d->threadData.loadRelaxed();
1716     if (Q_UNLIKELY(!thisThreadData->hasEventDispatcher())) {
1717         qWarning("QObject::startTimer: Timers can only be used with threads started with QThread");
1718         return 0;
1719     }
1720     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1721         qWarning("QObject::startTimer: Timers cannot be started from another thread");
1722         return 0;
1723     }
1724     int timerId = thisThreadData->eventDispatcher.loadRelaxed()->registerTimer(interval, timerType, this);
1725     if (!d->extraData)
1726         d->extraData = new QObjectPrivate::ExtraData;
1727     d->extraData->runningTimers.append(timerId);
1728     return timerId;
1729 }
1730 
1731 /*!
1732     \since 5.9
1733     \overload
1734     \fn int QObject::startTimer(std::chrono::milliseconds time, Qt::TimerType timerType)
1735 
1736     Starts a timer and returns a timer identifier, or returns zero if
1737     it could not start a timer.
1738 
1739     A timer event will occur every \a time interval until killTimer()
1740     is called. If \a time is equal to \c{std::chrono::duration::zero()},
1741     then the timer event occurs once every time there are no more window
1742     system events to process.
1743 
1744     The virtual timerEvent() function is called with the QTimerEvent
1745     event parameter class when a timer event occurs. Reimplement this
1746     function to get timer events.
1747 
1748     If multiple timers are running, the QTimerEvent::timerId() can be
1749     used to find out which timer was activated.
1750 
1751     Example:
1752 
1753     \snippet code/src_corelib_kernel_qobject.cpp 8
1754 
1755     Note that QTimer's accuracy depends on the underlying operating system and
1756     hardware. The \a timerType argument allows you to customize the accuracy of
1757     the timer. See Qt::TimerType for information on the different timer types.
1758     Most platforms support an accuracy of 20 milliseconds; some provide more.
1759     If Qt is unable to deliver the requested number of timer events, it will
1760     silently discard some.
1761 
1762     The QTimer class provides a high-level programming interface with
1763     single-shot timers and timer signals instead of events. There is
1764     also a QBasicTimer class that is more lightweight than QTimer and
1765     less clumsy than using timer IDs directly.
1766 
1767     \sa timerEvent(), killTimer(), QTimer::singleShot()
1768 */
1769 
1770 /*!
1771     Kills the timer with timer identifier, \a id.
1772 
1773     The timer identifier is returned by startTimer() when a timer
1774     event is started.
1775 
1776     \sa timerEvent(), startTimer()
1777 */
1778 
1779 void QObject::killTimer(int id)
1780 {
1781     Q_D(QObject);
1782     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1783         qWarning("QObject::killTimer: Timers cannot be stopped from another thread");
1784         return;
1785     }
1786     if (id) {
1787         int at = d->extraData ? d->extraData->runningTimers.indexOf(id) : -1;
1788         if (at == -1) {
1789             // timer isn't owned by this object
1790             qWarning("QObject::killTimer(): Error: timer id %d is not valid for object %p (%s, %ls), timer has not been killed",
1791                      id,
1792                      this,
1793                      metaObject()->className(),
1794                      qUtf16Printable(objectName()));
1795             return;
1796         }
1797 
1798         auto thisThreadData = d->threadData.loadRelaxed();
1799         if (thisThreadData->hasEventDispatcher())
1800             thisThreadData->eventDispatcher.loadRelaxed()->unregisterTimer(id);
1801 
1802         d->extraData->runningTimers.remove(at);
1803         QAbstractEventDispatcherPrivate::releaseTimerId(id);
1804     }
1805 }
1806 
1807 
1808 /*!
1809     \fn QObject *QObject::parent() const
1810 
1811     Returns a pointer to the parent object.
1812 
1813     \sa children()
1814 */
1815 
1816 /*!
1817     \fn const QObjectList &QObject::children() const
1818 
1819     Returns a list of child objects.
1820     The QObjectList class is defined in the \c{<QObject>} header
1821     file as the following:
1822 
1823     \quotefromfile kernel/qobject.h
1824     \skipto /typedef .*QObjectList/
1825     \printuntil QObjectList
1826 
1827     The first child added is the \l{QList::first()}{first} object in
1828     the list and the last child added is the \l{QList::last()}{last}
1829     object in the list, i.e. new children are appended at the end.
1830 
1831     Note that the list order changes when QWidget children are
1832     \l{QWidget::raise()}{raised} or \l{QWidget::lower()}{lowered}. A
1833     widget that is raised becomes the last object in the list, and a
1834     widget that is lowered becomes the first object in the list.
1835 
1836     \sa findChild(), findChildren(), parent(), setParent()
1837 */
1838 
1839 
1840 /*!
1841     \fn template<typename T> T *QObject::findChild(const QString &name, Qt::FindChildOptions options) const
1842 
1843     Returns the child of this object that can be cast into type T and
1844     that is called \a name, or \nullptr if there is no such object.
1845     Omitting the \a name argument causes all object names to be matched.
1846     The search is performed recursively, unless \a options specifies the
1847     option FindDirectChildrenOnly.
1848 
1849     If there is more than one child matching the search, the most
1850     direct ancestor is returned. If there are several direct
1851     ancestors, it is undefined which one will be returned. In that
1852     case, findChildren() should be used.
1853 
1854     This example returns a child \c{QPushButton} of \c{parentWidget}
1855     named \c{"button1"}, even if the button isn't a direct child of
1856     the parent:
1857 
1858     \snippet code/src_corelib_kernel_qobject.cpp 10
1859 
1860     This example returns a \c{QListWidget} child of \c{parentWidget}:
1861 
1862     \snippet code/src_corelib_kernel_qobject.cpp 11
1863 
1864     This example returns a child \c{QPushButton} of \c{parentWidget}
1865     (its direct parent) named \c{"button1"}:
1866 
1867     \snippet code/src_corelib_kernel_qobject.cpp 41
1868 
1869     This example returns a \c{QListWidget} child of \c{parentWidget},
1870     its direct parent:
1871 
1872     \snippet code/src_corelib_kernel_qobject.cpp 42
1873 
1874     \sa findChildren()
1875 */
1876 
1877 /*!
1878     \fn template<typename T> QList<T> QObject::findChildren(const QString &name, Qt::FindChildOptions options) const
1879 
1880     Returns all children of this object with the given \a name that can be
1881     cast to type T, or an empty list if there are no such objects.
1882     Omitting the \a name argument causes all object names to be matched.
1883     The search is performed recursively, unless \a options specifies the
1884     option FindDirectChildrenOnly.
1885 
1886     The following example shows how to find a list of child \c{QWidget}s of
1887     the specified \c{parentWidget} named \c{widgetname}:
1888 
1889     \snippet code/src_corelib_kernel_qobject.cpp 12
1890 
1891     This example returns all \c{QPushButton}s that are children of \c{parentWidget}:
1892 
1893     \snippet code/src_corelib_kernel_qobject.cpp 13
1894 
1895     This example returns all \c{QPushButton}s that are immediate children of \c{parentWidget}:
1896 
1897     \snippet code/src_corelib_kernel_qobject.cpp 43
1898 
1899     \sa findChild()
1900 */
1901 
1902 /*!
1903     \fn QList<T> QObject::findChildren(const QRegularExpression &re, Qt::FindChildOptions options) const
1904     \overload findChildren()
1905 
1906     \since 5.0
1907 
1908     Returns the children of this object that can be cast to type T
1909     and that have names matching the regular expression \a re,
1910     or an empty list if there are no such objects.
1911     The search is performed recursively, unless \a options specifies the
1912     option FindDirectChildrenOnly.
1913 */
1914 
1915 /*!
1916     \fn template<typename T> T qFindChild(const QObject *obj, const QString &name)
1917     \relates QObject
1918     \overload qFindChildren()
1919     \obsolete
1920 
1921     This function is equivalent to
1922     \a{obj}->\l{QObject::findChild()}{findChild}<T>(\a name).
1923 
1924     \note This function was provided as a workaround for MSVC 6
1925     which did not support member template functions. It is advised
1926     to use the other form in new code.
1927 
1928     \sa QObject::findChild()
1929 */
1930 
1931 /*!
1932     \fn template<typename T> QList<T> qFindChildren(const QObject *obj, const QString &name)
1933     \relates QObject
1934     \overload qFindChildren()
1935     \obsolete
1936 
1937     This function is equivalent to
1938     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a name).
1939 
1940     \note This function was provided as a workaround for MSVC 6
1941     which did not support member template functions. It is advised
1942     to use the other form in new code.
1943 
1944     \sa QObject::findChildren()
1945 */
1946 
1947 /*!
1948     \internal
1949 */
1950 void qt_qFindChildren_helper(const QObject *parent, const QString &name,
1951                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1952 {
1953     if (!parent || !list)
1954         return;
1955     const QObjectList &children = parent->children();
1956     QObject *obj;
1957     for (int i = 0; i < children.size(); ++i) {
1958         obj = children.at(i);
1959         if (mo.cast(obj)) {
1960             if (name.isNull() || obj->objectName() == name)
1961                 list->append(obj);
1962         }
1963         if (options & Qt::FindChildrenRecursively)
1964             qt_qFindChildren_helper(obj, name, mo, list, options);
1965     }
1966 }
1967 
1968 #if QT_CONFIG(regularexpression)
1969 /*!
1970     \internal
1971 */
1972 void qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &re,
1973                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
1974 {
1975     if (!parent || !list)
1976         return;
1977     const QObjectList &children = parent->children();
1978     QObject *obj;
1979     for (int i = 0; i < children.size(); ++i) {
1980         obj = children.at(i);
1981         if (mo.cast(obj)) {
1982             QRegularExpressionMatch m = re.match(obj->objectName());
1983             if (m.hasMatch())
1984                 list->append(obj);
1985         }
1986         if (options & Qt::FindChildrenRecursively)
1987             qt_qFindChildren_helper(obj, re, mo, list, options);
1988     }
1989 }
1990 #endif // QT_CONFIG(regularexpression)
1991 
1992 /*!
1993     \internal
1994  */
1995 QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo, Qt::FindChildOptions options)
1996 {
1997     if (!parent)
1998         return nullptr;
1999     const QObjectList &children = parent->children();
2000     QObject *obj;
2001     int i;
2002     for (i = 0; i < children.size(); ++i) {
2003         obj = children.at(i);
2004         if (mo.cast(obj) && (name.isNull() || obj->objectName() == name))
2005             return obj;
2006     }
2007     if (options & Qt::FindChildrenRecursively) {
2008         for (i = 0; i < children.size(); ++i) {
2009             obj = qt_qFindChild_helper(children.at(i), name, mo, options);
2010             if (obj)
2011                 return obj;
2012         }
2013     }
2014     return nullptr;
2015 }
2016 
2017 /*!
2018     Makes the object a child of \a parent.
2019 
2020     \sa parent(), children()
2021 */
2022 void QObject::setParent(QObject *parent)
2023 {
2024     Q_D(QObject);
2025     Q_ASSERT(!d->isWidget);
2026     d->setParent_helper(parent);
2027 }
2028 
2029 void QObjectPrivate::deleteChildren()
2030 {
2031     Q_ASSERT_X(!isDeletingChildren, "QObjectPrivate::deleteChildren()", "isDeletingChildren already set, did this function recurse?");
2032     isDeletingChildren = true;
2033     // delete children objects
2034     // don't use qDeleteAll as the destructor of the child might
2035     // delete siblings
2036     for (int i = 0; i < children.count(); ++i) {
2037         currentChildBeingDeleted = children.at(i);
2038         children[i] = nullptr;
2039         delete currentChildBeingDeleted;
2040     }
2041     children.clear();
2042     currentChildBeingDeleted = nullptr;
2043     isDeletingChildren = false;
2044 }
2045 
2046 void QObjectPrivate::setParent_helper(QObject *o)
2047 {
2048     Q_Q(QObject);
2049     Q_ASSERT_X(q != o, Q_FUNC_INFO, "Cannot parent a QObject to itself");
2050 #ifdef QT_DEBUG
2051     const auto checkForParentChildLoops = qScopeGuard([&](){
2052         int depth = 0;
2053         auto p = parent;
2054         while (p) {
2055             if (++depth == CheckForParentChildLoopsWarnDepth) {
2056                 qWarning("QObject %p (class: '%s', object name: '%s') may have a loop in its parent-child chain; "
2057                          "this is undefined behavior",
2058                          q, q->metaObject()->className(), qPrintable(q->objectName()));
2059             }
2060             p = p->parent();
2061         }
2062     });
2063 #endif
2064 
2065     if (o == parent)
2066         return;
2067 
2068     if (parent) {
2069         QObjectPrivate *parentD = parent->d_func();
2070         if (parentD->isDeletingChildren && wasDeleted
2071             && parentD->currentChildBeingDeleted == q) {
2072             // don't do anything since QObjectPrivate::deleteChildren() already
2073             // cleared our entry in parentD->children.
2074         } else {
2075             const int index = parentD->children.indexOf(q);
2076             if (index < 0) {
2077                 // we're probably recursing into setParent() from a ChildRemoved event, don't do anything
2078             } else if (parentD->isDeletingChildren) {
2079                 parentD->children[index] = nullptr;
2080             } else {
2081                 parentD->children.removeAt(index);
2082                 if (sendChildEvents && parentD->receiveChildEvents) {
2083                     QChildEvent e(QEvent::ChildRemoved, q);
2084                     QCoreApplication::sendEvent(parent, &e);
2085                 }
2086             }
2087         }
2088     }
2089     parent = o;
2090     if (parent) {
2091         // object hierarchies are constrained to a single thread
2092         if (threadData != parent->d_func()->threadData) {
2093             qWarning("QObject::setParent: Cannot set parent, new parent is in a different thread");
2094             parent = nullptr;
2095             return;
2096         }
2097         parent->d_func()->children.append(q);
2098         if(sendChildEvents && parent->d_func()->receiveChildEvents) {
2099             if (!isWidget) {
2100                 QChildEvent e(QEvent::ChildAdded, q);
2101                 QCoreApplication::sendEvent(parent, &e);
2102             }
2103         }
2104     }
2105     if (!wasDeleted && !isDeletingChildren && declarativeData && QAbstractDeclarativeData::parentChanged)
2106         QAbstractDeclarativeData::parentChanged(declarativeData, q, o);
2107 }
2108 
2109 /*!
2110     \fn void QObject::installEventFilter(QObject *filterObj)
2111 
2112     Installs an event filter \a filterObj on this object. For example:
2113     \snippet code/src_corelib_kernel_qobject.cpp 14
2114 
2115     An event filter is an object that receives all events that are
2116     sent to this object. The filter can either stop the event or
2117     forward it to this object. The event filter \a filterObj receives
2118     events via its eventFilter() function. The eventFilter() function
2119     must return true if the event should be filtered, (i.e. stopped);
2120     otherwise it must return false.
2121 
2122     If multiple event filters are installed on a single object, the
2123     filter that was installed last is activated first.
2124 
2125     Here's a \c KeyPressEater class that eats the key presses of its
2126     monitored objects:
2127 
2128     \snippet code/src_corelib_kernel_qobject.cpp 15
2129 
2130     And here's how to install it on two widgets:
2131 
2132     \snippet code/src_corelib_kernel_qobject.cpp 16
2133 
2134     The QShortcut class, for example, uses this technique to intercept
2135     shortcut key presses.
2136 
2137     \warning If you delete the receiver object in your eventFilter()
2138     function, be sure to return true. If you return false, Qt sends
2139     the event to the deleted object and the program will crash.
2140 
2141     Note that the filtering object must be in the same thread as this
2142     object. If \a filterObj is in a different thread, this function does
2143     nothing. If either \a filterObj or this object are moved to a different
2144     thread after calling this function, the event filter will not be
2145     called until both objects have the same thread affinity again (it
2146     is \e not removed).
2147 
2148     \sa removeEventFilter(), eventFilter(), event()
2149 */
2150 
2151 void QObject::installEventFilter(QObject *obj)
2152 {
2153     Q_D(QObject);
2154     if (!obj)
2155         return;
2156     if (d->threadData != obj->d_func()->threadData) {
2157         qWarning("QObject::installEventFilter(): Cannot filter events for objects in a different thread.");
2158         return;
2159     }
2160 
2161     if (!d->extraData)
2162         d->extraData = new QObjectPrivate::ExtraData;
2163 
2164     // clean up unused items in the list
2165     d->extraData->eventFilters.removeAll((QObject*)nullptr);
2166     d->extraData->eventFilters.removeAll(obj);
2167     d->extraData->eventFilters.prepend(obj);
2168 }
2169 
2170 /*!
2171     Removes an event filter object \a obj from this object. The
2172     request is ignored if such an event filter has not been installed.
2173 
2174     All event filters for this object are automatically removed when
2175     this object is destroyed.
2176 
2177     It is always safe to remove an event filter, even during event
2178     filter activation (i.e. from the eventFilter() function).
2179 
2180     \sa installEventFilter(), eventFilter(), event()
2181 */
2182 
2183 void QObject::removeEventFilter(QObject *obj)
2184 {
2185     Q_D(QObject);
2186     if (d->extraData) {
2187         for (int i = 0; i < d->extraData->eventFilters.count(); ++i) {
2188             if (d->extraData->eventFilters.at(i) == obj)
2189                 d->extraData->eventFilters[i] = nullptr;
2190         }
2191     }
2192 }
2193 
2194 
2195 /*!
2196     \fn void QObject::destroyed(QObject *obj)
2197 
2198     This signal is emitted immediately before the object \a obj is
2199     destroyed, after any instances of QPointer have been notified,
2200     and cannot be blocked.
2201 
2202     All the objects's children are destroyed immediately after this
2203     signal is emitted.
2204 
2205     \sa deleteLater(), QPointer
2206 */
2207 
2208 /*!
2209     \threadsafe
2210 
2211     Schedules this object for deletion.
2212 
2213     The object will be deleted when control returns to the event
2214     loop. If the event loop is not running when this function is
2215     called (e.g. deleteLater() is called on an object before
2216     QCoreApplication::exec()), the object will be deleted once the
2217     event loop is started. If deleteLater() is called after the main event loop
2218     has stopped, the object will not be deleted.
2219     Since Qt 4.8, if deleteLater() is called on an object that lives in a
2220     thread with no running event loop, the object will be destroyed when the
2221     thread finishes.
2222 
2223     Note that entering and leaving a new event loop (e.g., by opening a modal
2224     dialog) will \e not perform the deferred deletion; for the object to be
2225     deleted, the control must return to the event loop from which deleteLater()
2226     was called. This does not apply to objects deleted while a previous, nested
2227     event loop was still running: the Qt event loop will delete those objects
2228     as soon as the new nested event loop starts.
2229 
2230     \b{Note:} It is safe to call this function more than once; when the
2231     first deferred deletion event is delivered, any pending events for the
2232     object are removed from the event queue.
2233 
2234     \sa destroyed(), QPointer
2235 */
2236 void QObject::deleteLater()
2237 {
2238     QCoreApplication::postEvent(this, new QDeferredDeleteEvent());
2239 }
2240 
2241 /*!
2242     \fn QString QObject::tr(const char *sourceText, const char *disambiguation, int n)
2243     \reentrant
2244 
2245     Returns a translated version of \a sourceText, optionally based on a
2246     \a disambiguation string and value of \a n for strings containing plurals;
2247     otherwise returns QString::fromUtf8(\a sourceText) if no appropriate
2248     translated string is available.
2249 
2250     Example:
2251     \snippet ../widgets/mainwindows/sdi/mainwindow.cpp implicit tr context
2252     \dots
2253 
2254     If the same \a sourceText is used in different roles within the
2255     same context, an additional identifying string may be passed in
2256     \a disambiguation (\nullptr by default). In Qt 4.4 and earlier, this was
2257     the preferred way to pass comments to translators.
2258 
2259     Example:
2260 
2261     \snippet code/src_corelib_kernel_qobject.cpp 17
2262     \dots
2263 
2264     See \l{Writing Source Code for Translation} for a detailed description of
2265     Qt's translation mechanisms in general, and the
2266     \l{Writing Source Code for Translation#Disambiguation}{Disambiguation}
2267     section for information on disambiguation.
2268 
2269     \warning This method is reentrant only if all translators are
2270     installed \e before calling this method. Installing or removing
2271     translators while performing translations is not supported. Doing
2272     so will probably result in crashes or other undesirable behavior.
2273 
2274     \sa QCoreApplication::translate(), {Internationalization with Qt}
2275 */
2276 
2277 /*!
2278     \fn QString QObject::trUtf8(const char *sourceText, const char *disambiguation, int n)
2279     \reentrant
2280     \obsolete
2281 
2282     Returns a translated version of \a sourceText, or
2283     QString::fromUtf8(\a sourceText) if there is no appropriate
2284     version. It is otherwise identical to tr(\a sourceText, \a
2285     disambiguation, \a n).
2286 
2287     \warning This method is reentrant only if all translators are
2288     installed \e before calling this method. Installing or removing
2289     translators while performing translations is not supported. Doing
2290     so will probably result in crashes or other undesirable behavior.
2291 
2292     \warning For portability reasons, we recommend that you use
2293     escape sequences for specifying non-ASCII characters in string
2294     literals to trUtf8(). For example:
2295 
2296     \snippet code/src_corelib_kernel_qobject.cpp 20
2297 
2298     \sa tr(), QCoreApplication::translate(), {Internationalization with Qt}
2299 */
2300 
2301 
2302 
2303 
2304 /*****************************************************************************
2305   Signals and slots
2306  *****************************************************************************/
2307 
2308 
2309 const char *qFlagLocation(const char *method)
2310 {
2311     QThreadData *currentThreadData = QThreadData::current(false);
2312     if (currentThreadData != nullptr)
2313         currentThreadData->flaggedSignatures.store(method);
2314     return method;
2315 }
2316 
2317 static int extract_code(const char *member)
2318 {
2319     // extract code, ensure QMETHOD_CODE <= code <= QSIGNAL_CODE
2320     return (((int)(*member) - '0') & 0x3);
2321 }
2322 
2323 static const char * extract_location(const char *member)
2324 {
2325     if (QThreadData::current()->flaggedSignatures.contains(member)) {
2326         // signature includes location information after the first null-terminator
2327         const char *location = member + qstrlen(member) + 1;
2328         if (*location != '\0')
2329             return location;
2330     }
2331     return nullptr;
2332 }
2333 
2334 static bool check_signal_macro(const QObject *sender, const char *signal,
2335                                 const char *func, const char *op)
2336 {
2337     int sigcode = extract_code(signal);
2338     if (sigcode != QSIGNAL_CODE) {
2339         if (sigcode == QSLOT_CODE)
2340             qWarning("QObject::%s: Attempt to %s non-signal %s::%s",
2341                      func, op, sender->metaObject()->className(), signal+1);
2342         else
2343             qWarning("QObject::%s: Use the SIGNAL macro to %s %s::%s",
2344                      func, op, sender->metaObject()->className(), signal);
2345         return false;
2346     }
2347     return true;
2348 }
2349 
2350 static bool check_method_code(int code, const QObject *object,
2351                                const char *method, const char *func)
2352 {
2353     if (code != QSLOT_CODE && code != QSIGNAL_CODE) {
2354         qWarning("QObject::%s: Use the SLOT or SIGNAL macro to "
2355                  "%s %s::%s", func, func, object->metaObject()->className(), method);
2356         return false;
2357     }
2358     return true;
2359 }
2360 
2361 static void err_method_notfound(const QObject *object,
2362                                 const char *method, const char *func)
2363 {
2364     const char *type = "method";
2365     switch (extract_code(method)) {
2366         case QSLOT_CODE:   type = "slot";   break;
2367         case QSIGNAL_CODE: type = "signal"; break;
2368     }
2369     const char *loc = extract_location(method);
2370     if (strchr(method,')') == nullptr)                // common typing mistake
2371         qWarning("QObject::%s: Parentheses expected, %s %s::%s%s%s",
2372                  func, type, object->metaObject()->className(), method+1,
2373                  loc ? " in ": "", loc ? loc : "");
2374     else
2375         qWarning("QObject::%s: No such %s %s::%s%s%s",
2376                  func, type, object->metaObject()->className(), method+1,
2377                  loc ? " in ": "", loc ? loc : "");
2378 
2379 }
2380 
2381 
2382 static void err_info_about_objects(const char * func,
2383                                     const QObject * sender,
2384                                     const QObject * receiver)
2385 {
2386     QString a = sender ? sender->objectName() : QString();
2387     QString b = receiver ? receiver->objectName() : QString();
2388     if (!a.isEmpty())
2389         qWarning("QObject::%s:  (sender name:   '%s')", func, a.toLocal8Bit().data());
2390     if (!b.isEmpty())
2391         qWarning("QObject::%s:  (receiver name: '%s')", func, b.toLocal8Bit().data());
2392 }
2393 
2394 /*!
2395     Returns a pointer to the object that sent the signal, if called in
2396     a slot activated by a signal; otherwise it returns \nullptr. The pointer
2397     is valid only during the execution of the slot that calls this
2398     function from this object's thread context.
2399 
2400     The pointer returned by this function becomes invalid if the
2401     sender is destroyed, or if the slot is disconnected from the
2402     sender's signal.
2403 
2404     \warning This function violates the object-oriented principle of
2405     modularity. However, getting access to the sender might be useful
2406     when many signals are connected to a single slot.
2407 
2408     \warning As mentioned above, the return value of this function is
2409     not valid when the slot is called via a Qt::DirectConnection from
2410     a thread different from this object's thread. Do not use this
2411     function in this type of scenario.
2412 
2413     \sa senderSignalIndex()
2414 */
2415 
2416 QObject *QObject::sender() const
2417 {
2418     Q_D(const QObject);
2419 
2420     QBasicMutexLocker locker(signalSlotLock(this));
2421     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2422     if (!cd || !cd->currentSender)
2423         return nullptr;
2424 
2425     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2426         if (c->sender == cd->currentSender->sender)
2427             return cd->currentSender->sender;
2428     }
2429 
2430     return nullptr;
2431 }
2432 
2433 /*!
2434     \since 4.8
2435 
2436     Returns the meta-method index of the signal that called the currently
2437     executing slot, which is a member of the class returned by sender().
2438     If called outside of a slot activated by a signal, -1 is returned.
2439 
2440     For signals with default parameters, this function will always return
2441     the index with all parameters, regardless of which was used with
2442     connect(). For example, the signal \c {destroyed(QObject *obj = \nullptr)}
2443     will have two different indexes (with and without the parameter), but
2444     this function will always return the index with a parameter. This does
2445     not apply when overloading signals with different parameters.
2446 
2447     \warning This function violates the object-oriented principle of
2448     modularity. However, getting access to the signal index might be useful
2449     when many signals are connected to a single slot.
2450 
2451     \warning The return value of this function is not valid when the slot
2452     is called via a Qt::DirectConnection from a thread different from this
2453     object's thread. Do not use this function in this type of scenario.
2454 
2455     \sa sender(), QMetaObject::indexOfSignal(), QMetaObject::method()
2456 */
2457 
2458 int QObject::senderSignalIndex() const
2459 {
2460     Q_D(const QObject);
2461 
2462     QBasicMutexLocker locker(signalSlotLock(this));
2463     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2464     if (!cd || !cd->currentSender)
2465         return -1;
2466 
2467     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2468         if (c->sender == cd->currentSender->sender) {
2469             // Convert from signal range to method range
2470             return QMetaObjectPrivate::signal(c->sender->metaObject(), cd->currentSender->signal).methodIndex();
2471         }
2472     }
2473 
2474     return -1;
2475 }
2476 
2477 /*!
2478     Returns the number of receivers connected to the \a signal.
2479 
2480     Since both slots and signals can be used as receivers for signals,
2481     and the same connections can be made many times, the number of
2482     receivers is the same as the number of connections made from this
2483     signal.
2484 
2485     When calling this function, you can use the \c SIGNAL() macro to
2486     pass a specific signal:
2487 
2488     \snippet code/src_corelib_kernel_qobject.cpp 21
2489 
2490     \warning This function violates the object-oriented principle of
2491     modularity. However, it might be useful when you need to perform
2492     expensive initialization only if something is connected to a
2493     signal.
2494 
2495     \sa isSignalConnected()
2496 */
2497 
2498 int QObject::receivers(const char *signal) const
2499 {
2500     Q_D(const QObject);
2501     int receivers = 0;
2502     if (signal) {
2503         QByteArray signal_name = QMetaObject::normalizedSignature(signal);
2504         signal = signal_name;
2505 #ifndef QT_NO_DEBUG
2506         if (!check_signal_macro(this, signal, "receivers", "bind"))
2507             return 0;
2508 #endif
2509         signal++; // skip code
2510         int signal_index = d->signalIndex(signal);
2511         if (signal_index < 0) {
2512 #ifndef QT_NO_DEBUG
2513             err_method_notfound(this, signal-1, "receivers");
2514 #endif
2515             return 0;
2516         }
2517 
2518         if (!d->isSignalConnected(signal_index))
2519             return receivers;
2520 
2521         if (d->declarativeData && QAbstractDeclarativeData::receivers) {
2522             receivers += QAbstractDeclarativeData::receivers(d->declarativeData, this,
2523                                                              signal_index);
2524         }
2525 
2526         QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2527         QBasicMutexLocker locker(signalSlotLock(this));
2528         if (cd && signal_index < cd->signalVectorCount()) {
2529             const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
2530             while (c) {
2531                 receivers += c->receiver.loadRelaxed() ? 1 : 0;
2532                 c = c->nextConnectionList.loadRelaxed();
2533             }
2534         }
2535     }
2536     return receivers;
2537 }
2538 
2539 /*!
2540     \since 5.0
2541     Returns \c true if the \a signal is connected to at least one receiver,
2542     otherwise returns \c false.
2543 
2544     \a signal must be a signal member of this object, otherwise the behaviour
2545     is undefined.
2546 
2547     \snippet code/src_corelib_kernel_qobject.cpp 49
2548 
2549     As the code snippet above illustrates, you can use this function
2550     to avoid emitting a signal that nobody listens to.
2551 
2552     \warning This function violates the object-oriented principle of
2553     modularity. However, it might be useful when you need to perform
2554     expensive initialization only if something is connected to a
2555     signal.
2556 */
2557 bool QObject::isSignalConnected(const QMetaMethod &signal) const
2558 {
2559     Q_D(const QObject);
2560     if (!signal.mobj)
2561         return false;
2562 
2563     Q_ASSERT_X(signal.mobj->cast(this) && signal.methodType() == QMetaMethod::Signal,
2564                "QObject::isSignalConnected" , "the parameter must be a signal member of the object");
2565     uint signalIndex = signal.relativeMethodIndex();
2566 
2567     if (signal.data.flags() & MethodCloned)
2568         signalIndex = QMetaObjectPrivate::originalClone(signal.mobj, signalIndex);
2569 
2570     signalIndex += QMetaObjectPrivate::signalOffset(signal.mobj);
2571 
2572     QBasicMutexLocker locker(signalSlotLock(this));
2573     return d->isSignalConnected(signalIndex, true);
2574 }
2575 
2576 /*!
2577     \internal
2578 
2579     This helper function calculates signal and method index for the given
2580     member in the specified class.
2581 
2582     \list
2583     \li If member.mobj is \nullptr then both signalIndex and methodIndex are set to -1.
2584 
2585     \li If specified member is not a member of obj instance class (or one of
2586     its parent classes) then both signalIndex and methodIndex are set to -1.
2587     \endlist
2588 
2589     This function is used by QObject::connect and QObject::disconnect which
2590     are working with QMetaMethod.
2591 
2592     \a signalIndex is set to the signal index of member. If the member
2593     specified is not signal this variable is set to -1.
2594 
2595     \a methodIndex is set to the method index of the member. If the
2596     member is not a method of the object specified by the \a obj argument this
2597     variable is set to -1.
2598 */
2599 void QMetaObjectPrivate::memberIndexes(const QObject *obj,
2600                                        const QMetaMethod &member,
2601                                        int *signalIndex, int *methodIndex)
2602 {
2603     *signalIndex = -1;
2604     *methodIndex = -1;
2605     if (!obj || !member.mobj)
2606         return;
2607     const QMetaObject *m = obj->metaObject();
2608     // Check that member is member of obj class
2609     while (m != nullptr && m != member.mobj)
2610         m = m->d.superdata;
2611     if (!m)
2612         return;
2613     *signalIndex = *methodIndex = member.relativeMethodIndex();
2614 
2615     int signalOffset;
2616     int methodOffset;
2617     computeOffsets(m, &signalOffset, &methodOffset);
2618 
2619     *methodIndex += methodOffset;
2620     if (member.methodType() == QMetaMethod::Signal) {
2621         *signalIndex = originalClone(m, *signalIndex);
2622         *signalIndex += signalOffset;
2623     } else {
2624         *signalIndex = -1;
2625     }
2626 }
2627 
2628 #ifndef QT_NO_DEBUG
2629 static inline void check_and_warn_compat(const QMetaObject *sender, const QMetaMethod &signal,
2630                                          const QMetaObject *receiver, const QMetaMethod &method)
2631 {
2632     if (signal.attributes() & QMetaMethod::Compatibility) {
2633         if (!(method.attributes() & QMetaMethod::Compatibility))
2634             qWarning("QObject::connect: Connecting from COMPAT signal (%s::%s)",
2635                      sender->className(), signal.methodSignature().constData());
2636     } else if ((method.attributes() & QMetaMethod::Compatibility) &&
2637                method.methodType() == QMetaMethod::Signal) {
2638         qWarning("QObject::connect: Connecting from %s::%s to COMPAT slot (%s::%s)",
2639                  sender->className(), signal.methodSignature().constData(),
2640                  receiver->className(), method.methodSignature().constData());
2641     }
2642 }
2643 #endif
2644 
2645 /*!
2646     \threadsafe
2647 
2648     Creates a connection of the given \a type from the \a signal in
2649     the \a sender object to the \a method in the \a receiver object.
2650     Returns a handle to the connection that can be used to disconnect
2651     it later.
2652 
2653     You must use the \c SIGNAL() and \c SLOT() macros when specifying
2654     the \a signal and the \a method, for example:
2655 
2656     \snippet code/src_corelib_kernel_qobject.cpp 22
2657 
2658     This example ensures that the label always displays the current
2659     scroll bar value. Note that the signal and slots parameters must not
2660     contain any variable names, only the type. E.g. the following would
2661     not work and return false:
2662 
2663     \snippet code/src_corelib_kernel_qobject.cpp 23
2664 
2665     A signal can also be connected to another signal:
2666 
2667     \snippet code/src_corelib_kernel_qobject.cpp 24
2668 
2669     In this example, the \c MyWidget constructor relays a signal from
2670     a private member variable, and makes it available under a name
2671     that relates to \c MyWidget.
2672 
2673     A signal can be connected to many slots and signals. Many signals
2674     can be connected to one slot.
2675 
2676     If a signal is connected to several slots, the slots are activated
2677     in the same order in which the connections were made, when the
2678     signal is emitted.
2679 
2680     The function returns a QMetaObject::Connection that represents
2681     a handle to a connection if it successfully
2682     connects the signal to the slot. The connection handle will be invalid
2683     if it cannot create the connection, for example, if QObject is unable
2684     to verify the existence of either \a signal or \a method, or if their
2685     signatures aren't compatible.
2686     You can check if the handle is valid by casting it to a bool.
2687 
2688     By default, a signal is emitted for every connection you make;
2689     two signals are emitted for duplicate connections. You can break
2690     all of these connections with a single disconnect() call.
2691     If you pass the Qt::UniqueConnection \a type, the connection will only
2692     be made if it is not a duplicate. If there is already a duplicate
2693     (exact same signal to the exact same slot on the same objects),
2694     the connection will fail and connect will return an invalid QMetaObject::Connection.
2695 
2696     \note Qt::UniqueConnections do not work for lambdas, non-member functions
2697     and functors; they only apply to connecting to member functions.
2698 
2699     The optional \a type parameter describes the type of connection
2700     to establish. In particular, it determines whether a particular
2701     signal is delivered to a slot immediately or queued for delivery
2702     at a later time. If the signal is queued, the parameters must be
2703     of types that are known to Qt's meta-object system, because Qt
2704     needs to copy the arguments to store them in an event behind the
2705     scenes. If you try to use a queued connection and get the error
2706     message
2707 
2708     \snippet code/src_corelib_kernel_qobject.cpp 25
2709 
2710     call qRegisterMetaType() to register the data type before you
2711     establish the connection.
2712 
2713     \sa disconnect(), sender(), qRegisterMetaType(), Q_DECLARE_METATYPE(),
2714     {Differences between String-Based and Functor-Based Connections}
2715 */
2716 QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal,
2717                                      const QObject *receiver, const char *method,
2718                                      Qt::ConnectionType type)
2719 {
2720     if (sender == nullptr || receiver == nullptr || signal == nullptr || method == nullptr) {
2721         qWarning("QObject::connect: Cannot connect %s::%s to %s::%s",
2722                  sender ? sender->metaObject()->className() : "(nullptr)",
2723                  (signal && *signal) ? signal+1 : "(nullptr)",
2724                  receiver ? receiver->metaObject()->className() : "(nullptr)",
2725                  (method && *method) ? method+1 : "(nullptr)");
2726         return QMetaObject::Connection(nullptr);
2727     }
2728     QByteArray tmp_signal_name;
2729 
2730     if (!check_signal_macro(sender, signal, "connect", "bind"))
2731         return QMetaObject::Connection(nullptr);
2732     const QMetaObject *smeta = sender->metaObject();
2733     const char *signal_arg = signal;
2734     ++signal; //skip code
2735     QArgumentTypeArray signalTypes;
2736     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
2737     QByteArray signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2738     int signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2739             &smeta, signalName, signalTypes.size(), signalTypes.constData());
2740     if (signal_index < 0) {
2741         // check for normalized signatures
2742         tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
2743         signal = tmp_signal_name.constData() + 1;
2744 
2745         signalTypes.clear();
2746         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2747         smeta = sender->metaObject();
2748         signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2749                 &smeta, signalName, signalTypes.size(), signalTypes.constData());
2750     }
2751     if (signal_index < 0) {
2752         err_method_notfound(sender, signal_arg, "connect");
2753         err_info_about_objects("connect", sender, receiver);
2754         return QMetaObject::Connection(nullptr);
2755     }
2756     signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
2757     signal_index += QMetaObjectPrivate::signalOffset(smeta);
2758 
2759     QByteArray tmp_method_name;
2760     int membcode = extract_code(method);
2761 
2762     if (!check_method_code(membcode, receiver, method, "connect"))
2763         return QMetaObject::Connection(nullptr);
2764     const char *method_arg = method;
2765     ++method; // skip code
2766 
2767     QArgumentTypeArray methodTypes;
2768     QByteArray methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2769     const QMetaObject *rmeta = receiver->metaObject();
2770     int method_index_relative = -1;
2771     Q_ASSERT(QMetaObjectPrivate::get(rmeta)->revision >= 7);
2772     switch (membcode) {
2773     case QSLOT_CODE:
2774         method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2775                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2776         break;
2777     case QSIGNAL_CODE:
2778         method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2779                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2780         break;
2781     }
2782     if (method_index_relative < 0) {
2783         // check for normalized methods
2784         tmp_method_name = QMetaObject::normalizedSignature(method);
2785         method = tmp_method_name.constData();
2786 
2787         methodTypes.clear();
2788         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2789         // rmeta may have been modified above
2790         rmeta = receiver->metaObject();
2791         switch (membcode) {
2792         case QSLOT_CODE:
2793             method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2794                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2795             break;
2796         case QSIGNAL_CODE:
2797             method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2798                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2799             break;
2800         }
2801     }
2802 
2803     if (method_index_relative < 0) {
2804         err_method_notfound(receiver, method_arg, "connect");
2805         err_info_about_objects("connect", sender, receiver);
2806         return QMetaObject::Connection(nullptr);
2807     }
2808 
2809     if (!QMetaObjectPrivate::checkConnectArgs(signalTypes.size(), signalTypes.constData(),
2810                                               methodTypes.size(), methodTypes.constData())) {
2811         qWarning("QObject::connect: Incompatible sender/receiver arguments"
2812                  "\n        %s::%s --> %s::%s",
2813                  sender->metaObject()->className(), signal,
2814                  receiver->metaObject()->className(), method);
2815         return QMetaObject::Connection(nullptr);
2816     }
2817 
2818     int *types = nullptr;
2819     if ((type == Qt::QueuedConnection)
2820             && !(types = queuedConnectionTypes(signalTypes.constData(), signalTypes.size()))) {
2821         return QMetaObject::Connection(nullptr);
2822     }
2823 
2824 #ifndef QT_NO_DEBUG
2825     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
2826     QMetaMethod rmethod = rmeta->method(method_index_relative + rmeta->methodOffset());
2827     check_and_warn_compat(smeta, smethod, rmeta, rmethod);
2828 #endif
2829     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2830         sender, signal_index, smeta, receiver, method_index_relative, rmeta ,type, types));
2831     return handle;
2832 }
2833 
2834 /*!
2835     \since 4.8
2836 
2837     Creates a connection of the given \a type from the \a signal in
2838     the \a sender object to the \a method in the \a receiver object.
2839     Returns a handle to the connection that can be used to disconnect
2840     it later.
2841 
2842     The Connection handle will be invalid  if it cannot create the
2843     connection, for example, the parameters were invalid.
2844     You can check if the QMetaObject::Connection is valid by casting it to a bool.
2845 
2846     This function works in the same way as
2847     \c {connect(const QObject *sender, const char *signal,
2848             const QObject *receiver, const char *method,
2849             Qt::ConnectionType type)}
2850     but it uses QMetaMethod to specify signal and method.
2851 
2852     \sa connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)
2853  */
2854 QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal,
2855                                      const QObject *receiver, const QMetaMethod &method,
2856                                      Qt::ConnectionType type)
2857 {
2858     if (sender == nullptr
2859             || receiver == nullptr
2860             || signal.methodType() != QMetaMethod::Signal
2861             || method.methodType() == QMetaMethod::Constructor) {
2862         qWarning("QObject::connect: Cannot connect %s::%s to %s::%s",
2863                  sender ? sender->metaObject()->className() : "(nullptr)",
2864                  signal.methodSignature().constData(),
2865                  receiver ? receiver->metaObject()->className() : "(nullptr)",
2866                  method.methodSignature().constData() );
2867         return QMetaObject::Connection(nullptr);
2868     }
2869 
2870     int signal_index;
2871     int method_index;
2872     {
2873         int dummy;
2874         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
2875         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
2876     }
2877 
2878     const QMetaObject *smeta = sender->metaObject();
2879     const QMetaObject *rmeta = receiver->metaObject();
2880     if (signal_index == -1) {
2881         qWarning("QObject::connect: Can't find signal %s on instance of class %s",
2882                  signal.methodSignature().constData(), smeta->className());
2883         return QMetaObject::Connection(nullptr);
2884     }
2885     if (method_index == -1) {
2886         qWarning("QObject::connect: Can't find method %s on instance of class %s",
2887                  method.methodSignature().constData(), rmeta->className());
2888         return QMetaObject::Connection(nullptr);
2889     }
2890 
2891     if (!QMetaObject::checkConnectArgs(signal.methodSignature().constData(), method.methodSignature().constData())) {
2892         qWarning("QObject::connect: Incompatible sender/receiver arguments"
2893                  "\n        %s::%s --> %s::%s",
2894                  smeta->className(), signal.methodSignature().constData(),
2895                  rmeta->className(), method.methodSignature().constData());
2896         return QMetaObject::Connection(nullptr);
2897     }
2898 
2899     int *types = nullptr;
2900     if ((type == Qt::QueuedConnection)
2901             && !(types = queuedConnectionTypes(signal.parameterTypes())))
2902         return QMetaObject::Connection(nullptr);
2903 
2904 #ifndef QT_NO_DEBUG
2905     check_and_warn_compat(smeta, signal, rmeta, method);
2906 #endif
2907     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2908         sender, signal_index, signal.enclosingMetaObject(), receiver, method_index, nullptr, type, types));
2909     return handle;
2910 }
2911 
2912 /*!
2913     \fn bool QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const
2914     \overload connect()
2915     \threadsafe
2916 
2917     Connects \a signal from the \a sender object to this object's \a
2918     method.
2919 
2920     Equivalent to connect(\a sender, \a signal, \c this, \a method, \a type).
2921 
2922     Every connection you make emits a signal, so duplicate connections emit
2923     two signals. You can break a connection using disconnect().
2924 
2925     \sa disconnect()
2926 */
2927 
2928 /*!
2929     \threadsafe
2930 
2931     Disconnects \a signal in object \a sender from \a method in object
2932     \a receiver. Returns \c true if the connection is successfully broken;
2933     otherwise returns \c false.
2934 
2935     A signal-slot connection is removed when either of the objects
2936     involved are destroyed.
2937 
2938     disconnect() is typically used in three ways, as the following
2939     examples demonstrate.
2940     \list 1
2941     \li Disconnect everything connected to an object's signals:
2942 
2943        \snippet code/src_corelib_kernel_qobject.cpp 26
2944 
2945        equivalent to the non-static overloaded function
2946 
2947        \snippet code/src_corelib_kernel_qobject.cpp 27
2948 
2949     \li Disconnect everything connected to a specific signal:
2950 
2951        \snippet code/src_corelib_kernel_qobject.cpp 28
2952 
2953        equivalent to the non-static overloaded function
2954 
2955        \snippet code/src_corelib_kernel_qobject.cpp 29
2956 
2957     \li Disconnect a specific receiver:
2958 
2959        \snippet code/src_corelib_kernel_qobject.cpp 30
2960 
2961        equivalent to the non-static overloaded function
2962 
2963        \snippet code/src_corelib_kernel_qobject.cpp 31
2964 
2965     \endlist
2966 
2967     \nullptr may be used as a wildcard, meaning "any signal", "any receiving
2968     object", or "any slot in the receiving object", respectively.
2969 
2970     The \a sender may never be \nullptr. (You cannot disconnect signals
2971     from more than one object in a single call.)
2972 
2973     If \a signal is \nullptr, it disconnects \a receiver and \a method from
2974     any signal. If not, only the specified signal is disconnected.
2975 
2976     If \a receiver is \nullptr, it disconnects anything connected to \a
2977     signal. If not, slots in objects other than \a receiver are not
2978     disconnected.
2979 
2980     If \a method is \nullptr, it disconnects anything that is connected to \a
2981     receiver. If not, only slots named \a method will be disconnected,
2982     and all other slots are left alone. The \a method must be \nullptr
2983     if \a receiver is left out, so you cannot disconnect a
2984     specifically-named slot on all objects.
2985 
2986     \sa connect()
2987 */
2988 bool QObject::disconnect(const QObject *sender, const char *signal,
2989                          const QObject *receiver, const char *method)
2990 {
2991     if (sender == nullptr || (receiver == nullptr && method != nullptr)) {
2992         qWarning("QObject::disconnect: Unexpected nullptr parameter");
2993         return false;
2994     }
2995 
2996     const char *signal_arg = signal;
2997     QByteArray signal_name;
2998     bool signal_found = false;
2999     if (signal) {
3000         QT_TRY {
3001             signal_name = QMetaObject::normalizedSignature(signal);
3002             signal = signal_name.constData();
3003         } QT_CATCH (const std::bad_alloc &) {
3004             // if the signal is already normalized, we can continue.
3005             if (sender->metaObject()->indexOfSignal(signal + 1) == -1)
3006                 QT_RETHROW;
3007         }
3008 
3009         if (!check_signal_macro(sender, signal, "disconnect", "unbind"))
3010             return false;
3011         signal++; // skip code
3012     }
3013 
3014     QByteArray method_name;
3015     const char *method_arg = method;
3016     int membcode = -1;
3017     bool method_found = false;
3018     if (method) {
3019         QT_TRY {
3020             method_name = QMetaObject::normalizedSignature(method);
3021             method = method_name.constData();
3022         } QT_CATCH(const std::bad_alloc &) {
3023             // if the method is already normalized, we can continue.
3024             if (receiver->metaObject()->indexOfMethod(method + 1) == -1)
3025                 QT_RETHROW;
3026         }
3027 
3028         membcode = extract_code(method);
3029         if (!check_method_code(membcode, receiver, method, "disconnect"))
3030             return false;
3031         method++; // skip code
3032     }
3033 
3034     /* We now iterate through all the sender's and receiver's meta
3035      * objects in order to also disconnect possibly shadowed signals
3036      * and slots with the same signature.
3037     */
3038     bool res = false;
3039     const QMetaObject *smeta = sender->metaObject();
3040     QByteArray signalName;
3041     QArgumentTypeArray signalTypes;
3042     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
3043     if (signal)
3044         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
3045     QByteArray methodName;
3046     QArgumentTypeArray methodTypes;
3047     Q_ASSERT(!receiver || QMetaObjectPrivate::get(receiver->metaObject())->revision >= 7);
3048     if (method)
3049         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
3050     do {
3051         int signal_index = -1;
3052         if (signal) {
3053             signal_index = QMetaObjectPrivate::indexOfSignalRelative(
3054                         &smeta, signalName, signalTypes.size(), signalTypes.constData());
3055             if (signal_index < 0)
3056                 break;
3057             signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
3058             signal_index += QMetaObjectPrivate::signalOffset(smeta);
3059             signal_found = true;
3060         }
3061 
3062         if (!method) {
3063             res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, -1, nullptr);
3064         } else {
3065             const QMetaObject *rmeta = receiver->metaObject();
3066             do {
3067                 int method_index = QMetaObjectPrivate::indexOfMethod(
3068                             rmeta, methodName, methodTypes.size(), methodTypes.constData());
3069                 if (method_index >= 0)
3070                     while (method_index < rmeta->methodOffset())
3071                             rmeta = rmeta->superClass();
3072                 if (method_index < 0)
3073                     break;
3074                 res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, method_index, nullptr);
3075                 method_found = true;
3076             } while ((rmeta = rmeta->superClass()));
3077         }
3078     } while (signal && (smeta = smeta->superClass()));
3079 
3080     if (signal && !signal_found) {
3081         err_method_notfound(sender, signal_arg, "disconnect");
3082         err_info_about_objects("disconnect", sender, receiver);
3083     } else if (method && !method_found) {
3084         err_method_notfound(receiver, method_arg, "disconnect");
3085         err_info_about_objects("disconnect", sender, receiver);
3086     }
3087     if (res) {
3088         if (!signal)
3089             const_cast<QObject*>(sender)->disconnectNotify(QMetaMethod());
3090     }
3091     return res;
3092 }
3093 
3094 /*!
3095     \since 4.8
3096 
3097     Disconnects \a signal in object \a sender from \a method in object
3098     \a receiver. Returns \c true if the connection is successfully broken;
3099     otherwise returns \c false.
3100 
3101     This function provides the same possibilities like
3102     \c {disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method) }
3103     but uses QMetaMethod to represent the signal and the method to be disconnected.
3104 
3105     Additionally this function returns false and no signals and slots disconnected
3106     if:
3107     \list 1
3108 
3109         \li \a signal is not a member of sender class or one of its parent classes.
3110 
3111         \li \a method is not a member of receiver class or one of its parent classes.
3112 
3113         \li \a signal instance represents not a signal.
3114 
3115     \endlist
3116 
3117     QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object".
3118     In the same way \nullptr can be used for \a receiver in the meaning "any receiving object".
3119     In this case method should also be QMetaMethod(). \a sender parameter should be never \nullptr.
3120 
3121     \sa disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
3122  */
3123 bool QObject::disconnect(const QObject *sender, const QMetaMethod &signal,
3124                          const QObject *receiver, const QMetaMethod &method)
3125 {
3126     if (sender == nullptr || (receiver == nullptr && method.mobj != nullptr)) {
3127         qWarning("QObject::disconnect: Unexpected nullptr parameter");
3128         return false;
3129     }
3130     if (signal.mobj) {
3131         if(signal.methodType() != QMetaMethod::Signal) {
3132             qWarning("QObject::%s: Attempt to %s non-signal %s::%s",
3133                      "disconnect","unbind",
3134                      sender->metaObject()->className(), signal.methodSignature().constData());
3135             return false;
3136         }
3137     }
3138     if (method.mobj) {
3139         if(method.methodType() == QMetaMethod::Constructor) {
3140             qWarning("QObject::disconnect: cannot use constructor as argument %s::%s",
3141                      receiver->metaObject()->className(), method.methodSignature().constData());
3142             return false;
3143         }
3144     }
3145 
3146     // Reconstructing SIGNAL() macro result for signal.methodSignature() string
3147     QByteArray signalSignature;
3148     if (signal.mobj) {
3149         signalSignature.reserve(signal.methodSignature().size()+1);
3150         signalSignature.append((char)(QSIGNAL_CODE + '0'));
3151         signalSignature.append(signal.methodSignature());
3152     }
3153 
3154     int signal_index;
3155     int method_index;
3156     {
3157         int dummy;
3158         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
3159         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
3160     }
3161     // If we are here sender is not nullptr. If signal is not nullptr while signal_index
3162     // is -1 then this signal is not a member of sender.
3163     if (signal.mobj && signal_index == -1) {
3164         qWarning("QObject::disconnect: signal %s not found on class %s",
3165                  signal.methodSignature().constData(), sender->metaObject()->className());
3166         return false;
3167     }
3168     // If this condition is true then method is not a member of receiver.
3169     if (receiver && method.mobj && method_index == -1) {
3170         qWarning("QObject::disconnect: method %s not found on class %s",
3171                  method.methodSignature().constData(), receiver->metaObject()->className());
3172         return false;
3173     }
3174 
3175     if (!QMetaObjectPrivate::disconnect(sender, signal_index, signal.mobj, receiver, method_index, nullptr))
3176         return false;
3177 
3178     if (!signal.isValid()) {
3179         // The signal is a wildcard, meaning all signals were disconnected.
3180         // QMetaObjectPrivate::disconnect() doesn't call disconnectNotify()
3181         // per connection in this case. Call it once now, with an invalid
3182         // QMetaMethod as argument, as documented.
3183         const_cast<QObject*>(sender)->disconnectNotify(signal);
3184     }
3185     return true;
3186 }
3187 
3188 /*!
3189     \threadsafe
3190 
3191     \fn bool QObject::disconnect(const char *signal, const QObject *receiver, const char *method) const
3192     \overload disconnect()
3193 
3194     Disconnects \a signal from \a method of \a receiver.
3195 
3196     A signal-slot connection is removed when either of the objects
3197     involved are destroyed.
3198 */
3199 
3200 /*!
3201     \fn bool QObject::disconnect(const QObject *receiver, const char *method) const
3202     \overload disconnect()
3203 
3204     Disconnects all signals in this object from \a receiver's \a
3205     method.
3206 
3207     A signal-slot connection is removed when either of the objects
3208     involved are destroyed.
3209 */
3210 
3211 
3212 /*!
3213     \since 5.0
3214 
3215     This virtual function is called when something has been connected
3216     to \a signal in this object.
3217 
3218     If you want to compare \a signal with a specific signal, you can
3219     use QMetaMethod::fromSignal() as follows:
3220 
3221     \snippet code/src_corelib_kernel_qobject.cpp 32
3222 
3223     \warning This function violates the object-oriented principle of
3224     modularity. However, it might be useful when you need to perform
3225     expensive initialization only if something is connected to a
3226     signal.
3227 
3228     \warning This function is called from the thread which performs the
3229     connection, which may be a different thread from the thread in
3230     which this object lives.
3231 
3232     \sa connect(), disconnectNotify()
3233 */
3234 
3235 void QObject::connectNotify(const QMetaMethod &signal)
3236 {
3237     Q_UNUSED(signal);
3238 }
3239 
3240 /*!
3241     \since 5.0
3242 
3243     This virtual function is called when something has been
3244     disconnected from \a signal in this object.
3245 
3246     See connectNotify() for an example of how to compare
3247     \a signal with a specific signal.
3248 
3249     If all signals were disconnected from this object (e.g., the
3250     signal argument to disconnect() was \nullptr), disconnectNotify()
3251     is only called once, and the \a signal will be an invalid
3252     QMetaMethod (QMetaMethod::isValid() returns \c false).
3253 
3254     \warning This function violates the object-oriented principle of
3255     modularity. However, it might be useful for optimizing access to
3256     expensive resources.
3257 
3258     \warning This function is called from the thread which performs the
3259     disconnection, which may be a different thread from the thread in
3260     which this object lives. This function may also be called with a QObject
3261     internal mutex locked. It is therefore not allowed to re-enter any
3262     of any QObject functions from your reimplementation and if you lock
3263     a mutex in your reimplementation, make sure that you don't call QObject
3264     functions with that mutex held in other places or it will result in
3265     a deadlock.
3266 
3267     \sa disconnect(), connectNotify()
3268 */
3269 
3270 void QObject::disconnectNotify(const QMetaMethod &signal)
3271 {
3272     Q_UNUSED(signal);
3273 }
3274 
3275 /*
3276     \internal
3277     convert a signal index from the method range to the signal range
3278  */
3279 static int methodIndexToSignalIndex(const QMetaObject **base, int signal_index)
3280 {
3281     if (signal_index < 0)
3282         return signal_index;
3283     const QMetaObject *metaObject = *base;
3284     while (metaObject && metaObject->methodOffset() > signal_index)
3285         metaObject = metaObject->superClass();
3286 
3287     if (metaObject) {
3288         int signalOffset, methodOffset;
3289         computeOffsets(metaObject, &signalOffset, &methodOffset);
3290         if (signal_index < metaObject->methodCount())
3291             signal_index = QMetaObjectPrivate::originalClone(metaObject, signal_index - methodOffset) + signalOffset;
3292         else
3293             signal_index = signal_index - methodOffset + signalOffset;
3294         *base = metaObject;
3295     }
3296     return signal_index;
3297 }
3298 
3299 /*!
3300    \internal
3301    \a types is a 0-terminated vector of meta types for queued
3302    connections.
3303 
3304    if \a signal_index is -1, then we effectively connect *all* signals
3305    from the sender to the receiver's slot
3306  */
3307 QMetaObject::Connection QMetaObject::connect(const QObject *sender, int signal_index,
3308                                           const QObject *receiver, int method_index, int type, int *types)
3309 {
3310     const QMetaObject *smeta = sender->metaObject();
3311     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3312     return Connection(QMetaObjectPrivate::connect(sender, signal_index, smeta,
3313                                        receiver, method_index,
3314                                        nullptr, //FIXME, we could speed this connection up by computing the relative index
3315                                        type, types));
3316 }
3317 
3318 /*!
3319     \internal
3320    Same as the QMetaObject::connect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3321 
3322     method_index is relative to the rmeta metaobject, if rmeta is \nullptr, then it is absolute index
3323 
3324     the QObjectPrivate::Connection* has a refcount of 2, so it must be passed to a QMetaObject::Connection
3325  */
3326 QObjectPrivate::Connection *QMetaObjectPrivate::connect(const QObject *sender,
3327                                  int signal_index, const QMetaObject *smeta,
3328                                  const QObject *receiver, int method_index,
3329                                  const QMetaObject *rmeta, int type, int *types)
3330 {
3331     QObject *s = const_cast<QObject *>(sender);
3332     QObject *r = const_cast<QObject *>(receiver);
3333 
3334     int method_offset = rmeta ? rmeta->methodOffset() : 0;
3335     Q_ASSERT(!rmeta || QMetaObjectPrivate::get(rmeta)->revision >= 6);
3336     QObjectPrivate::StaticMetaCallFunction callFunction = rmeta ? rmeta->d.static_metacall : nullptr;
3337 
3338     QOrderedMutexLocker locker(signalSlotLock(sender),
3339                                signalSlotLock(receiver));
3340 
3341     QObjectPrivate::ConnectionData *scd  = QObjectPrivate::get(s)->connections.loadRelaxed();
3342     if (type & Qt::UniqueConnection && scd) {
3343         if (scd->signalVectorCount() > signal_index) {
3344             const QObjectPrivate::Connection *c2 = scd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
3345 
3346             int method_index_absolute = method_index + method_offset;
3347 
3348             while (c2) {
3349                 if (!c2->isSlotObject && c2->receiver.loadRelaxed() == receiver && c2->method() == method_index_absolute)
3350                     return nullptr;
3351                 c2 = c2->nextConnectionList.loadRelaxed();
3352             }
3353         }
3354     }
3355     type &= ~Qt::UniqueConnection;
3356 
3357     const bool isSingleShot = type & Qt::SingleShotConnection;
3358     type &= ~Qt::SingleShotConnection;
3359 
3360     Q_ASSERT(type >= 0);
3361     Q_ASSERT(type <= 3);
3362 
3363     std::unique_ptr<QObjectPrivate::Connection> c{new QObjectPrivate::Connection};
3364     c->sender = s;
3365     c->signal_index = signal_index;
3366     c->receiver.storeRelaxed(r);
3367     QThreadData *td = r->d_func()->threadData;
3368     td->ref();
3369     c->receiverThreadData.storeRelaxed(td);
3370     c->method_relative = method_index;
3371     c->method_offset = method_offset;
3372     c->connectionType = type;
3373     c->isSlotObject = false;
3374     c->argumentTypes.storeRelaxed(types);
3375     c->callFunction = callFunction;
3376     c->isSingleShot = isSingleShot;
3377 
3378     QObjectPrivate::get(s)->addConnection(signal_index, c.get());
3379 
3380     locker.unlock();
3381     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3382     if (smethod.isValid())
3383         s->connectNotify(smethod);
3384 
3385     return c.release();
3386 }
3387 
3388 /*!
3389     \internal
3390  */
3391 bool QMetaObject::disconnect(const QObject *sender, int signal_index,
3392                              const QObject *receiver, int method_index)
3393 {
3394     const QMetaObject *smeta = sender->metaObject();
3395     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3396     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3397                                           receiver, method_index, nullptr);
3398 }
3399 
3400 /*!
3401     \internal
3402 
3403 Disconnect a single signal connection.  If QMetaObject::connect() has been called
3404 multiple times for the same sender, signal_index, receiver and method_index only
3405 one of these connections will be removed.
3406  */
3407 bool QMetaObject::disconnectOne(const QObject *sender, int signal_index,
3408                                 const QObject *receiver, int method_index)
3409 {
3410     const QMetaObject *smeta = sender->metaObject();
3411     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3412     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3413                                           receiver, method_index, nullptr,
3414                                           QMetaObjectPrivate::DisconnectOne);
3415 }
3416 
3417 /*!
3418     \internal
3419     Helper function to remove the connection from the senders list and set the receivers to \nullptr
3420  */
3421 bool QMetaObjectPrivate::disconnectHelper(QObjectPrivate::ConnectionData *connections, int signalIndex,
3422                                           const QObject *receiver, int method_index, void **slot,
3423                                           QBasicMutex *senderMutex, DisconnectType disconnectType)
3424 {
3425     bool success = false;
3426 
3427     auto &connectionList = connections->connectionsForSignal(signalIndex);
3428     auto *c = connectionList.first.loadRelaxed();
3429     while (c) {
3430         QObject *r = c->receiver.loadRelaxed();
3431         if (r && (receiver == nullptr || (r == receiver
3432                            && (method_index < 0 || (!c->isSlotObject && c->method() == method_index))
3433                            && (slot == nullptr || (c->isSlotObject && c->slotObj->compare(slot)))))) {
3434             bool needToUnlock = false;
3435             QBasicMutex *receiverMutex = nullptr;
3436             if (r) {
3437                 receiverMutex = signalSlotLock(r);
3438                 // need to relock this receiver and sender in the correct order
3439                 needToUnlock = QOrderedMutexLocker::relock(senderMutex, receiverMutex);
3440             }
3441             if (c->receiver.loadRelaxed())
3442                 connections->removeConnection(c);
3443 
3444             if (needToUnlock)
3445                 receiverMutex->unlock();
3446 
3447             success = true;
3448 
3449             if (disconnectType == DisconnectOne)
3450                 return success;
3451         }
3452         c = c->nextConnectionList.loadRelaxed();
3453     }
3454     return success;
3455 }
3456 
3457 /*!
3458     \internal
3459     Same as the QMetaObject::disconnect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3460  */
3461 bool QMetaObjectPrivate::disconnect(const QObject *sender,
3462                                     int signal_index, const QMetaObject *smeta,
3463                                     const QObject *receiver, int method_index, void **slot,
3464                                     DisconnectType disconnectType)
3465 {
3466     if (!sender)
3467         return false;
3468 
3469     QObject *s = const_cast<QObject *>(sender);
3470 
3471     QBasicMutex *senderMutex = signalSlotLock(sender);
3472     QBasicMutexLocker locker(senderMutex);
3473 
3474     QObjectPrivate::ConnectionData *scd  = QObjectPrivate::get(s)->connections.loadRelaxed();
3475     if (!scd)
3476         return false;
3477 
3478     bool success = false;
3479     {
3480         // prevent incoming connections changing the connections->receivers while unlocked
3481         QObjectPrivate::ConnectionDataPointer connections(scd);
3482 
3483         if (signal_index < 0) {
3484             // remove from all connection lists
3485             for (int sig_index = -1; sig_index < scd->signalVectorCount(); ++sig_index) {
3486                 if (disconnectHelper(connections.data(), sig_index, receiver, method_index, slot, senderMutex, disconnectType))
3487                     success = true;
3488             }
3489         } else if (signal_index < scd->signalVectorCount()) {
3490             if (disconnectHelper(connections.data(), signal_index, receiver, method_index, slot, senderMutex, disconnectType))
3491                 success = true;
3492         }
3493     }
3494 
3495     locker.unlock();
3496     if (success) {
3497         scd->cleanOrphanedConnections(s);
3498 
3499         QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3500         if (smethod.isValid())
3501             s->disconnectNotify(smethod);
3502     }
3503 
3504     return success;
3505 }
3506 
3507 // Helpers for formatting the connect statements of connectSlotsByName()'s debug mode
3508 static QByteArray formatConnectionSignature(const char *className, const QMetaMethod &method)
3509 {
3510     const auto signature = method.methodSignature();
3511     Q_ASSERT(signature.endsWith(')'));
3512     const int openParen = signature.indexOf('(');
3513     const bool hasParameters = openParen >= 0 && openParen < signature.size() - 2;
3514     QByteArray result;
3515     if (hasParameters) {
3516         result += "qOverload<"
3517             + signature.mid(openParen + 1, signature.size() - openParen - 2) + ">(";
3518     }
3519     result += '&';
3520     result += className + QByteArrayLiteral("::") + method.name();
3521     if (hasParameters)
3522         result += ')';
3523     return result;
3524 }
3525 
3526 static QByteArray msgConnect(const QMetaObject *senderMo, const QByteArray &senderName,
3527                              const QMetaMethod &signal, const QObject *receiver, int receiverIndex)
3528 {
3529     const auto receiverMo = receiver->metaObject();
3530     const auto slot = receiverMo->method(receiverIndex);
3531     QByteArray message = QByteArrayLiteral("QObject::connect(")
3532         + senderName + ", " + formatConnectionSignature(senderMo->className(), signal)
3533         + ", " + receiver->objectName().toLatin1() + ", "
3534         + formatConnectionSignature(receiverMo->className(), slot) + ");";
3535     return message;
3536 }
3537 
3538 /*!
3539     \fn void QMetaObject::connectSlotsByName(QObject *object)
3540 
3541     Searches recursively for all child objects of the given \a object, and connects
3542     matching signals from them to slots of \a object that follow the following form:
3543 
3544     \snippet code/src_corelib_kernel_qobject.cpp 33
3545 
3546     Let's assume our object has a child object of type \c{QPushButton} with
3547     the \l{QObject::objectName}{object name} \c{button1}. The slot to catch the
3548     button's \c{clicked()} signal would be:
3549 
3550     \snippet code/src_corelib_kernel_qobject.cpp 34
3551 
3552     If \a object itself has a properly set object name, its own signals are also
3553     connected to its respective slots.
3554 
3555     \sa QObject::setObjectName()
3556  */
3557 void QMetaObject::connectSlotsByName(QObject *o)
3558 {
3559     if (!o)
3560         return;
3561     const QMetaObject *mo = o->metaObject();
3562     Q_ASSERT(mo);
3563     const QObjectList list = // list of all objects to look for matching signals including...
3564             o->findChildren<QObject *>(QString()) // all children of 'o'...
3565             << o; // and the object 'o' itself
3566 
3567     // for each method/slot of o ...
3568     for (int i = 0; i < mo->methodCount(); ++i) {
3569         const QByteArray slotSignature = mo->method(i).methodSignature();
3570         const char *slot = slotSignature.constData();
3571         Q_ASSERT(slot);
3572 
3573         // ...that starts with "on_", ...
3574         if (slot[0] != 'o' || slot[1] != 'n' || slot[2] != '_')
3575             continue;
3576 
3577         // ...we check each object in our list, ...
3578         bool foundIt = false;
3579         for(int j = 0; j < list.count(); ++j) {
3580             const QObject *co = list.at(j);
3581             const QByteArray coName = co->objectName().toLatin1();
3582 
3583             // ...discarding those whose objectName is not fitting the pattern "on_<objectName>_...", ...
3584             if (coName.isEmpty() || qstrncmp(slot + 3, coName.constData(), coName.size()) || slot[coName.size()+3] != '_')
3585                 continue;
3586 
3587             const char *signal = slot + coName.size() + 4; // the 'signal' part of the slot name
3588 
3589             // ...for the presence of a matching signal "on_<objectName>_<signal>".
3590             const QMetaObject *smeta;
3591             int sigIndex = co->d_func()->signalIndex(signal, &smeta);
3592             if (sigIndex < 0) {
3593                 // if no exactly fitting signal (name + complete parameter type list) could be found
3594                 // look for just any signal with the correct name and at least the slot's parameter list.
3595                 // Note: if more than one of those signals exist, the one that gets connected is
3596                 // chosen 'at random' (order of declaration in source file)
3597                 QList<QByteArray> compatibleSignals;
3598                 const QMetaObject *smo = co->metaObject();
3599                 int sigLen = qstrlen(signal) - 1; // ignore the trailing ')'
3600                 for (int k = QMetaObjectPrivate::absoluteSignalCount(smo)-1; k >= 0; --k) {
3601                     const QMetaMethod method = QMetaObjectPrivate::signal(smo, k);
3602                     if (!qstrncmp(method.methodSignature().constData(), signal, sigLen)) {
3603                         smeta = method.enclosingMetaObject();
3604                         sigIndex = k;
3605                         compatibleSignals.prepend(method.methodSignature());
3606                     }
3607                 }
3608                 if (compatibleSignals.size() > 1)
3609                     qWarning() << "QMetaObject::connectSlotsByName: Connecting slot" << slot
3610                                << "with the first of the following compatible signals:" << compatibleSignals;
3611             }
3612 
3613             if (sigIndex < 0)
3614                 continue;
3615 
3616             // we connect it...
3617             if (Connection(QMetaObjectPrivate::connect(co, sigIndex, smeta, o, i))) {
3618                 foundIt = true;
3619                 qCDebug(lcConnections, "%s",
3620                         msgConnect(smeta, coName, QMetaObjectPrivate::signal(smeta, sigIndex), o,  i).constData());
3621                 // ...and stop looking for further objects with the same name.
3622                 // Note: the Designer will make sure each object name is unique in the above
3623                 // 'list' but other code may create two child objects with the same name. In
3624                 // this case one is chosen 'at random'.
3625                 break;
3626             }
3627         }
3628         if (foundIt) {
3629             // we found our slot, now skip all overloads
3630             while (mo->method(i + 1).attributes() & QMetaMethod::Cloned)
3631                   ++i;
3632         } else if (!(mo->method(i).attributes() & QMetaMethod::Cloned)) {
3633             // check if the slot has the following signature: "on_..._...(..."
3634             int iParen = slotSignature.indexOf('(');
3635             int iLastUnderscore = slotSignature.lastIndexOf('_', iParen-1);
3636             if (iLastUnderscore > 3)
3637                 qWarning("QMetaObject::connectSlotsByName: No matching signal for %s", slot);
3638         }
3639     }
3640 }
3641 
3642 namespace {
3643 /*!
3644     \internal
3645 */
3646 class QSingleShotConnectionHandler {
3647     QObjectPrivate::Connection *c;
3648     Q_DISABLE_COPY_MOVE(QSingleShotConnectionHandler)
3649 public:
3650     explicit QSingleShotConnectionHandler(QObjectPrivate::Connection *c) : c(c) {}
3651     ~QSingleShotConnectionHandler()
3652     {
3653         if (c->isSingleShot)
3654             QObjectPrivate::disconnect(c);
3655     }
3656 };
3657 
3658 } // anonymous namespace
3659 
3660 /*!
3661     \internal
3662 
3663     \a signal must be in the signal index range (see QObjectPrivate::signalIndex()).
3664 */
3665 static void queued_activate(QObject *sender, int signal, QObjectPrivate::Connection *c, void **argv)
3666 {
3667     const int *argumentTypes = c->argumentTypes.loadRelaxed();
3668     if (!argumentTypes) {
3669         QMetaMethod m = QMetaObjectPrivate::signal(sender->metaObject(), signal);
3670         argumentTypes = queuedConnectionTypes(m.parameterTypes());
3671         if (!argumentTypes) // cannot queue arguments
3672             argumentTypes = &DIRECT_CONNECTION_ONLY;
3673         if (!c->argumentTypes.testAndSetOrdered(nullptr, argumentTypes)) {
3674             if (argumentTypes != &DIRECT_CONNECTION_ONLY)
3675                 delete [] argumentTypes;
3676             argumentTypes = c->argumentTypes.loadRelaxed();
3677         }
3678     }
3679     if (argumentTypes == &DIRECT_CONNECTION_ONLY) // cannot activate
3680         return;
3681     int nargs = 1; // include return type
3682     while (argumentTypes[nargs-1])
3683         ++nargs;
3684 
3685     QBasicMutexLocker locker(signalSlotLock(c->receiver.loadRelaxed()));
3686     if (!c->receiver.loadRelaxed()) {
3687         // the connection has been disconnected before we got the lock
3688         return;
3689     }
3690     if (c->isSlotObject)
3691         c->slotObj->ref();
3692     locker.unlock();
3693 
3694     QMetaCallEvent *ev = c->isSlotObject ?
3695         new QMetaCallEvent(c->slotObj, sender, signal, nargs) :
3696         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction, sender, signal, nargs);
3697 
3698     void **args = ev->args();
3699     int *types = ev->types();
3700 
3701     types[0] = 0; // return type
3702     args[0] = nullptr; // return value
3703 
3704     if (nargs > 1) {
3705         for (int n = 1; n < nargs; ++n)
3706             types[n] = argumentTypes[n-1];
3707 
3708         for (int n = 1; n < nargs; ++n)
3709             args[n] = QMetaType::create(types[n], argv[n]);
3710     }
3711 
3712     locker.relock();
3713     if (c->isSlotObject)
3714         c->slotObj->destroyIfLastRef();
3715     if (!c->receiver.loadRelaxed()) {
3716         // the connection has been disconnected while we were unlocked
3717         locker.unlock();
3718         delete ev;
3719         return;
3720     }
3721 
3722     QCoreApplication::postEvent(c->receiver.loadRelaxed(), ev);
3723 }
3724 
3725 template <bool callbacks_enabled>
3726 void doActivate(QObject *sender, int signal_index, void **argv)
3727 {
3728     QObjectPrivate *sp = QObjectPrivate::get(sender);
3729 
3730     if (sp->blockSig)
3731         return;
3732 
3733     Q_TRACE_SCOPE(QMetaObject_activate, sender, signal_index);
3734 
3735     if (sp->isDeclarativeSignalConnected(signal_index)
3736             && QAbstractDeclarativeData::signalEmitted) {
3737         Q_TRACE_SCOPE(QMetaObject_activate_declarative_signal, sender, signal_index);
3738         QAbstractDeclarativeData::signalEmitted(sp->declarativeData, sender,
3739                                                 signal_index, argv);
3740     }
3741 
3742     const QSignalSpyCallbackSet *signal_spy_set = callbacks_enabled ? qt_signal_spy_callback_set.loadAcquire() : nullptr;
3743 
3744     void *empty_argv[] = { nullptr };
3745     if (!argv)
3746         argv = empty_argv;
3747 
3748     if (!sp->maybeSignalConnected(signal_index)) {
3749         // The possible declarative connection is done, and nothing else is connected
3750         if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3751             signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3752         if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3753             signal_spy_set->signal_end_callback(sender, signal_index);
3754         return;
3755     }
3756 
3757     if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3758         signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3759 
3760     bool senderDeleted = false;
3761     {
3762     Q_ASSERT(sp->connections.loadAcquire());
3763     QObjectPrivate::ConnectionDataPointer connections(sp->connections.loadRelaxed());
3764     QObjectPrivate::SignalVector *signalVector = connections->signalVector.loadRelaxed();
3765 
3766     const QObjectPrivate::ConnectionList *list;
3767     if (signal_index < signalVector->count())
3768         list = &signalVector->at(signal_index);
3769     else
3770         list = &signalVector->at(-1);
3771 
3772     Qt::HANDLE currentThreadId = QThread::currentThreadId();
3773     bool inSenderThread = currentThreadId == QObjectPrivate::get(sender)->threadData.loadRelaxed()->threadId.loadRelaxed();
3774 
3775     // We need to check against the highest connection id to ensure that signals added
3776     // during the signal emission are not emitted in this emission.
3777     uint highestConnectionId = connections->currentConnectionId.loadRelaxed();
3778     do {
3779         QObjectPrivate::Connection *c = list->first.loadRelaxed();
3780         if (!c)
3781             continue;
3782 
3783         do {
3784             QObject * const receiver = c->receiver.loadRelaxed();
3785             if (!receiver)
3786                 continue;
3787 
3788             QThreadData *td = c->receiverThreadData.loadRelaxed();
3789             if (!td)
3790                 continue;
3791 
3792             bool receiverInSameThread;
3793             if (inSenderThread) {
3794                 receiverInSameThread = currentThreadId == td->threadId.loadRelaxed();
3795             } else {
3796                 // need to lock before reading the threadId, because moveToThread() could interfere
3797                 QMutexLocker lock(signalSlotLock(receiver));
3798                 receiverInSameThread = currentThreadId == td->threadId.loadRelaxed();
3799             }
3800 
3801             const QSingleShotConnectionHandler singleShotConnectionhandler(c);
3802 
3803             // determine if this connection should be sent immediately or
3804             // put into the event queue
3805             if ((c->connectionType == Qt::AutoConnection && !receiverInSameThread)
3806                 || (c->connectionType == Qt::QueuedConnection)) {
3807                 queued_activate(sender, signal_index, c, argv);
3808                 continue;
3809 #if QT_CONFIG(thread)
3810             } else if (c->connectionType == Qt::BlockingQueuedConnection) {
3811                 if (receiverInSameThread) {
3812                     qWarning("Qt: Dead lock detected while activating a BlockingQueuedConnection: "
3813                     "Sender is %s(%p), receiver is %s(%p)",
3814                     sender->metaObject()->className(), sender,
3815                     receiver->metaObject()->className(), receiver);
3816                 }
3817                 QSemaphore semaphore;
3818                 {
3819                     QBasicMutexLocker locker(signalSlotLock(sender));
3820                     if (!c->receiver.loadAcquire())
3821                         continue;
3822                     QMetaCallEvent *ev = c->isSlotObject ?
3823                         new QMetaCallEvent(c->slotObj, sender, signal_index, argv, &semaphore) :
3824                         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction,
3825                                            sender, signal_index, argv, &semaphore);
3826                     QCoreApplication::postEvent(receiver, ev);
3827                 }
3828                 semaphore.acquire();
3829                 continue;
3830 #endif
3831             }
3832 
3833             QObjectPrivate::Sender senderData(receiverInSameThread ? receiver : nullptr, sender, signal_index);
3834 
3835             if (c->isSlotObject) {
3836                 c->slotObj->ref();
3837 
3838                 struct Deleter {
3839                     void operator()(QtPrivate::QSlotObjectBase *slot) const {
3840                         if (slot) slot->destroyIfLastRef();
3841                     }
3842                 };
3843                 const std::unique_ptr<QtPrivate::QSlotObjectBase, Deleter> obj{c->slotObj};
3844 
3845                 {
3846                     Q_TRACE_SCOPE(QMetaObject_activate_slot_functor, obj.get());
3847                     obj->call(receiver, argv);
3848                 }
3849             } else if (c->callFunction && c->method_offset <= receiver->metaObject()->methodOffset()) {
3850                 //we compare the vtable to make sure we are not in the destructor of the object.
3851                 const int method_relative = c->method_relative;
3852                 const auto callFunction = c->callFunction;
3853                 const int methodIndex = (Q_HAS_TRACEPOINTS || callbacks_enabled) ? c->method() : 0;
3854                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr)
3855                     signal_spy_set->slot_begin_callback(receiver, methodIndex, argv);
3856 
3857                 {
3858                     Q_TRACE_SCOPE(QMetaObject_activate_slot, receiver, methodIndex);
3859                     callFunction(receiver, QMetaObject::InvokeMetaMethod, method_relative, argv);
3860                 }
3861 
3862                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3863                     signal_spy_set->slot_end_callback(receiver, methodIndex);
3864             } else {
3865                 const int method = c->method_relative + c->method_offset;
3866 
3867                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr) {
3868                     signal_spy_set->slot_begin_callback(receiver, method, argv);
3869                 }
3870 
3871                 {
3872                     Q_TRACE_SCOPE(QMetaObject_activate_slot, receiver, method);
3873                     QMetaObject::metacall(receiver, QMetaObject::InvokeMetaMethod, method, argv);
3874                 }
3875 
3876                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3877                     signal_spy_set->slot_end_callback(receiver, method);
3878             }
3879         } while ((c = c->nextConnectionList.loadRelaxed()) != nullptr && c->id <= highestConnectionId);
3880 
3881     } while (list != &signalVector->at(-1) &&
3882         //start over for all signals;
3883         ((list = &signalVector->at(-1)), true));
3884 
3885         if (connections->currentConnectionId.loadRelaxed() == 0)
3886             senderDeleted = true;
3887     }
3888     if (!senderDeleted) {
3889         sp->connections.loadRelaxed()->cleanOrphanedConnections(sender);
3890 
3891         if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3892             signal_spy_set->signal_end_callback(sender, signal_index);
3893     }
3894 }
3895 
3896 /*!
3897     \internal
3898  */
3899 void QMetaObject::activate(QObject *sender, const QMetaObject *m, int local_signal_index,
3900                            void **argv)
3901 {
3902     int signal_index = local_signal_index + QMetaObjectPrivate::signalOffset(m);
3903 
3904     if (Q_UNLIKELY(qt_signal_spy_callback_set.loadRelaxed()))
3905         doActivate<true>(sender, signal_index, argv);
3906     else
3907         doActivate<false>(sender, signal_index, argv);
3908 }
3909 
3910 /*!
3911     \internal
3912  */
3913 void QMetaObject::activate(QObject *sender, int signalOffset, int local_signal_index, void **argv)
3914 {
3915     int signal_index = signalOffset + local_signal_index;
3916 
3917     if (Q_UNLIKELY(qt_signal_spy_callback_set.loadRelaxed()))
3918         doActivate<true>(sender, signal_index, argv);
3919     else
3920         doActivate<false>(sender, signal_index, argv);
3921  }
3922 
3923 /*!
3924     \internal
3925    signal_index comes from indexOfMethod()
3926 */
3927 void QMetaObject::activate(QObject *sender, int signal_index, void **argv)
3928 {
3929     const QMetaObject *mo = sender->metaObject();
3930     while (mo->methodOffset() > signal_index)
3931         mo = mo->superClass();
3932     activate(sender, mo, signal_index - mo->methodOffset(), argv);
3933 }
3934 
3935 /*!
3936     \internal
3937     Returns the signal index used in the internal connections->receivers vector.
3938 
3939     It is different from QMetaObject::indexOfSignal():  indexOfSignal is the same as indexOfMethod
3940     while QObjectPrivate::signalIndex is smaller because it doesn't give index to slots.
3941 
3942     If \a meta is not \nullptr, it is set to the meta-object where the signal was found.
3943 */
3944 int QObjectPrivate::signalIndex(const char *signalName,
3945                                 const QMetaObject **meta) const
3946 {
3947     Q_Q(const QObject);
3948     const QMetaObject *base = q->metaObject();
3949     Q_ASSERT(QMetaObjectPrivate::get(base)->revision >= 7);
3950     QArgumentTypeArray types;
3951     QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signalName, types);
3952     int relative_index = QMetaObjectPrivate::indexOfSignalRelative(
3953             &base, name, types.size(), types.constData());
3954     if (relative_index < 0)
3955         return relative_index;
3956     relative_index = QMetaObjectPrivate::originalClone(base, relative_index);
3957     if (meta)
3958         *meta = base;
3959     return relative_index + QMetaObjectPrivate::signalOffset(base);
3960 }
3961 
3962 /*****************************************************************************
3963   Properties
3964  *****************************************************************************/
3965 
3966 #ifndef QT_NO_PROPERTIES
3967 
3968 /*!
3969   Sets the value of the object's \a name property to \a value.
3970 
3971   If the property is defined in the class using Q_PROPERTY then
3972   true is returned on success and false otherwise. If the property
3973   is not defined using Q_PROPERTY, and therefore not listed in the
3974   meta-object, it is added as a dynamic property and false is returned.
3975 
3976   Information about all available properties is provided through the
3977   metaObject() and dynamicPropertyNames().
3978 
3979   Dynamic properties can be queried again using property() and can be
3980   removed by setting the property value to an invalid QVariant.
3981   Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent
3982   to be sent to the object.
3983 
3984   \b{Note:} Dynamic properties starting with "_q_" are reserved for internal
3985   purposes.
3986 
3987   \sa property(), metaObject(), dynamicPropertyNames(), QMetaProperty::write()
3988 */
3989 bool QObject::setProperty(const char *name, const QVariant &value)
3990 {
3991     Q_D(QObject);
3992     const QMetaObject* meta = metaObject();
3993     if (!name || !meta)
3994         return false;
3995 
3996     int id = meta->indexOfProperty(name);
3997     if (id < 0) {
3998         if (!d->extraData)
3999             d->extraData = new QObjectPrivate::ExtraData;
4000 
4001         const int idx = d->extraData->propertyNames.indexOf(name);
4002 
4003         if (!value.isValid()) {
4004             if (idx == -1)
4005                 return false;
4006             d->extraData->propertyNames.removeAt(idx);
4007             d->extraData->propertyValues.removeAt(idx);
4008         } else {
4009             if (idx == -1) {
4010                 d->extraData->propertyNames.append(name);
4011                 d->extraData->propertyValues.append(value);
4012             } else {
4013                 if (value.userType() == d->extraData->propertyValues.at(idx).userType()
4014                         && value == d->extraData->propertyValues.at(idx))
4015                     return false;
4016                 d->extraData->propertyValues[idx] = value;
4017             }
4018         }
4019 
4020         QDynamicPropertyChangeEvent ev(name);
4021         QCoreApplication::sendEvent(this, &ev);
4022 
4023         return false;
4024     }
4025     QMetaProperty p = meta->property(id);
4026 #ifndef QT_NO_DEBUG
4027     if (!p.isWritable())
4028         qWarning("%s::setProperty: Property \"%s\" invalid,"
4029                  " read-only or does not exist", metaObject()->className(), name);
4030 #endif
4031     return p.write(this, value);
4032 }
4033 
4034 /*!
4035   Returns the value of the object's \a name property.
4036 
4037   If no such property exists, the returned variant is invalid.
4038 
4039   Information about all available properties is provided through the
4040   metaObject() and dynamicPropertyNames().
4041 
4042   \sa setProperty(), QVariant::isValid(), metaObject(), dynamicPropertyNames()
4043 */
4044 QVariant QObject::property(const char *name) const
4045 {
4046     Q_D(const QObject);
4047     const QMetaObject* meta = metaObject();
4048     if (!name || !meta)
4049         return QVariant();
4050 
4051     int id = meta->indexOfProperty(name);
4052     if (id < 0) {
4053         if (!d->extraData)
4054             return QVariant();
4055         const int i = d->extraData->propertyNames.indexOf(name);
4056         return d->extraData->propertyValues.value(i);
4057     }
4058     QMetaProperty p = meta->property(id);
4059 #ifndef QT_NO_DEBUG
4060     if (!p.isReadable())
4061         qWarning("%s::property: Property \"%s\" invalid or does not exist",
4062                  metaObject()->className(), name);
4063 #endif
4064     return p.read(this);
4065 }
4066 
4067 /*!
4068     \since 4.2
4069 
4070     Returns the names of all properties that were dynamically added to
4071     the object using setProperty().
4072 */
4073 QList<QByteArray> QObject::dynamicPropertyNames() const
4074 {
4075     Q_D(const QObject);
4076     if (d->extraData)
4077         return d->extraData->propertyNames;
4078     return QList<QByteArray>();
4079 }
4080 
4081 #endif // QT_NO_PROPERTIES
4082 
4083 
4084 /*****************************************************************************
4085   QObject debugging output routines.
4086  *****************************************************************************/
4087 
4088 static void dumpRecursive(int level, const QObject *object)
4089 {
4090     if (object) {
4091         QByteArray buf;
4092         buf.fill(' ', level / 2 * 8);
4093         if (level % 2)
4094             buf += "    ";
4095         QString name = object->objectName();
4096         QString flags = QLatin1String("");
4097 #if 0
4098         if (qApp->focusWidget() == object)
4099             flags += 'F';
4100         if (object->isWidgetType()) {
4101             QWidget * w = (QWidget *)object;
4102             if (w->isVisible()) {
4103                 QString t("<%1,%2,%3,%4>");
4104                 flags += t.arg(w->x()).arg(w->y()).arg(w->width()).arg(w->height());
4105             } else {
4106                 flags += 'I';
4107             }
4108         }
4109 #endif
4110         qDebug("%s%s::%s %s", (const char*)buf, object->metaObject()->className(), name.toLocal8Bit().data(),
4111                flags.toLatin1().data());
4112         QObjectList children = object->children();
4113         if (!children.isEmpty()) {
4114             for (int i = 0; i < children.size(); ++i)
4115                 dumpRecursive(level+1, children.at(i));
4116         }
4117     }
4118 }
4119 
4120 
4121 /*!
4122     Dumps a tree of children to the debug output.
4123 
4124     \note before Qt 5.9, this function was not const.
4125 
4126     \sa dumpObjectInfo()
4127 */
4128 
4129 void QObject::dumpObjectTree() const
4130 {
4131     dumpRecursive(0, this);
4132 }
4133 
4134 /*!
4135     Dumps information about signal connections, etc. for this object
4136     to the debug output.
4137 
4138     \note before Qt 5.9, this function was not const.
4139 
4140     \sa dumpObjectTree()
4141 */
4142 
4143 void QObject::dumpObjectInfo() const
4144 {
4145     qDebug("OBJECT %s::%s", metaObject()->className(),
4146            objectName().isEmpty() ? "unnamed" : objectName().toLocal8Bit().data());
4147 
4148     Q_D(const QObject);
4149     QBasicMutexLocker locker(signalSlotLock(this));
4150 
4151     // first, look for connections where this object is the sender
4152     qDebug("  SIGNALS OUT");
4153 
4154     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
4155     if (cd && cd->signalVectorCount()) {
4156         QObjectPrivate::SignalVector *signalVector = cd->signalVector.loadRelaxed();
4157         for (int signal_index = 0; signal_index < signalVector->count(); ++signal_index) {
4158             const QObjectPrivate::Connection *c = signalVector->at(signal_index).first.loadRelaxed();
4159             if (!c)
4160                 continue;
4161             const QMetaMethod signal = QMetaObjectPrivate::signal(metaObject(), signal_index);
4162             qDebug("        signal: %s", signal.methodSignature().constData());
4163 
4164             // receivers
4165             while (c) {
4166                 if (!c->receiver.loadRelaxed()) {
4167                     qDebug("          <Disconnected receiver>");
4168                     c = c->nextConnectionList.loadRelaxed();
4169                     continue;
4170                 }
4171                 if (c->isSlotObject) {
4172                     qDebug("          <functor or function pointer>");
4173                     c = c->nextConnectionList.loadRelaxed();
4174                     continue;
4175                 }
4176                 const QMetaObject *receiverMetaObject = c->receiver.loadRelaxed()->metaObject();
4177                 const QMetaMethod method = receiverMetaObject->method(c->method());
4178                 qDebug("          --> %s::%s %s",
4179                        receiverMetaObject->className(),
4180                        c->receiver.loadRelaxed()->objectName().isEmpty() ? "unnamed" : qPrintable(c->receiver.loadRelaxed()->objectName()),
4181                        method.methodSignature().constData());
4182                 c = c->nextConnectionList.loadRelaxed();
4183             }
4184         }
4185     } else {
4186         qDebug( "        <None>" );
4187     }
4188 
4189     // now look for connections where this object is the receiver
4190     qDebug("  SIGNALS IN");
4191 
4192     if (cd && cd->senders) {
4193         for (QObjectPrivate::Connection *s = cd->senders; s; s = s->next) {
4194             QByteArray slotName = QByteArrayLiteral("<unknown>");
4195             if (!s->isSlotObject) {
4196                 const QMetaMethod slot = metaObject()->method(s->method());
4197                 slotName = slot.methodSignature();
4198             }
4199             qDebug("          <-- %s::%s %s",
4200                    s->sender->metaObject()->className(),
4201                    s->sender->objectName().isEmpty() ? "unnamed" : qPrintable(s->sender->objectName()),
4202                    slotName.constData());
4203         }
4204     } else {
4205         qDebug("        <None>");
4206     }
4207 }
4208 
4209 
4210 #ifndef QT_NO_DEBUG_STREAM
4211 QDebug operator<<(QDebug dbg, const QObject *o)
4212 {
4213     QDebugStateSaver saver(dbg);
4214     if (!o)
4215         return dbg << "QObject(0x0)";
4216     dbg.nospace() << o->metaObject()->className() << '(' << (const void *)o;
4217     if (!o->objectName().isEmpty())
4218         dbg << ", name = " << o->objectName();
4219     dbg << ')';
4220     return dbg;
4221 }
4222 #endif
4223 
4224 /*!
4225     \macro Q_CLASSINFO(Name, Value)
4226     \relates QObject
4227 
4228     This macro associates extra information to the class, which is available
4229     using QObject::metaObject(). Qt makes only limited use of this feature, in
4230     the \l{Active Qt}, \l{Qt D-Bus} and \l{Qt QML module}{Qt QML}.
4231 
4232     The extra information takes the form of a \a Name string and a \a Value
4233     literal string.
4234 
4235     Example:
4236 
4237     \snippet code/src_corelib_kernel_qobject.cpp 35
4238 
4239     \sa QMetaObject::classInfo()
4240     \sa QAxFactory
4241     \sa {Using Qt D-Bus Adaptors}
4242     \sa {Extending QML}
4243 */
4244 
4245 /*!
4246     \macro Q_INTERFACES(...)
4247     \relates QObject
4248 
4249     This macro tells Qt which interfaces the class implements. This
4250     is used when implementing plugins.
4251 
4252     Example:
4253 
4254     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 1
4255     \dots
4256     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 3
4257 
4258     See the \l{tools/plugandpaint/plugins/basictools}{Plug & Paint
4259     Basic Tools} example for details.
4260 
4261     \sa Q_DECLARE_INTERFACE(), Q_PLUGIN_METADATA(), {How to Create Qt Plugins}
4262 */
4263 
4264 /*!
4265     \macro Q_PROPERTY(...)
4266     \relates QObject
4267 
4268     This macro is used for declaring properties in classes that
4269     inherit QObject. Properties behave like class data members, but
4270     they have additional features accessible through the \l
4271     {Meta-Object System}.
4272 
4273     \snippet code/doc_src_properties.cpp 0
4274 
4275     The property name and type and the \c READ function are required.
4276     The type can be any type supported by QVariant, or it can be a
4277     user-defined type.  The other items are optional, but a \c WRITE
4278     function is common.  The attributes default to true except \c USER,
4279     which defaults to false.
4280 
4281     For example:
4282 
4283     \snippet code/src_corelib_kernel_qobject.cpp 37
4284 
4285     For more details about how to use this macro, and a more detailed
4286     example of its use, see the discussion on \l {Qt's Property System}.
4287 
4288     \sa {Qt's Property System}
4289 */
4290 
4291 /*!
4292     \macro Q_ENUMS(...)
4293     \relates QObject
4294     \obsolete
4295 
4296     In new code, you should prefer the use of the Q_ENUM() macro, which makes the
4297     type available also to the meta type system.
4298     For instance, QMetaEnum::fromType() will not work with types declared with Q_ENUMS().
4299 
4300     This macro registers one or several enum types to the meta-object
4301     system.
4302 
4303     If you want to register an enum that is declared in another class,
4304     the enum must be fully qualified with the name of the class
4305     defining it. In addition, the class \e defining the enum has to
4306     inherit QObject as well as declare the enum using Q_ENUMS().
4307 
4308     \sa {Qt's Property System}
4309 */
4310 
4311 /*!
4312     \macro Q_FLAGS(...)
4313     \relates QObject
4314     \obsolete
4315 
4316     This macro registers one or several \l{QFlags}{flags types} with the
4317     meta-object system. It is typically used in a class definition to declare
4318     that values of a given enum can be used as flags and combined using the
4319     bitwise OR operator.
4320 
4321     \note This macro takes care of registering individual flag values
4322     with the meta-object system, so it is unnecessary to use Q_ENUMS()
4323     in addition to this macro.
4324 
4325     In new code, you should prefer the use of the Q_FLAG() macro, which makes the
4326     type available also to the meta type system.
4327 
4328     \sa {Qt's Property System}
4329 */
4330 
4331 /*!
4332     \macro Q_ENUM(...)
4333     \relates QObject
4334     \since 5.5
4335 
4336     This macro registers an enum type with the meta-object system.
4337     It must be placed after the enum declaration in a class that has the Q_OBJECT or the
4338     Q_GADGET macro. For namespaces use \l Q_ENUM_NS() instead.
4339 
4340     For example:
4341 
4342     \snippet code/src_corelib_kernel_qobject.cpp 38
4343 
4344     Enumerations that are declared with Q_ENUM have their QMetaEnum registered in the
4345     enclosing QMetaObject. You can also use QMetaEnum::fromType() to get the QMetaEnum.
4346 
4347     Registered enumerations are automatically registered also to the Qt meta
4348     type system, making them known to QMetaType without the need to use
4349     Q_DECLARE_METATYPE(). This will enable useful features; for example, if used
4350     in a QVariant, you can convert them to strings. Likewise, passing them to
4351     QDebug will print out their names.
4352 
4353     Mind that the enum values are stored as signed \c int in the meta object system.
4354     Registering enumerations with values outside the range of values valid for \c int
4355     will lead to overflows and potentially undefined behavior when accessing them through
4356     the meta object system. QML, for example, does access registered enumerations through
4357     the meta object system.
4358 
4359     \sa {Qt's Property System}
4360 */
4361 
4362 
4363 /*!
4364     \macro Q_FLAG(...)
4365     \relates QObject
4366     \since 5.5
4367 
4368     This macro registers a single \l{QFlags}{flags type} with the
4369     meta-object system. It is typically used in a class definition to declare
4370     that values of a given enum can be used as flags and combined using the
4371     bitwise OR operator. For namespaces use \l Q_FLAG_NS() instead.
4372 
4373     The macro must be placed after the enum declaration. The declaration of
4374     the flags type is done using the \l Q_DECLARE_FLAGS() macro.
4375 
4376     For example, in QItemSelectionModel, the
4377     \l{QItemSelectionModel::SelectionFlags}{SelectionFlags} flag is
4378     declared in the following way:
4379 
4380     \snippet code/src_corelib_kernel_qobject.cpp 39
4381 
4382     \note The Q_FLAG macro takes care of registering individual flag values
4383     with the meta-object system, so it is unnecessary to use Q_ENUM()
4384     in addition to this macro.
4385 
4386     \sa {Qt's Property System}
4387 */
4388 
4389 /*!
4390     \macro Q_ENUM_NS(...)
4391     \relates QObject
4392     \since 5.8
4393 
4394     This macro registers an enum type with the meta-object system.
4395     It must be placed after the enum declaration in a namespace that
4396     has the Q_NAMESPACE macro. It is the same as \l Q_ENUM but in a
4397     namespace.
4398 
4399     Enumerations that are declared with Q_ENUM_NS have their QMetaEnum
4400     registered in the enclosing QMetaObject. You can also use
4401     QMetaEnum::fromType() to get the QMetaEnum.
4402 
4403     Registered enumerations are automatically registered also to the Qt meta
4404     type system, making them known to QMetaType without the need to use
4405     Q_DECLARE_METATYPE(). This will enable useful features; for example, if
4406     used in a QVariant, you can convert them to strings. Likewise, passing them
4407     to QDebug will print out their names.
4408 
4409     Mind that the enum values are stored as signed \c int in the meta object system.
4410     Registering enumerations with values outside the range of values valid for \c int
4411     will lead to overflows and potentially undefined behavior when accessing them through
4412     the meta object system. QML, for example, does access registered enumerations through
4413     the meta object system.
4414 
4415     \sa {Qt's Property System}
4416 */
4417 
4418 
4419 /*!
4420     \macro Q_FLAG_NS(...)
4421     \relates QObject
4422     \since 5.8
4423 
4424     This macro registers a single \l{QFlags}{flags type} with the
4425     meta-object system. It is used in a namespace that has the
4426     Q_NAMESPACE macro, to declare that values of a given enum can be
4427     used as flags and combined using the bitwise OR operator.
4428     It is the same as \l Q_FLAG but in a namespace.
4429 
4430     The macro must be placed after the enum declaration.
4431 
4432     \note The Q_FLAG_NS macro takes care of registering individual flag
4433     values with the meta-object system, so it is unnecessary to use
4434     Q_ENUM_NS() in addition to this macro.
4435 
4436     \sa {Qt's Property System}
4437 */
4438 
4439 
4440 /*!
4441     \macro Q_OBJECT
4442     \relates QObject
4443 
4444     The Q_OBJECT macro must appear in the private section of a class
4445     definition that declares its own signals and slots or that uses
4446     other services provided by Qt's meta-object system.
4447 
4448     For example:
4449 
4450     \snippet signalsandslots/signalsandslots.h 1
4451     \codeline
4452     \snippet signalsandslots/signalsandslots.h 2
4453     \snippet signalsandslots/signalsandslots.h 3
4454 
4455     \note This macro requires the class to be a subclass of QObject. Use
4456     Q_GADGET instead of Q_OBJECT to enable the meta object system's support
4457     for enums in a class that is not a QObject subclass.
4458 
4459     \sa {Meta-Object System}, {Signals and Slots}, {Qt's Property System}
4460 */
4461 
4462 /*!
4463     \macro Q_GADGET
4464     \relates QObject
4465 
4466     The Q_GADGET macro is a lighter version of the Q_OBJECT macro for classes
4467     that do not inherit from QObject but still want to use some of the
4468     reflection capabilities offered by QMetaObject. Just like the Q_OBJECT
4469     macro, it must appear in the private section of a class definition.
4470 
4471     Q_GADGETs can have Q_ENUM, Q_PROPERTY and Q_INVOKABLE, but they cannot have
4472     signals or slots.
4473 
4474     Q_GADGET makes a class member, \c{staticMetaObject}, available.
4475     \c{staticMetaObject} is of type QMetaObject and provides access to the
4476     enums declared with Q_ENUMS.
4477 */
4478 
4479 /*!
4480     \macro Q_NAMESPACE
4481     \relates QObject
4482     \since 5.8
4483 
4484     The Q_NAMESPACE macro can be used to add QMetaObject capabilities
4485     to a namespace.
4486 
4487     Q_NAMESPACEs can have Q_CLASSINFO, Q_ENUM_NS, Q_FLAG_NS, but they
4488     cannot have Q_ENUM, Q_FLAG, Q_PROPERTY, Q_INVOKABLE, signals nor slots.
4489 
4490     Q_NAMESPACE makes an external variable, \c{staticMetaObject}, available.
4491     \c{staticMetaObject} is of type QMetaObject and provides access to the
4492     enums declared with Q_ENUM_NS/Q_FLAG_NS.
4493 
4494     For example:
4495 
4496     \code
4497     namespace test {
4498     Q_NAMESPACE
4499     ...
4500     \endcode
4501 
4502     \sa Q_NAMESPACE_EXPORT
4503 */
4504 
4505 /*!
4506     \macro Q_NAMESPACE_EXPORT(EXPORT_MACRO)
4507     \relates QObject
4508     \since 5.14
4509 
4510     The Q_NAMESPACE_EXPORT macro can be used to add QMetaObject capabilities
4511     to a namespace.
4512 
4513     It works exactly like the Q_NAMESPACE macro. However, the external
4514     \c{staticMetaObject} variable that gets defined in the namespace
4515     is declared with the supplied \a EXPORT_MACRO qualifier. This is
4516     useful if the object needs to be exported from a dynamic library.
4517 
4518     For example:
4519 
4520     \code
4521     namespace test {
4522     Q_NAMESPACE_EXPORT(EXPORT_MACRO)
4523     ...
4524     \endcode
4525 
4526     \sa Q_NAMESPACE, {Creating Shared Libraries}
4527 */
4528 
4529 /*!
4530     \macro Q_MOC_INCLUDE
4531     \relates QObject
4532     \since 6.0
4533 
4534     The Q_MOC_INCLUDE macro can be used within or outside a class, and tell the
4535     \l{moc}{Meta Object Compiler} to add an include.
4536 
4537     \code
4538         // Put this in your code and the generated code will include this header.
4539         Q_MOC_INCLUDE("myheader.h")
4540     \endcode
4541 
4542     This is useful if the types you use as properties or signal/slots arguments
4543     are forward declared.
4544 */
4545 
4546 /*!
4547     \macro Q_SIGNALS
4548     \relates QObject
4549 
4550     Use this macro to replace the \c signals keyword in class
4551     declarations, when you want to use Qt Signals and Slots with a
4552     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4553 
4554     The macro is normally used when \c no_keywords is specified with
4555     the \c CONFIG variable in the \c .pro file, but it can be used
4556     even when \c no_keywords is \e not specified.
4557 */
4558 
4559 /*!
4560     \macro Q_SIGNAL
4561     \relates QObject
4562 
4563     This is an additional macro that allows you to mark a single
4564     function as a signal. It can be quite useful, especially when you
4565     use a 3rd-party source code parser which doesn't understand a \c
4566     signals or \c Q_SIGNALS groups.
4567 
4568     Use this macro to replace the \c signals keyword in class
4569     declarations, when you want to use Qt Signals and Slots with a
4570     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4571 
4572     The macro is normally used when \c no_keywords is specified with
4573     the \c CONFIG variable in the \c .pro file, but it can be used
4574     even when \c no_keywords is \e not specified.
4575 */
4576 
4577 /*!
4578     \macro Q_SLOTS
4579     \relates QObject
4580 
4581     Use this macro to replace the \c slots keyword in class
4582     declarations, when you want to use Qt Signals and Slots with a
4583     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4584 
4585     The macro is normally used when \c no_keywords is specified with
4586     the \c CONFIG variable in the \c .pro file, but it can be used
4587     even when \c no_keywords is \e not specified.
4588 */
4589 
4590 /*!
4591     \macro Q_SLOT
4592     \relates QObject
4593 
4594     This is an additional macro that allows you to mark a single
4595     function as a slot. It can be quite useful, especially when you
4596     use a 3rd-party source code parser which doesn't understand a \c
4597     slots or \c Q_SLOTS groups.
4598 
4599     Use this macro to replace the \c slots keyword in class
4600     declarations, when you want to use Qt Signals and Slots with a
4601     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4602 
4603     The macro is normally used when \c no_keywords is specified with
4604     the \c CONFIG variable in the \c .pro file, but it can be used
4605     even when \c no_keywords is \e not specified.
4606 */
4607 
4608 /*!
4609     \macro Q_EMIT
4610     \relates QObject
4611 
4612     Use this macro to replace the \c emit keyword for emitting
4613     signals, when you want to use Qt Signals and Slots with a
4614     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4615 
4616     The macro is normally used when \c no_keywords is specified with
4617     the \c CONFIG variable in the \c .pro file, but it can be used
4618     even when \c no_keywords is \e not specified.
4619 */
4620 
4621 /*!
4622     \macro Q_INVOKABLE
4623     \relates QObject
4624 
4625     Apply this macro to declarations of member functions to allow them to
4626     be invoked via the meta-object system. The macro is written before
4627     the return type, as shown in the following example:
4628 
4629     \snippet qmetaobject-invokable/window.h Window class with invokable method
4630 
4631     The \c invokableMethod() function is marked up using Q_INVOKABLE, causing
4632     it to be registered with the meta-object system and enabling it to be
4633     invoked using QMetaObject::invokeMethod().
4634     Since \c normalMethod() function is not registered in this way, it cannot
4635     be invoked using QMetaObject::invokeMethod().
4636 
4637     If an invokable member function returns a pointer to a QObject or a
4638     subclass of QObject and it is invoked from QML, special ownership rules
4639     apply. See \l{qtqml-cppintegration-data.html}{Data Type Conversion Between QML and C++}
4640     for more information.
4641 */
4642 
4643 /*!
4644     \macro Q_REVISION
4645     \relates QObject
4646 
4647     Apply this macro to declarations of member functions to tag them with a
4648     revision number in the meta-object system. The macro is written before
4649     the return type, as shown in the following example:
4650 
4651     \snippet qmetaobject-revision/window.h Window class with revision
4652 
4653     This is useful when using the meta-object system to dynamically expose
4654     objects to another API, as you can match the version expected by multiple
4655     versions of the other API. Consider the following simplified example:
4656 
4657     \snippet qmetaobject-revision/main.cpp Window class using revision
4658 
4659     Using the same Window class as the previous example, the newProperty and
4660     newMethod would only be exposed in this code when the expected version is
4661     \c{2.1} or greater.
4662 
4663     Since all methods are considered to be in revision \c{0} if untagged, a tag
4664     of \c{Q_REVISION(0)} or \c{Q_REVISION(0, 0)} is invalid and ignored.
4665 
4666     You can pass one or two integer parameters to \c{Q_REVISION}. If you pass
4667     one parameter, it denotes the minor version only. This means that the major
4668     version is unspecified. If you pass two, the first parameter is the major
4669     version and the second parameter is the minor version.
4670 
4671     This tag is not used by the meta-object system itself. Currently this is only
4672     used by the QtQml module.
4673 
4674     For a more generic string tag, see \l QMetaMethod::tag()
4675 
4676     \sa QMetaMethod::revision()
4677 */
4678 
4679 /*!
4680     \macro Q_SET_OBJECT_NAME(Object)
4681     \relates QObject
4682     \since 5.0
4683 
4684     This macro assigns \a Object the objectName "Object".
4685 
4686     It doesn't matter whether \a Object is a pointer or not, the
4687     macro figures that out by itself.
4688 
4689     \sa QObject::objectName()
4690 */
4691 
4692 /*!
4693     \macro QT_NO_NARROWING_CONVERSIONS_IN_CONNECT
4694     \relates QObject
4695     \since 5.8
4696 
4697     Defining this macro will disable narrowing and floating-point-to-integral
4698     conversions between the arguments carried by a signal and the arguments
4699     accepted by a slot, when the signal and the slot are connected using the
4700     PMF-based syntax.
4701 
4702     \sa QObject::connect
4703 */
4704 
4705 /*!
4706     \typedef QObjectList
4707     \relates QObject
4708 
4709     Synonym for QList<QObject *>.
4710 */
4711 
4712 void qDeleteInEventHandler(QObject *o)
4713 {
4714     delete o;
4715 }
4716 
4717 /*!
4718     \fn template<typename PointerToMemberFunction> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)
4719     \overload connect()
4720     \threadsafe
4721 
4722     Creates a connection of the given \a type from the \a signal in
4723     the \a sender object to the \a method in the \a receiver object.
4724     Returns a handle to the connection that can be used to disconnect
4725     it later.
4726 
4727     The signal must be a function declared as a signal in the header.
4728     The slot function can be any member function that can be connected
4729     to the signal.
4730     A slot can be connected to a given signal if the signal has at
4731     least as many arguments as the slot, and there is an implicit
4732     conversion between the types of the corresponding arguments in the
4733     signal and the slot.
4734 
4735     Example:
4736 
4737     \snippet code/src_corelib_kernel_qobject.cpp 44
4738 
4739     This example ensures that the label always displays the current
4740     line edit text.
4741 
4742     A signal can be connected to many slots and signals. Many signals
4743     can be connected to one slot.
4744 
4745     If a signal is connected to several slots, the slots are activated
4746     in the same order as the order the connection was made, when the
4747     signal is emitted
4748 
4749     The function returns an handle to a connection if it successfully
4750     connects the signal to the slot. The Connection handle will be invalid
4751     if it cannot create the connection, for example, if QObject is unable
4752     to verify the existence of \a signal (if it was not declared as a signal)
4753     You can check if the QMetaObject::Connection is valid by casting it to a bool.
4754 
4755     By default, a signal is emitted for every connection you make;
4756     two signals are emitted for duplicate connections. You can break
4757     all of these connections with a single disconnect() call.
4758     If you pass the Qt::UniqueConnection \a type, the connection will only
4759     be made if it is not a duplicate. If there is already a duplicate
4760     (exact same signal to the exact same slot on the same objects),
4761     the connection will fail and connect will return an invalid QMetaObject::Connection.
4762 
4763     The optional \a type parameter describes the type of connection
4764     to establish. In particular, it determines whether a particular
4765     signal is delivered to a slot immediately or queued for delivery
4766     at a later time. If the signal is queued, the parameters must be
4767     of types that are known to Qt's meta-object system, because Qt
4768     needs to copy the arguments to store them in an event behind the
4769     scenes. If you try to use a queued connection and get the error
4770     message
4771 
4772     \snippet code/src_corelib_kernel_qobject.cpp 25
4773 
4774     make sure to declare the argument type with Q_DECLARE_METATYPE
4775 
4776     Overloaded functions can be resolved with help of \l qOverload.
4777 
4778     \sa {Differences between String-Based and Functor-Based Connections}
4779  */
4780 
4781 /*!
4782     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
4783 
4784     \threadsafe
4785     \overload connect()
4786 
4787     Creates a connection from \a signal in
4788     \a sender object to \a functor, and returns a handle to the connection
4789 
4790     The signal must be a function declared as a signal in the header.
4791     The slot function can be any function or functor that can be connected
4792     to the signal.
4793     A function can be connected to a given signal if the signal has at
4794     least as many argument as the slot. A functor can be connected to a signal
4795     if they have exactly the same number of arguments. There must exist implicit
4796     conversion between the types of the corresponding arguments in the
4797     signal and the slot.
4798 
4799     Example:
4800 
4801     \snippet code/src_corelib_kernel_qobject.cpp 45
4802 
4803     Lambda expressions can also be used:
4804 
4805     \snippet code/src_corelib_kernel_qobject.cpp 46
4806 
4807     The connection will automatically disconnect if the sender is destroyed.
4808     However, you should take care that any objects used within the functor
4809     are still alive when the signal is emitted.
4810 
4811     Overloaded functions can be resolved with help of \l qOverload.
4812 
4813  */
4814 
4815 /*!
4816     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)
4817 
4818     \threadsafe
4819     \overload connect()
4820 
4821     \since 5.2
4822 
4823     Creates a connection of a given \a type from \a signal in
4824     \a sender object to \a functor to be placed in a specific event
4825     loop of \a context, and returns a handle to the connection.
4826 
4827     \note Qt::UniqueConnections do not work for lambdas, non-member functions
4828     and functors; they only apply to connecting to member functions.
4829 
4830     The signal must be a function declared as a signal in the header.
4831     The slot function can be any function or functor that can be connected
4832     to the signal.
4833     A function can be connected to a given signal if the signal has at
4834     least as many argument as the slot. A functor can be connected to a signal
4835     if they have exactly the same number of arguments. There must exist implicit
4836     conversion between the types of the corresponding arguments in the
4837     signal and the slot.
4838 
4839     Example:
4840 
4841     \snippet code/src_corelib_kernel_qobject.cpp 50
4842 
4843     Lambda expressions can also be used:
4844 
4845     \snippet code/src_corelib_kernel_qobject.cpp 51
4846 
4847     The connection will automatically disconnect if the sender or the context
4848     is destroyed.
4849     However, you should take care that any objects used within the functor
4850     are still alive when the signal is emitted.
4851 
4852     Overloaded functions can be resolved with help of \l qOverload.
4853  */
4854 
4855 /*!
4856     \internal
4857 
4858     Implementation of the template version of connect
4859 
4860     \a sender is the sender object
4861     \a signal is a pointer to a pointer to a member signal of the sender
4862     \a receiver is the receiver object, may not be \nullptr, will be equal to sender when
4863                 connecting to a static function or a functor
4864     \a slot a pointer only used when using Qt::UniqueConnection
4865     \a type the Qt::ConnectionType passed as argument to connect
4866     \a types an array of integer with the metatype id of the parameter of the signal
4867              to be used with queued connection
4868              must stay valid at least for the whole time of the connection, this function
4869              do not take ownership. typically static data.
4870              If \nullptr, then the types will be computed when the signal is emit in a queued
4871              connection from the types from the signature.
4872     \a senderMetaObject is the metaobject used to lookup the signal, the signal must be in
4873                         this metaobject
4874  */
4875 QMetaObject::Connection QObject::connectImpl(const QObject *sender, void **signal,
4876                                              const QObject *receiver, void **slot,
4877                                              QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
4878                                              const int *types, const QMetaObject *senderMetaObject)
4879 {
4880     if (!signal) {
4881         qWarning("QObject::connect: invalid nullptr parameter");
4882         if (slotObj)
4883             slotObj->destroyIfLastRef();
4884         return QMetaObject::Connection();
4885     }
4886 
4887     int signal_index = -1;
4888     void *args[] = { &signal_index, signal };
4889     for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
4890         senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
4891         if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
4892             break;
4893     }
4894     if (!senderMetaObject) {
4895         qWarning("QObject::connect: signal not found in %s", sender->metaObject()->className());
4896         slotObj->destroyIfLastRef();
4897         return QMetaObject::Connection(nullptr);
4898     }
4899     signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
4900     return QObjectPrivate::connectImpl(sender, signal_index, receiver, slot, slotObj, type, types, senderMetaObject);
4901 }
4902 
4903 /*!
4904     \internal
4905 
4906     Internal version of connect used by the template version of QObject::connect (called via connectImpl) and
4907     also used by the QObjectPrivate::connect version used by QML. The signal_index is expected to be relative
4908     to the number of signals.
4909  */
4910 QMetaObject::Connection QObjectPrivate::connectImpl(const QObject *sender, int signal_index,
4911                                              const QObject *receiver, void **slot,
4912                                              QtPrivate::QSlotObjectBase *slotObj, int type,
4913                                              const int *types, const QMetaObject *senderMetaObject)
4914 {
4915     if (!sender || !receiver || !slotObj || !senderMetaObject) {
4916         const char *senderString = sender ? sender->metaObject()->className()
4917                                           : senderMetaObject ? senderMetaObject->className()
4918                                           : "Unknown";
4919         const char *receiverString = receiver ? receiver->metaObject()->className()
4920                                               : "Unknown";
4921         qWarning("QObject::connect(%s, %s): invalid nullptr parameter", senderString, receiverString);
4922         if (slotObj)
4923             slotObj->destroyIfLastRef();
4924         return QMetaObject::Connection();
4925     }
4926 
4927     QObject *s = const_cast<QObject *>(sender);
4928     QObject *r = const_cast<QObject *>(receiver);
4929 
4930     QOrderedMutexLocker locker(signalSlotLock(sender),
4931                                signalSlotLock(receiver));
4932 
4933     if (type & Qt::UniqueConnection && slot && QObjectPrivate::get(s)->connections.loadRelaxed()) {
4934         QObjectPrivate::ConnectionData *connections = QObjectPrivate::get(s)->connections.loadRelaxed();
4935         if (connections->signalVectorCount() > signal_index) {
4936             const QObjectPrivate::Connection *c2 = connections->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
4937 
4938             while (c2) {
4939                 if (c2->receiver.loadRelaxed() == receiver && c2->isSlotObject && c2->slotObj->compare(slot)) {
4940                     slotObj->destroyIfLastRef();
4941                     return QMetaObject::Connection();
4942                 }
4943                 c2 = c2->nextConnectionList.loadRelaxed();
4944             }
4945         }
4946     }
4947     type &= ~Qt::UniqueConnection;
4948 
4949     const bool isSingleShot = type & Qt::SingleShotConnection;
4950     type &= ~Qt::SingleShotConnection;
4951 
4952     Q_ASSERT(type >= 0);
4953     Q_ASSERT(type <= 3);
4954 
4955     std::unique_ptr<QObjectPrivate::Connection> c{new QObjectPrivate::Connection};
4956     c->sender = s;
4957     c->signal_index = signal_index;
4958     QThreadData *td = r->d_func()->threadData;
4959     td->ref();
4960     c->receiverThreadData.storeRelaxed(td);
4961     c->receiver.storeRelaxed(r);
4962     c->slotObj = slotObj;
4963     c->connectionType = type;
4964     c->isSlotObject = true;
4965     if (types) {
4966         c->argumentTypes.storeRelaxed(types);
4967         c->ownArgumentTypes = false;
4968     }
4969     c->isSingleShot = isSingleShot;
4970 
4971     QObjectPrivate::get(s)->addConnection(signal_index, c.get());
4972     QMetaObject::Connection ret(c.release());
4973     locker.unlock();
4974 
4975     QMetaMethod method = QMetaObjectPrivate::signal(senderMetaObject, signal_index);
4976     Q_ASSERT(method.isValid());
4977     s->connectNotify(method);
4978 
4979     return ret;
4980 }
4981 
4982 /*!
4983     Disconnect a connection.
4984 
4985     If the \a connection is invalid or has already been disconnected, do nothing
4986     and return false.
4987 
4988    \sa connect()
4989  */
4990 bool QObject::disconnect(const QMetaObject::Connection &connection)
4991 {
4992     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(connection.d_ptr);
4993     const bool disconnected = QObjectPrivate::disconnect(c);
4994     if (disconnected) {
4995         const_cast<QMetaObject::Connection &>(connection).d_ptr = nullptr;
4996         c->deref(); // has been removed from the QMetaObject::Connection object
4997     }
4998     return disconnected;
4999 }
5000 
5001 /*! \fn template<typename PointerToMemberFunction> bool QObject::disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
5002     \overload disconnect()
5003     \threadsafe
5004 
5005     Disconnects \a signal in object \a sender from \a method in object
5006     \a receiver. Returns \c true if the connection is successfully broken;
5007     otherwise returns \c false.
5008 
5009     A signal-slot connection is removed when either of the objects
5010     involved are destroyed.
5011 
5012     disconnect() is typically used in three ways, as the following
5013     examples demonstrate.
5014     \list 1
5015     \li Disconnect everything connected to an object's signals:
5016 
5017        \snippet code/src_corelib_kernel_qobject.cpp 26
5018 
5019     \li Disconnect everything connected to a specific signal:
5020 
5021        \snippet code/src_corelib_kernel_qobject.cpp 47
5022 
5023     \li Disconnect a specific receiver:
5024 
5025        \snippet code/src_corelib_kernel_qobject.cpp 30
5026 
5027     \li Disconnect a connection from one specific signal to a specific slot:
5028 
5029        \snippet code/src_corelib_kernel_qobject.cpp 48
5030 
5031 
5032     \endlist
5033 
5034     \nullptr may be used as a wildcard, meaning "any signal", "any receiving
5035     object", or "any slot in the receiving object", respectively.
5036 
5037     The \a sender may never be \nullptr. (You cannot disconnect signals
5038     from more than one object in a single call.)
5039 
5040     If \a signal is \nullptr, it disconnects \a receiver and \a method from
5041     any signal. If not, only the specified signal is disconnected.
5042 
5043     If \a receiver is \nullptr, it disconnects anything connected to \a
5044     signal. If not, slots in objects other than \a receiver are not
5045     disconnected.
5046 
5047     If \a method is \nullptr, it disconnects anything that is connected to \a
5048     receiver. If not, only slots named \a method will be disconnected,
5049     and all other slots are left alone. The \a method must be \nullptr
5050     if \a receiver is left out, so you cannot disconnect a
5051     specifically-named slot on all objects.
5052 
5053     \note It is not possible to use this overload to disconnect signals
5054     connected to functors or lambda expressions. That is because it is not
5055     possible to compare them. Instead, use the overload that takes a
5056     QMetaObject::Connection
5057 
5058     \sa connect()
5059 */
5060 
5061 bool QObject::disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, const QMetaObject *senderMetaObject)
5062 {
5063     if (sender == nullptr || (receiver == nullptr && slot != nullptr)) {
5064         qWarning("QObject::disconnect: Unexpected nullptr parameter");
5065         return false;
5066     }
5067 
5068     int signal_index = -1;
5069     if (signal) {
5070         void *args[] = { &signal_index, signal };
5071         for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
5072             senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
5073             if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
5074                 break;
5075         }
5076         if (!senderMetaObject) {
5077             qWarning("QObject::disconnect: signal not found in %s", sender->metaObject()->className());
5078             return false;
5079         }
5080         signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
5081     }
5082 
5083     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, receiver, -1, slot);
5084 }
5085 
5086 /*!
5087  \internal
5088  Used by QML to connect a signal by index to a slot implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass).
5089 
5090  The signal_index is an index relative to the number of methods.
5091  */
5092 QMetaObject::Connection QObjectPrivate::connect(const QObject *sender, int signal_index, QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type)
5093 {
5094     if (!sender) {
5095         qWarning("QObject::connect: invalid nullptr parameter");
5096         if (slotObj)
5097             slotObj->destroyIfLastRef();
5098         return QMetaObject::Connection();
5099     }
5100     const QMetaObject *senderMetaObject = sender->metaObject();
5101     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
5102 
5103     return QObjectPrivate::connectImpl(sender, signal_index, sender, /*slot*/nullptr, slotObj, type, /*types*/nullptr, senderMetaObject);
5104 }
5105 
5106 /*!
5107  \internal
5108  Used by QML to disconnect a signal by index that's connected to a slot implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass)
5109  In the QML case the slot is not a pointer to a pointer to the function to disconnect, but instead it is a pointer to an array of internal values
5110  required for the disconnect.
5111  */
5112 bool QObjectPrivate::disconnect(const QObject *sender, int signal_index, void **slot)
5113 {
5114     const QMetaObject *senderMetaObject = sender->metaObject();
5115     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
5116 
5117     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, sender, -1, slot);
5118 }
5119 
5120 /*!
5121     \internal
5122 */
5123 bool QObjectPrivate::disconnect(QObjectPrivate::Connection *c)
5124 {
5125     if (!c)
5126         return false;
5127     QObject *receiver = c->receiver.loadRelaxed();
5128     if (!receiver)
5129         return false;
5130 
5131     QBasicMutex *senderMutex = signalSlotLock(c->sender);
5132     QBasicMutex *receiverMutex = signalSlotLock(receiver);
5133 
5134     QObjectPrivate::ConnectionData *connections;
5135     {
5136         QOrderedMutexLocker locker(senderMutex, receiverMutex);
5137 
5138         // load receiver once again and recheck to ensure nobody else has removed the connection in the meantime
5139         receiver = c->receiver.loadRelaxed();
5140         if (!receiver)
5141             return false;
5142 
5143         connections = QObjectPrivate::get(c->sender)->connections.loadRelaxed();
5144         Q_ASSERT(connections);
5145         connections->removeConnection(c);
5146     }
5147 
5148     connections->cleanOrphanedConnections(c->sender);
5149 
5150     c->sender->disconnectNotify(QMetaObjectPrivate::signal(c->sender->metaObject(),
5151                                                            c->signal_index));
5152 
5153     return true;
5154 }
5155 
5156 /*! \class QMetaObject::Connection
5157     \inmodule QtCore
5158      Represents a handle to a signal-slot (or signal-functor) connection.
5159 
5160      It can be used to check if the connection is valid and to disconnect it using
5161      QObject::disconnect(). For a signal-functor connection without a context object,
5162      it is the only way to selectively disconnect that connection.
5163 
5164      As Connection is just a handle, the underlying signal-slot connection is unaffected
5165      when Connection is destroyed or reassigned.
5166  */
5167 
5168 /*!
5169     Create a copy of the handle to the \a other connection
5170  */
5171 QMetaObject::Connection::Connection(const QMetaObject::Connection &other) : d_ptr(other.d_ptr)
5172 {
5173     if (d_ptr)
5174         static_cast<QObjectPrivate::Connection *>(d_ptr)->ref();
5175 }
5176 
5177 /*!
5178     Assigns \a other to this connection and returns a reference to this connection.
5179 */
5180 QMetaObject::Connection& QMetaObject::Connection::operator=(const QMetaObject::Connection& other)
5181 {
5182     if (other.d_ptr != d_ptr) {
5183         if (d_ptr)
5184             static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5185         d_ptr = other.d_ptr;
5186         if (other.d_ptr)
5187             static_cast<QObjectPrivate::Connection *>(other.d_ptr)->ref();
5188     }
5189     return *this;
5190 }
5191 
5192 /*!
5193     Creates a Connection instance.
5194 */
5195 
5196 QMetaObject::Connection::Connection() : d_ptr(nullptr) {}
5197 
5198 /*!
5199     Destructor for QMetaObject::Connection.
5200 */
5201 QMetaObject::Connection::~Connection()
5202 {
5203     if (d_ptr)
5204         static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5205 }
5206 
5207 /*! \internal Returns true if the object is still connected */
5208 bool QMetaObject::Connection::isConnected_helper() const
5209 {
5210     Q_ASSERT(d_ptr);    // we're only called from operator RestrictedBool() const
5211     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(d_ptr);
5212 
5213     return c->receiver.loadRelaxed();
5214 }
5215 
5216 
5217 /*!
5218     \fn QMetaObject::Connection::operator bool() const
5219 
5220     Returns \c true if the connection is valid.
5221 
5222     The connection is valid if the call to QObject::connect succeeded.
5223     The connection is invalid if QObject::connect was not able to find
5224     the signal or the slot, or if the arguments do not match.
5225  */
5226 
5227 QT_END_NAMESPACE
5228 
5229 #include "moc_qnamespace.cpp"
5230 #include "moc_qobject.cpp"
