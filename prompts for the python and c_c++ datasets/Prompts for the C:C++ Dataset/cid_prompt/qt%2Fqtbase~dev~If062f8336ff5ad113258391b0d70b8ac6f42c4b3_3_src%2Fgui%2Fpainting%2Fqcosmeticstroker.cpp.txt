Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtGui module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qcosmeticstroker_p.h"
41 #include "private/qpainterpath_p.h"
42 #include "private/qrgba64_p.h"
43 #include <qdebug.h>
44 
45 QT_BEGIN_NAMESPACE
46 
47 #if 0
48 inline QString capString(int caps)
49 {
50     QString str;
51     if (caps & QCosmeticStroker::CapBegin) {
52         str += "CapBegin ";
53     }
54     if (caps & QCosmeticStroker::CapEnd) {
55         str += "CapEnd ";
56     }
57     return str;
58 }
59 #endif
60 
61 #if Q_PROCESSOR_WORDSIZE == 8
62 typedef qint64 FDot16;
63 #else
64 typedef int FDot16;
65 #endif
66 
67 #define toF26Dot6(x) ((int)((x)*64.))
68 
69 static inline uint sourceOver(uint d, uint color)
70 {
71     return color + BYTE_MUL(d, qAlpha(~color));
72 }
73 
74 inline static FDot16 FDot16FixedDiv(int x, int y)
75 {
76 #if Q_PROCESSOR_WORDSIZE == 8
77     return FDot16(x) * (1<<16) / y;
78 #else
79     if (qAbs(x) > 0x7fff)
80         return qlonglong(x) * (1<<16) / y;
81     return x * (1<<16) / y;
82 #endif
83 }
84 
85 typedef void (*DrawPixel)(QCosmeticStroker *stroker, int x, int y, int coverage);
86 
87 namespace {
88 
89 struct Dasher {
90     QCosmeticStroker *stroker;
91     int *pattern;
92     int offset;
93     int dashIndex;
94     int dashOn;
95 
96     Dasher(QCosmeticStroker *s, bool reverse, int start, int stop)
97         : stroker(s)
98     {
99         int delta = stop - start;
100         if (reverse) {
101             pattern = stroker->reversePattern;
102             offset = stroker->patternLength - stroker->patternOffset - delta - ((start & 63) - 32);
103             dashOn = 0;
104         } else {
105             pattern = stroker->pattern;
106             offset = stroker->patternOffset - ((start & 63) - 32);
107             dashOn = 1;
108         }
109         offset %= stroker->patternLength;
110         if (offset < 0)
111             offset += stroker->patternLength;
112 
113         dashIndex = 0;
114         while (dashIndex < stroker->patternSize - 1 && offset>= pattern[dashIndex])
115             ++dashIndex;
116 
117 //        qDebug() << "   dasher" << offset/64. << reverse << dashIndex;
118         stroker->patternOffset += delta;
119         stroker->patternOffset %= stroker->patternLength;
120     }
121 
122     bool on() const {
123         return (dashIndex + dashOn) & 1;
124     }
125     void adjust() {
126         offset += 64;
127         if (offset >= pattern[dashIndex]) {
128             ++dashIndex;
129             dashIndex %= stroker->patternSize;
130         }
131         offset %= stroker->patternLength;
132 //        qDebug() << "dasher.adjust" << offset/64. << dashIndex;
133     }
134 };
135 
136 struct NoDasher {
137     NoDasher(QCosmeticStroker *, bool, int, int) {}
138     bool on() const { return true; }
139     void adjust(int = 0) {}
140 };
141 
142 };
143 
144 /*
145  * The return value is the result of the clipLine() call performed at the start
146  * of each of the two functions, aka "false" means completely outside the devices
147  * rect.
148  */
149 template<DrawPixel drawPixel, class Dasher>
150 static bool drawLine(QCosmeticStroker *stroker, qreal x1, qreal y1, qreal x2, qreal y2, int caps);
151 template<DrawPixel drawPixel, class Dasher>
152 static bool drawLineAA(QCosmeticStroker *stroker, qreal x1, qreal y1, qreal x2, qreal y2, int caps);
153 
154 inline void drawPixel(QCosmeticStroker *stroker, int x, int y, int coverage)
155 {
156     const QRect &cl = stroker->clip;
157     if (x < cl.x() || x > cl.right() || y < cl.y() || y > cl.bottom())
158         return;
159 
160     if (stroker->current_span > 0) {
161         const int lastx = stroker->spans[stroker->current_span-1].x + stroker->spans[stroker->current_span-1].len ;
162         const int lasty = stroker->spans[stroker->current_span-1].y;
163 
164         if (stroker->current_span == QCosmeticStroker::NSPANS || y < lasty || (y == lasty && x < lastx)) {
165             stroker->blend(stroker->current_span, stroker->spans, &stroker->state->penData);
166             stroker->current_span = 0;
167         }
168     }
169 
170     stroker->spans[stroker->current_span].x = x;
171     stroker->spans[stroker->current_span].len = 1;
172     stroker->spans[stroker->current_span].y = y;
173     stroker->spans[stroker->current_span].coverage = coverage*stroker->opacity >> 8;
174     ++stroker->current_span;
175 }
176 
177 inline void drawPixelARGB32(QCosmeticStroker *stroker, int x, int y, int coverage)
178 {
179     const QRect &cl = stroker->clip;
180     if (x < cl.x() || x > cl.right() || y < cl.y() || y > cl.bottom())
181         return;
182 
183     int offset = x + stroker->ppl*y;
184     uint c = BYTE_MUL(stroker->color, coverage);
185     stroker->pixels[offset] = sourceOver(stroker->pixels[offset], c);
186 }
187 
188 inline void drawPixelARGB32Opaque(QCosmeticStroker *stroker, int x, int y, int)
189 {
190     const QRect &cl = stroker->clip;
191     if (x < cl.x() || x > cl.right() || y < cl.y() || y > cl.bottom())
192         return;
193 
194     int offset = x + stroker->ppl*y;
195     stroker->pixels[offset] = sourceOver(stroker->pixels[offset], stroker->color);
196 }
197 
198 enum StrokeSelection {
199     Aliased = 0,
200     AntiAliased = 1,
201     Solid = 0,
202     Dashed = 2,
203     RegularDraw = 0,
204     FastDraw = 4
205 };
206 
207 static StrokeLine strokeLine(int strokeSelection)
208 {
209     StrokeLine stroke;
210 
211     switch (strokeSelection) {
212     case Aliased|Solid|RegularDraw:
213         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixel, NoDasher>;
214         break;
215     case Aliased|Solid|FastDraw:
216         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixelARGB32Opaque, NoDasher>;
217         break;
218     case Aliased|Dashed|RegularDraw:
219         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixel, Dasher>;
220         break;
221     case Aliased|Dashed|FastDraw:
222         stroke = &QT_PREPEND_NAMESPACE(drawLine)<drawPixelARGB32Opaque, Dasher>;
223         break;
224     case AntiAliased|Solid|RegularDraw:
225         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixel, NoDasher>;
226         break;
227     case AntiAliased|Solid|FastDraw:
228         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixelARGB32, NoDasher>;
229         break;
230     case AntiAliased|Dashed|RegularDraw:
231         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixel, Dasher>;
232         break;
233     case AntiAliased|Dashed|FastDraw:
234         stroke = &QT_PREPEND_NAMESPACE(drawLineAA)<drawPixelARGB32, Dasher>;
235         break;
236     default:
237         Q_ASSERT(false);
238         stroke = nullptr;
239     }
240     return stroke;
241 }
242 
243 void QCosmeticStroker::setup()
244 {
245     blend = state->penData.blend;
246     if (state->clip && state->clip->enabled && state->clip->hasRectClip && !state->clip->clipRect.isEmpty()) {
247         clip &= state->clip->clipRect;
248         blend = state->penData.unclipped_blend;
249     }
250 
251     int strokeSelection = 0;
252     if (blend == state->penData.unclipped_blend
253         && state->penData.type == QSpanData::Solid
254         && (state->penData.rasterBuffer->format == QImage::Format_ARGB32_Premultiplied
255             || state->penData.rasterBuffer->format == QImage::Format_RGB32)
256         && state->compositionMode() == QPainter::CompositionMode_SourceOver)
257         strokeSelection |= FastDraw;
258 
259     if (state->renderHints & QPainter::Antialiasing)
260         strokeSelection |= AntiAliased;
261 
262     const QList<qreal> &penPattern = state->lastPen.dashPattern();
263     if (penPattern.isEmpty() || penPattern.size() > 32767) {
264         Q_ASSERT(!pattern && !reversePattern);
265         pattern = nullptr;
266         reversePattern = nullptr;
267         patternLength = 0;
268         patternSize = 0;
269     } else {
270         pattern = (int *)malloc(penPattern.size()*sizeof(int));
271         reversePattern = (int *)malloc(penPattern.size()*sizeof(int));
272         patternSize = penPattern.size();
273 
274         patternLength = 0;
275         for (int i = 0; i < patternSize; ++i) {
276             patternLength += (int)qBound(1., penPattern.at(i) * 64, 65536.);
277             pattern[i] = patternLength;
278         }
279         patternLength = 0;
280         for (int i = 0; i < patternSize; ++i) {
281             patternLength += (int)qBound(1., penPattern.at(patternSize - 1 - i) * 64, 65536.);
282             reversePattern[i] = patternLength;
283         }
284         strokeSelection |= Dashed;
285 //        qDebug() << "setup: size=" << patternSize << "length=" << patternLength/64.;
286     }
287 
288     stroke = strokeLine(strokeSelection);
289 
290     qreal width = state->lastPen.widthF();
291     if (width == 0)
292         opacity = 256;
293     else if (state->lastPen.isCosmetic())
294         opacity = (int) 256*width;
295     else
296         opacity = (int) 256*width*state->txscale;
297     opacity = qBound(0, opacity, 256);
298 
299     drawCaps = state->lastPen.capStyle() != Qt::FlatCap;
300 
301     if (strokeSelection & FastDraw) {
302         color = multiplyAlpha256(state->penData.solidColor, opacity).toArgb32();
303         QRasterBuffer *buffer = state->penData.rasterBuffer;
304         pixels = (uint *)buffer->buffer();
305         ppl = buffer->stride<quint32>();
306     }
307 
308     // line drawing produces different results with different clips, so
309     // we need to clip consistently when painting to the same device
310 
311     // setup FP clip bounds
312     xmin = deviceRect.left() - 1;
313     xmax = deviceRect.right() + 2;
314     ymin = deviceRect.top() - 1;
315     ymax = deviceRect.bottom() + 2;
316 
317     lastPixel.x = INT_MIN;
318     lastPixel.y = INT_MIN;
319 }
320 
321 // returns true if the whole line gets clipped away
322 bool QCosmeticStroker::clipLine(qreal &x1, qreal &y1, qreal &x2, qreal &y2)
323 {
324     // basic/rough clipping is done in floating point coordinates to avoid
325     // integer overflow problems.
326     if (x1 < xmin) {
327         if (x2 <= xmin)
328             goto clipped;
329         y1 += (y2 - y1)/(x2 - x1) * (xmin - x1);
330         x1 = xmin;
331     } else if (x1 > xmax) {
332         if (x2 >= xmax)
333             goto clipped;
334         y1 += (y2 - y1)/(x2 - x1) * (xmax - x1);
335         x1 = xmax;
336     }
337     if (x2 < xmin) {
338         lastPixel.x = INT_MIN;
339         y2 += (y2 - y1)/(x2 - x1) * (xmin - x2);
340         x2 = xmin;
341     } else if (x2 > xmax) {
342         lastPixel.x = INT_MIN;
343         y2 += (y2 - y1)/(x2 - x1) * (xmax - x2);
344         x2 = xmax;
345     }
346 
347     if (y1 < ymin) {
348         if (y2 <= ymin)
349             goto clipped;
350         x1 += (x2 - x1)/(y2 - y1) * (ymin - y1);
351         y1 = ymin;
352     } else if (y1 > ymax) {
353         if (y2 >= ymax)
354             goto clipped;
355         x1 += (x2 - x1)/(y2 - y1) * (ymax - y1);
356         y1 = ymax;
357     }
358     if (y2 < ymin) {
359         lastPixel.x = INT_MIN;
360         x2 += (x2 - x1)/(y2 - y1) * (ymin - y2);
361         y2 = ymin;
362     } else if (y2 > ymax) {
363         lastPixel.x = INT_MIN;
364         x2 += (x2 - x1)/(y2 - y1) * (ymax - y2);
365         y2 = ymax;
366     }
367 
368     return false;
369 
370   clipped:
371     lastPixel.x = INT_MIN;
372     return true;
373 }
374 
375 
376 void QCosmeticStroker::drawLine(const QPointF &p1, const QPointF &p2)
377 {
378     if (p1 == p2) {
379         drawPoints(&p1, 1);
380         return;
381     }
382 
383     QPointF start = p1 * state->matrix;
384     QPointF end = p2 * state->matrix;
385 
386     patternOffset = state->lastPen.dashOffset()*64;
387     lastPixel.x = INT_MIN;
388     lastPixel.y = INT_MIN;
389 
390     stroke(this, start.x(), start.y(), end.x(), end.y(), drawCaps ? CapBegin|CapEnd : 0);
391 
392     blend(current_span, spans, &state->penData);
393     current_span = 0;
394 }
395 
396 void QCosmeticStroker::drawPoints(const QPoint *points, int num)
397 {
398     const QPoint *end = points + num;
399     while (points < end) {
400         QPointF p = QPointF(*points) * state->matrix;
401         drawPixel(this, qRound(p.x()), qRound(p.y()), 255);
402         ++points;
403     }
404 
405     blend(current_span, spans, &state->penData);
406     current_span = 0;
407 }
408 
409 void QCosmeticStroker::drawPoints(const QPointF *points, int num)
410 {
411     const QPointF *end = points + num;
412     while (points < end) {
413         QPointF p = (*points) * state->matrix;
414         drawPixel(this, qRound(p.x()), qRound(p.y()), 255);
415         ++points;
416     }
417 
418     blend(current_span, spans, &state->penData);
419     current_span = 0;
420 }
421 
422 void QCosmeticStroker::calculateLastPoint(qreal rx1, qreal ry1, qreal rx2, qreal ry2)
423 {
424     // this is basically the same code as used in the aliased stroke method,
425     // but it only determines the direction and last point of a line
426     //
427     // This is being used to have proper dropout control for closed contours
428     // by calculating the direction and last pixel of the last segment in the contour.
429     // the info is then used to perform dropout control when drawing the first line segment
430     // of the contour
431     lastPixel.x = INT_MIN;
432     lastPixel.y = INT_MIN;
433 
434     if (clipLine(rx1, ry1, rx2, ry2))
435         return;
436 
437     int x1 = toF26Dot6(rx1);
438     int y1 = toF26Dot6(ry1);
439     int x2 = toF26Dot6(rx2);
440     int y2 = toF26Dot6(ry2);
441 
442     int dx = qAbs(x2 - x1);
443     int dy = qAbs(y2 - y1);
444 
445     if (dx < dy) {
446         // vertical
447         bool swapped = false;
448         if (y1 > y2) {
449             swapped = true;
450             qSwap(y1, y2);
451             qSwap(x1, x2);
452         }
453         FDot16 xinc = FDot16FixedDiv(x2 - x1, y2 - y1);
454         FDot16 x = FDot16(x1) * (1<<10);
455 
456         int y = (y1 + 32) >> 6;
457         int ys = (y2 + 32) >> 6;
458 
459         int round = (xinc > 0) ? 32 : 0;
460         if (y != ys) {
461             x += ((y * (1<<6)) + round - y1) * xinc >> 6;
462 
463             if (swapped) {
464                 lastPixel.x = x >> 16;
465                 lastPixel.y = y;
466                 lastDir = QCosmeticStroker::BottomToTop;
467             } else {
468                 lastPixel.x = (x + (ys - y - 1)*xinc) >> 16;
469                 lastPixel.y = ys - 1;
470                 lastDir = QCosmeticStroker::TopToBottom;
471             }
472             lastAxisAligned = qAbs(xinc) < (1 << 14);
473         }
474     } else {
475         // horizontal
476         if (!dx)
477             return;
478 
479         bool swapped = false;
480         if (x1 > x2) {
481             swapped = true;
482             qSwap(x1, x2);
483             qSwap(y1, y2);
484         }
485         FDot16 yinc = FDot16FixedDiv(y2 - y1, x2 - x1);
486         FDot16 y = FDot16(y1) * (1 << 10);
487 
488         int x = (x1 + 32) >> 6;
489         int xs = (x2 + 32) >> 6;
490 
491         int round = (yinc > 0) ? 32 : 0;
492         if (x != xs) {
493             y += ((x * (1<<6)) + round - x1) * yinc >> 6;
494 
495             if (swapped) {
496                 lastPixel.x = x;
497                 lastPixel.y = y >> 16;
498                 lastDir = QCosmeticStroker::RightToLeft;
499             } else {
500                 lastPixel.x = xs - 1;
501                 lastPixel.y = (y + (xs - x - 1)*yinc) >> 16;
502                 lastDir = QCosmeticStroker::LeftToRight;
503             }
504             lastAxisAligned = qAbs(yinc) < (1 << 14);
505         }
506     }
507 //    qDebug() << "   moveTo: setting last pixel to x/y dir" << lastPixel.x << lastPixel.y << lastDir;
508 }
509 
510 static inline const QPainterPath::ElementType *subPath(const QPainterPath::ElementType *t, const QPainterPath::ElementType *end,
511                                                  const qreal *points, bool *closed)
512 {
513     const QPainterPath::ElementType *start = t;
514     ++t;
515 
516     // find out if the subpath is closed
517     while (t < end) {
518         if (*t == QPainterPath::MoveToElement)
519             break;
520         ++t;
521     }
522 
523     int offset = t - start - 1;
524 //    qDebug() << "subpath" << offset << points[0] << points[1] << points[2*offset] << points[2*offset+1];
525     *closed = (points[0] == points[2*offset] && points[1] == points[2*offset + 1]);
526 
527     return t;
528 }
529 
530 void QCosmeticStroker::drawPath(const QVectorPath &path)
531 {
532 //    qDebug() << ">>>> drawpath" << path.convertToPainterPath()
533 //             << "antialiasing:" << (bool)(state->renderHints & QPainter::Antialiasing) << " implicit close:" << path.hasImplicitClose();
534     if (path.isEmpty())
535         return;
536 
537     const qreal *points = path.points();
538     const QPainterPath::ElementType *type = path.elements();
539 
540     if (type) {
541         const QPainterPath::ElementType *end = type + path.elementCount();
542 
543         while (type < end) {
544             Q_ASSERT(type == path.elements() || *type == QPainterPath::MoveToElement);
545 
546             QPointF p = QPointF(points[0], points[1]) * state->matrix;
547             patternOffset = state->lastPen.dashOffset()*64;
548             lastPixel.x = INT_MIN;
549             lastPixel.y = INT_MIN;
550 
551             bool closed;
552             const QPainterPath::ElementType *e = subPath(type, end, points, &closed);
553             if (closed) {
554                 const qreal *p = points + 2*(e-type);
555                 QPointF p1 = QPointF(p[-4], p[-3]) * state->matrix;
556                 QPointF p2 = QPointF(p[-2], p[-1]) * state->matrix;
557                 calculateLastPoint(p1.x(), p1.y(), p2.x(), p2.y());
558             }
559             int caps = (!closed && drawCaps) ? CapBegin : NoCaps;
560 //            qDebug() << "closed =" << closed << capString(caps);
561 
562             points += 2;
563             ++type;
564 
565             while (type < e) {
566                 QPointF p2 = QPointF(points[0], points[1]) * state->matrix;
567                 switch (*type) {
568                 case QPainterPath::MoveToElement:
569                     Q_ASSERT(!"Logic error");
570                     break;
571 
572                 case QPainterPath::LineToElement:
573                     if (!closed && drawCaps && type == e - 1)
574                         caps |= CapEnd;
575                     stroke(this, p.x(), p.y(), p2.x(), p2.y(), caps);
576                     p = p2;
577                     points += 2;
578                     ++type;
579                     break;
580 
581                 case QPainterPath::CurveToElement: {
582                     if (!closed && drawCaps && type == e - 3)
583                         caps |= CapEnd;
584                     QPointF p3 = QPointF(points[2], points[3]) * state->matrix;
585                     QPointF p4 = QPointF(points[4], points[5]) * state->matrix;
586                     renderCubic(p, p2, p3, p4, caps);
587                     p = p4;
588                     type += 3;
589                     points += 6;
590                     break;
591                 }
592                 case QPainterPath::CurveToDataElement:
593                     Q_ASSERT(!"QPainterPath::toSubpathPolygons(), bad element type");
594                     break;
595                 }
596                 caps = NoCaps;
597             }
598         }
599     } else { // !type, simple polygon
600         QPointF p = QPointF(points[0], points[1]) * state->matrix;
601         QPointF movedTo = p;
602         patternOffset = state->lastPen.dashOffset()*64;
603         lastPixel.x = INT_MIN;
604         lastPixel.y = INT_MIN;
605 
606         const qreal *begin = points;
607         const qreal *end = points + 2*path.elementCount();
608         // handle closed path case
609         bool closed = path.hasImplicitClose() || (points[0] == end[-2] && points[1] == end[-1]);
610         int caps = (!closed && drawCaps) ? CapBegin : NoCaps;
611         if (closed) {
612             QPointF p2;
613             if (points[0] == end[-2] && points[1] == end[-1] && path.elementCount() > 2)
614                 p2 = QPointF(end[-4], end[-3]) * state->matrix;
615             else
616                 p2 = QPointF(end[-2], end[-1]) * state->matrix;
617             calculateLastPoint(p2.x(), p2.y(), p.x(), p.y());
618         }
619 
620         bool fastPenAliased = (state->flags.fast_pen && !state->flags.antialiased);
621         points += 2;
622         while (points < end) {
623             QPointF p2 = QPointF(points[0], points[1]) * state->matrix;
624 
625             if (!closed && drawCaps && points == end - 2)
626                 caps |= CapEnd;
627 
628             bool moveNextStart = stroke(this, p.x(), p.y(), p2.x(), p2.y(), caps);
629 
630             /* fix for gaps in polylines with fastpen and aliased in a sequence
631                of points with small distances: if current point p2 has been dropped
632                out, keep last non dropped point p.
633 
634                However, if the line was completely outside the devicerect, we
635                still need to update p to avoid drawing the line after this one from
636                a bad starting position.
637             */
638             if (!fastPenAliased || moveNextStart || points == begin + 2 || points == end - 2)
639                 p = p2;
640             points += 2;
641             caps = NoCaps;
642         }
643         if (path.hasImplicitClose())
644             stroke(this, p.x(), p.y(), movedTo.x(), movedTo.y(), NoCaps);
645     }
646 
647 
648     blend(current_span, spans, &state->penData);
649     current_span = 0;
650 }
651 
652 void QCosmeticStroker::renderCubic(const QPointF &p1, const QPointF &p2, const QPointF &p3, const QPointF &p4, int caps)
653 {
654 //    qDebug() << ">>>> renderCubic" << p1 << p2 << p3 << p4 << capString(caps);
655     const int maxSubDivisions = 6;
656     PointF points[3*maxSubDivisions + 4];
657 
658     points[3].x = p1.x();
659     points[3].y = p1.y();
660     points[2].x = p2.x();
661     points[2].y = p2.y();
662     points[1].x = p3.x();
663     points[1].y = p3.y();
664     points[0].x = p4.x();
665     points[0].y = p4.y();
666 
667     PointF *p = points;
668     int level = maxSubDivisions;
669 
670     renderCubicSubdivision(p, level, caps);
671 }
672 
673 static void splitCubic(QCosmeticStroker::PointF *points)
674 {
675     const qreal half = .5;
676     qreal  a, b, c, d;
677 
678     points[6].x = points[3].x;
679     c = points[1].x;
680     d = points[2].x;
681     points[1].x = a = ( points[0].x + c ) * half;
682     points[5].x = b = ( points[3].x + d ) * half;
683     c = ( c + d ) * half;
684     points[2].x = a = ( a + c ) * half;
685     points[4].x = b = ( b + c ) * half;
686     points[3].x = ( a + b ) * half;
687 
688     points[6].y = points[3].y;
689     c = points[1].y;
690     d = points[2].y;
691     points[1].y = a = ( points[0].y + c ) * half;
692     points[5].y = b = ( points[3].y + d ) * half;
693     c = ( c + d ) * half;
694     points[2].y = a = ( a + c ) * half;
695     points[4].y = b = ( b + c ) * half;
696     points[3].y = ( a + b ) * half;
697 }
698 
699 void QCosmeticStroker::renderCubicSubdivision(QCosmeticStroker::PointF *points, int level, int caps)
700 {
701     if (level) {
702         qreal dx = points[3].x - points[0].x;
703         qreal dy = points[3].y - points[0].y;
704         qreal len = ((qreal).25) * (qAbs(dx) + qAbs(dy));
705 
706         if (qAbs(dx * (points[0].y - points[2].y) - dy * (points[0].x - points[2].x)) >= len ||
707             qAbs(dx * (points[0].y - points[1].y) - dy * (points[0].x - points[1].x)) >= len) {
708             splitCubic(points);
709 
710             --level;
711             renderCubicSubdivision(points + 3, level, caps & CapBegin);
712             renderCubicSubdivision(points, level, caps & CapEnd);
713             return;
714         }
715     }
716 
717     stroke(this, points[3].x, points[3].y, points[0].x, points[0].y, caps);
718 }
719 
720 static inline int swapCaps(int caps)
721 {
722     return ((caps & QCosmeticStroker::CapBegin) << 1) |
723            ((caps & QCosmeticStroker::CapEnd) >> 1);
724 }
725 
726 // adjust line by half a pixel
727 static inline void capAdjust(int caps, int &x1, int &x2, FDot16 &y, FDot16 yinc)
728 {
729     if (caps & QCosmeticStroker::CapBegin) {
730         x1 -= 32;
731         y -= yinc >> 1;
732     }
733     if (caps & QCosmeticStroker::CapEnd) {
734         x2 += 32;
735     }
736 }
737 
738 /*
739   The hard part about this is dropout control and avoiding douple drawing of points when
740   the drawing shifts from horizontal to vertical or back.
741   */
742 template<DrawPixel drawPixel, class Dasher>
743 static bool drawLine(QCosmeticStroker *stroker, qreal rx1, qreal ry1, qreal rx2, qreal ry2, int caps)
744 {
745     bool didDraw = qAbs(rx2 - rx1) + qAbs(ry2 - ry1) >= 1.0;
746 
747     if (stroker->clipLine(rx1, ry1, rx2, ry2))
748         return true;
749 
750     int x1 = toF26Dot6(rx1);
751     int y1 = toF26Dot6(ry1);
752     int x2 = toF26Dot6(rx2);
753     int y2 = toF26Dot6(ry2);
754 
755     int dx = qAbs(x2 - x1);
756     int dy = qAbs(y2 - y1);
757 
758     QCosmeticStroker::Point last = stroker->lastPixel;
759 
760 //    qDebug() << "stroke" << x1/64. << y1/64. << x2/64. << y2/64.;
761 
762     if (dx < dy) {
763         // vertical
764         QCosmeticStroker::Direction dir = QCosmeticStroker::TopToBottom;
765 
766         bool swapped = false;
767         if (y1 > y2) {
768             swapped = true;
769             qSwap(y1, y2);
770             qSwap(x1, x2);
771             caps = swapCaps(caps);
772             dir = QCosmeticStroker::BottomToTop;
773         }
774         FDot16 xinc = FDot16FixedDiv(x2 - x1, y2 - y1);
775         FDot16 x = FDot16(x1) * (1<<10);
776 
777         if ((stroker->lastDir ^ QCosmeticStroker::VerticalMask) == dir)
778             caps |= swapped ? QCosmeticStroker::CapEnd : QCosmeticStroker::CapBegin;
779 
780         capAdjust(caps, y1, y2, x, xinc);
781 
782         int y = (y1 + 32) >> 6;
783         int ys = (y2 + 32) >> 6;
784         int round = (xinc > 0) ? 32 : 0;
785 
786         // If capAdjust made us round away from what calculateLastPoint gave us,
787         // round back the other way so we start and end on the right point.
788         if ((caps & QCosmeticStroker::CapBegin) && stroker->lastPixel.y == y + 1)
789            y++;
790 
791         if (y != ys) {
792             x += ((y * (1<<6)) + round - y1) * xinc >> 6;
793 
794             // calculate first and last pixel and perform dropout control
795             QCosmeticStroker::Point first;
796             first.x = x >> 16;
797             first.y = y;
798             last.x = (x + (ys - y - 1)*xinc) >> 16;
799             last.y = ys - 1;
800             if (swapped)
801                 qSwap(first, last);
802 
803             bool axisAligned = qAbs(xinc) < (1 << 14);
804             if (stroker->lastPixel.x > INT_MIN) {
805                 if (first.x == stroker->lastPixel.x &&
806                     first.y == stroker->lastPixel.y) {
807                     // remove duplicated pixel
808                     if (swapped) {
809                         --ys;
810                     } else {
811                         ++y;
812                         x += xinc;
813                     }
814                 } else if (stroker->lastDir != dir &&
815                            (((axisAligned && stroker->lastAxisAligned) &&
816                              stroker->lastPixel.x != first.x && stroker->lastPixel.y != first.y) ||
817                             (qAbs(stroker->lastPixel.x - first.x) > 1 ||
818                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
819                     // have a missing pixel, insert it
820                     if (swapped) {
821                         ++ys;
822                     } else {
823                         --y;
824                         x -= xinc;
825                     }
826                 } else if (stroker->lastDir == dir &&
827                            ((qAbs(stroker->lastPixel.x - first.x) <= 1 &&
828                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
829                     x += xinc >> 1;
830                     if (swapped)
831                         last.x = (x >> 16);
832                     else
833                         last.x = (x + (ys - y - 1)*xinc) >> 16;
834                 }
835             }
836             stroker->lastDir = dir;
837             stroker->lastAxisAligned = axisAligned;
838 
839             Dasher dasher(stroker, swapped, y * (1<<6), ys * (1<<6));
840 
841             do {
842                 if (dasher.on())
843                     drawPixel(stroker, x >> 16, y, 255);
844                 dasher.adjust();
845                 x += xinc;
846             } while (++y < ys);
847             didDraw = true;
848         }
849     } else {
850         // horizontal
851         if (!dx)
852             return true;
853 
854         QCosmeticStroker::Direction dir = QCosmeticStroker::LeftToRight;
855 
856         bool swapped = false;
857         if (x1 > x2) {
858             swapped = true;
859             qSwap(x1, x2);
860             qSwap(y1, y2);
861             caps = swapCaps(caps);
862             dir = QCosmeticStroker::RightToLeft;
863         }
864         FDot16 yinc = FDot16FixedDiv(y2 - y1, x2 - x1);
865         FDot16 y = FDot16(y1) * (1<<10);
866 
867         if ((stroker->lastDir ^ QCosmeticStroker::HorizontalMask) == dir)
868             caps |= swapped ? QCosmeticStroker::CapEnd : QCosmeticStroker::CapBegin;
869 
870         capAdjust(caps, x1, x2, y, yinc);
871 
872         int x = (x1 + 32) >> 6;
873         int xs = (x2 + 32) >> 6;
874         int round = (yinc > 0) ? 32 : 0;
875 
876         // If capAdjust made us round away from what calculateLastPoint gave us,
877         // round back the other way so we start and end on the right point.
878         if ((caps & QCosmeticStroker::CapBegin) && stroker->lastPixel.x == x + 1)
879             x++;
880 
881         if (x != xs) {
882             y += ((x * (1<<6)) + round - x1) * yinc >> 6;
883 
884             // calculate first and last pixel to perform dropout control
885             QCosmeticStroker::Point first;
886             first.x = x;
887             first.y = y >> 16;
888             last.x = xs - 1;
889             last.y = (y + (xs - x - 1)*yinc) >> 16;
890             if (swapped)
891                 qSwap(first, last);
892 
893             bool axisAligned = qAbs(yinc) < (1 << 14);
894             if (stroker->lastPixel.x > INT_MIN) {
895                 if (first.x == stroker->lastPixel.x && first.y == stroker->lastPixel.y) {
896                     // remove duplicated pixel
897                     if (swapped) {
898                         --xs;
899                     } else {
900                         ++x;
901                         y += yinc;
902                     }
903                 } else if (stroker->lastDir != dir &&
904                            (((axisAligned && stroker->lastAxisAligned) &&
905                              stroker->lastPixel.x != first.x && stroker->lastPixel.y != first.y) ||
906                             (qAbs(stroker->lastPixel.x - first.x) > 1 ||
907                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
908                     // have a missing pixel, insert it
909                     if (swapped) {
910                         ++xs;
911                     } else {
912                         --x;
913                         y -= yinc;
914                     }
915                 } else if (stroker->lastDir == dir &&
916                            ((qAbs(stroker->lastPixel.x - first.x) <= 1 &&
917                              qAbs(stroker->lastPixel.y - first.y) > 1))) {
918                     y += yinc >> 1;
919                     if (swapped)
920                         last.y = (y >> 16);
921                     else
922                         last.y = (y + (xs - x - 1)*yinc) >> 16;
923                 }
924             }
925             stroker->lastDir = dir;
926             stroker->lastAxisAligned = axisAligned;
927 
928             Dasher dasher(stroker, swapped, x * (1<<6), xs * (1<<6));
929 
930             do {
931                 if (dasher.on())
932                     drawPixel(stroker, x, y >> 16, 255);
933                 dasher.adjust();
934                 y += yinc;
935             } while (++x < xs);
936             didDraw = true;
937         }
938     }
939     stroker->lastPixel = last;
940     return didDraw;
941 }
942 
943 
944 template<DrawPixel drawPixel, class Dasher>
945 static bool drawLineAA(QCosmeticStroker *stroker, qreal rx1, qreal ry1, qreal rx2, qreal ry2, int caps)
946 {
947     if (stroker->clipLine(rx1, ry1, rx2, ry2))
948         return true;
949 
950     int x1 = toF26Dot6(rx1);
951     int y1 = toF26Dot6(ry1);
952     int x2 = toF26Dot6(rx2);
953     int y2 = toF26Dot6(ry2);
954 
955     int dx = x2 - x1;
956     int dy = y2 - y1;
957 
958     if (qAbs(dx) < qAbs(dy)) {
959         // vertical
960 
961         FDot16 xinc = FDot16FixedDiv(dx, dy);
962 
963         bool swapped = false;
964         if (y1 > y2) {
965             qSwap(y1, y2);
966             qSwap(x1, x2);
967             swapped = true;
968             caps = swapCaps(caps);
969         }
970 
971         FDot16 x = FDot16(x1 - 32) * (1<<10);
972         x -= ( ((y1 & 63) - 32)  * xinc ) >> 6;
973 
974         capAdjust(caps, y1, y2, x, xinc);
975 
976         Dasher dasher(stroker, swapped, y1, y2);
977 
978         int y = y1 >> 6;
979         int ys = y2 >> 6;
980 
981         int alphaStart, alphaEnd;
982         if (y == ys) {
983             alphaStart = y2 - y1;
984             Q_ASSERT(alphaStart >= 0 && alphaStart < 64);
985             alphaEnd = 0;
986         } else {
987             alphaStart = 64 - (y1 & 63);
988             alphaEnd = (y2 & 63);
989         }
990 //        qDebug() << "vertical" << x1/64. << y1/64. << x2/64. << y2/64.;
991 //        qDebug() << "          x=" << x << "dx=" << dx << "xi=" << (x>>16) << "xsi=" << ((x+(ys-y)*dx)>>16) << "y=" << y << "ys=" << ys;
992 
993         // draw first pixel
994         if (dasher.on()) {
995             uint alpha = (quint8)(x >> 8);
996             drawPixel(stroker, x>>16, y, (255-alpha) * alphaStart >> 6);
997             drawPixel(stroker, (x>>16) + 1, y, alpha * alphaStart >> 6);
998         }
999         dasher.adjust();
1000         x += xinc;
1001         ++y;
1002         if (y < ys) {
1003             do {
1004                 if (dasher.on()) {
1005                     uint alpha = (quint8)(x >> 8);
1006                     drawPixel(stroker, x>>16, y, (255-alpha));
1007                     drawPixel(stroker, (x>>16) + 1, y, alpha);
1008                 }
1009                 dasher.adjust();
1010                 x += xinc;
1011             } while (++y < ys);
1012         }
1013         // draw last pixel
1014         if (alphaEnd && dasher.on()) {
1015             uint alpha = (quint8)(x >> 8);
1016             drawPixel(stroker, x>>16, y, (255-alpha) * alphaEnd >> 6);
1017             drawPixel(stroker, (x>>16) + 1, y, alpha * alphaEnd >> 6);
1018         }
1019     } else {
1020         // horizontal
1021         if (!dx)
1022             return true;
1023 
1024         FDot16 yinc = FDot16FixedDiv(dy, dx);
1025 
1026         bool swapped = false;
1027         if (x1 > x2) {
1028             qSwap(x1, x2);
1029             qSwap(y1, y2);
1030             swapped = true;
1031             caps = swapCaps(caps);
1032         }
1033 
1034         FDot16 y = FDot16(y1 - 32) * (1<<10);
1035         y -= ( ((x1 & 63) - 32)  * yinc ) >> 6;
1036 
1037         capAdjust(caps, x1, x2, y, yinc);
1038 
1039         Dasher dasher(stroker, swapped, x1, x2);
1040 
1041         int x = x1 >> 6;
1042         int xs = x2 >> 6;
1043 
1044 //        qDebug() << "horizontal" << x1/64. << y1/64. << x2/64. << y2/64.;
1045 //        qDebug() << "          y=" << y << "dy=" << dy << "x=" << x << "xs=" << xs << "yi=" << (y>>16) << "ysi=" << ((y+(xs-x)*dy)>>16);
1046         int alphaStart, alphaEnd;
1047         if (x == xs) {
1048             alphaStart = x2 - x1;
1049             Q_ASSERT(alphaStart >= 0 && alphaStart < 64);
1050             alphaEnd = 0;
1051         } else {
1052             alphaStart = 64 - (x1 & 63);
1053             alphaEnd = (x2 & 63);
1054         }
1055 
1056         // draw first pixel
1057         if (dasher.on()) {
1058             uint alpha = (quint8)(y >> 8);
1059             drawPixel(stroker, x, y>>16, (255-alpha) * alphaStart >> 6);
1060             drawPixel(stroker, x, (y>>16) + 1, alpha * alphaStart >> 6);
1061         }
1062         dasher.adjust();
1063         y += yinc;
1064         ++x;
1065         // draw line
1066         if (x < xs) {
1067             do {
1068                 if (dasher.on()) {
1069                     uint alpha = (quint8)(y >> 8);
1070                     drawPixel(stroker, x, y>>16, (255-alpha));
1071                     drawPixel(stroker, x, (y>>16) + 1, alpha);
1072                 }
1073                 dasher.adjust();
1074                 y += yinc;
1075             } while (++x < xs);
1076         }
1077         // draw last pixel
1078         if (alphaEnd && dasher.on()) {
1079             uint alpha = (quint8)(y >> 8);
1080             drawPixel(stroker, x, y>>16, (255-alpha) * alphaEnd >> 6);
1081             drawPixel(stroker, x, (y>>16) + 1, alpha * alphaEnd >> 6);
1082         }
1083     }
1084     return true;
1085 }
1086 
1087 QT_END_NAMESPACE
