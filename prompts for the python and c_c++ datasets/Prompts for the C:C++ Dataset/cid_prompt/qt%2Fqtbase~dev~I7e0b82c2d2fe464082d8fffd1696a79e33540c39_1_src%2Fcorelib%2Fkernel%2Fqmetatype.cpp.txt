Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Copyright (C) 2021 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #define QT_QMETATYPE_BC_COMPAT 1
42 #include "qmetatype.h"
43 #undef QT_QMETATYPE_BC_COMPAT
44 #include "qmetatype_p.h"
45 #include "qobjectdefs.h"
46 #include "qdatetime.h"
47 #include "qbytearray.h"
48 #include "qreadwritelock.h"
49 #include "qstring.h"
50 #include "qstringlist.h"
51 #include "qlist.h"
52 #include "qlocale.h"
53 #include "qdebug.h"
54 #if QT_CONFIG(easingcurve)
55 #include "qeasingcurve.h"
56 #endif
57 #include "quuid.h"
58 #include "qvariant.h"
59 #include "qdatastream.h"
60 
61 #if QT_CONFIG(regularexpression)
62 #  include "qregularexpression.h"
63 #endif
64 
65 #ifndef QT_BOOTSTRAPPED
66 #  include "qbitarray.h"
67 #  include "qurl.h"
68 #  include "qvariant.h"
69 #  include "qjsonvalue.h"
70 #  include "qjsonobject.h"
71 #  include "qjsonarray.h"
72 #  include "qjsondocument.h"
73 #  include "qcborvalue.h"
74 #  include "qcborarray.h"
75 #  include "qcbormap.h"
76 #  include "qbytearraylist.h"
77 #  include "qmetaobject.h"
78 #  include "qsequentialiterable.h"
79 #  include "qassociativeiterable.h"
80 #endif
81 
82 #if QT_CONFIG(itemmodel)
83 #  include "qabstractitemmodel.h"
84 #endif
85 
86 #ifndef QT_NO_GEOM_VARIANT
87 # include "qsize.h"
88 # include "qpoint.h"
89 # include "qrect.h"
90 # include "qline.h"
91 #endif
92 
93 #include <bitset>
94 #include <new>
95 #include <cstring>
96 
97 QT_BEGIN_NAMESPACE
98 
99 #define NS(x) QT_PREPEND_NAMESPACE(x)
100 
101 
102 namespace {
103 struct DefinedTypesFilter {
104     template<typename T>
105     struct Acceptor {
106         static const bool IsAccepted = QtMetaTypePrivate::TypeDefinition<T>::IsAvailable && QModulesPrivate::QTypeModuleInfo<T>::IsCore;
107     };
108 };
109 
110 template<typename T, typename Key>
111 class QMetaTypeFunctionRegistry
112 {
113 public:
114     ~QMetaTypeFunctionRegistry()
115     {
116         const QWriteLocker locker(&lock);
117         map.clear();
118     }
119 
120     bool contains(Key k) const
121     {
122         const QReadLocker locker(&lock);
123         return map.contains(k);
124     }
125 
126     bool insertIfNotContains(Key k, const T &f)
127     {
128         const QWriteLocker locker(&lock);
129         if (map.contains(k))
130             return false;
131         map.insert(k, f);
132         return true;
133     }
134 
135     const T *function(Key k) const
136     {
137         const QReadLocker locker(&lock);
138         auto it = map.find(k);
139         return it == map.end() ? nullptr : std::addressof(*it);
140     }
141 
142     void remove(int from, int to)
143     {
144         const Key k(from, to);
145         const QWriteLocker locker(&lock);
146         map.remove(k);
147     }
148 private:
149     mutable QReadWriteLock lock;
150     QHash<Key, T> map;
151 };
152 
153 struct QMetaTypeCustomRegistry
154 {
155     // extra data not protected by the lock
156     using ConverterRegistry = QMetaTypeFunctionRegistry<QMetaType::ConverterFunction,QPair<int,int> >;
157     using MutableViewRegistry = QMetaTypeFunctionRegistry<QMetaType::MutableViewFunction, QPair<int,int>>;
158     ConverterRegistry *converters = new ConverterRegistry;
159     MutableViewRegistry *mutableViews = new MutableViewRegistry;
160 
161     // the lock protects the next set of fields
162     QReadWriteLock lock;
163     QList<const QtPrivate::QMetaTypeInterface *> registry;
164     QHash<QByteArray, const QtPrivate::QMetaTypeInterface *> aliases;
165     // index of first empty (unregistered) type in registry, if any.
166     int firstEmpty = 0;
167 
168 #ifdef __SANITIZE_ADDRESS__
169     // For full debugging, please see QTBUG-94831.
170     //
171     // The two containers holding std::function MUST be leaked at the end of
172     // the execution, otherwise we can cause a crash. That can happen whenever
173     // a module that registered a meta type gets unloaded before QtCore itself
174     // is unloaded. Because std::function, by its nature, type-erases the clean
175     // up of whatever callable it holds, the code to perform this clean up is
176     // usually located in that module that was unloaded. And on Windows, the
177     // DLL loader unloads the plugin code before it unloads QtCore that the
178     // plugin needed.
179     //
180     // This leak is necessary so long as we're using std::function. We could
181     // replace its use with a custom type whose destructor doesn't call out to
182     // user code, and thus only leaks for non-trivially-destructible functors
183     // (which for some reason we allow -- for Qt 7 we may want to disallow them
184     // and allow ONLY stateless functions and PMFs).
185     ~QMetaTypeCustomRegistry()
186     {
187         delete converters;
188         delete mutableViews;
189     }
190 #endif
191 
192     int registerCustomType(const QtPrivate::QMetaTypeInterface *ti)
193     {
194         {
195             QWriteLocker l(&lock);
196             if (ti->typeId)
197                 return ti->typeId;
198             QByteArray name =
199 #ifndef QT_NO_QOBJECT
200                     QMetaObject::normalizedType
201 #endif
202                     (ti->name);
203             if (auto ti2 = aliases.value(name)) {
204                 ti->typeId.storeRelaxed(ti2->typeId.loadRelaxed());
205                 return ti2->typeId;
206             }
207             aliases[name] = ti;
208             int size = registry.size();
209             while (firstEmpty < size && registry[firstEmpty])
210                 ++firstEmpty;
211             if (firstEmpty < size) {
212                 registry[firstEmpty] = ti;
213                 ++firstEmpty;
214             } else {
215                 registry.append(ti);
216                 firstEmpty = registry.size();
217             }
218             ti->typeId = firstEmpty + QMetaType::User;
219         }
220         if (ti->legacyRegisterOp)
221             ti->legacyRegisterOp();
222         return ti->typeId;
223     };
224 
225     void unregisterDynamicType(int id)
226     {
227         if (!id)
228             return;
229         Q_ASSERT(id > QMetaType::User);
230         QWriteLocker l(&lock);
231         int idx = id - QMetaType::User - 1;
232         auto &ti = registry[idx];
233 
234         // We must unregister all names.
235         auto it = aliases.begin();
236         while (it != aliases.end()) {
237             if (it.value() == ti)
238                 it = aliases.erase(it);
239             else
240                 ++it;
241         }
242 
243         ti = nullptr;
244 
245         firstEmpty = std::min(firstEmpty, idx);
246     }
247 
248     const QtPrivate::QMetaTypeInterface *getCustomType(int id)
249     {
250         QReadLocker l(&lock);
251         return registry.value(id - QMetaType::User - 1);
252     }
253 };
254 
255 Q_GLOBAL_STATIC(QMetaTypeCustomRegistry, customTypeRegistry)
256 
257 } // namespace
258 
259 /*!
260     \macro Q_DECLARE_OPAQUE_POINTER(PointerType)
261     \relates QMetaType
262     \since 5.0
263 
264     This macro enables pointers to forward-declared types (\a PointerType)
265     to be registered with QMetaType using either Q_DECLARE_METATYPE()
266     or qRegisterMetaType().
267 
268     \sa Q_DECLARE_METATYPE(), qRegisterMetaType()
269 */
270 
271 /*!
272     \macro Q_DECLARE_METATYPE(Type)
273     \relates QMetaType
274 
275     This macro makes the type \a Type known to QMetaType as long as it
276     provides a public default constructor, a public copy constructor and
277     a public destructor.
278     It is needed to use the type \a Type as a custom type in QVariant.
279 
280     This macro requires that \a Type is a fully defined type at the point where
281     it is used. For pointer types, it also requires that the pointed to type is
282     fully defined. Use in conjunction with Q_DECLARE_OPAQUE_POINTER() to
283     register pointers to forward declared types.
284 
285     Ideally, this macro should be placed below the declaration of
286     the class or struct. If that is not possible, it can be put in
287     a private header file which has to be included every time that
288     type is used in a QVariant.
289 
290     Adding a Q_DECLARE_METATYPE() makes the type known to all template
291     based functions, including QVariant. Note that if you intend to
292     use the type in \e queued signal and slot connections or in
293     QObject's property system, you also have to call
294     qRegisterMetaType() since the names are resolved at runtime.
295 
296     This example shows a typical use case of Q_DECLARE_METATYPE():
297 
298     \snippet code/src_corelib_kernel_qmetatype.cpp 0
299 
300     If \c MyStruct is in a namespace, the Q_DECLARE_METATYPE() macro
301     has to be outside the namespace:
302 
303     \snippet code/src_corelib_kernel_qmetatype.cpp 1
304 
305     Since \c{MyStruct} is now known to QMetaType, it can be used in QVariant:
306 
307     \snippet code/src_corelib_kernel_qmetatype.cpp 2
308 
309     Some types are registered automatically and do not need this macro:
310 
311     \list
312     \li Pointers to classes derived from QObject
313     \li QList<T>, QQueue<T>, QStack<T> or QSet<T>
314         where T is a registered meta type
315     \li QHash<T1, T2>, QMap<T1, T2> or QPair<T1, T2> where T1 and T2 are
316         registered meta types
317     \li QPointer<T>, QSharedPointer<T>, QWeakPointer<T>, where T is a class that derives from QObject
318     \li Enumerations registered with Q_ENUM or Q_FLAG
319     \li Classes that have a Q_GADGET macro
320     \endlist
321 
322     \note This method also registers the stream and debug operators for the type if they
323     are visible at registration time. As this is done automatically in some places,
324     it is strongly recommended to declare the stream operators for a type directly
325     after the type itself. Because of the argument dependent lookup rules of C++, it is
326     also strongly recommended to declare the operators in the same namespace as the type itself.
327 
328     The stream operators should have the following signatures:
329 
330     \snippet code/src_corelib_kernel_qmetatype.cpp 6
331 
332     \sa qRegisterMetaType()
333 */
334 
335 /*!
336     \macro Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(Container)
337     \relates QMetaType
338 
339     This macro makes the container \a Container known to QMetaType as a sequential
340     container. This makes it possible to put an instance of Container<T> into
341     a QVariant, if T itself is known to QMetaType.
342 
343     Note that all of the Qt sequential containers already have built-in
344     support, and it is not necessary to use this macro with them. The
345     std::vector and std::list containers also have built-in support.
346 
347     This example shows a typical use of Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE():
348 
349     \snippet code/src_corelib_kernel_qmetatype.cpp 10
350 */
351 
352 /*!
353     \macro Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE(Container)
354     \relates QMetaType
355 
356     This macro makes the container \a Container known to QMetaType as an associative
357     container. This makes it possible to put an instance of Container<T, U> into
358     a QVariant, if T and U are themselves known to QMetaType.
359 
360     Note that all of the Qt associative containers already have built-in
361     support, and it is not necessary to use this macro with them. The
362     std::map container also has built-in support.
363 
364     This example shows a typical use of Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE():
365 
366     \snippet code/src_corelib_kernel_qmetatype.cpp 11
367 */
368 
369 /*!
370     \macro Q_DECLARE_SMART_POINTER_METATYPE(SmartPointer)
371     \relates QMetaType
372 
373     This macro makes the smart pointer \a SmartPointer known to QMetaType as a
374     smart pointer. This makes it possible to put an instance of SmartPointer<T> into
375     a QVariant, if T is a type which inherits QObject.
376 
377     Note that the QWeakPointer, QSharedPointer and QPointer already have built-in
378     support, and it is not necessary to use this macro with them.
379 
380     This example shows a typical use of Q_DECLARE_SMART_POINTER_METATYPE():
381 
382     \snippet code/src_corelib_kernel_qmetatype.cpp 13
383 */
384 
385 /*!
386     \enum QMetaType::Type
387 
388     These are the built-in types supported by QMetaType:
389 
390     \value Void \c void
391     \value Bool \c bool
392     \value Int \c int
393     \value UInt \c{unsigned int}
394     \value Double \c double
395     \value QChar QChar
396     \value QString QString
397     \value QByteArray QByteArray
398     \value Nullptr \c{std::nullptr_t}
399 
400     \value VoidStar \c{void *}
401     \value Long \c{long}
402     \value LongLong LongLong
403     \value Short \c{short}
404     \value Char \c{char}
405     \value Char16 \c{char16_t}
406     \value Char32 \c{char32_t}
407     \value ULong \c{unsigned long}
408     \value ULongLong ULongLong
409     \value UShort \c{unsigned short}
410     \value SChar \c{signed char}
411     \value UChar \c{unsigned char}
412     \value Float \c float
413     \value QObjectStar QObject *
414     \value QVariant QVariant
415 
416     \value QCursor QCursor
417     \value QDate QDate
418     \value QSize QSize
419     \value QTime QTime
420     \value QVariantList QVariantList
421     \value QPolygon QPolygon
422     \value QPolygonF QPolygonF
423     \value QColor QColor
424     \value QColorSpace QColorSpace (introduced in Qt 5.15)
425     \value QSizeF QSizeF
426     \value QRectF QRectF
427     \value QLine QLine
428     \value QTextLength QTextLength
429     \value QStringList QStringList
430     \value QVariantMap QVariantMap
431     \value QVariantHash QVariantHash
432     \value QIcon QIcon
433     \value QPen QPen
434     \value QLineF QLineF
435     \value QTextFormat QTextFormat
436     \value QRect QRect
437     \value QPoint QPoint
438     \value QUrl QUrl
439     \value QRegularExpression QRegularExpression
440     \value QDateTime QDateTime
441     \value QPointF QPointF
442     \value QPalette QPalette
443     \value QFont QFont
444     \value QBrush QBrush
445     \value QRegion QRegion
446     \value QBitArray QBitArray
447     \value QImage QImage
448     \value QKeySequence QKeySequence
449     \value QSizePolicy QSizePolicy
450     \value QPixmap QPixmap
451     \value QLocale QLocale
452     \value QBitmap QBitmap
453     \value QTransform QTransform
454     \value QMatrix4x4 QMatrix4x4
455     \value QVector2D QVector2D
456     \value QVector3D QVector3D
457     \value QVector4D QVector4D
458     \value QQuaternion QQuaternion
459     \value QEasingCurve QEasingCurve
460     \value QJsonValue QJsonValue
461     \value QJsonObject QJsonObject
462     \value QJsonArray QJsonArray
463     \value QJsonDocument QJsonDocument
464     \value QCborValue QCborValue
465     \value QCborArray QCborArray
466     \value QCborMap QCborMap
467     \value QCborSimpleType QCborSimpleType
468     \value QModelIndex QModelIndex
469     \value QPersistentModelIndex QPersistentModelIndex (introduced in Qt 5.5)
470     \value QUuid QUuid
471     \value QByteArrayList QByteArrayList
472 
473     \value User  Base value for user types
474     \value UnknownType This is an invalid type id. It is returned from QMetaType for types that are not registered
475     \omitvalue LastCoreType
476     \omitvalue LastGuiType
477 
478     Additional types can be registered using Q_DECLARE_METATYPE().
479 
480     \sa type(), typeName()
481 */
482 
483 /*!
484     \enum QMetaType::TypeFlag
485 
486     The enum describes attributes of a type supported by QMetaType.
487 
488     \value NeedsConstruction This type has non-trivial constructors. If the flag is not set instances can be safely initialized with memset to 0.
489     \value NeedsDestruction This type has a non-trivial destructor. If the flag is not set calls to the destructor are not necessary before discarding objects.
490     \value RelocatableType An instance of a type having this attribute can be safely moved to a different memory location using memcpy.
491     \omitvalue MovableType
492     \omitvalue SharedPointerToQObject
493     \value IsEnumeration This type is an enumeration.
494     \value IsUnsignedEnumeration If the type is an Enumeration, its underlying type is unsigned.
495     \value PointerToQObject This type is a pointer to a derived of QObject.
496     \value IsPointer This type is a pointer to another type.
497     \omitvalue WeakPointerToQObject
498     \omitvalue TrackingPointerToQObject
499     \omitvalue IsGadget \omit This type is a Q_GADGET and it's corresponding QMetaObject can be accessed with QMetaType::metaObject Since 5.5. \endomit
500     \omitvalue PointerToGadget
501     \omitvalue IsQmlList
502     \value IsConst Indicates that values of this types are immutable; for instance because they are pointers to const objects.
503 */
504 
505 /*!
506     \class QMetaType
507     \inmodule QtCore
508     \brief The QMetaType class manages named types in the meta-object system.
509 
510     \ingroup objectmodel
511     \threadsafe
512 
513     The class is used as a helper to marshall types in QVariant and
514     in queued signals and slots connections. It associates a type
515     name to a type so that it can be created and destructed
516     dynamically at run-time. Declare new types with Q_DECLARE_METATYPE()
517     to make them available to QVariant and other template-based functions.
518     Call qRegisterMetaType() to make types available to non-template based
519     functions, such as the queued signal and slot connections.
520 
521     Any class or struct that has a public default
522     constructor, a public copy constructor, and a public destructor
523     can be registered.
524 
525     The following code allocates and destructs an instance of
526     \c{MyClass}:
527 
528     \snippet code/src_corelib_kernel_qmetatype.cpp 3
529 
530     If we want the stream operators \c operator<<() and \c
531     operator>>() to work on QVariant objects that store custom types,
532     the custom type must provide \c operator<<() and \c operator>>()
533     operators.
534 
535     \sa Q_DECLARE_METATYPE(), QVariant::setValue(), QVariant::value(), QVariant::fromValue()
536 */
537 
538 /*!
539     \fn bool QMetaType::isValid() const
540     \since 5.0
541 
542     Returns \c true if this QMetaType object contains valid
543     information about a type, false otherwise.
544 */
545 bool QMetaType::isValid() const
546 {
547     return d_ptr;
548 }
549 
550 /*!
551     \fn bool QMetaType::isRegistered() const
552     \since 5.0
553 
554     Returns \c true if this QMetaType object contains valid
555     information about a type, false otherwise.
556 */
557 bool QMetaType::isRegistered() const
558 {
559     return d_ptr;
560 }
561 
562 /*!
563     \fn int QMetaType::id() const
564     \since 5.13
565 
566     Returns id type hold by this QMetatype instance.
567 */
568 
569 // keep in sync with version in header
570 // ### Qt 7::remove BC helper
571 int QMetaType::id() const
572 {
573     if (d_ptr) {
574         if (int id = d_ptr->typeId.loadRelaxed())
575             return id;
576         return idHelper();
577     }
578     return 0;
579 }
580 
581 /*!
582     \internal
583     The slowpath of id(). Precondition: d_ptr != nullptr
584 */
585 int QMetaType::idHelper() const
586 {
587     Q_ASSERT(d_ptr);
588     auto reg = customTypeRegistry();
589     if (reg) {
590         return reg->registerCustomType(d_ptr);
591     }
592     return 0;
593 }
594 
595 /*!
596     \fn constexpr qsizetype QMetaType::sizeOf() const
597     \since 5.0
598 
599     Returns the size of the type in bytes (i.e. sizeof(T),
600     where T is the actual type for which this QMetaType instance
601     was constructed for).
602 
603     This function is typically used together with construct()
604     to perform low-level management of the memory used by a type.
605 
606     \sa QMetaType::construct(), QMetaType::sizeOf(), QMetaType::alignOf()
607 */
608 
609 /*!
610   \fn constexpr int QMetaType::alignOf() const
611   \since 6.0
612 
613   Returns the alignment of the type in bytes (i.e. alignof(T),
614   where T is the actual type for which this QMetaType instance
615   was constructed for).
616 
617   This function is typically used together with construct()
618   to perform low-level management of the memory used by a type.
619 
620   \sa QMetaType::construct(), QMetaType::sizeOf()
621 
622  */
623 
624 /*!
625     \fn constexpr TypeFlags QMetaType::flags() const
626     \since 5.0
627 
628     Returns flags of the type for which this QMetaType instance was constructed.
629 
630     \sa QMetaType::TypeFlags, QMetaType::flags()
631 */
632 
633 /*!
634     \fn constexpr const QMetaObject *QMetaType::metaObject() const
635     \since 5.5
636 
637     return a QMetaObject relative to this type.
638 
639     If the type is a pointer type to a subclass of QObject, flags() contains
640     QMetaType::PointerToQObject and this function returns the corresponding QMetaObject. This can
641     be used to in combinaison with QMetaObject::construct to create QObject of this type.
642 
643     If the type is a Q_GADGET, flags() contains QMetaType::IsGadget, and this function returns its
644     QMetaObject.  This can be used to retrieve QMetaMethod and QMetaProperty and use them on a
645     pointer of this type. (given by QVariant::data for example)
646 
647     If the type is an enumeration, flags() contains QMetaType::IsEnumeration, and this function
648     returns the QMetaObject of the enclosing object if the enum was registered as a Q_ENUM or
649     \nullptr otherwise
650 
651     \sa QMetaType::flags()
652 */
653 
654 /*!
655     \fn void *QMetaType::create(const void *copy = nullptr) const
656     \since 5.0
657 
658     Returns a copy of \a copy, assuming it is of the type that this
659     QMetaType instance was created for. If \a copy is \nullptr, creates
660     a default constructed instance.
661 
662     \sa QMetaType::destroy()
663 */
664 void *QMetaType::create(const void *copy) const
665 {
666     if (d_ptr && (copy ? !!d_ptr->copyCtr : !!d_ptr->defaultCtr)) {
667         void *where =
668 #ifdef __STDCPP_DEFAULT_NEW_ALIGNMENT__
669             d_ptr->alignment > __STDCPP_DEFAULT_NEW_ALIGNMENT__ ?
670                 operator new(d_ptr->size, std::align_val_t(d_ptr->alignment)) :
671 #endif
672                 operator new(d_ptr->size);
673         return construct(where, copy);
674     }
675     return nullptr;
676 }
677 
678 /*!
679     \fn void QMetaType::destroy(void *data) const
680     \since 5.0
681 
682     Destroys the \a data, assuming it is of the type that this
683     QMetaType instance was created for.
684 
685     \sa QMetaType::create()
686 */
687 void QMetaType::destroy(void *data) const
688 {
689     if (d_ptr) {
690         if (d_ptr->dtor)
691             d_ptr->dtor(d_ptr, data);
692         if (d_ptr->alignment > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
693             operator delete(data, std::align_val_t(d_ptr->alignment));
694         } else {
695             operator delete(data);
696         }
697     }
698 }
699 
700 /*!
701     \fn void *QMetaType::construct(void *where, const void *copy = nullptr) const
702     \since 5.0
703 
704     Constructs a value of the type that this QMetaType instance
705     was constructed for in the existing memory addressed by \a where,
706     that is a copy of \a copy, and returns \a where. If \a copy is
707     zero, the value is default constructed.
708 
709     This is a low-level function for explicitly managing the memory
710     used to store the type. Consider calling create() if you don't
711     need this level of control (that is, use "new" rather than
712     "placement new").
713 
714     You must ensure that \a where points to a location where the new
715     value can be stored and that \a where is suitably aligned.
716     The type's size can be queried by calling sizeOf().
717 
718     The rule of thumb for alignment is that a type is aligned to its
719     natural boundary, which is the smallest power of 2 that is bigger
720     than the type, unless that alignment is larger than the maximum
721     useful alignment for the platform. For practical purposes,
722     alignment larger than 2 * sizeof(void*) is only necessary for
723     special hardware instructions (e.g., aligned SSE loads and stores
724     on x86).
725 */
726 void *QMetaType::construct(void *where, const void *copy) const
727 {
728     if (!where)
729         return nullptr;
730     if (d_ptr) {
731         if (copy && d_ptr->copyCtr) {
732             d_ptr->copyCtr(d_ptr, where, copy);
733             return where;
734         } else if (!copy && d_ptr->defaultCtr) {
735             d_ptr->defaultCtr(d_ptr, where);
736             return where;
737         }
738     }
739     return nullptr;
740 }
741 
742 /*!
743     \fn void QMetaType::destruct(void *data) const
744     \since 5.0
745 
746     Destructs the value, located at \a data, assuming that it is
747     of the type for which this QMetaType instance was constructed for.
748 
749     Unlike destroy(), this function only invokes the type's
750     destructor, it doesn't invoke the delete operator.
751     \sa QMetaType::construct()
752 */
753 void QMetaType::destruct(void *data) const
754 {
755     if (!data)
756         return;
757     if (d_ptr && d_ptr->dtor) {
758         d_ptr->dtor(d_ptr, data);
759         return;
760     }
761 }
762 
763 static QPartialOrdering threeWayCompare(const void *ptr1, const void *ptr2)
764 {
765     std::less<const void *> less;
766     if (less(ptr1, ptr2))
767         return QPartialOrdering::Less;
768     if (less(ptr2, ptr1))
769         return QPartialOrdering::Greater;
770     return QPartialOrdering::Equivalent;
771 }
772 
773 /*!
774     Compares the objects at \a lhs and \a rhs for ordering.
775 
776     Returns QPartialOrdering::Unordered if comparison is not supported
777     or the values are unordered. Otherwise, returns
778     QPartialOrdering::Less, QPartialOrdering::Equivalent or
779     QPartialOrdering::Greater if \a lhs is less than, equivalent
780     to or greater than \a rhs, respectively.
781 
782     Both objects must be of the type described by this metatype. If either \a lhs
783     or \a rhs is \nullptr, the values are unordered. Comparison is only supported
784     if the type's less than operator was visible to the metatype declaration.
785 
786     If the type's equality operator was also visible, values will only compare equal if the
787     equality operator says they are. In the absence of an equality operator, when neither
788     value is less than the other, values are considered equal; if equality is also available
789     and two such values are not equal, they are considered unordered, just as NaN (not a
790     number) values of a floating point type lie outside its ordering.
791 
792     \note If no less than operator was visible to the metatype declaration, values are
793     unordered even if an equality operator visible to the declaration considers them equal:
794     \c{compare() == 0} only agrees with equals() if the less than operator was visible.
795 
796     \since 6.0
797     \sa equals(), isOrdered()
798 */
799 QPartialOrdering QMetaType::compare(const void *lhs, const void *rhs) const
800 {
801     if (!lhs || !rhs)
802         return QPartialOrdering::Unordered;
803     if (d_ptr->flags & QMetaType::IsPointer)
804         return threeWayCompare(*reinterpret_cast<const void * const *>(lhs),
805                                *reinterpret_cast<const void * const *>(rhs));
806     if (d_ptr && d_ptr->lessThan) {
807         if (d_ptr->equals && d_ptr->equals(d_ptr, lhs, rhs))
808             return QPartialOrdering::Equivalent;
809         if (d_ptr->lessThan(d_ptr, lhs, rhs))
810             return QPartialOrdering::Less;
811         if (d_ptr->lessThan(d_ptr, rhs, lhs))
812             return QPartialOrdering::Greater;
813         if (!d_ptr->equals)
814             return QPartialOrdering::Equivalent;
815     }
816     return QPartialOrdering::Unordered;
817 }
818 
819 /*!
820     Compares the objects at \a lhs and \a rhs for equality.
821 
822     Both objects must be of the type described by this metatype.  Can only compare the
823     two objects if a less than or equality operator for the type was visible to the
824     metatype declaration.  Otherwise, the metatype never considers values equal.  When
825     an equality operator was visible to the metatype declaration, it is authoritative;
826     otherwise, if less than is visible, when neither value is less than the other, the
827     two are considered equal.  If values are unordered (see compare() for details) they
828     are not equal.
829 
830     Returns true if the two objects compare equal, otherwise false.
831 
832     \since 6.0
833     \sa isEqualityComparable(), compare()
834 */
835 bool QMetaType::equals(const void *lhs, const void *rhs) const
836 {
837     if (!lhs || !rhs)
838         return false;
839     if (d_ptr) {
840         if (d_ptr->flags & QMetaType::IsPointer)
841             return *reinterpret_cast<const void * const *>(lhs) == *reinterpret_cast<const void * const *>(rhs);
842 
843         if (d_ptr->equals)
844             return d_ptr->equals(d_ptr, lhs, rhs);
845         if (d_ptr->lessThan && !d_ptr->lessThan(d_ptr, lhs, rhs) && !d_ptr->lessThan(d_ptr, rhs, lhs))
846             return true;
847     }
848     return false;
849 }
850 
851 /*!
852     Returns \c true if a less than or equality operator for the type described by
853     this metatype was visible to the metatype declaration, otherwise \c false.
854 
855     \sa equals(), isOrdered()
856 */
857 bool QMetaType::isEqualityComparable() const
858 {
859     return d_ptr && (d_ptr->flags & QMetaType::IsPointer || d_ptr->equals != nullptr || d_ptr->lessThan != nullptr);
860 }
861 
862 /*!
863     Returns \c true if a less than operator for the type described by this metatype
864     was visible to the metatype declaration, otherwise \c false.
865 
866     \sa compare(), isEqualityComparable()
867 */
868 bool QMetaType::isOrdered() const
869 {
870     return d_ptr && (d_ptr->flags & QMetaType::IsPointer || d_ptr->lessThan != nullptr);
871 }
872 
873 
874 /*!
875    \internal
876 */
877 void QMetaType::unregisterMetaType(QMetaType type)
878 {
879     if (type.d_ptr && type.d_ptr->typeId.loadRelaxed() >= QMetaType::User) {
880         if (auto reg = customTypeRegistry())
881             reg->unregisterDynamicType(type.d_ptr->typeId.loadRelaxed());
882         type.d_ptr->typeId.storeRelease(0);
883     }
884 }
885 
886 /*!
887     \fn template<typename T> QMetaType QMetaType::fromType()
888     \since 5.15
889 
890     Returns the QMetaType corresponding to the type in the template parameter.
891 */
892 
893 /*! \fn bool QMetaType::operator==(QMetaType a, QMetaType b)
894     \since 5.15
895     \overload
896 
897     Returns \c true if the QMetaType \a a represents the same type
898     as the QMetaType \a b, otherwise returns \c false.
899 */
900 
901 /*! \fn bool QMetaType::operator!=(QMetaType a, QMetaType b)
902     \since 5.15
903     \overload
904 
905     Returns \c true if the QMetaType \a a represents a different type
906     than the QMetaType \a b, otherwise returns \c false.
907 */
908 
909 #define QT_ADD_STATIC_METATYPE(MetaTypeName, MetaTypeId, RealName) \
910     { #RealName, sizeof(#RealName) - 1, MetaTypeId },
911 
912 #define QT_ADD_STATIC_METATYPE_ALIASES_ITER(MetaTypeName, MetaTypeId, AliasingName, RealNameStr) \
913     { RealNameStr, sizeof(RealNameStr) - 1, QMetaType::MetaTypeName },
914 
915 
916 
917 static const struct { const char * typeName; int typeNameLength; int type; } types[] = {
918     QT_FOR_EACH_STATIC_TYPE(QT_ADD_STATIC_METATYPE)
919     QT_FOR_EACH_STATIC_ALIAS_TYPE(QT_ADD_STATIC_METATYPE_ALIASES_ITER)
920     QT_ADD_STATIC_METATYPE(_, QMetaTypeId2<qreal>::MetaType, qreal)
921     {nullptr, 0, QMetaType::UnknownType}
922 };
923 
924 static const struct : QMetaTypeModuleHelper
925 {
926     template<typename T, typename LiteralWrapper =
927              std::conditional_t<std::is_same_v<T, QString>, QLatin1String, const char *>>
928     static inline bool convertToBool(const T &source)
929     {
930         T str = source.toLower();
931         return !(str.isEmpty() || str == LiteralWrapper("0") || str == LiteralWrapper("false"));
932     }
933 
934     const QtPrivate::QMetaTypeInterface *interfaceForType(int type) const override {
935         switch (type) {
936             QT_FOR_EACH_STATIC_PRIMITIVE_TYPE(QT_METATYPE_CONVERT_ID_TO_TYPE)
937             QT_FOR_EACH_STATIC_PRIMITIVE_POINTER(QT_METATYPE_CONVERT_ID_TO_TYPE)
938             QT_FOR_EACH_STATIC_CORE_CLASS(QT_METATYPE_CONVERT_ID_TO_TYPE)
939             QT_FOR_EACH_STATIC_CORE_POINTER(QT_METATYPE_CONVERT_ID_TO_TYPE)
940             QT_FOR_EACH_STATIC_CORE_TEMPLATE(QT_METATYPE_CONVERT_ID_TO_TYPE)
941         default:
942             return nullptr;
943         }
944     }
945 
946     bool convert(const void *from, int fromTypeId, void *to, int toTypeId) const override
947     {
948         Q_ASSERT(fromTypeId != toTypeId);
949 
950         // canConvert calls with two nullptr
951         bool onlyCheck = (from == nullptr && to == nullptr);
952 
953         // other callers must provide two valid pointers
954         Q_ASSERT(onlyCheck || (bool(from) && bool(to)));
955 
956         using Char = char;
957         using SChar = signed char;
958         using UChar = unsigned char;
959         using Short = short;
960         using UShort = unsigned short;
961         using Int = int;
962         using UInt = unsigned int;
963         using Long = long;
964         using LongLong = qlonglong;
965         using ULong = unsigned long;
966         using ULongLong = qulonglong;
967         using Float = float;
968         using Double = double;
969         using Bool = bool;
970         using Nullptr = std::nullptr_t;
971 
972 #define QMETATYPE_CONVERTER_ASSIGN_DOUBLE(To, From) \
973     QMETATYPE_CONVERTER(To, From, result = double(source); return true;)
974 #define QMETATYPE_CONVERTER_ASSIGN_NUMBER(To, From) \
975     QMETATYPE_CONVERTER(To, From, result = To::number(source); return true;)
976 #ifndef QT_BOOTSTRAPPED
977 #define CONVERT_CBOR_AND_JSON(To) \
978     QMETATYPE_CONVERTER(To, QCborValue, \
979         if constexpr(std::is_same_v<To, Bool>) { \
980             if (!source.isBool()) \
981                 return false; \
982             result = source.toBool(); \
983         } else { \
984             if (!source.isInteger() && !source.isDouble()) \
985                 return false; \
986             if constexpr(std::is_integral_v<To>) \
987                 result = source.toInteger(); \
988             else \
989                 result = source.toDouble(); \
990         } \
991         return true; \
992     ); \
993     QMETATYPE_CONVERTER(To, QJsonValue, \
994         if constexpr(std::is_same_v<To, Bool>) { \
995             if (!source.isBool()) \
996                 return false; \
997             result = source.toBool(); \
998         } else { \
999             if (!source.isDouble()) \
1000                 return false; \
1001             if constexpr(std::is_integral_v<To>) \
1002                 result = source.toInteger(); \
1003             else \
1004                 result = source.toDouble(); \
1005         } \
1006         return true; \
1007     )
1008 #else
1009 #define CONVERT_CBOR_AND_JSON(To)
1010 #endif
1011 
1012 #define INTEGRAL_CONVERTER(To) \
1013     QMETATYPE_CONVERTER_ASSIGN(To, Bool); \
1014     QMETATYPE_CONVERTER_ASSIGN(To, Char); \
1015     QMETATYPE_CONVERTER_ASSIGN(To, UChar); \
1016     QMETATYPE_CONVERTER_ASSIGN(To, SChar); \
1017     QMETATYPE_CONVERTER_ASSIGN(To, Short); \
1018     QMETATYPE_CONVERTER_ASSIGN(To, UShort); \
1019     QMETATYPE_CONVERTER_ASSIGN(To, Int); \
1020     QMETATYPE_CONVERTER_ASSIGN(To, UInt); \
1021     QMETATYPE_CONVERTER_ASSIGN(To, Long); \
1022     QMETATYPE_CONVERTER_ASSIGN(To, ULong); \
1023     QMETATYPE_CONVERTER_ASSIGN(To, LongLong); \
1024     QMETATYPE_CONVERTER_ASSIGN(To, ULongLong); \
1025     QMETATYPE_CONVERTER(To, Float, result = qRound64(source); return true;); \
1026     QMETATYPE_CONVERTER(To, Double, result = qRound64(source); return true;); \
1027     QMETATYPE_CONVERTER(To, QChar, result = source.unicode(); return true;); \
1028     QMETATYPE_CONVERTER(To, QString, \
1029         bool ok = false; \
1030         if constexpr(std::is_same_v<To, bool>) \
1031             result = (ok = true, convertToBool(source)); \
1032         else if constexpr(std::is_signed_v<To>) \
1033             result = To(source.toLongLong(&ok)); \
1034         else \
1035             result = To(source.toULongLong(&ok)); \
1036         return ok; \
1037     ); \
1038     QMETATYPE_CONVERTER(To, QByteArray, \
1039         bool ok = false; \
1040         if constexpr(std::is_same_v<To, bool>) \
1041             result = (ok = true, convertToBool(source)); \
1042         else if constexpr(std::is_signed_v<To>) \
1043             result = To(source.toLongLong(&ok)); \
1044         else \
1045             result = To(source.toULongLong(&ok)); \
1046         return ok; \
1047     ); \
1048     CONVERT_CBOR_AND_JSON(To)
1049 
1050 #define FLOAT_CONVERTER(To) \
1051     QMETATYPE_CONVERTER_ASSIGN(To, Bool); \
1052     QMETATYPE_CONVERTER_ASSIGN(To, Char); \
1053     QMETATYPE_CONVERTER_ASSIGN(To, UChar); \
1054     QMETATYPE_CONVERTER_ASSIGN(To, SChar); \
1055     QMETATYPE_CONVERTER_ASSIGN(To, Short); \
1056     QMETATYPE_CONVERTER_ASSIGN(To, UShort); \
1057     QMETATYPE_CONVERTER_ASSIGN(To, Int); \
1058     QMETATYPE_CONVERTER_ASSIGN(To, UInt); \
1059     QMETATYPE_CONVERTER_ASSIGN(To, Long); \
1060     QMETATYPE_CONVERTER_ASSIGN(To, ULong); \
1061     QMETATYPE_CONVERTER_ASSIGN(To, LongLong); \
1062     QMETATYPE_CONVERTER_ASSIGN(To, ULongLong); \
1063     QMETATYPE_CONVERTER_ASSIGN(To, Float); \
1064     QMETATYPE_CONVERTER_ASSIGN(To, Double); \
1065     QMETATYPE_CONVERTER(To, QString, \
1066         bool ok = false; \
1067         result = source.toDouble(&ok); \
1068         return ok; \
1069     ); \
1070     QMETATYPE_CONVERTER(To, QByteArray, \
1071         bool ok = false; \
1072         result = source.toDouble(&ok); \
1073         return ok; \
1074     ); \
1075     CONVERT_CBOR_AND_JSON(To)
1076 
1077         switch (makePair(toTypeId, fromTypeId)) {
1078 
1079         // integral conversions
1080         INTEGRAL_CONVERTER(Bool);
1081         INTEGRAL_CONVERTER(Char);
1082         INTEGRAL_CONVERTER(UChar);
1083         INTEGRAL_CONVERTER(SChar);
1084         INTEGRAL_CONVERTER(Short);
1085         INTEGRAL_CONVERTER(UShort);
1086         INTEGRAL_CONVERTER(Int);
1087         INTEGRAL_CONVERTER(UInt);
1088         INTEGRAL_CONVERTER(Long);
1089         INTEGRAL_CONVERTER(ULong);
1090         INTEGRAL_CONVERTER(LongLong);
1091         INTEGRAL_CONVERTER(ULongLong);
1092         FLOAT_CONVERTER(Float);
1093         FLOAT_CONVERTER(Double);
1094 
1095 #ifndef QT_BOOTSTRAPPED
1096         QMETATYPE_CONVERTER_ASSIGN(QUrl, QString);
1097         QMETATYPE_CONVERTER(QUrl, QCborValue,
1098             if (source.isUrl()) {
1099                 result = source.toUrl();
1100                 return true;
1101              }
1102             return false;
1103         );
1104 #endif
1105 #if QT_CONFIG(itemmodel)
1106         QMETATYPE_CONVERTER_ASSIGN(QModelIndex, QPersistentModelIndex);
1107         QMETATYPE_CONVERTER_ASSIGN(QPersistentModelIndex, QModelIndex);
1108 #endif // QT_CONFIG(itemmodel)
1109 
1110         // QChar methods
1111 #define QMETATYPE_CONVERTER_ASSIGN_QCHAR(From) \
1112         QMETATYPE_CONVERTER(QChar, From, result = QChar::fromUcs2(source); return true;)
1113         QMETATYPE_CONVERTER_ASSIGN_QCHAR(Char);
1114         QMETATYPE_CONVERTER_ASSIGN_QCHAR(SChar);
1115         QMETATYPE_CONVERTER_ASSIGN_QCHAR(Short);
1116         QMETATYPE_CONVERTER_ASSIGN_QCHAR(Long);
1117         QMETATYPE_CONVERTER_ASSIGN_QCHAR(Int);
1118         QMETATYPE_CONVERTER_ASSIGN_QCHAR(LongLong);
1119         QMETATYPE_CONVERTER_ASSIGN_QCHAR(Float);
1120         QMETATYPE_CONVERTER_ASSIGN_QCHAR(UChar);
1121         QMETATYPE_CONVERTER_ASSIGN_QCHAR(UShort);
1122         QMETATYPE_CONVERTER_ASSIGN_QCHAR(ULong);
1123         QMETATYPE_CONVERTER_ASSIGN_QCHAR(UInt);
1124         QMETATYPE_CONVERTER_ASSIGN_QCHAR(ULongLong);
1125 
1126         // conversions to QString
1127         QMETATYPE_CONVERTER_ASSIGN(QString, QChar);
1128         QMETATYPE_CONVERTER(QString, Bool,
1129             result = source ? QStringLiteral("true") : QStringLiteral("false");
1130             return true;
1131         );
1132         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, Short);
1133         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, Long);
1134         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, Int);
1135         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, LongLong);
1136         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, UShort);
1137         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, ULong);
1138         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, UInt);
1139         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QString, ULongLong);
1140         QMETATYPE_CONVERTER(QString, Float,
1141             result = QString::number(source, 'g', QLocale::FloatingPointShortest);
1142             return true;
1143         );
1144         QMETATYPE_CONVERTER(QString, Double,
1145             result = QString::number(source, 'g', QLocale::FloatingPointShortest);
1146             return true;
1147         );
1148         QMETATYPE_CONVERTER(QString, Char,
1149             result = QString::fromLatin1(&source, 1);
1150             return true;
1151         );
1152         QMETATYPE_CONVERTER(QString, SChar,
1153             char s = source;
1154             result = QString::fromLatin1(&s, 1);
1155             return true;
1156         );
1157         QMETATYPE_CONVERTER(QString, UChar,
1158             char s = source;
1159             result = QString::fromLatin1(&s, 1);
1160             return true;
1161         );
1162 #if QT_CONFIG(datestring)
1163         QMETATYPE_CONVERTER(QString, QDate, result = source.toString(Qt::ISODate); return true;);
1164         QMETATYPE_CONVERTER(QString, QTime, result = source.toString(Qt::ISODateWithMs); return true;);
1165         QMETATYPE_CONVERTER(QString, QDateTime, result = source.toString(Qt::ISODateWithMs); return true;);
1166 #endif
1167         QMETATYPE_CONVERTER(QString, QByteArray, result = QString::fromUtf8(source); return true;);
1168         QMETATYPE_CONVERTER(QString, QStringList,
1169             return (source.count() == 1) ? (result = source.at(0), true) : false;
1170         );
1171 #ifndef QT_BOOTSTRAPPED
1172         QMETATYPE_CONVERTER(QString, QUrl, result = source.toString(); return true;);
1173         QMETATYPE_CONVERTER(QString, QJsonValue,
1174             if (source.isString() || source.isNull()) {
1175                 result = source.toString();
1176                 return true;
1177             }
1178             return false;
1179         );
1180 #endif
1181         QMETATYPE_CONVERTER(QString, Nullptr, Q_UNUSED(source); result = QString(); return true;);
1182 
1183         // QByteArray
1184         QMETATYPE_CONVERTER(QByteArray, QString, result = source.toUtf8(); return true;);
1185         QMETATYPE_CONVERTER(QByteArray, Bool,
1186             result = source ? "true" : "false";
1187             return true;
1188         );
1189         QMETATYPE_CONVERTER(QByteArray, Char, result = QByteArray(source, 1); return true;);
1190         QMETATYPE_CONVERTER(QByteArray, SChar, result = QByteArray(source, 1); return true;);
1191         QMETATYPE_CONVERTER(QByteArray, UChar, result = QByteArray(source, 1); return true;);
1192         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, Short);
1193         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, Long);
1194         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, Int);
1195         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, LongLong);
1196         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, UShort);
1197         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, ULong);
1198         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, UInt);
1199         QMETATYPE_CONVERTER_ASSIGN_NUMBER(QByteArray, ULongLong);
1200         QMETATYPE_CONVERTER(QByteArray, Float,
1201             result = QByteArray::number(source, 'g', QLocale::FloatingPointShortest);
1202             return true;
1203         );
1204         QMETATYPE_CONVERTER(QByteArray, Double,
1205             result = QByteArray::number(source, 'g', QLocale::FloatingPointShortest);
1206             return true;
1207         );
1208         QMETATYPE_CONVERTER(QByteArray, Nullptr, Q_UNUSED(source); result = QByteArray(); return true;);
1209 
1210         QMETATYPE_CONVERTER(QString, QUuid, result = source.toString(); return true;);
1211         QMETATYPE_CONVERTER(QUuid, QString, result = QUuid(source); return true;);
1212         QMETATYPE_CONVERTER(QByteArray, QUuid, result = source.toByteArray(); return true;);
1213         QMETATYPE_CONVERTER(QUuid, QByteArray, result = QUuid(source); return true;);
1214 
1215 #ifndef QT_NO_GEOM_VARIANT
1216         QMETATYPE_CONVERTER(QSize, QSizeF, result = source.toSize(); return true;);
1217         QMETATYPE_CONVERTER_ASSIGN(QSizeF, QSize);
1218         QMETATYPE_CONVERTER(QLine, QLineF, result = source.toLine(); return true;);
1219         QMETATYPE_CONVERTER_ASSIGN(QLineF, QLine);
1220         QMETATYPE_CONVERTER(QRect, QRectF, result = source.toRect(); return true;);
1221         QMETATYPE_CONVERTER_ASSIGN(QRectF, QRect);
1222         QMETATYPE_CONVERTER(QPoint, QPointF, result = source.toPoint(); return true;);
1223         QMETATYPE_CONVERTER_ASSIGN(QPointF, QPoint);
1224  #endif
1225 
1226         QMETATYPE_CONVERTER(QByteArrayList, QVariantList,
1227             result.reserve(source.size());
1228             for (auto v: source)
1229                 result.append(v.toByteArray());
1230             return true;
1231         );
1232         QMETATYPE_CONVERTER(QVariantList, QByteArrayList,
1233             result.reserve(source.size());
1234             for (auto v: source)
1235                 result.append(QVariant(v));
1236             return true;
1237         );
1238 
1239         QMETATYPE_CONVERTER(QStringList, QVariantList,
1240             result.reserve(source.size());
1241             for (auto v: source)
1242                 result.append(v.toString());
1243             return true;
1244         );
1245         QMETATYPE_CONVERTER(QVariantList, QStringList,
1246             result.reserve(source.size());
1247             for (auto v: source)
1248                 result.append(QVariant(v));
1249             return true;
1250         );
1251         QMETATYPE_CONVERTER(QStringList, QString, result = QStringList() << source; return true;);
1252 
1253         QMETATYPE_CONVERTER(QVariantHash, QVariantMap,
1254             for (auto it = source.begin(); it != source.end(); ++it)
1255                 result.insert(it.key(), it.value());
1256             return true;
1257         );
1258         QMETATYPE_CONVERTER(QVariantMap, QVariantHash,
1259             for (auto it = source.begin(); it != source.end(); ++it)
1260                 result.insert(it.key(), it.value());
1261             return true;
1262         );
1263 
1264 #ifndef QT_BOOTSTRAPPED
1265         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QString);
1266         QMETATYPE_CONVERTER(QString, QCborValue,
1267             if (source.isContainer() || source.isTag())
1268                  return false;
1269             result = source.toVariant().toString();
1270             return true;
1271         );
1272         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QByteArray);
1273         QMETATYPE_CONVERTER(QByteArray, QCborValue,
1274             if (source.isByteArray()) {
1275                 result = source.toByteArray();
1276                 return true;
1277             }
1278             return false;
1279         );
1280         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QUuid);
1281         QMETATYPE_CONVERTER(QUuid, QCborValue,
1282             if (!source.isUuid())
1283                 return false;
1284             result = source.toUuid();
1285             return true;
1286         );
1287         QMETATYPE_CONVERTER(QCborValue, QVariantList, result = QCborArray::fromVariantList(source); return true;);
1288         QMETATYPE_CONVERTER(QVariantList, QCborValue,
1289             if (!source.isArray())
1290                 return false;
1291             result = source.toArray().toVariantList();
1292             return true;
1293         );
1294         QMETATYPE_CONVERTER(QCborValue, QVariantMap, result = QCborMap::fromVariantMap(source); return true;);
1295         QMETATYPE_CONVERTER(QVariantMap, QCborValue,
1296             if (!source.isMap())
1297                 return false;
1298                 result = source.toMap().toVariantMap();
1299             return true;
1300         );
1301         QMETATYPE_CONVERTER(QCborValue, QVariantHash, result = QCborMap::fromVariantHash(source); return true;);
1302         QMETATYPE_CONVERTER(QVariantHash, QCborValue,
1303             if (!source.isMap())
1304                 return false;
1305             result = source.toMap().toVariantHash();
1306             return true;
1307         );
1308 #if QT_CONFIG(regularexpression)
1309         QMETATYPE_CONVERTER(QCborValue, QRegularExpression, result = QCborValue(source); return true;);
1310         QMETATYPE_CONVERTER(QRegularExpression, QCborValue,
1311             if (!source.isRegularExpression())
1312                 return false;
1313             result = source.toRegularExpression();
1314             return true;
1315         );
1316 #endif
1317 
1318         QMETATYPE_CONVERTER(QCborValue, Nullptr,
1319             Q_UNUSED(source);
1320             result = QCborValue(QCborValue::Null);
1321             return true;
1322         );
1323         QMETATYPE_CONVERTER(Nullptr, QCborValue,
1324             result = nullptr;
1325             return source.isNull();
1326         );
1327         QMETATYPE_CONVERTER_ASSIGN(QCborValue, Bool);
1328         QMETATYPE_CONVERTER_ASSIGN(QCborValue, Int);
1329         QMETATYPE_CONVERTER_ASSIGN(QCborValue, UInt);
1330         QMETATYPE_CONVERTER(QCborValue, ULong, result = qlonglong(source); return true;);
1331         QMETATYPE_CONVERTER(QCborValue, Long, result = qlonglong(source); return true;);
1332         QMETATYPE_CONVERTER_ASSIGN(QCborValue, LongLong);
1333         QMETATYPE_CONVERTER(QCborValue, ULongLong, result = qlonglong(source); return true;);
1334         QMETATYPE_CONVERTER_ASSIGN(QCborValue, UShort);
1335         QMETATYPE_CONVERTER_ASSIGN(QCborValue, UChar);
1336         QMETATYPE_CONVERTER_ASSIGN(QCborValue, Char);
1337         QMETATYPE_CONVERTER_ASSIGN(QCborValue, SChar);
1338         QMETATYPE_CONVERTER_ASSIGN(QCborValue, Short);
1339         QMETATYPE_CONVERTER_ASSIGN(QCborValue, Double);
1340         QMETATYPE_CONVERTER_ASSIGN(QCborValue, Float);
1341         QMETATYPE_CONVERTER(QCborValue, QStringList,
1342             result = QCborArray::fromStringList(source);
1343             return true;
1344         );
1345         QMETATYPE_CONVERTER(QCborValue, QDate,
1346             result = QCborValue(source.startOfDay());
1347             return true;
1348         );
1349         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QUrl);
1350         QMETATYPE_CONVERTER(QCborValue, QJsonValue,
1351             result = QCborValue::fromJsonValue(source);
1352             return true;
1353         );
1354         QMETATYPE_CONVERTER(QCborValue, QJsonObject,
1355             result = QCborMap::fromJsonObject(source);
1356             return true;
1357         );
1358         QMETATYPE_CONVERTER(QCborValue, QJsonArray,
1359             result = QCborArray::fromJsonArray(source);
1360             return true;
1361         );
1362         QMETATYPE_CONVERTER(QCborValue, QJsonDocument,
1363             QJsonDocument doc = source;
1364             if (doc.isArray())
1365                 result = QCborArray::fromJsonArray(doc.array());
1366             else
1367                 result = QCborMap::fromJsonObject(doc.object());
1368             return true;
1369         );
1370         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QCborMap);
1371         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QCborArray);
1372 
1373         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QDateTime);
1374         QMETATYPE_CONVERTER(QDateTime, QCborValue,
1375             if (source.isDateTime()) {
1376                 result = source.toDateTime();
1377                 return true;
1378             }
1379             return false;
1380         );
1381 
1382         QMETATYPE_CONVERTER_ASSIGN(QCborValue, QCborSimpleType);
1383         QMETATYPE_CONVERTER(QCborSimpleType, QCborValue,
1384             if (source.isSimpleType()) {
1385                  result = source.toSimpleType();
1386                  return true;
1387              }
1388              return false;
1389         );
1390 
1391         QMETATYPE_CONVERTER(QCborArray, QVariantList, result = QCborArray::fromVariantList(source); return true;);
1392         QMETATYPE_CONVERTER(QVariantList, QCborArray, result = source.toVariantList(); return true;);
1393         QMETATYPE_CONVERTER(QCborArray, QStringList, result = QCborArray::fromStringList(source); return true;);
1394         QMETATYPE_CONVERTER(QCborMap, QVariantMap, result = QCborMap::fromVariantMap(source); return true;);
1395         QMETATYPE_CONVERTER(QVariantMap, QCborMap, result = source.toVariantMap(); return true;);
1396         QMETATYPE_CONVERTER(QCborMap, QVariantHash, result = QCborMap::fromVariantHash(source); return true;);
1397         QMETATYPE_CONVERTER(QVariantHash, QCborMap, result = source.toVariantHash(); return true;);
1398 
1399         QMETATYPE_CONVERTER(QCborArray, QCborValue,
1400             if (!source.isArray())
1401                 return false;
1402             result = source.toArray();
1403             return true;
1404         );
1405         QMETATYPE_CONVERTER(QCborArray, QJsonDocument,
1406             if (!source.isArray())
1407                 return false;
1408             result = QCborArray::fromJsonArray(source.array());
1409             return true;
1410         );
1411         QMETATYPE_CONVERTER(QCborArray, QJsonValue,
1412             if (!source.isArray())
1413                 return false;
1414             result = QCborArray::fromJsonArray(source.toArray());
1415             return true;
1416         );
1417         QMETATYPE_CONVERTER(QCborArray, QJsonArray,
1418             result = QCborArray::fromJsonArray(source);
1419             return true;
1420         );
1421         QMETATYPE_CONVERTER(QCborMap, QCborValue,
1422             if (!source.isMap())
1423                 return false;
1424             result = source.toMap();
1425             return true;
1426         );
1427         QMETATYPE_CONVERTER(QCborMap, QJsonDocument,
1428             if (source.isArray())
1429                 return false;
1430             result = QCborMap::fromJsonObject(source.object());
1431             return true;
1432         );
1433         QMETATYPE_CONVERTER(QCborMap, QJsonValue,
1434             if (!source.isObject())
1435                 return false;
1436             result = QCborMap::fromJsonObject(source.toObject());
1437             return true;
1438         );
1439         QMETATYPE_CONVERTER(QCborMap, QJsonObject,
1440             result = QCborMap::fromJsonObject(source);
1441             return true;
1442         );
1443 
1444 
1445         QMETATYPE_CONVERTER(QVariantList, QJsonValue,
1446             if (!source.isArray())
1447                 return false;
1448             result = source.toArray().toVariantList();
1449             return true;
1450         );
1451         QMETATYPE_CONVERTER(QVariantList, QJsonArray, result = source.toVariantList(); return true;);
1452         QMETATYPE_CONVERTER(QVariantMap, QJsonValue,
1453             if (!source.isObject())
1454                 return false;
1455             result = source.toObject().toVariantMap();
1456             return true;
1457         );
1458         QMETATYPE_CONVERTER(QVariantMap, QJsonObject, result = source.toVariantMap(); return true;);
1459         QMETATYPE_CONVERTER(QVariantHash, QJsonValue,
1460             if (!source.isObject())
1461                 return false;
1462             result = source.toObject().toVariantHash();
1463             return true;
1464         );
1465         QMETATYPE_CONVERTER(QVariantHash, QJsonObject, result = source.toVariantHash(); return true;);
1466 
1467 
1468         QMETATYPE_CONVERTER(QJsonArray, QStringList, result = QJsonArray::fromStringList(source); return true;);
1469         QMETATYPE_CONVERTER(QJsonArray, QVariantList, result = QJsonArray::fromVariantList(source); return true;);
1470         QMETATYPE_CONVERTER(QJsonArray, QJsonValue,
1471             if (!source.isArray())
1472                 return false;
1473             result = source.toArray();
1474             return true;
1475         );
1476         QMETATYPE_CONVERTER(QJsonArray, QJsonDocument,
1477             if (!source.isArray())
1478                 return false;
1479             result = source.array();
1480             return true;
1481         );
1482         QMETATYPE_CONVERTER(QJsonArray, QCborValue,
1483             if (!source.isArray())
1484                 return false;
1485             result = source.toArray().toJsonArray();
1486             return true;
1487         );
1488         QMETATYPE_CONVERTER(QJsonArray, QCborArray, result = source.toJsonArray(); return true;);
1489         QMETATYPE_CONVERTER(QJsonObject, QVariantMap, result = QJsonObject::fromVariantMap(source); return true;);
1490         QMETATYPE_CONVERTER(QJsonObject, QVariantHash, result = QJsonObject::fromVariantHash(source); return true;);
1491         QMETATYPE_CONVERTER(QJsonObject, QJsonValue,
1492             if (!source.isObject())
1493                 return false;
1494             result = source.toObject();
1495             return true;
1496         );
1497         QMETATYPE_CONVERTER(QJsonObject, QJsonDocument,
1498             if (source.isArray())
1499                 return false;
1500             result = source.object();
1501             return true;
1502         );
1503         QMETATYPE_CONVERTER(QJsonObject, QCborValue,
1504             if (!source.isMap())
1505                 return false;
1506             result = source.toMap().toJsonObject();
1507             return true;
1508         );
1509         QMETATYPE_CONVERTER(QJsonObject, QCborMap, result = source.toJsonObject(); return true; );
1510 
1511         QMETATYPE_CONVERTER(QJsonValue, Nullptr,
1512             Q_UNUSED(source);
1513             result = QJsonValue(QJsonValue::Null);
1514             return true;
1515         );
1516         QMETATYPE_CONVERTER(Nullptr, QJsonValue,
1517             result = nullptr;
1518             return source.isNull();
1519         );
1520         QMETATYPE_CONVERTER(QJsonValue, Bool,
1521             result = QJsonValue(source);
1522             return true;);
1523         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, Int);
1524         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, UInt);
1525         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, Double);
1526         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, Float);
1527         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, ULong);
1528         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, Long);
1529         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, LongLong);
1530         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, ULongLong);
1531         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, UShort);
1532         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, UChar);
1533         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, Char);
1534         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, SChar);
1535         QMETATYPE_CONVERTER_ASSIGN_DOUBLE(QJsonValue, Short);
1536         QMETATYPE_CONVERTER_ASSIGN(QJsonValue, QString);
1537         QMETATYPE_CONVERTER(QJsonValue, QStringList,
1538             result = QJsonValue(QJsonArray::fromStringList(source));
1539             return true;
1540         );
1541         QMETATYPE_CONVERTER(QJsonValue, QVariantList,
1542             result = QJsonValue(QJsonArray::fromVariantList(source));
1543             return true;
1544         );
1545         QMETATYPE_CONVERTER(QJsonValue, QVariantMap,
1546             result = QJsonValue(QJsonObject::fromVariantMap(source));
1547             return true;
1548         );
1549         QMETATYPE_CONVERTER(QJsonValue, QVariantHash,
1550             result = QJsonValue(QJsonObject::fromVariantHash(source));
1551             return true;
1552         );
1553         QMETATYPE_CONVERTER(QJsonValue, QJsonObject,
1554             result = source;
1555             return true;
1556         );
1557         QMETATYPE_CONVERTER(QJsonValue, QJsonArray,
1558             result = source;
1559             return true;
1560         );
1561         QMETATYPE_CONVERTER(QJsonValue, QJsonDocument,
1562             QJsonDocument doc = source;
1563             result = doc.isArray() ? QJsonValue(doc.array()) : QJsonValue(doc.object());
1564             return true;
1565         );
1566         QMETATYPE_CONVERTER(QJsonValue, QCborValue,
1567             result = source.toJsonValue();
1568             return true;
1569         );
1570         QMETATYPE_CONVERTER(QJsonValue, QCborMap,
1571             result = source.toJsonObject();
1572             return true;
1573         );
1574         QMETATYPE_CONVERTER(QJsonValue, QCborArray,
1575             result = source.toJsonArray();
1576             return true;
1577         );
1578 
1579 #endif
1580 
1581         QMETATYPE_CONVERTER(QDate, QDateTime, result = source.date(); return true;);
1582         QMETATYPE_CONVERTER(QTime, QDateTime, result = source.time(); return true;);
1583         QMETATYPE_CONVERTER(QDateTime, QDate, result = source.startOfDay(); return true;);
1584 #if QT_CONFIG(datestring)
1585         QMETATYPE_CONVERTER(QDate, QString,
1586             result = QDate::fromString(source, Qt::ISODate);
1587             return result.isValid();
1588         );
1589         QMETATYPE_CONVERTER(QTime, QString,
1590             result = QTime::fromString(source, Qt::ISODate);
1591             return result.isValid();
1592         );
1593         QMETATYPE_CONVERTER(QDateTime, QString,
1594             result = QDateTime::fromString(source, Qt::ISODate);
1595             return result.isValid();
1596         );
1597 #endif
1598 
1599         }
1600         return false;
1601     }
1602 } metatypeHelper;
1603 
1604 static const QMetaTypeModuleHelper *qMetaTypeCoreHelper = &metatypeHelper;
1605 Q_CORE_EXPORT const QMetaTypeModuleHelper *qMetaTypeGuiHelper = nullptr;
1606 Q_CORE_EXPORT const QMetaTypeModuleHelper *qMetaTypeWidgetsHelper = nullptr;
1607 
1608 static const QMetaTypeModuleHelper *qModuleHelperForType(int type)
1609 {
1610     if (type <= QMetaType::LastCoreType)
1611         return qMetaTypeCoreHelper;
1612     if (type >= QMetaType::FirstGuiType && type <= QMetaType::LastGuiType)
1613         return qMetaTypeGuiHelper;
1614     else if (type >= QMetaType::FirstWidgetsType && type <= QMetaType::LastWidgetsType)
1615         return qMetaTypeWidgetsHelper;
1616     return nullptr;
1617 }
1618 
1619 /*!
1620     \fn bool QMetaType::registerConverter()
1621     \since 5.2
1622     Registers the possibility of an implicit conversion from type From to type To in the meta
1623     type system. Returns \c true if the registration succeeded, otherwise false.
1624 */
1625 
1626 /*!
1627     \fn  template<typename MemberFunction, int> bool QMetaType::registerConverter(MemberFunction function)
1628     \since 5.2
1629     \overload
1630     Registers a method \a function like To From::function() const as converter from type From
1631     to type To in the meta type system. Returns \c true if the registration succeeded, otherwise false.
1632 */
1633 
1634 /*!
1635     \fn template<typename MemberFunctionOk, char> bool QMetaType::registerConverter(MemberFunctionOk function)
1636     \since 5.2
1637     \overload
1638     Registers a method \a function like To From::function(bool *ok) const as converter from type From
1639     to type To in the meta type system. Returns \c true if the registration succeeded, otherwise false.
1640 */
1641 
1642 /*!
1643     \fn template<typename UnaryFunction> bool QMetaType::registerConverter(UnaryFunction function)
1644     \since 5.2
1645     \overload
1646     Registers a unary function object \a function as converter from type From
1647     to type To in the meta type system. Returns \c true if the registration succeeded, otherwise false.
1648 */
1649 
1650 /*!
1651     Registers function \a f as converter function from type id \a from to \a to.
1652     If there's already a conversion registered, this does nothing but deleting \a f.
1653     Returns \c true if the registration succeeded, otherwise false.
1654     \since 5.2
1655     \internal
1656 */
1657 bool QMetaType::registerConverterFunction(const ConverterFunction &f, QMetaType from, QMetaType to)
1658 {
1659     if (!customTypeRegistry()->converters->insertIfNotContains(qMakePair(from.id(), to.id()), f)) {
1660         qWarning("Type conversion already registered from type %s to type %s",
1661                  from.name(), to.name());
1662         return false;
1663     }
1664     return true;
1665 }
1666 
1667 /*!
1668     \fn  template<typename MemberFunction, int> bool QMetaType::registerMutableView(MemberFunction function)
1669     \since 6.0
1670     \overload
1671     Registers a method \a function like \c {To From::function()} as mutable view of type \c {To} on
1672     type \c {From} in the meta type system. Returns \c true if the registration succeeded, otherwise
1673     \c false.
1674 */
1675 
1676 /*!
1677     \fn template<typename MemberFunctionOk, char> bool QMetaType::registerMutableView(MemberFunctionOk function)
1678     \since 6.0
1679     \overload
1680     Registers a method \a function like To From::function(bool *ok) as mutable view of type To on
1681     type From in the meta type system. Returns \c true if the registration succeeded, otherwise
1682     \c false.
1683 */
1684 
1685 /*!
1686     \fn template<typename UnaryFunction> bool QMetaType::registerMutableView(UnaryFunction function)
1687     \since 6.0
1688     \overload
1689     Registers a unary function object \a function as mutable view of type To on type From
1690     in the meta type system. Returns \c true if the registration succeeded, otherwise \c false.
1691 */
1692 
1693 /*!
1694     Registers function \a f as mutable view of type id \a to on type id \a from.
1695     Returns \c true if the registration succeeded, otherwise \c false.
1696     \since 6.0
1697     \internal
1698 */
1699 bool QMetaType::registerMutableViewFunction(const MutableViewFunction &f, QMetaType from, QMetaType to)
1700 {
1701     if (!customTypeRegistry()->mutableViews->insertIfNotContains(qMakePair(from.id(), to.id()), f)) {
1702         qWarning("Mutable view on type already registered from type %s to type %s",
1703                  from.name(), to.name());
1704         return false;
1705     }
1706     return true;
1707 }
1708 
1709 /*!
1710     \internal
1711  */
1712 void QMetaType::unregisterMutableViewFunction(QMetaType from, QMetaType to)
1713 {
1714     if (customTypeRegistry.isDestroyed())
1715         return;
1716     customTypeRegistry->mutableViews->remove(from.id(), to.id());
1717 }
1718 
1719 /*!
1720     \internal
1721 
1722     Invoked automatically when a converter function object is destroyed.
1723  */
1724 void QMetaType::unregisterConverterFunction(QMetaType from, QMetaType to)
1725 {
1726     if (customTypeRegistry.isDestroyed())
1727         return;
1728     customTypeRegistry->converters->remove(from.id(), to.id());
1729 }
1730 
1731 #ifndef QT_NO_DEBUG_STREAM
1732 
1733 /*!
1734     Streams the object at \a rhs to the debug stream \a dbg. Returns \c true
1735     on success, otherwise false.
1736     \since 5.2
1737 */
1738 bool QMetaType::debugStream(QDebug& dbg, const void *rhs)
1739 {
1740     if (d_ptr && d_ptr->flags & QMetaType::IsPointer) {
1741         dbg << *reinterpret_cast<const void * const *>(rhs);
1742         return true;
1743     }
1744     if (d_ptr && d_ptr->debugStream) {
1745         d_ptr->debugStream(d_ptr, dbg, rhs);
1746         return true;
1747     }
1748     return false;
1749 }
1750 
1751 /*!
1752     \fn bool QMetaType::debugStream(QDebug& dbg, const void *rhs, int typeId)
1753     \overload
1754     \deprecated
1755 */
1756 
1757 /*!
1758     \fn bool QMetaType::hasRegisteredDebugStreamOperator()
1759     \deprecated
1760     \since 5.2
1761 
1762     Returns \c true, if the meta type system has a registered debug stream operator for type T.
1763  */
1764 
1765 /*!
1766     \fn bool QMetaType::hasRegisteredDebugStreamOperator(int typeId)
1767     \deprecated Use QMetaType::hasRegisteredDebugStreamOperator() instead.
1768 
1769     Returns \c true, if the meta type system has a registered debug stream operator for type
1770     id \a typeId.
1771     \since 5.2
1772 */
1773 
1774 /*!
1775     \since 6.0
1776 
1777     Returns \c true, if the meta type system has a registered debug stream operator for this
1778     meta type.
1779 */
1780 bool QMetaType::hasRegisteredDebugStreamOperator() const
1781 {
1782     return d_ptr && d_ptr->debugStream != nullptr;
1783 }
1784 #endif
1785 
1786 #ifndef QT_NO_QOBJECT
1787 /*!
1788   \internal
1789   returns a QMetaEnum for a given meta tape type id if possible
1790 */
1791 static QMetaEnum metaEnumFromType(QMetaType t)
1792 {
1793     if (t.flags() & QMetaType::IsEnumeration) {
1794         if (const QMetaObject *metaObject = t.metaObject()) {
1795             const QByteArray enumName = t.name();
1796             const char *lastColon = std::strrchr(enumName, ':');
1797             return metaObject->enumerator(metaObject->indexOfEnumerator(
1798                     lastColon ? lastColon + 1 : enumName.constData()));
1799         }
1800     }
1801     return QMetaEnum();
1802 }
1803 #endif
1804 
1805 static bool convertFromEnum(QMetaType fromType, const void *from, QMetaType toType, void *to)
1806 {
1807     qlonglong ll;
1808     if (fromType.flags() & QMetaType::IsUnsignedEnumeration) {
1809         qulonglong ull;
1810         switch (fromType.sizeOf()) {
1811         case 1:
1812             ull = *static_cast<const unsigned char *>(from);
1813             break;
1814         case 2:
1815             ull = *static_cast<const unsigned short *>(from);
1816             break;
1817         case 4:
1818             ull = *static_cast<const unsigned int *>(from);
1819             break;
1820         case 8:
1821             ull = *static_cast<const quint64 *>(from);
1822             break;
1823         default:
1824             Q_UNREACHABLE();
1825         }
1826         if (toType.id() == QMetaType::ULongLong) {
1827             *static_cast<qulonglong *>(to) = ull;
1828             return true;
1829         }
1830         if (toType.id() != QMetaType::QString && toType.id() != QMetaType::QByteArray)
1831             return QMetaType::convert(QMetaType::fromType<qulonglong>(), &ull, toType, to);
1832         ll = qlonglong(ull);
1833     } else {
1834         switch (fromType.sizeOf()) {
1835         case 1:
1836             ll = *static_cast<const signed char *>(from);
1837             break;
1838         case 2:
1839             ll = *static_cast<const short *>(from);
1840             break;
1841         case 4:
1842             ll = *static_cast<const int *>(from);
1843             break;
1844         case 8:
1845             ll = *static_cast<const qint64 *>(from);
1846             break;
1847         default:
1848             Q_UNREACHABLE();
1849         }
1850         if (toType.id() == QMetaType::LongLong) {
1851             *static_cast<qlonglong *>(to) = ll;
1852             return true;
1853         }
1854         if (toType.id() != QMetaType::QString && toType.id() != QMetaType::QByteArray)
1855             return QMetaType::convert(QMetaType::fromType<qlonglong>(), &ll, toType, to);
1856     }
1857     Q_ASSERT(toType.id() == QMetaType::QString || toType.id() == QMetaType::QByteArray);
1858 #ifndef QT_NO_QOBJECT
1859     QMetaEnum en = metaEnumFromType(fromType);
1860     if (en.isValid()) {
1861         const char *key = en.valueToKey(ll);
1862         if (toType.id() == QMetaType::QString)
1863             *static_cast<QString *>(to) = QString::fromUtf8(key);
1864         else
1865             *static_cast<QByteArray *>(to) = key;
1866         return true;
1867     }
1868 #endif
1869     return false;
1870 }
1871 
1872 static bool convertToEnum(QMetaType fromType, const void *from, QMetaType toType, void *to)
1873 {
1874     int fromTypeId = fromType.id();
1875     qlonglong value = -1;
1876     bool ok = false;
1877 #ifndef QT_NO_QOBJECT
1878     if (fromTypeId == QMetaType::QString || fromTypeId == QMetaType::QByteArray) {
1879         QMetaEnum en = metaEnumFromType(toType);
1880         if (!en.isValid())
1881             return false;
1882         QByteArray keys = (fromTypeId == QMetaType::QString)
1883                 ? static_cast<const QString *>(from)->toUtf8()
1884                 : *static_cast<const QByteArray *>(from);
1885         value = en.keysToValue(keys.constData(), &ok);
1886     }
1887 #endif
1888     if (!ok) {
1889         if (fromTypeId == QMetaType::LongLong) {
1890             value = *static_cast<const qlonglong *>(from);
1891             ok = true;
1892         } else {
1893             ok = QMetaType::convert(fromType, from, QMetaType::fromType<qlonglong>(), &value);
1894         }
1895     }
1896 
1897     if (!ok)
1898         return false;
1899 
1900     switch (toType.sizeOf()) {
1901     case 1:
1902         *static_cast<signed char *>(to) = value;
1903         return true;
1904     case 2:
1905         *static_cast<qint16 *>(to) = value;
1906         return true;
1907     case 4:
1908         *static_cast<qint32 *>(to) = value;
1909         return true;
1910     case 8:
1911         *static_cast<qint64 *>(to) = value;
1912         return true;
1913     default:
1914         Q_UNREACHABLE();
1915         return false;
1916     }
1917 }
1918 
1919 #ifndef QT_BOOTSTRAPPED
1920 static bool convertIterableToVariantList(QMetaType fromType, const void *from, void *to)
1921 {
1922     QSequentialIterable list;
1923     if (!QMetaType::convert(fromType, from, QMetaType::fromType<QSequentialIterable>(), &list))
1924         return false;
1925 
1926     QVariantList &l = *static_cast<QVariantList *>(to);
1927     l.clear();
1928     l.reserve(list.size());
1929     auto end = list.end();
1930     for (auto it = list.begin(); it != end; ++it)
1931         l << *it;
1932     return true;
1933 }
1934 
1935 static bool convertIterableToVariantMap(QMetaType fromType, const void *from, void *to)
1936 {
1937     QAssociativeIterable map;
1938     if (!QMetaType::convert(fromType, from, QMetaType::fromType<QAssociativeIterable>(), &map))
1939         return false;
1940 
1941     QVariantMap &h = *static_cast<QVariantMap *>(to);
1942     h.clear();
1943     auto end = map.end();
1944     for (auto it = map.begin(); it != end; ++it)
1945         h.insert(it.key().toString(), it.value());
1946     return true;
1947 }
1948 
1949 static bool convertIterableToVariantHash(QMetaType fromType, const void *from, void *to)
1950 {
1951     QAssociativeIterable map;
1952     if (!QMetaType::convert(fromType, from, QMetaType::fromType<QAssociativeIterable>(), &map))
1953         return false;
1954 
1955     QVariantHash &h = *static_cast<QVariantHash *>(to);
1956     h.clear();
1957     h.reserve(map.size());
1958     auto end = map.end();
1959     for (auto it = map.begin(); it != end; ++it)
1960         h.insert(it.key().toString(), it.value());
1961     return true;
1962 }
1963 #endif
1964 
1965 static bool convertIterableToVariantPair(QMetaType fromType, const void *from, void *to)
1966 {
1967     const QMetaType::ConverterFunction * const f =
1968         customTypeRegistry()->converters->function(qMakePair(fromType.id(),
1969                                                             qMetaTypeId<QtMetaTypePrivate::QPairVariantInterfaceImpl>()));
1970     if (!f)
1971         return false;
1972 
1973     QtMetaTypePrivate::QPairVariantInterfaceImpl pi;
1974     (*f)(from, &pi);
1975 
1976     QVariant v1(pi._metaType_first);
1977     void *dataPtr;
1978     if (pi._metaType_first == QMetaType::fromType<QVariant>())
1979         dataPtr = &v1;
1980     else
1981         dataPtr = v1.data();
1982     pi.first(dataPtr);
1983 
1984     QVariant v2(pi._metaType_second);
1985     if (pi._metaType_second == QMetaType::fromType<QVariant>())
1986         dataPtr = &v2;
1987     else
1988         dataPtr = v2.data();
1989     pi.second(dataPtr);
1990 
1991     *static_cast<QVariantPair *>(to) = QVariantPair(v1, v2);
1992     return true;
1993 }
1994 
1995 #ifndef QT_BOOTSTRAPPED
1996 static bool convertToSequentialIterable(QMetaType fromType, const void *from, void *to)
1997 {
1998     using namespace QtMetaTypePrivate;
1999     const int fromTypeId = fromType.id();
2000 
2001     QSequentialIterable &i = *static_cast<QSequentialIterable *>(to);
2002     switch (fromTypeId) {
2003     case QMetaType::QVariantList:
2004         i = QSequentialIterable(reinterpret_cast<const QVariantList *>(from));
2005         return true;
2006     case QMetaType::QStringList:
2007         i = QSequentialIterable(reinterpret_cast<const QStringList *>(from));
2008         return true;
2009     case QMetaType::QByteArrayList:
2010         i = QSequentialIterable(reinterpret_cast<const QByteArrayList *>(from));
2011         return true;
2012     case QMetaType::QString:
2013         i = QSequentialIterable(reinterpret_cast<const QString *>(from));
2014         return true;
2015     case QMetaType::QByteArray:
2016         i = QSequentialIterable(reinterpret_cast<const QByteArray *>(from));
2017         return true;
2018     default: {
2019         QSequentialIterable impl;
2020         if (QMetaType::convert(
2021                     fromType, from, QMetaType::fromType<QIterable<QMetaSequence>>(), &impl)) {
2022             i = std::move(impl);
2023             return true;
2024         }
2025     }
2026     }
2027 
2028     return false;
2029 }
2030 
2031 static bool canConvertToSequentialIterable(QMetaType fromType)
2032 {
2033     switch (fromType.id()) {
2034     case QMetaType::QVariantList:
2035     case QMetaType::QStringList:
2036     case QMetaType::QByteArrayList:
2037     case QMetaType::QString:
2038     case QMetaType::QByteArray:
2039         return true;
2040     default:
2041         return QMetaType::canConvert(fromType, QMetaType::fromType<QIterable<QMetaSequence>>());
2042     }
2043 }
2044 
2045 static bool canImplicitlyViewAsSequentialIterable(QMetaType fromType)
2046 {
2047     switch (fromType.id()) {
2048     case QMetaType::QVariantList:
2049     case QMetaType::QStringList:
2050     case QMetaType::QByteArrayList:
2051     case QMetaType::QString:
2052     case QMetaType::QByteArray:
2053         return true;
2054     default:
2055         return QMetaType::canView(
2056                     fromType, QMetaType::fromType<QIterable<QMetaSequence>>());
2057     }
2058 }
2059 
2060 static bool viewAsSequentialIterable(QMetaType fromType, void *from, void *to)
2061 {
2062     using namespace QtMetaTypePrivate;
2063     const int fromTypeId = fromType.id();
2064 
2065     QSequentialIterable &i = *static_cast<QSequentialIterable *>(to);
2066     switch (fromTypeId) {
2067     case QMetaType::QVariantList:
2068         i = QSequentialIterable(reinterpret_cast<QVariantList *>(from));
2069         return true;
2070     case QMetaType::QStringList:
2071         i = QSequentialIterable(reinterpret_cast<QStringList *>(from));
2072         return true;
2073     case QMetaType::QByteArrayList:
2074         i = QSequentialIterable(reinterpret_cast<QByteArrayList *>(from));
2075         return true;
2076     case QMetaType::QString:
2077         i = QSequentialIterable(reinterpret_cast<QString *>(from));
2078         return true;
2079     case QMetaType::QByteArray:
2080         i = QSequentialIterable(reinterpret_cast<QByteArray *>(from));
2081         return true;
2082     default: {
2083         QIterable<QMetaSequence> j(QMetaSequence(), nullptr);
2084         if (QMetaType::view(
2085                     fromType, from, QMetaType::fromType<QIterable<QMetaSequence>>(), &j)) {
2086             i = std::move(j);
2087             return true;
2088         }
2089     }
2090     }
2091 
2092     return false;
2093 }
2094 
2095 static bool convertToAssociativeIterable(QMetaType fromType, const void *from, void *to)
2096 {
2097     using namespace QtMetaTypePrivate;
2098 
2099     QAssociativeIterable &i = *static_cast<QAssociativeIterable *>(to);
2100     if (fromType.id() == QMetaType::QVariantMap) {
2101         i = QAssociativeIterable(reinterpret_cast<const QVariantMap *>(from));
2102         return true;
2103     }
2104     if (fromType.id() == QMetaType::QVariantHash) {
2105         i = QAssociativeIterable(reinterpret_cast<const QVariantHash *>(from));
2106         return true;
2107     }
2108 
2109     QAssociativeIterable impl;
2110     if (QMetaType::convert(
2111                 fromType, from, QMetaType::fromType<QIterable<QMetaAssociation>>(), &impl)) {
2112         i = std::move(impl);
2113         return true;
2114     }
2115 
2116     return false;
2117 }
2118 
2119 static bool canConvertMetaObject(QMetaType fromType, QMetaType toType)
2120 {
2121     const QMetaObject *f = fromType.metaObject();
2122     const QMetaObject *t = toType.metaObject();
2123     if (f && t) {
2124         return f->inherits(t) || (t->inherits(f));
2125     }
2126     return false;
2127 }
2128 
2129 static bool canConvertToAssociativeIterable(QMetaType fromType)
2130 {
2131     switch (fromType.id()) {
2132     case QMetaType::QVariantMap:
2133     case QMetaType::QVariantHash:
2134         return true;
2135     default:
2136         return QMetaType::canConvert(fromType, QMetaType::fromType<QIterable<QMetaAssociation>>());
2137     }
2138 }
2139 
2140 static bool canImplicitlyViewAsAssociativeIterable(QMetaType fromType)
2141 {
2142     switch (fromType.id()) {
2143     case QMetaType::QVariantMap:
2144     case QMetaType::QVariantHash:
2145         return true;
2146     default:
2147         return QMetaType::canView(
2148                     fromType, QMetaType::fromType<QIterable<QMetaAssociation>>());
2149     }
2150 }
2151 
2152 static bool viewAsAssociativeIterable(QMetaType fromType, void *from, void *to)
2153 {
2154     using namespace QtMetaTypePrivate;
2155     int fromTypeId = fromType.id();
2156 
2157     QAssociativeIterable &i = *static_cast<QAssociativeIterable *>(to);
2158     if (fromTypeId == QMetaType::QVariantMap) {
2159         i = QAssociativeIterable(reinterpret_cast<QVariantMap *>(from));
2160         return true;
2161     }
2162     if (fromTypeId == QMetaType::QVariantHash) {
2163         i = QAssociativeIterable(reinterpret_cast<QVariantHash *>(from));
2164         return true;
2165     }
2166 
2167     QIterable<QMetaAssociation> j(QMetaAssociation(), nullptr);
2168     if (QMetaType::view(
2169                 fromType, from, QMetaType::fromType<QIterable<QMetaAssociation>>(), &j)) {
2170         i = std::move(j);
2171         return true;
2172     }
2173 
2174     return false;
2175 }
2176 
2177 static bool convertQObject(QMetaType fromType, const void *from, QMetaType toType, void *to)
2178 {
2179     // handle QObject conversion
2180     if ((fromType.flags() & QMetaType::PointerToQObject) && (toType.flags() & QMetaType::PointerToQObject)) {
2181         QObject *fromObject = *static_cast<QObject * const *>(from);
2182         // use dynamic metatype of from if possible
2183         if (fromObject && fromObject->metaObject()->inherits(toType.metaObject()))  {
2184             *static_cast<QObject **>(to) = toType.metaObject()->cast(fromObject);
2185             return true;
2186         } else if (!fromObject && fromType.metaObject()) {
2187             // if fromObject is null, use static fromType to check if conversion works
2188             *static_cast<void **>(to) = nullptr;
2189             return fromType.metaObject()->inherits(toType.metaObject());
2190         } else {
2191             return false;
2192         }
2193     }
2194     return false;
2195 }
2196 #endif
2197 
2198 /*!
2199     \fn bool QMetaType::convert(const void *from, int fromTypeId, void *to, int toTypeId)
2200     \deprecated
2201 
2202     Converts the object at \a from from \a fromTypeId to the preallocated space at \a to
2203     typed \a toTypeId. Returns \c true, if the conversion succeeded, otherwise false.
2204 
2205     Both \a from and \a to have to be valid pointers.
2206 
2207     \since 5.2
2208 */
2209 
2210 /*!
2211     Converts the object at \a from from \a fromType to the preallocated space at \a to
2212     typed \a toType. Returns \c true, if the conversion succeeded, otherwise false.
2213 
2214     Both \a from and \a to have to be valid pointers.
2215 
2216     \since 5.2
2217 */
2218 bool QMetaType::convert(QMetaType fromType, const void *from, QMetaType toType, void *to)
2219 {
2220     if (!fromType.isValid() || !toType.isValid())
2221         return false;
2222 
2223     if (fromType == toType) {
2224         // just make a copy
2225         fromType.destruct(to);
2226         fromType.construct(to, from);
2227         return true;
2228     }
2229 
2230     int fromTypeId = fromType.id();
2231     int toTypeId = toType.id();
2232 
2233     if (auto moduleHelper = qModuleHelperForType(qMax(fromTypeId, toTypeId))) {
2234         if (moduleHelper->convert(from, fromTypeId, to, toTypeId))
2235             return true;
2236     }
2237     const QMetaType::ConverterFunction * const f =
2238         customTypeRegistry()->converters->function(qMakePair(fromTypeId, toTypeId));
2239     if (f)
2240         return (*f)(from, to);
2241 
2242     if (fromType.flags() & QMetaType::IsEnumeration)
2243         return convertFromEnum(fromType, from, toType, to);
2244     if (toType.flags() & QMetaType::IsEnumeration)
2245         return convertToEnum(fromType, from, toType, to);
2246     if (toTypeId == Nullptr) {
2247         *static_cast<std::nullptr_t *>(to) = nullptr;
2248         if (fromType.flags() & QMetaType::IsPointer) {
2249             if (*static_cast<const void * const *>(from) == nullptr)
2250                 return true;
2251         }
2252     }
2253 
2254     if (toTypeId == QVariantPair && convertIterableToVariantPair(fromType, from, to))
2255         return true;
2256 
2257 #ifndef QT_BOOTSTRAPPED
2258     // handle iterables
2259     if (toTypeId == QVariantList && convertIterableToVariantList(fromType, from, to))
2260         return true;
2261 
2262     if (toTypeId == QVariantMap && convertIterableToVariantMap(fromType, from, to))
2263         return true;
2264 
2265     if (toTypeId == QVariantHash && convertIterableToVariantHash(fromType, from, to))
2266         return true;
2267 
2268     if (toTypeId == qMetaTypeId<QSequentialIterable>())
2269         return convertToSequentialIterable(fromType, from, to);
2270 
2271     if (toTypeId == qMetaTypeId<QAssociativeIterable>())
2272         return convertToAssociativeIterable(fromType, from, to);
2273 
2274     return convertQObject(fromType, from, toType, to);
2275 #else
2276     return false;
2277 #endif
2278 }
2279 
2280 /*!
2281     Creates a mutable view on the object at \a from of \a fromType in the preallocated space at
2282     \a to typed \a toType. Returns \c true if the conversion succeeded, otherwise false.
2283     \since 6.0
2284 */
2285 bool QMetaType::view(QMetaType fromType, void *from, QMetaType toType, void *to)
2286 {
2287     if (!fromType.isValid() || !toType.isValid())
2288         return false;
2289 
2290     int fromTypeId = fromType.id();
2291     int toTypeId = toType.id();
2292 
2293     const QMetaType::MutableViewFunction * const f =
2294         customTypeRegistry()->mutableViews->function(qMakePair(fromTypeId, toTypeId));
2295     if (f)
2296         return (*f)(from, to);
2297 
2298 #ifndef QT_BOOTSTRAPPED
2299     if (toTypeId == qMetaTypeId<QSequentialIterable>())
2300         return viewAsSequentialIterable(fromType, from, to);
2301 
2302     if (toTypeId == qMetaTypeId<QAssociativeIterable>())
2303         return viewAsAssociativeIterable(fromType, from, to);
2304 
2305     return convertQObject(fromType, from, toType, to);
2306 #else
2307     return false;
2308 #endif
2309 }
2310 
2311 /*!
2312     Returns \c true if QMetaType::view can create a mutable view of type \a toType
2313     on type \a fromType.
2314 
2315     Converting between pointers of types derived from QObject will return true for this
2316     function if a qobject_cast from the type described by \a fromType to the type described
2317     by \a toType would succeed.
2318 
2319     You can create a mutable view of type QSequentialIterable on any container registered with
2320     Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE().
2321 
2322     Similarly you can create a mutable view of type QAssociativeIterable on any container
2323     registered with Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE().
2324 
2325     \sa convert(), QSequentialIterable, Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(),
2326         QAssociativeIterable, Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE()
2327 */
2328 bool QMetaType::canView(QMetaType fromType, QMetaType toType)
2329 {
2330     int fromTypeId = fromType.id();
2331     int toTypeId = toType.id();
2332 
2333     if (fromTypeId == UnknownType || toTypeId == UnknownType)
2334         return false;
2335 
2336     const MutableViewFunction * const f =
2337         customTypeRegistry()->mutableViews->function(qMakePair(fromTypeId, toTypeId));
2338     if (f)
2339         return true;
2340 
2341 #ifndef QT_BOOTSTRAPPED
2342     if (toTypeId == qMetaTypeId<QSequentialIterable>())
2343         return canImplicitlyViewAsSequentialIterable(fromType);
2344 
2345     if (toTypeId == qMetaTypeId<QAssociativeIterable>())
2346         return canImplicitlyViewAsAssociativeIterable(fromType);
2347 
2348     if (canConvertMetaObject(fromType, toType))
2349         return true;
2350 #endif
2351 
2352     return false;
2353 }
2354 
2355 /*!
2356     Returns \c true if QMetaType::convert can convert from \a fromType to
2357     \a toType.
2358 
2359     The following conversions are supported by Qt:
2360 
2361     \table
2362     \header \li Type \li Automatically Cast To
2363     \row \li \l QMetaType::Bool \li \l QMetaType::QChar, \l QMetaType::Double,
2364         \l QMetaType::Int, \l QMetaType::LongLong, \l QMetaType::QString,
2365         \l QMetaType::UInt, \l QMetaType::ULongLong
2366     \row \li \l QMetaType::QByteArray \li \l QMetaType::Double,
2367         \l QMetaType::Int, \l QMetaType::LongLong, \l QMetaType::QString,
2368         \l QMetaType::UInt, \l QMetaType::ULongLong, \l QMetaType::QUuid
2369     \row \li \l QMetaType::QChar \li \l QMetaType::Bool, \l QMetaType::Int,
2370         \l QMetaType::UInt, \l QMetaType::LongLong, \l QMetaType::ULongLong
2371     \row \li \l QMetaType::QColor \li \l QMetaType::QString
2372     \row \li \l QMetaType::QDate \li \l QMetaType::QDateTime,
2373         \l QMetaType::QString
2374     \row \li \l QMetaType::QDateTime \li \l QMetaType::QDate,
2375         \l QMetaType::QString, \l QMetaType::QTime
2376     \row \li \l QMetaType::Double \li \l QMetaType::Bool, \l QMetaType::Int,
2377         \l QMetaType::LongLong, \l QMetaType::QString, \l QMetaType::UInt,
2378         \l QMetaType::ULongLong
2379     \row \li \l QMetaType::QFont \li \l QMetaType::QString
2380     \row \li \l QMetaType::Int \li \l QMetaType::Bool, \l QMetaType::QChar,
2381         \l QMetaType::Double, \l QMetaType::LongLong, \l QMetaType::QString,
2382         \l QMetaType::UInt, \l QMetaType::ULongLong
2383     \row \li \l QMetaType::QKeySequence \li \l QMetaType::Int,
2384         \l QMetaType::QString
2385     \row \li \l QMetaType::QVariantList \li \l QMetaType::QStringList (if the
2386         list's items can be converted to QStrings)
2387     \row \li \l QMetaType::LongLong \li \l QMetaType::Bool,
2388         \l QMetaType::QByteArray, \l QMetaType::QChar, \l QMetaType::Double,
2389         \l QMetaType::Int, \l QMetaType::QString, \l QMetaType::UInt,
2390         \l QMetaType::ULongLong
2391     \row \li \l QMetaType::QPoint \li QMetaType::QPointF
2392     \row \li \l QMetaType::QRect \li QMetaType::QRectF
2393     \row \li \l QMetaType::QString \li \l QMetaType::Bool,
2394         \l QMetaType::QByteArray, \l QMetaType::QChar, \l QMetaType::QColor,
2395         \l QMetaType::QDate, \l QMetaType::QDateTime, \l QMetaType::Double,
2396         \l QMetaType::QFont, \l QMetaType::Int, \l QMetaType::QKeySequence,
2397         \l QMetaType::LongLong, \l QMetaType::QStringList, \l QMetaType::QTime,
2398         \l QMetaType::UInt, \l QMetaType::ULongLong, \l QMetaType::QUuid
2399     \row \li \l QMetaType::QStringList \li \l QMetaType::QVariantList,
2400         \l QMetaType::QString (if the list contains exactly one item)
2401     \row \li \l QMetaType::QTime \li \l QMetaType::QString
2402     \row \li \l QMetaType::UInt \li \l QMetaType::Bool, \l QMetaType::QChar,
2403         \l QMetaType::Double, \l QMetaType::Int, \l QMetaType::LongLong,
2404         \l QMetaType::QString, \l QMetaType::ULongLong
2405     \row \li \l QMetaType::ULongLong \li \l QMetaType::Bool,
2406         \l QMetaType::QChar, \l QMetaType::Double, \l QMetaType::Int,
2407         \l QMetaType::LongLong, \l QMetaType::QString, \l QMetaType::UInt
2408     \row \li \l QMetaType::QUuid \li \l QMetaType::QByteArray, \l QMetaType::QString
2409     \endtable
2410 
2411     Casting between primitive type (int, float, bool etc.) is supported.
2412 
2413     Converting between pointers of types derived from QObject will also return true for this
2414     function if a qobject_cast from the type described by \a fromType to the type described
2415     by \a toType would succeed.
2416 
2417     A cast from a sequential container will also return true for this
2418     function if the \a toType is QVariantList.
2419 
2420     Similarly, a cast from an associative container will also return true for this
2421     function the \a toType is QVariantHash or QVariantMap.
2422 
2423     \sa convert(), QSequentialIterable, Q_DECLARE_SEQUENTIAL_CONTAINER_METATYPE(), QAssociativeIterable,
2424         Q_DECLARE_ASSOCIATIVE_CONTAINER_METATYPE()
2425 */
2426 bool QMetaType::canConvert(QMetaType fromType, QMetaType toType)
2427 {
2428     int fromTypeId = fromType.id();
2429     int toTypeId = toType.id();
2430 
2431     if (fromTypeId == UnknownType || toTypeId == UnknownType)
2432         return false;
2433 
2434     if (fromTypeId == toTypeId)
2435         return true;
2436 
2437     if (auto moduleHelper = qModuleHelperForType(qMax(fromTypeId, toTypeId))) {
2438         if (moduleHelper->convert(nullptr, fromTypeId, nullptr, toTypeId))
2439             return true;
2440     }
2441     const ConverterFunction * const f =
2442         customTypeRegistry()->converters->function(qMakePair(fromTypeId, toTypeId));
2443     if (f)
2444         return true;
2445 
2446 #ifndef QT_BOOTSTRAPPED
2447     if (toTypeId == qMetaTypeId<QSequentialIterable>())
2448         return canConvertToSequentialIterable(fromType);
2449 
2450     if (toTypeId == qMetaTypeId<QAssociativeIterable>())
2451         return canConvertToAssociativeIterable(fromType);
2452 
2453     if (toTypeId == QVariantList
2454             && canConvert(fromType, QMetaType::fromType<QSequentialIterable>())) {
2455         return true;
2456     }
2457 
2458     if ((toTypeId == QVariantHash || toTypeId == QVariantMap)
2459             && canConvert(fromType, QMetaType::fromType<QAssociativeIterable>())) {
2460         return true;
2461     }
2462 #endif
2463 
2464     if (toTypeId == QVariantPair && hasRegisteredConverterFunction(
2465                     fromType, QMetaType::fromType<QtMetaTypePrivate::QPairVariantInterfaceImpl>()))
2466         return true;
2467 
2468     if (fromType.flags() & IsEnumeration) {
2469         if (toTypeId == QString || toTypeId == QByteArray)
2470             return true;
2471         return canConvert(QMetaType(LongLong), toType);
2472     }
2473     if (toType.flags() & IsEnumeration) {
2474         if (fromTypeId == QString || fromTypeId == QByteArray)
2475             return true;
2476         return canConvert(fromType, QMetaType(LongLong));
2477     }
2478     if (toTypeId == Nullptr && fromType.flags() & IsPointer)
2479         return true;
2480 #ifndef QT_BOOTSTRAPPED
2481     if (canConvertMetaObject(fromType, toType))
2482         return true;
2483 #endif
2484 
2485     return false;
2486 }
2487 
2488 /*!
2489     \fn bool QMetaType::compare(const void *lhs, const void *rhs, int typeId, int* result)
2490     \deprecated Use the non-static compare method instead
2491 
2492     Compares the objects at \a lhs and \a rhs. Both objects need to be of type \a typeId.
2493     \a result is set to less than, equal to or greater than zero, if \a lhs is less than, equal to
2494     or greater than \a rhs. Returns \c true, if the comparison succeeded, otherwise \c false.
2495 */
2496 
2497 /*!
2498     \fn bool QMetaType::hasRegisteredConverterFunction()
2499     Returns \c true, if the meta type system has a registered conversion from type From to type To.
2500     \since 5.2
2501     \overload
2502     */
2503 
2504 /*!
2505     Returns \c true, if the meta type system has a registered conversion from meta type id \a fromType
2506     to \a toType
2507     \since 5.2
2508 */
2509 bool QMetaType::hasRegisteredConverterFunction(QMetaType fromType, QMetaType toType)
2510 {
2511     return customTypeRegistry()->converters->contains(qMakePair(fromType.id(), toType.id()));
2512 }
2513 
2514 /*!
2515     \fn bool QMetaType::hasRegisteredMutableViewFunction()
2516     Returns \c true, if the meta type system has a registered mutable view on type From of type To.
2517     \since 6.0
2518     \overload
2519 */
2520 
2521 /*!
2522     Returns \c true, if the meta type system has a registered mutable view on meta type id
2523     \a fromType of meta type id \a toType.
2524     \since 5.2
2525 */
2526 bool QMetaType::hasRegisteredMutableViewFunction(QMetaType fromType, QMetaType toType)
2527 {
2528     return customTypeRegistry()->mutableViews->contains(qMakePair(fromType.id(), toType.id()));
2529 }
2530 
2531 /*!
2532     \fn const char *QMetaType::typeName(int typeId)
2533     \deprecated
2534 
2535     Returns the type name associated with the given \a typeId, or a null
2536     pointer if no matching type was found. The returned pointer must not be
2537     deleted.
2538 
2539     \sa type(), isRegistered(), Type, name()
2540 */
2541 
2542 /*!
2543     \fn constexpr const char *QMetaType::name() const
2544     \since 5.15
2545 
2546     Returns the type name associated with this QMetaType, or a null
2547     pointer if no matching type was found. The returned pointer must not be
2548     deleted.
2549 
2550     \sa typeName()
2551 */
2552 
2553 /*
2554     Similar to QMetaType::type(), but only looks in the static set of types.
2555 */
2556 static inline int qMetaTypeStaticType(const char *typeName, int length)
2557 {
2558     int i = 0;
2559     while (types[i].typeName && ((length != types[i].typeNameLength)
2560                                  || memcmp(typeName, types[i].typeName, length))) {
2561         ++i;
2562     }
2563     return types[i].type;
2564 }
2565 
2566 /*
2567     Similar to QMetaType::type(), but only looks in the custom set of
2568     types, and doesn't lock the mutex.
2569 
2570 */
2571 static int qMetaTypeCustomType_unlocked(const char *typeName, int length)
2572 {
2573     if (auto reg = customTypeRegistry()) {
2574 #if QT_CONFIG(thread)
2575         Q_ASSERT(!reg->lock.tryLockForWrite());
2576 #endif
2577         if (auto ti = reg->aliases.value(QByteArray(typeName, length), nullptr)) {
2578             return ti->typeId;
2579         }
2580     }
2581     return QMetaType::UnknownType;
2582 }
2583 
2584 /*!
2585     \internal
2586 
2587     Registers a user type for marshalling, as an alias of another type (typedef).
2588     Note that normalizedTypeName is not checked for conformance with Qt's normalized format,
2589     so it must already conform.
2590 */
2591 void QMetaType::registerNormalizedTypedef(const NS(QByteArray) & normalizedTypeName,
2592                                           QMetaType metaType)
2593 {
2594     if (!metaType.isValid())
2595         return;
2596     if (auto reg = customTypeRegistry()) {
2597         QWriteLocker lock(&reg->lock);
2598         auto &al = reg->aliases[normalizedTypeName];
2599         if (al)
2600             return;
2601         al = metaType.d_ptr;
2602     }
2603 }
2604 
2605 /*!
2606     Returns \c true if the datatype with ID \a type is registered;
2607     otherwise returns \c false.
2608 
2609     \sa type(), typeName(), Type
2610 */
2611 bool QMetaType::isRegistered(int type)
2612 {
2613     return QMetaType(type).isRegistered();
2614 }
2615 
2616 template <bool tryNormalizedType>
2617 static inline int qMetaTypeTypeImpl(const char *typeName, int length)
2618 {
2619     if (!length)
2620         return QMetaType::UnknownType;
2621     int type = qMetaTypeStaticType(typeName, length);
2622     if (type == QMetaType::UnknownType) {
2623         QReadLocker locker(&customTypeRegistry()->lock);
2624         type = qMetaTypeCustomType_unlocked(typeName, length);
2625 #ifndef QT_NO_QOBJECT
2626         if ((type == QMetaType::UnknownType) && tryNormalizedType) {
2627             const NS(QByteArray) normalizedTypeName = QMetaObject::normalizedType(typeName);
2628             type = qMetaTypeStaticType(normalizedTypeName.constData(),
2629                                        normalizedTypeName.size());
2630             if (type == QMetaType::UnknownType) {
2631                 type = qMetaTypeCustomType_unlocked(normalizedTypeName.constData(),
2632                                                     normalizedTypeName.size());
2633             }
2634         }
2635 #endif
2636     }
2637     return type;
2638 }
2639 
2640 /*!
2641     \fn int QMetaType::type(const char *typeName)
2642     \deprecated
2643 
2644     Returns a handle to the type called \a typeName, or QMetaType::UnknownType if there is
2645     no such type.
2646 
2647     \sa isRegistered(), typeName(), Type
2648 */
2649 
2650 /*!
2651     \a internal
2652 
2653     Similar to QMetaType::type(); the only difference is that this function
2654     doesn't attempt to normalize the type name (i.e., the lookup will fail
2655     for type names in non-normalized form).
2656 */
2657 Q_CORE_EXPORT int qMetaTypeTypeInternal(const char *typeName)
2658 {
2659     return qMetaTypeTypeImpl</*tryNormalizedType=*/false>(typeName, int(qstrlen(typeName)));
2660 }
2661 
2662 /*!
2663     \fn int QMetaType::type(const QT_PREPEND_NAMESPACE(QByteArray) &typeName)
2664 
2665     \since 5.5
2666     \overload
2667     \deprecated
2668 
2669     Returns a handle to the type called \a typeName, or 0 if there is
2670     no such type.
2671 
2672     \sa isRegistered(), typeName()
2673 */
2674 
2675 #ifndef QT_NO_DATASTREAM
2676 /*!
2677     Writes the object pointed to by \a data to the given \a stream.
2678     Returns \c true if the object is saved successfully; otherwise
2679     returns \c false.
2680 
2681     The type must have been registered with Q_DECLARE_METATYPE()
2682     beforehand.
2683 
2684     Normally, you should not need to call this function directly.
2685     Instead, use QVariant's \c operator<<(), which relies on save()
2686     to stream custom types.
2687 
2688     \sa load()
2689 */
2690 bool QMetaType::save(QDataStream &stream, const void *data) const
2691 {
2692     if (!data || !isValid())
2693         return false;
2694 
2695     // keep compatibility for long/ulong
2696     if (id() == QMetaType::Long) {
2697         stream << qlonglong(*(long *)data);
2698         return true;
2699     } else if (id() == QMetaType::ULong) {
2700         stream << qlonglong(*(unsigned long *)data);
2701         return true;
2702     }
2703 
2704     if (!d_ptr->dataStreamOut)
2705         return false;
2706 
2707     d_ptr->dataStreamOut(d_ptr, stream, data);
2708     return true;
2709 }
2710 
2711 /*!
2712    \fn bool QMetaType::save(QDataStream &stream, int type, const void *data)
2713    \overload
2714    \deprecated
2715 */
2716 
2717 /*!
2718     Reads the object of this type from the given \a stream into \a data.
2719     Returns \c true if the object is loaded successfully; otherwise
2720     returns \c false.
2721 
2722     The type must have been registered with Q_DECLARE_METATYPE()
2723     beforehand.
2724 
2725     Normally, you should not need to call this function directly.
2726     Instead, use QVariant's \c operator>>(), which relies on load()
2727     to stream custom types.
2728 
2729     \sa save()
2730 */
2731 bool QMetaType::load(QDataStream &stream, void *data) const
2732 {
2733     if (!data || !isValid())
2734         return false;
2735 
2736     // keep compatibility for long/ulong
2737     if (id() == QMetaType::Long) {
2738         qlonglong ll;
2739         stream >> ll;
2740         *(long *)data = long(ll);
2741         return true;
2742     } else if (id() == QMetaType::ULong) {
2743         qulonglong ull;
2744         stream >> ull;
2745         *(unsigned long *)data = (unsigned long)(ull);
2746         return true;
2747     }
2748     if (!d_ptr->dataStreamIn)
2749         return false;
2750 
2751     d_ptr->dataStreamIn(d_ptr, stream, data);
2752     return true;
2753 }
2754 
2755 /*!
2756     \since 6.1
2757 
2758     Returns \c true, if the meta type system has registered data stream operators for this
2759     meta type.
2760 */
2761 bool QMetaType::hasRegisteredDataStreamOperators() const
2762 {
2763     int type = id();
2764     if (type == QMetaType::Long || type == QMetaType::ULong)
2765         return true;
2766     return d_ptr && d_ptr->dataStreamIn != nullptr && d_ptr->dataStreamOut != nullptr;
2767 }
2768 
2769 /*!
2770    \fn bool QMetaType::load(QDataStream &stream, int type, void *data)
2771    \overload
2772    \deprecated
2773 */
2774 #endif // QT_NO_DATASTREAM
2775 
2776 /*!
2777     Returns a QMetaType matching \a typeName. The returned object is
2778     not valid if the typeName is not known to QMetaType
2779  */
2780 QMetaType QMetaType::fromName(QByteArrayView typeName)
2781 {
2782     return QMetaType(qMetaTypeTypeImpl</*tryNormalizedType=*/true>(typeName.data(), typeName.size()));
2783 }
2784 
2785 /*!
2786     \fn void *QMetaType::create(int type, const void *copy)
2787     \deprecated
2788 
2789     Returns a copy of \a copy, assuming it is of type \a type. If \a
2790     copy is zero, creates a default constructed instance.
2791 
2792     \sa destroy(), isRegistered(), Type
2793 */
2794 
2795 /*!
2796     \fn void QMetaType::destroy(int type, void *data)
2797     \deprecated
2798     Destroys the \a data, assuming it is of the \a type given.
2799 
2800     \sa create(), isRegistered(), Type
2801 */
2802 
2803 /*!
2804     \fn void *QMetaType::construct(int type, void *where, const void *copy)
2805     \since 5.0
2806     \deprecated
2807 
2808     Constructs a value of the given \a type in the existing memory
2809     addressed by \a where, that is a copy of \a copy, and returns
2810     \a where. If \a copy is zero, the value is default constructed.
2811 
2812     This is a low-level function for explicitly managing the memory
2813     used to store the type. Consider calling create() if you don't
2814     need this level of control (that is, use "new" rather than
2815     "placement new").
2816 
2817     You must ensure that \a where points to a location that can store
2818     a value of type \a type, and that \a where is suitably aligned.
2819     The type's size can be queried by calling sizeOf().
2820 
2821     The rule of thumb for alignment is that a type is aligned to its
2822     natural boundary, which is the smallest power of 2 that is bigger
2823     than the type, unless that alignment is larger than the maximum
2824     useful alignment for the platform. For practical purposes,
2825     alignment larger than 2 * sizeof(void*) is only necessary for
2826     special hardware instructions (e.g., aligned SSE loads and stores
2827     on x86).
2828 
2829     \sa destruct(), sizeOf()
2830 */
2831 
2832 
2833 /*!
2834     \fn void QMetaType::destruct(int type, void *where)
2835     \since 5.0
2836     \deprecated
2837 
2838     Destructs the value of the given \a type, located at \a where.
2839 
2840     Unlike destroy(), this function only invokes the type's
2841     destructor, it doesn't invoke the delete operator.
2842 
2843     \sa construct()
2844 */
2845 
2846 /*!
2847     \fn int QMetaType::sizeOf(int type)
2848     \since 5.0
2849     \deprecated
2850 
2851     Returns the size of the given \a type in bytes (i.e. sizeof(T),
2852     where T is the actual type identified by the \a type argument).
2853 
2854     This function is typically used together with construct()
2855     to perform low-level management of the memory used by a type.
2856 
2857     \sa construct(), QMetaType::alignOf()
2858 */
2859 
2860 /*!
2861     \fn QMetaType::TypeFlags QMetaType::typeFlags(int type)
2862     \since 5.0
2863     \deprecated
2864 
2865     Returns flags of the given \a type.
2866 
2867     \sa QMetaType::TypeFlags
2868 */
2869 
2870 /*!
2871     \fn const QMetaObject *QMetaType::metaObjectForType(int type)
2872     \since 5.0
2873     \deprecated
2874 
2875     returns QMetaType::metaObject for \a type
2876 
2877     \sa metaObject()
2878 */
2879 
2880 /*!
2881     \fn int qRegisterMetaType(const char *typeName)
2882     \relates QMetaType
2883     \threadsafe
2884 
2885     Registers the type name \a typeName for the type \c{T}. Returns
2886     the internal ID used by QMetaType. Any class or struct that has a
2887     public default constructor, a public copy constructor and a public
2888     destructor can be registered.
2889 
2890     This function requires that \c{T} is a fully defined type at the point
2891     where the function is called. For pointer types, it also requires that the
2892     pointed to type is fully defined. Use Q_DECLARE_OPAQUE_POINTER() to be able
2893     to register pointers to forward declared types.
2894 
2895     After a type has been registered, you can create and destroy
2896     objects of that type dynamically at run-time.
2897 
2898     This example registers the class \c{MyClass}:
2899 
2900     \snippet code/src_corelib_kernel_qmetatype.cpp 4
2901 
2902     This function is useful to register typedefs so they can be used
2903     by QMetaProperty, or in QueuedConnections
2904 
2905     \snippet code/src_corelib_kernel_qmetatype.cpp 9
2906 
2907     \warning This function is useful only for registering an alias (typedef)
2908     for every other use case Q_DECLARE_METATYPE and qMetaTypeId() should be used instead.
2909 
2910     \sa {QMetaType::}{isRegistered()}, Q_DECLARE_METATYPE()
2911 */
2912 
2913 /*!
2914     \fn int qRegisterMetaType()
2915     \relates QMetaType
2916     \threadsafe
2917     \since 4.2
2918 
2919     Call this function to register the type \c T. \c T must be declared with
2920     Q_DECLARE_METATYPE(). Returns the meta type Id.
2921 
2922     Example:
2923 
2924     \snippet code/src_corelib_kernel_qmetatype.cpp 7
2925 
2926     This function requires that \c{T} is a fully defined type at the point
2927     where the function is called. For pointer types, it also requires that the
2928     pointed to type is fully defined. Use Q_DECLARE_OPAQUE_POINTER() to be able
2929     to register pointers to forward declared types.
2930 
2931     After a type has been registered, you can create and destroy
2932     objects of that type dynamically at run-time.
2933 
2934     To use the type \c T in QVariant, using Q_DECLARE_METATYPE() is
2935     sufficient. To use the type \c T in queued signal and slot connections,
2936     \c{qRegisterMetaType<T>()} must be called before the first connection
2937     is established.
2938 
2939     Also, to use type \c T with the QObject::property() API,
2940     \c{qRegisterMetaType<T>()} must be called before it is used, typically
2941     in the constructor of the class that uses \c T, or in the \c{main()}
2942     function.
2943 
2944     \sa Q_DECLARE_METATYPE()
2945  */
2946 
2947 /*!
2948     \fn int qMetaTypeId()
2949     \relates QMetaType
2950     \threadsafe
2951     \since 4.1
2952 
2953     Returns the meta type id of type \c T at compile time. If the
2954     type was not declared with Q_DECLARE_METATYPE(), compilation will
2955     fail.
2956 
2957     Typical usage:
2958 
2959     \snippet code/src_corelib_kernel_qmetatype.cpp 8
2960 
2961     QMetaType::type() returns the same ID as qMetaTypeId(), but does
2962     a lookup at runtime based on the name of the type.
2963     QMetaType::type() is a bit slower, but compilation succeeds if a
2964     type is not registered.
2965 
2966     \sa Q_DECLARE_METATYPE(), QMetaType::type()
2967 */
2968 
2969 static const QtPrivate::QMetaTypeInterface *interfaceForType(int typeId)
2970 {
2971     const QtPrivate::QMetaTypeInterface *iface = nullptr;
2972     if (typeId >= QMetaType::User) {
2973         if (auto reg = customTypeRegistry())
2974             iface = reg->getCustomType(typeId);
2975     } else {
2976         if (auto moduleHelper = qModuleHelperForType(typeId))
2977             iface = moduleHelper->interfaceForType(typeId);
2978     }
2979 
2980     if (!iface && typeId != QMetaType::UnknownType)
2981         qWarning("Trying to construct an instance of an invalid type, type id: %i", typeId);
2982 
2983     return iface;
2984 }
2985 
2986 /*!
2987      \fn QMetaType::QMetaType(int typeId)
2988      \since 5.0
2989 
2990      Constructs a QMetaType object that contains all information about type \a typeId.
2991 */
2992 QMetaType::QMetaType(int typeId) : QMetaType(interfaceForType(typeId)) {}
2993 
2994 namespace QtPrivate {
2995 #ifndef QT_BOOTSTRAPPED
2996 
2997 #if defined(Q_CC_MSVC) && defined(QT_BUILD_CORE_LIB)
2998 #define QT_METATYPE_TEMPLATE_EXPORT Q_CORE_EXPORT
2999 #else
3000 #define QT_METATYPE_TEMPLATE_EXPORT
3001 #endif
3002 
3003 // Explicit instantiation definition
3004 #define QT_METATYPE_DECLARE_TEMPLATE_ITER(TypeName, Id, Name) \
3005     template class QT_METATYPE_TEMPLATE_EXPORT QMetaTypeForType<Name>;
3006 QT_FOR_EACH_STATIC_PRIMITIVE_TYPE(QT_METATYPE_DECLARE_TEMPLATE_ITER)
3007 QT_FOR_EACH_STATIC_PRIMITIVE_POINTER(QT_METATYPE_DECLARE_TEMPLATE_ITER)
3008 QT_FOR_EACH_STATIC_CORE_CLASS(QT_METATYPE_DECLARE_TEMPLATE_ITER)
3009 QT_FOR_EACH_STATIC_CORE_POINTER(QT_METATYPE_DECLARE_TEMPLATE_ITER)
3010 QT_FOR_EACH_STATIC_CORE_TEMPLATE(QT_METATYPE_DECLARE_TEMPLATE_ITER)
3011 #undef QT_METATYPE_DECLARE_TEMPLATE_ITER
3012 #undef QT_METATYPE_TEMPLATE_EXPORT
3013 #endif
3014 }
3015 
3016 QT_END_NAMESPACE
