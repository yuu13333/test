Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "fakevimplugin.h"
27 
28 #include "fakevimactions.h"
29 #include "fakevimhandler.h"
30 #include "fakevimtr.h"
31 #include "ui_fakevimoptions.h"
32 
33 #include <coreplugin/actionmanager/actioncontainer.h>
34 #include <coreplugin/actionmanager/actionmanager.h>
35 #include <coreplugin/actionmanager/command.h>
36 #include <coreplugin/actionmanager/command.h>
37 #include <coreplugin/actionmanager/commandmappings.h>
38 #include <coreplugin/coreconstants.h>
39 #include <coreplugin/dialogs/ioptionspage.h>
40 #include <coreplugin/editormanager/editormanager.h>
41 #include <coreplugin/editormanager/documentmodel.h>
42 #include <coreplugin/find/findplugin.h>
43 #include <coreplugin/find/textfindconstants.h>
44 #include <coreplugin/find/ifindsupport.h>
45 #include <coreplugin/documentmanager.h>
46 #include <coreplugin/icore.h>
47 #include <coreplugin/idocument.h>
48 #include <coreplugin/messagemanager.h>
49 #include <coreplugin/id.h>
50 #include <coreplugin/statusbarwidget.h>
51 #include <coreplugin/statusbarmanager.h>
52 
53 #include <projectexplorer/projectexplorerconstants.h>
54 
55 #include <texteditor/displaysettings.h>
56 #include <texteditor/textdocumentlayout.h>
57 #include <texteditor/texteditor.h>
58 #include <texteditor/textmark.h>
59 #include <texteditor/texteditorconstants.h>
60 #include <texteditor/typingsettings.h>
61 #include <texteditor/tabsettings.h>
62 #include <texteditor/icodestylepreferences.h>
63 #include <texteditor/texteditorsettings.h>
64 #include <texteditor/indenter.h>
65 #include <texteditor/codeassist/assistproposalitem.h>
66 #include <texteditor/codeassist/genericproposalmodel.h>
67 #include <texteditor/codeassist/completionassistprovider.h>
68 #include <texteditor/codeassist/iassistprocessor.h>
69 #include <texteditor/codeassist/assistinterface.h>
70 #include <texteditor/codeassist/genericproposal.h>
71 
72 #include <utils/fancylineedit.h>
73 #include <utils/hostosinfo.h>
74 #include <utils/qtcassert.h>
75 #include <utils/pathchooser.h>
76 #include <utils/savedaction.h>
77 #include <utils/stylehelper.h>
78 
79 #include <cpptools/cpptoolsconstants.h>
80 
81 #include <extensionsystem/pluginmanager.h>
82 
83 #include <QAbstractTableModel>
84 #include <QDebug>
85 #include <QFile>
86 #include <QItemDelegate>
87 #include <QPainter>
88 #include <QPlainTextEdit>
89 #include <QPointer>
90 #include <QScrollBar>
91 #include <QSettings>
92 #include <QStackedWidget>
93 #include <QStandardPaths>
94 #include <QTextBlock>
95 #include <QTextCursor>
96 #include <QTextEdit>
97 #include <QTimer>
98 #include <QTreeWidgetItem>
99 
100 using namespace TextEditor;
101 using namespace Core;
102 using namespace Utils;
103 
104 namespace FakeVim {
105 namespace Internal {
106 
107 const char INSTALL_HANDLER[]                = "TextEditor.FakeVimHandler";
108 const char SETTINGS_CATEGORY[]              = "D.FakeVim";
109 const char SETTINGS_CATEGORY_FAKEVIM_ICON[] = ":/fakevim/images/category_fakevim.png";
110 const char SETTINGS_ID[]                    = "A.FakeVim.General";
111 const char SETTINGS_EX_CMDS_ID[]            = "B.FakeVim.ExCommands";
112 const char SETTINGS_USER_CMDS_ID[]          = "C.FakeVim.UserCommands";
113 
114 class MiniBuffer : public QStackedWidget
115 {
116     Q_OBJECT
117 
118 public:
119     MiniBuffer()
120         : m_label(new QLabel(this))
121         , m_edit(new QLineEdit(this))
122     {
123         connect(m_edit, &QLineEdit::textEdited, this, &MiniBuffer::changed);
124         connect(m_edit, &QLineEdit::cursorPositionChanged, this, &MiniBuffer::changed);
125         connect(m_edit, &QLineEdit::selectionChanged, this, &MiniBuffer::changed);
126         m_label->setTextInteractionFlags(Qt::TextSelectableByMouse);
127 
128         addWidget(m_label);
129         addWidget(m_edit);
130 
131         m_hideTimer.setSingleShot(true);
132         m_hideTimer.setInterval(8000);
133         connect(&m_hideTimer, &QTimer::timeout, this, &QWidget::hide);
134     }
135 
136     void setContents(const QString &contents, int cursorPos, int anchorPos,
137                      int messageLevel, FakeVimHandler *eventFilter)
138     {
139         if (cursorPos != -1) {
140             m_edit->blockSignals(true);
141             m_label->clear();
142             m_edit->setText(contents);
143             if (anchorPos != -1 && anchorPos != cursorPos)
144                 m_edit->setSelection(anchorPos, cursorPos - anchorPos);
145             else
146                 m_edit->setCursorPosition(cursorPos);
147             m_edit->blockSignals(false);
148             setCurrentWidget(m_edit);
149             m_edit->setFocus();
150         } else {
151             if (contents.isEmpty()) {
152                 if (m_lastMessageLevel == MessageMode)
153                     hide();
154                 else
155                     m_hideTimer.start();
156             } else {
157                 m_hideTimer.stop();
158                 show();
159 
160                 m_label->setText(contents);
161 
162                 QString css;
163                 if (messageLevel == MessageError) {
164                     css = "border:1px solid rgba(255,255,255,150);"
165                           "background-color:rgba(255,0,0,100);";
166                 } else if (messageLevel == MessageWarning) {
167                     css = "border:1px solid rgba(255,255,255,120);"
168                             "background-color:rgba(255,255,0,20);";
169                 } else if (messageLevel == MessageShowCmd) {
170                     css = "border:1px solid rgba(255,255,255,120);"
171                             "background-color:rgba(100,255,100,30);";
172                 }
173                 m_label->setStyleSheet(QString::fromLatin1(
174                     "*{border-radius:2px;padding-left:4px;padding-right:4px;%1}").arg(css));
175             }
176 
177             if (m_edit->hasFocus())
178                 emit edited(QString(), -1, -1);
179 
180             setCurrentWidget(m_label);
181         }
182 
183         if (m_eventFilter != eventFilter) {
184             if (m_eventFilter != 0) {
185                 m_edit->removeEventFilter(m_eventFilter);
186                 disconnect(this, &MiniBuffer::edited, 0, 0);
187             }
188             if (eventFilter != 0) {
189                 m_edit->installEventFilter(eventFilter);
190                 connect(this, &MiniBuffer::edited,
191                         eventFilter, &FakeVimHandler::miniBufferTextEdited);
192             }
193             m_eventFilter = eventFilter;
194         }
195 
196         m_lastMessageLevel = messageLevel;
197     }
198 
199     QSize sizeHint() const
200     {
201         QSize size = QWidget::sizeHint();
202         // reserve maximal width for line edit widget
203         return currentWidget() == m_edit ? QSize(maximumWidth(), size.height()) : size;
204     }
205 
206 signals:
207     void edited(const QString &text, int cursorPos, int anchorPos);
208 
209 private:
210     void changed()
211     {
212         const int cursorPos = m_edit->cursorPosition();
213         int anchorPos = m_edit->selectionStart();
214         if (anchorPos == cursorPos)
215             anchorPos = cursorPos + m_edit->selectedText().length();
216         emit edited(m_edit->text(), cursorPos, anchorPos);
217     }
218 
219     QLabel *m_label;
220     QLineEdit *m_edit;
221     QObject *m_eventFilter = nullptr;
222     QTimer m_hideTimer;
223     int m_lastMessageLevel = MessageMode;
224 };
225 
226 class RelativeNumbersColumn : public QWidget
227 {
228     Q_OBJECT
229 
230 public:
231     RelativeNumbersColumn(TextEditorWidget *baseTextEditor)
232         : QWidget(baseTextEditor)
233         , m_editor(baseTextEditor)
234     {
235         setAttribute(Qt::WA_TransparentForMouseEvents, true);
236 
237         m_timerUpdate.setSingleShot(true);
238         m_timerUpdate.setInterval(0);
239         connect(&m_timerUpdate, &QTimer::timeout,
240                 this, &RelativeNumbersColumn::followEditorLayout);
241 
242         auto start = static_cast<void(QTimer::*)()>(&QTimer::start);
243         connect(m_editor, &QPlainTextEdit::cursorPositionChanged,
244                 &m_timerUpdate, start);
245         connect(m_editor->verticalScrollBar(), &QAbstractSlider::valueChanged,
246                 &m_timerUpdate, start);
247         connect(m_editor->document(), &QTextDocument::contentsChanged,
248                 &m_timerUpdate, start);
249         connect(TextEditorSettings::instance(), &TextEditorSettings::displaySettingsChanged,
250                 &m_timerUpdate, start);
251 
252         m_editor->installEventFilter(this);
253 
254         followEditorLayout();
255     }
256 
257 protected:
258     void paintEvent(QPaintEvent *event)
259     {
260         QTextCursor firstVisibleCursor = m_editor->cursorForPosition(QPoint(0, 0));
261         QTextBlock firstVisibleBlock = firstVisibleCursor.block();
262         if (firstVisibleCursor.positionInBlock() > 0) {
263             firstVisibleBlock = firstVisibleBlock.next();
264             firstVisibleCursor.setPosition(firstVisibleBlock.position());
265         }
266 
267         // Find relative number for the first visible line.
268         QTextBlock block = m_editor->textCursor().block();
269         bool forward = firstVisibleBlock.blockNumber() > block.blockNumber();
270         int n = 0;
271         while (block.isValid() && block != firstVisibleBlock) {
272             block = forward ? block.next() : block.previous();
273             if (block.isVisible())
274                 n += forward ? 1 : -1;
275         }
276 
277         // Copy colors from extra area palette.
278         QPainter p(this);
279         QPalette pal = m_editor->extraArea()->palette();
280         const QColor fg = pal.color(QPalette::Dark);
281         const QColor bg = pal.color(QPalette::Background);
282         p.setPen(fg);
283 
284         // Draw relative line numbers.
285         QRect rect(0, m_editor->cursorRect(firstVisibleCursor).y(), width(), m_lineSpacing);
286         bool hideLineNumbers = m_editor->lineNumbersVisible();
287         while (block.isValid()) {
288             if (block.isVisible()) {
289                 if (n != 0 && rect.intersects(event->rect())) {
290                     const int line = qAbs(n);
291                     const QString number = QString::number(line);
292                     if (hideLineNumbers)
293                         p.fillRect(rect, bg);
294                     if (hideLineNumbers || line < 100)
295                         p.drawText(rect, Qt::AlignRight | Qt::AlignVCenter, number);
296                 }
297 
298                 rect.translate(0, m_lineSpacing * block.lineCount());
299                 if (rect.y() > height())
300                     break;
301 
302                 ++n;
303             }
304 
305             block = block.next();
306         }
307     }
308 
309     bool eventFilter(QObject *, QEvent *event)
310     {
311         if (event->type() == QEvent::Resize || event->type() == QEvent::Move)
312             m_timerUpdate.start();
313         return false;
314     }
315 
316 private:
317     void followEditorLayout()
318     {
319         QTextCursor tc = m_editor->textCursor();
320         m_currentPos = tc.position();
321         m_lineSpacing = m_editor->cursorRect(tc).height();
322         setFont(m_editor->extraArea()->font());
323 
324         // Follow geometry of normal line numbers if visible,
325         // otherwise follow geometry of marks (breakpoints etc.).
326         QRect rect = m_editor->extraArea()->geometry().adjusted(0, 0, -3, 0);
327         bool marksVisible = m_editor->marksVisible();
328         bool lineNumbersVisible = m_editor->lineNumbersVisible();
329         bool foldMarksVisible = m_editor->codeFoldingVisible();
330         if (marksVisible && lineNumbersVisible)
331             rect.setLeft(m_lineSpacing);
332         if (foldMarksVisible && (marksVisible || lineNumbersVisible))
333             rect.setRight(rect.right() - (m_lineSpacing + m_lineSpacing % 2));
334         setGeometry(rect);
335 
336         update();
337     }
338 
339     int m_currentPos = 0;
340     int m_lineSpacing = 0;
341     TextEditorWidget *m_editor;
342     QTimer m_timerUpdate;
343 };
344 
345 ///////////////////////////////////////////////////////////////////////
346 //
347 // FakeVimOptionPage
348 //
349 ///////////////////////////////////////////////////////////////////////
350 
351 typedef QMap<QString, QRegExp> ExCommandMap;
352 typedef QMap<int, QString> UserCommandMap;
353 
354 class FakeVimOptionPage : public IOptionsPage
355 {
356     Q_OBJECT
357 
358 public:
359     FakeVimOptionPage()
360     {
361         setId(SETTINGS_ID);
362         setDisplayName(Tr::tr("General"));
363         setCategory(SETTINGS_CATEGORY);
364         setDisplayCategory(Tr::tr("FakeVim"));
365         setCategoryIcon(Utils::Icon(SETTINGS_CATEGORY_FAKEVIM_ICON));
366     }
367 
368     QWidget *widget();
369     void apply();
370     void finish();
371 
372 private:
373     void copyTextEditorSettings();
374     void setQtStyle();
375     void setPlainStyle();
376     void updateVimRcWidgets();
377 
378     QPointer<QWidget> m_widget;
379     Ui::FakeVimOptionPage m_ui;
380     SavedActionSet m_group;
381 };
382 
383 QWidget *FakeVimOptionPage::widget()
384 {
385     if (!m_widget) {
386         m_widget = new QWidget;
387         m_ui.setupUi(m_widget);
388         const QString vimrcDefault = QLatin1String(HostOsInfo::isAnyUnixHost()
389                 ? "$HOME/.vimrc" : "%USERPROFILE%\\_vimrc");
390         m_ui.pathChooserVimRcPath->setExpectedKind(PathChooser::File);
391         m_ui.pathChooserVimRcPath->lineEdit()->setToolTip(Tr::tr("Keep empty to use the default path, i.e. "
392                                                              "%USERPROFILE%\\_vimrc on Windows, ~/.vimrc otherwise."));
393         m_ui.pathChooserVimRcPath->lineEdit()->setPlaceholderText(Tr::tr("Default: %1").arg(vimrcDefault));
394 
395         m_group.clear();
396         m_group.insert(theFakeVimSetting(ConfigUseFakeVim),
397                        m_ui.checkBoxUseFakeVim);
398         m_group.insert(theFakeVimSetting(ConfigReadVimRc),
399                        m_ui.checkBoxReadVimRc);
400         m_group.insert(theFakeVimSetting(ConfigVimRcPath),
401                        m_ui.pathChooserVimRcPath);
402 
403         m_group.insert(theFakeVimSetting(ConfigExpandTab),
404                        m_ui.checkBoxExpandTab);
405         m_group.insert(theFakeVimSetting(ConfigHlSearch),
406                        m_ui.checkBoxHlSearch);
407         m_group.insert(theFakeVimSetting(ConfigShiftWidth),
408                        m_ui.spinBoxShiftWidth);
409         m_group.insert(theFakeVimSetting(ConfigShowMarks),
410                        m_ui.checkBoxShowMarks);
411 
412         m_group.insert(theFakeVimSetting(ConfigSmartTab),
413                        m_ui.checkBoxSmartTab);
414         m_group.insert(theFakeVimSetting(ConfigStartOfLine),
415                        m_ui.checkBoxStartOfLine);
416         m_group.insert(theFakeVimSetting(ConfigPassKeys),
417                        m_ui.checkBoxPassKeys);
418         m_group.insert(theFakeVimSetting(ConfigTabStop),
419                        m_ui.spinBoxTabStop);
420         m_group.insert(theFakeVimSetting(ConfigScrollOff),
421                        m_ui.spinBoxScrollOff);
422         m_group.insert(theFakeVimSetting(ConfigBackspace),
423                        m_ui.lineEditBackspace);
424         m_group.insert(theFakeVimSetting(ConfigIsKeyword),
425                        m_ui.lineEditIsKeyword);
426 
427         m_group.insert(theFakeVimSetting(ConfigPassControlKey),
428                        m_ui.checkBoxPassControlKey);
429         m_group.insert(theFakeVimSetting(ConfigAutoIndent),
430                        m_ui.checkBoxAutoIndent);
431         m_group.insert(theFakeVimSetting(ConfigSmartIndent),
432                        m_ui.checkBoxSmartIndent);
433 
434         m_group.insert(theFakeVimSetting(ConfigIncSearch),
435                        m_ui.checkBoxIncSearch);
436         m_group.insert(theFakeVimSetting(ConfigUseCoreSearch),
437                        m_ui.checkBoxUseCoreSearch);
438         m_group.insert(theFakeVimSetting(ConfigSmartCase),
439                        m_ui.checkBoxSmartCase);
440         m_group.insert(theFakeVimSetting(ConfigIgnoreCase),
441                        m_ui.checkBoxIgnoreCase);
442         m_group.insert(theFakeVimSetting(ConfigWrapScan),
443                        m_ui.checkBoxWrapScan);
444 
445         m_group.insert(theFakeVimSetting(ConfigShowCmd),
446                        m_ui.checkBoxShowCmd);
447 
448         m_group.insert(theFakeVimSetting(ConfigRelativeNumber),
449                        m_ui.checkBoxRelativeNumber);
450 
451         connect(m_ui.pushButtonCopyTextEditorSettings, &QAbstractButton::clicked,
452                 this, &FakeVimOptionPage::copyTextEditorSettings);
453         connect(m_ui.pushButtonSetQtStyle, &QAbstractButton::clicked,
454                 this, &FakeVimOptionPage::setQtStyle);
455         connect(m_ui.pushButtonSetPlainStyle, &QAbstractButton::clicked,
456                 this, &FakeVimOptionPage::setPlainStyle);
457         connect(m_ui.checkBoxReadVimRc, &QCheckBox::stateChanged,
458                 this, &FakeVimOptionPage::updateVimRcWidgets);
459         updateVimRcWidgets();
460 
461     }
462     return m_widget;
463 }
464 
465 void FakeVimOptionPage::apply()
466 {
467     m_group.apply(ICore::settings());
468 }
469 
470 void FakeVimOptionPage::finish()
471 {
472     m_group.finish();
473     delete m_widget;
474 }
475 
476 void FakeVimOptionPage::copyTextEditorSettings()
477 {
478     TabSettings ts = TextEditorSettings::codeStyle()->tabSettings();
479     TypingSettings tps = TextEditorSettings::typingSettings();
480     m_ui.checkBoxExpandTab->setChecked(ts.m_tabPolicy != TabSettings::TabsOnlyTabPolicy);
481     m_ui.spinBoxTabStop->setValue(ts.m_tabSize);
482     m_ui.spinBoxShiftWidth->setValue(ts.m_indentSize);
483     m_ui.checkBoxSmartTab->setChecked(
484         tps.m_smartBackspaceBehavior == TypingSettings::BackspaceFollowsPreviousIndents);
485     m_ui.checkBoxAutoIndent->setChecked(true);
486     m_ui.checkBoxSmartIndent->setChecked(tps.m_autoIndent);
487     m_ui.checkBoxIncSearch->setChecked(true);
488 }
489 
490 void FakeVimOptionPage::setQtStyle()
491 {
492     m_ui.checkBoxExpandTab->setChecked(true);
493     m_ui.spinBoxTabStop->setValue(4);
494     m_ui.spinBoxShiftWidth->setValue(4);
495     m_ui.checkBoxSmartTab->setChecked(true);
496     m_ui.checkBoxAutoIndent->setChecked(true);
497     m_ui.checkBoxSmartIndent->setChecked(true);
498     m_ui.checkBoxIncSearch->setChecked(true);
499     m_ui.lineEditBackspace->setText("indent,eol,start");
500     m_ui.checkBoxPassKeys->setChecked(true);
501 }
502 
503 void FakeVimOptionPage::setPlainStyle()
504 {
505     m_ui.checkBoxExpandTab->setChecked(false);
506     m_ui.spinBoxTabStop->setValue(8);
507     m_ui.spinBoxShiftWidth->setValue(8);
508     m_ui.checkBoxSmartTab->setChecked(false);
509     m_ui.checkBoxAutoIndent->setChecked(false);
510     m_ui.checkBoxSmartIndent->setChecked(false);
511     m_ui.checkBoxIncSearch->setChecked(false);
512     m_ui.lineEditBackspace->clear();
513     m_ui.checkBoxPassKeys->setChecked(false);
514 }
515 
516 void FakeVimOptionPage::updateVimRcWidgets()
517 {
518     m_ui.pathChooserVimRcPath->setEnabled(m_ui.checkBoxReadVimRc->isChecked());
519 }
520 
521 //const char *FAKEVIM_CONTEXT = "FakeVim";
522 
523 ///////////////////////////////////////////////////////////////////////
524 //
525 // FakeVimExCommandsPage
526 //
527 ///////////////////////////////////////////////////////////////////////
528 
529 enum { CommandRole = Qt::UserRole };
530 
531 class FakeVimExCommandsWidget : public CommandMappings
532 {
533     Q_OBJECT
534 
535 public:
536     FakeVimExCommandsWidget(FakeVimPluginPrivate *q, QWidget *parent = 0);
537 
538 protected:
539     void commandChanged();
540     void resetToDefault();
541     void defaultAction() override;
542 
543     void handleCurrentCommandChanged(QTreeWidgetItem *current);
544 
545 private:
546     void initialize();
547 
548     ExCommandMap &exCommandMap();
549     ExCommandMap &defaultExCommandMap();
550 
551     FakeVimPluginPrivate *m_q;
552     QGroupBox *m_commandBox;
553     FancyLineEdit *m_commandEdit;
554 };
555 
556 FakeVimExCommandsWidget::FakeVimExCommandsWidget(FakeVimPluginPrivate *q, QWidget *parent)
557     : CommandMappings(parent), m_q(q)
558 {
559     setPageTitle(Tr::tr("Ex Command Mapping"));
560     setTargetHeader(Tr::tr("Ex Trigger Expression"));
561     setImportExportEnabled(false);
562 
563     connect(this, &FakeVimExCommandsWidget::currentCommandChanged,
564             this, &FakeVimExCommandsWidget::handleCurrentCommandChanged);
565 
566     m_commandBox = new QGroupBox(Tr::tr("Ex Command"), this);
567     m_commandBox->setEnabled(false);
568     auto boxLayout = new QHBoxLayout(m_commandBox);
569     m_commandEdit = new FancyLineEdit(m_commandBox);
570     m_commandEdit->setFiltering(true);
571     m_commandEdit->setPlaceholderText(QString());
572     connect(m_commandEdit, &FancyLineEdit::textChanged,
573             this, &FakeVimExCommandsWidget::commandChanged);
574     auto resetButton = new QPushButton(Tr::tr("Reset"), m_commandBox);
575     resetButton->setToolTip(Tr::tr("Reset to default."));
576     connect(resetButton, &QPushButton::clicked,
577             this, &FakeVimExCommandsWidget::resetToDefault);
578     boxLayout->addWidget(new QLabel(Tr::tr("Regular expression:")));
579     boxLayout->addWidget(m_commandEdit);
580     boxLayout->addWidget(resetButton);
581 
582     layout()->addWidget(m_commandBox);
583 
584     initialize();
585 }
586 
587 class FakeVimExCommandsPage : public IOptionsPage
588 {
589     Q_OBJECT
590 
591 public:
592     FakeVimExCommandsPage(FakeVimPluginPrivate *q)
593         : m_q(q)
594     {
595         setId(SETTINGS_EX_CMDS_ID);
596         setDisplayName(Tr::tr("Ex Command Mapping"));
597         setCategory(SETTINGS_CATEGORY);
598         setDisplayCategory(Tr::tr("FakeVim"));
599         setCategoryIcon(Utils::Icon(SETTINGS_CATEGORY_FAKEVIM_ICON));
600     }
601 
602     QWidget *widget() override;
603     void apply() override {}
604     void finish() override;
605 
606 private:
607     FakeVimPluginPrivate *m_q;
608     QPointer<QWidget> m_widget;
609 };
610 
611 QWidget *FakeVimExCommandsPage::widget()
612 {
613     if (!m_widget)
614         m_widget = new FakeVimExCommandsWidget(m_q);
615     return m_widget;
616 }
617 
618 void FakeVimExCommandsPage::finish()
619 {
620     delete m_widget;
621 }
622 
623 void FakeVimExCommandsWidget::initialize()
624 {
625     QMap<QString, QTreeWidgetItem *> sections;
626 
627     foreach (Command *c, ActionManager::commands()) {
628         if (c->action() && c->action()->isSeparator())
629             continue;
630 
631         auto item = new QTreeWidgetItem;
632         const QString name = c->id().toString();
633         const int pos = name.indexOf('.');
634         const QString section = name.left(pos);
635         const QString subId = name.mid(pos + 1);
636         item->setData(0, CommandRole, name);
637 
638         if (!sections.contains(section)) {
639             auto categoryItem = new QTreeWidgetItem(commandList(), { section });
640             QFont f = categoryItem->font(0);
641             f.setBold(true);
642             categoryItem->setFont(0, f);
643             sections.insert(section, categoryItem);
644             commandList()->expandItem(categoryItem);
645         }
646         sections[section]->addChild(item);
647 
648         item->setText(0, subId);
649         item->setText(1, c->description());
650 
651         QString regex;
652         if (exCommandMap().contains(name))
653             regex = exCommandMap()[name].pattern();
654         item->setText(2, regex);
655 
656         if (regex != defaultExCommandMap()[name].pattern())
657             setModified(item, true);
658     }
659 
660     handleCurrentCommandChanged(0);
661 }
662 
663 void FakeVimExCommandsWidget::handleCurrentCommandChanged(QTreeWidgetItem *current)
664 {
665     if (current) {
666         m_commandEdit->setText(current->text(2));
667         m_commandBox->setEnabled(true);
668     } else {
669         m_commandEdit->clear();
670         m_commandBox->setEnabled(false);
671     }
672 }
673 
674 void FakeVimExCommandsWidget::commandChanged()
675 {
676     QTreeWidgetItem *current = commandList()->currentItem();
677     if (!current)
678         return;
679 
680     const QString name =  current->data(0, CommandRole).toString();
681     const QString regex = m_commandEdit->text();
682 
683     if (current->data(0, Qt::UserRole).isValid()) {
684         current->setText(2, regex);
685         exCommandMap()[name] = QRegExp(regex);
686     }
687 
688     setModified(current, regex != defaultExCommandMap()[name].pattern());
689 }
690 
691 void FakeVimExCommandsWidget::resetToDefault()
692 {
693     QTreeWidgetItem *current = commandList()->currentItem();
694     if (!current)
695         return;
696     const QString name = current->data(0, CommandRole).toString();
697     QString regex;
698     if (defaultExCommandMap().contains(name))
699         regex = defaultExCommandMap()[name].pattern();
700     m_commandEdit->setText(regex);
701 }
702 
703 void FakeVimExCommandsWidget::defaultAction()
704 {
705     int n = commandList()->topLevelItemCount();
706     for (int i = 0; i != n; ++i) {
707         QTreeWidgetItem *section = commandList()->topLevelItem(i);
708         int m = section->childCount();
709         for (int j = 0; j != m; ++j) {
710             QTreeWidgetItem *item = section->child(j);
711             const QString name = item->data(0, CommandRole).toString();
712             QString regex;
713             if (defaultExCommandMap().contains(name))
714                 regex = defaultExCommandMap()[name].pattern();
715             setModified(item, false);
716             item->setText(2, regex);
717             if (item == commandList()->currentItem())
718                 currentCommandChanged(item);
719         }
720     }
721 }
722 
723 ///////////////////////////////////////////////////////////////////////
724 //
725 // FakeVimUserCommandsPage
726 //
727 ///////////////////////////////////////////////////////////////////////
728 
729 class FakeVimUserCommandsModel : public QAbstractTableModel
730 {
731     Q_OBJECT
732 public:
733     FakeVimUserCommandsModel(FakeVimPluginPrivate *q) : m_q(q) {}
734     ~FakeVimUserCommandsModel() {}
735 
736     int rowCount(const QModelIndex &parent) const;
737     int columnCount(const QModelIndex &parent) const;
738     QVariant data(const QModelIndex &index, int role) const;
739     bool setData(const QModelIndex &index, const QVariant &data, int role);
740     QVariant headerData(int section, Qt::Orientation orientation, int role) const;
741     Qt::ItemFlags flags(const QModelIndex &index) const;
742 
743 private:
744     FakeVimPluginPrivate *m_q;
745 };
746 
747 int FakeVimUserCommandsModel::rowCount(const QModelIndex &parent) const
748 {
749     return parent.isValid() ? 0 : 9;
750 }
751 
752 int FakeVimUserCommandsModel::columnCount(const QModelIndex &parent) const
753 {
754     return parent.isValid() ? 0 : 2;
755 }
756 
757 
758 QVariant FakeVimUserCommandsModel::headerData(int section,
759     Qt::Orientation orient, int role) const
760 {
761     if (orient == Qt::Horizontal && role == Qt::DisplayRole) {
762         switch (section) {
763             case 0: return Tr::tr("Action");
764             case 1: return Tr::tr("Command");
765         };
766     }
767     return QVariant();
768 }
769 
770 Qt::ItemFlags FakeVimUserCommandsModel::flags(const QModelIndex &index) const
771 {
772     if (index.column() == 1)
773         return QAbstractTableModel::flags(index) | Qt::ItemIsEditable;
774     return QAbstractTableModel::flags(index);
775 }
776 
777 class FakeVimUserCommandsDelegate : public QItemDelegate
778 {
779 public:
780     explicit FakeVimUserCommandsDelegate(QObject *parent)
781         : QItemDelegate(parent)
782     {}
783 
784     QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &,
785         const QModelIndex &) const
786     {
787         auto lineEdit = new QLineEdit(parent);
788         lineEdit->setFrame(false);
789         return lineEdit;
790     }
791 
792     void setModelData(QWidget *editor, QAbstractItemModel *model,
793                       const QModelIndex &index) const
794     {
795         QLineEdit *lineEdit = qobject_cast<QLineEdit *>(editor);
796         QTC_ASSERT(lineEdit, return);
797         model->setData(index, lineEdit->text(), Qt::EditRole);
798     }
799 };
800 
801 class FakeVimUserCommandsPage : public IOptionsPage
802 {
803     Q_OBJECT
804 
805 public:
806     FakeVimUserCommandsPage(FakeVimPluginPrivate *q)
807         : m_q(q)
808     {
809         setId(SETTINGS_USER_CMDS_ID);
810         setDisplayName(Tr::tr("User Command Mapping"));
811         setCategory(SETTINGS_CATEGORY);
812         setDisplayCategory(Tr::tr("FakeVim"));
813         setCategoryIcon(Utils::Icon(SETTINGS_CATEGORY_FAKEVIM_ICON));
814     }
815 
816     void apply();
817     void finish() {}
818 
819     QWidget *widget();
820     void initialize() {}
821     UserCommandMap &userCommandMap();
822     UserCommandMap &defaultUserCommandMap();
823 
824 private:
825     FakeVimPluginPrivate *m_q;
826     QPointer<QWidget> m_widget;
827 };
828 
829 QWidget *FakeVimUserCommandsPage::widget()
830 {
831     if (!m_widget) {
832         m_widget = new QWidget;
833 
834         auto model = new FakeVimUserCommandsModel(m_q);
835         auto widget = new QTreeView;
836         model->setParent(widget);
837         widget->setModel(model);
838         widget->resizeColumnToContents(0);
839 
840         auto delegate = new FakeVimUserCommandsDelegate(widget);
841         widget->setItemDelegateForColumn(1, delegate);
842 
843         auto layout = new QGridLayout(m_widget);
844         layout->addWidget(widget, 0, 0);
845         m_widget->setLayout(layout);
846     }
847     return m_widget;
848 }
849 
850 void FakeVimUserCommandsPage::apply()
851 {
852     //m_q->writeSettings();
853     delete m_widget;
854 }
855 
856 
857 ///////////////////////////////////////////////////////////////////////
858 //
859 // WordCompletion
860 //
861 ///////////////////////////////////////////////////////////////////////
862 
863 class FakeVimCompletionAssistProvider : public CompletionAssistProvider
864 {
865 public:
866     bool supportsEditor(Id ) const
867     {
868         return false;
869     }
870 
871     IAssistProcessor *createProcessor() const;
872 
873     void setActive(const QString &needle, bool forward, FakeVimHandler *handler)
874     {
875         Q_UNUSED(forward);
876         m_handler = handler;
877         if (!m_handler)
878             return;
879 
880         TextEditorWidget *editor = qobject_cast<TextEditorWidget *>(handler->widget());
881         if (!editor)
882             return;
883 
884         //qDebug() << "ACTIVATE: " << needle << forward;
885         m_needle = needle;
886         editor->invokeAssist(Completion, this);
887     }
888 
889     void setInactive()
890     {
891         m_needle.clear();
892         m_handler = 0;
893     }
894 
895     const QString &needle() const
896     {
897         return m_needle;
898     }
899 
900     void appendNeedle(const QChar &c)
901     {
902         m_needle.append(c);
903     }
904 
905     FakeVimHandler *handler() const
906     {
907         return m_handler;
908     }
909 
910 private:
911     FakeVimHandler *m_handler = nullptr;
912     QString m_needle;
913 };
914 
915 class FakeVimAssistProposalItem final : public AssistProposalItem
916 {
917 public:
918     FakeVimAssistProposalItem(const FakeVimCompletionAssistProvider *provider)
919         : m_provider(const_cast<FakeVimCompletionAssistProvider *>(provider))
920     {}
921 
922     bool implicitlyApplies() const override
923     {
924         return false;
925     }
926 
927     bool prematurelyApplies(const QChar &c) const override
928     {
929         m_provider->appendNeedle(c);
930         return text() == m_provider->needle();
931     }
932 
933     void applyContextualContent(TextDocumentManipulatorInterface &, int) const override
934     {
935         QTC_ASSERT(m_provider->handler(), return);
936         m_provider->handler()->handleReplay(text().mid(m_provider->needle().size()));
937         const_cast<FakeVimCompletionAssistProvider *>(m_provider)->setInactive();
938     }
939 
940 private:
941     FakeVimCompletionAssistProvider *m_provider;
942 };
943 
944 
945 class FakeVimAssistProposalModel : public GenericProposalModel
946 {
947 public:
948     FakeVimAssistProposalModel(const QList<AssistProposalItemInterface *> &items)
949     {
950         loadContent(items);
951     }
952 
953     bool supportsPrefixExpansion() const override
954     {
955         return false;
956     }
957 };
958 
959 class FakeVimCompletionAssistProcessor : public IAssistProcessor
960 {
961 public:
962     FakeVimCompletionAssistProcessor(const IAssistProvider *provider)
963         : m_provider(static_cast<const FakeVimCompletionAssistProvider *>(provider))
964     {}
965 
966     IAssistProposal *perform(const AssistInterface *interface) override
967     {
968         const QString &needle = m_provider->needle();
969 
970         const int basePosition = interface->position() - needle.size();
971 
972         QTextCursor tc(interface->textDocument());
973         tc.setPosition(interface->position());
974         tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor);
975 
976         QList<AssistProposalItemInterface *> items;
977         QSet<QString> seen;
978         QTextDocument::FindFlags flags = QTextDocument::FindCaseSensitively;
979         while (1) {
980             tc = tc.document()->find(needle, tc.position(), flags);
981             if (tc.isNull())
982                 break;
983             QTextCursor sel = tc;
984             sel.select(QTextCursor::WordUnderCursor);
985             QString found = sel.selectedText();
986             // Only add "real" completions.
987             if (found.startsWith(needle)
988                     && !seen.contains(found)
989                     && sel.anchor() != basePosition) {
990                 seen.insert(found);
991                 auto item = new FakeVimAssistProposalItem(m_provider);
992                 item->setText(found);
993                 items.append(item);
994             }
995             tc.movePosition(QTextCursor::Right, QTextCursor::MoveAnchor);
996         }
997         //qDebug() << "COMPLETIONS" << completions->size();
998 
999         delete interface;
1000         return new GenericProposal(basePosition, new FakeVimAssistProposalModel(items));
1001     }
1002 
1003 private:
1004     const FakeVimCompletionAssistProvider *m_provider;
1005 };
1006 
1007 IAssistProcessor *FakeVimCompletionAssistProvider::createProcessor() const
1008 {
1009     return new FakeVimCompletionAssistProcessor(this);
1010 }
1011 
1012 
1013 ///////////////////////////////////////////////////////////////////////
1014 //
1015 // FakeVimPluginPrivate
1016 //
1017 ///////////////////////////////////////////////////////////////////////
1018 
1019 class FakeVimPluginPrivate : public QObject
1020 {
1021     Q_OBJECT
1022 
1023 public:
1024     FakeVimPluginPrivate(FakeVimPlugin *);
1025 
1026     friend class FakeVimPlugin;
1027     friend class FakeVimExCommandsWidget;
1028     friend class FakeVimUserCommandsPage;
1029     friend class FakeVimUserCommandsModel;
1030 
1031     bool initialize();
1032     void aboutToShutdown();
1033 
1034 private:
1035     void onCoreAboutToClose();
1036     void editorOpened(Core::IEditor *);
1037     void editorAboutToClose(Core::IEditor *);
1038     void currentEditorAboutToChange(Core::IEditor *);
1039 
1040     void allDocumentsRenamed(const QString &oldName, const QString &newName);
1041     void documentRenamed(Core::IDocument *document, const QString &oldName, const QString &newName);
1042     void renameFileNameInEditors(const QString &oldName, const QString &newName);
1043 
1044     void setUseFakeVim(const QVariant &value);
1045     void setUseFakeVimInternal(bool on);
1046     void quitFakeVim();
1047     void triggerCompletions(FakeVimHandler *handler);
1048     void triggerSimpleCompletions(FakeVimHandler *handler, const QString &needle, bool forward);
1049     void windowCommand(FakeVimHandler *handler, const QString &key, int count);
1050     void find(bool reverse);
1051     void findNext(bool reverse);
1052     void foldToggle(FakeVimHandler *handler, int depth);
1053     void foldAll(FakeVimHandler *handler, bool fold);
1054     void fold(FakeVimHandler *handler, int depth, bool fold);
1055     void foldGoTo(FakeVimHandler *handler, int count, bool current);
1056     void jumpToGlobalMark(FakeVimHandler *, QChar mark, bool backTickMode, const QString &fileName);
1057     void maybeReadVimRc();
1058     void disableBlockSelection(FakeVimHandler *handler);
1059     void setBlockSelection(FakeVimHandler *handler, const QTextCursor &cursor);
1060     void blockSelection(FakeVimHandler *handler, QTextCursor *cursor);
1061     void hasBlockSelection(FakeVimHandler *handler, bool *on);
1062     void setShowRelativeLineNumbers(const QVariant &value);
1063 
1064     void resetCommandBuffer();
1065     void showCommandBuffer(FakeVimHandler *handler, const QString &contents,
1066                            int cursorPos, int anchorPos, int messageLevel);
1067     void showExtraInformation(FakeVimHandler *handler, const QString &msg);
1068     void changeSelection(FakeVimHandler *handler, const QList<QTextEdit::ExtraSelection> &selections);
1069     void highlightMatches(FakeVimHandler *handler, const QString &needle);
1070     void moveToMatchingParenthesis(FakeVimHandler *handler, bool *moved, bool *forward, QTextCursor *cursor);
1071     void checkForElectricCharacter(FakeVimHandler *handler, bool *result, QChar c);
1072     void indentRegion(FakeVimHandler *handler, int beginBlock, int endBlock, QChar typedChar);
1073     void handleExCommand(FakeVimHandler *handler, bool *handled, const ExCommand &cmd);
1074 
1075     void writeSettings();
1076     void readSettings();
1077 
1078     void handleDelayedQuitAll(bool forced);
1079     void handleDelayedQuit(bool forced, Core::IEditor *editor);
1080     void userActionTriggered(int key);
1081 
1082     void switchToFile(int n);
1083     int currentFile() const;
1084 
1085     void createRelativeNumberWidget(IEditor *editor);
1086 
1087 signals:
1088     void delayedQuitRequested(bool forced, Core::IEditor *editor);
1089     void delayedQuitAllRequested(bool forced);
1090 
1091 private:
1092     FakeVimPlugin *q;
1093     FakeVimOptionPage *m_fakeVimOptionsPage = nullptr;
1094     FakeVimExCommandsPage *m_fakeVimExCommandsPage = nullptr;
1095     FakeVimUserCommandsPage *m_fakeVimUserCommandsPage = nullptr;
1096     QHash<IEditor *, FakeVimHandler *> m_editorToHandler;
1097 
1098     void triggerAction(Id id);
1099     void setActionChecked(Id id, bool check);
1100 
1101     typedef int (*DistFunction)(const QRect &cursor, const QRect &other);
1102     void moveSomewhere(FakeVimHandler *handler, DistFunction f, int count);
1103 
1104     void keepOnlyWindow(); // :only
1105 
1106     ExCommandMap &exCommandMap() { return m_exCommandMap; }
1107     ExCommandMap &defaultExCommandMap() { return m_defaultExCommandMap; }
1108     ExCommandMap m_exCommandMap;
1109     ExCommandMap m_defaultExCommandMap;
1110 
1111     UserCommandMap &userCommandMap() { return m_userCommandMap; }
1112     UserCommandMap &defaultUserCommandMap() { return m_defaultUserCommandMap; }
1113     UserCommandMap m_userCommandMap;
1114     UserCommandMap m_defaultUserCommandMap;
1115 
1116     StatusBarWidget *m_statusBar;
1117     // @TODO: Delete
1118     //WordCompletion *m_wordCompletion;
1119     FakeVimCompletionAssistProvider *m_wordProvider = nullptr;
1120 };
1121 
1122 QVariant FakeVimUserCommandsModel::data(const QModelIndex &index, int role) const
1123 {
1124     if (!index.isValid())
1125         return QVariant();
1126 
1127     if (role == Qt::DisplayRole || role == Qt::EditRole) {
1128         switch (index.column()) {
1129         case 0: // Action
1130             return Tr::tr("User command #%1").arg(index.row() + 1);
1131         case 1: // Command
1132             return m_q->userCommandMap().value(index.row() + 1);
1133         }
1134     }
1135 
1136     return QVariant();
1137 }
1138 
1139 bool FakeVimUserCommandsModel::setData(const QModelIndex &index,
1140     const QVariant &data, int role)
1141 {
1142     if (role == Qt::DisplayRole || role == Qt::EditRole)
1143         if (index.column() == 1)
1144             m_q->userCommandMap()[index.row() + 1] = data.toString();
1145     return true;
1146 }
1147 
1148 FakeVimPluginPrivate::FakeVimPluginPrivate(FakeVimPlugin *plugin)
1149     : q(plugin)
1150 {
1151     defaultExCommandMap()[CppTools::Constants::SWITCH_HEADER_SOURCE] =
1152         QRegExp("^A$");
1153     defaultExCommandMap()["Coreplugin.OutputPane.previtem"] =
1154         QRegExp("^(cN(ext)?|cp(revious)?)!?( (.*))?$");
1155     defaultExCommandMap()["Coreplugin.OutputPane.nextitem"] =
1156         QRegExp("^cn(ext)?!?( (.*))?$");
1157     defaultExCommandMap()[TextEditor::Constants::FOLLOW_SYMBOL_UNDER_CURSOR] =
1158         QRegExp("^tag?$");
1159     defaultExCommandMap()[Core::Constants::GO_BACK] =
1160         QRegExp("^pop?$");
1161     defaultExCommandMap()["QtCreator.Locate"] =
1162         QRegExp("^e$");
1163 
1164     for (int i = 1; i < 10; ++i) {
1165         QString cmd = QString::fromLatin1(":echo User command %1 executed.<CR>");
1166         defaultUserCommandMap().insert(i, cmd.arg(i));
1167     }
1168 
1169     m_statusBar = 0;
1170 }
1171 
1172 void FakeVimPluginPrivate::onCoreAboutToClose()
1173 {
1174     // Don't attach to editors anymore.
1175     disconnect(EditorManager::instance(), &EditorManager::editorOpened,
1176                this, &FakeVimPluginPrivate::editorOpened);
1177 }
1178 
1179 void FakeVimPluginPrivate::aboutToShutdown()
1180 {
1181     q->removeObject(m_fakeVimOptionsPage);
1182     delete m_fakeVimOptionsPage;
1183     m_fakeVimOptionsPage = 0;
1184 
1185     q->removeObject(m_fakeVimExCommandsPage);
1186     delete m_fakeVimExCommandsPage;
1187     m_fakeVimExCommandsPage = 0;
1188 
1189     q->removeObject(m_fakeVimUserCommandsPage);
1190     delete m_fakeVimUserCommandsPage;
1191     m_fakeVimUserCommandsPage = 0;
1192 
1193     delete m_wordProvider;
1194     m_wordProvider = 0;
1195 }
1196 
1197 bool FakeVimPluginPrivate::initialize()
1198 {
1199     //m_wordCompletion = new WordCompletion;
1200     //q->addAutoReleasedObject(m_wordCompletion);
1201     m_wordProvider = new FakeVimCompletionAssistProvider;
1202 
1203 /*
1204     // Set completion settings and keep them up to date.
1205     TextEditorSettings *textEditorSettings = TextEditorSettings::instance();
1206     completion->setCompletionSettings(textEditorSettings->completionSettings());
1207     connect(textEditorSettings, &TextEditorSettings::completionSettingsChanged,
1208             completion, &TextEditorWidget::setCompletionSettings);
1209 */
1210 
1211     Context globalcontext(Core::Constants::C_GLOBAL);
1212 
1213     m_fakeVimOptionsPage = new FakeVimOptionPage;
1214     q->addObject(m_fakeVimOptionsPage);
1215 
1216     m_fakeVimExCommandsPage = new FakeVimExCommandsPage(this);
1217     q->addObject(m_fakeVimExCommandsPage);
1218 
1219     m_fakeVimUserCommandsPage = new FakeVimUserCommandsPage(this);
1220     q->addObject(m_fakeVimUserCommandsPage);
1221 
1222     readSettings();
1223 
1224     Command *cmd = 0;
1225     cmd = ActionManager::registerAction(theFakeVimSetting(ConfigUseFakeVim),
1226         INSTALL_HANDLER, globalcontext, true);
1227     cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? Tr::tr("Meta+Shift+V,Meta+Shift+V") : Tr::tr("Alt+V,Alt+V")));
1228 
1229     ActionContainer *advancedMenu =
1230         ActionManager::actionContainer(Core::Constants::M_EDIT_ADVANCED);
1231     advancedMenu->addAction(cmd, Core::Constants::G_EDIT_EDITOR);
1232 
1233     const Id base = "FakeVim.UserAction";
1234     for (int i = 1; i < 10; ++i) {
1235         auto act = new QAction(this);
1236         act->setText(Tr::tr("Execute User Action #%1").arg(i));
1237         cmd = ActionManager::registerAction(act, base.withSuffix(i));
1238         cmd->setDefaultKeySequence(QKeySequence((UseMacShortcuts ? Tr::tr("Meta+Shift+V,%1") : Tr::tr("Alt+V,%1")).arg(i)));
1239         connect(act, &QAction::triggered, this, [this, i] { userActionTriggered(i); });
1240     }
1241 
1242     connect(ICore::instance(), &ICore::coreAboutToClose,
1243             this, &FakeVimPluginPrivate::onCoreAboutToClose);
1244 
1245     // EditorManager
1246     connect(EditorManager::instance(), &EditorManager::editorAboutToClose,
1247             this, &FakeVimPluginPrivate::editorAboutToClose);
1248     connect(EditorManager::instance(), &EditorManager::editorOpened,
1249             this, &FakeVimPluginPrivate::editorOpened);
1250     connect(EditorManager::instance(), &EditorManager::currentEditorAboutToChange,
1251             this, &FakeVimPluginPrivate::currentEditorAboutToChange);
1252 
1253     connect(DocumentManager::instance(), &DocumentManager::allDocumentsRenamed,
1254             this, &FakeVimPluginPrivate::allDocumentsRenamed);
1255     connect(DocumentManager::instance(), &DocumentManager::documentRenamed,
1256             this, &FakeVimPluginPrivate::documentRenamed);
1257 
1258     connect(theFakeVimSetting(ConfigUseFakeVim), &SavedAction::valueChanged,
1259             this, &FakeVimPluginPrivate::setUseFakeVim);
1260     connect(theFakeVimSetting(ConfigReadVimRc), &SavedAction::valueChanged,
1261             this, &FakeVimPluginPrivate::maybeReadVimRc);
1262     connect(theFakeVimSetting(ConfigVimRcPath), &SavedAction::valueChanged,
1263             this, &FakeVimPluginPrivate::maybeReadVimRc);
1264     connect(theFakeVimSetting(ConfigRelativeNumber), &SavedAction::valueChanged,
1265             this, &FakeVimPluginPrivate::setShowRelativeLineNumbers);
1266 
1267     // Delayed operations.
1268     connect(this, &FakeVimPluginPrivate::delayedQuitRequested,
1269             this, &FakeVimPluginPrivate::handleDelayedQuit, Qt::QueuedConnection);
1270     connect(this, &FakeVimPluginPrivate::delayedQuitAllRequested,
1271             this, &FakeVimPluginPrivate::handleDelayedQuitAll, Qt::QueuedConnection);
1272 
1273     // Vimrc can break test so don't source it if running tests.
1274     if (!ExtensionSystem::PluginManager::testRunRequested())
1275         maybeReadVimRc();
1276     //    << "MODE: " << theFakeVimSetting(ConfigUseFakeVim)->value();
1277 
1278     return true;
1279 }
1280 
1281 void FakeVimPluginPrivate::userActionTriggered(int key)
1282 {
1283     IEditor *editor = EditorManager::currentEditor();
1284     FakeVimHandler *handler = m_editorToHandler[editor];
1285     if (handler) {
1286         // If disabled, enable FakeVim mode just for single user command.
1287         bool enableFakeVim = !theFakeVimSetting(ConfigUseFakeVim)->value().toBool();
1288         if (enableFakeVim)
1289             setUseFakeVimInternal(true);
1290 
1291         const QString cmd = userCommandMap().value(key);
1292         handler->handleInput(cmd);
1293 
1294         if (enableFakeVim)
1295             setUseFakeVimInternal(false);
1296     }
1297 }
1298 
1299 void FakeVimPluginPrivate::createRelativeNumberWidget(IEditor *editor)
1300 {
1301     if (TextEditorWidget *textEditor = qobject_cast<TextEditorWidget *>(editor->widget())) {
1302         auto relativeNumbers = new RelativeNumbersColumn(textEditor);
1303         connect(theFakeVimSetting(ConfigRelativeNumber), &SavedAction::valueChanged,
1304                 relativeNumbers, &QObject::deleteLater);
1305         connect(theFakeVimSetting(ConfigUseFakeVim), &SavedAction::valueChanged,
1306                 relativeNumbers, &QObject::deleteLater);
1307         relativeNumbers->show();
1308     }
1309 }
1310 
1311 const char exCommandMapGroup[] = "FakeVimExCommand";
1312 const char userCommandMapGroup[] = "FakeVimUserCommand";
1313 const char reKey[] = "RegEx";
1314 const char cmdKey[] = "Cmd";
1315 const char idKey[] = "Command";
1316 
1317 void FakeVimPluginPrivate::writeSettings()
1318 {
1319     QSettings *settings = ICore::settings();
1320 
1321     theFakeVimSettings()->writeSettings(settings);
1322 
1323     { // block
1324     settings->beginWriteArray(exCommandMapGroup);
1325     int count = 0;
1326     typedef ExCommandMap::const_iterator Iterator;
1327     const Iterator end = exCommandMap().constEnd();
1328     for (Iterator it = exCommandMap().constBegin(); it != end; ++it) {
1329         const QString id = it.key();
1330         const QRegExp re = it.value();
1331 
1332         if ((defaultExCommandMap().contains(id) && defaultExCommandMap()[id] != re)
1333             || (!defaultExCommandMap().contains(id) && !re.pattern().isEmpty())) {
1334             settings->setArrayIndex(count);
1335             settings->setValue(idKey, id);
1336             settings->setValue(reKey, re.pattern());
1337             ++count;
1338         }
1339     }
1340     settings->endArray();
1341     } // block
1342 
1343     { // block
1344     settings->beginWriteArray(userCommandMapGroup);
1345     int count = 0;
1346     typedef UserCommandMap::const_iterator Iterator;
1347     const Iterator end = userCommandMap().constEnd();
1348     for (Iterator it = userCommandMap().constBegin(); it != end; ++it) {
1349         const int key = it.key();
1350         const QString cmd = it.value();
1351 
1352         if ((defaultUserCommandMap().contains(key)
1353                 && defaultUserCommandMap()[key] != cmd)
1354             || (!defaultUserCommandMap().contains(key) && !cmd.isEmpty())) {
1355             settings->setArrayIndex(count);
1356             settings->setValue(idKey, key);
1357             settings->setValue(cmdKey, cmd);
1358             ++count;
1359         }
1360     }
1361     settings->endArray();
1362     } // block
1363 }
1364 
1365 void FakeVimPluginPrivate::readSettings()
1366 {
1367     QSettings *settings = ICore::settings();
1368 
1369     theFakeVimSettings()->readSettings(settings);
1370 
1371     exCommandMap() = defaultExCommandMap();
1372     int size = settings->beginReadArray(exCommandMapGroup);
1373     for (int i = 0; i < size; ++i) {
1374         settings->setArrayIndex(i);
1375         const QString id = settings->value(idKey).toString();
1376         const QString re = settings->value(reKey).toString();
1377         exCommandMap()[id] = QRegExp(re);
1378     }
1379     settings->endArray();
1380 
1381     userCommandMap() = defaultUserCommandMap();
1382     size = settings->beginReadArray(userCommandMapGroup);
1383     for (int i = 0; i < size; ++i) {
1384         settings->setArrayIndex(i);
1385         const int id = settings->value(idKey).toInt();
1386         const QString cmd = settings->value(cmdKey).toString();
1387         userCommandMap()[id] = cmd;
1388     }
1389     settings->endArray();
1390 }
1391 
1392 void FakeVimPluginPrivate::maybeReadVimRc()
1393 {
1394     //qDebug() << theFakeVimSetting(ConfigReadVimRc)
1395     //    << theFakeVimSetting(ConfigReadVimRc)->value();
1396     //qDebug() << theFakeVimSetting(ConfigShiftWidth)->value();
1397     if (!theFakeVimSetting(ConfigReadVimRc)->value().toBool())
1398         return;
1399     QString fileName = theFakeVimSetting(ConfigVimRcPath)->value().toString();
1400     if (fileName.isEmpty()) {
1401         fileName = QStandardPaths::writableLocation(QStandardPaths::HomeLocation)
1402             + HostOsInfo::isWindowsHost() ? QLatin1String("/_vimrc") : QLatin1String("/.vimrc");
1403     }
1404     //qDebug() << "READING VIMRC: " << fileName;
1405     // Read it into a temporary handler for effects modifying global state.
1406     QPlainTextEdit editor;
1407     FakeVimHandler handler(&editor);
1408     handler.handleCommand("source " + fileName);
1409     //writeSettings();
1410     //qDebug() << theFakeVimSetting(ConfigShiftWidth)->value();
1411 }
1412 
1413 void FakeVimPluginPrivate::triggerAction(Id id)
1414 {
1415     Command *cmd = ActionManager::command(id);
1416     QTC_ASSERT(cmd, qDebug() << "UNKNOWN CODE: " << id.name(); return);
1417     QAction *action = cmd->action();
1418     QTC_ASSERT(action, return);
1419     action->trigger();
1420 }
1421 
1422 void FakeVimPluginPrivate::setActionChecked(Id id, bool check)
1423 {
1424     Command *cmd = ActionManager::command(id);
1425     QTC_ASSERT(cmd, return);
1426     QAction *action = cmd->action();
1427     QTC_ASSERT(action, return);
1428     QTC_ASSERT(action->isCheckable(), return);
1429     action->setChecked(!check); // trigger negates the action's state
1430     action->trigger();
1431 }
1432 
1433 static int moveRightWeight(const QRect &cursor, const QRect &other)
1434 {
1435     if (!cursor.adjusted(999999, 0, 0, 0).intersects(other))
1436         return -1;
1437     const int dx = other.left() - cursor.right();
1438     const int dy = qAbs(cursor.center().y() - other.center().y());
1439     const int w = 10000 * dx + dy;
1440     return w;
1441 }
1442 
1443 static int moveLeftWeight(const QRect &cursor, const QRect &other)
1444 {
1445     if (!cursor.adjusted(-999999, 0, 0, 0).intersects(other))
1446         return -1;
1447     const int dx = cursor.left() - other.right();
1448     const int dy = qAbs(cursor.center().y() -other.center().y());
1449     const int w = 10000 * dx + dy;
1450     return w;
1451 }
1452 
1453 static int moveUpWeight(const QRect &cursor, const QRect &other)
1454 {
1455     if (!cursor.adjusted(0, 0, 0, -999999).intersects(other))
1456         return -1;
1457     const int dy = cursor.top() - other.bottom();
1458     const int dx = qAbs(cursor.center().x() - other.center().x());
1459     const int w = 10000 * dy + dx;
1460     return w;
1461 }
1462 
1463 static int moveDownWeight(const QRect &cursor, const QRect &other)
1464 {
1465     if (!cursor.adjusted(0, 0, 0, 999999).intersects(other))
1466         return -1;
1467     const int dy = other.top() - cursor.bottom();
1468     const int dx = qAbs(cursor.center().x() - other.center().x());
1469     const int w = 10000 * dy + dx;
1470     return w;
1471 }
1472 
1473 void FakeVimPluginPrivate::windowCommand(FakeVimHandler *handler, const QString &map, int count)
1474 {
1475     // normalize mapping
1476     const QString key = map.toUpper();
1477 
1478     if (key == "C" || key == "<C-C>")
1479         triggerAction(Core::Constants::REMOVE_CURRENT_SPLIT);
1480     else if (key == "N" || key == "<C-N>")
1481         triggerAction(Core::Constants::GOTONEXT);
1482     else if (key == "O" || key == "<C-O>")
1483         keepOnlyWindow();
1484     else if (key == "P" || key == "<C-P>")
1485         triggerAction(Core::Constants::GOTOPREV);
1486     else if (key == "S" || key == "<C-S>")
1487         triggerAction(Core::Constants::SPLIT);
1488     else if (key == "V" || key == "<C-V>")
1489         triggerAction(Core::Constants::SPLIT_SIDE_BY_SIDE);
1490     else if (key == "W" || key == "<C-W>")
1491         triggerAction(Core::Constants::GOTO_NEXT_SPLIT);
1492     else if (key.contains("RIGHT") || key == "L" || key == "<S-L>")
1493         moveSomewhere(handler, &moveRightWeight, key == "<S-L>" ? -1 : count);
1494     else if (key.contains("LEFT")  || key == "H" || key == "<S-H>")
1495         moveSomewhere(handler, &moveLeftWeight, key == "<S-H>" ? -1 : count);
1496     else if (key.contains("UP")    || key == "K" || key == "<S-K>")
1497         moveSomewhere(handler, &moveUpWeight, key == "<S-K>" ? -1 : count);
1498     else if (key.contains("DOWN")  || key == "J" || key == "<S-J>")
1499         moveSomewhere(handler, &moveDownWeight, key == "<S-J>" ? -1 : count);
1500     else
1501         qDebug() << "UNKNOWN WINDOW COMMAND: <C-W>" << map;
1502 }
1503 
1504 void FakeVimPluginPrivate::moveSomewhere(FakeVimHandler *handler, DistFunction f, int count)
1505 {
1506     QTC_ASSERT(handler, return);
1507     QWidget *w = handler->widget();
1508     QPlainTextEdit *pe = qobject_cast<QPlainTextEdit *>(w);
1509     QTC_ASSERT(pe, return);
1510     QRect rc = pe->cursorRect();
1511     QRect cursorRect(w->mapToGlobal(rc.topLeft()), w->mapToGlobal(rc.bottomRight()));
1512     //qDebug() << "\nCURSOR: " << cursorRect;
1513 
1514     IEditor *bestEditor = 0;
1515     int repeat = count;
1516 
1517     IEditor *currentEditor = EditorManager::currentEditor();
1518     QList<IEditor *> editors = EditorManager::visibleEditors();
1519     while (repeat < 0 || repeat-- > 0) {
1520         editors.removeOne(currentEditor);
1521         int bestValue = -1;
1522         foreach (IEditor *editor, editors) {
1523             QWidget *w = editor->widget();
1524             QRect editorRect(w->mapToGlobal(w->geometry().topLeft()),
1525                     w->mapToGlobal(w->geometry().bottomRight()));
1526             //qDebug() << "   EDITOR: " << editorRect << editor;
1527 
1528             int value = f(cursorRect, editorRect);
1529             if (value != -1 && (bestValue == -1 || value < bestValue)) {
1530                 bestValue = value;
1531                 bestEditor = editor;
1532                 //qDebug() << "          BEST SO FAR: " << bestValue << bestEditor;
1533             }
1534         }
1535         if (bestValue == -1)
1536             break;
1537 
1538         currentEditor = bestEditor;
1539         //qDebug() << "     BEST: " << bestValue << bestEditor;
1540     }
1541 
1542     // FIME: This is know to fail as the EditorManager will fall back to
1543     // the current editor's view. Needs additional public API there.
1544     if (bestEditor)
1545         EditorManager::activateEditor(bestEditor);
1546 }
1547 
1548 void FakeVimPluginPrivate::keepOnlyWindow()
1549 {
1550     IEditor *currentEditor = EditorManager::currentEditor();
1551     QList<IEditor *> editors = EditorManager::visibleEditors();
1552     editors.removeOne(currentEditor);
1553 
1554     foreach (IEditor *editor, editors) {
1555         EditorManager::activateEditor(editor);
1556         triggerAction(Core::Constants::REMOVE_CURRENT_SPLIT);
1557     }
1558 }
1559 
1560 void FakeVimPluginPrivate::find(bool reverse)
1561 {
1562     Find::setUseFakeVim(true);
1563     Find::openFindToolBar(reverse ? Find::FindBackwardDirection
1564                                   : Find::FindForwardDirection);
1565 }
1566 
1567 void FakeVimPluginPrivate::findNext(bool reverse)
1568 {
1569     if (reverse)
1570         triggerAction(Core::Constants::FIND_PREVIOUS);
1571     else
1572         triggerAction(Core::Constants::FIND_NEXT);
1573 }
1574 
1575 void FakeVimPluginPrivate::foldToggle(FakeVimHandler *handler, int depth)
1576 {
1577     QTC_ASSERT(handler, return);
1578     QTextBlock block = handler->textCursor().block();
1579     fold(handler, depth, !TextDocumentLayout::isFolded(block));
1580 }
1581 
1582 void FakeVimPluginPrivate::foldAll(FakeVimHandler *handler, bool fold)
1583 {
1584     QTC_ASSERT(handler, return);
1585     QTextDocument *document = handler->textCursor().document();
1586     auto documentLayout = qobject_cast<TextDocumentLayout*>(document->documentLayout());
1587     QTC_ASSERT(documentLayout != 0, return);
1588 
1589     QTextBlock block = document->firstBlock();
1590     while (block.isValid()) {
1591         TextDocumentLayout::doFoldOrUnfold(block, !fold);
1592         block = block.next();
1593     }
1594 
1595     documentLayout->requestUpdate();
1596     documentLayout->emitDocumentSizeChanged();
1597 }
1598 
1599 void FakeVimPluginPrivate::fold(FakeVimHandler *handler, int depth, bool fold)
1600 {
1601     QTC_ASSERT(handler, return);
1602     QTextDocument *doc = handler->textCursor().document();
1603     QTC_ASSERT(doc, return);
1604     auto documentLayout = qobject_cast<TextDocumentLayout*>(doc->documentLayout());
1605     QTC_ASSERT(documentLayout, return);
1606 
1607     QTextBlock block = handler->textCursor().block();
1608     int indent = TextDocumentLayout::foldingIndent(block);
1609     if (fold) {
1610         if (TextDocumentLayout::isFolded(block)) {
1611             while (block.isValid() && (TextDocumentLayout::foldingIndent(block) >= indent
1612                 || !block.isVisible())) {
1613                 block = block.previous();
1614             }
1615         }
1616         if (TextDocumentLayout::canFold(block))
1617             ++indent;
1618         while (depth != 0 && block.isValid()) {
1619             const int indent2 = TextDocumentLayout::foldingIndent(block);
1620             if (TextDocumentLayout::canFold(block) && indent2 < indent) {
1621                 TextDocumentLayout::doFoldOrUnfold(block, false);
1622                 if (depth > 0)
1623                     --depth;
1624                 indent = indent2;
1625             }
1626             block = block.previous();
1627         }
1628     } else {
1629         if (TextDocumentLayout::isFolded(block)) {
1630             if (depth < 0) {
1631                 // recursively open fold
1632                 while (block.isValid()
1633                     && TextDocumentLayout::foldingIndent(block) >= indent) {
1634                     if (TextDocumentLayout::canFold(block))
1635                         TextDocumentLayout::doFoldOrUnfold(block, true);
1636                     block = block.next();
1637                 }
1638             } else {
1639                 if (TextDocumentLayout::canFold(block)) {
1640                     TextDocumentLayout::doFoldOrUnfold(block, true);
1641                     if (depth > 0)
1642                         --depth;
1643                 }
1644             }
1645         }
1646     }
1647 
1648     documentLayout->requestUpdate();
1649     documentLayout->emitDocumentSizeChanged();
1650 }
1651 
1652 void FakeVimPluginPrivate::foldGoTo(FakeVimHandler *handler, int count, bool current)
1653 {
1654     QTC_ASSERT(handler, return);
1655     QTextCursor tc = handler->textCursor();
1656     QTextBlock block = tc.block();
1657 
1658     int pos = -1;
1659     if (count > 0) {
1660         int repeat = count;
1661         block = block.next();
1662         QTextBlock prevBlock = block;
1663         int indent = TextDocumentLayout::foldingIndent(block);
1664         block = block.next();
1665         while (block.isValid()) {
1666             int newIndent = TextDocumentLayout::foldingIndent(block);
1667             if (current ? indent > newIndent : indent < newIndent) {
1668                 if (prevBlock.isVisible()) {
1669                     pos = prevBlock.position();
1670                     if (--repeat <= 0)
1671                         break;
1672                 } else if (current) {
1673                     indent = newIndent;
1674                 }
1675             }
1676             if (!current)
1677                 indent = newIndent;
1678             prevBlock = block;
1679             block = block.next();
1680         }
1681     } else if (count < 0) {
1682         int repeat = -count;
1683         int indent = TextDocumentLayout::foldingIndent(block);
1684         block = block.previous();
1685         while (block.isValid()) {
1686             int newIndent = TextDocumentLayout::foldingIndent(block);
1687             if (current ? indent > newIndent : indent < newIndent) {
1688                 while (block.isValid() && !block.isVisible())
1689                     block = block.previous();
1690                 pos = block.position();
1691                 if (--repeat <= 0)
1692                     break;
1693             }
1694             if (!current)
1695                 indent = newIndent;
1696             block = block.previous();
1697         }
1698     }
1699 
1700     if (pos != -1) {
1701         tc.setPosition(pos, QTextCursor::KeepAnchor);
1702         handler->setTextCursor(tc);
1703     }
1704 }
1705 
1706 void FakeVimPluginPrivate::jumpToGlobalMark(FakeVimHandler *,
1707     QChar mark, bool backTickMode, const QString &fileName)
1708 {
1709     IEditor *iedit = EditorManager::openEditor(fileName);
1710     if (!iedit)
1711         return;
1712     FakeVimHandler *handler = m_editorToHandler.value(iedit, 0);
1713     if (handler)
1714         handler->jumpToLocalMark(mark, backTickMode);
1715 }
1716 
1717 // This class defers deletion of a child FakeVimHandler using deleteLater().
1718 class DeferredDeleter : public QObject
1719 {
1720     Q_OBJECT
1721 
1722     FakeVimHandler *m_handler;
1723 
1724 public:
1725     DeferredDeleter(QObject *parent, FakeVimHandler *handler)
1726         : QObject(parent), m_handler(handler)
1727     {}
1728 
1729     ~DeferredDeleter()
1730     {
1731         if (m_handler) {
1732             m_handler->disconnectFromEditor();
1733             m_handler->deleteLater();
1734             m_handler = 0;
1735         }
1736     }
1737 };
1738 
1739 void FakeVimPluginPrivate::editorOpened(IEditor *editor)
1740 {
1741     if (!editor)
1742         return;
1743 
1744     QWidget *widget = editor->widget();
1745     if (!widget)
1746         return;
1747 
1748     // we can only handle QTextEdit and QPlainTextEdit
1749     if (!qobject_cast<QTextEdit *>(widget) && !qobject_cast<QPlainTextEdit *>(widget))
1750         return;
1751 
1752     //qDebug() << "OPENING: " << editor << editor->widget()
1753     //    << "MODE: " << theFakeVimSetting(ConfigUseFakeVim)->value();
1754 
1755     auto handler = new FakeVimHandler(widget, 0);
1756     // the handler might have triggered the deletion of the editor:
1757     // make sure that it can return before being deleted itself
1758     new DeferredDeleter(widget, handler);
1759     m_editorToHandler[editor] = handler;
1760 
1761     connect(handler, &FakeVimHandler::extraInformationChanged,
1762             this, &FakeVimPluginPrivate::showExtraInformation);
1763     connect(handler, &FakeVimHandler::commandBufferChanged,
1764             this, &FakeVimPluginPrivate::showCommandBuffer);
1765     connect(handler, &FakeVimHandler::selectionChanged,
1766             this, &FakeVimPluginPrivate::changeSelection);
1767     connect(handler, &FakeVimHandler::highlightMatches,
1768             this, &FakeVimPluginPrivate::highlightMatches);
1769     connect(handler, &FakeVimHandler::moveToMatchingParenthesis,
1770             this, &FakeVimPluginPrivate::moveToMatchingParenthesis, Qt::DirectConnection);
1771     connect(handler, &FakeVimHandler::indentRegion,
1772             this, &FakeVimPluginPrivate::indentRegion);
1773     connect(handler, &FakeVimHandler::checkForElectricCharacter,
1774             this, &FakeVimPluginPrivate::checkForElectricCharacter, Qt::DirectConnection);
1775     connect(handler, &FakeVimHandler::requestDisableBlockSelection,
1776             this, &FakeVimPluginPrivate::disableBlockSelection);
1777     connect(handler, &FakeVimHandler::requestSetBlockSelection,
1778             this, &FakeVimPluginPrivate::setBlockSelection);
1779     connect(handler, &FakeVimHandler::requestBlockSelection,
1780             this, &FakeVimPluginPrivate::blockSelection, Qt::DirectConnection);
1781     connect(handler, &FakeVimHandler::requestHasBlockSelection,
1782             this, &FakeVimPluginPrivate::hasBlockSelection, Qt::DirectConnection);
1783     connect(handler, &FakeVimHandler::completionRequested,
1784             this, &FakeVimPluginPrivate::triggerCompletions);
1785     connect(handler, &FakeVimHandler::simpleCompletionRequested,
1786             this, &FakeVimPluginPrivate::triggerSimpleCompletions);
1787     connect(handler, &FakeVimHandler::windowCommandRequested,
1788             this, &FakeVimPluginPrivate::windowCommand);
1789     connect(handler, &FakeVimHandler::findRequested,
1790             this, &FakeVimPluginPrivate::find);
1791     connect(handler, &FakeVimHandler::findNextRequested,
1792             this, &FakeVimPluginPrivate::findNext);
1793     connect(handler, &FakeVimHandler::foldToggle,
1794             this, &FakeVimPluginPrivate::foldToggle);
1795     connect(handler, &FakeVimHandler::foldAll,
1796             this, &FakeVimPluginPrivate::foldAll);
1797     connect(handler, &FakeVimHandler::fold,
1798             this, &FakeVimPluginPrivate::fold);
1799     connect(handler, &FakeVimHandler::foldGoTo,
1800             this, &FakeVimPluginPrivate::foldGoTo);
1801     connect(handler, &FakeVimHandler::jumpToGlobalMark,
1802             this, &FakeVimPluginPrivate::jumpToGlobalMark);
1803 
1804     connect(handler, &FakeVimHandler::handleExCommandRequested,
1805             this, &FakeVimPluginPrivate::handleExCommand, Qt::DirectConnection);
1806 
1807     connect(ICore::instance(), &ICore::saveSettingsRequested,
1808             this, &FakeVimPluginPrivate::writeSettings);
1809 
1810     handler->setCurrentFileName(editor->document()->filePath().toString());
1811     handler->installEventFilter();
1812 
1813     // pop up the bar
1814     if (theFakeVimSetting(ConfigUseFakeVim)->value().toBool()) {
1815        resetCommandBuffer();
1816        handler->setupWidget();
1817 
1818        if (theFakeVimSetting(ConfigRelativeNumber)->value().toBool())
1819            createRelativeNumberWidget(editor);
1820     }
1821 }
1822 
1823 void FakeVimPluginPrivate::editorAboutToClose(IEditor *editor)
1824 {
1825     //qDebug() << "CLOSING: " << editor << editor->widget();
1826     m_editorToHandler.remove(editor);
1827 }
1828 
1829 void FakeVimPluginPrivate::currentEditorAboutToChange(IEditor *editor)
1830 {
1831     if (FakeVimHandler *handler = m_editorToHandler.value(editor, 0))
1832         handler->enterCommandMode();
1833 }
1834 
1835 void FakeVimPluginPrivate::allDocumentsRenamed(const QString &oldName, const QString &newName)
1836 {
1837     renameFileNameInEditors(oldName, newName);
1838     FakeVimHandler::updateGlobalMarksFilenames(oldName, newName);
1839 }
1840 
1841 void FakeVimPluginPrivate::documentRenamed(
1842         IDocument *, const QString &oldName, const QString &newName)
1843 {
1844     renameFileNameInEditors(oldName, newName);
1845 }
1846 
1847 void FakeVimPluginPrivate::renameFileNameInEditors(const QString &oldName, const QString &newName)
1848 {
1849     foreach (FakeVimHandler *handler, m_editorToHandler.values()) {
1850         if (handler->currentFileName() == oldName)
1851             handler->setCurrentFileName(newName);
1852     }
1853 }
1854 
1855 void FakeVimPluginPrivate::setUseFakeVim(const QVariant &value)
1856 {
1857     //qDebug() << "SET USE FAKEVIM" << value;
1858     bool on = value.toBool();
1859     Find::setUseFakeVim(on);
1860     setUseFakeVimInternal(on);
1861     setShowRelativeLineNumbers(theFakeVimSetting(ConfigRelativeNumber)->value());
1862 }
1863 
1864 void FakeVimPluginPrivate::setUseFakeVimInternal(bool on)
1865 {
1866     if (on) {
1867         //ICore *core = ICore::instance();
1868         //core->updateAdditionalContexts(Context(FAKEVIM_CONTEXT),
1869         // Context());
1870         foreach (IEditor *editor, m_editorToHandler.keys())
1871             m_editorToHandler[editor]->setupWidget();
1872     } else {
1873         //ICore *core = ICore::instance();
1874         //core->updateAdditionalContexts(Context(),
1875         // Context(FAKEVIM_CONTEXT));
1876         resetCommandBuffer();
1877         foreach (IEditor *editor, m_editorToHandler.keys()) {
1878             if (TextDocument *textDocument = qobject_cast<TextDocument *>(editor->document()))
1879                 m_editorToHandler[editor]->restoreWidget(textDocument->tabSettings().m_tabSize);
1880         }
1881     }
1882 }
1883 
1884 void FakeVimPluginPrivate::triggerCompletions(FakeVimHandler *handler)
1885 {
1886     QTC_ASSERT(handler, return);
1887     if (TextEditorWidget *editor = qobject_cast<TextEditorWidget *>(handler->widget()))
1888         editor->invokeAssist(Completion, m_wordProvider);
1889 //        CompletionSupport::instance()->complete(editor->editor(), TextCompletion, false);
1890 }
1891 
1892 void FakeVimPluginPrivate::triggerSimpleCompletions(FakeVimHandler *handler, const QString &needle, bool forward)
1893 {
1894     QTC_ASSERT(handler, return);
1895 //    m_wordCompletion->setActive(needle, forward, handler);
1896     m_wordProvider->setActive(needle, forward, handler);
1897 }
1898 
1899 void FakeVimPluginPrivate::disableBlockSelection(FakeVimHandler *handler)
1900 {
1901     QTC_ASSERT(handler, return);
1902     if (TextEditorWidget *bt = qobject_cast<TextEditorWidget *>(handler->widget()))
1903         bt->setBlockSelection(false);
1904 }
1905 
1906 void FakeVimPluginPrivate::setBlockSelection(FakeVimHandler *handler, const QTextCursor &cursor)
1907 {
1908     QTC_ASSERT(handler, return);
1909     if (TextEditorWidget *bt = qobject_cast<TextEditorWidget *>(handler->widget()))
1910         bt->setBlockSelection(cursor);
1911 }
1912 
1913 void FakeVimPluginPrivate::blockSelection(FakeVimHandler *handler, QTextCursor *cursor)
1914 {
1915     QTC_ASSERT(handler, return);
1916     if (TextEditorWidget *bt = qobject_cast<TextEditorWidget *>(handler->widget()))
1917         if (cursor)
1918             *cursor = bt->blockSelection();
1919 }
1920 
1921 void FakeVimPluginPrivate::hasBlockSelection(FakeVimHandler *handler, bool *on)
1922 {
1923     QTC_ASSERT(handler, return);
1924     if (TextEditorWidget *bt = qobject_cast<TextEditorWidget *>(handler->widget()))
1925         *on = bt->hasBlockSelection();
1926 }
1927 
1928 void FakeVimPluginPrivate::setShowRelativeLineNumbers(const QVariant &value)
1929 {
1930     if (value.toBool() && theFakeVimSetting(ConfigUseFakeVim)->value().toBool()) {
1931         foreach (IEditor *editor, m_editorToHandler.keys())
1932             createRelativeNumberWidget(editor);
1933     }
1934 }
1935 
1936 void FakeVimPluginPrivate::checkForElectricCharacter(FakeVimHandler *handler, bool *result, QChar c)
1937 {
1938     QTC_ASSERT(handler, return);
1939     if (TextEditorWidget *bt = qobject_cast<TextEditorWidget *>(handler->widget()))
1940         *result = bt->textDocument()->indenter()->isElectricCharacter(c);
1941 }
1942 
1943 void FakeVimPluginPrivate::handleExCommand(FakeVimHandler *handler, bool *handled, const ExCommand &cmd)
1944 {
1945     QTC_ASSERT(handler, return);
1946     using namespace Core;
1947     //qDebug() << "PLUGIN HANDLE: " << cmd.cmd << cmd.count;
1948 
1949     *handled = false;
1950 
1951     // Focus editor first so actions can be executed in correct context.
1952     QWidget *editor = handler->widget();
1953     if (editor)
1954         editor->setFocus();
1955 
1956     *handled = true;
1957     if ((cmd.matches("w", "write") || cmd.cmd == "wq") && cmd.args.isEmpty()) {
1958         // :w[rite]
1959         bool saved = false;
1960         IEditor *editor = m_editorToHandler.key(handler);
1961         const QString fileName = handler->currentFileName();
1962         if (editor && editor->document()->filePath().toString() == fileName) {
1963             triggerAction(Core::Constants::SAVE);
1964             saved = !editor->document()->isModified();
1965             if (saved) {
1966                 QFile file3(fileName);
1967                 if (file3.open(QIODevice::ReadOnly)) {
1968                     const QByteArray ba = file3.readAll();
1969                     handler->showMessage(MessageInfo, Tr::tr("\"%1\" %2 %3L, %4C written")
1970                         .arg(fileName).arg(' ').arg(ba.count('\n')).arg(ba.size()));
1971                     if (cmd.cmd == "wq")
1972                         delayedQuitRequested(cmd.hasBang, m_editorToHandler.key(handler));
1973                 }
1974             }
1975         }
1976 
1977         if (!saved)
1978             handler->showMessage(MessageError, Tr::tr("File not saved"));
1979     } else if (cmd.matches("wa", "wall")) {
1980         // :w[all]
1981         triggerAction(Core::Constants::SAVEALL);
1982         const QList<IDocument *> failed = DocumentManager::modifiedDocuments();
1983         if (failed.isEmpty())
1984             handler->showMessage(MessageInfo, Tr::tr("Saving succeeded"));
1985         else
1986             handler->showMessage(MessageError, Tr::tr("%n files not saved", 0, failed.size()));
1987     } else if (cmd.matches("q", "quit")) {
1988         // :q[uit]
1989         emit delayedQuitRequested(cmd.hasBang, m_editorToHandler.key(handler));
1990     } else if (cmd.matches("qa", "qall")) {
1991         // :qa[ll]
1992         emit delayedQuitAllRequested(cmd.hasBang);
1993     } else if (cmd.matches("sp", "split")) {
1994         // :sp[lit]
1995         triggerAction(Core::Constants::SPLIT);
1996     } else if (cmd.matches("vs", "vsplit")) {
1997         // :vs[plit]
1998         triggerAction(Core::Constants::SPLIT_SIDE_BY_SIDE);
1999     } else if (cmd.matches("mak", "make")) {
2000         // :mak[e][!] [arguments]
2001         triggerAction(ProjectExplorer::Constants::BUILD);
2002     } else if (cmd.matches("se", "set")) {
2003         if (cmd.args.isEmpty()) {
2004             // :se[t]
2005             ICore::showOptionsDialog(SETTINGS_ID);
2006         } else if (cmd.args == "ic" || cmd.args == "ignorecase") {
2007             // :set nc
2008             setActionChecked(Core::Constants::CASE_SENSITIVE, false);
2009         } else if (cmd.args == "noic" || cmd.args == "noignorecase") {
2010             // :set noic
2011             setActionChecked(Core::Constants::CASE_SENSITIVE, true);
2012         }
2013         *handled = false; // Let the handler see it as well.
2014     } else if (cmd.matches("n", "next")) {
2015         // :n[ext]
2016         switchToFile(currentFile() + cmd.count);
2017     } else if (cmd.matches("prev", "previous") || cmd.matches("N", "Next")) {
2018         // :prev[ious], :N[ext]
2019         switchToFile(currentFile() - cmd.count);
2020     } else if (cmd.matches("bn", "bnext")) {
2021         // :bn[ext]
2022         switchToFile(currentFile() + cmd.count);
2023     } else if (cmd.matches("bp", "bprevious") || cmd.matches("bN", "bNext")) {
2024         // :bp[revious], :bN[ext]
2025         switchToFile(currentFile() - cmd.count);
2026     } else if (cmd.matches("on", "only")) {
2027         // :on[ly]
2028         keepOnlyWindow();
2029     } else if (cmd.cmd == "AS") {
2030         triggerAction(Core::Constants::SPLIT);
2031         triggerAction(CppTools::Constants::SWITCH_HEADER_SOURCE);
2032     } else if (cmd.cmd == "AV") {
2033         triggerAction(Core::Constants::SPLIT_SIDE_BY_SIDE);
2034         triggerAction(CppTools::Constants::SWITCH_HEADER_SOURCE);
2035     } else {
2036         // Check whether one of the configure commands matches.
2037         typedef ExCommandMap::const_iterator Iterator;
2038         const Iterator end = exCommandMap().constEnd();
2039         for (Iterator it = exCommandMap().constBegin(); it != end; ++it) {
2040             const QString &id = it.key();
2041             QRegExp re = it.value();
2042             if (!re.pattern().isEmpty() && re.indexIn(cmd.cmd) != -1) {
2043                 triggerAction(Id::fromString(id));
2044                 return;
2045             }
2046         }
2047         *handled = false;
2048     }
2049 }
2050 
2051 void FakeVimPluginPrivate::handleDelayedQuit(bool forced, IEditor *editor)
2052 {
2053     // This tries to simulate vim behaviour. But the models of vim and
2054     // Qt Creator core do not match well...
2055     if (EditorManager::hasSplitter())
2056         triggerAction(Core::Constants::REMOVE_CURRENT_SPLIT);
2057     else
2058         EditorManager::closeEditor(editor, !forced);
2059 }
2060 
2061 void FakeVimPluginPrivate::handleDelayedQuitAll(bool forced)
2062 {
2063     triggerAction(Core::Constants::REMOVE_ALL_SPLITS);
2064     EditorManager::closeAllEditors(!forced);
2065 }
2066 
2067 void FakeVimPluginPrivate::moveToMatchingParenthesis(FakeVimHandler *, bool *moved, bool *forward,
2068         QTextCursor *cursor)
2069 {
2070     *moved = false;
2071 
2072     bool undoFakeEOL = false;
2073     if (cursor->atBlockEnd() && cursor->block().length() > 1) {
2074         cursor->movePosition(QTextCursor::Left, QTextCursor::KeepAnchor, 1);
2075         undoFakeEOL = true;
2076     }
2077     TextBlockUserData::MatchType match
2078         = TextBlockUserData::matchCursorForward(cursor);
2079     if (match == TextBlockUserData::Match) {
2080         *moved = true;
2081         *forward = true;
2082     } else {
2083         if (undoFakeEOL)
2084             cursor->movePosition(QTextCursor::Right, QTextCursor::KeepAnchor, 1);
2085         if (match == TextBlockUserData::NoMatch) {
2086             // Backward matching is according to the character before the cursor.
2087             bool undoMove = false;
2088             if (!cursor->atBlockEnd()) {
2089                 cursor->movePosition(QTextCursor::Right, QTextCursor::KeepAnchor, 1);
2090                 undoMove = true;
2091             }
2092             match = TextBlockUserData::matchCursorBackward(cursor);
2093             if (match == TextBlockUserData::Match) {
2094                 *moved = true;
2095                 *forward = false;
2096             } else if (undoMove) {
2097                 cursor->movePosition(QTextCursor::Left, QTextCursor::KeepAnchor, 1);
2098             }
2099         }
2100     }
2101 }
2102 
2103 void FakeVimPluginPrivate::indentRegion(FakeVimHandler *handler,
2104         int beginBlock, int endBlock, QChar typedChar)
2105 {
2106     QTC_ASSERT(handler, return);
2107 
2108     TextEditorWidget *bt = qobject_cast<TextEditorWidget *>(handler->widget());
2109     if (!bt)
2110         return;
2111 
2112     TabSettings tabSettings;
2113     tabSettings.m_indentSize = theFakeVimSetting(ConfigShiftWidth)->value().toInt();
2114     tabSettings.m_tabSize = theFakeVimSetting(ConfigTabStop)->value().toInt();
2115     tabSettings.m_tabPolicy = theFakeVimSetting(ConfigExpandTab)->value().toBool()
2116             ? TabSettings::SpacesOnlyTabPolicy : TabSettings::TabsOnlyTabPolicy;
2117 
2118     QTextDocument *doc = bt->document();
2119     QTextBlock startBlock = doc->findBlockByNumber(beginBlock);
2120 
2121     // Record line lenghts for mark adjustments
2122     QVector<int> lineLengths(endBlock - beginBlock + 1);
2123     QTextBlock block = startBlock;
2124 
2125     for (int i = beginBlock; i <= endBlock; ++i) {
2126         lineLengths[i - beginBlock] = block.text().length();
2127         if (typedChar.unicode() == 0 && block.text().simplified().isEmpty()) {
2128             // clear empty lines
2129             QTextCursor cursor(block);
2130             while (!cursor.atBlockEnd())
2131                 cursor.deleteChar();
2132         } else {
2133             bt->textDocument()->indenter()->indentBlock(doc, block, typedChar, tabSettings);
2134         }
2135         block = block.next();
2136     }
2137 }
2138 
2139 void FakeVimPluginPrivate::quitFakeVim()
2140 {
2141     theFakeVimSetting(ConfigUseFakeVim)->setValue(false);
2142 }
2143 
2144 void FakeVimPluginPrivate::resetCommandBuffer()
2145 {
2146     showCommandBuffer(nullptr, QString(), -1, -1, 0);
2147 }
2148 
2149 void FakeVimPluginPrivate::showCommandBuffer(FakeVimHandler *handler, const QString &contents, int cursorPos, int anchorPos,
2150                                              int messageLevel)
2151 {
2152     //qDebug() << "SHOW COMMAND BUFFER" << contents;
2153     if (MiniBuffer *w = qobject_cast<MiniBuffer *>(m_statusBar->widget()))
2154         w->setContents(contents, cursorPos, anchorPos, messageLevel, handler);
2155 }
2156 
2157 void FakeVimPluginPrivate::showExtraInformation(FakeVimHandler *, const QString &text)
2158 {
2159     EditorManager::splitSideBySide();
2160     QString title = "stdout.txt";
2161     IEditor *iedit = EditorManager::openEditorWithContents(Id(), &title, text.toUtf8());
2162     EditorManager::activateEditor(iedit);
2163     FakeVimHandler *handler = m_editorToHandler.value(iedit, 0);
2164     QTC_ASSERT(handler, return);
2165     handler->handleCommand("0");
2166 }
2167 
2168 void FakeVimPluginPrivate::changeSelection(FakeVimHandler *handler, const QList<QTextEdit::ExtraSelection> &selection)
2169 {
2170     QTC_ASSERT(handler, return);
2171     if (TextEditorWidget *bt = qobject_cast<TextEditorWidget *>(handler->widget()))
2172         bt->setExtraSelections(TextEditorWidget::FakeVimSelection, selection);
2173 }
2174 
2175 void FakeVimPluginPrivate::highlightMatches(FakeVimHandler *, const QString &needle)
2176 {
2177     foreach (IEditor *editor, EditorManager::visibleEditors()) {
2178         QWidget *w = editor->widget();
2179         IFindSupport *find = Aggregation::query<IFindSupport>(w);
2180         if (find != 0)
2181             find->highlightAll(needle, FindRegularExpression | FindCaseSensitively);
2182     }
2183 }
2184 
2185 int FakeVimPluginPrivate::currentFile() const
2186 {
2187     IEditor *editor = EditorManager::currentEditor();
2188     if (!editor)
2189         return -1;
2190     return DocumentModel::indexOfDocument(editor->document());
2191 }
2192 
2193 void FakeVimPluginPrivate::switchToFile(int n)
2194 {
2195     int size = DocumentModel::entryCount();
2196     QTC_ASSERT(size, return);
2197     n = n % size;
2198     if (n < 0)
2199         n += size;
2200     EditorManager::activateEditorForEntry(DocumentModel::entries().at(n));
2201 }
2202 
2203 ExCommandMap &FakeVimExCommandsWidget::exCommandMap()
2204 {
2205     return m_q->exCommandMap();
2206 }
2207 
2208 ExCommandMap &FakeVimExCommandsWidget::defaultExCommandMap()
2209 {
2210     return m_q->defaultExCommandMap();
2211 }
2212 
2213 UserCommandMap &FakeVimUserCommandsPage::userCommandMap()
2214 {
2215     return m_q->userCommandMap();
2216 }
2217 
2218 UserCommandMap &FakeVimUserCommandsPage::defaultUserCommandMap()
2219 {
2220     return m_q->defaultUserCommandMap();
2221 }
2222 
2223 ///////////////////////////////////////////////////////////////////////
2224 //
2225 // FakeVimPlugin
2226 //
2227 ///////////////////////////////////////////////////////////////////////
2228 
2229 FakeVimPlugin::FakeVimPlugin()
2230     : d(new FakeVimPluginPrivate(this))
2231 {}
2232 
2233 FakeVimPlugin::~FakeVimPlugin()
2234 {
2235     delete d;
2236 }
2237 
2238 bool FakeVimPlugin::initialize(const QStringList &arguments, QString *errorMessage)
2239 {
2240     Q_UNUSED(arguments)
2241     Q_UNUSED(errorMessage)
2242     return d->initialize();
2243 }
2244 
2245 ExtensionSystem::IPlugin::ShutdownFlag FakeVimPlugin::aboutToShutdown()
2246 {
2247     d->aboutToShutdown();
2248     return SynchronousShutdown;
2249 }
2250 
2251 void FakeVimPlugin::extensionsInitialized()
2252 {
2253     d->m_statusBar = new StatusBarWidget;
2254     d->m_statusBar->setWidget(new MiniBuffer);
2255     d->m_statusBar->setPosition(StatusBarWidget::LastLeftAligned);
2256     addAutoReleasedObject(d->m_statusBar);
2257 }
2258 
2259 #ifdef WITH_TESTS
2260 void FakeVimPlugin::setupTest(QString *title, FakeVimHandler **handler, QWidget **edit)
2261 {
2262     *title = QString::fromLatin1("test.cpp");
2263     IEditor *iedit = EditorManager::openEditorWithContents(Id(), title);
2264     EditorManager::activateEditor(iedit);
2265     *edit = iedit->widget();
2266     *handler = d->m_editorToHandler.value(iedit, 0);
2267     (*handler)->setupWidget();
2268     (*handler)->handleCommand("set startofline");
2269 
2270 //    *handler = 0;
2271 //    m_statusMessage.clear();
2272 //    m_statusData.clear();
2273 //    m_infoMessage.clear();
2274 //    if (m_textedit) {
2275 //        m_textedit->setPlainText(lines);
2276 //        QTextCursor tc = m_textedit->textCursor();
2277 //        tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor);
2278 //        m_textedit->setTextCursor(tc);
2279 //        m_textedit->setPlainText(lines);
2280 //        *handler = new FakeVimHandler(m_textedit);
2281 //    } else {
2282 //        m_plaintextedit->setPlainText(lines);
2283 //        QTextCursor tc = m_plaintextedit->textCursor();
2284 //        tc.movePosition(QTextCursor::Start, QTextCursor::MoveAnchor);
2285 //        m_plaintextedit->setTextCursor(tc);
2286 //        m_plaintextedit->setPlainText(lines);
2287 //        *handler = new FakeVimHandler(m_plaintextedit);
2288 //    }
2289 
2290 //    connect(*handler, &FakeVimHandler::commandBufferChanged,
2291 //            this, &FakeVimPlugin::changeStatusMessage);
2292 //    connect(*handler, &FakeVimHandler::extraInformationChanged,
2293 //            this, &FakeVimPlugin::changeExtraInformation);
2294 //    connect(*handler, &FakeVimHandler::statusDataChanged,
2295 //            this, &FakeVimPlugin::changeStatusData);
2296 
2297 //    QCOMPARE(EDITOR(toPlainText()), lines);
2298     (*handler)->handleCommand("set iskeyword=@,48-57,_,192-255,a-z,A-Z");
2299 }
2300 #endif
2301 
2302 } // namespace Internal
2303 } // namespace FakeVim
2304 
2305 #include "fakevimplugin.moc"
