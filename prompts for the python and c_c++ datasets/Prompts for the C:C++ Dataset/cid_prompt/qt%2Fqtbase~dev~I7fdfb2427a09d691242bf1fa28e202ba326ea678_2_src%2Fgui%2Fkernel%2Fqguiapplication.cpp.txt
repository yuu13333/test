Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtGui module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qguiapplication.h"
42 
43 #include "private/qguiapplication_p.h"
44 #include "private/qabstractfileiconprovider_p.h"
45 #include <qpa/qplatformintegrationfactory_p.h>
46 #include "private/qevent_p.h"
47 #include "qfont.h"
48 #include "qpointingdevice.h"
49 #include <qpa/qplatformfontdatabase.h>
50 #include <qpa/qplatformwindow.h>
51 #include <qpa/qplatformnativeinterface.h>
52 #include <qpa/qplatformtheme.h>
53 #include <qpa/qplatformintegration.h>
54 
55 #include <QtCore/QAbstractEventDispatcher>
56 #include <QtCore/QStandardPaths>
57 #include <QtCore/QVariant>
58 #include <QtCore/private/qcoreapplication_p.h>
59 #include <QtCore/private/qabstracteventdispatcher_p.h>
60 #include <QtCore/qmutex.h>
61 #include <QtCore/private/qthread_p.h>
62 #include <QtCore/private/qlocking_p.h>
63 #include <QtCore/private/qflatmap_p.h>
64 #include <QtCore/qdir.h>
65 #include <QtCore/qlibraryinfo.h>
66 #include <QtCore/qnumeric.h>
67 #include <QtDebug>
68 #ifndef QT_NO_ACCESSIBILITY
69 #include "qaccessible.h"
70 #endif
71 #include <qpalette.h>
72 #include <qscreen.h>
73 #include "qsessionmanager.h"
74 #include <private/qcolortrclut_p.h>
75 #include <private/qscreen_p.h>
76 
77 #include <QtGui/qgenericpluginfactory.h>
78 #include <QtGui/qstylehints.h>
79 #include <QtGui/qinputmethod.h>
80 #include <QtGui/qpixmapcache.h>
81 #include <qpa/qplatforminputcontext.h>
82 #include <qpa/qplatforminputcontext_p.h>
83 
84 #include <qpa/qwindowsysteminterface.h>
85 #include <qpa/qwindowsysteminterface_p.h>
86 #include "private/qwindow_p.h"
87 #include "private/qcursor_p.h"
88 #include "private/qopenglcontext_p.h"
89 #include "private/qinputdevicemanager_p.h"
90 #include "private/qinputmethod_p.h"
91 #include "private/qpointingdevice_p.h"
92 
93 #include <qpa/qplatformthemefactory_p.h>
94 
95 #if QT_CONFIG(draganddrop)
96 #include <qpa/qplatformdrag.h>
97 #include <private/qdnd_p.h>
98 #endif
99 
100 #ifndef QT_NO_CURSOR
101 #include <qpa/qplatformcursor.h>
102 #endif
103 
104 #include <QtGui/QPixmap>
105 
106 #ifndef QT_NO_CLIPBOARD
107 #include <QtGui/QClipboard>
108 #endif
109 
110 #if QT_CONFIG(library)
111 #include <QtCore/QLibrary>
112 #endif
113 
114 #if defined(Q_OS_MAC)
115 #  include "private/qcore_mac_p.h"
116 #elif defined(Q_OS_WIN)
117 #  include <QtCore/qt_windows.h>
118 #  include <QtCore/QLibraryInfo>
119 #endif // Q_OS_WIN
120 
121 #ifdef Q_OS_WASM
122 #include <emscripten.h>
123 #endif
124 
125 #include <qtgui_tracepoints_p.h>
126 
127 #include <ctype.h>
128 
129 QT_BEGIN_NAMESPACE
130 
131 // Helper macro for static functions to check on the existence of the application class.
132 #define CHECK_QAPP_INSTANCE(...) \
133     if (Q_LIKELY(QCoreApplication::instance())) { \
134     } else { \
135         qWarning("Must construct a QGuiApplication first."); \
136         return __VA_ARGS__; \
137     }
138 
139 Q_CORE_EXPORT void qt_call_post_routines();
140 Q_GUI_EXPORT bool qt_is_gui_used = true;
141 
142 Qt::MouseButtons QGuiApplicationPrivate::mouse_buttons = Qt::NoButton;
143 Qt::KeyboardModifiers QGuiApplicationPrivate::modifier_buttons = Qt::NoModifier;
144 
145 QPointF QGuiApplicationPrivate::lastCursorPosition(qInf(), qInf());
146 
147 QWindow *QGuiApplicationPrivate::currentMouseWindow = nullptr;
148 
149 QString QGuiApplicationPrivate::styleOverride;
150 
151 Qt::ApplicationState QGuiApplicationPrivate::applicationState = Qt::ApplicationInactive;
152 
153 Qt::HighDpiScaleFactorRoundingPolicy QGuiApplicationPrivate::highDpiScaleFactorRoundingPolicy =
154     Qt::HighDpiScaleFactorRoundingPolicy::PassThrough;
155 
156 QPointer<QWindow> QGuiApplicationPrivate::currentDragWindow;
157 
158 QList<QGuiApplicationPrivate::TabletPointData> QGuiApplicationPrivate::tabletDevicePoints; // TODO remove
159 
160 QPlatformIntegration *QGuiApplicationPrivate::platform_integration = nullptr;
161 QPlatformTheme *QGuiApplicationPrivate::platform_theme = nullptr;
162 
163 QList<QObject *> QGuiApplicationPrivate::generic_plugin_list;
164 
165 enum ApplicationResourceFlags
166 {
167     ApplicationFontExplicitlySet = 0x2
168 };
169 
170 static unsigned applicationResourceFlags = 0;
171 
172 QIcon *QGuiApplicationPrivate::app_icon = nullptr;
173 
174 QString *QGuiApplicationPrivate::platform_name = nullptr;
175 QString *QGuiApplicationPrivate::displayName = nullptr;
176 QString *QGuiApplicationPrivate::desktopFileName = nullptr;
177 
178 QPalette *QGuiApplicationPrivate::app_pal = nullptr;        // default application palette
179 
180 Qt::MouseButton QGuiApplicationPrivate::mousePressButton = Qt::NoButton;
181 
182 static int mouseDoubleClickDistance = 0;
183 static int touchDoubleTapDistance = 0;
184 
185 QWindow *QGuiApplicationPrivate::currentMousePressWindow = nullptr;
186 
187 static Qt::LayoutDirection layout_direction = Qt::LayoutDirectionAuto;
188 static bool force_reverse = false;
189 
190 QGuiApplicationPrivate *QGuiApplicationPrivate::self = nullptr;
191 int QGuiApplicationPrivate::m_fakeMouseSourcePointId = -1;
192 
193 #ifndef QT_NO_CLIPBOARD
194 QClipboard *QGuiApplicationPrivate::qt_clipboard = nullptr;
195 #endif
196 
197 QList<QScreen *> QGuiApplicationPrivate::screen_list;
198 
199 QWindowList QGuiApplicationPrivate::window_list;
200 QWindow *QGuiApplicationPrivate::focus_window = nullptr;
201 
202 static QBasicMutex applicationFontMutex;
203 QFont *QGuiApplicationPrivate::app_font = nullptr;
204 QStyleHints *QGuiApplicationPrivate::styleHints = nullptr;
205 bool QGuiApplicationPrivate::obey_desktop_settings = true;
206 
207 QInputDeviceManager *QGuiApplicationPrivate::m_inputDeviceManager = nullptr;
208 
209 qreal QGuiApplicationPrivate::m_maxDevicePixelRatio = 0.0;
210 
211 static qreal fontSmoothingGamma = 1.7;
212 
213 bool QGuiApplicationPrivate::quitOnLastWindowClosed = true;
214 
215 extern void qRegisterGuiVariant();
216 #if QT_CONFIG(animation)
217 extern void qRegisterGuiGetInterpolator();
218 #endif
219 
220 static bool qt_detectRTLLanguage()
221 {
222     return force_reverse ^
223         (QGuiApplication::tr("QT_LAYOUT_DIRECTION",
224                          "Translate this string to the string 'LTR' in left-to-right"
225                          " languages or to 'RTL' in right-to-left languages (such as Hebrew"
226                          " and Arabic) to get proper widget layout.") == QLatin1String("RTL"));
227 }
228 
229 static void initFontUnlocked()
230 {
231     if (!QGuiApplicationPrivate::app_font) {
232         if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
233             if (const QFont *font = theme->font(QPlatformTheme::SystemFont))
234                 QGuiApplicationPrivate::app_font = new QFont(*font);
235     }
236     if (!QGuiApplicationPrivate::app_font)
237         QGuiApplicationPrivate::app_font =
238             new QFont(QGuiApplicationPrivate::platformIntegration()->fontDatabase()->defaultFont());
239 }
240 
241 static inline void clearFontUnlocked()
242 {
243     delete QGuiApplicationPrivate::app_font;
244     QGuiApplicationPrivate::app_font = nullptr;
245 }
246 
247 static void initThemeHints()
248 {
249     mouseDoubleClickDistance = QGuiApplicationPrivate::platformTheme()->themeHint(QPlatformTheme::MouseDoubleClickDistance).toInt();
250     touchDoubleTapDistance = QGuiApplicationPrivate::platformTheme()->themeHint(QPlatformTheme::TouchDoubleTapDistance).toInt();
251 }
252 
253 static bool checkNeedPortalSupport()
254 {
255 #if QT_CONFIG(dbus)
256     return !QStandardPaths::locate(QStandardPaths::RuntimeLocation, QLatin1String("flatpak-info")).isEmpty() || qEnvironmentVariableIsSet("SNAP");
257 #else
258     return false;
259 #endif // QT_CONFIG(dbus)
260 }
261 
262 // Using aggregate initialization instead of ctor so we can have a POD global static
263 #define Q_WINDOW_GEOMETRY_SPECIFICATION_INITIALIZER { Qt::TopLeftCorner, -1, -1, -1, -1 }
264 
265 // Geometry specification for top level windows following the convention of the
266 // -geometry command line arguments in X11 (see XParseGeometry).
267 struct QWindowGeometrySpecification
268 {
269     static QWindowGeometrySpecification fromArgument(const QByteArray &a);
270     void applyTo(QWindow *window) const;
271 
272     Qt::Corner corner;
273     int xOffset;
274     int yOffset;
275     int width;
276     int height;
277 };
278 
279 // Parse a token of a X11 geometry specification "200x100+10-20".
280 static inline int nextGeometryToken(const QByteArray &a, int &pos, char *op)
281 {
282     *op = 0;
283     const int size = a.size();
284     if (pos >= size)
285         return -1;
286 
287     *op = a.at(pos);
288     if (*op == '+' || *op == '-' || *op == 'x')
289         pos++;
290     else if (isdigit(*op))
291         *op = 'x'; // If it starts with a digit, it is supposed to be a width specification.
292     else
293         return -1;
294 
295     const int numberPos = pos;
296     for ( ; pos < size && isdigit(a.at(pos)); ++pos) ;
297 
298     bool ok;
299     const int result = a.mid(numberPos, pos - numberPos).toInt(&ok);
300     return ok ? result : -1;
301 }
302 
303 QWindowGeometrySpecification QWindowGeometrySpecification::fromArgument(const QByteArray &a)
304 {
305     QWindowGeometrySpecification result = Q_WINDOW_GEOMETRY_SPECIFICATION_INITIALIZER;
306     int pos = 0;
307     for (int i = 0; i < 4; ++i) {
308         char op;
309         const int value = nextGeometryToken(a, pos, &op);
310         if (value < 0)
311             break;
312         switch (op) {
313         case 'x':
314             (result.width >= 0 ? result.height : result.width) = value;
315             break;
316         case '+':
317         case '-':
318             if (result.xOffset >= 0) {
319                 result.yOffset = value;
320                 if (op == '-')
321                     result.corner = result.corner == Qt::TopRightCorner ? Qt::BottomRightCorner : Qt::BottomLeftCorner;
322             } else {
323                 result.xOffset = value;
324                 if (op == '-')
325                     result.corner = Qt::TopRightCorner;
326             }
327         }
328     }
329     return result;
330 }
331 
332 void QWindowGeometrySpecification::applyTo(QWindow *window) const
333 {
334     QRect windowGeometry = window->frameGeometry();
335     QSize size = windowGeometry.size();
336     if (width >= 0 || height >= 0) {
337         const QSize windowMinimumSize = window->minimumSize();
338         const QSize windowMaximumSize = window->maximumSize();
339         if (width >= 0)
340             size.setWidth(qBound(windowMinimumSize.width(), width, windowMaximumSize.width()));
341         if (height >= 0)
342             size.setHeight(qBound(windowMinimumSize.height(), height, windowMaximumSize.height()));
343         window->resize(size);
344     }
345     if (xOffset >= 0 || yOffset >= 0) {
346         const QRect availableGeometry = window->screen()->virtualGeometry();
347         QPoint topLeft = windowGeometry.topLeft();
348         if (xOffset >= 0) {
349             topLeft.setX(corner == Qt::TopLeftCorner || corner == Qt::BottomLeftCorner ?
350                          xOffset :
351                          qMax(availableGeometry.right() - size.width() - xOffset, availableGeometry.left()));
352         }
353         if (yOffset >= 0) {
354             topLeft.setY(corner == Qt::TopLeftCorner || corner == Qt::TopRightCorner ?
355                          yOffset :
356                          qMax(availableGeometry.bottom() - size.height() - yOffset, availableGeometry.top()));
357         }
358         window->setFramePosition(topLeft);
359     }
360 }
361 
362 static QWindowGeometrySpecification windowGeometrySpecification = Q_WINDOW_GEOMETRY_SPECIFICATION_INITIALIZER;
363 
364 /*!
365     \macro qGuiApp
366     \relates QGuiApplication
367 
368     A global pointer referring to the unique application object.
369     Only valid for use when that object is a QGuiApplication.
370 
371     \sa QCoreApplication::instance(), qApp
372 */
373 
374 /*!
375     \class QGuiApplication
376     \brief The QGuiApplication class manages the GUI application's control
377     flow and main settings.
378 
379     \inmodule QtGui
380     \since 5.0
381 
382     QGuiApplication contains the main event loop, where all events from the window
383     system and other sources are processed and dispatched. It also handles the
384     application's initialization and finalization, and provides session management.
385     In addition, QGuiApplication handles most of the system-wide and application-wide
386     settings.
387 
388     For any GUI application using Qt, there is precisely \b one QGuiApplication
389     object no matter whether the application has 0, 1, 2 or more windows at
390     any given time. For non-GUI Qt applications, use QCoreApplication instead,
391     as it does not depend on the Qt GUI module. For QWidget based Qt applications,
392     use QApplication instead, as it provides some functionality needed for creating
393     QWidget instances.
394 
395     The QGuiApplication object is accessible through the instance() function, which
396     returns a pointer equivalent to the global \l qApp pointer.
397 
398     QGuiApplication's main areas of responsibility are:
399         \list
400             \li  It initializes the application with the user's desktop settings,
401                 such as palette(), font() and styleHints(). It keeps
402                 track of these properties in case the user changes the desktop
403                 globally, for example, through some kind of control panel.
404 
405             \li  It performs event handling, meaning that it receives events
406                 from the underlying window system and dispatches them to the
407                 relevant widgets. You can send your own events to windows by
408                 using sendEvent() and postEvent().
409 
410             \li  It parses common command line arguments and sets its internal
411                 state accordingly. See the \l{QGuiApplication::QGuiApplication()}
412                 {constructor documentation} below for more details.
413 
414             \li  It provides localization of strings that are visible to the
415                 user via translate().
416 
417             \li  It provides some magical objects like the clipboard().
418 
419             \li  It knows about the application's windows. You can ask which
420                 window is at a certain position using topLevelAt(), get a list of
421                 topLevelWindows(), etc.
422 
423             \li  It manages the application's mouse cursor handling, see
424                 setOverrideCursor()
425 
426             \li  It provides support for sophisticated \l{Session Management}
427                 {session management}. This makes it possible for applications
428                 to terminate gracefully when the user logs out, to cancel a
429                 shutdown process if termination isn't possible and even to
430                 preserve the entire application's state for a future session.
431                 See isSessionRestored(), sessionId() and commitDataRequest() and
432                 saveStateRequest() for details.
433         \endlist
434 
435     Since the QGuiApplication object does so much initialization, it \e{must} be
436     created before any other objects related to the user interface are created.
437     QGuiApplication also deals with common command line arguments. Hence, it is
438     usually a good idea to create it \e before any interpretation or
439     modification of \c argv is done in the application itself.
440 
441     \table
442     \header
443         \li{2,1} Groups of functions
444 
445         \row
446         \li  System settings
447         \li  desktopSettingsAware(),
448             setDesktopSettingsAware(),
449             styleHints(),
450             palette(),
451             setPalette(),
452             font(),
453             setFont().
454 
455         \row
456         \li  Event handling
457         \li  exec(),
458             processEvents(),
459             exit(),
460             quit().
461             sendEvent(),
462             postEvent(),
463             sendPostedEvents(),
464             removePostedEvents(),
465             notify().
466 
467         \row
468         \li  Windows
469         \li  allWindows(),
470             topLevelWindows(),
471             focusWindow(),
472             clipboard(),
473             topLevelAt().
474 
475         \row
476         \li  Advanced cursor handling
477         \li  overrideCursor(),
478             setOverrideCursor(),
479             restoreOverrideCursor().
480 
481         \row
482         \li  Session management
483         \li  isSessionRestored(),
484             sessionId(),
485             commitDataRequest(),
486             saveStateRequest().
487 
488         \row
489         \li  Miscellaneous
490         \li  startingUp(),
491             closingDown().
492     \endtable
493 
494     \sa QCoreApplication, QAbstractEventDispatcher, QEventLoop
495 */
496 
497 /*!
498     Initializes the window system and constructs an application object with
499     \a argc command line arguments in \a argv.
500 
501     \warning The data referred to by \a argc and \a argv must stay valid for
502     the entire lifetime of the QGuiApplication object. In addition, \a argc must
503     be greater than zero and \a argv must contain at least one valid character
504     string.
505 
506     The global \c qApp pointer refers to this application object. Only one
507     application object should be created.
508 
509     This application object must be constructed before any \l{QPaintDevice}
510     {paint devices} (including pixmaps, bitmaps etc.).
511 
512     \note \a argc and \a argv might be changed as Qt removes command line
513     arguments that it recognizes.
514 
515     \section1 Supported Command Line Options
516 
517     All Qt programs automatically support a set of command-line options that
518     allow modifying the way Qt will interact with the windowing system. Some of
519     the options are also accessible via environment variables, which are the
520     preferred form if the application can launch GUI sub-processes or other
521     applications (environment variables will be inherited by child processes).
522     When in doubt, use the environment variables.
523 
524     The options currently supported are the following:
525     \list
526 
527         \li \c{-platform} \e {platformName[:options]}, specifies the
528             \l{Qt Platform Abstraction} (QPA) plugin.
529 
530             Overrides the \c QT_QPA_PLATFORM environment variable.
531         \li \c{-platformpluginpath} \e path, specifies the path to platform
532             plugins.
533 
534             Overrides the \c QT_QPA_PLATFORM_PLUGIN_PATH environment variable.
535 
536         \li \c{-platformtheme} \e platformTheme, specifies the platform theme.
537 
538             Overrides the \c QT_QPA_PLATFORMTHEME environment variable.
539 
540         \li \c{-plugin} \e plugin, specifies additional plugins to load. The argument
541             may appear multiple times.
542 
543             Concatenated with the plugins in the \c QT_QPA_GENERIC_PLUGINS environment
544             variable.
545 
546         \li \c{-qmljsdebugger=}, activates the QML/JS debugger with a specified port.
547             The value must be of format \c{port:1234}\e{[,block]}, where
548             \e block is optional
549             and will make the application wait until a debugger connects to it.
550         \li \c {-qwindowgeometry} \e geometry, specifies window geometry for
551             the main window using the X11-syntax. For example:
552             \c {-qwindowgeometry 100x100+50+50}
553         \li \c {-qwindowicon}, sets the default window icon
554         \li \c {-qwindowtitle}, sets the title of the first window
555         \li \c{-reverse}, sets the application's layout direction to
556             Qt::RightToLeft. This option is intended to aid debugging and should
557             not be used in production. The default value is automatically detected
558             from the user's locale (see also QLocale::textDirection()).
559         \li \c{-session} \e session, restores the application from an earlier
560             \l{Session Management}{session}.
561     \endlist
562 
563     The following standard command line options are available for X11:
564 
565     \list
566         \li \c {-display} \e {hostname:screen_number}, switches displays on X11.
567 
568              Overrides the \c DISPLAY environment variable.
569         \li \c {-geometry} \e geometry, same as \c {-qwindowgeometry}.
570     \endlist
571 
572     \section1 Platform-Specific Arguments
573 
574     You can specify platform-specific arguments for the \c{-platform} option.
575     Place them after the platform plugin name following a colon as a
576     comma-separated list. For example,
577     \c{-platform windows:dialogs=xp,fontengine=freetype}.
578 
579     The following parameters are available for \c {-platform windows}:
580 
581     \list
582         \li \c {altgr}, detect the key \c {AltGr} found on some keyboards as
583                Qt::GroupSwitchModifier (since Qt 5.12).
584         \li \c {darkmode=[1|2]} controls how Qt responds to the activation
585                of the \e{Dark Mode for applications} introduced in Windows 10
586                1903 (since Qt 5.15).
587 
588                A value of 1 causes Qt to switch the window borders to black
589                when \e{Dark Mode for applications} is activated and no High
590                Contrast Theme is in use. This is intended for applications
591                that implement their own theming.
592 
593                A value of 2 will in addition cause the Windows Vista style to
594                be deactivated and switch to the Windows style using a
595                simplified palette in dark mode. This is currently
596                experimental pending the introduction of new style that
597                properly adapts to dark mode.
598 
599         \li \c {dialogs=[xp|none]}, \c xp uses XP-style native dialogs and
600             \c none disables them.
601 
602         \li \c {fontengine=freetype}, uses the FreeType font engine.
603         \li \c {fontengine=directwrite}, uses the experimental DirectWrite
604                font database and defaults to using the DirectWrite font
605                engine (which is otherwise only used for some font types
606                or font properties.) This affects font selection and aims
607                to provide font naming more consistent with other platforms,
608                but does not support all font formats, such as Postscript
609                Type-1 or Microsoft FNT fonts.
610         \li \c {menus=[native|none]}, controls the use of native menus.
611 
612                Native menus are implemented using Win32 API and are simpler than
613                QMenu-based menus in for example that they do allow for placing
614                widgets on them or changing properties like fonts and do not
615                provide hover signals. They are mainly intended for Qt Quick.
616                By default, they will be used if the application is not an
617                instance of QApplication or for Qt Quick Controls 2
618                applications (since Qt 5.10).
619 
620         \li \c {nocolorfonts} Turn off DirectWrite Color fonts
621                (since Qt 5.8).
622 
623         \li \c {nodirectwrite} Turn off DirectWrite fonts (since Qt 5.8).
624 
625         \li \c {nomousefromtouch} Ignores mouse events synthesized
626                from touch events by the operating system.
627 
628         \li \c {nowmpointer} Switches from Pointer Input Messages handling
629                to legacy mouse handling (since Qt 5.12).
630         \li \c {reverse} Activates Right-to-left mode (experimental).
631                Windows title bars will be shown accordingly in Right-to-left locales
632                (since Qt 5.13).
633         \li \c {tabletabsoluterange=<value>} Sets a value for mouse mode detection
634                of WinTab tablets (Legacy, since Qt 5.3).
635     \endlist
636 
637     The following parameter is available for \c {-platform cocoa} (on macOS):
638 
639     \list
640         \li \c {fontengine=freetype}, uses the FreeType font engine.
641     \endlist
642 
643     For more information about the platform-specific arguments available for
644     embedded Linux platforms, see \l{Qt for Embedded Linux}.
645 
646     \sa arguments() QGuiApplication::platformName
647 */
648 #ifdef Q_QDOC
649 QGuiApplication::QGuiApplication(int &argc, char **argv)
650 #else
651 QGuiApplication::QGuiApplication(int &argc, char **argv, int flags)
652 #endif
653     : QCoreApplication(*new QGuiApplicationPrivate(argc, argv, flags))
654 {
655     d_func()->init();
656 
657     QCoreApplicationPrivate::eventDispatcher->startingUp();
658 }
659 
660 /*!
661     \internal
662 */
663 QGuiApplication::QGuiApplication(QGuiApplicationPrivate &p)
664     : QCoreApplication(p)
665 {
666 }
667 
668 /*!
669     Destructs the application.
670 */
671 QGuiApplication::~QGuiApplication()
672 {
673     Q_D(QGuiApplication);
674 
675     qt_call_post_routines();
676 
677     d->eventDispatcher->closingDown();
678     d->eventDispatcher = nullptr;
679 
680 #ifndef QT_NO_CLIPBOARD
681     delete QGuiApplicationPrivate::qt_clipboard;
682     QGuiApplicationPrivate::qt_clipboard = nullptr;
683 #endif
684 
685 #ifndef QT_NO_SESSIONMANAGER
686     delete d->session_manager;
687     d->session_manager = nullptr;
688 #endif //QT_NO_SESSIONMANAGER
689 
690     QGuiApplicationPrivate::clearPalette();
691     QFontDatabase::removeAllApplicationFonts();
692 
693 #ifndef QT_NO_CURSOR
694     d->cursor_list.clear();
695 #endif
696 
697     delete QGuiApplicationPrivate::app_icon;
698     QGuiApplicationPrivate::app_icon = nullptr;
699     delete QGuiApplicationPrivate::platform_name;
700     QGuiApplicationPrivate::platform_name = nullptr;
701     delete QGuiApplicationPrivate::displayName;
702     QGuiApplicationPrivate::displayName = nullptr;
703     delete QGuiApplicationPrivate::m_inputDeviceManager;
704     QGuiApplicationPrivate::m_inputDeviceManager = nullptr;
705     delete QGuiApplicationPrivate::desktopFileName;
706     QGuiApplicationPrivate::desktopFileName = nullptr;
707     QGuiApplicationPrivate::mouse_buttons = Qt::NoButton;
708     QGuiApplicationPrivate::modifier_buttons = Qt::NoModifier;
709     QGuiApplicationPrivate::lastCursorPosition = {qreal(qInf()), qreal(qInf())};
710     QGuiApplicationPrivate::currentMousePressWindow = QGuiApplicationPrivate::currentMouseWindow = nullptr;
711     QGuiApplicationPrivate::applicationState = Qt::ApplicationInactive;
712     QGuiApplicationPrivate::currentDragWindow = nullptr;
713     QGuiApplicationPrivate::tabletDevicePoints.clear();
714 }
715 
716 QGuiApplicationPrivate::QGuiApplicationPrivate(int &argc, char **argv, int flags)
717     : QCoreApplicationPrivate(argc, argv, flags),
718       inputMethod(nullptr),
719       lastTouchType(QEvent::TouchEnd),
720       ownGlobalShareContext(false)
721 {
722     self = this;
723     application_type = QCoreApplicationPrivate::Gui;
724 #ifndef QT_NO_SESSIONMANAGER
725     is_session_restored = false;
726     is_saving_session = false;
727 #endif
728 }
729 
730 /*!
731     \property QGuiApplication::applicationDisplayName
732     \brief the user-visible name of this application
733     \since 5.0
734 
735     This name is shown to the user, for instance in window titles.
736     It can be translated, if necessary.
737 
738     If not set, the application display name defaults to the application name.
739 
740     \sa applicationName
741 */
742 void QGuiApplication::setApplicationDisplayName(const QString &name)
743 {
744     if (!QGuiApplicationPrivate::displayName) {
745         QGuiApplicationPrivate::displayName = new QString(name);
746         if (qGuiApp) {
747             disconnect(qGuiApp, &QGuiApplication::applicationNameChanged,
748                     qGuiApp, &QGuiApplication::applicationDisplayNameChanged);
749 
750             if (*QGuiApplicationPrivate::displayName != applicationName())
751                 emit qGuiApp->applicationDisplayNameChanged();
752         }
753     } else if (name != *QGuiApplicationPrivate::displayName) {
754         *QGuiApplicationPrivate::displayName = name;
755         if (qGuiApp)
756             emit qGuiApp->applicationDisplayNameChanged();
757     }
758 }
759 
760 QString QGuiApplication::applicationDisplayName()
761 {
762     return QGuiApplicationPrivate::displayName ? *QGuiApplicationPrivate::displayName : applicationName();
763 }
764 
765 /*!
766     \property QGuiApplication::desktopFileName
767     \brief the base name of the desktop entry for this application
768     \since 5.7
769 
770     This is the file name, without the full path, of the desktop entry
771     that represents this application according to the freedesktop desktop
772     entry specification.
773 
774     This property gives a precise indication of what desktop entry represents
775     the application and it is needed by the windowing system to retrieve
776     such information without resorting to imprecise heuristics.
777 
778     The latest version of the freedesktop desktop entry specification can be obtained
779     \l{http://standards.freedesktop.org/desktop-entry-spec/latest/}{here}.
780 */
781 void QGuiApplication::setDesktopFileName(const QString &name)
782 {
783     if (!QGuiApplicationPrivate::desktopFileName)
784         QGuiApplicationPrivate::desktopFileName = new QString;
785     *QGuiApplicationPrivate::desktopFileName = name;
786 }
787 
788 QString QGuiApplication::desktopFileName()
789 {
790     return QGuiApplicationPrivate::desktopFileName ? *QGuiApplicationPrivate::desktopFileName : QString();
791 }
792 
793 /*!
794     Returns the most recently shown modal window. If no modal windows are
795     visible, this function returns zero.
796 
797     A modal window is a window which has its
798     \l{QWindow::modality}{modality} property set to Qt::WindowModal
799     or Qt::ApplicationModal. A modal window must be closed before the user can
800     continue with other parts of the program.
801 
802     Modal window are organized in a stack. This function returns the modal
803     window at the top of the stack.
804 
805     \sa Qt::WindowModality, QWindow::setModality()
806 */
807 QWindow *QGuiApplication::modalWindow()
808 {
809     CHECK_QAPP_INSTANCE(nullptr)
810     if (QGuiApplicationPrivate::self->modalWindowList.isEmpty())
811         return nullptr;
812     return QGuiApplicationPrivate::self->modalWindowList.first();
813 }
814 
815 static void updateBlockedStatusRecursion(QWindow *window, bool shouldBeBlocked)
816 {
817     QWindowPrivate *p = qt_window_private(window);
818     if (p->blockedByModalWindow != shouldBeBlocked) {
819         p->blockedByModalWindow = shouldBeBlocked;
820         QEvent e(shouldBeBlocked ? QEvent::WindowBlocked : QEvent::WindowUnblocked);
821         QGuiApplication::sendEvent(window, &e);
822         for (QObject *c : window->children()) {
823             if (c->isWindowType())
824                 updateBlockedStatusRecursion(static_cast<QWindow *>(c), shouldBeBlocked);
825         }
826     }
827 }
828 
829 void QGuiApplicationPrivate::updateBlockedStatus(QWindow *window)
830 {
831     bool shouldBeBlocked = false;
832     const bool popupType = (window->type() == Qt::ToolTip) || (window->type() == Qt::Popup);
833     if (!popupType && !self->modalWindowList.isEmpty())
834         shouldBeBlocked = self->isWindowBlocked(window);
835     updateBlockedStatusRecursion(window, shouldBeBlocked);
836 }
837 
838 // Return whether the window needs to be notified about window blocked events.
839 // As opposed to QGuiApplication::topLevelWindows(), embedded windows are
840 // included in this list (QTBUG-18099).
841 static inline bool needsWindowBlockedEvent(const QWindow *w)
842 {
843     return w->isTopLevel() && w->type() != Qt::Desktop;
844 }
845 
846 void QGuiApplicationPrivate::showModalWindow(QWindow *modal)
847 {
848     self->modalWindowList.prepend(modal);
849 
850     // Send leave for currently entered window if it should be blocked
851     if (currentMouseWindow && !QWindowPrivate::get(currentMouseWindow)->isPopup()) {
852         bool shouldBeBlocked = self->isWindowBlocked(currentMouseWindow);
853         if (shouldBeBlocked) {
854             // Remove the new window from modalWindowList temporarily so leave can go through
855             self->modalWindowList.removeFirst();
856             QEvent e(QEvent::Leave);
857             QGuiApplication::sendEvent(currentMouseWindow, &e);
858             currentMouseWindow = nullptr;
859             self->modalWindowList.prepend(modal);
860         }
861     }
862 
863     for (QWindow *window : qAsConst(QGuiApplicationPrivate::window_list)) {
864         if (needsWindowBlockedEvent(window) && !window->d_func()->blockedByModalWindow)
865             updateBlockedStatus(window);
866     }
867 
868     updateBlockedStatus(modal);
869 }
870 
871 void QGuiApplicationPrivate::hideModalWindow(QWindow *window)
872 {
873     self->modalWindowList.removeAll(window);
874 
875     for (QWindow *window : qAsConst(QGuiApplicationPrivate::window_list)) {
876         if (needsWindowBlockedEvent(window) && window->d_func()->blockedByModalWindow)
877             updateBlockedStatus(window);
878     }
879 }
880 
881 /*
882     Returns \c true if \a window is blocked by a modal window. If \a
883     blockingWindow is non-zero, *blockingWindow will be set to the blocking
884     window (or to zero if \a window is not blocked).
885 */
886 bool QGuiApplicationPrivate::isWindowBlocked(QWindow *window, QWindow **blockingWindow) const
887 {
888     QWindow *unused = nullptr;
889     if (!blockingWindow)
890         blockingWindow = &unused;
891 
892     if (modalWindowList.isEmpty()) {
893         *blockingWindow = nullptr;
894         return false;
895     }
896 
897     for (int i = 0; i < modalWindowList.count(); ++i) {
898         QWindow *modalWindow = modalWindowList.at(i);
899 
900         // A window is not blocked by another modal window if the two are
901         // the same, or if the window is a child of the modal window.
902         if (window == modalWindow || modalWindow->isAncestorOf(window, QWindow::IncludeTransients)) {
903             *blockingWindow = nullptr;
904             return false;
905         }
906 
907         Qt::WindowModality windowModality = modalWindow->modality();
908         switch (windowModality) {
909         case Qt::ApplicationModal:
910         {
911             if (modalWindow != window) {
912                 *blockingWindow = modalWindow;
913                 return true;
914             }
915             break;
916         }
917         case Qt::WindowModal:
918         {
919             QWindow *w = window;
920             do {
921                 QWindow *m = modalWindow;
922                 do {
923                     if (m == w) {
924                         *blockingWindow = m;
925                         return true;
926                     }
927                     QWindow *p = m->parent();
928                     if (!p)
929                         p = m->transientParent();
930                     m = p;
931                 } while (m);
932                 QWindow *p = w->parent();
933                 if (!p)
934                     p = w->transientParent();
935                 w = p;
936             } while (w);
937             break;
938         }
939         default:
940             Q_ASSERT_X(false, "QGuiApplication", "internal error, a modal widget cannot be modeless");
941             break;
942         }
943     }
944     *blockingWindow = nullptr;
945     return false;
946 }
947 
948 /*!
949     Returns the QWindow that receives events tied to focus,
950     such as key events.
951 */
952 QWindow *QGuiApplication::focusWindow()
953 {
954     return QGuiApplicationPrivate::focus_window;
955 }
956 
957 /*!
958     \fn QGuiApplication::focusObjectChanged(QObject *focusObject)
959 
960     This signal is emitted when final receiver of events tied to focus is changed.
961     \a focusObject is the new receiver.
962 
963     \sa focusObject()
964 */
965 
966 /*!
967     \fn QGuiApplication::focusWindowChanged(QWindow *focusWindow)
968 
969     This signal is emitted when the focused window changes.
970     \a focusWindow is the new focused window.
971 
972     \sa focusWindow()
973 */
974 
975 /*!
976     Returns the QObject in currently active window that will be final receiver of events
977     tied to focus, such as key events.
978  */
979 QObject *QGuiApplication::focusObject()
980 {
981     if (focusWindow())
982         return focusWindow()->focusObject();
983     return nullptr;
984 }
985 
986 /*!
987     \fn QGuiApplication::allWindows()
988 
989     Returns a list of all the windows in the application.
990 
991     The list is empty if there are no windows.
992 
993     \sa topLevelWindows()
994  */
995 QWindowList QGuiApplication::allWindows()
996 {
997     return QGuiApplicationPrivate::window_list;
998 }
999 
1000 /*!
1001     \fn QGuiApplication::topLevelWindows()
1002 
1003     Returns a list of the top-level windows in the application.
1004 
1005     \sa allWindows()
1006  */
1007 QWindowList QGuiApplication::topLevelWindows()
1008 {
1009     const QWindowList &list = QGuiApplicationPrivate::window_list;
1010     QWindowList topLevelWindows;
1011     for (int i = 0; i < list.size(); ++i) {
1012         QWindow *window = list.at(i);
1013         if (!window->isTopLevel())
1014             continue;
1015 
1016         // Desktop windows are special, as each individual desktop window
1017         // will report that it's a top level window, but we don't want to
1018         // include them in the application wide list of top level windows.
1019         if (window->type() == Qt::Desktop)
1020             continue;
1021 
1022         // Windows embedded in native windows do not have QWindow parents,
1023         // but they are not true top level windows, so do not include them.
1024         if (window->handle() && window->handle()->isEmbedded())
1025             continue;
1026 
1027         topLevelWindows.prepend(window);
1028     }
1029 
1030     return topLevelWindows;
1031 }
1032 
1033 QScreen *QGuiApplication::primaryScreen()
1034 {
1035     if (QGuiApplicationPrivate::screen_list.isEmpty())
1036         return nullptr;
1037     return QGuiApplicationPrivate::screen_list.at(0);
1038 }
1039 
1040 /*!
1041     Returns a list of all the screens associated with the
1042     windowing system the application is connected to.
1043 */
1044 QList<QScreen *> QGuiApplication::screens()
1045 {
1046     return QGuiApplicationPrivate::screen_list;
1047 }
1048 
1049 /*!
1050     Returns the screen at \a point, or \nullptr if outside of any screen.
1051 
1052     The \a point is in relation to the virtualGeometry() of each set of virtual
1053     siblings. If the point maps to more than one set of virtual siblings the first
1054     match is returned.  If you wish to search only the virtual desktop siblings
1055     of a known screen (for example siblings of the screen of your application
1056     window \c QWidget::windowHandle()->screen()), use QScreen::virtualSiblingAt().
1057 
1058     \since 5.10
1059 */
1060 QScreen *QGuiApplication::screenAt(const QPoint &point)
1061 {
1062     QVarLengthArray<const QScreen *, 8> visitedScreens;
1063     for (const QScreen *screen : QGuiApplication::screens()) {
1064         if (visitedScreens.contains(screen))
1065             continue;
1066 
1067         // The virtual siblings include the screen itself, so iterate directly
1068         for (QScreen *sibling : screen->virtualSiblings()) {
1069             if (sibling->geometry().contains(point))
1070                 return sibling;
1071 
1072             visitedScreens.append(sibling);
1073         }
1074     }
1075 
1076     return nullptr;
1077 }
1078 
1079 /*!
1080     \fn void QGuiApplication::screenAdded(QScreen *screen)
1081 
1082     This signal is emitted whenever a new screen \a screen has been added to the system.
1083 
1084     \sa screens(), primaryScreen, screenRemoved()
1085 */
1086 
1087 /*!
1088     \fn void QGuiApplication::screenRemoved(QScreen *screen)
1089 
1090     This signal is emitted whenever a \a screen is removed from the system. It
1091     provides an opportunity to manage the windows on the screen before Qt falls back
1092     to moving them to the primary screen.
1093 
1094     \sa screens(), screenAdded(), QObject::destroyed(), QWindow::setScreen()
1095 
1096     \since 5.4
1097 */
1098 
1099 
1100 /*!
1101     \property QGuiApplication::primaryScreen
1102 
1103     \brief the primary (or default) screen of the application.
1104 
1105     This will be the screen where QWindows are initially shown, unless otherwise specified.
1106 
1107     The primaryScreenChanged signal was introduced in Qt 5.6.
1108 
1109     \sa screens()
1110 */
1111 
1112 /*!
1113     Returns the highest screen device pixel ratio found on
1114     the system. This is the ratio between physical pixels and
1115     device-independent pixels.
1116 
1117     Use this function only when you don't know which window you are targeting.
1118     If you do know the target window, use QWindow::devicePixelRatio() instead.
1119 
1120     \sa QWindow::devicePixelRatio()
1121 */
1122 qreal QGuiApplication::devicePixelRatio() const
1123 {
1124     if (!qFuzzyIsNull(QGuiApplicationPrivate::m_maxDevicePixelRatio))
1125         return QGuiApplicationPrivate::m_maxDevicePixelRatio;
1126 
1127     QGuiApplicationPrivate::m_maxDevicePixelRatio = 1.0; // make sure we never return 0.
1128     for (QScreen *screen : qAsConst(QGuiApplicationPrivate::screen_list))
1129         QGuiApplicationPrivate::m_maxDevicePixelRatio = qMax(QGuiApplicationPrivate::m_maxDevicePixelRatio, screen->devicePixelRatio());
1130 
1131     return QGuiApplicationPrivate::m_maxDevicePixelRatio;
1132 }
1133 
1134 void QGuiApplicationPrivate::resetCachedDevicePixelRatio()
1135 {
1136     m_maxDevicePixelRatio = 0.0;
1137 }
1138 
1139 /*!
1140     Returns the top level window at the given position \a pos, if any.
1141 */
1142 QWindow *QGuiApplication::topLevelAt(const QPoint &pos)
1143 {
1144     if (QScreen *windowScreen = screenAt(pos)) {
1145         const QPoint devicePosition = QHighDpi::toNativePixels(pos, windowScreen);
1146         return windowScreen->handle()->topLevelAt(devicePosition);
1147     }
1148     return nullptr;
1149 }
1150 
1151 /*!
1152     \property QGuiApplication::platformName
1153     \brief The name of the underlying platform plugin.
1154 
1155     The QPA platform plugins are located in \c {qtbase\src\plugins\platforms}.
1156     At the time of writing, the following platform plugin names are supported:
1157 
1158     \list
1159         \li \c android
1160         \li \c cocoa is a platform plugin for \macos.
1161         \li \c directfb
1162         \li \c eglfs is a platform plugin for running Qt5 applications on top of
1163             EGL and  OpenGL ES 2.0 without an actual windowing system (like X11
1164             or Wayland). For more information, see \l{EGLFS}.
1165         \li \c ios (also used for tvOS)
1166         \li \c linuxfb writes directly to the framebuffer. For more information,
1167             see \l{LinuxFB}.
1168         \li \c minimal is provided as an examples for developers who want to
1169             write their own platform plugins. However, you can use the plugin to
1170             run GUI applications in environments without a GUI, such as servers.
1171         \li \c minimalegl is an example plugin.
1172         \li \c offscreen
1173         \li \c qnx
1174         \li \c windows
1175         \li \c wayland is a platform plugin for modern Linux desktops and some
1176             embedded systems.
1177         \li \c xcb is the X11 plugin used on regular desktop Linux platforms.
1178     \endlist
1179 
1180     For more information about the platform plugins for embedded Linux devices,
1181     see \l{Qt for Embedded Linux}.
1182 */
1183 
1184 QString QGuiApplication::platformName()
1185 {
1186     return QGuiApplicationPrivate::platform_name ?
1187            *QGuiApplicationPrivate::platform_name : QString();
1188 }
1189 
1190 Q_LOGGING_CATEGORY(lcQpaPluginLoading, "qt.qpa.plugin");
1191 Q_LOGGING_CATEGORY(lcPtrDispatch, "qt.pointer.dispatch");
1192 
1193 static void init_platform(const QString &pluginNamesWithArguments, const QString &platformPluginPath, const QString &platformThemeName, int &argc, char **argv)
1194 {
1195     QStringList plugins = pluginNamesWithArguments.split(QLatin1Char(';'), Qt::SkipEmptyParts);
1196     QStringList platformArguments;
1197     QStringList availablePlugins = QPlatformIntegrationFactory::keys(platformPluginPath);
1198     for (const auto &pluginArgument : plugins) {
1199         // Split into platform name and arguments
1200         QStringList arguments = pluginArgument.split(QLatin1Char(':'), Qt::SkipEmptyParts);
1201         if (arguments.isEmpty())
1202             continue;
1203         const QString name = arguments.takeFirst().toLower();
1204         QString argumentsKey = name;
1205         if (name.isEmpty())
1206             continue;
1207         argumentsKey[0] = argumentsKey.at(0).toUpper();
1208         arguments.append(QLibraryInfo::platformPluginArguments(argumentsKey));
1209 
1210         // Create the platform integration.
1211         QGuiApplicationPrivate::platform_integration = QPlatformIntegrationFactory::create(name, arguments, argc, argv, platformPluginPath);
1212         if (Q_UNLIKELY(!QGuiApplicationPrivate::platform_integration)) {
1213             if (availablePlugins.contains(name)) {
1214                 qCInfo(lcQpaPluginLoading).nospace().noquote()
1215                         << "Could not load the Qt platform plugin \"" << name << "\" in \""
1216                         << QDir::toNativeSeparators(platformPluginPath) << "\" even though it was found.";
1217             } else {
1218                 qCWarning(lcQpaPluginLoading).nospace().noquote()
1219                         << "Could not find the Qt platform plugin \"" << name << "\" in \""
1220                         << QDir::toNativeSeparators(platformPluginPath) << "\"";
1221             }
1222         } else {
1223             QGuiApplicationPrivate::platform_name = new QString(name);
1224             platformArguments = arguments;
1225             break;
1226         }
1227     }
1228 
1229     if (Q_UNLIKELY(!QGuiApplicationPrivate::platform_integration)) {
1230         QString fatalMessage = QStringLiteral("This application failed to start because no Qt platform plugin could be initialized. "
1231                                               "Reinstalling the application may fix this problem.\n");
1232 
1233         if (!availablePlugins.isEmpty())
1234             fatalMessage += QStringLiteral("\nAvailable platform plugins are: %1.\n").arg(availablePlugins.join(QLatin1String(", ")));
1235 
1236 #if defined(Q_OS_WIN)
1237         // Windows: Display message box unless it is a console application
1238         // or debug build showing an assert box.
1239         if (!QLibraryInfo::isDebugBuild() && !GetConsoleWindow())
1240             MessageBox(0, (LPCTSTR)fatalMessage.utf16(), (LPCTSTR)(QCoreApplication::applicationName().utf16()), MB_OK | MB_ICONERROR);
1241 #endif // Q_OS_WIN
1242         qFatal("%s", qPrintable(fatalMessage));
1243 
1244         return;
1245     }
1246 
1247     // Create the platform theme:
1248 
1249     // 1) Fetch the platform name from the environment if present.
1250     QStringList themeNames;
1251     if (!platformThemeName.isEmpty())
1252         themeNames.append(platformThemeName);
1253 
1254     // 2) Special case - check whether it's a flatpak or snap app to use xdg-desktop-portal platform theme for portals support
1255     if (checkNeedPortalSupport()) {
1256         themeNames.append(QStringLiteral("xdgdesktopportal"));
1257     }
1258 
1259     // 3) Ask the platform integration for a list of theme names
1260     themeNames += QGuiApplicationPrivate::platform_integration->themeNames();
1261     // 4) Look for a theme plugin.
1262     for (const QString &themeName : qAsConst(themeNames)) {
1263         QGuiApplicationPrivate::platform_theme = QPlatformThemeFactory::create(themeName, platformPluginPath);
1264         if (QGuiApplicationPrivate::platform_theme)
1265             break;
1266     }
1267 
1268     // 5) If no theme plugin was found ask the platform integration to
1269     // create a theme
1270     if (!QGuiApplicationPrivate::platform_theme) {
1271         for (const QString &themeName : qAsConst(themeNames)) {
1272             QGuiApplicationPrivate::platform_theme = QGuiApplicationPrivate::platform_integration->createPlatformTheme(themeName);
1273             if (QGuiApplicationPrivate::platform_theme)
1274                 break;
1275         }
1276         // No error message; not having a theme plugin is allowed.
1277     }
1278 
1279     // 6) Fall back on the built-in "null" platform theme.
1280     if (!QGuiApplicationPrivate::platform_theme)
1281         QGuiApplicationPrivate::platform_theme = new QPlatformTheme;
1282 
1283 #ifndef QT_NO_PROPERTIES
1284     // Set arguments as dynamic properties on the native interface as
1285     // boolean 'foo' or strings: 'foo=bar'
1286     if (!platformArguments.isEmpty()) {
1287         if (QObject *nativeInterface = QGuiApplicationPrivate::platform_integration->nativeInterface()) {
1288             for (const QString &argument : qAsConst(platformArguments)) {
1289                 const int equalsPos = argument.indexOf(QLatin1Char('='));
1290                 const QByteArray name =
1291                     equalsPos != -1 ? argument.left(equalsPos).toUtf8() : argument.toUtf8();
1292                 const QVariant value =
1293                     equalsPos != -1 ? QVariant(argument.mid(equalsPos + 1)) : QVariant(true);
1294                 nativeInterface->setProperty(name.constData(), value);
1295             }
1296         }
1297     }
1298 #endif
1299 
1300     const auto platformIntegration = QGuiApplicationPrivate::platformIntegration();
1301     fontSmoothingGamma = platformIntegration->styleHint(QPlatformIntegration::FontSmoothingGamma).toReal();
1302     QCoreApplication::setAttribute(Qt::AA_DontShowShortcutsInContextMenus,
1303         !platformIntegration->styleHint(QPlatformIntegration::ShowShortcutsInContextMenus).toBool());
1304 }
1305 
1306 static void init_plugins(const QList<QByteArray> &pluginList)
1307 {
1308     for (int i = 0; i < pluginList.count(); ++i) {
1309         QByteArray pluginSpec = pluginList.at(i);
1310         int colonPos = pluginSpec.indexOf(':');
1311         QObject *plugin;
1312         if (colonPos < 0)
1313             plugin = QGenericPluginFactory::create(QLatin1String(pluginSpec), QString());
1314         else
1315             plugin = QGenericPluginFactory::create(QLatin1String(pluginSpec.mid(0, colonPos)),
1316                                                    QLatin1String(pluginSpec.mid(colonPos+1)));
1317         if (plugin)
1318             QGuiApplicationPrivate::generic_plugin_list.append(plugin);
1319         else
1320             qWarning("No such plugin for spec \"%s\"", pluginSpec.constData());
1321     }
1322 }
1323 
1324 #if QT_CONFIG(commandlineparser)
1325 void QGuiApplicationPrivate::addQtOptions(QList<QCommandLineOption> *options)
1326 {
1327     QCoreApplicationPrivate::addQtOptions(options);
1328 
1329 #if defined(Q_OS_UNIX) && !defined(Q_OS_DARWIN)
1330     const QByteArray sessionType = qgetenv("XDG_SESSION_TYPE");
1331     const bool x11 = sessionType == "x11";
1332     // Technically the x11 aliases are only available if platformName is "xcb", but we can't know that here.
1333 #else
1334     const bool x11 = false;
1335 #endif
1336 
1337     options->append(QCommandLineOption(QStringLiteral("platform"),
1338                     QGuiApplication::tr("QPA plugin. See QGuiApplication documentation for available options for each plugin."), QStringLiteral("platformName[:options]")));
1339     options->append(QCommandLineOption(QStringLiteral("platformpluginpath"),
1340                     QGuiApplication::tr("Path to the platform plugins."), QStringLiteral("path")));
1341     options->append(QCommandLineOption(QStringLiteral("platformtheme"),
1342                     QGuiApplication::tr("Platform theme."), QStringLiteral("theme")));
1343     options->append(QCommandLineOption(QStringLiteral("plugin"),
1344                     QGuiApplication::tr("Additional plugins to load, can be specified multiple times."), QStringLiteral("plugin")));
1345     options->append(QCommandLineOption(QStringLiteral("qwindowgeometry"),
1346                     QGuiApplication::tr("Window geometry for the main window, using the X11-syntax, like 100x100+50+50."), QStringLiteral("geometry")));
1347     options->append(QCommandLineOption(QStringLiteral("qwindowicon"),
1348                     QGuiApplication::tr("Default window icon."), QStringLiteral("icon")));
1349     options->append(QCommandLineOption(QStringLiteral("qwindowtitle"),
1350                     QGuiApplication::tr("Title of the first window."), QStringLiteral("title")));
1351     options->append(QCommandLineOption(QStringLiteral("reverse"),
1352                     QGuiApplication::tr("Sets the application's layout direction to Qt::RightToLeft (debugging helper).")));
1353     options->append(QCommandLineOption(QStringLiteral("session"),
1354                     QGuiApplication::tr("Restores the application from an earlier session."), QStringLiteral("session")));
1355 
1356     if (x11) {
1357          options->append(QCommandLineOption(QStringLiteral("display"),
1358                          QGuiApplication::tr("Display name, overrides $DISPLAY."), QStringLiteral("display")));
1359          options->append(QCommandLineOption(QStringLiteral("name"),
1360                          QGuiApplication::tr("Instance name according to ICCCM 4.1.2.5."), QStringLiteral("name")));
1361          options->append(QCommandLineOption(QStringLiteral("nograb"),
1362                          QGuiApplication::tr("Disable mouse grabbing (useful in debuggers).")));
1363          options->append(QCommandLineOption(QStringLiteral("dograb"),
1364                          QGuiApplication::tr("Force mouse grabbing (even when running in a debugger).")));
1365          options->append(QCommandLineOption(QStringLiteral("visual"),
1366                          QGuiApplication::tr("ID of the X11 Visual to use."), QStringLiteral("id")));
1367          // Not using the "QStringList names" solution for those aliases, because it makes the first column too wide
1368          options->append(QCommandLineOption(QStringLiteral("geometry"),
1369                          QGuiApplication::tr("Alias for --qwindowgeometry."), QStringLiteral("geometry")));
1370          options->append(QCommandLineOption(QStringLiteral("icon"),
1371                          QGuiApplication::tr("Alias for --qwindowicon."), QStringLiteral("icon")));
1372          options->append(QCommandLineOption(QStringLiteral("title"),
1373                          QGuiApplication::tr("Alias for --qwindowtitle."), QStringLiteral("title")));
1374     }
1375 }
1376 #endif // QT_CONFIG(commandlineparser)
1377 
1378 void QGuiApplicationPrivate::createPlatformIntegration()
1379 {
1380     QHighDpiScaling::initHighDpiScaling();
1381 
1382     // Load the platform integration
1383     QString platformPluginPath = QString::fromLocal8Bit(qgetenv("QT_QPA_PLATFORM_PLUGIN_PATH"));
1384 
1385 
1386     QByteArray platformName;
1387 #ifdef QT_QPA_DEFAULT_PLATFORM_NAME
1388     platformName = QT_QPA_DEFAULT_PLATFORM_NAME;
1389 #endif
1390 #if defined(Q_OS_UNIX) && !defined(Q_OS_DARWIN)
1391     QList<QByteArray> platformArguments = platformName.split(':');
1392     QByteArray platformPluginBase = platformArguments.first();
1393 
1394     const bool hasWaylandDisplay = qEnvironmentVariableIsSet("WAYLAND_DISPLAY");
1395     const bool isWaylandSessionType = qgetenv("XDG_SESSION_TYPE") == "wayland";
1396 
1397     QVector<QByteArray> preferredPlatformOrder;
1398     const bool defaultIsXcb = platformPluginBase == "xcb";
1399     const QByteArray xcbPlatformName = defaultIsXcb ? platformName : "xcb";
1400     if (qEnvironmentVariableIsSet("DISPLAY")) {
1401         preferredPlatformOrder << xcbPlatformName;
1402         if (defaultIsXcb)
1403             platformName.clear();
1404     }
1405 
1406     const bool defaultIsWayland = !defaultIsXcb && platformPluginBase.startsWith("wayland");
1407     const QByteArray waylandPlatformName = defaultIsWayland ? platformName : "wayland";
1408     if (hasWaylandDisplay || isWaylandSessionType) {
1409         preferredPlatformOrder.prepend(waylandPlatformName);
1410 
1411         if (defaultIsWayland)
1412             platformName.clear();
1413     }
1414 
1415     if (!platformName.isEmpty())
1416         preferredPlatformOrder.append(platformName);
1417 
1418     platformName = preferredPlatformOrder.join(';');
1419 #endif
1420 
1421     bool platformExplicitlySelected = false;
1422     QByteArray platformNameEnv = qgetenv("QT_QPA_PLATFORM");
1423     if (!platformNameEnv.isEmpty()) {
1424         platformName = platformNameEnv;
1425         platformExplicitlySelected = true;
1426     }
1427 
1428     QString platformThemeName = QString::fromLocal8Bit(qgetenv("QT_QPA_PLATFORMTHEME"));
1429 
1430     // Get command line params
1431 
1432     QString icon;
1433 
1434     int j = argc ? 1 : 0;
1435     for (int i=1; i<argc; i++) {
1436         if (!argv[i])
1437             continue;
1438         if (*argv[i] != '-') {
1439             argv[j++] = argv[i];
1440             continue;
1441         }
1442         const bool xcbIsDefault = platformName.startsWith("xcb");
1443         const char *arg = argv[i];
1444         if (arg[1] == '-') // startsWith("--")
1445             ++arg;
1446         if (strcmp(arg, "-platformpluginpath") == 0) {
1447             if (++i < argc)
1448                 platformPluginPath = QFile::decodeName(argv[i]);
1449         } else if (strcmp(arg, "-platform") == 0) {
1450             if (++i < argc) {
1451                 platformExplicitlySelected = true;
1452                 platformName = argv[i];
1453             }
1454         } else if (strcmp(arg, "-platformtheme") == 0) {
1455             if (++i < argc)
1456                 platformThemeName = QString::fromLocal8Bit(argv[i]);
1457         } else if (strcmp(arg, "-qwindowgeometry") == 0 || (xcbIsDefault && strcmp(arg, "-geometry") == 0)) {
1458             if (++i < argc)
1459                 windowGeometrySpecification = QWindowGeometrySpecification::fromArgument(argv[i]);
1460         } else if (strcmp(arg, "-qwindowtitle") == 0 || (xcbIsDefault && strcmp(arg, "-title") == 0)) {
1461             if (++i < argc)
1462                 firstWindowTitle = QString::fromLocal8Bit(argv[i]);
1463         } else if (strcmp(arg, "-qwindowicon") == 0 || (xcbIsDefault && strcmp(arg, "-icon") == 0)) {
1464             if (++i < argc) {
1465                 icon = QFile::decodeName(argv[i]);
1466             }
1467         } else {
1468             argv[j++] = argv[i];
1469         }
1470     }
1471 
1472     if (j < argc) {
1473         argv[j] = nullptr;
1474         argc = j;
1475     }
1476 
1477     Q_UNUSED(platformExplicitlySelected);
1478 
1479     init_platform(QLatin1String(platformName), platformPluginPath, platformThemeName, argc, argv);
1480 
1481     if (!icon.isEmpty())
1482         forcedWindowIcon = QDir::isAbsolutePath(icon) ? QIcon(icon) : QIcon::fromTheme(icon);
1483 }
1484 
1485 /*!
1486     Called from QCoreApplication::init()
1487 
1488     Responsible for creating an event dispatcher when QCoreApplication
1489     decides that it needs one (because a custom one has not been set).
1490 */
1491 void QGuiApplicationPrivate::createEventDispatcher()
1492 {
1493     Q_ASSERT(!eventDispatcher);
1494 
1495     if (platform_integration == nullptr)
1496         createPlatformIntegration();
1497 
1498     // The platform integration should not mess with the event dispatcher
1499     Q_ASSERT(!eventDispatcher);
1500 
1501     eventDispatcher = platform_integration->createEventDispatcher();
1502 }
1503 
1504 void QGuiApplicationPrivate::eventDispatcherReady()
1505 {
1506     if (platform_integration == nullptr)
1507         createPlatformIntegration();
1508 
1509     platform_integration->initialize();
1510 }
1511 
1512 void QGuiApplicationPrivate::init()
1513 {
1514     Q_TRACE_SCOPE(QGuiApplicationPrivate_init);
1515 
1516 #if defined(Q_OS_MACOS)
1517     QMacAutoReleasePool pool;
1518 #endif
1519 
1520     QCoreApplicationPrivate::init();
1521 
1522     QCoreApplicationPrivate::is_app_running = false; // Starting up.
1523 
1524     bool loadTestability = false;
1525     QList<QByteArray> pluginList;
1526     // Get command line params
1527 #ifndef QT_NO_SESSIONMANAGER
1528     QString session_id;
1529     QString session_key;
1530 # if defined(Q_OS_WIN)
1531     wchar_t guidstr[40];
1532     GUID guid;
1533     CoCreateGuid(&guid);
1534     StringFromGUID2(guid, guidstr, 40);
1535     session_id = QString::fromWCharArray(guidstr);
1536     CoCreateGuid(&guid);
1537     StringFromGUID2(guid, guidstr, 40);
1538     session_key = QString::fromWCharArray(guidstr);
1539 # endif
1540 #endif
1541     QString s;
1542     int j = argc ? 1 : 0;
1543     for (int i=1; i<argc; i++) {
1544         if (!argv[i])
1545             continue;
1546         if (*argv[i] != '-') {
1547             argv[j++] = argv[i];
1548             continue;
1549         }
1550         const char *arg = argv[i];
1551         if (arg[1] == '-') // startsWith("--")
1552             ++arg;
1553         if (strcmp(arg, "-plugin") == 0) {
1554             if (++i < argc)
1555                 pluginList << argv[i];
1556         } else if (strcmp(arg, "-reverse") == 0) {
1557             force_reverse = true;
1558 #ifdef Q_OS_MAC
1559         } else if (strncmp(arg, "-psn_", 5) == 0) {
1560             // eat "-psn_xxxx" on Mac, which is passed when starting an app from Finder.
1561             // special hack to change working directory (for an app bundle) when running from finder
1562             if (QDir::currentPath() == QLatin1String("/")) {
1563                 QCFType<CFURLRef> bundleURL(CFBundleCopyBundleURL(CFBundleGetMainBundle()));
1564                 QString qbundlePath = QCFString(CFURLCopyFileSystemPath(bundleURL,
1565                                                                         kCFURLPOSIXPathStyle));
1566                 if (qbundlePath.endsWith(QLatin1String(".app")))
1567                     QDir::setCurrent(qbundlePath.section(QLatin1Char('/'), 0, -2));
1568             }
1569 #endif
1570 #ifndef QT_NO_SESSIONMANAGER
1571         } else if (strcmp(arg, "-session") == 0 && i < argc - 1) {
1572             ++i;
1573             if (argv[i] && *argv[i]) {
1574                 session_id = QString::fromLatin1(argv[i]);
1575                 int p = session_id.indexOf(QLatin1Char('_'));
1576                 if (p >= 0) {
1577                     session_key = session_id.mid(p +1);
1578                     session_id = session_id.left(p);
1579                 }
1580                 is_session_restored = true;
1581             }
1582 #endif
1583         } else if (strcmp(arg, "-testability") == 0) {
1584             loadTestability = true;
1585         } else if (strncmp(arg, "-style=", 7) == 0) {
1586             s = QString::fromLocal8Bit(arg + 7);
1587         } else if (strcmp(arg, "-style") == 0 && i < argc - 1) {
1588             s = QString::fromLocal8Bit(argv[++i]);
1589         } else {
1590             argv[j++] = argv[i];
1591         }
1592 
1593         if (!s.isEmpty())
1594             styleOverride = s;
1595     }
1596 
1597     if (j < argc) {
1598         argv[j] = nullptr;
1599         argc = j;
1600     }
1601 
1602     // Load environment exported generic plugins
1603     QByteArray envPlugins = qgetenv("QT_QPA_GENERIC_PLUGINS");
1604     if (!envPlugins.isEmpty())
1605         pluginList += envPlugins.split(',');
1606 
1607     if (platform_integration == nullptr)
1608         createPlatformIntegration();
1609 
1610     updatePalette();
1611     QFont::initialize();
1612     initThemeHints();
1613 
1614 #ifndef QT_NO_CURSOR
1615     QCursorData::initialize();
1616 #endif
1617 
1618     // trigger registering of QVariant's GUI types
1619     qRegisterGuiVariant();
1620 
1621 #if QT_CONFIG(animation)
1622     // trigger registering of animation interpolators
1623     qRegisterGuiGetInterpolator();
1624 #endif
1625 
1626     // set a global share context when enabled unless there is already one
1627 #ifndef QT_NO_OPENGL
1628     if (qApp->testAttribute(Qt::AA_ShareOpenGLContexts) && !qt_gl_global_share_context()) {
1629         QOpenGLContext *ctx = new QOpenGLContext;
1630         ctx->setFormat(QSurfaceFormat::defaultFormat());
1631         ctx->create();
1632         qt_gl_set_global_share_context(ctx);
1633         ownGlobalShareContext = true;
1634     }
1635 #endif
1636 
1637     QWindowSystemInterfacePrivate::eventTime.start();
1638 
1639     is_app_running = true;
1640     init_plugins(pluginList);
1641     QWindowSystemInterface::flushWindowSystemEvents();
1642 
1643     Q_Q(QGuiApplication);
1644 #ifndef QT_NO_SESSIONMANAGER
1645     // connect to the session manager
1646     session_manager = new QSessionManager(q, session_id, session_key);
1647 #endif
1648 
1649 #if QT_CONFIG(library)
1650     if (qEnvironmentVariableIntValue("QT_LOAD_TESTABILITY") > 0)
1651         loadTestability = true;
1652 
1653     if (loadTestability) {
1654         QLibrary testLib(QStringLiteral("qttestability"));
1655         if (Q_UNLIKELY(!testLib.load())) {
1656             qCritical() << "Library qttestability load failed:" << testLib.errorString();
1657         } else {
1658             typedef void (*TasInitialize)(void);
1659             TasInitialize initFunction = (TasInitialize)testLib.resolve("qt_testability_init");
1660             if (Q_UNLIKELY(!initFunction)) {
1661                 qCritical("Library qttestability resolve failed!");
1662             } else {
1663                 initFunction();
1664             }
1665         }
1666     }
1667 #else
1668     Q_UNUSED(loadTestability);
1669 #endif // QT_CONFIG(library)
1670 
1671     if (layout_direction == Qt::LayoutDirectionAuto || force_reverse)
1672         QGuiApplication::setLayoutDirection(qt_detectRTLLanguage() ? Qt::RightToLeft : Qt::LeftToRight);
1673 
1674     if (!QGuiApplicationPrivate::displayName)
1675         QObject::connect(q, &QGuiApplication::applicationNameChanged,
1676                          q, &QGuiApplication::applicationDisplayNameChanged);
1677 }
1678 
1679 extern void qt_cleanupFontDatabase();
1680 
1681 QGuiApplicationPrivate::~QGuiApplicationPrivate()
1682 {
1683     is_app_closing = true;
1684     is_app_running = false;
1685 
1686     for (int i = 0; i < generic_plugin_list.count(); ++i)
1687         delete generic_plugin_list.at(i);
1688     generic_plugin_list.clear();
1689 
1690     clearFontUnlocked();
1691 
1692     QFont::cleanup();
1693 
1694 #ifndef QT_NO_CURSOR
1695     QCursorData::cleanup();
1696 #endif
1697 
1698     layout_direction = Qt::LeftToRight;
1699 
1700     cleanupThreadData();
1701 
1702     delete QGuiApplicationPrivate::styleHints;
1703     QGuiApplicationPrivate::styleHints = nullptr;
1704     delete inputMethod;
1705 
1706     qt_cleanupFontDatabase();
1707 
1708     QPixmapCache::clear();
1709 
1710 #ifndef QT_NO_OPENGL
1711     if (ownGlobalShareContext) {
1712         delete qt_gl_global_share_context();
1713         qt_gl_set_global_share_context(nullptr);
1714     }
1715 #endif
1716 
1717     platform_integration->destroy();
1718 
1719     delete platform_theme;
1720     platform_theme = nullptr;
1721     delete platform_integration;
1722     platform_integration = nullptr;
1723 
1724     window_list.clear();
1725     screen_list.clear();
1726 
1727     self = nullptr;
1728 }
1729 
1730 #if 0
1731 #ifndef QT_NO_CURSOR
1732 QCursor *overrideCursor();
1733 void setOverrideCursor(const QCursor &);
1734 void changeOverrideCursor(const QCursor &);
1735 void restoreOverrideCursor();
1736 #endif
1737 
1738 static QFont font();
1739 static QFont font(const QWidget*);
1740 static QFont font(const char *className);
1741 static void setFont(const QFont &, const char *className = nullptr);
1742 static QFontMetrics fontMetrics();
1743 
1744 #ifndef QT_NO_CLIPBOARD
1745 static QClipboard *clipboard();
1746 #endif
1747 #endif
1748 
1749 /*!
1750     Returns the current state of the modifier keys on the keyboard. The current
1751     state is updated synchronously as the event queue is emptied of events that
1752     will spontaneously change the keyboard state (QEvent::KeyPress and
1753     QEvent::KeyRelease events).
1754 
1755     It should be noted this may not reflect the actual keys held on the input
1756     device at the time of calling but rather the modifiers as last reported in
1757     one of the above events. If no keys are being held Qt::NoModifier is
1758     returned.
1759 
1760     \sa mouseButtons(), queryKeyboardModifiers()
1761 */
1762 Qt::KeyboardModifiers QGuiApplication::keyboardModifiers()
1763 {
1764     return QGuiApplicationPrivate::modifier_buttons;
1765 }
1766 
1767 /*!
1768     \fn Qt::KeyboardModifiers QGuiApplication::queryKeyboardModifiers()
1769 
1770     Queries and returns the state of the modifier keys on the keyboard.
1771     Unlike keyboardModifiers, this method returns the actual keys held
1772     on the input device at the time of calling the method.
1773 
1774     It does not rely on the keypress events having been received by this
1775     process, which makes it possible to check the modifiers while moving
1776     a window, for instance. Note that in most cases, you should use
1777     keyboardModifiers(), which is faster and more accurate since it contains
1778     the state of the modifiers as they were when the currently processed
1779     event was received.
1780 
1781     \sa keyboardModifiers()
1782 */
1783 Qt::KeyboardModifiers QGuiApplication::queryKeyboardModifiers()
1784 {
1785     CHECK_QAPP_INSTANCE(Qt::KeyboardModifiers{})
1786     QPlatformIntegration *pi = QGuiApplicationPrivate::platformIntegration();
1787     return pi->queryKeyboardModifiers();
1788 }
1789 
1790 /*!
1791     Returns the current state of the buttons on the mouse. The current state is
1792     updated synchronously as the event queue is emptied of events that will
1793     spontaneously change the mouse state (QEvent::MouseButtonPress and
1794     QEvent::MouseButtonRelease events).
1795 
1796     It should be noted this may not reflect the actual buttons held on the
1797     input device at the time of calling but rather the mouse buttons as last
1798     reported in one of the above events. If no mouse buttons are being held
1799     Qt::NoButton is returned.
1800 
1801     \sa keyboardModifiers()
1802 */
1803 Qt::MouseButtons QGuiApplication::mouseButtons()
1804 {
1805     return QGuiApplicationPrivate::mouse_buttons;
1806 }
1807 
1808 /*!
1809     \internal
1810     Returns the platform's native interface, for platform specific
1811     functionality.
1812 */
1813 QPlatformNativeInterface *QGuiApplication::platformNativeInterface()
1814 {
1815     QPlatformIntegration *pi = QGuiApplicationPrivate::platformIntegration();
1816     return pi ? pi->nativeInterface() : nullptr;
1817 }
1818 
1819 /*!
1820     \internal
1821     Returns a function pointer from the platformplugin matching \a function
1822 */
1823 QFunctionPointer QGuiApplication::platformFunction(const QByteArray &function)
1824 {
1825     QPlatformIntegration *pi = QGuiApplicationPrivate::platformIntegration();
1826     if (!pi) {
1827         qWarning("QGuiApplication::platformFunction(): Must construct a QGuiApplication before accessing a platform function");
1828         return nullptr;
1829     }
1830 
1831     return pi->nativeInterface() ? pi->nativeInterface()->platformFunction(function) : nullptr;
1832 }
1833 
1834 /*!
1835     Enters the main event loop and waits until exit() is called, and then
1836     returns the value that was set to exit() (which is 0 if exit() is called
1837     via quit()).
1838 
1839     It is necessary to call this function to start event handling. The main
1840     event loop receives events from the window system and dispatches these to
1841     the application widgets.
1842 
1843     Generally, no user interaction can take place before calling exec().
1844 
1845     To make your application perform idle processing, e.g., executing a special
1846     function whenever there are no pending events, use a QTimer with 0 timeout.
1847     More advanced idle processing schemes can be achieved using processEvents().
1848 
1849     We recommend that you connect clean-up code to the
1850     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in your
1851     application's \c{main()} function. This is because, on some platforms, the
1852     QApplication::exec() call may not return.
1853 
1854     \sa quitOnLastWindowClosed, quit(), exit(), processEvents(),
1855         QCoreApplication::exec()
1856 */
1857 int QGuiApplication::exec()
1858 {
1859 #ifndef QT_NO_ACCESSIBILITY
1860     QAccessible::setRootObject(qApp);
1861 #endif
1862     return QCoreApplication::exec();
1863 }
1864 
1865 void QGuiApplicationPrivate::captureGlobalModifierState(QEvent *e)
1866 {
1867     if (e->spontaneous()) {
1868         // Capture the current mouse and keyboard states. Doing so here is
1869         // required in order to support Qt Test synthesized events. Real mouse
1870         // and keyboard state updates from the platform plugin are managed by
1871         // QGuiApplicationPrivate::process(Mouse|Wheel|Key|Touch|Tablet)Event();
1872         // ### FIXME: Qt Test should not call qapp->notify(), but rather route
1873         // the events through the proper QPA interface. This is required to
1874         // properly generate all other events such as enter/leave etc.
1875         switch (e->type()) {
1876         case QEvent::MouseButtonPress: {
1877             QMouseEvent *me = static_cast<QMouseEvent *>(e);
1878             QGuiApplicationPrivate::modifier_buttons = me->modifiers();
1879             QGuiApplicationPrivate::mouse_buttons |= me->button();
1880             break;
1881         }
1882         case QEvent::MouseButtonDblClick: {
1883             QMouseEvent *me = static_cast<QMouseEvent *>(e);
1884             QGuiApplicationPrivate::modifier_buttons = me->modifiers();
1885             QGuiApplicationPrivate::mouse_buttons |= me->button();
1886             break;
1887         }
1888         case QEvent::MouseButtonRelease: {
1889             QMouseEvent *me = static_cast<QMouseEvent *>(e);
1890             QGuiApplicationPrivate::modifier_buttons = me->modifiers();
1891             QGuiApplicationPrivate::mouse_buttons &= ~me->button();
1892             break;
1893         }
1894         case QEvent::KeyPress:
1895         case QEvent::KeyRelease:
1896         case QEvent::MouseMove:
1897 #if QT_CONFIG(wheelevent)
1898         case QEvent::Wheel:
1899 #endif
1900         case QEvent::TouchBegin:
1901         case QEvent::TouchUpdate:
1902         case QEvent::TouchEnd:
1903 #if QT_CONFIG(tabletevent)
1904         case QEvent::TabletMove:
1905         case QEvent::TabletPress:
1906         case QEvent::TabletRelease:
1907 #endif
1908         {
1909             QInputEvent *ie = static_cast<QInputEvent *>(e);
1910             QGuiApplicationPrivate::modifier_buttons = ie->modifiers();
1911             break;
1912         }
1913         default:
1914             break;
1915         }
1916     }
1917 }
1918 
1919 /*! \reimp
1920 */
1921 bool QGuiApplication::notify(QObject *object, QEvent *event)
1922 {
1923     if (object->isWindowType()) {
1924         if (QGuiApplicationPrivate::sendQWindowEventToQPlatformWindow(static_cast<QWindow *>(object), event))
1925             return true; // Platform plugin ate the event
1926     }
1927 
1928     QGuiApplicationPrivate::captureGlobalModifierState(event);
1929 
1930     return QCoreApplication::notify(object, event);
1931 }
1932 
1933 /*! \reimp
1934 */
1935 bool QGuiApplication::event(QEvent *e)
1936 {
1937     if (e->type() == QEvent::LanguageChange) {
1938         setLayoutDirection(qt_detectRTLLanguage()?Qt::RightToLeft:Qt::LeftToRight);
1939         for (auto *topLevelWindow : QGuiApplication::topLevelWindows()) {
1940             if (topLevelWindow->flags() != Qt::Desktop)
1941                 postEvent(topLevelWindow, new QEvent(QEvent::LanguageChange));
1942         }
1943     } else if (e->type() == QEvent::ApplicationFontChange ||
1944                e->type() == QEvent::ApplicationPaletteChange) {
1945         for (auto *topLevelWindow : QGuiApplication::topLevelWindows()) {
1946             if (topLevelWindow->flags() != Qt::Desktop)
1947                 postEvent(topLevelWindow, new QEvent(e->type()));
1948         }
1949     } else if (e->type() == QEvent::Quit) {
1950         // Close open windows. This is done in order to deliver de-expose
1951         // events while the event loop is still running.
1952         for (QWindow *topLevelWindow : QGuiApplication::topLevelWindows()) {
1953             // Already closed windows will not have a platform window, skip those
1954             if (!topLevelWindow->handle())
1955                 continue;
1956             if (!topLevelWindow->close()) {
1957                 e->ignore();
1958                 return true;
1959             }
1960         }
1961     }
1962 
1963     return QCoreApplication::event(e);
1964 }
1965 
1966 /*!
1967     \internal
1968 */
1969 bool QGuiApplication::compressEvent(QEvent *event, QObject *receiver, QPostEventList *postedEvents)
1970 {
1971     return QCoreApplication::compressEvent(event, receiver, postedEvents);
1972 }
1973 
1974 bool QGuiApplicationPrivate::sendQWindowEventToQPlatformWindow(QWindow *window, QEvent *event)
1975 {
1976     if (!window)
1977         return false;
1978     QPlatformWindow *platformWindow = window->handle();
1979     if (!platformWindow)
1980         return false;
1981     // spontaneous events come from the platform integration already, we don't need to send the events back
1982     if (event->spontaneous())
1983         return false;
1984     // let the platform window do any handling it needs to as well
1985     return platformWindow->windowEvent(event);
1986 }
1987 
1988 bool QGuiApplicationPrivate::processNativeEvent(QWindow *window, const QByteArray &eventType, void *message, qintptr *result)
1989 {
1990     return window->nativeEvent(eventType, message, result);
1991 }
1992 
1993 void QGuiApplicationPrivate::processWindowSystemEvent(QWindowSystemInterfacePrivate::WindowSystemEvent *e)
1994 {
1995     Q_TRACE_SCOPE(QGuiApplicationPrivate_processWindowSystemEvent, e->type);
1996 
1997     switch(e->type) {
1998     case QWindowSystemInterfacePrivate::Mouse:
1999         QGuiApplicationPrivate::processMouseEvent(static_cast<QWindowSystemInterfacePrivate::MouseEvent *>(e));
2000         break;
2001     case QWindowSystemInterfacePrivate::Wheel:
2002         QGuiApplicationPrivate::processWheelEvent(static_cast<QWindowSystemInterfacePrivate::WheelEvent *>(e));
2003         break;
2004     case QWindowSystemInterfacePrivate::Key:
2005         QGuiApplicationPrivate::processKeyEvent(static_cast<QWindowSystemInterfacePrivate::KeyEvent *>(e));
2006         break;
2007     case QWindowSystemInterfacePrivate::Touch:
2008         QGuiApplicationPrivate::processTouchEvent(static_cast<QWindowSystemInterfacePrivate::TouchEvent *>(e));
2009         break;
2010     case QWindowSystemInterfacePrivate::GeometryChange:
2011         QGuiApplicationPrivate::processGeometryChangeEvent(static_cast<QWindowSystemInterfacePrivate::GeometryChangeEvent*>(e));
2012         break;
2013     case QWindowSystemInterfacePrivate::Enter:
2014         QGuiApplicationPrivate::processEnterEvent(static_cast<QWindowSystemInterfacePrivate::EnterEvent *>(e));
2015         break;
2016     case QWindowSystemInterfacePrivate::Leave:
2017         QGuiApplicationPrivate::processLeaveEvent(static_cast<QWindowSystemInterfacePrivate::LeaveEvent *>(e));
2018         break;
2019     case QWindowSystemInterfacePrivate::ActivatedWindow:
2020         QGuiApplicationPrivate::processActivatedEvent(static_cast<QWindowSystemInterfacePrivate::ActivatedWindowEvent *>(e));
2021         break;
2022     case QWindowSystemInterfacePrivate::WindowStateChanged:
2023         QGuiApplicationPrivate::processWindowStateChangedEvent(static_cast<QWindowSystemInterfacePrivate::WindowStateChangedEvent *>(e));
2024         break;
2025     case QWindowSystemInterfacePrivate::WindowScreenChanged:
2026         QGuiApplicationPrivate::processWindowScreenChangedEvent(static_cast<QWindowSystemInterfacePrivate::WindowScreenChangedEvent *>(e));
2027         break;
2028     case QWindowSystemInterfacePrivate::SafeAreaMarginsChanged:
2029         QGuiApplicationPrivate::processSafeAreaMarginsChangedEvent(static_cast<QWindowSystemInterfacePrivate::SafeAreaMarginsChangedEvent *>(e));
2030         break;
2031     case QWindowSystemInterfacePrivate::ApplicationStateChanged: {
2032         QWindowSystemInterfacePrivate::ApplicationStateChangedEvent * changeEvent = static_cast<QWindowSystemInterfacePrivate::ApplicationStateChangedEvent *>(e);
2033         QGuiApplicationPrivate::setApplicationState(changeEvent->newState, changeEvent->forcePropagate); }
2034         break;
2035     case QWindowSystemInterfacePrivate::ApplicationTermination:
2036         QGuiApplicationPrivate::processApplicationTermination(e);
2037         break;
2038     case QWindowSystemInterfacePrivate::FlushEvents: {
2039         QWindowSystemInterfacePrivate::FlushEventsEvent *flushEventsEvent = static_cast<QWindowSystemInterfacePrivate::FlushEventsEvent *>(e);
2040         QWindowSystemInterface::deferredFlushWindowSystemEvents(flushEventsEvent->flags); }
2041         break;
2042     case QWindowSystemInterfacePrivate::Close:
2043         QGuiApplicationPrivate::processCloseEvent(
2044                 static_cast<QWindowSystemInterfacePrivate::CloseEvent *>(e));
2045         break;
2046     case QWindowSystemInterfacePrivate::ScreenOrientation:
2047         QGuiApplicationPrivate::processScreenOrientationChange(
2048                 static_cast<QWindowSystemInterfacePrivate::ScreenOrientationEvent *>(e));
2049         break;
2050     case QWindowSystemInterfacePrivate::ScreenGeometry:
2051         QGuiApplicationPrivate::processScreenGeometryChange(
2052                 static_cast<QWindowSystemInterfacePrivate::ScreenGeometryEvent *>(e));
2053         break;
2054     case QWindowSystemInterfacePrivate::ScreenLogicalDotsPerInch:
2055         QGuiApplicationPrivate::processScreenLogicalDotsPerInchChange(
2056                 static_cast<QWindowSystemInterfacePrivate::ScreenLogicalDotsPerInchEvent *>(e));
2057         break;
2058     case QWindowSystemInterfacePrivate::ScreenRefreshRate:
2059         QGuiApplicationPrivate::processScreenRefreshRateChange(
2060                 static_cast<QWindowSystemInterfacePrivate::ScreenRefreshRateEvent *>(e));
2061         break;
2062     case QWindowSystemInterfacePrivate::ThemeChange:
2063         QGuiApplicationPrivate::processThemeChanged(
2064                     static_cast<QWindowSystemInterfacePrivate::ThemeChangeEvent *>(e));
2065         break;
2066     case QWindowSystemInterfacePrivate::Expose:
2067         QGuiApplicationPrivate::processExposeEvent(static_cast<QWindowSystemInterfacePrivate::ExposeEvent *>(e));
2068         break;
2069     case QWindowSystemInterfacePrivate::Paint:
2070         QGuiApplicationPrivate::processPaintEvent(static_cast<QWindowSystemInterfacePrivate::PaintEvent *>(e));
2071         break;
2072     case QWindowSystemInterfacePrivate::Tablet:
2073         QGuiApplicationPrivate::processTabletEvent(
2074                     static_cast<QWindowSystemInterfacePrivate::TabletEvent *>(e));
2075         break;
2076     case QWindowSystemInterfacePrivate::TabletEnterProximity:
2077         QGuiApplicationPrivate::processTabletEnterProximityEvent(
2078                     static_cast<QWindowSystemInterfacePrivate::TabletEnterProximityEvent *>(e));
2079         break;
2080     case QWindowSystemInterfacePrivate::TabletLeaveProximity:
2081         QGuiApplicationPrivate::processTabletLeaveProximityEvent(
2082                     static_cast<QWindowSystemInterfacePrivate::TabletLeaveProximityEvent *>(e));
2083         break;
2084 #ifndef QT_NO_GESTURES
2085     case QWindowSystemInterfacePrivate::Gesture:
2086         QGuiApplicationPrivate::processGestureEvent(
2087                     static_cast<QWindowSystemInterfacePrivate::GestureEvent *>(e));
2088         break;
2089 #endif
2090     case QWindowSystemInterfacePrivate::PlatformPanel:
2091         QGuiApplicationPrivate::processPlatformPanelEvent(
2092                     static_cast<QWindowSystemInterfacePrivate::PlatformPanelEvent *>(e));
2093         break;
2094     case QWindowSystemInterfacePrivate::FileOpen:
2095         QGuiApplicationPrivate::processFileOpenEvent(
2096                     static_cast<QWindowSystemInterfacePrivate::FileOpenEvent *>(e));
2097         break;
2098 #ifndef QT_NO_CONTEXTMENU
2099         case QWindowSystemInterfacePrivate::ContextMenu:
2100         QGuiApplicationPrivate::processContextMenuEvent(
2101                     static_cast<QWindowSystemInterfacePrivate::ContextMenuEvent *>(e));
2102         break;
2103 #endif
2104     case QWindowSystemInterfacePrivate::EnterWhatsThisMode:
2105         QGuiApplication::postEvent(QGuiApplication::instance(), new QEvent(QEvent::EnterWhatsThisMode));
2106         break;
2107     default:
2108         qWarning() << "Unknown user input event type:" << e->type;
2109         break;
2110     }
2111 }
2112 
2113 /*! \internal
2114 
2115     History is silent on why Qt splits mouse events that change position and
2116     button state at the same time. We believe that this was done to emulate mouse
2117     behavior on touch screens. If mouse tracking is enabled, we will get move
2118     events before the button is pressed. A touch panel does not generally give
2119     move events when not pressed, so without event splitting code path we would
2120     only see a press in a new location without any intervening moves. This could
2121     confuse code that is written for a real mouse. The same is true for mouse
2122     release events that change position, see tst_QWidget::touchEventSynthesizedMouseEvent()
2123     and tst_QWindow::generatedMouseMove() auto tests.
2124 */
2125 void QGuiApplicationPrivate::processMouseEvent(QWindowSystemInterfacePrivate::MouseEvent *e)
2126 {
2127     QEvent::Type type = QEvent::None;
2128     Qt::MouseButton button = Qt::NoButton;
2129     QWindow *window = e->window.data();
2130     const QPointingDevice *device = static_cast<const QPointingDevice *>(e->device);
2131     Q_ASSERT(device);
2132     QPointingDevicePrivate *devPriv = QPointingDevicePrivate::get(const_cast<QPointingDevice*>(device));
2133     bool positionChanged = QGuiApplicationPrivate::lastCursorPosition != e->globalPos;
2134     bool mouseMove = false;
2135     bool mousePress = false;
2136     const QPointF lastGlobalPosition = QGuiApplicationPrivate::lastCursorPosition;
2137     QPointF globalPoint = e->globalPos;
2138 
2139     if (qIsNaN(e->globalPos.x()) || qIsNaN(e->globalPos.y())) {
2140         qWarning("QGuiApplicationPrivate::processMouseEvent: Got NaN in mouse position");
2141         return;
2142     }
2143 
2144     type = e->buttonType;
2145     button = e->button;
2146 
2147     if (type == QEvent::NonClientAreaMouseMove || type == QEvent::MouseMove)
2148         mouseMove = true;
2149     else if (type == QEvent::NonClientAreaMouseButtonPress || type == QEvent::MouseButtonPress)
2150         mousePress = true;
2151 
2152     if (!mouseMove && positionChanged) {
2153         QWindowSystemInterfacePrivate::MouseEvent moveEvent(window, e->timestamp,
2154             e->localPos, e->globalPos, e->buttons ^ button, e->modifiers, Qt::NoButton,
2155             e->nonClientArea ? QEvent::NonClientAreaMouseMove : QEvent::MouseMove,
2156             e->source, e->nonClientArea);
2157         if (e->synthetic())
2158             moveEvent.flags |= QWindowSystemInterfacePrivate::WindowSystemEvent::Synthetic;
2159         processMouseEvent(&moveEvent); // mouse move excluding state change
2160         processMouseEvent(e); // the original mouse event
2161         return;
2162     }
2163     if (type == QEvent::MouseMove && !positionChanged) {
2164         // On Windows, and possibly other platforms, a touchpad can send a mouse move
2165         // that does not change position, between a press and a release. This may
2166         // confuse applications, so we always filter out these mouse events for
2167         // consistent behavior among platforms.
2168         return;
2169     }
2170 
2171     modifier_buttons = e->modifiers;
2172     QPointF localPoint = e->localPos;
2173     bool doubleClick = false;
2174     auto persistentEPD = devPriv->pointById(0);
2175     const auto &persistentPoint = persistentEPD->eventPoint;
2176 
2177     if (mouseMove) {
2178         QGuiApplicationPrivate::lastCursorPosition = globalPoint;
2179         const auto doubleClickDistance = (e->device && e->device->type() == QInputDevice::DeviceType::Mouse ?
2180                     mouseDoubleClickDistance : touchDoubleTapDistance);
2181         const auto pressPos = persistentPoint.globalPressPosition();
2182         if (qAbs(globalPoint.x() - pressPos.x()) > doubleClickDistance ||
2183             qAbs(globalPoint.y() - pressPos.y()) > doubleClickDistance)
2184             mousePressButton = Qt::NoButton;
2185     } else {
2186         mouse_buttons = e->buttons;
2187         if (mousePress) {
2188             ulong doubleClickInterval = static_cast<ulong>(QGuiApplication::styleHints()->mouseDoubleClickInterval());
2189             doubleClick = e->timestamp - persistentPoint.pressTimestamp() < doubleClickInterval && button == mousePressButton;
2190             mousePressButton = button;
2191         }
2192     }
2193 
2194     if (e->nullWindow()) {
2195         window = QGuiApplication::topLevelAt(globalPoint.toPoint());
2196         if (window) {
2197             // Moves and the release following a press must go to the same
2198             // window, even if the cursor has moved on over another window.
2199             if (e->buttons != Qt::NoButton) {
2200                 if (!currentMousePressWindow)
2201                     currentMousePressWindow = window;
2202                 else
2203                     window = currentMousePressWindow;
2204             } else if (currentMousePressWindow) {
2205                 window = currentMousePressWindow;
2206                 currentMousePressWindow = nullptr;
2207             }
2208             localPoint = window->mapFromGlobal(globalPoint);
2209         }
2210     }
2211 
2212     if (!window)
2213         return;
2214 
2215 #ifndef QT_NO_CURSOR
2216     if (!e->synthetic()) {
2217         if (const QScreen *screen = window->screen())
2218             if (QPlatformCursor *cursor = screen->handle()->cursor()) {
2219                 const QPointF nativeLocalPoint = QHighDpi::toNativePixels(localPoint, screen);
2220                 const QPointF nativeGlobalPoint = QHighDpi::toNativePixels(globalPoint, screen);
2221                 QMouseEvent ev(type, nativeLocalPoint, nativeLocalPoint, nativeGlobalPoint,
2222                                button, e->buttons, e->modifiers, e->source, device);
2223                 // avoid incorrect velocity calculation: ev is in the native coordinate system,
2224                 // but we need to consistently use the logical coordinate system for velocity
2225                 // whenever QEventPoint::setTimestamp() is called
2226                 ev.QInputEvent::setTimestamp(e->timestamp);
2227                 cursor->pointerEvent(ev);
2228             }
2229     }
2230 #endif
2231 
2232     QMouseEvent ev(type, localPoint, localPoint, globalPoint, button, e->buttons, e->modifiers, e->source, device);
2233     // restore globalLastPosition to avoid invalidating the velocity calculations,
2234     // because the QPlatformCursor mouse event above was in native coordinates
2235     QMutableEventPoint::from(persistentEPD->eventPoint).setGlobalLastPosition(lastGlobalPosition);
2236     // ev now contains a detached copy of the QEventPoint from QPointingDevicePrivate::activePoints
2237     ev.setTimestamp(e->timestamp);
2238     if (window->d_func()->blockedByModalWindow && !qApp->d_func()->popupActive()) {
2239         // a modal window is blocking this window, don't allow mouse events through
2240         return;
2241     }
2242 
2243     if (doubleClick && (ev.type() == QEvent::MouseButtonPress)) {
2244         // QtBUG-25831, used to suppress delivery in qwidgetwindow.cpp
2245         QMutableSinglePointEvent::from(ev).setDoubleClick();
2246     }
2247 
2248     QGuiApplication::sendSpontaneousEvent(window, &ev);
2249     e->eventAccepted = ev.isAccepted();
2250     if (!e->synthetic() && !ev.isAccepted()
2251         && !e->nonClientArea
2252         && qApp->testAttribute(Qt::AA_SynthesizeTouchForUnhandledMouseEvents)) {
2253         QList<QWindowSystemInterface::TouchPoint> points;
2254         QWindowSystemInterface::TouchPoint point;
2255         point.id = 1;
2256         point.area = QHighDpi::toNativePixels(QRectF(globalPoint.x() - 2, globalPoint.y() - 2, 4, 4), window);
2257 
2258         // only translate left button related events to
2259         // avoid strange touch event sequences when several
2260         // buttons are pressed
2261         if (type == QEvent::MouseButtonPress && button == Qt::LeftButton) {
2262             point.state = QEventPoint::State::Pressed;
2263         } else if (type == QEvent::MouseButtonRelease && button == Qt::LeftButton) {
2264             point.state = QEventPoint::State::Released;
2265         } else if (type == QEvent::MouseMove && (e->buttons & Qt::LeftButton)) {
2266             point.state = QEventPoint::State::Updated;
2267         } else {
2268             return;
2269         }
2270 
2271         points << point;
2272 
2273         QEvent::Type type;
2274         const QList<QEventPoint> &touchPoints =
2275                 QWindowSystemInterfacePrivate::fromNativeTouchPoints(points, window, &type);
2276 
2277         QWindowSystemInterfacePrivate::TouchEvent fake(window, e->timestamp, type, device, touchPoints, e->modifiers);
2278         fake.flags |= QWindowSystemInterfacePrivate::WindowSystemEvent::Synthetic;
2279         processTouchEvent(&fake);
2280     }
2281     if (doubleClick) {
2282         mousePressButton = Qt::NoButton;
2283         if (!e->window.isNull() || e->nullWindow()) { // QTBUG-36364, check if window closed in response to press
2284             const QEvent::Type doubleClickType = e->nonClientArea ? QEvent::NonClientAreaMouseButtonDblClick : QEvent::MouseButtonDblClick;
2285             QMouseEvent dblClickEvent(doubleClickType, localPoint, localPoint, globalPoint,
2286                                       button, e->buttons, e->modifiers, e->source, device);
2287             dblClickEvent.setTimestamp(e->timestamp);
2288             QGuiApplication::sendSpontaneousEvent(window, &dblClickEvent);
2289         }
2290     }
2291     if (type == QEvent::MouseButtonRelease && e->buttons == Qt::NoButton) {
2292         ev.setExclusiveGrabber(persistentPoint, nullptr);
2293         ev.clearPassiveGrabbers(persistentPoint);
2294     }
2295 }
2296 
2297 void QGuiApplicationPrivate::processWheelEvent(QWindowSystemInterfacePrivate::WheelEvent *e)
2298 {
2299 #if QT_CONFIG(wheelevent)
2300     QWindow *window = e->window.data();
2301     QPointF globalPoint = e->globalPos;
2302     QPointF localPoint = e->localPos;
2303 
2304     if (e->nullWindow()) {
2305         window = QGuiApplication::topLevelAt(globalPoint.toPoint());
2306         if (window)
2307             localPoint = window->mapFromGlobal(globalPoint);
2308     }
2309 
2310     if (!window)
2311         return;
2312 
2313     QGuiApplicationPrivate::lastCursorPosition = globalPoint;
2314     modifier_buttons = e->modifiers;
2315 
2316     if (window->d_func()->blockedByModalWindow) {
2317         // a modal window is blocking this window, don't allow wheel events through
2318         return;
2319     }
2320 
2321     const QPointingDevice *device = static_cast<const QPointingDevice *>(e->device);
2322     QWheelEvent ev(localPoint, globalPoint, e->pixelDelta, e->angleDelta,
2323                    mouse_buttons, e->modifiers, e->phase, e->inverted, e->source, device);
2324     ev.setTimestamp(e->timestamp);
2325     QGuiApplication::sendSpontaneousEvent(window, &ev);
2326 #else
2327      Q_UNUSED(e);
2328 #endif // QT_CONFIG(wheelevent)
2329 }
2330 
2331 void QGuiApplicationPrivate::processKeyEvent(QWindowSystemInterfacePrivate::KeyEvent *e)
2332 {
2333     QWindow *window = e->window.data();
2334     modifier_buttons = e->modifiers;
2335     if (e->nullWindow()
2336 #ifdef Q_OS_ANDROID
2337            || e->key == Qt::Key_Back || e->key == Qt::Key_Menu
2338 #endif
2339             ) {
2340         window = QGuiApplication::focusWindow();
2341     }
2342 
2343 #if defined(Q_OS_ANDROID)
2344     static bool backKeyPressAccepted = false;
2345     static bool menuKeyPressAccepted = false;
2346 #endif
2347 
2348 #if !defined(Q_OS_MACOS)
2349     // FIXME: Include OS X in this code path by passing the key event through
2350     // QPlatformInputContext::filterEvent().
2351     if (e->keyType == QEvent::KeyPress && window) {
2352         if (QWindowSystemInterface::handleShortcutEvent(window, e->timestamp, e->key, e->modifiers,
2353             e->nativeScanCode, e->nativeVirtualKey, e->nativeModifiers, e->unicode, e->repeat, e->repeatCount)) {
2354 #if defined(Q_OS_ANDROID)
2355             backKeyPressAccepted = e->key == Qt::Key_Back;
2356             menuKeyPressAccepted = e->key == Qt::Key_Menu;
2357 #endif
2358             return;
2359         }
2360     }
2361 #endif
2362 
2363     QKeyEvent ev(e->keyType, e->key, e->modifiers,
2364                  e->nativeScanCode, e->nativeVirtualKey, e->nativeModifiers,
2365                  e->unicode, e->repeat, e->repeatCount);
2366     ev.setTimestamp(e->timestamp);
2367 
2368     // only deliver key events when we have a window, and no modal window is blocking this window
2369 
2370     if (window && !window->d_func()->blockedByModalWindow)
2371         QGuiApplication::sendSpontaneousEvent(window, &ev);
2372 #ifdef Q_OS_ANDROID
2373     else
2374         ev.setAccepted(false);
2375 
2376     if (e->keyType == QEvent::KeyPress) {
2377         backKeyPressAccepted = e->key == Qt::Key_Back && ev.isAccepted();
2378         menuKeyPressAccepted = e->key == Qt::Key_Menu && ev.isAccepted();
2379     } else if (e->keyType == QEvent::KeyRelease) {
2380         if (e->key == Qt::Key_Back && !backKeyPressAccepted && !ev.isAccepted()) {
2381             if (window)
2382                 QWindowSystemInterface::handleCloseEvent(window);
2383         } else if (e->key == Qt::Key_Menu && !menuKeyPressAccepted && !ev.isAccepted()) {
2384             platform_theme->showPlatformMenuBar();
2385         }
2386     }
2387 #endif
2388     e->eventAccepted = ev.isAccepted();
2389 }
2390 
2391 void QGuiApplicationPrivate::processEnterEvent(QWindowSystemInterfacePrivate::EnterEvent *e)
2392 {
2393     if (!e->enter)
2394         return;
2395     if (e->enter.data()->d_func()->blockedByModalWindow) {
2396         // a modal window is blocking this window, don't allow enter events through
2397         return;
2398     }
2399 
2400     currentMouseWindow = e->enter;
2401 
2402     // TODO later: EnterEvent must report _which_ mouse entered the window; for now we assume primaryPointingDevice()
2403     QEnterEvent event(e->localPos, e->localPos, e->globalPos);
2404 
2405     // Since we don't always track mouse moves that occur outside a window, any residual velocity
2406     // stored in the persistent QEventPoint may be inaccurate (especially in fast-moving autotests).
2407     // Reset the Kalman filter so that the velocity of the first mouse event after entering the window
2408     // will be based on a zero residual velocity (but the result can still be non-zero if the mouse
2409     // moves to a different position from where this enter event occurred; tests often do that).
2410     const QPointingDevicePrivate *devPriv = QPointingDevicePrivate::get(event.pointingDevice());
2411     auto epd = devPriv->queryPointById(event.points().first().id());
2412     Q_ASSERT(epd);
2413     QMutableEventPoint::from(epd->eventPoint).setVelocity({});
2414 
2415     QCoreApplication::sendSpontaneousEvent(e->enter.data(), &event);
2416 }
2417 
2418 void QGuiApplicationPrivate::processLeaveEvent(QWindowSystemInterfacePrivate::LeaveEvent *e)
2419 {
2420     if (!e->leave)
2421         return;
2422     if (e->leave.data()->d_func()->blockedByModalWindow) {
2423         // a modal window is blocking this window, don't allow leave events through
2424         return;
2425     }
2426 
2427     currentMouseWindow = nullptr;
2428 
2429     QEvent event(QEvent::Leave);
2430     QCoreApplication::sendSpontaneousEvent(e->leave.data(), &event);
2431 }
2432 
2433 void QGuiApplicationPrivate::processActivatedEvent(QWindowSystemInterfacePrivate::ActivatedWindowEvent *e)
2434 {
2435     QWindow *previous = QGuiApplicationPrivate::focus_window;
2436     QWindow *newFocus = e->activated.data();
2437 
2438     if (previous == newFocus)
2439         return;
2440 
2441     if (newFocus)
2442         if (QPlatformWindow *platformWindow = newFocus->handle())
2443             if (platformWindow->isAlertState())
2444                 platformWindow->setAlertState(false);
2445 
2446     QObject *previousFocusObject = previous ? previous->focusObject() : nullptr;
2447 
2448     if (previous) {
2449         QFocusEvent focusAboutToChange(QEvent::FocusAboutToChange);
2450         QCoreApplication::sendSpontaneousEvent(previous, &focusAboutToChange);
2451     }
2452 
2453     QGuiApplicationPrivate::focus_window = newFocus;
2454     if (!qApp)
2455         return;
2456 
2457     if (previous) {
2458         Qt::FocusReason r = e->reason;
2459         if ((r == Qt::OtherFocusReason || r == Qt::ActiveWindowFocusReason) &&
2460                 newFocus && (newFocus->flags() & Qt::Popup) == Qt::Popup)
2461             r = Qt::PopupFocusReason;
2462         QFocusEvent focusOut(QEvent::FocusOut, r);
2463         QCoreApplication::sendSpontaneousEvent(previous, &focusOut);
2464         QObject::disconnect(previous, SIGNAL(focusObjectChanged(QObject*)),
2465                             qApp, SLOT(_q_updateFocusObject(QObject*)));
2466     } else if (!platformIntegration()->hasCapability(QPlatformIntegration::ApplicationState)) {
2467         setApplicationState(Qt::ApplicationActive);
2468     }
2469 
2470     if (QGuiApplicationPrivate::focus_window) {
2471         Qt::FocusReason r = e->reason;
2472         if ((r == Qt::OtherFocusReason || r == Qt::ActiveWindowFocusReason) &&
2473                 previous && (previous->flags() & Qt::Popup) == Qt::Popup)
2474             r = Qt::PopupFocusReason;
2475         QFocusEvent focusIn(QEvent::FocusIn, r);
2476         QCoreApplication::sendSpontaneousEvent(QGuiApplicationPrivate::focus_window, &focusIn);
2477         QObject::connect(QGuiApplicationPrivate::focus_window, SIGNAL(focusObjectChanged(QObject*)),
2478                          qApp, SLOT(_q_updateFocusObject(QObject*)));
2479     } else if (!platformIntegration()->hasCapability(QPlatformIntegration::ApplicationState)) {
2480         setApplicationState(Qt::ApplicationInactive);
2481     }
2482 
2483     if (self) {
2484         self->notifyActiveWindowChange(previous);
2485 
2486         if (previousFocusObject != qApp->focusObject())
2487             self->_q_updateFocusObject(qApp->focusObject());
2488     }
2489 
2490     emit qApp->focusWindowChanged(newFocus);
2491     if (previous)
2492         emit previous->activeChanged();
2493     if (newFocus)
2494         emit newFocus->activeChanged();
2495 }
2496 
2497 void QGuiApplicationPrivate::processWindowStateChangedEvent(QWindowSystemInterfacePrivate::WindowStateChangedEvent *wse)
2498 {
2499     if (QWindow *window  = wse->window.data()) {
2500         QWindowStateChangeEvent e(wse->oldState);
2501         window->d_func()->windowState = wse->newState;
2502         QGuiApplication::sendSpontaneousEvent(window, &e);
2503     }
2504 }
2505 
2506 void QGuiApplicationPrivate::processWindowScreenChangedEvent(QWindowSystemInterfacePrivate::WindowScreenChangedEvent *wse)
2507 {
2508     if (QWindow *window  = wse->window.data()) {
2509         if (window->screen() == wse->screen.data())
2510             return;
2511         if (QWindow *topLevelWindow = window->d_func()->topLevelWindow(QWindow::ExcludeTransients)) {
2512             if (QScreen *screen = wse->screen.data())
2513                 topLevelWindow->d_func()->setTopLevelScreen(screen, false /* recreate */);
2514             else // Fall back to default behavior, and try to find some appropriate screen
2515                 topLevelWindow->setScreen(nullptr);
2516         }
2517 
2518         // We may have changed scaling; trigger resize event if needed,
2519         // except on Windows, where we send resize events during WM_DPICHANGED
2520         // event handling. FIXME: unify DPI change handling across all platforms.
2521 #ifndef Q_OS_WIN
2522         if (window->handle()) {
2523             QWindowSystemInterfacePrivate::GeometryChangeEvent gce(window, QHighDpi::fromNativePixels(window->handle()->geometry(), window));
2524             processGeometryChangeEvent(&gce);
2525         }
2526 #endif
2527     }
2528 }
2529 
2530 void QGuiApplicationPrivate::processSafeAreaMarginsChangedEvent(QWindowSystemInterfacePrivate::SafeAreaMarginsChangedEvent *wse)
2531 {
2532     if (wse->window.isNull())
2533         return;
2534 
2535     // Handle by forwarding directly to QWindowPrivate, instead of sending spontaneous
2536     // QEvent like most other functions, as there's no QEvent type for the safe area
2537     // change, and we don't want to add one until we know that this is a good API.
2538     qt_window_private(wse->window)->processSafeAreaMarginsChanged();
2539 }
2540 
2541 void QGuiApplicationPrivate::processThemeChanged(QWindowSystemInterfacePrivate::ThemeChangeEvent *tce)
2542 {
2543     if (self)
2544         self->notifyThemeChanged();
2545     if (QWindow *window  = tce->window.data()) {
2546         QEvent e(QEvent::ThemeChange);
2547         QGuiApplication::sendSpontaneousEvent(window, &e);
2548     }
2549 }
2550 
2551 void QGuiApplicationPrivate::processGeometryChangeEvent(QWindowSystemInterfacePrivate::GeometryChangeEvent *e)
2552 {
2553     if (e->window.isNull())
2554        return;
2555 
2556     QWindow *window = e->window.data();
2557     if (!window)
2558         return;
2559 
2560     const QRect lastReportedGeometry = window->d_func()->geometry;
2561     const QRect requestedGeometry = e->requestedGeometry;
2562     const QRect actualGeometry = e->newGeometry;
2563 
2564     // We send size and move events only if the geometry has changed from
2565     // what was last reported, or if the user tried to set a new geometry,
2566     // but the window manager responded by keeping the old geometry. In the
2567     // latter case we send move/resize events with the same geometry as the
2568     // last reported geometry, to indicate that the window wasn't moved or
2569     // resized. Note that this logic does not apply to the property changes
2570     // of the window, as we don't treat them as part of this request/response
2571     // protocol of QWindow/QPA.
2572     const bool isResize = actualGeometry.size() != lastReportedGeometry.size()
2573         || requestedGeometry.size() != actualGeometry.size();
2574     const bool isMove = actualGeometry.topLeft() != lastReportedGeometry.topLeft()
2575         || requestedGeometry.topLeft() != actualGeometry.topLeft();
2576 
2577     window->d_func()->geometry = actualGeometry;
2578 
2579     if (isResize || window->d_func()->resizeEventPending) {
2580         QResizeEvent e(actualGeometry.size(), lastReportedGeometry.size());
2581         QGuiApplication::sendSpontaneousEvent(window, &e);
2582 
2583         window->d_func()->resizeEventPending = false;
2584 
2585         if (actualGeometry.width() != lastReportedGeometry.width())
2586             emit window->widthChanged(actualGeometry.width());
2587         if (actualGeometry.height() != lastReportedGeometry.height())
2588             emit window->heightChanged(actualGeometry.height());
2589     }
2590 
2591     if (isMove) {
2592         //### frame geometry
2593         QMoveEvent e(actualGeometry.topLeft(), lastReportedGeometry.topLeft());
2594         QGuiApplication::sendSpontaneousEvent(window, &e);
2595 
2596         if (actualGeometry.x() != lastReportedGeometry.x())
2597             emit window->xChanged(actualGeometry.x());
2598         if (actualGeometry.y() != lastReportedGeometry.y())
2599             emit window->yChanged(actualGeometry.y());
2600     }
2601 }
2602 
2603 void QGuiApplicationPrivate::processCloseEvent(QWindowSystemInterfacePrivate::CloseEvent *e)
2604 {
2605     if (e->window.isNull())
2606         return;
2607     if (e->window.data()->d_func()->blockedByModalWindow) {
2608         // a modal window is blocking this window, don't allow close events through
2609         return;
2610     }
2611 
2612     QCloseEvent event;
2613     QGuiApplication::sendSpontaneousEvent(e->window.data(), &event);
2614 
2615     e->eventAccepted = event.isAccepted();
2616 }
2617 
2618 void QGuiApplicationPrivate::processFileOpenEvent(QWindowSystemInterfacePrivate::FileOpenEvent *e)
2619 {
2620     if (e->url.isEmpty())
2621         return;
2622 
2623     QFileOpenEvent event(e->url);
2624     QGuiApplication::sendSpontaneousEvent(qApp, &event);
2625 }
2626 
2627 QGuiApplicationPrivate::TabletPointData &QGuiApplicationPrivate::tabletDevicePoint(qint64 deviceId)
2628 {
2629     for (int i = 0; i < tabletDevicePoints.size(); ++i) {
2630         TabletPointData &pointData = tabletDevicePoints[i];
2631         if (pointData.deviceId == deviceId)
2632             return pointData;
2633     }
2634 
2635     tabletDevicePoints.append(TabletPointData(deviceId));
2636     return tabletDevicePoints.last();
2637 }
2638 
2639 void QGuiApplicationPrivate::processTabletEvent(QWindowSystemInterfacePrivate::TabletEvent *e)
2640 {
2641 #if QT_CONFIG(tabletevent)
2642     const auto device = static_cast<const QPointingDevice *>(e->device);
2643     TabletPointData &pointData = tabletDevicePoint(device->uniqueId().numericId());
2644 
2645     QEvent::Type type = QEvent::TabletMove;
2646     if (e->buttons != pointData.state)
2647         type = (e->buttons > pointData.state) ? QEvent::TabletPress : QEvent::TabletRelease;
2648 
2649     QWindow *window = e->window.data();
2650     modifier_buttons = e->modifiers;
2651 
2652     bool localValid = true;
2653     // If window is null, pick one based on the global position and make sure all
2654     // subsequent events up to the release are delivered to that same window.
2655     // If window is given, just send to that.
2656     if (type == QEvent::TabletPress) {
2657         if (e->nullWindow()) {
2658             window = QGuiApplication::topLevelAt(e->global.toPoint());
2659             localValid = false;
2660         }
2661         if (!window)
2662             return;
2663         pointData.target = window;
2664     } else {
2665         if (e->nullWindow()) {
2666             window = pointData.target;
2667             localValid = false;
2668         }
2669         if (type == QEvent::TabletRelease)
2670             pointData.target = nullptr;
2671         if (!window)
2672             return;
2673     }
2674     QPointF local = e->local;
2675     if (!localValid) {
2676         QPointF delta = e->global - e->global.toPoint();
2677         local = window->mapFromGlobal(e->global.toPoint()) + delta;
2678     }
2679 
2680     // TODO stop deducing the button state change here: rather require it from the platform plugin, as with mouse events
2681     Qt::MouseButtons stateChange = e->buttons ^ pointData.state;
2682     Qt::MouseButton button = Qt::NoButton;
2683     for (int check = Qt::LeftButton; check <= int(Qt::MaxMouseButton); check = check << 1) {
2684         if (check & stateChange) {
2685             button = Qt::MouseButton(check);
2686             break;
2687         }
2688     }
2689 
2690     QTabletEvent tabletEvent(type, device, local, e->global,
2691                              e->pressure, e->xTilt, e->yTilt,
2692                              e->tangentialPressure, e->rotation, e->z,
2693                              e->modifiers, button, e->buttons);
2694     tabletEvent.setAccepted(false);
2695     tabletEvent.setTimestamp(e->timestamp);
2696     QGuiApplication::sendSpontaneousEvent(window, &tabletEvent);
2697     pointData.state = e->buttons;
2698     if (!tabletEvent.isAccepted()
2699         && !QWindowSystemInterfacePrivate::TabletEvent::platformSynthesizesMouse
2700         && qApp->testAttribute(Qt::AA_SynthesizeMouseForUnhandledTabletEvents)) {
2701 
2702         const QEvent::Type mouseType = [&]() {
2703             switch (type) {
2704             case QEvent::TabletPress:   return QEvent::MouseButtonPress;
2705             case QEvent::TabletMove:    return QEvent::MouseMove;
2706             case QEvent::TabletRelease: return QEvent::MouseButtonRelease;
2707             default: Q_UNREACHABLE();
2708             }
2709         }();
2710         QWindowSystemInterfacePrivate::MouseEvent mouseEvent(window, e->timestamp, e->local,
2711             e->global, e->buttons, e->modifiers, button, mouseType, Qt::MouseEventNotSynthesized, false, device);
2712         mouseEvent.flags |= QWindowSystemInterfacePrivate::WindowSystemEvent::Synthetic;
2713         processMouseEvent(&mouseEvent);
2714     }
2715 #else
2716     Q_UNUSED(e);
2717 #endif
2718 }
2719 
2720 void QGuiApplicationPrivate::processTabletEnterProximityEvent(QWindowSystemInterfacePrivate::TabletEnterProximityEvent *e)
2721 {
2722 #if QT_CONFIG(tabletevent)
2723     const QPointingDevice *dev = static_cast<const QPointingDevice *>(e->device);
2724     QTabletEvent ev(QEvent::TabletEnterProximity, dev, QPointF(), QPointF(),
2725                     0, 0, 0, 0, 0, 0, e->modifiers, Qt::NoButton,
2726                     tabletDevicePoint(dev->uniqueId().numericId()).state);
2727     ev.setTimestamp(e->timestamp);
2728     QGuiApplication::sendSpontaneousEvent(qGuiApp, &ev);
2729 #else
2730     Q_UNUSED(e);
2731 #endif
2732 }
2733 
2734 void QGuiApplicationPrivate::processTabletLeaveProximityEvent(QWindowSystemInterfacePrivate::TabletLeaveProximityEvent *e)
2735 {
2736 #if QT_CONFIG(tabletevent)
2737     const QPointingDevice *dev = static_cast<const QPointingDevice *>(e->device);
2738     QTabletEvent ev(QEvent::TabletLeaveProximity, dev, QPointF(), QPointF(),
2739                     0, 0, 0, 0, 0, 0, e->modifiers, Qt::NoButton,
2740                     tabletDevicePoint(dev->uniqueId().numericId()).state);
2741     ev.setTimestamp(e->timestamp);
2742     QGuiApplication::sendSpontaneousEvent(qGuiApp, &ev);
2743 #else
2744     Q_UNUSED(e);
2745 #endif
2746 }
2747 
2748 #ifndef QT_NO_GESTURES
2749 void QGuiApplicationPrivate::processGestureEvent(QWindowSystemInterfacePrivate::GestureEvent *e)
2750 {
2751     if (e->window.isNull())
2752         return;
2753 
2754     const QPointingDevice *device = static_cast<const QPointingDevice *>(e->device);
2755     QNativeGestureEvent ev(e->type, device, e->fingerCount, e->pos, e->pos, e->globalPos, (e->intValue ? e->intValue : e->realValue),
2756                            e->delta, e->sequenceId);
2757     ev.setTimestamp(e->timestamp);
2758     QGuiApplication::sendSpontaneousEvent(e->window, &ev);
2759 }
2760 #endif // QT_NO_GESTURES
2761 
2762 void QGuiApplicationPrivate::processPlatformPanelEvent(QWindowSystemInterfacePrivate::PlatformPanelEvent *e)
2763 {
2764     if (!e->window)
2765         return;
2766 
2767     if (e->window->d_func()->blockedByModalWindow) {
2768         // a modal window is blocking this window, don't allow events through
2769         return;
2770     }
2771 
2772     QEvent ev(QEvent::PlatformPanel);
2773     QGuiApplication::sendSpontaneousEvent(e->window.data(), &ev);
2774 }
2775 
2776 #ifndef QT_NO_CONTEXTMENU
2777 void QGuiApplicationPrivate::processContextMenuEvent(QWindowSystemInterfacePrivate::ContextMenuEvent *e)
2778 {
2779     // Widgets do not care about mouse triggered context menu events. Also, do not forward event
2780     // to a window blocked by a modal window.
2781     if (!e->window || e->mouseTriggered || e->window->d_func()->blockedByModalWindow)
2782         return;
2783 
2784     QContextMenuEvent ev(QContextMenuEvent::Keyboard, e->pos, e->globalPos, e->modifiers);
2785     QGuiApplication::sendSpontaneousEvent(e->window.data(), &ev);
2786 }
2787 #endif
2788 
2789 void QGuiApplicationPrivate::processTouchEvent(QWindowSystemInterfacePrivate::TouchEvent *e)
2790 {
2791     modifier_buttons = e->modifiers;
2792     QPointingDevice *device = const_cast<QPointingDevice *>(static_cast<const QPointingDevice *>(e->device));
2793     QPointingDevicePrivate *devPriv = QPointingDevicePrivate::get(device);
2794 
2795     if (e->touchType == QEvent::TouchCancel) {
2796         // The touch sequence has been canceled (e.g. by the compositor).
2797         // Send the TouchCancel to all windows with active touches and clean up.
2798         QTouchEvent touchEvent(QEvent::TouchCancel, device, e->modifiers);
2799         touchEvent.setTimestamp(e->timestamp);
2800         QSet<QWindow *> windowsNeedingCancel;
2801 
2802         for (auto &epd : devPriv->activePoints.values()) {
2803             auto &mut = QMutableEventPoint::from(const_cast<QEventPoint &>(epd.eventPoint));
2804             QWindow *w = mut.window();
2805             if (w)
2806                 windowsNeedingCancel.insert(w);
2807         }
2808 
2809         for (QSet<QWindow *>::const_iterator winIt = windowsNeedingCancel.constBegin(),
2810             winItEnd = windowsNeedingCancel.constEnd(); winIt != winItEnd; ++winIt) {
2811             QGuiApplication::sendSpontaneousEvent(*winIt, &touchEvent);
2812         }
2813         if (!self->synthesizedMousePoints.isEmpty() && !e->synthetic()) {
2814             for (QHash<QWindow *, SynthesizedMouseData>::const_iterator synthIt = self->synthesizedMousePoints.constBegin(),
2815                  synthItEnd = self->synthesizedMousePoints.constEnd(); synthIt != synthItEnd; ++synthIt) {
2816                 if (!synthIt->window)
2817                     continue;
2818                 QWindowSystemInterfacePrivate::MouseEvent fake(synthIt->window.data(),
2819                                                                e->timestamp,
2820                                                                synthIt->pos,
2821                                                                synthIt->screenPos,
2822                                                                Qt::NoButton,
2823                                                                e->modifiers,
2824                                                                Qt::LeftButton,
2825                                                                QEvent::MouseButtonRelease,
2826                                                                Qt::MouseEventNotSynthesized,
2827                                                                false,
2828                                                                device);
2829                 fake.flags |= QWindowSystemInterfacePrivate::WindowSystemEvent::Synthetic;
2830                 processMouseEvent(&fake);
2831             }
2832             self->synthesizedMousePoints.clear();
2833         }
2834         self->lastTouchType = e->touchType;
2835         return;
2836     }
2837 
2838     // Prevent sending ill-formed event sequences: Cancel can only be followed by a Begin.
2839     if (self->lastTouchType == QEvent::TouchCancel && e->touchType != QEvent::TouchBegin)
2840         return;
2841 
2842     self->lastTouchType = e->touchType;
2843 
2844     QPointer<QWindow> window = e->window;  // the platform hopefully tells us which window received the event
2845     QVarLengthArray<QMutableTouchEvent, 2> touchEvents;
2846 
2847     // For each temporary QEventPoint from the QPA TouchEvent:
2848     // - update the persistent QEventPoint in QPointingDevicePrivate::activePoints with current values
2849     // - determine which window to deliver it to
2850     // - add it to the QTouchEvent instance for that window (QMutableTouchEvent::target() will be QWindow*, for now)
2851     for (auto &tempPt : e->points) {
2852         // update state
2853         auto epd = devPriv->pointById(tempPt.id());
2854         auto &mut = QMutableEventPoint::from(const_cast<QEventPoint &>(epd->eventPoint));
2855         epd->eventPoint.setAccepted(false);
2856         switch (tempPt.state()) {
2857         case QEventPoint::State::Pressed:
2858             // On touchpads, send all touch points to the same window.
2859             if (!window && e->device && e->device->type() == QInputDevice::DeviceType::TouchPad)
2860                 window = devPriv->firstActiveWindow();
2861             // If the QPA event didn't tell us which window, find the one under the touchpoint position.
2862             if (!window)
2863                 window = QGuiApplication::topLevelAt(tempPt.globalPosition().toPoint());
2864             mut.setWindow(window);
2865             break;
2866 
2867         case QEventPoint::State::Released:
2868             if (Q_UNLIKELY(!window.isNull() && window != mut.window()))
2869                 qCWarning(lcPtrDispatch) << "delivering touch release to same window" << mut.window() << "not" << window.data();
2870             window = mut.window();
2871             break;
2872 
2873         default: // update or stationary
2874             if (Q_UNLIKELY(!window.isNull() && window != mut.window()))
2875                 qCWarning(lcPtrDispatch) << "delivering touch update to same window" << mut.window() << "not" << window.data();
2876             window = mut.window();
2877             break;
2878         }
2879         // If we somehow still don't have a window, we can't deliver this touchpoint.  (should never happen)
2880         if (Q_UNLIKELY(!window)) {
2881             qCWarning(lcPtrDispatch) << "skipping" << &tempPt << ": no target window";
2882             continue;
2883         }
2884         mut.updateFrom(tempPt);
2885 
2886         Q_ASSERT(window.data() != nullptr);
2887 
2888         // make the *scene* position the same as the *global* position
2889         mut.setScenePosition(tempPt.globalPosition());
2890 
2891         // store the scene position as local position, for now
2892         mut.setPosition(window->mapFromGlobal(tempPt.globalPosition()));
2893 
2894         // setTimeStamp has side effects, so we do it last
2895         mut.setTimestamp(e->timestamp);
2896 
2897         // add the touchpoint to the event that will be delivered to the window
2898         bool added = false;
2899         for (QMutableTouchEvent &ev : touchEvents) {
2900             if (ev.target() == window.data()) {
2901                 ev.addPoint(mut);
2902                 added = true;
2903                 break;
2904             }
2905         }
2906         if (!added) {
2907             QMutableTouchEvent mte(e->touchType, device, e->modifiers, {mut});
2908             mte.setTimestamp(e->timestamp);
2909             mte.setTarget(window.data());
2910             touchEvents.append(mte);
2911         }
2912     }
2913 
2914     if (touchEvents.isEmpty())
2915         return;
2916 
2917     for (QMutableTouchEvent &touchEvent : touchEvents) {
2918         QWindow *window = static_cast<QWindow *>(touchEvent.target());
2919 
2920         QEvent::Type eventType;
2921         switch (touchEvent.touchPointStates()) {
2922         case QEventPoint::State::Pressed:
2923             eventType = QEvent::TouchBegin;
2924             break;
2925         case QEventPoint::State::Released:
2926             eventType = QEvent::TouchEnd;
2927             break;
2928         default:
2929             eventType = QEvent::TouchUpdate;
2930             break;
2931         }
2932 
2933         if (window->d_func()->blockedByModalWindow && !qApp->d_func()->popupActive()) {
2934             // a modal window is blocking this window, don't allow touch events through
2935 
2936             // QTBUG-37371 temporary fix; TODO: revisit when we have a forwarding solution
2937             if (touchEvent.type() == QEvent::TouchEnd) {
2938                 // but don't leave dangling state: e.g.
2939                 // QQuickWindowPrivate::itemForTouchPointId needs to be cleared.
2940                 QTouchEvent touchEvent(QEvent::TouchCancel, device, e->modifiers);
2941                 touchEvent.setTimestamp(e->timestamp);
2942                 QGuiApplication::sendSpontaneousEvent(window, &touchEvent);
2943             }
2944             continue;
2945         }
2946 
2947         // Note: after the call to sendSpontaneousEvent, touchEvent.position() will have
2948         // changed to reflect the local position inside the last (random) widget it tried
2949         // to deliver the touch event to, and will therefore be invalid afterwards.
2950         QGuiApplication::sendSpontaneousEvent(window, &touchEvent);
2951 
2952         if (!e->synthetic() && !touchEvent.isAccepted() && qApp->testAttribute(Qt::AA_SynthesizeMouseForUnhandledTouchEvents)) {
2953             // exclude devices which generate their own mouse events
2954             if (!(touchEvent.device()->capabilities().testFlag(QInputDevice::Capability::MouseEmulation))) {
2955 
2956                 QEvent::Type mouseEventType = QEvent::MouseMove;
2957                 Qt::MouseButton button = Qt::NoButton;
2958                 Qt::MouseButtons buttons = Qt::LeftButton;
2959                 if (eventType == QEvent::TouchBegin  && m_fakeMouseSourcePointId < 0) {
2960                     m_fakeMouseSourcePointId = touchEvent.point(0).id();
2961                     qCDebug(lcPtrDispatch) << "synthesizing mouse events from touchpoint" << m_fakeMouseSourcePointId;
2962                 }
2963                 if (m_fakeMouseSourcePointId >= 0) {
2964                     const auto *touchPoint = touchEvent.pointById(m_fakeMouseSourcePointId);
2965                     if (touchPoint) {
2966                         switch (touchPoint->state()) {
2967                         case QEventPoint::State::Pressed:
2968                             mouseEventType = QEvent::MouseButtonPress;
2969                             button = Qt::LeftButton;
2970                             break;
2971                         case QEventPoint::State::Released:
2972                             mouseEventType = QEvent::MouseButtonRelease;
2973                             button = Qt::LeftButton;
2974                             buttons = Qt::NoButton;
2975                             Q_ASSERT(m_fakeMouseSourcePointId == touchPoint->id());
2976                             m_fakeMouseSourcePointId = -1;
2977                             break;
2978                         default:
2979                             break;
2980                         }
2981                         if (touchPoint->state() != QEventPoint::State::Released) {
2982                             self->synthesizedMousePoints.insert(window, SynthesizedMouseData(
2983                                                                     touchPoint->position(), touchPoint->globalPosition(), window));
2984                         }
2985                         // All touch events that are not accepted by the application will be translated to
2986                         // left mouse button events instead (see AA_SynthesizeMouseForUnhandledTouchEvents docs).
2987                         // TODO why go through QPA?  Why not just send a QMouseEvent right from here?
2988                         QWindowSystemInterfacePrivate::MouseEvent fake(window, e->timestamp,
2989                                                                        window->mapFromGlobal(touchPoint->globalPosition().toPoint()),
2990                                                                        touchPoint->globalPosition(),
2991                                                                        buttons,
2992                                                                        e->modifiers,
2993                                                                        button,
2994                                                                        mouseEventType,
2995                                                                        Qt::MouseEventSynthesizedByQt,
2996                                                                        false,
2997                                                                        device);
2998                         fake.flags |= QWindowSystemInterfacePrivate::WindowSystemEvent::Synthetic;
2999                         processMouseEvent(&fake);
3000                     }
3001                 }
3002                 if (eventType == QEvent::TouchEnd)
3003                     self->synthesizedMousePoints.clear();
3004             }
3005         }
3006     }
3007 
3008     // Remove released points from QPointingDevicePrivate::activePoints only after the event is
3009     // delivered.  Widgets and Qt Quick are allowed to access them at any time before this.
3010     for (const QEventPoint &touchPoint : e->points) {
3011         if (touchPoint.state() == QEventPoint::State::Released)
3012             devPriv->removePointById(touchPoint.id());
3013     }
3014 }
3015 
3016 void QGuiApplicationPrivate::processScreenOrientationChange(QWindowSystemInterfacePrivate::ScreenOrientationEvent *e)
3017 {
3018     // This operation only makes sense after the QGuiApplication constructor runs
3019     if (QCoreApplication::startingUp())
3020         return;
3021 
3022     if (!e->screen)
3023         return;
3024 
3025     QScreen *s = e->screen.data();
3026     s->d_func()->orientation = e->orientation;
3027 
3028     emit s->orientationChanged(s->orientation());
3029 
3030     QScreenOrientationChangeEvent event(s, s->orientation());
3031     QCoreApplication::sendEvent(QCoreApplication::instance(), &event);
3032 }
3033 
3034 void QGuiApplicationPrivate::processScreenGeometryChange(QWindowSystemInterfacePrivate::ScreenGeometryEvent *e)
3035 {
3036     // This operation only makes sense after the QGuiApplication constructor runs
3037     if (QCoreApplication::startingUp())
3038         return;
3039 
3040     if (!e->screen)
3041         return;
3042 
3043     QScreen *s = e->screen.data();
3044 
3045     bool geometryChanged = e->geometry != s->d_func()->geometry;
3046     s->d_func()->geometry = e->geometry;
3047 
3048     bool availableGeometryChanged = e->availableGeometry != s->d_func()->availableGeometry;
3049     s->d_func()->availableGeometry = e->availableGeometry;
3050 
3051     const Qt::ScreenOrientation primaryOrientation = s->primaryOrientation();
3052     if (geometryChanged)
3053         s->d_func()->updatePrimaryOrientation();
3054 
3055     s->d_func()->emitGeometryChangeSignals(geometryChanged, availableGeometryChanged);
3056 
3057     if (geometryChanged) {
3058         emit s->physicalSizeChanged(s->physicalSize());
3059         emit s->logicalDotsPerInchChanged(s->logicalDotsPerInch());
3060 
3061         if (s->primaryOrientation() != primaryOrientation)
3062             emit s->primaryOrientationChanged(s->primaryOrientation());
3063     }
3064 
3065     resetCachedDevicePixelRatio();
3066 }
3067 
3068 void QGuiApplicationPrivate::processScreenLogicalDotsPerInchChange(QWindowSystemInterfacePrivate::ScreenLogicalDotsPerInchEvent *e)
3069 {
3070     // This operation only makes sense after the QGuiApplication constructor runs
3071     if (QCoreApplication::startingUp())
3072         return;
3073 
3074     QHighDpiScaling::updateHighDpiScaling();
3075 
3076     if (!e->screen)
3077         return;
3078 
3079     QScreen *s = e->screen.data();
3080     s->d_func()->logicalDpi = QDpi(e->dpiX, e->dpiY);
3081 
3082     emit s->logicalDotsPerInchChanged(s->logicalDotsPerInch());
3083     s->d_func()->updateGeometriesWithSignals();
3084 
3085     resetCachedDevicePixelRatio();
3086 }
3087 
3088 void QGuiApplicationPrivate::processScreenRefreshRateChange(QWindowSystemInterfacePrivate::ScreenRefreshRateEvent *e)
3089 {
3090     // This operation only makes sense after the QGuiApplication constructor runs
3091     if (QCoreApplication::startingUp())
3092         return;
3093 
3094     if (!e->screen)
3095         return;
3096 
3097     QScreen *s = e->screen.data();
3098     qreal rate = e->rate;
3099     // safeguard ourselves against buggy platform behavior...
3100     if (rate < 1.0)
3101         rate = 60.0;
3102     if (!qFuzzyCompare(s->d_func()->refreshRate, rate)) {
3103         s->d_func()->refreshRate = rate;
3104         emit s->refreshRateChanged(s->refreshRate());
3105     }
3106 }
3107 
3108 void QGuiApplicationPrivate::processExposeEvent(QWindowSystemInterfacePrivate::ExposeEvent *e)
3109 {
3110     if (!e->window)
3111         return;
3112 
3113     QWindow *window = e->window.data();
3114     if (!window)
3115         return;
3116     QWindowPrivate *p = qt_window_private(window);
3117 
3118     if (!p->receivedExpose) {
3119         if (p->resizeEventPending) {
3120             // as a convenience for plugins, send a resize event before the first expose event if they haven't done so
3121             // window->geometry() should have a valid size as soon as a handle exists.
3122             QResizeEvent e(window->geometry().size(), p->geometry.size());
3123             QGuiApplication::sendSpontaneousEvent(window, &e);
3124 
3125             p->resizeEventPending = false;
3126         }
3127 
3128         // FIXME: It would logically make sense to set this _after_ we've sent the
3129         // expose event to the window, to mark that it now has received an expose.
3130         // But some parts of Qt (mis)use this private member to check whether the
3131         // window has been mapped yet, which they do in code that is triggered
3132         // by the very same expose event we send below. To keep the code working
3133         // we need to set the variable up front, until the code has been fixed.
3134         p->receivedExpose = true;
3135     }
3136 
3137     // If the platform does not send paint events we need to synthesize them from expose events
3138     const bool shouldSynthesizePaintEvents = !platformIntegration()->hasCapability(QPlatformIntegration::PaintEvents);
3139 
3140     const bool wasExposed = p->exposed;
3141     p->exposed = e->isExposed && window->screen();
3142 
3143     // We treat expose events for an already exposed window as paint events
3144     if (wasExposed && p->exposed && shouldSynthesizePaintEvents) {
3145         QPaintEvent paintEvent(e->region);
3146         QCoreApplication::sendSpontaneousEvent(window, &paintEvent);
3147         if (paintEvent.isAccepted())
3148             return; // No need to send expose
3149 
3150         // The paint event was not accepted, so we fall through and send an expose
3151         // event instead, to maintain compatibility for clients that haven't adopted
3152         // paint events yet.
3153     }
3154 
3155     QExposeEvent exposeEvent(e->region);
3156     QCoreApplication::sendSpontaneousEvent(window, &exposeEvent);
3157     e->eventAccepted = exposeEvent.isAccepted();
3158 
3159     // If the window was just exposed we also need to send a paint event,
3160     // so that clients that implement paint events will draw something.
3161     // Note that we we can not skip this based on the expose event being
3162     // accepted, as clients may implement exposeEvent to track the state
3163     // change, but without drawing anything.
3164     if (!wasExposed && p->exposed && shouldSynthesizePaintEvents) {
3165         QPaintEvent paintEvent(e->region);
3166         QCoreApplication::sendSpontaneousEvent(window, &paintEvent);
3167     }
3168 }
3169 
3170 void QGuiApplicationPrivate::processPaintEvent(QWindowSystemInterfacePrivate::PaintEvent *e)
3171 {
3172     Q_ASSERT_X(platformIntegration()->hasCapability(QPlatformIntegration::PaintEvents), "QGuiApplication",
3173         "The platform sent paint events without claiming support for it in QPlatformIntegration::capabilities()");
3174 
3175     if (!e->window)
3176         return;
3177 
3178     QPaintEvent paintEvent(e->region);
3179     QCoreApplication::sendSpontaneousEvent(e->window, &paintEvent);
3180 
3181     // We report back the accepted state to the platform, so that it can
3182     // decide when the best time to send the fallback expose event is.
3183     e->eventAccepted = paintEvent.isAccepted();
3184 }
3185 
3186 #if QT_CONFIG(draganddrop)
3187 
3188 /*! \internal
3189 
3190   This function updates an internal state to keep the source compatibility.
3191   ### Qt 6 - Won't need after QTBUG-73829
3192 */
3193 static void updateMouseAndModifierButtonState(Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers)
3194 {
3195     QGuiApplicationPrivate::mouse_buttons = buttons;
3196     QGuiApplicationPrivate::modifier_buttons = modifiers;
3197 }
3198 
3199 QPlatformDragQtResponse QGuiApplicationPrivate::processDrag(QWindow *w, const QMimeData *dropData,
3200                                                             const QPoint &p, Qt::DropActions supportedActions,
3201                                                             Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers)
3202 {
3203     updateMouseAndModifierButtonState(buttons, modifiers);
3204 
3205     static Qt::DropAction lastAcceptedDropAction = Qt::IgnoreAction;
3206     QPlatformDrag *platformDrag = platformIntegration()->drag();
3207     if (!platformDrag || (w && w->d_func()->blockedByModalWindow)) {
3208         lastAcceptedDropAction = Qt::IgnoreAction;
3209         return QPlatformDragQtResponse(false, lastAcceptedDropAction, QRect());
3210     }
3211 
3212     if (!dropData) {
3213         currentDragWindow = nullptr;
3214         QDragLeaveEvent e;
3215         QGuiApplication::sendEvent(w, &e);
3216         lastAcceptedDropAction = Qt::IgnoreAction;
3217         return QPlatformDragQtResponse(false, lastAcceptedDropAction, QRect());
3218     }
3219     QDragMoveEvent me(p, supportedActions, dropData, buttons, modifiers);
3220 
3221     if (w != currentDragWindow) {
3222         lastAcceptedDropAction = Qt::IgnoreAction;
3223         if (currentDragWindow) {
3224             QDragLeaveEvent e;
3225             QGuiApplication::sendEvent(currentDragWindow, &e);
3226         }
3227         currentDragWindow = w;
3228         QDragEnterEvent e(p, supportedActions, dropData, buttons, modifiers);
3229         QGuiApplication::sendEvent(w, &e);
3230         if (e.isAccepted() && e.dropAction() != Qt::IgnoreAction)
3231             lastAcceptedDropAction = e.dropAction();
3232     }
3233 
3234     // Handling 'DragEnter' should suffice for the application.
3235     if (lastAcceptedDropAction != Qt::IgnoreAction
3236         && (supportedActions & lastAcceptedDropAction)) {
3237         me.setDropAction(lastAcceptedDropAction);
3238         me.accept();
3239     }
3240     QGuiApplication::sendEvent(w, &me);
3241     lastAcceptedDropAction = me.isAccepted() ?
3242                              me.dropAction() :  Qt::IgnoreAction;
3243     return QPlatformDragQtResponse(me.isAccepted(), lastAcceptedDropAction, me.answerRect());
3244 }
3245 
3246 QPlatformDropQtResponse QGuiApplicationPrivate::processDrop(QWindow *w, const QMimeData *dropData,
3247                                                             const QPoint &p, Qt::DropActions supportedActions,
3248                                                             Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers)
3249 {
3250     updateMouseAndModifierButtonState(buttons, modifiers);
3251 
3252     currentDragWindow = nullptr;
3253 
3254     QDropEvent de(p, supportedActions, dropData, buttons, modifiers);
3255     QGuiApplication::sendEvent(w, &de);
3256 
3257     Qt::DropAction acceptedAction = de.isAccepted() ? de.dropAction() : Qt::IgnoreAction;
3258     QPlatformDropQtResponse response(de.isAccepted(),acceptedAction);
3259     return response;
3260 }
3261 
3262 #endif // QT_CONFIG(draganddrop)
3263 
3264 #ifndef QT_NO_CLIPBOARD
3265 /*!
3266     Returns the object for interacting with the clipboard.
3267 */
3268 QClipboard * QGuiApplication::clipboard()
3269 {
3270     if (QGuiApplicationPrivate::qt_clipboard == nullptr) {
3271         if (!qApp) {
3272             qWarning("QGuiApplication: Must construct a QGuiApplication before accessing a QClipboard");
3273             return nullptr;
3274         }
3275         QGuiApplicationPrivate::qt_clipboard = new QClipboard(nullptr);
3276     }
3277     return QGuiApplicationPrivate::qt_clipboard;
3278 }
3279 #endif
3280 
3281 /*!
3282     \since 5.4
3283     \fn void QGuiApplication::paletteChanged(const QPalette &palette)
3284     \deprecated [6.0] Handle QEvent::ApplicationPaletteChange instead.
3285 
3286     This signal is emitted when the \a palette of the application changes. Use
3287     QEvent::ApplicationPaletteChanged instead.
3288 
3289     \sa palette()
3290 */
3291 
3292 /*!
3293     Returns the current application palette.
3294 
3295     Roles that have not been explicitly set will reflect the system's platform theme.
3296 
3297     \sa setPalette()
3298 */
3299 
3300 QPalette QGuiApplication::palette()
3301 {
3302     if (!QGuiApplicationPrivate::app_pal)
3303         QGuiApplicationPrivate::updatePalette();
3304 
3305     return *QGuiApplicationPrivate::app_pal;
3306 }
3307 
3308 void QGuiApplicationPrivate::updatePalette()
3309 {
3310     if (app_pal) {
3311         if (setPalette(*app_pal) && qGuiApp)
3312             qGuiApp->d_func()->handlePaletteChanged();
3313     } else {
3314         setPalette(QPalette());
3315     }
3316 }
3317 
3318 void QGuiApplicationPrivate::clearPalette()
3319 {
3320     delete app_pal;
3321     app_pal = nullptr;
3322 }
3323 
3324 /*!
3325     Changes the application palette to \a pal.
3326 
3327     The color roles from this palette are combined with the system's platform
3328     theme to form the application's final palette.
3329 
3330     \sa palette()
3331 */
3332 void QGuiApplication::setPalette(const QPalette &pal)
3333 {
3334     if (QGuiApplicationPrivate::setPalette(pal) && qGuiApp)
3335         qGuiApp->d_func()->handlePaletteChanged();
3336 }
3337 
3338 bool QGuiApplicationPrivate::setPalette(const QPalette &palette)
3339 {
3340     // Resolve the palette against the theme palette, filling in
3341     // any missing roles, while keeping the original resolve mask.
3342     QPalette basePalette = qGuiApp ? qGuiApp->d_func()->basePalette() : Qt::gray;
3343     basePalette.setResolveMask(0); // The base palette only contributes missing colors roles
3344     QPalette resolvedPalette = palette.resolve(basePalette);
3345 
3346     if (app_pal && resolvedPalette == *app_pal && resolvedPalette.resolveMask() == app_pal->resolveMask())
3347         return false;
3348 
3349     if (!app_pal)
3350         app_pal = new QPalette(resolvedPalette);
3351     else
3352         *app_pal = resolvedPalette;
3353 
3354     QCoreApplication::setAttribute(Qt::AA_SetPalette, app_pal->resolveMask() != 0);
3355 
3356     return true;
3357 }
3358 
3359 /*
3360     Returns the base palette used to fill in missing roles in
3361     the current application palette.
3362 
3363     Normally this is the theme palette, but QApplication
3364     overrides this for compatibility reasons.
3365 */
3366 QPalette QGuiApplicationPrivate::basePalette() const
3367 {
3368     return platformTheme() ? *platformTheme()->palette() : Qt::gray;
3369 }
3370 
3371 void QGuiApplicationPrivate::handlePaletteChanged(const char *className)
3372 {
3373     if (!className) {
3374         Q_ASSERT(app_pal);
3375 QT_WARNING_PUSH
3376 QT_WARNING_DISABLE_DEPRECATED
3377         emit qGuiApp->paletteChanged(*QGuiApplicationPrivate::app_pal);
3378 QT_WARNING_POP
3379     }
3380 
3381     if (is_app_running && !is_app_closing) {
3382         QEvent event(QEvent::ApplicationPaletteChange);
3383         QGuiApplication::sendEvent(qGuiApp, &event);
3384     }
3385 }
3386 
3387 void QGuiApplicationPrivate::applyWindowGeometrySpecificationTo(QWindow *window)
3388 {
3389     windowGeometrySpecification.applyTo(window);
3390 }
3391 
3392 /*!
3393     \since 5.11
3394     \fn void QGuiApplication::fontChanged(const QFont &font)
3395     \deprecated [6.0] Handle QEvent::ApplicationFontChange instead.
3396 
3397     This signal is emitted when the \a font of the application changes. Use
3398     QEvent::ApplicationFontChanged instead.
3399 
3400     \sa font()
3401 */
3402 
3403 /*!
3404     Returns the default application font.
3405 
3406     \sa setFont()
3407 */
3408 QFont QGuiApplication::font()
3409 {
3410     const auto locker = qt_scoped_lock(applicationFontMutex);
3411     if (!QGuiApplicationPrivate::self && !QGuiApplicationPrivate::app_font) {
3412         qWarning("QGuiApplication::font(): no QGuiApplication instance and no application font set.");
3413         return QFont();  // in effect: QFont((QFontPrivate*)nullptr), so no recursion
3414     }
3415     initFontUnlocked();
3416     return *QGuiApplicationPrivate::app_font;
3417 }
3418 
3419 /*!
3420     Changes the default application font to \a font.
3421 
3422     \sa font()
3423 */
3424 void QGuiApplication::setFont(const QFont &font)
3425 {
3426     auto locker = qt_unique_lock(applicationFontMutex);
3427     const bool emitChange = !QGuiApplicationPrivate::app_font
3428                             || (*QGuiApplicationPrivate::app_font != font);
3429     if (!QGuiApplicationPrivate::app_font)
3430         QGuiApplicationPrivate::app_font = new QFont(font);
3431     else
3432         *QGuiApplicationPrivate::app_font = font;
3433     applicationResourceFlags |= ApplicationFontExplicitlySet;
3434 
3435     if (emitChange && qGuiApp) {
3436         auto font = *QGuiApplicationPrivate::app_font;
3437         locker.unlock();
3438 QT_WARNING_PUSH
3439 QT_WARNING_DISABLE_DEPRECATED
3440         emit qGuiApp->fontChanged(font);
3441 QT_WARNING_POP
3442         QEvent event(QEvent::ApplicationFontChange);
3443         QGuiApplication::sendEvent(qGuiApp, &event);
3444     }
3445 }
3446 
3447 /*!
3448     \fn bool QGuiApplication::isRightToLeft()
3449 
3450     Returns \c true if the application's layout direction is
3451     Qt::RightToLeft; otherwise returns \c false.
3452 
3453     \sa layoutDirection(), isLeftToRight()
3454 */
3455 
3456 /*!
3457     \fn bool QGuiApplication::isLeftToRight()
3458 
3459     Returns \c true if the application's layout direction is
3460     Qt::LeftToRight; otherwise returns \c false.
3461 
3462     \sa layoutDirection(), isRightToLeft()
3463 */
3464 
3465 void QGuiApplicationPrivate::notifyLayoutDirectionChange()
3466 {
3467     const QWindowList list = QGuiApplication::topLevelWindows();
3468     for (int i = 0; i < list.size(); ++i) {
3469         QEvent ev(QEvent::ApplicationLayoutDirectionChange);
3470         QCoreApplication::sendEvent(list.at(i), &ev);
3471     }
3472 }
3473 
3474 void QGuiApplicationPrivate::notifyActiveWindowChange(QWindow *prev)
3475 {
3476     if (prev) {
3477         QEvent de(QEvent::WindowDeactivate);
3478         QCoreApplication::sendEvent(prev, &de);
3479     }
3480     if (self->focus_window) {
3481         QEvent ae(QEvent::WindowActivate);
3482         QCoreApplication::sendEvent(focus_window, &ae);
3483     }
3484 }
3485 
3486 /*!
3487     \property QGuiApplication::windowIcon
3488     \brief the default window icon
3489 
3490     \sa QWindow::setIcon(), {Setting the Application Icon}
3491 */
3492 QIcon QGuiApplication::windowIcon()
3493 {
3494     return QGuiApplicationPrivate::app_icon ? *QGuiApplicationPrivate::app_icon : QIcon();
3495 }
3496 
3497 void QGuiApplication::setWindowIcon(const QIcon &icon)
3498 {
3499     if (!QGuiApplicationPrivate::app_icon)
3500         QGuiApplicationPrivate::app_icon = new QIcon();
3501     *QGuiApplicationPrivate::app_icon = icon;
3502     if (QGuiApplicationPrivate::platform_integration
3503             && QGuiApplicationPrivate::platform_integration->hasCapability(QPlatformIntegration::ApplicationIcon))
3504         QGuiApplicationPrivate::platform_integration->setApplicationIcon(icon);
3505     if (QGuiApplicationPrivate::is_app_running && !QGuiApplicationPrivate::is_app_closing)
3506         QGuiApplicationPrivate::self->notifyWindowIconChanged();
3507 }
3508 
3509 void QGuiApplicationPrivate::notifyWindowIconChanged()
3510 {
3511     QEvent ev(QEvent::ApplicationWindowIconChange);
3512     const QWindowList list = QGuiApplication::topLevelWindows();
3513     for (int i = 0; i < list.size(); ++i)
3514         QCoreApplication::sendEvent(list.at(i), &ev);
3515 }
3516 
3517 
3518 
3519 /*!
3520     \property QGuiApplication::quitOnLastWindowClosed
3521 
3522     \brief whether the application implicitly quits when the last window is
3523     closed.
3524 
3525     The default is \c true.
3526 
3527     If this property is \c true, the applications quits when the last visible
3528     \l{Primary and Secondary Windows}{primary window} (i.e. top level window
3529     with no transient parent) is closed.
3530 
3531     \sa quit(), QWindow::close()
3532  */
3533 
3534 void QGuiApplication::setQuitOnLastWindowClosed(bool quit)
3535 {
3536     QGuiApplicationPrivate::quitOnLastWindowClosed = quit;
3537 }
3538 
3539 bool QGuiApplication::quitOnLastWindowClosed()
3540 {
3541     return QGuiApplicationPrivate::quitOnLastWindowClosed;
3542 }
3543 
3544 void QGuiApplicationPrivate::maybeLastWindowClosed()
3545 {
3546     if (!lastWindowClosed())
3547         return;
3548 
3549     if (in_exec)
3550         emit q_func()->lastWindowClosed();
3551 
3552     if (quitOnLastWindowClosed && canQuitAutomatically())
3553         quitAutomatically();
3554 }
3555 
3556 /*!
3557     \fn void QGuiApplication::lastWindowClosed()
3558 
3559     This signal is emitted from exec() when the last visible
3560     \l{Primary and Secondary Windows}{primary window} (i.e.
3561     top level window with no transient parent) is closed.
3562 
3563     By default, QGuiApplication quits after this signal is emitted. This feature
3564     can be turned off by setting \l quitOnLastWindowClosed to \c false.
3565 
3566     \sa QWindow::close(), QWindow::isTopLevel(), QWindow::transientParent()
3567 */
3568 
3569 bool QGuiApplicationPrivate::lastWindowClosed() const
3570 {
3571     for (auto *window : QGuiApplication::topLevelWindows()) {
3572         auto *windowPrivate = qt_window_private(window);
3573         if (!windowPrivate->participatesInLastWindowClosed())
3574             continue;
3575 
3576         if (windowPrivate->treatAsVisible())
3577             return false;
3578      }
3579 
3580      return true;
3581 }
3582 
3583 bool QGuiApplicationPrivate::canQuitAutomatically()
3584 {
3585     if (quitOnLastWindowClosed && !lastWindowClosed())
3586         return false;
3587 
3588     return QCoreApplicationPrivate::canQuitAutomatically();
3589 }
3590 
3591 void QGuiApplicationPrivate::quit()
3592 {
3593     if (auto *platformIntegration = QGuiApplicationPrivate::platformIntegration())
3594         platformIntegration->quit();
3595     else
3596         QCoreApplicationPrivate::quit();
3597 }
3598 
3599 void QGuiApplicationPrivate::processApplicationTermination(QWindowSystemInterfacePrivate::WindowSystemEvent *windowSystemEvent)
3600 {
3601     QEvent event(QEvent::Quit);
3602     QGuiApplication::sendSpontaneousEvent(QGuiApplication::instance(), &event);
3603     windowSystemEvent->eventAccepted = event.isAccepted();
3604 }
3605 
3606 /*!
3607     \since 5.2
3608     \fn Qt::ApplicationState QGuiApplication::applicationState()
3609 
3610 
3611     Returns the current state of the application.
3612 
3613     You can react to application state changes to perform actions such as
3614     stopping/resuming CPU-intensive tasks, freeing/loading resources or
3615     saving/restoring application data.
3616  */
3617 
3618 Qt::ApplicationState QGuiApplication::applicationState()
3619 {
3620     return QGuiApplicationPrivate::applicationState;
3621 }
3622 
3623 /*!
3624     \since 5.14
3625 
3626     Sets the high-DPI scale factor rounding policy for the application. The
3627     \a policy decides how non-integer scale factors (such as Windows 150%) are
3628     handled.
3629 
3630     The two principal options are whether fractional scale factors should
3631     be rounded to an integer or not. Keeping the scale factor as-is will
3632     make the user interface size match the OS setting exactly, but may cause
3633     painting errors, for example with the Windows style.
3634 
3635     If rounding is wanted, then which type of rounding should be decided
3636     next. Mathematically correct rounding is supported but may not give
3637     the best visual results: Consider if you want to render 1.5x as 1x
3638     ("small UI") or as 2x ("large UI"). See the Qt::HighDpiScaleFactorRoundingPolicy
3639     enum for a complete list of all options.
3640 
3641     This function must be called before creating the application object.
3642     The QGuiApplication::highDpiScaleFactorRoundingPolicy()
3643     accessor will reflect the environment, if set.
3644 
3645     The default value is Qt::HighDpiScaleFactorRoundingPolicy::PassThrough.
3646 */
3647 void QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy policy)
3648 {
3649     QGuiApplicationPrivate::highDpiScaleFactorRoundingPolicy = policy;
3650 }
3651 
3652 /*!
3653   \since 5.14
3654 
3655   Returns the high-DPI scale factor rounding policy.
3656 */
3657 Qt::HighDpiScaleFactorRoundingPolicy QGuiApplication::highDpiScaleFactorRoundingPolicy()
3658 {
3659     return QGuiApplicationPrivate::highDpiScaleFactorRoundingPolicy;
3660 }
3661 
3662 /*!
3663     \since 5.2
3664     \fn void QGuiApplication::applicationStateChanged(Qt::ApplicationState state)
3665 
3666     This signal is emitted when the \a state of the application changes.
3667 
3668     \sa applicationState()
3669 */
3670 
3671 void QGuiApplicationPrivate::setApplicationState(Qt::ApplicationState state, bool forcePropagate)
3672 {
3673     if ((applicationState == state) && !forcePropagate)
3674         return;
3675 
3676     applicationState = state;
3677 
3678     switch (state) {
3679     case Qt::ApplicationActive: {
3680         QEvent appActivate(QEvent::ApplicationActivate);
3681         QCoreApplication::sendSpontaneousEvent(qApp, &appActivate);
3682         break; }
3683     case Qt::ApplicationInactive: {
3684         QEvent appDeactivate(QEvent::ApplicationDeactivate);
3685         QCoreApplication::sendSpontaneousEvent(qApp, &appDeactivate);
3686         break; }
3687     default:
3688         break;
3689     }
3690 
3691     QApplicationStateChangeEvent event(applicationState);
3692     QCoreApplication::sendSpontaneousEvent(qApp, &event);
3693 
3694     emit qApp->applicationStateChanged(applicationState);
3695 }
3696 
3697 /*!
3698     \since 4.2
3699     \fn void QGuiApplication::commitDataRequest(QSessionManager &manager)
3700 
3701     This signal deals with \l{Session Management}{session management}. It is
3702     emitted when the QSessionManager wants the application to commit all its
3703     data.
3704 
3705     Usually this means saving all open files, after getting permission from
3706     the user. Furthermore you may want to provide a means by which the user
3707     can cancel the shutdown.
3708 
3709     You should not exit the application within this signal. Instead,
3710     the session manager may or may not do this afterwards, depending on the
3711     context.
3712 
3713     \warning Within this signal, no user interaction is possible, \e
3714     unless you ask the \a manager for explicit permission. See
3715     QSessionManager::allowsInteraction() and
3716     QSessionManager::allowsErrorInteraction() for details and example
3717     usage.
3718 
3719     \note You should use Qt::DirectConnection when connecting to this signal.
3720 
3721     \sa isSessionRestored(), sessionId(), saveStateRequest(), {Session Management}
3722 */
3723 
3724 /*!
3725     \since 4.2
3726     \fn void QGuiApplication::saveStateRequest(QSessionManager &manager)
3727 
3728     This signal deals with \l{Session Management}{session management}. It is
3729     invoked when the \l{QSessionManager}{session manager} wants the application
3730     to preserve its state for a future session.
3731 
3732     For example, a text editor would create a temporary file that includes the
3733     current contents of its edit buffers, the location of the cursor and other
3734     aspects of the current editing session.
3735 
3736     You should never exit the application within this signal. Instead, the
3737     session manager may or may not do this afterwards, depending on the
3738     context. Furthermore, most session managers will very likely request a saved
3739     state immediately after the application has been started. This permits the
3740     session manager to learn about the application's restart policy.
3741 
3742     \warning Within this signal, no user interaction is possible, \e
3743     unless you ask the \a manager for explicit permission. See
3744     QSessionManager::allowsInteraction() and
3745     QSessionManager::allowsErrorInteraction() for details.
3746 
3747     \note You should use Qt::DirectConnection when connecting to this signal.
3748 
3749     \sa isSessionRestored(), sessionId(), commitDataRequest(), {Session Management}
3750 */
3751 
3752 /*!
3753     \fn bool QGuiApplication::isSessionRestored() const
3754 
3755     Returns \c true if the application has been restored from an earlier
3756     \l{Session Management}{session}; otherwise returns \c false.
3757 
3758     \sa sessionId(), commitDataRequest(), saveStateRequest()
3759 */
3760 
3761 /*!
3762     \since 5.0
3763     \fn bool QGuiApplication::isSavingSession() const
3764 
3765     Returns \c true if the application is currently saving the
3766     \l{Session Management}{session}; otherwise returns \c false.
3767 
3768     This is \c true when commitDataRequest() and saveStateRequest() are emitted,
3769     but also when the windows are closed afterwards by session management.
3770 
3771     \sa sessionId(), commitDataRequest(), saveStateRequest()
3772 */
3773 
3774 /*!
3775     \fn QString QGuiApplication::sessionId() const
3776 
3777     Returns the current \l{Session Management}{session's} identifier.
3778 
3779     If the application has been restored from an earlier session, this
3780     identifier is the same as it was in that previous session. The session
3781     identifier is guaranteed to be unique both for different applications
3782     and for different instances of the same application.
3783 
3784     \sa isSessionRestored(), sessionKey(), commitDataRequest(), saveStateRequest()
3785 */
3786 
3787 /*!
3788     \fn QString QGuiApplication::sessionKey() const
3789 
3790     Returns the session key in the current \l{Session Management}{session}.
3791 
3792     If the application has been restored from an earlier session, this key is
3793     the same as it was when the previous session ended.
3794 
3795     The session key changes every time the session is saved. If the shutdown process
3796     is cancelled, another session key will be used when shutting down again.
3797 
3798     \sa isSessionRestored(), sessionId(), commitDataRequest(), saveStateRequest()
3799 */
3800 #ifndef QT_NO_SESSIONMANAGER
3801 bool QGuiApplication::isSessionRestored() const
3802 {
3803     Q_D(const QGuiApplication);
3804     return d->is_session_restored;
3805 }
3806 
3807 QString QGuiApplication::sessionId() const
3808 {
3809     Q_D(const QGuiApplication);
3810     return d->session_manager->sessionId();
3811 }
3812 
3813 QString QGuiApplication::sessionKey() const
3814 {
3815     Q_D(const QGuiApplication);
3816     return d->session_manager->sessionKey();
3817 }
3818 
3819 bool QGuiApplication::isSavingSession() const
3820 {
3821     Q_D(const QGuiApplication);
3822     return d->is_saving_session;
3823 }
3824 
3825 void QGuiApplicationPrivate::commitData()
3826 {
3827     Q_Q(QGuiApplication);
3828     is_saving_session = true;
3829     emit q->commitDataRequest(*session_manager);
3830     is_saving_session = false;
3831 }
3832 
3833 
3834 void QGuiApplicationPrivate::saveState()
3835 {
3836     Q_Q(QGuiApplication);
3837     is_saving_session = true;
3838     emit q->saveStateRequest(*session_manager);
3839     is_saving_session = false;
3840 }
3841 #endif //QT_NO_SESSIONMANAGER
3842 
3843 /*!
3844     \since 5.2
3845 
3846     Function that can be used to sync Qt state with the Window Systems state.
3847 
3848     This function will first empty Qts events by calling QCoreApplication::processEvents(),
3849     then the platform plugin will sync up with the windowsystem, and finally Qts events
3850     will be delived by another call to QCoreApplication::processEvents();
3851 
3852     This function is timeconsuming and its use is discouraged.
3853 */
3854 void QGuiApplication::sync()
3855 {
3856     QCoreApplication::processEvents();
3857     if (QGuiApplicationPrivate::platform_integration
3858             && QGuiApplicationPrivate::platform_integration->hasCapability(QPlatformIntegration::SyncState)) {
3859         QGuiApplicationPrivate::platform_integration->sync();
3860         QCoreApplication::processEvents();
3861         QWindowSystemInterface::flushWindowSystemEvents();
3862     }
3863 }
3864 
3865 /*!
3866     \property QGuiApplication::layoutDirection
3867     \brief the default layout direction for this application
3868 
3869     On system start-up, the default layout direction depends on the
3870     application's language.
3871 
3872     The notifier signal was introduced in Qt 5.4.
3873 
3874     \sa QWidget::layoutDirection, isLeftToRight(), isRightToLeft()
3875  */
3876 
3877 void QGuiApplication::setLayoutDirection(Qt::LayoutDirection direction)
3878 {
3879     if (layout_direction == direction || direction == Qt::LayoutDirectionAuto)
3880         return;
3881 
3882     layout_direction = direction;
3883 
3884     if (qGuiApp) {
3885         emit qGuiApp->layoutDirectionChanged(direction);
3886         QGuiApplicationPrivate::self->notifyLayoutDirectionChange();
3887     }
3888 }
3889 
3890 Qt::LayoutDirection QGuiApplication::layoutDirection()
3891 {
3892     // layout_direction is only ever Qt::LayoutDirectionAuto if setLayoutDirection
3893     // was never called, or called with Qt::LayoutDirectionAuto (which is a no-op).
3894     // In that case we return the default LeftToRight.
3895     return layout_direction == Qt::LayoutDirectionAuto ? Qt::LeftToRight : layout_direction;
3896 }
3897 
3898 /*!
3899     \fn QCursor *QGuiApplication::overrideCursor()
3900 
3901     Returns the active application override cursor.
3902 
3903     This function returns \nullptr if no application cursor has been defined (i.e. the
3904     internal cursor stack is empty).
3905 
3906     \sa setOverrideCursor(), restoreOverrideCursor()
3907 */
3908 #ifndef QT_NO_CURSOR
3909 QCursor *QGuiApplication::overrideCursor()
3910 {
3911     CHECK_QAPP_INSTANCE(nullptr)
3912     return qGuiApp->d_func()->cursor_list.isEmpty() ? nullptr : &qGuiApp->d_func()->cursor_list.first();
3913 }
3914 
3915 /*!
3916     Changes the currently active application override cursor to \a cursor.
3917 
3918     This function has no effect if setOverrideCursor() was not called.
3919 
3920     \sa setOverrideCursor(), overrideCursor(), restoreOverrideCursor(),
3921     QWidget::setCursor()
3922  */
3923 void QGuiApplication::changeOverrideCursor(const QCursor &cursor)
3924 {
3925     CHECK_QAPP_INSTANCE()
3926     if (qGuiApp->d_func()->cursor_list.isEmpty())
3927         return;
3928     qGuiApp->d_func()->cursor_list.removeFirst();
3929     setOverrideCursor(cursor);
3930 }
3931 #endif
3932 
3933 
3934 #ifndef QT_NO_CURSOR
3935 static inline void applyCursor(QWindow *w, QCursor c)
3936 {
3937     if (const QScreen *screen = w->screen())
3938         if (QPlatformCursor *cursor = screen->handle()->cursor())
3939             cursor->changeCursor(&c, w);
3940 }
3941 
3942 static inline void unsetCursor(QWindow *w)
3943 {
3944     if (const QScreen *screen = w->screen())
3945         if (QPlatformCursor *cursor = screen->handle()->cursor())
3946             cursor->changeCursor(nullptr, w);
3947 }
3948 
3949 static inline void applyCursor(const QList<QWindow *> &l, const QCursor &c)
3950 {
3951     for (int i = 0; i < l.size(); ++i) {
3952         QWindow *w = l.at(i);
3953         if (w->handle() && w->type() != Qt::Desktop)
3954             applyCursor(w, c);
3955     }
3956 }
3957 
3958 static inline void applyOverrideCursor(const QList<QScreen *> &screens, const QCursor &c)
3959 {
3960     for (QScreen *screen : screens) {
3961         if (QPlatformCursor *cursor = screen->handle()->cursor())
3962             cursor->setOverrideCursor(c);
3963     }
3964 }
3965 
3966 static inline void clearOverrideCursor(const QList<QScreen *> &screens)
3967 {
3968     for (QScreen *screen : screens) {
3969         if (QPlatformCursor *cursor = screen->handle()->cursor())
3970             cursor->clearOverrideCursor();
3971     }
3972 }
3973 
3974 static inline void applyWindowCursor(const QList<QWindow *> &l)
3975 {
3976     for (int i = 0; i < l.size(); ++i) {
3977         QWindow *w = l.at(i);
3978         if (w->handle() && w->type() != Qt::Desktop) {
3979             if (qt_window_private(w)->hasCursor) {
3980                 applyCursor(w, w->cursor());
3981             } else {
3982                 unsetCursor(w);
3983             }
3984         }
3985     }
3986 }
3987 
3988 /*!
3989     \fn void QGuiApplication::setOverrideCursor(const QCursor &cursor)
3990 
3991     Sets the application override cursor to \a cursor.
3992 
3993     Application override cursors are intended for showing the user that the
3994     application is in a special state, for example during an operation that
3995     might take some time.
3996 
3997     This cursor will be displayed in all the application's widgets until
3998     restoreOverrideCursor() or another setOverrideCursor() is called.
3999 
4000     Application cursors are stored on an internal stack. setOverrideCursor()
4001     pushes the cursor onto the stack, and restoreOverrideCursor() pops the
4002     active cursor off the stack. changeOverrideCursor() changes the currently
4003     active application override cursor.
4004 
4005     Every setOverrideCursor() must eventually be followed by a corresponding
4006     restoreOverrideCursor(), otherwise the stack will never be emptied.
4007 
4008     Example:
4009     \snippet code/src_gui_kernel_qguiapplication_x11.cpp 0
4010 
4011     \sa overrideCursor(), restoreOverrideCursor(), changeOverrideCursor(),
4012     QWidget::setCursor()
4013 */
4014 void QGuiApplication::setOverrideCursor(const QCursor &cursor)
4015 {
4016     CHECK_QAPP_INSTANCE()
4017     qGuiApp->d_func()->cursor_list.prepend(cursor);
4018     if (QPlatformCursor::capabilities().testFlag(QPlatformCursor::OverrideCursor))
4019         applyOverrideCursor(QGuiApplicationPrivate::screen_list, cursor);
4020     else
4021         applyCursor(QGuiApplicationPrivate::window_list, cursor);
4022 }
4023 
4024 /*!
4025     \fn void QGuiApplication::restoreOverrideCursor()
4026 
4027     Undoes the last setOverrideCursor().
4028 
4029     If setOverrideCursor() has been called twice, calling
4030     restoreOverrideCursor() will activate the first cursor set. Calling this
4031     function a second time restores the original widgets' cursors.
4032 
4033     \sa setOverrideCursor(), overrideCursor()
4034 */
4035 void QGuiApplication::restoreOverrideCursor()
4036 {
4037     CHECK_QAPP_INSTANCE()
4038     if (qGuiApp->d_func()->cursor_list.isEmpty())
4039         return;
4040     qGuiApp->d_func()->cursor_list.removeFirst();
4041     if (qGuiApp->d_func()->cursor_list.size() > 0) {
4042         QCursor c(qGuiApp->d_func()->cursor_list.value(0));
4043         if (QPlatformCursor::capabilities().testFlag(QPlatformCursor::OverrideCursor))
4044             applyOverrideCursor(QGuiApplicationPrivate::screen_list, c);
4045         else
4046             applyCursor(QGuiApplicationPrivate::window_list, c);
4047     } else {
4048         if (QPlatformCursor::capabilities().testFlag(QPlatformCursor::OverrideCursor))
4049             clearOverrideCursor(QGuiApplicationPrivate::screen_list);
4050         applyWindowCursor(QGuiApplicationPrivate::window_list);
4051     }
4052 }
4053 #endif// QT_NO_CURSOR
4054 
4055 /*!
4056   Returns the application's style hints.
4057 
4058   The style hints encapsulate a set of platform dependent properties
4059   such as double click intervals, full width selection and others.
4060 
4061   The hints can be used to integrate tighter with the underlying platform.
4062 
4063   \sa QStyleHints
4064   */
4065 QStyleHints *QGuiApplication::styleHints()
4066 {
4067     if (!QGuiApplicationPrivate::styleHints)
4068         QGuiApplicationPrivate::styleHints = new QStyleHints();
4069     return QGuiApplicationPrivate::styleHints;
4070 }
4071 
4072 /*!
4073     Sets whether Qt should use the system's standard colors, fonts, etc., to
4074     \a on. By default, this is \c true.
4075 
4076     This function must be called before creating the QGuiApplication object, like
4077     this:
4078 
4079     \snippet code/src_gui_kernel_qguiapplication.cpp 0
4080 
4081     \sa desktopSettingsAware()
4082 */
4083 void QGuiApplication::setDesktopSettingsAware(bool on)
4084 {
4085     QGuiApplicationPrivate::obey_desktop_settings = on;
4086 }
4087 
4088 /*!
4089     Returns \c true if Qt is set to use the system's standard colors, fonts, etc.;
4090     otherwise returns \c false. The default is \c true.
4091 
4092     \sa setDesktopSettingsAware()
4093 */
4094 bool QGuiApplication::desktopSettingsAware()
4095 {
4096     return QGuiApplicationPrivate::obey_desktop_settings;
4097 }
4098 
4099 /*!
4100   returns the input method.
4101 
4102   The input method returns properties about the state and position of
4103   the virtual keyboard. It also provides information about the position of the
4104   current focused input element.
4105 
4106   \sa QInputMethod
4107   */
4108 QInputMethod *QGuiApplication::inputMethod()
4109 {
4110     CHECK_QAPP_INSTANCE(nullptr)
4111     if (!qGuiApp->d_func()->inputMethod)
4112         qGuiApp->d_func()->inputMethod = new QInputMethod();
4113     return qGuiApp->d_func()->inputMethod;
4114 }
4115 
4116 /*!
4117     \fn void QGuiApplication::fontDatabaseChanged()
4118 
4119     This signal is emitted when application fonts are loaded or removed.
4120 
4121     \sa QFontDatabase::addApplicationFont(),
4122     QFontDatabase::addApplicationFontFromData(),
4123     QFontDatabase::removeAllApplicationFonts(),
4124     QFontDatabase::removeApplicationFont()
4125 */
4126 
4127 QPixmap QGuiApplicationPrivate::getPixmapCursor(Qt::CursorShape cshape)
4128 {
4129     Q_UNUSED(cshape);
4130     return QPixmap();
4131 }
4132 
4133 void QGuiApplicationPrivate::notifyThemeChanged()
4134 {
4135     updatePalette();
4136 
4137     QAbstractFileIconProviderPrivate::clearIconTypeCache();
4138 
4139     if (!(applicationResourceFlags & ApplicationFontExplicitlySet)) {
4140         const auto locker = qt_scoped_lock(applicationFontMutex);
4141         clearFontUnlocked();
4142         initFontUnlocked();
4143     }
4144     initThemeHints();
4145 }
4146 
4147 #if QT_CONFIG(draganddrop)
4148 void QGuiApplicationPrivate::notifyDragStarted(const QDrag *drag)
4149 {
4150     Q_UNUSED(drag);
4151 
4152 }
4153 #endif
4154 
4155 const QColorTrcLut *QGuiApplicationPrivate::colorProfileForA8Text()
4156 {
4157 #ifdef Q_OS_WIN
4158     if (!m_a8ColorProfile)
4159         m_a8ColorProfile = QColorTrcLut::fromGamma(2.31); // This is a hard-coded thing for Windows text rendering
4160     return m_a8ColorProfile.get();
4161 #else
4162     return colorProfileForA32Text();
4163 #endif
4164 }
4165 
4166 const QColorTrcLut *QGuiApplicationPrivate::colorProfileForA32Text()
4167 {
4168     if (!m_a32ColorProfile)
4169         m_a32ColorProfile = QColorTrcLut::fromGamma(fontSmoothingGamma);
4170     return m_a32ColorProfile.get();
4171 }
4172 
4173 void QGuiApplicationPrivate::_q_updateFocusObject(QObject *object)
4174 {
4175     Q_Q(QGuiApplication);
4176 
4177     QPlatformInputContext *inputContext = platformIntegration()->inputContext();
4178     const bool enabled = inputContext && QInputMethodPrivate::objectAcceptsInputMethod(object);
4179 
4180     QPlatformInputContextPrivate::setInputMethodAccepted(enabled);
4181     if (inputContext)
4182         inputContext->setFocusObject(object);
4183     emit q->focusObjectChanged(object);
4184 }
4185 
4186 enum MouseMasks {
4187     MouseCapsMask = 0xFF,
4188     MouseSourceMaskDst = 0xFF00,
4189     MouseSourceMaskSrc = MouseCapsMask,
4190     MouseSourceShift = 8,
4191     MouseFlagsCapsMask = 0xFF0000,
4192     MouseFlagsShift = 16
4193 };
4194 
4195 QInputDeviceManager *QGuiApplicationPrivate::inputDeviceManager()
4196 {
4197     Q_ASSERT(QGuiApplication::instance());
4198 
4199     if (!m_inputDeviceManager)
4200         m_inputDeviceManager = new QInputDeviceManager(QGuiApplication::instance());
4201 
4202     return m_inputDeviceManager;
4203 }
4204 
4205 /*!
4206     \fn template <typename QNativeInterface> QNativeInterface *QGuiApplication::nativeInterface() const
4207 
4208     Returns a native interface of the given type for the application.
4209 
4210     This function provides access to platform specific functionality
4211     of QGuiApplication, as defined in the QNativeInterface namespace:
4212 
4213     \annotatedlist native-interfaces-qguiapplication
4214 
4215     If the requested interface is not available a \nullptr is returned.
4216  */
4217 
4218 void *QGuiApplication::resolveInterface(const char *name, int revision) const
4219 {
4220     using namespace QNativeInterface;
4221     using namespace QNativeInterface::Private;
4222 
4223     auto *platformIntegration = QGuiApplicationPrivate::platformIntegration();
4224     Q_UNUSED(platformIntegration);
4225 
4226 #if defined(Q_OS_WIN)
4227     QT_NATIVE_INTERFACE_RETURN_IF(QWindowsApplication, platformIntegration);
4228 #endif
4229 #if QT_CONFIG(xcb)
4230     QT_NATIVE_INTERFACE_RETURN_IF(QX11Application, platformNativeInterface());
4231 #endif
4232 
4233     return QCoreApplication::resolveInterface(name, revision);
4234 }
4235 
4236 #include "moc_qguiapplication.cpp"
4237 
4238 QT_END_NAMESPACE
