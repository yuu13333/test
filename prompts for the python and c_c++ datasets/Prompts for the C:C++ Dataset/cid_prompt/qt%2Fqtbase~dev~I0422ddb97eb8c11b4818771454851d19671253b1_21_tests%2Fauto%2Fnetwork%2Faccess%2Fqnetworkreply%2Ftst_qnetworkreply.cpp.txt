Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the test suite of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
21 ** included in the packaging of this file. Please review the following
22 ** information to ensure the GNU General Public License requirements will
23 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
24 **
25 ** $QT_END_LICENSE$
26 **
27 ****************************************************************************/
28 
29 
30 #include <QtTest/QtTest>
31 #include <QtCore/QCryptographicHash>
32 #include <QtCore/QDataStream>
33 #include <QtCore/QUrl>
34 #include <QtCore/QEventLoop>
35 #include <QtCore/QFile>
36 #include <QtCore/QRandomGenerator>
37 #include <QtCore/QSharedPointer>
38 #include <QtCore/QScopedPointer>
39 #include <QtCore/QTemporaryFile>
40 #include <QtNetwork/QTcpServer>
41 #include <QtNetwork/QTcpSocket>
42 #include <QtNetwork/QLocalSocket>
43 #include <QtNetwork/QLocalServer>
44 #include <QtNetwork/QHostInfo>
45 #include <QtNetwork/QNetworkAccessManager>
46 #include <QtNetwork/QNetworkRequest>
47 #include <QtNetwork/QNetworkReply>
48 #include <QtNetwork/QAbstractNetworkCache>
49 #include <QtNetwork/qauthenticator.h>
50 #include <QtNetwork/qnetworkaccessmanager.h>
51 #include <QtNetwork/qnetworkdiskcache.h>
52 #include <QtNetwork/qnetworkrequest.h>
53 #include <QtNetwork/qnetworkreply.h>
54 #include <QtNetwork/qnetworkcookie.h>
55 #include <QtNetwork/QNetworkCookieJar>
56 #include <QtNetwork/QHttpPart>
57 #include <QtNetwork/QHttpMultiPart>
58 #include <QtNetwork/QNetworkProxyQuery>
59 #ifndef QT_NO_SSL
60 #include <QtNetwork/qsslerror.h>
61 #include <QtNetwork/qsslconfiguration.h>
62 #ifdef QT_BUILD_INTERNAL
63 #include <QtNetwork/private/qsslconfiguration_p.h>
64 #endif
65 #endif
66 #ifndef QT_NO_BEARERMANAGEMENT
67 #include <QtNetwork/qnetworkconfigmanager.h>
68 #include <QtNetwork/qnetworkconfiguration.h>
69 #include <QtNetwork/qnetworksession.h>
70 #include <QtNetwork/private/qnetworksession_p.h>
71 #endif
72 #ifdef QT_BUILD_INTERNAL
73 #include <QtNetwork/private/qnetworkreplyimpl_p.h> // implicitly included by qnetworkaccessmanager_p.h currently, but don't rely on that being true forever
74 #include <QtNetwork/private/qnetworkaccessmanager_p.h>
75 #else
76 Q_DECLARE_METATYPE(QSharedPointer<char>)
77 #endif
78 
79 #ifdef Q_OS_UNIX
80 # include <sys/types.h>
81 # include <unistd.h> // for getuid()
82 #endif
83 #include <time.h>
84 
85 #include "../../../network-settings.h"
86 
87 // Non-OpenSSL backends are not able to report a specific error code
88 // for self-signed certificates.
89 #ifndef QT_NO_OPENSSL
90 #define FLUKE_CERTIFICATE_ERROR QSslError::SelfSignedCertificate
91 #else
92 #define FLUKE_CERTIFICATE_ERROR QSslError::CertificateUntrusted
93 #endif
94 
95 Q_DECLARE_METATYPE(QAuthenticator*)
96 #ifndef QT_NO_NETWORKPROXY
97 Q_DECLARE_METATYPE(QNetworkProxyQuery)
98 #endif
99 
100 #include "emulationdetector.h"
101 
102 typedef QSharedPointer<QNetworkReply> QNetworkReplyPtr;
103 
104 class MyCookieJar;
105 class tst_QNetworkReply: public QObject
106 {
107     Q_OBJECT
108 
109 #ifndef QT_NO_NETWORKPROXY
110     struct ProxyData
111     {
112         ProxyData(const QNetworkProxy &p, const QByteArray &t, bool auth)
113             : tag(t), proxy(p), requiresAuthentication(auth) {}
114         QByteArray tag;
115         QNetworkProxy proxy;
116         bool requiresAuthentication;
117     };
118 #endif // !QT_NO_NETWORKPROXY
119 
120     static bool seedCreated;
121     static QString createUniqueExtension()
122     {
123         if (!seedCreated) {
124             seedCreated = true; // not thread-safe, but who cares
125         }
126         return QString::number(QTime(0, 0, 0).msecsTo(QTime::currentTime()))
127             + QLatin1Char('-') + QString::number(QCoreApplication::applicationPid())
128             + QLatin1Char('-') + QString::number(QRandomGenerator::global()->generate());
129     }
130 
131     static QString tempRedirectReplyStr() {
132         QString s = "HTTP/1.1 307 Temporary Redirect\r\n"
133                     "Content-Type: text/plain\r\n"
134                     "location: %1\r\n"
135                     "\r\n";
136         return s;
137     }
138 
139     static const QByteArray httpEmpty200Response;
140     static const QString filePermissionFileName;
141 
142     QEventLoop *loop;
143     enum RunSimpleRequestReturn { Timeout = 0, Success, Failure };
144     int returnCode;
145     QString testFileName;
146     QString echoProcessDir;
147 #if !defined Q_OS_WIN
148     QString wronlyFileName;
149 #endif
150     QString uniqueExtension;
151 #ifndef QT_NO_NETWORKPROXY
152     QList<ProxyData> proxies;
153 #endif
154     QNetworkAccessManager manager;
155     MyCookieJar *cookieJar;
156 #ifndef QT_NO_SSL
157     QSslConfiguration storedSslConfiguration;
158     QList<QSslError> storedExpectedSslErrors;
159     static const QString certsFilePath;
160 #endif
161 #ifndef QT_NO_BEARERMANAGEMENT
162     QNetworkConfigurationManager *netConfMan;
163     QNetworkConfiguration networkConfiguration;
164     QScopedPointer<QNetworkSession> networkSession;
165 #endif
166 
167     using QObject::connect;
168     static bool connect(const QNetworkReplyPtr &ptr, const char *signal, const QObject *receiver, const char *slot, Qt::ConnectionType ct = Qt::AutoConnection)
169     { return connect(ptr.data(), signal, receiver, slot, ct); }
170     bool connect(const QNetworkReplyPtr &ptr, const char *signal, const char *slot, Qt::ConnectionType ct = Qt::AutoConnection)
171     { return connect(ptr.data(), signal, slot, ct); }
172 
173 public:
174     tst_QNetworkReply();
175     ~tst_QNetworkReply();
176     QString runSimpleRequest(QNetworkAccessManager::Operation op, const QNetworkRequest &request,
177                              QNetworkReplyPtr &reply, const QByteArray &data = QByteArray());
178     QString runMultipartRequest(const QNetworkRequest &request, QNetworkReplyPtr &reply,
179                                     QHttpMultiPart *multiPart, const QByteArray &verb);
180 
181     QString runCustomRequest(const QNetworkRequest &request, QNetworkReplyPtr &reply,
182                              const QByteArray &verb, QIODevice *data);
183     int waitForFinish(QNetworkReplyPtr &reply);
184 
185 public Q_SLOTS:
186     void finished();
187     void gotError();
188     void authenticationRequired(QNetworkReply*,QAuthenticator*);
189     void proxyAuthenticationRequired(const QNetworkProxy &,QAuthenticator*);
190     void pipeliningHelperSlot();
191     void emitErrorForAllRepliesSlot();
192 
193 #ifndef QT_NO_SSL
194     void sslErrors(QNetworkReply*,const QList<QSslError> &);
195     void storeSslConfiguration();
196     void ignoreSslErrorListSlot(QNetworkReply *reply, const QList<QSslError> &);
197 #ifdef QT_BUILD_INTERNAL
198     void sslSessionSharingHelperSlot();
199 #endif
200 #endif
201 
202 protected Q_SLOTS:
203     void nestedEventLoops_slot();
204     void notEnoughData();
205 
206 private Q_SLOTS:
207     void cleanup() { cleanupTestData(); }
208     void initTestCase();
209     void cleanupTestCase();
210 
211     void stateChecking();
212     void invalidProtocol();
213     void getFromData_data();
214     void getFromData();
215     void getFromFile_data();
216     void getFromFile();
217     void getFromFileSpecial_data();
218     void getFromFileSpecial();
219     void getFromFtp_data();
220     void getFromFtp();
221     void getFromFtpAfterError();    // QTBUG-40797
222     void getFromHttp_data();
223     void getFromHttp();
224     void getErrors_data();
225     void getErrors();
226 #ifndef QT_NO_NETWORKPROXY
227     void headFromHttp_data();
228     void headFromHttp();
229 #endif // !QT_NO_NETWORKPROXY
230     void putToFile_data();
231     void putToFile();
232     void putToFtp_data();
233     void putToFtp();
234     void putToFtpWithInvalidCredentials();    // QTBUG-40622
235     void putToHttp_data();
236     void putToHttp();
237     void putToHttpSynchronous_data();
238     void putToHttpSynchronous();
239     void putToHttpMultipart_data();
240     void putToHttpMultipart();
241     void postToHttp_data();
242     void postToHttp();
243     void postToHttpSynchronous_data();
244     void postToHttpSynchronous();
245     void postToHttpMultipart_data();
246     void postToHttpMultipart();
247     void multipartSkipIndices(); // QTBUG-32534
248 #ifndef QT_NO_SSL
249     void putToHttps_data();
250     void putToHttps();
251     void putToHttpsSynchronous_data();
252     void putToHttpsSynchronous();
253     void postToHttps_data();
254     void postToHttps();
255     void postToHttpsSynchronous_data();
256     void postToHttpsSynchronous();
257     void postToHttpsMultipart_data();
258     void postToHttpsMultipart();
259 #endif
260     void deleteFromHttp_data();
261     void deleteFromHttp();
262     void putGetDeleteGetFromHttp_data();
263     void putGetDeleteGetFromHttp();
264     void sendCustomRequestToHttp_data();
265     void sendCustomRequestToHttp();
266     void connectToIPv6Address_data();
267     void connectToIPv6Address();
268 
269     void ioGetFromData_data();
270     void ioGetFromData();
271     void ioGetFromFileSpecial_data();
272     void ioGetFromFileSpecial();
273     void ioGetFromFile_data();
274     void ioGetFromFile();
275     void ioGetFromFtp_data();
276     void ioGetFromFtp();
277     void ioGetFromFtpWithReuse();
278     void ioGetFromHttp();
279 
280     void ioGetFromBuiltinHttp_data();
281     void ioGetFromBuiltinHttp();
282     void ioGetFromHttpWithReuseParallel();
283     void ioGetFromHttpWithReuseSequential();
284     void ioGetFromHttpWithAuth_data();
285     void ioGetFromHttpWithAuth();
286     void ioGetFromHttpWithAuthSynchronous();
287 #ifndef QT_NO_NETWORKPROXY
288     void ioGetFromHttpWithProxyAuth();
289     void ioGetFromHttpWithProxyAuthSynchronous();
290     void ioGetFromHttpWithSocksProxy();
291 #endif // !QT_NO_NETWORKPROXY
292 #ifndef QT_NO_SSL
293     void ioGetFromHttpsWithSslErrors();
294     void ioGetFromHttpsWithIgnoreSslErrors();
295     void ioGetFromHttpsWithSslHandshakeError();
296 #endif
297     void ioGetFromHttpBrokenServer_data();
298     void ioGetFromHttpBrokenServer();
299     void ioGetFromHttpStatus100_data();
300     void ioGetFromHttpStatus100();
301     void ioGetFromHttpNoHeaders_data();
302     void ioGetFromHttpNoHeaders();
303     void ioGetFromHttpWithCache_data();
304     void ioGetFromHttpWithCache();
305 
306 #ifndef QT_NO_NETWORKPROXY
307     void ioGetWithManyProxies_data();
308     void ioGetWithManyProxies();
309 #endif // !QT_NO_NETWORKPROXY
310 
311     void ioPutToFileFromFile_data();
312     void ioPutToFileFromFile();
313     void ioPutToFileFromSocket_data();
314     void ioPutToFileFromSocket();
315     void ioPutToFileFromLocalSocket_data();
316     void ioPutToFileFromLocalSocket();
317     void ioPutToFileFromProcess_data();
318     void ioPutToFileFromProcess();
319     void ioPutToFtpFromFile_data();
320     void ioPutToFtpFromFile();
321     void ioPutToHttpFromFile_data();
322     void ioPutToHttpFromFile();
323     void ioPostToHttpFromFile_data();
324     void ioPostToHttpFromFile();
325 #ifndef QT_NO_NETWORKPROXY
326     void ioPostToHttpFromSocket_data();
327     void ioPostToHttpFromSocket();
328     void ioPostToHttpFromSocketSynchronous();
329     void ioPostToHttpFromSocketSynchronous_data();
330 #endif // !QT_NO_NETWORKPROXY
331     void ioPostToHttpFromMiddleOfFileToEnd();
332     void ioPostToHttpFromMiddleOfFileFiveBytes();
333     void ioPostToHttpFromMiddleOfQBufferFiveBytes();
334     void ioPostToHttpNoBufferFlag();
335     void ioPostToHttpUploadProgress();
336     void emitAllUploadProgressSignals();
337     void ioPostToHttpEmptyUploadProgress();
338 
339     void lastModifiedHeaderForFile();
340     void lastModifiedHeaderForHttp();
341 
342     void httpCanReadLine();
343 
344 #ifdef QT_BUILD_INTERNAL
345     void rateControl_data();
346     void rateControl();
347 #endif
348 
349     void downloadProgress_data();
350     void downloadProgress();
351 #ifdef QT_BUILD_INTERNAL
352     void uploadProgress_data();
353     void uploadProgress();
354 #endif
355 
356     void chaining_data();
357     void chaining();
358 
359     void receiveCookiesFromHttp_data();
360     void receiveCookiesFromHttp();
361     void receiveCookiesFromHttpSynchronous_data();
362     void receiveCookiesFromHttpSynchronous();
363     void sendCookies_data();
364     void sendCookies();
365     void sendCookiesSynchronous_data();
366     void sendCookiesSynchronous();
367 
368     void nestedEventLoops();
369 
370 #ifndef QT_NO_NETWORKPROXY
371     void httpProxyCommands_data();
372     void httpProxyCommands();
373     void httpProxyCommandsSynchronous_data();
374     void httpProxyCommandsSynchronous();
375     void proxyChange();
376 #endif // !QT_NO_NETWORKPROXY
377     void authorizationError_data();
378     void authorizationError();
379 
380     void httpConnectionCount();
381 
382     void httpReUsingConnectionSequential_data();
383     void httpReUsingConnectionSequential();
384     void httpReUsingConnectionFromFinishedSlot_data();
385     void httpReUsingConnectionFromFinishedSlot();
386 
387     void httpRecursiveCreation();
388 
389 #ifndef QT_NO_SSL
390     void ioPostToHttpsUploadProgress();
391     void ignoreSslErrorsList_data();
392     void ignoreSslErrorsList();
393     void ignoreSslErrorsListWithSlot_data();
394     void ignoreSslErrorsListWithSlot();
395     void encrypted();
396     void sslConfiguration_data();
397     void sslConfiguration();
398 #ifdef QT_BUILD_INTERNAL
399     void sslSessionSharing_data();
400     void sslSessionSharing();
401     void sslSessionSharingFromPersistentSession_data();
402     void sslSessionSharingFromPersistentSession();
403 #endif
404 #endif
405 
406     void getAndThenDeleteObject_data();
407     void getAndThenDeleteObject();
408 
409     void symbianOpenCDataUrlCrash();
410 
411     void getFromHttpIntoBuffer_data();
412     void getFromHttpIntoBuffer();
413     void getFromHttpIntoBuffer2_data();
414     void getFromHttpIntoBuffer2();
415     void getFromHttpIntoBufferCanReadLine();
416 
417     void ioGetFromHttpWithoutContentLength();
418 
419     void ioGetFromHttpBrokenChunkedEncoding();
420     void qtbug12908compressedHttpReply();
421     void compressedHttpReplyBrokenGzip();
422 
423     void getFromUnreachableIp();
424 
425     void qtbug4121unknownAuthentication();
426 
427     void qtbug13431replyThrottling();
428 
429     void httpWithNoCredentialUsage();
430 
431     void qtbug15311doubleContentLength();
432 
433     void qtbug18232gzipContentLengthZero();
434     void qtbug22660gzipNoContentLengthEmptyContent();
435 
436     void qtbug27161httpHeaderMayBeDamaged_data();
437     void qtbug27161httpHeaderMayBeDamaged();
438 
439     void qtbug28035browserDoesNotLoadQtProjectOrgCorrectly();
440 
441     void qtbug45581WrongReplyStatusCode();
442 
443     void synchronousRequest_data();
444     void synchronousRequest();
445 #ifndef QT_NO_SSL
446     void synchronousRequestSslFailure();
447 #endif
448 
449     void httpAbort();
450 
451     void dontInsertPartialContentIntoTheCache();
452 
453     void httpUserAgent();
454 #ifndef QT_NO_NETWORKPROXY
455     void authenticationCacheAfterCancel_data();
456     void authenticationCacheAfterCancel();
457     void authenticationWithDifferentRealm();
458 #endif // !QT_NO_NETWORKPROXY
459     void synchronousAuthenticationCache();
460     void pipelining();
461 
462     void closeDuringDownload_data();
463     void closeDuringDownload();
464 
465     void ftpAuthentication_data();
466     void ftpAuthentication();
467 
468     void emitErrorForAllReplies(); // QTBUG-36890
469 
470 #ifdef QT_BUILD_INTERNAL
471     void backgroundRequest_data();
472     void backgroundRequest();
473     void backgroundRequestInterruption_data();
474     void backgroundRequestInterruption();
475     void backgroundRequestConnectInBackground_data();
476     void backgroundRequestConnectInBackground();
477 #endif
478 
479     void putWithRateLimiting();
480 
481     void ioHttpSingleRedirect();
482     void ioHttpChangeMaxRedirects();
483     void ioHttpRedirectErrors_data();
484     void ioHttpRedirectErrors();
485     void ioHttpRedirectPolicy_data();
486     void ioHttpRedirectPolicy();
487     void ioHttpRedirectPolicyErrors_data();
488     void ioHttpRedirectPolicyErrors();
489     void ioHttpUserVerifiedRedirect_data();
490     void ioHttpUserVerifiedRedirect();
491     void ioHttpCookiesDuringRedirect();
492     void ioHttpRedirect_data();
493     void ioHttpRedirect();
494     void ioHttpRedirectFromLocalToRemote();
495     void ioHttpRedirectPostPut_data();
496     void ioHttpRedirectPostPut();
497     void ioHttpRedirectMultipartPost_data();
498     void ioHttpRedirectMultipartPost();
499     void ioHttpRedirectDelete();
500     void ioHttpRedirectCustom();
501 #ifndef QT_NO_SSL
502     void putWithServerClosingConnectionImmediately();
503 #endif
504 
505     // NOTE: This test must be last!
506     void parentingRepliesToTheApp();
507 private:
508     void cleanupTestData();
509 
510     QString testDataDir;
511     bool notEnoughDataForFastSender;
512 };
513 
514 const QByteArray tst_QNetworkReply::httpEmpty200Response =
515                             "HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n";
516 const QString tst_QNetworkReply::filePermissionFileName = "/etc/shadow";
517 
518 bool tst_QNetworkReply::seedCreated = false;
519 
520 #define RUN_REQUEST(call)                       \
521     do {                                        \
522         QString errorMsg = call;                \
523         if (!errorMsg.isEmpty())                \
524             QFAIL(qPrintable(errorMsg));        \
525     } while (0)
526 
527 static bool validateRedirectedResponseHeaders(QNetworkReplyPtr reply)
528 {
529     // QTBUG-61300: previously we were mixing 'raw' headers from all responses
530     // along the redirect chain. The simplest test is to check/verify we have
531     // no 'location' header anymore.
532     Q_ASSERT(reply.data());
533 
534     return !reply->hasRawHeader("location")
535            && !reply->header(QNetworkRequest::LocationHeader).isValid();
536 }
537 
538 #ifndef QT_NO_SSL
539 static void setupSslServer(QSslSocket* serverSocket)
540 {
541     QString testDataDir = QFileInfo(QFINDTESTDATA("rfc3252.txt")).absolutePath();
542     if (testDataDir.isEmpty())
543         testDataDir = QCoreApplication::applicationDirPath();
544 
545     serverSocket->setProtocol(QSsl::AnyProtocol);
546     serverSocket->setLocalCertificate(testDataDir + "/certs/server.pem");
547     serverSocket->setPrivateKey(testDataDir + "/certs/server.key");
548     serverSocket->startServerEncryption();
549 }
550 
551 #ifdef QT_TEST_SERVER
552 const QString tst_QNetworkReply::certsFilePath = "/certs/qt-test-net-cacert.pem";
553 #else
554 const QString tst_QNetworkReply::certsFilePath = "/certs/qt-test-server-cacert.pem";
555 #endif
556 
557 #endif // !QT_NO_SSL
558 
559 // NOTE: MiniHttpServer has a very limited support of PUT/POST requests! Make
560 // sure you understand the server's code before PUTting/POSTing data (and
561 // probably you'll have to update the logic).
562 class MiniHttpServer: public QTcpServer
563 {
564     Q_OBJECT
565 public:
566     QPointer<QTcpSocket> client; // always the last one that was received
567     QByteArray dataToTransmit;
568     QByteArray receivedData;
569     QSemaphore ready;
570     bool doClose;
571     bool doSsl;
572     bool ipv6;
573     bool multiple;
574     int totalConnections;
575 
576     bool hasContent = false;
577     int contentRead = 0;
578     int contentLength = 0;
579 
580     MiniHttpServer(const QByteArray &data, bool ssl = false, QThread *thread = 0, bool useipv6 = false)
581         : dataToTransmit(data), doClose(true), doSsl(ssl), ipv6(useipv6),
582           multiple(false), totalConnections(0)
583     {
584         if (useipv6) {
585             if (!listen(QHostAddress::AnyIPv6))
586                 qWarning() << "listen() IPv6 failed" << errorString();
587         } else {
588             if (!listen(QHostAddress::AnyIPv4))
589                 qWarning() << "listen() IPv4 failed" << errorString();
590         }
591         if (thread) {
592             connect(thread, SIGNAL(started()), this, SLOT(threadStartedSlot()));
593             moveToThread(thread);
594             thread->start();
595             ready.acquire();
596         }
597     }
598 
599     void setDataToTransmit(const QByteArray &data)
600     {
601         dataToTransmit = data;
602     }
603 
604     void clearHeaderParserState()
605     {
606         contentLength = 0;
607         receivedData.clear();
608     }
609 
610 protected:
611     void incomingConnection(qintptr socketDescriptor)
612     {
613         //qDebug() << "incomingConnection" << socketDescriptor << "doSsl:" << doSsl << "ipv6:" << ipv6;
614 #ifndef QT_NO_SSL
615         if (doSsl) {
616             QSslSocket *serverSocket = new QSslSocket(this);
617             if (!serverSocket->setSocketDescriptor(socketDescriptor)) {
618                 delete serverSocket;
619                 return;
620             }
621             connect(serverSocket, SIGNAL(sslErrors(QList<QSslError>)), this, SLOT(slotSslErrors(QList<QSslError>)));
622             // connect(serverSocket, &QSslSocket::encrypted, this, &SslServer::ready); ?
623             setupSslServer(serverSocket);
624             client = serverSocket;
625         } else
626 #endif
627         {
628             client = new QTcpSocket;
629             client->setSocketDescriptor(socketDescriptor);
630         }
631         connectSocketSignals();
632         client->setParent(this);
633         ++totalConnections;
634     }
635 
636     virtual void reply()
637     {
638         Q_ASSERT(!client.isNull());
639         // we need to emulate the bytesWrittenSlot call if the data is empty.
640         if (dataToTransmit.size() == 0) {
641             emit client->bytesWritten(0);
642         } else {
643             client->write(dataToTransmit);
644             // FIXME: For SSL connections, if we don't flush the socket, the
645             // client never receives the data and since we're doing a disconnect
646             // immediately afterwards, it causes a RemoteHostClosedError for the
647             // client
648             client->flush();
649         }
650     }
651 private:
652     void connectSocketSignals()
653     {
654         Q_ASSERT(!client.isNull());
655         //qDebug() << "connectSocketSignals" << client;
656         connect(client.data(), SIGNAL(readyRead()), this, SLOT(readyReadSlot()));
657         connect(client.data(), SIGNAL(bytesWritten(qint64)), this, SLOT(bytesWrittenSlot()));
658         connect(client.data(), SIGNAL(error(QAbstractSocket::SocketError)),
659                 this, SLOT(slotError(QAbstractSocket::SocketError)));
660     }
661 
662     void parseContentLength()
663     {
664         int index = receivedData.indexOf("Content-Length:");
665         index += sizeof("Content-Length:") - 1;
666         const auto end = std::find(receivedData.cbegin() + index, receivedData.cend(), '\r');
667         auto num = receivedData.mid(index, std::distance(receivedData.cbegin() + index, end));
668         bool ok;
669         contentLength = num.toInt(&ok);
670         if (!ok)
671             contentLength = -1;
672     }
673 
674 private slots:
675 #ifndef QT_NO_SSL
676     void slotSslErrors(const QList<QSslError>& errors)
677     {
678         QTcpSocket *currentClient = qobject_cast<QTcpSocket *>(sender());
679         Q_ASSERT(currentClient);
680         qDebug() << "slotSslErrors" << currentClient->errorString() << errors;
681     }
682 #endif
683     void slotError(QAbstractSocket::SocketError err)
684     {
685         QTcpSocket *currentClient = qobject_cast<QTcpSocket *>(sender());
686         Q_ASSERT(currentClient);
687         qDebug() << "slotError" << err << currentClient->errorString();
688     }
689 
690 public slots:
691 
692     void readyReadSlot()
693     {
694         QTcpSocket *currentClient = qobject_cast<QTcpSocket *>(sender());
695         Q_ASSERT(currentClient);
696         if (currentClient != client)
697             client = currentClient;
698 
699         receivedData += client->readAll();
700         const int doubleEndlPos = receivedData.indexOf("\r\n\r\n");
701 
702         if (doubleEndlPos != -1) {
703             const int endOfHeader = doubleEndlPos + 4;
704             hasContent = receivedData.startsWith("POST") || receivedData.startsWith("PUT");
705             if (hasContent && contentLength == 0)
706                 parseContentLength();
707             contentRead = receivedData.length() - endOfHeader;
708             if (hasContent && contentRead < contentLength)
709                 return;
710 
711             // multiple requests incoming. remove the bytes of the current one
712             if (multiple)
713                 receivedData.remove(0, endOfHeader);
714 
715             reply();
716         }
717     }
718 
719     void bytesWrittenSlot()
720     {
721         Q_ASSERT(!client.isNull());
722         // Disconnect and delete in next cycle (else Windows clients will fail with RemoteHostClosedError).
723         if (doClose && client->bytesToWrite() == 0) {
724             disconnect(client, 0, this, 0);
725             client->deleteLater();
726         }
727     }
728 
729     void threadStartedSlot()
730     {
731         ready.release();
732     }
733 };
734 
735 class MyCookieJar: public QNetworkCookieJar
736 {
737 public:
738     inline QList<QNetworkCookie> allCookies() const
739         { return QNetworkCookieJar::allCookies(); }
740     inline void setAllCookies(const QList<QNetworkCookie> &cookieList)
741         { QNetworkCookieJar::setAllCookies(cookieList); }
742 };
743 
744 #ifndef QT_NO_NETWORKPROXY
745 class MyProxyFactory: public QNetworkProxyFactory
746 {
747 public:
748     int callCount;
749     QList<QNetworkProxy> toReturn;
750     QNetworkProxyQuery lastQuery;
751     inline MyProxyFactory() { clear(); }
752 
753     inline void clear()
754     {
755         callCount = 0;
756         toReturn = QList<QNetworkProxy>() << QNetworkProxy::DefaultProxy;
757         lastQuery = QNetworkProxyQuery();
758     }
759 
760     virtual QList<QNetworkProxy> queryProxy(const QNetworkProxyQuery &query)
761     {
762         lastQuery = query;
763         ++callCount;
764         return toReturn;
765     }
766 };
767 #endif // !QT_NO_NETWORKPROXY
768 
769 class MyMemoryCache: public QAbstractNetworkCache
770 {
771 public:
772     typedef QPair<QNetworkCacheMetaData, QByteArray> CachedContent;
773     typedef QHash<QByteArray, CachedContent> CacheData;
774     CacheData cache;
775 
776     MyMemoryCache(QObject *parent) : QAbstractNetworkCache(parent) {}
777 
778     QNetworkCacheMetaData metaData(const QUrl &url)
779     {
780         return cache.value(url.toEncoded()).first;
781     }
782 
783     void updateMetaData(const QNetworkCacheMetaData &metaData)
784     {
785         cache[metaData.url().toEncoded()].first = metaData;
786     }
787 
788     QIODevice *data(const QUrl &url)
789     {
790         CacheData::ConstIterator it = cache.find(url.toEncoded());
791         if (it == cache.constEnd())
792             return 0;
793         QBuffer *io = new QBuffer(this);
794         io->setData(it->second);
795         io->open(QIODevice::ReadOnly);
796         io->seek(0);
797         return io;
798     }
799 
800     bool remove(const QUrl &url)
801     {
802         cache.remove(url.toEncoded());
803         return true;
804     }
805 
806     qint64 cacheSize() const
807     {
808         qint64 total = 0;
809         foreach (const CachedContent &entry, cache)
810             total += entry.second.size();
811         return total;
812     }
813 
814     QIODevice *prepare(const QNetworkCacheMetaData &)
815     {
816         qFatal("%s: Should not have tried to add to the cache", Q_FUNC_INFO);
817         return 0;
818     }
819     void insert(QIODevice *)
820     {
821         qFatal("%s: Should not have tried to add to the cache", Q_FUNC_INFO);
822     }
823 
824     void clear() { cache.clear(); }
825 };
826 Q_DECLARE_METATYPE(MyMemoryCache::CachedContent)
827 Q_DECLARE_METATYPE(MyMemoryCache::CacheData)
828 
829 class MySpyMemoryCache: public QAbstractNetworkCache
830 {
831 public:
832     MySpyMemoryCache(QObject *parent) : QAbstractNetworkCache(parent) {}
833     ~MySpyMemoryCache()
834     {
835         qDeleteAll(m_buffers);
836         m_buffers.clear();
837     }
838 
839     QHash<QUrl, QIODevice*> m_buffers;
840     QList<QUrl> m_insertedUrls;
841 
842     QNetworkCacheMetaData metaData(const QUrl &)
843     {
844         return QNetworkCacheMetaData();
845     }
846 
847     void updateMetaData(const QNetworkCacheMetaData &)
848     {
849     }
850 
851     QIODevice *data(const QUrl &)
852     {
853         return 0;
854     }
855 
856     bool remove(const QUrl &url)
857     {
858         delete m_buffers.take(url);
859         return m_insertedUrls.removeAll(url) > 0;
860     }
861 
862     qint64 cacheSize() const
863     {
864         return 0;
865     }
866 
867     QIODevice *prepare(const QNetworkCacheMetaData &metaData)
868     {
869         QBuffer* buffer = new QBuffer;
870         buffer->open(QIODevice::ReadWrite);
871         buffer->setProperty("url", metaData.url());
872         m_buffers.insert(metaData.url(), buffer);
873         return buffer;
874     }
875 
876     void insert(QIODevice *buffer)
877     {
878         QUrl url = buffer->property("url").toUrl();
879         m_insertedUrls << url;
880         delete m_buffers.take(url);
881     }
882 
883     void clear() { m_insertedUrls.clear(); }
884 };
885 
886 class DataReader: public QObject
887 {
888     Q_OBJECT
889 public:
890     qint64 totalBytes;
891     QByteArray data;
892     QIODevice *device;
893     bool accumulate;
894     DataReader(const QNetworkReplyPtr &dev, bool acc = true) : totalBytes(0), device(dev.data()), accumulate(acc)
895     { connect(device, SIGNAL(readyRead()), SLOT(doRead()) ); }
896     DataReader(QIODevice *dev, bool acc = true) : totalBytes(0), device(dev), accumulate(acc)
897     {
898         connect(device, SIGNAL(readyRead()), SLOT(doRead()));
899     }
900 
901 public slots:
902     void doRead()
903     {
904         QByteArray buffer;
905         buffer.resize(device->bytesAvailable());
906         qint64 bytesRead = device->read(buffer.data(), device->bytesAvailable());
907         if (bytesRead == -1) {
908             QTestEventLoop::instance().exitLoop();
909             return;
910         }
911         buffer.truncate(bytesRead);
912         totalBytes += bytesRead;
913 
914         if (accumulate)
915             data += buffer;
916     }
917 };
918 
919 
920 class SocketPair: public QObject
921 {
922     Q_OBJECT
923 public:
924     QIODevice *endPoints[2];
925 
926     SocketPair(QObject *parent = 0)
927         : QObject(parent)
928     {
929         endPoints[0] = endPoints[1] = 0;
930     }
931 
932     bool create()
933     {
934         QTcpServer server;
935         server.listen();
936 
937         QTcpSocket *active = new QTcpSocket(this);
938         active->connectToHost("127.0.0.1", server.serverPort());
939 
940         // need more time as working with embedded
941         // device and testing from emualtor
942         // things tend to get slower
943         if (!active->waitForConnected(1000))
944             return false;
945 
946         if (!server.waitForNewConnection(1000))
947             return false;
948 
949         QTcpSocket *passive = server.nextPendingConnection();
950         passive->setParent(this);
951 
952         endPoints[0] = active;
953         endPoints[1] = passive;
954         return true;
955     }
956 };
957 
958 // A blocking tcp server (must be used in a thread) which supports SSL.
959 class BlockingTcpServer : public QTcpServer
960 {
961     Q_OBJECT
962 public:
963     BlockingTcpServer(bool ssl) : doSsl(ssl), sslSocket(0) {}
964 
965     QTcpSocket* waitForNextConnectionSocket()
966     {
967         waitForNewConnection(-1);
968         if (doSsl) {
969             if (!sslSocket)
970                 qFatal("%s: sslSocket should not be null after calling waitForNewConnection()",
971                        Q_FUNC_INFO);
972             return sslSocket;
973         } else {
974             //qDebug() << "returning nextPendingConnection";
975             return nextPendingConnection();
976         }
977     }
978     virtual void incomingConnection(qintptr socketDescriptor)
979     {
980 #ifndef QT_NO_SSL
981         if (doSsl) {
982             QSslSocket *serverSocket = new QSslSocket;
983             serverSocket->setParent(this);
984             serverSocket->setSocketDescriptor(socketDescriptor);
985             connect(serverSocket, SIGNAL(sslErrors(QList<QSslError>)), this, SLOT(slotSslErrors(QList<QSslError>)));
986             setupSslServer(serverSocket);
987             sslSocket = serverSocket;
988         } else
989 #endif
990         {
991             QTcpServer::incomingConnection(socketDescriptor);
992         }
993     }
994 private slots:
995 
996 #ifndef QT_NO_SSL
997     void slotSslErrors(const QList<QSslError>& errors)
998     {
999         qDebug() << "slotSslErrors" << sslSocket->errorString() << errors;
1000     }
1001 #endif
1002 
1003 private:
1004     const bool doSsl;
1005     QTcpSocket* sslSocket;
1006 };
1007 
1008 // This server tries to send data as fast as possible (like most servers)
1009 // but it measures how fast it was able to send it, which shows at which
1010 // rate the reader is processing the data.
1011 class FastSender: public QThread
1012 {
1013     Q_OBJECT
1014     QSemaphore ready;
1015     qint64 wantedSize;
1016     int port;
1017     enum Protocol { DebugPipe, ProvidedData };
1018     const Protocol protocol;
1019     const bool doSsl;
1020     const bool fillKernelBuffer;
1021 public:
1022     int transferRate;
1023     QWaitCondition cond;
1024 
1025     QByteArray dataToTransmit;
1026     int dataIndex;
1027 
1028     // a server that sends debugpipe data
1029     FastSender(qint64 size)
1030         : wantedSize(size), port(-1), protocol(DebugPipe),
1031           doSsl(false), fillKernelBuffer(true), transferRate(-1),
1032           dataIndex(0)
1033     {
1034         start();
1035         ready.acquire();
1036     }
1037 
1038     // a server that sends the data provided at construction time, useful for HTTP
1039     FastSender(const QByteArray& data, bool https, bool fillBuffer, tst_QNetworkReply *listener = 0)
1040         : wantedSize(data.size()), port(-1), protocol(ProvidedData),
1041           doSsl(https), fillKernelBuffer(fillBuffer), transferRate(-1),
1042           dataToTransmit(data), dataIndex(0)
1043     {
1044         if (listener)
1045             connect(this, SIGNAL(notEnoughData()), listener, SLOT(notEnoughData()));
1046         start();
1047         ready.acquire();
1048     }
1049 
1050     inline int serverPort() const { return port; }
1051 
1052     int writeNextData(QTcpSocket* socket, qint32 size)
1053     {
1054         if (protocol == DebugPipe) {
1055             QByteArray data;
1056             QDataStream stream(&data, QIODevice::WriteOnly);
1057             stream << QVariantMap() << QByteArray(size, 'a');
1058             socket->write((char*)&size, sizeof size);
1059             socket->write(data);
1060             dataIndex += size;
1061             return size;
1062         } else {
1063             const QByteArray data = dataToTransmit.mid(dataIndex, size);
1064             socket->write(data);
1065             dataIndex += data.size();
1066             //qDebug() << "wrote" << dataIndex << "/" << dataToTransmit.size();
1067             return data.size();
1068         }
1069     }
1070     void writeLastData(QTcpSocket* socket)
1071     {
1072         if (protocol == DebugPipe) {
1073             QByteArray data;
1074             QDataStream stream(&data, QIODevice::WriteOnly);
1075             stream << QVariantMap() << QByteArray();
1076             const qint32 size = data.size();
1077             socket->write((char*)&size, sizeof size);
1078             socket->write(data);
1079         }
1080     }
1081 
1082 protected:
1083     void run()
1084     {
1085         BlockingTcpServer server(doSsl);
1086         server.listen();
1087         port = server.serverPort();
1088         ready.release();
1089 
1090         QTcpSocket *client = server.waitForNextConnectionSocket();
1091 
1092         // get the "request" packet
1093         if (!client->waitForReadyRead(2000)) {
1094             qDebug() << "FastSender:" << client->error() << "waiting for \"request\" packet";
1095             return;
1096         }
1097         client->readAll();      // we're not interested in the actual contents (e.g. HTTP request)
1098 
1099         enum { BlockSize = 1024 };
1100 
1101         if (fillKernelBuffer) {
1102 
1103             // write a bunch of bytes to fill up the buffers
1104             bool done = false;
1105             do {
1106                 if (writeNextData(client, BlockSize) < BlockSize) {
1107                     qDebug() << "ERROR: FastSender: not enough data to write in order to fill buffers; or client is reading too fast";
1108                     emit notEnoughData();
1109                     return;
1110                 }
1111                 while (client->bytesToWrite() > 0) {
1112                     if (!client->waitForBytesWritten(0)) {
1113                         done = true;
1114                         break;
1115                     }
1116                 }
1117                 //qDebug() << "Filling kernel buffer: wrote" << dataIndex << "bytes";
1118             } while (!done);
1119 
1120             qDebug() << "FastSender: ok, kernel buffer is full after writing" << dataIndex << "bytes";
1121         }
1122 
1123         // Tell the client to start reading
1124         emit dataReady();
1125 
1126         // the kernel buffer is full
1127         // clean up QAbstractSocket's residue:
1128         while (client->bytesToWrite() > 0) {
1129             qDebug() << "Still having" << client->bytesToWrite() << "bytes to write, doing that now";
1130             if (!client->waitForBytesWritten(10000)) {
1131                 qDebug() << "ERROR: FastSender:" << client->error() << "cleaning up residue";
1132                 return;
1133             }
1134         }
1135 
1136         // now write in "blocking mode", this is where the rate measuring starts
1137         QTime timer;
1138         timer.start();
1139         //const qint64 writtenBefore = dataIndex;
1140         //qint64 measuredTotalBytes = wantedSize - writtenBefore;
1141         qint64 measuredSentBytes = 0;
1142         while (dataIndex < wantedSize) {
1143             const int remainingBytes = wantedSize - measuredSentBytes;
1144             const int bytesToWrite = qMin(remainingBytes, static_cast<int>(BlockSize));
1145             if (bytesToWrite <= 0)
1146                 qFatal("%s: attempt to write %d bytes", Q_FUNC_INFO, bytesToWrite);
1147             measuredSentBytes += writeNextData(client, bytesToWrite);
1148 
1149             while (client->bytesToWrite() > 0) {
1150                 if (!client->waitForBytesWritten(10000)) {
1151                     qDebug() << "ERROR: FastSender:" << client->error() << "during blocking write";
1152                     return;
1153                 }
1154             }
1155             /*qDebug() << "FastSender:" << bytesToWrite << "bytes written now;"
1156                      << measuredSentBytes << "measured bytes" << measuredSentBytes + writtenBefore << "total ("
1157                      << measuredSentBytes*100/measuredTotalBytes << "% complete);"
1158                      << timer.elapsed() << "ms elapsed";*/
1159         }
1160 
1161         transferRate = measuredSentBytes * 1000 / timer.elapsed();
1162         qDebug() << "FastSender: flushed" << measuredSentBytes << "bytes in" << timer.elapsed() << "ms: rate =" << transferRate << "B/s";
1163 
1164         // write a "close connection" packet, if the protocol needs it
1165         writeLastData(client);
1166     }
1167 signals:
1168     void dataReady();
1169     void notEnoughData();
1170 };
1171 
1172 class RateControlledReader: public QObject
1173 {
1174     Q_OBJECT
1175     QIODevice *device;
1176     int bytesToRead;
1177     int interval;
1178     int readBufferSize;
1179 public:
1180     QByteArray data;
1181     qint64 totalBytesRead;
1182     RateControlledReader(QObject& senderObj, QIODevice *dev, int kbPerSec, int maxBufferSize = 0)
1183         : device(dev), readBufferSize(maxBufferSize), totalBytesRead(0)
1184     {
1185         // determine how often we have to wake up
1186         int timesPerSecond;
1187         if (readBufferSize == 0) {
1188             // The requirement is simply "N KB per seconds"
1189             timesPerSecond = 20;
1190             bytesToRead = kbPerSec * 1024 / timesPerSecond;
1191         } else {
1192             // The requirement also includes "<readBufferSize> bytes at a time"
1193             bytesToRead = readBufferSize;
1194             timesPerSecond = kbPerSec * 1024 / readBufferSize;
1195         }
1196         interval = 1000 / timesPerSecond; // in ms
1197 
1198         qDebug() << "RateControlledReader: going to read" << bytesToRead
1199                  << "bytes every" << interval << "ms";
1200         qDebug() << "actual read rate will be"
1201                  << (bytesToRead * 1000 / interval) << "bytes/sec (wanted"
1202                  << kbPerSec * 1024 << "bytes/sec)";
1203 
1204         // Wait for data to be readyRead
1205         bool ok = connect(&senderObj, SIGNAL(dataReady()), this, SLOT(slotDataReady()));
1206         if (!ok)
1207             qFatal("%s: Cannot connect dataReady signal", Q_FUNC_INFO);
1208     }
1209 
1210     void wrapUp()
1211     {
1212         QByteArray someData = device->read(device->bytesAvailable());
1213         data += someData;
1214         totalBytesRead += someData.size();
1215         qDebug() << "wrapUp: found" << someData.size() << "bytes left. progress" << data.size();
1216         //qDebug() << "wrapUp: now bytesAvailable=" << device->bytesAvailable();
1217     }
1218 
1219 private slots:
1220     void slotDataReady()
1221     {
1222         //qDebug() << "RateControlledReader: ready to go";
1223         startTimer(interval);
1224     }
1225 
1226 protected:
1227     void timerEvent(QTimerEvent *)
1228     {
1229         //qDebug() << "RateControlledReader: timerEvent bytesAvailable=" << device->bytesAvailable();
1230         if (readBufferSize > 0 && device->bytesAvailable() > readBufferSize) {
1231             // This passes all the time, except in the final flush.
1232             //qFatal("%s: Too many bytes available", Q_FUNC_INFO);
1233         }
1234 
1235         qint64 bytesRead = 0;
1236         QTime stopWatch;
1237         stopWatch.start();
1238         do {
1239             if (device->bytesAvailable() == 0) {
1240                 if (stopWatch.elapsed() > 20) {
1241                     qDebug() << "RateControlledReader: Not enough data available for reading, waited too much, timing out";
1242                     break;
1243                 }
1244                 if (!device->waitForReadyRead(5)) {
1245                     qDebug() << "RateControlledReader: Not enough data available for reading, even after waiting 5ms, bailing out";
1246                     break;
1247                 }
1248             }
1249             QByteArray someData = device->read(bytesToRead - bytesRead);
1250             data += someData;
1251             bytesRead += someData.size();
1252             //qDebug() << "RateControlledReader: successfully read" << someData.size() << "progress:" << data.size();
1253         } while (bytesRead < bytesToRead);
1254         totalBytesRead += bytesRead;
1255 
1256         if (bytesRead < bytesToRead)
1257             qWarning() << "RateControlledReader: WARNING:" << bytesToRead - bytesRead << "bytes not read";
1258     }
1259 };
1260 
1261 
1262 tst_QNetworkReply::tst_QNetworkReply()
1263 {
1264     qRegisterMetaType<QNetworkReply *>(); // for QSignalSpy
1265     qRegisterMetaType<QAuthenticator *>();
1266 #ifndef QT_NO_NETWORKPROXY
1267     qRegisterMetaType<QNetworkProxy>();
1268 #endif
1269 #ifndef QT_NO_SSL
1270     qRegisterMetaType<QList<QSslError> >();
1271 #endif
1272     qRegisterMetaType<QNetworkReply::NetworkError>();
1273 
1274     uniqueExtension = createUniqueExtension();
1275     testFileName = QDir::currentPath() + "/testfile" + uniqueExtension;
1276     cookieJar = new MyCookieJar;
1277     manager.setCookieJar(cookieJar);
1278 
1279 #ifndef QT_NO_NETWORKPROXY
1280     QHostInfo hostInfo = QHostInfo::fromName(QtNetworkSettings::serverName());
1281 
1282     proxies << ProxyData(QNetworkProxy::NoProxy, "", false);
1283 
1284     if (hostInfo.error() == QHostInfo::NoError && !hostInfo.addresses().isEmpty()) {
1285         QString proxyserver = hostInfo.addresses().first().toString();
1286         proxies << ProxyData(QNetworkProxy(QNetworkProxy::HttpProxy, proxyserver, 3128), "+proxy", false)
1287                 << ProxyData(QNetworkProxy(QNetworkProxy::HttpProxy, proxyserver, 3129), "+proxyauth", true)
1288                 // currently unsupported
1289                 // << ProxyData(QNetworkProxy(QNetworkProxy::HttpProxy, proxyserver, 3130), "+proxyauth-ntlm", true);
1290 #ifdef QT_TEST_SERVER
1291                 << ProxyData(QNetworkProxy(QNetworkProxy::Socks5Proxy, proxyserver, 1082),
1292                              "+socks", false)
1293                 << ProxyData(QNetworkProxy(QNetworkProxy::Socks5Proxy, proxyserver, 1083),
1294                              "+socksauth", true);
1295 #else
1296                 << ProxyData(QNetworkProxy(QNetworkProxy::Socks5Proxy, proxyserver, 1080),
1297                              "+socks", false)
1298                 << ProxyData(QNetworkProxy(QNetworkProxy::Socks5Proxy, proxyserver, 1081),
1299                              "+socksauth", true);
1300 #endif
1301     } else {
1302 #endif // !QT_NO_NETWORKPROXY
1303         printf("==================================================================\n");
1304         printf("Proxy could not be looked up. No proxy will be used while testing!\n");
1305         printf("==================================================================\n");
1306 #ifndef QT_NO_NETWORKPROXY
1307     }
1308 #endif // !QT_NO_NETWORKPROXY
1309 }
1310 
1311 tst_QNetworkReply::~tst_QNetworkReply()
1312 {
1313 }
1314 
1315 
1316 void tst_QNetworkReply::authenticationRequired(QNetworkReply*, QAuthenticator* auth)
1317 {
1318     auth->setUser("httptest");
1319     auth->setPassword("httptest");
1320 }
1321 
1322 void tst_QNetworkReply::proxyAuthenticationRequired(const QNetworkProxy &, QAuthenticator* auth)
1323 {
1324     auth->setUser("qsockstest");
1325     auth->setPassword("password");
1326 }
1327 
1328 #ifndef QT_NO_SSL
1329 void tst_QNetworkReply::sslErrors(QNetworkReply *reply, const QList<QSslError> &errors)
1330 {
1331     reply->ignoreSslErrors();
1332     QVERIFY(!errors.isEmpty());
1333     QVERIFY(!reply->sslConfiguration().isNull());
1334 }
1335 
1336 void tst_QNetworkReply::storeSslConfiguration()
1337 {
1338     storedSslConfiguration = QSslConfiguration();
1339     QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
1340     if (reply)
1341         storedSslConfiguration = reply->sslConfiguration();
1342 }
1343 #endif
1344 
1345 QString tst_QNetworkReply::runMultipartRequest(const QNetworkRequest &request,
1346                                                    QNetworkReplyPtr &reply,
1347                                                    QHttpMultiPart *multiPart,
1348                                                    const QByteArray &verb)
1349 {
1350     if (verb == "POST")
1351         reply.reset(manager.post(request, multiPart));
1352     else
1353         reply.reset(manager.put(request, multiPart));
1354 
1355     // the code below is copied from tst_QNetworkReply::runSimpleRequest, see below
1356     reply->setParent(this);
1357     connect(reply, SIGNAL(finished()), SLOT(finished()));
1358     connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), SLOT(gotError()));
1359     multiPart->setParent(reply.data());
1360 
1361     returnCode = Timeout;
1362     loop = new QEventLoop;
1363     QTimer::singleShot(25000, loop, SLOT(quit()));
1364     int code = returnCode == Timeout ? loop->exec() : returnCode;
1365     delete loop;
1366     loop = 0;
1367 
1368     switch (code) {
1369     case Failure:
1370         return "Request failed: " + reply->errorString();
1371     case Timeout:
1372         return "Network timeout";
1373     }
1374     return QString();
1375 }
1376 
1377 QString tst_QNetworkReply::runSimpleRequest(QNetworkAccessManager::Operation op,
1378                                             const QNetworkRequest &request,
1379                                             QNetworkReplyPtr &reply,
1380                                             const QByteArray &data)
1381 {
1382     switch (op) {
1383     case QNetworkAccessManager::HeadOperation:
1384         reply.reset(manager.head(request));
1385         break;
1386 
1387     case QNetworkAccessManager::GetOperation:
1388         reply.reset(manager.get(request));
1389         break;
1390 
1391     case QNetworkAccessManager::PutOperation:
1392         reply.reset(manager.put(request, data));
1393         break;
1394 
1395     case QNetworkAccessManager::PostOperation:
1396         reply.reset(manager.post(request, data));
1397         break;
1398 
1399     case QNetworkAccessManager::DeleteOperation:
1400         reply.reset(manager.deleteResource(request));
1401         break;
1402 
1403     default:
1404         qFatal("%s: Invalid/unknown operation requested", Q_FUNC_INFO);
1405     }
1406     reply->setParent(this);
1407 
1408     returnCode = Timeout;
1409     int code = Success;
1410 
1411     if (request.attribute(QNetworkRequest::SynchronousRequestAttribute).toBool()) {
1412         if (reply->isFinished())
1413             code = reply->error() != QNetworkReply::NoError ? Failure : Success;
1414         else
1415             code = Failure;
1416     } else {
1417         connect(reply, SIGNAL(finished()), SLOT(finished()));
1418         connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), SLOT(gotError()));
1419 
1420         int count = 0;
1421         loop = new QEventLoop;
1422         QSignalSpy spy(reply.data(), SIGNAL(downloadProgress(qint64,qint64)));
1423         while (!reply->isFinished()) {
1424             QTimer::singleShot(20000, loop, SLOT(quit()));
1425             code = loop->exec();
1426             if (count == spy.count() && !reply->isFinished()) {
1427                 code = Timeout;
1428                 break;
1429             }
1430             count = spy.count();
1431         }
1432         delete loop;
1433         loop = 0;
1434     }
1435 
1436     switch (code) {
1437     case Failure:
1438         return "Request failed: " + reply->errorString();
1439     case Timeout:
1440         return "Network timeout";
1441     }
1442     return QString();
1443 }
1444 
1445 QString tst_QNetworkReply::runCustomRequest(const QNetworkRequest &request,
1446                                             QNetworkReplyPtr &reply,
1447                                             const QByteArray &verb,
1448                                             QIODevice *data)
1449 {
1450     reply.reset(manager.sendCustomRequest(request, verb, data));
1451     reply->setParent(this);
1452     connect(reply, SIGNAL(finished()), SLOT(finished()));
1453     connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), SLOT(gotError()));
1454 
1455     returnCode = Timeout;
1456     loop = new QEventLoop;
1457     QTimer::singleShot(20000, loop, SLOT(quit()));
1458     int code = returnCode == Timeout ? loop->exec() : returnCode;
1459     delete loop;
1460     loop = 0;
1461 
1462     switch (code) {
1463     case Failure:
1464         return "Request failed: " + reply->errorString();
1465     case Timeout:
1466         return "Network timeout";
1467     }
1468     return QString();
1469 }
1470 
1471 static QByteArray msgWaitForFinished(QNetworkReplyPtr &reply)
1472 {
1473     QString result;
1474     QDebug debug(&result);
1475     debug << reply->url();
1476     if (!reply->isFinished())
1477         debug << "timed out.";
1478     else if (reply->error() == QNetworkReply::NoError)
1479         debug << "finished.";
1480     else
1481         debug << "failed: #" << reply->error() << reply->errorString();
1482     return result.toLocal8Bit();
1483 }
1484 
1485 int tst_QNetworkReply::waitForFinish(QNetworkReplyPtr &reply)
1486 {
1487     int count = 0;
1488 
1489     connect(reply, SIGNAL(finished()), SLOT(finished()));
1490     connect(reply, SIGNAL(error(QNetworkReply::NetworkError)), SLOT(gotError()));
1491     returnCode = Success;
1492     loop = new QEventLoop;
1493     QSignalSpy spy(reply.data(), SIGNAL(downloadProgress(qint64,qint64)));
1494     while (!reply->isFinished()) {
1495         QTimer::singleShot(5000, loop, SLOT(quit()));
1496         if (loop->exec() == Timeout && count == spy.count() && !reply->isFinished()) {
1497             returnCode = Timeout;
1498             break;
1499         }
1500         count = spy.count();
1501     }
1502     delete loop;
1503     loop = 0;
1504 
1505     return returnCode;
1506 }
1507 
1508 void tst_QNetworkReply::finished()
1509 {
1510     if (loop)
1511         loop->exit(returnCode = Success);
1512 }
1513 
1514 void tst_QNetworkReply::gotError()
1515 {
1516     if (loop)
1517         loop->exit(returnCode = Failure);
1518     disconnect(QObject::sender(), SIGNAL(finished()), this, 0);
1519 }
1520 
1521 void tst_QNetworkReply::initTestCase()
1522 {
1523     testDataDir = QFileInfo(QFINDTESTDATA("rfc3252.txt")).absolutePath();
1524     if (testDataDir.isEmpty())
1525         testDataDir = QCoreApplication::applicationDirPath();
1526 
1527     if (!QtNetworkSettings::verifyTestNetworkSettings())
1528         QSKIP("No network test server available");
1529 #if !defined Q_OS_WIN
1530     wronlyFileName = testDataDir + "/write-only" + uniqueExtension;
1531     QFile wr(wronlyFileName);
1532     QVERIFY(wr.open(QIODevice::WriteOnly | QIODevice::Truncate));
1533     wr.setPermissions(QFile::WriteOwner | QFile::WriteUser);
1534     wr.close();
1535 #endif
1536 
1537     QDir::setSearchPaths("testdata", QStringList() << testDataDir);
1538 #ifndef QT_NO_SSL
1539     QSslSocket::defaultCaCertificates(); //preload certificates
1540 #endif
1541 #ifndef QT_NO_BEARERMANAGEMENT
1542     netConfMan = new QNetworkConfigurationManager(this);
1543     networkConfiguration = netConfMan->defaultConfiguration();
1544     networkSession.reset(new QNetworkSession(networkConfiguration));
1545     if (!networkSession->isOpen()) {
1546         networkSession->open();
1547         QVERIFY(networkSession->waitForOpened(30000));
1548     }
1549 #endif
1550 
1551     echoProcessDir = QFINDTESTDATA("echo");
1552     QVERIFY2(!echoProcessDir.isEmpty(), qPrintable(
1553         QString::fromLatin1("Couldn't find echo dir starting from %1.").arg(QDir::currentPath())));
1554 
1555     cleanupTestData();
1556 }
1557 
1558 void tst_QNetworkReply::cleanupTestCase()
1559 {
1560 #if !defined Q_OS_WIN
1561     if (!wronlyFileName.isNull())
1562         QFile::remove(wronlyFileName);
1563 #endif
1564 #ifndef QT_NO_BEARERMANAGEMENT
1565     if (networkSession && networkSession->isOpen()) {
1566         networkSession->close();
1567     }
1568 #endif
1569 }
1570 
1571 void tst_QNetworkReply::cleanupTestData()
1572 {
1573     QFile file(testFileName);
1574     QVERIFY(!file.exists() || file.remove());
1575 
1576     // clear the internal cache
1577     manager.clearAccessCache();
1578 #ifndef QT_NO_NETWORKPROXY
1579     manager.setProxy(QNetworkProxy());
1580 #endif
1581     manager.setCache(0);
1582 
1583     // clear cookies
1584     cookieJar->setAllCookies(QList<QNetworkCookie>());
1585 
1586     // disconnect manager signals
1587 #ifndef QT_NO_SSL
1588     manager.disconnect(SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)));
1589 #endif
1590     manager.disconnect(SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
1591     manager.disconnect(SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
1592 }
1593 
1594 void tst_QNetworkReply::stateChecking()
1595 {
1596     QUrl url = QUrl("file:///");
1597     QNetworkRequest req(url);   // you can't open this file, I know
1598     QNetworkReplyPtr reply(manager.get(req));
1599 
1600     QVERIFY(reply.data());
1601     QVERIFY(reply->isOpen());
1602     QVERIFY(reply->isReadable());
1603     QVERIFY(!reply->isWritable());
1604 
1605     // both behaviours are OK since we might change underlying behaviour again
1606     if (!reply->isFinished())
1607         QCOMPARE(reply->errorString(), QString("Unknown error"));
1608     else
1609         QVERIFY(!reply->errorString().isEmpty());
1610 
1611 
1612     QCOMPARE(reply->manager(), &manager);
1613     QCOMPARE(reply->request(), req);
1614     QCOMPARE(int(reply->operation()), int(QNetworkAccessManager::GetOperation));
1615     // error and not error are OK since we might change underlying behaviour again
1616     if (!reply->isFinished())
1617         QCOMPARE(reply->error(), QNetworkReply::NoError);
1618     QCOMPARE(reply->url(), url);
1619 
1620     reply->abort();
1621 }
1622 
1623 void tst_QNetworkReply::invalidProtocol()
1624 {
1625     QUrl url = QUrl::fromEncoded("not-a-known-protocol://foo/bar");
1626     QNetworkRequest req(url);
1627     QNetworkReplyPtr reply;
1628 
1629     QString errorMsg = "Request failed: Protocol \"not-a-known-protocol\" is unknown";
1630     QString result = runSimpleRequest(QNetworkAccessManager::GetOperation, req, reply);
1631     QCOMPARE(result, errorMsg);
1632 
1633     QCOMPARE(reply->url(), url);
1634     QCOMPARE(reply->error(), QNetworkReply::ProtocolUnknownError);
1635 }
1636 
1637 void tst_QNetworkReply::getFromData_data()
1638 {
1639     QTest::addColumn<QString>("request");
1640     QTest::addColumn<QByteArray>("expected");
1641     QTest::addColumn<QString>("mimeType");
1642 
1643     const QString defaultMimeType("text/plain;charset=US-ASCII");
1644 
1645     //QTest::newRow("empty") << "data:" << QByteArray() << defaultMimeType;
1646     QTest::newRow("empty2") << "data:," << QByteArray() << defaultMimeType;
1647     QTest::newRow("just-charset_1") << "data:charset=iso-8859-1,"
1648                                     << QByteArray() << "text/plain;charset=iso-8859-1";
1649     QTest::newRow("just-charset_2") << "data:charset = iso-8859-1 ,"
1650                                     << QByteArray() << "text/plain;charset = iso-8859-1";
1651     //QTest::newRow("just-media") << "data:text/xml" << QByteArray() << "text/xml";
1652     QTest::newRow("just-media2") << "data:text/xml," << QByteArray() << "text/xml";
1653 
1654     QTest::newRow("plain_1") << "data:,foo" << QByteArray("foo") << defaultMimeType;
1655     QTest::newRow("plain_2") << "data:text/html,Hello World" << QByteArray("Hello World")
1656                              << "text/html";
1657     QTest::newRow("plain_3") << "data:text/html;charset=utf-8,Hello World"
1658                              << QByteArray("Hello World") << "text/html;charset=utf-8";
1659 
1660     QTest::newRow("pct_1") << "data:,%3Cbody%20contentEditable%3Dtrue%3E%0D%0A"
1661                            << QByteArray("<body contentEditable=true>\r\n") << defaultMimeType;
1662     QTest::newRow("pct_2") << "data:text/html;charset=utf-8,%3Cbody%20contentEditable%3Dtrue%3E%0D%0A"
1663                            << QByteArray("<body contentEditable=true>\r\n")
1664                            << "text/html;charset=utf-8";
1665 
1666     QTest::newRow("base64-empty_1") << "data:;base64," << QByteArray() << defaultMimeType;
1667     QTest::newRow("base64-empty_2") << "data:charset=utf-8;base64," << QByteArray()
1668                                     << "text/plain;charset=utf-8";
1669     QTest::newRow("base64-empty_3") << "data:text/html;charset=utf-8;base64,"
1670                                     << QByteArray() << "text/html;charset=utf-8";
1671 
1672     QTest::newRow("base64_1") << "data:;base64,UXQgaXMgZ3JlYXQh" << QByteArray("Qt is great!")
1673                               << defaultMimeType;
1674     QTest::newRow("base64_2") << "data:charset=utf-8;base64,UXQgaXMgZ3JlYXQh"
1675                               << QByteArray("Qt is great!") << "text/plain;charset=utf-8";
1676     QTest::newRow("base64_3") << "data:text/html;charset=utf-8;base64,UXQgaXMgZ3JlYXQh"
1677                               << QByteArray("Qt is great!") << "text/html;charset=utf-8";
1678 
1679     QTest::newRow("pct-nul") << "data:,a%00g" << QByteArray("a\0g", 3) << defaultMimeType;
1680     QTest::newRow("base64-nul") << "data:;base64,YQBn" << QByteArray("a\0g", 3) << defaultMimeType;
1681     QTest::newRow("pct-nonutf8") << "data:,a%E1g" << QByteArray("a\xE1g", 3) << defaultMimeType;
1682 
1683     QTest::newRow("base64")
1684         << QString::fromLatin1("data:application/xml;base64,PGUvPg==")
1685         << QByteArray("<e/>")
1686         << "application/xml";
1687 
1688     QTest::newRow("base64, no media type")
1689         << QString::fromLatin1("data:;base64,PGUvPg==")
1690         << QByteArray("<e/>")
1691         << defaultMimeType;
1692 
1693     QTest::newRow("Percent encoding")
1694         << QString::fromLatin1("data:application/xml,%3Ce%2F%3E")
1695         << QByteArray("<e/>")
1696         << "application/xml";
1697 
1698     QTest::newRow("Percent encoding, no media type")
1699         << QString::fromLatin1("data:,%3Ce%2F%3E")
1700         << QByteArray("<e/>")
1701         << defaultMimeType;
1702 
1703     QTest::newRow("querychars")
1704         << QString::fromLatin1("data:,foo?x=0&y=0")
1705         << QByteArray("foo?x=0&y=0")
1706         << defaultMimeType;
1707 
1708     QTest::newRow("css") << "data:text/css,div%20{%20border-right:%20solid;%20}"
1709                          << QByteArray("div { border-right: solid; }")
1710                          << "text/css";
1711 }
1712 
1713 void tst_QNetworkReply::getFromData()
1714 {
1715     QFETCH(QString, request);
1716     QFETCH(QByteArray, expected);
1717     QFETCH(QString, mimeType);
1718 
1719     QUrl url = QUrl::fromEncoded(request.toLatin1());
1720     QNetworkRequest req(url);
1721     QNetworkReplyPtr reply;
1722 
1723     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, req, reply));
1724 
1725     QCOMPARE(reply->url(), url);
1726     QCOMPARE(reply->error(), QNetworkReply::NoError);
1727 
1728     QCOMPARE(reply->header(QNetworkRequest::ContentTypeHeader).toString(), mimeType);
1729     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), qint64(expected.size()));
1730     QCOMPARE(reply->readAll(), expected);
1731 }
1732 
1733 void tst_QNetworkReply::getFromFile_data()
1734 {
1735     QTest::addColumn<bool>("backgroundAttribute");
1736 
1737     QTest::newRow("no-background-attribute") << false;
1738     QTest::newRow("background-attribute") << true;
1739 }
1740 
1741 void tst_QNetworkReply::getFromFile()
1742 {
1743     QFETCH(bool, backgroundAttribute);
1744 
1745     // create the file:
1746     QTemporaryFile file(QDir::currentPath() + "/temp-XXXXXX");
1747     file.setAutoRemove(true);
1748     QVERIFY2(file.open(), qPrintable(file.errorString()));
1749 
1750     QNetworkRequest request(QUrl::fromLocalFile(file.fileName()));
1751     if (backgroundAttribute)
1752         request.setAttribute(QNetworkRequest::BackgroundRequestAttribute, QVariant::fromValue(true));
1753     QNetworkReplyPtr reply;
1754 
1755     static const char fileData[] = "This is some data that is in the file.\r\n";
1756     QByteArray data = QByteArray::fromRawData(fileData, sizeof fileData - 1);
1757     QCOMPARE(file.write(data), data.size());
1758     file.flush();
1759     QCOMPARE(file.size(), qint64(data.size()));
1760 
1761     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply));
1762     QVERIFY(waitForFinish(reply) != Timeout);
1763 
1764     QCOMPARE(reply->url(), request.url());
1765     QCOMPARE(reply->error(), QNetworkReply::NoError);
1766 
1767     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), file.size());
1768     QCOMPARE(reply->readAll(), data);
1769 
1770     // make the file bigger
1771     file.resize(0);
1772     const int multiply = (128 * 1024) / (sizeof fileData - 1);
1773     for (int i = 0; i < multiply; ++i)
1774         file.write(fileData, sizeof fileData - 1);
1775     file.flush();
1776 
1777     // run again
1778     reply.clear();
1779 
1780     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply));
1781     QCOMPARE(reply->url(), request.url());
1782     QCOMPARE(reply->error(), QNetworkReply::NoError);
1783 
1784     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), file.size());
1785     QCOMPARE(qint64(reply->readAll().size()), file.size());
1786 }
1787 
1788 void tst_QNetworkReply::getFromFileSpecial_data()
1789 {
1790     QTest::addColumn<QString>("fileName");
1791     QTest::addColumn<QString>("url");
1792 
1793     QTest::newRow("resource") << ":/resource" <<  "qrc:/resource";
1794     QTest::newRow("search-path") << "testdata:/rfc3252.txt" << "testdata:/rfc3252.txt";
1795     QTest::newRow("bigfile-path") << "testdata:/bigfile" << "testdata:/bigfile";
1796 #ifdef Q_OS_WIN
1797     QTest::newRow("smb-path") << "testdata:/smb-file.txt" << "file://" + QtNetworkSettings::winServerName() + "/testshare/test.pri";
1798 #endif
1799 }
1800 
1801 void tst_QNetworkReply::getFromFileSpecial()
1802 {
1803     QFETCH(QString, fileName);
1804     QFETCH(QString, url);
1805 
1806     // open the resource so we can find out its size
1807     QFile resource(fileName);
1808     QVERIFY(resource.open(QIODevice::ReadOnly));
1809 
1810     QNetworkRequest request;
1811     QNetworkReplyPtr reply;
1812     request.setUrl(url);
1813     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply));
1814 
1815     QCOMPARE(reply->url(), request.url());
1816     QCOMPARE(reply->error(), QNetworkReply::NoError);
1817 
1818     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), resource.size());
1819     QCOMPARE(reply->readAll(), resource.readAll());
1820 }
1821 
1822 void tst_QNetworkReply::getFromFtp_data()
1823 {
1824     QTest::addColumn<QString>("referenceName");
1825     QTest::addColumn<QString>("url");
1826 
1827     QTest::newRow("rfc3252.txt") << (testDataDir + "/rfc3252.txt") << "ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt";
1828     QTest::newRow("bigfile") << (testDataDir + "/bigfile") << "ftp://" + QtNetworkSettings::serverName() + "/qtest/bigfile";
1829 }
1830 
1831 void tst_QNetworkReply::getFromFtp()
1832 {
1833     QFETCH(QString, referenceName);
1834     QFETCH(QString, url);
1835 
1836     QFile reference(referenceName);
1837     QVERIFY(reference.open(QIODevice::ReadOnly));
1838 
1839     QNetworkRequest request(url);
1840     QNetworkReplyPtr reply;
1841     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply));
1842 
1843     QCOMPARE(reply->url(), request.url());
1844     QCOMPARE(reply->error(), QNetworkReply::NoError);
1845 
1846     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
1847     QCOMPARE(reply->readAll(), reference.readAll());
1848 }
1849 
1850 void tst_QNetworkReply::getFromFtpAfterError()
1851 {
1852     QNetworkRequest invalidRequest(QUrl("ftp://" + QtNetworkSettings::serverName() + "/qtest/invalid.txt"));
1853     QNetworkReplyPtr invalidReply;
1854     invalidReply.reset(manager.get(invalidRequest));
1855     QSignalSpy spy(invalidReply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
1856     QVERIFY(spy.wait());
1857     QCOMPARE(invalidReply->error(), QNetworkReply::ContentNotFoundError);
1858 
1859     QFile reference(testDataDir + "/rfc3252.txt");
1860     QVERIFY(reference.open(QIODevice::ReadOnly));
1861     QNetworkRequest validRequest(QUrl("ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
1862     QNetworkReplyPtr validReply;
1863     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, validRequest, validReply));
1864     QCOMPARE(validReply->url(), validRequest.url());
1865     QCOMPARE(validReply->error(), QNetworkReply::NoError);
1866     QCOMPARE(validReply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
1867     QCOMPARE(validReply->readAll(), reference.readAll());
1868 }
1869 
1870 void tst_QNetworkReply::getFromHttp_data()
1871 {
1872     QTest::addColumn<QString>("referenceName");
1873     QTest::addColumn<QString>("url");
1874 
1875     QTest::newRow("success-internal") << (testDataDir + "/rfc3252.txt") << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt";
1876     QTest::newRow("success-external") << (testDataDir + "/rfc3252.txt") << "http://www.ietf.org/rfc/rfc3252.txt";
1877     QTest::newRow("bigfile-internal") << (testDataDir + "/bigfile") << "http://" + QtNetworkSettings::serverName() + "/qtest/bigfile";
1878 }
1879 
1880 void tst_QNetworkReply::getFromHttp()
1881 {
1882     QFETCH(QString, referenceName);
1883     QFETCH(QString, url);
1884 
1885     QFile reference(referenceName);
1886     QVERIFY(reference.open(QIODevice::ReadOnly));
1887 
1888     QNetworkRequest request(url);
1889     QNetworkReplyPtr reply;
1890     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply));
1891 
1892     QCOMPARE(reply->url(), request.url());
1893     QCOMPARE(reply->error(), QNetworkReply::NoError);
1894     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
1895     QCOMPARE(reply->size(), reference.size());
1896     // only compare when the header is set.
1897     if (reply->header(QNetworkRequest::ContentLengthHeader).isValid())
1898         QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
1899 
1900     // We know our internal server is apache..
1901     if (qstrcmp(QTest::currentDataTag(), "success-internal") == 0)
1902         QVERIFY(reply->header(QNetworkRequest::ServerHeader).toString().contains("Apache"));
1903 
1904     QCOMPARE(reply->readAll(), reference.readAll());
1905 }
1906 
1907 #ifndef QT_NO_NETWORKPROXY
1908 void tst_QNetworkReply::headFromHttp_data()
1909 {
1910     QTest::addColumn<qint64>("referenceSize");
1911     QTest::addColumn<QUrl>("url");
1912     QTest::addColumn<QString>("contentType");
1913     QTest::addColumn<QNetworkProxy>("proxy");
1914 
1915     qint64 rfcsize = QFileInfo(testDataDir + "/rfc3252.txt").size();
1916     qint64 bigfilesize = QFileInfo(testDataDir + "/bigfile").size();
1917     qint64 indexsize = QFileInfo(testDataDir + "/index.html").size();
1918 
1919     //testing proxies, mainly for the 407 response from http proxy
1920     for (int i = 0; i < proxies.count(); ++i) {
1921         QTest::newRow("rfc" + proxies.at(i).tag) << rfcsize << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt") << "text/plain" << proxies.at(i).proxy;
1922         QTest::newRow("bigfile" + proxies.at(i).tag) << bigfilesize << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/bigfile") << "text/plain" << proxies.at(i).proxy;
1923         QTest::newRow("index" + proxies.at(i).tag) << indexsize << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/") << "text/html" << proxies.at(i).proxy;
1924         QTest::newRow("with-authentication" + proxies.at(i).tag) << rfcsize << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt") << "text/plain" << proxies.at(i).proxy;
1925         QTest::newRow("cgi" + proxies.at(i).tag) << (qint64)-1 << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/httpcachetest_expires500.cgi") << "text/html" << proxies.at(i).proxy;
1926     }
1927 }
1928 
1929 void tst_QNetworkReply::headFromHttp()
1930 {
1931     QFETCH(qint64, referenceSize);
1932     QFETCH(QUrl, url);
1933     QFETCH(QString, contentType);
1934     QFETCH(QNetworkProxy, proxy);
1935 
1936     QNetworkRequest request(url);
1937     QNetworkReplyPtr reply;
1938 
1939     QElapsedTimer time;
1940     time.start();
1941 
1942     manager.setProxy(proxy);
1943     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
1944             SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
1945     connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
1946             SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
1947 
1948     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::HeadOperation, request, reply));
1949 
1950     manager.disconnect(SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
1951                this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
1952     manager.disconnect(SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
1953                this, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
1954 
1955     QVERIFY(time.elapsed() < 8000); //check authentication didn't wait for the server to timeout the http connection (15s on qt test server)
1956 
1957     QCOMPARE(reply->url(), request.url());
1958     QCOMPARE(reply->error(), QNetworkReply::NoError);
1959     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
1960     // only compare when the header is set.
1961     if (reply->header(QNetworkRequest::ContentLengthHeader).isValid() && referenceSize >= 0)
1962         QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), referenceSize);
1963     if (reply->header(QNetworkRequest::ContentTypeHeader).isValid())
1964         QCOMPARE(reply->header(QNetworkRequest::ContentTypeHeader).toString(), contentType);
1965 }
1966 #endif // !QT_NO_NETWORKPROXY
1967 
1968 void tst_QNetworkReply::getErrors_data()
1969 {
1970     QTest::addColumn<QString>("url");
1971     QTest::addColumn<int>("error");
1972     QTest::addColumn<int>("httpStatusCode");
1973     QTest::addColumn<bool>("dataIsEmpty");
1974 
1975     // empties
1976     QTest::newRow("empty-url") << QString() << int(QNetworkReply::ProtocolUnknownError) << 0 << true;
1977     QTest::newRow("empty-scheme-host") << (testDataDir + "/rfc3252.txt") << int(QNetworkReply::ProtocolUnknownError) << 0 << true;
1978     QTest::newRow("empty-scheme") << "//" + QtNetworkSettings::winServerName() + "/testshare/test.pri"
1979             << int(QNetworkReply::ProtocolUnknownError) << 0 << true;
1980 
1981     // file: errors
1982     QTest::newRow("file-host") << "file://invalid.test.qt-project.org/foo.txt"
1983 #if !defined Q_OS_WIN
1984                                << int(QNetworkReply::ProtocolInvalidOperationError) << 0 << true;
1985 #else
1986                                << int(QNetworkReply::ContentNotFoundError) << 0 << true;
1987 #endif
1988     QTest::newRow("file-no-path") << "file://localhost"
1989                                   << int(QNetworkReply::ContentOperationNotPermittedError) << 0 << true;
1990     QTest::newRow("file-is-dir") << QUrl::fromLocalFile(QDir::currentPath()).toString()
1991                                  << int(QNetworkReply::ContentOperationNotPermittedError) << 0 << true;
1992     QTest::newRow("file-exist") << QUrl::fromLocalFile(QDir::currentPath() + "/this-file-doesnt-exist.txt").toString()
1993                                 << int(QNetworkReply::ContentNotFoundError) << 0 << true;
1994 #if !defined Q_OS_WIN
1995     QTest::newRow("file-is-wronly") << QUrl::fromLocalFile(wronlyFileName).toString()
1996                                     << int(QNetworkReply::ContentAccessDenied) << 0 << true;
1997 #endif
1998 
1999 
2000     if (QFile::exists(filePermissionFileName))
2001         QTest::newRow("file-permissions") << "file:" + filePermissionFileName
2002                                           << int(QNetworkReply::ContentAccessDenied) << 0 << true;
2003 
2004     // ftp: errors
2005     QTest::newRow("ftp-host") << "ftp://invalid.test.qt-project.org/foo.txt"
2006                               << int(QNetworkReply::HostNotFoundError) << 0 << true;
2007     QTest::newRow("ftp-no-path") << "ftp://" + QtNetworkSettings::serverName()
2008                                  << int(QNetworkReply::ContentOperationNotPermittedError) << 0 << true;
2009     QTest::newRow("ftp-is-dir") << "ftp://" + QtNetworkSettings::serverName() + "/qtest"
2010                                 << int(QNetworkReply::ContentOperationNotPermittedError) << 0 << true;
2011     QTest::newRow("ftp-dir-not-readable") << "ftp://" + QtNetworkSettings::serverName() + "/pub/dir-not-readable/foo.txt"
2012                                           << int(QNetworkReply::ContentAccessDenied) << 0 << true;
2013     QTest::newRow("ftp-file-not-readable") << "ftp://" + QtNetworkSettings::serverName() + "/pub/file-not-readable.txt"
2014                                            << int(QNetworkReply::ContentAccessDenied) << 0 << true;
2015     QTest::newRow("ftp-exist") << "ftp://" + QtNetworkSettings::serverName() + "/pub/this-file-doesnt-exist.txt"
2016                                << int(QNetworkReply::ContentNotFoundError) << 0 << true;
2017 
2018     // http: errors
2019     QTest::newRow("http-host") << "http://invalid.test.qt-project.org/"
2020                                << int(QNetworkReply::HostNotFoundError) << 0 << true;
2021     QTest::newRow("http-exist") << "http://" + QtNetworkSettings::serverName() + "/this-file-doesnt-exist.txt"
2022                                 << int(QNetworkReply::ContentNotFoundError) << 404 << false;
2023     QTest::newRow("http-authentication") << "http://" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth"
2024                                          << int(QNetworkReply::AuthenticationRequiredError) << 401 << false;
2025 }
2026 
2027 static QByteArray msgGetErrors(int waitResult, const QNetworkReplyPtr &reply)
2028 {
2029     QByteArray result ="waitResult=" + QByteArray::number(waitResult);
2030     if (reply->isFinished())
2031         result += ", finished";
2032     if (reply->error() != QNetworkReply::NoError)
2033         result += ", error: " + QByteArray::number(int(reply->error()));
2034     return result;
2035 }
2036 
2037 void tst_QNetworkReply::getErrors()
2038 {
2039     QFETCH(QString, url);
2040     QNetworkRequest request(url);
2041 
2042 #ifdef Q_OS_UNIX
2043     if ((qstrcmp(QTest::currentDataTag(), "file-is-wronly") == 0) ||
2044         (qstrcmp(QTest::currentDataTag(), "file-permissions") == 0)) {
2045         if (::getuid() == 0)
2046             QSKIP("Running this test as root doesn't make sense");
2047 
2048     }
2049 
2050     if (EmulationDetector::isRunningArmOnX86()
2051         && qstrcmp(QTest::currentDataTag(), "file-permissions") == 0) {
2052         QFileInfo filePermissionFile = QFileInfo(filePermissionFileName.toLatin1());
2053         if (filePermissionFile.ownerId() == ::geteuid()) {
2054             QSKIP("Sysroot directories are owned by the current user");
2055         }
2056     }
2057 #endif
2058 
2059     QNetworkReplyPtr reply(manager.get(request));
2060     reply->setParent(this);     // we have expect-fails
2061 
2062     if (!reply->isFinished())
2063         QCOMPARE(reply->error(), QNetworkReply::NoError);
2064 
2065     // now run the request:
2066     const int waitResult = waitForFinish(reply);
2067     QVERIFY2(waitResult != Timeout, msgGetErrors(waitResult, reply));
2068 
2069     QFETCH(int, error);
2070     QEXPECT_FAIL("ftp-is-dir", "QFtp cannot provide enough detail", Abort);
2071     // the line below is not necessary
2072     QEXPECT_FAIL("ftp-dir-not-readable", "QFtp cannot provide enough detail", Abort);
2073     QCOMPARE(reply->error(), QNetworkReply::NetworkError(error));
2074 
2075     QTEST(reply->readAll().isEmpty(), "dataIsEmpty");
2076 
2077     QVERIFY(reply->isFinished());
2078     QVERIFY(!reply->isRunning());
2079 
2080     QFETCH(int, httpStatusCode);
2081     if (httpStatusCode != 0) {
2082         QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), httpStatusCode);
2083     }
2084 }
2085 
2086 static inline QByteArray md5sum(const QByteArray &data)
2087 {
2088     return QCryptographicHash::hash(data, QCryptographicHash::Md5);
2089 }
2090 
2091 void tst_QNetworkReply::putToFile_data()
2092 {
2093     QTest::addColumn<QByteArray>("data");
2094     QTest::addColumn<QByteArray>("md5sum");
2095 
2096     QByteArray data;
2097     data = "";
2098     QTest::newRow("empty") << data << md5sum(data);
2099 
2100     data = "This is a normal message.";
2101     QTest::newRow("generic") << data << md5sum(data);
2102 
2103     data = "This is a message to show that Qt rocks!\r\n\n";
2104     QTest::newRow("small") << data << md5sum(data);
2105 
2106     data = QByteArray("abcd\0\1\2\abcd",12);
2107     QTest::newRow("with-nul") << data << md5sum(data);
2108 
2109     data = QByteArray(4097, '\4');
2110     QTest::newRow("4k+1") << data << md5sum(data);
2111 
2112     data = QByteArray(128*1024+1, '\177');
2113     QTest::newRow("128k+1") << data << md5sum(data);
2114 
2115     data = QByteArray(2*1024*1024+1, '\177');
2116     QTest::newRow("2MB+1") << data << md5sum(data);
2117 }
2118 
2119 void tst_QNetworkReply::putToFile()
2120 {
2121     QFile file(testFileName);
2122 
2123     QUrl url = QUrl::fromLocalFile(file.fileName());
2124     QNetworkRequest request(url);
2125     QNetworkReplyPtr reply;
2126 
2127     QFETCH(QByteArray, data);
2128 
2129     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PutOperation, request, reply, data));
2130 
2131     QCOMPARE(reply->url(), url);
2132     QCOMPARE(reply->error(), QNetworkReply::NoError);
2133     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
2134     QVERIFY(reply->readAll().isEmpty());
2135 
2136     QVERIFY(file.open(QIODevice::ReadOnly));
2137     QCOMPARE(file.size(), qint64(data.size()));
2138     QByteArray contents = file.readAll();
2139     QCOMPARE(contents, data);
2140 }
2141 
2142 void tst_QNetworkReply::putToFtp_data()
2143 {
2144     putToFile_data();
2145 }
2146 
2147 void tst_QNetworkReply::putToFtp()
2148 {
2149     QUrl url("ftp://" + QtNetworkSettings::serverName());
2150     url.setPath(QString("/qtest/upload/qnetworkaccess-putToFtp-%1-%2")
2151                 .arg(QTest::currentDataTag())
2152                 .arg(uniqueExtension));
2153 
2154     QNetworkRequest request(url);
2155     QNetworkReplyPtr reply;
2156 
2157     QFETCH(QByteArray, data);
2158 
2159     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PutOperation, request, reply, data));
2160 
2161     QCOMPARE(reply->url(), url);
2162     QCOMPARE(reply->error(), QNetworkReply::NoError);
2163     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
2164     QVERIFY(reply->readAll().isEmpty());
2165 
2166     // download the file again from FTP to make sure it was uploaded
2167     // correctly
2168     QNetworkAccessManager qnam;
2169     QNetworkRequest req(url);
2170     QNetworkReply *r = qnam.get(req);
2171 
2172     QObject::connect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
2173     int count = 0;
2174     QSignalSpy spy(r, SIGNAL(downloadProgress(qint64,qint64)));
2175     while (!r->isFinished()) {
2176         QTestEventLoop::instance().enterLoop(10);
2177         if (count == spy.count() && !r->isFinished())
2178             break;
2179         count = spy.count();
2180     }
2181     QObject::disconnect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
2182 
2183     QByteArray uploaded = r->readAll();
2184     QCOMPARE(uploaded.size(), data.size());
2185     QCOMPARE(uploaded, data);
2186 
2187     r->close();
2188     QObject::connect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
2189     QTestEventLoop::instance().enterLoop(10);
2190     QObject::disconnect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
2191 }
2192 
2193 void tst_QNetworkReply::putToFtpWithInvalidCredentials()
2194 {
2195     QUrl url("ftp://" + QtNetworkSettings::serverName());
2196     url.setPath(QString("/qtest/upload/qnetworkaccess-putToFtp-%1-%2")
2197                 .arg(QTest::currentDataTag())
2198                 .arg(uniqueExtension));
2199     url.setUserName("invalidUser");
2200     url.setPassword("InvalidPassword");
2201     QNetworkRequest req(url);
2202     QNetworkReplyPtr r;
2203 
2204     for (int i = 0; i < 2; i++)
2205     {
2206         runSimpleRequest(QNetworkAccessManager::PutOperation, req, r, QByteArray());
2207 
2208         QVERIFY(r->isFinished());
2209         QCOMPARE(r->url(), url);
2210         QCOMPARE(r->error(), QNetworkReply::AuthenticationRequiredError);
2211         r->close();
2212     }
2213 }
2214 
2215 void tst_QNetworkReply::putToHttp_data()
2216 {
2217     putToFile_data();
2218 }
2219 
2220 void tst_QNetworkReply::putToHttp()
2221 {
2222     QUrl url("http://" + QtNetworkSettings::serverName());
2223     url.setPath(QString("/dav/qnetworkaccess-putToHttp-%1-%2")
2224                 .arg(QTest::currentDataTag())
2225                 .arg(uniqueExtension));
2226 
2227     QNetworkRequest request(url);
2228     QNetworkReplyPtr reply;
2229 
2230     QFETCH(QByteArray, data);
2231 
2232     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PutOperation, request, reply, data));
2233 
2234     QCOMPARE(reply->url(), url);
2235     QCOMPARE(reply->error(), QNetworkReply::NoError);
2236 
2237     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 201); // 201 Created
2238 
2239     // download the file again from HTTP to make sure it was uploaded
2240     // correctly. HTTP/0.9 is enough
2241     QTcpSocket socket;
2242     socket.connectToHost(QtNetworkSettings::serverName(), 80);
2243     socket.write("GET " + url.toEncoded(QUrl::RemoveScheme | QUrl::RemoveAuthority) + "\r\n");
2244     if (!socket.waitForDisconnected(10000))
2245         QFAIL("Network timeout");
2246 
2247     QByteArray uploadedData = socket.readAll();
2248     QCOMPARE(uploadedData, data);
2249 }
2250 
2251 void tst_QNetworkReply::putToHttpSynchronous_data()
2252 {
2253     uniqueExtension = createUniqueExtension();
2254     putToFile_data();
2255 }
2256 
2257 void tst_QNetworkReply::putToHttpSynchronous()
2258 {
2259     QUrl url("http://" + QtNetworkSettings::serverName());
2260     url.setPath(QString("/dav/qnetworkaccess-putToHttp-%1-%2")
2261                 .arg(QTest::currentDataTag())
2262                 .arg(uniqueExtension));
2263 
2264     QNetworkRequest request(url);
2265     QNetworkReplyPtr reply;
2266 
2267     QFETCH(QByteArray, data);
2268 
2269     request.setAttribute(
2270             QNetworkRequest::SynchronousRequestAttribute,
2271             true);
2272 
2273     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PutOperation, request, reply, data));
2274 
2275     QCOMPARE(reply->url(), url);
2276     QCOMPARE(reply->error(), QNetworkReply::NoError);
2277 
2278     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 201); // 201 Created
2279 
2280     // download the file again from HTTP to make sure it was uploaded
2281     // correctly. HTTP/0.9 is enough
2282     QTcpSocket socket;
2283     socket.connectToHost(QtNetworkSettings::serverName(), 80);
2284     socket.write("GET " + url.toEncoded(QUrl::RemoveScheme | QUrl::RemoveAuthority) + "\r\n");
2285     if (!socket.waitForDisconnected(10000))
2286         QFAIL("Network timeout");
2287 
2288     QByteArray uploadedData = socket.readAll();
2289     QCOMPARE(uploadedData, data);
2290 }
2291 
2292 void tst_QNetworkReply::postToHttp_data()
2293 {
2294     putToFile_data();
2295 }
2296 
2297 void tst_QNetworkReply::postToHttp()
2298 {
2299     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi");
2300 
2301     QNetworkRequest request(url);
2302     request.setRawHeader("Content-Type", "application/octet-stream");
2303     QNetworkReplyPtr reply;
2304 
2305     QFETCH(QByteArray, data);
2306 
2307     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PostOperation, request, reply, data));
2308 
2309     QCOMPARE(reply->url(), url);
2310     QCOMPARE(reply->error(), QNetworkReply::NoError);
2311 
2312     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2313 
2314     QFETCH(QByteArray, md5sum);
2315     QByteArray uploadedData = reply->readAll().trimmed();
2316     QCOMPARE(uploadedData, md5sum.toHex());
2317 }
2318 
2319 void tst_QNetworkReply::postToHttpSynchronous_data()
2320 {
2321     putToFile_data();
2322 }
2323 
2324 void tst_QNetworkReply::postToHttpSynchronous()
2325 {
2326     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi");
2327 
2328     QNetworkRequest request(url);
2329     request.setRawHeader("Content-Type", "application/octet-stream");
2330 
2331     request.setAttribute(
2332             QNetworkRequest::SynchronousRequestAttribute,
2333             true);
2334 
2335     QNetworkReplyPtr reply;
2336 
2337     QFETCH(QByteArray, data);
2338 
2339     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PostOperation, request, reply, data));
2340 
2341     QCOMPARE(reply->url(), url);
2342     QCOMPARE(reply->error(), QNetworkReply::NoError);
2343 
2344     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2345 
2346     QFETCH(QByteArray, md5sum);
2347     QByteArray uploadedData = reply->readAll().trimmed();
2348     QCOMPARE(uploadedData, md5sum.toHex());
2349 }
2350 
2351 void tst_QNetworkReply::postToHttpMultipart_data()
2352 {
2353     QTest::addColumn<QUrl>("url");
2354     QTest::addColumn<QHttpMultiPart *>("multiPart");
2355     QTest::addColumn<QByteArray>("expectedReplyData");
2356     QTest::addColumn<QByteArray>("contentType");
2357 
2358     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/multipart.cgi");
2359     QByteArray expectedData;
2360 
2361 
2362     // empty parts
2363 
2364     QHttpMultiPart *emptyMultiPart = new QHttpMultiPart;
2365     QTest::newRow("empty") << url << emptyMultiPart << expectedData << QByteArray("mixed");
2366 
2367     QHttpMultiPart *emptyRelatedMultiPart = new QHttpMultiPart;
2368     emptyRelatedMultiPart->setContentType(QHttpMultiPart::RelatedType);
2369     QTest::newRow("empty-related") << url << emptyRelatedMultiPart << expectedData << QByteArray("related");
2370 
2371     QHttpMultiPart *emptyAlternativeMultiPart = new QHttpMultiPart;
2372     emptyAlternativeMultiPart->setContentType(QHttpMultiPart::AlternativeType);
2373     QTest::newRow("empty-alternative") << url << emptyAlternativeMultiPart << expectedData << QByteArray("alternative");
2374 
2375 
2376     // text-only parts
2377 
2378     QHttpPart textPart;
2379     textPart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("text/plain"));
2380     textPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"text\""));
2381     textPart.setBody("7 bytes");
2382     QHttpMultiPart *multiPart1 = new QHttpMultiPart;
2383     multiPart1->setContentType(QHttpMultiPart::FormDataType);
2384     multiPart1->append(textPart);
2385     expectedData = "key: text, value: 7 bytes\n";
2386     QTest::newRow("text") << url << multiPart1 << expectedData << QByteArray("form-data");
2387 
2388     QHttpMultiPart *customMultiPart = new QHttpMultiPart;
2389     customMultiPart->append(textPart);
2390     expectedData = "header: Content-Type, value: 'text/plain'\n"
2391                    "header: Content-Disposition, value: 'form-data; name=\"text\"'\n"
2392                    "content: 7 bytes\n"
2393                    "\n";
2394     QTest::newRow("text-custom") << url << customMultiPart << expectedData << QByteArray("custom");
2395 
2396     QHttpPart textPart2;
2397     textPart2.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("text/plain"));
2398     textPart2.setRawHeader("myRawHeader", "myValue");
2399     textPart2.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"text2\""));
2400     textPart2.setBody("some more bytes");
2401     textPart2.setBodyDevice((QIODevice *) 1); // test whether setting and unsetting of the device works
2402     textPart2.setBodyDevice(0);
2403     QHttpMultiPart *multiPart2 = new QHttpMultiPart;
2404     multiPart2->setContentType(QHttpMultiPart::FormDataType);
2405     multiPart2->append(textPart);
2406     multiPart2->append(textPart2);
2407 #ifdef QT_TEST_SERVER
2408     expectedData = "key: text, value: 7 bytes\n"
2409                    "key: text2, value: some more bytes\n";
2410 #else
2411     expectedData = "key: text2, value: some more bytes\n"
2412                    "key: text, value: 7 bytes\n";
2413 #endif
2414     QTest::newRow("text-text") << url << multiPart2 << expectedData << QByteArray("form-data");
2415 
2416 
2417     QHttpPart textPart3;
2418     textPart3.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("text/plain"));
2419     textPart3.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"text3\""));
2420     textPart3.setRawHeader("Content-Location", "http://my.test.location.tld");
2421     textPart3.setBody("even more bytes");
2422     QHttpMultiPart *multiPart3 = new QHttpMultiPart;
2423     multiPart3->setContentType(QHttpMultiPart::AlternativeType);
2424     multiPart3->append(textPart);
2425     multiPart3->append(textPart2);
2426     multiPart3->append(textPart3);
2427     expectedData = "header: Content-Type, value: 'text/plain'\n"
2428                    "header: Content-Disposition, value: 'form-data; name=\"text\"'\n"
2429                    "content: 7 bytes\n"
2430                    "\n"
2431                    "header: Content-Type, value: 'text/plain'\n"
2432                    "header: myRawHeader, value: 'myValue'\n"
2433                    "header: Content-Disposition, value: 'form-data; name=\"text2\"'\n"
2434                    "content: some more bytes\n"
2435                    "\n"
2436                    "header: Content-Type, value: 'text/plain'\n"
2437                    "header: Content-Disposition, value: 'form-data; name=\"text3\"'\n"
2438                    "header: Content-Location, value: 'http://my.test.location.tld'\n"
2439                    "content: even more bytes\n\n";
2440     QTest::newRow("text-text-text") << url << multiPart3 << expectedData << QByteArray("alternative");
2441 
2442 
2443 
2444     // text and image parts
2445 
2446     QHttpPart imagePart11;
2447     imagePart11.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2448     imagePart11.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"testImage\""));
2449     imagePart11.setRawHeader("Content-Location", "http://my.test.location.tld");
2450     imagePart11.setRawHeader("Content-ID", "my@id.tld");
2451     QFile *file11 = new QFile(testDataDir + "/image1.jpg");
2452     file11->open(QIODevice::ReadOnly);
2453     imagePart11.setBodyDevice(file11);
2454     QHttpMultiPart *imageMultiPart1 = new QHttpMultiPart(QHttpMultiPart::FormDataType);
2455     imageMultiPart1->append(imagePart11);
2456     file11->setParent(imageMultiPart1);
2457     expectedData = "key: testImage, value: 87ef3bb319b004ba9e5e9c9fa713776e\n"; // md5 sum of file
2458     QTest::newRow("image") << url << imageMultiPart1 << expectedData << QByteArray("form-data");
2459 
2460     QHttpPart imagePart21;
2461     imagePart21.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2462     imagePart21.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"testImage1\""));
2463     imagePart21.setRawHeader("Content-Location", "http://my.test.location.tld");
2464     imagePart21.setRawHeader("Content-ID", "my@id.tld");
2465     QFile *file21 = new QFile(testDataDir + "/image1.jpg");
2466     file21->open(QIODevice::ReadOnly);
2467     imagePart21.setBodyDevice(file21);
2468     QHttpMultiPart *imageMultiPart2 = new QHttpMultiPart();
2469     imageMultiPart2->setContentType(QHttpMultiPart::FormDataType);
2470     imageMultiPart2->append(textPart);
2471     imageMultiPart2->append(imagePart21);
2472     file21->setParent(imageMultiPart2);
2473     QHttpPart imagePart22;
2474     imagePart22.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2475     imagePart22.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"testImage2\""));
2476     QFile *file22 = new QFile(testDataDir + "/image2.jpg");
2477     file22->open(QIODevice::ReadOnly);
2478     imagePart22.setBodyDevice(file22);
2479     imageMultiPart2->append(imagePart22);
2480     file22->setParent(imageMultiPart2);
2481 #ifdef QT_TEST_SERVER
2482     expectedData = "key: text, value: 7 bytes\n"
2483                    "key: testImage1, value: 87ef3bb319b004ba9e5e9c9fa713776e\n"
2484                    "key: testImage2, value: 483761b893f7fb1bd2414344cd1f3dfb\n";
2485 #else
2486     expectedData = "key: testImage1, value: 87ef3bb319b004ba9e5e9c9fa713776e\n"
2487                    "key: text, value: 7 bytes\n"
2488                    "key: testImage2, value: 483761b893f7fb1bd2414344cd1f3dfb\n";
2489 #endif
2490     QTest::newRow("text-image-image") << url << imageMultiPart2 << expectedData << QByteArray("form-data");
2491 
2492 
2493     QHttpPart imagePart31;
2494     imagePart31.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2495     imagePart31.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"testImage1\""));
2496     imagePart31.setRawHeader("Content-Location", "http://my.test.location.tld");
2497     imagePart31.setRawHeader("Content-ID", "my@id.tld");
2498     QFile *file31 = new QFile(testDataDir + "/image1.jpg");
2499     file31->open(QIODevice::ReadOnly);
2500     imagePart31.setBodyDevice(file31);
2501     QHttpMultiPart *imageMultiPart3 = new QHttpMultiPart(QHttpMultiPart::FormDataType);
2502     imageMultiPart3->append(imagePart31);
2503     file31->setParent(imageMultiPart3);
2504     QHttpPart imagePart32;
2505     imagePart32.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2506     imagePart32.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"testImage2\""));
2507     QFile *file32 = new QFile(testDataDir + "/image2.jpg");
2508     file32->open(QIODevice::ReadOnly);
2509     imagePart32.setBodyDevice(file31); // check that resetting works
2510     imagePart32.setBodyDevice(file32);
2511     imageMultiPart3->append(imagePart32);
2512     file32->setParent(imageMultiPart3);
2513     QHttpPart imagePart33;
2514     imagePart33.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2515     imagePart33.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"testImage3\""));
2516     QFile *file33 = new QFile(testDataDir + "/image3.jpg");
2517     file33->open(QIODevice::ReadOnly);
2518     imagePart33.setBodyDevice(file33);
2519     imageMultiPart3->append(imagePart33);
2520     file33->setParent(imageMultiPart3);
2521     expectedData = "key: testImage1, value: 87ef3bb319b004ba9e5e9c9fa713776e\n"
2522                    "key: testImage2, value: 483761b893f7fb1bd2414344cd1f3dfb\n"
2523                    "key: testImage3, value: ab0eb6fd4fcf8b4436254870b4513033\n";
2524     QTest::newRow("3-images") << url << imageMultiPart3 << expectedData << QByteArray("form-data");
2525 
2526 
2527     // note: nesting multiparts is not working currently; for that, the outputDevice would need to be public
2528 
2529 //    QHttpPart imagePart41;
2530 //    imagePart41.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2531 //    QFile *file41 = new QFile(testDataDir + "/image1.jpg");
2532 //    file41->open(QIODevice::ReadOnly);
2533 //    imagePart41.setBodyDevice(file41);
2534 //
2535 //    QHttpMultiPart *innerMultiPart = new QHttpMultiPart();
2536 //    innerMultiPart->setContentType(QHttpMultiPart::FormDataType);
2537 //    textPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant());
2538 //    innerMultiPart->append(textPart);
2539 //    innerMultiPart->append(imagePart41);
2540 //    textPart2.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant());
2541 //    innerMultiPart->append(textPart2);
2542 //
2543 //    QHttpPart nestedPart;
2544 //    nestedPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"nestedMessage"));
2545 //    nestedPart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("multipart/alternative; boundary=\"" + innerMultiPart->boundary() + "\""));
2546 //    innerMultiPart->outputDevice()->open(QIODevice::ReadOnly);
2547 //    nestedPart.setBodyDevice(innerMultiPart->outputDevice());
2548 //
2549 //    QHttpMultiPart *outerMultiPart = new QHttpMultiPart;
2550 //    outerMultiPart->setContentType(QHttpMultiPart::FormDataType);
2551 //    outerMultiPart->append(textPart);
2552 //    outerMultiPart->append(nestedPart);
2553 //    outerMultiPart->append(textPart2);
2554 //    expectedData = "nothing"; // the CGI.pm module running on the test server does not understand nested multiparts
2555 //    openFiles.clear();
2556 //    openFiles << file41;
2557 //    QTest::newRow("nested") << url << outerMultiPart << expectedData << openFiles;
2558 
2559 
2560     // test setting large chunks of content with a byte array instead of a device (DISCOURAGED because of high memory consumption,
2561     // but we need to test that the behavior is correct)
2562     QHttpPart imagePart51;
2563     imagePart51.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/jpeg"));
2564     imagePart51.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=\"testImage\""));
2565     QFile *file51 = new QFile(testDataDir + "/image1.jpg");
2566     file51->open(QIODevice::ReadOnly);
2567     QByteArray imageData = file51->readAll();
2568     file51->close();
2569     delete file51;
2570     imagePart51.setBody("7 bytes"); // check that resetting works
2571     imagePart51.setBody(imageData);
2572     QHttpMultiPart *imageMultiPart5 = new QHttpMultiPart;
2573     imageMultiPart5->setContentType(QHttpMultiPart::FormDataType);
2574     imageMultiPart5->append(imagePart51);
2575     expectedData = "key: testImage, value: 87ef3bb319b004ba9e5e9c9fa713776e\n"; // md5 sum of file
2576     QTest::newRow("image-as-content") << url << imageMultiPart5 << expectedData << QByteArray("form-data");
2577 }
2578 
2579 void tst_QNetworkReply::postToHttpMultipart()
2580 {
2581     QFETCH(QUrl, url);
2582 
2583     static QSet<QByteArray> boundaries;
2584 
2585     QNetworkRequest request(url);
2586     QNetworkReplyPtr reply;
2587 
2588     QFETCH(QHttpMultiPart *, multiPart);
2589     QFETCH(QByteArray, expectedReplyData);
2590     QFETCH(QByteArray, contentType);
2591 
2592     // hack for testing the setting of the content-type header by hand:
2593     if (contentType == "custom") {
2594         QByteArray contentType("multipart/custom; boundary=\"" + multiPart->boundary() + "\"");
2595         request.setHeader(QNetworkRequest::ContentTypeHeader, contentType);
2596     }
2597 
2598     QVERIFY2(! boundaries.contains(multiPart->boundary()), "boundary '" + multiPart->boundary() + "' has been created twice");
2599     boundaries.insert(multiPart->boundary());
2600 
2601     RUN_REQUEST(runMultipartRequest(request, reply, multiPart, "POST"));
2602     multiPart->deleteLater();
2603 
2604     QCOMPARE(reply->url(), url);
2605     QCOMPARE(reply->error(), QNetworkReply::NoError);
2606 
2607     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2608 
2609     QVERIFY(multiPart->boundary().count() > 20); // check that there is randomness after the "boundary_.oOo._" string
2610     QVERIFY(multiPart->boundary().count() < 70);
2611     QByteArray replyData = reply->readAll();
2612 
2613     expectedReplyData.prepend("content type: multipart/" + contentType + "; boundary=\"" + multiPart->boundary() + "\"\n");
2614 //    QEXPECT_FAIL("nested", "the server does not understand nested multipart messages", Continue); // see above
2615     QCOMPARE(replyData, expectedReplyData);
2616 }
2617 
2618 void tst_QNetworkReply::multipartSkipIndices() // QTBUG-32534
2619 {
2620     QHttpMultiPart *multiPart = new QHttpMultiPart(QHttpMultiPart::MixedType);
2621     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/multipart.cgi");
2622     QNetworkRequest request(url);
2623     QList<QByteArray> parts;
2624     parts << QByteArray(56083, 'X') << QByteArray(468, 'X') << QByteArray(24952, 'X');
2625 
2626     QHttpPart part1;
2627     part1.setHeader(QNetworkRequest::ContentDispositionHeader, "form-data; name=\"field1\"; filename=\"aaaa.bin\"");
2628     part1.setHeader(QNetworkRequest::ContentTypeHeader, "application/octet-stream");
2629     part1.setBody(parts.at(0));
2630     multiPart->append(part1);
2631 
2632     QHttpPart part2;
2633     part2.setHeader(QNetworkRequest::ContentDispositionHeader, "form-data; name=\"field2\"; filename=\"bbbb.txt\"");
2634     part2.setHeader(QNetworkRequest::ContentTypeHeader, "text/plain");
2635     part2.setBody(parts.at(1));
2636     multiPart->append(part2);
2637 
2638     QHttpPart part3;
2639     part3.setHeader(QNetworkRequest::ContentDispositionHeader, "form-data; name=\"text-3\"; filename=\"cccc.txt\"");
2640     part3.setHeader(QNetworkRequest::ContentTypeHeader, "text/plain");
2641     part3.setBody(parts.at(2));
2642     multiPart->append(part3);
2643 
2644     QNetworkReplyPtr reply;
2645     RUN_REQUEST(runMultipartRequest(request, reply, multiPart, "POST"));
2646 
2647     QCOMPARE(reply->error(), QNetworkReply::NoError);
2648 
2649     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2650     QByteArray line;
2651     int partIndex = 0;
2652     while ((line = reply->readLine()) != QByteArray("")) {
2653         if (line.startsWith("content:")) {
2654             // before, the 3rd part would return garbled output at the end
2655             QCOMPARE("content: " + parts[partIndex++] + "\n", line);
2656         }
2657     }
2658     multiPart->deleteLater();
2659 }
2660 
2661 void tst_QNetworkReply::putToHttpMultipart_data()
2662 {
2663     postToHttpMultipart_data();
2664 }
2665 
2666 void tst_QNetworkReply::putToHttpMultipart()
2667 {
2668     QSKIP("test server script cannot handle PUT data yet");
2669     QFETCH(QUrl, url);
2670 
2671     static QSet<QByteArray> boundaries;
2672 
2673     QNetworkRequest request(url);
2674     QNetworkReplyPtr reply;
2675 
2676     QFETCH(QHttpMultiPart *, multiPart);
2677     QFETCH(QByteArray, expectedReplyData);
2678     QFETCH(QByteArray, contentType);
2679 
2680     // hack for testing the setting of the content-type header by hand:
2681     if (contentType == "custom") {
2682         QByteArray contentType("multipart/custom; boundary=\"" + multiPart->boundary() + "\"");
2683         request.setHeader(QNetworkRequest::ContentTypeHeader, contentType);
2684     }
2685 
2686     QVERIFY2(! boundaries.contains(multiPart->boundary()), "boundary '" + multiPart->boundary() + "' has been created twice");
2687     boundaries.insert(multiPart->boundary());
2688 
2689     RUN_REQUEST(runMultipartRequest(request, reply, multiPart, "PUT"));
2690     multiPart->deleteLater();
2691 
2692     QCOMPARE(reply->url(), url);
2693     QCOMPARE(reply->error(), QNetworkReply::NoError);
2694 
2695     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2696 
2697     QVERIFY(multiPart->boundary().count() > 20); // check that there is randomness after the "boundary_.oOo._" string
2698     QVERIFY(multiPart->boundary().count() < 70);
2699     QByteArray replyData = reply->readAll();
2700 
2701     expectedReplyData.prepend("content type: multipart/" + contentType + "; boundary=\"" + multiPart->boundary() + "\"\n");
2702 //    QEXPECT_FAIL("nested", "the server does not understand nested multipart messages", Continue); // see above
2703     QCOMPARE(replyData, expectedReplyData);
2704 }
2705 
2706 #ifndef QT_NO_SSL
2707 void tst_QNetworkReply::putToHttps_data()
2708 {
2709     uniqueExtension = createUniqueExtension();
2710     putToFile_data();
2711 }
2712 
2713 void tst_QNetworkReply::putToHttps()
2714 {
2715     QUrl url("https://" + QtNetworkSettings::serverName());
2716     url.setPath(QString("/dav/qnetworkaccess-putToHttp-%1-%2")
2717                 .arg(QTest::currentDataTag())
2718                 .arg(uniqueExtension));
2719 
2720     QNetworkRequest request(url);
2721     QList<QSslCertificate> certs = QSslCertificate::fromPath(testDataDir + certsFilePath);
2722     QSslConfiguration conf;
2723     conf.setCaCertificates(certs);
2724     request.setSslConfiguration(conf);
2725     QNetworkReplyPtr reply;
2726 
2727     QFETCH(QByteArray, data);
2728 
2729     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PutOperation, request, reply, data));
2730 
2731     QCOMPARE(reply->url(), url);
2732     QCOMPARE(reply->error(), QNetworkReply::NoError);
2733 
2734     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 201); // 201 Created
2735 
2736     // download the file again from HTTP to make sure it was uploaded
2737     // correctly. HTTP/0.9 is enough
2738     QTcpSocket socket;
2739     socket.connectToHost(QtNetworkSettings::serverName(), 80);
2740     socket.write("GET " + url.toEncoded(QUrl::RemoveScheme | QUrl::RemoveAuthority) + "\r\n");
2741     if (!socket.waitForDisconnected(10000))
2742         QFAIL("Network timeout");
2743 
2744     QByteArray uploadedData = socket.readAll();
2745     QCOMPARE(uploadedData, data);
2746 }
2747 
2748 void tst_QNetworkReply::putToHttpsSynchronous_data()
2749 {
2750     uniqueExtension = createUniqueExtension();
2751     putToFile_data();
2752 }
2753 
2754 void tst_QNetworkReply::putToHttpsSynchronous()
2755 {
2756     QUrl url("https://" + QtNetworkSettings::serverName());
2757     url.setPath(QString("/dav/qnetworkaccess-putToHttp-%1-%2")
2758                 .arg(QTest::currentDataTag())
2759                 .arg(uniqueExtension));
2760 
2761     QNetworkRequest request(url);
2762     QList<QSslCertificate> certs = QSslCertificate::fromPath(testDataDir + certsFilePath);
2763     QSslConfiguration conf;
2764     conf.setCaCertificates(certs);
2765     request.setSslConfiguration(conf);
2766     QNetworkReplyPtr reply;
2767 
2768     QFETCH(QByteArray, data);
2769 
2770     request.setAttribute(
2771                 QNetworkRequest::SynchronousRequestAttribute,
2772                 true);
2773 
2774     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PutOperation, request, reply, data));
2775 
2776     QCOMPARE(reply->url(), url);
2777     QCOMPARE(reply->error(), QNetworkReply::NoError);
2778 
2779     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 201); // 201 Created
2780 
2781     // download the file again from HTTP to make sure it was uploaded
2782     // correctly. HTTP/0.9 is enough
2783     QTcpSocket socket;
2784     socket.connectToHost(QtNetworkSettings::serverName(), 80);
2785     socket.write("GET " + url.toEncoded(QUrl::RemoveScheme | QUrl::RemoveAuthority) + "\r\n");
2786     if (!socket.waitForDisconnected(10000))
2787         QFAIL("Network timeout");
2788 
2789     QByteArray uploadedData = socket.readAll();
2790     QCOMPARE(uploadedData, data);
2791 }
2792 
2793 void tst_QNetworkReply::postToHttps_data()
2794 {
2795     putToFile_data();
2796 }
2797 
2798 void tst_QNetworkReply::postToHttps()
2799 {
2800     QUrl url("https://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi");
2801 
2802     QNetworkRequest request(url);
2803     QList<QSslCertificate> certs = QSslCertificate::fromPath(testDataDir + certsFilePath);
2804     QSslConfiguration conf;
2805     conf.setCaCertificates(certs);
2806     request.setSslConfiguration(conf);
2807     request.setRawHeader("Content-Type", "application/octet-stream");
2808     QNetworkReplyPtr reply;
2809 
2810     QFETCH(QByteArray, data);
2811 
2812     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PostOperation, request, reply, data));
2813 
2814     QCOMPARE(reply->url(), url);
2815     QCOMPARE(reply->error(), QNetworkReply::NoError);
2816 
2817     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2818 
2819     QFETCH(QByteArray, md5sum);
2820     QByteArray uploadedData = reply->readAll().trimmed();
2821     QCOMPARE(uploadedData, md5sum.toHex());
2822 }
2823 
2824 void tst_QNetworkReply::postToHttpsSynchronous_data()
2825 {
2826     putToFile_data();
2827 }
2828 
2829 void tst_QNetworkReply::postToHttpsSynchronous()
2830 {
2831     QUrl url("https://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi");
2832 
2833     QNetworkRequest request(url);
2834     QList<QSslCertificate> certs = QSslCertificate::fromPath(testDataDir + certsFilePath);
2835     QSslConfiguration conf;
2836     conf.setCaCertificates(certs);
2837     request.setSslConfiguration(conf);
2838     request.setRawHeader("Content-Type", "application/octet-stream");
2839 
2840     request.setAttribute(
2841                 QNetworkRequest::SynchronousRequestAttribute,
2842                 true);
2843 
2844     QNetworkReplyPtr reply;
2845 
2846     QFETCH(QByteArray, data);
2847 
2848     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PostOperation, request, reply, data));
2849 
2850     QCOMPARE(reply->url(), url);
2851     QCOMPARE(reply->error(), QNetworkReply::NoError);
2852 
2853     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2854 
2855     QFETCH(QByteArray, md5sum);
2856     QByteArray uploadedData = reply->readAll().trimmed();
2857     QCOMPARE(uploadedData, md5sum.toHex());
2858 }
2859 
2860 void tst_QNetworkReply::postToHttpsMultipart_data()
2861 {
2862     postToHttpMultipart_data();
2863 }
2864 
2865 void tst_QNetworkReply::postToHttpsMultipart()
2866 {
2867     QFETCH(QUrl, url);
2868     url.setScheme("https");
2869 
2870     static QSet<QByteArray> boundaries;
2871 
2872     QNetworkRequest request(url);
2873     QList<QSslCertificate> certs = QSslCertificate::fromPath(testDataDir + certsFilePath);
2874     QSslConfiguration conf;
2875     conf.setCaCertificates(certs);
2876     request.setSslConfiguration(conf);
2877     QNetworkReplyPtr reply;
2878 
2879     QFETCH(QHttpMultiPart *, multiPart);
2880     QFETCH(QByteArray, expectedReplyData);
2881     QFETCH(QByteArray, contentType);
2882 
2883     // hack for testing the setting of the content-type header by hand:
2884     if (contentType == "custom") {
2885         QByteArray contentType("multipart/custom; boundary=\"" + multiPart->boundary() + '"');
2886         request.setHeader(QNetworkRequest::ContentTypeHeader, contentType);
2887     }
2888 
2889     QVERIFY2(! boundaries.contains(multiPart->boundary()), "boundary '" + multiPart->boundary() + "' has been created twice");
2890     boundaries.insert(multiPart->boundary());
2891 
2892     RUN_REQUEST(runMultipartRequest(request, reply, multiPart, "POST"));
2893     multiPart->deleteLater();
2894 
2895     QCOMPARE(reply->url(), url);
2896     QCOMPARE(reply->error(), QNetworkReply::NoError);
2897 
2898     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
2899 
2900     QVERIFY(multiPart->boundary().count() > 20); // check that there is randomness after the "boundary_.oOo._" string
2901     QVERIFY(multiPart->boundary().count() < 70);
2902     QByteArray replyData = reply->readAll();
2903 
2904     expectedReplyData.prepend("content type: multipart/" + contentType + "; boundary=\"" + multiPart->boundary() + "\"\n");
2905     QCOMPARE(replyData, expectedReplyData);
2906 }
2907 
2908 #endif // QT_NO_SSL
2909 
2910 void tst_QNetworkReply::deleteFromHttp_data()
2911 {
2912     QTest::addColumn<QUrl>("url");
2913     QTest::addColumn<int>("resultCode");
2914     QTest::addColumn<QNetworkReply::NetworkError>("error");
2915 
2916     // for status codes to expect, see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
2917 
2918     QTest::newRow("405-method-not-allowed") << QUrl("http://" + QtNetworkSettings::serverName() + "/index.html") << 405 << QNetworkReply::ContentOperationNotPermittedError;
2919     QTest::newRow("200-ok") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/http-delete.cgi?200-ok") << 200 << QNetworkReply::NoError;
2920     QTest::newRow("202-accepted") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/http-delete.cgi?202-accepted") << 202 << QNetworkReply::NoError;
2921     QTest::newRow("204-no-content") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/http-delete.cgi?204-no-content") << 204 << QNetworkReply::NoError;
2922     QTest::newRow("404-not-found") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/http-delete.cgi?404-not-found") << 404 << QNetworkReply::ContentNotFoundError;
2923 }
2924 
2925 void tst_QNetworkReply::deleteFromHttp()
2926 {
2927     QFETCH(QUrl, url);
2928     QFETCH(int, resultCode);
2929     QFETCH(QNetworkReply::NetworkError, error);
2930     QNetworkRequest request(url);
2931     QNetworkReplyPtr reply;
2932     runSimpleRequest(QNetworkAccessManager::DeleteOperation, request, reply, 0);
2933     QCOMPARE(reply->url(), url);
2934     QCOMPARE(reply->error(), error);
2935     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), resultCode);
2936 }
2937 
2938 void tst_QNetworkReply::putGetDeleteGetFromHttp_data()
2939 {
2940     QTest::addColumn<QUrl>("putUrl");
2941     QTest::addColumn<int>("putResultCode");
2942     QTest::addColumn<QNetworkReply::NetworkError>("putError");
2943     QTest::addColumn<QUrl>("deleteUrl");
2944     QTest::addColumn<int>("deleteResultCode");
2945     QTest::addColumn<QNetworkReply::NetworkError>("deleteError");
2946     QTest::addColumn<QUrl>("get2Url");
2947     QTest::addColumn<int>("get2ResultCode");
2948     QTest::addColumn<QNetworkReply::NetworkError>("get2Error");
2949 
2950     QUrl url("http://" + QtNetworkSettings::serverName());
2951     url.setPath(QString("/dav/qnetworkaccess-putToHttp-%1-%2")
2952                 .arg(QTest::currentDataTag())
2953                 .arg(uniqueExtension));
2954 
2955     // first use case: put, get (to check it is there), delete, get (to check it is not there anymore)
2956     QTest::newRow("success") << url << 201 << QNetworkReply::NoError << url << 204 << QNetworkReply::NoError << url << 404 << QNetworkReply::ContentNotFoundError;
2957 
2958     QUrl wrongUrl("http://" + QtNetworkSettings::serverName());
2959     wrongUrl.setPath(QString("/dav/qnetworkaccess-thisURLisNotAvailable"));
2960 
2961     // second use case: put, get (to check it is there), delete wrong URL, get (to check it is still there)
2962     QTest::newRow("delete-error") << url << 201 << QNetworkReply::NoError << wrongUrl << 404 << QNetworkReply::ContentNotFoundError << url << 200 << QNetworkReply::NoError;
2963 
2964 }
2965 
2966 void tst_QNetworkReply::putGetDeleteGetFromHttp()
2967 {
2968     QFETCH(QUrl, putUrl);
2969     QFETCH(int, putResultCode);
2970     QFETCH(QNetworkReply::NetworkError, putError);
2971     QFETCH(QUrl, deleteUrl);
2972     QFETCH(int, deleteResultCode);
2973     QFETCH(QNetworkReply::NetworkError, deleteError);
2974     QFETCH(QUrl, get2Url);
2975     QFETCH(int, get2ResultCode);
2976     QFETCH(QNetworkReply::NetworkError, get2Error);
2977 
2978     QNetworkRequest putRequest(putUrl);
2979     QNetworkRequest deleteRequest(deleteUrl);
2980     QNetworkRequest get2Request(get2Url);
2981     QNetworkReplyPtr reply;
2982 
2983     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PutOperation, putRequest, reply, 0));
2984     QCOMPARE(reply->error(), putError);
2985     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), putResultCode);
2986 
2987     runSimpleRequest(QNetworkAccessManager::GetOperation, putRequest, reply, 0);
2988     QCOMPARE(reply->error(), QNetworkReply::NoError);
2989     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
2990 
2991     runSimpleRequest(QNetworkAccessManager::DeleteOperation, deleteRequest, reply, 0);
2992     QCOMPARE(reply->error(), deleteError);
2993     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), deleteResultCode);
2994 
2995     runSimpleRequest(QNetworkAccessManager::GetOperation, get2Request, reply, 0);
2996     QCOMPARE(reply->error(), get2Error);
2997     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), get2ResultCode);
2998 
2999 }
3000 
3001 void tst_QNetworkReply::connectToIPv6Address_data()
3002 {
3003     QTest::addColumn<QUrl>("url");
3004     QTest::addColumn<QNetworkReply::NetworkError>("error");
3005     QTest::addColumn<QByteArray>("dataToSend");
3006     QTest::addColumn<QByteArray>("hostfield");
3007     QTest::newRow("localhost") << QUrl(QByteArray("http://[::1]")) << QNetworkReply::NoError<< QByteArray("localhost") << QByteArray("[::1]");
3008     //QTest::newRow("ipv4localhost") << QUrl(QByteArray("http://127.0.0.1")) << QNetworkReply::NoError<< QByteArray("ipv4localhost") << QByteArray("127.0.0.1");
3009     //to add more test data here
3010 }
3011 
3012 void tst_QNetworkReply::connectToIPv6Address()
3013 {
3014     QFETCH(QUrl, url);
3015     QFETCH(QNetworkReply::NetworkError, error);
3016     QFETCH(QByteArray, dataToSend);
3017     QFETCH(QByteArray, hostfield);
3018 
3019     if (!QtNetworkSettings::hasIPv6())
3020         QSKIP("system doesn't support ipv6!");
3021 
3022     QByteArray httpResponse = QByteArray("HTTP/1.0 200 OK\r\nContent-Length: ");
3023     httpResponse += QByteArray::number(dataToSend.size());
3024     httpResponse += "\r\n\r\n";
3025     httpResponse += dataToSend;
3026 
3027     MiniHttpServer server(httpResponse, false, NULL/*thread*/, true/*useipv6*/);
3028     server.doClose = true;
3029 
3030     url.setPort(server.serverPort());
3031     QNetworkRequest request(url);
3032 
3033     QNetworkReplyPtr reply(manager.get(request));
3034     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3035     QByteArray content = reply->readAll();
3036     //qDebug() << server.receivedData;
3037     QByteArray hostinfo = "\r\nHost: " + hostfield + ':' + QByteArray::number(server.serverPort()) + "\r\n";
3038     QVERIFY(server.receivedData.contains(hostinfo));
3039     QCOMPARE(content, dataToSend);
3040     QCOMPARE(reply->url(), request.url());
3041     QCOMPARE(reply->error(), error);
3042 }
3043 
3044 void tst_QNetworkReply::sendCustomRequestToHttp_data()
3045 {
3046     QTest::addColumn<QUrl>("url");
3047     QTest::addColumn<QByteArray>("verb");
3048     QTest::addColumn<QBuffer *>("device");
3049     QTest::addColumn<int>("resultCode");
3050     QTest::addColumn<QNetworkReply::NetworkError>("error");
3051     QTest::addColumn<QByteArray>("expectedContent");
3052 
3053     QTest::newRow("options") << QUrl("http://" + QtNetworkSettings::serverName()) <<
3054             QByteArray("OPTIONS") << (QBuffer *) 0 << 200 << QNetworkReply::NoError << QByteArray();
3055     QTest::newRow("trace") << QUrl("http://" + QtNetworkSettings::serverName()) <<
3056             QByteArray("TRACE") << (QBuffer *) 0 << 200 << QNetworkReply::NoError << QByteArray();
3057     QTest::newRow("connect") << QUrl("http://" + QtNetworkSettings::serverName()) <<
3058             QByteArray("CONNECT") << (QBuffer *) 0 << 400 << QNetworkReply::ProtocolInvalidOperationError << QByteArray(); // 400 = Bad Request
3059     QTest::newRow("nonsense") << QUrl("http://" + QtNetworkSettings::serverName()) <<
3060             QByteArray("NONSENSE") << (QBuffer *) 0 << 501 << QNetworkReply::OperationNotImplementedError << QByteArray(); // 501 = Method Not Implemented
3061 
3062     QByteArray ba("test");
3063     QBuffer *buffer = new QBuffer;
3064     buffer->setData(ba);
3065     buffer->open(QIODevice::ReadOnly);
3066     QTest::newRow("post") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi") << QByteArray("POST")
3067             << buffer << 200 << QNetworkReply::NoError << QByteArray("098f6bcd4621d373cade4e832627b4f6\n");
3068 
3069     QByteArray ba2("test");
3070     QBuffer *buffer2 = new QBuffer;
3071     buffer2->setData(ba2);
3072     buffer2->open(QIODevice::ReadOnly);
3073     QTest::newRow("put") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi") << QByteArray("PUT")
3074             << buffer2 << 200 << QNetworkReply::NoError << QByteArray("098f6bcd4621d373cade4e832627b4f6\n");
3075 }
3076 
3077 void tst_QNetworkReply::sendCustomRequestToHttp()
3078 {
3079     QFETCH(QUrl, url);
3080     QNetworkRequest request(url);
3081     QNetworkReplyPtr reply;
3082     QFETCH(QByteArray, verb);
3083     QFETCH(QBuffer *, device);
3084     runCustomRequest(request, reply, verb, device);
3085     QCOMPARE(reply->url(), url);
3086     QFETCH(QNetworkReply::NetworkError, error);
3087     QCOMPARE(reply->error(), error);
3088     QFETCH(int, resultCode);
3089     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), resultCode);
3090     QFETCH(QByteArray, expectedContent);
3091     if (! expectedContent.isEmpty())
3092         QCOMPARE(reply->readAll(), expectedContent);
3093 }
3094 
3095 void tst_QNetworkReply::ioGetFromData_data()
3096 {
3097     QTest::addColumn<QString>("urlStr");
3098     QTest::addColumn<QByteArray>("data");
3099 
3100     QTest::newRow("data-empty") << "data:," << QByteArray();
3101     QTest::newRow("data-literal") << "data:,foo" << QByteArray("foo");
3102     QTest::newRow("data-pct") << "data:,%3Cbody%20contentEditable%3Dtrue%3E%0D%0A"
3103                            << QByteArray("<body contentEditable=true>\r\n");
3104     QTest::newRow("data-base64") << "data:;base64,UXQgaXMgZ3JlYXQh" << QByteArray("Qt is great!");
3105 }
3106 
3107 void tst_QNetworkReply::ioGetFromData()
3108 {
3109     QFETCH(QString, urlStr);
3110 
3111     QUrl url = QUrl::fromEncoded(urlStr.toLatin1());
3112     QNetworkRequest request(url);
3113 
3114     QNetworkReplyPtr reply(manager.get(request));
3115     DataReader reader(reply);
3116 
3117     connect(reply, SIGNAL(finished()),
3118             &QTestEventLoop::instance(), SLOT(exitLoop()));
3119     QTestEventLoop::instance().enterLoop(10);
3120     QVERIFY(!QTestEventLoop::instance().timeout());
3121 
3122     QCOMPARE(reply->url(), request.url());
3123     QCOMPARE(reply->error(), QNetworkReply::NoError);
3124 
3125     QFETCH(QByteArray, data);
3126     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toInt(), data.size());
3127     QCOMPARE(reader.data.size(), data.size());
3128     QCOMPARE(reader.data, data);
3129 }
3130 
3131 void tst_QNetworkReply::ioGetFromFileSpecial_data()
3132 {
3133     getFromFileSpecial_data();
3134 }
3135 
3136 void tst_QNetworkReply::ioGetFromFileSpecial()
3137 {
3138     QFETCH(QString, fileName);
3139     QFETCH(QString, url);
3140 
3141     QFile resource(fileName);
3142     QVERIFY(resource.open(QIODevice::ReadOnly));
3143 
3144     QNetworkRequest request;
3145     request.setUrl(url);
3146     QNetworkReplyPtr reply(manager.get(request));
3147     DataReader reader(reply);
3148 
3149     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
3150     QTestEventLoop::instance().enterLoop(10);
3151     QVERIFY(!QTestEventLoop::instance().timeout());
3152 
3153     QCOMPARE(reply->url(), request.url());
3154     QCOMPARE(reply->error(), QNetworkReply::NoError);
3155 
3156     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), resource.size());
3157     QCOMPARE(qint64(reader.data.size()), resource.size());
3158     QCOMPARE(reader.data, resource.readAll());
3159 }
3160 
3161 void tst_QNetworkReply::ioGetFromFile_data()
3162 {
3163     putToFile_data();
3164 }
3165 
3166 void tst_QNetworkReply::ioGetFromFile()
3167 {
3168     QTemporaryFile file(QDir::currentPath() + "/temp-XXXXXX");
3169     file.setAutoRemove(true);
3170     QVERIFY2(file.open(), qPrintable(file.errorString()));
3171 
3172     QFETCH(QByteArray, data);
3173     QCOMPARE(file.write(data), data.size());
3174     file.flush();
3175     QCOMPARE(file.size(), qint64(data.size()));
3176 
3177     QNetworkRequest request(QUrl::fromLocalFile(file.fileName()));
3178     QNetworkReplyPtr reply(manager.get(request));
3179     QVERIFY(reply->isFinished()); // a file should immediately be done
3180     DataReader reader(reply);
3181 
3182     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
3183     QTestEventLoop::instance().enterLoop(10);
3184     QVERIFY(!QTestEventLoop::instance().timeout());
3185 
3186     QCOMPARE(reply->url(), request.url());
3187     QCOMPARE(reply->error(), QNetworkReply::NoError);
3188 
3189     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), file.size());
3190     QCOMPARE(qint64(reader.data.size()), file.size());
3191     QCOMPARE(reader.data, data);
3192 }
3193 
3194 void tst_QNetworkReply::ioGetFromFtp_data()
3195 {
3196     QTest::addColumn<QString>("fileName");
3197     QTest::addColumn<qint64>("expectedSize");
3198 
3199     QTest::newRow("bigfile") << "bigfile" << Q_INT64_C(519240);
3200 
3201     QFile file(testDataDir + "/rfc3252.txt");
3202     QTest::newRow("rfc3252.txt") << "rfc3252.txt" << file.size();
3203 }
3204 
3205 void tst_QNetworkReply::ioGetFromFtp()
3206 {
3207     QFETCH(QString, fileName);
3208     QFile reference(fileName);
3209     reference.open(QIODevice::ReadOnly); // will fail for bigfile
3210 
3211     QNetworkRequest request("ftp://" + QtNetworkSettings::serverName() + "/qtest/" + fileName);
3212     QNetworkReplyPtr reply(manager.get(request));
3213     DataReader reader(reply);
3214 
3215     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3216 
3217     QCOMPARE(reply->url(), request.url());
3218     QCOMPARE(reply->error(), QNetworkReply::NoError);
3219 
3220     QFETCH(qint64, expectedSize);
3221     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), expectedSize);
3222     QCOMPARE(qint64(reader.data.size()), expectedSize);
3223 
3224     if (reference.isOpen())
3225         QCOMPARE(reader.data, reference.readAll());
3226 }
3227 
3228 void tst_QNetworkReply::ioGetFromFtpWithReuse()
3229 {
3230     QString fileName = testDataDir + "/rfc3252.txt";
3231     QFile reference(fileName);
3232     reference.open(QIODevice::ReadOnly);
3233 
3234     QNetworkRequest request(QUrl("ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3235 
3236     // two concurrent (actually, consecutive) gets:
3237     QNetworkReplyPtr reply1(manager.get(request));
3238     DataReader reader1(reply1);
3239     QNetworkReplyPtr reply2(manager.get(request));
3240     DataReader reader2(reply2);
3241     QSignalSpy spy(reply1.data(), SIGNAL(finished()));
3242 
3243     QCOMPARE(waitForFinish(reply1), int(Success));
3244     QCOMPARE(waitForFinish(reply2), int(Success));
3245 
3246     QCOMPARE(reply1->url(), request.url());
3247     QCOMPARE(reply2->url(), request.url());
3248     QCOMPARE(reply1->error(), QNetworkReply::NoError);
3249     QCOMPARE(reply2->error(), QNetworkReply::NoError);
3250 
3251     QCOMPARE(qint64(reader1.data.size()), reference.size());
3252     QCOMPARE(qint64(reader2.data.size()), reference.size());
3253     QCOMPARE(reply1->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
3254     QCOMPARE(reply2->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
3255 
3256     QByteArray referenceData = reference.readAll();
3257     QCOMPARE(reader1.data, referenceData);
3258     QCOMPARE(reader2.data, referenceData);
3259 }
3260 
3261 void tst_QNetworkReply::ioGetFromHttp()
3262 {
3263     QFile reference(testDataDir + "/rfc3252.txt");
3264     QVERIFY(reference.open(QIODevice::ReadOnly));
3265 
3266     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3267     QNetworkReplyPtr reply(manager.get(request));
3268     DataReader reader(reply);
3269 
3270     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3271 
3272     QCOMPARE(reply->url(), request.url());
3273     QCOMPARE(reply->error(), QNetworkReply::NoError);
3274     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3275 
3276     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
3277     QCOMPARE(qint64(reader.data.size()), reference.size());
3278 
3279     QCOMPARE(reader.data, reference.readAll());
3280 }
3281 
3282 void tst_QNetworkReply::ioGetFromHttpWithReuseParallel()
3283 {
3284     QFile reference(testDataDir + "/rfc3252.txt");
3285     QVERIFY(reference.open(QIODevice::ReadOnly));
3286 
3287     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3288     QNetworkReplyPtr reply1(manager.get(request));
3289     QNetworkReplyPtr reply2(manager.get(request));
3290     DataReader reader1(reply1);
3291     DataReader reader2(reply2);
3292     QSignalSpy spy(reply1.data(), SIGNAL(finished()));
3293 
3294     QCOMPARE(waitForFinish(reply2), int(Success));
3295     QCOMPARE(waitForFinish(reply1), int(Success));
3296 
3297     QCOMPARE(reply1->url(), request.url());
3298     QCOMPARE(reply2->url(), request.url());
3299     QCOMPARE(reply1->error(), QNetworkReply::NoError);
3300     QCOMPARE(reply2->error(), QNetworkReply::NoError);
3301     QCOMPARE(reply1->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3302     QCOMPARE(reply2->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3303 
3304     QCOMPARE(reply1->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
3305     QCOMPARE(reply2->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
3306     QCOMPARE(qint64(reader1.data.size()), reference.size());
3307     QCOMPARE(qint64(reader2.data.size()), reference.size());
3308 
3309     QByteArray referenceData = reference.readAll();
3310     QCOMPARE(reader1.data, referenceData);
3311     QCOMPARE(reader2.data, referenceData);
3312 }
3313 
3314 void tst_QNetworkReply::ioGetFromHttpWithReuseSequential()
3315 {
3316     QFile reference(testDataDir + "/rfc3252.txt");
3317     QVERIFY(reference.open(QIODevice::ReadOnly));
3318 
3319     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3320     {
3321         QNetworkReplyPtr reply(manager.get(request));
3322         DataReader reader(reply);
3323 
3324         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3325 
3326         QCOMPARE(reply->url(), request.url());
3327         QCOMPARE(reply->error(), QNetworkReply::NoError);
3328         QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3329 
3330         QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
3331         QCOMPARE(qint64(reader.data.size()), reference.size());
3332 
3333         QCOMPARE(reader.data, reference.readAll());
3334     }
3335 
3336     reference.seek(0);
3337     // rinse and repeat:
3338     {
3339         QNetworkReplyPtr reply(manager.get(request));
3340         DataReader reader(reply);
3341 
3342         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3343 
3344         QCOMPARE(reply->url(), request.url());
3345         QCOMPARE(reply->error(), QNetworkReply::NoError);
3346         QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3347 
3348         QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
3349         QCOMPARE(qint64(reader.data.size()), reference.size());
3350 
3351         QCOMPARE(reader.data, reference.readAll());
3352     }
3353 }
3354 
3355 void tst_QNetworkReply::ioGetFromHttpWithAuth_data()
3356 {
3357     QTest::addColumn<QUrl>("url");
3358     QTest::addColumn<QByteArray>("expectedData");
3359     QTest::addColumn<int>("expectedAuth");
3360 
3361     QFile reference(testDataDir + "/rfc3252.txt");
3362     reference.open(QIODevice::ReadOnly);
3363     QByteArray referenceData = reference.readAll();
3364     QTest::newRow("basic") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt") << referenceData << 1;
3365     QTest::newRow("digest") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/auth-digest/") << QByteArray("digest authentication successful\n") << 1;
3366     //if url contains username & password, then it should be used
3367     QTest::newRow("basic-in-url") << QUrl("http://httptest:httptest@" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt") << referenceData << 0;
3368     QTest::newRow("digest-in-url") << QUrl("http://httptest:httptest@" + QtNetworkSettings::serverName() + "/qtest/auth-digest/") << QByteArray("digest authentication successful\n") << 0;
3369     // if url contains incorrect credentials, expect QNAM to ask for good ones (even if cached - matches behaviour of browsers)
3370     QTest::newRow("basic-bad-user-in-url") << QUrl("http://baduser:httptest@" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt") << referenceData << 3;
3371     QTest::newRow("basic-bad-password-in-url") << QUrl("http://httptest:wrong@" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt") << referenceData << 3;
3372     QTest::newRow("digest-bad-user-in-url") << QUrl("http://baduser:httptest@" + QtNetworkSettings::serverName() + "/qtest/auth-digest/") << QByteArray("digest authentication successful\n") << 3;
3373     QTest::newRow("digest-bad-password-in-url") << QUrl("http://httptest:wrong@" + QtNetworkSettings::serverName() + "/qtest/auth-digest/") << QByteArray("digest authentication successful\n") << 3;
3374 }
3375 
3376 void tst_QNetworkReply::ioGetFromHttpWithAuth()
3377 {
3378     // This test sends three requests
3379     // The first two in parallel
3380     // The third after the first two finished
3381 
3382     QFETCH(QUrl, url);
3383     QFETCH(QByteArray, expectedData);
3384     QFETCH(int, expectedAuth);
3385     QNetworkRequest request(url);
3386     {
3387         QNetworkReplyPtr reply1(manager.get(request));
3388         QNetworkReplyPtr reply2(manager.get(request));
3389         DataReader reader1(reply1);
3390         DataReader reader2(reply2);
3391         QSignalSpy finishedspy(reply1.data(), SIGNAL(finished()));
3392 
3393         QSignalSpy authspy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3394         connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
3395                 SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3396 
3397         QCOMPARE(waitForFinish(reply2), int(Success));
3398         QCOMPARE(waitForFinish(reply1), int(Success));
3399 
3400         manager.disconnect(SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
3401                            this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3402 
3403         QCOMPARE(reply1->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3404         QCOMPARE(reply2->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3405         QCOMPARE(reader1.data, expectedData);
3406         QCOMPARE(reader2.data, expectedData);
3407 
3408         QCOMPARE(authspy.count(), (expectedAuth ? 1 : 0));
3409         expectedAuth = qMax(0, expectedAuth - 1);
3410     }
3411 
3412     // rinse and repeat:
3413     {
3414         QNetworkReplyPtr reply(manager.get(request));
3415         DataReader reader(reply);
3416 
3417         QSignalSpy authspy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3418         connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
3419                 SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3420 
3421         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3422 
3423         manager.disconnect(SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
3424                            this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3425 
3426         QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3427         QCOMPARE(reader.data, expectedData);
3428 
3429         QCOMPARE(authspy.count(), (expectedAuth ? 1 : 0));
3430         expectedAuth = qMax(0, expectedAuth - 1);
3431     }
3432 
3433     // now check with synchronous calls:
3434     {
3435         request.setAttribute(
3436                 QNetworkRequest::SynchronousRequestAttribute,
3437                 true);
3438 
3439         QSignalSpy authspy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3440         QNetworkReplyPtr replySync(manager.get(request));
3441         QVERIFY(replySync->isFinished()); // synchronous
3442         if (expectedAuth) {
3443             // bad credentials in a synchronous request should just fail
3444             QCOMPARE(replySync->error(), QNetworkReply::AuthenticationRequiredError);
3445         } else {
3446             QCOMPARE(authspy.count(), 0);
3447 
3448             // we cannot use a data reader here, since that connects to the readyRead signal,
3449             // just use readAll()
3450 
3451             // the only thing we check here is that the auth cache was used when using synchronous requests
3452             QCOMPARE(replySync->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3453             QCOMPARE(replySync->readAll(), expectedData);
3454         }
3455     }
3456 
3457     // check that credentials are used from cache if the same url is requested without credentials
3458     {
3459         url.setUserInfo(QString());
3460         request.setUrl(url);
3461         request.setAttribute(
3462                 QNetworkRequest::SynchronousRequestAttribute,
3463                 true);
3464 
3465         QSignalSpy authspy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3466         QNetworkReplyPtr replySync(manager.get(request));
3467         QVERIFY(replySync->isFinished()); // synchronous
3468         if (expectedAuth) {
3469             // bad credentials in a synchronous request should just fail
3470             QCOMPARE(replySync->error(), QNetworkReply::AuthenticationRequiredError);
3471         } else {
3472             QCOMPARE(authspy.count(), 0);
3473 
3474             // we cannot use a data reader here, since that connects to the readyRead signal,
3475             // just use readAll()
3476 
3477             // the only thing we check here is that the auth cache was used when using synchronous requests
3478             QCOMPARE(replySync->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3479             QCOMPARE(replySync->readAll(), expectedData);
3480         }
3481     }
3482 }
3483 
3484 void tst_QNetworkReply::ioGetFromHttpWithAuthSynchronous()
3485 {
3486     // verify that we do not enter an endless loop with synchronous calls and wrong credentials
3487     // the case when we succeed with the login is tested in ioGetFromHttpWithAuth()
3488 
3489     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt"));
3490     request.setAttribute(
3491             QNetworkRequest::SynchronousRequestAttribute,
3492             true);
3493 
3494     QSignalSpy authspy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
3495     QNetworkReplyPtr replySync(manager.get(request));
3496     QVERIFY(replySync->isFinished()); // synchronous
3497     QCOMPARE(replySync->error(), QNetworkReply::AuthenticationRequiredError);
3498     QCOMPARE(authspy.count(), 0);
3499     QCOMPARE(replySync->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 401);
3500 }
3501 
3502 #ifndef QT_NO_NETWORKPROXY
3503 void tst_QNetworkReply::ioGetFromHttpWithProxyAuth()
3504 {
3505     // This test sends three requests
3506     // The first two in parallel
3507     // The third after the first two finished
3508     QFile reference(testDataDir + "/rfc3252.txt");
3509     QVERIFY(reference.open(QIODevice::ReadOnly));
3510 
3511     QNetworkProxy proxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129);
3512     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3513     {
3514         manager.setProxy(proxy);
3515         QNetworkReplyPtr reply1(manager.get(request));
3516         QNetworkReplyPtr reply2(manager.get(request));
3517         manager.setProxy(QNetworkProxy());
3518 
3519         DataReader reader1(reply1);
3520         DataReader reader2(reply2);
3521         QSignalSpy finishedspy(reply1.data(), SIGNAL(finished()));
3522 
3523         QSignalSpy authspy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3524         connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3525                 SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3526 
3527         QCOMPARE(waitForFinish(reply2), int(Success));
3528         QCOMPARE(waitForFinish(reply1), int(Success));
3529 
3530         manager.disconnect(SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3531                            this, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3532 
3533         QCOMPARE(reply1->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3534         QCOMPARE(reply2->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3535         QByteArray referenceData = reference.readAll();
3536         QCOMPARE(reader1.data, referenceData);
3537         QCOMPARE(reader2.data, referenceData);
3538 
3539         QCOMPARE(authspy.count(), 1);
3540     }
3541 
3542     reference.seek(0);
3543     // rinse and repeat:
3544     {
3545         manager.setProxy(proxy);
3546         QNetworkReplyPtr reply(manager.get(request));
3547         DataReader reader(reply);
3548         manager.setProxy(QNetworkProxy());
3549 
3550         QSignalSpy authspy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3551         connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3552                 SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3553 
3554         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3555 
3556         manager.disconnect(SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3557                            this, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3558 
3559         QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3560         QCOMPARE(reader.data, reference.readAll());
3561 
3562         QCOMPARE(authspy.count(), 0);
3563     }
3564 
3565     // now check with synchronous calls:
3566     reference.seek(0);
3567     {
3568         request.setAttribute(
3569                 QNetworkRequest::SynchronousRequestAttribute,
3570                 true);
3571 
3572         QSignalSpy authspy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3573         QNetworkReplyPtr replySync(manager.get(request));
3574         QVERIFY(replySync->isFinished()); // synchronous
3575         QCOMPARE(authspy.count(), 0);
3576 
3577         // we cannot use a data reader here, since that connects to the readyRead signal,
3578         // just use readAll()
3579 
3580         // the only thing we check here is that the proxy auth cache was used when using synchronous requests
3581         QCOMPARE(replySync->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3582         QCOMPARE(replySync->readAll(), reference.readAll());
3583     }
3584 }
3585 
3586 void tst_QNetworkReply::ioGetFromHttpWithProxyAuthSynchronous()
3587 {
3588     // verify that we do not enter an endless loop with synchronous calls and wrong credentials
3589     // the case when we succeed with the login is tested in ioGetFromHttpWithAuth()
3590 
3591     QNetworkProxy proxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129);
3592     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3593     manager.setProxy(proxy);
3594     request.setAttribute(
3595             QNetworkRequest::SynchronousRequestAttribute,
3596             true);
3597 
3598     QSignalSpy authspy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3599     QNetworkReplyPtr replySync(manager.get(request));
3600     manager.setProxy(QNetworkProxy()); // reset
3601     QVERIFY(replySync->isFinished()); // synchronous
3602     QCOMPARE(replySync->error(), QNetworkReply::ProxyAuthenticationRequiredError);
3603     QCOMPARE(authspy.count(), 0);
3604     QCOMPARE(replySync->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 407);
3605 }
3606 
3607 void tst_QNetworkReply::ioGetFromHttpWithSocksProxy()
3608 {
3609     // HTTP caching proxies are tested by the above function
3610     // test SOCKSv5 proxies too
3611 
3612     QFile reference(testDataDir + "/rfc3252.txt");
3613     QVERIFY(reference.open(QIODevice::ReadOnly));
3614 
3615 #ifdef QT_TEST_SERVER
3616     QNetworkProxy proxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(), 1082);
3617 #else
3618     QNetworkProxy proxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(), 1080);
3619 #endif
3620     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3621     {
3622         manager.setProxy(proxy);
3623         QNetworkReplyPtr reply(manager.get(request));
3624         DataReader reader(reply);
3625         manager.setProxy(QNetworkProxy());
3626 
3627         QSignalSpy authspy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3628         connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3629                 SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3630 
3631         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3632 
3633         manager.disconnect(SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3634                            this, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3635 
3636         QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3637         QCOMPARE(reader.data, reference.readAll());
3638 
3639         QCOMPARE(authspy.count(), 0);
3640     }
3641 
3642     // set an invalid proxy just to make sure that we can't load
3643     proxy = QNetworkProxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(), 1079);
3644     {
3645         manager.setProxy(proxy);
3646         QNetworkReplyPtr reply(manager.get(request));
3647         DataReader reader(reply);
3648         manager.setProxy(QNetworkProxy());
3649 
3650         QSignalSpy authspy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3651         connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3652                 SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3653 
3654         QCOMPARE(waitForFinish(reply), int(Failure));
3655 
3656         manager.disconnect(SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
3657                            this, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
3658 
3659         QVERIFY(!reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).isValid());
3660         QVERIFY(reader.data.isEmpty());
3661 
3662         QVERIFY(int(reply->error()) > 0);
3663         QEXPECT_FAIL("", "QTcpSocket doesn't return enough information yet", Continue);
3664         QCOMPARE(int(reply->error()), int(QNetworkReply::ProxyConnectionRefusedError));
3665 
3666         QCOMPARE(authspy.count(), 0);
3667     }
3668 }
3669 #endif // !QT_NO_NETWORKPROXY
3670 
3671 #ifndef QT_NO_SSL
3672 void tst_QNetworkReply::ioGetFromHttpsWithSslErrors()
3673 {
3674     QFile reference(testDataDir + "/rfc3252.txt");
3675     QVERIFY(reference.open(QIODevice::ReadOnly));
3676 
3677     QNetworkRequest request(QUrl("https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3678     QNetworkReplyPtr reply(manager.get(request));
3679     DataReader reader(reply);
3680 
3681     QSignalSpy sslspy(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)));
3682     connect(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
3683             SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
3684     connect(reply, SIGNAL(metaDataChanged()), SLOT(storeSslConfiguration()));
3685 
3686     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3687 
3688     manager.disconnect(SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
3689                        this, SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
3690 
3691     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3692     QCOMPARE(reader.data, reference.readAll());
3693 
3694     QCOMPARE(sslspy.count(), 1);
3695 
3696     QVERIFY(!storedSslConfiguration.isNull());
3697     QVERIFY(!reply->sslConfiguration().isNull());
3698 }
3699 
3700 void tst_QNetworkReply::ioGetFromHttpsWithIgnoreSslErrors()
3701 {
3702     // same as above, except that we call ignoreSslErrors and don't connect
3703     // to the sslErrors() signal (which is *still* emitted)
3704 
3705     QFile reference(testDataDir + "/rfc3252.txt");
3706     QVERIFY(reference.open(QIODevice::ReadOnly));
3707 
3708     QNetworkRequest request(QUrl("https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
3709 
3710     QNetworkReplyPtr reply(manager.get(request));
3711     reply->ignoreSslErrors();
3712     DataReader reader(reply);
3713 
3714     QSignalSpy sslspy(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)));
3715     connect(reply, SIGNAL(metaDataChanged()), SLOT(storeSslConfiguration()));
3716 
3717     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3718 
3719     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3720     QCOMPARE(reader.data, reference.readAll());
3721 
3722     QCOMPARE(sslspy.count(), 1);
3723 
3724     QVERIFY(!storedSslConfiguration.isNull());
3725     QVERIFY(!reply->sslConfiguration().isNull());
3726 }
3727 
3728 void tst_QNetworkReply::ioGetFromHttpsWithSslHandshakeError()
3729 {
3730     QFile reference(testDataDir + "/rfc3252.txt");
3731     QVERIFY(reference.open(QIODevice::ReadOnly));
3732 
3733     QNetworkRequest request(QUrl("https://" + QtNetworkSettings::serverName() + ":80"));
3734 
3735     QNetworkReplyPtr reply(manager.get(request));
3736     reply->ignoreSslErrors();
3737     DataReader reader(reply);
3738 
3739     QSignalSpy sslspy(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)));
3740     connect(reply, SIGNAL(metaDataChanged()), SLOT(storeSslConfiguration()));
3741 
3742     QCOMPARE(waitForFinish(reply), int(Failure));
3743 
3744     QCOMPARE(reply->error(), QNetworkReply::SslHandshakeFailedError);
3745     QCOMPARE(sslspy.count(), 0);
3746 }
3747 #endif
3748 
3749 void tst_QNetworkReply::ioGetFromHttpBrokenServer_data()
3750 {
3751     QTest::addColumn<QByteArray>("dataToSend");
3752     QTest::addColumn<bool>("doDisconnect");
3753 
3754     QTest::newRow("no-newline") << QByteArray("Hello World") << false;
3755 
3756     // these are OK now, we just eat the lonely newlines
3757     //QTest::newRow("just-newline") << QByteArray("\r\n") << false;
3758     //QTest::newRow("just-2newline") << QByteArray("\r\n\r\n") << false;
3759 
3760     QTest::newRow("with-newlines") << QByteArray("Long first line\r\nLong second line") << false;
3761     QTest::newRow("with-newlines2") << QByteArray("\r\nSecond line") << false;
3762     QTest::newRow("with-newlines3") << QByteArray("ICY\r\nSecond line") << false;
3763     QTest::newRow("invalid-version") << QByteArray("HTTP/123 200 \r\n") << false;
3764     QTest::newRow("invalid-version2") << QByteArray("HTTP/a.\033 200 \r\n") << false;
3765     QTest::newRow("invalid-reply-code") << QByteArray("HTTP/1.0 fuu \r\n") << false;
3766 
3767     QTest::newRow("empty+disconnect") << QByteArray() << true;
3768 
3769     QTest::newRow("no-newline+disconnect") << QByteArray("Hello World") << true;
3770     QTest::newRow("just-newline+disconnect") << QByteArray("\r\n") << true;
3771     QTest::newRow("just-2newline+disconnect") << QByteArray("\r\n\r\n") << true;
3772     QTest::newRow("with-newlines+disconnect") << QByteArray("Long first line\r\nLong second line") << true;
3773     QTest::newRow("with-newlines2+disconnect") << QByteArray("\r\nSecond line") << true;
3774     QTest::newRow("with-newlines3+disconnect") << QByteArray("ICY\r\nSecond line") << true;
3775 
3776     QTest::newRow("invalid-version+disconnect") << QByteArray("HTTP/123 200 ") << true;
3777     QTest::newRow("invalid-version2+disconnect") << QByteArray("HTTP/a.\033 200 ") << true;
3778     QTest::newRow("invalid-reply-code+disconnect") << QByteArray("HTTP/1.0 fuu ") << true;
3779 
3780     QTest::newRow("immediate disconnect") << QByteArray("") << true;
3781     QTest::newRow("justHalfStatus+disconnect") << QByteArray("HTTP/1.1") << true;
3782     QTest::newRow("justStatus+disconnect") << QByteArray("HTTP/1.1 200 OK\r\n") << true;
3783     QTest::newRow("justStatusAndHalfHeaders+disconnect") << QByteArray("HTTP/1.1 200 OK\r\nContent-L") << true;
3784 
3785     QTest::newRow("halfContent+disconnect") << QByteArray("HTTP/1.1 200 OK\r\nContent-Length: 4\r\n\r\nAB") << true;
3786 
3787 }
3788 
3789 void tst_QNetworkReply::ioGetFromHttpBrokenServer()
3790 {
3791     QFETCH(QByteArray, dataToSend);
3792     QFETCH(bool, doDisconnect);
3793     MiniHttpServer server(dataToSend);
3794     server.doClose = doDisconnect;
3795 
3796     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
3797     QNetworkReplyPtr reply(manager.get(request));
3798     QSignalSpy spy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
3799 
3800     QCOMPARE(waitForFinish(reply), int(Failure));
3801 
3802     QCOMPARE(reply->url(), request.url());
3803     QCOMPARE(spy.count(), 1);
3804     QVERIFY(reply->error() != QNetworkReply::NoError);
3805 }
3806 
3807 void tst_QNetworkReply::ioGetFromHttpStatus100_data()
3808 {
3809     QTest::addColumn<QByteArray>("dataToSend");
3810     QTest::addColumn<int>("statusCode");
3811     QTest::newRow("normal") << QByteArray("HTTP/1.1 100 Continue\r\n\r\nHTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n") << 200;
3812     QTest::newRow("minimal") << QByteArray("HTTP/1.1 100 Continue\n\nHTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n") << 200;
3813     QTest::newRow("minimal2") << QByteArray("HTTP/1.1 100 Continue\n\nHTTP/1.0 200 OK\r\n\r\n") << 200;
3814     QTest::newRow("minimal3") << QByteArray("HTTP/1.1 100 Continue\n\nHTTP/1.0 200 OK\n\n") << 200;
3815     QTest::newRow("minimal+404") << QByteArray("HTTP/1.1 100 Continue\n\nHTTP/1.0 204 No Content\r\n\r\n") << 204;
3816     QTest::newRow("with_headers") << QByteArray("HTTP/1.1 100 Continue\r\nBla: x\r\n\r\nHTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n") << 200;
3817     QTest::newRow("with_headers2") << QByteArray("HTTP/1.1 100 Continue\nBla: x\n\nHTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n") << 200;
3818 }
3819 
3820 void tst_QNetworkReply::ioGetFromHttpStatus100()
3821 {
3822     QFETCH(QByteArray, dataToSend);
3823     QFETCH(int, statusCode);
3824     MiniHttpServer server(dataToSend);
3825     server.doClose = true;
3826 
3827     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
3828     QNetworkReplyPtr reply(manager.get(request));
3829 
3830     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3831 
3832     QCOMPARE(reply->url(), request.url());
3833     QCOMPARE(reply->error(), QNetworkReply::NoError);
3834     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), statusCode);
3835     QVERIFY(reply->rawHeader("bla").isNull());
3836 }
3837 
3838 void tst_QNetworkReply::ioGetFromHttpNoHeaders_data()
3839 {
3840     QTest::addColumn<QByteArray>("dataToSend");
3841     QTest::newRow("justStatus+noheaders+disconnect") << QByteArray("HTTP/1.0 200 OK\r\n\r\n");
3842 }
3843 
3844 void tst_QNetworkReply::ioGetFromHttpNoHeaders()
3845 {
3846     QFETCH(QByteArray, dataToSend);
3847     MiniHttpServer server(dataToSend);
3848     server.doClose = true;
3849 
3850     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
3851     QNetworkReplyPtr reply(manager.get(request));
3852 
3853     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
3854 
3855     QCOMPARE(reply->url(), request.url());
3856     QCOMPARE(reply->error(), QNetworkReply::NoError);
3857     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
3858 }
3859 
3860 void tst_QNetworkReply::ioGetFromHttpWithCache_data()
3861 {
3862     qRegisterMetaType<MyMemoryCache::CachedContent>();
3863     QTest::addColumn<QByteArray>("dataToSend");
3864     QTest::addColumn<QString>("body");
3865     QTest::addColumn<MyMemoryCache::CachedContent>("cachedReply");
3866     QTest::addColumn<int>("cacheMode");
3867     QTest::addColumn<QStringList>("extraHttpHeaders");
3868     QTest::addColumn<bool>("loadedFromCache");
3869     QTest::addColumn<bool>("networkUsed");
3870 
3871     QByteArray reply200 =
3872             "HTTP/1.0 200\r\n"
3873             "Connection: keep-alive\r\n"
3874             "Content-Type: text/plain\r\n"
3875             "Cache-control: no-cache\r\n"
3876             "Content-length: 8\r\n"
3877             "\r\n"
3878             "Reloaded";
3879     QByteArray reply304 =
3880             "HTTP/1.0 304 Use Cache\r\n"
3881             "Connection: keep-alive\r\n"
3882             "\r\n";
3883 
3884     QTest::newRow("not-cached,always-network")
3885             << reply200 << "Reloaded" << MyMemoryCache::CachedContent() << int(QNetworkRequest::AlwaysNetwork) << QStringList() << false << true;
3886     QTest::newRow("not-cached,prefer-network")
3887             << reply200 << "Reloaded" << MyMemoryCache::CachedContent() << int(QNetworkRequest::PreferNetwork) << QStringList() << false << true;
3888     QTest::newRow("not-cached,prefer-cache")
3889             << reply200 << "Reloaded" << MyMemoryCache::CachedContent() << int(QNetworkRequest::PreferCache) << QStringList() << false << true;
3890 
3891     QDateTime present = QDateTime::currentDateTime().toUTC();
3892     QDateTime past = present.addSecs(-3600);
3893     QDateTime future = present.addSecs(3600);
3894     static const char dateFormat[] = "ddd, dd MMM yyyy hh:mm:ss 'GMT'";
3895 
3896     QNetworkCacheMetaData::RawHeaderList rawHeaders;
3897     MyMemoryCache::CachedContent content;
3898     content.second = "Not-reloaded";
3899     content.first.setLastModified(past);
3900 
3901     //
3902     // Set to expired
3903     //
3904     rawHeaders.clear();
3905     rawHeaders << QNetworkCacheMetaData::RawHeader("Date", QLocale::c().toString(past, dateFormat).toLatin1())
3906             << QNetworkCacheMetaData::RawHeader("Cache-control", "max-age=0"); // isn't used in cache loading
3907     content.first.setRawHeaders(rawHeaders);
3908     content.first.setLastModified(past);
3909     content.first.setExpirationDate(past);
3910 
3911     QTest::newRow("expired,200,prefer-network")
3912             << reply200 << "Reloaded" << content << int(QNetworkRequest::PreferNetwork) << QStringList() << false << true;
3913     QTest::newRow("expired,200,prefer-cache")
3914             << reply200 << "Reloaded" << content << int(QNetworkRequest::PreferCache) << QStringList() << false << true;
3915 
3916     QTest::newRow("expired,304,prefer-network")
3917             << reply304 << "Not-reloaded" << content << int(QNetworkRequest::PreferNetwork) << QStringList() << true << true;
3918     QTest::newRow("expired,304,prefer-cache")
3919             << reply304 << "Not-reloaded" << content << int(QNetworkRequest::PreferCache) << QStringList() << true << true;
3920 
3921     //
3922     // Set to not-expired
3923     //
3924     rawHeaders.clear();
3925     rawHeaders << QNetworkCacheMetaData::RawHeader("Date", QLocale::c().toString(past, dateFormat).toLatin1())
3926             << QNetworkCacheMetaData::RawHeader("Cache-control", "max-age=7200"); // isn't used in cache loading
3927     content.first.setRawHeaders(rawHeaders);
3928     content.first.setExpirationDate(future);
3929 
3930     QTest::newRow("not-expired,200,always-network")
3931             << reply200 << "Reloaded" << content << int(QNetworkRequest::AlwaysNetwork) << QStringList() << false << true;
3932     QTest::newRow("not-expired,200,prefer-network")
3933             << reply200 << "Not-reloaded" << content << int(QNetworkRequest::PreferNetwork) << QStringList() << true << false;
3934     QTest::newRow("not-expired,200,prefer-cache")
3935             << reply200 << "Not-reloaded" << content << int(QNetworkRequest::PreferCache) << QStringList() << true << false;
3936     QTest::newRow("not-expired,200,always-cache")
3937             << reply200 << "Not-reloaded" << content << int(QNetworkRequest::AlwaysCache) << QStringList() << true << false;
3938 
3939     QTest::newRow("not-expired,304,prefer-network")
3940             << reply304 << "Not-reloaded" << content << int(QNetworkRequest::PreferNetwork) << QStringList() << true << false;
3941     QTest::newRow("not-expired,304,prefer-cache")
3942             << reply304 << "Not-reloaded" << content << int(QNetworkRequest::PreferCache) << QStringList() << true << false;
3943     QTest::newRow("not-expired,304,always-cache")
3944             << reply304 << "Not-reloaded" << content << int(QNetworkRequest::AlwaysCache) << QStringList() << true << false;
3945 
3946     //
3947     // Set must-revalidate now
3948     //
3949     rawHeaders.clear();
3950     rawHeaders << QNetworkCacheMetaData::RawHeader("Date", QLocale::c().toString(past, dateFormat).toLatin1())
3951             << QNetworkCacheMetaData::RawHeader("Cache-control", "max-age=7200, must-revalidate"); // must-revalidate is used
3952     content.first.setRawHeaders(rawHeaders);
3953 
3954     QTest::newRow("must-revalidate,200,always-network")
3955             << reply200 << "Reloaded" << content << int(QNetworkRequest::AlwaysNetwork) << QStringList() << false << true;
3956     QTest::newRow("must-revalidate,200,prefer-network")
3957             << reply200 << "Reloaded" << content << int(QNetworkRequest::PreferNetwork) << QStringList() << false << true;
3958     QTest::newRow("must-revalidate,200,prefer-cache")
3959             << reply200 << "Reloaded" << content << int(QNetworkRequest::PreferCache) << QStringList() << false << true;
3960     QTest::newRow("must-revalidate,200,always-cache")
3961             << reply200 << "" << content << int(QNetworkRequest::AlwaysCache) << QStringList() << false << false;
3962 
3963     QTest::newRow("must-revalidate,304,prefer-network")
3964             << reply304 << "Not-reloaded" << content << int(QNetworkRequest::PreferNetwork) << QStringList() << true << true;
3965     QTest::newRow("must-revalidate,304,prefer-cache")
3966             << reply304 << "Not-reloaded" << content << int(QNetworkRequest::PreferCache) << QStringList() << true << true;
3967     QTest::newRow("must-revalidate,304,always-cache")
3968             << reply304 << "" << content << int(QNetworkRequest::AlwaysCache) << QStringList() << false << false;
3969 
3970     //
3971     // Partial content
3972     //
3973     rawHeaders.clear();
3974     rawHeaders << QNetworkCacheMetaData::RawHeader("Date", QLocale::c().toString(past, dateFormat).toLatin1())
3975             << QNetworkCacheMetaData::RawHeader("Cache-control", "max-age=7200"); // isn't used in cache loading
3976     content.first.setRawHeaders(rawHeaders);
3977     content.first.setExpirationDate(future);
3978 
3979     QByteArray reply206 =
3980             "HTTP/1.0 206\r\n"
3981             "Connection: keep-alive\r\n"
3982             "Content-Type: text/plain\r\n"
3983             "Cache-control: no-cache\r\n"
3984             "Content-Range: bytes 2-6/8\r\n"
3985             "Content-length: 4\r\n"
3986             "\r\n"
3987             "load";
3988 
3989     QTest::newRow("partial,dontuse-cache")
3990             << reply206 << "load" << content << int(QNetworkRequest::PreferCache) << (QStringList() << "Range" << "bytes=2-6") << false << true;
3991 }
3992 
3993 void tst_QNetworkReply::ioGetFromHttpWithCache()
3994 {
3995     QFETCH(QByteArray, dataToSend);
3996     MiniHttpServer server(dataToSend);
3997     server.doClose = false;
3998 
3999     MyMemoryCache *memoryCache = new MyMemoryCache(&manager);
4000     manager.setCache(memoryCache);
4001 
4002     QFETCH(MyMemoryCache::CachedContent, cachedReply);
4003     QUrl url = "http://localhost:" + QString::number(server.serverPort());
4004     cachedReply.first.setUrl(url);
4005     if (!cachedReply.second.isNull())
4006         memoryCache->cache.insert(url.toEncoded(), cachedReply);
4007 
4008     QFETCH(int, cacheMode);
4009     QNetworkRequest request(url);
4010     request.setAttribute(QNetworkRequest::CacheLoadControlAttribute, cacheMode);
4011     request.setAttribute(QNetworkRequest::CacheSaveControlAttribute, false);
4012 
4013     QFETCH(QStringList, extraHttpHeaders);
4014     QStringListIterator it(extraHttpHeaders);
4015     while (it.hasNext()) {
4016         QString header = it.next();
4017         QString value = it.next();
4018         request.setRawHeader(header.toLatin1(), value.toLatin1()); // To latin1? Deal with it!
4019     }
4020 
4021     QNetworkReplyPtr reply(manager.get(request));
4022 
4023     QVERIFY(waitForFinish(reply) != Timeout);
4024 
4025     QTEST(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), "loadedFromCache");
4026     QTEST(server.totalConnections > 0, "networkUsed");
4027     QFETCH(QString, body);
4028     QCOMPARE(reply->readAll().constData(), qPrintable(body));
4029 }
4030 
4031 #ifndef QT_NO_NETWORKPROXY
4032 void tst_QNetworkReply::ioGetWithManyProxies_data()
4033 {
4034     QTest::addColumn<QList<QNetworkProxy> >("proxyList");
4035     QTest::addColumn<QNetworkProxy>("proxyUsed");
4036     QTest::addColumn<QString>("url");
4037     QTest::addColumn<QNetworkReply::NetworkError>("expectedError");
4038 
4039     QList<QNetworkProxy> proxyList;
4040 
4041 #ifdef QT_TEST_SERVER
4042     const quint16 Socks5ProxyHttpPort = 1083;
4043 #else
4044     const quint16 Socks5ProxyHttpPort = 1081;
4045 #endif
4046     const quint16 Socks5ProxyFtpPort = 1081;
4047 
4048     // All of the other functions test DefaultProxy
4049     // So let's test something else
4050 
4051     // Simple tests that work:
4052 
4053     // HTTP request with HTTP caching proxy
4054     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129);
4055     QTest::newRow("http-on-http")
4056         << proxyList << proxyList.at(0)
4057         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4058         << QNetworkReply::NoError;
4059 
4060     // HTTP request with HTTP transparent proxy
4061     proxyList.clear();
4062     proxyList << QNetworkProxy(QNetworkProxy::HttpProxy, QtNetworkSettings::serverName(), 3129);
4063     QTest::newRow("http-on-http2")
4064         << proxyList << proxyList.at(0)
4065         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4066         << QNetworkReply::NoError;
4067 
4068     // HTTP request with SOCKS transparent proxy
4069     proxyList.clear();
4070     proxyList << QNetworkProxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(),
4071                                Socks5ProxyHttpPort);
4072     QTest::newRow("http-on-socks")
4073         << proxyList << proxyList.at(0)
4074         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4075         << QNetworkReply::NoError;
4076 
4077     // FTP request with FTP caching proxy
4078     proxyList.clear();
4079     proxyList << QNetworkProxy(QNetworkProxy::FtpCachingProxy, QtNetworkSettings::serverName(), 2121);
4080     QTest::newRow("ftp-on-ftp")
4081         << proxyList << proxyList.at(0)
4082         << "ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4083         << QNetworkReply::NoError;
4084 
4085     // The following test doesn't work because QFtp is too limited
4086     // It can only talk to its own kind of proxies
4087 
4088     // FTP request with SOCKSv5 transparent proxy
4089     proxyList.clear();
4090     proxyList << QNetworkProxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(),
4091                                Socks5ProxyFtpPort);
4092     QTest::newRow("ftp-on-socks")
4093         << proxyList << proxyList.at(0)
4094         << "ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4095         << QNetworkReply::NoError;
4096 
4097 #ifndef QT_NO_SSL
4098     // HTTPS with HTTP transparent proxy
4099     proxyList.clear();
4100     proxyList << QNetworkProxy(QNetworkProxy::HttpProxy, QtNetworkSettings::serverName(), 3129);
4101     QTest::newRow("https-on-http")
4102         << proxyList << proxyList.at(0)
4103         << "https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4104         << QNetworkReply::NoError;
4105 
4106     // HTTPS request with SOCKS transparent proxy
4107     proxyList.clear();
4108     proxyList << QNetworkProxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(),
4109                                Socks5ProxyHttpPort);
4110     QTest::newRow("https-on-socks")
4111         << proxyList << proxyList.at(0)
4112         << "https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4113         << QNetworkReply::NoError;
4114 #endif
4115 
4116     // Tests that fail:
4117 
4118     // HTTP request with FTP caching proxy
4119     proxyList.clear();
4120     proxyList << QNetworkProxy(QNetworkProxy::FtpCachingProxy, QtNetworkSettings::serverName(), 2121);
4121     QTest::newRow("http-on-ftp")
4122         << proxyList << QNetworkProxy()
4123         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4124         << QNetworkReply::ProxyNotFoundError;
4125 
4126     // FTP request with HTTP caching proxy
4127     proxyList.clear();
4128     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129);
4129     QTest::newRow("ftp-on-http")
4130         << proxyList << QNetworkProxy()
4131         << "ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4132         << QNetworkReply::ProxyNotFoundError;
4133 
4134     // FTP request with HTTP caching proxies
4135     proxyList.clear();
4136     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129)
4137               << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3130);
4138     QTest::newRow("ftp-on-multiple-http")
4139         << proxyList << QNetworkProxy()
4140         << "ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4141         << QNetworkReply::ProxyNotFoundError;
4142 
4143 #ifndef QT_NO_SSL
4144     // HTTPS with HTTP caching proxy
4145     proxyList.clear();
4146     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129);
4147     QTest::newRow("https-on-httptransparent")
4148         << proxyList << QNetworkProxy()
4149         << "https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4150         << QNetworkReply::ProxyNotFoundError;
4151 
4152     // HTTPS with FTP caching proxy
4153     proxyList.clear();
4154     proxyList << QNetworkProxy(QNetworkProxy::FtpCachingProxy, QtNetworkSettings::serverName(), 2121);
4155     QTest::newRow("https-on-ftp")
4156         << proxyList << QNetworkProxy()
4157         << "https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4158         << QNetworkReply::ProxyNotFoundError;
4159 #endif
4160 
4161     // Complex requests:
4162 
4163     // HTTP request with more than one HTTP proxy
4164     proxyList.clear();
4165     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129)
4166               << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3130);
4167     QTest::newRow("http-on-multiple-http")
4168         << proxyList << proxyList.at(0)
4169         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4170         << QNetworkReply::NoError;
4171 
4172     // HTTP request with HTTP + SOCKS
4173     proxyList.clear();
4174     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129)
4175               << QNetworkProxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(),
4176                                Socks5ProxyHttpPort);
4177     QTest::newRow("http-on-http+socks")
4178         << proxyList << proxyList.at(0)
4179         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4180         << QNetworkReply::NoError;
4181 
4182     // HTTP request with FTP + HTTP + SOCKS
4183     proxyList.clear();
4184     proxyList << QNetworkProxy(QNetworkProxy::FtpCachingProxy, QtNetworkSettings::serverName(), 2121)
4185               << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129)
4186               << QNetworkProxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(),
4187                                Socks5ProxyHttpPort);
4188     QTest::newRow("http-on-ftp+http+socks")
4189         << proxyList << proxyList.at(1) // second proxy should be used
4190         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4191         << QNetworkReply::NoError;
4192 
4193     // HTTP request with NoProxy + HTTP
4194     proxyList.clear();
4195     proxyList << QNetworkProxy(QNetworkProxy::NoProxy)
4196               << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129);
4197     QTest::newRow("http-on-noproxy+http")
4198         << proxyList << proxyList.at(0)
4199         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4200         << QNetworkReply::NoError;
4201 
4202     // HTTP request with FTP + NoProxy
4203     proxyList.clear();
4204     proxyList << QNetworkProxy(QNetworkProxy::FtpCachingProxy, QtNetworkSettings::serverName(), 2121)
4205               << QNetworkProxy(QNetworkProxy::NoProxy);
4206     QTest::newRow("http-on-ftp+noproxy")
4207         << proxyList << proxyList.at(1) // second proxy should be used
4208         << "http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4209         << QNetworkReply::NoError;
4210 
4211     // FTP request with HTTP Caching + FTP
4212     proxyList.clear();
4213     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129)
4214               << QNetworkProxy(QNetworkProxy::FtpCachingProxy, QtNetworkSettings::serverName(), 2121);
4215     QTest::newRow("ftp-on-http+ftp")
4216         << proxyList << proxyList.at(1) // second proxy should be used
4217         << "ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4218         << QNetworkReply::NoError;
4219 
4220 #ifndef QT_NO_SSL
4221     // HTTPS request with HTTP Caching + HTTP transparent
4222     proxyList.clear();
4223     proxyList << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129)
4224               << QNetworkProxy(QNetworkProxy::HttpProxy, QtNetworkSettings::serverName(), 3129);
4225     QTest::newRow("https-on-httpcaching+http")
4226         << proxyList << proxyList.at(1) // second proxy should be used
4227         << "https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4228         << QNetworkReply::NoError;
4229 
4230     // HTTPS request with FTP + HTTP C + HTTP T
4231     proxyList.clear();
4232     proxyList << QNetworkProxy(QNetworkProxy::FtpCachingProxy, QtNetworkSettings::serverName(), 2121)
4233               << QNetworkProxy(QNetworkProxy::HttpCachingProxy, QtNetworkSettings::serverName(), 3129)
4234               << QNetworkProxy(QNetworkProxy::HttpProxy, QtNetworkSettings::serverName(), 3129);
4235     QTest::newRow("https-on-ftp+httpcaching+http")
4236         << proxyList << proxyList.at(2) // skip the first two
4237         << "https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"
4238         << QNetworkReply::NoError;
4239 #endif
4240 }
4241 
4242 void tst_QNetworkReply::ioGetWithManyProxies()
4243 {
4244     // Test proxy factories
4245 
4246     QFile reference(testDataDir + "/rfc3252.txt");
4247     QVERIFY(reference.open(QIODevice::ReadOnly));
4248 
4249     // set the proxy factory:
4250     QFETCH(QList<QNetworkProxy>, proxyList);
4251     MyProxyFactory *proxyFactory = new MyProxyFactory;
4252     proxyFactory->toReturn = proxyList;
4253     manager.setProxyFactory(proxyFactory);
4254 
4255     QFETCH(QString, url);
4256     QUrl theUrl(url);
4257     QNetworkRequest request(theUrl);
4258     QNetworkReplyPtr reply(manager.get(request));
4259     DataReader reader(reply);
4260 
4261     QSignalSpy authspy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
4262     connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
4263             SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
4264 #ifndef QT_NO_SSL
4265     connect(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
4266             SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
4267 #endif
4268 
4269     QVERIFY(waitForFinish(reply) != Timeout);
4270 
4271     manager.disconnect(SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
4272                        this, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
4273 #ifndef QT_NO_SSL
4274     manager.disconnect(SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
4275                        this, SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
4276 #endif
4277 
4278     QFETCH(QNetworkReply::NetworkError, expectedError);
4279     QEXPECT_FAIL("ftp-on-socks", "QFtp is too limited and won't accept non-FTP proxies", Abort);
4280     QCOMPARE(reply->error(), expectedError);
4281 
4282     // Verify that the factory was called properly
4283     QCOMPARE(proxyFactory->callCount, 1);
4284     QCOMPARE(proxyFactory->lastQuery, QNetworkProxyQuery(theUrl));
4285 
4286     if (expectedError == QNetworkReply::NoError) {
4287         // request succeeded
4288         QCOMPARE(reader.data, reference.readAll());
4289 
4290         // now verify that the proxies worked:
4291         QFETCH(QNetworkProxy, proxyUsed);
4292         if (proxyUsed.type() == QNetworkProxy::NoProxy) {
4293             QCOMPARE(authspy.count(), 0);
4294         } else {
4295             if (QByteArray(QTest::currentDataTag()).startsWith("ftp-"))
4296                 return;         // No authentication with current FTP or with FTP proxies
4297             QCOMPARE(authspy.count(), 1);
4298             QCOMPARE(qvariant_cast<QNetworkProxy>(authspy.at(0).at(0)), proxyUsed);
4299         }
4300     } else {
4301         // request failed
4302         QCOMPARE(authspy.count(), 0);
4303     }
4304 }
4305 #endif // !QT_NO_NETWORKPROXY
4306 
4307 void tst_QNetworkReply::ioPutToFileFromFile_data()
4308 {
4309     QTest::addColumn<QString>("fileName");
4310 
4311     QTest::newRow("empty") << (testDataDir + "/empty");
4312     QTest::newRow("real-file") << (testDataDir + "/rfc3252.txt");
4313     QTest::newRow("resource") << ":/resource";
4314     QTest::newRow("search-path") << "testdata:/rfc3252.txt";
4315 }
4316 
4317 void tst_QNetworkReply::ioPutToFileFromFile()
4318 {
4319     QFETCH(QString, fileName);
4320     QFile sourceFile(fileName);
4321     QFile targetFile(testFileName);
4322 
4323     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
4324 
4325     QUrl url = QUrl::fromLocalFile(targetFile.fileName());
4326     QNetworkRequest request(url);
4327     QNetworkReplyPtr reply(manager.put(request, &sourceFile));
4328 
4329     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4330 
4331     QCOMPARE(reply->url(), url);
4332     QCOMPARE(reply->error(), QNetworkReply::NoError);
4333     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
4334     QVERIFY(reply->readAll().isEmpty());
4335 
4336     QVERIFY(sourceFile.atEnd());
4337     sourceFile.seek(0);         // reset it to the beginning
4338 
4339     QVERIFY(targetFile.open(QIODevice::ReadOnly));
4340     QCOMPARE(targetFile.size(), sourceFile.size());
4341     QCOMPARE(targetFile.readAll(), sourceFile.readAll());
4342 }
4343 
4344 void tst_QNetworkReply::ioPutToFileFromSocket_data()
4345 {
4346     putToFile_data();
4347 }
4348 
4349 void tst_QNetworkReply::ioPutToFileFromSocket()
4350 {
4351     QFile file(testFileName);
4352 
4353     QUrl url = QUrl::fromLocalFile(file.fileName());
4354     QNetworkRequest request(url);
4355 
4356     QFETCH(QByteArray, data);
4357     SocketPair socketpair;
4358     QTRY_VERIFY(socketpair.create()); //QTRY_VERIFY as a workaround for QTBUG-24451
4359 
4360     socketpair.endPoints[0]->write(data);
4361     QNetworkReplyPtr reply(manager.put(QNetworkRequest(url), socketpair.endPoints[1]));
4362     socketpair.endPoints[0]->close();
4363 
4364     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4365     QCOMPARE(reply->error(), QNetworkReply::NoError);
4366 
4367     QCOMPARE(reply->url(), url);
4368     QCOMPARE(reply->error(), QNetworkReply::NoError);
4369     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
4370     QVERIFY(reply->readAll().isEmpty());
4371 
4372     QVERIFY(file.open(QIODevice::ReadOnly));
4373     QCOMPARE(file.size(), qint64(data.size()));
4374     QByteArray contents = file.readAll();
4375     QCOMPARE(contents, data);
4376 }
4377 
4378 void tst_QNetworkReply::ioPutToFileFromLocalSocket_data()
4379 {
4380     putToFile_data();
4381 }
4382 
4383 void tst_QNetworkReply::ioPutToFileFromLocalSocket()
4384 {
4385     QString socketname = "networkreplytest";
4386     QLocalServer server;
4387     if (!server.listen(socketname)) {
4388         QLocalServer::removeServer(socketname);
4389         QVERIFY(server.listen(socketname));
4390     }
4391     QLocalSocket active;
4392     active.connectToServer(socketname);
4393     QVERIFY2(server.waitForNewConnection(10), server.errorString().toLatin1().constData());
4394     QVERIFY2(active.waitForConnected(10), active.errorString().toLatin1().constData());
4395     QVERIFY2(server.hasPendingConnections(), server.errorString().toLatin1().constData());
4396     QLocalSocket *passive = server.nextPendingConnection();
4397 
4398     QFile file(testFileName);
4399     QUrl url = QUrl::fromLocalFile(file.fileName());
4400     QNetworkRequest request(url);
4401 
4402     QFETCH(QByteArray, data);
4403     active.write(data);
4404     active.close();
4405     QNetworkReplyPtr reply(manager.put(QNetworkRequest(url), passive));
4406     passive->setParent(reply.data());
4407 
4408 #ifdef Q_OS_WIN
4409     if (!data.isEmpty())
4410         QEXPECT_FAIL("", "QTBUG-18385", Abort);
4411 #endif
4412     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4413     QCOMPARE(reply->error(), QNetworkReply::NoError);
4414 
4415     QCOMPARE(reply->url(), url);
4416     QCOMPARE(reply->error(), QNetworkReply::NoError);
4417     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
4418     QVERIFY(reply->readAll().isEmpty());
4419 
4420     QVERIFY(file.open(QIODevice::ReadOnly));
4421     QCOMPARE(file.size(), qint64(data.size()));
4422     QByteArray contents = file.readAll();
4423     QCOMPARE(contents, data);
4424 }
4425 
4426 // Currently no stdin/out supported for Windows CE.
4427 void tst_QNetworkReply::ioPutToFileFromProcess_data()
4428 {
4429 #if QT_CONFIG(process)
4430     putToFile_data();
4431 #endif
4432 }
4433 
4434 void tst_QNetworkReply::ioPutToFileFromProcess()
4435 {
4436 #if !QT_CONFIG(process)
4437     QSKIP("No qprocess support", SkipAll);
4438 #else
4439 
4440 #ifdef Q_OS_WIN
4441     if (qstrcmp(QTest::currentDataTag(), "small") == 0)
4442         QSKIP("When passing a CR-LF-LF sequence through Windows stdio, it gets converted, "
4443               "so this test fails. Disabled on Windows");
4444 #endif
4445 
4446     QFile file(testFileName);
4447 
4448     QUrl url = QUrl::fromLocalFile(file.fileName());
4449     QNetworkRequest request(url);
4450 
4451     QFETCH(QByteArray, data);
4452     QProcess process;
4453     QString echoExe = echoProcessDir + "/echo";
4454     process.start(echoExe, QStringList("all"));
4455     QVERIFY2(process.waitForStarted(), qPrintable(
4456         QString::fromLatin1("Could not start %1: %2").arg(echoExe, process.errorString())));
4457     process.write(data);
4458     process.closeWriteChannel();
4459 
4460     QNetworkReplyPtr reply(manager.put(QNetworkRequest(url), &process));
4461 
4462     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4463 
4464     QCOMPARE(reply->url(), url);
4465     QCOMPARE(reply->error(), QNetworkReply::NoError);
4466     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
4467     QVERIFY(reply->readAll().isEmpty());
4468 
4469     QVERIFY(file.open(QIODevice::ReadOnly));
4470     QCOMPARE(file.size(), qint64(data.size()));
4471     QByteArray contents = file.readAll();
4472     QCOMPARE(contents, data);
4473 
4474 #endif // QT_CONFIG(process)
4475 }
4476 
4477 void tst_QNetworkReply::ioPutToFtpFromFile_data()
4478 {
4479     ioPutToFileFromFile_data();
4480 }
4481 
4482 void tst_QNetworkReply::ioPutToFtpFromFile()
4483 {
4484     QFETCH(QString, fileName);
4485     QFile sourceFile(fileName);
4486     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
4487 
4488     QUrl url("ftp://" + QtNetworkSettings::serverName());
4489     url.setPath(QString("/qtest/upload/qnetworkaccess-ioPutToFtpFromFile-%1-%2")
4490                 .arg(QTest::currentDataTag())
4491                 .arg(uniqueExtension));
4492 
4493     QNetworkRequest request(url);
4494     QNetworkReplyPtr reply(manager.put(request, &sourceFile));
4495 
4496     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4497 
4498     QCOMPARE(reply->url(), url);
4499     QCOMPARE(reply->error(), QNetworkReply::NoError);
4500     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
4501     QVERIFY(reply->readAll().isEmpty());
4502 
4503     QVERIFY(sourceFile.atEnd());
4504     sourceFile.seek(0);         // reset it to the beginning
4505 
4506     // download the file again from FTP to make sure it was uploaded
4507     // correctly
4508     QNetworkAccessManager qnam;
4509     QNetworkRequest req(url);
4510     QNetworkReply *r = qnam.get(req);
4511 
4512     QObject::connect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
4513     QTestEventLoop::instance().enterLoop(3);
4514     QObject::disconnect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
4515 
4516     QByteArray uploaded = r->readAll();
4517     QCOMPARE(qint64(uploaded.size()), sourceFile.size());
4518     QCOMPARE(uploaded, sourceFile.readAll());
4519 
4520     r->close();
4521     QObject::connect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
4522     QTestEventLoop::instance().enterLoop(10);
4523     QObject::disconnect(r, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
4524 }
4525 
4526 void tst_QNetworkReply::ioPutToHttpFromFile_data()
4527 {
4528     ioPutToFileFromFile_data();
4529 }
4530 
4531 void tst_QNetworkReply::ioPutToHttpFromFile()
4532 {
4533     QFETCH(QString, fileName);
4534     QFile sourceFile(fileName);
4535     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
4536 
4537     QUrl url("http://" + QtNetworkSettings::serverName());
4538     url.setPath(QString("/dav/qnetworkaccess-ioPutToHttpFromFile-%1-%2")
4539                 .arg(QTest::currentDataTag())
4540                 .arg(uniqueExtension));
4541 
4542     QNetworkRequest request(url);
4543     QNetworkReplyPtr reply(manager.put(request, &sourceFile));
4544 
4545     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4546 
4547     QCOMPARE(reply->url(), url);
4548     QCOMPARE(reply->error(), QNetworkReply::NoError);
4549 
4550     // verify that the HTTP status code is 201 Created
4551     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 201);
4552 
4553     QVERIFY(sourceFile.atEnd());
4554     sourceFile.seek(0);         // reset it to the beginning
4555 
4556     // download the file again from HTTP to make sure it was uploaded
4557     // correctly
4558     reply.reset(manager.get(request));
4559 
4560     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4561 
4562     QCOMPARE(reply->url(), url);
4563     QCOMPARE(reply->error(), QNetworkReply::NoError);
4564     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
4565 
4566     QCOMPARE(reply->readAll(), sourceFile.readAll());
4567 }
4568 
4569 void tst_QNetworkReply::ioPostToHttpFromFile_data()
4570 {
4571     ioPutToFileFromFile_data();
4572 }
4573 
4574 void tst_QNetworkReply::ioPostToHttpFromFile()
4575 {
4576     QFETCH(QString, fileName);
4577     QFile sourceFile(fileName);
4578     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
4579 
4580     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi");
4581     QNetworkRequest request(url);
4582     request.setRawHeader("Content-Type", "application/octet-stream");
4583 
4584     QNetworkReplyPtr reply(manager.post(request, &sourceFile));
4585 
4586     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4587 
4588     QCOMPARE(reply->url(), url);
4589     QCOMPARE(reply->error(), QNetworkReply::NoError);
4590 
4591     // verify that the HTTP status code is 200 Ok
4592     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
4593 
4594     QVERIFY(sourceFile.atEnd());
4595     sourceFile.seek(0);         // reset it to the beginning
4596 
4597     QCOMPARE(reply->readAll().trimmed(), md5sum(sourceFile.readAll()).toHex());
4598 }
4599 
4600 #ifndef QT_NO_NETWORKPROXY
4601 void tst_QNetworkReply::ioPostToHttpFromSocket_data()
4602 {
4603     QTest::addColumn<QByteArray>("data");
4604     QTest::addColumn<QByteArray>("md5sum");
4605     QTest::addColumn<QUrl>("url");
4606     QTest::addColumn<QNetworkProxy>("proxy");
4607     QTest::addColumn<int>("authenticationRequiredCount");
4608     QTest::addColumn<int>("proxyAuthenticationRequiredCount");
4609 
4610     for (int i = 0; i < proxies.count(); ++i)
4611         for (int auth = 0; auth < 2; ++auth) {
4612             QUrl url;
4613             if (auth)
4614                 url = "http://" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi";
4615             else
4616                 url = "http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi";
4617 
4618             QNetworkProxy proxy = proxies.at(i).proxy;
4619             QByteArray testsuffix = QByteArray(auth ? "+auth" : "") + proxies.at(i).tag;
4620             int proxyauthcount = proxies.at(i).requiresAuthentication;
4621 
4622             QByteArray data;
4623             data = "";
4624             QTest::newRow("empty" + testsuffix) << data << md5sum(data) << url << proxy << auth << proxyauthcount;
4625 
4626             data = "This is a normal message.";
4627             QTest::newRow("generic" + testsuffix) << data << md5sum(data) << url << proxy << auth << proxyauthcount;
4628 
4629             data = "This is a message to show that Qt rocks!\r\n\n";
4630             QTest::newRow("small" + testsuffix) << data << md5sum(data) << url << proxy << auth << proxyauthcount;
4631 
4632             data = QByteArray("abcd\0\1\2\abcd",12);
4633             QTest::newRow("with-nul" + testsuffix) << data << md5sum(data) << url << proxy << auth << proxyauthcount;
4634 
4635             data = QByteArray(4097, '\4');
4636             QTest::newRow("4k+1" + testsuffix) << data << md5sum(data) << url << proxy << auth << proxyauthcount;
4637 
4638             data = QByteArray(128*1024+1, '\177');
4639             QTest::newRow("128k+1" + testsuffix) << data << md5sum(data) << url << proxy << auth << proxyauthcount;
4640         }
4641 }
4642 
4643 void tst_QNetworkReply::ioPostToHttpFromSocket()
4644 {
4645     if (QTest::currentDataTag() == QByteArray("128k+1+proxyauth")
4646             || QTest::currentDataTag() == QByteArray("128k+1+auth+proxyauth"))
4647         QSKIP("Squid cannot handle authentication with POST data >= 64K (QTBUG-33180)");
4648 
4649     QFETCH(QByteArray, data);
4650     QFETCH(QUrl, url);
4651     QFETCH(QNetworkProxy, proxy);
4652 
4653     SocketPair socketpair;
4654     QTRY_VERIFY(socketpair.create()); //QTRY_VERIFY as a workaround for QTBUG-24451
4655 
4656     socketpair.endPoints[0]->write(data);
4657 
4658     QNetworkRequest request(url);
4659     request.setRawHeader("Content-Type", "application/octet-stream");
4660 
4661     manager.setProxy(proxy);
4662     QNetworkReplyPtr reply(manager.post(request, socketpair.endPoints[1]));
4663     socketpair.endPoints[0]->close();
4664 
4665     connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
4666             SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
4667     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4668             SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4669 
4670     QSignalSpy authenticationRequiredSpy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4671     QSignalSpy proxyAuthenticationRequiredSpy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
4672 
4673     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4674 
4675     disconnect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
4676                this, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
4677     disconnect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4678                this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4679     QCOMPARE(reply->error(), QNetworkReply::NoError);
4680 
4681     QCOMPARE(reply->url(), url);
4682     QCOMPARE(reply->error(), QNetworkReply::NoError);
4683     // verify that the HTTP status code is 200 Ok
4684     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
4685 
4686     QCOMPARE(reply->readAll().trimmed(), md5sum(data).toHex());
4687 
4688     QTEST(authenticationRequiredSpy.count(), "authenticationRequiredCount");
4689     QTEST(proxyAuthenticationRequiredSpy.count(), "proxyAuthenticationRequiredCount");
4690 }
4691 
4692 void tst_QNetworkReply::ioPostToHttpFromSocketSynchronous_data()
4693 {
4694     QTest::addColumn<QByteArray>("data");
4695     QTest::addColumn<QByteArray>("md5sum");
4696 
4697     QByteArray data;
4698     data = "";
4699     QTest::newRow("empty") << data << md5sum(data);
4700 
4701     data = "This is a normal message.";
4702     QTest::newRow("generic") << data << md5sum(data);
4703 
4704     data = "This is a message to show that Qt rocks!\r\n\n";
4705     QTest::newRow("small") << data << md5sum(data);
4706 
4707     data = QByteArray("abcd\0\1\2\abcd",12);
4708     QTest::newRow("with-nul") << data << md5sum(data);
4709 
4710     data = QByteArray(4097, '\4');
4711     QTest::newRow("4k+1") << data << md5sum(data);
4712 
4713     data = QByteArray(128*1024+1, '\177');
4714     QTest::newRow("128k+1") << data << md5sum(data);
4715 
4716     data = QByteArray(2*1024*1024+1, '\177');
4717     QTest::newRow("2MB+1") << data << md5sum(data);
4718 }
4719 
4720 void tst_QNetworkReply::ioPostToHttpFromSocketSynchronous()
4721 {
4722     QFETCH(QByteArray, data);
4723 
4724     SocketPair socketpair;
4725     QTRY_VERIFY(socketpair.create()); //QTRY_VERIFY as a workaround for QTBUG-24451
4726     socketpair.endPoints[0]->write(data);
4727     socketpair.endPoints[0]->waitForBytesWritten(5000);
4728     // ### for 4.8: make the socket pair unbuffered, to not read everything in one go in QNetworkReplyImplPrivate::setup()
4729     QTestEventLoop::instance().enterLoop(3);
4730 
4731     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi");
4732     QNetworkRequest request(url);
4733     request.setRawHeader("Content-Type", "application/octet-stream");
4734     request.setAttribute(
4735             QNetworkRequest::SynchronousRequestAttribute,
4736             true);
4737 
4738     QNetworkReplyPtr reply(manager.post(request, socketpair.endPoints[1]));
4739     QVERIFY(reply->isFinished());
4740     socketpair.endPoints[0]->close();
4741 
4742     QCOMPARE(reply->error(), QNetworkReply::NoError);
4743 
4744     QCOMPARE(reply->url(), url);
4745     QCOMPARE(reply->error(), QNetworkReply::NoError);
4746     // verify that the HTTP status code is 200 Ok
4747     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
4748 
4749     QCOMPARE(reply->readAll().trimmed(), md5sum(data).toHex());
4750 }
4751 #endif // !QT_NO_NETWORKPROXY
4752 
4753 // this tests checks if rewinding the POST-data to some place in the middle
4754 // worked.
4755 void tst_QNetworkReply::ioPostToHttpFromMiddleOfFileToEnd()
4756 {
4757     QFile sourceFile(testDataDir + "/rfc3252.txt");
4758     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
4759     // seeking to the middle
4760     sourceFile.seek(sourceFile.size() / 2);
4761 
4762     QUrl url = "http://" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi";
4763     QNetworkRequest request(url);
4764     request.setRawHeader("Content-Type", "application/octet-stream");
4765     QNetworkReplyPtr reply(manager.post(request, &sourceFile));
4766 
4767     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4768             SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4769 
4770     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4771 
4772     disconnect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4773                this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4774 
4775     // compare half data
4776     sourceFile.seek(sourceFile.size() / 2);
4777     QByteArray data = sourceFile.readAll();
4778     QCOMPARE(reply->readAll().trimmed(), md5sum(data).toHex());
4779 }
4780 
4781 void tst_QNetworkReply::ioPostToHttpFromMiddleOfFileFiveBytes()
4782 {
4783     QFile sourceFile(testDataDir + "/rfc3252.txt");
4784     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
4785     // seeking to the middle
4786     sourceFile.seek(sourceFile.size() / 2);
4787 
4788     QUrl url = "http://" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi";
4789     QNetworkRequest request(url);
4790     request.setRawHeader("Content-Type", "application/octet-stream");
4791     // only send 5 bytes
4792     request.setHeader(QNetworkRequest::ContentLengthHeader, 5);
4793     QVERIFY(request.header(QNetworkRequest::ContentLengthHeader).isValid());
4794     QNetworkReplyPtr reply(manager.post(request, &sourceFile));
4795 
4796     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4797             SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4798 
4799     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4800 
4801     disconnect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4802                this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4803 
4804     // compare half data
4805     sourceFile.seek(sourceFile.size() / 2);
4806     QByteArray data = sourceFile.read(5);
4807     QCOMPARE(reply->readAll().trimmed(), md5sum(data).toHex());
4808 }
4809 
4810 void tst_QNetworkReply::ioPostToHttpFromMiddleOfQBufferFiveBytes()
4811 {
4812     // test needed since a QBuffer goes with a different codepath than the QFile
4813     // tested in ioPostToHttpFromMiddleOfFileFiveBytes
4814     QBuffer uploadBuffer;
4815     uploadBuffer.open(QIODevice::ReadWrite);
4816     uploadBuffer.write("1234567890");
4817     uploadBuffer.seek(5);
4818 
4819     QUrl url = "http://" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi";
4820     QNetworkRequest request(url);
4821     request.setRawHeader("Content-Type", "application/octet-stream");
4822     QNetworkReplyPtr reply(manager.post(request, &uploadBuffer));
4823 
4824     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4825             SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4826 
4827     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4828 
4829     disconnect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4830                this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4831 
4832     // compare half data
4833     uploadBuffer.seek(5);
4834     QByteArray data = uploadBuffer.read(5);
4835     QCOMPARE(reply->readAll().trimmed(), md5sum(data).toHex());
4836 }
4837 
4838 
4839 void tst_QNetworkReply::ioPostToHttpNoBufferFlag()
4840 {
4841     QByteArray data = QByteArray("daaaaaaataaaaaaa");
4842     // create a sequential QIODevice by feeding the data into a local TCP server
4843     SocketPair socketpair;
4844     QTRY_VERIFY(socketpair.create()); //QTRY_VERIFY as a workaround for QTBUG-24451
4845     socketpair.endPoints[0]->write(data);
4846 
4847     QUrl url = "http://" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi";
4848     QNetworkRequest request(url);
4849     request.setRawHeader("Content-Type", "application/octet-stream");
4850     // disallow buffering
4851     request.setAttribute(QNetworkRequest::DoNotBufferUploadDataAttribute, true);
4852     request.setHeader(QNetworkRequest::ContentLengthHeader, data.size());
4853     QNetworkReplyPtr reply(manager.post(request, socketpair.endPoints[1]));
4854     socketpair.endPoints[0]->close();
4855 
4856     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4857             SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4858 
4859     QCOMPARE(waitForFinish(reply), int(Failure));
4860 
4861     disconnect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)),
4862                this, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
4863 
4864     // verify: error code is QNetworkReply::ContentReSendError
4865     QCOMPARE(reply->error(), QNetworkReply::ContentReSendError);
4866 }
4867 
4868 #ifndef QT_NO_SSL
4869 class SslServer : public QTcpServer
4870 {
4871     Q_OBJECT
4872 public:
4873     SslServer() : socket(0), m_ssl(true) {}
4874     void incomingConnection(qintptr socketDescriptor)
4875     {
4876         QSslSocket *serverSocket = new QSslSocket;
4877         serverSocket->setParent(this);
4878 
4879         if (serverSocket->setSocketDescriptor(socketDescriptor)) {
4880             connect(serverSocket, SIGNAL(readyRead()), this, SLOT(readyReadSlot()));
4881             if (!m_ssl) {
4882                 emit newPlainConnection(serverSocket);
4883                 return;
4884             }
4885             connect(serverSocket, SIGNAL(encrypted()), this, SLOT(encryptedSlot()));
4886             connect(serverSocket, SIGNAL(sslErrors(QList<QSslError>)), serverSocket, SLOT(ignoreSslErrors()));
4887             setupSslServer(serverSocket);
4888         } else {
4889             delete serverSocket;
4890         }
4891     }
4892 signals:
4893     void newEncryptedConnection(QSslSocket *s);
4894     void newPlainConnection(QSslSocket *s);
4895 public slots:
4896     void encryptedSlot()
4897     {
4898         socket = (QSslSocket*) sender();
4899         emit newEncryptedConnection(socket);
4900     }
4901     void readyReadSlot()
4902     {
4903         // for the incoming sockets, not the server socket
4904         //qDebug() << static_cast<QSslSocket*>(sender())->bytesAvailable() << static_cast<QSslSocket*>(sender())->encryptedBytesAvailable();
4905     }
4906 
4907 public:
4908     QSslSocket *socket;
4909     bool m_ssl;
4910 };
4911 
4912 // very similar to ioPostToHttpUploadProgress but for SSL
4913 void tst_QNetworkReply::ioPostToHttpsUploadProgress()
4914 {
4915     //QFile sourceFile(testDataDir + "/bigfile");
4916     //QVERIFY(sourceFile.open(QIODevice::ReadOnly));
4917     qint64 wantedSize = 2*1024*1024; // 2 MB
4918     QByteArray sourceFile;
4919     // And in the case of SSL, the compression can fool us and let the
4920     // server send the data much faster than expected.
4921     // So better provide random data that cannot be compressed.
4922     for (int i = 0; i < wantedSize; ++i)
4923         sourceFile += (char)QRandomGenerator::global()->generate();
4924 
4925     // emulate a minimal https server
4926     SslServer server;
4927     server.listen(QHostAddress(QHostAddress::LocalHost), 0);
4928 
4929     // create the request
4930     QUrl url = QUrl(QLatin1String("https://127.0.0.1:") + QString::number(server.serverPort()) + QLatin1Char('/'));
4931     QNetworkRequest request(url);
4932 
4933     request.setRawHeader("Content-Type", "application/octet-stream");
4934     QNetworkReplyPtr reply(manager.post(request, sourceFile));
4935 
4936     QSignalSpy spy(reply.data(), SIGNAL(uploadProgress(qint64,qint64)));
4937     connect(&server, SIGNAL(newEncryptedConnection(QSslSocket*)), &QTestEventLoop::instance(), SLOT(exitLoop()));
4938     connect(reply, SIGNAL(sslErrors(QList<QSslError>)), reply.data(), SLOT(ignoreSslErrors()));
4939 
4940     // get the request started and the incoming socket connected
4941     QTestEventLoop::instance().enterLoop(10);
4942     QVERIFY(!QTestEventLoop::instance().timeout());
4943     QTcpSocket *incomingSocket = server.socket;
4944     QVERIFY(incomingSocket);
4945     disconnect(&server, SIGNAL(newEncryptedConnection(QSslSocket*)), &QTestEventLoop::instance(), SLOT(exitLoop()));
4946 
4947 
4948     incomingSocket->setReadBufferSize(1024);
4949     // some progress should have been made
4950     QTRY_VERIFY(!spy.isEmpty());
4951     QList<QVariant> args = spy.last();
4952     QVERIFY(args.at(0).toLongLong() > 0);
4953     // but not everything!
4954     QVERIFY(args.at(0).toLongLong() != sourceFile.size());
4955 
4956     // set the read buffer to unlimited
4957     incomingSocket->setReadBufferSize(0);
4958     QTestEventLoop::instance().enterLoop(10);
4959     // progress should be finished
4960     QVERIFY(!spy.isEmpty());
4961     QList<QVariant> args3 = spy.last();
4962     QCOMPARE(args3.at(0).toLongLong(), args3.at(1).toLongLong());
4963     QCOMPARE(args3.at(0).toLongLong(), qint64(sourceFile.size()));
4964 
4965     // after sending this, the QNAM should emit finished()
4966     incomingSocket->write("HTTP/1.0 200 OK\r\n");
4967     incomingSocket->write("Content-Length: 0\r\n");
4968     incomingSocket->write("\r\n");
4969 
4970     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
4971 
4972     incomingSocket->close();
4973     server.close();
4974 }
4975 #endif
4976 
4977 void tst_QNetworkReply::ioGetFromBuiltinHttp_data()
4978 {
4979     QTest::addColumn<bool>("https");
4980     QTest::addColumn<int>("bufferSize");
4981     QTest::newRow("http+unlimited") << false << 0;
4982     QTest::newRow("http+limited") << false << 4096;
4983 #ifndef QT_NO_SSL
4984     QTest::newRow("https+unlimited") << true << 0;
4985     QTest::newRow("https+limited") << true << 4096;
4986 #endif
4987 }
4988 
4989 void tst_QNetworkReply::ioGetFromBuiltinHttp()
4990 {
4991     QFETCH(bool, https);
4992     QFETCH(int, bufferSize);
4993 
4994     QByteArray testData;
4995     // Make the data big enough so that it can fill the kernel buffer
4996     // (which seems to hold 202 KB here)
4997     const int wantedSize = 1200 * 1000;
4998     testData.reserve(wantedSize);
4999     // And in the case of SSL, the compression can fool us and let the
5000     // server send the data much faster than expected.
5001     // So better provide random data that cannot be compressed.
5002     for (int i = 0; i < wantedSize; ++i)
5003         testData += (char)QRandomGenerator::global()->generate();
5004 
5005     QByteArray httpResponse = QByteArray("HTTP/1.0 200 OK\r\nContent-Length: ");
5006     httpResponse += QByteArray::number(testData.size());
5007     httpResponse += "\r\n\r\n";
5008     httpResponse += testData;
5009 
5010     qDebug() << "Server will send" << (httpResponse.size()-testData.size()) << "bytes of header and"
5011              << testData.size() << "bytes of data";
5012 
5013     const bool fillKernelBuffer = bufferSize > 0;
5014     notEnoughDataForFastSender = false;
5015     FastSender server(httpResponse, https, fillKernelBuffer, this);
5016 
5017     QUrl url(QString("%1://127.0.0.1:%2/qtest/rfc3252.txt")
5018              .arg(https?"https":"http")
5019              .arg(server.serverPort()));
5020     QNetworkRequest request(url);
5021     QNetworkReplyPtr reply(manager.get(request));
5022     reply->setReadBufferSize(bufferSize);
5023     reply->ignoreSslErrors();
5024     const int rate = 200; // in kB per sec
5025     RateControlledReader reader(server, reply.data(), rate, bufferSize);
5026 
5027     QTime loopTime;
5028     loopTime.start();
5029 
5030     const int result = waitForFinish(reply);
5031     if (notEnoughDataForFastSender) {
5032         server.wait();
5033         QSKIP("kernel socket buffers are too big for this test to work");
5034     }
5035 
5036     QVERIFY2(result == Success, msgWaitForFinished(reply));
5037 
5038     const int elapsedTime = loopTime.elapsed();
5039     server.wait();
5040     reader.wrapUp();
5041 
5042     qDebug() << "send rate:" << server.transferRate << "B/s";
5043     qDebug() << "receive rate:" << reader.totalBytesRead * 1000 / elapsedTime
5044              << "(it received" << reader.totalBytesRead << "bytes in" << elapsedTime << "ms)";
5045 
5046     QCOMPARE(reply->url(), request.url());
5047     QCOMPARE(reply->error(), QNetworkReply::NoError);
5048     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
5049 
5050     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), (qint64)testData.size());
5051     if (reader.data.size() < testData.size()) { // oops?
5052         QCOMPARE(reader.data, testData.left(reader.data.size()));
5053         qDebug() << "The data is incomplete, the last" << testData.size() - reader.data.size() << "bytes are missing";
5054     }
5055     QCOMPARE(reader.data.size(), testData.size());
5056     QCOMPARE(reader.data, testData);
5057 
5058     // OK we got the file alright, but did setReadBufferSize work?
5059     QVERIFY(server.transferRate != -1);
5060     if (bufferSize > 0) {
5061         const int allowedDeviation = 16; // TODO find out why the send rate is 13% faster currently
5062         const int minRate = rate * 1024 * (100-allowedDeviation) / 100;
5063         const int maxRate = rate * 1024 * (100+allowedDeviation) / 100;
5064         qDebug() << minRate << "<="<< server.transferRate << "<=" << maxRate << '?';
5065         // The test takes too long to run if sending enough data to overwhelm the
5066         // receiver's kernel buffers.
5067         //QEXPECT_FAIL("http+limited", "Limiting is broken right now, check QTBUG-15065", Continue);
5068         //QEXPECT_FAIL("https+limited", "Limiting is broken right now, check QTBUG-15065", Continue);
5069         //QVERIFY(server.transferRate >= minRate && server.transferRate <= maxRate);
5070     }
5071 }
5072 
5073 void tst_QNetworkReply::ioPostToHttpUploadProgress()
5074 {
5075     //test file must be larger than OS socket buffers (~830kB on MacOS 10.6)
5076     QFile sourceFile(testDataDir + "/image1.jpg");
5077     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
5078     const qint64 sourceFileSize = sourceFile.size();
5079 
5080     // emulate a minimal http server
5081     QTcpServer server;
5082     server.listen(QHostAddress(QHostAddress::LocalHost), 0);
5083 
5084     // create the request
5085     QUrl url = QUrl(QString("http://127.0.0.1:%1/").arg(server.serverPort()));
5086     QNetworkRequest request(url);
5087     request.setRawHeader("Content-Type", "application/octet-stream");
5088     QNetworkReplyPtr reply(manager.post(request, &sourceFile));
5089     QSignalSpy spy(reply.data(), SIGNAL(uploadProgress(qint64,qint64)));
5090     connect(&server, SIGNAL(newConnection()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5091 
5092     // get the request started and the incoming socket connected
5093     QTestEventLoop::instance().enterLoop(10);
5094     QVERIFY(!QTestEventLoop::instance().timeout());
5095     QTcpSocket *incomingSocket = server.nextPendingConnection();
5096     QVERIFY(incomingSocket);
5097     disconnect(&server, SIGNAL(newConnection()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5098 
5099     incomingSocket->setReadBufferSize(1024);
5100     QTestEventLoop::instance().enterLoop(5);
5101     // some progress should have been made
5102     QVERIFY(!spy.isEmpty());
5103     const QList<QVariant> args = spy.last();
5104     QVERIFY(!args.isEmpty());
5105     const qint64 bufferedUploadProgress = args.at(0).toLongLong();
5106     QVERIFY(bufferedUploadProgress > 0);
5107     // but not everything? - Note however, that under CI virtualization,
5108     // particularly on Windows, it frequently happens that the whole file
5109     // is uploaded in one chunk.
5110     if (bufferedUploadProgress == sourceFileSize) {
5111         qWarning() << QDir::toNativeSeparators(sourceFile.fileName())
5112                    << "of" << sourceFileSize << "bytes was uploaded in one go.";
5113     }
5114 
5115     // set the read buffer to unlimited
5116     incomingSocket->setReadBufferSize(0);
5117     QTestEventLoop::instance().enterLoop(10);
5118     // progress should be finished
5119     QVERIFY(!spy.isEmpty());
5120     const QList<QVariant> args3 = spy.last();
5121     QVERIFY(!args3.isEmpty());
5122     // More progress than before
5123     const qint64 unbufferedUploadProgress = args3.at(0).toLongLong();
5124     if (bufferedUploadProgress < sourceFileSize)
5125         QVERIFY(unbufferedUploadProgress > bufferedUploadProgress);
5126     QCOMPARE(unbufferedUploadProgress, args3.at(1).toLongLong());
5127     // And actually finished..
5128     QCOMPARE(unbufferedUploadProgress, sourceFileSize);
5129 
5130     // after sending this, the QNAM should emit finished()
5131     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5132     incomingSocket->write("HTTP/1.0 200 OK\r\n");
5133     incomingSocket->write("Content-Length: 0\r\n");
5134     incomingSocket->write("\r\n");
5135     QTestEventLoop::instance().enterLoop(10);
5136     // not timeouted -> finished() was emitted
5137     QVERIFY(!QTestEventLoop::instance().timeout());
5138 
5139     incomingSocket->close();
5140     server.close();
5141 }
5142 
5143 void tst_QNetworkReply::emitAllUploadProgressSignals()
5144 {
5145     QFile sourceFile(testDataDir + "/image1.jpg");
5146     QVERIFY(sourceFile.open(QIODevice::ReadOnly));
5147 
5148     // emulate a minimal http server
5149     QTcpServer server;
5150     server.listen(QHostAddress(QHostAddress::LocalHost), 0);
5151     connect(&server, SIGNAL(newConnection()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5152 
5153     QUrl url = QUrl(QLatin1String("http://127.0.0.1:") + QString::number(server.serverPort()) + QLatin1Char('/'));
5154     QNetworkRequest normalRequest(url);
5155     normalRequest.setRawHeader("Content-Type", "application/octet-stream");
5156 
5157     QNetworkRequest catchAllSignalsRequest(normalRequest);
5158     catchAllSignalsRequest.setAttribute(QNetworkRequest::EmitAllUploadProgressSignalsAttribute, true);
5159 
5160     QList<QNetworkRequest> requests;
5161     requests << normalRequest << catchAllSignalsRequest;
5162 
5163     QList<int> signalCount;
5164 
5165     foreach (const QNetworkRequest &request, requests) {
5166 
5167         sourceFile.seek(0);
5168         QNetworkReplyPtr reply(manager.post(request, &sourceFile));
5169         QSignalSpy spy(reply.data(), SIGNAL(uploadProgress(qint64,qint64)));
5170 
5171         // get the request started and the incoming socket connected
5172         QTestEventLoop::instance().enterLoop(10);
5173         QVERIFY(!QTestEventLoop::instance().timeout());
5174         QTcpSocket *incomingSocket = server.nextPendingConnection();
5175         QVERIFY(incomingSocket);
5176         QTestEventLoop::instance().enterLoop(10);
5177 
5178         connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5179         incomingSocket->write("HTTP/1.0 200 OK\r\n");
5180         incomingSocket->write("Content-Length: 0\r\n");
5181         incomingSocket->write("\r\n");
5182         QTestEventLoop::instance().enterLoop(10);
5183         // not timeouted -> finished() was emitted
5184         QVERIFY(!QTestEventLoop::instance().timeout());
5185 
5186         incomingSocket->close();
5187         signalCount.append(spy.count());
5188         reply->deleteLater();
5189     }
5190     server.close();
5191 
5192     // verify that the normal request emitted less signals than the one emitting all signals
5193     QVERIFY2(signalCount.at(0) < signalCount.at(1), "no upload signal was suppressed");
5194 }
5195 
5196 void tst_QNetworkReply::ioPostToHttpEmptyUploadProgress()
5197 {
5198     QByteArray ba;
5199     ba.resize(0);
5200     QBuffer buffer(&ba,0);
5201     QVERIFY(buffer.open(QIODevice::ReadOnly));
5202 
5203     // emulate a minimal http server
5204     QTcpServer server;
5205     server.listen(QHostAddress(QHostAddress::LocalHost), 0);
5206 
5207     // create the request
5208     QUrl url = QUrl(QLatin1String("http://127.0.0.1:") + QString::number(server.serverPort()) + QLatin1Char('/'));
5209     QNetworkRequest request(url);
5210     request.setRawHeader("Content-Type", "application/octet-stream");
5211     QNetworkReplyPtr reply(manager.post(request, &buffer));
5212     QSignalSpy spy(reply.data(), SIGNAL(uploadProgress(qint64,qint64)));
5213     connect(&server, SIGNAL(newConnection()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5214 
5215 
5216     // get the request started and the incoming socket connected
5217     QTestEventLoop::instance().enterLoop(10);
5218     QVERIFY(!QTestEventLoop::instance().timeout());
5219     QTcpSocket *incomingSocket = server.nextPendingConnection();
5220     QVERIFY(incomingSocket);
5221 
5222     // after sending this, the QNAM should emit finished()
5223     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5224     incomingSocket->write("HTTP/1.0 200 OK\r\n");
5225     incomingSocket->write("Content-Length: 0\r\n");
5226     incomingSocket->write("\r\n");
5227     incomingSocket->flush();
5228     QTestEventLoop::instance().enterLoop(10);
5229     // not timeouted -> finished() was emitted
5230     QVERIFY(!QTestEventLoop::instance().timeout());
5231 
5232     // final check: only 1 uploadProgress has been emitted
5233     QCOMPARE(spy.length(), 1);
5234     QList<QVariant> args = spy.last();
5235     QVERIFY(!args.isEmpty());
5236     QCOMPARE(args.at(0).toLongLong(), buffer.size());
5237     QCOMPARE(args.at(0).toLongLong(), buffer.size());
5238 
5239     incomingSocket->close();
5240     server.close();
5241 }
5242 
5243 void tst_QNetworkReply::lastModifiedHeaderForFile()
5244 {
5245     QFileInfo fileInfo(testDataDir + "/bigfile");
5246     QVERIFY(fileInfo.exists());
5247 
5248     QUrl url = QUrl::fromLocalFile(fileInfo.filePath());
5249 
5250     QNetworkRequest request(url);
5251     QNetworkReplyPtr reply(manager.head(request));
5252 
5253     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
5254 
5255     QDateTime header = reply->header(QNetworkRequest::LastModifiedHeader).toDateTime();
5256     QCOMPARE(header, fileInfo.lastModified());
5257 }
5258 
5259 void tst_QNetworkReply::lastModifiedHeaderForHttp()
5260 {
5261     // Tue, 22 May 2007 12:04:57 GMT according to webserver
5262     QUrl url = "http://" + QtNetworkSettings::serverName() + "/qtest/fluke.gif";
5263 
5264     QNetworkRequest request(url);
5265     QNetworkReplyPtr reply(manager.head(request));
5266 
5267     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
5268 
5269     QDateTime header = reply->header(QNetworkRequest::LastModifiedHeader).toDateTime();
5270     QDateTime realDate = QDateTime::fromString("2007-05-22T12:04:57", Qt::ISODate);
5271     realDate.setTimeSpec(Qt::UTC);
5272 
5273     QCOMPARE(header, realDate);
5274 }
5275 
5276 void tst_QNetworkReply::httpCanReadLine()
5277 {
5278     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt"));
5279     QNetworkReplyPtr reply(manager.get(request));
5280 
5281     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
5282 
5283     QCOMPARE(reply->error(), QNetworkReply::NoError);
5284 
5285     QVERIFY(reply->canReadLine());
5286     QVERIFY(!reply->readAll().isEmpty());
5287     QVERIFY(!reply->canReadLine());
5288 }
5289 
5290 #ifdef QT_BUILD_INTERNAL
5291 void tst_QNetworkReply::rateControl_data()
5292 {
5293     QTest::addColumn<int>("rate");
5294 
5295     QTest::newRow("15") << 15;
5296     QTest::newRow("40") << 40;
5297     QTest::newRow("73") << 73;
5298     QTest::newRow("80") << 80;
5299     QTest::newRow("125") << 125;
5300     QTest::newRow("250") << 250;
5301     QTest::newRow("1024") << 1024;
5302 }
5303 #endif
5304 
5305 #ifdef QT_BUILD_INTERNAL
5306 void tst_QNetworkReply::rateControl()
5307 {
5308     QSKIP("Test disabled -- only for manual purposes");
5309     // this function tests that we aren't reading from the network
5310     // faster than the data is being consumed.
5311     QFETCH(int, rate);
5312 
5313     // ask for 20 seconds worth of data
5314     FastSender sender(20 * rate * 1024);
5315 
5316     QNetworkRequest request("debugpipe://localhost:" + QString::number(sender.serverPort()));
5317     QNetworkReplyPtr reply(manager.get(request));
5318     reply->setReadBufferSize(32768);
5319     QSignalSpy errorSpy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
5320 
5321     RateControlledReader reader(sender, reply.data(), rate, 20);
5322 
5323     // this test is designed to run for 25 seconds at most
5324     QTime loopTime;
5325     loopTime.start();
5326 
5327     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
5328 
5329     int elapsedTime = loopTime.elapsed();
5330 
5331     if (!errorSpy.isEmpty()) {
5332         qDebug() << "ERROR!" << errorSpy[0][0] << reply->errorString();
5333     }
5334 
5335     qDebug() << "tst_QNetworkReply::rateControl" << "send rate:" << sender.transferRate;
5336     qDebug() << "tst_QNetworkReply::rateControl" << "receive rate:" << reader.totalBytesRead * 1000 / elapsedTime
5337              << "(it received" << reader.totalBytesRead << "bytes in" << elapsedTime << "ms)";
5338 
5339     sender.wait();
5340 
5341     QCOMPARE(reply->url(), request.url());
5342     QCOMPARE(reply->error(), QNetworkReply::NoError);
5343 
5344     QVERIFY(sender.transferRate != -1);
5345     int minRate = rate * 1024 * 9 / 10;
5346     int maxRate = rate * 1024 * 11 / 10;
5347     QVERIFY(sender.transferRate >= minRate);
5348     QVERIFY(sender.transferRate <= maxRate);
5349 }
5350 #endif
5351 
5352 void tst_QNetworkReply::downloadProgress_data()
5353 {
5354     QTest::addColumn<QUrl>("url");
5355     QTest::addColumn<int>("expectedSize");
5356 
5357     QTest::newRow("empty") << QUrl::fromLocalFile(QFINDTESTDATA("empty")) << 0;
5358     QTest::newRow("http:small") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt") << 25962;
5359     QTest::newRow("http:big") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/bigfile") << 519240;
5360     QTest::newRow("http:no-length") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/deflate/rfc2616.html") << -1;
5361     QTest::newRow("ftp:small") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt") << 25962;
5362     QTest::newRow("ftp:big") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/bigfile") << 519240;
5363 }
5364 
5365 class SlowReader : public QObject
5366 {
5367     Q_OBJECT
5368 public:
5369     SlowReader(QIODevice *dev)
5370         : device(dev)
5371     {
5372         connect(device, SIGNAL(readyRead()), this, SLOT(deviceReady()));
5373     }
5374 private slots:
5375     void deviceReady()
5376     {
5377         QTimer::singleShot(100, this, SLOT(doRead()));
5378     }
5379 
5380     void doRead()
5381     {
5382         device->readAll();
5383     }
5384 private:
5385     QIODevice *device;
5386 };
5387 
5388 void tst_QNetworkReply::downloadProgress()
5389 {
5390     QFETCH(QUrl, url);
5391     QFETCH(int, expectedSize);
5392 
5393     QNetworkRequest request(url);
5394     QNetworkReplyPtr reply(manager.get(request));
5395     //artificially slow down the test, otherwise only the final signal is emitted
5396     reply->setReadBufferSize(qMax(20000, expectedSize / 4));
5397     SlowReader reader(reply.data());
5398     QSignalSpy spy(reply.data(), SIGNAL(downloadProgress(qint64,qint64)));
5399     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
5400     QTestEventLoop::instance().enterLoop(30);
5401     QVERIFY(!QTestEventLoop::instance().timeout());
5402     QVERIFY(reply->isFinished());
5403 
5404     QVERIFY(spy.count() > 0);
5405 
5406     //final progress should have equal current & total
5407     QList<QVariant> args = spy.takeLast();
5408     QCOMPARE(args.at(0).toInt(), args.at(1).toInt());
5409 
5410     qint64 current = 0;
5411     //intermediate progress ascending and has expected total
5412     while (!spy.isEmpty()) {
5413         args = spy.takeFirst();
5414         QVERIFY(args.at(0).toInt() >= current);
5415         if (expectedSize >=0)
5416             QCOMPARE(args.at(1).toInt(), expectedSize);
5417         else
5418             QVERIFY(args.at(1).toInt() == expectedSize || args.at(1).toInt() == args.at(0).toInt());
5419         current = args.at(0).toInt();
5420     }
5421 }
5422 
5423 #ifdef QT_BUILD_INTERNAL
5424 void tst_QNetworkReply::uploadProgress_data()
5425 {
5426     putToFile_data();
5427 }
5428 #endif
5429 
5430 #ifdef QT_BUILD_INTERNAL
5431 void tst_QNetworkReply::uploadProgress()
5432 {
5433     QFETCH(QByteArray, data);
5434     QTcpServer server;
5435     QVERIFY(server.listen());
5436 
5437     QNetworkRequest request("debugpipe://127.0.0.1:" + QString::number(server.serverPort()) + "/?bare=1");
5438     QNetworkReplyPtr reply(manager.put(request, data));
5439     QSignalSpy spy(reply.data(), SIGNAL(uploadProgress(qint64,qint64)));
5440     QSignalSpy finished(reply.data(), SIGNAL(finished()));
5441     QVERIFY(spy.isValid());
5442     QVERIFY(finished.isValid());
5443 
5444     QCoreApplication::instance()->processEvents();
5445     if (!server.hasPendingConnections())
5446         server.waitForNewConnection(1000);
5447     QVERIFY(server.hasPendingConnections());
5448 
5449     QTcpSocket *receiver = server.nextPendingConnection();
5450     if (finished.count() == 0) {
5451         // it's not finished yet, so wait for it to be
5452         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
5453     }
5454     delete receiver;
5455 
5456     QVERIFY(finished.count() > 0);
5457     QVERIFY(spy.count() > 0);
5458 
5459     QList<QVariant> args = spy.last();
5460     QCOMPARE(args.at(0).toInt(), data.size());
5461     QCOMPARE(args.at(1).toInt(), data.size());
5462 }
5463 #endif
5464 
5465 void tst_QNetworkReply::chaining_data()
5466 {
5467     putToFile_data();
5468 }
5469 
5470 void tst_QNetworkReply::chaining()
5471 {
5472     QTemporaryFile sourceFile(QDir::currentPath() + "/temp-XXXXXX");
5473     sourceFile.setAutoRemove(true);
5474     QVERIFY2(sourceFile.open(), qPrintable(sourceFile.errorString()));
5475 
5476     QFETCH(QByteArray, data);
5477     QCOMPARE(sourceFile.write(data), data.size());
5478     sourceFile.flush();
5479     QCOMPARE(sourceFile.size(), qint64(data.size()));
5480 
5481     QNetworkRequest request(QUrl::fromLocalFile(sourceFile.fileName()));
5482     QNetworkReplyPtr getReply(manager.get(request));
5483 
5484     QFile targetFile(testFileName);
5485     QUrl url = QUrl::fromLocalFile(targetFile.fileName());
5486     request.setUrl(url);
5487     QNetworkReplyPtr putReply(manager.put(request, getReply.data()));
5488 
5489     QCOMPARE(waitForFinish(putReply), int(Success));
5490 
5491     QCOMPARE(getReply->url(), QUrl::fromLocalFile(sourceFile.fileName()));
5492     QCOMPARE(getReply->error(), QNetworkReply::NoError);
5493     QCOMPARE(getReply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), sourceFile.size());
5494 
5495     QCOMPARE(putReply->url(), url);
5496     QCOMPARE(putReply->error(), QNetworkReply::NoError);
5497     QCOMPARE(putReply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), Q_INT64_C(0));
5498     QVERIFY(putReply->readAll().isEmpty());
5499 
5500     QVERIFY(sourceFile.atEnd());
5501     sourceFile.seek(0);         // reset it to the beginning
5502 
5503     QVERIFY(targetFile.open(QIODevice::ReadOnly));
5504     QCOMPARE(targetFile.size(), sourceFile.size());
5505     QCOMPARE(targetFile.readAll(), sourceFile.readAll());
5506 }
5507 
5508 void tst_QNetworkReply::receiveCookiesFromHttp_data()
5509 {
5510     QTest::addColumn<QString>("cookieString");
5511     QTest::addColumn<QList<QNetworkCookie> >("expectedCookiesFromHttp");
5512     QTest::addColumn<QList<QNetworkCookie> >("expectedCookiesInJar");
5513 
5514     QTest::newRow("empty") << "" << QList<QNetworkCookie>() << QList<QNetworkCookie>();
5515 
5516     QList<QNetworkCookie> header, jar;
5517     QNetworkCookie cookie("a", "b");
5518     header << cookie;
5519     cookie.setDomain(QtNetworkSettings::serverName());
5520     cookie.setPath("/qtest/cgi-bin/");
5521     jar << cookie;
5522     QTest::newRow("simple-cookie") << "a=b" << header << jar;
5523 
5524     header << QNetworkCookie("c", "d");
5525     cookie.setName("c");
5526     cookie.setValue("d");
5527     jar << cookie;
5528     QTest::newRow("two-cookies") << "a=b\nc=d" << header << jar;
5529 
5530     header.clear();
5531     jar.clear();
5532     header << QNetworkCookie("a", "b, c=d");
5533     cookie.setName("a");
5534     cookie.setValue("b, c=d");
5535     jar << cookie;
5536     QTest::newRow("invalid-two-cookies") << "a=b, c=d" << header << jar;
5537 
5538     header.clear();
5539     jar.clear();
5540     cookie = QNetworkCookie("a", "b");
5541     cookie.setPath("/not/part-of-path");
5542     header << cookie;
5543     cookie.setDomain(QtNetworkSettings::serverName());
5544     jar << cookie;
5545     QTest::newRow("invalid-cookie-path") << "a=b; path=/not/part-of-path" << header << jar;
5546 
5547     jar.clear();
5548     cookie = QNetworkCookie("a", "b");
5549     cookie.setDomain(".example.com");
5550     header.clear();
5551     header << cookie;
5552     QTest::newRow("invalid-cookie-domain") << "a=b; domain=.example.com" << header << jar;
5553 }
5554 
5555 void tst_QNetworkReply::receiveCookiesFromHttp()
5556 {
5557     QFETCH(QString, cookieString);
5558 
5559     QByteArray data = cookieString.toLatin1() + '\n';
5560     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/set-cookie.cgi");
5561     QNetworkRequest request(url);
5562     request.setRawHeader("Content-Type", "application/octet-stream");
5563     QNetworkReplyPtr reply;
5564     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PostOperation, request, reply, data));
5565 
5566     QCOMPARE(reply->url(), url);
5567     QCOMPARE(reply->error(), QNetworkReply::NoError);
5568 
5569     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
5570 
5571     QList<QNetworkCookie> setCookies =
5572         qvariant_cast<QList<QNetworkCookie> >(reply->header(QNetworkRequest::SetCookieHeader));
5573     QTEST(setCookies, "expectedCookiesFromHttp");
5574     QTEST(cookieJar->allCookies(), "expectedCookiesInJar");
5575 }
5576 
5577 void tst_QNetworkReply::receiveCookiesFromHttpSynchronous_data()
5578 {
5579     tst_QNetworkReply::receiveCookiesFromHttp_data();
5580 }
5581 
5582 void tst_QNetworkReply::receiveCookiesFromHttpSynchronous()
5583 {
5584     QFETCH(QString, cookieString);
5585 
5586     QByteArray data = cookieString.toLatin1() + '\n';
5587     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/set-cookie.cgi");
5588 
5589     QNetworkRequest request(url);
5590     request.setRawHeader("Content-Type", "application/octet-stream");
5591     request.setAttribute(
5592             QNetworkRequest::SynchronousRequestAttribute,
5593             true);
5594 
5595     QNetworkReplyPtr reply;
5596     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::PostOperation, request, reply, data));
5597 
5598     QCOMPARE(reply->url(), url);
5599     QCOMPARE(reply->error(), QNetworkReply::NoError);
5600 
5601     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
5602 
5603     QList<QNetworkCookie> setCookies =
5604             qvariant_cast<QList<QNetworkCookie> >(reply->header(QNetworkRequest::SetCookieHeader));
5605     QTEST(setCookies, "expectedCookiesFromHttp");
5606     QTEST(cookieJar->allCookies(), "expectedCookiesInJar");
5607 }
5608 
5609 void tst_QNetworkReply::sendCookies_data()
5610 {
5611     QTest::addColumn<QList<QNetworkCookie> >("cookiesToSet");
5612     QTest::addColumn<QString>("expectedCookieString");
5613 
5614     QList<QNetworkCookie> list;
5615     QTest::newRow("empty") << list << "";
5616 
5617     QNetworkCookie cookie("a", "b");
5618     cookie.setPath("/");
5619     cookie.setDomain("example.com");
5620     list << cookie;
5621     QTest::newRow("no-match-domain") << list << "";
5622 
5623     cookie.setDomain(QtNetworkSettings::serverName());
5624     cookie.setPath("/something/else");
5625     list << cookie;
5626     QTest::newRow("no-match-path") << list << "";
5627 
5628     cookie.setPath("/");
5629     list << cookie;
5630     QTest::newRow("simple-cookie") << list << "a=b";
5631 
5632     cookie.setPath("/qtest");
5633     cookie.setValue("longer");
5634     list << cookie;
5635     QTest::newRow("two-cookies") << list << "a=longer; a=b";
5636 
5637     list.clear();
5638     cookie = QNetworkCookie("a", "b");
5639     cookie.setPath("/");
5640     cookie.setDomain(QLatin1Char('.') + QtNetworkSettings::serverDomainName());
5641     list << cookie;
5642     QTest::newRow("domain-match") << list << "a=b";
5643 
5644     // but it shouldn't match this:
5645     cookie.setDomain(QtNetworkSettings::serverDomainName());
5646     list << cookie;
5647     QTest::newRow("domain-match-2") << list << "a=b";
5648 }
5649 
5650 void tst_QNetworkReply::sendCookies()
5651 {
5652     QFETCH(QString, expectedCookieString);
5653     QFETCH(QList<QNetworkCookie>, cookiesToSet);
5654     cookieJar->setAllCookies(cookiesToSet);
5655 
5656     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/get-cookie.cgi");
5657     QNetworkRequest request(url);
5658     QNetworkReplyPtr reply;
5659     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply));
5660 
5661     QCOMPARE(reply->url(), url);
5662     QCOMPARE(reply->error(), QNetworkReply::NoError);
5663 
5664     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
5665 
5666     QCOMPARE(QString::fromLatin1(reply->readAll()).trimmed(), expectedCookieString);
5667 }
5668 
5669 void tst_QNetworkReply::sendCookiesSynchronous_data()
5670 {
5671     tst_QNetworkReply::sendCookies_data();
5672 }
5673 
5674 void tst_QNetworkReply::sendCookiesSynchronous()
5675 {
5676     QFETCH(QString, expectedCookieString);
5677     QFETCH(QList<QNetworkCookie>, cookiesToSet);
5678     cookieJar->setAllCookies(cookiesToSet);
5679 
5680     QUrl url("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/get-cookie.cgi");
5681     QNetworkRequest request(url);
5682 
5683     request.setAttribute(
5684             QNetworkRequest::SynchronousRequestAttribute,
5685             true);
5686 
5687     QNetworkReplyPtr reply;
5688     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply));
5689 
5690     QCOMPARE(reply->url(), url);
5691     QCOMPARE(reply->error(), QNetworkReply::NoError);
5692 
5693     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 Ok
5694 
5695     QCOMPARE(QString::fromLatin1(reply->readAll()).trimmed(), expectedCookieString);
5696 }
5697 
5698 void tst_QNetworkReply::nestedEventLoops_slot()
5699 {
5700     QEventLoop subloop;
5701 
5702     // 16 seconds: fluke times out in 15 seconds, which triggers a QTcpSocket error
5703     QTimer::singleShot(16000, &subloop, SLOT(quit()));
5704     subloop.exec();
5705 
5706     QTestEventLoop::instance().exitLoop();
5707 }
5708 
5709 void tst_QNetworkReply::notEnoughData()
5710 {
5711     notEnoughDataForFastSender = true;
5712 }
5713 
5714 void tst_QNetworkReply::nestedEventLoops()
5715 {
5716     // Slightly fragile test, it may not be testing anything
5717     // This is certifying that we're not running into the same issue
5718     // that QHttp had (task 200432): the QTcpSocket connection is
5719     // closed by the remote end because of the kept-alive HTTP
5720     // connection timed out.
5721     //
5722     // The exact time required for this to happen is not exactly
5723     // defined. Our server (Apache httpd) times out after 15
5724     // seconds. (see above)
5725 
5726     qDebug("Takes 16 seconds to run, please wait");
5727 
5728     QUrl url("http://" + QtNetworkSettings::serverName());
5729     QNetworkRequest request(url);
5730     QNetworkReplyPtr reply(manager.get(request));
5731 
5732     QSignalSpy finishedspy(reply.data(), SIGNAL(finished()));
5733     QSignalSpy errorspy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
5734 
5735     connect(reply, SIGNAL(finished()), SLOT(nestedEventLoops_slot()));
5736     QTestEventLoop::instance().enterLoop(20);
5737     QVERIFY2(!QTestEventLoop::instance().timeout(), "Network timeout");
5738 
5739     QCOMPARE(finishedspy.count(), 1);
5740     QCOMPARE(errorspy.count(), 0);
5741 }
5742 
5743 #ifndef QT_NO_NETWORKPROXY
5744 void tst_QNetworkReply::httpProxyCommands_data()
5745 {
5746     QTest::addColumn<QUrl>("url");
5747     QTest::addColumn<QByteArray>("responseToSend");
5748     QTest::addColumn<QString>("expectedCommand");
5749 
5750     QTest::newRow("http")
5751         << QUrl("http://0.0.0.0:4443/http-request")
5752         << QByteArray("HTTP/1.0 200 OK\r\nProxy-Connection: close\r\nContent-Length: 1\r\n\r\n1")
5753         << "GET http://0.0.0.0:4443/http-request HTTP/1.";
5754 #ifndef QT_NO_SSL
5755     QTest::newRow("https")
5756         << QUrl("https://0.0.0.0:4443/https-request")
5757         << QByteArray("HTTP/1.0 200 Connection Established\r\n\r\n")
5758         << "CONNECT 0.0.0.0:4443 HTTP/1.";
5759 #endif
5760 }
5761 
5762 void tst_QNetworkReply::httpProxyCommands()
5763 {
5764     QFETCH(QUrl, url);
5765     QFETCH(QByteArray, responseToSend);
5766     QFETCH(QString, expectedCommand);
5767 
5768     MiniHttpServer proxyServer(responseToSend);
5769     QNetworkProxy proxy(QNetworkProxy::HttpProxy, "127.0.0.1", proxyServer.serverPort());
5770 
5771     manager.setProxy(proxy);
5772     QNetworkRequest request(url);
5773     request.setRawHeader("User-Agent", "QNetworkReplyAutoTest/1.0");
5774     QNetworkReplyPtr reply(manager.get(request));
5775     //clearing the proxy here causes the test to fail.
5776     //the proxy isn't used until after the bearer has been started
5777     //which is correct in general, because system proxy isn't known until that time.
5778     //removing this line is safe, as the proxy is also reset by the cleanup() function
5779     //manager.setProxy(QNetworkProxy());
5780 
5781     // wait for the finished signal
5782     QVERIFY(waitForFinish(reply) != Timeout);
5783 
5784     //qDebug() << reply->error() << reply->errorString();
5785     //qDebug() << proxyServer.receivedData;
5786 
5787     // we don't really care if the request succeeded
5788     // especially since it won't succeed in the HTTPS case
5789     // so just check that the command was correct
5790 
5791     QString receivedHeader = proxyServer.receivedData.left(expectedCommand.length());
5792     QCOMPARE(receivedHeader, expectedCommand);
5793 
5794     //QTBUG-17223 - make sure the user agent from the request is sent to proxy server even for CONNECT
5795     int uapos = proxyServer.receivedData.indexOf("User-Agent");
5796     int uaend = proxyServer.receivedData.indexOf("\r\n", uapos);
5797     QByteArray uaheader = proxyServer.receivedData.mid(uapos, uaend - uapos);
5798     QCOMPARE(uaheader, QByteArray("User-Agent: QNetworkReplyAutoTest/1.0"));
5799 }
5800 
5801 class ProxyChangeHelper : public QObject
5802 {
5803     Q_OBJECT
5804 public:
5805     ProxyChangeHelper() : QObject(), signalCount(0) {};
5806 public slots:
5807     void finishedSlot()
5808     {
5809         signalCount++;
5810         if (signalCount == 2)
5811             QMetaObject::invokeMethod(&QTestEventLoop::instance(), "exitLoop", Qt::QueuedConnection);
5812     }
5813 private:
5814    int signalCount;
5815 };
5816 
5817 void tst_QNetworkReply::httpProxyCommandsSynchronous_data()
5818 {
5819     httpProxyCommands_data();
5820 }
5821 #endif // !QT_NO_NETWORKPROXY
5822 
5823 struct QThreadCleanup
5824 {
5825     static inline void cleanup(QThread *thread)
5826     {
5827         thread->quit();
5828         if (thread->wait(3000))
5829             delete thread;
5830         else
5831             qWarning("thread hung, leaking memory so test can finish");
5832     }
5833 };
5834 
5835 struct QDeleteLaterCleanup
5836 {
5837     static inline void cleanup(QObject *o)
5838     {
5839         o->deleteLater();
5840     }
5841 };
5842 
5843 #ifndef QT_NO_NETWORKPROXY
5844 void tst_QNetworkReply::httpProxyCommandsSynchronous()
5845 {
5846     QFETCH(QUrl, url);
5847     QFETCH(QByteArray, responseToSend);
5848     QFETCH(QString, expectedCommand);
5849 
5850     // when using synchronous commands, we need a different event loop for
5851     // the server thread, because the client is never returning to the
5852     // event loop
5853     QScopedPointer<QThread, QThreadCleanup> serverThread(new QThread);
5854     QScopedPointer<MiniHttpServer, QDeleteLaterCleanup> proxyServer(new MiniHttpServer(responseToSend, false, serverThread.data()));
5855     QNetworkProxy proxy(QNetworkProxy::HttpProxy, "127.0.0.1", proxyServer->serverPort());
5856 
5857     manager.setProxy(proxy);
5858     QNetworkRequest request(url);
5859 
5860     // send synchronous request
5861     request.setAttribute(
5862             QNetworkRequest::SynchronousRequestAttribute,
5863             true);
5864 
5865     QNetworkReplyPtr reply(manager.get(request));
5866     QVERIFY(reply->isFinished()); // synchronous
5867     manager.setProxy(QNetworkProxy());
5868 
5869     //qDebug() << reply->error() << reply->errorString();
5870 
5871     // we don't really care if the request succeeded
5872     // especially since it won't succeed in the HTTPS case
5873     // so just check that the command was correct
5874 
5875     QString receivedHeader = proxyServer->receivedData.left(expectedCommand.length());
5876     QCOMPARE(receivedHeader, expectedCommand);
5877 }
5878 
5879 void tst_QNetworkReply::proxyChange()
5880 {
5881     ProxyChangeHelper helper;
5882     MiniHttpServer proxyServer(
5883         "HTTP/1.0 200 OK\r\nProxy-Connection: keep-alive\r\n"
5884         "Content-Length: 1\r\n\r\n1");
5885     QNetworkProxy dummyProxy(QNetworkProxy::HttpProxy, "127.0.0.1", proxyServer.serverPort());
5886     QNetworkRequest req(QUrl("http://" + QtNetworkSettings::serverName()));
5887     proxyServer.doClose = false;
5888 
5889     {
5890         // Needed to initialize a network session in QNAM. Without an initialized session the GET
5891         // will be deferred until later, and the proxy will be unset first. This caused the test to
5892         // fail in standalone runs (it passed in CI because the same QNAM instance is used for the
5893         // entire test).
5894         QNetworkReplyPtr temporary(manager.get(req));
5895         waitForFinish(temporary);
5896     }
5897 
5898     manager.setProxy(dummyProxy);
5899     QNetworkReplyPtr reply1(manager.get(req));
5900     connect(reply1, SIGNAL(finished()), &helper, SLOT(finishedSlot()));
5901 
5902     manager.setProxy(QNetworkProxy());
5903     QNetworkReplyPtr reply2(manager.get(req));
5904     connect(reply2, SIGNAL(finished()), &helper, SLOT(finishedSlot()));
5905 
5906     QTestEventLoop::instance().enterLoop(20);
5907     QVERIFY(!QTestEventLoop::instance().timeout());
5908 
5909     // verify that the replies succeeded
5910     QCOMPARE(reply1->error(), QNetworkReply::NoError);
5911     QCOMPARE(reply1->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
5912     QCOMPARE(reply1->size(), 1);
5913 
5914     QCOMPARE(reply2->error(), QNetworkReply::NoError);
5915     QCOMPARE(reply2->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
5916     QVERIFY(reply2->size() > 1);
5917 
5918     // now try again and get an error
5919     // this verifies that we reuse the already-open connection
5920 
5921     proxyServer.doClose = true;
5922     proxyServer.dataToTransmit =
5923         "HTTP/1.0 403 Forbidden\r\nProxy-Connection: close\r\n"
5924         "Content-Length: 1\r\n\r\n1";
5925 
5926     manager.setProxy(dummyProxy);
5927     QNetworkReplyPtr reply3(manager.get(req));
5928 
5929     QCOMPARE(waitForFinish(reply3), int(Failure));
5930 
5931     QVERIFY(int(reply3->error()) > 0);
5932 }
5933 #endif // !QT_NO_NETWORKPROXY
5934 
5935 void tst_QNetworkReply::authorizationError_data()
5936 {
5937 
5938     QTest::addColumn<QString>("url");
5939     QTest::addColumn<int>("errorSignalCount");
5940     QTest::addColumn<int>("finishedSignalCount");
5941     QTest::addColumn<int>("error");
5942     QTest::addColumn<int>("httpStatusCode");
5943     QTest::addColumn<QString>("httpBody");
5944 
5945     QTest::newRow("unknown-authorization-method") << "http://" + QtNetworkSettings::serverName() +
5946                                                      "/qtest/cgi-bin/http-unknown-authentication-method.cgi?401-authorization-required" << 1 << 1
5947                                                   << int(QNetworkReply::AuthenticationRequiredError) << 401 << "authorization required";
5948     QTest::newRow("unknown-proxy-authorization-method") << "http://" + QtNetworkSettings::serverName() +
5949                                                            "/qtest/cgi-bin/http-unknown-authentication-method.cgi?407-proxy-authorization-required" << 1 << 1
5950                                                         << int(QNetworkReply::ProxyAuthenticationRequiredError) << 407
5951                                                         << "authorization required";
5952 }
5953 
5954 void tst_QNetworkReply::authorizationError()
5955 {
5956     QFETCH(QString, url);
5957     QNetworkRequest request(url);
5958     QNetworkReplyPtr reply(manager.get(request));
5959 
5960     QCOMPARE(reply->error(), QNetworkReply::NoError);
5961 
5962     QSignalSpy errorSpy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
5963     QSignalSpy finishedSpy(reply.data(), SIGNAL(finished()));
5964     // now run the request:
5965     QCOMPARE(waitForFinish(reply), int(Failure));
5966 
5967     QFETCH(int, errorSignalCount);
5968     QCOMPARE(errorSpy.count(), errorSignalCount);
5969     QFETCH(int, finishedSignalCount);
5970     QCOMPARE(finishedSpy.count(), finishedSignalCount);
5971     QFETCH(int, error);
5972     QCOMPARE(reply->error(), QNetworkReply::NetworkError(error));
5973 
5974     QFETCH(int, httpStatusCode);
5975     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), httpStatusCode);
5976 
5977     QFETCH(QString, httpBody);
5978     QCOMPARE(qint64(reply->size()), qint64(httpBody.size()));
5979     QCOMPARE(QString(reply->readAll()), httpBody);
5980 }
5981 
5982 void tst_QNetworkReply::httpConnectionCount()
5983 {
5984     QTcpServer server;
5985     QVERIFY(server.listen());
5986     QCoreApplication::instance()->processEvents();
5987 
5988     for (int i = 0; i < 10; i++) {
5989         QNetworkRequest request (QUrl("http://127.0.0.1:" + QString::number(server.serverPort()) + QLatin1Char('/') +  QString::number(i)));
5990         QNetworkReply* reply = manager.get(request);
5991         reply->setParent(&server);
5992     }
5993 
5994     int pendingConnectionCount = 0;
5995     QTime time;
5996     time.start();
5997 
5998     while(pendingConnectionCount <= 20) {
5999         QTestEventLoop::instance().enterLoop(1);
6000         QTcpSocket *socket = server.nextPendingConnection();
6001         while (socket != 0) {
6002             pendingConnectionCount++;
6003             socket->setParent(&server);
6004             socket = server.nextPendingConnection();
6005         }
6006 
6007         // at max. wait 10 sec
6008         if (time.elapsed() > 10000)
6009             break;
6010     }
6011 
6012     QCOMPARE(pendingConnectionCount, 6);
6013 }
6014 
6015 void tst_QNetworkReply::httpReUsingConnectionSequential_data()
6016 {
6017     QTest::addColumn<bool>("doDeleteLater");
6018     QTest::newRow("deleteLater") << true;
6019     QTest::newRow("noDeleteLater") << false;
6020 }
6021 
6022 void tst_QNetworkReply::httpReUsingConnectionSequential()
6023 {
6024     QFETCH(bool, doDeleteLater);
6025 
6026     QByteArray response("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n");
6027     MiniHttpServer server(response);
6028     server.multiple = true;
6029     server.doClose = false;
6030 
6031     QUrl url;
6032     url.setScheme("http");
6033     url.setPort(server.serverPort());
6034     url.setHost("127.0.0.1");
6035     // first request
6036     QNetworkReply* reply1 = manager.get(QNetworkRequest(url));
6037     connect(reply1, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6038     QTestEventLoop::instance().enterLoop(2);
6039     QVERIFY(!QTestEventLoop::instance().timeout());
6040     QVERIFY(!reply1->error());
6041     int reply1port = server.client->peerPort();
6042 
6043     if (doDeleteLater)
6044         reply1->deleteLater();
6045 
6046     // finished received, send the next one
6047     QNetworkReply*reply2 = manager.get(QNetworkRequest(url));
6048     connect(reply2, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6049     QTestEventLoop::instance().enterLoop(2);
6050     QVERIFY(!QTestEventLoop::instance().timeout());
6051     QVERIFY(!reply2->error());
6052     int reply2port = server.client->peerPort(); // should still be the same object
6053 
6054     QVERIFY(reply1port > 0);
6055     QCOMPARE(server.totalConnections, 1);
6056     QCOMPARE(reply2port, reply1port);
6057 
6058     if (!doDeleteLater)
6059         reply1->deleteLater(); // only do it if it was not done earlier
6060     reply2->deleteLater();
6061 }
6062 
6063 class HttpReUsingConnectionFromFinishedSlot : public QObject
6064 {
6065     Q_OBJECT
6066 public:
6067     QNetworkReply* reply1;
6068     QNetworkReply* reply2;
6069     QUrl url;
6070     QNetworkAccessManager manager;
6071 public slots:
6072     void finishedSlot()
6073     {
6074         QVERIFY(!reply1->error());
6075 
6076         QFETCH(bool, doDeleteLater);
6077         if (doDeleteLater) {
6078             reply1->deleteLater();
6079             reply1 = 0;
6080         }
6081 
6082         // kick off 2nd request and exit the loop when it is done
6083         reply2 = manager.get(QNetworkRequest(url));
6084         reply2->setParent(this);
6085         connect(reply2, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6086     }
6087 };
6088 
6089 void tst_QNetworkReply::httpReUsingConnectionFromFinishedSlot_data()
6090 {
6091     httpReUsingConnectionSequential_data();
6092 }
6093 
6094 void tst_QNetworkReply::httpReUsingConnectionFromFinishedSlot()
6095 {
6096     QByteArray response("HTTP/1.1 200 OK\r\nContent-Length: 0\r\n\r\n");
6097     MiniHttpServer server(response);
6098     server.multiple = true;
6099     server.doClose = false;
6100 
6101     HttpReUsingConnectionFromFinishedSlot helper;
6102     helper.reply1 = 0;
6103     helper.reply2 = 0;
6104     helper.url.setScheme("http");
6105     helper.url.setPort(server.serverPort());
6106     helper.url.setHost("127.0.0.1");
6107 
6108     // first request
6109     helper.reply1 = helper.manager.get(QNetworkRequest(helper.url));
6110     helper.reply1->setParent(&helper);
6111     connect(helper.reply1, SIGNAL(finished()), &helper, SLOT(finishedSlot()));
6112     QTestEventLoop::instance().enterLoop(4);
6113     QVERIFY(!QTestEventLoop::instance().timeout());
6114 
6115     QVERIFY(helper.reply2);
6116     QVERIFY(!helper.reply2->error());
6117 
6118     QCOMPARE(server.totalConnections, 1);
6119 }
6120 
6121 class HttpRecursiveCreationHelper : public QObject
6122 {
6123     Q_OBJECT
6124 public:
6125 
6126     HttpRecursiveCreationHelper():
6127             QObject(0),
6128             requestsStartedCount_finished(0),
6129             requestsStartedCount_readyRead(0),
6130             requestsFinishedCount(0)
6131     {
6132     }
6133     QNetworkAccessManager manager;
6134     int requestsStartedCount_finished;
6135     int requestsStartedCount_readyRead;
6136     int requestsFinishedCount;
6137 public slots:
6138     void finishedSlot()
6139     {
6140         requestsFinishedCount++;
6141 
6142         QNetworkReply *reply = qobject_cast<QNetworkReply*>(sender());
6143         QVERIFY(!reply->error());
6144         QCOMPARE(reply->bytesAvailable(), 27906);
6145 
6146         if (requestsFinishedCount == 60) {
6147             QTestEventLoop::instance().exitLoop();
6148             return;
6149         }
6150 
6151         if (requestsStartedCount_finished < 30) {
6152             startOne();
6153             requestsStartedCount_finished++;
6154         }
6155 
6156         reply->deleteLater();
6157     }
6158     void readyReadSlot()
6159     {
6160         QNetworkReply *reply = qobject_cast<QNetworkReply*>(sender());
6161         QVERIFY(!reply->error());
6162 
6163         if (requestsStartedCount_readyRead < 30 && reply->bytesAvailable() > 27906/2) {
6164             startOne();
6165             requestsStartedCount_readyRead++;
6166         }
6167     }
6168     void startOne()
6169     {
6170         QUrl url = "http://" + QtNetworkSettings::serverName() + "/qtest/fluke.gif";
6171         QNetworkRequest request(url);
6172         QNetworkReply *reply = manager.get(request);
6173         reply->setParent(this);
6174         connect(reply, SIGNAL(finished()), this, SLOT(finishedSlot()));
6175         connect(reply, SIGNAL(readyRead()), this, SLOT(readyReadSlot()));
6176     }
6177 };
6178 
6179 void tst_QNetworkReply::httpRecursiveCreation()
6180 {
6181     // this test checks if creation of new requests to the same host properly works
6182     // from readyRead() and finished() signals
6183     HttpRecursiveCreationHelper helper;
6184     helper.startOne();
6185     QTestEventLoop::instance().enterLoop(30);
6186     QVERIFY(!QTestEventLoop::instance().timeout());
6187 }
6188 
6189 #ifndef QT_NO_SSL
6190 void tst_QNetworkReply::ignoreSslErrorsList_data()
6191 {
6192     QTest::addColumn<QString>("url");
6193     QTest::addColumn<QList<QSslError> >("expectedSslErrors");
6194     QTest::addColumn<QNetworkReply::NetworkError>("expectedNetworkError");
6195 
6196     QList<QSslError> expectedSslErrors;
6197     QList<QSslCertificate> certs = QSslCertificate::fromPath(testDataDir + certsFilePath);
6198     QSslError rightError(FLUKE_CERTIFICATE_ERROR, certs.at(0));
6199     QSslError wrongError(FLUKE_CERTIFICATE_ERROR);
6200 
6201     QTest::newRow("SSL-failure-empty-list") << "https://" + QtNetworkSettings::serverName() + "/index.html" << expectedSslErrors << QNetworkReply::SslHandshakeFailedError;
6202     expectedSslErrors.append(wrongError);
6203     QTest::newRow("SSL-failure-wrong-error") << "https://" + QtNetworkSettings::serverName() + "/index.html" << expectedSslErrors << QNetworkReply::SslHandshakeFailedError;
6204     expectedSslErrors.append(rightError);
6205     QTest::newRow("allErrorsInExpectedList1") << "https://" + QtNetworkSettings::serverName() + "/index.html" << expectedSslErrors << QNetworkReply::NoError;
6206     expectedSslErrors.removeAll(wrongError);
6207     QTest::newRow("allErrorsInExpectedList2") << "https://" + QtNetworkSettings::serverName() + "/index.html" << expectedSslErrors << QNetworkReply::NoError;
6208     expectedSslErrors.removeAll(rightError);
6209     QTest::newRow("SSL-failure-empty-list-again") << "https://" + QtNetworkSettings::serverName() + "/index.html" << expectedSslErrors << QNetworkReply::SslHandshakeFailedError;
6210 }
6211 
6212 void tst_QNetworkReply::ignoreSslErrorsList()
6213 {
6214     QFETCH(QString, url);
6215     QNetworkRequest request(url);
6216     QNetworkReplyPtr reply(manager.get(request));
6217 
6218     QFETCH(QList<QSslError>, expectedSslErrors);
6219     reply->ignoreSslErrors(expectedSslErrors);
6220 
6221     QVERIFY(waitForFinish(reply) != Timeout);
6222 
6223     QFETCH(QNetworkReply::NetworkError, expectedNetworkError);
6224     QCOMPARE(reply->error(), expectedNetworkError);
6225 }
6226 
6227 void tst_QNetworkReply::ignoreSslErrorsListWithSlot_data()
6228 {
6229     ignoreSslErrorsList_data();
6230 }
6231 
6232 // this is not a test, just a slot called in the test below
6233 void tst_QNetworkReply::ignoreSslErrorListSlot(QNetworkReply *reply, const QList<QSslError> &)
6234 {
6235     reply->ignoreSslErrors(storedExpectedSslErrors);
6236 }
6237 
6238 // do the same as in ignoreSslErrorsList, but ignore the errors in the slot
6239 void tst_QNetworkReply::ignoreSslErrorsListWithSlot()
6240 {
6241     QFETCH(QString, url);
6242     QNetworkRequest request(url);
6243     QNetworkReplyPtr reply(manager.get(request));
6244 
6245     QFETCH(QList<QSslError>, expectedSslErrors);
6246     // store the errors to ignore them later in the slot connected below
6247     storedExpectedSslErrors = expectedSslErrors;
6248     connect(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
6249             this, SLOT(ignoreSslErrorListSlot(QNetworkReply*,QList<QSslError>)));
6250 
6251 
6252     QVERIFY(waitForFinish(reply) != Timeout);
6253 
6254     QFETCH(QNetworkReply::NetworkError, expectedNetworkError);
6255     QCOMPARE(reply->error(), expectedNetworkError);
6256 }
6257 
6258 void tst_QNetworkReply::sslConfiguration_data()
6259 {
6260     QTest::addColumn<QSslConfiguration>("configuration");
6261     QTest::addColumn<bool>("works");
6262 
6263     QTest::newRow("empty") << QSslConfiguration() << false;
6264     QSslConfiguration conf = QSslConfiguration::defaultConfiguration();
6265     QTest::newRow("default") << conf << false; // does not contain test server cert
6266     QList<QSslCertificate> testServerCert = QSslCertificate::fromPath(testDataDir + certsFilePath);
6267     conf.setCaCertificates(testServerCert);
6268     QTest::newRow("set-root-cert") << conf << true;
6269     conf.setProtocol(QSsl::SecureProtocols);
6270     QTest::newRow("secure") << conf << true;
6271 }
6272 
6273 void tst_QNetworkReply::encrypted()
6274 {
6275     qDebug() << QtNetworkSettings::serverName();
6276     QUrl url("https://" + QtNetworkSettings::serverName());
6277     QNetworkRequest request(url);
6278     QNetworkReply *reply = manager.get(request);
6279     reply->ignoreSslErrors();
6280 
6281     QSignalSpy spy(reply, SIGNAL(encrypted()));
6282     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6283     QTestEventLoop::instance().enterLoop(20);
6284     QVERIFY(!QTestEventLoop::instance().timeout());
6285 
6286     QCOMPARE(spy.count(), 1);
6287 
6288     reply->deleteLater();
6289 }
6290 
6291 void tst_QNetworkReply::sslConfiguration()
6292 {
6293     QNetworkRequest request(QUrl("https://" + QtNetworkSettings::serverName() + "/index.html"));
6294     QFETCH(QSslConfiguration, configuration);
6295     request.setSslConfiguration(configuration);
6296     QNetworkReplyPtr reply(manager.get(request));
6297 
6298     QVERIFY(waitForFinish(reply) != Timeout);
6299 
6300     QFETCH(bool, works);
6301     QNetworkReply::NetworkError expectedError = works ? QNetworkReply::NoError : QNetworkReply::SslHandshakeFailedError;
6302     QCOMPARE(reply->error(), expectedError);
6303 }
6304 
6305 #ifdef QT_BUILD_INTERNAL
6306 
6307 void tst_QNetworkReply::sslSessionSharing_data()
6308 {
6309     QTest::addColumn<bool>("sessionSharingEnabled");
6310     QTest::newRow("enabled") << true;
6311     QTest::newRow("disabled") << false;
6312 }
6313 
6314 void tst_QNetworkReply::sslSessionSharing()
6315 {
6316 #ifdef QT_SECURETRANSPORT
6317     QSKIP("Not implemented with SecureTransport");
6318 #endif
6319 
6320     QString urlString("https://" + QtNetworkSettings::serverName());
6321     QList<QNetworkReplyPtr> replies;
6322 
6323     // warm up SSL session cache
6324     QNetworkRequest warmupRequest(urlString);
6325     QFETCH(bool, sessionSharingEnabled);
6326     warmupRequest.setAttribute(QNetworkRequest::User, sessionSharingEnabled); // so we can read it from the slot
6327     if (! sessionSharingEnabled) {
6328         QSslConfiguration configuration(QSslConfiguration::defaultConfiguration());
6329         configuration.setSslOption(QSsl::SslOptionDisableSessionSharing, true);
6330         warmupRequest.setSslConfiguration(configuration);
6331     }
6332     QNetworkReply *reply = manager.get(warmupRequest);
6333     reply->ignoreSslErrors();
6334     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6335     QTestEventLoop::instance().enterLoop(20);
6336     QVERIFY(!QTestEventLoop::instance().timeout());
6337     QCOMPARE(reply->error(), QNetworkReply::NoError);
6338     reply->deleteLater();
6339 
6340     // now send several requests at the same time, so we open more sockets and reuse the SSL session
6341     for (int a = 0; a < 6; a++) {
6342         QNetworkRequest request(warmupRequest);
6343         replies.append(QNetworkReplyPtr(manager.get(request)));
6344         connect(replies.at(a), SIGNAL(finished()), this, SLOT(sslSessionSharingHelperSlot()));
6345     }
6346     QTestEventLoop::instance().enterLoop(20);
6347     QVERIFY(!QTestEventLoop::instance().timeout());
6348 }
6349 
6350 void tst_QNetworkReply::sslSessionSharingHelperSlot()
6351 {
6352     static int count = 0;
6353 
6354     // check that SSL session sharing was used in at least one of the replies
6355     static bool sslSessionSharingWasUsed = false;
6356     QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
6357     bool sslSessionSharingWasUsedInReply = QSslConfigurationPrivate::peerSessionWasShared(reply->sslConfiguration());
6358     if (sslSessionSharingWasUsedInReply)
6359         sslSessionSharingWasUsed = true;
6360 
6361     QString urlQueryString = reply->url().query();
6362     QCOMPARE(reply->error(), QNetworkReply::NoError);
6363 
6364     count++;
6365 
6366     if (count == 6) { // all replies have finished
6367         QTestEventLoop::instance().exitLoop();
6368         bool sessionSharingWasEnabled = reply->request().attribute(QNetworkRequest::User).toBool();
6369         QCOMPARE(sslSessionSharingWasUsed, sessionSharingWasEnabled);
6370         count = 0; // reset for next row
6371         sslSessionSharingWasUsed = false; // reset for next row
6372     }
6373 }
6374 
6375 void tst_QNetworkReply::sslSessionSharingFromPersistentSession_data()
6376 {
6377     QTest::addColumn<bool>("sessionPersistenceEnabled");
6378     QTest::newRow("enabled") << true;
6379     QTest::newRow("disabled") << false;
6380 }
6381 
6382 void tst_QNetworkReply::sslSessionSharingFromPersistentSession()
6383 {
6384 #ifdef QT_SECURETRANSPORT
6385     QSKIP("Not implemented with SecureTransport");
6386 #endif
6387 
6388     QString urlString("https://" + QtNetworkSettings::serverName());
6389 
6390     // warm up SSL session cache to get a working session
6391     QNetworkRequest warmupRequest(urlString);
6392     QFETCH(bool, sessionPersistenceEnabled);
6393     if (sessionPersistenceEnabled) {
6394         QSslConfiguration warmupConfiguration(QSslConfiguration::defaultConfiguration());
6395         warmupConfiguration.setSslOption(QSsl::SslOptionDisableSessionPersistence, false);
6396         warmupRequest.setSslConfiguration(warmupConfiguration);
6397     }
6398     QNetworkReply *warmupReply = manager.get(warmupRequest);
6399     warmupReply->ignoreSslErrors();
6400     connect(warmupReply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6401     QTestEventLoop::instance().enterLoop(20);
6402     QVERIFY(!QTestEventLoop::instance().timeout());
6403     QCOMPARE(warmupReply->error(), QNetworkReply::NoError);
6404     QByteArray sslSession = warmupReply->sslConfiguration().sessionTicket();
6405     QCOMPARE(!sslSession.isEmpty(), sessionPersistenceEnabled);
6406 
6407     // test server sends a life time hint of 0 (old server) or 300 (new server),
6408     // without session ticket we get -1
6409     QList<int> expectedSessionTicketLifeTimeHint = sessionPersistenceEnabled
6410             ? QList<int>() << 0 << 300 : QList<int>() << -1;
6411     QVERIFY2(expectedSessionTicketLifeTimeHint.contains(
6412                  warmupReply->sslConfiguration().sessionTicketLifeTimeHint()),
6413              "server did not send expected session life time hint");
6414 
6415     warmupReply->deleteLater();
6416 
6417     // now send another request with a new QNAM and the persisted session,
6418     // to verify it can be resumed without any internal state
6419     QNetworkRequest request(warmupRequest);
6420     if (sessionPersistenceEnabled) {
6421         QSslConfiguration configuration = request.sslConfiguration();
6422         configuration.setSessionTicket(sslSession);
6423         request.setSslConfiguration(configuration);
6424     }
6425     QNetworkAccessManager newManager;
6426     QNetworkReply *reply = newManager.get(request);
6427     reply->ignoreSslErrors();
6428     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6429     QTestEventLoop::instance().enterLoop(20);
6430     QVERIFY(!QTestEventLoop::instance().timeout());
6431     QCOMPARE(reply->error(), QNetworkReply::NoError);
6432 
6433     bool sslSessionSharingWasUsedInReply = QSslConfigurationPrivate::peerSessionWasShared(
6434                 reply->sslConfiguration());
6435     QCOMPARE(sessionPersistenceEnabled, sslSessionSharingWasUsedInReply);
6436 }
6437 
6438 #endif // QT_BUILD_INTERNAL
6439 #endif // QT_NO_SSL
6440 
6441 void tst_QNetworkReply::getAndThenDeleteObject_data()
6442 {
6443     QTest::addColumn<bool>("replyFirst");
6444 
6445     QTest::newRow("delete-reply-first") << true;
6446     QTest::newRow("delete-qnam-first") << false;
6447 }
6448 
6449 void tst_QNetworkReply::getAndThenDeleteObject()
6450 {
6451     QSKIP("unstable test - reply may be finished too early");
6452     // yes, this will leak if the testcase fails. I don't care. It must not fail then :P
6453     QNetworkAccessManager *manager = new QNetworkAccessManager();
6454     QNetworkRequest request("http://" + QtNetworkSettings::serverName() + "/qtest/bigfile");
6455     QNetworkReply *reply = manager->get(request);
6456     reply->setReadBufferSize(1);
6457     reply->setParent((QObject*)0); // must be 0 because else it is the manager
6458 
6459     QTRY_VERIFY_WITH_TIMEOUT(reply->bytesAvailable(), 30000);
6460     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
6461     QVERIFY(!reply->isFinished()); // must not be finished
6462 
6463     QFETCH(bool, replyFirst);
6464 
6465     if (replyFirst) {
6466         delete reply;
6467         delete manager;
6468     } else {
6469         delete manager;
6470         delete reply;
6471     }
6472 }
6473 
6474 // see https://bugs.webkit.org/show_bug.cgi?id=38935
6475 void tst_QNetworkReply::symbianOpenCDataUrlCrash()
6476 {
6477     QString requestUrl("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAWCAYAAAA1vze2AAAAB3RJTUUH2AUSEgolrgBvVQAAAAlwSFlzAAALEwAACxMBAJqcGAAAAARnQU1BAACxjwv8YQUAAAHlSURBVHja5VbNShxBEK6ZaXtnHTebQPA1gngNmfaeq+QNPIlIXkC9iQdJxJNvEHLN3VkxhxxE8gTmEhAVddXZ6Z3f9Ndriz89/sHmkBQUVVT1fB9d9c3uOERUKTunIdn3HzstxGpYBDS4wZk7TAJj/wlJ90J+jnuygqs8svSj+/rGHBos3rE18XBvfU3no7NzlJfUaY/5whAwl8Lr/WDUv4ODxTMb+P5xLExe5LmO559WqTX/MQR4WZYEAtSePS4pE0qSnuhnRUcBU5Gm2k9XljU4Z26I3NRxBrd80rj2fh+KNE0FY4xevRgTjREvPFpasAK8Xli6MUbbuKw3afAGgSBXozo5u4hkmncAlkl5wx8iMGbdyQjnCFEiEwGiosj1UQA/x2rVddiVoi+l4IxE0PTDnx+mrQBvvnx9cFz3krhVvuhzFn579/aq/n5rW8fbtTqiWhIQZEo17YBvbkxOXNVndnYpTvod7AtiuN2re0+siwcB9oH8VxxrNwQQAhzyRs30n7wTI2HIN2g2QtQwjjhJIQatOq7E8bIVCLwzpl83Lvtvl+NohWWlE8UZTWEMAGCcR77fHKhPnZF5tYie6dfdxCphACmLPM+j8bYfmTryg64kV9Vh3mV8jP0b/4wO/YUPiT/8i0MLf55lSQAAAABJRU5ErkJggg==");
6478     QUrl url = QUrl::fromEncoded(requestUrl.toLatin1());
6479     QNetworkRequest req(url);
6480     QNetworkReplyPtr reply;
6481 
6482     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, req, reply));
6483 
6484     QCOMPARE(reply->url(), url);
6485     QCOMPARE(reply->error(), QNetworkReply::NoError);
6486 
6487     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), qint64(598));
6488 }
6489 
6490 void tst_QNetworkReply::getFromHttpIntoBuffer_data()
6491 {
6492     QTest::addColumn<QUrl>("url");
6493 
6494     QTest::newRow("rfc-internal") << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt");
6495 }
6496 
6497 // Please note that the whole "zero copy" download buffer API is private right now. Do not use it.
6498 void tst_QNetworkReply::getFromHttpIntoBuffer()
6499 {
6500     QFETCH(QUrl, url);
6501     QNetworkRequest request(url);
6502     request.setAttribute(QNetworkRequest::MaximumDownloadBufferSizeAttribute, 1024*128); // 128 kB
6503 
6504     QNetworkAccessManager manager;
6505     QNetworkReply *reply = manager.get(request);
6506     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6507     QTestEventLoop::instance().enterLoop(10);
6508     QVERIFY(!QTestEventLoop::instance().timeout());
6509     QVERIFY(reply->isFinished());
6510 
6511     QFile reference(testDataDir + "/rfc3252.txt");
6512     QVERIFY(reference.open(QIODevice::ReadOnly));
6513 
6514     QCOMPARE(reference.bytesAvailable(), reply->bytesAvailable());
6515     QCOMPARE(reference.size(), reply->size());
6516 
6517     // Compare the memory buffer
6518     QVariant downloadBufferAttribute = reply->attribute(QNetworkRequest::DownloadBufferAttribute);
6519     QVERIFY(downloadBufferAttribute.isValid());
6520     QSharedPointer<char> sharedPointer = downloadBufferAttribute.value<QSharedPointer<char> >();
6521     bool memoryComparison =
6522             (0 == memcmp(static_cast<void*>(reference.readAll().data()),
6523                          sharedPointer.data(), reference.size()));
6524     QVERIFY(memoryComparison);
6525 
6526     // Make sure the normal reading works
6527     reference.seek(0);
6528     QCOMPARE(reply->read(42), reference.read(42));
6529     QCOMPARE(reply->getChar(0), reference.getChar(0));
6530     QCOMPARE(reply->peek(23), reference.peek(23));
6531     QCOMPARE(reply->readLine(), reference.readLine());
6532     QCOMPARE(reference.bytesAvailable(), reply->bytesAvailable());
6533     QCOMPARE(reply->readAll(), reference.readAll());
6534     QVERIFY(reply->atEnd());
6535 }
6536 
6537 // FIXME we really need to consolidate all those server implementations
6538 class GetFromHttpIntoBuffer2Server : QObject
6539 {
6540     Q_OBJECT
6541     qint64 dataSize;
6542     qint64 dataSent;
6543     QTcpServer server;
6544     QTcpSocket *client;
6545     bool serverSendsContentLength;
6546     bool chunkedEncoding;
6547 
6548 public:
6549     GetFromHttpIntoBuffer2Server (qint64 ds, bool sscl, bool ce)
6550         : dataSize(ds), dataSent(0), client(0),
6551           serverSendsContentLength(sscl), chunkedEncoding(ce)
6552     {
6553         server.listen();
6554         connect(&server, SIGNAL(newConnection()), this, SLOT(newConnectionSlot()));
6555     }
6556 
6557     int serverPort() { return server.serverPort(); }
6558 
6559 public slots:
6560 
6561     void newConnectionSlot()
6562     {
6563         client = server.nextPendingConnection();
6564         client->setParent(this);
6565         connect(client, SIGNAL(readyRead()), this, SLOT(readyReadSlot()));
6566         connect(client, SIGNAL(bytesWritten(qint64)), this, SLOT(bytesWrittenSlot(qint64)));
6567     }
6568 
6569     void readyReadSlot()
6570     {
6571         client->readAll();
6572         client->write("HTTP/1.0 200 OK\n");
6573         if (serverSendsContentLength)
6574             client->write(QString("Content-Length: " + QString::number(dataSize) + "\n").toLatin1());
6575         if (chunkedEncoding)
6576             client->write(QString("Transfer-Encoding: chunked\n").toLatin1());
6577         client->write("Connection: close\n\n");
6578     }
6579 
6580     void bytesWrittenSlot(qint64 amount)
6581     {
6582         Q_UNUSED(amount);
6583         if (dataSent == dataSize && client) {
6584             // close eventually
6585 
6586             // chunked encoding: we have to send a last "empty" chunk
6587             if (chunkedEncoding)
6588                 client->write(QString("0\r\n\r\n").toLatin1());
6589 
6590             client->disconnectFromHost();
6591             server.close();
6592             client = 0;
6593             return;
6594         }
6595 
6596         // send data
6597         if (client && client->bytesToWrite() < 100*1024 && dataSent < dataSize) {
6598             qint64 amount = qMin(qint64(16*1024), dataSize - dataSent);
6599             QByteArray data(amount, '@');
6600 
6601             if (chunkedEncoding) {
6602                 client->write(QByteArray::number(amount, 16).toUpper());
6603                 client->write("\r\n");
6604                 client->write(data.constData(), amount);
6605                 client->write("\r\n");
6606             } else {
6607                 client->write(data.constData(), amount);
6608             }
6609 
6610             dataSent += amount;
6611         }
6612     }
6613 };
6614 
6615 class GetFromHttpIntoBuffer2Client : QObject
6616 {
6617     Q_OBJECT
6618 private:
6619     bool useDownloadBuffer;
6620     QNetworkReply *reply;
6621     qint64 uploadSize;
6622     QList<qint64> bytesAvailableList;
6623 public:
6624     GetFromHttpIntoBuffer2Client (QNetworkReply *reply, bool useDownloadBuffer, qint64 uploadSize)
6625         : useDownloadBuffer(useDownloadBuffer), reply(reply), uploadSize(uploadSize)
6626     {
6627         connect(reply, SIGNAL(metaDataChanged()), this, SLOT(metaDataChangedSlot()));
6628         connect(reply, SIGNAL(readyRead()), this, SLOT(readyReadSlot()));
6629         connect(reply, SIGNAL(finished()), this, SLOT(finishedSlot()));
6630     }
6631 
6632     public slots:
6633     void metaDataChangedSlot()
6634     {
6635         if (useDownloadBuffer) {
6636             QSharedPointer<char> sharedPointer = qvariant_cast<QSharedPointer<char> >(reply->attribute(QNetworkRequest::DownloadBufferAttribute));
6637             QVERIFY(!sharedPointer.isNull()); // It will be 0 if it failed
6638         }
6639 
6640         // metaDataChanged needs to come before everything else
6641         QVERIFY(bytesAvailableList.isEmpty());
6642     }
6643 
6644     void readyReadSlot()
6645     {
6646         QVERIFY(!reply->isFinished());
6647 
6648         qint64 bytesAvailable = reply->bytesAvailable();
6649 
6650         // bytesAvailable must never be 0
6651         QVERIFY(bytesAvailable != 0);
6652 
6653         if (bytesAvailableList.length() < 5) {
6654             // We assume that the first few times the bytes available must be less than the complete size, e.g.
6655             // the bytesAvailable() function works correctly in case of a downloadBuffer.
6656             QVERIFY(bytesAvailable < uploadSize);
6657         }
6658         if (!bytesAvailableList.isEmpty()) {
6659             // Also check that the same bytesAvailable is not coming twice in a row
6660             QVERIFY(bytesAvailableList.last() != bytesAvailable);
6661         }
6662 
6663         bytesAvailableList.append(bytesAvailable);
6664         // Add bytesAvailable to a list an parse
6665     }
6666 
6667     void finishedSlot()
6668     {
6669         // We should have already received all readyRead
6670         QVERIFY(!bytesAvailableList.isEmpty());
6671         QCOMPARE(bytesAvailableList.last(), uploadSize);
6672     }
6673 };
6674 
6675 void tst_QNetworkReply::getFromHttpIntoBuffer2_data()
6676 {
6677     QTest::addColumn<bool>("useDownloadBuffer");
6678 
6679     QTest::newRow("use-download-buffer") << true;
6680     QTest::newRow("do-not-use-download-buffer") << false;
6681 }
6682 
6683 // This test checks mostly that signal emissions are in correct order
6684 // Please note that the whole "zero copy" download buffer API is private right now. Do not use it.
6685 void tst_QNetworkReply::getFromHttpIntoBuffer2()
6686 {
6687     QFETCH(bool, useDownloadBuffer);
6688 
6689     // On my Linux Desktop the results are already visible with 128 kB, however we use this to have good results.
6690     enum {UploadSize = 32*1024*1024}; // 32 MB
6691 
6692     GetFromHttpIntoBuffer2Server server(UploadSize, true, false);
6693 
6694     QNetworkRequest request(QUrl("http://127.0.0.1:" + QString::number(server.serverPort()) + "/?bare=1"));
6695     if (useDownloadBuffer)
6696         request.setAttribute(QNetworkRequest::MaximumDownloadBufferSizeAttribute, 1024*1024*128); // 128 MB is max allowed
6697 
6698     QNetworkAccessManager manager;
6699     QNetworkReplyPtr reply(manager.get(request));
6700 
6701     GetFromHttpIntoBuffer2Client client(reply.data(), useDownloadBuffer, UploadSize);
6702 
6703     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
6704     QTestEventLoop::instance().enterLoop(40);
6705     QCOMPARE(reply->error(), QNetworkReply::NoError);
6706     QVERIFY(!QTestEventLoop::instance().timeout());
6707 }
6708 
6709 
6710 void tst_QNetworkReply::getFromHttpIntoBufferCanReadLine()
6711 {
6712     QString header("HTTP/1.0 200 OK\r\nContent-Length: 7\r\n\r\nxxx\nxxx");
6713 
6714     MiniHttpServer server(header.toLatin1());
6715     server.doClose = true;
6716 
6717     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
6718     request.setAttribute(QNetworkRequest::MaximumDownloadBufferSizeAttribute, 1024*1024*128); // 128 MB is max allowed
6719     QNetworkReplyPtr reply(manager.get(request));
6720 
6721     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
6722 
6723     QCOMPARE(reply->error(), QNetworkReply::NoError);
6724     QVERIFY(reply->canReadLine());
6725     QCOMPARE(reply->read(1), QByteArray("x"));
6726     QVERIFY(reply->canReadLine());
6727     QCOMPARE(reply->read(3), QByteArray("xx\n"));
6728     QVERIFY(!reply->canReadLine());
6729     QCOMPARE(reply->readAll(), QByteArray("xxx"));
6730     QVERIFY(!reply->canReadLine());
6731 }
6732 
6733 
6734 
6735 // Is handled somewhere else too, introduced this special test to have it more accessible
6736 void tst_QNetworkReply::ioGetFromHttpWithoutContentLength()
6737 {
6738     QByteArray dataToSend("HTTP/1.0 200 OK\r\n\r\nHALLO! 123!");
6739     MiniHttpServer server(dataToSend);
6740     server.doClose = true;
6741 
6742     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
6743     QNetworkReplyPtr reply(manager.get(request));
6744 
6745     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
6746 
6747     QCOMPARE(reply->url(), request.url());
6748     QVERIFY(reply->isFinished());
6749     QCOMPARE(reply->error(), QNetworkReply::NoError);
6750 }
6751 
6752 // Is handled somewhere else too, introduced this special test to have it more accessible
6753 void tst_QNetworkReply::ioGetFromHttpBrokenChunkedEncoding()
6754 {
6755     // This is wrong chunked encoding because of the X. What actually has to follow is \r\n
6756     // and then the declaration of the final 0 chunk
6757     QByteArray dataToSend("HTTP/1.0 200 OK\r\nTransfer-Encoding: chunked\r\n\r\n3\r\nABCX");
6758     MiniHttpServer server(dataToSend);
6759     server.doClose = false; // FIXME
6760 
6761     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
6762     QNetworkReplyPtr reply(manager.get(request));
6763 
6764     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
6765     QTestEventLoop::instance().enterLoop(10);
6766 
6767     QEXPECT_FAIL(0, "We should close the socket and not just do nothing", Continue);
6768     QVERIFY(!QTestEventLoop::instance().timeout());
6769     QEXPECT_FAIL(0, "We should close the socket and not just do nothing", Continue);
6770     QVERIFY(reply->isFinished());
6771     QCOMPARE(reply->error(), QNetworkReply::NoError);
6772 }
6773 
6774 // TODO:
6775 // Prepare a gzip that has one chunk that expands to the size mentioned in the bugreport.
6776 // Then have a custom HTTP server that waits after this chunk so the returning gets
6777 // triggered.
6778 void tst_QNetworkReply::qtbug12908compressedHttpReply()
6779 {
6780     QString header("HTTP/1.0 200 OK\r\nContent-Encoding: gzip\r\nContent-Length: 63\r\n\r\n");
6781 
6782     // dd if=/dev/zero of=qtbug-12908 bs=16384  count=1 && gzip qtbug-12908 && base64 -w 0 qtbug-12908.gz
6783     QString encodedFile("H4sICDdDaUwAA3F0YnVnLTEyOTA4AO3BMQEAAADCoPVPbQwfoAAAAAAAAAAAAAAAAAAAAIC3AYbSVKsAQAAA");
6784     QByteArray decodedFile = QByteArray::fromBase64(encodedFile.toLatin1());
6785     QCOMPARE(decodedFile.size(), 63);
6786 
6787     MiniHttpServer server(header.toLatin1() + decodedFile);
6788     server.doClose = true;
6789 
6790     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
6791     QNetworkReplyPtr reply(manager.get(request));
6792 
6793     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
6794 
6795     QCOMPARE(reply->error(), QNetworkReply::NoError);
6796     QCOMPARE(reply->size(), qint64(16384));
6797     QCOMPARE(reply->readAll(), QByteArray(16384, '\0'));
6798 }
6799 
6800 void tst_QNetworkReply::compressedHttpReplyBrokenGzip()
6801 {
6802     QString header("HTTP/1.0 200 OK\r\nContent-Encoding: gzip\r\nContent-Length: 63\r\n\r\n");
6803 
6804     // dd if=/dev/zero of=qtbug-12908 bs=16384  count=1 && gzip qtbug-12908 && base64 -w 0 qtbug-12908.gz
6805     // Then change "BMQ" to "BMX"
6806     QString encodedFile("H4sICDdDaUwAA3F0YnVnLTEyOTA4AO3BMXEAAADCoPVPbQwfoAAAAAAAAAAAAAAAAAAAAIC3AYbSVKsAQAAA");
6807     QByteArray decodedFile = QByteArray::fromBase64(encodedFile.toLatin1());
6808     QCOMPARE(decodedFile.size(), 63);
6809 
6810     MiniHttpServer server(header.toLatin1() + decodedFile);
6811     server.doClose = true;
6812 
6813     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
6814     QNetworkReplyPtr reply(manager.get(request));
6815 
6816     QCOMPARE(waitForFinish(reply), int(Failure));
6817 
6818     QCOMPARE(reply->error(), QNetworkReply::ProtocolFailure);
6819 }
6820 
6821 // TODO add similar test for FTP
6822 void tst_QNetworkReply::getFromUnreachableIp()
6823 {
6824     QNetworkAccessManager manager;
6825 
6826 #ifdef Q_OS_WIN
6827     // This test assumes that attempt to connect to 255.255.255.255 fails more
6828     // or less fast/immediately. This is not what we observe on Windows:
6829     // WSAConnect on non-blocking socket returns SOCKET_ERROR, WSAGetLastError
6830     // returns WSAEWOULDBLOCK (expected) and getsockopt most of the time returns
6831     // NOERROR; so socket engine starts a timer (30 s.) and waits for a timeout/
6832     // error/success. Unfortunately, the test itself is waiting only for 5 s.
6833     // So we have to adjust the connection timeout or skip the test completely
6834     // if the 'bearermanagement' feature is not available.
6835 #if QT_CONFIG(bearermanagement)
6836     class ConfigurationGuard
6837     {
6838     public:
6839         explicit ConfigurationGuard(QNetworkAccessManager *m)
6840             : manager(m)
6841         {
6842             Q_ASSERT(m);
6843             auto conf = manager->configuration();
6844             previousTimeout = conf.connectTimeout();
6845             conf.setConnectTimeout(1500);
6846             manager->setConfiguration(conf);
6847         }
6848         ~ConfigurationGuard()
6849         {
6850             Q_ASSERT(manager);
6851             auto conf = manager->configuration();
6852             conf.setConnectTimeout(previousTimeout);
6853             manager->setConfiguration(conf);
6854         }
6855     private:
6856         QNetworkAccessManager *manager = nullptr;
6857         int previousTimeout = 0;
6858 
6859         Q_DISABLE_COPY(ConfigurationGuard)
6860     };
6861 
6862     const ConfigurationGuard restorer(&manager);
6863 #else // bearermanagement
6864     QSKIP("This test is non-deterministic on Windows x86");
6865 #endif // !bearermanagement
6866 #endif // Q_OS_WIN
6867 
6868     QNetworkRequest request(QUrl("http://255.255.255.255/42/23/narf/narf/narf"));
6869     QNetworkReplyPtr reply(manager.get(request));
6870 
6871     QCOMPARE(waitForFinish(reply), int(Failure));
6872 
6873     QVERIFY(reply->error() != QNetworkReply::NoError);
6874 }
6875 
6876 void tst_QNetworkReply::qtbug4121unknownAuthentication()
6877 {
6878     MiniHttpServer server(QByteArray("HTTP/1.1 401 bla\r\nWWW-Authenticate: crap\r\nContent-Length: 0\r\n\r\n"));
6879     server.doClose = false;
6880 
6881     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
6882     QNetworkAccessManager manager;
6883     QNetworkReplyPtr reply(manager.get(request));
6884 
6885     QSignalSpy authSpy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
6886     QSignalSpy finishedSpy(&manager, SIGNAL(finished(QNetworkReply*)));
6887     QSignalSpy errorSpy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
6888 
6889     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
6890     QTestEventLoop::instance().enterLoop(10);
6891     QVERIFY(!QTestEventLoop::instance().timeout());
6892 
6893     QCOMPARE(authSpy.count(), 0);
6894     QCOMPARE(finishedSpy.count(), 1);
6895     QCOMPARE(errorSpy.count(), 1);
6896 
6897     QCOMPARE(reply->error(), QNetworkReply::AuthenticationRequiredError);
6898 }
6899 
6900 #ifndef QT_NO_NETWORKPROXY
6901 void tst_QNetworkReply::authenticationCacheAfterCancel_data()
6902 {
6903     QTest::addColumn<QNetworkProxy>("proxy");
6904     QTest::addColumn<bool>("proxyAuth");
6905     QTest::addColumn<QUrl>("url");
6906     for (int i = 0; i < proxies.count(); ++i) {
6907         QTest::newRow("http" + proxies.at(i).tag) << proxies.at(i).proxy << proxies.at(i).requiresAuthentication << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt");
6908 #ifndef QT_NO_SSL
6909         QTest::newRow("https" + proxies.at(i).tag) << proxies.at(i).proxy << proxies.at(i).requiresAuthentication << QUrl("https://" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt");
6910 #endif
6911     }
6912 }
6913 
6914 class AuthenticationCacheHelper : public QObject
6915 {
6916     Q_OBJECT
6917 public:
6918     AuthenticationCacheHelper()
6919     {}
6920 public slots:
6921     void proxyAuthenticationRequired(const QNetworkProxy &, QAuthenticator *auth)
6922     {
6923         if (!proxyPassword.isNull()) {
6924             auth->setUser(proxyUserName);
6925             auth->setPassword(proxyPassword);
6926             //clear credentials, if they are asked again, they were bad
6927             proxyUserName.clear();
6928             proxyPassword.clear();
6929         }
6930     }
6931     void authenticationRequired(QNetworkReply*,QAuthenticator *auth)
6932     {
6933         if (!httpPassword.isNull()) {
6934             auth->setUser(httpUserName);
6935             auth->setPassword(httpPassword);
6936             //clear credentials, if they are asked again, they were bad
6937             httpUserName.clear();
6938             httpPassword.clear();
6939         }
6940     }
6941 public:
6942     QString httpUserName;
6943     QString httpPassword;
6944     QString proxyUserName;
6945     QString proxyPassword;
6946 };
6947 
6948 /* Purpose of this test is to check credentials are cached correctly.
6949  - If user cancels authentication dialog (i.e. nothing is set to the QAuthenticator by the callback) then this is not cached
6950  - if user supplies a wrong password, then this is not cached
6951  - if user supplies a correct user/password combination then this is cached
6952 
6953  Test is checking both the proxyAuthenticationRequired and authenticationRequired signals.
6954  */
6955 void tst_QNetworkReply::authenticationCacheAfterCancel()
6956 {
6957     QFETCH(QNetworkProxy, proxy);
6958     QFETCH(bool, proxyAuth);
6959     QFETCH(QUrl, url);
6960     QNetworkAccessManager manager;
6961 #ifndef QT_NO_SSL
6962     connect(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
6963             SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
6964 #endif
6965     manager.setProxy(proxy);
6966     QSignalSpy authSpy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
6967     QSignalSpy proxyAuthSpy(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
6968 
6969     AuthenticationCacheHelper helper;
6970     connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)), &helper, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
6971     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)), &helper, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
6972 
6973     QNetworkRequest request(url);
6974     QNetworkReplyPtr reply;
6975     if (proxyAuth) {
6976         //should fail due to no credentials
6977         reply.reset(manager.get(request));
6978         connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
6979         QTestEventLoop::instance().enterLoop(10);
6980         QVERIFY(!QTestEventLoop::instance().timeout());
6981 
6982         QCOMPARE(reply->error(), QNetworkReply::ProxyAuthenticationRequiredError);
6983         QCOMPARE(authSpy.count(), 0);
6984         QCOMPARE(proxyAuthSpy.count(), 1);
6985         proxyAuthSpy.clear();
6986 
6987         //should fail due to bad credentials
6988         helper.proxyUserName = "qsockstest";
6989         helper.proxyPassword = "badpassword";
6990         reply.reset(manager.get(request));
6991         connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
6992         QTestEventLoop::instance().enterLoop(10);
6993         QVERIFY(!QTestEventLoop::instance().timeout());
6994 
6995         // Work round known quirk in the old test server (danted -v < v1.1.19):
6996         if (reply->error() != QNetworkReply::HostNotFoundError)
6997             QCOMPARE(reply->error(), QNetworkReply::ProxyAuthenticationRequiredError);
6998         QCOMPARE(authSpy.count(), 0);
6999         QVERIFY(proxyAuthSpy.count() > 0);
7000         proxyAuthSpy.clear();
7001 
7002         // QTBUG-23136 workaround (needed even with danted v1.1.19):
7003         if (proxy.port() == 1081) {
7004 #ifdef QT_BUILD_INTERNAL
7005             QNetworkAccessManagerPrivate::clearAuthenticationCache(&manager);
7006             QNetworkAccessManagerPrivate::clearConnectionCache(&manager);
7007 #else
7008             return;
7009 #endif
7010         }
7011 
7012         //next proxy auth should succeed, due to correct credentials
7013         helper.proxyUserName = "qsockstest";
7014         helper.proxyPassword = "password";
7015     }
7016 
7017     //should fail due to no credentials
7018     reply.reset(manager.get(request));
7019     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
7020     QTestEventLoop::instance().enterLoop(10);
7021     QVERIFY(!QTestEventLoop::instance().timeout());
7022 
7023     QCOMPARE(reply->error(), QNetworkReply::AuthenticationRequiredError);
7024     QVERIFY(authSpy.count() > 0);
7025     authSpy.clear();
7026     if (proxyAuth) {
7027         QVERIFY(proxyAuthSpy.count() > 0);
7028         proxyAuthSpy.clear();
7029     }
7030 
7031     //should fail due to bad credentials
7032     helper.httpUserName = "baduser";
7033     helper.httpPassword = "badpassword";
7034     reply.reset(manager.get(request));
7035     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
7036     QTestEventLoop::instance().enterLoop(10);
7037     QVERIFY(!QTestEventLoop::instance().timeout());
7038 
7039     QCOMPARE(reply->error(), QNetworkReply::AuthenticationRequiredError);
7040     QVERIFY(authSpy.count() > 0);
7041     authSpy.clear();
7042     if (proxyAuth) {
7043         //should be supplied from cache
7044         QCOMPARE(proxyAuthSpy.count(), 0);
7045         proxyAuthSpy.clear();
7046     }
7047 
7048     //next auth should succeed, due to correct credentials
7049     helper.httpUserName = "httptest";
7050     helper.httpPassword = "httptest";
7051 
7052     reply.reset(manager.get(request));
7053     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
7054     QTestEventLoop::instance().enterLoop(10);
7055     QVERIFY(!QTestEventLoop::instance().timeout());
7056 
7057     QCOMPARE(reply->error(), QNetworkReply::NoError);
7058     QVERIFY(authSpy.count() > 0);
7059     authSpy.clear();
7060     if (proxyAuth) {
7061         //should be supplied from cache
7062         QCOMPARE(proxyAuthSpy.count(), 0);
7063         proxyAuthSpy.clear();
7064     }
7065 
7066     //next auth should use cached credentials
7067     reply.reset(manager.get(request));
7068     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
7069     QTestEventLoop::instance().enterLoop(10);
7070     QVERIFY(!QTestEventLoop::instance().timeout());
7071 
7072     QCOMPARE(reply->error(), QNetworkReply::NoError);
7073     //should be supplied from cache
7074     QCOMPARE(authSpy.count(), 0);
7075     authSpy.clear();
7076     if (proxyAuth) {
7077         //should be supplied from cache
7078         QCOMPARE(proxyAuthSpy.count(), 0);
7079         proxyAuthSpy.clear();
7080     }
7081 
7082 }
7083 
7084 void tst_QNetworkReply::authenticationWithDifferentRealm()
7085 {
7086     AuthenticationCacheHelper helper;
7087     QNetworkAccessManager manager;
7088 #ifndef QT_NO_SSL
7089     connect(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
7090             SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
7091 #endif
7092     connect(&manager, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)), &helper, SLOT(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)));
7093     connect(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)), &helper, SLOT(authenticationRequired(QNetworkReply*,QAuthenticator*)));
7094 
7095     helper.httpUserName = "httptest";
7096     helper.httpPassword = "httptest";
7097 
7098     QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfcs-auth/rfc3252.txt"));
7099     QNetworkReply* reply = manager.get(request);
7100     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
7101     QTestEventLoop::instance().enterLoop(10);
7102     QVERIFY(!QTestEventLoop::instance().timeout());
7103     QCOMPARE(reply->error(), QNetworkReply::NoError);
7104 
7105     helper.httpUserName = "httptest";
7106     helper.httpPassword = "httptest";
7107 
7108     request.setUrl(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/auth-digest/"));
7109     reply = manager.get(request);
7110     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
7111     QTestEventLoop::instance().enterLoop(10);
7112     QVERIFY(!QTestEventLoop::instance().timeout());
7113     QCOMPARE(reply->error(), QNetworkReply::NoError);
7114 }
7115 #endif // !QT_NO_NETWORKPROXY
7116 
7117 class QtBug13431Helper : public QObject
7118 {
7119     Q_OBJECT
7120 public:
7121     QNetworkReply* m_reply;
7122     QTimer m_dlTimer;
7123 public slots:
7124     void replyFinished(QNetworkReply*) { QTestEventLoop::instance().exitLoop(); }
7125 
7126     void onReadAndReschedule()
7127     {
7128         const qint64 bytesReceived = m_reply->bytesAvailable();
7129         if (bytesReceived && m_reply->readBufferSize()) {
7130            QByteArray data = m_reply->read(bytesReceived);
7131            // reschedule read
7132            const int millisecDelay = static_cast<int>(bytesReceived * 1000 / m_reply->readBufferSize());
7133            m_dlTimer.start(millisecDelay);
7134         }
7135         else {
7136            // reschedule read
7137            m_dlTimer.start(200);
7138         }
7139     }
7140 };
7141 
7142 void tst_QNetworkReply::qtbug13431replyThrottling()
7143 {
7144     QtBug13431Helper helper;
7145 
7146     QNetworkAccessManager nam;
7147     connect(&nam, SIGNAL(finished(QNetworkReply*)), &helper, SLOT(replyFinished(QNetworkReply*)));
7148 
7149     // Download a bigger file
7150     QNetworkRequest netRequest(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/bigfile"));
7151     helper.m_reply = nam.get(netRequest);
7152     // Set the throttle
7153     helper.m_reply->setReadBufferSize(36000);
7154 
7155     // Schedule a timer that tries to read
7156 
7157     connect(&helper.m_dlTimer, SIGNAL(timeout()), &helper, SLOT(onReadAndReschedule()));
7158     helper.m_dlTimer.setSingleShot(true);
7159     helper.m_dlTimer.start(0);
7160 
7161     QTestEventLoop::instance().enterLoop(30);
7162     QVERIFY(!QTestEventLoop::instance().timeout());
7163     QVERIFY(helper.m_reply->isFinished());
7164     QCOMPARE(helper.m_reply->error(), QNetworkReply::NoError);
7165 }
7166 
7167 void tst_QNetworkReply::httpWithNoCredentialUsage()
7168 {
7169     QNetworkAccessManager manager;
7170 
7171     QSignalSpy authSpy(&manager, SIGNAL(authenticationRequired(QNetworkReply*,QAuthenticator*)));
7172     QSignalSpy finishedSpy(&manager, SIGNAL(finished(QNetworkReply*)));
7173 
7174     // Get with credentials, to preload authentication cache
7175     {
7176         QNetworkRequest request(QUrl("http://httptest:httptest@" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi"));
7177         QNetworkReplyPtr reply(manager.get(request));
7178         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7179         // credentials in URL, so don't expect authentication signal
7180         QCOMPARE(authSpy.count(), 0);
7181         QCOMPARE(finishedSpy.count(), 1);
7182         finishedSpy.clear();
7183     }
7184 
7185     // Get with cached credentials (normal usage)
7186     {
7187         QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi"));
7188         QNetworkReplyPtr reply(manager.get(request));
7189         QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7190         // credentials in cache, so don't expect authentication signal
7191         QCOMPARE(authSpy.count(), 0);
7192         QCOMPARE(finishedSpy.count(), 1);
7193         finishedSpy.clear();
7194     }
7195 
7196     // Do not use cached credentials (webkit cross origin usage)
7197     {
7198         QNetworkRequest request(QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/protected/cgi-bin/md5sum.cgi"));
7199         request.setAttribute(QNetworkRequest::AuthenticationReuseAttribute, QNetworkRequest::Manual);
7200         QNetworkReplyPtr reply(manager.get(request));
7201 
7202         QSignalSpy errorSpy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
7203 
7204         connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()), Qt::QueuedConnection);
7205         QTestEventLoop::instance().enterLoop(10);
7206         QVERIFY(!QTestEventLoop::instance().timeout());
7207 
7208         // We check if authenticationRequired was emitted, however we do not anything in it so it should be 401
7209         QCOMPARE(authSpy.count(), 1);
7210         QCOMPARE(finishedSpy.count(), 1);
7211         QCOMPARE(errorSpy.count(), 1);
7212 
7213         QCOMPARE(reply->error(), QNetworkReply::AuthenticationRequiredError);
7214     }
7215 }
7216 
7217 void tst_QNetworkReply::qtbug15311doubleContentLength()
7218 {
7219     QByteArray response("HTTP/1.0 200 OK\r\nContent-Length: 3\r\nServer: bogus\r\nContent-Length: 3\r\n\r\nABC");
7220     MiniHttpServer server(response);
7221     server.doClose = true;
7222 
7223     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
7224     QNetworkReplyPtr reply(manager.get(request));
7225 
7226     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7227 
7228     QVERIFY(reply->isFinished());
7229     QCOMPARE(reply->error(), QNetworkReply::NoError);
7230     QCOMPARE(reply->size(), qint64(3));
7231     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), qint64(3));
7232     QCOMPARE(reply->rawHeader("Content-length"), QByteArray("3, 3"));
7233     QCOMPARE(reply->readAll(), QByteArray("ABC"));
7234 }
7235 
7236 void tst_QNetworkReply::qtbug18232gzipContentLengthZero()
7237 {
7238     QByteArray response("HTTP/1.0 200 OK\r\nContent-Encoding: gzip\r\nContent-Length: 0\r\n\r\n");
7239     MiniHttpServer server(response);
7240     server.doClose = true;
7241 
7242     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
7243     QNetworkReplyPtr reply(manager.get(request));
7244 
7245     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7246 
7247     QVERIFY(reply->isFinished());
7248     QCOMPARE(reply->error(), QNetworkReply::NoError);
7249     QCOMPARE(reply->size(), qint64(0));
7250     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), qint64(0));
7251     QCOMPARE(reply->readAll(), QByteArray());
7252 }
7253 
7254 // Reproduced a crash in QHttpNetworkReplyPrivate::gunzipBodyPartiallyEnd
7255 // where zlib inflateEnd was called for uninitialized zlib stream
7256 void tst_QNetworkReply::qtbug22660gzipNoContentLengthEmptyContent()
7257 {
7258     // Response with no Content-Length in header and empty content
7259     QByteArray response("HTTP/1.0 200 OK\r\nContent-Encoding: gzip\r\n\r\n");
7260     MiniHttpServer server(response);
7261     server.doClose = true;
7262 
7263     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
7264     QNetworkReplyPtr reply(manager.get(request));
7265 
7266     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7267 
7268     QVERIFY(reply->isFinished());
7269     QCOMPARE(reply->error(), QNetworkReply::NoError);
7270     QCOMPARE(reply->size(), qint64(0));
7271     QVERIFY(!reply->header(QNetworkRequest::ContentLengthHeader).isValid());
7272     QCOMPARE(reply->readAll(), QByteArray());
7273 }
7274 
7275 class QtBug27161Helper : public QObject
7276 {
7277     Q_OBJECT
7278 public:
7279     QtBug27161Helper(MiniHttpServer & server, const QByteArray & data):
7280         m_server(server),
7281         m_data(data)
7282     {
7283         connect(&m_server, SIGNAL(newConnection()), this, SLOT(newConnectionSlot()));
7284     }
7285 public slots:
7286     void newConnectionSlot()
7287     {
7288         connect(m_server.client, SIGNAL(bytesWritten(qint64)), this, SLOT(bytesWrittenSlot()));
7289     }
7290 
7291     void bytesWrittenSlot()
7292     {
7293         disconnect(m_server.client, SIGNAL(bytesWritten(qint64)), this, SLOT(bytesWrittenSlot()));
7294         m_Timer.singleShot(100, this, SLOT(timeoutSlot()));
7295     }
7296 
7297     void timeoutSlot()
7298     {
7299         m_server.doClose = true;
7300         // we need to emulate the bytesWrittenSlot call if the data is empty.
7301         if (m_data.size() == 0)
7302             QMetaObject::invokeMethod(&m_server, "bytesWrittenSlot", Qt::QueuedConnection);
7303         else
7304             m_server.client->write(m_data);
7305     }
7306 
7307 private:
7308     MiniHttpServer & m_server;
7309     QByteArray m_data;
7310     QTimer m_Timer;
7311 };
7312 
7313 void tst_QNetworkReply::qtbug27161httpHeaderMayBeDamaged_data(){
7314     QByteArray response("HTTP/1.0 200 OK\r\nServer: bogus\r\nContent-Length: 3\r\n\r\nABC");
7315     QTest::addColumn<QByteArray>("firstPacket");
7316     QTest::addColumn<QByteArray>("secondPacket");
7317 
7318     for (int i = 1; i < response.size(); i++){
7319         QByteArray dataTag("Iteration: ");
7320         dataTag.append(QByteArray::number(i - 1));
7321         QTest::newRow(dataTag.constData()) << response.left(i) << response.mid(i);
7322     }
7323 }
7324 
7325 /*
7326  * Purpose of this test is to check whether a content from server is parsed correctly
7327  * if it is split into two parts.
7328  */
7329 void tst_QNetworkReply::qtbug27161httpHeaderMayBeDamaged(){
7330     QFETCH(QByteArray, firstPacket);
7331     QFETCH(QByteArray, secondPacket);
7332     MiniHttpServer server(firstPacket);
7333     server.doClose = false;
7334     QtBug27161Helper helper(server, secondPacket);
7335 
7336     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
7337     QNetworkReplyPtr reply(manager.get(request));
7338 
7339     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7340 
7341     QVERIFY(reply->isFinished());
7342     QCOMPARE(reply->error(), QNetworkReply::NoError);
7343     QCOMPARE(reply->size(), qint64(3));
7344     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), qint64(3));
7345     QCOMPARE(reply->rawHeader("Content-length"), QByteArray("3"));
7346     QCOMPARE(reply->rawHeader("Server"), QByteArray("bogus"));
7347     QCOMPARE(reply->readAll(), QByteArray("ABC"));
7348 }
7349 
7350 void tst_QNetworkReply::qtbug28035browserDoesNotLoadQtProjectOrgCorrectly() {
7351     QByteArray getReply =
7352             "HTTP/1.1 200\r\n"
7353             "Connection: keep-alive\r\n"
7354             "Content-Type: text/plain\r\n"
7355             "Cache-control: max-age = 6000\r\n"
7356             "\r\n"
7357             "GET";
7358 
7359     QByteArray postReply =
7360             "HTTP/1.1 200\r\n"
7361             "Connection: keep-alive\r\n"
7362             "Content-Type: text/plain\r\n"
7363             "Cache-control: max-age = 6000\r\n"
7364             "Content-length: 4\r\n"
7365             "\r\n"
7366             "POST";
7367 
7368     QByteArray putReply =
7369             "HTTP/1.1 201\r\n"
7370             "Connection: keep-alive\r\n"
7371             "Content-Type: text/plain\r\n"
7372             "Cache-control: max-age = 6000\r\n"
7373             "\r\n";
7374 
7375     QByteArray postData = "ACT=100";
7376 
7377     QTemporaryDir tempDir(QDir::tempPath() + "/tmp_cache_28035");
7378     QVERIFY2(tempDir.isValid(), qPrintable(tempDir.errorString()));
7379     tempDir.setAutoRemove(true);
7380 
7381     QNetworkDiskCache *diskCache = new QNetworkDiskCache();
7382     diskCache->setCacheDirectory(tempDir.path());
7383     manager.setCache(diskCache);
7384 
7385     MiniHttpServer server(getReply);
7386 
7387     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
7388     QNetworkReplyPtr reply(manager.get(request));
7389 
7390     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7391 
7392     QVERIFY(reply->isFinished());
7393     QCOMPARE(reply->error(), QNetworkReply::NoError);
7394     QCOMPARE(reply->readAll(), QByteArray("GET"));
7395     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), false);
7396 
7397     server.clearHeaderParserState();
7398     server.setDataToTransmit(getReply);
7399     reply.reset(manager.get(request));
7400     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7401 
7402     QVERIFY(reply->isFinished());
7403     QCOMPARE(reply->error(), QNetworkReply::NoError);
7404     QCOMPARE(reply->readAll(), QByteArray("GET"));
7405     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), true);
7406 
7407     server.clearHeaderParserState();
7408     server.setDataToTransmit(postReply);
7409     request.setRawHeader("Content-Type", "text/plain");
7410     reply.reset(manager.post(request, postData));
7411 
7412     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7413 
7414     QVERIFY(reply->isFinished());
7415     QCOMPARE(reply->error(), QNetworkReply::NoError);
7416     QCOMPARE(reply->rawHeader("Content-length"), QByteArray("4"));
7417     QCOMPARE(reply->readAll(), QByteArray("POST"));
7418     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), false);
7419 
7420     server.clearHeaderParserState();
7421     server.setDataToTransmit(getReply);
7422     reply.reset(manager.get(request));
7423 
7424     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7425 
7426     QVERIFY(reply->isFinished());
7427     QCOMPARE(reply->error(), QNetworkReply::NoError);
7428     QCOMPARE(reply->readAll(), QByteArray("GET"));
7429     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), false);
7430 
7431     server.clearHeaderParserState();
7432     server.setDataToTransmit(getReply);
7433     reply.reset(manager.get(request));
7434 
7435     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7436 
7437     QVERIFY(reply->isFinished());
7438     QCOMPARE(reply->error(), QNetworkReply::NoError);
7439     QCOMPARE(reply->readAll(), QByteArray("GET"));
7440     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), true);
7441 
7442     server.clearHeaderParserState();
7443     server.setDataToTransmit(putReply);
7444     reply.reset(manager.put(request, postData));
7445 
7446     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7447 
7448     QVERIFY(reply->isFinished());
7449     QCOMPARE(reply->error(), QNetworkReply::NoError);
7450     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), false);
7451 
7452     server.clearHeaderParserState();
7453     server.setDataToTransmit(getReply);
7454     reply.reset(manager.get(request));
7455 
7456     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7457 
7458     QVERIFY(reply->isFinished());
7459     QCOMPARE(reply->error(), QNetworkReply::NoError);
7460     QCOMPARE(reply->readAll(), QByteArray("GET"));
7461     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), false);
7462 
7463     server.clearHeaderParserState();
7464     server.setDataToTransmit(getReply);
7465     reply.reset(manager.get(request));
7466 
7467     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7468 
7469     QVERIFY(reply->isFinished());
7470     QCOMPARE(reply->error(), QNetworkReply::NoError);
7471     QCOMPARE(reply->readAll(), QByteArray("GET"));
7472     QCOMPARE(reply->attribute(QNetworkRequest::SourceIsFromCacheAttribute).toBool(), true);
7473 }
7474 
7475 void tst_QNetworkReply::qtbug45581WrongReplyStatusCode()
7476 {
7477     const QUrl url("file:" + testDataDir + "/element.xml");
7478     QNetworkRequest request(url);
7479 
7480     QNetworkReplyPtr reply;
7481     QSignalSpy finishedSpy(&manager, SIGNAL(finished(QNetworkReply*)));
7482     QSignalSpy sslErrorsSpy(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)));
7483     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply, 0));
7484     QVERIFY(reply->isFinished());
7485 
7486     const QByteArray expectedContent =
7487             "<root attr=\"value\" attr2=\"value2\">"
7488             "<person /><fruit /></root>"
7489 #ifdef Q_OS_WIN
7490             "\r"
7491 #endif
7492             "\n";
7493 
7494     QCOMPARE(reply->readAll(), expectedContent);
7495 
7496     QCOMPARE(finishedSpy.count(), 0);
7497     QCOMPARE(sslErrorsSpy.count(), 0);
7498 
7499     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), expectedContent.size());
7500 
7501     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
7502     QCOMPARE(reply->attribute(QNetworkRequest::HttpReasonPhraseAttribute).toString(), QLatin1String("OK"));
7503 
7504     reply->deleteLater();
7505 }
7506 
7507 void tst_QNetworkReply::synchronousRequest_data()
7508 {
7509     QTest::addColumn<QUrl>("url");
7510     QTest::addColumn<QString>("expected");
7511     QTest::addColumn<bool>("checkContentLength");
7512     QTest::addColumn<QString>("mimeType");
7513 
7514     // ### cache, auth, proxies
7515 
7516     QTest::newRow("http")
7517         << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt")
7518         << QString("file:" + testDataDir + "/rfc3252.txt")
7519         << true
7520         << QString("text/plain");
7521 
7522     QTest::newRow("http-gzip")
7523         << QUrl("http://" + QtNetworkSettings::serverName() + "/qtest/deflate/rfc3252.txt")
7524         << QString("file:" + testDataDir + "/rfc3252.txt")
7525         << false // don't check content length, because it's gzip encoded
7526         //  ### we would need to enflate (un-deflate) the file content and compare the sizes
7527         << QString("text/plain");
7528 
7529 #ifndef QT_NO_SSL
7530     QTest::newRow("https")
7531         << QUrl("https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt")
7532         << QString("file:" + testDataDir + "/rfc3252.txt")
7533         << true
7534         << QString("text/plain");
7535 #endif
7536 
7537     QTest::newRow("data")
7538         << QUrl(QString::fromLatin1("data:text/plain,hello world"))
7539         << QString("data:hello world")
7540         << true // check content length
7541         << QString("text/plain");
7542 
7543     QTest::newRow("simple-file")
7544         << QUrl::fromLocalFile(testDataDir + "/rfc3252.txt")
7545         << QString("file:" + testDataDir + "/rfc3252.txt")
7546         << true
7547         << QString();
7548 }
7549 
7550 // FIXME add testcase for failing network etc
7551 void tst_QNetworkReply::synchronousRequest()
7552 {
7553     QFETCH(QUrl, url);
7554     QFETCH(QString, expected);
7555     QFETCH(bool, checkContentLength);
7556     QFETCH(QString, mimeType);
7557 
7558     QNetworkRequest request(url);
7559 
7560 #ifndef QT_NO_SSL
7561     // workaround for HTTPS requests: add self-signed server cert to list of CA certs,
7562     // since we cannot react to the sslErrors() signal
7563     // to fix this properly we would need to have an ignoreSslErrors() method in the
7564     // QNetworkRequest, see QTBUG-14774
7565     if (url.scheme() == "https") {
7566         QSslConfiguration sslConf;
7567         QList<QSslCertificate> certs = QSslCertificate::fromPath(testDataDir + certsFilePath);
7568         sslConf.setCaCertificates(certs);
7569         request.setSslConfiguration(sslConf);
7570     }
7571 #endif
7572 
7573     request.setAttribute(
7574             QNetworkRequest::SynchronousRequestAttribute,
7575             true);
7576 
7577     QNetworkReplyPtr reply;
7578     QSignalSpy finishedSpy(&manager, SIGNAL(finished(QNetworkReply*)));
7579     QSignalSpy sslErrorsSpy(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)));
7580     RUN_REQUEST(runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply, 0));
7581     QVERIFY(reply->isFinished());
7582     QCOMPARE(finishedSpy.count(), 0);
7583     QCOMPARE(sslErrorsSpy.count(), 0);
7584 
7585     QCOMPARE(reply->header(QNetworkRequest::ContentTypeHeader).toString(), mimeType);
7586 
7587     QByteArray expectedContent;
7588 
7589     if (expected.startsWith("file:")) {
7590         QString path = expected.mid(5);
7591         QFile file(path);
7592         file.open(QIODevice::ReadOnly);
7593         expectedContent = file.readAll();
7594     } else if (expected.startsWith("data:")) {
7595         expectedContent = expected.mid(5).toUtf8();
7596     }
7597 
7598     if (checkContentLength)
7599         QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), qint64(expectedContent.size()));
7600     QCOMPARE(reply->readAll(), expectedContent);
7601 
7602     reply->deleteLater();
7603 }
7604 
7605 #ifndef QT_NO_SSL
7606 void tst_QNetworkReply::synchronousRequestSslFailure()
7607 {
7608     // test that SSL won't be accepted with self-signed certificate,
7609     // and that we do not emit the sslError signal (in the manager that is,
7610     // in the reply we don't care)
7611 
7612     QUrl url("https://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt");
7613     QNetworkRequest request(url);
7614     request.setAttribute(
7615             QNetworkRequest::SynchronousRequestAttribute,
7616             true);
7617     QNetworkReplyPtr reply;
7618     QSignalSpy sslErrorsSpy(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)));
7619     runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply, 0);
7620     QVERIFY(reply->isFinished());
7621     QCOMPARE(reply->error(), QNetworkReply::SslHandshakeFailedError);
7622     QCOMPARE(sslErrorsSpy.count(), 0);
7623 }
7624 #endif
7625 
7626 class HttpAbortHelper : public QObject
7627 {
7628     Q_OBJECT
7629 public:
7630     HttpAbortHelper(QNetworkReply *parent)
7631     : QObject(parent)
7632     {
7633         mReply = parent;
7634         connect(parent, SIGNAL(readyRead()), this, SLOT(readyRead()));
7635     }
7636 
7637     ~HttpAbortHelper()
7638     {
7639     }
7640 
7641 public slots:
7642     void readyRead()
7643     {
7644         mReply->abort();
7645         QMetaObject::invokeMethod(&QTestEventLoop::instance(), "exitLoop", Qt::QueuedConnection);
7646     }
7647 
7648 private:
7649     QNetworkReply *mReply;
7650 };
7651 
7652 void tst_QNetworkReply::httpAbort()
7653 {
7654     // FIXME Also implement one where we do a big upload and then abort().
7655     // It must not crash either.
7656 
7657     // Abort after the first readyRead()
7658     QNetworkRequest request("http://" + QtNetworkSettings::serverName() + "/qtest/bigfile");
7659     QNetworkReplyPtr reply(manager.get(request));
7660     HttpAbortHelper replyHolder(reply.data());
7661     QTestEventLoop::instance().enterLoop(10);
7662     QVERIFY(!QTestEventLoop::instance().timeout());
7663     QCOMPARE(reply->error(), QNetworkReply::OperationCanceledError);
7664     QVERIFY(reply->isFinished());
7665 
7666     // Abort immediately after the get()
7667     QNetworkReplyPtr reply2(manager.get(request));
7668     connect(reply2, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
7669     reply2->abort();
7670     QCOMPARE(reply2->error(), QNetworkReply::OperationCanceledError);
7671     QVERIFY(reply2->isFinished());
7672 
7673     // Abort after the finished()
7674     QNetworkRequest request3("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt");
7675     QNetworkReplyPtr reply3(manager.get(request3));
7676 
7677     QCOMPARE(waitForFinish(reply3), int(Success));
7678 
7679     QVERIFY(reply3->isFinished());
7680     reply3->abort();
7681     QCOMPARE(reply3->error(), QNetworkReply::NoError);
7682 }
7683 
7684 void tst_QNetworkReply::dontInsertPartialContentIntoTheCache()
7685 {
7686     QByteArray reply206 =
7687             "HTTP/1.0 206\r\n"
7688             "Connection: keep-alive\r\n"
7689             "Content-Type: text/plain\r\n"
7690             "Cache-control: no-cache\r\n"
7691             "Content-Range: bytes 2-6/8\r\n"
7692             "Content-length: 4\r\n"
7693             "\r\n"
7694             "load";
7695 
7696     MiniHttpServer server(reply206);
7697     server.doClose = false;
7698 
7699     MySpyMemoryCache *memoryCache = new MySpyMemoryCache(&manager);
7700     manager.setCache(memoryCache);
7701 
7702     QUrl url = "http://localhost:" + QString::number(server.serverPort());
7703     QNetworkRequest request(url);
7704     request.setRawHeader("Range", "bytes=2-6");
7705 
7706     QNetworkReplyPtr reply(manager.get(request));
7707 
7708     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7709 
7710     QVERIFY(server.totalConnections > 0);
7711     QCOMPARE(reply->readAll().constData(), "load");
7712     QCOMPARE(memoryCache->m_insertedUrls.count(), 0);
7713 }
7714 
7715 void tst_QNetworkReply::httpUserAgent()
7716 {
7717     QByteArray response("HTTP/1.0 200 OK\r\n\r\n");
7718     MiniHttpServer server(response);
7719     server.doClose = true;
7720 
7721     QNetworkRequest request(QUrl("http://localhost:" + QString::number(server.serverPort())));
7722     request.setHeader(QNetworkRequest::UserAgentHeader, "abcDEFghi");
7723     QNetworkReplyPtr reply(manager.get(request));
7724 
7725     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
7726 
7727     QVERIFY(reply->isFinished());
7728     QCOMPARE(reply->error(), QNetworkReply::NoError);
7729     QVERIFY(server.receivedData.contains("\r\nUser-Agent: abcDEFghi\r\n"));
7730 }
7731 
7732 void tst_QNetworkReply::synchronousAuthenticationCache()
7733 {
7734     class MiniAuthServer : public MiniHttpServer
7735     {
7736     public:
7737         MiniAuthServer(QThread *thread) : MiniHttpServer(QByteArray(), false, thread) {}
7738         virtual void reply()
7739         {
7740 
7741             dataToTransmit =
7742                 "HTTP/1.0 401 Unauthorized\r\n"
7743                 "WWW-Authenticate: Basic realm=\"QNetworkAccessManager Test Realm\"\r\n"
7744                 "Content-Length: 4\r\n"
7745                 "Connection: close\r\n"
7746                 "Content-Type: text/plain\r\n"
7747                 "\r\n"
7748                 "auth";
7749             QRegExp rx("Authorization: Basic ([^\r\n]*)\r\n");
7750             if (rx.indexIn(receivedData) > 0) {
7751                 if (QByteArray::fromBase64(rx.cap(1).toLatin1()) == "login:password") {
7752                     dataToTransmit =
7753                           "HTTP/1.0 200 OK\r\n"
7754                           "Content-Type: text/plain\r\n"
7755                           "Content-Length: 2\r\n"
7756                           "\r\n"
7757                           "OK";
7758                 }
7759             }
7760             receivedData.clear();
7761             MiniHttpServer::reply();
7762         }
7763     };
7764 
7765     // when using synchronous commands, we need a different event loop for
7766     // the server thread, because the client is never returning to the
7767     // event loop
7768     QScopedPointer<QThread, QThreadCleanup> serverThread(new QThread);
7769     QScopedPointer<MiniHttpServer, QDeleteLaterCleanup> server(new MiniAuthServer(serverThread.data()));
7770     server->doClose = true;
7771 
7772     //1)  URL without credentials, we are not authenticated
7773     {
7774         QUrl url = "http://localhost:" + QString::number(server->serverPort()) + "/path";
7775         QNetworkRequest request(url);
7776         request.setAttribute(QNetworkRequest::SynchronousRequestAttribute, true);
7777 
7778         QNetworkReplyPtr reply(manager.get(request));
7779         QVERIFY(reply->isFinished());
7780         QCOMPARE(reply->error(), QNetworkReply::AuthenticationRequiredError);
7781     }
7782 
7783     //2)  URL with credentials, we are authenticated
7784     {
7785         QUrl url = "http://login:password@localhost:" + QString::number(server->serverPort()) + "/path2";
7786         QNetworkRequest request(url);
7787         request.setAttribute(QNetworkRequest::SynchronousRequestAttribute, true);
7788 
7789         QNetworkReplyPtr reply(manager.get(request));
7790         QVERIFY(reply->isFinished());
7791         QCOMPARE(reply->error(), QNetworkReply::NoError);
7792         QCOMPARE(reply->readAll().constData(), "OK");
7793     }
7794 
7795     //3)  URL without credentials, we are authenticated because they are cached
7796     {
7797         QUrl url = "http://localhost:" + QString::number(server->serverPort()) + "/path3";
7798         QNetworkRequest request(url);
7799         request.setAttribute(QNetworkRequest::SynchronousRequestAttribute, true);
7800 
7801         QNetworkReplyPtr reply(manager.get(request));
7802         QVERIFY(reply->isFinished());
7803         QCOMPARE(reply->error(), QNetworkReply::NoError);
7804         QCOMPARE(reply->readAll().constData(), "OK");
7805     }
7806 }
7807 
7808 void tst_QNetworkReply::pipelining()
7809 {
7810     QString urlString("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/echo.cgi?");
7811     QList<QNetworkReplyPtr> replies;
7812     for (int a = 0; a < 20; a++) {
7813         QNetworkRequest request(urlString + QString::number(a));
7814         request.setAttribute(QNetworkRequest::HttpPipeliningAllowedAttribute, QVariant(true));
7815         replies.append(QNetworkReplyPtr(manager.get(request)));
7816         connect(replies.at(a), SIGNAL(finished()), this, SLOT(pipeliningHelperSlot()));
7817     }
7818     QTestEventLoop::instance().enterLoop(20);
7819     QVERIFY(!QTestEventLoop::instance().timeout());
7820 }
7821 
7822 void tst_QNetworkReply::pipeliningHelperSlot() {
7823     static int a = 0;
7824 
7825     // check that pipelining was used in at least one of the replies
7826     static bool pipeliningWasUsed = false;
7827     QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
7828     bool pipeliningWasUsedInReply = reply->attribute(QNetworkRequest::HttpPipeliningWasUsedAttribute).toBool();
7829     if (pipeliningWasUsedInReply)
7830         pipeliningWasUsed = true;
7831 
7832     // check that the contents match (the response to echo.cgi?3 should return 3 etc.)
7833     QString urlQueryString = reply->url().query();
7834     QString content = reply->readAll();
7835     QVERIFY2(urlQueryString == content, "data corruption with pipelining detected");
7836 
7837     a++;
7838 
7839     if (a == 20) { // all replies have finished
7840         QTestEventLoop::instance().exitLoop();
7841         QVERIFY2(pipeliningWasUsed, "pipelining was not used in any of the replies when trying to test pipelining");
7842     }
7843 }
7844 
7845 void tst_QNetworkReply::emitErrorForAllRepliesSlot() {
7846     static int a = 0;
7847     if (++a == 3)
7848         QTestEventLoop::instance().exitLoop();
7849 }
7850 
7851 void tst_QNetworkReply::closeDuringDownload_data()
7852 {
7853     QTest::addColumn<QUrl>("url");
7854     QTest::newRow("http") << QUrl("http://" + QtNetworkSettings::serverName() + "/bigfile");
7855     QTest::newRow("ftp") << QUrl("ftp://" + QtNetworkSettings::serverName() + "/qtest/bigfile");
7856 }
7857 
7858 void tst_QNetworkReply::closeDuringDownload()
7859 {
7860     QFETCH(QUrl, url);
7861     QNetworkRequest request(url);
7862     QNetworkReply* reply = manager.get(request);
7863     connect(reply, SIGNAL(readyRead()), &QTestEventLoop::instance(), SLOT(exitLoop()));
7864     QTestEventLoop::instance().enterLoop(10);
7865     QVERIFY(!QTestEventLoop::instance().timeout());
7866     connect(reply, SIGNAL(finished()), &QTestEventLoop::instance(), SLOT(exitLoop()));
7867     reply->close();
7868     reply->deleteLater();
7869     QTest::qWait(1000); //cancelling ftp takes some time, this avoids a warning caused by test's cleanup() destroying the connection cache before the abort is finished
7870 }
7871 
7872 void tst_QNetworkReply::ftpAuthentication_data()
7873 {
7874     QTest::addColumn<QString>("referenceName");
7875     QTest::addColumn<QString>("url");
7876     QTest::addColumn<int>("error");
7877 
7878     QTest::newRow("invalidPassword") << (testDataDir + "/rfc3252.txt") << "ftp://ftptest:invalid@" + QtNetworkSettings::serverName() + "/home/qt-test-server/ftp/qtest/rfc3252.txt" << int(QNetworkReply::AuthenticationRequiredError);
7879     QTest::newRow("validPassword") << (testDataDir + "/rfc3252.txt") << "ftp://ftptest:password@" + QtNetworkSettings::serverName() + "/home/qt-test-server/ftp/qtest/rfc3252.txt" << int(QNetworkReply::NoError);
7880 }
7881 
7882 void tst_QNetworkReply::ftpAuthentication()
7883 {
7884     QFETCH(QString, referenceName);
7885     QFETCH(QString, url);
7886     QFETCH(int, error);
7887 
7888     QFile reference(referenceName);
7889     QVERIFY(reference.open(QIODevice::ReadOnly));
7890 
7891     QNetworkRequest request(url);
7892     QNetworkReplyPtr reply;
7893     runSimpleRequest(QNetworkAccessManager::GetOperation, request, reply);
7894 
7895     QCOMPARE(reply->url(), request.url());
7896     QCOMPARE(reply->error(), QNetworkReply::NetworkError(error));
7897 }
7898 
7899 void tst_QNetworkReply::emitErrorForAllReplies() // QTBUG-36890
7900 {
7901     // port 100 is not well-known and should be closed
7902     QList<QUrl> urls = QList<QUrl>() << QUrl("http://localhost:100/request1")
7903                                      << QUrl("http://localhost:100/request2")
7904                                      << QUrl("http://localhost:100/request3");
7905     QList<QNetworkReply *> replies;
7906     QList<QSignalSpy *> errorSpies;
7907     QList<QSignalSpy *> finishedSpies;
7908     for (int a = 0; a < urls.count(); ++a) {
7909         QNetworkRequest request(urls.at(a));
7910         QNetworkReply *reply = manager.get(request);
7911         replies.append(reply);
7912         QSignalSpy *errorSpy = new QSignalSpy(reply, SIGNAL(error(QNetworkReply::NetworkError)));
7913         errorSpies.append(errorSpy);
7914         QSignalSpy *finishedSpy = new QSignalSpy(reply, SIGNAL(finished()));
7915         finishedSpies.append(finishedSpy);
7916         QObject::connect(reply, SIGNAL(finished()), SLOT(emitErrorForAllRepliesSlot()));
7917     }
7918     QTestEventLoop::instance().enterLoop(10);
7919     QVERIFY(!QTestEventLoop::instance().timeout());
7920     for (int a = 0; a < urls.count(); ++a) {
7921         QVERIFY(replies.at(a)->isFinished());
7922         QCOMPARE(errorSpies.at(a)->count(), 1);
7923         errorSpies.at(a)->deleteLater();
7924         QCOMPARE(finishedSpies.at(a)->count(), 1);
7925         finishedSpies.at(a)->deleteLater();
7926         replies.at(a)->deleteLater();
7927     }
7928 }
7929 
7930 #ifdef QT_BUILD_INTERNAL
7931 void tst_QNetworkReply::backgroundRequest_data()
7932 {
7933 #ifndef QT_NO_BEARERMANAGEMENT
7934     QTest::addColumn<QUrl>("url");
7935     QTest::addColumn<bool>("background");
7936     QTest::addColumn<int>("policy");
7937     QTest::addColumn<QNetworkReply::NetworkError>("error");
7938 
7939     QUrl httpurl("http://" + QtNetworkSettings::serverName());
7940     QUrl httpsurl("https://" + QtNetworkSettings::serverName());
7941     QUrl ftpurl("ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt");
7942 
7943     QTest::newRow("http, fg, normal") << httpurl << false << (int)QNetworkSession::NoPolicy << QNetworkReply::NoError;
7944     QTest::newRow("http, bg, normal") << httpurl << true << (int)QNetworkSession::NoPolicy << QNetworkReply::NoError;
7945     QTest::newRow("http, fg, nobg") << httpurl << false << (int)QNetworkSession::NoBackgroundTrafficPolicy << QNetworkReply::NoError;
7946     QTest::newRow("http, bg, nobg") << httpurl << true << (int)QNetworkSession::NoBackgroundTrafficPolicy << QNetworkReply::BackgroundRequestNotAllowedError;
7947 
7948 #ifndef QT_NO_SSL
7949     QTest::newRow("https, fg, normal") << httpsurl << false << (int)QNetworkSession::NoPolicy << QNetworkReply::NoError;
7950     QTest::newRow("https, bg, normal") << httpsurl << true << (int)QNetworkSession::NoPolicy << QNetworkReply::NoError;
7951     QTest::newRow("https, fg, nobg") << httpsurl << false << (int)QNetworkSession::NoBackgroundTrafficPolicy << QNetworkReply::NoError;
7952     QTest::newRow("https, bg, nobg") << httpsurl << true << (int)QNetworkSession::NoBackgroundTrafficPolicy << QNetworkReply::BackgroundRequestNotAllowedError;
7953 #endif
7954 
7955     QTest::newRow("ftp, fg, normal") << ftpurl << false << (int)QNetworkSession::NoPolicy << QNetworkReply::NoError;
7956     QTest::newRow("ftp, bg, normal") << ftpurl << true << (int)QNetworkSession::NoPolicy << QNetworkReply::NoError;
7957     QTest::newRow("ftp, fg, nobg") << ftpurl << false << (int)QNetworkSession::NoBackgroundTrafficPolicy << QNetworkReply::NoError;
7958     QTest::newRow("ftp, bg, nobg") << ftpurl << true << (int)QNetworkSession::NoBackgroundTrafficPolicy << QNetworkReply::BackgroundRequestNotAllowedError;
7959 #endif // !QT_NO_BEARERMANAGEMENT
7960 }
7961 #endif
7962 
7963 //test purpose: background requests can't be started when not allowed
7964 #ifdef QT_BUILD_INTERNAL
7965 void tst_QNetworkReply::backgroundRequest()
7966 {
7967 #ifndef QT_NO_BEARERMANAGEMENT
7968     QFETCH(QUrl, url);
7969     QFETCH(bool, background);
7970     QFETCH(int, policy);
7971     QFETCH(QNetworkReply::NetworkError, error);
7972 
7973     QNetworkRequest request(url);
7974 
7975     if (background)
7976         request.setAttribute(QNetworkRequest::BackgroundRequestAttribute, QVariant::fromValue(true));
7977 
7978     //this preconstructs the session so we can change policies in advance
7979     manager.setConfiguration(networkConfiguration);
7980 
7981 #ifndef QT_NO_SSL
7982     connect(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
7983         SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
7984 #endif
7985 
7986     const QWeakPointer<const QNetworkSession> session = QNetworkAccessManagerPrivate::getNetworkSession(&manager);
7987     QVERIFY(session);
7988     QNetworkSession::UsagePolicies original = session.data()->usagePolicies();
7989     QNetworkSessionPrivate::setUsagePolicies(*const_cast<QNetworkSession *>(session.data()), QNetworkSession::UsagePolicies(policy));
7990 
7991     QNetworkReplyPtr reply(manager.get(request));
7992 
7993     QVERIFY(waitForFinish(reply) != Timeout);
7994     if (session)
7995         QNetworkSessionPrivate::setUsagePolicies(*const_cast<QNetworkSession *>(session.data()), original);
7996 
7997     QVERIFY(reply->isFinished());
7998     QCOMPARE(reply->error(), error);
7999 #endif
8000 }
8001 #endif
8002 
8003 #ifdef QT_BUILD_INTERNAL
8004 void tst_QNetworkReply::backgroundRequestInterruption_data()
8005 {
8006     QTest::addColumn<QUrl>("url");
8007     QTest::addColumn<bool>("background");
8008     QTest::addColumn<QNetworkReply::NetworkError>("error");
8009 
8010     QUrl httpurl("http://" + QtNetworkSettings::serverName() + "/qtest/mediumfile");
8011     QUrl httpsurl("https://" + QtNetworkSettings::serverName() + "/qtest/mediumfile");
8012     QUrl ftpurl("ftp://" + QtNetworkSettings::serverName() + "/qtest/bigfile");
8013 
8014     QTest::newRow("http, fg, nobg") << httpurl << false << QNetworkReply::NoError;
8015     QTest::newRow("http, bg, nobg") << httpurl << true << QNetworkReply::BackgroundRequestNotAllowedError;
8016 
8017 #ifndef QT_NO_SSL
8018     QTest::newRow("https, fg, nobg") << httpsurl << false << QNetworkReply::NoError;
8019     QTest::newRow("https, bg, nobg") << httpsurl << true  << QNetworkReply::BackgroundRequestNotAllowedError;
8020 #endif
8021 
8022     QTest::newRow("ftp, fg, nobg") << ftpurl << false << QNetworkReply::NoError;
8023     QTest::newRow("ftp, bg, nobg") << ftpurl << true << QNetworkReply::BackgroundRequestNotAllowedError;
8024 
8025 }
8026 #endif
8027 
8028 //test purpose: background requests in progress are aborted when policy changes to disallow them
8029 #ifdef QT_BUILD_INTERNAL
8030 void tst_QNetworkReply::backgroundRequestInterruption()
8031 {
8032 #ifndef QT_NO_BEARERMANAGEMENT
8033     QFETCH(QUrl, url);
8034     QFETCH(bool, background);
8035     QFETCH(QNetworkReply::NetworkError, error);
8036 
8037     QNetworkRequest request(url);
8038 
8039     if (background)
8040         request.setAttribute(QNetworkRequest::BackgroundRequestAttribute, QVariant::fromValue(true));
8041 
8042     //this preconstructs the session so we can change policies in advance
8043     manager.setConfiguration(networkConfiguration);
8044 
8045 #ifndef QT_NO_SSL
8046     connect(&manager, SIGNAL(sslErrors(QNetworkReply*,QList<QSslError>)),
8047         SLOT(sslErrors(QNetworkReply*,QList<QSslError>)));
8048 #endif
8049 
8050     const QWeakPointer<const QNetworkSession> session = QNetworkAccessManagerPrivate::getNetworkSession(&manager);
8051     QVERIFY(session);
8052     QNetworkSession::UsagePolicies original = session.data()->usagePolicies();
8053     QNetworkSessionPrivate::setUsagePolicies(*const_cast<QNetworkSession *>(session.data()), QNetworkSession::NoPolicy);
8054 
8055     request.setAttribute(QNetworkRequest::MaximumDownloadBufferSizeAttribute, 8192);
8056     QNetworkReplyPtr reply(manager.get(request));
8057     reply->setReadBufferSize(1024);
8058 
8059     QSignalSpy spy(reply.data(), SIGNAL(readyRead()));
8060     QTRY_VERIFY(spy.count() > 0);
8061 
8062     QNetworkSessionPrivate::setUsagePolicies(*const_cast<QNetworkSession *>(session.data()), QNetworkSession::NoBackgroundTrafficPolicy);
8063 
8064     // After we have changed the policy we can download at full speed.
8065     reply->setReadBufferSize(0);
8066 
8067     QVERIFY(waitForFinish(reply) != Timeout);
8068     if (session)
8069         QNetworkSessionPrivate::setUsagePolicies(*const_cast<QNetworkSession *>(session.data()), original);
8070 
8071     QVERIFY(reply->isFinished());
8072     QCOMPARE(reply->error(), error);
8073 #endif
8074 }
8075 #endif
8076 
8077 #ifdef QT_BUILD_INTERNAL
8078 void tst_QNetworkReply::backgroundRequestConnectInBackground_data()
8079 {
8080     QTest::addColumn<QUrl>("url");
8081     QTest::addColumn<bool>("background");
8082 
8083     QUrl httpurl("http://" + QtNetworkSettings::serverName());
8084     QUrl ftpurl("ftp://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt");
8085 
8086     QTest::newRow("http, fg") << httpurl << false;
8087     QTest::newRow("http, bg") << httpurl << true;
8088 
8089     QTest::newRow("ftp, fg") << ftpurl << false;
8090     QTest::newRow("ftp, bg") << ftpurl << true;
8091 }
8092 #endif
8093 
8094 //test purpose: check that backgroundness is propagated to the network session
8095 #ifdef QT_BUILD_INTERNAL
8096 void tst_QNetworkReply::backgroundRequestConnectInBackground()
8097 {
8098 #ifndef QT_NO_BEARERMANAGEMENT
8099     QFETCH(QUrl, url);
8100     QFETCH(bool, background);
8101 
8102     QNetworkRequest request(url);
8103 
8104     if (background)
8105         request.setAttribute(QNetworkRequest::BackgroundRequestAttribute, QVariant::fromValue(true));
8106 
8107     QWeakPointer<const QNetworkSession> session = QNetworkAccessManagerPrivate::getNetworkSession(&manager);
8108     //force QNAM to reopen the session.
8109     if (session && session.data()->isOpen()) {
8110         const_cast<QNetworkSession *>(session.data())->close();
8111         QCoreApplication::processEvents(); //let signals propagate inside QNAM
8112     }
8113 
8114     //this preconstructs the session so we can change policies in advance
8115     manager.setConfiguration(networkConfiguration);
8116 
8117     session = QNetworkAccessManagerPrivate::getNetworkSession(&manager);
8118     QVERIFY(session);
8119     QNetworkSession::UsagePolicies original = session.data()->usagePolicies();
8120     QNetworkSessionPrivate::setUsagePolicies(*const_cast<QNetworkSession *>(session.data()), QNetworkSession::NoPolicy);
8121 
8122     QNetworkReplyPtr reply(manager.get(request));
8123 
8124     QVERIFY(waitForFinish(reply) != Timeout);
8125     session = QNetworkAccessManagerPrivate::getNetworkSession(&manager);
8126     if (session) {
8127         QVariant cib = session.data()->sessionProperty(QStringLiteral("ConnectInBackground"));
8128         if (!cib.isValid())
8129             QSKIP("inconclusive - ConnectInBackground session property not supported by the bearer plugin");
8130         QCOMPARE(cib.toBool(), background);
8131         QNetworkSessionPrivate::setUsagePolicies(*const_cast<QNetworkSession *>(session.data()), original);
8132     } else {
8133         QSKIP("inconclusive - network session has been destroyed");
8134     }
8135 
8136     QVERIFY(reply->isFinished());
8137 #endif
8138 }
8139 #endif
8140 
8141 class RateLimitedUploadDevice : public QIODevice
8142 {
8143     Q_OBJECT
8144 public:
8145     QByteArray data;
8146     QBuffer buffer;
8147     qint64 read;
8148     qint64 bandwidthQuota;
8149     QTimer timer;
8150 
8151     RateLimitedUploadDevice(QByteArray d) : QIODevice(),data(d),read(0),bandwidthQuota(0)
8152     {
8153         buffer.setData(data);
8154         buffer.open(QIODevice::ReadOnly);
8155         timer.setInterval(200);
8156         QObject::connect(&timer, SIGNAL(timeout()), this, SLOT(timeoutSlot()));
8157         timer.start();
8158     }
8159 
8160     virtual qint64 writeData(const char* , qint64 )
8161     {
8162         Q_ASSERT(false);
8163         return 0;
8164     }
8165 
8166     virtual qint64 readData(char* data, qint64 maxlen)
8167     {
8168         //qDebug() << Q_FUNC_INFO << maxlen << bandwidthQuota;
8169         maxlen = qMin(maxlen, buffer.bytesAvailable());
8170         maxlen = qMin(maxlen, bandwidthQuota);
8171         if (maxlen <= 0) {  // no quota or at end
8172             return 0;
8173         }
8174         bandwidthQuota -= maxlen; // reduce quota
8175 
8176         qint64 ret = buffer.read(data, maxlen);
8177         if (ret == -1) {
8178             return -1;
8179         }
8180         read += ret;
8181         //qDebug() << Q_FUNC_INFO << maxlen << bandwidthQuota << read << ret << buffer.bytesAvailable();
8182         return ret;
8183     }
8184     virtual bool atEnd() const { return buffer.atEnd(); }
8185     virtual qint64 size() const { return data.length(); }
8186     qint64 bytesAvailable() const
8187     {
8188         return buffer.bytesAvailable() + QIODevice::bytesAvailable();
8189     }
8190     virtual bool isSequential() const { return false; } // random access, we can seek
8191     virtual bool seek (qint64 pos) { return buffer.seek(pos); }
8192 protected slots:
8193     void timeoutSlot()
8194     {
8195         //qDebug() << Q_FUNC_INFO;
8196         bandwidthQuota = 8*1024; // fill quota
8197         emit readyRead();
8198         // Emitting readyRead() several times triggers a bug ("QIODevice::read: Called with maxSize < 0") we fix with this commit
8199         emit readyRead();
8200     }
8201 };
8202 
8203 void tst_QNetworkReply::putWithRateLimiting()
8204 {
8205     QFile reference(testDataDir + "/rfc3252.txt");
8206     reference.open(QIODevice::ReadOnly);
8207     QByteArray data = reference.readAll();
8208     QVERIFY(data.length() > 0);
8209 
8210     QUrl url = QUrl::fromUserInput("http://" + QtNetworkSettings::serverName()+ "/qtest/cgi-bin/echo.cgi?");
8211 
8212     QNetworkRequest request(url);
8213     QNetworkReplyPtr reply;
8214 
8215     RateLimitedUploadDevice rateLimitedUploadDevice(data);
8216     rateLimitedUploadDevice.open(QIODevice::ReadOnly);
8217 
8218     RUN_REQUEST(runCustomRequest(request, reply,QByteArray("POST"), &rateLimitedUploadDevice));
8219     QCOMPARE(reply->error(), QNetworkReply::NoError);
8220     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
8221 
8222     QByteArray uploadedData = reply->readAll();
8223     QCOMPARE(uploadedData.length(), data.length());
8224     QCOMPARE(uploadedData, data);
8225 }
8226 
8227 void tst_QNetworkReply::ioHttpSingleRedirect()
8228 {
8229     QUrl localhost = QUrl("http://localhost");
8230 
8231     // Setup server to which the second server will redirect to
8232     MiniHttpServer server2(httpEmpty200Response);
8233 
8234     QUrl redirectUrl = QUrl(localhost);
8235     redirectUrl.setPort(server2.serverPort());
8236 
8237     QByteArray tempRedirectReply =
8238             tempRedirectReplyStr().arg(QString(redirectUrl.toEncoded())).toLatin1();
8239 
8240 
8241     // Setup redirect server
8242     MiniHttpServer server(tempRedirectReply);
8243 
8244     localhost.setPort(server.serverPort());
8245     QNetworkRequest request(localhost);
8246     request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, true);
8247 
8248     QNetworkReplyPtr reply(manager.get(request));
8249     QSignalSpy redSpy(reply.data(), SIGNAL(redirected(QUrl)));
8250     QSignalSpy finSpy(reply.data(), SIGNAL(finished()));
8251 
8252     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
8253 
8254     // Redirected and finished should be emitted exactly once
8255     QCOMPARE(redSpy.count(), 1);
8256     QCOMPARE(finSpy.count(), 1);
8257 
8258     // Original URL should not be changed after redirect
8259     QCOMPARE(request.url(), localhost);
8260 
8261     // Verify Redirect url
8262     QList<QVariant> args = redSpy.takeFirst();
8263     QCOMPARE(args.at(0).toUrl(), redirectUrl);
8264 
8265     // Reply url is set to the redirect url
8266     QCOMPARE(reply->url(), redirectUrl);
8267     QCOMPARE(reply->error(), QNetworkReply::NoError);
8268     QVERIFY(validateRedirectedResponseHeaders(reply));
8269 }
8270 
8271 void tst_QNetworkReply::ioHttpChangeMaxRedirects()
8272 {
8273     QUrl localhost = QUrl("http://localhost");
8274 
8275     MiniHttpServer server1("");
8276     MiniHttpServer server2("");
8277     MiniHttpServer server3(httpEmpty200Response);
8278 
8279     QUrl server2Url(localhost);
8280     server2Url.setPort(server2.serverPort());
8281     server1.setDataToTransmit(tempRedirectReplyStr().arg(
8282                               QString(server2Url.toEncoded())).toLatin1());
8283 
8284     QUrl server3Url(localhost);
8285     server3Url.setPort(server3.serverPort());
8286     server2.setDataToTransmit(tempRedirectReplyStr().arg(
8287                               QString(server3Url.toEncoded())).toLatin1());
8288 
8289     localhost.setPort(server1.serverPort());
8290     QNetworkRequest request(localhost);
8291     request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, true);
8292 
8293     // Set Max redirects to 1. This will cause TooManyRedirectsError
8294     request.setMaximumRedirectsAllowed(1);
8295 
8296     QNetworkReplyPtr reply(manager.get(request));
8297     QSignalSpy redSpy(reply.data(), SIGNAL(redirected(QUrl)));
8298     QSignalSpy spy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
8299 
8300     QCOMPARE(waitForFinish(reply), int(Failure));
8301 
8302     QCOMPARE(redSpy.count(), request.maximumRedirectsAllowed());
8303     QCOMPARE(spy.count(), 1);
8304     QCOMPARE(reply->error(), QNetworkReply::TooManyRedirectsError);
8305 
8306     // Increase max redirects to allow successful completion
8307     request.setMaximumRedirectsAllowed(3);
8308 
8309     QNetworkReplyPtr reply2(manager.get(request));
8310     QSignalSpy redSpy2(reply2.data(), SIGNAL(redirected(QUrl)));
8311 
8312     QVERIFY2(waitForFinish(reply2) == Success, msgWaitForFinished(reply2));
8313 
8314     QCOMPARE(redSpy2.count(), 2);
8315     QCOMPARE(reply2->url(), server3Url);
8316     QCOMPARE(reply2->error(), QNetworkReply::NoError);
8317     QVERIFY(validateRedirectedResponseHeaders(reply2));
8318 }
8319 
8320 void tst_QNetworkReply::ioHttpRedirectErrors_data()
8321 {
8322     QTest::addColumn<QString>("url");
8323     QTest::addColumn<QString>("dataToSend");
8324     QTest::addColumn<QNetworkReply::NetworkError>("error");
8325 
8326     QString tempRedirectReply = QString("HTTP/1.1 307 Temporary Redirect\r\n"
8327                                         "Content-Type: text/plain\r\n"
8328                                         "location: http://localhost:%1\r\n\r\n");
8329 
8330     QTest::newRow("too-many-redirects") << "http://localhost" << tempRedirectReply << QNetworkReply::TooManyRedirectsError;
8331 #if QT_CONFIG(ssl)
8332     QTest::newRow("insecure-redirect") << "https://localhost" << tempRedirectReply << QNetworkReply::InsecureRedirectError;
8333 #endif
8334     QTest::newRow("unknown-redirect") << "http://localhost"<< tempRedirectReply.replace("http", "bad_protocol") << QNetworkReply::ProtocolUnknownError;
8335 }
8336 
8337 void tst_QNetworkReply::ioHttpRedirectErrors()
8338 {
8339     QFETCH(QString, url);
8340     QFETCH(QString, dataToSend);
8341     QFETCH(QNetworkReply::NetworkError, error);
8342 
8343     QUrl localhost(url);
8344     MiniHttpServer server("", localhost.scheme() == QLatin1String("https"));
8345 
8346     localhost.setPort(server.serverPort());
8347 
8348     QByteArray d2s = dataToSend.arg(
8349                 QString::number(server.serverPort())).toLatin1();
8350     server.setDataToTransmit(d2s);
8351 
8352     QNetworkRequest request(localhost);
8353     request.setAttribute(QNetworkRequest::FollowRedirectsAttribute, true);
8354     QNetworkReplyPtr reply(manager.get(request));
8355     if (localhost.scheme() == "https")
8356         reply.data()->ignoreSslErrors();
8357 
8358     QEventLoop eventLoop;
8359     QTimer watchDog;
8360     watchDog.setSingleShot(true);
8361 
8362     reply->connect(reply.data(), QOverload<QNetworkReply::NetworkError>().of(&QNetworkReply::error),
8363                    [&eventLoop](QNetworkReply::NetworkError){
8364                         eventLoop.exit(Failure);
8365                    });
8366 
8367     watchDog.connect(&watchDog, &QTimer::timeout, [&eventLoop](){
8368                         eventLoop.exit(Timeout);
8369                     });
8370 
8371     watchDog.start(5000);
8372 
8373     QCOMPARE(eventLoop.exec(), int(Failure));
8374     QCOMPARE(reply->error(), error);
8375 }
8376 
8377 struct SameOriginRedirector : MiniHttpServer
8378 {
8379     SameOriginRedirector(const QByteArray &data, bool ssl = false)
8380         : MiniHttpServer(data, ssl)
8381     { }
8382 
8383     std::vector<QByteArray> responses;
8384 
8385     void reply() override
8386     {
8387         if (responses.empty()) {
8388             dataToTransmit.clear();
8389         } else {
8390             dataToTransmit = responses.back();
8391             responses.pop_back();
8392         }
8393 
8394         MiniHttpServer::reply();
8395     }
8396 };
8397 
8398 void tst_QNetworkReply::ioHttpRedirectPolicy_data()
8399 {
8400     QTest::addColumn<QNetworkRequest::RedirectPolicy>("policy");
8401     QTest::addColumn<bool>("ssl");
8402     QTest::addColumn<int>("redirectCount");
8403     QTest::addColumn<int>("statusCode");
8404 
8405     QTest::newRow("manual-nossl") << QNetworkRequest::ManualRedirectPolicy << false << 0 << 307;
8406     QTest::newRow("nolesssafe-nossl") << QNetworkRequest::NoLessSafeRedirectPolicy << false << 1 << 200;
8407     QTest::newRow("same-origin-nossl") << QNetworkRequest::SameOriginRedirectPolicy << false << 1 << 200;
8408 #if QT_CONFIG(ssl)
8409     QTest::newRow("manual-ssl") << QNetworkRequest::ManualRedirectPolicy << true << 0 << 307;
8410     QTest::newRow("nolesssafe-ssl") << QNetworkRequest::NoLessSafeRedirectPolicy << true << 1 << 200;
8411     QTest::newRow("same-origin-ssl") << QNetworkRequest::SameOriginRedirectPolicy << true << 1 << 200;
8412 #endif
8413 }
8414 
8415 void tst_QNetworkReply::ioHttpRedirectPolicy()
8416 {
8417     QFETCH(const QNetworkRequest::RedirectPolicy, policy);
8418 
8419     QFETCH(const bool, ssl);
8420 
8421     QFETCH(const int, redirectCount);
8422     QFETCH(const int, statusCode);
8423 
8424     // Setup HTTP server.
8425     SameOriginRedirector redirectServer("", ssl);
8426 
8427     QUrl url(QLatin1String(ssl ? "https://localhost" : "http://localhost"));
8428 
8429     url.setPort(redirectServer.serverPort());
8430     redirectServer.responses.push_back(httpEmpty200Response);
8431     redirectServer.responses.push_back(tempRedirectReplyStr().arg(QString(url.toEncoded())).toLatin1());
8432 
8433     // This is the default one we preserve between tests.
8434     QCOMPARE(manager.redirectPolicy(), QNetworkRequest::ManualRedirectPolicy);
8435 
8436     manager.setRedirectPolicy(policy);
8437     QCOMPARE(manager.redirectPolicy(), policy);
8438     QNetworkReplyPtr reply(manager.get(QNetworkRequest(url)));
8439     if (ssl)
8440         reply->ignoreSslErrors();
8441 
8442     // Restore default:
8443     manager.setRedirectPolicy(QNetworkRequest::ManualRedirectPolicy);
8444     QSignalSpy redirectSpy(reply.data(), SIGNAL(redirected(QUrl)));
8445     QSignalSpy finishedSpy(reply.data(), SIGNAL(finished()));
8446     QVERIFY2(waitForFinish(reply) == Success, msgWaitForFinished(reply));
8447     QCOMPARE(finishedSpy.count(), 1);
8448     QCOMPARE(redirectSpy.count(), redirectCount);
8449     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), statusCode);
8450     QVERIFY(validateRedirectedResponseHeaders(reply) || statusCode != 200);
8451 }
8452 
8453 void tst_QNetworkReply::ioHttpRedirectPolicyErrors_data()
8454 {
8455     QTest::addColumn<QNetworkRequest::RedirectPolicy>("policy");
8456     QTest::addColumn<bool>("ssl");
8457     QTest::addColumn<QString>("location");
8458     QTest::addColumn<int>("maxRedirects");
8459     QTest::addColumn<QNetworkReply::NetworkError>("expectedError");
8460 
8461     // 1. NoLessSafeRedirectsPolicy
8462     QTest::newRow("nolesssafe-nossl-nossl-too-many") << QNetworkRequest::NoLessSafeRedirectPolicy
8463             << false << QString("http://localhost:%1") << 0 << QNetworkReply::TooManyRedirectsError;
8464 #if QT_CONFIG(ssl)
8465     QTest::newRow("nolesssafe-ssl-ssl-too-many") << QNetworkRequest::NoLessSafeRedirectPolicy
8466             << true << QString("https:/localhost:%1") << 0 << QNetworkReply::TooManyRedirectsError;
8467     QTest::newRow("nolesssafe-ssl-nossl-insecure-redirect") << QNetworkRequest::NoLessSafeRedirectPolicy
8468             << true << QString("http://localhost:%1") << 50 << QNetworkReply::InsecureRedirectError;
8469 #endif
8470     // 2. SameOriginRedirectsPolicy
8471     QTest::newRow("same-origin-nossl-nossl-too-many") << QNetworkRequest::SameOriginRedirectPolicy
8472             << false << QString("http://localhost:%1") << 0 << QNetworkReply::TooManyRedirectsError;
8473 #if QT_CONFIG(ssl)
8474     QTest::newRow("same-origin-ssl-ssl-too-many") << QNetworkRequest::SameOriginRedirectPolicy
8475             << true << QString("https://localhost:%1") << 0 << QNetworkReply::TooManyRedirectsError;
8476     QTest::newRow("same-origin-https-http-wrong-protocol") << QNetworkRequest::SameOriginRedirectPolicy
8477             << true << QString("http://localhost:%1") << 50 << QNetworkReply::InsecureRedirectError;
8478 #endif
8479     QTest::newRow("same-origin-http-https-wrong-protocol") << QNetworkRequest::SameOriginRedirectPolicy
8480             << false << QString("https://localhost:%1") << 50 << QNetworkReply::InsecureRedirectError;
8481     QTest::newRow("same-origin-http-http-wrong-host") << QNetworkRequest::SameOriginRedirectPolicy
8482             << false << QString("http://not-so-localhost:%1") << 50 << QNetworkReply::InsecureRedirectError;
8483 #if QT_CONFIG(ssl)
8484     QTest::newRow("same-origin-https-https-wrong-host") << QNetworkRequest::SameOriginRedirectPolicy
8485             << true << QString("https://not-so-localhost:%1") << 50 << QNetworkReply::InsecureRedirectError;
8486 #endif
8487     QTest::newRow("same-origin-http-http-wrong-port") << QNetworkRequest::SameOriginRedirectPolicy
8488             << false << QString("http://localhost/%1") << 50 << QNetworkReply::InsecureRedirectError;
8489 #if QT_CONFIG(ssl)
8490     QTest::newRow("same-origin-https-https-wrong-port") << QNetworkRequest::SameOriginRedirectPolicy
8491             << true << QString("https://localhost/%1") << 50 << QNetworkReply::InsecureRedirectError;
8492 #endif
8493 }
8494 
8495 void tst_QNetworkReply::ioHttpRedirectPolicyErrors()
8496 {
8497     QFETCH(const QNetworkRequest::RedirectPolicy, policy);
8498     // This should never happen:
8499     QVERIFY(policy != QNetworkRequest::ManualRedirectPolicy);
8500 
8501     QFETCH(const bool, ssl);
8502     QFETCH(const QString, location);
8503     QFETCH(const int, maxRedirects);
8504     QFETCH(const QNetworkReply::NetworkError, expectedError);
8505 
8506     // Setup the server.
8507     MiniHttpServer server("", ssl);
8508     server.setDataToTransmit(tempRedirectReplyStr().arg(location.arg(server.serverPort())).toLatin1());
8509 
8510     QUrl url(QLatin1String(ssl ? "https://localhost" : "http://localhost"));
8511     url.setPort(server.serverPort());
8512 
8513     QNetworkRequest request(url);
8514     request.setMaximumRedirectsAllowed(maxRedirects);
8515     // We always reset the policy to the default one ('Manual') after any related
8516     // test is finished:
8517     QCOMPARE(manager.redirectPolicy(), QNetworkRequest::ManualRedirectPolicy);
8518     manager.setRedirectPolicy(policy);
8519     QCOMPARE(manager.redirectPolicy(), policy);
8520 
8521     QNetworkReplyPtr reply(manager.get(request));
8522     // Set it back to default:
8523     manager.setRedirectPolicy(QNetworkRequest::ManualRedirectPolicy);
8524 
8525     if (ssl)
8526         reply->ignoreSslErrors();
8527 
8528     QSignalSpy spy(reply.data(), SIGNAL(error(QNetworkReply::NetworkError)));
8529 
8530     QCOMPARE(waitForFinish(reply), int(Failure));
8531     QCOMPARE(spy.count(), 1);
8532     QCOMPARE(reply->error(), expectedError);
8533 }
8534 
8535 void tst_QNetworkReply::ioHttpUserVerifiedRedirect_data()
8536 {
8537     QTest::addColumn<bool>("followRedirect");
8538     QTest::addColumn<int>("statusCode");
8539 
8540     QTest::newRow("allow-redirect") << true << 200;
8541     QTest::newRow("reject-redirect") << false << 307;
8542 }
8543 
8544 void tst_QNetworkReply::ioHttpUserVerifiedRedirect()
8545 {
8546     QFETCH(const bool, followRedirect);
8547     QFETCH(const int, statusCode);
8548 
8549     // Setup HTTP server.
8550     MiniHttpServer target(httpEmpty200Response, false);
8551     QUrl url("http://localhost");
8552     url.setPort(target.serverPort());
8553 
8554     MiniHttpServer redirectServer("", false);
8555     redirectServer.setDataToTransmit(tempRedirectReplyStr().arg(QString(url.toEncoded())).toLatin1());
8556     url.setPort(redirectServer.serverPort());
8557 
8558     QCOMPARE(manager.redirectPolicy(), QNetworkRequest::ManualRedirectPolicy);
8559     manager.setRedirectPolicy(QNetworkRequest::UserVerifiedRedirectPolicy);
8560     QCOMPARE(manager.redirectPolicy(), QNetworkRequest::UserVerifiedRedirectPolicy);
8561 
8562     QNetworkReplyPtr reply(manager.get(QNetworkRequest(url)));
8563     reply->connect(reply.data(), &QNetworkReply::redirected,
8564                    [&](const QUrl &redirectUrl) {
8565                         qDebug() << "redirect to:" << redirectUrl;
8566                         if (followRedirect) {
8567                             qDebug() << "confirmed.";
8568                             emit reply->redirectAllowed();
8569                         } else{
8570                             qDebug() << "rejected.";
8571                             emit reply->abort();
8572                         }
8573                    });
8574 
8575     // Before any test failed, reset the policy to default:
8576     manager.setRedirectPolicy(QNetworkRequest::ManualRedirectPolicy);
8577     QCOMPARE(manager.redirectPolicy(), QNetworkRequest::ManualRedirectPolicy);
8578 
8579     QSignalSpy finishedSpy(reply.data(), SIGNAL(finished()));
8580     waitForFinish(reply);
8581     QCOMPARE(finishedSpy.count(), 1);
8582     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), statusCode);
8583     QVERIFY(validateRedirectedResponseHeaders(reply) || statusCode != 200);
8584 }
8585 
8586 void tst_QNetworkReply::ioHttpCookiesDuringRedirect()
8587 {
8588     MiniHttpServer target(httpEmpty200Response, false);
8589 
8590     const QString cookieHeader = QStringLiteral("Set-Cookie: hello=world; Path=/;\r\n");
8591     QString redirect = tempRedirectReplyStr();
8592     // Insert 'cookieHeader' before the final \r\n
8593     redirect.insert(redirect.length() - 2, cookieHeader);
8594 
8595     QUrl url("http://localhost/");
8596     url.setPort(target.serverPort());
8597     redirect = redirect.arg(url.toString());
8598     MiniHttpServer redirectServer(redirect.toLatin1(), false);
8599 
8600     url = QUrl("http://localhost/");
8601     url.setPort(redirectServer.serverPort());
8602     QNetworkRequest request(url);
8603     auto oldRedirectPolicy = manager.redirectPolicy();
8604     manager.setRedirectPolicy(QNetworkRequest::RedirectPolicy::NoLessSafeRedirectPolicy);
8605     QNetworkReplyPtr reply(manager.get(request));
8606     // Set policy back to whatever it was
8607     manager.setRedirectPolicy(oldRedirectPolicy);
8608 
8609     QVERIFY(waitForFinish(reply) == Success);
8610     QVERIFY(target.receivedData.contains("\r\nCookie: hello=world\r\n"));
8611     QVERIFY(validateRedirectedResponseHeaders(reply));
8612 }
8613 
8614 void tst_QNetworkReply::ioHttpRedirect_data()
8615 {
8616     QTest::addColumn<QString>("status");
8617 
8618     QTest::addRow("301") << "301 Moved Permanently";
8619     QTest::addRow("302") << "302 Found";
8620     QTest::addRow("303") << "303 See Other";
8621     QTest::addRow("305") << "305 Use Proxy";
8622     QTest::addRow("307") << "307 Temporary Redirect";
8623     QTest::addRow("308") << "308 Permanent Redirect";
8624 }
8625 
8626 void tst_QNetworkReply::ioHttpRedirect()
8627 {
8628     QFETCH(QString, status);
8629 
8630     MiniHttpServer target(httpEmpty200Response, false);
8631     QUrl targetUrl("http://localhost/");
8632     targetUrl.setPort(target.serverPort());
8633 
8634     QString redirectReply = QStringLiteral("HTTP/1.1 %1\r\n"
8635                                            "Content-Type: text/plain\r\n"
8636                                            "location: %2\r\n"
8637                                            "\r\n").arg(status, targetUrl.toString());
8638     MiniHttpServer redirectServer(redirectReply.toLatin1(), false);
8639     QUrl url("http://localhost/");
8640     url.setPort(redirectServer.serverPort());
8641     QNetworkRequest request(url);
8642     auto oldRedirectPolicy = manager.redirectPolicy();
8643     manager.setRedirectPolicy(QNetworkRequest::RedirectPolicy::NoLessSafeRedirectPolicy);
8644     QNetworkReplyPtr reply(manager.get(request));
8645     // Set policy back to what it was
8646     manager.setRedirectPolicy(oldRedirectPolicy);
8647 
8648     QCOMPARE(waitForFinish(reply), int(Success));
8649     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200);
8650     QVERIFY(validateRedirectedResponseHeaders(reply));
8651 }
8652 
8653 void tst_QNetworkReply::ioHttpRedirectFromLocalToRemote()
8654 {
8655     QUrl targetUrl("http://" + QtNetworkSettings::serverName() + "/qtest/rfc3252.txt");
8656 
8657     QString redirectReply = tempRedirectReplyStr().arg(targetUrl.toString());
8658     MiniHttpServer redirectServer(redirectReply.toLatin1(), false);
8659     QUrl url("http://localhost/");
8660     url.setPort(redirectServer.serverPort());
8661 
8662     QFile reference(testDataDir + "/rfc3252.txt");
8663     QVERIFY(reference.open(QIODevice::ReadOnly));
8664     QNetworkRequest request(url);
8665 
8666     auto oldRedirectPolicy = manager.redirectPolicy();
8667     manager.setRedirectPolicy(QNetworkRequest::RedirectPolicy::NoLessSafeRedirectPolicy);
8668     QNetworkReplyPtr reply(manager.get(request));
8669     // Restore previous policy
8670     manager.setRedirectPolicy(oldRedirectPolicy);
8671 
8672     QCOMPARE(waitForFinish(reply), int(Success));
8673 
8674     QCOMPARE(reply->url(), targetUrl);
8675     QCOMPARE(reply->error(), QNetworkReply::NoError);
8676     QCOMPARE(reply->header(QNetworkRequest::ContentLengthHeader).toLongLong(), reference.size());
8677     QCOMPARE(reply->readAll(), reference.readAll());
8678 }
8679 
8680 void tst_QNetworkReply::ioHttpRedirectPostPut_data()
8681 {
8682     QTest::addColumn<bool>("usePost");
8683     QTest::addColumn<QString>("status");
8684     QTest::addColumn<QByteArray>("data");
8685     QTest::addColumn<QString>("contentType");
8686 
8687     QByteArray data;
8688     data = "hello world";
8689     QTest::addRow("post-307") << true << "307 Temporary Redirect" << data << "text/plain";
8690     QTest::addRow("put-307") << false << "307 Temporary Redirect" << data << "text/plain";
8691     QString permanentRedirect = "308 Permanent Redirect";
8692     QTest::addRow("post-308") << true << permanentRedirect << data << "text/plain";
8693     QTest::addRow("put-308") << false << permanentRedirect << data << "text/plain";
8694 
8695     // Some data from ::putToFile_data
8696     data = "";
8697     QTest::newRow("post-empty") << true << permanentRedirect << data << "application/octet-stream";
8698     QTest::newRow("put-empty") << false << permanentRedirect << data << "application/octet-stream";
8699 
8700     data = QByteArray("abcd\0\1\2\abcd",12);
8701     QTest::newRow("post-with-nul") << true << permanentRedirect << data << "application/octet-stream";
8702     QTest::newRow("put-with-nul") << false << permanentRedirect << data << "application/octet-stream";
8703 
8704     data = QByteArray(4097, '\4');
8705     QTest::newRow("post-4k+1") << true << permanentRedirect << data << "application/octet-stream";
8706     QTest::newRow("put-4k+1") << false << permanentRedirect << data << "application/octet-stream";
8707 
8708     data = QByteArray(128*1024+1, '\177');
8709     QTest::newRow("post-128k+1") << true << permanentRedirect << data << "application/octet-stream";
8710     QTest::newRow("put-128k+1") << false << permanentRedirect << data << "application/octet-stream";
8711 
8712     data = QByteArray(2*1024*1024+1, '\177');
8713     QTest::newRow("post-2MB+1") << true << permanentRedirect << data << "application/octet-stream";
8714     QTest::newRow("put-2MB+1") << false << permanentRedirect << data << "application/octet-stream";
8715 }
8716 
8717 void tst_QNetworkReply::ioHttpRedirectPostPut()
8718 {
8719     QFETCH(bool, usePost);
8720     QFETCH(QString, status);
8721     QFETCH(QByteArray, data);
8722     QFETCH(QString, contentType);
8723 
8724     QUrl targetUrl("http://" + QtNetworkSettings::serverName() + "/qtest/cgi-bin/md5sum.cgi");
8725 
8726     QString redirectReply = QStringLiteral("HTTP/1.1 %1\r\n"
8727                                            "Content-Type: text/plain\r\n"
8728                                            "location: %2\r\n"
8729                                            "\r\n").arg(status, targetUrl.toString());
8730     MiniHttpServer redirectServer(redirectReply.toLatin1());
8731     QUrl url("http://localhost/");
8732     url.setPort(redirectServer.serverPort());
8733     QNetworkRequest request(url);
8734     request.setHeader(QNetworkRequest::KnownHeaders::ContentTypeHeader, contentType);
8735     auto oldRedirectPolicy = manager.redirectPolicy();
8736     manager.setRedirectPolicy(QNetworkRequest::RedirectPolicy::NoLessSafeRedirectPolicy);
8737 
8738     QNetworkReplyPtr reply(usePost ? manager.post(request, data) : manager.put(request, data));
8739     // Restore previous policy:
8740     manager.setRedirectPolicy(oldRedirectPolicy);
8741 
8742     QCOMPARE(waitForFinish(reply), int(Success));
8743     QCOMPARE(reply->readAll().trimmed(), md5sum(data).toHex());
8744 }
8745 
8746 void tst_QNetworkReply::ioHttpRedirectMultipartPost_data()
8747 {
8748     postToHttpMultipart_data();
8749 }
8750 
8751 void tst_QNetworkReply::ioHttpRedirectMultipartPost()
8752 {
8753     // Note: This code is heavily based on postToHttpMultipart
8754     QFETCH(QUrl, url);
8755 
8756     static QSet<QByteArray> boundaries;
8757 
8758     QNetworkReplyPtr reply;
8759 
8760     QFETCH(QHttpMultiPart *, multiPart);
8761     QFETCH(QByteArray, expectedReplyData);
8762     QFETCH(QByteArray, contentType);
8763 
8764     QString redirectReply = tempRedirectReplyStr().arg(url.toString());
8765     MiniHttpServer redirectServer(redirectReply.toLatin1());
8766     QUrl redirectUrl("http://localhost/");
8767     redirectUrl.setPort(redirectServer.serverPort());
8768     QNetworkRequest request(redirectUrl);
8769 
8770     // Restore policy when we leave this scope:
8771     struct PolicyRestorer
8772     {
8773         QNetworkAccessManager &qnam;
8774         QNetworkRequest::RedirectPolicy policy;
8775         PolicyRestorer(QNetworkAccessManager &qnam)
8776             : qnam(qnam), policy(qnam.redirectPolicy())
8777         { qnam.setRedirectPolicy(QNetworkRequest::RedirectPolicy::NoLessSafeRedirectPolicy); }
8778         ~PolicyRestorer() { qnam.setRedirectPolicy(policy); }
8779     } policyRestorer(manager);
8780 
8781     // hack for testing the setting of the content-type header by hand:
8782     if (contentType == "custom") {
8783         QByteArray contentType("multipart/custom; boundary=\"" + multiPart->boundary() + "\"");
8784         request.setHeader(QNetworkRequest::ContentTypeHeader, contentType);
8785     }
8786 
8787     QVERIFY2(! boundaries.contains(multiPart->boundary()), "boundary '" + multiPart->boundary() + "' has been created twice");
8788     boundaries.insert(multiPart->boundary());
8789 
8790     RUN_REQUEST(runMultipartRequest(request, reply, multiPart, "POST"));
8791     multiPart->deleteLater();
8792 
8793     QCOMPARE(reply->url(), url);
8794     QCOMPARE(reply->error(), QNetworkReply::NoError);
8795 
8796     QCOMPARE(reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt(), 200); // 200 OK
8797 
8798     QVERIFY(multiPart->boundary().count() > 20); // check that there is randomness after the "boundary_.oOo._" string
8799     QVERIFY(multiPart->boundary().count() < 70);
8800     QByteArray replyData = reply->readAll();
8801 
8802     expectedReplyData.prepend("content type: multipart/" + contentType + "; boundary=\"" + multiPart->boundary() + "\"\n");
8803 //    QEXPECT_FAIL("nested", "the server does not understand nested multipart messages", Continue); // see above
8804     QCOMPARE(replyData, expectedReplyData);
8805 }
8806 
8807 void tst_QNetworkReply::ioHttpRedirectDelete()
8808 {
8809     MiniHttpServer target(httpEmpty200Response, false);
8810     QUrl targetUrl("http://localhost/");
8811     targetUrl.setPort(target.serverPort());
8812 
8813     QString redirectReply = tempRedirectReplyStr().arg(targetUrl.toString());
8814     MiniHttpServer redirectServer(redirectReply.toLatin1());
8815     QUrl url("http://localhost/");
8816     url.setPort(redirectServer.serverPort());
8817     QNetworkRequest request(url);
8818     auto oldRedirectPolicy = manager.redirectPolicy();
8819     manager.setRedirectPolicy(QNetworkRequest::RedirectPolicy::NoLessSafeRedirectPolicy);
8820 
8821     QNetworkReplyPtr reply(manager.deleteResource(request));
8822     // Restore previous policy:
8823     manager.setRedirectPolicy(oldRedirectPolicy);
8824 
8825     QCOMPARE(waitForFinish(reply), int(Success));
8826     QVERIFY2(target.receivedData.startsWith("DELETE"), "Target server called with the wrong method");
8827 }
8828 
8829 void tst_QNetworkReply::ioHttpRedirectCustom()
8830 {
8831     MiniHttpServer target(httpEmpty200Response, false);
8832     QUrl targetUrl("http://localhost/");
8833     targetUrl.setPort(target.serverPort());
8834 
8835     QString redirectReply = tempRedirectReplyStr().arg(targetUrl.toString());
8836     MiniHttpServer redirectServer(redirectReply.toLatin1());
8837     QUrl url("http://localhost/");
8838     url.setPort(redirectServer.serverPort());
8839     QNetworkRequest request(url);
8840     auto oldRedirectPolicy = manager.redirectPolicy();
8841     manager.setRedirectPolicy(QNetworkRequest::RedirectPolicy::NoLessSafeRedirectPolicy);
8842 
8843     QNetworkReplyPtr reply(manager.sendCustomRequest(request, QByteArrayLiteral("CUSTOM")));
8844     // Restore previous policy:
8845     manager.setRedirectPolicy(oldRedirectPolicy);
8846 
8847     QCOMPARE(waitForFinish(reply), int(Success));
8848     QVERIFY2(target.receivedData.startsWith("CUSTOM"), "Target server called with the wrong method");
8849 }
8850 
8851 #ifndef QT_NO_SSL
8852 
8853 class PutWithServerClosingConnectionImmediatelyHandler: public QObject
8854 {
8855     Q_OBJECT
8856 public:
8857     bool m_parsedHeaders;
8858     QByteArray m_receivedData;
8859     QByteArray m_expectedData;
8860     QSslSocket *m_socket;
8861     PutWithServerClosingConnectionImmediatelyHandler(QSslSocket *s, QByteArray expected) :m_parsedHeaders(false),  m_expectedData(expected), m_socket(s)
8862     {
8863         m_socket->setParent(this);
8864         connect(m_socket, SIGNAL(readyRead()), SLOT(readyReadSlot()));
8865         connect(m_socket, SIGNAL(disconnected()), SLOT(disconnectedSlot()));
8866     }
8867 signals:
8868     void correctFileUploadReceived();
8869     void corruptFileUploadReceived();
8870 
8871 public slots:
8872     void closeDelayed() { m_socket->close(); }
8873 
8874     void readyReadSlot()
8875     {
8876         QByteArray data = m_socket->readAll();
8877         m_receivedData += data;
8878         if (!m_parsedHeaders && m_receivedData.contains("\r\n\r\n")) {
8879             m_parsedHeaders = true;
8880             QTimer::singleShot(QRandomGenerator::global()->bounded(60), this, SLOT(closeDelayed())); // simulate random network latency
8881             // This server simulates a web server connection closing, e.g. because of Apaches MaxKeepAliveRequests or KeepAliveTimeout
8882             // In this case QNAM needs to re-send the upload data but it had a bug which then corrupts the upload
8883             // This test catches that.
8884         }
8885 
8886     }
8887     void disconnectedSlot()
8888     {
8889         if (m_parsedHeaders) {
8890             //qDebug() << m_receivedData.left(m_receivedData.indexOf("\r\n\r\n"));
8891             m_receivedData = m_receivedData.mid(m_receivedData.indexOf("\r\n\r\n")+4); // check only actual data
8892         }
8893         if (m_receivedData.length() > 0 && !m_expectedData.startsWith(m_receivedData)) {
8894             // We had received some data but it is corrupt!
8895             qDebug() << "CORRUPT" << m_receivedData.count();
8896 
8897 #if 0 // Use this to track down the pattern of the corruption and conclude the source
8898             QFile a("/tmp/corrupt");
8899             a.open(QIODevice::WriteOnly);
8900             a.write(m_receivedData);
8901             a.close();
8902 
8903             QFile b("/tmp/correct");
8904             b.open(QIODevice::WriteOnly);
8905             b.write(m_expectedData);
8906             b.close();
8907             //exit(1);
8908 #endif
8909             emit corruptFileUploadReceived();
8910         } else {
8911             emit correctFileUploadReceived();
8912         }
8913     }
8914 };
8915 
8916 class PutWithServerClosingConnectionImmediatelyServer: public SslServer
8917 {
8918     Q_OBJECT
8919 public:
8920     int m_correctUploads;
8921     int m_corruptUploads;
8922     int m_repliesFinished;
8923     int m_expectedReplies;
8924     QByteArray m_expectedData;
8925     PutWithServerClosingConnectionImmediatelyServer()
8926         : SslServer(), m_correctUploads(0), m_corruptUploads(0),
8927           m_repliesFinished(0), m_expectedReplies(0)
8928     {
8929         QObject::connect(this, SIGNAL(newEncryptedConnection(QSslSocket*)), this, SLOT(createHandlerForConnection(QSslSocket*)));
8930         QObject::connect(this, SIGNAL(newPlainConnection(QSslSocket*)), this, SLOT(createHandlerForConnection(QSslSocket*)));
8931     }
8932 
8933 public slots:
8934     void createHandlerForConnection(QSslSocket* s)
8935     {
8936         PutWithServerClosingConnectionImmediatelyHandler *handler = new PutWithServerClosingConnectionImmediatelyHandler(s, m_expectedData);
8937         handler->setParent(this);
8938         QObject::connect(handler, SIGNAL(correctFileUploadReceived()), this, SLOT(increaseCorrect()));
8939         QObject::connect(handler, SIGNAL(corruptFileUploadReceived()), this, SLOT(increaseCorrupt()));
8940     }
8941     void increaseCorrect() { m_correctUploads++; }
8942     void increaseCorrupt() { m_corruptUploads++; }
8943     void replyFinished()
8944     {
8945         m_repliesFinished++;
8946         if (m_repliesFinished == m_expectedReplies) {
8947             QTestEventLoop::instance().exitLoop();
8948         }
8949      }
8950 };
8951 
8952 
8953 
8954 void tst_QNetworkReply::putWithServerClosingConnectionImmediately()
8955 {
8956     const int numUploads = 40;
8957     qint64 wantedSize = 512*1024; // 512 kB
8958     QByteArray sourceFile;
8959     for (int i = 0; i < wantedSize; ++i) {
8960         sourceFile += (char)'a' +(i%26);
8961     }
8962     bool withSsl = false;
8963 
8964     for (int s = 0; s <= 1; s++) {
8965         withSsl = (s == 1);
8966         // Test also needs to run several times because of 9c2ecf89
8967         for (int j = 0; j < 20; j++) {
8968             // emulate a minimal https server
8969             PutWithServerClosingConnectionImmediatelyServer server;
8970             server.m_ssl = withSsl;
8971             server.m_expectedData = sourceFile;
8972             server.m_expectedReplies = numUploads;
8973             server.listen(QHostAddress(QHostAddress::LocalHost), 0);
8974 
8975             QString urlPrefix = QLatin1String("http");
8976             if (withSsl)
8977                 urlPrefix += QLatin1Char('s');
8978             urlPrefix += QLatin1String("://127.0.0.1:");
8979             urlPrefix += QString::number(server.serverPort());
8980             urlPrefix += QLatin1String("/file=");
8981             for (int i = 0; i < numUploads; i++) {
8982                 // create the request
8983                 QNetworkRequest request(QUrl(urlPrefix + QString::number(i)));
8984                 QNetworkReply *reply = manager.put(request, sourceFile);
8985                 connect(reply, SIGNAL(sslErrors(QList<QSslError>)), reply, SLOT(ignoreSslErrors()));
8986                 connect(reply, SIGNAL(finished()), &server, SLOT(replyFinished()));
8987                 reply->setParent(&server);
8988             }
8989 
8990             // get the request started and the incoming socket connected
8991             QTestEventLoop::instance().enterLoop(10);
8992             QVERIFY(!QTestEventLoop::instance().timeout());
8993 
8994             //qDebug() << "correct=" << server.m_correctUploads << "corrupt=" << server.m_corruptUploads << "expected=" <<numUploads;
8995 
8996             // Sanity check because ecause of 9c2ecf89 most replies will error out but we want to make sure at least some of them worked
8997             QVERIFY(server.m_correctUploads > 2);
8998             // Because actually important is that we don't get any corruption:
8999             QCOMPARE(server.m_corruptUploads, 0);
9000 
9001             server.close();
9002         }
9003     }
9004 
9005 
9006 }
9007 
9008 #endif
9009 
9010 // NOTE: This test must be last testcase in tst_qnetworkreply!
9011 void tst_QNetworkReply::parentingRepliesToTheApp()
9012 {
9013     QNetworkRequest request (QUrl("http://" + QtNetworkSettings::serverName()));
9014     manager.get(request)->setParent(this); // parent to this object
9015     manager.get(request)->setParent(qApp); // parent to the app
9016 }
9017 
9018 QTEST_MAIN(tst_QNetworkReply)
9019 
9020 #include "tst_qnetworkreply.moc"
