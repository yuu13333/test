Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "debuggerplugin.h"
27 
28 #include "debuggermainwindow.h"
29 #include "debuggerstartparameters.h"
30 #include "debuggeractions.h"
31 #include "debuggerinternalconstants.h"
32 #include "debuggercore.h"
33 #include "debuggerkitconfigwidget.h"
34 #include "debuggerdialogs.h"
35 #include "debuggerengine.h"
36 #include "debuggericons.h"
37 #include "debuggeritem.h"
38 #include "debuggeritemmanager.h"
39 #include "debuggermainwindow.h"
40 #include "debuggerrunconfigurationaspect.h"
41 #include "debuggerruncontrol.h"
42 #include "debuggerkitinformation.h"
43 #include "memoryagent.h"
44 #include "breakhandler.h"
45 #include "disassemblerlines.h"
46 #include "logwindow.h"
47 #include "moduleshandler.h"
48 #include "snapshotwindow.h"
49 #include "stackhandler.h"
50 #include "stackwindow.h"
51 #include "watchhandler.h"
52 #include "watchwindow.h"
53 #include "watchutils.h"
54 #include "unstartedappwatcherdialog.h"
55 #include "debuggertooltipmanager.h"
56 #include "localsandexpressionswindow.h"
57 #include "loadcoredialog.h"
58 #include "sourceutils.h"
59 #include "shared/hostutils.h"
60 #include "console/console.h"
61 
62 #include "snapshothandler.h"
63 #include "threadshandler.h"
64 #include "commonoptionspage.h"
65 #include "gdb/startgdbserverdialog.h"
66 
67 #include "analyzer/analyzerconstants.h"
68 #include "analyzer/analyzermanager.h"
69 #include "analyzer/analyzerstartparameters.h"
70 
71 #include <coreplugin/actionmanager/actioncontainer.h>
72 #include <coreplugin/actionmanager/actionmanager.h>
73 #include <coreplugin/actionmanager/command.h>
74 #include <coreplugin/coreconstants.h>
75 #include <coreplugin/editormanager/documentmodel.h>
76 #include <coreplugin/editormanager/editormanager.h>
77 #include <coreplugin/find/itemviewfind.h>
78 #include <coreplugin/icore.h>
79 #include <coreplugin/imode.h>
80 #include <coreplugin/messagebox.h>
81 #include <coreplugin/messagemanager.h>
82 #include <coreplugin/modemanager.h>
83 #include <coreplugin/modemanager.h>
84 #include <coreplugin/navigationwidget.h>
85 #include <coreplugin/outputpane.h>
86 #include <coreplugin/rightpane.h>
87 
88 #include <cppeditor/cppeditorconstants.h>
89 #include <qmljseditor/qmljseditorconstants.h>
90 #include <cpptools/cppmodelmanager.h>
91 
92 #include <projectexplorer/buildconfiguration.h>
93 #include <projectexplorer/buildmanager.h>
94 #include <projectexplorer/devicesupport/deviceprocessesdialog.h>
95 #include <projectexplorer/devicesupport/deviceprocesslist.h>
96 #include <projectexplorer/project.h>
97 #include <projectexplorer/projectexplorer.h>
98 #include <projectexplorer/projectexplorericons.h>
99 #include <projectexplorer/projectexplorersettings.h>
100 #include <projectexplorer/projecttree.h>
101 #include <projectexplorer/runconfiguration.h>
102 #include <projectexplorer/runnables.h>
103 #include <projectexplorer/session.h>
104 #include <projectexplorer/target.h>
105 #include <projectexplorer/taskhub.h>
106 #include <projectexplorer/toolchain.h>
107 
108 #include <texteditor/texteditor.h>
109 #include <texteditor/textdocument.h>
110 #include <texteditor/fontsettings.h>
111 #include <texteditor/texteditorsettings.h>
112 
113 #include <utils/algorithm.h>
114 #include <utils/appmainwindow.h>
115 #include <utils/basetreeview.h>
116 #include <utils/checkablemessagebox.h>
117 #include <utils/fancymainwindow.h>
118 #include <utils/hostosinfo.h>
119 #include <utils/proxyaction.h>
120 #include <utils/qtcassert.h>
121 #include <utils/savedaction.h>
122 #include <utils/statuslabel.h>
123 #include <utils/styledbar.h>
124 #include <utils/temporarydirectory.h>
125 #include <utils/utilsicons.h>
126 #include <utils/winutils.h>
127 
128 #include <QAction>
129 #include <QApplication>
130 #include <QCheckBox>
131 #include <QComboBox>
132 #include <QDebug>
133 #include <QDialog>
134 #include <QDialogButtonBox>
135 #include <QDockWidget>
136 #include <QFileDialog>
137 #include <QHBoxLayout>
138 #include <QHeaderView>
139 #include <QInputDialog>
140 #include <QMenu>
141 #include <QMessageBox>
142 #include <QPointer>
143 #include <QPushButton>
144 #include <QSettings>
145 #include <QStackedWidget>
146 #include <QTextBlock>
147 #include <QToolButton>
148 #include <QTreeWidget>
149 #include <QVBoxLayout>
150 #include <QVariant>
151 #include <QJsonDocument>
152 #include <QJsonObject>
153 #include <QtPlugin>
154 
155 #ifdef WITH_TESTS
156 
157 #include <cpptools/cpptoolstestcase.h>
158 #include <cpptools/projectinfo.h>
159 
160 #include <utils/executeondestruction.h>
161 
162 #include <QTest>
163 #include <QSignalSpy>
164 #include <QTestEventLoop>
165 
166 //#define WITH_BENCHMARK
167 #ifdef WITH_BENCHMARK
168 #include <valgrind/callgrind.h>
169 #endif
170 
171 #endif // WITH_TESTS
172 
173 #include <climits>
174 
175 #define DEBUG_STATE 1
176 #ifdef DEBUG_STATE
177 //#   define STATE_DEBUG(s)
178 //    do { QString msg; QTextStream ts(&msg); ts << s;
179 //      showMessage(msg, LogDebug); } while (0)
180 #   define STATE_DEBUG(s) do { qDebug() << s; } while (0)
181 #else
182 #   define STATE_DEBUG(s)
183 #endif
184 
185 /*!
186     \namespace Debugger
187     Debugger plugin namespace
188 */
189 
190 /*!
191     \namespace Debugger::Internal
192     Internal namespace of the Debugger plugin
193     \internal
194 */
195 
196 /*!
197     \class Debugger::DebuggerEngine
198 
199     \brief The DebuggerEngine class is the base class of a debugger engine.
200 
201     \note The Debugger process itself and any helper processes like
202     gdbserver are referred to as 'Engine', whereas the debugged process
203     is referred to as 'Inferior'.
204 
205     Transitions marked by '---' are done in the individual engines.
206     Transitions marked by '+-+' are done in the base DebuggerEngine.
207     Transitions marked by '*' are done asynchronously.
208 
209     The GdbEngine->setupEngine() function is described in more detail below.
210 
211     The engines are responsible for local roll-back to the last
212     acknowledged state before calling notify*Failed. I.e. before calling
213     notifyEngineSetupFailed() any process started during setupEngine()
214     so far must be terminated.
215     \code
216 
217                         DebuggerNotReady
218                          progressmanager/progressmanager.cpp      +
219                       EngineSetupRequested
220                                +
221                   (calls *Engine->setupEngine())
222                             |      |
223                             |      |
224                        {notify-  {notify-
225                         Engine-   Engine-
226                         SetupOk}  SetupFailed}
227                             +      +
228                             +      `+-+-+> EngineSetupFailed
229                             +                   +
230                             +    [calls RunControl->startFailed]
231                             +                   +
232                             +             DebuggerFinished
233                             v
234                       EngineSetupOk
235                             +
236              [calls RunControl->StartSuccessful]
237                             +
238                   InferiorSetupRequested
239                             +
240              (calls *Engine->setupInferior())
241                          |       |
242                          |       |
243                     {notify-   {notify-
244                      Inferior- Inferior-
245                      SetupOk}  SetupFailed}
246                          +       +
247                          +       ` +-+-> InferiorSetupFailed +-+-+-+-+-+->.
248                          +                                                +
249                   InferiorSetupOk                                         +
250                          +                                                +
251                   EngineRunRequested                                      +
252                          +                                                +
253                  (calls *Engine->runEngine())                             +
254                /       |            |        \                            +
255              /         |            |          \                          +
256             | (core)   | (attach)   |           |                         +
257             |          |            |           |                         +
258       {notify-    {notifyER&- {notifyER&-  {notify-                       +
259       Inferior-     Inferior-   Inferior-  EngineRun-                     +
260      Unrunnable}     StopOk}     RunOk}     Failed}                       +
261            +           +            +           +                         +
262    InferiorUnrunnable  +     InferiorRunOk      +                         +
263                        +                        +                         +
264                 InferiorStopOk            EngineRunFailed                 +
265                                                 +                         v
266                                                  `-+-+-+-+-+-+-+-+-+-+-+>-+
267                                                                           +
268                                                                           +
269                        #Interrupt@InferiorRunOk#                          +
270                                   +                                       +
271                           InferiorStopRequested                           +
272   #SpontaneousStop                +                                       +
273    @InferiorRunOk#         (calls *Engine->                               +
274           +               interruptInferior())                            +
275       {notify-               |          |                                 +
276      Spontaneous-       {notify-    {notify-                              +
277       Inferior-          Inferior-   Inferior-                            +
278        StopOk}           StopOk}    StopFailed}                           +
279            +              +             +                                 +
280             +            +              +                                 +
281             InferiorStopOk              +                                 +
282                   +                     +                                 +
283                   +                    +                                  +
284                   +                   +                                   +
285         #Stop@InferiorUnrunnable#    +                                    +
286           #Creator Close Event#     +                                     +
287                        +           +                                      +
288                 InferiorShutdownRequested                                 +
289                             +                                             +
290            (calls *Engine->shutdownInferior())                            +
291                          |        |                                       +
292                     {notify-   {notify-                                   +
293                      Inferior- Inferior-                                  +
294                   ShutdownOk}  ShutdownFailed}                            +
295                          +        +                                       +
296                          +        +                                       +
297   #Inferior exited#      +        +                                       +
298          |               +        +                                       +
299    {notifyInferior-      +        +                                       +
300       Exited}            +        +                                       +
301            +             +        +                                       +
302             +            +        +                                       +
303              +           +        +                                       +
304             InferiorShutdownOk InferiorShutdownFailed                     +
305                       *          *                                        +
306                   EngineShutdownRequested                                 +
307                             +                                             +
308            (calls *Engine->shutdownEngine())  <+-+-+-+-+-+-+-+-+-+-+-+-+-+'
309                          |        |
310                          |        |
311                     {notify-   {notify-
312                      Engine-    Engine-
313                   ShutdownOk}  ShutdownFailed}
314                          +       +
315             EngineShutdownOk  EngineShutdownFailed
316                          *       *
317                      DebuggerFinished
318 
319 \endcode */
320 
321 /* Here is a matching graph as a GraphViz graph. View it using
322  * \code
323 grep "^sg1:" debuggerplugin.cpp | cut -c5- | dot -osg1.ps -Tps && gv sg1.ps
324 
325 sg1: digraph DebuggerStates {
326 sg1:   DebuggerNotReady -> EngineSetupRequested
327 sg1:   EngineSetupRequested -> EngineSetupOk [ label="notifyEngineSetupOk", style="dashed" ];
328 sg1:   EngineSetupRequested -> EngineSetupFailed [ label= "notifyEngineSetupFailed", style="dashed"];
329 sg1:   EngineSetupFailed -> DebuggerFinished [ label= "RunControl::StartFailed" ];
330 sg1:   EngineSetupOk -> InferiorSetupRequested [ label= "RunControl::StartSuccessful" ];
331 sg1:   InferiorSetupRequested -> InferiorSetupOk [ label="notifyInferiorSetupOk", style="dashed" ];
332 sg1:   InferiorSetupRequested -> InferiorSetupFailed [ label="notifyInferiorFailed", style="dashed" ];
333 sg1:   InferiorSetupOk -> EngineRunRequested
334 sg1:   InferiorSetupFailed -> EngineShutdownRequested
335 sg1:   EngineRunRequested -> InferiorUnrunnable [ label="notifyInferiorUnrunnable", style="dashed" ];
336 sg1:   EngineRunRequested -> InferiorStopOk [ label="notifyEngineRunAndInferiorStopOk", style="dashed" ];
337 sg1:   EngineRunRequested -> InferiorRunOk [ label="notifyEngineRunAndInferiorRunOk", style="dashed" ];
338 sg1:   EngineRunRequested -> EngineRunFailed [ label="notifyEngineRunFailed", style="dashed" ];
339 sg1:   EngineRunFailed -> EngineShutdownRequested
340 sg1:   InferiorRunOk -> InferiorStopOk [ label="SpontaneousStop\nnotifyInferiorSpontaneousStop", style="dashed" ];
341 sg1:   InferiorRunOk -> InferiorStopRequested [ label="User stop\nEngine::interruptInferior", style="dashed"];
342 sg1:   InferiorStopRequested -> InferiorStopOk [ label="notifyInferiorStopOk", style="dashed" ];
343 sg1:   InferiorStopRequested -> InferiorShutdownRequested  [ label="notifyInferiorStopFailed", style="dashed" ];
344 sg1:   InferiorStopOk -> InferiorRunRequested [ label="User\nEngine::continueInferior" ];
345 sg1:   InferiorRunRequested -> InferiorRunOk [ label="notifyInferiorRunOk", style="dashed"];
346 sg1:   InferiorRunRequested -> InferiorRunFailed [ label="notifyInferiorRunFailed", style="dashed"];
347 sg1:   InferiorRunFailed -> InferiorStopOk
348 sg1:   InferiorStopOk -> InferiorShutdownRequested [ label="Close event" ];
349 sg1:   InferiorUnrunnable -> InferiorShutdownRequested [ label="Close event" ];
350 sg1:   InferiorShutdownRequested -> InferiorShutdownOk [ label= "Engine::shutdownInferior\nnotifyInferiorShutdownOk", style="dashed" ];
351 sg1:   InferiorShutdownRequested -> InferiorShutdownFailed [ label="Engine::shutdownInferior\nnotifyInferiorShutdownFailed", style="dashed" ];
352 sg1:   InferiorExited -> InferiorExitOk [ label="notifyInferiorExited", style="dashed"];
353 sg1:   InferiorExitOk -> InferiorShutdownOk
354 sg1:   InferiorShutdownOk -> EngineShutdownRequested
355 sg1:   InferiorShutdownFailed -> EngineShutdownRequested
356 sg1:   EngineShutdownRequested -> EngineShutdownOk [ label="Engine::shutdownEngine\nnotifyEngineShutdownOk", style="dashed" ];
357 sg1:   EngineShutdownRequested -> EngineShutdownFailed  [ label="Engine::shutdownEngine\nnotifyEngineShutdownFailed", style="dashed" ];
358 sg1:   EngineShutdownOk -> DebuggerFinished  [ style = "dotted" ];
359 sg1:   EngineShutdownFailed  -> DebuggerFinished [ style = "dotted" ];
360 sg1: }
361 * \endcode */
362 // Additional signalling:    {notifyInferiorIll}   {notifyEngineIll}
363 
364 
365 /*!
366     \class Debugger::Internal::GdbEngine
367     \brief The GdbEngine class implements Debugger::Engine driving a GDB
368     executable.
369 
370     GdbEngine specific startup. All happens in EngineSetupRequested state:
371 
372     \list
373         \li Transitions marked by '---' are done in the individual adapters.
374 
375         \li Transitions marked by '+-+' are done in the GdbEngine.
376     \endlist
377 
378     \code
379                   GdbEngine::setupEngine()
380                           +
381             (calls *Adapter->startAdapter())
382                           |      |
383                           |      `---> handleAdapterStartFailed()
384                           |                   +
385                           |             {notifyEngineSetupFailed}
386                           |
387                  handleAdapterStarted()
388                           +
389                  {notifyEngineSetupOk}
390 
391 
392 
393                 GdbEngine::setupInferior()
394                           +
395             (calls *Adapter->prepareInferior())
396                           |      |
397                           |      `---> handlePrepareInferiorFailed()
398                           |                   +
399                           |             {notifyInferiorSetupFailed}
400                           |
401                 handleInferiorPrepared()
402                           +
403                 {notifyInferiorSetupOk}
404 
405 \endcode */
406 
407 using namespace Core;
408 using namespace Core::Constants;
409 using namespace Debugger::Constants;
410 using namespace Debugger::Internal;
411 using namespace ExtensionSystem;
412 using namespace ProjectExplorer;
413 using namespace TextEditor;
414 using namespace Utils;
415 
416 namespace CC = Core::Constants;
417 namespace PE = ProjectExplorer::Constants;
418 
419 namespace Debugger {
420 namespace Internal {
421 
422 void addCdbOptionPages(QList<IOptionsPage*> *opts);
423 void addGdbOptionPages(QList<IOptionsPage*> *opts);
424 QObject *createDebuggerRunControlFactory(QObject *parent);
425 
426 static QIcon visibleStartIcon(Id id, bool toolBarStyle)
427 {
428     if (id == Id(Constants::DEBUG)) {
429         const static QIcon sidebarIcon =
430                 Icon::sideBarIcon(ProjectExplorer::Icons::DEBUG_START, ProjectExplorer::Icons::DEBUG_START_FLAT);
431         const static QIcon icon =
432                 Icon::combinedIcon({ProjectExplorer::Icons::DEBUG_START_SMALL.icon(), sidebarIcon});
433         const static QIcon iconToolBar =
434                 Icon::combinedIcon({ProjectExplorer::Icons::DEBUG_START_SMALL_TOOLBAR.icon(), sidebarIcon});
435         return toolBarStyle ? iconToolBar : icon;
436     } else if (id == Id(Constants::CONTINUE)) {
437         const static QIcon sidebarIcon =
438                 Icon::sideBarIcon(Icons::CONTINUE, Icons::CONTINUE_FLAT);
439         const static QIcon icon =
440                 Icon::combinedIcon({Icons::DEBUG_CONTINUE_SMALL.icon(), sidebarIcon});
441         const static QIcon iconToolBar =
442                 Icon::combinedIcon({Icons::DEBUG_CONTINUE_SMALL_TOOLBAR.icon(), sidebarIcon});
443         return toolBarStyle ? iconToolBar : icon;
444     } else if (id == Id(Constants::INTERRUPT)) {
445         const static QIcon sidebarIcon =
446                 Icon::sideBarIcon(Icons::INTERRUPT, Icons::INTERRUPT_FLAT);
447         const static QIcon icon =
448                 Icon::combinedIcon({Icons::DEBUG_INTERRUPT_SMALL.icon(), sidebarIcon});
449         const static QIcon iconToolBar =
450                 Icon::combinedIcon({Icons::DEBUG_INTERRUPT_SMALL_TOOLBAR.icon(), sidebarIcon});
451         return toolBarStyle ? iconToolBar : icon;
452     }
453     return QIcon();
454 }
455 
456 static void setProxyAction(ProxyAction *proxy, Id id)
457 {
458     proxy->setAction(ActionManager::command(id)->action());
459     proxy->setIcon(visibleStartIcon(id, true));
460 }
461 
462 QAction *addAction(QMenu *menu, const QString &display, bool on,
463                    const std::function<void()> &onTriggered)
464 {
465     QAction *act = menu->addAction(display);
466     act->setEnabled(on);
467     QObject::connect(act, &QAction::triggered, onTriggered);
468     return act;
469 };
470 
471 QAction *addAction(QMenu *menu, const QString &d1, const QString &d2, bool on,
472                    const std::function<void()> &onTriggered)
473 {
474     return on ? addAction(menu, d1, true, onTriggered) : addAction(menu, d2, false);
475 };
476 
477 QAction *addCheckableAction(QMenu *menu, const QString &display, bool on, bool checked,
478                             const std::function<void()> &onTriggered)
479 {
480     QAction *act = addAction(menu, display, on, onTriggered);
481     act->setCheckable(true);
482     act->setChecked(checked);
483     return act;
484 }
485 
486 ///////////////////////////////////////////////////////////////////////
487 //
488 // DummyEngine
489 //
490 ///////////////////////////////////////////////////////////////////////
491 
492 class DummyEngine : public DebuggerEngine
493 {
494 public:
495     DummyEngine() {}
496     ~DummyEngine() override {}
497 
498     void setupEngine() override {}
499     void setupInferior() override {}
500     void runEngine() override {}
501     void shutdownEngine() override {}
502     void shutdownInferior() override {}
503     bool hasCapability(unsigned cap) const override;
504     bool acceptsBreakpoint(Breakpoint) const override { return false; }
505     bool acceptsDebuggerCommands() const override { return false; }
506     void selectThread(ThreadId) override {}
507 };
508 
509 bool DummyEngine::hasCapability(unsigned cap) const
510 {
511     // This can only be a first approximation of what to expect when running.
512     Project *project = ProjectTree::currentProject();
513     if (!project)
514         return 0;
515     Target *target = project->activeTarget();
516     QTC_ASSERT(target, return 0);
517     RunConfiguration *activeRc = target->activeRunConfiguration();
518     QTC_ASSERT(activeRc, return 0);
519 
520     // This is a non-started Cdb or Gdb engine:
521     if (activeRc->extraAspect<Debugger::DebuggerRunConfigurationAspect>()->useCppDebugger())
522         return cap & (WatchpointByAddressCapability
523                | BreakConditionCapability
524                | TracePointCapability
525                | OperateByInstructionCapability);
526 
527     // This is a Qml or unknown engine.
528     return cap & AddWatcherCapability;
529 }
530 
531 ///////////////////////////////////////////////////////////////////////
532 //
533 // DebugMode
534 //
535 ///////////////////////////////////////////////////////////////////////
536 
537 class DebugModeContext : public IContext
538 {
539 public:
540     DebugModeContext(QWidget *modeWindow)
541     {
542         setContext(Context(CC::C_EDITORMANAGER));
543         setWidget(modeWindow);
544         ICore::addContextObject(this);
545     }
546 };
547 
548 class DebugMode : public IMode
549 {
550 public:
551     DebugMode()
552     {
553         setObjectName(QLatin1String("DebugMode"));
554         setContext(Context(C_DEBUGMODE, CC::C_NAVIGATION_PANE));
555         setDisplayName(DebuggerPlugin::tr("Debug"));
556         setIcon(Utils::Icon::modeIcon(Icons::MODE_DEBUGGER_CLASSIC,
557                                       Icons::MODE_DEBUGGER_FLAT, Icons::MODE_DEBUGGER_FLAT_ACTIVE));
558         setPriority(85);
559         setId(MODE_DEBUG);
560     }
561 };
562 
563 ///////////////////////////////////////////////////////////////////////
564 //
565 // Misc
566 //
567 ///////////////////////////////////////////////////////////////////////
568 
569 static QWidget *addSearch(BaseTreeView *treeView, const QString &title,
570     const QString &objectName)
571 {
572     QAction *act = action(UseAlternatingRowColors);
573     treeView->setAlternatingRowColors(act->isChecked());
574     QObject::connect(act, &QAction::toggled,
575                      treeView, &BaseTreeView::setAlternatingRowColors);
576 
577     QWidget *widget = ItemViewFind::createSearchableWrapper(treeView);
578     widget->setObjectName(objectName);
579     widget->setWindowTitle(title);
580     return widget;
581 }
582 
583 static Kit::Predicate cdbPredicate(char wordWidth = 0)
584 {
585     return [wordWidth](const Kit *k) -> bool {
586         if (DebuggerKitInformation::engineType(k) != CdbEngineType
587             || DebuggerKitInformation::configurationErrors(k)) {
588             return false;
589         }
590         if (wordWidth)
591             return ToolChainKitInformation::targetAbi(k).wordWidth() == wordWidth;
592         return true;
593     };
594 }
595 
596 // Find a CDB kit for debugging unknown processes.
597 // On a 64bit OS, prefer a 64bit debugger.
598 static Kit *findUniversalCdbKit()
599 {
600     if (Utils::is64BitWindowsSystem()) {
601         if (Kit *cdb64Kit = KitManager::kit(cdbPredicate(64)))
602             return cdb64Kit;
603     }
604     return KitManager::kit(cdbPredicate());
605 }
606 
607 ///////////////////////////////////////////////////////////////////////
608 //
609 // DebuggerPluginPrivate
610 //
611 ///////////////////////////////////////////////////////////////////////
612 
613 static DebuggerPluginPrivate *dd = 0;
614 
615 //class DockWidgetEventFilter : public QObject
616 //{
617 //public:
618 //    DockWidgetEventFilter() {}
619 
620 //private:
621 //    bool eventFilter(QObject *obj, QEvent *event) override;
622 //};
623 
624 /*!
625     \class Debugger::Internal::DebuggerCore
626 
627     This is the "internal" interface of the debugger plugin that's
628     used by debugger views and debugger engines. The interface is
629     implemented in DebuggerPluginPrivate.
630 */
631 
632 /*!
633     \class Debugger::Internal::DebuggerPluginPrivate
634 
635     Implementation of DebuggerCore.
636 */
637 
638 class DebuggerPluginPrivate : public QObject
639 {
640     Q_OBJECT
641 
642 public:
643     explicit DebuggerPluginPrivate(DebuggerPlugin *plugin);
644     ~DebuggerPluginPrivate();
645 
646     bool initialize(const QStringList &arguments, QString *errorMessage);
647     void extensionsInitialized();
648     void aboutToShutdown();
649 
650     void connectEngine(DebuggerEngine *engine);
651     void disconnectEngine() { connectEngine(0); }
652     DebuggerEngine *dummyEngine();
653 
654     void setThreadBoxContents(const QStringList &list, int index)
655     {
656         const bool state = m_threadBox->blockSignals(true);
657         m_threadBox->clear();
658         foreach (const QString &item, list)
659             m_threadBox->addItem(item);
660         m_threadBox->setCurrentIndex(index);
661         m_threadBox->blockSignals(state);
662     }
663 
664     RunControl *attachToRunningProcess(Kit *kit, DeviceProcessItem process, bool contAfterAttach);
665 
666     void writeSettings()
667     {
668         m_debuggerSettings->writeSettings();
669 //        writeWindowSettings();
670     }
671 
672     void selectThread(int index)
673     {
674         ThreadId id = m_currentEngine->threadsHandler()->threadAt(index);
675         m_currentEngine->selectThread(id);
676     }
677 
678     void breakpointSetMarginActionTriggered(bool isMessageOnly, const ContextData &data)
679     {
680         QString message;
681         if (isMessageOnly) {
682             if (data.type == LocationByAddress) {
683                 //: Message tracepoint: Address hit.
684                 message = tr("0x%1 hit").arg(data.address, 0, 16);
685             } else {
686                 //: Message tracepoint: %1 file, %2 line %3 function hit.
687                 message = tr("%1:%2 %3() hit").arg(FileName::fromString(data.fileName).fileName()).
688                         arg(data.lineNumber).
689                         arg(cppFunctionAt(data.fileName, data.lineNumber));
690             }
691             QInputDialog dialog; // Create wide input dialog.
692             dialog.setWindowFlags(dialog.windowFlags()
693               & ~(Qt::WindowContextHelpButtonHint|Qt::MSWindowsFixedSizeDialogHint));
694             dialog.resize(600, dialog.height());
695             dialog.setWindowTitle(tr("Add Message Tracepoint"));
696             dialog.setLabelText (tr("Message:"));
697             dialog.setTextValue(message);
698             if (dialog.exec() != QDialog::Accepted || dialog.textValue().isEmpty())
699                 return;
700             message = dialog.textValue();
701         }
702         toggleBreakpoint(data, message);
703     }
704 
705     void updateWatchersHeader(int section, int, int newSize)
706     {
707         if (m_shuttingDown)
708             return;
709 
710         m_watchersView->header()->resizeSection(section, newSize);
711         m_returnView->header()->resizeSection(section, newSize);
712     }
713 
714     void synchronizeBreakpoints()
715     {
716         showMessage(QLatin1String("ATTEMPT SYNC"), LogDebug);
717         for (int i = 0, n = m_snapshotHandler->size(); i != n; ++i) {
718             if (DebuggerEngine *engine = m_snapshotHandler->at(i)->engine())
719                 engine->attemptBreakpointSynchronization();
720         }
721     }
722 
723     void reloadSourceFiles() { if (m_currentEngine) m_currentEngine->reloadSourceFiles(); }
724     void reloadRegisters() { if (m_currentEngine) m_currentEngine->reloadRegisters(); }
725     void reloadModules() { if (m_currentEngine) m_currentEngine->reloadModules(); }
726 
727     void editorOpened(IEditor *editor);
728     void updateBreakMenuItem(IEditor *editor);
729     void setBusyCursor(bool busy);
730     void requestMark(TextEditorWidget *widget, int lineNumber,
731                      TextMarkRequestKind kind);
732     void requestContextMenu(TextEditorWidget *widget,
733                             int lineNumber, QMenu *menu);
734 
735     void activatePreviousMode();
736     void activateDebugMode();
737     void toggleBreakpointHelper();
738     void toggleBreakpoint(const ContextData &location, const QString &tracePointMessage = QString());
739     void onModeChanged(Id mode);
740     void updateDebugWithoutDeployMenu();
741 
742     void startAndDebugApplication();
743     void startRemoteCdbSession();
744     void startRemoteServerAndAttachToProcess();
745     void attachToRemoteServer();
746     void attachToRunningApplication();
747     void attachToUnstartedApplicationDialog();
748     void attachToQmlPort();
749     void runScheduled();
750     void attachCore();
751 
752     void enableReverseDebuggingTriggered(const QVariant &value);
753     void showStatusMessage(const QString &msg, int timeout = -1);
754 
755     void runControlStarted(DebuggerRunTool *runTool);
756     void runControlFinished(DebuggerRunTool *runTool);
757     void remoteCommand(const QStringList &options);
758 
759     void displayDebugger(DebuggerEngine *engine, bool updateEngine = true);
760 
761     void dumpLog();
762     void cleanupViews();
763     void setInitialState();
764 
765     void fontSettingsChanged(const FontSettings &settings);
766 
767     void updateState(DebuggerEngine *engine);
768     void onCurrentProjectChanged(Project *project);
769 
770     void sessionLoaded();
771     void aboutToUnloadSession();
772     void aboutToSaveSession();
773 
774     void coreShutdown();
775 
776 public:
777     void updateDebugActions();
778 
779     void handleExecDetach()
780     {
781         currentEngine()->resetLocation();
782         currentEngine()->detachDebugger();
783     }
784 
785     void handleExecContinue()
786     {
787         currentEngine()->resetLocation();
788         currentEngine()->continueInferior();
789     }
790 
791     void handleExecInterrupt()
792     {
793         currentEngine()->resetLocation();
794         currentEngine()->requestInterruptInferior();
795     }
796 
797     void handleAbort()
798     {
799         currentEngine()->resetLocation();
800         currentEngine()->abortDebugger();
801     }
802 
803     void handleReset()
804     {
805         currentEngine()->resetLocation();
806         currentEngine()->resetInferior();
807     }
808 
809     void handleExecStep()
810     {
811         if (currentEngine()->state() == DebuggerNotReady) {
812             ProjectExplorerPlugin::runStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE_WITH_BREAK_ON_MAIN);
813         } else {
814             currentEngine()->resetLocation();
815             if (boolSetting(OperateByInstruction))
816                 currentEngine()->executeStepI();
817             else
818                 currentEngine()->executeStep();
819         }
820     }
821 
822     void handleExecNext()
823     {
824         if (currentEngine()->state() == DebuggerNotReady) {
825             ProjectExplorerPlugin::runStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE_WITH_BREAK_ON_MAIN);
826         } else {
827             currentEngine()->resetLocation();
828             if (boolSetting(OperateByInstruction))
829                 currentEngine()->executeNextI();
830             else
831                 currentEngine()->executeNext();
832         }
833     }
834 
835     void handleExecStepOut()
836     {
837         currentEngine()->resetLocation();
838         currentEngine()->executeStepOut();
839     }
840 
841     void handleExecReturn()
842     {
843         currentEngine()->resetLocation();
844         currentEngine()->executeReturn();
845     }
846 
847     void handleExecJumpToLine()
848     {
849         currentEngine()->resetLocation();
850         if (BaseTextEditor *textEditor = BaseTextEditor::currentTextEditor()) {
851             ContextData location = getLocationContext(textEditor->textDocument(),
852                                                       textEditor->currentLine());
853             if (location.isValid())
854                 currentEngine()->executeJumpToLine(location);
855         }
856     }
857 
858     void handleExecRunToLine()
859     {
860         currentEngine()->resetLocation();
861         if (BaseTextEditor *textEditor = BaseTextEditor::currentTextEditor()) {
862             ContextData location = getLocationContext(textEditor->textDocument(),
863                                                       textEditor->currentLine());
864             if (location.isValid())
865                 currentEngine()->executeRunToLine(location);
866         }
867     }
868 
869     void handleExecRunToSelectedFunction()
870     {
871         BaseTextEditor *textEditor = BaseTextEditor::currentTextEditor();
872         QTC_ASSERT(textEditor, return);
873         QTextCursor cursor = textEditor->textCursor();
874         QString functionName = cursor.selectedText();
875         if (functionName.isEmpty()) {
876             const QTextBlock block = cursor.block();
877             const QString line = block.text();
878             foreach (const QString &str, line.trimmed().split(QLatin1Char('('))) {
879                 QString a;
880                 for (int i = str.size(); --i >= 0; ) {
881                     if (!str.at(i).isLetterOrNumber())
882                         break;
883                     a = str.at(i) + a;
884                 }
885                 if (!a.isEmpty()) {
886                     functionName = a;
887                     break;
888                 }
889             }
890         }
891 
892         if (functionName.isEmpty()) {
893             showStatusMessage(tr("No function selected."));
894         } else {
895             showStatusMessage(tr("Running to function \"%1\".")
896                 .arg(functionName));
897             currentEngine()->resetLocation();
898             currentEngine()->executeRunToFunction(functionName);
899         }
900     }
901 
902     void handleAddToWatchWindow()
903     {
904         // Requires a selection, but that's the only case we want anyway.
905         BaseTextEditor *textEditor = BaseTextEditor::currentTextEditor();
906         if (!textEditor)
907             return;
908         QTextCursor tc = textEditor->textCursor();
909         QString exp;
910         if (tc.hasSelection()) {
911             exp = tc.selectedText();
912         } else {
913             int line, column;
914             exp = cppExpressionAt(textEditor->editorWidget(), tc.position(), &line, &column);
915         }
916         if (currentEngine()->hasCapability(WatchComplexExpressionsCapability))
917             exp = removeObviousSideEffects(exp);
918         else
919             exp = fixCppExpression(exp);
920         exp = exp.trimmed();
921         if (exp.isEmpty()) {
922             // Happens e.g. when trying to evaluate 'char' or 'return'.
923             AsynchronousMessageBox::warning(tr("Warning"),
924                 tr("Select a valid expression to evaluate."));
925             return;
926         }
927         currentEngine()->watchHandler()->watchVariable(exp);
928     }
929 
930     void handleExecExit()
931     {
932         currentEngine()->exitDebugger();
933     }
934 
935     void handleFrameDown()
936     {
937         currentEngine()->frameDown();
938     }
939 
940     void handleFrameUp()
941     {
942         currentEngine()->frameUp();
943     }
944 
945     void handleOperateByInstructionTriggered(bool operateByInstructionTriggered)
946     {
947         // Go to source only if we have the file.
948         if (DebuggerEngine *cppEngine = currentEngine()->cppEngine()) {
949             if (cppEngine->stackHandler()->currentIndex() >= 0) {
950                 const StackFrame frame = cppEngine->stackHandler()->currentFrame();
951                 if (operateByInstructionTriggered || frame.isUsable())
952                     cppEngine->gotoLocation(Location(frame, true));
953             }
954         }
955     }
956 
957     void showMessage(const QString &msg, int channel, int timeout = -1);
958 
959     bool parseArgument(QStringList::const_iterator &it,
960         const QStringList::const_iterator &cend, QString *errorMessage);
961     bool parseArguments(const QStringList &args, QString *errorMessage);
962     void parseCommandLineArguments();
963 
964     // Called when all dependent plugins have loaded.
965     void initialize();
966 
967     void updateUiForProject(ProjectExplorer::Project *project);
968     void updateUiForTarget(ProjectExplorer::Target *target);
969     void updateActiveLanguages();
970 
971 public:
972     QPointer<DebuggerMainWindow> m_mainWindow;
973     QPointer<QWidget> m_modeWindow;
974     QPointer<DebugMode> m_mode;
975 
976     QHash<Id, RunControlCreator> m_runControlCreators;
977     ActionContainer *m_menu = 0;
978 
979 //    DockWidgetEventFilter m_resizeEventFilter;
980 
981     QHash<DebuggerLanguage, Core::Context> m_contextsForLanguage;
982 
983     Project *m_previousProject = 0;
984     QPointer<Target> m_previousTarget;
985     QPointer<RunConfiguration> m_previousRunConfiguration;
986 
987     Id m_previousMode;
988     QVector<QPair<DebuggerRunParameters, Kit *>> m_scheduledStarts;
989 
990     ProxyAction *m_visibleStartAction = 0;
991     ProxyAction *m_hiddenStopAction = 0;
992     QAction *m_startAction = 0;
993     QAction *m_debugWithoutDeployAction = 0;
994     QAction *m_startAndDebugApplicationAction = 0;
995     QAction *m_startRemoteServerAction = 0;
996     QAction *m_attachToRunningApplication = 0;
997     QAction *m_attachToUnstartedApplication = 0;
998     QAction *m_attachToQmlPortAction = 0;
999     QAction *m_attachToRemoteServerAction = 0;
1000     QAction *m_startRemoteCdbAction = 0;
1001     QAction *m_attachToCoreAction = 0;
1002     QAction *m_detachAction = 0;
1003     QAction *m_continueAction = 0;
1004     QAction *m_exitAction = 0; // On application output button if "Stop" is possible
1005     QAction *m_interruptAction = 0; // On the fat debug button if "Pause" is possible
1006     QAction *m_undisturbableAction = 0; // On the fat debug button if nothing can be done
1007     QAction *m_abortAction = 0;
1008     QAction *m_stepAction = 0;
1009     QAction *m_stepOutAction = 0;
1010     QAction *m_runToLineAction = 0; // In the debug menu
1011     QAction *m_runToSelectedFunctionAction = 0;
1012     QAction *m_jumpToLineAction = 0; // In the Debug menu.
1013     QAction *m_returnFromFunctionAction = 0;
1014     QAction *m_nextAction = 0;
1015     QAction *m_watchAction = 0;
1016     Command *m_watchCommand = 0;
1017     QAction *m_breakAction = 0;
1018     QAction *m_reverseDirectionAction = 0;
1019     QAction *m_frameUpAction = 0;
1020     QAction *m_frameDownAction = 0;
1021     QAction *m_resetAction = 0;
1022     QAction *m_operateByInstructionAction = 0;
1023 
1024     QToolButton *m_reverseToolButton = 0;
1025 
1026     QLabel *m_threadLabel = 0;
1027     QComboBox *m_threadBox = 0;
1028 
1029     BaseTreeView *m_breakView = 0;
1030     BaseTreeView *m_returnView = 0;
1031     BaseTreeView *m_localsView = 0;
1032     BaseTreeView *m_watchersView = 0;
1033     WatchTreeView *m_inspectorView = 0;
1034     BaseTreeView *m_registerView = 0;
1035     BaseTreeView *m_modulesView = 0;
1036     BaseTreeView *m_snapshotView = 0;
1037     BaseTreeView *m_sourceFilesView = 0;
1038     BaseTreeView *m_stackView = 0;
1039     BaseTreeView *m_threadsView = 0;
1040 
1041     QWidget *m_breakWindow = 0;
1042     BreakHandler *m_breakHandler = 0;
1043     QWidget *m_returnWindow = 0;
1044     QWidget *m_localsWindow = 0;
1045     QWidget *m_watchersWindow = 0;
1046     QWidget *m_inspectorWindow = 0;
1047     QWidget *m_registerWindow = 0;
1048     QWidget *m_modulesWindow = 0;
1049     QWidget *m_snapshotWindow = 0;
1050     QWidget *m_sourceFilesWindow = 0;
1051     QWidget *m_stackWindow = 0;
1052     QWidget *m_threadsWindow = 0;
1053     LogWindow *m_logWindow = 0;
1054     LocalsAndExpressionsWindow *m_localsAndExpressionsWindow = 0;
1055 
1056     bool m_busy;
1057     QString m_lastPermanentStatusMessage;
1058 
1059     mutable CPlusPlus::Snapshot m_codeModelSnapshot;
1060     DebuggerPlugin *m_plugin = 0;
1061 
1062     SnapshotHandler *m_snapshotHandler = 0;
1063     bool m_shuttingDown = false;
1064     QPointer<DebuggerEngine> m_currentEngine;
1065     DebuggerSettings *m_debuggerSettings = 0;
1066     QStringList m_arguments;
1067     DebuggerToolTipManager m_toolTipManager;
1068     CommonOptionsPage *m_commonOptionsPage = 0;
1069     DummyEngine *m_dummyEngine = 0;
1070     const QSharedPointer<GlobalDebuggerOptions> m_globalDebuggerOptions;
1071 };
1072 
1073 DebuggerPluginPrivate::DebuggerPluginPrivate(DebuggerPlugin *plugin)
1074     : m_globalDebuggerOptions(new GlobalDebuggerOptions)
1075 {
1076     qRegisterMetaType<ContextData>("ContextData");
1077     qRegisterMetaType<DebuggerRunParameters>("DebuggerRunParameters");
1078 
1079     QTC_CHECK(!dd);
1080     dd = this;
1081 
1082     m_plugin = plugin;
1083 
1084 //    m_toolBars.insert(CppLanguage, 0);
1085 //    m_toolBars.insert(QmlLanguage, 0);
1086     m_contextsForLanguage.insert(CppLanguage, Context(C_CPPDEBUGGER));
1087     m_contextsForLanguage.insert(QmlLanguage, Context(C_QMLDEBUGGER));
1088 }
1089 
1090 DebuggerPluginPrivate::~DebuggerPluginPrivate()
1091 {
1092     delete m_debuggerSettings;
1093     m_debuggerSettings = 0;
1094 
1095     delete m_snapshotHandler;
1096     m_snapshotHandler = 0;
1097 
1098     delete m_breakHandler;
1099     m_breakHandler = 0;
1100 }
1101 
1102 DebuggerEngine *DebuggerPluginPrivate::dummyEngine()
1103 {
1104     if (!m_dummyEngine) {
1105         m_dummyEngine = new DummyEngine;
1106         m_dummyEngine->setParent(this);
1107         m_dummyEngine->setObjectName("DummyEngine");
1108     }
1109     return m_dummyEngine;
1110 }
1111 
1112 static QString msgParameterMissing(const QString &a)
1113 {
1114     return DebuggerPlugin::tr("Option \"%1\" is missing the parameter.").arg(a);
1115 }
1116 
1117 static Kit *guessKitFromParameters(const DebuggerRunParameters &rp)
1118 {
1119     Kit *kit = 0;
1120 
1121     // Try to find a kit via ABI.
1122     QList<Abi> abis;
1123     if (rp.toolChainAbi.isValid())
1124         abis.push_back(rp.toolChainAbi);
1125     else if (!rp.inferior.executable.isEmpty())
1126         abis = Abi::abisOfBinary(FileName::fromString(rp.inferior.executable));
1127 
1128     if (!abis.isEmpty()) {
1129         // Try exact abis.
1130         kit = KitManager::kit([abis](const Kit *k) {
1131             const Abi tcAbi = ToolChainKitInformation::targetAbi(k);
1132             return abis.contains(tcAbi) && !DebuggerKitInformation::configurationErrors(k);
1133         });
1134         if (!kit) {
1135             // Or something compatible.
1136             kit = KitManager::kit([abis](const Kit *k) {
1137                 const Abi tcAbi = ToolChainKitInformation::targetAbi(k);
1138                 return !DebuggerKitInformation::configurationErrors(k)
1139                         && Utils::contains(abis, [tcAbi](const Abi &a) { return a.isCompatibleWith(tcAbi); });
1140             });
1141         }
1142     }
1143 
1144     if (!kit)
1145         kit = KitManager::defaultKit();
1146 
1147     return kit;
1148 }
1149 
1150 bool DebuggerPluginPrivate::parseArgument(QStringList::const_iterator &it,
1151     const QStringList::const_iterator &cend, QString *errorMessage)
1152 {
1153     const QString &option = *it;
1154     // '-debug <pid>'
1155     // '-debug <exe>[,server=<server:port>][,core=<core>][,kit=<kit>][,terminal={0,1}]'
1156     if (*it == "-debug") {
1157         ++it;
1158         if (it == cend) {
1159             *errorMessage = msgParameterMissing(*it);
1160             return false;
1161         }
1162         Kit *kit = 0;
1163         DebuggerRunParameters rp;
1164         qulonglong pid = it->toULongLong();
1165         if (pid) {
1166             rp.startMode = AttachExternal;
1167             rp.closeMode = DetachAtClose;
1168             rp.attachPID = ProcessHandle(pid);
1169             rp.displayName = tr("Process %1").arg(rp.attachPID.pid());
1170             rp.startMessage = tr("Attaching to local process %1.").arg(rp.attachPID.pid());
1171         } else {
1172             rp.startMode = StartExternal;
1173             QStringList args = it->split(QLatin1Char(','));
1174             foreach (const QString &arg, args) {
1175                 QString key = arg.section(QLatin1Char('='), 0, 0);
1176                 QString val = arg.section(QLatin1Char('='), 1, 1);
1177                 if (val.isEmpty()) {
1178                     if (key.isEmpty()) {
1179                         continue;
1180                     } else if (rp.inferior.executable.isEmpty()) {
1181                         rp.inferior.executable = key;
1182                     } else {
1183                         *errorMessage = DebuggerPlugin::tr("Only one executable allowed.");
1184                         return false;
1185                     }
1186                 }
1187                 if (key == QLatin1String("server")) {
1188                     rp.startMode = AttachToRemoteServer;
1189                     rp.remoteChannel = val;
1190                     rp.displayName = tr("Remote: \"%1\"").arg(rp.remoteChannel);
1191                     rp.startMessage = tr("Attaching to remote server %1.").arg(rp.remoteChannel);
1192                 } else if (key == QLatin1String("core")) {
1193                     rp.startMode = AttachCore;
1194                     rp.closeMode = DetachAtClose;
1195                     rp.coreFile = val;
1196                     rp.displayName = tr("Core file \"%1\"").arg(rp.coreFile);
1197                     rp.startMessage = tr("Attaching to core file %1.").arg(rp.coreFile);
1198                 } else if (key == QLatin1String("terminal")) {
1199                     rp.useTerminal = bool(val.toInt());
1200                 } else if (key == QLatin1String("kit")) {
1201                     kit = KitManager::kit(Id::fromString(val));
1202                 }
1203             }
1204         }
1205         if (rp.startMode == StartExternal) {
1206             rp.displayName = tr("Executable file \"%1\"").arg(rp.inferior.executable);
1207             rp.startMessage = tr("Debugging file %1.").arg(rp.inferior.executable);
1208         }
1209         rp.inferior.environment = Utils::Environment::systemEnvironment();
1210         rp.stubEnvironment = Utils::Environment::systemEnvironment();
1211         rp.debugger.environment = Utils::Environment::systemEnvironment();
1212 
1213         if (!kit)
1214             kit = guessKitFromParameters(rp);
1215         m_scheduledStarts.append(QPair<DebuggerRunParameters, Kit *>(rp, kit));
1216         return true;
1217     }
1218     // -wincrashevent <event-handle>:<pid>. A handle used for
1219     // a handshake when attaching to a crashed Windows process.
1220     // This is created by $QTC/src/tools/qtcdebugger/main.cpp:
1221     // args << QLatin1String("-wincrashevent")
1222     //   << QString::fromLatin1("%1:%2").arg(argWinCrashEvent).arg(argProcessId);
1223     if (*it == "-wincrashevent") {
1224         ++it;
1225         if (it == cend) {
1226             *errorMessage = msgParameterMissing(*it);
1227             return false;
1228         }
1229         DebuggerRunParameters rp;
1230         rp.startMode = AttachCrashedExternal;
1231         rp.crashParameter = it->section(QLatin1Char(':'), 0, 0);
1232         rp.attachPID = ProcessHandle(it->section(QLatin1Char(':'), 1, 1).toULongLong());
1233         rp.displayName = tr("Crashed process %1").arg(rp.attachPID.pid());
1234         rp.startMessage = tr("Attaching to crashed process %1").arg(rp.attachPID.pid());
1235         if (!rp.attachPID.isValid()) {
1236             *errorMessage = DebuggerPlugin::tr("The parameter \"%1\" of option \"%2\" "
1237                 "does not match the pattern <handle>:<pid>.").arg(*it, option);
1238             return false;
1239         }
1240         m_scheduledStarts.append(QPair<DebuggerRunParameters, Kit *>(rp, findUniversalCdbKit()));
1241         return true;
1242     }
1243 
1244     *errorMessage = DebuggerPlugin::tr("Invalid debugger option: %1").arg(option);
1245     return false;
1246 }
1247 
1248 bool DebuggerPluginPrivate::parseArguments(const QStringList &args,
1249     QString *errorMessage)
1250 {
1251     const QStringList::const_iterator cend = args.constEnd();
1252     for (QStringList::const_iterator it = args.constBegin(); it != cend; ++it)
1253         if (!parseArgument(it, cend, errorMessage))
1254             return false;
1255     return true;
1256 }
1257 
1258 void DebuggerPluginPrivate::parseCommandLineArguments()
1259 {
1260     QString errorMessage;
1261     if (!parseArguments(m_arguments, &errorMessage)) {
1262         errorMessage = tr("Error evaluating command line arguments: %1")
1263             .arg(errorMessage);
1264         qWarning("%s\n", qPrintable(errorMessage));
1265         MessageManager::write(errorMessage);
1266     }
1267     if (!m_scheduledStarts.isEmpty())
1268         QTimer::singleShot(0, this, &DebuggerPluginPrivate::runScheduled);
1269 }
1270 
1271 bool DebuggerPluginPrivate::initialize(const QStringList &arguments,
1272     QString *errorMessage)
1273 {
1274     Q_UNUSED(errorMessage);
1275     m_arguments = arguments;
1276     if (!m_arguments.isEmpty())
1277         connect(ProjectExplorerPlugin::instance(), &ProjectExplorerPlugin::finishedInitialization,
1278                 this, &DebuggerPluginPrivate::parseCommandLineArguments);
1279 
1280     m_mainWindow = new DebuggerMainWindow;
1281 
1282     // Menus
1283     m_menu = ActionManager::createMenu(M_DEBUG_ANALYZER);
1284     m_menu->menu()->setTitle(tr("&Analyze"));
1285     m_menu->menu()->setEnabled(true);
1286 
1287     m_menu->appendGroup(G_ANALYZER_CONTROL);
1288     m_menu->appendGroup(G_ANALYZER_TOOLS);
1289     m_menu->appendGroup(G_ANALYZER_REMOTE_TOOLS);
1290     m_menu->appendGroup(G_ANALYZER_OPTIONS);
1291 
1292     ActionContainer *menubar = ActionManager::actionContainer(MENU_BAR);
1293     ActionContainer *mtools = ActionManager::actionContainer(M_TOOLS);
1294     menubar->addMenu(mtools, m_menu);
1295 
1296     m_menu->addSeparator(G_ANALYZER_TOOLS);
1297     m_menu->addSeparator(G_ANALYZER_REMOTE_TOOLS);
1298     m_menu->addSeparator(G_ANALYZER_OPTIONS);
1299 
1300     // Populate Windows->Views menu with standard actions.
1301     Context debugcontext(Constants::C_DEBUGMODE);
1302 
1303     auto openMemoryEditorAction = new QAction(this);
1304     openMemoryEditorAction->setText(DebuggerPluginPrivate::tr("Memory..."));
1305     connect(openMemoryEditorAction, &QAction::triggered,
1306             this, &Internal::openMemoryEditor);
1307 
1308     Command *cmd = ActionManager::registerAction(openMemoryEditorAction,
1309         "Debugger.Views.OpenMemoryEditor", debugcontext);
1310     cmd->setAttribute(Command::CA_Hide);
1311 
1312     m_plugin->addAutoReleasedObject(debuggerConsole());
1313 
1314     TaskHub::addCategory(TASK_CATEGORY_DEBUGGER_DEBUGINFO,
1315                          tr("Debug Information"));
1316     TaskHub::addCategory(TASK_CATEGORY_DEBUGGER_RUNTIME,
1317                          tr("Debugger Runtime"));
1318 
1319     const QKeySequence debugKey = QKeySequence(UseMacShortcuts ? tr("Ctrl+Y") : tr("F5"));
1320 
1321     QSettings *settings = ICore::settings();
1322 
1323     m_debuggerSettings = new DebuggerSettings;
1324     m_debuggerSettings->readSettings();
1325 
1326     connect(ICore::instance(), &ICore::coreAboutToClose, this, &DebuggerPluginPrivate::coreShutdown);
1327 
1328     const Context cppDebuggercontext(C_CPPDEBUGGER);
1329     const Context qmljsDebuggercontext(C_QMLDEBUGGER);
1330 
1331     m_busy = false;
1332 
1333     m_logWindow = new LogWindow;
1334     m_logWindow->setObjectName(QLatin1String(DOCKWIDGET_OUTPUT));
1335 
1336     m_breakHandler = new BreakHandler;
1337     m_breakView = new BaseTreeView;
1338     m_breakView->setIconSize(QSize(10, 10));
1339     m_breakView->setWindowIcon(Icons::BREAKPOINTS.icon());
1340     m_breakView->setSelectionMode(QAbstractItemView::ExtendedSelection);
1341     connect(action(UseAddressInBreakpointsView), &QAction::toggled,
1342             this, [this](bool on) { m_breakView->setColumnHidden(BreakpointAddressColumn, !on); });
1343     m_breakView->setSettings(settings, "Debugger.BreakWindow");
1344     m_breakView->setModel(m_breakHandler->model());
1345     m_breakWindow = addSearch(m_breakView, tr("Breakpoints"), DOCKWIDGET_BREAK);
1346 
1347     m_modulesView = new BaseTreeView;
1348     m_modulesView->setSortingEnabled(true);
1349     m_modulesView->setSettings(settings, "Debugger.ModulesView");
1350     connect(m_modulesView, &BaseTreeView::aboutToShow,
1351             this, &DebuggerPluginPrivate::reloadModules,
1352             Qt::QueuedConnection);
1353     m_modulesWindow = addSearch(m_modulesView, tr("Modules"), DOCKWIDGET_MODULES);
1354 
1355     m_registerView = new BaseTreeView;
1356     m_registerView->setRootIsDecorated(true);
1357     m_registerView->setSettings(settings, "Debugger.RegisterView");
1358     connect(m_registerView, &BaseTreeView::aboutToShow,
1359             this, &DebuggerPluginPrivate::reloadRegisters,
1360             Qt::QueuedConnection);
1361     m_registerWindow = addSearch(m_registerView, tr("Registers"), DOCKWIDGET_REGISTER);
1362 
1363     m_stackView = new StackTreeView;
1364     m_stackView->setSettings(settings, "Debugger.StackView");
1365     m_stackView->setIconSize(QSize(10, 10));
1366     m_stackWindow = addSearch(m_stackView, tr("Stack"), DOCKWIDGET_STACK);
1367 
1368     m_sourceFilesView = new BaseTreeView;
1369     m_sourceFilesView->setSortingEnabled(true);
1370     m_sourceFilesView->setSettings(settings, "Debugger.SourceFilesView");
1371     connect(m_sourceFilesView, &BaseTreeView::aboutToShow,
1372             this, &DebuggerPluginPrivate::reloadSourceFiles,
1373             Qt::QueuedConnection);
1374     m_sourceFilesWindow = addSearch(m_sourceFilesView, tr("Source Files"), DOCKWIDGET_SOURCE_FILES);
1375 
1376     m_threadsView = new BaseTreeView;
1377     m_threadsView->setSortingEnabled(true);
1378     m_threadsView->setSettings(settings, "Debugger.ThreadsView");
1379     m_threadsView->setIconSize(QSize(10, 10));
1380     m_threadsWindow = addSearch(m_threadsView, tr("Threads"), DOCKWIDGET_THREADS);
1381 
1382     m_returnView = new WatchTreeView(ReturnType); // No settings.
1383     m_returnWindow = addSearch(m_returnView, tr("Locals and Expressions"), "CppDebugReturn");
1384 
1385     m_localsView = new WatchTreeView(LocalsType);
1386     m_localsView->setSettings(settings, "Debugger.LocalsView");
1387     m_localsWindow = addSearch(m_localsView, tr("Locals and Expressions"), "CppDebugLocals");
1388 
1389     m_watchersView = new WatchTreeView(WatchersType); // No settings.
1390     m_watchersWindow = addSearch(m_watchersView, tr("Locals and Expressions"), "CppDebugWatchers");
1391 
1392     m_inspectorView = new WatchTreeView(InspectType);
1393     m_inspectorView->setSettings(settings, "Debugger.LocalsView"); // sic! same as locals view.
1394     m_inspectorWindow = addSearch(m_inspectorView, tr("Locals and Expressions"), "Inspector");
1395 
1396     // Snapshot
1397     m_snapshotHandler = new SnapshotHandler;
1398     m_snapshotView = new SnapshotTreeView(m_snapshotHandler);
1399     m_snapshotView->setSettings(settings, "Debugger.SnapshotView");
1400     m_snapshotView->setIconSize(QSize(10, 10));
1401     m_snapshotView->setModel(m_snapshotHandler->model());
1402     m_snapshotWindow = addSearch(m_snapshotView, tr("Snapshots"), DOCKWIDGET_SNAPSHOTS);
1403 
1404     // Watchers
1405     connect(m_localsView->header(), &QHeaderView::sectionResized,
1406         this, &DebuggerPluginPrivate::updateWatchersHeader, Qt::QueuedConnection);
1407 
1408     auto act = m_continueAction = new QAction(tr("Continue"), this);
1409     act->setIcon(visibleStartIcon(Id(Constants::CONTINUE), false));
1410     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecContinue);
1411 
1412     act = m_exitAction = new QAction(tr("Stop Debugger"), this);
1413     act->setIcon(Icons::DEBUG_EXIT_SMALL.icon());
1414     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecExit);
1415 
1416     act = m_interruptAction = new QAction(tr("Interrupt"), this);
1417     act->setIcon(visibleStartIcon(Id(Constants::INTERRUPT), false));
1418     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecInterrupt);
1419 
1420     // A "disabled pause" seems to be a good choice.
1421     act = m_undisturbableAction = new QAction(tr("Debugger is Busy"), this);
1422     act->setIcon(visibleStartIcon(Id(Constants::INTERRUPT), false));
1423     act->setEnabled(false);
1424 
1425     act = m_abortAction = new QAction(tr("Abort Debugging"), this);
1426     act->setToolTip(tr("Aborts debugging and "
1427         "resets the debugger to the initial state."));
1428     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleAbort);
1429 
1430     act = m_resetAction = new QAction(tr("Restart Debugging"),this);
1431     act->setToolTip(tr("Restart the debugging session."));
1432     act->setIcon(Icons::RESTART_TOOLBAR.icon());
1433     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleReset);
1434 
1435     act = m_nextAction = new QAction(tr("Step Over"), this);
1436     act->setIcon(Icons::STEP_OVER.icon());
1437     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecNext);
1438 
1439     act = m_stepAction = new QAction(tr("Step Into"), this);
1440     act->setIcon(Icons::STEP_INTO.icon());
1441     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecStep);
1442 
1443     act = m_stepOutAction = new QAction(tr("Step Out"), this);
1444     act->setIcon(Icons::STEP_OUT.icon());
1445     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecStepOut);
1446 
1447     act = m_runToLineAction = new QAction(tr("Run to Line"), this);
1448     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecRunToLine);
1449 
1450     act = m_runToSelectedFunctionAction = new QAction(tr("Run to Selected Function"), this);
1451     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecRunToSelectedFunction);
1452 
1453     act = m_returnFromFunctionAction =
1454         new QAction(tr("Immediately Return From Inner Function"), this);
1455     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecReturn);
1456 
1457     act = m_jumpToLineAction = new QAction(tr("Jump to Line"), this);
1458     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecJumpToLine);
1459 
1460     m_breakAction = new QAction(tr("Toggle Breakpoint"), this);
1461 
1462     act = m_watchAction = new QAction(tr("Add Expression Evaluator"), this);
1463     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleAddToWatchWindow);
1464 
1465     //act = m_snapshotAction = new QAction(tr("Create Snapshot"), this);
1466     //act->setProperty(Role, RequestCreateSnapshotRole);
1467     //act->setIcon(Icons::SNAPSHOT.icon());
1468 
1469     act = m_reverseDirectionAction = new QAction(tr("Reverse Direction"), this);
1470     act->setCheckable(true);
1471     act->setChecked(false);
1472     act->setCheckable(false);
1473     act->setIcon(Icons::REVERSE_MODE.icon());
1474     act->setIconVisibleInMenu(false);
1475 
1476     act = m_frameDownAction = new QAction(tr("Move to Called Frame"), this);
1477     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleFrameDown);
1478 
1479     act = m_frameUpAction = new QAction(tr("Move to Calling Frame"), this);
1480     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleFrameUp);
1481 
1482     act = m_operateByInstructionAction = action(OperateByInstruction);
1483     connect(act, &QAction::triggered,
1484             this, &DebuggerPluginPrivate::handleOperateByInstructionTriggered);
1485 
1486     ActionContainer *debugMenu = ActionManager::actionContainer(PE::M_DEBUG);
1487 
1488     m_localsAndExpressionsWindow = new LocalsAndExpressionsWindow(
1489                 m_localsWindow, m_inspectorWindow, m_returnWindow, m_watchersWindow);
1490     m_localsAndExpressionsWindow->setObjectName(QLatin1String(DOCKWIDGET_WATCHERS));
1491     m_localsAndExpressionsWindow->setWindowTitle(m_localsWindow->windowTitle());
1492 
1493     m_plugin->addAutoReleasedObject(createDebuggerRunControlFactory(m_plugin));
1494 
1495     // The main "Start Debugging" action.
1496     act = m_startAction = new QAction(this);
1497     act->setIcon(visibleStartIcon(Id(Constants::DEBUG), false));
1498     act->setText(tr("Start Debugging"));
1499     connect(act, &QAction::triggered, [] { ProjectExplorerPlugin::runStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE); });
1500 
1501     act = m_debugWithoutDeployAction = new QAction(this);
1502     act->setText(tr("Start Debugging Without Deployment"));
1503     connect(act, &QAction::triggered, [] { ProjectExplorerPlugin::runStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE, true); });
1504 
1505     act = m_startAndDebugApplicationAction = new QAction(this);
1506     act->setText(tr("Start and Debug External Application..."));
1507     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::startAndDebugApplication);
1508 
1509     act = m_attachToCoreAction = new QAction(this);
1510     act->setText(tr("Load Core File..."));
1511     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::attachCore);
1512 
1513     act = m_attachToRemoteServerAction = new QAction(this);
1514     act->setText(tr("Attach to Running Debug Server..."));
1515     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::attachToRemoteServer);
1516 
1517     act = m_startRemoteServerAction = new QAction(this);
1518     act->setText(tr("Start Debug Server Attached to Process..."));
1519     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::startRemoteServerAndAttachToProcess);
1520 
1521     act = m_attachToRunningApplication = new QAction(this);
1522     act->setText(tr("Attach to Running Application..."));
1523     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::attachToRunningApplication);
1524 
1525     act = m_attachToUnstartedApplication = new QAction(this);
1526     act->setText(tr("Attach to Unstarted Application..."));
1527     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::attachToUnstartedApplicationDialog);
1528 
1529     act = m_attachToQmlPortAction = new QAction(this);
1530     act->setText(tr("Attach to QML Port..."));
1531     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::attachToQmlPort);
1532 
1533     if (HostOsInfo::isWindowsHost()) {
1534         m_startRemoteCdbAction = new QAction(tr("Attach to Remote CDB Session..."), this);
1535         connect(m_startRemoteCdbAction, &QAction::triggered,
1536                 this, &DebuggerPluginPrivate::startRemoteCdbSession);
1537     }
1538 
1539     act = m_detachAction = new QAction(this);
1540     act->setText(tr("Detach Debugger"));
1541     connect(act, &QAction::triggered, this, &DebuggerPluginPrivate::handleExecDetach);
1542 
1543     // "Start Debugging" sub-menu
1544     // groups:
1545     //   G_DEFAULT_ONE
1546     //   G_START_LOCAL
1547     //   G_START_REMOTE
1548     //   G_START_QML
1549 
1550     ActionContainer *mstart = ActionManager::actionContainer(PE::M_DEBUG_STARTDEBUGGING);
1551 
1552     cmd = ActionManager::registerAction(m_startAction, Constants::DEBUG);
1553     cmd->setDescription(tr("Start Debugging"));
1554     cmd->setDefaultKeySequence(debugKey);
1555     cmd->setAttribute(Command::CA_UpdateText);
1556     mstart->addAction(cmd, CC::G_DEFAULT_ONE);
1557     m_visibleStartAction = new ProxyAction(this);
1558     m_visibleStartAction->initialize(m_startAction);
1559     m_visibleStartAction->setAttribute(ProxyAction::UpdateText);
1560     m_visibleStartAction->setAction(m_startAction);
1561 
1562     ModeManager::addAction(m_visibleStartAction, Constants::P_ACTION_DEBUG);
1563 
1564     cmd = ActionManager::registerAction(m_debugWithoutDeployAction,
1565         "Debugger.DebugWithoutDeploy");
1566     cmd->setAttribute(Command::CA_Hide);
1567     mstart->addAction(cmd, CC::G_DEFAULT_ONE);
1568 
1569     cmd = ActionManager::registerAction(m_attachToRunningApplication,
1570          "Debugger.AttachToRemoteProcess");
1571     cmd->setDescription(tr("Attach to Running Application"));
1572     mstart->addAction(cmd, G_GENERAL);
1573 
1574     cmd = ActionManager::registerAction(m_attachToUnstartedApplication,
1575           "Debugger.AttachToUnstartedProcess");
1576     cmd->setDescription(tr("Attach to Unstarted Application"));
1577     mstart->addAction(cmd, G_GENERAL);
1578 
1579     cmd = ActionManager::registerAction(m_startAndDebugApplicationAction,
1580         "Debugger.StartAndDebugApplication");
1581     cmd->setAttribute(Command::CA_Hide);
1582     mstart->addAction(cmd, G_GENERAL);
1583 
1584     cmd = ActionManager::registerAction(m_attachToCoreAction,
1585         "Debugger.AttachCore");
1586     cmd->setAttribute(Command::CA_Hide);
1587     mstart->addAction(cmd, Constants::G_GENERAL);
1588 
1589     cmd = ActionManager::registerAction(m_attachToRemoteServerAction,
1590         "Debugger.AttachToRemoteServer");
1591     cmd->setAttribute(Command::CA_Hide);
1592     mstart->addAction(cmd, Constants::G_SPECIAL);
1593 
1594     cmd = ActionManager::registerAction(m_startRemoteServerAction,
1595          "Debugger.StartRemoteServer");
1596     cmd->setDescription(tr("Start Gdbserver"));
1597     mstart->addAction(cmd, Constants::G_SPECIAL);
1598 
1599     if (m_startRemoteCdbAction) {
1600         cmd = ActionManager::registerAction(m_startRemoteCdbAction,
1601              "Debugger.AttachRemoteCdb");
1602         cmd->setAttribute(Command::CA_Hide);
1603         mstart->addAction(cmd, Constants::G_SPECIAL);
1604     }
1605 
1606     mstart->addSeparator(Context(CC::C_GLOBAL), Constants::G_START_QML);
1607 
1608     cmd = ActionManager::registerAction(m_attachToQmlPortAction, "Debugger.AttachToQmlPort");
1609     cmd->setAttribute(Command::CA_Hide);
1610     mstart->addAction(cmd, Constants::G_START_QML);
1611 
1612     cmd = ActionManager::registerAction(m_detachAction, "Debugger.Detach");
1613     cmd->setAttribute(Command::CA_Hide);
1614     debugMenu->addAction(cmd, CC::G_DEFAULT_ONE);
1615 
1616     cmd = ActionManager::registerAction(m_interruptAction, Constants::INTERRUPT);
1617     cmd->setDescription(tr("Interrupt Debugger"));
1618     debugMenu->addAction(cmd, CC::G_DEFAULT_ONE);
1619 
1620     cmd = ActionManager::registerAction(m_continueAction, Constants::CONTINUE);
1621     cmd->setDefaultKeySequence(debugKey);
1622     debugMenu->addAction(cmd, CC::G_DEFAULT_ONE);
1623 
1624     cmd = ActionManager::registerAction(m_exitAction, Constants::STOP);
1625     debugMenu->addAction(cmd, CC::G_DEFAULT_ONE);
1626     m_hiddenStopAction = new ProxyAction(this);
1627     m_hiddenStopAction->initialize(cmd->action());
1628     m_hiddenStopAction->setAttribute(ProxyAction::UpdateText);
1629     m_hiddenStopAction->setAttribute(ProxyAction::UpdateIcon);
1630 
1631     cmd = ActionManager::registerAction(m_hiddenStopAction, Constants::HIDDEN_STOP);
1632     cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? tr("Shift+Ctrl+Y") : tr("Shift+F5")));
1633 
1634     cmd = ActionManager::registerAction(m_abortAction, Constants::ABORT);
1635     cmd->setDescription(tr("Reset Debugger"));
1636     debugMenu->addAction(cmd, CC::G_DEFAULT_ONE);
1637 
1638     cmd = ActionManager::registerAction(m_resetAction, Constants::RESET);
1639     cmd->setDescription(tr("Restart Debugging"));
1640     debugMenu->addAction(cmd, CC::G_DEFAULT_ONE);
1641 
1642     debugMenu->addSeparator();
1643 
1644     cmd = ActionManager::registerAction(m_nextAction, Constants::NEXT);
1645     cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? tr("Ctrl+Shift+O") : tr("F10")));
1646     cmd->setAttribute(Command::CA_Hide);
1647     cmd->setAttribute(Command::CA_UpdateText);
1648     debugMenu->addAction(cmd);
1649 
1650     cmd = ActionManager::registerAction(m_stepAction, Constants::STEP);
1651     cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? tr("Ctrl+Shift+I") : tr("F11")));
1652     cmd->setAttribute(Command::CA_Hide);
1653     cmd->setAttribute(Command::CA_UpdateText);
1654     debugMenu->addAction(cmd);
1655 
1656     cmd = ActionManager::registerAction(m_stepOutAction, Constants::STEPOUT);
1657     cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? tr("Ctrl+Shift+T") : tr("Shift+F11")));
1658     cmd->setAttribute(Command::CA_Hide);
1659     debugMenu->addAction(cmd);
1660 
1661     cmd = ActionManager::registerAction(m_runToLineAction,
1662         "Debugger.RunToLine", cppDebuggercontext);
1663     cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? tr("Shift+F8") : tr("Ctrl+F10")));
1664     cmd->setAttribute(Command::CA_Hide);
1665     debugMenu->addAction(cmd);
1666 
1667     cmd = ActionManager::registerAction(m_runToSelectedFunctionAction,
1668         "Debugger.RunToSelectedFunction", cppDebuggercontext);
1669     cmd->setDefaultKeySequence(QKeySequence(tr("Ctrl+F6")));
1670     cmd->setAttribute(Command::CA_Hide);
1671     // Don't add to menu by default as keeping its enabled state
1672     // and text up-to-date is a lot of hassle.
1673     // debugMenu->addAction(cmd);
1674 
1675     cmd = ActionManager::registerAction(m_jumpToLineAction,
1676         "Debugger.JumpToLine", cppDebuggercontext);
1677     cmd->setAttribute(Command::CA_Hide);
1678     debugMenu->addAction(cmd);
1679 
1680     cmd = ActionManager::registerAction(m_returnFromFunctionAction,
1681         "Debugger.ReturnFromFunction", cppDebuggercontext);
1682     cmd->setAttribute(Command::CA_Hide);
1683     debugMenu->addAction(cmd);
1684 
1685     if (isReverseDebuggingEnabled()) {
1686         cmd = ActionManager::registerAction(m_reverseDirectionAction,
1687                                             Constants::REVERSE, cppDebuggercontext);
1688         cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? QString() : tr("F12")));
1689         cmd->setAttribute(Command::CA_Hide);
1690         debugMenu->addAction(cmd);
1691     }
1692 
1693     debugMenu->addSeparator();
1694 
1695     //cmd = ActionManager::registerAction(m_snapshotAction,
1696     //    "Debugger.Snapshot", cppDebuggercontext);
1697     //cmd->setDefaultKeySequence(QKeySequence(tr("Ctrl+D,Ctrl+S")));
1698     //cmd->setAttribute(Command::CA_Hide);
1699     //debugMenu->addAction(cmd);
1700 
1701     ActionManager::registerAction(m_frameDownAction,
1702         "Debugger.FrameDown", cppDebuggercontext);
1703     ActionManager::registerAction(m_frameUpAction,
1704         "Debugger.FrameUp", cppDebuggercontext);
1705 
1706     cmd = ActionManager::registerAction(m_operateByInstructionAction,
1707         Constants::OPERATE_BY_INSTRUCTION, cppDebuggercontext);
1708     cmd->setAttribute(Command::CA_Hide);
1709     debugMenu->addAction(cmd);
1710 
1711     cmd = ActionManager::registerAction(m_breakAction, "Debugger.ToggleBreak");
1712     cmd->setDefaultKeySequence(QKeySequence(UseMacShortcuts ? tr("F8") : tr("F9")));
1713     debugMenu->addAction(cmd);
1714     connect(m_breakAction, &QAction::triggered,
1715         this, &DebuggerPluginPrivate::toggleBreakpointHelper);
1716 
1717     debugMenu->addSeparator();
1718 
1719     // currently broken
1720 //    auto qmlUpdateOnSaveDummyAction = new QAction(tr("Apply Changes on Save"), this);
1721 //    qmlUpdateOnSaveDummyAction->setCheckable(true);
1722 //    qmlUpdateOnSaveDummyAction->setIcon(Icons::APPLY_ON_SAVE.icon());
1723 //    qmlUpdateOnSaveDummyAction->setEnabled(false);
1724 //    cmd = ActionManager::registerAction(qmlUpdateOnSaveDummyAction, Constants::QML_UPDATE_ON_SAVE);
1725 //    debugMenu->addAction(cmd);
1726 
1727     auto qmlShowAppOnTopDummyAction = new QAction(tr("Show Application on Top"), this);
1728     qmlShowAppOnTopDummyAction->setCheckable(true);
1729     qmlShowAppOnTopDummyAction->setIcon(Icons::APP_ON_TOP.icon());
1730     qmlShowAppOnTopDummyAction->setEnabled(false);
1731     cmd = ActionManager::registerAction(qmlShowAppOnTopDummyAction, Constants::QML_SHOW_APP_ON_TOP);
1732     debugMenu->addAction(cmd);
1733 
1734     auto qmlSelectDummyAction = new QAction(tr("Select"), this);
1735     qmlSelectDummyAction->setCheckable(true);
1736     qmlSelectDummyAction->setIcon(Icons::SELECT.icon());
1737     qmlSelectDummyAction->setEnabled(false);
1738     cmd = ActionManager::registerAction(qmlSelectDummyAction, Constants::QML_SELECTTOOL);
1739     debugMenu->addAction(cmd);
1740 
1741     debugMenu->addSeparator();
1742 
1743     cmd = m_watchCommand = ActionManager::registerAction(m_watchAction, "Debugger.AddToWatch",
1744             Context(CppEditor::Constants::CPPEDITOR_ID,  QmlJSEditor::Constants::C_QMLJSEDITOR_ID));
1745     //cmd->setDefaultKeySequence(QKeySequence(tr("Ctrl+D,Ctrl+W")));
1746     debugMenu->addAction(cmd);
1747 
1748     QList<IOptionsPage *> engineOptionPages;
1749     addGdbOptionPages(&engineOptionPages);
1750     addCdbOptionPages(&engineOptionPages);
1751 
1752     foreach (IOptionsPage *op, engineOptionPages)
1753         m_plugin->addAutoReleasedObject(op);
1754     m_plugin->addAutoReleasedObject(new LocalsAndExpressionsOptionsPage);
1755 
1756     connect(ModeManager::instance(), &ModeManager::currentModeChanged,
1757         this, &DebuggerPluginPrivate::onModeChanged);
1758     connect(ModeManager::instance(), &ModeManager::currentModeChanged,
1759             m_mainWindow.data(), &DebuggerMainWindow::onModeChanged);
1760     connect(ProjectExplorerPlugin::instance(), &ProjectExplorerPlugin::settingsChanged,
1761         this, &DebuggerPluginPrivate::updateDebugWithoutDeployMenu);
1762 
1763     m_mainWindow->finalizeSetup();
1764 
1765     // Debug mode setup
1766     m_mode = new DebugMode;
1767     m_modeWindow = createModeWindow(Constants::MODE_DEBUG, m_mainWindow);
1768     m_mode->setWidget(m_modeWindow);
1769 
1770     m_plugin->addAutoReleasedObject(new DebugModeContext(m_modeWindow));
1771 
1772     m_plugin->addObject(m_mode);
1773 
1774 
1775     connect(SessionManager::instance(), &SessionManager::startupProjectChanged,
1776             this, &DebuggerPluginPrivate::updateUiForProject);
1777 
1778     //
1779     //  Connections
1780     //
1781 
1782     // Core
1783     connect(ICore::instance(), &ICore::saveSettingsRequested,
1784             this, &DebuggerPluginPrivate::writeSettings);
1785 
1786     // TextEditor
1787     connect(TextEditorSettings::instance(), &TextEditorSettings::fontSettingsChanged,
1788             this, &DebuggerPluginPrivate::fontSettingsChanged);
1789 
1790     // ProjectExplorer
1791     connect(SessionManager::instance(), &SessionManager::sessionLoaded,
1792             this, &DebuggerPluginPrivate::sessionLoaded);
1793     connect(SessionManager::instance(), &SessionManager::aboutToSaveSession,
1794             this, &DebuggerPluginPrivate::aboutToSaveSession);
1795     connect(SessionManager::instance(), &SessionManager::aboutToUnloadSession,
1796             this, &DebuggerPluginPrivate::aboutToUnloadSession);
1797     connect(ProjectExplorerPlugin::instance(), &ProjectExplorerPlugin::updateRunActions,
1798             this, &DebuggerPluginPrivate::updateDebugActions);
1799 
1800     // EditorManager
1801     connect(EditorManager::instance(), &EditorManager::editorOpened,
1802             this, &DebuggerPluginPrivate::editorOpened);
1803     connect(EditorManager::instance(), &EditorManager::currentEditorChanged,
1804             this, &DebuggerPluginPrivate::updateBreakMenuItem);
1805 
1806     // Application interaction
1807     connect(action(SettingsDialog), &QAction::triggered,
1808             [] { ICore::showOptionsDialog(DEBUGGER_COMMON_SETTINGS_ID); });
1809 
1810     // Toolbar
1811     ToolbarDescription toolbar;
1812     toolbar.addAction(m_visibleStartAction);
1813     toolbar.addAction(ActionManager::command(Constants::STOP)->action(), Icons::DEBUG_EXIT_SMALL_TOOLBAR.icon());
1814     toolbar.addAction(ActionManager::command(Constants::NEXT)->action(), Icons::STEP_OVER_TOOLBAR.icon());
1815     toolbar.addAction(ActionManager::command(Constants::STEP)->action(), Icons::STEP_INTO_TOOLBAR.icon());
1816     toolbar.addAction(ActionManager::command(Constants::STEPOUT)->action(), Icons::STEP_OUT_TOOLBAR.icon());
1817     toolbar.addAction(ActionManager::command(Constants::RESET)->action(), Icons::RESTART_TOOLBAR.icon());
1818     toolbar.addAction(ActionManager::command(Constants::OPERATE_BY_INSTRUCTION)->action());
1819 
1820     if (isReverseDebuggingEnabled()) {
1821         m_reverseToolButton = new QToolButton;
1822         m_reverseToolButton->setDefaultAction(m_reverseDirectionAction);
1823         toolbar.addWidget(m_reverseToolButton);
1824     }
1825 
1826     toolbar.addWidget(new StyledSeparator);
1827 
1828     m_threadLabel = new QLabel(tr("Threads:"));
1829     toolbar.addWidget(m_threadLabel);
1830 
1831     m_threadBox = new QComboBox;
1832     m_threadBox->setSizeAdjustPolicy(QComboBox::AdjustToContents);
1833     connect(m_threadBox, static_cast<void(QComboBox::*)(int)>(&QComboBox::activated),
1834             this, &DebuggerPluginPrivate::selectThread);
1835 
1836     toolbar.addWidget(m_threadBox);
1837 //    toolbar.addSpacerItem(new QSpacerItem(4, 0));
1838 
1839 //    ToolbarDescription qmlToolbar
1840 //    qmlToolbar.addAction(qmlUpdateOnSaveDummyAction);
1841 //    qmlToolbar.addAction(qmlShowAppOnTopDummyAction, Icons::APP_ON_TOP_TOOLBAR.icon());
1842 //    qmlToolbar.addWidget(new StyledSeparator);
1843 //    qmlToolbar.addAction(qmlSelectDummyAction, Icons::SELECT_TOOLBAR.icon());
1844 //    qmlToolbar.addWidget(new StyledSeparator);
1845 
1846     auto createBasePerspective = [this] { return new Perspective({}, {
1847         {DOCKWIDGET_STACK, m_stackWindow, {}, Perspective::SplitVertical},
1848         {DOCKWIDGET_BREAK, m_breakWindow, DOCKWIDGET_STACK, Perspective::SplitHorizontal},
1849         {DOCKWIDGET_THREADS, m_threadsWindow, DOCKWIDGET_BREAK, Perspective::AddToTab, false},
1850         {DOCKWIDGET_MODULES, m_modulesWindow, DOCKWIDGET_THREADS, Perspective::AddToTab, false},
1851         {DOCKWIDGET_SOURCE_FILES, m_sourceFilesWindow, DOCKWIDGET_MODULES, Perspective::AddToTab, false},
1852         {DOCKWIDGET_SNAPSHOTS, m_snapshotWindow, DOCKWIDGET_SOURCE_FILES, Perspective::AddToTab, false},
1853         {DOCKWIDGET_WATCHERS, m_localsAndExpressionsWindow, {}, Perspective::AddToTab, true,
1854          Qt::RightDockWidgetArea},
1855         {DOCKWIDGET_OUTPUT, m_logWindow, {}, Perspective::AddToTab, false, Qt::TopDockWidgetArea},
1856         {DOCKWIDGET_BREAK, 0, {}, Perspective::Raise}
1857     }); };
1858 
1859     Perspective *cppPerspective = createBasePerspective();
1860     cppPerspective->setName(tr("Debugger"));
1861     cppPerspective->addOperation({DOCKWIDGET_REGISTER, m_registerWindow, DOCKWIDGET_SNAPSHOTS,
1862                                   Perspective::AddToTab, false});
1863 
1864     Debugger::registerToolbar(CppPerspectiveId, toolbar);
1865     Debugger::registerPerspective(CppPerspectiveId, cppPerspective);
1866 
1867 //    Perspective *qmlPerspective = createBasePerspective();
1868 //    qmlPerspective->setName(tr("QML Debugger"));
1869 //    qmlPerspective->addOperation({ DOCKWIDGET_REGISTER, DOCKWIDGET_SNAPSHOTS,
1870 //                                  Perspective::AddToTab, false });
1871 //
1872 //    Debugger::registerToolbar(QmlPerspectiveId, toolbarContainer);
1873 //    Debugger::registerPerspective(QmlPerspectiveId, qmlPerspective);
1874 
1875     connect(action(EnableReverseDebugging), &SavedAction::valueChanged,
1876             this, &DebuggerPluginPrivate::enableReverseDebuggingTriggered);
1877 
1878     setInitialState();
1879     connectEngine(0);
1880 
1881     connect(SessionManager::instance(), &SessionManager::startupProjectChanged,
1882         this, &DebuggerPluginPrivate::onCurrentProjectChanged);
1883 
1884     m_commonOptionsPage = new CommonOptionsPage(m_globalDebuggerOptions);
1885     m_plugin->addAutoReleasedObject(m_commonOptionsPage);
1886 
1887     m_globalDebuggerOptions->fromSettings();
1888     m_watchersWindow->setVisible(false);
1889     m_returnWindow->setVisible(false);
1890 
1891     return true;
1892 }
1893 
1894 void setConfigValue(const QString &name, const QVariant &value)
1895 {
1896     ICore::settings()->setValue("DebugMode/" + name, value);
1897 }
1898 
1899 QVariant configValue(const QString &name)
1900 {
1901     return ICore::settings()->value("DebugMode/" + name);
1902 }
1903 
1904 void DebuggerPluginPrivate::onCurrentProjectChanged(Project *project)
1905 {
1906     RunConfiguration *activeRc = 0;
1907     if (project) {
1908         Target *target = project->activeTarget();
1909         if (target)
1910             activeRc = target->activeRunConfiguration();
1911         if (!activeRc)
1912             return;
1913     }
1914     for (int i = 0, n = m_snapshotHandler->size(); i != n; ++i) {
1915         // Run controls might be deleted during exit.
1916         if (DebuggerRunTool *runTool = m_snapshotHandler->at(i)) {
1917             if (RunControl *runControl = runTool->runControl()) {
1918                 RunConfiguration *rc = runControl->runConfiguration();
1919                 if (rc == activeRc) {
1920                     m_snapshotHandler->setCurrentIndex(i);
1921                     updateState(runTool->engine());
1922                     return;
1923                 }
1924             }
1925         }
1926     }
1927 
1928     // If we have a running debugger, don't touch it.
1929     if (m_snapshotHandler->size())
1930         return;
1931 
1932     // No corresponding debugger found. So we are ready to start one.
1933     m_interruptAction->setEnabled(false);
1934     m_continueAction->setEnabled(false);
1935     m_exitAction->setEnabled(false);
1936     QString whyNot;
1937     const bool canRun = ProjectExplorerPlugin::canRunStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE, &whyNot);
1938     m_startAction->setEnabled(canRun);
1939     m_startAction->setToolTip(whyNot);
1940     m_debugWithoutDeployAction->setEnabled(canRun);
1941     setProxyAction(m_visibleStartAction, Id(Constants::DEBUG));
1942 }
1943 
1944 void DebuggerPluginPrivate::startAndDebugApplication()
1945 {
1946     DebuggerRunParameters rp;
1947     Kit *kit;
1948     if (StartApplicationDialog::run(ICore::dialogParent(), &rp, &kit))
1949         createAndScheduleRun(rp, kit);
1950 }
1951 
1952 void DebuggerPluginPrivate::attachCore()
1953 {
1954     AttachCoreDialog dlg(ICore::dialogParent());
1955 
1956     const QString lastExternalKit = configValue("LastExternalKit").toString();
1957     if (!lastExternalKit.isEmpty())
1958         dlg.setKitId(Id::fromString(lastExternalKit));
1959     dlg.setLocalExecutableFile(configValue("LastExternalExecutableFile").toString());
1960     dlg.setLocalCoreFile(configValue("LastLocalCoreFile").toString());
1961     dlg.setRemoteCoreFile(configValue("LastRemoteCoreFile").toString());
1962     dlg.setOverrideStartScript(configValue("LastExternalStartScript").toString());
1963     dlg.setForceLocalCoreFile(configValue("LastForceLocalCoreFile").toBool());
1964 
1965     if (dlg.exec() != QDialog::Accepted)
1966         return;
1967 
1968     setConfigValue("LastExternalExecutableFile", dlg.localExecutableFile());
1969     setConfigValue("LastLocalCoreFile", dlg.localCoreFile());
1970     setConfigValue("LastRemoteCoreFile", dlg.remoteCoreFile());
1971     setConfigValue("LastExternalKit", dlg.kit()->id().toSetting());
1972     setConfigValue("LastExternalStartScript", dlg.overrideStartScript());
1973     setConfigValue("LastForceLocalCoreFile", dlg.forcesLocalCoreFile());
1974 
1975     QString display = dlg.useLocalCoreFile() ? dlg.localCoreFile() : dlg.remoteCoreFile();
1976     DebuggerRunParameters rp;
1977     rp.masterEngineType = DebuggerKitInformation::engineType(dlg.kit());
1978     rp.inferior.executable = dlg.localExecutableFile();
1979     rp.coreFile = dlg.localCoreFile();
1980     rp.displayName = tr("Core file \"%1\"").arg(display);
1981     rp.startMode = AttachCore;
1982     rp.closeMode = DetachAtClose;
1983     rp.overrideStartScript = dlg.overrideStartScript();
1984     createAndScheduleRun(rp, dlg.kit());
1985 }
1986 
1987 void DebuggerPluginPrivate::startRemoteCdbSession()
1988 {
1989     const QString connectionKey = "CdbRemoteConnection";
1990     DebuggerRunParameters rp;
1991     Kit *kit = findUniversalCdbKit();
1992     QTC_ASSERT(kit, return);
1993     rp.startMode = AttachToRemoteServer;
1994     rp.closeMode = KillAtClose;
1995     StartRemoteCdbDialog dlg(ICore::dialogParent());
1996     QString previousConnection = configValue(connectionKey).toString();
1997     if (previousConnection.isEmpty())
1998         previousConnection = QLatin1String("localhost:1234");
1999     dlg.setConnection(previousConnection);
2000     if (dlg.exec() != QDialog::Accepted)
2001         return;
2002     rp.remoteChannel = dlg.connection();
2003     setConfigValue(connectionKey, rp.remoteChannel);
2004     createAndScheduleRun(rp, kit);
2005 }
2006 
2007 void DebuggerPluginPrivate::attachToRemoteServer()
2008 {
2009     DebuggerRunParameters rp;
2010     Kit *kit;
2011     rp.startMode = AttachToRemoteServer;
2012     rp.useContinueInsteadOfRun = true;
2013     if (StartApplicationDialog::run(ICore::dialogParent(), &rp, &kit)) {
2014         rp.closeMode = KillAtClose;
2015         createAndScheduleRun(rp, kit);
2016     }
2017 }
2018 
2019 void DebuggerPluginPrivate::startRemoteServerAndAttachToProcess()
2020 {
2021     auto kitChooser = new DebuggerKitChooser(DebuggerKitChooser::AnyDebugging);
2022     auto dlg = new DeviceProcessesDialog(kitChooser, ICore::dialogParent());
2023     dlg->addAcceptButton(DeviceProcessesDialog::tr("&Attach to Process"));
2024     dlg->showAllDevices();
2025     if (dlg->exec() == QDialog::Rejected) {
2026         delete dlg;
2027         return;
2028     }
2029 
2030     dlg->setAttribute(Qt::WA_DeleteOnClose);
2031     Kit *kit = kitChooser->currentKit();
2032     QTC_ASSERT(kit, return);
2033     IDevice::ConstPtr device = DeviceKitInformation::device(kit);
2034     QTC_ASSERT(device, return);
2035 
2036     GdbServerStarter *starter = new GdbServerStarter(dlg, true);
2037     starter->run();
2038 }
2039 
2040 void DebuggerPluginPrivate::attachToRunningApplication()
2041 {
2042     auto kitChooser = new DebuggerKitChooser(DebuggerKitChooser::LocalDebugging);
2043 
2044     auto dlg = new DeviceProcessesDialog(kitChooser, ICore::dialogParent());
2045     dlg->addAcceptButton(DeviceProcessesDialog::tr("&Attach to Process"));
2046     dlg->showAllDevices();
2047     if (dlg->exec() == QDialog::Rejected) {
2048         delete dlg;
2049         return;
2050     }
2051 
2052     dlg->setAttribute(Qt::WA_DeleteOnClose);
2053     Kit *kit = kitChooser->currentKit();
2054     QTC_ASSERT(kit, return);
2055     IDevice::ConstPtr device = DeviceKitInformation::device(kit);
2056     QTC_ASSERT(device, return);
2057 
2058     if (device->type() == PE::DESKTOP_DEVICE_TYPE) {
2059         attachToRunningProcess(kit, dlg->currentProcess(), false);
2060     } else {
2061         GdbServerStarter *starter = new GdbServerStarter(dlg, true);
2062         starter->run();
2063     }
2064 }
2065 
2066 void DebuggerPluginPrivate::attachToUnstartedApplicationDialog()
2067 {
2068     auto dlg = new UnstartedAppWatcherDialog(ICore::dialogParent());
2069 
2070     connect(dlg, &QDialog::finished, dlg, &QObject::deleteLater);
2071     connect(dlg, &UnstartedAppWatcherDialog::processFound, this, [this, dlg] {
2072         RunControl *rc = attachToRunningProcess(dlg->currentKit(),
2073                                                 dlg->currentProcess(),
2074                                                 dlg->continueOnAttach());
2075         if (!rc)
2076             return;
2077 
2078         if (dlg->hideOnAttach())
2079             connect(rc, &RunControl::finished, dlg, &UnstartedAppWatcherDialog::startWatching);
2080     });
2081 
2082     dlg->show();
2083 }
2084 
2085 RunControl *DebuggerPluginPrivate::attachToRunningProcess(Kit *kit,
2086     DeviceProcessItem process, bool contAfterAttach)
2087 {
2088     QTC_ASSERT(kit, return 0);
2089     IDevice::ConstPtr device = DeviceKitInformation::device(kit);
2090     QTC_ASSERT(device, return 0);
2091     if (process.pid == 0) {
2092         AsynchronousMessageBox::warning(tr("Warning"), tr("Cannot attach to process with PID 0"));
2093         return 0;
2094     }
2095 
2096     const Abi tcAbi = ToolChainKitInformation::targetAbi(kit);
2097     const bool isWindows = (tcAbi.os() == Abi::WindowsOS);
2098     if (isWindows && isWinProcessBeingDebugged(process.pid)) {
2099         AsynchronousMessageBox::warning(tr("Process Already Under Debugger Control"),
2100                              tr("The process %1 is already under the control of a debugger.\n"
2101                                 "Qt Creator cannot attach to it.").arg(process.pid));
2102         return 0;
2103     }
2104 
2105     if (device->type() != PE::DESKTOP_DEVICE_TYPE) {
2106         AsynchronousMessageBox::warning(tr("Not a Desktop Device Type"),
2107                              tr("It is only possible to attach to a locally running process."));
2108         return 0;
2109     }
2110 
2111     DebuggerRunParameters rp;
2112     rp.attachPID = ProcessHandle(process.pid);
2113     rp.displayName = tr("Process %1").arg(process.pid);
2114     rp.inferior.executable = process.exe;
2115     rp.startMode = AttachExternal;
2116     rp.closeMode = DetachAtClose;
2117     rp.continueAfterAttach = contAfterAttach;
2118     return createAndScheduleRun(rp, kit);
2119 }
2120 
2121 void DebuggerPlugin::attachExternalApplication(RunControl *rc)
2122 {
2123     DebuggerRunParameters rp;
2124     rp.attachPID = rc->applicationProcessHandle();
2125     rp.displayName = tr("Process %1").arg(rp.attachPID.pid());
2126     rp.startMode = AttachExternal;
2127     rp.closeMode = DetachAtClose;
2128     rp.toolChainAbi = rc->abi();
2129     if (RunConfiguration *runConfig = rc->runConfiguration()) {
2130         auto runControl = new RunControl(runConfig, ProjectExplorer::Constants::DEBUG_RUN_MODE);
2131         (void) new DebuggerRunTool(runControl, rp);
2132         ProjectExplorerPlugin::startRunControl(runControl);
2133     } else {
2134         createAndScheduleRun(rp, guessKitFromParameters(rp));
2135     }
2136 }
2137 
2138 void DebuggerPlugin::getEnginesState(QByteArray *json) const
2139 {
2140     QTC_ASSERT(json, return);
2141     QVariantMap result {
2142         {"version", 1}
2143     };
2144     QVariantMap states;
2145 
2146     for (int i = 0; i < dd->m_snapshotHandler->size(); ++i) {
2147         const DebuggerEngine *engine = dd->m_snapshotHandler->at(i)->engine();
2148         states[QString::number(i)] = QVariantMap({
2149                    {"current", dd->m_snapshotHandler->currentIndex() == i},
2150                    {"pid", engine->inferiorPid()},
2151                    {"state", engine->state()}
2152         });
2153     }
2154 
2155     if (!states.isEmpty())
2156         result["states"] = states;
2157 
2158     *json = QJsonDocument(QJsonObject::fromVariantMap(result)).toJson();
2159 }
2160 
2161 void DebuggerPluginPrivate::attachToQmlPort()
2162 {
2163     DebuggerRunParameters rp;
2164     AttachToQmlPortDialog dlg(ICore::mainWindow());
2165 
2166     const QVariant qmlServerPort = configValue("LastQmlServerPort");
2167     if (qmlServerPort.isValid())
2168         dlg.setPort(qmlServerPort.toInt());
2169     else if (rp.qmlServer.port.isValid())
2170         dlg.setPort(rp.qmlServer.port.number());
2171     else
2172         dlg.setPort(-1);
2173 
2174     const Id kitId = Id::fromSetting(configValue("LastProfile"));
2175     if (kitId.isValid())
2176         dlg.setKitId(kitId);
2177 
2178     if (dlg.exec() != QDialog::Accepted)
2179         return;
2180 
2181     Kit *kit = dlg.kit();
2182     QTC_ASSERT(kit, return);
2183     setConfigValue("LastQmlServerPort", dlg.port());
2184     setConfigValue("LastProfile", kit->id().toSetting());
2185 
2186     IDevice::ConstPtr device = DeviceKitInformation::device(kit);
2187     if (device) {
2188         rp.connParams = device->sshParameters();
2189         Connection toolControl = device->toolControlChannel(IDevice::QmlControlChannel);
2190         QTC_ASSERT(toolControl.is<HostName>(), return);
2191         rp.qmlServer.host = toolControl.as<HostName>().host();
2192     }
2193     rp.qmlServer.port = Utils::Port(dlg.port());
2194     rp.startMode = AttachToRemoteProcess;
2195     rp.closeMode = KillAtClose;
2196     rp.languages = QmlLanguage;
2197     rp.masterEngineType = QmlEngineType;
2198 
2199     //
2200     // get files from all the projects in the session
2201     //
2202     QList<Project *> projects = SessionManager::projects();
2203     if (Project *startupProject = SessionManager::startupProject()) {
2204         // startup project first
2205         projects.removeOne(startupProject);
2206         projects.insert(0, startupProject);
2207     }
2208     QStringList sourceFiles;
2209     foreach (Project *project, projects)
2210         sourceFiles << project->files(Project::SourceFiles);
2211 
2212     rp.projectSourceDirectory =
2213             !projects.isEmpty() ? projects.first()->projectDirectory().toString() : QString();
2214     rp.projectSourceFiles = sourceFiles;
2215     createAndScheduleRun(rp, kit);
2216 }
2217 
2218 void DebuggerPluginPrivate::enableReverseDebuggingTriggered(const QVariant &value)
2219 {
2220     QTC_ASSERT(m_reverseToolButton, return);
2221     m_reverseToolButton->setVisible(value.toBool());
2222     m_reverseDirectionAction->setChecked(false);
2223     m_reverseDirectionAction->setEnabled(value.toBool());
2224 }
2225 
2226 void DebuggerPluginPrivate::runScheduled()
2227 {
2228     for (const QPair<DebuggerRunParameters, Kit *> pair : m_scheduledStarts)
2229         createAndScheduleRun(pair.first, pair.second);
2230 }
2231 
2232 void DebuggerPluginPrivate::editorOpened(IEditor *editor)
2233 {
2234     if (auto widget = qobject_cast<TextEditorWidget *>(editor->widget())) {
2235         connect(widget, &TextEditorWidget::markRequested,
2236                 this, &DebuggerPluginPrivate::requestMark);
2237 
2238         connect(widget, &TextEditorWidget::markContextMenuRequested,
2239                 this, &DebuggerPluginPrivate::requestContextMenu);
2240     }
2241 }
2242 
2243 void DebuggerPluginPrivate::updateBreakMenuItem(IEditor *editor)
2244 {
2245     BaseTextEditor *textEditor = qobject_cast<BaseTextEditor *>(editor);
2246     m_breakAction->setEnabled(textEditor != 0);
2247 }
2248 
2249 void DebuggerPluginPrivate::requestContextMenu(TextEditorWidget *widget,
2250     int lineNumber, QMenu *menu)
2251 {
2252     Breakpoint bp;
2253     TextDocument *document = widget->textDocument();
2254 
2255     ContextData args = getLocationContext(document, lineNumber);
2256     if (args.type == LocationByAddress) {
2257         BreakpointResponse needle;
2258         needle.type = BreakpointByAddress;
2259         needle.address = args.address;
2260         needle.lineNumber = -1;
2261         bp = breakHandler()->findSimilarBreakpoint(needle);
2262     } else if (args.type == LocationByFile) {
2263         bp = breakHandler()->findBreakpointByFileAndLine(args.fileName, lineNumber);
2264         if (!bp)
2265             bp = breakHandler()->findBreakpointByFileAndLine(args.fileName, lineNumber, false);
2266     }
2267 
2268     if (bp) {
2269         QString id = bp.id().toString();
2270 
2271         // Remove existing breakpoint.
2272         auto act = menu->addAction(tr("Remove Breakpoint %1").arg(id));
2273         connect(act, &QAction::triggered, [bp] { bp.removeBreakpoint(); });
2274 
2275         // Enable/disable existing breakpoint.
2276         if (bp.isEnabled()) {
2277             act = menu->addAction(tr("Disable Breakpoint %1").arg(id));
2278             connect(act, &QAction::triggered, [bp] { bp.setEnabled(false); });
2279         } else {
2280             act = menu->addAction(tr("Enable Breakpoint %1").arg(id));
2281             connect(act, &QAction::triggered, [bp] { bp.setEnabled(true); });
2282         }
2283 
2284         // Edit existing breakpoint.
2285         act = menu->addAction(tr("Edit Breakpoint %1...").arg(id));
2286         connect(act, &QAction::triggered, [bp] {
2287             breakHandler()->editBreakpoint(bp, ICore::dialogParent());
2288         });
2289 
2290     } else {
2291         // Handle non-existing breakpoint.
2292         const QString text = args.address
2293             ? tr("Set Breakpoint at 0x%1").arg(args.address, 0, 16)
2294             : tr("Set Breakpoint at Line %1").arg(lineNumber);
2295         auto act = menu->addAction(text);
2296         act->setEnabled(args.isValid());
2297         connect(act, &QAction::triggered, [this, args] {
2298             breakpointSetMarginActionTriggered(false, args);
2299         });
2300 
2301         // Message trace point
2302         const QString tracePointText = args.address
2303             ? tr("Set Message Tracepoint at 0x%1...").arg(args.address, 0, 16)
2304             : tr("Set Message Tracepoint at Line %1...").arg(lineNumber);
2305         act = menu->addAction(tracePointText);
2306         act->setEnabled(args.isValid());
2307         connect(act, &QAction::triggered, [this, args] {
2308             breakpointSetMarginActionTriggered(true, args);
2309         });
2310     }
2311 
2312     // Run to, jump to line below in stopped state.
2313     if (currentEngine()->state() == InferiorStopOk && args.isValid()) {
2314         menu->addSeparator();
2315         if (currentEngine()->hasCapability(RunToLineCapability)) {
2316             auto act = menu->addAction(args.address
2317                 ? DebuggerEngine::tr("Run to Address 0x%1").arg(args.address, 0, 16)
2318                 : DebuggerEngine::tr("Run to Line %1").arg(args.lineNumber));
2319             connect(act, &QAction::triggered, [this, args] {
2320                 currentEngine()->executeRunToLine(args);
2321             });
2322         }
2323         if (currentEngine()->hasCapability(JumpToLineCapability)) {
2324             auto act = menu->addAction(args.address
2325                 ? DebuggerEngine::tr("Jump to Address 0x%1").arg(args.address, 0, 16)
2326                 : DebuggerEngine::tr("Jump to Line %1").arg(args.lineNumber));
2327             connect(act, &QAction::triggered, [this, args] {
2328                 currentEngine()->executeJumpToLine(args);
2329             });
2330         }
2331         // Disassemble current function in stopped state.
2332         if (currentEngine()->hasCapability(DisassemblerCapability)) {
2333             StackFrame frame;
2334             frame.function = cppFunctionAt(args.fileName, lineNumber, 1);
2335             frame.line = 42; // trick gdb into mixed mode.
2336             if (!frame.function.isEmpty()) {
2337                 const QString text = tr("Disassemble Function \"%1\"")
2338                     .arg(frame.function);
2339                 auto act = new QAction(text, menu);
2340                 connect(act, &QAction::triggered, [this, frame] {
2341                     currentEngine()->openDisassemblerView(Location(frame));
2342                 });
2343                 menu->addAction(act);
2344             }
2345         }
2346     }
2347 }
2348 
2349 void DebuggerPluginPrivate::toggleBreakpoint(const ContextData &location, const QString &tracePointMessage)
2350 {
2351     QTC_ASSERT(location.isValid(), return);
2352     BreakHandler *handler = m_breakHandler;
2353     Breakpoint bp;
2354     if (location.type == LocationByFile) {
2355         bp = handler->findBreakpointByFileAndLine(location.fileName, location.lineNumber, true);
2356         if (!bp)
2357             bp = handler->findBreakpointByFileAndLine(location.fileName, location.lineNumber, false);
2358     } else if (location.type == LocationByAddress) {
2359         bp = handler->findBreakpointByAddress(location.address);
2360     }
2361 
2362     if (bp) {
2363         bp.removeBreakpoint();
2364     } else {
2365         BreakpointParameters data;
2366         if (location.type == LocationByFile) {
2367             data.type = BreakpointByFileAndLine;
2368             if (boolSetting(BreakpointsFullPathByDefault))
2369                 data.pathUsage = BreakpointUseFullPath;
2370             data.tracepoint = !tracePointMessage.isEmpty();
2371             data.message = tracePointMessage;
2372             data.fileName = location.fileName;
2373             data.lineNumber = location.lineNumber;
2374         } else if (location.type == LocationByAddress) {
2375             data.type = BreakpointByAddress;
2376             data.tracepoint = !tracePointMessage.isEmpty();
2377             data.message = tracePointMessage;
2378             data.address = location.address;
2379         }
2380         handler->appendBreakpoint(data);
2381     }
2382 }
2383 
2384 void DebuggerPluginPrivate::toggleBreakpointHelper()
2385 {
2386     BaseTextEditor *textEditor = BaseTextEditor::currentTextEditor();
2387     QTC_ASSERT(textEditor, return);
2388     const int lineNumber = textEditor->currentLine();
2389     ContextData location = getLocationContext(textEditor->textDocument(), lineNumber);
2390     if (location.isValid())
2391         toggleBreakpoint(location);
2392 }
2393 
2394 void DebuggerPluginPrivate::requestMark(TextEditorWidget *widget, int lineNumber,
2395                                         TextMarkRequestKind kind)
2396 {
2397     if (kind == BreakpointRequest) {
2398         ContextData location = getLocationContext(widget->textDocument(), lineNumber);
2399         if (location.isValid())
2400             toggleBreakpoint(location);
2401     }
2402 }
2403 
2404 // If updateEngine is set, the engine will update its threads/modules and so forth.
2405 void DebuggerPluginPrivate::displayDebugger(DebuggerEngine *engine, bool updateEngine)
2406 {
2407     QTC_ASSERT(engine, return);
2408     disconnectEngine();
2409     connectEngine(engine);
2410     if (updateEngine)
2411         engine->updateAll();
2412     engine->updateViews();
2413 }
2414 
2415 void DebuggerPluginPrivate::connectEngine(DebuggerEngine *engine)
2416 {
2417     if (!engine)
2418         engine = dummyEngine();
2419 
2420     if (m_currentEngine == engine)
2421         return;
2422 
2423     if (m_shuttingDown)
2424         return;
2425 
2426     if (m_currentEngine)
2427         m_currentEngine->resetLocation();
2428     m_currentEngine = engine;
2429 
2430     m_localsView->setModel(engine->watchModel());
2431     m_modulesView->setModel(engine->modulesModel());
2432     m_registerView->setModel(engine->registerModel());
2433     m_returnView->setModel(engine->watchModel());
2434     m_sourceFilesView->setModel(engine->sourceFilesModel());
2435     m_stackView->setModel(engine->stackModel());
2436     m_threadsView->setModel(engine->threadsModel());
2437     m_watchersView->setModel(engine->watchModel());
2438     m_inspectorView->setModel(engine->watchModel());
2439 
2440     engine->watchHandler()->resetWatchers();
2441     m_localsView->hideProgressIndicator();
2442     updateActiveLanguages();
2443 }
2444 
2445 static void changeFontSize(QWidget *widget, qreal size)
2446 {
2447     QFont font = widget->font();
2448     font.setPointSizeF(size);
2449     widget->setFont(font);
2450 }
2451 
2452 void DebuggerPluginPrivate::fontSettingsChanged(const FontSettings &settings)
2453 {
2454     if (!boolSetting(FontSizeFollowsEditor))
2455         return;
2456     qreal size = settings.fontZoom() * settings.fontSize() / 100.;
2457     changeFontSize(m_breakWindow, size);
2458     changeFontSize(m_logWindow, size);
2459     changeFontSize(m_localsWindow, size);
2460     changeFontSize(m_modulesWindow, size);
2461     //changeFontSize(m_consoleWindow, size);
2462     changeFontSize(m_registerWindow, size);
2463     changeFontSize(m_returnWindow, size);
2464     changeFontSize(m_sourceFilesWindow, size);
2465     changeFontSize(m_stackWindow, size);
2466     changeFontSize(m_threadsWindow, size);
2467     changeFontSize(m_watchersWindow, size);
2468     changeFontSize(m_inspectorWindow, size);
2469 }
2470 
2471 void DebuggerPluginPrivate::cleanupViews()
2472 {
2473     m_reverseDirectionAction->setChecked(false);
2474     m_reverseDirectionAction->setEnabled(false);
2475 
2476     const bool closeSource = boolSetting(CloseSourceBuffersOnExit);
2477     const bool closeMemory = boolSetting(CloseMemoryBuffersOnExit);
2478 
2479     QList<IDocument *> toClose;
2480     foreach (IDocument *document, DocumentModel::openedDocuments()) {
2481         const bool isMemory = document->property(Constants::OPENED_WITH_DISASSEMBLY).toBool();
2482         if (document->property(Constants::OPENED_BY_DEBUGGER).toBool()) {
2483             bool keepIt = true;
2484             if (document->isModified())
2485                 keepIt = true;
2486             else if (isMemory)
2487                 keepIt = !closeMemory;
2488             else
2489                 keepIt = !closeSource;
2490 
2491             if (keepIt)
2492                 document->setProperty(Constants::OPENED_BY_DEBUGGER, false);
2493             else
2494                 toClose.append(document);
2495         }
2496     }
2497     EditorManager::closeDocuments(toClose);
2498 }
2499 
2500 void DebuggerPluginPrivate::setBusyCursor(bool busy)
2501 {
2502     //STATE_DEBUG("BUSY FROM: " << m_busy << " TO: " << busy);
2503     if (busy == m_busy)
2504         return;
2505     m_busy = busy;
2506     QCursor cursor(busy ? Qt::BusyCursor : Qt::ArrowCursor);
2507     m_breakWindow->setCursor(cursor);
2508     //m_consoleWindow->setCursor(cursor);
2509     m_localsWindow->setCursor(cursor);
2510     m_modulesWindow->setCursor(cursor);
2511     m_logWindow->setCursor(cursor);
2512     m_registerWindow->setCursor(cursor);
2513     m_returnWindow->setCursor(cursor);
2514     m_sourceFilesWindow->setCursor(cursor);
2515     m_stackWindow->setCursor(cursor);
2516     m_threadsWindow->setCursor(cursor);
2517     m_watchersWindow->setCursor(cursor);
2518     m_snapshotWindow->setCursor(cursor);
2519 }
2520 
2521 void DebuggerPluginPrivate::setInitialState()
2522 {
2523     m_watchersWindow->setVisible(false);
2524     m_returnWindow->setVisible(false);
2525     setBusyCursor(false);
2526     m_reverseDirectionAction->setChecked(false);
2527     m_reverseDirectionAction->setEnabled(false);
2528     m_toolTipManager.closeAllToolTips();
2529 
2530     m_startAndDebugApplicationAction->setEnabled(true);
2531     m_attachToQmlPortAction->setEnabled(true);
2532     m_attachToCoreAction->setEnabled(true);
2533     m_attachToRemoteServerAction->setEnabled(true);
2534     m_attachToRunningApplication->setEnabled(true);
2535     m_attachToUnstartedApplication->setEnabled(true);
2536     m_detachAction->setEnabled(false);
2537 
2538     m_watchAction->setEnabled(true);
2539     m_breakAction->setEnabled(false);
2540     //m_snapshotAction->setEnabled(false);
2541     m_operateByInstructionAction->setEnabled(false);
2542 
2543     m_exitAction->setEnabled(false);
2544     m_abortAction->setEnabled(false);
2545     m_resetAction->setEnabled(false);
2546 
2547     m_interruptAction->setEnabled(false);
2548     m_continueAction->setEnabled(false);
2549 
2550     m_stepAction->setEnabled(true);
2551     m_stepOutAction->setEnabled(false);
2552     m_runToLineAction->setEnabled(false);
2553     m_runToSelectedFunctionAction->setEnabled(true);
2554     m_returnFromFunctionAction->setEnabled(false);
2555     m_jumpToLineAction->setEnabled(false);
2556     m_nextAction->setEnabled(true);
2557 
2558     action(AutoDerefPointers)->setEnabled(true);
2559     action(ExpandStack)->setEnabled(false);
2560 
2561     m_threadLabel->setEnabled(false);
2562 }
2563 
2564 void DebuggerPluginPrivate::updateState(DebuggerEngine *engine)
2565 {
2566     if (m_shuttingDown)
2567         return;
2568     QTC_ASSERT(engine, return);
2569     QTC_ASSERT(m_watchersView->model(), return);
2570     QTC_ASSERT(m_returnView->model(), return);
2571     QTC_ASSERT(!engine->isSlaveEngine(), return);
2572 
2573     m_threadBox->setCurrentIndex(engine->threadsHandler()->currentThreadIndex());
2574 
2575     const DebuggerState state = engine->state();
2576     //showMessage(QString::fromLatin1("PLUGIN SET STATE: ")
2577     //    + DebuggerEngine::stateName(state), LogStatus);
2578     //qDebug() << "PLUGIN SET STATE: " << state;
2579 
2580     static DebuggerState previousState = DebuggerNotReady;
2581     if (state == previousState)
2582         return;
2583 
2584     bool actionsEnabled = DebuggerEngine::debuggerActionsEnabled(state);
2585 
2586     if (state == DebuggerNotReady) {
2587         QTC_ASSERT(false, /* We use the Core's m_debugAction here */);
2588         // F5 starts debugging. It is "startable".
2589         m_interruptAction->setEnabled(false);
2590         m_continueAction->setEnabled(false);
2591         m_exitAction->setEnabled(false);
2592         m_startAction->setEnabled(true);
2593         m_debugWithoutDeployAction->setEnabled(true);
2594         setProxyAction(m_visibleStartAction, Id(Constants::DEBUG));
2595         m_hiddenStopAction->setAction(m_undisturbableAction);
2596     } else if (state == InferiorStopOk) {
2597         // F5 continues, Shift-F5 kills. It is "continuable".
2598         m_interruptAction->setEnabled(false);
2599         m_continueAction->setEnabled(true);
2600         m_exitAction->setEnabled(true);
2601         m_startAction->setEnabled(false);
2602         m_debugWithoutDeployAction->setEnabled(false);
2603         setProxyAction(m_visibleStartAction, Id(Constants::CONTINUE));
2604         m_hiddenStopAction->setAction(m_exitAction);
2605         m_localsAndExpressionsWindow->setShowLocals(true);
2606     } else if (state == InferiorRunOk) {
2607         // Shift-F5 interrupts. It is also "interruptible".
2608         m_interruptAction->setEnabled(true);
2609         m_continueAction->setEnabled(false);
2610         m_exitAction->setEnabled(true);
2611         m_startAction->setEnabled(false);
2612         m_debugWithoutDeployAction->setEnabled(false);
2613         setProxyAction(m_visibleStartAction, Id(Constants::INTERRUPT));
2614         m_hiddenStopAction->setAction(m_interruptAction);
2615         m_localsAndExpressionsWindow->setShowLocals(false);
2616     } else if (state == DebuggerFinished) {
2617         const bool canRun = ProjectExplorerPlugin::canRunStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE);
2618         // We don't want to do anything anymore.
2619         m_interruptAction->setEnabled(false);
2620         m_continueAction->setEnabled(false);
2621         m_exitAction->setEnabled(false);
2622         m_startAction->setEnabled(canRun);
2623         m_debugWithoutDeployAction->setEnabled(canRun);
2624         setProxyAction(m_visibleStartAction, Id(Constants::DEBUG));
2625         m_hiddenStopAction->setAction(m_undisturbableAction);
2626         m_codeModelSnapshot = CPlusPlus::Snapshot();
2627         setBusyCursor(false);
2628         cleanupViews();
2629     } else if (state == InferiorUnrunnable) {
2630         // We don't want to do anything anymore.
2631         m_interruptAction->setEnabled(false);
2632         m_continueAction->setEnabled(false);
2633         m_exitAction->setEnabled(true);
2634         m_startAction->setEnabled(false);
2635         m_debugWithoutDeployAction->setEnabled(false);
2636         m_visibleStartAction->setAction(m_undisturbableAction);
2637         m_hiddenStopAction->setAction(m_exitAction);
2638         // show locals in core dumps
2639         m_localsAndExpressionsWindow->setShowLocals(true);
2640     } else {
2641         // Everything else is "undisturbable".
2642         m_interruptAction->setEnabled(false);
2643         m_continueAction->setEnabled(false);
2644         m_exitAction->setEnabled(false);
2645         m_startAction->setEnabled(false);
2646         m_debugWithoutDeployAction->setEnabled(false);
2647         m_visibleStartAction->setAction(m_undisturbableAction);
2648         m_hiddenStopAction->setAction(m_undisturbableAction);
2649     }
2650 
2651     m_startAndDebugApplicationAction->setEnabled(true);
2652     m_attachToQmlPortAction->setEnabled(true);
2653     m_attachToCoreAction->setEnabled(true);
2654     m_attachToRemoteServerAction->setEnabled(true);
2655     m_attachToRunningApplication->setEnabled(true);
2656     m_attachToUnstartedApplication->setEnabled(true);
2657 
2658     m_threadBox->setEnabled(state == InferiorStopOk || state == InferiorUnrunnable);
2659     m_threadLabel->setEnabled(m_threadBox->isEnabled());
2660 
2661     const bool isCore = engine->runParameters().startMode == AttachCore;
2662     const bool stopped = state == InferiorStopOk;
2663     const bool detachable = stopped && !isCore;
2664     m_detachAction->setEnabled(detachable);
2665 
2666     if (stopped)
2667         QApplication::alert(mainWindow(), 3000);
2668 
2669     const bool canReverse = engine->hasCapability(ReverseSteppingCapability)
2670                 && boolSetting(EnableReverseDebugging);
2671     m_reverseDirectionAction->setEnabled(canReverse);
2672 
2673     m_watchAction->setEnabled(true);
2674     m_breakAction->setEnabled(true);
2675 
2676     const bool canOperateByInstruction = engine->hasCapability(OperateByInstructionCapability)
2677             && (stopped || isCore);
2678     m_operateByInstructionAction->setEnabled(canOperateByInstruction);
2679 
2680     m_abortAction->setEnabled(state != DebuggerNotReady
2681                                       && state != DebuggerFinished);
2682     m_resetAction->setEnabled((stopped || state == DebuggerNotReady)
2683                               && engine->hasCapability(ResetInferiorCapability));
2684 
2685     m_stepAction->setEnabled(stopped || state == DebuggerNotReady);
2686     m_nextAction->setEnabled(stopped || state == DebuggerNotReady);
2687     m_stepAction->setToolTip(QString());
2688     m_nextAction->setToolTip(QString());
2689 
2690     m_stepOutAction->setEnabled(stopped);
2691     m_runToLineAction->setEnabled(stopped && engine->hasCapability(RunToLineCapability));
2692     m_runToSelectedFunctionAction->setEnabled(stopped);
2693     m_returnFromFunctionAction->
2694         setEnabled(stopped && engine->hasCapability(ReturnFromFunctionCapability));
2695 
2696     const bool canJump = stopped && engine->hasCapability(JumpToLineCapability);
2697     m_jumpToLineAction->setEnabled(canJump);
2698 
2699     const bool canDeref = actionsEnabled && engine->hasCapability(AutoDerefPointersCapability);
2700     action(AutoDerefPointers)->setEnabled(canDeref);
2701     action(AutoDerefPointers)->setEnabled(true);
2702     action(ExpandStack)->setEnabled(actionsEnabled);
2703 
2704     const bool notbusy = state == InferiorStopOk
2705         || state == DebuggerNotReady
2706         || state == DebuggerFinished
2707         || state == InferiorUnrunnable;
2708     setBusyCursor(!notbusy);
2709 }
2710 
2711 void DebuggerPluginPrivate::updateDebugActions()
2712 {
2713     if (m_shuttingDown)
2714         return;
2715     //if we're currently debugging the actions are controlled by engine
2716     if (m_currentEngine && m_currentEngine->state() != DebuggerNotReady)
2717         return;
2718 
2719     QString whyNot;
2720     const bool canRun = ProjectExplorerPlugin::canRunStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE, &whyNot);
2721     m_startAction->setEnabled(canRun);
2722     m_startAction->setToolTip(whyNot);
2723     m_debugWithoutDeployAction->setEnabled(canRun);
2724 
2725     // Step into/next: Start and break at 'main' unless a debugger is running.
2726     if (m_snapshotHandler->currentIndex() < 0) {
2727         QString toolTip;
2728         const bool canRunAndBreakMain
2729                 = ProjectExplorerPlugin::canRunStartupProject(ProjectExplorer::Constants::DEBUG_RUN_MODE_WITH_BREAK_ON_MAIN, &toolTip);
2730         m_stepAction->setEnabled(canRunAndBreakMain);
2731         m_nextAction->setEnabled(canRunAndBreakMain);
2732         if (canRunAndBreakMain) {
2733             Project *project = SessionManager::startupProject();
2734             QTC_ASSERT(project, return);
2735             toolTip = tr("Start \"%1\" and break at function \"main()\"")
2736                       .arg(project->displayName());
2737         }
2738         m_stepAction->setToolTip(toolTip);
2739         m_nextAction->setToolTip(toolTip);
2740     }
2741 }
2742 
2743 void DebuggerPluginPrivate::updateDebugWithoutDeployMenu()
2744 {
2745     const bool state = ProjectExplorerPlugin::projectExplorerSettings().deployBeforeRun;
2746     m_debugWithoutDeployAction->setVisible(state);
2747 }
2748 
2749 void DebuggerPluginPrivate::dumpLog()
2750 {
2751     QString fileName = QFileDialog::getSaveFileName(ICore::mainWindow(),
2752         tr("Save Debugger Log"), Utils::TemporaryDirectory::masterDirectoryPath());
2753     if (fileName.isEmpty())
2754         return;
2755     FileSaver saver(fileName);
2756     if (!saver.hasError()) {
2757         QTextStream ts(saver.file());
2758         ts << m_logWindow->inputContents();
2759         ts << "\n\n=======================================\n\n";
2760         ts << m_logWindow->combinedContents();
2761         saver.setResult(&ts);
2762     }
2763     saver.finalize(ICore::mainWindow());
2764 }
2765 
2766 /*! Activates the previous mode when the current mode is the debug mode. */
2767 void DebuggerPluginPrivate::activatePreviousMode()
2768 {
2769     if (ModeManager::currentMode() == MODE_DEBUG && m_previousMode.isValid()) {
2770         // If stopping the application also makes Qt Creator active (as the
2771         // "previously active application"), doing the switch synchronously
2772         // leads to funny effects with floating dock widgets
2773         const Core::Id mode = m_previousMode;
2774         QTimer::singleShot(0, this, [mode]() { ModeManager::activateMode(mode); });
2775         m_previousMode = Id();
2776     }
2777 }
2778 
2779 void DebuggerPluginPrivate::activateDebugMode()
2780 {
2781     m_reverseDirectionAction->setChecked(false);
2782     m_reverseDirectionAction->setEnabled(false);
2783     ModeManager::activateMode(MODE_DEBUG);
2784 }
2785 
2786 void DebuggerPluginPrivate::sessionLoaded()
2787 {
2788     m_breakHandler->loadSessionData();
2789     dummyEngine()->watchHandler()->loadSessionData();
2790     DebuggerToolTipManager::loadSessionData();
2791 }
2792 
2793 void DebuggerPluginPrivate::aboutToUnloadSession()
2794 {
2795     m_toolTipManager.sessionAboutToChange();
2796 }
2797 
2798 void DebuggerPluginPrivate::aboutToSaveSession()
2799 {
2800     dummyEngine()->watchHandler()->saveSessionData();
2801     m_breakHandler->saveSessionData();
2802     DebuggerToolTipManager::saveSessionData();
2803 }
2804 
2805 void DebuggerPluginPrivate::showStatusMessage(const QString &msg0, int timeout)
2806 {
2807     if (m_shuttingDown)
2808         return;
2809     showMessage(msg0, LogStatus);
2810     QString msg = msg0;
2811     msg.replace(QChar::LineFeed, QLatin1String("; "));
2812     m_mainWindow->showStatusMessage(msg, timeout);
2813 }
2814 
2815 void DebuggerPluginPrivate::coreShutdown()
2816 {
2817     m_shuttingDown = true;
2818     if (currentEngine()) {
2819         if (currentEngine()->state() != Debugger::DebuggerNotReady) {
2820             currentEngine()->setTargetState(Debugger::DebuggerFinished);
2821             currentEngine()->abortDebugger();
2822         }
2823     }
2824 }
2825 
2826 const CPlusPlus::Snapshot &cppCodeModelSnapshot()
2827 {
2828     if (dd->m_codeModelSnapshot.isEmpty() && action(UseCodeModel)->isChecked())
2829         dd->m_codeModelSnapshot = CppTools::CppModelManager::instance()->snapshot();
2830     return dd->m_codeModelSnapshot;
2831 }
2832 
2833 void setSessionValue(const QByteArray &key, const QVariant &value)
2834 {
2835     SessionManager::setValue(QString::fromUtf8(key), value);
2836 }
2837 
2838 QVariant sessionValue(const QByteArray &key)
2839 {
2840     return SessionManager::value(QString::fromUtf8(key));
2841 }
2842 
2843 WatchTreeView *inspectorView()
2844 {
2845     return dd->m_inspectorView;
2846 }
2847 
2848 void DebuggerPluginPrivate::showMessage(const QString &msg, int channel, int timeout)
2849 {
2850     if (m_shuttingDown)
2851         return;
2852     //qDebug() << "PLUGIN OUTPUT: " << channel << msg;
2853     QTC_ASSERT(m_logWindow, return);
2854     switch (channel) {
2855         case StatusBar:
2856             // This will append to m_logWindow's output pane, too.
2857             showStatusMessage(msg, timeout);
2858             break;
2859         case LogMiscInput:
2860             m_logWindow->showInput(LogMisc, msg);
2861             m_logWindow->showOutput(LogMisc, msg);
2862             break;
2863         case LogInput:
2864             m_logWindow->showInput(LogInput, msg);
2865             m_logWindow->showOutput(LogInput, msg);
2866             break;
2867         case LogError:
2868             m_logWindow->showInput(LogError, QLatin1String("ERROR: ") + msg);
2869             m_logWindow->showOutput(LogError, QLatin1String("ERROR: ") + msg);
2870             break;
2871         default:
2872             m_logWindow->showOutput(channel, msg);
2873             break;
2874     }
2875 }
2876 
2877 static void createNewDock(QWidget *widget)
2878 {
2879 //    m_mainWindow->registerDockWidget(dockId, widget);
2880 
2881 //    QDockWidget *dockWidget = qobject_cast<QDockWidget *>(widget->parentWidget());
2882 //    //dockWidget->installEventFilter(&m_resizeEventFilter);
2883 
2884 //    QAction *toggleViewAction = dockWidget->toggleViewAction();
2885 //    Command *cmd = ActionManager::registerAction(toggleViewAction,
2886 //             Id("Debugger.").withSuffix(widget->objectName()));
2887 //    cmd->setAttribute(Command::CA_Hide);
2888 //    dd->createDockWidget(Core::Id::fromString(widget->objectName()), widget);
2889 //    QDockWidget *dockWidget = qobject_cast<QDockWidget *>(widget->parentWidget());
2890 //    QDockWidget *dockWidget = Debugger::registerDockWidget(Id::fromString(widget->objectName()), widget);
2891     QDockWidget *dockWidget = new QDockWidget;
2892     dockWidget->setWidget(widget);
2893 
2894     dockWidget->setWindowTitle(widget->windowTitle());
2895     dockWidget->setFeatures(QDockWidget::DockWidgetClosable);
2896     dockWidget->show();
2897 }
2898 
2899 static QString formatStartParameters(DebuggerRunParameters &sp)
2900 {
2901     QString rc;
2902     QTextStream str(&rc);
2903     str << "Start parameters: '" << sp.displayName << "' mode: " << sp.startMode
2904         << "\nABI: " << sp.toolChainAbi.toString() << '\n';
2905     str << "Languages: ";
2906     if (sp.languages == AnyLanguage)
2907         str << "any ";
2908     if (sp.languages & CppLanguage)
2909         str << "c++ ";
2910     if (sp.languages & QmlLanguage)
2911         str << "qml";
2912     str << '\n';
2913     if (!sp.inferior.executable.isEmpty()) {
2914         str << "Executable: " << QDir::toNativeSeparators(sp.inferior.executable)
2915             << ' ' << sp.inferior.commandLineArguments;
2916         if (sp.useTerminal)
2917             str << " [terminal]";
2918         str << '\n';
2919         if (!sp.inferior.workingDirectory.isEmpty())
2920             str << "Directory: " << QDir::toNativeSeparators(sp.inferior.workingDirectory)
2921                 << '\n';
2922     }
2923     QString cmd = sp.debugger.executable;
2924     if (!cmd.isEmpty())
2925         str << "Debugger: " << QDir::toNativeSeparators(cmd) << '\n';
2926     if (!sp.coreFile.isEmpty())
2927         str << "Core: " << QDir::toNativeSeparators(sp.coreFile) << '\n';
2928     if (sp.attachPID.isValid())
2929         str << "PID: " << sp.attachPID.pid() << ' ' << sp.crashParameter << '\n';
2930     if (!sp.projectSourceDirectory.isEmpty()) {
2931         str << "Project: " << QDir::toNativeSeparators(sp.projectSourceDirectory);
2932         str << "Addtional Search Directories:"
2933             << sp.additionalSearchDirectories.join(QLatin1Char(' ')) << '\n';
2934     }
2935     if (!sp.remoteChannel.isEmpty())
2936         str << "Remote: " << sp.remoteChannel << '\n';
2937     if (!sp.qmlServer.host.isEmpty())
2938         str << "QML server: " << sp.qmlServer.host << ':'
2939             << (sp.qmlServer.port.isValid() ? sp.qmlServer.port.number() : -1) << '\n';
2940     str << "Sysroot: " << sp.sysRoot << '\n';
2941     str << "Debug Source Location: " << sp.debugSourceLocation.join(QLatin1Char(':')) << '\n';
2942     return rc;
2943 }
2944 
2945 void DebuggerPluginPrivate::runControlStarted(DebuggerRunTool *runTool)
2946 {
2947     activateDebugMode();
2948     const QString message = tr("Starting debugger \"%1\" for ABI \"%2\"...")
2949             .arg(runTool->objectName())
2950             .arg(runTool->runParameters().toolChainAbi.toString());
2951     showStatusMessage(message);
2952     showMessage(formatStartParameters(runTool->runParameters()), LogDebug);
2953     showMessage(m_debuggerSettings->dump(), LogDebug);
2954     m_snapshotHandler->appendSnapshot(runTool);
2955     connectEngine(runTool->engine());
2956 }
2957 
2958 void DebuggerPluginPrivate::runControlFinished(DebuggerRunTool *runTool)
2959 {
2960     if (runTool && runTool->engine())
2961         runTool->engine()->handleFinished();
2962     if (m_shuttingDown)
2963         return;
2964     showStatusMessage(tr("Debugger finished."));
2965     m_snapshotHandler->removeSnapshot(runTool);
2966     if (m_snapshotHandler->size() == 0) {
2967         // Last engine quits.
2968         disconnectEngine();
2969         if (boolSetting(SwitchModeOnExit))
2970             activatePreviousMode();
2971     } else {
2972         // Connect to some existing engine.
2973         m_snapshotHandler->activateSnapshot(0);
2974     }
2975     m_operateByInstructionAction->setChecked(false);
2976     m_logWindow->clearUndoRedoStacks();
2977 }
2978 
2979 void DebuggerPluginPrivate::remoteCommand(const QStringList &options)
2980 {
2981     if (options.isEmpty())
2982         return;
2983 
2984     QString errorMessage;
2985 
2986     if (!parseArguments(options, &errorMessage)) {
2987         qWarning("%s", qPrintable(errorMessage));
2988         return;
2989     }
2990     runScheduled();
2991 }
2992 
2993 QMessageBox *showMessageBox(int icon, const QString &title,
2994     const QString &text, int buttons)
2995 {
2996     QMessageBox *mb = new QMessageBox(QMessageBox::Icon(icon),
2997         title, text, QMessageBox::StandardButtons(buttons),
2998         ICore::mainWindow());
2999     mb->setAttribute(Qt::WA_DeleteOnClose);
3000     mb->setTextInteractionFlags(Qt::TextSelectableByMouse);
3001     mb->show();
3002     return mb;
3003 }
3004 
3005 bool isReverseDebuggingEnabled()
3006 {
3007     static bool enabled = qEnvironmentVariableIsSet("QTC_DEBUGGER_ENABLE_REVERSE");
3008     return enabled;
3009 }
3010 
3011 bool isReverseDebugging()
3012 {
3013     return isReverseDebuggingEnabled() && dd->m_reverseDirectionAction->isChecked();
3014 }
3015 
3016 void DebuggerPluginPrivate::extensionsInitialized()
3017 {
3018     // If the CppEditor or QmlJS editor plugin is there, we want to add something to
3019     // the editor context menu.
3020     for (Id menuId : { CppEditor::Constants::M_CONTEXT, QmlJSEditor::Constants::M_CONTEXT }) {
3021         if (ActionContainer *editorContextMenu = ActionManager::actionContainer(menuId)) {
3022             auto cmd = editorContextMenu->addSeparator(m_watchCommand->context());
3023             cmd->setAttribute(Command::CA_Hide);
3024             cmd = m_watchCommand;
3025             cmd->action()->setEnabled(true);
3026             editorContextMenu->addAction(cmd);
3027             cmd->setAttribute(Command::CA_Hide);
3028             cmd->setAttribute(Command::CA_NonConfigurable);
3029         }
3030     }
3031 }
3032 
3033 DebuggerEngine *currentEngine()
3034 {
3035     return dd->m_currentEngine;
3036 }
3037 
3038 SavedAction *action(int code)
3039 {
3040     return dd->m_debuggerSettings->item(code);
3041 }
3042 
3043 bool boolSetting(int code)
3044 {
3045     return dd->m_debuggerSettings->item(code)->value().toBool();
3046 }
3047 
3048 QString stringSetting(int code)
3049 {
3050     return dd->m_debuggerSettings->item(code)->value().toString();
3051 }
3052 
3053 QStringList stringListSetting(int code)
3054 {
3055     return dd->m_debuggerSettings->item(code)->value().toStringList();
3056 }
3057 
3058 BreakHandler *breakHandler()
3059 {
3060     return dd->m_breakHandler;
3061 }
3062 
3063 void showModuleSymbols(const QString &moduleName, const Symbols &symbols)
3064 {
3065     QTreeWidget *w = new QTreeWidget;
3066     w->setUniformRowHeights(true);
3067     w->setColumnCount(5);
3068     w->setRootIsDecorated(false);
3069     w->setAlternatingRowColors(true);
3070     w->setSortingEnabled(true);
3071     w->setObjectName(QLatin1String("Symbols.") + moduleName);
3072     QStringList header;
3073     header.append(DebuggerPlugin::tr("Symbol"));
3074     header.append(DebuggerPlugin::tr("Address"));
3075     header.append(DebuggerPlugin::tr("Code"));
3076     header.append(DebuggerPlugin::tr("Section"));
3077     header.append(DebuggerPlugin::tr("Name"));
3078     w->setHeaderLabels(header);
3079     w->setWindowTitle(DebuggerPlugin::tr("Symbols in \"%1\"").arg(moduleName));
3080     foreach (const Symbol &s, symbols) {
3081         QTreeWidgetItem *it = new QTreeWidgetItem;
3082         it->setData(0, Qt::DisplayRole, s.name);
3083         it->setData(1, Qt::DisplayRole, s.address);
3084         it->setData(2, Qt::DisplayRole, s.state);
3085         it->setData(3, Qt::DisplayRole, s.section);
3086         it->setData(4, Qt::DisplayRole, s.demangled);
3087         w->addTopLevelItem(it);
3088     }
3089     createNewDock(w);
3090 }
3091 
3092 void showModuleSections(const QString &moduleName, const Sections &sections)
3093 {
3094     QTreeWidget *w = new QTreeWidget;
3095     w->setUniformRowHeights(true);
3096     w->setColumnCount(5);
3097     w->setRootIsDecorated(false);
3098     w->setAlternatingRowColors(true);
3099     w->setSortingEnabled(true);
3100     w->setObjectName(QLatin1String("Sections.") + moduleName);
3101     QStringList header;
3102     header.append(DebuggerPlugin::tr("Name"));
3103     header.append(DebuggerPlugin::tr("From"));
3104     header.append(DebuggerPlugin::tr("To"));
3105     header.append(DebuggerPlugin::tr("Address"));
3106     header.append(DebuggerPlugin::tr("Flags"));
3107     w->setHeaderLabels(header);
3108     w->setWindowTitle(DebuggerPlugin::tr("Sections in \"%1\"").arg(moduleName));
3109     foreach (const Section &s, sections) {
3110         QTreeWidgetItem *it = new QTreeWidgetItem;
3111         it->setData(0, Qt::DisplayRole, s.name);
3112         it->setData(1, Qt::DisplayRole, s.from);
3113         it->setData(2, Qt::DisplayRole, s.to);
3114         it->setData(3, Qt::DisplayRole, s.address);
3115         it->setData(4, Qt::DisplayRole, s.flags);
3116         w->addTopLevelItem(it);
3117     }
3118     createNewDock(w);
3119 }
3120 
3121 void DebuggerPluginPrivate::aboutToShutdown()
3122 {
3123     disconnect(SessionManager::instance(), &SessionManager::startupProjectChanged, this, nullptr);
3124 
3125     m_mainWindow->saveCurrentPerspective();
3126     delete m_mainWindow;
3127     m_mainWindow = 0;
3128 
3129     // removeObject leads to aboutToRemoveObject, which leads to
3130     // ModeManager::aboutToRemove, which leads to the mode manager
3131     // removing the mode's widget from the stackwidget
3132     // (currently by index, but possibly the stackwidget resets the
3133     // parent and stuff on the widget)
3134     m_plugin->removeObject(m_mode);
3135 
3136     delete m_modeWindow;
3137     m_modeWindow = 0;
3138 
3139     delete m_mode;
3140     m_mode = 0;
3141 }
3142 
3143 void updateState(DebuggerEngine *engine)
3144 {
3145     dd->updateState(engine);
3146 }
3147 
3148 void updateWatchersWindow(bool showWatch, bool showReturn)
3149 {
3150     dd->m_watchersWindow->setVisible(showWatch);
3151     dd->m_returnWindow->setVisible(showReturn);
3152     dd->m_localsView->resizeColumns();
3153 }
3154 
3155 bool hasSnapshots()
3156 {
3157      return dd->m_snapshotHandler->size();
3158 }
3159 
3160 void openTextEditor(const QString &titlePattern0, const QString &contents)
3161 {
3162     if (dd->m_shuttingDown)
3163         return;
3164     QString titlePattern = titlePattern0;
3165     IEditor *editor = EditorManager::openEditorWithContents(
3166                 CC::K_DEFAULT_TEXT_EDITOR_ID, &titlePattern, contents.toUtf8(), QString(),
3167                 EditorManager::IgnoreNavigationHistory);
3168     if (auto textEditor = qobject_cast<BaseTextEditor *>(editor)) {
3169         QString suggestion = titlePattern;
3170         if (!suggestion.contains(QLatin1Char('.')))
3171             suggestion.append(QLatin1String(".txt"));
3172         textEditor->textDocument()->setFallbackSaveAsFileName(suggestion);
3173     }
3174     QTC_ASSERT(editor, return);
3175 }
3176 
3177 // void runTest(const QString &fileName);
3178 void showMessage(const QString &msg, int channel, int timeout)
3179 {
3180     dd->showMessage(msg, channel, timeout);
3181 }
3182 
3183 void runControlStarted(DebuggerRunTool *runTool)
3184 {
3185     dd->runControlStarted(runTool);
3186 }
3187 
3188 void runControlFinished(DebuggerRunTool *runTool)
3189 {
3190     dd->runControlFinished(runTool);
3191 }
3192 
3193 void displayDebugger(DebuggerEngine *engine, bool updateEngine)
3194 {
3195     dd->displayDebugger(engine, updateEngine);
3196 }
3197 
3198 void synchronizeBreakpoints()
3199 {
3200     dd->synchronizeBreakpoints();
3201 }
3202 
3203 QWidget *mainWindow()
3204 {
3205     return dd->m_mainWindow;
3206 }
3207 
3208 bool isRegistersWindowVisible()
3209 {
3210     return dd->m_registerWindow->isVisible();
3211 }
3212 
3213 bool isModulesWindowVisible()
3214 {
3215     return dd->m_modulesWindow->isVisible();
3216 }
3217 
3218 void openMemoryEditor()
3219 {
3220     AddressDialog dialog;
3221     if (dialog.exec() == QDialog::Accepted) {
3222         MemoryViewSetupData data;
3223         data.startAddress = dialog.address();
3224         currentEngine()->openMemoryView(data);
3225     }
3226 }
3227 
3228 void setThreadBoxContents(const QStringList &list, int index)
3229 {
3230     dd->setThreadBoxContents(list, index);
3231 }
3232 
3233 QSharedPointer<Internal::GlobalDebuggerOptions> globalDebuggerOptions()
3234 {
3235     return dd->m_globalDebuggerOptions;
3236 }
3237 
3238 ///////////////////////////////////////////////////////////////////////
3239 //
3240 // DebuggerPlugin
3241 //
3242 ///////////////////////////////////////////////////////////////////////
3243 
3244 /*!
3245     \class Debugger::DebuggerPlugin
3246 
3247     This is the "external" interface of the debugger plugin that's visible
3248     from Qt Creator core. The internal interface to global debugger
3249     functionality that is used by debugger views and debugger engines
3250     is DebuggerCore, implemented in DebuggerPluginPrivate.
3251 */
3252 
3253 static DebuggerPlugin *m_instance = 0;
3254 
3255 DebuggerPlugin::DebuggerPlugin()
3256 {
3257     setObjectName(QLatin1String("DebuggerPlugin"));
3258     m_instance = this;
3259 }
3260 
3261 DebuggerPlugin::~DebuggerPlugin()
3262 {
3263     delete dd;
3264     dd = 0;
3265     m_instance = 0;
3266 }
3267 
3268 DebuggerPlugin *DebuggerPlugin::instance()
3269 {
3270     return m_instance;
3271 }
3272 
3273 bool DebuggerPlugin::initialize(const QStringList &arguments, QString *errorMessage)
3274 {
3275     dd = new DebuggerPluginPrivate(this);
3276 
3277     addObject(this);
3278     // Menu groups
3279     ActionContainer *mstart = ActionManager::actionContainer(PE::M_DEBUG_STARTDEBUGGING);
3280     mstart->appendGroup(Constants::G_GENERAL);
3281     mstart->appendGroup(Constants::G_SPECIAL);
3282     mstart->appendGroup(Constants::G_START_QML);
3283 
3284     // Separators
3285     mstart->addSeparator(Constants::G_GENERAL);
3286     mstart->addSeparator(Constants::G_SPECIAL);
3287 
3288     addAutoReleasedObject(new DebuggerItemManager);
3289 
3290     KitManager::registerKitInformation(new DebuggerKitInformation);
3291 
3292     // Task integration.
3293     //: Category under which Analyzer tasks are listed in Issues view
3294     ProjectExplorer::TaskHub::addCategory(Debugger::Constants::ANALYZERTASK_ID, tr("Debugger"));
3295 
3296     return dd->initialize(arguments, errorMessage);
3297 }
3298 
3299 IPlugin::ShutdownFlag DebuggerPlugin::aboutToShutdown()
3300 {
3301     removeObject(this);
3302     dd->aboutToShutdown();
3303     return SynchronousShutdown;
3304 }
3305 
3306 QObject *DebuggerPlugin::remoteCommand(const QStringList &options,
3307                                        const QString &workingDirectory,
3308                                        const QStringList &list)
3309 {
3310     Q_UNUSED(workingDirectory);
3311     Q_UNUSED(list);
3312     dd->remoteCommand(options);
3313     return 0;
3314 }
3315 
3316 void DebuggerPlugin::extensionsInitialized()
3317 {
3318     dd->extensionsInitialized();
3319 }
3320 
3321 void DebuggerPluginPrivate::updateUiForProject(Project *project)
3322 {
3323     if (m_previousProject) {
3324         disconnect(m_previousProject, &Project::activeTargetChanged,
3325             this, &DebuggerPluginPrivate::updateUiForTarget);
3326     }
3327     m_previousProject = project;
3328     if (!project) {
3329         updateUiForTarget(nullptr);
3330         return;
3331     }
3332     connect(project, &Project::activeTargetChanged,
3333             this, &DebuggerPluginPrivate::updateUiForTarget);
3334     updateUiForTarget(project->activeTarget());
3335 }
3336 
3337 void DebuggerPluginPrivate::updateUiForTarget(Target *target)
3338 {
3339     if (m_previousTarget) {
3340          disconnect(m_previousTarget.data(), &Target::activeRunConfigurationChanged,
3341                     this, &DebuggerPluginPrivate::updateActiveLanguages);
3342     }
3343 
3344     m_previousTarget = target;
3345 
3346     if (!target) {
3347         updateActiveLanguages();
3348         return;
3349     }
3350 
3351     connect(target, &Target::activeRunConfigurationChanged,
3352             this, &DebuggerPluginPrivate::updateActiveLanguages);
3353     updateActiveLanguages();
3354 }
3355 
3356 void DebuggerPluginPrivate::updateActiveLanguages()
3357 {
3358     QTC_ASSERT(dd->m_currentEngine, return);
3359     if (!dd->m_currentEngine->runTool())
3360         return;
3361     const DebuggerLanguages languages = dd->m_currentEngine->runParameters().languages;
3362 //    Id perspective = (languages & QmlLanguage) && !(languages & CppLanguage)
3363 //            ? QmlPerspectiveId : CppPerspectiveId;
3364 //    m_mainWindow->restorePerspective(perspective);
3365     for (DebuggerLanguage language: {QmlLanguage, CppLanguage}) {
3366         const Context context = m_contextsForLanguage.value(language);
3367         if (languages & language)
3368             ICore::addAdditionalContext(context);
3369         else
3370             ICore::removeAdditionalContext(context);
3371     }
3372 }
3373 
3374 //bool DockWidgetEventFilter::eventFilter(QObject *obj, QEvent *event)
3375 //{
3376 //    switch (event->type()) {
3377 //    case QEvent::Resize:
3378 //    case QEvent::ZOrderChange:
3379 //        dd->updateDockWidgetSettings();
3380 //        break;
3381 //    default:
3382 //        break;
3383 //    }
3384 //    return QObject::eventFilter(obj, event);
3385 //}
3386 
3387 void DebuggerPluginPrivate::onModeChanged(Id mode)
3388 {
3389     // FIXME: This one gets always called, even if switching between modes
3390     //        different then the debugger mode. E.g. Welcome and Help mode and
3391     //        also on shutdown.
3392 
3393     if (mode == MODE_DEBUG) {
3394         if (IEditor *editor = EditorManager::currentEditor())
3395             editor->widget()->setFocus();
3396 
3397         m_toolTipManager.debugModeEntered();
3398 
3399 //        static bool firstTime = true;
3400 //        if (firstTime) {
3401 
3402 //            // Dock widgets
3403 //            connect(m_mainWindow->dockWidget(DOCKWIDGET_MODULES)->toggleViewAction(), &QAction::toggled,
3404 //                    this, &DebuggerPluginPrivate::modulesDockToggled, Qt::QueuedConnection);
3405 //            connect(m_mainWindow->dockWidget(DOCKWIDGET_OUTPUT)->toggleViewAction(), &QAction::toggled,
3406 //                    this, &DebuggerPluginPrivate::registerDockToggled, Qt::QueuedConnection);
3407 //            connect(m_mainWindow->dockWidget(DOCKWIDGET_SOURCE_FILES)->toggleViewAction(), &QAction::toggled,
3408 //                    this, &DebuggerPluginPrivate::sourceFilesDockToggled, Qt::QueuedConnection);
3409 
3410 //            firstTime = false;
3411 //        }
3412         updateActiveLanguages();
3413     } else {
3414         m_toolTipManager.leavingDebugMode();
3415     }
3416 }
3417 
3418 void saveModeToRestore()
3419 {
3420     dd->m_previousMode = ModeManager::currentMode();
3421 }
3422 
3423 } // namespace Internal
3424 
3425 static bool buildTypeAccepted(QFlags<ToolMode> toolMode, BuildConfiguration::BuildType buildType)
3426 {
3427     if (buildType == BuildConfiguration::Unknown)
3428         return true;
3429     if (buildType == BuildConfiguration::Debug && (toolMode & DebugMode))
3430         return true;
3431     if (buildType == BuildConfiguration::Release && (toolMode & ReleaseMode))
3432         return true;
3433     if (buildType == BuildConfiguration::Profile && (toolMode & ProfileMode))
3434         return true;
3435     return false;
3436 }
3437 
3438 RunConfiguration *startupRunConfiguration()
3439 {
3440     if (Project *pro = SessionManager::startupProject()) {
3441         if (const Target *target = pro->activeTarget())
3442             return target->activeRunConfiguration();
3443     }
3444     return nullptr;
3445 }
3446 
3447 static BuildConfiguration::BuildType startupBuildType()
3448 {
3449     BuildConfiguration::BuildType buildType = BuildConfiguration::Unknown;
3450     if (RunConfiguration *runConfig = startupRunConfiguration()) {
3451         if (const BuildConfiguration *buildConfig = runConfig->target()->activeBuildConfiguration())
3452             buildType = buildConfig->buildType();
3453     }
3454     return buildType;
3455 }
3456 
3457 void showCannotStartDialog(const QString &text)
3458 {
3459     QMessageBox *errorDialog = new QMessageBox(ICore::mainWindow());
3460     errorDialog->setIcon(QMessageBox::Warning);
3461     errorDialog->setWindowTitle(text);
3462     errorDialog->setText(DebuggerPlugin::tr("Cannot start %1 without a project. Please open the project "
3463                                                "and try again.").arg(text));
3464     errorDialog->setStandardButtons(QMessageBox::Ok);
3465     errorDialog->setDefaultButton(QMessageBox::Ok);
3466     errorDialog->show();
3467 }
3468 
3469 bool wantRunTool(ToolMode toolMode, const QString &toolName)
3470 {
3471     // Check the project for whether the build config is in the correct mode
3472     // if not, notify the user and urge him to use the correct mode.
3473     BuildConfiguration::BuildType buildType = startupBuildType();
3474     if (!buildTypeAccepted(toolMode, buildType)) {
3475         QString currentMode;
3476         switch (buildType) {
3477             case BuildConfiguration::Debug:
3478                 currentMode = DebuggerPlugin::tr("Debug");
3479                 break;
3480             case BuildConfiguration::Profile:
3481                 currentMode = DebuggerPlugin::tr("Profile");
3482                 break;
3483             case BuildConfiguration::Release:
3484                 currentMode = DebuggerPlugin::tr("Release");
3485                 break;
3486             default:
3487                 QTC_CHECK(false);
3488         }
3489 
3490         QString toolModeString;
3491         switch (toolMode) {
3492             case DebugMode:
3493                 toolModeString = DebuggerPlugin::tr("in Debug mode");
3494                 break;
3495             case ProfileMode:
3496                 toolModeString = DebuggerPlugin::tr("in Profile mode");
3497                 break;
3498             case ReleaseMode:
3499                 toolModeString = DebuggerPlugin::tr("in Release mode");
3500                 break;
3501             case SymbolsMode:
3502                 toolModeString = DebuggerPlugin::tr("with debug symbols (Debug or Profile mode)");
3503                 break;
3504             case OptimizedMode:
3505                 toolModeString = DebuggerPlugin::tr("on optimized code (Profile or Release mode)");
3506                 break;
3507             default:
3508                 QTC_CHECK(false);
3509         }
3510         const QString title = DebuggerPlugin::tr("Run %1 in %2 Mode?").arg(toolName).arg(currentMode);
3511         const QString message = DebuggerPlugin::tr("<html><head/><body><p>You are trying "
3512             "to run the tool \"%1\" on an application in %2 mode. "
3513             "The tool is designed to be used %3.</p><p>"
3514             "Run-time characteristics differ significantly between "
3515             "optimized and non-optimized binaries. Analytical "
3516             "findings for one mode may or may not be relevant for "
3517             "the other.</p><p>"
3518             "Running tools that need debug symbols on binaries that "
3519             "don't provide any may lead to missing function names "
3520             "or otherwise insufficient output.</p><p>"
3521             "Do you want to continue and run the tool in %2 mode?</p></body></html>")
3522                 .arg(toolName).arg(currentMode).arg(toolModeString);
3523         if (Utils::CheckableMessageBox::doNotAskAgainQuestion(ICore::mainWindow(),
3524                 title, message, ICore::settings(), QLatin1String("AnalyzerCorrectModeWarning"))
3525                     != QDialogButtonBox::Yes)
3526             return false;
3527     }
3528 
3529     return true;
3530 }
3531 
3532 void registerAction(Id runMode, const RunControlCreator &runControlCreator)
3533 {
3534     dd->m_runControlCreators.insert(runMode, runControlCreator);
3535 }
3536 
3537 void registerToolbar(const QByteArray &perspectiveId, const ToolbarDescription &desc)
3538 {
3539     auto toolbar = new QWidget;
3540     toolbar->setObjectName(QString::fromLatin1(perspectiveId + ".Toolbar"));
3541     auto hbox = new QHBoxLayout(toolbar);
3542     hbox->setMargin(0);
3543     hbox->setSpacing(0);
3544     for (QWidget *widget : desc.widgets())
3545         hbox->addWidget(widget);
3546     hbox->addStretch();
3547     toolbar->setLayout(hbox);
3548 
3549     dd->m_mainWindow->registerToolbar(perspectiveId, toolbar);
3550 }
3551 
3552 QAction *createStartAction()
3553 {
3554     auto action = new QAction(DebuggerMainWindow::tr("Start"), DebuggerPlugin::instance());
3555     action->setIcon(ProjectExplorer::Icons::ANALYZER_START_SMALL_TOOLBAR.icon());
3556     action->setEnabled(true);
3557     return action;
3558 }
3559 
3560 QAction *createStopAction()
3561 {
3562     auto action = new QAction(DebuggerMainWindow::tr("Stop"), DebuggerPlugin::instance());
3563     action->setIcon(Utils::Icons::STOP_SMALL_TOOLBAR.icon());
3564     action->setEnabled(true);
3565     return action;
3566 }
3567 
3568 void registerPerspective(const QByteArray &perspectiveId, const Perspective *perspective)
3569 {
3570     dd->m_mainWindow->registerPerspective(perspectiveId, perspective);
3571 }
3572 
3573 void selectPerspective(const QByteArray &perspectiveId)
3574 {
3575     if (dd->m_mainWindow->currentPerspective() == perspectiveId)
3576         return;
3577 
3578     // FIXME: Work-around aslong as the GammaRay integration does not use the same setup,
3579     if (perspectiveId.isEmpty())
3580         return;
3581     ModeManager::activateMode(MODE_DEBUG);
3582     dd->m_mainWindow->restorePerspective(perspectiveId);
3583 }
3584 
3585 QByteArray currentPerspective()
3586 {
3587     return dd->m_mainWindow->currentPerspective();
3588 }
3589 
3590 QWidget *mainWindow()
3591 {
3592     return dd->m_mainWindow;
3593 }
3594 
3595 void enableMainWindow(bool on)
3596 {
3597     dd->m_mainWindow->setEnabled(on);
3598 }
3599 
3600 void showStatusMessage(const QString &message, int timeoutMS)
3601 {
3602     dd->m_mainWindow->showStatusMessage(message, timeoutMS);
3603 }
3604 
3605 void showPermanentStatusMessage(const QString &message)
3606 {
3607     dd->m_mainWindow->showStatusMessage(message, -1);
3608 }
3609 
3610 RunControl *createAnalyzerRunControl(RunConfiguration *runConfiguration, Id runMode)
3611 {
3612     RunControlCreator rcc = dd->m_runControlCreators.value(runMode);
3613     if (rcc)
3614         return rcc(runConfiguration, runMode);
3615     return nullptr;
3616 }
3617 
3618 namespace Internal {
3619 
3620 static bool s_testRun = false;
3621 bool isTestRun() { return s_testRun; }
3622 
3623 #ifdef WITH_TESTS
3624 
3625 class DebuggerUnitTests : public QObject
3626 {
3627     Q_OBJECT
3628 
3629 public:
3630     DebuggerUnitTests() {}
3631 
3632 private slots:
3633     void initTestCase();
3634     void cleanupTestCase();
3635 
3636     void testDebuggerMatching_data();
3637     void testDebuggerMatching();
3638 
3639     void testBenchmark();
3640     void testStateMachine();
3641 
3642 private:
3643     CppTools::Tests::TemporaryCopiedDir *m_tmpDir = 0;
3644 };
3645 
3646 void DebuggerUnitTests::initTestCase()
3647 {
3648 //    const QList<Kit *> allKits = KitManager::kits();
3649 //    if (allKits.count() != 1)
3650 //        QSKIP("This test requires exactly one kit to be present");
3651 //    const ToolChain * const toolchain = ToolChainKitInformation::toolChain(allKits.first());
3652 //    if (!toolchain)
3653 //        QSKIP("This test requires that there is a kit with a toolchain.");
3654 //    bool hasClangExecutable;
3655 //    clangExecutableFromSettings(toolchain->typeId(), &hasClangExecutable);
3656 //    if (!hasClangExecutable)
3657 //        QSKIP("No clang suitable for analyzing found");
3658 
3659     s_testRun = true;
3660     m_tmpDir = new CppTools::Tests::TemporaryCopiedDir(QLatin1String(":/unit-tests"));
3661     QVERIFY(m_tmpDir->isValid());
3662 }
3663 
3664 void DebuggerUnitTests::cleanupTestCase()
3665 {
3666     delete m_tmpDir;
3667 }
3668 
3669 void DebuggerUnitTests::testStateMachine()
3670 {
3671     QString proFile = m_tmpDir->absolutePath("simple/simple.pro");
3672 
3673     CppTools::Tests::ProjectOpenerAndCloser projectManager;
3674     const CppTools::ProjectInfo projectInfo = projectManager.open(proFile, true);
3675     QVERIFY(projectInfo.isValid());
3676 
3677     QEventLoop loop;
3678     connect(BuildManager::instance(), &BuildManager::buildQueueFinished,
3679             &loop, &QEventLoop::quit);
3680     ProjectExplorerPlugin::buildProject(SessionManager::startupProject());
3681     loop.exec();
3682 
3683     ExecuteOnDestruction guard([] () {
3684         EditorManager::closeAllEditors(false);
3685     });
3686     DebuggerRunParameters rp;
3687     Target *t = SessionManager::startupProject()->activeTarget();
3688     QVERIFY(t);
3689     RunConfiguration *rc = t->activeRunConfiguration();
3690     QVERIFY(rc);
3691     rp.inferior = rc->runnable().as<StandardRunnable>();
3692     rp.testCase = TestNoBoundsOfCurrentFunction;
3693 
3694     auto runControl = new RunControl(rc, ProjectExplorer::Constants::DEBUG_RUN_MODE);
3695     (void) new DebuggerRunTool(runControl, rp);
3696     ProjectExplorerPlugin::startRunControl(runControl);
3697 
3698     connect(runControl, &RunControl::finished, this, [this] {
3699         QTestEventLoop::instance().exitLoop();
3700     });
3701 
3702     QTestEventLoop::instance().enterLoop(5);
3703 }
3704 
3705 
3706 enum FakeEnum { FakeDebuggerCommonSettingsId };
3707 
3708 void DebuggerUnitTests::testBenchmark()
3709 {
3710 #ifdef WITH_BENCHMARK
3711     CALLGRIND_START_INSTRUMENTATION;
3712     volatile Id id1 = Id(DEBUGGER_COMMON_SETTINGS_ID);
3713     CALLGRIND_STOP_INSTRUMENTATION;
3714     CALLGRIND_DUMP_STATS;
3715 
3716     CALLGRIND_START_INSTRUMENTATION;
3717     volatile FakeEnum id2 = FakeDebuggerCommonSettingsId;
3718     CALLGRIND_STOP_INSTRUMENTATION;
3719     CALLGRIND_DUMP_STATS;
3720 #endif
3721 }
3722 
3723 void DebuggerUnitTests::testDebuggerMatching_data()
3724 {
3725     QTest::addColumn<QStringList>("debugger");
3726     QTest::addColumn<QString>("target");
3727     QTest::addColumn<int>("result");
3728 
3729     QTest::newRow("Invalid data")
3730             << QStringList()
3731             << QString()
3732             << int(DebuggerItem::DoesNotMatch);
3733     QTest::newRow("Invalid debugger")
3734             << QStringList()
3735             << QString::fromLatin1("x86-linux-generic-elf-32bit")
3736             << int(DebuggerItem::DoesNotMatch);
3737     QTest::newRow("Invalid target")
3738             << QStringList("x86-linux-generic-elf-32bit")
3739             << QString()
3740             << int(DebuggerItem::DoesNotMatch);
3741 
3742     QTest::newRow("Fuzzy match 1")
3743             << QStringList("unknown-unknown-unknown-unknown-0bit")
3744             << QString::fromLatin1("x86-linux-generic-elf-32bit")
3745             << int(DebuggerItem::MatchesWell); // Is this the expected behavior?
3746     QTest::newRow("Fuzzy match 2")
3747             << QStringList("unknown-unknown-unknown-unknown-0bit")
3748             << QString::fromLatin1("arm-windows-msys-pe-64bit")
3749             << int(DebuggerItem::MatchesWell); // Is this the expected behavior?
3750 
3751     QTest::newRow("Architecture mismatch")
3752             << QStringList("x86-linux-generic-elf-32bit")
3753             << QString::fromLatin1("arm-linux-generic-elf-32bit")
3754             << int(DebuggerItem::DoesNotMatch);
3755     QTest::newRow("OS mismatch")
3756             << QStringList("x86-linux-generic-elf-32bit")
3757             << QString::fromLatin1("x86-macosx-generic-elf-32bit")
3758             << int(DebuggerItem::DoesNotMatch);
3759     QTest::newRow("Format mismatch")
3760             << QStringList("x86-linux-generic-elf-32bit")
3761             << QString::fromLatin1("x86-linux-generic-pe-32bit")
3762             << int(DebuggerItem::DoesNotMatch);
3763 
3764     QTest::newRow("Linux perfect match")
3765             << QStringList("x86-linux-generic-elf-32bit")
3766             << QString::fromLatin1("x86-linux-generic-elf-32bit")
3767             << int(DebuggerItem::MatchesWell);
3768     QTest::newRow("Linux match")
3769             << QStringList("x86-linux-generic-elf-64bit")
3770             << QString::fromLatin1("x86-linux-generic-elf-32bit")
3771             << int(DebuggerItem::MatchesSomewhat);
3772 
3773     QTest::newRow("Windows perfect match 1")
3774             << QStringList("x86-windows-msvc2013-pe-64bit")
3775             << QString::fromLatin1("x86-windows-msvc2013-pe-64bit")
3776             << int(DebuggerItem::MatchesWell);
3777     QTest::newRow("Windows perfect match 2")
3778             << QStringList("x86-windows-msvc2013-pe-64bit")
3779             << QString::fromLatin1("x86-windows-msvc2012-pe-64bit")
3780             << int(DebuggerItem::MatchesWell);
3781     QTest::newRow("Windows match 1")
3782             << QStringList("x86-windows-msvc2013-pe-64bit")
3783             << QString::fromLatin1("x86-windows-msvc2013-pe-32bit")
3784             << int(DebuggerItem::MatchesSomewhat);
3785     QTest::newRow("Windows match 2")
3786             << QStringList("x86-windows-msvc2013-pe-64bit")
3787             << QString::fromLatin1("x86-windows-msvc2012-pe-32bit")
3788             << int(DebuggerItem::MatchesSomewhat);
3789     QTest::newRow("Windows mismatch on word size")
3790             << QStringList("x86-windows-msvc2013-pe-32bit")
3791             << QString::fromLatin1("x86-windows-msvc2013-pe-64bit")
3792             << int(DebuggerItem::DoesNotMatch);
3793     QTest::newRow("Windows mismatch on osflavor 1")
3794             << QStringList("x86-windows-msvc2013-pe-32bit")
3795             << QString::fromLatin1("x86-windows-msys-pe-64bit")
3796             << int(DebuggerItem::DoesNotMatch);
3797     QTest::newRow("Windows mismatch on osflavor 2")
3798             << QStringList("x86-windows-msys-pe-32bit")
3799             << QString::fromLatin1("x86-windows-msvc2010-pe-64bit")
3800             << int(DebuggerItem::DoesNotMatch);
3801 }
3802 
3803 void DebuggerUnitTests::testDebuggerMatching()
3804 {
3805     QFETCH(QStringList, debugger);
3806     QFETCH(QString, target);
3807     QFETCH(int, result);
3808 
3809     DebuggerItem::MatchLevel expectedLevel = static_cast<DebuggerItem::MatchLevel>(result);
3810 
3811     QList<Abi> debuggerAbis;
3812     foreach (const QString &abi, debugger)
3813         debuggerAbis << Abi(abi);
3814 
3815     DebuggerItem item;
3816     item.setAbis(debuggerAbis);
3817 
3818     DebuggerItem::MatchLevel level = item.matchTarget(Abi(target));
3819     if (level == DebuggerItem::MatchesPerfectly)
3820         level = DebuggerItem::MatchesWell;
3821 
3822     QCOMPARE(expectedLevel, level);
3823 }
3824 
3825 
3826 QList<QObject *> DebuggerPlugin::createTestObjects() const
3827 {
3828     return {new DebuggerUnitTests};
3829 }
3830 
3831 #else // ^-- if WITH_TESTS else --v
3832 
3833 QList<QObject *> DebuggerPlugin::createTestObjects() const
3834 {
3835     return {};
3836 }
3837 
3838 #endif // if  WITH_TESTS
3839 
3840 } // namespace Internal
3841 
3842 void *AnalyzerConnection::staticTypeId = &AnalyzerConnection::staticTypeId;
3843 
3844 } // namespace Debugger
3845 
3846 #include "debuggerplugin.moc"
