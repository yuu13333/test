Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2013 Klaralvdalens Datakonsult AB (KDAB)
4 ** Copyright (C) 2016 The Qt Company Ltd.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtOpenGL module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 **
40 ** This file was generated by glgen version 0.1
41 ** Command line was: glgen
42 **
43 ** glgen is Copyright (C) 2013 Klaralvdalens Datakonsult AB (KDAB)
44 **
45 ** This is an auto-generated file.
46 ** Do not edit! All changes made to it will be lost.
47 **
48 ****************************************************************************/
49 
50 #include "qopenglversionfunctions.h"
51 #include "qopenglversionfunctions_p.h"
52 #include "qopenglcontext.h"
53 #include "qdebug.h"
54 
55 QT_BEGIN_NAMESPACE
56 
57 QOpenGLContextVersionData::~QOpenGLContextVersionData()
58 {
59     for (auto *f : qAsConst(externalFunctions)) {
60         auto *fp = QAbstractOpenGLFunctionsPrivate::get(f);
61         fp->owningContext = nullptr;
62         fp->initialized = false;
63     }
64     externalFunctions.clear();
65     qDeleteAll(functions);
66     functions.clear();
67 }
68 
69 QOpenGLContextVersionData *QOpenGLContextVersionData::forContext(QOpenGLContext *context)
70 {
71     auto *data = contextData.value(context);
72     if (!data) {
73         data = new QOpenGLContextVersionData;
74         // The data will live as long as the context. It could potentially be an opaque pointer
75         // member of QOpenGLContextPrivate, but this avoids polluting QOpenGLContext with version
76         // functions specifics
77         QObject::connect(context, &QObject::destroyed, context, [data](){ delete data; }, Qt::DirectConnection);
78         contextData[context] = data;
79     }
80     return data;
81 }
82 
83 QMap<QOpenGLContext *, QOpenGLContextVersionData *> QOpenGLContextVersionData::contextData;
84 
85 #define QT_OPENGL_COUNT_FUNCTIONS(ret, name, args) +1
86 #define QT_OPENGL_FUNCTION_NAMES(ret, name, args) \
87     "gl"#name"\0"
88 #define QT_OPENGL_IMPLEMENT(CLASS, FUNCTIONS) \
89 void CLASS::init() \
90 { \
91     const char *names = FUNCTIONS(QT_OPENGL_FUNCTION_NAMES); \
92     const char *name = names; \
93     for (int i = 0; i < FUNCTIONS(QT_OPENGL_COUNT_FUNCTIONS); ++i) { \
94         functions[i] = context->getProcAddress(name); \
95         name += strlen(name) + 1; \
96     } \
97 }
98 
99 QOpenGLVersionFunctionsStorage::QOpenGLVersionFunctionsStorage()
100     : backends(nullptr)
101 {
102 }
103 
104 QOpenGLVersionFunctionsStorage::~QOpenGLVersionFunctionsStorage()
105 {
106 #ifndef QT_OPENGL_ES
107     if (backends) {
108 
109         int i = 0;
110 
111 #define DELETE_BACKEND(X) \
112         if (backends[i] && !--backends[i]->refs) \
113             delete static_cast<QOpenGLFunctions_##X##Backend*>(backends[i]); \
114         ++i;
115 
116         QT_OPENGL_VERSIONS(DELETE_BACKEND)
117 #undef DELETE_BACKEND
118         delete[] backends;
119     }
120 #endif
121 }
122 
123 QOpenGLVersionFunctionsBackend *QOpenGLVersionFunctionsStorage::backend(QOpenGLContext *context, QOpenGLVersionFunctionsBackend::Version v)
124 {
125 #ifdef QT_OPENGL_ES
126     Q_UNUSED(context);
127     Q_UNUSED(v);
128     return 0;
129 #else
130     if (!backends) {
131         backends = new QOpenGLVersionFunctionsBackend *[QOpenGLVersionFunctionsBackend::OpenGLVersionBackendCount];
132         memset(backends, 0, sizeof(QOpenGLVersionFunctionsBackend *)*QOpenGLVersionFunctionsBackend::OpenGLVersionBackendCount);
133     }
134     if (backends[v])
135         return backends[v];
136 
137     switch(v) {
138 #define VERSION_ENUM(X) QOpenGLVersionFunctionsBackend::OpenGL_##X
139 #define CREATE_BACKEND(X) \
140     case VERSION_ENUM(X): \
141         backends[VERSION_ENUM(X)] = new QOpenGLFunctions_##X##Backend(context); \
142         break;
143     QT_OPENGL_VERSIONS(CREATE_BACKEND)
144     case QOpenGLVersionFunctionsBackend::OpenGLVersionBackendCount:
145         Q_UNREACHABLE();
146     }
147     // the storage keeps one ref
148     ++backends[v]->refs;
149     return backends[v];
150 #endif
151 }
152 
153 QOpenGLVersionFunctionsBackend *QAbstractOpenGLFunctionsPrivate::functionsBackend(QOpenGLContext *context, QOpenGLVersionFunctionsBackend::Version v)
154 {
155     Q_ASSERT(context);
156     return QOpenGLContextVersionData::forContext(context)->functionsStorage.backend(context, v);
157 }
158 
159 void QAbstractOpenGLFunctionsPrivate::insertExternalFunctions(QOpenGLContext *context, QAbstractOpenGLFunctions *f)
160 {
161     Q_ASSERT(context);
162     QOpenGLContextVersionData::forContext(context)->externalFunctions.insert(f);
163 }
164 
165 void QAbstractOpenGLFunctionsPrivate::removeExternalFunctions(QOpenGLContext *context, QAbstractOpenGLFunctions *f)
166 {
167     Q_ASSERT(context);
168     QOpenGLContextVersionData::forContext(context)->externalFunctions.remove(f);
169 }
170 
171 /*!
172     \class QAbstractOpenGLFunctions
173     \inmodule QtOpenGL
174     \since 5.1
175     \brief The QAbstractOpenGLFunctions class is the base class of a family of
176            classes that expose all functions for each OpenGL version and
177            profile.
178 
179     OpenGL implementations on different platforms are able to link to a variable
180     number of OpenGL functions depending upon the OpenGL ABI on that platform.
181     For example, on Microsoft Windows only functions up to those in OpenGL 1.1
182     can be linked to at build time. All other functions must be resolved at
183     runtime. The traditional solution to this has been to use either
184     QOpenGLContext::getProcAddress() or QOpenGLFunctions. The former is tedious
185     and error prone and means dealing directly with function pointers. The
186     latter only exposes those functions common to OpenGL ES 2 and desktop
187     OpenGL. There is however much new OpenGL functionality that is useful when
188     writing real world OpenGL applications.
189 
190     Qt now provides a family of classes which all inherit from
191     QAbstractOpenGLFunctions which expose every core OpenGL function by way of a
192     corresponding member function. There is a class for every valid combination
193     of OpenGL version and profile. Each class follows the naming convention:
194     \badcode
195     QOpenGLFunctions_<MAJOR VERSION>_<MINOR VERSION>[_PROFILE]
196     \endcode
197 
198     For OpenGL versions 1.0 through to 3.0 there are no profiles, leading to the
199     classes:
200 
201     \list
202         \li QOpenGLFunctions_1_0
203         \li QOpenGLFunctions_1_1
204         \li QOpenGLFunctions_1_2
205         \li QOpenGLFunctions_1_3
206         \li QOpenGLFunctions_1_4
207         \li QOpenGLFunctions_1_5
208         \li QOpenGLFunctions_2_0
209         \li QOpenGLFunctions_2_1
210         \li QOpenGLFunctions_3_0
211     \endlist
212 
213     where each class inherits from QAbstractOpenGLFunctions.
214 
215     OpenGL version 3.1 removed many deprecated functions leading to a much
216     simpler and generic API.
217 
218     With OpenGL 3.2 the concept of profiles was introduced. Two profiles are
219     currently defined for OpenGL: Core and Compatibility.
220 
221     The Core profile does not include any of the functions that were removed
222     in OpenGL 3.1. The Compatibility profile contains all functions in the
223     Core profile of the same version plus all of the functions that were
224     removed in OpenGL 3.1. In this way the Compatibility profile classes allow
225     use of newer OpenGL functionality but also allows you to keep using your
226     legacy OpenGL code. For new OpenGL code the Core profile should be
227     preferred.
228 
229     Please note that some vendors, notably Apple, do not implement the
230     Compatibility profile. Therefore if you wish to target new OpenGL features
231     on \macos then you should ensure that you request a Core profile context via
232     QSurfaceFormat::setProfile().
233 
234     Qt provides classes for all version and Core and Compatibility profile
235     combinations. The classes for OpenGL versions 3.1 through to 4.3 are:
236 
237     \list
238         \li QOpenGLFunctions_3_1
239         \li QOpenGLFunctions_3_2_Core
240         \li QOpenGLFunctions_3_2_Compatibility
241         \li QOpenGLFunctions_3_3_Core
242         \li QOpenGLFunctions_3_3_Compatibility
243         \li QOpenGLFunctions_4_0_Core
244         \li QOpenGLFunctions_4_0_Compatibility
245         \li QOpenGLFunctions_4_1_Core
246         \li QOpenGLFunctions_4_1_Compatibility
247         \li QOpenGLFunctions_4_2_Core
248         \li QOpenGLFunctions_4_2_Compatibility
249         \li QOpenGLFunctions_4_3_Core
250         \li QOpenGLFunctions_4_3_Compatibility
251     \endlist
252 
253     where each class inherits from QAbstractOpenGLFunctions.
254 
255     A pointer to an object of the class corresponding to the version and
256     profile of OpenGL in use can be obtained from
257     QOpenGLContext::versionFunctions(). If obtained in this way, note that
258     the QOpenGLContext retains ownership of the object. This is so that only
259     one instance need be created.
260 
261     Before calling any of the exposed OpenGL functions you must ensure that the
262     object has resolved the function pointers to the OpenGL functions. This
263     only needs to be done once per instance with initializeOpenGLFunctions().
264     Once initialized, the object can be used to call any OpenGL function for
265     the corresponding version and profile. Note that initializeOpenGLFunctions()
266     can fail in some circumstances so check the return value. Situations in
267     which initialization can fail are if you have a functions object for a version
268     or profile that contains functions that are not part of the context being
269     used to resolve the function pointers.
270 
271     If you exclusively use function objects then you will get compile time
272     errors if you attempt to use a function not included in that version and
273     profile. This is obviously a lot easier to debug than undefined behavior
274     at run time.
275 
276     \sa QOpenGLContext::versionFunctions()
277 */
278 /*!
279    Constructs a QAbstractOpenGLFunctions object.
280 */
281 QAbstractOpenGLFunctions::QAbstractOpenGLFunctions()
282     : d_ptr(new QAbstractOpenGLFunctionsPrivate)
283 {
284 }
285 
286 /*!
287    Destroys a QAbstractOpenGLFunctions object.
288 */
289 QAbstractOpenGLFunctions::~QAbstractOpenGLFunctions()
290 {
291     Q_D(QAbstractOpenGLFunctions);
292     if (d->owningContext)
293         d->removeExternalFunctions(d->owningContext, this);
294     delete d_ptr;
295 }
296 
297 /*! \internal
298  */
299 bool QAbstractOpenGLFunctions::initializeOpenGLFunctions()
300 {
301     Q_D(QAbstractOpenGLFunctions);
302     d->initialized = true;
303 
304     // For a subclass whose instance is not created via
305     // QOpenGLContext::versionFunctions() owningContext is not set. Set it now
306     // and register such instances to the context as external ones. These are
307     // not owned by the context but still need certain cleanup when the context
308     // is destroyed.
309     if (!d->owningContext) {
310         d->owningContext = QOpenGLContext::currentContext();
311         if (d->owningContext)
312             d->insertExternalFunctions(d->owningContext, this);
313     }
314 
315     return true;
316 }
317 
318 /*! \internal
319  */
320 bool QAbstractOpenGLFunctions::isInitialized() const
321 {
322     Q_D(const QAbstractOpenGLFunctions);
323     return d->initialized;
324 }
325 
326 /*! \internal
327  */
328 void QAbstractOpenGLFunctions::setOwningContext(const QOpenGLContext *context)
329 {
330     Q_D(QAbstractOpenGLFunctions);
331     d->owningContext = const_cast<QOpenGLContext*>(context);
332 }
333 
334 /*! \internal
335  */
336 QOpenGLContext *QAbstractOpenGLFunctions::owningContext() const
337 {
338     Q_D(const QAbstractOpenGLFunctions);
339     return d->owningContext;
340 }
341 
342 #if !defined(QT_OPENGL_ES_2)
343 
344 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_0_CoreBackend, QT_OPENGL_1_0_FUNCTIONS)
345 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_1_CoreBackend, QT_OPENGL_1_1_FUNCTIONS)
346 
347 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_2_CoreBackend, QT_OPENGL_1_2_FUNCTIONS)
348 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_3_CoreBackend, QT_OPENGL_1_3_FUNCTIONS)
349 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_4_CoreBackend, QT_OPENGL_1_4_FUNCTIONS)
350 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_5_CoreBackend, QT_OPENGL_1_5_FUNCTIONS)
351 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_2_0_CoreBackend, QT_OPENGL_2_0_FUNCTIONS)
352 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_2_1_CoreBackend, QT_OPENGL_2_1_FUNCTIONS)
353 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_3_0_CoreBackend, QT_OPENGL_3_0_FUNCTIONS)
354 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_3_1_CoreBackend, QT_OPENGL_3_1_FUNCTIONS)
355 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_3_2_CoreBackend, QT_OPENGL_3_2_FUNCTIONS)
356 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_3_3_CoreBackend, QT_OPENGL_3_3_FUNCTIONS)
357 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_4_0_CoreBackend, QT_OPENGL_4_0_FUNCTIONS)
358 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_4_1_CoreBackend, QT_OPENGL_4_1_FUNCTIONS)
359 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_4_2_CoreBackend, QT_OPENGL_4_2_FUNCTIONS)
360 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_4_3_CoreBackend, QT_OPENGL_4_3_FUNCTIONS)
361 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_4_4_CoreBackend, QT_OPENGL_4_4_FUNCTIONS)
362 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_4_5_CoreBackend, QT_OPENGL_4_5_FUNCTIONS)
363 
364 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_0_DeprecatedBackend, QT_OPENGL_1_0_DEPRECATED_FUNCTIONS)
365 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_1_DeprecatedBackend, QT_OPENGL_1_1_DEPRECATED_FUNCTIONS)
366 
367 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_2_DeprecatedBackend, QT_OPENGL_1_2_DEPRECATED_FUNCTIONS)
368 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_3_DeprecatedBackend, QT_OPENGL_1_3_DEPRECATED_FUNCTIONS)
369 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_1_4_DeprecatedBackend, QT_OPENGL_1_4_DEPRECATED_FUNCTIONS)
370 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_2_0_DeprecatedBackend, QT_OPENGL_2_0_DEPRECATED_FUNCTIONS)
371 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_3_0_DeprecatedBackend, QT_OPENGL_3_0_DEPRECATED_FUNCTIONS)
372 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_3_3_DeprecatedBackend, QT_OPENGL_3_3_DEPRECATED_FUNCTIONS)
373 QT_OPENGL_IMPLEMENT(QOpenGLFunctions_4_5_DeprecatedBackend, QT_OPENGL_4_5_DEPRECATED_FUNCTIONS)
374 
375 #else
376 
377 // No backends for OpenGL ES 2
378 
379 #endif // !QT_OPENGL_ES_2
380 
381 QT_END_NAMESPACE
