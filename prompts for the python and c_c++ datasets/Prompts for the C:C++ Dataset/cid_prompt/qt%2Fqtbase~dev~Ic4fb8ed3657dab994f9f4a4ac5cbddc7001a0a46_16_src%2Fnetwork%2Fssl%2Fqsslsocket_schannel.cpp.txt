Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2018 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtNetwork module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qsslsocket.h"
41 #include "qsslsocket_schannel_p.h"
42 #include "qsslcertificate.h"
43 #include "qsslcertificateextension.h"
44 #include "qsslcertificate_p.h"
45 #include "qsslcipher_p.h"
46 
47 #include <QtCore/qscopeguard.h>
48 #include <QtCore/qoperatingsystemversion.h>
49 #include <QtCore/qregularexpression.h>
50 #include <QtCore/qdatastream.h>
51 
52 #define SECURITY_WIN32
53 #include <security.h>
54 #include <schnlsp.h>
55 
56 // Not defined in MinGW
57 #ifndef SECBUFFER_ALERT
58 #define SECBUFFER_ALERT 17
59 #endif
60 #ifndef SECPKG_ATTR_APPLICATION_PROTOCOL
61 #define SECPKG_ATTR_APPLICATION_PROTOCOL 35
62 #endif
63 
64 // Also not defined in MinGW.......
65 #ifndef SP_PROT_TLS1_SERVER
66 #define SP_PROT_TLS1_SERVER 0x00000040
67 #endif
68 #ifndef SP_PROT_TLS1_CLIENT
69 #define SP_PROT_TLS1_CLIENT 0x00000080
70 #endif
71 #ifndef SP_PROT_TLS1_0_SERVER
72 #define SP_PROT_TLS1_0_SERVER SP_PROT_TLS1_SERVER
73 #endif
74 #ifndef SP_PROT_TLS1_0_CLIENT
75 #define SP_PROT_TLS1_0_CLIENT SP_PROT_TLS1_CLIENT
76 #endif
77 #ifndef SP_PROT_TLS1_0
78 #define SP_PROT_TLS1_0 (SP_PROT_TLS1_0_CLIENT | SP_PROT_TLS1_0_SERVER)
79 #endif
80 #ifndef SP_PROT_TLS1_1_SERVER
81 #define SP_PROT_TLS1_1_SERVER 0x00000100
82 #endif
83 #ifndef SP_PROT_TLS1_1_CLIENT
84 #define SP_PROT_TLS1_1_CLIENT 0x00000200
85 #endif
86 #ifndef SP_PROT_TLS1_1
87 #define SP_PROT_TLS1_1 (SP_PROT_TLS1_1_CLIENT | SP_PROT_TLS1_1_SERVER)
88 #endif
89 #ifndef SP_PROT_TLS1_2_SERVER
90 #define SP_PROT_TLS1_2_SERVER 0x00000400
91 #endif
92 #ifndef SP_PROT_TLS1_2_CLIENT
93 #define SP_PROT_TLS1_2_CLIENT 0x00000800
94 #endif
95 #ifndef SP_PROT_TLS1_2
96 #define SP_PROT_TLS1_2 (SP_PROT_TLS1_2_CLIENT | SP_PROT_TLS1_2_SERVER)
97 #endif
98 #ifndef SP_PROT_TLS1_3_SERVER
99 #define SP_PROT_TLS1_3_SERVER 0x00001000
100 #endif
101 #ifndef SP_PROT_TLS1_3_CLIENT
102 #define SP_PROT_TLS1_3_CLIENT 0x00002000
103 #endif
104 #ifndef SP_PROT_TLS1_3
105 #define SP_PROT_TLS1_3 (SP_PROT_TLS1_3_CLIENT | SP_PROT_TLS1_3_SERVER)
106 #endif
107 
108 #undef Q_UNIMPLEMENTED // @temp: remove, just want better output
109 #define Q_UNIMPLEMENTED() qWarning() << __func__ << "is not implemented"
110 
111 /*
112     @todo list:
113 
114     High(?) priority:
115     - Send certificate chain/intermediate certificates!!
116         - No documentation on how to send the chain
117         - A stackoverflow question on this from 3 years ago implies schannel only sends intermediate
118             certificates if it's "in the system or user certificate store".
119                 - https://stackoverflow.com/q/30156584/2493610
120                 - Need to test if this actually works
121                     - Tested: It works. But pollutes the system store.
122         - I'd like to avoid 'polluting' the system/user store, even if temporarily (temporarily
123             storing certificates in the system store relies on a clean exit to remove the certificates).
124 
125     Medium priority:
126     - Setting cipher-suites (or ALG_ID)
127         - People have survived without it in WinRT
128     - peerCertificateChain() is different in Schannel in that it includes the entire chain, not just
129         the certificates that the peer sent. This means the root certificate is found in this chain.
130         Which I would argue makes sense for a list whose purpose is displaying the chain.
131         But this should be up for discussion. Relevant (support-reported) bug: QTBUG-20119
132 
133     Low priority:
134     - Possibly make RAII wrappers for SecBuffer (which I commonly create QScopeGuards for)
135     - Perform the '@future' optimization in "transmit()"
136 
137     @future!:
138 
139     - PSK support
140         - Was added in Windows 10 (it seems), documentation at time of writing is sparse/non-existent.
141             - Specifically about how to supply credentials when they're requested.
142             - Or how to recognize that they're requested in the first place.
143         - Skip certificate verification.
144         - Check if "PSK-only" is still required to do PSK _at all_ (all-around bad solution).
145         - Check if SEC_I_INCOMPLETE_CREDENTIALS is still returned for both "missing certificate" and
146             "missing PSK" when calling InitializeSecurityContext in "doStep2".
147 
148     *** Things that need to be documented ***
149 
150     About PeerVerifyMode (copied from somewhere in this code):
151     QueryPeer can (currently) not work in Schannel since Schannel itself doesn't have a way to
152     ask for a certificate and then still be OK if it's not received.
153     To work around this we don't request a certificate at all for QueryPeer.
154     For servers AutoVerifyPeer is supposed to be treated the same as QueryPeer. This means that
155     servers using Schannel will only request client certificate for "VerifyPeer".
156 
157     About PSK:
158     Not supported (at least for now).
159 */
160 
161 QT_BEGIN_NAMESPACE
162 
163 namespace {
164 SecBuffer createSecBuffer(void *ptr, unsigned long length, unsigned long bufferType)
165 {
166     return SecBuffer{
167         length,
168         bufferType,
169         ptr
170     };
171 }
172 
173 SecBuffer createSecBuffer(QByteArray &buffer, unsigned long bufferType)
174 {
175     return createSecBuffer(buffer.data(), static_cast<unsigned long>(buffer.length()), bufferType);
176 }
177 
178 void schannelError(qint32 status)
179 {
180     // @todo: make this less debugging-related
181     switch (status) {
182     case SEC_E_INSUFFICIENT_MEMORY:
183     case SEC_E_INTERNAL_ERROR:
184         qDebug() << "silly error";
185         break;
186     case SEC_E_INVALID_HANDLE:
187         qDebug() << "invalid handle";
188         break;
189 
190     case SEC_E_INVALID_TOKEN:
191         qDebug() << "invalid token";
192         break;
193     case SEC_E_LOGON_DENIED:
194     case SEC_E_NO_AUTHENTICATING_AUTHORITY:
195     case SEC_E_NO_CREDENTIALS:
196         qDebug() << "auth errors";
197         break;
198     case SEC_E_TARGET_UNKNOWN:
199         qDebug() << "target unknown";
200         break;
201     case SEC_E_UNSUPPORTED_FUNCTION:
202         qDebug() << "unsupported function";
203         break;
204     case SEC_E_WRONG_PRINCIPAL:
205         qDebug() << "wrong principal";
206         break;
207 #ifdef Q_CC_MSVC // @todo: define missing on mingw
208     case SEC_E_APPLICATION_PROTOCOL_MISMATCH:
209         qDebug() << "protocol mismatch";
210         break;
211 #endif
212     case SEC_E_ILLEGAL_MESSAGE:
213         qDebug() << "unexpected or badly formatted message received";
214         break;
215     case SEC_E_ENCRYPT_FAILURE:
216         qDebug() << "The data could not be encrypted!";
217         break;
218     case SEC_E_ALGORITHM_MISMATCH:
219         qDebug() << "Algorithm mismatch";
220         break;
221     case SEC_E_UNKNOWN_CREDENTIALS:
222         qDebug() << "unknown credentials";
223         break;
224     default:
225         qDebug() << "unknown status:" << status;
226         break;
227     }
228 }
229 
230 DWORD fromQtSslProtocol(QSsl::SslProtocol protocol)
231 {
232     DWORD protocols = 0;
233     switch (protocol) {
234     case QSsl::UnknownProtocol:
235         return 0; // no
236     case QSsl::AnyProtocol:
237         protocols = SP_PROT_SSL2 | SP_PROT_SSL3 | SP_PROT_TLS1_0
238                 | SP_PROT_TLS1_1 | SP_PROT_TLS1_2; // @future: TlsV1_3
239         break;
240     case QSsl::SslV2:
241         protocols = SP_PROT_SSL2;
242         break;
243     case QSsl::SslV3:
244         protocols = SP_PROT_SSL3;
245         break;
246     case QSsl::TlsV1SslV3:
247         protocols = (SP_PROT_SSL3 | SP_PROT_TLS1_0);
248         break;
249     case QSsl::TlsV1_0:
250         protocols = SP_PROT_TLS1_0;
251         break;
252     case QSsl::TlsV1_1:
253         protocols = SP_PROT_TLS1_1;
254         break;
255     case QSsl::TlsV1_2:
256         protocols = SP_PROT_TLS1_2;
257         break;
258     // @future: TlsV1_3
259     case QSsl::SecureProtocols: // TLS v1.0 and later is currently considered secure (@todo: can also be 0; system defaults)
260     case QSsl::TlsV1_0OrLater:
261         // For the "OrLater" protocols we fall through from one to the next, adding all of them
262         // in ascending order
263         protocols = SP_PROT_TLS1_0;
264         Q_FALLTHROUGH();
265     case QSsl::TlsV1_1OrLater:
266         protocols |= SP_PROT_TLS1_1;
267         Q_FALLTHROUGH();
268     case QSsl::TlsV1_2OrLater:
269         protocols |= SP_PROT_TLS1_2;
270         break; // @future: fallthrough to TlsV1_3OrLater when it is added
271     }
272     return protocols;
273 }
274 
275 QSsl::SslProtocol toQtSslProtocol(DWORD protocol)
276 {
277     if (protocol & SP_PROT_SSL2)
278         return QSsl::SslV2;
279     if (protocol & SP_PROT_SSL3)
280         return QSsl::SslV3;
281     if (protocol & SP_PROT_TLS1_0)
282         return QSsl::TlsV1_0;
283     if (protocol & SP_PROT_TLS1_1)
284         return QSsl::TlsV1_1;
285     if (protocol & SP_PROT_TLS1_2)
286         return QSsl::TlsV1_2;
287     // @future: TlsV1_3
288     Q_UNREACHABLE();
289     return QSsl::UnknownProtocol;
290 }
291 
292 void printSecBufferDescInfo(const SecBufferDesc &desc) // @temp ?
293 {
294 #ifndef QSSLSOCKET_DEBUG
295     Q_UNUSED(desc)
296 #else
297 #define Print(value) #value << ":" << value
298     for (unsigned i = 0; i < desc.cBuffers; i++) {
299         auto buffer = desc.pBuffers[i];
300         qDebug() << i << Print(buffer.BufferType) << Print(buffer.cbBuffer);
301     }
302 #undef Print
303 #endif
304 }
305 
306 Q_DECL_UNUSED QVector<ALG_ID> QSslCipherToALG_ID(QList<QSslCipher> ciphers)
307 {
308     if (ciphers.isEmpty())
309         return {};
310     Q_UNIMPLEMENTED();
311     return {}; // @todo: implement
312 }
313 } // anonymous namespace
314 
315 // bool QSslSocketPrivate::s_libraryLoaded = true;
316 bool QSslSocketPrivate::s_loadRootCertsOnDemand = true;
317 // bool QSslSocketPrivate::s_loadedCiphersAndCerts = false;
318 
319 void QSslSocketPrivate::ensureInitialized()
320 {
321     static QMutex initMutex;
322     static bool initialized = false;
323 
324     if (initialized)
325         return;
326     QMutexLocker locker(&initMutex);
327     if (initialized)
328         return;
329     initialized = true;
330 
331     setDefaultCaCertificates(systemCaCertificates());
332     resetDefaultCiphers();
333 }
334 
335 void QSslSocketPrivate::resetDefaultCiphers()
336 {
337     setDefaultSupportedCiphers(QSslSocketBackendPrivate::defaultCiphers());
338     setDefaultCiphers(QSslSocketBackendPrivate::defaultCiphers());
339 }
340 
341 void QSslSocketPrivate::resetDefaultEllipticCurves()
342 {
343     Q_UNIMPLEMENTED();
344 }
345 
346 bool QSslSocketPrivate::supportsSsl()
347 {
348     return true;
349 }
350 
351 QList<QSslCertificate> QSslSocketPrivate::systemCaCertificates()
352 {
353     // Copied from qsslsocket_openssl.cpp's systemCaCertificates function.
354     // Changes: function pointers changed to direct usage. (@todo: update original)
355     QList<QSslCertificate> systemCerts;
356     HCERTSTORE hSystemStore = CertOpenSystemStore(0, L"ROOT");
357     if (hSystemStore) {
358         PCCERT_CONTEXT pc = nullptr;
359         while (1) {
360             pc = CertFindCertificateInStore(hSystemStore, X509_ASN_ENCODING, 0, CERT_FIND_ANY, nullptr, pc);
361             if (!pc)
362                 break;
363             QByteArray der(reinterpret_cast<const char *>(pc->pbCertEncoded),
364                            static_cast<int>(pc->cbCertEncoded));
365             QSslCertificate cert(der, QSsl::Der);
366             systemCerts.append(cert);
367         }
368         CertCloseStore(hSystemStore, 0);
369     }
370     return systemCerts;
371 }
372 
373 long QSslSocketPrivate::sslLibraryVersionNumber()
374 {
375     return QOperatingSystemVersion::current().majorVersion(); // @todo should be more accurate than this..
376 }
377 
378 QString QSslSocketPrivate::sslLibraryVersionString()
379 {
380     auto os = QOperatingSystemVersion::current();
381     return QString::fromLatin1("Secure Channel, %1 %2.%3.%4")
382             .arg(os.name(),
383                  QString::number(os.majorVersion()),
384                  QString::number(os.minorVersion()),
385                  QString::number(os.microVersion()));
386 }
387 
388 long QSslSocketPrivate::sslLibraryBuildVersionNumber()
389 {
390     return QOperatingSystemVersion::current().majorVersion(); // @todo not accurate at all
391 }
392 
393 QString QSslSocketPrivate::sslLibraryBuildVersionString()
394 {
395     auto os = QOperatingSystemVersion::current();
396     return QString::fromLatin1("%1.%2.%3")
397             .arg(QString::number(os.majorVersion()),
398                  QString::number(os.minorVersion()),
399                  QString::number(os.microVersion()));
400 }
401 
402 QSslSocketBackendPrivate::QSslSocketBackendPrivate()
403 {
404     SecInvalidateHandle(&credentialHandle);
405     SecInvalidateHandle(&contextHandle);
406     ensureInitialized();
407 }
408 
409 QSslSocketBackendPrivate::~QSslSocketBackendPrivate()
410 {
411     closeCertificateStores();
412     deallocateContext();
413     freeCredentialsHandle();
414 }
415 
416 bool QSslSocketBackendPrivate::sendToken(void *token, unsigned long tokenLength)
417 {
418     int written = plainSocket->write(static_cast<const char *>(token), tokenLength);
419     if (written >= 0 && written != int(tokenLength)) {
420         // failed to write everything
421         setErrorAndEmit(QAbstractSocket::SslInternalError, QStringLiteral("@todo: couldn't write all the data"));
422         return false;
423     }
424     return true;
425 }
426 
427 QString QSslSocketBackendPrivate::targetName() const
428 {
429     Q_Q(const QSslSocket);
430     // Used for SNI extension
431     return verificationPeerName.isEmpty() ? q->peerName() : verificationPeerName;
432 }
433 
434 ULONG QSslSocketBackendPrivate::getContextRequirements()
435 {
436     bool isServer = mode == QSslSocket::SslServerMode;
437     ULONG req = 0;
438 
439     req |= ISC_REQ_ALLOCATE_MEMORY; // allocate memory for buffers automatically
440     req |= ISC_REQ_CONFIDENTIALITY; // encrypt messages
441     req |= ISC_REQ_REPLAY_DETECT; // detect replayed messages
442     req |= ISC_REQ_SEQUENCE_DETECT; // detect out of sequence messages
443     if (!isServer) // @todo ??? why'd I put this here, forgot (but it's required somehow)
444         req |= ISC_REQ_MANUAL_CRED_VALIDATION; // Manually validate certificate
445     req |= ISC_REQ_STREAM; // Support a stream-oriented connection
446 
447     if (isServer
448         && configuration.peerVerifyMode != QSslSocket::PeerVerifyMode::VerifyNone
449         // There doesn't seem to be a way to ask for client cert without _requiring_ it.
450         && configuration.peerVerifyMode != QSslSocket::PeerVerifyMode::AutoVerifyPeer
451         && configuration.peerVerifyMode != QSslSocket::PeerVerifyMode::QueryPeer) {
452         req |= ASC_REQ_MUTUAL_AUTH;
453     }
454     if (certificateRequested) { // @todo (sorta experimental?)
455         Q_ASSERT(!isServer);
456         certificateRequested = false;
457         req |= ISC_REQ_USE_SUPPLIED_CREDS;
458     }
459 
460     return req;
461 }
462 
463 bool QSslSocketBackendPrivate::acquireCredentialsHandle()
464 {
465     const bool isClient = mode == QSslSocket::SslClientMode;
466     qDebug() << __func__ << (isClient ? "client" : "server");
467     const DWORD protocols = fromQtSslProtocol(configuration.protocol);
468 
469     const CERT_CHAIN_CONTEXT *chainContext = nullptr;
470     const CERT_CONTEXT *localCert = nullptr;
471     auto freeCertChain = qScopeGuard([&chainContext]() {
472         if (chainContext)
473             CertFreeCertificateChain(chainContext);
474     });
475 
476     DWORD certsCount = 0;
477     // Set up our certificate stores before trying to use one...
478     initializeCertificateStores();
479     if (localCertificateStore != nullptr) {
480         if (configuration.privateKey.isNull()) {
481             setErrorAndEmit(QAbstractSocket::SslInvalidUserDataError,
482                             QSslSocket::tr("Cannot provide a certificate with no key"));
483             return true; // Needed to support tst_QSslSocket::setEmptyKey
484         }
485         CERT_CHAIN_FIND_BY_ISSUER_PARA findParam;
486         ZeroMemory(&findParam, sizeof(findParam));
487         findParam.cbSize = sizeof(findParam);
488         findParam.pszUsageIdentifier = isClient ? szOID_PKIX_KP_CLIENT_AUTH : szOID_PKIX_KP_SERVER_AUTH;
489 
490         // There should only be one chain in our store, so.. we grab that one.
491         chainContext = CertFindChainInStore(localCertificateStore,
492                                             X509_ASN_ENCODING,
493                                             0,
494                                             CERT_CHAIN_FIND_BY_ISSUER,
495                                             &findParam,
496                                             nullptr);
497         if (!chainContext) {
498             qDebug() << "no certificate chain fits our purpose"; // @temp
499             return false; // @todo The user provided a certificate, but if we continue it will not be used
500         } else {
501             // @temp debug message
502             qDebug() << "local chain numbers:" << chainContext->cChain << chainContext->rgpChain[0]->cElement;
503             localCert = chainContext->rgpChain[0]->rgpElement[0]->pCertContext;
504             certsCount = 1;
505 
506             ///////////////// @temp
507             {
508                 // @temp: this works, but leaves the certificate in the system store
509                 HCERTSTORE myStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_OPEN_EXISTING_FLAG, L"My");
510                 qDebug() << "myStore:" << myStore;
511                 if (myStore) {
512                     for (DWORD i = 1; i < chainContext->rgpChain[0]->cElement; i++)
513                         qDebug() << !!CertAddCertificateContextToStore(myStore, chainContext->rgpChain[0]->rgpElement[i]->pCertContext, CERT_STORE_ADD_NEWER, nullptr);
514                     CertCloseStore(myStore, 0);
515                 }
516             }
517             //////////////// @temp
518         }
519     }
520 
521     SCHANNEL_CRED cred{
522         SCHANNEL_CRED_VERSION, // dwVersion;
523         certsCount, // cCreds
524         &localCert, // paCred (certificate(s) containing a private key for authentication)
525         nullptr, // hRootStore
526 
527         0, // cMappers (reserved)
528         nullptr, // aphMappers (reserved)
529 
530         0, // cSupportedAlgs
531         nullptr, // palgSupportedAlgs (nullptr = system default) @todo
532 
533         protocols, // grbitEnabledProtocols
534         0, // dwMinimumCipherStrength (0 = system default)
535         0, // dwMaximumCipherStrength (0 = system default)
536         0, // dwSessionLifespan (0 = schannel default, 10 hours)
537         SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
538                 | SCH_CRED_NO_DEFAULT_CREDS, // dwFlags
539         0 // dwCredFormat (must be 0)
540     };
541 
542     TimeStamp expiration{ 0, 0 };
543     auto status = AcquireCredentialsHandle(nullptr, // pszPrincipal (unused)
544                                            const_cast<wchar_t *>(UNISP_NAME), // pszPackage
545                                            isClient ? SECPKG_CRED_OUTBOUND : SECPKG_CRED_INBOUND, // fCredentialUse
546                                            nullptr, // pvLogonID (unused)
547                                            &cred, // pAuthData
548                                            nullptr, // pGetKeyFn (unused)
549                                            nullptr, // pvGetKeyArgument (unused)
550                                            &credentialHandle, // phCredential
551                                            &expiration // ptsExpir
552     );
553 
554     if (status != SEC_E_OK) {
555         qDebug() << "failed to acquire credentials handle:";
556         qDebug() << "protocol:" << configuration.protocol << "schannel:" << protocols;
557         schannelError(status);
558         // @todo: handle failure
559         return false;
560     }
561     return true;
562 }
563 
564 void QSslSocketBackendPrivate::deallocateContext()
565 {
566     if (SecIsValidHandle(&contextHandle)) {
567         DeleteSecurityContext(&contextHandle);
568         SecInvalidateHandle(&contextHandle);
569     }
570 }
571 
572 void QSslSocketBackendPrivate::freeCredentialsHandle()
573 {
574     if (SecIsValidHandle(&credentialHandle)) {
575         FreeCredentialsHandle(&credentialHandle);
576         SecInvalidateHandle(&credentialHandle);
577     }
578 }
579 
580 void QSslSocketBackendPrivate::closeCertificateStores()
581 {
582     if (localCertificateStore) {
583         CertCloseStore(localCertificateStore, CERT_CLOSE_STORE_FORCE_FLAG);
584         localCertificateStore = nullptr;
585     }
586     if (peerCertificateStore) {
587         CertCloseStore(peerCertificateStore, CERT_CLOSE_STORE_FORCE_FLAG);
588         peerCertificateStore = nullptr;
589     }
590     if (caCertificateStore) {
591         CertCloseStore(caCertificateStore, CERT_CLOSE_STORE_FORCE_FLAG);
592         caCertificateStore = nullptr;
593     }
594 }
595 
596 bool QSslSocketBackendPrivate::createContext()
597 {
598     qDebug() << __func__;
599     Q_ASSERT(mode == QSslSocket::SslClientMode);
600     ULONG contextReq = getContextRequirements();
601 
602     SecBuffer outBuffers[3];
603     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
604     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
605     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
606     auto freeBuffers = qScopeGuard([&outBuffers]() {
607         for (int i = 0; i < 3; i++) {
608             if (outBuffers[i].pvBuffer)
609                 FreeContextBuffer(outBuffers[i].pvBuffer);
610         }
611     });
612     SecBufferDesc outputBufferDesc{
613         SECBUFFER_VERSION,
614         3,
615         outBuffers
616     };
617 
618     TimeStamp expiry;
619 
620     auto status = InitializeSecurityContext(&credentialHandle, // phCredential
621                                             nullptr, // phContext
622                                             targetName().toStdWString().data(), // pszTargetName
623                                             contextReq, // fContextReq
624                                             0, // Reserved1
625                                             0, // TargetDataRep (unused)
626                                             nullptr, // pInput (no input at the moment @todo: alpn)
627                                             0, // Reserved2
628                                             &contextHandle, // phNewContext
629                                             &outputBufferDesc, // pOutput
630                                             &contextAttributes, // pfContextAttr
631                                             &expiry // ptsExpiry
632     );
633 
634     if (status != SEC_I_CONTINUE_NEEDED) // @todo: other possible non-error return values here?
635     {
636         // @todo Some error occurred, handle it
637         if (status == SEC_E_WRONG_PRINCIPAL) {
638             // @todo: SNI error...
639             setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError, QStringLiteral("@todo: some SNI error"));
640         } else if (status == SEC_E_INTERNAL_ERROR) {
641             setErrorAndEmit(QAbstractSocket::SslInternalError, QStringLiteral("@todo: internal error when creating security context"));
642         } else {
643             // Not very descriptive...
644             setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError, QStringLiteral("Handshake failed."));
645         }
646         qDebug() << "create context: ssl dead";
647         schannelError(status); // @temp: for debugging
648         return false;
649     }
650 
651     printSecBufferDescInfo(outputBufferDesc); // @temp
652     if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
653         return false;
654     schannelState = SchannelState::Step2;
655     return true;
656 }
657 
658 bool QSslSocketBackendPrivate::acceptContext()
659 {
660     qDebug() << __func__; // @temp
661     Q_ASSERT(mode == QSslSocket::SslServerMode);
662     ULONG contextReq = getContextRequirements();
663 
664     intermediateBuffer += plainSocket->readAll();
665     qDebug() << "bytes available:" << intermediateBuffer.length();
666     if (intermediateBuffer.isEmpty())
667         return true; // definitely need more data..
668 
669     SecBuffer inBuffers[3];
670     inBuffers[0] = createSecBuffer(intermediateBuffer, SECBUFFER_TOKEN);
671     inBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
672     SecBufferDesc inputBufferDesc{
673         SECBUFFER_VERSION,
674         2,
675         inBuffers
676     };
677 
678     SecBuffer outBuffers[3];
679     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
680     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
681     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
682     auto freeBuffers = qScopeGuard([&outBuffers]() {
683         for (int i = 0; i < 3; i++) {
684             if (outBuffers[i].pvBuffer)
685                 FreeContextBuffer(outBuffers[i].pvBuffer);
686         }
687     });
688     SecBufferDesc outputBufferDesc{
689         SECBUFFER_VERSION,
690         3,
691         outBuffers
692     };
693 
694     TimeStamp expiry;
695     auto status = AcceptSecurityContext(
696             &credentialHandle, // phCredential
697             nullptr, // phContext
698             &inputBufferDesc, // pInput
699             contextReq, // fContextReq
700             0, // TargetDataRep (unused)
701             &contextHandle, // phNewContext
702             &outputBufferDesc, // pOutput
703             &contextAttributes, // pfContextAttr
704             &expiry // ptsTimeStamp
705     );
706 
707     if (outBuffers[1].cbBuffer) { // some alert was raised
708         qDebug() << "ALERT::" // @todo
709                  << "I don't know how to check the alert";
710     }
711 
712     if (inBuffers[1].BufferType == SECBUFFER_EXTRA) {
713         // https://docs.microsoft.com/en-us/windows/desktop/secauthn/extra-buffers-returned-by-schannel
714         // inBuffers[1].cbBuffer indicates the amount of bytes _NOT_ processed, the rest need to
715         // be stored.
716         intermediateBuffer = intermediateBuffer.right(inBuffers[1].cbBuffer);
717     } else if (status != SEC_E_INCOMPLETE_MESSAGE) {
718         intermediateBuffer.clear();
719     }
720 
721     if (status != SEC_I_CONTINUE_NEEDED) {
722         qDebug() << "accept context: ssl dead";
723         schannelError(status); // @temp: for debugging
724         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError, errorString);
725         return false;
726     }
727     qDebug() << "accept context: continue needed";
728     if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer)) {
729         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError, errorString);
730         return false;
731     }
732     schannelState = SchannelState::Step2;
733     return true;
734 }
735 
736 bool QSslSocketBackendPrivate::doStep2()
737 {
738     bool isClient = mode == QSslSocket::SslClientMode;
739     qDebug() << __func__ << (isClient ? "client" : "server");
740     if (plainSocket->state() == QAbstractSocket::UnconnectedState) {
741         qDebug() << "Remote host disconnected";
742         return false;
743     }
744     // @temp:
745     qDebug() << "bytes available from socket:" << plainSocket->bytesAvailable();
746     qDebug() << "intermediateBuffer size:" << intermediateBuffer.size();
747 
748     intermediateBuffer += plainSocket->readAll();
749     if (intermediateBuffer.isEmpty())
750         return true; // no data, will fail
751 
752     SecBuffer inputBuffers[2];
753     inputBuffers[0] = createSecBuffer(intermediateBuffer, SECBUFFER_TOKEN);
754     inputBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
755     SecBufferDesc inputBufferDesc{
756         SECBUFFER_VERSION,
757         2,
758         inputBuffers
759     };
760 
761     SecBuffer outBuffers[3];
762     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
763     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
764     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
765     auto freeBuffers = qScopeGuard([&outBuffers]() {
766         for (int i = 0; i < 3; i++) {
767             if (outBuffers[i].pvBuffer)
768                 FreeContextBuffer(outBuffers[i].pvBuffer);
769         }
770     });
771     SecBufferDesc outputBufferDesc{
772         SECBUFFER_VERSION,
773         3,
774         outBuffers
775     };
776     qDebug() << "input";
777     printSecBufferDescInfo(inputBufferDesc);
778     qDebug() << "output";
779     printSecBufferDescInfo(outputBufferDesc);
780 
781     ULONG contextReq = getContextRequirements();
782     TimeStamp expiry;
783     auto status = InitializeSecurityContext(&credentialHandle, // phCredential
784                                             &contextHandle, // phContext
785                                             targetName().toStdWString().data(), // pszTargetName
786                                             contextReq, // fContextReq
787                                             0, // Reserved1
788                                             0, // TargetDataRep (unused)
789                                             &inputBufferDesc, // pInput
790                                             0, // Reserved2
791                                             nullptr, // phNewContext (we already have one)
792                                             &outputBufferDesc, // pOutput
793                                             &contextAttributes, // pfContextAttr
794                                             &expiry // ptsExpiry
795     );
796 
797     qDebug() << "input";
798     printSecBufferDescInfo(inputBufferDesc);
799     qDebug() << "output";
800     printSecBufferDescInfo(outputBufferDesc);
801     if (outBuffers[1].cbBuffer) { // some alert was raised
802         qDebug() << "ALERT::" // @todo
803                  << "I don't know how to check the alert";
804     }
805 
806     if (inputBuffers[1].BufferType == SECBUFFER_EXTRA) {
807         // https://docs.microsoft.com/en-us/windows/desktop/secauthn/extra-buffers-returned-by-schannel
808         // inputBuffers[1].cbBuffer indicates the amount of bytes _NOT_ processed, the rest need to
809         // be stored.
810         intermediateBuffer = intermediateBuffer.right(inputBuffers[1].cbBuffer);
811     } else {
812         // Clear the buffer if we weren't asked for more data
813         if (status != SEC_E_INCOMPLETE_MESSAGE)
814             intermediateBuffer.clear();
815     }
816     // @todo: clean up
817     switch (status) {
818     case SEC_E_OK:
819         // Need to transmit a final token in the handshake if 'cbBuffer' is non-zero.
820         if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
821             return false;
822         qDebug() << "ssl done";
823         schannelState = SchannelState::Step3;
824         return true;
825     case SEC_I_COMPLETE_AND_CONTINUE:
826     case SEC_I_COMPLETE_NEEDED:
827         qDebug() << "ssl need complete"; // @note: server-side only!
828         SecBufferDesc message; // @todo implement
829         status = CompleteAuthToken(&contextHandle, &message);
830         return true;
831     case SEC_I_CONTINUE_NEEDED:
832         if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
833             return false;
834         // Must call InitializeSecurityContext again later (done through continueHandshake)
835         qDebug() << "ssl need continue";
836         return true;
837     case SEC_I_INCOMPLETE_CREDENTIALS: {
838         // @todo: server asked for client credentials, and they didn't match anything server-side
839         qDebug() << "ssl need credentials";
840 
841         certificateRequested = true;
842 
843         // Delete the context and recreate it now that we have set "certificateRequested" to true.
844         // This will recreate the context with a new flag which makes schannel send our certificate.
845         deallocateContext();
846         schannelState = SchannelState::Step1;
847         return createContext();
848     }
849     case SEC_I_CONTEXT_EXPIRED:
850         // "The message sender has finished using the connection and has initiated a shutdown."
851         if (outBuffers[0].BufferType == SECBUFFER_TOKEN) {
852             if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
853                 return false;
854         }
855         return true;
856     case SEC_E_INCOMPLETE_MESSAGE:
857         // Simply incomplete, wait for more data
858         qDebug() << "incomplete message";
859         return true;
860     case SEC_E_ALGORITHM_MISMATCH:
861         qDebug() << "algorithm mismatch";
862         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError, QStringLiteral("Protocol version mismatch"));
863         return false;
864     }
865 
866     // Note: We can get here if the connection is using TLS 1.2 and the server certificate uses
867     // MD5, which is not allowed in Schannel. This causes an "invalid token" error during handshake.
868     // (If you came here investigating an error: md5 is insecure, update your certificate)
869 
870     // @todo Some error occurred, handle it. Error message is vague
871     setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError, QStringLiteral("Handshake failed"));
872     qDebug() << "step 2: ssl dead";
873     schannelError(status);
874     return false;
875 }
876 
877 bool QSslSocketBackendPrivate::doStep3()
878 {
879     bool isClient = mode == QSslSocket::SslClientMode;
880     qDebug() << __func__ << (isClient ? "client" : "server");
881     // @todo: make this more.. release-version-friendly
882 #define checkStatus(status)                                   \
883     if (status != SEC_E_OK) {                                 \
884         qDebug() << __LINE__ << "Couldn't query the context"; \
885         schannelError(status); /*@temp: debugging*/           \
886         return false;                                         \
887     }
888 
889     // everything is set up, now make sure there's nothing wrong and query some attributes...
890     if (contextAttributes != getContextRequirements()) {
891         qWarning() << "Didn't get the requirements we asked for!"; // @todo: emit error
892 
893 #ifdef QSSLSOCKET_DEBUG
894         qDebug() << "Context and requested:\n"
895                  << contextAttributes << "xor" << getContextRequirements()
896                  << '=' << (contextAttributes ^ getContextRequirements());
897         if (!(contextAttributes & ISC_RET_ALLOCATED_MEMORY))
898             qDebug() << "alloc mem missing";
899         if (!(contextAttributes & ISC_RET_CONFIDENTIALITY)) // encrypt messages
900             qDebug() << "encrypt messages missing";
901         if (!(contextAttributes & ISC_RET_REPLAY_DETECT)) // detect replayed messages
902             qDebug() << "detect replay missing";
903         if (!(contextAttributes & ISC_RET_SEQUENCE_DETECT)) // detect out of sequence messages
904             qDebug() << "detect out of sequence missing";
905         if (!(contextAttributes & ISC_RET_MANUAL_CRED_VALIDATION)) // Manually validate certificate
906             qDebug() << "manually validate cert missing";
907         if (!(contextAttributes & ISC_RET_STREAM)) // Support stream
908             qDebug() << "stream missing";
909 #endif
910         return false;
911     }
912 
913     // Get stream sizes (to know the max size of a message and the size of the header and trailer)
914     auto status = QueryContextAttributes(&contextHandle,
915                                          SECPKG_ATTR_STREAM_SIZES,
916                                          reinterpret_cast<void *>(&streamSizes));
917     checkStatus(status);
918 
919     // Get session cipher info
920     status = QueryContextAttributes(&contextHandle,
921                                     SECPKG_ATTR_CONNECTION_INFO,
922                                     reinterpret_cast<void *>(&connectionInfo));
923     checkStatus(status);
924 
925     // Verify certificate
926     CERT_CONTEXT *certificateContext = nullptr;
927     auto freeCertificate = qScopeGuard([&certificateContext]() {
928         CertFreeCertificateContext(certificateContext);
929     });
930     status = QueryContextAttributes(&contextHandle,
931                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
932                                     reinterpret_cast<void *>(&certificateContext));
933 
934     // QueryPeer can (currently) not work in Schannel since Schannel itself doesn't have a way to
935     // ask for a certificate and then still be OK if it's not received.
936     // To work around this we don't request a certificate at all for QueryPeer.
937     // For servers AutoVerifyPeer is supposed to be treated the same as QueryPeer.
938     // This means that servers using Schannel will only request client certificate for "VerifyPeer".
939     if ((!isClient && configuration.peerVerifyMode == QSslSocket::PeerVerifyMode::VerifyPeer)
940         || (isClient && configuration.peerVerifyMode != QSslSocket::PeerVerifyMode::VerifyNone
941             && configuration.peerVerifyMode != QSslSocket::PeerVerifyMode::QueryPeer)) {
942         checkStatus(status);
943     }
944 
945     sslErrors = verifySingleCertificate(certificateContext); // @todo
946     qDebug() << sslErrors;
947     if (!checkSslErrors() || state != QAbstractSocket::ConnectedState) {
948         qDebug() << "doStep3 unsuccessful";
949         return paused; // If we're paused then checkSslErrors returned false, but it's not an error
950     }
951     qDebug() << "doStep3 successful";
952 
953     schannelState = SchannelState::Done;
954     return true;
955 #undef checkStatus
956 }
957 
958 bool QSslSocketBackendPrivate::renegotiate()
959 {
960     qDebug() << __func__;
961     SecBuffer outBuffers[3];
962     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
963     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
964     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
965     auto freeBuffers = qScopeGuard([&outBuffers]() {
966         for (int i = 0; i < 3; i++) {
967             if (outBuffers[i].pvBuffer)
968                 FreeContextBuffer(outBuffers[i].pvBuffer);
969         }
970     });
971     SecBufferDesc outputBufferDesc{
972         SECBUFFER_VERSION,
973         3,
974         outBuffers
975     };
976 
977     ULONG contextReq = getContextRequirements();
978     TimeStamp expiry;
979     auto status = InitializeSecurityContext(&credentialHandle, // phCredential
980                                             &contextHandle, // phContext
981                                             targetName().toStdWString().data(), // pszTargetName
982                                             contextReq, // fContextReq
983                                             0, // Reserved1
984                                             0, // TargetDataRep (unused)
985                                             nullptr, // pInput (nullptr for renegotiate)
986                                             0, // Reserved2
987                                             nullptr, // phNewContext (we already have one)
988                                             &outputBufferDesc, // pOutput
989                                             &contextAttributes, // pfContextAttr
990                                             &expiry // ptsExpiry
991     );
992     for (int i = 0; i < 3; i++) { // @temp debug
993         qDebug() << "type:" << outBuffers[i].BufferType << "bytecount:" << outBuffers[i].cbBuffer;
994     }
995     if (status == SEC_I_CONTINUE_NEEDED) {
996         qDebug() << "reneg needs continue";
997         schannelState = SchannelState::Step2;
998         if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
999             return false;
1000 
1001         return true;
1002     }
1003     qDebug() << "reneg failed";
1004     schannelError(status);
1005     // @todo: emit some error
1006     return false;
1007 }
1008 
1009 /*!
1010     \internal
1011     reset the state in preparation for reuse of socket
1012 */
1013 void QSslSocketBackendPrivate::reset()
1014 {
1015     freeCredentialsHandle(); // in case we already had one (@todo: session resumption requires re-use)
1016     deallocateContext();
1017     closeCertificateStores(); // certificate stores could've changed
1018 
1019     contextAttributes = 0;
1020     intermediateBuffer.clear();
1021     schannelState = SchannelState::Step1;
1022 }
1023 
1024 void QSslSocketBackendPrivate::startClientEncryption()
1025 {
1026     if (connectionEncrypted)
1027         return; // let's not mess up the connection...
1028     reset();
1029     continueHandshake();
1030 }
1031 
1032 void QSslSocketBackendPrivate::startServerEncryption()
1033 {
1034     if (connectionEncrypted)
1035         return; // let's not mess up the connection...
1036     reset();
1037     continueHandshake();
1038 }
1039 
1040 void QSslSocketBackendPrivate::transmit()
1041 {
1042     bool isClient = mode == QSslSocket::SslClientMode;
1043     qDebug() << __func__ << (isClient ? "client" : "server");
1044     Q_Q(QSslSocket);
1045 
1046     if (!connectionEncrypted || renegotiating)
1047         continueHandshake();
1048     if (renegotiating || shutdown)
1049         return;
1050 
1051     if (connectionEncrypted) { // encrypt data in writeBuffer and write it to plainSocket
1052         qint64 totalBytesWritten = 0;
1053         qint64 nextDataBlockSize;
1054         while ((nextDataBlockSize = writeBuffer.nextDataBlockSize()) > 0) {
1055             QByteArray plaintext;
1056             {
1057                 // Try to read 'cbMaximumMessage' bytes from buffer before encrypting.
1058                 int size = int(std::min(writeBuffer.size(), qint64(streamSizes.cbMaximumMessage)));
1059                 plaintext.resize(size);
1060                 // @temp
1061                 qDebug() << "writeBuffer.size:" << writeBuffer.size() << ", streamSizes.cbMaximumMessage:" << streamSizes.cbMaximumMessage << ", end size:" << size;
1062                 qint64 copied = 0;
1063                 do {
1064                     int toRead = int(std::min(nextDataBlockSize, qint64(size - copied)));
1065                     copied += writeBuffer.read(plaintext.data() + copied, toRead);
1066                 } while ((nextDataBlockSize = writeBuffer.nextDataBlockSize()) > 0
1067                          && copied < size);
1068 
1069                 Q_ASSERT(copied <= size);
1070                 plaintext.resize(copied);
1071             }
1072             QByteArray header(streamSizes.cbHeader, '\0');
1073             QByteArray trailer(streamSizes.cbTrailer, '\0');
1074 
1075             SecBuffer inputBuffers[4]{
1076                 // @future[0/1]: optimize by using one container for all fields...
1077                 createSecBuffer(header, SECBUFFER_STREAM_HEADER),
1078                 createSecBuffer(plaintext, SECBUFFER_DATA),
1079                 createSecBuffer(trailer, SECBUFFER_STREAM_TRAILER),
1080                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY)
1081             };
1082             SecBufferDesc message{
1083                 SECBUFFER_VERSION,
1084                 4,
1085                 inputBuffers
1086             };
1087             auto status = EncryptMessage(&contextHandle, // phContext
1088                                          0, // fQOP
1089                                          &message, // pMessage
1090                                          0 // sequence number (must be 0)
1091             );
1092             if (status != SEC_E_OK) {
1093                 schannelError(status);
1094                 setErrorAndEmit(QAbstractSocket::SslInternalError, QStringLiteral("@todo: encryption failed"));
1095                 // @todo: restore the data somewhere? can't prepend to writebuffer...
1096                 return;
1097             }
1098             // trailer has been observed to change size, so resize them all (when needed) to be safe
1099             header = header.left(inputBuffers[0].cbBuffer);
1100             plaintext = plaintext.left(inputBuffers[1].cbBuffer);
1101             trailer = trailer.left(inputBuffers[2].cbBuffer);
1102             qDebug() << (isClient ? "client" : "server") << "sending" << header.length() + plaintext.length() + trailer.length() << "bytes";
1103             int bytesWritten = 0;
1104             bytesWritten += plainSocket->write(header // @future[1/1]: ...because they need to be merged
1105                                                + plaintext
1106                                                + trailer);
1107             if (bytesWritten >= 0) {
1108                 totalBytesWritten += bytesWritten;
1109             } else {
1110                 // @todo: some error, handle that
1111             }
1112         }
1113 
1114         if (totalBytesWritten > 0) {
1115             Q_Q(QSslSocket);
1116             // Don't emit bytesWritten() recursively.
1117             if (!emittedBytesWritten) {
1118                 emittedBytesWritten = true;
1119                 emit q->bytesWritten(totalBytesWritten);
1120                 emittedBytesWritten = false;
1121             }
1122             emit q->channelBytesWritten(0, totalBytesWritten);
1123         }
1124     }
1125 
1126     if (connectionEncrypted) { // Decrypt data from remote
1127         qDebug() << (isClient ? "client" : "server") << "about to decrypt from remote";
1128         int totalRead = 0;
1129         bool hadIncompleteData = false;
1130         while (!readBufferMaxSize || buffer.size() < readBufferMaxSize) {
1131             QByteArray ciphertext;
1132             if (intermediateBuffer.length()) {
1133                 qDebug() << "There's data in intermediateBuffer:" << intermediateBuffer.length();
1134                 ciphertext.swap(intermediateBuffer);
1135             }
1136             int initialLength = ciphertext.length();
1137             ciphertext += plainSocket->read(16384);
1138             if (ciphertext.length() == 0 || (hadIncompleteData && initialLength == ciphertext.length())) {
1139                 qDebug() << "Nothing to decrypt, leaving loop!";
1140                 if (ciphertext.length()) // Swap back if needed
1141                     intermediateBuffer.swap(ciphertext);
1142                 break;
1143             }
1144             hadIncompleteData = false;
1145             qDebug() << "ciphertext length:" << ciphertext.length();
1146 
1147             SecBuffer dataBuffer[4]{
1148                 createSecBuffer(ciphertext, SECBUFFER_DATA),
1149                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY),
1150                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY),
1151                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY)
1152             };
1153             SecBufferDesc message{
1154                 SECBUFFER_VERSION,
1155                 4,
1156                 dataBuffer
1157             };
1158             ULONG qop;
1159             auto status = DecryptMessage(&contextHandle, // phContext
1160                                          &message, // pMessage
1161                                          0, // MessageSeqNo
1162                                          &qop // pfQOP
1163             );
1164             if (status == SEC_E_OK || status == SEC_I_RENEGOTIATE || status == SEC_I_CONTEXT_EXPIRED) {
1165                 // There can still be 0 output even if it succeeds, this is fine
1166                 if (dataBuffer[1].cbBuffer > 0) {
1167                     // It was decrypted in-place.
1168                     // But [0] is the STREAM_HEADER, [1] is the DATA and [2] is the STREAM_TRAILER.
1169                     // The pointers in all of those still point into the 'ciphertext' byte array.
1170                     buffer.append(static_cast<char *>(dataBuffer[1].pvBuffer),
1171                                   dataBuffer[1].cbBuffer);
1172                     qDebug() << "read data, new buffer size:" << buffer.size();
1173                     qDebug() << "data read:" << ciphertext.mid(dataBuffer[0].cbBuffer, std::min(100ul, dataBuffer[1].cbBuffer));
1174                     totalRead += dataBuffer[1].cbBuffer;
1175                 }
1176                 if (dataBuffer[3].BufferType == SECBUFFER_EXTRA) {
1177                     // https://docs.microsoft.com/en-us/windows/desktop/secauthn/extra-buffers-returned-by-schannel
1178                     // dataBuffer[3].cbBuffer indicates the amount of bytes _NOT_ processed, the rest need to
1179                     // be stored.
1180                     qDebug() << "We've got excess data:" << dataBuffer[3].cbBuffer;
1181                     intermediateBuffer = ciphertext.right(dataBuffer[3].cbBuffer);
1182                 }
1183                 printSecBufferDescInfo(message); // @temp debug
1184             }
1185             // @todo: clean up error handling a bit...
1186             if (status == SEC_E_INCOMPLETE_MESSAGE) {
1187                 // Need more data before we can decrypt.. to the buffer it goes!
1188                 qDebug() << "data was incomplete, need more";
1189                 Q_ASSERT(intermediateBuffer.isEmpty());
1190                 intermediateBuffer.swap(ciphertext);
1191                 // We try again, but if we don't get any more data then we leave
1192                 hadIncompleteData = true;
1193             } else if (status == SEC_E_INVALID_HANDLE) {
1194                 // I don't think this should happen, if it does we're done...
1195                 qDebug() << "invalid handle";
1196                 Q_UNREACHABLE();
1197             } else if (status == SEC_E_INVALID_TOKEN) {
1198                 qDebug() << "invalid token";
1199                 Q_UNREACHABLE(); // Happened once due to a bug, but shouldn't generally happen(?)
1200             } else if (status == SEC_E_MESSAGE_ALTERED) {
1201                 // The message has been altered, disconnect now
1202                 // @todo: emit error?
1203                 qDebug() << "message altered";
1204                 shutdown = true; // skips sending the shutdown alert
1205                 disconnectFromHost();
1206                 break;
1207             } else if (status == SEC_E_OUT_OF_SEQUENCE) {
1208                 // I don't know if this one is actually "fatal"..
1209                 qDebug() << "out of sequence";
1210                 // @todo
1211                 shutdown = true; // skips sending the shutdown alert
1212                 disconnectFromHost();
1213                 break;
1214             } else if (status == SEC_I_CONTEXT_EXPIRED) {
1215                 // 'remote' has initiated a shutdown
1216                 qDebug() << "remote shut down";
1217                 shutdown = true; // skips sending the shutdown alert
1218                 disconnectFromHost();
1219                 setErrorAndEmit(QAbstractSocket::RemoteHostClosedError,
1220                                 QSslSocket::tr("The TLS/SSL connection has been closed"));
1221                 break;
1222             } else if (status == SEC_I_RENEGOTIATE) {
1223                 // 'remote' wants to renegotiate
1224                 qDebug() << "remote wants to renegotiate";
1225                 qDebug() << message.pBuffers[1].cbBuffer
1226                          << ciphertext.mid(message.pBuffers[0].cbBuffer, message.pBuffers[1].cbBuffer);
1227                 schannelState = SchannelState::Renegotiate;
1228                 renegotiating = true;
1229                 // We need to call 'continueHandshake' or else there's no guarantee it ever gets called
1230                 continueHandshake();
1231                 break;
1232             }
1233         }
1234 
1235         if (totalRead) {
1236             if (readyReadEmittedPointer)
1237                 *readyReadEmittedPointer = true;
1238             emit q->readyRead();
1239             emit q->channelReadyRead(0);
1240         }
1241     }
1242 }
1243 
1244 void QSslSocketBackendPrivate::sendShutdown()
1245 {
1246     qDebug() << __func__ << (mode == QSslSocket::SslClientMode ? "client" : "server");
1247     DWORD shutdownToken = SCHANNEL_SHUTDOWN;
1248     SecBuffer buffer = createSecBuffer(&shutdownToken, sizeof(SCHANNEL_SHUTDOWN), SECBUFFER_TOKEN);
1249     SecBufferDesc token{
1250         SECBUFFER_VERSION,
1251         1,
1252         &buffer
1253     };
1254     auto status = ApplyControlToken(&contextHandle, &token);
1255 
1256     if (status == SEC_E_OK) {
1257         SecBuffer outBuffers[3];
1258         outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
1259         outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
1260         outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
1261         auto freeBuffers = qScopeGuard([&outBuffers]() {
1262             for (int i = 0; i < 3; i++) {
1263                 if (outBuffers[i].pvBuffer)
1264                     FreeContextBuffer(outBuffers[i].pvBuffer);
1265             }
1266         });
1267         SecBufferDesc outputBufferDesc{
1268             SECBUFFER_VERSION,
1269             3,
1270             outBuffers
1271         };
1272 
1273         ULONG contextReq = getContextRequirements();
1274         TimeStamp expiry;
1275         auto status = InitializeSecurityContext(&credentialHandle, // phCredential
1276                                                 &contextHandle, // phContext
1277                                                 targetName().toStdWString().data(), // pszTargetName
1278                                                 contextReq, // fContextReq
1279                                                 0, // Reserved1
1280                                                 0, // TargetDataRep (unused)
1281                                                 nullptr, // pInput
1282                                                 0, // Reserved2
1283                                                 nullptr, // phNewContext (we already have one)
1284                                                 &outputBufferDesc, // pOutput
1285                                                 &contextAttributes, // pfContextAttr
1286                                                 &expiry // ptsExpiry
1287         );
1288         qDebug() << "output";
1289         printSecBufferDescInfo(outputBufferDesc);
1290         if (status == SEC_E_OK || status == SEC_I_CONTEXT_EXPIRED) {
1291             if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer)) {
1292                 // @temp for debugging
1293                 qDebug() << "Failed to send the shutdown alert/token";
1294                 return;
1295             }
1296 
1297             schannelState = SchannelState::Step2;
1298             continueHandshake();
1299         } else {
1300             schannelError(status); // @temp
1301         }
1302     } else {
1303         schannelError(status); // @temp
1304     }
1305 }
1306 
1307 void QSslSocketBackendPrivate::disconnectFromHost()
1308 {
1309     qDebug() << __func__;
1310     if (SecIsValidHandle(&contextHandle)) {
1311         if (!shutdown) {
1312             qDebug() << plainSocket->state() << connectionEncrypted;
1313             if (plainSocket->state() != QAbstractSocket::UnconnectedState) {
1314                 if (schannelState >= SchannelState::Step3)
1315                     sendShutdown();
1316                 if (connectionEncrypted)
1317                     transmit();
1318             }
1319             shutdown = true;
1320         }
1321     }
1322     if (plainSocket->state() != QAbstractSocket::UnconnectedState)
1323         plainSocket->disconnectFromHost();
1324 }
1325 
1326 void QSslSocketBackendPrivate::disconnected()
1327 {
1328     if (plainSocket->bytesAvailable() <= 0) {
1329         shutdown = true;
1330         connectionEncrypted = false;
1331         deallocateContext();
1332         freeCredentialsHandle();
1333     }
1334 }
1335 
1336 QSslCipher QSslSocketBackendPrivate::sessionCipher() const
1337 {
1338     if (!connectionEncrypted)
1339         return QSslCipher();
1340     Q_UNIMPLEMENTED();
1341     auto ciph = QSslCipher(QStringLiteral("Schannel"), sessionProtocol());
1342     return ciph;
1343 }
1344 
1345 QSsl::SslProtocol QSslSocketBackendPrivate::sessionProtocol() const
1346 {
1347     if (!connectionEncrypted)
1348         return QSsl::SslProtocol::UnknownProtocol;
1349     return toQtSslProtocol(connectionInfo.dwProtocol);
1350 }
1351 
1352 void QSslSocketBackendPrivate::continueHandshake()
1353 {
1354     Q_Q(QSslSocket);
1355     const bool isServer = mode == QSslSocket::SslServerMode;
1356     switch (schannelState) {
1357     case SchannelState::Step1:
1358         if (!SecIsValidHandle(&credentialHandle) && !acquireCredentialsHandle()) {
1359             disconnectFromHost();
1360             return;
1361         }
1362         if (!SecIsValidHandle(&credentialHandle)) // Needed to support tst_QSslSocket::setEmptyKey
1363             return;
1364         if (!SecIsValidHandle(&contextHandle) && (isServer ? !acceptContext() : !createContext())) {
1365             disconnectFromHost();
1366             return;
1367         }
1368         if (schannelState != SchannelState::Step2)
1369             break;
1370         Q_FALLTHROUGH();
1371     case SchannelState::Step2:
1372         if (!doStep2()) {
1373             disconnectFromHost();
1374             return;
1375         }
1376         if (schannelState != SchannelState::Step3)
1377             break;
1378         Q_FALLTHROUGH();
1379     case SchannelState::Step3:
1380         if (!doStep3()) {
1381             disconnectFromHost();
1382             return;
1383         }
1384         if (schannelState != SchannelState::Done)
1385             break;
1386         Q_FALLTHROUGH();
1387     case SchannelState::Done:
1388         // connectionEncrypted is already true if we come here from a renegotiation
1389         if (!renegotiating) {
1390             connectionEncrypted = true; // all is done
1391             emit q->encrypted();
1392         }
1393         renegotiating = false;
1394         if (pendingClose) {
1395             pendingClose = false;
1396             disconnectFromHost();
1397         } else {
1398             transmit();
1399         }
1400         break;
1401     case SchannelState::Renegotiate:
1402         if (!renegotiate()) {
1403             disconnectFromHost();
1404             return;
1405         }
1406         break;
1407     }
1408 }
1409 
1410 QList<QSslCipher> QSslSocketBackendPrivate::defaultCiphers()
1411 {
1412     QList<QSslCipher> ciphers;
1413     // @temp (I hope), stolen from qsslsocket_winrt.cpp
1414     const QString protocolStrings[] = { QStringLiteral("SSLv3"), QStringLiteral("TLSv1"),
1415                                         QStringLiteral("TLSv1.1"), QStringLiteral("TLSv1.2") };
1416     const QSsl::SslProtocol protocols[] = { QSsl::SslV3, QSsl::TlsV1_0, QSsl::TlsV1_1, QSsl::TlsV1_2 };
1417     const int size = 4;
1418     ciphers.reserve(size);
1419     for (int i = 0; i < size; ++i) {
1420         QSslCipher cipher;
1421         cipher.d->isNull = false;
1422         cipher.d->name = QStringLiteral("Schannel");
1423         cipher.d->protocol = protocols[i];
1424         cipher.d->protocolString = protocolStrings[i];
1425         ciphers.append(cipher);
1426     }
1427     return ciphers;
1428 }
1429 
1430 QList<QSslError> QSslSocketBackendPrivate::verify(const QList<QSslCertificate> &certificateChain,
1431                                                   const QString &hostName)
1432 {
1433     Q_UNUSED(certificateChain);
1434     Q_UNUSED(hostName);
1435 
1436     Q_UNIMPLEMENTED();
1437     return {}; // @todo?
1438 }
1439 
1440 bool QSslSocketBackendPrivate::importPkcs12(QIODevice *device, QSslKey *key, QSslCertificate *cert,
1441                                             QList<QSslCertificate> *caCertificates,
1442                                             const QByteArray &passPhrase)
1443 {
1444     Q_UNUSED(device);
1445     Q_UNUSED(key);
1446     Q_UNUSED(cert);
1447     Q_UNUSED(caCertificates);
1448     Q_UNUSED(passPhrase);
1449     // @todo can load into its own certificate store.
1450     Q_UNIMPLEMENTED();
1451     return false;
1452 }
1453 
1454 /*
1455     Copied from qsslsocket_mac.cpp, which was copied from qsslsocket_openssl.cpp
1456 */
1457 bool QSslSocketBackendPrivate::checkSslErrors()
1458 {
1459     Q_Q(QSslSocket);
1460     if (sslErrors.isEmpty())
1461         return true;
1462 
1463     emit q->sslErrors(sslErrors);
1464     qDebug() << "checking errors";
1465 
1466     const bool doVerifyPeer = configuration.peerVerifyMode == QSslSocket::VerifyPeer
1467             || (configuration.peerVerifyMode == QSslSocket::AutoVerifyPeer
1468                 && mode == QSslSocket::SslClientMode);
1469     const bool doEmitSslError = !verifyErrorsHaveBeenIgnored();
1470     // check whether we need to emit an SSL handshake error
1471     if (doVerifyPeer && doEmitSslError) {
1472         if (q->pauseMode() & QAbstractSocket::PauseOnSslErrors) {
1473             qDebug() << "paused";
1474             pauseSocketNotifiers(q);
1475             paused = true;
1476         } else {
1477             qDebug() << "disconnecting";
1478             setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
1479                             sslErrors.constFirst().errorString());
1480             plainSocket->disconnectFromHost();
1481         }
1482         return false;
1483     }
1484 
1485     return true;
1486 }
1487 
1488 void QSslSocketBackendPrivate::initializeCertificateStores()
1489 {
1490     //// helper function which turns a chain into a certificate store
1491     auto createStoreFromCertificateChain = [](const QList<QSslCertificate> certChain, const QSslKey &privateKey) {
1492         // @todo: move some of this somewhere else so it can be used by importPkcs12?
1493         const wchar_t *passphrase = L"";
1494         // Need to embed the private key in the certificate
1495         QByteArray pkcs12 = _q_makePkcs12(certChain,
1496                                           privateKey,
1497                                           QString::fromWCharArray(passphrase, 0));
1498         CRYPT_DATA_BLOB pfxBlob;
1499         pfxBlob.cbData = pkcs12.length();
1500         pfxBlob.pbData = reinterpret_cast<unsigned char *>(pkcs12.data());
1501         return PFXImportCertStore(&pfxBlob, passphrase, 0); // returns HCERTSTORE
1502     };
1503 
1504     if (!configuration.localCertificateChain.isEmpty()) {
1505         if (localCertificateStore == nullptr) {
1506             localCertificateStore = createStoreFromCertificateChain(configuration.localCertificateChain,
1507                                                                     configuration.privateKey);
1508             if (localCertificateStore == nullptr)
1509                 qDebug() << "Failed to load certificate chain"; // @temp
1510         }
1511     }
1512 
1513     if (!configuration.caCertificates.isEmpty() && !caCertificateStore) {
1514         caCertificateStore = createStoreFromCertificateChain(configuration.caCertificates,
1515                                                              {}); // No private key for the CA certs
1516     }
1517 }
1518 
1519 // @todo: this name doesn't really match, since it grabs and checks a cert chain in the process..
1520 QList<QSslError> QSslSocketBackendPrivate::verifySingleCertificate(CERT_CONTEXT *certContext)
1521 {
1522     // @todo: I want this to be better, doesn't really match up with the openssl backend.
1523     Q_Q(QSslSocket);
1524     QList<QSslError> errors;
1525     if (certContext == nullptr)
1526         return errors;
1527 
1528     bool isClient = mode == QSslSocket::SslClientMode;
1529 
1530     // Create a collection of stores so we can pass in multiple stores as additional locations to
1531     // search for the certificate chain
1532     HCERTSTORE tempCertCollection = CertOpenStore(CERT_STORE_PROV_COLLECTION,
1533                                                   X509_ASN_ENCODING,
1534                                                   0,
1535                                                   CERT_STORE_CREATE_NEW_FLAG,
1536                                                   nullptr);
1537     if (caCertificateStore)
1538         CertAddStoreToCollection(tempCertCollection, caCertificateStore, 0, 1);
1539     CertAddStoreToCollection(tempCertCollection, certContext->hCertStore, 0, 0);
1540 
1541     CERT_CHAIN_PARA parameters;
1542     ZeroMemory(&parameters, sizeof(parameters));
1543     parameters.cbSize = sizeof(CERT_CHAIN_PARA);
1544     parameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
1545     parameters.RequestedUsage.Usage.cUsageIdentifier = 1;
1546     LPSTR oid = LPSTR(isClient ? szOID_PKIX_KP_SERVER_AUTH
1547                                : szOID_PKIX_KP_CLIENT_AUTH);
1548     parameters.RequestedUsage.Usage.rgpszUsageIdentifier = &oid;
1549 
1550     configuration.peerCertificate.clear();
1551     configuration.peerCertificateChain.clear();
1552     const CERT_CHAIN_CONTEXT *chainContext = nullptr;
1553     auto freeCertChain = qScopeGuard([&chainContext]() {
1554         if (chainContext)
1555             CertFreeCertificateChain(chainContext);
1556     });
1557     auto status = CertGetCertificateChain(nullptr, // hChainEngine, default
1558                                           certContext, // pCertContext
1559                                           nullptr, // pTime, 'now'
1560                                           tempCertCollection, // hAdditionalStore, additional cert store
1561                                           &parameters, // pChainPara
1562                                           CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT, // dwFlags
1563                                           nullptr, // reserved
1564                                           &chainContext // ppChainContext
1565     );
1566     CertCloseStore(tempCertCollection, 0);
1567     if (status == 0) {
1568         QSslError error(QSslError::UnspecifiedError);
1569         errors += error;
1570         emit q->peerVerifyError(error);
1571         return errors;
1572     }
1573 
1574     // Helper-function to get a QSslCertificate given a CERT_CHAIN_ELEMENT
1575     static auto getCertificateFromChainElement = [](CERT_CHAIN_ELEMENT *element) {
1576         if (!element)
1577             return QSslCertificate();
1578 
1579         const CERT_CONTEXT *certContext = element->pCertContext;
1580         QByteArray certificate = QByteArray(const_cast<const char *>(reinterpret_cast<char *>(certContext->pbCertEncoded)),
1581                                             certContext->cbCertEncoded);
1582         return QSslCertificate(certificate, QSsl::Der);
1583     };
1584 
1585     // @todo look into making these mappings into a map (map<error, qt sslerror>) to simplify
1586     // the loop somewhat
1587     qDebug() << "chains:" << chainContext->cChain;
1588     // Pick a chain to use as the certificate chain, if multiple are available:
1589     CERT_SIMPLE_CHAIN *chain = nullptr;
1590     if (chainContext->cChain > 0) {
1591         // According to https://docs.microsoft.com/en-gb/windows/desktop/api/wincrypt/ns-wincrypt-_cert_chain_context
1592         // this seems to be the best way to get a trusted chain.
1593         // (@temp Most search results to confirm this leads back to our code, qwindowscarootfetcher.cpp)
1594         chain = chainContext->rgpChain[chainContext->cChain - 1];
1595     }
1596 
1597     if (chain) {
1598         if (chain->TrustStatus.dwErrorStatus & CERT_TRUST_IS_PARTIAL_CHAIN) {
1599             qDebug() << "we have a partial chain...";
1600             auto error = QSslError(QSslError::SslError::UnableToGetIssuerCertificate);
1601             errors += error;
1602             emit q->peerVerifyError(error);
1603         }
1604         if (chain->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_BASIC_CONSTRAINTS) {
1605             auto error = QSslError(QSslError::PathLengthExceeded);
1606             errors += error;
1607             emit q->peerVerifyError(error);
1608         }
1609         if (chain->TrustStatus.dwErrorStatus & CERT_TRUST_IS_CYCLIC
1610             || chain->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_EXTENSION
1611             || chain->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_POLICY_CONSTRAINTS
1612             || chain->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_BASIC_CONSTRAINTS
1613             || chain->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_NAME_CONSTRAINTS
1614             || chain->TrustStatus.dwErrorStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID
1615             || chain->TrustStatus.dwErrorStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID
1616             || chain->TrustStatus.dwErrorStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE) {
1617             auto error = QSslError(QSslError::SslError::UnspecifiedError);
1618             errors += error;
1619             emit q->peerVerifyError(error);
1620         }
1621 
1622         DWORD verifyDepth = (configuration.peerVerifyDepth == 0)
1623                 ? chain->cElement
1624                 : std::min(chain->cElement, DWORD(configuration.peerVerifyDepth));
1625 
1626         qDebug() << "elements:" << chain->cElement << ", verifyDepth:" << verifyDepth;
1627         for (DWORD j = 0; j < verifyDepth; j++) {
1628             CERT_CHAIN_ELEMENT *element = chain->rgpElement[j];
1629             QSslCertificate certificate = getCertificateFromChainElement(element);
1630             const QList<QSslCertificateExtension> extensions = certificate.extensions();
1631             qDebug() << "issuer:" << certificate.issuerDisplayName();
1632             qDebug() << "subject:" << certificate.subjectDisplayName();
1633             qDebug() << certificate;
1634             qDebug() << "extended error info:" << element->pwszExtendedErrorInfo;
1635             qDebug() << "error status:" << element->TrustStatus.dwErrorStatus;
1636 
1637             ////// @todo @note This is where certificates are added, read at the top for "discussion".
1638             configuration.peerCertificateChain.append(certificate);
1639 
1640             if (certificate.isBlacklisted()) {
1641                 const auto error = QSslError(QSslError::CertificateBlacklisted, certificate);
1642                 errors += error;
1643                 emit q->peerVerifyError(error);
1644             }
1645 
1646             LONG result = CertVerifyTimeValidity(nullptr /* now */, element->pCertContext->pCertInfo);
1647             if (result == -1) {
1648                 auto error = QSslError(QSslError::CertificateNotYetValid, certificate);
1649                 errors += error;
1650                 emit q->peerVerifyError(error);
1651             } else if (result == 1) {
1652                 auto error = QSslError(QSslError::CertificateExpired, certificate);
1653                 errors += error;
1654                 emit q->peerVerifyError(error);
1655             }
1656 
1657             //// Errors
1658             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_TIME_VALID) {
1659                 // handled right above
1660             }
1661             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_REVOKED) {
1662                 auto error = QSslError(QSslError::CertificateRevoked, certificate);
1663                 errors += error;
1664                 emit q->peerVerifyError(error);
1665             }
1666             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID) {
1667                 auto error = QSslError(QSslError::CertificateSignatureFailed, certificate);
1668                 errors += error;
1669                 emit q->peerVerifyError(error);
1670             }
1671 
1672             // While netscape shouldn't be relevant now it still defined an extension which is
1673             // still in use in some cases (*cough*our tests*cough*). Schannel does not check this
1674             // automatically, so we'll do it manually. It is used to differentiate between client
1675             // and server certificates.
1676             auto netscapeIt = std::find_if(extensions.cbegin(), extensions.cend(),
1677                                            [](const QSslCertificateExtension &extension) {
1678                                                return extension.oid() == QStringLiteral("2.16.840.1.113730.1.1"); // Netscape cert type
1679                                            });
1680             if (netscapeIt != extensions.cend()) {
1681                 qDebug() << "certificate actually has netscape cert type extension";
1682                 const QByteArray netscapeCertTypeByte = netscapeIt->value().toByteArray();
1683                 int netscapeCertType = 0;
1684                 QDataStream(netscapeCertTypeByte) >> netscapeCertType;
1685                 qDebug() << "Netscape cert type value:" << netscapeCertTypeByte << netscapeCertType;
1686                 if ((isClient && (netscapeCertType & NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE) == 0)
1687                     || (!isClient && (netscapeCertType & NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE) == 0)) {
1688                     qDebug() << "Netscape says: wrong usage";
1689                     element->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
1690                 }
1691             }
1692             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE) {
1693                 auto error = QSslError(QSslError::InvalidPurpose, certificate);
1694                 errors += error;
1695                 emit q->peerVerifyError(error);
1696             }
1697             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT) {
1698                 bool isTrustedRoot = false;
1699                 qDebug() << "cert is untrusted root";
1700                 if (!isTrustedRoot && !configuration.caCertificates.isEmpty()) {
1701                     // Override this error if we have the certificate inside our trusted CAs list.
1702                     if (configuration.caCertificates.contains(certificate)) {
1703                         qDebug() << "It's a trusted CA";
1704                         isTrustedRoot = true;
1705                     }
1706                 }
1707                 if (!isTrustedRoot) {
1708                     auto error = QSslError(QSslError::CertificateUntrusted, certificate);
1709                     errors += error;
1710                     emit q->peerVerifyError(error);
1711                 }
1712             }
1713             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_OFFLINE_REVOCATION
1714                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_REVOCATION_STATUS_UNKNOWN) {
1715                 // @todo what am I supposed to do about that???
1716                 qDebug() << "Revocation status unknown";
1717             }
1718             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_CYCLIC // Dumping ground of errors that don't fit our specific errors
1719                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_EXTENSION
1720                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_BASIC_CONSTRAINTS
1721                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_NAME_CONSTRAINTS
1722                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_POLICY_CONSTRAINTS
1723                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT
1724                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT
1725                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT
1726                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT
1727                 || element->TrustStatus.dwErrorStatus & CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT) {
1728                 auto error = QSslError(QSslError::UnspecifiedError, certificate);
1729                 errors += error;
1730                 emit q->peerVerifyError(error);
1731             }
1732             if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_EXPLICIT_DISTRUST) {
1733                 // @todo Rejected, untrusted, blacklisted. They all fit!
1734                 auto error = QSslError(QSslError::CertificateUntrusted, certificate);
1735                 errors += error;
1736                 emit q->peerVerifyError(error);
1737             }
1738 
1739             if (element->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) {
1740                 qDebug() << "Self-signed certificate";
1741                 bool isRootCertificateAuthority = false;
1742                 auto it = std::find_if(extensions.cbegin(), extensions.cend(),
1743                                        [](const QSslCertificateExtension &extension) {
1744                                            return extension.name() == QLatin1String("basicConstraints");
1745                                        });
1746                 if (it != extensions.cend()) {
1747                     QVariantMap basicConstraints = it->value().toMap();
1748                     qDebug() << "Basic constraints:" << basicConstraints;
1749                     // If it's self-signed *and* a CA then we can assume it's a root CA certificate
1750                     // and we can ignore the "self-signed" note
1751                     isRootCertificateAuthority = basicConstraints.value(QLatin1String("ca"), false).toBool();
1752                     qDebug() << "isRootCertificateAuthority" << isRootCertificateAuthority;
1753                 } else if (certificate.version() == "1") {
1754                     // In version 1 there was no Basic Constraint... so we can only guess...........
1755                     // @todo: check spec if "self-signed" is the only way to tell.
1756                     isRootCertificateAuthority = true;
1757                     qDebug() << "version 1 certificate";
1758                     qDebug() << "isRootCertificateAuthority" << isRootCertificateAuthority;
1759                 }
1760 
1761                 // Root certificate tends to be signed by themselves, so ignore self-signed status.
1762                 if (!isRootCertificateAuthority) {
1763                     auto error = QSslError(QSslError::SelfSignedCertificate, certificate);
1764                     errors += error;
1765                     emit q->peerVerifyError(error);
1766                 }
1767             }
1768         }
1769     }
1770 
1771     if (!configuration.peerCertificateChain.isEmpty()) {
1772         configuration.peerCertificate = configuration.peerCertificateChain.first();
1773 
1774         qDebug() << "Leaf certificate's extensions:";
1775         for (auto extension : configuration.peerCertificate.extensions()) {
1776             qDebug() << "  " << extension.name() << "-" << extension.value();
1777         }
1778     }
1779 
1780     // @Note: Somewhat copied from qsslsocket_mac.cpp
1781     // Changes: dropped check for "!canIgnoreVerify" at positions: [0], [1]
1782     const bool doVerifyPeer = configuration.peerVerifyMode == QSslSocket::VerifyPeer
1783             || (configuration.peerVerifyMode == QSslSocket::AutoVerifyPeer
1784                 && mode == QSslSocket::SslClientMode);
1785     // Check the peer certificate itself. First try the subject's common name
1786     // (CN) as a wildcard, then try all alternate subject name DNS entries the
1787     // same way.
1788     if (!configuration.peerCertificate.isNull()) {
1789         // but only if we're a client connecting to a server
1790         // if we're the server, don't check CN
1791         if (mode == QSslSocket::SslClientMode) {
1792             const QString peerName(verificationPeerName.isEmpty() ? q->peerName() : verificationPeerName);
1793             qDebug() << "peerName:" << peerName;
1794             if (!isMatchingHostname(configuration.peerCertificate, peerName)) { // [0]: here
1795                 // No matches in common names or alternate names.
1796                 const QSslError error(QSslError::HostNameMismatch, configuration.peerCertificate);
1797                 errors += error;
1798                 emit q->peerVerifyError(error);
1799             }
1800         }
1801     } else if (doVerifyPeer) { // [1]: and here
1802         // No peer certificate presented. Report as error if the socket
1803         // expected one.
1804         const QSslError error(QSslError::NoPeerCertificate);
1805         errors += error;
1806         emit q->peerVerifyError(error);
1807     }
1808 
1809     return errors;
1810 }
1811 
1812 QT_END_NAMESPACE
