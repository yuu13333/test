Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
Allow reading QObject::objectName from other threads

It is not thread-safe and will require external locking to be safe, but
at least make it possible.

Pick-to: 6.3 6.2
Change-Id: I845afa5d545ca0ac762ac369181b1497dac52195

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Copyright (C) 2013 Olivier Goffart <ogoffart@woboq.com>
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qobject.h"
43 #include "qobject_p.h"
44 #include "qmetaobject_p.h"
45 
46 #include "qabstracteventdispatcher.h"
47 #include "qabstracteventdispatcher_p.h"
48 #include "qcoreapplication.h"
49 #include "qcoreapplication_p.h"
50 #include "qloggingcategory.h"
51 #include "qvariant.h"
52 #include "qmetaobject.h"
53 #if QT_CONFIG(regularexpression)
54 #  include <qregularexpression.h>
55 #endif
56 #include <qthread.h>
57 #include <private/qthread_p.h>
58 #include <qdebug.h>
59 #include <qpair.h>
60 #include <qvarlengtharray.h>
61 #include <qscopeguard.h>
62 #include <qset.h>
63 #if QT_CONFIG(thread)
64 #include <qsemaphore.h>
65 #endif
66 #include <qsharedpointer.h>
67 
68 #include <private/qorderedmutexlocker_p.h>
69 #include <private/qhooks_p.h>
70 #include <qtcore_tracepoints_p.h>
71 
72 #include <new>
73 #include <mutex>
74 
75 #include <ctype.h>
76 #include <limits.h>
77 
78 QT_BEGIN_NAMESPACE
79 
80 static int DIRECT_CONNECTION_ONLY = 0;
81 
82 Q_LOGGING_CATEGORY(lcConnectSlotsByName, "qt.core.qmetaobject.connectslotsbyname")
83 Q_LOGGING_CATEGORY(lcConnect, "qt.core.qobject.connect")
84 
85 Q_CORE_EXPORT QBasicAtomicPointer<QSignalSpyCallbackSet> qt_signal_spy_callback_set = Q_BASIC_ATOMIC_INITIALIZER(nullptr);
86 
87 void qt_register_signal_spy_callbacks(QSignalSpyCallbackSet *callback_set)
88 {
89     qt_signal_spy_callback_set.storeRelease(callback_set);
90 }
91 
92 QDynamicMetaObjectData::~QDynamicMetaObjectData()
93 {
94 }
95 
96 QAbstractDynamicMetaObject::~QAbstractDynamicMetaObject()
97 {
98 }
99 
100 static int *queuedConnectionTypes(const QMetaMethod &method)
101 {
102     const auto parameterCount = method.parameterCount();
103     int *typeIds = new int[parameterCount + 1];
104     Q_CHECK_PTR(typeIds);
105     for (int i = 0; i < parameterCount; ++i) {
106         const QMetaType metaType = method.parameterMetaType(i);
107         if (metaType.flags() & QMetaType::IsPointer)
108             typeIds[i] = QMetaType::VoidStar;
109         else
110             typeIds[i] = metaType.id();
111         if (!typeIds[i]) {
112             const QByteArray typeName = method.parameterTypeName(i);
113             qCWarning(lcConnect,
114                       "QObject::connect: Cannot queue arguments of type '%s'\n"
115                       "(Make sure '%s' is registered using qRegisterMetaType().)",
116                       typeName.constData(), typeName.constData());
117             delete[] typeIds;
118             return nullptr;
119         }
120     }
121     typeIds[parameterCount] = 0;
122 
123     return typeIds;
124 }
125 
126 static int *queuedConnectionTypes(const QArgumentType *argumentTypes, int argc)
127 {
128     QScopedArrayPointer<int> types(new int[argc + 1]);
129     for (int i = 0; i < argc; ++i) {
130         const QArgumentType &type = argumentTypes[i];
131         if (type.type())
132             types[i] = type.type();
133         else if (type.name().endsWith('*'))
134             types[i] = QMetaType::VoidStar;
135         else
136             types[i] = QMetaType::fromName(type.name()).id();
137 
138         if (!types[i]) {
139             qCWarning(lcConnect,
140                       "QObject::connect: Cannot queue arguments of type '%s'\n"
141                       "(Make sure '%s' is registered using qRegisterMetaType().)",
142                       type.name().constData(), type.name().constData());
143             return nullptr;
144         }
145     }
146     types[argc] = 0;
147 
148     return types.take();
149 }
150 
151 static QBasicMutex _q_ObjectMutexPool[131];
152 
153 /**
154  * \internal
155  * mutex to be locked when accessing the connection lists or the senders list
156  */
157 static inline QBasicMutex *signalSlotLock(const QObject *o)
158 {
159     return &_q_ObjectMutexPool[uint(quintptr(o)) % sizeof(_q_ObjectMutexPool)/sizeof(QBasicMutex)];
160 }
161 
162 void (*QAbstractDeclarativeData::destroyed)(QAbstractDeclarativeData *, QObject *) = nullptr;
163 void (*QAbstractDeclarativeData::signalEmitted)(QAbstractDeclarativeData *, QObject *, int, void **) = nullptr;
164 int  (*QAbstractDeclarativeData::receivers)(QAbstractDeclarativeData *, const QObject *, int) = nullptr;
165 bool (*QAbstractDeclarativeData::isSignalConnected)(QAbstractDeclarativeData *, const QObject *, int) = nullptr;
166 void (*QAbstractDeclarativeData::setWidgetParent)(QObject *, QObject *) = nullptr;
167 
168 /*!
169     \fn QObjectData::QObjectData()
170     \internal
171  */
172 
173 
174 QObjectData::~QObjectData() {}
175 
176 QMetaObject *QObjectData::dynamicMetaObject() const
177 {
178     return metaObject->toDynamicMetaObject(q_ptr);
179 }
180 
181 QObjectPrivate::QObjectPrivate(int version)
182     : threadData(nullptr), currentChildBeingDeleted(nullptr)
183 {
184     checkForIncompatibleLibraryVersion(version);
185 
186     // QObjectData initialization
187     q_ptr = nullptr;
188     parent = nullptr;                           // no parent yet. It is set by setParent()
189     isWidget = false;                           // assume not a widget object
190     blockSig = false;                           // not blocking signals
191     wasDeleted = false;                         // double-delete catcher
192     isDeletingChildren = false;                 // set by deleteChildren()
193     sendChildEvents = true;                     // if we should send ChildAdded and ChildRemoved events to parent
194     receiveChildEvents = true;
195     postedEvents = 0;
196     extraData = nullptr;
197     metaObject = nullptr;
198     isWindow = false;
199     deleteLaterCalled = false;
200     isQuickItem = false;
201     willBeWidget = false;
202     wasWidget = false;
203 }
204 
205 QObjectPrivate::~QObjectPrivate()
206 {
207     auto thisThreadData = threadData.loadRelaxed();
208     if (extraData && !extraData->runningTimers.isEmpty()) {
209         if (Q_LIKELY(thisThreadData->thread.loadAcquire() == QThread::currentThread())) {
210             // unregister pending timers
211             if (thisThreadData->hasEventDispatcher())
212                 thisThreadData->eventDispatcher.loadRelaxed()->unregisterTimers(q_ptr);
213 
214             // release the timer ids back to the pool
215             for (int i = 0; i < extraData->runningTimers.size(); ++i)
216                 QAbstractEventDispatcherPrivate::releaseTimerId(extraData->runningTimers.at(i));
217         } else {
218             qWarning("QObject::~QObject: Timers cannot be stopped from another thread");
219         }
220     }
221 
222     if (postedEvents)
223         QCoreApplication::removePostedEvents(q_ptr, 0);
224 
225     thisThreadData->deref();
226 
227     if (metaObject)
228         metaObject->objectDestroyed(q_ptr);
229 
230     delete extraData;
231 }
232 
233 /*!
234   \internal
235   For a given metaobject, compute the signal offset, and the method offset (including signals)
236 */
237 static void computeOffsets(const QMetaObject *metaobject, int *signalOffset, int *methodOffset)
238 {
239     *signalOffset = *methodOffset = 0;
240     const QMetaObject *m = metaobject->d.superdata;
241     while (m) {
242         const QMetaObjectPrivate *d = QMetaObjectPrivate::get(m);
243         *methodOffset += d->methodCount;
244         Q_ASSERT(d->revision >= 4);
245         *signalOffset += d->signalCount;
246         m = m->d.superdata;
247     }
248 }
249 
250 // Used by QAccessibleWidget
251 bool QObjectPrivate::isSender(const QObject *receiver, const char *signal) const
252 {
253     Q_Q(const QObject);
254     int signal_index = signalIndex(signal);
255     ConnectionData *cd = connections.loadRelaxed();
256     if (signal_index < 0 || !cd)
257         return false;
258     QBasicMutexLocker locker(signalSlotLock(q));
259     if (signal_index < cd->signalVectorCount()) {
260         const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
261 
262         while (c) {
263             if (c->receiver.loadRelaxed() == receiver)
264                 return true;
265             c = c->nextConnectionList.loadRelaxed();
266         }
267     }
268     return false;
269 }
270 
271 // Used by QAccessibleWidget
272 QObjectList QObjectPrivate::receiverList(const char *signal) const
273 {
274     QObjectList returnValue;
275     int signal_index = signalIndex(signal);
276     ConnectionData *cd = connections.loadRelaxed();
277     if (signal_index < 0 || !cd)
278         return returnValue;
279     if (signal_index < cd->signalVectorCount()) {
280         const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
281 
282         while (c) {
283             QObject *r = c->receiver.loadRelaxed();
284             if (r)
285                 returnValue << r;
286             c = c->nextConnectionList.loadRelaxed();
287         }
288     }
289     return returnValue;
290 }
291 
292 // Used by QAccessibleWidget
293 QObjectList QObjectPrivate::senderList() const
294 {
295     QObjectList returnValue;
296     ConnectionData *cd = connections.loadRelaxed();
297     if (cd) {
298         QBasicMutexLocker locker(signalSlotLock(q_func()));
299         for (Connection *c = cd->senders; c; c = c->next)
300             returnValue << c->sender;
301     }
302     return returnValue;
303 }
304 
305 /*!
306   \internal
307   Add the connection \a c to the list of connections of the sender's object
308   for the specified \a signal
309 
310   The signalSlotLock() of the sender and receiver must be locked while calling
311   this function
312 
313   Will also add the connection in the sender's list of the receiver.
314  */
315 void QObjectPrivate::addConnection(int signal, Connection *c)
316 {
317     Q_ASSERT(c->sender == q_ptr);
318     ensureConnectionData();
319     ConnectionData *cd = connections.loadRelaxed();
320     cd->resizeSignalVector(signal + 1);
321 
322     ConnectionList &connectionList = cd->connectionsForSignal(signal);
323     if (connectionList.last.loadRelaxed()) {
324         Q_ASSERT(connectionList.last.loadRelaxed()->receiver.loadRelaxed());
325         connectionList.last.loadRelaxed()->nextConnectionList.storeRelaxed(c);
326     } else {
327         connectionList.first.storeRelaxed(c);
328     }
329     c->id = ++cd->currentConnectionId;
330     c->prevConnectionList = connectionList.last.loadRelaxed();
331     connectionList.last.storeRelaxed(c);
332 
333     QObjectPrivate *rd = QObjectPrivate::get(c->receiver.loadRelaxed());
334     rd->ensureConnectionData();
335 
336     c->prev = &(rd->connections.loadRelaxed()->senders);
337     c->next = *c->prev;
338     *c->prev = c;
339     if (c->next)
340         c->next->prev = &c->next;
341 }
342 
343 void QObjectPrivate::ConnectionData::removeConnection(QObjectPrivate::Connection *c)
344 {
345     Q_ASSERT(c->receiver.loadRelaxed());
346     ConnectionList &connections = signalVector.loadRelaxed()->at(c->signal_index);
347     c->receiver.storeRelaxed(nullptr);
348     QThreadData *td = c->receiverThreadData.loadRelaxed();
349     if (td)
350         td->deref();
351     c->receiverThreadData.storeRelaxed(nullptr);
352 
353 #ifndef QT_NO_DEBUG
354     bool found = false;
355     for (Connection *cc = connections.first.loadRelaxed(); cc; cc = cc->nextConnectionList.loadRelaxed()) {
356         if (cc == c) {
357             found = true;
358             break;
359         }
360     }
361     Q_ASSERT(found);
362 #endif
363 
364     // remove from the senders linked list
365     *c->prev = c->next;
366     if (c->next)
367         c->next->prev = c->prev;
368     c->prev = nullptr;
369 
370     if (connections.first.loadRelaxed() == c)
371         connections.first.storeRelaxed(c->nextConnectionList.loadRelaxed());
372     if (connections.last.loadRelaxed() == c)
373         connections.last.storeRelaxed(c->prevConnectionList);
374     Q_ASSERT(signalVector.loadRelaxed()->at(c->signal_index).first.loadRelaxed() != c);
375     Q_ASSERT(signalVector.loadRelaxed()->at(c->signal_index).last.loadRelaxed() != c);
376 
377     // keep c->nextConnectionList intact, as it might still get accessed by activate
378     Connection *n = c->nextConnectionList.loadRelaxed();
379     if (n)
380         n->prevConnectionList = c->prevConnectionList;
381     if (c->prevConnectionList)
382         c->prevConnectionList->nextConnectionList.storeRelaxed(n);
383     c->prevConnectionList = nullptr;
384 
385     Q_ASSERT(c != orphaned.loadRelaxed());
386     // add c to orphanedConnections
387     Connection *o = nullptr;
388     /* No ABA issue here: When adding a node, we only care about the list head, it doesn't
389      * matter if the tail changes.
390      */
391     do {
392         o = orphaned.loadRelaxed();
393         c->nextInOrphanList = o;
394     } while (!orphaned.testAndSetRelease(o, c));
395 
396 #ifndef QT_NO_DEBUG
397     found = false;
398     for (Connection *cc = connections.first.loadRelaxed(); cc; cc = cc->nextConnectionList.loadRelaxed()) {
399         if (cc == c) {
400             found = true;
401             break;
402         }
403     }
404     Q_ASSERT(!found);
405 #endif
406 
407 }
408 
409 void QObjectPrivate::ConnectionData::cleanOrphanedConnectionsImpl(QObject *sender, LockPolicy lockPolicy)
410 {
411     QBasicMutex *senderMutex = signalSlotLock(sender);
412     ConnectionOrSignalVector *c = nullptr;
413     {
414         std::unique_lock<QBasicMutex> lock(*senderMutex, std::defer_lock_t{});
415         if (lockPolicy == NeedToLock)
416             lock.lock();
417         if (ref.loadAcquire() > 1)
418             return;
419 
420         // Since ref == 1, no activate() is in process since we locked the mutex. That implies,
421         // that nothing can reference the orphaned connection objects anymore and they can
422         // be safely deleted
423         c = orphaned.fetchAndStoreRelaxed(nullptr);
424     }
425     if (c) {
426         // Deleting c might run arbitrary user code, so we must not hold the lock
427         if (lockPolicy == AlreadyLockedAndTemporarilyReleasingLock) {
428             senderMutex->unlock();
429             deleteOrphaned(c);
430             senderMutex->lock();
431         } else {
432             deleteOrphaned(c);
433         }
434     }
435 }
436 
437 void QObjectPrivate::ConnectionData::deleteOrphaned(QObjectPrivate::ConnectionOrSignalVector *o)
438 {
439     while (o) {
440         QObjectPrivate::ConnectionOrSignalVector *next = nullptr;
441         if (SignalVector *v = ConnectionOrSignalVector::asSignalVector(o)) {
442             next = v->nextInOrphanList;
443             free(v);
444         } else {
445             QObjectPrivate::Connection *c = static_cast<Connection *>(o);
446             next = c->nextInOrphanList;
447             Q_ASSERT(!c->receiver.loadRelaxed());
448             Q_ASSERT(!c->prev);
449             c->freeSlotObject();
450             c->deref();
451         }
452         o = next;
453     }
454 }
455 
456 /*! \internal
457 
458   Returns \c true if the signal with index \a signal_index from object \a sender is connected.
459 
460   \a signal_index must be the index returned by QObjectPrivate::signalIndex;
461 */
462 bool QObjectPrivate::isSignalConnected(uint signalIndex, bool checkDeclarative) const
463 {
464     if (checkDeclarative && isDeclarativeSignalConnected(signalIndex))
465         return true;
466 
467     ConnectionData *cd = connections.loadRelaxed();
468     if (!cd)
469         return false;
470     SignalVector *signalVector = cd->signalVector.loadRelaxed();
471     if (!signalVector)
472         return false;
473 
474     if (signalVector->at(-1).first.loadRelaxed())
475         return true;
476 
477     if (signalIndex < uint(cd->signalVectorCount())) {
478         const QObjectPrivate::Connection *c = signalVector->at(signalIndex).first.loadRelaxed();
479         while (c) {
480             if (c->receiver.loadRelaxed())
481                 return true;
482             c = c->nextConnectionList.loadRelaxed();
483         }
484     }
485     return false;
486 }
487 
488 bool QObjectPrivate::maybeSignalConnected(uint signalIndex) const
489 {
490     ConnectionData *cd = connections.loadRelaxed();
491     if (!cd)
492         return false;
493     SignalVector *signalVector = cd->signalVector.loadRelaxed();
494     if (!signalVector)
495         return false;
496 
497     if (signalVector->at(-1).first.loadAcquire())
498         return true;
499 
500     if (signalIndex < uint(cd->signalVectorCount())) {
501         const QObjectPrivate::Connection *c = signalVector->at(signalIndex).first.loadAcquire();
502         return c != nullptr;
503     }
504     return false;
505 }
506 
507 /*!
508     \internal
509  */
510 QAbstractMetaCallEvent::~QAbstractMetaCallEvent()
511 {
512 #if QT_CONFIG(thread)
513     if (semaphore_)
514         semaphore_->release();
515 #endif
516 }
517 
518 /*!
519     \internal
520  */
521 inline void QMetaCallEvent::allocArgs()
522 {
523     if (!d.nargs_)
524         return;
525 
526     constexpr size_t each = sizeof(void*) + sizeof(QMetaType);
527     void *const memory = d.nargs_ * each > sizeof(prealloc_) ?
528         calloc(d.nargs_, each) : prealloc_;
529 
530     Q_CHECK_PTR(memory);
531     d.args_ = static_cast<void **>(memory);
532 }
533 
534 /*!
535     \internal
536 
537     Used for blocking queued connections, just passes \a args through without
538     allocating any memory.
539  */
540 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative,
541                                QObjectPrivate::StaticMetaCallFunction callFunction,
542                                const QObject *sender, int signalId,
543                                void **args, QSemaphore *semaphore)
544     : QAbstractMetaCallEvent(sender, signalId, semaphore),
545       d({nullptr, args, callFunction, 0, method_offset, method_relative}),
546       prealloc_()
547 {
548 }
549 
550 /*!
551     \internal
552 
553     Used for blocking queued connections, just passes \a args through without
554     allocating any memory.
555  */
556 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO,
557                                const QObject *sender, int signalId,
558                                void **args, QSemaphore *semaphore)
559     : QAbstractMetaCallEvent(sender, signalId, semaphore),
560       d({slotO, args, nullptr, 0, 0, ushort(-1)}),
561       prealloc_()
562 {
563     if (d.slotObj_)
564         d.slotObj_->ref();
565 }
566 
567 /*!
568     \internal
569 
570     Allocates memory for \a nargs; code creating an event needs to initialize
571     the void* and int arrays by accessing \a args() and \a types(), respectively.
572  */
573 QMetaCallEvent::QMetaCallEvent(ushort method_offset, ushort method_relative,
574                                QObjectPrivate::StaticMetaCallFunction callFunction,
575                                const QObject *sender, int signalId,
576                                int nargs)
577     : QAbstractMetaCallEvent(sender, signalId),
578       d({nullptr, nullptr, callFunction, nargs, method_offset, method_relative}),
579       prealloc_()
580 {
581     allocArgs();
582 }
583 
584 /*!
585     \internal
586 
587     Allocates memory for \a nargs; code creating an event needs to initialize
588     the void* and int arrays by accessing \a args() and \a types(), respectively.
589  */
590 QMetaCallEvent::QMetaCallEvent(QtPrivate::QSlotObjectBase *slotO,
591                                const QObject *sender, int signalId,
592                                int nargs)
593     : QAbstractMetaCallEvent(sender, signalId),
594       d({slotO, nullptr, nullptr, nargs, 0, ushort(-1)}),
595       prealloc_()
596 {
597     if (d.slotObj_)
598         d.slotObj_->ref();
599     allocArgs();
600 }
601 
602 /*!
603     \internal
604  */
605 QMetaCallEvent::~QMetaCallEvent()
606 {
607     if (d.nargs_) {
608         QMetaType *t = types();
609         for (int i = 0; i < d.nargs_; ++i) {
610             if (t[i].isValid() && d.args_[i])
611                 t[i].destroy(d.args_[i]);
612         }
613         if (reinterpret_cast<void *>(d.args_) != reinterpret_cast<void *>(prealloc_))
614             free(d.args_);
615     }
616     if (d.slotObj_)
617         d.slotObj_->destroyIfLastRef();
618 }
619 
620 /*!
621     \internal
622  */
623 void QMetaCallEvent::placeMetaCall(QObject *object)
624 {
625     if (d.slotObj_) {
626         d.slotObj_->call(object, d.args_);
627     } else if (d.callFunction_ && d.method_offset_ <= object->metaObject()->methodOffset()) {
628         d.callFunction_(object, QMetaObject::InvokeMetaMethod, d.method_relative_, d.args_);
629     } else {
630         QMetaObject::metacall(object, QMetaObject::InvokeMetaMethod,
631                               d.method_offset_ + d.method_relative_, d.args_);
632     }
633 }
634 
635 /*!
636     \class QSignalBlocker
637     \brief Exception-safe wrapper around QObject::blockSignals().
638     \since 5.3
639     \ingroup objectmodel
640     \inmodule QtCore
641 
642     \reentrant
643 
644     QSignalBlocker can be used wherever you would otherwise use a
645     pair of calls to blockSignals(). It blocks signals in its
646     constructor and in the destructor it resets the state to what
647     it was before the constructor ran.
648 
649     \snippet code/src_corelib_kernel_qobject.cpp 53
650     is thus equivalent to
651     \snippet code/src_corelib_kernel_qobject.cpp 54
652 
653     except the code using QSignalBlocker is safe in the face of
654     exceptions.
655 
656     \sa QMutexLocker, QEventLoopLocker
657 */
658 
659 /*!
660     \fn QSignalBlocker::QSignalBlocker(QObject *object)
661 
662     Constructor. Calls \a{object}->blockSignals(true).
663 */
664 
665 /*!
666     \fn QSignalBlocker::QSignalBlocker(QObject &object)
667     \overload
668 
669     Calls \a{object}.blockSignals(true).
670 */
671 
672 /*!
673     \fn QSignalBlocker::QSignalBlocker(QSignalBlocker &&other)
674 
675     Move-constructs a signal blocker from \a other. \a other will have
676     a no-op destructor, while responsibility for restoring the
677     QObject::signalsBlocked() state is transferred to the new object.
678 */
679 
680 /*!
681     \fn QSignalBlocker &QSignalBlocker::operator=(QSignalBlocker &&other)
682 
683     Move-assigns this signal blocker from \a other. \a other will have
684     a no-op destructor, while responsibility for restoring the
685     QObject::signalsBlocked() state is transferred to this object.
686 
687     The object's signals this signal blocker was blocking prior to
688     being moved to, if any, are unblocked \e except in the case where
689     both instances block the same object's signals and \c *this is
690     unblocked while \a other is not, at the time of the move.
691 */
692 
693 /*!
694     \fn QSignalBlocker::~QSignalBlocker()
695 
696     Destructor. Restores the QObject::signalsBlocked() state to what it
697     was before the constructor ran, unless unblock() has been called
698     without a following reblock(), in which case it does nothing.
699 */
700 
701 /*!
702     \fn void QSignalBlocker::reblock()
703 
704     Re-blocks signals after a previous unblock().
705 
706     The numbers of reblock() and unblock() calls are not counted, so
707     every reblock() undoes any number of unblock() calls.
708 */
709 
710 /*!
711     \fn void QSignalBlocker::unblock()
712 
713     Temporarily restores the QObject::signalsBlocked() state to what
714     it was before this QSignalBlocker's constructor ran. To undo, use
715     reblock().
716 
717     The numbers of reblock() and unblock() calls are not counted, so
718     every unblock() undoes any number of reblock() calls.
719 */
720 
721 /*!
722     \class QObject
723     \inmodule QtCore
724     \brief The QObject class is the base class of all Qt objects.
725 
726     \ingroup objectmodel
727 
728     \reentrant
729 
730     QObject is the heart of the Qt \l{Object Model}. The central
731     feature in this model is a very powerful mechanism for seamless
732     object communication called \l{signals and slots}. You can
733     connect a signal to a slot with connect() and destroy the
734     connection with disconnect(). To avoid never ending notification
735     loops you can temporarily block signals with blockSignals(). The
736     protected functions connectNotify() and disconnectNotify() make
737     it possible to track connections.
738 
739     QObjects organize themselves in \l {Object Trees & Ownership}
740     {object trees}. When you create a QObject with another object as
741     parent, the object will automatically add itself to the parent's
742     children() list. The parent takes ownership of the object; i.e.,
743     it will automatically delete its children in its destructor. You
744     can look for an object by name and optionally type using
745     findChild() or findChildren().
746 
747     Every object has an objectName() and its class name can be found
748     via the corresponding metaObject() (see QMetaObject::className()).
749     You can determine whether the object's class inherits another
750     class in the QObject inheritance hierarchy by using the
751     inherits() function.
752 
753     When an object is deleted, it emits a destroyed() signal. You can
754     catch this signal to avoid dangling references to QObjects.
755 
756     QObjects can receive events through event() and filter the events
757     of other objects. See installEventFilter() and eventFilter() for
758     details. A convenience handler, childEvent(), can be reimplemented
759     to catch child events.
760 
761     Last but not least, QObject provides the basic timer support in
762     Qt; see QTimer for high-level support for timers.
763 
764     Notice that the Q_OBJECT macro is mandatory for any object that
765     implements signals, slots or properties. You also need to run the
766     \l{moc}{Meta Object Compiler} on the source file. We strongly
767     recommend the use of this macro in all subclasses of QObject
768     regardless of whether or not they actually use signals, slots and
769     properties, since failure to do so may lead certain functions to
770     exhibit strange behavior.
771 
772     All Qt widgets inherit QObject. The convenience function
773     isWidgetType() returns whether an object is actually a widget. It
774     is much faster than
775     \l{qobject_cast()}{qobject_cast}<QWidget *>(\e{obj}) or
776     \e{obj}->\l{inherits()}{inherits}("QWidget").
777 
778     Some QObject functions, e.g. children(), return a QObjectList.
779     QObjectList is a typedef for QList<QObject *>.
780 
781     \section1 Thread Affinity
782 
783     A QObject instance is said to have a \e{thread affinity}, or that
784     it \e{lives} in a certain thread. When a QObject receives a
785     \l{Qt::QueuedConnection}{queued signal} or a \l{The Event
786     System#Sending Events}{posted event}, the slot or event handler
787     will run in the thread that the object lives in.
788 
789     \note If a QObject has no thread affinity (that is, if thread()
790     returns zero), or if it lives in a thread that has no running event
791     loop, then it cannot receive queued signals or posted events.
792 
793     By default, a QObject lives in the thread in which it is created.
794     An object's thread affinity can be queried using thread() and
795     changed using moveToThread().
796 
797     All QObjects must live in the same thread as their parent. Consequently:
798 
799     \list
800     \li setParent() will fail if the two QObjects involved live in
801         different threads.
802     \li When a QObject is moved to another thread, all its children
803         will be automatically moved too.
804     \li moveToThread() will fail if the QObject has a parent.
805     \li If QObjects are created within QThread::run(), they cannot
806         become children of the QThread object because the QThread does
807         not live in the thread that calls QThread::run().
808     \endlist
809 
810     \note A QObject's member variables \e{do not} automatically become
811     its children. The parent-child relationship must be set by either
812     passing a pointer to the child's \l{QObject()}{constructor}, or by
813     calling setParent(). Without this step, the object's member variables
814     will remain in the old thread when moveToThread() is called.
815 
816     \target No copy constructor
817     \section1 No Copy Constructor or Assignment Operator
818 
819     QObject has neither a copy constructor nor an assignment operator.
820     This is by design. Actually, they are declared, but in a
821     \c{private} section with the macro Q_DISABLE_COPY(). In fact, all
822     Qt classes derived from QObject (direct or indirect) use this
823     macro to declare their copy constructor and assignment operator to
824     be private. The reasoning is found in the discussion on
825     \l{Identity vs Value} {Identity vs Value} on the Qt \l{Object
826     Model} page.
827 
828     The main consequence is that you should use pointers to QObject
829     (or to your QObject subclass) where you might otherwise be tempted
830     to use your QObject subclass as a value. For example, without a
831     copy constructor, you can't use a subclass of QObject as the value
832     to be stored in one of the container classes. You must store
833     pointers.
834 
835     \section1 Auto-Connection
836 
837     Qt's meta-object system provides a mechanism to automatically connect
838     signals and slots between QObject subclasses and their children. As long
839     as objects are defined with suitable object names, and slots follow a
840     simple naming convention, this connection can be performed at run-time
841     by the QMetaObject::connectSlotsByName() function.
842 
843     \l uic generates code that invokes this function to enable
844     auto-connection to be performed between widgets on forms created
845     with \e{Qt Designer}. More information about using auto-connection with \e{Qt Designer} is
846     given in the \l{Using a Designer UI File in Your Application} section of
847     the \e{Qt Designer} manual.
848 
849     \section1 Dynamic Properties
850 
851     From Qt 4.2, dynamic properties can be added to and removed from QObject
852     instances at run-time. Dynamic properties do not need to be declared at
853     compile-time, yet they provide the same advantages as static properties
854     and are manipulated using the same API - using property() to read them
855     and setProperty() to write them.
856 
857     From Qt 4.3, dynamic properties are supported by
858     \l{Qt Designer's Widget Editing Mode#The Property Editor}{Qt Designer},
859     and both standard Qt widgets and user-created forms can be given dynamic
860     properties.
861 
862     \section1 Internationalization (I18n)
863 
864     All QObject subclasses support Qt's translation features, making it possible
865     to translate an application's user interface into different languages.
866 
867     To make user-visible text translatable, it must be wrapped in calls to
868     the tr() function. This is explained in detail in the
869     \l{Writing Source Code for Translation} document.
870 
871     \sa QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY()
872     \sa {Object Trees & Ownership}
873 */
874 
875 /*****************************************************************************
876   QObject member functions
877  *****************************************************************************/
878 
879 // check the constructor's parent thread argument
880 static bool check_parent_thread(QObject *parent,
881                                 QThreadData *parentThreadData,
882                                 QThreadData *currentThreadData)
883 {
884     if (parent && parentThreadData != currentThreadData) {
885         QThread *parentThread = parentThreadData->thread.loadAcquire();
886         QThread *currentThread = currentThreadData->thread.loadAcquire();
887         qWarning("QObject: Cannot create children for a parent that is in a different thread.\n"
888                  "(Parent is %s(%p), parent's thread is %s(%p), current thread is %s(%p)",
889                  parent->metaObject()->className(),
890                  parent,
891                  parentThread ? parentThread->metaObject()->className() : "QThread",
892                  parentThread,
893                  currentThread ? currentThread->metaObject()->className() : "QThread",
894                  currentThread);
895         return false;
896     }
897     return true;
898 }
899 
900 /*!
901     Constructs an object with parent object \a parent.
902 
903     The parent of an object may be viewed as the object's owner. For
904     instance, a \l{QDialog}{dialog box} is the parent of the \uicontrol{OK}
905     and \uicontrol{Cancel} buttons it contains.
906 
907     The destructor of a parent object destroys all child objects.
908 
909     Setting \a parent to \nullptr constructs an object with no parent. If the
910     object is a widget, it will become a top-level window.
911 
912     \sa parent(), findChild(), findChildren()
913 */
914 
915 QObject::QObject(QObject *parent)
916     : QObject(*new QObjectPrivate, parent)
917 {
918 }
919 
920 /*!
921     \internal
922  */
923 QObject::QObject(QObjectPrivate &dd, QObject *parent)
924     : d_ptr(&dd)
925 {
926     Q_ASSERT_X(this != parent, Q_FUNC_INFO, "Cannot parent a QObject to itself");
927 
928     Q_D(QObject);
929     d_ptr->q_ptr = this;
930     auto threadData = (parent && !parent->thread()) ? parent->d_func()->threadData.loadRelaxed() : QThreadData::current();
931     threadData->ref();
932     d->threadData.storeRelaxed(threadData);
933     if (parent) {
934         QT_TRY {
935             if (!check_parent_thread(parent, parent ? parent->d_func()->threadData.loadRelaxed() : nullptr, threadData))
936                 parent = nullptr;
937             if (d->willBeWidget) {
938                 if (parent) {
939                     d->parent = parent;
940                     d->parent->d_func()->children.append(this);
941                 }
942                 // no events sent here, this is done at the end of the QWidget constructor
943             } else {
944                 setParent(parent);
945             }
946         } QT_CATCH(...) {
947             threadData->deref();
948             QT_RETHROW;
949         }
950     }
951     if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
952         reinterpret_cast<QHooks::AddQObjectCallback>(qtHookData[QHooks::AddQObject])(this);
953     Q_TRACE(QObject_ctor, this);
954 }
955 
956 void QObjectPrivate::clearBindingStorage()
957 {
958     bindingStorage.clear();
959 }
960 
961 /*!
962     Destroys the object, deleting all its child objects.
963 
964     All signals to and from the object are automatically disconnected, and
965     any pending posted events for the object are removed from the event
966     queue. However, it is often safer to use deleteLater() rather than
967     deleting a QObject subclass directly.
968 
969     \warning All child objects are deleted. If any of these objects
970     are on the stack or global, sooner or later your program will
971     crash. We do not recommend holding pointers to child objects from
972     outside the parent. If you still do, the destroyed() signal gives
973     you an opportunity to detect when an object is destroyed.
974 
975     \warning Deleting a QObject while pending events are waiting to
976     be delivered can cause a crash. You must not delete the QObject
977     directly if it exists in a different thread than the one currently
978     executing. Use deleteLater() instead, which will cause the event
979     loop to delete the object after all pending events have been
980     delivered to it.
981 
982     \sa deleteLater()
983 */
984 
985 QObject::~QObject()
986 {
987     Q_D(QObject);
988     d->wasDeleted = true;
989     d->blockSig = 0; // unblock signals so we always emit destroyed()
990 
991     // If we reached this point, we need to clear the binding data
992     // as the corresponding properties are no longer useful
993     d->clearBindingStorage();
994 
995     QtSharedPointer::ExternalRefCountData *sharedRefcount = d->sharedRefcount.loadRelaxed();
996     if (sharedRefcount) {
997         if (sharedRefcount->strongref.loadRelaxed() > 0) {
998             qWarning("QObject: shared QObject was deleted directly. The program is malformed and may crash.");
999             // but continue deleting, it's too late to stop anyway
1000         }
1001 
1002         // indicate to all QWeakPointers that this QObject has now been deleted
1003         sharedRefcount->strongref.storeRelaxed(0);
1004         if (!sharedRefcount->weakref.deref())
1005             delete sharedRefcount;
1006     }
1007 
1008     if (!d->wasWidget && d->isSignalConnected(0)) {
1009         emit destroyed(this);
1010     }
1011 
1012     if (d->declarativeData && QAbstractDeclarativeData::destroyed)
1013         QAbstractDeclarativeData::destroyed(d->declarativeData, this);
1014 
1015     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
1016     if (cd) {
1017         if (cd->currentSender) {
1018             cd->currentSender->receiverDeleted();
1019             cd->currentSender = nullptr;
1020         }
1021 
1022         QBasicMutex *signalSlotMutex = signalSlotLock(this);
1023         QBasicMutexLocker locker(signalSlotMutex);
1024 
1025         // disconnect all receivers
1026         int receiverCount = cd->signalVectorCount();
1027         for (int signal = -1; signal < receiverCount; ++signal) {
1028             QObjectPrivate::ConnectionList &connectionList = cd->connectionsForSignal(signal);
1029 
1030             while (QObjectPrivate::Connection *c = connectionList.first.loadRelaxed()) {
1031                 Q_ASSERT(c->receiver.loadAcquire());
1032 
1033                 QBasicMutex *m = signalSlotLock(c->receiver.loadRelaxed());
1034                 bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
1035                 if (c == connectionList.first.loadAcquire() && c->receiver.loadAcquire()) {
1036                     cd->removeConnection(c);
1037                     Q_ASSERT(connectionList.first.loadRelaxed() != c);
1038                 }
1039                 if (needToUnlock)
1040                     m->unlock();
1041             }
1042         }
1043 
1044         /* Disconnect all senders:
1045          */
1046         while (QObjectPrivate::Connection *node = cd->senders) {
1047             Q_ASSERT(node->receiver.loadAcquire());
1048             QObject *sender = node->sender;
1049             // Send disconnectNotify before removing the connection from sender's connection list.
1050             // This ensures any eventual destructor of sender will block on getting receiver's lock
1051             // and not finish until we release it.
1052             sender->disconnectNotify(QMetaObjectPrivate::signal(sender->metaObject(), node->signal_index));
1053             QBasicMutex *m = signalSlotLock(sender);
1054             bool needToUnlock = QOrderedMutexLocker::relock(signalSlotMutex, m);
1055             //the node has maybe been removed while the mutex was unlocked in relock?
1056             if (node != cd->senders) {
1057                 // We hold the wrong mutex
1058                 Q_ASSERT(needToUnlock);
1059                 m->unlock();
1060                 continue;
1061             }
1062 
1063             QObjectPrivate::ConnectionData *senderData = sender->d_func()->connections.loadRelaxed();
1064             Q_ASSERT(senderData);
1065 
1066             QtPrivate::QSlotObjectBase *slotObj = nullptr;
1067             if (node->isSlotObject) {
1068                 slotObj = node->slotObj;
1069                 node->isSlotObject = false;
1070             }
1071 
1072             senderData->removeConnection(node);
1073             /*
1074               When we unlock, another thread has the chance to delete/modify sender data.
1075               Thus we need to call cleanOrphanedConnections before unlocking. We use the
1076               variant of the function which assumes that the lock is already held to avoid
1077               a deadlock.
1078               We need to hold m, the sender lock. Considering that we might execute arbitrary user
1079               code, we should already release the signalSlotMutex here – unless they are the same.
1080             */
1081             const bool locksAreTheSame = signalSlotMutex == m;
1082             if (!locksAreTheSame)
1083                 locker.unlock();
1084             senderData->cleanOrphanedConnections(
1085                         sender,
1086                         QObjectPrivate::ConnectionData::AlreadyLockedAndTemporarilyReleasingLock
1087                         );
1088             if (needToUnlock)
1089                 m->unlock();
1090 
1091             if (locksAreTheSame) // otherwise already unlocked
1092                 locker.unlock();
1093             if (slotObj)
1094                 slotObj->destroyIfLastRef();
1095             locker.relock();
1096         }
1097 
1098         // invalidate all connections on the object and make sure
1099         // activate() will skip them
1100         cd->currentConnectionId.storeRelaxed(0);
1101     }
1102     if (cd && !cd->ref.deref())
1103         delete cd;
1104     d->connections.storeRelaxed(nullptr);
1105 
1106     if (!d->children.isEmpty())
1107         d->deleteChildren();
1108 
1109     if (Q_UNLIKELY(qtHookData[QHooks::RemoveQObject]))
1110         reinterpret_cast<QHooks::RemoveQObjectCallback>(qtHookData[QHooks::RemoveQObject])(this);
1111 
1112     Q_TRACE(QObject_dtor, this);
1113 
1114     if (d->parent)        // remove it from parent object
1115         d->setParent_helper(nullptr);
1116 }
1117 
1118 QObjectPrivate::Connection::~Connection()
1119 {
1120     if (ownArgumentTypes) {
1121         const int *v = argumentTypes.loadRelaxed();
1122         if (v != &DIRECT_CONNECTION_ONLY)
1123             delete[] v;
1124     }
1125     if (isSlotObject)
1126         slotObj->destroyIfLastRef();
1127 }
1128 
1129 
1130 /*!
1131     \fn const QMetaObject *QObject::metaObject() const
1132 
1133     Returns a pointer to the meta-object of this object.
1134 
1135     A meta-object contains information about a class that inherits
1136     QObject, e.g. class name, superclass name, properties, signals and
1137     slots. Every QObject subclass that contains the Q_OBJECT macro will have a
1138     meta-object.
1139 
1140     The meta-object information is required by the signal/slot
1141     connection mechanism and the property system. The inherits()
1142     function also makes use of the meta-object.
1143 
1144     If you have no pointer to an actual object instance but still
1145     want to access the meta-object of a class, you can use \l
1146     staticMetaObject.
1147 
1148     Example:
1149 
1150     \snippet code/src_corelib_kernel_qobject.cpp 1
1151 
1152     \sa staticMetaObject
1153 */
1154 
1155 /*!
1156     \variable QObject::staticMetaObject
1157 
1158     This variable stores the meta-object for the class.
1159 
1160     A meta-object contains information about a class that inherits
1161     QObject, e.g. class name, superclass name, properties, signals and
1162     slots. Every class that contains the Q_OBJECT macro will also have
1163     a meta-object.
1164 
1165     The meta-object information is required by the signal/slot
1166     connection mechanism and the property system. The inherits()
1167     function also makes use of the meta-object.
1168 
1169     If you have a pointer to an object, you can use metaObject() to
1170     retrieve the meta-object associated with that object.
1171 
1172     Example:
1173 
1174     \snippet code/src_corelib_kernel_qobject.cpp 2
1175 
1176     \sa metaObject()
1177 */
1178 
1179 /*!
1180     \fn template <class T> T qobject_cast(QObject *object)
1181     \fn template <class T> T qobject_cast(const QObject *object)
1182     \relates QObject
1183 
1184     Returns the given \a object cast to type T if the object is of type
1185     T (or of a subclass); otherwise returns \nullptr. If \a object is
1186     \nullptr then it will also return \nullptr.
1187 
1188     The class T must inherit (directly or indirectly) QObject and be
1189     declared with the \l Q_OBJECT macro.
1190 
1191     A class is considered to inherit itself.
1192 
1193     Example:
1194 
1195     \snippet code/src_corelib_kernel_qobject.cpp 3
1196 
1197     The qobject_cast() function behaves similarly to the standard C++
1198     \c dynamic_cast(), with the advantages that it doesn't require
1199     RTTI support and it works across dynamic library boundaries.
1200 
1201     qobject_cast() can also be used in conjunction with interfaces;
1202     see the \l{tools/plugandpaint/app}{Plug & Paint} example for details.
1203 
1204     \warning If T isn't declared with the Q_OBJECT macro, this
1205     function's return value is undefined.
1206 
1207     \sa QObject::inherits()
1208 */
1209 
1210 /*!
1211     \fn bool QObject::inherits(const char *className) const
1212 
1213     Returns \c true if this object is an instance of a class that
1214     inherits \a className or a QObject subclass that inherits \a
1215     className; otherwise returns \c false.
1216 
1217     A class is considered to inherit itself.
1218 
1219     Example:
1220 
1221     \snippet code/src_corelib_kernel_qobject.cpp 4
1222 
1223     If you need to determine whether an object is an instance of a particular
1224     class for the purpose of casting it, consider using qobject_cast<Type *>(object)
1225     instead.
1226 
1227     \sa metaObject(), qobject_cast()
1228 */
1229 
1230 /*!
1231     \property QObject::objectName
1232 
1233     \brief the name of this object
1234 
1235     You can find an object by name (and type) using findChild().
1236     You can find a set of objects with findChildren().
1237 
1238     \snippet code/src_corelib_kernel_qobject.cpp 5
1239 
1240     By default, this property contains an empty string.
1241 
1242     \sa metaObject(), QMetaObject::className()
1243 */
1244 
1245 QString QObject::objectName() const
1246 {
1247     Q_D(const QObject);
1248     if (QThread::currentThread() != thread())
1249         return d->extraData ? d->extraData->objectName.valueBypassingBindings() : QString();
1250     if (!d->extraData && QtPrivate::isAnyBindingEvaluating()) {
1251         QObjectPrivate *dd = const_cast<QObjectPrivate *>(d);
1252         // extraData is mutable, so this should be safe
1253         dd->extraData = new QObjectPrivate::ExtraData(dd);
1254     }
1255     return d->extraData ? d->extraData->objectName : QString();
1256 }
1257 
1258 /*
1259     Sets the object's name to \a name.
1260 */
1261 void QObject::setObjectName(const QString &name)
1262 {
1263     Q_D(QObject);
1264 
1265     if (!d->extraData)
1266         d->extraData = new QObjectPrivate::ExtraData(d);
1267 
1268     d->extraData->objectName.removeBindingUnlessInWrapper();
1269 
1270     if (d->extraData->objectName != name) {
1271         d->extraData->objectName.setValueBypassingBindings(name);
1272         d->extraData->objectName.notify(); // also emits a signal
1273     }
1274 }
1275 
1276 QBindable<QString> QObject::bindableObjectName()
1277 {
1278     Q_D(QObject);
1279 
1280     if (!d->extraData)
1281         d->extraData = new QObjectPrivate::ExtraData(d);
1282 
1283     return QBindable<QString>(&d->extraData->objectName);
1284 }
1285 
1286 /*! \fn void QObject::objectNameChanged(const QString &objectName)
1287 
1288     This signal is emitted after the object's name has been changed. The new object name is passed as \a objectName.
1289 
1290     \sa QObject::objectName
1291 */
1292 
1293 /*!
1294     \fn bool QObject::isWidgetType() const
1295 
1296     Returns \c true if the object is a widget; otherwise returns \c false.
1297 
1298     Calling this function is equivalent to calling
1299     \c{inherits("QWidget")}, except that it is much faster.
1300 */
1301 
1302 /*!
1303     \fn bool QObject::isWindowType() const
1304 
1305     Returns \c true if the object is a window; otherwise returns \c false.
1306 
1307     Calling this function is equivalent to calling
1308     \c{inherits("QWindow")}, except that it is much faster.
1309 */
1310 
1311 /*!
1312     \fn bool QObject::isQuickItemType() const
1313 
1314     Returns \c true if the object is a QQuickItem; otherwise returns \c false.
1315 
1316     Calling this function is equivalent to calling
1317     \c{inherits("QQuickItem")}, except that it is much faster.
1318 
1319     \since 6.4
1320 */
1321 
1322 /*!
1323     This virtual function receives events to an object and should
1324     return true if the event \a e was recognized and processed.
1325 
1326     The event() function can be reimplemented to customize the
1327     behavior of an object.
1328 
1329     Make sure you call the parent event class implementation
1330     for all the events you did not handle.
1331 
1332     Example:
1333 
1334     \snippet code/src_corelib_kernel_qobject.cpp 52
1335 
1336     \sa installEventFilter(), timerEvent(), QCoreApplication::sendEvent(),
1337     QCoreApplication::postEvent()
1338 */
1339 
1340 bool QObject::event(QEvent *e)
1341 {
1342     switch (e->type()) {
1343     case QEvent::Timer:
1344         timerEvent((QTimerEvent *)e);
1345         break;
1346 
1347     case QEvent::ChildAdded:
1348     case QEvent::ChildPolished:
1349     case QEvent::ChildRemoved:
1350         childEvent((QChildEvent *)e);
1351         break;
1352 
1353     case QEvent::DeferredDelete:
1354         qDeleteInEventHandler(this);
1355         break;
1356 
1357     case QEvent::MetaCall:
1358         {
1359             QAbstractMetaCallEvent *mce = static_cast<QAbstractMetaCallEvent*>(e);
1360 
1361             if (!d_func()->connections.loadRelaxed()) {
1362                 QBasicMutexLocker locker(signalSlotLock(this));
1363                 d_func()->ensureConnectionData();
1364             }
1365             QObjectPrivate::Sender sender(this, const_cast<QObject*>(mce->sender()), mce->signalId());
1366 
1367             mce->placeMetaCall(this);
1368             break;
1369         }
1370 
1371     case QEvent::ThreadChange: {
1372         Q_D(QObject);
1373         QThreadData *threadData = d->threadData.loadRelaxed();
1374         QAbstractEventDispatcher *eventDispatcher = threadData->eventDispatcher.loadRelaxed();
1375         if (eventDispatcher) {
1376             QList<QAbstractEventDispatcher::TimerInfo> timers = eventDispatcher->registeredTimers(this);
1377             if (!timers.isEmpty()) {
1378                 // do not to release our timer ids back to the pool (since the timer ids are moving to a new thread).
1379                 eventDispatcher->unregisterTimers(this);
1380                 QMetaObject::invokeMethod(this, "_q_reregisterTimers", Qt::QueuedConnection,
1381                                           Q_ARG(void*, (new QList<QAbstractEventDispatcher::TimerInfo>(timers))));
1382             }
1383         }
1384         break;
1385     }
1386 
1387     default:
1388         if (e->type() >= QEvent::User) {
1389             customEvent(e);
1390             break;
1391         }
1392         return false;
1393     }
1394     return true;
1395 }
1396 
1397 /*!
1398     \fn void QObject::timerEvent(QTimerEvent *event)
1399 
1400     This event handler can be reimplemented in a subclass to receive
1401     timer events for the object.
1402 
1403     QTimer provides a higher-level interface to the timer
1404     functionality, and also more general information about timers. The
1405     timer event is passed in the \a event parameter.
1406 
1407     \sa startTimer(), killTimer(), event()
1408 */
1409 
1410 void QObject::timerEvent(QTimerEvent *)
1411 {
1412 }
1413 
1414 
1415 /*!
1416     This event handler can be reimplemented in a subclass to receive
1417     child events. The event is passed in the \a event parameter.
1418 
1419     QEvent::ChildAdded and QEvent::ChildRemoved events are sent to
1420     objects when children are added or removed. In both cases you can
1421     only rely on the child being a QObject, or if isWidgetType()
1422     returns \c true, a QWidget. (This is because, in the
1423     \l{QEvent::ChildAdded}{ChildAdded} case, the child is not yet
1424     fully constructed, and in the \l{QEvent::ChildRemoved}{ChildRemoved}
1425     case it might have been destructed already).
1426 
1427     QEvent::ChildPolished events are sent to widgets when children
1428     are polished, or when polished children are added. If you receive
1429     a child polished event, the child's construction is usually
1430     completed. However, this is not guaranteed, and multiple polish
1431     events may be delivered during the execution of a widget's
1432     constructor.
1433 
1434     For every child widget, you receive one
1435     \l{QEvent::ChildAdded}{ChildAdded} event, zero or more
1436     \l{QEvent::ChildPolished}{ChildPolished} events, and one
1437     \l{QEvent::ChildRemoved}{ChildRemoved} event.
1438 
1439     The \l{QEvent::ChildPolished}{ChildPolished} event is omitted if
1440     a child is removed immediately after it is added. If a child is
1441     polished several times during construction and destruction, you
1442     may receive several child polished events for the same child,
1443     each time with a different virtual table.
1444 
1445     \sa event()
1446 */
1447 
1448 void QObject::childEvent(QChildEvent * /* event */)
1449 {
1450 }
1451 
1452 
1453 /*!
1454     This event handler can be reimplemented in a subclass to receive
1455     custom events. Custom events are user-defined events with a type
1456     value at least as large as the QEvent::User item of the
1457     QEvent::Type enum, and is typically a QEvent subclass. The event
1458     is passed in the \a event parameter.
1459 
1460     \sa event(), QEvent
1461 */
1462 void QObject::customEvent(QEvent * /* event */)
1463 {
1464 }
1465 
1466 
1467 
1468 /*!
1469     Filters events if this object has been installed as an event
1470     filter for the \a watched object.
1471 
1472     In your reimplementation of this function, if you want to filter
1473     the \a event out, i.e. stop it being handled further, return
1474     true; otherwise return false.
1475 
1476     Example:
1477     \snippet code/src_corelib_kernel_qobject.cpp 6
1478 
1479     Notice in the example above that unhandled events are passed to
1480     the base class's eventFilter() function, since the base class
1481     might have reimplemented eventFilter() for its own internal
1482     purposes.
1483 
1484     Some events, such as \l QEvent::ShortcutOverride must be explicitly
1485     accepted (by calling \l {QEvent::}{accept()} on them) in order to prevent
1486     propagation.
1487 
1488     \warning If you delete the receiver object in this function, be
1489     sure to return true. Otherwise, Qt will forward the event to the
1490     deleted object and the program might crash.
1491 
1492     \sa installEventFilter()
1493 */
1494 
1495 bool QObject::eventFilter(QObject * /* watched */, QEvent * /* event */)
1496 {
1497     return false;
1498 }
1499 
1500 /*!
1501     \fn bool QObject::signalsBlocked() const
1502 
1503     Returns \c true if signals are blocked; otherwise returns \c false.
1504 
1505     Signals are not blocked by default.
1506 
1507     \sa blockSignals(), QSignalBlocker
1508 */
1509 
1510 /*!
1511     If \a block is true, signals emitted by this object are blocked
1512     (i.e., emitting a signal will not invoke anything connected to it).
1513     If \a block is false, no such blocking will occur.
1514 
1515     The return value is the previous value of signalsBlocked().
1516 
1517     Note that the destroyed() signal will be emitted even if the signals
1518     for this object have been blocked.
1519 
1520     Signals emitted while being blocked are not buffered.
1521 
1522     \sa signalsBlocked(), QSignalBlocker
1523 */
1524 
1525 bool QObject::blockSignals(bool block) noexcept
1526 {
1527     Q_D(QObject);
1528     bool previous = d->blockSig;
1529     d->blockSig = block;
1530     return previous;
1531 }
1532 
1533 /*!
1534     Returns the thread in which the object lives.
1535 
1536     \sa moveToThread()
1537 */
1538 QThread *QObject::thread() const
1539 {
1540     return d_func()->threadData.loadRelaxed()->thread.loadAcquire();
1541 }
1542 
1543 /*!
1544     Changes the thread affinity for this object and its children. The
1545     object cannot be moved if it has a parent. Event processing will
1546     continue in the \a targetThread.
1547 
1548     To move an object to the main thread, use QApplication::instance()
1549     to retrieve a pointer to the current application, and then use
1550     QApplication::thread() to retrieve the thread in which the
1551     application lives. For example:
1552 
1553     \snippet code/src_corelib_kernel_qobject.cpp 7
1554 
1555     If \a targetThread is \nullptr, all event processing for this object
1556     and its children stops, as they are no longer associated with any
1557     thread.
1558 
1559     Note that all active timers for the object will be reset. The
1560     timers are first stopped in the current thread and restarted (with
1561     the same interval) in the \a targetThread. As a result, constantly
1562     moving an object between threads can postpone timer events
1563     indefinitely.
1564 
1565     A QEvent::ThreadChange event is sent to this object just before
1566     the thread affinity is changed. You can handle this event to
1567     perform any special processing. Note that any new events that are
1568     posted to this object will be handled in the \a targetThread,
1569     provided it is not \nullptr: when it is \nullptr, no event processing
1570     for this object or its children can happen, as they are no longer
1571     associated with any thread.
1572 
1573     \warning This function is \e not thread-safe; the current thread
1574     must be same as the current thread affinity. In other words, this
1575     function can only "push" an object from the current thread to
1576     another thread, it cannot "pull" an object from any arbitrary
1577     thread to the current thread. There is one exception to this rule
1578     however: objects with no thread affinity can be "pulled" to the
1579     current thread.
1580 
1581     \sa thread()
1582  */
1583 void QObject::moveToThread(QThread *targetThread)
1584 {
1585     Q_D(QObject);
1586 
1587     if (d->threadData.loadRelaxed()->thread.loadAcquire() == targetThread) {
1588         // object is already in this thread
1589         return;
1590     }
1591 
1592     if (d->parent != nullptr) {
1593         qWarning("QObject::moveToThread: Cannot move objects with a parent");
1594         return;
1595     }
1596     if (d->isWidget) {
1597         qWarning("QObject::moveToThread: Widgets cannot be moved to a new thread");
1598         return;
1599     }
1600     if (!d->bindingStorage.isEmpty()) {
1601         qWarning("QObject::moveToThread: Can not move objects that contain bindings or are used in bindings to a new thread.");
1602         return;
1603     }
1604 
1605     QThreadData *currentData = QThreadData::current();
1606     QThreadData *targetData = targetThread ? QThreadData::get2(targetThread) : nullptr;
1607     QThreadData *thisThreadData = d->threadData.loadRelaxed();
1608     if (!thisThreadData->thread.loadAcquire() && currentData == targetData) {
1609         // one exception to the rule: we allow moving objects with no thread affinity to the current thread
1610         currentData = d->threadData;
1611     } else if (thisThreadData != currentData) {
1612         qWarning("QObject::moveToThread: Current thread (%p) is not the object's thread (%p).\n"
1613                  "Cannot move to target thread (%p)\n",
1614                  currentData->thread.loadRelaxed(), thisThreadData->thread.loadRelaxed(), targetData ? targetData->thread.loadRelaxed() : nullptr);
1615 
1616 #ifdef Q_OS_MAC
1617         qWarning("You might be loading two sets of Qt binaries into the same process. "
1618                  "Check that all plugins are compiled against the right Qt binaries. Export "
1619                  "DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.");
1620 #endif
1621 
1622         return;
1623     }
1624 
1625     // prepare to move
1626     d->moveToThread_helper();
1627 
1628     if (!targetData)
1629         targetData = new QThreadData(0);
1630 
1631     // make sure nobody adds/removes connections to this object while we're moving it
1632     QMutexLocker l(signalSlotLock(this));
1633 
1634     QOrderedMutexLocker locker(&currentData->postEventList.mutex,
1635                                &targetData->postEventList.mutex);
1636 
1637     // keep currentData alive (since we've got it locked)
1638     currentData->ref();
1639 
1640     // move the object
1641     d_func()->setThreadData_helper(currentData, targetData);
1642 
1643     locker.unlock();
1644 
1645     // now currentData can commit suicide if it wants to
1646     currentData->deref();
1647 }
1648 
1649 void QObjectPrivate::moveToThread_helper()
1650 {
1651     Q_Q(QObject);
1652     QEvent e(QEvent::ThreadChange);
1653     QCoreApplication::sendEvent(q, &e);
1654     for (int i = 0; i < children.size(); ++i) {
1655         QObject *child = children.at(i);
1656         child->d_func()->moveToThread_helper();
1657     }
1658 }
1659 
1660 void QObjectPrivate::setThreadData_helper(QThreadData *currentData, QThreadData *targetData)
1661 {
1662     Q_Q(QObject);
1663 
1664     // move posted events
1665     int eventsMoved = 0;
1666     for (int i = 0; i < currentData->postEventList.size(); ++i) {
1667         const QPostEvent &pe = currentData->postEventList.at(i);
1668         if (!pe.event)
1669             continue;
1670         if (pe.receiver == q) {
1671             // move this post event to the targetList
1672             targetData->postEventList.addEvent(pe);
1673             const_cast<QPostEvent &>(pe).event = nullptr;
1674             ++eventsMoved;
1675         }
1676     }
1677     if (eventsMoved > 0 && targetData->hasEventDispatcher()) {
1678         targetData->canWait = false;
1679         targetData->eventDispatcher.loadRelaxed()->wakeUp();
1680     }
1681 
1682     // the current emitting thread shouldn't restore currentSender after calling moveToThread()
1683     ConnectionData *cd = connections.loadRelaxed();
1684     if (cd) {
1685         if (cd->currentSender) {
1686             cd->currentSender->receiverDeleted();
1687             cd->currentSender = nullptr;
1688         }
1689 
1690         // adjust the receiverThreadId values in the Connections
1691         if (cd) {
1692             auto *c = cd->senders;
1693             while (c) {
1694                 QObject *r = c->receiver.loadRelaxed();
1695                 if (r) {
1696                     Q_ASSERT(r == q);
1697                     targetData->ref();
1698                     QThreadData *old = c->receiverThreadData.loadRelaxed();
1699                     if (old)
1700                         old->deref();
1701                     c->receiverThreadData.storeRelaxed(targetData);
1702                 }
1703                 c = c->next;
1704             }
1705         }
1706 
1707     }
1708 
1709     // set new thread data
1710     targetData->ref();
1711     threadData.loadRelaxed()->deref();
1712 
1713     // synchronizes with loadAcquire e.g. in QCoreApplication::postEvent
1714     threadData.storeRelease(targetData);
1715 
1716     for (int i = 0; i < children.size(); ++i) {
1717         QObject *child = children.at(i);
1718         child->d_func()->setThreadData_helper(currentData, targetData);
1719     }
1720 }
1721 
1722 void QObjectPrivate::_q_reregisterTimers(void *pointer)
1723 {
1724     Q_Q(QObject);
1725     QList<QAbstractEventDispatcher::TimerInfo> *timerList = reinterpret_cast<QList<QAbstractEventDispatcher::TimerInfo> *>(pointer);
1726     QAbstractEventDispatcher *eventDispatcher = threadData.loadRelaxed()->eventDispatcher.loadRelaxed();
1727     for (int i = 0; i < timerList->size(); ++i) {
1728         const QAbstractEventDispatcher::TimerInfo &ti = timerList->at(i);
1729         eventDispatcher->registerTimer(ti.timerId, ti.interval, ti.timerType, q);
1730     }
1731     delete timerList;
1732 }
1733 
1734 
1735 //
1736 // The timer flag hasTimer is set when startTimer is called.
1737 // It is not reset when killing the timer because more than
1738 // one timer might be active.
1739 //
1740 
1741 /*!
1742     Starts a timer and returns a timer identifier, or returns zero if
1743     it could not start a timer.
1744 
1745     A timer event will occur every \a interval milliseconds until
1746     killTimer() is called. If \a interval is 0, then the timer event
1747     occurs once every time there are no more window system events to
1748     process.
1749 
1750     The virtual timerEvent() function is called with the QTimerEvent
1751     event parameter class when a timer event occurs. Reimplement this
1752     function to get timer events.
1753 
1754     If multiple timers are running, the QTimerEvent::timerId() can be
1755     used to find out which timer was activated.
1756 
1757     Example:
1758 
1759     \snippet code/src_corelib_kernel_qobject.cpp 8
1760 
1761     Note that QTimer's accuracy depends on the underlying operating system and
1762     hardware. The \a timerType argument allows you to customize the accuracy of
1763     the timer. See Qt::TimerType for information on the different timer types.
1764     Most platforms support an accuracy of 20 milliseconds; some provide more.
1765     If Qt is unable to deliver the requested number of timer events, it will
1766     silently discard some.
1767 
1768     The QTimer class provides a high-level programming interface with
1769     single-shot timers and timer signals instead of events. There is
1770     also a QBasicTimer class that is more lightweight than QTimer and
1771     less clumsy than using timer IDs directly.
1772 
1773     \sa timerEvent(), killTimer(), QTimer::singleShot()
1774 */
1775 
1776 int QObject::startTimer(int interval, Qt::TimerType timerType)
1777 {
1778     Q_D(QObject);
1779 
1780     if (Q_UNLIKELY(interval < 0)) {
1781         qWarning("QObject::startTimer: Timers cannot have negative intervals");
1782         return 0;
1783     }
1784 
1785     auto thisThreadData = d->threadData.loadRelaxed();
1786     if (Q_UNLIKELY(!thisThreadData->hasEventDispatcher())) {
1787         qWarning("QObject::startTimer: Timers can only be used with threads started with QThread");
1788         return 0;
1789     }
1790     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1791         qWarning("QObject::startTimer: Timers cannot be started from another thread");
1792         return 0;
1793     }
1794     int timerId = thisThreadData->eventDispatcher.loadRelaxed()->registerTimer(interval, timerType, this);
1795     if (!d->extraData)
1796         d->extraData = new QObjectPrivate::ExtraData(d);
1797     d->extraData->runningTimers.append(timerId);
1798     return timerId;
1799 }
1800 
1801 /*!
1802     \since 5.9
1803     \overload
1804     \fn int QObject::startTimer(std::chrono::milliseconds time, Qt::TimerType timerType)
1805 
1806     Starts a timer and returns a timer identifier, or returns zero if
1807     it could not start a timer.
1808 
1809     A timer event will occur every \a time interval until killTimer()
1810     is called. If \a time is equal to \c{std::chrono::duration::zero()},
1811     then the timer event occurs once every time there are no more window
1812     system events to process.
1813 
1814     The virtual timerEvent() function is called with the QTimerEvent
1815     event parameter class when a timer event occurs. Reimplement this
1816     function to get timer events.
1817 
1818     If multiple timers are running, the QTimerEvent::timerId() can be
1819     used to find out which timer was activated.
1820 
1821     Example:
1822 
1823     \snippet code/src_corelib_kernel_qobject.cpp 8
1824 
1825     Note that QTimer's accuracy depends on the underlying operating system and
1826     hardware. The \a timerType argument allows you to customize the accuracy of
1827     the timer. See Qt::TimerType for information on the different timer types.
1828     Most platforms support an accuracy of 20 milliseconds; some provide more.
1829     If Qt is unable to deliver the requested number of timer events, it will
1830     silently discard some.
1831 
1832     The QTimer class provides a high-level programming interface with
1833     single-shot timers and timer signals instead of events. There is
1834     also a QBasicTimer class that is more lightweight than QTimer and
1835     less clumsy than using timer IDs directly.
1836 
1837     \sa timerEvent(), killTimer(), QTimer::singleShot()
1838 */
1839 
1840 /*!
1841     Kills the timer with timer identifier, \a id.
1842 
1843     The timer identifier is returned by startTimer() when a timer
1844     event is started.
1845 
1846     \sa timerEvent(), startTimer()
1847 */
1848 
1849 void QObject::killTimer(int id)
1850 {
1851     Q_D(QObject);
1852     if (Q_UNLIKELY(thread() != QThread::currentThread())) {
1853         qWarning("QObject::killTimer: Timers cannot be stopped from another thread");
1854         return;
1855     }
1856     if (id) {
1857         int at = d->extraData ? d->extraData->runningTimers.indexOf(id) : -1;
1858         if (at == -1) {
1859             // timer isn't owned by this object
1860             qWarning("QObject::killTimer(): Error: timer id %d is not valid for object %p (%s, %ls), timer has not been killed",
1861                      id,
1862                      this,
1863                      metaObject()->className(),
1864                      qUtf16Printable(objectName()));
1865             return;
1866         }
1867 
1868         auto thisThreadData = d->threadData.loadRelaxed();
1869         if (thisThreadData->hasEventDispatcher())
1870             thisThreadData->eventDispatcher.loadRelaxed()->unregisterTimer(id);
1871 
1872         d->extraData->runningTimers.remove(at);
1873         QAbstractEventDispatcherPrivate::releaseTimerId(id);
1874     }
1875 }
1876 
1877 
1878 /*!
1879     \fn QObject *QObject::parent() const
1880 
1881     Returns a pointer to the parent object.
1882 
1883     \sa children()
1884 */
1885 
1886 /*!
1887     \fn const QObjectList &QObject::children() const
1888 
1889     Returns a list of child objects.
1890     The QObjectList class is defined in the \c{<QObject>} header
1891     file as the following:
1892 
1893     \quotefromfile kernel/qobject.h
1894     \skipto /typedef .*QObjectList/
1895     \printuntil QObjectList
1896 
1897     The first child added is the \l{QList::first()}{first} object in
1898     the list and the last child added is the \l{QList::last()}{last}
1899     object in the list, i.e. new children are appended at the end.
1900 
1901     Note that the list order changes when QWidget children are
1902     \l{QWidget::raise()}{raised} or \l{QWidget::lower()}{lowered}. A
1903     widget that is raised becomes the last object in the list, and a
1904     widget that is lowered becomes the first object in the list.
1905 
1906     \sa findChild(), findChildren(), parent(), setParent()
1907 */
1908 
1909 
1910 /*!
1911     \fn template<typename T> T *QObject::findChild(const QString &name, Qt::FindChildOptions options) const
1912 
1913     Returns the child of this object that can be cast into type T and
1914     that is called \a name, or \nullptr if there is no such object.
1915     Omitting the \a name argument causes all object names to be matched.
1916     The search is performed recursively, unless \a options specifies the
1917     option FindDirectChildrenOnly.
1918 
1919     If there is more than one child matching the search, the most
1920     direct ancestor is returned. If there are several direct
1921     ancestors, it is undefined which one will be returned. In that
1922     case, findChildren() should be used.
1923 
1924     This example returns a child \c{QPushButton} of \c{parentWidget}
1925     named \c{"button1"}, even if the button isn't a direct child of
1926     the parent:
1927 
1928     \snippet code/src_corelib_kernel_qobject.cpp 10
1929 
1930     This example returns a \c{QListWidget} child of \c{parentWidget}:
1931 
1932     \snippet code/src_corelib_kernel_qobject.cpp 11
1933 
1934     This example returns a child \c{QPushButton} of \c{parentWidget}
1935     (its direct parent) named \c{"button1"}:
1936 
1937     \snippet code/src_corelib_kernel_qobject.cpp 41
1938 
1939     This example returns a \c{QListWidget} child of \c{parentWidget},
1940     its direct parent:
1941 
1942     \snippet code/src_corelib_kernel_qobject.cpp 42
1943 
1944     \sa findChildren()
1945 */
1946 
1947 /*!
1948     \fn template<typename T> QList<T> QObject::findChildren(const QString &name, Qt::FindChildOptions options) const
1949 
1950     Returns all children of this object with the given \a name that can be
1951     cast to type T, or an empty list if there are no such objects.
1952     A null \a name argument causes all objects to be matched, an empty one
1953     only those whose objectName is empty.
1954     The search is performed recursively, unless \a options specifies the
1955     option FindDirectChildrenOnly.
1956 
1957     The following example shows how to find a list of child \c{QWidget}s of
1958     the specified \c{parentWidget} named \c{widgetname}:
1959 
1960     \snippet code/src_corelib_kernel_qobject.cpp 12
1961 
1962     This example returns all \c{QPushButton}s that are children of \c{parentWidget}:
1963 
1964     \snippet code/src_corelib_kernel_qobject.cpp 13
1965 
1966     This example returns all \c{QPushButton}s that are immediate children of \c{parentWidget}:
1967 
1968     \snippet code/src_corelib_kernel_qobject.cpp 43
1969 
1970     \sa findChild()
1971 */
1972 
1973 /*!
1974     \fn template<typename T> QList<T> QObject::findChildren(Qt::FindChildOptions options) const
1975     \overload
1976     \since 6.3
1977 
1978     Returns all children of this object that can be cast to type T, or
1979     an empty list if there are no such objects.
1980     The search is performed recursively, unless \a options specifies the
1981     option FindDirectChildrenOnly.
1982 
1983     \sa findChild()
1984 */
1985 
1986 /*!
1987     \fn QList<T> QObject::findChildren(const QRegularExpression &re, Qt::FindChildOptions options) const
1988     \overload findChildren()
1989 
1990     \since 5.0
1991 
1992     Returns the children of this object that can be cast to type T
1993     and that have names matching the regular expression \a re,
1994     or an empty list if there are no such objects.
1995     The search is performed recursively, unless \a options specifies the
1996     option FindDirectChildrenOnly.
1997 */
1998 
1999 /*!
2000     \fn template<typename T> T qFindChild(const QObject *obj, const QString &name)
2001     \relates QObject
2002     \overload qFindChildren()
2003     \deprecated
2004 
2005     This function is equivalent to
2006     \a{obj}->\l{QObject::findChild()}{findChild}<T>(\a name).
2007 
2008     \note This function was provided as a workaround for MSVC 6
2009     which did not support member template functions. It is advised
2010     to use the other form in new code.
2011 
2012     \sa QObject::findChild()
2013 */
2014 
2015 /*!
2016     \fn template<typename T> QList<T> qFindChildren(const QObject *obj, const QString &name)
2017     \relates QObject
2018     \overload qFindChildren()
2019     \deprecated
2020 
2021     This function is equivalent to
2022     \a{obj}->\l{QObject::findChildren()}{findChildren}<T>(\a name).
2023 
2024     \note This function was provided as a workaround for MSVC 6
2025     which did not support member template functions. It is advised
2026     to use the other form in new code.
2027 
2028     \sa QObject::findChildren()
2029 */
2030 
2031 static void qt_qFindChildren_with_name(const QObject *parent, const QString &name,
2032                                        const QMetaObject &mo, QList<void *> *list,
2033                                        Qt::FindChildOptions options)
2034 {
2035     Q_ASSERT(parent);
2036     Q_ASSERT(list);
2037     Q_ASSERT(!name.isNull());
2038     for (QObject *obj : parent->children()) {
2039         if (mo.cast(obj) && obj->objectName() == name)
2040             list->append(obj);
2041         if (options & Qt::FindChildrenRecursively)
2042             qt_qFindChildren_with_name(obj, name, mo, list, options);
2043     }
2044 }
2045 
2046 /*!
2047     \internal
2048 */
2049 void qt_qFindChildren_helper(const QObject *parent, const QString &name,
2050                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
2051 {
2052     if (name.isNull())
2053         return qt_qFindChildren_helper(parent, mo, list, options);
2054     else
2055         return qt_qFindChildren_with_name(parent, name, mo, list, options);
2056 }
2057 
2058 /*!
2059     \internal
2060 */
2061 void qt_qFindChildren_helper(const QObject *parent, const QMetaObject &mo,
2062                              QList<void*> *list, Qt::FindChildOptions options)
2063 {
2064     Q_ASSERT(parent);
2065     Q_ASSERT(list);
2066     for (QObject *obj : parent->children()) {
2067         if (mo.cast(obj))
2068             list->append(obj);
2069         if (options & Qt::FindChildrenRecursively)
2070             qt_qFindChildren_helper(obj, mo, list, options);
2071     }
2072 }
2073 
2074 #if QT_CONFIG(regularexpression)
2075 /*!
2076     \internal
2077 */
2078 void qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &re,
2079                              const QMetaObject &mo, QList<void*> *list, Qt::FindChildOptions options)
2080 {
2081     Q_ASSERT(parent);
2082     Q_ASSERT(list);
2083     for (QObject *obj : parent->children()) {
2084         if (mo.cast(obj)) {
2085             QRegularExpressionMatch m = re.match(obj->objectName());
2086             if (m.hasMatch())
2087                 list->append(obj);
2088         }
2089         if (options & Qt::FindChildrenRecursively)
2090             qt_qFindChildren_helper(obj, re, mo, list, options);
2091     }
2092 }
2093 #endif // QT_CONFIG(regularexpression)
2094 
2095 /*!
2096     \internal
2097  */
2098 QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo, Qt::FindChildOptions options)
2099 {
2100     Q_ASSERT(parent);
2101     for (QObject *obj : parent->children()) {
2102         if (mo.cast(obj) && (name.isNull() || obj->objectName() == name))
2103             return obj;
2104     }
2105     if (options & Qt::FindChildrenRecursively) {
2106         for (QObject *child : parent->children()) {
2107             if (QObject *obj = qt_qFindChild_helper(child, name, mo, options))
2108                 return obj;
2109         }
2110     }
2111     return nullptr;
2112 }
2113 
2114 /*!
2115     Makes the object a child of \a parent.
2116 
2117     \sa parent(), children()
2118 */
2119 void QObject::setParent(QObject *parent)
2120 {
2121     Q_D(QObject);
2122     Q_ASSERT(!d->isWidget);
2123     d->setParent_helper(parent);
2124 }
2125 
2126 void QObjectPrivate::deleteChildren()
2127 {
2128     Q_ASSERT_X(!isDeletingChildren, "QObjectPrivate::deleteChildren()", "isDeletingChildren already set, did this function recurse?");
2129     isDeletingChildren = true;
2130     // delete children objects
2131     // don't use qDeleteAll as the destructor of the child might
2132     // delete siblings
2133     for (int i = 0; i < children.count(); ++i) {
2134         currentChildBeingDeleted = children.at(i);
2135         children[i] = nullptr;
2136         delete currentChildBeingDeleted;
2137     }
2138     children.clear();
2139     currentChildBeingDeleted = nullptr;
2140     isDeletingChildren = false;
2141 }
2142 
2143 void QObjectPrivate::setParent_helper(QObject *o)
2144 {
2145     Q_Q(QObject);
2146     Q_ASSERT_X(q != o, Q_FUNC_INFO, "Cannot parent a QObject to itself");
2147 #ifdef QT_DEBUG
2148     const auto checkForParentChildLoops = qScopeGuard([&](){
2149         int depth = 0;
2150         auto p = parent;
2151         while (p) {
2152             if (++depth == CheckForParentChildLoopsWarnDepth) {
2153                 qWarning("QObject %p (class: '%s', object name: '%s') may have a loop in its parent-child chain; "
2154                          "this is undefined behavior",
2155                          q, q->metaObject()->className(), qPrintable(q->objectName()));
2156             }
2157             p = p->parent();
2158         }
2159     });
2160 #endif
2161 
2162     if (o == parent)
2163         return;
2164 
2165     if (parent) {
2166         QObjectPrivate *parentD = parent->d_func();
2167         if (parentD->isDeletingChildren && wasDeleted
2168             && parentD->currentChildBeingDeleted == q) {
2169             // don't do anything since QObjectPrivate::deleteChildren() already
2170             // cleared our entry in parentD->children.
2171         } else {
2172             const int index = parentD->children.indexOf(q);
2173             if (index < 0) {
2174                 // we're probably recursing into setParent() from a ChildRemoved event, don't do anything
2175             } else if (parentD->isDeletingChildren) {
2176                 parentD->children[index] = nullptr;
2177             } else {
2178                 parentD->children.removeAt(index);
2179                 if (sendChildEvents && parentD->receiveChildEvents) {
2180                     QChildEvent e(QEvent::ChildRemoved, q);
2181                     QCoreApplication::sendEvent(parent, &e);
2182                 }
2183             }
2184         }
2185     }
2186     parent = o;
2187     if (parent) {
2188         // object hierarchies are constrained to a single thread
2189         if (threadData != parent->d_func()->threadData) {
2190             qWarning("QObject::setParent: Cannot set parent, new parent is in a different thread");
2191             parent = nullptr;
2192             return;
2193         }
2194         parent->d_func()->children.append(q);
2195         if (sendChildEvents && parent->d_func()->receiveChildEvents) {
2196             if (!isWidget) {
2197                 QChildEvent e(QEvent::ChildAdded, q);
2198                 QCoreApplication::sendEvent(parent, &e);
2199             }
2200         }
2201     }
2202 }
2203 
2204 /*!
2205     \fn void QObject::installEventFilter(QObject *filterObj)
2206 
2207     Installs an event filter \a filterObj on this object. For example:
2208     \snippet code/src_corelib_kernel_qobject.cpp 14
2209 
2210     An event filter is an object that receives all events that are
2211     sent to this object. The filter can either stop the event or
2212     forward it to this object. The event filter \a filterObj receives
2213     events via its eventFilter() function. The eventFilter() function
2214     must return true if the event should be filtered, (i.e. stopped);
2215     otherwise it must return false.
2216 
2217     If multiple event filters are installed on a single object, the
2218     filter that was installed last is activated first.
2219 
2220     Here's a \c KeyPressEater class that eats the key presses of its
2221     monitored objects:
2222 
2223     \snippet code/src_corelib_kernel_qobject.cpp 15
2224 
2225     And here's how to install it on two widgets:
2226 
2227     \snippet code/src_corelib_kernel_qobject.cpp 16
2228 
2229     The QShortcut class, for example, uses this technique to intercept
2230     shortcut key presses.
2231 
2232     \warning If you delete the receiver object in your eventFilter()
2233     function, be sure to return true. If you return false, Qt sends
2234     the event to the deleted object and the program will crash.
2235 
2236     Note that the filtering object must be in the same thread as this
2237     object. If \a filterObj is in a different thread, this function does
2238     nothing. If either \a filterObj or this object are moved to a different
2239     thread after calling this function, the event filter will not be
2240     called until both objects have the same thread affinity again (it
2241     is \e not removed).
2242 
2243     \sa removeEventFilter(), eventFilter(), event()
2244 */
2245 
2246 void QObject::installEventFilter(QObject *obj)
2247 {
2248     Q_D(QObject);
2249     if (!obj)
2250         return;
2251     if (d->threadData != obj->d_func()->threadData) {
2252         qWarning("QObject::installEventFilter(): Cannot filter events for objects in a different thread.");
2253         return;
2254     }
2255 
2256     if (!d->extraData)
2257         d->extraData = new QObjectPrivate::ExtraData(d);
2258 
2259     // clean up unused items in the list
2260     d->extraData->eventFilters.removeAll((QObject *)nullptr);
2261     d->extraData->eventFilters.removeAll(obj);
2262     d->extraData->eventFilters.prepend(obj);
2263 }
2264 
2265 /*!
2266     Removes an event filter object \a obj from this object. The
2267     request is ignored if such an event filter has not been installed.
2268 
2269     All event filters for this object are automatically removed when
2270     this object is destroyed.
2271 
2272     It is always safe to remove an event filter, even during event
2273     filter activation (i.e. from the eventFilter() function).
2274 
2275     \sa installEventFilter(), eventFilter(), event()
2276 */
2277 
2278 void QObject::removeEventFilter(QObject *obj)
2279 {
2280     Q_D(QObject);
2281     if (d->extraData) {
2282         for (int i = 0; i < d->extraData->eventFilters.count(); ++i) {
2283             if (d->extraData->eventFilters.at(i) == obj)
2284                 d->extraData->eventFilters[i] = nullptr;
2285         }
2286     }
2287 }
2288 
2289 /*!
2290     \fn void QObject::destroyed(QObject *obj)
2291 
2292     This signal is emitted immediately before the object \a obj is
2293     destroyed, after any instances of QPointer have been notified,
2294     and cannot be blocked.
2295 
2296     All the objects's children are destroyed immediately after this
2297     signal is emitted.
2298 
2299     \sa deleteLater(), QPointer
2300 */
2301 
2302 /*!
2303     \threadsafe
2304 
2305     Schedules this object for deletion.
2306 
2307     The object will be deleted when control returns to the event
2308     loop. If the event loop is not running when this function is
2309     called (e.g. deleteLater() is called on an object before
2310     QCoreApplication::exec()), the object will be deleted once the
2311     event loop is started. If deleteLater() is called after the main event loop
2312     has stopped, the object will not be deleted.
2313     Since Qt 4.8, if deleteLater() is called on an object that lives in a
2314     thread with no running event loop, the object will be destroyed when the
2315     thread finishes.
2316 
2317     Note that entering and leaving a new event loop (e.g., by opening a modal
2318     dialog) will \e not perform the deferred deletion; for the object to be
2319     deleted, the control must return to the event loop from which deleteLater()
2320     was called. This does not apply to objects deleted while a previous, nested
2321     event loop was still running: the Qt event loop will delete those objects
2322     as soon as the new nested event loop starts.
2323 
2324     \note It is safe to call this function more than once; when the
2325     first deferred deletion event is delivered, any pending events for the
2326     object are removed from the event queue.
2327 
2328     \sa destroyed(), QPointer
2329 */
2330 void QObject::deleteLater()
2331 {
2332 #ifdef QT_DEBUG
2333     if (qApp == this)
2334         qWarning("You are deferring the delete of QCoreApplication, this may not work as expected.");
2335 #endif
2336     QCoreApplication::postEvent(this, new QDeferredDeleteEvent());
2337 }
2338 
2339 /*!
2340     \fn QString QObject::tr(const char *sourceText, const char *disambiguation, int n)
2341     \reentrant
2342 
2343     Returns a translated version of \a sourceText, optionally based on a
2344     \a disambiguation string and value of \a n for strings containing plurals;
2345     otherwise returns QString::fromUtf8(\a sourceText) if no appropriate
2346     translated string is available.
2347 
2348     Example:
2349     \snippet ../widgets/mainwindows/sdi/mainwindow.cpp implicit tr context
2350     \dots
2351 
2352     If the same \a sourceText is used in different roles within the
2353     same context, an additional identifying string may be passed in
2354     \a disambiguation (\nullptr by default). In Qt 4.4 and earlier, this was
2355     the preferred way to pass comments to translators.
2356 
2357     Example:
2358 
2359     \snippet code/src_corelib_kernel_qobject.cpp 17
2360     \dots
2361 
2362     See \l{Writing Source Code for Translation} for a detailed description of
2363     Qt's translation mechanisms in general, and the
2364     \l{Writing Source Code for Translation#Disambiguation}{Disambiguation}
2365     section for information on disambiguation.
2366 
2367     \warning This method is reentrant only if all translators are
2368     installed \e before calling this method. Installing or removing
2369     translators while performing translations is not supported. Doing
2370     so will probably result in crashes or other undesirable behavior.
2371 
2372     \sa QCoreApplication::translate(), {Internationalization with Qt}
2373 */
2374 
2375 /*****************************************************************************
2376   Signals and slots
2377  *****************************************************************************/
2378 
2379 const char *qFlagLocation(const char *method)
2380 {
2381     QThreadData *currentThreadData = QThreadData::current(false);
2382     if (currentThreadData != nullptr)
2383         currentThreadData->flaggedSignatures.store(method);
2384     return method;
2385 }
2386 
2387 static int extract_code(const char *member)
2388 {
2389     // extract code, ensure QMETHOD_CODE <= code <= QSIGNAL_CODE
2390     return (((int)(*member) - '0') & 0x3);
2391 }
2392 
2393 static const char *extract_location(const char *member)
2394 {
2395     if (QThreadData::current()->flaggedSignatures.contains(member)) {
2396         // signature includes location information after the first null-terminator
2397         const char *location = member + qstrlen(member) + 1;
2398         if (*location != '\0')
2399             return location;
2400     }
2401     return nullptr;
2402 }
2403 
2404 static bool check_signal_macro(const QObject *sender, const char *signal,
2405                                 const char *func, const char *op)
2406 {
2407     int sigcode = extract_code(signal);
2408     if (sigcode != QSIGNAL_CODE) {
2409         if (sigcode == QSLOT_CODE)
2410             qCWarning(lcConnect, "QObject::%s: Attempt to %s non-signal %s::%s", func, op,
2411                       sender->metaObject()->className(), signal + 1);
2412         else
2413             qCWarning(lcConnect, "QObject::%s: Use the SIGNAL macro to %s %s::%s", func, op,
2414                       sender->metaObject()->className(), signal);
2415         return false;
2416     }
2417     return true;
2418 }
2419 
2420 static bool check_method_code(int code, const QObject *object, const char *method, const char *func)
2421 {
2422     if (code != QSLOT_CODE && code != QSIGNAL_CODE) {
2423         qCWarning(lcConnect,
2424                   "QObject::%s: Use the SLOT or SIGNAL macro to "
2425                   "%s %s::%s",
2426                   func, func, object->metaObject()->className(), method);
2427         return false;
2428     }
2429     return true;
2430 }
2431 
2432 static void err_method_notfound(const QObject *object,
2433                                 const char *method, const char *func)
2434 {
2435     const char *type = "method";
2436     switch (extract_code(method)) {
2437         case QSLOT_CODE:   type = "slot";   break;
2438         case QSIGNAL_CODE: type = "signal"; break;
2439     }
2440     const char *loc = extract_location(method);
2441     if (strchr(method, ')') == nullptr) // common typing mistake
2442         qCWarning(lcConnect, "QObject::%s: Parentheses expected, %s %s::%s%s%s", func, type,
2443                   object->metaObject()->className(), method + 1, loc ? " in " : "", loc ? loc : "");
2444     else
2445         qCWarning(lcConnect, "QObject::%s: No such %s %s::%s%s%s", func, type,
2446                   object->metaObject()->className(), method + 1, loc ? " in " : "", loc ? loc : "");
2447 }
2448 
2449 static void err_info_about_objects(const char *func, const QObject *sender, const QObject *receiver)
2450 {
2451     QString a = sender ? sender->objectName() : QString();
2452     QString b = receiver ? receiver->objectName() : QString();
2453     if (!a.isEmpty())
2454         qCWarning(lcConnect, "QObject::%s:  (sender name:   '%s')", func, a.toLocal8Bit().data());
2455     if (!b.isEmpty())
2456         qCWarning(lcConnect, "QObject::%s:  (receiver name: '%s')", func, b.toLocal8Bit().data());
2457 }
2458 
2459 /*!
2460     Returns a pointer to the object that sent the signal, if called in
2461     a slot activated by a signal; otherwise it returns \nullptr. The pointer
2462     is valid only during the execution of the slot that calls this
2463     function from this object's thread context.
2464 
2465     The pointer returned by this function becomes invalid if the
2466     sender is destroyed, or if the slot is disconnected from the
2467     sender's signal.
2468 
2469     \warning This function violates the object-oriented principle of
2470     modularity. However, getting access to the sender might be useful
2471     when many signals are connected to a single slot.
2472 
2473     \warning As mentioned above, the return value of this function is
2474     not valid when the slot is called via a Qt::DirectConnection from
2475     a thread different from this object's thread. Do not use this
2476     function in this type of scenario.
2477 
2478     \sa senderSignalIndex()
2479 */
2480 
2481 QObject *QObject::sender() const
2482 {
2483     Q_D(const QObject);
2484 
2485     QBasicMutexLocker locker(signalSlotLock(this));
2486     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2487     if (!cd || !cd->currentSender)
2488         return nullptr;
2489 
2490     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2491         if (c->sender == cd->currentSender->sender)
2492             return cd->currentSender->sender;
2493     }
2494 
2495     return nullptr;
2496 }
2497 
2498 /*!
2499     \since 4.8
2500 
2501     Returns the meta-method index of the signal that called the currently
2502     executing slot, which is a member of the class returned by sender().
2503     If called outside of a slot activated by a signal, -1 is returned.
2504 
2505     For signals with default parameters, this function will always return
2506     the index with all parameters, regardless of which was used with
2507     connect(). For example, the signal \c {destroyed(QObject *obj = \nullptr)}
2508     will have two different indexes (with and without the parameter), but
2509     this function will always return the index with a parameter. This does
2510     not apply when overloading signals with different parameters.
2511 
2512     \warning This function violates the object-oriented principle of
2513     modularity. However, getting access to the signal index might be useful
2514     when many signals are connected to a single slot.
2515 
2516     \warning The return value of this function is not valid when the slot
2517     is called via a Qt::DirectConnection from a thread different from this
2518     object's thread. Do not use this function in this type of scenario.
2519 
2520     \sa sender(), QMetaObject::indexOfSignal(), QMetaObject::method()
2521 */
2522 
2523 int QObject::senderSignalIndex() const
2524 {
2525     Q_D(const QObject);
2526 
2527     QBasicMutexLocker locker(signalSlotLock(this));
2528     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2529     if (!cd || !cd->currentSender)
2530         return -1;
2531 
2532     for (QObjectPrivate::Connection *c = cd->senders; c; c = c->next) {
2533         if (c->sender == cd->currentSender->sender) {
2534             // Convert from signal range to method range
2535             return QMetaObjectPrivate::signal(c->sender->metaObject(), cd->currentSender->signal).methodIndex();
2536         }
2537     }
2538 
2539     return -1;
2540 }
2541 
2542 /*!
2543     Returns the number of receivers connected to the \a signal.
2544 
2545     Since both slots and signals can be used as receivers for signals,
2546     and the same connections can be made many times, the number of
2547     receivers is the same as the number of connections made from this
2548     signal.
2549 
2550     When calling this function, you can use the \c SIGNAL() macro to
2551     pass a specific signal:
2552 
2553     \snippet code/src_corelib_kernel_qobject.cpp 21
2554 
2555     \warning This function violates the object-oriented principle of
2556     modularity. However, it might be useful when you need to perform
2557     expensive initialization only if something is connected to a
2558     signal.
2559 
2560     \sa isSignalConnected()
2561 */
2562 
2563 int QObject::receivers(const char *signal) const
2564 {
2565     Q_D(const QObject);
2566     int receivers = 0;
2567     if (signal) {
2568         QByteArray signal_name = QMetaObject::normalizedSignature(signal);
2569         signal = signal_name;
2570 #ifndef QT_NO_DEBUG
2571         if (!check_signal_macro(this, signal, "receivers", "bind"))
2572             return 0;
2573 #endif
2574         signal++; // skip code
2575         int signal_index = d->signalIndex(signal);
2576         if (signal_index < 0) {
2577 #ifndef QT_NO_DEBUG
2578             err_method_notfound(this, signal - 1, "receivers");
2579 #endif
2580             return 0;
2581         }
2582 
2583         if (!d->isSignalConnected(signal_index))
2584             return receivers;
2585 
2586         if (d->declarativeData && QAbstractDeclarativeData::receivers) {
2587             receivers += QAbstractDeclarativeData::receivers(d->declarativeData, this,
2588                                                              signal_index);
2589         }
2590 
2591         QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
2592         QBasicMutexLocker locker(signalSlotLock(this));
2593         if (cd && signal_index < cd->signalVectorCount()) {
2594             const QObjectPrivate::Connection *c = cd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
2595             while (c) {
2596                 receivers += c->receiver.loadRelaxed() ? 1 : 0;
2597                 c = c->nextConnectionList.loadRelaxed();
2598             }
2599         }
2600     }
2601     return receivers;
2602 }
2603 
2604 /*!
2605     \since 5.0
2606     Returns \c true if the \a signal is connected to at least one receiver,
2607     otherwise returns \c false.
2608 
2609     \a signal must be a signal member of this object, otherwise the behaviour
2610     is undefined.
2611 
2612     \snippet code/src_corelib_kernel_qobject.cpp 49
2613 
2614     As the code snippet above illustrates, you can use this function
2615     to avoid emitting a signal that nobody listens to.
2616 
2617     \warning This function violates the object-oriented principle of
2618     modularity. However, it might be useful when you need to perform
2619     expensive initialization only if something is connected to a
2620     signal.
2621 */
2622 bool QObject::isSignalConnected(const QMetaMethod &signal) const
2623 {
2624     Q_D(const QObject);
2625     if (!signal.mobj)
2626         return false;
2627 
2628     Q_ASSERT_X(signal.mobj->cast(this) && signal.methodType() == QMetaMethod::Signal,
2629                "QObject::isSignalConnected" , "the parameter must be a signal member of the object");
2630     uint signalIndex = signal.relativeMethodIndex();
2631 
2632     if (signal.data.flags() & MethodCloned)
2633         signalIndex = QMetaObjectPrivate::originalClone(signal.mobj, signalIndex);
2634 
2635     signalIndex += QMetaObjectPrivate::signalOffset(signal.mobj);
2636 
2637     QBasicMutexLocker locker(signalSlotLock(this));
2638     return d->isSignalConnected(signalIndex, true);
2639 }
2640 
2641 /*!
2642     \internal
2643 
2644     This helper function calculates signal and method index for the given
2645     member in the specified class.
2646 
2647     \list
2648     \li If member.mobj is \nullptr then both signalIndex and methodIndex are set to -1.
2649 
2650     \li If specified member is not a member of obj instance class (or one of
2651     its parent classes) then both signalIndex and methodIndex are set to -1.
2652     \endlist
2653 
2654     This function is used by QObject::connect and QObject::disconnect which
2655     are working with QMetaMethod.
2656 
2657     \a signalIndex is set to the signal index of member. If the member
2658     specified is not signal this variable is set to -1.
2659 
2660     \a methodIndex is set to the method index of the member. If the
2661     member is not a method of the object specified by the \a obj argument this
2662     variable is set to -1.
2663 */
2664 void QMetaObjectPrivate::memberIndexes(const QObject *obj,
2665                                        const QMetaMethod &member,
2666                                        int *signalIndex, int *methodIndex)
2667 {
2668     *signalIndex = -1;
2669     *methodIndex = -1;
2670     if (!obj || !member.mobj)
2671         return;
2672     const QMetaObject *m = obj->metaObject();
2673     // Check that member is member of obj class
2674     while (m != nullptr && m != member.mobj)
2675         m = m->d.superdata;
2676     if (!m)
2677         return;
2678     *signalIndex = *methodIndex = member.relativeMethodIndex();
2679 
2680     int signalOffset;
2681     int methodOffset;
2682     computeOffsets(m, &signalOffset, &methodOffset);
2683 
2684     *methodIndex += methodOffset;
2685     if (member.methodType() == QMetaMethod::Signal) {
2686         *signalIndex = originalClone(m, *signalIndex);
2687         *signalIndex += signalOffset;
2688     } else {
2689         *signalIndex = -1;
2690     }
2691 }
2692 
2693 #ifndef QT_NO_DEBUG
2694 static inline void check_and_warn_compat(const QMetaObject *sender, const QMetaMethod &signal,
2695                                          const QMetaObject *receiver, const QMetaMethod &method)
2696 {
2697     if (signal.attributes() & QMetaMethod::Compatibility) {
2698         if (!(method.attributes() & QMetaMethod::Compatibility))
2699             qCWarning(lcConnect, "QObject::connect: Connecting from COMPAT signal (%s::%s)",
2700                       sender->className(), signal.methodSignature().constData());
2701     } else if ((method.attributes() & QMetaMethod::Compatibility)
2702                && method.methodType() == QMetaMethod::Signal) {
2703         qCWarning(lcConnect, "QObject::connect: Connecting from %s::%s to COMPAT slot (%s::%s)",
2704                   sender->className(), signal.methodSignature().constData(), receiver->className(),
2705                   method.methodSignature().constData());
2706     }
2707 }
2708 #endif
2709 
2710 /*!
2711     \threadsafe
2712 
2713     Creates a connection of the given \a type from the \a signal in
2714     the \a sender object to the \a method in the \a receiver object.
2715     Returns a handle to the connection that can be used to disconnect
2716     it later.
2717 
2718     You must use the \c SIGNAL() and \c SLOT() macros when specifying
2719     the \a signal and the \a method, for example:
2720 
2721     \snippet code/src_corelib_kernel_qobject.cpp 22
2722 
2723     This example ensures that the label always displays the current
2724     scroll bar value. Note that the signal and slots parameters must not
2725     contain any variable names, only the type. E.g. the following would
2726     not work and return false:
2727 
2728     \snippet code/src_corelib_kernel_qobject.cpp 23
2729 
2730     A signal can also be connected to another signal:
2731 
2732     \snippet code/src_corelib_kernel_qobject.cpp 24
2733 
2734     In this example, the \c MyWidget constructor relays a signal from
2735     a private member variable, and makes it available under a name
2736     that relates to \c MyWidget.
2737 
2738     A signal can be connected to many slots and signals. Many signals
2739     can be connected to one slot.
2740 
2741     If a signal is connected to several slots, the slots are activated
2742     in the same order in which the connections were made, when the
2743     signal is emitted.
2744 
2745     The function returns a QMetaObject::Connection that represents
2746     a handle to a connection if it successfully
2747     connects the signal to the slot. The connection handle will be invalid
2748     if it cannot create the connection, for example, if QObject is unable
2749     to verify the existence of either \a signal or \a method, or if their
2750     signatures aren't compatible.
2751     You can check if the handle is valid by casting it to a bool.
2752 
2753     By default, a signal is emitted for every connection you make;
2754     two signals are emitted for duplicate connections. You can break
2755     all of these connections with a single disconnect() call.
2756     If you pass the Qt::UniqueConnection \a type, the connection will only
2757     be made if it is not a duplicate. If there is already a duplicate
2758     (exact same signal to the exact same slot on the same objects),
2759     the connection will fail and connect will return an invalid QMetaObject::Connection.
2760 
2761     \note Qt::UniqueConnections do not work for lambdas, non-member functions
2762     and functors; they only apply to connecting to member functions.
2763 
2764     The optional \a type parameter describes the type of connection
2765     to establish. In particular, it determines whether a particular
2766     signal is delivered to a slot immediately or queued for delivery
2767     at a later time. If the signal is queued, the parameters must be
2768     of types that are known to Qt's meta-object system, because Qt
2769     needs to copy the arguments to store them in an event behind the
2770     scenes. If you try to use a queued connection and get the error
2771     message
2772 
2773     \snippet code/src_corelib_kernel_qobject.cpp 25
2774 
2775     call qRegisterMetaType() to register the data type before you
2776     establish the connection.
2777 
2778     \sa disconnect(), sender(), qRegisterMetaType(), Q_DECLARE_METATYPE(),
2779     {Differences between String-Based and Functor-Based Connections}
2780 */
2781 QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal,
2782                                          const QObject *receiver, const char *method,
2783                                          Qt::ConnectionType type)
2784 {
2785     if (sender == nullptr || receiver == nullptr || signal == nullptr || method == nullptr) {
2786         qCWarning(lcConnect, "QObject::connect: Cannot connect %s::%s to %s::%s",
2787                   sender ? sender->metaObject()->className() : "(nullptr)",
2788                   (signal && *signal) ? signal + 1 : "(nullptr)",
2789                   receiver ? receiver->metaObject()->className() : "(nullptr)",
2790                   (method && *method) ? method + 1 : "(nullptr)");
2791         return QMetaObject::Connection(nullptr);
2792     }
2793     QByteArray tmp_signal_name;
2794 
2795     if (!check_signal_macro(sender, signal, "connect", "bind"))
2796         return QMetaObject::Connection(nullptr);
2797     const QMetaObject *smeta = sender->metaObject();
2798     const char *signal_arg = signal;
2799     ++signal; // skip code
2800     QArgumentTypeArray signalTypes;
2801     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
2802     QByteArray signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2803     int signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2804             &smeta, signalName, signalTypes.size(), signalTypes.constData());
2805     if (signal_index < 0) {
2806         // check for normalized signatures
2807         tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
2808         signal = tmp_signal_name.constData() + 1;
2809 
2810         signalTypes.clear();
2811         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
2812         smeta = sender->metaObject();
2813         signal_index = QMetaObjectPrivate::indexOfSignalRelative(
2814                 &smeta, signalName, signalTypes.size(), signalTypes.constData());
2815     }
2816     if (signal_index < 0) {
2817         err_method_notfound(sender, signal_arg, "connect");
2818         err_info_about_objects("connect", sender, receiver);
2819         return QMetaObject::Connection(nullptr);
2820     }
2821     signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
2822     signal_index += QMetaObjectPrivate::signalOffset(smeta);
2823 
2824     QByteArray tmp_method_name;
2825     int membcode = extract_code(method);
2826 
2827     if (!check_method_code(membcode, receiver, method, "connect"))
2828         return QMetaObject::Connection(nullptr);
2829     const char *method_arg = method;
2830     ++method; // skip code
2831 
2832     QArgumentTypeArray methodTypes;
2833     QByteArray methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2834     const QMetaObject *rmeta = receiver->metaObject();
2835     int method_index_relative = -1;
2836     Q_ASSERT(QMetaObjectPrivate::get(rmeta)->revision >= 7);
2837     switch (membcode) {
2838     case QSLOT_CODE:
2839         method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2840                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2841         break;
2842     case QSIGNAL_CODE:
2843         method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2844                 &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2845         break;
2846     }
2847     if (method_index_relative < 0) {
2848         // check for normalized methods
2849         tmp_method_name = QMetaObject::normalizedSignature(method);
2850         method = tmp_method_name.constData();
2851 
2852         methodTypes.clear();
2853         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
2854         // rmeta may have been modified above
2855         rmeta = receiver->metaObject();
2856         switch (membcode) {
2857         case QSLOT_CODE:
2858             method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
2859                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2860             break;
2861         case QSIGNAL_CODE:
2862             method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
2863                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
2864             break;
2865         }
2866     }
2867 
2868     if (method_index_relative < 0) {
2869         err_method_notfound(receiver, method_arg, "connect");
2870         err_info_about_objects("connect", sender, receiver);
2871         return QMetaObject::Connection(nullptr);
2872     }
2873 
2874     if (!QMetaObjectPrivate::checkConnectArgs(signalTypes.size(), signalTypes.constData(),
2875                                               methodTypes.size(), methodTypes.constData())) {
2876         qCWarning(lcConnect,
2877                   "QObject::connect: Incompatible sender/receiver arguments"
2878                   "\n        %s::%s --> %s::%s",
2879                   sender->metaObject()->className(), signal, receiver->metaObject()->className(),
2880                   method);
2881         return QMetaObject::Connection(nullptr);
2882     }
2883 
2884     int *types = nullptr;
2885     if ((type == Qt::QueuedConnection)
2886             && !(types = queuedConnectionTypes(signalTypes.constData(), signalTypes.size()))) {
2887         return QMetaObject::Connection(nullptr);
2888     }
2889 
2890 #ifndef QT_NO_DEBUG
2891     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
2892     QMetaMethod rmethod = rmeta->method(method_index_relative + rmeta->methodOffset());
2893     check_and_warn_compat(smeta, smethod, rmeta, rmethod);
2894 #endif
2895     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2896         sender, signal_index, smeta, receiver, method_index_relative, rmeta ,type, types));
2897     return handle;
2898 }
2899 
2900 /*!
2901     \since 4.8
2902 
2903     Creates a connection of the given \a type from the \a signal in
2904     the \a sender object to the \a method in the \a receiver object.
2905     Returns a handle to the connection that can be used to disconnect
2906     it later.
2907 
2908     The Connection handle will be invalid  if it cannot create the
2909     connection, for example, the parameters were invalid.
2910     You can check if the QMetaObject::Connection is valid by casting it to a bool.
2911 
2912     This function works in the same way as
2913     \c {connect(const QObject *sender, const char *signal,
2914             const QObject *receiver, const char *method,
2915             Qt::ConnectionType type)}
2916     but it uses QMetaMethod to specify signal and method.
2917 
2918     \sa connect(const QObject *sender, const char *signal, const QObject *receiver, const char *method, Qt::ConnectionType type)
2919  */
2920 QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &signal,
2921                                      const QObject *receiver, const QMetaMethod &method,
2922                                      Qt::ConnectionType type)
2923 {
2924     if (sender == nullptr
2925             || receiver == nullptr
2926             || signal.methodType() != QMetaMethod::Signal
2927             || method.methodType() == QMetaMethod::Constructor) {
2928         qCWarning(lcConnect, "QObject::connect: Cannot connect %s::%s to %s::%s",
2929                   sender ? sender->metaObject()->className() : "(nullptr)",
2930                   signal.methodSignature().constData(),
2931                   receiver ? receiver->metaObject()->className() : "(nullptr)",
2932                   method.methodSignature().constData());
2933         return QMetaObject::Connection(nullptr);
2934     }
2935 
2936     int signal_index;
2937     int method_index;
2938     {
2939         int dummy;
2940         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
2941         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
2942     }
2943 
2944     const QMetaObject *smeta = sender->metaObject();
2945     const QMetaObject *rmeta = receiver->metaObject();
2946     if (signal_index == -1) {
2947         qCWarning(lcConnect, "QObject::connect: Can't find signal %s on instance of class %s",
2948                   signal.methodSignature().constData(), smeta->className());
2949         return QMetaObject::Connection(nullptr);
2950     }
2951     if (method_index == -1) {
2952         qCWarning(lcConnect, "QObject::connect: Can't find method %s on instance of class %s",
2953                   method.methodSignature().constData(), rmeta->className());
2954         return QMetaObject::Connection(nullptr);
2955     }
2956 
2957     if (!QMetaObject::checkConnectArgs(signal.methodSignature().constData(),
2958                                        method.methodSignature().constData())) {
2959         qCWarning(lcConnect,
2960                   "QObject::connect: Incompatible sender/receiver arguments"
2961                   "\n        %s::%s --> %s::%s",
2962                   smeta->className(), signal.methodSignature().constData(), rmeta->className(),
2963                   method.methodSignature().constData());
2964         return QMetaObject::Connection(nullptr);
2965     }
2966 
2967     int *types = nullptr;
2968     if ((type == Qt::QueuedConnection) && !(types = queuedConnectionTypes(signal)))
2969         return QMetaObject::Connection(nullptr);
2970 
2971 #ifndef QT_NO_DEBUG
2972     check_and_warn_compat(smeta, signal, rmeta, method);
2973 #endif
2974     QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
2975         sender, signal_index, signal.enclosingMetaObject(), receiver, method_index, nullptr, type, types));
2976     return handle;
2977 }
2978 
2979 /*!
2980     \fn bool QObject::connect(const QObject *sender, const char *signal, const char *method, Qt::ConnectionType type) const
2981     \overload connect()
2982     \threadsafe
2983 
2984     Connects \a signal from the \a sender object to this object's \a
2985     method.
2986 
2987     Equivalent to connect(\a sender, \a signal, \c this, \a method, \a type).
2988 
2989     Every connection you make emits a signal, so duplicate connections emit
2990     two signals. You can break a connection using disconnect().
2991 
2992     \sa disconnect()
2993 */
2994 
2995 /*!
2996     \threadsafe
2997 
2998     Disconnects \a signal in object \a sender from \a method in object
2999     \a receiver. Returns \c true if the connection is successfully broken;
3000     otherwise returns \c false.
3001 
3002     A signal-slot connection is removed when either of the objects
3003     involved are destroyed.
3004 
3005     disconnect() is typically used in three ways, as the following
3006     examples demonstrate.
3007     \list 1
3008     \li Disconnect everything connected to an object's signals:
3009 
3010        \snippet code/src_corelib_kernel_qobject.cpp 26
3011 
3012        equivalent to the non-static overloaded function
3013 
3014        \snippet code/src_corelib_kernel_qobject.cpp 27
3015 
3016     \li Disconnect everything connected to a specific signal:
3017 
3018        \snippet code/src_corelib_kernel_qobject.cpp 28
3019 
3020        equivalent to the non-static overloaded function
3021 
3022        \snippet code/src_corelib_kernel_qobject.cpp 29
3023 
3024     \li Disconnect a specific receiver:
3025 
3026        \snippet code/src_corelib_kernel_qobject.cpp 30
3027 
3028        equivalent to the non-static overloaded function
3029 
3030        \snippet code/src_corelib_kernel_qobject.cpp 31
3031 
3032     \endlist
3033 
3034     \nullptr may be used as a wildcard, meaning "any signal", "any receiving
3035     object", or "any slot in the receiving object", respectively.
3036 
3037     The \a sender may never be \nullptr. (You cannot disconnect signals
3038     from more than one object in a single call.)
3039 
3040     If \a signal is \nullptr, it disconnects \a receiver and \a method from
3041     any signal. If not, only the specified signal is disconnected.
3042 
3043     If \a receiver is \nullptr, it disconnects anything connected to \a
3044     signal. If not, slots in objects other than \a receiver are not
3045     disconnected.
3046 
3047     If \a method is \nullptr, it disconnects anything that is connected to \a
3048     receiver. If not, only slots named \a method will be disconnected,
3049     and all other slots are left alone. The \a method must be \nullptr
3050     if \a receiver is left out, so you cannot disconnect a
3051     specifically-named slot on all objects.
3052 
3053     \include includes/qobject.qdocinc disconnect-all
3054 
3055     \sa connect()
3056 */
3057 bool QObject::disconnect(const QObject *sender, const char *signal,
3058                          const QObject *receiver, const char *method)
3059 {
3060     if (sender == nullptr || (receiver == nullptr && method != nullptr)) {
3061         qCWarning(lcConnect, "QObject::disconnect: Unexpected nullptr parameter");
3062         return false;
3063     }
3064 
3065     const char *signal_arg = signal;
3066     QByteArray signal_name;
3067     bool signal_found = false;
3068     if (signal) {
3069         QT_TRY {
3070             signal_name = QMetaObject::normalizedSignature(signal);
3071             signal = signal_name.constData();
3072         } QT_CATCH (const std::bad_alloc &) {
3073             // if the signal is already normalized, we can continue.
3074             if (sender->metaObject()->indexOfSignal(signal + 1) == -1)
3075                 QT_RETHROW;
3076         }
3077 
3078         if (!check_signal_macro(sender, signal, "disconnect", "unbind"))
3079             return false;
3080         signal++; // skip code
3081     }
3082 
3083     QByteArray method_name;
3084     const char *method_arg = method;
3085     int membcode = -1;
3086     bool method_found = false;
3087     if (method) {
3088         QT_TRY {
3089             method_name = QMetaObject::normalizedSignature(method);
3090             method = method_name.constData();
3091         } QT_CATCH(const std::bad_alloc &) {
3092             // if the method is already normalized, we can continue.
3093             if (receiver->metaObject()->indexOfMethod(method + 1) == -1)
3094                 QT_RETHROW;
3095         }
3096 
3097         membcode = extract_code(method);
3098         if (!check_method_code(membcode, receiver, method, "disconnect"))
3099             return false;
3100         method++; // skip code
3101     }
3102 
3103     /* We now iterate through all the sender's and receiver's meta
3104      * objects in order to also disconnect possibly shadowed signals
3105      * and slots with the same signature.
3106     */
3107     bool res = false;
3108     const QMetaObject *smeta = sender->metaObject();
3109     QByteArray signalName;
3110     QArgumentTypeArray signalTypes;
3111     Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
3112     if (signal)
3113         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
3114     QByteArray methodName;
3115     QArgumentTypeArray methodTypes;
3116     Q_ASSERT(!receiver || QMetaObjectPrivate::get(receiver->metaObject())->revision >= 7);
3117     if (method)
3118         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
3119     do {
3120         int signal_index = -1;
3121         if (signal) {
3122             signal_index = QMetaObjectPrivate::indexOfSignalRelative(
3123                         &smeta, signalName, signalTypes.size(), signalTypes.constData());
3124             if (signal_index < 0)
3125                 break;
3126             signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
3127             signal_index += QMetaObjectPrivate::signalOffset(smeta);
3128             signal_found = true;
3129         }
3130 
3131         if (!method) {
3132             res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, -1, nullptr);
3133         } else {
3134             const QMetaObject *rmeta = receiver->metaObject();
3135             do {
3136                 int method_index = QMetaObjectPrivate::indexOfMethod(
3137                             rmeta, methodName, methodTypes.size(), methodTypes.constData());
3138                 if (method_index >= 0)
3139                     while (method_index < rmeta->methodOffset())
3140                             rmeta = rmeta->superClass();
3141                 if (method_index < 0)
3142                     break;
3143                 res |= QMetaObjectPrivate::disconnect(sender, signal_index, smeta, receiver, method_index, nullptr);
3144                 method_found = true;
3145             } while ((rmeta = rmeta->superClass()));
3146         }
3147     } while (signal && (smeta = smeta->superClass()));
3148 
3149     if (signal && !signal_found) {
3150         err_method_notfound(sender, signal_arg, "disconnect");
3151         err_info_about_objects("disconnect", sender, receiver);
3152     } else if (method && !method_found) {
3153         err_method_notfound(receiver, method_arg, "disconnect");
3154         err_info_about_objects("disconnect", sender, receiver);
3155     }
3156     if (res) {
3157         if (!signal)
3158             const_cast<QObject *>(sender)->disconnectNotify(QMetaMethod());
3159     }
3160     return res;
3161 }
3162 
3163 /*!
3164     \since 4.8
3165 
3166     Disconnects \a signal in object \a sender from \a method in object
3167     \a receiver. Returns \c true if the connection is successfully broken;
3168     otherwise returns \c false.
3169 
3170     This function provides the same possibilities like
3171     \c {disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method) }
3172     but uses QMetaMethod to represent the signal and the method to be disconnected.
3173 
3174     Additionally this function returns false and no signals and slots disconnected
3175     if:
3176     \list 1
3177 
3178         \li \a signal is not a member of sender class or one of its parent classes.
3179 
3180         \li \a method is not a member of receiver class or one of its parent classes.
3181 
3182         \li \a signal instance represents not a signal.
3183 
3184     \endlist
3185 
3186     QMetaMethod() may be used as wildcard in the meaning "any signal" or "any slot in receiving object".
3187     In the same way \nullptr can be used for \a receiver in the meaning "any receiving object".
3188     In this case method should also be QMetaMethod(). \a sender parameter should be never \nullptr.
3189 
3190     \include includes/qobject.qdocinc disconnect-all
3191 
3192     \sa disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)
3193  */
3194 bool QObject::disconnect(const QObject *sender, const QMetaMethod &signal,
3195                          const QObject *receiver, const QMetaMethod &method)
3196 {
3197     if (sender == nullptr || (receiver == nullptr && method.mobj != nullptr)) {
3198         qCWarning(lcConnect, "QObject::disconnect: Unexpected nullptr parameter");
3199         return false;
3200     }
3201     if (signal.mobj) {
3202         if (signal.methodType() != QMetaMethod::Signal) {
3203             qCWarning(lcConnect, "QObject::%s: Attempt to %s non-signal %s::%s",
3204                      "disconnect","unbind",
3205                      sender->metaObject()->className(), signal.methodSignature().constData());
3206             return false;
3207         }
3208     }
3209     if (method.mobj) {
3210         if (method.methodType() == QMetaMethod::Constructor) {
3211             qCWarning(lcConnect, "QObject::disconnect: cannot use constructor as argument %s::%s",
3212                       receiver->metaObject()->className(), method.methodSignature().constData());
3213             return false;
3214         }
3215     }
3216 
3217     int signal_index;
3218     int method_index;
3219     {
3220         int dummy;
3221         QMetaObjectPrivate::memberIndexes(sender, signal, &signal_index, &dummy);
3222         QMetaObjectPrivate::memberIndexes(receiver, method, &dummy, &method_index);
3223     }
3224     // If we are here sender is not nullptr. If signal is not nullptr while signal_index
3225     // is -1 then this signal is not a member of sender.
3226     if (signal.mobj && signal_index == -1) {
3227         qCWarning(lcConnect, "QObject::disconnect: signal %s not found on class %s",
3228                   signal.methodSignature().constData(), sender->metaObject()->className());
3229         return false;
3230     }
3231     // If this condition is true then method is not a member of receiver.
3232     if (receiver && method.mobj && method_index == -1) {
3233         qCWarning(lcConnect, "QObject::disconnect: method %s not found on class %s",
3234                   method.methodSignature().constData(), receiver->metaObject()->className());
3235         return false;
3236     }
3237 
3238     if (!QMetaObjectPrivate::disconnect(sender, signal_index, signal.mobj, receiver, method_index, nullptr))
3239         return false;
3240 
3241     if (!signal.isValid()) {
3242         // The signal is a wildcard, meaning all signals were disconnected.
3243         // QMetaObjectPrivate::disconnect() doesn't call disconnectNotify()
3244         // per connection in this case. Call it once now, with an invalid
3245         // QMetaMethod as argument, as documented.
3246         const_cast<QObject *>(sender)->disconnectNotify(signal);
3247     }
3248     return true;
3249 }
3250 
3251 /*!
3252     \threadsafe
3253 
3254     \fn bool QObject::disconnect(const char *signal, const QObject *receiver, const char *method) const
3255     \overload disconnect()
3256 
3257     Disconnects \a signal from \a method of \a receiver.
3258 
3259     A signal-slot connection is removed when either of the objects
3260     involved are destroyed.
3261 
3262     \include includes/qobject.qdocinc disconnect-all
3263 */
3264 
3265 /*!
3266     \fn bool QObject::disconnect(const QObject *receiver, const char *method) const
3267     \overload disconnect()
3268 
3269     Disconnects all signals in this object from \a receiver's \a
3270     method.
3271 
3272     A signal-slot connection is removed when either of the objects
3273     involved are destroyed.
3274 */
3275 
3276 
3277 /*!
3278     \since 5.0
3279 
3280     This virtual function is called when something has been connected
3281     to \a signal in this object.
3282 
3283     If you want to compare \a signal with a specific signal, you can
3284     use QMetaMethod::fromSignal() as follows:
3285 
3286     \snippet code/src_corelib_kernel_qobject.cpp 32
3287 
3288     \warning This function violates the object-oriented principle of
3289     modularity. However, it might be useful when you need to perform
3290     expensive initialization only if something is connected to a
3291     signal.
3292 
3293     \warning This function is called from the thread which performs the
3294     connection, which may be a different thread from the thread in
3295     which this object lives.
3296 
3297     \sa connect(), disconnectNotify()
3298 */
3299 
3300 void QObject::connectNotify(const QMetaMethod &signal)
3301 {
3302     Q_UNUSED(signal);
3303 }
3304 
3305 /*!
3306     \since 5.0
3307 
3308     This virtual function is called when something has been
3309     disconnected from \a signal in this object.
3310 
3311     See connectNotify() for an example of how to compare
3312     \a signal with a specific signal.
3313 
3314     If all signals were disconnected from this object (e.g., the
3315     signal argument to disconnect() was \nullptr), disconnectNotify()
3316     is only called once, and the \a signal will be an invalid
3317     QMetaMethod (QMetaMethod::isValid() returns \c false).
3318 
3319     \warning This function violates the object-oriented principle of
3320     modularity. However, it might be useful for optimizing access to
3321     expensive resources.
3322 
3323     \warning This function is called from the thread which performs the
3324     disconnection, which may be a different thread from the thread in
3325     which this object lives. This function may also be called with a QObject
3326     internal mutex locked. It is therefore not allowed to re-enter any
3327     of any QObject functions from your reimplementation and if you lock
3328     a mutex in your reimplementation, make sure that you don't call QObject
3329     functions with that mutex held in other places or it will result in
3330     a deadlock.
3331 
3332     \sa disconnect(), connectNotify()
3333 */
3334 
3335 void QObject::disconnectNotify(const QMetaMethod &signal)
3336 {
3337     Q_UNUSED(signal);
3338 }
3339 
3340 /*
3341     \internal
3342     convert a signal index from the method range to the signal range
3343  */
3344 static int methodIndexToSignalIndex(const QMetaObject **base, int signal_index)
3345 {
3346     if (signal_index < 0)
3347         return signal_index;
3348     const QMetaObject *metaObject = *base;
3349     while (metaObject && metaObject->methodOffset() > signal_index)
3350         metaObject = metaObject->superClass();
3351 
3352     if (metaObject) {
3353         int signalOffset, methodOffset;
3354         computeOffsets(metaObject, &signalOffset, &methodOffset);
3355         if (signal_index < metaObject->methodCount())
3356             signal_index = QMetaObjectPrivate::originalClone(metaObject, signal_index - methodOffset) + signalOffset;
3357         else
3358             signal_index = signal_index - methodOffset + signalOffset;
3359         *base = metaObject;
3360     }
3361     return signal_index;
3362 }
3363 
3364 /*!
3365    \internal
3366    \a types is a 0-terminated vector of meta types for queued
3367    connections.
3368 
3369    if \a signal_index is -1, then we effectively connect *all* signals
3370    from the sender to the receiver's slot
3371  */
3372 QMetaObject::Connection QMetaObject::connect(const QObject *sender, int signal_index,
3373                                              const QObject *receiver, int method_index, int type,
3374                                              int *types)
3375 {
3376     const QMetaObject *smeta = sender->metaObject();
3377     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3378     return Connection(QMetaObjectPrivate::connect(sender, signal_index, smeta,
3379                                        receiver, method_index,
3380                                        nullptr, //FIXME, we could speed this connection up by computing the relative index
3381                                        type, types));
3382 }
3383 
3384 /*!
3385     \internal
3386    Same as the QMetaObject::connect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3387 
3388     method_index is relative to the rmeta metaobject, if rmeta is \nullptr, then it is absolute index
3389 
3390     the QObjectPrivate::Connection* has a refcount of 2, so it must be passed to a QMetaObject::Connection
3391  */
3392 QObjectPrivate::Connection *QMetaObjectPrivate::connect(const QObject *sender,
3393                                  int signal_index, const QMetaObject *smeta,
3394                                  const QObject *receiver, int method_index,
3395                                  const QMetaObject *rmeta, int type, int *types)
3396 {
3397     QObject *s = const_cast<QObject *>(sender);
3398     QObject *r = const_cast<QObject *>(receiver);
3399 
3400     int method_offset = rmeta ? rmeta->methodOffset() : 0;
3401     Q_ASSERT(!rmeta || QMetaObjectPrivate::get(rmeta)->revision >= 6);
3402     QObjectPrivate::StaticMetaCallFunction callFunction = rmeta ? rmeta->d.static_metacall : nullptr;
3403 
3404     QOrderedMutexLocker locker(signalSlotLock(sender),
3405                                signalSlotLock(receiver));
3406 
3407     QObjectPrivate::ConnectionData *scd  = QObjectPrivate::get(s)->connections.loadRelaxed();
3408     if (type & Qt::UniqueConnection && scd) {
3409         if (scd->signalVectorCount() > signal_index) {
3410             const QObjectPrivate::Connection *c2 = scd->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
3411 
3412             int method_index_absolute = method_index + method_offset;
3413 
3414             while (c2) {
3415                 if (!c2->isSlotObject && c2->receiver.loadRelaxed() == receiver && c2->method() == method_index_absolute)
3416                     return nullptr;
3417                 c2 = c2->nextConnectionList.loadRelaxed();
3418             }
3419         }
3420     }
3421     type &= ~Qt::UniqueConnection;
3422 
3423     const bool isSingleShot = type & Qt::SingleShotConnection;
3424     type &= ~Qt::SingleShotConnection;
3425 
3426     Q_ASSERT(type >= 0);
3427     Q_ASSERT(type <= 3);
3428 
3429     std::unique_ptr<QObjectPrivate::Connection> c{new QObjectPrivate::Connection};
3430     c->sender = s;
3431     c->signal_index = signal_index;
3432     c->receiver.storeRelaxed(r);
3433     QThreadData *td = r->d_func()->threadData;
3434     td->ref();
3435     c->receiverThreadData.storeRelaxed(td);
3436     c->method_relative = method_index;
3437     c->method_offset = method_offset;
3438     c->connectionType = type;
3439     c->isSlotObject = false;
3440     c->argumentTypes.storeRelaxed(types);
3441     c->callFunction = callFunction;
3442     c->isSingleShot = isSingleShot;
3443 
3444     QObjectPrivate::get(s)->addConnection(signal_index, c.get());
3445 
3446     locker.unlock();
3447     QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3448     if (smethod.isValid())
3449         s->connectNotify(smethod);
3450 
3451     return c.release();
3452 }
3453 
3454 /*!
3455     \internal
3456  */
3457 bool QMetaObject::disconnect(const QObject *sender, int signal_index,
3458                              const QObject *receiver, int method_index)
3459 {
3460     const QMetaObject *smeta = sender->metaObject();
3461     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3462     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3463                                           receiver, method_index, nullptr);
3464 }
3465 
3466 /*!
3467     \internal
3468 
3469 Disconnect a single signal connection.  If QMetaObject::connect() has been called
3470 multiple times for the same sender, signal_index, receiver and method_index only
3471 one of these connections will be removed.
3472  */
3473 bool QMetaObject::disconnectOne(const QObject *sender, int signal_index,
3474                                 const QObject *receiver, int method_index)
3475 {
3476     const QMetaObject *smeta = sender->metaObject();
3477     signal_index = methodIndexToSignalIndex(&smeta, signal_index);
3478     return QMetaObjectPrivate::disconnect(sender, signal_index, smeta,
3479                                           receiver, method_index, nullptr,
3480                                           QMetaObjectPrivate::DisconnectOne);
3481 }
3482 
3483 /*!
3484     \internal
3485     Helper function to remove the connection from the senders list and set the receivers to \nullptr
3486  */
3487 bool QMetaObjectPrivate::disconnectHelper(QObjectPrivate::ConnectionData *connections, int signalIndex,
3488                                           const QObject *receiver, int method_index, void **slot,
3489                                           QBasicMutex *senderMutex, DisconnectType disconnectType)
3490 {
3491     bool success = false;
3492 
3493     auto &connectionList = connections->connectionsForSignal(signalIndex);
3494     auto *c = connectionList.first.loadRelaxed();
3495     while (c) {
3496         QObject *r = c->receiver.loadRelaxed();
3497         if (r && (receiver == nullptr || (r == receiver
3498                            && (method_index < 0 || (!c->isSlotObject && c->method() == method_index))
3499                            && (slot == nullptr || (c->isSlotObject && c->slotObj->compare(slot)))))) {
3500             bool needToUnlock = false;
3501             QBasicMutex *receiverMutex = nullptr;
3502             if (r) {
3503                 receiverMutex = signalSlotLock(r);
3504                 // need to relock this receiver and sender in the correct order
3505                 needToUnlock = QOrderedMutexLocker::relock(senderMutex, receiverMutex);
3506             }
3507             if (c->receiver.loadRelaxed())
3508                 connections->removeConnection(c);
3509 
3510             if (needToUnlock)
3511                 receiverMutex->unlock();
3512 
3513             success = true;
3514 
3515             if (disconnectType == DisconnectOne)
3516                 return success;
3517         }
3518         c = c->nextConnectionList.loadRelaxed();
3519     }
3520     return success;
3521 }
3522 
3523 /*!
3524     \internal
3525     Same as the QMetaObject::disconnect, but \a signal_index must be the result of QObjectPrivate::signalIndex
3526  */
3527 bool QMetaObjectPrivate::disconnect(const QObject *sender,
3528                                     int signal_index, const QMetaObject *smeta,
3529                                     const QObject *receiver, int method_index, void **slot,
3530                                     DisconnectType disconnectType)
3531 {
3532     if (!sender)
3533         return false;
3534 
3535     QObject *s = const_cast<QObject *>(sender);
3536 
3537     QBasicMutex *senderMutex = signalSlotLock(sender);
3538     QBasicMutexLocker locker(senderMutex);
3539 
3540     QObjectPrivate::ConnectionData *scd = QObjectPrivate::get(s)->connections.loadRelaxed();
3541     if (!scd)
3542         return false;
3543 
3544     bool success = false;
3545     {
3546         // prevent incoming connections changing the connections->receivers while unlocked
3547         QObjectPrivate::ConnectionDataPointer connections(scd);
3548 
3549         if (signal_index < 0) {
3550             // remove from all connection lists
3551             for (int sig_index = -1; sig_index < scd->signalVectorCount(); ++sig_index) {
3552                 if (disconnectHelper(connections.data(), sig_index, receiver, method_index, slot, senderMutex, disconnectType))
3553                     success = true;
3554             }
3555         } else if (signal_index < scd->signalVectorCount()) {
3556             if (disconnectHelper(connections.data(), signal_index, receiver, method_index, slot, senderMutex, disconnectType))
3557                 success = true;
3558         }
3559     }
3560 
3561     locker.unlock();
3562     if (success) {
3563         scd->cleanOrphanedConnections(s);
3564 
3565         QMetaMethod smethod = QMetaObjectPrivate::signal(smeta, signal_index);
3566         if (smethod.isValid())
3567             s->disconnectNotify(smethod);
3568     }
3569 
3570     return success;
3571 }
3572 
3573 // Helpers for formatting the connect statements of connectSlotsByName()'s debug mode
3574 static QByteArray formatConnectionSignature(const char *className, const QMetaMethod &method)
3575 {
3576     const auto signature = method.methodSignature();
3577     Q_ASSERT(signature.endsWith(')'));
3578     const int openParen = signature.indexOf('(');
3579     const bool hasParameters = openParen >= 0 && openParen < signature.size() - 2;
3580     QByteArray result;
3581     if (hasParameters) {
3582         result += "qOverload<"
3583             + signature.mid(openParen + 1, signature.size() - openParen - 2) + ">(";
3584     }
3585     result += '&';
3586     result += className + QByteArrayLiteral("::") + method.name();
3587     if (hasParameters)
3588         result += ')';
3589     return result;
3590 }
3591 
3592 static QByteArray msgConnect(const QMetaObject *senderMo, const QByteArray &senderName,
3593                              const QMetaMethod &signal, const QObject *receiver, int receiverIndex)
3594 {
3595     const auto receiverMo = receiver->metaObject();
3596     const auto slot = receiverMo->method(receiverIndex);
3597     QByteArray message = QByteArrayLiteral("QObject::connect(")
3598         + senderName + ", " + formatConnectionSignature(senderMo->className(), signal)
3599         + ", " + receiver->objectName().toLatin1() + ", "
3600         + formatConnectionSignature(receiverMo->className(), slot) + ");";
3601     return message;
3602 }
3603 
3604 /*!
3605     \fn void QMetaObject::connectSlotsByName(QObject *object)
3606 
3607     Searches recursively for all child objects of the given \a object, and connects
3608     matching signals from them to slots of \a object that follow the following form:
3609 
3610     \snippet code/src_corelib_kernel_qobject.cpp 33
3611 
3612     Let's assume our object has a child object of type \c{QPushButton} with
3613     the \l{QObject::objectName}{object name} \c{button1}. The slot to catch the
3614     button's \c{clicked()} signal would be:
3615 
3616     \snippet code/src_corelib_kernel_qobject.cpp 34
3617 
3618     If \a object itself has a properly set object name, its own signals are also
3619     connected to its respective slots.
3620 
3621     \sa QObject::setObjectName()
3622  */
3623 void QMetaObject::connectSlotsByName(QObject *o)
3624 {
3625     if (!o)
3626         return;
3627     const QMetaObject *mo = o->metaObject();
3628     Q_ASSERT(mo);
3629     const QObjectList list = // list of all objects to look for matching signals including...
3630             o->findChildren<QObject *>() // all children of 'o'...
3631             << o; // and the object 'o' itself
3632 
3633     // for each method/slot of o ...
3634     for (int i = 0; i < mo->methodCount(); ++i) {
3635         const QByteArray slotSignature = mo->method(i).methodSignature();
3636         const char *slot = slotSignature.constData();
3637         Q_ASSERT(slot);
3638 
3639         // ...that starts with "on_", ...
3640         if (slot[0] != 'o' || slot[1] != 'n' || slot[2] != '_')
3641             continue;
3642 
3643         // ...we check each object in our list, ...
3644         bool foundIt = false;
3645         for (int j = 0; j < list.count(); ++j) {
3646             const QObject *co = list.at(j);
3647             const QByteArray coName = co->objectName().toLatin1();
3648 
3649             // ...discarding those whose objectName is not fitting the pattern "on_<objectName>_...", ...
3650             if (coName.isEmpty() || qstrncmp(slot + 3, coName.constData(), coName.size()) || slot[coName.size()+3] != '_')
3651                 continue;
3652 
3653             const char *signal = slot + coName.size() + 4; // the 'signal' part of the slot name
3654 
3655             // ...for the presence of a matching signal "on_<objectName>_<signal>".
3656             const QMetaObject *smeta;
3657             int sigIndex = co->d_func()->signalIndex(signal, &smeta);
3658             if (sigIndex < 0) {
3659                 // if no exactly fitting signal (name + complete parameter type list) could be found
3660                 // look for just any signal with the correct name and at least the slot's parameter list.
3661                 // Note: if more than one of those signals exist, the one that gets connected is
3662                 // chosen 'at random' (order of declaration in source file)
3663                 QList<QByteArray> compatibleSignals;
3664                 const QMetaObject *smo = co->metaObject();
3665                 int sigLen = int(qstrlen(signal)) - 1; // ignore the trailing ')'
3666                 for (int k = QMetaObjectPrivate::absoluteSignalCount(smo)-1; k >= 0; --k) {
3667                     const QMetaMethod method = QMetaObjectPrivate::signal(smo, k);
3668                     if (!qstrncmp(method.methodSignature().constData(), signal, sigLen)) {
3669                         smeta = method.enclosingMetaObject();
3670                         sigIndex = k;
3671                         compatibleSignals.prepend(method.methodSignature());
3672                     }
3673                 }
3674                 if (compatibleSignals.size() > 1)
3675                     qCWarning(lcConnectSlotsByName) << "QMetaObject::connectSlotsByName: Connecting slot" << slot
3676                                << "with the first of the following compatible signals:" << compatibleSignals;
3677             }
3678 
3679             if (sigIndex < 0)
3680                 continue;
3681 
3682             // we connect it...
3683             if (Connection(QMetaObjectPrivate::connect(co, sigIndex, smeta, o, i))) {
3684                 foundIt = true;
3685                 qCDebug(lcConnectSlotsByName, "%s",
3686                         msgConnect(smeta, coName, QMetaObjectPrivate::signal(smeta, sigIndex), o,  i).constData());
3687                 // ...and stop looking for further objects with the same name.
3688                 // Note: the Designer will make sure each object name is unique in the above
3689                 // 'list' but other code may create two child objects with the same name. In
3690                 // this case one is chosen 'at random'.
3691                 break;
3692             }
3693         }
3694         if (foundIt) {
3695             // we found our slot, now skip all overloads
3696             while (mo->method(i + 1).attributes() & QMetaMethod::Cloned)
3697                 ++i;
3698         } else if (!(mo->method(i).attributes() & QMetaMethod::Cloned)) {
3699             // check if the slot has the following signature: "on_..._...(..."
3700             int iParen = slotSignature.indexOf('(');
3701             int iLastUnderscore = slotSignature.lastIndexOf('_', iParen - 1);
3702             if (iLastUnderscore > 3)
3703                 qCWarning(lcConnectSlotsByName,
3704                           "QMetaObject::connectSlotsByName: No matching signal for %s", slot);
3705         }
3706     }
3707 }
3708 
3709 /*!
3710      \internal
3711      A small RAII helper for QSlotObjectBase.
3712      Calls ref on construction and destroyLastRef in its dtor.
3713      Allows construction from a nullptr in which case it does nothing.
3714  */
3715 struct SlotObjectGuard {
3716     SlotObjectGuard() = default;
3717     // move would be fine, but we do not need it currently
3718     Q_DISABLE_COPY_MOVE(SlotObjectGuard)
3719     explicit SlotObjectGuard(QtPrivate::QSlotObjectBase *slotObject)
3720         : m_slotObject(slotObject)
3721     {
3722         if (m_slotObject)
3723             m_slotObject->ref();
3724     }
3725 
3726     QtPrivate::QSlotObjectBase const *operator->() const
3727     { return m_slotObject; }
3728 
3729     QtPrivate::QSlotObjectBase *operator->()
3730     { return m_slotObject; }
3731 
3732     ~SlotObjectGuard() {
3733         if (m_slotObject)
3734             m_slotObject->destroyIfLastRef();
3735     }
3736 private:
3737     QtPrivate::QSlotObjectBase *m_slotObject = nullptr;
3738 };
3739 
3740 /*!
3741     \internal
3742 
3743     \a signal must be in the signal index range (see QObjectPrivate::signalIndex()).
3744 */
3745 static void queued_activate(QObject *sender, int signal, QObjectPrivate::Connection *c, void **argv)
3746 {
3747     const int *argumentTypes = c->argumentTypes.loadRelaxed();
3748     if (!argumentTypes) {
3749         QMetaMethod m = QMetaObjectPrivate::signal(sender->metaObject(), signal);
3750         argumentTypes = queuedConnectionTypes(m);
3751         if (!argumentTypes) // cannot queue arguments
3752             argumentTypes = &DIRECT_CONNECTION_ONLY;
3753         if (!c->argumentTypes.testAndSetOrdered(nullptr, argumentTypes)) {
3754             if (argumentTypes != &DIRECT_CONNECTION_ONLY)
3755                 delete[] argumentTypes;
3756             argumentTypes = c->argumentTypes.loadRelaxed();
3757         }
3758     }
3759     if (argumentTypes == &DIRECT_CONNECTION_ONLY) // cannot activate
3760         return;
3761     int nargs = 1; // include return type
3762     while (argumentTypes[nargs - 1])
3763         ++nargs;
3764 
3765     QBasicMutexLocker locker(signalSlotLock(c->receiver.loadRelaxed()));
3766     QObject *receiver = c->receiver.loadRelaxed();
3767     if (!receiver) {
3768         // the connection has been disconnected before we got the lock
3769         return;
3770     }
3771 
3772     SlotObjectGuard slotObjectGuard { c->isSlotObject ? c->slotObj : nullptr };
3773     locker.unlock();
3774 
3775     QMetaCallEvent *ev = c->isSlotObject ?
3776         new QMetaCallEvent(c->slotObj, sender, signal, nargs) :
3777         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction, sender, signal, nargs);
3778 
3779     void **args = ev->args();
3780     QMetaType *types = ev->types();
3781 
3782     types[0] = QMetaType(); // return type
3783     args[0] = nullptr; // return value
3784 
3785     if (nargs > 1) {
3786         for (int n = 1; n < nargs; ++n)
3787             types[n] = QMetaType(argumentTypes[n - 1]);
3788 
3789         for (int n = 1; n < nargs; ++n)
3790             args[n] = types[n].create(argv[n]);
3791     }
3792 
3793     if (c->isSingleShot && !QObjectPrivate::disconnect(c)) {
3794         delete ev;
3795         return;
3796     }
3797 
3798     locker.relock();
3799     if (!c->isSingleShot && !c->receiver.loadRelaxed()) {
3800         // the connection has been disconnected while we were unlocked
3801         locker.unlock();
3802         delete ev;
3803         return;
3804     }
3805 
3806     QCoreApplication::postEvent(receiver, ev);
3807 }
3808 
3809 template <bool callbacks_enabled>
3810 void doActivate(QObject *sender, int signal_index, void **argv)
3811 {
3812     QObjectPrivate *sp = QObjectPrivate::get(sender);
3813 
3814     if (sp->blockSig)
3815         return;
3816 
3817     Q_TRACE_SCOPE(QMetaObject_activate, sender, signal_index);
3818 
3819     if (sp->isDeclarativeSignalConnected(signal_index)
3820             && QAbstractDeclarativeData::signalEmitted) {
3821         Q_TRACE_SCOPE(QMetaObject_activate_declarative_signal, sender, signal_index);
3822         QAbstractDeclarativeData::signalEmitted(sp->declarativeData, sender,
3823                                                 signal_index, argv);
3824     }
3825 
3826     const QSignalSpyCallbackSet *signal_spy_set = callbacks_enabled ? qt_signal_spy_callback_set.loadAcquire() : nullptr;
3827 
3828     void *empty_argv[] = { nullptr };
3829     if (!argv)
3830         argv = empty_argv;
3831 
3832     if (!sp->maybeSignalConnected(signal_index)) {
3833         // The possible declarative connection is done, and nothing else is connected
3834         if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3835             signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3836         if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3837             signal_spy_set->signal_end_callback(sender, signal_index);
3838         return;
3839     }
3840 
3841     if (callbacks_enabled && signal_spy_set->signal_begin_callback != nullptr)
3842         signal_spy_set->signal_begin_callback(sender, signal_index, argv);
3843 
3844     bool senderDeleted = false;
3845     {
3846     Q_ASSERT(sp->connections.loadAcquire());
3847     QObjectPrivate::ConnectionDataPointer connections(sp->connections.loadRelaxed());
3848     QObjectPrivate::SignalVector *signalVector = connections->signalVector.loadRelaxed();
3849 
3850     const QObjectPrivate::ConnectionList *list;
3851     if (signal_index < signalVector->count())
3852         list = &signalVector->at(signal_index);
3853     else
3854         list = &signalVector->at(-1);
3855 
3856     Qt::HANDLE currentThreadId = QThread::currentThreadId();
3857     bool inSenderThread = currentThreadId == QObjectPrivate::get(sender)->threadData.loadRelaxed()->threadId.loadRelaxed();
3858 
3859     // We need to check against the highest connection id to ensure that signals added
3860     // during the signal emission are not emitted in this emission.
3861     uint highestConnectionId = connections->currentConnectionId.loadRelaxed();
3862     do {
3863         QObjectPrivate::Connection *c = list->first.loadRelaxed();
3864         if (!c)
3865             continue;
3866 
3867         do {
3868             QObject * const receiver = c->receiver.loadRelaxed();
3869             if (!receiver)
3870                 continue;
3871 
3872             QThreadData *td = c->receiverThreadData.loadRelaxed();
3873             if (!td)
3874                 continue;
3875 
3876             bool receiverInSameThread;
3877             if (inSenderThread) {
3878                 receiverInSameThread = currentThreadId == td->threadId.loadRelaxed();
3879             } else {
3880                 // need to lock before reading the threadId, because moveToThread() could interfere
3881                 QMutexLocker lock(signalSlotLock(receiver));
3882                 receiverInSameThread = currentThreadId == td->threadId.loadRelaxed();
3883             }
3884 
3885 
3886             // determine if this connection should be sent immediately or
3887             // put into the event queue
3888             if ((c->connectionType == Qt::AutoConnection && !receiverInSameThread)
3889                 || (c->connectionType == Qt::QueuedConnection)) {
3890                 queued_activate(sender, signal_index, c, argv);
3891                 continue;
3892 #if QT_CONFIG(thread)
3893             } else if (c->connectionType == Qt::BlockingQueuedConnection) {
3894                 if (receiverInSameThread) {
3895                     qWarning("Qt: Dead lock detected while activating a BlockingQueuedConnection: "
3896                     "Sender is %s(%p), receiver is %s(%p)",
3897                     sender->metaObject()->className(), sender,
3898                     receiver->metaObject()->className(), receiver);
3899                 }
3900 
3901                 if (c->isSingleShot && !QObjectPrivate::disconnect(c))
3902                     continue;
3903 
3904                 QSemaphore semaphore;
3905                 {
3906                     QBasicMutexLocker locker(signalSlotLock(receiver));
3907                     if (!c->isSingleShot && !c->receiver.loadAcquire())
3908                         continue;
3909                     QMetaCallEvent *ev = c->isSlotObject ?
3910                         new QMetaCallEvent(c->slotObj, sender, signal_index, argv, &semaphore) :
3911                         new QMetaCallEvent(c->method_offset, c->method_relative, c->callFunction,
3912                                            sender, signal_index, argv, &semaphore);
3913                     QCoreApplication::postEvent(receiver, ev);
3914                 }
3915                 semaphore.acquire();
3916                 continue;
3917 #endif
3918             }
3919 
3920             if (c->isSingleShot && !QObjectPrivate::disconnect(c))
3921                 continue;
3922 
3923             QObjectPrivate::Sender senderData(receiverInSameThread ? receiver : nullptr, sender, signal_index);
3924 
3925             if (c->isSlotObject) {
3926                 SlotObjectGuard obj{c->slotObj};
3927 
3928                 {
3929                     Q_TRACE_SCOPE(QMetaObject_activate_slot_functor, c->slotObj);
3930                     obj->call(receiver, argv);
3931                 }
3932             } else if (c->callFunction && c->method_offset <= receiver->metaObject()->methodOffset()) {
3933                 //we compare the vtable to make sure we are not in the destructor of the object.
3934                 const int method_relative = c->method_relative;
3935                 const auto callFunction = c->callFunction;
3936                 const int methodIndex = (Q_HAS_TRACEPOINTS || callbacks_enabled) ? c->method() : 0;
3937                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr)
3938                     signal_spy_set->slot_begin_callback(receiver, methodIndex, argv);
3939 
3940                 {
3941                     Q_TRACE_SCOPE(QMetaObject_activate_slot, receiver, methodIndex);
3942                     callFunction(receiver, QMetaObject::InvokeMetaMethod, method_relative, argv);
3943                 }
3944 
3945                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3946                     signal_spy_set->slot_end_callback(receiver, methodIndex);
3947             } else {
3948                 const int method = c->method_relative + c->method_offset;
3949 
3950                 if (callbacks_enabled && signal_spy_set->slot_begin_callback != nullptr) {
3951                     signal_spy_set->slot_begin_callback(receiver, method, argv);
3952                 }
3953 
3954                 {
3955                     Q_TRACE_SCOPE(QMetaObject_activate_slot, receiver, method);
3956                     QMetaObject::metacall(receiver, QMetaObject::InvokeMetaMethod, method, argv);
3957                 }
3958 
3959                 if (callbacks_enabled && signal_spy_set->slot_end_callback != nullptr)
3960                     signal_spy_set->slot_end_callback(receiver, method);
3961             }
3962         } while ((c = c->nextConnectionList.loadRelaxed()) != nullptr && c->id <= highestConnectionId);
3963 
3964     } while (list != &signalVector->at(-1) &&
3965         //start over for all signals;
3966         ((list = &signalVector->at(-1)), true));
3967 
3968         if (connections->currentConnectionId.loadRelaxed() == 0)
3969             senderDeleted = true;
3970     }
3971     if (!senderDeleted) {
3972         sp->connections.loadRelaxed()->cleanOrphanedConnections(sender);
3973 
3974         if (callbacks_enabled && signal_spy_set->signal_end_callback != nullptr)
3975             signal_spy_set->signal_end_callback(sender, signal_index);
3976     }
3977 }
3978 
3979 /*!
3980     \internal
3981  */
3982 void QMetaObject::activate(QObject *sender, const QMetaObject *m, int local_signal_index,
3983                            void **argv)
3984 {
3985     int signal_index = local_signal_index + QMetaObjectPrivate::signalOffset(m);
3986 
3987     if (Q_UNLIKELY(qt_signal_spy_callback_set.loadRelaxed()))
3988         doActivate<true>(sender, signal_index, argv);
3989     else
3990         doActivate<false>(sender, signal_index, argv);
3991 }
3992 
3993 /*!
3994     \internal
3995  */
3996 void QMetaObject::activate(QObject *sender, int signalOffset, int local_signal_index, void **argv)
3997 {
3998     int signal_index = signalOffset + local_signal_index;
3999 
4000     if (Q_UNLIKELY(qt_signal_spy_callback_set.loadRelaxed()))
4001         doActivate<true>(sender, signal_index, argv);
4002     else
4003         doActivate<false>(sender, signal_index, argv);
4004 }
4005 
4006 /*!
4007     \internal
4008    signal_index comes from indexOfMethod()
4009 */
4010 void QMetaObject::activate(QObject *sender, int signal_index, void **argv)
4011 {
4012     const QMetaObject *mo = sender->metaObject();
4013     while (mo->methodOffset() > signal_index)
4014         mo = mo->superClass();
4015     activate(sender, mo, signal_index - mo->methodOffset(), argv);
4016 }
4017 
4018 /*!
4019     \internal
4020     Returns the signal index used in the internal connections->receivers vector.
4021 
4022     It is different from QMetaObject::indexOfSignal():  indexOfSignal is the same as indexOfMethod
4023     while QObjectPrivate::signalIndex is smaller because it doesn't give index to slots.
4024 
4025     If \a meta is not \nullptr, it is set to the meta-object where the signal was found.
4026 */
4027 int QObjectPrivate::signalIndex(const char *signalName,
4028                                 const QMetaObject **meta) const
4029 {
4030     Q_Q(const QObject);
4031     const QMetaObject *base = q->metaObject();
4032     Q_ASSERT(QMetaObjectPrivate::get(base)->revision >= 7);
4033     QArgumentTypeArray types;
4034     QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signalName, types);
4035     int relative_index = QMetaObjectPrivate::indexOfSignalRelative(
4036             &base, name, types.size(), types.constData());
4037     if (relative_index < 0)
4038         return relative_index;
4039     relative_index = QMetaObjectPrivate::originalClone(base, relative_index);
4040     if (meta)
4041         *meta = base;
4042     return relative_index + QMetaObjectPrivate::signalOffset(base);
4043 }
4044 
4045 /*****************************************************************************
4046   Properties
4047  *****************************************************************************/
4048 
4049 #ifndef QT_NO_PROPERTIES
4050 
4051 /*!
4052   Sets the value of the object's \a name property to \a value.
4053 
4054   If the property is defined in the class using Q_PROPERTY then
4055   true is returned on success and false otherwise. If the property
4056   is not defined using Q_PROPERTY, and therefore not listed in the
4057   meta-object, it is added as a dynamic property and false is returned.
4058 
4059   Information about all available properties is provided through the
4060   metaObject() and dynamicPropertyNames().
4061 
4062   Dynamic properties can be queried again using property() and can be
4063   removed by setting the property value to an invalid QVariant.
4064   Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent
4065   to be sent to the object.
4066 
4067   \b{Note:} Dynamic properties starting with "_q_" are reserved for internal
4068   purposes.
4069 
4070   \sa property(), metaObject(), dynamicPropertyNames(), QMetaProperty::write()
4071 */
4072 bool QObject::setProperty(const char *name, const QVariant &value)
4073 {
4074     Q_D(QObject);
4075     const QMetaObject *meta = metaObject();
4076     if (!name || !meta)
4077         return false;
4078 
4079     int id = meta->indexOfProperty(name);
4080     if (id < 0) {
4081         if (!d->extraData)
4082             d->extraData = new QObjectPrivate::ExtraData(d);
4083 
4084         const int idx = d->extraData->propertyNames.indexOf(name);
4085 
4086         if (!value.isValid()) {
4087             if (idx == -1)
4088                 return false;
4089             d->extraData->propertyNames.removeAt(idx);
4090             d->extraData->propertyValues.removeAt(idx);
4091         } else {
4092             if (idx == -1) {
4093                 d->extraData->propertyNames.append(name);
4094                 d->extraData->propertyValues.append(value);
4095             } else {
4096                 if (value.userType() == d->extraData->propertyValues.at(idx).userType()
4097                         && value == d->extraData->propertyValues.at(idx))
4098                     return false;
4099                 d->extraData->propertyValues[idx] = value;
4100             }
4101         }
4102 
4103         QDynamicPropertyChangeEvent ev(name);
4104         QCoreApplication::sendEvent(this, &ev);
4105 
4106         return false;
4107     }
4108     QMetaProperty p = meta->property(id);
4109 #ifndef QT_NO_DEBUG
4110     if (!p.isWritable())
4111         qWarning("%s::setProperty: Property \"%s\" invalid,"
4112                  " read-only or does not exist", metaObject()->className(), name);
4113 #endif
4114     return p.write(this, value);
4115 }
4116 
4117 /*!
4118   Returns the value of the object's \a name property.
4119 
4120   If no such property exists, the returned variant is invalid.
4121 
4122   Information about all available properties is provided through the
4123   metaObject() and dynamicPropertyNames().
4124 
4125   \sa setProperty(), QVariant::isValid(), metaObject(), dynamicPropertyNames()
4126 */
4127 QVariant QObject::property(const char *name) const
4128 {
4129     Q_D(const QObject);
4130     const QMetaObject *meta = metaObject();
4131     if (!name || !meta)
4132         return QVariant();
4133 
4134     int id = meta->indexOfProperty(name);
4135     if (id < 0) {
4136         if (!d->extraData)
4137             return QVariant();
4138         const int i = d->extraData->propertyNames.indexOf(name);
4139         return d->extraData->propertyValues.value(i);
4140     }
4141     QMetaProperty p = meta->property(id);
4142 #ifndef QT_NO_DEBUG
4143     if (!p.isReadable())
4144         qWarning("%s::property: Property \"%s\" invalid or does not exist",
4145                  metaObject()->className(), name);
4146 #endif
4147     return p.read(this);
4148 }
4149 
4150 /*!
4151     \since 4.2
4152 
4153     Returns the names of all properties that were dynamically added to
4154     the object using setProperty().
4155 */
4156 QList<QByteArray> QObject::dynamicPropertyNames() const
4157 {
4158     Q_D(const QObject);
4159     if (d->extraData)
4160         return d->extraData->propertyNames;
4161     return QList<QByteArray>();
4162 }
4163 
4164 #endif // QT_NO_PROPERTIES
4165 
4166 
4167 /*****************************************************************************
4168   QObject debugging output routines.
4169  *****************************************************************************/
4170 
4171 static void dumpRecursive(int level, const QObject *object)
4172 {
4173     if (object) {
4174         QByteArray buf;
4175         buf.fill(' ', level / 2 * 8);
4176         if (level % 2)
4177             buf += "    ";
4178         QString name = object->objectName();
4179         QString flags = QLatin1String("");
4180 #if 0
4181         if (qApp->focusWidget() == object)
4182             flags += 'F';
4183         if (object->isWidgetType()) {
4184             QWidget * w = (QWidget *)object;
4185             if (w->isVisible()) {
4186                 QString t("<%1,%2,%3,%4>");
4187                 flags += t.arg(w->x()).arg(w->y()).arg(w->width()).arg(w->height());
4188             } else {
4189                 flags += 'I';
4190             }
4191         }
4192 #endif
4193         qDebug("%s%s::%s %s", (const char*)buf, object->metaObject()->className(), name.toLocal8Bit().data(),
4194                flags.toLatin1().data());
4195         QObjectList children = object->children();
4196         if (!children.isEmpty()) {
4197             for (int i = 0; i < children.size(); ++i)
4198                 dumpRecursive(level+1, children.at(i));
4199         }
4200     }
4201 }
4202 
4203 
4204 /*!
4205     Dumps a tree of children to the debug output.
4206 
4207     \note Before Qt 5.9, this function was not const.
4208 
4209     \sa dumpObjectInfo()
4210 */
4211 
4212 void QObject::dumpObjectTree() const
4213 {
4214     dumpRecursive(0, this);
4215 }
4216 
4217 /*!
4218     Dumps information about signal connections, etc. for this object
4219     to the debug output.
4220 
4221     \note Before Qt 5.9, this function was not const.
4222 
4223     \sa dumpObjectTree()
4224 */
4225 
4226 void QObject::dumpObjectInfo() const
4227 {
4228     qDebug("OBJECT %s::%s", metaObject()->className(),
4229            objectName().isEmpty() ? "unnamed" : objectName().toLocal8Bit().data());
4230 
4231     Q_D(const QObject);
4232     QBasicMutexLocker locker(signalSlotLock(this));
4233 
4234     // first, look for connections where this object is the sender
4235     qDebug("  SIGNALS OUT");
4236 
4237     QObjectPrivate::ConnectionData *cd = d->connections.loadRelaxed();
4238     if (cd && cd->signalVectorCount() > 0) {
4239         QObjectPrivate::SignalVector *signalVector = cd->signalVector.loadRelaxed();
4240         for (int signal_index = 0; signal_index < signalVector->count(); ++signal_index) {
4241             const QObjectPrivate::Connection *c = signalVector->at(signal_index).first.loadRelaxed();
4242             if (!c)
4243                 continue;
4244             const QMetaMethod signal = QMetaObjectPrivate::signal(metaObject(), signal_index);
4245             qDebug("        signal: %s", signal.methodSignature().constData());
4246 
4247             // receivers
4248             while (c) {
4249                 if (!c->receiver.loadRelaxed()) {
4250                     qDebug("          <Disconnected receiver>");
4251                     c = c->nextConnectionList.loadRelaxed();
4252                     continue;
4253                 }
4254                 if (c->isSlotObject) {
4255                     qDebug("          <functor or function pointer>");
4256                     c = c->nextConnectionList.loadRelaxed();
4257                     continue;
4258                 }
4259                 const QMetaObject *receiverMetaObject = c->receiver.loadRelaxed()->metaObject();
4260                 const QMetaMethod method = receiverMetaObject->method(c->method());
4261                 qDebug("          --> %s::%s %s",
4262                        receiverMetaObject->className(),
4263                        c->receiver.loadRelaxed()->objectName().isEmpty() ? "unnamed" : qPrintable(c->receiver.loadRelaxed()->objectName()),
4264                        method.methodSignature().constData());
4265                 c = c->nextConnectionList.loadRelaxed();
4266             }
4267         }
4268     } else {
4269         qDebug( "        <None>" );
4270     }
4271 
4272     // now look for connections where this object is the receiver
4273     qDebug("  SIGNALS IN");
4274 
4275     if (cd && cd->senders) {
4276         for (QObjectPrivate::Connection *s = cd->senders; s; s = s->next) {
4277             QByteArray slotName = QByteArrayLiteral("<unknown>");
4278             if (!s->isSlotObject) {
4279                 const QMetaMethod slot = metaObject()->method(s->method());
4280                 slotName = slot.methodSignature();
4281             }
4282             qDebug("          <-- %s::%s %s",
4283                    s->sender->metaObject()->className(),
4284                    s->sender->objectName().isEmpty() ? "unnamed" : qPrintable(s->sender->objectName()),
4285                    slotName.constData());
4286         }
4287     } else {
4288         qDebug("        <None>");
4289     }
4290 }
4291 
4292 
4293 #ifndef QT_NO_DEBUG_STREAM
4294 QDebug operator<<(QDebug dbg, const QObject *o)
4295 {
4296     QDebugStateSaver saver(dbg);
4297     if (!o)
4298         return dbg << "QObject(0x0)";
4299     dbg.nospace() << o->metaObject()->className() << '(' << (const void *)o;
4300     if (!o->objectName().isEmpty())
4301         dbg << ", name = " << o->objectName();
4302     dbg << ')';
4303     return dbg;
4304 }
4305 #endif
4306 
4307 /*!
4308     \macro Q_CLASSINFO(Name, Value)
4309     \relates QObject
4310 
4311     This macro associates extra information to the class, which is available
4312     using QObject::metaObject(). Qt makes only limited use of this feature in
4313     \l{Qt D-Bus} and \l{Qt QML} modules.
4314 
4315     The extra information takes the form of a \a Name string and a \a Value
4316     literal string.
4317 
4318     Example:
4319 
4320     \snippet code/src_corelib_kernel_qobject.cpp 35
4321 
4322     \sa QMetaObject::classInfo()
4323     \sa {Using Qt D-Bus Adaptors}
4324     \sa {Extending QML}
4325 */
4326 
4327 /*!
4328     \macro Q_INTERFACES(...)
4329     \relates QObject
4330 
4331     This macro tells Qt which interfaces the class implements. This
4332     is used when implementing plugins.
4333 
4334     Example:
4335 
4336     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 1
4337     \dots
4338     \snippet ../widgets/tools/plugandpaint/plugins/basictools/basictoolsplugin.h 3
4339 
4340     See the \l{tools/plugandpaint/plugins/basictools}{Plug & Paint
4341     Basic Tools} example for details.
4342 
4343     \sa Q_DECLARE_INTERFACE(), Q_PLUGIN_METADATA(), {How to Create Qt Plugins}
4344 */
4345 
4346 /*!
4347     \macro Q_PROPERTY(...)
4348     \relates QObject
4349 
4350     This macro is used for declaring properties in classes that
4351     inherit QObject. Properties behave like class data members, but
4352     they have additional features accessible through the \l
4353     {Meta-Object System}.
4354 
4355     \snippet code/doc_src_properties.cpp 0
4356 
4357     The property name and type and the \c READ function are required.
4358     The type can be any type supported by QVariant, or it can be a
4359     user-defined type.  The other items are optional, but a \c WRITE
4360     function is common.  The attributes default to true except \c USER,
4361     which defaults to false.
4362 
4363     For example:
4364 
4365     \snippet code/src_corelib_kernel_qobject.cpp 37
4366 
4367     For more details about how to use this macro, and a more detailed
4368     example of its use, see the discussion on \l {Qt's Property System}.
4369 
4370     \sa {Qt's Property System}
4371 */
4372 
4373 /*!
4374     \macro Q_ENUMS(...)
4375     \relates QObject
4376     \deprecated
4377 
4378     In new code, you should prefer the use of the Q_ENUM() macro, which makes the
4379     type available also to the meta type system.
4380     For instance, QMetaEnum::fromType() will not work with types declared with Q_ENUMS().
4381 
4382     This macro registers one or several enum types to the meta-object
4383     system.
4384 
4385     If you want to register an enum that is declared in another class,
4386     the enum must be fully qualified with the name of the class
4387     defining it. In addition, the class \e defining the enum has to
4388     inherit QObject as well as declare the enum using Q_ENUMS().
4389 
4390     \sa {Qt's Property System}
4391 */
4392 
4393 /*!
4394     \macro Q_FLAGS(...)
4395     \relates QObject
4396     \deprecated
4397 
4398     This macro registers one or several \l{QFlags}{flags types} with the
4399     meta-object system. It is typically used in a class definition to declare
4400     that values of a given enum can be used as flags and combined using the
4401     bitwise OR operator.
4402 
4403     \note This macro takes care of registering individual flag values
4404     with the meta-object system, so it is unnecessary to use Q_ENUMS()
4405     in addition to this macro.
4406 
4407     In new code, you should prefer the use of the Q_FLAG() macro, which makes the
4408     type available also to the meta type system.
4409 
4410     \sa {Qt's Property System}
4411 */
4412 
4413 /*!
4414     \macro Q_ENUM(...)
4415     \relates QObject
4416     \since 5.5
4417 
4418     This macro registers an enum type with the meta-object system.
4419     It must be placed after the enum declaration in a class that has the Q_OBJECT,
4420     Q_GADGET or Q_GADGET_EXPORT macro. For namespaces use \l Q_ENUM_NS() instead.
4421 
4422     For example:
4423 
4424     \snippet code/src_corelib_kernel_qobject.cpp 38
4425 
4426     Enumerations that are declared with Q_ENUM have their QMetaEnum registered in the
4427     enclosing QMetaObject. You can also use QMetaEnum::fromType() to get the QMetaEnum.
4428 
4429     Registered enumerations are automatically registered also to the Qt meta
4430     type system, making them known to QMetaType without the need to use
4431     Q_DECLARE_METATYPE(). This will enable useful features; for example, if used
4432     in a QVariant, you can convert them to strings. Likewise, passing them to
4433     QDebug will print out their names.
4434 
4435     Mind that the enum values are stored as signed \c int in the meta object system.
4436     Registering enumerations with values outside the range of values valid for \c int
4437     will lead to overflows and potentially undefined behavior when accessing them through
4438     the meta object system. QML, for example, does access registered enumerations through
4439     the meta object system.
4440 
4441     \sa {Qt's Property System}
4442 */
4443 
4444 
4445 /*!
4446     \macro Q_FLAG(...)
4447     \relates QObject
4448     \since 5.5
4449 
4450     This macro registers a single \l{QFlags}{flags type} with the
4451     meta-object system. It is typically used in a class definition to declare
4452     that values of a given enum can be used as flags and combined using the
4453     bitwise OR operator. For namespaces use \l Q_FLAG_NS() instead.
4454 
4455     The macro must be placed after the enum declaration. The declaration of
4456     the flags type is done using the \l Q_DECLARE_FLAGS() macro.
4457 
4458     For example, in QItemSelectionModel, the
4459     \l{QItemSelectionModel::SelectionFlags}{SelectionFlags} flag is
4460     declared in the following way:
4461 
4462     \snippet code/src_corelib_kernel_qobject.cpp 39
4463 
4464     \note The Q_FLAG macro takes care of registering individual flag values
4465     with the meta-object system, so it is unnecessary to use Q_ENUM()
4466     in addition to this macro.
4467 
4468     \sa {Qt's Property System}
4469 */
4470 
4471 /*!
4472     \macro Q_ENUM_NS(...)
4473     \relates QObject
4474     \since 5.8
4475 
4476     This macro registers an enum type with the meta-object system.
4477     It must be placed after the enum declaration in a namespace that
4478     has the Q_NAMESPACE macro. It is the same as \l Q_ENUM but in a
4479     namespace.
4480 
4481     Enumerations that are declared with Q_ENUM_NS have their QMetaEnum
4482     registered in the enclosing QMetaObject. You can also use
4483     QMetaEnum::fromType() to get the QMetaEnum.
4484 
4485     Registered enumerations are automatically registered also to the Qt meta
4486     type system, making them known to QMetaType without the need to use
4487     Q_DECLARE_METATYPE(). This will enable useful features; for example, if
4488     used in a QVariant, you can convert them to strings. Likewise, passing them
4489     to QDebug will print out their names.
4490 
4491     Mind that the enum values are stored as signed \c int in the meta object system.
4492     Registering enumerations with values outside the range of values valid for \c int
4493     will lead to overflows and potentially undefined behavior when accessing them through
4494     the meta object system. QML, for example, does access registered enumerations through
4495     the meta object system.
4496 
4497     \sa {Qt's Property System}
4498 */
4499 
4500 
4501 /*!
4502     \macro Q_FLAG_NS(...)
4503     \relates QObject
4504     \since 5.8
4505 
4506     This macro registers a single \l{QFlags}{flags type} with the
4507     meta-object system. It is used in a namespace that has the
4508     Q_NAMESPACE macro, to declare that values of a given enum can be
4509     used as flags and combined using the bitwise OR operator.
4510     It is the same as \l Q_FLAG but in a namespace.
4511 
4512     The macro must be placed after the enum declaration.
4513 
4514     \note The Q_FLAG_NS macro takes care of registering individual flag
4515     values with the meta-object system, so it is unnecessary to use
4516     Q_ENUM_NS() in addition to this macro.
4517 
4518     \sa {Qt's Property System}
4519 */
4520 
4521 
4522 /*!
4523     \macro Q_OBJECT
4524     \relates QObject
4525 
4526     The Q_OBJECT macro must appear in the private section of a class
4527     definition that declares its own signals and slots or that uses
4528     other services provided by Qt's meta-object system.
4529 
4530     For example:
4531 
4532     \snippet signalsandslots/signalsandslots.h 1
4533     \codeline
4534     \snippet signalsandslots/signalsandslots.h 2
4535     \snippet signalsandslots/signalsandslots.h 3
4536 
4537     \note This macro requires the class to be a subclass of QObject. Use
4538     Q_GADGET or Q_GADGET_EXPORT instead of Q_OBJECT to enable the meta object system's support
4539     for enums in a class that is not a QObject subclass.
4540 
4541     \sa {Meta-Object System}, {Signals and Slots}, {Qt's Property System}
4542 */
4543 
4544 /*!
4545     \macro Q_GADGET
4546     \relates QObject
4547 
4548     The Q_GADGET macro is a lighter version of the Q_OBJECT macro for classes
4549     that do not inherit from QObject but still want to use some of the
4550     reflection capabilities offered by QMetaObject. Just like the Q_OBJECT
4551     macro, it must appear in the private section of a class definition.
4552 
4553     Q_GADGETs can have Q_ENUM, Q_PROPERTY and Q_INVOKABLE, but they cannot have
4554     signals or slots.
4555 
4556     Q_GADGET makes a class member, \c{staticMetaObject}, available.
4557     \c{staticMetaObject} is of type QMetaObject and provides access to the
4558     enums declared with Q_ENUMS.
4559 
4560     \sa Q_GADGET_EXPORT
4561 */
4562 
4563 /*!
4564     \macro Q_GADGET_EXPORT(EXPORT_MACRO)
4565     \relates QObject
4566     \since 6.3
4567 
4568     The Q_GADGET_EXPORT macro works exactly like the Q_GADGET macro.
4569     However, the \c{staticMetaObject} variable that is made available (see
4570     Q_GADGET) is declared with the supplied \a EXPORT_MACRO qualifier. This is
4571     useful if the object needs to be exported from a dynamic library, but the
4572     enclosing class as a whole should not be (e.g. because it consists of mostly
4573     inline functions).
4574 
4575     For example:
4576 
4577     \code
4578     class Point {
4579         Q_GADGET_EXPORT(EXPORT_MACRO)
4580         Q_PROPERTY(int x MEMBER x)
4581         Q_PROPERTY(int y MEMBER y)
4582         ~~~
4583     \endcode
4584 
4585     \sa Q_GADGET, {Creating Shared Libraries}
4586 */
4587 
4588 /*!
4589     \macro Q_NAMESPACE
4590     \relates QObject
4591     \since 5.8
4592 
4593     The Q_NAMESPACE macro can be used to add QMetaObject capabilities
4594     to a namespace.
4595 
4596     Q_NAMESPACEs can have Q_CLASSINFO, Q_ENUM_NS, Q_FLAG_NS, but they
4597     cannot have Q_ENUM, Q_FLAG, Q_PROPERTY, Q_INVOKABLE, signals nor slots.
4598 
4599     Q_NAMESPACE makes an external variable, \c{staticMetaObject}, available.
4600     \c{staticMetaObject} is of type QMetaObject and provides access to the
4601     enums declared with Q_ENUM_NS/Q_FLAG_NS.
4602 
4603     For example:
4604 
4605     \code
4606     namespace test {
4607     Q_NAMESPACE
4608     ...
4609     \endcode
4610 
4611     \sa Q_NAMESPACE_EXPORT
4612 */
4613 
4614 /*!
4615     \macro Q_NAMESPACE_EXPORT(EXPORT_MACRO)
4616     \relates QObject
4617     \since 5.14
4618 
4619     The Q_NAMESPACE_EXPORT macro can be used to add QMetaObject capabilities
4620     to a namespace.
4621 
4622     It works exactly like the Q_NAMESPACE macro. However, the external
4623     \c{staticMetaObject} variable that gets defined in the namespace
4624     is declared with the supplied \a EXPORT_MACRO qualifier. This is
4625     useful if the object needs to be exported from a dynamic library.
4626 
4627     For example:
4628 
4629     \code
4630     namespace test {
4631     Q_NAMESPACE_EXPORT(EXPORT_MACRO)
4632     ...
4633     \endcode
4634 
4635     \sa Q_NAMESPACE, {Creating Shared Libraries}
4636 */
4637 
4638 /*!
4639     \macro Q_MOC_INCLUDE
4640     \relates QObject
4641     \since 6.0
4642 
4643     The Q_MOC_INCLUDE macro can be used within or outside a class, and tell the
4644     \l{moc}{Meta Object Compiler} to add an include.
4645 
4646     \code
4647         // Put this in your code and the generated code will include this header.
4648         Q_MOC_INCLUDE("myheader.h")
4649     \endcode
4650 
4651     This is useful if the types you use as properties or signal/slots arguments
4652     are forward declared.
4653 */
4654 
4655 /*!
4656     \macro Q_SIGNALS
4657     \relates QObject
4658 
4659     Use this macro to replace the \c signals keyword in class
4660     declarations, when you want to use Qt Signals and Slots with a
4661     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4662 
4663     The macro is normally used when \c no_keywords is specified with
4664     the \c CONFIG variable in the \c .pro file, but it can be used
4665     even when \c no_keywords is \e not specified.
4666 */
4667 
4668 /*!
4669     \macro Q_SIGNAL
4670     \relates QObject
4671 
4672     This is an additional macro that allows you to mark a single
4673     function as a signal. It can be quite useful, especially when you
4674     use a 3rd-party source code parser which doesn't understand a \c
4675     signals or \c Q_SIGNALS groups.
4676 
4677     Use this macro to replace the \c signals keyword in class
4678     declarations, when you want to use Qt Signals and Slots with a
4679     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4680 
4681     The macro is normally used when \c no_keywords is specified with
4682     the \c CONFIG variable in the \c .pro file, but it can be used
4683     even when \c no_keywords is \e not specified.
4684 */
4685 
4686 /*!
4687     \macro Q_SLOTS
4688     \relates QObject
4689 
4690     Use this macro to replace the \c slots keyword in class
4691     declarations, when you want to use Qt Signals and Slots with a
4692     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4693 
4694     The macro is normally used when \c no_keywords is specified with
4695     the \c CONFIG variable in the \c .pro file, but it can be used
4696     even when \c no_keywords is \e not specified.
4697 */
4698 
4699 /*!
4700     \macro Q_SLOT
4701     \relates QObject
4702 
4703     This is an additional macro that allows you to mark a single
4704     function as a slot. It can be quite useful, especially when you
4705     use a 3rd-party source code parser which doesn't understand a \c
4706     slots or \c Q_SLOTS groups.
4707 
4708     Use this macro to replace the \c slots keyword in class
4709     declarations, when you want to use Qt Signals and Slots with a
4710     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4711 
4712     The macro is normally used when \c no_keywords is specified with
4713     the \c CONFIG variable in the \c .pro file, but it can be used
4714     even when \c no_keywords is \e not specified.
4715 */
4716 
4717 /*!
4718     \macro Q_EMIT
4719     \relates QObject
4720 
4721     Use this macro to replace the \c emit keyword for emitting
4722     signals, when you want to use Qt Signals and Slots with a
4723     \l{3rd Party Signals and Slots} {3rd party signal/slot mechanism}.
4724 
4725     The macro is normally used when \c no_keywords is specified with
4726     the \c CONFIG variable in the \c .pro file, but it can be used
4727     even when \c no_keywords is \e not specified.
4728 */
4729 
4730 /*!
4731     \macro Q_INVOKABLE
4732     \relates QObject
4733 
4734     Apply this macro to declarations of member functions to allow them to
4735     be invoked via the meta-object system. The macro is written before
4736     the return type, as shown in the following example:
4737 
4738     \snippet qmetaobject-invokable/window.h Window class with invokable method
4739 
4740     The \c invokableMethod() function is marked up using Q_INVOKABLE, causing
4741     it to be registered with the meta-object system and enabling it to be
4742     invoked using QMetaObject::invokeMethod().
4743     Since \c normalMethod() function is not registered in this way, it cannot
4744     be invoked using QMetaObject::invokeMethod().
4745 
4746     If an invokable member function returns a pointer to a QObject or a
4747     subclass of QObject and it is invoked from QML, special ownership rules
4748     apply. See \l{qtqml-cppintegration-data.html}{Data Type Conversion Between QML and C++}
4749     for more information.
4750 */
4751 
4752 /*!
4753     \macro Q_REVISION
4754     \relates QObject
4755 
4756     Apply this macro to declarations of member functions to tag them with a
4757     revision number in the meta-object system. The macro is written before
4758     the return type, as shown in the following example:
4759 
4760     \snippet qmetaobject-revision/window.h Window class with revision
4761 
4762     This is useful when using the meta-object system to dynamically expose
4763     objects to another API, as you can match the version expected by multiple
4764     versions of the other API. Consider the following simplified example:
4765 
4766     \snippet qmetaobject-revision/main.cpp Window class using revision
4767 
4768     Using the same Window class as the previous example, the newProperty and
4769     newMethod would only be exposed in this code when the expected version is
4770     \c{2.1} or greater.
4771 
4772     Since all methods are considered to be in revision \c{0} if untagged, a tag
4773     of \c{Q_REVISION(0)} or \c{Q_REVISION(0, 0)} is invalid and ignored.
4774 
4775     You can pass one or two integer parameters to \c{Q_REVISION}. If you pass
4776     one parameter, it denotes the minor version only. This means that the major
4777     version is unspecified. If you pass two, the first parameter is the major
4778     version and the second parameter is the minor version.
4779 
4780     This tag is not used by the meta-object system itself. Currently this is only
4781     used by the QtQml module.
4782 
4783     For a more generic string tag, see \l QMetaMethod::tag()
4784 
4785     \sa QMetaMethod::revision()
4786 */
4787 
4788 /*!
4789     \macro Q_SET_OBJECT_NAME(Object)
4790     \relates QObject
4791     \since 5.0
4792 
4793     This macro assigns \a Object the objectName "Object".
4794 
4795     It doesn't matter whether \a Object is a pointer or not, the
4796     macro figures that out by itself.
4797 
4798     \sa QObject::objectName()
4799 */
4800 
4801 /*!
4802     \macro QT_NO_NARROWING_CONVERSIONS_IN_CONNECT
4803     \relates QObject
4804     \since 5.8
4805 
4806     Defining this macro will disable narrowing and floating-point-to-integral
4807     conversions between the arguments carried by a signal and the arguments
4808     accepted by a slot, when the signal and the slot are connected using the
4809     PMF-based syntax.
4810 
4811     \sa QObject::connect
4812 */
4813 
4814 /*!
4815     \typedef QObjectList
4816     \relates QObject
4817 
4818     Synonym for QList<QObject *>.
4819 */
4820 
4821 void qDeleteInEventHandler(QObject *o)
4822 {
4823     delete o;
4824 }
4825 
4826 /*!
4827     \fn template<typename PointerToMemberFunction> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type)
4828     \overload connect()
4829     \threadsafe
4830 
4831     Creates a connection of the given \a type from the \a signal in
4832     the \a sender object to the \a method in the \a receiver object.
4833     Returns a handle to the connection that can be used to disconnect
4834     it later.
4835 
4836     The signal must be a function declared as a signal in the header.
4837     The slot function can be any member function that can be connected
4838     to the signal.
4839     A slot can be connected to a given signal if the signal has at
4840     least as many arguments as the slot, and there is an implicit
4841     conversion between the types of the corresponding arguments in the
4842     signal and the slot.
4843 
4844     Example:
4845 
4846     \snippet code/src_corelib_kernel_qobject.cpp 44
4847 
4848     This example ensures that the label always displays the current
4849     line edit text.
4850 
4851     A signal can be connected to many slots and signals. Many signals
4852     can be connected to one slot.
4853 
4854     If a signal is connected to several slots, the slots are activated
4855     in the same order as the order the connection was made, when the
4856     signal is emitted
4857 
4858     The function returns an handle to a connection if it successfully
4859     connects the signal to the slot. The Connection handle will be invalid
4860     if it cannot create the connection, for example, if QObject is unable
4861     to verify the existence of \a signal (if it was not declared as a signal)
4862     You can check if the QMetaObject::Connection is valid by casting it to a bool.
4863 
4864     By default, a signal is emitted for every connection you make;
4865     two signals are emitted for duplicate connections. You can break
4866     all of these connections with a single disconnect() call.
4867     If you pass the Qt::UniqueConnection \a type, the connection will only
4868     be made if it is not a duplicate. If there is already a duplicate
4869     (exact same signal to the exact same slot on the same objects),
4870     the connection will fail and connect will return an invalid QMetaObject::Connection.
4871 
4872     The optional \a type parameter describes the type of connection
4873     to establish. In particular, it determines whether a particular
4874     signal is delivered to a slot immediately or queued for delivery
4875     at a later time. If the signal is queued, the parameters must be
4876     of types that are known to Qt's meta-object system, because Qt
4877     needs to copy the arguments to store them in an event behind the
4878     scenes. If you try to use a queued connection and get the error
4879     message
4880 
4881     \snippet code/src_corelib_kernel_qobject.cpp 25
4882 
4883     make sure to declare the argument type with Q_DECLARE_METATYPE
4884 
4885     Overloaded functions can be resolved with help of \l qOverload.
4886 
4887     \sa {Differences between String-Based and Functor-Based Connections}
4888  */
4889 
4890 /*!
4891     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, Functor functor)
4892 
4893     \threadsafe
4894     \overload connect()
4895 
4896     Creates a connection from \a signal in
4897     \a sender object to \a functor, and returns a handle to the connection
4898 
4899     The signal must be a function declared as a signal in the header.
4900     The slot function can be any function or functor that can be connected
4901     to the signal.
4902     A slot function can be connected to a given signal if the signal has at
4903     least as many arguments as the slot function. There must exist implicit
4904     conversion between the types of the corresponding arguments in the
4905     signal and the slot.
4906 
4907     Example:
4908 
4909     \snippet code/src_corelib_kernel_qobject.cpp 45
4910 
4911     Lambda expressions can also be used:
4912 
4913     \snippet code/src_corelib_kernel_qobject.cpp 46
4914 
4915     The connection will automatically disconnect if the sender is destroyed.
4916     However, you should take care that any objects used within the functor
4917     are still alive when the signal is emitted.
4918 
4919     Overloaded functions can be resolved with help of \l qOverload.
4920 
4921  */
4922 
4923 /*!
4924     \fn template<typename PointerToMemberFunction, typename Functor> QMetaObject::Connection QObject::connect(const QObject *sender, PointerToMemberFunction signal, const QObject *context, Functor functor, Qt::ConnectionType type)
4925 
4926     \threadsafe
4927     \overload connect()
4928 
4929     \since 5.2
4930 
4931     Creates a connection of a given \a type from \a signal in
4932     \a sender object to \a functor to be placed in a specific event
4933     loop of \a context, and returns a handle to the connection.
4934 
4935     \note Qt::UniqueConnections do not work for lambdas, non-member functions
4936     and functors; they only apply to connecting to member functions.
4937 
4938     The signal must be a function declared as a signal in the header.
4939     The slot function can be any function or functor that can be connected
4940     to the signal.
4941     A slot function can be connected to a given signal if the signal has at
4942     least as many arguments as the slot function. There must exist implicit
4943     conversion between the types of the corresponding arguments in the
4944     signal and the slot.
4945 
4946     Example:
4947 
4948     \snippet code/src_corelib_kernel_qobject.cpp 50
4949 
4950     Lambda expressions can also be used:
4951 
4952     \snippet code/src_corelib_kernel_qobject.cpp 51
4953 
4954     The connection will automatically disconnect if the sender or the context
4955     is destroyed.
4956     However, you should take care that any objects used within the functor
4957     are still alive when the signal is emitted.
4958 
4959     Overloaded functions can be resolved with help of \l qOverload.
4960  */
4961 
4962 /*!
4963     \internal
4964 
4965     Implementation of the template version of connect
4966 
4967     \a sender is the sender object
4968     \a signal is a pointer to a pointer to a member signal of the sender
4969     \a receiver is the receiver object, may not be \nullptr, will be equal to sender when
4970                 connecting to a static function or a functor
4971     \a slot a pointer only used when using Qt::UniqueConnection
4972     \a type the Qt::ConnectionType passed as argument to connect
4973     \a types an array of integer with the metatype id of the parameter of the signal
4974              to be used with queued connection
4975              must stay valid at least for the whole time of the connection, this function
4976              do not take ownership. typically static data.
4977              If \nullptr, then the types will be computed when the signal is emit in a queued
4978              connection from the types from the signature.
4979     \a senderMetaObject is the metaobject used to lookup the signal, the signal must be in
4980                         this metaobject
4981  */
4982 QMetaObject::Connection QObject::connectImpl(const QObject *sender, void **signal,
4983                                              const QObject *receiver, void **slot,
4984                                              QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type,
4985                                              const int *types, const QMetaObject *senderMetaObject)
4986 {
4987     if (!signal) {
4988         qCWarning(lcConnect, "QObject::connect: invalid nullptr parameter");
4989         if (slotObj)
4990             slotObj->destroyIfLastRef();
4991         return QMetaObject::Connection();
4992     }
4993 
4994     int signal_index = -1;
4995     void *args[] = { &signal_index, signal };
4996     for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
4997         senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
4998         if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
4999             break;
5000     }
5001     if (!senderMetaObject) {
5002         qCWarning(lcConnect, "QObject::connect: signal not found in %s", sender->metaObject()->className());
5003         slotObj->destroyIfLastRef();
5004         return QMetaObject::Connection(nullptr);
5005     }
5006     signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
5007     return QObjectPrivate::connectImpl(sender, signal_index, receiver, slot, slotObj, type, types, senderMetaObject);
5008 }
5009 
5010 static void connectWarning(const QObject *sender,
5011                            const QMetaObject *senderMetaObject,
5012                            const QObject *receiver,
5013                            const char *message)
5014 {
5015     const char *senderString = sender ? sender->metaObject()->className()
5016                                       : senderMetaObject ? senderMetaObject->className()
5017                                       : "Unknown";
5018     const char *receiverString = receiver ? receiver->metaObject()->className()
5019                                           : "Unknown";
5020     qCWarning(lcConnect, "QObject::connect(%s, %s): %s", senderString, receiverString, message);
5021 }
5022 
5023 /*!
5024     \internal
5025 
5026     Internal version of connect used by the template version of QObject::connect (called via connectImpl) and
5027     also used by the QObjectPrivate::connect version used by QML. The signal_index is expected to be relative
5028     to the number of signals.
5029  */
5030 QMetaObject::Connection QObjectPrivate::connectImpl(const QObject *sender, int signal_index,
5031                                              const QObject *receiver, void **slot,
5032                                              QtPrivate::QSlotObjectBase *slotObj, int type,
5033                                              const int *types, const QMetaObject *senderMetaObject)
5034 {
5035     auto connectFailureGuard = qScopeGuard([&]()
5036     {
5037         if (slotObj)
5038             slotObj->destroyIfLastRef();
5039     });
5040 
5041     if (!sender || !receiver || !slotObj || !senderMetaObject) {
5042         connectWarning(sender, senderMetaObject, receiver, "invalid nullptr parameter");
5043         return QMetaObject::Connection();
5044     }
5045 
5046     if (type & Qt::UniqueConnection && !slot) {
5047         connectWarning(sender, senderMetaObject, receiver, "unique connections require a pointer to member function of a QObject subclass");
5048         return QMetaObject::Connection();
5049     }
5050 
5051     connectFailureGuard.dismiss();
5052 
5053     QObject *s = const_cast<QObject *>(sender);
5054     QObject *r = const_cast<QObject *>(receiver);
5055 
5056     QOrderedMutexLocker locker(signalSlotLock(sender),
5057                                signalSlotLock(receiver));
5058 
5059     if (type & Qt::UniqueConnection && slot && QObjectPrivate::get(s)->connections.loadRelaxed()) {
5060         QObjectPrivate::ConnectionData *connections = QObjectPrivate::get(s)->connections.loadRelaxed();
5061         if (connections->signalVectorCount() > signal_index) {
5062             const QObjectPrivate::Connection *c2 = connections->signalVector.loadRelaxed()->at(signal_index).first.loadRelaxed();
5063 
5064             while (c2) {
5065                 if (c2->receiver.loadRelaxed() == receiver && c2->isSlotObject && c2->slotObj->compare(slot)) {
5066                     slotObj->destroyIfLastRef();
5067                     return QMetaObject::Connection();
5068                 }
5069                 c2 = c2->nextConnectionList.loadRelaxed();
5070             }
5071         }
5072     }
5073     type &= ~Qt::UniqueConnection;
5074 
5075     const bool isSingleShot = type & Qt::SingleShotConnection;
5076     type &= ~Qt::SingleShotConnection;
5077 
5078     Q_ASSERT(type >= 0);
5079     Q_ASSERT(type <= 3);
5080 
5081     std::unique_ptr<QObjectPrivate::Connection> c{new QObjectPrivate::Connection};
5082     c->sender = s;
5083     c->signal_index = signal_index;
5084     QThreadData *td = r->d_func()->threadData;
5085     td->ref();
5086     c->receiverThreadData.storeRelaxed(td);
5087     c->receiver.storeRelaxed(r);
5088     c->slotObj = slotObj;
5089     c->connectionType = type;
5090     c->isSlotObject = true;
5091     if (types) {
5092         c->argumentTypes.storeRelaxed(types);
5093         c->ownArgumentTypes = false;
5094     }
5095     c->isSingleShot = isSingleShot;
5096 
5097     QObjectPrivate::get(s)->addConnection(signal_index, c.get());
5098     QMetaObject::Connection ret(c.release());
5099     locker.unlock();
5100 
5101     QMetaMethod method = QMetaObjectPrivate::signal(senderMetaObject, signal_index);
5102     Q_ASSERT(method.isValid());
5103     s->connectNotify(method);
5104 
5105     return ret;
5106 }
5107 
5108 /*!
5109     Disconnect a connection.
5110 
5111     If the \a connection is invalid or has already been disconnected, do nothing
5112     and return false.
5113 
5114    \sa connect()
5115  */
5116 bool QObject::disconnect(const QMetaObject::Connection &connection)
5117 {
5118     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(connection.d_ptr);
5119     if (!c)
5120         return false;
5121     const bool disconnected = QObjectPrivate::disconnect(c);
5122     const_cast<QMetaObject::Connection &>(connection).d_ptr = nullptr;
5123     c->deref(); // has been removed from the QMetaObject::Connection object
5124     return disconnected;
5125 }
5126 
5127 /*! \fn template<typename PointerToMemberFunction> bool QObject::disconnect(const QObject *sender, PointerToMemberFunction signal, const QObject *receiver, PointerToMemberFunction method)
5128     \overload disconnect()
5129     \threadsafe
5130 
5131     Disconnects \a signal in object \a sender from \a method in object
5132     \a receiver. Returns \c true if the connection is successfully broken;
5133     otherwise returns \c false.
5134 
5135     A signal-slot connection is removed when either of the objects
5136     involved are destroyed.
5137 
5138     disconnect() is typically used in three ways, as the following
5139     examples demonstrate.
5140     \list 1
5141     \li Disconnect everything connected to an object's signals:
5142 
5143        \snippet code/src_corelib_kernel_qobject.cpp 26
5144 
5145     \li Disconnect everything connected to a specific signal:
5146 
5147        \snippet code/src_corelib_kernel_qobject.cpp 47
5148 
5149     \li Disconnect a specific receiver:
5150 
5151        \snippet code/src_corelib_kernel_qobject.cpp 30
5152 
5153     \li Disconnect a connection from one specific signal to a specific slot:
5154 
5155        \snippet code/src_corelib_kernel_qobject.cpp 48
5156 
5157 
5158     \endlist
5159 
5160     \nullptr may be used as a wildcard, meaning "any signal", "any receiving
5161     object", or "any slot in the receiving object", respectively.
5162 
5163     The \a sender may never be \nullptr. (You cannot disconnect signals
5164     from more than one object in a single call.)
5165 
5166     If \a signal is \nullptr, it disconnects \a receiver and \a method from
5167     any signal. If not, only the specified signal is disconnected.
5168 
5169     If \a receiver is \nullptr, it disconnects anything connected to \a
5170     signal. If not, only slots in the specified receiver are disconnected.
5171     disconnect() with a non-null \a receiver also disconnects slot functions
5172     that were connected with \a receiver as their context object.
5173 
5174     If \a method is \nullptr, it disconnects anything that is connected to \a
5175     receiver. If not, only slots named \a method will be disconnected,
5176     and all other slots are left alone. The \a method must be \nullptr
5177     if \a receiver is left out, so you cannot disconnect a
5178     specifically-named slot on all objects.
5179 
5180     \note It is not possible to use this overload to disconnect signals
5181     connected to functors or lambda expressions. That is because it is not
5182     possible to compare them. Instead, use the overload that takes a
5183     QMetaObject::Connection
5184 
5185     \sa connect()
5186 */
5187 
5188 bool QObject::disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot, const QMetaObject *senderMetaObject)
5189 {
5190     if (sender == nullptr || (receiver == nullptr && slot != nullptr)) {
5191         qCWarning(lcConnect, "QObject::disconnect: Unexpected nullptr parameter");
5192         return false;
5193     }
5194 
5195     int signal_index = -1;
5196     if (signal) {
5197         void *args[] = { &signal_index, signal };
5198         for (; senderMetaObject && signal_index < 0; senderMetaObject = senderMetaObject->superClass()) {
5199             senderMetaObject->static_metacall(QMetaObject::IndexOfMethod, 0, args);
5200             if (signal_index >= 0 && signal_index < QMetaObjectPrivate::get(senderMetaObject)->signalCount)
5201                 break;
5202         }
5203         if (!senderMetaObject) {
5204             qCWarning(lcConnect, "QObject::disconnect: signal not found in %s", sender->metaObject()->className());
5205             return false;
5206         }
5207         signal_index += QMetaObjectPrivate::signalOffset(senderMetaObject);
5208     }
5209 
5210     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, receiver, -1, slot);
5211 }
5212 
5213 /*!
5214  \internal
5215  Used by QML to connect a signal by index to a slot implemented in JavaScript
5216  (wrapped in a custom QSlotObjectBase subclass).
5217 
5218  This version of connect assumes that sender and receiver are the same object.
5219 
5220  The signal_index is an index relative to the number of methods.
5221  */
5222 QMetaObject::Connection QObjectPrivate::connect(const QObject *sender, int signal_index, QtPrivate::QSlotObjectBase *slotObj, Qt::ConnectionType type)
5223 {
5224     return QObjectPrivate::connect(sender, signal_index, sender, slotObj, type);
5225 }
5226 
5227 /*!
5228  \internal
5229  Used by QML to connect a signal by index to a slot implemented in JavaScript
5230  (wrapped in a custom QSlotObjectBase subclass).
5231 
5232  This is an overload that should be used when \a sender and \a receiver are
5233  different objects.
5234 
5235  The signal_index is an index relative to the number of methods.
5236  */
5237 QMetaObject::Connection QObjectPrivate::connect(const QObject *sender, int signal_index,
5238                                                 const QObject *receiver,
5239                                                 QtPrivate::QSlotObjectBase *slotObj,
5240                                                 Qt::ConnectionType type)
5241 {
5242     if (!sender) {
5243         qCWarning(lcConnect, "QObject::connect: invalid nullptr parameter");
5244         if (slotObj)
5245             slotObj->destroyIfLastRef();
5246         return QMetaObject::Connection();
5247     }
5248     const QMetaObject *senderMetaObject = sender->metaObject();
5249     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
5250 
5251     return QObjectPrivate::connectImpl(sender, signal_index, receiver, /*slot*/ nullptr, slotObj,
5252                                        type, /*types*/ nullptr, senderMetaObject);
5253 }
5254 
5255 /*!
5256  \internal
5257  Used by QML to disconnect a signal by index that's connected to a slot implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass)
5258  In the QML case the slot is not a pointer to a pointer to the function to disconnect, but instead it is a pointer to an array of internal values
5259  required for the disconnect.
5260 
5261  This version of disconnect assumes that sender and receiver are the same object.
5262  */
5263 bool QObjectPrivate::disconnect(const QObject *sender, int signal_index, void **slot)
5264 {
5265     return QObjectPrivate::disconnect(sender, signal_index, sender, slot);
5266 }
5267 
5268 /*!
5269  \internal
5270 
5271  Used by QML to disconnect a signal by index that's connected to a slot
5272  implemented in JavaScript (wrapped in a custom QSlotObjectBase subclass) In the
5273  QML case the slot is not a pointer to a pointer to the function to disconnect,
5274  but instead it is a pointer to an array of internal values required for the
5275  disconnect.
5276 
5277  This is an overload that should be used when \a sender and \a receiver are
5278  different objects.
5279  */
5280 bool QObjectPrivate::disconnect(const QObject *sender, int signal_index, const QObject *receiver,
5281                                 void **slot)
5282 {
5283     const QMetaObject *senderMetaObject = sender->metaObject();
5284     signal_index = methodIndexToSignalIndex(&senderMetaObject, signal_index);
5285 
5286     return QMetaObjectPrivate::disconnect(sender, signal_index, senderMetaObject, receiver, -1,
5287                                           slot);
5288 }
5289 
5290 /*!
5291     \internal
5292     \threadsafe
5293 */
5294 bool QObjectPrivate::disconnect(QObjectPrivate::Connection *c)
5295 {
5296     if (!c)
5297         return false;
5298     QObject *receiver = c->receiver.loadRelaxed();
5299     if (!receiver)
5300         return false;
5301 
5302     QBasicMutex *senderMutex = signalSlotLock(c->sender);
5303     QBasicMutex *receiverMutex = signalSlotLock(receiver);
5304 
5305     QObjectPrivate::ConnectionData *connections;
5306     {
5307         QOrderedMutexLocker locker(senderMutex, receiverMutex);
5308 
5309         // load receiver once again and recheck to ensure nobody else has removed the connection in the meantime
5310         receiver = c->receiver.loadRelaxed();
5311         if (!receiver)
5312             return false;
5313 
5314         connections = QObjectPrivate::get(c->sender)->connections.loadRelaxed();
5315         Q_ASSERT(connections);
5316         connections->removeConnection(c);
5317 
5318         c->sender->disconnectNotify(QMetaObjectPrivate::signal(c->sender->metaObject(), c->signal_index));
5319         // We must not hold the receiver mutex, else we risk dead-locking; we also only need the sender mutex
5320         // It is however vital to hold the senderMutex before calling cleanOrphanedConnections, as otherwise
5321         // another thread might modify/delete the connection
5322         if (receiverMutex != senderMutex) {
5323             receiverMutex->unlock();
5324         }
5325         connections->cleanOrphanedConnections(c->sender, ConnectionData::AlreadyLockedAndTemporarilyReleasingLock);
5326         senderMutex->unlock(); // now both sender and receiver mutex have been manually unlocked
5327         locker.dismiss(); // so we dismiss the QOrderedMutexLocker
5328     }
5329 
5330     return true;
5331 }
5332 
5333 /*! \class QMetaObject::Connection
5334     \inmodule QtCore
5335      Represents a handle to a signal-slot (or signal-functor) connection.
5336 
5337      It can be used to check if the connection is valid and to disconnect it using
5338      QObject::disconnect(). For a signal-functor connection without a context object,
5339      it is the only way to selectively disconnect that connection.
5340 
5341      As Connection is just a handle, the underlying signal-slot connection is unaffected
5342      when Connection is destroyed or reassigned.
5343  */
5344 
5345 /*!
5346     Create a copy of the handle to the \a other connection
5347  */
5348 QMetaObject::Connection::Connection(const QMetaObject::Connection &other) : d_ptr(other.d_ptr)
5349 {
5350     if (d_ptr)
5351         static_cast<QObjectPrivate::Connection *>(d_ptr)->ref();
5352 }
5353 
5354 /*!
5355     Assigns \a other to this connection and returns a reference to this connection.
5356 */
5357 QMetaObject::Connection &QMetaObject::Connection::operator=(const QMetaObject::Connection &other)
5358 {
5359     if (other.d_ptr != d_ptr) {
5360         if (d_ptr)
5361             static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5362         d_ptr = other.d_ptr;
5363         if (other.d_ptr)
5364             static_cast<QObjectPrivate::Connection *>(other.d_ptr)->ref();
5365     }
5366     return *this;
5367 }
5368 
5369 /*!
5370     Creates a Connection instance.
5371 */
5372 
5373 QMetaObject::Connection::Connection() : d_ptr(nullptr) {}
5374 
5375 /*!
5376     Destructor for QMetaObject::Connection.
5377 */
5378 QMetaObject::Connection::~Connection()
5379 {
5380     if (d_ptr)
5381         static_cast<QObjectPrivate::Connection *>(d_ptr)->deref();
5382 }
5383 
5384 /*! \internal Returns true if the object is still connected */
5385 bool QMetaObject::Connection::isConnected_helper() const
5386 {
5387     Q_ASSERT(d_ptr);    // we're only called from operator RestrictedBool() const
5388     QObjectPrivate::Connection *c = static_cast<QObjectPrivate::Connection *>(d_ptr);
5389 
5390     return c->receiver.loadRelaxed();
5391 }
5392 
5393 
5394 /*!
5395     \fn QMetaObject::Connection::operator bool() const
5396 
5397     Returns \c true if the connection is valid.
5398 
5399     The connection is valid if the call to QObject::connect succeeded.
5400     The connection is invalid if QObject::connect was not able to find
5401     the signal or the slot, or if the arguments do not match.
5402  */
5403 
5404 QT_END_NAMESPACE
5405 
5406 #include "moc_qobject.cpp"
