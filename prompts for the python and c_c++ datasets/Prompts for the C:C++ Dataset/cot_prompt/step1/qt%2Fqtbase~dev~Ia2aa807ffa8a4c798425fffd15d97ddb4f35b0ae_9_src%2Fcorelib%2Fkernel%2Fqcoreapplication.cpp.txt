Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
QCoreApplication: force the process locale codec to UTF-8

As discussed in the mailing list and in the Qt Contributor Summit 2019.

Tested on Linux, macOS and FreeBSD, showing these fallbacks:
OS        environment         setlocale() call
FreeBSD   empty               "C.UTF-8"
FreeBSD   LC_ALL=C            "C.UTF-8"
Linux     empty               "C.UTF-8"
Linux     LC_ALL=C            "C.UTF-8"
Linux     LANG=en_US          "en_US.UTF-8"
Linux     LANG=de_DE@euro     "de_DE.UTF-8"
Linux     LANG=en_GB.iso885915 "en_GB.UTF-8"
Linux     LANG=hy_AM.armscii8 "hy_AM.UTF-8"
Linux     LANG=ja_JP.sjis     "ja_JP.UTF-8"
Linux     LANG=ru_RU.koi8r    "ru_RU.UTF-8"
macOS     empty               "UTF-8"
macOS     LC_ALL=C            "UTF-8"

Versions tested: FreeBSD 12.1, Linux w/ glibc 2.30, macOS 10.14.2.

See
* https://wiki.qt.io/Qt_Contributor_Summit_2019_-_QtCore
* https://lists.qt-project.org/pipermail/development/2019-October/037791.html

Change-Id: Ia2aa807ffa8a4c798425fffd15d97ddb4f35b0ae
Reviewed-by: Thiago Macieira <thiago.macieira@intel.com>
Reviewed-by: Lars Knoll <lars.knoll@qt.io>

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qcoreapplication.h"
42 #include "qcoreapplication_p.h"
43 
44 #ifndef QT_NO_QOBJECT
45 #include "qabstracteventdispatcher.h"
46 #include "qcoreevent.h"
47 #include "qeventloop.h"
48 #endif
49 #include "qmetaobject.h"
50 #include "qcorecmdlineargs_p.h"
51 #include <qdatastream.h>
52 #include <qdebug.h>
53 #include <qdir.h>
54 #include <qfile.h>
55 #include <qfileinfo.h>
56 #include <qmutex.h>
57 #include <private/qloggingregistry_p.h>
58 #include <qscopeguard.h>
59 #include <qstandardpaths.h>
60 #ifndef QT_NO_QOBJECT
61 #include <qthread.h>
62 #include <qthreadstorage.h>
63 #include <private/qthread_p.h>
64 #if QT_CONFIG(thread)
65 #include <qthreadpool.h>
66 #endif
67 #endif
68 #include <qelapsedtimer.h>
69 #include <qlibraryinfo.h>
70 #include <qvarlengtharray.h>
71 #include <private/qfactoryloader_p.h>
72 #include <private/qfunctions_p.h>
73 #include <private/qlocale_p.h>
74 #include <private/qlocking_p.h>
75 #include <private/qhooks_p.h>
76 
77 #ifndef QT_NO_QOBJECT
78 #if defined(Q_OS_UNIX)
79 # if defined(Q_OS_DARWIN)
80 #  include "qeventdispatcher_cf_p.h"
81 # else
82 #  if !defined(QT_NO_GLIB)
83 #   include "qeventdispatcher_glib_p.h"
84 #  endif
85 # endif
86 # include "qeventdispatcher_unix_p.h"
87 #endif
88 #ifdef Q_OS_WIN
89 # ifdef Q_OS_WINRT
90 #  include "qeventdispatcher_winrt_p.h"
91 #  include "qfunctions_winrt.h"
92 #  include <wrl.h>
93 #  include <Windows.ApplicationModel.core.h>
94    using namespace ABI::Windows::ApplicationModel::Core;
95    using namespace Microsoft::WRL;
96 # else
97 #  include "qeventdispatcher_win_p.h"
98 # endif
99 #endif
100 #endif // QT_NO_QOBJECT
101 
102 #if defined(Q_OS_ANDROID) && !defined(Q_OS_ANDROID_EMBEDDED)
103 #  include <private/qjni_p.h>
104 #  include <private/qjnihelpers_p.h>
105 #endif
106 
107 #ifdef Q_OS_MAC
108 #  include "qcore_mac_p.h"
109 #endif
110 
111 #include <stdlib.h>
112 
113 #ifdef Q_OS_UNIX
114 #  include <locale.h>
115 #  include <langinfo.h>
116 #  include <unistd.h>
117 #  include <sys/types.h>
118 #endif
119 
120 #ifdef Q_OS_VXWORKS
121 #  include <taskLib.h>
122 #endif
123 
124 #ifdef Q_OS_WASM
125 #include <emscripten/val.h>
126 #endif
127 
128 #ifdef QT_BOOTSTRAPPED
129 #include <private/qtrace_p.h>
130 #else
131 #include <qtcore_tracepoints_p.h>
132 #endif
133 
134 #include <algorithm>
135 
136 QT_BEGIN_NAMESPACE
137 
138 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
139 extern QString qAppFileName();
140 #endif
141 
142 #if QT_VERSION >= 0x070000
143 # error "Bump QCoreApplicatoinPrivate::app_compile_version to 0x070000"
144 #endif
145 int QCoreApplicationPrivate::app_compile_version = 0x060000; //we don't know exactly, but it's at least 6.0.0
146 
147 bool QCoreApplicationPrivate::setuidAllowed = false;
148 
149 #if !defined(Q_OS_WIN)
150 #ifdef Q_OS_DARWIN
151 QString QCoreApplicationPrivate::infoDictionaryStringProperty(const QString &propertyName)
152 {
153     QString bundleName;
154     QCFString cfPropertyName = propertyName.toCFString();
155     CFTypeRef string = CFBundleGetValueForInfoDictionaryKey(CFBundleGetMainBundle(),
156                                                             cfPropertyName);
157     if (string)
158         bundleName = QString::fromCFString(static_cast<CFStringRef>(string));
159     return bundleName;
160 }
161 #endif
162 QString QCoreApplicationPrivate::appName() const
163 {
164     QString applicationName;
165 #ifdef Q_OS_DARWIN
166     applicationName = infoDictionaryStringProperty(QStringLiteral("CFBundleName"));
167 #endif
168     if (applicationName.isEmpty() && argv[0]) {
169         char *p = strrchr(argv[0], '/');
170         applicationName = QString::fromLocal8Bit(p ? p + 1 : argv[0]);
171     }
172 
173     return applicationName;
174 }
175 QString QCoreApplicationPrivate::appVersion() const
176 {
177     QString applicationVersion;
178 #ifndef QT_BOOTSTRAPPED
179 #  ifdef Q_OS_DARWIN
180     applicationVersion = infoDictionaryStringProperty(QStringLiteral("CFBundleVersion"));
181 #  elif defined(Q_OS_ANDROID) && !defined(Q_OS_ANDROID_EMBEDDED)
182     QJNIObjectPrivate context(QtAndroidPrivate::context());
183     if (context.isValid()) {
184         QJNIObjectPrivate pm = context.callObjectMethod(
185             "getPackageManager", "()Landroid/content/pm/PackageManager;");
186         QJNIObjectPrivate pn = context.callObjectMethod<jstring>("getPackageName");
187         if (pm.isValid() && pn.isValid()) {
188             QJNIObjectPrivate packageInfo = pm.callObjectMethod(
189                 "getPackageInfo", "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;",
190                 pn.object(), 0);
191             if (packageInfo.isValid()) {
192                 QJNIObjectPrivate versionName = packageInfo.getObjectField(
193                     "versionName", "Ljava/lang/String;");
194                 if (versionName.isValid())
195                     return versionName.toString();
196             }
197         }
198     }
199 #  endif
200 #endif
201     return applicationVersion;
202 }
203 #endif
204 
205 QString *QCoreApplicationPrivate::cachedApplicationFilePath = nullptr;
206 
207 bool QCoreApplicationPrivate::checkInstance(const char *function)
208 {
209     bool b = (QCoreApplication::self != nullptr);
210     if (!b)
211         qWarning("QApplication::%s: Please instantiate the QApplication object first", function);
212     return b;
213 }
214 
215 #if QT_CONFIG(commandlineparser)
216 void QCoreApplicationPrivate::addQtOptions(QList<QCommandLineOption> *options)
217 {
218     options->append(QCommandLineOption(QStringLiteral("qmljsdebugger"),
219                 QStringLiteral("Activates the QML/JS debugger with a specified port. The value must be of format port:1234[,block]. \"block\" makes the application wait for a connection."),
220                 QStringLiteral("value")));
221 }
222 #endif
223 
224 void QCoreApplicationPrivate::processCommandLineArguments()
225 {
226     int j = argc ? 1 : 0;
227     for (int i = 1; i < argc; ++i) {
228         if (!argv[i])
229             continue;
230         if (*argv[i] != '-') {
231             argv[j++] = argv[i];
232             continue;
233         }
234         const char *arg = argv[i];
235         if (arg[1] == '-') // startsWith("--")
236             ++arg;
237         if (strncmp(arg, "-qmljsdebugger=", 15) == 0) {
238             qmljs_debug_arguments = QString::fromLocal8Bit(arg + 15);
239         } else if (strcmp(arg, "-qmljsdebugger") == 0 && i < argc - 1) {
240             ++i;
241             qmljs_debug_arguments = QString::fromLocal8Bit(argv[i]);
242         } else {
243             argv[j++] = argv[i];
244         }
245     }
246 
247     if (j < argc) {
248         argv[j] = nullptr;
249         argc = j;
250     }
251 }
252 
253 // Support for introspection
254 
255 extern "C" void Q_CORE_EXPORT qt_startup_hook()
256 {
257 }
258 
259 typedef QList<QtStartUpFunction> QStartUpFuncList;
260 Q_GLOBAL_STATIC(QStartUpFuncList, preRList)
261 typedef QList<QtCleanUpFunction> QVFuncList;
262 Q_GLOBAL_STATIC(QVFuncList, postRList)
263 static QBasicMutex globalRoutinesMutex;
264 
265 /*!
266     \internal
267 
268     Adds a global routine that will be called from the QCoreApplication
269     constructor. The public API is Q_COREAPP_STARTUP_FUNCTION.
270 */
271 void qAddPreRoutine(QtStartUpFunction p)
272 {
273     QStartUpFuncList *list = preRList();
274     if (!list)
275         return;
276 
277     if (QCoreApplication::instance())
278         p();
279 
280     // Due to C++11 parallel dynamic initialization, this can be called
281     // from multiple threads.
282     const auto locker = qt_scoped_lock(globalRoutinesMutex);
283     list->prepend(p); // in case QCoreApplication is re-created, see qt_call_pre_routines
284 }
285 
286 void qAddPostRoutine(QtCleanUpFunction p)
287 {
288     QVFuncList *list = postRList();
289     if (!list)
290         return;
291     const auto locker = qt_scoped_lock(globalRoutinesMutex);
292     list->prepend(p);
293 }
294 
295 void qRemovePostRoutine(QtCleanUpFunction p)
296 {
297     QVFuncList *list = postRList();
298     if (!list)
299         return;
300     const auto locker = qt_scoped_lock(globalRoutinesMutex);
301     list->removeAll(p);
302 }
303 
304 static void qt_call_pre_routines()
305 {
306     if (!preRList.exists())
307         return;
308 
309     QVFuncList list;
310     {
311         const auto locker = qt_scoped_lock(globalRoutinesMutex);
312         // Unlike qt_call_post_routines, we don't empty the list, because
313         // Q_COREAPP_STARTUP_FUNCTION is a macro, so the user expects
314         // the function to be executed every time QCoreApplication is created.
315         list = *preRList;
316     }
317     for (int i = 0; i < list.count(); ++i)
318         list.at(i)();
319 }
320 
321 void Q_CORE_EXPORT qt_call_post_routines()
322 {
323     if (!postRList.exists())
324         return;
325 
326     forever {
327         QVFuncList list;
328         {
329             // extract the current list and make the stored list empty
330             const auto locker = qt_scoped_lock(globalRoutinesMutex);
331             qSwap(*postRList, list);
332         }
333 
334         if (list.isEmpty())
335             break;
336         for (QtCleanUpFunction f : qAsConst(list))
337             f();
338     }
339 }
340 
341 
342 #ifndef QT_NO_QOBJECT
343 
344 // app starting up if false
345 bool QCoreApplicationPrivate::is_app_running = false;
346  // app closing down if true
347 bool QCoreApplicationPrivate::is_app_closing = false;
348 
349 Q_CORE_EXPORT uint qGlobalPostedEventsCount()
350 {
351     QThreadData *currentThreadData = QThreadData::current();
352     return currentThreadData->postEventList.size() - currentThreadData->postEventList.startOffset;
353 }
354 
355 QAbstractEventDispatcher *QCoreApplicationPrivate::eventDispatcher = nullptr;
356 
357 #endif // QT_NO_QOBJECT
358 
359 QCoreApplication *QCoreApplication::self = nullptr;
360 uint QCoreApplicationPrivate::attribs =
361     (1 << Qt::AA_SynthesizeMouseForUnhandledTouchEvents) |
362     (1 << Qt::AA_SynthesizeMouseForUnhandledTabletEvents) |
363     (1 << Qt::AA_UseHighDpiPixmaps);
364 
365 struct QCoreApplicationData {
366     QCoreApplicationData() noexcept {
367         applicationNameSet = false;
368         applicationVersionSet = false;
369     }
370     ~QCoreApplicationData() {
371 #ifndef QT_NO_QOBJECT
372         // cleanup the QAdoptedThread created for the main() thread
373         if (auto *t = QCoreApplicationPrivate::theMainThread.loadAcquire()) {
374             QThreadData *data = QThreadData::get2(t);
375             data->deref(); // deletes the data and the adopted thread
376         }
377 #endif
378     }
379 
380     QString orgName, orgDomain;
381     QString application; // application name, initially from argv[0], can then be modified.
382     QString applicationVersion;
383     bool applicationNameSet; // true if setApplicationName was called
384     bool applicationVersionSet; // true if setApplicationVersion was called
385 
386 #if QT_CONFIG(library)
387     QScopedPointer<QStringList> app_libpaths;
388     QScopedPointer<QStringList> manual_libpaths;
389 #endif
390 
391 };
392 
393 Q_GLOBAL_STATIC(QCoreApplicationData, coreappdata)
394 
395 #ifndef QT_NO_QOBJECT
396 static bool quitLockRefEnabled = true;
397 #endif
398 
399 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
400 // Check whether the command line arguments match those passed to main()
401 // by comparing to the global __argv/__argc (MS extension).
402 // Deep comparison is required since argv/argc is rebuilt by WinMain for
403 // GUI apps or when using MinGW due to its globbing.
404 static inline bool isArgvModified(int argc, char **argv)
405 {
406     if (__argc != argc || !__argv /* wmain() */)
407         return true;
408     if (__argv == argv)
409         return false;
410     for (int a = 0; a < argc; ++a) {
411         if (argv[a] != __argv[a] && strcmp(argv[a], __argv[a]))
412             return true;
413     }
414     return false;
415 }
416 
417 static inline bool contains(int argc, char **argv, const char *needle)
418 {
419     for (int a = 0; a < argc; ++a) {
420         if (!strcmp(argv[a], needle))
421             return true;
422     }
423     return false;
424 }
425 #endif // Q_OS_WIN && !Q_OS_WINRT
426 
427 QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv, uint flags)
428     :
429 #ifndef QT_NO_QOBJECT
430       QObjectPrivate(),
431 #endif
432       argc(aargc)
433     , argv(aargv)
434 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
435     , origArgc(0)
436     , origArgv(nullptr)
437 #endif
438     , application_type(QCoreApplicationPrivate::Tty)
439 #ifndef QT_NO_QOBJECT
440     , in_exec(false)
441     , aboutToQuitEmitted(false)
442     , threadData_clean(false)
443 #else
444     , q_ptr(nullptr)
445 #endif
446 {
447     app_compile_version = flags & 0xffffff;
448     static const char *const empty = "";
449     if (argc == 0 || argv == nullptr) {
450         argc = 0;
451         argv = const_cast<char **>(&empty);
452     }
453 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
454     if (!isArgvModified(argc, argv)) {
455         origArgc = argc;
456         origArgv = new char *[argc];
457         std::copy(argv, argv + argc, QT_MAKE_CHECKED_ARRAY_ITERATOR(origArgv, argc));
458     }
459 #endif // Q_OS_WIN && !Q_OS_WINRT
460 
461 #ifndef QT_NO_QOBJECT
462     QCoreApplicationPrivate::is_app_closing = false;
463 
464 #  if defined(Q_OS_UNIX)
465     if (Q_UNLIKELY(!setuidAllowed && (geteuid() != getuid())))
466         qFatal("FATAL: The application binary appears to be running setuid, this is a security hole.");
467 #  endif // Q_OS_UNIX
468 
469 #ifdef Q_OS_WINRT
470     QThreadData::setMainThread();
471 #endif
472 
473     QThread *cur = QThread::currentThread(); // note: this may end up setting theMainThread!
474     if (cur != theMainThread.loadAcquire())
475         qWarning("WARNING: QApplication was not created in the main() thread.");
476 #endif
477 }
478 
479 QCoreApplicationPrivate::~QCoreApplicationPrivate()
480 {
481 #ifndef QT_NO_QOBJECT
482     cleanupThreadData();
483 #endif
484 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
485     delete [] origArgv;
486 #endif
487     QCoreApplicationPrivate::clearApplicationFilePath();
488 }
489 
490 #ifndef QT_NO_QOBJECT
491 
492 void QCoreApplicationPrivate::cleanupThreadData()
493 {
494     auto thisThreadData = threadData.loadRelaxed();
495 
496     if (thisThreadData && !threadData_clean) {
497 #if QT_CONFIG(thread)
498         void *data = &thisThreadData->tls;
499         QThreadStorageData::finish((void **)data);
500 #endif
501 
502         // need to clear the state of the mainData, just in case a new QCoreApplication comes along.
503         const auto locker = qt_scoped_lock(thisThreadData->postEventList.mutex);
504         for (int i = 0; i < thisThreadData->postEventList.size(); ++i) {
505             const QPostEvent &pe = thisThreadData->postEventList.at(i);
506             if (pe.event) {
507                 --pe.receiver->d_func()->postedEvents;
508                 pe.event->posted = false;
509                 delete pe.event;
510             }
511         }
512         thisThreadData->postEventList.clear();
513         thisThreadData->postEventList.recursion = 0;
514         thisThreadData->quitNow = false;
515         threadData_clean = true;
516     }
517 }
518 
519 void QCoreApplicationPrivate::createEventDispatcher()
520 {
521     Q_Q(QCoreApplication);
522     QThreadData *data = QThreadData::current();
523     Q_ASSERT(!data->hasEventDispatcher());
524     eventDispatcher = data->createEventDispatcher();
525     eventDispatcher->setParent(q);
526 }
527 
528 void QCoreApplicationPrivate::eventDispatcherReady()
529 {
530 }
531 
532 QBasicAtomicPointer<QThread> QCoreApplicationPrivate::theMainThread = Q_BASIC_ATOMIC_INITIALIZER(nullptr);
533 QThread *QCoreApplicationPrivate::mainThread()
534 {
535     Q_ASSERT(theMainThread.loadRelaxed() != nullptr);
536     return theMainThread.loadRelaxed();
537 }
538 
539 bool QCoreApplicationPrivate::threadRequiresCoreApplication()
540 {
541     QThreadData *data = QThreadData::current(false);
542     if (!data)
543         return true;    // default setting
544     return data->requiresCoreApplication;
545 }
546 
547 void QCoreApplicationPrivate::checkReceiverThread(QObject *receiver)
548 {
549     QThread *currentThread = QThread::currentThread();
550     QThread *thr = receiver->thread();
551     Q_ASSERT_X(currentThread == thr || !thr,
552                "QCoreApplication::sendEvent",
553                QString::asprintf("Cannot send events to objects owned by a different thread. "
554                                  "Current thread 0x%p. Receiver '%ls' (of type '%s') was created in thread 0x%p",
555                                  currentThread, qUtf16Printable(receiver->objectName()),
556                                  receiver->metaObject()->className(), thr)
557                .toLocal8Bit().data());
558     Q_UNUSED(currentThread);
559     Q_UNUSED(thr);
560 }
561 
562 #endif // QT_NO_QOBJECT
563 
564 void QCoreApplicationPrivate::appendApplicationPathToLibraryPaths()
565 {
566 #if QT_CONFIG(library)
567     QStringList *app_libpaths = coreappdata()->app_libpaths.data();
568     if (!app_libpaths)
569         coreappdata()->app_libpaths.reset(app_libpaths = new QStringList);
570     QString app_location = QCoreApplication::applicationFilePath();
571     app_location.truncate(app_location.lastIndexOf(QLatin1Char('/')));
572 #ifdef Q_OS_WINRT
573     if (app_location.isEmpty())
574         app_location.append(QLatin1Char('/'));
575 #endif
576     app_location = QDir(app_location).canonicalPath();
577     if (QFile::exists(app_location) && !app_libpaths->contains(app_location))
578         app_libpaths->append(app_location);
579 #endif
580 }
581 
582 QString qAppName()
583 {
584     if (!QCoreApplicationPrivate::checkInstance("qAppName"))
585         return QString();
586     return QCoreApplication::instance()->d_func()->appName();
587 }
588 
589 void QCoreApplicationPrivate::initLocale()
590 {
591 #if defined(Q_OS_UNIX) && !defined(QT_BOOTSTRAPPED)
592     static bool qt_locale_initialized = false;
593     if (qt_locale_initialized)
594         return;
595     qt_locale_initialized = true;
596 
597 #ifdef Q_OS_ANDROID
598     // Android's Bionic didn't get nl_langinfo until NDK 15 (Android 8.0),
599     // which is too new for Qt, so we just assume it's always UTF-8.
600     auto nl_langinfo = [](int) { return "UTF-8"; };
601 #endif
602 
603     const char *locale = setlocale(LC_ALL, "");
604     const char *codec = nl_langinfo(CODESET);
605     if (Q_UNLIKELY(strcmp(codec, "UTF-8") != 0 && strcmp(codec, "utf8") != 0)) {
606         QByteArray oldLocale = locale;
607         QByteArray newLocale = setlocale(LC_CTYPE, nullptr);
608         if (int dot = newLocale.indexOf('.'); dot != -1)
609             newLocale.truncate(dot);    // remove encoding, if any
610         if (int at = newLocale.indexOf('@'); at != -1)
611             newLocale.truncate(at);     // remove variant, as the old de_DE@euro
612         newLocale += ".UTF-8";
613         newLocale = setlocale(LC_CTYPE, newLocale);
614 
615         // if locale doesn't exist, try some fallbacks
616 #  ifdef Q_OS_DARWIN
617         if (newLocale.isEmpty())
618             newLocale = setlocale(LC_CTYPE, "UTF-8");
619 #  endif
620         if (newLocale.isEmpty())
621             newLocale = setlocale(LC_CTYPE, "C.UTF-8");
622         if (newLocale.isEmpty())
623             newLocale = setlocale(LC_CTYPE, "C.utf8");
624 
625         qWarning("Detected system locale encoding (%s, locale \"%s\") is not UTF-8.\n"
626                  "Qt shall use a UTF-8 locale (\"%s\") instead. If this causes problems,\n"
627                  "reconfigure your locale. See the locale(1) manual for more information.",
628                  codec, oldLocale.constData(), newLocale.constData());
629     }
630 #endif
631 }
632 
633 
634 /*!
635     \class QCoreApplication
636     \inmodule QtCore
637     \brief The QCoreApplication class provides an event loop for Qt
638     applications without UI.
639 
640     This class is used by non-GUI applications to provide their event
641     loop. For non-GUI application that uses Qt, there should be exactly
642     one QCoreApplication object. For GUI applications, see
643     QGuiApplication. For applications that use the Qt Widgets module,
644     see QApplication.
645 
646     QCoreApplication contains the main event loop, where all events
647     from the operating system (e.g., timer and network events) and
648     other sources are processed and dispatched. It also handles the
649     application's initialization and finalization, as well as
650     system-wide and application-wide settings.
651 
652     \section1 The Event Loop and Event Handling
653 
654     The event loop is started with a call to exec(). Long-running
655     operations can call processEvents() to keep the application
656     responsive.
657 
658     In general, we recommend that you create a QCoreApplication,
659     QGuiApplication or a QApplication object in your \c main()
660     function as early as possible. exec() will not return until
661     the event loop exits; e.g., when quit() is called.
662 
663     Several static convenience functions are also provided. The
664     QCoreApplication object is available from instance(). Events can
665     be sent with sendEvent() or posted to an event queue with postEvent().
666     Pending events can be removed with removePostedEvents() or dispatched
667     with sendPostedEvents().
668 
669     The class provides a quit() slot and an aboutToQuit() signal.
670 
671     \section1 Application and Library Paths
672 
673     An application has an applicationDirPath() and an
674     applicationFilePath(). Library paths (see QLibrary) can be retrieved
675     with libraryPaths() and manipulated by setLibraryPaths(), addLibraryPath(),
676     and removeLibraryPath().
677 
678     \section1 Internationalization and Translations
679 
680     Translation files can be added or removed
681     using installTranslator() and removeTranslator(). Application
682     strings can be translated using translate(). The QObject::tr()
683     and QObject::trUtf8() functions are implemented in terms of
684     translate().
685 
686     \section1 Accessing Command Line Arguments
687 
688     The command line arguments which are passed to QCoreApplication's
689     constructor should be accessed using the arguments() function.
690 
691     \note QCoreApplication removes option \c -qmljsdebugger="...". It parses the
692     argument of \c qmljsdebugger, and then removes this option plus its argument.
693 
694     For more advanced command line option handling, create a QCommandLineParser.
695 
696     \section1 Locale Settings
697 
698     On Unix/Linux Qt is configured to use the system locale settings by
699     default. This can cause a conflict when using POSIX functions, for
700     instance, when converting between data types such as floats and
701     strings, since the notation may differ between locales. To get
702     around this problem, call the POSIX function \c{setlocale(LC_NUMERIC,"C")}
703     right after initializing QApplication, QGuiApplication or QCoreApplication
704     to reset the locale that is used for number formatting to "C"-locale.
705 
706     \sa QGuiApplication, QAbstractEventDispatcher, QEventLoop,
707     {Semaphores Example}, {Wait Conditions Example}
708 */
709 
710 /*!
711     \fn static QCoreApplication *QCoreApplication::instance()
712 
713     Returns a pointer to the application's QCoreApplication (or
714     QGuiApplication/QApplication) instance.
715 
716     If no instance has been allocated, \nullptr is returned.
717 */
718 
719 /*!
720     \internal
721  */
722 QCoreApplication::QCoreApplication(QCoreApplicationPrivate &p)
723 #ifdef QT_NO_QOBJECT
724     : d_ptr(&p)
725 #else
726     : QObject(p, nullptr)
727 #endif
728 {
729     d_func()->q_ptr = this;
730     // note: it is the subclasses' job to call
731     // QCoreApplicationPrivate::eventDispatcher->startingUp();
732 }
733 
734 #ifndef QT_NO_QOBJECT
735 /*!
736     \deprecated
737     This function is equivalent to calling \c {QCoreApplication::eventDispatcher()->flush()},
738     which also is deprecated, see QAbstractEventDispatcher::flush(). Use sendPostedEvents()
739     and processEvents() for more fine-grained control of the event loop instead.
740 
741     Historically this functions was used to flush the platform-specific native event queues.
742 
743     \sa sendPostedEvents(), processEvents(), QAbstractEventDispatcher::flush()
744 */
745 #if QT_DEPRECATED_SINCE(5, 9)
746 void QCoreApplication::flush()
747 {
748     if (self && self->d_func()->eventDispatcher)
749         self->d_func()->eventDispatcher->flush();
750 }
751 #endif
752 #endif
753 
754 /*!
755     Constructs a Qt core application. Core applications are applications without
756     a graphical user interface. Such applications are used at the console or as
757     server processes.
758 
759     The \a argc and \a argv arguments are processed by the application,
760     and made available in a more convenient form by the arguments()
761     function.
762 
763     \warning The data referred to by \a argc and \a argv must stay valid
764     for the entire lifetime of the QCoreApplication object. In addition,
765     \a argc must be greater than zero and \a argv must contain at least
766     one valid character string.
767 */
768 QCoreApplication::QCoreApplication(int &argc, char **argv
769 #ifndef Q_QDOC
770                                    , int _internal
771 #endif
772                                    )
773 #ifdef QT_NO_QOBJECT
774     : d_ptr(new QCoreApplicationPrivate(argc, argv, _internal))
775 #else
776     : QObject(*new QCoreApplicationPrivate(argc, argv, _internal))
777 #endif
778 {
779     d_func()->q_ptr = this;
780     d_func()->init();
781 #ifndef QT_NO_QOBJECT
782     QCoreApplicationPrivate::eventDispatcher->startingUp();
783 #endif
784 }
785 
786 /*!
787   \enum QCoreApplication::anonymous
788   \internal
789 
790   \value ApplicationFlags QT_VERSION
791 */
792 
793 void QCoreApplicationPrivate::init()
794 {
795     Q_TRACE_SCOPE(QCoreApplicationPrivate_init);
796 
797 #if defined(Q_OS_MACOS)
798     QMacAutoReleasePool pool;
799 #endif
800 
801     Q_Q(QCoreApplication);
802 
803     initLocale();
804 
805     Q_ASSERT_X(!QCoreApplication::self, "QCoreApplication", "there should be only one application object");
806     QCoreApplication::self = q;
807 
808 #if QT_CONFIG(thread)
809 #ifdef Q_OS_WASM
810     QThreadPrivate::idealThreadCount = emscripten::val::global("navigator")["hardwareConcurrency"].as<int>();
811 #endif
812 #endif
813 
814     // Store app name/version (so they're still available after QCoreApplication is destroyed)
815     if (!coreappdata()->applicationNameSet)
816         coreappdata()->application = appName();
817 
818     if (!coreappdata()->applicationVersionSet)
819         coreappdata()->applicationVersion = appVersion();
820 
821 #if defined(Q_OS_ANDROID)
822     // We've deferred initializing the logging registry due to not being
823     // able to guarantee that logging happened on the same thread as the
824     // Qt main thread, but now that the Qt main thread is set up, we can
825     // enable categorized logging.
826     QLoggingRegistry::instance()->initializeRules();
827 #endif
828 
829 #if QT_CONFIG(library)
830     // Reset the lib paths, so that they will be recomputed, taking the availability of argv[0]
831     // into account. If necessary, recompute right away and replay the manual changes on top of the
832     // new lib paths.
833     QStringList *appPaths = coreappdata()->app_libpaths.take();
834     QStringList *manualPaths = coreappdata()->manual_libpaths.take();
835     if (appPaths) {
836         if (manualPaths) {
837             // Replay the delta. As paths can only be prepended to the front or removed from
838             // anywhere in the list, we can just linearly scan the lists and find the items that
839             // have been removed. Once the original list is exhausted we know all the remaining
840             // items have been added.
841             QStringList newPaths(q->libraryPaths());
842             for (int i = manualPaths->length(), j = appPaths->length(); i > 0 || j > 0; qt_noop()) {
843                 if (--j < 0) {
844                     newPaths.prepend((*manualPaths)[--i]);
845                 } else if (--i < 0) {
846                     newPaths.removeAll((*appPaths)[j]);
847                 } else if ((*manualPaths)[i] != (*appPaths)[j]) {
848                     newPaths.removeAll((*appPaths)[j]);
849                     ++i; // try again with next item.
850                 }
851             }
852             delete manualPaths;
853             coreappdata()->manual_libpaths.reset(new QStringList(newPaths));
854         }
855         delete appPaths;
856     }
857 #endif
858 
859 #ifndef QT_NO_QOBJECT
860     // use the event dispatcher created by the app programmer (if any)
861     Q_ASSERT(!eventDispatcher);
862     auto thisThreadData = threadData.loadRelaxed();
863     eventDispatcher = thisThreadData->eventDispatcher.loadRelaxed();
864 
865     // otherwise we create one
866     if (!eventDispatcher)
867         createEventDispatcher();
868     Q_ASSERT(eventDispatcher);
869 
870     if (!eventDispatcher->parent()) {
871         eventDispatcher->moveToThread(thisThreadData->thread.loadAcquire());
872         eventDispatcher->setParent(q);
873     }
874 
875     thisThreadData->eventDispatcher = eventDispatcher;
876     eventDispatcherReady();
877 #endif
878 
879     processCommandLineArguments();
880 
881     qt_call_pre_routines();
882     qt_startup_hook();
883 #ifndef QT_BOOTSTRAPPED
884     if (Q_UNLIKELY(qtHookData[QHooks::Startup]))
885         reinterpret_cast<QHooks::StartupCallback>(qtHookData[QHooks::Startup])();
886 #endif
887 
888 #ifndef QT_NO_QOBJECT
889     is_app_running = true; // No longer starting up.
890 #endif
891 }
892 
893 /*!
894     Destroys the QCoreApplication object.
895 */
896 QCoreApplication::~QCoreApplication()
897 {
898     qt_call_post_routines();
899 
900     self = nullptr;
901 #ifndef QT_NO_QOBJECT
902     QCoreApplicationPrivate::is_app_closing = true;
903     QCoreApplicationPrivate::is_app_running = false;
904 #endif
905 
906 #if QT_CONFIG(thread)
907     // Synchronize and stop the global thread pool threads.
908     QThreadPool *globalThreadPool = nullptr;
909     QT_TRY {
910         globalThreadPool = QThreadPool::globalInstance();
911     } QT_CATCH (...) {
912         // swallow the exception, since destructors shouldn't throw
913     }
914     if (globalThreadPool)
915         globalThreadPool->waitForDone();
916 #endif
917 
918 #ifndef QT_NO_QOBJECT
919     d_func()->threadData.loadRelaxed()->eventDispatcher = nullptr;
920     if (QCoreApplicationPrivate::eventDispatcher)
921         QCoreApplicationPrivate::eventDispatcher->closingDown();
922     QCoreApplicationPrivate::eventDispatcher = nullptr;
923 #endif
924 
925 #if QT_CONFIG(library)
926     coreappdata()->app_libpaths.reset();
927     coreappdata()->manual_libpaths.reset();
928 #endif
929 }
930 
931 /*!
932     \since 5.3
933 
934     Allows the application to run setuid on UNIX platforms if \a allow
935     is true.
936 
937     If \a allow is false (the default) and Qt detects the application is
938     running with an effective user id different than the real user id,
939     the application will be aborted when a QCoreApplication instance is
940     created.
941 
942     Qt is not an appropriate solution for setuid programs due to its
943     large attack surface. However some applications may be required
944     to run in this manner for historical reasons. This flag will
945     prevent Qt from aborting the application when this is detected,
946     and must be set before a QCoreApplication instance is created.
947 
948     \note It is strongly recommended not to enable this option since
949     it introduces security risks.
950 */
951 void QCoreApplication::setSetuidAllowed(bool allow)
952 {
953     QCoreApplicationPrivate::setuidAllowed = allow;
954 }
955 
956 /*!
957     \since 5.3
958 
959     Returns true if the application is allowed to run setuid on UNIX
960     platforms.
961 
962     \sa QCoreApplication::setSetuidAllowed()
963 */
964 bool QCoreApplication::isSetuidAllowed()
965 {
966     return QCoreApplicationPrivate::setuidAllowed;
967 }
968 
969 
970 /*!
971     Sets the attribute \a attribute if \a on is true;
972     otherwise clears the attribute.
973 
974     \note Some application attributes must be set \b before creating a
975     QCoreApplication instance. Refer to the Qt::ApplicationAttribute
976     documentation for more information.
977 
978     \sa testAttribute()
979 */
980 void QCoreApplication::setAttribute(Qt::ApplicationAttribute attribute, bool on)
981 {
982     if (on)
983         QCoreApplicationPrivate::attribs |= 1 << attribute;
984     else
985         QCoreApplicationPrivate::attribs &= ~(1 << attribute);
986 #if defined(QT_NO_QOBJECT)
987     if (Q_UNLIKELY(qApp)) {
988 #else
989     if (Q_UNLIKELY(QCoreApplicationPrivate::is_app_running)) {
990 #endif
991         switch (attribute) {
992             case Qt::AA_EnableHighDpiScaling:
993             case Qt::AA_DisableHighDpiScaling:
994             case Qt::AA_PluginApplication:
995             case Qt::AA_UseDesktopOpenGL:
996             case Qt::AA_UseOpenGLES:
997             case Qt::AA_UseSoftwareOpenGL:
998             case Qt::AA_ShareOpenGLContexts:
999 #ifdef QT_BOOTSTRAPPED
1000                 qWarning("Attribute %d must be set before QCoreApplication is created.",
1001                          attribute);
1002 #else
1003                 qWarning("Attribute Qt::%s must be set before QCoreApplication is created.",
1004                          QMetaEnum::fromType<Qt::ApplicationAttribute>().valueToKey(attribute));
1005 #endif
1006                 break;
1007             default:
1008                 break;
1009         }
1010     }
1011 }
1012 
1013 /*!
1014   Returns \c true if attribute \a attribute is set;
1015   otherwise returns \c false.
1016 
1017   \sa setAttribute()
1018  */
1019 bool QCoreApplication::testAttribute(Qt::ApplicationAttribute attribute)
1020 {
1021     return QCoreApplicationPrivate::testAttribute(attribute);
1022 }
1023 
1024 
1025 #ifndef QT_NO_QOBJECT
1026 
1027 /*!
1028     \property QCoreApplication::quitLockEnabled
1029 
1030     \brief Whether the use of the QEventLoopLocker feature can cause the
1031     application to quit.
1032 
1033     The default is \c true.
1034 
1035     \sa QEventLoopLocker
1036 */
1037 
1038 bool QCoreApplication::isQuitLockEnabled()
1039 {
1040     return quitLockRefEnabled;
1041 }
1042 
1043 static bool doNotify(QObject *, QEvent *);
1044 
1045 void QCoreApplication::setQuitLockEnabled(bool enabled)
1046 {
1047     quitLockRefEnabled = enabled;
1048 }
1049 
1050 #if QT_DEPRECATED_SINCE(5, 6)
1051 /*!
1052   \internal
1053   \deprecated
1054 
1055   This function is here to make it possible for Qt extensions to
1056   hook into event notification without subclassing QApplication
1057 */
1058 bool QCoreApplication::notifyInternal(QObject *receiver, QEvent *event)
1059 {
1060     return notifyInternal2(receiver, event);
1061 }
1062 #endif
1063 
1064 /*!
1065   \internal
1066   \since 5.6
1067 
1068   This function is here to make it possible for Qt extensions to
1069   hook into event notification without subclassing QApplication.
1070 */
1071 bool QCoreApplication::notifyInternal2(QObject *receiver, QEvent *event)
1072 {
1073     bool selfRequired = QCoreApplicationPrivate::threadRequiresCoreApplication();
1074     if (!self && selfRequired)
1075         return false;
1076 
1077     // Make it possible for Qt Script to hook into events even
1078     // though QApplication is subclassed...
1079     bool result = false;
1080     void *cbdata[] = { receiver, event, &result };
1081     if (QInternal::activateCallbacks(QInternal::EventNotifyCallback, cbdata)) {
1082         return result;
1083     }
1084 
1085     // Qt enforces the rule that events can only be sent to objects in
1086     // the current thread, so receiver->d_func()->threadData is
1087     // equivalent to QThreadData::current(), just without the function
1088     // call overhead.
1089     QObjectPrivate *d = receiver->d_func();
1090     QThreadData *threadData = d->threadData;
1091     QScopedScopeLevelCounter scopeLevelCounter(threadData);
1092     if (!selfRequired)
1093         return doNotify(receiver, event);
1094     return self->notify(receiver, event);
1095 }
1096 
1097 /*!
1098     \internal
1099     \since 5.10
1100 
1101     Forwards the \a event to the \a receiver, using the spontaneous
1102     state of the \a originatingEvent if specified.
1103 */
1104 bool QCoreApplication::forwardEvent(QObject *receiver, QEvent *event, QEvent *originatingEvent)
1105 {
1106     if (event && originatingEvent)
1107         event->spont = originatingEvent->spont;
1108 
1109     return notifyInternal2(receiver, event);
1110 }
1111 
1112 /*!
1113   Sends \a event to \a receiver: \a {receiver}->event(\a event).
1114   Returns the value that is returned from the receiver's event
1115   handler. Note that this function is called for all events sent to
1116   any object in any thread.
1117 
1118   For certain types of events (e.g. mouse and key events),
1119   the event will be propagated to the receiver's parent and so on up to
1120   the top-level object if the receiver is not interested in the event
1121   (i.e., it returns \c false).
1122 
1123   There are five different ways that events can be processed;
1124   reimplementing this virtual function is just one of them. All five
1125   approaches are listed below:
1126   \list 1
1127   \li Reimplementing \l {QWidget::}{paintEvent()}, \l {QWidget::}{mousePressEvent()} and so
1128   on. This is the most common, easiest, and least powerful way.
1129 
1130   \li Reimplementing this function. This is very powerful, providing
1131   complete control; but only one subclass can be active at a time.
1132 
1133   \li Installing an event filter on QCoreApplication::instance(). Such
1134   an event filter is able to process all events for all widgets, so
1135   it's just as powerful as reimplementing notify(); furthermore, it's
1136   possible to have more than one application-global event filter.
1137   Global event filters even see mouse events for
1138   \l{QWidget::isEnabled()}{disabled widgets}. Note that application
1139   event filters are only called for objects that live in the main
1140   thread.
1141 
1142   \li Reimplementing QObject::event() (as QWidget does). If you do
1143   this you get Tab key presses, and you get to see the events before
1144   any widget-specific event filters.
1145 
1146   \li Installing an event filter on the object. Such an event filter gets all
1147   the events, including Tab and Shift+Tab key press events, as long as they
1148   do not change the focus widget.
1149   \endlist
1150 
1151   \b{Future direction:} This function will not be called for objects that live
1152   outside the main thread in Qt 6. Applications that need that functionality
1153   should find other solutions for their event inspection needs in the meantime.
1154   The change may be extended to the main thread, causing this function to be
1155   deprecated.
1156 
1157   \warning If you override this function, you must ensure all threads that
1158   process events stop doing so before your application object begins
1159   destruction. This includes threads started by other libraries that you may be
1160   using, but does not apply to Qt's own threads.
1161 
1162   \sa QObject::event(), installNativeEventFilter()
1163 */
1164 
1165 bool QCoreApplication::notify(QObject *receiver, QEvent *event)
1166 {
1167     // no events are delivered after ~QCoreApplication() has started
1168     if (QCoreApplicationPrivate::is_app_closing)
1169         return true;
1170     return doNotify(receiver, event);
1171 }
1172 
1173 static bool doNotify(QObject *receiver, QEvent *event)
1174 {
1175     if (receiver == nullptr) {                        // serious error
1176         qWarning("QCoreApplication::notify: Unexpected null receiver");
1177         return true;
1178     }
1179 
1180 #ifndef QT_NO_DEBUG
1181     QCoreApplicationPrivate::checkReceiverThread(receiver);
1182 #endif
1183 
1184     return receiver->isWidgetType() ? false : QCoreApplicationPrivate::notify_helper(receiver, event);
1185 }
1186 
1187 bool QCoreApplicationPrivate::sendThroughApplicationEventFilters(QObject *receiver, QEvent *event)
1188 {
1189     // We can't access the application event filters outside of the main thread (race conditions)
1190     Q_ASSERT(receiver->d_func()->threadData.loadRelaxed()->thread.loadAcquire() == mainThread());
1191 
1192     if (extraData) {
1193         // application event filters are only called for objects in the GUI thread
1194         for (int i = 0; i < extraData->eventFilters.size(); ++i) {
1195             QObject *obj = extraData->eventFilters.at(i);
1196             if (!obj)
1197                 continue;
1198             if (obj->d_func()->threadData != threadData) {
1199                 qWarning("QCoreApplication: Application event filter cannot be in a different thread.");
1200                 continue;
1201             }
1202             if (obj->eventFilter(receiver, event))
1203                 return true;
1204         }
1205     }
1206     return false;
1207 }
1208 
1209 bool QCoreApplicationPrivate::sendThroughObjectEventFilters(QObject *receiver, QEvent *event)
1210 {
1211     if (receiver != QCoreApplication::instance() && receiver->d_func()->extraData) {
1212         for (int i = 0; i < receiver->d_func()->extraData->eventFilters.size(); ++i) {
1213             QObject *obj = receiver->d_func()->extraData->eventFilters.at(i);
1214             if (!obj)
1215                 continue;
1216             if (obj->d_func()->threadData != receiver->d_func()->threadData) {
1217                 qWarning("QCoreApplication: Object event filter cannot be in a different thread.");
1218                 continue;
1219             }
1220             if (obj->eventFilter(receiver, event))
1221                 return true;
1222         }
1223     }
1224     return false;
1225 }
1226 
1227 /*!
1228   \internal
1229 
1230   Helper function called by QCoreApplicationPrivate::notify() and qapplication.cpp
1231  */
1232 bool QCoreApplicationPrivate::notify_helper(QObject *receiver, QEvent * event)
1233 {
1234     // Note: when adjusting the tracepoints in here
1235     // consider adjusting QApplicationPrivate::notify_helper too.
1236     Q_TRACE(QCoreApplication_notify_entry, receiver, event, event->type());
1237     bool consumed = false;
1238     bool filtered = false;
1239     Q_TRACE_EXIT(QCoreApplication_notify_exit, consumed, filtered);
1240 
1241     // send to all application event filters (only does anything in the main thread)
1242     if (QCoreApplication::self
1243             && receiver->d_func()->threadData.loadRelaxed()->thread.loadAcquire() == mainThread()
1244             && QCoreApplication::self->d_func()->sendThroughApplicationEventFilters(receiver, event)) {
1245         filtered = true;
1246         return filtered;
1247     }
1248     // send to all receiver event filters
1249     if (sendThroughObjectEventFilters(receiver, event)) {
1250         filtered = true;
1251         return filtered;
1252     }
1253 
1254     // deliver the event
1255     consumed = receiver->event(event);
1256     return consumed;
1257 }
1258 
1259 /*!
1260   Returns \c true if an application object has not been created yet;
1261   otherwise returns \c false.
1262 
1263   \sa closingDown()
1264 */
1265 
1266 bool QCoreApplication::startingUp()
1267 {
1268     return !QCoreApplicationPrivate::is_app_running;
1269 }
1270 
1271 /*!
1272   Returns \c true if the application objects are being destroyed;
1273   otherwise returns \c false.
1274 
1275   \sa startingUp()
1276 */
1277 
1278 bool QCoreApplication::closingDown()
1279 {
1280     return QCoreApplicationPrivate::is_app_closing;
1281 }
1282 
1283 
1284 /*!
1285     Processes all pending events for the calling thread according to
1286     the specified \a flags until there are no more events to process.
1287 
1288     You can call this function occasionally when your program is busy
1289     performing a long operation (e.g. copying a file).
1290 
1291     In the event that you are running a local loop which calls this function
1292     continuously, without an event loop, the
1293     \l{QEvent::DeferredDelete}{DeferredDelete} events will
1294     not be processed. This can affect the behaviour of widgets,
1295     e.g. QToolTip, that rely on \l{QEvent::DeferredDelete}{DeferredDelete}
1296     events to function properly. An alternative would be to call
1297     \l{QCoreApplication::sendPostedEvents()}{sendPostedEvents()} from
1298     within that local loop.
1299 
1300     Calling this function processes events only for the calling thread,
1301     and returns after all available events have been processed. Available
1302     events are events queued before the function call. This means that
1303     events that are posted while the function runs will be queued until
1304     a later round of event processing.
1305 
1306     \threadsafe
1307 
1308     \sa exec(), QTimer, QEventLoop::processEvents(), flush(), sendPostedEvents()
1309 */
1310 void QCoreApplication::processEvents(QEventLoop::ProcessEventsFlags flags)
1311 {
1312     QThreadData *data = QThreadData::current();
1313     if (!data->hasEventDispatcher())
1314         return;
1315     data->eventDispatcher.loadRelaxed()->processEvents(flags);
1316 }
1317 
1318 /*!
1319     \overload processEvents()
1320 
1321     Processes pending events for the calling thread for \a ms
1322     milliseconds or until there are no more events to process,
1323     whichever is shorter.
1324 
1325     You can call this function occasionally when your program is busy
1326     doing a long operation (e.g. copying a file).
1327 
1328     Calling this function processes events only for the calling thread.
1329 
1330     \note Unlike the \l{QCoreApplication::processEvents(QEventLoop::ProcessEventsFlags flags)}{processEvents()}
1331     overload, this function also processes events that are posted while the function runs.
1332 
1333     \threadsafe
1334 
1335     \sa exec(), QTimer, QEventLoop::processEvents()
1336 */
1337 void QCoreApplication::processEvents(QEventLoop::ProcessEventsFlags flags, int ms)
1338 {
1339     // ### Qt 6: consider splitting this method into a public and a private
1340     //           one, so that a user-invoked processEvents can be detected
1341     //           and handled properly.
1342     QThreadData *data = QThreadData::current();
1343     if (!data->hasEventDispatcher())
1344         return;
1345     QElapsedTimer start;
1346     start.start();
1347     while (data->eventDispatcher.loadRelaxed()->processEvents(flags & ~QEventLoop::WaitForMoreEvents)) {
1348         if (start.elapsed() > ms)
1349             break;
1350     }
1351 }
1352 
1353 /*****************************************************************************
1354   Main event loop wrappers
1355  *****************************************************************************/
1356 
1357 /*!
1358     Enters the main event loop and waits until exit() is called.  Returns
1359     the value that was passed to exit() (which is 0 if exit() is called via
1360     quit()).
1361 
1362     It is necessary to call this function to start event handling. The
1363     main event loop receives events from the window system and
1364     dispatches these to the application widgets.
1365 
1366     To make your application perform idle processing (by executing a
1367     special function whenever there are no pending events), use a
1368     QTimer with 0 timeout. More advanced idle processing schemes can
1369     be achieved using processEvents().
1370 
1371     We recommend that you connect clean-up code to the
1372     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in
1373     your application's \c{main()} function because on some platforms the
1374     exec() call may not return. For example, on Windows
1375     when the user logs off, the system terminates the process after Qt
1376     closes all top-level windows. Hence, there is no guarantee that the
1377     application will have time to exit its event loop and execute code at
1378     the end of the \c{main()} function after the exec()
1379     call.
1380 
1381     \sa quit(), exit(), processEvents(), QApplication::exec()
1382 */
1383 int QCoreApplication::exec()
1384 {
1385     if (!QCoreApplicationPrivate::checkInstance("exec"))
1386         return -1;
1387 
1388     QThreadData *threadData = self->d_func()->threadData;
1389     if (threadData != QThreadData::current()) {
1390         qWarning("%s::exec: Must be called from the main thread", self->metaObject()->className());
1391         return -1;
1392     }
1393     if (!threadData->eventLoops.isEmpty()) {
1394         qWarning("QCoreApplication::exec: The event loop is already running");
1395         return -1;
1396     }
1397 
1398     threadData->quitNow = false;
1399     QEventLoop eventLoop;
1400     self->d_func()->in_exec = true;
1401     self->d_func()->aboutToQuitEmitted = false;
1402     int returnCode = eventLoop.exec();
1403     threadData->quitNow = false;
1404 
1405     if (self)
1406         self->d_func()->execCleanup();
1407 
1408     return returnCode;
1409 }
1410 
1411 
1412 // Cleanup after eventLoop is done executing in QCoreApplication::exec().
1413 // This is for use cases in which QCoreApplication is instantiated by a
1414 // library and not by an application executable, for example, Active X
1415 // servers.
1416 
1417 void QCoreApplicationPrivate::execCleanup()
1418 {
1419     threadData.loadRelaxed()->quitNow = false;
1420     in_exec = false;
1421     if (!aboutToQuitEmitted)
1422         emit q_func()->aboutToQuit(QCoreApplication::QPrivateSignal());
1423     aboutToQuitEmitted = true;
1424     QCoreApplication::sendPostedEvents(nullptr, QEvent::DeferredDelete);
1425 }
1426 
1427 
1428 /*!
1429   Tells the application to exit with a return code.
1430 
1431     After this function has been called, the application leaves the
1432     main event loop and returns from the call to exec(). The exec()
1433     function returns \a returnCode. If the event loop is not running,
1434     this function does nothing.
1435 
1436   By convention, a \a returnCode of 0 means success, and any non-zero
1437   value indicates an error.
1438 
1439   It's good practice to always connect signals to this slot using a
1440   \l{Qt::}{QueuedConnection}. If a signal connected (non-queued) to this slot
1441   is emitted before control enters the main event loop (such as before
1442   "int main" calls \l{QCoreApplication::}{exec()}), the slot has no effect
1443   and the application never exits. Using a queued connection ensures that the
1444   slot will not be invoked until after control enters the main event loop.
1445 
1446   Note that unlike the C library function of the same name, this
1447   function \e does return to the caller -- it is event processing that
1448   stops.
1449 
1450   \sa quit(), exec()
1451 */
1452 void QCoreApplication::exit(int returnCode)
1453 {
1454     if (!self)
1455         return;
1456     QThreadData *data = self->d_func()->threadData.loadRelaxed();
1457     data->quitNow = true;
1458     for (int i = 0; i < data->eventLoops.size(); ++i) {
1459         QEventLoop *eventLoop = data->eventLoops.at(i);
1460         eventLoop->exit(returnCode);
1461     }
1462 }
1463 
1464 /*****************************************************************************
1465   QCoreApplication management of posted events
1466  *****************************************************************************/
1467 
1468 #ifndef QT_NO_QOBJECT
1469 /*!
1470     \fn bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)
1471 
1472     Sends event \a event directly to receiver \a receiver, using the
1473     notify() function. Returns the value that was returned from the
1474     event handler.
1475 
1476     The event is \e not deleted when the event has been sent. The normal
1477     approach is to create the event on the stack, for example:
1478 
1479     \snippet code/src_corelib_kernel_qcoreapplication.cpp 0
1480 
1481     \sa postEvent(), notify()
1482 */
1483 bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)
1484 {
1485     Q_TRACE(QCoreApplication_sendEvent, receiver, event, event->type());
1486 
1487     if (event)
1488         event->spont = false;
1489     return notifyInternal2(receiver, event);
1490 }
1491 
1492 /*!
1493     \internal
1494 */
1495 bool QCoreApplication::sendSpontaneousEvent(QObject *receiver, QEvent *event)
1496 {
1497     Q_TRACE(QCoreApplication_sendSpontaneousEvent, receiver, event, event->type());
1498 
1499     if (event)
1500         event->spont = true;
1501     return notifyInternal2(receiver, event);
1502 }
1503 
1504 #endif // QT_NO_QOBJECT
1505 
1506 QCoreApplicationPrivate::QPostEventListLocker QCoreApplicationPrivate::lockThreadPostEventList(QObject *object)
1507 {
1508     QPostEventListLocker locker;
1509 
1510     if (!object) {
1511         locker.threadData = QThreadData::current();
1512         locker.locker = qt_unique_lock(locker.threadData->postEventList.mutex);
1513         return locker;
1514     }
1515 
1516     auto &threadData = QObjectPrivate::get(object)->threadData;
1517 
1518     // if object has moved to another thread, follow it
1519     for (;;) {
1520         // synchronizes with the storeRelease in QObject::moveToThread
1521         locker.threadData = threadData.loadAcquire();
1522         if (!locker.threadData) {
1523             // destruction in progress
1524             return locker;
1525         }
1526 
1527         auto temporaryLocker = qt_unique_lock(locker.threadData->postEventList.mutex);
1528         if (locker.threadData == threadData.loadAcquire()) {
1529             locker.locker = std::move(temporaryLocker);
1530             break;
1531         }
1532     }
1533 
1534     Q_ASSERT(locker.threadData);
1535     return locker;
1536 }
1537 
1538 /*!
1539     \since 4.3
1540 
1541     Adds the event \a event, with the object \a receiver as the
1542     receiver of the event, to an event queue and returns immediately.
1543 
1544     The event must be allocated on the heap since the post event queue
1545     will take ownership of the event and delete it once it has been
1546     posted.  It is \e {not safe} to access the event after
1547     it has been posted.
1548 
1549     When control returns to the main event loop, all events that are
1550     stored in the queue will be sent using the notify() function.
1551 
1552     Events are sorted in descending \a priority order, i.e. events
1553     with a high \a priority are queued before events with a lower \a
1554     priority. The \a priority can be any integer value, i.e. between
1555     INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for more
1556     details. Events with equal \a priority will be processed in the
1557     order posted.
1558 
1559     \threadsafe
1560 
1561     \sa sendEvent(), notify(), sendPostedEvents(), Qt::EventPriority
1562 */
1563 void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority)
1564 {
1565     Q_TRACE_SCOPE(QCoreApplication_postEvent, receiver, event, event->type());
1566 
1567     if (receiver == nullptr) {
1568         qWarning("QCoreApplication::postEvent: Unexpected null receiver");
1569         delete event;
1570         return;
1571     }
1572 
1573     auto locker = QCoreApplicationPrivate::lockThreadPostEventList(receiver);
1574     if (!locker.threadData) {
1575         // posting during destruction? just delete the event to prevent a leak
1576         delete event;
1577         return;
1578     }
1579 
1580     QThreadData *data = locker.threadData;
1581 
1582     // if this is one of the compressible events, do compression
1583     if (receiver->d_func()->postedEvents
1584         && self && self->compressEvent(event, receiver, &data->postEventList)) {
1585         Q_TRACE(QCoreApplication_postEvent_event_compressed, receiver, event);
1586         return;
1587     }
1588 
1589     if (event->type() == QEvent::DeferredDelete)
1590         receiver->d_ptr->deleteLaterCalled = true;
1591 
1592     if (event->type() == QEvent::DeferredDelete && data == QThreadData::current()) {
1593         // remember the current running eventloop for DeferredDelete
1594         // events posted in the receiver's thread.
1595 
1596         // Events sent by non-Qt event handlers (such as glib) may not
1597         // have the scopeLevel set correctly. The scope level makes sure that
1598         // code like this:
1599         //     foo->deleteLater();
1600         //     qApp->processEvents(); // without passing QEvent::DeferredDelete
1601         // will not cause "foo" to be deleted before returning to the event loop.
1602 
1603         // If the scope level is 0 while loopLevel != 0, we are called from a
1604         // non-conformant code path, and our best guess is that the scope level
1605         // should be 1. (Loop level 0 is special: it means that no event loops
1606         // are running.)
1607         int loopLevel = data->loopLevel;
1608         int scopeLevel = data->scopeLevel;
1609         if (scopeLevel == 0 && loopLevel != 0)
1610             scopeLevel = 1;
1611         static_cast<QDeferredDeleteEvent *>(event)->level = loopLevel + scopeLevel;
1612     }
1613 
1614     // delete the event on exceptions to protect against memory leaks till the event is
1615     // properly owned in the postEventList
1616     QScopedPointer<QEvent> eventDeleter(event);
1617     Q_TRACE(QCoreApplication_postEvent_event_posted, receiver, event, event->type());
1618     data->postEventList.addEvent(QPostEvent(receiver, event, priority));
1619     eventDeleter.take();
1620     event->posted = true;
1621     ++receiver->d_func()->postedEvents;
1622     data->canWait = false;
1623     locker.unlock();
1624 
1625     QAbstractEventDispatcher* dispatcher = data->eventDispatcher.loadAcquire();
1626     if (dispatcher)
1627         dispatcher->wakeUp();
1628 }
1629 
1630 /*!
1631   \internal
1632   Returns \c true if \a event was compressed away (possibly deleted) and should not be added to the list.
1633 */
1634 bool QCoreApplication::compressEvent(QEvent *event, QObject *receiver, QPostEventList *postedEvents)
1635 {
1636 #ifdef Q_OS_WIN
1637     Q_ASSERT(event);
1638     Q_ASSERT(receiver);
1639     Q_ASSERT(postedEvents);
1640 
1641     // compress posted timers to this object.
1642     if (event->type() == QEvent::Timer && receiver->d_func()->postedEvents > 0) {
1643         int timerId = ((QTimerEvent *) event)->timerId();
1644         for (int i=0; i<postedEvents->size(); ++i) {
1645             const QPostEvent &e = postedEvents->at(i);
1646             if (e.receiver == receiver && e.event && e.event->type() == QEvent::Timer
1647                 && ((QTimerEvent *) e.event)->timerId() == timerId) {
1648                 delete event;
1649                 return true;
1650             }
1651         }
1652         return false;
1653     }
1654 #endif
1655 
1656     if (event->type() == QEvent::DeferredDelete) {
1657         if (receiver->d_ptr->deleteLaterCalled) {
1658             // there was a previous DeferredDelete event, so we can drop the new one
1659             delete event;
1660             return true;
1661         }
1662         // deleteLaterCalled is set to true in postedEvents when queueing the very first
1663         // deferred deletion event.
1664         return false;
1665     }
1666 
1667     if (event->type() == QEvent::Quit && receiver->d_func()->postedEvents > 0) {
1668         for (int i = 0; i < postedEvents->size(); ++i) {
1669             const QPostEvent &cur = postedEvents->at(i);
1670             if (cur.receiver != receiver
1671                     || cur.event == nullptr
1672                     || cur.event->type() != event->type())
1673                 continue;
1674             // found an event for this receiver
1675             delete event;
1676             return true;
1677         }
1678     }
1679 
1680     return false;
1681 }
1682 
1683 /*!
1684   Immediately dispatches all events which have been previously queued
1685   with QCoreApplication::postEvent() and which are for the object \a
1686   receiver and have the event type \a event_type.
1687 
1688   Events from the window system are \e not dispatched by this
1689   function, but by processEvents().
1690 
1691   If \a receiver is \nullptr, the events of \a event_type are sent for
1692   all objects. If \a event_type is 0, all the events are sent for
1693   \a receiver.
1694 
1695   \note This method must be called from the thread in which its QObject
1696   parameter, \a receiver, lives.
1697 
1698   \sa flush(), postEvent()
1699 */
1700 void QCoreApplication::sendPostedEvents(QObject *receiver, int event_type)
1701 {
1702     // ### Qt 6: consider splitting this method into a public and a private
1703     //           one, so that a user-invoked sendPostedEvents can be detected
1704     //           and handled properly.
1705     QThreadData *data = QThreadData::current();
1706 
1707     QCoreApplicationPrivate::sendPostedEvents(receiver, event_type, data);
1708 }
1709 
1710 void QCoreApplicationPrivate::sendPostedEvents(QObject *receiver, int event_type,
1711                                                QThreadData *data)
1712 {
1713     if (event_type == -1) {
1714         // we were called by an obsolete event dispatcher.
1715         event_type = 0;
1716     }
1717 
1718     if (receiver && receiver->d_func()->threadData != data) {
1719         qWarning("QCoreApplication::sendPostedEvents: Cannot send "
1720                  "posted events for objects in another thread");
1721         return;
1722     }
1723 
1724     ++data->postEventList.recursion;
1725 
1726     auto locker = qt_unique_lock(data->postEventList.mutex);
1727 
1728     // by default, we assume that the event dispatcher can go to sleep after
1729     // processing all events. if any new events are posted while we send
1730     // events, canWait will be set to false.
1731     data->canWait = (data->postEventList.size() == 0);
1732 
1733     if (data->postEventList.size() == 0 || (receiver && !receiver->d_func()->postedEvents)) {
1734         --data->postEventList.recursion;
1735         return;
1736     }
1737 
1738     data->canWait = true;
1739 
1740     // okay. here is the tricky loop. be careful about optimizing
1741     // this, it looks the way it does for good reasons.
1742     int startOffset = data->postEventList.startOffset;
1743     int &i = (!event_type && !receiver) ? data->postEventList.startOffset : startOffset;
1744     data->postEventList.insertionOffset = data->postEventList.size();
1745 
1746     // Exception-safe cleaning up without the need for a try/catch block
1747     struct CleanUp {
1748         QObject *receiver;
1749         int event_type;
1750         QThreadData *data;
1751         bool exceptionCaught;
1752 
1753         inline CleanUp(QObject *receiver, int event_type, QThreadData *data) :
1754             receiver(receiver), event_type(event_type), data(data), exceptionCaught(true)
1755         {}
1756         inline ~CleanUp()
1757         {
1758             if (exceptionCaught) {
1759                 // since we were interrupted, we need another pass to make sure we clean everything up
1760                 data->canWait = false;
1761             }
1762 
1763             --data->postEventList.recursion;
1764             if (!data->postEventList.recursion && !data->canWait && data->hasEventDispatcher())
1765                 data->eventDispatcher.loadRelaxed()->wakeUp();
1766 
1767             // clear the global list, i.e. remove everything that was
1768             // delivered.
1769             if (!event_type && !receiver && data->postEventList.startOffset >= 0) {
1770                 const QPostEventList::iterator it = data->postEventList.begin();
1771                 data->postEventList.erase(it, it + data->postEventList.startOffset);
1772                 data->postEventList.insertionOffset -= data->postEventList.startOffset;
1773                 Q_ASSERT(data->postEventList.insertionOffset >= 0);
1774                 data->postEventList.startOffset = 0;
1775             }
1776         }
1777     };
1778     CleanUp cleanup(receiver, event_type, data);
1779 
1780     while (i < data->postEventList.size()) {
1781         // avoid live-lock
1782         if (i >= data->postEventList.insertionOffset)
1783             break;
1784 
1785         const QPostEvent &pe = data->postEventList.at(i);
1786         ++i;
1787 
1788         if (!pe.event)
1789             continue;
1790         if ((receiver && receiver != pe.receiver) || (event_type && event_type != pe.event->type())) {
1791             data->canWait = false;
1792             continue;
1793         }
1794 
1795         if (pe.event->type() == QEvent::DeferredDelete) {
1796             // DeferredDelete events are sent either
1797             // 1) when the event loop that posted the event has returned; or
1798             // 2) if explicitly requested (with QEvent::DeferredDelete) for
1799             //    events posted by the current event loop; or
1800             // 3) if the event was posted before the outermost event loop.
1801 
1802             int eventLevel = static_cast<QDeferredDeleteEvent *>(pe.event)->loopLevel();
1803             int loopLevel = data->loopLevel + data->scopeLevel;
1804             const bool allowDeferredDelete =
1805                 (eventLevel > loopLevel
1806                  || (!eventLevel && loopLevel > 0)
1807                  || (event_type == QEvent::DeferredDelete
1808                      && eventLevel == loopLevel));
1809             if (!allowDeferredDelete) {
1810                 // cannot send deferred delete
1811                 if (!event_type && !receiver) {
1812                     // we must copy it first; we want to re-post the event
1813                     // with the event pointer intact, but we can't delay
1814                     // nulling the event ptr until after re-posting, as
1815                     // addEvent may invalidate pe.
1816                     QPostEvent pe_copy = pe;
1817 
1818                     // null out the event so if sendPostedEvents recurses, it
1819                     // will ignore this one, as it's been re-posted.
1820                     const_cast<QPostEvent &>(pe).event = nullptr;
1821 
1822                     // re-post the copied event so it isn't lost
1823                     data->postEventList.addEvent(pe_copy);
1824                 }
1825                 continue;
1826             }
1827         }
1828 
1829         // first, we diddle the event so that we can deliver
1830         // it, and that no one will try to touch it later.
1831         pe.event->posted = false;
1832         QEvent *e = pe.event;
1833         QObject * r = pe.receiver;
1834 
1835         --r->d_func()->postedEvents;
1836         Q_ASSERT(r->d_func()->postedEvents >= 0);
1837 
1838         // next, update the data structure so that we're ready
1839         // for the next event.
1840         const_cast<QPostEvent &>(pe).event = nullptr;
1841 
1842         locker.unlock();
1843         const auto relocker = qScopeGuard([&locker] { locker.lock(); });
1844 
1845         QScopedPointer<QEvent> event_deleter(e); // will delete the event (with the mutex unlocked)
1846 
1847         // after all that work, it's time to deliver the event.
1848         QCoreApplication::sendEvent(r, e);
1849 
1850         // careful when adding anything below this point - the
1851         // sendEvent() call might invalidate any invariants this
1852         // function depends on.
1853     }
1854 
1855     cleanup.exceptionCaught = false;
1856 }
1857 
1858 /*!
1859     \since 4.3
1860 
1861     Removes all events of the given \a eventType that were posted
1862     using postEvent() for \a receiver.
1863 
1864     The events are \e not dispatched, instead they are removed from
1865     the queue. You should never need to call this function. If you do
1866     call it, be aware that killing events may cause \a receiver to
1867     break one or more invariants.
1868 
1869     If \a receiver is \nullptr, the events of \a eventType are removed
1870     for all objects. If \a eventType is 0, all the events are removed
1871     for \a receiver. You should never call this function with \a
1872     eventType of 0.
1873 
1874     \threadsafe
1875 */
1876 
1877 void QCoreApplication::removePostedEvents(QObject *receiver, int eventType)
1878 {
1879     auto locker = QCoreApplicationPrivate::lockThreadPostEventList(receiver);
1880     QThreadData *data = locker.threadData;
1881 
1882     // the QObject destructor calls this function directly.  this can
1883     // happen while the event loop is in the middle of posting events,
1884     // and when we get here, we may not have any more posted events
1885     // for this object.
1886     if (receiver && !receiver->d_func()->postedEvents)
1887         return;
1888 
1889     //we will collect all the posted events for the QObject
1890     //and we'll delete after the mutex was unlocked
1891     QVarLengthArray<QEvent*> events;
1892     int n = data->postEventList.size();
1893     int j = 0;
1894 
1895     for (int i = 0; i < n; ++i) {
1896         const QPostEvent &pe = data->postEventList.at(i);
1897 
1898         if ((!receiver || pe.receiver == receiver)
1899             && (pe.event && (eventType == 0 || pe.event->type() == eventType))) {
1900             --pe.receiver->d_func()->postedEvents;
1901             pe.event->posted = false;
1902             events.append(pe.event);
1903             const_cast<QPostEvent &>(pe).event = nullptr;
1904         } else if (!data->postEventList.recursion) {
1905             if (i != j)
1906                 qSwap(data->postEventList[i], data->postEventList[j]);
1907             ++j;
1908         }
1909     }
1910 
1911 #ifdef QT_DEBUG
1912     if (receiver && eventType == 0) {
1913         Q_ASSERT(!receiver->d_func()->postedEvents);
1914     }
1915 #endif
1916 
1917     if (!data->postEventList.recursion) {
1918         // truncate list
1919         data->postEventList.erase(data->postEventList.begin() + j, data->postEventList.end());
1920     }
1921 
1922     locker.unlock();
1923     qDeleteAll(events);
1924 }
1925 
1926 /*!
1927   Removes \a event from the queue of posted events, and emits a
1928   warning message if appropriate.
1929 
1930   \warning This function can be \e really slow. Avoid using it, if
1931   possible.
1932 
1933   \threadsafe
1934 */
1935 
1936 void QCoreApplicationPrivate::removePostedEvent(QEvent * event)
1937 {
1938     if (!event || !event->posted)
1939         return;
1940 
1941     QThreadData *data = QThreadData::current();
1942 
1943     const auto locker = qt_scoped_lock(data->postEventList.mutex);
1944 
1945     if (data->postEventList.size() == 0) {
1946 #if defined(QT_DEBUG)
1947         qDebug("QCoreApplication::removePostedEvent: Internal error: %p %d is posted",
1948                 (void*)event, event->type());
1949         return;
1950 #endif
1951     }
1952 
1953     for (int i = 0; i < data->postEventList.size(); ++i) {
1954         const QPostEvent & pe = data->postEventList.at(i);
1955         if (pe.event == event) {
1956 #ifndef QT_NO_DEBUG
1957             qWarning("QCoreApplication::removePostedEvent: Event of type %d deleted while posted to %s %s",
1958                      event->type(),
1959                      pe.receiver->metaObject()->className(),
1960                      pe.receiver->objectName().toLocal8Bit().data());
1961 #endif
1962             --pe.receiver->d_func()->postedEvents;
1963             pe.event->posted = false;
1964             delete pe.event;
1965             const_cast<QPostEvent &>(pe).event = nullptr;
1966             return;
1967         }
1968     }
1969 }
1970 
1971 /*!\reimp
1972 
1973 */
1974 bool QCoreApplication::event(QEvent *e)
1975 {
1976     if (e->type() == QEvent::Quit) {
1977         quit();
1978         return true;
1979     }
1980     return QObject::event(e);
1981 }
1982 
1983 /*! \enum QCoreApplication::Encoding
1984     \obsolete
1985 
1986     This enum type used to define the 8-bit encoding of character string
1987     arguments to translate(). This enum is now obsolete and UTF-8 will be
1988     used in all cases.
1989 
1990     \value UnicodeUTF8   UTF-8.
1991     \omitvalue Latin1
1992     \omitvalue DefaultCodec \omit UTF-8. \endomit
1993     \omitvalue CodecForTr
1994 
1995     \sa QObject::tr(), QString::fromUtf8()
1996 */
1997 
1998 void QCoreApplicationPrivate::ref()
1999 {
2000     quitLockRef.ref();
2001 }
2002 
2003 void QCoreApplicationPrivate::deref()
2004 {
2005     if (!quitLockRef.deref())
2006         maybeQuit();
2007 }
2008 
2009 void QCoreApplicationPrivate::maybeQuit()
2010 {
2011     if (quitLockRef.loadRelaxed() == 0 && in_exec && quitLockRefEnabled && shouldQuit())
2012         QCoreApplication::postEvent(QCoreApplication::instance(), new QEvent(QEvent::Quit));
2013 }
2014 
2015 /*!
2016     Tells the application to exit with return code 0 (success).
2017     Equivalent to calling QCoreApplication::exit(0).
2018 
2019     It's common to connect the QGuiApplication::lastWindowClosed() signal
2020     to quit(), and you also often connect e.g. QAbstractButton::clicked() or
2021     signals in QAction, QMenu, or QMenuBar to it.
2022 
2023     It's good practice to always connect signals to this slot using a
2024     \l{Qt::}{QueuedConnection}. If a signal connected (non-queued) to this slot
2025     is emitted before control enters the main event loop (such as before
2026     "int main" calls \l{QCoreApplication::}{exec()}), the slot has no effect
2027     and the application never exits. Using a queued connection ensures that the
2028     slot will not be invoked until after control enters the main event loop.
2029 
2030     Example:
2031 
2032     \snippet code/src_corelib_kernel_qcoreapplication.cpp 1
2033 
2034     \sa exit(), aboutToQuit(), QGuiApplication::lastWindowClosed()
2035 */
2036 
2037 void QCoreApplication::quit()
2038 {
2039     exit(0);
2040 }
2041 
2042 /*!
2043   \fn void QCoreApplication::aboutToQuit()
2044 
2045   This signal is emitted when the application is about to quit the
2046   main event loop, e.g. when the event loop level drops to zero.
2047   This may happen either after a call to quit() from inside the
2048   application or when the user shuts down the entire desktop session.
2049 
2050   The signal is particularly useful if your application has to do some
2051   last-second cleanup. Note that no user interaction is possible in
2052   this state.
2053 
2054   \sa quit()
2055 */
2056 
2057 #endif // QT_NO_QOBJECT
2058 
2059 #ifndef QT_NO_TRANSLATION
2060 /*!
2061     Adds the translation file \a translationFile to the list of
2062     translation files to be used for translations.
2063 
2064     Multiple translation files can be installed. Translations are
2065     searched for in the reverse order in which they were installed,
2066     so the most recently installed translation file is searched first
2067     and the first translation file installed is searched last.
2068     The search stops as soon as a translation containing a matching
2069     string is found.
2070 
2071     Installing or removing a QTranslator, or changing an installed QTranslator
2072     generates a \l{QEvent::LanguageChange}{LanguageChange} event for the
2073     QCoreApplication instance. A QApplication instance will propagate the event
2074     to all toplevel widgets, where a reimplementation of changeEvent can
2075     re-translate the user interface by passing user-visible strings via the
2076     tr() function to the respective property setters. User-interface classes
2077     generated by Qt Designer provide a \c retranslateUi() function that can be
2078     called.
2079 
2080     The function returns \c true on success and false on failure.
2081 
2082     \sa removeTranslator(), translate(), QTranslator::load(), {Dynamic Translation}
2083 */
2084 
2085 bool QCoreApplication::installTranslator(QTranslator *translationFile)
2086 {
2087     if (!translationFile)
2088         return false;
2089 
2090     if (!QCoreApplicationPrivate::checkInstance("installTranslator"))
2091         return false;
2092     QCoreApplicationPrivate *d = self->d_func();
2093     {
2094         QWriteLocker locker(&d->translateMutex);
2095         d->translators.prepend(translationFile);
2096     }
2097 
2098 #ifndef QT_NO_TRANSLATION_BUILDER
2099     if (translationFile->isEmpty())
2100         return false;
2101 #endif
2102 
2103 #ifndef QT_NO_QOBJECT
2104     QEvent ev(QEvent::LanguageChange);
2105     QCoreApplication::sendEvent(self, &ev);
2106 #endif
2107 
2108     return true;
2109 }
2110 
2111 /*!
2112     Removes the translation file \a translationFile from the list of
2113     translation files used by this application. (It does not delete the
2114     translation file from the file system.)
2115 
2116     The function returns \c true on success and false on failure.
2117 
2118     \sa installTranslator(), translate(), QObject::tr()
2119 */
2120 
2121 bool QCoreApplication::removeTranslator(QTranslator *translationFile)
2122 {
2123     if (!translationFile)
2124         return false;
2125     if (!QCoreApplicationPrivate::checkInstance("removeTranslator"))
2126         return false;
2127     QCoreApplicationPrivate *d = self->d_func();
2128     QWriteLocker locker(&d->translateMutex);
2129     if (d->translators.removeAll(translationFile)) {
2130 #ifndef QT_NO_QOBJECT
2131         locker.unlock();
2132         if (!self->closingDown()) {
2133             QEvent ev(QEvent::LanguageChange);
2134             QCoreApplication::sendEvent(self, &ev);
2135         }
2136 #endif
2137         return true;
2138     }
2139     return false;
2140 }
2141 
2142 static void replacePercentN(QString *result, int n)
2143 {
2144     if (n >= 0) {
2145         int percentPos = 0;
2146         int len = 0;
2147         while ((percentPos = result->indexOf(QLatin1Char('%'), percentPos + len)) != -1) {
2148             len = 1;
2149             if (percentPos + len == result->length())
2150                 break;
2151             QString fmt;
2152             if (result->at(percentPos + len) == QLatin1Char('L')) {
2153                 ++len;
2154                 if (percentPos + len == result->length())
2155                     break;
2156                 fmt = QLatin1String("%L1");
2157             } else {
2158                 fmt = QLatin1String("%1");
2159             }
2160             if (result->at(percentPos + len) == QLatin1Char('n')) {
2161                 fmt = fmt.arg(n);
2162                 ++len;
2163                 result->replace(percentPos, len, fmt);
2164                 len = fmt.length();
2165             }
2166         }
2167     }
2168 }
2169 
2170 /*!
2171     \threadsafe
2172 
2173     Returns the translation text for \a sourceText, by querying the
2174     installed translation files. The translation files are searched
2175     from the most recently installed file back to the first
2176     installed file.
2177 
2178     QObject::tr() provides this functionality more conveniently.
2179 
2180     \a context is typically a class name (e.g., "MyDialog") and \a
2181     sourceText is either English text or a short identifying text.
2182 
2183     \a disambiguation is an identifying string, for when the same \a
2184     sourceText is used in different roles within the same context. By
2185     default, it is \nullptr.
2186 
2187     See the \l QTranslator and \l QObject::tr() documentation for
2188     more information about contexts, disambiguations and comments.
2189 
2190     \a n is used in conjunction with \c %n to support plural forms.
2191     See QObject::tr() for details.
2192 
2193     If none of the translation files contain a translation for \a
2194     sourceText in \a context, this function returns a QString
2195     equivalent of \a sourceText.
2196 
2197     This function is not virtual. You can use alternative translation
2198     techniques by subclassing \l QTranslator.
2199 
2200     \sa QObject::tr(), installTranslator(), removeTranslator(), translate()
2201 */
2202 QString QCoreApplication::translate(const char *context, const char *sourceText,
2203                                     const char *disambiguation, int n)
2204 {
2205     QString result;
2206 
2207     if (!sourceText)
2208         return result;
2209 
2210     if (self) {
2211         QCoreApplicationPrivate *d = self->d_func();
2212         QReadLocker locker(&d->translateMutex);
2213         if (!d->translators.isEmpty()) {
2214             QList<QTranslator*>::ConstIterator it;
2215             QTranslator *translationFile;
2216             for (it = d->translators.constBegin(); it != d->translators.constEnd(); ++it) {
2217                 translationFile = *it;
2218                 result = translationFile->translate(context, sourceText, disambiguation, n);
2219                 if (!result.isNull())
2220                     break;
2221             }
2222         }
2223     }
2224 
2225     if (result.isNull())
2226         result = QString::fromUtf8(sourceText);
2227 
2228     replacePercentN(&result, n);
2229     return result;
2230 }
2231 
2232 /*! \fn static QString QCoreApplication::translate(const char *context, const char *key, const char *disambiguation, Encoding encoding, int n = -1)
2233 
2234   \obsolete
2235 */
2236 
2237 // Declared in qglobal.h
2238 QString qtTrId(const char *id, int n)
2239 {
2240     return QCoreApplication::translate(nullptr, id, nullptr, n);
2241 }
2242 
2243 bool QCoreApplicationPrivate::isTranslatorInstalled(QTranslator *translator)
2244 {
2245     if (!QCoreApplication::self)
2246         return false;
2247     QCoreApplicationPrivate *d = QCoreApplication::self->d_func();
2248     QReadLocker locker(&d->translateMutex);
2249     return d->translators.contains(translator);
2250 }
2251 
2252 #else
2253 
2254 QString QCoreApplication::translate(const char *context, const char *sourceText,
2255                                     const char *disambiguation, int n)
2256 {
2257     Q_UNUSED(context)
2258     Q_UNUSED(disambiguation)
2259     QString ret = QString::fromUtf8(sourceText);
2260     if (n >= 0)
2261         ret.replace(QLatin1String("%n"), QString::number(n));
2262     return ret;
2263 }
2264 
2265 #endif //QT_NO_TRANSLATION
2266 
2267 // Makes it possible to point QCoreApplication to a custom location to ensure
2268 // the directory is added to the patch, and qt.conf and deployed plugins are
2269 // found from there. This is for use cases in which QGuiApplication is
2270 // instantiated by a library and not by an application executable, for example,
2271 // Active X servers.
2272 
2273 void QCoreApplicationPrivate::setApplicationFilePath(const QString &path)
2274 {
2275     if (QCoreApplicationPrivate::cachedApplicationFilePath)
2276         *QCoreApplicationPrivate::cachedApplicationFilePath = path;
2277     else
2278         QCoreApplicationPrivate::cachedApplicationFilePath = new QString(path);
2279 }
2280 
2281 /*!
2282     Returns the directory that contains the application executable.
2283 
2284     For example, if you have installed Qt in the \c{C:\Qt}
2285     directory, and you run the \c{regexp} example, this function will
2286     return "C:/Qt/examples/tools/regexp".
2287 
2288     On \macos and iOS this will point to the directory actually containing
2289     the executable, which may be inside an application bundle (if the
2290     application is bundled).
2291 
2292     \warning On Linux, this function will try to get the path from the
2293     \c {/proc} file system. If that fails, it assumes that \c
2294     {argv[0]} contains the absolute file name of the executable. The
2295     function also assumes that the current directory has not been
2296     changed by the application.
2297 
2298     \sa applicationFilePath()
2299 */
2300 QString QCoreApplication::applicationDirPath()
2301 {
2302     if (!self) {
2303         qWarning("QCoreApplication::applicationDirPath: Please instantiate the QApplication object first");
2304         return QString();
2305     }
2306 
2307     QCoreApplicationPrivate *d = self->d_func();
2308     if (d->cachedApplicationDirPath.isNull())
2309         d->cachedApplicationDirPath = QFileInfo(applicationFilePath()).path();
2310     return d->cachedApplicationDirPath;
2311 }
2312 
2313 /*!
2314     Returns the file path of the application executable.
2315 
2316     For example, if you have installed Qt in the \c{/usr/local/qt}
2317     directory, and you run the \c{regexp} example, this function will
2318     return "/usr/local/qt/examples/tools/regexp/regexp".
2319 
2320     \warning On Linux, this function will try to get the path from the
2321     \c {/proc} file system. If that fails, it assumes that \c
2322     {argv[0]} contains the absolute file name of the executable. The
2323     function also assumes that the current directory has not been
2324     changed by the application.
2325 
2326     \sa applicationDirPath()
2327 */
2328 QString QCoreApplication::applicationFilePath()
2329 {
2330     if (!self) {
2331         qWarning("QCoreApplication::applicationFilePath: Please instantiate the QApplication object first");
2332         return QString();
2333     }
2334 
2335     QCoreApplicationPrivate *d = self->d_func();
2336 
2337     if (d->argc) {
2338         static QByteArray procName = QByteArray(d->argv[0]);
2339         if (procName != d->argv[0]) {
2340             // clear the cache if the procname changes, so we reprocess it.
2341             QCoreApplicationPrivate::clearApplicationFilePath();
2342             procName = QByteArray(d->argv[0]);
2343         }
2344     }
2345 
2346     if (QCoreApplicationPrivate::cachedApplicationFilePath)
2347         return *QCoreApplicationPrivate::cachedApplicationFilePath;
2348 
2349 #if defined(Q_OS_WIN)
2350     QCoreApplicationPrivate::setApplicationFilePath(QFileInfo(qAppFileName()).filePath());
2351     return *QCoreApplicationPrivate::cachedApplicationFilePath;
2352 #elif defined(Q_OS_MAC)
2353     QString qAppFileName_str = qAppFileName();
2354     if(!qAppFileName_str.isEmpty()) {
2355         QFileInfo fi(qAppFileName_str);
2356         if (fi.exists()) {
2357             QCoreApplicationPrivate::setApplicationFilePath(fi.canonicalFilePath());
2358             return *QCoreApplicationPrivate::cachedApplicationFilePath;
2359         }
2360     }
2361 #endif
2362 #if defined( Q_OS_UNIX )
2363 #  if defined(Q_OS_LINUX) && (!defined(Q_OS_ANDROID) || defined(Q_OS_ANDROID_EMBEDDED))
2364     // Try looking for a /proc/<pid>/exe symlink first which points to
2365     // the absolute path of the executable
2366     QFileInfo pfi(QString::fromLatin1("/proc/%1/exe").arg(getpid()));
2367     if (pfi.exists() && pfi.isSymLink()) {
2368         QCoreApplicationPrivate::setApplicationFilePath(pfi.canonicalFilePath());
2369         return *QCoreApplicationPrivate::cachedApplicationFilePath;
2370     }
2371 #  endif
2372     if (!arguments().isEmpty()) {
2373         QString argv0 = QFile::decodeName(arguments().at(0).toLocal8Bit());
2374         QString absPath;
2375 
2376         if (!argv0.isEmpty() && argv0.at(0) == QLatin1Char('/')) {
2377             /*
2378               If argv0 starts with a slash, it is already an absolute
2379               file path.
2380             */
2381             absPath = argv0;
2382         } else if (argv0.contains(QLatin1Char('/'))) {
2383             /*
2384               If argv0 contains one or more slashes, it is a file path
2385               relative to the current directory.
2386             */
2387             absPath = QDir::current().absoluteFilePath(argv0);
2388         } else {
2389             /*
2390               Otherwise, the file path has to be determined using the
2391               PATH environment variable.
2392             */
2393             absPath = QStandardPaths::findExecutable(argv0);
2394         }
2395 
2396         absPath = QDir::cleanPath(absPath);
2397 
2398         QFileInfo fi(absPath);
2399         if (fi.exists()) {
2400             QCoreApplicationPrivate::setApplicationFilePath(fi.canonicalFilePath());
2401             return *QCoreApplicationPrivate::cachedApplicationFilePath;
2402         }
2403     }
2404 
2405 #endif
2406     return QString();
2407 }
2408 
2409 /*!
2410     \since 4.4
2411 
2412     Returns the current process ID for the application.
2413 */
2414 qint64 QCoreApplication::applicationPid()
2415 {
2416 #if defined(Q_OS_WIN)
2417     return GetCurrentProcessId();
2418 #elif defined(Q_OS_VXWORKS)
2419     return (pid_t) taskIdCurrent;
2420 #else
2421     return getpid();
2422 #endif
2423 }
2424 
2425 /*!
2426     \since 4.1
2427 
2428     Returns the list of command-line arguments.
2429 
2430     Usually arguments().at(0) is the program name, arguments().at(1)
2431     is the first argument, and arguments().last() is the last
2432     argument. See the note below about Windows.
2433 
2434     Calling this function is slow - you should store the result in a variable
2435     when parsing the command line.
2436 
2437     \warning On Unix, this list is built from the argc and argv parameters passed
2438     to the constructor in the main() function. The string-data in argv is
2439     interpreted using QString::fromLocal8Bit(); hence it is not possible to
2440     pass, for example, Japanese command line arguments on a system that runs in a
2441     Latin1 locale. Most modern Unix systems do not have this limitation, as they are
2442     Unicode-based.
2443 
2444     On Windows, the list is built from the argc and argv parameters only if
2445     modified argv/argc parameters are passed to the constructor. In that case,
2446     encoding problems might occur.
2447 
2448     Otherwise, the arguments() are constructed from the return value of
2449     \l{http://msdn2.microsoft.com/en-us/library/ms683156(VS.85).aspx}{GetCommandLine()}.
2450     As a result of this, the string given by arguments().at(0) might not be
2451     the program name on Windows, depending on how the application was started.
2452 
2453     \sa applicationFilePath(), QCommandLineParser
2454 */
2455 
2456 QStringList QCoreApplication::arguments()
2457 {
2458     QStringList list;
2459 
2460     if (!self) {
2461         qWarning("QCoreApplication::arguments: Please instantiate the QApplication object first");
2462         return list;
2463     }
2464     const int ac = self->d_func()->argc;
2465     char ** const av = self->d_func()->argv;
2466     list.reserve(ac);
2467 
2468 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
2469     // On Windows, it is possible to pass Unicode arguments on
2470     // the command line. To restore those, we split the command line
2471     // and filter out arguments that were deleted by derived application
2472     // classes by index.
2473     QString cmdline = QString::fromWCharArray(GetCommandLine());
2474 
2475     const QCoreApplicationPrivate *d = self->d_func();
2476     if (d->origArgv) {
2477         const QStringList allArguments = qWinCmdArgs(cmdline);
2478         Q_ASSERT(allArguments.size() == d->origArgc);
2479         for (int i = 0; i < d->origArgc; ++i) {
2480             if (contains(ac, av, d->origArgv[i]))
2481                 list.append(allArguments.at(i));
2482         }
2483         return list;
2484     } // Fall back to rebuilding from argv/argc when a modified argv was passed.
2485 #endif // defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
2486 
2487     for (int a = 0; a < ac; ++a) {
2488         list << QString::fromLocal8Bit(av[a]);
2489     }
2490 
2491     return list;
2492 }
2493 
2494 /*!
2495     \property QCoreApplication::organizationName
2496     \brief the name of the organization that wrote this application
2497 
2498     The value is used by the QSettings class when it is constructed
2499     using the empty constructor. This saves having to repeat this
2500     information each time a QSettings object is created.
2501 
2502     On Mac, QSettings uses \l {QCoreApplication::}{organizationDomain()} as the organization
2503     if it's not an empty string; otherwise it uses
2504     organizationName(). On all other platforms, QSettings uses
2505     organizationName() as the organization.
2506 
2507     \sa organizationDomain, applicationName
2508 */
2509 
2510 /*!
2511   \fn void QCoreApplication::organizationNameChanged()
2512   \internal
2513 
2514   While not useful from C++ due to how organizationName is normally set once on
2515   startup, this is still needed for QML so that bindings are reevaluated after
2516   that initial change.
2517 */
2518 void QCoreApplication::setOrganizationName(const QString &orgName)
2519 {
2520     if (coreappdata()->orgName == orgName)
2521         return;
2522     coreappdata()->orgName = orgName;
2523 #ifndef QT_NO_QOBJECT
2524     if (QCoreApplication::self)
2525         emit QCoreApplication::self->organizationNameChanged();
2526 #endif
2527 }
2528 
2529 QString QCoreApplication::organizationName()
2530 {
2531     return coreappdata()->orgName;
2532 }
2533 
2534 /*!
2535     \property QCoreApplication::organizationDomain
2536     \brief the Internet domain of the organization that wrote this application
2537 
2538     The value is used by the QSettings class when it is constructed
2539     using the empty constructor. This saves having to repeat this
2540     information each time a QSettings object is created.
2541 
2542     On Mac, QSettings uses organizationDomain() as the organization
2543     if it's not an empty string; otherwise it uses organizationName().
2544     On all other platforms, QSettings uses organizationName() as the
2545     organization.
2546 
2547     \sa organizationName, applicationName, applicationVersion
2548 */
2549 /*!
2550   \fn void QCoreApplication::organizationDomainChanged()
2551   \internal
2552 
2553   Primarily for QML, see organizationNameChanged.
2554 */
2555 void QCoreApplication::setOrganizationDomain(const QString &orgDomain)
2556 {
2557     if (coreappdata()->orgDomain == orgDomain)
2558         return;
2559     coreappdata()->orgDomain = orgDomain;
2560 #ifndef QT_NO_QOBJECT
2561     if (QCoreApplication::self)
2562         emit QCoreApplication::self->organizationDomainChanged();
2563 #endif
2564 }
2565 
2566 QString QCoreApplication::organizationDomain()
2567 {
2568     return coreappdata()->orgDomain;
2569 }
2570 
2571 /*!
2572     \property QCoreApplication::applicationName
2573     \brief the name of this application
2574 
2575     The value is used by the QSettings class when it is constructed
2576     using the empty constructor. This saves having to repeat this
2577     information each time a QSettings object is created.
2578 
2579     If not set, the application name defaults to the executable name (since 5.0).
2580 
2581     \sa organizationName, organizationDomain, applicationVersion, applicationFilePath()
2582 */
2583 /*!
2584   \fn void QCoreApplication::applicationNameChanged()
2585   \internal
2586 
2587   Primarily for QML, see organizationNameChanged.
2588 */
2589 void QCoreApplication::setApplicationName(const QString &application)
2590 {
2591     coreappdata()->applicationNameSet = !application.isEmpty();
2592     QString newAppName = application;
2593     if (newAppName.isEmpty() && QCoreApplication::self)
2594         newAppName = QCoreApplication::self->d_func()->appName();
2595     if (coreappdata()->application == newAppName)
2596         return;
2597     coreappdata()->application = newAppName;
2598 #ifndef QT_NO_QOBJECT
2599     if (QCoreApplication::self)
2600         emit QCoreApplication::self->applicationNameChanged();
2601 #endif
2602 }
2603 
2604 QString QCoreApplication::applicationName()
2605 {
2606     return coreappdata() ? coreappdata()->application : QString();
2607 }
2608 
2609 // Exported for QDesktopServices (Qt4 behavior compatibility)
2610 Q_CORE_EXPORT QString qt_applicationName_noFallback()
2611 {
2612     return coreappdata()->applicationNameSet ? coreappdata()->application : QString();
2613 }
2614 
2615 /*!
2616     \property QCoreApplication::applicationVersion
2617     \since 4.4
2618     \brief the version of this application
2619 
2620     If not set, the application version defaults to a platform-specific value
2621     determined from the main application executable or package (since Qt 5.9):
2622 
2623     \table
2624     \header
2625         \li Platform
2626         \li Source
2627     \row
2628         \li Windows (classic desktop)
2629         \li PRODUCTVERSION parameter of the VERSIONINFO resource
2630     \row
2631         \li Universal Windows Platform
2632         \li version attribute of the application package manifest
2633     \row
2634         \li macOS, iOS, tvOS, watchOS
2635         \li CFBundleVersion property of the information property list
2636     \row
2637         \li Android
2638         \li android:versionName property of the AndroidManifest.xml manifest element
2639     \endtable
2640 
2641     On other platforms, the default is the empty string.
2642 
2643     \sa applicationName, organizationName, organizationDomain
2644 */
2645 /*!
2646   \fn void QCoreApplication::applicationVersionChanged()
2647   \internal
2648 
2649   Primarily for QML, see organizationNameChanged.
2650 */
2651 void QCoreApplication::setApplicationVersion(const QString &version)
2652 {
2653     coreappdata()->applicationVersionSet = !version.isEmpty();
2654     QString newVersion = version;
2655     if (newVersion.isEmpty() && QCoreApplication::self)
2656         newVersion = QCoreApplication::self->d_func()->appVersion();
2657     if (coreappdata()->applicationVersion == newVersion)
2658         return;
2659     coreappdata()->applicationVersion = newVersion;
2660 #ifndef QT_NO_QOBJECT
2661     if (QCoreApplication::self)
2662         emit QCoreApplication::self->applicationVersionChanged();
2663 #endif
2664 }
2665 
2666 QString QCoreApplication::applicationVersion()
2667 {
2668     return coreappdata() ? coreappdata()->applicationVersion : QString();
2669 }
2670 
2671 #if QT_CONFIG(library)
2672 
2673 Q_GLOBAL_STATIC(QRecursiveMutex, libraryPathMutex)
2674 
2675 /*!
2676     Returns a list of paths that the application will search when
2677     dynamically loading libraries.
2678 
2679     The return value of this function may change when a QCoreApplication
2680     is created. It is not recommended to call it before creating a
2681     QCoreApplication. The directory of the application executable (\b not
2682     the working directory) is part of the list if it is known. In order
2683     to make it known a QCoreApplication has to be constructed as it will
2684     use \c {argv[0]} to find it.
2685 
2686     Qt provides default library paths, but they can also be set using
2687     a \l{Using qt.conf}{qt.conf} file. Paths specified in this file
2688     will override default values. Note that if the qt.conf file is in
2689     the directory of the application executable, it may not be found
2690     until a QCoreApplication is created. If it is not found when calling
2691     this function, the default library paths will be used.
2692 
2693     The list will include the installation directory for plugins if
2694     it exists (the default installation directory for plugins is \c
2695     INSTALL/plugins, where \c INSTALL is the directory where Qt was
2696     installed). The colon separated entries of the \c QT_PLUGIN_PATH
2697     environment variable are always added. The plugin installation
2698     directory (and its existence) may change when the directory of
2699     the application executable becomes known.
2700 
2701     If you want to iterate over the list, you can use the \l foreach
2702     pseudo-keyword:
2703 
2704     \snippet code/src_corelib_kernel_qcoreapplication.cpp 2
2705 
2706     \sa setLibraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary,
2707         {How to Create Qt Plugins}
2708 */
2709 QStringList QCoreApplication::libraryPaths()
2710 {
2711     QMutexLocker locker(libraryPathMutex());
2712     return libraryPathsLocked();
2713 }
2714 
2715 /*!
2716     \internal
2717 */
2718 QStringList QCoreApplication::libraryPathsLocked()
2719 {
2720     if (coreappdata()->manual_libpaths)
2721         return *(coreappdata()->manual_libpaths);
2722 
2723     if (!coreappdata()->app_libpaths) {
2724         QStringList *app_libpaths = new QStringList;
2725         coreappdata()->app_libpaths.reset(app_libpaths);
2726 
2727         auto setPathsFromEnv = [&](QString libPathEnv) {
2728             if (!libPathEnv.isEmpty()) {
2729                 QStringList paths = libPathEnv.split(QDir::listSeparator(), Qt::SkipEmptyParts);
2730                 for (QStringList::const_iterator it = paths.constBegin(); it != paths.constEnd(); ++it) {
2731                     QString canonicalPath = QDir(*it).canonicalPath();
2732                     if (!canonicalPath.isEmpty()
2733                         && !app_libpaths->contains(canonicalPath)) {
2734                         app_libpaths->append(canonicalPath);
2735                     }
2736                 }
2737             }
2738         };
2739         setPathsFromEnv(qEnvironmentVariable("QT_PLUGIN_PATH"));
2740 #ifdef Q_OS_ANDROID
2741         setPathsFromEnv(qEnvironmentVariable("QT_BUNDLED_LIBS_PATH"));
2742 #endif
2743 #ifdef Q_OS_DARWIN
2744         // Check the main bundle's PlugIns directory as this is a standard location for Apple OSes.
2745         // Note that the QLibraryInfo::PluginsPath below will coincidentally be the same as this value
2746         // but with a different casing, so it can't be relied upon when the underlying filesystem
2747         // is case sensitive (and this is always the case on newer OSes like iOS).
2748         if (CFBundleRef bundleRef = CFBundleGetMainBundle()) {
2749             if (QCFType<CFURLRef> urlRef = CFBundleCopyBuiltInPlugInsURL(bundleRef)) {
2750                 if (QCFType<CFURLRef> absoluteUrlRef = CFURLCopyAbsoluteURL(urlRef)) {
2751                     if (QCFString path = CFURLCopyFileSystemPath(absoluteUrlRef, kCFURLPOSIXPathStyle)) {
2752                         if (QFile::exists(path)) {
2753                             path = QDir(path).canonicalPath();
2754                             if (!app_libpaths->contains(path))
2755                                 app_libpaths->append(path);
2756                         }
2757                     }
2758                 }
2759             }
2760         }
2761 #endif // Q_OS_DARWIN
2762 
2763         QString installPathPlugins =  QLibraryInfo::location(QLibraryInfo::PluginsPath);
2764         if (QFile::exists(installPathPlugins)) {
2765             // Make sure we convert from backslashes to slashes.
2766             installPathPlugins = QDir(installPathPlugins).canonicalPath();
2767             if (!app_libpaths->contains(installPathPlugins))
2768                 app_libpaths->append(installPathPlugins);
2769         }
2770 
2771         // If QCoreApplication is not yet instantiated,
2772         // make sure we add the application path when we construct the QCoreApplication
2773         if (self) self->d_func()->appendApplicationPathToLibraryPaths();
2774     }
2775     return *(coreappdata()->app_libpaths);
2776 }
2777 
2778 
2779 
2780 /*!
2781 
2782     Sets the list of directories to search when loading libraries to
2783     \a paths. All existing paths will be deleted and the path list
2784     will consist of the paths given in \a paths.
2785 
2786     The library paths are reset to the default when an instance of
2787     QCoreApplication is destructed.
2788 
2789     \sa libraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary
2790  */
2791 void QCoreApplication::setLibraryPaths(const QStringList &paths)
2792 {
2793     QMutexLocker locker(libraryPathMutex());
2794 
2795     // setLibraryPaths() is considered a "remove everything and then add some new ones" operation.
2796     // When the application is constructed it should still amend the paths. So we keep the originals
2797     // around, and even create them if they don't exist, yet.
2798     if (!coreappdata()->app_libpaths)
2799         libraryPathsLocked();
2800 
2801     if (coreappdata()->manual_libpaths)
2802         *(coreappdata()->manual_libpaths) = paths;
2803     else
2804         coreappdata()->manual_libpaths.reset(new QStringList(paths));
2805 
2806     locker.unlock();
2807     QFactoryLoader::refreshAll();
2808 }
2809 
2810 /*!
2811   Prepends \a path to the beginning of the library path list, ensuring that
2812   it is searched for libraries first. If \a path is empty or already in the
2813   path list, the path list is not changed.
2814 
2815   The default path list consists of a single entry, the installation
2816   directory for plugins.  The default installation directory for plugins
2817   is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was
2818   installed.
2819 
2820   The library paths are reset to the default when an instance of
2821   QCoreApplication is destructed.
2822 
2823   \sa removeLibraryPath(), libraryPaths(), setLibraryPaths()
2824  */
2825 void QCoreApplication::addLibraryPath(const QString &path)
2826 {
2827     if (path.isEmpty())
2828         return;
2829 
2830     QString canonicalPath = QDir(path).canonicalPath();
2831     if (canonicalPath.isEmpty())
2832         return;
2833 
2834     QMutexLocker locker(libraryPathMutex());
2835 
2836     QStringList *libpaths = coreappdata()->manual_libpaths.data();
2837     if (libpaths) {
2838         if (libpaths->contains(canonicalPath))
2839             return;
2840     } else {
2841         // make sure that library paths are initialized
2842         libraryPathsLocked();
2843         QStringList *app_libpaths = coreappdata()->app_libpaths.data();
2844         if (app_libpaths->contains(canonicalPath))
2845             return;
2846 
2847         coreappdata()->manual_libpaths.reset(libpaths = new QStringList(*app_libpaths));
2848     }
2849 
2850     libpaths->prepend(canonicalPath);
2851     locker.unlock();
2852     QFactoryLoader::refreshAll();
2853 }
2854 
2855 /*!
2856     Removes \a path from the library path list. If \a path is empty or not
2857     in the path list, the list is not changed.
2858 
2859     The library paths are reset to the default when an instance of
2860     QCoreApplication is destructed.
2861 
2862     \sa addLibraryPath(), libraryPaths(), setLibraryPaths()
2863 */
2864 void QCoreApplication::removeLibraryPath(const QString &path)
2865 {
2866     if (path.isEmpty())
2867         return;
2868 
2869     QString canonicalPath = QDir(path).canonicalPath();
2870     if (canonicalPath.isEmpty())
2871         return;
2872 
2873     QMutexLocker locker(libraryPathMutex());
2874 
2875     QStringList *libpaths = coreappdata()->manual_libpaths.data();
2876     if (libpaths) {
2877         if (libpaths->removeAll(canonicalPath) == 0)
2878             return;
2879     } else {
2880         // make sure that library paths is initialized
2881         libraryPathsLocked();
2882         QStringList *app_libpaths = coreappdata()->app_libpaths.data();
2883         if (!app_libpaths->contains(canonicalPath))
2884             return;
2885 
2886         coreappdata()->manual_libpaths.reset(libpaths = new QStringList(*app_libpaths));
2887         libpaths->removeAll(canonicalPath);
2888     }
2889 
2890     locker.unlock();
2891     QFactoryLoader::refreshAll();
2892 }
2893 
2894 #endif // QT_CONFIG(library)
2895 
2896 #ifndef QT_NO_QOBJECT
2897 
2898 /*!
2899     Installs an event filter \a filterObj for all native events
2900     received by the application in the main thread.
2901 
2902     The event filter \a filterObj receives events via its \l {QAbstractNativeEventFilter::}{nativeEventFilter()}
2903     function, which is called for all native events received in the main thread.
2904 
2905     The QAbstractNativeEventFilter::nativeEventFilter() function should
2906     return true if the event should be filtered, i.e. stopped. It should
2907     return false to allow normal Qt processing to continue: the native
2908     event can then be translated into a QEvent and handled by the standard
2909     Qt \l{QEvent} {event} filtering, e.g. QObject::installEventFilter().
2910 
2911     If multiple event filters are installed, the filter that was
2912     installed last is activated first.
2913 
2914     \note The filter function set here receives native messages,
2915     i.e. MSG or XCB event structs.
2916 
2917     \note Native event filters will be disabled in the application when the
2918     Qt::AA_PluginApplication attribute is set.
2919 
2920     For maximum portability, you should always try to use QEvent
2921     and QObject::installEventFilter() whenever possible.
2922 
2923     \sa QObject::installEventFilter()
2924 
2925     \since 5.0
2926 */
2927 void QCoreApplication::installNativeEventFilter(QAbstractNativeEventFilter *filterObj)
2928 {
2929     if (QCoreApplication::testAttribute(Qt::AA_PluginApplication)) {
2930         qWarning("Native event filters are not applied when the Qt::AA_PluginApplication attribute is set");
2931         return;
2932     }
2933 
2934     QAbstractEventDispatcher *eventDispatcher = QAbstractEventDispatcher::instance(QCoreApplicationPrivate::theMainThread.loadAcquire());
2935     if (!filterObj || !eventDispatcher)
2936         return;
2937     eventDispatcher->installNativeEventFilter(filterObj);
2938 }
2939 
2940 /*!
2941     Removes an event \a filterObject from this object. The
2942     request is ignored if such an event filter has not been installed.
2943 
2944     All event filters for this object are automatically removed when
2945     this object is destroyed.
2946 
2947     It is always safe to remove an event filter, even during event
2948     filter activation (i.e. from the nativeEventFilter() function).
2949 
2950     \sa installNativeEventFilter()
2951     \since 5.0
2952 */
2953 void QCoreApplication::removeNativeEventFilter(QAbstractNativeEventFilter *filterObject)
2954 {
2955     QAbstractEventDispatcher *eventDispatcher = QAbstractEventDispatcher::instance();
2956     if (!filterObject || !eventDispatcher)
2957         return;
2958     eventDispatcher->removeNativeEventFilter(filterObject);
2959 }
2960 
2961 /*!
2962     \deprecated
2963 
2964     This function returns \c true if there are pending events; otherwise
2965     returns \c false. Pending events can be either from the window
2966     system or posted events using postEvent().
2967 
2968     \note this function is not thread-safe. It may only be called in the main
2969     thread and only if there are no other threads running in the application
2970     (including threads Qt starts for its own purposes).
2971 
2972     \sa QAbstractEventDispatcher::hasPendingEvents()
2973 */
2974 #if QT_DEPRECATED_SINCE(5, 3)
2975 bool QCoreApplication::hasPendingEvents()
2976 {
2977     QAbstractEventDispatcher *eventDispatcher = QAbstractEventDispatcher::instance();
2978     if (eventDispatcher)
2979         return eventDispatcher->hasPendingEvents();
2980     return false;
2981 }
2982 #endif
2983 
2984 /*!
2985     Returns a pointer to the event dispatcher object for the main thread. If no
2986     event dispatcher exists for the thread, this function returns \nullptr.
2987 */
2988 QAbstractEventDispatcher *QCoreApplication::eventDispatcher()
2989 {
2990     if (QCoreApplicationPrivate::theMainThread.loadAcquire())
2991         return QCoreApplicationPrivate::theMainThread.loadRelaxed()->eventDispatcher();
2992     return nullptr;
2993 }
2994 
2995 /*!
2996     Sets the event dispatcher for the main thread to \a eventDispatcher. This
2997     is only possible as long as there is no event dispatcher installed yet. That
2998     is, before QCoreApplication has been instantiated. This method takes
2999     ownership of the object.
3000 */
3001 void QCoreApplication::setEventDispatcher(QAbstractEventDispatcher *eventDispatcher)
3002 {
3003     QThread *mainThread = QCoreApplicationPrivate::theMainThread.loadAcquire();
3004     if (!mainThread)
3005         mainThread = QThread::currentThread(); // will also setup theMainThread
3006     mainThread->setEventDispatcher(eventDispatcher);
3007 }
3008 
3009 #endif // QT_NO_QOBJECT
3010 
3011 /*!
3012     \macro Q_COREAPP_STARTUP_FUNCTION(QtStartUpFunction ptr)
3013     \since 5.1
3014     \relates QCoreApplication
3015     \reentrant
3016 
3017     Adds a global function that will be called from the QCoreApplication
3018     constructor. This macro is normally used to initialize libraries
3019     for program-wide functionality, without requiring the application to
3020     call into the library for initialization.
3021 
3022     The function specified by \a ptr should take no arguments and should
3023     return nothing. For example:
3024 
3025     \snippet code/src_corelib_kernel_qcoreapplication.cpp 3
3026 
3027     Note that the startup function will run at the end of the QCoreApplication constructor,
3028     before any GUI initialization. If GUI code is required in the function,
3029     use a timer (or a queued invocation) to perform the initialization later on,
3030     from the event loop.
3031 
3032     If QCoreApplication is deleted and another QCoreApplication is created,
3033     the startup function will be invoked again.
3034 
3035     \note This macro is not suitable for use in library code that is then
3036     statically linked into an application since the function may not be called
3037     at all due to being eliminated by the linker.
3038 */
3039 
3040 /*!
3041     \fn void qAddPostRoutine(QtCleanUpFunction ptr)
3042     \threadsafe
3043     \relates QCoreApplication
3044 
3045     Adds a global routine that will be called from the QCoreApplication
3046     destructor. This function is normally used to add cleanup routines
3047     for program-wide functionality.
3048 
3049     The cleanup routines are called in the reverse order of their addition.
3050 
3051     The function specified by \a ptr should take no arguments and should
3052     return nothing. For example:
3053 
3054     \snippet code/src_corelib_kernel_qcoreapplication.cpp 4
3055 
3056     Note that for an application- or module-wide cleanup, qAddPostRoutine()
3057     is often not suitable. For example, if the program is split into dynamically
3058     loaded modules, the relevant module may be unloaded long before the
3059     QCoreApplication destructor is called. In such cases, if using qAddPostRoutine()
3060     is still desirable, qRemovePostRoutine() can be used to prevent a routine
3061     from being called by the QCoreApplication destructor. For example, if that
3062     routine was called before the module was unloaded.
3063 
3064     For modules and libraries, using a reference-counted
3065     initialization manager or Qt's parent-child deletion mechanism may
3066     be better. Here is an example of a private class that uses the
3067     parent-child mechanism to call a cleanup function at the right
3068     time:
3069 
3070     \snippet code/src_corelib_kernel_qcoreapplication.cpp 5
3071 
3072     By selecting the right parent object, this can often be made to
3073     clean up the module's data at the right moment.
3074 
3075     \note This function has been thread-safe since Qt 5.10.
3076 
3077     \sa qRemovePostRoutine()
3078 */
3079 
3080 /*!
3081     \fn void qRemovePostRoutine(QtCleanUpFunction ptr)
3082     \threadsafe
3083     \relates QCoreApplication
3084     \since 5.3
3085 
3086     Removes the cleanup routine specified by \a ptr from the list of
3087     routines called by the QCoreApplication destructor. The routine
3088     must have been previously added to the list by a call to
3089     qAddPostRoutine(), otherwise this function has no effect.
3090 
3091     \note This function has been thread-safe since Qt 5.10.
3092 
3093     \sa qAddPostRoutine()
3094 */
3095 
3096 /*!
3097     \macro Q_DECLARE_TR_FUNCTIONS(context)
3098     \relates QCoreApplication
3099 
3100     The Q_DECLARE_TR_FUNCTIONS() macro declares and implements two
3101     translation functions, \c tr() and \c trUtf8(), with these
3102     signatures:
3103 
3104     \snippet code/src_corelib_kernel_qcoreapplication.cpp 6
3105 
3106     This macro is useful if you want to use QObject::tr() or
3107     QObject::trUtf8() in classes that don't inherit from QObject.
3108 
3109     Q_DECLARE_TR_FUNCTIONS() must appear at the very top of the
3110     class definition (before the first \c{public:} or \c{protected:}).
3111     For example:
3112 
3113     \snippet code/src_corelib_kernel_qcoreapplication.cpp 7
3114 
3115     The \a context parameter is normally the class name, but it can
3116     be any text.
3117 
3118     \sa Q_OBJECT, QObject::tr(), QObject::trUtf8()
3119 */
3120 
3121 QT_END_NAMESPACE
3122 
3123 #ifndef QT_NO_QOBJECT
3124 #include "moc_qcoreapplication.cpp"
3125 #endif
