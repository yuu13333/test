Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
Make bindings introspectable through moc

Add a new BINDABLE declaration to the Q_PROPERTY() macro that tells moc
where to find the QBindable for the property.

Add a QUntypedBindable base class to QBindable<T> that gives access to
generic functionality and checks argument compatibility at runtime.
QBindable<T> will still do static checking at compile time.

Add QMetaProperty::isBindable() and QMetaProperty::bindable()
to be able to dynamically access the binding functionality.

Change-Id: Ic7b08ae2cde83fd43e627d813a886e1de01fa3dc

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #ifndef QPROPERTY_H
41 #define QPROPERTY_H
42 
43 #include <QtCore/qglobal.h>
44 #include <QtCore/QSharedDataPointer>
45 #include <QtCore/QString>
46 #include <functional>
47 #include <type_traits>
48 #include <variant>
49 
50 #include <QtCore/qpropertyprivate.h>
51 
52 #if __has_include(<source_location>) && __cplusplus >= 202002L && !defined(Q_CLANG_QDOC)
53 #include <experimental/source_location>
54 #define QT_PROPERTY_COLLECT_BINDING_LOCATION
55 #define QT_PROPERTY_DEFAULT_BINDING_LOCATION QPropertyBindingSourceLocation(std::source_location::current())
56 #elif __has_include(<experimental/source_location>) && __cplusplus >= 201703L && !defined(Q_CLANG_QDOC)
57 #include <experimental/source_location>
58 #define QT_PROPERTY_COLLECT_BINDING_LOCATION
59 #define QT_PROPERTY_DEFAULT_BINDING_LOCATION QPropertyBindingSourceLocation(std::experimental::source_location::current())
60 #else
61 #define QT_PROPERTY_DEFAULT_BINDING_LOCATION QPropertyBindingSourceLocation()
62 #endif
63 
64 QT_BEGIN_NAMESPACE
65 
66 template <typename T>
67 class QPropertyData : public QUntypedPropertyData
68 {
69 protected:
70     mutable T val = T();
71 private:
72     class DisableRValueRefs {};
73 protected:
74     static constexpr bool UseReferences = !(std::is_arithmetic_v<T> || std::is_enum_v<T> || std::is_pointer_v<T>);
75 public:
76     using value_type = T;
77     using parameter_type = std::conditional_t<UseReferences, const T &, T>;
78     using rvalue_ref = typename std::conditional_t<UseReferences, T &&, DisableRValueRefs>;
79     using arrow_operator_result = std::conditional_t<!UseReferences, void,
80                                         std::conditional_t<QTypeTraits::is_dereferencable_v<T>, parameter_type, const T *>>;
81 
82     QPropertyData() = default;
83     QPropertyData(parameter_type t) : val(t) {}
84     QPropertyData(rvalue_ref t) : val(std::move(t)) {}
85     ~QPropertyData() = default;
86 
87     parameter_type valueBypassingBindings() const { return val; }
88     void setValueBypassingBindings(parameter_type v) { val = v; }
89     void setValueBypassingBindings(rvalue_ref v) { val = std::move(v); }
90 };
91 
92 struct Q_CORE_EXPORT QPropertyBindingSourceLocation
93 {
94     const char *fileName = nullptr;
95     const char *functionName = nullptr;
96     quint32 line = 0;
97     quint32 column = 0;
98     QPropertyBindingSourceLocation() = default;
99 #ifdef QT_PROPERTY_COLLECT_BINDING_LOCATION
100     QPropertyBindingSourceLocation(const std::experimental::source_location &cppLocation)
101     {
102         fileName = cppLocation.file_name();
103         functionName = cppLocation.function_name();
104         line = cppLocation.line();
105         column = cppLocation.column();
106     }
107 #endif
108 };
109 
110 template <typename Functor> class QPropertyChangeHandler;
111 class QPropertyBindingErrorPrivate;
112 
113 class Q_CORE_EXPORT QPropertyBindingError
114 {
115 public:
116     enum Type {
117         NoError,
118         BindingLoop,
119         EvaluationError,
120         UnknownError
121     };
122 
123     QPropertyBindingError();
124     QPropertyBindingError(Type type, const QString &description = QString());
125 
126     QPropertyBindingError(const QPropertyBindingError &other);
127     QPropertyBindingError &operator=(const QPropertyBindingError &other);
128     QPropertyBindingError(QPropertyBindingError &&other);
129     QPropertyBindingError &operator=(QPropertyBindingError &&other);
130     ~QPropertyBindingError();
131 
132     bool hasError() const { return d.get() != nullptr; }
133     Type type() const;
134     QString description() const;
135 
136 private:
137     QSharedDataPointer<QPropertyBindingErrorPrivate> d;
138 };
139 
140 class Q_CORE_EXPORT QUntypedPropertyBinding
141 {
142 public:
143     // writes binding result into dataPtr
144     using BindingEvaluationFunction = QtPrivate::QPropertyBindingFunction;
145 
146     QUntypedPropertyBinding();
147     QUntypedPropertyBinding(QMetaType metaType, BindingEvaluationFunction function, const QPropertyBindingSourceLocation &location);
148     QUntypedPropertyBinding(QUntypedPropertyBinding &&other);
149     QUntypedPropertyBinding(const QUntypedPropertyBinding &other);
150     QUntypedPropertyBinding &operator=(const QUntypedPropertyBinding &other);
151     QUntypedPropertyBinding &operator=(QUntypedPropertyBinding &&other);
152     ~QUntypedPropertyBinding();
153 
154     bool isNull() const;
155 
156     QPropertyBindingError error() const;
157 
158     QMetaType valueMetaType() const;
159 
160     explicit QUntypedPropertyBinding(QPropertyBindingPrivate *priv);
161 private:
162     friend class QtPrivate::QPropertyBindingData;
163     friend class QPropertyBindingPrivate;
164     template <typename> friend class QPropertyBinding;
165     QPropertyBindingPrivatePtr d;
166 };
167 
168 template <typename PropertyType>
169 class QPropertyBinding : public QUntypedPropertyBinding
170 {
171     template <typename Functor>
172     struct BindingAdaptor
173     {
174         Functor impl;
175         bool operator()(QMetaType /*metaType*/, QUntypedPropertyData *dataPtr)
176         {
177             QPropertyData<PropertyType> *propertyPtr = static_cast<QPropertyData<PropertyType> *>(dataPtr);
178             PropertyType newValue = impl();
179             if constexpr (QTypeTraits::has_operator_equal_v<PropertyType>) {
180                 if (newValue == propertyPtr->valueBypassingBindings())
181                     return false;
182             }
183             propertyPtr->setValueBypassingBindings(std::move(newValue));
184             return true;
185         }
186     };
187 
188 public:
189     QPropertyBinding() = default;
190 
191     template<typename Functor>
192     QPropertyBinding(Functor &&f, const QPropertyBindingSourceLocation &location)
193         : QUntypedPropertyBinding(QMetaType::fromType<PropertyType>(), BindingAdaptor<Functor>{std::forward<Functor>(f)}, location)
194     {}
195 
196     template<typename Property, typename = std::void_t<decltype(&Property::bindingData)>>
197     QPropertyBinding(const Property &property)
198         : QUntypedPropertyBinding(property.bindingData().binding())
199     {}
200 
201     // Internal
202     explicit QPropertyBinding(const QUntypedPropertyBinding &binding)
203         : QUntypedPropertyBinding(binding)
204     {}
205 };
206 
207 namespace Qt {
208     template <typename Functor>
209     auto makePropertyBinding(Functor &&f, const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION,
210                              std::enable_if_t<std::is_invocable_v<Functor>> * = 0)
211     {
212         return QPropertyBinding<std::invoke_result_t<Functor>>(std::forward<Functor>(f), location);
213     }
214 }
215 
216 struct QPropertyObserverPrivate;
217 struct QPropertyObserverPointer;
218 
219 class Q_CORE_EXPORT QPropertyObserver
220 {
221 public:
222     // Internal
223     enum ObserverTag {
224         ObserverNotifiesBinding,
225         ObserverNotifiesChangeHandler,
226         ObserverNotifiesAlias,
227     };
228 
229     QPropertyObserver() = default;
230     QPropertyObserver(QPropertyObserver &&other);
231     QPropertyObserver &operator=(QPropertyObserver &&other);
232     ~QPropertyObserver();
233 
234     template<typename Property, typename = std::enable_if<std::is_same_v<decltype(std::declval<Property>().bindingData()), QtPrivate::QPropertyBindingData &>>>
235     void setSource(const Property &property)
236     { setSource(property.bindingData()); }
237     void setSource(const QtPrivate::QPropertyBindingData &property);
238 
239 protected:
240     using ChangeHandler = void (*)(QPropertyObserver*, QUntypedPropertyData *);
241     QPropertyObserver(ChangeHandler changeHandler);
242     QPropertyObserver(QUntypedPropertyData *aliasedPropertyPtr);
243 
244     QUntypedPropertyData *aliasedProperty() const
245     {
246         return aliasedPropertyData;
247     }
248 
249 private:
250 
251     QTaggedPointer<QPropertyObserver, ObserverTag> next;
252     // prev is a pointer to the "next" element within the previous node, or to the "firstObserverPtr" if it is the
253     // first node.
254     QtPrivate::QTagPreservingPointerToPointer<QPropertyObserver, ObserverTag> prev;
255 
256     union {
257         QPropertyBindingPrivate *bindingToMarkDirty = nullptr;
258         ChangeHandler changeHandler;
259         QUntypedPropertyData *aliasedPropertyData;
260     };
261 
262     QPropertyObserver(const QPropertyObserver &) = delete;
263     QPropertyObserver &operator=(const QPropertyObserver &) = delete;
264 
265     friend struct QPropertyObserverPointer;
266     friend struct QPropertyBindingDataPointer;
267     friend class QPropertyBindingPrivate;
268 };
269 
270 template <typename Functor>
271 class QPropertyChangeHandler : public QPropertyObserver
272 {
273     Functor m_handler;
274 public:
275     QPropertyChangeHandler(Functor handler)
276         : QPropertyObserver([](QPropertyObserver *self, QUntypedPropertyData *) {
277               auto This = static_cast<QPropertyChangeHandler<Functor>*>(self);
278               This->m_handler();
279           })
280         , m_handler(handler)
281     {
282     }
283 
284     template<typename Property, typename = std::void_t<decltype(&Property::bindingData)>>
285     QPropertyChangeHandler(const Property &property, Functor handler)
286         : QPropertyObserver([](QPropertyObserver *self, QUntypedPropertyData *) {
287               auto This = static_cast<QPropertyChangeHandler<Functor>*>(self);
288               This->m_handler();
289           })
290         , m_handler(handler)
291     {
292         setSource(property);
293     }
294 };
295 
296 template <typename T>
297 class QProperty : public QPropertyData<T>
298 {
299     QtPrivate::QPropertyBindingData d;
300     bool is_equal(const T &v)
301     {
302         if constexpr (QTypeTraits::has_operator_equal_v<T>) {
303             if (v == this->val)
304                 return true;
305         }
306         return false;
307     }
308 
309 public:
310     using value_type = typename QPropertyData<T>::value_type;
311     using parameter_type = typename QPropertyData<T>::parameter_type;
312     using rvalue_ref = typename QPropertyData<T>::rvalue_ref;
313     using arrow_operator_result = typename QPropertyData<T>::arrow_operator_result;
314 
315     QProperty() = default;
316     explicit QProperty(parameter_type initialValue) : QPropertyData<T>(initialValue) {}
317     explicit QProperty(rvalue_ref initialValue) : QPropertyData<T>(std::move(initialValue)) {}
318     QProperty(QProperty &&other) : QPropertyData<T>(std::move(other.val)), d(std::move(other.d), this) { notify(); }
319     explicit QProperty(const QPropertyBinding<T> &binding)
320         : QProperty()
321     { setBinding(binding); }
322 #ifndef Q_CLANG_QDOC
323     template <typename Functor>
324     explicit QProperty(Functor &&f, const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION,
325                        typename std::enable_if_t<std::is_invocable_r_v<T, Functor&>> * = 0)
326         : QProperty(QPropertyBinding<T>(std::forward<Functor>(f), location))
327     {}
328 #else
329     template <typename Functor>
330     explicit QProperty(Functor &&f);
331 #endif
332     QProperty &operator=(QProperty &&other) { this->val = std::move(other.val); d.moveAssign(std::move(other.d), this); notify(); return *this; }
333     ~QProperty() = default;
334 
335     parameter_type value() const
336     {
337         if (d.hasBinding())
338             d.evaluateIfDirty(this);
339         d.registerWithCurrentlyEvaluatingBinding();
340         return this->val;
341     }
342 
343     arrow_operator_result operator->() const
344     {
345         if constexpr (QTypeTraits::is_dereferencable_v<T>)
346             return value();
347         else if constexpr (QPropertyData<T>::UseReferences)
348             return &value();
349         else
350             return;
351     }
352 
353     parameter_type operator*() const
354     {
355         return value();
356     }
357 
358     operator parameter_type() const
359     {
360         return value();
361     }
362 
363     void setValue(rvalue_ref newValue)
364     {
365         d.removeBinding();
366         if (is_equal(newValue))
367             return;
368         this->val = std::move(newValue);
369         notify();
370     }
371 
372     void setValue(parameter_type newValue)
373     {
374         d.removeBinding();
375         if (is_equal(newValue))
376             return;
377         this->val = newValue;
378         notify();
379     }
380 
381     QProperty<T> &operator=(rvalue_ref newValue)
382     {
383         setValue(std::move(newValue));
384         return *this;
385     }
386 
387     QProperty<T> &operator=(parameter_type newValue)
388     {
389         setValue(newValue);
390         return *this;
391     }
392 
393     QPropertyBinding<T> setBinding(const QPropertyBinding<T> &newBinding)
394     {
395         QPropertyBinding<T> oldBinding(d.setBinding(newBinding, this));
396         notify();
397         return oldBinding;
398     }
399 
400     bool setBinding(const QUntypedPropertyBinding &newBinding)
401     {
402         if (!newBinding.isNull() && newBinding.valueMetaType().id() != qMetaTypeId<T>())
403             return false;
404         setBinding(static_cast<const QPropertyBinding<T> &>(newBinding));
405         return true;
406     }
407 
408 #ifndef Q_CLANG_QDOC
409     template <typename Functor>
410     QPropertyBinding<T> setBinding(Functor &&f,
411                                    const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION,
412                                    std::enable_if_t<std::is_invocable_v<Functor>> * = nullptr)
413     {
414         return setBinding(Qt::makePropertyBinding(std::forward<Functor>(f), location));
415     }
416 #else
417     template <typename Functor>
418     QPropertyBinding<T> setBinding(Functor f);
419 #endif
420 
421     bool hasBinding() const { return d.hasBinding(); }
422 
423     QPropertyBinding<T> binding() const
424     {
425         return QPropertyBinding<T>(*this);
426     }
427 
428     QPropertyBinding<T> takeBinding()
429     {
430         return QPropertyBinding<T>(d.setBinding(QUntypedPropertyBinding(), this));
431     }
432 
433     template<typename Functor>
434     QPropertyChangeHandler<Functor> onValueChanged(Functor f)
435     {
436 #if defined(__cpp_lib_is_invocable) && (__cpp_lib_is_invocable >= 201703L)
437         static_assert(std::is_invocable_v<Functor>, "Functor callback must be callable without any parameters");
438 #endif
439         return QPropertyChangeHandler<Functor>(*this, f);
440     }
441 
442     template<typename Functor>
443     QPropertyChangeHandler<Functor> subscribe(Functor f)
444     {
445 #if defined(__cpp_lib_is_invocable) && (__cpp_lib_is_invocable >= 201703L)
446         static_assert(std::is_invocable_v<Functor>, "Functor callback must be callable without any parameters");
447 #endif
448         f();
449         return onValueChanged(f);
450     }
451 
452     const QtPrivate::QPropertyBindingData &bindingData() const { return d; }
453 private:
454     void notify()
455     {
456         d.notifyObservers(this);
457     }
458 
459     Q_DISABLE_COPY(QProperty)
460 };
461 
462 namespace Qt {
463     template <typename PropertyType>
464     QPropertyBinding<PropertyType> makePropertyBinding(const QProperty<PropertyType> &otherProperty,
465                                                        const QPropertyBindingSourceLocation &location =
466                                                        QT_PROPERTY_DEFAULT_BINDING_LOCATION)
467     {
468         return Qt::makePropertyBinding([&otherProperty]() -> PropertyType { return otherProperty; }, location);
469     }
470 }
471 
472 template<typename T>
473 class QPropertyAlias : public QPropertyObserver
474 {
475     Q_DISABLE_COPY_MOVE(QPropertyAlias)
476     QProperty<T> *aliasedProperty() const
477     {
478         return static_cast<QProperty<T> *>(QPropertyObserver::aliasedProperty());
479     }
480 
481 public:
482     QPropertyAlias(QProperty<T> *property)
483         : QPropertyObserver(property)
484     {
485         if (property)
486             setSource(*property);
487     }
488 
489     QPropertyAlias(QPropertyAlias<T> *alias)
490         : QPropertyAlias(alias->aliasedProperty())
491     {}
492 
493     T value() const
494     {
495         if (auto *p = aliasedProperty())
496             return p->value();
497         return T();
498     }
499 
500     operator T() const { return value(); }
501 
502     void setValue(T &&newValue)
503     {
504         if (auto *p = aliasedProperty())
505             p->setValue(std::move(newValue));
506     }
507 
508     void setValue(const T &newValue)
509     {
510         if (auto *p = aliasedProperty())
511             p->setValue(newValue);
512     }
513 
514     QPropertyAlias<T> &operator=(T &&newValue)
515     {
516         if (auto *p = aliasedProperty())
517             *p = std::move(newValue);
518         return *this;
519     }
520 
521     QPropertyAlias<T> &operator=(const T &newValue)
522     {
523         if (auto *p = aliasedProperty())
524             *p = newValue;
525         return *this;
526     }
527 
528     QPropertyBinding<T> setBinding(const QPropertyBinding<T> &newBinding)
529     {
530         if (auto *p = aliasedProperty())
531             return p->setBinding(newBinding);
532         return QPropertyBinding<T>();
533     }
534 
535     QPropertyBinding<T> setBinding(QPropertyBinding<T> &&newBinding)
536     {
537         if (auto *p = aliasedProperty())
538             return p->setBinding(std::move(newBinding));
539         return QPropertyBinding<T>();
540     }
541 
542     bool setBinding(const QUntypedPropertyBinding &newBinding)
543     {
544         if (auto *p = aliasedProperty())
545             return p->setBinding(newBinding);
546         return false;
547     }
548 
549 #ifndef Q_CLANG_QDOC
550     template <typename Functor>
551     QPropertyBinding<T> setBinding(Functor &&f,
552                                    const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION,
553                                    std::enable_if_t<std::is_invocable_v<Functor>> * = nullptr)
554     {
555         return setBinding(Qt::makePropertyBinding(std::forward<Functor>(f), location));
556     }
557 #else
558     template <typename Functor>
559     QPropertyBinding<T> setBinding(Functor f);
560 #endif
561 
562     bool hasBinding() const
563     {
564         if (auto *p = aliasedProperty())
565             return p->hasBinding();
566         return false;
567     }
568 
569     QPropertyBinding<T> binding() const
570     {
571         if (auto *p = aliasedProperty())
572             return p->binding();
573         return QPropertyBinding<T>();
574     }
575 
576     QPropertyBinding<T> takeBinding()
577     {
578         if (auto *p = aliasedProperty())
579             return p->takeBinding();
580         return QPropertyBinding<T>();
581     }
582 
583     template<typename Functor>
584     QPropertyChangeHandler<Functor> onValueChanged(Functor f)
585     {
586         if (auto *p = aliasedProperty())
587             return p->onValueChanged(f);
588         return QPropertyChangeHandler<Functor>(f);
589     }
590 
591     template<typename Functor>
592     QPropertyChangeHandler<Functor> subscribe(Functor f)
593     {
594         if (auto *p = aliasedProperty())
595             return p->subscribe(f);
596         return QPropertyChangeHandler<Functor>(f);
597     }
598 
599     bool isValid() const
600     {
601         return aliasedProperty() != nullptr;
602     }
603 };
604 
605 namespace QtPrivate
606 {
607 
608 struct QBindableInterface
609 {
610     using BindingGetter = QUntypedPropertyBinding (*)(const QUntypedPropertyData *d);
611     using BindingSetter = QUntypedPropertyBinding (*)(QUntypedPropertyData *d, const QUntypedPropertyBinding &binding);
612     using MakeBinding = QUntypedPropertyBinding (*)(const QUntypedPropertyData *d, const QPropertyBindingSourceLocation &location);
613     using SetObserver = void (*)(const QUntypedPropertyData *d, QPropertyObserver *observer);
614     BindingGetter getBinding;
615     BindingSetter setBinding;
616     MakeBinding makeBinding;
617     SetObserver setObserver;
618     QMetaType metaType;
619 };
620 
621 template<typename Property, typename = void>
622 class QBindableInterfaceForProperty
623 {
624     using T = typename Property::value_type;
625 public:
626     static constexpr QBindableInterface interface = {
627         nullptr,
628         nullptr,
629         [](const QUntypedPropertyData *d, const QPropertyBindingSourceLocation &location) -> QUntypedPropertyBinding
630         { return Qt::makePropertyBinding([d]() -> T { return static_cast<const Property *>(d)->value(); }, location); },
631         [](const QUntypedPropertyData *d, QPropertyObserver *observer) -> void
632         { observer->setSource(static_cast<const Property *>(d)->bindingData()); },
633         QMetaType::fromType<T>()
634     };
635 };
636 
637 template<typename Property>
638 class QBindableInterfaceForProperty<Property, std::void_t<decltype(std::declval<Property>().binding())>>
639 {
640     using T = typename Property::value_type;
641 public:
642     static constexpr QBindableInterface interface = {
643         [](const QUntypedPropertyData *d) -> QUntypedPropertyBinding
644         { return static_cast<const Property *>(d)->binding(); },
645         [](QUntypedPropertyData *d, const QUntypedPropertyBinding &binding) -> QUntypedPropertyBinding
646         { return static_cast<Property *>(d)->setBinding(static_cast<const QPropertyBinding<T> &>(binding)); },
647         [](const QUntypedPropertyData *d, const QPropertyBindingSourceLocation &location) -> QUntypedPropertyBinding
648         { return Qt::makePropertyBinding([d]() -> T { return static_cast<const Property *>(d)->value(); }, location); },
649         [](const QUntypedPropertyData *d, QPropertyObserver *observer) -> void
650         { observer->setSource(static_cast<const Property *>(d)->bindingData()); },
651         QMetaType::fromType<T>()
652     };
653 };
654 
655 }
656 
657 class QUntypedBindable
658 {
659 protected:
660     QUntypedPropertyData *data = nullptr;
661     const QtPrivate::QBindableInterface *iface = nullptr;
662 
663 public:
664     constexpr QUntypedBindable() = default;
665     template<typename Property>
666     QUntypedBindable(Property *p)
667         : data(const_cast<std::remove_cv_t<Property> *>(p)),
668           iface(&QtPrivate::QBindableInterfaceForProperty<Property>::interface)
669     { Q_ASSERT(data && iface); }
670 
671     bool isValid() const { return data != nullptr; }
672     bool isBindable() const { return iface && iface->getBinding; }
673 
674     QUntypedPropertyBinding makeBinding(const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION)
675     {
676         return iface->makeBinding(data, location);
677     }
678     void observe(QPropertyObserver *observer)
679     {
680         iface->setObserver(data, observer);
681     }
682 
683     template<typename Functor>
684     QPropertyChangeHandler<Functor> onValueChanged(Functor f)
685     {
686         QPropertyChangeHandler<Functor> handler(f);
687         observe(&handler);
688         return handler;
689     }
690 
691     template<typename Functor>
692     QPropertyChangeHandler<Functor> subscribe(Functor f)
693     {
694         f();
695         return onValueChanged(f);
696     }
697 
698     QUntypedPropertyBinding binding() const
699     {
700         if (!iface->getBinding)
701             return QUntypedPropertyBinding();
702         return iface->getBinding(data);
703     }
704     bool setBinding(const QUntypedPropertyBinding &binding)
705     {
706         if (!iface->setBinding)
707             return false;
708         if (!binding.isNull() && binding.valueMetaType() != iface->metaType)
709             return false;
710         iface->setBinding(data, binding);
711         return true;
712     }
713     bool hasBinding() const
714     {
715         return !binding().isNull();
716     }
717 
718 };
719 
720 template<typename T>
721 class QBindable : public QUntypedBindable
722 {
723 public:
724     using QUntypedBindable::QUntypedBindable;
725     explicit QBindable(const QUntypedBindable &b) : QUntypedBindable(b) {}
726 
727     QPropertyBinding<T> makeBinding(const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION)
728     {
729         return static_cast<QPropertyBinding<T> &&>(iface->makeBinding(data, location));
730     }
731     QPropertyBinding<T> binding() const
732     {
733         return static_cast<QPropertyBinding<T> &&>(QUntypedBindable::binding());
734     }
735     using QUntypedBindable::setBinding;
736     QPropertyBinding<T> setBinding(const QPropertyBinding<T> &binding)
737     {
738         return static_cast<QPropertyBinding<T> &&>(iface->setBinding(data, binding));
739     }
740 #ifndef Q_CLANG_QDOC
741     template <typename Functor>
742     QPropertyBinding<T> setBinding(Functor &&f,
743                                    const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION,
744                                    std::enable_if_t<std::is_invocable_v<Functor>> * = nullptr)
745     {
746         return setBinding(Qt::makePropertyBinding(std::forward<Functor>(f), location));
747     }
748 #else
749     template <typename Functor>
750     QPropertyBinding<T> setBinding(Functor f);
751 #endif
752 };
753 
754 struct QBindingStatus;
755 
756 struct QBindingStorageData;
757 class Q_CORE_EXPORT QBindingStorage
758 {
759     mutable QBindingStorageData *d = nullptr;
760     QBindingStatus *bindingStatus = nullptr;
761 
762     template<typename Class, typename T, auto Offset, auto Setter>
763     friend class QObjectCompatProperty;
764 public:
765     QBindingStorage();
766     ~QBindingStorage();
767 
768     void maybeUpdateBindingAndRegister(const QUntypedPropertyData *data) const;
769     QtPrivate::QPropertyBindingData *bindingData(const QUntypedPropertyData *data) const;
770     QtPrivate::QPropertyBindingData *bindingData(QUntypedPropertyData *data, bool create);
771 };
772 
773 
774 template<typename Class, typename T, auto Offset, auto Signal = nullptr>
775 class QObjectBindableProperty : public QPropertyData<T>
776 {
777     using ThisType = QObjectBindableProperty<Class, T, Offset, Signal>;
778     static bool constexpr HasSignal = !std::is_same_v<decltype(Signal), std::nullptr_t>;
779     static constexpr size_t offset = QtPrivate::detail::getOffset(Offset);
780     Class *owner()
781     {
782         char *that = reinterpret_cast<char *>(this);
783         return reinterpret_cast<Class *>(that - offset);
784     }
785     const Class *owner() const
786     {
787         char *that = const_cast<char *>(reinterpret_cast<const char *>(this));
788         return reinterpret_cast<Class *>(that - offset);
789     }
790     static void signalCallBack(QUntypedPropertyData *o)
791     {
792         QObjectBindableProperty *that = static_cast<QObjectBindableProperty *>(o);
793         if constexpr (HasSignal)
794             (that->owner()->*Signal)();
795     }
796 public:
797     using value_type = typename QPropertyData<T>::value_type;
798     using parameter_type = typename QPropertyData<T>::parameter_type;
799     using rvalue_ref = typename QPropertyData<T>::rvalue_ref;
800     using arrow_operator_result = typename QPropertyData<T>::arrow_operator_result;
801 
802     QObjectBindableProperty() = default;
803     explicit QObjectBindableProperty(const T &initialValue) : QPropertyData<T>(initialValue) {}
804     explicit QObjectBindableProperty(T &&initialValue) : QPropertyData<T>(std::move(initialValue)) {}
805     explicit QObjectBindableProperty(const QPropertyBinding<T> &binding)
806         : QObjectBindableProperty()
807     { setBinding(binding); }
808 #ifndef Q_CLANG_QDOC
809     template <typename Functor>
810     explicit QObjectBindableProperty(Functor &&f, const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION,
811                        typename std::enable_if_t<std::is_invocable_r_v<T, Functor&>> * = 0)
812         : QObjectBindableProperty(QPropertyBinding<T>(std::forward<Functor>(f), location))
813     {}
814 #else
815     template <typename Functor>
816     explicit QProperty(Functor &&f);
817 #endif
818 
819     parameter_type value() const {
820         qGetBindingStorage(owner())->maybeUpdateBindingAndRegister(this);
821         return this->val;
822     }
823 
824     arrow_operator_result operator->() const
825     {
826         if constexpr (QTypeTraits::is_dereferencable_v<T>)
827             return value();
828         else if constexpr (QPropertyData<T>::UseReferences)
829             return &value();
830         else
831             return;
832     }
833 
834     parameter_type operator*() const
835     {
836         return value();
837     }
838 
839     operator parameter_type() const
840     {
841         return value();
842     }
843 
844     void setValue(parameter_type t) {
845         auto *bd = qGetBindingStorage(owner())->bindingData(this);
846         if (bd)
847             bd->removeBinding();
848         if (this->val == t)
849             return;
850         this->val = t;
851         notify(bd);
852     }
853 
854     void setValue(rvalue_ref t) {
855         auto *bd = qGetBindingStorage(owner())->bindingData(this);
856         if (bd)
857             bd->removeBinding();
858         if (this->val == t)
859             return;
860         this->val = std::move(t);
861         notify(bd);
862     }
863 
864     QObjectBindableProperty &operator=(rvalue_ref newValue)
865     {
866         setValue(std::move(newValue));
867         return *this;
868     }
869 
870     QObjectBindableProperty &operator=(parameter_type newValue)
871     {
872         setValue(newValue);
873         return *this;
874     }
875 
876     QPropertyBinding<T> setBinding(const QPropertyBinding<T> &newBinding)
877     {
878         QtPrivate::QPropertyBindingData *bd = qGetBindingStorage(owner())->bindingData(this, true);
879         QUntypedPropertyBinding oldBinding(bd->setBinding(newBinding, this, HasSignal ? &signalCallBack : nullptr));
880         notify(bd);
881         return static_cast<QPropertyBinding<T> &>(oldBinding);
882     }
883 
884     bool setBinding(const QUntypedPropertyBinding &newBinding)
885     {
886         if (!newBinding.isNull() && newBinding.valueMetaType().id() != qMetaTypeId<T>())
887             return false;
888         setBinding(static_cast<const QPropertyBinding<T> &>(newBinding));
889         return true;
890     }
891 
892 #ifndef Q_CLANG_QDOC
893     template <typename Functor>
894     QPropertyBinding<T> setBinding(Functor &&f,
895                                    const QPropertyBindingSourceLocation &location = QT_PROPERTY_DEFAULT_BINDING_LOCATION,
896                                    std::enable_if_t<std::is_invocable_v<Functor>> * = nullptr)
897     {
898         return setBinding(Qt::makePropertyBinding(std::forward<Functor>(f), location));
899     }
900 #else
901     template <typename Functor>
902     QPropertyBinding<T> setBinding(Functor f);
903 #endif
904 
905     bool hasBinding() const {
906         auto *bd = qGetBindingStorage(owner())->bindingData(this);
907         return bd && bd->binding() != nullptr;
908     }
909 
910     QPropertyBinding<T> binding() const
911     {
912         auto *bd = qGetBindingStorage(owner())->bindingData(this);
913         return static_cast<QPropertyBinding<T> &&>(QUntypedPropertyBinding(bd ? bd->binding() : nullptr));
914     }
915 
916     QPropertyBinding<T> takeBinding()
917     {
918         return setBinding(QPropertyBinding<T>());
919     }
920 
921     template<typename Functor>
922     QPropertyChangeHandler<Functor> onValueChanged(Functor f)
923     {
924 #if defined(__cpp_lib_is_invocable) && (__cpp_lib_is_invocable >= 201703L)
925         static_assert(std::is_invocable_v<Functor>, "Functor callback must be callable without any parameters");
926 #endif
927         return QPropertyChangeHandler<Functor>(*this, f);
928     }
929 
930     template<typename Functor>
931     QPropertyChangeHandler<Functor> subscribe(Functor f)
932     {
933 #if defined(__cpp_lib_is_invocable) && (__cpp_lib_is_invocable >= 201703L)
934         static_assert(std::is_invocable_v<Functor>, "Functor callback must be callable without any parameters");
935 #endif
936         f();
937         return onValueChanged(f);
938     }
939 
940     const QtPrivate::QPropertyBindingData &bindingData() const
941     {
942         auto *storage = const_cast<QBindingStorage *>(qGetBindingStorage(owner()));
943         return *storage->bindingData(const_cast<ThisType *>(this), true);
944     }
945 private:
946     void notify(const QtPrivate::QPropertyBindingData *binding)
947     {
948         if (binding)
949             binding->notifyObservers(this);
950         if constexpr (HasSignal)
951             (owner()->*Signal)();
952     }
953 };
954 
955 #define Q_OBJECT_BINDABLE_PROPERTY(Class, Type, name,  ...) \
956     static constexpr size_t _qt_property_##name##_offset() { \
957         QT_WARNING_PUSH QT_WARNING_DISABLE_INVALID_OFFSETOF \
958         return offsetof(Class, name); \
959         QT_WARNING_POP \
960     } \
961     QObjectBindableProperty<Class, Type, Class::_qt_property_##name##_offset, __VA_ARGS__> name;
962 
963 template<typename Class, typename T, auto Offset, auto Getter>
964 class QObjectComputedProperty : public QUntypedPropertyData
965 {
966     static constexpr size_t offset = QtPrivate::detail::getOffset(Offset);
967     Class *owner()
968     {
969         char *that = reinterpret_cast<char *>(this);
970         return reinterpret_cast<Class *>(that - offset);
971     }
972     const Class *owner() const
973     {
974         char *that = const_cast<char *>(reinterpret_cast<const char *>(this));
975         return reinterpret_cast<Class *>(that - offset);
976     }
977 public:
978     using value_type = T;
979     using parameter_type = T;
980 
981     QObjectComputedProperty() = default;
982 
983     parameter_type value() const {
984         qGetBindingStorage(owner())->maybeUpdateBindingAndRegister(this);
985         return (owner()->*Getter)();
986     }
987 
988     std::conditional_t<QTypeTraits::is_dereferencable_v<T>, parameter_type, void>
989     operator->() const
990     {
991         if constexpr (QTypeTraits::is_dereferencable_v<T>)
992             return value();
993         else
994             return;
995     }
996 
997     parameter_type operator*() const
998     {
999         return value();
1000     }
1001 
1002     operator parameter_type() const
1003     {
1004         return value();
1005     }
1006 
1007     constexpr bool hasBinding() const { return false; }
1008 
1009     template<typename Functor>
1010     QPropertyChangeHandler<Functor> onValueChanged(Functor f)
1011     {
1012 #if defined(__cpp_lib_is_invocable) && (__cpp_lib_is_invocable >= 201703L)
1013         static_assert(std::is_invocable_v<Functor>, "Functor callback must be callable without any parameters");
1014 #endif
1015         return QPropertyChangeHandler<Functor>(*this, f);
1016     }
1017 
1018     template<typename Functor>
1019     QPropertyChangeHandler<Functor> subscribe(Functor f)
1020     {
1021 #if defined(__cpp_lib_is_invocable) && (__cpp_lib_is_invocable >= 201703L)
1022         static_assert(std::is_invocable_v<Functor>, "Functor callback must be callable without any parameters");
1023 #endif
1024         f();
1025         return onValueChanged(f);
1026     }
1027 
1028     QtPrivate::QPropertyBindingData &bindingData() const
1029     {
1030         auto *storage = const_cast<QBindingStorage *>(qGetBindingStorage(owner()));
1031         return *storage->bindingData(const_cast<QObjectComputedProperty *>(this), true);
1032     }
1033 private:
1034 };
1035 
1036 #define Q_OBJECT_COMPUTED_PROPERTY(Class, Type, name,  ...) \
1037     static constexpr size_t _qt_property_##name##_offset() { \
1038         QT_WARNING_PUSH QT_WARNING_DISABLE_INVALID_OFFSETOF \
1039         return offsetof(Class, name); \
1040         QT_WARNING_POP \
1041     } \
1042     QObjectComputedProperty<Class, Type, Class::_qt_property_##name##_offset, __VA_ARGS__> name;
1043 
1044 QT_END_NAMESPACE
1045 
1046 #endif // QPROPERTY_H
