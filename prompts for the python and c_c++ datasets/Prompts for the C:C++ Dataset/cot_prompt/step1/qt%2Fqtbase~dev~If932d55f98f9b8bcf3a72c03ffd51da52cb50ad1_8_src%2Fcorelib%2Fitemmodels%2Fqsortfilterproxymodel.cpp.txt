Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
Add support for QRegularExpression to QSortFilterProxyModel

This patch implements the support for QRegularExpression in
QSortFilterProxyModel. It adds setFilter with two overloads: one for QRegExp
and one for QRegularExpression.

[ChangeLog][QtCore][Item Models] QSortFilterProxyModel now supports
QRegularExpressions.

Task-number: QTBUG-46810
Change-Id: If932d55f98f9b8bcf3a72c03ffd51da52cb50ad1

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtGui module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qsortfilterproxymodel.h"
41 #include "qitemselectionmodel.h"
42 #include <qsize.h>
43 #include <qdebug.h>
44 #include <qdatetime.h>
45 #include <qpair.h>
46 #include <qregularexpression.h>
47 #include <qstringlist.h>
48 #include <private/qabstractitemmodel_p.h>
49 #include <private/qabstractproxymodel_p.h>
50 
51 #include <algorithm>
52 
53 QT_BEGIN_NAMESPACE
54 
55 typedef QVector<QPair<QModelIndex, QPersistentModelIndex> > QModelIndexPairList;
56 
57 struct QSortFilterProxyModelDataChanged
58 {
59     QSortFilterProxyModelDataChanged(const QModelIndex &tl, const QModelIndex &br)
60         : topLeft(tl), bottomRight(br) { }
61 
62     QModelIndex topLeft;
63     QModelIndex bottomRight;
64 };
65 
66 static inline QSet<int> qVectorToSet(const QVector<int> &vector)
67 {
68     QSet<int> set;
69     set.reserve(vector.size());
70     for(int i=0; i < vector.size(); ++i)
71         set << vector.at(i);
72     return set;
73 }
74 
75 class QSortFilterProxyModelLessThan
76 {
77 public:
78     inline QSortFilterProxyModelLessThan(int column, const QModelIndex &parent,
79                                        const QAbstractItemModel *source,
80                                        const QSortFilterProxyModel *proxy)
81         : sort_column(column), source_parent(parent), source_model(source), proxy_model(proxy) {}
82 
83     inline bool operator()(int r1, int r2) const
84     {
85         QModelIndex i1 = source_model->index(r1, sort_column, source_parent);
86         QModelIndex i2 = source_model->index(r2, sort_column, source_parent);
87         return proxy_model->lessThan(i1, i2);
88     }
89 
90 private:
91     int sort_column;
92     QModelIndex source_parent;
93     const QAbstractItemModel *source_model;
94     const QSortFilterProxyModel *proxy_model;
95 };
96 
97 class QSortFilterProxyModelGreaterThan
98 {
99 public:
100     inline QSortFilterProxyModelGreaterThan(int column, const QModelIndex &parent,
101                                           const QAbstractItemModel *source,
102                                           const QSortFilterProxyModel *proxy)
103         : sort_column(column), source_parent(parent),
104           source_model(source), proxy_model(proxy) {}
105 
106     inline bool operator()(int r1, int r2) const
107     {
108         QModelIndex i1 = source_model->index(r1, sort_column, source_parent);
109         QModelIndex i2 = source_model->index(r2, sort_column, source_parent);
110         return proxy_model->lessThan(i2, i1);
111     }
112 
113 private:
114     int sort_column;
115     QModelIndex source_parent;
116     const QAbstractItemModel *source_model;
117     const QSortFilterProxyModel *proxy_model;
118 };
119 
120 
121 //this struct is used to store what are the rows that are removed
122 //between a call to rowsAboutToBeRemoved and rowsRemoved
123 //it avoids readding rows to the mapping that are currently being removed
124 struct QRowsRemoval
125 {
126     QRowsRemoval(const QModelIndex &parent_source, int start, int end) : parent_source(parent_source), start(start), end(end)
127     {
128     }
129 
130     QRowsRemoval() : start(-1), end(-1)
131     {
132     }
133 
134     bool contains(QModelIndex parent, int row)
135     {
136         do {
137             if (parent == parent_source)
138                 return row >= start && row <= end;
139             row = parent.row();
140             parent = parent.parent();
141         } while (row >= 0);
142         return false;
143     }
144 private:
145     QModelIndex parent_source;
146     int start;
147     int end;
148 };
149 
150 class RegularExpressionData {
151 
152 private:
153     enum class ExpressionType {
154         RegExp,
155 #if QT_CONFIG(regularexpression)
156         RegularExpression
157 #endif
158     };
159 
160 public:
161     RegularExpressionData() :
162         _type(ExpressionType::RegExp)
163     {}
164 
165 #if QT_CONFIG(regularexpression)
166     QRegularExpression regularExpression() const
167     {
168         if (_type == ExpressionType::RegularExpression)
169             return _regularExpression;
170         return QRegularExpression();
171     }
172 
173     void setRegularExpression(const QRegularExpression &rx)
174     {
175         _regularExpression = rx;
176         _type = ExpressionType::RegularExpression;
177     }
178 #endif
179 
180     QRegExp regExp() const
181     {
182         if (_type == ExpressionType::RegExp)
183             return _regExp;
184         return QRegExp();
185     }
186 
187     void setRegExp(const QRegExp &rx)
188     {
189         _regExp = rx;
190         _type = ExpressionType::RegExp;
191     }
192 
193     bool isEmpty() const
194     {
195         bool result = true;
196         switch (_type) {
197         case ExpressionType::RegExp:
198             result = _regExp.isEmpty();
199             break;
200 #if QT_CONFIG(regularexpression)
201         case ExpressionType::RegularExpression:
202             result = _regularExpression.pattern().isEmpty();
203             break;
204 #endif
205         }
206         return result;
207     }
208 
209     Qt::CaseSensitivity caseSensitivity() const
210     {
211         Qt::CaseSensitivity sensitivity = Qt::CaseInsensitive;
212         switch (_type) {
213         case ExpressionType::RegExp:
214             sensitivity = _regExp.caseSensitivity();
215             break;
216 #if QT_CONFIG(regularexpression)
217         case ExpressionType::RegularExpression:
218         {
219             QRegularExpression::PatternOptions options = _regularExpression.patternOptions();
220             bool isCaseInsensitive = options & QRegularExpression::CaseInsensitiveOption;
221             sensitivity = isCaseInsensitive ? Qt::CaseInsensitive : Qt::CaseSensitive;
222         }
223             break;
224 #endif
225         }
226         return sensitivity;
227     }
228 
229     void setCaseSensitivity(Qt::CaseSensitivity cs)
230     {
231         switch (_type) {
232         case ExpressionType::RegExp:
233             _regExp.setCaseSensitivity(cs);
234             break;
235 #if QT_CONFIG(regularexpression)
236         case ExpressionType::RegularExpression:
237         {
238             QRegularExpression::PatternOptions options = _regularExpression.patternOptions();
239             options.setFlag(QRegularExpression::CaseInsensitiveOption, cs == Qt::CaseSensitive);
240             _regularExpression.setPatternOptions(options);
241         }
242             break;
243 #endif
244         }
245     }
246 
247     bool isRxInString(const QString &str) const
248     {
249         bool result = false;
250         switch (_type) {
251         case ExpressionType::RegExp:
252             result = str.contains(_regExp);
253             break;
254 #if QT_CONFIG(regularexpression)
255         case ExpressionType::RegularExpression:
256             result = str.contains(_regularExpression);
257             break;
258 #endif
259         }
260         return result;
261     }
262 
263 private:
264     ExpressionType _type;
265     QRegExp _regExp;
266 #if QT_CONFIG(regularexpression)
267     QRegularExpression _regularExpression;
268 #endif
269 };
270 
271 
272 class QSortFilterProxyModelPrivate : public QAbstractProxyModelPrivate
273 {
274     Q_DECLARE_PUBLIC(QSortFilterProxyModel)
275 
276 public:
277     struct Mapping {
278         QVector<int> source_rows;
279         QVector<int> source_columns;
280         QVector<int> proxy_rows;
281         QVector<int> proxy_columns;
282         QVector<QModelIndex> mapped_children;
283         QHash<QModelIndex, Mapping *>::const_iterator map_iter;
284     };
285 
286     mutable QHash<QModelIndex, Mapping*> source_index_mapping;
287 
288     int source_sort_column;
289     int proxy_sort_column;
290     Qt::SortOrder sort_order;
291     Qt::CaseSensitivity sort_casesensitivity;
292     int sort_role;
293     bool sort_localeaware;
294 
295     int filter_column;
296     int filter_role;
297     RegularExpressionData filter_data;
298     QModelIndex last_top_source;
299 
300     bool filter_recursive;
301     bool complete_insert;
302     bool dynamic_sortfilter;
303     QRowsRemoval itemsBeingRemoved;
304 
305     QModelIndexPairList saved_persistent_indexes;
306     QList<QPersistentModelIndex> saved_layoutChange_parents;
307 
308     QHash<QModelIndex, Mapping *>::const_iterator create_mapping(
309         const QModelIndex &source_parent) const;
310     QModelIndex proxy_to_source(const QModelIndex &proxyIndex) const;
311     QModelIndex source_to_proxy(const QModelIndex &sourceIndex) const;
312     bool can_create_mapping(const QModelIndex &source_parent) const;
313 
314     void remove_from_mapping(const QModelIndex &source_parent);
315 
316     inline QHash<QModelIndex, Mapping *>::const_iterator index_to_iterator(
317         const QModelIndex &proxy_index) const
318     {
319         Q_ASSERT(proxy_index.isValid());
320         Q_ASSERT(proxy_index.model() == q_func());
321         const void *p = proxy_index.internalPointer();
322         Q_ASSERT(p);
323         QHash<QModelIndex, Mapping *>::const_iterator it =
324             static_cast<const Mapping*>(p)->map_iter;
325         Q_ASSERT(it != source_index_mapping.constEnd());
326         Q_ASSERT(it.value());
327         return it;
328     }
329 
330     inline QModelIndex create_index(int row, int column,
331                                     QHash<QModelIndex, Mapping*>::const_iterator it) const
332     {
333         return q_func()->createIndex(row, column, *it);
334     }
335 
336     void _q_sourceDataChanged(const QModelIndex &source_top_left,
337                               const QModelIndex &source_bottom_right,
338                               const QVector<int> &roles);
339     void _q_sourceHeaderDataChanged(Qt::Orientation orientation, int start, int end);
340 
341     void _q_sourceAboutToBeReset();
342     void _q_sourceReset();
343 
344     void _q_sourceLayoutAboutToBeChanged(const QList<QPersistentModelIndex> &sourceParents, QAbstractItemModel::LayoutChangeHint hint);
345     void _q_sourceLayoutChanged(const QList<QPersistentModelIndex> &sourceParents, QAbstractItemModel::LayoutChangeHint hint);
346 
347     void _q_sourceRowsAboutToBeInserted(const QModelIndex &source_parent,
348                                         int start, int end);
349     void _q_sourceRowsInserted(const QModelIndex &source_parent,
350                                int start, int end);
351     void _q_sourceRowsAboutToBeRemoved(const QModelIndex &source_parent,
352                                        int start, int end);
353     void _q_sourceRowsRemoved(const QModelIndex &source_parent,
354                               int start, int end);
355     void _q_sourceRowsAboutToBeMoved(const QModelIndex &sourceParent,
356                                      int sourceStart, int sourceEnd,
357                                      const QModelIndex &destParent, int dest);
358     void _q_sourceRowsMoved(const QModelIndex &sourceParent,
359                             int sourceStart, int sourceEnd,
360                             const QModelIndex &destParent, int dest);
361     void _q_sourceColumnsAboutToBeInserted(const QModelIndex &source_parent,
362                                            int start, int end);
363     void _q_sourceColumnsInserted(const QModelIndex &source_parent,
364                                   int start, int end);
365     void _q_sourceColumnsAboutToBeRemoved(const QModelIndex &source_parent,
366                                           int start, int end);
367     void _q_sourceColumnsRemoved(const QModelIndex &source_parent,
368                                  int start, int end);
369     void _q_sourceColumnsAboutToBeMoved(const QModelIndex &sourceParent,
370                                         int sourceStart, int sourceEnd,
371                                         const QModelIndex &destParent, int dest);
372     void _q_sourceColumnsMoved(const QModelIndex &sourceParent,
373                                int sourceStart, int sourceEnd,
374                                const QModelIndex &destParent, int dest);
375 
376     void _q_clearMapping();
377 
378     void sort();
379     bool update_source_sort_column();
380     void sort_source_rows(QVector<int> &source_rows,
381                           const QModelIndex &source_parent) const;
382     QVector<QPair<int, QVector<int > > > proxy_intervals_for_source_items_to_add(
383         const QVector<int> &proxy_to_source, const QVector<int> &source_items,
384         const QModelIndex &source_parent, Qt::Orientation orient) const;
385     QVector<QPair<int, int > > proxy_intervals_for_source_items(
386         const QVector<int> &source_to_proxy, const QVector<int> &source_items) const;
387     void insert_source_items(
388         QVector<int> &source_to_proxy, QVector<int> &proxy_to_source,
389         const QVector<int> &source_items, const QModelIndex &source_parent,
390         Qt::Orientation orient, bool emit_signal = true);
391     void remove_source_items(
392         QVector<int> &source_to_proxy, QVector<int> &proxy_to_source,
393         const QVector<int> &source_items, const QModelIndex &source_parent,
394         Qt::Orientation orient, bool emit_signal = true);
395     void remove_proxy_interval(
396         QVector<int> &source_to_proxy, QVector<int> &proxy_to_source,
397         int proxy_start, int proxy_end, const QModelIndex &proxy_parent,
398         Qt::Orientation orient, bool emit_signal = true);
399     void build_source_to_proxy_mapping(
400         const QVector<int> &proxy_to_source, QVector<int> &source_to_proxy) const;
401     void source_items_inserted(const QModelIndex &source_parent,
402                                int start, int end, Qt::Orientation orient);
403     void source_items_about_to_be_removed(const QModelIndex &source_parent,
404                                           int start, int end, Qt::Orientation orient);
405     void source_items_removed(const QModelIndex &source_parent,
406                               int start, int end, Qt::Orientation orient);
407     void proxy_item_range(
408         const QVector<int> &source_to_proxy, const QVector<int> &source_items,
409         int &proxy_low, int &proxy_high) const;
410 
411     QModelIndexPairList store_persistent_indexes() const;
412     void update_persistent_indexes(const QModelIndexPairList &source_indexes);
413 
414     void filter_about_to_be_changed(const QModelIndex &source_parent = QModelIndex());
415     void filter_changed(const QModelIndex &source_parent = QModelIndex());
416     QSet<int> handle_filter_changed(
417         QVector<int> &source_to_proxy, QVector<int> &proxy_to_source,
418         const QModelIndex &source_parent, Qt::Orientation orient);
419 
420     void updateChildrenMapping(const QModelIndex &source_parent, Mapping *parent_mapping,
421                                Qt::Orientation orient, int start, int end, int delta_item_count, bool remove);
422 
423     virtual void _q_sourceModelDestroyed() override;
424 
425     bool needsReorder(const QVector<int> &source_rows, const QModelIndex &source_parent) const;
426 
427     bool filterAcceptsRowInternal(int source_row, const QModelIndex &source_parent) const;
428     bool filterRecursiveAcceptsRow(int source_row, const QModelIndex &source_parent) const;
429 };
430 
431 typedef QHash<QModelIndex, QSortFilterProxyModelPrivate::Mapping *> IndexMap;
432 
433 void QSortFilterProxyModelPrivate::_q_sourceModelDestroyed()
434 {
435     QAbstractProxyModelPrivate::_q_sourceModelDestroyed();
436     qDeleteAll(source_index_mapping);
437     source_index_mapping.clear();
438 }
439 
440 bool QSortFilterProxyModelPrivate::filterAcceptsRowInternal(int source_row, const QModelIndex &source_parent) const
441 {
442     Q_Q(const QSortFilterProxyModel);
443     return filter_recursive
444             ? filterRecursiveAcceptsRow(source_row, source_parent)
445             : q->filterAcceptsRow(source_row, source_parent);
446 }
447 
448 bool QSortFilterProxyModelPrivate::filterRecursiveAcceptsRow(int source_row, const QModelIndex &source_parent) const
449 {
450     Q_Q(const QSortFilterProxyModel);
451 
452     if (q->filterAcceptsRow(source_row, source_parent))
453         return true;
454 
455     const QModelIndex index = model->index(source_row, 0, source_parent);
456     const int count = model->rowCount(index);
457 
458     for (int i = 0; i < count; ++i) {
459         if (filterRecursiveAcceptsRow(i, index))
460             return true;
461     }
462 
463     return false;
464 }
465 
466 void QSortFilterProxyModelPrivate::remove_from_mapping(const QModelIndex &source_parent)
467 {
468     if (Mapping *m = source_index_mapping.take(source_parent)) {
469         for (int i = 0; i < m->mapped_children.size(); ++i)
470             remove_from_mapping(m->mapped_children.at(i));
471         delete m;
472     }
473 }
474 
475 void QSortFilterProxyModelPrivate::_q_clearMapping()
476 {
477     // store the persistent indexes
478     QModelIndexPairList source_indexes = store_persistent_indexes();
479 
480     qDeleteAll(source_index_mapping);
481     source_index_mapping.clear();
482     if (dynamic_sortfilter && update_source_sort_column()) {
483         //update_source_sort_column might have created wrong mapping so we have to clear it again
484         qDeleteAll(source_index_mapping);
485         source_index_mapping.clear();
486     }
487 
488     // update the persistent indexes
489     update_persistent_indexes(source_indexes);
490 }
491 
492 IndexMap::const_iterator QSortFilterProxyModelPrivate::create_mapping(
493     const QModelIndex &source_parent) const
494 {
495     Q_Q(const QSortFilterProxyModel);
496 
497     IndexMap::const_iterator it = source_index_mapping.constFind(source_parent);
498     if (it != source_index_mapping.constEnd()) // was mapped already
499         return it;
500 
501     Mapping *m = new Mapping;
502 
503     int source_rows = model->rowCount(source_parent);
504     m->source_rows.reserve(source_rows);
505     for (int i = 0; i < source_rows; ++i) {
506         if (filterAcceptsRowInternal(i, source_parent))
507             m->source_rows.append(i);
508     }
509     int source_cols = model->columnCount(source_parent);
510     m->source_columns.reserve(source_cols);
511     for (int i = 0; i < source_cols; ++i) {
512         if (q->filterAcceptsColumn(i, source_parent))
513             m->source_columns.append(i);
514     }
515 
516     sort_source_rows(m->source_rows, source_parent);
517     m->proxy_rows.resize(source_rows);
518     build_source_to_proxy_mapping(m->source_rows, m->proxy_rows);
519     m->proxy_columns.resize(source_cols);
520     build_source_to_proxy_mapping(m->source_columns, m->proxy_columns);
521 
522     it = IndexMap::const_iterator(source_index_mapping.insert(source_parent, m));
523     m->map_iter = it;
524 
525     if (source_parent.isValid()) {
526         QModelIndex source_grand_parent = source_parent.parent();
527         IndexMap::const_iterator it2 = create_mapping(source_grand_parent);
528         Q_ASSERT(it2 != source_index_mapping.constEnd());
529         it2.value()->mapped_children.append(source_parent);
530     }
531 
532     Q_ASSERT(it != source_index_mapping.constEnd());
533     Q_ASSERT(it.value());
534 
535     return it;
536 }
537 
538 QModelIndex QSortFilterProxyModelPrivate::proxy_to_source(const QModelIndex &proxy_index) const
539 {
540     if (!proxy_index.isValid())
541         return QModelIndex(); // for now; we may want to be able to set a root index later
542     if (proxy_index.model() != q_func()) {
543         qWarning("QSortFilterProxyModel: index from wrong model passed to mapToSource");
544         Q_ASSERT(!"QSortFilterProxyModel: index from wrong model passed to mapToSource");
545         return QModelIndex();
546     }
547     IndexMap::const_iterator it = index_to_iterator(proxy_index);
548     Mapping *m = it.value();
549     if ((proxy_index.row() >= m->source_rows.size()) || (proxy_index.column() >= m->source_columns.size()))
550         return QModelIndex();
551     int source_row = m->source_rows.at(proxy_index.row());
552     int source_col = m->source_columns.at(proxy_index.column());
553     return model->index(source_row, source_col, it.key());
554 }
555 
556 QModelIndex QSortFilterProxyModelPrivate::source_to_proxy(const QModelIndex &source_index) const
557 {
558     if (!source_index.isValid())
559         return QModelIndex(); // for now; we may want to be able to set a root index later
560     if (source_index.model() != model) {
561         qWarning("QSortFilterProxyModel: index from wrong model passed to mapFromSource");
562         Q_ASSERT(!"QSortFilterProxyModel: index from wrong model passed to mapFromSource");
563         return QModelIndex();
564     }
565     QModelIndex source_parent = source_index.parent();
566     IndexMap::const_iterator it = create_mapping(source_parent);
567     Mapping *m = it.value();
568     if ((source_index.row() >= m->proxy_rows.size()) || (source_index.column() >= m->proxy_columns.size()))
569         return QModelIndex();
570     int proxy_row = m->proxy_rows.at(source_index.row());
571     int proxy_column = m->proxy_columns.at(source_index.column());
572     if (proxy_row == -1 || proxy_column == -1)
573         return QModelIndex();
574     return create_index(proxy_row, proxy_column, it);
575 }
576 
577 bool QSortFilterProxyModelPrivate::can_create_mapping(const QModelIndex &source_parent) const
578 {
579     if (source_parent.isValid()) {
580         QModelIndex source_grand_parent = source_parent.parent();
581         IndexMap::const_iterator it = source_index_mapping.constFind(source_grand_parent);
582         if (it == source_index_mapping.constEnd()) {
583             // Don't care, since we don't have mapping for the grand parent
584             return false;
585         }
586         Mapping *gm = it.value();
587         if (gm->proxy_rows.at(source_parent.row()) == -1 ||
588             gm->proxy_columns.at(source_parent.column()) == -1) {
589             // Don't care, since parent is filtered
590             return false;
591         }
592     }
593     return true;
594 }
595 
596 /*!
597   \internal
598 
599   Sorts the existing mappings.
600 */
601 void QSortFilterProxyModelPrivate::sort()
602 {
603     Q_Q(QSortFilterProxyModel);
604     emit q->layoutAboutToBeChanged(QList<QPersistentModelIndex>(), QAbstractItemModel::VerticalSortHint);
605     QModelIndexPairList source_indexes = store_persistent_indexes();
606     IndexMap::const_iterator it = source_index_mapping.constBegin();
607     for (; it != source_index_mapping.constEnd(); ++it) {
608         QModelIndex source_parent = it.key();
609         Mapping *m = it.value();
610         sort_source_rows(m->source_rows, source_parent);
611         build_source_to_proxy_mapping(m->source_rows, m->proxy_rows);
612     }
613     update_persistent_indexes(source_indexes);
614     emit q->layoutChanged(QList<QPersistentModelIndex>(), QAbstractItemModel::VerticalSortHint);
615 }
616 
617 /*!
618   \internal
619 
620     update the source_sort_column according to the proxy_sort_column
621     return true if the column was changed
622 */
623 bool QSortFilterProxyModelPrivate::update_source_sort_column()
624 {
625     int old_source_sort_column = source_sort_column;
626 
627     if (proxy_sort_column == -1) {
628         source_sort_column = -1;
629     } else {
630         // We cannot use index mapping here because in case of a still-empty
631         // proxy model there's no valid proxy index we could map to source.
632         // So always use the root mapping directly instead.
633         Mapping *m = create_mapping(QModelIndex()).value();
634         if (proxy_sort_column < m->source_columns.size())
635             source_sort_column = m->source_columns.at(proxy_sort_column);
636         else
637             source_sort_column = -1;
638     }
639 
640     return old_source_sort_column != source_sort_column;
641 }
642 
643 
644 /*!
645   \internal
646 
647   Sorts the given \a source_rows according to current sort column and order.
648 */
649 void QSortFilterProxyModelPrivate::sort_source_rows(
650     QVector<int> &source_rows, const QModelIndex &source_parent) const
651 {
652     Q_Q(const QSortFilterProxyModel);
653     if (source_sort_column >= 0) {
654         if (sort_order == Qt::AscendingOrder) {
655             QSortFilterProxyModelLessThan lt(source_sort_column, source_parent, model, q);
656             std::stable_sort(source_rows.begin(), source_rows.end(), lt);
657         } else {
658             QSortFilterProxyModelGreaterThan gt(source_sort_column, source_parent, model, q);
659             std::stable_sort(source_rows.begin(), source_rows.end(), gt);
660         }
661     } else { // restore the source model order
662         std::stable_sort(source_rows.begin(), source_rows.end());
663     }
664 }
665 
666 /*!
667   \internal
668 
669   Given source-to-proxy mapping \a source_to_proxy and the set of
670   source items \a source_items (which are part of that mapping),
671   determines the corresponding proxy item intervals that should
672   be removed from the proxy model.
673 
674   The result is a vector of pairs, where each pair represents a
675   (start, end) tuple, sorted in ascending order.
676 */
677 QVector<QPair<int, int > > QSortFilterProxyModelPrivate::proxy_intervals_for_source_items(
678     const QVector<int> &source_to_proxy, const QVector<int> &source_items) const
679 {
680     QVector<QPair<int, int> > proxy_intervals;
681     if (source_items.isEmpty())
682         return proxy_intervals;
683 
684     int source_items_index = 0;
685     while (source_items_index < source_items.size()) {
686         int first_proxy_item = source_to_proxy.at(source_items.at(source_items_index));
687         Q_ASSERT(first_proxy_item != -1);
688         int last_proxy_item = first_proxy_item;
689         ++source_items_index;
690         // Find end of interval
691         while ((source_items_index < source_items.size())
692                && (source_to_proxy.at(source_items.at(source_items_index)) == last_proxy_item + 1)) {
693             ++last_proxy_item;
694             ++source_items_index;
695         }
696         // Add interval to result
697         proxy_intervals.append(QPair<int, int>(first_proxy_item, last_proxy_item));
698     }
699     std::stable_sort(proxy_intervals.begin(), proxy_intervals.end());
700     // Consolidate adjacent intervals
701     for (int i = proxy_intervals.size()-1; i > 0; --i) {
702         QPair<int, int> &interval = proxy_intervals[i];
703         QPair<int, int> &preceeding_interval = proxy_intervals[i - 1];
704         if (interval.first == preceeding_interval.second + 1) {
705             preceeding_interval.second = interval.second;
706             interval.first = interval.second = -1;
707         }
708     }
709     proxy_intervals.erase(
710         std::remove_if(proxy_intervals.begin(), proxy_intervals.end(),
711                        [](QPair<int, int> &interval) { return interval.first < 0; }),
712         proxy_intervals.end());
713     return proxy_intervals;
714 }
715 
716 /*!
717   \internal
718 
719   Given source-to-proxy mapping \a src_to_proxy and proxy-to-source mapping
720   \a proxy_to_source, removes \a source_items from this proxy model.
721   The corresponding proxy items are removed in intervals, so that the proper
722   rows/columnsRemoved(start, end) signals will be generated.
723 */
724 void QSortFilterProxyModelPrivate::remove_source_items(
725     QVector<int> &source_to_proxy, QVector<int> &proxy_to_source,
726     const QVector<int> &source_items, const QModelIndex &source_parent,
727     Qt::Orientation orient, bool emit_signal)
728 {
729     Q_Q(QSortFilterProxyModel);
730     QModelIndex proxy_parent = q->mapFromSource(source_parent);
731     if (!proxy_parent.isValid() && source_parent.isValid())
732         return; // nothing to do (already removed)
733 
734     QVector<QPair<int, int> > proxy_intervals;
735     proxy_intervals = proxy_intervals_for_source_items(source_to_proxy, source_items);
736 
737     for (int i = proxy_intervals.size()-1; i >= 0; --i) {
738         QPair<int, int> interval = proxy_intervals.at(i);
739         int proxy_start = interval.first;
740         int proxy_end = interval.second;
741         remove_proxy_interval(source_to_proxy, proxy_to_source, proxy_start, proxy_end,
742                               proxy_parent, orient, emit_signal);
743     }
744 }
745 
746 /*!
747   \internal
748 
749   Given source-to-proxy mapping \a source_to_proxy and proxy-to-source mapping
750   \a proxy_to_source, removes items from \a proxy_start to \a proxy_end
751   (inclusive) from this proxy model.
752 */
753 void QSortFilterProxyModelPrivate::remove_proxy_interval(
754     QVector<int> &source_to_proxy, QVector<int> &proxy_to_source, int proxy_start, int proxy_end,
755     const QModelIndex &proxy_parent, Qt::Orientation orient, bool emit_signal)
756 {
757     Q_Q(QSortFilterProxyModel);
758     if (emit_signal) {
759         if (orient == Qt::Vertical)
760             q->beginRemoveRows(proxy_parent, proxy_start, proxy_end);
761         else
762             q->beginRemoveColumns(proxy_parent, proxy_start, proxy_end);
763     }
764 
765     // Remove items from proxy-to-source mapping
766     proxy_to_source.remove(proxy_start, proxy_end - proxy_start + 1);
767 
768     build_source_to_proxy_mapping(proxy_to_source, source_to_proxy);
769 
770     if (emit_signal) {
771         if (orient == Qt::Vertical)
772             q->endRemoveRows();
773         else
774             q->endRemoveColumns();
775     }
776 }
777 
778 /*!
779   \internal
780 
781   Given proxy-to-source mapping \a proxy_to_source and a set of
782   unmapped source items \a source_items, determines the proxy item
783   intervals at which the subsets of source items should be inserted
784   (but does not actually add them to the mapping).
785 
786   The result is a vector of pairs, each pair representing a tuple (start,
787   items), where items is a vector containing the (sorted) source items that
788   should be inserted at that proxy model location.
789 */
790 QVector<QPair<int, QVector<int > > > QSortFilterProxyModelPrivate::proxy_intervals_for_source_items_to_add(
791     const QVector<int> &proxy_to_source, const QVector<int> &source_items,
792     const QModelIndex &source_parent, Qt::Orientation orient) const
793 {
794     Q_Q(const QSortFilterProxyModel);
795     QVector<QPair<int, QVector<int> > > proxy_intervals;
796     if (source_items.isEmpty())
797         return proxy_intervals;
798 
799     int proxy_low = 0;
800     int proxy_item = 0;
801     int source_items_index = 0;
802     QVector<int> source_items_in_interval;
803     bool compare = (orient == Qt::Vertical && source_sort_column >= 0 && dynamic_sortfilter);
804     while (source_items_index < source_items.size()) {
805         source_items_in_interval.clear();
806         int first_new_source_item = source_items.at(source_items_index);
807         source_items_in_interval.append(first_new_source_item);
808         ++source_items_index;
809 
810         // Find proxy item at which insertion should be started
811         int proxy_high = proxy_to_source.size() - 1;
812         QModelIndex i1 = compare ? model->index(first_new_source_item, source_sort_column, source_parent) : QModelIndex();
813         while (proxy_low <= proxy_high) {
814             proxy_item = (proxy_low + proxy_high) / 2;
815             if (compare) {
816                 QModelIndex i2 = model->index(proxy_to_source.at(proxy_item), source_sort_column, source_parent);
817                 if ((sort_order == Qt::AscendingOrder) ? q->lessThan(i1, i2) : q->lessThan(i2, i1))
818                     proxy_high = proxy_item - 1;
819                 else
820                     proxy_low = proxy_item + 1;
821             } else {
822                 if (first_new_source_item < proxy_to_source.at(proxy_item))
823                     proxy_high = proxy_item - 1;
824                 else
825                     proxy_low = proxy_item + 1;
826             }
827         }
828         proxy_item = proxy_low;
829 
830         // Find the sequence of new source items that should be inserted here
831         if (proxy_item >= proxy_to_source.size()) {
832             for ( ; source_items_index < source_items.size(); ++source_items_index)
833                 source_items_in_interval.append(source_items.at(source_items_index));
834         } else {
835             i1 = compare ? model->index(proxy_to_source.at(proxy_item), source_sort_column, source_parent) : QModelIndex();
836             for ( ; source_items_index < source_items.size(); ++source_items_index) {
837                 int new_source_item = source_items.at(source_items_index);
838                 if (compare) {
839                     QModelIndex i2 = model->index(new_source_item, source_sort_column, source_parent);
840                     if ((sort_order == Qt::AscendingOrder) ? q->lessThan(i1, i2) : q->lessThan(i2, i1))
841                         break;
842                 } else {
843                     if (proxy_to_source.at(proxy_item) < new_source_item)
844                         break;
845                 }
846                 source_items_in_interval.append(new_source_item);
847             }
848         }
849 
850         // Add interval to result
851         proxy_intervals.append(QPair<int, QVector<int> >(proxy_item, source_items_in_interval));
852     }
853     return proxy_intervals;
854 }
855 
856 /*!
857   \internal
858 
859   Given source-to-proxy mapping \a source_to_proxy and proxy-to-source mapping
860   \a proxy_to_source, inserts the given \a source_items into this proxy model.
861   The source items are inserted in intervals (based on some sorted order), so
862   that the proper rows/columnsInserted(start, end) signals will be generated.
863 */
864 void QSortFilterProxyModelPrivate::insert_source_items(
865     QVector<int> &source_to_proxy, QVector<int> &proxy_to_source,
866     const QVector<int> &source_items, const QModelIndex &source_parent,
867     Qt::Orientation orient, bool emit_signal)
868 {
869     Q_Q(QSortFilterProxyModel);
870     QModelIndex proxy_parent = q->mapFromSource(source_parent);
871     if (!proxy_parent.isValid() && source_parent.isValid())
872         return; // nothing to do (source_parent is not mapped)
873 
874     QVector<QPair<int, QVector<int> > > proxy_intervals;
875     proxy_intervals = proxy_intervals_for_source_items_to_add(
876         proxy_to_source, source_items, source_parent, orient);
877 
878     for (int i = proxy_intervals.size()-1; i >= 0; --i) {
879         QPair<int, QVector<int> > interval = proxy_intervals.at(i);
880         int proxy_start = interval.first;
881         QVector<int> source_items = interval.second;
882         int proxy_end = proxy_start + source_items.size() - 1;
883 
884         if (emit_signal) {
885             if (orient == Qt::Vertical)
886                 q->beginInsertRows(proxy_parent, proxy_start, proxy_end);
887             else
888                 q->beginInsertColumns(proxy_parent, proxy_start, proxy_end);
889         }
890 
891         for (int i = 0; i < source_items.size(); ++i)
892             proxy_to_source.insert(proxy_start + i, source_items.at(i));
893 
894         build_source_to_proxy_mapping(proxy_to_source, source_to_proxy);
895 
896         if (emit_signal) {
897             if (orient == Qt::Vertical)
898                 q->endInsertRows();
899             else
900                 q->endInsertColumns();
901         }
902     }
903 }
904 
905 /*!
906   \internal
907 
908   Handles source model items insertion (columnsInserted(), rowsInserted()).
909   Determines
910   1) which of the inserted items to also insert into proxy model (filtering),
911   2) where to insert the items into the proxy model (sorting),
912   then inserts those items.
913   The items are inserted into the proxy model in intervals (based on
914   sorted order), so that the proper rows/columnsInserted(start, end)
915   signals will be generated.
916 */
917 void QSortFilterProxyModelPrivate::source_items_inserted(
918     const QModelIndex &source_parent, int start, int end, Qt::Orientation orient)
919 {
920     Q_Q(QSortFilterProxyModel);
921     if ((start < 0) || (end < 0))
922         return;
923     IndexMap::const_iterator it = source_index_mapping.constFind(source_parent);
924     if (it == source_index_mapping.constEnd()) {
925         if (!can_create_mapping(source_parent))
926             return;
927         it = create_mapping(source_parent);
928         Mapping *m = it.value();
929         QModelIndex proxy_parent = q->mapFromSource(source_parent);
930         if (m->source_rows.count() > 0) {
931             q->beginInsertRows(proxy_parent, 0, m->source_rows.count() - 1);
932             q->endInsertRows();
933         }
934         if (m->source_columns.count() > 0) {
935             q->beginInsertColumns(proxy_parent, 0, m->source_columns.count() - 1);
936             q->endInsertColumns();
937         }
938         return;
939     }
940 
941     Mapping *m = it.value();
942     QVector<int> &source_to_proxy = (orient == Qt::Vertical) ? m->proxy_rows : m->proxy_columns;
943     QVector<int> &proxy_to_source = (orient == Qt::Vertical) ? m->source_rows : m->source_columns;
944 
945     int delta_item_count = end - start + 1;
946     int old_item_count = source_to_proxy.size();
947 
948     updateChildrenMapping(source_parent, m, orient, start, end, delta_item_count, false);
949 
950     // Expand source-to-proxy mapping to account for new items
951     if (start < 0 || start > source_to_proxy.size()) {
952         qWarning("QSortFilterProxyModel: invalid inserted rows reported by source model");
953         remove_from_mapping(source_parent);
954         return;
955     }
956     source_to_proxy.insert(start, delta_item_count, -1);
957 
958     if (start < old_item_count) {
959         // Adjust existing "stale" indexes in proxy-to-source mapping
960         int proxy_count = proxy_to_source.size();
961         for (int proxy_item = 0; proxy_item < proxy_count; ++proxy_item) {
962             int source_item = proxy_to_source.at(proxy_item);
963             if (source_item >= start)
964                 proxy_to_source.replace(proxy_item, source_item + delta_item_count);
965         }
966         build_source_to_proxy_mapping(proxy_to_source, source_to_proxy);
967     }
968 
969     // Figure out which items to add to mapping based on filter
970     QVector<int> source_items;
971     for (int i = start; i <= end; ++i) {
972         if ((orient == Qt::Vertical)
973             ? filterAcceptsRowInternal(i, source_parent)
974             : q->filterAcceptsColumn(i, source_parent)) {
975             source_items.append(i);
976         }
977     }
978 
979     if (model->rowCount(source_parent) == delta_item_count) {
980         // Items were inserted where there were none before.
981         // If it was new rows make sure to create mappings for columns so that a
982         // valid mapping can be retrieved later and vice-versa.
983 
984         QVector<int> &orthogonal_proxy_to_source = (orient == Qt::Horizontal) ? m->source_rows : m->source_columns;
985         QVector<int> &orthogonal_source_to_proxy = (orient == Qt::Horizontal) ? m->proxy_rows : m->proxy_columns;
986 
987         if (orthogonal_source_to_proxy.isEmpty()) {
988             const int ortho_end = (orient == Qt::Horizontal) ? model->rowCount(source_parent) : model->columnCount(source_parent);
989 
990             orthogonal_source_to_proxy.resize(ortho_end);
991 
992             for (int ortho_item = 0; ortho_item < ortho_end; ++ortho_item) {
993                 if ((orient == Qt::Horizontal) ? filterAcceptsRowInternal(ortho_item, source_parent)
994                         : q->filterAcceptsColumn(ortho_item, source_parent)) {
995                     orthogonal_proxy_to_source.append(ortho_item);
996                 }
997             }
998             if (orient == Qt::Horizontal) {
999                 // We're reacting to columnsInserted, but we've just inserted new rows. Sort them.
1000                 sort_source_rows(orthogonal_proxy_to_source, source_parent);
1001             }
1002             build_source_to_proxy_mapping(orthogonal_proxy_to_source, orthogonal_source_to_proxy);
1003         }
1004     }
1005 
1006     // Sort and insert the items
1007     if (orient == Qt::Vertical) // Only sort rows
1008         sort_source_rows(source_items, source_parent);
1009     insert_source_items(source_to_proxy, proxy_to_source, source_items, source_parent, orient);
1010 }
1011 
1012 /*!
1013   \internal
1014 
1015   Handles source model items removal
1016   (columnsAboutToBeRemoved(), rowsAboutToBeRemoved()).
1017 */
1018 void QSortFilterProxyModelPrivate::source_items_about_to_be_removed(
1019     const QModelIndex &source_parent, int start, int end, Qt::Orientation orient)
1020 {
1021     if ((start < 0) || (end < 0))
1022         return;
1023     IndexMap::const_iterator it = source_index_mapping.constFind(source_parent);
1024     if (it == source_index_mapping.constEnd()) {
1025         // Don't care, since we don't have mapping for this index
1026         return;
1027     }
1028 
1029     Mapping *m = it.value();
1030     QVector<int> &source_to_proxy = (orient == Qt::Vertical) ? m->proxy_rows : m->proxy_columns;
1031     QVector<int> &proxy_to_source = (orient == Qt::Vertical) ? m->source_rows : m->source_columns;
1032 
1033     // figure out which items to remove
1034     QVector<int> source_items_to_remove;
1035     int proxy_count = proxy_to_source.size();
1036     for (int proxy_item = 0; proxy_item < proxy_count; ++proxy_item) {
1037         int source_item = proxy_to_source.at(proxy_item);
1038         if ((source_item >= start) && (source_item <= end))
1039             source_items_to_remove.append(source_item);
1040     }
1041 
1042     remove_source_items(source_to_proxy, proxy_to_source, source_items_to_remove,
1043                         source_parent, orient);
1044 }
1045 
1046 /*!
1047   \internal
1048 
1049   Handles source model items removal (columnsRemoved(), rowsRemoved()).
1050 */
1051 void QSortFilterProxyModelPrivate::source_items_removed(
1052     const QModelIndex &source_parent, int start, int end, Qt::Orientation orient)
1053 {
1054     if ((start < 0) || (end < 0))
1055         return;
1056     IndexMap::const_iterator it = source_index_mapping.constFind(source_parent);
1057     if (it == source_index_mapping.constEnd()) {
1058         // Don't care, since we don't have mapping for this index
1059         return;
1060     }
1061 
1062     Mapping *m = it.value();
1063     QVector<int> &source_to_proxy = (orient == Qt::Vertical) ? m->proxy_rows : m->proxy_columns;
1064     QVector<int> &proxy_to_source = (orient == Qt::Vertical) ? m->source_rows : m->source_columns;
1065 
1066     if (end >= source_to_proxy.size())
1067         end = source_to_proxy.size() - 1;
1068 
1069     // Shrink the source-to-proxy mapping to reflect the new item count
1070     int delta_item_count = end - start + 1;
1071     source_to_proxy.remove(start, delta_item_count);
1072 
1073     int proxy_count = proxy_to_source.size();
1074     if (proxy_count > source_to_proxy.size()) {
1075         // mapping is in an inconsistent state -- redo the whole mapping
1076         qWarning("QSortFilterProxyModel: inconsistent changes reported by source model");
1077         Q_Q(QSortFilterProxyModel);
1078         q->beginResetModel();
1079         remove_from_mapping(source_parent);
1080         q->endResetModel();
1081         return;
1082     }
1083 
1084     // Adjust "stale" indexes in proxy-to-source mapping
1085     for (int proxy_item = 0; proxy_item < proxy_count; ++proxy_item) {
1086         int source_item = proxy_to_source.at(proxy_item);
1087         if (source_item >= start) {
1088             Q_ASSERT(source_item - delta_item_count >= 0);
1089             proxy_to_source.replace(proxy_item, source_item - delta_item_count);
1090         }
1091     }
1092     build_source_to_proxy_mapping(proxy_to_source, source_to_proxy);
1093 
1094     updateChildrenMapping(source_parent, m, orient, start, end, delta_item_count, true);
1095 
1096 }
1097 
1098 
1099 /*!
1100   \internal
1101   updates the mapping of the children when inserting or removing items
1102 */
1103 void QSortFilterProxyModelPrivate::updateChildrenMapping(const QModelIndex &source_parent, Mapping *parent_mapping,
1104                                                          Qt::Orientation orient, int start, int end, int delta_item_count, bool remove)
1105 {
1106     // see if any mapped children should be (re)moved
1107     QVector<QPair<QModelIndex, Mapping*> > moved_source_index_mappings;
1108     QVector<QModelIndex>::iterator it2 = parent_mapping->mapped_children.begin();
1109     for ( ; it2 != parent_mapping->mapped_children.end();) {
1110         const QModelIndex source_child_index = *it2;
1111         const int pos = (orient == Qt::Vertical)
1112                         ? source_child_index.row()
1113                         : source_child_index.column();
1114         if (pos < start) {
1115             // not affected
1116             ++it2;
1117         } else if (remove && pos <= end) {
1118             // in the removed interval
1119             it2 = parent_mapping->mapped_children.erase(it2);
1120             remove_from_mapping(source_child_index);
1121         } else {
1122             // below the removed items -- recompute the index
1123             QModelIndex new_index;
1124             const int newpos = remove ? pos - delta_item_count : pos + delta_item_count;
1125             if (orient == Qt::Vertical) {
1126                 new_index = model->index(newpos,
1127                                          source_child_index.column(),
1128                                          source_parent);
1129             } else {
1130                 new_index = model->index(source_child_index.row(),
1131                                          newpos,
1132                                          source_parent);
1133             }
1134             *it2 = new_index;
1135             ++it2;
1136 
1137             // update mapping
1138             Mapping *cm = source_index_mapping.take(source_child_index);
1139             Q_ASSERT(cm);
1140             // we do not reinsert right away, because the new index might be identical with another, old index
1141             moved_source_index_mappings.append(QPair<QModelIndex, Mapping*>(new_index, cm));
1142         }
1143     }
1144 
1145     // reinsert moved, mapped indexes
1146     QVector<QPair<QModelIndex, Mapping*> >::iterator it = moved_source_index_mappings.begin();
1147     for (; it != moved_source_index_mappings.end(); ++it) {
1148         (*it).second->map_iter = QHash<QModelIndex, Mapping *>::const_iterator(source_index_mapping.insert((*it).first, (*it).second));
1149     }
1150 }
1151 
1152 /*!
1153   \internal
1154 */
1155 void QSortFilterProxyModelPrivate::proxy_item_range(
1156     const QVector<int> &source_to_proxy, const QVector<int> &source_items,
1157     int &proxy_low, int &proxy_high) const
1158 {
1159     proxy_low = INT_MAX;
1160     proxy_high = INT_MIN;
1161     for (int i = 0; i < source_items.count(); ++i) {
1162         int proxy_item = source_to_proxy.at(source_items.at(i));
1163         Q_ASSERT(proxy_item != -1);
1164         if (proxy_item < proxy_low)
1165             proxy_low = proxy_item;
1166         if (proxy_item > proxy_high)
1167             proxy_high = proxy_item;
1168     }
1169 }
1170 
1171 /*!
1172   \internal
1173 */
1174 void QSortFilterProxyModelPrivate::build_source_to_proxy_mapping(
1175     const QVector<int> &proxy_to_source, QVector<int> &source_to_proxy) const
1176 {
1177     source_to_proxy.fill(-1);
1178     int proxy_count = proxy_to_source.size();
1179     for (int i = 0; i < proxy_count; ++i)
1180         source_to_proxy[proxy_to_source.at(i)] = i;
1181 }
1182 
1183 /*!
1184   \internal
1185 
1186   Maps the persistent proxy indexes to source indexes and
1187   returns the list of source indexes.
1188 */
1189 QModelIndexPairList QSortFilterProxyModelPrivate::store_persistent_indexes() const
1190 {
1191     Q_Q(const QSortFilterProxyModel);
1192     QModelIndexPairList source_indexes;
1193     source_indexes.reserve(persistent.indexes.count());
1194     for (QPersistentModelIndexData *data : qAsConst(persistent.indexes)) {
1195         QModelIndex proxy_index = data->index;
1196         QModelIndex source_index = q->mapToSource(proxy_index);
1197         source_indexes.append(qMakePair(proxy_index, QPersistentModelIndex(source_index)));
1198     }
1199     return source_indexes;
1200 }
1201 
1202 /*!
1203   \internal
1204 
1205   Maps \a source_indexes to proxy indexes and stores those
1206   as persistent indexes.
1207 */
1208 void QSortFilterProxyModelPrivate::update_persistent_indexes(
1209         const QModelIndexPairList &source_indexes)
1210 {
1211     Q_Q(QSortFilterProxyModel);
1212     QModelIndexList from, to;
1213     const int numSourceIndexes = source_indexes.count();
1214     from.reserve(numSourceIndexes);
1215     to.reserve(numSourceIndexes);
1216     for (int i = 0; i < numSourceIndexes; ++i) {
1217         QModelIndex source_index = source_indexes.at(i).second;
1218         QModelIndex old_proxy_index = source_indexes.at(i).first;
1219         create_mapping(source_index.parent());
1220         QModelIndex proxy_index = q->mapFromSource(source_index);
1221         from << old_proxy_index;
1222         to << proxy_index;
1223     }
1224     q->changePersistentIndexList(from, to);
1225 }
1226 
1227 /*!
1228   \internal
1229 
1230   Updates the source_index mapping in case it's invalid and we
1231   need it because we have a valid filter
1232 */
1233 void QSortFilterProxyModelPrivate::filter_about_to_be_changed(const QModelIndex &source_parent)
1234 {
1235   if (!filter_data.isEmpty() &&
1236         source_index_mapping.constFind(source_parent) == source_index_mapping.constEnd())
1237     create_mapping(source_parent);
1238 }
1239 
1240 
1241 /*!
1242   \internal
1243 
1244   Updates the proxy model (adds/removes rows) based on the
1245   new filter.
1246 */
1247 void QSortFilterProxyModelPrivate::filter_changed(const QModelIndex &source_parent)
1248 {
1249     IndexMap::const_iterator it = source_index_mapping.constFind(source_parent);
1250     if (it == source_index_mapping.constEnd())
1251         return;
1252     Mapping *m = it.value();
1253     QSet<int> rows_removed = handle_filter_changed(m->proxy_rows, m->source_rows, source_parent, Qt::Vertical);
1254     QSet<int> columns_removed = handle_filter_changed(m->proxy_columns, m->source_columns, source_parent, Qt::Horizontal);
1255 
1256     // We need to iterate over a copy of m->mapped_children because otherwise it may be changed by other code, invalidating
1257     // the iterator it2.
1258     // The m->mapped_children vector can be appended to with indexes which are no longer filtered
1259     // out (in create_mapping) when this function recurses for child indexes.
1260     const QVector<QModelIndex> mappedChildren = m->mapped_children;
1261     QVector<int> indexesToRemove;
1262     for (int i = 0; i < mappedChildren.size(); ++i) {
1263         const QModelIndex source_child_index = mappedChildren.at(i);
1264         if (rows_removed.contains(source_child_index.row()) || columns_removed.contains(source_child_index.column())) {
1265             indexesToRemove.push_back(i);
1266             remove_from_mapping(source_child_index);
1267         } else {
1268             filter_changed(source_child_index);
1269         }
1270     }
1271     QVector<int>::const_iterator removeIt = indexesToRemove.constEnd();
1272     const QVector<int>::const_iterator removeBegin = indexesToRemove.constBegin();
1273 
1274     // We can't just remove these items from mappedChildren while iterating above and then
1275     // do something like m->mapped_children = mappedChildren, because mapped_children might
1276     // be appended to in create_mapping, and we would lose those new items.
1277     // Because they are always appended in create_mapping, we can still remove them by
1278     // position here.
1279     while (removeIt != removeBegin) {
1280         --removeIt;
1281         m->mapped_children.remove(*removeIt);
1282     }
1283 }
1284 
1285 /*!
1286   \internal
1287   returns the removed items indexes
1288 */
1289 QSet<int> QSortFilterProxyModelPrivate::handle_filter_changed(
1290     QVector<int> &source_to_proxy, QVector<int> &proxy_to_source,
1291     const QModelIndex &source_parent, Qt::Orientation orient)
1292 {
1293     Q_Q(QSortFilterProxyModel);
1294     // Figure out which mapped items to remove
1295     QVector<int> source_items_remove;
1296     for (int i = 0; i < proxy_to_source.count(); ++i) {
1297         const int source_item = proxy_to_source.at(i);
1298         if ((orient == Qt::Vertical)
1299             ? !filterAcceptsRowInternal(source_item, source_parent)
1300             : !q->filterAcceptsColumn(source_item, source_parent)) {
1301             // This source item does not satisfy the filter, so it must be removed
1302             source_items_remove.append(source_item);
1303         }
1304     }
1305     // Figure out which non-mapped items to insert
1306     QVector<int> source_items_insert;
1307     int source_count = source_to_proxy.size();
1308     for (int source_item = 0; source_item < source_count; ++source_item) {
1309         if (source_to_proxy.at(source_item) == -1) {
1310             if ((orient == Qt::Vertical)
1311                 ? filterAcceptsRowInternal(source_item, source_parent)
1312                 : q->filterAcceptsColumn(source_item, source_parent)) {
1313                 // This source item satisfies the filter, so it must be added
1314                 source_items_insert.append(source_item);
1315             }
1316         }
1317     }
1318     if (!source_items_remove.isEmpty() || !source_items_insert.isEmpty()) {
1319         // Do item removal and insertion
1320         remove_source_items(source_to_proxy, proxy_to_source,
1321                             source_items_remove, source_parent, orient);
1322         if (orient == Qt::Vertical)
1323             sort_source_rows(source_items_insert, source_parent);
1324         insert_source_items(source_to_proxy, proxy_to_source,
1325                             source_items_insert, source_parent, orient);
1326     }
1327     return qVectorToSet(source_items_remove);
1328 }
1329 
1330 bool QSortFilterProxyModelPrivate::needsReorder(const QVector<int> &source_rows, const QModelIndex &source_parent) const
1331 {
1332     Q_Q(const QSortFilterProxyModel);
1333     Q_ASSERT(source_sort_column != -1);
1334     const int proxyRowCount = q->rowCount(source_to_proxy(source_parent));
1335     // If any modified proxy row no longer passes lessThan(previous, current) or lessThan(current, next) then we need to reorder.
1336     return std::any_of(source_rows.begin(), source_rows.end(),
1337             [this, q, proxyRowCount, source_parent](int sourceRow) -> bool {
1338         const QModelIndex sourceIndex = model->index(sourceRow, source_sort_column, source_parent);
1339         const QModelIndex proxyIndex = source_to_proxy(sourceIndex);
1340         Q_ASSERT(proxyIndex.isValid()); // caller ensured source_rows were not filtered out
1341         if (proxyIndex.row() > 0) {
1342             const QModelIndex prevProxyIndex = q->sibling(proxyIndex.row() - 1, proxy_sort_column, proxyIndex);
1343             const QModelIndex prevSourceIndex = proxy_to_source(prevProxyIndex);
1344             if (sort_order == Qt::AscendingOrder ? q->lessThan(sourceIndex, prevSourceIndex) : q->lessThan(prevSourceIndex, sourceIndex))
1345                 return true;
1346         }
1347         if (proxyIndex.row() < proxyRowCount - 1) {
1348             const QModelIndex nextProxyIndex = q->sibling(proxyIndex.row() + 1, proxy_sort_column, proxyIndex);
1349             const QModelIndex nextSourceIndex = proxy_to_source(nextProxyIndex);
1350             if (sort_order == Qt::AscendingOrder ? q->lessThan(nextSourceIndex, sourceIndex) : q->lessThan(sourceIndex, nextSourceIndex))
1351                 return true;
1352         }
1353         return false;
1354     });
1355 }
1356 
1357 void QSortFilterProxyModelPrivate::_q_sourceDataChanged(const QModelIndex &source_top_left,
1358                                                         const QModelIndex &source_bottom_right,
1359                                                         const QVector<int> &roles)
1360 {
1361     Q_Q(QSortFilterProxyModel);
1362     if (!source_top_left.isValid() || !source_bottom_right.isValid())
1363         return;
1364 
1365     std::vector<QSortFilterProxyModelDataChanged> data_changed_list;
1366     data_changed_list.emplace_back(source_top_left, source_bottom_right);
1367 
1368     // Do check parents if the filter role have changed and we are recursive
1369     if (filter_recursive && (roles.isEmpty() || roles.contains(filter_role))) {
1370         QModelIndex source_parent = source_top_left.parent();
1371 
1372         while (source_parent.isValid()) {
1373             data_changed_list.emplace_back(source_parent, source_parent);
1374             source_parent = source_parent.parent();
1375         }
1376     }
1377 
1378     for (const QSortFilterProxyModelDataChanged &data_changed : data_changed_list) {
1379         const QModelIndex &source_top_left = data_changed.topLeft;
1380         const QModelIndex &source_bottom_right = data_changed.bottomRight;
1381         const QModelIndex source_parent = source_top_left.parent();
1382 
1383         IndexMap::const_iterator it = source_index_mapping.constFind(source_parent);
1384         if (it == source_index_mapping.constEnd()) {
1385             // Don't care, since we don't have mapping for this index
1386             continue;
1387         }
1388         Mapping *m = it.value();
1389 
1390         // Figure out how the source changes affect us
1391         QVector<int> source_rows_remove;
1392         QVector<int> source_rows_insert;
1393         QVector<int> source_rows_change;
1394         QVector<int> source_rows_resort;
1395         int end = qMin(source_bottom_right.row(), m->proxy_rows.count() - 1);
1396         for (int source_row = source_top_left.row(); source_row <= end; ++source_row) {
1397             if (dynamic_sortfilter) {
1398                 if (m->proxy_rows.at(source_row) != -1) {
1399                     if (!filterAcceptsRowInternal(source_row, source_parent)) {
1400                         // This source row no longer satisfies the filter, so it must be removed
1401                         source_rows_remove.append(source_row);
1402                     } else if (source_sort_column >= source_top_left.column() && source_sort_column <= source_bottom_right.column()) {
1403                         // This source row has changed in a way that may affect sorted order
1404                         source_rows_resort.append(source_row);
1405                     } else {
1406                         // This row has simply changed, without affecting filtering nor sorting
1407                         source_rows_change.append(source_row);
1408                     }
1409                 } else {
1410                     if (!itemsBeingRemoved.contains(source_parent, source_row) && filterAcceptsRowInternal(source_row, source_parent)) {
1411                         // This source row now satisfies the filter, so it must be added
1412                         source_rows_insert.append(source_row);
1413                     }
1414                 }
1415             } else {
1416                 if (m->proxy_rows.at(source_row) != -1)
1417                     source_rows_change.append(source_row);
1418             }
1419         }
1420 
1421         if (!source_rows_remove.isEmpty()) {
1422             remove_source_items(m->proxy_rows, m->source_rows,
1423                                 source_rows_remove, source_parent, Qt::Vertical);
1424             QSet<int> source_rows_remove_set = qVectorToSet(source_rows_remove);
1425             QVector<QModelIndex>::iterator childIt = m->mapped_children.end();
1426             while (childIt != m->mapped_children.begin()) {
1427                 --childIt;
1428                 const QModelIndex source_child_index = *childIt;
1429                 if (source_rows_remove_set.contains(source_child_index.row())) {
1430                     childIt = m->mapped_children.erase(childIt);
1431                     remove_from_mapping(source_child_index);
1432                 }
1433             }
1434         }
1435 
1436         if (!source_rows_resort.isEmpty()) {
1437             if (needsReorder(source_rows_resort, source_parent)) {
1438                 // Re-sort the rows of this level
1439                 QList<QPersistentModelIndex> parents;
1440                 parents << q->mapFromSource(source_parent);
1441                 emit q->layoutAboutToBeChanged(parents, QAbstractItemModel::VerticalSortHint);
1442                 QModelIndexPairList source_indexes = store_persistent_indexes();
1443                 remove_source_items(m->proxy_rows, m->source_rows, source_rows_resort,
1444                         source_parent, Qt::Vertical, false);
1445                 sort_source_rows(source_rows_resort, source_parent);
1446                 insert_source_items(m->proxy_rows, m->source_rows, source_rows_resort,
1447                         source_parent, Qt::Vertical, false);
1448                 update_persistent_indexes(source_indexes);
1449                 emit q->layoutChanged(parents, QAbstractItemModel::VerticalSortHint);
1450             }
1451             // Make sure we also emit dataChanged for the rows
1452             source_rows_change += source_rows_resort;
1453         }
1454 
1455         if (!source_rows_change.isEmpty()) {
1456             // Find the proxy row range
1457             int proxy_start_row;
1458             int proxy_end_row;
1459             proxy_item_range(m->proxy_rows, source_rows_change,
1460                              proxy_start_row, proxy_end_row);
1461             // ### Find the proxy column range also
1462             if (proxy_end_row >= 0) {
1463                 // the row was accepted, but some columns might still be filtered out
1464                 int source_left_column = source_top_left.column();
1465                 while (source_left_column < source_bottom_right.column()
1466                        && m->proxy_columns.at(source_left_column) == -1)
1467                     ++source_left_column;
1468                 const QModelIndex proxy_top_left = create_index(
1469                     proxy_start_row, m->proxy_columns.at(source_left_column), it);
1470                 int source_right_column = source_bottom_right.column();
1471                 while (source_right_column > source_top_left.column()
1472                        && m->proxy_columns.at(source_right_column) == -1)
1473                     --source_right_column;
1474                 const QModelIndex proxy_bottom_right = create_index(
1475                     proxy_end_row, m->proxy_columns.at(source_right_column), it);
1476                 emit q->dataChanged(proxy_top_left, proxy_bottom_right, roles);
1477             }
1478         }
1479 
1480         if (!source_rows_insert.isEmpty()) {
1481             sort_source_rows(source_rows_insert, source_parent);
1482             insert_source_items(m->proxy_rows, m->source_rows,
1483                                 source_rows_insert, source_parent, Qt::Vertical);
1484         }
1485     }
1486 }
1487 
1488 void QSortFilterProxyModelPrivate::_q_sourceHeaderDataChanged(Qt::Orientation orientation,
1489                                                            int start, int end)
1490 {
1491     Q_ASSERT(start <= end);
1492 
1493     Q_Q(QSortFilterProxyModel);
1494     Mapping *m = create_mapping(QModelIndex()).value();
1495 
1496     const QVector<int> &source_to_proxy = (orientation == Qt::Vertical) ? m->proxy_rows : m->proxy_columns;
1497 
1498     QVector<int> proxy_positions;
1499     proxy_positions.reserve(end - start + 1);
1500     {
1501         Q_ASSERT(source_to_proxy.size() > end);
1502         QVector<int>::const_iterator it = source_to_proxy.constBegin() + start;
1503         const QVector<int>::const_iterator endIt = source_to_proxy.constBegin() + end + 1;
1504         for ( ; it != endIt; ++it) {
1505             if (*it != -1)
1506                 proxy_positions.push_back(*it);
1507         }
1508     }
1509 
1510     std::sort(proxy_positions.begin(), proxy_positions.end());
1511 
1512     int last_index = 0;
1513     const int numItems = proxy_positions.size();
1514     while (last_index < numItems) {
1515         const int proxyStart = proxy_positions.at(last_index);
1516         int proxyEnd = proxyStart;
1517         ++last_index;
1518         for (int i = last_index; i < numItems; ++i) {
1519             if (proxy_positions.at(i) == proxyEnd + 1) {
1520                 ++last_index;
1521                 ++proxyEnd;
1522             } else {
1523                 break;
1524             }
1525         }
1526         emit q->headerDataChanged(orientation, proxyStart, proxyEnd);
1527     }
1528 }
1529 
1530 void QSortFilterProxyModelPrivate::_q_sourceAboutToBeReset()
1531 {
1532     Q_Q(QSortFilterProxyModel);
1533     q->beginResetModel();
1534 }
1535 
1536 void QSortFilterProxyModelPrivate::_q_sourceReset()
1537 {
1538     Q_Q(QSortFilterProxyModel);
1539     invalidatePersistentIndexes();
1540     _q_clearMapping();
1541     // All internal structures are deleted in clear()
1542     q->endResetModel();
1543     update_source_sort_column();
1544     if (dynamic_sortfilter && update_source_sort_column())
1545         sort();
1546 }
1547 
1548 void QSortFilterProxyModelPrivate::_q_sourceLayoutAboutToBeChanged(const QList<QPersistentModelIndex> &sourceParents, QAbstractItemModel::LayoutChangeHint hint)
1549 {
1550     Q_Q(QSortFilterProxyModel);
1551     Q_UNUSED(hint); // We can't forward Hint because we might filter additional rows or columns
1552     saved_persistent_indexes.clear();
1553 
1554     saved_layoutChange_parents.clear();
1555     for (const QPersistentModelIndex &parent : sourceParents) {
1556         if (!parent.isValid()) {
1557             saved_layoutChange_parents << QPersistentModelIndex();
1558             continue;
1559         }
1560         const QModelIndex mappedParent = q->mapFromSource(parent);
1561         // Might be filtered out.
1562         if (mappedParent.isValid())
1563             saved_layoutChange_parents << mappedParent;
1564     }
1565 
1566     // All parents filtered out.
1567     if (!sourceParents.isEmpty() && saved_layoutChange_parents.isEmpty())
1568         return;
1569 
1570     emit q->layoutAboutToBeChanged(saved_layoutChange_parents);
1571     if (persistent.indexes.isEmpty())
1572         return;
1573 
1574     saved_persistent_indexes = store_persistent_indexes();
1575 }
1576 
1577 void QSortFilterProxyModelPrivate::_q_sourceLayoutChanged(const QList<QPersistentModelIndex> &sourceParents, QAbstractItemModel::LayoutChangeHint hint)
1578 {
1579     Q_Q(QSortFilterProxyModel);
1580     Q_UNUSED(hint); // We can't forward Hint because we might filter additional rows or columns
1581 
1582     if (!sourceParents.isEmpty() && saved_layoutChange_parents.isEmpty())
1583         return;
1584 
1585     // Optimize: We only actually have to clear the mapping related to the contents of
1586     // sourceParents, not everything.
1587     qDeleteAll(source_index_mapping);
1588     source_index_mapping.clear();
1589 
1590     update_persistent_indexes(saved_persistent_indexes);
1591     saved_persistent_indexes.clear();
1592 
1593     if (dynamic_sortfilter && update_source_sort_column()) {
1594         //update_source_sort_column might have created wrong mapping so we have to clear it again
1595         qDeleteAll(source_index_mapping);
1596         source_index_mapping.clear();
1597     }
1598 
1599     emit q->layoutChanged(saved_layoutChange_parents);
1600     saved_layoutChange_parents.clear();
1601 }
1602 
1603 void QSortFilterProxyModelPrivate::_q_sourceRowsAboutToBeInserted(
1604     const QModelIndex &source_parent, int start, int end)
1605 {
1606     Q_UNUSED(start);
1607     Q_UNUSED(end);
1608 
1609     const bool toplevel = !source_parent.isValid();
1610     const bool recursive_accepted = filter_recursive && !toplevel && filterAcceptsRowInternal(source_parent.row(), source_parent.parent());
1611     //Force the creation of a mapping now, even if its empty.
1612     //We need it because the proxy can be acessed at the moment it emits rowsAboutToBeInserted in insert_source_items
1613     if (!filter_recursive || toplevel || recursive_accepted) {
1614         if (can_create_mapping(source_parent))
1615             create_mapping(source_parent);
1616         if (filter_recursive)
1617             complete_insert = true;
1618     } else {
1619         // The row could have been rejected or the parent might be not yet known... let's try to discover it
1620         QModelIndex top_source_parent = source_parent;
1621         QModelIndex parent = source_parent.parent();
1622         QModelIndex grandParent = parent.parent();
1623 
1624         while (parent.isValid() && !filterAcceptsRowInternal(parent.row(), grandParent)) {
1625             top_source_parent = parent;
1626             parent = grandParent;
1627             grandParent = parent.parent();
1628         }
1629 
1630         last_top_source = top_source_parent;
1631     }
1632 }
1633 
1634 void QSortFilterProxyModelPrivate::_q_sourceRowsInserted(
1635     const QModelIndex &source_parent, int start, int end)
1636 {
1637     if (!filter_recursive || complete_insert) {
1638         if (filter_recursive)
1639             complete_insert = false;
1640         source_items_inserted(source_parent, start, end, Qt::Vertical);
1641         if (update_source_sort_column() && dynamic_sortfilter) //previous call to update_source_sort_column may fail if the model has no column.
1642             sort();                      // now it should succeed so we need to make sure to sort again
1643         return;
1644     }
1645 
1646     if (filter_recursive) {
1647         bool accept = false;
1648 
1649         for (int row = start; row <= end; ++row) {
1650             if (filterAcceptsRowInternal(row, source_parent)) {
1651                 accept = true;
1652                 break;
1653             }
1654         }
1655 
1656         if (!accept) // the new rows have no descendants that match the filter, filter them out.
1657             return;
1658 
1659         // last_top_source should now become visible
1660         _q_sourceDataChanged(last_top_source, last_top_source, QVector<int>());
1661     }
1662 }
1663 
1664 void QSortFilterProxyModelPrivate::_q_sourceRowsAboutToBeRemoved(
1665     const QModelIndex &source_parent, int start, int end)
1666 {
1667     itemsBeingRemoved = QRowsRemoval(source_parent, start, end);
1668     source_items_about_to_be_removed(source_parent, start, end,
1669                                      Qt::Vertical);
1670 }
1671 
1672 void QSortFilterProxyModelPrivate::_q_sourceRowsRemoved(
1673     const QModelIndex &source_parent, int start, int end)
1674 {
1675     itemsBeingRemoved = QRowsRemoval();
1676     source_items_removed(source_parent, start, end, Qt::Vertical);
1677 
1678     if (filter_recursive) {
1679         // Find out if removing this visible row means that some ascendant
1680         // row can now be hidden.
1681         // We go up until we find a row that should still be visible
1682         // and then make QSFPM re-evaluate the last one we saw before that, to hide it.
1683 
1684         QModelIndex to_hide;
1685         QModelIndex source_ascendant = source_parent;
1686 
1687         while (source_ascendant.isValid()) {
1688             if (filterAcceptsRowInternal(source_ascendant.row(), source_ascendant.parent()))
1689                 break;
1690 
1691             to_hide = source_ascendant;
1692             source_ascendant = source_ascendant.parent();
1693         }
1694 
1695         if (to_hide.isValid())
1696             _q_sourceDataChanged(to_hide, to_hide, QVector<int>());
1697     }
1698 }
1699 
1700 void QSortFilterProxyModelPrivate::_q_sourceRowsAboutToBeMoved(
1701     const QModelIndex &sourceParent, int /* sourceStart */, int /* sourceEnd */, const QModelIndex &destParent, int /* dest */)
1702 {
1703     // Because rows which are contiguous in the source model might not be contiguous
1704     // in the proxy due to sorting, the best thing we can do here is be specific about what
1705     // parents are having their children changed.
1706     // Optimize: Emit move signals if the proxy is not sorted. Will need to account for rows
1707     // being filtered out though.
1708 
1709     QList<QPersistentModelIndex> parents;
1710     parents << sourceParent;
1711     if (sourceParent != destParent)
1712         parents << destParent;
1713     _q_sourceLayoutAboutToBeChanged(parents, QAbstractItemModel::NoLayoutChangeHint);
1714 }
1715 
1716 void QSortFilterProxyModelPrivate::_q_sourceRowsMoved(
1717     const QModelIndex &sourceParent, int /* sourceStart */, int /* sourceEnd */, const QModelIndex &destParent, int /* dest */)
1718 {
1719     QList<QPersistentModelIndex> parents;
1720     parents << sourceParent;
1721     if (sourceParent != destParent)
1722         parents << destParent;
1723     _q_sourceLayoutChanged(parents, QAbstractItemModel::NoLayoutChangeHint);
1724 }
1725 
1726 void QSortFilterProxyModelPrivate::_q_sourceColumnsAboutToBeInserted(
1727     const QModelIndex &source_parent, int start, int end)
1728 {
1729     Q_UNUSED(start);
1730     Q_UNUSED(end);
1731     //Force the creation of a mapping now, even if its empty.
1732     //We need it because the proxy can be acessed at the moment it emits columnsAboutToBeInserted in insert_source_items
1733     if (can_create_mapping(source_parent))
1734         create_mapping(source_parent);
1735 }
1736 
1737 void QSortFilterProxyModelPrivate::_q_sourceColumnsInserted(
1738     const QModelIndex &source_parent, int start, int end)
1739 {
1740     Q_Q(const QSortFilterProxyModel);
1741     source_items_inserted(source_parent, start, end, Qt::Horizontal);
1742 
1743     if (source_parent.isValid())
1744         return; //we sort according to the root column only
1745     if (source_sort_column == -1) {
1746         //we update the source_sort_column depending on the proxy_sort_column
1747         if (update_source_sort_column() && dynamic_sortfilter)
1748             sort();
1749     } else {
1750         if (start <= source_sort_column)
1751             source_sort_column += end - start + 1;
1752 
1753         proxy_sort_column = q->mapFromSource(model->index(0,source_sort_column, source_parent)).column();
1754     }
1755 }
1756 
1757 void QSortFilterProxyModelPrivate::_q_sourceColumnsAboutToBeRemoved(
1758     const QModelIndex &source_parent, int start, int end)
1759 {
1760     source_items_about_to_be_removed(source_parent, start, end,
1761                                      Qt::Horizontal);
1762 }
1763 
1764 void QSortFilterProxyModelPrivate::_q_sourceColumnsRemoved(
1765     const QModelIndex &source_parent, int start, int end)
1766 {
1767     Q_Q(const QSortFilterProxyModel);
1768     source_items_removed(source_parent, start, end, Qt::Horizontal);
1769 
1770     if (source_parent.isValid())
1771         return; //we sort according to the root column only
1772     if (start <= source_sort_column) {
1773         if (end < source_sort_column)
1774             source_sort_column -= end - start + 1;
1775         else
1776             source_sort_column = -1;
1777     }
1778 
1779     proxy_sort_column = q->mapFromSource(model->index(0,source_sort_column, source_parent)).column();
1780 }
1781 
1782 void QSortFilterProxyModelPrivate::_q_sourceColumnsAboutToBeMoved(
1783     const QModelIndex &sourceParent, int /* sourceStart */, int /* sourceEnd */, const QModelIndex &destParent, int /* dest */)
1784 {
1785     QList<QPersistentModelIndex> parents;
1786     parents << sourceParent;
1787     if (sourceParent != destParent)
1788         parents << destParent;
1789     _q_sourceLayoutAboutToBeChanged(parents, QAbstractItemModel::NoLayoutChangeHint);
1790 }
1791 
1792 void QSortFilterProxyModelPrivate::_q_sourceColumnsMoved(
1793     const QModelIndex &sourceParent, int /* sourceStart */, int /* sourceEnd */, const QModelIndex &destParent, int /* dest */)
1794 {
1795     QList<QPersistentModelIndex> parents;
1796     parents << sourceParent;
1797     if (sourceParent != destParent)
1798         parents << destParent;
1799     _q_sourceLayoutChanged(parents, QAbstractItemModel::NoLayoutChangeHint);
1800 }
1801 
1802 /*!
1803     \since 4.1
1804     \class QSortFilterProxyModel
1805     \inmodule QtCore
1806     \brief The QSortFilterProxyModel class provides support for sorting and
1807     filtering data passed between another model and a view.
1808 
1809     \ingroup model-view
1810 
1811     QSortFilterProxyModel can be used for sorting items, filtering out items,
1812     or both. The model transforms the structure of a source model by mapping
1813     the model indexes it supplies to new indexes, corresponding to different
1814     locations, for views to use. This approach allows a given source model to
1815     be restructured as far as views are concerned without requiring any
1816     transformations on the underlying data, and without duplicating the data in
1817     memory.
1818 
1819     Let's assume that we want to sort and filter the items provided by a custom
1820     model. The code to set up the model and the view, \e without sorting and
1821     filtering, would look like this:
1822 
1823     \snippet qsortfilterproxymodel-details/main.cpp 1
1824 
1825     To add sorting and filtering support to \c MyItemModel, we need to create
1826     a QSortFilterProxyModel, call setSourceModel() with the \c MyItemModel as
1827     argument, and install the QSortFilterProxyModel on the view:
1828 
1829     \snippet qsortfilterproxymodel-details/main.cpp 0
1830     \snippet qsortfilterproxymodel-details/main.cpp 2
1831 
1832     At this point, neither sorting nor filtering is enabled; the original data
1833     is displayed in the view. Any changes made through the
1834     QSortFilterProxyModel are applied to the original model.
1835 
1836     The QSortFilterProxyModel acts as a wrapper for the original model. If you
1837     need to convert source \l{QModelIndex}es to sorted/filtered model indexes
1838     or vice versa, use mapToSource(), mapFromSource(), mapSelectionToSource(),
1839     and mapSelectionFromSource().
1840 
1841     \note By default, the model dynamically re-sorts and re-filters data
1842     whenever the original model changes. This behavior can be changed by
1843     setting the \l{QSortFilterProxyModel::dynamicSortFilter}{dynamicSortFilter}
1844     property.
1845 
1846     The \l{itemviews/basicsortfiltermodel}{Basic Sort/Filter Model} and
1847     \l{itemviews/customsortfiltermodel}{Custom Sort/Filter Model} examples
1848     illustrate how to use QSortFilterProxyModel to perform basic sorting and
1849     filtering and how to subclass it to implement custom behavior.
1850 
1851     \section1 Sorting
1852 
1853     QTableView and QTreeView have a
1854     \l{QTreeView::sortingEnabled}{sortingEnabled} property that controls
1855     whether the user can sort the view by clicking the view's horizontal
1856     header. For example:
1857 
1858     \snippet qsortfilterproxymodel-details/main.cpp 3
1859 
1860     When this feature is on (the default is off), clicking on a header section
1861     sorts the items according to that column. By clicking repeatedly, the user
1862     can alternate between ascending and descending order.
1863 
1864     \image qsortfilterproxymodel-sorting.png A sorted QTreeView
1865 
1866     Behind the scene, the view calls the sort() virtual function on the model
1867     to reorder the data in the model. To make your data sortable, you can
1868     either implement sort() in your model, or use a QSortFilterProxyModel to
1869     wrap your model -- QSortFilterProxyModel provides a generic sort()
1870     reimplementation that operates on the sortRole() (Qt::DisplayRole by
1871     default) of the items and that understands several data types, including
1872     \c int, QString, and QDateTime. For hierarchical models, sorting is applied
1873     recursively to all child items. String comparisons are case sensitive by
1874     default; this can be changed by setting the \l{QSortFilterProxyModel::}
1875     {sortCaseSensitivity} property.
1876 
1877     Custom sorting behavior is achieved by subclassing
1878     QSortFilterProxyModel and reimplementing lessThan(), which is
1879     used to compare items. For example:
1880 
1881     \snippet ../widgets/itemviews/customsortfiltermodel/mysortfilterproxymodel.cpp 5
1882 
1883     (This code snippet comes from the
1884     \l{itemviews/customsortfiltermodel}{Custom Sort/Filter Model}
1885     example.)
1886 
1887     An alternative approach to sorting is to disable sorting on the view and to
1888     impose a certain order to the user. This is done by explicitly calling
1889     sort() with the desired column and order as arguments on the
1890     QSortFilterProxyModel (or on the original model if it implements sort()).
1891     For example:
1892 
1893     \snippet qsortfilterproxymodel-details/main.cpp 4
1894 
1895     QSortFilterProxyModel can be sorted by column -1, in which case it returns
1896     to the sort order of the underlying source model.
1897 
1898     \section1 Filtering
1899 
1900     In addition to sorting, QSortFilterProxyModel can be used to hide items
1901     that do not match a certain filter. The filter is specified using a QRegExp
1902     object and is applied to the filterRole() (Qt::DisplayRole by default) of
1903     each item, for a given column. The QRegExp object can be used to match a
1904     regular expression, a wildcard pattern, or a fixed string. For example:
1905 
1906     \snippet qsortfilterproxymodel-details/main.cpp 5
1907 
1908     For hierarchical models, the filter is applied recursively to all children.
1909     If a parent item doesn't match the filter, none of its children will be
1910     shown.
1911 
1912     A common use case is to let the user specify the filter regular expression,
1913     wildcard pattern, or fixed string in a QLineEdit and to connect the
1914     \l{QLineEdit::textChanged()}{textChanged()} signal to setFilterRegularExpression(),
1915     setFilterWildcard(), or setFilterFixedString() to reapply the filter.
1916 
1917     Custom filtering behavior can be achieved by reimplementing the
1918     filterAcceptsRow() and filterAcceptsColumn() functions. For
1919     example (from the \l{itemviews/customsortfiltermodel}
1920     {Custom Sort/Filter Model} example), the following implementation ignores
1921     the \l{QSortFilterProxyModel::filterKeyColumn}{filterKeyColumn} property
1922     and performs filtering on columns 0, 1, and 2:
1923 
1924     \snippet ../widgets/itemviews/customsortfiltermodel/mysortfilterproxymodel.cpp 3
1925 
1926     (This code snippet comes from the
1927     \l{itemviews/customsortfiltermodel}{Custom Sort/Filter Model}
1928     example.)
1929 
1930     If you are working with large amounts of filtering and have to invoke
1931     invalidateFilter() repeatedly, using reset() may be more efficient,
1932     depending on the implementation of your model. However, reset() returns the
1933     proxy model to its original state, losing selection information, and will
1934     cause the proxy model to be repopulated.
1935 
1936     \section1 Subclassing
1937 
1938     Since QAbstractProxyModel and its subclasses are derived from
1939     QAbstractItemModel, much of the same advice about subclassing normal models
1940     also applies to proxy models. In addition, it is worth noting that many of
1941     the default implementations of functions in this class are written so that
1942     they call the equivalent functions in the relevant source model. This
1943     simple proxying mechanism may need to be overridden for source models with
1944     more complex behavior; for example, if the source model provides a custom
1945     hasChildren() implementation, you should also provide one in the proxy
1946     model.
1947 
1948     \note Some general guidelines for subclassing models are available in the
1949     \l{Model Subclassing Reference}.
1950 
1951     \note With Qt 5, regular expression support has been improved through the
1952     QRegularExpression class. QSortFilterProxyModel dating back prior to that
1953     class creation, it originally supported only QRegExp. Since Qt 5.12,
1954     QRegularExpression API have been added. Therefore, QRegExp APIs should be
1955     considered deprecated and the QRegularExpression version should be used in
1956     place.
1957 
1958     \warning Don't mix the old and new APIs. For maximum compatibility, the
1959     original implementation has been kept. Therefore, if, for example, a call to
1960     setFilterRegularExpression is made followed by another one to
1961     setFilterFixedString, the first call will setup a QRegularExpression object
1962     to use as filter while the second will setup a QRegExp in FixedString mode.
1963 
1964     \sa QAbstractProxyModel, QAbstractItemModel, {Model/View Programming},
1965     {Basic Sort/Filter Model Example}, {Custom Sort/Filter Model Example}, QIdentityProxyModel
1966 */
1967 
1968 /*!
1969     Constructs a sorting filter model with the given \a parent.
1970 */
1971 
1972 QSortFilterProxyModel::QSortFilterProxyModel(QObject *parent)
1973     : QAbstractProxyModel(*new QSortFilterProxyModelPrivate, parent)
1974 {
1975     Q_D(QSortFilterProxyModel);
1976     d->proxy_sort_column = d->source_sort_column = -1;
1977     d->sort_order = Qt::AscendingOrder;
1978     d->sort_casesensitivity = Qt::CaseSensitive;
1979     d->sort_role = Qt::DisplayRole;
1980     d->sort_localeaware = false;
1981     d->filter_column = 0;
1982     d->filter_role = Qt::DisplayRole;
1983     d->filter_recursive = false;
1984     d->dynamic_sortfilter = true;
1985     d->complete_insert = false;
1986     connect(this, SIGNAL(modelReset()), this, SLOT(_q_clearMapping()));
1987 }
1988 
1989 /*!
1990     Destroys this sorting filter model.
1991 */
1992 QSortFilterProxyModel::~QSortFilterProxyModel()
1993 {
1994     Q_D(QSortFilterProxyModel);
1995     qDeleteAll(d->source_index_mapping);
1996     d->source_index_mapping.clear();
1997 }
1998 
1999 /*!
2000   \reimp
2001 */
2002 void QSortFilterProxyModel::setSourceModel(QAbstractItemModel *sourceModel)
2003 {
2004     Q_D(QSortFilterProxyModel);
2005 
2006     if (sourceModel == d->model)
2007         return;
2008 
2009     beginResetModel();
2010 
2011     disconnect(d->model, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
2012                this, SLOT(_q_sourceDataChanged(QModelIndex,QModelIndex,QVector<int>)));
2013 
2014     disconnect(d->model, SIGNAL(headerDataChanged(Qt::Orientation,int,int)),
2015                this, SLOT(_q_sourceHeaderDataChanged(Qt::Orientation,int,int)));
2016 
2017     disconnect(d->model, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
2018                this, SLOT(_q_sourceRowsAboutToBeInserted(QModelIndex,int,int)));
2019 
2020     disconnect(d->model, SIGNAL(rowsInserted(QModelIndex,int,int)),
2021                this, SLOT(_q_sourceRowsInserted(QModelIndex,int,int)));
2022 
2023     disconnect(d->model, SIGNAL(columnsAboutToBeInserted(QModelIndex,int,int)),
2024                this, SLOT(_q_sourceColumnsAboutToBeInserted(QModelIndex,int,int)));
2025 
2026     disconnect(d->model, SIGNAL(columnsInserted(QModelIndex,int,int)),
2027                this, SLOT(_q_sourceColumnsInserted(QModelIndex,int,int)));
2028 
2029     disconnect(d->model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
2030                this, SLOT(_q_sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
2031 
2032     disconnect(d->model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
2033                this, SLOT(_q_sourceRowsRemoved(QModelIndex,int,int)));
2034 
2035     disconnect(d->model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
2036                this, SLOT(_q_sourceColumnsAboutToBeRemoved(QModelIndex,int,int)));
2037 
2038     disconnect(d->model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
2039                this, SLOT(_q_sourceColumnsRemoved(QModelIndex,int,int)));
2040 
2041     disconnect(d->model, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
2042                this, SLOT(_q_sourceRowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
2043 
2044     disconnect(d->model, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
2045                this, SLOT(_q_sourceRowsMoved(QModelIndex,int,int,QModelIndex,int)));
2046 
2047     disconnect(d->model, SIGNAL(columnsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
2048                this, SLOT(_q_sourceColumnsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
2049 
2050     disconnect(d->model, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)),
2051                this, SLOT(_q_sourceColumnsMoved(QModelIndex,int,int,QModelIndex,int)));
2052 
2053     disconnect(d->model, SIGNAL(layoutAboutToBeChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)),
2054                this, SLOT(_q_sourceLayoutAboutToBeChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)));
2055 
2056     disconnect(d->model, SIGNAL(layoutChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)),
2057                this, SLOT(_q_sourceLayoutChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)));
2058 
2059     disconnect(d->model, SIGNAL(modelAboutToBeReset()), this, SLOT(_q_sourceAboutToBeReset()));
2060     disconnect(d->model, SIGNAL(modelReset()), this, SLOT(_q_sourceReset()));
2061 
2062     d->_q_sourceModelDestroyed();
2063     QAbstractProxyModel::setSourceModel(sourceModel);
2064 
2065     connect(d->model, SIGNAL(dataChanged(QModelIndex,QModelIndex,QVector<int>)),
2066             this, SLOT(_q_sourceDataChanged(QModelIndex,QModelIndex,QVector<int>)));
2067 
2068     connect(d->model, SIGNAL(headerDataChanged(Qt::Orientation,int,int)),
2069             this, SLOT(_q_sourceHeaderDataChanged(Qt::Orientation,int,int)));
2070 
2071     connect(d->model, SIGNAL(rowsAboutToBeInserted(QModelIndex,int,int)),
2072             this, SLOT(_q_sourceRowsAboutToBeInserted(QModelIndex,int,int)));
2073 
2074     connect(d->model, SIGNAL(rowsInserted(QModelIndex,int,int)),
2075             this, SLOT(_q_sourceRowsInserted(QModelIndex,int,int)));
2076 
2077     connect(d->model, SIGNAL(columnsAboutToBeInserted(QModelIndex,int,int)),
2078             this, SLOT(_q_sourceColumnsAboutToBeInserted(QModelIndex,int,int)));
2079 
2080     connect(d->model, SIGNAL(columnsInserted(QModelIndex,int,int)),
2081             this, SLOT(_q_sourceColumnsInserted(QModelIndex,int,int)));
2082 
2083     connect(d->model, SIGNAL(rowsAboutToBeRemoved(QModelIndex,int,int)),
2084             this, SLOT(_q_sourceRowsAboutToBeRemoved(QModelIndex,int,int)));
2085 
2086     connect(d->model, SIGNAL(rowsRemoved(QModelIndex,int,int)),
2087             this, SLOT(_q_sourceRowsRemoved(QModelIndex,int,int)));
2088 
2089     connect(d->model, SIGNAL(columnsAboutToBeRemoved(QModelIndex,int,int)),
2090             this, SLOT(_q_sourceColumnsAboutToBeRemoved(QModelIndex,int,int)));
2091 
2092     connect(d->model, SIGNAL(columnsRemoved(QModelIndex,int,int)),
2093             this, SLOT(_q_sourceColumnsRemoved(QModelIndex,int,int)));
2094 
2095     connect(d->model, SIGNAL(rowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
2096             this, SLOT(_q_sourceRowsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
2097 
2098     connect(d->model, SIGNAL(rowsMoved(QModelIndex,int,int,QModelIndex,int)),
2099             this, SLOT(_q_sourceRowsMoved(QModelIndex,int,int,QModelIndex,int)));
2100 
2101     connect(d->model, SIGNAL(columnsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)),
2102             this, SLOT(_q_sourceColumnsAboutToBeMoved(QModelIndex,int,int,QModelIndex,int)));
2103 
2104     connect(d->model, SIGNAL(columnsMoved(QModelIndex,int,int,QModelIndex,int)),
2105             this, SLOT(_q_sourceColumnsMoved(QModelIndex,int,int,QModelIndex,int)));
2106 
2107     connect(d->model, SIGNAL(layoutAboutToBeChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)),
2108             this, SLOT(_q_sourceLayoutAboutToBeChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)));
2109 
2110     connect(d->model, SIGNAL(layoutChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)),
2111             this, SLOT(_q_sourceLayoutChanged(QList<QPersistentModelIndex>,QAbstractItemModel::LayoutChangeHint)));
2112 
2113     connect(d->model, SIGNAL(modelAboutToBeReset()), this, SLOT(_q_sourceAboutToBeReset()));
2114     connect(d->model, SIGNAL(modelReset()), this, SLOT(_q_sourceReset()));
2115 
2116     endResetModel();
2117     if (d->update_source_sort_column() && d->dynamic_sortfilter)
2118         d->sort();
2119 }
2120 
2121 /*!
2122     \reimp
2123 */
2124 QModelIndex QSortFilterProxyModel::index(int row, int column, const QModelIndex &parent) const
2125 {
2126     Q_D(const QSortFilterProxyModel);
2127     if (row < 0 || column < 0)
2128         return QModelIndex();
2129 
2130     QModelIndex source_parent = mapToSource(parent); // parent is already mapped at this point
2131     IndexMap::const_iterator it = d->create_mapping(source_parent); // but make sure that the children are mapped
2132     if (it.value()->source_rows.count() <= row || it.value()->source_columns.count() <= column)
2133         return QModelIndex();
2134 
2135     return d->create_index(row, column, it);
2136 }
2137 
2138 /*!
2139   \reimp
2140 */
2141 QModelIndex QSortFilterProxyModel::parent(const QModelIndex &child) const
2142 {
2143     Q_D(const QSortFilterProxyModel);
2144     if (!d->indexValid(child))
2145         return QModelIndex();
2146     IndexMap::const_iterator it = d->index_to_iterator(child);
2147     Q_ASSERT(it != d->source_index_mapping.constEnd());
2148     QModelIndex source_parent = it.key();
2149     QModelIndex proxy_parent = mapFromSource(source_parent);
2150     return proxy_parent;
2151 }
2152 
2153 /*!
2154   \reimp
2155 */
2156 QModelIndex QSortFilterProxyModel::sibling(int row, int column, const QModelIndex &idx) const
2157 {
2158     Q_D(const QSortFilterProxyModel);
2159     if (!d->indexValid(idx))
2160         return QModelIndex();
2161 
2162     const IndexMap::const_iterator it = d->index_to_iterator(idx);
2163     if (it.value()->source_rows.count() <= row || it.value()->source_columns.count() <= column)
2164         return QModelIndex();
2165 
2166     return d->create_index(row, column, it);
2167 }
2168 
2169 /*!
2170   \reimp
2171 */
2172 int QSortFilterProxyModel::rowCount(const QModelIndex &parent) const
2173 {
2174     Q_D(const QSortFilterProxyModel);
2175     QModelIndex source_parent = mapToSource(parent);
2176     if (parent.isValid() && !source_parent.isValid())
2177         return 0;
2178     IndexMap::const_iterator it = d->create_mapping(source_parent);
2179     return it.value()->source_rows.count();
2180 }
2181 
2182 /*!
2183   \reimp
2184 */
2185 int QSortFilterProxyModel::columnCount(const QModelIndex &parent) const
2186 {
2187     Q_D(const QSortFilterProxyModel);
2188     QModelIndex source_parent = mapToSource(parent);
2189     if (parent.isValid() && !source_parent.isValid())
2190         return 0;
2191     IndexMap::const_iterator it = d->create_mapping(source_parent);
2192     return it.value()->source_columns.count();
2193 }
2194 
2195 /*!
2196   \reimp
2197 */
2198 bool QSortFilterProxyModel::hasChildren(const QModelIndex &parent) const
2199 {
2200     Q_D(const QSortFilterProxyModel);
2201     QModelIndex source_parent = mapToSource(parent);
2202     if (parent.isValid() && !source_parent.isValid())
2203         return false;
2204     if (!d->model->hasChildren(source_parent))
2205         return false;
2206 
2207     if (d->model->canFetchMore(source_parent))
2208         return true; //we assume we might have children that can be fetched
2209 
2210     QSortFilterProxyModelPrivate::Mapping *m = d->create_mapping(source_parent).value();
2211     return m->source_rows.count() != 0 && m->source_columns.count() != 0;
2212 }
2213 
2214 /*!
2215   \reimp
2216 */
2217 QVariant QSortFilterProxyModel::data(const QModelIndex &index, int role) const
2218 {
2219     Q_D(const QSortFilterProxyModel);
2220     QModelIndex source_index = mapToSource(index);
2221     if (index.isValid() && !source_index.isValid())
2222         return QVariant();
2223     return d->model->data(source_index, role);
2224 }
2225 
2226 /*!
2227   \reimp
2228 */
2229 bool QSortFilterProxyModel::setData(const QModelIndex &index, const QVariant &value, int role)
2230 {
2231     Q_D(QSortFilterProxyModel);
2232     QModelIndex source_index = mapToSource(index);
2233     if (index.isValid() && !source_index.isValid())
2234         return false;
2235     return d->model->setData(source_index, value, role);
2236 }
2237 
2238 /*!
2239   \reimp
2240 */
2241 QVariant QSortFilterProxyModel::headerData(int section, Qt::Orientation orientation, int role) const
2242 {
2243     Q_D(const QSortFilterProxyModel);
2244     IndexMap::const_iterator it = d->create_mapping(QModelIndex());
2245     if (it.value()->source_rows.count() * it.value()->source_columns.count() > 0)
2246         return QAbstractProxyModel::headerData(section, orientation, role);
2247     int source_section;
2248     if (orientation == Qt::Vertical) {
2249         if (section < 0 || section >= it.value()->source_rows.count())
2250             return QVariant();
2251         source_section = it.value()->source_rows.at(section);
2252     } else {
2253         if (section < 0 || section >= it.value()->source_columns.count())
2254             return QVariant();
2255         source_section = it.value()->source_columns.at(section);
2256     }
2257     return d->model->headerData(source_section, orientation, role);
2258 }
2259 
2260 /*!
2261   \reimp
2262 */
2263 bool QSortFilterProxyModel::setHeaderData(int section, Qt::Orientation orientation,
2264                                           const QVariant &value, int role)
2265 {
2266     Q_D(QSortFilterProxyModel);
2267     IndexMap::const_iterator it = d->create_mapping(QModelIndex());
2268     if (it.value()->source_rows.count() * it.value()->source_columns.count() > 0)
2269         return QAbstractProxyModel::setHeaderData(section, orientation, value, role);
2270     int source_section;
2271     if (orientation == Qt::Vertical) {
2272         if (section < 0 || section >= it.value()->source_rows.count())
2273             return false;
2274         source_section = it.value()->source_rows.at(section);
2275     } else {
2276         if (section < 0 || section >= it.value()->source_columns.count())
2277             return false;
2278         source_section = it.value()->source_columns.at(section);
2279     }
2280     return d->model->setHeaderData(source_section, orientation, value, role);
2281 }
2282 
2283 /*!
2284   \reimp
2285 */
2286 QMimeData *QSortFilterProxyModel::mimeData(const QModelIndexList &indexes) const
2287 {
2288     Q_D(const QSortFilterProxyModel);
2289     QModelIndexList source_indexes;
2290     const int numIndexes = indexes.count();
2291     source_indexes.reserve(numIndexes);
2292     for (int i = 0; i < numIndexes; ++i)
2293         source_indexes << mapToSource(indexes.at(i));
2294     return d->model->mimeData(source_indexes);
2295 }
2296 
2297 /*!
2298   \reimp
2299 */
2300 QStringList QSortFilterProxyModel::mimeTypes() const
2301 {
2302     Q_D(const QSortFilterProxyModel);
2303     return d->model->mimeTypes();
2304 }
2305 
2306 /*!
2307   \reimp
2308 */
2309 Qt::DropActions QSortFilterProxyModel::supportedDropActions() const
2310 {
2311     Q_D(const QSortFilterProxyModel);
2312     return d->model->supportedDropActions();
2313 }
2314 
2315 // Qt6: remove unnecessary reimplementation
2316 /*!
2317   \reimp
2318 */
2319 bool QSortFilterProxyModel::dropMimeData(const QMimeData *data, Qt::DropAction action,
2320                                          int row, int column, const QModelIndex &parent)
2321 {
2322     return QAbstractProxyModel::dropMimeData(data, action, row, column, parent);
2323 }
2324 
2325 /*!
2326   \reimp
2327 */
2328 bool QSortFilterProxyModel::insertRows(int row, int count, const QModelIndex &parent)
2329 {
2330     Q_D(QSortFilterProxyModel);
2331     if (row < 0 || count <= 0)
2332         return false;
2333     QModelIndex source_parent = mapToSource(parent);
2334     if (parent.isValid() && !source_parent.isValid())
2335         return false;
2336     QSortFilterProxyModelPrivate::Mapping *m = d->create_mapping(source_parent).value();
2337     if (row > m->source_rows.count())
2338         return false;
2339     int source_row = (row >= m->source_rows.count()
2340                       ? m->source_rows.count()
2341                       : m->source_rows.at(row));
2342     return d->model->insertRows(source_row, count, source_parent);
2343 }
2344 
2345 /*!
2346   \reimp
2347 */
2348 bool QSortFilterProxyModel::insertColumns(int column, int count, const QModelIndex &parent)
2349 {
2350     Q_D(QSortFilterProxyModel);
2351     if (column < 0|| count <= 0)
2352         return false;
2353     QModelIndex source_parent = mapToSource(parent);
2354     if (parent.isValid() && !source_parent.isValid())
2355         return false;
2356     QSortFilterProxyModelPrivate::Mapping *m = d->create_mapping(source_parent).value();
2357     if (column > m->source_columns.count())
2358         return false;
2359     int source_column = (column >= m->source_columns.count()
2360                          ? m->source_columns.count()
2361                          : m->source_columns.at(column));
2362     return d->model->insertColumns(source_column, count, source_parent);
2363 }
2364 
2365 /*!
2366   \reimp
2367 */
2368 bool QSortFilterProxyModel::removeRows(int row, int count, const QModelIndex &parent)
2369 {
2370     Q_D(QSortFilterProxyModel);
2371     if (row < 0 || count <= 0)
2372         return false;
2373     QModelIndex source_parent = mapToSource(parent);
2374     if (parent.isValid() && !source_parent.isValid())
2375         return false;
2376     QSortFilterProxyModelPrivate::Mapping *m = d->create_mapping(source_parent).value();
2377     if (row + count > m->source_rows.count())
2378         return false;
2379     if ((count == 1)
2380         || ((d->source_sort_column < 0) && (m->proxy_rows.count() == m->source_rows.count()))) {
2381         int source_row = m->source_rows.at(row);
2382         return d->model->removeRows(source_row, count, source_parent);
2383     }
2384     // remove corresponding source intervals
2385     // ### if this proves to be slow, we can switch to single-row removal
2386     QVector<int> rows;
2387     rows.reserve(count);
2388     for (int i = row; i < row + count; ++i)
2389         rows.append(m->source_rows.at(i));
2390     std::sort(rows.begin(), rows.end());
2391 
2392     int pos = rows.count() - 1;
2393     bool ok = true;
2394     while (pos >= 0) {
2395         const int source_end = rows.at(pos--);
2396         int source_start = source_end;
2397         while ((pos >= 0) && (rows.at(pos) == (source_start - 1))) {
2398             --source_start;
2399             --pos;
2400         }
2401         ok = ok && d->model->removeRows(source_start, source_end - source_start + 1,
2402                                         source_parent);
2403     }
2404     return ok;
2405 }
2406 
2407 /*!
2408   \reimp
2409 */
2410 bool QSortFilterProxyModel::removeColumns(int column, int count, const QModelIndex &parent)
2411 {
2412     Q_D(QSortFilterProxyModel);
2413     if (column < 0 || count <= 0)
2414         return false;
2415     QModelIndex source_parent = mapToSource(parent);
2416     if (parent.isValid() && !source_parent.isValid())
2417         return false;
2418     QSortFilterProxyModelPrivate::Mapping *m = d->create_mapping(source_parent).value();
2419     if (column + count > m->source_columns.count())
2420         return false;
2421     if ((count == 1) || (m->proxy_columns.count() == m->source_columns.count())) {
2422         int source_column = m->source_columns.at(column);
2423         return d->model->removeColumns(source_column, count, source_parent);
2424     }
2425     // remove corresponding source intervals
2426     QVector<int> columns;
2427     columns.reserve(count);
2428     for (int i = column; i < column + count; ++i)
2429         columns.append(m->source_columns.at(i));
2430 
2431     int pos = columns.count() - 1;
2432     bool ok = true;
2433     while (pos >= 0) {
2434         const int source_end = columns.at(pos--);
2435         int source_start = source_end;
2436         while ((pos >= 0) && (columns.at(pos) == (source_start - 1))) {
2437             --source_start;
2438             --pos;
2439         }
2440         ok = ok && d->model->removeColumns(source_start, source_end - source_start + 1,
2441                                            source_parent);
2442     }
2443     return ok;
2444 }
2445 
2446 /*!
2447   \reimp
2448 */
2449 void QSortFilterProxyModel::fetchMore(const QModelIndex &parent)
2450 {
2451     Q_D(QSortFilterProxyModel);
2452     QModelIndex source_parent;
2453     if (d->indexValid(parent))
2454         source_parent = mapToSource(parent);
2455     d->model->fetchMore(source_parent);
2456 }
2457 
2458 /*!
2459   \reimp
2460 */
2461 bool QSortFilterProxyModel::canFetchMore(const QModelIndex &parent) const
2462 {
2463     Q_D(const QSortFilterProxyModel);
2464     QModelIndex source_parent;
2465     if (d->indexValid(parent))
2466         source_parent = mapToSource(parent);
2467     return d->model->canFetchMore(source_parent);
2468 }
2469 
2470 /*!
2471   \reimp
2472 */
2473 Qt::ItemFlags QSortFilterProxyModel::flags(const QModelIndex &index) const
2474 {
2475     Q_D(const QSortFilterProxyModel);
2476     QModelIndex source_index;
2477     if (d->indexValid(index))
2478         source_index = mapToSource(index);
2479     return d->model->flags(source_index);
2480 }
2481 
2482 /*!
2483   \reimp
2484 */
2485 QModelIndex QSortFilterProxyModel::buddy(const QModelIndex &index) const
2486 {
2487     Q_D(const QSortFilterProxyModel);
2488     if (!d->indexValid(index))
2489         return QModelIndex();
2490     QModelIndex source_index = mapToSource(index);
2491     QModelIndex source_buddy = d->model->buddy(source_index);
2492     if (source_index == source_buddy)
2493         return index;
2494     return mapFromSource(source_buddy);
2495 }
2496 
2497 /*!
2498   \reimp
2499 */
2500 QModelIndexList QSortFilterProxyModel::match(const QModelIndex &start, int role,
2501                                              const QVariant &value, int hits,
2502                                              Qt::MatchFlags flags) const
2503 {
2504     return QAbstractProxyModel::match(start, role, value, hits, flags);
2505 }
2506 
2507 /*!
2508   \reimp
2509 */
2510 QSize QSortFilterProxyModel::span(const QModelIndex &index) const
2511 {
2512     Q_D(const QSortFilterProxyModel);
2513     QModelIndex source_index = mapToSource(index);
2514     if (index.isValid() && !source_index.isValid())
2515         return QSize();
2516     return d->model->span(source_index);
2517 }
2518 
2519 /*!
2520   \reimp
2521 */
2522 void QSortFilterProxyModel::sort(int column, Qt::SortOrder order)
2523 {
2524     Q_D(QSortFilterProxyModel);
2525     if (d->dynamic_sortfilter && d->proxy_sort_column == column && d->sort_order == order)
2526         return;
2527     d->sort_order = order;
2528     d->proxy_sort_column = column;
2529     d->update_source_sort_column();
2530     d->sort();
2531 }
2532 
2533 /*!
2534     \since 4.5
2535     \brief the column currently used for sorting
2536 
2537     This returns the most recently used sort column.
2538 */
2539 int QSortFilterProxyModel::sortColumn() const
2540 {
2541     Q_D(const QSortFilterProxyModel);
2542     return d->proxy_sort_column;
2543 }
2544 
2545 /*!
2546     \since 4.5
2547     \brief the order currently used for sorting
2548 
2549     This returns the most recently used sort order.
2550 */
2551 Qt::SortOrder QSortFilterProxyModel::sortOrder() const
2552 {
2553     Q_D(const QSortFilterProxyModel);
2554     return d->sort_order;
2555 }
2556 
2557 /*!
2558     \property QSortFilterProxyModel::filterRegExp
2559     \brief the QRegExp used to filter the contents of the source model
2560 
2561     Setting this property overwrites the current
2562     \l{QSortFilterProxyModel::filterCaseSensitivity}{filterCaseSensitivity}.
2563     By default, the QRegExp is an empty string matching all contents.
2564 
2565     If no QRegExp or an empty string is set, everything in the source model
2566     will be accepted.
2567 
2568     \sa filterCaseSensitivity, setFilterWildcard(), setFilterFixedString()
2569 */
2570 QRegExp QSortFilterProxyModel::filterRegExp() const
2571 {
2572     Q_D(const QSortFilterProxyModel);
2573     return d->filter_data.regExp();
2574 }
2575 
2576 void QSortFilterProxyModel::setFilterRegExp(const QRegExp &regExp)
2577 {
2578     Q_D(QSortFilterProxyModel);
2579     d->filter_about_to_be_changed();
2580     d->filter_data.setRegExp(regExp);
2581     d->filter_changed();
2582 }
2583 
2584 #if QT_CONFIG(regularexpression)
2585 /*!
2586     \since 5.12
2587     \property QSortFilterProxyModel::filterRegularExpression
2588     \brief the QRegularExpression used to filter the contents of the source model
2589 
2590     Setting this property overwrites the current
2591     \l{QSortFilterProxyModel::filterCaseSensitivity}{filterCaseSensitivity}.
2592     By default, the QRegularExpression is an empty string matching all contents.
2593 
2594     If no QRegularExpression or an empty string is set, everything in the source
2595     model will be accepted.
2596 
2597     \sa filterCaseSensitivity, setFilterWildcard(), setFilterFixedString()
2598 */
2599 QRegularExpression QSortFilterProxyModel::filterRegularExpression() const
2600 {
2601     Q_D(const QSortFilterProxyModel);
2602     return d->filter_data.regularExpression();
2603 }
2604 
2605 void QSortFilterProxyModel::setFilterRegularExpression(const QRegularExpression &regularExpression)
2606 {
2607     Q_D(QSortFilterProxyModel);
2608     d->filter_about_to_be_changed();
2609     d->filter_data.setRegularExpression(regularExpression);
2610     d->filter_changed();
2611 }
2612 #endif
2613 
2614 /*!
2615     \property QSortFilterProxyModel::filterKeyColumn
2616     \brief the column where the key used to filter the contents of the
2617     source model is read from.
2618 
2619     The default value is 0. If the value is -1, the keys will be read
2620     from all columns.
2621 */
2622 int QSortFilterProxyModel::filterKeyColumn() const
2623 {
2624     Q_D(const QSortFilterProxyModel);
2625     return d->filter_column;
2626 }
2627 
2628 void QSortFilterProxyModel::setFilterKeyColumn(int column)
2629 {
2630     Q_D(QSortFilterProxyModel);
2631     d->filter_about_to_be_changed();
2632     d->filter_column = column;
2633     d->filter_changed();
2634 }
2635 
2636 /*!
2637     \property QSortFilterProxyModel::filterCaseSensitivity
2638 
2639     \brief the case sensitivity of the QRegExp pattern used to filter the
2640     contents of the source model
2641 
2642     By default, the filter is case sensitive.
2643 
2644     \sa filterRegExp, sortCaseSensitivity
2645 */
2646 Qt::CaseSensitivity QSortFilterProxyModel::filterCaseSensitivity() const
2647 {
2648     Q_D(const QSortFilterProxyModel);
2649     return d->filter_data.caseSensitivity();
2650 }
2651 
2652 void QSortFilterProxyModel::setFilterCaseSensitivity(Qt::CaseSensitivity cs)
2653 {
2654     Q_D(QSortFilterProxyModel);
2655     if (cs == d->filter_data.caseSensitivity())
2656         return;
2657     d->filter_about_to_be_changed();
2658     d->filter_data.setCaseSensitivity(cs);
2659     d->filter_changed();
2660 }
2661 
2662 /*!
2663     \since 4.2
2664     \property QSortFilterProxyModel::sortCaseSensitivity
2665     \brief the case sensitivity setting used for comparing strings when sorting
2666 
2667     By default, sorting is case sensitive.
2668 
2669     \sa filterCaseSensitivity, lessThan()
2670 */
2671 Qt::CaseSensitivity QSortFilterProxyModel::sortCaseSensitivity() const
2672 {
2673     Q_D(const QSortFilterProxyModel);
2674     return d->sort_casesensitivity;
2675 }
2676 
2677 void QSortFilterProxyModel::setSortCaseSensitivity(Qt::CaseSensitivity cs)
2678 {
2679     Q_D(QSortFilterProxyModel);
2680     if (d->sort_casesensitivity == cs)
2681         return;
2682 
2683     d->sort_casesensitivity = cs;
2684     d->sort();
2685 }
2686 
2687 /*!
2688     \since 4.3
2689     \property QSortFilterProxyModel::isSortLocaleAware
2690     \brief the local aware setting used for comparing strings when sorting
2691 
2692     By default, sorting is not local aware.
2693 
2694     \sa sortCaseSensitivity, lessThan()
2695 */
2696 bool QSortFilterProxyModel::isSortLocaleAware() const
2697 {
2698     Q_D(const QSortFilterProxyModel);
2699     return d->sort_localeaware;
2700 }
2701 
2702 void QSortFilterProxyModel::setSortLocaleAware(bool on)
2703 {
2704     Q_D(QSortFilterProxyModel);
2705     if (d->sort_localeaware == on)
2706         return;
2707 
2708     d->sort_localeaware = on;
2709     d->sort();
2710 }
2711 
2712 /*!
2713     \overload
2714 
2715     Sets the regular expression used to filter the contents
2716     of the source model to \a pattern.
2717 
2718     \sa setFilterCaseSensitivity(), setFilterWildcard(), setFilterFixedString(), filterRegExp()
2719 */
2720 void QSortFilterProxyModel::setFilterRegExp(const QString &pattern)
2721 {
2722     Q_D(QSortFilterProxyModel);
2723     d->filter_about_to_be_changed();
2724     QRegExp rx(pattern);
2725     d->filter_data.setRegExp(rx);
2726     d->filter_changed();
2727 }
2728 
2729 #if QT_CONFIG(regularexpression)
2730 /*!
2731     \since 5.12
2732 
2733     Sets the regular expression used to filter the contents
2734     of the source model to \a pattern.
2735 
2736     \sa setFilterCaseSensitivity(), setFilterWildcard(), setFilterFixedString(), filterRegularExpression()
2737 */
2738 void QSortFilterProxyModel::setFilterRegularExpression(const QString &pattern)
2739 {
2740     Q_D(QSortFilterProxyModel);
2741     d->filter_about_to_be_changed();
2742     QRegularExpression rx(pattern);
2743     d->filter_data.setRegularExpression(rx);
2744     d->filter_changed();
2745 }
2746 #endif
2747 
2748 /*!
2749     Sets the wildcard expression used to filter the contents
2750     of the source model to the given \a pattern.
2751 
2752     \sa setFilterCaseSensitivity(), setFilterRegExp(), setFilterFixedString(), filterRegExp()
2753 */
2754 void QSortFilterProxyModel::setFilterWildcard(const QString &pattern)
2755 {
2756     Q_D(QSortFilterProxyModel);
2757     d->filter_about_to_be_changed();
2758     QRegExp rx(pattern, d->filter_data.caseSensitivity(), QRegExp::Wildcard);
2759     d->filter_data.setRegExp(rx);
2760     d->filter_changed();
2761 }
2762 
2763 /*!
2764     Sets the fixed string used to filter the contents
2765     of the source model to the given \a pattern.
2766 
2767     \sa setFilterCaseSensitivity(), setFilterRegExp(), setFilterWildcard(), filterRegExp()
2768 */
2769 void QSortFilterProxyModel::setFilterFixedString(const QString &pattern)
2770 {
2771     Q_D(QSortFilterProxyModel);
2772     d->filter_about_to_be_changed();
2773     QRegExp rx(pattern, d->filter_data.caseSensitivity(), QRegExp::FixedString);
2774     d->filter_data.setRegExp(rx);
2775     d->filter_changed();
2776 }
2777 
2778 /*!
2779     \since 4.2
2780     \property QSortFilterProxyModel::dynamicSortFilter
2781     \brief whether the proxy model is dynamically sorted and filtered
2782     whenever the contents of the source model change
2783 
2784     Note that you should not update the source model through the proxy
2785     model when dynamicSortFilter is true. For instance, if you set the
2786     proxy model on a QComboBox, then using functions that update the
2787     model, e.g., \l{QComboBox::}{addItem()}, will not work as
2788     expected. An alternative is to set dynamicSortFilter to false and
2789     call \l{QSortFilterProxyModel::}{sort()} after adding items to the
2790     QComboBox.
2791 
2792     The default value is true.
2793 */
2794 bool QSortFilterProxyModel::dynamicSortFilter() const
2795 {
2796     Q_D(const QSortFilterProxyModel);
2797     return d->dynamic_sortfilter;
2798 }
2799 
2800 void QSortFilterProxyModel::setDynamicSortFilter(bool enable)
2801 {
2802     Q_D(QSortFilterProxyModel);
2803     d->dynamic_sortfilter = enable;
2804     if (enable)
2805         d->sort();
2806 }
2807 
2808 /*!
2809     \since 4.2
2810     \property QSortFilterProxyModel::sortRole
2811     \brief the item role that is used to query the source model's data when sorting items
2812 
2813     The default value is Qt::DisplayRole.
2814 
2815     \sa lessThan()
2816 */
2817 int QSortFilterProxyModel::sortRole() const
2818 {
2819     Q_D(const QSortFilterProxyModel);
2820     return d->sort_role;
2821 }
2822 
2823 void QSortFilterProxyModel::setSortRole(int role)
2824 {
2825     Q_D(QSortFilterProxyModel);
2826     if (d->sort_role == role)
2827         return;
2828     d->sort_role = role;
2829     d->sort();
2830 }
2831 
2832 /*!
2833     \since 4.2
2834     \property QSortFilterProxyModel::filterRole
2835     \brief the item role that is used to query the source model's data when filtering items
2836 
2837     The default value is Qt::DisplayRole.
2838 
2839     \sa filterAcceptsRow()
2840 */
2841 int QSortFilterProxyModel::filterRole() const
2842 {
2843     Q_D(const QSortFilterProxyModel);
2844     return d->filter_role;
2845 }
2846 
2847 void QSortFilterProxyModel::setFilterRole(int role)
2848 {
2849     Q_D(QSortFilterProxyModel);
2850     if (d->filter_role == role)
2851         return;
2852     d->filter_about_to_be_changed();
2853     d->filter_role = role;
2854     d->filter_changed();
2855 }
2856 
2857 /*!
2858     \since 5.10
2859     \property QSortFilterProxyModel::recursiveFilteringEnabled
2860     \brief whether the filter to be applied recursively on children, and for
2861     any matching child, its parents will be visible as well.
2862 
2863     The default value is false.
2864 
2865     \sa filterAcceptsRow()
2866 */
2867 bool QSortFilterProxyModel::isRecursiveFilteringEnabled() const
2868 {
2869     Q_D(const QSortFilterProxyModel);
2870     return d->filter_recursive;
2871 }
2872 
2873 void QSortFilterProxyModel::setRecursiveFilteringEnabled(bool recursive)
2874 {
2875     Q_D(QSortFilterProxyModel);
2876     if (d->filter_recursive == recursive)
2877         return;
2878     d->filter_about_to_be_changed();
2879     d->filter_recursive = recursive;
2880     d->filter_changed();
2881 }
2882 
2883 #if QT_DEPRECATED_SINCE(5, 11)
2884 /*!
2885     \obsolete
2886 
2887     This function is obsolete. Use invalidate() instead.
2888 */
2889 void QSortFilterProxyModel::clear()
2890 {
2891     invalidate();
2892 }
2893 #endif
2894 /*!
2895    \since 4.3
2896 
2897     Invalidates the current sorting and filtering.
2898 
2899     \sa invalidateFilter()
2900 */
2901 void QSortFilterProxyModel::invalidate()
2902 {
2903     Q_D(QSortFilterProxyModel);
2904     emit layoutAboutToBeChanged();
2905     d->_q_clearMapping();
2906     emit layoutChanged();
2907 }
2908 
2909 #if QT_DEPRECATED_SINCE(5, 11)
2910 /*!
2911    \obsolete
2912 
2913     This function is obsolete. Use invalidateFilter() instead.
2914 */
2915 void QSortFilterProxyModel::filterChanged()
2916 {
2917     invalidateFilter();
2918 }
2919 #endif
2920 
2921 /*!
2922    \since 4.3
2923 
2924    Invalidates the current filtering.
2925 
2926    This function should be called if you are implementing custom filtering
2927    (e.g. filterAcceptsRow()), and your filter parameters have changed.
2928 
2929    \sa invalidate()
2930 */
2931 void QSortFilterProxyModel::invalidateFilter()
2932 {
2933     Q_D(QSortFilterProxyModel);
2934     d->filter_changed();
2935 }
2936 
2937 /*!
2938     Returns \c true if the value of the item referred to by the given
2939     index \a source_left is less than the value of the item referred to by
2940     the given index \a source_right, otherwise returns \c false.
2941 
2942     This function is used as the < operator when sorting, and handles
2943     the following QVariant types:
2944 
2945     \list
2946     \li QMetaType::Int
2947     \li QMetaType::UInt
2948     \li QMetaType::LongLong
2949     \li QMetaType::ULongLong
2950     \li QMetaType::Float
2951     \li QMetaType::Double
2952     \li QMetaType::QChar
2953     \li QMetaType::QDate
2954     \li QMetaType::QTime
2955     \li QMetaType::QDateTime
2956     \li QMetaType::QString
2957     \endlist
2958 
2959     Any other type will be converted to a QString using
2960     QVariant::toString().
2961 
2962     Comparison of \l{QString}s is case sensitive by default; this can
2963     be changed using the \l {QSortFilterProxyModel::sortCaseSensitivity}
2964     {sortCaseSensitivity} property.
2965 
2966     By default, the Qt::DisplayRole associated with the
2967     \l{QModelIndex}es is used for comparisons. This can be changed by
2968     setting the \l {QSortFilterProxyModel::sortRole} {sortRole} property.
2969 
2970     \note The indices passed in correspond to the source model.
2971 
2972     \sa sortRole, sortCaseSensitivity, dynamicSortFilter
2973 */
2974 bool QSortFilterProxyModel::lessThan(const QModelIndex &source_left, const QModelIndex &source_right) const
2975 {
2976     Q_D(const QSortFilterProxyModel);
2977     QVariant l = (source_left.model() ? source_left.model()->data(source_left, d->sort_role) : QVariant());
2978     QVariant r = (source_right.model() ? source_right.model()->data(source_right, d->sort_role) : QVariant());
2979     return QAbstractItemModelPrivate::isVariantLessThan(l, r, d->sort_casesensitivity, d->sort_localeaware);
2980 }
2981 
2982 /*!
2983     Returns \c true if the item in the row indicated by the given \a source_row
2984     and \a source_parent should be included in the model; otherwise returns
2985     false.
2986 
2987     The default implementation returns \c true if the value held by the relevant item
2988     matches the filter string, wildcard string or regular expression.
2989 
2990     \note By default, the Qt::DisplayRole is used to determine if the row
2991     should be accepted or not. This can be changed by setting the
2992     \l{QSortFilterProxyModel::filterRole}{filterRole} property.
2993 
2994     \sa filterAcceptsColumn(), setFilterFixedString(), setFilterRegExp(), setFilterWildcard()
2995 */
2996 bool QSortFilterProxyModel::filterAcceptsRow(int source_row, const QModelIndex &source_parent) const
2997 {
2998     Q_D(const QSortFilterProxyModel);
2999 
3000     if (d->filter_data.isEmpty())
3001         return true;
3002     if (d->filter_column == -1) {
3003         int column_count = d->model->columnCount(source_parent);
3004         for (int column = 0; column < column_count; ++column) {
3005             QModelIndex source_index = d->model->index(source_row, column, source_parent);
3006             QString key = d->model->data(source_index, d->filter_role).toString();
3007             if (d->filter_data.isRxInString(key))
3008                 return true;
3009         }
3010         return false;
3011     }
3012     QModelIndex source_index = d->model->index(source_row, d->filter_column, source_parent);
3013     if (!source_index.isValid()) // the column may not exist
3014         return true;
3015     QString key = d->model->data(source_index, d->filter_role).toString();
3016     return d->filter_data.isRxInString(key);
3017 }
3018 
3019 /*!
3020     Returns \c true if the item in the column indicated by the given \a source_column
3021     and \a source_parent should be included in the model; otherwise returns \c false.
3022 
3023     The default implementation returns \c true if the value held by the relevant item
3024     matches the filter string, wildcard string or regular expression.
3025 
3026     \note By default, the Qt::DisplayRole is used to determine if the column
3027     should be accepted or not. This can be changed by setting the \l
3028     filterRole property.
3029 
3030     \sa filterAcceptsRow(), setFilterFixedString(), setFilterRegExp(), setFilterWildcard()
3031 */
3032 bool QSortFilterProxyModel::filterAcceptsColumn(int source_column, const QModelIndex &source_parent) const
3033 {
3034     Q_UNUSED(source_column);
3035     Q_UNUSED(source_parent);
3036     return true;
3037 }
3038 
3039 /*!
3040    Returns the source model index corresponding to the given \a
3041    proxyIndex from the sorting filter model.
3042 
3043    \sa mapFromSource()
3044 */
3045 QModelIndex QSortFilterProxyModel::mapToSource(const QModelIndex &proxyIndex) const
3046 {
3047     Q_D(const QSortFilterProxyModel);
3048     return d->proxy_to_source(proxyIndex);
3049 }
3050 
3051 /*!
3052     Returns the model index in the QSortFilterProxyModel given the \a
3053     sourceIndex from the source model.
3054 
3055     \sa mapToSource()
3056 */
3057 QModelIndex QSortFilterProxyModel::mapFromSource(const QModelIndex &sourceIndex) const
3058 {
3059     Q_D(const QSortFilterProxyModel);
3060     return d->source_to_proxy(sourceIndex);
3061 }
3062 
3063 /*!
3064   \reimp
3065 */
3066 QItemSelection QSortFilterProxyModel::mapSelectionToSource(const QItemSelection &proxySelection) const
3067 {
3068     return QAbstractProxyModel::mapSelectionToSource(proxySelection);
3069 }
3070 
3071 /*!
3072   \reimp
3073 */
3074 QItemSelection QSortFilterProxyModel::mapSelectionFromSource(const QItemSelection &sourceSelection) const
3075 {
3076     return QAbstractProxyModel::mapSelectionFromSource(sourceSelection);
3077 }
3078 
3079 QT_END_NAMESPACE
3080 
3081 #include "moc_qsortfilterproxymodel.cpp"
