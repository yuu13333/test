Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
QCborValue: avoid allocating result if data is insufficient

Similar to the previous commit which applied to QCborStreamReader, don't
allocate too much data before checking that the stream actually has that
much.

Pick-to: 5.15
Fixes: QTBUG-88256
Change-Id: I7b9b97ae9b32412abdc6fffd16454b7568a063ba

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 Intel Corporation.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qcborvalue.h"
41 #include "qcborvalue_p.h"
42 #include "qdatastream.h"
43 #include "qcborarray.h"
44 #include "qcbormap.h"
45 
46 #if QT_CONFIG(cborstreamreader)
47 #include "qcborstreamreader.h"
48 #endif
49 
50 #if QT_CONFIG(cborstreamwriter)
51 #include "qcborstreamwriter.h"
52 #endif
53 
54 #include <qendian.h>
55 #include <qlocale.h>
56 #include <private/qbytearray_p.h>
57 #include <private/qnumeric_p.h>
58 #include <private/qsimd_p.h>
59 
60 #include <new>
61 
62 QT_BEGIN_NAMESPACE
63 
64 /*!
65     \class QCborValue
66     \inmodule QtCore
67     \ingroup cbor
68     \reentrant
69     \since 5.12
70 
71     \brief The QCborValue class encapsulates a value in CBOR.
72 
73     This class can be used to hold one of the many types available in CBOR.
74     CBOR is the Concise Binary Object Representation, a very compact form of
75     binary data encoding that is a superset of JSON. It was created by the IETF
76     Constrained RESTful Environments (CoRE) WG, which has used it in many
77     new RFCs. It is meant to be used alongside the
78     \l{https://tools.ietf.org/html/rfc7252}{CoAP protocol}.
79 
80     CBOR has three groups of built-in types:
81 
82     \list
83       \li Basic types: integers, floating point (double), boolean, null, etc.
84       \li String-like types: strings and byte arrays
85       \li Containers: arrays and maps
86     \endlist
87 
88     Additionally, CBOR supports a form of type extensibility by associating a
89     "tag" to one of the above types to convey more information. For example, a
90     UUID is represented by a tag and a byte array containing the 16 bytes of
91     the UUID content. QCborValue supports creating and decoding several of those
92     extended types directly with Qt classes (like QUuid).
93 
94     For the complete list, see \l QCborValue::Type. The type of a QCborValue can
95     be queried using type() or one of the "isXxxx" functions.
96 
97     \section1 Extended types and tagged values
98 
99     A tagged value is a normal QCborValue that is paired with a number that
100     is its tag. See \l QCborKnownTags for more information on what tags are in
101     the API as well as the full, official list. Such combinations form extended
102     types.
103 
104     QCborValue has support for certain extended types in the API, like URL
105     (with \l QUrl) and UUID (with \l QUuid). Other extended types not supported
106     in the API are represented by a QCborValue of \l {Type}{Tag} type. The tag
107     can later be retrieved by tag() and the tagged value using taggedValue().
108 
109     In order to support future compatibility, QCborValues containing extended
110     Qt types compare equal to the tag type of the same contents. In other
111     words, the following expression is true:
112 
113     \snippet code/src_corelib_serialization_qcborvalue.cpp 0
114 
115     \section1 Undefined and null values
116 
117     QCborValue can contain a value of "null", which is not of any specific type.
118     It resembles the C++ \c {std::nullptr_t} type, whose only possible value is
119     \nullptr. QCborValue has a constructor taking such a type and creates a
120     null QCborValue.
121 
122     Null values are used to indicate that an optional value is not present. In
123     that aspect, it is similar to the C++ Standard Library type \c
124     {std::optional} when that is disengaged. Unlike the C++ type, CBOR nulls
125     are simply of type "Null" and it is not possible to determine what concrete
126     type it is replacing.
127 
128     QCborValue can also be of the undefined type, which represents a value of
129     "undefined". In fact, that is what the QCborValue default constructor
130     creates.
131 
132     Undefined values are different from null values. While nulls are used to
133     indicate an optional value that is not provided, Undefined is usually
134     used to indicate that an expected value could not be provided, usually due
135     to an error or a precondition that could not be satisfied.
136 
137     Such values are completely valid and may appear in CBOR streams, unlike
138     JSON content and QJsonValue's undefined bit. But like QJsonValue's
139     Undefined, it is returned by a CBOR container's value() or read-only
140     operator[] for invalid look-ups (index out of range for QCborArray, or key
141     not found for QCborMap). It is not possible to tell such a case apart from
142     the value of Undefined, so if that is required, check the QCborArray size
143     and use the QCborMap iterator API.
144 
145     \section1 Simple types
146 
147     CBOR supports additional simple types that, like Null and Undefined, carry
148     no other value. They are called interchangeably "Simple Types" and "Simple
149     Values". CBOR encodes booleans as two distinct types (one for \c true and
150     one for \c false), but QCborValue has a convenience API for them.
151 
152     There are currently no other defined CBOR simple types. QCborValue supports
153     them simply by their number with API like isSimpleType() and
154     toSimpleType(), available for compatibility with future specifications
155     before the Qt API can be updated. Their use before such a specification is
156     discouraged, as other CBOR implementations may not support them fully.
157 
158     \section1 CBOR support
159 
160     QCborValue supports all CBOR features required to create canonical and
161     strict streams. It implements almost all of the features specified in \l
162     {https://tools.ietf.org/html/rfc7049}{RFC 7049}.
163 
164     The following table lists the CBOR features that QCborValue supports.
165 
166     \table
167       \header \li Feature                        \li Support
168       \row   \li Unsigned numbers                \li Yes (\l qint64 range)
169       \row   \li Negative numbers                \li Yes (\l qint64 range)
170       \row   \li Byte strings                    \li Yes
171       \row   \li Text strings                    \li Yes
172       \row   \li Chunked strings                 \li See below
173       \row   \li Tags                            \li Yes (arbitrary)
174       \row   \li Booleans                        \li Yes
175       \row   \li Null                            \li Yes
176       \row   \li Undefined                       \li Yes
177       \row   \li Arbitrary simple values         \li Yes
178       \row   \li Half-precision float (16-bit)   \li Yes
179       \row   \li Single-precision float (32-bit) \li Yes
180       \row   \li Double-precision float (64-bit) \li Yes
181       \row   \li Infinities and NaN floating point \li Yes
182       \row   \li Determinate-length arrays and maps \li Yes
183       \row   \li Indeterminate-length arrays and maps \li Yes
184       \row   \li Map key types other than strings and integers \li Yes (arbitrary)
185     \endtable
186 
187     Integers in QCborValue are limited to the range of the \l qint64 type. That
188     is, from -9,223,372,036,854,775,808 (-2\sup{63}) to
189     9,223,372,036,854,775,807 (2\sup{63} - 1). CBOR itself can represent integer
190     values outside of this range, which QCborValue does not support. When
191     decoding a stream using fromCbor() containing one of those values,
192     QCborValue will convert automatically to \l {Type}{Double}, but that may
193     lose up to 11 bits of precision.
194 
195     fromCbor() is able to decode chunked strings, but will always merge the
196     chunks together into a single QCborValue. For that reason, it always writes
197     non-chunked strings when using toCbor() (which is required by the Canonical
198     format anyway).
199 
200     QCborValue will always convert half- and single-precision floating point
201     values in the CBOR stream to double-precision. The toCbor() function can
202     take a parameter indicating to recreate them.
203 
204     \section1 QCborValueRef
205 
206     QCborValueRef is a helper class for QCborArray and QCborMap. It is the type
207     you get when using one of the mutating APIs in those classes. Unlike
208     QCborValue, new values can be assigned to that class. When that is done, the
209     array or map it refers to will be modified with the new value. In all other
210     aspects, its API is identical to QCborValue.
211 
212     \sa QCborArray, QCborMap, QCborStreamReader, QCborStreamWriter
213         QJsonValue, QJsonDocument
214  */
215 
216 /*!
217     \class QCborParserError
218     \inmodule QtCore
219     \ingroup cbor
220     \reentrant
221     \since 5.12
222 
223     \brief The QCborParserError is used by QCborValue to report a parsing error.
224 
225     This class is used by \l {QCborValue::fromCbor(const QByteArray &ba,
226     QCborParserError *error)} to report a parser error and the byte offset
227     where the error was detected.
228 
229     \sa QCborValue, QCborError
230  */
231 
232 /*!
233     \variable QCborParserError::offset
234 
235     This field contains the offset from the beginning of the data where the
236     error was detected. The offset should point to the beginning of the item
237     that contained the error, even if the error itself was elsewhere (for
238     example, for UTF-8 decoding issues).
239 
240     \sa QCborValue::fromCbor()
241  */
242 
243 /*!
244     \variable QCborParserError::error
245 
246     This field contains the error code that indicates what decoding problem was
247     found.
248 
249     \sa QCborValue::fromCbor()
250  */
251 
252 /*!
253     \fn QString QCborParserError::errorString() const
254 
255     Returns a string representation of the error code. This string is not
256     translated.
257 
258     \sa QCborError::toString(), QCborValue::fromCbor()
259  */
260 
261 /*!
262     \enum QCborValue::EncodingOption
263 
264     This enum is used in the options argument to toCbor(), modifying the
265     behavior of the encoder.
266 
267     \omitvalue SortKeysInMaps
268     \value NoTransformation (Default) Performs no transformations.
269     \value UseFloat         Tells the encoder to use IEEE 754 single-precision floating point
270                             (that is, \c float) whenever possible.
271     \value UseFloat16       Tells the encoder to use IEEE 754 half-precision floating point
272                             (that is, \c qfloat16), whenever possible. Implies \c UseFloat.
273     \value UseIntegers      Tells the encoder to use integers whenever a value of type \l
274                             {Type}{Double} contains an integer.
275 
276     The use of \c UseFloat16 is required to encode the stream in Canonical
277     Format, but is not otherwise necessary.
278 
279     \sa toCbor()
280  */
281 
282 /*!
283     \enum QCborValue::DiagnosticNotationOption
284 
285     This enum is used in the option argument to toDiagnosticNotation(), to
286     modify the output format.
287 
288     \value Compact          Does not use any line-breaks, producing a compact representation.
289     \value LineWrapped      Uses line-breaks, one QCborValue per line.
290     \value ExtendedFormat   Uses some different options to represent values, not found in
291                             RFC 7049. Those options are subject to change.
292 
293     Currently, \c ExtendedFormat will change how byte arrays are represented.
294     Without it, they are always hex-encoded and without spaces. With it,
295     QCborValue::toCbor() will either use hex with spaces, base64 or base64url
296     encoding, depending on the context.
297 
298     \sa toDiagnosticNotation()
299  */
300 
301 /*!
302     \enum QCborValue::Type
303 
304     This enum represents the QCborValue type. It is returned by the type()
305     function.
306 
307     The CBOR built-in types are:
308 
309     \value Integer              \c qint64: An integer value
310     \value ByteArray            \l QByteArray: a byte array ("byte string")
311     \value String               \l QString: a Unicode string ("text string")
312     \value Array                \l QCborArray: an array of QCborValues
313     \value Map                  \l QCborMap: an associative container of QCborValues
314     \value SimpleType           \l QCborSimpleType: one of several simple types/values
315     \value False                \c bool: the simple type for value \c false
316     \value True                 \c bool: the simple type for value \c true
317     \value Null                 \c std::nullptr_t: the simple type for the null value
318     \value Undefined            (no type) the simple type for the undefined value
319     \value Double               \c double: a double-precision floating point
320     \value Invalid              Not a valid value, this usually indicates a CBOR decoding error
321 
322     Additionally, QCborValue can represent extended types:
323 
324     \value Tag                  An unknown or unrecognized extended type, represented by its
325                                 tag (a \l QCborTag) and the tagged value (a QCborValue)
326     \value DateTime             \l QDateTime: a date and time stamp
327     \value Url                  \l QUrl: a URL or URI
328     \value RegularExpression    \l QRegularExpression: the pattern of a regular expression
329     \value Uuid                 \l QUuid: a UUID
330 
331     \sa type()
332  */
333 
334 /*!
335     \fn QCborValue::QCborValue()
336 
337     Creates a QCborValue of the \l {Type}{Undefined} type.
338 
339     CBOR undefined values are used to indicate missing information, usually as
340     a result of a previous operation that did not complete as expected. They
341     are also used by the QCborArray and QCborMap API to indicate the searched
342     item was not found.
343 
344     Undefined values are represented by the \l {QCborSimpleType}{Undefined
345     simple type}. Because of that, QCborValues with undefined values will also
346     return true for isSimpleType() and
347     \c{isSimpleType(QCborSimpleType::Undefined)}.
348 
349     Undefined values are different from null values.
350 
351     QCborValue objects with undefined values are also different from invalid
352     QCborValue objects. The API will not create invalid QCborValues, but they
353     may exist as a result of a parsing error.
354 
355     \sa isUndefined(), isNull(), isSimpleType()
356  */
357 
358 /*!
359     \fn QCborValue::QCborValue(Type t_)
360 
361     Creates a QCborValue of type \a t_. The value associated with such a type
362     (if any) will be default constructed.
363 
364     \sa type()
365  */
366 
367 /*!
368     \fn QCborValue::QCborValue(std::nullptr_t)
369 
370     Creates a QCborValue of the \l {Type}{Null} type.
371 
372     CBOR null values are used to indicate optional values that were not
373     provided. They are distinct from undefined values, in that null values are
374     usually not the result of an earlier error or problem.
375 
376     \sa isNull(), isUndefined(), isSimpleType()
377  */
378 
379 /*!
380     \fn QCborValue::QCborValue(bool b)
381 
382     Creates a QCborValue with boolean value \a b. The value can later be
383     retrieved using toBool().
384 
385     Internally, CBOR booleans are represented by a pair of types, one for true
386     and one for false. For that reason, boolean QCborValues will return true
387     for isSimpleType() and one of \c{isSimpleType(QCborSimpleType::False)} or
388     \c{isSimpleType(QCborSimpleType::True)}.
389 
390     \sa toBool(), isBool(), isTrue(), isFalse(), isSimpleType()
391  */
392 
393 /*!
394     \fn QCborValue::QCborValue(qint64 i)
395 
396     Creates a QCborValue with integer value \a i. The value can later be
397     retrieved using toInteger().
398 
399     CBOR integer values are distinct from floating point values. Therefore,
400     QCborValue objects with integers will compare differently to QCborValue
401     objects containing floating-point, even if the values contained in the
402     objects are equivalent.
403 
404     \sa toInteger(), isInteger(), isDouble()
405  */
406 
407 /*!
408     \fn QCborValue::QCborValue(double d)
409 
410     Creates a QCborValue with floating point value \a d. The value can later be
411     retrieved using toDouble().
412 
413     CBOR floating point values are distinct from integer values. Therefore,
414     QCborValue objects with integers will compare differently to QCborValue
415     objects containing floating-point, even if the values contained in the
416     objects are equivalent.
417 
418     \sa toDouble(), isDouble(), isInteger()
419  */
420 
421 /*!
422     \fn QCborValue::QCborValue(QCborSimpleType st)
423 
424     Creates a QCborValue of simple type \a st. The type can later later be retrieved
425     using toSimpleType() as well as isSimpleType(st).
426 
427     CBOR simple types are types that do not have any associated value, like
428     C++'s \c{std::nullptr_t} type, whose only possible value is \nullptr.
429 
430     If \a st is \c{QCborSimpleType::Null}, the resulting QCborValue will be of
431     the \l{Type}{Null} type and similarly for \c{QCborSimpleType::Undefined}.
432     If \a st is \c{QCborSimpleType::False} or \c{QCborSimpleType::True}, the
433     created QCborValue will be a boolean containing a value of false or true,
434     respectively.
435 
436     This function can be used with simple types not defined in the API. For
437     example, to create a QCborValue with simple type 12, one could write:
438 
439     \snippet code/src_corelib_serialization_qcborvalue.cpp 1
440 
441     Simple types should not be used until a specification for them has been
442     published, since other implementations may not support them properly.
443     Simple type values 24 to 31 are reserved and must not be used.
444 
445     isSimpleType(), isNull(), isUndefined(), isTrue(), isFalse()
446  */
447 
448 /*!
449     \fn QCborValue::QCborValue(QCborKnownTags tag, const QCborValue &taggedValue)
450     \overload
451 
452     Creates a QCborValue for the extended type represented by the tag value \a
453     tag, tagging value \a taggedValue. The tag can later be retrieved using
454     tag() and the tagged value using taggedValue().
455 
456     \sa isTag(), tag(), taggedValue(), QCborKnownTags
457  */
458 
459 /*!
460     \fn QCborValue::~QCborValue()
461 
462     Disposes of the current QCborValue object and frees any associated resources.
463  */
464 
465 /*!
466     \fn QCborValue::QCborValue(QCborValue &&other)
467     \overload
468 
469     Moves the contents of the \a other QCborValue object into this one and frees
470     the resources of this one.
471  */
472 
473 /*!
474     \fn QCborValue &&QCborValue::operator=(QCborValue &&other)
475     \overload
476 
477     Moves the contents of the \a other QCborValue object into this one and frees
478     the resources of this one. Returns a reference to this object.
479  */
480 
481 /*!
482     \fn void QCborValue::swap(QCborValue &other)
483 
484     Swaps the contents of this QCborValue object and \a other.
485  */
486 
487 /*!
488     \fn QCborValue::Type QCborValue::type() const
489 
490     Returns the type of this QCborValue. The type can also later be retrieved by one
491     of the "isXxx" functions.
492 
493     \sa isInteger(), isByteArray(), isString(), isArray(), isMap(),
494         isTag(), isFalse(), isTrue(), isBool(), isNull(), isUndefined, isDouble(),
495         isDateTime(), isUrl(), isRegularExpression(), isUuid()
496  */
497 
498 /*!
499     \fn bool QCborValue::isInteger() const
500 
501     Returns true if this QCborValue is of the integer type. The integer value
502     can be retrieved using toInteger().
503 
504     \sa type(), toInteger()
505  */
506 
507 /*!
508     \fn bool QCborValue::isByteArray() const
509 
510     Returns true if this QCborValue is of the byte array type. The byte array
511     value can be retrieved using toByteArray().
512 
513     \sa type(), toByteArray()
514  */
515 
516 /*!
517     \fn bool QCborValue::isString() const
518 
519     Returns true if this QCborValue is of the string type. The string value
520     can be retrieved using toString().
521 
522     \sa type(), toString()
523  */
524 
525 /*!
526     \fn bool QCborValue::isArray() const
527 
528     Returns true if this QCborValue is of the array type. The array value can
529     be retrieved using toArray().
530 
531     \sa type(), toArray()
532  */
533 
534 /*!
535     \fn bool QCborValue::isMap() const
536 
537     Returns true if this QCborValue is of the map type. The map value can be
538     retrieved using toMap().
539 
540     \sa type(), toMap()
541  */
542 
543 /*!
544     \fn bool QCborValue::isTag() const
545 
546     Returns true if this QCborValue is of the tag type. The tag value can be
547     retrieved using tag() and the tagged value using taggedValue().
548 
549     This function also returns true for extended types that the API
550     recognizes. For code that handles extended types directly before the Qt API
551     is updated to support them, it is possible to recreate the tag + tagged
552     value pair by using taggedValue().
553 
554     \sa type(), tag(), taggedValue(), taggedValue()
555  */
556 
557 /*!
558     \fn bool QCborValue::isFalse() const
559 
560     Returns true if this QCborValue is a boolean with false value. This
561     function exists because, internally, CBOR booleans are stored as two
562     separate types, one for true and one for false.
563 
564     \sa type(), isBool(), isTrue(), toBool()
565  */
566 
567 /*!
568     \fn bool QCborValue::isTrue() const
569 
570     Returns true if this QCborValue is a boolean with true value. This
571     function exists because, internally, CBOR booleans are stored as two
572     separate types, one for false and one for true.
573 
574     \sa type(), isBool(), isFalse(), toBool()
575  */
576 
577 /*!
578     \fn bool QCborValue::isBool() const
579 
580     Returns true if this QCborValue is a boolean. The value can be retrieved
581     using toBool().
582 
583     \sa type(), toBool(), isTrue(), isFalse()
584  */
585 
586 /*!
587     \fn bool QCborValue::isUndefined() const
588 
589     Returns true if this QCborValue is of the undefined type.
590 
591     CBOR undefined values are used to indicate missing information, usually as
592     a result of a previous operation that did not complete as expected. They
593     are also used by the QCborArray and QCborMap API to indicate the searched
594     item was not found.
595 
596     Undefined values are distinct from null values.
597 
598     QCborValue objects with undefined values are also different from invalid
599     QCborValue objects. The API will not create invalid QCborValues, but they
600     may exist as a result of a parsing error.
601 
602     \sa type(), isNull(), isInvalid()
603  */
604 
605 /*!
606     \fn bool QCborValue::isNull() const
607 
608     Returns true if this QCborValue is of the null type.
609 
610     CBOR null values are used to indicate optional values that were not
611     provided. They are distinct from undefined values, in that null values are
612     usually not the result of an earlier error or problem.
613 
614     Null values are distinct from undefined values and from invalid QCborValue
615     objects. The API will not create invalid QCborValues, but they may exist as
616     a result of a parsing error.
617 
618     \sa type(), isUndefined(), isInvalid()
619  */
620 
621 /*!
622     \fn bool QCborValue::isDouble() const
623 
624     Returns true if this QCborValue is of the floating-point type. The value
625     can be retrieved using toDouble().
626 
627     \sa type(), toDouble()
628  */
629 
630 /*!
631     \fn bool QCborValue::isDateTime() const
632 
633     Returns true if this QCborValue is of the date/time type. The value can be
634     retrieved using toDateTime(). Date/times are extended types that use the
635     tag \l{QCborKnownTags}{DateTime}.
636 
637     Additionally, when decoding from a CBOR stream, QCborValue will interpret
638     tags of value \l{QCborKnownTags}{UnixTime_t} and convert them to the
639     equivalent date/time.
640 
641     \sa type(), toDateTime()
642  */
643 
644 /*!
645     \fn bool QCborValue::isUrl() const
646 
647     Returns true if this QCborValue is of the URL type. The URL value
648     can be retrieved using toUrl().
649 
650     \sa type(), toUrl()
651  */
652 
653 /*!
654     \fn bool QCborValue::isRegularExpression() const
655 
656     Returns true if this QCborValue contains a regular expression's pattern.
657     The pattern can be retrieved using toRegularExpression().
658 
659     \sa type(), toRegularExpression()
660  */
661 
662 /*!
663     \fn bool QCborValue::isUuid() const
664 
665     Returns true if this QCborValue contains a UUID. The value can be retrieved
666     using toUuid().
667 
668     \sa type(), toUuid()
669  */
670 
671 /*!
672     \fn bool QCborValue::isInvalid() const
673 
674     Returns true if this QCborValue is not of any valid type. Invalid
675     QCborValues are distinct from those with undefined values and they usually
676     represent a decoding error.
677 
678     \sa isUndefined(), isNull()
679  */
680 
681 /*!
682     \fn bool QCborValue::isContainer() const
683 
684     This convenience function returns true if the QCborValue is either an array
685     or a map.
686 
687     \sa isArray(), isMap()
688  */
689 
690 /*!
691     \fn bool QCborValue::isSimpleType() const
692 
693     Returns true if this QCborValue is of one of the CBOR simple types. The
694     type itself can later be retrieved using type(), even for types that don't have an
695     enumeration in the API. They can also be checked with the
696     \l{isSimpleType(QCborSimpleType)} overload.
697 
698     \sa QCborSimpleType, isSimpleType(QCborSimpleType), toSimpleType()
699  */
700 
701 /*!
702     \fn bool QCborValue::isSimpleType(QCborSimpleType st) const
703     \overload
704 
705     Returns true if this QCborValue is of a simple type and toSimpleType()
706     would return \a st, false otherwise. This function can be used to check for
707     any CBOR simple type, even those for which there is no enumeration in the
708     API. For example, for the simple type of value 12, you could write:
709 
710     \snippet code/src_corelib_serialization_qcborvalue.cpp 2
711 
712     \sa QCborValue::QCborValue(QCborSimpleType), isSimpleType(), isFalse(),
713         isTrue(), isNull, isUndefined(), toSimpleType()
714  */
715 
716 /*!
717     \fn QCborSimpleType QCborValue::toSimpleType(QCborSimpleType defaultValue) const
718 
719     Returns the simple type this QCborValue is of, if it is a simple type. If
720     it is not a simple type, it returns \a defaultValue.
721 
722     The following types are simple types and this function will return the
723     listed values:
724 
725     \table
726       \row \li QCborValue::False        \li QCborSimpleType::False
727       \row \li QCborValue::True         \li QCborSimpleType::True
728       \row \li QCborValue::Null         \li QCborSimpleType::Null
729       \row \li QCborValue::Undefined    \li QCborSimpleType::Undefined
730     \endtable
731 
732     \sa type(), isSimpleType(), isBool(), isTrue(), isFalse(), isTrue(),
733         isNull(), isUndefined()
734  */
735 
736 /*!
737     \fn qint64 QCborValue::toInteger(qint64 defaultValue) const
738 
739     Returns the integer value stored in this QCborValue, if it is of the
740     integer type. If it is of the Double type, this function returns the
741     floating point value converted to integer. In any other case, it returns \a
742     defaultValue.
743 
744     \sa isInteger(), isDouble(), toDouble()
745  */
746 
747 /*!
748     \fn bool QCborValue::toBool(bool defaultValue) const
749 
750     Returns the boolean value stored in this QCborValue, if it is of a boolean
751     type. Otherwise, it returns \a defaultValue.
752 
753     \sa isBool(), isTrue(), isFalse()
754  */
755 
756 /*!
757     \fn double QCborValue::toDouble(double defaultValue) const
758 
759     Returns the floating point value stored in this QCborValue, if it is of the
760     Double type. If it is of the Integer type, this function returns the
761     integer value converted to double. In any other case, it returns \a
762     defaultValue.
763 
764     \sa isDouble(), isInteger(), toInteger()
765  */
766 
767 using namespace QtCbor;
768 
769 static QCborValue::Type convertToExtendedType(QCborContainerPrivate *d)
770 {
771     qint64 tag = d->elements.at(0).value;
772     auto &e = d->elements[1];
773     const ByteData *b = d->byteData(e);
774 
775     auto replaceByteData = [&](const char *buf, qsizetype len, Element::ValueFlags f) {
776         d->data.clear();
777         d->usedData = 0;
778         e.flags = Element::HasByteData | f;
779         e.value = d->addByteData(buf, len);
780     };
781 
782     switch (tag) {
783     case qint64(QCborKnownTags::DateTimeString):
784     case qint64(QCborKnownTags::UnixTime_t): {
785         QDateTime dt;
786         if (tag == qint64(QCborKnownTags::DateTimeString) && b &&
787             e.type == QCborValue::String && (e.flags & Element::StringIsUtf16) == 0) {
788             // The data is supposed to be US-ASCII. If it isn't (contains UTF-8),
789             // QDateTime::fromString will fail anyway.
790             dt = QDateTime::fromString(b->asLatin1(), Qt::ISODateWithMs);
791         } else if (tag == qint64(QCborKnownTags::UnixTime_t)) {
792             qint64 msecs;
793             bool ok = false;
794             if (e.type == QCborValue::Integer) {
795 #if QT_POINTER_SIZE == 8
796                 // we don't have a fast 64-bit mul_overflow implementation on
797                 // 32-bit architectures.
798                 ok = !mul_overflow(e.value, qint64(1000), &msecs);
799 #else
800                 static const qint64 Limit = std::numeric_limits<qint64>::max() / 1000;
801                 ok = (e.value > -Limit && e.value < Limit);
802                 if (ok)
803                     msecs = e.value * 1000;
804 #endif
805             } else if (e.type == QCborValue::Double) {
806                 ok = convertDoubleTo(round(e.fpvalue() * 1000), &msecs);
807             }
808             if (ok)
809                 dt = QDateTime::fromMSecsSinceEpoch(msecs, Qt::UTC);
810         }
811         if (dt.isValid()) {
812             QByteArray text = dt.toString(Qt::ISODateWithMs).toLatin1();
813             if (!text.isEmpty()) {
814                 replaceByteData(text, text.size(), Element::StringIsAscii);
815                 e.type = QCborValue::String;
816                 d->elements[0].value = qint64(QCborKnownTags::DateTimeString);
817                 return QCborValue::DateTime;
818             }
819         }
820         break;
821     }
822 
823 #ifndef QT_BOOTSTRAPPED
824     case qint64(QCborKnownTags::Url):
825         if (e.type == QCborValue::String) {
826             if (b) {
827                 // normalize to a short (decoded) form, so as to save space
828                 QUrl url(e.flags & Element::StringIsUtf16 ?
829                              b->asQStringRaw() :
830                              b->toUtf8String(), QUrl::StrictMode);
831                 if (url.isValid()) {
832                     QByteArray encoded = url.toString(QUrl::DecodeReserved).toUtf8();
833                     replaceByteData(encoded, encoded.size(), {});
834                 }
835             }
836             return QCborValue::Url;
837         }
838         break;
839 #endif // QT_BOOTSTRAPPED
840 
841 #if QT_CONFIG(regularexpression)
842     case quint64(QCborKnownTags::RegularExpression):
843         if (e.type == QCborValue::String) {
844             // no normalization is necessary
845             return QCborValue::RegularExpression;
846         }
847         break;
848 #endif // QT_CONFIG(regularexpression)
849 
850     case qint64(QCborKnownTags::Uuid):
851         if (e.type == QCborValue::ByteArray) {
852             // force the size to 16
853             char buf[sizeof(QUuid)] = {};
854             if (b)
855                 memcpy(buf, b->byte(), qMin(sizeof(buf), size_t(b->len)));
856             replaceByteData(buf, sizeof(buf), {});
857 
858             return QCborValue::Uuid;
859         }
860         break;
861     }
862 
863     // no enriching happened
864     return QCborValue::Tag;
865 }
866 
867 #if QT_CONFIG(cborstreamwriter)
868 static void writeDoubleToCbor(QCborStreamWriter &writer, double d, QCborValue::EncodingOptions opt)
869 {
870     if (qt_is_nan(d)) {
871         if (opt & QCborValue::UseFloat) {
872 #ifndef QT_BOOTSTRAPPED
873             if ((opt & QCborValue::UseFloat16) == QCborValue::UseFloat16)
874                 return writer.append(std::numeric_limits<qfloat16>::quiet_NaN());
875 #endif
876             return writer.append(std::numeric_limits<float>::quiet_NaN());
877         }
878         return writer.append(qt_qnan());
879     }
880 
881     if (qt_is_inf(d)) {
882         d = d > 0 ? qt_inf() : -qt_inf();
883     } else if (opt & QCborValue::UseIntegers) {
884         quint64 i;
885         if (convertDoubleTo(d, &i)) {
886             if (d < 0)
887                 return writer.append(QCborNegativeInteger(i));
888             return writer.append(i);
889         }
890     }
891 
892     if (opt & QCborValue::UseFloat) {
893         float f = float(d);
894         if (f == d) {
895             // no data loss, we could use float
896 #ifndef QT_BOOTSTRAPPED
897             if ((opt & QCborValue::UseFloat16) == QCborValue::UseFloat16) {
898                 qfloat16 f16 = f;
899                 if (f16 == f)
900                     return writer.append(f16);
901             }
902 #endif
903 
904             return writer.append(f);
905         }
906     }
907 
908     writer.append(d);
909 }
910 #endif // QT_CONFIG(cborstreamwriter)
911 
912 static inline int typeOrder(Element e1, Element e2)
913 {
914     auto comparable = [](Element e) {
915         if (e.type >= 0x10000)      // see QCborValue::isTag_helper()
916             return QCborValue::Tag;
917         return e.type;
918     };
919     return comparable(e1) - comparable(e2);
920 }
921 
922 QCborContainerPrivate::~QCborContainerPrivate()
923 {
924     // delete our elements
925     for (Element &e : elements) {
926         if (e.flags & Element::IsContainer)
927             e.container->deref();
928     }
929 }
930 
931 void QCborContainerPrivate::compact(qsizetype reserved)
932 {
933     if (usedData > data.size() / 2)
934         return;
935 
936     // 50% savings if we recreate the byte data
937     // ### TBD
938     Q_UNUSED(reserved);
939 }
940 
941 QCborContainerPrivate *QCborContainerPrivate::clone(QCborContainerPrivate *d, qsizetype reserved)
942 {
943     if (!d) {
944         d = new QCborContainerPrivate;
945     } else {
946         d = new QCborContainerPrivate(*d);
947         if (reserved >= 0) {
948             d->elements.reserve(reserved);
949             d->compact(reserved);
950         }
951         for (auto &e : qAsConst(d->elements)) {
952             if (e.flags & Element::IsContainer)
953                 e.container->ref.ref();
954         }
955     }
956     return d;
957 }
958 
959 QCborContainerPrivate *QCborContainerPrivate::detach(QCborContainerPrivate *d, qsizetype reserved)
960 {
961     if (!d || d->ref.loadRelaxed() != 1)
962         return clone(d, reserved);
963     return d;
964 }
965 
966 /*!
967   Prepare for an insertion at position \a index
968 
969   Detaches and ensures there are at least index entries in the array, padding
970   with Undefined as needed.
971 */
972 QCborContainerPrivate *QCborContainerPrivate::grow(QCborContainerPrivate *d, qsizetype index)
973 {
974     Q_ASSERT(index >= 0);
975     d = detach(d, index + 1);
976     Q_ASSERT(d);
977     int j = d->elements.size();
978     while (j++ < index)
979         d->append(Undefined());
980     return d;
981 }
982 
983 // Copies or moves \a value into element at position \a e. If \a disp is
984 // CopyContainer, then this function increases the reference count of the
985 // container, but otherwise leaves it unmodified. If \a disp is MoveContainer,
986 // then it transfers ownership (move semantics) and the caller must set
987 // value.container back to nullptr.
988 void QCborContainerPrivate::replaceAt_complex(Element &e, const QCborValue &value, ContainerDisposition disp)
989 {
990     if (value.n < 0) {
991         // This QCborValue is an array, map, or tagged value (container points
992         // to itself).
993 
994         // detect self-assignment
995         if (Q_UNLIKELY(this == value.container)) {
996             Q_ASSERT(ref.loadRelaxed() >= 2);
997             if (disp == MoveContainer)
998                 ref.deref();    // not deref() because it can't drop to 0
999             QCborContainerPrivate *d = QCborContainerPrivate::clone(this);
1000             d->elements.detach();
1001             d->ref.storeRelaxed(1);
1002             e.container = d;
1003         } else {
1004             e.container = value.container;
1005             if (disp == CopyContainer)
1006                 e.container->ref.ref();
1007         }
1008 
1009         e.type = value.type();
1010         e.flags = Element::IsContainer;
1011     } else {
1012         // String data, copy contents
1013         e = value.container->elements.at(value.n);
1014 
1015         // Copy string data, if any
1016         if (const ByteData *b = value.container->byteData(value.n)) {
1017             if (this == value.container)
1018                 e.value = addByteData(b->toByteArray(), b->len);
1019             else
1020                 e.value = addByteData(b->byte(), b->len);
1021         }
1022 
1023         if (disp == MoveContainer)
1024             value.container->deref();
1025     }
1026 }
1027 
1028 // in qstring.cpp
1029 void qt_to_latin1_unchecked(uchar *dst, const char16_t *uc, qsizetype len);
1030 
1031 Q_NEVER_INLINE void QCborContainerPrivate::appendAsciiString(QStringView s)
1032 {
1033     qsizetype len = s.size();
1034     QtCbor::Element e;
1035     e.value = addByteData(nullptr, len);
1036     e.type = QCborValue::String;
1037     e.flags = Element::HasByteData | Element::StringIsAscii;
1038     elements.append(e);
1039 
1040     char *ptr = data.data() + e.value + sizeof(ByteData);
1041     uchar *l = reinterpret_cast<uchar *>(ptr);
1042     qt_to_latin1_unchecked(l, s.utf16(), len);
1043 }
1044 
1045 QCborValue QCborContainerPrivate::extractAt_complex(Element e)
1046 {
1047     // create a new container for the returned value, containing the byte data
1048     // from this element, if it's worth it
1049     Q_ASSERT(e.flags & Element::HasByteData);
1050     auto b = byteData(e);
1051     auto container = new QCborContainerPrivate;
1052 
1053     if (b->len + qsizetype(sizeof(*b)) < data.size() / 4) {
1054         // make a shallow copy of the byte data
1055         container->appendByteData(b->byte(), b->len, e.type, e.flags);
1056         usedData -= b->len + qsizetype(sizeof(*b));
1057         compact(elements.size());
1058     } else {
1059         // just share with the original byte data
1060         container->data = data;
1061         container->elements.reserve(1);
1062         container->elements.append(e);
1063     }
1064 
1065     return makeValue(e.type, 0, container);
1066 }
1067 
1068 QT_WARNING_DISABLE_MSVC(4146)   // unary minus operator applied to unsigned type, result still unsigned
1069 static int compareContainer(const QCborContainerPrivate *c1, const QCborContainerPrivate *c2);
1070 static int compareElementNoData(const Element &e1, const Element &e2)
1071 {
1072     Q_ASSERT(e1.type == e2.type);
1073 
1074     if (e1.type == QCborValue::Integer) {
1075         // CBOR sorting order is 0, 1, 2, ..., INT64_MAX, -1, -2, -3, ... INT64_MIN
1076         // So we transform:
1077         //  0           ->      0
1078         //  1           ->      1
1079         //  INT64_MAX   ->      INT64_MAX
1080         //  -1          ->      INT64_MAX + 1 = INT64_MAX - (-1)
1081         //  -2          ->      INT64_MAX + 2 = INT64_MAX - (-2)
1082         //  INT64_MIN   ->      UINT64_MAX = INT64_MAX - INT64_MIN
1083         // Note how the unsigned arithmethic is well defined in C++ (it's
1084         // always performed modulo 2^64).
1085         auto makeSortable = [](qint64 v) {
1086             quint64 u = quint64(v);
1087             if (v < 0)
1088                 return quint64(std::numeric_limits<qint64>::max()) + (-u);
1089             return u;
1090         };
1091         quint64 u1 = makeSortable(e1.value);
1092         quint64 u2 = makeSortable(e2.value);
1093         if (u1 < u2)
1094             return -1;
1095         if (u1 > u2)
1096             return 1;
1097     }
1098 
1099     if (e1.type == QCborValue::Tag || e1.type == QCborValue::Double) {
1100         // Perform unsigned comparisons for the tag value and floating point
1101         quint64 u1 = quint64(e1.value);
1102         quint64 u2 = quint64(e2.value);
1103         if (u1 != u2)
1104             return u1 < u2 ? -1 : 1;
1105     }
1106 
1107     // Any other type is equal at this point:
1108     // - simple types carry no value
1109     // - empty strings, arrays and maps
1110     return 0;
1111 }
1112 
1113 static int compareElementRecursive(const QCborContainerPrivate *c1, const Element &e1,
1114                                    const QCborContainerPrivate *c2, const Element &e2)
1115 {
1116     int cmp = typeOrder(e1, e2);
1117     if (cmp != 0)
1118         return cmp;
1119 
1120     if ((e1.flags & Element::IsContainer) || (e2.flags & Element::IsContainer))
1121         return compareContainer(e1.flags & Element::IsContainer ? e1.container : nullptr,
1122                                 e2.flags & Element::IsContainer ? e2.container : nullptr);
1123 
1124     // string data?
1125     const ByteData *b1 = c1 ? c1->byteData(e1) : nullptr;
1126     const ByteData *b2 = c2 ? c2->byteData(e2) : nullptr;
1127     if (b1 || b2) {
1128         auto len1 = b1 ? b1->len : 0;
1129         auto len2 = b2 ? b2->len : 0;
1130 
1131         if (e1.flags & Element::StringIsUtf16)
1132             len1 /= 2;
1133         if (e2.flags & Element::StringIsUtf16)
1134             len2 /= 2;
1135         if (len1 == 0 || len2 == 0)
1136             return len1 < len2 ? -1 : len1 == len2 ? 0 : 1;
1137 
1138         // we definitely have data from this point forward
1139         Q_ASSERT(b1);
1140         Q_ASSERT(b2);
1141 
1142         // Officially with CBOR, we sort first the string with the shortest
1143         // UTF-8 length. The length of an ASCII string is the same as its UTF-8
1144         // and UTF-16 ones, but the UTF-8 length of a string is bigger than the
1145         // UTF-16 equivalent. Combinations are:
1146         //  1) UTF-16 and UTF-16
1147         //  2) UTF-16 and UTF-8  <=== this is the problem case
1148         //  3) UTF-16 and US-ASCII
1149         //  4) UTF-8 and UTF-8
1150         //  5) UTF-8 and US-ASCII
1151         //  6) US-ASCII and US-ASCII
1152         if ((e1.flags & Element::StringIsUtf16) && (e2.flags & Element::StringIsUtf16)) {
1153             // Case 1: both UTF-16, so lengths are comparable.
1154             // (we can't use memcmp in little-endian machines)
1155             if (len1 == len2)
1156                 return QtPrivate::compareStrings(b1->asStringView(), b2->asStringView());
1157             return len1 < len2 ? -1 : 1;
1158         }
1159 
1160         if (!(e1.flags & Element::StringIsUtf16) && !(e2.flags & Element::StringIsUtf16)) {
1161             // Cases 4, 5 and 6: neither is UTF-16, so lengths are comparable too
1162             // (this case includes byte arrays too)
1163             if (len1 == len2)
1164                 return memcmp(b1->byte(), b2->byte(), size_t(len1));
1165             return len1 < len2 ? -1 : 1;
1166         }
1167 
1168         if (!(e1.flags & Element::StringIsAscii) || !(e2.flags & Element::StringIsAscii)) {
1169             // Case 2: one of them is UTF-8 and the other is UTF-16, so lengths
1170             // are NOT comparable. We need to convert to UTF-16 first...
1171             // (we can't use QUtf8::compareUtf8 because we need to compare lengths)
1172             auto string = [](const Element &e, const ByteData *b) {
1173                 return e.flags & Element::StringIsUtf16 ? b->asQStringRaw() : b->toUtf8String();
1174             };
1175 
1176             QString s1 = string(e1, b1);
1177             QString s2 = string(e2, b2);
1178             if (s1.size() == s2.size())
1179                 return s1.compare(s2);
1180             return s1.size() < s2.size() ? -1 : 1;
1181         }
1182 
1183         // Case 3 (UTF-16 and US-ASCII) remains, so lengths are comparable again
1184         if (len1 != len2)
1185             return len1 < len2 ? -1 : 1;
1186         if (e1.flags & Element::StringIsUtf16)
1187             return QtPrivate::compareStrings(b1->asStringView(), b2->asLatin1());
1188         return QtPrivate::compareStrings(b1->asLatin1(), b2->asStringView());
1189     }
1190 
1191     return compareElementNoData(e1, e2);
1192 }
1193 
1194 static int compareContainer(const QCborContainerPrivate *c1, const QCborContainerPrivate *c2)
1195 {
1196     auto len1 = c1 ? c1->elements.size() : 0;
1197     auto len2 = c2 ? c2->elements.size() : 0;
1198     if (len1 != len2) {
1199         // sort the shorter container first
1200         return len1 < len2 ? -1 : 1;
1201     }
1202 
1203     for (qsizetype i = 0; i < len1; ++i) {
1204         const Element &e1 = c1->elements.at(i);
1205         const Element &e2 = c2->elements.at(i);
1206         int cmp = QCborContainerPrivate::compareElement_helper(c1, e1, c2, e2);
1207         if (cmp)
1208             return cmp;
1209     }
1210 
1211     return 0;
1212 }
1213 
1214 inline int QCborContainerPrivate::compareElement_helper(const QCborContainerPrivate *c1, Element e1,
1215                                                         const QCborContainerPrivate *c2, Element e2)
1216 {
1217     return compareElementRecursive(c1, e1, c2, e2);
1218 }
1219 
1220 /*!
1221     \fn bool QCborValue::operator==(const QCborValue &other) const
1222 
1223     Compares this value and \a other, and returns true if they hold the same
1224     contents, false otherwise. If each QCborValue contains an array or map, the
1225     comparison is recursive to elements contained in them.
1226 
1227     For more information on CBOR equality in Qt, see, compare().
1228 
1229     \sa compare(), QCborValue::operator==(), QCborMap::operator==(),
1230         operator!=(), operator<()
1231  */
1232 
1233 /*!
1234     \fn bool QCborValue::operator!=(const QCborValue &other) const
1235 
1236     Compares this value and \a other, and returns true if contents differ,
1237     false otherwise. If each QCborValue contains an array or map, the comparison
1238     is recursive to elements contained in them.
1239 
1240     For more information on CBOR equality in Qt, see, QCborValue::compare().
1241 
1242     \sa compare(), QCborValue::operator==(), QCborMap::operator==(),
1243         operator==(), operator<()
1244  */
1245 
1246 /*!
1247     \fn bool QCborValue::operator<(const QCborValue &other) const
1248 
1249     Compares this value and \a other, and returns true if this value should be
1250     sorted before \a other, false otherwise. If each QCborValue contains an
1251     array or map, the comparison is recursive to elements contained in them.
1252 
1253     For more information on CBOR sorting order, see QCborValue::compare().
1254 
1255     \sa compare(), QCborValue::operator==(), QCborMap::operator==(),
1256         operator==(), operator!=()
1257  */
1258 
1259 /*!
1260     Compares this value and \a other, and returns an integer that indicates
1261     whether this value should be sorted prior to (if the result is negative) or
1262     after \a other (if the result is positive). If this function returns 0, the
1263     two values are equal and hold the same contents.
1264 
1265     If each QCborValue contains an array or map, the comparison is recursive to
1266     elements contained in them.
1267 
1268     \section3 Extended types
1269 
1270     QCborValue compares equal a QCborValue containing an extended type, like
1271     \l{Type}{Url} and \l{Type}{Url} and its equivalent tagged representation.
1272     So, for example, the following expression is true:
1273 
1274     \snippet code/src_corelib_serialization_qcborvalue.cpp 3
1275 
1276     Do note that Qt types like \l QUrl and \l QDateTime will normalize and
1277     otherwise modify their arguments. The expression above is true only because
1278     the string on the right side is the normalized value that the QCborValue on
1279     the left would take. If, for example, the "https" part were uppercase in
1280     both sides, the comparison would fail. For information on normalizations
1281     performed by QCborValue, please consult the documentation of the
1282     constructor taking the Qt type in question.
1283 
1284     \section3 Sorting order
1285 
1286     Sorting order in CBOR is defined in RFC 7049
1287     {https://tools.ietf.org/html/rfc7049#section-3.9}{section 3.9}, which
1288     discusses the sorting of keys in a map when following the Canonical
1289     encoding. According to the specification, "sorting is performed on the
1290     bytes of the representation of the key data items" and lists as
1291     consequences that:
1292 
1293     \list
1294       \li "If two keys have different lengths, the shorter one sorts earlier;"
1295       \li "If two keys have the same length, the one with the lower value in
1296           (byte-wise) lexical order sorts earlier."
1297     \endlist
1298 
1299     This results in surprising sorting of QCborValues, where the result of this
1300     function is different from that which would later be retrieved by comparing the
1301     contained elements. For example, the QCborValue containing string "zzz"
1302     sorts before the QCborValue with string "foobar", even though when
1303     comparing as \l{QString::compare()}{QStrings} or
1304     \l{QByteArray}{QByteArrays} the "zzz" sorts after "foobar"
1305     (dictionary order).
1306 
1307     The specification does not clearly indicate what sorting order should be
1308     done for values of different types (it says sorting should not pay
1309     "attention to the 3/5 bit splitting for major types"). QCborValue makes the
1310     assumption that types should be sorted too. The numeric values of the
1311     QCborValue::Type enumeration are in that order, with the exception of the
1312     extended types, which compare as their tagged equivalents.
1313 
1314     \note Sorting order is preliminary and is subject to change. Applications
1315     should not depend on the order returned by this function for the time
1316     being.
1317 
1318     \sa QCborArray::compare(), QCborMap::compare(), operator==()
1319  */
1320 int QCborValue::compare(const QCborValue &other) const
1321 {
1322     Element e1 = QCborContainerPrivate::elementFromValue(*this);
1323     Element e2 = QCborContainerPrivate::elementFromValue(other);
1324     return compareElementRecursive(container, e1, other.container, e2);
1325 }
1326 
1327 int QCborArray::compare(const QCborArray &other) const noexcept
1328 {
1329     return compareContainer(d.data(), other.d.data());
1330 }
1331 
1332 int QCborMap::compare(const QCborMap &other) const noexcept
1333 {
1334     return compareContainer(d.data(), other.d.data());
1335 }
1336 
1337 #if QT_CONFIG(cborstreamwriter)
1338 static void encodeToCbor(QCborStreamWriter &writer, const QCborContainerPrivate *d, qsizetype idx,
1339                          QCborValue::EncodingOptions opt)
1340 {
1341     if (idx == -QCborValue::Array || idx == -QCborValue::Map) {
1342         bool isArray = (idx == -QCborValue::Array);
1343         qsizetype len = d ? d->elements.size() : 0;
1344         if (isArray)
1345             writer.startArray(quint64(len));
1346         else
1347             writer.startMap(quint64(len) / 2);
1348 
1349         for (idx = 0; idx < len; ++idx)
1350             encodeToCbor(writer, d, idx, opt);
1351 
1352         if (isArray)
1353             writer.endArray();
1354         else
1355             writer.endMap();
1356     } else if (idx < 0) {
1357         if (d->elements.size() != 2) {
1358             // invalid state!
1359             qWarning("QCborValue: invalid tag state; are you encoding something that was improperly decoded?");
1360             return;
1361         }
1362 
1363         // write the tag and the tagged element
1364         writer.append(QCborTag(d->elements.at(0).value));
1365         encodeToCbor(writer, d, 1, opt);
1366     } else {
1367         // just one element
1368         auto e = d->elements.at(idx);
1369         const ByteData *b = d->byteData(idx);
1370         switch (e.type) {
1371         case QCborValue::Integer:
1372             return writer.append(qint64(e.value));
1373 
1374         case QCborValue::ByteArray:
1375             if (b)
1376                 return writer.appendByteString(b->byte(), b->len);
1377             return writer.appendByteString("", 0);
1378 
1379         case QCborValue::String:
1380             if (b) {
1381                 if (e.flags & Element::StringIsUtf16)
1382                     return writer.append(b->asStringView());
1383                 return writer.appendTextString(b->byte(), b->len);
1384             }
1385             return writer.append(QLatin1String());
1386 
1387         case QCborValue::Array:
1388         case QCborValue::Map:
1389         case QCborValue::Tag:
1390             // recurse
1391             return encodeToCbor(writer,
1392                                 e.flags & Element::IsContainer ? e.container : nullptr,
1393                                 -qsizetype(e.type), opt);
1394 
1395         case QCborValue::SimpleType:
1396         case QCborValue::False:
1397         case QCborValue::True:
1398         case QCborValue::Null:
1399         case QCborValue::Undefined:
1400             break;
1401 
1402         case QCborValue::Double:
1403             return writeDoubleToCbor(writer, e.fpvalue(), opt);
1404 
1405         case QCborValue::Invalid:
1406             return;
1407 
1408         case QCborValue::DateTime:
1409         case QCborValue::Url:
1410         case QCborValue::RegularExpression:
1411         case QCborValue::Uuid:
1412             // recurse as tag
1413             return encodeToCbor(writer, e.container, -QCborValue::Tag, opt);
1414         }
1415 
1416         // maybe it's a simple type
1417         int simpleType = e.type - QCborValue::SimpleType;
1418         if (unsigned(simpleType) < 0x100)
1419             return writer.append(QCborSimpleType(simpleType));
1420 
1421         // if we got here, we've got an unknown type
1422         qWarning("QCborValue: found unknown type 0x%x", e.type);
1423     }
1424 }
1425 #endif // QT_CONFIG(cborstreamwriter)
1426 
1427 #if QT_CONFIG(cborstreamreader)
1428 static inline double integerOutOfRange(const QCborStreamReader &reader)
1429 {
1430     Q_ASSERT(reader.isInteger());
1431     if (reader.isUnsignedInteger()) {
1432         quint64 v = reader.toUnsignedInteger();
1433         if (qint64(v) < 0)
1434             return double(v);
1435     } else {
1436         quint64 v = quint64(reader.toNegativeInteger());
1437         if (qint64(v - 1) < 0)
1438             return -double(v);
1439     }
1440 
1441     // result is in range
1442     return 0;
1443 }
1444 
1445 static Element decodeBasicValueFromCbor(QCborStreamReader &reader)
1446 {
1447     Element e = {};
1448 
1449     switch (reader.type()) {
1450     case QCborStreamReader::UnsignedInteger:
1451     case QCborStreamReader::NegativeInteger:
1452         if (double d = integerOutOfRange(reader)) {
1453             e.type = QCborValue::Double;
1454             qToUnaligned(d, &e.value);
1455         } else {
1456             e.type = QCborValue::Integer;
1457             e.value = reader.toInteger();
1458         }
1459         break;
1460     case QCborStreamReader::SimpleType:
1461         e.type = QCborValue::Type(quint8(reader.toSimpleType()) + 0x100);
1462         break;
1463     case QCborStreamReader::Float16:
1464         e.type = QCborValue::Double;
1465         qToUnaligned(double(reader.toFloat16()), &e.value);
1466         break;
1467     case QCborStreamReader::Float:
1468         e.type = QCborValue::Double;
1469         qToUnaligned(double(reader.toFloat()), &e.value);
1470         break;
1471     case QCborStreamReader::Double:
1472         e.type = QCborValue::Double;
1473         qToUnaligned(reader.toDouble(), &e.value);
1474         break;
1475 
1476     default:
1477         Q_UNREACHABLE();
1478     }
1479 
1480     reader.next();
1481     return e;
1482 }
1483 
1484 static inline QCborContainerPrivate *createContainerFromCbor(QCborStreamReader &reader, int remainingRecursionDepth)
1485 {
1486     if (Q_UNLIKELY(remainingRecursionDepth == 0)) {
1487         QCborContainerPrivate::setErrorInReader(reader, { QCborError::NestingTooDeep });
1488         return nullptr;
1489     }
1490 
1491     QCborContainerPrivate *d = nullptr;
1492     int mapShift = reader.isMap() ? 1 : 0;
1493     if (reader.isLengthKnown()) {
1494         quint64 len = reader.length();
1495 
1496         // Clamp allocation to 1M elements (avoids crashing due to corrupt
1497         // stream or loss of precision when converting from quint64 to
1498         // QList::size_type).
1499         len = qMin(len, quint64(1024 * 1024 - 1));
1500         if (len) {
1501             d = new QCborContainerPrivate;
1502             d->ref.storeRelaxed(1);
1503             d->elements.reserve(qsizetype(len) << mapShift);
1504         }
1505     } else {
1506         d = new QCborContainerPrivate;
1507         d->ref.storeRelaxed(1);
1508     }
1509 
1510     reader.enterContainer();
1511     if (reader.lastError() != QCborError::NoError)
1512         return d;
1513 
1514     while (reader.hasNext() && reader.lastError() == QCborError::NoError)
1515         d->decodeValueFromCbor(reader, remainingRecursionDepth - 1);
1516 
1517     if (reader.lastError() == QCborError::NoError)
1518         reader.leaveContainer();
1519 
1520     return d;
1521 }
1522 
1523 static QCborValue taggedValueFromCbor(QCborStreamReader &reader, int remainingRecursionDepth)
1524 {
1525     if (Q_UNLIKELY(remainingRecursionDepth == 0)) {
1526         QCborContainerPrivate::setErrorInReader(reader, { QCborError::NestingTooDeep });
1527         return QCborValue::Invalid;
1528     }
1529 
1530     auto d = new QCborContainerPrivate;
1531     d->append(reader.toTag());
1532     reader.next();
1533 
1534     if (reader.lastError() == QCborError::NoError) {
1535         // decode tagged value
1536         d->decodeValueFromCbor(reader, remainingRecursionDepth - 1);
1537     }
1538 
1539     QCborValue::Type type;
1540     if (reader.lastError() == QCborError::NoError) {
1541         // post-process to create our extended types
1542         type = convertToExtendedType(d);
1543     } else {
1544         // decoding error
1545         type = QCborValue::Invalid;
1546     }
1547 
1548     // note: may return invalid state!
1549     return QCborContainerPrivate::makeValue(type, -1, d);
1550 }
1551 
1552 // in qcborstream.cpp
1553 extern void qt_cbor_stream_set_error(QCborStreamReaderPrivate *d, QCborError error);
1554 inline void QCborContainerPrivate::setErrorInReader(QCborStreamReader &reader, QCborError error)
1555 {
1556     qt_cbor_stream_set_error(reader.d.data(), error);
1557 }
1558 
1559 extern QCborStreamReader::StringResultCode qt_cbor_append_string_chunk(QCborStreamReaderPrivate *d, QByteArray *data);
1560 QCborStreamReader::StringResultCode QCborContainerPrivate::appendStringChunk(QCborStreamReader &reader, QByteArray *data)
1561 {
1562     auto status = qt_cbor_append_string_chunk(reader.d.data(), data);
1563     if (status == QCborStreamReader::EndOfString && reader.lastError() == QCborError::NoError)
1564         reader.preparse();
1565     return status;
1566 }
1567 
1568 void QCborContainerPrivate::decodeStringFromCbor(QCborStreamReader &reader)
1569 {
1570     // The use of size_t means none of the operations here can overflow because
1571     // all inputs are less than half SIZE_MAX.
1572     auto addByteData_local = [this](size_t len) -> qint64 {
1573         constexpr size_t EstimatedOverhead = 16;
1574         constexpr size_t MaxMemoryIncrement = 16384;
1575         size_t offset = data.size();
1576 
1577         // add space for aligned ByteData (this can't overflow)
1578         offset += sizeof(QtCbor::ByteData) + alignof(QtCbor::ByteData);
1579         offset &= ~(alignof(QtCbor::ByteData) - 1);
1580         if (offset > size_t(MaxByteArraySize))
1581             return -1;
1582 
1583         // and calculate the size we want to have
1584         size_t newCapacity = offset + len;          // can't overflow
1585         if (len > MaxMemoryIncrement - EstimatedOverhead) {
1586             // there's a non-zero chance that we won't need this memory at all,
1587             // so capa how much we allocate
1588             newCapacity = offset + MaxMemoryIncrement - EstimatedOverhead;
1589         }
1590         if (newCapacity > size_t(MaxByteArraySize)) {
1591             // this may cause an allocation failure
1592             newCapacity = MaxByteArraySize;
1593         }
1594         if (newCapacity > size_t(data.capacity()))
1595             data.reserve(newCapacity);
1596         data.resize(offset + sizeof(QtCbor::ByteData));
1597         return offset;
1598     };
1599     auto dataPtr = [this]() {
1600         // Null happens when we're reading zero bytes.
1601         Q_ASSERT(data.isNull() || data.isDetached());
1602         return const_cast<char *>(data.constData());
1603     };
1604 
1605     Element e = {};
1606     e.type = (reader.isByteArray() ? QCborValue::ByteArray : QCborValue::String);
1607     if (reader.lastError() != QCborError::NoError)
1608         return;
1609 
1610     qsizetype rawlen = reader.currentStringChunkSize();
1611     QByteArray::size_type len = rawlen;
1612     if (rawlen < 0)
1613         return;                     // error
1614     if (len != rawlen) {
1615         // truncation
1616         setErrorInReader(reader, { QCborError::DataTooLarge });
1617         return;
1618     }
1619 
1620     // allocate space, but only if there will be data
1621     if (len != 0 || !reader.isLengthKnown()) {
1622         e.flags = Element::HasByteData;
1623         e.value = addByteData_local(len);
1624         if (e.value < 0) {
1625             // overflow
1626             setErrorInReader(reader, { QCborError::DataTooLarge });
1627             return;
1628         }
1629     }
1630 
1631     // read chunks
1632     bool isAscii = (e.type == QCborValue::String);
1633     QCborStreamReader::StringResultCode status = appendStringChunk(reader, &data);
1634     while (status == QCborStreamReader::Ok) {
1635         if (e.type == QCborValue::String && len) {
1636             // verify UTF-8 string validity
1637             auto utf8result = QUtf8::isValidUtf8(QByteArrayView(dataPtr(), data.size()).last(len));
1638             if (!utf8result.isValidUtf8) {
1639                 status = QCborStreamReader::Error;
1640                 setErrorInReader(reader, { QCborError::InvalidUtf8String });
1641                 break;
1642             }
1643             isAscii = isAscii && utf8result.isValidAscii;
1644         }
1645 
1646         rawlen = reader.currentStringChunkSize();
1647         len = rawlen;
1648         if (len == rawlen) {
1649             status = appendStringChunk(reader, &data);
1650         } else {
1651             // error
1652             status = QCborStreamReader::Error;
1653             setErrorInReader(reader, { QCborError::DataTooLarge });
1654         }
1655     }
1656 
1657     // update size
1658     if (status == QCborStreamReader::EndOfString) {
1659         auto b = new (dataPtr() + e.value) ByteData;
1660         b->len = data.size() - e.value - int(sizeof(*b));
1661         usedData += b->len;
1662 
1663         if (isAscii) {
1664             // set the flag if it is US-ASCII only (as it often is)
1665             Q_ASSERT(e.type == QCborValue::String);
1666             e.flags |= Element::StringIsAscii;
1667         }
1668 
1669         // check that this UTF-8 text string can be loaded onto a QString
1670         if (e.type == QCborValue::String) {
1671             if (Q_UNLIKELY(b->len > MaxStringSize)) {
1672                 setErrorInReader(reader, { QCborError::DataTooLarge });
1673                 status = QCborStreamReader::Error;
1674             }
1675         }
1676     }
1677 
1678     if (status == QCborStreamReader::Error) {
1679         data.truncate(e.value);
1680         return;
1681     }
1682 
1683     elements.append(e);
1684 }
1685 
1686 void QCborContainerPrivate::decodeValueFromCbor(QCborStreamReader &reader, int remainingRecursionDepth)
1687 {
1688     QCborStreamReader::Type t = reader.type();
1689     switch (t) {
1690     case QCborStreamReader::UnsignedInteger:
1691     case QCborStreamReader::NegativeInteger:
1692     case QCborStreamReader::SimpleType:
1693     case QCborStreamReader::Float16:
1694     case QCborStreamReader::Float:
1695     case QCborStreamReader::Double:
1696         elements.append(decodeBasicValueFromCbor(reader));
1697         break;
1698 
1699     case QCborStreamReader::ByteArray:
1700     case QCborStreamReader::String:
1701         decodeStringFromCbor(reader);
1702         break;
1703 
1704     case QCborStreamReader::Array:
1705     case QCborStreamReader::Map:
1706         return append(makeValue(t == QCborStreamReader::Array ? QCborValue::Array : QCborValue::Map, -1,
1707                                 createContainerFromCbor(reader, remainingRecursionDepth),
1708                                 MoveContainer));
1709 
1710     case QCborStreamReader::Tag:
1711         return append(taggedValueFromCbor(reader, remainingRecursionDepth));
1712 
1713     case QCborStreamReader::Invalid:
1714         return;                 // probably a decode error
1715     }
1716 }
1717 #endif // QT_CONFIG(cborstreamreader)
1718 
1719 /*!
1720     Creates a QCborValue with byte array value \a ba. The value can later be
1721     retrieved using toByteArray().
1722 
1723     \sa toByteArray(), isByteArray(), isString()
1724  */
1725 QCborValue::QCborValue(const QByteArray &ba)
1726     : n(0), container(new QCborContainerPrivate), t(ByteArray)
1727 {
1728     container->appendByteData(ba.constData(), ba.size(), t);
1729     container->ref.storeRelaxed(1);
1730 }
1731 
1732 #if QT_STRINGVIEW_LEVEL < 2
1733 /*!
1734     Creates a QCborValue with string value \a s. The value can later be
1735     retrieved using toString().
1736 
1737     \sa toString(), isString(), isByteArray()
1738  */
1739 QCborValue::QCborValue(const QString &s) : QCborValue(qToStringViewIgnoringNull(s)) {}
1740 #endif
1741 
1742 /*!
1743     Creates a QCborValue with string value \a s. The value can later be
1744     retrieved using toString().
1745 
1746     \sa toString(), isString(), isByteArray()
1747 */
1748 QCborValue::QCborValue(QStringView s)
1749     : n(0), container(new QCborContainerPrivate), t(String)
1750 {
1751     container->append(s);
1752     container->ref.storeRelaxed(1);
1753 }
1754 
1755 /*!
1756     \overload
1757 
1758     Creates a QCborValue with string value \a s. The value can later be
1759     retrieved using toString().
1760 
1761     \sa toString(), isString(), isByteArray()
1762  */
1763 QCborValue::QCborValue(QLatin1String s)
1764     : n(0), container(new QCborContainerPrivate), t(String)
1765 {
1766     container->append(s);
1767     container->ref.storeRelaxed(1);
1768 }
1769 
1770 /*!
1771     \fn QCborValue::QCborValue(const QCborArray &a)
1772     \fn QCborValue::QCborValue(QCborArray &&a)
1773 
1774     Creates a QCborValue with the array \a a. The array can later be retrieved
1775     using toArray().
1776 
1777     \sa toArray(), isArray(), isMap()
1778  */
1779 QCborValue::QCborValue(const QCborArray &a)
1780     : n(-1), container(a.d.data()), t(Array)
1781 {
1782     if (container)
1783         container->ref.ref();
1784 }
1785 
1786 /*!
1787     \fn QCborValue::QCborValue(const QCborMap &m)
1788     \fn QCborValue::QCborValue(QCborMap &&m)
1789 
1790     Creates a QCborValue with the map \a m. The map can later be retrieved
1791     using toMap().
1792 
1793     \sa toMap(), isMap(), isArray()
1794  */
1795 QCborValue::QCborValue(const QCborMap &m)
1796     : n(-1), container(m.d.data()), t(Map)
1797 {
1798     if (container)
1799         container->ref.ref();
1800 }
1801 
1802 /*!
1803     \fn QCborValue::QCborValue(QCborTag tag, const QCborValue &tv)
1804     \fn QCborValue::QCborValue(QCborKnownTags tag, const QCborValue &tv)
1805 
1806     Creates a QCborValue for the extended type represented by the tag value \a
1807     tag, tagging value \a tv. The tag can later be retrieved using tag() and
1808     the tagged value using taggedValue().
1809 
1810     \sa isTag(), tag(), taggedValue(), QCborKnownTags
1811  */
1812 QCborValue::QCborValue(QCborTag tag, const QCborValue &tv)
1813     : n(-1), container(new QCborContainerPrivate), t(Tag)
1814 {
1815     container->ref.storeRelaxed(1);
1816     container->append(tag);
1817     container->append(tv);
1818     t = convertToExtendedType(container);
1819 }
1820 
1821 /*!
1822     Copies the contents of \a other into this object.
1823  */
1824 QCborValue::QCborValue(const QCborValue &other)
1825     : n(other.n), container(other.container), t(other.t)
1826 {
1827     if (container)
1828         container->ref.ref();
1829 }
1830 
1831 /*!
1832     Creates a QCborValue object of the date/time extended type and containing
1833     the value represented by \a dt. The value can later be retrieved using
1834     toDateTime().
1835 
1836     The CBOR date/time types are extension types using tags: either a string
1837     (in ISO date format) tagged as a \l{QCborKnownTags}{DateTime} or a number
1838     (of seconds since the start of 1970, UTC) tagged as a
1839     \l{QCborKnownTags}{UnixTime_t}. When parsing CBOR streams, QCborValue will
1840     convert \l{QCborKnownTags}{UnixTime_t} to the string-based type.
1841 
1842     \sa toDateTime(), isDateTime(), taggedValue()
1843  */
1844 QCborValue::QCborValue(const QDateTime &dt)
1845     : QCborValue(QCborKnownTags::DateTimeString, dt.toString(Qt::ISODateWithMs).toLatin1())
1846 {
1847     // change types
1848     t = DateTime;
1849     container->elements[1].type = String;
1850 }
1851 
1852 #ifndef QT_BOOTSTRAPPED
1853 /*!
1854     Creates a QCborValue object of the URL extended type and containing the
1855     value represented by \a url. The value can later be retrieved using toUrl().
1856 
1857     The CBOR URL type is an extended type represented by a string tagged as an
1858     \l{QCborKnownTags}{Url}.
1859 
1860     \sa toUrl(), isUrl(), taggedValue()
1861  */
1862 QCborValue::QCborValue(const QUrl &url)
1863     : QCborValue(QCborKnownTags::Url, url.toString(QUrl::DecodeReserved).toUtf8())
1864 {
1865     // change types
1866     t = Url;
1867     container->elements[1].type = String;
1868 }
1869 #endif
1870 
1871 #if QT_CONFIG(regularexpression)
1872 /*!
1873     Creates a QCborValue object of the regular expression pattern extended type
1874     and containing the value represented by \a rx. The value can later be retrieved
1875     using toRegularExpression().
1876 
1877     The CBOR regular expression type is an extended type represented by a
1878     string tagged as an \l{QCborKnownTags}{RegularExpression}. Note that CBOR
1879     regular expressions only store the patterns, so any flags that the
1880     QRegularExpression object may carry will be lost.
1881 
1882     \sa toRegularExpression(), isRegularExpression(), taggedValue()
1883  */
1884 QCborValue::QCborValue(const QRegularExpression &rx)
1885     : QCborValue(QCborKnownTags::RegularExpression, rx.pattern())
1886 {
1887     // change type
1888     t = RegularExpression;
1889 }
1890 #endif // QT_CONFIG(regularexpression)
1891 
1892 /*!
1893     Creates a QCborValue object of the UUID extended type and containing the
1894     value represented by \a uuid. The value can later be retrieved using
1895     toUuid().
1896 
1897     The CBOR UUID type is an extended type represented by a byte array tagged
1898     as an \l{QCborKnownTags}{Uuid}.
1899 
1900     \sa toUuid(), isUuid(), taggedValue()
1901  */
1902 QCborValue::QCborValue(const QUuid &uuid)
1903     : QCborValue(QCborKnownTags::Uuid, uuid.toRfc4122())
1904 {
1905     // change our type
1906     t = Uuid;
1907 }
1908 
1909 // destructor
1910 void QCborValue::dispose()
1911 {
1912     container->deref();
1913 }
1914 
1915 /*!
1916     Replaces the contents of this QCborObject with a copy of \a other.
1917  */
1918 QCborValue &QCborValue::operator=(const QCborValue &other)
1919 {
1920     if (other.container)
1921         other.container->ref.ref();
1922     if (container)
1923         container->deref();
1924 
1925     n = other.n;
1926     container = other.container;
1927     t = other.t;
1928     return *this;
1929 }
1930 
1931 /*!
1932     Returns the tag of this extended QCborValue object, if it is of the tag
1933     type, \a defaultValue otherwise.
1934 
1935     CBOR represents extended types by associating a number (the tag) with a
1936     stored representation. This function returns that number. To retrieve the
1937     representation, use taggedValue().
1938 
1939     \sa isTag(), taggedValue(), isDateTime(), isUrl(), isRegularExpression(), isUuid()
1940  */
1941 QCborTag QCborValue::tag(QCborTag defaultValue) const
1942 {
1943     return isTag() && container && container->elements.size() == 2 ?
1944                 QCborTag(container->elements.at(0).value) : defaultValue;
1945 }
1946 
1947 /*!
1948     Returns the tagged value of this extended QCborValue object, if it is of
1949     the tag type, \a defaultValue otherwise.
1950 
1951     CBOR represents extended types by associating a number (the tag) with a
1952     stored representation. This function returns that representation. To
1953     retrieve the tag, use tag().
1954 
1955     \sa isTag(), tag(), isDateTime(), isUrl(), isRegularExpression(), isUuid()
1956  */
1957 QCborValue QCborValue::taggedValue(const QCborValue &defaultValue) const
1958 {
1959     return isTag() && container && container->elements.size() == 2 ?
1960                 container->valueAt(1) : defaultValue;
1961 }
1962 
1963 /*!
1964     Returns the byte array value stored in this QCborValue, if it is of the byte
1965     array type. Otherwise, it returns \a defaultValue.
1966 
1967     Note that this function performs no conversion from other types to
1968     QByteArray.
1969 
1970     \sa isByteArray(), isString(), toString()
1971  */
1972 QByteArray QCborValue::toByteArray(const QByteArray &defaultValue) const
1973 {
1974     if (!container || !isByteArray())
1975         return defaultValue;
1976 
1977     Q_ASSERT(n >= 0);
1978     return container->byteArrayAt(n);
1979 }
1980 
1981 /*!
1982     Returns the string value stored in this QCborValue, if it is of the string
1983     type. Otherwise, it returns \a defaultValue.
1984 
1985     Note that this function performs no conversion from other types to
1986     QString.
1987 
1988     \sa isString(), isByteArray(), toByteArray()
1989  */
1990 QString QCborValue::toString(const QString &defaultValue) const
1991 {
1992     if (!container || !isString())
1993         return defaultValue;
1994 
1995     Q_ASSERT(n >= 0);
1996     return container->stringAt(n);
1997 }
1998 
1999 /*!
2000     Returns the date/time value stored in this QCborValue, if it is of the
2001     date/time extended type. Otherwise, it returns \a defaultValue.
2002 
2003     Note that this function performs no conversion from other types to
2004     QDateTime.
2005 
2006     \sa isDateTime(), isTag(), taggedValue()
2007  */
2008 QDateTime QCborValue::toDateTime(const QDateTime &defaultValue) const
2009 {
2010     if (!container || !isDateTime() || container->elements.size() != 2)
2011         return defaultValue;
2012 
2013     Q_ASSERT(n == -1);
2014     const ByteData *byteData = container->byteData(1);
2015     if (!byteData)
2016         return defaultValue; // date/times are never empty, so this must be invalid
2017 
2018     // Our data must be US-ASCII.
2019     Q_ASSERT((container->elements.at(1).flags & Element::StringIsUtf16) == 0);
2020     return QDateTime::fromString(byteData->asLatin1(), Qt::ISODateWithMs);
2021 }
2022 
2023 #ifndef QT_BOOTSTRAPPED
2024 /*!
2025     Returns the URL value stored in this QCborValue, if it is of the URL
2026     extended type. Otherwise, it returns \a defaultValue.
2027 
2028     Note that this function performs no conversion from other types to QUrl.
2029 
2030     \sa isUrl(), isTag(), taggedValue()
2031  */
2032 QUrl QCborValue::toUrl(const QUrl &defaultValue) const
2033 {
2034     if (!container || !isUrl() || container->elements.size() != 2)
2035         return defaultValue;
2036 
2037     Q_ASSERT(n == -1);
2038     const ByteData *byteData = container->byteData(1);
2039     if (!byteData)
2040         return QUrl();  // valid, empty URL
2041 
2042     return QUrl::fromEncoded(byteData->asByteArrayView());
2043 }
2044 #endif
2045 
2046 #if QT_CONFIG(regularexpression)
2047 /*!
2048     Returns the regular expression value stored in this QCborValue, if it is of
2049     the regular expression pattern extended type. Otherwise, it returns \a
2050     defaultValue.
2051 
2052     Note that this function performs no conversion from other types to
2053     QRegularExpression.
2054 
2055     \sa isRegularExpression(), isTag(), taggedValue()
2056  */
2057 QRegularExpression QCborValue::toRegularExpression(const QRegularExpression &defaultValue) const
2058 {
2059     if (!container || !isRegularExpression() || container->elements.size() != 2)
2060         return defaultValue;
2061 
2062     Q_ASSERT(n == -1);
2063     return QRegularExpression(container->stringAt(1));
2064 }
2065 #endif // QT_CONFIG(regularexpression)
2066 
2067 /*!
2068     Returns the UUID value stored in this QCborValue, if it is of the UUID
2069     extended type. Otherwise, it returns \a defaultValue.
2070 
2071     Note that this function performs no conversion from other types to QUuid.
2072 
2073     \sa isUuid(), isTag(), taggedValue()
2074  */
2075 QUuid QCborValue::toUuid(const QUuid &defaultValue) const
2076 {
2077     if (!container || !isUuid() || container->elements.size() != 2)
2078         return defaultValue;
2079 
2080     Q_ASSERT(n == -1);
2081     const ByteData *byteData = container->byteData(1);
2082     if (!byteData)
2083         return defaultValue; // UUIDs must always be 16 bytes, so this must be invalid
2084 
2085     return QUuid::fromRfc4122(byteData->asByteArrayView());
2086 }
2087 
2088 /*!
2089     \fn QCborArray QCborValue::toArray() const
2090     \fn QCborArray QCborValue::toArray(const QCborArray &defaultValue) const
2091 
2092     Returns the array value stored in this QCborValue, if it is of the array
2093     type. Otherwise, it returns \a defaultValue.
2094 
2095     Note that this function performs no conversion from other types to
2096     QCborArray.
2097 
2098     \sa isArray(), isByteArray(), isMap(), isContainer(), toMap()
2099  */
2100 
2101 /*!
2102     \fn QCborArray QCborValueRef::toArray() const
2103     \fn QCborArray QCborValueRef::toArray(const QCborArray &defaultValue) const
2104     \internal
2105 
2106     Returns the array value stored in this QCborValue, if it is of the array
2107     type. Otherwise, it returns \a defaultValue.
2108 
2109     Note that this function performs no conversion from other types to
2110     QCborArray.
2111 
2112     \sa isArray(), isByteArray(), isMap(), isContainer(), toMap()
2113  */
2114 QCborArray QCborValue::toArray() const
2115 {
2116     return toArray(QCborArray());
2117 }
2118 
2119 QCborArray QCborValue::toArray(const QCborArray &defaultValue) const
2120 {
2121     if (!isArray())
2122         return defaultValue;
2123     QCborContainerPrivate *dd = nullptr;
2124     Q_ASSERT(n == -1 || container == nullptr);
2125     if (n < 0)
2126         dd = container;
2127     return dd ? QCborArray(*dd) : defaultValue;
2128 }
2129 
2130 /*!
2131     \fn QCborMap QCborValue::toMap() const
2132     \fn QCborMap QCborValue::toMap(const QCborMap &defaultValue) const
2133 
2134     Returns the map value stored in this QCborValue, if it is of the map type.
2135     Otherwise, it returns \a defaultValue.
2136 
2137     Note that this function performs no conversion from other types to
2138     QCborMap.
2139 
2140     \sa isMap(), isArray(), isContainer(), toArray()
2141  */
2142 
2143 /*!
2144     \fn QCborMap QCborValueRef::toMap() const
2145     \fn QCborMap QCborValueRef::toMap(const QCborMap &defaultValue) const
2146     \internal
2147 
2148     Returns the map value stored in this QCborValue, if it is of the map type.
2149     Otherwise, it returns \a defaultValue.
2150 
2151     Note that this function performs no conversion from other types to
2152     QCborMap.
2153 
2154     \sa isMap(), isArray(), isContainer(), toArray()
2155  */
2156 QCborMap QCborValue::toMap() const
2157 {
2158     return toMap(QCborMap());
2159 }
2160 
2161 QCborMap QCborValue::toMap(const QCborMap &defaultValue) const
2162 {
2163     if (!isMap())
2164         return defaultValue;
2165     QCborContainerPrivate *dd = nullptr;
2166     Q_ASSERT(n == -1 || container == nullptr);
2167     if (n < 0)
2168         dd = container;
2169     return dd ? QCborMap(*dd) : defaultValue;
2170 }
2171 
2172 /*!
2173     If this QCborValue is a QCborMap, searches elements for the value whose key
2174     matches \a key. If there's no key matching \a key in the map or if this
2175     QCborValue object is not a map, returns the undefined value.
2176 
2177     This function is equivalent to:
2178 
2179     \snippet code/src_corelib_serialization_qcborvalue.cpp 4
2180 
2181     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2182         QCborMap::find()
2183  */
2184 const QCborValue QCborValue::operator[](const QString &key) const
2185 {
2186     if (isMap())
2187         return toMap().value(key);
2188     return QCborValue();
2189 }
2190 
2191 /*!
2192     \overload
2193 
2194     If this QCborValue is a QCborMap, searches elements for the value whose key
2195     matches \a key. If there's no key matching \a key in the map or if this
2196     QCborValue object is not a map, returns the undefined value.
2197 
2198     This function is equivalent to:
2199 
2200     \snippet code/src_corelib_serialization_qcborvalue.cpp 5
2201 
2202     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2203         QCborMap::find()
2204  */
2205 const QCborValue QCborValue::operator[](QLatin1String key) const
2206 {
2207     if (isMap())
2208         return toMap().value(key);
2209     return QCborValue();
2210 }
2211 
2212 /*!
2213     \overload
2214 
2215     If this QCborValue is a QCborMap, searches elements for the value whose key
2216     matches \a key. If this is a QCborArray, returns the element whose index is
2217     \a key. If there's no matching value in the array or map, or if this
2218     QCborValue object is not an array or map, returns the undefined value.
2219 
2220     \sa operator[], QCborMap::operator[], QCborMap::value(),
2221         QCborMap::find(), QCborArray::operator[], QCborArray::at()
2222  */
2223 const QCborValue QCborValue::operator[](qint64 key) const
2224 {
2225     if (isMap())
2226         return toMap().value(key);
2227     if (isArray())
2228         return toArray().at(key);
2229     return QCborValue();
2230 }
2231 
2232 /*!
2233   \internal
2234  */
2235 static Q_DECL_COLD_FUNCTION QCborMap arrayAsMap(const QCborArray &array)
2236 {
2237     if (array.size())
2238         qWarning("Using CBOR array as map forced conversion");
2239     QCborMap map;
2240     for (qsizetype i = array.size(); i-- > 0; ) {
2241         QCborValue entry = array.at(i);
2242         // Ignore padding entries that may have been added to grow the array
2243         // when inserting past its end:
2244         if (!entry.isInvalid())
2245             map[i] = entry;
2246     }
2247     return map;
2248 }
2249 
2250 /*!
2251   \internal
2252  */
2253 static QCborContainerPrivate *maybeDetach(QCborContainerPrivate *container, qsizetype size)
2254 {
2255     auto replace = QCborContainerPrivate::detach(container, size);
2256     Q_ASSERT(replace);
2257     if (replace != container) {
2258         if (container)
2259             container->deref();
2260         replace->ref.ref();
2261     }
2262     return replace;
2263 }
2264 
2265 /*!
2266   \internal
2267  */
2268 static QCborContainerPrivate *maybeGrow(QCborContainerPrivate *container, qsizetype index)
2269 {
2270     auto replace = QCborContainerPrivate::grow(container, index);
2271     Q_ASSERT(replace);
2272     if (replace != container) {
2273         if (container)
2274             container->deref();
2275         replace->ref.ref();
2276     }
2277     if (replace->elements.size() == index)
2278         replace->append(Undefined());
2279     else
2280         Q_ASSERT(replace->elements.size() > index);
2281     return replace;
2282 }
2283 
2284 /*!
2285     Returns a QCborValueRef that can be used to read or modify the entry in
2286     this, as a map, with the given \a key. When this QCborValue is a QCborMap,
2287     this function is equivalent to the matching operator[] on that map.
2288 
2289     Before returning the reference: if this QCborValue was an array, it is first
2290     converted to a map (so that \c{map[i]} is \c{array[i]} for each index, \c i,
2291     with valid \c{array[i]}); otherwise, if it was not a map it will be
2292     over-written with an empty map.
2293 
2294     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2295         QCborMap::find()
2296  */
2297 QCborValueRef QCborValue::operator[](const QString &key)
2298 {
2299     if (!isMap())
2300         *this = QCborValue(isArray() ? arrayAsMap(toArray()) : QCborMap());
2301 
2302     const qsizetype size = container ? container->elements.size() : 0;
2303     qsizetype index = size + 1;
2304     bool found = false;
2305     if (container) {
2306         QCborMap proxy(*container);
2307         auto it = proxy.constFind(key);
2308         if (it < proxy.constEnd()) {
2309             found = true;
2310             index = it.item.i;
2311         }
2312     }
2313 
2314     container = maybeDetach(container, size + (found ? 0 : 2));
2315     Q_ASSERT(container);
2316     if (!found) {
2317         container->append(key);
2318         container->append(QCborValue());
2319     }
2320     Q_ASSERT(index & 1 && !(container->elements.size() & 1));
2321     Q_ASSERT(index < container->elements.size());
2322     return { container, index };
2323 }
2324 
2325 /*!
2326     \overload
2327 
2328     Returns a QCborValueRef that can be used to read or modify the entry in
2329     this, as a map, with the given \a key. When this QCborValue is a QCborMap,
2330     this function is equivalent to the matching operator[] on that map.
2331 
2332     Before returning the reference: if this QCborValue was an array, it is first
2333     converted to a map (so that \c{map[i]} is \c{array[i]} for each index, \c i,
2334     with valid \c{array[i]}); otherwise, if it was not a map it will be
2335     over-written with an empty map.
2336 
2337     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2338         QCborMap::find()
2339  */
2340 QCborValueRef QCborValue::operator[](QLatin1String key)
2341 {
2342     if (!isMap())
2343         *this = QCborValue(isArray() ? arrayAsMap(toArray()) : QCborMap());
2344 
2345     const qsizetype size = container ? container->elements.size() : 0;
2346     qsizetype index = size + 1;
2347     bool found = false;
2348     if (container) {
2349         QCborMap proxy(*container);
2350         auto it = proxy.constFind(key);
2351         if (it < proxy.constEnd()) {
2352             found = true;
2353             index = it.item.i;
2354         }
2355     }
2356 
2357     container = maybeDetach(container, size + (found ? 0 : 2));
2358     Q_ASSERT(container);
2359     if (!found) {
2360         container->append(key);
2361         container->append(QCborValue());
2362     }
2363     Q_ASSERT(index & 1 && !(container->elements.size() & 1));
2364     Q_ASSERT(index < container->elements.size());
2365     return { container, index };
2366 }
2367 
2368 /*!
2369     \overload
2370 
2371     Returns a QCborValueRef that can be used to read or modify the entry in
2372     this, as a map or array, with the given \a key. When this QCborValue is a
2373     QCborMap or, for 0 <= key < 0x10000, a QCborArray, this function is
2374     equivalent to the matching operator[] on that map or array.
2375 
2376     Before returning the reference: if this QCborValue was an array but the key
2377     is out of range, the array is first converted to a map (so that \c{map[i]}
2378     is \c{array[i]} for each index, \c i, with valid \c{array[i]}); otherwise,
2379     if it was not a map it will be over-written with an empty map.
2380 
2381     \sa operator[], QCborMap::operator[], QCborMap::value(),
2382         QCborMap::find(), QCborArray::operator[], QCborArray::at()
2383  */
2384 QCborValueRef QCborValue::operator[](qint64 key)
2385 {
2386     if (isArray() && key >= 0 && key < 0x10000) {
2387         container = maybeGrow(container, key);
2388         return { container, qsizetype(key) };
2389     }
2390     if (!isMap())
2391         *this = QCborValue(isArray() ? arrayAsMap(toArray()) : QCborMap());
2392 
2393     const qsizetype size = container ? container->elements.size() : 0;
2394     Q_ASSERT(!(size & 1));
2395     qsizetype index = size + 1;
2396     bool found = false;
2397     if (container) {
2398         QCborMap proxy(*container);
2399         auto it = proxy.constFind(key);
2400         if (it < proxy.constEnd()) {
2401             found = true;
2402             index = it.item.i;
2403         }
2404     }
2405 
2406     container = maybeDetach(container, size + (found ? 0 : 2));
2407     Q_ASSERT(container);
2408     if (!found) {
2409         container->append(key);
2410         container->append(QCborValue());
2411     }
2412     Q_ASSERT(index & 1 && !(container->elements.size() & 1));
2413     Q_ASSERT(index < container->elements.size());
2414     return { container, index };
2415 }
2416 
2417 #if QT_CONFIG(cborstreamreader)
2418 enum { MaximumRecursionDepth = 1024 };
2419 
2420 /*!
2421     Decodes one item from the CBOR stream found in \a reader and returns the
2422     equivalent representation. This function is recursive: if the item is a map
2423     or array, it will decode all items found in that map or array, until the
2424     outermost object is finished.
2425 
2426     This function need not be used on the root element of a \l
2427     QCborStreamReader. For example, the following code illustrates how to skip
2428     the CBOR signature tag from the beginning of a file:
2429 
2430     \snippet code/src_corelib_serialization_qcborvalue.cpp 6
2431 
2432     The returned value may be partially complete and indistinguishable from a
2433     valid QCborValue even if the decoding failed. To determine if there was an
2434     error, check if \l{QCborStreamReader::lastError()}{reader.lastError()} is
2435     indicating an error condition. This function stops decoding immediately
2436     after the first error.
2437 
2438     \sa toCbor(), toDiagnosticNotation(), toVariant(), toJsonValue()
2439  */
2440 QCborValue QCborValue::fromCbor(QCborStreamReader &reader)
2441 {
2442     QCborValue result;
2443     auto t = reader.type();
2444     if (reader.lastError() != QCborError::NoError)
2445         t = QCborStreamReader::Invalid;
2446 
2447     switch (t) {
2448     // basic types, no container needed:
2449     case QCborStreamReader::UnsignedInteger:
2450     case QCborStreamReader::NegativeInteger:
2451     case QCborStreamReader::SimpleType:
2452     case QCborStreamReader::Float16:
2453     case QCborStreamReader::Float:
2454     case QCborStreamReader::Double: {
2455         Element e = decodeBasicValueFromCbor(reader);
2456         result.n = e.value;
2457         result.t = e.type;
2458         break;
2459     }
2460 
2461     case QCborStreamReader::Invalid:
2462         result.t = QCborValue::Invalid;
2463         break;              // probably a decode error
2464 
2465     // strings
2466     case QCborStreamReader::ByteArray:
2467     case QCborStreamReader::String:
2468         result.n = 0;
2469         result.t = reader.isString() ? String : ByteArray;
2470         result.container = new QCborContainerPrivate;
2471         result.container->ref.ref();
2472         result.container->decodeStringFromCbor(reader);
2473         break;
2474 
2475     // containers
2476     case QCborStreamReader::Array:
2477     case QCborStreamReader::Map:
2478         result.n = -1;
2479         result.t = reader.isArray() ? Array : Map;
2480         result.container = createContainerFromCbor(reader, MaximumRecursionDepth);
2481         break;
2482 
2483     // tag
2484     case QCborStreamReader::Tag:
2485         result = taggedValueFromCbor(reader, MaximumRecursionDepth);
2486         break;
2487     }
2488 
2489     return result;
2490 }
2491 
2492 /*!
2493     \overload
2494 
2495     Decodes one item from the CBOR stream found in the byte array \a ba and
2496     returns the equivalent representation. This function is recursive: if the
2497     item is a map or array, it will decode all items found in that map or
2498     array, until the outermost object is finished.
2499 
2500     This function stores the error state, if any, in the object pointed to by
2501     \a error, along with the offset of where the error occurred. If no error
2502     happened, it stores \l{QCborError}{NoError} in the error state and the
2503     number of bytes that it consumed (that is, it stores the offset for the
2504     first unused byte). Using that information makes it possible to parse
2505     further data that may exist in the same byte array.
2506 
2507     The returned value may be partially complete and indistinguishable from a
2508     valid QCborValue even if the decoding failed. To determine if there was an
2509     error, check if there was an error stored in \a error. This function stops
2510     decoding immediately after the first error.
2511 
2512     \sa toCbor(), toDiagnosticNotation(), toVariant(), toJsonValue()
2513  */
2514 QCborValue QCborValue::fromCbor(const QByteArray &ba, QCborParserError *error)
2515 {
2516     QCborStreamReader reader(ba);
2517     QCborValue result = fromCbor(reader);
2518     if (error) {
2519         error->error = reader.lastError();
2520         error->offset = reader.currentOffset();
2521     }
2522     return result;
2523 }
2524 
2525 /*!
2526     \fn QCborValue QCborValue::fromCbor(const char *data, qsizetype len, QCborParserError *error)
2527     \fn QCborValue QCborValue::fromCbor(const quint8 *data, qsizetype len, QCborParserError *error)
2528     \overload
2529 
2530     Converts \a len bytes of \a data to a QByteArray and then calls the
2531     overload of this function that accepts a QByteArray, also passing \a error,
2532     if provided.
2533 */
2534 #endif // QT_CONFIG(cborstreamreader)
2535 
2536 #if QT_CONFIG(cborstreamwriter)
2537 /*!
2538     Encodes this QCborValue object to its CBOR representation, using the
2539     options specified in \a opt, and return the byte array containing that
2540     representation.
2541 
2542     This function will not fail, except if this QCborValue or any of the
2543     contained items, if this is a map or array, are invalid. Invalid types are
2544     not produced normally by the API, but can result from decoding errors.
2545 
2546     By default, this function performs no transformation on the values in the
2547     QCborValue, writing all floating point directly as double-precision (\c
2548     double) types. If the \l{EncodingOption}{UseFloat} option is specified, it
2549     will use single precision (\c float) for any floating point value for which
2550     there's no loss of precision in using that representation. That includes
2551     infinities and NaN values.
2552 
2553     Similarly, if \l{EncodingOption}{UseFloat16} is specified, this function
2554     will try to use half-precision (\c qfloat16) floating point if the
2555     conversion to that results in no loss of precision. This is always true for
2556     infinities and NaN.
2557 
2558     If \l{EncodingOption}{UseIntegers} is specified, it will use integers for
2559     any floating point value that contains an actual integer.
2560 
2561     \sa fromCbor(), fromVariant(), fromJsonValue()
2562  */
2563 QByteArray QCborValue::toCbor(EncodingOptions opt) const
2564 {
2565     QByteArray result;
2566     QCborStreamWriter writer(&result);
2567     toCbor(writer, opt);
2568     return result;
2569 }
2570 
2571 /*!
2572     \overload
2573 
2574     Encodes this QCborValue object to its CBOR representation, using the
2575     options specified in \a opt, to the writer specified by \a writer. The same
2576     writer can be used by multiple QCborValues, for example, in order to encode
2577     different elements in a larger array.
2578 
2579     This function will not fail, except if this QCborValue or any of the
2580     contained items, if this is a map or array, are invalid. Invalid types are
2581     not produced normally by the API, but can result from decoding errors.
2582 
2583     By default, this function performs no transformation on the values in the
2584     QCborValue, writing all floating point directly as double-precision
2585     (binary64) types. If the \l{EncodingOption}{UseFloat} option is
2586     specified, it will use single precision (binary32) for any floating point
2587     value for which there's no loss of precision in using that representation.
2588     That includes infinities and NaN values.
2589 
2590     Similarly, if \l{EncodingOption}{UseFloat16} is specified, this function
2591     will try to use half-precision (binary16) floating point if the conversion
2592     to that results in no loss of precision. This is always true for infinities
2593     and NaN.
2594 
2595     If \l{EncodingOption}{UseIntegers} is specified, it will use integers
2596     for any floating point value that contains an actual integer.
2597 
2598     \sa fromCbor(), fromVariant(), fromJsonValue()
2599  */
2600 Q_NEVER_INLINE void QCborValue::toCbor(QCborStreamWriter &writer, EncodingOptions opt) const
2601 {
2602     if (isContainer() || isTag())
2603         return encodeToCbor(writer, container, -type(), opt);
2604     if (container)
2605         return encodeToCbor(writer, container, n, opt);
2606 
2607     // very simple types
2608     if (isSimpleType())
2609         return writer.append(toSimpleType());
2610 
2611     switch (type()) {
2612     case Integer:
2613         return writer.append(n);
2614 
2615     case Double:
2616         return writeDoubleToCbor(writer, fp_helper(), opt);
2617 
2618     case Invalid:
2619         return;
2620 
2621     case SimpleType:
2622     case False:
2623     case True:
2624     case Null:
2625     case Undefined:
2626         // handled by "if (isSimpleType())"
2627         Q_UNREACHABLE();
2628         break;
2629 
2630     case ByteArray:
2631         // Byte array with no container is empty
2632         return writer.appendByteString("", 0);
2633 
2634     case String:
2635         // String with no container is empty
2636         return writer.appendTextString("", 0);
2637 
2638     case Array:
2639     case Map:
2640     case Tag:
2641         // handled by "if (isContainer() || isTag())"
2642         Q_UNREACHABLE();
2643         break;
2644 
2645     case DateTime:
2646     case Url:
2647     case RegularExpression:
2648     case Uuid:
2649         // not possible
2650         Q_UNREACHABLE();
2651         break;
2652     }
2653 }
2654 
2655 void QCborValueRef::toCbor(QCborStreamWriter &writer, QCborValue::EncodingOptions opt)
2656 {
2657     concrete().toCbor(writer, opt);
2658 }
2659 #endif // QT_CONFIG(cborstreamwriter)
2660 
2661 void QCborValueRef::assign(QCborValueRef that, const QCborValue &other)
2662 {
2663     that.d->replaceAt(that.i, other);
2664 }
2665 
2666 void QCborValueRef::assign(QCborValueRef that, QCborValue &&other)
2667 {
2668     that.d->replaceAt(that.i, other, QCborContainerPrivate::MoveContainer);
2669 }
2670 
2671 void QCborValueRef::assign(QCborValueRef that, const QCborValueRef other)
2672 {
2673     // ### optimize?
2674     that = other.concrete();
2675 }
2676 
2677 QCborValue QCborValueRef::concrete(QCborValueRef self) noexcept
2678 {
2679     return self.d->valueAt(self.i);
2680 }
2681 
2682 QCborValue::Type QCborValueRef::concreteType(QCborValueRef self) noexcept
2683 {
2684     return self.d->elements.at(self.i).type;
2685 }
2686 
2687 /*!
2688     If this QCborValueRef refers to a QCborMap, searches elements for the value
2689     whose key matches \a key. If there's no key matching \a key in the map or if
2690     this QCborValueRef object is not a map, returns the undefined value.
2691 
2692     This function is equivalent to:
2693 
2694     \code
2695       value.toMap().value(key);
2696     \endcode
2697 
2698     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2699         QCborMap::find()
2700  */
2701 const QCborValue QCborValueRef::operator[](const QString &key) const
2702 {
2703     const QCborValue item = d->valueAt(i);
2704     return item[key];
2705 }
2706 
2707 /*!
2708     \overload
2709 
2710     If this QCborValueRef refers to a QCborMap, searches elements for the value
2711     whose key matches \a key. If there's no key matching \a key in the map or if
2712     this QCborValueRef object is not a map, returns the undefined value.
2713 
2714     This function is equivalent to:
2715 
2716     \code
2717       value.toMap().value(key);
2718     \endcode
2719 
2720     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2721         QCborMap::find()
2722  */
2723 const QCborValue QCborValueRef::operator[](QLatin1String key) const
2724 {
2725     const QCborValue item = d->valueAt(i);
2726     return item[key];
2727 }
2728 
2729 /*!
2730    \overload
2731 
2732     If this QCborValueRef refers to a QCborMap, searches elements for the value
2733     whose key matches \a key. If this is a QCborArray, returns the element whose
2734     index is \a key. If there's no matching value in the array or map, or if
2735     this QCborValueRef object is not an array or map, returns the undefined
2736     value.
2737 
2738     \sa operator[], QCborMap::operator[], QCborMap::value(),
2739         QCborMap::find(), QCborArray::operator[], QCborArray::at()
2740  */
2741 const QCborValue QCborValueRef::operator[](qint64 key) const
2742 {
2743     const QCborValue item = d->valueAt(i);
2744     return item[key];
2745 }
2746 
2747 /*!
2748     Returns a QCborValueRef that can be used to read or modify the entry in
2749     this, as a map, with the given \a key. When this QCborValueRef refers to a
2750     QCborMap, this function is equivalent to the matching operator[] on that
2751     map.
2752 
2753     Before returning the reference: if the QCborValue referenced was an array,
2754     it is first converted to a map (so that \c{map[i]} is \c{array[i]} for each
2755     index, \c i, with valid \c{array[i]}); otherwise, if it was not a map it
2756     will be over-written with an empty map.
2757 
2758     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2759         QCborMap::find()
2760  */
2761 QCborValueRef QCborValueRef::operator[](const QString &key)
2762 {
2763     auto &e = d->elements[i];
2764     qsizetype size = 0;
2765     if (e.flags & QtCbor::Element::IsContainer) {
2766         if (e.container) {
2767             if (e.type == QCborValue::Array) {
2768                 QCborValue repack = QCborValue(arrayAsMap(QCborArray(*e.container)));
2769                 qSwap(e.container, repack.container);
2770             } else if (e.type != QCborValue::Map) {
2771                 e.container->deref();
2772                 e.container = nullptr;
2773             }
2774         }
2775         e.type = QCborValue::Map;
2776         if (e.container)
2777             size = e.container->elements.size();
2778     } else {
2779         // Stomp any prior e.value, replace with a map (that we'll grow)
2780         e.container = nullptr;
2781         e.type = QCborValue::Map;
2782         e.flags = QtCbor::Element::IsContainer;
2783     }
2784 
2785     qsizetype index = size + 1;
2786     bool found = false;
2787     if (e.container) {
2788         QCborMap proxy(*e.container);
2789         auto it = proxy.constFind(key);
2790         if (it < proxy.constEnd()) {
2791             found = true;
2792             index = it.item.i;
2793         }
2794     }
2795 
2796     e.container = maybeDetach(e.container, size + (found ? 0 : 2));
2797     Q_ASSERT(e.container);
2798     if (!found) {
2799         e.container->append(key);
2800         e.container->append(QCborValue());
2801     }
2802     Q_ASSERT(index & 1 && !(e.container->elements.size() & 1));
2803     Q_ASSERT(index < e.container->elements.size());
2804     return { e.container, index };
2805 }
2806 
2807 /*!
2808     \overload
2809 
2810     Returns a QCborValueRef that can be used to read or modify the entry in
2811     this, as a map, with the given \a key. When this QCborValue is a QCborMap,
2812     this function is equivalent to the matching operator[] on that map.
2813 
2814     Before returning the reference: if the QCborValue referenced was an array,
2815     it is first converted to a map (so that \c{map[i]} is \c{array[i]} for each
2816     index, \c i, with valid \c{array[i]}); otherwise, if it was not a map it
2817     will be over-written with an empty map.
2818 
2819     \sa operator[](qint64), QCborMap::operator[], QCborMap::value(),
2820         QCborMap::find()
2821  */
2822 QCborValueRef QCborValueRef::operator[](QLatin1String key)
2823 {
2824     auto &e = d->elements[i];
2825     qsizetype size = 0;
2826     if (e.flags & QtCbor::Element::IsContainer) {
2827         if (e.container) {
2828             if (e.type == QCborValue::Array) {
2829                 QCborValue repack = QCborValue(arrayAsMap(QCborArray(*e.container)));
2830                 qSwap(e.container, repack.container);
2831             } else if (e.type != QCborValue::Map) {
2832                 e.container->deref();
2833                 e.container = nullptr;
2834             }
2835         }
2836         e.type = QCborValue::Map;
2837         if (e.container)
2838             size = e.container->elements.size();
2839     } else {
2840         // Stomp any prior e.value, replace with a map (that we'll grow)
2841         e.container = nullptr;
2842         e.type = QCborValue::Map;
2843         e.flags = QtCbor::Element::IsContainer;
2844     }
2845 
2846     qsizetype index = size + 1;
2847     bool found = false;
2848     if (e.container) {
2849         QCborMap proxy(*e.container);
2850         auto it = proxy.constFind(key);
2851         if (it < proxy.constEnd()) {
2852             found = true;
2853             index = it.item.i;
2854         }
2855     }
2856 
2857     e.container = maybeDetach(e.container, size + (found ? 0 : 2));
2858     Q_ASSERT(e.container);
2859     if (!found) {
2860         e.container->append(key);
2861         e.container->append(QCborValue());
2862     }
2863     Q_ASSERT(index & 1 && !(e.container->elements.size() & 1));
2864     Q_ASSERT(index < e.container->elements.size());
2865     return { e.container, index };
2866 }
2867 
2868 /*!
2869     \overload
2870 
2871     Returns a QCborValueRef that can be used to read or modify the entry in
2872     this, as a map or array, with the given \a key. When this QCborValue is a
2873     QCborMap or, for 0 <= key < 0x10000, a QCborArray, this function is
2874     equivalent to the matching operator[] on that map or array.
2875 
2876     Before returning the reference: if the QCborValue referenced was an array
2877     but the key is out of range, the array is first converted to a map (so that
2878     \c{map[i]} is \c{array[i]} for each index, \c i, with valid \c{array[i]});
2879     otherwise, if it was not a map it will be over-written with an empty map.
2880 
2881     \sa operator[], QCborMap::operator[], QCborMap::value(),
2882         QCborMap::find(), QCborArray::operator[], QCborArray::at()
2883  */
2884 QCborValueRef QCborValueRef::operator[](qint64 key)
2885 {
2886     auto &e = d->elements[i];
2887     if (e.type == QCborValue::Array && key >= 0 && key < 0x10000) {
2888         e.container = maybeGrow(e.container, key);
2889         return { e.container, qsizetype(key) };
2890     }
2891     qsizetype size = 0;
2892     if (e.flags & QtCbor::Element::IsContainer) {
2893         if (e.container) {
2894             if (e.type == QCborValue::Array) {
2895                 QCborValue repack = QCborValue(arrayAsMap(QCborArray(*e.container)));
2896                 qSwap(e.container, repack.container);
2897             } else if (e.type != QCborValue::Map) {
2898                 e.container->deref();
2899                 e.container = nullptr;
2900             }
2901         }
2902         e.type = QCborValue::Map;
2903         if (e.container)
2904             size = e.container->elements.size();
2905     } else {
2906         // Stomp any prior e.value, replace with a map (that we'll grow)
2907         e.container = nullptr;
2908         e.type = QCborValue::Map;
2909         e.flags = QtCbor::Element::IsContainer;
2910     }
2911     Q_ASSERT(!(size & 1));
2912 
2913     qsizetype index = size + 1;
2914     bool found = false;
2915     if (e.container) {
2916         QCborMap proxy(*e.container);
2917         auto it = proxy.constFind(key);
2918         if (it < proxy.constEnd()) {
2919             found = true;
2920             index = it.item.i;
2921         }
2922     }
2923 
2924     e.container = maybeDetach(e.container, size + (found ? 0 : 2));
2925     Q_ASSERT(e.container);
2926     if (!found) {
2927         e.container->append(key);
2928         e.container->append(QCborValue());
2929     }
2930     Q_ASSERT(index & 1 && !(e.container->elements.size() & 1));
2931     Q_ASSERT(index < e.container->elements.size());
2932     return { e.container, index };
2933 }
2934 
2935 
2936 inline QCborArray::QCborArray(QCborContainerPrivate &dd) noexcept
2937     : d(&dd)
2938 {
2939 }
2940 
2941 inline QCborMap::QCborMap(QCborContainerPrivate &dd) noexcept
2942     : d(&dd)
2943 {
2944 }
2945 
2946 size_t qHash(const QCborValue &value, size_t seed)
2947 {
2948     switch (value.type()) {
2949     case QCborValue::Integer:
2950         return qHash(value.toInteger(), seed);
2951     case QCborValue::ByteArray:
2952         return qHash(value.toByteArray(), seed);
2953     case QCborValue::String:
2954         return qHash(value.toString(), seed);
2955     case QCborValue::Array:
2956         return qHash(value.toArray(), seed);
2957     case QCborValue::Map:
2958         return qHash(value.toMap(), seed);
2959     case QCborValue::Tag: {
2960         QtPrivate::QHashCombine hash;
2961         seed = hash(seed, value.tag());
2962         seed = hash(seed, value.taggedValue());
2963         return seed;
2964     }
2965     case QCborValue::SimpleType:
2966         break;
2967     case QCborValue::False:
2968         return qHash(false, seed);
2969     case QCborValue::True:
2970         return qHash(true, seed);
2971     case QCborValue::Null:
2972         return qHash(nullptr, seed);
2973     case QCborValue::Undefined:
2974         return seed;
2975     case QCborValue::Double:
2976         return qHash(value.toDouble(), seed);
2977     case QCborValue::DateTime:
2978         return qHash(value.toDateTime(), seed);
2979 #ifndef QT_BOOTSTRAPPED
2980     case QCborValue::Url:
2981         return qHash(value.toUrl(), seed);
2982 #endif
2983 #if QT_CONFIG(regularexpression)
2984     case QCborValue::RegularExpression:
2985         return qHash(value.toRegularExpression(), seed);
2986 #endif
2987     case QCborValue::Uuid:
2988         return qHash(value.toUuid(), seed);
2989     case QCborValue::Invalid:
2990         return seed;
2991     default:
2992         break;
2993     }
2994 
2995     Q_ASSERT(value.isSimpleType());
2996     return qHash(value.toSimpleType(), seed);
2997 }
2998 
2999 Q_CORE_EXPORT const char *qt_cbor_simpletype_id(QCborSimpleType st)
3000 {
3001     switch (st) {
3002     case QCborSimpleType::False:
3003         return "False";
3004     case QCborSimpleType::True:
3005         return "True";
3006     case QCborSimpleType::Null:
3007         return "Null";
3008     case QCborSimpleType::Undefined:
3009         return "Undefined";
3010     }
3011     return nullptr;
3012 }
3013 
3014 Q_CORE_EXPORT const char *qt_cbor_tag_id(QCborTag tag)
3015 {
3016     // Casting to QCborKnownTags's underlying type will make the comparison
3017     // below fail if the tag value is out of range.
3018     auto n = std::underlying_type<QCborKnownTags>::type(tag);
3019     if (QCborTag(n) == tag) {
3020         switch (QCborKnownTags(n)) {
3021         case QCborKnownTags::DateTimeString:
3022             return "DateTimeString";
3023         case QCborKnownTags::UnixTime_t:
3024             return "UnixTime_t";
3025         case QCborKnownTags::PositiveBignum:
3026             return "PositiveBignum";
3027         case QCborKnownTags::NegativeBignum:
3028             return "NegativeBignum";
3029         case QCborKnownTags::Decimal:
3030             return "Decimal";
3031         case QCborKnownTags::Bigfloat:
3032             return "Bigfloat";
3033         case QCborKnownTags::COSE_Encrypt0:
3034             return "COSE_Encrypt0";
3035         case QCborKnownTags::COSE_Mac0:
3036             return "COSE_Mac0";
3037         case QCborKnownTags::COSE_Sign1:
3038             return "COSE_Sign1";
3039         case QCborKnownTags::ExpectedBase64url:
3040             return "ExpectedBase64url";
3041         case QCborKnownTags::ExpectedBase64:
3042             return "ExpectedBase64";
3043         case QCborKnownTags::ExpectedBase16:
3044             return "ExpectedBase16";
3045         case QCborKnownTags::EncodedCbor:
3046             return "EncodedCbor";
3047         case QCborKnownTags::Url:
3048             return "Url";
3049         case QCborKnownTags::Base64url:
3050             return "Base64url";
3051         case QCborKnownTags::Base64:
3052             return "Base64";
3053         case QCborKnownTags::RegularExpression:
3054             return "RegularExpression";
3055         case QCborKnownTags::MimeMessage:
3056             return "MimeMessage";
3057         case QCborKnownTags::Uuid:
3058             return "Uuid";
3059         case QCborKnownTags::COSE_Encrypt:
3060             return "COSE_Encrypt";
3061         case QCborKnownTags::COSE_Mac:
3062             return "COSE_Mac";
3063         case QCborKnownTags::COSE_Sign:
3064             return "COSE_Sign";
3065         case QCborKnownTags::Signature:
3066             return "Signature";
3067         }
3068     }
3069     return nullptr;
3070 }
3071 
3072 #if !defined(QT_NO_DEBUG_STREAM)
3073 static QDebug debugContents(QDebug &dbg, const QCborValue &v)
3074 {
3075     switch (v.type()) {
3076     case QCborValue::Integer:
3077         return dbg << v.toInteger();
3078     case QCborValue::ByteArray:
3079         return dbg << "QByteArray(" << v.toByteArray() << ')';
3080     case QCborValue::String:
3081         return dbg << v.toString();
3082     case QCborValue::Array:
3083         return dbg << v.toArray();
3084     case QCborValue::Map:
3085         return dbg << v.toMap();
3086     case QCborValue::Tag: {
3087         QCborTag tag = v.tag();
3088         const char *id = qt_cbor_tag_id(tag);
3089         if (id)
3090             dbg.nospace() << "QCborKnownTags::" << id << ", ";
3091         else
3092             dbg.nospace() << "QCborTag(" << quint64(tag) << "), ";
3093         return dbg << v.taggedValue();
3094     }
3095     case QCborValue::SimpleType:
3096         break;
3097     case QCborValue::True:
3098         return dbg << true;
3099     case QCborValue::False:
3100         return dbg << false;
3101     case QCborValue::Null:
3102         return dbg << "nullptr";
3103     case QCborValue::Undefined:
3104         return dbg;
3105     case QCborValue::Double: {
3106         qint64 i;
3107         if (convertDoubleTo(v.toDouble(), &i))
3108             return dbg << i << ".0";
3109         else
3110             return dbg << v.toDouble();
3111     }
3112     case QCborValue::DateTime:
3113         return dbg << v.toDateTime();
3114 #ifndef QT_BOOTSTRAPPED
3115     case QCborValue::Url:
3116         return dbg << v.toUrl();
3117 #if QT_CONFIG(regularexpression)
3118     case QCborValue::RegularExpression:
3119         return dbg << v.toRegularExpression();
3120 #endif
3121     case QCborValue::Uuid:
3122         return dbg << v.toUuid();
3123 #endif
3124     case QCborValue::Invalid:
3125         return dbg << "<invalid>";
3126     default:
3127         break;
3128     }
3129     if (v.isSimpleType())
3130         return dbg << v.toSimpleType();
3131     return dbg << "<unknown type 0x" << Qt::hex << int(v.type()) << Qt::dec << '>';
3132 }
3133 QDebug operator<<(QDebug dbg, const QCborValue &v)
3134 {
3135     QDebugStateSaver saver(dbg);
3136     dbg.nospace() << "QCborValue(";
3137     return debugContents(dbg, v) << ')';
3138 }
3139 
3140 QDebug operator<<(QDebug dbg, QCborSimpleType st)
3141 {
3142     QDebugStateSaver saver(dbg);
3143     const char *id = qt_cbor_simpletype_id(st);
3144     if (id)
3145         return dbg.nospace() << "QCborSimpleType::" << id;
3146 
3147     return dbg.nospace() << "QCborSimpleType(" << uint(st) << ')';
3148 }
3149 
3150 QDebug operator<<(QDebug dbg, QCborTag tag)
3151 {
3152     QDebugStateSaver saver(dbg);
3153     const char *id = qt_cbor_tag_id(tag);
3154     dbg.nospace() << "QCborTag(";
3155     if (id)
3156         dbg.nospace() << "QCborKnownTags::" << id;
3157     else
3158         dbg.nospace() << quint64(tag);
3159 
3160     return dbg << ')';
3161 }
3162 
3163 QDebug operator<<(QDebug dbg, QCborKnownTags tag)
3164 {
3165     QDebugStateSaver saver(dbg);
3166     const char *id = qt_cbor_tag_id(QCborTag(int(tag)));
3167     if (id)
3168         return dbg.nospace() << "QCborKnownTags::" << id;
3169 
3170     return dbg.nospace() << "QCborKnownTags(" << int(tag) << ')';
3171 }
3172 #endif
3173 
3174 #ifndef QT_NO_DATASTREAM
3175 #if QT_CONFIG(cborstreamwriter)
3176 QDataStream &operator<<(QDataStream &stream, const QCborValue &value)
3177 {
3178     stream << QCborValue(value).toCbor();
3179     return stream;
3180 }
3181 #endif
3182 
3183 QDataStream &operator>>(QDataStream &stream, QCborValue &value)
3184 {
3185     QByteArray buffer;
3186     stream >> buffer;
3187     QCborParserError parseError{};
3188     value = QCborValue::fromCbor(buffer, &parseError);
3189     if (parseError.error)
3190         stream.setStatus(QDataStream::ReadCorruptData);
3191     return stream;
3192 }
3193 #endif
3194 
3195 
3196 QT_END_NAMESPACE
3197 
3198 #include "qcborarray.cpp"
3199 #include "qcbormap.cpp"
3200 
3201 #ifndef QT_NO_QOBJECT
3202 #include "moc_qcborvalue.cpp"
3203 #endif
