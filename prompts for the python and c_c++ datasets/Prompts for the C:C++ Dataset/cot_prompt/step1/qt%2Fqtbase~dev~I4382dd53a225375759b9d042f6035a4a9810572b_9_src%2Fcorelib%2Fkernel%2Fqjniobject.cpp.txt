Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
Make QJniObject and QJniEnvironment public API

As part of Qt 6 restructring for the extras modules, this change exposes
the Jni APIs which are very important for Android platform. This patch
adds the APIs QJniObject, QJniEnvironment, QJniExceptionCleaner based
from private QtCore and QtAndroidExtras.

The Jni interface is cross-platform which justifies the name, but
currently, this API is used mainly for Android, and the naming comes
generic without Android keyword to avoid any future limitation on
supporting other platforms.

[ChangeLog][QtCore] Add new QJniObject, QJniEnvironment and
QJniExceptionCleaner APIs.

Task-number: QTBUG-89482
Fixes: QTBUG-89633
Change-Id: I4382dd53a225375759b9d042f6035a4a9810572b

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qjnienvironment.h"
41 #include "qjnihelpers_p.h"
42 #include "qjniobject.h"
43 
44 #include <QtCore/QReadWriteLock>
45 #include <QtCore/QHash>
46 
47 QT_BEGIN_NAMESPACE
48 
49 /*!
50     \class QJniObject
51     \inmodule QtCore
52     \brief Provides a convenient set of APIs to call Java code from C++ using the Java Native Interface (JNI).
53     \since 6.1
54 
55     \sa QJniEnvironment
56 
57     \section1 General Notes
58 
59     \list
60         \li Class names needs to contain the fully-qualified class name, for example: \b"java/lang/String".
61         \li Method signatures are written as \b"(Arguments)ReturnType"
62         \li All object types are returned as a QJniObject.
63     \endlist
64 
65     \note This API has been tested mainly for Android.
66 
67     \section1 Method Signatures
68 
69     For functions that take no arguments, QJniObject provides convenience functions that will use
70     the correct signature based on the provided template type. For example:
71 
72     \code
73     jint x = QJniObject::callMethod<jint>("getSize");
74     QJniObject::callMethod<void>("touch");
75     \endcode
76 
77     In other cases you will need to supply the signature yourself, and it is important that the
78     signature matches the function you want to call. The signature structure is \b \(A\)R, where \b A
79     is the type of the argument\(s\) and \b R is the return type. Array types in the signature must
80     have the \b\[ suffix and the fully-qualified type names must have the \b L prefix and \b ; suffix.
81 
82     The example below demonstrates how to call two different static functions.
83     \code
84     // Java class
85     package org.qtproject.qt;
86     class TestClass
87     {
88        static String fromNumber(int x) { ... }
89        static String[] stringArray(String s1, String s2) { ... }
90     }
91     \endcode
92 
93     The signature for the first function is \b"\(I\)Ljava/lang/String;"
94 
95     \code
96     // C++ code
97     QJniObject stringNumber = QJniObject::callStaticObjectMethod("org/qtproject/qt/TestClass",
98                                                                                "fromNumber"
99                                                                                "(I)Ljava/lang/String;",
100                                                                                10);
101     \endcode
102 
103     and the signature for the second function is \b"\(Ljava/lang/String;Ljava/lang/String;\)\[Ljava/lang/String;"
104 
105     \code
106     // C++ code
107     QJniObject string1 = QJniObject::fromString("String1");
108     QJniObject string2 = QJniObject::fromString("String2");
109     QJniObject stringArray = QJniObject::callStaticObjectMethod("org/qtproject/qt/TestClass",
110                                                                               "stringArray"
111                                                                               "(Ljava/lang/String;Ljava/lang/String;)[Ljava/lang/String;"
112                                                                                string1.object<jstring>(),
113                                                                                string2.object<jstring>());
114     \endcode
115 
116 
117     \section1 Handling Java Exception
118 
119     When calling Java functions that might throw an exception, it is important that you check, handle
120     and clear out the exception before continuing.
121 
122     \note It is unsafe to make a JNI call when there are exceptions pending.
123 
124     \snippet jni/src_qjJniobject.cpp Check for exceptions
125 
126     \section1 Java Native Methods
127 
128     Java native methods makes it possible to call native code from Java, this is done by creating a
129     function declaration in Java and prefixing it with the \b native keyword.
130     Before a native function can be called from Java, you need to map the Java native function to a
131     native function in your code. Mapping functions can be done by calling the RegisterNatives() function
132     through the \l{QJniEnvironment}{JNI environment pointer}.
133 
134     The example below demonstrates how this could be done.
135 
136     Java implementation:
137     \snippet jni/src_qjniobject.cpp Java native methods
138 
139     C++ Implementation:
140     \snippet jni/src_qjniobject.cpp Registering native methods
141 
142     \section1 The Lifetime of a Java Object
143 
144     Most \l{Object types}{objects} received from Java will be local references and will only stay valid
145     in the scope you received them. After that, the object becomes eligible for garbage collection. If you
146     want to keep a Java object alive you need to either create a new global reference to the object and
147     release it when you are done, or construct a new QJniObject and let it manage the lifetime of the Java object.
148     \sa object()
149 
150     \note The QJniObject does only manage its own references, if you construct a QJniObject from a
151           global or local reference that reference will not be released by the QJniObject.
152 
153     \section1 JNI Types
154 
155     \section2 Object Types
156     \table
157     \header
158         \li Type
159         \li Signature
160     \row
161         \li jobject
162         \li Ljava/lang/Object;
163     \row
164         \li jclass
165         \li Ljava/lang/Class;
166     \row
167         \li jstring
168         \li Ljava/lang/String;
169     \row
170         \li jthrowable
171         \li Ljava/lang/Throwable;
172     \row
173         \li jobjectArray
174         \li [Ljava/lang/Object;
175     \row
176         \li jarray
177         \li [\e<type>
178     \row
179         \li jbooleanArray
180         \li [Z
181     \row
182         \li jbyteArray
183         \li [B
184     \row
185         \li jcharArray
186         \li [C
187     \row
188         \li jshortArray
189         \li [S
190     \row
191         \li jintArray
192         \li [I
193     \row
194         \li jlongArray
195         \li [J
196     \row
197         \li jfloatArray
198         \li [F
199     \row
200         \li jdoubleArray
201         \li [D
202     \endtable
203 
204     \section2 Primitive Types
205     \table
206     \header
207         \li Type
208         \li Signature
209     \row
210         \li jboolean
211         \li Z
212     \row
213         \li jbyte
214         \li B
215     \row
216         \li jchar
217         \li C
218     \row
219        \li jshort
220        \li S
221     \row
222         \li jint
223         \li I
224     \row
225         \li jlong
226         \li J
227     \row
228         \li jfloat
229         \li F
230     \row
231         \li jdouble
232         \li D
233     \endtable
234 
235     \section3 Other
236     \table
237     \header
238         \li Type
239         \li Signature
240     \row
241         \li void
242         \li V
243     \row
244         \li \e{Custom type}
245         \li L\e<fully-qualified-name>;
246     \endtable
247 
248     For more information about JNI see: \l http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html
249 */
250 
251 /*!
252     \fn bool operator==(const QJniObject &o1, const QJniObject &o2)
253 
254     \relates QJniObject
255 
256     Returns true if both objects, \a o1 and \a o2, are referencing the same Java object, or if both
257     are NULL. In any other cases false will be returned.
258 */
259 
260 /*!
261     \fn bool operator!=(const QJniObject &o1, const QJniObject &o2)
262     \relates QJniObject
263 
264     Returns true if \a o1 holds a reference to a different object than \a o2.
265 */
266 
267 static inline QLatin1String keyBase()
268 {
269     return QLatin1String("%1%2:%3");
270 }
271 
272 static QString qt_convertJString(jstring string)
273 {
274     QJniEnvironment env;
275     int strLength = env->GetStringLength(string);
276     QString res(strLength, Qt::Uninitialized);
277     env->GetStringRegion(string, 0, strLength, reinterpret_cast<jchar *>(res.data()));
278     return res;
279 }
280 
281 static inline bool exceptionCheckAndClear(JNIEnv *env)
282 {
283     if (Q_UNLIKELY(env->ExceptionCheck())) {
284         env->ExceptionDescribe();
285         env->ExceptionClear();
286         return true;
287     }
288 
289     return false;
290 }
291 
292 typedef QHash<QString, jclass> JClassHash;
293 Q_GLOBAL_STATIC(JClassHash, cachedClasses)
294 Q_GLOBAL_STATIC(QReadWriteLock, cachedClassesLock)
295 
296 static QByteArray toBinaryEncClassName(const QByteArray &className)
297 {
298     return QByteArray(className).replace('/', '.');
299 }
300 
301 static jclass getCachedClass(const QByteArray &classBinEnc, bool *isCached = nullptr)
302 {
303     QReadLocker locker(cachedClassesLock);
304     const QHash<QString, jclass>::const_iterator &it = cachedClasses->constFind(QString::fromLatin1(classBinEnc));
305     const bool found = (it != cachedClasses->constEnd());
306 
307     if (isCached != 0)
308         *isCached = found;
309 
310     return found ? it.value() : 0;
311 }
312 
313 inline static jclass loadClass(const QByteArray &className, JNIEnv *env, bool binEncoded = false)
314 {
315     const QByteArray &binEncClassName = binEncoded ? className : toBinaryEncClassName(className);
316 
317     bool isCached = false;
318     jclass clazz = getCachedClass(binEncClassName, &isCached);
319     if (clazz != 0 || isCached)
320         return clazz;
321 
322     QJniObject classLoader(QtAndroidPrivate::classLoader());
323     if (!classLoader.isValid())
324         return 0;
325 
326     QWriteLocker locker(cachedClassesLock);
327     // did we lose the race?
328     const QLatin1String key(binEncClassName);
329     const QHash<QString, jclass>::const_iterator &it = cachedClasses->constFind(key);
330     if (it != cachedClasses->constEnd())
331         return it.value();
332 
333     QJniObject stringName = QJniObject::fromString(key);
334     QJniObject classObject = classLoader.callObjectMethod("loadClass",
335                                                           "(Ljava/lang/String;)Ljava/lang/Class;",
336                                                           stringName.object());
337 
338     if (!exceptionCheckAndClear(env) && classObject.isValid())
339         clazz = static_cast<jclass>(env->NewGlobalRef(classObject.object()));
340 
341     cachedClasses->insert(key, clazz);
342     return clazz;
343 }
344 
345 typedef QHash<QString, jmethodID> JMethodIDHash;
346 Q_GLOBAL_STATIC(JMethodIDHash, cachedMethodID)
347 Q_GLOBAL_STATIC(QReadWriteLock, cachedMethodIDLock)
348 
349 static inline jmethodID getMethodID(JNIEnv *env,
350                                     jclass clazz,
351                                     const char *name,
352                                     const char *sig,
353                                     bool isStatic = false)
354 {
355     jmethodID id = isStatic ? env->GetStaticMethodID(clazz, name, sig)
356                             : env->GetMethodID(clazz, name, sig);
357 
358     if (exceptionCheckAndClear(env))
359         return 0;
360 
361     return id;
362 }
363 
364 static jmethodID getCachedMethodID(JNIEnv *env,
365                                    jclass clazz,
366                                    const QByteArray &className,
367                                    const char *name,
368                                    const char *sig,
369                                    bool isStatic = false)
370 {
371     if (className.isEmpty())
372         return getMethodID(env, clazz, name, sig, isStatic);
373 
374     const QString key = keyBase().arg(QLatin1String(className), QLatin1String(name), QLatin1String(sig));
375     QHash<QString, jmethodID>::const_iterator it;
376 
377     {
378         QReadLocker locker(cachedMethodIDLock);
379         it = cachedMethodID->constFind(key);
380         if (it != cachedMethodID->constEnd())
381             return it.value();
382     }
383 
384     {
385         QWriteLocker locker(cachedMethodIDLock);
386         it = cachedMethodID->constFind(key);
387         if (it != cachedMethodID->constEnd())
388             return it.value();
389 
390         jmethodID id = getMethodID(env, clazz, name, sig, isStatic);
391 
392         cachedMethodID->insert(key, id);
393         return id;
394     }
395 }
396 
397 typedef QHash<QString, jfieldID> JFieldIDHash;
398 Q_GLOBAL_STATIC(JFieldIDHash, cachedFieldID)
399 Q_GLOBAL_STATIC(QReadWriteLock, cachedFieldIDLock)
400 
401 static inline jfieldID getFieldID(JNIEnv *env,
402                                   jclass clazz,
403                                   const char *name,
404                                   const char *sig,
405                                   bool isStatic = false)
406 {
407     jfieldID id = isStatic ? env->GetStaticFieldID(clazz, name, sig)
408                            : env->GetFieldID(clazz, name, sig);
409 
410     if (exceptionCheckAndClear(env))
411         return 0;
412 
413     return id;
414 }
415 
416 static jfieldID getCachedFieldID(JNIEnv *env,
417                                  jclass clazz,
418                                  const QByteArray &className,
419                                  const char *name,
420                                  const char *sig,
421                                  bool isStatic = false)
422 {
423     if (className.isNull())
424         return getFieldID(env, clazz, name, sig, isStatic);
425 
426     const QString key = keyBase().arg(QLatin1String(className), QLatin1String(name), QLatin1String(sig));
427     QHash<QString, jfieldID>::const_iterator it;
428 
429     {
430         QReadLocker locker(cachedFieldIDLock);
431         it = cachedFieldID->constFind(key);
432         if (it != cachedFieldID->constEnd())
433             return it.value();
434     }
435 
436     {
437         QWriteLocker locker(cachedFieldIDLock);
438         it = cachedFieldID->constFind(key);
439         if (it != cachedFieldID->constEnd())
440             return it.value();
441 
442         jfieldID id = getFieldID(env, clazz, name, sig, isStatic);
443 
444         cachedFieldID->insert(key, id);
445         return id;
446     }
447 }
448 
449 jclass QtAndroidPrivate::findClass(const char *className, JNIEnv *env)
450 {
451     const QByteArray &classDotEnc = toBinaryEncClassName(className);
452     bool isCached = false;
453     jclass clazz = getCachedClass(classDotEnc, &isCached);
454 
455     const bool found = (clazz != 0) || (clazz == 0 && isCached);
456 
457     if (found)
458         return clazz;
459 
460     const QLatin1String key(classDotEnc);
461     if (env != 0) { // We got an env. pointer (We expect this to be the right env. and call FindClass())
462         QWriteLocker locker(cachedClassesLock);
463         const QHash<QString, jclass>::const_iterator &it = cachedClasses->constFind(key);
464         // Did we lose the race?
465         if (it != cachedClasses->constEnd())
466             return it.value();
467 
468         jclass fclazz = env->FindClass(className);
469         if (!exceptionCheckAndClear(env)) {
470             clazz = static_cast<jclass>(env->NewGlobalRef(fclazz));
471             env->DeleteLocalRef(fclazz);
472         }
473 
474         if (clazz != 0)
475             cachedClasses->insert(key, clazz);
476     }
477 
478     if (clazz == 0) // We didn't get an env. pointer or we got one with the WRONG class loader...
479         clazz = loadClass(classDotEnc, QJniEnvironment(), true);
480 
481     return clazz;
482 }
483 
484 class QJniObjectPrivate
485 {
486 public:
487     QJniObjectPrivate() = default;
488     ~QJniObjectPrivate() {
489         QJniEnvironment env;
490         if (m_jobject)
491             env->DeleteGlobalRef(m_jobject);
492         if (m_jclass && m_own_jclass)
493             env->DeleteGlobalRef(m_jclass);
494     }
495 
496     jobject m_jobject = nullptr;
497     jclass m_jclass = nullptr;
498     bool m_own_jclass = true;
499     QByteArray m_className;
500 };
501 
502 /*!
503     \fn QJniObject::QJniObject()
504 
505     Constructs an invalid QJniObject.
506 
507     \sa isValid()
508 */
509 QJniObject::QJniObject()
510     : d(new QJniObjectPrivate())
511 {
512 }
513 
514 /*!
515     \fn QJniObject::QJniObject(const char *className)
516 
517     Constructs a new QJniObject by calling the default constructor of \a className.
518 
519     \code
520     QJniObject myJavaString("java/lang/String");
521     \endcode
522 */
523 QJniObject::QJniObject(const char *className)
524     : d(new QJniObjectPrivate())
525 {
526     QJniEnvironment env;
527     d->m_className = toBinaryEncClassName(className);
528     d->m_jclass = loadClass(d->m_className, env, true);
529     d->m_own_jclass = false;
530     if (d->m_jclass) {
531         // get default constructor
532         jmethodID constructorId = getCachedMethodID(env, d->m_jclass, d->m_className, "<init>", "()V");
533         if (constructorId) {
534             jobject obj = env->NewObject(d->m_jclass, constructorId);
535             if (obj) {
536                 d->m_jobject = env->NewGlobalRef(obj);
537                 env->DeleteLocalRef(obj);
538             }
539         }
540     }
541 }
542 
543 /*!
544     \fn QJniObject::QJniObject(const char *className, const char *signature, ...)
545 
546     Constructs a new QJniObject by calling the constructor of \a className with \a signature
547     and arguments.
548 
549     \code
550     QJniEnvironment env;
551     char* str = "Hello";
552     jstring myJStringArg = env->NewStringUTF(str);
553     QJniObject myNewJavaString("java/lang/String", "(Ljava/lang/String;)V", myJStringArg);
554     \endcode
555 */
556 QJniObject::QJniObject(const char *className, const char *sig, ...)
557     : d(new QJniObjectPrivate())
558 {
559     QJniEnvironment env;
560     d->m_className = toBinaryEncClassName(className);
561     d->m_jclass = loadClass(d->m_className, env, true);
562     d->m_own_jclass = false;
563     if (d->m_jclass) {
564         jmethodID constructorId = getCachedMethodID(env, d->m_jclass, d->m_className, "<init>", sig);
565         if (constructorId) {
566             va_list args;
567             va_start(args, sig);
568             jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
569             va_end(args);
570             if (obj) {
571                 d->m_jobject = env->NewGlobalRef(obj);
572                 env->DeleteLocalRef(obj);
573             }
574         }
575     }
576 }
577 
578 QJniObject::QJniObject(const char *className, const char *sig, const QVaListPrivate &args)
579     : d(new QJniObjectPrivate())
580 {
581     QJniEnvironment env;
582     d->m_className = toBinaryEncClassName(className);
583     d->m_jclass = loadClass(d->m_className, env, true);
584     d->m_own_jclass = false;
585     if (d->m_jclass) {
586         jmethodID constructorId = getCachedMethodID(env, d->m_jclass, d->m_className, "<init>", sig);
587         if (constructorId) {
588             jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
589             if (obj) {
590                 d->m_jobject = env->NewGlobalRef(obj);
591                 env->DeleteLocalRef(obj);
592             }
593         }
594     }
595 }
596 
597 /*!
598     \fn QJniObject::QJniObject(jclass clazz, const char *signature, ...)
599 
600     Constructs a new QJniObject from \a clazz by calling the constructor with \a signature
601     and arguments.
602 
603     \code
604     QJniEnvironment env;
605     jclass myClazz = env.findClass("org/qtproject/qt/TestClass");
606     QJniObject(myClazz, "(I)V", 3);
607     \endcode
608 */
609 QJniObject::QJniObject(jclass clazz, const char *sig, ...)
610     : d(new QJniObjectPrivate())
611 {
612     QJniEnvironment env;
613     if (clazz) {
614         d->m_jclass = static_cast<jclass>(env->NewGlobalRef(clazz));
615         if (d->m_jclass) {
616             jmethodID constructorId = getMethodID(env, d->m_jclass, "<init>", sig);
617             if (constructorId) {
618                 va_list args;
619                 va_start(args, sig);
620                 jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
621                 va_end(args);
622                 if (obj) {
623                     d->m_jobject = env->NewGlobalRef(obj);
624                     env->DeleteLocalRef(obj);
625                 }
626             }
627         }
628     }
629 }
630 
631 /*!
632     \fn QJniObject::QJniObject(jclass clazz)
633 
634     Constructs a new QJniObject by calling the default constructor of \a clazz.
635 
636     Note: The QJniObject will create a new reference to the class \a clazz
637           and releases it again when it is destroyed. References to the class created
638           outside the QJniObject needs to be managed by the caller.
639 */
640 
641 QJniObject::QJniObject(jclass clazz)
642     : d(new QJniObjectPrivate())
643 {
644     QJniEnvironment env;
645     d->m_jclass = static_cast<jclass>(env->NewGlobalRef(clazz));
646     if (d->m_jclass) {
647         // get default constructor
648         jmethodID constructorId = getMethodID(env, d->m_jclass, "<init>", "()V");
649         if (constructorId) {
650             jobject obj = env->NewObject(d->m_jclass, constructorId);
651             if (obj) {
652                 d->m_jobject = env->NewGlobalRef(obj);
653                 env->DeleteLocalRef(obj);
654             }
655         }
656     }
657 }
658 
659 QJniObject::QJniObject(jclass clazz, const char *sig, const QVaListPrivate &args)
660     : d(new QJniObjectPrivate())
661 {
662     QJniEnvironment env;
663     if (clazz) {
664         d->m_jclass = static_cast<jclass>(env->NewGlobalRef(clazz));
665         if (d->m_jclass) {
666             jmethodID constructorId = getMethodID(env, d->m_jclass, "<init>", sig);
667             if (constructorId) {
668                 jobject obj = env->NewObjectV(d->m_jclass, constructorId, args);
669                 if (obj) {
670                     d->m_jobject = env->NewGlobalRef(obj);
671                     env->DeleteLocalRef(obj);
672                 }
673             }
674         }
675     }
676 }
677 
678 /*!
679     \fn QJniObject::QJniObject(jobject object)
680 
681     Constructs a new QJniObject around the Java object \a object.
682 
683     \note The QJniObject will hold a reference to the Java object \a object
684     and release it when destroyed. Any references to the Java object \a object
685     outside QJniObject needs to be managed by the caller. In most cases you
686     should never call this function with a local reference unless you intend
687     to manage the local reference yourself. See QJniObject::fromLocalRef()
688     for converting a local reference to a QJniObject.
689 
690     \sa fromLocalRef()
691 */
692 QJniObject::QJniObject(jobject obj)
693     : d(new QJniObjectPrivate())
694 {
695     if (!obj)
696         return;
697 
698     QJniEnvironment env;
699     d->m_jobject = env->NewGlobalRef(obj);
700     jclass cls = env->GetObjectClass(obj);
701     d->m_jclass = static_cast<jclass>(env->NewGlobalRef(cls));
702     env->DeleteLocalRef(cls);
703 }
704 
705 /*!
706     \fn QJniObject::~QJniObject()
707 
708     Destroys the QJniObject and releases any references held by the QJniObject.
709 */
710 QJniObject::~QJniObject()
711 {}
712 
713 /*!
714     \fn template <typename T> T QJniObject::object() const
715 
716     Returns the object held by the QJniObject as type T.
717 
718     \code
719     QJniObject string = QJniObject::fromString("Hello, JNI");
720     jstring jstring = string.object<jstring>();
721     \endcode
722 
723     \note The returned object is still owned by the QJniObject. If you want to keep the object valid
724     you should create a new QJniObject or make a new global reference to the object and
725     free it yourself.
726 
727     \snippet jni/src_qjniobject.cpp QJniObject scope
728 
729     \code
730     jobject object = jniObject.object();
731     \endcode
732 */
733 Q_CORE_EXPORT jobject QJniObject::object() const
734 {
735     return javaObject();
736 }
737 
738 QJniObject QJniObject::callObjectMethodV(const char *methodName,
739                                          const char *sig,
740                                          va_list args) const
741 {
742     QJniEnvironment env;
743     jobject res = 0;
744     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
745     if (id) {
746         res = env->CallObjectMethodV(d->m_jobject, id, args);
747         if (res && env->ExceptionCheck())
748             res = 0;
749     }
750 
751     QJniObject obj(res);
752     env->DeleteLocalRef(res);
753     return obj;
754 }
755 
756 QJniObject QJniObject::callStaticObjectMethodV(const char *className,
757                                                const char *methodName,
758                                                const char *sig,
759                                                va_list args)
760 {
761     QJniEnvironment env;
762     jobject res = 0;
763     jclass clazz = loadClass(className, env);
764     if (clazz) {
765         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName, sig, true);
766         if (id) {
767             res = env->CallStaticObjectMethodV(clazz, id, args);
768             if (res && env->ExceptionCheck())
769                 res = 0;
770         }
771     }
772 
773     QJniObject obj(res);
774     env->DeleteLocalRef(res);
775     return obj;
776 }
777 
778 QJniObject QJniObject::callStaticObjectMethodV(jclass clazz,
779                                                const char *methodName,
780                                                const char *sig,
781                                                va_list args)
782 {
783     QJniEnvironment env;
784     jobject res = 0;
785     jmethodID id = getMethodID(env, clazz, methodName, sig, true);
786     if (id) {
787         res = env->CallStaticObjectMethodV(clazz, id, args);
788         if (res && env->ExceptionCheck())
789             res = 0;
790     }
791 
792     QJniObject obj(res);
793     env->DeleteLocalRef(res);
794     return obj;
795 }
796 
797 /*!
798     \fn template <typename T> T QJniObject::callMethod(const char *methodName, const char *sig, ...) const
799 
800     Calls the method \a  methodName with a signature \a sig and returns the value.
801 
802     \code
803     QJniObject myJavaString = ...;
804     jint index = myJavaString.callMethod<jint>("indexOf", "(I)I", 0x0051);
805     \endcode
806 
807 */
808 template <>
809 Q_CORE_EXPORT void QJniObject::callMethod<void>(const char *methodName, const char *sig, ...) const
810 {
811     QJniEnvironment env;
812     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
813     if (id) {
814         va_list args;
815         va_start(args, sig);
816         env->CallVoidMethodV(d->m_jobject, id, args);
817         va_end(args);
818     }
819 }
820 
821 /*!
822     \fn template <typename T> T QJniObject::callMethod(const char *methodName) const
823 
824     Calls the method \a methodName and returns the value.
825 
826     \code
827     QJniObject myJavaString = ...;
828     jint size = myJavaString.callMethod<jint>("length");
829     \endcode
830 */
831 template <>
832 Q_CORE_EXPORT void QJniObject::callMethod<void>(const char *methodName) const
833 {
834     callMethod<void>(methodName, "()V");
835 }
836 
837 /*!
838     \fn template <typename T> T QJniObject::callStaticMethod(const char *className, const char *methodName, const char *signature, ...)
839 
840     Calls the static method with \a methodName with \a signature on class \a className with optional arguments.
841 
842     \code
843     ...
844     jint a = 2;
845     jint b = 4;
846     jint max = QJniObject::callStaticMethod<jint>("java/lang/Math", "max", "(II)I", a, b);
847     ...
848     \endcode
849 */
850 template <>
851 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(const char *className,
852                                                       const char *methodName,
853                                                       const char *sig,
854                                                       ...)
855 {
856     QJniEnvironment env;
857     jclass clazz = loadClass(className, env);
858     if (clazz) {
859         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className),
860                                          methodName, sig, true);
861         if (id) {
862             va_list args;
863             va_start(args, sig);
864             env->CallStaticVoidMethodV(clazz, id, args);
865             va_end(args);
866         }
867     }
868 }
869 
870 /*!
871     \fn template <typename T> T QJniObject::callStaticMethod(const char *className, const char *methodName)
872 
873     Calls the static method \a methodName on class \a className and returns the value.
874 
875     \code
876     jint value = QJniObject::callStaticMethod<jint>("MyClass", "staticMethod");
877     \endcode
878 */
879 template <>
880 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(const char *className, const char *methodName)
881 {
882     callStaticMethod<void>(className, methodName, "()V");
883 }
884 
885 /*!
886     \fn template <typename T> T QJniObject::callStaticMethod(jclass clazz, const char *methodName, const char *signature, ...)
887 
888     Calls the static method \a methodName with \a signature on \a clazz and returns the value.
889 
890     \code
891     ...
892     jclass javaMathClass = ...; // ("java/lang/Math")
893     jint a = 2;
894     jint b = 4;
895     jint max = QJniObject::callStaticMethod<jint>(javaMathClass, "max", "(II)I", a, b);
896     ...
897     \endcode
898 */
899 template <>
900 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(jclass clazz,
901                                                       const char *methodName,
902                                                       const char *sig,
903                                                       ...)
904 {
905     QJniEnvironment env;
906     if (clazz) {
907         jmethodID id = getMethodID(env, clazz, methodName, sig, true);
908         if (id) {
909             va_list args;
910             va_start(args, sig);
911             env->CallStaticVoidMethodV(clazz, id, args);
912             va_end(args);
913         }
914     }
915 }
916 
917 template <>
918 Q_CORE_EXPORT void QJniObject::callStaticMethodV<void>(const char *className,
919                                                        const char *methodName,
920                                                        const char *sig,
921                                                        va_list args)
922 {
923     QJniEnvironment env;
924     jclass clazz = loadClass(className, env);
925     if (clazz) {
926         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName,
927                                          sig, true);
928         if (id) {
929             env->CallStaticVoidMethodV(clazz, id, args);
930         }
931     }
932 }
933 
934 template <>
935 Q_CORE_EXPORT void QJniObject::callStaticMethodV<void>(jclass clazz,
936                                                        const char *methodName,
937                                                        const char *sig,
938                                                        va_list args)
939 {
940     QJniEnvironment env;
941     jmethodID id = getMethodID(env, clazz, methodName, sig, true);
942     if (id) {
943         env->CallStaticVoidMethodV(clazz, id, args);
944     }
945 }
946 
947 /*!
948     \fn template <typename T> T QJniObject::callStaticMethod(jclass clazz, const char *methodName)
949 
950     Calls the static method \a methodName on \a clazz and returns the value.
951 
952     \code
953     ...
954     jclass javaMathClass = ...; // ("java/lang/Math")
955     jdouble randNr = QJniObject::callStaticMethod<jdouble>(javaMathClass, "random");
956     ...
957     \endcode
958 */
959 template <>
960 Q_CORE_EXPORT void QJniObject::callStaticMethod<void>(jclass clazz, const char *methodName)
961 {
962     callStaticMethod<void>(clazz, methodName, "()V");
963 }
964 
965 template <>
966 Q_CORE_EXPORT void QJniObject::callMethodV<void>(const char *methodName, const char *sig,
967                                                  va_list args) const
968 {
969     QJniEnvironment env;
970     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
971     if (id) {
972         env->CallVoidMethodV(d->m_jobject, id, args);
973     }
974 }
975 #define MAKE_JNI_METHODS(MethodName, Type, Signature) \
976 template <> Q_CORE_EXPORT Type QJniObject::callMethod<Type>(const char *methodName, \
977                                                                    const char *sig, ...) const \
978 { \
979     QJniEnvironment env; \
980     Type res = 0; \
981     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig); \
982     if (id) { \
983         va_list args; \
984         va_start(args, sig); \
985         res = env->Call##MethodName##MethodV(d->m_jobject, id, args); \
986         va_end(args); \
987     } \
988     return res; \
989 }\
990 template <> Q_CORE_EXPORT Type QJniObject::callMethod<Type>(const char *methodName) const \
991 { \
992     return callMethod<Type>(methodName, Signature); \
993 } \
994 \
995 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(const char *className, \
996                                                                   const char *methodName, \
997                                                                   const char *sig, \
998                                                                   ...) \
999 { \
1000     QJniEnvironment env; \
1001     Type res = 0; \
1002     jclass clazz = loadClass(className, env); \
1003     if (clazz) { \
1004         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName, \
1005                                          sig, true); \
1006         if (id) { \
1007             va_list args; \
1008             va_start(args, sig); \
1009             res = env->CallStatic##MethodName##MethodV(clazz, id, args); \
1010             va_end(args); \
1011         } \
1012     } \
1013     return res; \
1014 } \
1015 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(const char *className, \
1016                                                                   const char *methodName) \
1017 { \
1018     return callStaticMethod<Type>(className, methodName, Signature); \
1019 }\
1020 \
1021 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(jclass clazz, \
1022                                                                   const char *methodName, \
1023                                                                   const char *sig, \
1024                                                                   ...) \
1025 { \
1026     QJniEnvironment env; \
1027     Type res = 0; \
1028     if (clazz) { \
1029         jmethodID id = getMethodID(env, clazz, methodName, sig, true); \
1030         if (id) { \
1031             va_list args; \
1032             va_start(args, sig); \
1033             res = env->CallStatic##MethodName##MethodV(clazz, id, args); \
1034             va_end(args); \
1035         } \
1036     } \
1037     return res; \
1038 } \
1039 template <> Q_CORE_EXPORT Type QJniObject::callStaticMethod<Type>(jclass clazz, \
1040                                                                   const char *methodName) \
1041 { \
1042     return callStaticMethod<Type>(clazz, methodName, Signature); \
1043 }\
1044 template <> \
1045 Q_CORE_EXPORT Type QJniObject::callMethodV<Type>(const char *methodName, const char *sig,\
1046                                                  va_list args) const\
1047 {\
1048     QJniEnvironment env;\
1049     Type res = 0;\
1050     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);\
1051     if (id) {\
1052         res = env->Call##MethodName##MethodV(d->m_jobject, id, args);\
1053     }\
1054     return res;\
1055 }\
1056 template <>\
1057 Q_CORE_EXPORT Type QJniObject::callStaticMethodV<Type>(const char *className,\
1058                                                      const char *methodName,\
1059                                                      const char *sig,\
1060                                                      va_list args)\
1061 {\
1062     QJniEnvironment env;\
1063     Type res = 0;\
1064     jclass clazz = loadClass(className, env);\
1065     if (clazz) {\
1066         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName,\
1067                                          sig, true);\
1068         if (id) {\
1069             res = env->CallStatic##MethodName##MethodV(clazz, id, args);\
1070         }\
1071     }\
1072     return res;\
1073 }\
1074 template <>\
1075 Q_CORE_EXPORT Type QJniObject::callStaticMethodV<Type>(jclass clazz,\
1076                                                      const char *methodName,\
1077                                                      const char *sig,\
1078                                                      va_list args)\
1079 {\
1080     QJniEnvironment env;\
1081     Type res = 0;\
1082     jmethodID id = getMethodID(env, clazz, methodName, sig, true);\
1083     if (id) {\
1084         res = env->CallStatic##MethodName##MethodV(clazz, id, args);\
1085     }\
1086     return res;\
1087 }
1088 
1089 #define DECLARE_JNI_METHODS(MethodName, Type, Signature) MAKE_JNI_METHODS(MethodName, \
1090                                                                           Type, \
1091                                                                           Signature)
1092 DECLARE_JNI_METHODS(Boolean, jboolean, "()Z")
1093 DECLARE_JNI_METHODS(Byte, jbyte, "()B")
1094 DECLARE_JNI_METHODS(Char, jchar, "()C")
1095 DECLARE_JNI_METHODS(Short, jshort, "()S")
1096 DECLARE_JNI_METHODS(Int, jint, "()I")
1097 DECLARE_JNI_METHODS(Long, jlong, "()J")
1098 DECLARE_JNI_METHODS(Float, jfloat, "()F")
1099 DECLARE_JNI_METHODS(Double, jdouble, "()D")
1100 
1101 /*!
1102     \fn QJniObject QJniObject::callObjectMethod(const char *methodName, const char *signature, ...) const
1103 
1104     Calls the Java object's method \a methodName with the signature \a signature and arguments
1105 
1106     \code
1107     QJniObject myJavaString; ==> "Hello, Java"
1108     QJniObject mySubstring = myJavaString.callObjectMethod("substring", "(II)Ljava/lang/String;", 7, 10);
1109     \endcode
1110 */
1111 QJniObject QJniObject::callObjectMethod(const char *methodName, const char *sig, ...) const
1112 {
1113     QJniEnvironment env;
1114     jobject res = nullptr;
1115     jmethodID id = getCachedMethodID(env, d->m_jclass, d->m_className, methodName, sig);
1116     if (id) {
1117         va_list args;
1118         va_start(args, sig);
1119         res = env->CallObjectMethodV(d->m_jobject, id, args);
1120         va_end(args);
1121         if (res && env->ExceptionCheck())
1122             res = 0;
1123     }
1124     QJniObject obj(res);
1125     env->DeleteLocalRef(res);
1126     return obj;
1127 }
1128 
1129 /*!
1130     \fn QJniObject QJniObject::callStaticObjectMethod(const char *className, const char *methodName, const char *signature, ...)
1131 
1132     Calls the static method with \a methodName and \a signature on the class \a className.
1133 
1134     \code
1135     QJniObject thread = QJniObject::callStaticObjectMethod("java/lang/Thread", "currentThread", "()Ljava/lang/Thread;");
1136     QJniObject string = QJniObject::callStaticObjectMethod("java/lang/String", "valueOf", "(I)Ljava/lang/String;", 10);
1137     \endcode
1138 */
1139 QJniObject QJniObject::callStaticObjectMethod(const char *className,
1140                                               const char *methodName,
1141                                               const char *sig,
1142                                               ...)
1143 {
1144     QJniEnvironment env;
1145     jobject res = nullptr;
1146     jclass clazz = loadClass(className, env);
1147     if (clazz) {
1148         jmethodID id = getCachedMethodID(env, clazz, toBinaryEncClassName(className), methodName,
1149                                          sig, true);
1150         if (id) {
1151             va_list args;
1152             va_start(args, sig);
1153             res = env->CallStaticObjectMethodV(clazz, id, args);
1154             va_end(args);
1155             if (res && env->ExceptionCheck())
1156                 res = nullptr;
1157         }
1158     }
1159     QJniObject obj(res);
1160     env->DeleteLocalRef(res);
1161     return obj;
1162 }
1163 
1164 /*!
1165     \fn QJniObject QJniObject::callStaticObjectMethod(jclass clazz, const char *methodName, const char *signature, ...)
1166 
1167     Calls the static method with \a methodName and \a signature on class \a clazz.
1168 */
1169 QJniObject QJniObject::callStaticObjectMethod(jclass clazz,
1170                                               const char *methodName,
1171                                               const char *sig,
1172                                               ...)
1173 {
1174     QJniEnvironment env;
1175     jobject res = nullptr;
1176     if (clazz) {
1177         jmethodID id = getMethodID(env, clazz, methodName, sig, true);
1178         if (id) {
1179             va_list args;
1180             va_start(args, sig);
1181             res = env->CallStaticObjectMethodV(clazz, id, args);
1182             va_end(args);
1183             if (res && env->ExceptionCheck())
1184                 res = nullptr;
1185         }
1186     }
1187     QJniObject obj(res);
1188     env->DeleteLocalRef(res);
1189     return obj;
1190 }
1191 
1192 /*!
1193     \fn QJniObject QJniObject::callObjectMethod(const char *methodName) const
1194 
1195     Calls the Java objects method \a methodName and returns a new QJniObject for
1196     the returned Java object.
1197 
1198     \code
1199     ...
1200     QJniObject myJavaString1 = ...;
1201     QJniObject myJavaString2 = myJavaString1.callObjectMethod<jstring>("toString");
1202     ...
1203     \endcode
1204 */
1205 
1206 /*!
1207     \fn QJniObject QJniObject::callStaticObjectMethod(const char *className, const char *methodName)
1208 
1209     Calls the static method with \a methodName on the class \a className.
1210 
1211     \code
1212     QJniObject string = QJniObject::callStaticObjectMethod<jstring>("CustomClass", "getClassName");
1213     \endcode
1214 */
1215 
1216 /*!
1217     \fn QJniObject QJniObject::callStaticObjectMethod(jclass clazz, const char *methodName)
1218 
1219     Calls the static method with \a methodName on \a clazz.
1220 
1221 */
1222 
1223 /*!
1224     \fn template <typename T> QJniObject &QJniObject::operator=(T object)
1225 
1226     Replace the current object with \a object. The old Java object will be released.
1227 */
1228 #define MAKE_JNI_OBJECT_METHODS(Type, Signature) \
1229 template <> \
1230 Q_CORE_EXPORT QJniObject QJniObject::callObjectMethod<Type>(const char *methodName) const \
1231 { \
1232     return callObjectMethod(methodName, Signature); \
1233 } \
1234 template <> \
1235 Q_CORE_EXPORT QJniObject QJniObject::callStaticObjectMethod<Type>(const char *className, \
1236                                                                   const char *methodName) \
1237 { \
1238     return callStaticObjectMethod(className, methodName, Signature); \
1239 } \
1240 template <> \
1241 Q_CORE_EXPORT QJniObject QJniObject::callStaticObjectMethod<Type>(jclass clazz, \
1242                                                                   const char *methodName) \
1243 { \
1244     return callStaticObjectMethod(clazz, methodName, Signature); \
1245 }\
1246 template <>\
1247 Q_CORE_EXPORT Type QJniObject::object<Type>() const\
1248 {\
1249     return static_cast<Type>(javaObject());\
1250 }\
1251 template <>\
1252 Q_CORE_EXPORT QJniObject &QJniObject::operator=(Type obj)\
1253 {\
1254     assign(static_cast<jobject>(obj));\
1255     return *this;\
1256 }
1257 
1258 #define DECLARE_JNI_OBJECT_METHODS(Type, Signature) MAKE_JNI_OBJECT_METHODS(Type, Signature)
1259 
1260 DECLARE_JNI_OBJECT_METHODS(jobject, "()Ljava/lang/Object;")
1261 DECLARE_JNI_OBJECT_METHODS(jclass, "()Ljava/lang/Class;")
1262 DECLARE_JNI_OBJECT_METHODS(jstring, "()Ljava/lang/String;")
1263 DECLARE_JNI_OBJECT_METHODS(jobjectArray, "()[Ljava/lang/Object;")
1264 DECLARE_JNI_OBJECT_METHODS(jbooleanArray, "()[Z")
1265 DECLARE_JNI_OBJECT_METHODS(jbyteArray, "()[B")
1266 DECLARE_JNI_OBJECT_METHODS(jshortArray, "()[S")
1267 DECLARE_JNI_OBJECT_METHODS(jintArray, "()[I")
1268 DECLARE_JNI_OBJECT_METHODS(jlongArray, "()[J")
1269 DECLARE_JNI_OBJECT_METHODS(jfloatArray, "()[F")
1270 DECLARE_JNI_OBJECT_METHODS(jdoubleArray, "()[D")
1271 DECLARE_JNI_OBJECT_METHODS(jcharArray, "()[C")
1272 DECLARE_JNI_OBJECT_METHODS(jthrowable, "()Ljava/lang/Throwable;")
1273 
1274 /*!
1275     \fn template <typename T> void QJniObject::setStaticField(const char *className, const char *fieldName, const char *signature, T value);
1276 
1277     Sets the static field with \a fieldName and \a signature to \a value on class named \a className.
1278 */
1279 template <>
1280 Q_CORE_EXPORT void QJniObject::setStaticField<jobject>(const char *className,
1281                                                        const char *fieldName,
1282                                                        const char *sig,
1283                                                        jobject value)
1284 {
1285     QJniEnvironment env;
1286     jclass clazz = loadClass(className, env);
1287     if (!clazz)
1288         return;
1289     jfieldID id = getCachedFieldID(env, clazz, className, fieldName, sig, true);
1290     if (!id)
1291         return;
1292     env->SetStaticObjectField(clazz, id, value);
1293 }
1294 
1295 /*!
1296     \fn template <typename T> void QJniObject::setStaticField(jclass clazz, const char *fieldName, const char *signature, T value);
1297 
1298     Sets the static field with \a fieldName and \a signature to \a value on class \a clazz.
1299 */
1300 template <> Q_CORE_EXPORT void QJniObject::setStaticField<jobject>(jclass clazz,
1301                                                                    const char *fieldName,
1302                                                                    const char *sig,
1303                                                                    jobject value)
1304 {
1305     QJniEnvironment env;
1306     jfieldID id = getFieldID(env, clazz, fieldName, sig, true);
1307     if (id)
1308         env->SetStaticObjectField(clazz, id, value);
1309 }
1310 
1311 /*!
1312     \fn T QJniObject::getField(const char *fieldName) const
1313 
1314     Retrieves the value of the field \a fieldName.
1315 
1316     \code
1317     QJniObject volumeControl = ...;
1318     jint fieldValue = volumeControl.getField<jint>("MAX_VOLUME");
1319     \endcode
1320 */
1321 
1322 /*!
1323     \fn T QJniObject::getStaticField(const char *className, const char *fieldName)
1324 
1325     Retrieves the value from the static field \a fieldName on the class \a className.
1326 */
1327 
1328 /*!
1329     \fn T QJniObject::getStaticField(jclass clazz, const char *fieldName)
1330 
1331     Retrieves the value from the static field \a fieldName on \a clazz.
1332 */
1333 
1334 /*!
1335     \fn template <typename T> void QJniObject::setStaticField(const char *className, const char *fieldName, T value)
1336 
1337     Sets the static field \a fieldName of the class named \a className to \a value.
1338 */
1339 
1340 /*!
1341     \fn template <typename T> void QJniObject::setStaticField(jclass clazz, const char *fieldName, T value)
1342 
1343     Sets the static field \a fieldName of the class \a clazz to \a value.
1344 */
1345 #define MAKE_JNI_PRIMITIVE_FIELDS(FieldName, Type, Signature) \
1346 template <> Q_CORE_EXPORT Type QJniObject::getField<Type>(const char *fieldName) const \
1347 { \
1348     QJniEnvironment env; \
1349     Type res = 0; \
1350     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, Signature); \
1351     if (id) \
1352         res = env->Get##FieldName##Field(d->m_jobject, id); \
1353     return res;\
1354 } \
1355 template <> \
1356 Q_CORE_EXPORT Type QJniObject::getStaticField<Type>(const char *className, const char *fieldName) \
1357 { \
1358     QJniEnvironment env; \
1359     jclass clazz = loadClass(className, env); \
1360     if (!clazz) \
1361         return 0; \
1362     jfieldID id = getCachedFieldID(env, clazz, toBinaryEncClassName(className), fieldName, \
1363                                    Signature, true); \
1364     if (!id) \
1365         return 0; \
1366     return env->GetStatic##FieldName##Field(clazz, id); \
1367 } \
1368 template <>\
1369 Q_CORE_EXPORT Type QJniObject::getStaticField<Type>(jclass clazz, const char *fieldName)\
1370 {\
1371     QJniEnvironment env;\
1372     Type res = 0;\
1373     jfieldID id = getFieldID(env, clazz, fieldName, Signature, true);\
1374     if (id)\
1375         res = env->GetStatic##FieldName##Field(clazz, id);\
1376     return res;\
1377 }\
1378 template <> Q_CORE_EXPORT void QJniObject::setStaticField<Type>(const char *className, \
1379                                                                 const char *fieldName, \
1380                                                                 Type value) \
1381 { \
1382     QJniEnvironment env; \
1383     jclass clazz = loadClass(className, env); \
1384     if (!clazz) \
1385         return; \
1386     jfieldID id = getCachedFieldID(env, clazz, className, fieldName, Signature, true); \
1387     if (!id) \
1388         return; \
1389     env->SetStatic##FieldName##Field(clazz, id, value); \
1390 }\
1391 template <> Q_CORE_EXPORT void QJniObject::setStaticField<Type>(jclass clazz,\
1392                                                                 const char *fieldName,\
1393                                                                 Type value)\
1394 {\
1395     QJniEnvironment env;\
1396     jfieldID id = getFieldID(env, clazz, fieldName, Signature, true);\
1397     if (id)\
1398         env->SetStatic##FieldName##Field(clazz, id, value);\
1399 }\
1400 template <> Q_CORE_EXPORT void QJniObject::setField<Type>(const char *fieldName, Type value) \
1401 { \
1402     QJniEnvironment env; \
1403     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, Signature); \
1404     if (id) \
1405         env->Set##FieldName##Field(d->m_jobject, id, value); \
1406 } \
1407 
1408 #define DECLARE_JNI_PRIMITIVE_FIELDS(FieldName, Type, Signature) MAKE_JNI_PRIMITIVE_FIELDS(FieldName, Type, \
1409                                                                                Signature)
1410 DECLARE_JNI_PRIMITIVE_FIELDS(Boolean, jboolean, "Z")
1411 DECLARE_JNI_PRIMITIVE_FIELDS(Byte, jbyte, "B")
1412 DECLARE_JNI_PRIMITIVE_FIELDS(Char, jchar, "C")
1413 DECLARE_JNI_PRIMITIVE_FIELDS(Short, jshort, "S")
1414 DECLARE_JNI_PRIMITIVE_FIELDS(Int, jint, "I")
1415 DECLARE_JNI_PRIMITIVE_FIELDS(Long, jlong, "J")
1416 DECLARE_JNI_PRIMITIVE_FIELDS(Float, jfloat, "F")
1417 DECLARE_JNI_PRIMITIVE_FIELDS(Double, jdouble, "D")
1418 
1419 /*!
1420     \fn QJniObject QJniObject::getStaticObjectField(const char *className, const char *fieldName, const char *signature)
1421     Retrieves the object from the field with \a signature and \a fieldName on class \a className.
1422 
1423     \note This function can be used without a template type.
1424 
1425     \code
1426     QJniObject jobj = QJniObject::getStaticObjectField("class/with/Fields", "FIELD_NAME", "Ljava/lang/String;");
1427     \endcode
1428 */
1429 QJniObject QJniObject::getStaticObjectField(const char *className,
1430                                             const char *fieldName,
1431                                             const char *sig)
1432 {
1433     QJniEnvironment env;
1434     jclass clazz = loadClass(className, env);
1435     if (!clazz)
1436         return QJniObject();
1437     jfieldID id = getCachedFieldID(env, clazz, toBinaryEncClassName(className), fieldName,
1438                                    sig, true);
1439     if (!id)
1440         return QJniObject();
1441     jobject res = env->GetStaticObjectField(clazz, id);
1442     if (res && env->ExceptionCheck())
1443         res = nullptr;
1444     QJniObject obj(res);
1445     env->DeleteLocalRef(res);
1446     return obj;
1447 }
1448 
1449 /*!
1450     \fn QJniObject QJniObject::getStaticObjectField(jclass clazz, const char *fieldName, const char *signature)
1451     Retrieves the object from the field with \a signature and \a fieldName on \a clazz.
1452 
1453     \note This function can be used without a template type.
1454 
1455     \code
1456     QJniObject jobj = QJniObject::getStaticObjectField(clazz, "FIELD_NAME", "Ljava/lang/String;");
1457     \endcode
1458 */
1459 QJniObject QJniObject::getStaticObjectField(jclass clazz,
1460                                             const char *fieldName,
1461                                             const char *sig)
1462 {
1463     QJniEnvironment env;
1464     jobject res = 0;
1465     jfieldID id = getFieldID(env, clazz, fieldName, sig, true);
1466     if (id) {
1467         res = env->GetStaticObjectField(clazz, id);
1468         if (res && env->ExceptionCheck())
1469             res = 0;
1470     }
1471 
1472     QJniObject obj(res);
1473     env->DeleteLocalRef(res);
1474     return obj;
1475 }
1476 
1477 /*!
1478     \fn QJniObject QJniObject::getStaticObjectField<jobject>(jclass clazz, const char *fieldName, const char *signature)
1479 
1480     Retrieves the \a jobject from the field with \a signature and \a fieldName on \a clazz.
1481 */
1482 template <>
1483 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobject>(jclass clazz,
1484                                                                    const char *fieldName,
1485                                                                    const char *sig)
1486 {
1487     return getStaticObjectField(clazz, fieldName, sig);
1488 }
1489 
1490 /*!
1491     \fn QJniObject QJniObject::getStaticObjectField<jobject>(jclass clazz, const char *fieldName, const char *signature)
1492 
1493     Retrieves the jobject from the field with \a signature and \a fieldName on class named \a className.
1494 */
1495 template <>
1496 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobject>(const char *className,
1497                                                                    const char *fieldName,
1498                                                                    const char *sig)
1499 {
1500     return getStaticObjectField(className, fieldName, sig);
1501 }
1502 
1503 /*!
1504     \fn QJniObject QJniObject::getStaticObjectField<jobjectArray>(jclass clazz, const char *fieldName, const char *signature)
1505 
1506     Retrieves the jobjectArray from the field with \a signature and \a fieldName on \a clazz.
1507 */
1508 template <>
1509 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobjectArray>(jclass clazz,
1510                                                                         const char *fieldName,
1511                                                                         const char *sig)
1512 {
1513     return getStaticObjectField(clazz, fieldName, sig);
1514 }
1515 
1516 /*!
1517     \fn QJniObject QJniObject::getStaticObjectField<jobjectArray>(jclass clazz, const char *fieldName, const char *signature)
1518 
1519     Retrieves the jobjectArray from the field with \a signature and \a fieldName on the class named \a className.
1520 */
1521 template <>
1522 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<jobjectArray>(const char *className,
1523                                                                         const char *fieldName,
1524                                                                         const char *sig)
1525 {
1526     return getStaticObjectField(className, fieldName, sig);
1527 }
1528 
1529 /*!
1530     \fn template <typename T> void QJniObject::setField(const char *fieldName, const char *signature, T value)
1531 
1532     Sets the value of \a fieldName with \a signature to \a value.
1533 
1534     \code
1535     QJniObject stringArray = ...;
1536     QJniObject obj = ...;
1537     obj.setField<jobjectArray>("KEY_VALUES", "([Ljava/lang/String;)V", stringArray.object<jobjectArray>())
1538     \endcode
1539 */
1540 template <> Q_CORE_EXPORT
1541 void QJniObject::setField<jobject>(const char *fieldName, const char *sig, jobject value)
1542 {
1543     QJniEnvironment env;
1544     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, sig);
1545     if (id)
1546         env->SetObjectField(d->m_jobject, id, value);
1547 }
1548 
1549 template <> Q_CORE_EXPORT
1550 void QJniObject::setField<jobjectArray>(const char *fieldName, const char *sig, jobjectArray value)
1551 {
1552     QJniEnvironment env;
1553     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, sig);
1554     if (id)
1555         env->SetObjectField(d->m_jobject, id, value);
1556 }
1557 
1558 /*!
1559     \fn QJniObject QJniObject::getObjectField(const char *fieldName) const
1560 
1561     Retrieves the object of field \a fieldName.
1562 
1563     \code
1564     QJniObject field = jniObject.getObjectField<jstring>("FIELD_NAME");
1565     \endcode
1566 */
1567 
1568 /*!
1569     \fn QJniObject QJniObject::getObjectField(const char *fieldName, const char *signature) const
1570 
1571     Retrieves the object from the field with \a signature and \a fieldName.
1572 
1573     \note This function can be used without a template type.
1574 
1575     \code
1576     QJniObject field = jniObject.getObjectField("FIELD_NAME", "Ljava/lang/String;");
1577     \endcode
1578 */
1579 QJniObject QJniObject::getObjectField(const char *fieldName, const char *sig) const
1580 {
1581     QJniEnvironment env;
1582     jobject res = nullptr;
1583     jfieldID id = getCachedFieldID(env, d->m_jclass, d->m_className, fieldName, sig);
1584     if (id) {
1585         res = env->GetObjectField(d->m_jobject, id);
1586         if (res && env->ExceptionCheck())
1587             res = nullptr;
1588     }
1589     QJniObject obj(res);
1590     env->DeleteLocalRef(res);
1591     return obj;
1592 }
1593 
1594 /*!
1595     \fn template <typename T> void QJniObject::setField(const char *fieldName, T value)
1596 
1597     Sets the value of \a fieldName to \a value.
1598 
1599     \code
1600     ...
1601     QJniObject obj;
1602     obj.setField<jint>("AN_INT_FIELD", 10);
1603     jstring myString = ...
1604     obj.setField<jstring>("A_STRING_FIELD", myString);
1605     ...
1606     \endcode
1607 */
1608 
1609 /*!
1610     \fn QJniObject QJniObject::getStaticObjectField(const char *className, const char *fieldName)
1611 
1612     Retrieves the object from the field \a fieldName on the class \a className.
1613 
1614     \code
1615     QJniObject jobj = QJniObject::getStaticObjectField<jstring>("class/with/Fields", "FIELD_NAME");
1616     \endcode
1617 */
1618 
1619 /*!
1620     \fn QJniObject QJniObject::getStaticObjectField(jclass clazz, const char *fieldName)
1621 
1622     Retrieves the object from the field \a fieldName on \a clazz.
1623 
1624     \code
1625     QJniObject jobj = QJniObject::getStaticObjectField<jstring>(clazz, "FIELD_NAME");
1626     \endcode
1627 */
1628 
1629 #define MAKE_JNI_OBJECT_FILEDS(Type, Signature) \
1630 template <> Q_CORE_EXPORT void QJniObject::setField<Type>(const char *fieldName, Type value) \
1631 { \
1632     QJniObject::setField<jobject>(fieldName, Signature, value); \
1633 } \
1634 \
1635 template <> Q_CORE_EXPORT void QJniObject::setStaticField<Type>(const char *className, \
1636                                                                 const char *fieldName, \
1637                                                                 Type value) \
1638 { \
1639     QJniObject::setStaticField<jobject>(className, fieldName, Signature, value); \
1640 }\
1641 template <>\
1642 Q_CORE_EXPORT QJniObject QJniObject::getObjectField<Type>(const char *fieldName) const\
1643 {\
1644     return getObjectField(fieldName, Signature);\
1645 }\
1646 template <>\
1647 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<Type>(jclass clazz,\
1648                                                                 const char *fieldName)\
1649 {\
1650     return getStaticObjectField(clazz, fieldName, Signature);\
1651 }\
1652 template <>\
1653 Q_CORE_EXPORT QJniObject QJniObject::getStaticObjectField<Type>(const char *className,\
1654                                                                 const char *fieldName)\
1655 {\
1656     return getStaticObjectField(className, fieldName, Signature);\
1657 }\
1658 
1659 #define DECLARE_JNI_OBJECT_FILEDS(Type, Signature) MAKE_JNI_OBJECT_FILEDS(Type, Signature)
1660 
1661 DECLARE_JNI_OBJECT_FILEDS(jobject, "Ljava/lang/Object;")
1662 DECLARE_JNI_OBJECT_FILEDS(jobjectArray, "[Ljava/lang/Object;")
1663 DECLARE_JNI_OBJECT_FILEDS(jstring, "Ljava/lang/String;")
1664 DECLARE_JNI_OBJECT_FILEDS(jclass, "Ljava/lang/Class;")
1665 DECLARE_JNI_OBJECT_FILEDS(jthrowable, "Ljava/lang/Throwable;")
1666 DECLARE_JNI_OBJECT_FILEDS(jbooleanArray, "[Z")
1667 DECLARE_JNI_OBJECT_FILEDS(jbyteArray, "[B")
1668 DECLARE_JNI_OBJECT_FILEDS(jcharArray, "[C")
1669 DECLARE_JNI_OBJECT_FILEDS(jshortArray, "[S")
1670 DECLARE_JNI_OBJECT_FILEDS(jintArray, "[I")
1671 DECLARE_JNI_OBJECT_FILEDS(jlongArray, "[J")
1672 DECLARE_JNI_OBJECT_FILEDS(jfloatArray, "[F")
1673 DECLARE_JNI_OBJECT_FILEDS(jdoubleArray, "[D")
1674 
1675 /*!
1676     \fn QJniObject QJniObject::fromString(const QString &string)
1677 
1678     Creates a Java string from the QString \a string and returns a QJniObject holding that string.
1679 
1680     \code
1681     QString myQString = "QString";
1682     QJniObject myJavaString = QJniObject::fromString(myQString);
1683     \endcode
1684 
1685     \sa toString()
1686 */
1687 QJniObject QJniObject::fromString(const QString &string)
1688 {
1689     QJniEnvironment env;
1690     jstring res = env->NewString(reinterpret_cast<const jchar*>(string.constData()),
1691                                         string.length());
1692     QJniObject obj(res);
1693     env->DeleteLocalRef(res);
1694     return obj;
1695 }
1696 
1697 /*!
1698     \fn QString QJniObject::toString() const
1699 
1700     Returns a QString with a string representation of the java object.
1701     Calling this function on a Java String object is a convenient way of getting the actual string
1702     data.
1703 
1704     \code
1705     QJniObject string = ...; //  "Hello Java"
1706     QString qstring = string.toString(); // "Hello Java"
1707     \endcode
1708 
1709     \sa fromString()
1710 */
1711 QString QJniObject::toString() const
1712 {
1713     if (!isValid())
1714         return QString();
1715 
1716     QJniObject string = callObjectMethod<jstring>("toString");
1717     return qt_convertJString(static_cast<jstring>(string.object()));
1718 }
1719 
1720 /*!
1721     \fn bool QJniObject::isClassAvailable(const char *className)
1722 
1723     Returns true if the Java class \a className is available.
1724 
1725     \code
1726     if (QJniObject::isClassAvailable("java/lang/String")) {
1727         // condition statement
1728     }
1729     \endcode
1730 */
1731 bool QJniObject::isClassAvailable(const char *className)
1732 {
1733     QJniEnvironment env;
1734 
1735     if (!env)
1736         return false;
1737 
1738     jclass clazz = loadClass(className, env);
1739     return (clazz != 0);
1740 }
1741 
1742 /*!
1743     \fn bool QJniObject::isValid() const
1744 
1745     Returns true if this instance holds a valid Java object.
1746 
1747     \code
1748     QJniObject qjniObject;                        ==> isValid() == false
1749     QJniObject qjniObject(0)                      ==> isValid() == false
1750     QJniObject qjniObject("could/not/find/Class") ==> isValid() == false
1751     \endcode
1752 */
1753 bool QJniObject::isValid() const
1754 {
1755     return d->m_jobject;
1756 }
1757 
1758 /*!
1759     \fn QJniObject QJniObject::fromLocalRef(jobject localRef)
1760     \since 6.1
1761 
1762     Creates a QJniObject from the local JNI reference \a localRef.
1763     This function takes ownership of \a localRef and frees it before returning.
1764 
1765     \note Only call this function with a local JNI reference. For example, most raw JNI calls, through
1766     the JNI environment, returns local references to a java object.
1767 
1768     \code
1769     jobject localRef = env->GetObjectArrayElement(array, index);
1770     QJniObject element = QJniObject::fromLocalRef(localRef);
1771     \endcode
1772 */
1773 QJniObject QJniObject::fromLocalRef(jobject lref)
1774 {
1775     QJniObject obj(lref);
1776     QJniEnvironment()->DeleteLocalRef(lref);
1777     return obj;
1778 }
1779 
1780 bool QJniObject::isSameObject(jobject obj) const
1781 {
1782     return QJniEnvironment()->IsSameObject(d->m_jobject, obj);
1783 }
1784 
1785 bool QJniObject::isSameObject(const QJniObject &other) const
1786 {
1787     return isSameObject(other.d->m_jobject);
1788 }
1789 
1790 void QJniObject::assign(jobject obj)
1791 {
1792     if (isSameObject(obj))
1793         return;
1794 
1795     jobject jobj = static_cast<jobject>(obj);
1796     d = QSharedPointer<QJniObjectPrivate>::create();
1797     if (obj) {
1798         QJniEnvironment env;
1799         d->m_jobject = env->NewGlobalRef(jobj);
1800         jclass objectClass = env->GetObjectClass(jobj);
1801         d->m_jclass = static_cast<jclass>(env->NewGlobalRef(objectClass));
1802         env->DeleteLocalRef(objectClass);
1803     }
1804 }
1805 
1806 jobject QJniObject::javaObject() const
1807 {
1808     return d->m_jobject;
1809 }
1810 
1811 QT_END_NAMESPACE
