Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
Add support of cancellation handler callbacks to QFuture

Added QFuture::onCanceled() method, for attaching handlers to be called
when the QFuture gets canceled.

Change-Id: I1f01647d6173ba0c1db6641e14140108b33ac7c4
Reviewed-by: Leena Miettinen <riitta-leena.miettinen@qt.io>
Reviewed-by: Fabian Kosmale <fabian.kosmale@qt.io>

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the test suite of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
21 ** included in the packaging of this file. Please review the following
22 ** information to ensure the GNU General Public License requirements will
23 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
24 **
25 ** $QT_END_LICENSE$
26 **
27 ****************************************************************************/
28 #include <QCoreApplication>
29 #include <QDebug>
30 
31 #define QFUTURE_TEST
32 
33 #include <QtTest/QtTest>
34 #include <qfuture.h>
35 #include <qfuturewatcher.h>
36 #include <qresultstore.h>
37 #include <qthreadpool.h>
38 #include <qexception.h>
39 #include <qrandom.h>
40 #include <QtConcurrent/qtconcurrentrun.h>
41 #include <private/qfutureinterface_p.h>
42 
43 #include <vector>
44 #include <memory>
45 
46 // COM interface macro.
47 #if defined(Q_OS_WIN) && defined(interface)
48 #  undef interface
49 #endif
50 
51 struct ResultStoreInt : QtPrivate::ResultStoreBase
52 {
53     ~ResultStoreInt() { clear<int>(); }
54 };
55 
56 class SenderObject : public QObject
57 {
58     Q_OBJECT
59 
60 public:
61     void emitNoArg() { emit noArgSignal(); }
62     void emitIntArg(int value) { emit intArgSignal(value); }
63     void emitConstRefArg(const QString &value) { emit constRefArg(value); }
64     void emitMultipleArgs(int value1, double value2, const QString &value3)
65     {
66         emit multipleArgs(value1, value2, value3);
67     }
68 
69 signals:
70     void noArgSignal();
71     void intArgSignal(int value);
72     void constRefArg(const QString &value);
73     void multipleArgs(int value1, double value2, const QString &value3);
74 };
75 
76 class LambdaThread : public QThread
77 {
78 public:
79     LambdaThread(std::function<void ()> fn)
80     :m_fn(fn)
81     {
82 
83     }
84 
85     void run() override
86     {
87         m_fn();
88     }
89 
90 private:
91     std::function<void ()> m_fn;
92 };
93 
94 using UniquePtr = std::unique_ptr<int>;
95 
96 class tst_QFuture: public QObject
97 {
98     Q_OBJECT
99 private slots:
100     void resultStore();
101     void future();
102     void futureInterface();
103     void refcounting();
104     void cancel();
105     void statePropagation();
106     void multipleResults();
107     void indexedResults();
108     void progress();
109     void progressText();
110     void resultsAfterFinished();
111     void resultsAsList();
112     void implicitConversions();
113     void iterators();
114     void iteratorsThread();
115     void pause();
116     void throttling();
117     void voidConversions();
118 #ifndef QT_NO_EXCEPTIONS
119     void exceptions();
120     void nestedExceptions();
121 #endif
122     void nonGlobalThreadPool();
123 
124     void then();
125     void thenForMoveOnlyTypes();
126     void thenOnCanceledFuture();
127 #ifndef QT_NO_EXCEPTIONS
128     void thenOnExceptionFuture();
129     void thenThrows();
130     void onFailed();
131     void onFailedTestCallables();
132     void onFailedForMoveOnlyTypes();
133 #endif
134     void onCanceled();
135     void takeResults();
136     void takeResult();
137     void runAndTake();
138     void resultsReadyAt_data();
139     void resultsReadyAt();
140     void takeResultWorksForTypesWithoutDefaultCtor();
141     void canceledFutureIsNotValid();
142     void signalConnect();
143 
144 private:
145     using size_type = std::vector<int>::size_type;
146 
147     static void testSingleResult(const UniquePtr &p);
148     static void testSingleResult(const std::vector<int> &v);
149     template<class T>
150     static void testSingleResult(const T &unknown);
151     template<class T>
152     static void testFutureTaken(QFuture<T> &noMoreFuture);
153     template<class T>
154     static  void testTakeResults(QFuture<T> future, size_type resultCount);
155 };
156 
157 void tst_QFuture::resultStore()
158 {
159     int int0 = 0;
160     int int1 = 1;
161     int int2 = 2;
162 
163     {
164         ResultStoreInt store;
165         QCOMPARE(store.begin(), store.end());
166         QCOMPARE(store.resultAt(0), store.end());
167         QCOMPARE(store.resultAt(1), store.end());
168     }
169 
170 
171     {
172         ResultStoreInt store;
173         store.addResult(-1, &int0);
174         store.addResult(1, &int1);
175         QtPrivate::ResultIteratorBase it = store.begin();
176         QCOMPARE(it.resultIndex(), 0);
177         QVERIFY(it == store.begin());
178         QVERIFY(it != store.end());
179 
180         ++it;
181         QCOMPARE(it.resultIndex(), 1);
182         QVERIFY(it != store.begin());
183         QVERIFY(it != store.end());
184 
185         ++it;
186         QVERIFY(it != store.begin());
187         QVERIFY(it == store.end());
188     }
189 
190     QVector<int> vec0 = QVector<int>() << 2 << 3;
191     QVector<int> vec1 = QVector<int>() << 4 << 5;
192 
193     {
194         ResultStoreInt store;
195         store.addResults(-1, &vec0, 2);
196         store.addResults(-1, &vec1, 2);
197         QtPrivate::ResultIteratorBase it = store.begin();
198         QCOMPARE(it.resultIndex(), 0);
199         QCOMPARE(it, store.begin());
200         QVERIFY(it != store.end());
201 
202         ++it;
203         QCOMPARE(it.resultIndex(), 1);
204         QVERIFY(it != store.begin());
205         QVERIFY(it != store.end());
206 
207         ++it;
208         QCOMPARE(it.resultIndex(), 2);
209 
210         ++it;
211         QCOMPARE(it.resultIndex(), 3);
212 
213         ++it;
214         QCOMPARE(it, store.end());
215     }
216     {
217         ResultStoreInt store;
218         store.addResult(-1, &int0);
219         store.addResults(-1, &vec1, 2);
220         store.addResult(-1, &int1);
221 
222         QtPrivate::ResultIteratorBase it = store.begin();
223         QCOMPARE(it.resultIndex(), 0);
224         QVERIFY(it == store.begin());
225         QVERIFY(it != store.end());
226 
227         ++it;
228         QCOMPARE(it.resultIndex(), 1);
229         QVERIFY(it != store.begin());
230         QVERIFY(it != store.end());
231 
232         ++it;
233         QCOMPARE(it.resultIndex(), 2);
234         QVERIFY(it != store.end());
235         ++it;
236         QCOMPARE(it.resultIndex(), 3);
237         QVERIFY(it != store.end());
238         ++it;
239         QVERIFY(it == store.end());
240 
241         QCOMPARE(store.resultAt(0).resultIndex(), 0);
242         QCOMPARE(store.resultAt(1).resultIndex(), 1);
243         QCOMPARE(store.resultAt(2).resultIndex(), 2);
244         QCOMPARE(store.resultAt(3).resultIndex(), 3);
245         QCOMPARE(store.resultAt(4), store.end());
246     }
247     {
248         ResultStoreInt store;
249         store.addResult(-1, &int0);
250         store.addResults(-1, &vec0);
251         store.addResult(-1, &int1);
252 
253         QtPrivate::ResultIteratorBase it = store.begin();
254         QCOMPARE(it.resultIndex(), 0);
255         QVERIFY(it == store.begin());
256         QVERIFY(it != store.end());
257 
258         ++it;
259         QCOMPARE(it.resultIndex(), 1);
260         QVERIFY(it != store.begin());
261         QVERIFY(it != store.end());
262 
263         ++it;
264         QCOMPARE(it.resultIndex(), 2);
265         QVERIFY(it != store.end());
266         ++it;
267         QCOMPARE(it.resultIndex(), 3);
268         QVERIFY(it != store.end());
269         ++it;
270         QVERIFY(it == store.end());
271 
272         QCOMPARE(store.resultAt(0).value<int>(), int0);
273         QCOMPARE(store.resultAt(1).value<int>(), vec0[0]);
274         QCOMPARE(store.resultAt(2).value<int>(), vec0[1]);
275         QCOMPARE(store.resultAt(3).value<int>(), int1);
276     }
277     {
278         ResultStoreInt store;
279         store.addResult(-1, &int0);
280         store.addResults(-1, &vec0);
281         store.addResult(200, &int1);
282 
283         QCOMPARE(store.resultAt(0).value<int>(), int0);
284         QCOMPARE(store.resultAt(1).value<int>(), vec0[0]);
285         QCOMPARE(store.resultAt(2).value<int>(), vec0[1]);
286         QCOMPARE(store.resultAt(200).value<int>(), int1);
287     }
288 
289     {
290         ResultStoreInt store;
291         store.addResult(1, &int1);
292         store.addResult(0, &int0);
293         store.addResult(-1, &int2);
294 
295         QCOMPARE(store.resultAt(0).value<int>(), int0);
296         QCOMPARE(store.resultAt(1).value<int>(), int1);
297         QCOMPARE(store.resultAt(2).value<int>(), int2);
298     }
299 
300     {
301         ResultStoreInt store;
302         QCOMPARE(store.contains(0), false);
303         QCOMPARE(store.contains(1), false);
304         QCOMPARE(store.contains(INT_MAX), false);
305     }
306 
307     {
308         // Test filter mode, where "gaps" in the result array aren't allowed.
309         ResultStoreInt store;
310         store.setFilterMode(true);
311 
312         store.addResult(0, &int0);
313         QCOMPARE(store.contains(0), true);
314 
315         store.addResult(2, &int2); // add result at index 2
316         QCOMPARE(store.contains(2), false); // but 1 is missing, so this 2 won't be reported yet.
317 
318         store.addResult(1, &int1);
319         QCOMPARE(store.contains(1), true);
320         QCOMPARE(store.contains(2), true); // 2 should be visible now.
321 
322         store.addResult(4, &int0);
323         store.addResult(5, &int0);
324         store.addResult(7, &int0);
325         QCOMPARE(store.contains(4), false);
326         QCOMPARE(store.contains(5), false);
327         QCOMPARE(store.contains(7), false);
328 
329         store.addResult(3, &int0);  // adding 3 makes 4 and 5 visible
330         QCOMPARE(store.contains(4), true);
331         QCOMPARE(store.contains(5), true);
332         QCOMPARE(store.contains(7), false);
333 
334         store.addResult(6, &int0);  // adding 6 makes 7 visible
335 
336         QCOMPARE(store.contains(6), true);
337         QCOMPARE(store.contains(7), true);
338         QCOMPARE(store.contains(8), false);
339     }
340 
341     {
342         // test canceled results
343         ResultStoreInt store;
344         store.setFilterMode(true);
345 
346         store.addResult(0, &int0);
347         QCOMPARE(store.contains(0), true);
348 
349         store.addResult(2, &int0);
350         QCOMPARE(store.contains(2), false);
351 
352         store.addCanceledResult(1); // report no result at 1
353 
354         QCOMPARE(store.contains(0), true);
355         QCOMPARE(store.contains(1), true); // 2 gets renamed to 1
356         QCOMPARE(store.contains(2), false);
357 
358         store.addResult(3, &int0);
359         QCOMPARE(store.contains(2), true); //3 gets renamed to 2
360 
361         store.addResult(6, &int0);
362         store.addResult(7, &int0);
363         QCOMPARE(store.contains(3), false);
364 
365         store.addCanceledResult(4);
366         store.addCanceledResult(5);
367 
368         QCOMPARE(store.contains(3), true); //6 gets renamed to 3
369         QCOMPARE(store.contains(4), true); //7 gets renamed to 4
370 
371         store.addResult(8, &int0);
372         QCOMPARE(store.contains(5), true); //8 gets renamed to 4
373 
374         QCOMPARE(store.contains(6), false);
375         QCOMPARE(store.contains(7), false);
376     }
377 
378     {
379         // test addResult return value
380         ResultStoreInt store;
381         store.setFilterMode(true);
382 
383         store.addResult(0, &int0);
384         QCOMPARE(store.count(), 1); // result 0 becomes available
385         QCOMPARE(store.contains(0), true);
386 
387         store.addResult(2, &int0);
388         QCOMPARE(store.count(), 1);
389         QCOMPARE(store.contains(2), false);
390 
391         store.addCanceledResult(1);
392         QCOMPARE(store.count(), 2); // result 2 is renamed to 1 and becomes available
393 
394         QCOMPARE(store.contains(0), true);
395         QCOMPARE(store.contains(1), true);
396         QCOMPARE(store.contains(2), false);
397 
398         store.addResult(3, &int0);
399         QCOMPARE(store.count(), 3);
400         QCOMPARE(store.contains(2), true);
401 
402         store.addResult(6, &int0);
403         QCOMPARE(store.count(), 3);
404         store.addResult(7, &int0);
405         QCOMPARE(store.count(), 3);
406         QCOMPARE(store.contains(3), false);
407 
408         store.addCanceledResult(4);
409         store.addCanceledResult(5);
410         QCOMPARE(store.count(), 5); // 6 and 7 is renamed to 3 and 4 and becomes available
411 
412         QCOMPARE(store.contains(3), true);
413         QCOMPARE(store.contains(4), true);
414 
415         store.addResult(8, &int0);
416         QCOMPARE(store.contains(5), true);
417         QCOMPARE(store.count(), 6);
418 
419         QCOMPARE(store.contains(6), false);
420         QCOMPARE(store.contains(7), false);
421     }
422 
423     {
424         // test resultCount in non-filtered mode. It should always be possible
425         // to iterate through the results 0 to resultCount.
426         ResultStoreInt store;
427         store.addResult(0, &int0);
428 
429         QCOMPARE(store.count(), 1);
430 
431         store.addResult(2, &int0);
432 
433         QCOMPARE(store.count(), 1);
434 
435         store.addResult(1, &int0);
436         QCOMPARE(store.count(), 3);
437     }
438 
439     {
440         ResultStoreInt store;
441         store.addResult(2, &int0);
442         QCOMPARE(store.count(), 0);
443 
444         store.addResult(1, &int0);
445         QCOMPARE(store.count(), 0);
446 
447         store.addResult(0, &int0);
448         QCOMPARE(store.count(), 3);
449     }
450 
451     {
452         ResultStoreInt store;
453         store.addResults(2, &vec1);
454         QCOMPARE(store.count(), 0);
455 
456         store.addResult(1, &int0);
457         QCOMPARE(store.count(), 0);
458 
459         store.addResult(0, &int0);
460         QCOMPARE(store.count(), 4);
461     }
462 
463     {
464         ResultStoreInt store;
465         store.addResults(2, &vec1);
466         QCOMPARE(store.count(), 0);
467 
468         store.addResults(0, &vec0);
469         QCOMPARE(store.count(), 4);
470     }
471     {
472         ResultStoreInt store;
473         store.addResults(3, &vec1);
474         QCOMPARE(store.count(), 0);
475 
476         store.addResults(0, &vec0);
477         QCOMPARE(store.count(), 2);
478 
479         store.addResult(2, &int0);
480         QCOMPARE(store.count(), 5);
481     }
482 
483     {
484         ResultStoreInt store;
485         store.setFilterMode(true);
486         store.addResults(3, &vec1);
487         QCOMPARE(store.count(), 0);
488 
489         store.addResults(0, &vec0);
490         QCOMPARE(store.count(), 2);
491 
492         store.addCanceledResult(2);
493         QCOMPARE(store.count(), 4);
494     }
495 
496     {
497         ResultStoreInt store;
498         store.setFilterMode(true);
499         store.addResults(3, &vec1);
500         QCOMPARE(store.count(), 0);
501 
502         store.addCanceledResults<int>(0, 3);
503         QCOMPARE(store.count(), 2);
504     }
505 
506     {
507         ResultStoreInt store;
508         store.setFilterMode(true);
509         store.addResults(3, &vec1);
510         QCOMPARE(store.count(), 0);
511 
512         store.addCanceledResults<int>(0, 3);
513         QCOMPARE(store.count(), 2);  // results at 3 and 4 become available at index 0, 1
514 
515         store.addResult(5, &int0);
516         QCOMPARE(store.count(), 3);// result 5 becomes available at index 2
517     }
518 
519     {
520         ResultStoreInt store;
521         store.addResult(1, &int0);
522         store.addResult(3, &int0);
523         store.addResults(6, &vec0);
524         QCOMPARE(store.contains(0), false);
525         QCOMPARE(store.contains(1), true);
526         QCOMPARE(store.contains(2), false);
527         QCOMPARE(store.contains(3), true);
528         QCOMPARE(store.contains(4), false);
529         QCOMPARE(store.contains(5), false);
530         QCOMPARE(store.contains(6), true);
531         QCOMPARE(store.contains(7), true);
532     }
533 
534     {
535         ResultStoreInt store;
536         store.setFilterMode(true);
537         store.addResult(1, &int0);
538         store.addResult(3, &int0);
539         store.addResults(6, &vec0);
540         QCOMPARE(store.contains(0), false);
541         QCOMPARE(store.contains(1), false);
542         QCOMPARE(store.contains(2), false);
543         QCOMPARE(store.contains(3), false);
544         QCOMPARE(store.contains(4), false);
545         QCOMPARE(store.contains(5), false);
546         QCOMPARE(store.contains(6), false);
547         QCOMPARE(store.contains(7), false);
548 
549         store.addCanceledResult(0);
550         store.addCanceledResult(2);
551         store.addCanceledResults<int>(4, 2);
552 
553         QCOMPARE(store.contains(0), true);
554         QCOMPARE(store.contains(1), true);
555         QCOMPARE(store.contains(2), true);
556         QCOMPARE(store.contains(3), true);
557         QCOMPARE(store.contains(4), false);
558         QCOMPARE(store.contains(5), false);
559         QCOMPARE(store.contains(6), false);
560         QCOMPARE(store.contains(7), false);
561     }
562     {
563         ResultStoreInt store;
564         store.setFilterMode(true);
565         store.addCanceledResult(0);
566         QCOMPARE(store.contains(0), false);
567 
568         store.addResult(1, &int0);
569         QCOMPARE(store.contains(0), true);
570         QCOMPARE(store.contains(1), false);
571     }
572 }
573 
574 void tst_QFuture::future()
575 {
576     // default constructors
577     QFuture<int> intFuture;
578     intFuture.waitForFinished();
579     QFuture<QString> stringFuture;
580     stringFuture.waitForFinished();
581     QFuture<void> voidFuture;
582     voidFuture.waitForFinished();
583     QFuture<void> defaultVoidFuture;
584     defaultVoidFuture.waitForFinished();
585 
586     // copy constructor
587     QFuture<int> intFuture2(intFuture);
588     QFuture<void> voidFuture2(defaultVoidFuture);
589 
590     // assigmnent operator
591     intFuture2 = QFuture<int>();
592     voidFuture2 = QFuture<void>();
593 
594     // state
595     QCOMPARE(intFuture2.isStarted(), true);
596     QCOMPARE(intFuture2.isFinished(), true);
597 }
598 
599 class IntResult : public QFutureInterface<int>
600 {
601 public:
602     QFuture<int> run()
603     {
604         this->reportStarted();
605         QFuture<int> future = QFuture<int>(this);
606 
607         int res = 10;
608         reportFinished(&res);
609         return future;
610     }
611 };
612 
613 int value = 10;
614 
615 class VoidResult : public QFutureInterfaceBase
616 {
617 public:
618     QFuture<void> run()
619     {
620         this->reportStarted();
621         QFuture<void> future = QFuture<void>(this);
622         reportFinished();
623         return future;
624     }
625 };
626 
627 void tst_QFuture::futureInterface()
628 {
629     {
630         QFuture<void> future;
631         {
632             QFutureInterface<void> i;
633             i.reportStarted();
634             future = i.future();
635             i.reportFinished();
636         }
637     }
638     {
639         QFuture<int> future;
640         {
641             QFutureInterface<int> i;
642             i.reportStarted();
643             i.reportResult(10);
644             future = i.future();
645             i.reportFinished();
646         }
647         QCOMPARE(future.resultAt(0), 10);
648     }
649 
650     {
651         QFuture<int> intFuture;
652 
653         QCOMPARE(intFuture.isStarted(), true);
654         QCOMPARE(intFuture.isFinished(), true);
655 
656         IntResult result;
657 
658         result.reportStarted();
659         intFuture = result.future();
660 
661         QCOMPARE(intFuture.isStarted(), true);
662         QCOMPARE(intFuture.isFinished(), false);
663 
664         result.reportFinished(&value);
665 
666         QCOMPARE(intFuture.isStarted(), true);
667         QCOMPARE(intFuture.isFinished(), true);
668 
669         int e = intFuture.result();
670 
671         QCOMPARE(intFuture.isStarted(), true);
672         QCOMPARE(intFuture.isFinished(), true);
673         QCOMPARE(intFuture.isCanceled(), false);
674 
675         QCOMPARE(e, value);
676         intFuture.waitForFinished();
677 
678         IntResult intAlgo;
679         intFuture = intAlgo.run();
680         QFuture<int> intFuture2(intFuture);
681         QCOMPARE(intFuture.result(), value);
682         QCOMPARE(intFuture2.result(), value);
683         intFuture.waitForFinished();
684 
685         VoidResult a;
686         a.run().waitForFinished();
687     }
688 }
689 
690 template <typename T>
691 void testRefCounting()
692 {
693     QFutureInterface<T> interface;
694     QCOMPARE(interface.d->refCount.load(), 1);
695 
696     {
697         interface.reportStarted();
698 
699         QFuture<T> f = interface.future();
700         QCOMPARE(interface.d->refCount.load(), 2);
701 
702         QFuture<T> f2(f);
703         QCOMPARE(interface.d->refCount.load(), 3);
704 
705         QFuture<T> f3;
706         f3 = f2;
707         QCOMPARE(interface.d->refCount.load(), 4);
708 
709         interface.reportFinished(0);
710         QCOMPARE(interface.d->refCount.load(), 4);
711     }
712 
713     QCOMPARE(interface.d->refCount.load(), 1);
714 }
715 
716 void tst_QFuture::refcounting()
717 {
718     testRefCounting<int>();
719 }
720 
721 void tst_QFuture::cancel()
722 {
723     {
724         QFuture<void> f;
725         QFutureInterface<void> result;
726 
727         result.reportStarted();
728         f = result.future();
729         QVERIFY(!f.isCanceled());
730         result.reportCanceled();
731         QVERIFY(f.isCanceled());
732         result.reportFinished();
733         QVERIFY(f.isCanceled());
734         f.waitForFinished();
735         QVERIFY(f.isCanceled());
736     }
737 
738     // Cancel from the QFuture side and test if the result
739     // interface detects it.
740     {
741         QFutureInterface<void> result;
742 
743         QFuture<void> f;
744         QVERIFY(f.isStarted());
745 
746         result.reportStarted();
747         f = result.future();
748 
749         QVERIFY(f.isStarted());
750 
751         QVERIFY(!result.isCanceled());
752         f.cancel();
753 
754         QVERIFY(result.isCanceled());
755 
756         result.reportFinished();
757     }
758 
759     // Test that finished futures can be canceled.
760     {
761         QFutureInterface<void> result;
762 
763         QFuture<void> f;
764         QVERIFY(f.isStarted());
765 
766         result.reportStarted();
767         f = result.future();
768 
769         QVERIFY(f.isStarted());
770 
771         result.reportFinished();
772 
773         f.cancel();
774 
775         QVERIFY(result.isCanceled());
776         QVERIFY(f.isCanceled());
777     }
778 
779     // Results reported after canceled is called should not be propagated.
780     {
781 
782         QFutureInterface<int> futureInterface;
783         futureInterface.reportStarted();
784         QFuture<int> f = futureInterface.future();
785 
786         int result = 0;
787         futureInterface.reportResult(&result);
788         result = 1;
789         futureInterface.reportResult(&result);
790         f.cancel();
791         result = 2;
792         futureInterface.reportResult(&result);
793         result = 3;
794         futureInterface.reportResult(&result);
795         futureInterface.reportFinished();
796         QCOMPARE(f.results(), QList<int>());
797     }
798 }
799 
800 void tst_QFuture::statePropagation()
801 {
802     QFuture<void> f1;
803     QFuture<void> f2;
804 
805     QCOMPARE(f1.isStarted(), true);
806 
807     QFutureInterface<void> result;
808     result.reportStarted();
809     f1 = result.future();
810 
811     f2 = f1;
812 
813     QCOMPARE(f2.isStarted(), true);
814 
815     result.reportCanceled();
816 
817     QCOMPARE(f2.isStarted(), true);
818     QCOMPARE(f2.isCanceled(), true);
819 
820     QFuture<void> f3 = f2;
821 
822     QCOMPARE(f3.isStarted(), true);
823     QCOMPARE(f3.isCanceled(), true);
824 
825     result.reportFinished();
826 
827     QCOMPARE(f2.isStarted(), true);
828     QCOMPARE(f2.isCanceled(), true);
829 
830     QCOMPARE(f3.isStarted(), true);
831     QCOMPARE(f3.isCanceled(), true);
832 }
833 
834 /*
835     Tests that a QFuture can return multiple results.
836 */
837 void tst_QFuture::multipleResults()
838 {
839     IntResult a;
840     a.reportStarted();
841     QFuture<int> f = a.future();
842 
843     QFuture<int> copy = f;
844     int result;
845 
846     result = 1;
847     a.reportResult(&result);
848     QCOMPARE(f.resultAt(0), 1);
849 
850     result = 2;
851     a.reportResult(&result);
852     QCOMPARE(f.resultAt(1), 2);
853 
854     result = 3;
855     a.reportResult(&result);
856 
857     result = 4;
858     a.reportFinished(&result);
859 
860     QCOMPARE(f.results(), QList<int>() << 1 << 2 << 3 << 4);
861 
862     // test foreach
863     QList<int> fasit = QList<int>() << 1 << 2 << 3 << 4;
864     {
865         QList<int> results;
866         foreach(int result, f)
867             results.append(result);
868         QCOMPARE(results, fasit);
869     }
870     {
871         QList<int> results;
872         foreach(int result, copy)
873             results.append(result);
874         QCOMPARE(results, fasit);
875     }
876 }
877 
878 /*
879     Test out-of-order result reporting using indexes
880 */
881 void tst_QFuture::indexedResults()
882 {
883     {
884         QFutureInterface<QChar> Interface;
885         QFuture<QChar> f;
886         QVERIFY(f.isStarted());
887 
888         Interface.reportStarted();
889         f = Interface.future();
890 
891         QVERIFY(f.isStarted());
892 
893         QChar result;
894 
895         result = 'B';
896         Interface.reportResult(&result, 1);
897 
898         QCOMPARE(f.resultAt(1), result);
899 
900         result = 'A';
901         Interface.reportResult(&result, 0);
902         QCOMPARE(f.resultAt(0), result);
903 
904         result = 'C';
905         Interface.reportResult(&result); // no index
906         QCOMPARE(f.resultAt(2), result);
907 
908         Interface.reportFinished();
909 
910         QCOMPARE(f.results(), QList<QChar>() << 'A' << 'B' << 'C');
911     }
912 
913     {
914         // Test result reporting with a missing result in the middle
915         QFutureInterface<int> Interface;
916         Interface.reportStarted();
917         QFuture<int> f = Interface.future();
918         int result;
919 
920         result = 0;
921         Interface.reportResult(&result, 0);
922         QVERIFY(f.isResultReadyAt(0));
923         QCOMPARE(f.resultAt(0), 0);
924 
925         result = 3;
926         Interface.reportResult(&result, 3);
927         QVERIFY(f.isResultReadyAt(3));
928         QCOMPARE(f.resultAt(3), 3);
929 
930         result = 2;
931         Interface.reportResult(&result, 2);
932         QVERIFY(f.isResultReadyAt(2));
933         QCOMPARE(f.resultAt(2), 2);
934 
935         result = 4;
936         Interface.reportResult(&result); // no index
937         QVERIFY(f.isResultReadyAt(4));
938         QCOMPARE(f.resultAt(4), 4);
939 
940         Interface.reportFinished();
941 
942         QCOMPARE(f.results(), QList<int>() << 0 << 2 << 3 << 4);
943     }
944 }
945 
946 void tst_QFuture::progress()
947 {
948     QFutureInterface<QChar> result;
949     QFuture<QChar> f;
950 
951     QCOMPARE (f.progressValue(), 0);
952 
953     result.reportStarted();
954     f = result.future();
955 
956     QCOMPARE (f.progressValue(), 0);
957 
958     result.setProgressValue(50);
959 
960     QCOMPARE (f.progressValue(), 50);
961 
962     result.reportFinished();
963 
964     QCOMPARE (f.progressValue(), 50);
965 }
966 
967 void tst_QFuture::progressText()
968 {
969     QFutureInterface<void> i;
970     i.reportStarted();
971     QFuture<void> f = i.future();
972 
973     QCOMPARE(f.progressText(), QLatin1String(""));
974     i.setProgressValueAndText(1, QLatin1String("foo"));
975     QCOMPARE(f.progressText(), QLatin1String("foo"));
976     i.reportFinished();
977 }
978 
979 /*
980     Test that results reported after finished are ignored.
981 */
982 void tst_QFuture::resultsAfterFinished()
983 {
984     {
985         IntResult a;
986         a.reportStarted();
987         QFuture<int> f =  a.future();
988         int result;
989 
990         QCOMPARE(f.resultCount(), 0);
991 
992         result = 1;
993         a.reportResult(&result);
994         QCOMPARE(f.resultAt(0), 1);
995 
996         a.reportFinished();
997 
998         QCOMPARE(f.resultAt(0), 1);
999         QCOMPARE(f.resultCount(), 1);
1000         result = 2;
1001         a.reportResult(&result);
1002         QCOMPARE(f.resultCount(), 1);
1003     }
1004     // cancel it
1005     {
1006         IntResult a;
1007         a.reportStarted();
1008         QFuture<int> f =  a.future();
1009         int result;
1010 
1011         QCOMPARE(f.resultCount(), 0);
1012 
1013         result = 1;
1014         a.reportResult(&result);
1015         QCOMPARE(f.resultAt(0), 1);
1016         QCOMPARE(f.resultCount(), 1);
1017 
1018         a.reportCanceled();
1019 
1020         QCOMPARE(f.resultAt(0), 1);
1021         QCOMPARE(f.resultCount(), 1);
1022 
1023         result = 2;
1024         a.reportResult(&result);
1025         a.reportFinished();
1026     }
1027 }
1028 
1029 void tst_QFuture::resultsAsList()
1030 {
1031     IntResult a;
1032     a.reportStarted();
1033     QFuture<int> f = a.future();
1034 
1035     int result;
1036     result = 1;
1037     a.reportResult(&result);
1038     result = 2;
1039     a.reportResult(&result);
1040 
1041     a.reportFinished();
1042 
1043     QList<int> results = f.results();
1044     QCOMPARE(results, QList<int>() << 1 << 2);
1045 }
1046 
1047 /*
1048     Test that QFuture<T> can be implicitly converted to T
1049 */
1050 void tst_QFuture::implicitConversions()
1051 {
1052     QFutureInterface<QString> iface;
1053     iface.reportStarted();
1054 
1055     QFuture<QString> f(&iface);
1056 
1057     const QString input("FooBar 2000");
1058     iface.reportFinished(&input);
1059 
1060     const QString result = f;
1061     QCOMPARE(result, input);
1062     QCOMPARE(QString(f), input);
1063     QCOMPARE(static_cast<QString>(f), input);
1064 }
1065 
1066 void tst_QFuture::iterators()
1067 {
1068     {
1069         QFutureInterface<int> e;
1070         e.reportStarted();
1071         QFuture<int> f = e.future();
1072 
1073         int result;
1074         result = 1;
1075         e.reportResult(&result);
1076         result = 2;
1077         e.reportResult(&result);
1078         result = 3;
1079         e.reportResult(&result);
1080         e.reportFinished();
1081 
1082         QList<int> results;
1083         QFutureIterator<int> i(f);
1084         while (i.hasNext()) {
1085             results.append(i.next());
1086         }
1087 
1088         QCOMPARE(results, f.results());
1089 
1090         QFuture<int>::const_iterator i1 = f.begin(), i2 = i1 + 1;
1091         QFuture<int>::const_iterator c1 = i1, c2 = c1 + 1;
1092 
1093         QCOMPARE(i1, i1);
1094         QCOMPARE(i1, c1);
1095         QCOMPARE(c1, i1);
1096         QCOMPARE(c1, c1);
1097         QCOMPARE(i2, i2);
1098         QCOMPARE(i2, c2);
1099         QCOMPARE(c2, i2);
1100         QCOMPARE(c2, c2);
1101         QCOMPARE(1 + i1, i1 + 1);
1102         QCOMPARE(1 + c1, c1 + 1);
1103 
1104         QVERIFY(i1 != i2);
1105         QVERIFY(i1 != c2);
1106         QVERIFY(c1 != i2);
1107         QVERIFY(c1 != c2);
1108         QVERIFY(i2 != i1);
1109         QVERIFY(i2 != c1);
1110         QVERIFY(c2 != i1);
1111         QVERIFY(c2 != c1);
1112 
1113         int x1 = *i1;
1114         Q_UNUSED(x1);
1115         int x2 = *i2;
1116         Q_UNUSED(x2);
1117         int y1 = *c1;
1118         Q_UNUSED(y1);
1119         int y2 = *c2;
1120         Q_UNUSED(y2);
1121     }
1122 
1123     {
1124         QFutureInterface<QString> e;
1125         e.reportStarted();
1126         QFuture<QString> f =  e.future();
1127 
1128         e.reportResult(QString("one"));
1129         e.reportResult(QString("two"));
1130         e.reportResult(QString("three"));
1131         e.reportFinished();
1132 
1133         QList<QString> results;
1134         QFutureIterator<QString> i(f);
1135         while (i.hasNext()) {
1136             results.append(i.next());
1137         }
1138 
1139         QCOMPARE(results, f.results());
1140 
1141         QFuture<QString>::const_iterator i1 = f.begin(), i2 = i1 + 1;
1142         QFuture<QString>::const_iterator c1 = i1, c2 = c1 + 1;
1143 
1144         QCOMPARE(i1, i1);
1145         QCOMPARE(i1, c1);
1146         QCOMPARE(c1, i1);
1147         QCOMPARE(c1, c1);
1148         QCOMPARE(i2, i2);
1149         QCOMPARE(i2, c2);
1150         QCOMPARE(c2, i2);
1151         QCOMPARE(c2, c2);
1152         QCOMPARE(1 + i1, i1 + 1);
1153         QCOMPARE(1 + c1, c1 + 1);
1154 
1155         QVERIFY(i1 != i2);
1156         QVERIFY(i1 != c2);
1157         QVERIFY(c1 != i2);
1158         QVERIFY(c1 != c2);
1159         QVERIFY(i2 != i1);
1160         QVERIFY(i2 != c1);
1161         QVERIFY(c2 != i1);
1162         QVERIFY(c2 != c1);
1163 
1164         QString x1 = *i1;
1165         QString x2 = *i2;
1166         QString y1 = *c1;
1167         QString y2 = *c2;
1168 
1169         QCOMPARE(x1, y1);
1170         QCOMPARE(x2, y2);
1171 
1172         int i1Size = i1->size();
1173         int i2Size = i2->size();
1174         int c1Size = c1->size();
1175         int c2Size = c2->size();
1176 
1177         QCOMPARE(i1Size, c1Size);
1178         QCOMPARE(i2Size, c2Size);
1179     }
1180 
1181     {
1182         const int resultCount = 20;
1183 
1184         QFutureInterface<int> e;
1185         e.reportStarted();
1186         QFuture<int> f =  e.future();
1187 
1188         for (int i = 0; i < resultCount; ++i) {
1189             e.reportResult(i);
1190         }
1191 
1192         e.reportFinished();
1193 
1194         {
1195             QFutureIterator<int> it(f);
1196             QFutureIterator<int> it2(it);
1197         }
1198 
1199         {
1200             QFutureIterator<int> it(f);
1201 
1202             for (int i = 0; i < resultCount - 1; ++i) {
1203                 QVERIFY(it.hasNext());
1204                 QCOMPARE(it.peekNext(), i);
1205                 QCOMPARE(it.next(), i);
1206             }
1207 
1208             QVERIFY(it.hasNext());
1209             QCOMPARE(it.peekNext(), resultCount - 1);
1210             QCOMPARE(it.next(), resultCount - 1);
1211             QVERIFY(!it.hasNext());
1212         }
1213 
1214         {
1215             QFutureIterator<int> it(f);
1216             QVERIFY(it.hasNext());
1217             it.toBack();
1218             QVERIFY(!it.hasNext());
1219             it.toFront();
1220             QVERIFY(it.hasNext());
1221         }
1222     }
1223 }
1224 void tst_QFuture::iteratorsThread()
1225 {
1226     const int expectedResultCount = 10;
1227     QFutureInterface<int> futureInterface;
1228 
1229     // Create result producer thread. The results are
1230     // produced with delays in order to make the consumer
1231     // wait.
1232     QSemaphore sem;
1233     LambdaThread thread = {[=, &futureInterface, &sem](){
1234         for (int i = 1; i <= expectedResultCount; i += 2) {
1235             int result = i;
1236             futureInterface.reportResult(&result);
1237             result = i + 1;
1238             futureInterface.reportResult(&result);
1239         }
1240 
1241         sem.acquire(2);
1242         futureInterface.reportFinished();
1243     }};
1244 
1245     futureInterface.reportStarted();
1246     QFuture<int> future = futureInterface.future();
1247 
1248     // Iterate over results while the thread is producing them.
1249     thread.start();
1250     int resultCount = 0;
1251     int resultSum = 0;
1252     for (int result : future) {
1253         sem.release();
1254         ++resultCount;
1255         resultSum += result;
1256     }
1257     thread.wait();
1258 
1259     QCOMPARE(resultCount, expectedResultCount);
1260     QCOMPARE(resultSum, expectedResultCount * (expectedResultCount + 1) / 2);
1261 
1262     // Reverse iterate
1263     resultSum = 0;
1264     QFutureIterator<int> it(future);
1265     it.toBack();
1266     while (it.hasPrevious())
1267         resultSum += it.previous();
1268 
1269     QCOMPARE(resultSum, expectedResultCount * (expectedResultCount + 1) / 2);
1270 }
1271 
1272 class SignalSlotObject : public QObject
1273 {
1274 Q_OBJECT
1275 public:
1276     SignalSlotObject()
1277     : finishedCalled(false),
1278       canceledCalled(false),
1279       rangeBegin(0),
1280       rangeEnd(0) { }
1281 
1282 public slots:
1283     void finished()
1284     {
1285         finishedCalled = true;
1286     }
1287 
1288     void canceled()
1289     {
1290         canceledCalled = true;
1291     }
1292 
1293     void resultReady(int index)
1294     {
1295         results.insert(index);
1296     }
1297 
1298     void progressRange(int begin, int end)
1299     {
1300         rangeBegin = begin;
1301         rangeEnd = end;
1302     }
1303 
1304     void progress(int progress)
1305     {
1306         reportedProgress.insert(progress);
1307     }
1308 public:
1309     bool finishedCalled;
1310     bool canceledCalled;
1311     QSet<int> results;
1312     int rangeBegin;
1313     int rangeEnd;
1314     QSet<int> reportedProgress;
1315 };
1316 
1317 void tst_QFuture::pause()
1318 {
1319     QFutureInterface<void> Interface;
1320 
1321     Interface.reportStarted();
1322     QFuture<void> f = Interface.future();
1323 
1324     QVERIFY(!Interface.isPaused());
1325     f.pause();
1326     QVERIFY(Interface.isPaused());
1327     f.resume();
1328     QVERIFY(!Interface.isPaused());
1329     f.togglePaused();
1330     QVERIFY(Interface.isPaused());
1331     f.togglePaused();
1332     QVERIFY(!Interface.isPaused());
1333 
1334     Interface.reportFinished();
1335 }
1336 
1337 class ResultObject : public QObject
1338 {
1339 Q_OBJECT
1340 public slots:
1341     void resultReady(int)
1342     {
1343 
1344     }
1345 public:
1346 };
1347 
1348 // Test that that the isPaused() on future result interface returns true
1349 // if we report a lot of results that are not handled.
1350 void tst_QFuture::throttling()
1351 {
1352     {
1353         QFutureInterface<void> i;
1354 
1355         i.reportStarted();
1356         QFuture<void> f = i.future();
1357 
1358         QVERIFY(!i.isThrottled());
1359 
1360         i.setThrottled(true);
1361         QVERIFY(i.isThrottled());
1362 
1363         i.setThrottled(false);
1364         QVERIFY(!i.isThrottled());
1365 
1366         i.setThrottled(true);
1367         QVERIFY(i.isThrottled());
1368 
1369         i.reportFinished();
1370     }
1371 }
1372 
1373 void tst_QFuture::voidConversions()
1374 {
1375     {
1376         QFutureInterface<int> iface;
1377         iface.reportStarted();
1378 
1379         QFuture<int> intFuture(&iface);
1380         int value = 10;
1381         iface.reportFinished(&value);
1382 
1383         QFuture<void> voidFuture(intFuture);
1384         voidFuture = intFuture;
1385 
1386         QVERIFY(voidFuture == intFuture);
1387     }
1388 
1389     {
1390         QFuture<void> voidFuture;
1391         {
1392             QFutureInterface<QList<int> > iface;
1393             iface.reportStarted();
1394 
1395             QFuture<QList<int> > listFuture(&iface);
1396             iface.reportResult(QList<int>() << 1 << 2 << 3);
1397             voidFuture = listFuture;
1398         }
1399         QCOMPARE(voidFuture.resultCount(), 0);
1400     }
1401 }
1402 
1403 
1404 #ifndef QT_NO_EXCEPTIONS
1405 
1406 QFuture<void> createExceptionFuture()
1407 {
1408     QFutureInterface<void> i;
1409     i.reportStarted();
1410     QFuture<void> f = i.future();
1411 
1412     QException e;
1413     i.reportException(e);
1414     i.reportFinished();
1415     return f;
1416 }
1417 
1418 QFuture<int> createExceptionResultFuture()
1419 {
1420     QFutureInterface<int> i;
1421     i.reportStarted();
1422     QFuture<int> f = i.future();
1423     int r = 0;
1424     i.reportResult(r);
1425 
1426     QException e;
1427     i.reportException(e);
1428     i.reportFinished();
1429     return f;
1430 }
1431 
1432 class DerivedException : public QException
1433 {
1434 public:
1435     void raise() const override { throw *this; }
1436     DerivedException *clone() const override { return new DerivedException(*this); }
1437 };
1438 
1439 QFuture<void> createDerivedExceptionFuture()
1440 {
1441     QFutureInterface<void> i;
1442     i.reportStarted();
1443     QFuture<void> f = i.future();
1444 
1445     DerivedException e;
1446     i.reportException(e);
1447     i.reportFinished();
1448     return f;
1449 }
1450 
1451 struct TestException
1452 {
1453 };
1454 
1455 QFuture<int> createCustomExceptionFuture()
1456 {
1457     QFutureInterface<int> i;
1458     i.reportStarted();
1459     QFuture<int> f = i.future();
1460     int r = 0;
1461     i.reportResult(r);
1462     auto exception = std::make_exception_ptr(TestException());
1463     i.reportException(exception);
1464     i.reportFinished();
1465     return f;
1466 }
1467 
1468 void tst_QFuture::exceptions()
1469 {
1470     // test throwing from waitForFinished
1471     {
1472         QFuture<void> f = createExceptionFuture();
1473         bool caught = false;
1474         try {
1475             f.waitForFinished();
1476         } catch (QException &) {
1477             caught = true;
1478         }
1479         QVERIFY(caught);
1480     }
1481 
1482     // test result()
1483     {
1484         QFuture<int> f = createExceptionResultFuture();
1485         bool caught = false;
1486         try {
1487             f.result();
1488         } catch (QException &) {
1489             caught = true;
1490         }
1491         QVERIFY(caught);
1492     }
1493 
1494     // test result() and destroy
1495     {
1496         bool caught = false;
1497         try {
1498             createExceptionResultFuture().result();
1499         } catch (QException &) {
1500             caught = true;
1501         }
1502         QVERIFY(caught);
1503     }
1504 
1505     // test results()
1506     {
1507         QFuture<int> f = createExceptionResultFuture();
1508         bool caught = false;
1509         try {
1510             f.results();
1511         } catch (QException &) {
1512             caught = true;
1513         }
1514         QVERIFY(caught);
1515     }
1516 
1517     // test foreach
1518     {
1519         QFuture<int> f = createExceptionResultFuture();
1520         bool caught = false;
1521         try {
1522             foreach (int e, f.results()) {
1523                 Q_UNUSED(e);
1524                 QFAIL("did not get exception");
1525             }
1526         } catch (QException &) {
1527             caught = true;
1528         }
1529         QVERIFY(caught);
1530     }
1531 
1532     // catch derived exceptions
1533     {
1534         bool caught = false;
1535         try {
1536             createDerivedExceptionFuture().waitForFinished();
1537         } catch (QException &) {
1538             caught = true;
1539         }
1540         QVERIFY(caught);
1541     }
1542 
1543     {
1544         bool caught = false;
1545         try {
1546             createDerivedExceptionFuture().waitForFinished();
1547         } catch (DerivedException &) {
1548             caught = true;
1549         }
1550         QVERIFY(caught);
1551     }
1552 
1553     // Custom exceptions
1554     {
1555         QFuture<int> f = createCustomExceptionFuture();
1556         bool caught = false;
1557         try {
1558             f.result();
1559         } catch (const TestException &) {
1560             caught = true;
1561         }
1562         QVERIFY(caught);
1563     }
1564 }
1565 
1566 class MyClass
1567 {
1568 public:
1569     ~MyClass()
1570     {
1571         QFuture<void> f = createExceptionFuture();
1572         try {
1573             f.waitForFinished();
1574         } catch (QException &) {
1575             caught = true;
1576         }
1577     }
1578     static bool caught;
1579 };
1580 
1581 bool MyClass::caught = false;
1582 
1583 // This is a regression test for QTBUG-18149. where QFuture did not throw
1584 // exceptions if called from destructors when the stack was already unwinding
1585 // due to an exception having been thrown.
1586 void tst_QFuture::nestedExceptions()
1587 {
1588     try {
1589         MyClass m;
1590         Q_UNUSED(m);
1591         throw 0;
1592     } catch (int) {}
1593 
1594     QVERIFY(MyClass::caught);
1595 }
1596 
1597 #endif // QT_NO_EXCEPTIONS
1598 
1599 void tst_QFuture::nonGlobalThreadPool()
1600 {
1601     static Q_CONSTEXPR int Answer = 42;
1602 
1603     struct UselessTask : QRunnable, QFutureInterface<int>
1604     {
1605         QFuture<int> start(QThreadPool *pool)
1606         {
1607             setRunnable(this);
1608             setThreadPool(pool);
1609             reportStarted();
1610             QFuture<int> f = future();
1611             pool->start(this);
1612             return f;
1613         }
1614 
1615         void run() override
1616         {
1617             const int ms = 100 + (QRandomGenerator::global()->bounded(100) - 100/2);
1618             QThread::msleep(ms);
1619             reportResult(Answer);
1620             reportFinished();
1621         }
1622     };
1623 
1624     QThreadPool pool;
1625 
1626     const int numTasks = QThread::idealThreadCount();
1627 
1628     QVector<QFuture<int> > futures;
1629     futures.reserve(numTasks);
1630 
1631     for (int i = 0; i < numTasks; ++i)
1632         futures.push_back((new UselessTask)->start(&pool));
1633 
1634     QVERIFY(!pool.waitForDone(0)); // pool is busy (meaning our tasks did end up executing there)
1635 
1636     QVERIFY(pool.waitForDone(10000)); // max sleep time in UselessTask::run is 150ms, so 10s should be enough
1637                                       // (and the call returns as soon as all tasks finished anyway, so the
1638                                       // maximum wait time only matters when the test fails)
1639 
1640     Q_FOREACH (const QFuture<int> &future, futures) {
1641         QVERIFY(future.isFinished());
1642         QCOMPARE(future.result(), Answer);
1643     }
1644 }
1645 
1646 void tst_QFuture::then()
1647 {
1648     {
1649         struct Add
1650         {
1651 
1652             static int addTwo(int arg) { return arg + 2; }
1653 
1654             int operator()(int arg) const { return arg + 3; }
1655         };
1656 
1657         QFutureInterface<int> promise;
1658         QFuture<int> then = promise.future()
1659                                     .then([](int res) { return res + 1; }) // lambda
1660                                     .then(Add::addTwo) // function
1661                                     .then(Add()); // functor
1662 
1663         promise.reportStarted();
1664         QVERIFY(!then.isStarted());
1665         QVERIFY(!then.isFinished());
1666 
1667         const int result = 0;
1668         promise.reportResult(result);
1669         promise.reportFinished();
1670 
1671         then.waitForFinished();
1672 
1673         QVERIFY(then.isStarted());
1674         QVERIFY(then.isFinished());
1675         QCOMPARE(then.result(), result + 6);
1676     }
1677 
1678     // then() on a ready future
1679     {
1680         QFutureInterface<int> promise;
1681         promise.reportStarted();
1682 
1683         const int result = 0;
1684         promise.reportResult(result);
1685         promise.reportFinished();
1686 
1687         QFuture<int> then = promise.future()
1688                                     .then([](int res1) { return res1 + 1; })
1689                                     .then([](int res2) { return res2 + 2; })
1690                                     .then([](int res3) { return res3 + 3; });
1691 
1692         then.waitForFinished();
1693 
1694         QVERIFY(then.isStarted());
1695         QVERIFY(then.isFinished());
1696         QCOMPARE(then.result(), result + 6);
1697     }
1698 
1699     // Continuation of QFuture<void>
1700     {
1701         int result = 0;
1702         QFutureInterface<void> promise;
1703         QFuture<void> then = promise.future()
1704                                      .then([&]() { result += 1; })
1705                                      .then([&]() { result += 2; })
1706                                      .then([&]() { result += 3; });
1707 
1708         promise.reportStarted();
1709         QVERIFY(!then.isStarted());
1710         QVERIFY(!then.isFinished());
1711         promise.reportFinished();
1712 
1713         then.waitForFinished();
1714 
1715         QVERIFY(then.isStarted());
1716         QVERIFY(then.isFinished());
1717         QCOMPARE(result, 6);
1718     }
1719 
1720     // Continuation returns QFuture<void>
1721     {
1722         QFutureInterface<int> promise;
1723         int value;
1724         QFuture<void> then =
1725                 promise.future().then([](int res) { return res * 2; }).then([&](int prevResult) {
1726                     value = prevResult;
1727                 });
1728 
1729         promise.reportStarted();
1730         QVERIFY(!then.isStarted());
1731         QVERIFY(!then.isFinished());
1732 
1733         const int result = 5;
1734         promise.reportResult(result);
1735         promise.reportFinished();
1736 
1737         then.waitForFinished();
1738 
1739         QVERIFY(then.isStarted());
1740         QVERIFY(then.isFinished());
1741         QCOMPARE(value, result * 2);
1742     }
1743 
1744     // Continuations taking a QFuture argument.
1745     {
1746         int value = 0;
1747         QFutureInterface<int> promise;
1748         QFuture<void> then = promise.future()
1749                                      .then([](QFuture<int> f1) { return f1.result() + 1; })
1750                                      .then([&](QFuture<int> f2) { value = f2.result() + 2; })
1751                                      .then([&](QFuture<void> f3) {
1752                                          QVERIFY(f3.isFinished());
1753                                          value += 3;
1754                                      });
1755 
1756         promise.reportStarted();
1757         QVERIFY(!then.isStarted());
1758         QVERIFY(!then.isFinished());
1759 
1760         const int result = 0;
1761         promise.reportResult(result);
1762         promise.reportFinished();
1763 
1764         then.waitForFinished();
1765 
1766         QVERIFY(then.isStarted());
1767         QVERIFY(then.isFinished());
1768         QCOMPARE(value, 6);
1769     }
1770 
1771     // Continuations use a new thread
1772     {
1773         Qt::HANDLE threadId1 = nullptr;
1774         Qt::HANDLE threadId2 = nullptr;
1775         QFutureInterface<void> promise;
1776         QFuture<void> then = promise.future()
1777                                      .then(QtFuture::Launch::Async,
1778                                            [&]() { threadId1 = QThread::currentThreadId(); })
1779                                      .then([&]() { threadId2 = QThread::currentThreadId(); });
1780 
1781         promise.reportStarted();
1782         QVERIFY(!then.isStarted());
1783         QVERIFY(!then.isFinished());
1784 
1785         promise.reportFinished();
1786 
1787         then.waitForFinished();
1788 
1789         QVERIFY(then.isStarted());
1790         QVERIFY(then.isFinished());
1791         QVERIFY(threadId1 != QThread::currentThreadId());
1792         QVERIFY(threadId2 != QThread::currentThreadId());
1793         QVERIFY(threadId1 == threadId2);
1794     }
1795 
1796     // Continuation inherits the launch policy of its parent (QtFuture::Launch::Sync)
1797     {
1798         Qt::HANDLE threadId1 = nullptr;
1799         Qt::HANDLE threadId2 = nullptr;
1800         QFutureInterface<void> promise;
1801         QFuture<void> then = promise.future()
1802                                      .then(QtFuture::Launch::Sync,
1803                                            [&]() { threadId1 = QThread::currentThreadId(); })
1804                                      .then(QtFuture::Launch::Inherit,
1805                                            [&]() { threadId2 = QThread::currentThreadId(); });
1806 
1807         promise.reportStarted();
1808         QVERIFY(!then.isStarted());
1809         QVERIFY(!then.isFinished());
1810 
1811         promise.reportFinished();
1812 
1813         then.waitForFinished();
1814 
1815         QVERIFY(then.isStarted());
1816         QVERIFY(then.isFinished());
1817         QVERIFY(threadId1 == QThread::currentThreadId());
1818         QVERIFY(threadId2 == QThread::currentThreadId());
1819         QVERIFY(threadId1 == threadId2);
1820     }
1821 
1822     // Continuation inherits the launch policy of its parent (QtFuture::Launch::Async)
1823     {
1824         Qt::HANDLE threadId1 = nullptr;
1825         Qt::HANDLE threadId2 = nullptr;
1826         QFutureInterface<void> promise;
1827         QFuture<void> then = promise.future()
1828                                      .then(QtFuture::Launch::Async,
1829                                            [&]() { threadId1 = QThread::currentThreadId(); })
1830                                      .then(QtFuture::Launch::Inherit,
1831                                            [&]() { threadId2 = QThread::currentThreadId(); });
1832 
1833         promise.reportStarted();
1834         QVERIFY(!then.isStarted());
1835         QVERIFY(!then.isFinished());
1836 
1837         promise.reportFinished();
1838 
1839         then.waitForFinished();
1840 
1841         QVERIFY(then.isStarted());
1842         QVERIFY(then.isFinished());
1843         QVERIFY(threadId1 != QThread::currentThreadId());
1844         QVERIFY(threadId2 != QThread::currentThreadId());
1845     }
1846 
1847     // Continuations use a custom thread pool
1848     {
1849         QFutureInterface<void> promise;
1850         QThreadPool pool;
1851         QVERIFY(pool.waitForDone(0)); // pool is not busy yet
1852         QSemaphore semaphore;
1853         QFuture<void> then = promise.future().then(&pool, [&]() { semaphore.acquire(); });
1854 
1855         promise.reportStarted();
1856         promise.reportFinished();
1857 
1858         // Make sure the custom thread pool is busy on running the continuation
1859         QVERIFY(!pool.waitForDone(0));
1860         semaphore.release();
1861         then.waitForFinished();
1862 
1863         QVERIFY(then.isStarted());
1864         QVERIFY(then.isFinished());
1865         QCOMPARE(then.d.threadPool(), &pool);
1866     }
1867 
1868     // Continuation inherits parent's thread pool
1869     {
1870         Qt::HANDLE threadId1 = nullptr;
1871         Qt::HANDLE threadId2 = nullptr;
1872         QFutureInterface<void> promise;
1873 
1874         QThreadPool pool;
1875         QFuture<void> then1 = promise.future().then(&pool, [&]() {
1876             threadId1 = QThread::currentThreadId();
1877         });
1878 
1879         promise.reportStarted();
1880         promise.reportFinished();
1881 
1882         then1.waitForFinished();
1883         QVERIFY(pool.waitForDone()); // The pool is not busy after the first continuation is done
1884 
1885         QSemaphore semaphore;
1886         QFuture<void> then2 = then1.then(QtFuture::Launch::Inherit, [&]() {
1887             semaphore.acquire();
1888             threadId2 = QThread::currentThreadId();
1889         });
1890 
1891         QVERIFY(!pool.waitForDone(0)); // The pool is busy running the 2nd continuation
1892 
1893         semaphore.release();
1894         then2.waitForFinished();
1895 
1896         QVERIFY(then2.isStarted());
1897         QVERIFY(then2.isFinished());
1898         QCOMPARE(then1.d.threadPool(), then2.d.threadPool());
1899         QCOMPARE(then2.d.threadPool(), &pool);
1900         QVERIFY(threadId1 != QThread::currentThreadId());
1901         QVERIFY(threadId2 != QThread::currentThreadId());
1902     }
1903 }
1904 
1905 template<class Type, class Callable>
1906 bool runThenForMoveOnly(Callable &&callable)
1907 {
1908     QFutureInterface<Type> promise;
1909     auto future = promise.future();
1910 
1911     auto then = future.then(std::forward<Callable>(callable));
1912 
1913     promise.reportStarted();
1914     if constexpr (!std::is_same_v<Type, void>)
1915         promise.reportAndMoveResult(std::make_unique<int>(42));
1916     promise.reportFinished();
1917     then.waitForFinished();
1918 
1919     bool success = true;
1920     if constexpr (!std::is_same_v<decltype(then), QFuture<void>>)
1921         success &= *then.takeResult() == 42;
1922 
1923     if constexpr (!std::is_same_v<Type, void>)
1924         success &= !future.isValid();
1925 
1926     return success;
1927 }
1928 
1929 void tst_QFuture::thenForMoveOnlyTypes()
1930 {
1931     QVERIFY(runThenForMoveOnly<UniquePtr>([](UniquePtr res) { return res; }));
1932     QVERIFY(runThenForMoveOnly<UniquePtr>([](UniquePtr res) { Q_UNUSED(res); }));
1933     QVERIFY(runThenForMoveOnly<UniquePtr>([](QFuture<UniquePtr> res) { return res.takeResult(); }));
1934     QVERIFY(runThenForMoveOnly<void>([] { return std::make_unique<int>(42); }));
1935 }
1936 
1937 template<class T>
1938 QFuture<T> createCanceledFuture()
1939 {
1940     QFutureInterface<T> promise;
1941     promise.reportStarted();
1942     promise.reportCanceled();
1943     promise.reportFinished();
1944     return promise.future();
1945 }
1946 
1947 void tst_QFuture::thenOnCanceledFuture()
1948 {
1949     // Continuations on a canceled future
1950     {
1951         int thenResult = 0;
1952         QFuture<void> then = createCanceledFuture<void>().then([&]() { ++thenResult; }).then([&]() {
1953             ++thenResult;
1954         });
1955 
1956         QVERIFY(then.isCanceled());
1957         QCOMPARE(thenResult, 0);
1958     }
1959 
1960     // QFuture gets canceled after continuations are set
1961     {
1962         QFutureInterface<void> promise;
1963 
1964         int thenResult = 0;
1965         QFuture<void> then =
1966                 promise.future().then([&]() { ++thenResult; }).then([&]() { ++thenResult; });
1967 
1968         promise.reportStarted();
1969         promise.reportCanceled();
1970         promise.reportFinished();
1971 
1972         QVERIFY(then.isCanceled());
1973         QCOMPARE(thenResult, 0);
1974     }
1975 
1976     // Same with QtFuture::Launch::Async
1977 
1978     // Continuations on a canceled future
1979     {
1980         int thenResult = 0;
1981         QFuture<void> then = createCanceledFuture<void>()
1982                                      .then(QtFuture::Launch::Async, [&]() { ++thenResult; })
1983                                      .then([&]() { ++thenResult; });
1984 
1985         QVERIFY(then.isCanceled());
1986         QCOMPARE(thenResult, 0);
1987     }
1988 
1989     // QFuture gets canceled after continuations are set
1990     {
1991         QFutureInterface<void> promise;
1992 
1993         int thenResult = 0;
1994         QFuture<void> then =
1995                 promise.future().then(QtFuture::Launch::Async, [&]() { ++thenResult; }).then([&]() {
1996                     ++thenResult;
1997                 });
1998 
1999         promise.reportStarted();
2000         promise.reportCanceled();
2001         promise.reportFinished();
2002 
2003         QVERIFY(then.isCanceled());
2004         QCOMPARE(thenResult, 0);
2005     }
2006 }
2007 
2008 #ifndef QT_NO_EXCEPTIONS
2009 void tst_QFuture::thenOnExceptionFuture()
2010 {
2011     {
2012         QFutureInterface<int> promise;
2013 
2014         int thenResult = 0;
2015         QFuture<void> then = promise.future().then([&](int res) { thenResult = res; });
2016 
2017         promise.reportStarted();
2018         QException e;
2019         promise.reportException(e);
2020         promise.reportFinished();
2021 
2022         bool caught = false;
2023         try {
2024             then.waitForFinished();
2025         } catch (QException &) {
2026             caught = true;
2027         }
2028         QVERIFY(caught);
2029         QCOMPARE(thenResult, 0);
2030     }
2031 
2032     // Exception handled inside the continuation
2033     {
2034         QFutureInterface<int> promise;
2035 
2036         bool caught = false;
2037         bool caughtByContinuation = false;
2038         bool success = false;
2039         int thenResult = 0;
2040         QFuture<void> then = promise.future()
2041                                      .then([&](QFuture<int> res) {
2042                                          try {
2043                                              thenResult = res.result();
2044                                          } catch (QException &) {
2045                                              caughtByContinuation = true;
2046                                          }
2047                                      })
2048                                      .then([&]() { success = true; });
2049 
2050         promise.reportStarted();
2051         QException e;
2052         promise.reportException(e);
2053         promise.reportFinished();
2054 
2055         try {
2056             then.waitForFinished();
2057         } catch (QException &) {
2058             caught = true;
2059         }
2060 
2061         QCOMPARE(thenResult, 0);
2062         QVERIFY(!caught);
2063         QVERIFY(caughtByContinuation);
2064         QVERIFY(success);
2065     }
2066 
2067     // Exception future
2068     {
2069         QFutureInterface<int> promise;
2070         promise.reportStarted();
2071         QException e;
2072         promise.reportException(e);
2073         promise.reportFinished();
2074 
2075         int thenResult = 0;
2076         QFuture<void> then = promise.future().then([&](int res) { thenResult = res; });
2077 
2078         bool caught = false;
2079         try {
2080             then.waitForFinished();
2081         } catch (QException &) {
2082             caught = true;
2083         }
2084         QVERIFY(caught);
2085         QCOMPARE(thenResult, 0);
2086     }
2087 
2088     // Same with QtFuture::Launch::Async
2089     {
2090         QFutureInterface<int> promise;
2091 
2092         int thenResult = 0;
2093         QFuture<void> then =
2094                 promise.future().then(QtFuture::Launch::Async, [&](int res) { thenResult = res; });
2095 
2096         promise.reportStarted();
2097         QException e;
2098         promise.reportException(e);
2099         promise.reportFinished();
2100 
2101         bool caught = false;
2102         try {
2103             then.waitForFinished();
2104         } catch (QException &) {
2105             caught = true;
2106         }
2107         QVERIFY(caught);
2108         QCOMPARE(thenResult, 0);
2109     }
2110 
2111     // Exception future
2112     {
2113         QFutureInterface<int> promise;
2114         promise.reportStarted();
2115         QException e;
2116         promise.reportException(e);
2117         promise.reportFinished();
2118 
2119         int thenResult = 0;
2120         QFuture<void> then =
2121                 promise.future().then(QtFuture::Launch::Async, [&](int res) { thenResult = res; });
2122 
2123         bool caught = false;
2124         try {
2125             then.waitForFinished();
2126         } catch (QException &) {
2127             caught = true;
2128         }
2129         QVERIFY(caught);
2130         QCOMPARE(thenResult, 0);
2131     }
2132 }
2133 
2134 template<class Exception, bool hasTestMsg = false>
2135 QFuture<void> createExceptionContinuation(QtFuture::Launch policy = QtFuture::Launch::Sync)
2136 {
2137     QFutureInterface<void> promise;
2138 
2139     auto then = promise.future().then(policy, [] {
2140         if constexpr (hasTestMsg)
2141             throw Exception("TEST");
2142         else
2143             throw Exception();
2144     });
2145 
2146     promise.reportStarted();
2147     promise.reportFinished();
2148 
2149     return then;
2150 }
2151 
2152 void tst_QFuture::thenThrows()
2153 {
2154     // Continuation throws a QException
2155     {
2156         auto future = createExceptionContinuation<QException>();
2157 
2158         bool caught = false;
2159         try {
2160             future.waitForFinished();
2161         } catch (const QException &) {
2162             caught = true;
2163         }
2164         QVERIFY(caught);
2165     }
2166 
2167     // Continuation throws an exception derived from QException
2168     {
2169         auto future = createExceptionContinuation<DerivedException>();
2170 
2171         bool caught = false;
2172         try {
2173             future.waitForFinished();
2174         } catch (const QException &) {
2175             caught = true;
2176         } catch (const std::exception &) {
2177             QFAIL("The exception should be caught by the above catch block.");
2178         }
2179 
2180         QVERIFY(caught);
2181     }
2182 
2183     // Continuation throws std::exception
2184     {
2185         auto future = createExceptionContinuation<std::runtime_error, true>();
2186 
2187         bool caught = false;
2188         try {
2189             future.waitForFinished();
2190         } catch (const QException &) {
2191             QFAIL("The exception should be caught by the below catch block.");
2192         } catch (const std::exception &e) {
2193             QCOMPARE(e.what(), "TEST");
2194             caught = true;
2195         }
2196 
2197         QVERIFY(caught);
2198     }
2199 
2200     // Same with QtFuture::Launch::Async
2201     {
2202         auto future = createExceptionContinuation<QException>(QtFuture::Launch::Async);
2203 
2204         bool caught = false;
2205         try {
2206             future.waitForFinished();
2207         } catch (const QException &) {
2208             caught = true;
2209         }
2210         QVERIFY(caught);
2211     }
2212 }
2213 
2214 void tst_QFuture::onFailed()
2215 {
2216     // Ready exception void future
2217     {
2218         int checkpoint = 0;
2219         auto future = createExceptionFuture().then([&] { checkpoint = 1; }).onFailed([&] {
2220             checkpoint = 2;
2221         });
2222 
2223         try {
2224             future.waitForFinished();
2225         } catch (...) {
2226             checkpoint = 3;
2227         }
2228         QCOMPARE(checkpoint, 2);
2229     }
2230 
2231     // std::exception handler
2232     {
2233         QFutureInterface<int> promise;
2234 
2235         int checkpoint = 0;
2236         auto then = promise.future()
2237                             .then([&](int res) {
2238                                 throw std::exception();
2239                                 return res;
2240                             })
2241                             .then([&](int res) { return res + 1; })
2242                             .onFailed([&](const QException &) {
2243                                 checkpoint = 1;
2244                                 return -1;
2245                             })
2246                             .onFailed([&](const std::exception &) {
2247                                 checkpoint = 2;
2248                                 return -1;
2249                             })
2250                             .onFailed([&] {
2251                                 checkpoint = 3;
2252                                 return -1;
2253                             });
2254 
2255         promise.reportStarted();
2256         promise.reportResult(1);
2257         promise.reportFinished();
2258 
2259         int res = 0;
2260         try {
2261             res = then.result();
2262         } catch (...) {
2263             checkpoint = 4;
2264         }
2265         QCOMPARE(checkpoint, 2);
2266         QCOMPARE(res, -1);
2267     }
2268 
2269     // then() throws an exception derived from QException
2270     {
2271         QFutureInterface<int> promise;
2272 
2273         int checkpoint = 0;
2274         auto then = promise.future()
2275                             .then([&](int res) {
2276                                 throw DerivedException();
2277                                 return res;
2278                             })
2279                             .then([&](int res) { return res + 1; })
2280                             .onFailed([&](const QException &) {
2281                                 checkpoint = 1;
2282                                 return -1;
2283                             })
2284                             .onFailed([&](const std::exception &) {
2285                                 checkpoint = 2;
2286                                 return -1;
2287                             })
2288                             .onFailed([&] {
2289                                 checkpoint = 3;
2290                                 return -1;
2291                             });
2292 
2293         promise.reportStarted();
2294         promise.reportResult(1);
2295         promise.reportFinished();
2296 
2297         int res = 0;
2298         try {
2299             res = then.result();
2300         } catch (...) {
2301             checkpoint = 4;
2302         }
2303         QCOMPARE(checkpoint, 1);
2304         QCOMPARE(res, -1);
2305     }
2306 
2307     // then() throws a custom exception
2308     {
2309         QFutureInterface<int> promise;
2310 
2311         int checkpoint = 0;
2312         auto then = promise.future()
2313                             .then([&](int res) {
2314                                 throw TestException();
2315                                 return res;
2316                             })
2317                             .then([&](int res) { return res + 1; })
2318                             .onFailed([&](const QException &) {
2319                                 checkpoint = 1;
2320                                 return -1;
2321                             })
2322                             .onFailed([&](const std::exception &) {
2323                                 checkpoint = 2;
2324                                 return -1;
2325                             })
2326                             .onFailed([&] {
2327                                 checkpoint = 3;
2328                                 return -1;
2329                             });
2330 
2331         promise.reportStarted();
2332         promise.reportResult(1);
2333         promise.reportFinished();
2334 
2335         int res = 0;
2336         try {
2337             res = then.result();
2338         } catch (...) {
2339             checkpoint = 4;
2340         }
2341         QCOMPARE(checkpoint, 3);
2342         QCOMPARE(res, -1);
2343     }
2344 
2345     // Custom exception handler
2346     {
2347         struct TestException
2348         {
2349         };
2350 
2351         QFutureInterface<int> promise;
2352 
2353         int checkpoint = 0;
2354         auto then = promise.future()
2355                             .then([&](int res) {
2356                                 throw TestException();
2357                                 return res;
2358                             })
2359                             .then([&](int res) { return res + 1; })
2360                             .onFailed([&](const QException &) {
2361                                 checkpoint = 1;
2362                                 return -1;
2363                             })
2364                             .onFailed([&](const TestException &) {
2365                                 checkpoint = 2;
2366                                 return -1;
2367                             })
2368                             .onFailed([&] {
2369                                 checkpoint = 3;
2370                                 return -1;
2371                             });
2372 
2373         promise.reportStarted();
2374         promise.reportResult(1);
2375         promise.reportFinished();
2376 
2377         int res = 0;
2378         try {
2379             res = then.result();
2380         } catch (...) {
2381             checkpoint = 4;
2382         }
2383         QCOMPARE(checkpoint, 2);
2384         QCOMPARE(res, -1);
2385     }
2386 
2387     // Handle all exceptions
2388     {
2389         QFutureInterface<int> promise;
2390 
2391         int checkpoint = 0;
2392         auto then = promise.future()
2393                             .then([&](int res) {
2394                                 throw QException();
2395                                 return res;
2396                             })
2397                             .then([&](int res) { return res + 1; })
2398                             .onFailed([&] {
2399                                 checkpoint = 1;
2400                                 return -1;
2401                             })
2402                             .onFailed([&](const QException &) {
2403                                 checkpoint = 2;
2404                                 return -1;
2405                             });
2406 
2407         promise.reportStarted();
2408         promise.reportResult(1);
2409         promise.reportFinished();
2410 
2411         int res = 0;
2412         try {
2413             res = then.result();
2414         } catch (...) {
2415             checkpoint = 3;
2416         }
2417         QCOMPARE(checkpoint, 1);
2418         QCOMPARE(res, -1);
2419     }
2420 
2421     // Handler throws exception
2422     {
2423         QFutureInterface<int> promise;
2424 
2425         int checkpoint = 0;
2426         auto then = promise.future()
2427                             .then([&](int res) {
2428                                 throw QException();
2429                                 return res;
2430                             })
2431                             .then([&](int res) { return res + 1; })
2432                             .onFailed([&](const QException &) {
2433                                 checkpoint = 1;
2434                                 throw QException();
2435                                 return -1;
2436                             })
2437                             .onFailed([&] {
2438                                 checkpoint = 2;
2439                                 return -1;
2440                             });
2441 
2442         promise.reportStarted();
2443         promise.reportResult(1);
2444         promise.reportFinished();
2445 
2446         int res = 0;
2447         try {
2448             res = then.result();
2449         } catch (...) {
2450             checkpoint = 3;
2451         }
2452         QCOMPARE(checkpoint, 2);
2453         QCOMPARE(res, -1);
2454     }
2455 
2456     // No handler for exception
2457     {
2458         QFutureInterface<int> promise;
2459 
2460         int checkpoint = 0;
2461         auto then = promise.future()
2462                             .then([&](int res) {
2463                                 throw QException();
2464                                 return res;
2465                             })
2466                             .then([&](int res) { return res + 1; })
2467                             .onFailed([&](const std::exception &) {
2468                                 checkpoint = 1;
2469                                 throw std::exception();
2470                                 return -1;
2471                             })
2472                             .onFailed([&](QException &) {
2473                                 checkpoint = 2;
2474                                 return -1;
2475                             });
2476 
2477         promise.reportStarted();
2478         promise.reportResult(1);
2479         promise.reportFinished();
2480 
2481         int res = 0;
2482         try {
2483             res = then.result();
2484         } catch (...) {
2485             checkpoint = 3;
2486         }
2487         QCOMPARE(checkpoint, 3);
2488         QCOMPARE(res, 0);
2489     }
2490 
2491     // onFailed on a canceled future
2492     {
2493         auto future = createCanceledFuture<int>()
2494                               .then([](int) { return 42; })
2495                               .onCanceled([] { return -1; })
2496                               .onFailed([] { return -2; });
2497         QCOMPARE(future.result(), -1);
2498     }
2499 }
2500 
2501 template<class Callable>
2502 bool runForCallable(Callable &&handler)
2503 {
2504     QFuture<int> future = createExceptionResultFuture()
2505                                   .then([&](int) { return 1; })
2506                                   .onFailed(std::forward<Callable>(handler));
2507 
2508     int res = 0;
2509     try {
2510         res = future.result();
2511     } catch (...) {
2512         return false;
2513     }
2514     return res == -1;
2515 }
2516 
2517 int foo()
2518 {
2519     return -1;
2520 }
2521 
2522 void tst_QFuture::onFailedTestCallables()
2523 {
2524     QVERIFY(runForCallable([&] { return -1; }));
2525     QVERIFY(runForCallable(foo));
2526     QVERIFY(runForCallable(&foo));
2527 
2528     std::function<int()> func = foo;
2529     QVERIFY(runForCallable(func));
2530 
2531     struct Functor1
2532     {
2533         int operator()() { return -1; }
2534         static int foo() { return -1; }
2535     };
2536     QVERIFY(runForCallable(Functor1()));
2537     QVERIFY(runForCallable(Functor1::foo));
2538 
2539     struct Functor2
2540     {
2541         int operator()() const { return -1; }
2542         static int foo() { return -1; }
2543     };
2544     QVERIFY(runForCallable(Functor2()));
2545 
2546     struct Functor3
2547     {
2548         int operator()() const noexcept { return -1; }
2549         static int foo() { return -1; }
2550     };
2551     QVERIFY(runForCallable(Functor3()));
2552 }
2553 
2554 template<class Callable>
2555 bool runOnFailedForMoveOnly(Callable &&callable)
2556 {
2557     QFutureInterface<UniquePtr> promise;
2558     auto future = promise.future();
2559 
2560     auto failedFuture = future.onFailed(std::forward<Callable>(callable));
2561 
2562     promise.reportStarted();
2563     QException e;
2564     promise.reportException(e);
2565     promise.reportFinished();
2566 
2567     return *failedFuture.takeResult() == -1;
2568 }
2569 
2570 void tst_QFuture::onFailedForMoveOnlyTypes()
2571 {
2572     QVERIFY(runOnFailedForMoveOnly([](const QException &) { return std::make_unique<int>(-1); }));
2573     QVERIFY(runOnFailedForMoveOnly([] { return std::make_unique<int>(-1); }));
2574 }
2575 
2576 #endif // QT_NO_EXCEPTIONS
2577 
2578 void tst_QFuture::onCanceled()
2579 {
2580     // Canceled int future
2581     {
2582         auto future = createCanceledFuture<int>().then([](int) { return 42; }).onCanceled([] {
2583             return -1;
2584         });
2585         QCOMPARE(future.result(), -1);
2586     }
2587 
2588     // Canceled void future
2589     {
2590         int checkpoint = 0;
2591         auto future = createCanceledFuture<void>().then([&] { checkpoint = 42; }).onCanceled([&] {
2592             checkpoint = -1;
2593         });
2594         QCOMPARE(checkpoint, -1);
2595     }
2596 
2597     // onCanceled propagates result
2598     {
2599         QFutureInterface<int> promise;
2600         auto future =
2601                 promise.future().then([](int res) { return res; }).onCanceled([] { return -1; });
2602 
2603         promise.reportStarted();
2604         promise.reportResult(42);
2605         promise.reportFinished();
2606         QCOMPARE(future.result(), 42);
2607     }
2608 
2609     // onCanceled propagates move-only result
2610     {
2611         QFutureInterface<UniquePtr> promise;
2612         auto future = promise.future().then([](UniquePtr res) { return res; }).onCanceled([] {
2613             return std::make_unique<int>(-1);
2614         });
2615 
2616         promise.reportStarted();
2617         promise.reportAndMoveResult(std::make_unique<int>(42));
2618         promise.reportFinished();
2619         QCOMPARE(*future.takeResult(), 42);
2620     }
2621 
2622 #ifndef QT_NO_EXCEPTIONS
2623     // onCanceled propagates exceptions
2624     {
2625         QFutureInterface<int> promise;
2626         auto future = promise.future()
2627                               .then([](int res) {
2628                                   throw std::runtime_error("error");
2629                                   return res;
2630                               })
2631                               .onCanceled([] { return 2; })
2632                               .onFailed([] { return 3; });
2633 
2634         promise.reportStarted();
2635         promise.reportResult(1);
2636         promise.reportFinished();
2637         QCOMPARE(future.result(), 3);
2638     }
2639 
2640     // onCanceled throws
2641     {
2642         auto future = createCanceledFuture<int>()
2643                               .then([](int) { return 42; })
2644                               .onCanceled([] {
2645                                   throw std::runtime_error("error");
2646                                   return -1;
2647                               })
2648                               .onFailed([] { return -2; });
2649 
2650         QCOMPARE(future.result(), -2);
2651     }
2652 
2653 #endif // QT_NO_EXCEPTIONS
2654 }
2655 
2656 void tst_QFuture::testSingleResult(const UniquePtr &p)
2657 {
2658     QVERIFY(p.get() != nullptr);
2659 }
2660 
2661 void tst_QFuture::testSingleResult(const std::vector<int> &v)
2662 {
2663     QVERIFY(!v.empty());
2664 }
2665 
2666 template<class T>
2667 void tst_QFuture::testSingleResult(const T &unknown)
2668 {
2669     Q_UNUSED(unknown);
2670 }
2671 
2672 
2673 template<class T>
2674 void tst_QFuture::testFutureTaken(QFuture<T> &noMoreFuture)
2675 {
2676     QCOMPARE(noMoreFuture.isValid(), false);
2677     QCOMPARE(noMoreFuture.resultCount(), 0);
2678     QCOMPARE(noMoreFuture.isStarted(), false);
2679     QCOMPARE(noMoreFuture.isRunning(), false);
2680     QCOMPARE(noMoreFuture.isPaused(), false);
2681     QCOMPARE(noMoreFuture.isFinished(), false);
2682     QCOMPARE(noMoreFuture.progressValue(), 0);
2683 }
2684 
2685 template<class T>
2686 void tst_QFuture::testTakeResults(QFuture<T> future, size_type resultCount)
2687 {
2688     auto copy = future;
2689     QVERIFY(future.isFinished());
2690     QVERIFY(future.isValid());
2691     QCOMPARE(size_type(future.resultCount()), resultCount);
2692     QVERIFY(copy.isFinished());
2693     QVERIFY(copy.isValid());
2694     QCOMPARE(size_type(copy.resultCount()), resultCount);
2695 
2696     auto vec = future.takeResults();
2697     QCOMPARE(vec.size(), resultCount);
2698 
2699     for (const auto &r : vec) {
2700         testSingleResult(r);
2701         if (QTest::currentTestFailed())
2702             return;
2703     }
2704 
2705     testFutureTaken(future);
2706     if (QTest::currentTestFailed())
2707         return;
2708     testFutureTaken(copy);
2709 }
2710 
2711 void tst_QFuture::takeResults()
2712 {
2713     // Test takeResults() for movable types (whether or not copyable).
2714 
2715     // std::unique_ptr<int> supports only move semantics:
2716     QFutureInterface<UniquePtr> moveIface;
2717     moveIface.reportStarted();
2718 
2719     // std::vector<int> supports both copy and move:
2720     QFutureInterface<std::vector<int>> copyIface;
2721     copyIface.reportStarted();
2722 
2723     const int expectedCount = 10;
2724 
2725     for (int i = 0; i < expectedCount; ++i) {
2726         moveIface.reportAndMoveResult(UniquePtr{new int(0b101010)}, i);
2727         copyIface.reportAndMoveResult(std::vector<int>{1,2,3,4,5}, i);
2728     }
2729 
2730     moveIface.reportFinished();
2731     copyIface.reportFinished();
2732 
2733     testTakeResults(moveIface.future(), size_type(expectedCount));
2734     if (QTest::currentTestFailed())
2735         return;
2736 
2737     testTakeResults(copyIface.future(), size_type(expectedCount));
2738 }
2739 
2740 void tst_QFuture::takeResult()
2741 {
2742     QFutureInterface<UniquePtr> iface;
2743     iface.reportStarted();
2744     iface.reportAndMoveResult(UniquePtr{new int(0b101010)}, 0);
2745     iface.reportFinished();
2746 
2747     auto future = iface.future();
2748     QVERIFY(future.isFinished());
2749     QVERIFY(future.isValid());
2750     QCOMPARE(future.resultCount(), 1);
2751 
2752     auto result = future.takeResult();
2753     testFutureTaken(future);
2754     if (QTest::currentTestFailed())
2755         return;
2756     testSingleResult(result);
2757 }
2758 
2759 void tst_QFuture::runAndTake()
2760 {
2761     // Test if a 'moving' future can be used by
2762     // QtConcurrent::run.
2763 
2764     auto rabbit = [](){
2765         // Let's wait a bit to give the test below some time
2766         // to sync up with us with its watcher.
2767         QThread::currentThread()->msleep(100);
2768         return UniquePtr(new int(10));
2769     };
2770 
2771     QTestEventLoop loop;
2772     QFutureWatcher<UniquePtr> watcha;
2773     connect(&watcha, &QFutureWatcher<UniquePtr>::finished, [&loop](){
2774         loop.exitLoop();
2775     });
2776 
2777     auto gotcha = QtConcurrent::run(rabbit);
2778     watcha.setFuture(gotcha);
2779 
2780     loop.enterLoopMSecs(500);
2781     if (loop.timeout())
2782         QSKIP("Failed to run the task, nothing to test");
2783 
2784     gotcha = watcha.future();
2785     testTakeResults(gotcha, size_type(1));
2786 }
2787 
2788 void tst_QFuture::resultsReadyAt_data()
2789 {
2790     QTest::addColumn<bool>("testMove");
2791 
2792     QTest::addRow("reportResult") << false;
2793     QTest::addRow("reportAndMoveResult") << true;
2794 }
2795 
2796 void tst_QFuture::resultsReadyAt()
2797 {
2798     QFETCH(const bool, testMove);
2799 
2800     QFutureInterface<int> iface;
2801     QFutureWatcher<int> watcher;
2802     watcher.setFuture(iface.future());
2803 
2804     QTestEventLoop eventProcessor;
2805     connect(&watcher, &QFutureWatcher<int>::finished, &eventProcessor, &QTestEventLoop::exitLoop);
2806 
2807     const int nExpectedResults = 4;
2808     int reported = 0;
2809     int taken = 0;
2810     connect(&watcher, &QFutureWatcher<int>::resultsReadyAt,
2811             [&iface, &reported, &taken](int begin, int end)
2812     {
2813         auto future = iface.future();
2814         QVERIFY(end - begin > 0);
2815         for (int i = begin; i < end; ++i, ++reported) {
2816             QVERIFY(future.isResultReadyAt(i));
2817             taken |= 1 << i;
2818         }
2819     });
2820 
2821     auto report = [&iface, testMove](int index)
2822     {
2823         int dummyResult = 0b101010;
2824         if (testMove)
2825             iface.reportAndMoveResult(std::move(dummyResult), index);
2826         else
2827             iface.reportResult(&dummyResult, index);
2828     };
2829 
2830     const QSignalSpy readyCounter(&watcher, &QFutureWatcher<int>::resultsReadyAt);
2831     QTimer::singleShot(0, [&iface, &report]{
2832         // With filter mode == true, the result may go into the pending results.
2833         // Reporting it as ready will allow an application to try and access the
2834         // result, crashing on invalid (store.end()) iterator dereferenced.
2835         iface.setFilterMode(true);
2836         iface.reportStarted();
2837         report(0);
2838         report(1);
2839         // This one - should not be reported (it goes into pending):
2840         report(3);
2841         // Let's close the 'gap' and make them all ready:
2842         report(-1);
2843         iface.reportFinished();
2844     });
2845 
2846     // Run event loop, QCoreApplication::postEvent is in use
2847     // in QFutureInterface:
2848     eventProcessor.enterLoopMSecs(2000);
2849     QVERIFY(!eventProcessor.timeout());
2850     if (QTest::currentTestFailed()) // Failed in our lambda observing 'ready at'
2851         return;
2852 
2853     QCOMPARE(reported, nExpectedResults);
2854     QCOMPARE(nExpectedResults, iface.future().resultCount());
2855     QCOMPARE(readyCounter.count(), 3);
2856     QCOMPARE(taken, 0b1111);
2857 }
2858 
2859 template <class T>
2860 auto makeFutureInterface(T &&result)
2861 {
2862     QFutureInterface<T> f;
2863 
2864     f.reportStarted();
2865     f.reportResult(std::forward<T>(result));
2866     f.reportFinished();
2867 
2868     return f;
2869 }
2870 
2871 void tst_QFuture::takeResultWorksForTypesWithoutDefaultCtor()
2872 {
2873     struct Foo
2874     {
2875         Foo() = delete;
2876         explicit Foo(int i) : _i(i) {}
2877 
2878         int _i = -1;
2879     };
2880 
2881     auto f = makeFutureInterface(Foo(42));
2882 
2883     QCOMPARE(f.takeResult()._i, 42);
2884 }
2885 void tst_QFuture::canceledFutureIsNotValid()
2886 {
2887     auto f = makeFutureInterface(42);
2888 
2889     f.cancel();
2890 
2891     QVERIFY(!f.isValid());
2892 }
2893 
2894 void tst_QFuture::signalConnect()
2895 {
2896     // No arg
2897     {
2898         SenderObject sender;
2899         auto future =
2900                 QtFuture::connect(&sender, &SenderObject::noArgSignal).then([&] { return true; });
2901         sender.emitNoArg();
2902         QCOMPARE(future.result(), true);
2903     }
2904 
2905     // One arg
2906     {
2907         SenderObject sender;
2908         auto future = QtFuture::connect(&sender, &SenderObject::intArgSignal).then([](int value) {
2909             return value;
2910         });
2911         sender.emitIntArg(42);
2912         QCOMPARE(future.result(), 42);
2913     }
2914 
2915     // Const ref arg
2916     {
2917         SenderObject sender;
2918         auto future =
2919                 QtFuture::connect(&sender, &SenderObject::constRefArg).then([](QString value) {
2920                     return value;
2921                 });
2922         sender.emitConstRefArg(QString("42"));
2923         QCOMPARE(future.result(), "42");
2924     }
2925 
2926     // Multiple args
2927     {
2928         SenderObject sender;
2929         using TupleArgs = std::tuple<int, double, QString>;
2930         auto future =
2931                 QtFuture::connect(&sender, &SenderObject::multipleArgs).then([](TupleArgs values) {
2932                     return values;
2933                 });
2934         sender.emitMultipleArgs(42, 42.5, "42");
2935         auto result = future.result();
2936         QCOMPARE(std::get<0>(result), 42);
2937         QCOMPARE(std::get<1>(result), 42.5);
2938         QCOMPARE(std::get<2>(result), "42");
2939     }
2940 
2941     // Sender destroyed
2942     {
2943         SenderObject *sender = new SenderObject();
2944 
2945         auto future = QtFuture::connect(sender, &SenderObject::intArgSignal);
2946 
2947         QSignalSpy spy(sender, &QObject::destroyed);
2948         sender->deleteLater();
2949 
2950         // emit the signal when sender is being destroyed
2951         QObject::connect(sender, &QObject::destroyed, [sender] { sender->emitIntArg(42); });
2952         spy.wait();
2953 
2954         QVERIFY(future.isCanceled());
2955         QVERIFY(!future.isValid());
2956     }
2957 }
2958 
2959 QTEST_MAIN(tst_QFuture)
2960 #include "tst_qfuture.moc"
