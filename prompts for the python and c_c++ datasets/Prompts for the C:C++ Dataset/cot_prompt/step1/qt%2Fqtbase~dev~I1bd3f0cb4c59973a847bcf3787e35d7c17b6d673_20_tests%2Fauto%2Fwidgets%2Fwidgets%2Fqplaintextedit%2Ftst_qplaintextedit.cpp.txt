Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
QPlainTextEdit: fix the visibility of placeholderText

If one calls setPlainText("") before setting a placeholder text, the
placeholder visibility is not updated, and the placeholder is not
visible. Fix it by updating placeholderVisible properly.

Fixes: QTBUG-96212
Pick-to: 5.15 6.2
Change-Id: I1bd3f0cb4c59973a847bcf3787e35d7c17b6d673

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the test suite of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
21 ** included in the packaging of this file. Please review the following
22 ** information to ensure the GNU General Public License requirements will
23 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
24 **
25 ** $QT_END_LICENSE$
26 **
27 ****************************************************************************/
28 
29 
30 #include <QTest>
31 #include <QSignalSpy>
32 
33 #include <qtextedit.h>
34 #include <qtextcursor.h>
35 #include <qtextlist.h>
36 #include <qdebug.h>
37 #include <qapplication.h>
38 #include <qclipboard.h>
39 #include <qtextbrowser.h>
40 #include <private/qwidgettextcontrol_p.h>
41 #include <private/qplaintextedit_p.h>
42 #include <qscrollbar.h>
43 #include <qtextobject.h>
44 #include <qmenu.h>
45 
46 #include <qabstracttextdocumentlayout.h>
47 #include <qtextdocumentfragment.h>
48 
49 #include "qplaintextedit.h"
50 #include "../../../shared/platformclipboard.h"
51 
52 //Used in copyAvailable
53 typedef QPair<Qt::Key, Qt::KeyboardModifier> keyPairType;
54 typedef QList<keyPairType> pairListType;
55 Q_DECLARE_METATYPE(keyPairType);
56 
57 QT_FORWARD_DECLARE_CLASS(QPlainTextEdit)
58 
59 class tst_QPlainTextEdit : public QObject
60 {
61     Q_OBJECT
62 public:
63     tst_QPlainTextEdit();
64 
65 public slots:
66     void init();
67     void cleanup();
68 private slots:
69     void getSetCheck();
70 #ifndef QT_NO_CLIPBOARD
71     void clearMustNotChangeClipboard();
72 #endif
73     void clearMustNotResetRootFrameMarginToDefault();
74     void paragSeparatorOnPlaintextAppend();
75 #ifndef QT_NO_CLIPBOARD
76     void selectAllSetsNotSelection();
77 #endif
78     void asciiTab();
79     void setDocument();
80     void emptyAppend();
81     void appendOnEmptyDocumentShouldReuseInitialParagraph();
82     void cursorPositionChanged();
83     void setTextCursor();
84 #ifndef QT_NO_CLIPBOARD
85     void undoAvailableAfterPaste();
86 #endif
87     void undoRedoAvailableRepetition();
88     void appendShouldNotTouchTheSelection();
89     void backspace();
90     void shiftBackspace();
91     void undoRedo();
92     void preserveCharFormatInAppend();
93 #ifndef QT_NO_CLIPBOARD
94     void copyAndSelectAllInReadonly();
95 #endif
96     void charWithAltOrCtrlModifier_data();
97     void charWithAltOrCtrlModifier();
98     void noPropertiesOnDefaultTextEditCharFormat();
99     void setPlainTextShouldEmitTextChangedOnce();
100     void overwriteMode();
101     void shiftDownInLineLastShouldSelectToEnd_data();
102     void shiftDownInLineLastShouldSelectToEnd();
103     void undoRedoShouldRepositionTextEditCursor();
104     void lineWrapModes();
105 #ifndef QT_NO_CURSOR
106     void mouseCursorShape();
107 #endif
108     void implicitClear();
109     void undoRedoAfterSetContent();
110     void numPadKeyNavigation();
111     void moveCursor();
112 #ifndef QT_NO_CLIPBOARD
113     void mimeDataReimplementations();
114 #endif
115     void shiftEnterShouldInsertLineSeparator();
116     void selectWordsFromStringsContainingSeparators_data();
117     void selectWordsFromStringsContainingSeparators();
118 #ifndef QT_NO_CLIPBOARD
119     void canPaste();
120     void copyAvailable_data();
121     void copyAvailable();
122 #endif
123     void ensureCursorVisibleOnInitialShow();
124     void setTextInsideResizeEvent();
125     void colorfulAppend();
126     void ensureVisibleWithRtl();
127     void preserveCharFormatAfterSetPlainText();
128     void extraSelections();
129     void adjustScrollbars();
130     void textObscuredByScrollbars();
131     void setTextPreservesUndoRedoEnabled();
132     void wordWrapProperty();
133     void lineWrapProperty();
134     void selectionChanged();
135     void blockCountChanged();
136     void insertAndScrollToBottom();
137     void inputMethodQueryImHints_data();
138     void inputMethodQueryImHints();
139 #if QT_CONFIG(regularexpression)
140     void findWithRegularExpression();
141     void findBackwardWithRegularExpression();
142     void findWithRegularExpressionReturnsFalseIfNoMoreResults();
143 #endif
144     void layoutAfterMultiLineRemove();
145     void undoCommandRemovesAndReinsertsBlock();
146     void taskQTBUG_43562_lineCountCrash();
147 #ifndef QT_NO_CONTEXTMENU
148     void contextMenu();
149 #endif
150     void inputMethodCursorRect();
151 #if QT_CONFIG(scrollbar)
152     void updateAfterChangeCenterOnScroll();
153 #endif
154 #ifndef QT_NO_CLIPBOARD
155     void updateCursorPositionAfterEdit();
156 #endif
157     void appendTextWhenInvisible();
158     void autoPlaceholderVisibility_data();
159     void autoPlaceholderVisibility();
160 
161 private:
162     void createSelection();
163     int blockCount() const;
164     int lineCount() const;
165 
166     QPlainTextEdit *ed;
167     qreal rootFrameMargin;
168 };
169 
170 // Testing get/set functions
171 void tst_QPlainTextEdit::getSetCheck()
172 {
173     QPlainTextEdit obj1;
174     // QTextDocument * QPlainTextEdit::document()
175     // void QPlainTextEdit::setDocument(QTextDocument *)
176     QTextDocument *var1 = new QTextDocument;
177     var1->setDocumentLayout(new QPlainTextDocumentLayout(var1));
178     obj1.setDocument(var1);
179     QCOMPARE(var1, obj1.document());
180     obj1.setDocument((QTextDocument *)0);
181     QVERIFY(var1 != obj1.document()); // QPlainTextEdit creates a new document when setting 0
182     QVERIFY((QTextDocument *)0 != obj1.document());
183     delete var1;
184 
185 
186     // bool QPlainTextEdit::tabChangesFocus()
187     // void QPlainTextEdit::setTabChangesFocus(bool)
188     obj1.setTabChangesFocus(false);
189     QCOMPARE(false, obj1.tabChangesFocus());
190     obj1.setTabChangesFocus(true);
191     QCOMPARE(true, obj1.tabChangesFocus());
192 
193     // LineWrapMode QPlainTextEdit::lineWrapMode()
194     // void QPlainTextEdit::setLineWrapMode(LineWrapMode)
195     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::NoWrap));
196     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::NoWrap), obj1.lineWrapMode());
197     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::WidgetWidth));
198     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::WidgetWidth), obj1.lineWrapMode());
199 //     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedPixelWidth));
200 //     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedPixelWidth), obj1.lineWrapMode());
201 //     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedColumnWidth));
202 //     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedColumnWidth), obj1.lineWrapMode());
203 
204 
205     // bool QPlainTextEdit::overwriteMode()
206     // void QPlainTextEdit::setOverwriteMode(bool)
207     obj1.setOverwriteMode(false);
208     QCOMPARE(false, obj1.overwriteMode());
209     obj1.setOverwriteMode(true);
210     QCOMPARE(true, obj1.overwriteMode());
211 
212     // int QPlainTextEdit::tabStopWidth()
213     // void QPlainTextEdit::setTabStopWidth(int)
214     obj1.setTabStopDistance(0);
215     QCOMPARE(0, obj1.tabStopDistance());
216     obj1.setTabStopDistance(-1);
217     QCOMPARE(0, obj1.tabStopDistance()); // Makes no sense to set a negative tabstop value
218     obj1.setTabStopDistance(std::numeric_limits<qreal>::max());
219     QCOMPARE(std::numeric_limits<qreal>::max(), obj1.tabStopDistance());
220 }
221 
222 class QtTestDocumentLayout : public QAbstractTextDocumentLayout
223 {
224     Q_OBJECT
225 public:
226     inline QtTestDocumentLayout(QPlainTextEdit *edit, QTextDocument *doc, int &itCount)
227         : QAbstractTextDocumentLayout(doc), useBiggerSize(false), ed(edit), iterationCounter(itCount) {}
228 
229     virtual void draw(QPainter *, const QAbstractTextDocumentLayout::PaintContext &) override {}
230 
231     virtual int hitTest(const QPointF &, Qt::HitTestAccuracy ) const override { return 0; }
232 
233     virtual void documentChanged(int, int, int) override {}
234 
235     virtual int pageCount() const override { return 1; }
236 
237     virtual QSizeF documentSize() const override { return usedSize; }
238 
239     virtual QRectF frameBoundingRect(QTextFrame *) const override { return QRectF(); }
240     virtual QRectF blockBoundingRect(const QTextBlock &) const override { return QRectF(); }
241 
242     bool useBiggerSize;
243     QSize usedSize;
244 
245     QPlainTextEdit *ed;
246 
247     int &iterationCounter;
248 };
249 
250 tst_QPlainTextEdit::tst_QPlainTextEdit()
251 {}
252 
253 void tst_QPlainTextEdit::init()
254 {
255     ed = new QPlainTextEdit(0);
256     rootFrameMargin = ed->document()->documentMargin();
257 }
258 
259 void tst_QPlainTextEdit::cleanup()
260 {
261     delete ed;
262     ed = 0;
263 }
264 
265 
266 void tst_QPlainTextEdit::createSelection()
267 {
268     QTest::keyClicks(ed, "Hello World");
269     /* go to start */
270 #ifndef Q_OS_MAC
271     QTest::keyClick(ed, Qt::Key_Home, Qt::ControlModifier);
272 #else
273     QTest::keyClick(ed, Qt::Key_Home);
274 #endif
275     QCOMPARE(ed->textCursor().position(), 0);
276     /* select until end of text */
277 #ifndef Q_OS_MAC
278     QTest::keyClick(ed, Qt::Key_End, Qt::ControlModifier | Qt::ShiftModifier);
279 #else
280     QTest::keyClick(ed, Qt::Key_End, Qt::ShiftModifier);
281 #endif
282     QCOMPARE(ed->textCursor().position(), 11);
283 }
284 #ifndef QT_NO_CLIPBOARD
285 void tst_QPlainTextEdit::clearMustNotChangeClipboard()
286 {
287     if (!PlatformClipboard::isAvailable())
288         QSKIP("Clipboard not working with cron-started unit tests");
289 
290     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
291         QSKIP("Wayland: This fails. Figure out why.");
292 
293     ed->textCursor().insertText("Hello World");
294     QString txt("This is different text");
295     QApplication::clipboard()->setText(txt);
296     ed->clear();
297     QCOMPARE(QApplication::clipboard()->text(), txt);
298 }
299 #endif
300 
301 void tst_QPlainTextEdit::clearMustNotResetRootFrameMarginToDefault()
302 {
303     QCOMPARE(ed->document()->rootFrame()->frameFormat().margin(), rootFrameMargin);
304     ed->clear();
305     QCOMPARE(ed->document()->rootFrame()->frameFormat().margin(), rootFrameMargin);
306 }
307 
308 
309 void tst_QPlainTextEdit::paragSeparatorOnPlaintextAppend()
310 {
311     ed->appendPlainText("Hello\nWorld");
312     int cnt = 0;
313     QTextBlock blk = ed->document()->begin();
314     while (blk.isValid()) {
315         ++cnt;
316         blk = blk.next();
317     }
318     QCOMPARE(cnt, 2);
319 }
320 
321 #ifndef QT_NO_CLIPBOARD
322 void tst_QPlainTextEdit::selectAllSetsNotSelection()
323 {
324     if (!QApplication::clipboard()->supportsSelection())
325         QSKIP("Test only relevant for systems with selection");
326 
327     QApplication::clipboard()->setText(QString("foobar"), QClipboard::Selection);
328     QCOMPARE(QApplication::clipboard()->text(QClipboard::Selection), QString("foobar"));
329 
330     ed->insertPlainText("Hello World");
331     ed->selectAll();
332 
333     QCOMPARE(QApplication::clipboard()->text(QClipboard::Selection), QString::fromLatin1("foobar"));
334 }
335 #endif
336 
337 void tst_QPlainTextEdit::asciiTab()
338 {
339     QPlainTextEdit edit;
340     edit.setPlainText("\t");
341     edit.show();
342     qApp->processEvents();
343     QCOMPARE(edit.toPlainText().at(0), QChar('\t'));
344 }
345 
346 void tst_QPlainTextEdit::setDocument()
347 {
348     QTextDocument *document = new QTextDocument(ed);
349     document->setDocumentLayout(new QPlainTextDocumentLayout(document));
350     QTextCursor(document).insertText("Test");
351     ed->setDocument(document);
352     QCOMPARE(ed->toPlainText(), QString("Test"));
353 }
354 
355 
356 int tst_QPlainTextEdit::blockCount() const
357 {
358     int blocks = 0;
359     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next())
360         ++blocks;
361     return blocks;
362 }
363 
364 int tst_QPlainTextEdit::lineCount() const
365 {
366     int lines = 0;
367     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next()) {
368         ed->document()->documentLayout()->blockBoundingRect(block);
369         lines += block.layout()->lineCount();
370     }
371     return lines;
372 }
373 
374 // Supporter issue #56783
375 void tst_QPlainTextEdit::emptyAppend()
376 {
377     ed->appendPlainText("Blah");
378     QCOMPARE(blockCount(), 1);
379     ed->appendPlainText(QString());
380     QCOMPARE(blockCount(), 2);
381     ed->appendPlainText(QString("   "));
382     QCOMPARE(blockCount(), 3);
383 }
384 
385 void tst_QPlainTextEdit::appendOnEmptyDocumentShouldReuseInitialParagraph()
386 {
387     QCOMPARE(blockCount(), 1);
388     ed->appendPlainText("Blah");
389     QCOMPARE(blockCount(), 1);
390 }
391 
392 
393 class CursorPositionChangedRecorder : public QObject
394 {
395     Q_OBJECT
396 public:
397     inline CursorPositionChangedRecorder(QPlainTextEdit *ed)
398         : editor(ed)
399     {
400         connect(editor, SIGNAL(cursorPositionChanged()), this, SLOT(recordCursorPos()));
401     }
402 
403     QList<int> cursorPositions;
404 
405 private slots:
406     void recordCursorPos()
407     {
408         cursorPositions.append(editor->textCursor().position());
409     }
410 
411 private:
412     QPlainTextEdit *editor;
413 };
414 
415 void tst_QPlainTextEdit::cursorPositionChanged()
416 {
417     QSignalSpy spy(ed, SIGNAL(cursorPositionChanged()));
418 
419     spy.clear();
420     QTest::keyClick(ed, Qt::Key_A);
421     QCOMPARE(spy.count(), 1);
422 
423     QTextCursor cursor = ed->textCursor();
424     cursor.movePosition(QTextCursor::Start);
425     ed->setTextCursor(cursor);
426     cursor.movePosition(QTextCursor::End);
427     spy.clear();
428     cursor.insertText("Test");
429     QCOMPARE(spy.count(), 0);
430 
431     cursor.movePosition(QTextCursor::End);
432     ed->setTextCursor(cursor);
433     cursor.movePosition(QTextCursor::Start);
434     spy.clear();
435     cursor.insertText("Test");
436     QCOMPARE(spy.count(), 1);
437 
438     spy.clear();
439     QTest::keyClick(ed, Qt::Key_Left);
440     QCOMPARE(spy.count(), 1);
441 
442     CursorPositionChangedRecorder spy2(ed);
443     QVERIFY(ed->textCursor().position() > 0);
444     ed->setPlainText("Hello World");
445     QCOMPARE(spy2.cursorPositions.count(), 1);
446     QCOMPARE(spy2.cursorPositions.at(0), 0);
447     QCOMPARE(ed->textCursor().position(), 0);
448 }
449 
450 void tst_QPlainTextEdit::setTextCursor()
451 {
452     QSignalSpy spy(ed, SIGNAL(cursorPositionChanged()));
453 
454     ed->setPlainText("Test");
455     QTextCursor cursor = ed->textCursor();
456     cursor.movePosition(QTextCursor::Start);
457     cursor.movePosition(QTextCursor::NextCharacter);
458 
459     spy.clear();
460 
461     ed->setTextCursor(cursor);
462     QCOMPARE(spy.count(), 1);
463 }
464 
465 #ifndef QT_NO_CLIPBOARD
466 void tst_QPlainTextEdit::undoAvailableAfterPaste()
467 {
468     if (!PlatformClipboard::isAvailable())
469         QSKIP("Clipboard not working with cron-started unit tests");
470 
471     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
472         QSKIP("Wayland: This fails. Figure out why.");
473 
474     QSignalSpy spy(ed->document(), SIGNAL(undoAvailable(bool)));
475 
476     const QString txt("Test");
477     QApplication::clipboard()->setText(txt);
478     ed->paste();
479     QVERIFY(spy.count() >= 1);
480     QCOMPARE(ed->toPlainText(), txt);
481 }
482 #endif
483 
484 class UndoRedoRecorder : public QObject
485 {
486     Q_OBJECT
487 public:
488     UndoRedoRecorder(QTextDocument *doc)
489         : undoRepetitions(false)
490         , redoRepetitions(false)
491         , undoCount(0)
492         , redoCount(0)
493     {
494         connect(doc, SIGNAL(undoAvailable(bool)), this, SLOT(undoAvailable(bool)));
495         connect(doc, SIGNAL(redoAvailable(bool)), this, SLOT(redoAvailable(bool)));
496     }
497 
498     bool undoRepetitions;
499     bool redoRepetitions;
500 
501 private slots:
502     void undoAvailable(bool enabled) {
503         if (undoCount > 0 && enabled == lastUndoEnabled)
504             undoRepetitions = true;
505 
506         ++undoCount;
507         lastUndoEnabled = enabled;
508     }
509 
510     void redoAvailable(bool enabled) {
511         if (redoCount > 0 && enabled == lastRedoEnabled)
512             redoRepetitions = true;
513 
514         ++redoCount;
515         lastRedoEnabled = enabled;
516     }
517 
518 private:
519     bool lastUndoEnabled;
520     bool lastRedoEnabled;
521 
522     int undoCount;
523     int redoCount;
524 };
525 
526 void tst_QPlainTextEdit::undoRedoAvailableRepetition()
527 {
528     UndoRedoRecorder spy(ed->document());
529 
530     ed->textCursor().insertText("ABC\n\nDEF\n\nGHI\n");
531     ed->textCursor().insertText("foo\n");
532     ed->textCursor().insertText("bar\n");
533     ed->undo(); ed->undo(); ed->undo();
534     ed->redo(); ed->redo(); ed->redo();
535 
536     QVERIFY(!spy.undoRepetitions);
537     QVERIFY(!spy.redoRepetitions);
538 }
539 
540 void tst_QPlainTextEdit::appendShouldNotTouchTheSelection()
541 {
542     QTextCursor cursor(ed->document());
543     QTextCharFormat fmt;
544     fmt.setForeground(Qt::blue);
545     cursor.insertText("H", fmt);
546     fmt.setForeground(Qt::red);
547     cursor.insertText("ey", fmt);
548 
549     cursor.insertText("some random text inbetween");
550 
551     cursor.movePosition(QTextCursor::Start);
552     cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
553     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::blue));
554     cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
555     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::red));
556     cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
557     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::red));
558     QCOMPARE(cursor.selectedText(), QString("Hey"));
559 
560     ed->setTextCursor(cursor);
561     QVERIFY(ed->textCursor().hasSelection());
562 
563     ed->appendHtml("<b>Some Bold Text</b>");
564     cursor.movePosition(QTextCursor::Start);
565     cursor.movePosition(QTextCursor::NextCharacter);
566     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::blue));
567 }
568 
569 void tst_QPlainTextEdit::backspace()
570 {
571     QTextCursor cursor = ed->textCursor();
572 
573     QTextListFormat listFmt;
574     listFmt.setStyle(QTextListFormat::ListDisc);
575     listFmt.setIndent(1);
576     cursor.insertList(listFmt);
577     cursor.insertText("A");
578 
579     ed->setTextCursor(cursor);
580 
581     // delete 'A'
582     QTest::keyClick(ed, Qt::Key_Backspace);
583     QVERIFY(ed->textCursor().currentList());
584     // delete list
585     QTest::keyClick(ed, Qt::Key_Backspace);
586     QVERIFY(!ed->textCursor().currentList());
587     QCOMPARE(ed->textCursor().blockFormat().indent(), 1);
588     // outdent paragraph
589     QTest::keyClick(ed, Qt::Key_Backspace);
590     QCOMPARE(ed->textCursor().blockFormat().indent(), 0);
591 }
592 
593 void tst_QPlainTextEdit::shiftBackspace()
594 {
595     QTextCursor cursor = ed->textCursor();
596 
597     QTextListFormat listFmt;
598     listFmt.setStyle(QTextListFormat::ListDisc);
599     listFmt.setIndent(1);
600     cursor.insertList(listFmt);
601     cursor.insertText("A");
602 
603     ed->setTextCursor(cursor);
604 
605     // delete 'A'
606     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier);
607     QVERIFY(ed->textCursor().currentList());
608     // delete list
609     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier);
610     QVERIFY(!ed->textCursor().currentList());
611     QCOMPARE(ed->textCursor().blockFormat().indent(), 1);
612     // outdent paragraph
613     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier);
614     QCOMPARE(ed->textCursor().blockFormat().indent(), 0);
615 }
616 
617 void tst_QPlainTextEdit::undoRedo()
618 {
619     ed->clear();
620     QTest::keyClicks(ed, "abc d");
621     QCOMPARE(ed->toPlainText(), QString("abc d"));
622     ed->undo();
623     QCOMPARE(ed->toPlainText(), QString());
624     ed->redo();
625     QCOMPARE(ed->toPlainText(), QString("abc d"));
626 #ifdef Q_OS_WIN
627     // shortcut for undo
628     QTest::keyClick(ed, Qt::Key_Backspace, Qt::AltModifier);
629     QCOMPARE(ed->toPlainText(), QString());
630     // shortcut for redo
631     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier|Qt::AltModifier);
632     QCOMPARE(ed->toPlainText(), QString("abc d"));
633 #endif
634 }
635 
636 // Task #70465
637 void tst_QPlainTextEdit::preserveCharFormatInAppend()
638 {
639     ed->appendHtml("First para");
640     ed->appendHtml("<b>Second para</b>");
641     ed->appendHtml("third para");
642 
643     QTextCursor cursor(ed->textCursor());
644 
645     cursor.movePosition(QTextCursor::Start);
646     cursor.movePosition(QTextCursor::NextCharacter);
647     QCOMPARE(cursor.charFormat().fontWeight(), (int)QFont::Normal);
648     QCOMPARE(cursor.block().text(), QString("First para"));
649 
650     cursor.movePosition(QTextCursor::NextBlock);
651     cursor.movePosition(QTextCursor::NextCharacter);
652     QCOMPARE(cursor.charFormat().fontWeight(), (int)QFont::Bold);
653     QCOMPARE(cursor.block().text(), QString("Second para"));
654 
655     cursor.movePosition(QTextCursor::NextBlock);
656     cursor.movePosition(QTextCursor::NextCharacter);
657     QCOMPARE(cursor.charFormat().fontWeight(), (int)QFont::Normal);
658     QCOMPARE(cursor.block().text(), QString("third para"));
659 }
660 
661 #ifndef QT_NO_CLIPBOARD
662 void tst_QPlainTextEdit::copyAndSelectAllInReadonly()
663 {
664     if (!PlatformClipboard::isAvailable())
665         QSKIP("Clipboard not working with cron-started unit tests");
666 
667     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
668         QSKIP("Wayland: This fails. Figure out why.");
669 
670     ed->setReadOnly(true);
671     ed->setPlainText("Hello World");
672 
673     QTextCursor cursor = ed->textCursor();
674     cursor.clearSelection();
675     ed->setTextCursor(cursor);
676     QVERIFY(!ed->textCursor().hasSelection());
677 
678     QCOMPARE(ed->toPlainText(), QString("Hello World"));
679 
680     // shouldn't do anything
681     QTest::keyClick(ed, Qt::Key_A);
682 
683     QCOMPARE(ed->toPlainText(), QString("Hello World"));
684 
685     QTest::keyClick(ed, Qt::Key_A, Qt::ControlModifier);
686 
687     QVERIFY(ed->textCursor().hasSelection());
688 
689     QApplication::clipboard()->setText(QString());
690     QVERIFY(QApplication::clipboard()->text().isEmpty());
691 
692     QTest::keyClick(ed, Qt::Key_C, Qt::ControlModifier);
693     QCOMPARE(QApplication::clipboard()->text(), QString("Hello World"));
694 }
695 #endif
696 
697 Q_DECLARE_METATYPE(Qt::KeyboardModifiers)
698 
699 // Test how QWidgetTextControlPrivate (used in QPlainTextEdit, QTextEdit)
700 // handles input with modifiers.
701 void tst_QPlainTextEdit::charWithAltOrCtrlModifier_data()
702 {
703     QTest::addColumn<Qt::KeyboardModifiers>("modifiers");
704     QTest::addColumn<bool>("textExpected");
705 
706     QTest::newRow("no-modifiers") << Qt::KeyboardModifiers() << true;
707     // Ctrl, Ctrl+Shift: No text (QTBUG-35734)
708     QTest::newRow("ctrl") << Qt::KeyboardModifiers(Qt::ControlModifier)
709         << false;
710     QTest::newRow("ctrl-shift") << Qt::KeyboardModifiers(Qt::ShiftModifier | Qt::ControlModifier)
711         << false;
712     QTest::newRow("alt") << Qt::KeyboardModifiers(Qt::AltModifier) << true;
713     // Alt-Ctrl (Alt-Gr on German keyboards, Task 129098): Expect text
714     QTest::newRow("alt-ctrl") << (Qt::AltModifier | Qt::ControlModifier) << true;
715 }
716 
717 void tst_QPlainTextEdit::charWithAltOrCtrlModifier()
718 {
719     QFETCH(Qt::KeyboardModifiers, modifiers);
720     QFETCH(bool, textExpected);
721 
722     QTest::keyClick(ed, Qt::Key_At, modifiers);
723     const QString expectedText = textExpected ?  QLatin1String("@") : QString();
724     QCOMPARE(ed->toPlainText(), expectedText);
725 }
726 
727 void tst_QPlainTextEdit::noPropertiesOnDefaultTextEditCharFormat()
728 {
729     // there should be no properties set on the default/initial char format
730     // on a text edit. Font properties instead should be taken from the
731     // widget's font (in sync with defaultFont property in document) and the
732     // foreground color should be taken from the palette.
733     QCOMPARE(ed->textCursor().charFormat().properties().count(), 0);
734 }
735 
736 void tst_QPlainTextEdit::setPlainTextShouldEmitTextChangedOnce()
737 {
738     QSignalSpy spy(ed, SIGNAL(textChanged()));
739     ed->setPlainText("Yankee Doodle");
740     QCOMPARE(spy.count(), 1);
741     ed->setPlainText("");
742     QCOMPARE(spy.count(), 2);
743 }
744 
745 void tst_QPlainTextEdit::overwriteMode()
746 {
747     QVERIFY(!ed->overwriteMode());
748     QTest::keyClicks(ed, "Some first text");
749 
750     QCOMPARE(ed->toPlainText(), QString("Some first text"));
751 
752     ed->setOverwriteMode(true);
753 
754     QTextCursor cursor = ed->textCursor();
755     cursor.setPosition(5);
756     ed->setTextCursor(cursor);
757 
758     QTest::keyClicks(ed, "shiny");
759     QCOMPARE(ed->toPlainText(), QString("Some shiny text"));
760 
761     cursor.movePosition(QTextCursor::End);
762     ed->setTextCursor(cursor);
763 
764     QTest::keyClick(ed, Qt::Key_Enter);
765 
766     ed->setOverwriteMode(false);
767     QTest::keyClicks(ed, "Second paragraph");
768 
769     QCOMPARE(blockCount(), 2);
770 
771     cursor.movePosition(QTextCursor::Start);
772     cursor.movePosition(QTextCursor::EndOfBlock);
773 
774     QCOMPARE(cursor.position(), 15);
775     ed->setTextCursor(cursor);
776 
777     ed->setOverwriteMode(true);
778 
779     QTest::keyClicks(ed, " blah");
780 
781     QCOMPARE(blockCount(), 2);
782 
783     QTextBlock block = ed->document()->begin();
784     QCOMPARE(block.text(), QString("Some shiny text blah"));
785     block = block.next();
786     QCOMPARE(block.text(), QString("Second paragraph"));
787 }
788 
789 void tst_QPlainTextEdit::shiftDownInLineLastShouldSelectToEnd_data()
790 {
791     // shift cursor-down in the last line should select to the end of the document
792 
793     QTest::addColumn<QString>("input");
794     QTest::addColumn<int>("totalLineCount");
795 
796     QTest::newRow("1") << QString("Foo\nBar") << 2;
797     QTest::newRow("2") << QString("Foo\nBar") + QChar(QChar::LineSeparator) + QString("Baz") << 3;
798 }
799 
800 void tst_QPlainTextEdit::shiftDownInLineLastShouldSelectToEnd()
801 {
802     QFETCH(QString, input);
803     QFETCH(int, totalLineCount);
804 
805     ed->setPlainText(input);
806     ed->show();
807 
808     // ensure we're layouted
809     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next())
810         ed->document()->documentLayout()->blockBoundingRect(block);
811 
812     QCOMPARE(blockCount(), 2);
813 
814     int lineCount = 0;
815     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next())
816         lineCount += block.layout()->lineCount();
817     QCOMPARE(lineCount, totalLineCount);
818 
819     QTextCursor cursor = ed->textCursor();
820     cursor.movePosition(QTextCursor::Start);
821     ed->setTextCursor(cursor);
822 
823     for (int i = 0; i < lineCount; ++i) {
824         QTest::keyClick(ed, Qt::Key_Down, Qt::ShiftModifier);
825     }
826 
827     input.replace(QLatin1Char('\n'), QChar(QChar::ParagraphSeparator));
828     QCOMPARE(ed->textCursor().selectedText(), input);
829     QVERIFY(ed->textCursor().atEnd());
830 
831     // also test that without shift modifier the cursor does not move to the end
832     // for Key_Down in the last line
833     cursor.movePosition(QTextCursor::Start);
834     ed->setTextCursor(cursor);
835     for (int i = 0; i < lineCount; ++i) {
836         QTest::keyClick(ed, Qt::Key_Down);
837     }
838     QVERIFY(!ed->textCursor().atEnd());
839 }
840 
841 void tst_QPlainTextEdit::undoRedoShouldRepositionTextEditCursor()
842 {
843     ed->setPlainText("five\nlines\nin\nthis\ntextedit");
844     QTextCursor cursor = ed->textCursor();
845     cursor.movePosition(QTextCursor::Start);
846 
847     ed->setUndoRedoEnabled(false);
848     ed->setUndoRedoEnabled(true);
849 
850     QVERIFY(!ed->document()->isUndoAvailable());
851     QVERIFY(!ed->document()->isRedoAvailable());
852 
853     cursor.insertText("Blah");
854 
855     QVERIFY(ed->document()->isUndoAvailable());
856     QVERIFY(!ed->document()->isRedoAvailable());
857 
858     cursor.movePosition(QTextCursor::End);
859     ed->setTextCursor(cursor);
860 
861     QVERIFY(QMetaObject::invokeMethod(ed, "undo"));
862 
863     QVERIFY(!ed->document()->isUndoAvailable());
864     QVERIFY(ed->document()->isRedoAvailable());
865 
866     QCOMPARE(ed->textCursor().position(), 0);
867 
868     cursor.movePosition(QTextCursor::End);
869     ed->setTextCursor(cursor);
870 
871     QVERIFY(QMetaObject::invokeMethod(ed, "redo"));
872 
873     QVERIFY(ed->document()->isUndoAvailable());
874     QVERIFY(!ed->document()->isRedoAvailable());
875 
876     QCOMPARE(ed->textCursor().position(), 4);
877 }
878 
879 void tst_QPlainTextEdit::lineWrapModes()
880 {
881     QWidget *window = new QWidget;
882     ed->setParent(window);
883     window->show();
884     ed->show();
885     ed->setPlainText("a b c d e f g h i j k l m n o p q r s t u v w x y z");
886     ed->setLineWrapMode(QPlainTextEdit::NoWrap);
887     QCOMPARE(lineCount(), 1);
888     ed->setLineWrapMode(QPlainTextEdit::WidgetWidth);
889 
890     // QPlainTextEdit does lazy line layout on resize, only for the visible blocks.
891     // We thus need to make it wide enough to show something visible.
892     int minimumWidth = 2 * ed->document()->documentMargin();
893     minimumWidth += ed->fontMetrics().horizontalAdvance(QLatin1Char('a'));
894     minimumWidth += ed->frameWidth();
895     ed->resize(minimumWidth, 1000);
896     QCOMPARE(lineCount(), 26);
897     ed->setParent(0);
898     delete window;
899 }
900 
901 #ifndef QT_NO_CURSOR
902 void tst_QPlainTextEdit::mouseCursorShape()
903 {
904     // always show an IBeamCursor, see change 170146
905     QVERIFY(!ed->isReadOnly());
906     QCOMPARE(ed->viewport()->cursor().shape(), Qt::IBeamCursor);
907 
908     ed->setReadOnly(true);
909     QCOMPARE(ed->viewport()->cursor().shape(), Qt::IBeamCursor);
910 
911     ed->setPlainText("Foo");
912     QCOMPARE(ed->viewport()->cursor().shape(), Qt::IBeamCursor);
913 }
914 #endif
915 
916 void tst_QPlainTextEdit::implicitClear()
917 {
918     // test that QPlainTextEdit::setHtml, etc. avoid calling clear() but instead call
919     // QTextDocument::setHtml/etc. instead, which also clear the contents and
920     // cached resource but preserve manually added resources. setHtml on a textedit
921     // should behave the same as on a document with respect to that.
922     // see also clearResources() autotest in qtextdocument
923 
924     // regular resource for QTextDocument
925     QUrl testUrl(":/foobar");
926     QVariant testResource("hello world");
927 
928     ed->document()->addResource(QTextDocument::ImageResource, testUrl, testResource);
929     QVERIFY(ed->document()->resource(QTextDocument::ImageResource, testUrl) == testResource);
930 
931     ed->setPlainText("Blah");
932     QVERIFY(ed->document()->resource(QTextDocument::ImageResource, testUrl) == testResource);
933 
934     ed->setPlainText("<b>Blah</b>");
935     QVERIFY(ed->document()->resource(QTextDocument::ImageResource, testUrl) == testResource);
936 
937     ed->clear();
938     QVERIFY(!ed->document()->resource(QTextDocument::ImageResource, testUrl).isValid());
939     QVERIFY(ed->toPlainText().isEmpty());
940 }
941 
942 #ifndef QT_NO_CLIPBOARD
943 void tst_QPlainTextEdit::copyAvailable_data()
944 {
945     QTest::addColumn<pairListType>("keystrokes");
946     QTest::addColumn<QList<bool> >("copyAvailable");
947     QTest::addColumn<QString>("function");
948 
949     pairListType keystrokes;
950     QList<bool> copyAvailable;
951 
952     keystrokes << qMakePair(Qt::Key_B, Qt::NoModifier) <<  qMakePair(Qt::Key_B, Qt::NoModifier)
953                << qMakePair(Qt::Key_Left, Qt::ShiftModifier);
954     copyAvailable << true ;
955     QTest::newRow(QString("Case1 B,B, <- + shift | signals: true").toLatin1())
956         << keystrokes << copyAvailable << QString();
957 
958     keystrokes.clear();
959     copyAvailable.clear();
960 
961     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
962                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier);
963     copyAvailable << true << false;
964     QTest::newRow(QString("Case2 T,A,A, <- + shift, cut() | signals: true, false").toLatin1())
965         << keystrokes << copyAvailable << QString("cut");
966 
967     keystrokes.clear();
968     copyAvailable.clear();
969 
970     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
971                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
972                << qMakePair(Qt::Key_Left, Qt::ShiftModifier)  << qMakePair(Qt::Key_Left, Qt::ShiftModifier);
973     copyAvailable << true;
974     QTest::newRow(QString("Case3 T,A,A, <- + shift, <- + shift, <- + shift, copy() | signals: true").toLatin1())
975         << keystrokes << copyAvailable << QString("copy");
976 
977     keystrokes.clear();
978     copyAvailable.clear();
979 
980     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
981                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
982                << qMakePair(Qt::Key_Left, Qt::ShiftModifier)  << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
983                << qMakePair(Qt::Key_X, Qt::ControlModifier);
984     copyAvailable << true << false;
985     QTest::newRow(QString("Case4 T,A,A, <- + shift, <- + shift, <- + shift, ctrl + x, paste() | signals: true, false").toLatin1())
986         << keystrokes << copyAvailable << QString("paste");
987 
988     keystrokes.clear();
989     copyAvailable.clear();
990 
991     keystrokes << qMakePair(Qt::Key_B, Qt::NoModifier) <<  qMakePair(Qt::Key_B, Qt::NoModifier)
992                << qMakePair(Qt::Key_Left, Qt::ShiftModifier) << qMakePair(Qt::Key_Left, Qt::NoModifier);
993     copyAvailable << true << false;
994     QTest::newRow(QString("Case5 B,B, <- + shift, <- | signals: true, false").toLatin1())
995         << keystrokes << copyAvailable << QString();
996 
997     keystrokes.clear();
998     copyAvailable.clear();
999 
1000     keystrokes << qMakePair(Qt::Key_B, Qt::NoModifier) <<  qMakePair(Qt::Key_A, Qt::NoModifier)
1001                << qMakePair(Qt::Key_Left, Qt::ShiftModifier) << qMakePair(Qt::Key_Left, Qt::NoModifier)
1002                << qMakePair(Qt::Key_Right, Qt::ShiftModifier);
1003     copyAvailable << true << false << true << false;
1004     QTest::newRow(QString("Case6 B,A, <- + shift, ->, <- + shift | signals: true, false, true, false").toLatin1())
1005         << keystrokes << copyAvailable << QString("cut");
1006 
1007     keystrokes.clear();
1008     copyAvailable.clear();
1009 
1010     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
1011                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
1012                << qMakePair(Qt::Key_Left, Qt::ShiftModifier)  << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
1013                << qMakePair(Qt::Key_X, Qt::ControlModifier);
1014     copyAvailable << true << false << true;
1015     QTest::newRow(QString("Case7 T,A,A, <- + shift, <- + shift, <- + shift, ctrl + x, undo() | signals: true, false, true").toLatin1())
1016         << keystrokes << copyAvailable << QString("undo");
1017 }
1018 
1019 //Tests the copyAvailable slot for several cases
1020 void tst_QPlainTextEdit::copyAvailable()
1021 {
1022     QFETCH(pairListType,keystrokes);
1023     QFETCH(QList<bool>, copyAvailable);
1024     QFETCH(QString, function);
1025 
1026 #ifdef Q_OS_MAC
1027     QSKIP("QTBUG-22283: copyAvailable has never passed on Mac");
1028 #endif
1029     ed->clear();
1030     QApplication::clipboard()->clear();
1031     QVERIFY(!ed->canPaste());
1032     QSignalSpy spyCopyAvailabe(ed, SIGNAL(copyAvailable(bool)));
1033 
1034     //Execute Keystrokes
1035     foreach(keyPairType keyPair, keystrokes) {
1036         QTest::keyClick(ed, keyPair.first, keyPair.second );
1037     }
1038 
1039     //Execute ed->"function"
1040     if (function == "cut")
1041         ed->cut();
1042     else if (function == "copy")
1043         ed->copy();
1044     else if (function == "paste")
1045         ed->paste();
1046     else if (function == "undo")
1047         ed->paste();
1048     else if (function == "redo")
1049         ed->paste();
1050 
1051     //Compare spied signals
1052     QEXPECT_FAIL("Case7 T,A,A, <- + shift, <- + shift, <- + shift, ctrl + x, undo() | signals: true, false, true",
1053         "Wrong undo selection behaviour. Should be fixed in some future release. (See task: 132482)", Abort);
1054     QCOMPARE(spyCopyAvailabe.count(), copyAvailable.count());
1055     for (int i=0;i<spyCopyAvailabe.count(); i++) {
1056         QVariant variantSpyCopyAvailable = spyCopyAvailabe.at(i).at(0);
1057         QVERIFY2(variantSpyCopyAvailable.toBool() == copyAvailable.at(i), QString("Spied singnal: %1").arg(i).toLatin1());
1058     }
1059 }
1060 #endif
1061 
1062 void tst_QPlainTextEdit::undoRedoAfterSetContent()
1063 {
1064     QVERIFY(!ed->document()->isUndoAvailable());
1065     QVERIFY(!ed->document()->isRedoAvailable());
1066     ed->setPlainText("Foobar");
1067     QVERIFY(!ed->document()->isUndoAvailable());
1068     QVERIFY(!ed->document()->isRedoAvailable());
1069     ed->setPlainText("<p>bleh</p>");
1070     QVERIFY(!ed->document()->isUndoAvailable());
1071     QVERIFY(!ed->document()->isRedoAvailable());
1072 }
1073 
1074 void tst_QPlainTextEdit::numPadKeyNavigation()
1075 {
1076     ed->setPlainText("Hello World");
1077     QCOMPARE(ed->textCursor().position(), 0);
1078     QTest::keyClick(ed, Qt::Key_Right, Qt::KeypadModifier);
1079     QCOMPARE(ed->textCursor().position(), 1);
1080 }
1081 
1082 void tst_QPlainTextEdit::moveCursor()
1083 {
1084     ed->setPlainText("Test");
1085 
1086     QSignalSpy cursorMovedSpy(ed, SIGNAL(cursorPositionChanged()));
1087 
1088     QCOMPARE(ed->textCursor().position(), 0);
1089     ed->moveCursor(QTextCursor::NextCharacter);
1090     QCOMPARE(ed->textCursor().position(), 1);
1091     QCOMPARE(cursorMovedSpy.count(), 1);
1092     ed->moveCursor(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
1093     QCOMPARE(ed->textCursor().position(), 2);
1094     QCOMPARE(cursorMovedSpy.count(), 2);
1095     QCOMPARE(ed->textCursor().selectedText(), QString("e"));
1096 }
1097 
1098 class MyTextEdit : public QPlainTextEdit
1099 {
1100 public:
1101     inline MyTextEdit()
1102         : createMimeDataCallCount(0),
1103           canInsertCallCount(0),
1104           insertCallCount(0)
1105     {}
1106 
1107     mutable int createMimeDataCallCount;
1108     mutable int canInsertCallCount;
1109     mutable int insertCallCount;
1110 
1111     virtual QMimeData *createMimeDataFromSelection() const override {
1112         createMimeDataCallCount++;
1113         return QPlainTextEdit::createMimeDataFromSelection();
1114     }
1115     virtual bool canInsertFromMimeData(const QMimeData *source) const override {
1116         canInsertCallCount++;
1117         return QPlainTextEdit::canInsertFromMimeData(source);
1118     }
1119     virtual void insertFromMimeData(const QMimeData *source) override {
1120         insertCallCount++;
1121         QPlainTextEdit::insertFromMimeData(source);
1122     }
1123 
1124 };
1125 
1126 #ifndef QT_NO_CLIPBOARD
1127 void tst_QPlainTextEdit::mimeDataReimplementations()
1128 {
1129     MyTextEdit ed;
1130     ed.setPlainText("Hello World");
1131 
1132     QCOMPARE(ed.createMimeDataCallCount, 0);
1133     QCOMPARE(ed.canInsertCallCount, 0);
1134     QCOMPARE(ed.insertCallCount, 0);
1135 
1136     ed.selectAll();
1137 
1138     QCOMPARE(ed.createMimeDataCallCount, 0);
1139     QCOMPARE(ed.canInsertCallCount, 0);
1140     QCOMPARE(ed.insertCallCount, 0);
1141 
1142     ed.copy();
1143 
1144     QCOMPARE(ed.createMimeDataCallCount, 1);
1145     QCOMPARE(ed.canInsertCallCount, 0);
1146     QCOMPARE(ed.insertCallCount, 0);
1147 
1148 #ifdef QT_BUILD_INTERNAL
1149     QWidgetTextControl *control = ed.findChild<QWidgetTextControl *>();
1150     QVERIFY(control);
1151 
1152     control->canInsertFromMimeData(QApplication::clipboard()->mimeData());
1153 
1154     QCOMPARE(ed.createMimeDataCallCount, 1);
1155     QCOMPARE(ed.canInsertCallCount, 1);
1156     QCOMPARE(ed.insertCallCount, 0);
1157 
1158     ed.paste();
1159 
1160     QCOMPARE(ed.createMimeDataCallCount, 1);
1161     QCOMPARE(ed.canInsertCallCount, 1);
1162     QCOMPARE(ed.insertCallCount, 1);
1163 #endif
1164 }
1165 #endif
1166 
1167 void tst_QPlainTextEdit::shiftEnterShouldInsertLineSeparator()
1168 {
1169     QTest::keyClick(ed, Qt::Key_A);
1170     QTest::keyClick(ed, Qt::Key_Enter, Qt::ShiftModifier);
1171     QTest::keyClick(ed, Qt::Key_B);
1172     QString expected;
1173     expected += 'a';
1174     expected += QChar::LineSeparator;
1175     expected += 'b';
1176     QCOMPARE(ed->textCursor().block().text(), expected);
1177 }
1178 
1179 void tst_QPlainTextEdit::selectWordsFromStringsContainingSeparators_data()
1180 {
1181     QTest::addColumn<QString>("testString");
1182     QTest::addColumn<QString>("selectedWord");
1183 
1184     const ushort wordSeparators[] =
1185         {'.', ',', '?', '!', ':', ';', '-', '<', '>', '[', ']', '(', ')', '{', '}',
1186          '=', '\t', ushort(QChar::Nbsp)};
1187 
1188     for (size_t i = 0, count = sizeof(wordSeparators) / sizeof(wordSeparators[0]); i < count; ++i) {
1189         const ushort u = wordSeparators[i];
1190         QByteArray rowName = QByteArrayLiteral("separator: ");
1191         if (u >= 32 && u < 128)
1192             rowName += char(u);
1193         else
1194             rowName += QByteArrayLiteral("0x") + QByteArray::number(u, 16);
1195         QTest::newRow(rowName.constData()) << QString("foo") + QChar(u) + QString("bar") << QString("foo");
1196     }
1197 }
1198 
1199 void tst_QPlainTextEdit::selectWordsFromStringsContainingSeparators()
1200 {
1201     QFETCH(QString, testString);
1202     QFETCH(QString, selectedWord);
1203     ed->setPlainText(testString);
1204     QTextCursor cursor = ed->textCursor();
1205     cursor.movePosition(QTextCursor::StartOfLine);
1206     cursor.select(QTextCursor::WordUnderCursor);
1207     QVERIFY(cursor.hasSelection());
1208     QCOMPARE(cursor.selection().toPlainText(), selectedWord);
1209     cursor.clearSelection();
1210 }
1211 
1212 #ifndef QT_NO_CLIPBOARD
1213 void tst_QPlainTextEdit::canPaste()
1214 {
1215     if (!PlatformClipboard::isAvailable())
1216         QSKIP("Clipboard not working with cron-started unit tests");
1217 
1218     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
1219         QSKIP("Wayland: This fails. Figure out why.");
1220 
1221     QApplication::clipboard()->setText(QString());
1222     QVERIFY(!ed->canPaste());
1223     QApplication::clipboard()->setText("Test");
1224     QVERIFY(ed->canPaste());
1225     ed->setTextInteractionFlags(Qt::NoTextInteraction);
1226     QVERIFY(!ed->canPaste());
1227 }
1228 #endif
1229 
1230 void tst_QPlainTextEdit::ensureCursorVisibleOnInitialShow()
1231 {
1232     QString manyPagesOfPlainText;
1233     for (int i = 0; i < 800; ++i)
1234         manyPagesOfPlainText += QLatin1String("Blah blah blah blah blah blah\n");
1235 
1236     ed->setPlainText(manyPagesOfPlainText);
1237     QCOMPARE(ed->textCursor().position(), 0);
1238 
1239     ed->moveCursor(QTextCursor::End);
1240     ed->show();
1241     QVERIFY(ed->verticalScrollBar()->value() > 10);
1242 
1243     ed->moveCursor(QTextCursor::Start);
1244     QVERIFY(ed->verticalScrollBar()->value() < 10);
1245     ed->hide();
1246     ed->verticalScrollBar()->setValue(ed->verticalScrollBar()->maximum());
1247     ed->show();
1248     QCOMPARE(ed->verticalScrollBar()->value(), ed->verticalScrollBar()->maximum());
1249 }
1250 
1251 class TestEdit : public QPlainTextEdit
1252 {
1253 public:
1254     TestEdit() : resizeEventCalled(false) {}
1255 
1256     bool resizeEventCalled;
1257 
1258 protected:
1259     virtual void resizeEvent(QResizeEvent *e) override
1260     {
1261         QPlainTextEdit::resizeEvent(e);
1262         setPlainText("<img src=qtextbrowser-resizeevent.png width=" + QString::number(size().width()) + "><br>Size is " + QString::number(size().width()) + " x " + QString::number(size().height()));
1263         resizeEventCalled = true;
1264     }
1265 };
1266 
1267 void tst_QPlainTextEdit::setTextInsideResizeEvent()
1268 {
1269     TestEdit edit;
1270     edit.show();
1271     edit.resize(800, 600);
1272     QVERIFY(edit.resizeEventCalled);
1273 }
1274 
1275 void tst_QPlainTextEdit::colorfulAppend()
1276 {
1277     QTextCharFormat fmt;
1278 
1279     fmt.setForeground(QBrush(Qt::red));
1280     ed->mergeCurrentCharFormat(fmt);
1281     ed->appendPlainText("Red");
1282     fmt.setForeground(QBrush(Qt::blue));
1283     ed->mergeCurrentCharFormat(fmt);
1284     ed->appendPlainText("Blue");
1285     fmt.setForeground(QBrush(Qt::green));
1286     ed->mergeCurrentCharFormat(fmt);
1287     ed->appendPlainText("Green");
1288 
1289     QCOMPARE(ed->document()->blockCount(), 3);
1290     QTextBlock block = ed->document()->begin();
1291     QCOMPARE(block.begin().fragment().text(), QString("Red"));
1292     QVERIFY(block.begin().fragment().charFormat().foreground().color() == Qt::red);
1293     block = block.next();
1294     QCOMPARE(block.begin().fragment().text(), QString("Blue"));
1295     QVERIFY(block.begin().fragment().charFormat().foreground().color() == Qt::blue);
1296     block = block.next();
1297     QCOMPARE(block.begin().fragment().text(), QString("Green"));
1298     QVERIFY(block.begin().fragment().charFormat().foreground().color() == Qt::green);
1299 }
1300 
1301 void tst_QPlainTextEdit::ensureVisibleWithRtl()
1302 {
1303     ed->setLayoutDirection(Qt::RightToLeft);
1304     ed->setLineWrapMode(QPlainTextEdit::NoWrap);
1305     QString txt(500, QChar(QLatin1Char('a')));
1306     QCOMPARE(txt.length(), 500);
1307     ed->setPlainText(txt);
1308     ed->resize(100, 100);
1309     ed->show();
1310 
1311     qApp->processEvents();
1312 
1313     QVERIFY(ed->horizontalScrollBar()->maximum() > 0);
1314 
1315     ed->moveCursor(QTextCursor::Start);
1316     QCOMPARE(ed->horizontalScrollBar()->value(), ed->horizontalScrollBar()->maximum());
1317     ed->moveCursor(QTextCursor::End);
1318     QCOMPARE(ed->horizontalScrollBar()->value(), 0);
1319     ed->moveCursor(QTextCursor::Start);
1320     QCOMPARE(ed->horizontalScrollBar()->value(), ed->horizontalScrollBar()->maximum());
1321     ed->moveCursor(QTextCursor::End);
1322     QCOMPARE(ed->horizontalScrollBar()->value(), 0);
1323 }
1324 
1325 void tst_QPlainTextEdit::preserveCharFormatAfterSetPlainText()
1326 {
1327     QTextCharFormat fmt;
1328     fmt.setForeground(QBrush(Qt::blue));
1329     ed->mergeCurrentCharFormat(fmt);
1330     ed->setPlainText("This is blue");
1331     ed->appendPlainText("This should still be blue");
1332     QTextBlock block = ed->document()->begin();
1333     block = block.next();
1334     QCOMPARE(block.text(), QString("This should still be blue"));
1335     QCOMPARE(block.begin().fragment().charFormat().foreground().color(), QColor(Qt::blue));
1336 }
1337 
1338 void tst_QPlainTextEdit::extraSelections()
1339 {
1340     ed->setPlainText("Hello World");
1341 
1342     QTextCursor c = ed->textCursor();
1343     c.movePosition(QTextCursor::Start);
1344     c.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
1345     const int endPos = c.position();
1346 
1347     QTextEdit::ExtraSelection sel;
1348     sel.cursor = c;
1349     ed->setExtraSelections(QList<QTextEdit::ExtraSelection>() << sel);
1350 
1351     c.movePosition(QTextCursor::Start);
1352     c.movePosition(QTextCursor::NextWord);
1353     const int wordPos = c.position();
1354     c.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
1355     sel.cursor = c;
1356     ed->setExtraSelections(QList<QTextEdit::ExtraSelection>() << sel);
1357 
1358     QList<QTextEdit::ExtraSelection> selections = ed->extraSelections();
1359     QCOMPARE(selections.count(), 1);
1360     QCOMPARE(selections.at(0).cursor.position(), endPos);
1361     QCOMPARE(selections.at(0).cursor.anchor(), wordPos);
1362 }
1363 
1364 void tst_QPlainTextEdit::adjustScrollbars()
1365 {
1366 // For some reason ff is defined to be << on Mac Panther / gcc 3.3
1367 #undef ff
1368     QFont ff(ed->font());
1369     ff.setFamily("Tahoma");
1370     ff.setPointSize(11);
1371     ed->setFont(ff);
1372     ed->setMinimumSize(140, 100);
1373     ed->setMaximumSize(140, 100);
1374     ed->show();
1375     QLatin1String txt("\nabc def ghi jkl mno pqr stu vwx");
1376     ed->setPlainText(txt + txt + txt + txt);
1377 
1378     QVERIFY(ed->verticalScrollBar()->maximum() > 0);
1379 
1380     ed->moveCursor(QTextCursor::End);
1381     int oldMaximum = ed->verticalScrollBar()->maximum();
1382     QTextCursor cursor = ed->textCursor();
1383     cursor.insertText(QLatin1String("\n"));
1384     cursor.deletePreviousChar();
1385     QCOMPARE(ed->verticalScrollBar()->maximum(), oldMaximum);
1386 }
1387 
1388 class SignalReceiver : public QObject
1389 {
1390     Q_OBJECT
1391 public:
1392     SignalReceiver() : received(0) {}
1393 
1394     int receivedSignals() const { return received; }
1395     QTextCharFormat charFormat() const { return format; }
1396 
1397 public slots:
1398     void charFormatChanged(const QTextCharFormat &tcf) { ++received; format = tcf; }
1399 
1400 private:
1401     QTextCharFormat format;
1402     int received;
1403 };
1404 
1405 void tst_QPlainTextEdit::textObscuredByScrollbars()
1406 {
1407     ed->textCursor().insertText(
1408             "ab cab cab c abca kjsdf lka sjd lfk jsal df j kasdf abc ab abc "
1409             "a b c d e f g h i j k l m n o p q r s t u v w x y z "
1410             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1411             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1412             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1413             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1414             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1415             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1416             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1417             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1418             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1419             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1420     );
1421     ed->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
1422     ed->show();
1423 
1424     QSize documentSize = ed->document()->documentLayout()->documentSize().toSize();
1425     QSize viewportSize = ed->viewport()->size();
1426 
1427     QVERIFY(documentSize.width() <= viewportSize.width());
1428 }
1429 
1430 void tst_QPlainTextEdit::setTextPreservesUndoRedoEnabled()
1431 {
1432     QVERIFY(ed->isUndoRedoEnabled());
1433 
1434     ed->setPlainText("Test");
1435 
1436     QVERIFY(ed->isUndoRedoEnabled());
1437 
1438     ed->setUndoRedoEnabled(false);
1439     QVERIFY(!ed->isUndoRedoEnabled());
1440     ed->setPlainText("Test2");
1441     QVERIFY(!ed->isUndoRedoEnabled());
1442 
1443     ed->setPlainText("<p>hello");
1444     QVERIFY(!ed->isUndoRedoEnabled());
1445 }
1446 
1447 void tst_QPlainTextEdit::wordWrapProperty()
1448 {
1449     {
1450         QPlainTextEdit edit;
1451         QTextDocument *doc = new QTextDocument(&edit);
1452         doc->setDocumentLayout(new QPlainTextDocumentLayout(doc));
1453         edit.setDocument(doc);
1454         edit.setWordWrapMode(QTextOption::NoWrap);
1455         QCOMPARE(doc->defaultTextOption().wrapMode(), QTextOption::NoWrap);
1456     }
1457     {
1458         QPlainTextEdit edit;
1459         QTextDocument *doc = new QTextDocument(&edit);
1460         doc->setDocumentLayout(new QPlainTextDocumentLayout(doc));
1461         edit.setWordWrapMode(QTextOption::NoWrap);
1462         edit.setDocument(doc);
1463         QCOMPARE(doc->defaultTextOption().wrapMode(), QTextOption::NoWrap);
1464     }
1465 }
1466 
1467 void tst_QPlainTextEdit::lineWrapProperty()
1468 {
1469     QCOMPARE(ed->wordWrapMode(), QTextOption::WrapAtWordBoundaryOrAnywhere);
1470     QCOMPARE(ed->lineWrapMode(), QPlainTextEdit::WidgetWidth);
1471     ed->setLineWrapMode(QPlainTextEdit::NoWrap);
1472     QCOMPARE(ed->lineWrapMode(), QPlainTextEdit::NoWrap);
1473     QCOMPARE(ed->wordWrapMode(), QTextOption::WrapAtWordBoundaryOrAnywhere);
1474     QCOMPARE(ed->document()->defaultTextOption().wrapMode(), QTextOption::NoWrap);
1475 }
1476 
1477 void tst_QPlainTextEdit::selectionChanged()
1478 {
1479     ed->setPlainText("Hello World");
1480 
1481     ed->moveCursor(QTextCursor::Start);
1482 
1483     QSignalSpy selectionChangedSpy(ed, SIGNAL(selectionChanged()));
1484 
1485     QTest::keyClick(ed, Qt::Key_Right);
1486     QCOMPARE(ed->textCursor().position(), 1);
1487     QCOMPARE(selectionChangedSpy.count(), 0);
1488 
1489     QTest::keyClick(ed, Qt::Key_Right, Qt::ShiftModifier);
1490     QCOMPARE(ed->textCursor().position(), 2);
1491     QCOMPARE(selectionChangedSpy.count(), 1);
1492 
1493     QTest::keyClick(ed, Qt::Key_Right, Qt::ShiftModifier);
1494     QCOMPARE(ed->textCursor().position(), 3);
1495     QCOMPARE(selectionChangedSpy.count(), 2);
1496 
1497     QTest::keyClick(ed, Qt::Key_Right, Qt::ShiftModifier);
1498     QCOMPARE(ed->textCursor().position(), 4);
1499     QCOMPARE(selectionChangedSpy.count(), 3);
1500 
1501     QTest::keyClick(ed, Qt::Key_Right);
1502     QCOMPARE(ed->textCursor().position(), 4);
1503     QCOMPARE(selectionChangedSpy.count(), 4);
1504 
1505     QTest::keyClick(ed, Qt::Key_Right);
1506     QCOMPARE(ed->textCursor().position(), 5);
1507     QCOMPARE(selectionChangedSpy.count(), 4);
1508 }
1509 
1510 void tst_QPlainTextEdit::blockCountChanged()
1511 {
1512     QSignalSpy blockCountCpangedSpy(ed, SIGNAL(blockCountChanged(int)));
1513     ed->setPlainText("Hello");
1514     QCOMPARE(blockCountCpangedSpy.count(), 0);
1515     ed->setPlainText("Hello World");
1516     QCOMPARE(blockCountCpangedSpy.count(), 0);
1517     ed->setPlainText("Hello \n World \n this \n has \n more \n blocks \n than \n just \n one");
1518     QCOMPARE(blockCountCpangedSpy.count(), 1);
1519     ed->setPlainText("One");
1520     QCOMPARE(blockCountCpangedSpy.count(), 2);
1521     ed->setPlainText("One \n Two");
1522     QCOMPARE(blockCountCpangedSpy.count(), 3);
1523     ed->setPlainText("Three \n Four");
1524     QCOMPARE(blockCountCpangedSpy.count(), 3);
1525 }
1526 
1527 
1528 void tst_QPlainTextEdit::insertAndScrollToBottom()
1529 {
1530     ed->setPlainText("First Line");
1531     ed->show();
1532     QString text;
1533     for(int i = 0; i < 2000; ++i) {
1534         text += QLatin1String("this is another line of text to be appended. It is quite long and will probably wrap around, meaning the number of lines is larger than the number of blocks in the text.\n");
1535     }
1536     QTextCursor cursor = ed->textCursor();
1537     cursor.beginEditBlock();
1538     cursor.insertText(text);
1539     cursor.endEditBlock();
1540     ed->verticalScrollBar()->setValue(ed->verticalScrollBar()->maximum());
1541     QCOMPARE(ed->verticalScrollBar()->value(), ed->verticalScrollBar()->maximum());
1542 }
1543 
1544 Q_DECLARE_METATYPE(Qt::InputMethodHints)
1545 void tst_QPlainTextEdit::inputMethodQueryImHints_data()
1546 {
1547     QTest::addColumn<Qt::InputMethodHints>("hints");
1548 
1549     QTest::newRow("None") << static_cast<Qt::InputMethodHints>(Qt::ImhNone);
1550     QTest::newRow("Password") << static_cast<Qt::InputMethodHints>(Qt::ImhHiddenText);
1551     QTest::newRow("Normal") << static_cast<Qt::InputMethodHints>(Qt::ImhNoAutoUppercase | Qt::ImhNoPredictiveText | Qt::ImhSensitiveData);
1552 }
1553 
1554 void tst_QPlainTextEdit::inputMethodQueryImHints()
1555 {
1556     QFETCH(Qt::InputMethodHints, hints);
1557     ed->setInputMethodHints(hints);
1558 
1559     QVariant value = ed->inputMethodQuery(Qt::ImHints);
1560     QCOMPARE(static_cast<Qt::InputMethodHints>(value.toInt()), hints);
1561 }
1562 
1563 #if QT_CONFIG(regularexpression)
1564 void tst_QPlainTextEdit::findWithRegularExpression()
1565 {
1566     ed->setPlainText(QStringLiteral("arbitrary text"));
1567     QRegularExpression rx("\\w{2}xt");
1568 
1569     bool found = ed->find(rx);
1570 
1571     QVERIFY(found);
1572     QCOMPARE(ed->textCursor().selectedText(), QStringLiteral("text"));
1573 }
1574 
1575 void tst_QPlainTextEdit::findBackwardWithRegularExpression()
1576 {
1577     ed->setPlainText(QStringLiteral("arbitrary text"));
1578     QTextCursor cursor = ed->textCursor();
1579     cursor.movePosition(QTextCursor::End);
1580     ed->setTextCursor(cursor);
1581     QRegularExpression rx("a\\w*t");
1582 
1583     bool found = ed->find(rx, QTextDocument::FindBackward);
1584 
1585     QVERIFY(found);
1586     QCOMPARE(ed->textCursor().selectedText(), QStringLiteral("arbit"));
1587 }
1588 
1589 void tst_QPlainTextEdit::findWithRegularExpressionReturnsFalseIfNoMoreResults()
1590 {
1591     ed->setPlainText(QStringLiteral("arbitrary text"));
1592     QRegularExpression rx("t.xt");
1593     ed->find(rx);
1594 
1595     bool found = ed->find(rx);
1596 
1597     QVERIFY(!found);
1598     QCOMPARE(ed->textCursor().selectedText(), QStringLiteral("text"));
1599 }
1600 #endif
1601 
1602 void tst_QPlainTextEdit::layoutAfterMultiLineRemove()
1603 {
1604     ed->setVisible(true); // The widget must be visible to reproduce this bug.
1605 
1606     QString contents;
1607     for (int i = 0; i < 5; ++i)
1608         contents.append("\ttest\n");
1609 
1610     ed->setPlainText(contents);
1611 
1612     /*
1613      * Remove the tab from the beginning of lines 2-4, in an edit block. The
1614      * edit block is required for the bug to be reproduced.
1615      */
1616 
1617     QTextCursor curs = ed->textCursor();
1618     curs.movePosition(QTextCursor::Start);
1619     curs.movePosition(QTextCursor::NextBlock);
1620 
1621     curs.beginEditBlock();
1622     for (int i = 0; i < 3; ++i) {
1623         curs.deleteChar();
1624         curs.movePosition(QTextCursor::NextBlock);
1625     }
1626     curs.endEditBlock();
1627 
1628     /*
1629      * Now, we're going to perform the following actions:
1630      *
1631      *     - Move to the beginning of the document.
1632      *     - Move down three times - this should put us at the front of block 3.
1633      *     - Move to the end of the line.
1634      *
1635      * At this point, if the document layout is behaving correctly, we should
1636      * still be positioned on block 3. Verify that this is the case.
1637      */
1638 
1639     curs.movePosition(QTextCursor::Start);
1640     curs.movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, 3);
1641     curs.movePosition(QTextCursor::EndOfLine);
1642 
1643     QCOMPARE(curs.blockNumber(), 3);
1644 }
1645 
1646 void tst_QPlainTextEdit::undoCommandRemovesAndReinsertsBlock()
1647 {
1648     ed->setVisible(true);
1649     ed->setPlainText(QStringLiteral("line1\nline2"));
1650     QCOMPARE(ed->document()->blockCount(), 2);
1651 
1652     QTextCursor cursor = ed->textCursor();
1653     cursor.movePosition(QTextCursor::Start);
1654     cursor.movePosition(QTextCursor::NextBlock, QTextCursor::KeepAnchor);
1655     cursor.insertText(QStringLiteral("\n"));
1656     QCOMPARE(ed->document()->blockCount(), 2);
1657 
1658     ed->undo();
1659     QCOMPARE(ed->document()->blockCount(), 2);
1660 
1661     QTextBlock block;
1662     for (block = ed->document()->begin(); block != ed->document()->end(); block = block.next()) {
1663         QVERIFY(block.isValid());
1664         QCOMPARE(block.length(), 6);
1665         QVERIFY(block.layout()->lineForTextPosition(0).isValid());
1666     }
1667 
1668 }
1669 
1670 class ContentsChangedFunctor {
1671 public:
1672     ContentsChangedFunctor(QPlainTextEdit *t) : textEdit(t) {}
1673     void operator()(int, int, int)
1674     {
1675         QTextCursor c(textEdit->textCursor());
1676         c.beginEditBlock();
1677         c.movePosition(QTextCursor::Start);
1678         c.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
1679         c.setCharFormat(QTextCharFormat());
1680         c.endEditBlock();
1681     }
1682 
1683 private:
1684     QPlainTextEdit *textEdit;
1685 };
1686 
1687 void tst_QPlainTextEdit::taskQTBUG_43562_lineCountCrash()
1688 {
1689     connect(ed->document(), &QTextDocument::contentsChange, ContentsChangedFunctor(ed));
1690     // Don't crash
1691     QTest::keyClicks(ed, "Some text");
1692     QTest::keyClick(ed, Qt::Key_Left);
1693     QTest::keyClick(ed, Qt::Key_Right);
1694     QTest::keyClick(ed, Qt::Key_A);
1695     QTest::keyClick(ed, Qt::Key_Left);
1696     QTest::keyClick(ed, Qt::Key_Right);
1697     QTest::keyClick(ed, Qt::Key_Space);
1698     QTest::keyClicks(ed, "nd some more");
1699     disconnect(ed->document(), SIGNAL(contentsChange(int, int, int)), 0, 0);
1700 }
1701 
1702 #ifndef QT_NO_CONTEXTMENU
1703 void tst_QPlainTextEdit::contextMenu()
1704 {
1705     ed->appendHtml(QStringLiteral("Hello <a href='http://www.qt.io'>Qt</a>"));
1706 
1707     QMenu *menu = ed->createStandardContextMenu();
1708     QVERIFY(menu);
1709     QAction *action = ed->findChild<QAction *>(QStringLiteral("link-copy"));
1710     QVERIFY(!action);
1711     delete menu;
1712     QVERIFY(!ed->findChild<QAction *>(QStringLiteral("link-copy")));
1713 
1714     ed->setTextInteractionFlags(Qt::TextBrowserInteraction);
1715 
1716     menu = ed->createStandardContextMenu();
1717     QVERIFY(menu);
1718     action = ed->findChild<QAction *>(QStringLiteral("link-copy"));
1719     QVERIFY(action);
1720     QVERIFY(!action->isEnabled());
1721     delete menu;
1722     QVERIFY(!ed->findChild<QAction *>(QStringLiteral("link-copy")));
1723 
1724     QTextCursor cursor = ed->textCursor();
1725     cursor.setPosition(ed->toPlainText().length() - 2);
1726     ed->setTextCursor(cursor);
1727 
1728     menu = ed->createStandardContextMenu(ed->cursorRect().center());
1729     QVERIFY(menu);
1730     action = ed->findChild<QAction *>(QStringLiteral("link-copy"));
1731     QVERIFY(action);
1732     QVERIFY(action->isEnabled());
1733     delete menu;
1734     QVERIFY(!ed->findChild<QAction *>(QStringLiteral("link-copy")));
1735 }
1736 #endif // QT_NO_CONTEXTMENU
1737 
1738 // QTBUG-51923: Verify that the cursor rectangle returned by the input
1739 // method query correctly reflects the viewport offset.
1740 void tst_QPlainTextEdit::inputMethodCursorRect()
1741 {
1742     ed->setPlainText("Line1\nLine2Line3\nLine3");
1743     ed->moveCursor(QTextCursor::End);
1744     const QRectF cursorRect = ed->cursorRect();
1745     const QVariant cursorRectV = ed->inputMethodQuery(Qt::ImCursorRectangle);
1746     QCOMPARE(cursorRectV.userType(), QMetaType::QRectF);
1747     QCOMPARE(cursorRectV.toRect(), cursorRect.toRect());
1748 }
1749 
1750 #if QT_CONFIG(scrollbar)
1751 // QTBUG-64730: Verify that the scrollbar is updated after center on scroll was set
1752 void tst_QPlainTextEdit::updateAfterChangeCenterOnScroll()
1753 {
1754     ed->setPlainText("Line1\nLine2Line3\nLine3");
1755     ed->show();
1756     ed->setCenterOnScroll(true);
1757     const int maxWithCenterOnScroll = ed->verticalScrollBar()->maximum();
1758     ed->setCenterOnScroll(false);
1759     const int maxWithoutCenterOnScroll = ed->verticalScrollBar()->maximum();
1760     QVERIFY(maxWithCenterOnScroll > maxWithoutCenterOnScroll);
1761 }
1762 
1763 #endif
1764 
1765 #ifndef QT_NO_CLIPBOARD
1766 void tst_QPlainTextEdit::updateCursorPositionAfterEdit()
1767 {
1768     QPlainTextEdit plaintextEdit;
1769     plaintextEdit.setPlainText("some text some text\nsome text some text");
1770 
1771     const auto initialPosition = 1;
1772 
1773     // select some text
1774     auto cursor = plaintextEdit.textCursor();
1775     cursor.setPosition(initialPosition, QTextCursor::MoveAnchor);
1776     cursor.setPosition(initialPosition + 3, QTextCursor::KeepAnchor);
1777     plaintextEdit.setTextCursor(cursor);
1778     QVERIFY(plaintextEdit.textCursor().hasSelection());
1779 
1780     QTest::keyClick(&plaintextEdit, Qt::Key_Delete);
1781     QTest::keyClick(&plaintextEdit, Qt::Key_Down);
1782     QTest::keyClick(&plaintextEdit, Qt::Key_Up);
1783 
1784     // Moving the cursor down and up should bring it to the initial position
1785     QCOMPARE(plaintextEdit.textCursor().position(), initialPosition);
1786 
1787     // Test the same with backspace
1788     cursor = plaintextEdit.textCursor();
1789     cursor.setPosition(initialPosition + 3, QTextCursor::KeepAnchor);
1790     plaintextEdit.setTextCursor(cursor);
1791     QVERIFY(plaintextEdit.textCursor().hasSelection());
1792 
1793     QTest::keyClick(&plaintextEdit, Qt::Key_Backspace);
1794     QTest::keyClick(&plaintextEdit, Qt::Key_Down);
1795     QTest::keyClick(&plaintextEdit, Qt::Key_Up);
1796 
1797     // Moving the cursor down and up should bring it to the initial position
1798     QCOMPARE(plaintextEdit.textCursor().position(), initialPosition);
1799 
1800     // Test insertion
1801     const QString txt("txt");
1802     QApplication::clipboard()->setText(txt);
1803     plaintextEdit.paste();
1804     QTest::keyClick(&plaintextEdit, Qt::Key_Down);
1805     QTest::keyClick(&plaintextEdit, Qt::Key_Up);
1806 
1807     // The curser should move back to the end of the copied text
1808     QCOMPARE(plaintextEdit.textCursor().position(), initialPosition + txt.length());
1809 }
1810 #endif
1811 
1812 void tst_QPlainTextEdit::appendTextWhenInvisible()
1813 {
1814     QWidget window;
1815     window.resize(640, 480);
1816 
1817     QPlainTextEdit *plainTextEdit = new QPlainTextEdit(&window);
1818     plainTextEdit->resize(320, 240);
1819 
1820     window.show();
1821     QVERIFY(QTest::qWaitForWindowActive(&window));
1822 
1823     // this should be long enough to let vertical scroll bar show up
1824     const QString baseText("text\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntext");
1825     const QString textToAppend("aaa");
1826 
1827     plainTextEdit->setPlainText(baseText + "\n" + textToAppend);
1828     const auto maxAfterSet = plainTextEdit->verticalScrollBar()->maximum();
1829     // make sure the vertical scroll bar is visible
1830     QVERIFY(maxAfterSet != 0);
1831 
1832     plainTextEdit->clear();
1833     plainTextEdit->setPlainText(baseText);
1834     plainTextEdit->hide();
1835     plainTextEdit->appendPlainText(textToAppend);
1836     plainTextEdit->show();
1837     const auto maxAfterAppend = plainTextEdit->verticalScrollBar()->maximum();
1838     QVERIFY(maxAfterAppend != 0);
1839 
1840     QCOMPARE(maxAfterAppend, maxAfterSet);
1841 }
1842 
1843 void tst_QPlainTextEdit::autoPlaceholderVisibility_data()
1844 {
1845     // "nosetPlaceholderText" : not set placeholderText
1846     // "nosetPlainText" : not set plainText
1847     // "setEmptyPlaceholderText" : set empty placeholderText
1848     // "setEmptyPlainText" : set empty plainText
1849     // "setPlaceholderText" : set non-empty placeholderText
1850     // "setPlainText" : set non-empty plainText
1851 
1852     QTest::addColumn<QStringList>("targetStringList");
1853     QTest::addColumn<bool>("placeholderVisible");
1854 
1855     {
1856         QStringList lst = { "nosetPlaceholderText",
1857                             "nosetPlainText" };
1858         QTest::addRow("no placeholder set + no text set")
1859                 << lst
1860                 << true;
1861     }
1862 
1863     {
1864         QStringList lst = { "nosetPlaceholderText",
1865                             "setPlainText" };
1866         QTest::addRow("no placeholder set + text set")
1867                 << lst
1868                 << false;
1869     }
1870 
1871     {
1872         QStringList lst = { "nosetPlaceholderText",
1873                             "setPlainText",
1874                             "setEmptyPlainText" };
1875         QTest::addRow("no placeholder set + text set + empty text set")
1876                 << lst
1877                 << false;
1878     }
1879 
1880     {
1881         QStringList lst = { "nosetPlaceholderText",
1882                             "setEmptyPlainText",
1883                             "setPlainText" };
1884         QTest::addRow("no placeholder set + empty text set + text set")
1885                 << lst
1886                 << false;
1887     }
1888 
1889     {
1890         QStringList lst = { "setEmptyPlaceholderText",
1891                             "nosetPlainText" };
1892         QTest::addRow("empty placeholder set + no text set")
1893                 << lst
1894                 << true;
1895     }
1896 
1897     {
1898         QStringList lst = { "setEmptyPlaceholderText",
1899                             "setPlainText" };
1900         QTest::addRow("empty placeholder set + text set")
1901                 << lst
1902                 << false;
1903     }
1904 
1905     {
1906         QStringList lst = { "setEmptyPlaceholderText",
1907                             "setEmptyPlainText",
1908                             "setPlainText" };
1909         QTest::addRow("empty placeholder set + text set + empty text set")
1910                 << lst
1911                 << false;
1912     }
1913 
1914     {
1915         QStringList lst = { "setEmptyPlaceholderText",
1916                             "setPlainText",
1917                             "setEmptyPlainText" };
1918         QTest::addRow("empty placeholder set + empty text set + text set")
1919                 << lst
1920                 << false;
1921     }
1922 
1923     {
1924         QStringList lst = { "setPlaceholderText",
1925                             "nosetPlainText" };
1926         QTest::addRow("placeholder set + no text set")
1927                 << lst
1928                 << true;
1929     }
1930 
1931     {
1932         QStringList lst = { "setPlaceholderText",
1933                             "setPlainText" };
1934         QTest::addRow("placeholder set + text set")
1935                 << lst
1936                 << false;
1937     }
1938 
1939     {
1940         QStringList lst = { "setPlaceholderText",
1941                             "setPlainText",
1942                             "setEmptyPlainText" };
1943         QTest::addRow("placeholder set + text set + empty text set")
1944                 << lst
1945                 << true;
1946     }
1947 
1948     {
1949         QStringList lst = { "setPlaceholderText",
1950                             "setEmptyPlainText",
1951                             "setPlainText" };
1952         QTest::addRow("placeholder set + empty text set + text set")
1953                 << lst
1954                 << false;
1955     }
1956 
1957     {
1958         QStringList lst = { "setPlaceholderText",
1959                             "setPlainText",
1960                             "setEmptyPlaceholderText" };
1961         QTest::addRow("placeholder set + text set + empty placeholder set")
1962                 << lst
1963                 << false;
1964     }
1965 
1966     {
1967         QStringList lst = { "setPlaceholderText",
1968                             "setEmptyPlaceholderText",
1969                             "setPlainText" };
1970         QTest::addRow("placeholder set + empty placeholder set + text set")
1971                 << lst
1972                 << false;
1973     }
1974 
1975     {
1976         QStringList lst = { "setPlaceholderText",
1977                             "setEmptyPlaceholderText",
1978                             "setEmptyPlainText" };
1979         QTest::addRow("placeholder set + empty placeholder set + empty text set")
1980                 << lst
1981                 << false;
1982     }
1983 
1984     {
1985         QStringList lst = { "setPlaceholderText",
1986                             "setEmptyPlainText"
1987                             "setEmptyPlaceholderText" };
1988         QTest::addRow("placeholder set + empty text set + empty placeholder set")
1989                 << lst
1990                 << true;
1991     }
1992 
1993     {
1994         QStringList lst = { "setPlainText",
1995                             "nosetPlaceholderText" };
1996         QTest::addRow("text set + no placeholder set")
1997                 << lst
1998                 << false;
1999     }
2000 
2001     {
2002         QStringList lst = { "setPlainText",
2003                             "nosetPlaceholderText",
2004                             "setEmptyPlainText" };
2005         QTest::addRow("text set + no placeholder set + empty text set")
2006                 << lst
2007                 << false;
2008     }
2009 
2010     {
2011         QStringList lst = { "setPlainText",
2012                             "setEmptyPlaceholderText" };
2013         QTest::addRow("text set + empty placeholder set")
2014                 << lst
2015                 << false;
2016     }
2017 
2018     {
2019         QStringList lst = { "setPlainText",
2020                             "setEmptyPlaceholderText",
2021                             "setEmptyPlainText"};
2022         QTest::addRow("text set + empty placeholder set + empty text set")
2023                 << lst
2024                 << false;//?
2025     }
2026 
2027     {
2028         QStringList lst = { "setPlainText",
2029                             "setPlaceholderText" };
2030         QTest::addRow("text set + placeholder set")
2031                 << lst
2032                 << false;
2033     }
2034 
2035     {
2036         QStringList lst = { "setPlainText",
2037                             "setPlaceholderText",
2038                             "setEmptyPlainText" };
2039         QTest::addRow("text set + placeholder set + empty text set")
2040                 << lst
2041                 << true;
2042     }
2043 
2044     {
2045         QStringList lst = { "setPlainText",
2046                             "setPlaceholderText",
2047                             "setEmptyPlaceholderText" };
2048         QTest::addRow("text set + placeholder set + empty placeholder set")
2049                 << lst
2050                 << false;
2051     }
2052 }
2053 
2054 void tst_QPlainTextEdit::autoPlaceholderVisibility()
2055 {
2056     const auto pimplOf = [](QPlainTextEdit &it) {
2057         return static_cast<QPlainTextEditPrivate *>(qt_widget_private(&it));
2058     };
2059 
2060     QFETCH(QStringList, targetStringList);
2061     QFETCH(bool, placeholderVisible);
2062 
2063     QPlainTextEdit *tempPtEdit = new  QPlainTextEdit;
2064     for (auto targetText : targetStringList) {
2065         if (("nosetPlaceholderText" == targetText) | ("nosetPlainText" == targetText)) {
2066             continue;
2067         }
2068         if ("setEmptyPlaceholderText" == targetText) {
2069             tempPtEdit->setPlaceholderText("");
2070         }
2071         if ("setEmptyPlainText" == targetText) {
2072             tempPtEdit->setPlainText("");
2073         }
2074         if ("setPlaceholderText" == targetText) {
2075             tempPtEdit->setPlaceholderText(targetText);
2076         }
2077         if ("setPlainText" == targetText) {
2078             tempPtEdit->setPlainText(targetText);
2079         }
2080     }
2081     tempPtEdit->show();
2082     QVERIFY(QTest::qWaitForWindowExposed(tempPtEdit));
2083     auto result = pimplOf(*tempPtEdit)->placeholderVisible == placeholderVisible;
2084     QTRY_VERIFY(result);
2085     delete tempPtEdit;
2086 }
2087 
2088 QTEST_MAIN(tst_QPlainTextEdit)
2089 #include "tst_qplaintextedit.moc"
