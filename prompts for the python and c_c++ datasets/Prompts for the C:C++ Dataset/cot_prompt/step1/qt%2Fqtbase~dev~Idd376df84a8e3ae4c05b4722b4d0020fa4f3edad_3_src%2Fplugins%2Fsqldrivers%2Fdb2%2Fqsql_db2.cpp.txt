Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
DB2: Pass on the native error codes to QSqlError

Since DB2 can potentially have more than one error code, we need to join
these together using ';' as a separator.

Task-number: QTBUG-142
Change-Id: Idd376df84a8e3ae4c05b4722b4d0020fa4f3edad

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtSql module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qsql_db2_p.h"
41 #include <qcoreapplication.h>
42 #include <qdatetime.h>
43 #include <qsqlfield.h>
44 #include <qsqlerror.h>
45 #include <qsqlindex.h>
46 #include <qsqlrecord.h>
47 #include <qstringlist.h>
48 #include <qvarlengtharray.h>
49 #include <qvector.h>
50 #include <QDebug>
51 #include <QtSql/private/qsqldriver_p.h>
52 #include <QtSql/private/qsqlresult_p.h>
53 
54 #if defined(Q_CC_BOR)
55 // DB2's sqlsystm.h (included through sqlcli1.h) defines the SQL_BIGINT_TYPE
56 // and SQL_BIGUINT_TYPE to wrong the types for Borland; so do the defines to
57 // the right type before including the header
58 #define SQL_BIGINT_TYPE qint64
59 #define SQL_BIGUINT_TYPE quint64
60 #endif
61 
62 #include <sqlcli1.h>
63 
64 #include <string.h>
65 
66 QT_BEGIN_NAMESPACE
67 
68 static const int COLNAMESIZE = 255;
69 // Based on what is mentioned in the documentation here:
70 // https://www.ibm.com/support/knowledgecenter/en/SSEPEK_10.0.0/sqlref/src/tpc/db2z_limits.html
71 // The limit is 128 bytes for table names
72 static const SQLSMALLINT TABLENAMESIZE = 128;
73 static const SQLSMALLINT qParamType[4] = { SQL_PARAM_INPUT, SQL_PARAM_INPUT, SQL_PARAM_OUTPUT, SQL_PARAM_INPUT_OUTPUT };
74 
75 class QDB2DriverPrivate : public QSqlDriverPrivate
76 {
77     Q_DECLARE_PUBLIC(QDB2Driver)
78 
79 public:
80     QDB2DriverPrivate() : QSqlDriverPrivate(), hEnv(0), hDbc(0) { dbmsType = QSqlDriver::DB2; }
81     SQLHANDLE hEnv;
82     SQLHANDLE hDbc;
83     QString user;
84 };
85 
86 class QDB2ResultPrivate;
87 
88 class QDB2Result: public QSqlResult
89 {
90     Q_DECLARE_PRIVATE(QDB2Result)
91 
92 public:
93     QDB2Result(const QDB2Driver *drv);
94     ~QDB2Result();
95     bool prepare(const QString &query) override;
96     bool exec() override;
97     QVariant handle() const override;
98 
99 protected:
100     QVariant data(int field) override;
101     bool reset(const QString &query) override;
102     bool fetch(int i) override;
103     bool fetchNext() override;
104     bool fetchFirst() override;
105     bool fetchLast() override;
106     bool isNull(int i) override;
107     int size() override;
108     int numRowsAffected() override;
109     QSqlRecord record() const override;
110     void virtual_hook(int id, void *data) override;
111     void detachFromResultSet() override;
112     bool nextResult() override;
113 };
114 
115 class QDB2ResultPrivate: public QSqlResultPrivate
116 {
117     Q_DECLARE_PUBLIC(QDB2Result)
118 
119 public:
120     Q_DECLARE_SQLDRIVER_PRIVATE(QDB2Driver)
121     QDB2ResultPrivate(QDB2Result *q, const QDB2Driver *drv)
122         : QSqlResultPrivate(q, drv),
123           hStmt(0)
124     {}
125     ~QDB2ResultPrivate()
126     {
127         emptyValueCache();
128     }
129     void clearValueCache()
130     {
131         for (int i = 0; i < valueCache.count(); ++i) {
132             delete valueCache[i];
133             valueCache[i] = NULL;
134         }
135     }
136     void emptyValueCache()
137     {
138         clearValueCache();
139         valueCache.clear();
140     }
141 
142     SQLHANDLE hStmt;
143     QSqlRecord recInf;
144     QVector<QVariant*> valueCache;
145 };
146 
147 static QString qFromTChar(SQLTCHAR* str)
148 {
149     return QString((const QChar *)str);
150 }
151 
152 // dangerous!! (but fast). Don't use in functions that
153 // require out parameters!
154 static SQLTCHAR* qToTChar(const QString& str)
155 {
156     return (SQLTCHAR*)str.utf16();
157 }
158 
159 static QString qWarnDB2Handle(int handleType, SQLHANDLE handle, int *errorCode)
160 {
161     SQLINTEGER nativeCode;
162     SQLSMALLINT msgLen;
163     SQLRETURN r = SQL_ERROR;
164     SQLTCHAR state[SQL_SQLSTATE_SIZE + 1];
165     SQLTCHAR description[SQL_MAX_MESSAGE_LENGTH];
166     r = SQLGetDiagRec(handleType,
167                        handle,
168                        1,
169                        (SQLTCHAR*) state,
170                        &nativeCode,
171                        (SQLTCHAR*) description,
172                        SQL_MAX_MESSAGE_LENGTH - 1, /* in bytes, not in characters */
173                        &msgLen);
174     if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {
175         if (errorCode)
176             *errorCode = nativeCode;
177         return QString(qFromTChar(description));
178     }
179     return QString();
180 }
181 
182 static QString qDB2Warn(const QDB2DriverPrivate* d, QStringList *errorCodes = nullptr)
183 {
184     int errorCode = 0;
185     QString error = qWarnDB2Handle(SQL_HANDLE_ENV, d->hEnv, &errorCode);
186     if (errorCodes && errorCode != 0) {
187         *errorCodes << QString::number(errorCode);
188         errorCode = 0;
189     }
190     if (!error.isEmpty())
191         error += QLatin1Char(' ');
192     error += qWarnDB2Handle(SQL_HANDLE_DBC, d->hDbc, &errorCode);
193     if (errorCodes && errorCode != 0)
194         *errorCodes << QString::number(errorCode);
195     return error;
196 }
197 
198 static QString qDB2Warn(const QDB2ResultPrivate* d, QStringList *errorCodes = nullptr)
199 {
200     int errorCode = 0;
201     QString error = qWarnDB2Handle(SQL_HANDLE_ENV, d->drv_d_func()->hEnv, &errorCode);
202     if (errorCode != 0) {
203         *errorCodes << QString::number(errorCode);
204         errorCode = 0;
205     }
206     if (!error.isEmpty())
207         error += QLatin1Char(' ');
208     error += qWarnDB2Handle(SQL_HANDLE_DBC, d->drv_d_func()->hDbc, &errorCode);
209     if (errorCodes && errorCode != 0) {
210         *errorCodes << QString::number(errorCode);
211         errorCode = 0;
212     }
213     if (!error.isEmpty())
214         error += QLatin1Char(' ');
215     error += qWarnDB2Handle(SQL_HANDLE_STMT, d->hStmt, &errorCode);
216     if (errorCodes && errorCode != 0)
217         *errorCodes << QString::number(errorCode);
218     return error;
219 }
220 
221 static void qSqlWarning(const QString& message, const QDB2DriverPrivate* d)
222 {
223     qWarning("%s\tError: %s", message.toLocal8Bit().constData(),
224                               qDB2Warn(d).toLocal8Bit().constData());
225 }
226 
227 static void qSqlWarning(const QString& message, const QDB2ResultPrivate* d)
228 {
229     qWarning("%s\tError: %s", message.toLocal8Bit().constData(),
230                               qDB2Warn(d).toLocal8Bit().constData());
231 }
232 
233 static QSqlError qMakeError(const QString& err, QSqlError::ErrorType type,
234                             const QDB2DriverPrivate* p)
235 {
236     QStringList errorCodes;
237     return QSqlError(QStringLiteral("QDB2: ") + err, qDB2Warn(p, &errorCodes), type,
238                      errorCodes.join(QLatin1Char(';')));
239 }
240 
241 static QSqlError qMakeError(const QString& err, QSqlError::ErrorType type,
242                             const QDB2ResultPrivate* p)
243 {
244     QStringList errorCodes;
245     return QSqlError(QStringLiteral("QDB2: ") + err, qDB2Warn(p, &errorCodes), type,
246                      errorCodes.join(QLatin1Char(';')));
247 }
248 
249 static QVariant::Type qDecodeDB2Type(SQLSMALLINT sqltype)
250 {
251     QVariant::Type type = QVariant::Invalid;
252     switch (sqltype) {
253     case SQL_REAL:
254     case SQL_FLOAT:
255     case SQL_DOUBLE:
256     case SQL_DECIMAL:
257     case SQL_NUMERIC:
258         type = QVariant::Double;
259         break;
260     case SQL_SMALLINT:
261     case SQL_INTEGER:
262     case SQL_BIT:
263     case SQL_TINYINT:
264         type = QVariant::Int;
265         break;
266     case SQL_BIGINT:
267         type = QVariant::LongLong;
268         break;
269     case SQL_BLOB:
270     case SQL_BINARY:
271     case SQL_VARBINARY:
272     case SQL_LONGVARBINARY:
273     case SQL_CLOB:
274     case SQL_DBCLOB:
275         type = QVariant::ByteArray;
276         break;
277     case SQL_DATE:
278     case SQL_TYPE_DATE:
279         type = QVariant::Date;
280         break;
281     case SQL_TIME:
282     case SQL_TYPE_TIME:
283         type = QVariant::Time;
284         break;
285     case SQL_TIMESTAMP:
286     case SQL_TYPE_TIMESTAMP:
287         type = QVariant::DateTime;
288         break;
289     case SQL_WCHAR:
290     case SQL_WVARCHAR:
291     case SQL_WLONGVARCHAR:
292     case SQL_CHAR:
293     case SQL_VARCHAR:
294     case SQL_LONGVARCHAR:
295         type = QVariant::String;
296         break;
297     default:
298         type = QVariant::ByteArray;
299         break;
300     }
301     return type;
302 }
303 
304 static QSqlField qMakeFieldInfo(const QDB2ResultPrivate* d, int i)
305 {
306     SQLSMALLINT colNameLen;
307     SQLSMALLINT colType;
308     SQLUINTEGER colSize;
309     SQLSMALLINT colScale;
310     SQLSMALLINT nullable;
311     SQLRETURN r = SQL_ERROR;
312     SQLTCHAR colName[COLNAMESIZE];
313     r = SQLDescribeCol(d->hStmt,
314                         i+1,
315                         colName,
316                         (SQLSMALLINT) COLNAMESIZE,
317                         &colNameLen,
318                         &colType,
319                         &colSize,
320                         &colScale,
321                         &nullable);
322 
323     if (r != SQL_SUCCESS) {
324         qSqlWarning(QString::fromLatin1("qMakeFieldInfo: Unable to describe column %1").arg(i), d);
325         return QSqlField();
326     }
327     QSqlField f(qFromTChar(colName), qDecodeDB2Type(colType));
328     // nullable can be SQL_NO_NULLS, SQL_NULLABLE or SQL_NULLABLE_UNKNOWN
329     if (nullable == SQL_NO_NULLS)
330         f.setRequired(true);
331     else if (nullable == SQL_NULLABLE)
332         f.setRequired(false);
333     // else required is unknown
334     f.setLength(colSize == 0 ? -1 : int(colSize));
335     f.setPrecision(colScale == 0 ? -1 : int(colScale));
336     f.setSqlType(int(colType));
337     SQLTCHAR tableName[TABLENAMESIZE];
338     SQLSMALLINT tableNameLen;
339     r = SQLColAttribute(d->hStmt, i + 1, SQL_DESC_BASE_TABLE_NAME, tableName,
340                         TABLENAMESIZE, &tableNameLen, 0);
341     if (r == SQL_SUCCESS)
342         f.setTableName(qFromTChar(tableName));
343     return f;
344 }
345 
346 static int qGetIntData(SQLHANDLE hStmt, int column, bool& isNull)
347 {
348     SQLINTEGER intbuf;
349     isNull = false;
350     SQLINTEGER lengthIndicator = 0;
351     SQLRETURN r = SQLGetData(hStmt,
352                               column + 1,
353                               SQL_C_SLONG,
354                               (SQLPOINTER) &intbuf,
355                               0,
356                               &lengthIndicator);
357     if ((r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) || lengthIndicator == SQL_NULL_DATA) {
358         isNull = true;
359         return 0;
360     }
361     return int(intbuf);
362 }
363 
364 static double qGetDoubleData(SQLHANDLE hStmt, int column, bool& isNull)
365 {
366     SQLDOUBLE dblbuf;
367     isNull = false;
368     SQLINTEGER lengthIndicator = 0;
369     SQLRETURN r = SQLGetData(hStmt,
370                               column+1,
371                               SQL_C_DOUBLE,
372                               (SQLPOINTER) &dblbuf,
373                               0,
374                               &lengthIndicator);
375     if ((r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) || lengthIndicator == SQL_NULL_DATA) {
376         isNull = true;
377         return 0.0;
378     }
379 
380     return (double) dblbuf;
381 }
382 
383 static SQLBIGINT qGetBigIntData(SQLHANDLE hStmt, int column, bool& isNull)
384 {
385     SQLBIGINT lngbuf = Q_INT64_C(0);
386     isNull = false;
387     SQLINTEGER lengthIndicator = 0;
388     SQLRETURN r = SQLGetData(hStmt,
389                               column+1,
390                               SQL_C_SBIGINT,
391                               (SQLPOINTER) &lngbuf,
392                               0,
393                               &lengthIndicator);
394     if ((r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) || lengthIndicator == SQL_NULL_DATA)
395         isNull = true;
396 
397     return lngbuf;
398 }
399 
400 static QString qGetStringData(SQLHANDLE hStmt, int column, int colSize, bool& isNull)
401 {
402     QString     fieldVal;
403     SQLRETURN   r = SQL_ERROR;
404     SQLINTEGER  lengthIndicator = 0;
405 
406     if (colSize <= 0)
407         colSize = 255;
408     else if (colSize > 65536) // limit buffer size to 64 KB
409         colSize = 65536;
410     else
411         colSize++; // make sure there is room for more than the 0 termination
412     SQLTCHAR* buf = new SQLTCHAR[colSize];
413 
414     while (true) {
415         r = SQLGetData(hStmt,
416                         column + 1,
417                         SQL_C_WCHAR,
418                         (SQLPOINTER)buf,
419                         colSize * sizeof(SQLTCHAR),
420                         &lengthIndicator);
421         if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {
422             if (lengthIndicator == SQL_NULL_DATA || lengthIndicator == SQL_NO_TOTAL) {
423                 fieldVal.clear();
424                 isNull = true;
425                 break;
426             }
427             fieldVal += qFromTChar(buf);
428         } else if (r == SQL_NO_DATA) {
429             break;
430         } else {
431             qWarning("qGetStringData: Error while fetching data (%d)", r);
432             fieldVal.clear();
433             break;
434         }
435     }
436     delete[] buf;
437     return fieldVal;
438 }
439 
440 static QByteArray qGetBinaryData(SQLHANDLE hStmt, int column, SQLINTEGER& lengthIndicator, bool& isNull)
441 {
442     QByteArray fieldVal;
443     SQLSMALLINT colNameLen;
444     SQLSMALLINT colType;
445     SQLUINTEGER colSize;
446     SQLSMALLINT colScale;
447     SQLSMALLINT nullable;
448     SQLRETURN r = SQL_ERROR;
449 
450     SQLTCHAR colName[COLNAMESIZE];
451     r = SQLDescribeCol(hStmt,
452                         column+1,
453                         colName,
454                         COLNAMESIZE,
455                         &colNameLen,
456                         &colType,
457                         &colSize,
458                         &colScale,
459                         &nullable);
460     if (r != SQL_SUCCESS)
461         qWarning("qGetBinaryData: Unable to describe column %d", column);
462     // SQLDescribeCol may return 0 if size cannot be determined
463     if (!colSize)
464         colSize = 255;
465     else if (colSize > 65536) // read the field in 64 KB chunks
466         colSize = 65536;
467     char * buf = new char[colSize];
468     while (true) {
469         r = SQLGetData(hStmt,
470                         column+1,
471                         colType == SQL_DBCLOB ? SQL_C_CHAR : SQL_C_BINARY,
472                         (SQLPOINTER) buf,
473                         colSize,
474                         &lengthIndicator);
475         if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {
476             if (lengthIndicator == SQL_NULL_DATA) {
477                 isNull = true;
478                 break;
479             } else {
480                 int rSize;
481                 r == SQL_SUCCESS ? rSize = lengthIndicator : rSize = colSize;
482                 if (lengthIndicator == SQL_NO_TOTAL) // size cannot be determined
483                     rSize = colSize;
484                 fieldVal.append(QByteArray(buf, rSize));
485                 if (r == SQL_SUCCESS) // the whole field was read in one chunk
486                     break;
487             }
488         } else {
489             break;
490         }
491     }
492     delete [] buf;
493     return fieldVal;
494 }
495 
496 static void qSplitTableQualifier(const QString & qualifier, QString * catalog,
497                                   QString * schema, QString * table)
498 {
499     if (!catalog || !schema || !table)
500         return;
501     QStringList l = qualifier.split(QLatin1Char('.'));
502     if (l.count() > 3)
503         return; // can't possibly be a valid table qualifier
504     int i = 0, n = l.count();
505     if (n == 1) {
506         *table = qualifier;
507     } else {
508         for (QStringList::Iterator it = l.begin(); it != l.end(); ++it) {
509             if (n == 3) {
510                 if (i == 0)
511                     *catalog = *it;
512                 else if (i == 1)
513                     *schema = *it;
514                 else if (i == 2)
515                     *table = *it;
516             } else if (n == 2) {
517                 if (i == 0)
518                     *schema = *it;
519                 else if (i == 1)
520                     *table = *it;
521             }
522             i++;
523         }
524     }
525 }
526 
527 // creates a QSqlField from a valid hStmt generated
528 // by SQLColumns. The hStmt has to point to a valid position.
529 static QSqlField qMakeFieldInfo(const SQLHANDLE hStmt)
530 {
531     bool isNull;
532     int type = qGetIntData(hStmt, 4, isNull);
533     QSqlField f(qGetStringData(hStmt, 3, -1, isNull), qDecodeDB2Type(type));
534     int required = qGetIntData(hStmt, 10, isNull); // nullable-flag
535     // required can be SQL_NO_NULLS, SQL_NULLABLE or SQL_NULLABLE_UNKNOWN
536     if (required == SQL_NO_NULLS)
537         f.setRequired(true);
538     else if (required == SQL_NULLABLE)
539         f.setRequired(false);
540     // else we don't know.
541     f.setLength(qGetIntData(hStmt, 6, isNull)); // column size
542     f.setPrecision(qGetIntData(hStmt, 8, isNull)); // precision
543     f.setSqlType(type);
544     return f;
545 }
546 
547 static bool qMakeStatement(QDB2ResultPrivate* d, bool forwardOnly, bool setForwardOnly = true)
548 {
549     SQLRETURN r;
550     if (!d->hStmt) {
551         r = SQLAllocHandle(SQL_HANDLE_STMT,
552                             d->drv_d_func()->hDbc,
553                             &d->hStmt);
554         if (r != SQL_SUCCESS) {
555             qSqlWarning(QLatin1String("QDB2Result::reset: Unable to allocate statement handle"), d);
556             return false;
557         }
558     } else {
559         r = SQLFreeStmt(d->hStmt, SQL_CLOSE);
560         if (r != SQL_SUCCESS) {
561             qSqlWarning(QLatin1String("QDB2Result::reset: Unable to close statement handle"), d);
562             return false;
563         }
564     }
565 
566     if (!setForwardOnly)
567         return true;
568 
569     if (forwardOnly) {
570         r = SQLSetStmtAttr(d->hStmt,
571                             SQL_ATTR_CURSOR_TYPE,
572                             (SQLPOINTER) SQL_CURSOR_FORWARD_ONLY,
573                             SQL_IS_UINTEGER);
574     } else {
575         r = SQLSetStmtAttr(d->hStmt,
576                             SQL_ATTR_CURSOR_TYPE,
577                             (SQLPOINTER) SQL_CURSOR_STATIC,
578                             SQL_IS_UINTEGER);
579     }
580     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
581         qSqlWarning(QString::fromLatin1("QDB2Result::reset: Unable to set %1 attribute.").arg(
582                      forwardOnly ? QLatin1String("SQL_CURSOR_FORWARD_ONLY")
583                                  : QLatin1String("SQL_CURSOR_STATIC")), d);
584         return false;
585     }
586     return true;
587 }
588 
589 QVariant QDB2Result::handle() const
590 {
591     Q_D(const QDB2Result);
592     return QVariant(qRegisterMetaType<SQLHANDLE>("SQLHANDLE"), &d->hStmt);
593 }
594 
595 /************************************/
596 
597 QDB2Result::QDB2Result(const QDB2Driver *drv)
598     : QSqlResult(*new QDB2ResultPrivate(this, drv))
599 {
600 }
601 
602 QDB2Result::~QDB2Result()
603 {
604     Q_D(const QDB2Result);
605     if (d->hStmt) {
606         SQLRETURN r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);
607         if (r != SQL_SUCCESS)
608             qSqlWarning(QLatin1String("QDB2Driver: Unable to free statement handle ")
609                         + QString::number(r), d);
610     }
611 }
612 
613 bool QDB2Result::reset (const QString& query)
614 {
615     Q_D(QDB2Result);
616     setActive(false);
617     setAt(QSql::BeforeFirstRow);
618     SQLRETURN r;
619 
620     d->recInf.clear();
621     d->emptyValueCache();
622 
623     if (!qMakeStatement(d, isForwardOnly()))
624         return false;
625 
626     r = SQLExecDirect(d->hStmt,
627                        qToTChar(query),
628                        (SQLINTEGER) query.length());
629     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
630         setLastError(qMakeError(QCoreApplication::translate("QDB2Result",
631                                 "Unable to execute statement"), QSqlError::StatementError, d));
632         return false;
633     }
634     SQLSMALLINT count = 0;
635     r = SQLNumResultCols(d->hStmt, &count);
636     if (count) {
637         setSelect(true);
638         for (int i = 0; i < count; ++i) {
639             d->recInf.append(qMakeFieldInfo(d, i));
640         }
641     } else {
642         setSelect(false);
643     }
644     d->valueCache.resize(count);
645     d->valueCache.fill(NULL);
646     setActive(true);
647     return true;
648 }
649 
650 bool QDB2Result::prepare(const QString& query)
651 {
652     Q_D(QDB2Result);
653     setActive(false);
654     setAt(QSql::BeforeFirstRow);
655     SQLRETURN r;
656 
657     d->recInf.clear();
658     d->emptyValueCache();
659 
660     if (!qMakeStatement(d, isForwardOnly()))
661         return false;
662 
663     r = SQLPrepare(d->hStmt,
664                     qToTChar(query),
665                     (SQLINTEGER) query.length());
666 
667     if (r != SQL_SUCCESS) {
668         setLastError(qMakeError(QCoreApplication::translate("QDB2Result",
669                      "Unable to prepare statement"), QSqlError::StatementError, d));
670         return false;
671     }
672     return true;
673 }
674 
675 bool QDB2Result::exec()
676 {
677     Q_D(QDB2Result);
678     QList<QByteArray> tmpStorage; // holds temporary ptrs
679     QVarLengthArray<SQLINTEGER, 32> indicators(boundValues().count());
680 
681     memset(indicators.data(), 0, indicators.size() * sizeof(SQLINTEGER));
682     setActive(false);
683     setAt(QSql::BeforeFirstRow);
684     SQLRETURN r;
685 
686     d->recInf.clear();
687     d->emptyValueCache();
688 
689     if (!qMakeStatement(d, isForwardOnly(), false))
690         return false;
691 
692 
693     QVector<QVariant> &values = boundValues();
694     int i;
695     for (i = 0; i < values.count(); ++i) {
696         // bind parameters - only positional binding allowed
697         SQLINTEGER *ind = &indicators[i];
698         if (values.at(i).isNull())
699             *ind = SQL_NULL_DATA;
700         if (bindValueType(i) & QSql::Out)
701             values[i].detach();
702 
703         switch (values.at(i).type()) {
704             case QVariant::Date: {
705                 QByteArray ba;
706                 ba.resize(sizeof(DATE_STRUCT));
707                 DATE_STRUCT *dt = (DATE_STRUCT *)ba.constData();
708                 QDate qdt = values.at(i).toDate();
709                 dt->year = qdt.year();
710                 dt->month = qdt.month();
711                 dt->day = qdt.day();
712                 r = SQLBindParameter(d->hStmt,
713                                      i + 1,
714                                      qParamType[bindValueType(i) & 3],
715                                      SQL_C_DATE,
716                                      SQL_DATE,
717                                      0,
718                                      0,
719                                      (void *) dt,
720                                      0,
721                                      *ind == SQL_NULL_DATA ? ind : NULL);
722                 tmpStorage.append(ba);
723                 break; }
724             case QVariant::Time: {
725                 QByteArray ba;
726                 ba.resize(sizeof(TIME_STRUCT));
727                 TIME_STRUCT *dt = (TIME_STRUCT *)ba.constData();
728                 QTime qdt = values.at(i).toTime();
729                 dt->hour = qdt.hour();
730                 dt->minute = qdt.minute();
731                 dt->second = qdt.second();
732                 r = SQLBindParameter(d->hStmt,
733                                       i + 1,
734                                       qParamType[bindValueType(i) & 3],
735                                       SQL_C_TIME,
736                                       SQL_TIME,
737                                       0,
738                                       0,
739                                       (void *) dt,
740                                       0,
741                                       *ind == SQL_NULL_DATA ? ind : NULL);
742                 tmpStorage.append(ba);
743                 break; }
744             case QVariant::DateTime: {
745                 QByteArray ba;
746                 ba.resize(sizeof(TIMESTAMP_STRUCT));
747                 TIMESTAMP_STRUCT * dt = (TIMESTAMP_STRUCT *)ba.constData();
748                 QDateTime qdt = values.at(i).toDateTime();
749                 dt->year = qdt.date().year();
750                 dt->month = qdt.date().month();
751                 dt->day = qdt.date().day();
752                 dt->hour = qdt.time().hour();
753                 dt->minute = qdt.time().minute();
754                 dt->second = qdt.time().second();
755                 dt->fraction = qdt.time().msec() * 1000000;
756                 r = SQLBindParameter(d->hStmt,
757                                       i + 1,
758                                       qParamType[bindValueType(i) & 3],
759                                       SQL_C_TIMESTAMP,
760                                       SQL_TIMESTAMP,
761                                       0,
762                                       0,
763                                       (void *) dt,
764                                       0,
765                                       *ind == SQL_NULL_DATA ? ind : NULL);
766                 tmpStorage.append(ba);
767                 break; }
768             case QVariant::Int:
769                 r = SQLBindParameter(d->hStmt,
770                                       i + 1,
771                                       qParamType[bindValueType(i) & 3],
772                                       SQL_C_SLONG,
773                                       SQL_INTEGER,
774                                       0,
775                                       0,
776                                       (void *)values.at(i).constData(),
777                                       0,
778                                       *ind == SQL_NULL_DATA ? ind : NULL);
779                 break;
780             case QVariant::Double:
781                 r = SQLBindParameter(d->hStmt,
782                                       i + 1,
783                                       qParamType[bindValueType(i) & 3],
784                                       SQL_C_DOUBLE,
785                                       SQL_DOUBLE,
786                                       0,
787                                       0,
788                                       (void *)values.at(i).constData(),
789                                       0,
790                                       *ind == SQL_NULL_DATA ? ind : NULL);
791                 break;
792             case QVariant::ByteArray: {
793                 int len = values.at(i).toByteArray().size();
794                 if (*ind != SQL_NULL_DATA)
795                     *ind = len;
796                 r = SQLBindParameter(d->hStmt,
797                                       i + 1,
798                                       qParamType[bindValueType(i) & 3],
799                                       SQL_C_BINARY,
800                                       SQL_LONGVARBINARY,
801                                       len,
802                                       0,
803                                       (void *)values.at(i).toByteArray().constData(),
804                                       len,
805                                       ind);
806                 break; }
807             case QVariant::String:
808             {
809                 QString str(values.at(i).toString());
810                 if (*ind != SQL_NULL_DATA)
811                     *ind = str.length() * sizeof(QChar);
812                 if (bindValueType(i) & QSql::Out) {
813                     QByteArray ba((char*)str.utf16(), str.capacity() * sizeof(QChar));
814                     r = SQLBindParameter(d->hStmt,
815                                         i + 1,
816                                         qParamType[bindValueType(i) & 3],
817                                         SQL_C_WCHAR,
818                                         SQL_WVARCHAR,
819                                         str.length(),
820                                         0,
821                                         (void *)ba.constData(),
822                                         ba.size(),
823                                         ind);
824                     tmpStorage.append(ba);
825                 } else {
826                     void *data = (void*)str.utf16();
827                     int len = str.length();
828                     r = SQLBindParameter(d->hStmt,
829                                         i + 1,
830                                         qParamType[bindValueType(i) & 3],
831                                         SQL_C_WCHAR,
832                                         SQL_WVARCHAR,
833                                         len,
834                                         0,
835                                         data,
836                                         len * sizeof(QChar),
837                                         ind);
838                 }
839                 break;
840             }
841             default: {
842                 QByteArray ba = values.at(i).toString().toLatin1();
843                 int len = ba.length() + 1;
844                 if (*ind != SQL_NULL_DATA)
845                     *ind = ba.length();
846                 r = SQLBindParameter(d->hStmt,
847                                       i + 1,
848                                       qParamType[bindValueType(i) & 3],
849                                       SQL_C_CHAR,
850                                       SQL_VARCHAR,
851                                       len,
852                                       0,
853                                       (void *) ba.constData(),
854                                       len,
855                                       ind);
856                 tmpStorage.append(ba);
857                 break; }
858         }
859         if (r != SQL_SUCCESS) {
860             qWarning("QDB2Result::exec: unable to bind variable: %s",
861                      qDB2Warn(d).toLocal8Bit().constData());
862             setLastError(qMakeError(QCoreApplication::translate("QDB2Result",
863                                     "Unable to bind variable"), QSqlError::StatementError, d));
864             return false;
865         }
866     }
867 
868     r = SQLExecute(d->hStmt);
869     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
870         qWarning("QDB2Result::exec: Unable to execute statement: %s",
871                  qDB2Warn(d).toLocal8Bit().constData());
872         setLastError(qMakeError(QCoreApplication::translate("QDB2Result",
873                                 "Unable to execute statement"), QSqlError::StatementError, d));
874         return false;
875     }
876     SQLSMALLINT count = 0;
877     r = SQLNumResultCols(d->hStmt, &count);
878     if (count) {
879         setSelect(true);
880         for (int i = 0; i < count; ++i) {
881             d->recInf.append(qMakeFieldInfo(d, i));
882         }
883     } else {
884         setSelect(false);
885     }
886     setActive(true);
887     d->valueCache.resize(count);
888     d->valueCache.fill(NULL);
889 
890     //get out parameters
891     if (!hasOutValues())
892         return true;
893 
894     for (i = 0; i < values.count(); ++i) {
895         switch (values[i].type()) {
896             case QVariant::Date: {
897                 DATE_STRUCT ds = *((DATE_STRUCT *)tmpStorage.takeFirst().constData());
898                 values[i] = QVariant(QDate(ds.year, ds.month, ds.day));
899                 break; }
900             case QVariant::Time: {
901                 TIME_STRUCT dt = *((TIME_STRUCT *)tmpStorage.takeFirst().constData());
902                 values[i] = QVariant(QTime(dt.hour, dt.minute, dt.second));
903                 break; }
904             case QVariant::DateTime: {
905                 TIMESTAMP_STRUCT dt = *((TIMESTAMP_STRUCT *)tmpStorage.takeFirst().constData());
906                 values[i] = QVariant(QDateTime(QDate(dt.year, dt.month, dt.day),
907                               QTime(dt.hour, dt.minute, dt.second, dt.fraction / 1000000)));
908                 break; }
909             case QVariant::Int:
910             case QVariant::Double:
911             case QVariant::ByteArray:
912                 break;
913             case QVariant::String:
914                 if (bindValueType(i) & QSql::Out)
915                     values[i] = QString((const QChar *)tmpStorage.takeFirst().constData());
916                 break;
917             default: {
918                 values[i] = QString::fromLatin1(tmpStorage.takeFirst().constData());
919                 break; }
920         }
921         if (indicators[i] == SQL_NULL_DATA)
922             values[i] = QVariant(values[i].type());
923     }
924     return true;
925 }
926 
927 bool QDB2Result::fetch(int i)
928 {
929     Q_D(QDB2Result);
930     if (isForwardOnly() && i < at())
931         return false;
932     if (i == at())
933         return true;
934     d->clearValueCache();
935     int actualIdx = i + 1;
936     if (actualIdx <= 0) {
937         setAt(QSql::BeforeFirstRow);
938         return false;
939     }
940     SQLRETURN r;
941     if (isForwardOnly()) {
942         bool ok = true;
943         while (ok && i > at())
944             ok = fetchNext();
945         return ok;
946     } else {
947         r = SQLFetchScroll(d->hStmt,
948                             SQL_FETCH_ABSOLUTE,
949                             actualIdx);
950     }
951     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {
952         setLastError(qMakeError(QCoreApplication::translate("QDB2Result",
953                                 "Unable to fetch record %1").arg(i), QSqlError::StatementError, d));
954         return false;
955     }
956     else if (r == SQL_NO_DATA)
957         return false;
958     setAt(i);
959     return true;
960 }
961 
962 bool QDB2Result::fetchNext()
963 {
964     Q_D(QDB2Result);
965     SQLRETURN r;
966     d->clearValueCache();
967     r = SQLFetchScroll(d->hStmt,
968                        SQL_FETCH_NEXT,
969                        0);
970     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
971         if (r != SQL_NO_DATA)
972             setLastError(qMakeError(QCoreApplication::translate("QDB2Result",
973                                     "Unable to fetch next"), QSqlError::StatementError, d));
974         return false;
975     }
976     setAt(at() + 1);
977     return true;
978 }
979 
980 bool QDB2Result::fetchFirst()
981 {
982     Q_D(QDB2Result);
983     if (isForwardOnly() && at() != QSql::BeforeFirstRow)
984         return false;
985     if (isForwardOnly())
986         return fetchNext();
987     d->clearValueCache();
988     SQLRETURN r;
989     r = SQLFetchScroll(d->hStmt,
990                        SQL_FETCH_FIRST,
991                        0);
992     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
993         if(r!= SQL_NO_DATA)
994             setLastError(qMakeError(QCoreApplication::translate("QDB2Result", "Unable to fetch first"),
995                                     QSqlError::StatementError, d));
996         return false;
997     }
998     setAt(0);
999     return true;
1000 }
1001 
1002 bool QDB2Result::fetchLast()
1003 {
1004     Q_D(QDB2Result);
1005     d->clearValueCache();
1006 
1007     int i = at();
1008     if (i == QSql::AfterLastRow) {
1009         if (isForwardOnly()) {
1010             return false;
1011         } else {
1012             if (!fetch(0))
1013                 return false;
1014             i = at();
1015         }
1016     }
1017 
1018     while (fetchNext())
1019         ++i;
1020 
1021     if (i == QSql::BeforeFirstRow) {
1022         setAt(QSql::AfterLastRow);
1023         return false;
1024     }
1025 
1026     if (!isForwardOnly())
1027         return fetch(i);
1028 
1029     setAt(i);
1030     return true;
1031 }
1032 
1033 
1034 QVariant QDB2Result::data(int field)
1035 {
1036     Q_D(QDB2Result);
1037     if (field >= d->recInf.count()) {
1038         qWarning("QDB2Result::data: column %d out of range", field);
1039         return QVariant();
1040     }
1041     SQLRETURN r = 0;
1042     SQLINTEGER lengthIndicator = 0;
1043     bool isNull = false;
1044     const QSqlField info = d->recInf.field(field);
1045 
1046     if (!info.isValid() || field >= d->valueCache.size())
1047         return QVariant();
1048 
1049     if (d->valueCache[field])
1050         return *d->valueCache[field];
1051 
1052 
1053     QVariant* v = 0;
1054     switch (info.type()) {
1055         case QVariant::LongLong:
1056             v = new QVariant((qint64) qGetBigIntData(d->hStmt, field, isNull));
1057             break;
1058         case QVariant::Int:
1059             v = new QVariant(qGetIntData(d->hStmt, field, isNull));
1060             break;
1061         case QVariant::Date: {
1062             DATE_STRUCT dbuf;
1063             r = SQLGetData(d->hStmt,
1064                             field + 1,
1065                             SQL_C_DATE,
1066                             (SQLPOINTER) &dbuf,
1067                             0,
1068                             &lengthIndicator);
1069             if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA)) {
1070                 v = new QVariant(QDate(dbuf.year, dbuf.month, dbuf.day));
1071             } else {
1072                 v = new QVariant(QDate());
1073                 isNull = true;
1074             }
1075             break; }
1076         case QVariant::Time: {
1077             TIME_STRUCT tbuf;
1078             r = SQLGetData(d->hStmt,
1079                             field + 1,
1080                             SQL_C_TIME,
1081                             (SQLPOINTER) &tbuf,
1082                             0,
1083                             &lengthIndicator);
1084             if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA)) {
1085                 v = new QVariant(QTime(tbuf.hour, tbuf.minute, tbuf.second));
1086             } else {
1087                 v = new QVariant(QTime());
1088                 isNull = true;
1089             }
1090             break; }
1091         case QVariant::DateTime: {
1092             TIMESTAMP_STRUCT dtbuf;
1093             r = SQLGetData(d->hStmt,
1094                             field + 1,
1095                             SQL_C_TIMESTAMP,
1096                             (SQLPOINTER) &dtbuf,
1097                             0,
1098                             &lengthIndicator);
1099             if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA)) {
1100                 v = new QVariant(QDateTime(QDate(dtbuf.year, dtbuf.month, dtbuf.day),
1101                                              QTime(dtbuf.hour, dtbuf.minute, dtbuf.second, dtbuf.fraction / 1000000)));
1102             } else {
1103                 v = new QVariant(QDateTime());
1104                 isNull = true;
1105             }
1106             break; }
1107         case QVariant::ByteArray:
1108             v = new QVariant(qGetBinaryData(d->hStmt, field, lengthIndicator, isNull));
1109             break;
1110         case QVariant::Double:
1111             {
1112             switch(numericalPrecisionPolicy()) {
1113                 case QSql::LowPrecisionInt32:
1114                     v = new QVariant(qGetIntData(d->hStmt, field, isNull));
1115                     break;
1116                 case QSql::LowPrecisionInt64:
1117                     v = new QVariant((qint64) qGetBigIntData(d->hStmt, field, isNull));
1118                     break;
1119                 case QSql::LowPrecisionDouble:
1120                     v = new QVariant(qGetDoubleData(d->hStmt, field, isNull));
1121                     break;
1122                 case QSql::HighPrecision:
1123                 default:
1124                     // length + 1 for the comma
1125                     v = new QVariant(qGetStringData(d->hStmt, field, info.length() + 1, isNull));
1126                     break;
1127             }
1128             break;
1129             }
1130         case QVariant::String:
1131         default:
1132             v = new QVariant(qGetStringData(d->hStmt, field, info.length(), isNull));
1133             break;
1134     }
1135     if (isNull)
1136         *v = QVariant(info.type());
1137     d->valueCache[field] = v;
1138     return *v;
1139 }
1140 
1141 bool QDB2Result::isNull(int i)
1142 {
1143     Q_D(const QDB2Result);
1144     if (i >= d->valueCache.size())
1145         return true;
1146 
1147     if (d->valueCache[i])
1148         return d->valueCache[i]->isNull();
1149     return data(i).isNull();
1150 }
1151 
1152 int QDB2Result::numRowsAffected()
1153 {
1154     Q_D(const QDB2Result);
1155     SQLINTEGER affectedRowCount = 0;
1156     SQLRETURN r = SQLRowCount(d->hStmt, &affectedRowCount);
1157     if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)
1158         return affectedRowCount;
1159     else
1160         qSqlWarning(QLatin1String("QDB2Result::numRowsAffected: Unable to count affected rows"), d);
1161     return -1;
1162 }
1163 
1164 int QDB2Result::size()
1165 {
1166     return -1;
1167 }
1168 
1169 QSqlRecord QDB2Result::record() const
1170 {
1171     Q_D(const QDB2Result);
1172     if (isActive())
1173         return d->recInf;
1174     return QSqlRecord();
1175 }
1176 
1177 bool QDB2Result::nextResult()
1178 {
1179     Q_D(QDB2Result);
1180     setActive(false);
1181     setAt(QSql::BeforeFirstRow);
1182     d->recInf.clear();
1183     d->emptyValueCache();
1184     setSelect(false);
1185 
1186     SQLRETURN r = SQLMoreResults(d->hStmt);
1187     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
1188         if (r != SQL_NO_DATA) {
1189             setLastError(qMakeError(QCoreApplication::translate("QODBCResult",
1190                 "Unable to fetch last"), QSqlError::ConnectionError, d));
1191         }
1192         return false;
1193     }
1194 
1195     SQLSMALLINT fieldCount = 0;
1196     r = SQLNumResultCols(d->hStmt, &fieldCount);
1197     setSelect(fieldCount > 0);
1198     for (int i = 0; i < fieldCount; ++i)
1199         d->recInf.append(qMakeFieldInfo(d, i));
1200 
1201     d->valueCache.resize(fieldCount);
1202     d->valueCache.fill(NULL);
1203     setActive(true);
1204 
1205     return true;
1206 }
1207 
1208 void QDB2Result::virtual_hook(int id, void *data)
1209 {
1210     QSqlResult::virtual_hook(id, data);
1211 }
1212 
1213 void QDB2Result::detachFromResultSet()
1214 {
1215     Q_D(QDB2Result);
1216     if (d->hStmt)
1217         SQLCloseCursor(d->hStmt);
1218 }
1219 
1220 /************************************/
1221 
1222 QDB2Driver::QDB2Driver(QObject* parent)
1223     : QSqlDriver(*new QDB2DriverPrivate, parent)
1224 {
1225 }
1226 
1227 QDB2Driver::QDB2Driver(Qt::HANDLE env, Qt::HANDLE con, QObject* parent)
1228     : QSqlDriver(*new QDB2DriverPrivate, parent)
1229 {
1230     Q_D(QDB2Driver);
1231     d->hEnv = reinterpret_cast<SQLHANDLE>(env);
1232     d->hDbc = reinterpret_cast<SQLHANDLE>(con);
1233     if (env && con) {
1234         setOpen(true);
1235         setOpenError(false);
1236     }
1237 }
1238 
1239 QDB2Driver::~QDB2Driver()
1240 {
1241     close();
1242 }
1243 
1244 bool QDB2Driver::open(const QString& db, const QString& user, const QString& password, const QString& host, int port,
1245                        const QString& connOpts)
1246 {
1247     Q_D(QDB2Driver);
1248     if (isOpen())
1249       close();
1250     SQLRETURN r;
1251     r = SQLAllocHandle(SQL_HANDLE_ENV,
1252                         SQL_NULL_HANDLE,
1253                         &d->hEnv);
1254     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
1255         qSqlWarning(QLatin1String("QDB2Driver::open: Unable to allocate environment"), d);
1256         setOpenError(true);
1257         return false;
1258     }
1259 
1260     r = SQLAllocHandle(SQL_HANDLE_DBC,
1261                         d->hEnv,
1262                         &d->hDbc);
1263     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
1264         qSqlWarning(QLatin1String("QDB2Driver::open: Unable to allocate connection"), d);
1265         setOpenError(true);
1266         return false;
1267     }
1268 
1269     QString protocol;
1270     // Set connection attributes
1271     const QStringList opts(connOpts.split(QLatin1Char(';'), QString::SkipEmptyParts));
1272     for (int i = 0; i < opts.count(); ++i) {
1273         const QString tmp(opts.at(i));
1274         int idx;
1275         if ((idx = tmp.indexOf(QLatin1Char('='))) == -1) {
1276             qWarning("QDB2Driver::open: Illegal connect option value '%s'",
1277                      tmp.toLocal8Bit().constData());
1278             continue;
1279         }
1280 
1281         const QString opt(tmp.left(idx));
1282         const QString val(tmp.mid(idx + 1).simplified());
1283 
1284         SQLUINTEGER v = 0;
1285         r = SQL_SUCCESS;
1286         if (opt == QLatin1String("SQL_ATTR_ACCESS_MODE")) {
1287             if (val == QLatin1String("SQL_MODE_READ_ONLY")) {
1288                 v = SQL_MODE_READ_ONLY;
1289             } else if (val == QLatin1String("SQL_MODE_READ_WRITE")) {
1290                 v = SQL_MODE_READ_WRITE;
1291             } else {
1292                 qWarning("QDB2Driver::open: Unknown option value '%s'",
1293                          tmp.toLocal8Bit().constData());
1294                 continue;
1295             }
1296             r = SQLSetConnectAttr(d->hDbc, SQL_ATTR_ACCESS_MODE, reinterpret_cast<SQLPOINTER>(v), 0);
1297         } else if (opt == QLatin1String("SQL_ATTR_LOGIN_TIMEOUT")) {
1298             v = val.toUInt();
1299             r = SQLSetConnectAttr(d->hDbc, SQL_ATTR_LOGIN_TIMEOUT, reinterpret_cast<SQLPOINTER>(v), 0);
1300         } else if (opt.compare(QLatin1String("PROTOCOL"), Qt::CaseInsensitive) == 0) {
1301                         protocol = tmp;
1302         }
1303         else {
1304             qWarning("QDB2Driver::open: Unknown connection attribute '%s'",
1305                       tmp.toLocal8Bit().constData());
1306         }
1307         if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)
1308             qSqlWarning(QString::fromLatin1("QDB2Driver::open: "
1309                            "Unable to set connection attribute '%1'").arg(opt), d);
1310     }
1311 
1312     if (protocol.isEmpty())
1313         protocol = QLatin1String("PROTOCOL=TCPIP");
1314 
1315     if (port < 0 )
1316         port = 50000;
1317 
1318     QString connQStr;
1319     connQStr =  protocol + QLatin1String(";DATABASE=") + db + QLatin1String(";HOSTNAME=") + host
1320         + QLatin1String(";PORT=") + QString::number(port) + QLatin1String(";UID=") + user
1321         + QLatin1String(";PWD=") + password;
1322 
1323 
1324     SQLTCHAR connOut[SQL_MAX_OPTION_STRING_LENGTH];
1325     SQLSMALLINT cb;
1326 
1327     r = SQLDriverConnect(d->hDbc,
1328                           NULL,
1329                           qToTChar(connQStr),
1330                           (SQLSMALLINT) connQStr.length(),
1331                           connOut,
1332                           SQL_MAX_OPTION_STRING_LENGTH,
1333                           &cb,
1334                           SQL_DRIVER_NOPROMPT);
1335     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
1336         setLastError(qMakeError(tr("Unable to connect"),
1337                                 QSqlError::ConnectionError, d));
1338         setOpenError(true);
1339         return false;
1340     }
1341 
1342     d->user = user;
1343     setOpen(true);
1344     setOpenError(false);
1345     return true;
1346 }
1347 
1348 void QDB2Driver::close()
1349 {
1350     Q_D(QDB2Driver);
1351     SQLRETURN r;
1352     if (d->hDbc) {
1353         // Open statements/descriptors handles are automatically cleaned up by SQLDisconnect
1354         if (isOpen()) {
1355             r = SQLDisconnect(d->hDbc);
1356             if (r != SQL_SUCCESS)
1357                 qSqlWarning(QLatin1String("QDB2Driver::close: Unable to disconnect datasource"), d);
1358         }
1359         r = SQLFreeHandle(SQL_HANDLE_DBC, d->hDbc);
1360         if (r != SQL_SUCCESS)
1361             qSqlWarning(QLatin1String("QDB2Driver::close: Unable to free connection handle"), d);
1362         d->hDbc = 0;
1363     }
1364 
1365     if (d->hEnv) {
1366         r = SQLFreeHandle(SQL_HANDLE_ENV, d->hEnv);
1367         if (r != SQL_SUCCESS)
1368             qSqlWarning(QLatin1String("QDB2Driver::close: Unable to free environment handle"), d);
1369         d->hEnv = 0;
1370     }
1371     setOpen(false);
1372     setOpenError(false);
1373 }
1374 
1375 QSqlResult *QDB2Driver::createResult() const
1376 {
1377     return new QDB2Result(this);
1378 }
1379 
1380 QSqlRecord QDB2Driver::record(const QString& tableName) const
1381 {
1382     Q_D(const QDB2Driver);
1383     QSqlRecord fil;
1384     if (!isOpen())
1385         return fil;
1386 
1387     SQLHANDLE hStmt;
1388     QString catalog, schema, table;
1389     qSplitTableQualifier(tableName, &catalog, &schema, &table);
1390     if (schema.isEmpty())
1391         schema = d->user;
1392 
1393     if (isIdentifierEscaped(catalog, QSqlDriver::TableName))
1394         catalog = stripDelimiters(catalog, QSqlDriver::TableName);
1395     else
1396         catalog = catalog.toUpper();
1397 
1398     if (isIdentifierEscaped(schema, QSqlDriver::TableName))
1399         schema = stripDelimiters(schema, QSqlDriver::TableName);
1400     else
1401         schema = schema.toUpper();
1402 
1403     if (isIdentifierEscaped(table, QSqlDriver::TableName))
1404         table = stripDelimiters(table, QSqlDriver::TableName);
1405     else
1406         table = table.toUpper();
1407 
1408     SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,
1409                                   d->hDbc,
1410                                   &hStmt);
1411     if (r != SQL_SUCCESS) {
1412         qSqlWarning(QLatin1String("QDB2Driver::record: Unable to allocate handle"), d);
1413         return fil;
1414     }
1415 
1416     r = SQLSetStmtAttr(hStmt,
1417                         SQL_ATTR_CURSOR_TYPE,
1418                         (SQLPOINTER) SQL_CURSOR_FORWARD_ONLY,
1419                         SQL_IS_UINTEGER);
1420 
1421 
1422     //Aside: szSchemaName and szTableName parameters of SQLColumns
1423     //are case sensitive search patterns, so no escaping is used.
1424     r =  SQLColumns(hStmt,
1425                      NULL,
1426                      0,
1427                      qToTChar(schema),
1428                      schema.length(),
1429                      qToTChar(table),
1430                      table.length(),
1431                      NULL,
1432                      0);
1433 
1434     if (r != SQL_SUCCESS)
1435         qSqlWarning(QLatin1String("QDB2Driver::record: Unable to execute column list"), d);
1436     r = SQLFetchScroll(hStmt,
1437                         SQL_FETCH_NEXT,
1438                         0);
1439     while (r == SQL_SUCCESS) {
1440         QSqlField fld = qMakeFieldInfo(hStmt);
1441         fld.setTableName(tableName);
1442         fil.append(fld);
1443         r = SQLFetchScroll(hStmt,
1444                             SQL_FETCH_NEXT,
1445                             0);
1446     }
1447 
1448     r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
1449     if (r != SQL_SUCCESS)
1450         qSqlWarning(QLatin1String("QDB2Driver: Unable to free statement handle ")
1451                     + QString::number(r), d);
1452 
1453     return fil;
1454 }
1455 
1456 QStringList QDB2Driver::tables(QSql::TableType type) const
1457 {
1458     Q_D(const QDB2Driver);
1459     QStringList tl;
1460     if (!isOpen())
1461         return tl;
1462 
1463     SQLHANDLE hStmt;
1464 
1465     SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,
1466                                   d->hDbc,
1467                                   &hStmt);
1468     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {
1469         qSqlWarning(QLatin1String("QDB2Driver::tables: Unable to allocate handle"), d);
1470         return tl;
1471     }
1472     r = SQLSetStmtAttr(hStmt,
1473                         SQL_ATTR_CURSOR_TYPE,
1474                         (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,
1475                         SQL_IS_UINTEGER);
1476 
1477     QString tableType;
1478     if (type & QSql::Tables)
1479         tableType += QLatin1String("TABLE,");
1480     if (type & QSql::Views)
1481         tableType += QLatin1String("VIEW,");
1482     if (type & QSql::SystemTables)
1483         tableType += QLatin1String("SYSTEM TABLE,");
1484     if (tableType.isEmpty())
1485         return tl;
1486     tableType.chop(1);
1487 
1488     r = SQLTables(hStmt,
1489                    NULL,
1490                    0,
1491                    NULL,
1492                    0,
1493                    NULL,
1494                    0,
1495                    qToTChar(tableType),
1496                    tableType.length());
1497 
1498     if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)
1499         qSqlWarning(QLatin1String("QDB2Driver::tables: Unable to execute table list"), d);
1500     r = SQLFetchScroll(hStmt,
1501                         SQL_FETCH_NEXT,
1502                         0);
1503     while (r == SQL_SUCCESS) {
1504         bool isNull;
1505         QString fieldVal = qGetStringData(hStmt, 2, -1, isNull);
1506         QString userVal = qGetStringData(hStmt, 1, -1, isNull);
1507         QString user = d->user;
1508         if ( isIdentifierEscaped(user, QSqlDriver::TableName))
1509             user = stripDelimiters(user, QSqlDriver::TableName);
1510         else
1511             user = user.toUpper();
1512 
1513         if (userVal != user)
1514             fieldVal = userVal + QLatin1Char('.') + fieldVal;
1515         tl.append(fieldVal);
1516         r = SQLFetchScroll(hStmt,
1517                             SQL_FETCH_NEXT,
1518                             0);
1519     }
1520 
1521     r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
1522     if (r != SQL_SUCCESS)
1523         qSqlWarning(QLatin1String("QDB2Driver::tables: Unable to free statement handle ")
1524                     + QString::number(r), d);
1525     return tl;
1526 }
1527 
1528 QSqlIndex QDB2Driver::primaryIndex(const QString& tablename) const
1529 {
1530     Q_D(const QDB2Driver);
1531     QSqlIndex index(tablename);
1532     if (!isOpen())
1533         return index;
1534     QSqlRecord rec = record(tablename);
1535 
1536     SQLHANDLE hStmt;
1537     SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,
1538                                   d->hDbc,
1539                                   &hStmt);
1540     if (r != SQL_SUCCESS) {
1541         qSqlWarning(QLatin1String("QDB2Driver::primaryIndex: Unable to list primary key"), d);
1542         return index;
1543     }
1544     QString catalog, schema, table;
1545     qSplitTableQualifier(tablename, &catalog, &schema, &table);
1546 
1547     if (isIdentifierEscaped(catalog, QSqlDriver::TableName))
1548         catalog = stripDelimiters(catalog, QSqlDriver::TableName);
1549     else
1550         catalog = catalog.toUpper();
1551 
1552     if (isIdentifierEscaped(schema, QSqlDriver::TableName))
1553         schema = stripDelimiters(schema, QSqlDriver::TableName);
1554     else
1555         schema = schema.toUpper();
1556 
1557     if (isIdentifierEscaped(table, QSqlDriver::TableName))
1558         table = stripDelimiters(table, QSqlDriver::TableName);
1559     else
1560         table = table.toUpper();
1561 
1562     r = SQLSetStmtAttr(hStmt,
1563                         SQL_ATTR_CURSOR_TYPE,
1564                         (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,
1565                         SQL_IS_UINTEGER);
1566 
1567     r = SQLPrimaryKeys(hStmt,
1568                         NULL,
1569                         0,
1570                         qToTChar(schema),
1571                         schema.length(),
1572                         qToTChar(table),
1573                         table.length());
1574     r = SQLFetchScroll(hStmt,
1575                         SQL_FETCH_NEXT,
1576                         0);
1577 
1578     bool isNull;
1579     QString cName, idxName;
1580     // Store all fields in a StringList because the driver can't detail fields in this FETCH loop
1581     while (r == SQL_SUCCESS) {
1582         cName = qGetStringData(hStmt, 3, -1, isNull); // column name
1583         idxName = qGetStringData(hStmt, 5, -1, isNull); // pk index name
1584         index.append(rec.field(cName));
1585         index.setName(idxName);
1586         r = SQLFetchScroll(hStmt,
1587                             SQL_FETCH_NEXT,
1588                             0);
1589     }
1590     r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
1591     if (r!= SQL_SUCCESS)
1592         qSqlWarning(QLatin1String("QDB2Driver: Unable to free statement handle ")
1593                     + QString::number(r), d);
1594     return index;
1595 }
1596 
1597 bool QDB2Driver::hasFeature(DriverFeature f) const
1598 {
1599     switch (f) {
1600         case QuerySize:
1601         case NamedPlaceholders:
1602         case BatchOperations:
1603         case LastInsertId:
1604         case SimpleLocking:
1605         case EventNotifications:
1606         case CancelQuery:
1607             return false;
1608         case BLOB:
1609         case Transactions:
1610         case MultipleResultSets:
1611         case PreparedQueries:
1612         case PositionalPlaceholders:
1613         case LowPrecisionNumbers:
1614         case FinishQuery:
1615             return true;
1616         case Unicode:
1617             return true;
1618     }
1619     return false;
1620 }
1621 
1622 bool QDB2Driver::beginTransaction()
1623 {
1624     if (!isOpen()) {
1625         qWarning("QDB2Driver::beginTransaction: Database not open");
1626         return false;
1627     }
1628     return setAutoCommit(false);
1629 }
1630 
1631 bool QDB2Driver::commitTransaction()
1632 {
1633     Q_D(QDB2Driver);
1634     if (!isOpen()) {
1635         qWarning("QDB2Driver::commitTransaction: Database not open");
1636         return false;
1637     }
1638     SQLRETURN r = SQLEndTran(SQL_HANDLE_DBC,
1639                               d->hDbc,
1640                               SQL_COMMIT);
1641     if (r != SQL_SUCCESS) {
1642         setLastError(qMakeError(tr("Unable to commit transaction"),
1643                      QSqlError::TransactionError, d));
1644         return false;
1645     }
1646     return setAutoCommit(true);
1647 }
1648 
1649 bool QDB2Driver::rollbackTransaction()
1650 {
1651     Q_D(QDB2Driver);
1652     if (!isOpen()) {
1653         qWarning("QDB2Driver::rollbackTransaction: Database not open");
1654         return false;
1655     }
1656     SQLRETURN r = SQLEndTran(SQL_HANDLE_DBC,
1657                               d->hDbc,
1658                               SQL_ROLLBACK);
1659     if (r != SQL_SUCCESS) {
1660         setLastError(qMakeError(tr("Unable to rollback transaction"),
1661                                 QSqlError::TransactionError, d));
1662         return false;
1663     }
1664     return setAutoCommit(true);
1665 }
1666 
1667 bool QDB2Driver::setAutoCommit(bool autoCommit)
1668 {
1669     Q_D(QDB2Driver);
1670     SQLUINTEGER ac = autoCommit ? SQL_AUTOCOMMIT_ON : SQL_AUTOCOMMIT_OFF;
1671     SQLRETURN r  = SQLSetConnectAttr(d->hDbc,
1672                                       SQL_ATTR_AUTOCOMMIT,
1673                                       reinterpret_cast<SQLPOINTER>(ac),
1674                                       sizeof(ac));
1675     if (r != SQL_SUCCESS) {
1676         setLastError(qMakeError(tr("Unable to set autocommit"),
1677                                 QSqlError::TransactionError, d));
1678         return false;
1679     }
1680     return true;
1681 }
1682 
1683 QString QDB2Driver::formatValue(const QSqlField &field, bool trimStrings) const
1684 {
1685     if (field.isNull())
1686         return QLatin1String("NULL");
1687 
1688     switch (field.type()) {
1689         case QVariant::DateTime: {
1690             // Use an escape sequence for the datetime fields
1691             if (field.value().toDateTime().isValid()) {
1692                 QDate dt = field.value().toDateTime().date();
1693                 QTime tm = field.value().toDateTime().time();
1694                 // Dateformat has to be "yyyy-MM-dd hh:mm:ss", with leading zeroes if month or day < 10
1695                 return QLatin1Char('\'') + QString::number(dt.year()) + QLatin1Char('-')
1696                        + QString::number(dt.month()) + QLatin1Char('-')
1697                        + QString::number(dt.day()) + QLatin1Char('-')
1698                        + QString::number(tm.hour()) + QLatin1Char('.')
1699                        + QString::number(tm.minute()).rightJustified(2, QLatin1Char('0'), true)
1700                        + QLatin1Char('.')
1701                        + QString::number(tm.second()).rightJustified(2, QLatin1Char('0'), true)
1702                        + QLatin1Char('.')
1703                        + QString::number(tm.msec() * 1000).rightJustified(6, QLatin1Char('0'), true)
1704                        + QLatin1Char('\'');
1705                 } else {
1706                     return QLatin1String("NULL");
1707                 }
1708         }
1709         case QVariant::ByteArray: {
1710             QByteArray ba = field.value().toByteArray();
1711             QString res;
1712             res += QLatin1String("BLOB(X'");
1713             static const char hexchars[] = "0123456789abcdef";
1714             for (int i = 0; i < ba.size(); ++i) {
1715                 uchar s = (uchar) ba[i];
1716                 res += QLatin1Char(hexchars[s >> 4]);
1717                 res += QLatin1Char(hexchars[s & 0x0f]);
1718             }
1719             res += QLatin1String("')");
1720             return res;
1721         }
1722         default:
1723             return QSqlDriver::formatValue(field, trimStrings);
1724     }
1725 }
1726 
1727 QVariant QDB2Driver::handle() const
1728 {
1729     Q_D(const QDB2Driver);
1730     return QVariant(qRegisterMetaType<SQLHANDLE>("SQLHANDLE"), &d->hDbc);
1731 }
1732 
1733 QString QDB2Driver::escapeIdentifier(const QString &identifier, IdentifierType) const
1734 {
1735     QString res = identifier;
1736     if(!identifier.isEmpty() && !identifier.startsWith(QLatin1Char('"')) && !identifier.endsWith(QLatin1Char('"')) ) {
1737         res.replace(QLatin1Char('"'), QLatin1String("\"\""));
1738         res.prepend(QLatin1Char('"')).append(QLatin1Char('"'));
1739         res.replace(QLatin1Char('.'), QLatin1String("\".\""));
1740     }
1741     return res;
1742 }
1743 
1744 QT_END_NAMESPACE
