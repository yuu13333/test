Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
Android: fix log output pattern

Removed hardcoded android log pattern as this is already part of the message.

Change-Id: I529b550114a2164beafe305f8392891c4ead88f0

####code 
1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Olivier Goffart <ogoffart@woboq.com>
5 ** Copyright (C) 2018 Intel Corporation.
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qglobal_p.h"
43 #include "qlogging.h"
44 #include "qlogging_p.h"
45 #include "qlist.h"
46 #include "qbytearray.h"
47 #include "qstring.h"
48 #include "qvarlengtharray.h"
49 #include "qdebug.h"
50 #include "qmutex.h"
51 #include "qloggingcategory.h"
52 #ifndef QT_BOOTSTRAPPED
53 #include "qelapsedtimer.h"
54 #include "qdatetime.h"
55 #include "qcoreapplication.h"
56 #include "qthread.h"
57 #include "private/qloggingregistry_p.h"
58 #include "private/qcoreapplication_p.h"
59 #include "private/qsimd_p.h"
60 #endif
61 #ifdef Q_OS_WIN
62 #include <qt_windows.h>
63 #endif
64 #ifdef Q_CC_MSVC
65 #include <intrin.h>
66 #endif
67 #if QT_CONFIG(slog2)
68 #include <sys/slog2.h>
69 #endif
70 #if QT_HAS_INCLUDE(<paths.h>)
71 #include <paths.h>
72 #endif
73 
74 #ifdef Q_OS_ANDROID
75 #include <android/log.h>
76 #endif
77 
78 #ifdef Q_OS_DARWIN
79 #include <QtCore/private/qcore_mac_p.h>
80 #endif
81 
82 #if QT_CONFIG(journald)
83 # define SD_JOURNAL_SUPPRESS_LOCATION
84 # include <systemd/sd-journal.h>
85 # include <syslog.h>
86 #endif
87 #if QT_CONFIG(syslog)
88 # include <syslog.h>
89 #endif
90 #ifdef Q_OS_UNIX
91 # include <sys/types.h>
92 # include <sys/stat.h>
93 # include <unistd.h>
94 # include "private/qcore_unix_p.h"
95 #endif
96 
97 #if QT_CONFIG(regularexpression)
98 #  ifdef __UCLIBC__
99 #    if __UCLIBC_HAS_BACKTRACE__
100 #      define QLOGGING_HAVE_BACKTRACE
101 #    endif
102 #  elif (defined(__GLIBC__) && defined(__GLIBCXX__)) || (QT_HAS_INCLUDE(<cxxabi.h>) && QT_HAS_INCLUDE(<execinfo.h>))
103 #    define QLOGGING_HAVE_BACKTRACE
104 #  endif
105 #endif
106 
107 #if QT_CONFIG(slog2)
108 extern char *__progname;
109 #endif
110 
111 #ifndef QT_BOOTSTRAPPED
112 #if defined(Q_OS_LINUX) && (defined(__GLIBC__) || QT_HAS_INCLUDE(<sys/syscall.h>))
113 #  include <sys/syscall.h>
114 
115 # if defined(Q_OS_ANDROID) && !defined(SYS_gettid)
116 #  define SYS_gettid __NR_gettid
117 # endif
118 
119 static long qt_gettid()
120 {
121     // no error handling
122     // this syscall has existed since Linux 2.4.11 and cannot fail
123     return syscall(SYS_gettid);
124 }
125 #elif defined(Q_OS_DARWIN)
126 #  include <pthread.h>
127 static int qt_gettid()
128 {
129     // no error handling: this call cannot fail
130     __uint64_t tid;
131     pthread_threadid_np(NULL, &tid);
132     return tid;
133 }
134 #elif defined(Q_OS_FREEBSD_KERNEL) && defined(__FreeBSD_version) && __FreeBSD_version >= 900031
135 #  include <pthread_np.h>
136 static int qt_gettid()
137 {
138     return pthread_getthreadid_np();
139 }
140 #else
141 static QT_PREPEND_NAMESPACE(qint64) qt_gettid()
142 {
143     QT_USE_NAMESPACE
144     return qintptr(QThread::currentThreadId());
145 }
146 #endif
147 
148 #ifdef QLOGGING_HAVE_BACKTRACE
149 #  include <qregularexpression.h>
150 #  include <cxxabi.h>
151 #  include <execinfo.h>
152 #endif
153 #endif // !QT_BOOTSTRAPPED
154 
155 #include <cstdlib>
156 
157 #include <stdio.h>
158 
159 QT_BEGIN_NAMESPACE
160 
161 #if !defined(Q_CC_MSVC)
162 Q_NORETURN
163 #endif
164 static void qt_message_fatal(QtMsgType, const QMessageLogContext &context, const QString &message);
165 static void qt_message_print(QtMsgType, const QMessageLogContext &context, const QString &message);
166 static void qt_message_print(const QString &message);
167 
168 static int checked_var_value(const char *varname)
169 {
170     // qEnvironmentVariableIntValue returns 0 on both parsing failure and on
171     // empty, but we need to distinguish between the two for backwards
172     // compatibility reasons.
173     QByteArray str = qgetenv(varname);
174     if (str.isEmpty())
175         return 0;
176 
177     bool ok;
178     int value = str.toInt(&ok, 0);
179     return ok ? value : 1;
180 }
181 
182 static bool isFatal(QtMsgType msgType)
183 {
184     if (msgType == QtFatalMsg)
185         return true;
186 
187     if (msgType == QtCriticalMsg) {
188         static QAtomicInt fatalCriticals = checked_var_value("QT_FATAL_CRITICALS");
189 
190         // it's fatal if the current value is exactly 1,
191         // otherwise decrement if it's non-zero
192         return fatalCriticals.load() && fatalCriticals.fetchAndAddRelaxed(-1) == 1;
193     }
194 
195     if (msgType == QtWarningMsg || msgType == QtCriticalMsg) {
196         static QAtomicInt fatalWarnings = checked_var_value("QT_FATAL_WARNINGS");
197 
198         // it's fatal if the current value is exactly 1,
199         // otherwise decrement if it's non-zero
200         return fatalWarnings.load() && fatalWarnings.fetchAndAddRelaxed(-1) == 1;
201     }
202 
203     return false;
204 }
205 
206 static bool isDefaultCategory(const char *category)
207 {
208     return !category || strcmp(category, "default") == 0;
209 }
210 
211 /*!
212     Returns true if writing to \c stderr is supported.
213 
214     \internal
215     \sa stderrHasConsoleAttached()
216 */
217 static bool systemHasStderr()
218 {
219 #if defined(Q_OS_WINRT)
220     return false; // WinRT has no stderr
221 #endif
222 
223     return true;
224 }
225 
226 /*!
227     Returns true if writing to \c stderr will end up in a console/terminal visible to the user.
228 
229     This is typically the case if the application was started from the command line.
230 
231     If the application is started without a controlling console/terminal, but the parent
232     process reads \c stderr and presents it to the user in some other way, the parent process
233     may override the detection in this function by setting the QT_ASSUME_STDERR_HAS_CONSOLE
234     environment variable to \c 1.
235 
236     \note Qt Creator does not implement a pseudo TTY, nor does it launch apps with
237     the override environment variable set, but it will read stderr and print it to
238     the user, so in effect this function can not be used to conclude that stderr
239     output will _not_ be visible to the user, as even if this function returns false,
240     the output might still end up visible to the user. For this reason, we don't guard
241     the stderr output in the default message handler with stderrHasConsoleAttached().
242 
243     \internal
244     \sa systemHasStderr()
245 */
246 bool stderrHasConsoleAttached()
247 {
248     static const bool stderrHasConsoleAttached = []() -> bool {
249         if (!systemHasStderr())
250             return false;
251 
252         if (qEnvironmentVariableIntValue("QT_LOGGING_TO_CONSOLE")) {
253             fprintf(stderr, "warning: Environment variable QT_LOGGING_TO_CONSOLE is deprecated, use\n"
254                             "QT_ASSUME_STDERR_HAS_CONSOLE and/or QT_FORCE_STDERR_LOGGING instead.\n");
255             return true;
256         }
257 
258         if (qEnvironmentVariableIntValue("QT_ASSUME_STDERR_HAS_CONSOLE"))
259             return true;
260 
261 #if defined(Q_OS_WIN) && !defined(Q_OS_WINRT)
262         return GetConsoleWindow();
263 #elif defined(Q_OS_UNIX)
264 #       ifndef _PATH_TTY
265 #       define _PATH_TTY "/dev/tty"
266 #       endif
267 
268         // If we can open /dev/tty, we have a controlling TTY
269         int ttyDevice = -1;
270         if ((ttyDevice = qt_safe_open(_PATH_TTY, O_RDONLY)) >= 0) {
271             qt_safe_close(ttyDevice);
272             return true;
273         } else if (errno == ENOENT || errno == EPERM || errno == ENXIO) {
274             // Fall back to isatty for some non-critical errors
275             return isatty(STDERR_FILENO);
276         } else {
277             return false;
278         }
279 #else
280         return false; // No way to detect if stderr has a console attached
281 #endif
282     }();
283 
284     return stderrHasConsoleAttached;
285 }
286 
287 
288 namespace QtPrivate {
289 
290 /*!
291     Returns true if logging \c stderr should be ensured.
292 
293     This is normally the case if \c stderr has a console attached, but may be overridden
294     by the user by setting the QT_FORCE_STDERR_LOGGING environment variable to \c 1.
295 
296     \internal
297     \sa stderrHasConsoleAttached()
298 */
299 bool shouldLogToStderr()
300 {
301     static bool forceStderrLogging = qEnvironmentVariableIntValue("QT_FORCE_STDERR_LOGGING");
302     return forceStderrLogging || stderrHasConsoleAttached();
303 }
304 
305 
306 } // QtPrivate
307 
308 using namespace QtPrivate;
309 
310 /*!
311     \class QMessageLogContext
312     \inmodule QtCore
313     \brief The QMessageLogContext class provides additional information about a log message.
314     \since 5.0
315 
316     The class provides information about the source code location a qDebug(), qInfo(), qWarning(),
317     qCritical() or qFatal() message was generated.
318 
319     \note By default, this information is recorded only in debug builds. You can overwrite
320     this explicitly by defining \c QT_MESSAGELOGCONTEXT or \c{QT_NO_MESSAGELOGCONTEXT}.
321 
322     \sa QMessageLogger, QtMessageHandler, qInstallMessageHandler()
323 */
324 
325 /*!
326     \class QMessageLogger
327     \inmodule QtCore
328     \brief The QMessageLogger class generates log messages.
329     \since 5.0
330 
331     QMessageLogger is used to generate messages for the Qt logging framework. Usually one uses
332     it through qDebug(), qInfo(), qWarning(), qCritical, or qFatal() functions,
333     which are actually macros: For example qDebug() expands to
334     QMessageLogger(__FILE__, __LINE__, Q_FUNC_INFO).debug()
335     for debug builds, and QMessageLogger(0, 0, 0).debug() for release builds.
336 
337     One example of direct use is to forward errors that stem from a scripting language, e.g. QML:
338 
339     \snippet code/qlogging/qlogging.cpp 1
340 
341     \sa QMessageLogContext, qDebug(), qInfo(), qWarning(), qCritical(), qFatal()
342 */
343 
344 #if defined(Q_CC_MSVC) && defined(QT_DEBUG) && defined(_DEBUG) && defined(_CRT_ERROR)
345 static inline void convert_to_wchar_t_elided(wchar_t *d, size_t space, const char *s) Q_DECL_NOEXCEPT
346 {
347     size_t len = qstrlen(s);
348     if (len + 1 > space) {
349         const size_t skip = len - space + 4; // 4 for "..." + '\0'
350         s += skip;
351         len -= skip;
352         for (int i = 0; i < 3; ++i)
353           *d++ = L'.';
354     }
355     while (len--)
356         *d++ = *s++;
357     *d++ = 0;
358 }
359 #endif
360 
361 /*!
362     \internal
363 */
364 Q_NEVER_INLINE
365 static QString qt_message(QtMsgType msgType, const QMessageLogContext &context, const char *msg, va_list ap)
366 {
367     QString buf = QString::vasprintf(msg, ap);
368     qt_message_print(msgType, context, buf);
369     return buf;
370 }
371 
372 #undef qDebug
373 /*!
374     Logs a debug message specified with format \a msg. Additional
375     parameters, specified by \a msg, may be used.
376 
377     \sa qDebug()
378 */
379 void QMessageLogger::debug(const char *msg, ...) const
380 {
381     va_list ap;
382     va_start(ap, msg); // use variable arg list
383     const QString message = qt_message(QtDebugMsg, context, msg, ap);
384     va_end(ap);
385 
386     if (isFatal(QtDebugMsg))
387         qt_message_fatal(QtDebugMsg, context, message);
388 }
389 
390 
391 #undef qInfo
392 /*!
393     Logs an informational message specified with format \a msg. Additional
394     parameters, specified by \a msg, may be used.
395 
396     \sa qInfo()
397     \since 5.5
398 */
399 void QMessageLogger::info(const char *msg, ...) const
400 {
401     va_list ap;
402     va_start(ap, msg); // use variable arg list
403     const QString message = qt_message(QtInfoMsg, context, msg, ap);
404     va_end(ap);
405 
406     if (isFatal(QtInfoMsg))
407         qt_message_fatal(QtInfoMsg, context, message);
408 }
409 
410 /*!
411     \typedef QMessageLogger::CategoryFunction
412 
413     This is a typedef for a pointer to a function with the following
414     signature:
415 
416     \snippet code/qlogging/qlogging.cpp 2
417 
418     A function which this signature is generated by Q_DECLARE_LOGGING_CATEGORY,
419     Q_LOGGING_CATEGORY.
420 
421     \since 5.3
422 */
423 
424 /*!
425     Logs a debug message specified with format \a msg for the context \a cat.
426     Additional parameters, specified by \a msg, may be used.
427 
428     \since 5.3
429     \sa qCDebug()
430 */
431 void QMessageLogger::debug(const QLoggingCategory &cat, const char *msg, ...) const
432 {
433     if (!cat.isDebugEnabled())
434         return;
435 
436     QMessageLogContext ctxt;
437     ctxt.copy(context);
438     ctxt.category = cat.categoryName();
439 
440     va_list ap;
441     va_start(ap, msg); // use variable arg list
442     const QString message = qt_message(QtDebugMsg, ctxt, msg, ap);
443     va_end(ap);
444 
445     if (isFatal(QtDebugMsg))
446         qt_message_fatal(QtDebugMsg, ctxt, message);
447 }
448 
449 /*!
450     Logs a debug message specified with format \a msg for the context returned
451     by \a catFunc. Additional parameters, specified by \a msg, may be used.
452 
453     \since 5.3
454     \sa qCDebug()
455 */
456 void QMessageLogger::debug(QMessageLogger::CategoryFunction catFunc,
457                            const char *msg, ...) const
458 {
459     const QLoggingCategory &cat = (*catFunc)();
460     if (!cat.isDebugEnabled())
461         return;
462 
463     QMessageLogContext ctxt;
464     ctxt.copy(context);
465     ctxt.category = cat.categoryName();
466 
467     va_list ap;
468     va_start(ap, msg); // use variable arg list
469     const QString message = qt_message(QtDebugMsg, ctxt, msg, ap);
470     va_end(ap);
471 
472     if (isFatal(QtDebugMsg))
473         qt_message_fatal(QtDebugMsg, ctxt, message);
474 }
475 
476 #ifndef QT_NO_DEBUG_STREAM
477 
478 /*!
479     Logs a debug message using a QDebug stream
480 
481     \sa qDebug(), QDebug
482 */
483 QDebug QMessageLogger::debug() const
484 {
485     QDebug dbg = QDebug(QtDebugMsg);
486     QMessageLogContext &ctxt = dbg.stream->context;
487     ctxt.copy(context);
488     return dbg;
489 }
490 
491 /*!
492     Logs a debug message into category \a cat using a QDebug stream.
493 
494     \since 5.3
495     \sa qCDebug(), QDebug
496 */
497 QDebug QMessageLogger::debug(const QLoggingCategory &cat) const
498 {
499     QDebug dbg = QDebug(QtDebugMsg);
500     if (!cat.isDebugEnabled())
501         dbg.stream->message_output = false;
502 
503     QMessageLogContext &ctxt = dbg.stream->context;
504     ctxt.copy(context);
505     ctxt.category = cat.categoryName();
506 
507     return dbg;
508 }
509 
510 /*!
511     Logs a debug message into category returned by \a catFunc using a QDebug stream.
512 
513     \since 5.3
514     \sa qCDebug(), QDebug
515 */
516 QDebug QMessageLogger::debug(QMessageLogger::CategoryFunction catFunc) const
517 {
518     return debug((*catFunc)());
519 }
520 
521 /*!
522     \internal
523 
524     Returns a QNoDebug object, which is used to ignore debugging output.
525 
526     \sa QNoDebug, qDebug()
527 */
528 QNoDebug QMessageLogger::noDebug() const Q_DECL_NOTHROW
529 {
530     return QNoDebug();
531 }
532 
533 #endif
534 
535 /*!
536     Logs an informational message specified with format \a msg for the context \a cat.
537     Additional parameters, specified by \a msg, may be used.
538 
539     \since 5.5
540     \sa qCInfo()
541 */
542 void QMessageLogger::info(const QLoggingCategory &cat, const char *msg, ...) const
543 {
544     if (!cat.isInfoEnabled())
545         return;
546 
547     QMessageLogContext ctxt;
548     ctxt.copy(context);
549     ctxt.category = cat.categoryName();
550 
551     va_list ap;
552     va_start(ap, msg); // use variable arg list
553     const QString message = qt_message(QtInfoMsg, ctxt, msg, ap);
554     va_end(ap);
555 
556     if (isFatal(QtInfoMsg))
557         qt_message_fatal(QtInfoMsg, ctxt, message);
558 }
559 
560 /*!
561     Logs an informational message specified with format \a msg for the context returned
562     by \a catFunc. Additional parameters, specified by \a msg, may be used.
563 
564     \since 5.5
565     \sa qCInfo()
566 */
567 void QMessageLogger::info(QMessageLogger::CategoryFunction catFunc,
568                            const char *msg, ...) const
569 {
570     const QLoggingCategory &cat = (*catFunc)();
571     if (!cat.isInfoEnabled())
572         return;
573 
574     QMessageLogContext ctxt;
575     ctxt.copy(context);
576     ctxt.category = cat.categoryName();
577 
578     va_list ap;
579     va_start(ap, msg); // use variable arg list
580     const QString message = qt_message(QtInfoMsg, ctxt, msg, ap);
581     va_end(ap);
582 
583     if (isFatal(QtInfoMsg))
584         qt_message_fatal(QtInfoMsg, ctxt, message);
585 }
586 
587 #ifndef QT_NO_DEBUG_STREAM
588 
589 /*!
590     Logs an informational message using a QDebug stream.
591 
592     \since 5.5
593     \sa qInfo(), QDebug
594 */
595 QDebug QMessageLogger::info() const
596 {
597     QDebug dbg = QDebug(QtInfoMsg);
598     QMessageLogContext &ctxt = dbg.stream->context;
599     ctxt.copy(context);
600     return dbg;
601 }
602 
603 /*!
604     Logs an informational message into the category \a cat using a QDebug stream.
605 
606     \since 5.5
607     \sa qCInfo(), QDebug
608 */
609 QDebug QMessageLogger::info(const QLoggingCategory &cat) const
610 {
611     QDebug dbg = QDebug(QtInfoMsg);
612     if (!cat.isInfoEnabled())
613         dbg.stream->message_output = false;
614 
615     QMessageLogContext &ctxt = dbg.stream->context;
616     ctxt.copy(context);
617     ctxt.category = cat.categoryName();
618 
619     return dbg;
620 }
621 
622 /*!
623     Logs an informational message into category returned by \a catFunc using a QDebug stream.
624 
625     \since 5.5
626     \sa qCInfo(), QDebug
627 */
628 QDebug QMessageLogger::info(QMessageLogger::CategoryFunction catFunc) const
629 {
630     return info((*catFunc)());
631 }
632 
633 #endif
634 
635 #undef qWarning
636 /*!
637     Logs a warning message specified with format \a msg. Additional
638     parameters, specified by \a msg, may be used.
639 
640     \sa qWarning()
641 */
642 void QMessageLogger::warning(const char *msg, ...) const
643 {
644     va_list ap;
645     va_start(ap, msg); // use variable arg list
646     const QString message = qt_message(QtWarningMsg, context, msg, ap);
647     va_end(ap);
648 
649     if (isFatal(QtWarningMsg))
650         qt_message_fatal(QtWarningMsg, context, message);
651 }
652 
653 /*!
654     Logs a warning message specified with format \a msg for the context \a cat.
655     Additional parameters, specified by \a msg, may be used.
656 
657     \since 5.3
658     \sa qCWarning()
659 */
660 void QMessageLogger::warning(const QLoggingCategory &cat, const char *msg, ...) const
661 {
662     if (!cat.isWarningEnabled())
663         return;
664 
665     QMessageLogContext ctxt;
666     ctxt.copy(context);
667     ctxt.category = cat.categoryName();
668 
669     va_list ap;
670     va_start(ap, msg); // use variable arg list
671     const QString message = qt_message(QtWarningMsg, ctxt, msg, ap);
672     va_end(ap);
673 
674     if (isFatal(QtWarningMsg))
675         qt_message_fatal(QtWarningMsg, ctxt, message);
676 }
677 
678 /*!
679     Logs a warning message specified with format \a msg for the context returned
680     by \a catFunc. Additional parameters, specified by \a msg, may be used.
681 
682     \since 5.3
683     \sa qCWarning()
684 */
685 void QMessageLogger::warning(QMessageLogger::CategoryFunction catFunc,
686                              const char *msg, ...) const
687 {
688     const QLoggingCategory &cat = (*catFunc)();
689     if (!cat.isWarningEnabled())
690         return;
691 
692     QMessageLogContext ctxt;
693     ctxt.copy(context);
694     ctxt.category = cat.categoryName();
695 
696     va_list ap;
697     va_start(ap, msg); // use variable arg list
698     const QString message = qt_message(QtWarningMsg, ctxt, msg, ap);
699     va_end(ap);
700 
701     if (isFatal(QtWarningMsg))
702         qt_message_fatal(QtWarningMsg, ctxt, message);
703 }
704 
705 #ifndef QT_NO_DEBUG_STREAM
706 /*!
707     Logs a warning message using a QDebug stream
708 
709     \sa qWarning(), QDebug
710 */
711 QDebug QMessageLogger::warning() const
712 {
713     QDebug dbg = QDebug(QtWarningMsg);
714     QMessageLogContext &ctxt = dbg.stream->context;
715     ctxt.copy(context);
716     return dbg;
717 }
718 
719 /*!
720     Logs a warning message into category \a cat using a QDebug stream.
721 
722     \sa qCWarning(), QDebug
723 */
724 QDebug QMessageLogger::warning(const QLoggingCategory &cat) const
725 {
726     QDebug dbg = QDebug(QtWarningMsg);
727     if (!cat.isWarningEnabled())
728         dbg.stream->message_output = false;
729 
730     QMessageLogContext &ctxt = dbg.stream->context;
731     ctxt.copy(context);
732     ctxt.category = cat.categoryName();
733 
734     return dbg;
735 }
736 
737 /*!
738     Logs a warning message into category returned by \a catFunc using a QDebug stream.
739 
740     \since 5.3
741     \sa qCWarning(), QDebug
742 */
743 QDebug QMessageLogger::warning(QMessageLogger::CategoryFunction catFunc) const
744 {
745     return warning((*catFunc)());
746 }
747 
748 #endif
749 
750 #undef qCritical
751 
752 /*!
753     Logs a critical message specified with format \a msg. Additional
754     parameters, specified by \a msg, may be used.
755 
756     \sa qCritical()
757 */
758 void QMessageLogger::critical(const char *msg, ...) const
759 {
760     va_list ap;
761     va_start(ap, msg); // use variable arg list
762     const QString message = qt_message(QtCriticalMsg, context, msg, ap);
763     va_end(ap);
764 
765     if (isFatal(QtCriticalMsg))
766         qt_message_fatal(QtCriticalMsg, context, message);
767 }
768 
769 /*!
770     Logs a critical message specified with format \a msg for the context \a cat.
771     Additional parameters, specified by \a msg, may be used.
772 
773     \since 5.3
774     \sa qCCritical()
775 */
776 void QMessageLogger::critical(const QLoggingCategory &cat, const char *msg, ...) const
777 {
778     if (!cat.isCriticalEnabled())
779         return;
780 
781     QMessageLogContext ctxt;
782     ctxt.copy(context);
783     ctxt.category = cat.categoryName();
784 
785     va_list ap;
786     va_start(ap, msg); // use variable arg list
787     const QString message = qt_message(QtCriticalMsg, ctxt, msg, ap);
788     va_end(ap);
789 
790     if (isFatal(QtCriticalMsg))
791         qt_message_fatal(QtCriticalMsg, ctxt, message);
792 }
793 
794 /*!
795     Logs a critical message specified with format \a msg for the context returned
796     by \a catFunc. Additional parameters, specified by \a msg, may be used.
797 
798     \since 5.3
799     \sa qCCritical()
800 */
801 void QMessageLogger::critical(QMessageLogger::CategoryFunction catFunc,
802                               const char *msg, ...) const
803 {
804     const QLoggingCategory &cat = (*catFunc)();
805     if (!cat.isCriticalEnabled())
806         return;
807 
808     QMessageLogContext ctxt;
809     ctxt.copy(context);
810     ctxt.category = cat.categoryName();
811 
812     va_list ap;
813     va_start(ap, msg); // use variable arg list
814     const QString message = qt_message(QtCriticalMsg, ctxt, msg, ap);
815     va_end(ap);
816 
817     if (isFatal(QtCriticalMsg))
818         qt_message_fatal(QtCriticalMsg, ctxt, message);
819 }
820 
821 #ifndef QT_NO_DEBUG_STREAM
822 /*!
823     Logs a critical message using a QDebug stream
824 
825     \sa qCritical(), QDebug
826 */
827 QDebug QMessageLogger::critical() const
828 {
829     QDebug dbg = QDebug(QtCriticalMsg);
830     QMessageLogContext &ctxt = dbg.stream->context;
831     ctxt.copy(context);
832     return dbg;
833 }
834 
835 /*!
836     Logs a critical message into category \a cat using a QDebug stream.
837 
838     \since 5.3
839     \sa qCCritical(), QDebug
840 */
841 QDebug QMessageLogger::critical(const QLoggingCategory &cat) const
842 {
843     QDebug dbg = QDebug(QtCriticalMsg);
844     if (!cat.isCriticalEnabled())
845         dbg.stream->message_output = false;
846 
847     QMessageLogContext &ctxt = dbg.stream->context;
848     ctxt.copy(context);
849     ctxt.category = cat.categoryName();
850 
851     return dbg;
852 }
853 
854 /*!
855     Logs a critical message into category returned by \a catFunc using a QDebug stream.
856 
857     \since 5.3
858     \sa qCCritical(), QDebug
859 */
860 QDebug QMessageLogger::critical(QMessageLogger::CategoryFunction catFunc) const
861 {
862     return critical((*catFunc)());
863 }
864 
865 #endif
866 
867 #undef qFatal
868 /*!
869     Logs a fatal message specified with format \a msg. Additional
870     parameters, specified by \a msg, may be used.
871 
872     \sa qFatal()
873 */
874 void QMessageLogger::fatal(const char *msg, ...) const Q_DECL_NOTHROW
875 {
876     QString message;
877 
878     va_list ap;
879     va_start(ap, msg); // use variable arg list
880     QT_TERMINATE_ON_EXCEPTION(message = qt_message(QtFatalMsg, context, msg, ap));
881     va_end(ap);
882 
883     qt_message_fatal(QtFatalMsg, context, message);
884 }
885 
886 /*!
887     \internal
888 */
889 Q_AUTOTEST_EXPORT QByteArray qCleanupFuncinfo(QByteArray info)
890 {
891     // Strip the function info down to the base function name
892     // note that this throws away the template definitions,
893     // the parameter types (overloads) and any const/volatile qualifiers.
894 
895     if (info.isEmpty())
896         return info;
897 
898     int pos;
899 
900     // Skip trailing [with XXX] for templates (gcc), but make
901     // sure to not affect Objective-C message names.
902     pos = info.size() - 1;
903     if (info.endsWith(']') && !(info.startsWith('+') || info.startsWith('-'))) {
904         while (--pos) {
905             if (info.at(pos) == '[')
906                 info.truncate(pos);
907         }
908     }
909 
910     // operator names with '(', ')', '<', '>' in it
911     static const char operator_call[] = "operator()";
912     static const char operator_lessThan[] = "operator<";
913     static const char operator_greaterThan[] = "operator>";
914     static const char operator_lessThanEqual[] = "operator<=";
915     static const char operator_greaterThanEqual[] = "operator>=";
916 
917     // canonize operator names
918     info.replace("operator ", "operator");
919 
920     // remove argument list
921     forever {
922         int parencount = 0;
923         pos = info.lastIndexOf(')');
924         if (pos == -1) {
925             // Don't know how to parse this function name
926             return info;
927         }
928 
929         // find the beginning of the argument list
930         --pos;
931         ++parencount;
932         while (pos && parencount) {
933             if (info.at(pos) == ')')
934                 ++parencount;
935             else if (info.at(pos) == '(')
936                 --parencount;
937             --pos;
938         }
939         if (parencount != 0)
940             return info;
941 
942         info.truncate(++pos);
943 
944         if (info.at(pos - 1) == ')') {
945             if (info.indexOf(operator_call) == pos - (int)strlen(operator_call))
946                 break;
947 
948             // this function returns a pointer to a function
949             // and we matched the arguments of the return type's parameter list
950             // try again
951             info.remove(0, info.indexOf('('));
952             info.chop(1);
953             continue;
954         } else {
955             break;
956         }
957     }
958 
959     // find the beginning of the function name
960     int parencount = 0;
961     int templatecount = 0;
962     --pos;
963 
964     // make sure special characters in operator names are kept
965     if (pos > -1) {
966         switch (info.at(pos)) {
967         case ')':
968             if (info.indexOf(operator_call) == pos - (int)strlen(operator_call) + 1)
969                 pos -= 2;
970             break;
971         case '<':
972             if (info.indexOf(operator_lessThan) == pos - (int)strlen(operator_lessThan) + 1)
973                 --pos;
974             break;
975         case '>':
976             if (info.indexOf(operator_greaterThan) == pos - (int)strlen(operator_greaterThan) + 1)
977                 --pos;
978             break;
979         case '=': {
980             int operatorLength = (int)strlen(operator_lessThanEqual);
981             if (info.indexOf(operator_lessThanEqual) == pos - operatorLength + 1)
982                 pos -= 2;
983             else if (info.indexOf(operator_greaterThanEqual) == pos - operatorLength + 1)
984                 pos -= 2;
985             break;
986         }
987         default:
988             break;
989         }
990     }
991 
992     while (pos > -1) {
993         if (parencount < 0 || templatecount < 0)
994             return info;
995 
996         char c = info.at(pos);
997         if (c == ')')
998             ++parencount;
999         else if (c == '(')
1000             --parencount;
1001         else if (c == '>')
1002             ++templatecount;
1003         else if (c == '<')
1004             --templatecount;
1005         else if (c == ' ' && templatecount == 0 && parencount == 0)
1006             break;
1007 
1008         --pos;
1009     }
1010     info = info.mid(pos + 1);
1011 
1012     // remove trailing '*', '&' that are part of the return argument
1013     while ((info.at(0) == '*')
1014            || (info.at(0) == '&'))
1015         info = info.mid(1);
1016 
1017     // we have the full function name now.
1018     // clean up the templates
1019     while ((pos = info.lastIndexOf('>')) != -1) {
1020         if (!info.contains('<'))
1021             break;
1022 
1023         // find the matching close
1024         int end = pos;
1025         templatecount = 1;
1026         --pos;
1027         while (pos && templatecount) {
1028             char c = info.at(pos);
1029             if (c == '>')
1030                 ++templatecount;
1031             else if (c == '<')
1032                 --templatecount;
1033             --pos;
1034         }
1035         ++pos;
1036         info.remove(pos, end - pos + 1);
1037     }
1038 
1039     return info;
1040 }
1041 
1042 // tokens as recognized in QT_MESSAGE_PATTERN
1043 static const char categoryTokenC[] = "%{category}";
1044 static const char typeTokenC[] = "%{type}";
1045 static const char messageTokenC[] = "%{message}";
1046 static const char fileTokenC[] = "%{file}";
1047 static const char lineTokenC[] = "%{line}";
1048 static const char functionTokenC[] = "%{function}";
1049 static const char pidTokenC[] = "%{pid}";
1050 static const char appnameTokenC[] = "%{appname}";
1051 static const char threadidTokenC[] = "%{threadid}";
1052 static const char qthreadptrTokenC[] = "%{qthreadptr}";
1053 static const char timeTokenC[] = "%{time"; //not a typo: this command has arguments
1054 static const char backtraceTokenC[] = "%{backtrace"; //ditto
1055 static const char ifCategoryTokenC[] = "%{if-category}";
1056 static const char ifDebugTokenC[] = "%{if-debug}";
1057 static const char ifInfoTokenC[] = "%{if-info}";
1058 static const char ifWarningTokenC[] = "%{if-warning}";
1059 static const char ifCriticalTokenC[] = "%{if-critical}";
1060 static const char ifFatalTokenC[] = "%{if-fatal}";
1061 static const char endifTokenC[] = "%{endif}";
1062 static const char emptyTokenC[] = "";
1063 
1064 static const char defaultPattern[] = "%{if-category}%{category}: %{endif}%{message}";
1065 
1066 
1067 struct QMessagePattern {
1068     QMessagePattern();
1069     ~QMessagePattern();
1070 
1071     void setPattern(const QString &pattern);
1072 
1073     // 0 terminated arrays of literal tokens / literal or placeholder tokens
1074     const char **literals;
1075     const char **tokens;
1076     QList<QString> timeArgs;   // timeFormats in sequence of %{time
1077 #ifndef QT_BOOTSTRAPPED
1078     QElapsedTimer timer;
1079 #endif
1080 #ifdef QLOGGING_HAVE_BACKTRACE
1081     struct BacktraceParams {
1082         QString backtraceSeparator;
1083         int backtraceDepth;
1084     };
1085     QVector<BacktraceParams> backtraceArgs; // backtrace argumens in sequence of %{backtrace
1086 #endif
1087 
1088     bool fromEnvironment;
1089     static QBasicMutex mutex;
1090 };
1091 #ifdef QLOGGING_HAVE_BACKTRACE
1092 Q_DECLARE_TYPEINFO(QMessagePattern::BacktraceParams, Q_MOVABLE_TYPE);
1093 #endif
1094 
1095 QBasicMutex QMessagePattern::mutex;
1096 
1097 QMessagePattern::QMessagePattern()
1098     : literals(0)
1099     , tokens(0)
1100     , fromEnvironment(false)
1101 {
1102 #ifndef QT_BOOTSTRAPPED
1103     timer.start();
1104 #endif
1105     const QString envPattern = QString::fromLocal8Bit(qgetenv("QT_MESSAGE_PATTERN"));
1106     if (envPattern.isEmpty()) {
1107         setPattern(QLatin1String(defaultPattern));
1108     } else {
1109         setPattern(envPattern);
1110         fromEnvironment = true;
1111     }
1112 }
1113 
1114 QMessagePattern::~QMessagePattern()
1115 {
1116     for (int i = 0; literals[i]; ++i)
1117         delete [] literals[i];
1118     delete [] literals;
1119     literals = 0;
1120     delete [] tokens;
1121     tokens = 0;
1122 }
1123 
1124 void QMessagePattern::setPattern(const QString &pattern)
1125 {
1126     if (literals) {
1127         for (int i = 0; literals[i]; ++i)
1128             delete [] literals[i];
1129         delete [] literals;
1130     }
1131     delete [] tokens;
1132     timeArgs.clear();
1133 #ifdef QLOGGING_HAVE_BACKTRACE
1134     backtraceArgs.clear();
1135 #endif
1136 
1137     // scanner
1138     QList<QString> lexemes;
1139     QString lexeme;
1140     bool inPlaceholder = false;
1141     for (int i = 0; i < pattern.size(); ++i) {
1142         const QChar c = pattern.at(i);
1143         if ((c == QLatin1Char('%'))
1144                 && !inPlaceholder) {
1145             if ((i + 1 < pattern.size())
1146                     && pattern.at(i + 1) == QLatin1Char('{')) {
1147                 // beginning of placeholder
1148                 if (!lexeme.isEmpty()) {
1149                     lexemes.append(lexeme);
1150                     lexeme.clear();
1151                 }
1152                 inPlaceholder = true;
1153             }
1154         }
1155 
1156         lexeme.append(c);
1157 
1158         if ((c == QLatin1Char('}') && inPlaceholder)) {
1159             // end of placeholder
1160             lexemes.append(lexeme);
1161             lexeme.clear();
1162             inPlaceholder = false;
1163         }
1164     }
1165     if (!lexeme.isEmpty())
1166         lexemes.append(lexeme);
1167 
1168     // tokenizer
1169     QVarLengthArray<const char*> literalsVar;
1170     tokens = new const char*[lexemes.size() + 1];
1171     tokens[lexemes.size()] = 0;
1172 
1173     bool nestedIfError = false;
1174     bool inIf = false;
1175     QString error;
1176 
1177     for (int i = 0; i < lexemes.size(); ++i) {
1178         const QString lexeme = lexemes.at(i);
1179         if (lexeme.startsWith(QLatin1String("%{"))
1180                 && lexeme.endsWith(QLatin1Char('}'))) {
1181             // placeholder
1182             if (lexeme == QLatin1String(typeTokenC)) {
1183                 tokens[i] = typeTokenC;
1184             } else if (lexeme == QLatin1String(categoryTokenC))
1185                 tokens[i] = categoryTokenC;
1186             else if (lexeme == QLatin1String(messageTokenC))
1187                 tokens[i] = messageTokenC;
1188             else if (lexeme == QLatin1String(fileTokenC))
1189                 tokens[i] = fileTokenC;
1190             else if (lexeme == QLatin1String(lineTokenC))
1191                 tokens[i] = lineTokenC;
1192             else if (lexeme == QLatin1String(functionTokenC))
1193                 tokens[i] = functionTokenC;
1194             else if (lexeme == QLatin1String(pidTokenC))
1195                 tokens[i] = pidTokenC;
1196             else if (lexeme == QLatin1String(appnameTokenC))
1197                 tokens[i] = appnameTokenC;
1198             else if (lexeme == QLatin1String(threadidTokenC))
1199                 tokens[i] = threadidTokenC;
1200             else if (lexeme == QLatin1String(qthreadptrTokenC))
1201                 tokens[i] = qthreadptrTokenC;
1202             else if (lexeme.startsWith(QLatin1String(timeTokenC))) {
1203                 tokens[i] = timeTokenC;
1204                 int spaceIdx = lexeme.indexOf(QChar::fromLatin1(' '));
1205                 if (spaceIdx > 0)
1206                     timeArgs.append(lexeme.mid(spaceIdx + 1, lexeme.length() - spaceIdx - 2));
1207                 else
1208                     timeArgs.append(QString());
1209             } else if (lexeme.startsWith(QLatin1String(backtraceTokenC))) {
1210 #ifdef QLOGGING_HAVE_BACKTRACE
1211                 tokens[i] = backtraceTokenC;
1212                 QString backtraceSeparator = QStringLiteral("|");
1213                 int backtraceDepth = 5;
1214                 QRegularExpression depthRx(QStringLiteral(" depth=(?|\"([^\"]*)\"|([^ }]*))"));
1215                 QRegularExpression separatorRx(QStringLiteral(" separator=(?|\"([^\"]*)\"|([^ }]*))"));
1216                 QRegularExpressionMatch m = depthRx.match(lexeme);
1217                 if (m.hasMatch()) {
1218                     int depth = m.capturedRef(1).toInt();
1219                     if (depth <= 0)
1220                         error += QLatin1String("QT_MESSAGE_PATTERN: %{backtrace} depth must be a number greater than 0\n");
1221                     else
1222                         backtraceDepth = depth;
1223                 }
1224                 m = separatorRx.match(lexeme);
1225                 if (m.hasMatch())
1226                     backtraceSeparator = m.captured(1);
1227                 BacktraceParams backtraceParams;
1228                 backtraceParams.backtraceDepth = backtraceDepth;
1229                 backtraceParams.backtraceSeparator = backtraceSeparator;
1230                 backtraceArgs.append(backtraceParams);
1231 #else
1232                 error += QLatin1String("QT_MESSAGE_PATTERN: %{backtrace} is not supported by this Qt build\n");
1233                 tokens[i] = "";
1234 #endif
1235             }
1236 
1237 #define IF_TOKEN(LEVEL) \
1238             else if (lexeme == QLatin1String(LEVEL)) { \
1239                 if (inIf) \
1240                     nestedIfError = true; \
1241                 tokens[i] = LEVEL; \
1242                 inIf = true; \
1243             }
1244             IF_TOKEN(ifCategoryTokenC)
1245             IF_TOKEN(ifDebugTokenC)
1246             IF_TOKEN(ifInfoTokenC)
1247             IF_TOKEN(ifWarningTokenC)
1248             IF_TOKEN(ifCriticalTokenC)
1249             IF_TOKEN(ifFatalTokenC)
1250 #undef IF_TOKEN
1251             else if (lexeme == QLatin1String(endifTokenC)) {
1252                 tokens[i] = endifTokenC;
1253                 if (!inIf && !nestedIfError)
1254                     error += QLatin1String("QT_MESSAGE_PATTERN: %{endif} without an %{if-*}\n");
1255                 inIf = false;
1256             } else {
1257                 tokens[i] = emptyTokenC;
1258                 error += QStringLiteral("QT_MESSAGE_PATTERN: Unknown placeholder %1\n")
1259                         .arg(lexeme);
1260             }
1261         } else {
1262             char *literal = new char[lexeme.size() + 1];
1263             strncpy(literal, lexeme.toLatin1().constData(), lexeme.size());
1264             literal[lexeme.size()] = '\0';
1265             literalsVar.append(literal);
1266             tokens[i] = literal;
1267         }
1268     }
1269     if (nestedIfError)
1270         error += QLatin1String("QT_MESSAGE_PATTERN: %{if-*} cannot be nested\n");
1271     else if (inIf)
1272         error += QLatin1String("QT_MESSAGE_PATTERN: missing %{endif}\n");
1273 
1274     if (!error.isEmpty())
1275         qt_message_print(error);
1276 
1277     literals = new const char*[literalsVar.size() + 1];
1278     literals[literalsVar.size()] = 0;
1279     memcpy(literals, literalsVar.constData(), literalsVar.size() * sizeof(const char*));
1280 }
1281 
1282 #if defined(QLOGGING_HAVE_BACKTRACE) && !defined(QT_BOOTSTRAPPED)
1283 // make sure the function has "Message" in the name so the function is removed
1284 
1285 #if ((defined(Q_CC_GNU) && defined(QT_COMPILER_SUPPORTS_SIMD_ALWAYS)) || QT_HAS_ATTRIBUTE(optimize)) \
1286     && !defined(Q_CC_INTEL) && !defined(Q_CC_CLANG)
1287 // force skipping the frame pointer, to save the backtrace() function some work
1288 __attribute__((optimize("omit-frame-pointer")))
1289 #endif
1290 static QStringList backtraceFramesForLogMessage(int frameCount)
1291 {
1292     QStringList result;
1293     if (frameCount == 0)
1294         return result;
1295 
1296     // The results of backtrace_symbols looks like this:
1297     //    /lib/libc.so.6(__libc_start_main+0xf3) [0x4a937413]
1298     // The offset and function name are optional.
1299     // This regexp tries to extract the library name (without the path) and the function name.
1300     // This code is protected by QMessagePattern::mutex so it is thread safe on all compilers
1301     static QRegularExpression rx(QStringLiteral("^(?:[^(]*/)?([^(/]+)\\(([^+]*)(?:[\\+[a-f0-9x]*)?\\) \\[[a-f0-9x]*\\]$"),
1302                                  QRegularExpression::OptimizeOnFirstUsageOption);
1303 
1304     QVarLengthArray<void*, 32> buffer(8 + frameCount);
1305     int n = backtrace(buffer.data(), buffer.size());
1306     if (n > 0) {
1307         int numberPrinted = 0;
1308         for (int i = 0; i < n && numberPrinted < frameCount; ++i) {
1309             QScopedPointer<char*, QScopedPointerPodDeleter> strings(backtrace_symbols(buffer.data() + i, 1));
1310             QString trace = QString::fromLatin1(strings.data()[0]);
1311             QRegularExpressionMatch m = rx.match(trace);
1312             if (m.hasMatch()) {
1313                 QString library = m.captured(1);
1314                 QString function = m.captured(2);
1315 
1316                 // skip the trace from QtCore that are because of the qDebug itself
1317                 if (!numberPrinted && library.contains(QLatin1String("Qt5Core"))
1318                         && (function.isEmpty() || function.contains(QLatin1String("Message"), Qt::CaseInsensitive)
1319                             || function.contains(QLatin1String("QDebug")))) {
1320                     continue;
1321                 }
1322 
1323                 if (function.startsWith(QLatin1String("_Z"))) {
1324                     QScopedPointer<char, QScopedPointerPodDeleter> demangled(
1325                                 abi::__cxa_demangle(function.toUtf8(), 0, 0, 0));
1326                     if (demangled)
1327                         function = QString::fromUtf8(qCleanupFuncinfo(demangled.data()));
1328                 }
1329 
1330                 if (function.isEmpty()) {
1331                     result.append(QLatin1Char('?') + library + QLatin1Char('?'));
1332                 } else {
1333                     result.append(function);
1334                 }
1335             } else {
1336                 if (numberPrinted == 0) {
1337                     // innermost, unknown frames are usually the logging framework itself
1338                     continue;
1339                 }
1340                 result.append(QStringLiteral("???"));
1341             }
1342             numberPrinted++;
1343         }
1344     }
1345     return result;
1346 }
1347 
1348 static QString formatBacktraceForLogMessage(const QMessagePattern::BacktraceParams backtraceParams,
1349                                             const char *function)
1350 {
1351     QString backtraceSeparator = backtraceParams.backtraceSeparator;
1352     int backtraceDepth = backtraceParams.backtraceDepth;
1353 
1354     QStringList frames = backtraceFramesForLogMessage(backtraceDepth);
1355     if (frames.isEmpty())
1356         return QString();
1357 
1358     // if the first frame is unknown, replace it with the context function
1359     if (function && frames.at(0).startsWith(QLatin1Char('?')))
1360         frames[0] = QString::fromUtf8(qCleanupFuncinfo(function));
1361 
1362     return frames.join(backtraceSeparator);
1363 }
1364 #endif // QLOGGING_HAVE_BACKTRACE && !QT_BOOTSTRAPPED
1365 
1366 Q_GLOBAL_STATIC(QMessagePattern, qMessagePattern)
1367 
1368 /*!
1369     \relates <QtGlobal>
1370     \since 5.4
1371 
1372     Generates a formatted string out of the \a type, \a context, \a str arguments.
1373 
1374     qFormatLogMessage returns a QString that is formatted according to the current message pattern.
1375     It can be used by custom message handlers to format output similar to Qt's default message
1376     handler.
1377 
1378     The function is thread-safe.
1379 
1380     \sa qInstallMessageHandler(), qSetMessagePattern()
1381  */
1382 QString qFormatLogMessage(QtMsgType type, const QMessageLogContext &context, const QString &str)
1383 {
1384     QString message;
1385 
1386     QMutexLocker lock(&QMessagePattern::mutex);
1387 
1388     QMessagePattern *pattern = qMessagePattern();
1389     if (!pattern) {
1390         // after destruction of static QMessagePattern instance
1391         message.append(str);
1392         return message;
1393     }
1394 
1395     bool skip = false;
1396 
1397 #ifndef QT_BOOTSTRAPPED
1398     int timeArgsIdx = 0;
1399 #ifdef QLOGGING_HAVE_BACKTRACE
1400     int backtraceArgsIdx = 0;
1401 #endif
1402 #endif
1403 
1404     // we do not convert file, function, line literals to local encoding due to overhead
1405     for (int i = 0; pattern->tokens[i] != 0; ++i) {
1406         const char *token = pattern->tokens[i];
1407         if (token == endifTokenC) {
1408             skip = false;
1409         } else if (skip) {
1410             // we skip adding messages, but we have to iterate over
1411             // timeArgsIdx and backtraceArgsIdx anyway
1412 #ifndef QT_BOOTSTRAPPED
1413             if (token == timeTokenC)
1414                 timeArgsIdx++;
1415 #ifdef QLOGGING_HAVE_BACKTRACE
1416             else if (token == backtraceTokenC)
1417                 backtraceArgsIdx++;
1418 #endif
1419 #endif
1420         } else if (token == messageTokenC) {
1421             message.append(str);
1422         } else if (token == categoryTokenC) {
1423             message.append(QLatin1String(context.category));
1424         } else if (token == typeTokenC) {
1425             switch (type) {
1426             case QtDebugMsg:   message.append(QLatin1String("debug")); break;
1427             case QtInfoMsg:    message.append(QLatin1String("info")); break;
1428             case QtWarningMsg: message.append(QLatin1String("warning")); break;
1429             case QtCriticalMsg:message.append(QLatin1String("critical")); break;
1430             case QtFatalMsg:   message.append(QLatin1String("fatal")); break;
1431             }
1432         } else if (token == fileTokenC) {
1433             if (context.file)
1434                 message.append(QLatin1String(context.file));
1435             else
1436                 message.append(QLatin1String("unknown"));
1437         } else if (token == lineTokenC) {
1438             message.append(QString::number(context.line));
1439         } else if (token == functionTokenC) {
1440             if (context.function)
1441                 message.append(QString::fromLatin1(qCleanupFuncinfo(context.function)));
1442             else
1443                 message.append(QLatin1String("unknown"));
1444 #ifndef QT_BOOTSTRAPPED
1445         } else if (token == pidTokenC) {
1446             message.append(QString::number(QCoreApplication::applicationPid()));
1447         } else if (token == appnameTokenC) {
1448             message.append(QCoreApplication::applicationName());
1449         } else if (token == threadidTokenC) {
1450             // print the TID as decimal
1451             message.append(QString::number(qt_gettid()));
1452         } else if (token == qthreadptrTokenC) {
1453             message.append(QLatin1String("0x"));
1454             message.append(QString::number(qlonglong(QThread::currentThread()->currentThread()), 16));
1455 #ifdef QLOGGING_HAVE_BACKTRACE
1456         } else if (token == backtraceTokenC) {
1457             QMessagePattern::BacktraceParams backtraceParams = pattern->backtraceArgs.at(backtraceArgsIdx);
1458             backtraceArgsIdx++;
1459             message.append(formatBacktraceForLogMessage(backtraceParams, context.function));
1460 #endif
1461         } else if (token == timeTokenC) {
1462             QString timeFormat = pattern->timeArgs.at(timeArgsIdx);
1463             timeArgsIdx++;
1464             if (timeFormat == QLatin1String("process")) {
1465                     quint64 ms = pattern->timer.elapsed();
1466                     message.append(QString::asprintf("%6d.%03d", uint(ms / 1000), uint(ms % 1000)));
1467             } else if (timeFormat ==  QLatin1String("boot")) {
1468                 // just print the milliseconds since the elapsed timer reference
1469                 // like the Linux kernel does
1470                 QElapsedTimer now;
1471                 now.start();
1472                 uint ms = now.msecsSinceReference();
1473                 message.append(QString::asprintf("%6d.%03d", uint(ms / 1000), uint(ms % 1000)));
1474 #if QT_CONFIG(datestring)
1475             } else if (timeFormat.isEmpty()) {
1476                     message.append(QDateTime::currentDateTime().toString(Qt::ISODate));
1477             } else {
1478                 message.append(QDateTime::currentDateTime().toString(timeFormat));
1479 #endif // QT_CONFIG(datestring)
1480             }
1481 #endif // !QT_BOOTSTRAPPED
1482         } else if (token == ifCategoryTokenC) {
1483             if (isDefaultCategory(context.category))
1484                 skip = true;
1485 #define HANDLE_IF_TOKEN(LEVEL)  \
1486         } else if (token == if##LEVEL##TokenC) { \
1487             skip = type != Qt##LEVEL##Msg;
1488         HANDLE_IF_TOKEN(Debug)
1489         HANDLE_IF_TOKEN(Info)
1490         HANDLE_IF_TOKEN(Warning)
1491         HANDLE_IF_TOKEN(Critical)
1492         HANDLE_IF_TOKEN(Fatal)
1493 #undef HANDLE_IF_TOKEN
1494         } else {
1495             message.append(QLatin1String(token));
1496         }
1497     }
1498     return message;
1499 }
1500 
1501 #if !QT_DEPRECATED_SINCE(5, 0)
1502 // make sure they're defined to be exported
1503 typedef void (*QtMsgHandler)(QtMsgType, const char *);
1504 Q_CORE_EXPORT QtMsgHandler qInstallMsgHandler(QtMsgHandler);
1505 #endif
1506 
1507 static void qDefaultMsgHandler(QtMsgType type, const char *buf);
1508 static void qDefaultMessageHandler(QtMsgType type, const QMessageLogContext &context, const QString &buf);
1509 
1510 // pointer to QtMsgHandler debug handler (without context)
1511 static QBasicAtomicPointer<void (QtMsgType, const char*)> msgHandler = Q_BASIC_ATOMIC_INITIALIZER(qDefaultMsgHandler);
1512 // pointer to QtMessageHandler debug handler (with context)
1513 static QBasicAtomicPointer<void (QtMsgType, const QMessageLogContext &, const QString &)> messageHandler = Q_BASIC_ATOMIC_INITIALIZER(qDefaultMessageHandler);
1514 
1515 // ------------------------ Alternate logging sinks -------------------------
1516 
1517 #if defined(QT_BOOTSTRAPPED)
1518     // Boostrapped tools always print to stderr, so no need for alternate sinks
1519 #else
1520 
1521 #if QT_CONFIG(slog2)
1522 #ifndef QT_LOG_CODE
1523 #define QT_LOG_CODE 9000
1524 #endif
1525 
1526 static bool slog2_default_handler(QtMsgType type, const QMessageLogContext &context, const QString &message)
1527 {
1528     if (shouldLogToStderr())
1529         return false; // Leave logging up to stderr handler
1530 
1531     QString formattedMessage = qFormatLogMessage(type, context, message);
1532     formattedMessage.append(QLatin1Char('\n'));
1533     if (slog2_set_default_buffer((slog2_buffer_t)-1) == 0) {
1534         slog2_buffer_set_config_t buffer_config;
1535         slog2_buffer_t buffer_handle;
1536 
1537         buffer_config.buffer_set_name = __progname;
1538         buffer_config.num_buffers = 1;
1539         buffer_config.verbosity_level = SLOG2_DEBUG1;
1540         buffer_config.buffer_config[0].buffer_name = "default";
1541         buffer_config.buffer_config[0].num_pages = 8;
1542 
1543         if (slog2_register(&buffer_config, &buffer_handle, 0) == -1) {
1544             fprintf(stderr, "Error registering slogger2 buffer!\n");
1545             fprintf(stderr, "%s", formattedMessage.toLocal8Bit().constData());
1546             fflush(stderr);
1547             return false;
1548         }
1549 
1550         // Set as the default buffer
1551         slog2_set_default_buffer(buffer_handle);
1552     }
1553     int severity;
1554     //Determines the severity level
1555     switch (type) {
1556     case QtDebugMsg:
1557         severity = SLOG2_DEBUG1;
1558         break;
1559     case QtInfoMsg:
1560         severity = SLOG2_INFO;
1561         break;
1562     case QtWarningMsg:
1563         severity = SLOG2_NOTICE;
1564         break;
1565     case QtCriticalMsg:
1566         severity = SLOG2_WARNING;
1567         break;
1568     case QtFatalMsg:
1569         severity = SLOG2_ERROR;
1570         break;
1571     }
1572     //writes to the slog2 buffer
1573     slog2c(NULL, QT_LOG_CODE, severity, formattedMessage.toLocal8Bit().constData());
1574 
1575     return true; // Prevent further output to stderr
1576 }
1577 #endif // slog2
1578 
1579 #if QT_CONFIG(journald)
1580 static bool systemd_default_message_handler(QtMsgType type,
1581                                             const QMessageLogContext &context,
1582                                             const QString &message)
1583 {
1584     if (shouldLogToStderr())
1585         return false; // Leave logging up to stderr handler
1586 
1587     QString formattedMessage = qFormatLogMessage(type, context, message);
1588 
1589     int priority = LOG_INFO; // Informational
1590     switch (type) {
1591     case QtDebugMsg:
1592         priority = LOG_DEBUG; // Debug-level messages
1593         break;
1594     case QtInfoMsg:
1595         priority = LOG_INFO; // Informational conditions
1596         break;
1597     case QtWarningMsg:
1598         priority = LOG_WARNING; // Warning conditions
1599         break;
1600     case QtCriticalMsg:
1601         priority = LOG_CRIT; // Critical conditions
1602         break;
1603     case QtFatalMsg:
1604         priority = LOG_ALERT; // Action must be taken immediately
1605         break;
1606     }
1607 
1608     sd_journal_send("MESSAGE=%s",     formattedMessage.toUtf8().constData(),
1609                     "PRIORITY=%i",    priority,
1610                     "CODE_FUNC=%s",   context.function ? context.function : "unknown",
1611                     "CODE_LINE=%d",   context.line,
1612                     "CODE_FILE=%s",   context.file ? context.file : "unknown",
1613                     "QT_CATEGORY=%s", context.category ? context.category : "unknown",
1614                     NULL);
1615 
1616     return true; // Prevent further output to stderr
1617 }
1618 #endif
1619 
1620 #if QT_CONFIG(syslog)
1621 static bool syslog_default_message_handler(QtMsgType type, const QMessageLogContext &context, const QString &message)
1622 {
1623     if (shouldLogToStderr())
1624         return false; // Leave logging up to stderr handler
1625 
1626     QString formattedMessage = qFormatLogMessage(type, context, message);
1627 
1628     int priority = LOG_INFO; // Informational
1629     switch (type) {
1630     case QtDebugMsg:
1631         priority = LOG_DEBUG; // Debug-level messages
1632         break;
1633     case QtInfoMsg:
1634         priority = LOG_INFO; // Informational conditions
1635         break;
1636     case QtWarningMsg:
1637         priority = LOG_WARNING; // Warning conditions
1638         break;
1639     case QtCriticalMsg:
1640         priority = LOG_CRIT; // Critical conditions
1641         break;
1642     case QtFatalMsg:
1643         priority = LOG_ALERT; // Action must be taken immediately
1644         break;
1645     }
1646 
1647     syslog(priority, "%s", formattedMessage.toUtf8().constData());
1648 
1649     return true; // Prevent further output to stderr
1650 }
1651 #endif
1652 
1653 #if defined(Q_OS_ANDROID) && !defined(Q_OS_ANDROID_EMBEDDED)
1654 static bool android_default_message_handler(QtMsgType type,
1655                                   const QMessageLogContext &context,
1656                                   const QString &message)
1657 {
1658     if (shouldLogToStderr())
1659         return false; // Leave logging up to stderr handler
1660 
1661     QString formattedMessage = qFormatLogMessage(type, context, message);
1662 
1663     android_LogPriority priority = ANDROID_LOG_DEBUG;
1664     switch (type) {
1665     case QtDebugMsg: priority = ANDROID_LOG_DEBUG; break;
1666     case QtInfoMsg: priority = ANDROID_LOG_INFO; break;
1667     case QtWarningMsg: priority = ANDROID_LOG_WARN; break;
1668     case QtCriticalMsg: priority = ANDROID_LOG_ERROR; break;
1669     case QtFatalMsg: priority = ANDROID_LOG_FATAL; break;
1670     };
1671 
1672     __android_log_print(priority, "Qt", qPrintable(formattedMessage));
1673 
1674     return true; // Prevent further output to stderr
1675 }
1676 #endif //Q_OS_ANDROID
1677 
1678 #ifdef Q_OS_WIN
1679 static bool win_message_handler(QtMsgType type, const QMessageLogContext &context, const QString &message)
1680 {
1681     if (shouldLogToStderr())
1682         return false; // Leave logging up to stderr handler
1683 
1684     QString formattedMessage = qFormatLogMessage(type, context, message);
1685     formattedMessage.append(QLatin1Char('\n'));
1686     OutputDebugString(reinterpret_cast<const wchar_t *>(formattedMessage.utf16()));
1687 
1688     return true; // Prevent further output to stderr
1689 }
1690 #endif
1691 
1692 #endif // Bootstrap check
1693 
1694 // --------------------------------------------------------------------------
1695 
1696 static void stderr_message_handler(QtMsgType type, const QMessageLogContext &context, const QString &message)
1697 {
1698     QString formattedMessage = qFormatLogMessage(type, context, message);
1699 
1700     // print nothing if message pattern didn't apply / was empty.
1701     // (still print empty lines, e.g. because message itself was empty)
1702     if (formattedMessage.isNull())
1703         return;
1704 
1705     fprintf(stderr, "%s\n", formattedMessage.toLocal8Bit().constData());
1706     fflush(stderr);
1707 }
1708 
1709 /*!
1710     \internal
1711 */
1712 static void qDefaultMessageHandler(QtMsgType type, const QMessageLogContext &context,
1713                                    const QString &message)
1714 {
1715     bool handledStderr = false;
1716 
1717     // A message sink logs the message to a structured or unstructured destination,
1718     // optionally formatting the message if the latter, and returns true if the sink
1719     // handled stderr output as well, which will shortcut our default stderr output.
1720     // In the future, if we allow multiple/dynamic sinks, this will be iterating
1721     // a list of sinks.
1722 
1723 #if !defined(QT_BOOTSTRAPPED)
1724 # if defined(Q_OS_WIN)
1725     handledStderr |= win_message_handler(type, context, message);
1726 # elif QT_CONFIG(slog2)
1727     handledStderr |= slog2_default_handler(type, context, message);
1728 # elif QT_CONFIG(journald)
1729     handledStderr |= systemd_default_message_handler(type, context, message);
1730 # elif QT_CONFIG(syslog)
1731     handledStderr |= syslog_default_message_handler(type, context, message);
1732 # elif defined(Q_OS_ANDROID) && !defined(Q_OS_ANDROID_EMBEDDED)
1733     handledStderr |= android_default_message_handler(type, context, message);
1734 # elif defined(QT_USE_APPLE_UNIFIED_LOGGING)
1735     if (__builtin_available(macOS 10.12, iOS 10, tvOS 10, watchOS 3, *))
1736         handledStderr |= AppleUnifiedLogger::messageHandler(type, context, message);
1737 # endif
1738 #endif
1739 
1740     if (!handledStderr)
1741         stderr_message_handler(type, context, message);
1742 }
1743 
1744 /*!
1745     \internal
1746 */
1747 static void qDefaultMsgHandler(QtMsgType type, const char *buf)
1748 {
1749     QMessageLogContext emptyContext;
1750     qDefaultMessageHandler(type, emptyContext, QString::fromLocal8Bit(buf));
1751 }
1752 
1753 #if defined(Q_COMPILER_THREAD_LOCAL)
1754 
1755 static thread_local bool msgHandlerGrabbed = false;
1756 
1757 static bool grabMessageHandler()
1758 {
1759     if (msgHandlerGrabbed)
1760         return false;
1761 
1762     msgHandlerGrabbed = true;
1763     return true;
1764 }
1765 
1766 static void ungrabMessageHandler()
1767 {
1768     msgHandlerGrabbed = false;
1769 }
1770 
1771 #else
1772 static bool grabMessageHandler() { return true; }
1773 static void ungrabMessageHandler() { }
1774 #endif // (Q_COMPILER_THREAD_LOCAL)
1775 
1776 static void qt_message_print(QtMsgType msgType, const QMessageLogContext &context, const QString &message)
1777 {
1778 #ifndef QT_BOOTSTRAPPED
1779     // qDebug, qWarning, ... macros do not check whether category is enabled
1780     if (isDefaultCategory(context.category)) {
1781         if (QLoggingCategory *defaultCategory = QLoggingCategory::defaultCategory()) {
1782             if (!defaultCategory->isEnabled(msgType))
1783                 return;
1784         }
1785     }
1786 #endif
1787 
1788     // prevent recursion in case the message handler generates messages
1789     // itself, e.g. by using Qt API
1790     if (grabMessageHandler()) {
1791         // prefer new message handler over the old one
1792         if (msgHandler.load() == qDefaultMsgHandler
1793                 || messageHandler.load() != qDefaultMessageHandler) {
1794             (*messageHandler.load())(msgType, context, message);
1795         } else {
1796             (*msgHandler.load())(msgType, message.toLocal8Bit().constData());
1797         }
1798         ungrabMessageHandler();
1799     } else {
1800         fprintf(stderr, "%s\n", message.toLocal8Bit().constData());
1801     }
1802 }
1803 
1804 static void qt_message_print(const QString &message)
1805 {
1806 #if defined(Q_OS_WINRT)
1807     OutputDebugString(reinterpret_cast<const wchar_t*>(message.utf16()));
1808     return;
1809 #elif defined(Q_OS_WIN) && !defined(QT_BOOTSTRAPPED)
1810     if (!shouldLogToStderr()) {
1811         OutputDebugString(reinterpret_cast<const wchar_t*>(message.utf16()));
1812         return;
1813     }
1814 #endif
1815     fprintf(stderr, "%s", message.toLocal8Bit().constData());
1816     fflush(stderr);
1817 }
1818 
1819 static void qt_message_fatal(QtMsgType, const QMessageLogContext &context, const QString &message)
1820 {
1821 #if defined(Q_CC_MSVC) && defined(QT_DEBUG) && defined(_DEBUG) && defined(_CRT_ERROR)
1822     wchar_t contextFileL[256];
1823     // we probably should let the compiler do this for us, by declaring QMessageLogContext::file to
1824     // be const wchar_t * in the first place, but the #ifdefery above is very complex  and we
1825     // wouldn't be able to change it later on...
1826     convert_to_wchar_t_elided(contextFileL, sizeof contextFileL / sizeof *contextFileL,
1827                               context.file);
1828     // get the current report mode
1829     int reportMode = _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW);
1830     _CrtSetReportMode(_CRT_ERROR, reportMode);
1831 
1832     int ret = _CrtDbgReportW(_CRT_ERROR, contextFileL, context.line, _CRT_WIDE(QT_VERSION_STR),
1833                              reinterpret_cast<const wchar_t *>(message.utf16()));
1834     if ((ret == 0) && (reportMode & _CRTDBG_MODE_WNDW))
1835         return; // ignore
1836     else if (ret == 1)
1837         _CrtDbgBreak();
1838 #else
1839     Q_UNUSED(context);
1840     Q_UNUSED(message);
1841 #endif
1842 
1843 #ifdef Q_OS_WIN
1844     // std::abort() in the MSVC runtime will call _exit(3) if the abort
1845     // behavior is _WRITE_ABORT_MSG - see also _set_abort_behavior(). This is
1846     // the default for a debug-mode build of the runtime. Worse, MinGW's
1847     // std::abort() implementation (in msvcrt.dll) is basically a call to
1848     // _exit(3) too. Unfortunately, _exit() and _Exit() *do* run the static
1849     // destructors of objects in DLLs, a violation of the C++ standard (see
1850     // [support.start.term]). So we bypass std::abort() and directly
1851     // terminate the application.
1852 
1853 #  ifdef Q_CC_MSVC
1854     if (IsProcessorFeaturePresent(PF_FASTFAIL_AVAILABLE))
1855         __fastfail(FAST_FAIL_FATAL_APP_EXIT);
1856 #  else
1857     RaiseFailFastException(nullptr, nullptr, 0);
1858 #  endif
1859 
1860     // Fallback
1861     TerminateProcess(GetCurrentProcess(), STATUS_FATAL_APP_EXIT);
1862 
1863     // Tell the compiler the application has stopped.
1864     Q_UNREACHABLE_IMPL();
1865 #else // !Q_OS_WIN
1866     std::abort();
1867 #endif
1868 }
1869 
1870 
1871 /*!
1872     \internal
1873 */
1874 void qt_message_output(QtMsgType msgType, const QMessageLogContext &context, const QString &message)
1875 {
1876     qt_message_print(msgType, context, message);
1877     if (isFatal(msgType))
1878         qt_message_fatal(msgType, context, message);
1879 }
1880 
1881 void qErrnoWarning(const char *msg, ...)
1882 {
1883     // qt_error_string() will allocate anyway, so we don't have
1884     // to be careful here (like we do in plain qWarning())
1885     va_list ap;
1886     va_start(ap, msg);
1887     QString buf = QString::vasprintf(msg, ap);
1888     va_end(ap);
1889 
1890     buf += QLatin1String(" (") + qt_error_string(-1) + QLatin1Char(')');
1891     QMessageLogContext context;
1892     qt_message_output(QtCriticalMsg, context, buf);
1893 }
1894 
1895 void qErrnoWarning(int code, const char *msg, ...)
1896 {
1897     // qt_error_string() will allocate anyway, so we don't have
1898     // to be careful here (like we do in plain qWarning())
1899     va_list ap;
1900     va_start(ap, msg);
1901     QString buf = QString::vasprintf(msg, ap);
1902     va_end(ap);
1903 
1904     buf += QLatin1String(" (") + qt_error_string(code) + QLatin1Char(')');
1905     QMessageLogContext context;
1906     qt_message_output(QtCriticalMsg, context, buf);
1907 }
1908 
1909 /*!
1910     \typedef QtMsgHandler
1911     \relates <QtGlobal>
1912     \deprecated
1913 
1914     This is a typedef for a pointer to a function with the following
1915     signature:
1916 
1917     \snippet code/src_corelib_global_qglobal.cpp 7
1918 
1919     This typedef is deprecated, you should use QtMessageHandler instead.
1920     \sa QtMsgType, QtMessageHandler, qInstallMsgHandler(), qInstallMessageHandler()
1921 */
1922 
1923 /*!
1924     \typedef QtMessageHandler
1925     \relates <QtGlobal>
1926     \since 5.0
1927 
1928     This is a typedef for a pointer to a function with the following
1929     signature:
1930 
1931     \snippet code/src_corelib_global_qglobal.cpp 49
1932 
1933     \sa QtMsgType, qInstallMessageHandler()
1934 */
1935 
1936 /*!
1937     \fn QtMessageHandler qInstallMessageHandler(QtMessageHandler handler)
1938     \relates <QtGlobal>
1939     \since 5.0
1940 
1941     Installs a Qt message \a handler which has been defined
1942     previously. Returns a pointer to the previous message handler.
1943 
1944     The message handler is a function that prints out debug messages,
1945     warnings, critical and fatal error messages. The Qt library (debug
1946     mode) contains hundreds of warning messages that are printed
1947     when internal errors (usually invalid function arguments)
1948     occur. Qt built in release mode also contains such warnings unless
1949     QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during
1950     compilation. If you implement your own message handler, you get total
1951     control of these messages.
1952 
1953     The default message handler prints the message to the standard
1954     output under X11 or to the debugger under Windows. If it is a
1955     fatal message, the application aborts immediately.
1956 
1957     Only one message handler can be defined, since this is usually
1958     done on an application-wide basis to control debug output.
1959 
1960     To restore the message handler, call \c qInstallMessageHandler(0).
1961 
1962     Example:
1963 
1964     \snippet code/src_corelib_global_qglobal.cpp 23
1965 
1966     \sa QtMessageHandler, QtMsgType, qDebug(), qInfo(), qWarning(), qCritical(), qFatal(),
1967     {Debugging Techniques}
1968 */
1969 
1970 /*!
1971     \fn QtMsgHandler qInstallMsgHandler(QtMsgHandler handler)
1972     \relates <QtGlobal>
1973     \deprecated
1974 
1975     Installs a Qt message \a handler which has been defined
1976     previously. This method is deprecated, use qInstallMessageHandler
1977     instead.
1978     \sa QtMsgHandler, qInstallMessageHandler()
1979 */
1980 /*!
1981     \fn void qSetMessagePattern(const QString &pattern)
1982     \relates <QtGlobal>
1983     \since 5.0
1984 
1985     \brief Changes the output of the default message handler.
1986 
1987     Allows to tweak the output of qDebug(), qInfo(), qWarning(), qCritical(),
1988     and qFatal(). The category logging output of qCDebug(), qCInfo(),
1989     qCWarning(), and qCCritical() is formatted, too.
1990 
1991     Following placeholders are supported:
1992 
1993     \table
1994     \header \li Placeholder \li Description
1995     \row \li \c %{appname} \li QCoreApplication::applicationName()
1996     \row \li \c %{category} \li Logging category
1997     \row \li \c %{file} \li Path to source file
1998     \row \li \c %{function} \li Function
1999     \row \li \c %{line} \li Line in source file
2000     \row \li \c %{message} \li The actual message
2001     \row \li \c %{pid} \li QCoreApplication::applicationPid()
2002     \row \li \c %{threadid} \li The system-wide ID of current thread (if it can be obtained)
2003     \row \li \c %{qthreadptr} \li A pointer to the current QThread (result of QThread::currentThread())
2004     \row \li \c %{type} \li "debug", "warning", "critical" or "fatal"
2005     \row \li \c %{time process} \li time of the message, in seconds since the process started (the token "process" is literal)
2006     \row \li \c %{time boot} \li the time of the message, in seconds since the system boot if that
2007         can be determined (the token "boot" is literal). If the time since boot could not be obtained,
2008         the output is indeterminate (see QElapsedTimer::msecsSinceReference()).
2009     \row \li \c %{time [format]} \li system time when the message occurred, formatted by
2010         passing the \c format to \l QDateTime::toString(). If the format is
2011         not specified, the format of Qt::ISODate is used.
2012     \row \li \c{%{backtrace [depth=N] [separator="..."]}} \li A backtrace with the number of frames
2013         specified by the optional \c depth parameter (defaults to 5), and separated by the optional
2014         \c separator parameter (defaults to "|").
2015         This expansion is available only on some platforms (currently only platfoms using glibc).
2016         Names are only known for exported functions. If you want to see the name of every function
2017         in your application, use \c{QMAKE_LFLAGS += -rdynamic}.
2018         When reading backtraces, take into account that frames might be missing due to inlining or
2019         tail call optimization.
2020     \endtable
2021 
2022     You can also use conditionals on the type of the message using \c %{if-debug}, \c %{if-info}
2023     \c %{if-warning}, \c %{if-critical} or \c %{if-fatal} followed by an \c %{endif}.
2024     What is inside the \c %{if-*} and \c %{endif} will only be printed if the type matches.
2025 
2026     Finally, text inside \c %{if-category} ... \c %{endif} is only printed if the category
2027     is not the default one.
2028 
2029     Example:
2030     \code
2031     QT_MESSAGE_PATTERN="[%{time yyyyMMdd h:mm:ss.zzz t} %{if-debug}D%{endif}%{if-info}I%{endif}%{if-warning}W%{endif}%{if-critical}C%{endif}%{if-fatal}F%{endif}] %{file}:%{line} - %{message}"
2032     \endcode
2033 
2034     The default \a pattern is "%{if-category}%{category}: %{endif}%{message}".
2035 
2036     The \a pattern can also be changed at runtime by setting the QT_MESSAGE_PATTERN
2037     environment variable; if both \l qSetMessagePattern() is called and QT_MESSAGE_PATTERN is
2038     set, the environment variable takes precedence.
2039 
2040     \note The message pattern only applies to unstructured logging, such as the default
2041     \c stderr output. Structured logging such as systemd will record the message as is,
2042     along with as much structured information as can be captured.
2043 
2044     Custom message handlers can use qFormatLogMessage() to take \a pattern into account.
2045 
2046     \sa qInstallMessageHandler(), {Debugging Techniques}, {QLoggingCategory}
2047  */
2048 
2049 QtMessageHandler qInstallMessageHandler(QtMessageHandler h)
2050 {
2051     if (!h)
2052         h = qDefaultMessageHandler;
2053     //set 'h' and return old message handler
2054     return messageHandler.fetchAndStoreRelaxed(h);
2055 }
2056 
2057 QtMsgHandler qInstallMsgHandler(QtMsgHandler h)
2058 {
2059     if (!h)
2060         h = qDefaultMsgHandler;
2061     //set 'h' and return old message handler
2062     return msgHandler.fetchAndStoreRelaxed(h);
2063 }
2064 
2065 void qSetMessagePattern(const QString &pattern)
2066 {
2067     QMutexLocker lock(&QMessagePattern::mutex);
2068 
2069     if (!qMessagePattern()->fromEnvironment)
2070         qMessagePattern()->setPattern(pattern);
2071 }
2072 
2073 
2074 /*!
2075     Copies context information from \a logContext into this QMessageLogContext
2076     \internal
2077 */
2078 void QMessageLogContext::copy(const QMessageLogContext &logContext)
2079 {
2080     this->category = logContext.category;
2081     this->file = logContext.file;
2082     this->line = logContext.line;
2083     this->function = logContext.function;
2084 }
2085 
2086 /*!
2087     \fn QMessageLogger::QMessageLogger()
2088 
2089     Constructs a default QMessageLogger. See the other constructors to specify
2090     context information.
2091 */
2092 
2093 /*!
2094     \fn QMessageLogger::QMessageLogger(const char *file, int line, const char *function)
2095 
2096     Constructs a QMessageLogger to record log messages for \a file at \a line
2097     in \a function. The is equivalent to QMessageLogger(file, line, function, "default")
2098 */
2099 /*!
2100     \fn QMessageLogger::QMessageLogger(const char *file, int line, const char *function, const char *category)
2101 
2102     Constructs a QMessageLogger to record \a category messages for \a file at \a line
2103     in \a function.
2104 */
2105 
2106 /*!
2107     \fn void QMessageLogger::noDebug(const char *, ...) const
2108     \internal
2109 
2110     Ignores logging output
2111 
2112     \sa QNoDebug, qDebug()
2113 */
2114 
2115 /*!
2116     \fn QMessageLogContext::QMessageLogContext()
2117     \internal
2118 
2119     Constructs a QMessageLogContext
2120 */
2121 
2122 /*!
2123     \fn QMessageLogContext::QMessageLogContext(const char *fileName, int lineNumber, const char *functionName, const char *categoryName)
2124     \internal
2125 
2126     Constructs a QMessageLogContext with for file \a fileName at line
2127     \a lineNumber, in function \a functionName, and category \a categoryName.
2128 */
2129 
2130 QT_END_NAMESPACE
