I want you to act as a code reviewer of Qt Creator in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "gitplugin.h"
27 
28 #include "changeselectiondialog.h"
29 #include "commitdata.h"
30 #include "gitclient.h"
31 #include "gitconstants.h"
32 #include "giteditor.h"
33 #include "gitsubmiteditor.h"
34 #include "gitversioncontrol.h"
35 #include "branchdialog.h"
36 #include "remotedialog.h"
37 #include "stashdialog.h"
38 #include "settingspage.h"
39 #include "logchangedialog.h"
40 #include "mergetool.h"
41 #include "gitutils.h"
42 #include "gitgrep.h"
43 
44 #include "gerrit/gerritplugin.h"
45 
46 #include <coreplugin/icore.h>
47 #include <coreplugin/coreconstants.h>
48 #include <coreplugin/documentmanager.h>
49 #include <coreplugin/actionmanager/actionmanager.h>
50 #include <coreplugin/actionmanager/actioncontainer.h>
51 #include <coreplugin/actionmanager/command.h>
52 #include <coreplugin/id.h>
53 #include <coreplugin/idocument.h>
54 #include <coreplugin/infobar.h>
55 #include <coreplugin/editormanager/editormanager.h>
56 #include <coreplugin/editormanager/ieditor.h>
57 #include <coreplugin/locator/commandlocator.h>
58 #include <coreplugin/vcsmanager.h>
59 
60 #include <coreplugin/messagebox.h>
61 #include <utils/asconst.h>
62 #include <utils/qtcassert.h>
63 #include <utils/parameteraction.h>
64 #include <utils/pathchooser.h>
65 #include <utils/utilsicons.h>
66 #include <texteditor/texteditor.h>
67 
68 #include <vcsbase/basevcseditorfactory.h>
69 #include <vcsbase/submitfilemodel.h>
70 #include <vcsbase/vcsbaseeditor.h>
71 #include <vcsbase/vcsbaseconstants.h>
72 #include <vcsbase/basevcssubmiteditorfactory.h>
73 #include <vcsbase/vcsoutputwindow.h>
74 #include <vcsbase/cleandialog.h>
75 
76 #include <QDebug>
77 #include <QDir>
78 #include <QFileInfo>
79 #include <QtPlugin>
80 
81 #include <QAction>
82 #include <QFileDialog>
83 #include <QMenu>
84 #include <QScopedPointer>
85 
86 #ifdef WITH_TESTS
87 #include <QTest>
88 #endif
89 
90 Q_DECLARE_METATYPE(Git::Internal::FileStates)
91 
92 using namespace Core;
93 using namespace TextEditor;
94 using namespace Utils;
95 using namespace VcsBase;
96 
97 namespace Git {
98 namespace Internal {
99 
100 const unsigned minimumRequiredVersion = 0x010900;
101 
102 const VcsBaseEditorParameters editorParameters[] = {
103 {
104     OtherContent,
105     Git::Constants::GIT_COMMAND_LOG_EDITOR_ID,
106     Git::Constants::GIT_COMMAND_LOG_EDITOR_DISPLAY_NAME,
107     "text/vnd.qtcreator.git.commandlog"},
108 {   LogOutput,
109     Git::Constants::GIT_LOG_EDITOR_ID,
110     Git::Constants::GIT_LOG_EDITOR_DISPLAY_NAME,
111     "text/vnd.qtcreator.git.log"},
112 {   AnnotateOutput,
113     Git::Constants::GIT_BLAME_EDITOR_ID,
114     Git::Constants::GIT_BLAME_EDITOR_DISPLAY_NAME,
115     "text/vnd.qtcreator.git.annotation"},
116 {   OtherContent,
117     Git::Constants::GIT_COMMIT_TEXT_EDITOR_ID,
118     Git::Constants::GIT_COMMIT_TEXT_EDITOR_DISPLAY_NAME,
119     "text/vnd.qtcreator.git.commit"},
120 {   OtherContent,
121     Git::Constants::GIT_REBASE_EDITOR_ID,
122     Git::Constants::GIT_REBASE_EDITOR_DISPLAY_NAME,
123     "text/vnd.qtcreator.git.rebase"},
124 };
125 
126 
127 // GitPlugin
128 
129 static GitPlugin *m_instance = 0;
130 
131 GitPlugin::GitPlugin()
132 {
133     m_instance = this;
134     m_fileActions.reserve(10);
135     m_projectActions.reserve(10);
136     m_repositoryActions.reserve(50);
137 }
138 
139 GitPlugin::~GitPlugin()
140 {
141     cleanCommitMessageFile();
142     delete m_gitClient;
143     m_instance = 0;
144 }
145 
146 void GitPlugin::cleanCommitMessageFile()
147 {
148     if (!m_commitMessageFileName.isEmpty()) {
149         QFile::remove(m_commitMessageFileName);
150         m_commitMessageFileName.clear();
151     }
152 }
153 
154 bool GitPlugin::isCommitEditorOpen() const
155 {
156     return !m_commitMessageFileName.isEmpty();
157 }
158 
159 GitPlugin *GitPlugin::instance()
160 {
161     return m_instance;
162 }
163 
164 GitClient *GitPlugin::client()
165 {
166     return m_instance->m_gitClient;
167 }
168 
169 QString GitPlugin::msgRepositoryLabel(const QString &repository)
170 {
171     return repository.isEmpty() ?
172             tr("<No repository>")  :
173             tr("Repository: %1").arg(QDir::toNativeSeparators(repository));
174 }
175 
176 // Returns a regular expression pattern with characters not allowed
177 // in branch and remote names.
178 QString GitPlugin::invalidBranchAndRemoteNamePattern()
179 {
180     return QLatin1String(
181         "\\s"     // no whitespace
182         "|~"      // no "~"
183         "|\\^"    // no "^"
184         "|\\["    // no "["
185         "|\\.\\." // no ".."
186         "|/\\."   // no slashdot
187         "|:"      // no ":"
188         "|@\\{"   // no "@{" sequence
189         "|\\\\"   // no backslash
190         "|//"     // no double slash
191         "|^[/-]"  // no leading slash or dash
192         "|\""     // no quotes
193         "|\\*"    // no asterisk
194     );
195 }
196 
197 const VcsBaseSubmitEditorParameters submitParameters = {
198     Git::Constants::SUBMIT_MIMETYPE,
199     Git::Constants::GITSUBMITEDITOR_ID,
200     Git::Constants::GITSUBMITEDITOR_DISPLAY_NAME,
201     VcsBaseSubmitEditorParameters::DiffRows
202 };
203 
204 Command *GitPlugin::createCommand(QAction *action, ActionContainer *ac, Id id,
205                                   const Context &context, bool addToLocator,
206                                   const std::function<void()> &callback, const QKeySequence &keys)
207 {
208     Command *command = ActionManager::registerAction(action, id, context);
209     if (!keys.isEmpty())
210         command->setDefaultKeySequence(keys);
211     if (ac)
212         ac->addAction(command);
213     if (addToLocator)
214         m_commandLocator->appendCommand(command);
215     connect(action, &QAction::triggered, this, callback);
216     return command;
217 }
218 
219 // Create a parameter action
220 ParameterAction *GitPlugin::createParameterAction(ActionContainer *ac,
221                                                   const QString &defaultText, const QString &parameterText,
222                                                   Id id, const Context &context,
223                                                   bool addToLocator, const std::function<void()> &callback,
224                                                   const QKeySequence &keys)
225 {
226     auto action = new ParameterAction(defaultText, parameterText, ParameterAction::EnabledWithParameter, this);
227     Command *command = createCommand(action, ac, id, context, addToLocator, callback, keys);
228     command->setAttribute(Command::CA_UpdateText);
229     return action;
230 }
231 
232 // Create an action to act on a file.
233 QAction *GitPlugin::createFileAction(ActionContainer *ac,
234                                      const QString &defaultText, const QString &parameterText,
235                                      Id id, const Context &context, bool addToLocator,
236                                      const std::function<void()> &callback,
237                                      const QKeySequence &keys)
238 {
239     ParameterAction *action = createParameterAction(ac, defaultText, parameterText, id, context,
240                                                     addToLocator, callback, keys);
241     m_fileActions.push_back(action);
242     return action;
243 }
244 
245 QAction *GitPlugin::createProjectAction(ActionContainer *ac, const QString &defaultText,
246                                         const QString &parameterText, Id id, const Context &context,
247                                         bool addToLocator, void (GitPlugin::*func)(),
248                                         const QKeySequence &keys)
249 {
250     ParameterAction *action = createParameterAction(ac, defaultText, parameterText, id, context,
251                                                     addToLocator, std::bind(func, this), keys);
252     m_projectActions.push_back(action);
253     return action;
254 }
255 
256 // Create an action to act on the repository
257 QAction *GitPlugin::createRepositoryAction(ActionContainer *ac, const QString &text, Id id,
258                                            const Context &context, bool addToLocator,
259                                            const std::function<void()> &callback,
260                                            const QKeySequence &keys)
261 {
262     auto action = new QAction(text, this);
263     createCommand(action, ac, id, context, addToLocator, callback, keys);
264     m_repositoryActions.push_back(action);
265     return action;
266 }
267 
268 QAction *GitPlugin::createChangeRelatedRepositoryAction(const QString &text, Id id,
269                                                         const Context &context)
270 {
271     return createRepositoryAction(nullptr, text, id, context, true,
272                                   std::bind(&GitPlugin::startChangeRelatedAction, this, id),
273                                   QKeySequence());
274 }
275 
276 // Action to act on the repository forwarded to a git client member function
277 // taking the directory.
278 QAction *GitPlugin::createRepositoryAction(ActionContainer *ac, const QString &text, Id id,
279                                            const Context &context, bool addToLocator,
280                                            GitClientMemberFunc func, const QKeySequence &keys)
281 {
282     auto cb = [this, func]() -> void {
283         QTC_ASSERT(currentState().hasTopLevel(), return);
284         (m_gitClient->*func)(currentState().topLevel());
285     };
286     // Set the member func as data and connect to GitClient method
287     return createRepositoryAction(ac, text, id, context, addToLocator, cb, keys);
288 }
289 
290 bool GitPlugin::initialize(const QStringList &arguments, QString *errorMessage)
291 {
292     Q_UNUSED(arguments)
293     Q_UNUSED(errorMessage)
294 
295     Context context(Constants::GIT_CONTEXT);
296 
297     m_gitClient = new GitClient;
298 
299     auto vc = initializeVcs<GitVersionControl>(context, m_gitClient);
300 
301     // Create the settings Page
302     auto settingsPage = new SettingsPage(vc, this);
303     connect(settingsPage, &SettingsPage::settingsChanged,
304             this, &GitPlugin::updateRepositoryBrowserAction);
305 
306     new GitGrep(this);
307 
308     const auto describeFunc = [this](const QString &source, const QString &id) {
309         m_gitClient->show(source, id);
310     };
311     const int editorCount = sizeof(editorParameters) / sizeof(editorParameters[0]);
312     const auto widgetCreator = []() { return new GitEditorWidget; };
313     for (int i = 0; i < editorCount; i++)
314         new VcsEditorFactory(editorParameters + i, widgetCreator, describeFunc, this);
315 
316     new VcsSubmitEditorFactory(&submitParameters,
317         []() { return new GitSubmitEditor(&submitParameters); }, this);
318 
319     const QString prefix = "git";
320     m_commandLocator = new CommandLocator("Git", prefix, prefix, this);
321 
322     //register actions
323     ActionContainer *toolsContainer = ActionManager::actionContainer(Core::Constants::M_TOOLS);
324 
325     ActionContainer *gitContainer = ActionManager::createMenu("Git");
326     gitContainer->menu()->setTitle(tr("&Git"));
327     toolsContainer->addMenu(gitContainer);
328     m_menuAction = gitContainer->menu()->menuAction();
329 
330 
331     /*  "Current File" menu */
332     ActionContainer *currentFileMenu = ActionManager::createMenu("Git.CurrentFileMenu");
333     currentFileMenu->menu()->setTitle(tr("Current &File"));
334     gitContainer->addMenu(currentFileMenu);
335 
336     createFileAction(currentFileMenu, tr("Diff Current File"), tr("Diff of \"%1\""),
337                      "Git.Diff", context, true, std::bind(&GitPlugin::diffCurrentFile, this),
338                       QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+D") : tr("Alt+G,Alt+D")));
339 
340     createFileAction(currentFileMenu, tr("Log Current File"), tr("Log of \"%1\""),
341                      "Git.Log", context, true, std::bind(&GitPlugin::logFile, this),
342                      QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+L") : tr("Alt+G,Alt+L")));
343 
344     createFileAction(currentFileMenu, tr("Blame Current File"), tr("Blame for \"%1\""),
345                      "Git.Blame", context, true, std::bind(&GitPlugin::blameFile, this),
346                      QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+B") : tr("Alt+G,Alt+B")));
347 
348     currentFileMenu->addSeparator(context);
349 
350     createFileAction(currentFileMenu, tr("Stage File for Commit"), tr("Stage \"%1\" for Commit"),
351                      "Git.Stage", context, true, std::bind(&GitPlugin::stageFile, this),
352                      QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+A") : tr("Alt+G,Alt+A")));
353 
354     createFileAction(currentFileMenu, tr("Unstage File from Commit"), tr("Unstage \"%1\" from Commit"),
355                      "Git.Unstage", context, true, std::bind(&GitPlugin::unstageFile, this));
356 
357     createFileAction(currentFileMenu, tr("Undo Unstaged Changes"), tr("Undo Unstaged Changes for \"%1\""),
358                      "Git.UndoUnstaged", context,
359                      true, std::bind(&GitPlugin::undoFileChanges, this, false));
360 
361     createFileAction(currentFileMenu, tr("Undo Uncommitted Changes"), tr("Undo Uncommitted Changes for \"%1\""),
362                      "Git.Undo", context,
363                      true, std::bind(&GitPlugin::undoFileChanges, this, true),
364                      QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+U") : tr("Alt+G,Alt+U")));
365 
366 
367     /*  "Current Project" menu */
368     ActionContainer *currentProjectMenu = ActionManager::createMenu("Git.CurrentProjectMenu");
369     currentProjectMenu->menu()->setTitle(tr("Current &Project"));
370     gitContainer->addMenu(currentProjectMenu);
371 
372     createProjectAction(currentProjectMenu, tr("Diff Current Project"), tr("Diff Project \"%1\""),
373                         "Git.DiffProject", context, true, &GitPlugin::diffCurrentProject,
374                         QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+Shift+D") : tr("Alt+G,Alt+Shift+D")));
375 
376     createProjectAction(currentProjectMenu, tr("Log Project"), tr("Log Project \"%1\""),
377                         "Git.LogProject", context, true, &GitPlugin::logProject,
378                         QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+K") : tr("Alt+G,Alt+K")));
379 
380     createProjectAction(currentProjectMenu, tr("Clean Project..."), tr("Clean Project \"%1\"..."),
381                         "Git.CleanProject", context, true, &GitPlugin::cleanProject);
382 
383 
384     /*  "Local Repository" menu */
385     ActionContainer *localRepositoryMenu = ActionManager::createMenu("Git.LocalRepositoryMenu");
386     localRepositoryMenu->menu()->setTitle(tr("&Local Repository"));
387     gitContainer->addMenu(localRepositoryMenu);
388 
389     createRepositoryAction(localRepositoryMenu, tr("Diff"), "Git.DiffRepository",
390                            context, true, &GitClient::diffRepository);
391 
392     createRepositoryAction(localRepositoryMenu, tr("Log"), "Git.LogRepository",
393                            context, true, std::bind(&GitPlugin::logRepository, this));
394 
395     createRepositoryAction(localRepositoryMenu, tr("Reflog"), "Git.ReflogRepository",
396                            context, true, &GitClient::reflog);
397 
398     createRepositoryAction(localRepositoryMenu, tr("Clean..."), "Git.CleanRepository",
399                            context, true, [this] { cleanRepository(); });
400 
401     createRepositoryAction(localRepositoryMenu, tr("Status"), "Git.StatusRepository",
402                            context, true, &GitClient::status);
403 
404     // --------------
405     localRepositoryMenu->addSeparator(context);
406 
407     createRepositoryAction(localRepositoryMenu, tr("Commit..."), "Git.Commit",
408                            context, true, std::bind(&GitPlugin::startCommit, this, SimpleCommit),
409                            QKeySequence(useMacShortcuts ? tr("Meta+G,Meta+C") : tr("Alt+G,Alt+C")));
410 
411     createRepositoryAction(localRepositoryMenu, tr("Amend Last Commit..."), "Git.AmendCommit",
412                            context, true, std::bind(&GitPlugin::startCommit, this, AmendCommit));
413 
414     m_fixupCommitAction
415             = createRepositoryAction(localRepositoryMenu,
416                                      tr("Fixup Previous Commit..."), "Git.FixupCommit", context, true,
417                                      std::bind(&GitPlugin::startCommit, this, FixupCommit));
418 
419     // --------------
420     localRepositoryMenu->addSeparator(context);
421 
422     createRepositoryAction(localRepositoryMenu, tr("Reset..."), "Git.Reset",
423                            context, true, std::bind(&GitPlugin::resetRepository, this));
424 
425     createRepositoryAction(localRepositoryMenu, tr("Recover Deleted Files"), "Git.RecoverDeleted",
426                            context, true, std::bind(&GitPlugin::recoverDeletedFiles, this));
427 
428     m_interactiveRebaseAction
429             = createRepositoryAction(localRepositoryMenu,
430                                      tr("Interactive Rebase..."), "Git.InteractiveRebase",
431                                      context, true, std::bind(&GitPlugin::startRebase, this));
432 
433     m_submoduleUpdateAction
434             = createRepositoryAction(localRepositoryMenu,
435                                      tr("Update Submodules"), "Git.SubmoduleUpdate",
436                                      context, true, std::bind(&GitPlugin::updateSubmodules, this));
437     m_abortMergeAction
438             = createRepositoryAction(localRepositoryMenu,
439                                      tr("Abort Merge"), "Git.MergeAbort",
440                                      context, true,
441                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
442 
443     m_abortRebaseAction
444             = createRepositoryAction(localRepositoryMenu,
445                                      tr("Abort Rebase"), "Git.RebaseAbort",
446                                      context, true,
447                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
448 
449     m_abortCherryPickAction
450             = createRepositoryAction(localRepositoryMenu,
451                                      tr("Abort Cherry Pick"), "Git.CherryPickAbort",
452                                      context, true,
453                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
454 
455     m_abortRevertAction
456             = createRepositoryAction(localRepositoryMenu,
457                                      tr("Abort Revert"), "Git.RevertAbort",
458                                      context, true,
459                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
460 
461     m_continueRebaseAction
462             = createRepositoryAction(localRepositoryMenu,
463                                      tr("Continue Rebase"), "Git.RebaseContinue",
464                                      context, true,
465                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
466 
467     m_skipRebaseAction
468             = createRepositoryAction(localRepositoryMenu,
469                                      tr("Skip Rebase"), "Git.RebaseSkip",
470                                      context, true,
471                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
472 
473     m_continueCherryPickAction
474             = createRepositoryAction(localRepositoryMenu,
475                                      tr("Continue Cherry Pick"), "Git.CherryPickContinue",
476                                      context, true,
477                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
478 
479     m_continueRevertAction
480             = createRepositoryAction(localRepositoryMenu,
481                                      tr("Continue Revert"), "Git.RevertContinue",
482                                      context, true,
483                                      std::bind(&GitPlugin::continueOrAbortCommand, this));
484 
485     // --------------
486     localRepositoryMenu->addSeparator(context);
487 
488     createRepositoryAction(localRepositoryMenu, tr("Branches..."), "Git.BranchList",
489                            context, true, std::bind(&GitPlugin::branchList, this));
490 
491     // --------------
492     localRepositoryMenu->addSeparator(context);
493 
494     // "Patch" menu
495     ActionContainer *patchMenu = ActionManager::createMenu("Git.PatchMenu");
496     patchMenu->menu()->setTitle(tr("&Patch"));
497     localRepositoryMenu->addMenu(patchMenu);
498 
499     // Apply current file as patch is handled specially.
500     m_applyCurrentFilePatchAction
501             = createParameterAction(patchMenu,
502                                     tr("Apply from Editor"), tr("Apply \"%1\""),
503                                     "Git.ApplyCurrentFilePatch",
504                                     context, true, std::bind(&GitPlugin::applyCurrentFilePatch, this));
505     createRepositoryAction(patchMenu, tr("Apply from File..."), "Git.ApplyPatch",
506                            context, true, std::bind(&GitPlugin::promptApplyPatch, this));
507 
508     // "Stash" menu
509     ActionContainer *stashMenu = ActionManager::createMenu("Git.StashMenu");
510     stashMenu->menu()->setTitle(tr("&Stash"));
511     localRepositoryMenu->addMenu(stashMenu);
512 
513     createRepositoryAction(stashMenu, tr("Stashes..."), "Git.StashList",
514                            context, false, std::bind(&GitPlugin::stashList, this));
515 
516     stashMenu->addSeparator(context);
517 
518     QAction *action = createRepositoryAction(stashMenu, tr("Stash"), "Git.Stash",
519                                              context, true, std::bind(&GitPlugin::stash, this, false));
520     action->setToolTip(tr("Saves the current state of your work and resets the repository."));
521 
522     action = createRepositoryAction(stashMenu, tr("Stash Unstaged Files"), "Git.StashUnstaged",
523                                     context, true, std::bind(&GitPlugin::stashUnstaged, this));
524     action->setToolTip(tr("Saves the current state of your unstaged files and resets the repository "
525                           "to its staged state."));
526 
527     action = createRepositoryAction(stashMenu, tr("Take Snapshot..."), "Git.StashSnapshot",
528                                     context, true, std::bind(&GitPlugin::stashSnapshot, this));
529     action->setToolTip(tr("Saves the current state of your work."));
530 
531     stashMenu->addSeparator(context);
532 
533     action = createRepositoryAction(stashMenu, tr("Stash Pop"), "Git.StashPop",
534                                     context, true, std::bind(&GitPlugin::stashPop, this));
535     action->setToolTip(tr("Restores changes saved to the stash list using \"Stash\"."));
536 
537 
538     /* \"Local Repository" menu */
539 
540     // --------------
541 
542     /*  "Remote Repository" menu */
543     ActionContainer *remoteRepositoryMenu = ActionManager::createMenu("Git.RemoteRepositoryMenu");
544     remoteRepositoryMenu->menu()->setTitle(tr("&Remote Repository"));
545     gitContainer->addMenu(remoteRepositoryMenu);
546 
547     createRepositoryAction(remoteRepositoryMenu, tr("Fetch"), "Git.Fetch",
548                            context, true, std::bind(&GitPlugin::fetch, this));
549 
550     createRepositoryAction(remoteRepositoryMenu, tr("Pull"), "Git.Pull",
551                            context, true, std::bind(&GitPlugin::pull, this));
552 
553     createRepositoryAction(remoteRepositoryMenu, tr("Push"), "Git.Push",
554                            context, true, std::bind(&GitPlugin::push, this));
555 
556     // --------------
557     remoteRepositoryMenu->addSeparator(context);
558 
559     // "Subversion" menu
560     ActionContainer *subversionMenu = ActionManager::createMenu("Git.Subversion");
561     subversionMenu->menu()->setTitle(tr("&Subversion"));
562     remoteRepositoryMenu->addMenu(subversionMenu);
563 
564     createRepositoryAction(subversionMenu, tr("Log"), "Git.Subversion.Log",
565                            context, false, &GitClient::subversionLog);
566 
567     createRepositoryAction(subversionMenu, tr("Fetch"), "Git.Subversion.Fetch",
568                            context, false, &GitClient::synchronousSubversionFetch);
569 
570     // --------------
571     remoteRepositoryMenu->addSeparator(context);
572 
573     createRepositoryAction(remoteRepositoryMenu, tr("Manage Remotes..."), "Git.RemoteList",
574                            context, false, std::bind(&GitPlugin::remoteList, this));
575 
576     /* \"Remote Repository" menu */
577 
578     // --------------
579 
580     /*  Actions only in locator */
581     createChangeRelatedRepositoryAction(tr("Show..."), "Git.Show", context);
582     createChangeRelatedRepositoryAction(tr("Revert..."), "Git.Revert", context);
583     createChangeRelatedRepositoryAction(tr("Cherry Pick..."), "Git.CherryPick", context);
584     createChangeRelatedRepositoryAction(tr("Checkout..."), "Git.Checkout", context);
585 
586     createRepositoryAction(nullptr, tr("Rebase..."), "Git.Rebase", context, true,
587                            std::bind(&GitPlugin::branchList, this));
588     createRepositoryAction(nullptr, tr("Merge..."), "Git.Merge", context, true,
589                            std::bind(&GitPlugin::branchList, this));
590     /*  \Actions only in locator */
591 
592     // --------------
593 
594     /*  "Git Tools" menu */
595     ActionContainer *gitToolsMenu = ActionManager::createMenu("Git.GitToolsMenu");
596     gitToolsMenu->menu()->setTitle(tr("Git &Tools"));
597     gitContainer->addMenu(gitToolsMenu);
598 
599     createRepositoryAction(gitToolsMenu, tr("Gitk"), "Git.LaunchGitK",
600                            context, true, &GitClient::launchGitK);
601 
602     createFileAction(gitToolsMenu, tr("Gitk Current File"), tr("Gitk of \"%1\""),
603                      "Git.GitkFile", context, true, std::bind(&GitPlugin::gitkForCurrentFile, this));
604 
605     createFileAction(gitToolsMenu, tr("Gitk for folder of Current File"), tr("Gitk for folder of \"%1\""),
606                      "Git.GitkFolder", context, true, std::bind(&GitPlugin::gitkForCurrentFolder, this));
607 
608     // --------------
609     gitToolsMenu->addSeparator(context);
610 
611     createRepositoryAction(gitToolsMenu, tr("Git Gui"), "Git.GitGui",
612                            context, true, std::bind(&GitPlugin::gitGui, this));
613 
614     // --------------
615     gitToolsMenu->addSeparator(context);
616 
617     m_repositoryBrowserAction
618             = createRepositoryAction(gitToolsMenu,
619                                      tr("Repository Browser"), "Git.LaunchRepositoryBrowser",
620                                      context, true, &GitClient::launchRepositoryBrowser);
621 
622     m_mergeToolAction
623             = createRepositoryAction(gitToolsMenu, tr("Merge Tool"), "Git.MergeTool",
624                                      context, true, std::bind(&GitPlugin::startMergeTool, this));
625 
626     /* \"Git Tools" menu */
627 
628     // --------------
629     gitContainer->addSeparator(context);
630 
631     QAction *actionsOnCommitsAction = new QAction(tr("Actions on Commits..."), this);
632     Command *actionsOnCommitsCommand = ActionManager::registerAction(
633                 actionsOnCommitsAction, "Git.ChangeActions");
634     connect(actionsOnCommitsAction, &QAction::triggered, this,
635             [this] { startChangeRelatedAction("Git.ChangeActions"); });
636     gitContainer->addAction(actionsOnCommitsCommand);
637 
638     QAction *createRepositoryAction = new QAction(tr("Create Repository..."), this);
639     Command *createRepositoryCommand = ActionManager::registerAction(
640                 createRepositoryAction, "Git.CreateRepository");
641     connect(createRepositoryAction, &QAction::triggered, this, &GitPlugin::createRepository);
642     gitContainer->addAction(createRepositoryCommand);
643 
644     // Submit editor
645     Context submitContext(Constants::GITSUBMITEDITOR_ID);
646     m_submitCurrentAction = new QAction(VcsBaseSubmitEditor::submitIcon(), tr("Commit"), this);
647     Command *command = ActionManager::registerAction(m_submitCurrentAction, Constants::SUBMIT_CURRENT, submitContext);
648     command->setAttribute(Command::CA_UpdateText);
649     connect(m_submitCurrentAction, &QAction::triggered, this, &GitPlugin::submitCurrentLog);
650 
651     m_diffSelectedFilesAction = new QAction(VcsBaseSubmitEditor::diffIcon(), tr("Diff &Selected Files"), this);
652     ActionManager::registerAction(m_diffSelectedFilesAction, Constants::DIFF_SELECTED, submitContext);
653 
654     m_undoAction = new QAction(tr("&Undo"), this);
655     ActionManager::registerAction(m_undoAction, Core::Constants::UNDO, submitContext);
656 
657     m_redoAction = new QAction(tr("&Redo"), this);
658     ActionManager::registerAction(m_redoAction, Core::Constants::REDO, submitContext);
659 
660     connect(VcsManager::instance(), &VcsManager::repositoryChanged,
661             this, &GitPlugin::updateContinueAndAbortCommands);
662     connect(VcsManager::instance(), &VcsManager::repositoryChanged,
663             this, &GitPlugin::updateBranches, Qt::QueuedConnection);
664 
665     /* "Gerrit" */
666     m_gerritPlugin = new Gerrit::Internal::GerritPlugin(this);
667     const bool ok = m_gerritPlugin->initialize(remoteRepositoryMenu);
668     m_gerritPlugin->updateActions(currentState());
669     m_gerritPlugin->addToLocator(m_commandLocator);
670 
671     return ok;
672 }
673 
674 GitVersionControl *GitPlugin::gitVersionControl() const
675 {
676     return static_cast<GitVersionControl *>(versionControl());
677 }
678 
679 void GitPlugin::diffCurrentFile()
680 {
681     const VcsBasePluginState state = currentState();
682     QTC_ASSERT(state.hasFile(), return);
683     m_gitClient->diffFile(state.currentFileTopLevel(), state.relativeCurrentFile());
684 }
685 
686 void GitPlugin::diffCurrentProject()
687 {
688     const VcsBasePluginState state = currentState();
689     QTC_ASSERT(state.hasProject(), return);
690     const QString relativeProject = state.relativeCurrentProject();
691     if (relativeProject.isEmpty())
692         m_gitClient->diffRepository(state.currentProjectTopLevel());
693     else
694         m_gitClient->diffProject(state.currentProjectTopLevel(), relativeProject);
695 }
696 
697 void GitPlugin::logFile()
698 {
699     const VcsBasePluginState state = currentState();
700     QTC_ASSERT(state.hasFile(), return);
701     m_gitClient->log(state.currentFileTopLevel(), state.relativeCurrentFile(), true);
702 }
703 
704 void GitPlugin::blameFile()
705 {
706     const VcsBasePluginState state = currentState();
707     QTC_ASSERT(state.hasFile(), return);
708     const int lineNumber = VcsBaseEditor::lineNumberOfCurrentEditor(state.currentFile());
709     QStringList extraOptions;
710     int firstLine = -1;
711     if (BaseTextEditor *textEditor = BaseTextEditor::currentTextEditor()) {
712         QTextCursor cursor = textEditor->textCursor();
713         if (cursor.hasSelection()) {
714             QString argument = "-L ";
715             int selectionStart = cursor.selectionStart();
716             int selectionEnd = cursor.selectionEnd();
717             cursor.setPosition(selectionStart);
718             const int startBlock = cursor.blockNumber();
719             cursor.setPosition(selectionEnd);
720             int endBlock = cursor.blockNumber();
721             if (startBlock != endBlock) {
722                 firstLine = startBlock + 1;
723                 if (cursor.atBlockStart())
724                     --endBlock;
725                 if (auto widget = qobject_cast<VcsBaseEditorWidget *>(textEditor->widget())) {
726                     const int previousFirstLine = widget->firstLineNumber();
727                     if (previousFirstLine > 0)
728                         firstLine = previousFirstLine;
729                 }
730                 argument += QString::number(firstLine) + ',';
731                 argument += QString::number(endBlock + firstLine - startBlock);
732                 extraOptions << argument;
733             }
734         }
735     }
736     VcsBaseEditorWidget *editor = m_gitClient->annotate(
737                 state.currentFileTopLevel(), state.relativeCurrentFile(), QString(),
738                 lineNumber, extraOptions);
739     if (firstLine > 0)
740         editor->setFirstLineNumber(firstLine);
741 }
742 
743 void GitPlugin::logProject()
744 {
745     const VcsBasePluginState state = currentState();
746     QTC_ASSERT(state.hasProject(), return);
747     m_gitClient->log(state.currentProjectTopLevel(), state.relativeCurrentProject());
748 }
749 
750 void GitPlugin::logRepository()
751 {
752     const VcsBasePluginState state = currentState();
753     QTC_ASSERT(state.hasTopLevel(), return);
754     m_gitClient->log(state.topLevel());
755 }
756 
757 void GitPlugin::undoFileChanges(bool revertStaging)
758 {
759     if (IDocument *document = EditorManager::currentDocument()) {
760         if (!DocumentManager::saveModifiedDocumentSilently(document))
761             return;
762     }
763     const VcsBasePluginState state = currentState();
764     QTC_ASSERT(state.hasFile(), return);
765     FileChangeBlocker fcb(state.currentFile());
766     m_gitClient->revert({state.currentFile()}, revertStaging);
767 }
768 
769 class ResetItemDelegate : public LogItemDelegate
770 {
771 public:
772     ResetItemDelegate(LogChangeWidget *widget) : LogItemDelegate(widget) {}
773     void initStyleOption(QStyleOptionViewItem *option, const QModelIndex &index) const override
774     {
775         if (index.row() < currentRow())
776             option->font.setStrikeOut(true);
777         LogItemDelegate::initStyleOption(option, index);
778     }
779 };
780 
781 class RebaseItemDelegate : public IconItemDelegate
782 {
783 public:
784     RebaseItemDelegate(LogChangeWidget *widget)
785         : IconItemDelegate(widget, Utils::Icons::UNDO)
786     {
787     }
788 
789 protected:
790     bool hasIcon(int row) const override
791     {
792         return row <= currentRow();
793     }
794 };
795 
796 void GitPlugin::resetRepository()
797 {
798     if (!DocumentManager::saveAllModifiedDocuments())
799         return;
800     const VcsBasePluginState state = currentState();
801     QTC_ASSERT(state.hasTopLevel(), return);
802     QString topLevel = state.topLevel();
803 
804     LogChangeDialog dialog(true, ICore::mainWindow());
805     ResetItemDelegate delegate(dialog.widget());
806     dialog.setWindowTitle(tr("Undo Changes to %1").arg(QDir::toNativeSeparators(topLevel)));
807     if (dialog.runDialog(topLevel, QString(), LogChangeWidget::IncludeRemotes))
808         m_gitClient->reset(topLevel, dialog.resetFlag(), dialog.commit());
809 }
810 
811 void GitPlugin::recoverDeletedFiles()
812 {
813     if (!DocumentManager::saveAllModifiedDocuments())
814         return;
815     const VcsBasePluginState state = currentState();
816     QTC_ASSERT(state.hasTopLevel(), return);
817     m_gitClient->recoverDeletedFiles(state.topLevel());
818 }
819 
820 void GitPlugin::startRebase()
821 {
822     if (!DocumentManager::saveAllModifiedDocuments())
823         return;
824     const VcsBasePluginState state = currentState();
825     QTC_ASSERT(state.hasTopLevel(), return);
826     const QString topLevel = state.topLevel();
827     if (topLevel.isEmpty() || !m_gitClient->canRebase(topLevel))
828         return;
829     LogChangeDialog dialog(false, ICore::mainWindow());
830     RebaseItemDelegate delegate(dialog.widget());
831     dialog.setWindowTitle(tr("Interactive Rebase"));
832     if (!dialog.runDialog(topLevel))
833         return;
834     if (m_gitClient->beginStashScope(topLevel, "Rebase-i"))
835         m_gitClient->interactiveRebase(topLevel, dialog.commit(), false);
836 }
837 
838 void GitPlugin::startChangeRelatedAction(const Id &id)
839 {
840     const VcsBasePluginState state = currentState();
841 
842     ChangeSelectionDialog dialog(state.hasTopLevel() ? state.topLevel() : PathChooser::homePath(),
843                                  id, ICore::mainWindow());
844 
845     int result = dialog.exec();
846 
847     if (result == QDialog::Rejected)
848         return;
849 
850     const QString workingDirectory = dialog.workingDirectory();
851     const QString change = dialog.change();
852 
853     if (workingDirectory.isEmpty() || change.isEmpty())
854         return;
855 
856     if (dialog.command() == Show) {
857         m_gitClient->show(workingDirectory, change);
858         return;
859     }
860 
861     if (!DocumentManager::saveAllModifiedDocuments())
862         return;
863 
864     switch (dialog.command()) {
865     case CherryPick:
866         m_gitClient->synchronousCherryPick(workingDirectory, change);
867         break;
868     case Revert:
869         m_gitClient->synchronousRevert(workingDirectory, change);
870         break;
871     case Checkout:
872         m_gitClient->stashAndCheckout(workingDirectory, change);
873         break;
874     default:
875         return;
876     }
877 }
878 
879 void GitPlugin::stageFile()
880 {
881     const VcsBasePluginState state = currentState();
882     QTC_ASSERT(state.hasFile(), return);
883     m_gitClient->addFile(state.currentFileTopLevel(), state.relativeCurrentFile());
884 }
885 
886 void GitPlugin::unstageFile()
887 {
888     const VcsBasePluginState state = currentState();
889     QTC_ASSERT(state.hasFile(), return);
890     m_gitClient->synchronousReset(state.currentFileTopLevel(), {state.relativeCurrentFile()});
891 }
892 
893 void GitPlugin::gitkForCurrentFile()
894 {
895     const VcsBasePluginState state = currentState();
896     QTC_ASSERT(state.hasFile(), return);
897     m_gitClient->launchGitK(state.currentFileTopLevel(), state.relativeCurrentFile());
898 }
899 
900 void GitPlugin::gitkForCurrentFolder()
901 {
902     const VcsBasePluginState state = currentState();
903     QTC_ASSERT(state.hasFile(), return);
904 
905     /*
906      *  entire lower part of the code can be easily replaced with one line:
907      *
908      *  m_gitClient->launchGitK(dir.currentFileDirectory(), ".");
909      *
910      *  However, there is a bug in gitk in version 1.7.9.5, and if you run above
911      *  command, there will be no documents listed in lower right section.
912      *
913      *  This is why I use lower combination in order to avoid this problems in gitk.
914      *
915      *  Git version 1.7.10.4 does not have this issue, and it can easily use
916      *  one line command mentioned above.
917      *
918      */
919     QDir dir(state.currentFileDirectory());
920     if (QFileInfo(dir,".git").exists() || dir.cd(".git")) {
921         m_gitClient->launchGitK(state.currentFileDirectory());
922     } else {
923         QString folderName = dir.absolutePath();
924         dir.cdUp();
925         folderName = folderName.remove(0, dir.absolutePath().length() + 1);
926         m_gitClient->launchGitK(dir.absolutePath(), folderName);
927     }
928 }
929 
930 void GitPlugin::gitGui()
931 {
932     const VcsBasePluginState state = currentState();
933     QTC_ASSERT(state.hasTopLevel(), return);
934     m_gitClient->launchGitGui(state.topLevel());
935 }
936 
937 void GitPlugin::startCommit(CommitType commitType)
938 {
939     if (!promptBeforeCommit())
940         return;
941 
942     if (raiseSubmitEditor())
943         return;
944     if (isCommitEditorOpen()) {
945         VcsOutputWindow::appendWarning(tr("Another submit is currently being executed."));
946         return;
947     }
948 
949     const VcsBasePluginState state = currentState();
950     QTC_ASSERT(state.hasTopLevel(), return);
951 
952     QString errorMessage, commitTemplate;
953     CommitData data(commitType);
954     if (!m_gitClient->getCommitData(state.topLevel(), &commitTemplate, data, &errorMessage)) {
955         VcsOutputWindow::appendError(errorMessage);
956         return;
957     }
958 
959     // Store repository for diff and the original list of
960     // files to be able to unstage files the user unchecks
961     m_submitRepository = data.panelInfo.repository;
962 
963     // Start new temp file with message template
964     TempFileSaver saver;
965     // Keep the file alive, else it removes self and forgets its name
966     saver.setAutoRemove(false);
967     saver.write(commitTemplate.toLocal8Bit());
968     if (!saver.finalize()) {
969         VcsOutputWindow::appendError(saver.errorString());
970         return;
971     }
972     m_commitMessageFileName = saver.fileName();
973     openSubmitEditor(m_commitMessageFileName, data);
974 }
975 
976 void GitPlugin::updateVersionWarning()
977 {
978     unsigned version = m_gitClient->gitVersion();
979     if (!version || version >= minimumRequiredVersion)
980         return;
981     IDocument *curDocument = EditorManager::currentDocument();
982     if (!curDocument)
983         return;
984     InfoBar *infoBar = curDocument->infoBar();
985     Id gitVersionWarning("GitVersionWarning");
986     if (!infoBar->canInfoBeAdded(gitVersionWarning))
987         return;
988     infoBar->addInfo(InfoBarEntry(gitVersionWarning,
989                         tr("Unsupported version of Git found. Git %1 or later required.")
990                         .arg(versionString(minimumRequiredVersion)),
991                         InfoBarEntry::GlobalSuppressionEnabled));
992 }
993 
994 IEditor *GitPlugin::openSubmitEditor(const QString &fileName, const CommitData &cd)
995 {
996     IEditor *editor = EditorManager::openEditor(fileName, Constants::GITSUBMITEDITOR_ID);
997     GitSubmitEditor *submitEditor = qobject_cast<GitSubmitEditor*>(editor);
998     QTC_ASSERT(submitEditor, return 0);
999     setSubmitEditor(submitEditor);
1000     // The actions are for some reason enabled by the context switching
1001     // mechanism. Disable them correctly.
1002     submitEditor->registerActions(m_undoAction, m_redoAction, m_submitCurrentAction, m_diffSelectedFilesAction);
1003     submitEditor->setCommitData(cd);
1004     submitEditor->setCheckScriptWorkingDirectory(m_submitRepository);
1005     QString title;
1006     switch (cd.commitType) {
1007     case AmendCommit:
1008         title = tr("Amend %1").arg(cd.amendSHA1);
1009         break;
1010     case FixupCommit:
1011         title = tr("Git Fixup Commit");
1012         break;
1013     default:
1014         title = tr("Git Commit");
1015     }
1016     IDocument *document = submitEditor->document();
1017     document->setPreferredDisplayName(title);
1018     VcsBasePlugin::setSource(document, m_submitRepository);
1019     return editor;
1020 }
1021 
1022 void GitPlugin::submitCurrentLog()
1023 {
1024     // Close the submit editor
1025     m_submitActionTriggered = true;
1026     QTC_ASSERT(submitEditor(), return);
1027     EditorManager::closeDocument(submitEditor()->document());
1028 }
1029 
1030 bool GitPlugin::submitEditorAboutToClose()
1031 {
1032     if (!isCommitEditorOpen())
1033         return true;
1034     GitSubmitEditor *editor = qobject_cast<GitSubmitEditor *>(submitEditor());
1035     QTC_ASSERT(editor, return true);
1036     IDocument *editorDocument = editor->document();
1037     QTC_ASSERT(editorDocument, return true);
1038     // Submit editor closing. Make it write out the commit message
1039     // and retrieve files
1040     const QFileInfo editorFile = editorDocument->filePath().toFileInfo();
1041     const QFileInfo changeFile(m_commitMessageFileName);
1042     // Paranoia!
1043     if (editorFile.absoluteFilePath() != changeFile.absoluteFilePath())
1044         return true;
1045     // Prompt user. Force a prompt unless submit was actually invoked (that
1046     // is, the editor was closed or shutdown).
1047     bool promptData = false;
1048     const VcsBaseSubmitEditor::PromptSubmitResult answer
1049             = editor->promptSubmit(tr("Closing Git Editor"),
1050                  tr("Do you want to commit the change?"),
1051                  tr("Git will not accept this commit. Do you want to continue to edit it?"),
1052                  &promptData, !m_submitActionTriggered, false);
1053     m_submitActionTriggered = false;
1054     switch (answer) {
1055     case VcsBaseSubmitEditor::SubmitCanceled:
1056         return false; // Keep editing and change file
1057     case VcsBaseSubmitEditor::SubmitDiscarded:
1058         cleanCommitMessageFile();
1059         return true; // Cancel all
1060     default:
1061         break;
1062     }
1063 
1064 
1065     // Go ahead!
1066     SubmitFileModel *model = qobject_cast<SubmitFileModel *>(editor->fileModel());
1067     bool closeEditor = true;
1068     CommitType commitType = editor->commitType();
1069     QString amendSHA1 = editor->amendSHA1();
1070     if (model->hasCheckedFiles() || !amendSHA1.isEmpty()) {
1071         // get message & commit
1072         if (!DocumentManager::saveDocument(editorDocument))
1073             return false;
1074 
1075         closeEditor = m_gitClient->addAndCommit(m_submitRepository, editor->panelData(),
1076                                                 commitType, amendSHA1,
1077                                                 m_commitMessageFileName, model);
1078     }
1079     if (!closeEditor)
1080         return false;
1081     cleanCommitMessageFile();
1082     if (commitType == FixupCommit) {
1083         if (!m_gitClient->beginStashScope(m_submitRepository, "Rebase-fixup",
1084                                           NoPrompt, editor->panelData().pushAction)) {
1085             return false;
1086         }
1087         m_gitClient->interactiveRebase(m_submitRepository, amendSHA1, true);
1088     } else {
1089         m_gitClient->continueCommandIfNeeded(m_submitRepository);
1090         if (editor->panelData().pushAction == NormalPush) {
1091             m_gitClient->push(m_submitRepository);
1092         } else if (editor->panelData().pushAction == PushToGerrit) {
1093             connect(editor, &QObject::destroyed, this, &GitPlugin::delayedPushToGerrit,
1094                     Qt::QueuedConnection);
1095         }
1096     }
1097 
1098     return true;
1099 }
1100 
1101 void GitPlugin::fetch()
1102 {
1103     m_gitClient->fetch(currentState().topLevel(), QString());
1104 }
1105 
1106 void GitPlugin::pull()
1107 {
1108     if (!DocumentManager::saveAllModifiedDocuments())
1109         return;
1110     const VcsBasePluginState state = currentState();
1111     QTC_ASSERT(state.hasTopLevel(), return);
1112     QString topLevel = state.topLevel();
1113     bool rebase = client()->settings().boolValue(GitSettings::pullRebaseKey);
1114 
1115     if (!rebase) {
1116         QString currentBranch = m_gitClient->synchronousCurrentLocalBranch(topLevel);
1117         if (!currentBranch.isEmpty()) {
1118             currentBranch.prepend("branch.");
1119             currentBranch.append(".rebase");
1120             rebase = (m_gitClient->readConfigValue(topLevel, currentBranch) == "true");
1121         }
1122     }
1123 
1124     if (!m_gitClient->beginStashScope(topLevel, "Pull", rebase ? Default : AllowUnstashed))
1125         return;
1126     m_gitClient->synchronousPull(topLevel, rebase);
1127 }
1128 
1129 void GitPlugin::push()
1130 {
1131     const VcsBasePluginState state = currentState();
1132     QTC_ASSERT(state.hasTopLevel(), return);
1133     m_gitClient->push(state.topLevel());
1134 }
1135 
1136 void GitPlugin::startMergeTool()
1137 {
1138     const VcsBasePluginState state = currentState();
1139     QTC_ASSERT(state.hasTopLevel(), return);
1140     m_gitClient->merge(state.topLevel());
1141 }
1142 
1143 void GitPlugin::continueOrAbortCommand()
1144 {
1145     if (!DocumentManager::saveAllModifiedDocuments())
1146         return;
1147     const VcsBasePluginState state = currentState();
1148     QTC_ASSERT(state.hasTopLevel(), return);
1149     QObject *action = QObject::sender();
1150 
1151     if (action == m_abortMergeAction)
1152         m_gitClient->synchronousMerge(state.topLevel(), "--abort");
1153     else if (action == m_abortRebaseAction)
1154         m_gitClient->rebase(state.topLevel(), "--abort");
1155     else if (action == m_abortCherryPickAction)
1156         m_gitClient->synchronousCherryPick(state.topLevel(), "--abort");
1157     else if (action == m_abortRevertAction)
1158         m_gitClient->synchronousRevert(state.topLevel(), "--abort");
1159     else if (action == m_skipRebaseAction)
1160         m_gitClient->rebase(state.topLevel(), "--skip");
1161     else if (action == m_continueRebaseAction)
1162         m_gitClient->rebase(state.topLevel(), "--continue");
1163     else if (action == m_continueCherryPickAction)
1164         m_gitClient->cherryPick(state.topLevel(), "--continue");
1165     else if (action == m_continueRevertAction)
1166         m_gitClient->revert(state.topLevel(), "--continue");
1167 
1168     updateContinueAndAbortCommands();
1169 }
1170 
1171 void GitPlugin::cleanProject()
1172 {
1173     const VcsBasePluginState state = currentState();
1174     QTC_ASSERT(state.hasProject(), return);
1175     cleanRepository(state.currentProjectPath());
1176 }
1177 
1178 void GitPlugin::cleanRepository()
1179 {
1180     const VcsBasePluginState state = currentState();
1181     QTC_ASSERT(state.hasTopLevel(), return);
1182     cleanRepository(state.topLevel());
1183 }
1184 
1185 void GitPlugin::cleanRepository(const QString &directory)
1186 {
1187     // Find files to be deleted
1188     QString errorMessage;
1189     QStringList files;
1190     QStringList ignoredFiles;
1191     QApplication::setOverrideCursor(Qt::WaitCursor);
1192     const bool gotFiles = m_gitClient->synchronousCleanList(directory, QString(), &files, &ignoredFiles, &errorMessage);
1193     QApplication::restoreOverrideCursor();
1194 
1195     if (!gotFiles) {
1196         Core::AsynchronousMessageBox::warning(tr("Unable to retrieve file list"), errorMessage);
1197         return;
1198     }
1199     if (files.isEmpty() && ignoredFiles.isEmpty()) {
1200         Core::AsynchronousMessageBox::information(tr("Repository Clean"),
1201                                                    tr("The repository is clean."));
1202         return;
1203     }
1204 
1205     // Show in dialog
1206     CleanDialog dialog(ICore::dialogParent());
1207     dialog.setFileList(directory, files, ignoredFiles);
1208     dialog.exec();
1209 }
1210 
1211 void GitPlugin::updateSubmodules()
1212 {
1213     const VcsBasePluginState state = currentState();
1214     QTC_ASSERT(state.hasTopLevel(), return);
1215     m_gitClient->updateSubmodulesIfNeeded(state.topLevel(), false);
1216 }
1217 
1218 // If the file is modified in an editor, make sure it is saved.
1219 static bool ensureFileSaved(const QString &fileName)
1220 {
1221     return DocumentManager::saveModifiedDocument(DocumentModel::documentForFilePath(fileName));
1222 }
1223 
1224 void GitPlugin::applyCurrentFilePatch()
1225 {
1226     const VcsBasePluginState state = currentState();
1227     QTC_ASSERT(state.hasPatchFile() && state.hasTopLevel(), return);
1228     const QString patchFile = state.currentPatchFile();
1229     if (!ensureFileSaved(patchFile))
1230         return;
1231     applyPatch(state.topLevel(), patchFile);
1232 }
1233 
1234 void GitPlugin::promptApplyPatch()
1235 {
1236     const VcsBasePluginState state = currentState();
1237     QTC_ASSERT(state.hasTopLevel(), return);
1238     applyPatch(state.topLevel(), QString());
1239 }
1240 
1241 void GitPlugin::applyPatch(const QString &workingDirectory, QString file)
1242 {
1243     // Ensure user has been notified about pending changes
1244     if (!m_gitClient->beginStashScope(workingDirectory, "Apply-Patch", AllowUnstashed))
1245         return;
1246     // Prompt for file
1247     if (file.isEmpty()) {
1248         const QString filter = tr("Patches (*.patch *.diff)");
1249         file = QFileDialog::getOpenFileName(ICore::mainWindow(), tr("Choose Patch"), QString(), filter);
1250         if (file.isEmpty()) {
1251             m_gitClient->endStashScope(workingDirectory);
1252             return;
1253         }
1254     }
1255     // Run!
1256     QString errorMessage;
1257     if (m_gitClient->synchronousApplyPatch(workingDirectory, file, &errorMessage)) {
1258         if (errorMessage.isEmpty())
1259             VcsOutputWindow::appendMessage(tr("Patch %1 successfully applied to %2").arg(file, workingDirectory));
1260         else
1261             VcsOutputWindow::appendError(errorMessage);
1262     } else {
1263         VcsOutputWindow::appendError(errorMessage);
1264     }
1265     m_gitClient->endStashScope(workingDirectory);
1266 }
1267 
1268 void GitPlugin::stash(bool unstagedOnly)
1269 {
1270     if (!DocumentManager::saveAllModifiedDocuments())
1271         return;
1272     // Simple stash without prompt, reset repo.
1273     const VcsBasePluginState state = currentState();
1274     QTC_ASSERT(state.hasTopLevel(), return);
1275 
1276     const QString topLevel = state.topLevel();
1277     m_gitClient->executeSynchronousStash(topLevel, QString(), unstagedOnly);
1278     if (m_stashDialog)
1279         m_stashDialog->refresh(topLevel, true);
1280 }
1281 
1282 void GitPlugin::stashUnstaged()
1283 {
1284     stash(true);
1285 }
1286 
1287 void GitPlugin::stashSnapshot()
1288 {
1289     // Prompt for description, restore immediately and keep on working.
1290     const VcsBasePluginState state = currentState();
1291     QTC_ASSERT(state.hasTopLevel(), return);
1292     const QString id = m_gitClient->synchronousStash(state.topLevel(), QString(),
1293                 GitClient::StashImmediateRestore | GitClient::StashPromptDescription);
1294     if (!id.isEmpty() && m_stashDialog)
1295         m_stashDialog->refresh(state.topLevel(), true);
1296 }
1297 
1298 void GitPlugin::stashPop()
1299 {
1300     if (!DocumentManager::saveAllModifiedDocuments())
1301         return;
1302     const QString repository = currentState().topLevel();
1303     m_gitClient->stashPop(repository);
1304     if (m_stashDialog)
1305         m_stashDialog->refresh(repository, true);
1306 }
1307 
1308 // Create a non-modal dialog with refresh function or raise if it exists
1309 template <class NonModalDialog>
1310     inline void showNonModalDialog(const QString &topLevel,
1311                                    QPointer<NonModalDialog> &dialog)
1312 {
1313     if (dialog) {
1314         dialog->show();
1315         dialog->raise();
1316     } else {
1317         dialog = new NonModalDialog(ICore::mainWindow());
1318         dialog->refresh(topLevel, true);
1319         dialog->show();
1320     }
1321 }
1322 
1323 void GitPlugin::branchList()
1324 {
1325     showNonModalDialog(currentState().topLevel(), m_branchDialog);
1326 }
1327 
1328 void GitPlugin::remoteList()
1329 {
1330     showNonModalDialog(currentState().topLevel(), m_remoteDialog);
1331 }
1332 
1333 void GitPlugin::stashList()
1334 {
1335     showNonModalDialog(currentState().topLevel(), m_stashDialog);
1336 }
1337 
1338 void GitPlugin::updateActions(VcsBasePlugin::ActionState as)
1339 {
1340     const VcsBasePluginState state = currentState();
1341     const bool repositoryEnabled = state.hasTopLevel();
1342     if (m_stashDialog)
1343         m_stashDialog->refresh(state.topLevel(), false);
1344     if (m_branchDialog)
1345         m_branchDialog->refresh(state.topLevel(), false);
1346     if (m_remoteDialog)
1347         m_remoteDialog->refresh(state.topLevel(), false);
1348 
1349     m_commandLocator->setEnabled(repositoryEnabled);
1350     if (!enableMenuAction(as, m_menuAction))
1351         return;
1352     if (repositoryEnabled)
1353         updateVersionWarning();
1354     // Note: This menu is visible if there is no repository. Only
1355     // 'Create Repository'/'Show' actions should be available.
1356     const QString fileName = state.currentFileName();
1357     for (ParameterAction *fileAction : Utils::asConst(m_fileActions))
1358         fileAction->setParameter(fileName);
1359     // If the current file looks like a patch, offer to apply
1360     m_applyCurrentFilePatchAction->setParameter(state.currentPatchFileDisplayName());
1361     const QString projectName = state.currentProjectName();
1362     for (ParameterAction *projectAction : Utils::asConst(m_projectActions))
1363         projectAction->setParameter(projectName);
1364 
1365     for (QAction *repositoryAction : Utils::asConst(m_repositoryActions))
1366         repositoryAction->setEnabled(repositoryEnabled);
1367 
1368     m_submoduleUpdateAction->setVisible(repositoryEnabled
1369             && !m_gitClient->submoduleList(state.topLevel()).isEmpty());
1370 
1371     updateContinueAndAbortCommands();
1372     updateRepositoryBrowserAction();
1373 
1374     m_gerritPlugin->updateActions(state);
1375 }
1376 
1377 void GitPlugin::updateContinueAndAbortCommands()
1378 {
1379     if (currentState().hasTopLevel()) {
1380         GitClient::CommandInProgress gitCommandInProgress =
1381                 m_gitClient->checkCommandInProgress(currentState().topLevel());
1382 
1383         m_mergeToolAction->setVisible(gitCommandInProgress != GitClient::NoCommand);
1384         m_abortMergeAction->setVisible(gitCommandInProgress == GitClient::Merge);
1385         m_abortCherryPickAction->setVisible(gitCommandInProgress == GitClient::CherryPick);
1386         m_abortRevertAction->setVisible(gitCommandInProgress == GitClient::Revert);
1387         m_abortRebaseAction->setVisible(gitCommandInProgress == GitClient::Rebase
1388                                         || gitCommandInProgress == GitClient::RebaseMerge);
1389         m_skipRebaseAction->setVisible(gitCommandInProgress == GitClient::Rebase
1390                                         || gitCommandInProgress == GitClient::RebaseMerge);
1391         m_continueCherryPickAction->setVisible(gitCommandInProgress == GitClient::CherryPick);
1392         m_continueRevertAction->setVisible(gitCommandInProgress == GitClient::Revert);
1393         m_continueRebaseAction->setVisible(gitCommandInProgress == GitClient::Rebase
1394                                            || gitCommandInProgress == GitClient::RebaseMerge);
1395         m_fixupCommitAction->setEnabled(gitCommandInProgress == GitClient::NoCommand);
1396         m_interactiveRebaseAction->setEnabled(gitCommandInProgress == GitClient::NoCommand);
1397     } else {
1398         m_mergeToolAction->setVisible(false);
1399         m_abortMergeAction->setVisible(false);
1400         m_abortCherryPickAction->setVisible(false);
1401         m_abortRevertAction->setVisible(false);
1402         m_abortRebaseAction->setVisible(false);
1403         m_skipRebaseAction->setVisible(false);
1404         m_continueCherryPickAction->setVisible(false);
1405         m_continueRevertAction->setVisible(false);
1406         m_continueRebaseAction->setVisible(false);
1407     }
1408 }
1409 
1410 void GitPlugin::delayedPushToGerrit()
1411 {
1412     m_gerritPlugin->push(m_submitRepository);
1413 }
1414 
1415 void GitPlugin::updateBranches(const QString &repository)
1416 {
1417     if (m_branchDialog && m_branchDialog->isVisible())
1418         m_branchDialog->refreshIfSame(repository);
1419 }
1420 
1421 QObject *GitPlugin::remoteCommand(const QStringList &, const QString &workingDirectory,
1422                                   const QStringList &args)
1423 {
1424     if (!m_gitClient || args.isEmpty())
1425         return nullptr;
1426 
1427     const QString arg = args.first();
1428 
1429     QProcess process;
1430     process.setWorkingDirectory(workingDirectory);
1431     process.setProcessEnvironment(m_gitClient->processEnvironment());
1432 
1433     process.start(m_gitClient->vcsBinary().toString(), {"show", "--stat=80", arg});
1434     process.closeWriteChannel();
1435     if (!process.waitForFinished(5000))
1436         return nullptr;
1437 
1438     if (process.exitCode() != 0)
1439         return nullptr;
1440 
1441     m_gitClient->show(workingDirectory, arg);
1442     return Core::EditorManager::currentDocument();
1443 }
1444 
1445 void GitPlugin::updateRepositoryBrowserAction()
1446 {
1447     const bool repositoryEnabled = currentState().hasTopLevel();
1448     const bool hasRepositoryBrowserCmd
1449             = !client()->settings().stringValue(GitSettings::repositoryBrowserCmd).isEmpty();
1450     m_repositoryBrowserAction->setEnabled(repositoryEnabled && hasRepositoryBrowserCmd);
1451 }
1452 
1453 Gerrit::Internal::GerritPlugin *GitPlugin::gerritPlugin() const
1454 {
1455     return m_gerritPlugin;
1456 }
1457 
1458 #ifdef WITH_TESTS
1459 
1460 void GitPlugin::testStatusParsing_data()
1461 {
1462     QTest::addColumn<FileStates>("first");
1463     QTest::addColumn<FileStates>("second");
1464 
1465     QTest::newRow(" M") << FileStates(ModifiedFile) << FileStates(UnknownFileState);
1466     QTest::newRow(" D") << FileStates(DeletedFile) << FileStates(UnknownFileState);
1467     QTest::newRow(" T") << FileStates(TypeChangedFile) << FileStates(UnknownFileState);
1468     QTest::newRow("T ") << (TypeChangedFile | StagedFile) << FileStates(UnknownFileState);
1469     QTest::newRow("TM") << (TypeChangedFile | StagedFile) << FileStates(ModifiedFile);
1470     QTest::newRow("MT") << (ModifiedFile | StagedFile) << FileStates(TypeChangedFile);
1471     QTest::newRow("M ") << (ModifiedFile | StagedFile) << FileStates(UnknownFileState);
1472     QTest::newRow("MM") << (ModifiedFile | StagedFile) << FileStates(ModifiedFile);
1473     QTest::newRow("MD") << (ModifiedFile | StagedFile) << FileStates(DeletedFile);
1474     QTest::newRow("A ") << (AddedFile | StagedFile) << FileStates(UnknownFileState);
1475     QTest::newRow("AM") << (AddedFile | StagedFile) << FileStates(ModifiedFile);
1476     QTest::newRow("AD") << (AddedFile | StagedFile) << FileStates(DeletedFile);
1477     QTest::newRow("D ") << (DeletedFile | StagedFile) << FileStates(UnknownFileState);
1478     QTest::newRow("DM") << (DeletedFile | StagedFile) << FileStates(ModifiedFile);
1479     QTest::newRow("R ") << (RenamedFile | StagedFile) << FileStates(UnknownFileState);
1480     QTest::newRow("RM") << (RenamedFile | StagedFile) << FileStates(ModifiedFile);
1481     QTest::newRow("RD") << (RenamedFile | StagedFile) << FileStates(DeletedFile);
1482     QTest::newRow("C ") << (CopiedFile | StagedFile) << FileStates(UnknownFileState);
1483     QTest::newRow("CM") << (CopiedFile | StagedFile) << FileStates(ModifiedFile);
1484     QTest::newRow("CD") << (CopiedFile | StagedFile) << FileStates(DeletedFile);
1485     QTest::newRow("??") << FileStates(UntrackedFile) << FileStates(UnknownFileState);
1486 
1487     // Merges
1488     QTest::newRow("DD") << (DeletedFile | UnmergedFile | UnmergedUs | UnmergedThem) << FileStates(UnknownFileState);
1489     QTest::newRow("AA") << (AddedFile | UnmergedFile | UnmergedUs | UnmergedThem) << FileStates(UnknownFileState);
1490     QTest::newRow("UU") << (ModifiedFile | UnmergedFile | UnmergedUs | UnmergedThem) << FileStates(UnknownFileState);
1491     QTest::newRow("AU") << (AddedFile | UnmergedFile | UnmergedUs) << FileStates(UnknownFileState);
1492     QTest::newRow("UD") << (DeletedFile | UnmergedFile | UnmergedThem) << FileStates(UnknownFileState);
1493     QTest::newRow("UA") << (AddedFile | UnmergedFile | UnmergedThem) << FileStates(UnknownFileState);
1494     QTest::newRow("DU") << (DeletedFile | UnmergedFile | UnmergedUs) << FileStates(UnknownFileState);
1495 }
1496 
1497 void GitPlugin::testStatusParsing()
1498 {
1499     CommitData data;
1500     QFETCH(FileStates, first);
1501     QFETCH(FileStates, second);
1502     QString output = "## master...origin/master [ahead 1]\n";
1503     output += QString::fromLatin1(QTest::currentDataTag()) + " main.cpp\n";
1504     data.parseFilesFromStatus(output);
1505     QCOMPARE(data.files.at(0).first, first);
1506     if (second == UnknownFileState)
1507         QCOMPARE(data.files.size(), 1);
1508     else
1509         QCOMPARE(data.files.at(1).first, second);
1510 }
1511 
1512 void GitPlugin::testDiffFileResolving_data()
1513 {
1514     QTest::addColumn<QByteArray>("header");
1515     QTest::addColumn<QByteArray>("fileName");
1516 
1517     QTest::newRow("New") << QByteArray(
1518             "diff --git a/src/plugins/git/giteditor.cpp b/src/plugins/git/giteditor.cpp\n"
1519             "new file mode 100644\n"
1520             "index 0000000..40997ff\n"
1521             "--- /dev/null\n"
1522             "+++ b/src/plugins/git/giteditor.cpp\n"
1523             "@@ -0,0 +1,281 @@\n\n")
1524         << QByteArray("src/plugins/git/giteditor.cpp");
1525     QTest::newRow("Deleted") << QByteArray(
1526             "diff --git a/src/plugins/git/giteditor.cpp b/src/plugins/git/giteditor.cpp\n"
1527             "deleted file mode 100644\n"
1528             "index 40997ff..0000000\n"
1529             "--- a/src/plugins/git/giteditor.cpp\n"
1530             "+++ /dev/null\n"
1531             "@@ -1,281 +0,0 @@\n\n")
1532         << QByteArray("src/plugins/git/giteditor.cpp");
1533     QTest::newRow("Normal") << QByteArray(
1534             "diff --git a/src/plugins/git/giteditor.cpp b/src/plugins/git/giteditor.cpp\n"
1535             "index 69e0b52..8fc974d 100644\n"
1536             "--- a/src/plugins/git/giteditor.cpp\n"
1537             "+++ b/src/plugins/git/giteditor.cpp\n"
1538             "@@ -49,6 +49,8 @@\n\n")
1539         << QByteArray("src/plugins/git/giteditor.cpp");
1540 }
1541 
1542 void GitPlugin::testDiffFileResolving()
1543 {
1544     VcsBaseEditorWidget::testDiffFileResolving(editorParameters[3].id);
1545 }
1546 
1547 void GitPlugin::testLogResolving()
1548 {
1549     QByteArray data(
1550                 "commit 50a6b54c03219ad74b9f3f839e0321be18daeaf6 (HEAD, origin/master)\n"
1551                 "Merge: 3587b51 bc93ceb\n"
1552                 "Author: Junio C Hamano <gitster@pobox.com>\n"
1553                 "Date:   Fri Jan 25 12:53:31 2013 -0800\n"
1554                 "\n"
1555                 "   Merge branch 'for-junio' of git://bogomips.org/git-svn\n"
1556                 "    \n"
1557                 "    * 'for-junio' of git://bogomips.org/git-svn:\n"
1558                 "      git-svn: Simplify calculation of GIT_DIR\n"
1559                 "      git-svn: cleanup sprintf usage for uppercasing hex\n"
1560                 "\n"
1561                 "commit 3587b513bafd7a83d8c816ac1deed72b5e3a27e9\n"
1562                 "Author: Junio C Hamano <gitster@pobox.com>\n"
1563                 "Date:   Fri Jan 25 12:52:55 2013 -0800\n"
1564                 "\n"
1565                 "    Update draft release notes to 1.8.2\n"
1566                 "    \n"
1567                 "    Signed-off-by: Junio C Hamano <gitster@pobox.com>\n"
1568                 );
1569 
1570     VcsBaseEditorWidget::testLogResolving(editorParameters[1].id, data,
1571                             "50a6b54c - Merge branch 'for-junio' of git://bogomips.org/git-svn",
1572                             "3587b513 - Update draft release notes to 1.8.2");
1573 }
1574 #endif
1575 
1576 } // namespace Internal
1577 } // namespace Git
