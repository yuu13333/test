I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2021 The Qt Company Ltd.
4 ** Copyright (C) 2013 John Layt <jlayt@kde.org>
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 
42 #include "qtimezone.h"
43 #include "qtimezoneprivate_p.h"
44 #include "qtimezoneprivate_data_p.h"
45 
46 #include <private/qnumeric_p.h>
47 #include <qdatastream.h>
48 #include <qdebug.h>
49 
50 #include <algorithm>
51 
52 QT_BEGIN_NAMESPACE
53 
54 /*
55     Static utilities for looking up Windows ID tables
56 */
57 
58 static const int windowsDataTableSize = sizeof(windowsDataTable) / sizeof(QWindowsData) - 1;
59 static const int zoneDataTableSize = sizeof(zoneDataTable) / sizeof(QZoneData) - 1;
60 static const int utcDataTableSize = sizeof(utcDataTable) / sizeof(QUtcData) - 1;
61 
62 
63 static const QZoneData *zoneData(quint16 index)
64 {
65     Q_ASSERT(index < zoneDataTableSize);
66     return &zoneDataTable[index];
67 }
68 
69 static const QWindowsData *windowsData(quint16 index)
70 {
71     Q_ASSERT(index < windowsDataTableSize);
72     return &windowsDataTable[index];
73 }
74 
75 static const QUtcData *utcData(quint16 index)
76 {
77     Q_ASSERT(index < utcDataTableSize);
78     return &utcDataTable[index];
79 }
80 
81 // Return the Windows ID literal for a given QWindowsData
82 static QByteArrayView windowsId(const QWindowsData *windowsData)
83 {
84     return (windowsIdData + windowsData->windowsIdIndex);
85 }
86 
87 // Return the IANA ID literal for a given QWindowsData
88 static QByteArray ianaId(const QWindowsData *windowsData)
89 {
90     return (ianaIdData + windowsData->ianaIdIndex);
91 }
92 
93 // Return the IANA ID literal for a given QZoneData
94 static QByteArrayView ianaId(const QZoneData *zoneData)
95 {
96     return (ianaIdData + zoneData->ianaIdIndex);
97 }
98 
99 static QByteArrayView utcId(const QUtcData *utcData)
100 {
101     return (ianaIdData + utcData->ianaIdIndex);
102 }
103 
104 static quint16 toWindowsIdKey(const QByteArray &winId)
105 {
106     for (quint16 i = 0; i < windowsDataTableSize; ++i) {
107         const QWindowsData *data = windowsData(i);
108         if (windowsId(data) == winId)
109             return data->windowsIdKey;
110     }
111     return 0;
112 }
113 
114 static QByteArray toWindowsIdLiteral(quint16 windowsIdKey)
115 {
116     for (quint16 i = 0; i < windowsDataTableSize; ++i) {
117         const QWindowsData *data = windowsData(i);
118         if (data->windowsIdKey == windowsIdKey)
119             return windowsId(data).toByteArray();
120     }
121     return QByteArray();
122 }
123 
124 /*
125     Base class implementing common utility routines, only intantiate for a null tz.
126 */
127 
128 QTimeZonePrivate::QTimeZonePrivate()
129 {
130 }
131 
132 QTimeZonePrivate::QTimeZonePrivate(const QTimeZonePrivate &other)
133     : QSharedData(other), m_id(other.m_id)
134 {
135 }
136 
137 QTimeZonePrivate::~QTimeZonePrivate()
138 {
139 }
140 
141 QTimeZonePrivate *QTimeZonePrivate::clone() const
142 {
143     return new QTimeZonePrivate(*this);
144 }
145 
146 bool QTimeZonePrivate::operator==(const QTimeZonePrivate &other) const
147 {
148     // TODO Too simple, but need to solve problem of comparing different derived classes
149     // Should work for all System and ICU classes as names guaranteed unique, but not for Simple.
150     // Perhaps once all classes have working transitions can compare full list?
151     return (m_id == other.m_id);
152 }
153 
154 bool QTimeZonePrivate::operator!=(const QTimeZonePrivate &other) const
155 {
156     return !(*this == other);
157 }
158 
159 bool QTimeZonePrivate::isValid() const
160 {
161     return !m_id.isEmpty();
162 }
163 
164 QByteArray QTimeZonePrivate::id() const
165 {
166     return m_id;
167 }
168 
169 QLocale::Territory QTimeZonePrivate::territory() const
170 {
171     // Default fall-back mode, use the zoneTable to find Region of known Zones
172     for (int i = 0; i < zoneDataTableSize; ++i) {
173         const QZoneData *data = zoneData(i);
174         QLatin1String view(ianaId(data));
175         for (QLatin1String token : view.tokenize(QLatin1String(" "))) {
176             if (token == QLatin1String(m_id.data(), m_id.size()))
177                 return QLocale::Territory(data->territory);
178         }
179     }
180     return QLocale::AnyTerritory;
181 }
182 
183 QString QTimeZonePrivate::comment() const
184 {
185     return QString();
186 }
187 
188 QString QTimeZonePrivate::displayName(qint64 atMSecsSinceEpoch,
189                                       QTimeZone::NameType nameType,
190                                       const QLocale &locale) const
191 {
192     if (nameType == QTimeZone::OffsetName)
193         return isoOffsetFormat(offsetFromUtc(atMSecsSinceEpoch));
194 
195     if (isDaylightTime(atMSecsSinceEpoch))
196         return displayName(QTimeZone::DaylightTime, nameType, locale);
197     else
198         return displayName(QTimeZone::StandardTime, nameType, locale);
199 }
200 
201 QString QTimeZonePrivate::displayName(QTimeZone::TimeType timeType,
202                                       QTimeZone::NameType nameType,
203                                       const QLocale &locale) const
204 {
205     Q_UNUSED(timeType);
206     Q_UNUSED(nameType);
207     Q_UNUSED(locale);
208     return QString();
209 }
210 
211 QString QTimeZonePrivate::abbreviation(qint64 atMSecsSinceEpoch) const
212 {
213     Q_UNUSED(atMSecsSinceEpoch);
214     return QString();
215 }
216 
217 int QTimeZonePrivate::offsetFromUtc(qint64 atMSecsSinceEpoch) const
218 {
219     const int std = standardTimeOffset(atMSecsSinceEpoch);
220     const int dst = daylightTimeOffset(atMSecsSinceEpoch);
221     const int bad = invalidSeconds();
222     return std == bad || dst == bad ? bad : std + dst;
223 }
224 
225 int QTimeZonePrivate::standardTimeOffset(qint64 atMSecsSinceEpoch) const
226 {
227     Q_UNUSED(atMSecsSinceEpoch);
228     return invalidSeconds();
229 }
230 
231 int QTimeZonePrivate::daylightTimeOffset(qint64 atMSecsSinceEpoch) const
232 {
233     Q_UNUSED(atMSecsSinceEpoch);
234     return invalidSeconds();
235 }
236 
237 bool QTimeZonePrivate::hasDaylightTime() const
238 {
239     return false;
240 }
241 
242 bool QTimeZonePrivate::isDaylightTime(qint64 atMSecsSinceEpoch) const
243 {
244     Q_UNUSED(atMSecsSinceEpoch);
245     return false;
246 }
247 
248 QTimeZonePrivate::Data QTimeZonePrivate::data(qint64 forMSecsSinceEpoch) const
249 {
250     Q_UNUSED(forMSecsSinceEpoch);
251     return invalidData();
252 }
253 
254 // Private only method for use by QDateTime to convert local msecs to epoch msecs
255 QTimeZonePrivate::Data QTimeZonePrivate::dataForLocalTime(qint64 forLocalMSecs, int hint) const
256 {
257 #if !defined(Q_OS_ANDROID) || defined(Q_OS_ANDROID_EMBEDDED)
258     // The Android back-end's hasDaylightTime() is only true for zones with
259     // transitions in the future; we need it to mean "has ever had a transition"
260     // though, so can't trust it here.
261     if (!hasDaylightTime()) // No DST means same offset for all local msecs
262         return data(forLocalMSecs - standardTimeOffset(forLocalMSecs) * 1000);
263 #endif
264 
265     /*
266       We need a UTC time at which to ask for the offset, in order to be able to
267       add that offset to forLocalMSecs, to get the UTC time we
268       need. Fortunately, no time-zone offset is more than 14 hours; and DST
269       transitions happen (much) more than thirty-two hours apart.  So sampling
270       offset sixteen hours each side gives us information we can be sure
271       brackets the correct time and at most one DST transition.
272     */
273     std::integral_constant<qint64, 16 * 3600 * 1000> sixteenHoursInMSecs;
274     static_assert(-sixteenHoursInMSecs / 1000 < QTimeZone::MinUtcOffsetSecs
275                   && sixteenHoursInMSecs / 1000 > QTimeZone::MaxUtcOffsetSecs);
276     using Bound = std::numeric_limits<qint64>;
277     qint64 millis;
278     const qint64 recent =
279         sub_overflow(forLocalMSecs, sixteenHoursInMSecs, &millis)
280         ? Bound::min() : millis;
281     const qint64 imminent =
282         add_overflow(forLocalMSecs, sixteenHoursInMSecs, &millis)
283         ? Bound::max() : millis;
284     // At most one of those took the boundary value:
285     Q_ASSERT(recent < imminent && sixteenHoursInMSecs < imminent - recent);
286     /*
287       Offsets are Local - UTC, positive to the east of Greenwich, negative to
288       the west; DST offset always exceeds standard offset, when DST applies.
289       When we have offsets on either side of a transition, the lower one is
290       standard, the higher is DST.
291 
292       Non-DST transitions (jurisdictions changing time-zone and time-zones
293       changing their standard offset, typically) are described below as if they
294       were DST transitions (since these are more usual and familiar); the code
295       mostly concerns itself with offsets from UTC, described in terms of the
296       common case for changes in that.  If there is no actual change in offset
297       (e.g. a DST transition cancelled by a standard offset change), this code
298       should handle it gracefully; without transitions, it'll see early == late
299       and take the easy path; with transitions, tran and nextTran get the
300       correct UTC time as atMSecsSinceEpoch so comparing to nextStart selects
301       the right one.  In all other cases, the transition changes offset and the
302       reasoning that applies to DST applies just the same.  Aside from hinting,
303       the only thing that looks at DST-ness at all, other than inferred from
304       offset changes, is the case without transition data handling an invalid
305       time in the gap that a transition passed over.
306 
307       The handling of hint (see below) is apt to go wrong in non-DST
308       transitions.  There isn't really a great deal we can hope to do about that
309       without adding yet more unreliable complexity to the heuristics in use for
310       already obscure corner-cases.
311      */
312 
313     /*
314       The hint (really a QDateTimePrivate::DaylightStatus) is > 0 if caller
315       thinks we're in DST, 0 if in standard.  A value of -2 means never-DST, so
316       should have been handled above; if it slips through, it's wrong but we
317       should probably treat it as standard anyway (never-DST means
318       always-standard, after all).  If the hint turns out to be wrong, fall back
319       on trying the other possibility: which makes it harmless to treat -1
320       (meaning unknown) as standard (i.e. try standard first, then try DST).  In
321       practice, away from a transition, the only difference hint makes is to
322       which candidate we try first: if the hint is wrong (or unknown and
323       standard fails), we'll try the other candidate and it'll work.
324 
325       For the obscure (and invalid) case where forLocalMSecs falls in a
326       spring-forward's missing hour, a common case is that we started with a
327       date/time for which the hint was valid and adjusted it naively; for that
328       case, we should correct the adjustment by shunting across the transition
329       into where hint is wrong.  So half-way through the gap, arrived at from
330       the DST side, should be read as an hour earlier, in standard time; but, if
331       arrived at from the standard side, should be read as an hour later, in
332       DST.  (This shall be wrong in some cases; for example, when a country
333       changes its transition dates and changing a date/time by more than six
334       months lands it on a transition.  However, these cases are even more
335       obscure than those where the heuristic is good.)
336      */
337 
338     if (hasTransitions()) {
339         /*
340           We have transitions.
341 
342           Each transition gives the offsets to use until the next; so we need the
343           most recent transition before the time forLocalMSecs describes.  If it
344           describes a time *in* a transition, we'll need both that transition and
345           the one before it.  So find one transition that's probably after (and not
346           much before, otherwise) and another that's definitely before, then work
347           out which one to use.  When both or neither work on forLocalMSecs, use
348           hint to disambiguate.
349         */
350 
351         // Get a transition definitely before the local MSecs; usually all we need.
352         // Only around the transition times might we need another.
353         Data tran = previousTransition(recent);
354         Q_ASSERT(forLocalMSecs < 0 || // Pre-epoch TZ info may be unavailable
355                  forLocalMSecs - tran.offsetFromUtc * 1000 >= tran.atMSecsSinceEpoch);
356         Data nextTran = nextTransition(tran.atMSecsSinceEpoch);
357         /*
358           Now walk those forward until they bracket forLocalMSecs with transitions.
359 
360           One of the transitions should then be telling us the right offset to use.
361           In a transition, we need the transition before it (to describe the run-up
362           to the transition) and the transition itself; so we need to stop when
363           nextTran is that transition.
364         */
365         while (nextTran.atMSecsSinceEpoch != invalidMSecs()
366                && forLocalMSecs > nextTran.atMSecsSinceEpoch + nextTran.offsetFromUtc * 1000) {
367             Data newTran = nextTransition(nextTran.atMSecsSinceEpoch);
368             if (newTran.atMSecsSinceEpoch == invalidMSecs()
369                 || newTran.atMSecsSinceEpoch + newTran.offsetFromUtc * 1000 > imminent) {
370                 // Definitely not a relevant tansition: too far in the future.
371                 break;
372             }
373             tran = nextTran;
374             nextTran = newTran;
375         }
376 
377         // Check we do *really* have transitions for this zone:
378         if (tran.atMSecsSinceEpoch != invalidMSecs()) {
379             /* So now tran is definitely before ... */
380             Q_ASSERT(forLocalMSecs < 0
381                      || forLocalMSecs - tran.offsetFromUtc * 1000 > tran.atMSecsSinceEpoch);
382             // Work out the UTC value it would make sense to return if using tran:
383             tran.atMSecsSinceEpoch = forLocalMSecs - tran.offsetFromUtc * 1000;
384             // If we know of no transition after it, the answer is easy:
385             const qint64 nextStart = nextTran.atMSecsSinceEpoch;
386             if (nextStart == invalidMSecs())
387                 return tran;
388 
389             /*
390               ... and nextTran is either after or only slightly before. We're
391               going to interpret one as standard time, the other as DST
392               (although the transition might in fact be a change in standard
393               offset, or a change in DST offset, e.g. to/from double-DST). Our
394               hint tells us which of those to use (defaulting to standard if no
395               hint): try it first; if that fails, try the other; if both fail,
396               life's tricky.
397             */
398             // Work out the UTC value it would make sense to return if using nextTran:
399             nextTran.atMSecsSinceEpoch = forLocalMSecs - nextTran.offsetFromUtc * 1000;
400 
401             // If both or neither have zero DST, treat the one with lower offset as standard:
402             const bool nextIsDst = !nextTran.daylightTimeOffset == !tran.daylightTimeOffset
403                 ? tran.offsetFromUtc < nextTran.offsetFromUtc : nextTran.daylightTimeOffset;
404             // If that agrees with hint > 0, our first guess is to use nextTran; else tran.
405             const bool nextFirst = nextIsDst == (hint > 0) && nextStart != invalidMSecs();
406             for (int i = 0; i < 2; i++) {
407                 /*
408                   On the first pass, the case we consider is what hint told us to expect
409                   (except when hint was -1 and didn't actually tell us what to expect),
410                   so it's likely right.  We only get a second pass if the first failed,
411                   by which time the second case, that we're trying, is likely right.
412                 */
413                 if (nextFirst ? i == 0 : i) {
414                     if (nextStart <= nextTran.atMSecsSinceEpoch)
415                         return nextTran;
416                 } else {
417                     // If next is invalid, nextFirst is false, to route us here first:
418                     if (nextStart > tran.atMSecsSinceEpoch)
419                         return tran;
420                 }
421             }
422 
423             /*
424               Neither is valid (e.g. in a spring-forward's gap) and
425               nextTran.atMSecsSinceEpoch < nextStart <= tran.atMSecsSinceEpoch, so
426               0 < tran.atMSecsSinceEpoch - nextTran.atMSecsSinceEpoch
427               = (nextTran.offsetFromUtc - tran.offsetFromUtc) * 1000
428             */
429             int dstStep = (nextTran.offsetFromUtc - tran.offsetFromUtc) * 1000;
430             Q_ASSERT(dstStep > 0); // How else could we get here ?
431             if (nextFirst) { // hint thought we needed nextTran, so use tran
432                 tran.atMSecsSinceEpoch -= dstStep;
433                 return tran;
434             }
435             nextTran.atMSecsSinceEpoch += dstStep;
436             return nextTran;
437         }
438         // Before first transition, or system has transitions but not for this zone.
439         // Try falling back to offsetFromUtc (works for before first transition, at least).
440     }
441 
442     /* Bracket and refine to discover offset. */
443     qint64 utcEpochMSecs;
444 
445     int early = offsetFromUtc(recent);
446     int late = offsetFromUtc(imminent);
447     if (early == late) { // > 99% of the time
448         if (sub_overflow(forLocalMSecs, early * qint64(1000), &utcEpochMSecs))
449             return invalidData(); // Outside representable range
450     } else {
451         // Close to a DST transition: early > late is near a fall-back,
452         // early < late is near a spring-forward.
453         const int offsetInDst = qMax(early, late);
454         const int offsetInStd = qMin(early, late);
455         // Candidate values for utcEpochMSecs (if forLocalMSecs is valid):
456         const qint64 forDst = forLocalMSecs - offsetInDst * 1000;
457         const qint64 forStd = forLocalMSecs - offsetInStd * 1000;
458         // Best guess at the answer:
459         const qint64 hinted = hint > 0 ? forDst : forStd;
460         if (offsetFromUtc(hinted) == (hint > 0 ? offsetInDst : offsetInStd)) {
461             utcEpochMSecs = hinted;
462         } else if (hint <= 0 && offsetFromUtc(forDst) == offsetInDst) {
463             utcEpochMSecs = forDst;
464         } else if (hint > 0 && offsetFromUtc(forStd) == offsetInStd) {
465             utcEpochMSecs = forStd;
466         } else {
467             // Invalid forLocalMSecs: in spring-forward gap.
468             const int dstStep = daylightTimeOffset(early < late ? imminent : recent) * 1000;
469             Q_ASSERT(dstStep); // There can't be a transition without it !
470             utcEpochMSecs = (hint > 0) ? forStd - dstStep : forDst + dstStep;
471         }
472     }
473 
474     return data(utcEpochMSecs);
475 }
476 
477 bool QTimeZonePrivate::hasTransitions() const
478 {
479     return false;
480 }
481 
482 QTimeZonePrivate::Data QTimeZonePrivate::nextTransition(qint64 afterMSecsSinceEpoch) const
483 {
484     Q_UNUSED(afterMSecsSinceEpoch);
485     return invalidData();
486 }
487 
488 QTimeZonePrivate::Data QTimeZonePrivate::previousTransition(qint64 beforeMSecsSinceEpoch) const
489 {
490     Q_UNUSED(beforeMSecsSinceEpoch);
491     return invalidData();
492 }
493 
494 QTimeZonePrivate::DataList QTimeZonePrivate::transitions(qint64 fromMSecsSinceEpoch,
495                                                          qint64 toMSecsSinceEpoch) const
496 {
497     DataList list;
498     if (toMSecsSinceEpoch >= fromMSecsSinceEpoch) {
499         // fromMSecsSinceEpoch is inclusive but nextTransitionTime() is exclusive so go back 1 msec
500         Data next = nextTransition(fromMSecsSinceEpoch - 1);
501         while (next.atMSecsSinceEpoch != invalidMSecs()
502                && next.atMSecsSinceEpoch <= toMSecsSinceEpoch) {
503             list.append(next);
504             next = nextTransition(next.atMSecsSinceEpoch);
505         }
506     }
507     return list;
508 }
509 
510 QByteArray QTimeZonePrivate::systemTimeZoneId() const
511 {
512     return QByteArray();
513 }
514 
515 bool QTimeZonePrivate::isTimeZoneIdAvailable(const QByteArray& ianaId) const
516 {
517     // Fall-back implementation, can be made faster in subclasses
518     const QList<QByteArray> tzIds = availableTimeZoneIds();
519     return std::binary_search(tzIds.begin(), tzIds.end(), ianaId);
520 }
521 
522 QList<QByteArray> QTimeZonePrivate::availableTimeZoneIds() const
523 {
524     return QList<QByteArray>();
525 }
526 
527 QList<QByteArray> QTimeZonePrivate::availableTimeZoneIds(QLocale::Territory territory) const
528 {
529     // Default fall-back mode, use the zoneTable to find Region of know Zones
530     QList<QByteArray> regions;
531 
532     // First get all Zones in the Zones table belonging to the Region
533     for (int i = 0; i < zoneDataTableSize; ++i) {
534         if (zoneData(i)->territory == territory) {
535             QLatin1String l1Id(ianaId(zoneData(i)));
536             for (auto l1 : l1Id.tokenize(QLatin1String(" ")))
537                 regions << QByteArray(l1.data(), l1.size());
538         }
539     }
540 
541     std::sort(regions.begin(), regions.end());
542     regions.erase(std::unique(regions.begin(), regions.end()), regions.end());
543 
544     // Then select just those that are available
545     const QList<QByteArray> all = availableTimeZoneIds();
546     QList<QByteArray> result;
547     result.reserve(qMin(all.size(), regions.size()));
548     std::set_intersection(all.begin(), all.end(), regions.cbegin(), regions.cend(),
549                           std::back_inserter(result));
550     return result;
551 }
552 
553 QList<QByteArray> QTimeZonePrivate::availableTimeZoneIds(int offsetFromUtc) const
554 {
555     // Default fall-back mode, use the zoneTable to find Offset of know Zones
556     QList<QByteArray> offsets;
557     // First get all Zones in the table using the Offset
558     for (int i = 0; i < windowsDataTableSize; ++i) {
559         const QWindowsData *winData = windowsData(i);
560         if (winData->offsetFromUtc == offsetFromUtc) {
561             for (int j = 0; j < zoneDataTableSize; ++j) {
562                 const QZoneData *data = zoneData(j);
563                 if (data->windowsIdKey == winData->windowsIdKey) {
564                     QLatin1String l1Id(ianaId(data));
565                     for (auto l1 : l1Id.tokenize(QLatin1String(" ")))
566                         offsets << QByteArray(l1.data(), l1.size());
567                 }
568             }
569         }
570     }
571 
572     std::sort(offsets.begin(), offsets.end());
573     offsets.erase(std::unique(offsets.begin(), offsets.end()), offsets.end());
574 
575     // Then select just those that are available
576     const QList<QByteArray> all = availableTimeZoneIds();
577     QList<QByteArray> result;
578     result.reserve(qMin(all.size(), offsets.size()));
579     std::set_intersection(all.begin(), all.end(), offsets.cbegin(), offsets.cend(),
580                           std::back_inserter(result));
581     return result;
582 }
583 
584 #ifndef QT_NO_DATASTREAM
585 void QTimeZonePrivate::serialize(QDataStream &ds) const
586 {
587     ds << QString::fromUtf8(m_id);
588 }
589 #endif // QT_NO_DATASTREAM
590 
591 // Static Utility Methods
592 
593 QTimeZonePrivate::Data QTimeZonePrivate::invalidData()
594 {
595     Data data;
596     data.atMSecsSinceEpoch = invalidMSecs();
597     data.offsetFromUtc = invalidSeconds();
598     data.standardTimeOffset = invalidSeconds();
599     data.daylightTimeOffset = invalidSeconds();
600     return data;
601 }
602 
603 QTimeZone::OffsetData QTimeZonePrivate::invalidOffsetData()
604 {
605     QTimeZone::OffsetData offsetData;
606     offsetData.atUtc = QDateTime();
607     offsetData.offsetFromUtc = invalidSeconds();
608     offsetData.standardTimeOffset = invalidSeconds();
609     offsetData.daylightTimeOffset = invalidSeconds();
610     return offsetData;
611 }
612 
613 QTimeZone::OffsetData QTimeZonePrivate::toOffsetData(const QTimeZonePrivate::Data &data)
614 {
615     QTimeZone::OffsetData offsetData = invalidOffsetData();
616     if (data.atMSecsSinceEpoch != invalidMSecs()) {
617         offsetData.atUtc = QDateTime::fromMSecsSinceEpoch(data.atMSecsSinceEpoch, Qt::UTC);
618         offsetData.offsetFromUtc = data.offsetFromUtc;
619         offsetData.standardTimeOffset = data.standardTimeOffset;
620         offsetData.daylightTimeOffset = data.daylightTimeOffset;
621         offsetData.abbreviation = data.abbreviation;
622     }
623     return offsetData;
624 }
625 
626 // Is the format of the ID valid ?
627 bool QTimeZonePrivate::isValidId(const QByteArray &ianaId)
628 {
629     /*
630       Main rules for defining TZ/IANA names as per ftp://ftp.iana.org/tz/code/Theory
631        1. Use only valid POSIX file name components
632        2. Within a file name component, use only ASCII letters, `.', `-' and `_'.
633        3. Do not use digits (except in a [+-]\d+ suffix, when used).
634        4. A file name component must not exceed 14 characters or start with `-'
635       However, the rules are really guidelines - a later one says
636        - Do not change established names if they only marginally violate the
637          above rules.
638       We may, therefore, need to be a bit slack in our check here, if we hit
639       legitimate exceptions in real time-zone databases.
640 
641       In particular, aliases such as "Etc/GMT+7" and "SystemV/EST5EDT" are valid
642       so we need to accept digits, ':', and '+'; aliases typically have the form
643       of POSIX TZ strings, which allow a suffix to a proper IANA name.  A POSIX
644       suffix starts with an offset (as in GMT+7) and may continue with another
645       name (as in EST5EDT, giving the DST name of the zone); a further offset is
646       allowed (for DST).  The ("hard to describe and [...] error-prone in
647       practice") POSIX form even allows a suffix giving the dates (and
648       optionally times) of the annual DST transitions.  Hopefully, no TZ aliases
649       go that far, but we at least need to accept an offset and (single
650       fragment) DST-name.
651 
652       But for the legacy complications, the following would be preferable if
653       QRegExp would work on QByteArrays directly:
654           const QRegExp rx(QStringLiteral("[a-z+._][a-z+._-]{,13}"
655                                       "(?:/[a-z+._][a-z+._-]{,13})*"
656                                           // Optional suffix:
657                                           "(?:[+-]?\d{1,2}(?::\d{1,2}){,2}" // offset
658                                              // one name fragment (DST):
659                                              "(?:[a-z+._][a-z+._-]{,13})?)"),
660                            Qt::CaseInsensitive);
661           return rx.exactMatch(ianaId);
662     */
663 
664     // Somewhat slack hand-rolled version:
665     const int MinSectionLength = 1;
666 #if defined(Q_OS_ANDROID) && !defined(Q_OS_ANDROID_EMBEDDED)
667     // Android has its own naming of zones.
668     // "Canada/East-Saskatchewan" has a 17-character second component.
669     const int MaxSectionLength = 17;
670 #else
671     const int MaxSectionLength = 14;
672 #endif
673     int sectionLength = 0;
674     for (const char *it = ianaId.begin(), * const end = ianaId.end(); it != end; ++it, ++sectionLength) {
675         const char ch = *it;
676         if (ch == '/') {
677             if (sectionLength < MinSectionLength || sectionLength > MaxSectionLength)
678                 return false; // violates (4)
679             sectionLength = -1;
680         } else if (ch == '-') {
681             if (sectionLength == 0)
682                 return false; // violates (4)
683         } else if (!(ch >= 'a' && ch <= 'z')
684                 && !(ch >= 'A' && ch <= 'Z')
685                 && !(ch == '_')
686                 && !(ch == '.')
687                    // Should ideally check these only happen as an offset:
688                 && !(ch >= '0' && ch <= '9')
689                 && !(ch == '+')
690                 && !(ch == ':')) {
691             return false; // violates (2)
692         }
693     }
694     if (sectionLength < MinSectionLength || sectionLength > MaxSectionLength)
695         return false; // violates (4)
696     return true;
697 }
698 
699 QString QTimeZonePrivate::isoOffsetFormat(int offsetFromUtc, QTimeZone::NameType mode)
700 {
701     if (mode == QTimeZone::ShortName && !offsetFromUtc)
702         return utcQString();
703 
704     char sign = '+';
705     if (offsetFromUtc < 0) {
706         sign = '-';
707         offsetFromUtc = -offsetFromUtc;
708     }
709     const int secs = offsetFromUtc % 60;
710     const int mins = (offsetFromUtc / 60) % 60;
711     const int hour = offsetFromUtc / 3600;
712     QString result = QString::asprintf("UTC%c%02d", sign, hour);
713     if (mode != QTimeZone::ShortName || secs || mins)
714         result += QString::asprintf(":%02d", mins);
715     if (mode == QTimeZone::LongName || secs)
716         result += QString::asprintf(":%02d", secs);
717     return result;
718 }
719 
720 QByteArray QTimeZonePrivate::ianaIdToWindowsId(const QByteArray &id)
721 {
722     for (int i = 0; i < zoneDataTableSize; ++i) {
723         const QZoneData *data = zoneData(i);
724         QLatin1String l1Id(ianaId(data));
725         for (auto l1 : l1Id.tokenize(QLatin1String(" "))) {
726             if (l1 == QByteArrayView(id))
727                 return toWindowsIdLiteral(data->windowsIdKey);
728         }
729     }
730     return QByteArray();
731 }
732 
733 QByteArray QTimeZonePrivate::windowsIdToDefaultIanaId(const QByteArray &windowsId)
734 {
735     const quint16 windowsIdKey = toWindowsIdKey(windowsId);
736     for (int i = 0; i < windowsDataTableSize; ++i) {
737         const QWindowsData *data = windowsData(i);
738         if (data->windowsIdKey == windowsIdKey)
739             return ianaId(data);
740     }
741     return QByteArray();
742 }
743 
744 QByteArray QTimeZonePrivate::windowsIdToDefaultIanaId(const QByteArray &windowsId,
745                                                        QLocale::Territory territory)
746 {
747     const QList<QByteArray> list = windowsIdToIanaIds(windowsId, territory);
748     if (list.count() > 0)
749         return list.first();
750     else
751         return QByteArray();
752 }
753 
754 QList<QByteArray> QTimeZonePrivate::windowsIdToIanaIds(const QByteArray &windowsId)
755 {
756     const quint16 windowsIdKey = toWindowsIdKey(windowsId);
757     QList<QByteArray> list;
758 
759     for (int i = 0; i < zoneDataTableSize; ++i) {
760         const QZoneData *data = zoneData(i);
761         if (data->windowsIdKey == windowsIdKey) {
762             QLatin1String l1Id(ianaId(data));
763             for (auto l1 : l1Id.tokenize(QLatin1String(" ")))
764                 list << QByteArray(l1.data(), l1.size());
765         }
766     }
767 
768     // Return the full list in alpha order
769     std::sort(list.begin(), list.end());
770     return list;
771 }
772 
773 QList<QByteArray> QTimeZonePrivate::windowsIdToIanaIds(const QByteArray &windowsId,
774                                                         QLocale::Territory territory)
775 {
776     const quint16 windowsIdKey = toWindowsIdKey(windowsId);
777     for (int i = 0; i < zoneDataTableSize; ++i) {
778         const QZoneData *data = zoneData(i);
779         // Return the region matches in preference order
780         if (data->windowsIdKey == windowsIdKey
781             && data->territory == static_cast<quint16>(territory)) {
782             QLatin1String l1Id(ianaId(data));
783             QList<QByteArray> list;
784             for (auto l1 : l1Id.tokenize(QLatin1String(" ")))
785                 list << QByteArray(l1.data(), l1.size());
786             return list;
787         }
788     }
789 
790     return QList<QByteArray>();
791 }
792 
793 // Define template for derived classes to reimplement so QSharedDataPointer clone() works correctly
794 template<> QTimeZonePrivate *QSharedDataPointer<QTimeZonePrivate>::clone()
795 {
796     return d->clone();
797 }
798 
799 /*
800     UTC Offset implementation, used when QT_NO_SYSTEMLOCALE set and ICU is not being used,
801     or for QDateTimes with a Qt:Spec of Qt::OffsetFromUtc.
802 */
803 
804 // Create default UTC time zone
805 QUtcTimeZonePrivate::QUtcTimeZonePrivate()
806 {
807     const QString name = utcQString();
808     init(utcQByteArray(), 0, name, name, QLocale::AnyTerritory, name);
809 }
810 
811 // Create a named UTC time zone
812 QUtcTimeZonePrivate::QUtcTimeZonePrivate(const QByteArray &id)
813 {
814     // Look for the name in the UTC list, if found set the values
815     for (int i = 0; i < utcDataTableSize; ++i) {
816         const QUtcData *data = utcData(i);
817         const QByteArrayView uid = utcId(data);
818         if (uid == id) {
819             QString name = QString::fromUtf8(id);
820             init(id, data->offsetFromUtc, name, name, QLocale::AnyTerritory, name);
821             break;
822         }
823     }
824 }
825 
826 qint64 QUtcTimeZonePrivate::offsetFromUtcString(const QByteArray &id)
827 {
828     // Convert reasonable UTC[+-]\d+(:\d+){,2} to offset in seconds.
829     // Assumption: id has already been tried as a CLDR UTC offset ID (notably
830     // including plain "UTC" itself) and a system offset ID; it's neither.
831     if (!id.startsWith("UTC") || id.size() < 5)
832         return invalidSeconds(); // Doesn't match
833     const char signChar = id.at(3);
834     if (signChar != '-' && signChar != '+')
835         return invalidSeconds(); // No sign
836     const int sign = signChar == '-' ? -1 : 1;
837 
838     const auto offsets = id.mid(4).split(':');
839     if (offsets.isEmpty() || offsets.size() > 3)
840         return invalidSeconds(); // No numbers, or too many.
841 
842     qint32 seconds = 0;
843     int prior = 0; // Number of fields parsed thus far
844     for (const auto &offset : offsets) {
845         bool ok = false;
846         unsigned short field = offset.toUShort(&ok);
847         // Bound hour above at 24, minutes and seconds at 60:
848         if (!ok || field >= (prior ? 60 : 24))
849             return invalidSeconds();
850         seconds = seconds * 60 + field;
851         ++prior;
852     }
853     while (prior++ < 3)
854         seconds *= 60;
855 
856     return seconds * sign;
857 }
858 
859 // Create offset from UTC
860 QUtcTimeZonePrivate::QUtcTimeZonePrivate(qint32 offsetSeconds)
861 {
862     QString utcId = isoOffsetFormat(offsetSeconds, QTimeZone::ShortName);
863     init(utcId.toUtf8(), offsetSeconds, utcId, utcId, QLocale::AnyTerritory, utcId);
864 }
865 
866 QUtcTimeZonePrivate::QUtcTimeZonePrivate(const QByteArray &zoneId, int offsetSeconds,
867                                          const QString &name, const QString &abbreviation,
868                                          QLocale::Territory territory, const QString &comment)
869 {
870     init(zoneId, offsetSeconds, name, abbreviation, territory, comment);
871 }
872 
873 QUtcTimeZonePrivate::QUtcTimeZonePrivate(const QUtcTimeZonePrivate &other)
874     : QTimeZonePrivate(other), m_name(other.m_name),
875       m_abbreviation(other.m_abbreviation),
876       m_comment(other.m_comment),
877       m_territory(other.m_territory),
878       m_offsetFromUtc(other.m_offsetFromUtc)
879 {
880 }
881 
882 QUtcTimeZonePrivate::~QUtcTimeZonePrivate()
883 {
884 }
885 
886 QUtcTimeZonePrivate *QUtcTimeZonePrivate::clone() const
887 {
888     return new QUtcTimeZonePrivate(*this);
889 }
890 
891 QTimeZonePrivate::Data QUtcTimeZonePrivate::data(qint64 forMSecsSinceEpoch) const
892 {
893     Data d;
894     d.abbreviation = m_abbreviation;
895     d.atMSecsSinceEpoch = forMSecsSinceEpoch;
896     d.standardTimeOffset = d.offsetFromUtc = m_offsetFromUtc;
897     d.daylightTimeOffset = 0;
898     return d;
899 }
900 
901 void QUtcTimeZonePrivate::init(const QByteArray &zoneId)
902 {
903     m_id = zoneId;
904 }
905 
906 void QUtcTimeZonePrivate::init(const QByteArray &zoneId, int offsetSeconds, const QString &name,
907                                const QString &abbreviation, QLocale::Territory territory,
908                                const QString &comment)
909 {
910     m_id = zoneId;
911     m_offsetFromUtc = offsetSeconds;
912     m_name = name;
913     m_abbreviation = abbreviation;
914     m_territory = territory;
915     m_comment = comment;
916 }
917 
918 QLocale::Territory QUtcTimeZonePrivate::territory() const
919 {
920     return m_territory;
921 }
922 
923 QString QUtcTimeZonePrivate::comment() const
924 {
925     return m_comment;
926 }
927 
928 QString QUtcTimeZonePrivate::displayName(QTimeZone::TimeType timeType,
929                                          QTimeZone::NameType nameType,
930                                          const QLocale &locale) const
931 {
932     Q_UNUSED(timeType);
933     Q_UNUSED(locale);
934     if (nameType == QTimeZone::ShortName)
935         return m_abbreviation;
936     else if (nameType == QTimeZone::OffsetName)
937         return isoOffsetFormat(m_offsetFromUtc);
938     return m_name;
939 }
940 
941 QString QUtcTimeZonePrivate::abbreviation(qint64 atMSecsSinceEpoch) const
942 {
943     Q_UNUSED(atMSecsSinceEpoch);
944     return m_abbreviation;
945 }
946 
947 qint32 QUtcTimeZonePrivate::standardTimeOffset(qint64 atMSecsSinceEpoch) const
948 {
949     Q_UNUSED(atMSecsSinceEpoch);
950     return m_offsetFromUtc;
951 }
952 
953 qint32 QUtcTimeZonePrivate::daylightTimeOffset(qint64 atMSecsSinceEpoch) const
954 {
955     Q_UNUSED(atMSecsSinceEpoch);
956     return 0;
957 }
958 
959 QByteArray QUtcTimeZonePrivate::systemTimeZoneId() const
960 {
961     return utcQByteArray();
962 }
963 
964 bool QUtcTimeZonePrivate::isTimeZoneIdAvailable(const QByteArray &ianaId) const
965 {
966     // Only the zone IDs supplied by CLDR and recognized by constructor.
967     for (int i = 0; i < utcDataTableSize; ++i) {
968         const QUtcData *data = utcData(i);
969         if (utcId(data) == ianaId)
970             return true;
971     }
972     // But see offsetFromUtcString(), which lets us accept some "unavailable" IDs.
973     return false;
974 }
975 
976 QList<QByteArray> QUtcTimeZonePrivate::availableTimeZoneIds() const
977 {
978     // Only the zone IDs supplied by CLDR and recognized by constructor.
979     QList<QByteArray> result;
980     result.reserve(utcDataTableSize);
981     for (int i = 0; i < utcDataTableSize; ++i)
982         result << utcId(utcData(i)).toByteArray();
983     // Not guaranteed to be sorted, so sort:
984     std::sort(result.begin(), result.end());
985     // ### assuming no duplicates
986     return result;
987 }
988 
989 QList<QByteArray> QUtcTimeZonePrivate::availableTimeZoneIds(QLocale::Territory country) const
990 {
991     // If AnyTerritory then is request for all non-region offset codes
992     if (country == QLocale::AnyTerritory)
993         return availableTimeZoneIds();
994     return QList<QByteArray>();
995 }
996 
997 QList<QByteArray> QUtcTimeZonePrivate::availableTimeZoneIds(qint32 offsetSeconds) const
998 {
999     // Only if it's present in CLDR. (May get more than one ID: UTC, UTC+00:00
1000     // and UTC-00:00 all have the same offset.)
1001     QList<QByteArray> result;
1002     for (int i = 0; i < utcDataTableSize; ++i) {
1003         const QUtcData *data = utcData(i);
1004         if (data->offsetFromUtc == offsetSeconds)
1005             result << utcId(data).toByteArray();
1006     }
1007     // Not guaranteed to be sorted, so sort:
1008     std::sort(result.begin(), result.end());
1009     // ### assuming no duplicates
1010     return result;
1011 }
1012 
1013 #ifndef QT_NO_DATASTREAM
1014 void QUtcTimeZonePrivate::serialize(QDataStream &ds) const
1015 {
1016     ds << QStringLiteral("OffsetFromUtc") << QString::fromUtf8(m_id) << m_offsetFromUtc << m_name
1017        << m_abbreviation << static_cast<qint32>(m_territory) << m_comment;
1018 }
1019 #endif // QT_NO_DATASTREAM
1020 
1021 QT_END_NAMESPACE
