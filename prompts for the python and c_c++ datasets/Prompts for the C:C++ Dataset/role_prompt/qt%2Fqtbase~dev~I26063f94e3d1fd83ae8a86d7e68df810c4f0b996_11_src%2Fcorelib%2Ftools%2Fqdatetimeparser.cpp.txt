I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include "qplatformdefs.h"
41 #include "private/qdatetimeparser_p.h"
42 
43 #include "qdatastream.h"
44 #include "qset.h"
45 #include "qlocale.h"
46 #include "qdatetime.h"
47 #include "qtimezone.h"
48 #include "qregexp.h"
49 #include "qdebug.h"
50 
51 //#define QDATETIMEPARSER_DEBUG
52 #if defined (QDATETIMEPARSER_DEBUG) && !defined(QT_NO_DEBUG_STREAM)
53 #  define QDTPDEBUG qDebug()
54 #  define QDTPDEBUGN qDebug
55 #else
56 #  define QDTPDEBUG if (false) qDebug()
57 #  define QDTPDEBUGN if (false) qDebug
58 #endif
59 
60 QT_BEGIN_NAMESPACE
61 
62 #ifndef QT_BOOTSTRAPPED
63 
64 QDateTimeParser::~QDateTimeParser()
65 {
66 }
67 
68 /*!
69   \internal
70   Gets the digit from a datetime. E.g.
71 
72   QDateTime var(QDate(2004, 02, 02));
73   int digit = getDigit(var, Year);
74   // digit = 2004
75 */
76 
77 int QDateTimeParser::getDigit(const QDateTime &t, int index) const
78 {
79     if (index < 0 || index >= sectionNodes.size()) {
80 #ifndef QT_NO_DATESTRING
81         qWarning("QDateTimeParser::getDigit() Internal error (%s %d)",
82                  qPrintable(t.toString()), index);
83 #else
84         qWarning("QDateTimeParser::getDigit() Internal error (%d)", index);
85 #endif
86         return -1;
87     }
88     const SectionNode &node = sectionNodes.at(index);
89     switch (node.type) {
90     case TimeZoneSection: return t.offsetFromUtc();
91     case Hour24Section: case Hour12Section: return t.time().hour();
92     case MinuteSection: return t.time().minute();
93     case SecondSection: return t.time().second();
94     case MSecSection: return t.time().msec();
95     case YearSection2Digits:
96     case YearSection: return t.date().year();
97     case MonthSection: return t.date().month();
98     case DaySection: return t.date().day();
99     case DayOfWeekSectionShort:
100     case DayOfWeekSectionLong: return t.date().day();
101     case AmPmSection: return t.time().hour() > 11 ? 1 : 0;
102 
103     default: break;
104     }
105 
106 #ifndef QT_NO_DATESTRING
107     qWarning("QDateTimeParser::getDigit() Internal error 2 (%s %d)",
108              qPrintable(t.toString()), index);
109 #else
110     qWarning("QDateTimeParser::getDigit() Internal error 2 (%d)", index);
111 #endif
112     return -1;
113 }
114 
115 /*!
116   \internal
117   Sets a digit in a datetime. E.g.
118 
119   QDateTime var(QDate(2004, 02, 02));
120   int digit = getDigit(var, Year);
121   // digit = 2004
122   setDigit(&var, Year, 2005);
123   digit = getDigit(var, Year);
124   // digit = 2005
125 */
126 
127 bool QDateTimeParser::setDigit(QDateTime &v, int index, int newVal) const
128 {
129     if (index < 0 || index >= sectionNodes.size()) {
130 #ifndef QT_NO_DATESTRING
131         qWarning("QDateTimeParser::setDigit() Internal error (%s %d %d)",
132                  qPrintable(v.toString()), index, newVal);
133 #else
134         qWarning("QDateTimeParser::setDigit() Internal error (%d %d)", index, newVal);
135 #endif
136         return false;
137     }
138     const SectionNode &node = sectionNodes.at(index);
139 
140     const QDate date = v.date();
141     const QTime time = v.time();
142     int year = date.year();
143     int month = date.month();
144     int day = date.day();
145     int hour = time.hour();
146     int minute = time.minute();
147     int second = time.second();
148     int msec = time.msec();
149     Qt::TimeSpec tspec = v.timeSpec();
150     // Only offset from UTC is amenable to setting an int value:
151     int offset = tspec == Qt::OffsetFromUTC ? v.offsetFromUtc() : 0;
152 
153     switch (node.type) {
154     case Hour24Section: case Hour12Section: hour = newVal; break;
155     case MinuteSection: minute = newVal; break;
156     case SecondSection: second = newVal; break;
157     case MSecSection: msec = newVal; break;
158     case YearSection2Digits:
159     case YearSection: year = newVal; break;
160     case MonthSection: month = newVal; break;
161     case DaySection:
162     case DayOfWeekSectionShort:
163     case DayOfWeekSectionLong:
164         if (newVal > 31) {
165             // have to keep legacy behavior. setting the
166             // date to 32 should return false. Setting it
167             // to 31 for february should return true
168             return false;
169         }
170         day = newVal;
171         break;
172     case TimeZoneSection:
173         if (newVal < absoluteMin(index) || newVal > absoluteMax(index))
174             return false;
175         tspec = Qt::OffsetFromUTC;
176         offset = newVal;
177         break;
178     case AmPmSection: hour = (newVal == 0 ? hour % 12 : (hour % 12) + 12); break;
179     default:
180         qWarning("QDateTimeParser::setDigit() Internal error (%s)",
181                  qPrintable(node.name()));
182         break;
183     }
184 
185     if (!(node.type & DaySectionMask)) {
186         if (day < cachedDay)
187             day = cachedDay;
188         const int max = QDate(year, month, 1).daysInMonth();
189         if (day > max) {
190             day = max;
191         }
192     }
193     if (QDate::isValid(year, month, day) && QTime::isValid(hour, minute, second, msec)) {
194         QDate date(year, month, day);
195         QTime time(hour, minute, second, msec);
196         if (tspec == Qt::TimeZone) // Preserve zone:
197             v = QDateTime(date, time, v.timeZone());
198         else
199             v = QDateTime(date, time, tspec, offset);
200         return true;
201     }
202     return false;
203 }
204 
205 
206 
207 /*!
208   \internal
209 
210   Returns the absolute maximum for a section
211 */
212 
213 int QDateTimeParser::absoluteMax(int s, const QDateTime &cur) const
214 {
215     const SectionNode &sn = sectionNode(s);
216     switch (sn.type) {
217         // No known zone > 14 hrs East of Greenwich (Kiritimati, Christmas Island, Kiribati)
218     case TimeZoneSection: return 14 * 3600;
219     case Hour24Section:
220     case Hour12Section: return 23; // this is special-cased in
221                                    // parseSection. We want it to be
222                                    // 23 for the stepBy case.
223     case MinuteSection:
224     case SecondSection: return 59;
225     case MSecSection: return 999;
226     case YearSection2Digits:
227     case YearSection: return 9999; // sectionMaxSize will prevent
228                                    // people from typing in a larger
229                                    // number in count == 2 sections.
230                                    // stepBy() will work on real years anyway
231     case MonthSection: return 12;
232     case DaySection:
233     case DayOfWeekSectionShort:
234     case DayOfWeekSectionLong: return cur.isValid() ? cur.date().daysInMonth() : 31;
235     case AmPmSection: return 1;
236     default: break;
237     }
238     qWarning("QDateTimeParser::absoluteMax() Internal error (%s)",
239              qPrintable(sn.name()));
240     return -1;
241 }
242 
243 /*!
244   \internal
245 
246   Returns the absolute minimum for a section
247 */
248 
249 int QDateTimeParser::absoluteMin(int s) const
250 {
251     const SectionNode &sn = sectionNode(s);
252     switch (sn.type) {
253         // No known zone > 12 hrs West of Greenwich (Baker Island, USA)
254     case TimeZoneSection: return -14 * 3600;
255     case Hour24Section:
256     case Hour12Section:
257     case MinuteSection:
258     case SecondSection:
259     case MSecSection:
260     case YearSection2Digits:
261     case YearSection: return 0;
262     case MonthSection:
263     case DaySection:
264     case DayOfWeekSectionShort:
265     case DayOfWeekSectionLong: return 1;
266     case AmPmSection: return 0;
267     default: break;
268     }
269     qWarning("QDateTimeParser::absoluteMin() Internal error (%s, %0x)",
270              qPrintable(sn.name()), sn.type);
271     return -1;
272 }
273 
274 /*!
275   \internal
276 
277   Returns the sectionNode for the Section \a s.
278 */
279 
280 const QDateTimeParser::SectionNode &QDateTimeParser::sectionNode(int sectionIndex) const
281 {
282     if (sectionIndex < 0) {
283         switch (sectionIndex) {
284         case FirstSectionIndex:
285             return first;
286         case LastSectionIndex:
287             return last;
288         case NoSectionIndex:
289             return none;
290         }
291     } else if (sectionIndex < sectionNodes.size()) {
292         return sectionNodes.at(sectionIndex);
293     }
294 
295     qWarning("QDateTimeParser::sectionNode() Internal error (%d)",
296              sectionIndex);
297     return none;
298 }
299 
300 QDateTimeParser::Section QDateTimeParser::sectionType(int sectionIndex) const
301 {
302     return sectionNode(sectionIndex).type;
303 }
304 
305 
306 /*!
307   \internal
308 
309   Returns the starting position for section \a s.
310 */
311 
312 int QDateTimeParser::sectionPos(int sectionIndex) const
313 {
314     return sectionPos(sectionNode(sectionIndex));
315 }
316 
317 int QDateTimeParser::sectionPos(const SectionNode &sn) const
318 {
319     switch (sn.type) {
320     case FirstSection: return 0;
321     case LastSection: return displayText().size() - 1;
322     default: break;
323     }
324     if (sn.pos == -1) {
325         qWarning("QDateTimeParser::sectionPos Internal error (%s)", qPrintable(sn.name()));
326         return -1;
327     }
328     return sn.pos;
329 }
330 
331 
332 /*!
333   \internal
334 
335   helper function for parseFormat. removes quotes that are
336   not escaped and removes the escaping on those that are escaped
337 
338 */
339 
340 static QString unquote(const QStringRef &str)
341 {
342     const QChar quote(QLatin1Char('\''));
343     const QChar slash(QLatin1Char('\\'));
344     const QChar zero(QLatin1Char('0'));
345     QString ret;
346     QChar status(zero);
347     const int max = str.size();
348     for (int i=0; i<max; ++i) {
349         if (str.at(i) == quote) {
350             if (status != quote) {
351                 status = quote;
352             } else if (!ret.isEmpty() && str.at(i - 1) == slash) {
353                 ret[ret.size() - 1] = quote;
354             } else {
355                 status = zero;
356             }
357         } else {
358             ret += str.at(i);
359         }
360     }
361     return ret;
362 }
363 /*!
364   \internal
365 
366   Parses the format \a newFormat. If successful, returns \c true and
367   sets up the format. Else keeps the old format and returns \c false.
368 
369 */
370 
371 static inline int countRepeat(const QString &str, int index, int maxCount)
372 {
373     int count = 1;
374     const QChar ch(str.at(index));
375     const int max = qMin(index + maxCount, str.size());
376     while (index + count < max && str.at(index + count) == ch) {
377         ++count;
378     }
379     return count;
380 }
381 
382 static inline void appendSeparator(QStringList *list, const QString &string, int from, int size, int lastQuote)
383 {
384     const QStringRef separator = string.midRef(from, size);
385     list->append(lastQuote >= from ? unquote(separator) : separator.toString());
386 }
387 
388 
389 bool QDateTimeParser::parseFormat(const QString &newFormat)
390 {
391     const QLatin1Char quote('\'');
392     const QLatin1Char slash('\\');
393     const QLatin1Char zero('0');
394     if (newFormat == displayFormat && !newFormat.isEmpty()) {
395         return true;
396     }
397 
398     QDTPDEBUGN("parseFormat: %s", newFormat.toLatin1().constData());
399 
400     QVector<SectionNode> newSectionNodes;
401     Sections newDisplay = 0;
402     QStringList newSeparators;
403     int i, index = 0;
404     int add = 0;
405     QChar status(zero);
406     const int max = newFormat.size();
407     int lastQuote = -1;
408     for (i = 0; i<max; ++i) {
409         if (newFormat.at(i) == quote) {
410             lastQuote = i;
411             ++add;
412             if (status != quote) {
413                 status = quote;
414             } else if (i > 0 && newFormat.at(i - 1) != slash) {
415                 status = zero;
416             }
417         } else if (status != quote) {
418             const char sect = newFormat.at(i).toLatin1();
419             switch (sect) {
420             case 'H':
421             case 'h':
422                 if (parserType != QVariant::Date) {
423                     const Section hour = (sect == 'h') ? Hour12Section : Hour24Section;
424                     const SectionNode sn = { hour, i - add, countRepeat(newFormat, i, 2), 0 };
425                     newSectionNodes.append(sn);
426                     appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
427                     i += sn.count - 1;
428                     index = i + 1;
429                     newDisplay |= hour;
430                 }
431                 break;
432             case 'm':
433                 if (parserType != QVariant::Date) {
434                     const SectionNode sn = { MinuteSection, i - add, countRepeat(newFormat, i, 2), 0 };
435                     newSectionNodes.append(sn);
436                     appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
437                     i += sn.count - 1;
438                     index = i + 1;
439                     newDisplay |= MinuteSection;
440                 }
441                 break;
442             case 's':
443                 if (parserType != QVariant::Date) {
444                     const SectionNode sn = { SecondSection, i - add, countRepeat(newFormat, i, 2), 0 };
445                     newSectionNodes.append(sn);
446                     appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
447                     i += sn.count - 1;
448                     index = i + 1;
449                     newDisplay |= SecondSection;
450                 }
451                 break;
452 
453             case 'z':
454                 if (parserType != QVariant::Date) {
455                     const SectionNode sn = { MSecSection, i - add, countRepeat(newFormat, i, 3) < 3 ? 1 : 3, 0 };
456                     newSectionNodes.append(sn);
457                     appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
458                     i += sn.count - 1;
459                     index = i + 1;
460                     newDisplay |= MSecSection;
461                 }
462                 break;
463             case 'A':
464             case 'a':
465                 if (parserType != QVariant::Date) {
466                     const bool cap = (sect == 'A');
467                     const SectionNode sn = { AmPmSection, i - add, (cap ? 1 : 0), 0 };
468                     newSectionNodes.append(sn);
469                     appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
470                     newDisplay |= AmPmSection;
471                     if (i + 1 < newFormat.size()
472                         && newFormat.at(i+1) == (cap ? QLatin1Char('P') : QLatin1Char('p'))) {
473                         ++i;
474                     }
475                     index = i + 1;
476                 }
477                 break;
478             case 'y':
479                 if (parserType != QVariant::Time) {
480                     const int repeat = countRepeat(newFormat, i, 4);
481                     if (repeat >= 2) {
482                         const SectionNode sn = { repeat == 4 ? YearSection : YearSection2Digits,
483                                                  i - add, repeat == 4 ? 4 : 2, 0 };
484                         newSectionNodes.append(sn);
485                         appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
486                         i += sn.count - 1;
487                         index = i + 1;
488                         newDisplay |= sn.type;
489                     }
490                 }
491                 break;
492             case 'M':
493                 if (parserType != QVariant::Time) {
494                     const SectionNode sn = { MonthSection, i - add, countRepeat(newFormat, i, 4), 0 };
495                     newSectionNodes.append(sn);
496                     newSeparators.append(unquote(newFormat.midRef(index, i - index)));
497                     i += sn.count - 1;
498                     index = i + 1;
499                     newDisplay |= MonthSection;
500                 }
501                 break;
502             case 'd':
503                 if (parserType != QVariant::Time) {
504                     const int repeat = countRepeat(newFormat, i, 4);
505                     const Section sectionType = (repeat == 4 ? DayOfWeekSectionLong
506                         : (repeat == 3 ? DayOfWeekSectionShort : DaySection));
507                     const SectionNode sn = { sectionType, i - add, repeat, 0 };
508                     newSectionNodes.append(sn);
509                     appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
510                     i += sn.count - 1;
511                     index = i + 1;
512                     newDisplay |= sn.type;
513                 }
514                 break;
515             case 't':
516                 if (parserType != QVariant::Time) {
517                     const SectionNode sn = { TimeZoneSection, i - add, countRepeat(newFormat, i, 4), 0 };
518                     newSectionNodes.append(sn);
519                     appendSeparator(&newSeparators, newFormat, index, i - index, lastQuote);
520                     i += sn.count - 1;
521                     index = i + 1;
522                     newDisplay |= TimeZoneSection;
523                 }
524                 break;
525             default:
526                 break;
527             }
528         }
529     }
530     if (newSectionNodes.isEmpty() && context == DateTimeEdit) {
531         return false;
532     }
533 
534     if ((newDisplay & (AmPmSection|Hour12Section)) == Hour12Section) {
535         const int count = newSectionNodes.size();
536         for (int i = 0; i < count; ++i) {
537             SectionNode &node = newSectionNodes[i];
538             if (node.type == Hour12Section)
539                 node.type = Hour24Section;
540         }
541     }
542 
543     if (index < max) {
544         appendSeparator(&newSeparators, newFormat, index, index - max, lastQuote);
545     } else {
546         newSeparators.append(QString());
547     }
548 
549     displayFormat = newFormat;
550     separators = newSeparators;
551     sectionNodes = newSectionNodes;
552     display = newDisplay;
553     last.pos = -1;
554 
555 //     for (int i=0; i<sectionNodes.size(); ++i) {
556 //         QDTPDEBUG << sectionNodes.at(i).name() << sectionNodes.at(i).count;
557 //     }
558 
559     QDTPDEBUG << newFormat << displayFormat;
560     QDTPDEBUGN("separators:\n'%s'", separators.join(QLatin1String("\n")).toLatin1().constData());
561 
562     return true;
563 }
564 
565 /*!
566   \internal
567 
568   Returns the size of section \a s.
569 */
570 
571 int QDateTimeParser::sectionSize(int sectionIndex) const
572 {
573     if (sectionIndex < 0)
574         return 0;
575 
576     if (sectionIndex >= sectionNodes.size()) {
577         qWarning("QDateTimeParser::sectionSize Internal error (%d)", sectionIndex);
578         return -1;
579     }
580 
581     if (sectionIndex == sectionNodes.size() - 1) {
582         // In some cases there is a difference between displayText() and text.
583         // e.g. when text is 2000/01/31 and displayText() is "2000/2/31" - text
584         // is the previous value and displayText() is the new value.
585         // The size difference is always due to leading zeroes.
586         int sizeAdjustment = 0;
587         const int displayTextSize = displayText().size();
588         if (displayTextSize != text.size()) {
589             // Any zeroes added before this section will affect our size.
590             int preceedingZeroesAdded = 0;
591             if (sectionNodes.size() > 1 && context == DateTimeEdit) {
592                 const auto begin = sectionNodes.cbegin();
593                 const auto end = begin + sectionIndex;
594                 for (auto sectionIt = begin; sectionIt != end; ++sectionIt)
595                     preceedingZeroesAdded += sectionIt->zeroesAdded;
596             }
597             sizeAdjustment = preceedingZeroesAdded;
598         }
599 
600         return displayTextSize + sizeAdjustment - sectionPos(sectionIndex) - separators.last().size();
601     } else {
602         return sectionPos(sectionIndex + 1) - sectionPos(sectionIndex)
603             - separators.at(sectionIndex + 1).size();
604     }
605 }
606 
607 
608 int QDateTimeParser::sectionMaxSize(Section s, int count) const
609 {
610 #ifndef QT_NO_TEXTDATE
611     int mcount = 12;
612 #endif
613 
614     switch (s) {
615     case FirstSection:
616     case NoSection:
617     case LastSection: return 0;
618 
619     case AmPmSection: {
620         const int lowerMax = qMin(getAmPmText(AmText, LowerCase).size(),
621                                   getAmPmText(PmText, LowerCase).size());
622         const int upperMax = qMin(getAmPmText(AmText, UpperCase).size(),
623                                   getAmPmText(PmText, UpperCase).size());
624         return qMin(4, qMin(lowerMax, upperMax));
625     }
626 
627     case Hour24Section:
628     case Hour12Section:
629     case MinuteSection:
630     case SecondSection:
631     case DaySection: return 2;
632     case DayOfWeekSectionShort:
633     case DayOfWeekSectionLong:
634 #ifdef QT_NO_TEXTDATE
635         return 2;
636 #else
637         mcount = 7;
638         Q_FALLTHROUGH();
639 #endif
640     case MonthSection:
641 #ifdef QT_NO_TEXTDATE
642         return 2;
643 #else
644         if (count <= 2)
645             return 2;
646 
647         {
648             int ret = 0;
649             const QLocale l = locale();
650             const QLocale::FormatType format = count == 4 ? QLocale::LongFormat : QLocale::ShortFormat;
651             for (int i=1; i<=mcount; ++i) {
652                 const QString str = (s == MonthSection
653                                      ? l.monthName(i, format)
654                                      : l.dayName(i, format));
655                 ret = qMax(str.size(), ret);
656             }
657             return ret;
658         }
659 #endif
660     case MSecSection: return 3;
661     case YearSection: return 4;
662     case YearSection2Digits: return 2;
663         // Arbitrarily many tokens (each up to 14 bytes) joined with / separators:
664     case TimeZoneSection: return std::numeric_limits<int>::max();
665 
666     case CalendarPopupSection:
667     case Internal:
668     case TimeSectionMask:
669     case DateSectionMask:
670     case HourSectionMask:
671     case YearSectionMask:
672     case DayOfWeekSectionMask:
673     case DaySectionMask:
674         qWarning("QDateTimeParser::sectionMaxSize: Invalid section %s",
675                  SectionNode::name(s).toLatin1().constData());
676 
677     case NoSectionIndex:
678     case FirstSectionIndex:
679     case LastSectionIndex:
680     case CalendarPopupIndex:
681         // these cases can't happen
682         break;
683     }
684     return -1;
685 }
686 
687 
688 int QDateTimeParser::sectionMaxSize(int index) const
689 {
690     const SectionNode &sn = sectionNode(index);
691     return sectionMaxSize(sn.type, sn.count);
692 }
693 
694 /*!
695   \internal
696 
697   Returns the text of section \a s. This function operates on the
698   arg text rather than edit->text().
699 */
700 
701 
702 QString QDateTimeParser::sectionText(const QString &text, int sectionIndex, int index) const
703 {
704     const SectionNode &sn = sectionNode(sectionIndex);
705     switch (sn.type) {
706     case NoSectionIndex:
707     case FirstSectionIndex:
708     case LastSectionIndex:
709         return QString();
710     default: break;
711     }
712 
713     return text.mid(index, sectionSize(sectionIndex));
714 }
715 
716 QString QDateTimeParser::sectionText(int sectionIndex) const
717 {
718     const SectionNode &sn = sectionNode(sectionIndex);
719     return sectionText(displayText(), sectionIndex, sn.pos);
720 }
721 
722 
723 #ifndef QT_NO_DATESTRING
724 
725 QDateTimeParser::ParsedSection
726 QDateTimeParser::parseSection(const QDateTime &currentValue, int sectionIndex,
727                               int offset, QString *text) const
728 {
729     ParsedSection result; // initially Invalid
730     const SectionNode &sn = sectionNode(sectionIndex);
731     if (sn.type & Internal) {
732         qWarning("QDateTimeParser::parseSection Internal error (%s %d)",
733                  qPrintable(sn.name()), sectionIndex);
734         return result;
735     }
736 
737     const int sectionmaxsize = sectionMaxSize(sectionIndex);
738     QStringRef sectionTextRef = text->midRef(offset, sectionmaxsize);
739 
740     QDTPDEBUG << "sectionValue for" << sn.name()
741               << "with text" << *text << "and (at" << offset
742               << ") st:" << sectionTextRef;
743 
744     switch (sn.type) {
745     case AmPmSection: {
746         QString sectiontext = sectionTextRef.toString();
747         int used;
748         const int ampm = findAmPm(sectiontext, sectionIndex, &used);
749         switch (ampm) {
750         case AM: // sectiontext == AM
751         case PM: // sectiontext == PM
752             result = ParsedSection(Acceptable, ampm, used);
753             break;
754         case PossibleAM: // sectiontext => AM
755         case PossiblePM: // sectiontext => PM
756             result = ParsedSection(Intermediate, ampm - 2, used);
757             break;
758         case PossibleBoth: // sectiontext => AM|PM
759             result = ParsedSection(Intermediate, 0, used);
760             break;
761         case Neither:
762             QDTPDEBUG << "invalid because findAmPm(" << sectiontext << ") returned -1";
763             break;
764         default:
765             QDTPDEBUGN("This should never happen (findAmPm returned %d)", ampm);
766             break;
767         }
768         if (result.state != Invalid)
769             text->replace(offset, used, sectiontext.constData(), used);
770         break; }
771     case TimeZoneSection:
772         result = findTimeZone(sectionTextRef, currentValue,
773                               absoluteMax(sectionIndex),
774                               absoluteMin(sectionIndex));
775         break;
776     case MonthSection:
777     case DayOfWeekSectionShort:
778     case DayOfWeekSectionLong:
779         if (sn.count >= 3) {
780             QString sectiontext = sectionTextRef.toString();
781             int num = 0, used = 0;
782             if (sn.type == MonthSection) {
783                 const QDate minDate = getMinimum().date();
784                 const int min = (currentValue.date().year() == minDate.year())
785                     ? minDate.month() : 1;
786                 num = findMonth(sectiontext.toLower(), min, sectionIndex, &sectiontext, &used);
787             } else {
788                 num = findDay(sectiontext.toLower(), 1, sectionIndex, &sectiontext, &used);
789             }
790 
791             result = ParsedSection(Intermediate, num, used);
792             if (num != -1) {
793                 text->replace(offset, used, sectiontext.constData(), used);
794                 if (used == sectiontext.size())
795                     result = ParsedSection(Acceptable, num, used);
796             }
797             break;
798         }
799         Q_FALLTHROUGH();
800     case DaySection:
801     case YearSection:
802     case YearSection2Digits:
803     case Hour12Section:
804     case Hour24Section:
805     case MinuteSection:
806     case SecondSection:
807     case MSecSection: {
808         int sectiontextSize = sectionTextRef.size();
809         if (sectiontextSize == 0) {
810             result = ParsedSection(Intermediate);
811         } else {
812             for (int i = 0; i < sectiontextSize; ++i) {
813                 if (sectionTextRef.at(i).isSpace())
814                     sectiontextSize = i; // which exits the loop
815             }
816 
817             const int absMax = absoluteMax(sectionIndex);
818             QLocale loc;
819             bool ok = true;
820             int last = -1, used = -1;
821 
822             const int max = qMin(sectionmaxsize, sectiontextSize);
823             QStringRef digitsStr = sectionTextRef.left(max);
824             for (int digits = max; digits >= 1; --digits) {
825                 digitsStr.truncate(digits);
826                 int tmp = (int)loc.toUInt(digitsStr, &ok);
827                 if (ok && sn.type == Hour12Section) {
828                     if (tmp > 12) {
829                         tmp = -1;
830                         ok = false;
831                     } else if (tmp == 12) {
832                         tmp = 0;
833                     }
834                 }
835                 if (ok && tmp <= absMax) {
836                     QDTPDEBUG << sectionTextRef.left(digits) << tmp << digits;
837                     last = tmp;
838                     used = digits;
839                     break;
840                 }
841             }
842 
843             if (last == -1) {
844                 QChar first(sectionTextRef.at(0));
845                 if (separators.at(sectionIndex + 1).startsWith(first))
846                     result = ParsedSection(Intermediate, 0, used);
847                 else
848                     QDTPDEBUG << "invalid because" << sectionTextRef << "can't become a uint" << last << ok;
849             } else {
850                 const FieldInfo fi = fieldInfo(sectionIndex);
851                 const bool done = (used == sectionmaxsize);
852                 if (!done && fi & Fraction) { // typing 2 in a zzz field should be .200, not .002
853                     for (int i = used; i < sectionmaxsize; ++i)
854                         last *= 10;
855                 }
856                 const int absMin = absoluteMin(sectionIndex);
857                 if (last < absMin) {
858                     if (!done) // reversed test to dodge QDTPDEBUG ugliness !
859                         result = ParsedSection(Intermediate, last, used);
860                     else
861                         QDTPDEBUG << "invalid because" << last << "is less than absoluteMin" << absMin;
862                 } else if (last > absMax) {
863                     result = ParsedSection(Intermediate, last, used);
864                 } else if (!done && (fi & (FixedWidth|Numeric)) == (FixedWidth|Numeric)) {
865                     if (skipToNextSection(sectionIndex, currentValue, digitsStr)) {
866                         const int missingZeroes = sectionmaxsize - digitsStr.size();
867                         result = ParsedSection(Acceptable, last, sectionmaxsize, missingZeroes);
868                         text->insert(offset, QString(missingZeroes, QLatin1Char('0')));
869                         sectionNodes[sectionIndex].zeroesAdded++;
870                     } else {
871                         result = ParsedSection(Intermediate, last, used);;
872                     }
873                 } else {
874                     result = ParsedSection(Acceptable, last, used);
875                 }
876             }
877         }
878         break; }
879     default:
880         qWarning("QDateTimeParser::parseSection Internal error (%s %d)",
881                  qPrintable(sn.name()), sectionIndex);
882         return result;
883     }
884     Q_ASSERT(result.state != Invalid || result.value == -1);
885 
886     return result;
887 }
888 
889 /*!
890   \internal
891 
892   Returns a date consistent with the given data on parts specified by known,
893   while staying as close to the given data as it can.  Returns an invalid date
894   when on valid date is consistent with the data.
895 */
896 
897 static QDate actualDate(QDateTimeParser::Sections known, int year, int year2digits,
898                         int month, int day, int dayofweek)
899 {
900     QDate actual(year, month, day);
901     if (actual.isValid() && year % 100 == year2digits && actual.dayOfWeek() == dayofweek)
902         return actual; // The obvious candidate is fine :-)
903 
904     if (dayofweek < 1 || dayofweek > 7) // Invalid: ignore
905         known &= ~QDateTimeParser::DayOfWeekSectionMask;
906 
907     // Assuming year > 0 ...
908     if (year % 100 != year2digits) {
909         if (known & QDateTimeParser::YearSection2Digits) {
910             // Over-ride year, even if specified:
911             year += year2digits - year % 100;
912             known &= ~QDateTimeParser::YearSection;
913         } else {
914             year2digits = year % 100;
915         }
916     }
917     Q_ASSERT(year % 100 == year2digits);
918 
919     if (month < 1) { // If invalid, clip to nearest valid and ignore in known.
920         month = 1;
921         known &= ~QDateTimeParser::MonthSection;
922     } else if (month > 12) {
923         month = 12;
924         known &= ~QDateTimeParser::MonthSection;
925     }
926 
927     QDate first(year, month, 1);
928     int last = known & QDateTimeParser::YearSection && known & QDateTimeParser::MonthSection
929         ? first.daysInMonth() : 0;
930     // If we also know day-of-week, tweak last to the last in the month that matches it:
931     if (last && known & QDateTimeParser::DayOfWeekSectionMask) {
932         int diff = (dayofweek - first.dayOfWeek() - last) % 7;
933         Q_ASSERT(diff <= 0); // C++11 specifies (-ve) % (+ve) to be <= 0.
934         last += diff;
935     }
936     if (day < 1) {
937         if (known & QDateTimeParser::DayOfWeekSectionMask && last) {
938             day = 1 + dayofweek - first.dayOfWeek();
939             if (day < 1)
940                 day += 7;
941         } else {
942             day = 1;
943         }
944         known &= ~QDateTimeParser::DaySection;
945     } else if (day > 31) {
946         day = last;
947         known &= ~QDateTimeParser::DaySection;
948     } else if (last && day > last && (known & QDateTimeParser::DaySection) == 0) {
949         day = last;
950     }
951 
952     actual = QDate(year, month, day);
953     if (!actual.isValid() // We can't do better than we have, in this case
954         || (known & QDateTimeParser::DaySection
955             && known & QDateTimeParser::MonthSection
956             && known & QDateTimeParser::YearSection) // ditto
957         || actual.dayOfWeek() == dayofweek // Good enough, use it.
958         || (known & QDateTimeParser::DayOfWeekSectionMask) == 0) { // No contradiction, use it.
959         return actual;
960     }
961 
962     /*
963       Now it gets trickier.
964 
965       We have some inconsistency in our data; we've been told day of week, but
966       it doesn't fit with our year, month and day.  At least one of these is
967       unknown, though: so we can fix day of week by tweaking it.
968     */
969 
970     if ((known & QDateTimeParser::DaySection) == 0) {
971         // Relatively easy to fix.
972         day += dayofweek - actual.dayOfWeek();
973         if (day < 1)
974             day += 7;
975         else if (day > actual.daysInMonth())
976             day -= 7;
977         actual = QDate(year, month, day);
978         return actual;
979     }
980 
981     if ((known & QDateTimeParser::MonthSection) == 0) {
982         /*
983           Try possible month-offsets, m, preferring small; at least one (present
984           month doesn't work) and at most 11 (max month, 12, minus min, 1); try
985           in both directions, ignoring any offset that takes us out of range.
986         */
987         for (int m = 1; m < 12; m++) {
988             if (m < month) {
989                 actual = QDate(year, month - m, day);
990                 if (actual.dayOfWeek() == dayofweek)
991                     return actual;
992             }
993             if (m + month <= 12) {
994                 actual = QDate(year, month + m, day);
995                 if (actual.dayOfWeek() == dayofweek)
996                     return actual;
997             }
998         }
999         // Should only get here in corner cases; e.g. day == 31
1000         actual = QDate(year, month, day); // Restore from trial values.
1001     }
1002 
1003     if ((known & QDateTimeParser::YearSection) == 0) {
1004         if (known & QDateTimeParser::YearSection2Digits) {
1005             /*
1006               Two-digit year and month are specified; choice of century can only
1007               fix this if diff is in one of {1, 2, 5} or {2, 4, 6}; but not if
1008               diff is in the other.  It's also only reasonable to consider
1009               adjacent century, e.g. if year thinks it's 2012 and two-digit year
1010               is '97, it makes sense to consider 1997.  If either adjacent
1011               century does work, the other won't.
1012             */
1013             actual = QDate(year + 100, month, day);
1014             if (actual.dayOfWeek() == dayofweek)
1015                 return actual;
1016             actual = QDate(year - 100, month, day);
1017             if (actual.dayOfWeek() == dayofweek)
1018                 return actual;
1019         } else {
1020             // Offset by 7 is usually enough, but rare cases may need more:
1021             for (int y = 1; y < 12; y++) {
1022                 actual = QDate(year - y, month, day);
1023                 if (actual.dayOfWeek() == dayofweek)
1024                     return actual;
1025                 actual = QDate(year + y, month, day);
1026                 if (actual.dayOfWeek() == dayofweek)
1027                     return actual;
1028             }
1029         }
1030         actual = QDate(year, month, day); // Restore from trial values.
1031     }
1032 
1033     return actual; // It'll just have to do :-(
1034 }
1035 
1036 /*!
1037   \internal
1038 */
1039 
1040 static QTime actualTime(QDateTimeParser::Sections known,
1041                         int hour, int hour12, int ampm,
1042                         int minute, int second, int msec)
1043 {
1044     // If we have no conflict, or don't know enough to diagonose one, use this:
1045     QTime actual(hour, minute, second, msec);
1046     if (hour12 < 0 || hour12 > 12) { // ignore bogus value
1047         known &= ~QDateTimeParser::Hour12Section;
1048         hour12 = hour % 12;
1049     }
1050 
1051     if (ampm == -1 || (known & QDateTimeParser::AmPmSection) == 0) {
1052         if ((known & QDateTimeParser::Hour12Section) == 0 || hour % 12 == hour12)
1053             return actual;
1054 
1055         if ((known & QDateTimeParser::Hour24Section) == 0)
1056             hour = hour12 + (hour > 12 ? 12 : 0);
1057     } else {
1058         Q_ASSERT(ampm == 0 || ampm == 1);
1059         if (hour - hour12 == ampm * 12)
1060             return actual;
1061 
1062         if ((known & QDateTimeParser::Hour24Section) == 0
1063             && known & QDateTimeParser::Hour12Section) {
1064             hour = hour12 + ampm * 12;
1065         }
1066     }
1067     actual = QTime(hour, minute, second, msec);
1068     return actual;
1069 }
1070 
1071 /*!
1072   \internal
1073 */
1074 
1075 QDateTimeParser::StateNode QDateTimeParser::parse(QString &input, int &cursorPosition,
1076                                                   const QDateTime &defaultValue, bool fixup) const
1077 {
1078     const QDateTime minimum = getMinimum();
1079     const QDateTime maximum = getMaximum();
1080 
1081     State state = Acceptable;
1082 
1083     QDateTime finalValue;
1084     bool conflicts = false;
1085     const int sectionNodesCount = sectionNodes.size();
1086 
1087     QDTPDEBUG << "parse" << input;
1088     {
1089         int pos = 0;
1090         int year, month, day;
1091         const QDate defaultDate = defaultValue.date();
1092         const QTime defaultTime = defaultValue.time();
1093         defaultDate.getDate(&year, &month, &day);
1094         int year2digits = year % 100;
1095         int hour = defaultTime.hour();
1096         int hour12 = -1;
1097         int minute = defaultTime.minute();
1098         int second = defaultTime.second();
1099         int msec = defaultTime.msec();
1100         int dayofweek = defaultDate.dayOfWeek();
1101         Qt::TimeSpec tspec = defaultValue.timeSpec();
1102         int zoneOffset = 0; // In seconds; local - UTC
1103         QTimeZone timeZone;
1104         switch (tspec) {
1105         case Qt::OffsetFromUTC: // timeZone is ignored
1106             zoneOffset = defaultValue.offsetFromUtc();
1107             break;
1108         case Qt::TimeZone:
1109             timeZone = defaultValue.timeZone();
1110             if (timeZone.isValid()) {
1111                 zoneOffset = timeZone.offsetFromUtc(defaultValue);
1112             } // else: is there anything we can do about this ?
1113             break;
1114         default: // zoneOffset and timeZone are ignored
1115             break;
1116         }
1117 
1118         int ampm = -1;
1119         Sections isSet = NoSection;
1120 
1121         for (int index=0; state != Invalid && index<sectionNodesCount; ++index) {
1122             if (QStringRef(&input, pos, separators.at(index).size()) != separators.at(index)) {
1123                 QDTPDEBUG << "invalid because" << input.midRef(pos, separators.at(index).size())
1124                           << "!=" << separators.at(index)
1125                           << index << pos << currentSectionIndex;
1126                 state = Invalid;
1127                 goto end;
1128             }
1129             pos += separators.at(index).size();
1130             sectionNodes[index].pos = pos;
1131             int *current = 0;
1132             const SectionNode sn = sectionNodes.at(index);
1133             ParsedSection sect;
1134 
1135             {
1136                 const QDate date = actualDate(isSet, year, year2digits, month, day, dayofweek);
1137                 const QTime time = actualTime(isSet, hour, hour12, ampm, minute, second, msec);
1138                 sect = parseSection(tspec == Qt::TimeZone
1139                                     ? QDateTime(date, time, timeZone)
1140                                     : QDateTime(date, time, tspec, zoneOffset),
1141                                     index, pos, &input);
1142             }
1143             cursorPosition += sect.zeroes;
1144             QDTPDEBUG << "sectionValue" << sn.name() << input
1145                       << "pos" << pos << "used" << sect.used << stateName(sect.state);
1146             if (fixup && sect.state == Intermediate && sect.used < sn.count) {
1147                 const FieldInfo fi = fieldInfo(index);
1148                 if ((fi & (Numeric|FixedWidth)) == (Numeric|FixedWidth)) {
1149                     const QString newText = QString::fromLatin1("%1").arg(sect.value, sn.count, 10, QLatin1Char('0'));
1150                     input.replace(pos, sect.used, newText);
1151                     sect.used = sn.count;
1152                 }
1153             }
1154 
1155             state = qMin<State>(state, sect.state);
1156             if (state == Intermediate && context == FromString) {
1157                 state = Invalid;
1158                 break;
1159             }
1160 
1161             if (state != Invalid) {
1162                 switch (sn.type) {
1163                 case TimeZoneSection:
1164                     current = &zoneOffset;
1165                     if (sect.value != -1 && sect.used > 0) {
1166                         QStringRef zoneName = input.midRef(pos, sect.used);
1167                         Q_ASSERT(!zoneName.isEmpty()); // sect.used > 0
1168                         const QByteArray latinZone(zoneName.toLatin1());
1169                         timeZone = QTimeZone(latinZone);
1170                         Q_ASSERT(timeZone.isValid()); // checked where used was set
1171                         tspec = QTimeZone::isTimeZoneIdAvailable(latinZone)
1172                             ? Qt::TimeZone : Qt::OffsetFromUTC;
1173                     }
1174                     break;
1175                 case Hour24Section: current = &hour; break;
1176                 case Hour12Section: current = &hour12; break;
1177                 case MinuteSection: current = &minute; break;
1178                 case SecondSection: current = &second; break;
1179                 case MSecSection: current = &msec; break;
1180                 case YearSection: current = &year; break;
1181                 case YearSection2Digits: current = &year2digits; break;
1182                 case MonthSection: current = &month; break;
1183                 case DayOfWeekSectionShort:
1184                 case DayOfWeekSectionLong: current = &dayofweek; break;
1185                 case DaySection: current = &day; sect.value = qMax<int>(1, sect.value); break;
1186                 case AmPmSection: current = &ampm; break;
1187                 default:
1188                     qWarning("QDateTimeParser::parse Internal error (%s)",
1189                              qPrintable(sn.name()));
1190                     break;
1191                 }
1192 
1193                 if (sect.used > 0)
1194                     pos += sect.used;
1195                 QDTPDEBUG << index << sn.name() << "is set to"
1196                           << pos << "state is" << stateName(state);
1197 
1198                 if (!current) {
1199                     qWarning("QDateTimeParser::parse Internal error 2");
1200                     return StateNode();
1201                 }
1202                 if (isSet & sn.type && *current != sect.value) {
1203                     QDTPDEBUG << "CONFLICT " << sn.name() << *current << sect.value;
1204                     conflicts = true;
1205                     if (index != currentSectionIndex || sect.value == -1) {
1206                         continue;
1207                     }
1208                 }
1209                 if (sect.value != -1)
1210                     *current = sect.value;
1211 
1212                 // Record the present section:
1213                 isSet |= sn.type;
1214             }
1215         }
1216 
1217         if (state != Invalid && QStringRef(&input, pos, input.size() - pos) != separators.last()) {
1218             QDTPDEBUG << "invalid because" << input.midRef(pos)
1219                       << "!=" << separators.last() << pos;
1220             state = Invalid;
1221         }
1222 
1223         if (state != Invalid) {
1224             if (parserType != QVariant::Time) {
1225                 if (year % 100 != year2digits && (isSet & YearSection2Digits)) {
1226                     if (!(isSet & YearSection)) {
1227                         year = (year / 100) * 100;
1228                         year += year2digits;
1229                     } else {
1230                         conflicts = true;
1231                         const SectionNode &sn = sectionNode(currentSectionIndex);
1232                         if (sn.type == YearSection2Digits) {
1233                             year = (year / 100) * 100;
1234                             year += year2digits;
1235                         }
1236                     }
1237                 }
1238 
1239                 const QDate date(year, month, day);
1240                 const int diff = dayofweek - date.dayOfWeek();
1241                 if (diff != 0 && state == Acceptable && isSet & DayOfWeekSectionMask) {
1242                     if (isSet & DaySection)
1243                         conflicts = true;
1244                     const SectionNode &sn = sectionNode(currentSectionIndex);
1245                     if (sn.type & DayOfWeekSectionMask || currentSectionIndex == -1) {
1246                         // dayofweek should be preferred
1247                         day += diff;
1248                         if (day <= 0) {
1249                             day += 7;
1250                         } else if (day > date.daysInMonth()) {
1251                             day -= 7;
1252                         }
1253                         QDTPDEBUG << year << month << day << dayofweek
1254                                   << diff << QDate(year, month, day).dayOfWeek();
1255                     }
1256                 }
1257 
1258                 bool needfixday = false;
1259                 if (sectionType(currentSectionIndex) & DaySectionMask) {
1260                     cachedDay = day;
1261                 } else if (cachedDay > day) {
1262                     day = cachedDay;
1263                     needfixday = true;
1264                 }
1265 
1266                 if (!QDate::isValid(year, month, day)) {
1267                     if (day < 32) {
1268                         cachedDay = day;
1269                     }
1270                     if (day > 28 && QDate::isValid(year, month, 1)) {
1271                         needfixday = true;
1272                     }
1273                 }
1274                 if (needfixday) {
1275                     if (context == FromString) {
1276                         state = Invalid;
1277                         goto end;
1278                     }
1279                     if (state == Acceptable && fixday) {
1280                         day = qMin<int>(day, QDate(year, month, 1).daysInMonth());
1281 
1282                         const QLocale loc = locale();
1283                         for (int i=0; i<sectionNodesCount; ++i) {
1284                             const SectionNode sn = sectionNode(i);
1285                             if (sn.type & DaySection) {
1286                                 input.replace(sectionPos(sn), sectionSize(i), loc.toString(day));
1287                             } else if (sn.type & DayOfWeekSectionMask) {
1288                                 const int dayOfWeek = QDate(year, month, day).dayOfWeek();
1289                                 const QLocale::FormatType dayFormat =
1290                                     (sn.type == DayOfWeekSectionShort
1291                                      ? QLocale::ShortFormat : QLocale::LongFormat);
1292                                 const QString dayName(loc.dayName(dayOfWeek, dayFormat));
1293                                 input.replace(sectionPos(sn), sectionSize(i), dayName);
1294                             }
1295                         }
1296                     } else if (state > Intermediate) {
1297                         state = Intermediate;
1298                     }
1299                 }
1300             }
1301 
1302             if (parserType != QVariant::Date) {
1303                 if (isSet & Hour12Section) {
1304                     const bool hasHour = isSet & Hour24Section;
1305                     if (ampm == -1) {
1306                         if (hasHour) {
1307                             ampm = (hour < 12 ? 0 : 1);
1308                         } else {
1309                             ampm = 0; // no way to tell if this is am or pm so I assume am
1310                         }
1311                     }
1312                     hour12 = (ampm == 0 ? hour12 % 12 : (hour12 % 12) + 12);
1313                     if (!hasHour) {
1314                         hour = hour12;
1315                     } else if (hour != hour12) {
1316                         conflicts = true;
1317                     }
1318                 } else if (ampm != -1) {
1319                     if (!(isSet & (Hour24Section))) {
1320                         hour = (12 * ampm); // special case. Only ap section
1321                     } else if ((ampm == 0) != (hour < 12)) {
1322                         conflicts = true;
1323                     }
1324                 }
1325 
1326             }
1327 
1328             {
1329                 QDate date(year, month, day);
1330                 QTime time(hour, minute, second, msec);
1331                 finalValue = tspec == Qt::TimeZone
1332                     ? QDateTime(date, time, timeZone)
1333                     : QDateTime(date, time, tspec, zoneOffset);
1334             }
1335             QDTPDEBUG << year << month << day << hour << minute << second << msec;
1336         }
1337         QDTPDEBUGN("'%s' => '%s'(%s)", input.toLatin1().constData(),
1338                    finalValue.toString(QLatin1String("yyyy/MM/dd hh:mm:ss.zzz")).toLatin1().constData(),
1339                    stateName(state).toLatin1().constData());
1340     }
1341 end:
1342     if (finalValue.isValid()) {
1343         if (context != FromString && state != Invalid && finalValue < minimum) {
1344             const QLatin1Char space(' ');
1345             if (finalValue >= minimum)
1346                 qWarning("QDateTimeParser::parse Internal error 3 (%s %s)",
1347                          qPrintable(finalValue.toString()), qPrintable(minimum.toString()));
1348 
1349             bool done = false;
1350             state = Invalid;
1351             for (int i=0; i<sectionNodesCount && !done; ++i) {
1352                 const SectionNode &sn = sectionNodes.at(i);
1353                 QString t = sectionText(input, i, sn.pos).toLower();
1354                 if ((t.size() < sectionMaxSize(i) && (((int)fieldInfo(i) & (FixedWidth|Numeric)) != Numeric))
1355                     || t.contains(space)) {
1356                     switch (sn.type) {
1357                     case AmPmSection:
1358                         switch (findAmPm(t, i)) {
1359                         case AM:
1360                         case PM:
1361                             state = Acceptable;
1362                             done = true;
1363                             break;
1364                         case Neither:
1365                             state = Invalid;
1366                             done = true;
1367                             break;
1368                         case PossibleAM:
1369                         case PossiblePM:
1370                         case PossibleBoth: {
1371                             const QDateTime copy(finalValue.addSecs(12 * 60 * 60));
1372                             if (copy >= minimum && copy <= maximum) {
1373                                 state = Intermediate;
1374                                 done = true;
1375                             }
1376                             break; }
1377                         }
1378                         Q_FALLTHROUGH();
1379                     case MonthSection:
1380                         if (sn.count >= 3) {
1381                             const int finalMonth = finalValue.date().month();
1382                             int tmp = finalMonth;
1383                             // I know the first possible month makes the date too early
1384                             while ((tmp = findMonth(t, tmp + 1, i)) != -1) {
1385                                 const QDateTime copy(finalValue.addMonths(tmp - finalMonth));
1386                                 if (copy >= minimum && copy <= maximum)
1387                                     break; // break out of while
1388                             }
1389                             if (tmp == -1) {
1390                                 break;
1391                             }
1392                             state = Intermediate;
1393                             done = true;
1394                             break;
1395                         }
1396                         Q_FALLTHROUGH();
1397                     default: {
1398                         int toMin;
1399                         int toMax;
1400 
1401                         if (sn.type & TimeSectionMask) {
1402                             if (finalValue.daysTo(minimum) != 0) {
1403                                 break;
1404                             }
1405                             const QTime time = finalValue.time();
1406                             toMin = time.msecsTo(minimum.time());
1407                             if (finalValue.daysTo(maximum) > 0) {
1408                                 toMax = -1; // can't get to max
1409                             } else {
1410                                 toMax = time.msecsTo(maximum.time());
1411                             }
1412                         } else {
1413                             toMin = finalValue.daysTo(minimum);
1414                             toMax = finalValue.daysTo(maximum);
1415                         }
1416                         const int maxChange = sn.maxChange();
1417                         if (toMin > maxChange) {
1418                             QDTPDEBUG << "invalid because toMin > maxChange" << toMin
1419                                       << maxChange << t << finalValue << minimum;
1420                             state = Invalid;
1421                             done = true;
1422                             break;
1423                         } else if (toMax > maxChange) {
1424                             toMax = -1; // can't get to max
1425                         }
1426 
1427                         const int min = getDigit(minimum, i);
1428                         if (min == -1) {
1429                             qWarning("QDateTimeParser::parse Internal error 4 (%s)",
1430                                      qPrintable(sn.name()));
1431                             state = Invalid;
1432                             done = true;
1433                             break;
1434                         }
1435 
1436                         int max = toMax != -1 ? getDigit(maximum, i) : absoluteMax(i, finalValue);
1437                         int pos = cursorPosition - sn.pos;
1438                         if (pos < 0 || pos >= t.size())
1439                             pos = -1;
1440                         if (!potentialValue(t.simplified(), min, max, i, finalValue, pos)) {
1441                             QDTPDEBUG << "invalid because potentialValue(" << t.simplified() << min << max
1442                                       << sn.name() << "returned" << toMax << toMin << pos;
1443                             state = Invalid;
1444                             done = true;
1445                             break;
1446                         }
1447                         state = Intermediate;
1448                         done = true;
1449                         break; }
1450                     }
1451                 }
1452             }
1453         } else {
1454             if (context == FromString) {
1455                 // optimization
1456                 Q_ASSERT(maximum.date().toJulianDay() == 4642999);
1457                 if (finalValue.date().toJulianDay() > 4642999)
1458                     state = Invalid;
1459             } else {
1460                 if (finalValue > maximum)
1461                     state = Invalid;
1462             }
1463 
1464             QDTPDEBUG << "not checking intermediate because finalValue is" << finalValue << minimum << maximum;
1465         }
1466     }
1467     StateNode node;
1468     node.input = input;
1469     node.state = state;
1470     node.conflicts = conflicts;
1471     node.value = finalValue.toTimeSpec(spec);
1472     text = input;
1473     return node;
1474 }
1475 
1476 /*
1477   \internal
1478   \brief Returns the index in \a entries with the best prefix match to \a text
1479 
1480   Scans \a entries looking for an entry overlapping \a text as much as possible
1481   (an exact match beats any prefix match; a match of the full entry as prefix of
1482   text beats any entry but one matching a longer prefix; otherwise, the match of
1483   longest prefix wins, earlier entries beating later on a draw).  Records the
1484   length of overlap in *used (if \a used is non-NULL) and the first entry that
1485   overlapped this much in *usedText (if \a usedText is non-NULL).
1486  */
1487 static int findTextEntry(const QString &text, const QVector<QString> &entries, QString *usedText, int *used)
1488 {
1489     if (text.isEmpty())
1490         return -1;
1491 
1492     int bestMatch = -1;
1493     int bestCount = 0;
1494     for (int n = 0; n < entries.size(); ++n)
1495     {
1496         const QString &name = entries.at(n);
1497 
1498         const int limit = qMin(text.size(), name.size());
1499         int i = 0;
1500         while (i < limit && text.at(i) == name.at(i).toLower())
1501             ++i;
1502         // Full match beats an equal prefix match:
1503         if (i > bestCount || (i == bestCount && i == name.size())) {
1504             bestCount = i;
1505             bestMatch = n;
1506             if (i == name.size() && i == text.size())
1507                 break; // Exact match, name == text, wins.
1508         }
1509     }
1510     if (usedText && bestMatch != -1)
1511         *usedText = entries.at(bestMatch);
1512     if (used)
1513         *used = bestCount;
1514 
1515     return bestMatch;
1516 }
1517 
1518 /*!
1519   \internal
1520   finds the first possible monthname that \a str1 can
1521   match. Starting from \a index; str should already by lowered
1522 */
1523 
1524 int QDateTimeParser::findMonth(const QString &str1, int startMonth, int sectionIndex,
1525                                QString *usedMonth, int *used) const
1526 {
1527     const SectionNode &sn = sectionNode(sectionIndex);
1528     if (sn.type != MonthSection) {
1529         qWarning("QDateTimeParser::findMonth Internal error");
1530         return -1;
1531     }
1532 
1533     QLocale::FormatType type = sn.count == 3 ? QLocale::ShortFormat : QLocale::LongFormat;
1534     QLocale l = locale();
1535     QVector<QString> monthNames;
1536     monthNames.reserve(13 - startMonth);
1537     for (int month = startMonth; month <= 12; ++month)
1538         monthNames.append(l.monthName(month, type));
1539 
1540     const int index = findTextEntry(str1, monthNames, usedMonth, used);
1541     return index < 0 ? index : index + startMonth;
1542 }
1543 
1544 int QDateTimeParser::findDay(const QString &str1, int startDay, int sectionIndex, QString *usedDay, int *used) const
1545 {
1546     const SectionNode &sn = sectionNode(sectionIndex);
1547     if (!(sn.type & DaySectionMask)) {
1548         qWarning("QDateTimeParser::findDay Internal error");
1549         return -1;
1550     }
1551 
1552     QLocale::FormatType type = sn.count == 4 ? QLocale::LongFormat : QLocale::ShortFormat;
1553     QLocale l = locale();
1554     QVector<QString> daysOfWeek;
1555     daysOfWeek.reserve(8 - startDay);
1556     for (int day = startDay; day <= 7; ++day)
1557         daysOfWeek.append(l.dayName(day, type));
1558 
1559     const int index = findTextEntry(str1, daysOfWeek, usedDay, used);
1560     return index < 0 ? index : index + startDay;
1561 }
1562 
1563 /*!
1564   \internal
1565 
1566   Return's .value is zone's offset, zone time - UTC time, in seconds.
1567   See QTimeZonePrivate::isValidId() for the format of zone names.
1568  */
1569 QDateTimeParser::ParsedSection
1570 QDateTimeParser::findTimeZone(QStringRef str, const QDateTime &when,
1571                               int maxVal, int minVal) const
1572 {
1573     int index = 0, size = str.length();
1574     // Collect up plausibly-valid characters; let QTimeZone work out what's truly valid.
1575     while (index < size) {
1576         QChar here = str[index];
1577         if (here < 127
1578             && (here.isLetterOrNumber()
1579                 || here == '/' || here == '-'
1580                 || here == '_' || here == '.'
1581                 || here == '+' || here == ':'))
1582             index++;
1583         else
1584             break;
1585     }
1586 
1587     int offset = std::numeric_limits<int>::max(); // deliberately out of range
1588     Q_ASSERT(offset > 14 * 3600); // c.f. absoluteMax()
1589     while (index > 0) {
1590         str.truncate(index);
1591         QTimeZone zone(str.toLatin1());
1592         if (zone.isValid()) {
1593             offset = zone.offsetFromUtc(when);
1594             /*
1595               parseSection() and parse() assume -1 is an error code, but it
1596               would be a valid TZ offset; thankfully, it would be a perverse
1597               one, so just assert we aren't returning that ...  (We could
1598               probably safely assert that the offset is a multiple of 300,
1599               i.e. 5 minutes, but there *were* some time-zones, historically,
1600               violating that.)
1601             */
1602             Q_ASSERT(offset != -1);
1603             break;
1604         }
1605         index--; // maybe we collected too much ...
1606     }
1607 
1608     if (index > 0 && maxVal >= offset && offset >= minVal)
1609         return ParsedSection(Acceptable, offset, index);
1610 
1611     return ParsedSection();
1612 }
1613 
1614 /*!
1615   \internal
1616 
1617   Returns
1618   AM if str == tr("AM")
1619   PM if str == tr("PM")
1620   PossibleAM if str can become tr("AM")
1621   PossiblePM if str can become tr("PM")
1622   PossibleBoth if str can become tr("PM") and can become tr("AM")
1623   Neither if str can't become anything sensible
1624 */
1625 QDateTimeParser::AmPmFinder QDateTimeParser::findAmPm(QString &str, int sectionIndex, int *used) const
1626 {
1627     const SectionNode &s = sectionNode(sectionIndex);
1628     if (s.type != AmPmSection) {
1629         qWarning("QDateTimeParser::findAmPm Internal error");
1630         return Neither;
1631     }
1632     if (used)
1633         *used = str.size();
1634     if (QStringRef(&str).trimmed().isEmpty()) {
1635         return PossibleBoth;
1636     }
1637     const QLatin1Char space(' ');
1638     int size = sectionMaxSize(sectionIndex);
1639 
1640     enum {
1641         amindex = 0,
1642         pmindex = 1
1643     };
1644     QString ampm[2];
1645     ampm[amindex] = getAmPmText(AmText, s.count == 1 ? UpperCase : LowerCase);
1646     ampm[pmindex] = getAmPmText(PmText, s.count == 1 ? UpperCase : LowerCase);
1647     for (int i=0; i<2; ++i)
1648         ampm[i].truncate(size);
1649 
1650     QDTPDEBUG << "findAmPm" << str << ampm[0] << ampm[1];
1651 
1652     if (str.indexOf(ampm[amindex], 0, Qt::CaseInsensitive) == 0) {
1653         str = ampm[amindex];
1654         return AM;
1655     } else if (str.indexOf(ampm[pmindex], 0, Qt::CaseInsensitive) == 0) {
1656         str = ampm[pmindex];
1657         return PM;
1658     } else if (context == FromString || (str.count(space) == 0 && str.size() >= size)) {
1659         return Neither;
1660     }
1661     size = qMin(size, str.size());
1662 
1663     bool broken[2] = {false, false};
1664     for (int i=0; i<size; ++i) {
1665         if (str.at(i) != space) {
1666             for (int j=0; j<2; ++j) {
1667                 if (!broken[j]) {
1668                     int index = ampm[j].indexOf(str.at(i));
1669                     QDTPDEBUG << "looking for" << str.at(i)
1670                               << "in" << ampm[j] << "and got" << index;
1671                     if (index == -1) {
1672                         if (str.at(i).category() == QChar::Letter_Uppercase) {
1673                             index = ampm[j].indexOf(str.at(i).toLower());
1674                             QDTPDEBUG << "trying with" << str.at(i).toLower()
1675                                       << "in" << ampm[j] << "and got" << index;
1676                         } else if (str.at(i).category() == QChar::Letter_Lowercase) {
1677                             index = ampm[j].indexOf(str.at(i).toUpper());
1678                             QDTPDEBUG << "trying with" << str.at(i).toUpper()
1679                                       << "in" << ampm[j] << "and got" << index;
1680                         }
1681                         if (index == -1) {
1682                             broken[j] = true;
1683                             if (broken[amindex] && broken[pmindex]) {
1684                                 QDTPDEBUG << str << "didn't make it";
1685                                 return Neither;
1686                             }
1687                             continue;
1688                         } else {
1689                             str[i] = ampm[j].at(index); // fix case
1690                         }
1691                     }
1692                     ampm[j].remove(index, 1);
1693                 }
1694             }
1695         }
1696     }
1697     if (!broken[pmindex] && !broken[amindex])
1698         return PossibleBoth;
1699     return (!broken[amindex] ? PossibleAM : PossiblePM);
1700 }
1701 #endif // QT_NO_DATESTRING
1702 
1703 /*!
1704   \internal
1705   Max number of units that can be changed by this section.
1706 */
1707 
1708 int QDateTimeParser::SectionNode::maxChange() const
1709 {
1710     switch (type) {
1711         // Time. unit is msec
1712     case MSecSection: return 999;
1713     case SecondSection: return 59 * 1000;
1714     case MinuteSection: return 59 * 60 * 1000;
1715     case Hour24Section: case Hour12Section: return 59 * 60 * 60 * 1000;
1716 
1717         // Date. unit is day
1718     case DayOfWeekSectionShort:
1719     case DayOfWeekSectionLong: return 7;
1720     case DaySection: return 30;
1721     case MonthSection: return 365 - 31;
1722     case YearSection: return 9999 * 365;
1723     case YearSection2Digits: return 100 * 365;
1724     default:
1725         qWarning("QDateTimeParser::maxChange() Internal error (%s)",
1726                  qPrintable(name()));
1727     }
1728 
1729     return -1;
1730 }
1731 
1732 QDateTimeParser::FieldInfo QDateTimeParser::fieldInfo(int index) const
1733 {
1734     FieldInfo ret = 0;
1735     const SectionNode &sn = sectionNode(index);
1736     switch (sn.type) {
1737     case MSecSection:
1738         ret |= Fraction;
1739         Q_FALLTHROUGH();
1740     case SecondSection:
1741     case MinuteSection:
1742     case Hour24Section:
1743     case Hour12Section:
1744     case YearSection2Digits:
1745         ret |= AllowPartial;
1746         Q_FALLTHROUGH();
1747     case YearSection:
1748         ret |= Numeric;
1749         if (sn.count != 1)
1750             ret |= FixedWidth;
1751         break;
1752     case MonthSection:
1753     case DaySection:
1754         switch (sn.count) {
1755         case 2:
1756             ret |= FixedWidth;
1757             Q_FALLTHROUGH();
1758         case 1:
1759             ret |= (Numeric|AllowPartial);
1760             break;
1761         }
1762         break;
1763     case DayOfWeekSectionShort:
1764     case DayOfWeekSectionLong:
1765         if (sn.count == 3)
1766             ret |= FixedWidth;
1767         break;
1768     case AmPmSection:
1769         ret |= FixedWidth;
1770         break;
1771     case TimeZoneSection:
1772         break;
1773     default:
1774         qWarning("QDateTimeParser::fieldInfo Internal error 2 (%d %s %d)",
1775                  index, qPrintable(sn.name()), sn.count);
1776         break;
1777     }
1778     return ret;
1779 }
1780 
1781 QString QDateTimeParser::SectionNode::format() const
1782 {
1783     QChar fillChar;
1784     switch (type) {
1785     case AmPmSection: return count == 1 ? QLatin1String("AP") : QLatin1String("ap");
1786     case MSecSection: fillChar = QLatin1Char('z'); break;
1787     case SecondSection: fillChar = QLatin1Char('s'); break;
1788     case MinuteSection: fillChar = QLatin1Char('m'); break;
1789     case Hour24Section: fillChar = QLatin1Char('H'); break;
1790     case Hour12Section: fillChar = QLatin1Char('h'); break;
1791     case DayOfWeekSectionShort:
1792     case DayOfWeekSectionLong:
1793     case DaySection: fillChar = QLatin1Char('d'); break;
1794     case MonthSection: fillChar = QLatin1Char('M'); break;
1795     case YearSection2Digits:
1796     case YearSection: fillChar = QLatin1Char('y'); break;
1797     default:
1798         qWarning("QDateTimeParser::sectionFormat Internal error (%s)",
1799                  qPrintable(name(type)));
1800         return QString();
1801     }
1802     if (fillChar.isNull()) {
1803         qWarning("QDateTimeParser::sectionFormat Internal error 2");
1804         return QString();
1805     }
1806     return QString(count, fillChar);
1807 }
1808 
1809 
1810 /*!
1811   \internal
1812 
1813   Returns \c true if str can be modified to represent a
1814   number that is within min and max.
1815 */
1816 
1817 bool QDateTimeParser::potentialValue(const QStringRef &str, int min, int max, int index,
1818                                      const QDateTime &currentValue, int insert) const
1819 {
1820     if (str.isEmpty()) {
1821         return true;
1822     }
1823     const int size = sectionMaxSize(index);
1824     int val = (int)locale().toUInt(str);
1825     const SectionNode &sn = sectionNode(index);
1826     if (sn.type == YearSection2Digits) {
1827         const int year = currentValue.date().year();
1828         val += year - (year % 100);
1829     }
1830     if (val >= min && val <= max && str.size() == size) {
1831         return true;
1832     } else if (val > max) {
1833         return false;
1834     } else if (str.size() == size && val < min) {
1835         return false;
1836     }
1837 
1838     const int len = size - str.size();
1839     for (int i=0; i<len; ++i) {
1840         for (int j=0; j<10; ++j) {
1841             if (potentialValue(str + QLatin1Char('0' + j), min, max, index, currentValue, insert)) {
1842                 return true;
1843             } else if (insert >= 0) {
1844                 const QString tmp = str.left(insert) + QLatin1Char('0' + j) + str.mid(insert);
1845                 if (potentialValue(tmp, min, max, index, currentValue, insert))
1846                     return true;
1847             }
1848         }
1849     }
1850 
1851     return false;
1852 }
1853 
1854 /*!
1855   \internal
1856 */
1857 bool QDateTimeParser::skipToNextSection(int index, const QDateTime &current, const QStringRef &text) const
1858 {
1859     Q_ASSERT(text.size() < sectionMaxSize(index));
1860     const SectionNode &node = sectionNode(index);
1861     int min = absoluteMin(index);
1862     int max = absoluteMax(index, current);
1863     // Time-zone field is only numeric if given as offset from UTC:
1864     if (node.type != TimeZoneSection || current.timeSpec() == Qt::OffsetFromUTC) {
1865         const QDateTime maximum = getMaximum();
1866         const QDateTime minimum = getMinimum();
1867         Q_ASSERT(current >= minimum && current <= maximum);
1868 
1869         QDateTime tmp = current;
1870         setDigit(tmp, index, min);
1871         if (tmp < minimum)
1872             min = getDigit(minimum, index);
1873 
1874         setDigit(tmp, index, max);
1875         if (tmp > maximum)
1876             max = getDigit(maximum, index);
1877     }
1878     int pos = cursorPosition() - node.pos;
1879     if (pos < 0 || pos >= text.size())
1880         pos = -1;
1881 
1882     /*
1883       If the value potentially can become another valid entry we don't want to
1884       skip to the next. E.g. In a M field (month without leading 0) if you type
1885       1 we don't want to autoskip (there might be [012] following) but if you
1886       type 3 we do.
1887     */
1888     return !potentialValue(text, min, max, index, current, pos);
1889 }
1890 
1891 /*!
1892   \internal
1893   For debugging. Returns the name of the section \a s.
1894 */
1895 
1896 QString QDateTimeParser::SectionNode::name(QDateTimeParser::Section s)
1897 {
1898     switch (s) {
1899     case QDateTimeParser::AmPmSection: return QLatin1String("AmPmSection");
1900     case QDateTimeParser::DaySection: return QLatin1String("DaySection");
1901     case QDateTimeParser::DayOfWeekSectionShort: return QLatin1String("DayOfWeekSectionShort");
1902     case QDateTimeParser::DayOfWeekSectionLong: return QLatin1String("DayOfWeekSectionLong");
1903     case QDateTimeParser::Hour24Section: return QLatin1String("Hour24Section");
1904     case QDateTimeParser::Hour12Section: return QLatin1String("Hour12Section");
1905     case QDateTimeParser::MSecSection: return QLatin1String("MSecSection");
1906     case QDateTimeParser::MinuteSection: return QLatin1String("MinuteSection");
1907     case QDateTimeParser::MonthSection: return QLatin1String("MonthSection");
1908     case QDateTimeParser::SecondSection: return QLatin1String("SecondSection");
1909     case QDateTimeParser::TimeZoneSection: return QLatin1String("TimeZoneSection");
1910     case QDateTimeParser::YearSection: return QLatin1String("YearSection");
1911     case QDateTimeParser::YearSection2Digits: return QLatin1String("YearSection2Digits");
1912     case QDateTimeParser::NoSection: return QLatin1String("NoSection");
1913     case QDateTimeParser::FirstSection: return QLatin1String("FirstSection");
1914     case QDateTimeParser::LastSection: return QLatin1String("LastSection");
1915     default: return QLatin1String("Unknown section ") + QString::number(int(s));
1916     }
1917 }
1918 
1919 /*!
1920   \internal
1921   For debugging. Returns the name of the state \a s.
1922 */
1923 
1924 QString QDateTimeParser::stateName(State s) const
1925 {
1926     switch (s) {
1927     case Invalid: return QLatin1String("Invalid");
1928     case Intermediate: return QLatin1String("Intermediate");
1929     case Acceptable: return QLatin1String("Acceptable");
1930     default: return QLatin1String("Unknown state ") + QString::number(s);
1931     }
1932 }
1933 
1934 #ifndef QT_NO_DATESTRING
1935 bool QDateTimeParser::fromString(const QString &t, QDate *date, QTime *time) const
1936 {
1937     QDateTime val(QDate(1900, 1, 1), QDATETIMEEDIT_TIME_MIN);
1938     QString text = t;
1939     int copy = -1;
1940     const StateNode tmp = parse(text, copy, val, false);
1941     if (tmp.state != Acceptable || tmp.conflicts) {
1942         return false;
1943     }
1944     if (time) {
1945         const QTime t = tmp.value.time();
1946         if (!t.isValid()) {
1947             return false;
1948         }
1949         *time = t;
1950     }
1951 
1952     if (date) {
1953         const QDate d = tmp.value.date();
1954         if (!d.isValid()) {
1955             return false;
1956         }
1957         *date = d;
1958     }
1959     return true;
1960 }
1961 #endif // QT_NO_DATESTRING
1962 
1963 QDateTime QDateTimeParser::getMinimum() const
1964 {
1965     // Cache the most common case
1966     if (spec == Qt::LocalTime) {
1967         static const QDateTime localTimeMin(QDATETIMEEDIT_DATE_MIN, QDATETIMEEDIT_TIME_MIN, Qt::LocalTime);
1968         return localTimeMin;
1969     }
1970     return QDateTime(QDATETIMEEDIT_DATE_MIN, QDATETIMEEDIT_TIME_MIN, spec);
1971 }
1972 
1973 QDateTime QDateTimeParser::getMaximum() const
1974 {
1975     // Cache the most common case
1976     if (spec == Qt::LocalTime) {
1977         static const QDateTime localTimeMax(QDATETIMEEDIT_DATE_MAX, QDATETIMEEDIT_TIME_MAX, Qt::LocalTime);
1978         return localTimeMax;
1979     }
1980     return QDateTime(QDATETIMEEDIT_DATE_MAX, QDATETIMEEDIT_TIME_MAX, spec);
1981 }
1982 
1983 QString QDateTimeParser::getAmPmText(AmPm ap, Case cs) const
1984 {
1985     const QLocale loc = locale();
1986     QString raw = ap == AmText ? loc.amText() : loc.pmText();
1987     return cs == UpperCase ? raw.toUpper() : raw.toLower();
1988 }
1989 
1990 /*
1991   \internal
1992 
1993   I give arg2 preference because arg1 is always a QDateTime.
1994 */
1995 
1996 bool operator==(const QDateTimeParser::SectionNode &s1, const QDateTimeParser::SectionNode &s2)
1997 {
1998     return (s1.type == s2.type) && (s1.pos == s2.pos) && (s1.count == s2.count);
1999 }
2000 
2001 #endif // QT_BOOTSTRAPPED
2002 
2003 QT_END_NAMESPACE
