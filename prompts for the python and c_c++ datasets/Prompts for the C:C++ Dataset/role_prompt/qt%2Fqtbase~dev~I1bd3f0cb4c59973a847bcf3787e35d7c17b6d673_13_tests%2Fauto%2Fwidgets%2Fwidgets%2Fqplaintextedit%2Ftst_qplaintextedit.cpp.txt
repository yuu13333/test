I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the test suite of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
21 ** included in the packaging of this file. Please review the following
22 ** information to ensure the GNU General Public License requirements will
23 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
24 **
25 ** $QT_END_LICENSE$
26 **
27 ****************************************************************************/
28 
29 
30 #include <QTest>
31 #include <QSignalSpy>
32 
33 #include <qtextedit.h>
34 #include <qtextcursor.h>
35 #include <qtextlist.h>
36 #include <qdebug.h>
37 #include <qapplication.h>
38 #include <qclipboard.h>
39 #include <qtextbrowser.h>
40 #include <private/qwidgettextcontrol_p.h>
41 #include <private/qplaintextedit_p.h>
42 #include <qscrollbar.h>
43 #include <qtextobject.h>
44 #include <qmenu.h>
45 
46 #include <qabstracttextdocumentlayout.h>
47 #include <qtextdocumentfragment.h>
48 
49 #include "qplaintextedit.h"
50 #include "../../../shared/platformclipboard.h"
51 
52 //Used in copyAvailable
53 typedef QPair<Qt::Key, Qt::KeyboardModifier> keyPairType;
54 typedef QList<keyPairType> pairListType;
55 Q_DECLARE_METATYPE(keyPairType);
56 
57 QT_FORWARD_DECLARE_CLASS(QPlainTextEdit)
58 
59 class tst_QPlainTextEdit : public QObject
60 {
61     Q_OBJECT
62 public:
63     tst_QPlainTextEdit();
64 
65 public slots:
66     void init();
67     void cleanup();
68 private slots:
69     void getSetCheck();
70 #ifndef QT_NO_CLIPBOARD
71     void clearMustNotChangeClipboard();
72 #endif
73     void clearMustNotResetRootFrameMarginToDefault();
74     void paragSeparatorOnPlaintextAppend();
75 #ifndef QT_NO_CLIPBOARD
76     void selectAllSetsNotSelection();
77 #endif
78     void asciiTab();
79     void setDocument();
80     void emptyAppend();
81     void appendOnEmptyDocumentShouldReuseInitialParagraph();
82     void cursorPositionChanged();
83     void setTextCursor();
84 #ifndef QT_NO_CLIPBOARD
85     void undoAvailableAfterPaste();
86 #endif
87     void undoRedoAvailableRepetition();
88     void appendShouldNotTouchTheSelection();
89     void backspace();
90     void shiftBackspace();
91     void undoRedo();
92     void preserveCharFormatInAppend();
93 #ifndef QT_NO_CLIPBOARD
94     void copyAndSelectAllInReadonly();
95 #endif
96     void charWithAltOrCtrlModifier_data();
97     void charWithAltOrCtrlModifier();
98     void noPropertiesOnDefaultTextEditCharFormat();
99     void setPlainTextShouldEmitTextChangedOnce();
100     void overwriteMode();
101     void shiftDownInLineLastShouldSelectToEnd_data();
102     void shiftDownInLineLastShouldSelectToEnd();
103     void undoRedoShouldRepositionTextEditCursor();
104     void lineWrapModes();
105 #ifndef QT_NO_CURSOR
106     void mouseCursorShape();
107 #endif
108     void implicitClear();
109     void undoRedoAfterSetContent();
110     void numPadKeyNavigation();
111     void moveCursor();
112 #ifndef QT_NO_CLIPBOARD
113     void mimeDataReimplementations();
114 #endif
115     void shiftEnterShouldInsertLineSeparator();
116     void selectWordsFromStringsContainingSeparators_data();
117     void selectWordsFromStringsContainingSeparators();
118 #ifndef QT_NO_CLIPBOARD
119     void canPaste();
120     void copyAvailable_data();
121     void copyAvailable();
122 #endif
123     void ensureCursorVisibleOnInitialShow();
124     void setTextInsideResizeEvent();
125     void colorfulAppend();
126     void ensureVisibleWithRtl();
127     void preserveCharFormatAfterSetPlainText();
128     void extraSelections();
129     void adjustScrollbars();
130     void textObscuredByScrollbars();
131     void setTextPreservesUndoRedoEnabled();
132     void wordWrapProperty();
133     void lineWrapProperty();
134     void selectionChanged();
135     void blockCountChanged();
136     void insertAndScrollToBottom();
137     void inputMethodQueryImHints_data();
138     void inputMethodQueryImHints();
139 #if QT_CONFIG(regularexpression)
140     void findWithRegularExpression();
141     void findBackwardWithRegularExpression();
142     void findWithRegularExpressionReturnsFalseIfNoMoreResults();
143 #endif
144     void layoutAfterMultiLineRemove();
145     void undoCommandRemovesAndReinsertsBlock();
146     void taskQTBUG_43562_lineCountCrash();
147 #ifndef QT_NO_CONTEXTMENU
148     void contextMenu();
149 #endif
150     void inputMethodCursorRect();
151 #if QT_CONFIG(scrollbar)
152     void updateAfterChangeCenterOnScroll();
153 #endif
154 #ifndef QT_NO_CLIPBOARD
155     void updateCursorPositionAfterEdit();
156 #endif
157     void appendTextWhenInvisible();
158     void autoPlaceholderVisibility();
159 
160 private:
161     void createSelection();
162     int blockCount() const;
163     int lineCount() const;
164 
165     QPlainTextEdit *ed;
166     qreal rootFrameMargin;
167 };
168 
169 // Testing get/set functions
170 void tst_QPlainTextEdit::getSetCheck()
171 {
172     QPlainTextEdit obj1;
173     // QTextDocument * QPlainTextEdit::document()
174     // void QPlainTextEdit::setDocument(QTextDocument *)
175     QTextDocument *var1 = new QTextDocument;
176     var1->setDocumentLayout(new QPlainTextDocumentLayout(var1));
177     obj1.setDocument(var1);
178     QCOMPARE(var1, obj1.document());
179     obj1.setDocument((QTextDocument *)0);
180     QVERIFY(var1 != obj1.document()); // QPlainTextEdit creates a new document when setting 0
181     QVERIFY((QTextDocument *)0 != obj1.document());
182     delete var1;
183 
184 
185     // bool QPlainTextEdit::tabChangesFocus()
186     // void QPlainTextEdit::setTabChangesFocus(bool)
187     obj1.setTabChangesFocus(false);
188     QCOMPARE(false, obj1.tabChangesFocus());
189     obj1.setTabChangesFocus(true);
190     QCOMPARE(true, obj1.tabChangesFocus());
191 
192     // LineWrapMode QPlainTextEdit::lineWrapMode()
193     // void QPlainTextEdit::setLineWrapMode(LineWrapMode)
194     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::NoWrap));
195     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::NoWrap), obj1.lineWrapMode());
196     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::WidgetWidth));
197     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::WidgetWidth), obj1.lineWrapMode());
198 //     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedPixelWidth));
199 //     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedPixelWidth), obj1.lineWrapMode());
200 //     obj1.setLineWrapMode(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedColumnWidth));
201 //     QCOMPARE(QPlainTextEdit::LineWrapMode(QPlainTextEdit::FixedColumnWidth), obj1.lineWrapMode());
202 
203 
204     // bool QPlainTextEdit::overwriteMode()
205     // void QPlainTextEdit::setOverwriteMode(bool)
206     obj1.setOverwriteMode(false);
207     QCOMPARE(false, obj1.overwriteMode());
208     obj1.setOverwriteMode(true);
209     QCOMPARE(true, obj1.overwriteMode());
210 
211     // int QPlainTextEdit::tabStopWidth()
212     // void QPlainTextEdit::setTabStopWidth(int)
213     obj1.setTabStopDistance(0);
214     QCOMPARE(0, obj1.tabStopDistance());
215     obj1.setTabStopDistance(-1);
216     QCOMPARE(0, obj1.tabStopDistance()); // Makes no sense to set a negative tabstop value
217     obj1.setTabStopDistance(std::numeric_limits<qreal>::max());
218     QCOMPARE(std::numeric_limits<qreal>::max(), obj1.tabStopDistance());
219 }
220 
221 class QtTestDocumentLayout : public QAbstractTextDocumentLayout
222 {
223     Q_OBJECT
224 public:
225     inline QtTestDocumentLayout(QPlainTextEdit *edit, QTextDocument *doc, int &itCount)
226         : QAbstractTextDocumentLayout(doc), useBiggerSize(false), ed(edit), iterationCounter(itCount) {}
227 
228     virtual void draw(QPainter *, const QAbstractTextDocumentLayout::PaintContext &) override {}
229 
230     virtual int hitTest(const QPointF &, Qt::HitTestAccuracy ) const override { return 0; }
231 
232     virtual void documentChanged(int, int, int) override {}
233 
234     virtual int pageCount() const override { return 1; }
235 
236     virtual QSizeF documentSize() const override { return usedSize; }
237 
238     virtual QRectF frameBoundingRect(QTextFrame *) const override { return QRectF(); }
239     virtual QRectF blockBoundingRect(const QTextBlock &) const override { return QRectF(); }
240 
241     bool useBiggerSize;
242     QSize usedSize;
243 
244     QPlainTextEdit *ed;
245 
246     int &iterationCounter;
247 };
248 
249 tst_QPlainTextEdit::tst_QPlainTextEdit()
250 {}
251 
252 void tst_QPlainTextEdit::init()
253 {
254     ed = new QPlainTextEdit(0);
255     rootFrameMargin = ed->document()->documentMargin();
256 }
257 
258 void tst_QPlainTextEdit::cleanup()
259 {
260     delete ed;
261     ed = 0;
262 }
263 
264 
265 void tst_QPlainTextEdit::createSelection()
266 {
267     QTest::keyClicks(ed, "Hello World");
268     /* go to start */
269 #ifndef Q_OS_MAC
270     QTest::keyClick(ed, Qt::Key_Home, Qt::ControlModifier);
271 #else
272     QTest::keyClick(ed, Qt::Key_Home);
273 #endif
274     QCOMPARE(ed->textCursor().position(), 0);
275     /* select until end of text */
276 #ifndef Q_OS_MAC
277     QTest::keyClick(ed, Qt::Key_End, Qt::ControlModifier | Qt::ShiftModifier);
278 #else
279     QTest::keyClick(ed, Qt::Key_End, Qt::ShiftModifier);
280 #endif
281     QCOMPARE(ed->textCursor().position(), 11);
282 }
283 #ifndef QT_NO_CLIPBOARD
284 void tst_QPlainTextEdit::clearMustNotChangeClipboard()
285 {
286     if (!PlatformClipboard::isAvailable())
287         QSKIP("Clipboard not working with cron-started unit tests");
288 
289     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
290         QSKIP("Wayland: This fails. Figure out why.");
291 
292     ed->textCursor().insertText("Hello World");
293     QString txt("This is different text");
294     QApplication::clipboard()->setText(txt);
295     ed->clear();
296     QCOMPARE(QApplication::clipboard()->text(), txt);
297 }
298 #endif
299 
300 void tst_QPlainTextEdit::clearMustNotResetRootFrameMarginToDefault()
301 {
302     QCOMPARE(ed->document()->rootFrame()->frameFormat().margin(), rootFrameMargin);
303     ed->clear();
304     QCOMPARE(ed->document()->rootFrame()->frameFormat().margin(), rootFrameMargin);
305 }
306 
307 
308 void tst_QPlainTextEdit::paragSeparatorOnPlaintextAppend()
309 {
310     ed->appendPlainText("Hello\nWorld");
311     int cnt = 0;
312     QTextBlock blk = ed->document()->begin();
313     while (blk.isValid()) {
314         ++cnt;
315         blk = blk.next();
316     }
317     QCOMPARE(cnt, 2);
318 }
319 
320 #ifndef QT_NO_CLIPBOARD
321 void tst_QPlainTextEdit::selectAllSetsNotSelection()
322 {
323     if (!QApplication::clipboard()->supportsSelection())
324         QSKIP("Test only relevant for systems with selection");
325 
326     QApplication::clipboard()->setText(QString("foobar"), QClipboard::Selection);
327     QCOMPARE(QApplication::clipboard()->text(QClipboard::Selection), QString("foobar"));
328 
329     ed->insertPlainText("Hello World");
330     ed->selectAll();
331 
332     QCOMPARE(QApplication::clipboard()->text(QClipboard::Selection), QString::fromLatin1("foobar"));
333 }
334 #endif
335 
336 void tst_QPlainTextEdit::asciiTab()
337 {
338     QPlainTextEdit edit;
339     edit.setPlainText("\t");
340     edit.show();
341     qApp->processEvents();
342     QCOMPARE(edit.toPlainText().at(0), QChar('\t'));
343 }
344 
345 void tst_QPlainTextEdit::setDocument()
346 {
347     QTextDocument *document = new QTextDocument(ed);
348     document->setDocumentLayout(new QPlainTextDocumentLayout(document));
349     QTextCursor(document).insertText("Test");
350     ed->setDocument(document);
351     QCOMPARE(ed->toPlainText(), QString("Test"));
352 }
353 
354 
355 int tst_QPlainTextEdit::blockCount() const
356 {
357     int blocks = 0;
358     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next())
359         ++blocks;
360     return blocks;
361 }
362 
363 int tst_QPlainTextEdit::lineCount() const
364 {
365     int lines = 0;
366     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next()) {
367         ed->document()->documentLayout()->blockBoundingRect(block);
368         lines += block.layout()->lineCount();
369     }
370     return lines;
371 }
372 
373 // Supporter issue #56783
374 void tst_QPlainTextEdit::emptyAppend()
375 {
376     ed->appendPlainText("Blah");
377     QCOMPARE(blockCount(), 1);
378     ed->appendPlainText(QString());
379     QCOMPARE(blockCount(), 2);
380     ed->appendPlainText(QString("   "));
381     QCOMPARE(blockCount(), 3);
382 }
383 
384 void tst_QPlainTextEdit::appendOnEmptyDocumentShouldReuseInitialParagraph()
385 {
386     QCOMPARE(blockCount(), 1);
387     ed->appendPlainText("Blah");
388     QCOMPARE(blockCount(), 1);
389 }
390 
391 
392 class CursorPositionChangedRecorder : public QObject
393 {
394     Q_OBJECT
395 public:
396     inline CursorPositionChangedRecorder(QPlainTextEdit *ed)
397         : editor(ed)
398     {
399         connect(editor, SIGNAL(cursorPositionChanged()), this, SLOT(recordCursorPos()));
400     }
401 
402     QList<int> cursorPositions;
403 
404 private slots:
405     void recordCursorPos()
406     {
407         cursorPositions.append(editor->textCursor().position());
408     }
409 
410 private:
411     QPlainTextEdit *editor;
412 };
413 
414 void tst_QPlainTextEdit::cursorPositionChanged()
415 {
416     QSignalSpy spy(ed, SIGNAL(cursorPositionChanged()));
417 
418     spy.clear();
419     QTest::keyClick(ed, Qt::Key_A);
420     QCOMPARE(spy.count(), 1);
421 
422     QTextCursor cursor = ed->textCursor();
423     cursor.movePosition(QTextCursor::Start);
424     ed->setTextCursor(cursor);
425     cursor.movePosition(QTextCursor::End);
426     spy.clear();
427     cursor.insertText("Test");
428     QCOMPARE(spy.count(), 0);
429 
430     cursor.movePosition(QTextCursor::End);
431     ed->setTextCursor(cursor);
432     cursor.movePosition(QTextCursor::Start);
433     spy.clear();
434     cursor.insertText("Test");
435     QCOMPARE(spy.count(), 1);
436 
437     spy.clear();
438     QTest::keyClick(ed, Qt::Key_Left);
439     QCOMPARE(spy.count(), 1);
440 
441     CursorPositionChangedRecorder spy2(ed);
442     QVERIFY(ed->textCursor().position() > 0);
443     ed->setPlainText("Hello World");
444     QCOMPARE(spy2.cursorPositions.count(), 1);
445     QCOMPARE(spy2.cursorPositions.at(0), 0);
446     QCOMPARE(ed->textCursor().position(), 0);
447 }
448 
449 void tst_QPlainTextEdit::setTextCursor()
450 {
451     QSignalSpy spy(ed, SIGNAL(cursorPositionChanged()));
452 
453     ed->setPlainText("Test");
454     QTextCursor cursor = ed->textCursor();
455     cursor.movePosition(QTextCursor::Start);
456     cursor.movePosition(QTextCursor::NextCharacter);
457 
458     spy.clear();
459 
460     ed->setTextCursor(cursor);
461     QCOMPARE(spy.count(), 1);
462 }
463 
464 #ifndef QT_NO_CLIPBOARD
465 void tst_QPlainTextEdit::undoAvailableAfterPaste()
466 {
467     if (!PlatformClipboard::isAvailable())
468         QSKIP("Clipboard not working with cron-started unit tests");
469 
470     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
471         QSKIP("Wayland: This fails. Figure out why.");
472 
473     QSignalSpy spy(ed->document(), SIGNAL(undoAvailable(bool)));
474 
475     const QString txt("Test");
476     QApplication::clipboard()->setText(txt);
477     ed->paste();
478     QVERIFY(spy.count() >= 1);
479     QCOMPARE(ed->toPlainText(), txt);
480 }
481 #endif
482 
483 class UndoRedoRecorder : public QObject
484 {
485     Q_OBJECT
486 public:
487     UndoRedoRecorder(QTextDocument *doc)
488         : undoRepetitions(false)
489         , redoRepetitions(false)
490         , undoCount(0)
491         , redoCount(0)
492     {
493         connect(doc, SIGNAL(undoAvailable(bool)), this, SLOT(undoAvailable(bool)));
494         connect(doc, SIGNAL(redoAvailable(bool)), this, SLOT(redoAvailable(bool)));
495     }
496 
497     bool undoRepetitions;
498     bool redoRepetitions;
499 
500 private slots:
501     void undoAvailable(bool enabled) {
502         if (undoCount > 0 && enabled == lastUndoEnabled)
503             undoRepetitions = true;
504 
505         ++undoCount;
506         lastUndoEnabled = enabled;
507     }
508 
509     void redoAvailable(bool enabled) {
510         if (redoCount > 0 && enabled == lastRedoEnabled)
511             redoRepetitions = true;
512 
513         ++redoCount;
514         lastRedoEnabled = enabled;
515     }
516 
517 private:
518     bool lastUndoEnabled;
519     bool lastRedoEnabled;
520 
521     int undoCount;
522     int redoCount;
523 };
524 
525 void tst_QPlainTextEdit::undoRedoAvailableRepetition()
526 {
527     UndoRedoRecorder spy(ed->document());
528 
529     ed->textCursor().insertText("ABC\n\nDEF\n\nGHI\n");
530     ed->textCursor().insertText("foo\n");
531     ed->textCursor().insertText("bar\n");
532     ed->undo(); ed->undo(); ed->undo();
533     ed->redo(); ed->redo(); ed->redo();
534 
535     QVERIFY(!spy.undoRepetitions);
536     QVERIFY(!spy.redoRepetitions);
537 }
538 
539 void tst_QPlainTextEdit::appendShouldNotTouchTheSelection()
540 {
541     QTextCursor cursor(ed->document());
542     QTextCharFormat fmt;
543     fmt.setForeground(Qt::blue);
544     cursor.insertText("H", fmt);
545     fmt.setForeground(Qt::red);
546     cursor.insertText("ey", fmt);
547 
548     cursor.insertText("some random text inbetween");
549 
550     cursor.movePosition(QTextCursor::Start);
551     cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
552     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::blue));
553     cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
554     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::red));
555     cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
556     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::red));
557     QCOMPARE(cursor.selectedText(), QString("Hey"));
558 
559     ed->setTextCursor(cursor);
560     QVERIFY(ed->textCursor().hasSelection());
561 
562     ed->appendHtml("<b>Some Bold Text</b>");
563     cursor.movePosition(QTextCursor::Start);
564     cursor.movePosition(QTextCursor::NextCharacter);
565     QCOMPARE(cursor.charFormat().foreground().color(), QColor(Qt::blue));
566 }
567 
568 void tst_QPlainTextEdit::backspace()
569 {
570     QTextCursor cursor = ed->textCursor();
571 
572     QTextListFormat listFmt;
573     listFmt.setStyle(QTextListFormat::ListDisc);
574     listFmt.setIndent(1);
575     cursor.insertList(listFmt);
576     cursor.insertText("A");
577 
578     ed->setTextCursor(cursor);
579 
580     // delete 'A'
581     QTest::keyClick(ed, Qt::Key_Backspace);
582     QVERIFY(ed->textCursor().currentList());
583     // delete list
584     QTest::keyClick(ed, Qt::Key_Backspace);
585     QVERIFY(!ed->textCursor().currentList());
586     QCOMPARE(ed->textCursor().blockFormat().indent(), 1);
587     // outdent paragraph
588     QTest::keyClick(ed, Qt::Key_Backspace);
589     QCOMPARE(ed->textCursor().blockFormat().indent(), 0);
590 }
591 
592 void tst_QPlainTextEdit::shiftBackspace()
593 {
594     QTextCursor cursor = ed->textCursor();
595 
596     QTextListFormat listFmt;
597     listFmt.setStyle(QTextListFormat::ListDisc);
598     listFmt.setIndent(1);
599     cursor.insertList(listFmt);
600     cursor.insertText("A");
601 
602     ed->setTextCursor(cursor);
603 
604     // delete 'A'
605     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier);
606     QVERIFY(ed->textCursor().currentList());
607     // delete list
608     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier);
609     QVERIFY(!ed->textCursor().currentList());
610     QCOMPARE(ed->textCursor().blockFormat().indent(), 1);
611     // outdent paragraph
612     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier);
613     QCOMPARE(ed->textCursor().blockFormat().indent(), 0);
614 }
615 
616 void tst_QPlainTextEdit::undoRedo()
617 {
618     ed->clear();
619     QTest::keyClicks(ed, "abc d");
620     QCOMPARE(ed->toPlainText(), QString("abc d"));
621     ed->undo();
622     QCOMPARE(ed->toPlainText(), QString());
623     ed->redo();
624     QCOMPARE(ed->toPlainText(), QString("abc d"));
625 #ifdef Q_OS_WIN
626     // shortcut for undo
627     QTest::keyClick(ed, Qt::Key_Backspace, Qt::AltModifier);
628     QCOMPARE(ed->toPlainText(), QString());
629     // shortcut for redo
630     QTest::keyClick(ed, Qt::Key_Backspace, Qt::ShiftModifier|Qt::AltModifier);
631     QCOMPARE(ed->toPlainText(), QString("abc d"));
632 #endif
633 }
634 
635 // Task #70465
636 void tst_QPlainTextEdit::preserveCharFormatInAppend()
637 {
638     ed->appendHtml("First para");
639     ed->appendHtml("<b>Second para</b>");
640     ed->appendHtml("third para");
641 
642     QTextCursor cursor(ed->textCursor());
643 
644     cursor.movePosition(QTextCursor::Start);
645     cursor.movePosition(QTextCursor::NextCharacter);
646     QCOMPARE(cursor.charFormat().fontWeight(), (int)QFont::Normal);
647     QCOMPARE(cursor.block().text(), QString("First para"));
648 
649     cursor.movePosition(QTextCursor::NextBlock);
650     cursor.movePosition(QTextCursor::NextCharacter);
651     QCOMPARE(cursor.charFormat().fontWeight(), (int)QFont::Bold);
652     QCOMPARE(cursor.block().text(), QString("Second para"));
653 
654     cursor.movePosition(QTextCursor::NextBlock);
655     cursor.movePosition(QTextCursor::NextCharacter);
656     QCOMPARE(cursor.charFormat().fontWeight(), (int)QFont::Normal);
657     QCOMPARE(cursor.block().text(), QString("third para"));
658 }
659 
660 #ifndef QT_NO_CLIPBOARD
661 void tst_QPlainTextEdit::copyAndSelectAllInReadonly()
662 {
663     if (!PlatformClipboard::isAvailable())
664         QSKIP("Clipboard not working with cron-started unit tests");
665 
666     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
667         QSKIP("Wayland: This fails. Figure out why.");
668 
669     ed->setReadOnly(true);
670     ed->setPlainText("Hello World");
671 
672     QTextCursor cursor = ed->textCursor();
673     cursor.clearSelection();
674     ed->setTextCursor(cursor);
675     QVERIFY(!ed->textCursor().hasSelection());
676 
677     QCOMPARE(ed->toPlainText(), QString("Hello World"));
678 
679     // shouldn't do anything
680     QTest::keyClick(ed, Qt::Key_A);
681 
682     QCOMPARE(ed->toPlainText(), QString("Hello World"));
683 
684     QTest::keyClick(ed, Qt::Key_A, Qt::ControlModifier);
685 
686     QVERIFY(ed->textCursor().hasSelection());
687 
688     QApplication::clipboard()->setText(QString());
689     QVERIFY(QApplication::clipboard()->text().isEmpty());
690 
691     QTest::keyClick(ed, Qt::Key_C, Qt::ControlModifier);
692     QCOMPARE(QApplication::clipboard()->text(), QString("Hello World"));
693 }
694 #endif
695 
696 Q_DECLARE_METATYPE(Qt::KeyboardModifiers)
697 
698 // Test how QWidgetTextControlPrivate (used in QPlainTextEdit, QTextEdit)
699 // handles input with modifiers.
700 void tst_QPlainTextEdit::charWithAltOrCtrlModifier_data()
701 {
702     QTest::addColumn<Qt::KeyboardModifiers>("modifiers");
703     QTest::addColumn<bool>("textExpected");
704 
705     QTest::newRow("no-modifiers") << Qt::KeyboardModifiers() << true;
706     // Ctrl, Ctrl+Shift: No text (QTBUG-35734)
707     QTest::newRow("ctrl") << Qt::KeyboardModifiers(Qt::ControlModifier)
708         << false;
709     QTest::newRow("ctrl-shift") << Qt::KeyboardModifiers(Qt::ShiftModifier | Qt::ControlModifier)
710         << false;
711     QTest::newRow("alt") << Qt::KeyboardModifiers(Qt::AltModifier) << true;
712     // Alt-Ctrl (Alt-Gr on German keyboards, Task 129098): Expect text
713     QTest::newRow("alt-ctrl") << (Qt::AltModifier | Qt::ControlModifier) << true;
714 }
715 
716 void tst_QPlainTextEdit::charWithAltOrCtrlModifier()
717 {
718     QFETCH(Qt::KeyboardModifiers, modifiers);
719     QFETCH(bool, textExpected);
720 
721     QTest::keyClick(ed, Qt::Key_At, modifiers);
722     const QString expectedText = textExpected ?  QLatin1String("@") : QString();
723     QCOMPARE(ed->toPlainText(), expectedText);
724 }
725 
726 void tst_QPlainTextEdit::noPropertiesOnDefaultTextEditCharFormat()
727 {
728     // there should be no properties set on the default/initial char format
729     // on a text edit. Font properties instead should be taken from the
730     // widget's font (in sync with defaultFont property in document) and the
731     // foreground color should be taken from the palette.
732     QCOMPARE(ed->textCursor().charFormat().properties().count(), 0);
733 }
734 
735 void tst_QPlainTextEdit::setPlainTextShouldEmitTextChangedOnce()
736 {
737     QSignalSpy spy(ed, SIGNAL(textChanged()));
738     ed->setPlainText("Yankee Doodle");
739     QCOMPARE(spy.count(), 1);
740     ed->setPlainText("");
741     QCOMPARE(spy.count(), 2);
742 }
743 
744 void tst_QPlainTextEdit::overwriteMode()
745 {
746     QVERIFY(!ed->overwriteMode());
747     QTest::keyClicks(ed, "Some first text");
748 
749     QCOMPARE(ed->toPlainText(), QString("Some first text"));
750 
751     ed->setOverwriteMode(true);
752 
753     QTextCursor cursor = ed->textCursor();
754     cursor.setPosition(5);
755     ed->setTextCursor(cursor);
756 
757     QTest::keyClicks(ed, "shiny");
758     QCOMPARE(ed->toPlainText(), QString("Some shiny text"));
759 
760     cursor.movePosition(QTextCursor::End);
761     ed->setTextCursor(cursor);
762 
763     QTest::keyClick(ed, Qt::Key_Enter);
764 
765     ed->setOverwriteMode(false);
766     QTest::keyClicks(ed, "Second paragraph");
767 
768     QCOMPARE(blockCount(), 2);
769 
770     cursor.movePosition(QTextCursor::Start);
771     cursor.movePosition(QTextCursor::EndOfBlock);
772 
773     QCOMPARE(cursor.position(), 15);
774     ed->setTextCursor(cursor);
775 
776     ed->setOverwriteMode(true);
777 
778     QTest::keyClicks(ed, " blah");
779 
780     QCOMPARE(blockCount(), 2);
781 
782     QTextBlock block = ed->document()->begin();
783     QCOMPARE(block.text(), QString("Some shiny text blah"));
784     block = block.next();
785     QCOMPARE(block.text(), QString("Second paragraph"));
786 }
787 
788 void tst_QPlainTextEdit::shiftDownInLineLastShouldSelectToEnd_data()
789 {
790     // shift cursor-down in the last line should select to the end of the document
791 
792     QTest::addColumn<QString>("input");
793     QTest::addColumn<int>("totalLineCount");
794 
795     QTest::newRow("1") << QString("Foo\nBar") << 2;
796     QTest::newRow("2") << QString("Foo\nBar") + QChar(QChar::LineSeparator) + QString("Baz") << 3;
797 }
798 
799 void tst_QPlainTextEdit::shiftDownInLineLastShouldSelectToEnd()
800 {
801     QFETCH(QString, input);
802     QFETCH(int, totalLineCount);
803 
804     ed->setPlainText(input);
805     ed->show();
806 
807     // ensure we're layouted
808     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next())
809         ed->document()->documentLayout()->blockBoundingRect(block);
810 
811     QCOMPARE(blockCount(), 2);
812 
813     int lineCount = 0;
814     for (QTextBlock block = ed->document()->begin(); block.isValid(); block = block.next())
815         lineCount += block.layout()->lineCount();
816     QCOMPARE(lineCount, totalLineCount);
817 
818     QTextCursor cursor = ed->textCursor();
819     cursor.movePosition(QTextCursor::Start);
820     ed->setTextCursor(cursor);
821 
822     for (int i = 0; i < lineCount; ++i) {
823         QTest::keyClick(ed, Qt::Key_Down, Qt::ShiftModifier);
824     }
825 
826     input.replace(QLatin1Char('\n'), QChar(QChar::ParagraphSeparator));
827     QCOMPARE(ed->textCursor().selectedText(), input);
828     QVERIFY(ed->textCursor().atEnd());
829 
830     // also test that without shift modifier the cursor does not move to the end
831     // for Key_Down in the last line
832     cursor.movePosition(QTextCursor::Start);
833     ed->setTextCursor(cursor);
834     for (int i = 0; i < lineCount; ++i) {
835         QTest::keyClick(ed, Qt::Key_Down);
836     }
837     QVERIFY(!ed->textCursor().atEnd());
838 }
839 
840 void tst_QPlainTextEdit::undoRedoShouldRepositionTextEditCursor()
841 {
842     ed->setPlainText("five\nlines\nin\nthis\ntextedit");
843     QTextCursor cursor = ed->textCursor();
844     cursor.movePosition(QTextCursor::Start);
845 
846     ed->setUndoRedoEnabled(false);
847     ed->setUndoRedoEnabled(true);
848 
849     QVERIFY(!ed->document()->isUndoAvailable());
850     QVERIFY(!ed->document()->isRedoAvailable());
851 
852     cursor.insertText("Blah");
853 
854     QVERIFY(ed->document()->isUndoAvailable());
855     QVERIFY(!ed->document()->isRedoAvailable());
856 
857     cursor.movePosition(QTextCursor::End);
858     ed->setTextCursor(cursor);
859 
860     QVERIFY(QMetaObject::invokeMethod(ed, "undo"));
861 
862     QVERIFY(!ed->document()->isUndoAvailable());
863     QVERIFY(ed->document()->isRedoAvailable());
864 
865     QCOMPARE(ed->textCursor().position(), 0);
866 
867     cursor.movePosition(QTextCursor::End);
868     ed->setTextCursor(cursor);
869 
870     QVERIFY(QMetaObject::invokeMethod(ed, "redo"));
871 
872     QVERIFY(ed->document()->isUndoAvailable());
873     QVERIFY(!ed->document()->isRedoAvailable());
874 
875     QCOMPARE(ed->textCursor().position(), 4);
876 }
877 
878 void tst_QPlainTextEdit::lineWrapModes()
879 {
880     QWidget *window = new QWidget;
881     ed->setParent(window);
882     window->show();
883     ed->show();
884     ed->setPlainText("a b c d e f g h i j k l m n o p q r s t u v w x y z");
885     ed->setLineWrapMode(QPlainTextEdit::NoWrap);
886     QCOMPARE(lineCount(), 1);
887     ed->setLineWrapMode(QPlainTextEdit::WidgetWidth);
888 
889     // QPlainTextEdit does lazy line layout on resize, only for the visible blocks.
890     // We thus need to make it wide enough to show something visible.
891     int minimumWidth = 2 * ed->document()->documentMargin();
892     minimumWidth += ed->fontMetrics().horizontalAdvance(QLatin1Char('a'));
893     minimumWidth += ed->frameWidth();
894     ed->resize(minimumWidth, 1000);
895     QCOMPARE(lineCount(), 26);
896     ed->setParent(0);
897     delete window;
898 }
899 
900 #ifndef QT_NO_CURSOR
901 void tst_QPlainTextEdit::mouseCursorShape()
902 {
903     // always show an IBeamCursor, see change 170146
904     QVERIFY(!ed->isReadOnly());
905     QCOMPARE(ed->viewport()->cursor().shape(), Qt::IBeamCursor);
906 
907     ed->setReadOnly(true);
908     QCOMPARE(ed->viewport()->cursor().shape(), Qt::IBeamCursor);
909 
910     ed->setPlainText("Foo");
911     QCOMPARE(ed->viewport()->cursor().shape(), Qt::IBeamCursor);
912 }
913 #endif
914 
915 void tst_QPlainTextEdit::implicitClear()
916 {
917     // test that QPlainTextEdit::setHtml, etc. avoid calling clear() but instead call
918     // QTextDocument::setHtml/etc. instead, which also clear the contents and
919     // cached resource but preserve manually added resources. setHtml on a textedit
920     // should behave the same as on a document with respect to that.
921     // see also clearResources() autotest in qtextdocument
922 
923     // regular resource for QTextDocument
924     QUrl testUrl(":/foobar");
925     QVariant testResource("hello world");
926 
927     ed->document()->addResource(QTextDocument::ImageResource, testUrl, testResource);
928     QVERIFY(ed->document()->resource(QTextDocument::ImageResource, testUrl) == testResource);
929 
930     ed->setPlainText("Blah");
931     QVERIFY(ed->document()->resource(QTextDocument::ImageResource, testUrl) == testResource);
932 
933     ed->setPlainText("<b>Blah</b>");
934     QVERIFY(ed->document()->resource(QTextDocument::ImageResource, testUrl) == testResource);
935 
936     ed->clear();
937     QVERIFY(!ed->document()->resource(QTextDocument::ImageResource, testUrl).isValid());
938     QVERIFY(ed->toPlainText().isEmpty());
939 }
940 
941 #ifndef QT_NO_CLIPBOARD
942 void tst_QPlainTextEdit::copyAvailable_data()
943 {
944     QTest::addColumn<pairListType>("keystrokes");
945     QTest::addColumn<QList<bool> >("copyAvailable");
946     QTest::addColumn<QString>("function");
947 
948     pairListType keystrokes;
949     QList<bool> copyAvailable;
950 
951     keystrokes << qMakePair(Qt::Key_B, Qt::NoModifier) <<  qMakePair(Qt::Key_B, Qt::NoModifier)
952                << qMakePair(Qt::Key_Left, Qt::ShiftModifier);
953     copyAvailable << true ;
954     QTest::newRow(QString("Case1 B,B, <- + shift | signals: true").toLatin1())
955         << keystrokes << copyAvailable << QString();
956 
957     keystrokes.clear();
958     copyAvailable.clear();
959 
960     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
961                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier);
962     copyAvailable << true << false;
963     QTest::newRow(QString("Case2 T,A,A, <- + shift, cut() | signals: true, false").toLatin1())
964         << keystrokes << copyAvailable << QString("cut");
965 
966     keystrokes.clear();
967     copyAvailable.clear();
968 
969     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
970                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
971                << qMakePair(Qt::Key_Left, Qt::ShiftModifier)  << qMakePair(Qt::Key_Left, Qt::ShiftModifier);
972     copyAvailable << true;
973     QTest::newRow(QString("Case3 T,A,A, <- + shift, <- + shift, <- + shift, copy() | signals: true").toLatin1())
974         << keystrokes << copyAvailable << QString("copy");
975 
976     keystrokes.clear();
977     copyAvailable.clear();
978 
979     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
980                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
981                << qMakePair(Qt::Key_Left, Qt::ShiftModifier)  << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
982                << qMakePair(Qt::Key_X, Qt::ControlModifier);
983     copyAvailable << true << false;
984     QTest::newRow(QString("Case4 T,A,A, <- + shift, <- + shift, <- + shift, ctrl + x, paste() | signals: true, false").toLatin1())
985         << keystrokes << copyAvailable << QString("paste");
986 
987     keystrokes.clear();
988     copyAvailable.clear();
989 
990     keystrokes << qMakePair(Qt::Key_B, Qt::NoModifier) <<  qMakePair(Qt::Key_B, Qt::NoModifier)
991                << qMakePair(Qt::Key_Left, Qt::ShiftModifier) << qMakePair(Qt::Key_Left, Qt::NoModifier);
992     copyAvailable << true << false;
993     QTest::newRow(QString("Case5 B,B, <- + shift, <- | signals: true, false").toLatin1())
994         << keystrokes << copyAvailable << QString();
995 
996     keystrokes.clear();
997     copyAvailable.clear();
998 
999     keystrokes << qMakePair(Qt::Key_B, Qt::NoModifier) <<  qMakePair(Qt::Key_A, Qt::NoModifier)
1000                << qMakePair(Qt::Key_Left, Qt::ShiftModifier) << qMakePair(Qt::Key_Left, Qt::NoModifier)
1001                << qMakePair(Qt::Key_Right, Qt::ShiftModifier);
1002     copyAvailable << true << false << true << false;
1003     QTest::newRow(QString("Case6 B,A, <- + shift, ->, <- + shift | signals: true, false, true, false").toLatin1())
1004         << keystrokes << copyAvailable << QString("cut");
1005 
1006     keystrokes.clear();
1007     copyAvailable.clear();
1008 
1009     keystrokes << qMakePair(Qt::Key_T, Qt::NoModifier) << qMakePair(Qt::Key_A, Qt::NoModifier)
1010                <<  qMakePair(Qt::Key_A, Qt::NoModifier) << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
1011                << qMakePair(Qt::Key_Left, Qt::ShiftModifier)  << qMakePair(Qt::Key_Left, Qt::ShiftModifier)
1012                << qMakePair(Qt::Key_X, Qt::ControlModifier);
1013     copyAvailable << true << false << true;
1014     QTest::newRow(QString("Case7 T,A,A, <- + shift, <- + shift, <- + shift, ctrl + x, undo() | signals: true, false, true").toLatin1())
1015         << keystrokes << copyAvailable << QString("undo");
1016 }
1017 
1018 //Tests the copyAvailable slot for several cases
1019 void tst_QPlainTextEdit::copyAvailable()
1020 {
1021     QFETCH(pairListType,keystrokes);
1022     QFETCH(QList<bool>, copyAvailable);
1023     QFETCH(QString, function);
1024 
1025 #ifdef Q_OS_MAC
1026     QSKIP("QTBUG-22283: copyAvailable has never passed on Mac");
1027 #endif
1028     ed->clear();
1029     QApplication::clipboard()->clear();
1030     QVERIFY(!ed->canPaste());
1031     QSignalSpy spyCopyAvailabe(ed, SIGNAL(copyAvailable(bool)));
1032 
1033     //Execute Keystrokes
1034     foreach(keyPairType keyPair, keystrokes) {
1035         QTest::keyClick(ed, keyPair.first, keyPair.second );
1036     }
1037 
1038     //Execute ed->"function"
1039     if (function == "cut")
1040         ed->cut();
1041     else if (function == "copy")
1042         ed->copy();
1043     else if (function == "paste")
1044         ed->paste();
1045     else if (function == "undo")
1046         ed->paste();
1047     else if (function == "redo")
1048         ed->paste();
1049 
1050     //Compare spied signals
1051     QEXPECT_FAIL("Case7 T,A,A, <- + shift, <- + shift, <- + shift, ctrl + x, undo() | signals: true, false, true",
1052         "Wrong undo selection behaviour. Should be fixed in some future release. (See task: 132482)", Abort);
1053     QCOMPARE(spyCopyAvailabe.count(), copyAvailable.count());
1054     for (int i=0;i<spyCopyAvailabe.count(); i++) {
1055         QVariant variantSpyCopyAvailable = spyCopyAvailabe.at(i).at(0);
1056         QVERIFY2(variantSpyCopyAvailable.toBool() == copyAvailable.at(i), QString("Spied singnal: %1").arg(i).toLatin1());
1057     }
1058 }
1059 #endif
1060 
1061 void tst_QPlainTextEdit::undoRedoAfterSetContent()
1062 {
1063     QVERIFY(!ed->document()->isUndoAvailable());
1064     QVERIFY(!ed->document()->isRedoAvailable());
1065     ed->setPlainText("Foobar");
1066     QVERIFY(!ed->document()->isUndoAvailable());
1067     QVERIFY(!ed->document()->isRedoAvailable());
1068     ed->setPlainText("<p>bleh</p>");
1069     QVERIFY(!ed->document()->isUndoAvailable());
1070     QVERIFY(!ed->document()->isRedoAvailable());
1071 }
1072 
1073 void tst_QPlainTextEdit::numPadKeyNavigation()
1074 {
1075     ed->setPlainText("Hello World");
1076     QCOMPARE(ed->textCursor().position(), 0);
1077     QTest::keyClick(ed, Qt::Key_Right, Qt::KeypadModifier);
1078     QCOMPARE(ed->textCursor().position(), 1);
1079 }
1080 
1081 void tst_QPlainTextEdit::moveCursor()
1082 {
1083     ed->setPlainText("Test");
1084 
1085     QSignalSpy cursorMovedSpy(ed, SIGNAL(cursorPositionChanged()));
1086 
1087     QCOMPARE(ed->textCursor().position(), 0);
1088     ed->moveCursor(QTextCursor::NextCharacter);
1089     QCOMPARE(ed->textCursor().position(), 1);
1090     QCOMPARE(cursorMovedSpy.count(), 1);
1091     ed->moveCursor(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
1092     QCOMPARE(ed->textCursor().position(), 2);
1093     QCOMPARE(cursorMovedSpy.count(), 2);
1094     QCOMPARE(ed->textCursor().selectedText(), QString("e"));
1095 }
1096 
1097 class MyTextEdit : public QPlainTextEdit
1098 {
1099 public:
1100     inline MyTextEdit()
1101         : createMimeDataCallCount(0),
1102           canInsertCallCount(0),
1103           insertCallCount(0)
1104     {}
1105 
1106     mutable int createMimeDataCallCount;
1107     mutable int canInsertCallCount;
1108     mutable int insertCallCount;
1109 
1110     virtual QMimeData *createMimeDataFromSelection() const override {
1111         createMimeDataCallCount++;
1112         return QPlainTextEdit::createMimeDataFromSelection();
1113     }
1114     virtual bool canInsertFromMimeData(const QMimeData *source) const override {
1115         canInsertCallCount++;
1116         return QPlainTextEdit::canInsertFromMimeData(source);
1117     }
1118     virtual void insertFromMimeData(const QMimeData *source) override {
1119         insertCallCount++;
1120         QPlainTextEdit::insertFromMimeData(source);
1121     }
1122 
1123 };
1124 
1125 #ifndef QT_NO_CLIPBOARD
1126 void tst_QPlainTextEdit::mimeDataReimplementations()
1127 {
1128     MyTextEdit ed;
1129     ed.setPlainText("Hello World");
1130 
1131     QCOMPARE(ed.createMimeDataCallCount, 0);
1132     QCOMPARE(ed.canInsertCallCount, 0);
1133     QCOMPARE(ed.insertCallCount, 0);
1134 
1135     ed.selectAll();
1136 
1137     QCOMPARE(ed.createMimeDataCallCount, 0);
1138     QCOMPARE(ed.canInsertCallCount, 0);
1139     QCOMPARE(ed.insertCallCount, 0);
1140 
1141     ed.copy();
1142 
1143     QCOMPARE(ed.createMimeDataCallCount, 1);
1144     QCOMPARE(ed.canInsertCallCount, 0);
1145     QCOMPARE(ed.insertCallCount, 0);
1146 
1147 #ifdef QT_BUILD_INTERNAL
1148     QWidgetTextControl *control = ed.findChild<QWidgetTextControl *>();
1149     QVERIFY(control);
1150 
1151     control->canInsertFromMimeData(QApplication::clipboard()->mimeData());
1152 
1153     QCOMPARE(ed.createMimeDataCallCount, 1);
1154     QCOMPARE(ed.canInsertCallCount, 1);
1155     QCOMPARE(ed.insertCallCount, 0);
1156 
1157     ed.paste();
1158 
1159     QCOMPARE(ed.createMimeDataCallCount, 1);
1160     QCOMPARE(ed.canInsertCallCount, 1);
1161     QCOMPARE(ed.insertCallCount, 1);
1162 #endif
1163 }
1164 #endif
1165 
1166 void tst_QPlainTextEdit::shiftEnterShouldInsertLineSeparator()
1167 {
1168     QTest::keyClick(ed, Qt::Key_A);
1169     QTest::keyClick(ed, Qt::Key_Enter, Qt::ShiftModifier);
1170     QTest::keyClick(ed, Qt::Key_B);
1171     QString expected;
1172     expected += 'a';
1173     expected += QChar::LineSeparator;
1174     expected += 'b';
1175     QCOMPARE(ed->textCursor().block().text(), expected);
1176 }
1177 
1178 void tst_QPlainTextEdit::selectWordsFromStringsContainingSeparators_data()
1179 {
1180     QTest::addColumn<QString>("testString");
1181     QTest::addColumn<QString>("selectedWord");
1182 
1183     const ushort wordSeparators[] =
1184         {'.', ',', '?', '!', ':', ';', '-', '<', '>', '[', ']', '(', ')', '{', '}',
1185          '=', '\t', ushort(QChar::Nbsp)};
1186 
1187     for (size_t i = 0, count = sizeof(wordSeparators) / sizeof(wordSeparators[0]); i < count; ++i) {
1188         const ushort u = wordSeparators[i];
1189         QByteArray rowName = QByteArrayLiteral("separator: ");
1190         if (u >= 32 && u < 128)
1191             rowName += char(u);
1192         else
1193             rowName += QByteArrayLiteral("0x") + QByteArray::number(u, 16);
1194         QTest::newRow(rowName.constData()) << QString("foo") + QChar(u) + QString("bar") << QString("foo");
1195     }
1196 }
1197 
1198 void tst_QPlainTextEdit::selectWordsFromStringsContainingSeparators()
1199 {
1200     QFETCH(QString, testString);
1201     QFETCH(QString, selectedWord);
1202     ed->setPlainText(testString);
1203     QTextCursor cursor = ed->textCursor();
1204     cursor.movePosition(QTextCursor::StartOfLine);
1205     cursor.select(QTextCursor::WordUnderCursor);
1206     QVERIFY(cursor.hasSelection());
1207     QCOMPARE(cursor.selection().toPlainText(), selectedWord);
1208     cursor.clearSelection();
1209 }
1210 
1211 #ifndef QT_NO_CLIPBOARD
1212 void tst_QPlainTextEdit::canPaste()
1213 {
1214     if (!PlatformClipboard::isAvailable())
1215         QSKIP("Clipboard not working with cron-started unit tests");
1216 
1217     if (QGuiApplication::platformName().startsWith(QLatin1String("wayland"), Qt::CaseInsensitive))
1218         QSKIP("Wayland: This fails. Figure out why.");
1219 
1220     QApplication::clipboard()->setText(QString());
1221     QVERIFY(!ed->canPaste());
1222     QApplication::clipboard()->setText("Test");
1223     QVERIFY(ed->canPaste());
1224     ed->setTextInteractionFlags(Qt::NoTextInteraction);
1225     QVERIFY(!ed->canPaste());
1226 }
1227 #endif
1228 
1229 void tst_QPlainTextEdit::ensureCursorVisibleOnInitialShow()
1230 {
1231     QString manyPagesOfPlainText;
1232     for (int i = 0; i < 800; ++i)
1233         manyPagesOfPlainText += QLatin1String("Blah blah blah blah blah blah\n");
1234 
1235     ed->setPlainText(manyPagesOfPlainText);
1236     QCOMPARE(ed->textCursor().position(), 0);
1237 
1238     ed->moveCursor(QTextCursor::End);
1239     ed->show();
1240     QVERIFY(ed->verticalScrollBar()->value() > 10);
1241 
1242     ed->moveCursor(QTextCursor::Start);
1243     QVERIFY(ed->verticalScrollBar()->value() < 10);
1244     ed->hide();
1245     ed->verticalScrollBar()->setValue(ed->verticalScrollBar()->maximum());
1246     ed->show();
1247     QCOMPARE(ed->verticalScrollBar()->value(), ed->verticalScrollBar()->maximum());
1248 }
1249 
1250 class TestEdit : public QPlainTextEdit
1251 {
1252 public:
1253     TestEdit() : resizeEventCalled(false) {}
1254 
1255     bool resizeEventCalled;
1256 
1257 protected:
1258     virtual void resizeEvent(QResizeEvent *e) override
1259     {
1260         QPlainTextEdit::resizeEvent(e);
1261         setPlainText("<img src=qtextbrowser-resizeevent.png width=" + QString::number(size().width()) + "><br>Size is " + QString::number(size().width()) + " x " + QString::number(size().height()));
1262         resizeEventCalled = true;
1263     }
1264 };
1265 
1266 void tst_QPlainTextEdit::setTextInsideResizeEvent()
1267 {
1268     TestEdit edit;
1269     edit.show();
1270     edit.resize(800, 600);
1271     QVERIFY(edit.resizeEventCalled);
1272 }
1273 
1274 void tst_QPlainTextEdit::colorfulAppend()
1275 {
1276     QTextCharFormat fmt;
1277 
1278     fmt.setForeground(QBrush(Qt::red));
1279     ed->mergeCurrentCharFormat(fmt);
1280     ed->appendPlainText("Red");
1281     fmt.setForeground(QBrush(Qt::blue));
1282     ed->mergeCurrentCharFormat(fmt);
1283     ed->appendPlainText("Blue");
1284     fmt.setForeground(QBrush(Qt::green));
1285     ed->mergeCurrentCharFormat(fmt);
1286     ed->appendPlainText("Green");
1287 
1288     QCOMPARE(ed->document()->blockCount(), 3);
1289     QTextBlock block = ed->document()->begin();
1290     QCOMPARE(block.begin().fragment().text(), QString("Red"));
1291     QVERIFY(block.begin().fragment().charFormat().foreground().color() == Qt::red);
1292     block = block.next();
1293     QCOMPARE(block.begin().fragment().text(), QString("Blue"));
1294     QVERIFY(block.begin().fragment().charFormat().foreground().color() == Qt::blue);
1295     block = block.next();
1296     QCOMPARE(block.begin().fragment().text(), QString("Green"));
1297     QVERIFY(block.begin().fragment().charFormat().foreground().color() == Qt::green);
1298 }
1299 
1300 void tst_QPlainTextEdit::ensureVisibleWithRtl()
1301 {
1302     ed->setLayoutDirection(Qt::RightToLeft);
1303     ed->setLineWrapMode(QPlainTextEdit::NoWrap);
1304     QString txt(500, QChar(QLatin1Char('a')));
1305     QCOMPARE(txt.length(), 500);
1306     ed->setPlainText(txt);
1307     ed->resize(100, 100);
1308     ed->show();
1309 
1310     qApp->processEvents();
1311 
1312     QVERIFY(ed->horizontalScrollBar()->maximum() > 0);
1313 
1314     ed->moveCursor(QTextCursor::Start);
1315     QCOMPARE(ed->horizontalScrollBar()->value(), ed->horizontalScrollBar()->maximum());
1316     ed->moveCursor(QTextCursor::End);
1317     QCOMPARE(ed->horizontalScrollBar()->value(), 0);
1318     ed->moveCursor(QTextCursor::Start);
1319     QCOMPARE(ed->horizontalScrollBar()->value(), ed->horizontalScrollBar()->maximum());
1320     ed->moveCursor(QTextCursor::End);
1321     QCOMPARE(ed->horizontalScrollBar()->value(), 0);
1322 }
1323 
1324 void tst_QPlainTextEdit::preserveCharFormatAfterSetPlainText()
1325 {
1326     QTextCharFormat fmt;
1327     fmt.setForeground(QBrush(Qt::blue));
1328     ed->mergeCurrentCharFormat(fmt);
1329     ed->setPlainText("This is blue");
1330     ed->appendPlainText("This should still be blue");
1331     QTextBlock block = ed->document()->begin();
1332     block = block.next();
1333     QCOMPARE(block.text(), QString("This should still be blue"));
1334     QCOMPARE(block.begin().fragment().charFormat().foreground().color(), QColor(Qt::blue));
1335 }
1336 
1337 void tst_QPlainTextEdit::extraSelections()
1338 {
1339     ed->setPlainText("Hello World");
1340 
1341     QTextCursor c = ed->textCursor();
1342     c.movePosition(QTextCursor::Start);
1343     c.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
1344     const int endPos = c.position();
1345 
1346     QTextEdit::ExtraSelection sel;
1347     sel.cursor = c;
1348     ed->setExtraSelections(QList<QTextEdit::ExtraSelection>() << sel);
1349 
1350     c.movePosition(QTextCursor::Start);
1351     c.movePosition(QTextCursor::NextWord);
1352     const int wordPos = c.position();
1353     c.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
1354     sel.cursor = c;
1355     ed->setExtraSelections(QList<QTextEdit::ExtraSelection>() << sel);
1356 
1357     QList<QTextEdit::ExtraSelection> selections = ed->extraSelections();
1358     QCOMPARE(selections.count(), 1);
1359     QCOMPARE(selections.at(0).cursor.position(), endPos);
1360     QCOMPARE(selections.at(0).cursor.anchor(), wordPos);
1361 }
1362 
1363 void tst_QPlainTextEdit::adjustScrollbars()
1364 {
1365 // For some reason ff is defined to be << on Mac Panther / gcc 3.3
1366 #undef ff
1367     QFont ff(ed->font());
1368     ff.setFamily("Tahoma");
1369     ff.setPointSize(11);
1370     ed->setFont(ff);
1371     ed->setMinimumSize(140, 100);
1372     ed->setMaximumSize(140, 100);
1373     ed->show();
1374     QLatin1String txt("\nabc def ghi jkl mno pqr stu vwx");
1375     ed->setPlainText(txt + txt + txt + txt);
1376 
1377     QVERIFY(ed->verticalScrollBar()->maximum() > 0);
1378 
1379     ed->moveCursor(QTextCursor::End);
1380     int oldMaximum = ed->verticalScrollBar()->maximum();
1381     QTextCursor cursor = ed->textCursor();
1382     cursor.insertText(QLatin1String("\n"));
1383     cursor.deletePreviousChar();
1384     QCOMPARE(ed->verticalScrollBar()->maximum(), oldMaximum);
1385 }
1386 
1387 class SignalReceiver : public QObject
1388 {
1389     Q_OBJECT
1390 public:
1391     SignalReceiver() : received(0) {}
1392 
1393     int receivedSignals() const { return received; }
1394     QTextCharFormat charFormat() const { return format; }
1395 
1396 public slots:
1397     void charFormatChanged(const QTextCharFormat &tcf) { ++received; format = tcf; }
1398 
1399 private:
1400     QTextCharFormat format;
1401     int received;
1402 };
1403 
1404 void tst_QPlainTextEdit::textObscuredByScrollbars()
1405 {
1406     ed->textCursor().insertText(
1407             "ab cab cab c abca kjsdf lka sjd lfk jsal df j kasdf abc ab abc "
1408             "a b c d e f g h i j k l m n o p q r s t u v w x y z "
1409             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1410             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1411             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1412             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1413             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1414             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1415             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1416             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1417             "abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc abc "
1418             "ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab"
1419     );
1420     ed->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
1421     ed->show();
1422 
1423     QSize documentSize = ed->document()->documentLayout()->documentSize().toSize();
1424     QSize viewportSize = ed->viewport()->size();
1425 
1426     QVERIFY(documentSize.width() <= viewportSize.width());
1427 }
1428 
1429 void tst_QPlainTextEdit::setTextPreservesUndoRedoEnabled()
1430 {
1431     QVERIFY(ed->isUndoRedoEnabled());
1432 
1433     ed->setPlainText("Test");
1434 
1435     QVERIFY(ed->isUndoRedoEnabled());
1436 
1437     ed->setUndoRedoEnabled(false);
1438     QVERIFY(!ed->isUndoRedoEnabled());
1439     ed->setPlainText("Test2");
1440     QVERIFY(!ed->isUndoRedoEnabled());
1441 
1442     ed->setPlainText("<p>hello");
1443     QVERIFY(!ed->isUndoRedoEnabled());
1444 }
1445 
1446 void tst_QPlainTextEdit::wordWrapProperty()
1447 {
1448     {
1449         QPlainTextEdit edit;
1450         QTextDocument *doc = new QTextDocument(&edit);
1451         doc->setDocumentLayout(new QPlainTextDocumentLayout(doc));
1452         edit.setDocument(doc);
1453         edit.setWordWrapMode(QTextOption::NoWrap);
1454         QCOMPARE(doc->defaultTextOption().wrapMode(), QTextOption::NoWrap);
1455     }
1456     {
1457         QPlainTextEdit edit;
1458         QTextDocument *doc = new QTextDocument(&edit);
1459         doc->setDocumentLayout(new QPlainTextDocumentLayout(doc));
1460         edit.setWordWrapMode(QTextOption::NoWrap);
1461         edit.setDocument(doc);
1462         QCOMPARE(doc->defaultTextOption().wrapMode(), QTextOption::NoWrap);
1463     }
1464 }
1465 
1466 void tst_QPlainTextEdit::lineWrapProperty()
1467 {
1468     QCOMPARE(ed->wordWrapMode(), QTextOption::WrapAtWordBoundaryOrAnywhere);
1469     QCOMPARE(ed->lineWrapMode(), QPlainTextEdit::WidgetWidth);
1470     ed->setLineWrapMode(QPlainTextEdit::NoWrap);
1471     QCOMPARE(ed->lineWrapMode(), QPlainTextEdit::NoWrap);
1472     QCOMPARE(ed->wordWrapMode(), QTextOption::WrapAtWordBoundaryOrAnywhere);
1473     QCOMPARE(ed->document()->defaultTextOption().wrapMode(), QTextOption::NoWrap);
1474 }
1475 
1476 void tst_QPlainTextEdit::selectionChanged()
1477 {
1478     ed->setPlainText("Hello World");
1479 
1480     ed->moveCursor(QTextCursor::Start);
1481 
1482     QSignalSpy selectionChangedSpy(ed, SIGNAL(selectionChanged()));
1483 
1484     QTest::keyClick(ed, Qt::Key_Right);
1485     QCOMPARE(ed->textCursor().position(), 1);
1486     QCOMPARE(selectionChangedSpy.count(), 0);
1487 
1488     QTest::keyClick(ed, Qt::Key_Right, Qt::ShiftModifier);
1489     QCOMPARE(ed->textCursor().position(), 2);
1490     QCOMPARE(selectionChangedSpy.count(), 1);
1491 
1492     QTest::keyClick(ed, Qt::Key_Right, Qt::ShiftModifier);
1493     QCOMPARE(ed->textCursor().position(), 3);
1494     QCOMPARE(selectionChangedSpy.count(), 2);
1495 
1496     QTest::keyClick(ed, Qt::Key_Right, Qt::ShiftModifier);
1497     QCOMPARE(ed->textCursor().position(), 4);
1498     QCOMPARE(selectionChangedSpy.count(), 3);
1499 
1500     QTest::keyClick(ed, Qt::Key_Right);
1501     QCOMPARE(ed->textCursor().position(), 4);
1502     QCOMPARE(selectionChangedSpy.count(), 4);
1503 
1504     QTest::keyClick(ed, Qt::Key_Right);
1505     QCOMPARE(ed->textCursor().position(), 5);
1506     QCOMPARE(selectionChangedSpy.count(), 4);
1507 }
1508 
1509 void tst_QPlainTextEdit::blockCountChanged()
1510 {
1511     QSignalSpy blockCountCpangedSpy(ed, SIGNAL(blockCountChanged(int)));
1512     ed->setPlainText("Hello");
1513     QCOMPARE(blockCountCpangedSpy.count(), 0);
1514     ed->setPlainText("Hello World");
1515     QCOMPARE(blockCountCpangedSpy.count(), 0);
1516     ed->setPlainText("Hello \n World \n this \n has \n more \n blocks \n than \n just \n one");
1517     QCOMPARE(blockCountCpangedSpy.count(), 1);
1518     ed->setPlainText("One");
1519     QCOMPARE(blockCountCpangedSpy.count(), 2);
1520     ed->setPlainText("One \n Two");
1521     QCOMPARE(blockCountCpangedSpy.count(), 3);
1522     ed->setPlainText("Three \n Four");
1523     QCOMPARE(blockCountCpangedSpy.count(), 3);
1524 }
1525 
1526 
1527 void tst_QPlainTextEdit::insertAndScrollToBottom()
1528 {
1529     ed->setPlainText("First Line");
1530     ed->show();
1531     QString text;
1532     for(int i = 0; i < 2000; ++i) {
1533         text += QLatin1String("this is another line of text to be appended. It is quite long and will probably wrap around, meaning the number of lines is larger than the number of blocks in the text.\n");
1534     }
1535     QTextCursor cursor = ed->textCursor();
1536     cursor.beginEditBlock();
1537     cursor.insertText(text);
1538     cursor.endEditBlock();
1539     ed->verticalScrollBar()->setValue(ed->verticalScrollBar()->maximum());
1540     QCOMPARE(ed->verticalScrollBar()->value(), ed->verticalScrollBar()->maximum());
1541 }
1542 
1543 Q_DECLARE_METATYPE(Qt::InputMethodHints)
1544 void tst_QPlainTextEdit::inputMethodQueryImHints_data()
1545 {
1546     QTest::addColumn<Qt::InputMethodHints>("hints");
1547 
1548     QTest::newRow("None") << static_cast<Qt::InputMethodHints>(Qt::ImhNone);
1549     QTest::newRow("Password") << static_cast<Qt::InputMethodHints>(Qt::ImhHiddenText);
1550     QTest::newRow("Normal") << static_cast<Qt::InputMethodHints>(Qt::ImhNoAutoUppercase | Qt::ImhNoPredictiveText | Qt::ImhSensitiveData);
1551 }
1552 
1553 void tst_QPlainTextEdit::inputMethodQueryImHints()
1554 {
1555     QFETCH(Qt::InputMethodHints, hints);
1556     ed->setInputMethodHints(hints);
1557 
1558     QVariant value = ed->inputMethodQuery(Qt::ImHints);
1559     QCOMPARE(static_cast<Qt::InputMethodHints>(value.toInt()), hints);
1560 }
1561 
1562 #if QT_CONFIG(regularexpression)
1563 void tst_QPlainTextEdit::findWithRegularExpression()
1564 {
1565     ed->setPlainText(QStringLiteral("arbitrary text"));
1566     QRegularExpression rx("\\w{2}xt");
1567 
1568     bool found = ed->find(rx);
1569 
1570     QVERIFY(found);
1571     QCOMPARE(ed->textCursor().selectedText(), QStringLiteral("text"));
1572 }
1573 
1574 void tst_QPlainTextEdit::findBackwardWithRegularExpression()
1575 {
1576     ed->setPlainText(QStringLiteral("arbitrary text"));
1577     QTextCursor cursor = ed->textCursor();
1578     cursor.movePosition(QTextCursor::End);
1579     ed->setTextCursor(cursor);
1580     QRegularExpression rx("a\\w*t");
1581 
1582     bool found = ed->find(rx, QTextDocument::FindBackward);
1583 
1584     QVERIFY(found);
1585     QCOMPARE(ed->textCursor().selectedText(), QStringLiteral("arbit"));
1586 }
1587 
1588 void tst_QPlainTextEdit::findWithRegularExpressionReturnsFalseIfNoMoreResults()
1589 {
1590     ed->setPlainText(QStringLiteral("arbitrary text"));
1591     QRegularExpression rx("t.xt");
1592     ed->find(rx);
1593 
1594     bool found = ed->find(rx);
1595 
1596     QVERIFY(!found);
1597     QCOMPARE(ed->textCursor().selectedText(), QStringLiteral("text"));
1598 }
1599 #endif
1600 
1601 void tst_QPlainTextEdit::layoutAfterMultiLineRemove()
1602 {
1603     ed->setVisible(true); // The widget must be visible to reproduce this bug.
1604 
1605     QString contents;
1606     for (int i = 0; i < 5; ++i)
1607         contents.append("\ttest\n");
1608 
1609     ed->setPlainText(contents);
1610 
1611     /*
1612      * Remove the tab from the beginning of lines 2-4, in an edit block. The
1613      * edit block is required for the bug to be reproduced.
1614      */
1615 
1616     QTextCursor curs = ed->textCursor();
1617     curs.movePosition(QTextCursor::Start);
1618     curs.movePosition(QTextCursor::NextBlock);
1619 
1620     curs.beginEditBlock();
1621     for (int i = 0; i < 3; ++i) {
1622         curs.deleteChar();
1623         curs.movePosition(QTextCursor::NextBlock);
1624     }
1625     curs.endEditBlock();
1626 
1627     /*
1628      * Now, we're going to perform the following actions:
1629      *
1630      *     - Move to the beginning of the document.
1631      *     - Move down three times - this should put us at the front of block 3.
1632      *     - Move to the end of the line.
1633      *
1634      * At this point, if the document layout is behaving correctly, we should
1635      * still be positioned on block 3. Verify that this is the case.
1636      */
1637 
1638     curs.movePosition(QTextCursor::Start);
1639     curs.movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, 3);
1640     curs.movePosition(QTextCursor::EndOfLine);
1641 
1642     QCOMPARE(curs.blockNumber(), 3);
1643 }
1644 
1645 void tst_QPlainTextEdit::undoCommandRemovesAndReinsertsBlock()
1646 {
1647     ed->setVisible(true);
1648     ed->setPlainText(QStringLiteral("line1\nline2"));
1649     QCOMPARE(ed->document()->blockCount(), 2);
1650 
1651     QTextCursor cursor = ed->textCursor();
1652     cursor.movePosition(QTextCursor::Start);
1653     cursor.movePosition(QTextCursor::NextBlock, QTextCursor::KeepAnchor);
1654     cursor.insertText(QStringLiteral("\n"));
1655     QCOMPARE(ed->document()->blockCount(), 2);
1656 
1657     ed->undo();
1658     QCOMPARE(ed->document()->blockCount(), 2);
1659 
1660     QTextBlock block;
1661     for (block = ed->document()->begin(); block != ed->document()->end(); block = block.next()) {
1662         QVERIFY(block.isValid());
1663         QCOMPARE(block.length(), 6);
1664         QVERIFY(block.layout()->lineForTextPosition(0).isValid());
1665     }
1666 
1667 }
1668 
1669 class ContentsChangedFunctor {
1670 public:
1671     ContentsChangedFunctor(QPlainTextEdit *t) : textEdit(t) {}
1672     void operator()(int, int, int)
1673     {
1674         QTextCursor c(textEdit->textCursor());
1675         c.beginEditBlock();
1676         c.movePosition(QTextCursor::Start);
1677         c.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
1678         c.setCharFormat(QTextCharFormat());
1679         c.endEditBlock();
1680     }
1681 
1682 private:
1683     QPlainTextEdit *textEdit;
1684 };
1685 
1686 void tst_QPlainTextEdit::taskQTBUG_43562_lineCountCrash()
1687 {
1688     connect(ed->document(), &QTextDocument::contentsChange, ContentsChangedFunctor(ed));
1689     // Don't crash
1690     QTest::keyClicks(ed, "Some text");
1691     QTest::keyClick(ed, Qt::Key_Left);
1692     QTest::keyClick(ed, Qt::Key_Right);
1693     QTest::keyClick(ed, Qt::Key_A);
1694     QTest::keyClick(ed, Qt::Key_Left);
1695     QTest::keyClick(ed, Qt::Key_Right);
1696     QTest::keyClick(ed, Qt::Key_Space);
1697     QTest::keyClicks(ed, "nd some more");
1698     disconnect(ed->document(), SIGNAL(contentsChange(int, int, int)), 0, 0);
1699 }
1700 
1701 #ifndef QT_NO_CONTEXTMENU
1702 void tst_QPlainTextEdit::contextMenu()
1703 {
1704     ed->appendHtml(QStringLiteral("Hello <a href='http://www.qt.io'>Qt</a>"));
1705 
1706     QMenu *menu = ed->createStandardContextMenu();
1707     QVERIFY(menu);
1708     QAction *action = ed->findChild<QAction *>(QStringLiteral("link-copy"));
1709     QVERIFY(!action);
1710     delete menu;
1711     QVERIFY(!ed->findChild<QAction *>(QStringLiteral("link-copy")));
1712 
1713     ed->setTextInteractionFlags(Qt::TextBrowserInteraction);
1714 
1715     menu = ed->createStandardContextMenu();
1716     QVERIFY(menu);
1717     action = ed->findChild<QAction *>(QStringLiteral("link-copy"));
1718     QVERIFY(action);
1719     QVERIFY(!action->isEnabled());
1720     delete menu;
1721     QVERIFY(!ed->findChild<QAction *>(QStringLiteral("link-copy")));
1722 
1723     QTextCursor cursor = ed->textCursor();
1724     cursor.setPosition(ed->toPlainText().length() - 2);
1725     ed->setTextCursor(cursor);
1726 
1727     menu = ed->createStandardContextMenu(ed->cursorRect().center());
1728     QVERIFY(menu);
1729     action = ed->findChild<QAction *>(QStringLiteral("link-copy"));
1730     QVERIFY(action);
1731     QVERIFY(action->isEnabled());
1732     delete menu;
1733     QVERIFY(!ed->findChild<QAction *>(QStringLiteral("link-copy")));
1734 }
1735 #endif // QT_NO_CONTEXTMENU
1736 
1737 // QTBUG-51923: Verify that the cursor rectangle returned by the input
1738 // method query correctly reflects the viewport offset.
1739 void tst_QPlainTextEdit::inputMethodCursorRect()
1740 {
1741     ed->setPlainText("Line1\nLine2Line3\nLine3");
1742     ed->moveCursor(QTextCursor::End);
1743     const QRectF cursorRect = ed->cursorRect();
1744     const QVariant cursorRectV = ed->inputMethodQuery(Qt::ImCursorRectangle);
1745     QCOMPARE(cursorRectV.userType(), QMetaType::QRectF);
1746     QCOMPARE(cursorRectV.toRect(), cursorRect.toRect());
1747 }
1748 
1749 #if QT_CONFIG(scrollbar)
1750 // QTBUG-64730: Verify that the scrollbar is updated after center on scroll was set
1751 void tst_QPlainTextEdit::updateAfterChangeCenterOnScroll()
1752 {
1753     ed->setPlainText("Line1\nLine2Line3\nLine3");
1754     ed->show();
1755     ed->setCenterOnScroll(true);
1756     const int maxWithCenterOnScroll = ed->verticalScrollBar()->maximum();
1757     ed->setCenterOnScroll(false);
1758     const int maxWithoutCenterOnScroll = ed->verticalScrollBar()->maximum();
1759     QVERIFY(maxWithCenterOnScroll > maxWithoutCenterOnScroll);
1760 }
1761 
1762 #endif
1763 
1764 #ifndef QT_NO_CLIPBOARD
1765 void tst_QPlainTextEdit::updateCursorPositionAfterEdit()
1766 {
1767     QPlainTextEdit plaintextEdit;
1768     plaintextEdit.setPlainText("some text some text\nsome text some text");
1769 
1770     const auto initialPosition = 1;
1771 
1772     // select some text
1773     auto cursor = plaintextEdit.textCursor();
1774     cursor.setPosition(initialPosition, QTextCursor::MoveAnchor);
1775     cursor.setPosition(initialPosition + 3, QTextCursor::KeepAnchor);
1776     plaintextEdit.setTextCursor(cursor);
1777     QVERIFY(plaintextEdit.textCursor().hasSelection());
1778 
1779     QTest::keyClick(&plaintextEdit, Qt::Key_Delete);
1780     QTest::keyClick(&plaintextEdit, Qt::Key_Down);
1781     QTest::keyClick(&plaintextEdit, Qt::Key_Up);
1782 
1783     // Moving the cursor down and up should bring it to the initial position
1784     QCOMPARE(plaintextEdit.textCursor().position(), initialPosition);
1785 
1786     // Test the same with backspace
1787     cursor = plaintextEdit.textCursor();
1788     cursor.setPosition(initialPosition + 3, QTextCursor::KeepAnchor);
1789     plaintextEdit.setTextCursor(cursor);
1790     QVERIFY(plaintextEdit.textCursor().hasSelection());
1791 
1792     QTest::keyClick(&plaintextEdit, Qt::Key_Backspace);
1793     QTest::keyClick(&plaintextEdit, Qt::Key_Down);
1794     QTest::keyClick(&plaintextEdit, Qt::Key_Up);
1795 
1796     // Moving the cursor down and up should bring it to the initial position
1797     QCOMPARE(plaintextEdit.textCursor().position(), initialPosition);
1798 
1799     // Test insertion
1800     const QString txt("txt");
1801     QApplication::clipboard()->setText(txt);
1802     plaintextEdit.paste();
1803     QTest::keyClick(&plaintextEdit, Qt::Key_Down);
1804     QTest::keyClick(&plaintextEdit, Qt::Key_Up);
1805 
1806     // The curser should move back to the end of the copied text
1807     QCOMPARE(plaintextEdit.textCursor().position(), initialPosition + txt.length());
1808 }
1809 #endif
1810 
1811 void tst_QPlainTextEdit::appendTextWhenInvisible()
1812 {
1813     QWidget window;
1814     window.resize(640, 480);
1815 
1816     QPlainTextEdit *plainTextEdit = new QPlainTextEdit(&window);
1817     plainTextEdit->resize(320, 240);
1818 
1819     window.show();
1820     QVERIFY(QTest::qWaitForWindowActive(&window));
1821 
1822     // this should be long enough to let vertical scroll bar show up
1823     const QString baseText("text\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntext");
1824     const QString textToAppend("aaa");
1825 
1826     plainTextEdit->setPlainText(baseText + "\n" + textToAppend);
1827     const auto maxAfterSet = plainTextEdit->verticalScrollBar()->maximum();
1828     // make sure the vertical scroll bar is visible
1829     QVERIFY(maxAfterSet != 0);
1830 
1831     plainTextEdit->clear();
1832     plainTextEdit->setPlainText(baseText);
1833     plainTextEdit->hide();
1834     plainTextEdit->appendPlainText(textToAppend);
1835     plainTextEdit->show();
1836     const auto maxAfterAppend = plainTextEdit->verticalScrollBar()->maximum();
1837     QVERIFY(maxAfterAppend != 0);
1838 
1839     QCOMPARE(maxAfterAppend, maxAfterSet);
1840 }
1841 
1842 void tst_QPlainTextEdit::autoPlaceholderVisibility()
1843 {
1844     QPlainTextEdit *tempPtEdit = new QPlainTextEdit();
1845 
1846     // no placeholder set + no text set
1847     tempPtEdit->show();
1848     auto *tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1849     QVERIFY(tempPrivate->placeholderVisible);
1850     tempPtEdit->hide();
1851     delete tempPtEdit;
1852 
1853     // no placeholder set + text set
1854     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1855     tempPtEdit = new QPlainTextEdit();
1856     tempPtEdit->setPlainText("PlainText...");
1857     tempPtEdit->show();
1858     QVERIFY(!tempPrivate->placeholderVisible);
1859     tempPtEdit->hide();
1860     delete tempPtEdit;
1861 
1862     // no placeholder set + text set + empty text set
1863     tempPtEdit = new QPlainTextEdit();
1864     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1865     tempPtEdit->setPlainText("PlainText...");
1866     tempPtEdit->setPlainText("");
1867     tempPtEdit->show();
1868     QVERIFY(!tempPrivate->placeholderVisible);
1869     tempPtEdit->hide();
1870     delete tempPtEdit;
1871 
1872     // no placeholder set + empty text set + text set
1873     tempPtEdit = new QPlainTextEdit();
1874     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1875     tempPtEdit->setPlainText("");
1876     tempPtEdit->setPlainText("PlainText...");
1877     tempPtEdit->show();
1878     QVERIFY(!tempPrivate->placeholderVisible);
1879     tempPtEdit->hide();
1880     delete tempPtEdit;
1881 
1882     // empty placeholder set + no text set
1883     tempPtEdit = new QPlainTextEdit();
1884     tempPtEdit->setPlaceholderText("");
1885     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1886     QVERIFY(tempPrivate->placeholderVisible);
1887     tempPtEdit->hide();
1888     delete tempPtEdit;
1889 
1890     // empty placeholder set + text set
1891     tempPtEdit = new QPlainTextEdit();
1892     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1893     tempPtEdit->setPlaceholderText("");
1894     tempPtEdit->setPlainText("PlainText...");
1895     tempPtEdit->show();
1896     QVERIFY(!tempPrivate->placeholderVisible);
1897     tempPtEdit->hide();
1898     delete tempPtEdit;
1899 
1900     // empty placeholder set + text set + empty text set
1901     tempPtEdit = new QPlainTextEdit();
1902     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1903     tempPtEdit->setPlaceholderText("");
1904     tempPtEdit->setPlainText("PlainText...");
1905     tempPtEdit->setPlainText("");
1906     tempPtEdit->show();
1907     QVERIFY(!tempPrivate->placeholderVisible);
1908     tempPtEdit->hide();
1909     delete tempPtEdit;
1910 
1911     // empty placeholder set + empty text set + text set
1912     tempPtEdit = new QPlainTextEdit();
1913     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1914     tempPtEdit->setPlaceholderText("");
1915     tempPtEdit->setPlainText("");
1916     tempPtEdit->setPlainText("PlainText...");
1917     tempPtEdit->show();
1918     QVERIFY(!tempPrivate->placeholderVisible);
1919     tempPtEdit->hide();
1920     delete tempPtEdit;
1921 
1922     // placeholder set + no text set
1923     tempPtEdit = new QPlainTextEdit();
1924     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1925     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1926     tempPtEdit->show();
1927     QVERIFY(tempPrivate->placeholderVisible);
1928     tempPtEdit->hide();
1929     delete tempPtEdit;
1930 
1931     // placeholder set + text set
1932     tempPtEdit = new QPlainTextEdit();
1933     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1934     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1935     tempPtEdit->setPlainText("PlainText...");
1936     tempPtEdit->show();
1937     QVERIFY(!tempPrivate->placeholderVisible);
1938     tempPtEdit->hide();
1939     delete tempPtEdit;
1940 
1941     // placeholder set + text set + empty text set
1942     tempPtEdit = new QPlainTextEdit();
1943     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1944     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1945     tempPtEdit->setPlainText("PlainText...");
1946     tempPtEdit->setPlainText("");
1947     tempPtEdit->show();
1948     QVERIFY(tempPrivate->placeholderVisible);
1949     tempPtEdit->hide();
1950     delete tempPtEdit;
1951 
1952     // placeholder set + empty text set + text set
1953     tempPtEdit = new QPlainTextEdit();
1954     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1955     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1956     tempPtEdit->setPlainText("");
1957     tempPtEdit->setPlainText("PlainText...");
1958     tempPtEdit->show();
1959     QVERIFY(!tempPrivate->placeholderVisible);
1960     tempPtEdit->hide();
1961     delete tempPtEdit;
1962 
1963     // placeholder set + text set + empty placeholder set
1964     tempPtEdit = new QPlainTextEdit();
1965     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1966     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1967     tempPtEdit->setPlainText("PlainText...");
1968     tempPtEdit->show();
1969     QVERIFY(!tempPrivate->placeholderVisible);
1970     tempPtEdit->hide();
1971     delete tempPtEdit;
1972 
1973     // placeholder set + empty placeholder set + text set
1974     tempPtEdit = new QPlainTextEdit();
1975     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1976     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1977     tempPtEdit->setPlainText("PlainText...");
1978     tempPtEdit->show();
1979     QVERIFY(!tempPrivate->placeholderVisible);
1980     tempPtEdit->hide();
1981     delete tempPtEdit;
1982 
1983     // placeholder set + empty placeholder set + empty text set
1984     tempPtEdit = new QPlainTextEdit();
1985     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1986     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1987     tempPtEdit->setPlaceholderText("");
1988     tempPtEdit->setPlainText("");
1989     tempPtEdit->show();
1990     QVERIFY(!tempPrivate->placeholderVisible);
1991     tempPtEdit->hide();
1992     delete tempPtEdit;
1993 
1994     // placeholder set + empty text set + empty placeholder set
1995     tempPtEdit = new QPlainTextEdit();
1996     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
1997     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
1998     tempPtEdit->setPlainText("");
1999     tempPtEdit->setPlaceholderText("");
2000     tempPtEdit->show();
2001     QVERIFY(!tempPrivate->placeholderVisible);
2002     tempPtEdit->hide();
2003     delete tempPtEdit;
2004 
2005     // text set + no placeholder set
2006     tempPtEdit = new QPlainTextEdit();
2007     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
2008     tempPtEdit->setPlainText("PlainText...");
2009     tempPtEdit->show();
2010     QVERIFY(!tempPrivate->placeholderVisible);
2011     tempPtEdit->hide();
2012     delete tempPtEdit;
2013 
2014     // text set + no placeholder set + empty text set
2015     tempPtEdit = new QPlainTextEdit();
2016     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
2017     tempPtEdit->setPlainText("PlainText...");
2018     tempPtEdit->setPlainText("");
2019     tempPtEdit->show();
2020     QVERIFY(!tempPrivate->placeholderVisible);
2021     tempPtEdit->hide();
2022     delete tempPtEdit;
2023 
2024     // text set + empty placeholder set
2025     tempPtEdit = new QPlainTextEdit();
2026     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
2027     tempPtEdit->setPlainText("PlainText...");
2028     tempPtEdit->setPlaceholderText("");
2029     tempPtEdit->show();
2030     QVERIFY(!tempPrivate->placeholderVisible);
2031     tempPtEdit->hide();
2032     delete tempPtEdit;
2033 
2034     // text set + empty placeholder set + empty text set
2035     tempPtEdit = new QPlainTextEdit();
2036     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
2037     tempPtEdit->setPlainText("PlainText...");
2038     tempPtEdit->setPlaceholderText("");
2039     tempPtEdit->setPlainText("");
2040     tempPtEdit->show();
2041     QVERIFY(!tempPrivate->placeholderVisible);
2042     tempPtEdit->hide();
2043     delete tempPtEdit;
2044 
2045     // text set + placeholder set
2046     tempPtEdit = new QPlainTextEdit();
2047     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
2048     tempPtEdit->setPlainText("PlainText...");
2049     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
2050     tempPtEdit->show();
2051     QVERIFY(!tempPrivate->placeholderVisible);
2052     tempPtEdit->hide();
2053     delete tempPtEdit;
2054 
2055     // text set + placeholder set + empty text set
2056     tempPtEdit = new QPlainTextEdit();
2057     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
2058     tempPtEdit->setPlainText("PlainText...");
2059     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
2060     tempPtEdit->setPlainText("");
2061     tempPtEdit->show();
2062     QVERIFY(tempPrivate->placeholderVisible);
2063     tempPtEdit->hide();
2064     delete tempPtEdit;
2065 
2066     // text set + placeholder set + empty placeholder set
2067     tempPtEdit = new QPlainTextEdit();
2068     tempPrivate = static_cast<QPlainTextEditPrivate *>(qt_widget_private(tempPtEdit));
2069     tempPtEdit->setPlainText("PlainText...");
2070     tempPtEdit->setPlaceholderText("Qt is awesome!!!");
2071     tempPtEdit->setPlaceholderText("");
2072     tempPtEdit->show();
2073     QVERIFY(!tempPrivate->placeholderVisible);
2074     tempPtEdit->hide();
2075     delete tempPtEdit;
2076 }
2077 
2078 QTEST_MAIN(tst_QPlainTextEdit)
2079 #include "tst_qplaintextedit.moc"
