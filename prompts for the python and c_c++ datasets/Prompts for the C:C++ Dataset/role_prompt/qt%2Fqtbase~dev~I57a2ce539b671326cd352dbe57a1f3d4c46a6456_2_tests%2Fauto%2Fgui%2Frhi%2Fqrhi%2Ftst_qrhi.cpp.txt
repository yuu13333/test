I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2019 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the test suite of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
21 ** included in the packaging of this file. Please review the following
22 ** information to ensure the GNU General Public License requirements will
23 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
24 **
25 ** $QT_END_LICENSE$
26 **
27 ****************************************************************************/
28 
29 #include <QTest>
30 #include <QThread>
31 #include <QFile>
32 #include <QOffscreenSurface>
33 #include <QPainter>
34 
35 #include <QtGui/private/qrhi_p.h>
36 #include <QtGui/private/qrhinull_p.h>
37 
38 #if QT_CONFIG(opengl)
39 # include <QOpenGLContext>
40 # include <QOpenGLFunctions>
41 # include <QtGui/private/qrhigles2_p.h>
42 # define TST_GL
43 #endif
44 
45 #if QT_CONFIG(vulkan)
46 # include <QVulkanInstance>
47 # include <QVulkanFunctions>
48 # include <QtGui/private/qrhivulkan_p.h>
49 # define TST_VK
50 #endif
51 
52 #ifdef Q_OS_WIN
53 #include <QtGui/private/qrhid3d11_p.h>
54 # define TST_D3D11
55 #endif
56 
57 #if defined(Q_OS_MACOS) || defined(Q_OS_IOS)
58 # include <QtGui/private/qrhimetal_p.h>
59 # define TST_MTL
60 #endif
61 
62 Q_DECLARE_METATYPE(QRhi::Implementation)
63 Q_DECLARE_METATYPE(QRhiInitParams *)
64 
65 class tst_QRhi : public QObject
66 {
67     Q_OBJECT
68 
69 private slots:
70     void initTestCase();
71     void cleanupTestCase();
72 
73     void rhiTestData();
74     void rhiTestDataOpenGL();
75     void create_data();
76     void create();
77     void nativeHandles_data();
78     void nativeHandles();
79     void nativeHandlesImportVulkan();
80     void nativeHandlesImportD3D11();
81     void nativeHandlesImportOpenGL();
82     void nativeTexture_data();
83     void nativeTexture();
84     void nativeBuffer_data();
85     void nativeBuffer();
86     void resourceUpdateBatchBuffer_data();
87     void resourceUpdateBatchBuffer();
88     void resourceUpdateBatchRGBATextureUpload_data();
89     void resourceUpdateBatchRGBATextureUpload();
90     void resourceUpdateBatchRGBATextureCopy_data();
91     void resourceUpdateBatchRGBATextureCopy();
92     void resourceUpdateBatchRGBATextureMip_data();
93     void resourceUpdateBatchRGBATextureMip();
94     void resourceUpdateBatchTextureRawDataStride_data();
95     void resourceUpdateBatchTextureRawDataStride();
96     void resourceUpdateBatchLotsOfResources_data();
97     void resourceUpdateBatchLotsOfResources();
98     void invalidPipeline_data();
99     void invalidPipeline();
100     void srbLayoutCompatibility_data();
101     void srbLayoutCompatibility();
102     void srbWithNoResource_data();
103     void srbWithNoResource();
104     void renderPassDescriptorCompatibility_data();
105     void renderPassDescriptorCompatibility();
106     void renderPassDescriptorClone_data();
107     void renderPassDescriptorClone();
108 
109     void renderToTextureSimple_data();
110     void renderToTextureSimple();
111     void renderToTextureMip_data();
112     void renderToTextureMip();
113     void renderToTextureCubemapFace_data();
114     void renderToTextureCubemapFace();
115     void renderToTextureTexturedQuad_data();
116     void renderToTextureTexturedQuad();
117     void renderToTextureArrayOfTexturedQuad_data();
118     void renderToTextureArrayOfTexturedQuad();
119     void renderToTextureTexturedQuadAndUniformBuffer_data();
120     void renderToTextureTexturedQuadAndUniformBuffer();
121     void renderToTextureTexturedQuadAllDynamicBuffers_data();
122     void renderToTextureTexturedQuadAllDynamicBuffers();
123     void renderToTextureDeferredSrb_data();
124     void renderToTextureDeferredSrb();
125     void renderToTextureMultipleUniformBuffersAndDynamicOffset_data();
126     void renderToTextureMultipleUniformBuffersAndDynamicOffset();
127     void renderToTextureSrbReuse_data();
128     void renderToTextureSrbReuse();
129     void renderToTextureIndexedDraw_data();
130     void renderToTextureIndexedDraw();
131     void renderToWindowSimple_data();
132     void renderToWindowSimple();
133     void finishWithinSwapchainFrame_data();
134     void finishWithinSwapchainFrame();
135 
136     void pipelineCache_data();
137     void pipelineCache();
138     void textureImportOpenGL_data();
139     void textureImportOpenGL();
140     void renderbufferImportOpenGL_data();
141     void renderbufferImportOpenGL();
142     void threeDimTexture_data();
143     void threeDimTexture();
144     void leakedResourceDestroy_data();
145     void leakedResourceDestroy();
146 
147 private:
148     void setWindowType(QWindow *window, QRhi::Implementation impl);
149 
150     struct {
151         QRhiNullInitParams null;
152 #ifdef TST_GL
153         QRhiGles2InitParams gl;
154 #endif
155 #ifdef TST_VK
156         QRhiVulkanInitParams vk;
157 #endif
158 #ifdef TST_D3D11
159         QRhiD3D11InitParams d3d;
160 #endif
161 #ifdef TST_MTL
162         QRhiMetalInitParams mtl;
163 #endif
164     } initParams;
165 
166 #ifdef TST_VK
167     QVulkanInstance vulkanInstance;
168 #endif
169     QOffscreenSurface *fallbackSurface = nullptr;
170 };
171 
172 void tst_QRhi::initTestCase()
173 {
174 #ifdef TST_GL
175     fallbackSurface = QRhiGles2InitParams::newFallbackSurface();
176     initParams.gl.fallbackSurface = fallbackSurface;
177 #endif
178 
179 #ifdef TST_VK
180     const QVersionNumber supportedVersion = vulkanInstance.supportedApiVersion();
181     if (supportedVersion >= QVersionNumber(1, 2))
182         vulkanInstance.setApiVersion(QVersionNumber(1, 2));
183     else if (supportedVersion >= QVersionNumber(1, 1))
184         vulkanInstance.setApiVersion(QVersionNumber(1, 2));
185     vulkanInstance.setLayers({ "VK_LAYER_KHRONOS_validation" });
186     vulkanInstance.setExtensions(QRhiVulkanInitParams::preferredInstanceExtensions());
187     vulkanInstance.create();
188     initParams.vk.inst = &vulkanInstance;
189 #endif
190 
191 #ifdef TST_D3D11
192     initParams.d3d.enableDebugLayer = true;
193 #endif
194 }
195 
196 void tst_QRhi::cleanupTestCase()
197 {
198 #ifdef TST_VK
199     vulkanInstance.destroy();
200 #endif
201 
202     delete fallbackSurface;
203 }
204 
205 void tst_QRhi::rhiTestData()
206 {
207     QTest::addColumn<QRhi::Implementation>("impl");
208     QTest::addColumn<QRhiInitParams *>("initParams");
209 
210     QTest::newRow("Null") << QRhi::Null << static_cast<QRhiInitParams *>(&initParams.null);
211 #ifdef TST_GL
212     QTest::newRow("OpenGL") << QRhi::OpenGLES2 << static_cast<QRhiInitParams *>(&initParams.gl);
213 #endif
214 #ifdef TST_VK
215     if (vulkanInstance.isValid())
216         QTest::newRow("Vulkan") << QRhi::Vulkan << static_cast<QRhiInitParams *>(&initParams.vk);
217 #endif
218 #ifdef TST_D3D11
219     QTest::newRow("Direct3D 11") << QRhi::D3D11 << static_cast<QRhiInitParams *>(&initParams.d3d);
220 #endif
221 #ifdef TST_MTL
222     QTest::newRow("Metal") << QRhi::Metal << static_cast<QRhiInitParams *>(&initParams.mtl);
223 #endif
224 }
225 
226 void tst_QRhi::rhiTestDataOpenGL()
227 {
228     QTest::addColumn<QRhi::Implementation>("impl");
229     QTest::addColumn<QRhiInitParams *>("initParams");
230 
231 #ifdef TST_GL
232     QTest::newRow("OpenGL") << QRhi::OpenGLES2 << static_cast<QRhiInitParams *>(&initParams.gl);
233 #endif
234 }
235 
236 void tst_QRhi::create_data()
237 {
238     rhiTestData();
239 }
240 
241 static int aligned(int v, int a)
242 {
243     return (v + a - 1) & ~(a - 1);
244 }
245 
246 void tst_QRhi::create()
247 {
248     // Merely attempting to create a QRhi should survive, with an error when
249     // not supported. (of course, there is always a chance we encounter a crash
250     // due to some random graphics stack...)
251 
252     QFETCH(QRhi::Implementation, impl);
253     QFETCH(QRhiInitParams *, initParams);
254 
255     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
256 
257     if (rhi) {
258         qDebug() << rhi->driverInfo();
259 
260         QCOMPARE(rhi->backend(), impl);
261         QVERIFY(strcmp(rhi->backendName(), ""));
262         QVERIFY(!rhi->driverInfo().deviceName.isEmpty());
263         QCOMPARE(rhi->thread(), QThread::currentThread());
264 
265         // do a basic smoke test for the apis that do not directly render anything
266 
267         int cleanupOk = 0;
268         QRhi *rhiPtr = rhi.data();
269         auto cleanupFunc = [rhiPtr, &cleanupOk](QRhi *dyingRhi) {
270             if (rhiPtr == dyingRhi)
271                 cleanupOk += 1;
272         };
273         rhi->addCleanupCallback(cleanupFunc);
274         rhi->runCleanup();
275         QCOMPARE(cleanupOk, 1);
276         cleanupOk = 0;
277         rhi->addCleanupCallback(cleanupFunc);
278 
279         QRhiResourceUpdateBatch *resUpd = rhi->nextResourceUpdateBatch();
280         QVERIFY(resUpd);
281         resUpd->release();
282 
283         QRhiResourceUpdateBatch *resUpdArray[64];
284         for (int i = 0; i < 64; ++i) {
285             resUpdArray[i] = rhi->nextResourceUpdateBatch();
286             QVERIFY(resUpdArray[i]);
287         }
288         resUpd = rhi->nextResourceUpdateBatch();
289         QVERIFY(!resUpd);
290         for (int i = 0; i < 64; ++i)
291             resUpdArray[i]->release();
292         resUpd = rhi->nextResourceUpdateBatch();
293         QVERIFY(resUpd);
294         resUpd->release();
295 
296         QVERIFY(!rhi->supportedSampleCounts().isEmpty());
297         QVERIFY(rhi->supportedSampleCounts().contains(1));
298 
299         QVERIFY(rhi->ubufAlignment() > 0);
300         QCOMPARE(rhi->ubufAligned(123), aligned(123, rhi->ubufAlignment()));
301 
302         QCOMPARE(rhi->mipLevelsForSize(QSize(512, 300)), 10);
303         QCOMPARE(rhi->sizeForMipLevel(0, QSize(512, 300)), QSize(512, 300));
304         QCOMPARE(rhi->sizeForMipLevel(1, QSize(512, 300)), QSize(256, 150));
305         QCOMPARE(rhi->sizeForMipLevel(2, QSize(512, 300)), QSize(128, 75));
306         QCOMPARE(rhi->sizeForMipLevel(9, QSize(512, 300)), QSize(1, 1));
307 
308         const bool fbUp = rhi->isYUpInFramebuffer();
309         const bool ndcUp = rhi->isYUpInNDC();
310         const bool d0to1 = rhi->isClipDepthZeroToOne();
311         const QMatrix4x4 corrMat = rhi->clipSpaceCorrMatrix();
312         if (impl == QRhi::OpenGLES2) {
313             QVERIFY(fbUp);
314             QVERIFY(ndcUp);
315             QVERIFY(!d0to1);
316             QVERIFY(corrMat.isIdentity());
317         } else if (impl == QRhi::Vulkan) {
318             QVERIFY(!fbUp);
319             QVERIFY(!ndcUp);
320             QVERIFY(d0to1);
321             QVERIFY(!corrMat.isIdentity());
322         } else if (impl == QRhi::D3D11) {
323             QVERIFY(!fbUp);
324             QVERIFY(ndcUp);
325             QVERIFY(d0to1);
326             QVERIFY(!corrMat.isIdentity());
327         } else if (impl == QRhi::Metal) {
328             QVERIFY(!fbUp);
329             QVERIFY(ndcUp);
330             QVERIFY(d0to1);
331             QVERIFY(!corrMat.isIdentity());
332         }
333 
334         const int texMin = rhi->resourceLimit(QRhi::TextureSizeMin);
335         const int texMax = rhi->resourceLimit(QRhi::TextureSizeMax);
336         const int maxAtt = rhi->resourceLimit(QRhi::MaxColorAttachments);
337         const int framesInFlight = rhi->resourceLimit(QRhi::FramesInFlight);
338         QVERIFY(texMin >= 1);
339         QVERIFY(texMax >= texMin);
340         QVERIFY(maxAtt >= 1);
341         QVERIFY(framesInFlight >= 1);
342 
343         QVERIFY(rhi->nativeHandles());
344         QVERIFY(rhi->profiler());
345 
346         const QRhi::Feature features[] = {
347             QRhi::MultisampleTexture,
348             QRhi::MultisampleRenderBuffer,
349             QRhi::DebugMarkers,
350             QRhi::Timestamps,
351             QRhi::Instancing,
352             QRhi::CustomInstanceStepRate,
353             QRhi::PrimitiveRestart,
354             QRhi::NonDynamicUniformBuffers,
355             QRhi::NonFourAlignedEffectiveIndexBufferOffset,
356             QRhi::NPOTTextureRepeat,
357             QRhi::RedOrAlpha8IsRed,
358             QRhi::ElementIndexUint,
359             QRhi::Compute,
360             QRhi::WideLines,
361             QRhi::VertexShaderPointSize,
362             QRhi::BaseVertex,
363             QRhi::BaseInstance,
364             QRhi::TriangleFanTopology,
365             QRhi::ReadBackNonUniformBuffer,
366             QRhi::ReadBackNonBaseMipLevel,
367             QRhi::TexelFetch,
368             QRhi::RenderToNonBaseMipLevel,
369             QRhi::IntAttributes,
370             QRhi::ScreenSpaceDerivatives,
371             QRhi::ReadBackAnyTextureFormat,
372             QRhi::PipelineCacheDataLoadSave,
373             QRhi::ImageDataStride,
374             QRhi::RenderBufferImport,
375             QRhi::ThreeDimensionalTextures
376         };
377         for (size_t i = 0; i <sizeof(features) / sizeof(QRhi::Feature); ++i)
378             rhi->isFeatureSupported(features[i]);
379 
380         QVERIFY(rhi->isTextureFormatSupported(QRhiTexture::RGBA8));
381 
382         rhi->releaseCachedResources();
383 
384         QVERIFY(!rhi->isDeviceLost());
385 
386         rhi.reset();
387         QCOMPARE(cleanupOk, 1);
388     }
389 }
390 
391 void tst_QRhi::nativeHandles_data()
392 {
393     rhiTestData();
394 }
395 
396 void tst_QRhi::nativeHandles()
397 {
398     QFETCH(QRhi::Implementation, impl);
399     QFETCH(QRhiInitParams *, initParams);
400 
401     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
402     if (!rhi)
403         QSKIP("QRhi could not be created, skipping testing native handles");
404 
405     // QRhi::nativeHandles()
406     {
407         const QRhiNativeHandles *rhiHandles = rhi->nativeHandles();
408         Q_ASSERT(rhiHandles);
409 
410         switch (impl) {
411         case QRhi::Null:
412             break;
413 #ifdef TST_VK
414         case QRhi::Vulkan:
415         {
416             const QRhiVulkanNativeHandles *vkHandles = static_cast<const QRhiVulkanNativeHandles *>(rhiHandles);
417             QVERIFY(vkHandles->physDev);
418             QVERIFY(vkHandles->dev);
419             QVERIFY(vkHandles->gfxQueueFamilyIdx >= 0);
420             QVERIFY(vkHandles->gfxQueueIdx >= 0);
421             QVERIFY(vkHandles->gfxQueue);
422             QVERIFY(vkHandles->vmemAllocator);
423         }
424             break;
425 #endif
426 #ifdef TST_GL
427         case QRhi::OpenGLES2:
428         {
429             const QRhiGles2NativeHandles *glHandles = static_cast<const QRhiGles2NativeHandles *>(rhiHandles);
430             QVERIFY(glHandles->context);
431             QVERIFY(glHandles->context->isValid());
432             glHandles->context->doneCurrent();
433             QVERIFY(!QOpenGLContext::currentContext());
434             rhi->makeThreadLocalNativeContextCurrent();
435             QVERIFY(QOpenGLContext::currentContext() == glHandles->context);
436         }
437             break;
438 #endif
439 #ifdef TST_D3D11
440         case QRhi::D3D11:
441         {
442             const QRhiD3D11NativeHandles *d3dHandles = static_cast<const QRhiD3D11NativeHandles *>(rhiHandles);
443             QVERIFY(d3dHandles->dev);
444             QVERIFY(d3dHandles->context);
445             QVERIFY(d3dHandles->featureLevel > 0);
446             QVERIFY(d3dHandles->adapterLuidLow || d3dHandles->adapterLuidHigh);
447         }
448             break;
449 #endif
450 #ifdef TST_MTL
451         case QRhi::Metal:
452         {
453             const QRhiMetalNativeHandles *mtlHandles = static_cast<const QRhiMetalNativeHandles *>(rhiHandles);
454             QVERIFY(mtlHandles->dev);
455             QVERIFY(mtlHandles->cmdQueue);
456         }
457             break;
458 #endif
459         default:
460             Q_ASSERT(false);
461         }
462     }
463 
464     // QRhiCommandBuffer::nativeHandles()
465     {
466         QRhiCommandBuffer *cb = nullptr;
467         QRhi::FrameOpResult result = rhi->beginOffscreenFrame(&cb);
468         QVERIFY(result == QRhi::FrameOpSuccess);
469         QVERIFY(cb);
470 
471         Q_DECL_UNUSED const QRhiNativeHandles *cbHandles = cb->nativeHandles();
472         // no null check here, backends where not applicable will return null
473 
474         switch (impl) {
475         case QRhi::Null:
476             break;
477 #ifdef TST_VK
478         case QRhi::Vulkan:
479         {
480             const QRhiVulkanCommandBufferNativeHandles *vkHandles = static_cast<const QRhiVulkanCommandBufferNativeHandles *>(cbHandles);
481             QVERIFY(vkHandles);
482             QVERIFY(vkHandles->commandBuffer);
483         }
484             break;
485 #endif
486 #ifdef TST_GL
487         case QRhi::OpenGLES2:
488             break;
489 #endif
490 #ifdef TST_D3D11
491         case QRhi::D3D11:
492             break;
493 #endif
494 #ifdef TST_MTL
495         case QRhi::Metal:
496         {
497             const QRhiMetalCommandBufferNativeHandles *mtlHandles = static_cast<const QRhiMetalCommandBufferNativeHandles *>(cbHandles);
498             QVERIFY(mtlHandles);
499             QVERIFY(mtlHandles->commandBuffer);
500             QVERIFY(!mtlHandles->encoder);
501 
502             QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
503             QVERIFY(tex->create());
504             QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ tex.data() }));
505             QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
506             QVERIFY(rpDesc);
507             rt->setRenderPassDescriptor(rpDesc.data());
508             QVERIFY(rt->create());
509             cb->beginPass(rt.data(), Qt::red, { 1.0f, 0 });
510             QVERIFY(static_cast<const QRhiMetalCommandBufferNativeHandles *>(cb->nativeHandles())->encoder);
511             cb->endPass();
512         }
513             break;
514 #endif
515         default:
516             Q_ASSERT(false);
517         }
518 
519         rhi->endOffscreenFrame();
520     }
521 
522     // QRhiRenderPassDescriptor::nativeHandles()
523     {
524         QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
525         QVERIFY(tex->create());
526         QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ tex.data() }));
527         QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
528         QVERIFY(rpDesc);
529         rt->setRenderPassDescriptor(rpDesc.data());
530         QVERIFY(rt->create());
531 
532         switch (impl) {
533         case QRhi::Null:
534             break;
535 #ifdef TST_VK
536         case QRhi::Vulkan:
537         {
538             const QRhiNativeHandles *rpHandles = rpDesc->nativeHandles();
539             const QRhiVulkanRenderPassNativeHandles *vkHandles = static_cast<const QRhiVulkanRenderPassNativeHandles *>(rpHandles);
540             QVERIFY(vkHandles);
541             QVERIFY(vkHandles->renderPass);
542         }
543             break;
544 #endif
545 #ifdef TST_GL
546         case QRhi::OpenGLES2:
547             break;
548 #endif
549 #ifdef TST_D3D11
550         case QRhi::D3D11:
551             break;
552 #endif
553 #ifdef TST_MTL
554         case QRhi::Metal:
555             break;
556 #endif
557         default:
558             Q_ASSERT(false);
559         }
560     }
561 }
562 
563 void tst_QRhi::nativeHandlesImportVulkan()
564 {
565 #ifdef TST_VK
566     // VkDevice and everything else. For simplicity we'll get QRhi to create one, and then use that with another QRhi.
567     {
568         QScopedPointer<QRhi> rhi(QRhi::create(QRhi::Vulkan, &initParams.vk, QRhi::Flags(), nullptr));
569         if (!rhi)
570             QSKIP("Skipping native Vulkan test");
571 
572         const QRhiVulkanNativeHandles *nativeHandles = static_cast<const QRhiVulkanNativeHandles *>(rhi->nativeHandles());
573         QRhiVulkanNativeHandles h = *nativeHandles;
574         // do not pass the rarely used fields, this is useful to test if it creates its own as expected
575         h.vmemAllocator = nullptr;
576 
577         QScopedPointer<QRhi> adoptingRhi(QRhi::create(QRhi::Vulkan, &initParams.vk, QRhi::Flags(), &h));
578         QVERIFY(adoptingRhi);
579 
580         const QRhiVulkanNativeHandles *newNativeHandles = static_cast<const QRhiVulkanNativeHandles *>(adoptingRhi->nativeHandles());
581         QCOMPARE(newNativeHandles->physDev, nativeHandles->physDev);
582         QCOMPARE(newNativeHandles->dev, nativeHandles->dev);
583         QCOMPARE(newNativeHandles->gfxQueueFamilyIdx, nativeHandles->gfxQueueFamilyIdx);
584         QCOMPARE(newNativeHandles->gfxQueueIdx, nativeHandles->gfxQueueIdx);
585         QVERIFY(newNativeHandles->vmemAllocator != nativeHandles->vmemAllocator);
586     }
587 
588     // Physical device only
589     {
590         uint32_t physDevCount = 0;
591         QVulkanFunctions *f = vulkanInstance.functions();
592         f->vkEnumeratePhysicalDevices(vulkanInstance.vkInstance(), &physDevCount, nullptr);
593         if (physDevCount < 1)
594             QSKIP("No Vulkan physical devices, skip");
595         QVarLengthArray<VkPhysicalDevice, 4> physDevs(physDevCount);
596         f->vkEnumeratePhysicalDevices(vulkanInstance.vkInstance(), &physDevCount, physDevs.data());
597 
598         for (uint32_t i = 0; i < physDevCount; ++i) {
599             QRhiVulkanNativeHandles h;
600             h.physDev = physDevs[i];
601             QScopedPointer<QRhi> rhi(QRhi::create(QRhi::Vulkan, &initParams.vk, QRhi::Flags(), &h));
602             // ok if fails, what we want to know is that if it succeeds, it must use that given phys.dev.
603             if (!rhi) {
604                 qWarning("Skipping native Vulkan handle test for physical device %u", i);
605                 continue;
606             }
607             const QRhiVulkanNativeHandles *actualNativeHandles = static_cast<const QRhiVulkanNativeHandles *>(rhi->nativeHandles());
608             QCOMPARE(actualNativeHandles->physDev, physDevs[i]);
609         }
610     }
611 
612 #else
613     QSKIP("Skipping Vulkan-specific test");
614 #endif
615 }
616 
617 void tst_QRhi::nativeHandlesImportD3D11()
618 {
619 #ifdef TST_D3D11
620     QScopedPointer<QRhi> rhi(QRhi::create(QRhi::D3D11, &initParams.d3d, QRhi::Flags(), nullptr));
621     if (!rhi)
622         QSKIP("QRhi could not be created, skipping testing D3D11 native handle import");
623 
624     const QRhiD3D11NativeHandles *nativeHandles = static_cast<const QRhiD3D11NativeHandles *>(rhi->nativeHandles());
625 
626     // Case 1: device and context
627     {
628         QRhiD3D11NativeHandles h = *nativeHandles;
629         h.featureLevel = 0; // see if these are queried as expected, even when not provided
630         h.adapterLuidLow = 0;
631         h.adapterLuidHigh = 0;
632         QScopedPointer<QRhi> adoptingRhi(QRhi::create(QRhi::D3D11, &initParams.d3d, QRhi::Flags(), &h));
633         QVERIFY(adoptingRhi);
634         const QRhiD3D11NativeHandles *newNativeHandles = static_cast<const QRhiD3D11NativeHandles *>(adoptingRhi->nativeHandles());
635         QCOMPARE(newNativeHandles->dev, nativeHandles->dev);
636         QCOMPARE(newNativeHandles->context, nativeHandles->context);
637         QCOMPARE(newNativeHandles->featureLevel, nativeHandles->featureLevel);
638         QCOMPARE(newNativeHandles->adapterLuidLow, nativeHandles->adapterLuidLow);
639         QCOMPARE(newNativeHandles->adapterLuidHigh, nativeHandles->adapterLuidHigh);
640     }
641 
642     // Case 2: adapter and feature level only (hello OpenXR)
643     {
644         QRhiD3D11NativeHandles h = *nativeHandles;
645         h.dev = nullptr;
646         h.context = nullptr;
647         QScopedPointer<QRhi> adoptingRhi(QRhi::create(QRhi::D3D11, &initParams.d3d, QRhi::Flags(), &h));
648         QVERIFY(adoptingRhi);
649         const QRhiD3D11NativeHandles *newNativeHandles = static_cast<const QRhiD3D11NativeHandles *>(adoptingRhi->nativeHandles());
650         QVERIFY(newNativeHandles->dev != nativeHandles->dev);
651         QVERIFY(newNativeHandles->context != nativeHandles->context);
652         QCOMPARE(newNativeHandles->featureLevel, nativeHandles->featureLevel);
653         QCOMPARE(newNativeHandles->adapterLuidLow, nativeHandles->adapterLuidLow);
654         QCOMPARE(newNativeHandles->adapterLuidHigh, nativeHandles->adapterLuidHigh);
655     }
656 
657 #else
658     QSKIP("Skipping D3D11-specific test");
659 #endif
660 }
661 
662 void tst_QRhi::nativeHandlesImportOpenGL()
663 {
664 #ifdef TST_GL
665     QRhiGles2NativeHandles h;
666     QScopedPointer<QOpenGLContext> ctx(new QOpenGLContext);
667     ctx->setFormat(QRhiGles2InitParams::adjustedFormat());
668     if (!ctx->create())
669         QSKIP("No OpenGL context, skipping OpenGL-specific test");
670     h.context = ctx.data();
671     QScopedPointer<QRhi> rhi(QRhi::create(QRhi::OpenGLES2, &initParams.gl, QRhi::Flags(), &h));
672     if (!rhi)
673         QSKIP("QRhi could not be created, skipping testing OpenGL native handle import");
674 
675     const QRhiGles2NativeHandles *actualNativeHandles = static_cast<const QRhiGles2NativeHandles *>(rhi->nativeHandles());
676     QCOMPARE(actualNativeHandles->context, ctx.data());
677 
678     rhi->makeThreadLocalNativeContextCurrent();
679     QCOMPARE(QOpenGLContext::currentContext(), ctx.data());
680 #else
681     QSKIP("Skipping OpenGL-specific test");
682 #endif
683 }
684 
685 void tst_QRhi::nativeTexture_data()
686 {
687     rhiTestData();
688 }
689 
690 void tst_QRhi::nativeTexture()
691 {
692     QFETCH(QRhi::Implementation, impl);
693     QFETCH(QRhiInitParams *, initParams);
694 
695     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
696     if (!rhi)
697         QSKIP("QRhi could not be created, skipping testing native texture");
698 
699     QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 256)));
700     QVERIFY(tex->create());
701 
702     const QRhiTexture::NativeTexture nativeTex = tex->nativeTexture();
703 
704     switch (impl) {
705     case QRhi::Null:
706         break;
707 #ifdef TST_VK
708     case QRhi::Vulkan:
709     {
710         auto image = VkImage(nativeTex.object);
711         QVERIFY(image);
712         QVERIFY(nativeTex.layout >= 1); // VK_IMAGE_LAYOUT_GENERAL
713         QVERIFY(nativeTex.layout <= 8); // VK_IMAGE_LAYOUT_PREINITIALIZED
714     }
715         break;
716 #endif
717 #ifdef TST_GL
718     case QRhi::OpenGLES2:
719     {
720         auto textureId = uint(nativeTex.object);
721         QVERIFY(textureId);
722     }
723         break;
724 #endif
725 #ifdef TST_D3D11
726     case QRhi::D3D11:
727     {
728         auto *texture = reinterpret_cast<void *>(nativeTex.object);
729         QVERIFY(texture);
730     }
731         break;
732 #endif
733 #ifdef TST_MTL
734     case QRhi::Metal:
735     {
736         auto texture = (void *)nativeTex.object;
737         QVERIFY(texture);
738     }
739         break;
740 #endif
741     default:
742         Q_ASSERT(false);
743     }
744 }
745 
746 void tst_QRhi::nativeBuffer_data()
747 {
748     rhiTestData();
749 }
750 
751 void tst_QRhi::nativeBuffer()
752 {
753     QFETCH(QRhi::Implementation, impl);
754     QFETCH(QRhiInitParams *, initParams);
755 
756     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
757     if (!rhi)
758         QSKIP("QRhi could not be created, skipping testing native buffer query");
759 
760     const QRhiBuffer::Type types[3] = { QRhiBuffer::Immutable, QRhiBuffer::Static, QRhiBuffer::Dynamic };
761     const QRhiBuffer::UsageFlags usages[3] = { QRhiBuffer::VertexBuffer, QRhiBuffer::IndexBuffer, QRhiBuffer::UniformBuffer };
762     for (int typeUsageIdx = 0; typeUsageIdx < 3; ++typeUsageIdx) {
763         QScopedPointer<QRhiBuffer> buf(rhi->newBuffer(types[typeUsageIdx], usages[typeUsageIdx], 256));
764         QVERIFY(buf->create());
765 
766         const QRhiBuffer::NativeBuffer nativeBuf = buf->nativeBuffer();
767         QVERIFY(nativeBuf.slotCount <= rhi->resourceLimit(QRhi::FramesInFlight));
768 
769         switch (impl) {
770         case QRhi::Null:
771             break;
772     #ifdef TST_VK
773         case QRhi::Vulkan:
774         {
775             QVERIFY(nativeBuf.slotCount >= 1); // always backed by native buffers
776             for (int i = 0; i < nativeBuf.slotCount; ++i) {
777                 auto *buffer = static_cast<const VkBuffer *>(nativeBuf.objects[i]);
778                 QVERIFY(buffer);
779                 QVERIFY(*buffer);
780             }
781         }
782             break;
783     #endif
784     #ifdef TST_GL
785         case QRhi::OpenGLES2:
786         {
787             QVERIFY(nativeBuf.slotCount >= 0); // UniformBuffers are not backed by native buffers, so 0 is perfectly valid
788             for (int i = 0; i < nativeBuf.slotCount; ++i) {
789                 auto *bufferId = static_cast<const uint *>(nativeBuf.objects[i]);
790                 QVERIFY(bufferId);
791                 QVERIFY(*bufferId);
792             }
793         }
794             break;
795     #endif
796     #ifdef TST_D3D11
797         case QRhi::D3D11:
798         {
799             QVERIFY(nativeBuf.slotCount >= 1); // always backed by native buffers
800             for (int i = 0; i < nativeBuf.slotCount; ++i) {
801                 auto *buffer = static_cast<void * const *>(nativeBuf.objects[i]);
802                 QVERIFY(buffer);
803                 QVERIFY(*buffer);
804             }
805         }
806             break;
807     #endif
808     #ifdef TST_MTL
809         case QRhi::Metal:
810         {
811             QVERIFY(nativeBuf.slotCount >= 1); // always backed by native buffers
812             for (int i = 0; i < nativeBuf.slotCount; ++i) {
813                 void * const * buffer = (void * const *) nativeBuf.objects[i];
814                 QVERIFY(buffer);
815                 QVERIFY(*buffer);
816             }
817         }
818             break;
819     #endif
820         default:
821             Q_ASSERT(false);
822         }
823     }
824 }
825 
826 static bool submitResourceUpdates(QRhi *rhi, QRhiResourceUpdateBatch *batch)
827 {
828     QRhiCommandBuffer *cb = nullptr;
829     QRhi::FrameOpResult result = rhi->beginOffscreenFrame(&cb);
830     if (result != QRhi::FrameOpSuccess) {
831         qWarning("beginOffscreenFrame returned %d", result);
832         return false;
833     }
834     if (!cb) {
835         qWarning("No command buffer from beginOffscreenFrame");
836         return false;
837     }
838     cb->resourceUpdate(batch);
839     rhi->endOffscreenFrame();
840     return true;
841 }
842 
843 void tst_QRhi::resourceUpdateBatchBuffer_data()
844 {
845     rhiTestData();
846 }
847 
848 void tst_QRhi::resourceUpdateBatchBuffer()
849 {
850     QFETCH(QRhi::Implementation, impl);
851     QFETCH(QRhiInitParams *, initParams);
852 
853     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
854     if (!rhi)
855         QSKIP("QRhi could not be created, skipping testing buffer resource updates");
856 
857     const int bufferSize = 23;
858     const QByteArray a(bufferSize, 'A');
859     const QByteArray b(bufferSize, 'B');
860 
861     // dynamic buffer, updates, readback
862     {
863         QScopedPointer<QRhiBuffer> dynamicBuffer(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, bufferSize));
864         QVERIFY(dynamicBuffer->create());
865 
866         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
867         QVERIFY(batch);
868 
869         batch->updateDynamicBuffer(dynamicBuffer.data(), 10, bufferSize - 10, a.constData());
870         batch->updateDynamicBuffer(dynamicBuffer.data(), 0, 12, b.constData());
871 
872         QRhiBufferReadbackResult readResult;
873         bool readCompleted = false;
874         readResult.completed = [&readCompleted] { readCompleted = true; };
875         batch->readBackBuffer(dynamicBuffer.data(), 5, 10, &readResult);
876 
877         QVERIFY(submitResourceUpdates(rhi.data(), batch));
878 
879         // Offscreen frames are synchronous, so the readback must have
880         // completed at this point. With swapchain frames this would not be the
881         // case.
882         QVERIFY(readCompleted);
883         QVERIFY(readResult.data.size() == 10);
884         QCOMPARE(readResult.data.left(7), QByteArrayLiteral("BBBBBBB"));
885         QCOMPARE(readResult.data.mid(7), QByteArrayLiteral("AAA"));
886     }
887 
888     // static buffer, updates, readback
889     {
890         QScopedPointer<QRhiBuffer> dynamicBuffer(rhi->newBuffer(QRhiBuffer::Static, QRhiBuffer::VertexBuffer, bufferSize));
891         QVERIFY(dynamicBuffer->create());
892 
893         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
894         QVERIFY(batch);
895 
896         batch->uploadStaticBuffer(dynamicBuffer.data(), 10, bufferSize - 10, a.constData());
897         batch->uploadStaticBuffer(dynamicBuffer.data(), 0, 12, b.constData());
898 
899         QRhiBufferReadbackResult readResult;
900         bool readCompleted = false;
901         readResult.completed = [&readCompleted] { readCompleted = true; };
902 
903         if (rhi->isFeatureSupported(QRhi::ReadBackNonUniformBuffer))
904             batch->readBackBuffer(dynamicBuffer.data(), 5, 10, &readResult);
905 
906         QVERIFY(submitResourceUpdates(rhi.data(), batch));
907 
908         if (rhi->isFeatureSupported(QRhi::ReadBackNonUniformBuffer)) {
909             QVERIFY(readCompleted);
910             QVERIFY(readResult.data.size() == 10);
911             QCOMPARE(readResult.data.left(7), QByteArrayLiteral("BBBBBBB"));
912             QCOMPARE(readResult.data.mid(7), QByteArrayLiteral("AAA"));
913         } else {
914             qDebug("Skipping verifying buffer contents because readback is not supported");
915         }
916     }
917 }
918 
919 inline bool imageRGBAEquals(const QImage &a, const QImage &b, int maxFuzz = 1)
920 {
921     if (a.size() != b.size())
922         return false;
923 
924     const QImage image0 = a.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
925     const QImage image1 = b.convertToFormat(QImage::Format_RGBA8888_Premultiplied);
926 
927     const int width = image0.width();
928     const int height = image0.height();
929     for (int y = 0; y < height; ++y) {
930         const quint32 *p0 = reinterpret_cast<const quint32 *>(image0.constScanLine(y));
931         const quint32 *p1 = reinterpret_cast<const quint32 *>(image1.constScanLine(y));
932         int x = width - 1;
933         while (x-- >= 0) {
934             const QRgb c0(*p0++);
935             const QRgb c1(*p1++);
936             const int red = qAbs(qRed(c0) - qRed(c1));
937             const int green = qAbs(qGreen(c0) - qGreen(c1));
938             const int blue = qAbs(qBlue(c0) - qBlue(c1));
939             const int alpha = qAbs(qAlpha(c0) - qAlpha(c1));
940             if (red > maxFuzz || green > maxFuzz || blue > maxFuzz || alpha > maxFuzz)
941                 return false;
942         }
943     }
944 
945     return true;
946 }
947 
948 void tst_QRhi::resourceUpdateBatchRGBATextureUpload_data()
949 {
950     rhiTestData();
951 }
952 
953 void tst_QRhi::resourceUpdateBatchRGBATextureUpload()
954 {
955     QFETCH(QRhi::Implementation, impl);
956     QFETCH(QRhiInitParams *, initParams);
957 
958     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
959     if (!rhi)
960         QSKIP("QRhi could not be created, skipping testing texture resource updates");
961 
962     QImage image(234, 123, QImage::Format_RGBA8888_Premultiplied);
963     image.fill(Qt::red);
964     QPainter painter;
965     const QPoint greenRectPos(35, 50);
966     const QSize greenRectSize(100, 50);
967     painter.begin(&image);
968     painter.fillRect(QRect(greenRectPos, greenRectSize), Qt::green);
969     painter.end();
970 
971     // simple image upload; uploading and reading back RGBA8 is supported by the Null backend even
972     {
973         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, image.size(),
974                                                             1, QRhiTexture::UsedAsTransferSource));
975         QVERIFY(texture->create());
976 
977         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
978         batch->uploadTexture(texture.data(), image);
979 
980         QRhiReadbackResult readResult;
981         bool readCompleted = false;
982         readResult.completed = [&readCompleted] { readCompleted = true; };
983         batch->readBackTexture(texture.data(), &readResult);
984 
985         QVERIFY(submitResourceUpdates(rhi.data(), batch));
986         // like with buffers, the readback is now complete due to endOffscreenFrame()
987         QVERIFY(readCompleted);
988         QCOMPARE(readResult.format, QRhiTexture::RGBA8);
989         QCOMPARE(readResult.pixelSize, image.size());
990 
991         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
992                             readResult.pixelSize.width(), readResult.pixelSize.height(),
993                             image.format());
994 
995         QVERIFY(imageRGBAEquals(image, wrapperImage));
996     }
997 
998     // the same with raw data
999     {
1000         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, image.size(),
1001                                                             1, QRhiTexture::UsedAsTransferSource));
1002         QVERIFY(texture->create());
1003 
1004         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
1005 
1006         QRhiTextureUploadEntry upload(0, 0, { image.constBits(), int(image.sizeInBytes()) });
1007         QRhiTextureUploadDescription uploadDesc(upload);
1008         batch->uploadTexture(texture.data(), uploadDesc);
1009 
1010         QRhiReadbackResult readResult;
1011         bool readCompleted = false;
1012         readResult.completed = [&readCompleted] { readCompleted = true; };
1013         batch->readBackTexture(texture.data(), &readResult);
1014 
1015         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1016         QVERIFY(readCompleted);
1017         QCOMPARE(readResult.format, QRhiTexture::RGBA8);
1018         QCOMPARE(readResult.pixelSize, image.size());
1019 
1020         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1021                             readResult.pixelSize.width(), readResult.pixelSize.height(),
1022                             image.format());
1023 
1024         QVERIFY(imageRGBAEquals(image, wrapperImage));
1025     }
1026 
1027     // partial image upload at a non-zero destination position
1028     {
1029         const QSize copySize(30, 40);
1030         const int gap = 10;
1031         const QSize fullSize(copySize.width() + gap, copySize.height() + gap);
1032         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, fullSize,
1033                                                             1, QRhiTexture::UsedAsTransferSource));
1034         QVERIFY(texture->create());
1035 
1036         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
1037 
1038         QImage clearImage(fullSize, image.format());
1039         clearImage.fill(Qt::black);
1040         batch->uploadTexture(texture.data(), clearImage);
1041 
1042         // copy green pixels of copySize to (gap, gap), leaving a black bar of
1043         // gap pixels on the left and top
1044         QRhiTextureSubresourceUploadDescription desc;
1045         desc.setImage(image);
1046         desc.setSourceSize(copySize);
1047         desc.setDestinationTopLeft(QPoint(gap, gap));
1048         desc.setSourceTopLeft(greenRectPos);
1049 
1050         batch->uploadTexture(texture.data(), QRhiTextureUploadDescription({ 0, 0, desc }));
1051 
1052         QRhiReadbackResult readResult;
1053         bool readCompleted = false;
1054         readResult.completed = [&readCompleted] { readCompleted = true; };
1055         batch->readBackTexture(texture.data(), &readResult);
1056 
1057         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1058         QVERIFY(readCompleted);
1059         QCOMPARE(readResult.format, QRhiTexture::RGBA8);
1060         QCOMPARE(readResult.pixelSize, clearImage.size());
1061 
1062         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1063                             readResult.pixelSize.width(), readResult.pixelSize.height(),
1064                             image.format());
1065 
1066         QVERIFY(!imageRGBAEquals(clearImage, wrapperImage));
1067 
1068         QImage expectedImage = clearImage;
1069         QPainter painter(&expectedImage);
1070         painter.fillRect(QRect(QPoint(gap, gap), QSize(copySize)), Qt::green);
1071         painter.end();
1072 
1073         QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
1074     }
1075 
1076     // the same (partial upload) with raw data as source
1077     {
1078         const QSize copySize(30, 40);
1079         const int gap = 10;
1080         const QSize fullSize(copySize.width() + gap, copySize.height() + gap);
1081         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, fullSize,
1082                                                             1, QRhiTexture::UsedAsTransferSource));
1083         QVERIFY(texture->create());
1084 
1085         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
1086 
1087         QImage clearImage(fullSize, image.format());
1088         clearImage.fill(Qt::black);
1089         batch->uploadTexture(texture.data(), clearImage);
1090 
1091         // SourceTopLeft is not supported for non-QImage-based uploads.
1092         const QImage im = image.copy(QRect(greenRectPos, copySize));
1093         QRhiTextureSubresourceUploadDescription desc;
1094         desc.setData(QByteArray::fromRawData(reinterpret_cast<const char *>(im.constBits()),
1095                                              int(im.sizeInBytes())));
1096         desc.setSourceSize(copySize);
1097         desc.setDestinationTopLeft(QPoint(gap, gap));
1098 
1099         batch->uploadTexture(texture.data(), QRhiTextureUploadDescription({ 0, 0, desc }));
1100 
1101         QRhiReadbackResult readResult;
1102         bool readCompleted = false;
1103         readResult.completed = [&readCompleted] { readCompleted = true; };
1104         batch->readBackTexture(texture.data(), &readResult);
1105 
1106         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1107         QVERIFY(readCompleted);
1108         QCOMPARE(readResult.format, QRhiTexture::RGBA8);
1109         QCOMPARE(readResult.pixelSize, clearImage.size());
1110 
1111         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1112                             readResult.pixelSize.width(), readResult.pixelSize.height(),
1113                             image.format());
1114 
1115         QVERIFY(!imageRGBAEquals(clearImage, wrapperImage));
1116 
1117         QImage expectedImage = clearImage;
1118         QPainter painter(&expectedImage);
1119         painter.fillRect(QRect(QPoint(gap, gap), QSize(copySize)), Qt::green);
1120         painter.end();
1121 
1122         QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
1123     }
1124 
1125     // now a QImage from an actual file
1126     {
1127         QImage inputImage;
1128         inputImage.load(QLatin1String(":/data/qt256.png"));
1129         QVERIFY(!inputImage.isNull());
1130         inputImage = std::move(inputImage).convertToFormat(image.format());
1131 
1132         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(),
1133                                                             1, QRhiTexture::UsedAsTransferSource));
1134         QVERIFY(texture->create());
1135 
1136         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
1137         batch->uploadTexture(texture.data(), inputImage);
1138 
1139         QRhiReadbackResult readResult;
1140         bool readCompleted = false;
1141         readResult.completed = [&readCompleted] { readCompleted = true; };
1142         batch->readBackTexture(texture.data(), &readResult);
1143 
1144         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1145         QVERIFY(readCompleted);
1146         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1147                             readResult.pixelSize.width(), readResult.pixelSize.height(),
1148                             inputImage.format());
1149 
1150         QVERIFY(imageRGBAEquals(inputImage, wrapperImage));
1151     }
1152 }
1153 
1154 void tst_QRhi::resourceUpdateBatchRGBATextureCopy_data()
1155 {
1156     rhiTestData();
1157 }
1158 
1159 void tst_QRhi::resourceUpdateBatchRGBATextureCopy()
1160 {
1161     QFETCH(QRhi::Implementation, impl);
1162     QFETCH(QRhiInitParams *, initParams);
1163 
1164     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1165     if (!rhi)
1166         QSKIP("QRhi could not be created, skipping testing texture resource updates");
1167 
1168     QImage red(256, 256, QImage::Format_RGBA8888_Premultiplied);
1169     red.fill(Qt::red);
1170 
1171     QImage green(35, 73, red.format());
1172     green.fill(Qt::green);
1173 
1174     QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
1175 
1176     QScopedPointer<QRhiTexture> redTexture(rhi->newTexture(QRhiTexture::RGBA8, red.size(),
1177                                                            1, QRhiTexture::UsedAsTransferSource));
1178     QVERIFY(redTexture->create());
1179     batch->uploadTexture(redTexture.data(), red);
1180 
1181     QScopedPointer<QRhiTexture> greenTexture(rhi->newTexture(QRhiTexture::RGBA8, green.size(),
1182                                                              1, QRhiTexture::UsedAsTransferSource));
1183     QVERIFY(greenTexture->create());
1184     batch->uploadTexture(greenTexture.data(), green);
1185 
1186     // 1. simple copy red -> texture; 2. subimage copy green -> texture; 3. partial subimage copy green -> texture
1187     {
1188         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, red.size(),
1189                                                             1, QRhiTexture::UsedAsTransferSource));
1190         QVERIFY(texture->create());
1191 
1192         // 1.
1193         batch->copyTexture(texture.data(), redTexture.data());
1194 
1195         QRhiReadbackResult readResult;
1196         bool readCompleted = false;
1197         readResult.completed = [&readCompleted] { readCompleted = true; };
1198         batch->readBackTexture(texture.data(), &readResult);
1199         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1200         QVERIFY(readCompleted);
1201         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1202                             readResult.pixelSize.width(), readResult.pixelSize.height(),
1203                             red.format());
1204         QVERIFY(imageRGBAEquals(red, wrapperImage));
1205 
1206         batch = rhi->nextResourceUpdateBatch();
1207         readCompleted = false;
1208 
1209         // 2.
1210         QRhiTextureCopyDescription copyDesc;
1211         copyDesc.setDestinationTopLeft(QPoint(15, 23));
1212         batch->copyTexture(texture.data(), greenTexture.data(), copyDesc);
1213 
1214         batch->readBackTexture(texture.data(), &readResult);
1215         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1216         QVERIFY(readCompleted);
1217         wrapperImage = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1218                               readResult.pixelSize.width(), readResult.pixelSize.height(),
1219                               red.format());
1220 
1221         QImage expectedImage = red;
1222         QPainter painter(&expectedImage);
1223         painter.drawImage(copyDesc.destinationTopLeft(), green);
1224         painter.end();
1225 
1226         QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
1227 
1228         batch = rhi->nextResourceUpdateBatch();
1229         readCompleted = false;
1230 
1231         // 3.
1232         copyDesc.setDestinationTopLeft(QPoint(125, 89));
1233         copyDesc.setSourceTopLeft(QPoint(5, 5));
1234         copyDesc.setPixelSize(QSize(26, 45));
1235         batch->copyTexture(texture.data(), greenTexture.data(), copyDesc);
1236 
1237         batch->readBackTexture(texture.data(), &readResult);
1238         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1239         QVERIFY(readCompleted);
1240         wrapperImage = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1241                               readResult.pixelSize.width(), readResult.pixelSize.height(),
1242                               red.format());
1243 
1244         painter.begin(&expectedImage);
1245         painter.drawImage(copyDesc.destinationTopLeft(), green,
1246                           QRect(copyDesc.sourceTopLeft(), copyDesc.pixelSize()));
1247         painter.end();
1248 
1249         QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
1250     }
1251 }
1252 
1253 void tst_QRhi::resourceUpdateBatchRGBATextureMip_data()
1254 {
1255     rhiTestData();
1256 }
1257 
1258 void tst_QRhi::resourceUpdateBatchRGBATextureMip()
1259 {
1260     QFETCH(QRhi::Implementation, impl);
1261     QFETCH(QRhiInitParams *, initParams);
1262 
1263     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1264     if (!rhi)
1265         QSKIP("QRhi could not be created, skipping testing texture resource updates");
1266 
1267 
1268     QImage red(512, 512, QImage::Format_RGBA8888_Premultiplied);
1269     red.fill(Qt::red);
1270 
1271     const QRhiTexture::Flags textureFlags =
1272             QRhiTexture::UsedAsTransferSource
1273             | QRhiTexture::MipMapped
1274             | QRhiTexture::UsedWithGenerateMips;
1275     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, red.size(), 1, textureFlags));
1276     QVERIFY(texture->create());
1277 
1278     QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
1279     batch->uploadTexture(texture.data(), red);
1280     batch->generateMips(texture.data());
1281     QVERIFY(submitResourceUpdates(rhi.data(), batch));
1282 
1283     const int levelCount = rhi->mipLevelsForSize(red.size());
1284     QCOMPARE(levelCount, 10);
1285     for (int level = 0; level < levelCount; ++level) {
1286         batch = rhi->nextResourceUpdateBatch();
1287 
1288         QRhiReadbackDescription readDesc(texture.data());
1289         readDesc.setLevel(level);
1290         QRhiReadbackResult readResult;
1291         bool readCompleted = false;
1292         readResult.completed = [&readCompleted] { readCompleted = true; };
1293         batch->readBackTexture(readDesc, &readResult);
1294 
1295         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1296         QVERIFY(readCompleted);
1297 
1298         const QSize expectedSize = rhi->sizeForMipLevel(level, texture->pixelSize());
1299         QCOMPARE(readResult.pixelSize, expectedSize);
1300 
1301         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1302                             readResult.pixelSize.width(), readResult.pixelSize.height(),
1303                             red.format());
1304         QImage expectedImage;
1305         if (level == 0 || rhi->isFeatureSupported(QRhi::ReadBackNonBaseMipLevel)) {
1306             // Compare to a scaled version; we can do this safely only because we
1307             // only have plain red pixels in the source image.
1308             expectedImage = red.scaled(expectedSize);
1309         } else {
1310             qDebug("Expecting all-zero image for level %d because reading back a level other than 0 is not supported", level);
1311             expectedImage = QImage(readResult.pixelSize, red.format());
1312             expectedImage.fill(0);
1313         }
1314         QVERIFY(imageRGBAEquals(expectedImage, wrapperImage));
1315     }
1316 }
1317 
1318 void tst_QRhi::resourceUpdateBatchTextureRawDataStride_data()
1319 {
1320     rhiTestData();
1321 }
1322 
1323 void tst_QRhi::resourceUpdateBatchTextureRawDataStride()
1324 {
1325     QFETCH(QRhi::Implementation, impl);
1326     QFETCH(QRhiInitParams *, initParams);
1327 
1328     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1329     if (!rhi)
1330         QSKIP("QRhi could not be created, skipping testing texture resource updates");
1331 
1332     const int WIDTH = 150;
1333     const int DATA_WIDTH = 180;
1334     const int HEIGHT = 50;
1335     QByteArray image;
1336     image.resize(DATA_WIDTH * HEIGHT * 4);
1337     for (int y = 0; y < HEIGHT; ++y) {
1338         char *p = image.data() + y * DATA_WIDTH * 4;
1339         memset(p, y, DATA_WIDTH * 4);
1340     }
1341 
1342     {
1343         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(WIDTH, HEIGHT),
1344                                                             1, QRhiTexture::UsedAsTransferSource));
1345         QVERIFY(texture->create());
1346 
1347         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
1348 
1349         QRhiTextureSubresourceUploadDescription subresDesc(image.constData(), image.size());
1350         subresDesc.setDataStride(DATA_WIDTH * 4);
1351         QRhiTextureUploadEntry upload(0, 0, subresDesc);
1352         QRhiTextureUploadDescription uploadDesc(upload);
1353         batch->uploadTexture(texture.data(), uploadDesc);
1354 
1355         QRhiReadbackResult readResult;
1356         bool readCompleted = false;
1357         readResult.completed = [&readCompleted] { readCompleted = true; };
1358         batch->readBackTexture(texture.data(), &readResult);
1359 
1360         QVERIFY(submitResourceUpdates(rhi.data(), batch));
1361         QVERIFY(readCompleted);
1362         QCOMPARE(readResult.format, QRhiTexture::RGBA8);
1363         QCOMPARE(readResult.pixelSize, QSize(WIDTH, HEIGHT));
1364 
1365         QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1366                             readResult.pixelSize.width(), readResult.pixelSize.height(),
1367                             QImage::Format_RGBA8888_Premultiplied);
1368         // wrap the original data, note the bytesPerLine argument
1369         QImage originalWrapperImage(reinterpret_cast<const uchar *>(image.constData()),
1370                                     WIDTH, HEIGHT, DATA_WIDTH * 4,
1371                                     QImage::Format_RGBA8888_Premultiplied);
1372         QVERIFY(imageRGBAEquals(wrapperImage, originalWrapperImage));
1373     }
1374 }
1375 
1376 void tst_QRhi::resourceUpdateBatchLotsOfResources_data()
1377 {
1378     rhiTestData();
1379 }
1380 
1381 void tst_QRhi::resourceUpdateBatchLotsOfResources()
1382 {
1383     QFETCH(QRhi::Implementation, impl);
1384     QFETCH(QRhiInitParams *, initParams);
1385 
1386     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1387     if (!rhi)
1388         QSKIP("QRhi could not be created, skipping testing resource updates");
1389 
1390     QImage image(128, 128, QImage::Format_RGBA8888_Premultiplied);
1391     image.fill(Qt::red);
1392     static const float bufferData[64] = {};
1393 
1394     QRhiResourceUpdateBatch *b = rhi->nextResourceUpdateBatch();
1395     QVector<QRhiTexture *> textures;
1396     QVector<QRhiBuffer *> buffers;
1397 
1398     // QTBUG-96619
1399     static const int TEXTURE_COUNT = 800;
1400     static const int BUFFER_COUNT = 1200;
1401 
1402     for (int i = 0; i < TEXTURE_COUNT; ++i) {
1403         textures << rhi->newTexture(QRhiTexture::RGBA8, image.size());
1404         QVERIFY(textures.last()->create());
1405         b->uploadTexture(textures.last(), image);
1406     }
1407 
1408     for (int i = 0; i < BUFFER_COUNT; ++i) {
1409         buffers << rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, 256);
1410         QVERIFY(buffers.last()->create());
1411         b->uploadStaticBuffer(buffers.last(), bufferData);
1412     }
1413 
1414     submitResourceUpdates(rhi.data(), b);
1415 
1416     qDeleteAll(textures);
1417     qDeleteAll(buffers);
1418 }
1419 
1420 static QShader loadShader(const char *name)
1421 {
1422     QFile f(QString::fromUtf8(name));
1423     if (f.open(QIODevice::ReadOnly)) {
1424         const QByteArray contents = f.readAll();
1425         return QShader::fromSerialized(contents);
1426     }
1427     return QShader();
1428 }
1429 
1430 void tst_QRhi::invalidPipeline_data()
1431 {
1432     rhiTestData();
1433 }
1434 
1435 void tst_QRhi::invalidPipeline()
1436 {
1437     QFETCH(QRhi::Implementation, impl);
1438     QFETCH(QRhiInitParams *, initParams);
1439 
1440     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1441     if (!rhi)
1442         QSKIP("QRhi could not be created, skipping testing empty shader");
1443 
1444     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(256, 256), 1, QRhiTexture::RenderTarget));
1445     QVERIFY(texture->create());
1446     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
1447     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
1448     rt->setRenderPassDescriptor(rpDesc.data());
1449     QVERIFY(rt->create());
1450 
1451     QRhiCommandBuffer *cb = nullptr;
1452     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
1453     QVERIFY(cb);
1454 
1455     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
1456     QVERIFY(srb->create());
1457 
1458     QRhiVertexInputLayout inputLayout;
1459     inputLayout.setBindings({ { 2 * sizeof(float) } });
1460     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
1461 
1462     // no stages
1463     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
1464     pipeline->setVertexInputLayout(inputLayout);
1465     pipeline->setShaderResourceBindings(srb.data());
1466     pipeline->setRenderPassDescriptor(rpDesc.data());
1467     QVERIFY(!pipeline->create());
1468 
1469     QShader vs;
1470     QShader fs;
1471 
1472     // no shaders in the stages
1473     pipeline.reset(rhi->newGraphicsPipeline());
1474     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1475     pipeline->setVertexInputLayout(inputLayout);
1476     pipeline->setShaderResourceBindings(srb.data());
1477     pipeline->setRenderPassDescriptor(rpDesc.data());
1478     QVERIFY(!pipeline->create());
1479 
1480     vs = loadShader(":/data/simple.vert.qsb");
1481     QVERIFY(vs.isValid());
1482     fs = loadShader(":/data/simple.frag.qsb");
1483     QVERIFY(fs.isValid());
1484 
1485     // no vertex stage
1486     pipeline.reset(rhi->newGraphicsPipeline());
1487     pipeline->setShaderStages({ { QRhiShaderStage::Fragment, fs } });
1488     pipeline->setVertexInputLayout(inputLayout);
1489     pipeline->setShaderResourceBindings(srb.data());
1490     pipeline->setRenderPassDescriptor(rpDesc.data());
1491     QVERIFY(!pipeline->create());
1492 
1493     // no renderpass descriptor
1494     pipeline.reset(rhi->newGraphicsPipeline());
1495     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1496     pipeline->setVertexInputLayout(inputLayout);
1497     pipeline->setShaderResourceBindings(srb.data());
1498     QVERIFY(!pipeline->create());
1499 
1500     // no shader resource bindings
1501     pipeline.reset(rhi->newGraphicsPipeline());
1502     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1503     pipeline->setVertexInputLayout(inputLayout);
1504     pipeline->setRenderPassDescriptor(rpDesc.data());
1505     QVERIFY(!pipeline->create());
1506 
1507     // correct
1508     pipeline.reset(rhi->newGraphicsPipeline());
1509     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1510     pipeline->setVertexInputLayout(inputLayout);
1511     pipeline->setRenderPassDescriptor(rpDesc.data());
1512     pipeline->setShaderResourceBindings(srb.data());
1513     QVERIFY(pipeline->create());
1514 }
1515 
1516 void tst_QRhi::renderToTextureSimple_data()
1517 {
1518     rhiTestData();
1519 }
1520 
1521 void tst_QRhi::renderToTextureSimple()
1522 {
1523     QFETCH(QRhi::Implementation, impl);
1524     QFETCH(QRhiInitParams *, initParams);
1525 
1526     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1527     if (!rhi)
1528         QSKIP("QRhi could not be created, skipping testing rendering");
1529 
1530     const QSize outputSize(1920, 1080);
1531     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, outputSize, 1,
1532                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
1533     QVERIFY(texture->create());
1534 
1535     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
1536     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
1537     rt->setRenderPassDescriptor(rpDesc.data());
1538     QVERIFY(rt->create());
1539 
1540     QRhiCommandBuffer *cb = nullptr;
1541     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
1542     QVERIFY(cb);
1543 
1544     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
1545 
1546     static const float vertices[] = {
1547         -1.0f, -1.0f,
1548         1.0f, -1.0f,
1549         0.0f, 1.0f
1550     };
1551     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
1552     QVERIFY(vbuf->create());
1553     updates->uploadStaticBuffer(vbuf.data(), vertices);
1554 
1555     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
1556     QVERIFY(srb->create());
1557 
1558     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
1559     QShader vs = loadShader(":/data/simple.vert.qsb");
1560     QVERIFY(vs.isValid());
1561     QShader fs = loadShader(":/data/simple.frag.qsb");
1562     QVERIFY(fs.isValid());
1563     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1564     QRhiVertexInputLayout inputLayout;
1565     inputLayout.setBindings({ { 2 * sizeof(float) } });
1566     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
1567     pipeline->setVertexInputLayout(inputLayout);
1568     pipeline->setShaderResourceBindings(srb.data());
1569     pipeline->setRenderPassDescriptor(rpDesc.data());
1570 
1571     QVERIFY(pipeline->create());
1572 
1573     cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, updates);
1574     cb->setGraphicsPipeline(pipeline.data());
1575     cb->setViewport({ 0, 0, float(outputSize.width()), float(outputSize.height()) });
1576     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
1577     cb->setVertexInput(0, 1, &vbindings);
1578     cb->draw(3);
1579 
1580     QRhiReadbackResult readResult;
1581     QImage result;
1582     readResult.completed = [&readResult, &result] {
1583         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1584                         readResult.pixelSize.width(), readResult.pixelSize.height(),
1585                         QImage::Format_RGBA8888_Premultiplied); // non-owning, no copy needed because readResult outlives result
1586     };
1587     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
1588     readbackBatch->readBackTexture({ texture.data() }, &readResult);
1589     cb->endPass(readbackBatch);
1590 
1591     rhi->endOffscreenFrame();
1592     // Offscreen frames are synchronous, so the readback is guaranteed to
1593     // complete at this point. This would not be the case with swapchain-based
1594     // frames.
1595     QCOMPARE(result.size(), texture->pixelSize());
1596 
1597     if (impl == QRhi::Null)
1598         return;
1599 
1600     // Now we have a red rectangle on blue background.
1601     const int y = 100;
1602     const quint32 *p = reinterpret_cast<const quint32 *>(result.constScanLine(y));
1603     int x = result.width() - 1;
1604     int redCount = 0;
1605     int blueCount = 0;
1606     const int maxFuzz = 1;
1607     while (x-- >= 0) {
1608         const QRgb c(*p++);
1609         if (qRed(c) >= (255 - maxFuzz) && qGreen(c) == 0 && qBlue(c) == 0)
1610             ++redCount;
1611         else if (qRed(c) == 0 && qGreen(c) == 0 && qBlue(c) >= (255 - maxFuzz))
1612             ++blueCount;
1613         else
1614             QFAIL("Encountered a pixel that is neither red or blue");
1615     }
1616 
1617     QCOMPARE(redCount + blueCount, texture->pixelSize().width());
1618 
1619     // The triangle is "pointing up" in the resulting image with OpenGL
1620     // (because Y is up both in normalized device coordinates and in images)
1621     // and Vulkan (because Y is down in both and the vertex data was specified
1622     // with Y up in mind), but "pointing down" with D3D (because Y is up in NDC
1623     // but down in images).
1624     if (rhi->isYUpInFramebuffer() == rhi->isYUpInNDC())
1625         QVERIFY(redCount < blueCount);
1626     else
1627         QVERIFY(redCount > blueCount);
1628 }
1629 
1630 void tst_QRhi::renderToTextureMip_data()
1631 {
1632     rhiTestData();
1633 }
1634 
1635 void tst_QRhi::renderToTextureMip()
1636 {
1637     QFETCH(QRhi::Implementation, impl);
1638     QFETCH(QRhiInitParams *, initParams);
1639 
1640     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1641     if (!rhi)
1642         QSKIP("QRhi could not be created, skipping testing rendering");
1643 
1644     if (!rhi->isFeatureSupported(QRhi::RenderToNonBaseMipLevel))
1645         QSKIP("Rendering to non-base mip levels is not supported on this platform, skipping test");
1646 
1647     const QSize baseLevelSize(1024, 1024);
1648     const int LEVEL = 3; // render into mip #3 (128x128)
1649     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, baseLevelSize, 1,
1650                                                         QRhiTexture::RenderTarget
1651                                                         | QRhiTexture::UsedAsTransferSource
1652                                                         | QRhiTexture::MipMapped));
1653     QVERIFY(texture->create());
1654 
1655     QRhiColorAttachment colorAtt(texture.data());
1656     colorAtt.setLevel(LEVEL);
1657     QRhiTextureRenderTargetDescription rtDesc(colorAtt);
1658     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget(rtDesc));
1659     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
1660     rt->setRenderPassDescriptor(rpDesc.data());
1661     QVERIFY(rt->create());
1662 
1663     QCOMPARE(rt->pixelSize(), rhi->sizeForMipLevel(LEVEL, baseLevelSize));
1664     const QSize mipSize(baseLevelSize.width() >> LEVEL, baseLevelSize.height() >> LEVEL);
1665     QCOMPARE(rt->pixelSize(), mipSize);
1666 
1667     QRhiCommandBuffer *cb = nullptr;
1668     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
1669     QVERIFY(cb);
1670 
1671     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
1672 
1673     static const float vertices[] = {
1674         -1.0f, -1.0f,
1675         1.0f, -1.0f,
1676         0.0f, 1.0f
1677     };
1678     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
1679     QVERIFY(vbuf->create());
1680     updates->uploadStaticBuffer(vbuf.data(), vertices);
1681 
1682     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
1683     QVERIFY(srb->create());
1684 
1685     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
1686     QShader vs = loadShader(":/data/simple.vert.qsb");
1687     QVERIFY(vs.isValid());
1688     QShader fs = loadShader(":/data/simple.frag.qsb");
1689     QVERIFY(fs.isValid());
1690     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1691     QRhiVertexInputLayout inputLayout;
1692     inputLayout.setBindings({ { 2 * sizeof(float) } });
1693     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
1694     pipeline->setVertexInputLayout(inputLayout);
1695     pipeline->setShaderResourceBindings(srb.data());
1696     pipeline->setRenderPassDescriptor(rpDesc.data());
1697 
1698     QVERIFY(pipeline->create());
1699 
1700     cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, updates);
1701     cb->setGraphicsPipeline(pipeline.data());
1702     cb->setViewport({ 0, 0, float(rt->pixelSize().width()), float(rt->pixelSize().height()) });
1703     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
1704     cb->setVertexInput(0, 1, &vbindings);
1705     cb->draw(3);
1706 
1707     QRhiReadbackResult readResult;
1708     QImage result;
1709     readResult.completed = [&readResult, &result] {
1710         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1711                         readResult.pixelSize.width(), readResult.pixelSize.height(),
1712                         QImage::Format_RGBA8888_Premultiplied);
1713     };
1714     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
1715     QRhiReadbackDescription readbackDescription(texture.data());
1716     readbackDescription.setLevel(LEVEL);
1717     readbackBatch->readBackTexture(readbackDescription, &readResult);
1718     cb->endPass(readbackBatch);
1719 
1720     rhi->endOffscreenFrame();
1721 
1722     if (!rhi->isFeatureSupported(QRhi::ReadBackNonBaseMipLevel))
1723         QSKIP("Reading back non-base mip levels is not supported on this platform, skipping readback");
1724 
1725     QCOMPARE(result.size(), mipSize);
1726 
1727     if (impl == QRhi::Null)
1728         return;
1729 
1730     const int y = 100;
1731     const quint32 *p = reinterpret_cast<const quint32 *>(result.constScanLine(y));
1732     int x = result.width() - 1;
1733     int redCount = 0;
1734     int blueCount = 0;
1735     const int maxFuzz = 1;
1736     while (x-- >= 0) {
1737         const QRgb c(*p++);
1738         if (qRed(c) >= (255 - maxFuzz) && qGreen(c) == 0 && qBlue(c) == 0)
1739             ++redCount;
1740         else if (qRed(c) == 0 && qGreen(c) == 0 && qBlue(c) >= (255 - maxFuzz))
1741             ++blueCount;
1742         else
1743             QFAIL("Encountered a pixel that is neither red or blue");
1744     }
1745 
1746     QCOMPARE(redCount + blueCount, mipSize.width());
1747 
1748     if (rhi->isYUpInFramebuffer() == rhi->isYUpInNDC())
1749         QVERIFY(redCount > blueCount); // 100, 28
1750     else
1751         QVERIFY(redCount < blueCount); // 28, 100
1752 }
1753 
1754 void tst_QRhi::renderToTextureCubemapFace_data()
1755 {
1756     rhiTestData();
1757 }
1758 
1759 void tst_QRhi::renderToTextureCubemapFace()
1760 {
1761     QFETCH(QRhi::Implementation, impl);
1762     QFETCH(QRhiInitParams *, initParams);
1763 
1764     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1765     if (!rhi)
1766         QSKIP("QRhi could not be created, skipping testing rendering");
1767 
1768     const QSize outputSize(512, 512); // width must be same as height
1769     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, outputSize, 1,
1770                                                         QRhiTexture::RenderTarget
1771                                                         | QRhiTexture::UsedAsTransferSource
1772                                                         | QRhiTexture::CubeMap)); // will be a cubemap, so 6 layers
1773     QVERIFY(texture->create());
1774 
1775     const int LAYER = 1; // render into the layer for face -X
1776     const int BAD_LAYER = 2; // +Y
1777 
1778     QRhiColorAttachment colorAtt(texture.data());
1779     colorAtt.setLayer(LAYER);
1780     QRhiTextureRenderTargetDescription rtDesc(colorAtt);
1781     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget(rtDesc));
1782     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
1783     rt->setRenderPassDescriptor(rpDesc.data());
1784     QVERIFY(rt->create());
1785 
1786     QCOMPARE(rt->pixelSize(), texture->pixelSize());
1787     QCOMPARE(rt->pixelSize(), outputSize);
1788 
1789     QRhiCommandBuffer *cb = nullptr;
1790     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
1791     QVERIFY(cb);
1792 
1793     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
1794 
1795     static const float vertices[] = {
1796         -1.0f, -1.0f,
1797         1.0f, -1.0f,
1798         0.0f, 1.0f
1799     };
1800     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
1801     QVERIFY(vbuf->create());
1802     updates->uploadStaticBuffer(vbuf.data(), vertices);
1803 
1804     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
1805     QVERIFY(srb->create());
1806 
1807     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
1808     QShader vs = loadShader(":/data/simple.vert.qsb");
1809     QVERIFY(vs.isValid());
1810     QShader fs = loadShader(":/data/simple.frag.qsb");
1811     QVERIFY(fs.isValid());
1812     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1813     QRhiVertexInputLayout inputLayout;
1814     inputLayout.setBindings({ { 2 * sizeof(float) } });
1815     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
1816     pipeline->setVertexInputLayout(inputLayout);
1817     pipeline->setShaderResourceBindings(srb.data());
1818     pipeline->setRenderPassDescriptor(rpDesc.data());
1819 
1820     QVERIFY(pipeline->create());
1821 
1822     cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, updates);
1823     cb->setGraphicsPipeline(pipeline.data());
1824     cb->setViewport({ 0, 0, float(rt->pixelSize().width()), float(rt->pixelSize().height()) });
1825     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
1826     cb->setVertexInput(0, 1, &vbindings);
1827     cb->draw(3);
1828 
1829     QRhiReadbackResult readResult;
1830     QImage result;
1831     readResult.completed = [&readResult, &result] {
1832         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1833                         readResult.pixelSize.width(), readResult.pixelSize.height(),
1834                         QImage::Format_RGBA8888_Premultiplied);
1835     };
1836     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
1837     QRhiReadbackDescription readbackDescription(texture.data());
1838     readbackDescription.setLayer(LAYER);
1839     readbackBatch->readBackTexture(readbackDescription, &readResult);
1840 
1841     // also read back a layer we did not render into
1842     QRhiReadbackResult readResult2;
1843     QImage result2;
1844     readResult2.completed = [&readResult2, &result2] {
1845         result2 = QImage(reinterpret_cast<const uchar *>(readResult2.data.constData()),
1846                          readResult2.pixelSize.width(), readResult2.pixelSize.height(),
1847                          QImage::Format_RGBA8888_Premultiplied);
1848     };
1849     QRhiReadbackDescription readbackDescription2(texture.data());
1850     readbackDescription2.setLayer(BAD_LAYER);
1851     readbackBatch->readBackTexture(readbackDescription2, &readResult2);
1852 
1853     cb->endPass(readbackBatch);
1854 
1855     rhi->endOffscreenFrame();
1856 
1857     QCOMPARE(result.size(), outputSize);
1858     QCOMPARE(result2.size(), outputSize);
1859 
1860     if (impl == QRhi::Null)
1861         return;
1862 
1863     // just want to ensure that we did not read the same thing back twice, i.e.
1864     // that the 'layer' parameter was not ignored
1865     QVERIFY(result != result2);
1866 
1867     const int y = 100;
1868     const quint32 *p = reinterpret_cast<const quint32 *>(result.constScanLine(y));
1869     int x = result.width() - 1;
1870     int redCount = 0;
1871     int blueCount = 0;
1872     const int maxFuzz = 1;
1873     while (x-- >= 0) {
1874         const QRgb c(*p++);
1875         if (qRed(c) >= (255 - maxFuzz) && qGreen(c) == 0 && qBlue(c) == 0)
1876             ++redCount;
1877         else if (qRed(c) == 0 && qGreen(c) == 0 && qBlue(c) >= (255 - maxFuzz))
1878             ++blueCount;
1879         else
1880             QFAIL("Encountered a pixel that is neither red or blue");
1881     }
1882 
1883     QCOMPARE(redCount + blueCount, outputSize.width());
1884 
1885     if (rhi->isYUpInFramebuffer() == rhi->isYUpInNDC())
1886         QVERIFY(redCount < blueCount); // 100, 412
1887     else
1888         QVERIFY(redCount > blueCount); // 412, 100
1889 }
1890 
1891 static const float quadVerticesUvs[] = {
1892     -1.0f, -1.0f,   0.0f, 0.0f,
1893     1.0f, -1.0f,    1.0f, 0.0f,
1894     -1.0f, 1.0f,    0.0f, 1.0f,
1895     1.0f, 1.0f,     1.0f, 1.0f
1896 };
1897 
1898 void tst_QRhi::renderToTextureTexturedQuad_data()
1899 {
1900     rhiTestData();
1901 }
1902 
1903 void tst_QRhi::renderToTextureTexturedQuad()
1904 {
1905     QFETCH(QRhi::Implementation, impl);
1906     QFETCH(QRhiInitParams *, initParams);
1907 
1908     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
1909     if (!rhi)
1910         QSKIP("QRhi could not be created, skipping testing rendering");
1911 
1912     QImage inputImage;
1913     inputImage.load(QLatin1String(":/data/qt256.png"));
1914     QVERIFY(!inputImage.isNull());
1915 
1916     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
1917                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
1918     QVERIFY(texture->create());
1919 
1920     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
1921     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
1922     rt->setRenderPassDescriptor(rpDesc.data());
1923     QVERIFY(rt->create());
1924 
1925     QRhiCommandBuffer *cb = nullptr;
1926     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
1927     QVERIFY(cb);
1928 
1929     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
1930 
1931     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(quadVerticesUvs)));
1932     QVERIFY(vbuf->create());
1933     updates->uploadStaticBuffer(vbuf.data(), quadVerticesUvs);
1934 
1935     QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
1936     QVERIFY(inputTexture->create());
1937     updates->uploadTexture(inputTexture.data(), inputImage);
1938 
1939     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
1940                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
1941     QVERIFY(sampler->create());
1942 
1943     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
1944     srb->setBindings({
1945                          QRhiShaderResourceBinding::sampledTexture(0, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
1946                      });
1947     QVERIFY(srb->create());
1948 
1949     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
1950     pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
1951     QShader vs = loadShader(":/data/simpletextured.vert.qsb");
1952     QVERIFY(vs.isValid());
1953     QShader fs = loadShader(":/data/simpletextured.frag.qsb");
1954     QVERIFY(fs.isValid());
1955     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
1956     QRhiVertexInputLayout inputLayout;
1957     inputLayout.setBindings({ { 4 * sizeof(float) } });
1958     inputLayout.setAttributes({
1959                                   { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
1960                                   { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
1961                               });
1962     pipeline->setVertexInputLayout(inputLayout);
1963     pipeline->setShaderResourceBindings(srb.data());
1964     pipeline->setRenderPassDescriptor(rpDesc.data());
1965 
1966     QVERIFY(pipeline->create());
1967 
1968     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
1969     cb->setGraphicsPipeline(pipeline.data());
1970     cb->setShaderResources();
1971     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
1972     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
1973     cb->setVertexInput(0, 1, &vbindings);
1974     cb->draw(4);
1975 
1976     QRhiReadbackResult readResult;
1977     QImage result;
1978     readResult.completed = [&readResult, &result] {
1979         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
1980                         readResult.pixelSize.width(), readResult.pixelSize.height(),
1981                         QImage::Format_RGBA8888_Premultiplied);
1982     };
1983     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
1984     readbackBatch->readBackTexture({ texture.data() }, &readResult);
1985     cb->endPass(readbackBatch);
1986 
1987     rhi->endOffscreenFrame();
1988 
1989     QVERIFY(!result.isNull());
1990 
1991     if (impl == QRhi::Null)
1992         return;
1993 
1994     // Flip with D3D and Metal because these have Y down in images. Vulkan does
1995     // not need this because there Y is down both in images and in NDC, which
1996     // just happens to give correct results with our OpenGL-targeted vertex and
1997     // UV data.
1998     if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC())
1999         result = std::move(result).mirrored();
2000 
2001     // check a few points that are expected to match regardless of the implementation
2002     QRgb white = qRgba(255, 255, 255, 255);
2003     QCOMPARE(result.pixel(79, 77), white);
2004     QCOMPARE(result.pixel(124, 81), white);
2005     QCOMPARE(result.pixel(128, 149), white);
2006     QCOMPARE(result.pixel(120, 189), white);
2007     QCOMPARE(result.pixel(116, 185), white);
2008 
2009     QRgb empty = qRgba(0, 0, 0, 0);
2010     QCOMPARE(result.pixel(11, 45), empty);
2011     QCOMPARE(result.pixel(246, 202), empty);
2012     QCOMPARE(result.pixel(130, 18), empty);
2013     QCOMPARE(result.pixel(4, 227), empty);
2014 
2015     QVERIFY(qGreen(result.pixel(32, 52)) > 2 * qRed(result.pixel(32, 52)));
2016     QVERIFY(qGreen(result.pixel(32, 52)) > 2 * qBlue(result.pixel(32, 52)));
2017     QVERIFY(qGreen(result.pixel(214, 191)) > 2 * qRed(result.pixel(214, 191)));
2018     QVERIFY(qGreen(result.pixel(214, 191)) > 2 * qBlue(result.pixel(214, 191)));
2019 }
2020 
2021 void tst_QRhi::renderToTextureArrayOfTexturedQuad_data()
2022 {
2023     rhiTestData();
2024 }
2025 
2026 void tst_QRhi::renderToTextureArrayOfTexturedQuad()
2027 {
2028     QFETCH(QRhi::Implementation, impl);
2029     QFETCH(QRhiInitParams *, initParams);
2030 
2031     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
2032     if (!rhi)
2033         QSKIP("QRhi could not be created, skipping testing rendering");
2034 
2035     QImage inputImage;
2036     inputImage.load(QLatin1String(":/data/qt256.png"));
2037     QVERIFY(!inputImage.isNull());
2038 
2039     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
2040                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
2041     QVERIFY(texture->create());
2042 
2043     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
2044     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
2045     rt->setRenderPassDescriptor(rpDesc.data());
2046     QVERIFY(rt->create());
2047 
2048     QRhiCommandBuffer *cb = nullptr;
2049     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
2050     QVERIFY(cb);
2051 
2052     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
2053 
2054     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(quadVerticesUvs)));
2055     QVERIFY(vbuf->create());
2056     updates->uploadStaticBuffer(vbuf.data(), quadVerticesUvs);
2057 
2058     // In this test we pass 3 textures (and samplers) to the fragment shader in
2059     // form of an array of combined image samplers.
2060 
2061     QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2062     QVERIFY(inputTexture->create());
2063     updates->uploadTexture(inputTexture.data(), inputImage);
2064 
2065     QImage redImage(inputImage.size(), QImage::Format_RGBA8888);
2066     redImage.fill(Qt::red);
2067 
2068     QScopedPointer<QRhiTexture> redTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2069     QVERIFY(redTexture->create());
2070     updates->uploadTexture(redTexture.data(), redImage);
2071 
2072     QImage greenImage(inputImage.size(), QImage::Format_RGBA8888);
2073     greenImage.fill(Qt::green);
2074 
2075     QScopedPointer<QRhiTexture> greenTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2076     QVERIFY(greenTexture->create());
2077     updates->uploadTexture(greenTexture.data(), greenImage);
2078 
2079     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
2080                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
2081     QVERIFY(sampler->create());
2082 
2083     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
2084     QRhiShaderResourceBinding::TextureAndSampler texSamplers[3] = {
2085         { inputTexture.data(), sampler.data() },
2086         { redTexture.data(), sampler.data() },
2087         { greenTexture.data(), sampler.data() }
2088     };
2089     srb->setBindings({
2090                          QRhiShaderResourceBinding::sampledTextures(0, QRhiShaderResourceBinding::FragmentStage, 3, texSamplers)
2091                      });
2092     QVERIFY(srb->create());
2093 
2094     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
2095     pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
2096     QShader vs = loadShader(":/data/simpletextured.vert.qsb");
2097     QVERIFY(vs.isValid());
2098     QShader fs = loadShader(":/data/simpletextured_array.frag.qsb");
2099     QVERIFY(fs.isValid());
2100     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
2101     QRhiVertexInputLayout inputLayout;
2102     inputLayout.setBindings({ { 4 * sizeof(float) } });
2103     inputLayout.setAttributes({
2104                                   { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
2105                                   { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
2106                               });
2107     pipeline->setVertexInputLayout(inputLayout);
2108     pipeline->setShaderResourceBindings(srb.data());
2109     pipeline->setRenderPassDescriptor(rpDesc.data());
2110 
2111     QVERIFY(pipeline->create());
2112 
2113     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
2114     cb->setGraphicsPipeline(pipeline.data());
2115     cb->setShaderResources();
2116     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2117     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
2118     cb->setVertexInput(0, 1, &vbindings);
2119     cb->draw(4);
2120 
2121     QRhiReadbackResult readResult;
2122     QImage result;
2123     readResult.completed = [&readResult, &result] {
2124         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
2125                         readResult.pixelSize.width(), readResult.pixelSize.height(),
2126                         QImage::Format_RGBA8888_Premultiplied);
2127     };
2128     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
2129     readbackBatch->readBackTexture({ texture.data() }, &readResult);
2130     cb->endPass(readbackBatch);
2131 
2132     rhi->endOffscreenFrame();
2133 
2134     QVERIFY(!result.isNull());
2135 
2136     if (impl == QRhi::Null)
2137         return;
2138 
2139     // Flip with D3D and Metal because these have Y down in images. Vulkan does
2140     // not need this because there Y is down both in images and in NDC, which
2141     // just happens to give correct results with our OpenGL-targeted vertex and
2142     // UV data.
2143     if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC())
2144         result = std::move(result).mirrored();
2145 
2146     // we added the input image + red + green together, so red and green must be all 1
2147     for (int y = 0; y < result.height(); ++y) {
2148         for (int x = 0; x < result.width(); ++x) {
2149             const QRgb pixel = result.pixel(x, y);
2150             QCOMPARE(qRed(pixel), 255);
2151             QCOMPARE(qGreen(pixel), 255);
2152         }
2153     }
2154 }
2155 
2156 void tst_QRhi::renderToTextureTexturedQuadAndUniformBuffer_data()
2157 {
2158     rhiTestData();
2159 }
2160 
2161 void tst_QRhi::renderToTextureTexturedQuadAndUniformBuffer()
2162 {
2163     QFETCH(QRhi::Implementation, impl);
2164     QFETCH(QRhiInitParams *, initParams);
2165 
2166     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
2167     if (!rhi)
2168         QSKIP("QRhi could not be created, skipping testing rendering");
2169 
2170     QImage inputImage;
2171     inputImage.load(QLatin1String(":/data/qt256.png"));
2172     QVERIFY(!inputImage.isNull());
2173 
2174     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
2175                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
2176     QVERIFY(texture->create());
2177 
2178     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
2179     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
2180     rt->setRenderPassDescriptor(rpDesc.data());
2181     QVERIFY(rt->create());
2182 
2183     QRhiCommandBuffer *cb = nullptr;
2184     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
2185     QVERIFY(cb);
2186 
2187     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
2188 
2189     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(quadVerticesUvs)));
2190     QVERIFY(vbuf->create());
2191     updates->uploadStaticBuffer(vbuf.data(), quadVerticesUvs);
2192 
2193     // There will be two renderpasses. One renders with no transformation and
2194     // an opacity of 0.5, the second has a rotation. Bake the uniform data for
2195     // both into a single buffer.
2196 
2197     const int UNIFORM_BLOCK_SIZE = 64 + 4; // matrix + opacity
2198     const int secondUbufOffset = rhi->ubufAligned(UNIFORM_BLOCK_SIZE);
2199     const int UBUF_SIZE = secondUbufOffset + UNIFORM_BLOCK_SIZE;
2200 
2201     QScopedPointer<QRhiBuffer> ubuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, UBUF_SIZE));
2202     QVERIFY(ubuf->create());
2203 
2204     QMatrix4x4 matrix;
2205     updates->updateDynamicBuffer(ubuf.data(), 0, 64, matrix.constData());
2206     float opacity = 0.5f;
2207     updates->updateDynamicBuffer(ubuf.data(), 64, 4, &opacity);
2208 
2209     // rotation by 45 degrees around the Z axis
2210     matrix.rotate(45, 0, 0, 1);
2211     updates->updateDynamicBuffer(ubuf.data(), secondUbufOffset, 64, matrix.constData());
2212     updates->updateDynamicBuffer(ubuf.data(), secondUbufOffset + 64, 4, &opacity);
2213 
2214     QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2215     QVERIFY(inputTexture->create());
2216     updates->uploadTexture(inputTexture.data(), inputImage);
2217 
2218     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
2219                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
2220     QVERIFY(sampler->create());
2221 
2222     const QRhiShaderResourceBinding::StageFlags commonVisibility = QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage;
2223     QScopedPointer<QRhiShaderResourceBindings> srb0(rhi->newShaderResourceBindings());
2224     srb0->setBindings({
2225                          QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data(), 0, UNIFORM_BLOCK_SIZE),
2226                          QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
2227                      });
2228     QVERIFY(srb0->create());
2229 
2230     QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
2231     srb1->setBindings({
2232                          QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data(), secondUbufOffset, UNIFORM_BLOCK_SIZE),
2233                          QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
2234                      });
2235     QVERIFY(srb1->create());
2236     QVERIFY(srb1->isLayoutCompatible(srb0.data())); // hence no need for a second pipeline
2237 
2238     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
2239     pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
2240     QShader vs = loadShader(":/data/textured.vert.qsb");
2241     QVERIFY(vs.isValid());
2242     QShaderDescription shaderDesc = vs.description();
2243     QVERIFY(!shaderDesc.uniformBlocks().isEmpty());
2244     QCOMPARE(shaderDesc.uniformBlocks().first().size, UNIFORM_BLOCK_SIZE);
2245 
2246     QShader fs = loadShader(":/data/textured.frag.qsb");
2247     QVERIFY(fs.isValid());
2248     shaderDesc = fs.description();
2249     QVERIFY(!shaderDesc.uniformBlocks().isEmpty());
2250     QCOMPARE(shaderDesc.uniformBlocks().first().size, UNIFORM_BLOCK_SIZE);
2251 
2252     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
2253     QRhiVertexInputLayout inputLayout;
2254     inputLayout.setBindings({ { 4 * sizeof(float) } });
2255     inputLayout.setAttributes({
2256                                   { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
2257                                   { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
2258                               });
2259     pipeline->setVertexInputLayout(inputLayout);
2260     pipeline->setShaderResourceBindings(srb0.data());
2261     pipeline->setRenderPassDescriptor(rpDesc.data());
2262 
2263     QVERIFY(pipeline->create());
2264 
2265     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
2266     cb->setGraphicsPipeline(pipeline.data());
2267     cb->setShaderResources();
2268     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2269     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
2270     cb->setVertexInput(0, 1, &vbindings);
2271     cb->draw(4);
2272 
2273     QRhiReadbackResult readResult0;
2274     QImage result0;
2275     readResult0.completed = [&readResult0, &result0] {
2276         result0 = QImage(reinterpret_cast<const uchar *>(readResult0.data.constData()),
2277                         readResult0.pixelSize.width(), readResult0.pixelSize.height(),
2278                         QImage::Format_RGBA8888_Premultiplied);
2279     };
2280     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
2281     readbackBatch->readBackTexture({ texture.data() }, &readResult0);
2282     cb->endPass(readbackBatch);
2283 
2284     // second pass (rotated)
2285     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 });
2286     cb->setGraphicsPipeline(pipeline.data());
2287     cb->setShaderResources(srb1.data()); // sources data from a different offset in ubuf
2288     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2289     cb->setVertexInput(0, 1, &vbindings);
2290     cb->draw(4);
2291 
2292     QRhiReadbackResult readResult1;
2293     QImage result1;
2294     readResult1.completed = [&readResult1, &result1] {
2295         result1 = QImage(reinterpret_cast<const uchar *>(readResult1.data.constData()),
2296                         readResult1.pixelSize.width(), readResult1.pixelSize.height(),
2297                         QImage::Format_RGBA8888_Premultiplied);
2298     };
2299     readbackBatch = rhi->nextResourceUpdateBatch();
2300     readbackBatch->readBackTexture({ texture.data() }, &readResult1);
2301     cb->endPass(readbackBatch);
2302 
2303     rhi->endOffscreenFrame();
2304 
2305     QVERIFY(!result0.isNull());
2306     QVERIFY(!result1.isNull());
2307 
2308     if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC()) {
2309         result0 = std::move(result0).mirrored();
2310         result1 = std::move(result1).mirrored();
2311     }
2312 
2313     if (impl == QRhi::Null)
2314         return;
2315 
2316     // opacity 0.5 (premultiplied)
2317     static const auto checkSemiWhite = [](const QRgb &c) {
2318         QRgb semiWhite127 = qPremultiply(qRgba(255, 255, 255, 127));
2319         QRgb semiWhite128 = qPremultiply(qRgba(255, 255, 255, 128));
2320         return c == semiWhite127 || c == semiWhite128;
2321     };
2322     QVERIFY(checkSemiWhite(result0.pixel(79, 77)));
2323     QVERIFY(checkSemiWhite(result0.pixel(124, 81)));
2324     QVERIFY(checkSemiWhite(result0.pixel(128, 149)));
2325     QVERIFY(checkSemiWhite(result0.pixel(120, 189)));
2326     QVERIFY(checkSemiWhite(result0.pixel(116, 185)));
2327     QVERIFY(checkSemiWhite(result0.pixel(191, 172)));
2328 
2329     QRgb empty = qRgba(0, 0, 0, 0);
2330     QCOMPARE(result0.pixel(11, 45), empty);
2331     QCOMPARE(result0.pixel(246, 202), empty);
2332     QCOMPARE(result0.pixel(130, 18), empty);
2333     QCOMPARE(result0.pixel(4, 227), empty);
2334 
2335     // also rotated 45 degrees around Z
2336     QRgb black = qRgba(0, 0, 0, 255);
2337     QCOMPARE(result1.pixel(20, 23), black);
2338     QCOMPARE(result1.pixel(47, 5), black);
2339     QCOMPARE(result1.pixel(238, 22), black);
2340     QCOMPARE(result1.pixel(250, 203), black);
2341     QCOMPARE(result1.pixel(224, 237), black);
2342     QCOMPARE(result1.pixel(12, 221), black);
2343 
2344     QVERIFY(checkSemiWhite(result1.pixel(142, 67)));
2345     QVERIFY(checkSemiWhite(result1.pixel(81, 79)));
2346     QVERIFY(checkSemiWhite(result1.pixel(79, 168)));
2347     QVERIFY(checkSemiWhite(result1.pixel(146, 204)));
2348     QVERIFY(checkSemiWhite(result1.pixel(186, 156)));
2349 
2350     QCOMPARE(result1.pixel(204, 45), empty);
2351     QCOMPARE(result1.pixel(28, 178), empty);
2352 }
2353 
2354 void tst_QRhi::renderToTextureTexturedQuadAllDynamicBuffers_data()
2355 {
2356     rhiTestData();
2357 }
2358 
2359 void tst_QRhi::renderToTextureTexturedQuadAllDynamicBuffers()
2360 {
2361     QFETCH(QRhi::Implementation, impl);
2362     QFETCH(QRhiInitParams *, initParams);
2363 
2364     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
2365     if (!rhi)
2366         QSKIP("QRhi could not be created, skipping testing rendering");
2367 
2368     QImage inputImage;
2369     inputImage.load(QLatin1String(":/data/qt256.png"));
2370     QVERIFY(!inputImage.isNull());
2371 
2372     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
2373                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
2374     QVERIFY(texture->create());
2375 
2376     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
2377     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
2378     rt->setRenderPassDescriptor(rpDesc.data());
2379     QVERIFY(rt->create());
2380 
2381     QRhiCommandBuffer *cb = nullptr;
2382     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
2383     QVERIFY(cb);
2384 
2385     // Do like renderToTextureTexturedQuadAndUniformBuffer but only use Dynamic
2386     // buffers, and do updates with the direct beginFullDynamicBufferUpdate
2387     // function. (for some backend this is different for UniformBuffer and
2388     // others, hence useful exercising it also on a VertexBuffer)
2389 
2390     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::VertexBuffer, sizeof(quadVerticesUvs)));
2391     QVERIFY(vbuf->create());
2392     char *p = vbuf->beginFullDynamicBufferUpdateForCurrentFrame();
2393     QVERIFY(p);
2394     memcpy(p, quadVerticesUvs, sizeof(quadVerticesUvs));
2395     vbuf->endFullDynamicBufferUpdateForCurrentFrame();
2396 
2397     const int UNIFORM_BLOCK_SIZE = 64 + 4; // matrix + opacity
2398     const int secondUbufOffset = rhi->ubufAligned(UNIFORM_BLOCK_SIZE);
2399     const int UBUF_SIZE = secondUbufOffset + UNIFORM_BLOCK_SIZE;
2400 
2401     QScopedPointer<QRhiBuffer> ubuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, UBUF_SIZE));
2402     QVERIFY(ubuf->create());
2403 
2404     p = ubuf->beginFullDynamicBufferUpdateForCurrentFrame();
2405     QVERIFY(p);
2406 
2407     QMatrix4x4 matrix;
2408     memcpy(p, matrix.constData(), 64);
2409     float opacity = 0.5f;
2410     memcpy(p + 64, &opacity, 4);
2411 
2412     // rotation by 45 degrees around the Z axis
2413     matrix.rotate(45, 0, 0, 1);
2414     memcpy(p + secondUbufOffset, matrix.constData(), 64);
2415     memcpy(p + secondUbufOffset + 64, &opacity, 4);
2416 
2417     ubuf->endFullDynamicBufferUpdateForCurrentFrame();
2418 
2419     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
2420     QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2421     QVERIFY(inputTexture->create());
2422     updates->uploadTexture(inputTexture.data(), inputImage);
2423     cb->resourceUpdate(updates);
2424 
2425     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
2426                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
2427     QVERIFY(sampler->create());
2428 
2429     const QRhiShaderResourceBinding::StageFlags commonVisibility = QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage;
2430     QScopedPointer<QRhiShaderResourceBindings> srb0(rhi->newShaderResourceBindings());
2431     srb0->setBindings({
2432                          QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data(), 0, UNIFORM_BLOCK_SIZE),
2433                          QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
2434                      });
2435     QVERIFY(srb0->create());
2436 
2437     QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
2438     srb1->setBindings({
2439                          QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data(), secondUbufOffset, UNIFORM_BLOCK_SIZE),
2440                          QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
2441                      });
2442     QVERIFY(srb1->create());
2443     QVERIFY(srb1->isLayoutCompatible(srb0.data())); // hence no need for a second pipeline
2444 
2445     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
2446     pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
2447     QShader vs = loadShader(":/data/textured.vert.qsb");
2448     QVERIFY(vs.isValid());
2449     QShaderDescription shaderDesc = vs.description();
2450     QVERIFY(!shaderDesc.uniformBlocks().isEmpty());
2451     QCOMPARE(shaderDesc.uniformBlocks().first().size, UNIFORM_BLOCK_SIZE);
2452 
2453     QShader fs = loadShader(":/data/textured.frag.qsb");
2454     QVERIFY(fs.isValid());
2455     shaderDesc = fs.description();
2456     QVERIFY(!shaderDesc.uniformBlocks().isEmpty());
2457     QCOMPARE(shaderDesc.uniformBlocks().first().size, UNIFORM_BLOCK_SIZE);
2458 
2459     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
2460     QRhiVertexInputLayout inputLayout;
2461     inputLayout.setBindings({ { 4 * sizeof(float) } });
2462     inputLayout.setAttributes({
2463                                   { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
2464                                   { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
2465                               });
2466     pipeline->setVertexInputLayout(inputLayout);
2467     pipeline->setShaderResourceBindings(srb0.data());
2468     pipeline->setRenderPassDescriptor(rpDesc.data());
2469 
2470     QVERIFY(pipeline->create());
2471 
2472     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 });
2473     cb->setGraphicsPipeline(pipeline.data());
2474     cb->setShaderResources();
2475     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2476     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
2477     cb->setVertexInput(0, 1, &vbindings);
2478     cb->draw(4);
2479 
2480     QRhiReadbackResult readResult0;
2481     QImage result0;
2482     readResult0.completed = [&readResult0, &result0] {
2483         result0 = QImage(reinterpret_cast<const uchar *>(readResult0.data.constData()),
2484                         readResult0.pixelSize.width(), readResult0.pixelSize.height(),
2485                         QImage::Format_RGBA8888_Premultiplied);
2486     };
2487     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
2488     readbackBatch->readBackTexture({ texture.data() }, &readResult0);
2489     cb->endPass(readbackBatch);
2490 
2491     // second pass (rotated)
2492     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 });
2493     cb->setGraphicsPipeline(pipeline.data());
2494     cb->setShaderResources(srb1.data()); // sources data from a different offset in ubuf
2495     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2496     cb->setVertexInput(0, 1, &vbindings);
2497     cb->draw(4);
2498 
2499     QRhiReadbackResult readResult1;
2500     QImage result1;
2501     readResult1.completed = [&readResult1, &result1] {
2502         result1 = QImage(reinterpret_cast<const uchar *>(readResult1.data.constData()),
2503                         readResult1.pixelSize.width(), readResult1.pixelSize.height(),
2504                         QImage::Format_RGBA8888_Premultiplied);
2505     };
2506     readbackBatch = rhi->nextResourceUpdateBatch();
2507     readbackBatch->readBackTexture({ texture.data() }, &readResult1);
2508     cb->endPass(readbackBatch);
2509 
2510     rhi->endOffscreenFrame();
2511 
2512     QVERIFY(!result0.isNull());
2513     QVERIFY(!result1.isNull());
2514 
2515     if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC()) {
2516         result0 = std::move(result0).mirrored();
2517         result1 = std::move(result1).mirrored();
2518     }
2519 
2520     if (impl == QRhi::Null)
2521         return;
2522 
2523     // opacity 0.5 (premultiplied)
2524     static const auto checkSemiWhite = [](const QRgb &c) {
2525         QRgb semiWhite127 = qPremultiply(qRgba(255, 255, 255, 127));
2526         QRgb semiWhite128 = qPremultiply(qRgba(255, 255, 255, 128));
2527         return c == semiWhite127 || c == semiWhite128;
2528     };
2529     QVERIFY(checkSemiWhite(result0.pixel(79, 77)));
2530     QVERIFY(checkSemiWhite(result0.pixel(124, 81)));
2531     QVERIFY(checkSemiWhite(result0.pixel(128, 149)));
2532     QVERIFY(checkSemiWhite(result0.pixel(120, 189)));
2533     QVERIFY(checkSemiWhite(result0.pixel(116, 185)));
2534     QVERIFY(checkSemiWhite(result0.pixel(191, 172)));
2535 
2536     QRgb empty = qRgba(0, 0, 0, 0);
2537     QCOMPARE(result0.pixel(11, 45), empty);
2538     QCOMPARE(result0.pixel(246, 202), empty);
2539     QCOMPARE(result0.pixel(130, 18), empty);
2540     QCOMPARE(result0.pixel(4, 227), empty);
2541 
2542     // also rotated 45 degrees around Z
2543     QRgb black = qRgba(0, 0, 0, 255);
2544     QCOMPARE(result1.pixel(20, 23), black);
2545     QCOMPARE(result1.pixel(47, 5), black);
2546     QCOMPARE(result1.pixel(238, 22), black);
2547     QCOMPARE(result1.pixel(250, 203), black);
2548     QCOMPARE(result1.pixel(224, 237), black);
2549     QCOMPARE(result1.pixel(12, 221), black);
2550 
2551     QVERIFY(checkSemiWhite(result1.pixel(142, 67)));
2552     QVERIFY(checkSemiWhite(result1.pixel(81, 79)));
2553     QVERIFY(checkSemiWhite(result1.pixel(79, 168)));
2554     QVERIFY(checkSemiWhite(result1.pixel(146, 204)));
2555     QVERIFY(checkSemiWhite(result1.pixel(186, 156)));
2556 
2557     QCOMPARE(result1.pixel(204, 45), empty);
2558     QCOMPARE(result1.pixel(28, 178), empty);
2559 }
2560 
2561 void tst_QRhi::renderToTextureDeferredSrb_data()
2562 {
2563     rhiTestData();
2564 }
2565 
2566 void tst_QRhi::renderToTextureDeferredSrb()
2567 {
2568     QFETCH(QRhi::Implementation, impl);
2569     QFETCH(QRhiInitParams *, initParams);
2570 
2571     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
2572     if (!rhi)
2573         QSKIP("QRhi could not be created, skipping testing rendering");
2574 
2575     QImage inputImage;
2576     inputImage.load(QLatin1String(":/data/qt256.png"));
2577     QVERIFY(!inputImage.isNull());
2578 
2579     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
2580                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
2581     QVERIFY(texture->create());
2582 
2583     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
2584     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
2585     rt->setRenderPassDescriptor(rpDesc.data());
2586     QVERIFY(rt->create());
2587 
2588     QRhiCommandBuffer *cb = nullptr;
2589     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
2590     QVERIFY(cb);
2591 
2592     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
2593 
2594     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(quadVerticesUvs)));
2595     QVERIFY(vbuf->create());
2596     updates->uploadStaticBuffer(vbuf.data(), quadVerticesUvs);
2597 
2598     QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2599     QVERIFY(inputTexture->create());
2600     updates->uploadTexture(inputTexture.data(), inputImage);
2601 
2602     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
2603                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
2604     QVERIFY(sampler->create());
2605 
2606     QScopedPointer<QRhiBuffer> ubuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 64 + 4));
2607     QVERIFY(ubuf->create());
2608 
2609     QMatrix4x4 matrix;
2610     updates->updateDynamicBuffer(ubuf.data(), 0, 64, matrix.constData());
2611     float opacity = 0.5f;
2612     updates->updateDynamicBuffer(ubuf.data(), 64, 4, &opacity);
2613 
2614     // this is the specific thing to test here: an srb with null resources
2615     const QRhiShaderResourceBinding::StageFlags commonVisibility = QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage;
2616     QScopedPointer<QRhiShaderResourceBindings> layoutOnlySrb(rhi->newShaderResourceBindings());
2617     layoutOnlySrb->setBindings({
2618                          QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, nullptr),
2619                          QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, nullptr, nullptr)
2620                      });
2621     QVERIFY(layoutOnlySrb->create());
2622 
2623     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
2624     pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
2625     QShader vs = loadShader(":/data/textured.vert.qsb");
2626     QVERIFY(vs.isValid());
2627     QShader fs = loadShader(":/data/textured.frag.qsb");
2628     QVERIFY(fs.isValid());
2629     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
2630     QRhiVertexInputLayout inputLayout;
2631     inputLayout.setBindings({ { 4 * sizeof(float) } });
2632     inputLayout.setAttributes({
2633                                   { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
2634                                   { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
2635                               });
2636     pipeline->setVertexInputLayout(inputLayout);
2637     pipeline->setShaderResourceBindings(layoutOnlySrb.data()); // no resources needed yet
2638     pipeline->setRenderPassDescriptor(rpDesc.data());
2639 
2640     QVERIFY(pipeline->create());
2641 
2642     // another, layout compatible, srb with the actual resources
2643     QScopedPointer<QRhiShaderResourceBindings> layoutCompatibleSrbWithResources(rhi->newShaderResourceBindings());
2644     layoutCompatibleSrbWithResources->setBindings({
2645                          QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data()),
2646                          QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
2647                      });
2648     QVERIFY(layoutCompatibleSrbWithResources->create());
2649 
2650     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
2651     cb->setGraphicsPipeline(pipeline.data());
2652     cb->setShaderResources(layoutCompatibleSrbWithResources.data()); // here we must use the srb referencing the resources
2653     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2654     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
2655     cb->setVertexInput(0, 1, &vbindings);
2656     cb->draw(4);
2657 
2658     QRhiReadbackResult readResult;
2659     QImage result;
2660     readResult.completed = [&readResult, &result] {
2661         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
2662                         readResult.pixelSize.width(), readResult.pixelSize.height(),
2663                         QImage::Format_RGBA8888_Premultiplied);
2664     };
2665     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
2666     readbackBatch->readBackTexture({ texture.data() }, &readResult);
2667     cb->endPass(readbackBatch);
2668 
2669     rhi->endOffscreenFrame();
2670 
2671     QVERIFY(!result.isNull());
2672 
2673     if (impl == QRhi::Null)
2674         return;
2675 
2676     if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC())
2677         result = std::move(result).mirrored();
2678 
2679     // opacity 0.5 (premultiplied)
2680     static const auto checkSemiWhite = [](const QRgb &c) {
2681         QRgb semiWhite127 = qPremultiply(qRgba(255, 255, 255, 127));
2682         QRgb semiWhite128 = qPremultiply(qRgba(255, 255, 255, 128));
2683         return c == semiWhite127 || c == semiWhite128;
2684     };
2685     QVERIFY(checkSemiWhite(result.pixel(79, 77)));
2686     QVERIFY(checkSemiWhite(result.pixel(124, 81)));
2687     QVERIFY(checkSemiWhite(result.pixel(128, 149)));
2688     QVERIFY(checkSemiWhite(result.pixel(120, 189)));
2689     QVERIFY(checkSemiWhite(result.pixel(116, 185)));
2690     QVERIFY(checkSemiWhite(result.pixel(191, 172)));
2691 
2692     QRgb empty = qRgba(0, 0, 0, 0);
2693     QCOMPARE(result.pixel(11, 45), empty);
2694     QCOMPARE(result.pixel(246, 202), empty);
2695     QCOMPARE(result.pixel(130, 18), empty);
2696     QCOMPARE(result.pixel(4, 227), empty);
2697 }
2698 
2699 void tst_QRhi::renderToTextureMultipleUniformBuffersAndDynamicOffset_data()
2700 {
2701     rhiTestData();
2702 }
2703 
2704 void tst_QRhi::renderToTextureMultipleUniformBuffersAndDynamicOffset()
2705 {
2706     QFETCH(QRhi::Implementation, impl);
2707     QFETCH(QRhiInitParams *, initParams);
2708 
2709     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
2710     if (!rhi)
2711         QSKIP("QRhi could not be created, skipping testing rendering");
2712 
2713     QImage inputImage;
2714     inputImage.load(QLatin1String(":/data/qt256.png"));
2715     QVERIFY(!inputImage.isNull());
2716 
2717     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
2718                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
2719     QVERIFY(texture->create());
2720 
2721     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
2722     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
2723     rt->setRenderPassDescriptor(rpDesc.data());
2724     QVERIFY(rt->create());
2725 
2726     QRhiCommandBuffer *cb = nullptr;
2727     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
2728     QVERIFY(cb);
2729 
2730     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
2731 
2732     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(quadVerticesUvs)));
2733     QVERIFY(vbuf->create());
2734     updates->uploadStaticBuffer(vbuf.data(), quadVerticesUvs);
2735 
2736     QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2737     QVERIFY(inputTexture->create());
2738     updates->uploadTexture(inputTexture.data(), inputImage);
2739 
2740     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
2741                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
2742     QVERIFY(sampler->create());
2743 
2744     const int MATRIX_COUNT = 4; // put 4 mat4s into the buffer, will only use one
2745     const int ubufElemSize = rhi->ubufAligned(64);
2746     QVERIFY(ubufElemSize >= 64);
2747     QScopedPointer<QRhiBuffer> ubuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, MATRIX_COUNT * ubufElemSize));
2748     QVERIFY(ubuf->create());
2749 
2750     float zeroes[16];
2751     memset(zeroes, 0, sizeof(zeroes));
2752     updates->updateDynamicBuffer(ubuf.data(), 0, 64, zeroes);
2753     updates->updateDynamicBuffer(ubuf.data(), ubufElemSize, 64, zeroes);
2754     // the only correct matrix is the third one
2755     QMatrix4x4 matrix;
2756     updates->updateDynamicBuffer(ubuf.data(), ubufElemSize * 2, 64, matrix.constData());
2757     updates->updateDynamicBuffer(ubuf.data(), ubufElemSize * 3, 64, zeroes);
2758 
2759     const int OPACITY_COUNT = 6; // put 6 floats into the buffer, will only use one
2760     const int ubuf2ElemSize = rhi->ubufAligned(4);
2761     QVERIFY(ubuf2ElemSize >= 4);
2762     QScopedPointer<QRhiBuffer> ubuf2(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, OPACITY_COUNT * ubuf2ElemSize));
2763     QVERIFY(ubuf2->create());
2764 
2765     updates->updateDynamicBuffer(ubuf2.data(), 0, 4, &zeroes[0]);
2766     updates->updateDynamicBuffer(ubuf2.data(), ubuf2ElemSize, 4, &zeroes[0]);
2767     updates->updateDynamicBuffer(ubuf2.data(), ubuf2ElemSize * 2, 4, &zeroes[0]);
2768     // the only correct opacity value is the fourth one
2769     float opacity = 0.5f;
2770     updates->updateDynamicBuffer(ubuf2.data(), ubuf2ElemSize * 3, 4, &opacity);
2771     updates->updateDynamicBuffer(ubuf2.data(), ubuf2ElemSize * 4, 4, &zeroes[0]);
2772     updates->updateDynamicBuffer(ubuf2.data(), ubuf2ElemSize * 5, 4, &zeroes[0]);
2773 
2774     const QRhiShaderResourceBinding::StageFlags commonVisibility = QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage;
2775     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
2776     srb->setBindings({
2777                          QRhiShaderResourceBinding::uniformBufferWithDynamicOffset(0, commonVisibility, ubuf.data(), 64),
2778                          QRhiShaderResourceBinding::uniformBufferWithDynamicOffset(1, commonVisibility, ubuf2.data(), 4),
2779                          QRhiShaderResourceBinding::sampledTexture(2, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
2780                      });
2781     QVERIFY(srb->create());
2782 
2783     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
2784     pipeline->setTopology(QRhiGraphicsPipeline::TriangleStrip);
2785     QShader vs = loadShader(":/data/textured_multiubuf.vert.qsb");
2786     QVERIFY(vs.isValid());
2787     QShader fs = loadShader(":/data/textured_multiubuf.frag.qsb");
2788     QVERIFY(fs.isValid());
2789     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
2790     QRhiVertexInputLayout inputLayout;
2791     inputLayout.setBindings({ { 4 * sizeof(float) } });
2792     inputLayout.setAttributes({
2793                                   { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
2794                                   { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
2795                               });
2796     pipeline->setVertexInputLayout(inputLayout);
2797     pipeline->setShaderResourceBindings(srb.data());
2798     pipeline->setRenderPassDescriptor(rpDesc.data());
2799 
2800     QVERIFY(pipeline->create());
2801 
2802     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
2803     cb->setGraphicsPipeline(pipeline.data());
2804 
2805     // Now the magic, expose the 3rd matrix and 4th opacity value to the shader.
2806     // If the handling of dynamic offsets were broken, the shaders would likely
2807     // "see" an all zero matrix and zero opacity, thus leading to different
2808     // rendering output. This way we can verify if using dynamic offsets, and
2809     // more than one at the same time, is functional.
2810     QVarLengthArray<QPair<int, quint32>, 2> dynamicOffset = {
2811         { 0, quint32(ubufElemSize * 2) },
2812         { 1, quint32(ubuf2ElemSize * 3) },
2813     };
2814     cb->setShaderResources(srb.data(), 2, dynamicOffset.constData());
2815 
2816     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2817     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
2818     cb->setVertexInput(0, 1, &vbindings);
2819     cb->draw(4);
2820 
2821     QRhiReadbackResult readResult;
2822     QImage result;
2823     readResult.completed = [&readResult, &result] {
2824         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
2825                         readResult.pixelSize.width(), readResult.pixelSize.height(),
2826                         QImage::Format_RGBA8888_Premultiplied);
2827     };
2828     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
2829     readbackBatch->readBackTexture({ texture.data() }, &readResult);
2830     cb->endPass(readbackBatch);
2831 
2832     rhi->endOffscreenFrame();
2833 
2834     QVERIFY(!result.isNull());
2835 
2836     if (impl == QRhi::Null)
2837         return;
2838 
2839     if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC())
2840         result = std::move(result).mirrored();
2841 
2842     // opacity 0.5 (premultiplied)
2843     static const auto checkSemiWhite = [](const QRgb &c) {
2844         QRgb semiWhite127 = qPremultiply(qRgba(255, 255, 255, 127));
2845         QRgb semiWhite128 = qPremultiply(qRgba(255, 255, 255, 128));
2846         return c == semiWhite127 || c == semiWhite128;
2847     };
2848     QVERIFY(checkSemiWhite(result.pixel(79, 77)));
2849     QVERIFY(checkSemiWhite(result.pixel(124, 81)));
2850     QVERIFY(checkSemiWhite(result.pixel(128, 149)));
2851     QVERIFY(checkSemiWhite(result.pixel(120, 189)));
2852     QVERIFY(checkSemiWhite(result.pixel(116, 185)));
2853     QVERIFY(checkSemiWhite(result.pixel(191, 172)));
2854 
2855     QRgb empty = qRgba(0, 0, 0, 0);
2856     QCOMPARE(result.pixel(11, 45), empty);
2857     QCOMPARE(result.pixel(246, 202), empty);
2858     QCOMPARE(result.pixel(130, 18), empty);
2859     QCOMPARE(result.pixel(4, 227), empty);
2860 }
2861 
2862 void tst_QRhi::renderToTextureSrbReuse_data()
2863 {
2864     rhiTestData();
2865 }
2866 
2867 void tst_QRhi::renderToTextureSrbReuse()
2868 {
2869     QFETCH(QRhi::Implementation, impl);
2870     QFETCH(QRhiInitParams *, initParams);
2871 
2872     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
2873     if (!rhi)
2874         QSKIP("QRhi could not be created, skipping testing rendering");
2875 
2876     // Draw a textured quad with opacity 0.5. The difference to the simple tests
2877     // of the same kind is that there are two (configuration-wise identical)
2878     // pipeline objects that are bound after each other, with the same one srb,
2879     // on the command buffer. This exercises, in particular for the OpenGL
2880     // backend, that the uniforms are set for the pipelines' underlying shader
2881     // program correctly. (with OpenGL we may not use real uniform buffers,
2882     // which presents extra pipeline-srb tracking work for the backend)
2883 
2884     QImage inputImage;
2885     inputImage.load(QLatin1String(":/data/qt256.png"));
2886     QVERIFY(!inputImage.isNull());
2887 
2888     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size(), 1,
2889                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
2890     QVERIFY(texture->create());
2891 
2892     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
2893     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
2894     rt->setRenderPassDescriptor(rpDesc.data());
2895     QVERIFY(rt->create());
2896 
2897     QRhiCommandBuffer *cb = nullptr;
2898     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
2899     QVERIFY(cb);
2900 
2901     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
2902 
2903     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(quadVerticesUvs)));
2904     QVERIFY(vbuf->create());
2905     updates->uploadStaticBuffer(vbuf.data(), quadVerticesUvs);
2906 
2907     QScopedPointer<QRhiTexture> inputTexture(rhi->newTexture(QRhiTexture::RGBA8, inputImage.size()));
2908     QVERIFY(inputTexture->create());
2909     updates->uploadTexture(inputTexture.data(), inputImage);
2910 
2911     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
2912                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
2913     QVERIFY(sampler->create());
2914 
2915     QScopedPointer<QRhiBuffer> ubuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 64 + 4));
2916     QVERIFY(ubuf->create());
2917     QMatrix4x4 matrix;
2918     updates->updateDynamicBuffer(ubuf.data(), 0, 64, matrix.constData());
2919     float opacity = 0.5f;
2920     updates->updateDynamicBuffer(ubuf.data(), 64, 4, &opacity);
2921 
2922     const QRhiShaderResourceBinding::StageFlags commonVisibility = QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage;
2923     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
2924     srb->setBindings({
2925             QRhiShaderResourceBinding::uniformBuffer(0, commonVisibility, ubuf.data()),
2926             QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, inputTexture.data(), sampler.data())
2927         });
2928     QVERIFY(srb->create());
2929 
2930     QScopedPointer<QRhiGraphicsPipeline> pipeline1(rhi->newGraphicsPipeline());
2931     pipeline1->setTopology(QRhiGraphicsPipeline::TriangleStrip);
2932     QShader vs = loadShader(":/data/textured.vert.qsb");
2933     QVERIFY(vs.isValid());
2934     QShader fs = loadShader(":/data/textured.frag.qsb");
2935     QVERIFY(fs.isValid());
2936     pipeline1->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
2937     QRhiVertexInputLayout inputLayout;
2938     inputLayout.setBindings({ { 4 * sizeof(float) } });
2939     inputLayout.setAttributes({
2940                                   { 0, 0, QRhiVertexInputAttribute::Float2, 0 },
2941                                   { 0, 1, QRhiVertexInputAttribute::Float2, 2 * sizeof(float) }
2942                               });
2943     pipeline1->setVertexInputLayout(inputLayout);
2944     pipeline1->setShaderResourceBindings(srb.data());
2945     pipeline1->setRenderPassDescriptor(rpDesc.data());
2946     QVERIFY(pipeline1->create());
2947 
2948     QScopedPointer<QRhiGraphicsPipeline> pipeline2(rhi->newGraphicsPipeline());
2949     pipeline2->setTopology(QRhiGraphicsPipeline::TriangleStrip);
2950     pipeline2->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
2951     pipeline2->setVertexInputLayout(inputLayout);
2952     pipeline2->setShaderResourceBindings(srb.data());
2953     pipeline2->setRenderPassDescriptor(rpDesc.data());
2954     QVERIFY(pipeline2->create());
2955 
2956     cb->beginPass(rt.data(), Qt::black, { 1.0f, 0 }, updates);
2957 
2958     // The key step in this test: set the 1st pipeline, then the 2nd, the
2959     // srb is the same. This should lead to identical results to just
2960     // binding one of them.
2961     cb->setGraphicsPipeline(pipeline1.data());
2962     cb->setShaderResources(srb.data());
2963     cb->setGraphicsPipeline(pipeline2.data());
2964     cb->setShaderResources(srb.data());
2965     cb->setViewport({ 0, 0, float(texture->pixelSize().width()), float(texture->pixelSize().height()) });
2966     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
2967     cb->setVertexInput(0, 1, &vbindings);
2968     cb->draw(4);
2969 
2970     QRhiReadbackResult readResult;
2971     QImage result;
2972     readResult.completed = [&readResult, &result] {
2973         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
2974                         readResult.pixelSize.width(), readResult.pixelSize.height(),
2975                         QImage::Format_RGBA8888_Premultiplied);
2976     };
2977     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
2978     readbackBatch->readBackTexture({ texture.data() }, &readResult);
2979     cb->endPass(readbackBatch);
2980 
2981     rhi->endOffscreenFrame();
2982 
2983     QVERIFY(!result.isNull());
2984 
2985     if (impl == QRhi::Null)
2986         return;
2987 
2988     if (rhi->isYUpInFramebuffer() != rhi->isYUpInNDC())
2989         result = std::move(result).mirrored();
2990 
2991     // opacity 0.5 (premultiplied)
2992     static const auto checkSemiWhite = [](const QRgb &c) {
2993         QRgb semiWhite127 = qPremultiply(qRgba(255, 255, 255, 127));
2994         QRgb semiWhite128 = qPremultiply(qRgba(255, 255, 255, 128));
2995         return c == semiWhite127 || c == semiWhite128;
2996     };
2997     QVERIFY(checkSemiWhite(result.pixel(79, 77)));
2998     QVERIFY(checkSemiWhite(result.pixel(124, 81)));
2999     QVERIFY(checkSemiWhite(result.pixel(128, 149)));
3000     QVERIFY(checkSemiWhite(result.pixel(120, 189)));
3001     QVERIFY(checkSemiWhite(result.pixel(116, 185)));
3002     QVERIFY(checkSemiWhite(result.pixel(191, 172)));
3003 
3004     QRgb empty = qRgba(0, 0, 0, 0);
3005     QCOMPARE(result.pixel(11, 45), empty);
3006     QCOMPARE(result.pixel(246, 202), empty);
3007     QCOMPARE(result.pixel(130, 18), empty);
3008     QCOMPARE(result.pixel(4, 227), empty);
3009 }
3010 
3011 void tst_QRhi::setWindowType(QWindow *window, QRhi::Implementation impl)
3012 {
3013     switch (impl) {
3014 #ifdef TST_GL
3015     case QRhi::OpenGLES2:
3016         window->setFormat(QRhiGles2InitParams::adjustedFormat());
3017         window->setSurfaceType(QSurface::OpenGLSurface);
3018         break;
3019 #endif
3020     case QRhi::D3D11:
3021         window->setSurfaceType(QSurface::Direct3DSurface);
3022         break;
3023     case QRhi::Metal:
3024         window->setSurfaceType(QSurface::MetalSurface);
3025         break;
3026 #ifdef TST_VK
3027     case QRhi::Vulkan:
3028         window->setSurfaceType(QSurface::VulkanSurface);
3029         window->setVulkanInstance(&vulkanInstance);
3030         break;
3031 #endif
3032     default:
3033         break;
3034     }
3035 }
3036 
3037 void tst_QRhi::renderToTextureIndexedDraw_data()
3038 {
3039     rhiTestData();
3040 }
3041 
3042 void tst_QRhi::renderToTextureIndexedDraw()
3043 {
3044     QFETCH(QRhi::Implementation, impl);
3045     QFETCH(QRhiInitParams *, initParams);
3046 
3047     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3048     if (!rhi)
3049         QSKIP("QRhi could not be created, skipping testing rendering");
3050 
3051     const QSize outputSize(1920, 1080);
3052     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, outputSize, 1,
3053                                                         QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
3054     QVERIFY(texture->create());
3055 
3056     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
3057     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3058     rt->setRenderPassDescriptor(rpDesc.data());
3059     QVERIFY(rt->create());
3060 
3061     QRhiCommandBuffer *cb = nullptr;
3062     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
3063     QVERIFY(cb);
3064 
3065     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
3066 
3067     static const float vertices[] = {
3068         -1.0f, -1.0f,
3069         1.0f, -1.0f,
3070         0.0f, 1.0f
3071     };
3072     static const quint16 indices[] = {
3073         0, 1, 2
3074     };
3075 
3076     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
3077     QVERIFY(vbuf->create());
3078     updates->uploadStaticBuffer(vbuf.data(), vertices);
3079 
3080     QScopedPointer<QRhiBuffer> ibuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::IndexBuffer, sizeof(indices)));
3081     QVERIFY(ibuf->create());
3082     updates->uploadStaticBuffer(ibuf.data(), indices);
3083 
3084     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
3085     QVERIFY(srb->create());
3086 
3087     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
3088     QShader vs = loadShader(":/data/simple.vert.qsb");
3089     QVERIFY(vs.isValid());
3090     QShader fs = loadShader(":/data/simple.frag.qsb");
3091     QVERIFY(fs.isValid());
3092     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
3093     QRhiVertexInputLayout inputLayout;
3094     inputLayout.setBindings({ { 2 * sizeof(float) } });
3095     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
3096     pipeline->setVertexInputLayout(inputLayout);
3097     pipeline->setShaderResourceBindings(srb.data());
3098     pipeline->setRenderPassDescriptor(rpDesc.data());
3099 
3100     QVERIFY(pipeline->create());
3101 
3102     QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
3103 
3104     // Do three render passes, even though all render the same thing. This is done to
3105     // verify that QTBUG-89765 is fixed.  One of them specifies ExternalContent which
3106     // triggers special behavior with some backends (uses a secondary command buffer with
3107     // Vulkan for example). This way we can see that optimizations, such as keeping track
3108     // of what index buffer is active, are handled correctly across pass boundaries in the
3109     // QRhi backends. Without the fix for QTBUG-89765 this test would show validation
3110     // warnings and even crash when run with Vulkan.
3111 
3112     cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, updates);
3113     cb->setGraphicsPipeline(pipeline.data());
3114     cb->setViewport({ 0, 0, float(outputSize.width()), float(outputSize.height()) });
3115     cb->setVertexInput(0, 1, &vbindings, ibuf.data(), 0, QRhiCommandBuffer::IndexUInt16);
3116     cb->drawIndexed(3);
3117     cb->endPass();
3118 
3119     cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, nullptr, QRhiCommandBuffer::ExternalContent);
3120     cb->setGraphicsPipeline(pipeline.data());
3121     cb->setViewport({ 0, 0, float(outputSize.width()), float(outputSize.height()) });
3122     cb->setVertexInput(0, 1, &vbindings, ibuf.data(), 0, QRhiCommandBuffer::IndexUInt16);
3123     cb->drawIndexed(3);
3124     cb->endPass();
3125 
3126     cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, nullptr);
3127     cb->setGraphicsPipeline(pipeline.data());
3128     cb->setViewport({ 0, 0, float(outputSize.width()), float(outputSize.height()) });
3129     cb->setVertexInput(0, 1, &vbindings, ibuf.data(), 0, QRhiCommandBuffer::IndexUInt16);
3130     cb->drawIndexed(3);
3131 
3132     QRhiReadbackResult readResult;
3133     QImage result;
3134     readResult.completed = [&readResult, &result] {
3135         result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
3136                         readResult.pixelSize.width(), readResult.pixelSize.height(),
3137                         QImage::Format_RGBA8888_Premultiplied);
3138     };
3139     QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
3140     readbackBatch->readBackTexture({ texture.data() }, &readResult);
3141     cb->endPass(readbackBatch);
3142 
3143     rhi->endOffscreenFrame();
3144     QCOMPARE(result.size(), texture->pixelSize());
3145 
3146     if (impl == QRhi::Null)
3147         return;
3148 
3149     // Now we have a red rectangle on blue background.
3150     const int y = 100;
3151     const quint32 *p = reinterpret_cast<const quint32 *>(result.constScanLine(y));
3152     int x = result.width() - 1;
3153     int redCount = 0;
3154     int blueCount = 0;
3155     const int maxFuzz = 1;
3156     while (x-- >= 0) {
3157         const QRgb c(*p++);
3158         if (qRed(c) >= (255 - maxFuzz) && qGreen(c) == 0 && qBlue(c) == 0)
3159             ++redCount;
3160         else if (qRed(c) == 0 && qGreen(c) == 0 && qBlue(c) >= (255 - maxFuzz))
3161             ++blueCount;
3162         else
3163             QFAIL("Encountered a pixel that is neither red or blue");
3164     }
3165 
3166     QCOMPARE(redCount + blueCount, texture->pixelSize().width());
3167 
3168     if (rhi->isYUpInFramebuffer() == rhi->isYUpInNDC())
3169         QVERIFY(redCount < blueCount);
3170     else
3171         QVERIFY(redCount > blueCount);
3172 }
3173 
3174 void tst_QRhi::renderToWindowSimple_data()
3175 {
3176     rhiTestData();
3177 }
3178 
3179 void tst_QRhi::renderToWindowSimple()
3180 {
3181     if (QGuiApplication::platformName().startsWith(QLatin1String("offscreen"), Qt::CaseInsensitive))
3182         QSKIP("Offscreen: This fails.");
3183 
3184     QFETCH(QRhi::Implementation, impl);
3185     QFETCH(QRhiInitParams *, initParams);
3186 
3187     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3188     if (!rhi)
3189         QSKIP("QRhi could not be created, skipping testing rendering");
3190 
3191     QScopedPointer<QWindow> window(new QWindow);
3192     setWindowType(window.data(), impl);
3193 
3194     window->setGeometry(0, 0, 640, 480);
3195     window->show();
3196     QVERIFY(QTest::qWaitForWindowExposed(window.data()));
3197 
3198     QScopedPointer<QRhiSwapChain> swapChain(rhi->newSwapChain());
3199     swapChain->setWindow(window.data());
3200     swapChain->setFlags(QRhiSwapChain::UsedAsTransferSource);
3201     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(swapChain->newCompatibleRenderPassDescriptor());
3202     swapChain->setRenderPassDescriptor(rpDesc.data());
3203     QVERIFY(swapChain->createOrResize());
3204 
3205     QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
3206 
3207     static const float vertices[] = {
3208         -1.0f, -1.0f,
3209         1.0f, -1.0f,
3210         0.0f, 1.0f
3211     };
3212     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
3213     QVERIFY(vbuf->create());
3214     updates->uploadStaticBuffer(vbuf.data(), vertices);
3215 
3216     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
3217     QVERIFY(srb->create());
3218 
3219     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
3220     QShader vs = loadShader(":/data/simple.vert.qsb");
3221     QVERIFY(vs.isValid());
3222     QShader fs = loadShader(":/data/simple.frag.qsb");
3223     QVERIFY(fs.isValid());
3224     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
3225     QRhiVertexInputLayout inputLayout;
3226     inputLayout.setBindings({ { 2 * sizeof(float) } });
3227     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
3228     pipeline->setVertexInputLayout(inputLayout);
3229     pipeline->setShaderResourceBindings(srb.data());
3230     pipeline->setRenderPassDescriptor(rpDesc.data());
3231 
3232     QVERIFY(pipeline->create());
3233 
3234     const int asyncReadbackFrames = rhi->resourceLimit(QRhi::MaxAsyncReadbackFrames);
3235     // one frame issues the readback, then we do MaxAsyncReadbackFrames more to ensure the readback completes
3236     const int FRAME_COUNT = asyncReadbackFrames + 1;
3237     bool readCompleted = false;
3238     QRhiReadbackResult readResult;
3239     QImage result;
3240     int readbackWidth = 0;
3241 
3242     for (int frameNo = 0; frameNo < FRAME_COUNT; ++frameNo) {
3243         QVERIFY(rhi->beginFrame(swapChain.data()) == QRhi::FrameOpSuccess);
3244         QRhiCommandBuffer *cb = swapChain->currentFrameCommandBuffer();
3245         QRhiRenderTarget *rt = swapChain->currentFrameRenderTarget();
3246         const QSize outputSize = swapChain->currentPixelSize();
3247         QCOMPARE(rt->pixelSize(), outputSize);
3248         QRhiViewport viewport(0, 0, float(outputSize.width()), float(outputSize.height()));
3249 
3250         cb->beginPass(rt, Qt::blue, { 1.0f, 0 }, updates);
3251         updates = nullptr;
3252         cb->setGraphicsPipeline(pipeline.data());
3253         cb->setViewport(viewport);
3254         QRhiCommandBuffer::VertexInput vbindings(vbuf.data(), 0);
3255         cb->setVertexInput(0, 1, &vbindings);
3256         cb->draw(3);
3257 
3258         if (frameNo == 0) {
3259             readResult.completed = [&readCompleted, &readResult, &result, &rhi] {
3260                 readCompleted = true;
3261                 QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
3262                                     readResult.pixelSize.width(), readResult.pixelSize.height(),
3263                                     QImage::Format_ARGB32_Premultiplied);
3264                 if (readResult.format == QRhiTexture::RGBA8)
3265                     wrapperImage = wrapperImage.rgbSwapped();
3266                 if (rhi->isYUpInFramebuffer() == rhi->isYUpInNDC())
3267                     result = wrapperImage.mirrored();
3268                 else
3269                     result = wrapperImage.copy();
3270             };
3271             QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
3272             readbackBatch->readBackTexture({}, &readResult); // read back the current backbuffer
3273             readbackWidth = outputSize.width();
3274             cb->endPass(readbackBatch);
3275         } else {
3276             cb->endPass();
3277         }
3278 
3279         rhi->endFrame(swapChain.data());
3280     }
3281 
3282     // The readback is asynchronous here. However it is guaranteed that it
3283     // finished at latest after rendering QRhi::MaxAsyncReadbackFrames frames
3284     // after the one that enqueues the readback.
3285     QVERIFY(readCompleted);
3286     QVERIFY(readbackWidth > 0);
3287 
3288     if (impl == QRhi::Null)
3289         return;
3290 
3291     // Now we have a red rectangle on blue background.
3292     const int y = 50;
3293     const quint32 *p = reinterpret_cast<const quint32 *>(result.constScanLine(y));
3294     int x = result.width() - 1;
3295     int redCount = 0;
3296     int blueCount = 0;
3297     const int maxFuzz = 1;
3298     while (x-- >= 0) {
3299         const QRgb c(*p++);
3300         if (qRed(c) >= (255 - maxFuzz) && qGreen(c) == 0 && qBlue(c) == 0)
3301             ++redCount;
3302         else if (qRed(c) == 0 && qGreen(c) == 0 && qBlue(c) >= (255 - maxFuzz))
3303             ++blueCount;
3304         else
3305             QFAIL("Encountered a pixel that is neither red or blue");
3306     }
3307 
3308     QCOMPARE(redCount + blueCount, readbackWidth);
3309     QVERIFY(redCount < blueCount);
3310 }
3311 
3312 void tst_QRhi::finishWithinSwapchainFrame_data()
3313 {
3314     rhiTestData();
3315 }
3316 
3317 void tst_QRhi::finishWithinSwapchainFrame()
3318 {
3319     if (QGuiApplication::platformName().startsWith(QLatin1String("offscreen"), Qt::CaseInsensitive))
3320         QSKIP("Offscreen: This fails.");
3321 
3322     QFETCH(QRhi::Implementation, impl);
3323     QFETCH(QRhiInitParams *, initParams);
3324 
3325     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3326     if (!rhi)
3327         QSKIP("QRhi could not be created, skipping testing rendering");
3328 
3329     QScopedPointer<QWindow> window(new QWindow);
3330     setWindowType(window.data(), impl);
3331 
3332     window->setGeometry(0, 0, 640, 480);
3333     window->show();
3334     QVERIFY(QTest::qWaitForWindowExposed(window.data()));
3335 
3336     QScopedPointer<QRhiSwapChain> swapChain(rhi->newSwapChain());
3337     swapChain->setWindow(window.data());
3338     swapChain->setFlags(QRhiSwapChain::UsedAsTransferSource);
3339     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(swapChain->newCompatibleRenderPassDescriptor());
3340     swapChain->setRenderPassDescriptor(rpDesc.data());
3341     QVERIFY(swapChain->createOrResize());
3342 
3343     QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
3344     QVERIFY(srb->create());
3345 
3346     QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
3347     QShader vs = loadShader(":/data/simple.vert.qsb");
3348     QVERIFY(vs.isValid());
3349     QShader fs = loadShader(":/data/simple.frag.qsb");
3350     QVERIFY(fs.isValid());
3351     pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
3352     QRhiVertexInputLayout inputLayout;
3353     inputLayout.setBindings({ { 2 * sizeof(float) } });
3354     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
3355     pipeline->setVertexInputLayout(inputLayout);
3356     pipeline->setShaderResourceBindings(srb.data());
3357     pipeline->setRenderPassDescriptor(rpDesc.data());
3358     QVERIFY(pipeline->create());
3359 
3360     static const float vertices[] = {
3361         -1.0f, -1.0f,
3362         1.0f, -1.0f,
3363         0.0f, 1.0f
3364     };
3365     QScopedPointer<QRhiBuffer> vbuf(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, sizeof(vertices)));
3366     QVERIFY(vbuf->create());
3367 
3368     // exercise begin/endExternal() just a little bit, note ExternalContent for beginPass()
3369     QVERIFY(rhi->beginFrame(swapChain.data()) == QRhi::FrameOpSuccess);
3370     QRhiCommandBuffer *cb = swapChain->currentFrameCommandBuffer();
3371     QRhiRenderTarget *rt = swapChain->currentFrameRenderTarget();
3372     const QSize outputSize = swapChain->currentPixelSize();
3373 
3374     // repeat a sequence of upload, renderpass, readback, finish a number of
3375     // times within the same frame
3376     for (int i = 0; i < 5; ++i) {
3377         QRhiResourceUpdateBatch *updates = rhi->nextResourceUpdateBatch();
3378         updates->uploadStaticBuffer(vbuf.data(), vertices);
3379 
3380         cb->beginPass(rt, Qt::blue, { 1.0f, 0 }, updates, QRhiCommandBuffer::ExternalContent);
3381 
3382         // just have some commands, do not bother with draw calls
3383         cb->setGraphicsPipeline(pipeline.data());
3384         QRhiViewport viewport(0, 0, float(outputSize.width()), float(outputSize.height()));
3385         cb->setViewport(viewport);
3386 
3387         // do a dummy begin/endExternal round: interesting for Vulkan because
3388         // there this may start end then submit a secondary command buffer
3389         cb->beginExternal();
3390         cb->endExternal();
3391 
3392         cb->endPass();
3393 
3394         QRhiReadbackResult readResult;
3395         bool ok = false;
3396         readResult.completed = [&readResult, &ok, impl] {
3397             QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
3398                                 readResult.pixelSize.width(), readResult.pixelSize.height(),
3399                                 QImage::Format_ARGB32_Premultiplied);
3400             if (readResult.format == QRhiTexture::RGBA8)
3401                 wrapperImage = wrapperImage.rgbSwapped();
3402 
3403             if (impl != QRhi::Null)
3404                 ok = qBlue(wrapperImage.pixel(43, 89)) > 250;
3405             else
3406                 ok = true; // the Null backend does not actually render
3407         };
3408         QRhiResourceUpdateBatch *readbackBatch = rhi->nextResourceUpdateBatch();
3409         readbackBatch->readBackTexture({}, &readResult); // read back the current backbuffer
3410         cb->resourceUpdate(readbackBatch);
3411 
3412         // force submit what we have so far, wait for the queue, and then start
3413         // a new primary command buffer
3414         rhi->finish();
3415 
3416         QVERIFY(ok);
3417     }
3418 
3419     rhi->endFrame(swapChain.data());
3420 }
3421 
3422 void tst_QRhi::srbLayoutCompatibility_data()
3423 {
3424     rhiTestData();
3425 }
3426 
3427 void tst_QRhi::srbLayoutCompatibility()
3428 {
3429     QFETCH(QRhi::Implementation, impl);
3430     QFETCH(QRhiInitParams *, initParams);
3431 
3432     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3433     if (!rhi)
3434         QSKIP("QRhi could not be created, skipping testing texture resource updates");
3435 
3436     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512)));
3437     QVERIFY(texture->create());
3438     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
3439                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
3440     QVERIFY(sampler->create());
3441     QScopedPointer<QRhiSampler> otherSampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
3442                                                              QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
3443     QVERIFY(otherSampler->create());
3444     QScopedPointer<QRhiBuffer> buf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 1024));
3445     QVERIFY(buf->create());
3446     QScopedPointer<QRhiBuffer> otherBuf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 256));
3447     QVERIFY(otherBuf->create());
3448 
3449     // empty (compatible)
3450     {
3451         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3452         QVERIFY(srb1->create());
3453 
3454         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3455         QVERIFY(srb2->create());
3456 
3457         QVERIFY(srb1->isLayoutCompatible(srb2.data()));
3458         QVERIFY(srb2->isLayoutCompatible(srb1.data()));
3459 
3460         QCOMPARE(srb1->serializedLayoutDescription(), srb2->serializedLayoutDescription());
3461         QVERIFY(srb1->serializedLayoutDescription().count() == 0);
3462     }
3463 
3464     // different count (not compatible)
3465     {
3466         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3467         QVERIFY(srb1->create());
3468 
3469         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3470         srb2->setBindings({
3471                               QRhiShaderResourceBinding::sampledTexture(0, QRhiShaderResourceBinding::FragmentStage, texture.data(), sampler.data())
3472                          });
3473         QVERIFY(srb2->create());
3474 
3475         QVERIFY(!srb1->isLayoutCompatible(srb2.data()));
3476         QVERIFY(!srb2->isLayoutCompatible(srb1.data()));
3477 
3478         QVERIFY(srb1->serializedLayoutDescription() != srb2->serializedLayoutDescription());
3479         QVERIFY(srb1->serializedLayoutDescription().count() == 0);
3480         QVERIFY(srb2->serializedLayoutDescription().count() == 1 * QRhiShaderResourceBinding::LAYOUT_DESC_ENTRIES_PER_BINDING);
3481     }
3482 
3483     // full match (compatible)
3484     {
3485         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3486         srb1->setBindings({
3487                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data()),
3488                               QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture.data(), sampler.data())
3489                          });
3490         QVERIFY(srb1->create());
3491 
3492         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3493         srb2->setBindings({
3494                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data()),
3495                               QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture.data(), sampler.data())
3496                          });
3497         QVERIFY(srb2->create());
3498 
3499         QVERIFY(srb1->isLayoutCompatible(srb2.data()));
3500         QVERIFY(srb2->isLayoutCompatible(srb1.data()));
3501 
3502         QVERIFY(!srb1->serializedLayoutDescription().isEmpty());
3503         QVERIFY(!srb2->serializedLayoutDescription().isEmpty());
3504         QCOMPARE(srb1->serializedLayoutDescription(), srb2->serializedLayoutDescription());
3505         QVERIFY(srb1->serializedLayoutDescription().count() == 2 * QRhiShaderResourceBinding::LAYOUT_DESC_ENTRIES_PER_BINDING);
3506 
3507         // see what we would get if a binding list got serialized "manually", without pulling it out from the srb after building
3508         // (the results should be identical)
3509         QVector<quint32> layoutDesc1;
3510         QRhiShaderResourceBinding::serializeLayoutDescription(srb1->cbeginBindings(), srb1->cendBindings(), std::back_inserter(layoutDesc1));
3511         QCOMPARE(layoutDesc1, srb1->serializedLayoutDescription());
3512         QVector<quint32> layoutDesc2;
3513         QRhiShaderResourceBinding::serializeLayoutDescription(srb2->cbeginBindings(), srb2->cendBindings(), std::back_inserter(layoutDesc2));
3514         QCOMPARE(layoutDesc2, srb2->serializedLayoutDescription());
3515 
3516         // exercise with an "output iterator" different from back_inserter
3517         quint32 layoutDesc3[2 * QRhiShaderResourceBinding::LAYOUT_DESC_ENTRIES_PER_BINDING];
3518         QRhiShaderResourceBinding::serializeLayoutDescription(srb1->cbeginBindings(), srb1->cendBindings(), layoutDesc3);
3519         QVERIFY(!memcmp(layoutDesc3, layoutDesc1.constData(), sizeof(quint32) * 2 * QRhiShaderResourceBinding::LAYOUT_DESC_ENTRIES_PER_BINDING));
3520     }
3521 
3522     // different visibility (not compatible)
3523     {
3524         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3525         srb1->setBindings({
3526                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage | QRhiShaderResourceBinding::FragmentStage, buf.data()),
3527                          });
3528         QVERIFY(srb1->create());
3529 
3530         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3531         srb2->setBindings({
3532                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data()),
3533                          });
3534         QVERIFY(srb2->create());
3535 
3536         QVERIFY(!srb1->isLayoutCompatible(srb2.data()));
3537         QVERIFY(!srb2->isLayoutCompatible(srb1.data()));
3538 
3539         QVERIFY(srb1->serializedLayoutDescription() != srb2->serializedLayoutDescription());
3540     }
3541 
3542     // different binding points (not compatible)
3543     {
3544         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3545         srb1->setBindings({
3546                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data()),
3547                          });
3548         QVERIFY(srb1->create());
3549 
3550         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3551         srb2->setBindings({
3552                               QRhiShaderResourceBinding::uniformBuffer(1, QRhiShaderResourceBinding::VertexStage, buf.data()),
3553                          });
3554         QVERIFY(srb2->create());
3555 
3556         QVERIFY(!srb1->isLayoutCompatible(srb2.data()));
3557         QVERIFY(!srb2->isLayoutCompatible(srb1.data()));
3558 
3559         QVERIFY(srb1->serializedLayoutDescription() != srb2->serializedLayoutDescription());
3560     }
3561 
3562     // different buffer region offset and size (compatible)
3563     {
3564         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3565         srb1->setBindings({
3566                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data(), rhi->ubufAligned(1), 128),
3567                               QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture.data(), sampler.data())
3568                          });
3569         QVERIFY(srb1->create());
3570 
3571         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3572         srb2->setBindings({
3573                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data()),
3574                               QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture.data(), sampler.data())
3575                          });
3576         QVERIFY(srb2->create());
3577 
3578         QVERIFY(srb1->isLayoutCompatible(srb2.data()));
3579         QVERIFY(srb2->isLayoutCompatible(srb1.data()));
3580 
3581         QCOMPARE(srb1->serializedLayoutDescription(), srb2->serializedLayoutDescription());
3582     }
3583 
3584     // different resources (compatible)
3585     {
3586         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3587         srb1->setBindings({
3588                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, otherBuf.data()),
3589                               QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture.data(), otherSampler.data())
3590                          });
3591         QVERIFY(srb1->create());
3592 
3593         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3594         srb2->setBindings({
3595                               QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data()),
3596                               QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture.data(), sampler.data())
3597                          });
3598         QVERIFY(srb2->create());
3599 
3600         QVERIFY(srb1->isLayoutCompatible(srb2.data()));
3601         QVERIFY(srb2->isLayoutCompatible(srb1.data()));
3602 
3603         QCOMPARE(srb1->serializedLayoutDescription(), srb2->serializedLayoutDescription());
3604     }
3605 }
3606 
3607 void tst_QRhi::srbWithNoResource_data()
3608 {
3609     rhiTestData();
3610 }
3611 
3612 void tst_QRhi::srbWithNoResource()
3613 {
3614     QFETCH(QRhi::Implementation, impl);
3615     QFETCH(QRhiInitParams *, initParams);
3616 
3617     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3618     if (!rhi)
3619         QSKIP("QRhi could not be created, skipping testing srb");
3620 
3621     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512)));
3622     QVERIFY(texture->create());
3623     QScopedPointer<QRhiSampler> sampler(rhi->newSampler(QRhiSampler::Nearest, QRhiSampler::Nearest, QRhiSampler::None,
3624                                                         QRhiSampler::ClampToEdge, QRhiSampler::ClampToEdge));
3625     QVERIFY(sampler->create());
3626     QScopedPointer<QRhiBuffer> buf(rhi->newBuffer(QRhiBuffer::Dynamic, QRhiBuffer::UniformBuffer, 1024));
3627     QVERIFY(buf->create());
3628 
3629     {
3630         QScopedPointer<QRhiShaderResourceBindings> srb1(rhi->newShaderResourceBindings());
3631         srb1->setBindings({
3632                              QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, nullptr),
3633                              QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, nullptr, nullptr)
3634                          });
3635         QVERIFY(srb1->create());
3636 
3637         QScopedPointer<QRhiShaderResourceBindings> srb2(rhi->newShaderResourceBindings());
3638         srb2->setBindings({
3639                              QRhiShaderResourceBinding::uniformBuffer(0, QRhiShaderResourceBinding::VertexStage, buf.data()),
3640                              QRhiShaderResourceBinding::sampledTexture(1, QRhiShaderResourceBinding::FragmentStage, texture.data(), sampler.data())
3641                          });
3642         QVERIFY(srb2->create());
3643 
3644         QVERIFY(srb1->isLayoutCompatible(srb2.data()));
3645         QVERIFY(srb2->isLayoutCompatible(srb1.data()));
3646     }
3647 }
3648 
3649 void tst_QRhi::renderPassDescriptorCompatibility_data()
3650 {
3651     rhiTestData();
3652 }
3653 
3654 void tst_QRhi::renderPassDescriptorCompatibility()
3655 {
3656     QFETCH(QRhi::Implementation, impl);
3657     QFETCH(QRhiInitParams *, initParams);
3658 
3659     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3660     if (!rhi)
3661         QSKIP("QRhi could not be created, skipping testing renderpass descriptors");
3662 
3663     // Note that checking compatibility is only relevant with backends where
3664     // there is a concept of renderpass descriptions (Vulkan, and partially
3665     // Metal). It is perfectly fine for isCompatible() to always return true
3666     // when that is not the case (D3D11, OpenGL). Hence the 'if (Vulkan or
3667     // Metal)' for all the negative tests. Also note "partial" for Metal:
3668     // resolve textures for examples have no effect on compatibility with Metal.
3669 
3670     // tex and tex2 have the same format
3671     QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
3672     QVERIFY(tex->create());
3673     QScopedPointer<QRhiTexture> tex2(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
3674     QVERIFY(tex2->create());
3675 
3676     QScopedPointer<QRhiRenderBuffer> ds(rhi->newRenderBuffer(QRhiRenderBuffer::DepthStencil, QSize(512, 512)));
3677     QVERIFY(ds->create());
3678 
3679     // two texture rendertargets with tex and tex2 as color0 (compatible)
3680     {
3681         QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ tex.data() }));
3682         QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3683         rt->setRenderPassDescriptor(rpDesc.data());
3684         QVERIFY(rt->create());
3685 
3686         QScopedPointer<QRhiTextureRenderTarget> rt2(rhi->newTextureRenderTarget({ tex2.data() }));
3687         QScopedPointer<QRhiRenderPassDescriptor> rpDesc2(rt2->newCompatibleRenderPassDescriptor());
3688         rt2->setRenderPassDescriptor(rpDesc2.data());
3689         QVERIFY(rt2->create());
3690 
3691         QVERIFY(rpDesc->isCompatible(rpDesc2.data()));
3692         QVERIFY(rpDesc2->isCompatible(rpDesc.data()));
3693         QCOMPARE(rpDesc->serializedFormat(), rpDesc2->serializedFormat());
3694     }
3695 
3696     // two texture rendertargets with tex and tex2 as color0, and a depth-stencil attachment as well (compatible)
3697     {
3698         QRhiTextureRenderTargetDescription desc({ tex.data() }, ds.data());
3699         QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget(desc));
3700         QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3701         rt->setRenderPassDescriptor(rpDesc.data());
3702         QVERIFY(rt->create());
3703 
3704         QScopedPointer<QRhiTextureRenderTarget> rt2(rhi->newTextureRenderTarget(desc));
3705         QScopedPointer<QRhiRenderPassDescriptor> rpDesc2(rt2->newCompatibleRenderPassDescriptor());
3706         rt2->setRenderPassDescriptor(rpDesc2.data());
3707         QVERIFY(rt2->create());
3708 
3709         QVERIFY(rpDesc->isCompatible(rpDesc2.data()));
3710         QVERIFY(rpDesc2->isCompatible(rpDesc.data()));
3711         QCOMPARE(rpDesc->serializedFormat(), rpDesc2->serializedFormat());
3712     }
3713 
3714     // now one of them does not have the ds attachment (not compatible)
3715     {
3716         QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ { tex.data() }, ds.data() }));
3717         QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3718         rt->setRenderPassDescriptor(rpDesc.data());
3719         QVERIFY(rt->create());
3720 
3721         QScopedPointer<QRhiTextureRenderTarget> rt2(rhi->newTextureRenderTarget({ tex.data() }));
3722         QScopedPointer<QRhiRenderPassDescriptor> rpDesc2(rt2->newCompatibleRenderPassDescriptor());
3723         rt2->setRenderPassDescriptor(rpDesc2.data());
3724         QVERIFY(rt2->create());
3725 
3726         // these backends have a real concept of rp compatibility, with those we
3727         // know that incompatibility must be reported; verify this
3728         if (impl == QRhi::Vulkan || impl == QRhi::Metal) {
3729             QVERIFY(!rpDesc->isCompatible(rpDesc2.data()));
3730             QVERIFY(!rpDesc2->isCompatible(rpDesc.data()));
3731             QVERIFY(!rpDesc->serializedFormat().isEmpty());
3732             QVERIFY(rpDesc->serializedFormat() != rpDesc2->serializedFormat());
3733         }
3734     }
3735 
3736     if (rhi->isFeatureSupported(QRhi::MultisampleRenderBuffer)) {
3737         // resolve attachments (compatible)
3738         {
3739             QScopedPointer<QRhiRenderBuffer> msaaRenderBuffer(rhi->newRenderBuffer(QRhiRenderBuffer::Color, QSize(512, 512), 4));
3740             QVERIFY(msaaRenderBuffer->create());
3741             QScopedPointer<QRhiRenderBuffer> msaaRenderBuffer2(rhi->newRenderBuffer(QRhiRenderBuffer::Color, QSize(512, 512), 4));
3742             QVERIFY(msaaRenderBuffer2->create());
3743 
3744             QRhiColorAttachment colorAtt(msaaRenderBuffer.data()); // color0, multisample
3745             colorAtt.setResolveTexture(tex.data()); // resolved into a non-msaa texture
3746             QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ colorAtt }));
3747             QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3748             rt->setRenderPassDescriptor(rpDesc.data());
3749             QVERIFY(rt->create());
3750 
3751             QRhiColorAttachment colorAtt2(msaaRenderBuffer2.data()); // color0, multisample
3752             colorAtt2.setResolveTexture(tex2.data()); // resolved into a non-msaa texture
3753             QScopedPointer<QRhiTextureRenderTarget> rt2(rhi->newTextureRenderTarget({ colorAtt2 }));
3754             QScopedPointer<QRhiRenderPassDescriptor> rpDesc2(rt2->newCompatibleRenderPassDescriptor());
3755             rt2->setRenderPassDescriptor(rpDesc2.data());
3756             QVERIFY(rt2->create());
3757 
3758             QVERIFY(rpDesc->isCompatible(rpDesc2.data()));
3759             QVERIFY(rpDesc2->isCompatible(rpDesc.data()));
3760             QCOMPARE(rpDesc->serializedFormat(), rpDesc2->serializedFormat());
3761         }
3762 
3763         // missing resolve for one of them (not compatible)
3764         {
3765             QScopedPointer<QRhiRenderBuffer> msaaRenderBuffer(rhi->newRenderBuffer(QRhiRenderBuffer::Color, QSize(512, 512), 4));
3766             QVERIFY(msaaRenderBuffer->create());
3767             QScopedPointer<QRhiRenderBuffer> msaaRenderBuffer2(rhi->newRenderBuffer(QRhiRenderBuffer::Color, QSize(512, 512), 4));
3768             QVERIFY(msaaRenderBuffer2->create());
3769 
3770             QRhiColorAttachment colorAtt(msaaRenderBuffer.data()); // color0, multisample
3771             colorAtt.setResolveTexture(tex.data()); // resolved into a non-msaa texture
3772             QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ colorAtt }));
3773             QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3774             rt->setRenderPassDescriptor(rpDesc.data());
3775             QVERIFY(rt->create());
3776 
3777             QRhiColorAttachment colorAtt2(msaaRenderBuffer2.data()); // color0, multisample
3778             QScopedPointer<QRhiTextureRenderTarget> rt2(rhi->newTextureRenderTarget({ colorAtt2 }));
3779             QScopedPointer<QRhiRenderPassDescriptor> rpDesc2(rt2->newCompatibleRenderPassDescriptor());
3780             rt2->setRenderPassDescriptor(rpDesc2.data());
3781             QVERIFY(rt2->create());
3782 
3783             if (impl == QRhi::Vulkan) { // no Metal here
3784                 QVERIFY(!rpDesc->isCompatible(rpDesc2.data()));
3785                 QVERIFY(!rpDesc2->isCompatible(rpDesc.data()));
3786                 QVERIFY(!rpDesc->serializedFormat().isEmpty());
3787                 QVERIFY(rpDesc->serializedFormat() != rpDesc2->serializedFormat());
3788             }
3789         }
3790     } else {
3791         qDebug("Skipping multisample renderbuffer dependent tests");
3792     }
3793 
3794     if (rhi->isTextureFormatSupported(QRhiTexture::RGBA32F)) {
3795         QScopedPointer<QRhiTexture> tex3(rhi->newTexture(QRhiTexture::RGBA32F, QSize(512, 512), 1, QRhiTexture::RenderTarget));
3796         QVERIFY(tex3->create());
3797 
3798         // different texture formats (not compatible)
3799         {
3800             QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ tex.data() }));
3801             QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3802             rt->setRenderPassDescriptor(rpDesc.data());
3803             QVERIFY(rt->create());
3804 
3805             QScopedPointer<QRhiTextureRenderTarget> rt2(rhi->newTextureRenderTarget({ tex3.data() }));
3806             QScopedPointer<QRhiRenderPassDescriptor> rpDesc2(rt2->newCompatibleRenderPassDescriptor());
3807             rt2->setRenderPassDescriptor(rpDesc2.data());
3808             QVERIFY(rt2->create());
3809 
3810             if (impl == QRhi::Vulkan || impl == QRhi::Metal) {
3811                 QVERIFY(!rpDesc->isCompatible(rpDesc2.data()));
3812                 QVERIFY(!rpDesc2->isCompatible(rpDesc.data()));
3813                 QVERIFY(!rpDesc->serializedFormat().isEmpty());
3814                 QVERIFY(rpDesc->serializedFormat() != rpDesc2->serializedFormat());
3815             }
3816         }
3817     } else {
3818         qDebug("Skipping texture format dependent tests");
3819     }
3820 }
3821 
3822 void tst_QRhi::renderPassDescriptorClone_data()
3823 {
3824     rhiTestData();
3825 }
3826 
3827 void tst_QRhi::renderPassDescriptorClone()
3828 {
3829     QFETCH(QRhi::Implementation, impl);
3830     QFETCH(QRhiInitParams *, initParams);
3831 
3832     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3833     if (!rhi)
3834         QSKIP("QRhi could not be created, skipping testing renderpass descriptors");
3835 
3836     // tex and tex2 have the same format
3837     QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
3838     QVERIFY(tex->create());
3839     QScopedPointer<QRhiTexture> tex2(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
3840     QVERIFY(tex2->create());
3841 
3842     QScopedPointer<QRhiRenderBuffer> ds(rhi->newRenderBuffer(QRhiRenderBuffer::DepthStencil, QSize(512, 512)));
3843     QVERIFY(ds->create());
3844 
3845     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ tex.data() }));
3846     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3847     rt->setRenderPassDescriptor(rpDesc.data());
3848     QVERIFY(rt->create());
3849 
3850     QScopedPointer<QRhiRenderPassDescriptor> rpDescClone(rpDesc->newCompatibleRenderPassDescriptor());
3851     QVERIFY(rpDescClone);
3852     QVERIFY(rpDesc->isCompatible(rpDescClone.data()));
3853 
3854     // rt and rt2 have the same set of attachments
3855     QScopedPointer<QRhiTextureRenderTarget> rt2(rhi->newTextureRenderTarget({ tex2.data() }));
3856     QScopedPointer<QRhiRenderPassDescriptor> rpDesc2(rt2->newCompatibleRenderPassDescriptor());
3857     rt2->setRenderPassDescriptor(rpDesc2.data());
3858     QVERIFY(rt2->create());
3859 
3860     QVERIFY(rpDesc2->isCompatible(rpDescClone.data()));
3861 }
3862 
3863 void tst_QRhi::pipelineCache_data()
3864 {
3865     rhiTestData();
3866 }
3867 
3868 void tst_QRhi::pipelineCache()
3869 {
3870     QFETCH(QRhi::Implementation, impl);
3871     QFETCH(QRhiInitParams *, initParams);
3872 
3873     QByteArray pcd;
3874     QShader vs = loadShader(":/data/simple.vert.qsb");
3875     QVERIFY(vs.isValid());
3876     QShader fs = loadShader(":/data/simple.frag.qsb");
3877     QVERIFY(fs.isValid());
3878     QRhiVertexInputLayout inputLayout;
3879     inputLayout.setBindings({ { 2 * sizeof(float) } });
3880     inputLayout.setAttributes({ { 0, 0, QRhiVertexInputAttribute::Float2, 0 } });
3881 
3882     {
3883         QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::EnablePipelineCacheDataSave));
3884         if (!rhi)
3885             QSKIP("QRhi could not be created, skipping testing (set)pipelineCacheData()");
3886 
3887         if (!rhi->isFeatureSupported(QRhi::PipelineCacheDataLoadSave))
3888             QSKIP("PipelineCacheDataLoadSave is not supported with this backend, skipping test");
3889 
3890         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(256, 256), 1, QRhiTexture::RenderTarget));
3891         QVERIFY(texture->create());
3892         QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
3893         QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3894         rt->setRenderPassDescriptor(rpDesc.data());
3895         QVERIFY(rt->create());
3896         QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
3897         QVERIFY(srb->create());
3898         QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
3899         pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
3900         pipeline->setVertexInputLayout(inputLayout);
3901         pipeline->setShaderResourceBindings(srb.data());
3902         pipeline->setRenderPassDescriptor(rpDesc.data());
3903         QVERIFY(pipeline->create());
3904 
3905         // This cannot be more than a basic smoketest: ensure that passing
3906         // in the data we retrieve still gives us successful pipeline
3907         // creation. What happens internally we cannot check.
3908         pcd = rhi->pipelineCacheData();
3909         rhi->setPipelineCacheData(pcd);
3910         QVERIFY(pipeline->create());
3911     }
3912 
3913     {
3914         // Now from scratch, with seeding the cache right from the start,
3915         // presumably leading to a cache hit when creating the pipeline.
3916         QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::EnablePipelineCacheDataSave));
3917         QVERIFY(rhi);
3918         rhi->setPipelineCacheData(pcd);
3919 
3920         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(256, 256), 1, QRhiTexture::RenderTarget));
3921         QVERIFY(texture->create());
3922         QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
3923         QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
3924         rt->setRenderPassDescriptor(rpDesc.data());
3925         QVERIFY(rt->create());
3926         QScopedPointer<QRhiShaderResourceBindings> srb(rhi->newShaderResourceBindings());
3927         QVERIFY(srb->create());
3928         QScopedPointer<QRhiGraphicsPipeline> pipeline(rhi->newGraphicsPipeline());
3929         pipeline->setShaderStages({ { QRhiShaderStage::Vertex, vs }, { QRhiShaderStage::Fragment, fs } });
3930         pipeline->setVertexInputLayout(inputLayout);
3931         pipeline->setShaderResourceBindings(srb.data());
3932         pipeline->setRenderPassDescriptor(rpDesc.data());
3933         QVERIFY(pipeline->create());
3934     }
3935 }
3936 
3937 void tst_QRhi::textureImportOpenGL_data()
3938 {
3939     rhiTestDataOpenGL();
3940 }
3941 
3942 void tst_QRhi::textureImportOpenGL()
3943 {
3944     QFETCH(QRhi::Implementation, impl);
3945     if (impl != QRhi::OpenGLES2)
3946         QSKIP("Skipping OpenGL-dependent test");
3947 
3948 #ifdef TST_GL
3949     QFETCH(QRhiInitParams *, initParams);
3950 
3951     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
3952     if (!rhi)
3953         QSKIP("QRhi could not be created, skipping testing native texture");
3954 
3955     QVERIFY(rhi->makeThreadLocalNativeContextCurrent());
3956     QOpenGLContext *ctx = QOpenGLContext::currentContext();
3957     QVERIFY(ctx);
3958     QOpenGLFunctions *f = ctx->functions();
3959 
3960     QImage image(320, 200, QImage::Format_RGBA8888_Premultiplied);
3961     image.fill(Qt::red);
3962 
3963     GLuint t = 0;
3964     f->glGenTextures(1, &t);
3965     f->glBindTexture(GL_TEXTURE_2D, t);
3966     f->glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image.width(), image.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, image.constBits());
3967 
3968     QScopedPointer<QRhiTexture> tex(rhi->newTexture(QRhiTexture::RGBA8, image.size()));
3969     QRhiTexture::NativeTexture nativeTex = { t, 0 };
3970     QVERIFY(tex->createFrom(nativeTex));
3971     QCOMPARE(tex->nativeTexture().object, nativeTex.object);
3972 
3973     QRhiReadbackResult readResult;
3974     bool readCompleted = false;
3975     readResult.completed = [&readCompleted] { readCompleted = true; };
3976     QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
3977     batch->readBackTexture(tex.data(), &readResult);
3978     QVERIFY(submitResourceUpdates(rhi.data(), batch));
3979     QVERIFY(readCompleted);
3980     QCOMPARE(readResult.format, QRhiTexture::RGBA8);
3981     QCOMPARE(readResult.pixelSize, image.size());
3982     QImage wrapperImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
3983                         readResult.pixelSize.width(), readResult.pixelSize.height(),
3984                         image.format());
3985     QVERIFY(imageRGBAEquals(image, wrapperImage));
3986 
3987     f->glDeleteTextures(1, &t);
3988 #endif
3989 }
3990 
3991 void tst_QRhi::renderbufferImportOpenGL_data()
3992 {
3993     rhiTestDataOpenGL();
3994 }
3995 
3996 void tst_QRhi::renderbufferImportOpenGL()
3997 {
3998     QFETCH(QRhi::Implementation, impl);
3999     if (impl != QRhi::OpenGLES2)
4000         QSKIP("Skipping OpenGL-dependent test");
4001 
4002 #ifdef TST_GL
4003     QFETCH(QRhiInitParams *, initParams);
4004 
4005     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams, QRhi::Flags(), nullptr));
4006     if (!rhi)
4007         QSKIP("QRhi could not be created, skipping testing native texture");
4008 
4009     QVERIFY(rhi->makeThreadLocalNativeContextCurrent());
4010     QOpenGLContext *ctx = QOpenGLContext::currentContext();
4011     QVERIFY(ctx);
4012     QOpenGLFunctions *f = ctx->functions();
4013 
4014     const QSize size(320, 200);
4015     GLuint b = 0;
4016     f->glGenRenderbuffers(1, &b);
4017     f->glBindRenderbuffer(GL_RENDERBUFFER, b);
4018     // in a real world use case this would be some extension, e.g. glEGLImageTargetRenderbufferStorageOES instead
4019     f->glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA4, size.width(), size.height());
4020     f->glBindRenderbuffer(GL_RENDERBUFFER, 0);
4021 
4022     QScopedPointer<QRhiRenderBuffer> rb(rhi->newRenderBuffer(QRhiRenderBuffer::Color, size));
4023     QVERIFY(rb->createFrom({ b }));
4024 
4025     QScopedPointer<QRhiRenderBuffer> depthStencil(rhi->newRenderBuffer(QRhiRenderBuffer::DepthStencil, size));
4026     QVERIFY(depthStencil->create());
4027     QRhiColorAttachment att(rb.data());
4028     QRhiTextureRenderTargetDescription rtDesc(att);
4029     rtDesc.setDepthStencilBuffer(depthStencil.data());
4030     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget(rtDesc));
4031     QScopedPointer<QRhiRenderPassDescriptor> rp(rt->newCompatibleRenderPassDescriptor());
4032     rt->setRenderPassDescriptor(rp.data());
4033     QVERIFY(rt->create());
4034 
4035     QRhiCommandBuffer *cb = nullptr;
4036     QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
4037     QVERIFY(cb);
4038     cb->beginPass(rt.data(), Qt::red, { 1.0f, 0 }, nullptr, QRhiCommandBuffer::ExternalContent);
4039     cb->beginExternal();
4040     QByteArray tmpBuf;
4041     tmpBuf.resize(size.width() * size.height() * 4);
4042     f->glReadPixels(0, 0, size.width(), size.height(), GL_RGBA, GL_UNSIGNED_BYTE, tmpBuf.data());
4043     cb->endExternal();
4044     cb->endPass();
4045     rhi->endOffscreenFrame();
4046 
4047     f->glDeleteRenderbuffers(1, &b);
4048 
4049     QImage wrapperImage(reinterpret_cast<const uchar *>(tmpBuf.constData()),
4050                         size.width(), size.height(), QImage::Format_RGBA8888_Premultiplied);
4051 
4052     QImage image(320, 200, QImage::Format_RGBA8888_Premultiplied);
4053     image.fill(Qt::red);
4054     QVERIFY(imageRGBAEquals(image, wrapperImage));
4055 #endif
4056 }
4057 
4058 void tst_QRhi::threeDimTexture_data()
4059 {
4060     rhiTestData();
4061 }
4062 
4063 void tst_QRhi::threeDimTexture()
4064 {
4065     QFETCH(QRhi::Implementation, impl);
4066     QFETCH(QRhiInitParams *, initParams);
4067 
4068     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams));
4069     if (!rhi)
4070         QSKIP("QRhi could not be created, skipping testing 3D textures");
4071 
4072     if (!rhi->isFeatureSupported(QRhi::ThreeDimensionalTextures))
4073         QSKIP("Skipping testing 3D textures because they are reported as unsupported");
4074 
4075     const int WIDTH = 512;
4076     const int HEIGHT = 256;
4077     const int DEPTH = 128;
4078 
4079     {
4080         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, WIDTH, HEIGHT, DEPTH));
4081         QVERIFY(texture->create());
4082 
4083         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
4084         QVERIFY(batch);
4085 
4086         for (int i = 0; i < DEPTH; ++i) {
4087             QImage img(WIDTH, HEIGHT, QImage::Format_RGBA8888);
4088             img.fill(QColor::fromRgb(i * 2, 0, 0));
4089             QRhiTextureUploadEntry sliceUpload(i, 0, QRhiTextureSubresourceUploadDescription(img));
4090             batch->uploadTexture(texture.data(), sliceUpload);
4091         }
4092 
4093         QVERIFY(submitResourceUpdates(rhi.data(), batch));
4094     }
4095 
4096     // mipmaps
4097     {
4098         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, WIDTH, HEIGHT, DEPTH,
4099                                                             1, QRhiTexture::MipMapped | QRhiTexture::UsedWithGenerateMips));
4100         QVERIFY(texture->create());
4101 
4102         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
4103         QVERIFY(batch);
4104 
4105         for (int i = 0; i < DEPTH; ++i) {
4106             QImage img(WIDTH, HEIGHT, QImage::Format_RGBA8888);
4107             img.fill(QColor::fromRgb(i * 2, 0, 0));
4108             QRhiTextureUploadEntry sliceUpload(i, 0, QRhiTextureSubresourceUploadDescription(img));
4109             batch->uploadTexture(texture.data(), sliceUpload);
4110         }
4111 
4112         batch->generateMips(texture.data());
4113 
4114         QVERIFY(submitResourceUpdates(rhi.data(), batch));
4115 
4116         // read back slice 63 of level 1 (256x128, almost red)
4117         batch = rhi->nextResourceUpdateBatch();
4118         QRhiReadbackResult readResult;
4119         QImage result;
4120         readResult.completed = [&readResult, &result] {
4121             result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
4122                             readResult.pixelSize.width(), readResult.pixelSize.height(),
4123                             QImage::Format_RGBA8888);
4124         };
4125         QRhiReadbackDescription readbackDescription(texture.data());
4126         readbackDescription.setLevel(1);
4127         readbackDescription.setLayer(63);
4128         batch->readBackTexture(readbackDescription, &readResult);
4129         QVERIFY(submitResourceUpdates(rhi.data(), batch));
4130         QVERIFY(!result.isNull());
4131         QImage referenceImage(WIDTH / 2, HEIGHT / 2, result.format());
4132         referenceImage.fill(QColor::fromRgb(253, 0, 0));
4133 
4134         // Now restrict the test a bit. The Null QRhi backend has broken support for
4135         // mipmap generation of 3D textures (it ignores the depth, effectively behaving as
4136         // if the 3D texture was a 2D array which is incorrect wrt mipmapping)
4137         // Some software-based OpenGL implementations, such as Mesa llvmpipe builds that are
4138         // used both in Qt CI and are shipped with the official Qt binaries also seem to have
4139         // problems with this.
4140         if (impl != QRhi::Null && impl != QRhi::OpenGLES2)
4141             QVERIFY(imageRGBAEquals(result, referenceImage, 2));
4142     }
4143 
4144     // render target (one slice)
4145     // NB with Vulkan we require Vulkan 1.1 for this to work.
4146     {
4147         const int SLICE = 23;
4148         QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, WIDTH, HEIGHT, DEPTH,
4149                                                             1, QRhiTexture::RenderTarget | QRhiTexture::UsedAsTransferSource));
4150         QVERIFY(texture->create());
4151 
4152         QRhiColorAttachment att(texture.data());
4153         att.setLayer(SLICE);
4154         QRhiTextureRenderTargetDescription rtDesc(att);
4155         QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget(rtDesc));
4156         QScopedPointer<QRhiRenderPassDescriptor> rp(rt->newCompatibleRenderPassDescriptor());
4157         rt->setRenderPassDescriptor(rp.data());
4158         QVERIFY(rt->create());
4159 
4160         QRhiResourceUpdateBatch *batch = rhi->nextResourceUpdateBatch();
4161         QVERIFY(batch);
4162 
4163         for (int i = 0; i < DEPTH; ++i) {
4164             QImage img(WIDTH, HEIGHT, QImage::Format_RGBA8888);
4165             img.fill(QColor::fromRgb(i * 2, 0, 0));
4166             QRhiTextureUploadEntry sliceUpload(i, 0, QRhiTextureSubresourceUploadDescription(img));
4167             batch->uploadTexture(texture.data(), sliceUpload);
4168         }
4169 
4170         QRhiCommandBuffer *cb = nullptr;
4171         QVERIFY(rhi->beginOffscreenFrame(&cb) == QRhi::FrameOpSuccess);
4172         QVERIFY(cb);
4173         cb->beginPass(rt.data(), Qt::blue, { 1.0f, 0 }, batch);
4174         // slice 23 is now blue
4175         cb->endPass();
4176         rhi->endOffscreenFrame();
4177 
4178         // read back slice 23 (blue)
4179         batch = rhi->nextResourceUpdateBatch();
4180         QRhiReadbackResult readResult;
4181         QImage result;
4182         readResult.completed = [&readResult, &result] {
4183             result = QImage(reinterpret_cast<const uchar *>(readResult.data.constData()),
4184                             readResult.pixelSize.width(), readResult.pixelSize.height(),
4185                             QImage::Format_RGBA8888);
4186         };
4187         QRhiReadbackDescription readbackDescription(texture.data());
4188         readbackDescription.setLayer(23);
4189         batch->readBackTexture(readbackDescription, &readResult);
4190         QVERIFY(submitResourceUpdates(rhi.data(), batch));
4191         QVERIFY(!result.isNull());
4192         QImage referenceImage(WIDTH, HEIGHT, result.format());
4193         referenceImage.fill(QColor::fromRgbF(0.0f, 0.0f, 1.0f));
4194         // the Null backend does not render so skip the verification for that
4195         if (impl != QRhi::Null)
4196             QVERIFY(imageRGBAEquals(result, referenceImage));
4197 
4198         // read back slice 0 (black)
4199         batch = rhi->nextResourceUpdateBatch();
4200         result = QImage();
4201         readbackDescription.setLayer(0);
4202         batch->readBackTexture(readbackDescription, &readResult);
4203         QVERIFY(submitResourceUpdates(rhi.data(), batch));
4204         QVERIFY(!result.isNull());
4205         referenceImage.fill(QColor::fromRgbF(0.0f, 0.0f, 0.0f));
4206         QVERIFY(imageRGBAEquals(result, referenceImage));
4207 
4208         // read back slice 127 (almost red)
4209         batch = rhi->nextResourceUpdateBatch();
4210         result = QImage();
4211         readbackDescription.setLayer(127);
4212         batch->readBackTexture(readbackDescription, &readResult);
4213         QVERIFY(submitResourceUpdates(rhi.data(), batch));
4214         QVERIFY(!result.isNull());
4215         referenceImage.fill(QColor::fromRgb(254, 0, 0));
4216         QVERIFY(imageRGBAEquals(result, referenceImage));
4217     }
4218 }
4219 
4220 void tst_QRhi::leakedResourceDestroy_data()
4221 {
4222     rhiTestData();
4223 }
4224 
4225 void tst_QRhi::leakedResourceDestroy()
4226 {
4227     QFETCH(QRhi::Implementation, impl);
4228     QFETCH(QRhiInitParams *, initParams);
4229 
4230     QScopedPointer<QRhi> rhi(QRhi::create(impl, initParams));
4231     if (!rhi)
4232         QSKIP("QRhi could not be created, skipping");
4233 
4234     // Incorrectly destroy the QRhi before the resources created from it.  Attempting to
4235     // destroy the resources afterwards is pointless, the native resources are leaked.
4236     // Nonetheless, it should not crash, which is what we are testing here.
4237     //
4238     // We do not however have control over other, native and 3rd party components: a
4239     // validation or debug layer, or a memory allocator may warn, assert, or abort when
4240     // not releasing all native resources correctly.
4241 #ifndef QT_NO_DEBUG
4242     // don't want asserts from vkmemalloc, skip the test in debug builds
4243     if (impl == QRhi::Vulkan)
4244         QSKIP("Skipping leaked resource destroy test due to Vulkan and debug build");
4245 #endif
4246 
4247     QScopedPointer<QRhiBuffer> buffer(rhi->newBuffer(QRhiBuffer::Immutable, QRhiBuffer::VertexBuffer, 256));
4248     QVERIFY(buffer->create());
4249 
4250     QScopedPointer<QRhiTexture> texture(rhi->newTexture(QRhiTexture::RGBA8, QSize(512, 512), 1, QRhiTexture::RenderTarget));
4251     QVERIFY(texture->create());
4252 
4253     QScopedPointer<QRhiTextureRenderTarget> rt(rhi->newTextureRenderTarget({ texture.data() }));
4254     QScopedPointer<QRhiRenderPassDescriptor> rpDesc(rt->newCompatibleRenderPassDescriptor());
4255     QVERIFY(rpDesc);
4256     rt->setRenderPassDescriptor(rpDesc.data());
4257     QVERIFY(rt->create());
4258 
4259     if (impl == QRhi::Vulkan)
4260         qDebug("Vulkan validation layer warnings may be printed below - this is expected");
4261 
4262     rhi.reset();
4263 
4264     // let the scoped ptr do its job with the resources
4265 }
4266 
4267 #include <tst_qrhi.moc>
4268 QTEST_MAIN(tst_QRhi)
