I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the test suite of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:GPL-EXCEPT$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
22 ** included in the packaging of this file. Please review the following
23 ** information to ensure the GNU General Public License requirements will
24 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
25 **
26 ** $QT_END_LICENSE$
27 **
28 ****************************************************************************/
29 
30 
31 #include <QtTest/QtTest>
32 
33 #include <qcoreapplication.h>
34 #include <qfileinfo.h>
35 #include <qdatastream.h>
36 #include <qdebug.h>
37 #include <qudpsocket.h>
38 #include <qhostaddress.h>
39 #include <qhostinfo.h>
40 #include <qtcpsocket.h>
41 #include <qmap.h>
42 #include <qnetworkdatagram.h>
43 #include <QNetworkProxy>
44 #include <QNetworkInterface>
45 
46 #include <qstringlist.h>
47 #include "../../../network-settings.h"
48 
49 #ifndef QT_NO_BEARERMANAGEMENT
50 #include <QtNetwork/qnetworkconfigmanager.h>
51 #include <QtNetwork/qnetworkconfiguration.h>
52 #include <QtNetwork/qnetworksession.h>
53 #endif
54 
55 #if defined(Q_OS_LINUX) && defined(Q_PROCESSOR_ARM)
56 #define SHOULD_CHECK_SYSCALL_SUPPORT
57 #include "emulationdetector.h"
58 #include <netinet/in.h>
59 #include <sys/socket.h>
60 #include <errno.h>
61 #include <asm-generic/errno.h>
62 #endif
63 
64 Q_DECLARE_METATYPE(QHostAddress)
65 
66 QT_FORWARD_DECLARE_CLASS(QUdpSocket)
67 
68 class tst_QUdpSocket : public QObject
69 {
70     Q_OBJECT
71 
72 private slots:
73     void initTestCase_data();
74     void initTestCase();
75     void init();
76     void cleanup();
77     void constructing();
78     void unconnectedServerAndClientTest();
79     void broadcasting();
80     void loop_data();
81     void loop();
82     void ipv6Loop_data();
83     void ipv6Loop();
84     void dualStack();
85     void dualStackAutoBinding();
86     void dualStackNoIPv4onV6only();
87     void connectToHost();
88     void bindAndConnectToHost();
89     void pendingDatagramSize();
90     void writeDatagram();
91     void performance();
92     void bindMode();
93     void writeDatagramToNonExistingPeer_data();
94     void writeDatagramToNonExistingPeer();
95     void writeToNonExistingPeer_data();
96     void writeToNonExistingPeer();
97     void outOfProcessConnectedClientServerTest();
98     void outOfProcessUnconnectedClientServerTest();
99     void zeroLengthDatagram();
100     void multicastTtlOption_data();
101     void multicastTtlOption();
102     void multicastLoopbackOption_data();
103     void multicastLoopbackOption();
104     void multicastJoinBeforeBind_data();
105     void multicastJoinBeforeBind();
106     void multicastLeaveAfterClose_data();
107     void multicastLeaveAfterClose();
108     void setMulticastInterface_data();
109     void setMulticastInterface();
110     void multicast_data();
111     void multicast();
112     void echo_data();
113     void echo();
114     void linkLocalIPv6();
115     void linkLocalIPv4();
116     void readyRead();
117     void readyReadForEmptyDatagram();
118     void asyncReadDatagram();
119     void writeInHostLookupState();
120 
121 protected slots:
122     void empty_readyReadSlot();
123     void empty_connectedSlot();
124     void async_readDatagramSlot();
125 
126 private:
127     bool shouldSkipIPv6TestOnEmulation();
128 #ifdef SHOULD_CHECK_SYSCALL_SUPPORT
129     bool ipv6SetsockoptionMissing(int level, int optname);
130 #endif
131 
132     bool m_skipUnsupportedIPv6Tests;
133     QList<QHostAddress> allAddresses;
134 #ifndef QT_NO_BEARERMANAGEMENT
135     QNetworkConfigurationManager *netConfMan;
136     QNetworkConfiguration networkConfiguration;
137     QSharedPointer<QNetworkSession> networkSession;
138 #endif
139     QUdpSocket *m_asyncSender;
140     QUdpSocket *m_asyncReceiver;
141 };
142 
143 #ifdef SHOULD_CHECK_SYSCALL_SUPPORT
144 bool tst_QUdpSocket::ipv6SetsockoptionMissing(int level, int optname)
145 {
146     int testSocket;
147 
148     testSocket = socket(PF_INET6, SOCK_DGRAM, 0);
149 
150     // If we can't test here, assume it's not missing
151     if (testSocket == -1)
152         return false;
153 
154     if (setsockopt(testSocket, level, optname, 0, 0) == -1)
155         if (errno == ENOPROTOOPT)
156             return true;
157 
158     close(testSocket);
159     return false;
160 }
161 #endif //SHOULD_CHECK_SYSCALL_SUPPORT
162 
163 bool tst_QUdpSocket::shouldSkipIPv6TestOnEmulation()
164 {
165 #ifdef SHOULD_CHECK_SYSCALL_SUPPORT
166     // If we are not running on an emulator, tests should not be skipped
167     if (!EmulationDetector::isRunningArmOnX86())
168         return false;
169 
170     if (ipv6SetsockoptionMissing(SOL_IPV6, IPV6_JOIN_GROUP)
171         || ipv6SetsockoptionMissing(SOL_IPV6, IPV6_MULTICAST_HOPS)
172         || ipv6SetsockoptionMissing(SOL_IPV6, IPV6_MULTICAST_IF)
173         || ipv6SetsockoptionMissing(SOL_IPV6, IPV6_MULTICAST_LOOP)
174         || ipv6SetsockoptionMissing(SOL_IPV6, IPV6_RECVHOPLIMIT)) {
175         return true;
176     }
177 #endif //SHOULD_CHECK_SYSCALL_SUPPORT
178 
179     return false;
180 }
181 
182 static QHostAddress makeNonAny(const QHostAddress &address, QHostAddress::SpecialAddress preferForAny = QHostAddress::LocalHost)
183 {
184     if (address == QHostAddress::Any)
185         return preferForAny;
186     if (address == QHostAddress::AnyIPv4)
187         return QHostAddress::LocalHost;
188     if (address == QHostAddress::AnyIPv6)
189         return QHostAddress::LocalHostIPv6;
190     return address;
191 }
192 
193 void tst_QUdpSocket::initTestCase_data()
194 {
195     // hack: we only enable the Socks5 over UDP tests on the old
196     // test server, because they fail on the new one. See QTBUG-35490
197     bool newTestServer = true;
198     QTcpSocket socket;
199     socket.connectToHost(QtNetworkSettings::serverName(), 22);
200     if (socket.waitForConnected(10000)) {
201         socket.waitForReadyRead(5000);
202         QByteArray ba = socket.readAll();
203         if (ba.startsWith("SSH-2.0-OpenSSH_5.8p1"))
204             newTestServer = false;
205         socket.disconnectFromHost();
206     }
207 
208     QTest::addColumn<bool>("setProxy");
209     QTest::addColumn<int>("proxyType");
210 
211     QTest::newRow("WithoutProxy") << false << 0;
212 #ifndef QT_NO_SOCKS5
213     if (!newTestServer)
214         QTest::newRow("WithSocks5Proxy") << true << int(QNetworkProxy::Socks5Proxy);
215 #endif
216 
217 #ifndef QT_NO_BEARERMANAGEMENT
218     netConfMan = new QNetworkConfigurationManager(this);
219     networkConfiguration = netConfMan->defaultConfiguration();
220     networkSession = QSharedPointer<QNetworkSession>(new QNetworkSession(networkConfiguration));
221     if (!networkSession->isOpen()) {
222         networkSession->open();
223         QVERIFY(networkSession->waitForOpened(30000));
224     }
225 #endif
226 }
227 
228 void tst_QUdpSocket::initTestCase()
229 {
230     if (!QtNetworkSettings::verifyTestNetworkSettings())
231         QSKIP("No network test server available");
232     allAddresses = QNetworkInterface::allAddresses();
233     m_skipUnsupportedIPv6Tests = shouldSkipIPv6TestOnEmulation();
234 }
235 
236 void tst_QUdpSocket::init()
237 {
238     QFETCH_GLOBAL(bool, setProxy);
239     if (setProxy) {
240 #ifndef QT_NO_SOCKS5
241         QFETCH_GLOBAL(int, proxyType);
242         if (proxyType == QNetworkProxy::Socks5Proxy) {
243             QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::Socks5Proxy, QtNetworkSettings::serverName(), 1080));
244         }
245 #else
246         QSKIP("No proxy support");
247 #endif // !QT_NO_SOCKS5
248     }
249 }
250 
251 void tst_QUdpSocket::cleanup()
252 {
253 #ifndef QT_NO_NETWORKPROXY
254         QNetworkProxy::setApplicationProxy(QNetworkProxy::DefaultProxy);
255 #endif // !QT_NO_NETWORKPROXY
256 }
257 
258 
259 //----------------------------------------------------------------------------------
260 
261 void tst_QUdpSocket::constructing()
262 {
263     QUdpSocket socket;
264 #ifdef FORCE_SESSION
265     socket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
266 #endif
267 
268     QVERIFY(socket.isSequential());
269     QVERIFY(!socket.isOpen());
270     QCOMPARE(socket.socketType(), QUdpSocket::UdpSocket);
271     QCOMPARE((int) socket.bytesAvailable(), 0);
272     QCOMPARE(socket.canReadLine(), false);
273     QCOMPARE(socket.readLine(), QByteArray());
274     QCOMPARE(socket.socketDescriptor(), (qintptr)-1);
275     QCOMPARE(socket.error(), QUdpSocket::UnknownSocketError);
276     QCOMPARE(socket.errorString(), QString("Unknown error"));
277 
278     // Check the state of the socket api
279 }
280 
281 void tst_QUdpSocket::unconnectedServerAndClientTest()
282 {
283     QUdpSocket serverSocket;
284 #ifdef FORCE_SESSION
285     serverSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
286 #endif
287 
288     qRegisterMetaType<QAbstractSocket::SocketState>("QAbstractSocket::SocketState");
289 
290     QSignalSpy stateChangedSpy(&serverSocket, SIGNAL(stateChanged(QAbstractSocket::SocketState)));
291     QVERIFY2(serverSocket.bind(), serverSocket.errorString().toLatin1().constData());
292     QCOMPARE(stateChangedSpy.count(), 1);
293 
294     const char *message[] = {"Yo mista", "Yo", "Wassap"};
295 
296     QHostAddress serverAddress = makeNonAny(serverSocket.localAddress());
297     for (int i = 0; i < 3; ++i) {
298         QUdpSocket clientSocket;
299 #ifdef FORCE_SESSION
300         clientSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
301 #endif
302         QCOMPARE(int(clientSocket.writeDatagram(message[i], strlen(message[i]),
303                                                serverAddress, serverSocket.localPort())),
304                 int(strlen(message[i])));
305         char buf[1024];
306         QHostAddress host;
307         quint16 port;
308         QVERIFY2(serverSocket.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(serverSocket).constData());
309         QCOMPARE(int(serverSocket.readDatagram(buf, sizeof(buf), &host, &port)),
310                 int(strlen(message[i])));
311         buf[strlen(message[i])] = '\0';
312         QCOMPARE(QByteArray(buf), QByteArray(message[i]));
313         QCOMPARE(port, clientSocket.localPort());
314         if (host.toIPv4Address()) // in case the sender is IPv4 mapped in IPv6
315             QCOMPARE(host.toIPv4Address(), makeNonAny(clientSocket.localAddress()).toIPv4Address());
316         else
317             QCOMPARE(host, makeNonAny(clientSocket.localAddress()));
318     }
319 }
320 
321 //----------------------------------------------------------------------------------
322 
323 void tst_QUdpSocket::broadcasting()
324 {
325     QFETCH_GLOBAL(bool, setProxy);
326     if (setProxy) {
327 #ifndef QT_NO_NETWORKPROXY
328         QFETCH_GLOBAL(int, proxyType);
329         if (proxyType == QNetworkProxy::Socks5Proxy)
330             QSKIP("With socks5 Broadcast is not supported.");
331 #else // !QT_NO_NETWORKPROXY
332         QSKIP("No proxy support");
333 #endif // QT_NO_NETWORKPROXY
334     }
335 #ifdef Q_OS_AIX
336     QSKIP("Broadcast does not work on darko");
337 #endif
338     const char *message[] = {"Yo mista", "", "Yo", "Wassap"};
339 
340     QList<QHostAddress> broadcastAddresses;
341     foreach (QNetworkInterface iface, QNetworkInterface::allInterfaces()) {
342         if ((iface.flags() & QNetworkInterface::CanBroadcast)
343             && iface.flags() & QNetworkInterface::IsUp) {
344             for (int i=0;i<iface.addressEntries().count();i++) {
345                 QHostAddress broadcast = iface.addressEntries().at(i).broadcast();
346                 if (broadcast.protocol() == QAbstractSocket::IPv4Protocol)
347                     broadcastAddresses.append(broadcast);
348             }
349         }
350     }
351     if (broadcastAddresses.isEmpty())
352         QSKIP("No interface can broadcast");
353     for (int i = 0; i < 4; ++i) {
354         QUdpSocket serverSocket;
355 #ifdef FORCE_SESSION
356         serverSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
357 #endif
358         QVERIFY2(serverSocket.bind(QHostAddress(QHostAddress::AnyIPv4), 0), serverSocket.errorString().toLatin1().constData());
359         quint16 serverPort = serverSocket.localPort();
360 
361         QCOMPARE(serverSocket.state(), QUdpSocket::BoundState);
362 
363         connect(&serverSocket, SIGNAL(readyRead()), SLOT(empty_readyReadSlot()));
364 
365         QUdpSocket broadcastSocket;
366 #ifdef FORCE_SESSION
367         broadcastSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
368 #endif
369         broadcastSocket.bind(QHostAddress(QHostAddress::AnyIPv4), 0);
370 
371         for (int j = 0; j < 10; ++j) {
372             for (int k = 0; k < 4; k++) {
373                 broadcastSocket.writeDatagram(message[i], strlen(message[i]),
374                     QHostAddress::Broadcast, serverPort);
375                 foreach (QHostAddress addr, broadcastAddresses)
376                     broadcastSocket.writeDatagram(message[i], strlen(message[i]), addr, serverPort);
377             }
378             QTestEventLoop::instance().enterLoop(15);
379             if (QTestEventLoop::instance().timeout()) {
380 #if defined(Q_OS_FREEBSD)
381                 QEXPECT_FAIL("",
382                              "Broadcasting to 255.255.255.255 does not work on FreeBSD",
383                              Abort);
384                 QVERIFY(false); // seems that QFAIL() doesn't respect the QEXPECT_FAIL() :/
385 #endif
386                 QFAIL("Network operation timed out");
387             }
388             QVERIFY(serverSocket.hasPendingDatagrams());
389 
390             do {
391                 const int messageLength = int(strlen(message[i]));
392                 QNetworkDatagram dgram = serverSocket.receiveDatagram();
393                 QVERIFY(dgram.isValid());
394                 QByteArray arr = dgram.data();
395 
396                 QCOMPARE(arr.length(), messageLength);
397                 arr.resize(messageLength);
398                 QCOMPARE(arr, QByteArray(message[i]));
399 
400                 if (dgram.senderAddress().toIPv4Address()) // in case it's a v6-mapped address
401                     QVERIFY2(allAddresses.contains(QHostAddress(dgram.senderAddress().toIPv4Address())),
402                              dgram.senderAddress().toString().toLatin1());
403                 else if (!dgram.senderAddress().isNull())
404                     QVERIFY2(allAddresses.contains(dgram.senderAddress()),
405                              dgram.senderAddress().toString().toLatin1());
406                 QCOMPARE(dgram.senderPort(), int(broadcastSocket.localPort()));
407                 if (!dgram.destinationAddress().isNull()) {
408                     QVERIFY2(dgram.destinationAddress() == QHostAddress::Broadcast
409                             || broadcastAddresses.contains(dgram.destinationAddress()),
410                              dgram.destinationAddress().toString().toLatin1());
411                     QCOMPARE(dgram.destinationPort(), int(serverSocket.localPort()));
412                 }
413 
414                 int ttl = dgram.hopLimit();
415                 if (ttl != -1)
416                     QVERIFY(ttl != 0);
417             } while (serverSocket.hasPendingDatagrams());
418         }
419     }
420 }
421 
422 //----------------------------------------------------------------------------------
423 
424 void tst_QUdpSocket::loop_data()
425 {
426     QTest::addColumn<QByteArray>("peterMessage");
427     QTest::addColumn<QByteArray>("paulMessage");
428     QTest::addColumn<bool>("success");
429 
430     QTest::newRow("\"Almond!\" | \"Joy!\"") << QByteArray("Almond!") << QByteArray("Joy!") << true;
431     QTest::newRow("\"A\" | \"B\"") << QByteArray("A") << QByteArray("B") << true;
432     QTest::newRow("\"AB\" | \"B\"") << QByteArray("AB") << QByteArray("B") << true;
433     QTest::newRow("\"AB\" | \"BB\"") << QByteArray("AB") << QByteArray("BB") << true;
434     QTest::newRow("\"A\\0B\" | \"B\\0B\"") << QByteArray::fromRawData("A\0B", 3) << QByteArray::fromRawData("B\0B", 3) << true;
435     QTest::newRow("\"(nil)\" | \"(nil)\"") << QByteArray() << QByteArray() << true;
436     QTest::newRow("Bigmessage") << QByteArray(600, '@') << QByteArray(600, '@') << true;
437 }
438 
439 void tst_QUdpSocket::loop()
440 {
441     QFETCH(QByteArray, peterMessage);
442     QFETCH(QByteArray, paulMessage);
443     QFETCH(bool, success);
444 
445     QUdpSocket peter;
446     QUdpSocket paul;
447 #ifdef FORCE_SESSION
448     peter.setProperty("_q_networksession", QVariant::fromValue(networkSession));
449     paul.setProperty("_q_networksession", QVariant::fromValue(networkSession));
450 #endif
451 
452     QVERIFY2(peter.bind(), peter.errorString().toLatin1().constData());
453     QVERIFY2(paul.bind(), paul.errorString().toLatin1().constData());
454 
455     QHostAddress peterAddress = makeNonAny(peter.localAddress());
456     QHostAddress pualAddress = makeNonAny(paul.localAddress());
457 
458     QCOMPARE(peter.writeDatagram(peterMessage.data(), peterMessage.length(),
459                                 pualAddress, paul.localPort()), qint64(peterMessage.length()));
460     QCOMPARE(paul.writeDatagram(paulMessage.data(), paulMessage.length(),
461                                peterAddress, peter.localPort()), qint64(paulMessage.length()));
462 
463     QVERIFY2(peter.waitForReadyRead(9000), QtNetworkSettings::msgSocketError(peter).constData());
464     QVERIFY2(paul.waitForReadyRead(9000), QtNetworkSettings::msgSocketError(paul).constData());
465     char peterBuffer[16*1024];
466     char paulBuffer[16*1024];
467     if (success) {
468         QCOMPARE(peter.readDatagram(peterBuffer, sizeof(peterBuffer)), qint64(paulMessage.length()));
469         QCOMPARE(paul.readDatagram(paulBuffer, sizeof(peterBuffer)), qint64(peterMessage.length()));
470     } else {
471         QVERIFY(peter.readDatagram(peterBuffer, sizeof(peterBuffer)) != paulMessage.length());
472         QVERIFY(paul.readDatagram(paulBuffer, sizeof(peterBuffer)) != peterMessage.length());
473     }
474 
475     QCOMPARE(QByteArray(peterBuffer, paulMessage.length()), paulMessage);
476     QCOMPARE(QByteArray(paulBuffer, peterMessage.length()), peterMessage);
477 }
478 
479 //----------------------------------------------------------------------------------
480 
481 void tst_QUdpSocket::ipv6Loop_data()
482 {
483     loop_data();
484 }
485 
486 void tst_QUdpSocket::ipv6Loop()
487 {
488     QFETCH(QByteArray, peterMessage);
489     QFETCH(QByteArray, paulMessage);
490     QFETCH(bool, success);
491 
492     QUdpSocket peter;
493     QUdpSocket paul;
494 #ifdef FORCE_SESSION
495     peter.setProperty("_q_networksession", QVariant::fromValue(networkSession));
496     paul.setProperty("_q_networksession", QVariant::fromValue(networkSession));
497 #endif
498 
499     quint16 peterPort;
500     quint16 paulPort;
501 
502     if (!peter.bind(QHostAddress(QHostAddress::LocalHostIPv6), 0)) {
503         QCOMPARE(peter.error(), QUdpSocket::UnsupportedSocketOperationError);
504         return;
505     }
506 
507     QVERIFY(paul.bind(QHostAddress(QHostAddress::LocalHostIPv6), 0));
508 
509     peterPort = peter.localPort();
510     paulPort = paul.localPort();
511 
512     QCOMPARE(peter.writeDatagram(peterMessage.data(), peterMessage.length(), QHostAddress("::1"),
513                                     paulPort), qint64(peterMessage.length()));
514     QCOMPARE(paul.writeDatagram(paulMessage.data(), paulMessage.length(),
515                                    QHostAddress("::1"), peterPort), qint64(paulMessage.length()));
516 
517     char peterBuffer[16*1024];
518     char paulBuffer[16*1024];
519     QVERIFY(peter.waitForReadyRead(5000));
520     QVERIFY(paul.waitForReadyRead(5000));
521     if (success) {
522         QCOMPARE(peter.readDatagram(peterBuffer, sizeof(peterBuffer)), qint64(paulMessage.length()));
523         QCOMPARE(paul.readDatagram(paulBuffer, sizeof(peterBuffer)), qint64(peterMessage.length()));
524     } else {
525         QVERIFY(peter.readDatagram(peterBuffer, sizeof(peterBuffer)) != paulMessage.length());
526         QVERIFY(paul.readDatagram(paulBuffer, sizeof(peterBuffer)) != peterMessage.length());
527     }
528 
529     QCOMPARE(QByteArray(peterBuffer, paulMessage.length()), paulMessage);
530     QCOMPARE(QByteArray(paulBuffer, peterMessage.length()), peterMessage);
531 }
532 
533 void tst_QUdpSocket::dualStack()
534 {
535     QFETCH_GLOBAL(bool, setProxy);
536     if (setProxy)
537         QSKIP("test server SOCKS proxy doesn't support IPv6");
538     QUdpSocket dualSock;
539     QByteArray dualData("dual");
540     QVERIFY(dualSock.bind(QHostAddress(QHostAddress::Any), 0));
541 
542     QUdpSocket v4Sock;
543     QByteArray v4Data("v4");
544     QVERIFY(v4Sock.bind(QHostAddress(QHostAddress::AnyIPv4), 0));
545 
546     QHostAddress from;
547     quint16 port;
548     QByteArray buffer;
549     //test v4 -> dual
550     QCOMPARE((int)v4Sock.writeDatagram(v4Data.constData(), v4Data.length(), QHostAddress(QHostAddress::LocalHost), dualSock.localPort()), v4Data.length());
551     QVERIFY2(dualSock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(dualSock).constData());
552     buffer.reserve(100);
553     qint64 size = dualSock.readDatagram(buffer.data(), 100, &from, &port);
554     QCOMPARE((int)size, v4Data.length());
555     buffer.resize(size);
556     QCOMPARE(buffer, v4Data);
557 
558     if (QtNetworkSettings::hasIPv6()) {
559         QUdpSocket v6Sock;
560         QByteArray v6Data("v6");
561         QVERIFY(v6Sock.bind(QHostAddress(QHostAddress::AnyIPv6), 0));
562 
563         //test v6 -> dual
564         QCOMPARE((int)v6Sock.writeDatagram(v6Data.constData(), v6Data.length(), QHostAddress(QHostAddress::LocalHostIPv6), dualSock.localPort()), v6Data.length());
565         QVERIFY2(dualSock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(dualSock).constData());
566         buffer.reserve(100);
567         size = dualSock.readDatagram(buffer.data(), 100, &from, &port);
568         QCOMPARE((int)size, v6Data.length());
569         buffer.resize(size);
570         QCOMPARE(buffer, v6Data);
571 
572         //test dual -> v6
573         QCOMPARE((int)dualSock.writeDatagram(dualData.constData(), dualData.length(), QHostAddress(QHostAddress::LocalHostIPv6), v6Sock.localPort()), dualData.length());
574         QVERIFY2(v6Sock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(v6Sock).constData());
575         buffer.reserve(100);
576         size = v6Sock.readDatagram(buffer.data(), 100, &from, &port);
577         QCOMPARE((int)size, dualData.length());
578         buffer.resize(size);
579         QCOMPARE(buffer, dualData);
580     }
581 
582     //test dual -> v4
583     QCOMPARE((int)dualSock.writeDatagram(dualData.constData(), dualData.length(), QHostAddress(QHostAddress::LocalHost), v4Sock.localPort()), dualData.length());
584     QVERIFY2(v4Sock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(v4Sock).constData());
585     buffer.reserve(100);
586     size = v4Sock.readDatagram(buffer.data(), 100, &from, &port);
587     QCOMPARE((int)size, dualData.length());
588     buffer.resize(size);
589     QCOMPARE(buffer, dualData);
590 }
591 
592 void tst_QUdpSocket::dualStackAutoBinding()
593 {
594     QFETCH_GLOBAL(bool, setProxy);
595     if (setProxy)
596         QSKIP("test server SOCKS proxy doesn't support IPv6");
597     if (!QtNetworkSettings::hasIPv6())
598         QSKIP("system doesn't support ipv6!");
599     QUdpSocket v4Sock;
600     QVERIFY(v4Sock.bind(QHostAddress(QHostAddress::AnyIPv4), 0));
601 
602     QUdpSocket v6Sock;
603     QVERIFY(v6Sock.bind(QHostAddress(QHostAddress::AnyIPv6), 0));
604 
605     QByteArray dualData("dual");
606     QHostAddress from;
607     quint16 port;
608     QByteArray buffer;
609     int size;
610 
611     {
612         //test an autobound socket can send to both v4 and v6 addresses (v4 first)
613         QUdpSocket dualSock;
614 
615         QCOMPARE((int)dualSock.writeDatagram(dualData.constData(), dualData.length(), QHostAddress(QHostAddress::LocalHost), v4Sock.localPort()), dualData.length());
616         QVERIFY2(v4Sock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(v4Sock).constData());
617         buffer.reserve(100);
618         size = v4Sock.readDatagram(buffer.data(), 100, &from, &port);
619         QCOMPARE((int)size, dualData.length());
620         buffer.resize(size);
621         QCOMPARE(buffer, dualData);
622 
623         QCOMPARE((int)dualSock.writeDatagram(dualData.constData(), dualData.length(), QHostAddress(QHostAddress::LocalHostIPv6), v6Sock.localPort()), dualData.length());
624         QVERIFY2(v6Sock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(v6Sock).constData());
625         buffer.reserve(100);
626         size = v6Sock.readDatagram(buffer.data(), 100, &from, &port);
627         QCOMPARE((int)size, dualData.length());
628         buffer.resize(size);
629         QCOMPARE(buffer, dualData);
630     }
631 
632     {
633         //test an autobound socket can send to both v4 and v6 addresses (v6 first)
634         QUdpSocket dualSock;
635 
636         QCOMPARE((int)dualSock.writeDatagram(dualData.constData(), dualData.length(), QHostAddress(QHostAddress::LocalHostIPv6), v6Sock.localPort()), dualData.length());
637         QVERIFY2(v6Sock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(v6Sock).constData());
638         buffer.reserve(100);
639         size = v6Sock.readDatagram(buffer.data(), 100, &from, &port);
640         QCOMPARE((int)size, dualData.length());
641         buffer.resize(size);
642         QCOMPARE(buffer, dualData);
643 
644         QCOMPARE((int)dualSock.writeDatagram(dualData.constData(), dualData.length(), QHostAddress(QHostAddress::LocalHost), v4Sock.localPort()), dualData.length());
645         QVERIFY2(v4Sock.waitForReadyRead(5000), QtNetworkSettings::msgSocketError(v4Sock).constData());
646         buffer.reserve(100);
647         size = v4Sock.readDatagram(buffer.data(), 100, &from, &port);
648         QCOMPARE((int)size, dualData.length());
649         buffer.resize(size);
650         QCOMPARE(buffer, dualData);
651     }
652 }
653 
654 void tst_QUdpSocket::dualStackNoIPv4onV6only()
655 {
656     QFETCH_GLOBAL(bool, setProxy);
657     if (setProxy)
658         QSKIP("test server SOCKS proxy doesn't support IPv6");
659     if (!QtNetworkSettings::hasIPv6())
660         QSKIP("system doesn't support ipv6!");
661     QUdpSocket v4Sock;
662     QVERIFY(v4Sock.bind(QHostAddress(QHostAddress::AnyIPv4), 0));
663     QByteArray v4Data("v4");
664 
665     QUdpSocket v6Sock;
666     QVERIFY(v6Sock.bind(QHostAddress(QHostAddress::AnyIPv6), 0));
667 
668     //test v4 -> v6 (should not be received as this is a v6 only socket)
669     QCOMPARE((int)v4Sock.writeDatagram(v4Data.constData(), v4Data.length(), QHostAddress(QHostAddress::LocalHost), v6Sock.localPort()), v4Data.length());
670     QVERIFY(!v6Sock.waitForReadyRead(1000));
671 }
672 
673 void tst_QUdpSocket::empty_readyReadSlot()
674 {
675     QTestEventLoop::instance().exitLoop();
676 }
677 
678 void tst_QUdpSocket::empty_connectedSlot()
679 {
680     QTestEventLoop::instance().exitLoop();
681 }
682 
683 //----------------------------------------------------------------------------------
684 
685 void tst_QUdpSocket::connectToHost()
686 {
687     QUdpSocket socket1;
688     QUdpSocket socket2;
689 #ifdef FORCE_SESSION
690     socket1.setProperty("_q_networksession", QVariant::fromValue(networkSession));
691     socket2.setProperty("_q_networksession", QVariant::fromValue(networkSession));
692 #endif
693 
694     QVERIFY2(socket1.bind(), socket1.errorString().toLatin1().constData());
695 
696     socket2.connectToHost(makeNonAny(socket1.localAddress()), socket1.localPort());
697     QVERIFY(socket2.waitForConnected(5000));
698 }
699 
700 //----------------------------------------------------------------------------------
701 
702 void tst_QUdpSocket::bindAndConnectToHost()
703 {
704     QUdpSocket socket1;
705     QUdpSocket socket2;
706     QUdpSocket dummysocket;
707 #ifdef FORCE_SESSION
708     socket1.setProperty("_q_networksession", QVariant::fromValue(networkSession));
709     socket2.setProperty("_q_networksession", QVariant::fromValue(networkSession));
710     dummysocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
711 #endif
712 
713     // we use the dummy socket to use up a file descriptor
714     dummysocket.bind();
715 
716     QVERIFY2(socket2.bind(), socket2.errorString().toLatin1());
717     quint16 boundPort = socket2.localPort();
718     qintptr fd = socket2.socketDescriptor();
719 
720     QVERIFY2(socket1.bind(), socket1.errorString().toLatin1().constData());
721 
722     dummysocket.close();
723     socket2.connectToHost(makeNonAny(socket1.localAddress()), socket1.localPort());
724     QVERIFY(socket2.waitForConnected(5000));
725 
726     QCOMPARE(socket2.localPort(), boundPort);
727     QCOMPARE(socket2.socketDescriptor(), fd);
728 }
729 
730 //----------------------------------------------------------------------------------
731 
732 void tst_QUdpSocket::pendingDatagramSize()
733 {
734     QUdpSocket server;
735 #ifdef FORCE_SESSION
736     server.setProperty("_q_networksession", QVariant::fromValue(networkSession));
737 #endif
738     QVERIFY2(server.bind(), server.errorString().toLatin1().constData());
739 
740     QHostAddress serverAddress = makeNonAny(server.localAddress());
741     QUdpSocket client;
742 #ifdef FORCE_SESSION
743     client.setProperty("_q_networksession", QVariant::fromValue(networkSession));
744 #endif
745     QVERIFY(client.writeDatagram("this is", 7, serverAddress, server.localPort()) == 7);
746     QVERIFY(client.writeDatagram(0, 0, serverAddress, server.localPort()) == 0);
747     QVERIFY(client.writeDatagram("3 messages", 10, serverAddress, server.localPort()) == 10);
748 
749     char c = 0;
750     QVERIFY2(server.waitForReadyRead(), QtNetworkSettings::msgSocketError(server).constData());
751     if (server.hasPendingDatagrams()) {
752 #if defined Q_OS_HPUX && defined __ia64
753         QEXPECT_FAIL("", "HP-UX 11i v2 can't determine the datagram size correctly.", Abort);
754 #endif
755         QCOMPARE(server.pendingDatagramSize(), qint64(7));
756         c = '\0';
757         QCOMPARE(server.readDatagram(&c, 1), qint64(1));
758         QCOMPARE(c, 't');
759         c = '\0';
760     } else
761         QSKIP("does not have the 1st datagram");
762 
763     if (server.hasPendingDatagrams()) {
764         QCOMPARE(server.pendingDatagramSize(), qint64(0));
765         QCOMPARE(server.readDatagram(&c, 1), qint64(0));
766         QCOMPARE(c, '\0'); // untouched
767         c = '\0';
768     } else
769         QSKIP("does not have the 2nd datagram");
770 
771     if (server.hasPendingDatagrams()) {
772         QCOMPARE(server.pendingDatagramSize(), qint64(10));
773         QCOMPARE(server.readDatagram(&c, 1), qint64(1));
774         QCOMPARE(c, '3');
775     } else
776         QSKIP("does not have the 3rd datagram");
777 }
778 
779 
780 void tst_QUdpSocket::writeDatagram()
781 {
782     QUdpSocket server;
783 #ifdef FORCE_SESSION
784     server.setProperty("_q_networksession", QVariant::fromValue(networkSession));
785 #endif
786     QVERIFY2(server.bind(), server.errorString().toLatin1().constData());
787 
788     QHostAddress serverAddress = makeNonAny(server.localAddress());
789     QUdpSocket client;
790 #ifdef FORCE_SESSION
791     client.setProperty("_q_networksession", QVariant::fromValue(networkSession));
792 #endif
793 
794     qRegisterMetaType<QAbstractSocket::SocketError>("QAbstractSocket::SocketError");
795 
796     for(int i=0;;i++) {
797         QSignalSpy errorspy(&client, SIGNAL(error(QAbstractSocket::SocketError)));
798         QSignalSpy bytesspy(&client, SIGNAL(bytesWritten(qint64)));
799 
800         qint64 written = client.writeDatagram(QByteArray(i * 1024, 'w'), serverAddress,
801                                                   server.localPort());
802 
803         if (written != i * 1024) {
804 #if defined (Q_OS_HPUX)
805             QSKIP("HP-UX 11.11 on hai (PA-RISC 64) truncates too long datagrams.");
806 #endif
807             QCOMPARE(bytesspy.count(), 0);
808             QCOMPARE(errorspy.count(), 1);
809             QCOMPARE(*static_cast<const int *>(errorspy.at(0).at(0).constData()),
810                     int(QUdpSocket::DatagramTooLargeError));
811             QCOMPARE(client.error(), QUdpSocket::DatagramTooLargeError);
812             break;
813         }
814         QCOMPARE(bytesspy.count(), 1);
815         QCOMPARE(*static_cast<const qint64 *>(bytesspy.at(0).at(0).constData()),
816                 qint64(i * 1024));
817         QCOMPARE(errorspy.count(), 0);
818         if (!server.waitForReadyRead(5000))
819             QSKIP(QString("UDP packet lost at size %1, unable to complete the test.").arg(i * 1024).toLatin1().data());
820         QCOMPARE(server.pendingDatagramSize(), qint64(i * 1024));
821         QCOMPARE(server.readDatagram(0, 0), qint64(0));
822     }
823 }
824 
825 void tst_QUdpSocket::performance()
826 {
827     QByteArray arr(8192, '@');
828 
829     QUdpSocket server;
830 #ifdef FORCE_SESSION
831     server.setProperty("_q_networksession", QVariant::fromValue(networkSession));
832 #endif
833     QVERIFY2(server.bind(), server.errorString().toLatin1().constData());
834 
835     QHostAddress serverAddress = makeNonAny(server.localAddress());
836     QUdpSocket client;
837 #ifdef FORCE_SESSION
838     client.setProperty("_q_networksession", QVariant::fromValue(networkSession));
839 #endif
840     client.connectToHost(serverAddress, server.localPort());
841     QVERIFY(client.waitForConnected(10000));
842 
843     QTime stopWatch;
844     stopWatch.start();
845 
846     qint64 nbytes = 0;
847     while (stopWatch.elapsed() < 5000) {
848         for (int i = 0; i < 100; ++i) {
849             if (client.write(arr.data(), arr.size()) > 0) {
850                 do {
851                     nbytes += server.readDatagram(arr.data(), arr.size());
852                 } while (server.hasPendingDatagrams());
853             }
854         }
855     }
856 
857     float secs = stopWatch.elapsed() / 1000.0;
858     qDebug("\t%.2fMB/%.2fs: %.2fMB/s", float(nbytes / (1024.0*1024.0)),
859            secs, float(nbytes / (1024.0*1024.0)) / secs);
860 }
861 
862 void tst_QUdpSocket::bindMode()
863 {
864     QFETCH_GLOBAL(bool, setProxy);
865     if (setProxy) {
866 #ifndef QT_NO_NETWORKPROXY
867         QFETCH_GLOBAL(int, proxyType);
868         if (proxyType == QNetworkProxy::Socks5Proxy)
869             QSKIP("With socks5 explicit port binding is not supported.");
870 #else // !QT_NO_NETWORKPROXY
871         QSKIP("No proxy support");
872 #endif // QT_NO_NETWORKPROXY
873     }
874 
875     QUdpSocket socket;
876 #ifdef FORCE_SESSION
877     socket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
878 #endif
879     QVERIFY2(socket.bind(), socket.errorString().toLatin1().constData());
880     QUdpSocket socket2;
881 #ifdef FORCE_SESSION
882     socket2.setProperty("_q_networksession", QVariant::fromValue(networkSession));
883 #endif
884     QVERIFY(!socket2.bind(socket.localPort()));
885 #if defined(Q_OS_UNIX)
886     QVERIFY(!socket2.bind(socket.localPort(), QUdpSocket::ReuseAddressHint));
887     socket.close();
888     QVERIFY2(socket.bind(0, QUdpSocket::ShareAddress), socket.errorString().toLatin1().constData());
889     QVERIFY2(socket2.bind(socket.localPort()), socket2.errorString().toLatin1().constData());
890     socket2.close();
891     QVERIFY2(socket2.bind(socket.localPort(), QUdpSocket::ReuseAddressHint), socket2.errorString().toLatin1().constData());
892 #else
893 
894     // Depending on the user's privileges, this or will succeed or
895     // fail. Admins are allowed to reuse the address, but nobody else.
896     if (!socket2.bind(socket.localPort(), QUdpSocket::ReuseAddressHint), socket2.errorString().toLatin1().constData())
897         qWarning("Failed to bind with QUdpSocket::ReuseAddressHint, user isn't an administrator?");
898     socket.close();
899     QVERIFY2(socket.bind(0, QUdpSocket::ShareAddress), socket.errorString().toLatin1().constData());
900     QVERIFY(!socket2.bind(socket.localPort()));
901     socket.close();
902     QVERIFY2(socket.bind(0, QUdpSocket::DontShareAddress), socket.errorString().toLatin1().constData());
903     QVERIFY(!socket2.bind(socket.localPort()));
904     QVERIFY(!socket2.bind(socket.localPort(), QUdpSocket::ReuseAddressHint));
905 #endif
906 }
907 
908 void tst_QUdpSocket::writeDatagramToNonExistingPeer_data()
909 {
910     QTest::addColumn<bool>("bind");
911     QTest::addColumn<QHostAddress>("peerAddress");
912     QHostAddress localhost(QHostAddress::LocalHost);
913     QList<QHostAddress> serverAddresses(QHostInfo::fromName(QtNetworkSettings::serverName()).addresses());
914     if (serverAddresses.isEmpty())
915         return;
916 
917     QHostAddress remote = serverAddresses.first();
918 
919     QTest::newRow("localhost-unbound") << false << localhost;
920     QTest::newRow("localhost-bound") << true << localhost;
921     QTest::newRow("remote-unbound") << false << remote;
922     QTest::newRow("remote-bound") << true << remote;
923 }
924 
925 void tst_QUdpSocket::writeDatagramToNonExistingPeer()
926 {
927     if (QHostInfo::fromName(QtNetworkSettings::serverName()).addresses().isEmpty())
928         QFAIL("Could not find test server address");
929     QFETCH(bool, bind);
930     QFETCH(QHostAddress, peerAddress);
931 
932     quint16 peerPort = 33533 + int(bind);
933 
934     QUdpSocket sUdp;
935 #ifdef FORCE_SESSION
936     sUdp.setProperty("_q_networksession", QVariant::fromValue(networkSession));
937 #endif
938     QSignalSpy sReadyReadSpy(&sUdp, SIGNAL(readyRead()));
939     if (bind)
940         QVERIFY(sUdp.bind());
941     QCOMPARE(sUdp.writeDatagram("", 1, peerAddress, peerPort), qint64(1));
942     QTestEventLoop::instance().enterLoop(1);
943     QCOMPARE(sReadyReadSpy.count(), 0);
944 }
945 
946 void tst_QUdpSocket::writeToNonExistingPeer_data()
947 {
948     QTest::addColumn<QHostAddress>("peerAddress");
949     QHostAddress localhost(QHostAddress::LocalHost);
950     QList<QHostAddress> serverAddresses(QHostInfo::fromName(QtNetworkSettings::serverName()).addresses());
951     if (serverAddresses.isEmpty())
952         return;
953 
954     QHostAddress remote = serverAddresses.first();
955     // write (required to be connected)
956     QTest::newRow("localhost") << localhost;
957     QTest::newRow("remote") << remote;
958 }
959 
960 void tst_QUdpSocket::writeToNonExistingPeer()
961 {
962     QSKIP("Connected-mode UDP sockets and their behaviour are erratic");
963     if (QHostInfo::fromName(QtNetworkSettings::serverName()).addresses().isEmpty())
964         QFAIL("Could not find test server address");
965     QFETCH(QHostAddress, peerAddress);
966     quint16 peerPort = 34534;
967     qRegisterMetaType<QAbstractSocket::SocketError>("QAbstractSocket::SocketError");
968 
969     QUdpSocket sConnected;
970 #ifdef FORCE_SESSION
971     sConnected.setProperty("_q_networksession", QVariant::fromValue(networkSession));
972 #endif
973     QSignalSpy sConnectedReadyReadSpy(&sConnected, SIGNAL(readyRead()));
974     QSignalSpy sConnectedErrorSpy(&sConnected, SIGNAL(error(QAbstractSocket::SocketError)));
975     sConnected.connectToHost(peerAddress, peerPort, QIODevice::ReadWrite);
976     QVERIFY(sConnected.waitForConnected(10000));
977 
978     // the first write succeeds...
979     QCOMPARE(sConnected.write("", 1), qint64(1));
980 
981     // the second one should fail!
982     QTest::qSleep(1000);                   // do not process events
983     QCOMPARE(sConnected.write("", 1), qint64(-1));
984     QCOMPARE(int(sConnected.error()), int(QUdpSocket::ConnectionRefusedError));
985 
986     // the third one will succeed...
987     QCOMPARE(sConnected.write("", 1), qint64(1));
988     QTestEventLoop::instance().enterLoop(1);
989     QCOMPARE(sConnectedReadyReadSpy.count(), 0);
990     QCOMPARE(sConnectedErrorSpy.count(), 1);
991     QCOMPARE(int(sConnected.error()), int(QUdpSocket::ConnectionRefusedError));
992 
993     // we should now get a read error
994     QCOMPARE(sConnected.write("", 1), qint64(1));
995     QTest::qSleep(1000);                   // do not process events
996     char buf[2];
997     QVERIFY(!sConnected.hasPendingDatagrams());
998     QCOMPARE(sConnected.bytesAvailable(), Q_INT64_C(0));
999     QCOMPARE(sConnected.pendingDatagramSize(), Q_INT64_C(-1));
1000     QCOMPARE(sConnected.readDatagram(buf, 2), Q_INT64_C(-1));
1001     QCOMPARE(int(sConnected.error()), int(QUdpSocket::ConnectionRefusedError));
1002 
1003     QCOMPARE(sConnected.write("", 1), qint64(1));
1004     QTest::qSleep(1000);                   // do not process events
1005     QCOMPARE(sConnected.read(buf, 2), Q_INT64_C(0));
1006     QCOMPARE(int(sConnected.error()), int(QUdpSocket::ConnectionRefusedError));
1007 
1008     // we should still be connected
1009     QCOMPARE(int(sConnected.state()), int(QUdpSocket::ConnectedState));
1010 }
1011 
1012 void tst_QUdpSocket::outOfProcessConnectedClientServerTest()
1013 {
1014 #if !QT_CONFIG(process)
1015     QSKIP("No qprocess support", SkipAll);
1016 #else
1017     QProcess serverProcess;
1018     serverProcess.start(QLatin1String("clientserver/clientserver server 1 1"),
1019                         QIODevice::ReadWrite | QIODevice::Text);
1020     QVERIFY2(serverProcess.waitForStarted(3000),
1021              qPrintable("Failed to start subprocess: " + serverProcess.errorString()));
1022 
1023     // Wait until the server has started and reports success.
1024     while (!serverProcess.canReadLine())
1025         QVERIFY(serverProcess.waitForReadyRead(3000));
1026     QByteArray serverGreeting = serverProcess.readLine();
1027     QVERIFY(serverGreeting != QByteArray("XXX\n"));
1028     int serverPort = serverGreeting.trimmed().toInt();
1029     QVERIFY(serverPort > 0 && serverPort < 65536);
1030 
1031     QProcess clientProcess;
1032     clientProcess.start(QString::fromLatin1("clientserver/clientserver connectedclient %1 %2")
1033                         .arg(QLatin1String("127.0.0.1")).arg(serverPort),
1034                         QIODevice::ReadWrite | QIODevice::Text);
1035     QVERIFY2(clientProcess.waitForStarted(3000),
1036              qPrintable("Failed to start subprocess: " + clientProcess.errorString()));
1037 
1038     // Wait until the server has started and reports success.
1039     while (!clientProcess.canReadLine())
1040         QVERIFY(clientProcess.waitForReadyRead(3000));
1041     QByteArray clientGreeting = clientProcess.readLine();
1042     QCOMPARE(clientGreeting, QByteArray("ok\n"));
1043 
1044     // Let the client and server talk for 3 seconds
1045     QTest::qWait(3000);
1046 
1047     QStringList serverData = QString::fromLocal8Bit(serverProcess.readAll()).split("\n");
1048     QStringList clientData = QString::fromLocal8Bit(clientProcess.readAll()).split("\n");
1049     QVERIFY(serverData.size() > 5);
1050     QVERIFY(clientData.size() > 5);
1051 
1052     for (int i = 0; i < clientData.size() / 2; ++i) {
1053         QCOMPARE(clientData.at(i * 2), QString("readData()"));
1054         QCOMPARE(serverData.at(i * 3), QString("readData()"));
1055 
1056         QString cdata = clientData.at(i * 2 + 1);
1057         QString sdata = serverData.at(i * 3 + 1);
1058         QVERIFY(cdata.startsWith(QLatin1String("got ")));
1059 
1060         QCOMPARE(cdata.mid(4).trimmed().toInt(), sdata.mid(4).trimmed().toInt() * 2);
1061         QVERIFY(serverData.at(i * 3 + 2).startsWith(QLatin1String("sending ")));
1062         QCOMPARE(serverData.at(i * 3 + 2).trimmed().mid(8).toInt(),
1063                  sdata.mid(4).trimmed().toInt() * 2);
1064     }
1065 
1066     clientProcess.kill();
1067     QVERIFY(clientProcess.waitForFinished());
1068     serverProcess.kill();
1069     QVERIFY(serverProcess.waitForFinished());
1070 #endif
1071 }
1072 
1073 void tst_QUdpSocket::outOfProcessUnconnectedClientServerTest()
1074 {
1075 #if !QT_CONFIG(process)
1076     QSKIP("No qprocess support", SkipAll);
1077 #else
1078     QProcess serverProcess;
1079     serverProcess.start(QLatin1String("clientserver/clientserver server 1 1"),
1080                         QIODevice::ReadWrite | QIODevice::Text);
1081     QVERIFY2(serverProcess.waitForStarted(3000),
1082              qPrintable("Failed to start subprocess: " + serverProcess.errorString()));
1083 
1084     // Wait until the server has started and reports success.
1085     while (!serverProcess.canReadLine())
1086         QVERIFY(serverProcess.waitForReadyRead(3000));
1087     QByteArray serverGreeting = serverProcess.readLine();
1088     QVERIFY(serverGreeting != QByteArray("XXX\n"));
1089     int serverPort = serverGreeting.trimmed().toInt();
1090     QVERIFY(serverPort > 0 && serverPort < 65536);
1091 
1092     QProcess clientProcess;
1093     clientProcess.start(QString::fromLatin1("clientserver/clientserver unconnectedclient %1 %2")
1094                         .arg(QLatin1String("127.0.0.1")).arg(serverPort),
1095                         QIODevice::ReadWrite | QIODevice::Text);
1096     QVERIFY2(clientProcess.waitForStarted(3000),
1097              qPrintable("Failed to start subprocess: " + clientProcess.errorString()));
1098 
1099     // Wait until the server has started and reports success.
1100     while (!clientProcess.canReadLine())
1101         QVERIFY(clientProcess.waitForReadyRead(3000));
1102     QByteArray clientGreeting = clientProcess.readLine();
1103     QCOMPARE(clientGreeting, QByteArray("ok\n"));
1104 
1105     // Let the client and server talk for 3 seconds
1106     QTest::qWait(3000);
1107 
1108     QStringList serverData = QString::fromLocal8Bit(serverProcess.readAll()).split("\n");
1109     QStringList clientData = QString::fromLocal8Bit(clientProcess.readAll()).split("\n");
1110 
1111     QVERIFY(serverData.size() > 5);
1112     QVERIFY(clientData.size() > 5);
1113 
1114     for (int i = 0; i < clientData.size() / 2; ++i) {
1115         QCOMPARE(clientData.at(i * 2), QString("readData()"));
1116         QCOMPARE(serverData.at(i * 3), QString("readData()"));
1117 
1118         QString cdata = clientData.at(i * 2 + 1);
1119         QString sdata = serverData.at(i * 3 + 1);
1120         QVERIFY(cdata.startsWith(QLatin1String("got ")));
1121 
1122         QCOMPARE(cdata.mid(4).trimmed().toInt(), sdata.mid(4).trimmed().toInt() * 2);
1123         QVERIFY(serverData.at(i * 3 + 2).startsWith(QLatin1String("sending ")));
1124         QCOMPARE(serverData.at(i * 3 + 2).trimmed().mid(8).toInt(),
1125                  sdata.mid(4).trimmed().toInt() * 2);
1126     }
1127 
1128     clientProcess.kill();
1129     QVERIFY(clientProcess.waitForFinished());
1130     serverProcess.kill();
1131     QVERIFY(serverProcess.waitForFinished());
1132 #endif
1133 }
1134 
1135 void tst_QUdpSocket::zeroLengthDatagram()
1136 {
1137     QFETCH_GLOBAL(bool, setProxy);
1138     if (setProxy)
1139         return;
1140 
1141     QUdpSocket receiver;
1142 #ifdef FORCE_SESSION
1143     receiver.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1144 #endif
1145     QVERIFY(receiver.bind());
1146 
1147     QVERIFY(!receiver.waitForReadyRead(100));
1148     QVERIFY(!receiver.hasPendingDatagrams());
1149 
1150     QUdpSocket sender;
1151 #ifdef FORCE_SESSION
1152     sender.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1153 #endif
1154     QCOMPARE(sender.writeDatagram(QNetworkDatagram(QByteArray(), QHostAddress::LocalHost, receiver.localPort())), qint64(0));
1155 
1156     QVERIFY2(receiver.waitForReadyRead(1000), QtNetworkSettings::msgSocketError(receiver).constData());
1157     QVERIFY(receiver.hasPendingDatagrams());
1158 
1159     char buf;
1160     QCOMPARE(receiver.readDatagram(&buf, 1), qint64(0));
1161 }
1162 
1163 void tst_QUdpSocket::multicastTtlOption_data()
1164 {
1165     QTest::addColumn<QHostAddress>("bindAddress");
1166     QTest::addColumn<int>("ttl");
1167     QTest::addColumn<int>("expected");
1168 
1169     QList<QHostAddress> addresses;
1170     addresses += QHostAddress(QHostAddress::AnyIPv4);
1171     addresses += QHostAddress(QHostAddress::AnyIPv6);
1172 
1173     foreach (const QHostAddress &address, addresses) {
1174         const QByteArray addressB = address.toString().toLatin1();
1175         QTest::newRow((addressB + " 0").constData()) << address << 0 << 0;
1176         QTest::newRow((addressB + " 1").constData()) << address << 1 << 1;
1177         QTest::newRow((addressB + " 2").constData()) << address << 2 << 2;
1178         QTest::newRow((addressB + " 128").constData()) << address << 128 << 128;
1179         QTest::newRow((addressB + " 255").constData()) << address << 255 << 255;
1180         QTest::newRow((addressB + " 1024").constData()) << address << 1024 << 1;
1181     }
1182 }
1183 
1184 void tst_QUdpSocket::multicastTtlOption()
1185 {
1186 #ifdef Q_OS_WINRT
1187     QSKIP("WinRT does not support multicast.");
1188 #endif
1189     QFETCH_GLOBAL(bool, setProxy);
1190     QFETCH(QHostAddress, bindAddress);
1191     QFETCH(int, ttl);
1192     QFETCH(int, expected);
1193     if (setProxy) {
1194         // UDP multicast does not work with proxies
1195         expected = 0;
1196     }
1197 
1198     // QEMU is missing some syscalls for ipv6 udp multicasting
1199     if (m_skipUnsupportedIPv6Tests) {
1200         if (bindAddress.protocol() == QAbstractSocket::IPv6Protocol) {
1201             QSKIP("QEMU does not support ipv6 udp multicasting");
1202         }
1203     }
1204 
1205     QUdpSocket udpSocket;
1206 #ifdef FORCE_SESSION
1207     udpSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1208 #endif
1209     // bind, but ignore the result, we are only interested in initializing the socket
1210     (void) udpSocket.bind(bindAddress, 0);
1211     udpSocket.setSocketOption(QUdpSocket::MulticastTtlOption, ttl);
1212     QCOMPARE(udpSocket.socketOption(QUdpSocket::MulticastTtlOption).toInt(), expected);
1213 }
1214 
1215 void tst_QUdpSocket::multicastLoopbackOption_data()
1216 {
1217     QTest::addColumn<QHostAddress>("bindAddress");
1218     QTest::addColumn<int>("loopback");
1219     QTest::addColumn<int>("expected");
1220 
1221     QList<QHostAddress> addresses;
1222     addresses += QHostAddress(QHostAddress::AnyIPv4);
1223     addresses += QHostAddress(QHostAddress::AnyIPv6);
1224 
1225     foreach (const QHostAddress &address, addresses) {
1226         const QByteArray addressB = address.toString().toLatin1();
1227         QTest::newRow((addressB + " 0").constData()) << address << 0 << 0;
1228         QTest::newRow((addressB + " 1").constData()) << address << 1 << 1;
1229         QTest::newRow((addressB + " 2").constData()) << address << 2 << 1;
1230         QTest::newRow((addressB + " 0 again").constData()) << address << 0 << 0;
1231         QTest::newRow((addressB + " 2 again").constData()) << address << 2 << 1;
1232         QTest::newRow((addressB + " 0 last time").constData()) << address << 0 << 0;
1233         QTest::newRow((addressB + " 1 again").constData()) << address << 1 << 1;
1234     }
1235 }
1236 
1237 void tst_QUdpSocket::multicastLoopbackOption()
1238 {
1239 #ifdef Q_OS_WINRT
1240     QSKIP("WinRT does not support multicast.");
1241 #endif
1242     QFETCH_GLOBAL(bool, setProxy);
1243     QFETCH(QHostAddress, bindAddress);
1244     QFETCH(int, loopback);
1245     QFETCH(int, expected);
1246     if (setProxy) {
1247         // UDP multicast does not work with proxies
1248         expected = 0;
1249     }
1250 
1251     // QEMU is missing some syscalls for ipv6 udp multicasting
1252     if (m_skipUnsupportedIPv6Tests) {
1253         if (bindAddress.protocol() == QAbstractSocket::IPv6Protocol) {
1254             QSKIP("QEMU does not support ipv6 udp multicasting");
1255         }
1256     }
1257 
1258     QUdpSocket udpSocket;
1259 #ifdef FORCE_SESSION
1260     udpSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1261 #endif
1262     // bind, but ignore the result, we are only interested in initializing the socket
1263     (void) udpSocket.bind(bindAddress, 0);
1264     udpSocket.setSocketOption(QUdpSocket::MulticastLoopbackOption, loopback);
1265     QCOMPARE(udpSocket.socketOption(QUdpSocket::MulticastLoopbackOption).toInt(), expected);
1266 }
1267 
1268 void tst_QUdpSocket::multicastJoinBeforeBind_data()
1269 {
1270     QTest::addColumn<QHostAddress>("groupAddress");
1271     QTest::newRow("valid ipv4 group address") << QHostAddress("239.255.118.62");
1272     QTest::newRow("invalid ipv4 group address") << QHostAddress(QHostAddress::Broadcast);
1273     QTest::newRow("valid ipv6 group address") << QHostAddress("FF01::114");
1274     QTest::newRow("invalid ipv6 group address") << QHostAddress(QHostAddress::AnyIPv6);
1275 }
1276 
1277 void tst_QUdpSocket::multicastJoinBeforeBind()
1278 {
1279 #ifdef Q_OS_WINRT
1280     QSKIP("WinRT does not support multicast.");
1281 #endif
1282     QFETCH(QHostAddress, groupAddress);
1283 
1284     QUdpSocket udpSocket;
1285 #ifdef FORCE_SESSION
1286     udpSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1287 #endif
1288     // cannot join group before binding
1289     QTest::ignoreMessage(QtWarningMsg, "QUdpSocket::joinMulticastGroup() called on a QUdpSocket when not in QUdpSocket::BoundState");
1290     QVERIFY(!udpSocket.joinMulticastGroup(groupAddress));
1291 }
1292 
1293 void tst_QUdpSocket::multicastLeaveAfterClose_data()
1294 {
1295     QTest::addColumn<QHostAddress>("groupAddress");
1296     QTest::newRow("ipv4") << QHostAddress("239.255.118.62");
1297     QTest::newRow("ipv6") << QHostAddress("FF01::114");
1298 }
1299 
1300 void tst_QUdpSocket::multicastLeaveAfterClose()
1301 {
1302 #ifdef Q_OS_WINRT
1303     QSKIP("WinRT does not support multicast.");
1304 #endif
1305     QFETCH_GLOBAL(bool, setProxy);
1306     QFETCH(QHostAddress, groupAddress);
1307     if (setProxy)
1308         QSKIP("UDP Multicast does not work with proxies");
1309     if (!QtNetworkSettings::hasIPv6() && groupAddress.protocol() == QAbstractSocket::IPv6Protocol)
1310         QSKIP("system doesn't support ipv6!");
1311 
1312     // QEMU is missing some syscalls for ipv6 udp multicasting
1313     if (m_skipUnsupportedIPv6Tests) {
1314         if (groupAddress.protocol() == QAbstractSocket::IPv6Protocol) {
1315             QSKIP("QEMU does not support ipv6 udp multicasting");
1316         }
1317     }
1318 
1319     QUdpSocket udpSocket;
1320 #ifdef FORCE_SESSION
1321     udpSocket.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1322 #endif
1323     QHostAddress bindAddress = QHostAddress::AnyIPv4;
1324     if (groupAddress.protocol() == QAbstractSocket::IPv6Protocol)
1325         bindAddress = QHostAddress::AnyIPv6;
1326     QVERIFY2(udpSocket.bind(bindAddress, 0),
1327              qPrintable(udpSocket.errorString()));
1328     QVERIFY2(udpSocket.joinMulticastGroup(groupAddress),
1329              qPrintable(udpSocket.errorString()));
1330     udpSocket.close();
1331     QTest::ignoreMessage(QtWarningMsg, "QUdpSocket::leaveMulticastGroup() called on a QUdpSocket when not in QUdpSocket::BoundState");
1332     QVERIFY(!udpSocket.leaveMulticastGroup(groupAddress));
1333 }
1334 
1335 void tst_QUdpSocket::setMulticastInterface_data()
1336 {
1337     QTest::addColumn<QNetworkInterface>("iface");
1338     QTest::addColumn<QHostAddress>("address");
1339     QList<QNetworkInterface> interfaces = QNetworkInterface::allInterfaces();
1340     foreach (const QNetworkInterface &iface, interfaces) {
1341         if ((iface.flags() & QNetworkInterface::IsUp) == 0)
1342             continue;
1343         foreach (const QNetworkAddressEntry &entry, iface.addressEntries()) {
1344             const QByteArray testName = iface.name().toLatin1() + ':' + entry.ip().toString().toLatin1();
1345             QTest::newRow(testName.constData()) << iface << entry.ip();
1346         }
1347     }
1348 }
1349 
1350 void tst_QUdpSocket::setMulticastInterface()
1351 {
1352 #ifdef Q_OS_WINRT
1353     QSKIP("WinRT does not support multicast.");
1354 #endif
1355     QFETCH_GLOBAL(bool, setProxy);
1356     QFETCH(QNetworkInterface, iface);
1357     QFETCH(QHostAddress, address);
1358 
1359     // QEMU is missing some syscalls setting multicast interface
1360     if (m_skipUnsupportedIPv6Tests) {
1361         QSKIP("QEMU does not support setting multicast interface");
1362     }
1363 
1364     QUdpSocket udpSocket;
1365     // bind initializes the socket
1366     bool bound = udpSocket.bind((address.protocol() == QAbstractSocket::IPv6Protocol
1367                                  ? QHostAddress(QHostAddress::AnyIPv6)
1368                                  : QHostAddress(QHostAddress::AnyIPv4)),
1369                                 0);
1370     if (!bound)
1371         QTest::ignoreMessage(QtWarningMsg, "QUdpSocket::setMulticastInterface() called on a QUdpSocket when not in QUdpSocket::BoundState");
1372     udpSocket.setMulticastInterface(iface);
1373     if (!bound)
1374         QTest::ignoreMessage(QtWarningMsg, "QUdpSocket::multicastInterface() called on a QUdpSocket when not in QUdpSocket::BoundState");
1375     QNetworkInterface iface2 = udpSocket.multicastInterface();
1376     if (!setProxy) {
1377         QVERIFY(iface2.isValid());
1378         QCOMPARE(iface.name(), iface2.name());
1379     } else {
1380         QVERIFY(!iface2.isValid());
1381     }
1382 }
1383 
1384 void tst_QUdpSocket::multicast_data()
1385 {
1386     QHostAddress anyAddress = QHostAddress(QHostAddress::AnyIPv4);
1387     QHostAddress groupAddress = QHostAddress("239.255.118.62");
1388     QHostAddress any6Address = QHostAddress(QHostAddress::AnyIPv6);
1389     QHostAddress group6Address = QHostAddress("FF01::114");
1390     QHostAddress dualAddress = QHostAddress(QHostAddress::Any);
1391 
1392     QTest::addColumn<QHostAddress>("bindAddress");
1393     QTest::addColumn<bool>("bindResult");
1394     QTest::addColumn<QHostAddress>("groupAddress");
1395     QTest::addColumn<bool>("joinResult");
1396     QTest::newRow("valid bind, group ipv4 address") << anyAddress << true << groupAddress << true;
1397     QTest::newRow("valid bind, invalid group ipv4 address") << anyAddress << true << anyAddress << false;
1398     QTest::newRow("same bind, group ipv4 address") << groupAddress << true << groupAddress << true;
1399     QTest::newRow("valid bind, group ipv6 address") << any6Address << true << group6Address << true;
1400     QTest::newRow("valid bind, invalid group ipv6 address") << any6Address << true << any6Address << false;
1401     QTest::newRow("same bind, group ipv6 address") << group6Address << false << group6Address << false;
1402     QTest::newRow("dual bind, group ipv4 address") << dualAddress << true << groupAddress << false;
1403     QTest::newRow("dual bind, group ipv6 address") << dualAddress << true << group6Address << true;
1404 }
1405 
1406 void tst_QUdpSocket::multicast()
1407 {
1408 #ifdef Q_OS_WINRT
1409     QSKIP("WinRT does not support multicast.");
1410 #endif
1411     QFETCH_GLOBAL(bool, setProxy);
1412     QFETCH(QHostAddress, bindAddress);
1413     QFETCH(bool, bindResult);
1414     QFETCH(QHostAddress, groupAddress);
1415     QFETCH(bool, joinResult);
1416     if (groupAddress.protocol() == QAbstractSocket::IPv6Protocol && !QtNetworkSettings::hasIPv6())
1417         QSKIP("system doesn't support ipv6!");
1418     if (setProxy) {
1419         // UDP multicast does not work with proxies
1420         return;
1421     }
1422 
1423     // QEMU is missing some syscalls for ipv6 udp multicasting
1424     if (m_skipUnsupportedIPv6Tests) {
1425         if (groupAddress.protocol() == QAbstractSocket::IPv6Protocol) {
1426             QSKIP("QEMU does not support ipv6 udp multicasting");
1427         }
1428     }
1429 
1430     QUdpSocket receiver;
1431 #ifdef FORCE_SESSION
1432     receiver.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1433 #endif
1434 
1435     // bind first, then verify that we can join the multicast group
1436     QVERIFY2(receiver.bind(bindAddress, 0) == bindResult,
1437              qPrintable(receiver.errorString()));
1438     if (!bindResult)
1439         return;
1440 
1441     if (bindAddress == QHostAddress::Any && groupAddress.protocol() == QAbstractSocket::IPv4Protocol) {
1442         QCOMPARE(joinResult, false);
1443         QTest::ignoreMessage(QtWarningMsg,
1444                              "QAbstractSocket: cannot bind to QHostAddress::Any (or an IPv6 address) and join an IPv4 multicast group;"
1445                              " bind to QHostAddress::AnyIPv4 instead if you want to do this");
1446     }
1447     QVERIFY2(receiver.joinMulticastGroup(groupAddress) == joinResult,
1448              qPrintable(receiver.errorString()));
1449     if (!joinResult)
1450         return;
1451 
1452     QList<QByteArray> datagrams = QList<QByteArray>()
1453                                   << QByteArray("0123")
1454                                   << QByteArray("4567")
1455                                   << QByteArray("89ab")
1456                                   << QByteArray("cdef");
1457 
1458     QUdpSocket sender;
1459 #ifdef FORCE_SESSION
1460     sender.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1461 #endif
1462     sender.bind();
1463     foreach (const QByteArray &datagram, datagrams) {
1464         QCOMPARE(int(sender.writeDatagram(datagram, groupAddress, receiver.localPort())),
1465                  int(datagram.size()));
1466     }
1467 
1468     QVERIFY2(receiver.waitForReadyRead(), QtNetworkSettings::msgSocketError(receiver).constData());
1469     QVERIFY(receiver.hasPendingDatagrams());
1470     QList<QByteArray> receivedDatagrams;
1471     while (receiver.hasPendingDatagrams()) {
1472         QNetworkDatagram dgram = receiver.receiveDatagram();
1473         receivedDatagrams << dgram.data();
1474 
1475         QVERIFY2(allAddresses.contains(dgram.senderAddress()),
1476                 dgram.senderAddress().toString().toLatin1());
1477         QCOMPARE(dgram.senderPort(), int(sender.localPort()));
1478         if (!dgram.destinationAddress().isNull()) {
1479             QCOMPARE(dgram.destinationAddress(), groupAddress);
1480             QCOMPARE(dgram.destinationPort(), int(receiver.localPort()));
1481         }
1482 
1483         int ttl = dgram.hopLimit();
1484         if (ttl != -1)
1485             QVERIFY(ttl != 0);
1486     }
1487     QCOMPARE(receivedDatagrams, datagrams);
1488 
1489     QVERIFY2(receiver.leaveMulticastGroup(groupAddress), qPrintable(receiver.errorString()));
1490 }
1491 
1492 void tst_QUdpSocket::echo_data()
1493 {
1494     QTest::addColumn<bool>("connect");
1495     QTest::newRow("writeDatagram") << false;
1496     QTest::newRow("write") << true;
1497 }
1498 
1499 void tst_QUdpSocket::echo()
1500 {
1501     QFETCH(bool, connect);
1502     QHostInfo info = QHostInfo::fromName(QtNetworkSettings::serverName());
1503     QVERIFY(info.addresses().count());
1504     QHostAddress remote = info.addresses().first();
1505 
1506     QUdpSocket sock;
1507 #ifdef FORCE_SESSION
1508     sock.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1509 #endif
1510     if (connect) {
1511         sock.connectToHost(remote, 7);
1512         QVERIFY(sock.waitForConnected(10000));
1513     } else {
1514         sock.bind();
1515     }
1516     QByteArray out(30, 'x');
1517     QByteArray in;
1518     int successes = 0;
1519     for (int i=0;i<10;i++) {
1520         if (connect) {
1521             sock.write(out);
1522         } else {
1523             sock.writeDatagram(out, remote, 7);
1524         }
1525         if (sock.waitForReadyRead(1000)) {
1526             while (sock.hasPendingDatagrams()) {
1527                 QHostAddress from;
1528                 quint16 port;
1529                 if (connect) {
1530                     in = sock.read(sock.pendingDatagramSize());
1531                 } else {
1532                     in.resize(sock.pendingDatagramSize());
1533                     sock.readDatagram(in.data(), in.length(), &from, &port);
1534                 }
1535                 if (in==out)
1536                     successes++;
1537             }
1538         }
1539         if (!sock.isValid())
1540             QFAIL(sock.errorString().toLatin1().constData());
1541         qDebug() << "packets in" << successes << "out" << i;
1542         QTest::qWait(50); //choke to avoid triggering flood/DDoS protections on echo service
1543     }
1544     QVERIFY2(successes >= 9, QByteArray::number(successes).constData());
1545 }
1546 
1547 void tst_QUdpSocket::linkLocalIPv6()
1548 {
1549     QFETCH_GLOBAL(bool, setProxy);
1550     if (setProxy)
1551         return;
1552 
1553     QList <QHostAddress> addresses;
1554     QSet <QString> scopes;
1555     QHostAddress localMask("fe80::");
1556     foreach (const QNetworkInterface& iface, QNetworkInterface::allInterfaces()) {
1557         //Windows preallocates link local addresses to interfaces that are down.
1558         //These may or may not work depending on network driver
1559         if (iface.flags() & QNetworkInterface::IsUp) {
1560             // Do not add the Teredo Tunneling Pseudo Interface on Windows.
1561             if (iface.humanReadableName().contains("Teredo"))
1562                 continue;
1563             foreach (QNetworkAddressEntry addressEntry, iface.addressEntries()) {
1564                 QHostAddress addr(addressEntry.ip());
1565                 if (!addr.scopeId().isEmpty() && addr.isInSubnet(localMask, 64)) {
1566                     scopes << addr.scopeId();
1567                     addresses << addr;
1568                     qDebug() << addr;
1569                 }
1570             }
1571         }
1572     }
1573     if (addresses.isEmpty())
1574         QSKIP("No IPv6 link local addresses");
1575 
1576     QList <QUdpSocket*> sockets;
1577     quint16 port = 0;
1578     foreach (const QHostAddress& addr, addresses) {
1579         QUdpSocket *s = new QUdpSocket;
1580         QVERIFY2(s->bind(addr, port), addr.toString().toLatin1()
1581                  + '/' + QByteArray::number(port) + ": " + qPrintable(s->errorString()));
1582         port = s->localPort(); //bind same port, different networks
1583         sockets << s;
1584     }
1585 
1586     QUdpSocket neutral;
1587     QVERIFY(neutral.bind(QHostAddress(QHostAddress::AnyIPv6)));
1588     QSignalSpy neutralReadSpy(&neutral, SIGNAL(readyRead()));
1589 
1590     QByteArray testData("hello");
1591     foreach (QUdpSocket *s, sockets) {
1592         QSignalSpy spy(s, SIGNAL(readyRead()));
1593 
1594         neutralReadSpy.clear();
1595         QVERIFY(s->writeDatagram(testData, s->localAddress(), neutral.localPort()));
1596         QTRY_VERIFY(neutralReadSpy.count() > 0); //note may need to accept a firewall prompt
1597 
1598         QNetworkDatagram dgram = neutral.receiveDatagram(testData.length() * 2);
1599         QVERIFY(dgram.isValid());
1600         QCOMPARE(dgram.senderAddress(), s->localAddress());
1601         QCOMPARE(dgram.senderPort(), int(s->localPort()));
1602         QCOMPARE(dgram.data().length(), testData.length());
1603         QCOMPARE(dgram.data(), testData);
1604 
1605         QVERIFY(neutral.writeDatagram(dgram.makeReply(testData)));
1606         QTRY_VERIFY(spy.count() > 0); //note may need to accept a firewall prompt
1607 
1608         dgram = s->receiveDatagram(testData.length() * 2);
1609         QCOMPARE(dgram.data(), testData);
1610 
1611         //sockets bound to other interfaces shouldn't have received anything
1612         foreach (QUdpSocket *s2, sockets) {
1613             QCOMPARE((int)s2->bytesAvailable(), 0);
1614         }
1615 
1616         //Sending to the same address with different scope should normally fail
1617         //However it will pass if there is a route between two interfaces,
1618         //e.g. connected to a home/office network via wired and wireless interfaces
1619         //which is a reasonably common case.
1620         //So this is not auto tested.
1621     }
1622     qDeleteAll(sockets);
1623 }
1624 
1625 void tst_QUdpSocket::linkLocalIPv4()
1626 {
1627     QFETCH_GLOBAL(bool, setProxy);
1628     if (setProxy)
1629         return;
1630 
1631     QList <QHostAddress> addresses;
1632     QHostAddress localMask("169.254.0.0");
1633     foreach (const QNetworkInterface& iface, QNetworkInterface::allInterfaces()) {
1634         //Windows preallocates link local addresses to interfaces that are down.
1635         //These may or may not work depending on network driver (they do not work for the Bluetooth PAN driver)
1636         if (iface.flags() & QNetworkInterface::IsUp) {
1637             // Do not add the Teredo Tunneling Pseudo Interface on Windows.
1638             if (iface.humanReadableName().contains("Teredo"))
1639                 continue;
1640             foreach (QNetworkAddressEntry addr, iface.addressEntries()) {
1641                 if (addr.ip().isInSubnet(localMask, 16)) {
1642                     addresses << addr.ip();
1643                     qDebug() << addr.ip();
1644                 }
1645             }
1646         }
1647     }
1648     if (addresses.isEmpty())
1649         QSKIP("No IPv4 link local addresses");
1650 
1651     QList <QUdpSocket*> sockets;
1652     quint16 port = 0;
1653     foreach (const QHostAddress& addr, addresses) {
1654         QUdpSocket *s = new QUdpSocket;
1655         QVERIFY2(s->bind(addr, port), qPrintable(s->errorString()));
1656         port = s->localPort(); //bind same port, different networks
1657         sockets << s;
1658     }
1659 
1660     QUdpSocket neutral;
1661     QVERIFY(neutral.bind(QHostAddress(QHostAddress::AnyIPv4)));
1662 
1663     QByteArray testData("hello");
1664     foreach (QUdpSocket *s, sockets) {
1665         QVERIFY(s->writeDatagram(testData, s->localAddress(), neutral.localPort()));
1666         QVERIFY2(neutral.waitForReadyRead(10000), QtNetworkSettings::msgSocketError(neutral).constData());
1667 
1668         QVERIFY2(s->waitForReadyRead(10000), QtNetworkSettings::msgSocketError(*s).constData());
1669         QNetworkDatagram dgram = neutral.receiveDatagram(testData.length() * 2);
1670         QVERIFY(dgram.isValid());
1671         QCOMPARE(dgram.senderAddress(), s->localAddress());
1672         QCOMPARE(dgram.senderPort(), int(s->localPort()));
1673         QCOMPARE(dgram.data().length(), testData.length());
1674         QCOMPARE(dgram.data(), testData);
1675 
1676         QVERIFY(neutral.writeDatagram(dgram.makeReply(testData)));
1677 
1678         dgram = s->receiveDatagram(testData.length() * 2);
1679         QVERIFY(dgram.isValid());
1680         QCOMPARE(dgram.data(), testData);
1681 
1682         //sockets bound to other interfaces shouldn't have received anything
1683         foreach (QUdpSocket *s2, sockets) {
1684             QCOMPARE((int)s2->bytesAvailable(), 0);
1685         }
1686     }
1687     qDeleteAll(sockets);
1688 }
1689 
1690 void tst_QUdpSocket::readyRead()
1691 {
1692     QFETCH_GLOBAL(bool, setProxy);
1693     if (setProxy)
1694         return;
1695 
1696     char buf[1];
1697     QUdpSocket sender, receiver;
1698 #ifdef FORCE_SESSION
1699     sender.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1700     receiver.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1701 #endif
1702 
1703     QVERIFY(receiver.bind(QHostAddress(QHostAddress::AnyIPv4), 0));
1704     quint16 port = receiver.localPort();
1705     QVERIFY(port != 0);
1706 
1707     QSignalSpy spy(&receiver, SIGNAL(readyRead()));
1708 
1709     // send a datagram to that port
1710     sender.writeDatagram("aa", makeNonAny(receiver.localAddress()), port);
1711 
1712     // wait a little
1713     // if QTBUG-43857 is still going, we'll live-lock on socket notifications from receiver's socket
1714     QTest::qWait(100);
1715 
1716     // make sure only one signal was emitted
1717     QCOMPARE(spy.count(), 1);
1718     QVERIFY(receiver.hasPendingDatagrams());
1719     QCOMPARE(receiver.bytesAvailable(), qint64(2));
1720     QCOMPARE(receiver.pendingDatagramSize(), qint64(2));
1721 
1722     // write another datagram
1723     sender.writeDatagram("ab", makeNonAny(receiver.localAddress()), port);
1724 
1725     // no new signal should be emitted because we haven't read the first datagram yet
1726     QTest::qWait(100);
1727     QCOMPARE(spy.count(), 1);
1728     QVERIFY(receiver.hasPendingDatagrams());
1729     QVERIFY(receiver.bytesAvailable() >= 1);    // most likely is 1, but it could be 1 + 2 in the future
1730     QCOMPARE(receiver.pendingDatagramSize(), qint64(2));
1731 
1732     // read all the datagrams (we could read one only, but we can't be sure the OS is queueing)
1733     while (receiver.hasPendingDatagrams())
1734         receiver.readDatagram(buf, sizeof buf);
1735 
1736     // write a new datagram and ensure the signal is emitted now
1737     sender.writeDatagram("abc", makeNonAny(receiver.localAddress()), port);
1738     QTest::qWait(100);
1739     QCOMPARE(spy.count(), 2);
1740     QVERIFY(receiver.hasPendingDatagrams());
1741     QCOMPARE(receiver.bytesAvailable(), qint64(3));
1742     QCOMPARE(receiver.pendingDatagramSize(), qint64(3));
1743 }
1744 
1745 void tst_QUdpSocket::readyReadForEmptyDatagram()
1746 {
1747     QFETCH_GLOBAL(bool, setProxy);
1748     if (setProxy)
1749         return;
1750 
1751     QUdpSocket sender, receiver;
1752 #ifdef FORCE_SESSION
1753     sender.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1754     receiver.setProperty("_q_networksession", QVariant::fromValue(networkSession));
1755 #endif
1756 
1757     QVERIFY(receiver.bind(QHostAddress(QHostAddress::AnyIPv4), 0));
1758     quint16 port = receiver.localPort();
1759     QVERIFY(port != 0);
1760 
1761     connect(&receiver, SIGNAL(readyRead()), SLOT(empty_readyReadSlot()));
1762 
1763     // send an empty datagram to that port
1764     sender.writeDatagram("", makeNonAny(receiver.localAddress()), port);
1765 
1766     // ensure that we got a readyRead, despite bytesAvailable() == 0
1767     QTestEventLoop::instance().enterLoop(1);
1768     QVERIFY(!QTestEventLoop::instance().timeout());
1769 
1770     char buf[1];
1771     QVERIFY(receiver.hasPendingDatagrams());
1772     QCOMPARE(receiver.pendingDatagramSize(), qint64(0));
1773     QCOMPARE(receiver.bytesAvailable(), qint64(0));
1774     QCOMPARE(receiver.readDatagram(buf, sizeof buf), qint64(0));
1775 }
1776 
1777 void tst_QUdpSocket::async_readDatagramSlot()
1778 {
1779     char buf[1];
1780     QVERIFY(m_asyncReceiver->hasPendingDatagrams());
1781     QCOMPARE(m_asyncReceiver->pendingDatagramSize(), qint64(1));
1782     QCOMPARE(m_asyncReceiver->bytesAvailable(), qint64(1));
1783     QCOMPARE(m_asyncReceiver->readDatagram(buf, sizeof(buf)), qint64(1));
1784 
1785     if (buf[0] == '2') {
1786         QTestEventLoop::instance().exitLoop();
1787         return;
1788     }
1789 
1790     m_asyncSender->writeDatagram("2", makeNonAny(m_asyncReceiver->localAddress()), m_asyncReceiver->localPort());
1791     // wait a little to ensure that the datagram we've just sent
1792     // will be delivered on receiver side.
1793     QTest::qSleep(100);
1794 }
1795 
1796 void tst_QUdpSocket::asyncReadDatagram()
1797 {
1798     QFETCH_GLOBAL(bool, setProxy);
1799     if (setProxy)
1800         return;
1801 
1802     m_asyncSender = new QUdpSocket;
1803     m_asyncReceiver = new QUdpSocket;
1804 #ifdef FORCE_SESSION
1805     m_asyncSender->setProperty("_q_networksession", QVariant::fromValue(networkSession));
1806     m_asyncReceiver->setProperty("_q_networksession", QVariant::fromValue(networkSession));
1807 #endif
1808 
1809     QVERIFY(m_asyncReceiver->bind(QHostAddress(QHostAddress::AnyIPv4), 0));
1810     quint16 port = m_asyncReceiver->localPort();
1811     QVERIFY(port != 0);
1812 
1813     QSignalSpy spy(m_asyncReceiver, SIGNAL(readyRead()));
1814     connect(m_asyncReceiver, SIGNAL(readyRead()), SLOT(async_readDatagramSlot()));
1815 
1816     m_asyncSender->writeDatagram("1", makeNonAny(m_asyncReceiver->localAddress()), port);
1817 
1818     QTestEventLoop::instance().enterLoop(1);
1819 
1820     QVERIFY(!QTestEventLoop::instance().timeout());
1821     QCOMPARE(spy.count(), 2);
1822 
1823     delete m_asyncSender;
1824     delete m_asyncReceiver;
1825 }
1826 
1827 void tst_QUdpSocket::writeInHostLookupState()
1828 {
1829     QFETCH_GLOBAL(bool, setProxy);
1830     if (setProxy)
1831         return;
1832 
1833     QUdpSocket socket;
1834     socket.connectToHost("nosuchserver.qt-project.org", 80);
1835     QCOMPARE(socket.state(), QUdpSocket::HostLookupState);
1836     QVERIFY(!socket.putChar('0'));
1837 }
1838 
1839 QTEST_MAIN(tst_QUdpSocket)
1840 #include "tst_qudpsocket.moc"
