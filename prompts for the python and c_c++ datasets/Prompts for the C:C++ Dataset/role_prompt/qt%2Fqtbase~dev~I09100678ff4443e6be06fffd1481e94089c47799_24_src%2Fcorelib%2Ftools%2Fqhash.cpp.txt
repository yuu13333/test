I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Copyright (C) 2012 Giuseppe D'Angelo <dangelog@gmail.com>.
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 // for rand_s, _CRT_RAND_S must be #defined before #including stdlib.h.
43 // put it at the beginning so some indirect inclusion doesn't break it
44 #ifndef _CRT_RAND_S
45 #define _CRT_RAND_S
46 #endif
47 #include <stdlib.h>
48 #include <stdint.h>
49 
50 #include "qhash.h"
51 
52 #ifdef truncate
53 #undef truncate
54 #endif
55 
56 #include <qbitarray.h>
57 #include <qstring.h>
58 #include <qglobal.h>
59 #include <qbytearray.h>
60 #include <qdatetime.h>
61 #include <qbasicatomic.h>
62 #include <qendian.h>
63 #include <private/qsimd_p.h>
64 
65 #ifndef QT_BOOTSTRAPPED
66 #include <qcoreapplication.h>
67 #include <qrandom.h>
68 #endif // QT_BOOTSTRAPPED
69 
70 #include <limits.h>
71 
72 QT_BEGIN_NAMESPACE
73 
74 // We assume that pointers and size_t have the same size. If that assumption should fail
75 // on a platform the code selecting the different methods below needs to be fixed.
76 static_assert(sizeof(size_t) == QT_POINTER_SIZE, "size_t and pointers have different size.");
77 
78 /*
79  * Hashing for memory segments is based on the public domain MurmurHash2 by
80  * Austin Appleby. See http://murmurhash.googlepages.com/
81  */
82 #if QT_POINTER_SIZE == 4
83 
84 static inline uint murmurhash(const void *key, uint len, uint seed) noexcept
85 {
86     // 'm' and 'r' are mixing constants generated offline.
87     // They're not really 'magic', they just happen to work well.
88 
89     const unsigned int m = 0x5bd1e995;
90     const int r = 24;
91 
92     // Initialize the hash to a 'random' value
93 
94     unsigned int h = seed ^ len;
95 
96     // Mix 4 bytes at a time into the hash
97 
98     const unsigned char *data = reinterpret_cast<const unsigned char *>(key);
99     const unsigned char *end = data + (len & ~3);
100 
101     while (data != end) {
102         size_t k;
103         memcpy(&k, data, sizeof(uint));
104 
105         k *= m;
106         k ^= k >> r;
107         k *= m;
108 
109         h *= m;
110         h ^= k;
111 
112         data += 4;
113     }
114 
115     // Handle the last few bytes of the input array
116     len &= 3;
117     if (len) {
118         unsigned int k = 0;
119         end += len;
120 
121         while (data != end) {
122             k <<= 8;
123             k |= *data;
124             ++data;
125         }
126         h ^= k;
127         h *= m;
128     }
129 
130     // Do a few final mixes of the hash to ensure the last few
131     // bytes are well-incorporated.
132 
133     h ^= h >> 13;
134     h *= m;
135     h ^= h >> 15;
136 
137     return h;
138 }
139 
140 #else
141 
142 static inline uint64_t murmurhash(const void *key, uint64_t len, uint64_t seed) noexcept
143 {
144     const uint64_t m = 0xc6a4a7935bd1e995ULL;
145     const int r = 47;
146 
147     uint64_t h = seed ^ (len * m);
148 
149     const unsigned char *data = reinterpret_cast<const unsigned char *>(key);
150     const unsigned char *end = data + (len & ~7ul);
151 
152     while (data != end) {
153         uint64_t k;
154         memcpy(&k, data, sizeof(uint64_t));
155 
156         k *= m;
157         k ^= k >> r;
158         k *= m;
159 
160         h ^= k;
161         h *= m;
162 
163         data += 8;
164     }
165 
166     len &= 7;
167     if (len) {
168         // handle the last few bytes of input
169         size_t k = 0;
170         end += len;
171 
172         while (data != end) {
173             k <<= 8;
174             k |= *data;
175             ++data;
176         }
177         h ^= k;
178         h *= m;
179     }
180 
181     h ^= h >> r;
182     h *= m;
183     h ^= h >> r;
184 
185     return h;
186 }
187 
188 #endif
189 
190 #if QT_POINTER_SIZE == 8
191 // This is an inlined version of the SipHash implementation that is
192 // trying to avoid some memcpy's from uint64 to uint8[] and back.
193 //
194 // The original algorithm uses a 128bit seed. Our public API only allows
195 // for a 64bit seed, so we mix in the length of the string to get some more
196 // bits for the seed.
197 //
198 // Use SipHash-1-2, which has similar performance characteristics as
199 // stablehash() above, instead of the SipHash-2-4 default
200 #define cROUNDS 1
201 #define dROUNDS 2
202 
203 #define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))
204 
205 #define SIPROUND                                                               \
206   do {                                                                         \
207     v0 += v1;                                                                  \
208     v1 = ROTL(v1, 13);                                                         \
209     v1 ^= v0;                                                                  \
210     v0 = ROTL(v0, 32);                                                         \
211     v2 += v3;                                                                  \
212     v3 = ROTL(v3, 16);                                                         \
213     v3 ^= v2;                                                                  \
214     v0 += v3;                                                                  \
215     v3 = ROTL(v3, 21);                                                         \
216     v3 ^= v0;                                                                  \
217     v2 += v1;                                                                  \
218     v1 = ROTL(v1, 17);                                                         \
219     v1 ^= v2;                                                                  \
220     v2 = ROTL(v2, 32);                                                         \
221   } while (0)
222 
223 
224 static uint64_t siphash(const uint8_t *in, uint64_t inlen, const uint64_t seed)
225 {
226     /* "somepseudorandomlygeneratedbytes" */
227     uint64_t v0 = 0x736f6d6570736575ULL;
228     uint64_t v1 = 0x646f72616e646f6dULL;
229     uint64_t v2 = 0x6c7967656e657261ULL;
230     uint64_t v3 = 0x7465646279746573ULL;
231     uint64_t b;
232     uint64_t k0 = seed;
233     uint64_t k1 = seed ^ inlen;
234     int i;
235     const uint8_t *end = in + (inlen & ~7ULL);
236     const int left = inlen & 7;
237     b = inlen << 56;
238     v3 ^= k1;
239     v2 ^= k0;
240     v1 ^= k1;
241     v0 ^= k0;
242 
243     for (; in != end; in += 8) {
244         uint64_t m = qFromUnaligned<uint64_t>(in);
245         v3 ^= m;
246 
247         for (i = 0; i < cROUNDS; ++i)
248             SIPROUND;
249 
250         v0 ^= m;
251     }
252 
253 
254 #if defined(Q_CC_GNU) && Q_CC_GNU >= 700
255     QT_WARNING_DISABLE_GCC("-Wimplicit-fallthrough")
256 #endif
257     switch (left) {
258     case 7:
259         b |= ((uint64_t)in[6]) << 48;
260     case 6:
261         b |= ((uint64_t)in[5]) << 40;
262     case 5:
263         b |= ((uint64_t)in[4]) << 32;
264     case 4:
265         b |= ((uint64_t)in[3]) << 24;
266     case 3:
267         b |= ((uint64_t)in[2]) << 16;
268     case 2:
269         b |= ((uint64_t)in[1]) << 8;
270     case 1:
271         b |= ((uint64_t)in[0]);
272         break;
273     case 0:
274         break;
275     }
276 
277     v3 ^= b;
278 
279     for (i = 0; i < cROUNDS; ++i)
280         SIPROUND;
281 
282     v0 ^= b;
283 
284     v2 ^= 0xff;
285 
286     for (i = 0; i < dROUNDS; ++i)
287         SIPROUND;
288 
289     b = v0 ^ v1 ^ v2 ^ v3;
290     return b;
291 }
292 #else
293 // This is a "SipHash" implementation adopted for 32bit platforms. It performs
294 // basically the same operations as the 64bit version using 4 byte at a time
295 // instead of 8.
296 //
297 // To make this work, we also need to change the constants for the mixing
298 // rotations in ROTL. We're simply using half of the 64bit constants, rounded up
299 // for odd numbers.
300 //
301 // For the v0-v4 constants, simply use the first four bytes of the 64 bit versions.
302 //
303 // Use SipHash-1-2, which has similar performance characteristics as
304 // stablehash() above, instead of the SipHash-2-4 default
305 #define cROUNDS 1
306 #define dROUNDS 2
307 
308 #define ROTL(x, b) (uint32_t)(((x) << (b)) | ((x) >> (32 - (b))))
309 
310 #define SIPROUND                                                               \
311   do {                                                                         \
312     v0 += v1;                                                                  \
313     v1 = ROTL(v1, 7);                                                          \
314     v1 ^= v0;                                                                  \
315     v0 = ROTL(v0, 16);                                                         \
316     v2 += v3;                                                                  \
317     v3 = ROTL(v3, 8);                                                          \
318     v3 ^= v2;                                                                  \
319     v0 += v3;                                                                  \
320     v3 = ROTL(v3, 11);                                                         \
321     v3 ^= v0;                                                                  \
322     v2 += v1;                                                                  \
323     v1 = ROTL(v1, 9);                                                          \
324     v1 ^= v2;                                                                  \
325     v2 = ROTL(v2, 16);                                                         \
326   } while (0)
327 
328 
329 static uint siphash(const uint8_t *in, uint inlen, const uint seed)
330 {
331     /* "somepseudorandomlygeneratedbytes" */
332     uint v0 = 0x736f6d65U;
333     uint v1 = 0x646f7261U;
334     uint v2 = 0x6c796765U;
335     uint v3 = 0x74656462U;
336     uint b;
337     uint k0 = seed;
338     uint k1 = seed ^ inlen;
339     int i;
340     const uint8_t *end = in + (inlen & ~3ULL);
341     const int left = inlen & 3;
342     b = inlen << 24;
343     v3 ^= k1;
344     v2 ^= k0;
345     v1 ^= k1;
346     v0 ^= k0;
347 
348     for (; in != end; in += 4) {
349         uint m = qFromUnaligned<uint>(in);
350         v3 ^= m;
351 
352         for (i = 0; i < cROUNDS; ++i)
353             SIPROUND;
354 
355         v0 ^= m;
356     }
357 
358 #if defined(Q_CC_GNU) && Q_CC_GNU >= 700
359     QT_WARNING_DISABLE_GCC("-Wimplicit-fallthrough")
360 #endif
361     switch (left) {
362     case 3:
363         b |= ((uint)in[2]) << 16;
364     case 2:
365         b |= ((uint)in[1]) << 8;
366     case 1:
367         b |= ((uint)in[0]);
368         break;
369     case 0:
370         break;
371     }
372 
373     v3 ^= b;
374 
375     for (i = 0; i < cROUNDS; ++i)
376         SIPROUND;
377 
378     v0 ^= b;
379 
380     v2 ^= 0xff;
381 
382     for (i = 0; i < dROUNDS; ++i)
383         SIPROUND;
384 
385     b = v0 ^ v1 ^ v2 ^ v3;
386     return b;
387 }
388 #endif
389 
390 
391 #if QT_COMPILER_SUPPORTS_HERE(AES) && QT_COMPILER_SUPPORTS_HERE(SSE4_2) && \
392     !(defined(__SANITIZE_ADDRESS__) || defined(__SANITIZE_THREAD__))
393 #  define AESHASH
394 
395 QT_FUNCTION_TARGET(AES)
396 static size_t aeshash(const uchar *p, size_t len, size_t seed) Q_DECL_NOTHROW
397 {
398     __m128i key;
399     if (sizeof(size_t) == 8) {
400 #ifdef Q_PROCESSOR_X86_64
401         quint64 seededlen = seed ^ len;
402         __m128i mseed = _mm_cvtsi64_si128(seed);
403         key = _mm_insert_epi64(mseed, seededlen, 1);
404 #endif
405     } else {
406         quint32 replicated_len = quint16(len) | (quint32(quint16(len)) << 16);
407         __m128i mseed = _mm_cvtsi32_si128(seed);
408         key = _mm_insert_epi32(mseed, replicated_len, 1);
409         key = _mm_unpacklo_epi64(key, key);
410     }
411 
412     // This is inspired by the algorithm in the Go language. See:
413     // https://github.com/golang/go/blob/894abb5f680c040777f17f9f8ee5a5ab3a03cb94/src/runtime/asm_386.s#L902
414     // https://github.com/golang/go/blob/894abb5f680c040777f17f9f8ee5a5ab3a03cb94/src/runtime/asm_amd64.s#L903
415     //
416     // Even though we're using the AESENC instruction from the CPU, this code
417     // is not encryption and this routine makes no claim to be
418     // cryptographically secure. We're simply using the instruction that performs
419     // the scrambling round (step 3 in [1]) because it's just very good at
420     // spreading the bits around.
421     //
422     // [1] https://en.wikipedia.org/wiki/Advanced_Encryption_Standard#High-level_description_of_the_algorithm
423 
424     // hash 16 bytes, running 3 scramble rounds of AES on itself (like label "final1")
425     const auto hash16bytes = [](__m128i &state0, __m128i data) QT_FUNCTION_TARGET(AES) {
426         state0 = _mm_xor_si128(state0, data);
427         state0 = _mm_aesenc_si128(state0, state0);
428         state0 = _mm_aesenc_si128(state0, state0);
429         state0 = _mm_aesenc_si128(state0, state0);
430     };
431 
432     __m128i state0 = key;
433     auto src = reinterpret_cast<const __m128i *>(p);
434 
435     if (len < 16)
436         goto lt16;
437     if (len < 32)
438         goto lt32;
439 
440     // rounds of 32 bytes
441     {
442         // Make state1 = ~state0:
443         __m128i one = _mm_cmpeq_epi64(key, key);
444         __m128i state1 = _mm_xor_si128(state0, one);
445 
446         // do simplified rounds of 32 bytes: unlike the Go code, we only
447         // scramble twice and we keep 256 bits of state
448         const auto srcend = src + (len / 32);
449         while (src < srcend) {
450             __m128i data0 = _mm_loadu_si128(src);
451             __m128i data1 = _mm_loadu_si128(src + 1);
452             data0 = _mm_xor_si128(data0, state0);
453             data1 = _mm_xor_si128(data1, state1);
454             state0 = _mm_aesenc_si128(state0, state0);
455             state1 = _mm_aesenc_si128(state1, state1);
456             state0 = _mm_aesenc_si128(state0, state0);
457             state1 = _mm_aesenc_si128(state1, state1);
458             src += 2;
459         }
460         state0 = _mm_xor_si128(state0, state1);
461     }
462     len &= 0x1f;
463 
464     // do we still have 16 or more bytes?
465     if (len & 0x10) {
466 lt32:
467         __m128i data = _mm_loadu_si128(src);
468         hash16bytes(state0, data);
469         ++src;
470     }
471     len &= 0xf;
472 
473 lt16:
474     if (len) {
475         // load the last chunk of data
476         // We're going to load 16 bytes and mask zero the part we don't care
477         // (the hash of a short string is different from the hash of a longer
478         // including NULLs at the end because the length is in the key)
479         // WARNING: this may produce valgrind warnings, but it's safe
480 
481         __m128i data;
482 
483         if (Q_LIKELY(quintptr(src + 1) & 0xff0)) {
484             // same page, we definitely can't fault:
485             // load all 16 bytes and mask off the bytes past the end of the source
486             static const qint8 maskarray[] = {
487                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
488                 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
489                 };
490             __m128i mask = _mm_loadu_si128(reinterpret_cast<const __m128i *>(maskarray + 15 - len));
491             data = _mm_loadu_si128(src);
492             data = _mm_and_si128(data, mask);
493         } else {
494             // too close to the end of the page, it could fault:
495             // load 16 bytes ending at the data end, then shuffle them to the beginning
496             static const qint8 shufflecontrol[] = {
497                 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
498                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
499             };
500             __m128i control = _mm_loadu_si128(reinterpret_cast<const __m128i *>(shufflecontrol + 15 - len));
501             p = reinterpret_cast<const uchar *>(src - 1);
502             data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(p + len));
503             data = _mm_shuffle_epi8(data, control);
504         }
505 
506         hash16bytes(state0, data);
507     }
508 
509     // extract state0
510 #  if QT_POINTER_SIZE == 8
511     return _mm_cvtsi128_si64(state0);
512 #  else
513     return _mm_cvtsi128_si32(state0);
514 #  endif
515 }
516 #endif
517 
518 size_t qHashBits(const void *p, size_t size, size_t seed) noexcept
519 {
520 
521     if (size <= QT_POINTER_SIZE)
522         return murmurhash(p, size, seed);
523 
524 #ifdef AESHASH
525     if (qCpuHasFeature(AES) && qCpuHasFeature(SSE4_2))
526         return aeshash(reinterpret_cast<const uchar *>(p), size, seed);
527 #endif
528 
529     return siphash(reinterpret_cast<const uchar *>(p), size, seed);
530 }
531 
532 size_t qHash(const QByteArray &key, size_t seed) noexcept
533 {
534     return qHashBits(key.constData(), size_t(key.size()), seed);
535 }
536 
537 #if QT_STRINGVIEW_LEVEL < 2
538 size_t qHash(const QString &key, size_t seed) noexcept
539 {
540     return qHashBits(key.unicode(), size_t(key.size()), seed);
541 }
542 
543 size_t qHash(const QStringRef &key, size_t seed) noexcept
544 {
545     return qHashBits(key.unicode(), size_t(key.size()), seed);
546 }
547 #endif
548 
549 size_t qHash(QStringView key, size_t seed) noexcept
550 {
551     return qHashBits(key.data(), key.size(), seed);
552 }
553 
554 size_t qHash(const QBitArray &bitArray, size_t seed) noexcept
555 {
556     int m = bitArray.d.size() - 1;
557     size_t result = qHashBits(reinterpret_cast<const uchar *>(bitArray.d.constData()), size_t(qMax(0, m)), seed);
558 
559     // deal with the last 0 to 7 bits manually, because we can't trust that
560     // the padding is initialized to 0 in bitArray.d
561     int n = bitArray.size();
562     if (n & 0x7)
563         result = ((result << 4) + bitArray.d.at(m)) & ((1 << n) - 1);
564     return result;
565 }
566 
567 size_t qHash(QLatin1String key, size_t seed) noexcept
568 {
569     return qHashBits(reinterpret_cast<const uchar *>(key.data()), size_t(key.size()), seed);
570 }
571 
572 /*!
573     \internal
574 */
575 static uint qt_create_qhash_seed()
576 {
577     uint seed = 0;
578 
579 #ifndef QT_BOOTSTRAPPED
580     QByteArray envSeed = qgetenv("QT_HASH_SEED");
581     if (!envSeed.isNull()) {
582         uint seed = envSeed.toUInt();
583         if (seed) {
584             // can't use qWarning here (reentrancy)
585             fprintf(stderr, "QT_HASH_SEED: forced seed value is not 0, cannot guarantee that the "
586                      "hashing functions will produce a stable value.");
587         }
588         return seed;
589     }
590 
591     seed = QRandomGenerator::system()->generate();
592 #endif // QT_BOOTSTRAPPED
593 
594     return seed;
595 }
596 
597 /*
598     The QHash seed itself.
599 */
600 static QBasicAtomicInt qt_qhash_seed = Q_BASIC_ATOMIC_INITIALIZER(-1);
601 
602 /*!
603     \internal
604 
605     Seed == -1 means it that it was not initialized yet.
606 
607     We let qt_create_qhash_seed return any unsigned integer,
608     but convert it to signed in order to initialize the seed.
609 
610     We don't actually care about the fact that different calls to
611     qt_create_qhash_seed() might return different values,
612     as long as in the end everyone uses the very same value.
613 */
614 static void qt_initialize_qhash_seed()
615 {
616     if (qt_qhash_seed.loadRelaxed() == -1) {
617         int x(qt_create_qhash_seed() & INT_MAX);
618         qt_qhash_seed.testAndSetRelaxed(-1, x);
619     }
620 }
621 
622 /*! \relates QHash
623     \since 5.6
624 
625     Returns the current global QHash seed.
626 
627     The seed is set in any newly created QHash. See \l{qHash} about how this seed
628     is being used by QHash.
629 
630     \sa qSetGlobalQHashSeed
631  */
632 int qGlobalQHashSeed()
633 {
634     qt_initialize_qhash_seed();
635     return qt_qhash_seed.loadRelaxed();
636 }
637 
638 /*! \relates QHash
639     \since 5.6
640 
641     Sets the global QHash seed to \a newSeed.
642 
643     Manually setting the global QHash seed value should be done only for testing
644     and debugging purposes, when deterministic and reproducible behavior on a QHash
645     is needed. We discourage to do it in production code as it can make your
646     application susceptible to \l{algorithmic complexity attacks}.
647 
648     From Qt 5.10 and onwards, the only allowed values are 0 and -1. Passing the
649     value -1 will reinitialize the global QHash seed to a random value, while
650     the value of 0 is used to request a stable algorithm for C++ primitive
651     types types (like \c int) and string types (QString, QByteArray).
652 
653     The seed is set in any newly created QHash. See \l{qHash} about how this seed
654     is being used by QHash.
655 
656     If the environment variable \c QT_HASH_SEED is set, calling this function will
657     result in a no-op.
658 
659     \sa qGlobalQHashSeed
660  */
661 void qSetGlobalQHashSeed(int newSeed)
662 {
663     if (qEnvironmentVariableIsSet("QT_HASH_SEED"))
664         return;
665     if (newSeed == -1) {
666         int x(qt_create_qhash_seed() & INT_MAX);
667         qt_qhash_seed.storeRelaxed(x);
668     } else {
669         if (newSeed) {
670             // can't use qWarning here (reentrancy)
671             fprintf(stderr, "qSetGlobalQHashSeed: forced seed value is not 0, cannot guarantee that the "
672                             "hashing functions will produce a stable value.");
673         }
674         qt_qhash_seed.storeRelaxed(newSeed & INT_MAX);
675     }
676 }
677 
678 /*!
679     \internal
680 
681     Private copy of the implementation of the Qt 4 qHash algorithm for strings,
682     (that is, QChar-based arrays, so all QString-like classes),
683     to be used wherever the result is somehow stored or reused across multiple
684     Qt versions. The public qHash implementation can change at any time,
685     therefore one must not rely on the fact that it will always give the same
686     results.
687 
688     The qt_hash functions must *never* change their results.
689 
690     This function can hash discontiguous memory by invoking it on each chunk,
691     passing the previous's result in the next call's \a chained argument.
692 */
693 uint qt_hash(QStringView key, uint chained) noexcept
694 {
695     auto n = key.size();
696     auto p = key.utf16();
697 
698     uint h = chained;
699 
700     while (n--) {
701         h = (h << 4) + *p++;
702         h ^= (h & 0xf0000000) >> 23;
703         h &= 0x0fffffff;
704     }
705     return h;
706 }
707 
708 /*!
709     \fn template <typename T1, typename T2> size_t qHash(const QPair<T1, T2> &key, size_t seed = 0)
710     \since 5.0
711     \relates QHash
712 
713     Returns the hash value for the \a key, using \a seed to seed the calculation.
714 
715     Types \c T1 and \c T2 must be supported by qHash().
716 */
717 
718 /*!
719     \fn template <typename T1, typename T2> size_t qHash(const std::pair<T1, T2> &key, size_t seed = 0)
720     \since 5.7
721     \relates QHash
722 
723     Returns the hash value for the \a key, using \a seed to seed the calculation.
724 
725     Types \c T1 and \c T2 must be supported by qHash().
726 
727     \note The return type of this function is \e{not} the same as that of
728     \snippet code/src_corelib_tools_qhash.cpp 29
729     The two functions use different hashing algorithms; due to binary compatibility
730     constraints, we cannot change the QPair algorithm to match the std::pair one before Qt 6.
731 */
732 
733 /*! \fn template <typename InputIterator> size_t qHashRange(InputIterator first, InputIterator last, size_t seed = 0)
734     \relates QHash
735     \since 5.5
736 
737     Returns the hash value for the range [\a{first},\a{last}), using \a seed
738     to seed the calculation, by successively applying qHash() to each
739     element and combining the hash values into a single one.
740 
741     The return value of this function depends on the order of elements
742     in the range. That means that
743 
744     \snippet code/src_corelib_tools_qhash.cpp 30
745 
746     and
747     \snippet code/src_corelib_tools_qhash.cpp 31
748 
749     hash to \b{different} values. If order does not matter, for example for hash
750     tables, use qHashRangeCommutative() instead. If you are hashing raw
751     memory, use qHashBits().
752 
753     Use this function only to implement qHash() for your own custom
754     types. For example, here's how you could implement a qHash() overload for
755     std::vector<int>:
756 
757     \snippet code/src_corelib_tools_qhash.cpp qhashrange
758 
759     It bears repeating that the implementation of qHashRange() - like
760     the qHash() overloads offered by Qt - may change at any time. You
761     \b{must not} rely on the fact that qHashRange() will give the same
762     results (for the same inputs) across different Qt versions, even
763     if qHash() for the element type would.
764 
765     \sa qHashBits(), qHashRangeCommutative()
766 */
767 
768 /*! \fn template <typename InputIterator> size_t qHashRangeCommutative(InputIterator first, InputIterator last, size_t seed = 0)
769     \relates QHash
770     \since 5.5
771 
772     Returns the hash value for the range [\a{first},\a{last}), using \a seed
773     to seed the calculation, by successively applying qHash() to each
774     element and combining the hash values into a single one.
775 
776     The return value of this function does not depend on the order of
777     elements in the range. That means that
778 
779     \snippet code/src_corelib_tools_qhash.cpp 30
780 
781     and
782     \snippet code/src_corelib_tools_qhash.cpp 31
783 
784     hash to the \b{same} values. If order matters, for example, for vectors
785     and arrays, use qHashRange() instead. If you are hashing raw
786     memory, use qHashBits().
787 
788     Use this function only to implement qHash() for your own custom
789     types. For example, here's how you could implement a qHash() overload for
790     std::unordered_set<int>:
791 
792     \snippet code/src_corelib_tools_qhash.cpp qhashrangecommutative
793 
794     It bears repeating that the implementation of
795     qHashRangeCommutative() - like the qHash() overloads offered by Qt
796     - may change at any time. You \b{must not} rely on the fact that
797     qHashRangeCommutative() will give the same results (for the same
798     inputs) across different Qt versions, even if qHash() for the
799     element type would.
800 
801     \sa qHashBits(), qHashRange()
802 */
803 
804 /*! \fn size_t qHashBits(const void *p, size_t len, size_t seed = 0)
805     \relates QHash
806     \since 5.4
807 
808     Returns the hash value for the memory block of size \a len pointed
809     to by \a p, using \a seed to seed the calculation.
810 
811     Use this function only to implement qHash() for your own custom
812     types. For example, here's how you could implement a qHash() overload for
813     std::vector<int>:
814 
815     \snippet code/src_corelib_tools_qhash.cpp qhashbits
816 
817     This takes advantage of the fact that std::vector lays out its data
818     contiguously. If that is not the case, or the contained type has
819     padding, you should use qHashRange() instead.
820 
821     It bears repeating that the implementation of qHashBits() - like
822     the qHash() overloads offered by Qt - may change at any time. You
823     \b{must not} rely on the fact that qHashBits() will give the same
824     results (for the same inputs) across different Qt versions.
825 
826     \sa qHashRange(), qHashRangeCommutative()
827 */
828 
829 /*! \fn size_t qHash(char key, size_t seed = 0)
830     \relates QHash
831     \since 5.0
832 
833     Returns the hash value for the \a key, using \a seed to seed the calculation.
834 */
835 
836 /*! \fn size_t qHash(uchar key, size_t seed = 0)
837     \relates QHash
838     \since 5.0
839 
840     Returns the hash value for the \a key, using \a seed to seed the calculation.
841 */
842 
843 /*! \fn size_t qHash(signed char key, size_t seed = 0)
844     \relates QHash
845     \since 5.0
846 
847     Returns the hash value for the \a key, using \a seed to seed the calculation.
848 */
849 
850 /*! \fn size_t qHash(ushort key, size_t seed = 0)
851     \relates QHash
852     \since 5.0
853 
854     Returns the hash value for the \a key, using \a seed to seed the calculation.
855 */
856 
857 /*! \fn size_t qHash(short key, size_t seed = 0)
858     \relates QHash
859     \since 5.0
860 
861     Returns the hash value for the \a key, using \a seed to seed the calculation.
862 */
863 
864 /*! \fn size_t qHash(uint key, size_t seed = 0)
865     \relates QHash
866     \since 5.0
867 
868     Returns the hash value for the \a key, using \a seed to seed the calculation.
869 */
870 
871 /*! \fn size_t qHash(int key, size_t seed = 0)
872     \relates QHash
873     \since 5.0
874 
875     Returns the hash value for the \a key, using \a seed to seed the calculation.
876 */
877 
878 /*! \fn size_t qHash(ulong key, size_t seed = 0)
879     \relates QHash
880     \since 5.0
881 
882     Returns the hash value for the \a key, using \a seed to seed the calculation.
883 */
884 
885 /*! \fn size_t qHash(long key, size_t seed = 0)
886     \relates QHash
887     \since 5.0
888 
889     Returns the hash value for the \a key, using \a seed to seed the calculation.
890 */
891 
892 /*! \fn size_t qHash(quint64 key, size_t seed = 0)
893     \relates QHash
894     \since 5.0
895 
896     Returns the hash value for the \a key, using \a seed to seed the calculation.
897 */
898 
899 /*! \fn size_t qHash(qint64 key, size_t seed = 0)
900     \relates QHash
901     \since 5.0
902 
903     Returns the hash value for the \a key, using \a seed to seed the calculation.
904 */
905 
906 /*! \fn size_t qHash(float key, size_t seed) noexcept
907     \relates QHash
908     \since 5.3
909 
910     Returns the hash value for the \a key, using \a seed to seed the calculation.
911 */
912 
913 /*! \relates QHash
914     \since 5.3
915 
916     Returns the hash value for the \a key, using \a seed to seed the calculation.
917 */
918 size_t qHash(double key, size_t seed) noexcept
919 {
920     // ensure -0 gets mapped to 0
921     key += 0.0;
922     if constexpr (sizeof(double) == sizeof(size_t)) {
923         size_t k;
924         memcpy(&k, &key, sizeof(double));
925         return QHashPrivate::hash(k, seed);
926     } else {
927         return murmurhash(&key, sizeof(key), seed);
928     }
929 }
930 
931 #if !defined(Q_OS_DARWIN) || defined(Q_CLANG_QDOC)
932 /*! \relates QHash
933     \since 5.3
934 
935     Returns the hash value for the \a key, using \a seed to seed the calculation.
936 */
937 size_t qHash(long double key, size_t seed) noexcept
938 {
939     // ensure -0 gets mapped to 0
940     key += static_cast<long double>(0.0);
941     if constexpr (sizeof(long double) == sizeof(size_t)) {
942         size_t k;
943         memcpy(&k, &key, sizeof(long double));
944         return QHashPrivate::hash(k, seed);
945     } else {
946         return murmurhash(&key, sizeof(key), seed);
947     }
948 }
949 #endif
950 
951 /*! \fn size_t qHash(const QChar key, size_t seed = 0)
952     \relates QHash
953     \since 5.0
954 
955     Returns the hash value for the \a key, using \a seed to seed the calculation.
956 */
957 
958 /*! \fn size_t qHash(const QByteArray &key, size_t seed = 0)
959     \relates QHash
960     \since 5.0
961 
962     Returns the hash value for the \a key, using \a seed to seed the calculation.
963 */
964 
965 /*! \fn size_t qHash(const QBitArray &key, size_t seed = 0)
966     \relates QHash
967     \since 5.0
968 
969     Returns the hash value for the \a key, using \a seed to seed the calculation.
970 */
971 
972 /*! \fn size_t qHash(const QString &key, size_t seed = 0)
973     \relates QHash
974     \since 5.0
975 
976     Returns the hash value for the \a key, using \a seed to seed the calculation.
977 */
978 
979 /*! \fn size_t qHash(const QStringRef &key, size_t seed = 0)
980     \relates QHash
981     \since 5.0
982 
983     Returns the hash value for the \a key, using \a seed to seed the calculation.
984 */
985 
986 /*! \fn size_t qHash(QStringView key, size_t seed = 0)
987     \relates QStringView
988     \since 5.10
989 
990     Returns the hash value for the \a key, using \a seed to seed the calculation.
991 */
992 
993 /*! \fn size_t qHash(QLatin1String key, size_t seed = 0)
994     \relates QHash
995     \since 5.0
996 
997     Returns the hash value for the \a key, using \a seed to seed the calculation.
998 */
999 
1000 /*! \fn template <class T> size_t qHash(const T *key, size_t seed = 0)
1001     \relates QHash
1002     \since 5.0
1003 
1004     Returns the hash value for the \a key, using \a seed to seed the calculation.
1005 */
1006 
1007 /*!
1008     \class QHash
1009     \inmodule QtCore
1010     \brief The QHash class is a template class that provides a hash-table-based dictionary.
1011 
1012     \ingroup tools
1013     \ingroup shared
1014 
1015     \reentrant
1016 
1017     QHash\<Key, T\> is one of Qt's generic \l{container classes}. It
1018     stores (key, value) pairs and provides very fast lookup of the
1019     value associated with a key.
1020 
1021     QHash provides very similar functionality to QMap. The
1022     differences are:
1023 
1024     \list
1025     \li QHash provides faster lookups than QMap. (See \l{Algorithmic
1026        Complexity} for details.)
1027     \li When iterating over a QMap, the items are always sorted by
1028        key. With QHash, the items are arbitrarily ordered.
1029     \li The key type of a QMap must provide operator<(). The key
1030        type of a QHash must provide operator==() and a global
1031        hash function called qHash() (see \l{qHash}).
1032     \endlist
1033 
1034     Here's an example QHash with QString keys and \c int values:
1035     \snippet code/src_corelib_tools_qhash.cpp 0
1036 
1037     To insert a (key, value) pair into the hash, you can use operator[]():
1038 
1039     \snippet code/src_corelib_tools_qhash.cpp 1
1040 
1041     This inserts the following three (key, value) pairs into the
1042     QHash: ("one", 1), ("three", 3), and ("seven", 7). Another way to
1043     insert items into the hash is to use insert():
1044 
1045     \snippet code/src_corelib_tools_qhash.cpp 2
1046 
1047     To look up a value, use operator[]() or value():
1048 
1049     \snippet code/src_corelib_tools_qhash.cpp 3
1050 
1051     If there is no item with the specified key in the hash, these
1052     functions return a \l{default-constructed value}.
1053 
1054     If you want to check whether the hash contains a particular key,
1055     use contains():
1056 
1057     \snippet code/src_corelib_tools_qhash.cpp 4
1058 
1059     There is also a value() overload that uses its second argument as
1060     a default value if there is no item with the specified key:
1061 
1062     \snippet code/src_corelib_tools_qhash.cpp 5
1063 
1064     In general, we recommend that you use contains() and value()
1065     rather than operator[]() for looking up a key in a hash. The
1066     reason is that operator[]() silently inserts an item into the
1067     hash if no item exists with the same key (unless the hash is
1068     const). For example, the following code snippet will create 1000
1069     items in memory:
1070 
1071     \snippet code/src_corelib_tools_qhash.cpp 6
1072 
1073     To avoid this problem, replace \c hash[i] with \c hash.value(i)
1074     in the code above.
1075 
1076     Internally, QHash uses a hash table to perform lookups. This
1077     hash table automatically grows to
1078     provide fast lookups without wasting too much memory. You can
1079     still control the size of the hash table by calling reserve() if
1080     you already know approximately how many items the QHash will
1081     contain, but this isn't necessary to obtain good performance. You
1082     can also call capacity() to retrieve the hash table's size.
1083 
1084     QHash will not shrink automatically if items are removed from the
1085     table. To minimize the memory used by the hash, call squeeze().
1086 
1087     If you want to navigate through all the (key, value) pairs stored
1088     in a QHash, you can use an iterator. QHash provides both
1089     \l{Java-style iterators} (QHashIterator and QMutableHashIterator)
1090     and \l{STL-style iterators} (QHash::const_iterator and
1091     QHash::iterator). Here's how to iterate over a QHash<QString,
1092     int> using a Java-style iterator:
1093 
1094     \snippet code/src_corelib_tools_qhash.cpp 7
1095 
1096     Here's the same code, but using an STL-style iterator:
1097 
1098     \snippet code/src_corelib_tools_qhash.cpp 8
1099 
1100     QHash is unordered, so an iterator's sequence cannot be assumed
1101     to be predictable. If ordering by key is required, use a QMap.
1102 
1103     A QHash allows only one value per key. If you call
1104     insert() with a key that already exists in the QHash, the
1105     previous value is erased. For example:
1106 
1107     \snippet code/src_corelib_tools_qhash.cpp 9
1108 
1109     If you need to store multiple entries for the same key in the
1110     hash table, use \l{QMultiHash}.
1111 
1112     If you only need to extract the values from a hash (not the keys),
1113     you can also use \l{foreach}:
1114 
1115     \snippet code/src_corelib_tools_qhash.cpp 12
1116 
1117     Items can be removed from the hash in several ways. One way is to
1118     call remove(); this will remove any item with the given key.
1119     Another way is to use QMutableHashIterator::remove(). In addition,
1120     you can clear the entire hash using clear().
1121 
1122     QHash's key and value data types must be \l{assignable data
1123     types}. You cannot, for example, store a QWidget as a value;
1124     instead, store a QWidget *.
1125 
1126     \target qHash
1127     \section2 The qHash() hashing function
1128 
1129     A QHash's key type has additional requirements other than being an
1130     assignable data type: it must provide operator==(), and there must also be
1131     a qHash() function in the type's namespace that returns a hash value for an
1132     argument of the key's type.
1133 
1134     The qHash() function computes a numeric value based on a key. It
1135     can use any algorithm imaginable, as long as it always returns
1136     the same value if given the same argument. In other words, if
1137     \c{e1 == e2}, then \c{qHash(e1) == qHash(e2)} must hold as well.
1138     However, to obtain good performance, the qHash() function should
1139     attempt to return different hash values for different keys to the
1140     largest extent possible.
1141 
1142     For a key type \c{K}, the qHash function must have one of these signatures:
1143 
1144     \snippet code/src_corelib_tools_qhash.cpp 32
1145 
1146     The two-arguments overloads take an unsigned integer that should be used to
1147     seed the calculation of the hash function. This seed is provided by QHash
1148     in order to prevent a family of \l{algorithmic complexity attacks}. If both
1149     a one-argument and a two-arguments overload are defined for a key type,
1150     the latter is used by QHash (note that you can simply define a
1151     two-arguments version, and use a default value for the seed parameter).
1152 
1153     Here's a partial list of the C++ and Qt types that can serve as keys in a
1154     QHash: any integer type (char, unsigned long, etc.), any pointer type,
1155     QChar, QString, and QByteArray. For all of these, the \c <QHash> header
1156     defines a qHash() function that computes an adequate hash value. Many other
1157     Qt classes also declare a qHash overload for their type; please refer to
1158     the documentation of each class.
1159 
1160     If you want to use other types as the key, make sure that you provide
1161     operator==() and a qHash() implementation.
1162 
1163     Example:
1164     \snippet code/src_corelib_tools_qhash.cpp 13
1165 
1166     In the example above, we've relied on Qt's global qHash(const
1167     QString &, uint) to give us a hash value for the employee's name, and
1168     XOR'ed this with the day they were born to help produce unique
1169     hashes for people with the same name.
1170 
1171     Note that the implementation of the qHash() overloads offered by Qt
1172     may change at any time. You \b{must not} rely on the fact that qHash()
1173     will give the same results (for the same inputs) across different Qt
1174     versions.
1175 
1176     \section2 Algorithmic complexity attacks
1177 
1178     All hash tables are vulnerable to a particular class of denial of service
1179     attacks, in which the attacker carefully pre-computes a set of different
1180     keys that are going to be hashed in the same bucket of a hash table (or
1181     even have the very same hash value). The attack aims at getting the
1182     worst-case algorithmic behavior (O(n) instead of amortized O(1), see
1183     \l{Algorithmic Complexity} for the details) when the data is fed into the
1184     table.
1185 
1186     In order to avoid this worst-case behavior, the calculation of the hash
1187     value done by qHash() can be salted by a random seed, that nullifies the
1188     attack's extent. This seed is automatically generated by QHash once per
1189     process, and then passed by QHash as the second argument of the
1190     two-arguments overload of the qHash() function.
1191 
1192     This randomization of QHash is enabled by default. Even though programs
1193     should never depend on a particular QHash ordering, there may be situations
1194     where you temporarily need deterministic behavior, for example for debugging or
1195     regression testing. To disable the randomization, define the environment
1196     variable \c QT_HASH_SEED to have the value 0. Alternatively, you can call
1197     the qSetGlobalQHashSeed() function with the value 0.
1198 
1199     \sa QHashIterator, QMutableHashIterator, QMap, QSet
1200 */
1201 
1202 /*! \fn template <class Key, class T> QHash<Key, T>::QHash()
1203 
1204     Constructs an empty hash.
1205 
1206     \sa clear()
1207 */
1208 
1209 /*!
1210     \fn template <class Key, class T> QHash<Key, T>::QHash(QHash &&other)
1211 
1212     Move-constructs a QHash instance, making it point at the same
1213     object that \a other was pointing to.
1214 
1215     \since 5.2
1216 */
1217 
1218 /*! \fn template <class Key, class T> QHash<Key, T>::QHash(std::initializer_list<std::pair<Key,T> > list)
1219     \since 5.1
1220 
1221     Constructs a hash with a copy of each of the elements in the
1222     initializer list \a list.
1223 */
1224 
1225 /*! \fn template <class Key, class T> template <class InputIterator> QHash<Key, T>::QHash(InputIterator begin, InputIterator end)
1226     \since 5.14
1227 
1228     Constructs a hash with a copy of each of the elements in the iterator range
1229     [\a begin, \a end). Either the elements iterated by the range must be
1230     objects with \c{first} and \c{second} data members (like \c{QPair},
1231     \c{std::pair}, etc.) convertible to \c Key and to \c T respectively; or the
1232     iterators must have \c{key()} and \c{value()} member functions, returning a
1233     key convertible to \c Key and a value convertible to \c T respectively.
1234 */
1235 
1236 /*! \fn template <class Key, class T> QHash<Key, T>::QHash(const QHash &other)
1237 
1238     Constructs a copy of \a other.
1239 
1240     This operation occurs in \l{constant time}, because QHash is
1241     \l{implicitly shared}. This makes returning a QHash from a
1242     function very fast. If a shared instance is modified, it will be
1243     copied (copy-on-write), and this takes \l{linear time}.
1244 
1245     \sa operator=()
1246 */
1247 
1248 /*! \fn template <class Key, class T> QHash<Key, T>::~QHash()
1249 
1250     Destroys the hash. References to the values in the hash and all
1251     iterators of this hash become invalid.
1252 */
1253 
1254 /*! \fn template <class Key, class T> QHash &QHash<Key, T>::operator=(const QHash &other)
1255 
1256     Assigns \a other to this hash and returns a reference to this hash.
1257 */
1258 
1259 /*!
1260     \fn template <class Key, class T> QHash &QHash<Key, T>::operator=(QHash &&other)
1261 
1262     Move-assigns \a other to this QHash instance.
1263 
1264     \since 5.2
1265 */
1266 
1267 /*! \fn template <class Key, class T> void QHash<Key, T>::swap(QHash &other)
1268     \since 4.8
1269 
1270     Swaps hash \a other with this hash. This operation is very
1271     fast and never fails.
1272 */
1273 
1274 /*! \fn template <class Key, class T> void QMultiHash<Key, T>::swap(QMultiHash &other)
1275     \since 4.8
1276 
1277     Swaps hash \a other with this hash. This operation is very
1278     fast and never fails.
1279 */
1280 
1281 /*! \fn template <class Key, class T> bool QHash<Key, T>::operator==(const QHash &other) const
1282 
1283     Returns \c true if \a other is equal to this hash; otherwise returns
1284     false.
1285 
1286     Two hashes are considered equal if they contain the same (key,
1287     value) pairs.
1288 
1289     This function requires the value type to implement \c operator==().
1290 
1291     \sa operator!=()
1292 */
1293 
1294 /*! \fn template <class Key, class T> bool QHash<Key, T>::operator!=(const QHash &other) const
1295 
1296     Returns \c true if \a other is not equal to this hash; otherwise
1297     returns \c false.
1298 
1299     Two hashes are considered equal if they contain the same (key,
1300     value) pairs.
1301 
1302     This function requires the value type to implement \c operator==().
1303 
1304     \sa operator==()
1305 */
1306 
1307 /*! \fn template <class Key, class T> int QHash<Key, T>::size() const
1308 
1309     Returns the number of items in the hash.
1310 
1311     \sa isEmpty(), count()
1312 */
1313 
1314 /*! \fn template <class Key, class T> bool QHash<Key, T>::isEmpty() const
1315 
1316     Returns \c true if the hash contains no items; otherwise returns
1317     false.
1318 
1319     \sa size()
1320 */
1321 
1322 /*! \fn template <class Key, class T> int QHash<Key, T>::capacity() const
1323 
1324     Returns the number of buckets in the QHash's internal hash table.
1325 
1326     The sole purpose of this function is to provide a means of fine
1327     tuning QHash's memory usage. In general, you will rarely ever
1328     need to call this function. If you want to know how many items are
1329     in the hash, call size().
1330 
1331     \sa reserve(), squeeze()
1332 */
1333 
1334 /*! \fn template <class Key, class T> float QHash<Key, T>::load_factor() const noexcept
1335 
1336     Returns the current load factor of the QHash's internal hash table.
1337     This is the same as capacity()/size(). The implementation used
1338     will aim to keep the load factor between 0.25 and 0.5. This avoids
1339     having too many hash table collisions that would degrade performance.
1340 
1341     Even with a low load factor, the implementation of the hash table has a
1342     very low memory overhead.
1343 
1344     This method purely exists for diagnostic purposes and you should rarely
1345     need to call it yourself.
1346 
1347     \sa reserve(), squeeze()
1348 */
1349 
1350 
1351 /*! \fn template <class Key, class T> void QHash<Key, T>::reserve(int size)
1352 
1353     Ensures that the QHash's internal hash table has space to store at
1354     least \a size items without having to grow the hash table.
1355 
1356     This implies that the hash table will contain at least 2 * \a size buckets
1357     to ensure good performance
1358 
1359     This function is useful for code that needs to build a huge hash
1360     and wants to avoid repeated reallocation. For example:
1361 
1362     \snippet code/src_corelib_tools_qhash.cpp 14
1363 
1364     Ideally, \a size should be the maximum number of items expected
1365     in the hash. QHash will then choose the smallest possible
1366     number of buckets that will allow storing \a size items in the table
1367     without having to grow the internal hash table. If \a size
1368     is an underestimate, the worst that will happen is that the QHash
1369     will be a bit slower.
1370 
1371     In general, you will rarely ever need to call this function.
1372     QHash's internal hash table automatically grows to
1373     provide good performance without wasting too much memory.
1374 
1375     \sa squeeze(), capacity()
1376 */
1377 
1378 /*! \fn template <class Key, class T> void QHash<Key, T>::squeeze()
1379 
1380     Reduces the size of the QHash's internal hash table to save
1381     memory.
1382 
1383     The sole purpose of this function is to provide a means of fine
1384     tuning QHash's memory usage. In general, you will rarely ever
1385     need to call this function.
1386 
1387     \sa reserve(), capacity()
1388 */
1389 
1390 /*! \fn template <class Key, class T> void QHash<Key, T>::detach()
1391 
1392     \internal
1393 
1394     Detaches this hash from any other hashes with which it may share
1395     data.
1396 
1397     \sa isDetached()
1398 */
1399 
1400 /*! \fn template <class Key, class T> bool QHash<Key, T>::isDetached() const
1401 
1402     \internal
1403 
1404     Returns \c true if the hash's internal data isn't shared with any
1405     other hash object; otherwise returns \c false.
1406 
1407     \sa detach()
1408 */
1409 
1410 /*! \fn template <class Key, class T> bool QHash<Key, T>::isSharedWith(const QHash &other) const
1411 
1412     \internal
1413 
1414     Returns true if the internal hash table of this QHash is shared with \a other, otherwise false.
1415 */
1416 
1417 /*! \fn template <class Key, class T> void QHash<Key, T>::clear()
1418 
1419     Removes all items from the hash and frees up all memory used by it.
1420 
1421     \sa remove()
1422 */
1423 
1424 /*! \fn template <class Key, class T> bool QHash<Key, T>::remove(const Key &key)
1425 
1426     Removes the item that has the \a key from the hash.
1427     Returns true if the key exists in the hash and the item has been removed,
1428     and false otherwise.
1429 
1430     \sa clear(), take()
1431 */
1432 
1433 /*! \fn template <class Key, class T> T QHash<Key, T>::take(const Key &key)
1434 
1435     Removes the item with the \a key from the hash and returns
1436     the value associated with it.
1437 
1438     If the item does not exist in the hash, the function simply
1439     returns a \l{default-constructed value}.
1440 
1441     If you don't use the return value, remove() is more efficient.
1442 
1443     \sa remove()
1444 */
1445 
1446 /*! \fn template <class Key, class T> bool QHash<Key, T>::contains(const Key &key) const
1447 
1448     Returns \c true if the hash contains an item with the \a key;
1449     otherwise returns \c false.
1450 
1451     \sa count(), QMultiHash::contains()
1452 */
1453 
1454 /*! \fn template <class Key, class T> T QHash<Key, T>::value(const Key &key, const T &defaultValue = T()) const
1455     \overload
1456 
1457     Returns the value associated with the \a key.
1458 
1459     If the hash contains no item with the \a key, the function
1460     returns \a defaultValue, which is a \l{default-constructed value} if the
1461     parameter has not been specified.
1462 */
1463 
1464 /*! \fn template <class Key, class T> T &QHash<Key, T>::operator[](const Key &key)
1465 
1466     Returns the value associated with the \a key as a modifiable
1467     reference.
1468 
1469     If the hash contains no item with the \a key, the function inserts
1470     a \l{default-constructed value} into the hash with the \a key, and
1471     returns a reference to it.
1472 
1473     \sa insert(), value()
1474 */
1475 
1476 /*! \fn template <class Key, class T> const T QHash<Key, T>::operator[](const Key &key) const
1477 
1478     \overload
1479 
1480     Same as value().
1481 */
1482 
1483 /*! \fn template <class Key, class T> QList<Key> QHash<Key, T>::keys() const
1484 
1485     Returns a list containing all the keys in the hash, in an
1486     arbitrary order.
1487 
1488     The order is guaranteed to be the same as that used by values().
1489 
1490     \sa values(), key()
1491 */
1492 
1493 /*! \fn template <class Key, class T> QList<Key> QHash<Key, T>::keys(const T &value) const
1494 
1495     \overload
1496 
1497     Returns a list containing all the keys associated with value \a
1498     value, in an arbitrary order.
1499 
1500     This function can be slow (\l{linear time}), because QHash's
1501     internal data structure is optimized for fast lookup by key, not
1502     by value.
1503 */
1504 
1505 /*! \fn template <class Key, class T> QList<T> QHash<Key, T>::values() const
1506 
1507     Returns a list containing all the values in the hash, in an
1508     arbitrary order.
1509 
1510     The order is guaranteed to be the same as that used by keys().
1511 
1512     \sa keys(), value()
1513 */
1514 
1515 /*!
1516     \fn template <class Key, class T> Key QHash<Key, T>::key(const T &value, const Key &defaultKey = Key()) const
1517     \since 4.3
1518 
1519     Returns the first key mapped to \a value, or \a defaultKey if the
1520     hash contains no item mapped to \a value.
1521 
1522     This function can be slow (\l{linear time}), because QHash's
1523     internal data structure is optimized for fast lookup by key, not
1524     by value.
1525 */
1526 
1527 /*! \fn template <class Key, class T> int QHash<Key, T>::count(const Key &key) const
1528 
1529     Returns the number of items associated with the \a key.
1530 
1531     \sa contains()
1532 */
1533 
1534 /*! \fn template <class Key, class T> int QHash<Key, T>::count() const
1535 
1536     \overload
1537 
1538     Same as size().
1539 */
1540 
1541 /*! \fn template <class Key, class T> QHash<Key, T>::iterator QHash<Key, T>::begin()
1542 
1543     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first item in
1544     the hash.
1545 
1546     \sa constBegin(), end()
1547 */
1548 
1549 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::begin() const
1550 
1551     \overload
1552 */
1553 
1554 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::cbegin() const
1555     \since 5.0
1556 
1557     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first item
1558     in the hash.
1559 
1560     \sa begin(), cend()
1561 */
1562 
1563 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::constBegin() const
1564 
1565     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first item
1566     in the hash.
1567 
1568     \sa begin(), constEnd()
1569 */
1570 
1571 /*! \fn template <class Key, class T> QHash<Key, T>::key_iterator QHash<Key, T>::keyBegin() const
1572     \since 5.6
1573 
1574     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first key
1575     in the hash.
1576 
1577     \sa keyEnd()
1578 */
1579 
1580 /*! \fn template <class Key, class T> QHash<Key, T>::iterator QHash<Key, T>::end()
1581 
1582     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary item
1583     after the last item in the hash.
1584 
1585     \sa begin(), constEnd()
1586 */
1587 
1588 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::end() const
1589 
1590     \overload
1591 */
1592 
1593 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::constEnd() const
1594 
1595     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1596     item after the last item in the hash.
1597 
1598     \sa constBegin(), end()
1599 */
1600 
1601 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::cend() const
1602     \since 5.0
1603 
1604     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1605     item after the last item in the hash.
1606 
1607     \sa cbegin(), end()
1608 */
1609 
1610 /*! \fn template <class Key, class T> QHash<Key, T>::key_iterator QHash<Key, T>::keyEnd() const
1611     \since 5.6
1612 
1613     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1614     item after the last key in the hash.
1615 
1616     \sa keyBegin()
1617 */
1618 
1619 /*! \fn template <class Key, class T> QHash<Key, T>::key_value_iterator QHash<Key, T>::keyValueBegin()
1620     \since 5.10
1621 
1622     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first entry
1623     in the hash.
1624 
1625     \sa keyValueEnd()
1626 */
1627 
1628 /*! \fn template <class Key, class T> QHash<Key, T>::key_value_iterator QHash<Key, T>::keyValueEnd()
1629     \since 5.10
1630 
1631     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1632     entry after the last entry in the hash.
1633 
1634     \sa keyValueBegin()
1635 */
1636 
1637 /*! \fn template <class Key, class T> QHash<Key, T>::const_key_value_iterator QHash<Key, T>::keyValueBegin() const
1638     \since 5.10
1639 
1640     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first entry
1641     in the hash.
1642 
1643     \sa keyValueEnd()
1644 */
1645 
1646 /*! \fn template <class Key, class T> QHash<Key, T>::const_key_value_iterator QHash<Key, T>::constKeyValueBegin() const
1647     \since 5.10
1648 
1649     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first entry
1650     in the hash.
1651 
1652     \sa keyValueBegin()
1653 */
1654 
1655 /*! \fn template <class Key, class T> QHash<Key, T>::const_key_value_iterator QHash<Key, T>::keyValueEnd() const
1656     \since 5.10
1657 
1658     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1659     entry after the last entry in the hash.
1660 
1661     \sa keyValueBegin()
1662 */
1663 
1664 /*! \fn template <class Key, class T> QHash<Key, T>::const_key_value_iterator QHash<Key, T>::constKeyValueEnd() const
1665     \since 5.10
1666 
1667     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1668     entry after the last entry in the hash.
1669 
1670     \sa constKeyValueBegin()
1671 */
1672 
1673 /*! \fn template <class Key, class T> QHash<Key, T>::iterator QHash<Key, T>::erase(const_iterator pos)
1674     \since 5.7
1675 
1676     Removes the (key, value) pair associated with the iterator \a pos
1677     from the hash, and returns an iterator to the next item in the
1678     hash.
1679 
1680     This function never causes QHash to
1681     rehash its internal data structure. This means that it can safely
1682     be called while iterating, and won't affect the order of items in
1683     the hash. For example:
1684 
1685     \snippet code/src_corelib_tools_qhash.cpp 15
1686 
1687     \sa remove(), take(), find()
1688 */
1689 
1690 /*! \fn template <class Key, class T> QHash<Key, T>::iterator QHash<Key, T>::erase(iterator pos)
1691     \overload
1692 */
1693 
1694 /*! \fn template <class Key, class T> QHash<Key, T>::iterator QHash<Key, T>::find(const Key &key)
1695 
1696     Returns an iterator pointing to the item with the \a key in the
1697     hash.
1698 
1699     If the hash contains no item with the \a key, the function
1700     returns end().
1701 
1702     If the hash contains multiple items with the \a key, this
1703     function returns an iterator that points to the most recently
1704     inserted value. The other values are accessible by incrementing
1705     the iterator. For example, here's some code that iterates over all
1706     the items with the same key:
1707 
1708     \snippet code/src_corelib_tools_qhash.cpp 16
1709 
1710     \sa value(), values()
1711 */
1712 
1713 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::find(const Key &key) const
1714 
1715     \overload
1716 */
1717 
1718 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::constFind(const Key &key) const
1719     \since 4.1
1720 
1721     Returns an iterator pointing to the item with the \a key in the
1722     hash.
1723 
1724     If the hash contains no item with the \a key, the function
1725     returns constEnd().
1726 
1727     \sa find()
1728 */
1729 
1730 /*! \fn template <class Key, class T> QHash<Key, T>::iterator QHash<Key, T>::insert(const Key &key, const T &value)
1731 
1732     Inserts a new item with the \a key and a value of \a value.
1733 
1734     If there is already an item with the \a key, that item's value
1735     is replaced with \a value.
1736 */
1737 
1738 /*!
1739     \fn template <typename T> template <typename ...Args> QHash<Key, T>::iterator QHash<Key, T>::emplace(const Key &key, Args&&... args)
1740     \fn template <typename T> template <typename ...Args> QHash<Key, T>::iterator QHash<Key, T>::emplace(Key &&key, Args&&... args)
1741 
1742     Inserts a new element into the container. This new element
1743     is constructed in-place using \a args as the arguments for its
1744     construction.
1745 
1746     Returns an iterator pointing to the new element.
1747 */
1748 
1749 
1750 /*! \fn template <class Key, class T> void QHash<Key, T>::insert(const QHash &other)
1751     \since 5.15
1752 
1753     Inserts all the items in the \a other hash into this hash.
1754 
1755     If a key is common to both hashes, its value will be replaced with the
1756     value stored in \a other.
1757 
1758     \note If \a other contains multiple entries with the same key then the
1759     final value of the key is undefined.
1760 */
1761 
1762 /*! \fn template <class Key, class T> bool QHash<Key, T>::empty() const
1763 
1764     This function is provided for STL compatibility. It is equivalent
1765     to isEmpty(), returning true if the hash is empty; otherwise
1766     returns \c false.
1767 */
1768 
1769 /*! \fn template <class Key, class T> QPair<iterator, iterator> QMultiHash<Key, T>::equal_range(const Key &key)
1770     \since 5.7
1771 
1772     Returns a pair of iterators delimiting the range of values \c{[first, second)}, that
1773     are stored under \a key. If the range is empty then both iterators will be equal to end().
1774 */
1775 
1776 /*!
1777     \fn template <class Key, class T> QPair<const_iterator, const_iterator> QMultiHash<Key, T>::equal_range(const Key &key) const
1778     \overload
1779     \since 5.7
1780 */
1781 
1782 /*! \typedef QHash::ConstIterator
1783 
1784     Qt-style synonym for QHash::const_iterator.
1785 */
1786 
1787 /*! \typedef QHash::Iterator
1788 
1789     Qt-style synonym for QHash::iterator.
1790 */
1791 
1792 /*! \typedef QHash::difference_type
1793 
1794     Typedef for ptrdiff_t. Provided for STL compatibility.
1795 */
1796 
1797 /*! \typedef QHash::key_type
1798 
1799     Typedef for Key. Provided for STL compatibility.
1800 */
1801 
1802 /*! \typedef QHash::mapped_type
1803 
1804     Typedef for T. Provided for STL compatibility.
1805 */
1806 
1807 /*! \typedef QHash::size_type
1808 
1809     Typedef for int. Provided for STL compatibility.
1810 */
1811 
1812 /*! \typedef QHash::iterator::difference_type
1813     \internal
1814 */
1815 
1816 /*! \typedef QHash::iterator::iterator_category
1817     \internal
1818 */
1819 
1820 /*! \typedef QHash::iterator::pointer
1821     \internal
1822 */
1823 
1824 /*! \typedef QHash::iterator::reference
1825     \internal
1826 */
1827 
1828 /*! \typedef QHash::iterator::value_type
1829     \internal
1830 */
1831 
1832 /*! \typedef QHash::const_iterator::difference_type
1833     \internal
1834 */
1835 
1836 /*! \typedef QHash::const_iterator::iterator_category
1837     \internal
1838 */
1839 
1840 /*! \typedef QHash::const_iterator::pointer
1841     \internal
1842 */
1843 
1844 /*! \typedef QHash::const_iterator::reference
1845     \internal
1846 */
1847 
1848 /*! \typedef QHash::const_iterator::value_type
1849     \internal
1850 */
1851 
1852 /*! \typedef QHash::key_iterator::difference_type
1853     \internal
1854 */
1855 
1856 /*! \typedef QHash::key_iterator::iterator_category
1857     \internal
1858 */
1859 
1860 /*! \typedef QHash::key_iterator::pointer
1861     \internal
1862 */
1863 
1864 /*! \typedef QHash::key_iterator::reference
1865     \internal
1866 */
1867 
1868 /*! \typedef QHash::key_iterator::value_type
1869     \internal
1870 */
1871 
1872 /*! \class QHash::iterator
1873     \inmodule QtCore
1874     \brief The QHash::iterator class provides an STL-style non-const iterator for QHash.
1875 
1876     QHash features both \l{STL-style iterators} and \l{Java-style
1877     iterators}. The STL-style iterators are more low-level and more
1878     cumbersome to use; on the other hand, they are slightly faster
1879     and, for developers who already know STL, have the advantage of
1880     familiarity.
1881 
1882     QHash\<Key, T\>::iterator allows you to iterate over a QHash
1883     and to modify the value (but not the key) associated
1884     with a particular key. If you want to iterate over a const QHash,
1885     you should use QHash::const_iterator. It is generally good
1886     practice to use QHash::const_iterator on a non-const QHash as
1887     well, unless you need to change the QHash through the iterator.
1888     Const iterators are slightly faster, and can improve code
1889     readability.
1890 
1891     The default QHash::iterator constructor creates an uninitialized
1892     iterator. You must initialize it using a QHash function like
1893     QHash::begin(), QHash::end(), or QHash::find() before you can
1894     start iterating. Here's a typical loop that prints all the (key,
1895     value) pairs stored in a hash:
1896 
1897     \snippet code/src_corelib_tools_qhash.cpp 17
1898 
1899     Unlike QMap, which orders its items by key, QHash stores its
1900     items in an arbitrary order.
1901 
1902     Let's see a few examples of things we can do with a
1903     QHash::iterator that we cannot do with a QHash::const_iterator.
1904     Here's an example that increments every value stored in the QHash
1905     by 2:
1906 
1907     \snippet code/src_corelib_tools_qhash.cpp 18
1908 
1909     Here's an example that removes all the items whose key is a
1910     string that starts with an underscore character:
1911 
1912     \snippet code/src_corelib_tools_qhash.cpp 19
1913 
1914     The call to QHash::erase() removes the item pointed to by the
1915     iterator from the hash, and returns an iterator to the next item.
1916     Here's another way of removing an item while iterating:
1917 
1918     \snippet code/src_corelib_tools_qhash.cpp 20
1919 
1920     It might be tempting to write code like this:
1921 
1922     \snippet code/src_corelib_tools_qhash.cpp 21
1923 
1924     However, this will potentially crash in \c{++i}, because \c i is
1925     a dangling iterator after the call to erase().
1926 
1927     Multiple iterators can be used on the same hash. However, be aware
1928     that any modification performed directly on the QHash (inserting and
1929     removing items) can cause the iterators to become invalid.
1930 
1931     Inserting items into the hash or calling methods such as QHash::reserve()
1932     or QHash::squeeze() can invalidate all iterators pointing into the hash.
1933     Iterators are guaranteed to stay valid only as long as the QHash doesn't have
1934     to grow/shrink its internal hash table.
1935     Using any iterator after a rehashing operation has occurred will lead to undefined behavior.
1936 
1937     You can however safely use iterators to remove entries from the hash
1938     using the QHash::erase() method. This function can safely be called while
1939     iterating, and won't affect the order of items in the hash.
1940 
1941     If you need to keep iterators over a long period of time, we recommend
1942     that you use QMap rather than QHash.
1943 
1944     \warning Iterators on implicitly shared containers do not work
1945     exactly like STL-iterators. You should avoid copying a container
1946     while iterators are active on that container. For more information,
1947     read \l{Implicit sharing iterator problem}.
1948 
1949     \sa QHash::const_iterator, QHash::key_iterator, QMutableHashIterator
1950 */
1951 
1952 /*! \fn template <class Key, class T> QHash<Key, T>::iterator::iterator()
1953 
1954     Constructs an uninitialized iterator.
1955 
1956     Functions like key(), value(), and operator++() must not be
1957     called on an uninitialized iterator. Use operator=() to assign a
1958     value to it before using it.
1959 
1960     \sa QHash::begin(), QHash::end()
1961 */
1962 
1963 /*! \fn template <class Key, class T> const Key &QHash<Key, T>::iterator::key() const
1964 
1965     Returns the current item's key as a const reference.
1966 
1967     There is no direct way of changing an item's key through an
1968     iterator, although it can be done by calling QHash::erase()
1969     followed by QHash::insert().
1970 
1971     \sa value()
1972 */
1973 
1974 /*! \fn template <class Key, class T> T &QHash<Key, T>::iterator::value() const
1975 
1976     Returns a modifiable reference to the current item's value.
1977 
1978     You can change the value of an item by using value() on
1979     the left side of an assignment, for example:
1980 
1981     \snippet code/src_corelib_tools_qhash.cpp 22
1982 
1983     \sa key(), operator*()
1984 */
1985 
1986 /*! \fn template <class Key, class T> T &QHash<Key, T>::iterator::operator*() const
1987 
1988     Returns a modifiable reference to the current item's value.
1989 
1990     Same as value().
1991 
1992     \sa key()
1993 */
1994 
1995 /*! \fn template <class Key, class T> T *QHash<Key, T>::iterator::operator->() const
1996 
1997     Returns a pointer to the current item's value.
1998 
1999     \sa value()
2000 */
2001 
2002 /*!
2003     \fn template <class Key, class T> bool QHash<Key, T>::iterator::operator==(const iterator &other) const
2004     \fn template <class Key, class T> bool QHash<Key, T>::iterator::operator==(const const_iterator &other) const
2005 
2006     Returns \c true if \a other points to the same item as this
2007     iterator; otherwise returns \c false.
2008 
2009     \sa operator!=()
2010 */
2011 
2012 /*!
2013     \fn template <class Key, class T> bool QHash<Key, T>::iterator::operator!=(const iterator &other) const
2014     \fn template <class Key, class T> bool QHash<Key, T>::iterator::operator!=(const const_iterator &other) const
2015 
2016     Returns \c true if \a other points to a different item than this
2017     iterator; otherwise returns \c false.
2018 
2019     \sa operator==()
2020 */
2021 
2022 /*!
2023     \fn template <class Key, class T> QHash<Key, T>::iterator &QHash<Key, T>::iterator::operator++()
2024 
2025     The prefix ++ operator (\c{++i}) advances the iterator to the
2026     next item in the hash and returns an iterator to the new current
2027     item.
2028 
2029     Calling this function on QHash::end() leads to undefined results.
2030 */
2031 
2032 /*! \fn template <class Key, class T> QHash<Key, T>::iterator QHash<Key, T>::iterator::operator++(int)
2033 
2034     \overload
2035 
2036     The postfix ++ operator (\c{i++}) advances the iterator to the
2037     next item in the hash and returns an iterator to the previously
2038     current item.
2039 */
2040 
2041 /*! \class QHash::const_iterator
2042     \inmodule QtCore
2043     \brief The QHash::const_iterator class provides an STL-style const iterator for QHash.
2044 
2045     QHash features both \l{STL-style iterators} and \l{Java-style
2046     iterators}. The STL-style iterators are more low-level and more
2047     cumbersome to use; on the other hand, they are slightly faster
2048     and, for developers who already know STL, have the advantage of
2049     familiarity.
2050 
2051     QHash\<Key, T\>::const_iterator allows you to iterate over a
2052     QHash. If you want to modify the QHash as you
2053     iterate over it, you must use QHash::iterator instead. It is
2054     generally good practice to use QHash::const_iterator on a
2055     non-const QHash as well, unless you need to change the QHash
2056     through the iterator. Const iterators are slightly faster, and
2057     can improve code readability.
2058 
2059     The default QHash::const_iterator constructor creates an
2060     uninitialized iterator. You must initialize it using a QHash
2061     function like QHash::constBegin(), QHash::constEnd(), or
2062     QHash::find() before you can start iterating. Here's a typical
2063     loop that prints all the (key, value) pairs stored in a hash:
2064 
2065     \snippet code/src_corelib_tools_qhash.cpp 23
2066 
2067     Unlike QMap, which orders its items by key, QHash stores its
2068     items in an arbitrary order. The only guarantee is that items that
2069     share the same key (because they were inserted using
2070     a QMultiHash) will appear consecutively, from the most
2071     recently to the least recently inserted value.
2072 
2073     Multiple iterators can be used on the same hash. However, be aware
2074     that any modification performed directly on the QHash (inserting and
2075     removing items) can cause the iterators to become invalid.
2076 
2077     Inserting items into the hash or calling methods such as QHash::reserve()
2078     or QHash::squeeze() can invalidate all iterators pointing into the hash.
2079     Iterators are guaranteed to stay valid only as long as the QHash doesn't have
2080     to grow/shrink its internal hash table.
2081     Using any iterator after a rehashing operation has occurred will lead to undefined behavior.
2082 
2083     \warning Iterators on implicitly shared containers do not work
2084     exactly like STL-iterators. You should avoid copying a container
2085     while iterators are active on that container. For more information,
2086     read \l{Implicit sharing iterator problem}.
2087 
2088     \sa QHash::iterator, QHashIterator
2089 */
2090 
2091 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator::const_iterator()
2092 
2093     Constructs an uninitialized iterator.
2094 
2095     Functions like key(), value(), and operator++() must not be
2096     called on an uninitialized iterator. Use operator=() to assign a
2097     value to it before using it.
2098 
2099     \sa QHash::constBegin(), QHash::constEnd()
2100 */
2101 
2102 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator::const_iterator(const iterator &other)
2103 
2104     Constructs a copy of \a other.
2105 */
2106 
2107 /*! \fn template <class Key, class T> const Key &QHash<Key, T>::const_iterator::key() const
2108 
2109     Returns the current item's key.
2110 
2111     \sa value()
2112 */
2113 
2114 /*! \fn template <class Key, class T> const T &QHash<Key, T>::const_iterator::value() const
2115 
2116     Returns the current item's value.
2117 
2118     \sa key(), operator*()
2119 */
2120 
2121 /*! \fn template <class Key, class T> const T &QHash<Key, T>::const_iterator::operator*() const
2122 
2123     Returns the current item's value.
2124 
2125     Same as value().
2126 
2127     \sa key()
2128 */
2129 
2130 /*! \fn template <class Key, class T> const T *QHash<Key, T>::const_iterator::operator->() const
2131 
2132     Returns a pointer to the current item's value.
2133 
2134     \sa value()
2135 */
2136 
2137 /*! \fn template <class Key, class T> bool QHash<Key, T>::const_iterator::operator==(const const_iterator &other) const
2138 
2139     Returns \c true if \a other points to the same item as this
2140     iterator; otherwise returns \c false.
2141 
2142     \sa operator!=()
2143 */
2144 
2145 /*! \fn template <class Key, class T> bool QHash<Key, T>::const_iterator::operator!=(const const_iterator &other) const
2146 
2147     Returns \c true if \a other points to a different item than this
2148     iterator; otherwise returns \c false.
2149 
2150     \sa operator==()
2151 */
2152 
2153 /*!
2154     \fn template <class Key, class T> QHash<Key, T>::const_iterator &QHash<Key, T>::const_iterator::operator++()
2155 
2156     The prefix ++ operator (\c{++i}) advances the iterator to the
2157     next item in the hash and returns an iterator to the new current
2158     item.
2159 
2160     Calling this function on QHash::end() leads to undefined results.
2161 
2162     \sa operator--()
2163 */
2164 
2165 /*! \fn template <class Key, class T> QHash<Key, T>::const_iterator QHash<Key, T>::const_iterator::operator++(int)
2166 
2167     \overload
2168 
2169     The postfix ++ operator (\c{i++}) advances the iterator to the
2170     next item in the hash and returns an iterator to the previously
2171     current item.
2172 */
2173 
2174 /*! \class QHash::key_iterator
2175     \inmodule QtCore
2176     \since 5.6
2177     \brief The QHash::key_iterator class provides an STL-style const iterator for QHash keys.
2178 
2179     QHash::key_iterator is essentially the same as QHash::const_iterator
2180     with the difference that operator*() and operator->() return a key
2181     instead of a value.
2182 
2183     For most uses QHash::iterator and QHash::const_iterator should be used,
2184     you can easily access the key by calling QHash::iterator::key():
2185 
2186     \snippet code/src_corelib_tools_qhash.cpp 27
2187 
2188     However, to have interoperability between QHash's keys and STL-style
2189     algorithms we need an iterator that dereferences to a key instead
2190     of a value. With QHash::key_iterator we can apply an algorithm to a
2191     range of keys without having to call QHash::keys(), which is inefficient
2192     as it costs one QHash iteration and memory allocation to create a temporary
2193     QList.
2194 
2195     \snippet code/src_corelib_tools_qhash.cpp 28
2196 
2197     QHash::key_iterator is const, it's not possible to modify the key.
2198 
2199     The default QHash::key_iterator constructor creates an uninitialized
2200     iterator. You must initialize it using a QHash function like
2201     QHash::keyBegin() or QHash::keyEnd().
2202 
2203     \warning Iterators on implicitly shared containers do not work
2204     exactly like STL-iterators. You should avoid copying a container
2205     while iterators are active on that container. For more information,
2206     read \l{Implicit sharing iterator problem}.
2207 
2208     \sa QHash::const_iterator, QHash::iterator
2209 */
2210 
2211 /*! \fn template <class Key, class T> const T &QHash<Key, T>::key_iterator::operator*() const
2212 
2213     Returns the current item's key.
2214 */
2215 
2216 /*! \fn template <class Key, class T> const T *QHash<Key, T>::key_iterator::operator->() const
2217 
2218     Returns a pointer to the current item's key.
2219 */
2220 
2221 /*! \fn template <class Key, class T> bool QHash<Key, T>::key_iterator::operator==(key_iterator other) const
2222 
2223     Returns \c true if \a other points to the same item as this
2224     iterator; otherwise returns \c false.
2225 
2226     \sa operator!=()
2227 */
2228 
2229 /*! \fn template <class Key, class T> bool QHash<Key, T>::key_iterator::operator!=(key_iterator other) const
2230 
2231     Returns \c true if \a other points to a different item than this
2232     iterator; otherwise returns \c false.
2233 
2234     \sa operator==()
2235 */
2236 
2237 /*!
2238     \fn template <class Key, class T> QHash<Key, T>::key_iterator &QHash<Key, T>::key_iterator::operator++()
2239 
2240     The prefix ++ operator (\c{++i}) advances the iterator to the
2241     next item in the hash and returns an iterator to the new current
2242     item.
2243 
2244     Calling this function on QHash::keyEnd() leads to undefined results.
2245 
2246     \sa operator--()
2247 */
2248 
2249 /*! \fn template <class Key, class T> QHash<Key, T>::key_iterator QHash<Key, T>::key_iterator::operator++(int)
2250 
2251     \overload
2252 
2253     The postfix ++ operator (\c{i++}) advances the iterator to the
2254     next item in the hash and returns an iterator to the previous
2255     item.
2256 */
2257 
2258 /*! \fn template <class Key, class T> const_iterator QHash<Key, T>::key_iterator::base() const
2259     Returns the underlying const_iterator this key_iterator is based on.
2260 */
2261 
2262 /*! \typedef QHash::const_key_value_iterator
2263     \inmodule QtCore
2264     \since 5.10
2265     \brief The QHash::const_key_value_iterator typedef provides an STL-style const iterator for QHash.
2266 
2267     QHash::const_key_value_iterator is essentially the same as QHash::const_iterator
2268     with the difference that operator*() returns a key/value pair instead of a
2269     value.
2270 
2271     \sa QKeyValueIterator
2272 */
2273 
2274 /*! \typedef QHash::key_value_iterator
2275     \inmodule QtCore
2276     \since 5.10
2277     \brief The QHash::key_value_iterator typedef provides an STL-style iterator for QHash.
2278 
2279     QHash::key_value_iterator is essentially the same as QHash::iterator
2280     with the difference that operator*() returns a key/value pair instead of a
2281     value.
2282 
2283     \sa QKeyValueIterator
2284 */
2285 
2286 /*! \fn template <class Key, class T> QDataStream &operator<<(QDataStream &out, const QHash<Key, T>& hash)
2287     \relates QHash
2288 
2289     Writes the hash \a hash to stream \a out.
2290 
2291     This function requires the key and value types to implement \c
2292     operator<<().
2293 
2294     \sa {Serializing Qt Data Types}
2295 */
2296 
2297 /*! \fn template <class Key, class T> QDataStream &operator>>(QDataStream &in, QHash<Key, T> &hash)
2298     \relates QHash
2299 
2300     Reads a hash from stream \a in into \a hash.
2301 
2302     This function requires the key and value types to implement \c
2303     operator>>().
2304 
2305     \sa {Serializing Qt Data Types}
2306 */
2307 
2308 /*! \class QMultiHash
2309     \inmodule QtCore
2310     \brief The QMultiHash class is a convenience QHash subclass that provides multi-valued hashes.
2311 
2312     \ingroup tools
2313     \ingroup shared
2314 
2315     \reentrant
2316 
2317     QMultiHash\<Key, T\> is one of Qt's generic \l{container classes}.
2318     It inherits QHash and extends it with a few convenience functions
2319     that make it more suitable than QHash for storing multi-valued
2320     hashes. A multi-valued hash is a hash that allows multiple values
2321     with the same key.
2322 
2323     Because QMultiHash inherits QHash, all of QHash's functionality also
2324     applies to QMultiHash. For example, you can use isEmpty() to test
2325     whether the hash is empty, and you can traverse a QMultiHash using
2326     QHash's iterator classes (for example, QHashIterator). But opposed to
2327     QHash, it provides an insert() function will allow the insertion of
2328     multiple items with the same key. The replace() function corresponds to
2329     QHash::insert(). It also provides convenient operator+() and
2330     operator+=().
2331 
2332     Unlike QMultiMap, QMultiHash does not provide and ordering of the
2333     inserted items. The only guarantee is that items that
2334     share the same key will appear consecutively, from the most
2335     recently to the least recently inserted value.
2336 
2337     Example:
2338     \snippet code/src_corelib_tools_qhash.cpp 24
2339 
2340     Unlike QHash, QMultiHash provides no operator[]. Use value() or
2341     replace() if you want to access the most recently inserted item
2342     with a certain key.
2343 
2344     If you want to retrieve all the values for a single key, you can
2345     use values(const Key &key), which returns a QList<T>:
2346 
2347     \snippet code/src_corelib_tools_qhash.cpp 25
2348 
2349     The items that share the same key are available from most
2350     recently to least recently inserted.
2351 
2352     A more efficient approach is to call find() to get
2353     the STL-style iterator for the first item with a key and iterate from
2354     there:
2355 
2356     \snippet code/src_corelib_tools_qhash.cpp 26
2357 
2358     QMultiHash's key and value data types must be \l{assignable data
2359     types}. You cannot, for example, store a QWidget as a value;
2360     instead, store a QWidget *. In addition, QMultiHash's key type
2361     must provide operator==(), and there must also be a qHash() function
2362    in the type's namespace that returns a hash value for an argument of the
2363     key's type. See the QHash documentation for details.
2364 
2365     \sa QHash, QHashIterator, QMutableHashIterator, QMultiMap
2366 */
2367 
2368 /*! \fn template <class Key, class T> QMultiHash<Key, T>::QMultiHash()
2369 
2370     Constructs an empty hash.
2371 */
2372 
2373 /*! \fn template <class Key, class T> QMultiHash<Key, T>::QMultiHash(std::initializer_list<std::pair<Key,T> > list)
2374     \since 5.1
2375 
2376     Constructs a multi-hash with a copy of each of the elements in the
2377     initializer list \a list.
2378 
2379     This function is only available if the program is being
2380     compiled in C++11 mode.
2381 */
2382 
2383 /*! \fn template <class Key, class T> QMultiHash<Key, T>::QMultiHash(const QHash<Key, T> &other)
2384 
2385     Constructs a copy of \a other (which can be a QHash or a
2386     QMultiHash).
2387 
2388     \sa operator=()
2389 */
2390 
2391 /*! \fn template <class Key, class T> template <class InputIterator> QMultiHash<Key, T>::QMultiHash(InputIterator begin, InputIterator end)
2392     \since 5.14
2393 
2394     Constructs a multi-hash with a copy of each of the elements in the iterator range
2395     [\a begin, \a end). Either the elements iterated by the range must be
2396     objects with \c{first} and \c{second} data members (like \c{QPair},
2397     \c{std::pair}, etc.) convertible to \c Key and to \c T respectively; or the
2398     iterators must have \c{key()} and \c{value()} member functions, returning a
2399     key convertible to \c Key and a value convertible to \c T respectively.
2400 */
2401 
2402 /*! \fn template <class Key, class T> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::replace(const Key &key, const T &value)
2403 
2404     Inserts a new item with the \a key and a value of \a value.
2405 
2406     If there is already an item with the \a key, that item's value
2407     is replaced with \a value.
2408 
2409     If there are multiple items with the \a key, the most
2410     recently inserted item's value is replaced with \a value.
2411 
2412     \sa insert()
2413 */
2414 
2415 /*! \fn template <class Key, class T> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::insert(const Key &key, const T &value)
2416 
2417     Inserts a new item with the \a key and a value of \a value.
2418 
2419     If there is already an item with the same key in the hash, this
2420     function will simply create a new one. (This behavior is
2421     different from replace(), which overwrites the value of an
2422     existing item.)
2423 
2424     \sa replace()
2425 */
2426 
2427 /*!
2428     \fn template <typename T> template <typename ...Args> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::emplace(const Key &key, Args&&... args)
2429     \fn template <typename T> template <typename ...Args> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::emplace(Key &&key, Args&&... args)
2430 
2431     Inserts a new element into the container. This new element
2432     is constructed in-place using \a args as the arguments for its
2433     construction.
2434 
2435     If there is already an item with the same key in the hash, this
2436     function will simply create a new one. (This behavior is
2437     different from replace(), which overwrites the value of an
2438     existing item.)
2439 
2440     Returns an iterator pointing to the new element.
2441 
2442     \sa insert
2443 */
2444 
2445 /*!
2446     \fn template <typename T> template <typename ...Args> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::emplaceReplace(const Key &key, Args&&... args)
2447     \fn template <typename T> template <typename ...Args> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::emplaceReplace(Key &&key, Args&&... args)
2448 
2449     Inserts a new element into the container. This new element
2450     is constructed in-place using \a args as the arguments for its
2451     construction.
2452 
2453     If there is already an item with the same key in the hash, that item's
2454     value is replaced with a value constructed from \a args.
2455 
2456     Returns an iterator pointing to the new element.
2457 
2458     \sa replace, emplace
2459 */
2460 
2461 
2462 /*! \fn template <class Key, class T> QMultiHash &QMultiHash<Key, T>::unite(const QMultiHash &other)
2463     \since 5.13
2464 
2465     Inserts all the items in the \a other hash into this hash
2466     and returns a reference to this hash.
2467 
2468     \sa insert()
2469 */
2470 
2471 /*! \fn template <class Key, class T> QList<Key> QMultiHash<Key, T>::uniqueKeys() const
2472     \since 5.13
2473 
2474     Returns a list containing all the keys in the map. Keys that occur multiple
2475     times in the map occur only once in the returned list.
2476 
2477     \sa keys(), values()
2478 */
2479 
2480 /*! \fn template <class Key, class T> T QMultiHash<Key, T>::value(const Key &key, const T &defaultValue = T()) const
2481     \overload
2482 
2483     Returns the value associated with the \a key.
2484 
2485     If the hash contains no item with the \a key, the function
2486     returns \a defaultValue, which is a \l{default-constructed value} if the
2487     parameter has not been specified.
2488 
2489     If there are multiple
2490     items for the \a key in the hash, the value of the most recently
2491     inserted one is returned.
2492 */
2493 
2494 /*! \fn template <class Key, class T> QList<T> QMultiHash<Key, T>::values(const Key &key) const
2495     \overload
2496 
2497     Returns a list of all the values associated with the \a key,
2498     from the most recently inserted to the least recently inserted.
2499 
2500     \sa count(), insert()
2501 */
2502 
2503 /*! \fn template <class Key, class T> T &QMultiHash<Key, T>::operator[](const Key &key)
2504 
2505     Returns the value associated with the \a key as a modifiable reference.
2506 
2507     If the hash contains no item with the \a key, the function inserts
2508     a \l{default-constructed value} into the hash with the \a key, and
2509     returns a reference to it.
2510 
2511     If the hash contains multiple items with the \a key, this function returns
2512     a reference to the most recently inserted value.
2513 
2514     \sa insert(), value()
2515 */
2516 
2517 /*! \fn template <class Key, class T> QMultiHash &QMultiHash<Key, T>::operator+=(const QMultiHash &other)
2518 
2519     Inserts all the items in the \a other hash into this hash
2520     and returns a reference to this hash.
2521 
2522     \sa unite(), insert()
2523 */
2524 
2525 /*! \fn template <class Key, class T> QMultiHash QMultiHash<Key, T>::operator+(const QMultiHash &other) const
2526 
2527     Returns a hash that contains all the items in this hash in
2528     addition to all the items in \a other. If a key is common to both
2529     hashes, the resulting hash will contain the key multiple times.
2530 
2531     \sa operator+=()
2532 */
2533 
2534 /*!
2535     \fn template <class Key, class T> bool QMultiHash<Key, T>::contains(const Key &key, const T &value) const
2536     \since 4.3
2537 
2538     Returns \c true if the hash contains an item with the \a key and
2539     \a value; otherwise returns \c false.
2540 
2541     \sa contains()
2542 */
2543 
2544 /*!
2545     \fn template <class Key, class T> int QMultiHash<Key, T>::remove(const Key &key, const T &value)
2546     \since 4.3
2547 
2548     Removes all the items that have the \a key and the value \a
2549     value from the hash. Returns the number of items removed.
2550 
2551     \sa remove()
2552 */
2553 
2554 /*! \fn template <class Key, class T> T QMultiHash<Key, T>::take(const Key &key)
2555 
2556     Removes the item with the \a key from the hash and returns
2557     the value associated with it.
2558 
2559     If the item does not exist in the hash, the function simply
2560     returns a \l{default-constructed value}. If there are multiple
2561     items for \a key in the hash, only the most recently inserted one
2562     is removed.
2563 
2564     If you don't use the return value, remove() is more efficient.
2565 
2566     \sa remove()
2567 */
2568 
2569 /*! \fn template <class Key, class T> QList<Key> QMultiHash<Key, T>::keys() const
2570 
2571     Returns a list containing all the keys in the hash, in an
2572     arbitrary order. Keys that occur multiple times in the hash
2573     also occur multiple times in the list.
2574 
2575     The order is guaranteed to be the same as that used by values().
2576 
2577     \sa values(), key()
2578 */
2579 
2580 /*! \fn template <class Key, class T> QList<T> QMultiHash<Key, T>::values() const
2581 
2582     Returns a list containing all the values in the hash, in an
2583     arbitrary order. If a key is associated with multiple values, all of
2584     its values will be in the list, and not just the most recently
2585     inserted one.
2586 
2587     The order is guaranteed to be the same as that used by keys().
2588 
2589     \sa keys(), value()
2590 */
2591 
2592 /*!
2593     \fn template <class Key, class T> Key QMultiHash<Key, T>::key(const T &value, const Key &defaultKey = Key()) const
2594     \since 4.3
2595 
2596     Returns the first key mapped to \a value, or \a defaultKey if the
2597     hash contains no item mapped to \a value.
2598 
2599     This function can be slow (\l{linear time}), because QMultiHash's
2600     internal data structure is optimized for fast lookup by key, not
2601     by value.
2602 */
2603 
2604 /*!
2605     \fn template <class Key, class T> int QMultiHash<Key, T>::count(const Key &key, const T &value) const
2606     \since 4.3
2607 
2608     Returns the number of items with the \a key and \a value.
2609 
2610     \sa count()
2611 */
2612 
2613 /*!
2614     \fn template <class Key, class T> typename QMultiHash<Key, T>::iterator QMultiHash<Key, T>::find(const Key &key, const T &value)
2615     \since 4.3
2616 
2617     Returns an iterator pointing to the item with the \a key and \a value.
2618     If the hash contains no such item, the function returns end().
2619 
2620     If the hash contains multiple items with the \a key and \a value, the
2621     iterator returned points to the most recently inserted item.
2622 */
2623 
2624 /*!
2625     \fn template <class Key, class T> typename QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::find(const Key &key, const T &value) const
2626     \since 4.3
2627     \overload
2628 */
2629 
2630 /*!
2631     \fn template <class Key, class T> typename QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::constFind(const Key &key, const T &value) const
2632     \since 4.3
2633 
2634     Returns an iterator pointing to the item with the \a key and the
2635     \a value in the hash.
2636 
2637     If the hash contains no such item, the function returns
2638     constEnd().
2639 */
2640 
2641 /*! \fn template <class Key, class T> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::begin()
2642 
2643     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first item in
2644     the hash.
2645 
2646     \sa constBegin(), end()
2647 */
2648 
2649 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::begin() const
2650 
2651     \overload
2652 */
2653 
2654 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::cbegin() const
2655     \since 5.0
2656 
2657     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first item
2658     in the hash.
2659 
2660     \sa begin(), cend()
2661 */
2662 
2663 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::constBegin() const
2664 
2665     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first item
2666     in the hash.
2667 
2668     \sa begin(), constEnd()
2669 */
2670 
2671 /*! \fn template <class Key, class T> QMultiHash<Key, T>::key_iterator QMultiHash<Key, T>::keyBegin() const
2672     \since 5.6
2673 
2674     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first key
2675     in the hash.
2676 
2677     \sa keyEnd()
2678 */
2679 
2680 /*! \fn template <class Key, class T> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::end()
2681 
2682     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary item
2683     after the last item in the hash.
2684 
2685     \sa begin(), constEnd()
2686 */
2687 
2688 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::end() const
2689 
2690     \overload
2691 */
2692 
2693 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::constEnd() const
2694 
2695     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
2696     item after the last item in the hash.
2697 
2698     \sa constBegin(), end()
2699 */
2700 
2701 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::cend() const
2702     \since 5.0
2703 
2704     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
2705     item after the last item in the hash.
2706 
2707     \sa cbegin(), end()
2708 */
2709 
2710 /*! \fn template <class Key, class T> QMultiHash<Key, T>::key_iterator QMultiHash<Key, T>::keyEnd() const
2711     \since 5.6
2712 
2713     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
2714     item after the last key in the hash.
2715 
2716     \sa keyBegin()
2717 */
2718 
2719 /*! \fn template <class Key, class T> QMultiHash<Key, T>::key_value_iterator QMultiHash<Key, T>::keyValueBegin()
2720     \since 5.10
2721 
2722     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first entry
2723     in the hash.
2724 
2725     \sa keyValueEnd()
2726 */
2727 
2728 /*! \fn template <class Key, class T> QMultiHash<Key, T>::key_value_iterator QMultiHash<Key, T>::keyValueEnd()
2729     \since 5.10
2730 
2731     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
2732     entry after the last entry in the hash.
2733 
2734     \sa keyValueBegin()
2735 */
2736 
2737 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_key_value_iterator QMultiHash<Key, T>::keyValueBegin() const
2738     \since 5.10
2739 
2740     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first entry
2741     in the hash.
2742 
2743     \sa keyValueEnd()
2744 */
2745 
2746 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_key_value_iterator QMultiHash<Key, T>::constKeyValueBegin() const
2747     \since 5.10
2748 
2749     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first entry
2750     in the hash.
2751 
2752     \sa keyValueBegin()
2753 */
2754 
2755 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_key_value_iterator QMultiHash<Key, T>::keyValueEnd() const
2756     \since 5.10
2757 
2758     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
2759     entry after the last entry in the hash.
2760 
2761     \sa keyValueBegin()
2762 */
2763 
2764 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_key_value_iterator QMultiHash<Key, T>::constKeyValueEnd() const
2765     \since 5.10
2766 
2767     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
2768     entry after the last entry in the hash.
2769 
2770     \sa constKeyValueBegin()
2771 */
2772 
2773 
2774 /*! \class QMultiHash::iterator
2775     \inmodule QtCore
2776     \brief The QMultiHash::iterator class provides an STL-style non-const iterator for QMultiHash.
2777 
2778     QMultiHash features both \l{STL-style iterators} and \l{Java-style
2779     iterators}. The STL-style iterators are more low-level and more
2780     cumbersome to use; on the other hand, they are slightly faster
2781     and, for developers who already know STL, have the advantage of
2782     familiarity.
2783 
2784     QMultiHash\<Key, T\>::iterator allows you to iterate over a QMultiHash
2785     and to modify the value (but not the key) associated
2786     with a particular key. If you want to iterate over a const QMultiHash,
2787     you should use QMultiHash::const_iterator. It is generally good
2788     practice to use QMultiHash::const_iterator on a non-const QMultiHash as
2789     well, unless you need to change the QMultiHash through the iterator.
2790     Const iterators are slightly faster, and can improve code
2791     readability.
2792 
2793     The default QMultiHash::iterator constructor creates an uninitialized
2794     iterator. You must initialize it using a QMultiHash function like
2795     QMultiHash::begin(), QMultiHash::end(), or QMultiHash::find() before you can
2796     start iterating. Here's a typical loop that prints all the (key,
2797     value) pairs stored in a hash:
2798 
2799     \snippet code/src_corelib_tools_qhash.cpp 17
2800 
2801     Unlike QMap, which orders its items by key, QMultiHash stores its
2802     items in an arbitrary order.
2803 
2804     Let's see a few examples of things we can do with a
2805     QMultiHash::iterator that we cannot do with a QMultiHash::const_iterator.
2806     Here's an example that increments every value stored in the QMultiHash
2807     by 2:
2808 
2809     \snippet code/src_corelib_tools_qhash.cpp 18
2810 
2811     Here's an example that removes all the items whose key is a
2812     string that starts with an underscore character:
2813 
2814     \snippet code/src_corelib_tools_qhash.cpp 19
2815 
2816     The call to QMultiHash::erase() removes the item pointed to by the
2817     iterator from the hash, and returns an iterator to the next item.
2818     Here's another way of removing an item while iterating:
2819 
2820     \snippet code/src_corelib_tools_qhash.cpp 20
2821 
2822     It might be tempting to write code like this:
2823 
2824     \snippet code/src_corelib_tools_qhash.cpp 21
2825 
2826     However, this will potentially crash in \c{++i}, because \c i is
2827     a dangling iterator after the call to erase().
2828 
2829     Multiple iterators can be used on the same hash. However, be aware
2830     that any modification performed directly on the QHash (inserting and
2831     removing items) can cause the iterators to become invalid.
2832 
2833     Inserting items into the hash or calling methods such as QHash::reserve()
2834     or QHash::squeeze() can invalidate all iterators pointing into the hash.
2835     Iterators are guaranteed to stay valid only as long as the QHash doesn't have
2836     to grow/shrink its internal hash table.
2837     Using any iterator after a rehashing operation has occurred will lead to undefined behavior.
2838 
2839     You can however safely use iterators to remove entries from the hash
2840     using the QHash::erase() method. This function can safely be called while
2841     iterating, and won't affect the order of items in the hash.
2842 
2843     If you need to keep iterators over a long period of time, we recommend
2844     that you use QMultiMap rather than QHash.
2845 
2846     \warning Iterators on implicitly shared containers do not work
2847     exactly like STL-iterators. You should avoid copying a container
2848     while iterators are active on that container. For more information,
2849     read \l{Implicit sharing iterator problem}.
2850 
2851     \sa QMultiHash::const_iterator, QMultiHash::key_iterator, QMutableHashIterator
2852 */
2853 
2854 /*! \fn template <class Key, class T> QMultiHash<Key, T>::iterator::iterator()
2855 
2856     Constructs an uninitialized iterator.
2857 
2858     Functions like key(), value(), and operator++() must not be
2859     called on an uninitialized iterator. Use operator=() to assign a
2860     value to it before using it.
2861 
2862     \sa QMultiHash::begin(), QMultiHash::end()
2863 */
2864 
2865 /*! \fn template <class Key, class T> const Key &QMultiHash<Key, T>::iterator::key() const
2866 
2867     Returns the current item's key as a const reference.
2868 
2869     There is no direct way of changing an item's key through an
2870     iterator, although it can be done by calling QMultiHash::erase()
2871     followed by QMultiHash::insert().
2872 
2873     \sa value()
2874 */
2875 
2876 /*! \fn template <class Key, class T> T &QMultiHash<Key, T>::iterator::value() const
2877 
2878     Returns a modifiable reference to the current item's value.
2879 
2880     You can change the value of an item by using value() on
2881     the left side of an assignment, for example:
2882 
2883     \snippet code/src_corelib_tools_qhash.cpp 22
2884 
2885     \sa key(), operator*()
2886 */
2887 
2888 /*! \fn template <class Key, class T> T &QMultiHash<Key, T>::iterator::operator*() const
2889 
2890     Returns a modifiable reference to the current item's value.
2891 
2892     Same as value().
2893 
2894     \sa key()
2895 */
2896 
2897 /*! \fn template <class Key, class T> T *QMultiHash<Key, T>::iterator::operator->() const
2898 
2899     Returns a pointer to the current item's value.
2900 
2901     \sa value()
2902 */
2903 
2904 /*!
2905     \fn template <class Key, class T> bool QMultiHash<Key, T>::iterator::operator==(const iterator &other) const
2906     \fn template <class Key, class T> bool QMultiHash<Key, T>::iterator::operator==(const const_iterator &other) const
2907 
2908     Returns \c true if \a other points to the same item as this
2909     iterator; otherwise returns \c false.
2910 
2911     \sa operator!=()
2912 */
2913 
2914 /*!
2915     \fn template <class Key, class T> bool QMultiHash<Key, T>::iterator::operator!=(const iterator &other) const
2916     \fn template <class Key, class T> bool QMultiHash<Key, T>::iterator::operator!=(const const_iterator &other) const
2917 
2918     Returns \c true if \a other points to a different item than this
2919     iterator; otherwise returns \c false.
2920 
2921     \sa operator==()
2922 */
2923 
2924 /*!
2925     \fn template <class Key, class T> QMultiHash<Key, T>::iterator &QMultiHash<Key, T>::iterator::operator++()
2926 
2927     The prefix ++ operator (\c{++i}) advances the iterator to the
2928     next item in the hash and returns an iterator to the new current
2929     item.
2930 
2931     Calling this function on QMultiHash::end() leads to undefined results.
2932 */
2933 
2934 /*! \fn template <class Key, class T> QMultiHash<Key, T>::iterator QMultiHash<Key, T>::iterator::operator++(int)
2935 
2936     \overload
2937 
2938     The postfix ++ operator (\c{i++}) advances the iterator to the
2939     next item in the hash and returns an iterator to the previously
2940     current item.
2941 */
2942 
2943 /*! \class QMultiHash::const_iterator
2944     \inmodule QtCore
2945     \brief The QMultiHash::const_iterator class provides an STL-style const iterator for QMultiHash.
2946 
2947     QMultiHash features both \l{STL-style iterators} and \l{Java-style
2948     iterators}. The STL-style iterators are more low-level and more
2949     cumbersome to use; on the other hand, they are slightly faster
2950     and, for developers who already know STL, have the advantage of
2951     familiarity.
2952 
2953     QMultiHash\<Key, T\>::const_iterator allows you to iterate over a
2954     QMultiHash. If you want to modify the QMultiHash as you
2955     iterate over it, you must use QMultiHash::iterator instead. It is
2956     generally good practice to use QMultiHash::const_iterator on a
2957     non-const QMultiHash as well, unless you need to change the QMultiHash
2958     through the iterator. Const iterators are slightly faster, and
2959     can improve code readability.
2960 
2961     The default QMultiHash::const_iterator constructor creates an
2962     uninitialized iterator. You must initialize it using a QMultiHash
2963     function like QMultiHash::constBegin(), QMultiHash::constEnd(), or
2964     QMultiHash::find() before you can start iterating. Here's a typical
2965     loop that prints all the (key, value) pairs stored in a hash:
2966 
2967     \snippet code/src_corelib_tools_qhash.cpp 23
2968 
2969     Unlike QMap, which orders its items by key, QMultiHash stores its
2970     items in an arbitrary order. The only guarantee is that items that
2971     share the same key (because they were inserted using
2972     a QMultiHash) will appear consecutively, from the most
2973     recently to the least recently inserted value.
2974 
2975     Multiple iterators can be used on the same hash. However, be aware
2976     that any modification performed directly on the QHash (inserting and
2977     removing items) can cause the iterators to become invalid.
2978 
2979     Inserting items into the hash or calling methods such as QHash::reserve()
2980     or QHash::squeeze() can invalidate all iterators pointing into the hash.
2981     Iterators are guaranteed to stay valid only as long as the QHash doesn't have
2982     to grow/shrink it's internal hash table.
2983     Using any iterator after a rehashing operation ahs occurred will lead to undefined behavior.
2984 
2985     You can however safely use iterators to remove entries from the hash
2986     using the QHash::erase() method. This function can safely be called while
2987     iterating, and won't affect the order of items in the hash.
2988 
2989     If you need to keep iterators over a long period of time, we recommend
2990     that you use QMap rather than QHash.
2991 
2992     \warning Iterators on implicitly shared containers do not work
2993     exactly like STL-iterators. You should avoid copying a container
2994     while iterators are active on that container. For more information,
2995     read \l{Implicit sharing iterator problem}.
2996 
2997     \sa QMultiHash::iterator, QMultiHashIterator
2998 */
2999 
3000 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator::const_iterator()
3001 
3002     Constructs an uninitialized iterator.
3003 
3004     Functions like key(), value(), and operator++() must not be
3005     called on an uninitialized iterator. Use operator=() to assign a
3006     value to it before using it.
3007 
3008     \sa QMultiHash::constBegin(), QMultiHash::constEnd()
3009 */
3010 
3011 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator::const_iterator(const iterator &other)
3012 
3013     Constructs a copy of \a other.
3014 */
3015 
3016 /*! \fn template <class Key, class T> const Key &QMultiHash<Key, T>::const_iterator::key() const
3017 
3018     Returns the current item's key.
3019 
3020     \sa value()
3021 */
3022 
3023 /*! \fn template <class Key, class T> const T &QMultiHash<Key, T>::const_iterator::value() const
3024 
3025     Returns the current item's value.
3026 
3027     \sa key(), operator*()
3028 */
3029 
3030 /*! \fn template <class Key, class T> const T &QMultiHash<Key, T>::const_iterator::operator*() const
3031 
3032     Returns the current item's value.
3033 
3034     Same as value().
3035 
3036     \sa key()
3037 */
3038 
3039 /*! \fn template <class Key, class T> const T *QMultiHash<Key, T>::const_iterator::operator->() const
3040 
3041     Returns a pointer to the current item's value.
3042 
3043     \sa value()
3044 */
3045 
3046 /*! \fn template <class Key, class T> bool QMultiHash<Key, T>::const_iterator::operator==(const const_iterator &other) const
3047 
3048     Returns \c true if \a other points to the same item as this
3049     iterator; otherwise returns \c false.
3050 
3051     \sa operator!=()
3052 */
3053 
3054 /*! \fn template <class Key, class T> bool QMultiHash<Key, T>::const_iterator::operator!=(const const_iterator &other) const
3055 
3056     Returns \c true if \a other points to a different item than this
3057     iterator; otherwise returns \c false.
3058 
3059     \sa operator==()
3060 */
3061 
3062 /*!
3063     \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator &QMultiHash<Key, T>::const_iterator::operator++()
3064 
3065     The prefix ++ operator (\c{++i}) advances the iterator to the
3066     next item in the hash and returns an iterator to the new current
3067     item.
3068 
3069     Calling this function on QMultiHash::end() leads to undefined results.
3070 
3071     \sa operator--()
3072 */
3073 
3074 /*! \fn template <class Key, class T> QMultiHash<Key, T>::const_iterator QMultiHash<Key, T>::const_iterator::operator++(int)
3075 
3076     \overload
3077 
3078     The postfix ++ operator (\c{i++}) advances the iterator to the
3079     next item in the hash and returns an iterator to the previously
3080     current item.
3081 */
3082 
3083 /*! \class QMultiHash::key_iterator
3084     \inmodule QtCore
3085     \since 5.6
3086     \brief The QMultiHash::key_iterator class provides an STL-style const iterator for QMultiHash keys.
3087 
3088     QMultiHash::key_iterator is essentially the same as QMultiHash::const_iterator
3089     with the difference that operator*() and operator->() return a key
3090     instead of a value.
3091 
3092     For most uses QMultiHash::iterator and QMultiHash::const_iterator should be used,
3093     you can easily access the key by calling QMultiHash::iterator::key():
3094 
3095     \snippet code/src_corelib_tools_qhash.cpp 27
3096 
3097     However, to have interoperability between QMultiHash's keys and STL-style
3098     algorithms we need an iterator that dereferences to a key instead
3099     of a value. With QMultiHash::key_iterator we can apply an algorithm to a
3100     range of keys without having to call QMultiHash::keys(), which is inefficient
3101     as it costs one QMultiHash iteration and memory allocation to create a temporary
3102     QList.
3103 
3104     \snippet code/src_corelib_tools_qhash.cpp 28
3105 
3106     QMultiHash::key_iterator is const, it's not possible to modify the key.
3107 
3108     The default QMultiHash::key_iterator constructor creates an uninitialized
3109     iterator. You must initialize it using a QMultiHash function like
3110     QMultiHash::keyBegin() or QMultiHash::keyEnd().
3111 
3112     \warning Iterators on implicitly shared containers do not work
3113     exactly like STL-iterators. You should avoid copying a container
3114     while iterators are active on that container. For more information,
3115     read \l{Implicit sharing iterator problem}.
3116 
3117     \sa QMultiHash::const_iterator, QMultiHash::iterator
3118 */
3119 
3120 /*! \fn template <class Key, class T> const T &QMultiHash<Key, T>::key_iterator::operator*() const
3121 
3122     Returns the current item's key.
3123 */
3124 
3125 /*! \fn template <class Key, class T> const T *QMultiHash<Key, T>::key_iterator::operator->() const
3126 
3127     Returns a pointer to the current item's key.
3128 */
3129 
3130 /*! \fn template <class Key, class T> bool QMultiHash<Key, T>::key_iterator::operator==(key_iterator other) const
3131 
3132     Returns \c true if \a other points to the same item as this
3133     iterator; otherwise returns \c false.
3134 
3135     \sa operator!=()
3136 */
3137 
3138 /*! \fn template <class Key, class T> bool QMultiHash<Key, T>::key_iterator::operator!=(key_iterator other) const
3139 
3140     Returns \c true if \a other points to a different item than this
3141     iterator; otherwise returns \c false.
3142 
3143     \sa operator==()
3144 */
3145 
3146 /*!
3147     \fn template <class Key, class T> QMultiHash<Key, T>::key_iterator &QMultiHash<Key, T>::key_iterator::operator++()
3148 
3149     The prefix ++ operator (\c{++i}) advances the iterator to the
3150     next item in the hash and returns an iterator to the new current
3151     item.
3152 
3153     Calling this function on QMultiHash::keyEnd() leads to undefined results.
3154 
3155     \sa operator--()
3156 */
3157 
3158 /*! \fn template <class Key, class T> QMultiHash<Key, T>::key_iterator QMultiHash<Key, T>::key_iterator::operator++(int)
3159 
3160     \overload
3161 
3162     The postfix ++ operator (\c{i++}) advances the iterator to the
3163     next item in the hash and returns an iterator to the previous
3164     item.
3165 */
3166 
3167 /*! \fn template <class Key, class T> const_iterator QMultiHash<Key, T>::key_iterator::base() const
3168     Returns the underlying const_iterator this key_iterator is based on.
3169 */
3170 
3171 /*! \typedef QMultiHash::const_key_value_iterator
3172     \inmodule QtCore
3173     \since 5.10
3174     \brief The QMap::const_key_value_iterator typedef provides an STL-style const iterator for QMultiHash and QMultiHash.
3175 
3176     QMultiHash::const_key_value_iterator is essentially the same as QMultiHash::const_iterator
3177     with the difference that operator*() returns a key/value pair instead of a
3178     value.
3179 
3180     \sa QKeyValueIterator
3181 */
3182 
3183 /*! \typedef QMultiHash::key_value_iterator
3184     \inmodule QtCore
3185     \since 5.10
3186     \brief The QMap::key_value_iterator typedef provides an STL-style iterator for QMultiHash and QMultiHash.
3187 
3188     QMultiHash::key_value_iterator is essentially the same as QMultiHash::iterator
3189     with the difference that operator*() returns a key/value pair instead of a
3190     value.
3191 
3192     \sa QKeyValueIterator
3193 */
3194 
3195 /*! \fn template <class Key, class T> QDataStream &operator<<(QDataStream &out, const QMultiHash<Key, T>& hash)
3196     \relates QMultiHash
3197 
3198     Writes the hash \a hash to stream \a out.
3199 
3200     This function requires the key and value types to implement \c
3201     operator<<().
3202 
3203     \sa {Serializing Qt Data Types}
3204 */
3205 
3206 /*! \fn template <class Key, class T> QDataStream &operator>>(QDataStream &in, QMultiHash<Key, T> &hash)
3207     \relates QMultiHash
3208 
3209     Reads a hash from stream \a in into \a hash.
3210 
3211     This function requires the key and value types to implement \c
3212     operator>>().
3213 
3214     \sa {Serializing Qt Data Types}
3215 */
3216 
3217 /*!
3218     \fn template <class Key, class T> size_t qHash(const QHash<Key, T> &key, size_t seed = 0)
3219     \since 5.8
3220     \relates QHash
3221 
3222     Returns the hash value for the \a key, using \a seed to seed the calculation.
3223 
3224     Type \c T must be supported by qHash().
3225 */
3226 
3227 /*!
3228     \fn template <class Key, class T> size_t qHash(const QMultiHash<Key, T> &key, size_t seed = 0)
3229     \since 5.8
3230     \relates QMultiHash
3231 
3232     Returns the hash value for the \a key, using \a seed to seed the calculation.
3233 
3234     Type \c T must be supported by qHash().
3235 */
3236 
3237 QT_END_NAMESPACE
