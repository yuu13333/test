I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2014 BlackBerry Limited. All rights reserved.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtNetwork module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qhttpnetworkconnectionchannel_p.h"
42 #include "qhttpnetworkconnection_p.h"
43 #include "private/qnoncontiguousbytedevice_p.h"
44 
45 #include <qpair.h>
46 #include <qdebug.h>
47 #include <QScopedValueRollback>
48 
49 #ifndef QT_NO_HTTP
50 
51 #include <private/qhttp2protocolhandler_p.h>
52 #include <private/qhttpprotocolhandler_p.h>
53 #include <private/qspdyprotocolhandler_p.h>
54 
55 #ifndef QT_NO_SSL
56 #    include <private/qsslsocket_p.h>
57 #    include <QtNetwork/qsslkey.h>
58 #    include <QtNetwork/qsslcipher.h>
59 #    include <QtNetwork/qsslconfiguration.h>
60 #endif
61 
62 #ifndef QT_NO_BEARERMANAGEMENT
63 #include "private/qnetworksession_p.h"
64 #endif
65 
66 QT_BEGIN_NAMESPACE
67 
68 // TODO: Put channel specific stuff here so it does not polute qhttpnetworkconnection.cpp
69 
70 // Because in-flight when sending a request, the server might close our connection (because the persistent HTTP
71 // connection times out)
72 // We use 3 because we can get a _q_error 3 times depending on the timing:
73 static const int reconnectAttemptsDefault = 3;
74 
75 QHttpNetworkConnectionChannel::QHttpNetworkConnectionChannel()
76     : socket(0)
77     , ssl(false)
78     , isInitialized(false)
79     , state(IdleState)
80     , reply(0)
81     , written(0)
82     , bytesTotal(0)
83     , resendCurrent(false)
84     , lastStatus(0)
85     , pendingEncrypt(false)
86     , reconnectAttempts(reconnectAttemptsDefault)
87     , authMethod(QAuthenticatorPrivate::None)
88     , proxyAuthMethod(QAuthenticatorPrivate::None)
89     , authenticationCredentialsSent(false)
90     , proxyCredentialsSent(false)
91     , protocolHandler(0)
92 #ifndef QT_NO_SSL
93     , ignoreAllSslErrors(false)
94 #endif
95     , pipeliningSupported(PipeliningSupportUnknown)
96     , networkLayerPreference(QAbstractSocket::AnyIPProtocol)
97     , connection(0)
98 {
99     // Inlining this function in the header leads to compiler error on
100     // release-armv5, on at least timebox 9.2 and 10.1.
101 }
102 
103 void QHttpNetworkConnectionChannel::init()
104 {
105 #ifndef QT_NO_SSL
106     if (connection->d_func()->encrypt)
107         socket = new QSslSocket;
108     else
109         socket = new QTcpSocket;
110 #else
111     socket = new QTcpSocket;
112 #endif
113 #ifndef QT_NO_BEARERMANAGEMENT
114     //push session down to socket
115     if (networkSession)
116         socket->setProperty("_q_networksession", QVariant::fromValue(networkSession));
117 #endif
118 #ifndef QT_NO_NETWORKPROXY
119     // Set by QNAM anyway, but let's be safe here
120     socket->setProxy(QNetworkProxy::NoProxy);
121 #endif
122 
123     // After some back and forth in all the last years, this is now a DirectConnection because otherwise
124     // the state inside the *Socket classes gets messed up, also in conjunction with the socket notifiers
125     // which behave slightly differently on Windows vs Linux
126     QObject::connect(socket, SIGNAL(bytesWritten(qint64)),
127                      this, SLOT(_q_bytesWritten(qint64)),
128                      Qt::DirectConnection);
129     QObject::connect(socket, SIGNAL(connected()),
130                      this, SLOT(_q_connected()),
131                      Qt::DirectConnection);
132     QObject::connect(socket, SIGNAL(readyRead()),
133                      this, SLOT(_q_readyRead()),
134                      Qt::DirectConnection);
135 
136     // The disconnected() and error() signals may already come
137     // while calling connectToHost().
138     // In case of a cached hostname or an IP this
139     // will then emit a signal to the user of QNetworkReply
140     // but cannot be caught because the user did not have a chance yet
141     // to connect to QNetworkReply's signals.
142     qRegisterMetaType<QAbstractSocket::SocketError>();
143     QObject::connect(socket, SIGNAL(disconnected()),
144                      this, SLOT(_q_disconnected()),
145                      Qt::DirectConnection);
146     QObject::connect(socket, SIGNAL(error(QAbstractSocket::SocketError)),
147                      this, SLOT(_q_error(QAbstractSocket::SocketError)),
148                      Qt::DirectConnection);
149 
150 
151 #ifndef QT_NO_NETWORKPROXY
152     QObject::connect(socket, SIGNAL(proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
153                      this, SLOT(_q_proxyAuthenticationRequired(QNetworkProxy,QAuthenticator*)),
154                      Qt::DirectConnection);
155 #endif
156 
157 #ifndef QT_NO_SSL
158     QSslSocket *sslSocket = qobject_cast<QSslSocket*>(socket);
159     if (sslSocket) {
160         // won't be a sslSocket if encrypt is false
161         QObject::connect(sslSocket, SIGNAL(encrypted()),
162                          this, SLOT(_q_encrypted()),
163                          Qt::DirectConnection);
164         QObject::connect(sslSocket, SIGNAL(sslErrors(QList<QSslError>)),
165                          this, SLOT(_q_sslErrors(QList<QSslError>)),
166                          Qt::DirectConnection);
167         QObject::connect(sslSocket, SIGNAL(preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator*)),
168                          this, SLOT(_q_preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator*)),
169                          Qt::DirectConnection);
170         QObject::connect(sslSocket, SIGNAL(encryptedBytesWritten(qint64)),
171                          this, SLOT(_q_encryptedBytesWritten(qint64)),
172                          Qt::DirectConnection);
173 
174         if (ignoreAllSslErrors)
175             sslSocket->ignoreSslErrors();
176 
177         if (!ignoreSslErrorsList.isEmpty())
178             sslSocket->ignoreSslErrors(ignoreSslErrorsList);
179 
180         if (!sslConfiguration.isNull())
181            sslSocket->setSslConfiguration(sslConfiguration);
182     } else {
183 #endif // !QT_NO_SSL
184         if (connection->connectionType() == QHttpNetworkConnection::ConnectionTypeHTTP2)
185             protocolHandler.reset(new QHttp2ProtocolHandler(this));
186         else
187             protocolHandler.reset(new QHttpProtocolHandler(this));
188 #ifndef QT_NO_SSL
189     }
190 #endif
191 
192 #ifndef QT_NO_NETWORKPROXY
193     if (proxy.type() != QNetworkProxy::NoProxy)
194         socket->setProxy(proxy);
195 #endif
196     isInitialized = true;
197 }
198 
199 
200 void QHttpNetworkConnectionChannel::close()
201 {
202     // socket can be 0 since the host lookup is done from qhttpnetworkconnection.cpp while
203     // there is no socket yet; we may also clear it, below or in abort, to avoid recursion.
204     const bool idle = !socket || socket->state() == QAbstractSocket::UnconnectedState;
205     // pendingEncrypt must only be true in between connected and encrypted states
206     pendingEncrypt = false;
207 
208     if (socket) {
209         QAbstractSocket *const detached = socket;
210         QScopedValueRollback<QAbstractSocket *> rollback(socket, nullptr);
211         detached->close(); // error states can cause recursion back to this method.
212     }
213 
214     // Set state *after* close(), to override any recursive call's idle setting:
215     state = idle ? IdleState : ClosingState;
216 }
217 
218 void QHttpNetworkConnectionChannel::abort()
219 {
220     // socket can be 0 since the host lookup is done from qhttpnetworkconnection.cpp while
221     // there is no socket yet; we may also clear it, below or in close, to avoid recursion.
222     const bool idle = !socket || socket->state() == QAbstractSocket::UnconnectedState;
223     // pendingEncrypt must only be true in between connected and encrypted states
224     pendingEncrypt = false;
225 
226     if (socket) {
227         QAbstractSocket *const detached = socket;
228         QScopedValueRollback<QAbstractSocket *> rollback(socket, nullptr);
229         detached->abort();
230     }
231 
232     // Set state *after* abort(), to override any recursive call's idle setting:
233     state = idle ? IdleState : ClosingState;
234 }
235 
236 
237 bool QHttpNetworkConnectionChannel::sendRequest()
238 {
239     Q_ASSERT(!protocolHandler.isNull());
240     return protocolHandler->sendRequest();
241 }
242 
243 
244 void QHttpNetworkConnectionChannel::_q_receiveReply()
245 {
246     Q_ASSERT(!protocolHandler.isNull());
247     protocolHandler->_q_receiveReply();
248 }
249 
250 void QHttpNetworkConnectionChannel::_q_readyRead()
251 {
252     Q_ASSERT(!protocolHandler.isNull());
253     protocolHandler->_q_readyRead();
254 }
255 
256 // called when unexpectedly reading a -1 or when data is expected but socket is closed
257 void QHttpNetworkConnectionChannel::handleUnexpectedEOF()
258 {
259     Q_ASSERT(reply);
260     if (reconnectAttempts <= 0) {
261         // too many errors reading/receiving/parsing the status, close the socket and emit error
262         requeueCurrentlyPipelinedRequests();
263         close();
264         reply->d_func()->errorString = connection->d_func()->errorDetail(QNetworkReply::RemoteHostClosedError, socket);
265         emit reply->finishedWithError(QNetworkReply::RemoteHostClosedError, reply->d_func()->errorString);
266         reply = 0;
267         if (protocolHandler)
268             protocolHandler->setReply(0);
269         request = QHttpNetworkRequest();
270         QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
271     } else {
272         reconnectAttempts--;
273         reply->d_func()->clear();
274         reply->d_func()->connection = connection;
275         reply->d_func()->connectionChannel = this;
276         closeAndResendCurrentRequest();
277     }
278 }
279 
280 bool QHttpNetworkConnectionChannel::ensureConnection()
281 {
282     if (!isInitialized)
283         init();
284 
285     QAbstractSocket::SocketState socketState = socket->state();
286 
287     // resend this request after we receive the disconnected signal
288     // If !socket->isOpen() then we have already called close() on the socket, but there was still a
289     // pending connectToHost() for which we hadn't seen a connected() signal, yet. The connected()
290     // has now arrived (as indicated by socketState != ClosingState), but we cannot send anything on
291     // such a socket anymore.
292     if (socketState == QAbstractSocket::ClosingState ||
293             (socketState != QAbstractSocket::UnconnectedState && !socket->isOpen())) {
294         if (reply)
295             resendCurrent = true;
296         return false;
297     }
298 
299     // already trying to connect?
300     if (socketState == QAbstractSocket::HostLookupState ||
301         socketState == QAbstractSocket::ConnectingState) {
302         return false;
303     }
304 
305     // make sure that this socket is in a connected state, if not initiate
306     // connection to the host.
307     if (socketState != QAbstractSocket::ConnectedState) {
308         // connect to the host if not already connected.
309         state = QHttpNetworkConnectionChannel::ConnectingState;
310         pendingEncrypt = ssl;
311 
312         // reset state
313         pipeliningSupported = PipeliningSupportUnknown;
314         authenticationCredentialsSent = false;
315         proxyCredentialsSent = false;
316         authenticator.detach();
317         QAuthenticatorPrivate *priv = QAuthenticatorPrivate::getPrivate(authenticator);
318         priv->hasFailed = false;
319         proxyAuthenticator.detach();
320         priv = QAuthenticatorPrivate::getPrivate(proxyAuthenticator);
321         priv->hasFailed = false;
322 
323         // This workaround is needed since we use QAuthenticator for NTLM authentication. The "phase == Done"
324         // is the usual criteria for emitting authentication signals. The "phase" is set to "Done" when the
325         // last header for Authorization is generated by the QAuthenticator. Basic & Digest logic does not
326         // check the "phase" for generating the Authorization header. NTLM authentication is a two stage
327         // process & needs the "phase". To make sure the QAuthenticator uses the current username/password
328         // the phase is reset to Start.
329         priv = QAuthenticatorPrivate::getPrivate(authenticator);
330         if (priv && priv->phase == QAuthenticatorPrivate::Done)
331             priv->phase = QAuthenticatorPrivate::Start;
332         priv = QAuthenticatorPrivate::getPrivate(proxyAuthenticator);
333         if (priv && priv->phase == QAuthenticatorPrivate::Done)
334             priv->phase = QAuthenticatorPrivate::Start;
335 
336         QString connectHost = connection->d_func()->hostName;
337         quint16 connectPort = connection->d_func()->port;
338 
339 #ifndef QT_NO_NETWORKPROXY
340         // HTTPS always use transparent proxy.
341         if (connection->d_func()->networkProxy.type() != QNetworkProxy::NoProxy && !ssl) {
342             connectHost = connection->d_func()->networkProxy.hostName();
343             connectPort = connection->d_func()->networkProxy.port();
344         }
345         if (socket->proxy().type() == QNetworkProxy::HttpProxy) {
346             // Make user-agent field available to HTTP proxy socket engine (QTBUG-17223)
347             QByteArray value;
348             // ensureConnection is called before any request has been assigned, but can also be called again if reconnecting
349             if (request.url().isEmpty())
350                 value = connection->d_func()->predictNextRequest().headerField("user-agent");
351             else
352                 value = request.headerField("user-agent");
353             if (!value.isEmpty()) {
354                 QNetworkProxy proxy(socket->proxy());
355                 proxy.setRawHeader("User-Agent", value); //detaches
356                 socket->setProxy(proxy);
357             }
358         }
359 #endif
360         if (ssl) {
361 #ifndef QT_NO_SSL
362             QSslSocket *sslSocket = qobject_cast<QSslSocket*>(socket);
363 
364             // check whether we can re-use an existing SSL session
365             // (meaning another socket in this connection has already
366             // performed a full handshake)
367             if (!connection->sslContext().isNull())
368                 QSslSocketPrivate::checkSettingSslContext(sslSocket, connection->sslContext());
369 
370             sslSocket->connectToHostEncrypted(connectHost, connectPort, QIODevice::ReadWrite, networkLayerPreference);
371             if (ignoreAllSslErrors)
372                 sslSocket->ignoreSslErrors();
373             sslSocket->ignoreSslErrors(ignoreSslErrorsList);
374 
375             // limit the socket read buffer size. we will read everything into
376             // the QHttpNetworkReply anyway, so let's grow only that and not
377             // here and there.
378             socket->setReadBufferSize(64*1024);
379 #else
380             // Need to dequeue the request so that we can emit the error.
381             if (!reply)
382                 connection->d_func()->dequeueRequest(socket);
383             connection->d_func()->emitReplyError(socket, reply, QNetworkReply::ProtocolUnknownError);
384 #endif
385         } else {
386             // In case of no proxy we can use the Unbuffered QTcpSocket
387 #ifndef QT_NO_NETWORKPROXY
388             if (connection->d_func()->networkProxy.type() == QNetworkProxy::NoProxy
389                     && connection->cacheProxy().type() == QNetworkProxy::NoProxy
390                     && connection->transparentProxy().type() == QNetworkProxy::NoProxy) {
391 #endif
392                 socket->connectToHost(connectHost, connectPort, QIODevice::ReadWrite | QIODevice::Unbuffered, networkLayerPreference);
393                 // For an Unbuffered QTcpSocket, the read buffer size has a special meaning.
394                 socket->setReadBufferSize(1*1024);
395 #ifndef QT_NO_NETWORKPROXY
396             } else {
397                 socket->connectToHost(connectHost, connectPort, QIODevice::ReadWrite, networkLayerPreference);
398 
399                 // limit the socket read buffer size. we will read everything into
400                 // the QHttpNetworkReply anyway, so let's grow only that and not
401                 // here and there.
402                 socket->setReadBufferSize(64*1024);
403             }
404 #endif
405         }
406         return false;
407     }
408 
409     // This code path for ConnectedState
410     if (pendingEncrypt) {
411         // Let's only be really connected when we have received the encrypted() signal. Else the state machine seems to mess up
412         // and corrupt the things sent to the server.
413         return false;
414     }
415 
416     return true;
417 }
418 
419 void QHttpNetworkConnectionChannel::allDone()
420 {
421     Q_ASSERT(reply);
422 
423     if (!reply) {
424         qWarning("QHttpNetworkConnectionChannel::allDone() called without reply. Please report at http://bugreports.qt.io/");
425         return;
426     }
427 
428     // while handling 401 & 407, we might reset the status code, so save this.
429     bool emitFinished = reply->d_func()->shouldEmitSignals();
430     bool connectionCloseEnabled = reply->d_func()->isConnectionCloseEnabled();
431     detectPipeliningSupport();
432 
433     handleStatus();
434     // handleStatus() might have removed the reply because it already called connection->emitReplyError()
435 
436     // queue the finished signal, this is required since we might send new requests from
437     // slot connected to it. The socket will not fire readyRead signal, if we are already
438     // in the slot connected to readyRead
439     if (reply && emitFinished)
440         QMetaObject::invokeMethod(reply, "finished", Qt::QueuedConnection);
441 
442 
443     // reset the reconnection attempts after we receive a complete reply.
444     // in case of failures, each channel will attempt two reconnects before emitting error.
445     reconnectAttempts = reconnectAttemptsDefault;
446 
447     // now the channel can be seen as free/idle again, all signal emissions for the reply have been done
448     if (state != QHttpNetworkConnectionChannel::ClosingState)
449         state = QHttpNetworkConnectionChannel::IdleState;
450 
451     // if it does not need to be sent again we can set it to 0
452     // the previous code did not do that and we had problems with accidental re-sending of a
453     // finished request.
454     // Note that this may trigger a segfault at some other point. But then we can fix the underlying
455     // problem.
456     if (!resendCurrent) {
457         request = QHttpNetworkRequest();
458         reply = 0;
459         protocolHandler->setReply(0);
460     }
461 
462     // move next from pipeline to current request
463     if (!alreadyPipelinedRequests.isEmpty()) {
464         if (resendCurrent || connectionCloseEnabled || socket->state() != QAbstractSocket::ConnectedState) {
465             // move the pipelined ones back to the main queue
466             requeueCurrentlyPipelinedRequests();
467             close();
468         } else {
469             // there were requests pipelined in and we can continue
470             HttpMessagePair messagePair = alreadyPipelinedRequests.takeFirst();
471 
472             request = messagePair.first;
473             reply = messagePair.second;
474             protocolHandler->setReply(messagePair.second);
475             state = QHttpNetworkConnectionChannel::ReadingState;
476             resendCurrent = false;
477 
478             written = 0; // message body, excluding the header, irrelevant here
479             bytesTotal = 0; // message body total, excluding the header, irrelevant here
480 
481             // pipeline even more
482             connection->d_func()->fillPipeline(socket);
483 
484             // continue reading
485             //_q_receiveReply();
486             // this was wrong, allDone gets called from that function anyway.
487         }
488     } else if (alreadyPipelinedRequests.isEmpty() && socket->bytesAvailable() > 0) {
489         // this is weird. we had nothing pipelined but still bytes available. better close it.
490         close();
491 
492         QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
493     } else if (alreadyPipelinedRequests.isEmpty()) {
494         if (connectionCloseEnabled)
495             if (socket->state() != QAbstractSocket::UnconnectedState)
496                 close();
497         if (qobject_cast<QHttpNetworkConnection*>(connection))
498             QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
499     }
500 }
501 
502 void QHttpNetworkConnectionChannel::detectPipeliningSupport()
503 {
504     Q_ASSERT(reply);
505     // detect HTTP Pipelining support
506     QByteArray serverHeaderField;
507     if (
508             // check for HTTP/1.1
509             (reply->d_func()->majorVersion == 1 && reply->d_func()->minorVersion == 1)
510             // check for not having connection close
511             && (!reply->d_func()->isConnectionCloseEnabled())
512             // check if it is still connected
513             && (socket->state() == QAbstractSocket::ConnectedState)
514             // check for broken servers in server reply header
515             // this is adapted from http://mxr.mozilla.org/firefox/ident?i=SupportsPipelining
516             && (serverHeaderField = reply->headerField("Server"), !serverHeaderField.contains("Microsoft-IIS/4."))
517             && (!serverHeaderField.contains("Microsoft-IIS/5."))
518             && (!serverHeaderField.contains("Netscape-Enterprise/3."))
519             // this is adpoted from the knowledge of the Nokia 7.x browser team (DEF143319)
520             && (!serverHeaderField.contains("WebLogic"))
521             && (!serverHeaderField.startsWith("Rocket")) // a Python Web Server, see Web2py.com
522             ) {
523         pipeliningSupported = QHttpNetworkConnectionChannel::PipeliningProbablySupported;
524     } else {
525         pipeliningSupported = QHttpNetworkConnectionChannel::PipeliningSupportUnknown;
526     }
527 }
528 
529 // called when the connection broke and we need to queue some pipelined requests again
530 void QHttpNetworkConnectionChannel::requeueCurrentlyPipelinedRequests()
531 {
532     for (int i = 0; i < alreadyPipelinedRequests.length(); i++)
533         connection->d_func()->requeueRequest(alreadyPipelinedRequests.at(i));
534     alreadyPipelinedRequests.clear();
535 
536     // only run when the QHttpNetworkConnection is not currently being destructed, e.g.
537     // this function is called from _q_disconnected which is called because
538     // of ~QHttpNetworkConnectionPrivate
539     if (qobject_cast<QHttpNetworkConnection*>(connection))
540         QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
541 }
542 
543 void QHttpNetworkConnectionChannel::handleStatus()
544 {
545     Q_ASSERT(socket);
546     Q_ASSERT(reply);
547 
548     int statusCode = reply->statusCode();
549     bool resend = false;
550 
551     switch (statusCode) {
552     case 301:
553     case 302:
554     case 303:
555     case 305:
556     case 307: {
557         // Parse the response headers and get the "location" url
558         QUrl redirectUrl = connection->d_func()->parseRedirectResponse(socket, reply);
559         if (redirectUrl.isValid())
560             reply->setRedirectUrl(redirectUrl);
561 
562         if (qobject_cast<QHttpNetworkConnection *>(connection))
563             QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
564         break;
565     }
566     case 401: // auth required
567     case 407: // proxy auth required
568         if (connection->d_func()->handleAuthenticateChallenge(socket, reply, (statusCode == 407), resend)) {
569             if (resend) {
570                 if (!resetUploadData())
571                     break;
572 
573                 reply->d_func()->eraseData();
574 
575                 if (alreadyPipelinedRequests.isEmpty()) {
576                     // this does a re-send without closing the connection
577                     resendCurrent = true;
578                     QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
579                 } else {
580                     // we had requests pipelined.. better close the connection in closeAndResendCurrentRequest
581                     closeAndResendCurrentRequest();
582                     QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
583                 }
584             } else {
585                 //authentication cancelled, close the channel.
586                 close();
587             }
588         } else {
589             emit reply->headerChanged();
590             emit reply->readyRead();
591             QNetworkReply::NetworkError errorCode = (statusCode == 407)
592                 ? QNetworkReply::ProxyAuthenticationRequiredError
593                 : QNetworkReply::AuthenticationRequiredError;
594             reply->d_func()->errorString = connection->d_func()->errorDetail(errorCode, socket);
595             emit reply->finishedWithError(errorCode, reply->d_func()->errorString);
596         }
597         break;
598     default:
599         if (qobject_cast<QHttpNetworkConnection*>(connection))
600             QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
601     }
602 }
603 
604 bool QHttpNetworkConnectionChannel::resetUploadData()
605 {
606     if (!reply) {
607         //this happens if server closes connection while QHttpNetworkConnectionPrivate::_q_startNextRequest is pending
608         return false;
609     }
610     QNonContiguousByteDevice* uploadByteDevice = request.uploadByteDevice();
611     if (!uploadByteDevice)
612         return true;
613 
614     if (uploadByteDevice->reset()) {
615         written = 0;
616         return true;
617     } else {
618         connection->d_func()->emitReplyError(socket, reply, QNetworkReply::ContentReSendError);
619         return false;
620     }
621 }
622 
623 #ifndef QT_NO_NETWORKPROXY
624 
625 void QHttpNetworkConnectionChannel::setProxy(const QNetworkProxy &networkProxy)
626 {
627     if (socket)
628         socket->setProxy(networkProxy);
629 
630     proxy = networkProxy;
631 }
632 
633 #endif
634 
635 #ifndef QT_NO_SSL
636 
637 void QHttpNetworkConnectionChannel::ignoreSslErrors()
638 {
639     if (socket)
640         static_cast<QSslSocket *>(socket)->ignoreSslErrors();
641 
642     ignoreAllSslErrors = true;
643 }
644 
645 
646 void QHttpNetworkConnectionChannel::ignoreSslErrors(const QList<QSslError> &errors)
647 {
648     if (socket)
649         static_cast<QSslSocket *>(socket)->ignoreSslErrors(errors);
650 
651     ignoreSslErrorsList = errors;
652 }
653 
654 void QHttpNetworkConnectionChannel::setSslConfiguration(const QSslConfiguration &config)
655 {
656     if (socket)
657         static_cast<QSslSocket *>(socket)->setSslConfiguration(config);
658 
659     sslConfiguration = config;
660 }
661 
662 #endif
663 
664 void QHttpNetworkConnectionChannel::pipelineInto(HttpMessagePair &pair)
665 {
666     // this is only called for simple GET
667 
668     QHttpNetworkRequest &request = pair.first;
669     QHttpNetworkReply *reply = pair.second;
670     reply->d_func()->clear();
671     reply->d_func()->connection = connection;
672     reply->d_func()->connectionChannel = this;
673     reply->d_func()->autoDecompress = request.d->autoDecompress;
674     reply->d_func()->pipeliningUsed = true;
675 
676 #ifndef QT_NO_NETWORKPROXY
677     pipeline.append(QHttpNetworkRequestPrivate::header(request,
678                                                            (connection->d_func()->networkProxy.type() != QNetworkProxy::NoProxy)));
679 #else
680     pipeline.append(QHttpNetworkRequestPrivate::header(request, false));
681 #endif
682 
683     alreadyPipelinedRequests.append(pair);
684 
685     // pipelineFlush() needs to be called at some point afterwards
686 }
687 
688 void QHttpNetworkConnectionChannel::pipelineFlush()
689 {
690     if (pipeline.isEmpty())
691         return;
692 
693     // The goal of this is so that we have everything in one TCP packet.
694     // For the Unbuffered QTcpSocket this is manually needed, the buffered
695     // QTcpSocket does it automatically.
696     // Also, sometimes the OS does it for us (Nagle's algorithm) but that
697     // happens only sometimes.
698     socket->write(pipeline);
699     pipeline.clear();
700 }
701 
702 
703 void QHttpNetworkConnectionChannel::closeAndResendCurrentRequest()
704 {
705     requeueCurrentlyPipelinedRequests();
706     close();
707     if (reply)
708         resendCurrent = true;
709     if (qobject_cast<QHttpNetworkConnection*>(connection))
710         QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
711 }
712 
713 void QHttpNetworkConnectionChannel::resendCurrentRequest()
714 {
715     requeueCurrentlyPipelinedRequests();
716     if (reply)
717         resendCurrent = true;
718     if (qobject_cast<QHttpNetworkConnection*>(connection))
719         QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
720 }
721 
722 bool QHttpNetworkConnectionChannel::isSocketBusy() const
723 {
724     return (state & QHttpNetworkConnectionChannel::BusyState);
725 }
726 
727 bool QHttpNetworkConnectionChannel::isSocketWriting() const
728 {
729     return (state & QHttpNetworkConnectionChannel::WritingState);
730 }
731 
732 bool QHttpNetworkConnectionChannel::isSocketWaiting() const
733 {
734     return (state & QHttpNetworkConnectionChannel::WaitingState);
735 }
736 
737 bool QHttpNetworkConnectionChannel::isSocketReading() const
738 {
739     return (state & QHttpNetworkConnectionChannel::ReadingState);
740 }
741 
742 void QHttpNetworkConnectionChannel::_q_bytesWritten(qint64 bytes)
743 {
744     Q_UNUSED(bytes);
745     if (ssl) {
746         // In the SSL case we want to send data from encryptedBytesWritten signal since that one
747         // is the one going down to the actual network, not only into some SSL buffer.
748         return;
749     }
750 
751     // bytes have been written to the socket. write even more of them :)
752     if (isSocketWriting())
753         sendRequest();
754     // otherwise we do nothing
755 }
756 
757 void QHttpNetworkConnectionChannel::_q_disconnected()
758 {
759     if (state == QHttpNetworkConnectionChannel::ClosingState) {
760         state = QHttpNetworkConnectionChannel::IdleState;
761         QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
762         return;
763     }
764 
765     // read the available data before closing (also done in _q_error for other codepaths)
766     if ((isSocketWaiting() || isSocketReading()) && socket->bytesAvailable()) {
767         if (reply) {
768             state = QHttpNetworkConnectionChannel::ReadingState;
769             _q_receiveReply();
770         }
771     } else if (state == QHttpNetworkConnectionChannel::IdleState && resendCurrent) {
772         // re-sending request because the socket was in ClosingState
773         QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
774     }
775     state = QHttpNetworkConnectionChannel::IdleState;
776 
777     requeueCurrentlyPipelinedRequests();
778 
779     pendingEncrypt = false;
780 }
781 
782 
783 void QHttpNetworkConnectionChannel::_q_connected()
784 {
785     // For the Happy Eyeballs we need to check if this is the first channel to connect.
786     if (connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::HostLookupPending || connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv4or6) {
787         if (connection->d_func()->delayedConnectionTimer.isActive())
788             connection->d_func()->delayedConnectionTimer.stop();
789         if (networkLayerPreference == QAbstractSocket::IPv4Protocol)
790             connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv4;
791         else if (networkLayerPreference == QAbstractSocket::IPv6Protocol)
792             connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv6;
793         else {
794             if (socket->peerAddress().protocol() == QAbstractSocket::IPv4Protocol)
795                 connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv4;
796             else
797                 connection->d_func()->networkLayerState = QHttpNetworkConnectionPrivate::IPv6;
798         }
799         connection->d_func()->networkLayerDetected(networkLayerPreference);
800     } else {
801         if (((connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv4) && (networkLayerPreference != QAbstractSocket::IPv4Protocol))
802             || ((connection->d_func()->networkLayerState == QHttpNetworkConnectionPrivate::IPv6) && (networkLayerPreference != QAbstractSocket::IPv6Protocol))) {
803             close();
804             // This is the second connection so it has to be closed and we can schedule it for another request.
805             QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
806             return;
807         }
808         //The connections networkLayerState had already been decided.
809     }
810 
811     // improve performance since we get the request sent by the kernel ASAP
812     //socket->setSocketOption(QAbstractSocket::LowDelayOption, 1);
813     // We have this commented out now. It did not have the effect we wanted. If we want to
814     // do this properly, Qt has to combine multiple HTTP requests into one buffer
815     // and send this to the kernel in one syscall and then the kernel immediately sends
816     // it as one TCP packet because of TCP_NODELAY.
817     // However, this code is currently not in Qt, so we rely on the kernel combining
818     // the requests into one TCP packet.
819 
820     // not sure yet if it helps, but it makes sense
821     socket->setSocketOption(QAbstractSocket::KeepAliveOption, 1);
822 
823     pipeliningSupported = QHttpNetworkConnectionChannel::PipeliningSupportUnknown;
824 
825     // ### FIXME: if the server closes the connection unexpectedly, we shouldn't send the same broken request again!
826     //channels[i].reconnectAttempts = 2;
827     if (ssl || pendingEncrypt) { // FIXME: Didn't work properly with pendingEncrypt only, we should refactor this into an EncrypingState
828 #ifndef QT_NO_SSL
829         if (connection->sslContext().isNull()) {
830             // this socket is making the 1st handshake for this connection,
831             // we need to set the SSL context so new sockets can reuse it
832             QSharedPointer<QSslContext> socketSslContext = QSslSocketPrivate::sslContext(static_cast<QSslSocket*>(socket));
833             if (!socketSslContext.isNull())
834                 connection->setSslContext(socketSslContext);
835         }
836 #endif
837     } else {
838         state = QHttpNetworkConnectionChannel::IdleState;
839         if (connection->connectionType() == QHttpNetworkConnection::ConnectionTypeHTTP2) {
840             if (spdyRequestsToSend.count() > 0) {
841                 // wait for data from the server first (e.g. initial window, max concurrent requests)
842                 QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
843             }
844         } else {
845             if (!reply)
846                 connection->d_func()->dequeueRequest(socket);
847             if (reply)
848                 sendRequest();
849         }
850     }
851 }
852 
853 
854 void QHttpNetworkConnectionChannel::_q_error(QAbstractSocket::SocketError socketError)
855 {
856     if (!socket)
857         return;
858     QNetworkReply::NetworkError errorCode = QNetworkReply::UnknownNetworkError;
859 
860     switch (socketError) {
861     case QAbstractSocket::HostNotFoundError:
862         errorCode = QNetworkReply::HostNotFoundError;
863         break;
864     case QAbstractSocket::ConnectionRefusedError:
865         errorCode = QNetworkReply::ConnectionRefusedError;
866         break;
867     case QAbstractSocket::RemoteHostClosedError:
868         // This error for SSL comes twice in a row, first from SSL layer ("The TLS/SSL connection has been closed") then from TCP layer.
869         // Depending on timing it can also come three times in a row (first time when we try to write into a closing QSslSocket).
870         // The reconnectAttempts handling catches the cases where we can re-send the request.
871         if (!reply && state == QHttpNetworkConnectionChannel::IdleState) {
872             // Not actually an error, it is normal for Keep-Alive connections to close after some time if no request
873             // is sent on them. No need to error the other replies below. Just bail out here.
874             // The _q_disconnected will handle the possibly pipelined replies
875             return;
876         } else if (state != QHttpNetworkConnectionChannel::IdleState && state != QHttpNetworkConnectionChannel::ReadingState) {
877             // Try to reconnect/resend before sending an error.
878             // While "Reading" the _q_disconnected() will handle this.
879             if (reconnectAttempts-- > 0) {
880                 resendCurrentRequest();
881                 return;
882             } else {
883                 errorCode = QNetworkReply::RemoteHostClosedError;
884             }
885         } else if (state == QHttpNetworkConnectionChannel::ReadingState) {
886             if (!reply)
887                 break;
888 
889             if (!reply->d_func()->expectContent()) {
890                 // No content expected, this is a valid way to have the connection closed by the server
891                 // We need to invoke this asynchronously to make sure the state() of the socket is on QAbstractSocket::UnconnectedState
892                 QMetaObject::invokeMethod(this, "_q_receiveReply", Qt::QueuedConnection);
893                 return;
894             }
895             if (reply->contentLength() == -1 && !reply->d_func()->isChunked()) {
896                 // There was no content-length header and it's not chunked encoding,
897                 // so this is a valid way to have the connection closed by the server
898                 // We need to invoke this asynchronously to make sure the state() of the socket is on QAbstractSocket::UnconnectedState
899                 QMetaObject::invokeMethod(this, "_q_receiveReply", Qt::QueuedConnection);
900                 return;
901             }
902             // ok, we got a disconnect even though we did not expect it
903             // Try to read everything from the socket before we emit the error.
904             if (socket->bytesAvailable()) {
905                 // Read everything from the socket into the reply buffer.
906                 // we can ignore the readbuffersize as the data is already
907                 // in memory and we will not receive more data on the socket.
908                 reply->setReadBufferSize(0);
909                 reply->setDownstreamLimited(false);
910                 _q_receiveReply();
911                 if (!reply) {
912                     // No more reply assigned after the previous call? Then it had been finished successfully.
913                     requeueCurrentlyPipelinedRequests();
914                     state = QHttpNetworkConnectionChannel::IdleState;
915                     QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
916                     return;
917                 }
918             }
919 
920             errorCode = QNetworkReply::RemoteHostClosedError;
921         } else {
922             errorCode = QNetworkReply::RemoteHostClosedError;
923         }
924         break;
925     case QAbstractSocket::SocketTimeoutError:
926         // try to reconnect/resend before sending an error.
927         if (state == QHttpNetworkConnectionChannel::WritingState && (reconnectAttempts-- > 0)) {
928             resendCurrentRequest();
929             return;
930         }
931         errorCode = QNetworkReply::TimeoutError;
932         break;
933     case QAbstractSocket::ProxyAuthenticationRequiredError:
934         errorCode = QNetworkReply::ProxyAuthenticationRequiredError;
935         break;
936     case QAbstractSocket::SslHandshakeFailedError:
937         errorCode = QNetworkReply::SslHandshakeFailedError;
938         break;
939     case QAbstractSocket::ProxyConnectionClosedError:
940         // try to reconnect/resend before sending an error.
941         if (reconnectAttempts-- > 0) {
942             resendCurrentRequest();
943             return;
944         }
945         errorCode = QNetworkReply::ProxyConnectionClosedError;
946         break;
947     case QAbstractSocket::ProxyConnectionTimeoutError:
948         // try to reconnect/resend before sending an error.
949         if (reconnectAttempts-- > 0) {
950             resendCurrentRequest();
951             return;
952         }
953         errorCode = QNetworkReply::ProxyTimeoutError;
954         break;
955     default:
956         // all other errors are treated as NetworkError
957         errorCode = QNetworkReply::UnknownNetworkError;
958         break;
959     }
960     QPointer<QHttpNetworkConnection> that = connection;
961     QString errorString = connection->d_func()->errorDetail(errorCode, socket, socket->errorString());
962 
963     // In the HostLookupPending state the channel should not emit the error.
964     // This will instead be handled by the connection.
965     if (!connection->d_func()->shouldEmitChannelError(socket))
966         return;
967 
968     // emit error for all waiting replies
969     do {
970         // Need to dequeu the request so that we can emit the error.
971         if (!reply)
972             connection->d_func()->dequeueRequest(socket);
973 
974         if (reply) {
975             reply->d_func()->errorString = errorString;
976             emit reply->finishedWithError(errorCode, errorString);
977             reply = 0;
978             if (protocolHandler)
979                 protocolHandler->setReply(0);
980         }
981     } while (!connection->d_func()->highPriorityQueue.isEmpty()
982              || !connection->d_func()->lowPriorityQueue.isEmpty());
983 
984     if (connection->connectionType() == QHttpNetworkConnection::ConnectionTypeHTTP2
985 #ifndef QT_NO_SSL
986         || connection->connectionType() == QHttpNetworkConnection::ConnectionTypeSPDY
987 #endif
988        ) {
989         QList<HttpMessagePair> spdyPairs = spdyRequestsToSend.values();
990         for (int a = 0; a < spdyPairs.count(); ++a) {
991             // emit error for all replies
992             QHttpNetworkReply *currentReply = spdyPairs.at(a).second;
993             Q_ASSERT(currentReply);
994             emit currentReply->finishedWithError(errorCode, errorString);
995         }
996     }
997 
998     // send the next request
999     QMetaObject::invokeMethod(that, "_q_startNextRequest", Qt::QueuedConnection);
1000 
1001     if (that) {
1002         //signal emission triggered event loop
1003         if (!socket)
1004             state = QHttpNetworkConnectionChannel::IdleState;
1005         else if (socket->state() == QAbstractSocket::UnconnectedState)
1006             state = QHttpNetworkConnectionChannel::IdleState;
1007         else
1008             state = QHttpNetworkConnectionChannel::ClosingState;
1009 
1010         // pendingEncrypt must only be true in between connected and encrypted states
1011         pendingEncrypt = false;
1012     }
1013 }
1014 
1015 #ifndef QT_NO_NETWORKPROXY
1016 void QHttpNetworkConnectionChannel::_q_proxyAuthenticationRequired(const QNetworkProxy &proxy, QAuthenticator* auth)
1017 {
1018     if (connection->connectionType() == QHttpNetworkConnection::ConnectionTypeHTTP2
1019 #ifndef QT_NO_SSL
1020         || connection->connectionType() == QHttpNetworkConnection::ConnectionTypeSPDY
1021 #endif
1022         ) {
1023         connection->d_func()->emitProxyAuthenticationRequired(this, proxy, auth);
1024     } else { // HTTP
1025         // Need to dequeue the request before we can emit the error.
1026         if (!reply)
1027             connection->d_func()->dequeueRequest(socket);
1028         if (reply)
1029             connection->d_func()->emitProxyAuthenticationRequired(this, proxy, auth);
1030     }
1031 }
1032 #endif
1033 
1034 void QHttpNetworkConnectionChannel::_q_uploadDataReadyRead()
1035 {
1036     if (reply)
1037         sendRequest();
1038 }
1039 
1040 void QHttpNetworkConnectionChannel::emitFinishedWithError(QNetworkReply::NetworkError error,
1041                                                           const char *message)
1042 {
1043     if (reply)
1044         emit reply->finishedWithError(error, QHttpNetworkConnectionChannel::tr(message));
1045     QList<HttpMessagePair> spdyPairs = spdyRequestsToSend.values();
1046     for (int a = 0; a < spdyPairs.count(); ++a) {
1047         QHttpNetworkReply *currentReply = spdyPairs.at(a).second;
1048         Q_ASSERT(currentReply);
1049         emit currentReply->finishedWithError(error, QHttpNetworkConnectionChannel::tr(message));
1050     }
1051 }
1052 
1053 #ifndef QT_NO_SSL
1054 void QHttpNetworkConnectionChannel::_q_encrypted()
1055 {
1056     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket);
1057     Q_ASSERT(sslSocket);
1058 
1059     if (!protocolHandler) {
1060         switch (sslSocket->sslConfiguration().nextProtocolNegotiationStatus()) {
1061         case QSslConfiguration::NextProtocolNegotiationNegotiated:
1062         case QSslConfiguration::NextProtocolNegotiationUnsupported: {
1063             QByteArray nextProtocol = sslSocket->sslConfiguration().nextNegotiatedProtocol();
1064             if (nextProtocol == QSslConfiguration::NextProtocolHttp1_1) {
1065                 // fall through to create a QHttpProtocolHandler
1066             } else if (nextProtocol == QSslConfiguration::NextProtocolSpdy3_0) {
1067                 protocolHandler.reset(new QSpdyProtocolHandler(this));
1068                 connection->setConnectionType(QHttpNetworkConnection::ConnectionTypeSPDY);
1069                 // no need to re-queue requests, if SPDY was enabled on the request it
1070                 // has gone to the SPDY queue already
1071                 break;
1072             } else if (nextProtocol == QSslConfiguration::ALPNProtocolHTTP2) {
1073                 protocolHandler.reset(new QHttp2ProtocolHandler(this));
1074                 connection->setConnectionType(QHttpNetworkConnection::ConnectionTypeHTTP2);
1075                 break;
1076             } else {
1077                 emitFinishedWithError(QNetworkReply::SslHandshakeFailedError,
1078                                       "detected unknown Next Protocol Negotiation protocol");
1079                 break;
1080             }
1081             Q_FALLTHROUGH();
1082         }
1083         case QSslConfiguration::NextProtocolNegotiationNone:
1084             protocolHandler.reset(new QHttpProtocolHandler(this));
1085             connection->setConnectionType(QHttpNetworkConnection::ConnectionTypeHTTP);
1086             // re-queue requests from SPDY queue to HTTP queue, if any
1087             requeueSpdyRequests();
1088             break;
1089         default:
1090             emitFinishedWithError(QNetworkReply::SslHandshakeFailedError,
1091                                   "detected unknown Next Protocol Negotiation protocol");
1092         }
1093     }
1094 
1095     if (!socket)
1096         return; // ### error
1097     state = QHttpNetworkConnectionChannel::IdleState;
1098     pendingEncrypt = false;
1099 
1100     if (connection->connectionType() == QHttpNetworkConnection::ConnectionTypeSPDY ||
1101         connection->connectionType() == QHttpNetworkConnection::ConnectionTypeHTTP2) {
1102         // we call setSpdyWasUsed(true) on the replies in the SPDY handler when the request is sent
1103         if (spdyRequestsToSend.count() > 0) {
1104             // wait for data from the server first (e.g. initial window, max concurrent requests)
1105             QMetaObject::invokeMethod(connection, "_q_startNextRequest", Qt::QueuedConnection);
1106         }
1107     } else { // HTTP
1108         if (!reply)
1109             connection->d_func()->dequeueRequest(socket);
1110         if (reply) {
1111             reply->setSpdyWasUsed(false);
1112             Q_ASSERT(reply->d_func()->connectionChannel == this);
1113             emit reply->encrypted();
1114         }
1115         if (reply)
1116             sendRequest();
1117     }
1118 }
1119 
1120 void QHttpNetworkConnectionChannel::requeueSpdyRequests()
1121 {
1122     QList<HttpMessagePair> spdyPairs = spdyRequestsToSend.values();
1123     for (int a = 0; a < spdyPairs.count(); ++a) {
1124         connection->d_func()->requeueRequest(spdyPairs.at(a));
1125     }
1126     spdyRequestsToSend.clear();
1127 }
1128 
1129 void QHttpNetworkConnectionChannel::_q_sslErrors(const QList<QSslError> &errors)
1130 {
1131     if (!socket)
1132         return;
1133     //QNetworkReply::NetworkError errorCode = QNetworkReply::ProtocolFailure;
1134     // Also pause the connection because socket notifiers may fire while an user
1135     // dialog is displaying
1136     connection->d_func()->pauseConnection();
1137     if (pendingEncrypt && !reply)
1138         connection->d_func()->dequeueRequest(socket);
1139     if (connection->connectionType() == QHttpNetworkConnection::ConnectionTypeHTTP) {
1140         if (reply)
1141             emit reply->sslErrors(errors);
1142     }
1143 #ifndef QT_NO_SSL
1144     else { // SPDY
1145         QList<HttpMessagePair> spdyPairs = spdyRequestsToSend.values();
1146         for (int a = 0; a < spdyPairs.count(); ++a) {
1147             // emit SSL errors for all replies
1148             QHttpNetworkReply *currentReply = spdyPairs.at(a).second;
1149             Q_ASSERT(currentReply);
1150             emit currentReply->sslErrors(errors);
1151         }
1152     }
1153 #endif // QT_NO_SSL
1154     connection->d_func()->resumeConnection();
1155 }
1156 
1157 void QHttpNetworkConnectionChannel::_q_preSharedKeyAuthenticationRequired(QSslPreSharedKeyAuthenticator *authenticator)
1158 {
1159     connection->d_func()->pauseConnection();
1160 
1161     if (pendingEncrypt && !reply)
1162         connection->d_func()->dequeueRequest(socket);
1163 
1164     if (connection->connectionType() == QHttpNetworkConnection::ConnectionTypeHTTP) {
1165         if (reply)
1166             emit reply->preSharedKeyAuthenticationRequired(authenticator);
1167     } else {
1168         QList<HttpMessagePair> spdyPairs = spdyRequestsToSend.values();
1169         for (int a = 0; a < spdyPairs.count(); ++a) {
1170             // emit SSL errors for all replies
1171             QHttpNetworkReply *currentReply = spdyPairs.at(a).second;
1172             Q_ASSERT(currentReply);
1173             emit currentReply->preSharedKeyAuthenticationRequired(authenticator);
1174         }
1175     }
1176 
1177     connection->d_func()->resumeConnection();
1178 }
1179 
1180 void QHttpNetworkConnectionChannel::_q_encryptedBytesWritten(qint64 bytes)
1181 {
1182     Q_UNUSED(bytes);
1183     // bytes have been written to the socket. write even more of them :)
1184     if (isSocketWriting())
1185         sendRequest();
1186     // otherwise we do nothing
1187 }
1188 
1189 #endif
1190 
1191 void QHttpNetworkConnectionChannel::setConnection(QHttpNetworkConnection *c)
1192 {
1193     // Inlining this function in the header leads to compiler error on
1194     // release-armv5, on at least timebox 9.2 and 10.1.
1195     connection = c;
1196 }
1197 
1198 QT_END_NAMESPACE
1199 
1200 #include "moc_qhttpnetworkconnectionchannel_p.cpp"
1201 
1202 #endif // QT_NO_HTTP
