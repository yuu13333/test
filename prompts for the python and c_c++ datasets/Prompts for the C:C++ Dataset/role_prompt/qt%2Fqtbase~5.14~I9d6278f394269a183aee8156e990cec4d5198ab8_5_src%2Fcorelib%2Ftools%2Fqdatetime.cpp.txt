I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Copyright (C) 2016 Intel Corporation.
5 ** Contact: https://www.qt.io/licensing/
6 **
7 ** This file is part of the QtCore module of the Qt Toolkit.
8 **
9 ** $QT_BEGIN_LICENSE:LGPL$
10 ** Commercial License Usage
11 ** Licensees holding valid commercial Qt licenses may use this file in
12 ** accordance with the commercial license agreement provided with the
13 ** Software or, alternatively, in accordance with the terms contained in
14 ** a written agreement between you and The Qt Company. For licensing terms
15 ** and conditions see https://www.qt.io/terms-conditions. For further
16 ** information use the contact form at https://www.qt.io/contact-us.
17 **
18 ** GNU Lesser General Public License Usage
19 ** Alternatively, this file may be used under the terms of the GNU Lesser
20 ** General Public License version 3 as published by the Free Software
21 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
22 ** packaging of this file. Please review the following information to
23 ** ensure the GNU Lesser General Public License version 3 requirements
24 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
25 **
26 ** GNU General Public License Usage
27 ** Alternatively, this file may be used under the terms of the GNU
28 ** General Public License version 2.0 or (at your option) the GNU General
29 ** Public license version 3 or any later version approved by the KDE Free
30 ** Qt Foundation. The licenses are as published by the Free Software
31 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
32 ** included in the packaging of this file. Please review the following
33 ** information to ensure the GNU General Public License requirements will
34 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
35 ** https://www.gnu.org/licenses/gpl-3.0.html.
36 **
37 ** $QT_END_LICENSE$
38 **
39 ****************************************************************************/
40 
41 #include "qplatformdefs.h"
42 #include "private/qdatetime_p.h"
43 #include "private/qdatetimeparser_p.h"
44 
45 #include "qdatastream.h"
46 #include "qset.h"
47 #include "qlocale.h"
48 #include "qdatetime.h"
49 #if QT_CONFIG(timezone)
50 #include "qtimezoneprivate_p.h"
51 #endif
52 #include "qregexp.h"
53 #include "qdebug.h"
54 #ifndef Q_OS_WIN
55 #include <locale.h>
56 #endif
57 
58 #include <cmath>
59 #include <time.h>
60 #ifdef Q_OS_WIN
61 #  include <qt_windows.h>
62 #  ifdef Q_OS_WINRT
63 #    include "qfunctions_winrt.h"
64 #  endif
65 #endif
66 
67 #if defined(Q_OS_MAC)
68 #include <private/qcore_mac_p.h>
69 #endif
70 
71 QT_BEGIN_NAMESPACE
72 
73 /*****************************************************************************
74   Date/Time Constants
75  *****************************************************************************/
76 
77 enum {
78     SECS_PER_DAY = 86400,
79     MSECS_PER_DAY = 86400000,
80     SECS_PER_HOUR = 3600,
81     MSECS_PER_HOUR = 3600000,
82     SECS_PER_MIN = 60,
83     MSECS_PER_MIN = 60000,
84     TIME_T_MAX = 2145916799,  // int maximum 2037-12-31T23:59:59 UTC
85     JULIAN_DAY_FOR_EPOCH = 2440588 // result of julianDayFromDate(1970, 1, 1)
86 };
87 
88 /*****************************************************************************
89   QDate static helper functions
90  *****************************************************************************/
91 
92 static inline QDate fixedDate(int y, int m, int d)
93 {
94     QDate result(y, m, 1);
95     result.setDate(y, m, qMin(d, result.daysInMonth()));
96     return result;
97 }
98 
99 /*
100   Division, rounding down (rather than towards zero).
101 
102   From C++11 onwards, integer division is defined to round towards zero, so we
103   can rely on that when implementing this.  This is only used with denominator b
104   > 0, so we only have to treat negative numerator, a, specially.
105  */
106 static inline qint64 floordiv(qint64 a, int b)
107 {
108     return (a - (a < 0 ? b - 1 : 0)) / b;
109 }
110 
111 static inline int floordiv(int a, int b)
112 {
113     return (a - (a < 0 ? b - 1 : 0)) / b;
114 }
115 
116 static inline qint64 julianDayFromDate(int year, int month, int day)
117 {
118     // Adjust for no year 0
119     if (year < 0)
120         ++year;
121 
122 /*
123  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php
124  * This formula is correct for all julian days, when using mathematical integer
125  * division (round to negative infinity), not c++11 integer division (round to zero)
126  */
127     int    a = floordiv(14 - month, 12);
128     qint64 y = (qint64)year + 4800 - a;
129     int    m = month + 12 * a - 3;
130     return day + floordiv(153 * m + 2, 5) + 365 * y + floordiv(y, 4) - floordiv(y, 100) + floordiv(y, 400) - 32045;
131 }
132 
133 struct ParsedDate
134 {
135     int year, month, day;
136 };
137 
138 // prevent this function from being inlined into all 10 users
139 Q_NEVER_INLINE
140 static ParsedDate getDateFromJulianDay(qint64 julianDay)
141 {
142 /*
143  * Math from The Calendar FAQ at http://www.tondering.dk/claus/cal/julperiod.php
144  * This formula is correct for all julian days, when using mathematical integer
145  * division (round to negative infinity), not c++11 integer division (round to zero)
146  */
147     qint64 a = julianDay + 32044;
148     qint64 b = floordiv(4 * a + 3, 146097);
149     int    c = a - floordiv(146097 * b, 4);
150 
151     int    d = floordiv(4 * c + 3, 1461);
152     int    e = c - floordiv(1461 * d, 4);
153     int    m = floordiv(5 * e + 2, 153);
154 
155     int    day = e - floordiv(153 * m + 2, 5) + 1;
156     int    month = m + 3 - 12 * floordiv(m, 10);
157     int    year = 100 * b + d - 4800 + floordiv(m, 10);
158 
159     // Adjust for no year 0
160     if (year <= 0)
161         --year ;
162 
163     const ParsedDate result = { year, month, day };
164     return result;
165 }
166 
167 /*****************************************************************************
168   Date/Time formatting helper functions
169  *****************************************************************************/
170 
171 static const char monthDays[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
172 
173 #ifndef QT_NO_TEXTDATE
174 static const char qt_shortMonthNames[][4] = {
175     "Jan", "Feb", "Mar", "Apr", "May", "Jun",
176     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };
177 
178 static int qt_monthNumberFromShortName(QStringRef shortName)
179 {
180     for (unsigned int i = 0; i < sizeof(qt_shortMonthNames) / sizeof(qt_shortMonthNames[0]); ++i) {
181         if (shortName == QLatin1String(qt_shortMonthNames[i], 3))
182             return i + 1;
183     }
184     return -1;
185 }
186 static int qt_monthNumberFromShortName(const QString &shortName)
187 { return qt_monthNumberFromShortName(QStringRef(&shortName)); }
188 
189 static int fromShortMonthName(const QStringRef &monthName)
190 {
191     // Assume that English monthnames are the default
192     int month = qt_monthNumberFromShortName(monthName);
193     if (month != -1)
194         return month;
195     // If English names can't be found, search the localized ones
196     for (int i = 1; i <= 12; ++i) {
197         if (monthName == QDate::shortMonthName(i))
198             return i;
199     }
200     return -1;
201 }
202 #endif // QT_NO_TEXTDATE
203 
204 #ifndef QT_NO_DATESTRING
205 struct ParsedRfcDateTime {
206     QDate date;
207     QTime time;
208     int utcOffset;
209 };
210 
211 static ParsedRfcDateTime rfcDateImpl(const QString &s)
212 {
213     ParsedRfcDateTime result;
214 
215     // Matches "Wdy, DD Mon YYYY HH:mm:ss Â±hhmm" (Wdy, being optional)
216     QRegExp rex(QStringLiteral("^(?:[A-Z][a-z]+,)?[ \\t]*(\\d{1,2})[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d)(?::(\\d\\d))?)?[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"));
217     if (s.indexOf(rex) == 0) {
218         const QStringList cap = rex.capturedTexts();
219         result.date = QDate(cap[3].toInt(), qt_monthNumberFromShortName(cap[2]), cap[1].toInt());
220         if (!cap[4].isEmpty())
221             result.time = QTime(cap[4].toInt(), cap[5].toInt(), cap[6].toInt());
222         const bool positiveOffset = (cap[7] == QLatin1String("+"));
223         const int hourOffset = cap[8].toInt();
224         const int minOffset = cap[9].toInt();
225         result.utcOffset = ((hourOffset * 60 + minOffset) * (positiveOffset ? 60 : -60));
226     } else {
227         // Matches "Wdy Mon DD HH:mm:ss YYYY"
228         QRegExp rex(QStringLiteral("^[A-Z][a-z]+[ \\t]+([A-Z][a-z]+)[ \\t]+(\\d\\d)(?:[ \\t]+(\\d\\d):(\\d\\d):(\\d\\d))?[ \\t]+(\\d\\d\\d\\d)[ \\t]*(?:([+-])(\\d\\d)(\\d\\d))?"));
229         if (s.indexOf(rex) == 0) {
230             const QStringList cap = rex.capturedTexts();
231             result.date = QDate(cap[6].toInt(), qt_monthNumberFromShortName(cap[1]), cap[2].toInt());
232             if (!cap[3].isEmpty())
233                 result.time = QTime(cap[3].toInt(), cap[4].toInt(), cap[5].toInt());
234             const bool positiveOffset = (cap[7] == QLatin1String("+"));
235             const int hourOffset = cap[8].toInt();
236             const int minOffset = cap[9].toInt();
237             result.utcOffset = ((hourOffset * 60 + minOffset) * (positiveOffset ? 60 : -60));
238         }
239     }
240 
241     return result;
242 }
243 #endif // QT_NO_DATESTRING
244 
245 // Return offset in [+-]HH:mm format
246 static QString toOffsetString(Qt::DateFormat format, int offset)
247 {
248     return QString::asprintf("%c%02d%s%02d",
249                              offset >= 0 ? '+' : '-',
250                              qAbs(offset) / SECS_PER_HOUR,
251                              // Qt::ISODate puts : between the hours and minutes, but Qt:TextDate does not:
252                              format == Qt::TextDate ? "" : ":",
253                              (qAbs(offset) / 60) % 60);
254 }
255 
256 // Parse offset in [+-]HH[[:]mm] format
257 static int fromOffsetString(const QStringRef &offsetString, bool *valid) Q_DECL_NOTHROW
258 {
259     *valid = false;
260 
261     const int size = offsetString.size();
262     if (size < 2 || size > 6)
263         return 0;
264 
265     // sign will be +1 for a positive and -1 for a negative offset
266     int sign;
267 
268     // First char must be + or -
269     const QChar signChar = offsetString.at(0);
270     if (signChar == QLatin1Char('+'))
271         sign = 1;
272     else if (signChar == QLatin1Char('-'))
273         sign = -1;
274     else
275         return 0;
276 
277     // Split the hour and minute parts
278     const QStringRef time = offsetString.mid(1);
279     int hhLen = time.indexOf(QLatin1Char(':'));
280     int mmIndex;
281     if (hhLen == -1)
282         mmIndex = hhLen = 2; // [+-]HHmm or [+-]HH format
283     else
284         mmIndex = hhLen + 1;
285 
286     const QStringRef hhRef = time.left(hhLen);
287     bool ok = false;
288     const int hour = hhRef.toInt(&ok);
289     if (!ok)
290         return 0;
291 
292     const QStringRef mmRef = time.mid(mmIndex);
293     const int minute = mmRef.isEmpty() ? 0 : mmRef.toInt(&ok);
294     if (!ok || minute < 0 || minute > 59)
295         return 0;
296 
297     *valid = true;
298     return sign * ((hour * 60) + minute) * 60;
299 }
300 
301 /*****************************************************************************
302   QDate member functions
303  *****************************************************************************/
304 
305 /*!
306     \since 4.5
307 
308     \enum QDate::MonthNameType
309 
310     This enum describes the types of the string representation used
311     for the month name.
312 
313     \value DateFormat This type of name can be used for date-to-string formatting.
314     \value StandaloneFormat This type is used when you need to enumerate months or weekdays.
315            Usually standalone names are represented in singular forms with
316            capitalized first letter.
317 */
318 
319 /*!
320     \class QDate
321     \inmodule QtCore
322     \reentrant
323     \brief The QDate class provides date functions.
324 
325 
326     A QDate object contains a calendar date, i.e. year, month, and day
327     numbers, in the Gregorian calendar. It can read the current date
328     from the system clock. It provides functions for comparing dates,
329     and for manipulating dates. For example, it is possible to add
330     and subtract days, months, and years to dates.
331 
332     A QDate object is typically created by giving the year,
333     month, and day numbers explicitly. Note that QDate interprets two
334     digit years as is, i.e., years 0 - 99. A QDate can also be
335     constructed with the static function currentDate(), which creates
336     a QDate object containing the system clock's date.  An explicit
337     date can also be set using setDate(). The fromString() function
338     returns a QDate given a string and a date format which is used to
339     interpret the date within the string.
340 
341     The year(), month(), and day() functions provide access to the
342     year, month, and day numbers. Also, dayOfWeek() and dayOfYear()
343     functions are provided. The same information is provided in
344     textual format by the toString(), shortDayName(), longDayName(),
345     shortMonthName(), and longMonthName() functions.
346 
347     QDate provides a full set of operators to compare two QDate
348     objects where smaller means earlier, and larger means later.
349 
350     You can increment (or decrement) a date by a given number of days
351     using addDays(). Similarly you can use addMonths() and addYears().
352     The daysTo() function returns the number of days between two
353     dates.
354 
355     The daysInMonth() and daysInYear() functions return how many days
356     there are in this date's month and year, respectively. The
357     isLeapYear() function indicates whether a date is in a leap year.
358 
359     \section1
360 
361     \section2 No Year 0
362 
363     There is no year 0. Dates in that year are considered invalid. The
364     year -1 is the year "1 before Christ" or "1 before current era."
365     The day before 1 January 1 CE is 31 December 1 BCE.
366 
367     \section2 Range of Valid Dates
368 
369     Dates are stored internally as a Julian Day number, an integer count of
370     every day in a contiguous range, with 24 November 4714 BCE in the Gregorian
371     calendar being Julian Day 0 (1 January 4713 BCE in the Julian calendar).
372     As well as being an efficient and accurate way of storing an absolute date,
373     it is suitable for converting a Date into other calendar systems such as
374     Hebrew, Islamic or Chinese. The Julian Day number can be obtained using
375     QDate::toJulianDay() and can be set using QDate::fromJulianDay().
376 
377     The range of dates able to be stored by QDate as a Julian Day number is
378     for technical reasons limited to between -784350574879 and 784354017364,
379     which means from before 2 billion BCE to after 2 billion CE.
380 
381     \sa QTime, QDateTime, QDateEdit, QDateTimeEdit, QCalendarWidget
382 */
383 
384 /*!
385     \fn QDate::QDate()
386 
387     Constructs a null date. Null dates are invalid.
388 
389     \sa isNull(), isValid()
390 */
391 
392 /*!
393     Constructs a date with year \a y, month \a m and day \a d.
394 
395     If the specified date is invalid, the date is not set and
396     isValid() returns \c false.
397 
398     \warning Years 1 to 99 are interpreted as is. Year 0 is invalid.
399 
400     \sa isValid()
401 */
402 
403 QDate::QDate(int y, int m, int d)
404 {
405     setDate(y, m, d);
406 }
407 
408 #ifndef QT_BUILD_QMAKE
409 QDate::QDate(int y, int m, int d, const QAbstractCalendar& cal)
410 {
411     setDate(y, m, d, cal);
412 }
413 #endif // QT_BUILD_QMAKE
414 
415 
416 /*!
417     \fn bool QDate::isNull() const
418 
419     Returns \c true if the date is null; otherwise returns \c false. A null
420     date is invalid.
421 
422     \note The behavior of this function is equivalent to isValid().
423 
424     \sa isValid()
425 */
426 
427 
428 /*!
429     \fn bool QDate::isValid() const
430 
431     Returns \c true if this date is valid; otherwise returns \c false.
432 
433     \sa isNull()
434 */
435 
436 
437 /*!
438     Returns the year of this date. Negative numbers indicate years
439     before 1 CE, such that year -44 is 44 BCE.
440 
441     Returns 0 if the date is invalid.
442 
443     \sa month(), day()
444 */
445 
446 int QDate::year() const
447 {
448     if (isNull())
449         return 0;
450 
451     return getDateFromJulianDay(jd).year;
452 }
453 
454 /*!
455     Returns the number corresponding to the month of this date, using
456     the following convention:
457 
458     \list
459     \li 1 = "January"
460     \li 2 = "February"
461     \li 3 = "March"
462     \li 4 = "April"
463     \li 5 = "May"
464     \li 6 = "June"
465     \li 7 = "July"
466     \li 8 = "August"
467     \li 9 = "September"
468     \li 10 = "October"
469     \li 11 = "November"
470     \li 12 = "December"
471     \endlist
472 
473     Returns 0 if the date is invalid.
474 
475     \sa year(), day()
476 */
477 
478 int QDate::month() const
479 {
480     if (isNull())
481         return 0;
482 
483     return getDateFromJulianDay(jd).month;
484 }
485 
486 /*!
487     Returns the day of the month (1 to 31) of this date.
488 
489     Returns 0 if the date is invalid.
490 
491     \sa year(), month(), dayOfWeek()
492 */
493 
494 int QDate::day() const
495 {
496     if (isNull())
497         return 0;
498 
499     return getDateFromJulianDay(jd).day;
500 }
501 
502 /*!
503     Returns the weekday (1 = Monday to 7 = Sunday) for this date.
504 
505     Returns 0 if the date is invalid.
506 
507     \sa day(), dayOfYear(), Qt::DayOfWeek
508 */
509 
510 int QDate::dayOfWeek() const
511 {
512     if (isNull())
513         return 0;
514 
515     if (jd >= 0)
516         return (jd % 7) + 1;
517     else
518         return ((jd + 1) % 7) + 7;
519 }
520 
521 /*!
522     Returns the day of the year (1 to 365 or 366 on leap years) for
523     this date.
524 
525     Returns 0 if the date is invalid.
526 
527     \sa day(), dayOfWeek()
528 */
529 
530 int QDate::dayOfYear() const
531 {
532     if (isNull())
533         return 0;
534 
535     return jd - julianDayFromDate(year(), 1, 1) + 1;
536 }
537 
538 /*!
539     Returns the number of days in the month (28 to 31) for this date.
540 
541     Returns 0 if the date is invalid.
542 
543     \sa day(), daysInYear()
544 */
545 
546 int QDate::daysInMonth() const
547 {
548     if (isNull())
549         return 0;
550 
551     const ParsedDate pd = getDateFromJulianDay(jd);
552     if (pd.month == 2 && isLeapYear(pd.year))
553         return 29;
554     else
555         return monthDays[pd.month];
556 }
557 
558 /*!
559     Returns the number of days in the year (365 or 366) for this date.
560 
561     Returns 0 if the date is invalid.
562 
563     \sa day(), daysInMonth()
564 */
565 
566 int QDate::daysInYear() const
567 {
568     if (isNull())
569         return 0;
570 
571     return isLeapYear(getDateFromJulianDay(jd).year) ? 366 : 365;
572 }
573 
574 /*!
575     Returns the week number (1 to 53), and stores the year in
576     *\a{yearNumber} unless \a yearNumber is null (the default).
577 
578     Returns 0 if the date is invalid.
579 
580     In accordance with ISO 8601, weeks start on Monday and the first
581     Thursday of a year is always in week 1 of that year. Most years
582     have 52 weeks, but some have 53.
583 
584     *\a{yearNumber} is not always the same as year(). For example, 1
585     January 2000 has week number 52 in the year 1999, and 31 December
586     2002 has week number 1 in the year 2003.
587 
588     \sa isValid()
589 */
590 
591 int QDate::weekNumber(int *yearNumber) const
592 {
593     if (!isValid())
594         return 0;
595 
596     int year = QDate::year();
597     int yday = dayOfYear();
598     int wday = dayOfWeek();
599 
600     int week = (yday - wday + 10) / 7;
601 
602     if (week == 0) {
603         // last week of previous year
604         --year;
605         week = (yday + 365 + (QDate::isLeapYear(year) ? 1 : 0) - wday + 10) / 7;
606         Q_ASSERT(week == 52 || week == 53);
607     } else if (week == 53) {
608         // maybe first week of next year
609         int w = (yday - 365 - (QDate::isLeapYear(year) ? 1 : 0) - wday + 10) / 7;
610         if (w > 0) {
611             ++year;
612             week = w;
613         }
614         Q_ASSERT(week == 53 || week == 1);
615     }
616 
617     if (yearNumber != 0)
618         *yearNumber = year;
619     return week;
620 }
621 
622 #ifndef QT_BUILD_QMAKE
623 
624 int QDate::year(const QAbstractCalendar &cal) const
625 {
626     if (isNull())
627         return 0;
628 
629     int y, m, d;
630     if (cal.julianDayToDate(jd, y, m, d))
631         return y;
632     else
633         return 0;
634 }
635 
636 int QDate::month(const QAbstractCalendar &cal) const
637 {
638     if (isNull())
639         return 0;
640 
641     int y, m, d;
642     if (cal.julianDayToDate(jd, y, m, d))
643         return m;
644     else
645         return 0;
646 }
647 
648 int QDate::day(const QAbstractCalendar &cal) const
649 {
650     if (isNull())
651         return 0;
652 
653     int y, m, d;
654     if (cal.julianDayToDate(jd, y, m, d))
655         return d;
656     else
657         return 0;
658 }
659 
660 int QDate::dayOfYear(const QAbstractCalendar &cal) const
661 {
662     if (isNull())
663         return 0;
664 
665     quint64 firstDay;
666     if (cal.dateToJulianDay(year(cal), 1, 1, firstDay))
667         return jd - firstDay + 1;
668     else
669         return 0;
670 }
671 
672 int QDate::daysInMonth(const QAbstractCalendar &cal) const
673 {
674     if (isNull())
675         return 0;
676 
677     return cal.daysInMonth(month(cal),year(cal));
678 }
679 
680 int QDate::daysInYear(const QAbstractCalendar &cal) const
681 {
682     if (isNull())
683         return 0;
684 
685     return cal.daysInYear(year(cal));
686 }
687 
688 #endif // QT_BUILD_QMAKE
689 
690 #ifndef QT_NO_TEXTDATE
691 /*!
692     \since 4.5
693 
694     Returns the short name of the \a month for the representation specified
695     by \a type.
696 
697     The months are enumerated using the following convention:
698 
699     \list
700     \li 1 = "Jan"
701     \li 2 = "Feb"
702     \li 3 = "Mar"
703     \li 4 = "Apr"
704     \li 5 = "May"
705     \li 6 = "Jun"
706     \li 7 = "Jul"
707     \li 8 = "Aug"
708     \li 9 = "Sep"
709     \li 10 = "Oct"
710     \li 11 = "Nov"
711     \li 12 = "Dec"
712     \endlist
713 
714     The month names will be localized according to the system's
715     locale settings, i.e. using QLocale::system().
716 
717     Returns an empty string if the date is invalid.
718 
719     \sa toString(), longMonthName(), shortDayName(), longDayName()
720 */
721 
722 QString QDate::shortMonthName(int month, QDate::MonthNameType type)
723 {
724     if (month >= 1 || month <= 12) {
725         switch (type) {
726         case QDate::DateFormat:
727             return QLocale::system().monthName(month, QLocale::ShortFormat);
728         case QDate::StandaloneFormat:
729             return QLocale::system().standaloneMonthName(month, QLocale::ShortFormat);
730         }
731     }
732     return QString();
733 }
734 
735 /*!
736     \since 4.5
737 
738     Returns the long name of the \a month for the representation specified
739     by \a type.
740 
741     The months are enumerated using the following convention:
742 
743     \list
744     \li 1 = "January"
745     \li 2 = "February"
746     \li 3 = "March"
747     \li 4 = "April"
748     \li 5 = "May"
749     \li 6 = "June"
750     \li 7 = "July"
751     \li 8 = "August"
752     \li 9 = "September"
753     \li 10 = "October"
754     \li 11 = "November"
755     \li 12 = "December"
756     \endlist
757 
758     The month names will be localized according to the system's
759     locale settings, i.e. using QLocale::system().
760 
761     Returns an empty string if the date is invalid.
762 
763     \sa toString(), shortMonthName(), shortDayName(), longDayName()
764 */
765 
766 QString QDate::longMonthName(int month, MonthNameType type)
767 {
768     if (month >= 1 && month <= 12) {
769         switch (type) {
770         case QDate::DateFormat:
771             return QLocale::system().monthName(month, QLocale::LongFormat);
772         case QDate::StandaloneFormat:
773             return QLocale::system().standaloneMonthName(month, QLocale::LongFormat);
774         }
775     }
776     return QString();
777 }
778 
779 /*!
780     \since 4.5
781 
782     Returns the short name of the \a weekday for the representation specified
783     by \a type.
784 
785     The days are enumerated using the following convention:
786 
787     \list
788     \li 1 = "Mon"
789     \li 2 = "Tue"
790     \li 3 = "Wed"
791     \li 4 = "Thu"
792     \li 5 = "Fri"
793     \li 6 = "Sat"
794     \li 7 = "Sun"
795     \endlist
796 
797     The day names will be localized according to the system's
798     locale settings, i.e. using QLocale::system().
799 
800     Returns an empty string if the date is invalid.
801 
802     \sa toString(), shortMonthName(), longMonthName(), longDayName()
803 */
804 
805 QString QDate::shortDayName(int weekday, MonthNameType type)
806 {
807     if (weekday >= 1 && weekday <= 7) {
808         switch (type) {
809         case QDate::DateFormat:
810             return QLocale::system().dayName(weekday, QLocale::ShortFormat);
811         case QDate::StandaloneFormat:
812             return QLocale::system().standaloneDayName(weekday, QLocale::ShortFormat);
813         }
814     }
815     return QString();
816 }
817 
818 /*!
819     \since 4.5
820 
821     Returns the long name of the \a weekday for the representation specified
822     by \a type.
823 
824     The days are enumerated using the following convention:
825 
826     \list
827     \li 1 = "Monday"
828     \li 2 = "Tuesday"
829     \li 3 = "Wednesday"
830     \li 4 = "Thursday"
831     \li 5 = "Friday"
832     \li 6 = "Saturday"
833     \li 7 = "Sunday"
834     \endlist
835 
836     The day names will be localized according to the system's
837     locale settings, i.e. using QLocale::system().
838 
839     Returns an empty string if the date is invalid.
840 
841     \sa toString(), shortDayName(), shortMonthName(), longMonthName()
842 */
843 
844 QString QDate::longDayName(int weekday, MonthNameType type)
845 {
846     if (weekday >= 1 && weekday <= 7) {
847         switch (type) {
848         case QDate::DateFormat:
849             return QLocale::system().dayName(weekday, QLocale::LongFormat);
850         case QDate::StandaloneFormat:
851             return QLocale::system().standaloneDayName(weekday, QLocale::LongFormat);
852         }
853     }
854     return QString();
855 }
856 
857 #ifndef QT_BUILD_QMAKE
858 
859 QString QDate::shortMonthName(int month, const QAbstractCalendar &cal, QDate::MonthNameType type)
860 {
861     if (month >= 1 || month <= cal.monthsInYear()) {
862         switch (type) {
863         case QDate::DateFormat:
864             return QLocale::system().monthName(month, QLocale::ShortFormat, cal);
865         case QDate::StandaloneFormat:
866             return QLocale::system().standaloneMonthName(month, QLocale::ShortFormat, cal);
867         }
868     }
869     return QString();
870 }
871 
872 QString QDate::longMonthName(int month, const QAbstractCalendar &cal, QDate::MonthNameType type)
873 {
874     if (month >= 1 && month <= cal.monthsInYear()) {
875         switch (type) {
876         case QDate::DateFormat:
877             return QLocale::system().monthName(month, QLocale::LongFormat, cal);
878         case QDate::StandaloneFormat:
879             return QLocale::system().standaloneMonthName(month, QLocale::LongFormat, cal);
880         }
881     }
882     return QString();
883 }
884 
885 #endif //QT_BUILD_QMAKE
886 #endif //QT_NO_TEXTDATE
887 
888 #ifndef QT_NO_DATESTRING
889 
890 #ifndef QT_NO_TEXTDATE
891 static QString toStringTextDate(QDate date)
892 {
893     const ParsedDate pd = getDateFromJulianDay(date.toJulianDay());
894     static const QLatin1Char sp(' ');
895     return date.shortDayName(date.dayOfWeek()) + sp
896          + date.shortMonthName(pd.month) + sp
897          + QString::number(pd.day) + sp
898          + QString::number(pd.year);
899 }
900 
901 #ifndef QT_BUILD_QMAKE
902 static QString toStringTextDate(QDate date, const QAbstractCalendar& cal)
903 {
904     static const QLatin1Char sp(' ');
905     return date.shortDayName(date.dayOfWeek()) + sp
906             + date.shortMonthName(date.month(cal)) + sp
907             + QString::number(date.day(cal)) + sp
908             + QString::number(date.year(cal));
909 }
910 #endif //QT_BUILD_QMAKE
911 
912 #endif // QT_NO_TEXTDATE
913 
914 static QString toStringIsoDate(qint64 jd)
915 {
916     const ParsedDate pd = getDateFromJulianDay(jd);
917     if (pd.year >= 0 && pd.year <= 9999)
918         return QString::asprintf("%04d-%02d-%02d", pd.year, pd.month, pd.day);
919     else
920         return QString();
921 }
922 
923 /*!
924     \fn QString QDate::toString(Qt::DateFormat format) const
925 
926     \overload
927 
928     Returns the date as a string. The \a format parameter determines
929     the format of the string.
930 
931     If the \a format is Qt::TextDate, the string is formatted in
932     the default way. QDate::shortDayName() and QDate::shortMonthName()
933     are used to generate the string, so the day and month names will
934     be localized names using the system locale, i.e. QLocale::system(). An
935     example of this formatting is "Sat May 20 1995".
936 
937     If the \a format is Qt::ISODate, the string format corresponds
938     to the ISO 8601 extended specification for representations of
939     dates and times, taking the form YYYY-MM-DD, where YYYY is the
940     year, MM is the month of the year (between 01 and 12), and DD is
941     the day of the month between 01 and 31.
942 
943     If the \a format is Qt::SystemLocaleShortDate or
944     Qt::SystemLocaleLongDate, the string format depends on the locale
945     settings of the system. Identical to calling
946     QLocale::system().toString(date, QLocale::ShortFormat) or
947     QLocale::system().toString(date, QLocale::LongFormat).
948 
949     If the \a format is Qt::DefaultLocaleShortDate or
950     Qt::DefaultLocaleLongDate, the string format depends on the
951     default application locale. This is the locale set with
952     QLocale::setDefault(), or the system locale if no default locale
953     has been set. Identical to calling
954     \l {QLocale::toString()}{QLocale().toString(date, QLocale::ShortFormat) } or
955     \l {QLocale::toString()}{QLocale().toString(date, QLocale::LongFormat)}.
956 
957     If the \a format is Qt::RFC2822Date, the string is formatted in
958     an \l{RFC 2822} compatible way. An example of this formatting is
959     "20 May 1995".
960 
961     If the date is invalid, an empty string will be returned.
962 
963     \warning The Qt::ISODate format is only valid for years in the
964     range 0 to 9999. This restriction may apply to locale-aware
965     formats as well, depending on the locale settings.
966 
967     \sa fromString(), shortDayName(), shortMonthName(), QLocale::toString()
968 */
969 QString QDate::toString(Qt::DateFormat format) const
970 {
971     if (!isValid())
972         return QString();
973 
974     switch (format) {
975     case Qt::SystemLocaleDate:
976     case Qt::SystemLocaleShortDate:
977         return QLocale::system().toString(*this, QLocale::ShortFormat);
978     case Qt::SystemLocaleLongDate:
979         return QLocale::system().toString(*this, QLocale::LongFormat);
980     case Qt::LocaleDate:
981     case Qt::DefaultLocaleShortDate:
982         return QLocale().toString(*this, QLocale::ShortFormat);
983     case Qt::DefaultLocaleLongDate:
984         return QLocale().toString(*this, QLocale::LongFormat);
985     case Qt::RFC2822Date:
986         return QLocale::c().toString(*this, QStringLiteral("dd MMM yyyy"));
987     default:
988 #ifndef QT_NO_TEXTDATE
989     case Qt::TextDate:
990         return toStringTextDate(*this);
991 #endif
992     case Qt::ISODate:
993     case Qt::ISODateWithMs:
994         return toStringIsoDate(jd);
995     }
996 }
997 
998 /*!
999     Returns the date as a string. The \a format parameter determines
1000     the format of the result string.
1001 
1002     These expressions may be used:
1003 
1004     \table
1005     \header \li Expression \li Output
1006     \row \li d \li the day as number without a leading zero (1 to 31)
1007     \row \li dd \li the day as number with a leading zero (01 to 31)
1008     \row \li ddd
1009          \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').
1010              Uses the system locale to localize the name, i.e. QLocale::system().
1011     \row \li dddd
1012          \li the long localized day name (e.g. 'Monday' to 'Sunday').
1013              Uses the system locale to localize the name, i.e. QLocale::system().
1014     \row \li M \li the month as number without a leading zero (1 to 12)
1015     \row \li MM \li the month as number with a leading zero (01 to 12)
1016     \row \li MMM
1017          \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').
1018              Uses the system locale to localize the name, i.e. QLocale::system().
1019     \row \li MMMM
1020          \li the long localized month name (e.g. 'January' to 'December').
1021              Uses the system locale to localize the name, i.e. QLocale::system().
1022     \row \li yy \li the year as two digit number (00 to 99)
1023     \row \li yyyy \li the year as four digit number. If the year is negative,
1024             a minus sign is prepended in addition.
1025     \endtable
1026 
1027     All other input characters will be ignored. Any sequence of characters that
1028     are enclosed in single quotes will be treated as text and not be used as an
1029     expression. Two consecutive single quotes ("''") are replaced by a singlequote
1030     in the output. Formats without separators (e.g. "ddMM") are currently not supported.
1031 
1032     Example format strings (assuming that the QDate is the 20 July
1033     1969):
1034 
1035     \table
1036     \header \li Format            \li Result
1037     \row    \li dd.MM.yyyy        \li 20.07.1969
1038     \row    \li ddd MMMM d yy     \li Sun July 20 69
1039     \row    \li 'The day is' dddd \li The day is Sunday
1040     \endtable
1041 
1042     If the datetime is invalid, an empty string will be returned.
1043 
1044     \sa fromString(), QDateTime::toString(), QTime::toString(), QLocale::toString()
1045 
1046 */
1047 QString QDate::toString(const QString& format) const
1048 {
1049     return QLocale::system().toString(*this, format); // QLocale::c() ### Qt6
1050 }
1051 
1052 #ifndef QT_BUILD_QMAKE
1053 
1054 QString QDate::toString(Qt::DateFormat format, const QAbstractCalendar &cal) const
1055 {
1056     if (!isValid())
1057         return QString();
1058 
1059     switch (format) {
1060     case Qt::SystemLocaleDate:
1061     case Qt::SystemLocaleShortDate:
1062         return QLocale::system().toString(*this, QLocale::ShortFormat, cal);
1063     case Qt::SystemLocaleLongDate:
1064         return QLocale::system().toString(*this, QLocale::LongFormat, cal);
1065     case Qt::LocaleDate:
1066     case Qt::DefaultLocaleShortDate:
1067         return QLocale().toString(*this, QLocale::ShortFormat, cal);
1068     case Qt::DefaultLocaleLongDate:
1069         return QLocale().toString(*this, QLocale::LongFormat, cal);
1070     case Qt::RFC2822Date:
1071         return QLocale::c().toString(*this, QStringLiteral("dd MMM yyyy"), cal);
1072     default:
1073 #ifndef QT_NO_TEXTDATE
1074     case Qt::TextDate:
1075         return toStringTextDate(*this, cal);
1076 #endif
1077     case Qt::ISODate:
1078     case Qt::ISODateWithMs:
1079         return toStringIsoDate(jd);
1080     }
1081 }
1082 
1083 QString QDate::toString(const QString &format, const QAbstractCalendar &cal) const
1084 {
1085     return QLocale::system().toString(*this, format, cal); // QLocale::c() ### Qt6
1086 }
1087 #endif // QT_BUILD_QMAKE
1088 
1089 
1090 #endif //QT_NO_DATESTRING
1091 
1092 /*!
1093     \fn bool QDate::setYMD(int y, int m, int d)
1094 
1095     \deprecated in 5.0, use setDate() instead.
1096 
1097     Sets the date's year \a y, month \a m, and day \a d.
1098 
1099     If \a y is in the range 0 to 99, it is interpreted as 1900 to
1100     1999.
1101     Returns \c false if the date is invalid.
1102 
1103     Use setDate() instead.
1104 */
1105 
1106 /*!
1107     \since 4.2
1108 
1109     Sets the date's \a year, \a month, and \a day. Returns \c true if
1110     the date is valid; otherwise returns \c false.
1111 
1112     If the specified date is invalid, the QDate object is set to be
1113     invalid.
1114 
1115     \sa isValid()
1116 */
1117 bool QDate::setDate(int year, int month, int day)
1118 {
1119     if (isValid(year, month, day))
1120         jd = julianDayFromDate(year, month, day);
1121     else
1122         jd = nullJd();
1123 
1124     return isValid();
1125 }
1126 
1127 #ifndef QT_BUILD_QMAKE
1128 bool QDate::setDate(int year, int month, int day, const QAbstractCalendar &cal)
1129 {
1130     quint64 newjd = nullJd();
1131     bool isDone = cal.isValid(year,month,day) && cal.dateToJulianDay(year,month,day,newjd);
1132     if(isDone){
1133         jd = newjd;
1134     } else {
1135         jd = nullJd();
1136     }
1137     return isDone;
1138 }
1139 #endif //QT_BUILD_QMAKE
1140 
1141 /*!
1142     \since 4.5
1143 
1144     Extracts the date's year, month, and day, and assigns them to
1145     *\a year, *\a month, and *\a day. The pointers may be null.
1146 
1147     Returns 0 if the date is invalid.
1148 
1149     \note In Qt versions prior to 5.7, this function is marked as non-\c{const}.
1150 
1151     \sa year(), month(), day(), isValid()
1152 */
1153 void QDate::getDate(int *year, int *month, int *day) const
1154 {
1155     ParsedDate pd = { 0, 0, 0 };
1156     if (isValid())
1157         pd = getDateFromJulianDay(jd);
1158 
1159     if (year)
1160         *year = pd.year;
1161     if (month)
1162         *month = pd.month;
1163     if (day)
1164         *day = pd.day;
1165 }
1166 
1167 #ifndef QT_BUILD_QMAKE
1168 void QDate::getDate(int *year, int *month, int *day, const QAbstractCalendar& cal) const
1169 {
1170     if(isValid()) {
1171         int y,m,d;
1172         if(cal.julianDayToDate(jd,y,m,d)) {
1173             *year = y;
1174             *month = m;
1175             *day = d;
1176         }
1177     }
1178 }
1179 #endif //QT_BUILD_QMAKE
1180 
1181 #if QT_VERSION < QT_VERSION_CHECK(6, 0, 0)
1182 /*!
1183     \overload
1184     \internal
1185 */
1186 void QDate::getDate(int *year, int *month, int *day)
1187 {
1188     qAsConst(*this).getDate(year, month, day);
1189 }
1190 #endif // < Qt 6
1191 
1192 /*!
1193     Returns a QDate object containing a date \a ndays later than the
1194     date of this object (or earlier if \a ndays is negative).
1195 
1196     Returns a null date if the current date is invalid or the new date is
1197     out of range.
1198 
1199     \sa addMonths(), addYears(), daysTo()
1200 */
1201 
1202 QDate QDate::addDays(qint64 ndays) const
1203 {
1204     if (isNull())
1205         return QDate();
1206 
1207     // Due to limits on minJd() and maxJd() we know that any overflow
1208     // will be invalid and caught by fromJulianDay().
1209     return fromJulianDay(jd + ndays);
1210 }
1211 
1212 /*!
1213     Returns a QDate object containing a date \a nmonths later than the
1214     date of this object (or earlier if \a nmonths is negative).
1215 
1216     \note If the ending day/month combination does not exist in the
1217     resulting month/year, this function will return a date that is the
1218     latest valid date.
1219 
1220     \sa addDays(), addYears()
1221 */
1222 
1223 QDate QDate::addMonths(int nmonths) const
1224 {
1225     if (!isValid())
1226         return QDate();
1227     if (!nmonths)
1228         return *this;
1229 
1230     int old_y, y, m, d;
1231     {
1232         const ParsedDate pd = getDateFromJulianDay(jd);
1233         y = pd.year;
1234         m = pd.month;
1235         d = pd.day;
1236     }
1237     old_y = y;
1238 
1239     bool increasing = nmonths > 0;
1240 
1241     while (nmonths != 0) {
1242         if (nmonths < 0 && nmonths + 12 <= 0) {
1243             y--;
1244             nmonths+=12;
1245         } else if (nmonths < 0) {
1246             m+= nmonths;
1247             nmonths = 0;
1248             if (m <= 0) {
1249                 --y;
1250                 m += 12;
1251             }
1252         } else if (nmonths - 12 >= 0) {
1253             y++;
1254             nmonths -= 12;
1255         } else if (m == 12) {
1256             y++;
1257             m = 0;
1258         } else {
1259             m += nmonths;
1260             nmonths = 0;
1261             if (m > 12) {
1262                 ++y;
1263                 m -= 12;
1264             }
1265         }
1266     }
1267 
1268     // was there a sign change?
1269     if ((old_y > 0 && y <= 0) ||
1270         (old_y < 0 && y >= 0))
1271         // yes, adjust the date by +1 or -1 years
1272         y += increasing ? +1 : -1;
1273 
1274     return fixedDate(y, m, d);
1275 }
1276 
1277 /*!
1278     Returns a QDate object containing a date \a nyears later than the
1279     date of this object (or earlier if \a nyears is negative).
1280 
1281     \note If the ending day/month combination does not exist in the
1282     resulting year (i.e., if the date was Feb 29 and the final year is
1283     not a leap year), this function will return a date that is the
1284     latest valid date (that is, Feb 28).
1285 
1286     \sa addDays(), addMonths()
1287 */
1288 
1289 QDate QDate::addYears(int nyears) const
1290 {
1291     if (!isValid())
1292         return QDate();
1293 
1294     ParsedDate pd = getDateFromJulianDay(jd);
1295 
1296     int old_y = pd.year;
1297     pd.year += nyears;
1298 
1299     // was there a sign change?
1300     if ((old_y > 0 && pd.year <= 0) ||
1301         (old_y < 0 && pd.year >= 0))
1302         // yes, adjust the date by +1 or -1 years
1303         pd.year += nyears > 0 ? +1 : -1;
1304 
1305     return fixedDate(pd.year, pd.month, pd.day);
1306 }
1307 
1308 
1309 #ifndef QT_BUILD_QMAKE
1310 
1311 QDate QDate::addYears(int nyears, const QAbstractCalendar &cal) const
1312 {
1313     if (!isValid())
1314         return QDate();
1315 
1316     ParsedDate pd;
1317     cal.julianDayToDate(jd,pd.year, pd.month, pd.day);
1318 
1319     int old_y = pd.year;
1320     pd.year += nyears;
1321 
1322     // was there a sign change?
1323     if ((old_y > 0 && pd.year <= 0) ||
1324             (old_y < 0 && pd.year >= 0))
1325         // yes, adjust the date by +1 or -1 years
1326         pd.year += nyears > 0 ? +1 : -1;
1327 
1328     return QDate(pd.year, pd.month, pd.day, cal);
1329 }
1330 
1331 QDate QDate::addMonths(int nmonths, const QAbstractCalendar &cal) const
1332 {
1333     if (!isValid())
1334         return QDate();
1335 
1336     if (nmonths == 0)
1337         return *this;
1338 
1339     int old_y, y, m, d;
1340     cal.julianDayToDate(jd,y,m,d);
1341     old_y = y;
1342 
1343     int monthsInYear = cal.monthsInYear();
1344 
1345     bool increasing = nmonths > 0;
1346 
1347     while (nmonths != 0) {
1348         if (nmonths < 0 && nmonths + monthsInYear <= 0) {
1349             y--;
1350             nmonths += monthsInYear;
1351         } else if (nmonths < 0) {
1352             m += nmonths;
1353             nmonths = 0;
1354             if (m <= 0) {
1355                 --y;
1356                 m += monthsInYear;
1357             }
1358         } else if (nmonths - monthsInYear >= 0) {
1359             y++;
1360             nmonths -= monthsInYear;
1361         } else if (m == monthsInYear) {
1362             y++;
1363             m = 0;
1364         } else {
1365             m += nmonths;
1366             nmonths = 0;
1367             if (m > monthsInYear) {
1368                 ++y;
1369                 m -= monthsInYear;
1370             }
1371         }
1372     }
1373 
1374     // was there a sign change?
1375     if ((old_y > 0 && y <= 0) ||
1376         (old_y < 0 && y >= 0))
1377         // yes, adjust the date by +1 or -1 years
1378         y += increasing ? +1 : -1;
1379 
1380     return QDate(y,m,d,cal);
1381 }
1382 
1383 #endif //QT_BUILD_QMAKE
1384 
1385 /*!
1386     Returns the number of days from this date to \a d (which is
1387     negative if \a d is earlier than this date).
1388 
1389     Returns 0 if either date is invalid.
1390 
1391     Example:
1392     \snippet code/src_corelib_tools_qdatetime.cpp 0
1393 
1394     \sa addDays()
1395 */
1396 
1397 qint64 QDate::daysTo(const QDate &d) const
1398 {
1399     if (isNull() || d.isNull())
1400         return 0;
1401 
1402     // Due to limits on minJd() and maxJd() we know this will never overflow
1403     return d.jd - jd;
1404 }
1405 
1406 
1407 /*!
1408     \fn bool QDate::operator==(const QDate &d) const
1409 
1410     Returns \c true if this date is equal to \a d; otherwise returns
1411     false.
1412 
1413 */
1414 
1415 /*!
1416     \fn bool QDate::operator!=(const QDate &d) const
1417 
1418     Returns \c true if this date is different from \a d; otherwise
1419     returns \c false.
1420 */
1421 
1422 /*!
1423     \fn bool QDate::operator<(const QDate &d) const
1424 
1425     Returns \c true if this date is earlier than \a d; otherwise returns
1426     false.
1427 */
1428 
1429 /*!
1430     \fn bool QDate::operator<=(const QDate &d) const
1431 
1432     Returns \c true if this date is earlier than or equal to \a d;
1433     otherwise returns \c false.
1434 */
1435 
1436 /*!
1437     \fn bool QDate::operator>(const QDate &d) const
1438 
1439     Returns \c true if this date is later than \a d; otherwise returns
1440     false.
1441 */
1442 
1443 /*!
1444     \fn bool QDate::operator>=(const QDate &d) const
1445 
1446     Returns \c true if this date is later than or equal to \a d;
1447     otherwise returns \c false.
1448 */
1449 
1450 /*!
1451     \fn QDate::currentDate()
1452     Returns the current date, as reported by the system clock.
1453 
1454     \sa QTime::currentTime(), QDateTime::currentDateTime()
1455 */
1456 
1457 #ifndef QT_NO_DATESTRING
1458 /*!
1459     \fn QDate QDate::fromString(const QString &string, Qt::DateFormat format)
1460 
1461     Returns the QDate represented by the \a string, using the
1462     \a format given, or an invalid date if the string cannot be
1463     parsed.
1464 
1465     Note for Qt::TextDate: It is recommended that you use the
1466     English short month names (e.g. "Jan"). Although localized month
1467     names can also be used, they depend on the user's locale settings.
1468 
1469     \sa toString(), QLocale::toDate()
1470 */
1471 QDate QDate::fromString(const QString& string, Qt::DateFormat format)
1472 {
1473     if (string.isEmpty())
1474         return QDate();
1475 
1476     switch (format) {
1477     case Qt::SystemLocaleDate:
1478     case Qt::SystemLocaleShortDate:
1479         return QLocale::system().toDate(string, QLocale::ShortFormat);
1480     case Qt::SystemLocaleLongDate:
1481         return QLocale::system().toDate(string, QLocale::LongFormat);
1482     case Qt::LocaleDate:
1483     case Qt::DefaultLocaleShortDate:
1484         return QLocale().toDate(string, QLocale::ShortFormat);
1485     case Qt::DefaultLocaleLongDate:
1486         return QLocale().toDate(string, QLocale::LongFormat);
1487     case Qt::RFC2822Date:
1488         return rfcDateImpl(string).date;
1489     default:
1490 #ifndef QT_NO_TEXTDATE
1491     case Qt::TextDate: {
1492         QVector<QStringRef> parts = string.splitRef(QLatin1Char(' '), QString::SkipEmptyParts);
1493 
1494         if (parts.count() != 4)
1495             return QDate();
1496 
1497         QStringRef monthName = parts.at(1);
1498         const int month = fromShortMonthName(monthName);
1499         if (month == -1) {
1500             // Month name matches neither English nor other localised name.
1501             return QDate();
1502         }
1503 
1504         bool ok = false;
1505         int year = parts.at(3).toInt(&ok);
1506         if (!ok)
1507             return QDate();
1508 
1509         return QDate(year, month, parts.at(2).toInt());
1510         }
1511 #endif // QT_NO_TEXTDATE
1512     case Qt::ISODate: {
1513         // Semi-strict parsing, must be long enough and have non-numeric separators
1514         if (string.size() < 10 || string.at(4).isDigit() || string.at(7).isDigit()
1515             || (string.size() > 10 && string.at(10).isDigit())) {
1516             return QDate();
1517         }
1518         const int year = string.midRef(0, 4).toInt();
1519         if (year <= 0 || year > 9999)
1520             return QDate();
1521         return QDate(year, string.midRef(5, 2).toInt(), string.midRef(8, 2).toInt());
1522         }
1523     }
1524     return QDate();
1525 }
1526 
1527 /*!
1528     \fn QDate::fromString(const QString &string, const QString &format)
1529 
1530     Returns the QDate represented by the \a string, using the \a
1531     format given, or an invalid date if the string cannot be parsed.
1532 
1533     These expressions may be used for the format:
1534 
1535     \table
1536     \header \li Expression \li Output
1537     \row \li d \li The day as a number without a leading zero (1 to 31)
1538     \row \li dd \li The day as a number with a leading zero (01 to 31)
1539     \row \li ddd
1540          \li The abbreviated localized day name (e.g. 'Mon' to 'Sun').
1541              Uses the system locale to localize the name, i.e. QLocale::system().
1542     \row \li dddd
1543          \li The long localized day name (e.g. 'Monday' to 'Sunday').
1544              Uses the system locale to localize the name, i.e. QLocale::system().
1545     \row \li M \li The month as a number without a leading zero (1 to 12)
1546     \row \li MM \li The month as a number with a leading zero (01 to 12)
1547     \row \li MMM
1548          \li The abbreviated localized month name (e.g. 'Jan' to 'Dec').
1549              Uses the system locale to localize the name, i.e. QLocale::system().
1550     \row \li MMMM
1551          \li The long localized month name (e.g. 'January' to 'December').
1552              Uses the system locale to localize the name, i.e. QLocale::system().
1553     \row \li yy \li The year as two digit number (00 to 99)
1554     \row \li yyyy \li The year as four digit number. If the year is negative,
1555             a minus sign is prepended in addition.
1556     \endtable
1557 
1558     All other input characters will be treated as text. Any sequence
1559     of characters that are enclosed in single quotes will also be
1560     treated as text and will not be used as an expression. For example:
1561 
1562     \snippet code/src_corelib_tools_qdatetime.cpp 1
1563 
1564     If the format is not satisfied, an invalid QDate is returned. The
1565     expressions that don't expect leading zeroes (d, M) will be
1566     greedy. This means that they will use two digits even if this
1567     will put them outside the accepted range of values and leaves too
1568     few digits for other sections. For example, the following format
1569     string could have meant January 30 but the M will grab two
1570     digits, resulting in an invalid date:
1571 
1572     \snippet code/src_corelib_tools_qdatetime.cpp 2
1573 
1574     For any field that is not represented in the format the following
1575     defaults are used:
1576 
1577     \table
1578     \header \li Field  \li Default value
1579     \row    \li Year   \li 1900
1580     \row    \li Month  \li 1
1581     \row    \li Day    \li 1
1582     \endtable
1583 
1584     The following examples demonstrate the default values:
1585 
1586     \snippet code/src_corelib_tools_qdatetime.cpp 3
1587 
1588     \sa toString(), QDateTime::fromString(), QTime::fromString(),
1589         QLocale::toDate()
1590 */
1591 
1592 QDate QDate::fromString(const QString &string, const QString &format)
1593 {
1594     QDate date;
1595 #if QT_CONFIG(timezone)
1596     QDateTimeParser dt(QVariant::Date, QDateTimeParser::FromString);
1597     // dt.setDefaultLocale(QLocale::c()); ### Qt 6
1598     if (dt.parseFormat(format))
1599         dt.fromString(string, &date, 0);
1600 #else
1601     Q_UNUSED(string);
1602     Q_UNUSED(format);
1603 #endif
1604     return date;
1605 }
1606 #endif // QT_NO_DATESTRING
1607 
1608 /*!
1609     \overload
1610 
1611     Returns \c true if the specified date (\a year, \a month, and \a
1612     day) is valid; otherwise returns \c false.
1613 
1614     Example:
1615     \snippet code/src_corelib_tools_qdatetime.cpp 4
1616 
1617     \sa isNull(), setDate()
1618 */
1619 
1620 bool QDate::isValid(int year, int month, int day)
1621 {
1622     // there is no year 0 in the Gregorian calendar
1623     if (year == 0)
1624         return false;
1625 
1626     return (day > 0 && month > 0 && month <= 12) &&
1627            (day <= monthDays[month] || (day == 29 && month == 2 && isLeapYear(year)));
1628 }
1629 
1630 /*!
1631     \fn bool QDate::isLeapYear(int year)
1632 
1633     Returns \c true if the specified \a year is a leap year; otherwise
1634     returns \c false.
1635 */
1636 
1637 bool QDate::isLeapYear(int y)
1638 {
1639     // No year 0 in Gregorian calendar, so -1, -5, -9 etc are leap years
1640     if ( y < 1)
1641         ++y;
1642 
1643     return (y % 4 == 0 && y % 100 != 0) || y % 400 == 0;
1644 }
1645 
1646 #if !defined(QT_BUILD_QMAKE)
1647 
1648 bool QDate::isValid(int y, int m, int d, const QAbstractCalendar &cal)
1649 {
1650     return cal.isValid(y, m, d);
1651 }
1652 
1653 bool QDate::isLeapYear(int year, const QAbstractCalendar &cal)
1654 {
1655     return cal.isLeapYear(year);
1656 }
1657 
1658 #endif
1659 
1660 /*! \fn static QDate QDate::fromJulianDay(qint64 jd)
1661 
1662     Converts the Julian day \a jd to a QDate.
1663 
1664     \sa toJulianDay()
1665 */
1666 
1667 /*! \fn int QDate::toJulianDay() const
1668 
1669     Converts the date to a Julian day.
1670 
1671     \sa fromJulianDay()
1672 */
1673 
1674 /*****************************************************************************
1675   QTime member functions
1676  *****************************************************************************/
1677 
1678 /*!
1679     \class QTime
1680     \inmodule QtCore
1681     \reentrant
1682 
1683     \brief The QTime class provides clock time functions.
1684 
1685 
1686     A QTime object contains a clock time, i.e. the number of hours,
1687     minutes, seconds, and milliseconds since midnight. It can read the
1688     current time from the system clock and measure a span of elapsed
1689     time. It provides functions for comparing times and for
1690     manipulating a time by adding a number of milliseconds.
1691 
1692     QTime uses the 24-hour clock format; it has no concept of AM/PM.
1693     Unlike QDateTime, QTime knows nothing about time zones or
1694     daylight-saving time (DST).
1695 
1696     A QTime object is typically created either by giving the number
1697     of hours, minutes, seconds, and milliseconds explicitly, or by
1698     using the static function currentTime(), which creates a QTime
1699     object that contains the system's local time. Note that the
1700     accuracy depends on the accuracy of the underlying operating
1701     system; not all systems provide 1-millisecond accuracy.
1702 
1703     The hour(), minute(), second(), and msec() functions provide
1704     access to the number of hours, minutes, seconds, and milliseconds
1705     of the time. The same information is provided in textual format by
1706     the toString() function.
1707 
1708     QTime provides a full set of operators to compare two QTime
1709     objects. QTime A is considered smaller than QTime B if A is
1710     earlier than B.
1711 
1712     The addSecs() and addMSecs() functions provide the time a given
1713     number of seconds or milliseconds later than a given time.
1714     Correspondingly, the number of seconds or milliseconds
1715     between two times can be found using secsTo() or msecsTo().
1716 
1717     QTime can be used to measure a span of elapsed time using the
1718     start(), restart(), and elapsed() functions.
1719 
1720     \sa QDate, QDateTime
1721 */
1722 
1723 /*!
1724     \fn QTime::QTime()
1725 
1726     Constructs a null time object. A null time can be a QTime(0, 0, 0, 0)
1727     (i.e., midnight) object, except that isNull() returns \c true and isValid()
1728     returns \c false.
1729 
1730     \sa isNull(), isValid()
1731 */
1732 
1733 /*!
1734     Constructs a time with hour \a h, minute \a m, seconds \a s and
1735     milliseconds \a ms.
1736 
1737     \a h must be in the range 0 to 23, \a m and \a s must be in the
1738     range 0 to 59, and \a ms must be in the range 0 to 999.
1739 
1740     \sa isValid()
1741 */
1742 
1743 QTime::QTime(int h, int m, int s, int ms)
1744 {
1745     setHMS(h, m, s, ms);
1746 }
1747 
1748 
1749 /*!
1750     \fn bool QTime::isNull() const
1751 
1752     Returns \c true if the time is null (i.e., the QTime object was
1753     constructed using the default constructor); otherwise returns
1754     false. A null time is also an invalid time.
1755 
1756     \sa isValid()
1757 */
1758 
1759 /*!
1760     Returns \c true if the time is valid; otherwise returns \c false. For example,
1761     the time 23:30:55.746 is valid, but 24:12:30 is invalid.
1762 
1763     \sa isNull()
1764 */
1765 
1766 bool QTime::isValid() const
1767 {
1768     return mds > NullTime && mds < MSECS_PER_DAY;
1769 }
1770 
1771 
1772 /*!
1773     Returns the hour part (0 to 23) of the time.
1774 
1775     Returns -1 if the time is invalid.
1776 
1777     \sa minute(), second(), msec()
1778 */
1779 
1780 int QTime::hour() const
1781 {
1782     if (!isValid())
1783         return -1;
1784 
1785     return ds() / MSECS_PER_HOUR;
1786 }
1787 
1788 /*!
1789     Returns the minute part (0 to 59) of the time.
1790 
1791     Returns -1 if the time is invalid.
1792 
1793     \sa hour(), second(), msec()
1794 */
1795 
1796 int QTime::minute() const
1797 {
1798     if (!isValid())
1799         return -1;
1800 
1801     return (ds() % MSECS_PER_HOUR) / MSECS_PER_MIN;
1802 }
1803 
1804 /*!
1805     Returns the second part (0 to 59) of the time.
1806 
1807     Returns -1 if the time is invalid.
1808 
1809     \sa hour(), minute(), msec()
1810 */
1811 
1812 int QTime::second() const
1813 {
1814     if (!isValid())
1815         return -1;
1816 
1817     return (ds() / 1000)%SECS_PER_MIN;
1818 }
1819 
1820 /*!
1821     Returns the millisecond part (0 to 999) of the time.
1822 
1823     Returns -1 if the time is invalid.
1824 
1825     \sa hour(), minute(), second()
1826 */
1827 
1828 int QTime::msec() const
1829 {
1830     if (!isValid())
1831         return -1;
1832 
1833     return ds() % 1000;
1834 }
1835 
1836 #ifndef QT_NO_DATESTRING
1837 /*!
1838     \overload
1839 
1840     Returns the time as a string. The \a format parameter determines
1841     the format of the string.
1842 
1843     If \a format is Qt::TextDate, the string format is HH:mm:ss;
1844     e.g. 1 second before midnight would be "23:59:59".
1845 
1846     If \a format is Qt::ISODate, the string format corresponds to the
1847     ISO 8601 extended specification for representations of dates,
1848     represented by HH:mm:ss. To include milliseconds in the ISO 8601
1849     date, use the \a format Qt::ISODateWithMs, which corresponds to
1850     HH:mm:ss.zzz.
1851 
1852     If the \a format is Qt::SystemLocaleShortDate or
1853     Qt::SystemLocaleLongDate, the string format depends on the locale
1854     settings of the system. Identical to calling
1855     QLocale::system().toString(time, QLocale::ShortFormat) or
1856     QLocale::system().toString(time, QLocale::LongFormat).
1857 
1858     If the \a format is Qt::DefaultLocaleShortDate or
1859     Qt::DefaultLocaleLongDate, the string format depends on the
1860     default application locale. This is the locale set with
1861     QLocale::setDefault(), or the system locale if no default locale
1862     has been set. Identical to calling
1863 
1864     \l {QLocale::toString()}{QLocale().toString(time, QLocale::ShortFormat)} or
1865     \l {QLocale::toString()}{QLocale().toString(time, QLocale::LongFormat)}.
1866 
1867     If the \a format is Qt::RFC2822Date, the string is formatted in
1868     an \l{RFC 2822} compatible way. An example of this formatting is
1869     "23:59:20".
1870 
1871     If the time is invalid, an empty string will be returned.
1872 
1873     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1874 */
1875 
1876 QString QTime::toString(Qt::DateFormat format) const
1877 {
1878     if (!isValid())
1879         return QString();
1880 
1881     switch (format) {
1882     case Qt::SystemLocaleDate:
1883     case Qt::SystemLocaleShortDate:
1884         return QLocale::system().toString(*this, QLocale::ShortFormat);
1885     case Qt::SystemLocaleLongDate:
1886         return QLocale::system().toString(*this, QLocale::LongFormat);
1887     case Qt::LocaleDate:
1888     case Qt::DefaultLocaleShortDate:
1889         return QLocale().toString(*this, QLocale::ShortFormat);
1890     case Qt::DefaultLocaleLongDate:
1891         return QLocale().toString(*this, QLocale::LongFormat);
1892     case Qt::ISODateWithMs:
1893         return QString::asprintf("%02d:%02d:%02d.%03d", hour(), minute(), second(), msec());
1894     case Qt::RFC2822Date:
1895     case Qt::ISODate:
1896     case Qt::TextDate:
1897     default:
1898         return QString::asprintf("%02d:%02d:%02d", hour(), minute(), second());
1899     }
1900 }
1901 
1902 /*!
1903     Returns the time as a string. The \a format parameter determines
1904     the format of the result string.
1905 
1906     These expressions may be used:
1907 
1908     \table
1909     \header \li Expression \li Output
1910     \row \li h
1911          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
1912     \row \li hh
1913          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
1914     \row \li H
1915          \li the hour without a leading zero (0 to 23, even with AM/PM display)
1916     \row \li HH
1917          \li the hour with a leading zero (00 to 23, even with AM/PM display)
1918     \row \li m \li the minute without a leading zero (0 to 59)
1919     \row \li mm \li the minute with a leading zero (00 to 59)
1920     \row \li s \li the second without a leading zero (0 to 59)
1921     \row \li ss \li the second with a leading zero (00 to 59)
1922     \row \li z \li the milliseconds without leading zeroes (0 to 999)
1923     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)
1924     \row \li AP or A
1925          \li use AM/PM display. \e A/AP will be replaced by either
1926              QLocale::amText() or QLocale::pmText().
1927     \row \li ap or a
1928          \li use am/pm display. \e a/ap will be replaced by a lower-case version of
1929              QLocale::amText() or QLocale::pmText().
1930     \row \li t \li the timezone (for example "CEST")
1931     \endtable
1932 
1933     All other input characters will be ignored. Any sequence of characters that
1934     are enclosed in single quotes will be treated as text and not be used as an
1935     expression. Two consecutive single quotes ("''") are replaced by a singlequote
1936     in the output. Formats without separators (e.g. "HHmm") are currently not supported.
1937 
1938     Example format strings (assuming that the QTime is 14:13:09.042 and the system
1939     locale is \c{en_US})
1940 
1941     \table
1942     \header \li Format \li Result
1943     \row \li hh:mm:ss.zzz \li 14:13:09.042
1944     \row \li h:m:s ap     \li 2:13:9 pm
1945     \row \li H:m:s a      \li 14:13:9 pm
1946     \endtable
1947 
1948     If the time is invalid, an empty string will be returned.
1949     If \a format is empty, the default format "hh:mm:ss" is used.
1950 
1951     \sa fromString(), QDate::toString(), QDateTime::toString(), QLocale::toString()
1952 */
1953 QString QTime::toString(const QString& format) const
1954 {
1955     return QLocale::system().toString(*this, format); // QLocale::c() ### Qt6
1956 }
1957 #endif //QT_NO_DATESTRING
1958 /*!
1959     Sets the time to hour \a h, minute \a m, seconds \a s and
1960     milliseconds \a ms.
1961 
1962     \a h must be in the range 0 to 23, \a m and \a s must be in the
1963     range 0 to 59, and \a ms must be in the range 0 to 999.
1964     Returns \c true if the set time is valid; otherwise returns \c false.
1965 
1966     \sa isValid()
1967 */
1968 
1969 bool QTime::setHMS(int h, int m, int s, int ms)
1970 {
1971     if (!isValid(h,m,s,ms)) {
1972         mds = NullTime;                // make this invalid
1973         return false;
1974     }
1975     mds = (h*SECS_PER_HOUR + m*SECS_PER_MIN + s)*1000 + ms;
1976     return true;
1977 }
1978 
1979 /*!
1980     Returns a QTime object containing a time \a s seconds later
1981     than the time of this object (or earlier if \a s is negative).
1982 
1983     Note that the time will wrap if it passes midnight.
1984 
1985     Returns a null time if this time is invalid.
1986 
1987     Example:
1988 
1989     \snippet code/src_corelib_tools_qdatetime.cpp 5
1990 
1991     \sa addMSecs(), secsTo(), QDateTime::addSecs()
1992 */
1993 
1994 QTime QTime::addSecs(int s) const
1995 {
1996     s %= SECS_PER_DAY;
1997     return addMSecs(s * 1000);
1998 }
1999 
2000 /*!
2001     Returns the number of seconds from this time to \a t.
2002     If \a t is earlier than this time, the number of seconds returned
2003     is negative.
2004 
2005     Because QTime measures time within a day and there are 86400
2006     seconds in a day, the result is always between -86400 and 86400.
2007 
2008     secsTo() does not take into account any milliseconds.
2009 
2010     Returns 0 if either time is invalid.
2011 
2012     \sa addSecs(), QDateTime::secsTo()
2013 */
2014 
2015 int QTime::secsTo(const QTime &t) const
2016 {
2017     if (!isValid() || !t.isValid())
2018         return 0;
2019 
2020     // Truncate milliseconds as we do not want to consider them.
2021     int ourSeconds = ds() / 1000;
2022     int theirSeconds = t.ds() / 1000;
2023     return theirSeconds - ourSeconds;
2024 }
2025 
2026 /*!
2027     Returns a QTime object containing a time \a ms milliseconds later
2028     than the time of this object (or earlier if \a ms is negative).
2029 
2030     Note that the time will wrap if it passes midnight. See addSecs()
2031     for an example.
2032 
2033     Returns a null time if this time is invalid.
2034 
2035     \sa addSecs(), msecsTo(), QDateTime::addMSecs()
2036 */
2037 
2038 QTime QTime::addMSecs(int ms) const
2039 {
2040     QTime t;
2041     if (isValid()) {
2042         if (ms < 0) {
2043             // %,/ not well-defined for -ve, so always work with +ve.
2044             int negdays = (MSECS_PER_DAY - ms) / MSECS_PER_DAY;
2045             t.mds = (ds() + ms + negdays * MSECS_PER_DAY) % MSECS_PER_DAY;
2046         } else {
2047             t.mds = (ds() + ms) % MSECS_PER_DAY;
2048         }
2049     }
2050     return t;
2051 }
2052 
2053 /*!
2054     Returns the number of milliseconds from this time to \a t.
2055     If \a t is earlier than this time, the number of milliseconds returned
2056     is negative.
2057 
2058     Because QTime measures time within a day and there are 86400
2059     seconds in a day, the result is always between -86400000 and
2060     86400000 ms.
2061 
2062     Returns 0 if either time is invalid.
2063 
2064     \sa secsTo(), addMSecs(), QDateTime::msecsTo()
2065 */
2066 
2067 int QTime::msecsTo(const QTime &t) const
2068 {
2069     if (!isValid() || !t.isValid())
2070         return 0;
2071     return t.ds() - ds();
2072 }
2073 
2074 
2075 /*!
2076     \fn bool QTime::operator==(const QTime &t) const
2077 
2078     Returns \c true if this time is equal to \a t; otherwise returns \c false.
2079 */
2080 
2081 /*!
2082     \fn bool QTime::operator!=(const QTime &t) const
2083 
2084     Returns \c true if this time is different from \a t; otherwise returns \c false.
2085 */
2086 
2087 /*!
2088     \fn bool QTime::operator<(const QTime &t) const
2089 
2090     Returns \c true if this time is earlier than \a t; otherwise returns \c false.
2091 */
2092 
2093 /*!
2094     \fn bool QTime::operator<=(const QTime &t) const
2095 
2096     Returns \c true if this time is earlier than or equal to \a t;
2097     otherwise returns \c false.
2098 */
2099 
2100 /*!
2101     \fn bool QTime::operator>(const QTime &t) const
2102 
2103     Returns \c true if this time is later than \a t; otherwise returns \c false.
2104 */
2105 
2106 /*!
2107     \fn bool QTime::operator>=(const QTime &t) const
2108 
2109     Returns \c true if this time is later than or equal to \a t;
2110     otherwise returns \c false.
2111 */
2112 
2113 /*!
2114     \fn QTime QTime::fromMSecsSinceStartOfDay(int msecs)
2115 
2116     Returns a new QTime instance with the time set to the number of \a msecs
2117     since the start of the day, i.e. since 00:00:00.
2118 
2119     If \a msecs falls outside the valid range an invalid QTime will be returned.
2120 
2121     \sa msecsSinceStartOfDay()
2122 */
2123 
2124 /*!
2125     \fn int QTime::msecsSinceStartOfDay() const
2126 
2127     Returns the number of msecs since the start of the day, i.e. since 00:00:00.
2128 
2129     \sa fromMSecsSinceStartOfDay()
2130 */
2131 
2132 /*!
2133     \fn QTime::currentTime()
2134 
2135     Returns the current time as reported by the system clock.
2136 
2137     Note that the accuracy depends on the accuracy of the underlying
2138     operating system; not all systems provide 1-millisecond accuracy.
2139 */
2140 
2141 #ifndef QT_NO_DATESTRING
2142 
2143 static QTime fromIsoTimeString(const QStringRef &string, Qt::DateFormat format, bool *isMidnight24)
2144 {
2145     if (isMidnight24)
2146         *isMidnight24 = false;
2147 
2148     const int size = string.size();
2149     if (size < 5)
2150         return QTime();
2151 
2152     bool ok = false;
2153     int hour = string.mid(0, 2).toInt(&ok);
2154     if (!ok)
2155         return QTime();
2156     const int minute = string.mid(3, 2).toInt(&ok);
2157     if (!ok)
2158         return QTime();
2159     int second = 0;
2160     int msec = 0;
2161 
2162     if (size == 5) {
2163         // HH:mm format
2164         second = 0;
2165         msec = 0;
2166     } else if (string.at(5) == QLatin1Char(',') || string.at(5) == QLatin1Char('.')) {
2167         if (format == Qt::TextDate)
2168             return QTime();
2169         // ISODate HH:mm.ssssss format
2170         // We only want 5 digits worth of fraction of minute. This follows the existing
2171         // behavior that determines how milliseconds are read; 4 millisecond digits are
2172         // read and then rounded to 3. If we read at most 5 digits for fraction of minute,
2173         // the maximum amount of millisecond digits it will expand to once converted to
2174         // seconds is 4. E.g. 12:34,99999 will expand to 12:34:59.9994. The milliseconds
2175         // will then be rounded up AND clamped to 999.
2176 
2177         const QStringRef minuteFractionStr = string.mid(6, 5);
2178         const long minuteFractionInt = minuteFractionStr.toLong(&ok);
2179         if (!ok)
2180             return QTime();
2181         const float minuteFraction = double(minuteFractionInt) / (std::pow(double(10), minuteFractionStr.count()));
2182 
2183         const float secondWithMs = minuteFraction * 60;
2184         const float secondNoMs = std::floor(secondWithMs);
2185         const float secondFraction = secondWithMs - secondNoMs;
2186         second = secondNoMs;
2187         msec = qMin(qRound(secondFraction * 1000.0), 999);
2188     } else {
2189         // HH:mm:ss or HH:mm:ss.zzz
2190         second = string.mid(6, 2).toInt(&ok);
2191         if (!ok)
2192             return QTime();
2193         if (size > 8 && (string.at(8) == QLatin1Char(',') || string.at(8) == QLatin1Char('.'))) {
2194             const QStringRef msecStr(string.mid(9, 4));
2195             int msecInt = msecStr.isEmpty() ? 0 : msecStr.toInt(&ok);
2196             if (!ok)
2197                 return QTime();
2198             const double secondFraction(msecInt / (std::pow(double(10), msecStr.count())));
2199             msec = qMin(qRound(secondFraction * 1000.0), 999);
2200         }
2201     }
2202 
2203     const bool isISODate = format == Qt::ISODate || format == Qt::ISODateWithMs;
2204     if (isISODate && hour == 24 && minute == 0 && second == 0 && msec == 0) {
2205         if (isMidnight24)
2206             *isMidnight24 = true;
2207         hour = 0;
2208     }
2209 
2210     return QTime(hour, minute, second, msec);
2211 }
2212 
2213 /*!
2214     \fn QTime QTime::fromString(const QString &string, Qt::DateFormat format)
2215 
2216     Returns the time represented in the \a string as a QTime using the
2217     \a format given, or an invalid time if this is not possible.
2218 
2219     Note that fromString() uses a "C" locale encoded string to convert
2220     milliseconds to a float value. If the default locale is not "C",
2221     this may result in two conversion attempts (if the conversion
2222     fails for the default locale). This should be considered an
2223     implementation detail.
2224 
2225     \sa toString(), QLocale::toTime()
2226 */
2227 QTime QTime::fromString(const QString& string, Qt::DateFormat format)
2228 {
2229     if (string.isEmpty())
2230         return QTime();
2231 
2232     switch (format) {
2233     case Qt::SystemLocaleDate:
2234     case Qt::SystemLocaleShortDate:
2235         return QLocale::system().toTime(string, QLocale::ShortFormat);
2236     case Qt::SystemLocaleLongDate:
2237         return QLocale::system().toTime(string, QLocale::LongFormat);
2238     case Qt::LocaleDate:
2239     case Qt::DefaultLocaleShortDate:
2240         return QLocale().toTime(string, QLocale::ShortFormat);
2241     case Qt::DefaultLocaleLongDate:
2242         return QLocale().toTime(string, QLocale::LongFormat);
2243     case Qt::RFC2822Date:
2244         return rfcDateImpl(string).time;
2245     case Qt::ISODate:
2246     case Qt::ISODateWithMs:
2247     case Qt::TextDate:
2248     default:
2249         return fromIsoTimeString(&string, format, 0);
2250     }
2251 }
2252 
2253 /*!
2254     \fn QTime::fromString(const QString &string, const QString &format)
2255 
2256     Returns the QTime represented by the \a string, using the \a
2257     format given, or an invalid time if the string cannot be parsed.
2258 
2259     These expressions may be used for the format:
2260 
2261     \table
2262     \header \li Expression \li Output
2263     \row \li h
2264          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
2265     \row \li hh
2266          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
2267     \row \li m \li the minute without a leading zero (0 to 59)
2268     \row \li mm \li the minute with a leading zero (00 to 59)
2269     \row \li s \li the second without a leading zero (0 to 59)
2270     \row \li ss \li the second with a leading zero (00 to 59)
2271     \row \li z \li the milliseconds without leading zeroes (0 to 999)
2272     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)
2273     \row \li AP
2274          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".
2275     \row \li ap
2276          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".
2277     \endtable
2278 
2279     All other input characters will be treated as text. Any sequence
2280     of characters that are enclosed in single quotes will also be
2281     treated as text and not be used as an expression.
2282 
2283     \snippet code/src_corelib_tools_qdatetime.cpp 6
2284 
2285     If the format is not satisfied, an invalid QTime is returned.
2286     Expressions that do not expect leading zeroes to be given (h, m, s
2287     and z) are greedy. This means that they will use two digits even if
2288     this puts them outside the range of accepted values and leaves too
2289     few digits for other sections. For example, the following string
2290     could have meant 00:07:10, but the m will grab two digits, resulting
2291     in an invalid time:
2292 
2293     \snippet code/src_corelib_tools_qdatetime.cpp 7
2294 
2295     Any field that is not represented in the format will be set to zero.
2296     For example:
2297 
2298     \snippet code/src_corelib_tools_qdatetime.cpp 8
2299 
2300     \sa toString(), QDateTime::fromString(), QDate::fromString(),
2301     QLocale::toTime()
2302 */
2303 
2304 QTime QTime::fromString(const QString &string, const QString &format)
2305 {
2306     QTime time;
2307 #if QT_CONFIG(timezone)
2308     QDateTimeParser dt(QVariant::Time, QDateTimeParser::FromString);
2309     // dt.setDefaultLocale(QLocale::c()); ### Qt 6
2310     if (dt.parseFormat(format))
2311         dt.fromString(string, 0, &time);
2312 #else
2313     Q_UNUSED(string);
2314     Q_UNUSED(format);
2315 #endif
2316     return time;
2317 }
2318 
2319 #endif // QT_NO_DATESTRING
2320 
2321 
2322 /*!
2323     \overload
2324 
2325     Returns \c true if the specified time is valid; otherwise returns
2326     false.
2327 
2328     The time is valid if \a h is in the range 0 to 23, \a m and
2329     \a s are in the range 0 to 59, and \a ms is in the range 0 to 999.
2330 
2331     Example:
2332 
2333     \snippet code/src_corelib_tools_qdatetime.cpp 9
2334 */
2335 
2336 bool QTime::isValid(int h, int m, int s, int ms)
2337 {
2338     return (uint)h < 24 && (uint)m < 60 && (uint)s < 60 && (uint)ms < 1000;
2339 }
2340 
2341 
2342 /*!
2343     Sets this time to the current time. This is practical for timing:
2344 
2345     \snippet code/src_corelib_tools_qdatetime.cpp 10
2346 
2347     \sa restart(), elapsed(), currentTime()
2348 */
2349 
2350 void QTime::start()
2351 {
2352     *this = currentTime();
2353 }
2354 
2355 /*!
2356     Sets this time to the current time and returns the number of
2357     milliseconds that have elapsed since the last time start() or
2358     restart() was called.
2359 
2360     This function is guaranteed to be atomic and is thus very handy
2361     for repeated measurements. Call start() to start the first
2362     measurement, and restart() for each later measurement.
2363 
2364     Note that the counter wraps to zero 24 hours after the last call
2365     to start() or restart().
2366 
2367     \warning If the system's clock setting has been changed since the
2368     last time start() or restart() was called, the result is
2369     undefined. This can happen when daylight-saving time is turned on
2370     or off.
2371 
2372     \sa start(), elapsed(), currentTime()
2373 */
2374 
2375 int QTime::restart()
2376 {
2377     QTime t = currentTime();
2378     int n = msecsTo(t);
2379     if (n < 0)                                // passed midnight
2380         n += 86400*1000;
2381     *this = t;
2382     return n;
2383 }
2384 
2385 /*!
2386     Returns the number of milliseconds that have elapsed since the
2387     last time start() or restart() was called.
2388 
2389     Note that the counter wraps to zero 24 hours after the last call
2390     to start() or restart.
2391 
2392     Note that the accuracy depends on the accuracy of the underlying
2393     operating system; not all systems provide 1-millisecond accuracy.
2394 
2395     \warning If the system's clock setting has been changed since the
2396     last time start() or restart() was called, the result is
2397     undefined. This can happen when daylight-saving time is turned on
2398     or off.
2399 
2400     \sa start(), restart()
2401 */
2402 
2403 int QTime::elapsed() const
2404 {
2405     int n = msecsTo(currentTime());
2406     if (n < 0)                                // passed midnight
2407         n += 86400 * 1000;
2408     return n;
2409 }
2410 
2411 /*****************************************************************************
2412   QDateTime static helper functions
2413  *****************************************************************************/
2414 
2415 // get the types from QDateTime (through QDateTimePrivate)
2416 typedef QDateTimePrivate::QDateTimeShortData ShortData;
2417 typedef QDateTimePrivate::QDateTimeData QDateTimeData;
2418 
2419 // Calls the platform variant of tzset
2420 static void qt_tzset()
2421 {
2422 #if defined(Q_OS_WIN)
2423     _tzset();
2424 #else
2425     tzset();
2426 #endif // Q_OS_WIN
2427 }
2428 
2429 // Returns the platform variant of timezone, i.e. the standard time offset
2430 // The timezone external variable is documented as always holding the
2431 // Standard Time offset as seconds west of Greenwich, i.e. UTC+01:00 is -3600
2432 // Note this may not be historicaly accurate.
2433 // Relies on tzset, mktime, or localtime having been called to populate timezone
2434 static int qt_timezone()
2435 {
2436 #if defined(_MSC_VER)
2437         long offset;
2438         _get_timezone(&offset);
2439         return offset;
2440 #elif defined(Q_OS_BSD4) && !defined(Q_OS_DARWIN)
2441         time_t clock = time(NULL);
2442         struct tm t;
2443         localtime_r(&clock, &t);
2444         // QTBUG-36080 Workaround for systems without the POSIX timezone
2445         // variable. This solution is not very efficient but fixing it is up to
2446         // the libc implementations.
2447         //
2448         // tm_gmtoff has some important differences compared to the timezone
2449         // variable:
2450         // - It returns the number of seconds east of UTC, and we want the
2451         //   number of seconds west of UTC.
2452         // - It also takes DST into account, so we need to adjust it to always
2453         //   get the Standard Time offset.
2454         return -t.tm_gmtoff + (t.tm_isdst ? (long)SECS_PER_HOUR : 0L);
2455 #elif defined(Q_OS_INTEGRITY)
2456         return 0;
2457 #else
2458         return timezone;
2459 #endif // Q_OS_WIN
2460 }
2461 
2462 // Returns the tzname, assume tzset has been called already
2463 static QString qt_tzname(QDateTimePrivate::DaylightStatus daylightStatus)
2464 {
2465     int isDst = (daylightStatus == QDateTimePrivate::DaylightTime) ? 1 : 0;
2466 #if defined(_MSC_VER) && _MSC_VER >= 1400
2467     size_t s = 0;
2468     char name[512];
2469     if (_get_tzname(&s, name, 512, isDst))
2470         return QString();
2471     return QString::fromLocal8Bit(name);
2472 #else
2473     return QString::fromLocal8Bit(tzname[isDst]);
2474 #endif // Q_OS_WIN
2475 }
2476 
2477 // Calls the platform variant of mktime for the given date, time and daylightStatus,
2478 // and updates the date, time, daylightStatus and abbreviation with the returned values
2479 // If the date falls outside the 1970 to 2037 range supported by mktime / time_t
2480 // then null date/time will be returned, you should adjust the date first if
2481 // you need a guaranteed result.
2482 static qint64 qt_mktime(QDate *date, QTime *time, QDateTimePrivate::DaylightStatus *daylightStatus,
2483                         QString *abbreviation, bool *ok = 0)
2484 {
2485     const qint64 msec = time->msec();
2486     int yy, mm, dd;
2487     date->getDate(&yy, &mm, &dd);
2488 
2489     // All other platforms provide standard C library time functions
2490     tm local;
2491     memset(&local, 0, sizeof(local)); // tm_[wy]day plus any non-standard fields
2492     local.tm_sec = time->second();
2493     local.tm_min = time->minute();
2494     local.tm_hour = time->hour();
2495     local.tm_mday = dd;
2496     local.tm_mon = mm - 1;
2497     local.tm_year = yy - 1900;
2498     if (daylightStatus)
2499         local.tm_isdst = int(*daylightStatus);
2500     else
2501         local.tm_isdst = -1;
2502 
2503 #if defined(Q_OS_WIN)
2504     int hh = local.tm_hour;
2505 #endif // Q_OS_WIN
2506     time_t secsSinceEpoch = mktime(&local);
2507     if (secsSinceEpoch != time_t(-1)) {
2508         *date = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2509         *time = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2510 #if defined(Q_OS_WIN)
2511         // Windows mktime for the missing hour subtracts 1 hour from the time
2512         // instead of adding 1 hour.  If time differs and is standard time then
2513         // this has happened, so add 2 hours to the time and 1 hour to the msecs
2514         if (local.tm_isdst == 0 && local.tm_hour != hh) {
2515             if (time->hour() >= 22)
2516                 *date = date->addDays(1);
2517             *time = time->addSecs(2 * SECS_PER_HOUR);
2518             secsSinceEpoch += SECS_PER_HOUR;
2519             local.tm_isdst = 1;
2520         }
2521 #endif // Q_OS_WIN
2522         if (local.tm_isdst >= 1) {
2523             if (daylightStatus)
2524                 *daylightStatus = QDateTimePrivate::DaylightTime;
2525             if (abbreviation)
2526                 *abbreviation = qt_tzname(QDateTimePrivate::DaylightTime);
2527         } else if (local.tm_isdst == 0) {
2528             if (daylightStatus)
2529                 *daylightStatus = QDateTimePrivate::StandardTime;
2530             if (abbreviation)
2531                 *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2532         } else {
2533             if (daylightStatus)
2534                 *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2535             if (abbreviation)
2536                 *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2537         }
2538         if (ok)
2539             *ok = true;
2540     } else {
2541         *date = QDate();
2542         *time = QTime();
2543         if (daylightStatus)
2544             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2545         if (abbreviation)
2546             *abbreviation = QString();
2547         if (ok)
2548             *ok = false;
2549     }
2550 
2551     return ((qint64)secsSinceEpoch * 1000) + msec;
2552 }
2553 
2554 // Calls the platform variant of localtime for the given msecs, and updates
2555 // the date, time, and DST status with the returned values.
2556 static bool qt_localtime(qint64 msecsSinceEpoch, QDate *localDate, QTime *localTime,
2557                          QDateTimePrivate::DaylightStatus *daylightStatus)
2558 {
2559     const time_t secsSinceEpoch = msecsSinceEpoch / 1000;
2560     const int msec = msecsSinceEpoch % 1000;
2561 
2562     tm local;
2563     bool valid = false;
2564 
2565 #if !defined(QT_NO_THREAD) && defined(_POSIX_THREAD_SAFE_FUNCTIONS)
2566     // localtime() is required to work as if tzset() was called before it.
2567     // localtime_r() does not have this requirement, so make an explicit call.
2568     qt_tzset();
2569     // Use the reentrant version of localtime() where available
2570     // as is thread-safe and doesn't use a shared static data area
2571     tm *res = 0;
2572     res = localtime_r(&secsSinceEpoch, &local);
2573     if (res)
2574         valid = true;
2575 #elif defined(_MSC_VER) && _MSC_VER >= 1400
2576     if (!_localtime64_s(&local, &secsSinceEpoch))
2577         valid = true;
2578 #else
2579     // Returns shared static data which may be overwritten at any time
2580     // So copy the result asap
2581     tm *res = 0;
2582     res = localtime(&secsSinceEpoch);
2583     if (res) {
2584         local = *res;
2585         valid = true;
2586     }
2587 #endif
2588     if (valid) {
2589         *localDate = QDate(local.tm_year + 1900, local.tm_mon + 1, local.tm_mday);
2590         *localTime = QTime(local.tm_hour, local.tm_min, local.tm_sec, msec);
2591         if (daylightStatus) {
2592             if (local.tm_isdst > 0)
2593                 *daylightStatus = QDateTimePrivate::DaylightTime;
2594             else if (local.tm_isdst < 0)
2595                 *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2596             else
2597                 *daylightStatus = QDateTimePrivate::StandardTime;
2598         }
2599         return true;
2600     } else {
2601         *localDate = QDate();
2602         *localTime = QTime();
2603         if (daylightStatus)
2604             *daylightStatus = QDateTimePrivate::UnknownDaylightTime;
2605         return false;
2606     }
2607 }
2608 
2609 // Converts an msecs value into a date and time
2610 static void msecsToTime(qint64 msecs, QDate *date, QTime *time)
2611 {
2612     qint64 jd = JULIAN_DAY_FOR_EPOCH;
2613     qint64 ds = 0;
2614 
2615     if (qAbs(msecs) >= MSECS_PER_DAY) {
2616         jd += (msecs / MSECS_PER_DAY);
2617         msecs %= MSECS_PER_DAY;
2618     }
2619 
2620     if (msecs < 0) {
2621         ds = MSECS_PER_DAY - msecs - 1;
2622         jd -= ds / MSECS_PER_DAY;
2623         ds = ds % MSECS_PER_DAY;
2624         ds = MSECS_PER_DAY - ds - 1;
2625     } else {
2626         ds = msecs;
2627     }
2628 
2629     if (date)
2630         *date = QDate::fromJulianDay(jd);
2631     if (time)
2632         *time = QTime::fromMSecsSinceStartOfDay(ds);
2633 }
2634 
2635 // Converts a date/time value into msecs
2636 static qint64 timeToMSecs(const QDate &date, const QTime &time)
2637 {
2638     return ((date.toJulianDay() - JULIAN_DAY_FOR_EPOCH) * MSECS_PER_DAY)
2639            + time.msecsSinceStartOfDay();
2640 }
2641 
2642 // Convert an MSecs Since Epoch into Local Time
2643 static bool epochMSecsToLocalTime(qint64 msecs, QDate *localDate, QTime *localTime,
2644                                   QDateTimePrivate::DaylightStatus *daylightStatus = 0)
2645 {
2646     if (msecs < 0) {
2647         // Docs state any LocalTime before 1970-01-01 will *not* have any Daylight Time applied
2648         // Instead just use the standard offset from UTC to convert to UTC time
2649         qt_tzset();
2650         msecsToTime(msecs - qt_timezone() * 1000, localDate, localTime);
2651         if (daylightStatus)
2652             *daylightStatus = QDateTimePrivate::StandardTime;
2653         return true;
2654     } else if (msecs > (qint64(TIME_T_MAX) * 1000)) {
2655         // Docs state any LocalTime after 2037-12-31 *will* have any DST applied
2656         // but this may fall outside the supported time_t range, so need to fake it.
2657         // Use existing method to fake the conversion, but this is deeply flawed as it may
2658         // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2659         // TODO Use QTimeZone when available to apply the future rule correctly
2660         QDate utcDate;
2661         QTime utcTime;
2662         msecsToTime(msecs, &utcDate, &utcTime);
2663         int year, month, day;
2664         utcDate.getDate(&year, &month, &day);
2665         // 2037 is not a leap year, so make sure date isn't Feb 29
2666         if (month == 2 && day == 29)
2667             --day;
2668         QDate fakeDate(2037, month, day);
2669         qint64 fakeMsecs = QDateTime(fakeDate, utcTime, Qt::UTC).toMSecsSinceEpoch();
2670         bool res = qt_localtime(fakeMsecs, localDate, localTime, daylightStatus);
2671         *localDate = localDate->addDays(fakeDate.daysTo(utcDate));
2672         return res;
2673     } else {
2674         // Falls inside time_t suported range so can use localtime
2675         return qt_localtime(msecs, localDate, localTime, daylightStatus);
2676     }
2677 }
2678 
2679 // Convert a LocalTime expressed in local msecs encoding and the corresponding
2680 // DST status into a UTC epoch msecs. Optionally populate the returned
2681 // values from mktime for the adjusted local date and time.
2682 static qint64 localMSecsToEpochMSecs(qint64 localMsecs,
2683                                      QDateTimePrivate::DaylightStatus *daylightStatus,
2684                                      QDate *localDate = 0, QTime *localTime = 0,
2685                                      QString *abbreviation = 0)
2686 {
2687     QDate dt;
2688     QTime tm;
2689     msecsToTime(localMsecs, &dt, &tm);
2690 
2691     const qint64 msecsMax = qint64(TIME_T_MAX) * 1000;
2692 
2693     if (localMsecs <= qint64(MSECS_PER_DAY)) {
2694 
2695         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
2696 
2697         // First, if localMsecs is within +/- 1 day of minimum time_t try mktime in case it does
2698         // fall after minimum and needs proper DST conversion
2699         if (localMsecs >= -qint64(MSECS_PER_DAY)) {
2700             bool valid;
2701             qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation, &valid);
2702             if (valid && utcMsecs >= 0) {
2703                 // mktime worked and falls in valid range, so use it
2704                 if (localDate)
2705                     *localDate = dt;
2706                 if (localTime)
2707                     *localTime = tm;
2708                 return utcMsecs;
2709             }
2710         } else {
2711             // If we don't call mktime then need to call tzset to get offset
2712             qt_tzset();
2713         }
2714         // Time is clearly before 1970-01-01 so just use standard offset to convert
2715         qint64 utcMsecs = localMsecs + qt_timezone() * 1000;
2716         if (localDate || localTime)
2717             msecsToTime(localMsecs, localDate, localTime);
2718         if (daylightStatus)
2719             *daylightStatus = QDateTimePrivate::StandardTime;
2720         if (abbreviation)
2721             *abbreviation = qt_tzname(QDateTimePrivate::StandardTime);
2722         return utcMsecs;
2723 
2724     } else if (localMsecs >= msecsMax - MSECS_PER_DAY) {
2725 
2726         // Docs state any LocalTime after 2037-12-31 *will* have any DST applied
2727         // but this may fall outside the supported time_t range, so need to fake it.
2728 
2729         // First, if localMsecs is within +/- 1 day of maximum time_t try mktime in case it does
2730         // fall before maximum and can use proper DST conversion
2731         if (localMsecs <= msecsMax + MSECS_PER_DAY) {
2732             bool valid;
2733             qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation, &valid);
2734             if (valid && utcMsecs <= msecsMax) {
2735                 // mktime worked and falls in valid range, so use it
2736                 if (localDate)
2737                     *localDate = dt;
2738                 if (localTime)
2739                     *localTime = tm;
2740                 return utcMsecs;
2741             }
2742         }
2743         // Use existing method to fake the conversion, but this is deeply flawed as it may
2744         // apply the conversion from the wrong day number, e.g. if rule is last Sunday of month
2745         // TODO Use QTimeZone when available to apply the future rule correctly
2746         int year, month, day;
2747         dt.getDate(&year, &month, &day);
2748         // 2037 is not a leap year, so make sure date isn't Feb 29
2749         if (month == 2 && day == 29)
2750             --day;
2751         QDate fakeDate(2037, month, day);
2752         qint64 fakeDiff = fakeDate.daysTo(dt);
2753         qint64 utcMsecs = qt_mktime(&fakeDate, &tm, daylightStatus, abbreviation);
2754         if (localDate)
2755             *localDate = fakeDate.addDays(fakeDiff);
2756         if (localTime)
2757             *localTime = tm;
2758         QDate utcDate;
2759         QTime utcTime;
2760         msecsToTime(utcMsecs, &utcDate, &utcTime);
2761         utcDate = utcDate.addDays(fakeDiff);
2762         utcMsecs = timeToMSecs(utcDate, utcTime);
2763         return utcMsecs;
2764 
2765     } else {
2766 
2767         // Clearly falls inside 1970-2037 suported range so can use mktime
2768         qint64 utcMsecs = qt_mktime(&dt, &tm, daylightStatus, abbreviation);
2769         if (localDate)
2770             *localDate = dt;
2771         if (localTime)
2772             *localTime = tm;
2773         return utcMsecs;
2774 
2775     }
2776 }
2777 
2778 static inline bool specCanBeSmall(Qt::TimeSpec spec)
2779 {
2780     return spec == Qt::LocalTime || spec == Qt::UTC;
2781 }
2782 
2783 static inline bool msecsCanBeSmall(qint64 msecs)
2784 {
2785     if (!QDateTimeData::CanBeSmall)
2786         return false;
2787 
2788     ShortData sd;
2789     sd.msecs = qintptr(msecs);
2790     return sd.msecs == msecs;
2791 }
2792 
2793 static Q_DECL_CONSTEXPR inline
2794 QDateTimePrivate::StatusFlags mergeSpec(QDateTimePrivate::StatusFlags status, Qt::TimeSpec spec)
2795 {
2796     return QDateTimePrivate::StatusFlags((status & ~QDateTimePrivate::TimeSpecMask) |
2797                                          (int(spec) << QDateTimePrivate::TimeSpecShift));
2798 }
2799 
2800 static Q_DECL_CONSTEXPR inline Qt::TimeSpec extractSpec(QDateTimePrivate::StatusFlags status)
2801 {
2802     return Qt::TimeSpec((status & QDateTimePrivate::TimeSpecMask) >> QDateTimePrivate::TimeSpecShift);
2803 }
2804 
2805 // Set the Daylight Status if LocalTime set via msecs
2806 static Q_DECL_RELAXED_CONSTEXPR inline QDateTimePrivate::StatusFlags
2807 mergeDaylightStatus(QDateTimePrivate::StatusFlags sf, QDateTimePrivate::DaylightStatus status)
2808 {
2809     sf &= ~QDateTimePrivate::DaylightMask;
2810     if (status == QDateTimePrivate::DaylightTime) {
2811         sf |= QDateTimePrivate::SetToDaylightTime;
2812     } else if (status == QDateTimePrivate::StandardTime) {
2813         sf |= QDateTimePrivate::SetToStandardTime;
2814     }
2815     return sf;
2816 }
2817 
2818 // Get the DST Status if LocalTime set via msecs
2819 static Q_DECL_RELAXED_CONSTEXPR inline
2820 QDateTimePrivate::DaylightStatus extractDaylightStatus(QDateTimePrivate::StatusFlags status)
2821 {
2822     if (status & QDateTimePrivate::SetToDaylightTime)
2823         return QDateTimePrivate::DaylightTime;
2824     if (status & QDateTimePrivate::SetToStandardTime)
2825         return QDateTimePrivate::StandardTime;
2826     return QDateTimePrivate::UnknownDaylightTime;
2827 }
2828 
2829 static inline qint64 getMSecs(const QDateTimeData &d)
2830 {
2831     if (d.isShort()) {
2832         // same as, but producing better code
2833         //return d.data.msecs;
2834         return qintptr(d.d) >> 8;
2835     }
2836     return d->m_msecs;
2837 }
2838 
2839 static inline QDateTimePrivate::StatusFlags getStatus(const QDateTimeData &d)
2840 {
2841     if (d.isShort()) {
2842         // same as, but producing better code
2843         //return StatusFlag(d.data.status);
2844         return QDateTimePrivate::StatusFlag(qintptr(d.d) & 0xFF);
2845     }
2846     return d->m_status;
2847 }
2848 
2849 static inline Qt::TimeSpec getSpec(const QDateTimeData &d)
2850 {
2851     return extractSpec(getStatus(d));
2852 }
2853 
2854 #if QT_CONFIG(timezone)
2855 void QDateTimePrivate::setUtcOffsetByTZ(qint64 atMSecsSinceEpoch)
2856 {
2857     m_offsetFromUtc = m_timeZone.d->offsetFromUtc(atMSecsSinceEpoch);
2858 }
2859 #endif
2860 
2861 // Refresh the LocalTime validity and offset
2862 static void refreshDateTime(QDateTimeData &d)
2863 {
2864     auto status = getStatus(d);
2865     const auto spec = extractSpec(status);
2866     const qint64 msecs = getMSecs(d);
2867     qint64 epochMSecs = 0;
2868     int offsetFromUtc = 0;
2869     QDate testDate;
2870     QTime testTime;
2871     Q_ASSERT(spec == Qt::TimeZone || spec == Qt::LocalTime);
2872 
2873 #if QT_CONFIG(timezone)
2874     // If not valid time zone then is invalid
2875     if (spec == Qt::TimeZone) {
2876         if (!d->m_timeZone.isValid()) {
2877             status &= ~QDateTimePrivate::ValidDateTime;
2878         } else {
2879             epochMSecs = QDateTimePrivate::zoneMSecsToEpochMSecs(msecs, d->m_timeZone, extractDaylightStatus(status), &testDate, &testTime);
2880             d->setUtcOffsetByTZ(epochMSecs);
2881         }
2882     }
2883 #endif // timezone
2884 
2885     // If not valid date and time then is invalid
2886     if (!(status & QDateTimePrivate::ValidDate) || !(status & QDateTimePrivate::ValidTime)) {
2887         status &= ~QDateTimePrivate::ValidDateTime;
2888         if (status & QDateTimePrivate::ShortData) {
2889             d.data.status = status;
2890         } else {
2891             d->m_status = status;
2892             d->m_offsetFromUtc = 0;
2893         }
2894         return;
2895     }
2896 
2897     // We have a valid date and time and a Qt::LocalTime or Qt::TimeZone that needs calculating
2898     // LocalTime and TimeZone might fall into a "missing" DST transition hour
2899     // Calling toEpochMSecs will adjust the returned date/time if it does
2900     if (spec == Qt::LocalTime) {
2901         auto dstStatus = extractDaylightStatus(status);
2902         epochMSecs = localMSecsToEpochMSecs(msecs, &dstStatus, &testDate, &testTime);
2903     }
2904     if (timeToMSecs(testDate, testTime) == msecs) {
2905         status |= QDateTimePrivate::ValidDateTime;
2906         // Cache the offset to use in offsetFromUtc()
2907         offsetFromUtc = (msecs - epochMSecs) / 1000;
2908     } else {
2909         status &= ~QDateTimePrivate::ValidDateTime;
2910     }
2911 
2912     if (status & QDateTimePrivate::ShortData) {
2913         d.data.status = status;
2914     } else {
2915         d->m_status = status;
2916         d->m_offsetFromUtc = offsetFromUtc;
2917     }
2918 }
2919 
2920 // Check the UTC / offsetFromUTC validity
2921 static void checkValidDateTime(QDateTimeData &d)
2922 {
2923     auto status = getStatus(d);
2924     auto spec = extractSpec(status);
2925     switch (spec) {
2926     case Qt::OffsetFromUTC:
2927     case Qt::UTC:
2928         // for these, a valid date and a valid time imply a valid QDateTime
2929         if ((status & QDateTimePrivate::ValidDate) && (status & QDateTimePrivate::ValidTime))
2930             status |= QDateTimePrivate::ValidDateTime;
2931         else
2932             status &= ~QDateTimePrivate::ValidDateTime;
2933         if (status & QDateTimePrivate::ShortData)
2934             d.data.status = status;
2935         else
2936             d->m_status = status;
2937         break;
2938     case Qt::TimeZone:
2939     case Qt::LocalTime:
2940         // for these, we need to check whether the timezone is valid and whether
2941         // the time is valid in that timezone. Expensive, but no other option.
2942         refreshDateTime(d);
2943         break;
2944     }
2945 }
2946 
2947 static void setTimeSpec(QDateTimeData &d, Qt::TimeSpec spec, int offsetSeconds)
2948 {
2949     auto status = getStatus(d);
2950     status &= ~(QDateTimePrivate::ValidDateTime | QDateTimePrivate::DaylightMask |
2951                 QDateTimePrivate::TimeSpecMask);
2952 
2953     switch (spec) {
2954     case Qt::OffsetFromUTC:
2955         if (offsetSeconds == 0)
2956             spec = Qt::UTC;
2957         break;
2958     case Qt::TimeZone:
2959         // Use system time zone instead
2960         spec = Qt::LocalTime;
2961         Q_FALLTHROUGH();
2962     case Qt::UTC:
2963     case Qt::LocalTime:
2964         offsetSeconds = 0;
2965         break;
2966     }
2967 
2968     status = mergeSpec(status, spec);
2969     if (d.isShort() && offsetSeconds == 0) {
2970         d.data.status = status;
2971     } else {
2972         d.detach();
2973         d->m_status = status & ~QDateTimePrivate::ShortData;
2974         d->m_offsetFromUtc = offsetSeconds;
2975 #if QT_CONFIG(timezone)
2976         d->m_timeZone = QTimeZone();
2977 #endif // timezone
2978     }
2979 }
2980 
2981 static void setDateTime(QDateTimeData &d, const QDate &date, const QTime &time)
2982 {
2983     // If the date is valid and the time is not we set time to 00:00:00
2984     QTime useTime = time;
2985     if (!useTime.isValid() && date.isValid())
2986         useTime = QTime::fromMSecsSinceStartOfDay(0);
2987 
2988     QDateTimePrivate::StatusFlags newStatus = 0;
2989 
2990     // Set date value and status
2991     qint64 days = 0;
2992     if (date.isValid()) {
2993         days = date.toJulianDay() - JULIAN_DAY_FOR_EPOCH;
2994         newStatus = QDateTimePrivate::ValidDate;
2995     }
2996 
2997     // Set time value and status
2998     int ds = 0;
2999     if (useTime.isValid()) {
3000         ds = useTime.msecsSinceStartOfDay();
3001         newStatus |= QDateTimePrivate::ValidTime;
3002     }
3003 
3004     // Set msecs serial value
3005     qint64 msecs = (days * MSECS_PER_DAY) + ds;
3006     if (d.isShort()) {
3007         // let's see if we can keep this short
3008         if (msecsCanBeSmall(msecs)) {
3009             // yes, we can
3010             d.data.msecs = qintptr(msecs);
3011             d.data.status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
3012             d.data.status |= newStatus;
3013         } else {
3014             // nope...
3015             d.detach();
3016         }
3017     }
3018     if (!d.isShort()) {
3019         d.detach();
3020         d->m_msecs = msecs;
3021         d->m_status &= ~(QDateTimePrivate::ValidityMask | QDateTimePrivate::DaylightMask);
3022         d->m_status |= newStatus;
3023     }
3024 
3025     // Set if date and time are valid
3026     checkValidDateTime(d);
3027 }
3028 
3029 static QPair<QDate, QTime> getDateTime(const QDateTimeData &d)
3030 {
3031     QPair<QDate, QTime> result;
3032     qint64 msecs = getMSecs(d);
3033     auto status = getStatus(d);
3034     msecsToTime(msecs, &result.first, &result.second);
3035 
3036     if (!status.testFlag(QDateTimePrivate::ValidDate))
3037         result.first = QDate();
3038 
3039     if (!status.testFlag(QDateTimePrivate::ValidTime))
3040         result.second = QTime();
3041 
3042     return result;
3043 }
3044 
3045 /*****************************************************************************
3046   QDateTime::Data member functions
3047  *****************************************************************************/
3048 
3049 inline QDateTime::Data::Data()
3050 {
3051     // default-constructed data has a special exception:
3052     // it can be small even if CanBeSmall == false
3053     // (optimization so we don't allocate memory in the default constructor)
3054     quintptr value = quintptr(mergeSpec(QDateTimePrivate::ShortData, Qt::LocalTime));
3055     d = reinterpret_cast<QDateTimePrivate *>(value);
3056 }
3057 
3058 inline QDateTime::Data::Data(Qt::TimeSpec spec)
3059 {
3060     if (CanBeSmall && Q_LIKELY(specCanBeSmall(spec))) {
3061         d = reinterpret_cast<QDateTimePrivate *>(quintptr(mergeSpec(QDateTimePrivate::ShortData, spec)));
3062     } else {
3063         // the structure is too small, we need to detach
3064         d = new QDateTimePrivate;
3065         d->ref.ref();
3066         d->m_status = mergeSpec(0, spec);
3067     }
3068 }
3069 
3070 inline QDateTime::Data::Data(const Data &other)
3071     : d(other.d)
3072 {
3073     if (!isShort()) {
3074         // check if we could shrink
3075         if (specCanBeSmall(extractSpec(d->m_status)) && msecsCanBeSmall(d->m_msecs)) {
3076             ShortData sd;
3077             sd.msecs = qintptr(d->m_msecs);
3078             sd.status = d->m_status | QDateTimePrivate::ShortData;
3079             data = sd;
3080         } else {
3081             // no, have to keep it big
3082             d->ref.ref();
3083         }
3084     }
3085 }
3086 
3087 inline QDateTime::Data::Data(Data &&other)
3088     : d(other.d)
3089 {
3090     // reset the other to a short state
3091     Data dummy;
3092     Q_ASSERT(dummy.isShort());
3093     other.d = dummy.d;
3094 }
3095 
3096 inline QDateTime::Data &QDateTime::Data::operator=(const Data &other)
3097 {
3098     if (d == other.d)
3099         return *this;
3100 
3101     auto x = d;
3102     d = other.d;
3103     if (!other.isShort()) {
3104         // check if we could shrink
3105         if (specCanBeSmall(extractSpec(other.d->m_status)) && msecsCanBeSmall(other.d->m_msecs)) {
3106             ShortData sd;
3107             sd.msecs = qintptr(other.d->m_msecs);
3108             sd.status = other.d->m_status | QDateTimePrivate::ShortData;
3109             data = sd;
3110         } else {
3111             // no, have to keep it big
3112             other.d->ref.ref();
3113         }
3114     }
3115 
3116     if (!(quintptr(x) & QDateTimePrivate::ShortData) && !x->ref.deref())
3117         delete x;
3118     return *this;
3119 }
3120 
3121 inline QDateTime::Data::~Data()
3122 {
3123     if (!isShort() && !d->ref.deref())
3124         delete d;
3125 }
3126 
3127 inline bool QDateTime::Data::isShort() const
3128 {
3129     bool b = quintptr(d) & QDateTimePrivate::ShortData;
3130 
3131     // even if CanBeSmall = false, we have short data for a default-constructed
3132     // QDateTime object. But it's unlikely.
3133     if (CanBeSmall)
3134         return Q_LIKELY(b);
3135     return Q_UNLIKELY(b);
3136 }
3137 
3138 inline void QDateTime::Data::detach()
3139 {
3140     QDateTimePrivate *x;
3141     bool wasShort = isShort();
3142     if (wasShort) {
3143         // force enlarging
3144         x = new QDateTimePrivate;
3145         x->m_status = QDateTimePrivate::StatusFlag(data.status & ~QDateTimePrivate::ShortData);
3146         x->m_msecs = data.msecs;
3147     } else {
3148         if (d->ref.load() == 1)
3149             return;
3150 
3151         x = new QDateTimePrivate(*d);
3152     }
3153 
3154     x->ref.store(1);
3155     if (!wasShort && !d->ref.deref())
3156         delete d;
3157     d = x;
3158 }
3159 
3160 inline const QDateTimePrivate *QDateTime::Data::operator->() const
3161 {
3162     Q_ASSERT(!isShort());
3163     return d;
3164 }
3165 
3166 inline QDateTimePrivate *QDateTime::Data::operator->()
3167 {
3168     // should we attempt to detach here?
3169     Q_ASSERT(!isShort());
3170     Q_ASSERT(d->ref.load() == 1);
3171     return d;
3172 }
3173 
3174 /*****************************************************************************
3175   QDateTimePrivate member functions
3176  *****************************************************************************/
3177 
3178 Q_NEVER_INLINE
3179 QDateTime::Data QDateTimePrivate::create(const QDate &toDate, const QTime &toTime, Qt::TimeSpec toSpec,
3180                                          int offsetSeconds)
3181 {
3182     QDateTime::Data result(toSpec);
3183     setTimeSpec(result, toSpec, offsetSeconds);
3184     setDateTime(result, toDate, toTime);
3185     return result;
3186 }
3187 
3188 #if QT_CONFIG(timezone)
3189 inline QDateTime::Data QDateTimePrivate::create(const QDate &toDate, const QTime &toTime,
3190                                                 const QTimeZone &toTimeZone)
3191 {
3192     QDateTime::Data result(Qt::TimeZone);
3193     Q_ASSERT(!result.isShort());
3194 
3195     result.d->m_status = mergeSpec(result.d->m_status, Qt::TimeZone);
3196     result.d->m_timeZone = toTimeZone;
3197     setDateTime(result, toDate, toTime);
3198     return result;
3199 }
3200 
3201 // Convert a TimeZone time expressed in zone msecs encoding into a UTC epoch msecs
3202 // DST transitions are disambiguated by hint.
3203 inline qint64 QDateTimePrivate::zoneMSecsToEpochMSecs(qint64 zoneMSecs, const QTimeZone &zone,
3204                                                       DaylightStatus hint,
3205                                                       QDate *localDate, QTime *localTime)
3206 {
3207     // Get the effective data from QTimeZone
3208     QTimeZonePrivate::Data data = zone.d->dataForLocalTime(zoneMSecs, int(hint));
3209     // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
3210     // but all affected times afterwards will have DST applied.
3211     if (data.atMSecsSinceEpoch >= 0) {
3212         msecsToTime(data.atMSecsSinceEpoch + (data.offsetFromUtc * 1000), localDate, localTime);
3213         return data.atMSecsSinceEpoch;
3214     } else {
3215         msecsToTime(zoneMSecs, localDate, localTime);
3216         return zoneMSecs - (data.standardTimeOffset * 1000);
3217     }
3218 }
3219 #endif // timezone
3220 
3221 /*****************************************************************************
3222   QDateTime member functions
3223  *****************************************************************************/
3224 
3225 /*!
3226     \class QDateTime
3227     \inmodule QtCore
3228     \ingroup shared
3229     \reentrant
3230     \brief The QDateTime class provides date and time functions.
3231 
3232 
3233     A QDateTime object contains a calendar date and a clock time (a
3234     "datetime"). It is a combination of the QDate and QTime classes.
3235     It can read the current datetime from the system clock. It
3236     provides functions for comparing datetimes and for manipulating a
3237     datetime by adding a number of seconds, days, months, or years.
3238 
3239     A QDateTime object is typically created either by giving a date
3240     and time explicitly in the constructor, or by using the static
3241     function currentDateTime() that returns a QDateTime object set
3242     to the system clock's time. The date and time can be changed with
3243     setDate() and setTime(). A datetime can also be set using the
3244     setTime_t() function that takes a POSIX-standard "number of
3245     seconds since 00:00:00 on January 1, 1970" value. The fromString()
3246     function returns a QDateTime, given a string and a date format
3247     used to interpret the date within the string.
3248 
3249     The date() and time() functions provide access to the date and
3250     time parts of the datetime. The same information is provided in
3251     textual format by the toString() function.
3252 
3253     QDateTime provides a full set of operators to compare two
3254     QDateTime objects, where smaller means earlier and larger means
3255     later.
3256 
3257     You can increment (or decrement) a datetime by a given number of
3258     milliseconds using addMSecs(), seconds using addSecs(), or days
3259     using addDays(). Similarly, you can use addMonths() and addYears().
3260     The daysTo() function returns the number of days between two datetimes,
3261     secsTo() returns the number of seconds between two datetimes, and
3262     msecsTo() returns the number of milliseconds between two datetimes.
3263 
3264     QDateTime can store datetimes as \l{Qt::LocalTime}{local time} or
3265     as \l{Qt::UTC}{UTC}. QDateTime::currentDateTime() returns a
3266     QDateTime expressed as local time; use toUTC() to convert it to
3267     UTC. You can also use timeSpec() to find out if a QDateTime
3268     object stores a UTC time or a local time. Operations such as
3269     addSecs() and secsTo() are aware of daylight-saving time (DST).
3270 
3271     \note QDateTime does not account for leap seconds.
3272 
3273     \section1
3274 
3275     \section2 No Year 0
3276 
3277     There is no year 0. Dates in that year are considered invalid. The
3278     year -1 is the year "1 before Christ" or "1 before current era."
3279     The day before 1 January 1 CE is 31 December 1 BCE.
3280 
3281     \section2 Range of Valid Dates
3282 
3283     The range of valid values able to be stored in QDateTime is dependent on
3284     the internal storage implementation. QDateTime is currently stored in a
3285     qint64 as a serial msecs value encoding the date and time.  This restricts
3286     the date range to about +/- 292 million years, compared to the QDate range
3287     of +/- 2 billion years.  Care must be taken when creating a QDateTime with
3288     extreme values that you do not overflow the storage.  The exact range of
3289     supported values varies depending on the Qt::TimeSpec and time zone.
3290 
3291     \section2
3292     Use of System Timezone
3293 
3294     QDateTime uses the system's time zone information to determine the
3295     offset of local time from UTC. If the system is not configured
3296     correctly or not up-to-date, QDateTime will give wrong results as
3297     well.
3298 
3299     \section2 Daylight-Saving Time (DST)
3300 
3301     QDateTime takes into account the system's time zone information
3302     when dealing with DST. On modern Unix systems, this means it
3303     applies the correct historical DST data whenever possible. On
3304     Windows, where the system doesn't support historical DST data,
3305     historical accuracy is not maintained with respect to DST.
3306 
3307     The range of valid dates taking DST into account is 1970-01-01 to
3308     the present, and rules are in place for handling DST correctly
3309     until 2037-12-31, but these could change. For dates falling
3310     outside that range, QDateTime makes a \e{best guess} using the
3311     rules for year 1970 or 2037, but we can't guarantee accuracy. This
3312     means QDateTime doesn't take into account changes in a locale's
3313     time zone before 1970, even if the system's time zone database
3314     supports that information.
3315 
3316     QDateTime takes into consideration the Standard Time to Daylight-Saving Time
3317     transition.  For example if the transition is at 2am and the clock goes
3318     forward to 3am, then there is a "missing" hour from 02:00:00 to 02:59:59.999
3319     which QDateTime considers to be invalid.  Any date maths performed
3320     will take this missing hour into account and return a valid result.
3321 
3322     \section2 Offset From UTC
3323 
3324     A Qt::TimeSpec of Qt::OffsetFromUTC is also supported. This allows you
3325     to define a QDateTime relative to UTC at a fixed offset of a given number
3326     of seconds from UTC.  For example, an offset of +3600 seconds is one hour
3327     ahead of UTC and is usually written in ISO standard notation as
3328     "UTC+01:00".  Daylight-Saving Time never applies with this TimeSpec.
3329 
3330     There is no explicit size restriction to the offset seconds, but there is
3331     an implicit limit imposed when using the toString() and fromString()
3332     methods which use a format of [+|-]hh:mm, effectively limiting the range
3333     to +/- 99 hours and 59 minutes and whole minutes only.  Note that currently
3334     no time zone lies outside the range of +/- 14 hours.
3335 
3336     \section2 Time Zone Support
3337 
3338     A Qt::TimeSpec of Qt::TimeZone is also supported in conjunction with the
3339     QTimeZone class.  This allows you to define a datetime in a named time zone
3340     adhering to a consistent set of daylight-saving transition rules.  For
3341     example a time zone of "Europe/Berlin" will apply the daylight-saving
3342     rules as used in Germany since 1970.  Note that the transition rules
3343     applied depend on the platform support.  See the QTimeZone documentation
3344     for more details.
3345 
3346     \sa QDate, QTime, QDateTimeEdit, QTimeZone
3347 */
3348 
3349 /*!
3350     Constructs a null datetime (i.e. null date and null time). A null
3351     datetime is invalid, since the date is invalid.
3352 
3353     \sa isValid()
3354 */
3355 QDateTime::QDateTime() Q_DECL_NOEXCEPT_EXPR(Data::CanBeSmall)
3356 {
3357 }
3358 
3359 
3360 /*!
3361     Constructs a datetime with the given \a date, a valid
3362     time(00:00:00.000), and sets the timeSpec() to Qt::LocalTime.
3363 */
3364 
3365 QDateTime::QDateTime(const QDate &date)
3366     : d(QDateTimePrivate::create(date, QTime(0, 0, 0), Qt::LocalTime, 0))
3367 {
3368 }
3369 
3370 /*!
3371     Constructs a datetime with the given \a date and \a time, using
3372     the time specification defined by \a spec.
3373 
3374     If \a date is valid and \a time is not, the time will be set to midnight.
3375 
3376     If \a spec is Qt::OffsetFromUTC then it will be set to Qt::UTC, i.e. an
3377     offset of 0 seconds. To create a Qt::OffsetFromUTC datetime use the
3378     correct constructor.
3379 
3380     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3381     i.e. the current system time zone.  To create a Qt::TimeZone datetime
3382     use the correct constructor.
3383 */
3384 
3385 QDateTime::QDateTime(const QDate &date, const QTime &time, Qt::TimeSpec spec)
3386     : d(QDateTimePrivate::create(date, time, spec, 0))
3387 {
3388 }
3389 
3390 /*!
3391     \since 5.2
3392 
3393     Constructs a datetime with the given \a date and \a time, using
3394     the time specification defined by \a spec and \a offsetSeconds seconds.
3395 
3396     If \a date is valid and \a time is not, the time will be set to midnight.
3397 
3398     If the \a spec is not Qt::OffsetFromUTC then \a offsetSeconds will be ignored.
3399 
3400     If the \a spec is Qt::OffsetFromUTC and \a offsetSeconds is 0 then the
3401     timeSpec() will be set to Qt::UTC, i.e. an offset of 0 seconds.
3402 
3403     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3404     i.e. the current system time zone.  To create a Qt::TimeZone datetime
3405     use the correct constructor.
3406 */
3407 
3408 QDateTime::QDateTime(const QDate &date, const QTime &time, Qt::TimeSpec spec, int offsetSeconds)
3409          : d(QDateTimePrivate::create(date, time, spec, offsetSeconds))
3410 {
3411 }
3412 
3413 #if QT_CONFIG(timezone)
3414 /*!
3415     \since 5.2
3416 
3417     Constructs a datetime with the given \a date and \a time, using
3418     the Time Zone specified by \a timeZone.
3419 
3420     If \a date is valid and \a time is not, the time will be set to 00:00:00.
3421 
3422     If \a timeZone is invalid then the datetime will be invalid.
3423 */
3424 
3425 QDateTime::QDateTime(const QDate &date, const QTime &time, const QTimeZone &timeZone)
3426     : d(QDateTimePrivate::create(date, time, timeZone))
3427 {
3428 }
3429 #endif // timezone
3430 
3431 /*!
3432     Constructs a copy of the \a other datetime.
3433 */
3434 QDateTime::QDateTime(const QDateTime &other) Q_DECL_NOTHROW
3435     : d(other.d)
3436 {
3437 }
3438 
3439 /*!
3440     \since 5.8
3441     Moves the content of the temporary \a other datetime to this object and
3442     leaves \a other in an unspecified (but proper) state.
3443 */
3444 QDateTime::QDateTime(QDateTime &&other) Q_DECL_NOTHROW
3445     : d(std::move(other.d))
3446 {
3447 }
3448 
3449 /*!
3450     Destroys the datetime.
3451 */
3452 QDateTime::~QDateTime()
3453 {
3454 }
3455 
3456 /*!
3457     Makes a copy of the \a other datetime and returns a reference to the
3458     copy.
3459 */
3460 
3461 QDateTime &QDateTime::operator=(const QDateTime &other) Q_DECL_NOTHROW
3462 {
3463     d = other.d;
3464     return *this;
3465 }
3466 /*!
3467     \fn void QDateTime::swap(QDateTime &other)
3468     \since 5.0
3469 
3470     Swaps this datetime with \a other. This operation is very fast
3471     and never fails.
3472 */
3473 
3474 /*!
3475     Returns \c true if both the date and the time are null; otherwise
3476     returns \c false. A null datetime is invalid.
3477 
3478     \sa QDate::isNull(), QTime::isNull(), isValid()
3479 */
3480 
3481 bool QDateTime::isNull() const
3482 {
3483     auto status = getStatus(d);
3484     return !status.testFlag(QDateTimePrivate::ValidDate) &&
3485             !status.testFlag(QDateTimePrivate::ValidTime);
3486 }
3487 
3488 /*!
3489     Returns \c true if both the date and the time are valid and they are valid in
3490     the current Qt::TimeSpec, otherwise returns \c false.
3491 
3492     If the timeSpec() is Qt::LocalTime or Qt::TimeZone then the date and time are
3493     checked to see if they fall in the Standard Time to Daylight-Saving Time transition
3494     hour, i.e. if the transition is at 2am and the clock goes forward to 3am
3495     then the time from 02:00:00 to 02:59:59.999 is considered to be invalid.
3496 
3497     \sa QDate::isValid(), QTime::isValid()
3498 */
3499 
3500 bool QDateTime::isValid() const
3501 {
3502     auto status = getStatus(d);
3503     return status & QDateTimePrivate::ValidDateTime;
3504 }
3505 
3506 /*!
3507     Returns the date part of the datetime.
3508 
3509     \sa setDate(), time(), timeSpec()
3510 */
3511 
3512 QDate QDateTime::date() const
3513 {
3514     auto status = getStatus(d);
3515     if (!status.testFlag(QDateTimePrivate::ValidDate))
3516         return QDate();
3517     QDate dt;
3518     msecsToTime(getMSecs(d), &dt, 0);
3519     return dt;
3520 }
3521 
3522 /*!
3523     Returns the time part of the datetime.
3524 
3525     \sa setTime(), date(), timeSpec()
3526 */
3527 
3528 QTime QDateTime::time() const
3529 {
3530     auto status = getStatus(d);
3531     if (!status.testFlag(QDateTimePrivate::ValidTime))
3532         return QTime();
3533     QTime tm;
3534     msecsToTime(getMSecs(d), 0, &tm);
3535     return tm;
3536 }
3537 
3538 /*!
3539     Returns the time specification of the datetime.
3540 
3541     \sa setTimeSpec(), date(), time(), Qt::TimeSpec
3542 */
3543 
3544 Qt::TimeSpec QDateTime::timeSpec() const
3545 {
3546     return getSpec(d);
3547 }
3548 
3549 #if QT_CONFIG(timezone)
3550 /*!
3551     \since 5.2
3552 
3553     Returns the time zone of the datetime.
3554 
3555     If the timeSpec() is Qt::LocalTime then an instance of the current system
3556     time zone will be returned. Note however that if you copy this time zone
3557     the instance will not remain in sync if the system time zone changes.
3558 
3559     \sa setTimeZone(), Qt::TimeSpec
3560 */
3561 
3562 QTimeZone QDateTime::timeZone() const
3563 {
3564     switch (getSpec(d)) {
3565     case Qt::UTC:
3566         return QTimeZone::utc();
3567     case Qt::OffsetFromUTC:
3568         return QTimeZone(d->m_offsetFromUtc);
3569     case Qt::TimeZone:
3570         Q_ASSERT(d->m_timeZone.isValid());
3571         return d->m_timeZone;
3572     case Qt::LocalTime:
3573         return QTimeZone::systemTimeZone();
3574     }
3575     return QTimeZone();
3576 }
3577 #endif // timezone
3578 
3579 /*!
3580     \since 5.2
3581 
3582     Returns the current Offset From UTC in seconds.
3583 
3584     If the timeSpec() is Qt::OffsetFromUTC this will be the value originally set.
3585 
3586     If the timeSpec() is Qt::TimeZone this will be the offset effective in the
3587     Time Zone including any Daylight-Saving Offset.
3588 
3589     If the timeSpec() is Qt::LocalTime this will be the difference between the
3590     Local Time and UTC including any Daylight-Saving Offset.
3591 
3592     If the timeSpec() is Qt::UTC this will be 0.
3593 
3594     \sa setOffsetFromUtc()
3595 */
3596 
3597 int QDateTime::offsetFromUtc() const
3598 {
3599     if (!d.isShort())
3600         return d->m_offsetFromUtc;
3601     if (!isValid())
3602         return 0;
3603 
3604     auto spec = getSpec(d);
3605     if (spec == Qt::LocalTime) {
3606         // we didn't cache the value, so we need to calculate it now...
3607         qint64 msecs = getMSecs(d);
3608         return (msecs - toMSecsSinceEpoch()) / 1000;
3609     }
3610 
3611     Q_ASSERT(spec == Qt::UTC);
3612     return 0;
3613 }
3614 
3615 /*!
3616     \since 5.2
3617 
3618     Returns the Time Zone Abbreviation for the datetime.
3619 
3620     If the timeSpec() is Qt::UTC this will be "UTC".
3621 
3622     If the timeSpec() is Qt::OffsetFromUTC this will be in the format
3623     "UTC[+-]00:00".
3624 
3625     If the timeSpec() is Qt::LocalTime then the host system is queried for the
3626     correct abbreviation.
3627 
3628     Note that abbreviations may or may not be localized.
3629 
3630     Note too that the abbreviation is not guaranteed to be a unique value,
3631     i.e. different time zones may have the same abbreviation.
3632 
3633     \sa timeSpec()
3634 */
3635 
3636 QString QDateTime::timeZoneAbbreviation() const
3637 {
3638     switch (getSpec(d)) {
3639     case Qt::UTC:
3640         return QLatin1String("UTC");
3641     case Qt::OffsetFromUTC:
3642         return QLatin1String("UTC") + toOffsetString(Qt::ISODate, d->m_offsetFromUtc);
3643     case Qt::TimeZone:
3644 #if !QT_CONFIG(timezone)
3645         break;
3646 #else
3647         return d->m_timeZone.d->abbreviation(toMSecsSinceEpoch());
3648 #endif // timezone
3649     case Qt::LocalTime:  {
3650         QString abbrev;
3651         auto status = extractDaylightStatus(getStatus(d));
3652         localMSecsToEpochMSecs(getMSecs(d), &status, 0, 0, &abbrev);
3653         return abbrev;
3654         }
3655     }
3656     return QString();
3657 }
3658 
3659 /*!
3660     \since 5.2
3661 
3662     Returns if this datetime falls in Daylight-Saving Time.
3663 
3664     If the Qt::TimeSpec is not Qt::LocalTime or Qt::TimeZone then will always
3665     return false.
3666 
3667     \sa timeSpec()
3668 */
3669 
3670 bool QDateTime::isDaylightTime() const
3671 {
3672     switch (getSpec(d)) {
3673     case Qt::UTC:
3674     case Qt::OffsetFromUTC:
3675         return false;
3676     case Qt::TimeZone:
3677 #if !QT_CONFIG(timezone)
3678         break;
3679 #else
3680         return d->m_timeZone.d->isDaylightTime(toMSecsSinceEpoch());
3681 #endif // timezone
3682     case Qt::LocalTime: {
3683         auto status = extractDaylightStatus(getStatus(d));
3684         if (status == QDateTimePrivate::UnknownDaylightTime)
3685             localMSecsToEpochMSecs(getMSecs(d), &status);
3686         return (status == QDateTimePrivate::DaylightTime);
3687         }
3688     }
3689     return false;
3690 }
3691 
3692 /*!
3693     Sets the date part of this datetime to \a date. If no time is set yet, it
3694     is set to midnight. If \a date is invalid, this QDateTime becomes invalid.
3695 
3696     \sa date(), setTime(), setTimeSpec()
3697 */
3698 
3699 void QDateTime::setDate(const QDate &date)
3700 {
3701     setDateTime(d, date, time());
3702 }
3703 
3704 /*!
3705     Sets the time part of this datetime to \a time. If \a time is not valid,
3706     this function sets it to midnight. Therefore, it's possible to clear any
3707     set time in a QDateTime by setting it to a default QTime:
3708 
3709     \code
3710         QDateTime dt = QDateTime::currentDateTime();
3711         dt.setTime(QTime());
3712     \endcode
3713 
3714     \sa time(), setDate(), setTimeSpec()
3715 */
3716 
3717 void QDateTime::setTime(const QTime &time)
3718 {
3719     setDateTime(d, date(), time);
3720 }
3721 
3722 /*!
3723     Sets the time specification used in this datetime to \a spec.
3724     The datetime will refer to a different point in time.
3725 
3726     If \a spec is Qt::OffsetFromUTC then the timeSpec() will be set
3727     to Qt::UTC, i.e. an effective offset of 0.
3728 
3729     If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
3730     i.e. the current system time zone.
3731 
3732     Example:
3733     \snippet code/src_corelib_tools_qdatetime.cpp 19
3734 
3735     \sa timeSpec(), setDate(), setTime(), setTimeZone(), Qt::TimeSpec
3736 */
3737 
3738 void QDateTime::setTimeSpec(Qt::TimeSpec spec)
3739 {
3740     QT_PREPEND_NAMESPACE(setTimeSpec(d, spec, 0));
3741     checkValidDateTime(d);
3742 }
3743 
3744 /*!
3745     \since 5.2
3746 
3747     Sets the timeSpec() to Qt::OffsetFromUTC and the offset to \a offsetSeconds.
3748     The datetime will refer to a different point in time.
3749 
3750     The maximum and minimum offset is 14 positive or negative hours.  If
3751     \a offsetSeconds is larger or smaller than that, then the result is
3752     undefined.
3753 
3754     If \a offsetSeconds is 0 then the timeSpec() will be set to Qt::UTC.
3755 
3756     \sa isValid(), offsetFromUtc()
3757 */
3758 
3759 void QDateTime::setOffsetFromUtc(int offsetSeconds)
3760 {
3761     QT_PREPEND_NAMESPACE(setTimeSpec(d, Qt::OffsetFromUTC, offsetSeconds));
3762     checkValidDateTime(d);
3763 }
3764 
3765 #if QT_CONFIG(timezone)
3766 /*!
3767     \since 5.2
3768 
3769     Sets the time zone used in this datetime to \a toZone.
3770     The datetime will refer to a different point in time.
3771 
3772     If \a toZone is invalid then the datetime will be invalid.
3773 
3774     \sa timeZone(), Qt::TimeSpec
3775 */
3776 
3777 void QDateTime::setTimeZone(const QTimeZone &toZone)
3778 {
3779     d.detach();         // always detach
3780     d->m_status = mergeSpec(d->m_status, Qt::TimeZone);
3781     d->m_offsetFromUtc = 0;
3782     d->m_timeZone = toZone;
3783     refreshDateTime(d);
3784 }
3785 #endif // timezone
3786 
3787 /*!
3788     \since 4.7
3789 
3790     Returns the datetime as the number of milliseconds that have passed
3791     since 1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3792 
3793     On systems that do not support time zones, this function will
3794     behave as if local time were Qt::UTC.
3795 
3796     The behavior for this function is undefined if the datetime stored in
3797     this object is not valid. However, for all valid dates, this function
3798     returns a unique value.
3799 
3800     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3801 */
3802 qint64 QDateTime::toMSecsSinceEpoch() const
3803 {
3804     switch (getSpec(d)) {
3805     case Qt::UTC:
3806         return getMSecs(d);
3807 
3808     case Qt::OffsetFromUTC:
3809         return d->m_msecs - (d->m_offsetFromUtc * 1000);
3810 
3811     case Qt::LocalTime: {
3812         // recalculate the local timezone
3813         auto status = extractDaylightStatus(getStatus(d));
3814         return localMSecsToEpochMSecs(getMSecs(d), &status);
3815     }
3816 
3817     case Qt::TimeZone:
3818 #if !QT_CONFIG(timezone)
3819         return 0;
3820 #else
3821         return QDateTimePrivate::zoneMSecsToEpochMSecs(d->m_msecs, d->m_timeZone,
3822                                                        extractDaylightStatus(getStatus(d)));
3823 #endif
3824     }
3825     Q_UNREACHABLE();
3826     return 0;
3827 }
3828 
3829 /*!
3830     \since 5.8
3831 
3832     Returns the datetime as the number of seconds that have passed since
3833     1970-01-01T00:00:00.000, Coordinated Universal Time (Qt::UTC).
3834 
3835     On systems that do not support time zones, this function will
3836     behave as if local time were Qt::UTC.
3837 
3838     The behavior for this function is undefined if the datetime stored in
3839     this object is not valid. However, for all valid dates, this function
3840     returns a unique value.
3841 
3842     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3843 */
3844 qint64 QDateTime::toSecsSinceEpoch() const
3845 {
3846     return toMSecsSinceEpoch() / 1000;
3847 }
3848 
3849 #if QT_DEPRECATED_SINCE(5, 8)
3850 /*!
3851     \deprecated
3852 
3853     Returns the datetime as the number of seconds that have passed
3854     since 1970-01-01T00:00:00, Coordinated Universal Time (Qt::UTC).
3855 
3856     On systems that do not support time zones, this function will
3857     behave as if local time were Qt::UTC.
3858 
3859     \note This function returns a 32-bit unsigned integer and is deprecated.
3860 
3861     If the date is outside the range 1970-01-01T00:00:00 to
3862     2106-02-07T06:28:14, this function returns -1 cast to an unsigned integer
3863     (i.e., 0xFFFFFFFF).
3864 
3865     To get an extended range, use toMSecsSinceEpoch() or toSecsSinceEpoch().
3866 
3867     \sa toSecsSinceEpoch(), toMSecsSinceEpoch(), setTime_t()
3868 */
3869 
3870 uint QDateTime::toTime_t() const
3871 {
3872     if (!isValid())
3873         return uint(-1);
3874     qint64 retval = toMSecsSinceEpoch() / 1000;
3875     if (quint64(retval) >= Q_UINT64_C(0xFFFFFFFF))
3876         return uint(-1);
3877     return uint(retval);
3878 }
3879 #endif
3880 
3881 /*!
3882     \since 4.7
3883 
3884     Sets the date and time given the number of milliseconds \a msecs that have
3885     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3886     (Qt::UTC). On systems that do not support time zones this function
3887     will behave as if local time were Qt::UTC.
3888 
3889     Note that passing the minimum of \c qint64
3890     (\c{std::numeric_limits<qint64>::min()}) to \a msecs will result in
3891     undefined behavior.
3892 
3893     \sa toMSecsSinceEpoch(), setSecsSinceEpoch()
3894 */
3895 void QDateTime::setMSecsSinceEpoch(qint64 msecs)
3896 {
3897     const auto spec = getSpec(d);
3898     auto status = getStatus(d);
3899 
3900     status &= ~QDateTimePrivate::ValidityMask;
3901     switch (spec) {
3902     case Qt::UTC:
3903         status = status
3904                     | QDateTimePrivate::ValidDate
3905                     | QDateTimePrivate::ValidTime
3906                     | QDateTimePrivate::ValidDateTime;
3907         break;
3908     case Qt::OffsetFromUTC:
3909         msecs = msecs + (d->m_offsetFromUtc * 1000);
3910         status = status
3911                     | QDateTimePrivate::ValidDate
3912                     | QDateTimePrivate::ValidTime
3913                     | QDateTimePrivate::ValidDateTime;
3914         break;
3915     case Qt::TimeZone:
3916         Q_ASSERT(!d.isShort());
3917 #if QT_CONFIG(timezone)
3918         // Docs state any LocalTime before 1970-01-01 will *not* have any DST applied
3919         // but all affected times afterwards will have DST applied.
3920         d.detach();
3921         if (msecs >= 0) {
3922             status = mergeDaylightStatus(status,
3923                                          d->m_timeZone.d->isDaylightTime(msecs)
3924                                          ? QDateTimePrivate::DaylightTime
3925                                          : QDateTimePrivate::StandardTime);
3926             d->m_offsetFromUtc = d->m_timeZone.d->offsetFromUtc(msecs);
3927         } else {
3928             status = mergeDaylightStatus(status, QDateTimePrivate::StandardTime);
3929             d->m_offsetFromUtc = d->m_timeZone.d->standardTimeOffset(msecs);
3930         }
3931         msecs = msecs + (d->m_offsetFromUtc * 1000);
3932         status = status
3933                     | QDateTimePrivate::ValidDate
3934                     | QDateTimePrivate::ValidTime
3935                     | QDateTimePrivate::ValidDateTime;
3936 #endif // timezone
3937         break;
3938     case Qt::LocalTime: {
3939         QDate dt;
3940         QTime tm;
3941         QDateTimePrivate::DaylightStatus dstStatus;
3942         epochMSecsToLocalTime(msecs, &dt, &tm, &dstStatus);
3943         setDateTime(d, dt, tm);
3944         msecs = getMSecs(d);
3945         status = mergeDaylightStatus(getStatus(d), dstStatus);
3946         break;
3947         }
3948     }
3949 
3950     if (msecsCanBeSmall(msecs) && d.isShort()) {
3951         // we can keep short
3952         d.data.msecs = qintptr(msecs);
3953         d.data.status = status;
3954     } else {
3955         d.detach();
3956         d->m_status = status;
3957         d->m_msecs = msecs;
3958     }
3959 
3960     if (spec == Qt::LocalTime || spec == Qt::TimeZone)
3961         refreshDateTime(d);
3962 }
3963 
3964 /*!
3965     \since 5.8
3966 
3967     Sets the date and time given the number of seconds \a secs that have
3968     passed since 1970-01-01T00:00:00.000, Coordinated Universal Time
3969     (Qt::UTC). On systems that do not support time zones this function
3970     will behave as if local time were Qt::UTC.
3971 
3972     \sa toSecsSinceEpoch(), setMSecsSinceEpoch()
3973 */
3974 void QDateTime::setSecsSinceEpoch(qint64 secs)
3975 {
3976     setMSecsSinceEpoch(secs * 1000);
3977 }
3978 
3979 #if QT_DEPRECATED_SINCE(5, 8)
3980 /*!
3981     \fn void QDateTime::setTime_t(uint seconds)
3982     \deprecated
3983 
3984     Sets the date and time given the number of \a seconds that have
3985     passed since 1970-01-01T00:00:00, Coordinated Universal Time
3986     (Qt::UTC). On systems that do not support time zones this function
3987     will behave as if local time were Qt::UTC.
3988 
3989     \note This function is deprecated. For new code, use setSecsSinceEpoch().
3990 
3991     \sa toTime_t()
3992 */
3993 
3994 void QDateTime::setTime_t(uint secsSince1Jan1970UTC)
3995 {
3996     setMSecsSinceEpoch((qint64)secsSince1Jan1970UTC * 1000);
3997 }
3998 #endif
3999 
4000 #ifndef QT_NO_DATESTRING
4001 /*!
4002     \fn QString QDateTime::toString(Qt::DateFormat format) const
4003 
4004     \overload
4005 
4006     Returns the datetime as a string in the \a format given.
4007 
4008     If the \a format is Qt::TextDate, the string is formatted in
4009     the default way. QDate::shortDayName(), QDate::shortMonthName(),
4010     and QTime::toString() are used to generate the string, so the
4011     day and month names will be localized names using the system locale,
4012     i.e. QLocale::system(). An example of this formatting is
4013     "Wed May 20 03:40:13 1998".
4014 
4015     If the \a format is Qt::ISODate, the string format corresponds
4016     to the ISO 8601 extended specification for representations of
4017     dates and times, taking the form YYYY-MM-DDTHH:mm:ss[Z|[+|-]HH:mm],
4018     depending on the timeSpec() of the QDateTime. If the timeSpec()
4019     is Qt::UTC, Z will be appended to the string; if the timeSpec() is
4020     Qt::OffsetFromUTC, the offset in hours and minutes from UTC will
4021     be appended to the string. To include milliseconds in the ISO 8601
4022     date, use the \a format Qt::ISODateWithMs, which corresponds to
4023     YYYY-MM-DDTHH:mm:ss.zzz[Z|[+|-]HH:mm].
4024 
4025     If the \a format is Qt::SystemLocaleShortDate or
4026     Qt::SystemLocaleLongDate, the string format depends on the locale
4027     settings of the system. Identical to calling
4028     QLocale::system().toString(datetime, QLocale::ShortFormat) or
4029     QLocale::system().toString(datetime, QLocale::LongFormat).
4030 
4031     If the \a format is Qt::DefaultLocaleShortDate or
4032     Qt::DefaultLocaleLongDate, the string format depends on the
4033     default application locale. This is the locale set with
4034     QLocale::setDefault(), or the system locale if no default locale
4035     has been set. Identical to calling QLocale().toString(datetime,
4036     QLocale::ShortFormat) or QLocale().toString(datetime,
4037     QLocale::LongFormat).
4038 
4039     If the \a format is Qt::RFC2822Date, the string is formatted
4040     following \l{RFC 2822}.
4041 
4042     If the datetime is invalid, an empty string will be returned.
4043 
4044     \warning The Qt::ISODate format is only valid for years in the
4045     range 0 to 9999. This restriction may apply to locale-aware
4046     formats as well, depending on the locale settings.
4047 
4048     \sa fromString(), QDate::toString(), QTime::toString(),
4049     QLocale::toString()
4050 */
4051 
4052 QString QDateTime::toString(Qt::DateFormat format) const
4053 {
4054     QString buf;
4055     if (!isValid())
4056         return buf;
4057 
4058     switch (format) {
4059     case Qt::SystemLocaleDate:
4060     case Qt::SystemLocaleShortDate:
4061         return QLocale::system().toString(*this, QLocale::ShortFormat);
4062     case Qt::SystemLocaleLongDate:
4063         return QLocale::system().toString(*this, QLocale::LongFormat);
4064     case Qt::LocaleDate:
4065     case Qt::DefaultLocaleShortDate:
4066         return QLocale().toString(*this, QLocale::ShortFormat);
4067     case Qt::DefaultLocaleLongDate:
4068         return QLocale().toString(*this, QLocale::LongFormat);
4069     case Qt::RFC2822Date: {
4070         buf = QLocale::c().toString(*this, QStringLiteral("dd MMM yyyy hh:mm:ss "));
4071         buf += toOffsetString(Qt::TextDate, offsetFromUtc());
4072         return buf;
4073     }
4074     default:
4075 #ifndef QT_NO_TEXTDATE
4076     case Qt::TextDate: {
4077         const QPair<QDate, QTime> p = getDateTime(d);
4078         buf = p.first.toString(Qt::TextDate);
4079         // Insert time between date's day and year:
4080         buf.insert(buf.lastIndexOf(QLatin1Char(' ')),
4081                    QLatin1Char(' ') + p.second.toString(Qt::TextDate));
4082         // Append zone/offset indicator, as appropriate:
4083         switch (timeSpec()) {
4084         case Qt::LocalTime:
4085             break;
4086 # if QT_CONFIG(timezone)
4087         case Qt::TimeZone:
4088             buf += QLatin1Char(' ') + d->m_timeZone.abbreviation(*this);
4089             break;
4090 # endif
4091         default:
4092             buf += QLatin1String(" GMT");
4093             if (getSpec(d) == Qt::OffsetFromUTC)
4094                 buf += toOffsetString(Qt::TextDate, offsetFromUtc());
4095         }
4096         return buf;
4097     }
4098 #endif
4099     case Qt::ISODate:
4100     case Qt::ISODateWithMs: {
4101         const QPair<QDate, QTime> p = getDateTime(d);
4102         const QDate &dt = p.first;
4103         const QTime &tm = p.second;
4104         buf = dt.toString(Qt::ISODate);
4105         if (buf.isEmpty())
4106             return QString();   // failed to convert
4107         buf += QLatin1Char('T');
4108         buf += tm.toString(format);
4109         switch (getSpec(d)) {
4110         case Qt::UTC:
4111             buf += QLatin1Char('Z');
4112             break;
4113         case Qt::OffsetFromUTC:
4114 #if QT_CONFIG(timezone)
4115         case Qt::TimeZone:
4116 #endif
4117             buf += toOffsetString(Qt::ISODate, offsetFromUtc());
4118             break;
4119         default:
4120             break;
4121         }
4122         return buf;
4123     }
4124     }
4125 }
4126 
4127 /*!
4128     Returns the datetime as a string. The \a format parameter
4129     determines the format of the result string.
4130 
4131     These expressions may be used for the date:
4132 
4133     \table
4134     \header \li Expression \li Output
4135     \row \li d \li the day as number without a leading zero (1 to 31)
4136     \row \li dd \li the day as number with a leading zero (01 to 31)
4137     \row \li ddd
4138             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').
4139             Uses the system locale to localize the name, i.e. QLocale::system().
4140     \row \li dddd
4141             \li the long localized day name (e.g. 'Monday' to 'Sunday').
4142             Uses the system locale to localize the name, i.e. QLocale::system().
4143     \row \li M \li the month as number without a leading zero (1-12)
4144     \row \li MM \li the month as number with a leading zero (01-12)
4145     \row \li MMM
4146             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').
4147             Uses the system locale to localize the name, i.e. QLocale::system().
4148     \row \li MMMM
4149             \li the long localized month name (e.g. 'January' to 'December').
4150             Uses the system locale to localize the name, i.e. QLocale::system().
4151     \row \li yy \li the year as two digit number (00-99)
4152     \row \li yyyy \li the year as four digit number
4153     \endtable
4154 
4155     These expressions may be used for the time:
4156 
4157     \table
4158     \header \li Expression \li Output
4159     \row \li h
4160          \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
4161     \row \li hh
4162          \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
4163     \row \li H
4164          \li the hour without a leading zero (0 to 23, even with AM/PM display)
4165     \row \li HH
4166          \li the hour with a leading zero (00 to 23, even with AM/PM display)
4167     \row \li m \li the minute without a leading zero (0 to 59)
4168     \row \li mm \li the minute with a leading zero (00 to 59)
4169     \row \li s \li the second without a leading zero (0 to 59)
4170     \row \li ss \li the second with a leading zero (00 to 59)
4171     \row \li z \li the milliseconds without leading zeroes (0 to 999)
4172     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)
4173     \row \li AP or A
4174          \li use AM/PM display. \e A/AP will be replaced by either "AM" or "PM".
4175     \row \li ap or a
4176          \li use am/pm display. \e a/ap will be replaced by either "am" or "pm".
4177     \row \li t \li the timezone (for example "CEST")
4178     \endtable
4179 
4180     All other input characters will be ignored. Any sequence of characters that
4181     are enclosed in single quotes will be treated as text and not be used as an
4182     expression. Two consecutive single quotes ("''") are replaced by a singlequote
4183     in the output. Formats without separators (e.g. "HHmm") are currently not supported.
4184 
4185     Example format strings (assumed that the QDateTime is 21 May 2001
4186     14:13:09):
4187 
4188     \table
4189     \header \li Format       \li Result
4190     \row \li dd.MM.yyyy      \li 21.05.2001
4191     \row \li ddd MMMM d yy   \li Tue May 21 01
4192     \row \li hh:mm:ss.zzz    \li 14:13:09.042
4193     \row \li h:m:s ap        \li 2:13:9 pm
4194     \endtable
4195 
4196     If the datetime is invalid, an empty string will be returned.
4197 
4198     \sa fromString(), QDate::toString(), QTime::toString(), QLocale::toString()
4199 */
4200 QString QDateTime::toString(const QString& format) const
4201 {
4202     return QLocale::system().toString(*this, format); // QLocale::c() ### Qt6
4203 }
4204 #endif //QT_NO_DATESTRING
4205 
4206 static inline void massageAdjustedDateTime(const QDateTimeData &d, QDate *date, QTime *time)
4207 {
4208     /*
4209       If we have just adjusted to a day with a DST transition, our given time
4210       may lie in the transition hour (either missing or duplicated).  For any
4211       other time, telling mktime (deep in the bowels of localMSecsToEpochMSecs)
4212       we don't know its DST-ness will produce no adjustment (just a decision as
4213       to its DST-ness); but for a time in spring's missing hour it'll adjust the
4214       time while picking a DST-ness.  (Handling of autumn is trickier, as either
4215       DST-ness is valid, without adjusting the time.  We might want to propagate
4216       the daylight status in that case, but it's hard to do so without breaking
4217       (far more common) other cases; and it makes little difference, as the two
4218       answers do then differ only in DST-ness.)
4219     */
4220     auto spec = getSpec(d);
4221     if (spec == Qt::LocalTime) {
4222         QDateTimePrivate::DaylightStatus status = QDateTimePrivate::UnknownDaylightTime;
4223         localMSecsToEpochMSecs(timeToMSecs(*date, *time), &status, date, time);
4224 #if QT_CONFIG(timezone)
4225     } else if (spec == Qt::TimeZone) {
4226         QDateTimePrivate::zoneMSecsToEpochMSecs(timeToMSecs(*date, *time),
4227                                                 d->m_timeZone,
4228                                                 QDateTimePrivate::UnknownDaylightTime,
4229                                                 date, time);
4230 #endif // timezone
4231     }
4232 }
4233 
4234 /*!
4235     Returns a QDateTime object containing a datetime \a ndays days
4236     later than the datetime of this object (or earlier if \a ndays is
4237     negative).
4238 
4239     If the timeSpec() is Qt::LocalTime and the resulting
4240     date and time fall in the Standard Time to Daylight-Saving Time transition
4241     hour then the result will be adjusted accordingly, i.e. if the transition
4242     is at 2am and the clock goes forward to 3am and the result falls between
4243     2am and 3am then the result will be adjusted to fall after 3am.
4244 
4245     \sa daysTo(), addMonths(), addYears(), addSecs()
4246 */
4247 
4248 QDateTime QDateTime::addDays(qint64 ndays) const
4249 {
4250     QDateTime dt(*this);
4251     QPair<QDate, QTime> p = getDateTime(d);
4252     QDate &date = p.first;
4253     QTime &time = p.second;
4254     date = date.addDays(ndays);
4255     massageAdjustedDateTime(dt.d, &date, &time);
4256     setDateTime(dt.d, date, time);
4257     return dt;
4258 }
4259 
4260 /*!
4261     Returns a QDateTime object containing a datetime \a nmonths months
4262     later than the datetime of this object (or earlier if \a nmonths
4263     is negative).
4264 
4265     If the timeSpec() is Qt::LocalTime and the resulting
4266     date and time fall in the Standard Time to Daylight-Saving Time transition
4267     hour then the result will be adjusted accordingly, i.e. if the transition
4268     is at 2am and the clock goes forward to 3am and the result falls between
4269     2am and 3am then the result will be adjusted to fall after 3am.
4270 
4271     \sa daysTo(), addDays(), addYears(), addSecs()
4272 */
4273 
4274 QDateTime QDateTime::addMonths(int nmonths) const
4275 {
4276     QDateTime dt(*this);
4277     QPair<QDate, QTime> p = getDateTime(d);
4278     QDate &date = p.first;
4279     QTime &time = p.second;
4280     date = date.addMonths(nmonths);
4281     massageAdjustedDateTime(dt.d, &date, &time);
4282     setDateTime(dt.d, date, time);
4283     return dt;
4284 }
4285 
4286 /*!
4287     Returns a QDateTime object containing a datetime \a nyears years
4288     later than the datetime of this object (or earlier if \a nyears is
4289     negative).
4290 
4291     If the timeSpec() is Qt::LocalTime and the resulting
4292     date and time fall in the Standard Time to Daylight-Saving Time transition
4293     hour then the result will be adjusted accordingly, i.e. if the transition
4294     is at 2am and the clock goes forward to 3am and the result falls between
4295     2am and 3am then the result will be adjusted to fall after 3am.
4296 
4297     \sa daysTo(), addDays(), addMonths(), addSecs()
4298 */
4299 
4300 QDateTime QDateTime::addYears(int nyears) const
4301 {
4302     QDateTime dt(*this);
4303     QPair<QDate, QTime> p = getDateTime(d);
4304     QDate &date = p.first;
4305     QTime &time = p.second;
4306     date = date.addYears(nyears);
4307     massageAdjustedDateTime(dt.d, &date, &time);
4308     setDateTime(dt.d, date, time);
4309     return dt;
4310 }
4311 
4312 /*!
4313     Returns a QDateTime object containing a datetime \a s seconds
4314     later than the datetime of this object (or earlier if \a s is
4315     negative).
4316 
4317     If this datetime is invalid, an invalid datetime will be returned.
4318 
4319     \sa addMSecs(), secsTo(), addDays(), addMonths(), addYears()
4320 */
4321 
4322 QDateTime QDateTime::addSecs(qint64 s) const
4323 {
4324     return addMSecs(s * 1000);
4325 }
4326 
4327 /*!
4328     Returns a QDateTime object containing a datetime \a msecs miliseconds
4329     later than the datetime of this object (or earlier if \a msecs is
4330     negative).
4331 
4332     If this datetime is invalid, an invalid datetime will be returned.
4333 
4334     \sa addSecs(), msecsTo(), addDays(), addMonths(), addYears()
4335 */
4336 QDateTime QDateTime::addMSecs(qint64 msecs) const
4337 {
4338     if (!isValid())
4339         return QDateTime();
4340 
4341     QDateTime dt(*this);
4342     auto spec = getSpec(d);
4343     if (spec == Qt::LocalTime || spec == Qt::TimeZone) {
4344         // Convert to real UTC first in case crosses DST transition
4345         dt.setMSecsSinceEpoch(toMSecsSinceEpoch() + msecs);
4346     } else {
4347         // No need to convert, just add on
4348         if (d.isShort()) {
4349             // need to check if we need to enlarge first
4350             msecs += dt.d.data.msecs;
4351             if (msecsCanBeSmall(msecs)) {
4352                 dt.d.data.msecs = qintptr(msecs);
4353             } else {
4354                 dt.d.detach();
4355                 dt.d->m_msecs = msecs;
4356             }
4357         } else {
4358             dt.d.detach();
4359             dt.d->m_msecs += msecs;
4360         }
4361     }
4362     return dt;
4363 }
4364 
4365 /*!
4366     Returns the number of days from this datetime to the \a other
4367     datetime. The number of days is counted as the number of times
4368     midnight is reached between this datetime to the \a other
4369     datetime. This means that a 10 minute difference from 23:55 to
4370     0:05 the next day counts as one day.
4371 
4372     If the \a other datetime is earlier than this datetime,
4373     the value returned is negative.
4374 
4375     Example:
4376     \snippet code/src_corelib_tools_qdatetime.cpp 15
4377 
4378     \sa addDays(), secsTo(), msecsTo()
4379 */
4380 
4381 qint64 QDateTime::daysTo(const QDateTime &other) const
4382 {
4383     return date().daysTo(other.date());
4384 }
4385 
4386 /*!
4387     Returns the number of seconds from this datetime to the \a other
4388     datetime. If the \a other datetime is earlier than this datetime,
4389     the value returned is negative.
4390 
4391     Before performing the comparison, the two datetimes are converted
4392     to Qt::UTC to ensure that the result is correct if daylight-saving
4393     (DST) applies to one of the two datetimes but not the other.
4394 
4395     Returns 0 if either datetime is invalid.
4396 
4397     Example:
4398     \snippet code/src_corelib_tools_qdatetime.cpp 11
4399 
4400     \sa addSecs(), daysTo(), QTime::secsTo()
4401 */
4402 
4403 qint64 QDateTime::secsTo(const QDateTime &other) const
4404 {
4405     return (msecsTo(other) / 1000);
4406 }
4407 
4408 /*!
4409     Returns the number of milliseconds from this datetime to the \a other
4410     datetime. If the \a other datetime is earlier than this datetime,
4411     the value returned is negative.
4412 
4413     Before performing the comparison, the two datetimes are converted
4414     to Qt::UTC to ensure that the result is correct if daylight-saving
4415     (DST) applies to one of the two datetimes and but not the other.
4416 
4417     Returns 0 if either datetime is invalid.
4418 
4419     \sa addMSecs(), daysTo(), QTime::msecsTo()
4420 */
4421 
4422 qint64 QDateTime::msecsTo(const QDateTime &other) const
4423 {
4424     if (!isValid() || !other.isValid())
4425         return 0;
4426 
4427     return other.toMSecsSinceEpoch() - toMSecsSinceEpoch();
4428 }
4429 
4430 /*!
4431     \fn QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const
4432 
4433     Returns a copy of this datetime converted to the given time
4434     \a spec.
4435 
4436     If \a spec is Qt::OffsetFromUTC then it is set to Qt::UTC.  To set to a
4437     spec of Qt::OffsetFromUTC use toOffsetFromUtc().
4438 
4439     If \a spec is Qt::TimeZone then it is set to Qt::LocalTime,
4440     i.e. the local Time Zone.
4441 
4442     Example:
4443     \snippet code/src_corelib_tools_qdatetime.cpp 16
4444 
4445     \sa timeSpec(), toTimeZone(), toUTC(), toLocalTime()
4446 */
4447 
4448 QDateTime QDateTime::toTimeSpec(Qt::TimeSpec spec) const
4449 {
4450     if (getSpec(d) == spec && (spec == Qt::UTC || spec == Qt::LocalTime))
4451         return *this;
4452 
4453     if (!isValid()) {
4454         QDateTime ret = *this;
4455         ret.setTimeSpec(spec);
4456         return ret;
4457     }
4458 
4459     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), spec, 0);
4460 }
4461 
4462 /*!
4463     \since 5.2
4464 
4465     \fn QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4466 
4467     Returns a copy of this datetime converted to a spec of Qt::OffsetFromUTC
4468     with the given \a offsetSeconds.
4469 
4470     If the \a offsetSeconds equals 0 then a UTC datetime will be returned
4471 
4472     \sa setOffsetFromUtc(), offsetFromUtc(), toTimeSpec()
4473 */
4474 
4475 QDateTime QDateTime::toOffsetFromUtc(int offsetSeconds) const
4476 {
4477     if (getSpec(d) == Qt::OffsetFromUTC
4478             && d->m_offsetFromUtc == offsetSeconds)
4479         return *this;
4480 
4481     if (!isValid()) {
4482         QDateTime ret = *this;
4483         ret.setOffsetFromUtc(offsetSeconds);
4484         return ret;
4485     }
4486 
4487     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), Qt::OffsetFromUTC, offsetSeconds);
4488 }
4489 
4490 #if QT_CONFIG(timezone)
4491 /*!
4492     \since 5.2
4493 
4494     Returns a copy of this datetime converted to the given \a timeZone
4495 
4496     \sa timeZone(), toTimeSpec()
4497 */
4498 
4499 QDateTime QDateTime::toTimeZone(const QTimeZone &timeZone) const
4500 {
4501     if (getSpec(d) == Qt::TimeZone && d->m_timeZone == timeZone)
4502         return *this;
4503 
4504     if (!isValid()) {
4505         QDateTime ret = *this;
4506         ret.setTimeZone(timeZone);
4507         return ret;
4508     }
4509 
4510     return fromMSecsSinceEpoch(toMSecsSinceEpoch(), timeZone);
4511 }
4512 #endif // timezone
4513 
4514 /*!
4515     Returns \c true if this datetime is equal to the \a other datetime;
4516     otherwise returns \c false.
4517 
4518     \sa operator!=()
4519 */
4520 
4521 bool QDateTime::operator==(const QDateTime &other) const
4522 {
4523     if (getSpec(d) == Qt::LocalTime
4524         && getStatus(d) == getStatus(other.d)) {
4525         return getMSecs(d) == getMSecs(other.d);
4526     }
4527     // Convert to UTC and compare
4528     return (toMSecsSinceEpoch() == other.toMSecsSinceEpoch());
4529 }
4530 
4531 /*!
4532     \fn bool QDateTime::operator!=(const QDateTime &other) const
4533 
4534     Returns \c true if this datetime is different from the \a other
4535     datetime; otherwise returns \c false.
4536 
4537     Two datetimes are different if either the date, the time, or the
4538     time zone components are different.
4539 
4540     \sa operator==()
4541 */
4542 
4543 /*!
4544     Returns \c true if this datetime is earlier than the \a other
4545     datetime; otherwise returns \c false.
4546 */
4547 
4548 bool QDateTime::operator<(const QDateTime &other) const
4549 {
4550     if (getSpec(d) == Qt::LocalTime
4551         && getStatus(d) == getStatus(other.d)) {
4552         return getMSecs(d) < getMSecs(other.d);
4553     }
4554     // Convert to UTC and compare
4555     return (toMSecsSinceEpoch() < other.toMSecsSinceEpoch());
4556 }
4557 
4558 /*!
4559     \fn bool QDateTime::operator<=(const QDateTime &other) const
4560 
4561     Returns \c true if this datetime is earlier than or equal to the
4562     \a other datetime; otherwise returns \c false.
4563 */
4564 
4565 /*!
4566     \fn bool QDateTime::operator>(const QDateTime &other) const
4567 
4568     Returns \c true if this datetime is later than the \a other datetime;
4569     otherwise returns \c false.
4570 */
4571 
4572 /*!
4573     \fn bool QDateTime::operator>=(const QDateTime &other) const
4574 
4575     Returns \c true if this datetime is later than or equal to the
4576     \a other datetime; otherwise returns \c false.
4577 */
4578 
4579 /*!
4580     \fn QDateTime QDateTime::currentDateTime()
4581     Returns the current datetime, as reported by the system clock, in
4582     the local time zone.
4583 
4584     \sa currentDateTimeUtc(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4585 */
4586 
4587 /*!
4588     \fn QDateTime QDateTime::currentDateTimeUtc()
4589     \since 4.7
4590     Returns the current datetime, as reported by the system clock, in
4591     UTC.
4592 
4593     \sa currentDateTime(), QDate::currentDate(), QTime::currentTime(), toTimeSpec()
4594 */
4595 
4596 /*!
4597     \fn qint64 QDateTime::currentMSecsSinceEpoch()
4598     \since 4.7
4599 
4600     Returns the number of milliseconds since 1970-01-01T00:00:00 Universal
4601     Coordinated Time. This number is like the POSIX time_t variable, but
4602     expressed in milliseconds instead.
4603 
4604     \sa currentDateTime(), currentDateTimeUtc(), toTime_t(), toTimeSpec()
4605 */
4606 
4607 /*!
4608     \fn qint64 QDateTime::currentSecsSinceEpoch()
4609     \since 5.8
4610 
4611     Returns the number of seconds since 1970-01-01T00:00:00 Universal
4612     Coordinated Time.
4613 
4614     \sa currentMSecsSinceEpoch()
4615 */
4616 
4617 #if defined(Q_OS_WIN)
4618 static inline uint msecsFromDecomposed(int hour, int minute, int sec, int msec = 0)
4619 {
4620     return MSECS_PER_HOUR * hour + MSECS_PER_MIN * minute + 1000 * sec + msec;
4621 }
4622 
4623 QDate QDate::currentDate()
4624 {
4625     QDate d;
4626     SYSTEMTIME st;
4627     memset(&st, 0, sizeof(SYSTEMTIME));
4628     GetLocalTime(&st);
4629     d.jd = julianDayFromDate(st.wYear, st.wMonth, st.wDay);
4630     return d;
4631 }
4632 
4633 QTime QTime::currentTime()
4634 {
4635     QTime ct;
4636     SYSTEMTIME st;
4637     memset(&st, 0, sizeof(SYSTEMTIME));
4638     GetLocalTime(&st);
4639     ct.setHMS(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4640     return ct;
4641 }
4642 
4643 QDateTime QDateTime::currentDateTime()
4644 {
4645     QDate d;
4646     QTime t;
4647     SYSTEMTIME st;
4648     memset(&st, 0, sizeof(SYSTEMTIME));
4649     GetLocalTime(&st);
4650     d.jd = julianDayFromDate(st.wYear, st.wMonth, st.wDay);
4651     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4652     return QDateTime(d, t);
4653 }
4654 
4655 QDateTime QDateTime::currentDateTimeUtc()
4656 {
4657     QDate d;
4658     QTime t;
4659     SYSTEMTIME st;
4660     memset(&st, 0, sizeof(SYSTEMTIME));
4661     GetSystemTime(&st);
4662     d.jd = julianDayFromDate(st.wYear, st.wMonth, st.wDay);
4663     t.mds = msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
4664     return QDateTime(d, t, Qt::UTC);
4665 }
4666 
4667 qint64 QDateTime::currentMSecsSinceEpoch() Q_DECL_NOTHROW
4668 {
4669     SYSTEMTIME st;
4670     memset(&st, 0, sizeof(SYSTEMTIME));
4671     GetSystemTime(&st);
4672 
4673     return msecsFromDecomposed(st.wHour, st.wMinute, st.wSecond, st.wMilliseconds) +
4674             qint64(julianDayFromDate(st.wYear, st.wMonth, st.wDay)
4675                    - julianDayFromDate(1970, 1, 1)) * Q_INT64_C(86400000);
4676 }
4677 
4678 qint64 QDateTime::currentSecsSinceEpoch() Q_DECL_NOTHROW
4679 {
4680     SYSTEMTIME st;
4681     memset(&st, 0, sizeof(SYSTEMTIME));
4682     GetSystemTime(&st);
4683 
4684     return st.wHour * SECS_PER_HOUR + st.wMinute * SECS_PER_MIN + st.wSecond +
4685             qint64(julianDayFromDate(st.wYear, st.wMonth, st.wDay)
4686                    - julianDayFromDate(1970, 1, 1)) * Q_INT64_C(86400);
4687 }
4688 
4689 #elif defined(Q_OS_UNIX)
4690 QDate QDate::currentDate()
4691 {
4692     return QDateTime::currentDateTime().date();
4693 }
4694 
4695 QTime QTime::currentTime()
4696 {
4697     return QDateTime::currentDateTime().time();
4698 }
4699 
4700 QDateTime QDateTime::currentDateTime()
4701 {
4702     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::LocalTime);
4703 }
4704 
4705 QDateTime QDateTime::currentDateTimeUtc()
4706 {
4707     return fromMSecsSinceEpoch(currentMSecsSinceEpoch(), Qt::UTC);
4708 }
4709 
4710 qint64 QDateTime::currentMSecsSinceEpoch() Q_DECL_NOTHROW
4711 {
4712     // posix compliant system
4713     // we have milliseconds
4714     struct timeval tv;
4715     gettimeofday(&tv, 0);
4716     return qint64(tv.tv_sec) * Q_INT64_C(1000) + tv.tv_usec / 1000;
4717 }
4718 
4719 qint64 QDateTime::currentSecsSinceEpoch() Q_DECL_NOTHROW
4720 {
4721     struct timeval tv;
4722     gettimeofday(&tv, 0);
4723     return qint64(tv.tv_sec);
4724 }
4725 #else
4726 #error "What system is this?"
4727 #endif
4728 
4729 #if QT_DEPRECATED_SINCE(5, 8)
4730 /*!
4731   \since 4.2
4732   \deprecated
4733 
4734   Returns a datetime whose date and time are the number of \a seconds
4735   that have passed since 1970-01-01T00:00:00, Coordinated Universal
4736   Time (Qt::UTC) and converted to Qt::LocalTime.  On systems that do not
4737   support time zones, the time will be set as if local time were Qt::UTC.
4738 
4739   \note This function is deprecated. Please use fromSecsSinceEpoch() in new
4740   code.
4741 
4742   \sa toTime_t(), setTime_t()
4743 */
4744 QDateTime QDateTime::fromTime_t(uint seconds)
4745 {
4746     return fromMSecsSinceEpoch((qint64)seconds * 1000, Qt::LocalTime);
4747 }
4748 
4749 /*!
4750   \since 5.2
4751   \deprecated
4752 
4753   Returns a datetime whose date and time are the number of \a seconds
4754   that have passed since 1970-01-01T00:00:00, Coordinated Universal
4755   Time (Qt::UTC) and converted to the given \a spec.
4756 
4757   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4758   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4759   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4760 
4761   \note This function is deprecated. Please use fromSecsSinceEpoch() in new
4762   code.
4763 
4764   \sa toTime_t(), setTime_t()
4765 */
4766 QDateTime QDateTime::fromTime_t(uint seconds, Qt::TimeSpec spec, int offsetSeconds)
4767 {
4768     return fromMSecsSinceEpoch((qint64)seconds * 1000, spec, offsetSeconds);
4769 }
4770 
4771 #if QT_CONFIG(timezone)
4772 /*!
4773     \since 5.2
4774     \deprecated
4775 
4776     Returns a datetime whose date and time are the number of \a seconds
4777     that have passed since 1970-01-01T00:00:00, Coordinated Universal
4778     Time (Qt::UTC) and with the given \a timeZone.
4779 
4780     \note This function is deprecated. Please use fromSecsSinceEpoch() in new
4781     code.
4782 
4783     \sa toTime_t(), setTime_t()
4784 */
4785 QDateTime QDateTime::fromTime_t(uint seconds, const QTimeZone &timeZone)
4786 {
4787     return fromMSecsSinceEpoch((qint64)seconds * 1000, timeZone);
4788 }
4789 #endif
4790 #endif // QT_DEPRECATED_SINCE(5, 8)
4791 
4792 /*!
4793   \since 4.7
4794 
4795   Returns a datetime whose date and time are the number of milliseconds, \a msecs,
4796   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4797   Time (Qt::UTC), and converted to Qt::LocalTime.  On systems that do not
4798   support time zones, the time will be set as if local time were Qt::UTC.
4799 
4800   Note that there are possible values for \a msecs that lie outside the valid
4801   range of QDateTime, both negative and positive. The behavior of this
4802   function is undefined for those values.
4803 
4804   \sa toMSecsSinceEpoch(), setMSecsSinceEpoch()
4805 */
4806 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs)
4807 {
4808     return fromMSecsSinceEpoch(msecs, Qt::LocalTime);
4809 }
4810 
4811 /*!
4812   \since 5.2
4813 
4814   Returns a datetime whose date and time are the number of milliseconds \a msecs
4815   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4816   Time (Qt::UTC) and converted to the given \a spec.
4817 
4818   Note that there are possible values for \a msecs that lie outside the valid
4819   range of QDateTime, both negative and positive. The behavior of this
4820   function is undefined for those values.
4821 
4822   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4823   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4824   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4825 
4826   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4827   i.e. the current system time zone.
4828 
4829   \sa toMSecsSinceEpoch(), setMSecsSinceEpoch()
4830 */
4831 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, Qt::TimeSpec spec, int offsetSeconds)
4832 {
4833     QDateTime dt;
4834     QT_PREPEND_NAMESPACE(setTimeSpec(dt.d, spec, offsetSeconds));
4835     dt.setMSecsSinceEpoch(msecs);
4836     return dt;
4837 }
4838 
4839 /*!
4840   \since 5.8
4841 
4842   Returns a datetime whose date and time are the number of seconds \a secs
4843   that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4844   Time (Qt::UTC) and converted to the given \a spec.
4845 
4846   Note that there are possible values for \a secs that lie outside the valid
4847   range of QDateTime, both negative and positive. The behavior of this
4848   function is undefined for those values.
4849 
4850   If the \a spec is not Qt::OffsetFromUTC then the \a offsetSeconds will be
4851   ignored.  If the \a spec is Qt::OffsetFromUTC and the \a offsetSeconds is 0
4852   then the spec will be set to Qt::UTC, i.e. an offset of 0 seconds.
4853 
4854   If \a spec is Qt::TimeZone then the spec will be set to Qt::LocalTime,
4855   i.e. the current system time zone.
4856 
4857   \sa toSecsSinceEpoch(), setSecsSinceEpoch()
4858 */
4859 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, Qt::TimeSpec spec, int offsetSeconds)
4860 {
4861     return fromMSecsSinceEpoch(secs * 1000, spec, offsetSeconds);
4862 }
4863 
4864 #if QT_CONFIG(timezone)
4865 /*!
4866     \since 5.2
4867 
4868     Returns a datetime whose date and time are the number of milliseconds \a msecs
4869     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4870     Time (Qt::UTC) and with the given \a timeZone.
4871 
4872     \sa fromSecsSinceEpoch()
4873 */
4874 QDateTime QDateTime::fromMSecsSinceEpoch(qint64 msecs, const QTimeZone &timeZone)
4875 {
4876     QDateTime dt;
4877     dt.setTimeZone(timeZone);
4878     dt.setMSecsSinceEpoch(msecs);
4879     return dt;
4880 }
4881 
4882 /*!
4883     \since 5.8
4884 
4885     Returns a datetime whose date and time are the number of seconds \a secs
4886     that have passed since 1970-01-01T00:00:00.000, Coordinated Universal
4887     Time (Qt::UTC) and with the given \a timeZone.
4888 
4889     \sa fromMSecsSinceEpoch()
4890 */
4891 QDateTime QDateTime::fromSecsSinceEpoch(qint64 secs, const QTimeZone &timeZone)
4892 {
4893     return fromMSecsSinceEpoch(secs * 1000, timeZone);
4894 }
4895 #endif
4896 
4897 #if QT_DEPRECATED_SINCE(5, 2)
4898 /*!
4899     \since 4.4
4900     \internal
4901     \obsolete
4902 
4903     This method was added in 4.4 but never documented as public. It was replaced
4904     in 5.2 with public method setOffsetFromUtc() for consistency with QTimeZone.
4905 
4906     This method should never be made public.
4907 
4908     \sa setOffsetFromUtc()
4909  */
4910 void QDateTime::setUtcOffset(int seconds)
4911 {
4912     setOffsetFromUtc(seconds);
4913 }
4914 
4915 /*!
4916     \since 4.4
4917     \internal
4918     \obsolete
4919 
4920     This method was added in 4.4 but never documented as public. It was replaced
4921     in 5.1 with public method offsetFromUTC() for consistency with QTimeZone.
4922 
4923     This method should never be made public.
4924 
4925     \sa offsetFromUTC()
4926 */
4927 int QDateTime::utcOffset() const
4928 {
4929     return offsetFromUtc();
4930 }
4931 #endif // QT_DEPRECATED_SINCE
4932 
4933 #ifndef QT_NO_DATESTRING
4934 
4935 /*!
4936     \fn QDateTime QDateTime::fromString(const QString &string, Qt::DateFormat format)
4937 
4938     Returns the QDateTime represented by the \a string, using the
4939     \a format given, or an invalid datetime if this is not possible.
4940 
4941     Note for Qt::TextDate: It is recommended that you use the
4942     English short month names (e.g. "Jan"). Although localized month
4943     names can also be used, they depend on the user's locale settings.
4944 
4945     \sa toString(), QLocale::toDateTime()
4946 */
4947 QDateTime QDateTime::fromString(const QString& string, Qt::DateFormat format)
4948 {
4949     if (string.isEmpty())
4950         return QDateTime();
4951 
4952     switch (format) {
4953     case Qt::SystemLocaleDate:
4954     case Qt::SystemLocaleShortDate:
4955         return QLocale::system().toDateTime(string, QLocale::ShortFormat);
4956     case Qt::SystemLocaleLongDate:
4957         return QLocale::system().toDateTime(string, QLocale::LongFormat);
4958     case Qt::LocaleDate:
4959     case Qt::DefaultLocaleShortDate:
4960         return QLocale().toDateTime(string, QLocale::ShortFormat);
4961     case Qt::DefaultLocaleLongDate:
4962         return QLocale().toDateTime(string, QLocale::LongFormat);
4963     case Qt::RFC2822Date: {
4964         const ParsedRfcDateTime rfc = rfcDateImpl(string);
4965 
4966         if (!rfc.date.isValid() || !rfc.time.isValid())
4967             return QDateTime();
4968 
4969         QDateTime dateTime(rfc.date, rfc.time, Qt::UTC);
4970         dateTime.setOffsetFromUtc(rfc.utcOffset);
4971         return dateTime;
4972     }
4973     case Qt::ISODate:
4974     case Qt::ISODateWithMs: {
4975         const int size = string.size();
4976         if (size < 10)
4977             return QDateTime();
4978 
4979         QStringRef isoString(&string);
4980         Qt::TimeSpec spec = Qt::LocalTime;
4981 
4982         QDate date = QDate::fromString(string.left(10), Qt::ISODate);
4983         if (!date.isValid())
4984             return QDateTime();
4985         if (size == 10)
4986             return QDateTime(date);
4987 
4988         isoString = isoString.right(isoString.length() - 11);
4989         int offset = 0;
4990         // Check end of string for Time Zone definition, either Z for UTC or [+-]HH:mm for Offset
4991         if (isoString.endsWith(QLatin1Char('Z'))) {
4992             spec = Qt::UTC;
4993             isoString = isoString.left(isoString.size() - 1);
4994         } else {
4995             // the loop below is faster but functionally equal to:
4996             // const int signIndex = isoString.indexOf(QRegExp(QStringLiteral("[+-]")));
4997             int signIndex = isoString.size() - 1;
4998             bool found = false;
4999             {
5000                 const QChar plus = QLatin1Char('+');
5001                 const QChar minus = QLatin1Char('-');
5002                 do {
5003                     QChar character(isoString.at(signIndex));
5004                     found = character == plus || character == minus;
5005                 } while (--signIndex >= 0 && !found);
5006                 ++signIndex;
5007             }
5008 
5009             if (found) {
5010                 bool ok;
5011                 offset = fromOffsetString(isoString.mid(signIndex), &ok);
5012                 if (!ok)
5013                     return QDateTime();
5014                 isoString = isoString.left(signIndex);
5015                 spec = Qt::OffsetFromUTC;
5016             }
5017         }
5018 
5019         // Might be end of day (24:00, including variants), which QTime considers invalid.
5020         // ISO 8601 (section 4.2.3) says that 24:00 is equivalent to 00:00 the next day.
5021         bool isMidnight24 = false;
5022         QTime time = fromIsoTimeString(isoString, format, &isMidnight24);
5023         if (!time.isValid())
5024             return QDateTime();
5025         if (isMidnight24)
5026             date = date.addDays(1);
5027         return QDateTime(date, time, spec, offset);
5028     }
5029 #if !defined(QT_NO_TEXTDATE)
5030     case Qt::TextDate: {
5031         QVector<QStringRef> parts = string.splitRef(QLatin1Char(' '), QString::SkipEmptyParts);
5032 
5033         if ((parts.count() < 5) || (parts.count() > 6))
5034             return QDateTime();
5035 
5036         // Accept "Sun Dec 1 13:02:00 1974" and "Sun 1. Dec 13:02:00 1974"
5037         int month = 0;
5038         int day = 0;
5039         bool ok = false;
5040 
5041         // First try month then day
5042         month = fromShortMonthName(parts.at(1));
5043         if (month)
5044             day = parts.at(2).toInt();
5045 
5046         // If failed try day then month
5047         if (!month || !day) {
5048             month = fromShortMonthName(parts.at(2));
5049             if (month) {
5050                 QStringRef dayStr = parts.at(1);
5051                 if (dayStr.endsWith(QLatin1Char('.'))) {
5052                     dayStr = dayStr.left(dayStr.size() - 1);
5053                     day = dayStr.toInt();
5054                 }
5055             }
5056         }
5057 
5058         // If both failed, give up
5059         if (!month || !day)
5060             return QDateTime();
5061 
5062         // Year can be before or after time, "Sun Dec 1 1974 13:02:00" or "Sun Dec 1 13:02:00 1974"
5063         // Guess which by looking for ':' in the time
5064         int year = 0;
5065         int yearPart = 0;
5066         int timePart = 0;
5067         if (parts.at(3).contains(QLatin1Char(':'))) {
5068             yearPart = 4;
5069             timePart = 3;
5070         } else if (parts.at(4).contains(QLatin1Char(':'))) {
5071             yearPart = 3;
5072             timePart = 4;
5073         } else {
5074             return QDateTime();
5075         }
5076 
5077         year = parts.at(yearPart).toInt(&ok);
5078         if (!ok)
5079             return QDateTime();
5080 
5081         QDate date(year, month, day);
5082         if (!date.isValid())
5083             return QDateTime();
5084 
5085         QVector<QStringRef> timeParts = parts.at(timePart).split(QLatin1Char(':'));
5086         if (timeParts.count() < 2 || timeParts.count() > 3)
5087             return QDateTime();
5088 
5089         int hour = timeParts.at(0).toInt(&ok);
5090         if (!ok)
5091             return QDateTime();
5092 
5093         int minute = timeParts.at(1).toInt(&ok);
5094         if (!ok)
5095             return QDateTime();
5096 
5097         int second = 0;
5098         int millisecond = 0;
5099         if (timeParts.count() > 2) {
5100             const QVector<QStringRef> secondParts = timeParts.at(2).split(QLatin1Char('.'));
5101             if (secondParts.size() > 2) {
5102                 return QDateTime();
5103             }
5104 
5105             second = secondParts.first().toInt(&ok);
5106             if (!ok) {
5107                 return QDateTime();
5108             }
5109 
5110             if (secondParts.size() > 1) {
5111                 millisecond = secondParts.last().toInt(&ok);
5112                 if (!ok) {
5113                     return QDateTime();
5114                 }
5115             }
5116         }
5117 
5118         QTime time(hour, minute, second, millisecond);
5119         if (!time.isValid())
5120             return QDateTime();
5121 
5122         if (parts.count() == 5)
5123             return QDateTime(date, time, Qt::LocalTime);
5124 
5125         QStringRef tz = parts.at(5);
5126         if (!tz.startsWith(QLatin1String("GMT"), Qt::CaseInsensitive))
5127             return QDateTime();
5128         tz = tz.mid(3);
5129         if (!tz.isEmpty()) {
5130             int offset = fromOffsetString(tz, &ok);
5131             if (!ok)
5132                 return QDateTime();
5133             return QDateTime(date, time, Qt::OffsetFromUTC, offset);
5134         } else {
5135             return QDateTime(date, time, Qt::UTC);
5136         }
5137     }
5138 #endif //QT_NO_TEXTDATE
5139     }
5140 
5141     return QDateTime();
5142 }
5143 
5144 /*!
5145     \fn QDateTime::fromString(const QString &string, const QString &format)
5146 
5147     Returns the QDateTime represented by the \a string, using the \a
5148     format given, or an invalid datetime if the string cannot be parsed.
5149 
5150     These expressions may be used for the date part of the format string:
5151 
5152     \table
5153     \header \li Expression \li Output
5154     \row \li d \li the day as number without a leading zero (1 to 31)
5155     \row \li dd \li the day as number with a leading zero (01 to 31)
5156     \row \li ddd
5157             \li the abbreviated localized day name (e.g. 'Mon' to 'Sun').
5158             Uses QDate::shortDayName().
5159     \row \li dddd
5160             \li the long localized day name (e.g. 'Monday' to 'Sunday').
5161             Uses QDate::longDayName().
5162     \row \li M \li the month as number without a leading zero (1-12)
5163     \row \li MM \li the month as number with a leading zero (01-12)
5164     \row \li MMM
5165             \li the abbreviated localized month name (e.g. 'Jan' to 'Dec').
5166             Uses QDate::shortMonthName().
5167     \row \li MMMM
5168             \li the long localized month name (e.g. 'January' to 'December').
5169             Uses QDate::longMonthName().
5170     \row \li yy \li the year as two digit number (00-99)
5171     \row \li yyyy \li the year as four digit number
5172     \endtable
5173 
5174     \note Unlike the other version of this function, day and month names must
5175     be given in the user's local language. It is only possible to use the English
5176     names if the user's language is English.
5177 
5178     These expressions may be used for the time part of the format string:
5179 
5180     \table
5181     \header \li Expression \li Output
5182     \row \li h
5183             \li the hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
5184     \row \li hh
5185             \li the hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
5186     \row \li H
5187             \li the hour without a leading zero (0 to 23, even with AM/PM display)
5188     \row \li HH
5189             \li the hour with a leading zero (00 to 23, even with AM/PM display)
5190     \row \li m \li the minute without a leading zero (0 to 59)
5191     \row \li mm \li the minute with a leading zero (00 to 59)
5192     \row \li s \li the second without a leading zero (0 to 59)
5193     \row \li ss \li the second with a leading zero (00 to 59)
5194     \row \li z \li the milliseconds without leading zeroes (0 to 999)
5195     \row \li zzz \li the milliseconds with leading zeroes (000 to 999)
5196     \row \li AP or A
5197          \li interpret as an AM/PM time. \e AP must be either "AM" or "PM".
5198     \row \li ap or a
5199          \li Interpret as an AM/PM time. \e ap must be either "am" or "pm".
5200     \endtable
5201 
5202     All other input characters will be treated as text. Any sequence
5203     of characters that are enclosed in single quotes will also be
5204     treated as text and not be used as an expression.
5205 
5206     \snippet code/src_corelib_tools_qdatetime.cpp 12
5207 
5208     If the format is not satisfied, an invalid QDateTime is returned.
5209     The expressions that don't have leading zeroes (d, M, h, m, s, z) will be
5210     greedy. This means that they will use two digits even if this will
5211     put them outside the range and/or leave too few digits for other
5212     sections.
5213 
5214     \snippet code/src_corelib_tools_qdatetime.cpp 13
5215 
5216     This could have meant 1 January 00:30.00 but the M will grab
5217     two digits.
5218 
5219     Incorrectly specified fields of the \a string will cause an invalid
5220     QDateTime to be returned. For example, consider the following code,
5221     where the two digit year 12 is read as 1912 (see the table below for all
5222     field defaults); the resulting datetime is invalid because 23 April 1912
5223     was a Tuesday, not a Monday:
5224 
5225     \snippet code/src_corelib_tools_qdatetime.cpp 20
5226 
5227     The correct code is:
5228 
5229     \snippet code/src_corelib_tools_qdatetime.cpp 21
5230 
5231     For any field that is not represented in the format, the following
5232     defaults are used:
5233 
5234     \table
5235     \header \li Field  \li Default value
5236     \row    \li Year   \li 1900
5237     \row    \li Month  \li 1 (January)
5238     \row    \li Day    \li 1
5239     \row    \li Hour   \li 0
5240     \row    \li Minute \li 0
5241     \row    \li Second \li 0
5242     \endtable
5243 
5244     For example:
5245 
5246     \snippet code/src_corelib_tools_qdatetime.cpp 14
5247 
5248     \sa toString(), QDate::fromString(), QTime::fromString(),
5249     QLocale::toDateTime()
5250 */
5251 
5252 QDateTime QDateTime::fromString(const QString &string, const QString &format)
5253 {
5254 #if QT_CONFIG(timezone)
5255     QTime time;
5256     QDate date;
5257 
5258     QDateTimeParser dt(QVariant::DateTime, QDateTimeParser::FromString);
5259     // dt.setDefaultLocale(QLocale::c()); ### Qt 6
5260     if (dt.parseFormat(format) && dt.fromString(string, &date, &time))
5261         return QDateTime(date, time);
5262 #else
5263     Q_UNUSED(string);
5264     Q_UNUSED(format);
5265 #endif
5266     return QDateTime();
5267 }
5268 
5269 #endif // QT_NO_DATESTRING
5270 /*!
5271     \fn QDateTime QDateTime::toLocalTime() const
5272 
5273     Returns a datetime containing the date and time information in
5274     this datetime, but specified using the Qt::LocalTime definition.
5275 
5276     Example:
5277 
5278     \snippet code/src_corelib_tools_qdatetime.cpp 17
5279 
5280     \sa toTimeSpec()
5281 */
5282 
5283 /*!
5284     \fn QDateTime QDateTime::toUTC() const
5285 
5286     Returns a datetime containing the date and time information in
5287     this datetime, but specified using the Qt::UTC definition.
5288 
5289     Example:
5290 
5291     \snippet code/src_corelib_tools_qdatetime.cpp 18
5292 
5293     \sa toTimeSpec()
5294 */
5295 
5296 /*****************************************************************************
5297   Date/time stream functions
5298  *****************************************************************************/
5299 
5300 #ifndef QT_NO_DATASTREAM
5301 /*!
5302     \relates QDate
5303 
5304     Writes the \a date to stream \a out.
5305 
5306     \sa {Serializing Qt Data Types}
5307 */
5308 
5309 QDataStream &operator<<(QDataStream &out, const QDate &date)
5310 {
5311     if (out.version() < QDataStream::Qt_5_0)
5312         return out << quint32(date.jd);
5313     else
5314         return out << qint64(date.jd);
5315 }
5316 
5317 /*!
5318     \relates QDate
5319 
5320     Reads a date from stream \a in into the \a date.
5321 
5322     \sa {Serializing Qt Data Types}
5323 */
5324 
5325 QDataStream &operator>>(QDataStream &in, QDate &date)
5326 {
5327     if (in.version() < QDataStream::Qt_5_0) {
5328         quint32 jd;
5329         in >> jd;
5330         // Older versions consider 0 an invalid jd.
5331         date.jd = (jd != 0 ? jd : QDate::nullJd());
5332     } else {
5333         qint64 jd;
5334         in >> jd;
5335         date.jd = jd;
5336     }
5337 
5338     return in;
5339 }
5340 
5341 /*!
5342     \relates QTime
5343 
5344     Writes \a time to stream \a out.
5345 
5346     \sa {Serializing Qt Data Types}
5347 */
5348 
5349 QDataStream &operator<<(QDataStream &out, const QTime &time)
5350 {
5351     if (out.version() >= QDataStream::Qt_4_0) {
5352         return out << quint32(time.mds);
5353     } else {
5354         // Qt3 had no support for reading -1, QTime() was valid and serialized as 0
5355         return out << quint32(time.isNull() ? 0 : time.mds);
5356     }
5357 }
5358 
5359 /*!
5360     \relates QTime
5361 
5362     Reads a time from stream \a in into the given \a time.
5363 
5364     \sa {Serializing Qt Data Types}
5365 */
5366 
5367 QDataStream &operator>>(QDataStream &in, QTime &time)
5368 {
5369     quint32 ds;
5370     in >> ds;
5371     if (in.version() >= QDataStream::Qt_4_0) {
5372         time.mds = int(ds);
5373     } else {
5374         // Qt3 would write 0 for a null time
5375         time.mds = (ds == 0) ? QTime::NullTime : int(ds);
5376     }
5377     return in;
5378 }
5379 
5380 /*!
5381     \relates QDateTime
5382 
5383     Writes \a dateTime to the \a out stream.
5384 
5385     \sa {Serializing Qt Data Types}
5386 */
5387 QDataStream &operator<<(QDataStream &out, const QDateTime &dateTime)
5388 {
5389     QPair<QDate, QTime> dateAndTime;
5390 
5391     if (out.version() >= QDataStream::Qt_5_2) {
5392 
5393         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5394         dateAndTime = getDateTime(dateTime.d);
5395         out << dateAndTime << qint8(dateTime.timeSpec());
5396         if (dateTime.timeSpec() == Qt::OffsetFromUTC)
5397             out << qint32(dateTime.offsetFromUtc());
5398 #if QT_CONFIG(timezone)
5399         else if (dateTime.timeSpec() == Qt::TimeZone)
5400             out << dateTime.timeZone();
5401 #endif // timezone
5402 
5403     } else if (out.version() == QDataStream::Qt_5_0) {
5404 
5405         // In Qt 5.0 we incorrectly serialised all datetimes as UTC.
5406         // This approach is wrong and should not be used again; it breaks
5407         // the guarantee that a deserialised local datetime is the same time
5408         // of day, regardless of which timezone it was serialised in.
5409         dateAndTime = getDateTime((dateTime.isValid() ? dateTime.toUTC() : dateTime).d);
5410         out << dateAndTime << qint8(dateTime.timeSpec());
5411 
5412     } else if (out.version() >= QDataStream::Qt_4_0) {
5413 
5414         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5415         dateAndTime = getDateTime(dateTime.d);
5416         out << dateAndTime;
5417         switch (dateTime.timeSpec()) {
5418         case Qt::UTC:
5419             out << (qint8)QDateTimePrivate::UTC;
5420             break;
5421         case Qt::OffsetFromUTC:
5422             out << (qint8)QDateTimePrivate::OffsetFromUTC;
5423             break;
5424         case Qt::TimeZone:
5425             out << (qint8)QDateTimePrivate::TimeZone;
5426             break;
5427         case Qt::LocalTime:
5428             out << (qint8)QDateTimePrivate::LocalUnknown;
5429             break;
5430         }
5431 
5432     } else { // version < QDataStream::Qt_4_0
5433 
5434         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5435         dateAndTime = getDateTime(dateTime.d);
5436         out << dateAndTime;
5437 
5438     }
5439 
5440     return out;
5441 }
5442 
5443 /*!
5444     \relates QDateTime
5445 
5446     Reads a datetime from the stream \a in into \a dateTime.
5447 
5448     \sa {Serializing Qt Data Types}
5449 */
5450 
5451 QDataStream &operator>>(QDataStream &in, QDateTime &dateTime)
5452 {
5453     QDate dt;
5454     QTime tm;
5455     qint8 ts = 0;
5456     Qt::TimeSpec spec = Qt::LocalTime;
5457     qint32 offset = 0;
5458 #if QT_CONFIG(timezone)
5459     QTimeZone tz;
5460 #endif // timezone
5461 
5462     if (in.version() >= QDataStream::Qt_5_2) {
5463 
5464         // In 5.2 we switched to using Qt::TimeSpec and added offset support
5465         in >> dt >> tm >> ts;
5466         spec = static_cast<Qt::TimeSpec>(ts);
5467         if (spec == Qt::OffsetFromUTC) {
5468             in >> offset;
5469             dateTime = QDateTime(dt, tm, spec, offset);
5470 #if QT_CONFIG(timezone)
5471         } else if (spec == Qt::TimeZone) {
5472             in >> tz;
5473             dateTime = QDateTime(dt, tm, tz);
5474 #endif // timezone
5475         } else {
5476             dateTime = QDateTime(dt, tm, spec);
5477         }
5478 
5479     } else if (in.version() == QDataStream::Qt_5_0) {
5480 
5481         // In Qt 5.0 we incorrectly serialised all datetimes as UTC
5482         in >> dt >> tm >> ts;
5483         spec = static_cast<Qt::TimeSpec>(ts);
5484         dateTime = QDateTime(dt, tm, Qt::UTC);
5485         dateTime = dateTime.toTimeSpec(spec);
5486 
5487     } else if (in.version() >= QDataStream::Qt_4_0) {
5488 
5489         // From 4.0 to 5.1 (except 5.0) we used QDateTimePrivate::Spec
5490         in >> dt >> tm >> ts;
5491         switch ((QDateTimePrivate::Spec)ts) {
5492         case QDateTimePrivate::UTC:
5493             spec = Qt::UTC;
5494             break;
5495         case QDateTimePrivate::OffsetFromUTC:
5496             spec = Qt::OffsetFromUTC;
5497             break;
5498         case QDateTimePrivate::TimeZone:
5499             spec = Qt::TimeZone;
5500 #if QT_CONFIG(timezone)
5501             // FIXME: need to use a different constructor !
5502 #endif
5503             break;
5504         case QDateTimePrivate::LocalUnknown:
5505         case QDateTimePrivate::LocalStandard:
5506         case QDateTimePrivate::LocalDST:
5507             spec = Qt::LocalTime;
5508             break;
5509         }
5510         dateTime = QDateTime(dt, tm, spec, offset);
5511 
5512     } else { // version < QDataStream::Qt_4_0
5513 
5514         // Before 4.0 there was no TimeSpec, only Qt::LocalTime was supported
5515         in >> dt >> tm;
5516         dateTime = QDateTime(dt, tm, spec, offset);
5517 
5518     }
5519 
5520     return in;
5521 }
5522 #endif // QT_NO_DATASTREAM
5523 
5524 /*****************************************************************************
5525   Date / Time Debug Streams
5526 *****************************************************************************/
5527 
5528 #if !defined(QT_NO_DEBUG_STREAM) && !defined(QT_NO_DATESTRING)
5529 QDebug operator<<(QDebug dbg, const QDate &date)
5530 {
5531     QDebugStateSaver saver(dbg);
5532     dbg.nospace() << "QDate(" << date.toString(Qt::ISODate) << ')';
5533     return dbg;
5534 }
5535 
5536 QDebug operator<<(QDebug dbg, const QTime &time)
5537 {
5538     QDebugStateSaver saver(dbg);
5539     dbg.nospace() << "QTime(" << time.toString(QStringLiteral("HH:mm:ss.zzz")) << ')';
5540     return dbg;
5541 }
5542 
5543 QDebug operator<<(QDebug dbg, const QDateTime &date)
5544 {
5545     QDebugStateSaver saver(dbg);
5546     const Qt::TimeSpec ts = date.timeSpec();
5547     dbg.nospace() << "QDateTime(";
5548     dbg.noquote() << date.toString(QStringLiteral("yyyy-MM-dd HH:mm:ss.zzz t"))
5549                   << ' ' << ts;
5550     switch (ts) {
5551     case Qt::UTC:
5552         break;
5553     case Qt::OffsetFromUTC:
5554         dbg << ' ' << date.offsetFromUtc() << 's';
5555         break;
5556     case Qt::TimeZone:
5557 #if QT_CONFIG(timezone)
5558         dbg << ' ' << date.timeZone().id();
5559 #endif // timezone
5560         break;
5561     case Qt::LocalTime:
5562         break;
5563     }
5564     return dbg << ')';
5565 }
5566 #endif
5567 
5568 /*! \fn uint qHash(const QDateTime &key, uint seed = 0)
5569     \relates QHash
5570     \since 5.0
5571 
5572     Returns the hash value for the \a key, using \a seed to seed the calculation.
5573 */
5574 uint qHash(const QDateTime &key, uint seed)
5575 {
5576     // Use to toMSecsSinceEpoch instead of individual qHash functions for
5577     // QDate/QTime/spec/offset because QDateTime::operator== converts both arguments
5578     // to the same timezone. If we don't, qHash would return different hashes for
5579     // two QDateTimes that are equivalent once converted to the same timezone.
5580     return qHash(key.toMSecsSinceEpoch(), seed);
5581 }
5582 
5583 /*! \fn uint qHash(const QDate &key, uint seed = 0)
5584     \relates QHash
5585     \since 5.0
5586 
5587     Returns the hash value for the \a key, using \a seed to seed the calculation.
5588 */
5589 uint qHash(const QDate &key, uint seed) Q_DECL_NOTHROW
5590 {
5591     return qHash(key.toJulianDay(), seed);
5592 }
5593 
5594 /*! \fn uint qHash(const QTime &key, uint seed = 0)
5595     \relates QHash
5596     \since 5.0
5597 
5598     Returns the hash value for the \a key, using \a seed to seed the calculation.
5599 */
5600 uint qHash(const QTime &key, uint seed) Q_DECL_NOTHROW
5601 {
5602     return qHash(key.msecsSinceStartOfDay(), seed);
5603 }
5604 
5605 QT_END_NAMESPACE
