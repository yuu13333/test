I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
4 ** Contact: http://www.qt-project.org/legal
5 **
6 ** This file is part of the QtCore module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and Digia.  For licensing terms and
14 ** conditions see http://qt.digia.com/licensing.  For further information
15 ** use the contact form at http://qt.digia.com/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 2.1 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL included in the
21 ** packaging of this file.  Please review the following information to
22 ** ensure the GNU Lesser General Public License version 2.1 requirements
23 ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
24 **
25 ** In addition, as a special exception, Digia gives you certain additional
26 ** rights.  These rights are described in the Digia Qt LGPL Exception
27 ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
28 **
29 ** GNU General Public License Usage
30 ** Alternatively, this file may be used under the terms of the GNU
31 ** General Public License version 3.0 as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL included in the
33 ** packaging of this file.  Please review the following information to
34 ** ensure the GNU General Public License version 3.0 requirements will be
35 ** met: http://www.gnu.org/copyleft/gpl.html.
36 **
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qcoreapplication.h"
43 #include "qcoreapplication_p.h"
44 
45 #include "qabstracteventdispatcher.h"
46 #include "qcoreevent.h"
47 #include "qeventloop.h"
48 #include "qcorecmdlineargs_p.h"
49 #include <qdatastream.h>
50 #include <qdebug.h>
51 #include <qdir.h>
52 #include <qfile.h>
53 #include <qfileinfo.h>
54 #include <qhash.h>
55 #include <private/qprocess_p.h>
56 #include <qstandardpaths.h>
57 #include <qtextcodec.h>
58 #include <qthread.h>
59 #include <qthreadpool.h>
60 #include <private/qmutexpool_p.h>
61 #include <qthreadstorage.h>
62 #include <private/qthread_p.h>
63 #include <qelapsedtimer.h>
64 #include <qlibraryinfo.h>
65 #include <qvarlengtharray.h>
66 #include <private/qfactoryloader_p.h>
67 #include <private/qfunctions_p.h>
68 #include <private/qlocale_p.h>
69 
70 #if defined(Q_OS_UNIX)
71 #  if defined(Q_OS_BLACKBERRY)
72 #    include "qeventdispatcher_blackberry_p.h"
73 #    include <process.h>
74 #    include <unistd.h>
75 #  else
76 #    if !defined(QT_NO_GLIB)
77 #      include "qeventdispatcher_glib_p.h"
78 #    endif
79 #    include "qeventdispatcher_unix_p.h"
80 #  endif
81 #endif
82 
83 #ifdef Q_OS_WIN
84 #  include "qeventdispatcher_win_p.h"
85 #endif
86 
87 #ifdef Q_OS_MAC
88 #  include "qcore_mac_p.h"
89 #endif
90 
91 #include <stdlib.h>
92 
93 #ifdef Q_OS_UNIX
94 #  include <locale.h>
95 #endif
96 
97 #ifdef Q_OS_VXWORKS
98 #  include <taskLib.h>
99 #endif
100 
101 QT_BEGIN_NAMESPACE
102 
103 class QMutexUnlocker
104 {
105 public:
106     inline explicit QMutexUnlocker(QMutex *m)
107         : mtx(m)
108     { }
109     inline ~QMutexUnlocker() { unlock(); }
110     inline void unlock() { if (mtx) mtx->unlock(); mtx = 0; }
111 
112 private:
113     Q_DISABLE_COPY(QMutexUnlocker)
114 
115     QMutex *mtx;
116 };
117 
118 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
119 extern QString qAppFileName();
120 #endif
121 
122 #if QT_VERSION >= 0x060000
123 # error "Bump QCoreApplicatoinPrivate::app_compile_version to 0x060000"
124 #endif
125 int QCoreApplicationPrivate::app_compile_version = 0x050000; //we don't know exactly, but it's at least 5.0.0
126 
127 #if !defined(Q_OS_WIN)
128 #ifdef Q_OS_MAC
129 QString QCoreApplicationPrivate::macMenuBarName()
130 {
131     QString bundleName;
132     CFTypeRef string = CFBundleGetValueForInfoDictionaryKey(CFBundleGetMainBundle(), CFSTR("CFBundleName"));
133     if (string)
134         bundleName = QCFString::toQString(static_cast<CFStringRef>(string));
135     return bundleName;
136 }
137 #endif
138 QString QCoreApplicationPrivate::appName() const
139 {
140     static QString applName;
141 #ifdef Q_OS_MAC
142     applName = macMenuBarName();
143 #endif
144     if (applName.isEmpty() && argv[0]) {
145         char *p = strrchr(argv[0], '/');
146         applName = QString::fromLocal8Bit(p ? p + 1 : argv[0]);
147     }
148     return applName;
149 }
150 #endif
151 
152 bool QCoreApplicationPrivate::checkInstance(const char *function)
153 {
154     bool b = (QCoreApplication::self != 0);
155     if (!b)
156         qWarning("QApplication::%s: Please instantiate the QApplication object first", function);
157     return b;
158 }
159 
160 void QCoreApplicationPrivate::processCommandLineArguments()
161 {
162     int j = argc ? 1 : 0;
163     for (int i = 1; i < argc; ++i) {
164         if (argv[i] && *argv[i] != '-') {
165             argv[j++] = argv[i];
166             continue;
167         }
168         QByteArray arg = argv[i];
169         if (arg.startsWith("-qmljsdebugger=")) {
170             qmljs_debug_arguments = QString::fromLocal8Bit(arg.right(arg.length() - 15));
171         } else if (arg == "-qmljsdebugger" && i < argc - 1) {
172             ++i;
173             qmljs_debug_arguments = QString::fromLocal8Bit(argv[i]);
174         } else {
175             argv[j++] = argv[i];
176         }
177     }
178 
179     if (j < argc) {
180         argv[j] = 0;
181         argc = j;
182     }
183 }
184 
185 // Support for introspection
186 
187 QSignalSpyCallbackSet Q_CORE_EXPORT qt_signal_spy_callback_set = { 0, 0, 0, 0 };
188 
189 void qt_register_signal_spy_callbacks(const QSignalSpyCallbackSet &callback_set)
190 {
191     qt_signal_spy_callback_set = callback_set;
192 }
193 
194 extern "C" void Q_CORE_EXPORT qt_startup_hook()
195 {
196 }
197 
198 typedef QList<QtStartUpFunction> QStartUpFuncList;
199 Q_GLOBAL_STATIC(QStartUpFuncList, preRList)
200 typedef QList<QtCleanUpFunction> QVFuncList;
201 Q_GLOBAL_STATIC(QVFuncList, postRList)
202 
203 void qAddPreRoutine(QtStartUpFunction p)
204 {
205     QStartUpFuncList *list = preRList();
206     if (!list)
207         return;
208 #ifndef QT_NO_THREAD
209     QMutexLocker locker(QMutexPool::globalInstanceGet(list));
210 #endif
211     list->prepend(p);
212 }
213 
214 void qAddPostRoutine(QtCleanUpFunction p)
215 {
216     QVFuncList *list = postRList();
217     if (!list)
218         return;
219     list->prepend(p);
220 }
221 
222 void qRemovePostRoutine(QtCleanUpFunction p)
223 {
224     QVFuncList *list = postRList();
225     if (!list)
226         return;
227     list->removeAll(p);
228 }
229 
230 void qt_call_pre_routines()
231 {
232     QStartUpFuncList *list = preRList();
233     if (!list)
234         return;
235     while (!list->isEmpty())
236         (list->takeFirst())();
237 }
238 
239 void Q_CORE_EXPORT qt_call_post_routines()
240 {
241     QVFuncList *list = 0;
242     QT_TRY {
243         list = postRList();
244     } QT_CATCH(const std::bad_alloc &) {
245         // ignore - if we can't allocate a post routine list,
246         // there's a high probability that there's no post
247         // routine to be executed :)
248     }
249     if (!list)
250         return;
251     while (!list->isEmpty())
252         (list->takeFirst())();
253 }
254 
255 
256 // app starting up if false
257 bool QCoreApplicationPrivate::is_app_running = false;
258  // app closing down if true
259 bool QCoreApplicationPrivate::is_app_closing = false;
260 // initialized in qcoreapplication and in qtextstream autotest when setlocale is called.
261 static bool qt_locale_initialized = false;
262 
263 Q_CORE_EXPORT uint qGlobalPostedEventsCount()
264 {
265     QThreadData *currentThreadData = QThreadData::current();
266     return currentThreadData->postEventList.size() - currentThreadData->postEventList.startOffset;
267 }
268 
269 QCoreApplication *QCoreApplication::self = 0;
270 QAbstractEventDispatcher *QCoreApplicationPrivate::eventDispatcher = 0;
271 uint QCoreApplicationPrivate::attribs = (1 << Qt::AA_SynthesizeMouseForUnhandledTouchEvents);
272 
273 #ifdef Q_OS_UNIX
274 Qt::HANDLE qt_application_thread_id = 0;
275 #endif
276 
277 struct QCoreApplicationData {
278     QCoreApplicationData() {
279 #ifndef QT_NO_LIBRARY
280         app_libpaths = 0;
281 #endif
282     }
283     ~QCoreApplicationData() {
284 #ifndef QT_NO_LIBRARY
285         delete app_libpaths;
286 #endif
287 
288         // cleanup the QAdoptedThread created for the main() thread
289        if (QCoreApplicationPrivate::theMainThread) {
290            QThreadData *data = QThreadData::get2(QCoreApplicationPrivate::theMainThread);
291            QCoreApplicationPrivate::theMainThread = 0;
292            data->deref(); // deletes the data and the adopted thread
293        }
294     }
295 
296 #ifdef Q_OS_BLACKBERRY
297     //The QCoreApplicationData struct is only populated on demand, because it is rarely needed and would
298     //affect startup time
299     void loadManifest() {
300         static bool manifestLoadAttempt = false;
301         if (manifestLoadAttempt)
302             return;
303 
304         manifestLoadAttempt = true;
305 
306         QFile metafile(QStringLiteral("app/META-INF/MANIFEST.MF"));
307         if (!metafile.open(QIODevice::ReadOnly)) {
308             qWarning() << Q_FUNC_INFO << "Could not open application metafile for reading";
309         } else {
310             while (!metafile.atEnd() && (application.isEmpty() || applicationVersion.isEmpty() || orgName.isEmpty())) {
311                 QByteArray line = metafile.readLine();
312                 if (line.startsWith("Application-Name:"))
313                     application = QString::fromUtf8(line.mid(18).trimmed());
314                 else if (line.startsWith("Application-Version:"))
315                     applicationVersion = QString::fromUtf8(line.mid(21).trimmed());
316                 else if (line.startsWith("Package-Author:"))
317                     orgName = QString::fromUtf8(line.mid(16).trimmed());
318             }
319             metafile.close();
320         }
321     }
322 #endif
323 
324     QString orgName, orgDomain, application;
325     QString applicationVersion;
326 
327 #ifndef QT_NO_LIBRARY
328     QStringList *app_libpaths;
329 #endif
330 
331 };
332 
333 Q_GLOBAL_STATIC(QCoreApplicationData, coreappdata)
334 
335 static bool quitLockRefEnabled = true;
336 
337 QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv, uint flags)
338     : QObjectPrivate()
339     , argc(aargc)
340     , argv(aargv)
341 #ifdef Q_OS_WIN
342     , origArgc(aargc)
343     , origArgv(new char *[aargc])
344 #endif
345     , application_type(0)
346     , in_exec(false)
347     , aboutToQuitEmitted(false)
348     , threadData_clean(false)
349 {
350     app_compile_version = flags & 0xffffff;
351     static const char *const empty = "";
352     if (argc == 0 || argv == 0) {
353         argc = 0;
354         argv = (char **)&empty; // ouch! careful with QCoreApplication::argv()!
355     }
356     QCoreApplicationPrivate::is_app_closing = false;
357 
358 #if defined(Q_OS_UNIX)
359     qt_application_thread_id = QThread::currentThreadId();
360 #elif defined(Q_OS_WIN)
361     qCopy(argv, argv + argc, origArgv);
362 #endif
363 
364     // note: this call to QThread::currentThread() may end up setting theMainThread!
365     if (QThread::currentThread() != theMainThread)
366         qWarning("WARNING: QApplication was not created in the main() thread.");
367 }
368 
369 QCoreApplicationPrivate::~QCoreApplicationPrivate()
370 {
371     cleanupThreadData();
372 #ifdef Q_OS_WIN
373     delete [] origArgv;
374 #endif
375 }
376 
377 void QCoreApplicationPrivate::cleanupThreadData()
378 {
379     if (threadData && !threadData_clean) {
380 #ifndef QT_NO_THREAD
381         void *data = &threadData->tls;
382         QThreadStorageData::finish((void **)data);
383 #endif
384 
385         // need to clear the state of the mainData, just in case a new QCoreApplication comes along.
386         QMutexLocker locker(&threadData->postEventList.mutex);
387         for (int i = 0; i < threadData->postEventList.size(); ++i) {
388             const QPostEvent &pe = threadData->postEventList.at(i);
389             if (pe.event) {
390                 --pe.receiver->d_func()->postedEvents;
391                 pe.event->posted = false;
392                 delete pe.event;
393             }
394         }
395         threadData->postEventList.clear();
396         threadData->postEventList.recursion = 0;
397         threadData->quitNow = false;
398         threadData_clean = true;
399     }
400 }
401 
402 void QCoreApplicationPrivate::createEventDispatcher()
403 {
404     Q_Q(QCoreApplication);
405 #if defined(Q_OS_UNIX)
406 #  if defined(Q_OS_BLACKBERRY)
407     eventDispatcher = new QEventDispatcherBlackberry(q);
408 #  else
409 #  if !defined(QT_NO_GLIB)
410     if (qEnvironmentVariableIsEmpty("QT_NO_GLIB") && QEventDispatcherGlib::versionSupported())
411         eventDispatcher = new QEventDispatcherGlib(q);
412     else
413 #  endif
414         eventDispatcher = new QEventDispatcherUNIX(q);
415 #  endif
416 #elif defined(Q_OS_WIN)
417     eventDispatcher = new QEventDispatcherWin32(q);
418 #else
419 #  error "QEventDispatcher not yet ported to this platform"
420 #endif
421 }
422 
423 QThread *QCoreApplicationPrivate::theMainThread = 0;
424 QThread *QCoreApplicationPrivate::mainThread()
425 {
426     Q_ASSERT(theMainThread != 0);
427     return theMainThread;
428 }
429 
430 #if !defined (QT_NO_DEBUG) || defined (QT_MAC_FRAMEWORK_BUILD)
431 void QCoreApplicationPrivate::checkReceiverThread(QObject *receiver)
432 {
433     QThread *currentThread = QThread::currentThread();
434     QThread *thr = receiver->thread();
435     Q_ASSERT_X(currentThread == thr || !thr,
436                "QCoreApplication::sendEvent",
437                QString::fromLatin1("Cannot send events to objects owned by a different thread. "
438                                    "Current thread %1. Receiver '%2' (of type '%3') was created in thread %4")
439                .arg(QString::number((quintptr) currentThread, 16))
440                .arg(receiver->objectName())
441                .arg(QLatin1String(receiver->metaObject()->className()))
442                .arg(QString::number((quintptr) thr, 16))
443                .toLocal8Bit().data());
444     Q_UNUSED(currentThread);
445     Q_UNUSED(thr);
446 }
447 #endif
448 
449 void QCoreApplicationPrivate::appendApplicationPathToLibraryPaths()
450 {
451 #ifndef QT_NO_LIBRARY
452     QStringList *app_libpaths = coreappdata()->app_libpaths;
453     if (!app_libpaths)
454         coreappdata()->app_libpaths = app_libpaths = new QStringList;
455     QString app_location = QCoreApplication::applicationFilePath();
456     app_location.truncate(app_location.lastIndexOf(QLatin1Char('/')));
457     app_location = QDir(app_location).canonicalPath();
458     if (QFile::exists(app_location) && !app_libpaths->contains(app_location))
459         app_libpaths->append(app_location);
460 #endif
461 }
462 
463 QString qAppName()
464 {
465     if (!QCoreApplicationPrivate::checkInstance("qAppName"))
466         return QString();
467     return QCoreApplication::instance()->d_func()->appName();
468 }
469 
470 void QCoreApplicationPrivate::initLocale()
471 {
472     if (qt_locale_initialized)
473         return;
474     qt_locale_initialized = true;
475 #ifdef Q_OS_UNIX
476     setlocale(LC_ALL, "");
477 #endif
478 }
479 
480 
481 /*!
482     \class QCoreApplication
483     \inmodule QtCore
484     \brief The QCoreApplication class provides an event loop for console Qt
485     applications.
486 
487     This class is used by non-GUI applications to provide their event
488     loop. For non-GUI application that uses Qt, there should be exactly
489     one QCoreApplication object. For GUI applications, see
490     QApplication.
491 
492     QCoreApplication contains the main event loop, where all events
493     from the operating system (e.g., timer and network events) and
494     other sources are processed and dispatched. It also handles the
495     application's initialization and finalization, as well as
496     system-wide and application-wide settings.
497 
498     \section1 The Event Loop and Event Handling
499 
500     The event loop is started with a call to exec(). Long running
501     operations can call processEvents() to keep the application
502     responsive.
503 
504     In general, we recommend that you create a QCoreApplication or a
505     QApplication object in your \c main() function as early as
506     possible. exec() will not return until the event loop exits; e.g.,
507     when quit() is called.
508 
509     Several static convenience functions are also provided. The
510     QCoreApplication object is available from instance(). Events can
511     be sent or posted using sendEvent(), postEvent(), and
512     sendPostedEvents(). Pending events can be removed with
513     removePostedEvents() or flushed with flush().
514 
515     The class provides a quit() slot and an aboutToQuit() signal.
516 
517     \section1 Application and Library Paths
518 
519     An application has an applicationDirPath() and an
520     applicationFilePath(). Library paths (see QLibrary) can be retrieved
521     with libraryPaths() and manipulated by setLibraryPaths(), addLibraryPath(),
522     and removeLibraryPath().
523 
524     \section1 Internationalization and Translations
525 
526     Translation files can be added or removed
527     using installTranslator() and removeTranslator(). Application
528     strings can be translated using translate(). The QObject::tr()
529     and QObject::trUtf8() functions are implemented in terms of
530     translate().
531 
532     \section1 Accessing Command Line Arguments
533 
534     The command line arguments which are passed to QCoreApplication's
535     constructor should be accessed using the arguments() function.
536     Note that some arguments supplied by the user may have been
537     processed and removed by QCoreApplication.
538 
539     In cases where command line arguments need to be obtained using the
540     argv() function, you must convert them from the local string encoding
541     using QString::fromLocal8Bit().
542 
543     \section1 Locale Settings
544 
545     On Unix/Linux Qt is configured to use the system locale settings by
546     default. This can cause a conflict when using POSIX functions, for
547     instance, when converting between data types such as floats and
548     strings, since the notation may differ between locales. To get
549     around this problem, call the POSIX function \c{setlocale(LC_NUMERIC,"C")}
550     right after initializing QApplication or QCoreApplication to reset
551     the locale that is used for number formatting to "C"-locale.
552 
553     \sa QGuiApplication, QAbstractEventDispatcher, QEventLoop,
554     {Semaphores Example}, {Wait Conditions Example}
555 */
556 
557 /*!
558     \fn static QCoreApplication *QCoreApplication::instance()
559 
560     Returns a pointer to the application's QCoreApplication (or
561     QApplication) instance.
562 
563     If no instance has been allocated, \c null is returned.
564 */
565 
566 /*!
567     \internal
568  */
569 QCoreApplication::QCoreApplication(QCoreApplicationPrivate &p)
570     : QObject(p, 0)
571 {
572     init();
573     // note: it is the subclasses' job to call
574     // QCoreApplicationPrivate::eventDispatcher->startingUp();
575 }
576 
577 /*!
578     Flushes the platform specific event queues.
579 
580     If you are doing graphical changes inside a loop that does not
581     return to the event loop on asynchronous window systems like X11
582     or double buffered window systems like Mac OS X, and you want to
583     visualize these changes immediately (e.g. Splash Screens), call
584     this function.
585 
586     \sa sendPostedEvents()
587 */
588 void QCoreApplication::flush()
589 {
590     if (self && self->d_func()->eventDispatcher)
591         self->d_func()->eventDispatcher->flush();
592 }
593 
594 /*!
595     Constructs a Qt kernel application. Kernel applications are
596     applications without a graphical user interface. These type of
597     applications are used at the console or as server processes.
598 
599     The \a argc and \a argv arguments are processed by the application,
600     and made available in a more convenient form by the arguments()
601     function.
602 
603     \warning The data referred to by \a argc and \a argv must stay valid
604     for the entire lifetime of the QCoreApplication object. In addition,
605     \a argc must be greater than zero and \a argv must contain at least
606     one valid character string.
607 */
608 QCoreApplication::QCoreApplication(int &argc, char **argv
609 #ifndef Q_QDOC
610                                    , int _internal
611 #endif
612                                    )
613     : QObject(*new QCoreApplicationPrivate(argc, argv, _internal))
614 {
615     init();
616     QCoreApplicationPrivate::eventDispatcher->startingUp();
617 }
618 
619 
620 // ### move to QCoreApplicationPrivate constructor?
621 void QCoreApplication::init()
622 {
623     Q_D(QCoreApplication);
624 
625     QCoreApplicationPrivate::initLocale();
626 
627     Q_ASSERT_X(!self, "QCoreApplication", "there should be only one application object");
628     QCoreApplication::self = this;
629 
630     // use the event dispatcher created by the app programmer (if any)
631     if (!QCoreApplicationPrivate::eventDispatcher)
632         QCoreApplicationPrivate::eventDispatcher = d->threadData->eventDispatcher;
633     // otherwise we create one
634     if (!QCoreApplicationPrivate::eventDispatcher)
635         d->createEventDispatcher();
636     Q_ASSERT(QCoreApplicationPrivate::eventDispatcher != 0);
637 
638     if (!QCoreApplicationPrivate::eventDispatcher->parent()) {
639         QCoreApplicationPrivate::eventDispatcher->moveToThread(d->threadData->thread);
640         QCoreApplicationPrivate::eventDispatcher->setParent(this);
641     }
642 
643     d->threadData->eventDispatcher = QCoreApplicationPrivate::eventDispatcher;
644 
645 #ifndef QT_NO_LIBRARY
646     if (coreappdata()->app_libpaths)
647         d->appendApplicationPathToLibraryPaths();
648 #endif
649 
650 #if defined(Q_OS_UNIX) && !(defined(QT_NO_PROCESS))
651     // Make sure the process manager thread object is created in the main
652     // thread.
653     QProcessPrivate::initializeProcessManager();
654 #endif
655 
656 #ifdef QT_EVAL
657     extern void qt_core_eval_init(uint);
658     qt_core_eval_init(d->application_type);
659 #endif
660 
661     d->processCommandLineArguments();
662 
663     qt_call_pre_routines();
664     qt_startup_hook();
665 }
666 
667 /*!
668     Destroys the QCoreApplication object.
669 */
670 QCoreApplication::~QCoreApplication()
671 {
672     qt_call_post_routines();
673 
674     self = 0;
675     QCoreApplicationPrivate::is_app_closing = true;
676     QCoreApplicationPrivate::is_app_running = false;
677 
678 #if !defined(QT_NO_THREAD)
679     // Synchronize and stop the global thread pool threads.
680     QThreadPool *globalThreadPool = 0;
681     QT_TRY {
682         globalThreadPool = QThreadPool::globalInstance();
683     } QT_CATCH (...) {
684         // swallow the exception, since destructors shouldn't throw
685     }
686     if (globalThreadPool)
687         globalThreadPool->waitForDone();
688 #endif
689 
690     d_func()->threadData->eventDispatcher = 0;
691     if (QCoreApplicationPrivate::eventDispatcher)
692         QCoreApplicationPrivate::eventDispatcher->closingDown();
693     QCoreApplicationPrivate::eventDispatcher = 0;
694 
695 #ifndef QT_NO_LIBRARY
696     delete coreappdata()->app_libpaths;
697     coreappdata()->app_libpaths = 0;
698 #endif
699 }
700 
701 
702 /*!
703     Sets the attribute \a attribute if \a on is true;
704     otherwise clears the attribute.
705 
706     One of the attributes that can be set with this method is
707     Qt::AA_ImmediateWidgetCreation. It tells Qt to create toplevel
708     windows immediately. Normally, resources for widgets are allocated
709     on demand to improve efficiency and minimize resource usage.
710     Therefore, if it is important to minimize resource consumption, do
711     not set this attribute.
712 
713     \sa testAttribute()
714 */
715 void QCoreApplication::setAttribute(Qt::ApplicationAttribute attribute, bool on)
716 {
717     if (on)
718         QCoreApplicationPrivate::attribs |= 1 << attribute;
719     else
720         QCoreApplicationPrivate::attribs &= ~(1 << attribute);
721 }
722 
723 /*!
724   Returns true if attribute \a attribute is set;
725   otherwise returns false.
726 
727   \sa setAttribute()
728  */
729 bool QCoreApplication::testAttribute(Qt::ApplicationAttribute attribute)
730 {
731     return QCoreApplicationPrivate::testAttribute(attribute);
732 }
733 
734 
735 /*!
736     \property QCoreApplication::quitLockEnabled
737 
738     Returns true if the use of the QEventLoopLocker feature can cause the
739     application to quit, otherwise returns false.
740 
741     \sa QEventLoopLocker
742 */
743 
744 /*!
745     Returns true if the use of the QEventLoopLocker feature can cause the
746     application to quit, otherwise returns false.
747 
748     \sa QEventLoopLocker
749  */
750 bool QCoreApplication::isQuitLockEnabled()
751 {
752     return quitLockRefEnabled;
753 }
754 
755 /*!
756     Enables the ability of the QEventLoopLocker feature to quit
757     the application.
758 
759     If disabled, the use of QEventLoopLocker will not quit the application.
760 
761     \sa QEventLoopLocker
762  */
763 void QCoreApplication::setQuitLockEnabled(bool enabled)
764 {
765     quitLockRefEnabled = enabled;
766 }
767 
768 /*!
769   \internal
770 
771   This function is here to make it possible for Qt extensions to
772   hook into event notification without subclassing QApplication
773 */
774 bool QCoreApplication::notifyInternal(QObject *receiver, QEvent *event)
775 {
776     // Make it possible for QtScript to hook into events even
777     // though QApplication is subclassed...
778     bool result = false;
779     void *cbdata[] = { receiver, event, &result };
780     if (QInternal::activateCallbacks(QInternal::EventNotifyCallback, cbdata)) {
781         return result;
782     }
783 
784     // Qt enforces the rule that events can only be sent to objects in
785     // the current thread, so receiver->d_func()->threadData is
786     // equivalent to QThreadData::current(), just without the function
787     // call overhead.
788     QObjectPrivate *d = receiver->d_func();
789     QThreadData *threadData = d->threadData;
790     QScopedLoopLevelCounter loopLevelCounter(threadData);
791     return notify(receiver, event);
792 }
793 
794 
795 /*!
796   Sends \a event to \a receiver: \a {receiver}->event(\a event).
797   Returns the value that is returned from the receiver's event
798   handler. Note that this function is called for all events sent to
799   any object in any thread.
800 
801   For certain types of events (e.g. mouse and key events),
802   the event will be propagated to the receiver's parent and so on up to
803   the top-level object if the receiver is not interested in the event
804   (i.e., it returns false).
805 
806   There are five different ways that events can be processed;
807   reimplementing this virtual function is just one of them. All five
808   approaches are listed below:
809   \list 1
810   \li Reimplementing paintEvent(), mousePressEvent() and so
811   on. This is the commonest, easiest and least powerful way.
812 
813   \li Reimplementing this function. This is very powerful, providing
814   complete control; but only one subclass can be active at a time.
815 
816   \li Installing an event filter on QCoreApplication::instance(). Such
817   an event filter is able to process all events for all widgets, so
818   it's just as powerful as reimplementing notify(); furthermore, it's
819   possible to have more than one application-global event filter.
820   Global event filters even see mouse events for
821   \l{QWidget::isEnabled()}{disabled widgets}. Note that application
822   event filters are only called for objects that live in the main
823   thread.
824 
825   \li Reimplementing QObject::event() (as QWidget does). If you do
826   this you get Tab key presses, and you get to see the events before
827   any widget-specific event filters.
828 
829   \li Installing an event filter on the object. Such an event filter gets all
830   the events, including Tab and Shift+Tab key press events, as long as they
831   do not change the focus widget.
832   \endlist
833 
834   \sa QObject::event(), installNativeEventFilter()
835 */
836 
837 bool QCoreApplication::notify(QObject *receiver, QEvent *event)
838 {
839     Q_D(QCoreApplication);
840     // no events are delivered after ~QCoreApplication() has started
841     if (QCoreApplicationPrivate::is_app_closing)
842         return true;
843 
844     if (receiver == 0) {                        // serious error
845         qWarning("QCoreApplication::notify: Unexpected null receiver");
846         return true;
847     }
848 
849 #ifndef QT_NO_DEBUG
850     d->checkReceiverThread(receiver);
851 #endif
852 
853     return receiver->isWidgetType() ? false : d->notify_helper(receiver, event);
854 }
855 
856 bool QCoreApplicationPrivate::sendThroughApplicationEventFilters(QObject *receiver, QEvent *event)
857 {
858     if (receiver->d_func()->threadData == this->threadData && extraData) {
859         // application event filters are only called for objects in the GUI thread
860         for (int i = 0; i < extraData->eventFilters.size(); ++i) {
861             register QObject *obj = extraData->eventFilters.at(i);
862             if (!obj)
863                 continue;
864             if (obj->d_func()->threadData != threadData) {
865                 qWarning("QCoreApplication: Application event filter cannot be in a different thread.");
866                 continue;
867             }
868             if (obj->eventFilter(receiver, event))
869                 return true;
870         }
871     }
872     return false;
873 }
874 
875 bool QCoreApplicationPrivate::sendThroughObjectEventFilters(QObject *receiver, QEvent *event)
876 {
877     Q_Q(QCoreApplication);
878     if (receiver != q && receiver->d_func()->extraData) {
879         for (int i = 0; i < receiver->d_func()->extraData->eventFilters.size(); ++i) {
880             register QObject *obj = receiver->d_func()->extraData->eventFilters.at(i);
881             if (!obj)
882                 continue;
883             if (obj->d_func()->threadData != receiver->d_func()->threadData) {
884                 qWarning("QCoreApplication: Object event filter cannot be in a different thread.");
885                 continue;
886             }
887             if (obj->eventFilter(receiver, event))
888                 return true;
889         }
890     }
891     return false;
892 }
893 
894 /*!
895   \internal
896 
897   Helper function called by notify()
898  */
899 bool QCoreApplicationPrivate::notify_helper(QObject *receiver, QEvent * event)
900 {
901     // send to all application event filters
902     if (sendThroughApplicationEventFilters(receiver, event))
903         return true;
904     // send to all receiver event filters
905     if (sendThroughObjectEventFilters(receiver, event))
906         return true;
907     // deliver the event
908     return receiver->event(event);
909 }
910 
911 /*!
912   Returns true if an application object has not been created yet;
913   otherwise returns false.
914 
915   \sa closingDown()
916 */
917 
918 bool QCoreApplication::startingUp()
919 {
920     return !QCoreApplicationPrivate::is_app_running;
921 }
922 
923 /*!
924   Returns true if the application objects are being destroyed;
925   otherwise returns false.
926 
927   \sa startingUp()
928 */
929 
930 bool QCoreApplication::closingDown()
931 {
932     return QCoreApplicationPrivate::is_app_closing;
933 }
934 
935 
936 /*!
937     Processes all pending events for the calling thread according to
938     the specified \a flags until there are no more events to process.
939 
940     You can call this function occasionally when your program is busy
941     performing a long operation (e.g. copying a file).
942 
943     In event you are running a local loop which calls this function
944     continuously, without an event loop, the
945     \l{QEvent::DeferredDelete}{DeferredDelete} events will
946     not be processed. This can affect the behaviour of widgets,
947     e.g. QToolTip, that rely on \l{QEvent::DeferredDelete}{DeferredDelete}
948     events to function properly. An alternative would be to call
949     \l{QCoreApplication::sendPostedEvents()}{sendPostedEvents()} from
950     within that local loop.
951 
952     Calling this function processes events only for the calling thread.
953 
954     \threadsafe
955 
956     \sa exec(), QTimer, QEventLoop::processEvents(), flush(), sendPostedEvents()
957 */
958 void QCoreApplication::processEvents(QEventLoop::ProcessEventsFlags flags)
959 {
960     QThreadData *data = QThreadData::current();
961     if (!data->eventDispatcher)
962         return;
963     data->eventDispatcher->processEvents(flags);
964 }
965 
966 /*!
967     \overload processEvents()
968 
969     Processes pending events for the calling thread for \a maxtime
970     milliseconds or until there are no more events to process,
971     whichever is shorter.
972 
973     You can call this function occasionally when you program is busy
974     doing a long operation (e.g. copying a file).
975 
976     Calling this function processes events only for the calling thread.
977 
978     \threadsafe
979 
980     \sa exec(), QTimer, QEventLoop::processEvents()
981 */
982 void QCoreApplication::processEvents(QEventLoop::ProcessEventsFlags flags, int maxtime)
983 {
984     QThreadData *data = QThreadData::current();
985     if (!data->eventDispatcher)
986         return;
987     QElapsedTimer start;
988     start.start();
989     while (data->eventDispatcher->processEvents(flags & ~QEventLoop::WaitForMoreEvents)) {
990         if (start.elapsed() > maxtime)
991             break;
992     }
993 }
994 
995 /*****************************************************************************
996   Main event loop wrappers
997  *****************************************************************************/
998 
999 /*!
1000     Enters the main event loop and waits until exit() is called.
1001     Returns the value that was set to exit() (which is 0 if exit() is
1002     called via quit()).
1003 
1004     It is necessary to call this function to start event handling. The
1005     main event loop receives events from the window system and
1006     dispatches these to the application widgets.
1007 
1008     To make your application perform idle processing (i.e. executing a
1009     special function whenever there are no pending events), use a
1010     QTimer with 0 timeout. More advanced idle processing schemes can
1011     be achieved using processEvents().
1012 
1013     We recommend that you connect clean-up code to the
1014     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in
1015     your application's \c{main()} function because on some platforms the
1016     QCoreApplication::exec() call may not return. For example, on Windows
1017     when the user logs off, the system terminates the process after Qt
1018     closes all top-level windows. Hence, there is no guarantee that the
1019     application will have time to exit its event loop and execute code at
1020     the end of the \c{main()} function after the QCoreApplication::exec()
1021     call.
1022 
1023     \sa quit(), exit(), processEvents(), QApplication::exec()
1024 */
1025 int QCoreApplication::exec()
1026 {
1027     if (!QCoreApplicationPrivate::checkInstance("exec"))
1028         return -1;
1029 
1030     QThreadData *threadData = self->d_func()->threadData;
1031     if (threadData != QThreadData::current()) {
1032         qWarning("%s::exec: Must be called from the main thread", self->metaObject()->className());
1033         return -1;
1034     }
1035     if (!threadData->eventLoops.isEmpty()) {
1036         qWarning("QCoreApplication::exec: The event loop is already running");
1037         return -1;
1038     }
1039 
1040     threadData->quitNow = false;
1041     QEventLoop eventLoop;
1042     self->d_func()->in_exec = true;
1043     self->d_func()->aboutToQuitEmitted = false;
1044     int returnCode = eventLoop.exec();
1045     threadData->quitNow = false;
1046     if (self) {
1047         self->d_func()->in_exec = false;
1048         if (!self->d_func()->aboutToQuitEmitted)
1049             emit self->aboutToQuit(QPrivateSignal());
1050         self->d_func()->aboutToQuitEmitted = true;
1051         sendPostedEvents(0, QEvent::DeferredDelete);
1052     }
1053 
1054     return returnCode;
1055 }
1056 
1057 
1058 /*!
1059   Tells the application to exit with a return code.
1060 
1061     After this function has been called, the application leaves the
1062     main event loop and returns from the call to exec(). The exec()
1063     function returns \a returnCode. If the event loop is not running,
1064     this function does nothing.
1065 
1066   By convention, a \a returnCode of 0 means success, and any non-zero
1067   value indicates an error.
1068 
1069   Note that unlike the C library function of the same name, this
1070   function \e does return to the caller -- it is event processing that
1071   stops.
1072 
1073   \sa quit(), exec()
1074 */
1075 void QCoreApplication::exit(int returnCode)
1076 {
1077     if (!self)
1078         return;
1079     QThreadData *data = self->d_func()->threadData;
1080     data->quitNow = true;
1081     for (int i = 0; i < data->eventLoops.size(); ++i) {
1082         QEventLoop *eventLoop = data->eventLoops.at(i);
1083         eventLoop->exit(returnCode);
1084     }
1085 }
1086 
1087 /*****************************************************************************
1088   QCoreApplication management of posted events
1089  *****************************************************************************/
1090 
1091 /*!
1092     \fn bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)
1093 
1094     Sends event \a event directly to receiver \a receiver, using the
1095     notify() function. Returns the value that was returned from the
1096     event handler.
1097 
1098     The event is \e not deleted when the event has been sent. The normal
1099     approach is to create the event on the stack, for example:
1100 
1101     \snippet code/src_corelib_kernel_qcoreapplication.cpp 0
1102 
1103     \sa postEvent(), notify()
1104 */
1105 
1106 /*!
1107     \since 4.3
1108 
1109     Adds the event \a event, with the object \a receiver as the
1110     receiver of the event, to an event queue and returns immediately.
1111 
1112     The event must be allocated on the heap since the post event queue
1113     will take ownership of the event and delete it once it has been
1114     posted.  It is \e {not safe} to access the event after
1115     it has been posted.
1116 
1117     When control returns to the main event loop, all events that are
1118     stored in the queue will be sent using the notify() function.
1119 
1120     Events are sorted in descending \a priority order, i.e. events
1121     with a high \a priority are queued before events with a lower \a
1122     priority. The \a priority can be any integer value, i.e. between
1123     INT_MAX and INT_MIN, inclusive; see Qt::EventPriority for more
1124     details. Events with equal \a priority will be processed in the
1125     order posted.
1126 
1127     \threadsafe
1128 
1129     \sa sendEvent(), notify(), sendPostedEvents(), Qt::EventPriority
1130 */
1131 void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority)
1132 {
1133     if (receiver == 0) {
1134         qWarning("QCoreApplication::postEvent: Unexpected null receiver");
1135         delete event;
1136         return;
1137     }
1138 
1139     QThreadData * volatile * pdata = &receiver->d_func()->threadData;
1140     QThreadData *data = *pdata;
1141     if (!data) {
1142         // posting during destruction? just delete the event to prevent a leak
1143         delete event;
1144         return;
1145     }
1146 
1147     // lock the post event mutex
1148     data->postEventList.mutex.lock();
1149 
1150     // if object has moved to another thread, follow it
1151     while (data != *pdata) {
1152         data->postEventList.mutex.unlock();
1153 
1154         data = *pdata;
1155         if (!data) {
1156             // posting during destruction? just delete the event to prevent a leak
1157             delete event;
1158             return;
1159         }
1160 
1161         data->postEventList.mutex.lock();
1162     }
1163 
1164     QMutexUnlocker locker(&data->postEventList.mutex);
1165 
1166     // if this is one of the compressible events, do compression
1167     if (receiver->d_func()->postedEvents
1168         && self && self->compressEvent(event, receiver, &data->postEventList)) {
1169         return;
1170     }
1171 
1172     if (event->type() == QEvent::DeferredDelete && data == QThreadData::current()) {
1173         // remember the current running eventloop for DeferredDelete
1174         // events posted in the receiver's thread
1175         static_cast<QDeferredDeleteEvent *>(event)->level = data->loopLevel;
1176     }
1177 
1178     // delete the event on exceptions to protect against memory leaks till the event is
1179     // properly owned in the postEventList
1180     QScopedPointer<QEvent> eventDeleter(event);
1181     data->postEventList.addEvent(QPostEvent(receiver, event, priority));
1182     eventDeleter.take();
1183     event->posted = true;
1184     ++receiver->d_func()->postedEvents;
1185     data->canWait = false;
1186     locker.unlock();
1187 
1188     if (data->eventDispatcher)
1189         data->eventDispatcher->wakeUp();
1190 }
1191 
1192 /*!
1193   \internal
1194   Returns true if \a event was compressed away (possibly deleted) and should not be added to the list.
1195 */
1196 bool QCoreApplication::compressEvent(QEvent *event, QObject *receiver, QPostEventList *postedEvents)
1197 {
1198 #ifdef Q_OS_WIN
1199     Q_ASSERT(event);
1200     Q_ASSERT(receiver);
1201     Q_ASSERT(postedEvents);
1202 
1203     // compress posted timers to this object.
1204     if (event->type() == QEvent::Timer && receiver->d_func()->postedEvents > 0) {
1205         int timerId = ((QTimerEvent *) event)->timerId();
1206         for (int i=0; i<postedEvents->size(); ++i) {
1207             const QPostEvent &e = postedEvents->at(i);
1208             if (e.receiver == receiver && e.event && e.event->type() == QEvent::Timer
1209                 && ((QTimerEvent *) e.event)->timerId() == timerId) {
1210                 delete event;
1211                 return true;
1212             }
1213         }
1214     } else
1215 #endif
1216         if ((event->type() == QEvent::DeferredDelete
1217              || event->type() == QEvent::Quit)
1218             && receiver->d_func()->postedEvents > 0) {
1219             for (int i = 0; i < postedEvents->size(); ++i) {
1220                 const QPostEvent &cur = postedEvents->at(i);
1221                 if (cur.receiver != receiver
1222                     || cur.event == 0
1223                     || cur.event->type() != event->type())
1224                     continue;
1225                 // found an event for this receiver
1226                 delete event;
1227                 return true;
1228             }
1229         }
1230     return false;
1231 }
1232 
1233 /*!
1234   Immediately dispatches all events which have been previously queued
1235   with QCoreApplication::postEvent() and which are for the object \a receiver
1236   and have the event type \a event_type.
1237 
1238   Events from the window system are \e not dispatched by this
1239   function, but by processEvents().
1240 
1241   If \a receiver is null, the events of \a event_type are sent for all
1242   objects. If \a event_type is 0, all the events are sent for \a receiver.
1243 
1244   \note This method must be called from the same thread as its QObject parameter, \a receiver.
1245 
1246   \sa flush(), postEvent()
1247 */
1248 void QCoreApplication::sendPostedEvents(QObject *receiver, int event_type)
1249 {
1250     QThreadData *data = QThreadData::current();
1251 
1252     QCoreApplicationPrivate::sendPostedEvents(receiver, event_type, data);
1253 }
1254 
1255 void QCoreApplicationPrivate::sendPostedEvents(QObject *receiver, int event_type,
1256                                                QThreadData *data)
1257 {
1258     if (event_type == -1) {
1259         // we were called by an obsolete event dispatcher.
1260         event_type = 0;
1261     }
1262 
1263     if (receiver && receiver->d_func()->threadData != data) {
1264         qWarning("QCoreApplication::sendPostedEvents: Cannot send "
1265                  "posted events for objects in another thread");
1266         return;
1267     }
1268 
1269     ++data->postEventList.recursion;
1270 
1271     QMutexLocker locker(&data->postEventList.mutex);
1272 
1273     // by default, we assume that the event dispatcher can go to sleep after
1274     // processing all events. if any new events are posted while we send
1275     // events, canWait will be set to false.
1276     data->canWait = (data->postEventList.size() == 0);
1277 
1278     if (data->postEventList.size() == 0 || (receiver && !receiver->d_func()->postedEvents)) {
1279         --data->postEventList.recursion;
1280         return;
1281     }
1282 
1283     data->canWait = true;
1284 
1285     // okay. here is the tricky loop. be careful about optimizing
1286     // this, it looks the way it does for good reasons.
1287     int startOffset = data->postEventList.startOffset;
1288     int &i = (!event_type && !receiver) ? data->postEventList.startOffset : startOffset;
1289     data->postEventList.insertionOffset = data->postEventList.size();
1290 
1291     // Exception-safe cleaning up without the need for a try/catch block
1292     struct CleanUp {
1293         QObject *receiver;
1294         int event_type;
1295         QThreadData *data;
1296         bool exceptionCaught;
1297 
1298         inline CleanUp(QObject *receiver, int event_type, QThreadData *data) :
1299             receiver(receiver), event_type(event_type), data(data), exceptionCaught(true)
1300         {}
1301         inline ~CleanUp()
1302         {
1303             if (exceptionCaught) {
1304                 // since we were interrupted, we need another pass to make sure we clean everything up
1305                 data->canWait = false;
1306             }
1307 
1308             --data->postEventList.recursion;
1309             if (!data->postEventList.recursion && !data->canWait && data->eventDispatcher)
1310                 data->eventDispatcher->wakeUp();
1311 
1312             // clear the global list, i.e. remove everything that was
1313             // delivered.
1314             if (!event_type && !receiver && data->postEventList.startOffset >= 0) {
1315                 const QPostEventList::iterator it = data->postEventList.begin();
1316                 data->postEventList.erase(it, it + data->postEventList.startOffset);
1317                 data->postEventList.insertionOffset -= data->postEventList.startOffset;
1318                 Q_ASSERT(data->postEventList.insertionOffset >= 0);
1319                 data->postEventList.startOffset = 0;
1320             }
1321         }
1322     };
1323     CleanUp cleanup(receiver, event_type, data);
1324 
1325     while (i < data->postEventList.size()) {
1326         // avoid live-lock
1327         if (i >= data->postEventList.insertionOffset)
1328             break;
1329 
1330         const QPostEvent &pe = data->postEventList.at(i);
1331         ++i;
1332 
1333         if (!pe.event)
1334             continue;
1335         if ((receiver && receiver != pe.receiver) || (event_type && event_type != pe.event->type())) {
1336             data->canWait = false;
1337             continue;
1338         }
1339 
1340         if (pe.event->type() == QEvent::DeferredDelete) {
1341             // DeferredDelete events are only sent when we are explicitly asked to
1342             // (s.a. QEvent::DeferredDelete), and then only if the event loop that
1343             // posted the event has returned.
1344             int loopLevel = static_cast<QDeferredDeleteEvent *>(pe.event)->loopLevel();
1345             const bool allowDeferredDelete =
1346                 (loopLevel > data->loopLevel
1347                  || (!loopLevel && data->loopLevel > 0)
1348                  || (event_type == QEvent::DeferredDelete
1349                      && loopLevel == data->loopLevel));
1350             if (!allowDeferredDelete) {
1351                 // cannot send deferred delete
1352                 if (!event_type && !receiver) {
1353                     // we must copy it first; we want to re-post the event
1354                     // with the event pointer intact, but we can't delay
1355                     // nulling the event ptr until after re-posting, as
1356                     // addEvent may invalidate pe.
1357                     QPostEvent pe_copy = pe;
1358 
1359                     // null out the event so if sendPostedEvents recurses, it
1360                     // will ignore this one, as it's been re-posted.
1361                     const_cast<QPostEvent &>(pe).event = 0;
1362 
1363                     // re-post the copied event so it isn't lost
1364                     data->postEventList.addEvent(pe_copy);
1365                 }
1366                 continue;
1367             }
1368         }
1369 
1370         // first, we diddle the event so that we can deliver
1371         // it, and that no one will try to touch it later.
1372         pe.event->posted = false;
1373         QScopedPointer<QEvent> e(pe.event);
1374         QObject * r = pe.receiver;
1375 
1376         --r->d_func()->postedEvents;
1377         Q_ASSERT(r->d_func()->postedEvents >= 0);
1378 
1379         // next, update the data structure so that we're ready
1380         // for the next event.
1381         const_cast<QPostEvent &>(pe).event = 0;
1382 
1383         struct MutexUnlocker
1384         {
1385             QMutexLocker &m;
1386             MutexUnlocker(QMutexLocker &m) : m(m) { m.unlock(); }
1387             ~MutexUnlocker() { m.relock(); }
1388         };
1389         MutexUnlocker unlocker(locker);
1390 
1391         // after all that work, it's time to deliver the event.
1392         QCoreApplication::sendEvent(r, e.data());
1393 
1394         // careful when adding anything below this point - the
1395         // sendEvent() call might invalidate any invariants this
1396         // function depends on.
1397     }
1398 
1399     cleanup.exceptionCaught = false;
1400 }
1401 
1402 /*!
1403     \since 4.3
1404 
1405     Removes all events of the given \a eventType that were posted
1406     using postEvent() for \a receiver.
1407 
1408     The events are \e not dispatched, instead they are removed from
1409     the queue. You should never need to call this function. If you do
1410     call it, be aware that killing events may cause \a receiver to
1411     break one or more invariants.
1412 
1413     If \a receiver is null, the events of \a eventType are removed for
1414     all objects. If \a eventType is 0, all the events are removed for
1415     \a receiver. You should never call this function with \a eventType
1416     of 0. If you do call it in this way, be aware that killing events
1417     may cause \a receiver to break one or more invariants.
1418 
1419     \threadsafe
1420 */
1421 
1422 void QCoreApplication::removePostedEvents(QObject *receiver, int eventType)
1423 {
1424     QThreadData *data = receiver ? receiver->d_func()->threadData : QThreadData::current();
1425     QMutexLocker locker(&data->postEventList.mutex);
1426 
1427     // the QObject destructor calls this function directly.  this can
1428     // happen while the event loop is in the middle of posting events,
1429     // and when we get here, we may not have any more posted events
1430     // for this object.
1431     if (receiver && !receiver->d_func()->postedEvents)
1432         return;
1433 
1434     //we will collect all the posted events for the QObject
1435     //and we'll delete after the mutex was unlocked
1436     QVarLengthArray<QEvent*> events;
1437     int n = data->postEventList.size();
1438     int j = 0;
1439 
1440     for (int i = 0; i < n; ++i) {
1441         const QPostEvent &pe = data->postEventList.at(i);
1442 
1443         if ((!receiver || pe.receiver == receiver)
1444             && (pe.event && (eventType == 0 || pe.event->type() == eventType))) {
1445             --pe.receiver->d_func()->postedEvents;
1446             pe.event->posted = false;
1447             events.append(pe.event);
1448             const_cast<QPostEvent &>(pe).event = 0;
1449         } else if (!data->postEventList.recursion) {
1450             if (i != j)
1451                 qSwap(data->postEventList[i], data->postEventList[j]);
1452             ++j;
1453         }
1454     }
1455 
1456 #ifdef QT_DEBUG
1457     if (receiver && eventType == 0) {
1458         Q_ASSERT(!receiver->d_func()->postedEvents);
1459     }
1460 #endif
1461 
1462     if (!data->postEventList.recursion) {
1463         // truncate list
1464         data->postEventList.erase(data->postEventList.begin() + j, data->postEventList.end());
1465     }
1466 
1467     locker.unlock();
1468     for (int i = 0; i < events.count(); ++i) {
1469         delete events[i];
1470     }
1471 }
1472 
1473 /*!
1474   Removes \a event from the queue of posted events, and emits a
1475   warning message if appropriate.
1476 
1477   \warning This function can be \e really slow. Avoid using it, if
1478   possible.
1479 
1480   \threadsafe
1481 */
1482 
1483 void QCoreApplicationPrivate::removePostedEvent(QEvent * event)
1484 {
1485     if (!event || !event->posted)
1486         return;
1487 
1488     QThreadData *data = QThreadData::current();
1489 
1490     QMutexLocker locker(&data->postEventList.mutex);
1491 
1492     if (data->postEventList.size() == 0) {
1493 #if defined(QT_DEBUG)
1494         qDebug("QCoreApplication::removePostedEvent: Internal error: %p %d is posted",
1495                 (void*)event, event->type());
1496         return;
1497 #endif
1498     }
1499 
1500     for (int i = 0; i < data->postEventList.size(); ++i) {
1501         const QPostEvent & pe = data->postEventList.at(i);
1502         if (pe.event == event) {
1503 #ifndef QT_NO_DEBUG
1504             qWarning("QCoreApplication::removePostedEvent: Event of type %d deleted while posted to %s %s",
1505                      event->type(),
1506                      pe.receiver->metaObject()->className(),
1507                      pe.receiver->objectName().toLocal8Bit().data());
1508 #endif
1509             --pe.receiver->d_func()->postedEvents;
1510             pe.event->posted = false;
1511             delete pe.event;
1512             const_cast<QPostEvent &>(pe).event = 0;
1513             return;
1514         }
1515     }
1516 }
1517 
1518 /*!\reimp
1519 
1520 */
1521 bool QCoreApplication::event(QEvent *e)
1522 {
1523     if (e->type() == QEvent::Quit) {
1524         quit();
1525         return true;
1526     }
1527     return QObject::event(e);
1528 }
1529 
1530 /*! \enum QCoreApplication::Encoding
1531     \obsolete
1532 
1533     This enum type used to define the 8-bit encoding of character string
1534     arguments to translate(). This enum is now obsolete and UTF-8 will be
1535     used in all cases.
1536 
1537     \value UnicodeUTF8   UTF-8.
1538     \omitvalue Latin1
1539     \omitvalue DefaultCodec  UTF-8.
1540     \omitvalue CodecForTr
1541 
1542     \sa QObject::tr(), QString::fromUtf8()
1543 */
1544 
1545 void QCoreApplicationPrivate::ref()
1546 {
1547     quitLockRef.ref();
1548 }
1549 
1550 void QCoreApplicationPrivate::deref()
1551 {
1552     if (!quitLockRef.deref())
1553         maybeQuit();
1554 }
1555 
1556 void QCoreApplicationPrivate::maybeQuit()
1557 {
1558     if (quitLockRef.load() == 0 && in_exec && quitLockRefEnabled && shouldQuit())
1559         QCoreApplication::postEvent(QCoreApplication::instance(), new QEvent(QEvent::Quit));
1560 }
1561 
1562 /*!
1563     Tells the application to exit with return code 0 (success).
1564     Equivalent to calling QCoreApplication::exit(0).
1565 
1566     It's common to connect the QApplication::lastWindowClosed() signal
1567     to quit(), and you also often connect e.g. QAbstractButton::clicked() or
1568     signals in QAction, QMenu, or QMenuBar to it.
1569 
1570     Example:
1571 
1572     \snippet code/src_corelib_kernel_qcoreapplication.cpp 1
1573 
1574     \sa exit(), aboutToQuit(), QApplication::lastWindowClosed()
1575 */
1576 
1577 void QCoreApplication::quit()
1578 {
1579     exit(0);
1580 }
1581 
1582 /*!
1583   \fn void QCoreApplication::aboutToQuit()
1584 
1585   This signal is emitted when the application is about to quit the
1586   main event loop, e.g. when the event loop level drops to zero.
1587   This may happen either after a call to quit() from inside the
1588   application or when the users shuts down the entire desktop session.
1589 
1590   The signal is particularly useful if your application has to do some
1591   last-second cleanup. Note that no user interaction is possible in
1592   this state.
1593 
1594   \sa quit()
1595 */
1596 
1597 #ifndef QT_NO_TRANSLATION
1598 /*!
1599     Adds the translation file \a translationFile to the list of
1600     translation files to be used for translations.
1601 
1602     Multiple translation files can be installed. Translations are
1603     searched for in the reverse order in which they were installed,
1604     so the most recently installed translation file is searched first
1605     and the first translation file installed is searched last.
1606     The search stops as soon as a translation containing a matching
1607     string is found.
1608 
1609     Installing or removing a QTranslator, or changing an installed QTranslator
1610     generates a \l{QEvent::LanguageChange}{LanguageChange} event for the
1611     QCoreApplication instance. A QApplication instance will propagate the event
1612     to all toplevel windows, where a reimplementation of changeEvent can
1613     re-translate the user interface by passing user-visible strings via the
1614     tr() function to the respective property setters. User-interface classes
1615     generated by Qt Designer provide a \c retranslateUi() function that can be
1616     called.
1617 
1618     The function returns true on success and false on failure.
1619 
1620     \sa removeTranslator(), translate(), QTranslator::load(), {Dynamic Translation}
1621 */
1622 
1623 bool QCoreApplication::installTranslator(QTranslator *translationFile)
1624 {
1625     if (!translationFile)
1626         return false;
1627 
1628     if (!QCoreApplicationPrivate::checkInstance("installTranslator"))
1629         return false;
1630     QCoreApplicationPrivate *d = self->d_func();
1631     d->translators.prepend(translationFile);
1632 
1633 #ifndef QT_NO_TRANSLATION_BUILDER
1634     if (translationFile->isEmpty())
1635         return false;
1636 #endif
1637 
1638     QEvent ev(QEvent::LanguageChange);
1639     QCoreApplication::sendEvent(self, &ev);
1640     return true;
1641 }
1642 
1643 /*!
1644     Removes the translation file \a translationFile from the list of
1645     translation files used by this application. (It does not delete the
1646     translation file from the file system.)
1647 
1648     The function returns true on success and false on failure.
1649 
1650     \sa installTranslator(), translate(), QObject::tr()
1651 */
1652 
1653 bool QCoreApplication::removeTranslator(QTranslator *translationFile)
1654 {
1655     if (!translationFile)
1656         return false;
1657     if (!QCoreApplicationPrivate::checkInstance("removeTranslator"))
1658         return false;
1659     QCoreApplicationPrivate *d = self->d_func();
1660     if (d->translators.removeAll(translationFile)) {
1661         if (!self->closingDown()) {
1662             QEvent ev(QEvent::LanguageChange);
1663             QCoreApplication::sendEvent(self, &ev);
1664         }
1665         return true;
1666     }
1667     return false;
1668 }
1669 
1670 static void replacePercentN(QString *result, int n)
1671 {
1672     if (n >= 0) {
1673         int percentPos = 0;
1674         int len = 0;
1675         while ((percentPos = result->indexOf(QLatin1Char('%'), percentPos + len)) != -1) {
1676             len = 1;
1677             QString fmt;
1678             if (result->at(percentPos + len) == QLatin1Char('L')) {
1679                 ++len;
1680                 fmt = QLatin1String("%L1");
1681             } else {
1682                 fmt = QLatin1String("%1");
1683             }
1684             if (result->at(percentPos + len) == QLatin1Char('n')) {
1685                 fmt = fmt.arg(n);
1686                 ++len;
1687                 result->replace(percentPos, len, fmt);
1688                 len = fmt.length();
1689             }
1690         }
1691     }
1692 }
1693 
1694 /*!
1695     \reentrant
1696 
1697     Returns the translation text for \a sourceText, by querying the
1698     installed translation files. The translation files are searched
1699     from the most recently installed file back to the first
1700     installed file.
1701 
1702     QObject::tr() provides this functionality more conveniently.
1703 
1704     \a context is typically a class name (e.g., "MyDialog") and \a
1705     sourceText is either English text or a short identifying text.
1706 
1707     \a disambiguation is an identifying string, for when the same \a
1708     sourceText is used in different roles within the same context. By
1709     default, it is null.
1710 
1711     See the \l QTranslator and \l QObject::tr() documentation for
1712     more information about contexts, disambiguations and comments.
1713 
1714     \a n is used in conjunction with \c %n to support plural forms.
1715     See QObject::tr() for details.
1716 
1717     If none of the translation files contain a translation for \a
1718     sourceText in \a context, this function returns a QString
1719     equivalent of \a sourceText.
1720 
1721     This function is not virtual. You can use alternative translation
1722     techniques by subclassing \l QTranslator.
1723 
1724     \warning This method is reentrant only if all translators are
1725     installed \e before calling this method. Installing or removing
1726     translators while performing translations is not supported. Doing
1727     so will most likely result in crashes or other undesirable
1728     behavior.
1729 
1730     \sa QObject::tr(), installTranslator()
1731 */
1732 QString QCoreApplication::translate(const char *context, const char *sourceText,
1733                                     const char *disambiguation, int n)
1734 {
1735     QString result;
1736 
1737     if (!sourceText)
1738         return result;
1739 
1740     if (self && !self->d_func()->translators.isEmpty()) {
1741         QList<QTranslator*>::ConstIterator it;
1742         QTranslator *translationFile;
1743         for (it = self->d_func()->translators.constBegin(); it != self->d_func()->translators.constEnd(); ++it) {
1744             translationFile = *it;
1745             result = translationFile->translate(context, sourceText, disambiguation, n);
1746             if (!result.isNull())
1747                 break;
1748         }
1749     }
1750 
1751     if (result.isNull())
1752         result = QString::fromUtf8(sourceText);
1753 
1754     replacePercentN(&result, n);
1755     return result;
1756 }
1757 
1758 /*! \fn static QString QCoreApplication::translate(const char *context, const char *key, const char *disambiguation, Encoding encoding, int n = -1)
1759 
1760   \obsolete
1761 */
1762 
1763 // Declared in qglobal.h
1764 QString qtTrId(const char *id, int n)
1765 {
1766     return QCoreApplication::translate(0, id, 0, n);
1767 }
1768 
1769 bool QCoreApplicationPrivate::isTranslatorInstalled(QTranslator *translator)
1770 {
1771     return QCoreApplication::self
1772            && QCoreApplication::self->d_func()->translators.contains(translator);
1773 }
1774 
1775 #endif //QT_NO_TRANSLATE
1776 
1777 /*!
1778     Returns the directory that contains the application executable.
1779 
1780     For example, if you have installed Qt in the \c{C:\Qt}
1781     directory, and you run the \c{regexp} example, this function will
1782     return "C:/Qt/examples/tools/regexp".
1783 
1784     On Mac OS X this will point to the directory actually containing the
1785     executable, which may be inside of an application bundle (if the
1786     application is bundled).
1787 
1788     \warning On Linux, this function will try to get the path from the
1789     \c {/proc} file system. If that fails, it assumes that \c
1790     {argv[0]} contains the absolute file name of the executable. The
1791     function also assumes that the current directory has not been
1792     changed by the application.
1793 
1794     \sa applicationFilePath()
1795 */
1796 QString QCoreApplication::applicationDirPath()
1797 {
1798     if (!self) {
1799         qWarning("QCoreApplication::applicationDirPath: Please instantiate the QApplication object first");
1800         return QString();
1801     }
1802 
1803     QCoreApplicationPrivate *d = self->d_func();
1804     if (d->cachedApplicationDirPath.isNull())
1805         d->cachedApplicationDirPath = QFileInfo(applicationFilePath()).path();
1806     return d->cachedApplicationDirPath;
1807 }
1808 
1809 /*!
1810     Returns the file path of the application executable.
1811 
1812     For example, if you have installed Qt in the \c{/usr/local/qt}
1813     directory, and you run the \c{regexp} example, this function will
1814     return "/usr/local/qt/examples/tools/regexp/regexp".
1815 
1816     \warning On Linux, this function will try to get the path from the
1817     \c {/proc} file system. If that fails, it assumes that \c
1818     {argv[0]} contains the absolute file name of the executable. The
1819     function also assumes that the current directory has not been
1820     changed by the application.
1821 
1822     \sa applicationDirPath()
1823 */
1824 QString QCoreApplication::applicationFilePath()
1825 {
1826     if (!self) {
1827         qWarning("QCoreApplication::applicationFilePath: Please instantiate the QApplication object first");
1828         return QString();
1829     }
1830 
1831     QCoreApplicationPrivate *d = self->d_func();
1832     if (!d->cachedApplicationFilePath.isNull())
1833         return d->cachedApplicationFilePath;
1834 
1835 #if defined(Q_OS_WIN)
1836     d->cachedApplicationFilePath = QFileInfo(qAppFileName()).filePath();
1837     return d->cachedApplicationFilePath;
1838 #elif defined(Q_OS_BLACKBERRY)
1839     if (!arguments().isEmpty()) { // args is never empty, but the navigator can change behaviour some day
1840         QFileInfo fileInfo(arguments().at(0));
1841         const bool zygotized = fileInfo.exists();
1842         if (zygotized) {
1843             // Handle the zygotized case:
1844             d->cachedApplicationFilePath = QDir::cleanPath(fileInfo.absoluteFilePath());
1845             return d->cachedApplicationFilePath;
1846         }
1847     }
1848 
1849     // Handle the non-zygotized case:
1850     const size_t maximum_path = static_cast<size_t>(pathconf("/",_PC_PATH_MAX));
1851     char buff[maximum_path+1];
1852     if (_cmdname(buff)) {
1853         d->cachedApplicationFilePath = QDir::cleanPath(QString::fromLocal8Bit(buff));
1854         return d->cachedApplicationFilePath;
1855     } else {
1856         qWarning("QCoreApplication::applicationFilePath: _cmdname() failed");
1857         // _cmdname() won't fail, but just in case, fallback to the old method
1858         QDir dir(QStringLiteral("./app/native/"));
1859         QStringList executables = dir.entryList(QDir::Executable | QDir::Files);
1860         if (!executables.empty()) {
1861             //We assume that there is only one executable in the folder
1862             d->cachedApplicationFilePath = dir.absoluteFilePath(executables.first());
1863             return d->cachedApplicationFilePath;
1864         } else {
1865             return QString();
1866         }
1867     }
1868 #elif defined(Q_OS_MAC)
1869     QString qAppFileName_str = qAppFileName();
1870     if(!qAppFileName_str.isEmpty()) {
1871         QFileInfo fi(qAppFileName_str);
1872         d->cachedApplicationFilePath = fi.exists() ? fi.canonicalFilePath() : QString();
1873         return d->cachedApplicationFilePath;
1874     }
1875 #endif
1876 #if defined( Q_OS_UNIX )
1877 #  ifdef Q_OS_LINUX
1878     // Try looking for a /proc/<pid>/exe symlink first which points to
1879     // the absolute path of the executable
1880     QFileInfo pfi(QString::fromLatin1("/proc/%1/exe").arg(getpid()));
1881     if (pfi.exists() && pfi.isSymLink()) {
1882         d->cachedApplicationFilePath = pfi.canonicalFilePath();
1883         return d->cachedApplicationFilePath;
1884     }
1885 #  endif
1886 
1887     QString argv0 = QFile::decodeName(arguments().at(0).toLocal8Bit());
1888     QString absPath;
1889 
1890     if (!argv0.isEmpty() && argv0.at(0) == QLatin1Char('/')) {
1891         /*
1892           If argv0 starts with a slash, it is already an absolute
1893           file path.
1894         */
1895         absPath = argv0;
1896     } else if (argv0.contains(QLatin1Char('/'))) {
1897         /*
1898           If argv0 contains one or more slashes, it is a file path
1899           relative to the current directory.
1900         */
1901         absPath = QDir::current().absoluteFilePath(argv0);
1902     } else {
1903         /*
1904           Otherwise, the file path has to be determined using the
1905           PATH environment variable.
1906         */
1907         absPath = QStandardPaths::findExecutable(argv0);
1908     }
1909 
1910     absPath = QDir::cleanPath(absPath);
1911 
1912     QFileInfo fi(absPath);
1913     d->cachedApplicationFilePath = fi.exists() ? fi.canonicalFilePath() : QString();
1914     return d->cachedApplicationFilePath;
1915 #endif
1916 }
1917 
1918 /*!
1919     \since 4.4
1920 
1921     Returns the current process ID for the application.
1922 */
1923 qint64 QCoreApplication::applicationPid()
1924 {
1925 #if defined(Q_OS_WIN32) || defined(Q_OS_WINCE)
1926     return GetCurrentProcessId();
1927 #elif defined(Q_OS_VXWORKS)
1928     return (pid_t) taskIdCurrent;
1929 #else
1930     return getpid();
1931 #endif
1932 }
1933 
1934 /*!
1935     \since 4.1
1936 
1937     Returns the list of command-line arguments.
1938 
1939     Usually arguments().at(0) is the program name, arguments().at(1)
1940     is the first argument, and arguments().last() is the last
1941     argument. See the note below about Windows.
1942 
1943     Calling this function is slow - you should store the result in a variable
1944     when parsing the command line.
1945 
1946     \warning On Unix, this list is built from the argc and argv parameters passed
1947     to the constructor in the main() function. The string-data in argv is
1948     interpreted using QString::fromLocal8Bit(); hence it is not possible to
1949     pass, for example, Japanese command line arguments on a system that runs in a
1950     Latin1 locale. Most modern Unix systems do not have this limitation, as they are
1951     Unicode-based.
1952 
1953     On NT-based Windows, this limitation does not apply either.
1954     On Windows, the arguments() are not built from the contents of argv/argc, as
1955     the content does not support Unicode. Instead, the arguments() are constructed
1956     from the return value of
1957     \l{http://msdn2.microsoft.com/en-us/library/ms683156(VS.85).aspx}{GetCommandLine()}.
1958     As a result of this, the string given by arguments().at(0) might not be
1959     the program name on Windows, depending on how the application was started.
1960 
1961     \sa applicationFilePath()
1962 */
1963 
1964 QStringList QCoreApplication::arguments()
1965 {
1966     QStringList list;
1967 
1968     if (!self) {
1969         qWarning("QCoreApplication::arguments: Please instantiate the QApplication object first");
1970         return list;
1971     }
1972     const int ac = self->d_func()->argc;
1973     char ** const av = self->d_func()->argv;
1974     list.reserve(ac);
1975 
1976 #ifdef Q_OS_WIN
1977     // On Windows, it is possible to pass Unicode arguments on
1978     // the command line. To restore those, we split the command line
1979     // and filter out arguments that were deleted by derived application
1980     // classes by index.
1981     QString cmdline = QString::fromWCharArray(GetCommandLine());
1982 
1983 #if defined(Q_OS_WINCE)
1984     wchar_t tempFilename[MAX_PATH+1];
1985     if (GetModuleFileName(0, tempFilename, MAX_PATH)) {
1986         tempFilename[MAX_PATH] = 0;
1987         cmdline.prepend(QLatin1Char('\"') + QString::fromWCharArray(tempFilename) + QLatin1String("\" "));
1988     }
1989 #endif // Q_OS_WINCE
1990 
1991     char ** const origArgv = self->d_func()->origArgv;
1992     const int origArgc = self->d_func()->origArgc;
1993     char ** const avEnd = av + ac;
1994 
1995     const QStringList allArguments = qWinCmdArgs(cmdline);
1996     Q_ASSERT(allArguments.size() == origArgc);
1997     for (int i = 0; i < origArgc; ++i)
1998         if (qFind(av, avEnd, origArgv[i]) != avEnd)
1999             list.push_back(allArguments.at(i));
2000 
2001 #else
2002     for (int a = 0; a < ac; ++a) {
2003         list << QString::fromLocal8Bit(av[a]);
2004     }
2005 #endif
2006 
2007     return list;
2008 }
2009 
2010 /*!
2011     \property QCoreApplication::organizationName
2012     \brief the name of the organization that wrote this application
2013 
2014     The value is used by the QSettings class when it is constructed
2015     using the empty constructor. This saves having to repeat this
2016     information each time a QSettings object is created.
2017 
2018     On Mac, QSettings uses organizationDomain() as the organization
2019     if it's not an empty string; otherwise it uses
2020     organizationName(). On all other platforms, QSettings uses
2021     organizationName() as the organization.
2022 
2023     \sa organizationDomain, applicationName
2024 */
2025 
2026 void QCoreApplication::setOrganizationName(const QString &orgName)
2027 {
2028     coreappdata()->orgName = orgName;
2029 }
2030 
2031 QString QCoreApplication::organizationName()
2032 {
2033 #ifdef Q_OS_BLACKBERRY
2034     coreappdata()->loadManifest();
2035 #endif
2036     return coreappdata()->orgName;
2037 }
2038 
2039 /*!
2040     \property QCoreApplication::organizationDomain
2041     \brief the Internet domain of the organization that wrote this application
2042 
2043     The value is used by the QSettings class when it is constructed
2044     using the empty constructor. This saves having to repeat this
2045     information each time a QSettings object is created.
2046 
2047     On Mac, QSettings uses organizationDomain() as the organization
2048     if it's not an empty string; otherwise it uses organizationName().
2049     On all other platforms, QSettings uses organizationName() as the
2050     organization.
2051 
2052     \sa organizationName, applicationName, applicationVersion
2053 */
2054 void QCoreApplication::setOrganizationDomain(const QString &orgDomain)
2055 {
2056     coreappdata()->orgDomain = orgDomain;
2057 }
2058 
2059 QString QCoreApplication::organizationDomain()
2060 {
2061     return coreappdata()->orgDomain;
2062 }
2063 
2064 /*!
2065     \property QCoreApplication::applicationName
2066     \brief the name of this application
2067 
2068     The value is used by the QSettings class when it is constructed
2069     using the empty constructor. This saves having to repeat this
2070     information each time a QSettings object is created.
2071 
2072     If not set, the application name defaults to the executable name (since 5.0).
2073 
2074     \sa organizationName, organizationDomain, applicationVersion, applicationFilePath
2075 */
2076 void QCoreApplication::setApplicationName(const QString &application)
2077 {
2078     coreappdata()->application = application;
2079 }
2080 
2081 QString QCoreApplication::applicationName()
2082 {
2083 #ifdef Q_OS_BLACKBERRY
2084     coreappdata()->loadManifest();
2085 #endif
2086     QString appname = coreappdata() ? coreappdata()->application : QString();
2087     if (appname.isEmpty() && QCoreApplication::self)
2088         appname = QCoreApplication::self->d_func()->appName();
2089     return appname;
2090 }
2091 
2092 // Exported for QDesktopServices (Qt4 behavior compatibility)
2093 Q_CORE_EXPORT QString qt_applicationName_noFallback()
2094 {
2095     return coreappdata()->application;
2096 }
2097 
2098 /*!
2099     \property QCoreApplication::applicationVersion
2100     \since 4.4
2101     \brief the version of this application
2102 
2103     \sa applicationName, organizationName, organizationDomain
2104 */
2105 void QCoreApplication::setApplicationVersion(const QString &version)
2106 {
2107     coreappdata()->applicationVersion = version;
2108 }
2109 
2110 QString QCoreApplication::applicationVersion()
2111 {
2112 #ifdef Q_OS_BLACKBERRY
2113     coreappdata()->loadManifest();
2114 #endif
2115     return coreappdata()->applicationVersion;
2116 }
2117 
2118 #ifndef QT_NO_LIBRARY
2119 
2120 Q_GLOBAL_STATIC_WITH_ARGS(QMutex, libraryPathMutex, (QMutex::Recursive))
2121 
2122 /*!
2123     Returns a list of paths that the application will search when
2124     dynamically loading libraries.
2125 
2126     Qt provides default library paths, but they can also be set using
2127     a \l{Using qt.conf}{qt.conf} file. Paths specified in this file
2128     will override default values.
2129 
2130     This list will include the installation directory for plugins if
2131     it exists (the default installation directory for plugins is \c
2132     INSTALL/plugins, where \c INSTALL is the directory where Qt was
2133     installed).  The directory of the application executable (NOT the
2134     working directory) is always added, as well as the colon separated
2135     entries of the QT_PLUGIN_PATH environment variable.
2136 
2137     If you want to iterate over the list, you can use the \l foreach
2138     pseudo-keyword:
2139 
2140     \snippet code/src_corelib_kernel_qcoreapplication.cpp 2
2141 
2142     \sa setLibraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary,
2143         {How to Create Qt Plugins}
2144 */
2145 QStringList QCoreApplication::libraryPaths()
2146 {
2147     QMutexLocker locker(libraryPathMutex());
2148     if (!coreappdata()->app_libpaths) {
2149         QStringList *app_libpaths = coreappdata()->app_libpaths = new QStringList;
2150         QString installPathPlugins =  QLibraryInfo::location(QLibraryInfo::PluginsPath);
2151         if (QFile::exists(installPathPlugins)) {
2152             // Make sure we convert from backslashes to slashes.
2153             installPathPlugins = QDir(installPathPlugins).canonicalPath();
2154             if (!app_libpaths->contains(installPathPlugins))
2155                 app_libpaths->append(installPathPlugins);
2156         }
2157 
2158         // If QCoreApplication is not yet instantiated,
2159         // make sure we add the application path when we construct the QCoreApplication
2160         if (self) self->d_func()->appendApplicationPathToLibraryPaths();
2161 
2162         const QByteArray libPathEnv = qgetenv("QT_PLUGIN_PATH");
2163         if (!libPathEnv.isEmpty()) {
2164 #if defined(Q_OS_WIN)
2165             QLatin1Char pathSep(';');
2166 #else
2167             QLatin1Char pathSep(':');
2168 #endif
2169             QStringList paths = QFile::decodeName(libPathEnv).split(pathSep, QString::SkipEmptyParts);
2170             for (QStringList::const_iterator it = paths.constBegin(); it != paths.constEnd(); ++it) {
2171                 QString canonicalPath = QDir(*it).canonicalPath();
2172                 if (!canonicalPath.isEmpty()
2173                     && !app_libpaths->contains(canonicalPath)) {
2174                     app_libpaths->append(canonicalPath);
2175                 }
2176             }
2177         }
2178     }
2179     return *(coreappdata()->app_libpaths);
2180 }
2181 
2182 
2183 
2184 /*!
2185 
2186     Sets the list of directories to search when loading libraries to
2187     \a paths. All existing paths will be deleted and the path list
2188     will consist of the paths given in \a paths.
2189 
2190     \sa libraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary
2191  */
2192 void QCoreApplication::setLibraryPaths(const QStringList &paths)
2193 {
2194     QMutexLocker locker(libraryPathMutex());
2195     if (!coreappdata()->app_libpaths)
2196         coreappdata()->app_libpaths = new QStringList;
2197     *(coreappdata()->app_libpaths) = paths;
2198     locker.unlock();
2199     QFactoryLoader::refreshAll();
2200 }
2201 
2202 /*!
2203   Prepends \a path to the beginning of the library path list, ensuring that
2204   it is searched for libraries first. If \a path is empty or already in the
2205   path list, the path list is not changed.
2206 
2207   The default path list consists of a single entry, the installation
2208   directory for plugins.  The default installation directory for plugins
2209   is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was
2210   installed.
2211 
2212   \sa removeLibraryPath(), libraryPaths(), setLibraryPaths()
2213  */
2214 void QCoreApplication::addLibraryPath(const QString &path)
2215 {
2216     if (path.isEmpty())
2217         return;
2218 
2219     QMutexLocker locker(libraryPathMutex());
2220 
2221     // make sure that library paths is initialized
2222     libraryPaths();
2223 
2224     QString canonicalPath = QDir(path).canonicalPath();
2225     if (!canonicalPath.isEmpty()
2226         && !coreappdata()->app_libpaths->contains(canonicalPath)) {
2227         coreappdata()->app_libpaths->prepend(canonicalPath);
2228         locker.unlock();
2229         QFactoryLoader::refreshAll();
2230     }
2231 }
2232 
2233 /*!
2234     Removes \a path from the library path list. If \a path is empty or not
2235     in the path list, the list is not changed.
2236 
2237     \sa addLibraryPath(), libraryPaths(), setLibraryPaths()
2238 */
2239 void QCoreApplication::removeLibraryPath(const QString &path)
2240 {
2241     if (path.isEmpty())
2242         return;
2243 
2244     QMutexLocker locker(libraryPathMutex());
2245 
2246     // make sure that library paths is initialized
2247     libraryPaths();
2248 
2249     QString canonicalPath = QDir(path).canonicalPath();
2250     coreappdata()->app_libpaths->removeAll(canonicalPath);
2251     QFactoryLoader::refreshAll();
2252 }
2253 
2254 #endif //QT_NO_LIBRARY
2255 
2256 /*!
2257     Installs an event filter \a filterObj for all native events
2258     received by the application in the main thread.
2259 
2260     The event filter \a filterObj receives events via its nativeEventFilter()
2261     function, which is called for all native events received in the main thread.
2262 
2263     The nativeEventFilter() function should return true if the event should
2264     be filtered, (i.e. stopped). It should return false to allow
2265     normal Qt processing to continue: the native event can then be translated
2266     into a QEvent and handled by the standard Qt \l{QEvent} {event} filtering,
2267     e.g. QObject::installEventFilter().
2268 
2269     If multiple event filters are installed, the filter that was
2270     installed last is activated first.
2271 
2272     \note The filter function set here receives native messages,
2273     i.e. MSG or XCB event structs.
2274 
2275     For maximum portability, you should always try to use QEvents
2276     and QObject::installEventFilter() whenever possible.
2277 
2278     \sa QObject::installEventFilter()
2279 
2280     \since 5.0
2281 */
2282 void QCoreApplication::installNativeEventFilter(QAbstractNativeEventFilter *filterObj)
2283 {
2284     QAbstractEventDispatcher *eventDispatcher = QAbstractEventDispatcher::instance(QCoreApplicationPrivate::theMainThread);
2285     if (!filterObj || !eventDispatcher)
2286         return;
2287     eventDispatcher->installNativeEventFilter(filterObj);
2288 }
2289 
2290 /*!
2291     Removes an event \a filterObject from this object. The
2292     request is ignored if such an event filter has not been installed.
2293 
2294     All event filters for this object are automatically removed when
2295     this object is destroyed.
2296 
2297     It is always safe to remove an event filter, even during event
2298     filter activation (i.e. from the nativeEventFilter() function).
2299 
2300     \sa installNativeEventFilter()
2301     \since 5.0
2302 */
2303 void QCoreApplication::removeNativeEventFilter(QAbstractNativeEventFilter *filterObject)
2304 {
2305     QAbstractEventDispatcher *eventDispatcher = QAbstractEventDispatcher::instance();
2306     if (!filterObject || !eventDispatcher)
2307         return;
2308     eventDispatcher->removeNativeEventFilter(filterObject);
2309 }
2310 
2311 /*!
2312     This function returns true if there are pending events; otherwise
2313     returns false. Pending events can be either from the window
2314     system or posted events using postEvent().
2315 
2316     \sa QAbstractEventDispatcher::hasPendingEvents()
2317 */
2318 bool QCoreApplication::hasPendingEvents()
2319 {
2320     QAbstractEventDispatcher *eventDispatcher = QAbstractEventDispatcher::instance();
2321     if (eventDispatcher)
2322         return eventDispatcher->hasPendingEvents();
2323     return false;
2324 }
2325 
2326 /*!
2327     Returns a pointer to the event dispatcher object for the main thread. If no
2328     event dispatcher exists for the thread, this function returns 0.
2329 */
2330 QAbstractEventDispatcher *QCoreApplication::eventDispatcher()
2331 {
2332     if (QCoreApplicationPrivate::theMainThread)
2333         return QCoreApplicationPrivate::theMainThread->eventDispatcher();
2334     return 0;
2335 }
2336 
2337 /*!
2338     Sets the event dispatcher for the main thread to \a eventDispatcher. This
2339     is only possible as long as there is no event dispatcher installed yet. That
2340     is, before QCoreApplication has been instantiated. This method takes
2341     ownership of the object.
2342 */
2343 void QCoreApplication::setEventDispatcher(QAbstractEventDispatcher *eventDispatcher)
2344 {
2345     QThread *mainThread = QCoreApplicationPrivate::theMainThread;
2346     if (!mainThread)
2347         mainThread = QThread::currentThread(); // will also setup theMainThread
2348     mainThread->setEventDispatcher(eventDispatcher);
2349 }
2350 
2351 /*!
2352     \macro Q_COREAPP_STARTUP_FUNCTION(QtStartUpFunction ptr)
2353     \since 5.1
2354     \relates QCoreApplication
2355 
2356     Adds a global routine that will be called from the QCoreApplication
2357     constructor. This macro is normally used to initialize libraries
2358     for program-wide functionality, without requiring the application to
2359     call into the library for initialization.
2360 
2361     The function specified by \a ptr should take no arguments and should
2362     return nothing. For example:
2363 
2364     \snippet code/src_corelib_kernel_qcoreapplication.cpp 3
2365 
2366     Note that the pre routine will run at the end of the QCoreApplication constructor,
2367     before any GUI initialization. If GUI code is required in the routine,
2368     use a timer (or a queued invocation) to perform the initialization later on,
2369     from the event loop.
2370 */
2371 
2372 /*!
2373     \internal
2374     \fn void qAddPreRoutine(QtStartUpFunction ptr)
2375 
2376     Adds a global routine that will be called from the QCoreApplication
2377     constructor. The public API is Q_COREAPP_STARTUP_FUNCTION.
2378 */
2379 
2380 /*!
2381     \fn void qAddPostRoutine(QtCleanUpFunction ptr)
2382     \relates QCoreApplication
2383 
2384     Adds a global routine that will be called from the QApplication
2385     destructor. This function is normally used to add cleanup routines
2386     for program-wide functionality.
2387 
2388     The function specified by \a ptr should take no arguments and should
2389     return nothing. For example:
2390 
2391     \snippet code/src_corelib_kernel_qcoreapplication.cpp 4
2392 
2393     Note that for an application- or module-wide cleanup,
2394     qAddPostRoutine() is often not suitable. For example, if the
2395     program is split into dynamically loaded modules, the relevant
2396     module may be unloaded long before the QApplication destructor is
2397     called.
2398 
2399     For modules and libraries, using a reference-counted
2400     initialization manager or Qt's parent-child deletion mechanism may
2401     be better. Here is an example of a private class that uses the
2402     parent-child mechanism to call a cleanup function at the right
2403     time:
2404 
2405     \snippet code/src_corelib_kernel_qcoreapplication.cpp 5
2406 
2407     By selecting the right parent object, this can often be made to
2408     clean up the module's data at the right moment.
2409 */
2410 
2411 /*!
2412     \macro Q_DECLARE_TR_FUNCTIONS(context)
2413     \relates QCoreApplication
2414 
2415     The Q_DECLARE_TR_FUNCTIONS() macro declares and implements two
2416     translation functions, \c tr() and \c trUtf8(), with these
2417     signatures:
2418 
2419     \snippet code/src_corelib_kernel_qcoreapplication.cpp 6
2420 
2421     This macro is useful if you want to use QObject::tr() or
2422     QObject::trUtf8() in classes that don't inherit from QObject.
2423 
2424     Q_DECLARE_TR_FUNCTIONS() must appear at the very top of the
2425     class definition (before the first \c{public:} or \c{protected:}).
2426     For example:
2427 
2428     \snippet code/src_corelib_kernel_qcoreapplication.cpp 7
2429 
2430     The \a context parameter is normally the class name, but it can
2431     be any string.
2432 
2433     \sa Q_OBJECT, QObject::tr(), QObject::trUtf8()
2434 */
2435 
2436 QT_END_NAMESPACE
