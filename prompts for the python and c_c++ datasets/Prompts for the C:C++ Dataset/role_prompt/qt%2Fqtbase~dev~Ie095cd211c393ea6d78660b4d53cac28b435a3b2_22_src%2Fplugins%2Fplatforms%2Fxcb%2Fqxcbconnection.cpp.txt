I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the plugins of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 #include <QtGui/private/qguiapplication_p.h>
41 #include <QtGui/private/qhighdpiscaling_p.h>
42 #include <QtCore/QDebug>
43 
44 #include "qxcbconnection.h"
45 #include "qxcbkeyboard.h"
46 #include "qxcbscreen.h"
47 #include "qxcbwindow.h"
48 #include "qxcbclipboard.h"
49 #include "qxcbdrag.h"
50 #include "qxcbwmsupport.h"
51 #include "qxcbnativeinterface.h"
52 #include "qxcbintegration.h"
53 #include "qxcbsystemtraytracker.h"
54 #include "qxcbglintegrationfactory.h"
55 #include "qxcbglintegration.h"
56 
57 #include <QSocketNotifier>
58 #include <QAbstractEventDispatcher>
59 #include <QTimer>
60 #include <QByteArray>
61 #include <QScopedPointer>
62 
63 #include <algorithm>
64 
65 #include <stdio.h>
66 #include <errno.h>
67 #include <xcb/shm.h>
68 #include <xcb/sync.h>
69 #include <xcb/xfixes.h>
70 #include <xcb/xinerama.h>
71 
72 #if QT_CONFIG(xcb_xlib)
73 #include <X11/Xlib.h>
74 #include <X11/Xlib-xcb.h>
75 #include <X11/Xlibint.h>
76 #include <X11/Xutil.h>
77 #endif
78 
79 #if QT_CONFIG(xinput2)
80 #include <X11/extensions/XI2proto.h>
81 #endif
82 
83 #if QT_CONFIG(xcb_render)
84 #include <xcb/render.h>
85 #endif
86 
87 #if defined(Q_CC_GNU) && defined(Q_OF_ELF)
88 static xcb_generic_event_t *local_xcb_poll_for_queued_event(xcb_connection_t *c)
89     __attribute__((weakref("xcb_poll_for_queued_event")));
90 
91 static inline void checkXcbPollForQueuedEvent()
92 { }
93 #else
94 #include <dlfcn.h>
95 typedef xcb_generic_event_t * (*XcbPollForQueuedEventFunctionPointer)(xcb_connection_t *c);
96 static XcbPollForQueuedEventFunctionPointer local_xcb_poll_for_queued_event;
97 
98 static inline void checkXcbPollForQueuedEvent()
99 {
100 #ifdef RTLD_DEFAULT
101     local_xcb_poll_for_queued_event = (XcbPollForQueuedEventFunctionPointer)dlsym(RTLD_DEFAULT, "xcb_poll_for_queued_event");
102 #endif
103 }
104 #endif
105 
106 QT_BEGIN_NAMESPACE
107 
108 Q_LOGGING_CATEGORY(lcQpaXInput, "qt.qpa.input")
109 Q_LOGGING_CATEGORY(lcQpaXInputDevices, "qt.qpa.input.devices")
110 Q_LOGGING_CATEGORY(lcQpaXInputEvents, "qt.qpa.input.events")
111 Q_LOGGING_CATEGORY(lcQpaScreen, "qt.qpa.screen")
112 Q_LOGGING_CATEGORY(lcQpaEvents, "qt.qpa.events")
113 Q_LOGGING_CATEGORY(lcQpaXcb, "qt.qpa.xcb") // for general (uncategorized) XCB logging
114 Q_LOGGING_CATEGORY(lcQpaPeeker, "qt.qpa.peeker")
115 
116 // this event type was added in libxcb 1.10,
117 // but we support also older version
118 #ifndef XCB_GE_GENERIC
119 #define XCB_GE_GENERIC 35
120 #endif
121 
122 #if QT_CONFIG(xinput2)
123 // Starting from the xcb version 1.9.3 struct xcb_ge_event_t has changed:
124 // - "pad0" became "extension"
125 // - "pad1" and "pad" became "pad0"
126 // New and old version of this struct share the following fields:
127 typedef struct qt_xcb_ge_event_t {
128     uint8_t  response_type;
129     uint8_t  extension;
130     uint16_t sequence;
131     uint32_t length;
132     uint16_t event_type;
133 } qt_xcb_ge_event_t;
134 
135 static inline bool isXIEvent(xcb_generic_event_t *event, int opCode)
136 {
137     qt_xcb_ge_event_t *e = reinterpret_cast<qt_xcb_ge_event_t *>(event);
138     return e->extension == opCode;
139 }
140 #endif // QT_CONFIG(xinput2)
141 
142 #if QT_CONFIG(xcb_xlib)
143 static const char * const xcbConnectionErrors[] = {
144     "No error", /* Error 0 */
145     "I/O error", /* XCB_CONN_ERROR */
146     "Unsupported extension used", /* XCB_CONN_CLOSED_EXT_NOTSUPPORTED */
147     "Out of memory", /* XCB_CONN_CLOSED_MEM_INSUFFICIENT */
148     "Maximum allowed requested length exceeded", /* XCB_CONN_CLOSED_REQ_LEN_EXCEED */
149     "Failed to parse display string", /* XCB_CONN_CLOSED_PARSE_ERR */
150     "No such screen on display", /* XCB_CONN_CLOSED_INVALID_SCREEN */
151     "Error during FD passing" /* XCB_CONN_CLOSED_FDPASSING_FAILED */
152 };
153 
154 static int nullErrorHandler(Display *dpy, XErrorEvent *err)
155 {
156 #ifndef Q_XCB_DEBUG
157     Q_UNUSED(dpy);
158     Q_UNUSED(err);
159 #else
160     const int buflen = 1024;
161     char buf[buflen];
162 
163     XGetErrorText(dpy, err->error_code, buf, buflen);
164     fprintf(stderr, "X Error: serial %lu error %d %s\n", err->serial, (int) err->error_code, buf);
165 #endif
166     return 0;
167 }
168 
169 static int ioErrorHandler(Display *dpy)
170 {
171     xcb_connection_t *conn = XGetXCBConnection(dpy);
172     if (conn != NULL) {
173         /* Print a message with a textual description of the error */
174         int code = xcb_connection_has_error(conn);
175         const char *str = "Unknown error";
176         int arrayLength = sizeof(xcbConnectionErrors) / sizeof(xcbConnectionErrors[0]);
177         if (code >= 0 && code < arrayLength)
178             str = xcbConnectionErrors[code];
179 
180         qWarning("The X11 connection broke: %s (code %d)", str, code);
181     }
182     return _XDefaultIOError(dpy);
183 }
184 #endif
185 
186 QXcbScreen* QXcbConnection::findScreenForCrtc(xcb_window_t rootWindow, xcb_randr_crtc_t crtc) const
187 {
188     for (QXcbScreen *screen : m_screens) {
189         if (screen->root() == rootWindow && screen->crtc() == crtc)
190             return screen;
191     }
192 
193     return 0;
194 }
195 
196 QXcbScreen* QXcbConnection::findScreenForOutput(xcb_window_t rootWindow, xcb_randr_output_t output) const
197 {
198     for (QXcbScreen *screen : m_screens) {
199         if (screen->root() == rootWindow && screen->output() == output)
200             return screen;
201     }
202 
203     return 0;
204 }
205 
206 QXcbVirtualDesktop* QXcbConnection::virtualDesktopForRootWindow(xcb_window_t rootWindow) const
207 {
208     for (QXcbVirtualDesktop *virtualDesktop : m_virtualDesktops) {
209         if (virtualDesktop->screen()->root == rootWindow)
210             return virtualDesktop;
211     }
212 
213     return 0;
214 }
215 
216 /*!
217     \brief Synchronizes the screen list, adds new screens, removes deleted ones
218 */
219 void QXcbConnection::updateScreens(const xcb_randr_notify_event_t *event)
220 {
221     if (event->subCode == XCB_RANDR_NOTIFY_CRTC_CHANGE) {
222         xcb_randr_crtc_change_t crtc = event->u.cc;
223         QXcbVirtualDesktop *virtualDesktop = virtualDesktopForRootWindow(crtc.window);
224         if (!virtualDesktop)
225             // Not for us
226             return;
227 
228         QXcbScreen *screen = findScreenForCrtc(crtc.window, crtc.crtc);
229         qCDebug(lcQpaScreen) << "QXcbConnection: XCB_RANDR_NOTIFY_CRTC_CHANGE:" << crtc.crtc
230                              << "mode" << crtc.mode << "relevant screen" << screen;
231         // Only update geometry when there's a valid mode on the CRTC
232         // CRTC with node mode could mean that output has been disabled, and we'll
233         // get RRNotifyOutputChange notification for that.
234         if (screen && crtc.mode) {
235             if (crtc.rotation == XCB_RANDR_ROTATION_ROTATE_90 ||
236                 crtc.rotation == XCB_RANDR_ROTATION_ROTATE_270)
237                 std::swap(crtc.width, crtc.height);
238             screen->updateGeometry(QRect(crtc.x, crtc.y, crtc.width, crtc.height), crtc.rotation);
239             if (screen->mode() != crtc.mode)
240                 screen->updateRefreshRate(crtc.mode);
241         }
242 
243     } else if (event->subCode == XCB_RANDR_NOTIFY_OUTPUT_CHANGE) {
244         xcb_randr_output_change_t output = event->u.oc;
245         QXcbVirtualDesktop *virtualDesktop = virtualDesktopForRootWindow(output.window);
246         if (!virtualDesktop)
247             // Not for us
248             return;
249 
250         QXcbScreen *screen = findScreenForOutput(output.window, output.output);
251         qCDebug(lcQpaScreen) << "QXcbConnection: XCB_RANDR_NOTIFY_OUTPUT_CHANGE:" << output.output;
252 
253         if (screen && output.connection == XCB_RANDR_CONNECTION_DISCONNECTED) {
254             qCDebug(lcQpaScreen) << "screen" << screen->name() << "has been disconnected";
255             destroyScreen(screen);
256         } else if (!screen && output.connection == XCB_RANDR_CONNECTION_CONNECTED) {
257             // New XRandR output is available and it's enabled
258             if (output.crtc != XCB_NONE && output.mode != XCB_NONE) {
259                 auto outputInfo = Q_XCB_REPLY(xcb_randr_get_output_info, xcb_connection(),
260                                               output.output, output.config_timestamp);
261                 // Find a fake screen
262                 const auto scrs = virtualDesktop->screens();
263                 for (QPlatformScreen *scr : scrs) {
264                     QXcbScreen *xcbScreen = static_cast<QXcbScreen *>(scr);
265                     if (xcbScreen->output() == XCB_NONE) {
266                         screen = xcbScreen;
267                         break;
268                     }
269                 }
270 
271                 if (screen) {
272                     QString nameWas = screen->name();
273                     // Transform the fake screen into a physical screen
274                     screen->setOutput(output.output, outputInfo.get());
275                     updateScreen(screen, output);
276                     qCDebug(lcQpaScreen) << "output" << screen->name()
277                                          << "is connected and enabled; was fake:" << nameWas;
278                 } else {
279                     screen = createScreen(virtualDesktop, output, outputInfo.get());
280                     qCDebug(lcQpaScreen) << "output" << screen->name() << "is connected and enabled";
281                 }
282                 QHighDpiScaling::updateHighDpiScaling();
283             }
284         } else if (screen) {
285             if (output.crtc == XCB_NONE && output.mode == XCB_NONE) {
286                 // Screen has been disabled
287                 auto outputInfo = Q_XCB_REPLY(xcb_randr_get_output_info, xcb_connection(),
288                                               output.output, output.config_timestamp);
289                 if (outputInfo->crtc == XCB_NONE) {
290                     qCDebug(lcQpaScreen) << "output" << screen->name() << "has been disabled";
291                     destroyScreen(screen);
292                 } else {
293                     qCDebug(lcQpaScreen) << "output" << screen->name() << "has been temporarily disabled for the mode switch";
294                     // Reset crtc to skip RRCrtcChangeNotify events,
295                     // because they may be invalid in the middle of the mode switch
296                     screen->setCrtc(XCB_NONE);
297                 }
298             } else {
299                 updateScreen(screen, output);
300                 qCDebug(lcQpaScreen) << "output has changed" << screen;
301             }
302         }
303 
304         qCDebug(lcQpaScreen) << "primary output is" << qAsConst(m_screens).first()->name();
305     }
306 }
307 
308 bool QXcbConnection::checkOutputIsPrimary(xcb_window_t rootWindow, xcb_randr_output_t output)
309 {
310     auto primary = Q_XCB_REPLY(xcb_randr_get_output_primary, xcb_connection(), rootWindow);
311     if (!primary)
312         qWarning("failed to get the primary output of the screen");
313 
314     const bool isPrimary = primary ? (primary->output == output) : false;
315 
316     return isPrimary;
317 }
318 
319 void QXcbConnection::updateScreen(QXcbScreen *screen, const xcb_randr_output_change_t &outputChange)
320 {
321     screen->setCrtc(outputChange.crtc); // Set the new crtc, because it can be invalid
322     screen->updateGeometry(outputChange.config_timestamp);
323     if (screen->mode() != outputChange.mode)
324         screen->updateRefreshRate(outputChange.mode);
325     // Only screen which belongs to the primary virtual desktop can be a primary screen
326     if (screen->screenNumber() == m_primaryScreenNumber) {
327         if (!screen->isPrimary() && checkOutputIsPrimary(outputChange.window, outputChange.output)) {
328             screen->setPrimary(true);
329 
330             // If the screen became primary, reshuffle the order in QGuiApplicationPrivate
331             const int idx = m_screens.indexOf(screen);
332             if (idx > 0) {
333                 qAsConst(m_screens).first()->setPrimary(false);
334                 m_screens.swap(0, idx);
335             }
336             screen->virtualDesktop()->setPrimaryScreen(screen);
337             QXcbIntegration::instance()->setPrimaryScreen(screen);
338         }
339     }
340 }
341 
342 QXcbScreen *QXcbConnection::createScreen(QXcbVirtualDesktop *virtualDesktop,
343                                          const xcb_randr_output_change_t &outputChange,
344                                          xcb_randr_get_output_info_reply_t *outputInfo)
345 {
346     QXcbScreen *screen = new QXcbScreen(this, virtualDesktop, outputChange.output, outputInfo);
347     // Only screen which belongs to the primary virtual desktop can be a primary screen
348     if (screen->screenNumber() == m_primaryScreenNumber)
349         screen->setPrimary(checkOutputIsPrimary(outputChange.window, outputChange.output));
350 
351     if (screen->isPrimary()) {
352         if (!m_screens.isEmpty())
353             qAsConst(m_screens).first()->setPrimary(false);
354 
355         m_screens.prepend(screen);
356     } else {
357         m_screens.append(screen);
358     }
359     virtualDesktop->addScreen(screen);
360     QXcbIntegration::instance()->screenAdded(screen, screen->isPrimary());
361 
362     return screen;
363 }
364 
365 void QXcbConnection::destroyScreen(QXcbScreen *screen)
366 {
367     QXcbVirtualDesktop *virtualDesktop = screen->virtualDesktop();
368     if (virtualDesktop->screens().count() == 1) {
369         // If there are no other screens on the same virtual desktop,
370         // then transform the physical screen into a fake screen.
371         const QString nameWas = screen->name();
372         screen->setOutput(XCB_NONE, Q_NULLPTR);
373         qCDebug(lcQpaScreen) << "transformed" << nameWas << "to fake" << screen;
374     } else {
375         // There is more than one screen on the same virtual desktop, remove the screen
376         m_screens.removeOne(screen);
377         virtualDesktop->removeScreen(screen);
378 
379         // When primary screen is removed, set the new primary screen
380         // which belongs to the primary virtual desktop.
381         if (screen->isPrimary()) {
382             QXcbScreen *newPrimary = static_cast<QXcbScreen *>(virtualDesktop->screens().at(0));
383             newPrimary->setPrimary(true);
384             const int idx = m_screens.indexOf(newPrimary);
385             if (idx > 0)
386                 m_screens.swap(0, idx);
387             QXcbIntegration::instance()->setPrimaryScreen(newPrimary);
388         }
389 
390         QXcbIntegration::instance()->destroyScreen(screen);
391     }
392 }
393 
394 void QXcbConnection::initializeScreens()
395 {
396     xcb_screen_iterator_t it = xcb_setup_roots_iterator(m_setup);
397     int xcbScreenNumber = 0;    // screen number in the xcb sense
398     QXcbScreen *primaryScreen = Q_NULLPTR;
399     while (it.rem) {
400         // Each "screen" in xcb terminology is a virtual desktop,
401         // potentially a collection of separate juxtaposed monitors.
402         // But we want a separate QScreen for each output (e.g. DVI-I-1, VGA-1, etc.)
403         // which will become virtual siblings.
404         xcb_screen_t *xcbScreen = it.data;
405         QXcbVirtualDesktop *virtualDesktop = new QXcbVirtualDesktop(this, xcbScreen, xcbScreenNumber);
406         m_virtualDesktops.append(virtualDesktop);
407         QList<QPlatformScreen *> siblings;
408         if (has_randr_extension) {
409             // RRGetScreenResourcesCurrent is fast but it may return nothing if the
410             // configuration is not initialized wrt to the hardware. We should call
411             // RRGetScreenResources in this case.
412             auto resources_current = Q_XCB_REPLY(xcb_randr_get_screen_resources_current,
413                                                  xcb_connection(), xcbScreen->root);
414             if (!resources_current) {
415                 qWarning("failed to get the current screen resources");
416             } else {
417                 xcb_timestamp_t timestamp = 0;
418                 xcb_randr_output_t *outputs = Q_NULLPTR;
419                 int outputCount = xcb_randr_get_screen_resources_current_outputs_length(resources_current.get());
420                 if (outputCount) {
421                     timestamp = resources_current->config_timestamp;
422                     outputs = xcb_randr_get_screen_resources_current_outputs(resources_current.get());
423                 } else {
424                     auto resources = Q_XCB_REPLY(xcb_randr_get_screen_resources,
425                                                  xcb_connection(), xcbScreen->root);
426                     if (!resources) {
427                         qWarning("failed to get the screen resources");
428                     } else {
429                         timestamp = resources->config_timestamp;
430                         outputCount = xcb_randr_get_screen_resources_outputs_length(resources.get());
431                         outputs = xcb_randr_get_screen_resources_outputs(resources.get());
432                     }
433                 }
434 
435                 if (outputCount) {
436                     auto primary = Q_XCB_REPLY(xcb_randr_get_output_primary, xcb_connection(), xcbScreen->root);
437                     if (!primary) {
438                         qWarning("failed to get the primary output of the screen");
439                     } else {
440                         for (int i = 0; i < outputCount; i++) {
441                             auto output = Q_XCB_REPLY_UNCHECKED(xcb_randr_get_output_info,
442                                                                 xcb_connection(), outputs[i], timestamp);
443                             // Invalid, disconnected or disabled output
444                             if (!output)
445                                 continue;
446 
447                             if (output->connection != XCB_RANDR_CONNECTION_CONNECTED) {
448                                 qCDebug(lcQpaScreen, "Output %s is not connected", qPrintable(
449                                             QString::fromUtf8((const char*)xcb_randr_get_output_info_name(output.get()),
450                                                               xcb_randr_get_output_info_name_length(output.get()))));
451                                 continue;
452                             }
453 
454                             if (output->crtc == XCB_NONE) {
455                                 qCDebug(lcQpaScreen, "Output %s is not enabled", qPrintable(
456                                             QString::fromUtf8((const char*)xcb_randr_get_output_info_name(output.get()),
457                                                               xcb_randr_get_output_info_name_length(output.get()))));
458                                 continue;
459                             }
460 
461                             QXcbScreen *screen = new QXcbScreen(this, virtualDesktop, outputs[i], output.get());
462                             siblings << screen;
463                             m_screens << screen;
464 
465                             // There can be multiple outputs per screen, use either
466                             // the first or an exact match.  An exact match isn't
467                             // always available if primary->output is XCB_NONE
468                             // or currently disconnected output.
469                             if (m_primaryScreenNumber == xcbScreenNumber) {
470                                 if (!primaryScreen || (primary && outputs[i] == primary->output)) {
471                                     if (primaryScreen)
472                                         primaryScreen->setPrimary(false);
473                                     primaryScreen = screen;
474                                     primaryScreen->setPrimary(true);
475                                     siblings.prepend(siblings.takeLast());
476                                 }
477                             }
478                         }
479                     }
480                 }
481             }
482         } else if (has_xinerama_extension) {
483             // Xinerama is available
484             auto screens = Q_XCB_REPLY(xcb_xinerama_query_screens, m_connection);
485             if (screens) {
486                 xcb_xinerama_screen_info_iterator_t it = xcb_xinerama_query_screens_screen_info_iterator(screens.get());
487                 while (it.rem) {
488                     xcb_xinerama_screen_info_t *screen_info = it.data;
489                     QXcbScreen *screen = new QXcbScreen(this, virtualDesktop,
490                                                         XCB_NONE, Q_NULLPTR,
491                                                         screen_info, it.index);
492                     siblings << screen;
493                     m_screens << screen;
494                     xcb_xinerama_screen_info_next(&it);
495                 }
496             }
497         }
498         if (siblings.isEmpty()) {
499             // If there are no XRandR outputs or XRandR extension is missing,
500             // then create a fake/legacy screen.
501             QXcbScreen *screen = new QXcbScreen(this, virtualDesktop, XCB_NONE, Q_NULLPTR);
502             qCDebug(lcQpaScreen) << "created fake screen" << screen;
503             m_screens << screen;
504             if (m_primaryScreenNumber == xcbScreenNumber) {
505                 primaryScreen = screen;
506                 primaryScreen->setPrimary(true);
507             }
508             siblings << screen;
509         }
510         virtualDesktop->setScreens(siblings);
511         xcb_screen_next(&it);
512         ++xcbScreenNumber;
513     } // for each xcb screen
514 
515     for (QXcbVirtualDesktop *virtualDesktop : qAsConst(m_virtualDesktops))
516         virtualDesktop->subscribeToXFixesSelectionNotify();
517 
518     if (m_virtualDesktops.isEmpty()) {
519         qFatal("QXcbConnection: no screens available");
520     } else {
521         // Ensure the primary screen is first on the list
522         if (primaryScreen) {
523             if (qAsConst(m_screens).first() != primaryScreen) {
524                 m_screens.removeOne(primaryScreen);
525                 m_screens.prepend(primaryScreen);
526             }
527         }
528 
529         // Push the screens to QGuiApplication
530         for (QXcbScreen *screen : qAsConst(m_screens)) {
531             qCDebug(lcQpaScreen) << "adding" << screen << "(Primary:" << screen->isPrimary() << ")";
532             QXcbIntegration::instance()->screenAdded(screen, screen->isPrimary());
533         }
534 
535         qCDebug(lcQpaScreen) << "primary output is" << qAsConst(m_screens).first()->name();
536     }
537 }
538 
539 QXcbConnection::QXcbConnection(QXcbNativeInterface *nativeInterface, bool canGrabServer, xcb_visualid_t defaultVisualId, const char *displayName)
540     : m_canGrabServer(canGrabServer)
541     , m_defaultVisualId(defaultVisualId)
542     , m_displayName(displayName ? QByteArray(displayName) : qgetenv("DISPLAY"))
543     , m_nativeInterface(nativeInterface)
544 {
545 #if QT_CONFIG(xcb_xlib)
546     Display *dpy = XOpenDisplay(m_displayName.constData());
547     if (dpy) {
548         m_primaryScreenNumber = DefaultScreen(dpy);
549         m_connection = XGetXCBConnection(dpy);
550         XSetEventQueueOwner(dpy, XCBOwnsEventQueue);
551         XSetErrorHandler(nullErrorHandler);
552         XSetIOErrorHandler(ioErrorHandler);
553         m_xlib_display = dpy;
554     }
555 #else
556     m_connection = xcb_connect(m_displayName.constData(), &m_primaryScreenNumber);
557 #endif // QT_CONFIG(xcb_xlib)
558 
559     if (Q_UNLIKELY(!m_connection || xcb_connection_has_error(m_connection)))
560         qFatal("QXcbConnection: Could not connect to display %s", m_displayName.constData());
561 
562 
563     m_reader = new QXcbEventReader(this);
564     m_reader->start();
565 
566     xcb_extension_t *extensions[] = {
567         &xcb_shm_id, &xcb_xfixes_id, &xcb_randr_id, &xcb_shape_id, &xcb_sync_id,
568 #if QT_CONFIG(xkb)
569         &xcb_xkb_id,
570 #endif
571 #if QT_CONFIG(xcb_render)
572         &xcb_render_id,
573 #endif
574         0
575     };
576 
577     for (xcb_extension_t **ext_it = extensions; *ext_it; ++ext_it)
578         xcb_prefetch_extension_data (m_connection, *ext_it);
579 
580     m_setup = xcb_get_setup(xcb_connection());
581 
582     initializeAllAtoms();
583 
584     if (!qEnvironmentVariableIsSet("QT_XCB_NO_XRANDR"))
585         initializeXRandr();
586     if (!has_randr_extension)
587         initializeXinerama();
588     initializeXFixes();
589     initializeScreens();
590 
591     initializeXRender();
592 #if QT_CONFIG(xinput2)
593     if (!qEnvironmentVariableIsSet("QT_XCB_NO_XI2"))
594         initializeXInput2();
595 #endif
596     initializeXShape();
597     initializeXKB();
598 
599     m_wmSupport.reset(new QXcbWMSupport(this));
600     m_keyboard = new QXcbKeyboard(this);
601 #ifndef QT_NO_CLIPBOARD
602     m_clipboard = new QXcbClipboard(this);
603 #endif
604 #ifndef QT_NO_DRAGANDDROP
605     m_drag = new QXcbDrag(this);
606 #endif
607 
608     m_startupId = qgetenv("DESKTOP_STARTUP_ID");
609     if (!m_startupId.isNull())
610         qunsetenv("DESKTOP_STARTUP_ID");
611 
612 
613     QStringList glIntegrationNames;
614     glIntegrationNames << QStringLiteral("xcb_glx") << QStringLiteral("xcb_egl");
615     QString glIntegrationName = QString::fromLocal8Bit(qgetenv("QT_XCB_GL_INTEGRATION"));
616     if (!glIntegrationName.isEmpty()) {
617         qCDebug(lcQpaGl) << "QT_XCB_GL_INTEGRATION is set to" << glIntegrationName;
618         if (glIntegrationName != QLatin1String("none")) {
619             glIntegrationNames.removeAll(glIntegrationName);
620             glIntegrationNames.prepend(glIntegrationName);
621         } else {
622             glIntegrationNames.clear();
623         }
624     }
625 
626     if (!glIntegrationNames.isEmpty()) {
627         qCDebug(lcQpaGl) << "Choosing xcb gl-integration based on following priority\n" << glIntegrationNames;
628         for (int i = 0; i < glIntegrationNames.size() && !m_glIntegration; i++) {
629             m_glIntegration = QXcbGlIntegrationFactory::create(glIntegrationNames.at(i));
630             if (m_glIntegration && !m_glIntegration->initialize(this)) {
631                 qCDebug(lcQpaGl) << "Failed to initialize xcb gl-integration" << glIntegrationNames.at(i);
632                 delete m_glIntegration;
633                 m_glIntegration = Q_NULLPTR;
634             }
635         }
636         if (!m_glIntegration)
637             qCDebug(lcQpaGl) << "Failed to create xcb gl-integration";
638     }
639 
640     sync();
641 }
642 
643 QXcbConnection::~QXcbConnection()
644 {
645 #ifndef QT_NO_CLIPBOARD
646     delete m_clipboard;
647 #endif
648 #ifndef QT_NO_DRAGANDDROP
649     delete m_drag;
650 #endif
651     if (m_reader->isRunning()) {
652         sendConnectionEvent(QXcbAtom::_QT_CLOSE_CONNECTION);
653         m_reader->wait();
654     }
655 
656     delete m_reader;
657 
658     QXcbIntegration *integration = QXcbIntegration::instance();
659     // Delete screens in reverse order to avoid crash in case of multiple screens
660     while (!m_screens.isEmpty())
661         integration->destroyScreen(m_screens.takeLast());
662 
663     while (!m_virtualDesktops.isEmpty())
664         delete m_virtualDesktops.takeLast();
665 
666     delete m_glIntegration;
667 
668 #if QT_CONFIG(xcb_xlib)
669     XCloseDisplay(static_cast<Display *>(m_xlib_display));
670 #else
671     xcb_disconnect(xcb_connection());
672 #endif
673 
674     delete m_keyboard;
675 }
676 
677 QXcbScreen *QXcbConnection::primaryScreen() const
678 {
679     if (!m_screens.isEmpty()) {
680         Q_ASSERT(m_screens.first()->screenNumber() == primaryScreenNumber());
681         return m_screens.first();
682     }
683 
684     return Q_NULLPTR;
685 }
686 
687 void QXcbConnection::addWindowEventListener(xcb_window_t id, QXcbWindowEventListener *eventListener)
688 {
689     m_mapper.insert(id, eventListener);
690 }
691 
692 void QXcbConnection::removeWindowEventListener(xcb_window_t id)
693 {
694     m_mapper.remove(id);
695 }
696 
697 QXcbWindowEventListener *QXcbConnection::windowEventListenerFromId(xcb_window_t id)
698 {
699     return m_mapper.value(id, 0);
700 }
701 
702 QXcbWindow *QXcbConnection::platformWindowFromId(xcb_window_t id)
703 {
704     QXcbWindowEventListener *listener = m_mapper.value(id, 0);
705     if (listener)
706         return listener->toWindow();
707     return 0;
708 }
709 
710 #define HANDLE_PLATFORM_WINDOW_EVENT(event_t, windowMember, handler) \
711 { \
712     event_t *e = reinterpret_cast<event_t *>(event); \
713     if (QXcbWindowEventListener *eventListener = windowEventListenerFromId(e->windowMember))  { \
714         handled = eventListener->handleGenericEvent(event, &result); \
715         if (!handled) \
716             eventListener->handler(e); \
717     } \
718 } \
719 break;
720 
721 #define HANDLE_KEYBOARD_EVENT(event_t, handler) \
722 { \
723     event_t *e = reinterpret_cast<event_t *>(event); \
724     if (QXcbWindowEventListener *eventListener = windowEventListenerFromId(e->event)) { \
725         handled = eventListener->handleGenericEvent(event, &result); \
726         if (!handled) \
727             m_keyboard->handler(e); \
728     } \
729 } \
730 break;
731 
732 void QXcbConnection::printXcbEvent(const QLoggingCategory &log, const char *message,
733                                    xcb_generic_event_t *event) const
734 {
735     quint8 response_type = event->response_type & ~0x80;
736     quint16 sequence = event->sequence;
737 
738     #define PRINT_AND_RETURN(name) { \
739         qCDebug(log, "%s | %s(%d) | sequence: %d", message, name, response_type, sequence); \
740         return; \
741     }
742 
743     switch (response_type) {
744     case XCB_KEY_PRESS         : PRINT_AND_RETURN("XCB_KEY_PRESS");
745     case XCB_KEY_RELEASE       : PRINT_AND_RETURN("XCB_KEY_RELEASE");
746     case XCB_BUTTON_PRESS      : PRINT_AND_RETURN("XCB_BUTTON_PRESS");
747     case XCB_BUTTON_RELEASE    : PRINT_AND_RETURN("XCB_BUTTON_RELEASE");
748     case XCB_MOTION_NOTIFY     : PRINT_AND_RETURN("XCB_MOTION_NOTIFY");
749     case XCB_ENTER_NOTIFY      : PRINT_AND_RETURN("XCB_ENTER_NOTIFY");
750     case XCB_LEAVE_NOTIFY      : PRINT_AND_RETURN("XCB_LEAVE_NOTIFY");
751     case XCB_FOCUS_IN          : PRINT_AND_RETURN("XCB_FOCUS_IN");
752     case XCB_FOCUS_OUT         : PRINT_AND_RETURN("XCB_FOCUS_OUT");
753     case XCB_KEYMAP_NOTIFY     : PRINT_AND_RETURN("XCB_KEYMAP_NOTIFY");
754     case XCB_EXPOSE            : PRINT_AND_RETURN("XCB_EXPOSE");
755     case XCB_GRAPHICS_EXPOSURE : PRINT_AND_RETURN("XCB_GRAPHICS_EXPOSURE");
756     case XCB_NO_EXPOSURE       : PRINT_AND_RETURN("XCB_NO_EXPOSURE");
757     case XCB_VISIBILITY_NOTIFY : PRINT_AND_RETURN("XCB_VISIBILITY_NOTIFY");
758     case XCB_CREATE_NOTIFY     : PRINT_AND_RETURN("XCB_CREATE_NOTIFY");
759     case XCB_DESTROY_NOTIFY    : PRINT_AND_RETURN("XCB_DESTROY_NOTIFY");
760     case XCB_UNMAP_NOTIFY      : PRINT_AND_RETURN("XCB_UNMAP_NOTIFY");
761     case XCB_MAP_NOTIFY        : PRINT_AND_RETURN("XCB_MAP_NOTIFY");
762     case XCB_MAP_REQUEST       : PRINT_AND_RETURN("XCB_MAP_REQUEST");
763     case XCB_REPARENT_NOTIFY   : PRINT_AND_RETURN("XCB_REPARENT_NOTIFY");
764     case XCB_CONFIGURE_NOTIFY  : PRINT_AND_RETURN("XCB_CONFIGURE_NOTIFY");
765     case XCB_CONFIGURE_REQUEST : PRINT_AND_RETURN("XCB_CONFIGURE_REQUEST");
766     case XCB_GRAVITY_NOTIFY    : PRINT_AND_RETURN("XCB_GRAVITY_NOTIFY");
767     case XCB_RESIZE_REQUEST    : PRINT_AND_RETURN("XCB_RESIZE_REQUEST");
768     case XCB_CIRCULATE_NOTIFY  : PRINT_AND_RETURN("XCB_CIRCULATE_NOTIFY");
769     case XCB_CIRCULATE_REQUEST : PRINT_AND_RETURN("XCB_CIRCULATE_REQUEST");
770     case XCB_PROPERTY_NOTIFY   : PRINT_AND_RETURN("XCB_PROPERTY_NOTIFY");
771     case XCB_SELECTION_CLEAR   : PRINT_AND_RETURN("XCB_SELECTION_CLEAR");
772     case XCB_SELECTION_REQUEST : PRINT_AND_RETURN("XCB_SELECTION_REQUEST");
773     case XCB_SELECTION_NOTIFY  : PRINT_AND_RETURN("XCB_SELECTION_NOTIFY");
774     case XCB_COLORMAP_NOTIFY   : PRINT_AND_RETURN("XCB_COLORMAP_NOTIFY");
775     case XCB_CLIENT_MESSAGE    : PRINT_AND_RETURN("XCB_CLIENT_MESSAGE");
776     case XCB_MAPPING_NOTIFY    : PRINT_AND_RETURN("XCB_MAPPING_NOTIFY");
777     case XCB_GE_GENERIC        : PRINT_AND_RETURN("XCB_GE_GENERIC");
778     }
779     // XFixes
780     if (has_xfixes && response_type == xfixes_first_event + XCB_XFIXES_SELECTION_NOTIFY)
781           PRINT_AND_RETURN("XCB_XFIXES_SELECTION_NOTIFY");
782     // XRandR
783     if (has_randr_extension) {
784         if (response_type == xrandr_first_event + XCB_RANDR_NOTIFY)
785             PRINT_AND_RETURN("XCB_RANDR_NOTIFY");
786         if (response_type == xrandr_first_event + XCB_RANDR_SCREEN_CHANGE_NOTIFY)
787             PRINT_AND_RETURN("XCB_RANDR_SCREEN_CHANGE_NOTIFY");
788     }
789     // XKB
790     if (response_type == xkb_first_event)
791         PRINT_AND_RETURN("XCB_XKB_* event");
792 
793     // UNKNOWN
794     qCDebug(log, "%s | unknown(%d) | sequence: %d", message, response_type, sequence);
795     #undef PRINT_AND_RETURN
796 }
797 
798 const char *xcb_errors[] =
799 {
800     "Success",
801     "BadRequest",
802     "BadValue",
803     "BadWindow",
804     "BadPixmap",
805     "BadAtom",
806     "BadCursor",
807     "BadFont",
808     "BadMatch",
809     "BadDrawable",
810     "BadAccess",
811     "BadAlloc",
812     "BadColor",
813     "BadGC",
814     "BadIDChoice",
815     "BadName",
816     "BadLength",
817     "BadImplementation",
818     "Unknown"
819 };
820 
821 const char *xcb_protocol_request_codes[] =
822 {
823     "Null",
824     "CreateWindow",
825     "ChangeWindowAttributes",
826     "GetWindowAttributes",
827     "DestroyWindow",
828     "DestroySubwindows",
829     "ChangeSaveSet",
830     "ReparentWindow",
831     "MapWindow",
832     "MapSubwindows",
833     "UnmapWindow",
834     "UnmapSubwindows",
835     "ConfigureWindow",
836     "CirculateWindow",
837     "GetGeometry",
838     "QueryTree",
839     "InternAtom",
840     "GetAtomName",
841     "ChangeProperty",
842     "DeleteProperty",
843     "GetProperty",
844     "ListProperties",
845     "SetSelectionOwner",
846     "GetSelectionOwner",
847     "ConvertSelection",
848     "SendEvent",
849     "GrabPointer",
850     "UngrabPointer",
851     "GrabButton",
852     "UngrabButton",
853     "ChangeActivePointerGrab",
854     "GrabKeyboard",
855     "UngrabKeyboard",
856     "GrabKey",
857     "UngrabKey",
858     "AllowEvents",
859     "GrabServer",
860     "UngrabServer",
861     "QueryPointer",
862     "GetMotionEvents",
863     "TranslateCoords",
864     "WarpPointer",
865     "SetInputFocus",
866     "GetInputFocus",
867     "QueryKeymap",
868     "OpenFont",
869     "CloseFont",
870     "QueryFont",
871     "QueryTextExtents",
872     "ListFonts",
873     "ListFontsWithInfo",
874     "SetFontPath",
875     "GetFontPath",
876     "CreatePixmap",
877     "FreePixmap",
878     "CreateGC",
879     "ChangeGC",
880     "CopyGC",
881     "SetDashes",
882     "SetClipRectangles",
883     "FreeGC",
884     "ClearArea",
885     "CopyArea",
886     "CopyPlane",
887     "PolyPoint",
888     "PolyLine",
889     "PolySegment",
890     "PolyRectangle",
891     "PolyArc",
892     "FillPoly",
893     "PolyFillRectangle",
894     "PolyFillArc",
895     "PutImage",
896     "GetImage",
897     "PolyText8",
898     "PolyText16",
899     "ImageText8",
900     "ImageText16",
901     "CreateColormap",
902     "FreeColormap",
903     "CopyColormapAndFree",
904     "InstallColormap",
905     "UninstallColormap",
906     "ListInstalledColormaps",
907     "AllocColor",
908     "AllocNamedColor",
909     "AllocColorCells",
910     "AllocColorPlanes",
911     "FreeColors",
912     "StoreColors",
913     "StoreNamedColor",
914     "QueryColors",
915     "LookupColor",
916     "CreateCursor",
917     "CreateGlyphCursor",
918     "FreeCursor",
919     "RecolorCursor",
920     "QueryBestSize",
921     "QueryExtension",
922     "ListExtensions",
923     "ChangeKeyboardMapping",
924     "GetKeyboardMapping",
925     "ChangeKeyboardControl",
926     "GetKeyboardControl",
927     "Bell",
928     "ChangePointerControl",
929     "GetPointerControl",
930     "SetScreenSaver",
931     "GetScreenSaver",
932     "ChangeHosts",
933     "ListHosts",
934     "SetAccessControl",
935     "SetCloseDownMode",
936     "KillClient",
937     "RotateProperties",
938     "ForceScreenSaver",
939     "SetPointerMapping",
940     "GetPointerMapping",
941     "SetModifierMapping",
942     "GetModifierMapping",
943     "Unknown"
944 };
945 
946 void QXcbConnection::handleXcbError(xcb_generic_error_t *error)
947 {
948     long result = 0;
949     QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();
950     if (dispatcher && dispatcher->filterNativeEvent(m_nativeInterface->genericEventFilterType(), error, &result))
951         return;
952 
953     uint clamped_error_code = qMin<uint>(error->error_code, (sizeof(xcb_errors) / sizeof(xcb_errors[0])) - 1);
954     uint clamped_major_code = qMin<uint>(error->major_code, (sizeof(xcb_protocol_request_codes) / sizeof(xcb_protocol_request_codes[0])) - 1);
955 
956     qWarning("QXcbConnection: XCB error: %d (%s), sequence: %d, resource id: %d, major code: %d (%s), minor code: %d",
957            int(error->error_code), xcb_errors[clamped_error_code],
958            int(error->sequence), int(error->resource_id),
959            int(error->major_code), xcb_protocol_request_codes[clamped_major_code],
960            int(error->minor_code));
961 }
962 
963 static Qt::MouseButtons translateMouseButtons(int s)
964 {
965     Qt::MouseButtons ret = 0;
966     if (s & XCB_BUTTON_MASK_1)
967         ret |= Qt::LeftButton;
968     if (s & XCB_BUTTON_MASK_2)
969         ret |= Qt::MidButton;
970     if (s & XCB_BUTTON_MASK_3)
971         ret |= Qt::RightButton;
972     return ret;
973 }
974 
975 Qt::MouseButton QXcbConnection::translateMouseButton(xcb_button_t s)
976 {
977     switch (s) {
978     case 1: return Qt::LeftButton;
979     case 2: return Qt::MidButton;
980     case 3: return Qt::RightButton;
981     // Button values 4-7 were already handled as Wheel events, and won't occur here.
982     case 8: return Qt::BackButton;      // Also known as Qt::ExtraButton1
983     case 9: return Qt::ForwardButton;   // Also known as Qt::ExtraButton2
984     case 10: return Qt::ExtraButton3;
985     case 11: return Qt::ExtraButton4;
986     case 12: return Qt::ExtraButton5;
987     case 13: return Qt::ExtraButton6;
988     case 14: return Qt::ExtraButton7;
989     case 15: return Qt::ExtraButton8;
990     case 16: return Qt::ExtraButton9;
991     case 17: return Qt::ExtraButton10;
992     case 18: return Qt::ExtraButton11;
993     case 19: return Qt::ExtraButton12;
994     case 20: return Qt::ExtraButton13;
995     case 21: return Qt::ExtraButton14;
996     case 22: return Qt::ExtraButton15;
997     case 23: return Qt::ExtraButton16;
998     case 24: return Qt::ExtraButton17;
999     case 25: return Qt::ExtraButton18;
1000     case 26: return Qt::ExtraButton19;
1001     case 27: return Qt::ExtraButton20;
1002     case 28: return Qt::ExtraButton21;
1003     case 29: return Qt::ExtraButton22;
1004     case 30: return Qt::ExtraButton23;
1005     case 31: return Qt::ExtraButton24;
1006     default: return Qt::NoButton;
1007     }
1008 }
1009 
1010 #if QT_CONFIG(xkb)
1011 namespace {
1012     typedef union {
1013         /* All XKB events share these fields. */
1014         struct {
1015             uint8_t response_type;
1016             uint8_t xkbType;
1017             uint16_t sequence;
1018             xcb_timestamp_t time;
1019             uint8_t deviceID;
1020         } any;
1021         xcb_xkb_new_keyboard_notify_event_t new_keyboard_notify;
1022         xcb_xkb_map_notify_event_t map_notify;
1023         xcb_xkb_state_notify_event_t state_notify;
1024     } _xkb_event;
1025 }
1026 #endif
1027 
1028 void QXcbConnection::handleXcbEvent(xcb_generic_event_t *event)
1029 {
1030     long result = 0;
1031     QAbstractEventDispatcher* dispatcher = QAbstractEventDispatcher::instance();
1032     bool handled = dispatcher && dispatcher->filterNativeEvent(m_nativeInterface->genericEventFilterType(), event, &result);
1033 
1034     uint response_type = event->response_type & ~0x80;
1035 
1036     if (!handled) {
1037         switch (response_type) {
1038         case XCB_EXPOSE:
1039             HANDLE_PLATFORM_WINDOW_EVENT(xcb_expose_event_t, window, handleExposeEvent);
1040 
1041         // press/release/motion is only delivered here when XI 2.2+ is _not_ in use
1042         case XCB_BUTTON_PRESS: {
1043             xcb_button_press_event_t *ev = (xcb_button_press_event_t *)event;
1044             m_keyboard->updateXKBStateFromCore(ev->state);
1045             // the event explicitly contains the state of the three first buttons,
1046             // the rest we need to manage ourselves
1047             m_buttonState = (m_buttonState & ~0x7) | translateMouseButtons(ev->state);
1048             m_buttonState |= translateMouseButton(ev->detail);
1049             if (Q_UNLIKELY(lcQpaXInputEvents().isDebugEnabled()))
1050                 qCDebug(lcQpaXInputEvents, "legacy mouse press, button %d state %X", ev->detail, static_cast<unsigned int>(m_buttonState));
1051             HANDLE_PLATFORM_WINDOW_EVENT(xcb_button_press_event_t, event, handleButtonPressEvent);
1052         }
1053         case XCB_BUTTON_RELEASE: {
1054             xcb_button_release_event_t *ev = (xcb_button_release_event_t *)event;
1055             m_keyboard->updateXKBStateFromCore(ev->state);
1056             m_buttonState = (m_buttonState & ~0x7) | translateMouseButtons(ev->state);
1057             m_buttonState &= ~translateMouseButton(ev->detail);
1058             if (Q_UNLIKELY(lcQpaXInputEvents().isDebugEnabled()))
1059                 qCDebug(lcQpaXInputEvents, "legacy mouse release, button %d state %X", ev->detail, static_cast<unsigned int>(m_buttonState));
1060             HANDLE_PLATFORM_WINDOW_EVENT(xcb_button_release_event_t, event, handleButtonReleaseEvent);
1061         }
1062         case XCB_MOTION_NOTIFY: {
1063             xcb_motion_notify_event_t *ev = (xcb_motion_notify_event_t *)event;
1064             m_keyboard->updateXKBStateFromCore(ev->state);
1065             m_buttonState = (m_buttonState & ~0x7) | translateMouseButtons(ev->state);
1066             if (Q_UNLIKELY(lcQpaXInputEvents().isDebugEnabled()))
1067                 qCDebug(lcQpaXInputEvents, "legacy mouse move %d,%d button %d state %X", ev->event_x, ev->event_y,
1068                         ev->detail, static_cast<unsigned int>(m_buttonState));
1069             HANDLE_PLATFORM_WINDOW_EVENT(xcb_motion_notify_event_t, event, handleMotionNotifyEvent);
1070         }
1071 
1072         case XCB_CONFIGURE_NOTIFY:
1073             HANDLE_PLATFORM_WINDOW_EVENT(xcb_configure_notify_event_t, event, handleConfigureNotifyEvent);
1074         case XCB_MAP_NOTIFY:
1075             HANDLE_PLATFORM_WINDOW_EVENT(xcb_map_notify_event_t, event, handleMapNotifyEvent);
1076         case XCB_UNMAP_NOTIFY:
1077             HANDLE_PLATFORM_WINDOW_EVENT(xcb_unmap_notify_event_t, event, handleUnmapNotifyEvent);
1078         case XCB_DESTROY_NOTIFY:
1079             HANDLE_PLATFORM_WINDOW_EVENT(xcb_destroy_notify_event_t, event, handleDestroyNotifyEvent);
1080         case XCB_CLIENT_MESSAGE:
1081             handleClientMessageEvent((xcb_client_message_event_t *)event);
1082             break;
1083         case XCB_ENTER_NOTIFY:
1084 #ifdef XCB_USE_XINPUT22
1085             if (isAtLeastXI22() && xi2MouseEvents())
1086                 break;
1087 #endif
1088             HANDLE_PLATFORM_WINDOW_EVENT(xcb_enter_notify_event_t, event, handleEnterNotifyEvent);
1089         case XCB_LEAVE_NOTIFY:
1090 #ifdef XCB_USE_XINPUT22
1091             if (isAtLeastXI22() && xi2MouseEvents())
1092                 break;
1093 #endif
1094             m_keyboard->updateXKBStateFromCore(((xcb_leave_notify_event_t *)event)->state);
1095             HANDLE_PLATFORM_WINDOW_EVENT(xcb_leave_notify_event_t, event, handleLeaveNotifyEvent);
1096         case XCB_FOCUS_IN:
1097             HANDLE_PLATFORM_WINDOW_EVENT(xcb_focus_in_event_t, event, handleFocusInEvent);
1098         case XCB_FOCUS_OUT:
1099             HANDLE_PLATFORM_WINDOW_EVENT(xcb_focus_out_event_t, event, handleFocusOutEvent);
1100         case XCB_KEY_PRESS:
1101         {
1102             xcb_key_press_event_t *kp = (xcb_key_press_event_t *)event;
1103             m_keyboard->updateXKBStateFromCore(kp->state);
1104             setTime(kp->time);
1105             HANDLE_KEYBOARD_EVENT(xcb_key_press_event_t, handleKeyPressEvent);
1106         }
1107         case XCB_KEY_RELEASE:
1108             m_keyboard->updateXKBStateFromCore(((xcb_key_release_event_t *)event)->state);
1109             HANDLE_KEYBOARD_EVENT(xcb_key_release_event_t, handleKeyReleaseEvent);
1110         case XCB_MAPPING_NOTIFY:
1111             m_keyboard->handleMappingNotifyEvent(reinterpret_cast<xcb_mapping_notify_event_t *>(event));
1112             break;
1113         case XCB_SELECTION_REQUEST:
1114         {
1115 #if QT_CONFIG(draganddrop) || QT_CONFIG(clipboard)
1116             xcb_selection_request_event_t *sr = reinterpret_cast<xcb_selection_request_event_t *>(event);
1117 #endif
1118 #ifndef QT_NO_DRAGANDDROP
1119             if (sr->selection == atom(QXcbAtom::XdndSelection))
1120                 m_drag->handleSelectionRequest(sr);
1121             else
1122 #endif
1123             {
1124 #ifndef QT_NO_CLIPBOARD
1125                 m_clipboard->handleSelectionRequest(sr);
1126 #endif
1127             }
1128             break;
1129         }
1130         case XCB_SELECTION_CLEAR:
1131             setTime((reinterpret_cast<xcb_selection_clear_event_t *>(event))->time);
1132 #ifndef QT_NO_CLIPBOARD
1133             m_clipboard->handleSelectionClearRequest(reinterpret_cast<xcb_selection_clear_event_t *>(event));
1134 #endif
1135             handled = true;
1136             break;
1137         case XCB_SELECTION_NOTIFY:
1138             setTime((reinterpret_cast<xcb_selection_notify_event_t *>(event))->time);
1139             handled = false;
1140             break;
1141         case XCB_PROPERTY_NOTIFY:
1142         {
1143             xcb_property_notify_event_t *pn = reinterpret_cast<xcb_property_notify_event_t *>(event);
1144             if (pn->atom == atom(QXcbAtom::_NET_WORKAREA)) {
1145                 QXcbVirtualDesktop *virtualDesktop = virtualDesktopForRootWindow(pn->window);
1146                 if (virtualDesktop)
1147                     virtualDesktop->updateWorkArea();
1148             } else {
1149                 HANDLE_PLATFORM_WINDOW_EVENT(xcb_property_notify_event_t, window, handlePropertyNotifyEvent);
1150             }
1151             break;
1152         }
1153 #if QT_CONFIG(xinput2)
1154         case XCB_GE_GENERIC:
1155             // Here the windowEventListener is invoked from xi2HandleEvent()
1156             if (m_xi2Enabled && isXIEvent(event, m_xiOpCode))
1157                 xi2HandleEvent(reinterpret_cast<xcb_ge_event_t *>(event));
1158             break;
1159 #endif
1160         default:
1161             handled = false;
1162             break;
1163         }
1164     }
1165 
1166     if (!handled) {
1167         if (has_xfixes && response_type == xfixes_first_event + XCB_XFIXES_SELECTION_NOTIFY) {
1168             xcb_xfixes_selection_notify_event_t *notify_event = reinterpret_cast<xcb_xfixes_selection_notify_event_t *>(event);
1169             setTime(notify_event->timestamp);
1170 #ifndef QT_NO_CLIPBOARD
1171             m_clipboard->handleXFixesSelectionRequest(notify_event);
1172 #endif
1173             for (QXcbVirtualDesktop *virtualDesktop : qAsConst(m_virtualDesktops))
1174                 virtualDesktop->handleXFixesSelectionNotify(notify_event);
1175 
1176             handled = true;
1177         } else if (has_randr_extension && response_type == xrandr_first_event + XCB_RANDR_NOTIFY) {
1178             updateScreens(reinterpret_cast<xcb_randr_notify_event_t *>(event));
1179             handled = true;
1180         } else if (has_randr_extension && response_type == xrandr_first_event + XCB_RANDR_SCREEN_CHANGE_NOTIFY) {
1181             xcb_randr_screen_change_notify_event_t *change_event = reinterpret_cast<xcb_randr_screen_change_notify_event_t *>(event);
1182             for (QXcbScreen *s : qAsConst(m_screens)) {
1183                 if (s->root() == change_event->root )
1184                     s->handleScreenChange(change_event);
1185             }
1186             handled = true;
1187 #if QT_CONFIG(xkb)
1188         } else if (response_type == xkb_first_event) { // https://bugs.freedesktop.org/show_bug.cgi?id=51295
1189             _xkb_event *xkb_event = reinterpret_cast<_xkb_event *>(event);
1190             if (xkb_event->any.deviceID == m_keyboard->coreDeviceId()) {
1191                 switch (xkb_event->any.xkbType) {
1192                     // XkbNewKkdNotify and XkbMapNotify together capture all sorts of keymap
1193                     // updates (e.g. xmodmap, xkbcomp, setxkbmap), with minimal redundent recompilations.
1194                     case XCB_XKB_STATE_NOTIFY:
1195                         m_keyboard->updateXKBState(&xkb_event->state_notify);
1196                         handled = true;
1197                         break;
1198                     case XCB_XKB_MAP_NOTIFY:
1199                         m_keyboard->handleMappingNotifyEvent(&xkb_event->map_notify);
1200                         handled = true;
1201                         break;
1202                     case XCB_XKB_NEW_KEYBOARD_NOTIFY: {
1203                         xcb_xkb_new_keyboard_notify_event_t *ev = &xkb_event->new_keyboard_notify;
1204                         if (ev->changed & XCB_XKB_NKN_DETAIL_KEYCODES)
1205                             m_keyboard->updateKeymap();
1206                         break;
1207                     }
1208                     default:
1209                         break;
1210                 }
1211             }
1212 #endif
1213         }
1214     }
1215 
1216     if (!handled && m_glIntegration)
1217         handled = m_glIntegration->handleXcbEvent(event, response_type);
1218 
1219     if (Q_UNLIKELY(lcQpaEvents().isDebugEnabled()))
1220         printXcbEvent(lcQpaEvents(), handled ? "Handled" : "Unhandled", event);
1221 }
1222 
1223 void QXcbConnection::addPeekFunc(PeekFunc f)
1224 {
1225     m_peekFuncs.append(f);
1226 }
1227 
1228 qint32 QXcbConnection::generatePeekerId()
1229 {
1230     qint32 peekerId = m_peekerIdSource++;
1231     m_peekerToCachedIndex.insert(peekerId, 0);
1232     return peekerId;
1233 }
1234 
1235 bool QXcbConnection::removePeekerId(qint32 peekerId)
1236 {
1237     if (!m_peekerToCachedIndex.contains(peekerId)) {
1238         qCWarning(lcQpaXcb, "failed to remove unknown peeker id: %d", peekerId);
1239         return false;
1240     }
1241     m_peekerToCachedIndex.remove(peekerId);
1242     if (m_peekerToCachedIndex.isEmpty()) {
1243         m_peekerIdSource = 1; // Once the hash becomes empty, we can start reusing IDs
1244         m_peekerIndexCacheDirty = false;
1245     }
1246     return true;
1247 }
1248 
1249 /*! \internal
1250 
1251     The peekerId argument is ignored with PeekOption::PeekFromQueueStart,
1252     but passing in some arbitrary negative number can be handy for debugging
1253     output.
1254 */
1255 bool QXcbConnection::peekEventQueue(PeekerCallback peeker, void *peekerData, PeekOption option,
1256                                     qint32 peekerId)
1257 {
1258     bool useCachedIndex = option == PeekOption::PeekFromCachedIndex;
1259     if (useCachedIndex && !m_peekerToCachedIndex.contains(peekerId)) {
1260         qCWarning(lcQpaXcb, "failed to find cached index for unknown peeker id: %d", peekerId);
1261         return false;
1262     }
1263 
1264     bool wasReset = false;
1265     if (useCachedIndex && m_peekerIndexCacheDirty && !m_peekerToCachedIndex.isEmpty()) {
1266         // When the main even loop has flushed the buffered XCB events into the window
1267         // system event queue, the cached indexes are not valid anymore and need reset.
1268         auto it = m_peekerToCachedIndex.constBegin();
1269         while (it != m_peekerToCachedIndex.constEnd()) {
1270             m_peekerToCachedIndex.insert(it.key(), 0);
1271             ++it;
1272         }
1273         m_peekerIndexCacheDirty = false;
1274         wasReset = true;
1275     }
1276 
1277     qint32 peekerIndex = useCachedIndex && !wasReset ? m_peekerToCachedIndex.value(peekerId) : 0;
1278     qint32 startingIndex = peekerIndex;
1279     bool result = false;
1280     m_mainEventLoopFlushedQueue = false;
1281 
1282     QXcbEventArray *eventqueue = m_reader->lock();
1283     if (Q_UNLIKELY(lcQpaPeeker().isDebugEnabled())) {
1284         qCDebug(lcQpaPeeker, "[%d] peeker index: %d | queue size: %d",
1285                 peekerId, peekerIndex, eventqueue->size());
1286     }
1287     while (peekerIndex < eventqueue->size() && !result && !m_mainEventLoopFlushedQueue) {
1288         xcb_generic_event_t *event = eventqueue->at(peekerIndex++);
1289         if (!event)
1290             continue;
1291         if (Q_UNLIKELY(lcQpaPeeker().isDebugEnabled())) {
1292             QString debug = QString((QLatin1String("[%1] peeking at index: %2")))
1293                             .arg(peekerId).arg(peekerIndex - 1);
1294             printXcbEvent(lcQpaPeeker(), debug.toLatin1(), event);
1295         }
1296         // A peeker may call QCoreApplication::processEvents(), which has two implications:
1297         // 1) We need to make the lock available for QXcbConnection::processXcbEvents(),
1298         //    otherwise we will dead lock;
1299         // 2) QXcbConnection::processXcbEvents() will flush the queue we are currently
1300         //    looping through;
1301         m_reader->unlock();
1302         result = peeker(event, peekerData);
1303         m_reader->lock();
1304     }
1305     m_reader->unlock();
1306 
1307     if (useCachedIndex && peekerIndex != startingIndex && !m_mainEventLoopFlushedQueue)
1308         m_peekerToCachedIndex.insert(peekerId, peekerIndex);
1309 
1310     return result;
1311 }
1312 
1313 QXcbEventReader::QXcbEventReader(QXcbConnection *connection)
1314     : m_connection(connection)
1315 {
1316     checkXcbPollForQueuedEvent();
1317 }
1318 
1319 void QXcbEventReader::start()
1320 {
1321     if (local_xcb_poll_for_queued_event) {
1322         connect(this, SIGNAL(eventPending()), m_connection, SLOT(processXcbEvents()), Qt::QueuedConnection);
1323         connect(this, SIGNAL(finished()), m_connection, SLOT(processXcbEvents()));
1324         QThread::start();
1325     } else {
1326         // Must be done after we have an event-dispatcher. By posting a method invocation
1327         // we are sure that by the time the method is called we have an event-dispatcher.
1328         QMetaObject::invokeMethod(this, "registerForEvents", Qt::QueuedConnection);
1329     }
1330 }
1331 
1332 void QXcbEventReader::registerForEvents()
1333 {
1334     QSocketNotifier *notifier = new QSocketNotifier(xcb_get_file_descriptor(m_connection->xcb_connection()), QSocketNotifier::Read, this);
1335     connect(notifier, SIGNAL(activated(int)), m_connection, SLOT(processXcbEvents()));
1336 
1337     QAbstractEventDispatcher *dispatcher = QGuiApplicationPrivate::eventDispatcher;
1338     connect(dispatcher, SIGNAL(aboutToBlock()), m_connection, SLOT(processXcbEvents()));
1339     connect(dispatcher, SIGNAL(awake()), m_connection, SLOT(processXcbEvents()));
1340 }
1341 
1342 void QXcbEventReader::registerEventDispatcher(QAbstractEventDispatcher *dispatcher)
1343 {
1344     // flush the xcb connection before the EventDispatcher is going to block
1345     // In the non-threaded case processXcbEvents is called before going to block,
1346     // which flushes the connection.
1347     if (local_xcb_poll_for_queued_event)
1348         connect(dispatcher, SIGNAL(aboutToBlock()), m_connection, SLOT(flush()));
1349 }
1350 
1351 void QXcbEventReader::run()
1352 {
1353     xcb_generic_event_t *event;
1354     while (m_connection && (event = xcb_wait_for_event(m_connection->xcb_connection()))) {
1355         m_mutex.lock();
1356         addEvent(event);
1357         while (m_connection && (event = local_xcb_poll_for_queued_event(m_connection->xcb_connection())))
1358             addEvent(event);
1359         m_mutex.unlock();
1360         emit eventPending();
1361     }
1362 
1363     m_mutex.lock();
1364     for (int i = 0; i < m_events.size(); ++i)
1365         free(m_events.at(i));
1366     m_events.clear();
1367     m_mutex.unlock();
1368 }
1369 
1370 void QXcbEventReader::addEvent(xcb_generic_event_t *event)
1371 {
1372     if ((event->response_type & ~0x80) == XCB_CLIENT_MESSAGE
1373         && (reinterpret_cast<xcb_client_message_event_t *>(event))->type == m_connection->atom(QXcbAtom::_QT_CLOSE_CONNECTION))
1374         m_connection = 0;
1375     m_events << event;
1376 }
1377 
1378 QXcbEventArray *QXcbEventReader::lock()
1379 {
1380     m_mutex.lock();
1381     if (!local_xcb_poll_for_queued_event) {
1382         while (xcb_generic_event_t *event = xcb_poll_for_event(m_connection->xcb_connection()))
1383             m_events << event;
1384     }
1385     return &m_events;
1386 }
1387 
1388 void QXcbEventReader::unlock()
1389 {
1390     m_mutex.unlock();
1391 }
1392 
1393 void QXcbConnection::setFocusWindow(QWindow *w)
1394 {
1395     m_focusWindow = w ? static_cast<QXcbWindow *>(w->handle()) : nullptr;
1396 }
1397 void QXcbConnection::setMouseGrabber(QXcbWindow *w)
1398 {
1399     m_mouseGrabber = w;
1400     m_mousePressWindow = Q_NULLPTR;
1401 }
1402 void QXcbConnection::setMousePressWindow(QXcbWindow *w)
1403 {
1404     m_mousePressWindow = w;
1405 }
1406 
1407 void QXcbConnection::grabServer()
1408 {
1409     if (m_canGrabServer)
1410         xcb_grab_server(m_connection);
1411 }
1412 
1413 void QXcbConnection::ungrabServer()
1414 {
1415     if (m_canGrabServer)
1416         xcb_ungrab_server(m_connection);
1417 }
1418 
1419 void QXcbConnection::sendConnectionEvent(QXcbAtom::Atom a, uint id)
1420 {
1421     xcb_client_message_event_t event;
1422     memset(&event, 0, sizeof(event));
1423 
1424     const xcb_window_t eventListener = xcb_generate_id(m_connection);
1425     xcb_screen_iterator_t it = xcb_setup_roots_iterator(m_setup);
1426     xcb_screen_t *screen = it.data;
1427     xcb_create_window(m_connection, XCB_COPY_FROM_PARENT,
1428                       eventListener, screen->root,
1429                       0, 0, 1, 1, 0, XCB_WINDOW_CLASS_INPUT_ONLY,
1430                       screen->root_visual, 0, 0);
1431 
1432     event.response_type = XCB_CLIENT_MESSAGE;
1433     event.format = 32;
1434     event.sequence = 0;
1435     event.window = eventListener;
1436     event.type = atom(a);
1437     event.data.data32[0] = id;
1438 
1439     xcb_send_event(xcb_connection(), false, eventListener, XCB_EVENT_MASK_NO_EVENT, reinterpret_cast<const char *>(&event));
1440     xcb_destroy_window(m_connection, eventListener);
1441     xcb_flush(xcb_connection());
1442 }
1443 
1444 namespace
1445 {
1446     class PropertyNotifyEvent {
1447     public:
1448         PropertyNotifyEvent(xcb_window_t win, xcb_atom_t property)
1449             : window(win), type(XCB_PROPERTY_NOTIFY), atom(property) {}
1450         xcb_window_t window;
1451         int type;
1452         xcb_atom_t atom;
1453         bool checkEvent(xcb_generic_event_t *event) const {
1454             if (!event)
1455                 return false;
1456             if ((event->response_type & ~0x80) != type) {
1457                 return false;
1458             } else {
1459                 xcb_property_notify_event_t *pn = reinterpret_cast<xcb_property_notify_event_t *>(event);
1460                 if ((pn->window == window) && (pn->atom == atom))
1461                     return true;
1462             }
1463             return false;
1464         }
1465     };
1466 }
1467 
1468 xcb_timestamp_t QXcbConnection::getTimestamp()
1469 {
1470     // send a dummy event to myself to get the timestamp from X server.
1471     xcb_window_t root_win = rootWindow();
1472     xcb_change_property(xcb_connection(), XCB_PROP_MODE_APPEND, root_win, atom(QXcbAtom::CLIP_TEMPORARY),
1473                         XCB_ATOM_INTEGER, 32, 0, NULL);
1474 
1475     connection()->flush();
1476     PropertyNotifyEvent checker(root_win, atom(QXcbAtom::CLIP_TEMPORARY));
1477 
1478     xcb_generic_event_t *event = 0;
1479     // lets keep this inside a loop to avoid a possible race condition, where
1480     // reader thread has not yet had the time to acquire the mutex in order
1481     // to add the new set of events to its event queue
1482     while (!event) {
1483         connection()->sync();
1484         event = checkEvent(checker);
1485     }
1486 
1487     xcb_property_notify_event_t *pn = reinterpret_cast<xcb_property_notify_event_t *>(event);
1488     xcb_timestamp_t timestamp = pn->time;
1489     free(event);
1490 
1491     xcb_delete_property(xcb_connection(), root_win, atom(QXcbAtom::CLIP_TEMPORARY));
1492 
1493     return timestamp;
1494 }
1495 
1496 xcb_window_t QXcbConnection::getSelectionOwner(xcb_atom_t atom) const
1497 {
1498     return Q_XCB_REPLY(xcb_get_selection_owner, xcb_connection(), atom)->owner;
1499 }
1500 
1501 xcb_window_t QXcbConnection::getQtSelectionOwner()
1502 {
1503     if (!m_qtSelectionOwner) {
1504         xcb_screen_t *xcbScreen = primaryVirtualDesktop()->screen();
1505         int16_t x = 0, y = 0;
1506         uint16_t w = 3, h = 3;
1507         m_qtSelectionOwner = xcb_generate_id(xcb_connection());
1508         xcb_create_window(xcb_connection(),
1509                           XCB_COPY_FROM_PARENT,               // depth -- same as root
1510                           m_qtSelectionOwner,                 // window id
1511                           xcbScreen->root,                    // parent window id
1512                           x, y, w, h,
1513                           0,                                  // border width
1514                           XCB_WINDOW_CLASS_INPUT_OUTPUT,      // window class
1515                           xcbScreen->root_visual,             // visual
1516                           0,                                  // value mask
1517                           0);                                 // value list
1518     }
1519     return m_qtSelectionOwner;
1520 }
1521 
1522 xcb_window_t QXcbConnection::rootWindow()
1523 {
1524     QXcbScreen *s = primaryScreen();
1525     return s ? s->root() : 0;
1526 }
1527 
1528 xcb_window_t QXcbConnection::clientLeader()
1529 {
1530     if (m_clientLeader == 0) {
1531         m_clientLeader = xcb_generate_id(xcb_connection());
1532         QXcbScreen *screen = primaryScreen();
1533         xcb_create_window(xcb_connection(),
1534                           XCB_COPY_FROM_PARENT,
1535                           m_clientLeader,
1536                           screen->root(),
1537                           0, 0, 1, 1,
1538                           0,
1539                           XCB_WINDOW_CLASS_INPUT_OUTPUT,
1540                           screen->screen()->root_visual,
1541                           0, 0);
1542 #ifndef QT_NO_DEBUG
1543         QByteArray ba("Qt client leader window");
1544         xcb_change_property(xcb_connection(),
1545                             XCB_PROP_MODE_REPLACE,
1546                             m_clientLeader,
1547                             atom(QXcbAtom::_NET_WM_NAME),
1548                             atom(QXcbAtom::UTF8_STRING),
1549                             8,
1550                             ba.length(),
1551                             ba.constData());
1552 #endif
1553         xcb_change_property(xcb_connection(),
1554                             XCB_PROP_MODE_REPLACE,
1555                             m_clientLeader,
1556                             atom(QXcbAtom::WM_CLIENT_LEADER),
1557                             XCB_ATOM_WINDOW,
1558                             32,
1559                             1,
1560                             &m_clientLeader);
1561 
1562 #if QT_CONFIG(xcb_sm)
1563         // If we are session managed, inform the window manager about it
1564         QByteArray session = qGuiApp->sessionId().toLatin1();
1565         if (!session.isEmpty()) {
1566             xcb_change_property(xcb_connection(),
1567                                 XCB_PROP_MODE_REPLACE,
1568                                 m_clientLeader,
1569                                 atom(QXcbAtom::SM_CLIENT_ID),
1570                                 XCB_ATOM_STRING,
1571                                 8,
1572                                 session.length(),
1573                                 session.constData());
1574         }
1575 #endif
1576     }
1577     return m_clientLeader;
1578 }
1579 
1580 #if QT_CONFIG(xcb_xlib)
1581 void *QXcbConnection::xlib_display() const
1582 {
1583     return m_xlib_display;
1584 }
1585 
1586 void *QXcbConnection::createVisualInfoForDefaultVisualId() const
1587 {
1588     if (m_defaultVisualId == UINT_MAX)
1589         return 0;
1590     XVisualInfo info;
1591     memset(&info, 0, sizeof info);
1592     info.visualid = m_defaultVisualId;
1593 
1594     int count = 0;
1595     Display *dpy = static_cast<Display *>(connection()->xlib_display());
1596     XVisualInfo *retVisual = XGetVisualInfo(dpy, VisualIDMask, &info, &count);
1597     Q_ASSERT(count < 2);
1598     return retVisual;
1599 }
1600 
1601 #endif
1602 
1603 #if QT_CONFIG(xinput2)
1604 // it is safe to cast XI_* events here as long as we are only touching the first 32 bytes,
1605 // after that position event needs memmove, see xi2PrepareXIGenericDeviceEvent
1606 static inline bool isXIType(xcb_generic_event_t *event, int opCode, uint16_t type)
1607 {
1608     if (!isXIEvent(event, opCode))
1609         return false;
1610 
1611     xXIGenericDeviceEvent *xiEvent = reinterpret_cast<xXIGenericDeviceEvent *>(event);
1612     return xiEvent->evtype == type;
1613 }
1614 #endif
1615 static inline bool isValid(xcb_generic_event_t *event)
1616 {
1617     return event && (event->response_type & ~0x80);
1618 }
1619 
1620 /*! \internal
1621 
1622     Compresses events of the same type to avoid swamping the event queue.
1623     If event compression is not desired there are several options what developers can do:
1624 
1625     1) Write responsive applications. We drop events that have been buffered in the event
1626        queue while waiting on unresponsive GUI thread.
1627     2) Use QAbstractNativeEventFilter to get all events from X connection. This is not optimal
1628        because it requires working with native event types.
1629     3) Or add public API to Qt for disabling event compression QTBUG-44964
1630 
1631 */
1632 bool QXcbConnection::compressEvent(xcb_generic_event_t *event, int currentIndex, QXcbEventArray *eventqueue) const
1633 {
1634     uint responseType = event->response_type & ~0x80;
1635     int nextIndex = currentIndex + 1;
1636 
1637     if (responseType == XCB_MOTION_NOTIFY) {
1638         // compress XCB_MOTION_NOTIFY notify events
1639         for (int j = nextIndex; j < eventqueue->size(); ++j) {
1640             xcb_generic_event_t *next = eventqueue->at(j);
1641             if (!isValid(next))
1642                 continue;
1643             if (next->response_type == XCB_MOTION_NOTIFY)
1644                 return true;
1645         }
1646         return false;
1647     }
1648 #if QT_CONFIG(xinput2)
1649     // compress XI_* events
1650     if (responseType == XCB_GE_GENERIC) {
1651         if (!m_xi2Enabled)
1652             return false;
1653 
1654         // compress XI_Motion, but not from tablet devices
1655         if (isXIType(event, m_xiOpCode, XI_Motion)) {
1656 #if QT_CONFIG(tabletevent)
1657             xXIDeviceEvent *xdev = reinterpret_cast<xXIDeviceEvent *>(event);
1658             if (!QCoreApplication::testAttribute(Qt::AA_CompressTabletEvents) &&
1659                     const_cast<QXcbConnection *>(this)->tabletDataForDevice(xdev->sourceid))
1660                 return false;
1661 #endif // QT_CONFIG(tabletevent)
1662             for (int j = nextIndex; j < eventqueue->size(); ++j) {
1663                 xcb_generic_event_t *next = eventqueue->at(j);
1664                 if (!isValid(next))
1665                     continue;
1666                 if (isXIType(next, m_xiOpCode, XI_Motion))
1667                     return true;
1668             }
1669             return false;
1670         }
1671 #ifdef XCB_USE_XINPUT22
1672         // compress XI_TouchUpdate for the same touch point id
1673         if (isXIType(event, m_xiOpCode, XI_TouchUpdate)) {
1674             xXIDeviceEvent *xiDeviceEvent = reinterpret_cast<xXIDeviceEvent *>(event);
1675             uint32_t id = xiDeviceEvent->detail % INT_MAX;
1676             for (int j = nextIndex; j < eventqueue->size(); ++j) {
1677                 xcb_generic_event_t *next = eventqueue->at(j);
1678                 if (!isValid(next))
1679                     continue;
1680                 if (isXIType(next, m_xiOpCode, XI_TouchUpdate)) {
1681                     xXIDeviceEvent *xiDeviceNextEvent = reinterpret_cast<xXIDeviceEvent *>(next);
1682                     if (id == xiDeviceNextEvent->detail % INT_MAX)
1683                         return true;
1684                 }
1685             }
1686             return false;
1687         }
1688 #endif
1689         return false;
1690     }
1691 #endif
1692     if (responseType == XCB_CONFIGURE_NOTIFY) {
1693         // compress multiple configure notify events for the same window
1694         for (int j = nextIndex; j < eventqueue->size(); ++j) {
1695             xcb_generic_event_t *next = eventqueue->at(j);
1696             if (isValid(next) && next->response_type == XCB_CONFIGURE_NOTIFY
1697                 && reinterpret_cast<xcb_configure_notify_event_t *>(next)->event == reinterpret_cast<xcb_configure_notify_event_t *>(event)->event)
1698             {
1699                 return true;
1700             }
1701         }
1702         return false;
1703     }
1704 
1705     return false;
1706 }
1707 
1708 void QXcbConnection::processXcbEvents()
1709 {
1710     int connection_error = xcb_connection_has_error(xcb_connection());
1711     if (connection_error) {
1712         qWarning("The X11 connection broke (error %d). Did the X11 server die?", connection_error);
1713         exit(1);
1714     }
1715 
1716     QXcbEventArray *eventqueue = m_reader->lock();
1717     for (int i = 0; i < eventqueue->size(); ++i) {
1718         xcb_generic_event_t *event = eventqueue->at(i);
1719         if (!event)
1720             continue;
1721 
1722         QScopedPointer<xcb_generic_event_t, QScopedPointerPodDeleter> eventGuard(event);
1723         (*eventqueue)[i] = 0;
1724 
1725         if (!(event->response_type & ~0x80)) {
1726             handleXcbError(reinterpret_cast<xcb_generic_error_t *>(event));
1727             continue;
1728         }
1729 
1730         if (Q_LIKELY(QCoreApplication::testAttribute(Qt::AA_CompressHighFrequencyEvents)) &&
1731                 compressEvent(event, i, eventqueue))
1732             continue;
1733 
1734 #ifndef QT_NO_CLIPBOARD
1735         bool accepted = false;
1736         if (clipboard()->processIncr())
1737             clipboard()->incrTransactionPeeker(event, accepted);
1738         if (accepted)
1739             continue;
1740 #endif
1741 
1742         auto isWaitingFor = [=](PeekFunc peekFunc) {
1743             // These callbacks return true if the event is what they were
1744             // waiting for, remove them from the list in that case.
1745             return peekFunc(this, event);
1746         };
1747         m_peekFuncs.erase(std::remove_if(m_peekFuncs.begin(), m_peekFuncs.end(),
1748                                          isWaitingFor),
1749                           m_peekFuncs.end());
1750         m_reader->unlock();
1751         handleXcbEvent(event);
1752         m_reader->lock();
1753     }
1754     eventqueue->clear();
1755     m_reader->unlock();
1756 
1757     m_peekerIndexCacheDirty = m_mainEventLoopFlushedQueue = true;
1758 
1759     // Indicate with a null event that the event the callbacks are waiting for
1760     // is not in the queue currently.
1761     for (PeekFunc f : qAsConst(m_peekFuncs))
1762         f(this, 0);
1763     m_peekFuncs.clear();
1764 
1765     xcb_flush(xcb_connection());
1766 }
1767 
1768 void QXcbConnection::handleClientMessageEvent(const xcb_client_message_event_t *event)
1769 {
1770     if (event->format != 32)
1771         return;
1772 
1773 #ifndef QT_NO_DRAGANDDROP
1774     if (event->type == atom(QXcbAtom::XdndStatus)) {
1775         drag()->handleStatus(event);
1776     } else if (event->type == atom(QXcbAtom::XdndFinished)) {
1777         drag()->handleFinished(event);
1778     }
1779 #endif
1780     if (m_systemTrayTracker && event->type == atom(QXcbAtom::MANAGER))
1781         m_systemTrayTracker->notifyManagerClientMessageEvent(event);
1782 
1783     QXcbWindow *window = platformWindowFromId(event->window);
1784     if (!window)
1785         return;
1786 
1787     window->handleClientMessageEvent(event);
1788 }
1789 
1790 static const char * xcb_atomnames = {
1791     // window-manager <-> client protocols
1792     "WM_PROTOCOLS\0"
1793     "WM_DELETE_WINDOW\0"
1794     "WM_TAKE_FOCUS\0"
1795     "_NET_WM_PING\0"
1796     "_NET_WM_CONTEXT_HELP\0"
1797     "_NET_WM_SYNC_REQUEST\0"
1798     "_NET_WM_SYNC_REQUEST_COUNTER\0"
1799     "MANAGER\0"
1800     "_NET_SYSTEM_TRAY_OPCODE\0"
1801 
1802     // ICCCM window state
1803     "WM_STATE\0"
1804     "WM_CHANGE_STATE\0"
1805     "WM_CLASS\0"
1806     "WM_NAME\0"
1807 
1808     // Session management
1809     "WM_CLIENT_LEADER\0"
1810     "WM_WINDOW_ROLE\0"
1811     "SM_CLIENT_ID\0"
1812 
1813     // Clipboard
1814     "CLIPBOARD\0"
1815     "INCR\0"
1816     "TARGETS\0"
1817     "MULTIPLE\0"
1818     "TIMESTAMP\0"
1819     "SAVE_TARGETS\0"
1820     "CLIP_TEMPORARY\0"
1821     "_QT_SELECTION\0"
1822     "_QT_CLIPBOARD_SENTINEL\0"
1823     "_QT_SELECTION_SENTINEL\0"
1824     "CLIPBOARD_MANAGER\0"
1825 
1826     "RESOURCE_MANAGER\0"
1827 
1828     "_XSETROOT_ID\0"
1829 
1830     "_QT_SCROLL_DONE\0"
1831     "_QT_INPUT_ENCODING\0"
1832 
1833     "_QT_CLOSE_CONNECTION\0"
1834 
1835     "_MOTIF_WM_HINTS\0"
1836 
1837     "DTWM_IS_RUNNING\0"
1838     "ENLIGHTENMENT_DESKTOP\0"
1839     "_DT_SAVE_MODE\0"
1840     "_SGI_DESKS_MANAGER\0"
1841 
1842     // EWMH (aka NETWM)
1843     "_NET_SUPPORTED\0"
1844     "_NET_VIRTUAL_ROOTS\0"
1845     "_NET_WORKAREA\0"
1846 
1847     "_NET_MOVERESIZE_WINDOW\0"
1848     "_NET_WM_MOVERESIZE\0"
1849 
1850     "_NET_WM_NAME\0"
1851     "_NET_WM_ICON_NAME\0"
1852     "_NET_WM_ICON\0"
1853 
1854     "_NET_WM_PID\0"
1855 
1856     "_NET_WM_WINDOW_OPACITY\0"
1857 
1858     "_NET_WM_STATE\0"
1859     "_NET_WM_STATE_ABOVE\0"
1860     "_NET_WM_STATE_BELOW\0"
1861     "_NET_WM_STATE_FULLSCREEN\0"
1862     "_NET_WM_STATE_MAXIMIZED_HORZ\0"
1863     "_NET_WM_STATE_MAXIMIZED_VERT\0"
1864     "_NET_WM_STATE_MODAL\0"
1865     "_NET_WM_STATE_STAYS_ON_TOP\0"
1866     "_NET_WM_STATE_DEMANDS_ATTENTION\0"
1867 
1868     "_NET_WM_USER_TIME\0"
1869     "_NET_WM_USER_TIME_WINDOW\0"
1870     "_NET_WM_FULL_PLACEMENT\0"
1871 
1872     "_NET_WM_WINDOW_TYPE\0"
1873     "_NET_WM_WINDOW_TYPE_DESKTOP\0"
1874     "_NET_WM_WINDOW_TYPE_DOCK\0"
1875     "_NET_WM_WINDOW_TYPE_TOOLBAR\0"
1876     "_NET_WM_WINDOW_TYPE_MENU\0"
1877     "_NET_WM_WINDOW_TYPE_UTILITY\0"
1878     "_NET_WM_WINDOW_TYPE_SPLASH\0"
1879     "_NET_WM_WINDOW_TYPE_DIALOG\0"
1880     "_NET_WM_WINDOW_TYPE_DROPDOWN_MENU\0"
1881     "_NET_WM_WINDOW_TYPE_POPUP_MENU\0"
1882     "_NET_WM_WINDOW_TYPE_TOOLTIP\0"
1883     "_NET_WM_WINDOW_TYPE_NOTIFICATION\0"
1884     "_NET_WM_WINDOW_TYPE_COMBO\0"
1885     "_NET_WM_WINDOW_TYPE_DND\0"
1886     "_NET_WM_WINDOW_TYPE_NORMAL\0"
1887     "_KDE_NET_WM_WINDOW_TYPE_OVERRIDE\0"
1888 
1889     "_KDE_NET_WM_FRAME_STRUT\0"
1890     "_NET_FRAME_EXTENTS\0"
1891 
1892     "_NET_STARTUP_INFO\0"
1893     "_NET_STARTUP_INFO_BEGIN\0"
1894 
1895     "_NET_SUPPORTING_WM_CHECK\0"
1896 
1897     "_NET_WM_CM_S0\0"
1898 
1899     "_NET_SYSTEM_TRAY_VISUAL\0"
1900 
1901     "_NET_ACTIVE_WINDOW\0"
1902 
1903     // Property formats
1904     "TEXT\0"
1905     "UTF8_STRING\0"
1906     "CARDINAL\0"
1907 
1908     // xdnd
1909     "XdndEnter\0"
1910     "XdndPosition\0"
1911     "XdndStatus\0"
1912     "XdndLeave\0"
1913     "XdndDrop\0"
1914     "XdndFinished\0"
1915     "XdndTypeList\0"
1916     "XdndActionList\0"
1917 
1918     "XdndSelection\0"
1919 
1920     "XdndAware\0"
1921     "XdndProxy\0"
1922 
1923     "XdndActionCopy\0"
1924     "XdndActionLink\0"
1925     "XdndActionMove\0"
1926     "XdndActionPrivate\0"
1927 
1928     // Motif DND
1929     "_MOTIF_DRAG_AND_DROP_MESSAGE\0"
1930     "_MOTIF_DRAG_INITIATOR_INFO\0"
1931     "_MOTIF_DRAG_RECEIVER_INFO\0"
1932     "_MOTIF_DRAG_WINDOW\0"
1933     "_MOTIF_DRAG_TARGETS\0"
1934 
1935     "XmTRANSFER_SUCCESS\0"
1936     "XmTRANSFER_FAILURE\0"
1937 
1938     // Xkb
1939     "_XKB_RULES_NAMES\0"
1940 
1941     // XEMBED
1942     "_XEMBED\0"
1943     "_XEMBED_INFO\0"
1944 
1945     // XInput2
1946     "Button Left\0"
1947     "Button Middle\0"
1948     "Button Right\0"
1949     "Button Wheel Up\0"
1950     "Button Wheel Down\0"
1951     "Button Horiz Wheel Left\0"
1952     "Button Horiz Wheel Right\0"
1953     "Abs MT Position X\0"
1954     "Abs MT Position Y\0"
1955     "Abs MT Touch Major\0"
1956     "Abs MT Touch Minor\0"
1957     "Abs MT Orientation\0"
1958     "Abs MT Pressure\0"
1959     "Abs MT Tracking ID\0"
1960     "Max Contacts\0"
1961     "Rel X\0"
1962     "Rel Y\0"
1963     // XInput2 tablet
1964     "Abs X\0"
1965     "Abs Y\0"
1966     "Abs Pressure\0"
1967     "Abs Tilt X\0"
1968     "Abs Tilt Y\0"
1969     "Abs Wheel\0"
1970     "Abs Distance\0"
1971     "Wacom Serial IDs\0"
1972     "INTEGER\0"
1973     "Rel Horiz Wheel\0"
1974     "Rel Vert Wheel\0"
1975     "Rel Horiz Scroll\0"
1976     "Rel Vert Scroll\0"
1977     "_XSETTINGS_SETTINGS\0"
1978     "_COMPIZ_DECOR_PENDING\0"
1979     "_COMPIZ_DECOR_REQUEST\0"
1980     "_COMPIZ_DECOR_DELETE_PIXMAP\0"
1981     "_COMPIZ_TOOLKIT_ACTION\0"
1982     "_GTK_LOAD_ICONTHEMES\0"
1983     // \0\0 terminates loop.
1984 };
1985 
1986 QXcbAtom::Atom QXcbConnection::qatom(xcb_atom_t xatom) const
1987 {
1988     return static_cast<QXcbAtom::Atom>(std::find(m_allAtoms, m_allAtoms + QXcbAtom::NAtoms, xatom) - m_allAtoms);
1989 }
1990 
1991 void QXcbConnection::initializeAllAtoms() {
1992     const char *names[QXcbAtom::NAtoms];
1993     const char *ptr = xcb_atomnames;
1994 
1995     int i = 0;
1996     while (*ptr) {
1997         names[i++] = ptr;
1998         while (*ptr)
1999             ++ptr;
2000         ++ptr;
2001     }
2002 
2003     Q_ASSERT(i == QXcbAtom::NPredefinedAtoms);
2004 
2005     const QByteArray settings_atom_name = "_QT_SETTINGS_TIMESTAMP_" + m_displayName;
2006     names[i++] = settings_atom_name;
2007 
2008     xcb_intern_atom_cookie_t cookies[QXcbAtom::NAtoms];
2009 
2010     Q_ASSERT(i == QXcbAtom::NAtoms);
2011     for (i = 0; i < QXcbAtom::NAtoms; ++i)
2012         cookies[i] = xcb_intern_atom(xcb_connection(), false, strlen(names[i]), names[i]);
2013 
2014     for (i = 0; i < QXcbAtom::NAtoms; ++i) {
2015         xcb_intern_atom_reply_t *reply = xcb_intern_atom_reply(xcb_connection(), cookies[i], 0);
2016         m_allAtoms[i] = reply->atom;
2017         free(reply);
2018     }
2019 }
2020 
2021 xcb_atom_t QXcbConnection::internAtom(const char *name)
2022 {
2023     if (!name || *name == 0)
2024         return XCB_NONE;
2025 
2026     return Q_XCB_REPLY(xcb_intern_atom, xcb_connection(), false, strlen(name), name)->atom;
2027 }
2028 
2029 QByteArray QXcbConnection::atomName(xcb_atom_t atom)
2030 {
2031     if (!atom)
2032         return QByteArray();
2033 
2034     auto reply = Q_XCB_REPLY(xcb_get_atom_name, xcb_connection(), atom);
2035     if (!reply)
2036         qWarning() << "QXcbConnection::atomName: bad Atom" << atom;
2037     else
2038         return QByteArray(xcb_get_atom_name_name(reply.get()), xcb_get_atom_name_name_length(reply.get()));
2039 
2040     return QByteArray();
2041 }
2042 
2043 const xcb_format_t *QXcbConnection::formatForDepth(uint8_t depth) const
2044 {
2045     xcb_format_iterator_t iterator =
2046         xcb_setup_pixmap_formats_iterator(m_setup);
2047 
2048     while (iterator.rem) {
2049         xcb_format_t *format = iterator.data;
2050         if (format->depth == depth)
2051             return format;
2052         xcb_format_next(&iterator);
2053     }
2054 
2055     return 0;
2056 }
2057 
2058 void QXcbConnection::sync()
2059 {
2060     // from xcb_aux_sync
2061     xcb_get_input_focus_cookie_t cookie = xcb_get_input_focus(xcb_connection());
2062     free(xcb_get_input_focus_reply(xcb_connection(), cookie, 0));
2063 }
2064 
2065 void QXcbConnection::initializeXFixes()
2066 {
2067     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_xfixes_id);
2068     if (!reply || !reply->present)
2069         return;
2070 
2071     auto xfixes_query = Q_XCB_REPLY(xcb_xfixes_query_version, m_connection,
2072                                     XCB_XFIXES_MAJOR_VERSION,
2073                                     XCB_XFIXES_MINOR_VERSION);
2074     if (!xfixes_query || xfixes_query->major_version < 2) {
2075         qWarning("QXcbConnection: Failed to initialize XFixes");
2076         return;
2077     }
2078     xfixes_first_event = reply->first_event;
2079     has_xfixes = true;
2080 }
2081 
2082 void QXcbConnection::initializeXRender()
2083 {
2084 #if QT_CONFIG(xcb_render)
2085     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_render_id);
2086     if (!reply || !reply->present)
2087         return;
2088 
2089     auto xrender_query = Q_XCB_REPLY(xcb_render_query_version, m_connection,
2090                                      XCB_RENDER_MAJOR_VERSION,
2091                                      XCB_RENDER_MINOR_VERSION);
2092     if (!xrender_query || (xrender_query->major_version == 0 && xrender_query->minor_version < 5)) {
2093         qWarning("QXcbConnection: Failed to initialize XRender");
2094         return;
2095     }
2096     has_render_extension = true;
2097 #endif
2098 }
2099 
2100 void QXcbConnection::initializeXRandr()
2101 {
2102     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_randr_id);
2103     if (!reply || !reply->present)
2104         return;
2105 
2106     xrandr_first_event = reply->first_event;
2107 
2108     auto xrandr_query = Q_XCB_REPLY(xcb_randr_query_version, m_connection,
2109                                     XCB_RANDR_MAJOR_VERSION,
2110                                     XCB_RANDR_MINOR_VERSION);
2111 
2112     has_randr_extension = true;
2113 
2114     if (!xrandr_query || (xrandr_query->major_version < 1 || (xrandr_query->major_version == 1 && xrandr_query->minor_version < 2))) {
2115         qWarning("QXcbConnection: Failed to initialize XRandr");
2116         has_randr_extension = false;
2117     }
2118 
2119     xcb_screen_iterator_t rootIter = xcb_setup_roots_iterator(m_setup);
2120     for (; rootIter.rem; xcb_screen_next(&rootIter)) {
2121         xcb_randr_select_input(xcb_connection(),
2122             rootIter.data->root,
2123             XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE |
2124             XCB_RANDR_NOTIFY_MASK_OUTPUT_CHANGE |
2125             XCB_RANDR_NOTIFY_MASK_CRTC_CHANGE |
2126             XCB_RANDR_NOTIFY_MASK_OUTPUT_PROPERTY
2127         );
2128     }
2129 }
2130 
2131 void QXcbConnection::initializeXinerama()
2132 {
2133     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_xinerama_id);
2134     if (!reply || !reply->present)
2135         return;
2136 
2137     auto xinerama_is_active = Q_XCB_REPLY(xcb_xinerama_is_active, m_connection);
2138     has_xinerama_extension = xinerama_is_active && xinerama_is_active->state;
2139 }
2140 
2141 void QXcbConnection::initializeXShape()
2142 {
2143     const xcb_query_extension_reply_t *xshape_reply = xcb_get_extension_data(m_connection, &xcb_shape_id);
2144     if (!xshape_reply || !xshape_reply->present)
2145         return;
2146 
2147     has_shape_extension = true;
2148     auto shape_query = Q_XCB_REPLY(xcb_shape_query_version, m_connection);
2149     if (!shape_query) {
2150         qWarning("QXcbConnection: Failed to initialize SHAPE extension");
2151     } else if (shape_query->major_version > 1 || (shape_query->major_version == 1 && shape_query->minor_version >= 1)) {
2152         // The input shape is the only thing added in SHAPE 1.1
2153         has_input_shape = true;
2154     }
2155 }
2156 
2157 void QXcbConnection::initializeXKB()
2158 {
2159 #if QT_CONFIG(xkb)
2160     const xcb_query_extension_reply_t *reply = xcb_get_extension_data(m_connection, &xcb_xkb_id);
2161     if (!reply || !reply->present) {
2162         qWarning("Qt: XKEYBOARD extension not present on the X server.");
2163         xkb_first_event = 0;
2164         return;
2165     }
2166     xkb_first_event = reply->first_event;
2167 
2168     xcb_connection_t *c = connection()->xcb_connection();
2169 
2170     auto xkb_query = Q_XCB_REPLY(xcb_xkb_use_extension, c,
2171                                  XKB_X11_MIN_MAJOR_XKB_VERSION,
2172                                  XKB_X11_MIN_MINOR_XKB_VERSION);
2173 
2174     if (!xkb_query) {
2175         qWarning("Qt: Failed to initialize XKB extension");
2176         return;
2177     } else if (!xkb_query->supported) {
2178         qWarning("Qt: Unsupported XKB version (We want %d %d, but X server has %d %d)",
2179                  XCB_XKB_MAJOR_VERSION, XCB_XKB_MINOR_VERSION,
2180                  xkb_query->serverMajor, xkb_query->serverMinor);
2181         return;
2182     }
2183 
2184     has_xkb = true;
2185 
2186     const uint16_t required_map_parts = (XCB_XKB_MAP_PART_KEY_TYPES |
2187         XCB_XKB_MAP_PART_KEY_SYMS |
2188         XCB_XKB_MAP_PART_MODIFIER_MAP |
2189         XCB_XKB_MAP_PART_EXPLICIT_COMPONENTS |
2190         XCB_XKB_MAP_PART_KEY_ACTIONS |
2191         XCB_XKB_MAP_PART_KEY_BEHAVIORS |
2192         XCB_XKB_MAP_PART_VIRTUAL_MODS |
2193         XCB_XKB_MAP_PART_VIRTUAL_MOD_MAP);
2194 
2195     const uint16_t required_events = (XCB_XKB_EVENT_TYPE_NEW_KEYBOARD_NOTIFY |
2196         XCB_XKB_EVENT_TYPE_MAP_NOTIFY |
2197         XCB_XKB_EVENT_TYPE_STATE_NOTIFY);
2198 
2199     // XKB events are reported to all interested clients without regard
2200     // to the current keyboard input focus or grab state
2201     xcb_void_cookie_t select = xcb_xkb_select_events_checked(c,
2202                        XCB_XKB_ID_USE_CORE_KBD,
2203                        required_events,
2204                        0,
2205                        required_events,
2206                        required_map_parts,
2207                        required_map_parts,
2208                        0);
2209 
2210     xcb_generic_error_t *error = xcb_request_check(c, select);
2211     if (error) {
2212         free(error);
2213         qWarning("Qt: failed to select notify events from xcb-xkb");
2214         return;
2215     }
2216 #endif
2217 }
2218 
2219 QXcbSystemTrayTracker *QXcbConnection::systemTrayTracker() const
2220 {
2221     if (!m_systemTrayTracker) {
2222         QXcbConnection *self = const_cast<QXcbConnection *>(this);
2223         if ((self->m_systemTrayTracker = QXcbSystemTrayTracker::create(self))) {
2224             connect(m_systemTrayTracker, SIGNAL(systemTrayWindowChanged(QScreen*)),
2225                     QGuiApplication::platformNativeInterface(), SIGNAL(systemTrayWindowChanged(QScreen*)));
2226         }
2227     }
2228     return m_systemTrayTracker;
2229 }
2230 
2231 bool QXcbConnection::xEmbedSystemTrayAvailable()
2232 {
2233     if (!QGuiApplicationPrivate::platformIntegration())
2234         return false;
2235     QXcbConnection *connection = static_cast<QXcbIntegration *>(QGuiApplicationPrivate::platformIntegration())->defaultConnection();
2236     return connection->systemTrayTracker();
2237 }
2238 
2239 bool QXcbConnection::xEmbedSystemTrayVisualHasAlphaChannel()
2240 {
2241     if (!QGuiApplicationPrivate::platformIntegration())
2242         return false;
2243     QXcbConnection *connection = static_cast<QXcbIntegration *>(QGuiApplicationPrivate::platformIntegration())->defaultConnection();
2244     return connection->systemTrayTracker() && connection->systemTrayTracker()->visualHasAlphaChannel();
2245 }
2246 
2247 bool QXcbConnection::event(QEvent *e)
2248 {
2249     if (e->type() == QEvent::User + 1) {
2250         QXcbSyncWindowRequest *ev = static_cast<QXcbSyncWindowRequest *>(e);
2251         QXcbWindow *w = ev->window();
2252         if (w) {
2253             w->updateSyncRequestCounter();
2254             ev->invalidate();
2255         }
2256         return true;
2257     }
2258     return QObject::event(e);
2259 }
2260 
2261 void QXcbSyncWindowRequest::invalidate()
2262 {
2263     if (m_window) {
2264         m_window->clearSyncWindowRequest();
2265         m_window = 0;
2266     }
2267 }
2268 
2269 QXcbConnectionGrabber::QXcbConnectionGrabber(QXcbConnection *connection)
2270     :m_connection(connection)
2271 {
2272     connection->grabServer();
2273 }
2274 
2275 QXcbConnectionGrabber::~QXcbConnectionGrabber()
2276 {
2277     if (m_connection)
2278         m_connection->ungrabServer();
2279 }
2280 
2281 void QXcbConnectionGrabber::release()
2282 {
2283     if (m_connection) {
2284         m_connection->ungrabServer();
2285         m_connection = 0;
2286     }
2287 }
2288 
2289 QT_END_NAMESPACE
