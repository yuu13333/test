I want you to act as a code reviewer of Qt Creator in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2016 BogDan Vatra <bog_dan_ro@yahoo.com>
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of Qt Creator.
7 **
8 ** Commercial License Usage
9 ** Licensees holding valid commercial Qt licenses may use this file in
10 ** accordance with the commercial license agreement provided with the
11 ** Software or, alternatively, in accordance with the terms contained in
12 ** a written agreement between you and The Qt Company. For licensing terms
13 ** and conditions see https://www.qt.io/terms-conditions. For further
14 ** information use the contact form at https://www.qt.io/contact-us.
15 **
16 ** GNU General Public License Usage
17 ** Alternatively, this file may be used under the terms of the GNU
18 ** General Public License version 3 as published by the Free Software
19 ** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
20 ** included in the packaging of this file. Please review the following
21 ** information to ensure the GNU General Public License requirements will
22 ** be met: https://www.gnu.org/licenses/gpl-3.0.html.
23 **
24 ****************************************************************************/
25 
26 #include "androidconfigurations.h"
27 #include "androidconstants.h"
28 #include "androidtoolchain.h"
29 #include "androiddevice.h"
30 #include "androidmanager.h"
31 #include "androidqtversion.h"
32 #include "androiddevicedialog.h"
33 #include "avddialog.h"
34 
35 #include <coreplugin/icore.h>
36 #include <coreplugin/messagemanager.h>
37 
38 #include <projectexplorer/devicesupport/devicemanager.h>
39 #include <projectexplorer/kitinformation.h>
40 #include <projectexplorer/kitmanager.h>
41 #include <projectexplorer/project.h>
42 #include <projectexplorer/projectexplorerconstants.h>
43 #include <projectexplorer/session.h>
44 #include <projectexplorer/toolchainmanager.h>
45 
46 #include <debugger/debuggeritemmanager.h>
47 #include <debugger/debuggeritem.h>
48 #include <debugger/debuggerkitinformation.h>
49 
50 #include <qtsupport/baseqtversion.h>
51 #include <qtsupport/qtkitinformation.h>
52 #include <qtsupport/qtversionmanager.h>
53 
54 #include <utils/algorithm.h>
55 #include <utils/environment.h>
56 #include <utils/environment.h>
57 #include <utils/hostosinfo.h>
58 #include <utils/persistentsettings.h>
59 #include <utils/qtcassert.h>
60 #include <utils/runextensions.h>
61 #include <utils/stringutils.h>
62 #include <utils/synchronousprocess.h>
63 
64 #include <QApplication>
65 #include <QDirIterator>
66 #include <QFileInfo>
67 #include <QHostAddress>
68 #include <QJsonArray>
69 #include <QJsonDocument>
70 #include <QJsonObject>
71 #include <QLoggingCategory>
72 #include <QProcess>
73 #include <QRegularExpression>
74 #include <QSettings>
75 #include <QStandardPaths>
76 #include <QStringList>
77 #include <QTcpSocket>
78 #include <QThread>
79 
80 #include <functional>
81 #include <memory>
82 
83 using namespace QtSupport;
84 using namespace ProjectExplorer;
85 using namespace Utils;
86 
87 namespace {
88 static Q_LOGGING_CATEGORY(avdConfigLog, "qtc.android.androidconfig", QtWarningMsg)
89 }
90 
91 namespace Android {
92 using namespace Internal;
93 
94 const char JsonFilePath[] = "/android/sdk_definitions.json";
95 const char SdkToolsUrlKey[] = "sdk_tools_url";
96 const char CommonKey[] = "common";
97 const char SdkEssentialPkgsKey[] = "sdk_essential_packages";
98 const char VersionsKey[] = "versions";
99 const char NdkPathKey[] = "ndk_path";
100 const char SpecificQtVersionsKey[] = "specific_qt_versions";
101 const char DefaultVersionKey[] = "default";
102 const char LinuxOsKey[] = "linux";
103 const char WindowsOsKey[] = "windows";
104 const char macOsKey[] = "mac";
105 
106 
107 namespace {
108     const char jdk8SettingsPath[] = "HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\Java Development Kit";
109     const char jdkLatestSettingsPath[] = "HKEY_LOCAL_MACHINE\\SOFTWARE\\JavaSoft\\JDK\\";
110 
111     const QLatin1String SettingsGroup("AndroidConfigurations");
112     const QLatin1String SDKLocationKey("SDKLocation");
113     const QLatin1String CustomNdkLocationsKey("CustomNdkLocations");
114     const QLatin1String SdkFullyConfiguredKey("AllEssentialsInstalled");
115     const QLatin1String SDKManagerToolArgsKey("SDKManagerToolArgs");
116     const QLatin1String OpenJDKLocationKey("OpenJDKLocation");
117     const QLatin1String OpenSslPriLocationKey("OpenSSLPriLocation");
118     const QLatin1String KeystoreLocationKey("KeystoreLocation");
119     const QLatin1String AutomaticKitCreationKey("AutomatiKitCreation");
120     const QLatin1String PartitionSizeKey("PartitionSize");
121 
122     const QLatin1String ArmToolchainPrefix("arm-linux-androideabi");
123     const QLatin1String X86ToolchainPrefix("x86");
124     const QLatin1String AArch64ToolchainPrefix("aarch64-linux-android");
125     const QLatin1String X86_64ToolchainPrefix("x86_64");
126 
127     const QLatin1String ArmToolsPrefix("arm-linux-androideabi");
128     const QLatin1String X86ToolsPrefix("i686-linux-android");
129     const QLatin1String AArch64ToolsPrefix("aarch64-linux-android");
130     const QLatin1String X86_64ToolsPrefix("x86_64-linux-android");
131 
132     const QLatin1String ArmToolsDisplayName("arm");
133     const QLatin1String X86ToolsDisplayName("i686");
134     const QLatin1String AArch64ToolsDisplayName("aarch64");
135     const QLatin1String X86_64ToolsDisplayName("x86_64");
136 
137     const QLatin1String Unknown("unknown");
138     const QLatin1String keytoolName("keytool");
139     const QLatin1String changeTimeStamp("ChangeTimeStamp");
140 
141     const QLatin1String sdkToolsVersionKey("Pkg.Revision");
142     const QLatin1String ndkRevisionKey("Pkg.Revision");
143 
144     static QString sdkSettingsFileName()
145     {
146         return Core::ICore::installerResourcePath() + "/android.xml";
147     }
148 
149     static bool is32BitUserSpace()
150     {
151         // Do the exact same check as android's emulator is doing:
152         if (HostOsInfo::isLinuxHost()) {
153             if (QSysInfo::WordSize == 32 ) {
154                 Environment env = Environment::systemEnvironment();
155                 QString executable = env.searchInPath(QLatin1String("file")).toString();
156                 QString shell = env.value(QLatin1String("SHELL"));
157                 if (executable.isEmpty() || shell.isEmpty())
158                     return true; // we can't detect, but creator is 32bit so assume 32bit
159 
160                 SynchronousProcess proc;
161                 proc.setProcessChannelMode(QProcess::MergedChannels);
162                 proc.setTimeoutS(30);
163                 SynchronousProcessResponse response = proc.runBlocking({executable, {shell}});
164                 if (response.result != SynchronousProcessResponse::Finished)
165                     return true;
166                 return !response.allOutput().contains("x86-64");
167             }
168         }
169         return false;
170     }
171 }
172 
173 //////////////////////////////////
174 // AndroidConfig
175 //////////////////////////////////
176 
177 QLatin1String AndroidConfig::toolchainPrefix(const Abi &abi)
178 {
179     switch (abi.architecture()) {
180     case Abi::ArmArchitecture:
181         if (abi.wordWidth() == 64)
182             return AArch64ToolchainPrefix;
183         return ArmToolchainPrefix;
184     case Abi::X86Architecture:
185         if (abi.wordWidth() == 64)
186             return X86_64ToolchainPrefix;
187         return X86ToolchainPrefix;
188     default:
189         return Unknown;
190     }
191 }
192 
193 QLatin1String AndroidConfig::toolsPrefix(const Abi &abi)
194 {
195     switch (abi.architecture()) {
196     case Abi::ArmArchitecture:
197         if (abi.wordWidth() == 64)
198             return AArch64ToolsPrefix;
199         return ArmToolsPrefix;
200     case Abi::X86Architecture:
201         if (abi.wordWidth() == 64)
202             return X86_64ToolsPrefix;
203         return X86ToolsPrefix;
204     default:
205         return Unknown;
206     }
207 }
208 
209 QLatin1String AndroidConfig::displayName(const Abi &abi)
210 {
211     switch (abi.architecture()) {
212     case Abi::ArmArchitecture:
213         if (abi.wordWidth() == 64)
214             return AArch64ToolsDisplayName;
215         return ArmToolsDisplayName;
216     case Abi::X86Architecture:
217         if (abi.wordWidth() == 64)
218             return X86_64ToolsDisplayName;
219         return X86ToolsDisplayName;
220     default:
221         return Unknown;
222     }
223 }
224 
225 void AndroidConfig::load(const QSettings &settings)
226 {
227     // user settings
228     m_partitionSize = settings.value(PartitionSizeKey, 1024).toInt();
229     m_sdkLocation = FilePath::fromString(settings.value(SDKLocationKey).toString());
230     m_customNdkList = settings.value(CustomNdkLocationsKey).toStringList();
231     m_sdkManagerToolArgs = settings.value(SDKManagerToolArgsKey).toStringList();
232     m_openJDKLocation = FilePath::fromString(settings.value(OpenJDKLocationKey).toString());
233     m_openSslLocation = FilePath::fromString(settings.value(OpenSslPriLocationKey).toString());
234     m_keystoreLocation = FilePath::fromString(settings.value(KeystoreLocationKey).toString());
235     m_automaticKitCreation = settings.value(AutomaticKitCreationKey, true).toBool();
236     m_sdkFullyConfigured = settings.value(SdkFullyConfiguredKey, false).toBool();
237 
238     PersistentSettingsReader reader;
239     if (reader.load(FilePath::fromString(sdkSettingsFileName()))
240             && settings.value(changeTimeStamp).toInt() != QFileInfo(sdkSettingsFileName()).lastModified().toMSecsSinceEpoch() / 1000) {
241         // persisten settings
242         m_sdkLocation = FilePath::fromString(reader.restoreValue(SDKLocationKey, m_sdkLocation.toString()).toString());
243         m_customNdkList = reader.restoreValue(CustomNdkLocationsKey).toStringList();
244         m_sdkManagerToolArgs = reader.restoreValue(SDKManagerToolArgsKey, m_sdkManagerToolArgs).toStringList();
245         m_openJDKLocation = FilePath::fromString(reader.restoreValue(OpenJDKLocationKey, m_openJDKLocation.toString()).toString());
246         m_openSslLocation = FilePath::fromString(reader.restoreValue(OpenSslPriLocationKey, m_openSslLocation.toString()).toString());
247         m_automaticKitCreation = reader.restoreValue(AutomaticKitCreationKey, m_automaticKitCreation).toBool();
248         m_sdkFullyConfigured = reader.restoreValue(SdkFullyConfiguredKey, m_sdkFullyConfigured).toBool();
249         // persistent settings
250     }
251     m_customNdkList.removeAll("");
252     parseDependenciesJson();
253 }
254 
255 void AndroidConfig::save(QSettings &settings) const
256 {
257     QFileInfo fileInfo(sdkSettingsFileName());
258     if (fileInfo.exists())
259         settings.setValue(changeTimeStamp, fileInfo.lastModified().toMSecsSinceEpoch() / 1000);
260 
261     // user settings
262     settings.setValue(SDKLocationKey, m_sdkLocation.toString());
263     settings.setValue(CustomNdkLocationsKey, m_customNdkList);
264     settings.setValue(SDKManagerToolArgsKey, m_sdkManagerToolArgs);
265     settings.setValue(OpenJDKLocationKey, m_openJDKLocation.toString());
266     settings.setValue(KeystoreLocationKey, m_keystoreLocation.toString());
267     settings.setValue(OpenSslPriLocationKey, m_openSslLocation.toString());
268     settings.setValue(PartitionSizeKey, m_partitionSize);
269     settings.setValue(AutomaticKitCreationKey, m_automaticKitCreation);
270     settings.setValue(SdkFullyConfiguredKey, m_sdkFullyConfigured);
271 }
272 
273 void AndroidConfig::parseDependenciesJson()
274 {
275     QString sdkConfigUserFile(Core::ICore::userResourcePath() + JsonFilePath);
276     QString sdkConfigFile(Core::ICore::resourcePath() + JsonFilePath);
277 
278     if (!QFile::exists(sdkConfigUserFile)) {
279         QDir(QFileInfo(sdkConfigUserFile).absolutePath()).mkpath(".");
280         QFile::copy(sdkConfigFile, sdkConfigUserFile);
281     }
282 
283     if (QFileInfo(sdkConfigFile).lastModified() > QFileInfo(sdkConfigUserFile).lastModified()) {
284         QFile::remove(sdkConfigUserFile + ".old");
285         QFile::rename(sdkConfigUserFile, sdkConfigUserFile + ".old");
286         QFile::copy(sdkConfigFile, sdkConfigUserFile);
287     }
288 
289     QFile jsonFile(sdkConfigUserFile);
290     if (!jsonFile.open(QIODevice::ReadOnly)) {
291         qCDebug(avdConfigLog, "Couldn't open JSON config file %s.", qPrintable(jsonFile.fileName()));
292         return;
293     }
294 
295     QJsonObject jsonObject = QJsonDocument::fromJson(jsonFile.readAll()).object();
296 
297     if (jsonObject.contains(CommonKey) && jsonObject[CommonKey].isObject()) {
298         QJsonObject commonObject = jsonObject[CommonKey].toObject();
299         // Parse SDK Tools URL
300         if (commonObject.contains(SdkToolsUrlKey) && commonObject[SdkToolsUrlKey].isObject()) {
301             QJsonObject sdkToolsObj(commonObject[SdkToolsUrlKey].toObject());
302             if (Utils::HostOsInfo::isMacHost()) {
303                 m_sdkToolsUrl = sdkToolsObj[macOsKey].toString();
304                 m_sdkToolsSha256 = QByteArray::fromHex(sdkToolsObj["mac_sha256"].toString().toUtf8());
305             } else if (Utils::HostOsInfo::isWindowsHost()) {
306                 m_sdkToolsUrl = sdkToolsObj[WindowsOsKey].toString();
307                 m_sdkToolsSha256 = QByteArray::fromHex(sdkToolsObj["windows_sha256"].toString().toUtf8());
308             } else {
309                 m_sdkToolsUrl = sdkToolsObj[LinuxOsKey].toString();
310                 m_sdkToolsSha256 = QByteArray::fromHex(sdkToolsObj["linux_sha256"].toString().toUtf8());
311             }
312         }
313 
314         // Parse common essential packages
315         auto appendEssentialsFromArray = [this](QJsonArray array) {
316             for (const QJsonValueRef &pkg : array)
317                 m_commonEssentialPkgs.append(pkg.toString());
318         };
319 
320         QJsonObject commonEssentials = commonObject[SdkEssentialPkgsKey].toObject();
321         appendEssentialsFromArray(commonEssentials[DefaultVersionKey].toArray());
322 
323         if (Utils::HostOsInfo::isWindowsHost())
324             appendEssentialsFromArray(commonEssentials[WindowsOsKey].toArray());
325         if (Utils::HostOsInfo::isMacHost())
326             appendEssentialsFromArray(commonEssentials[macOsKey].toArray());
327         else
328             appendEssentialsFromArray(commonEssentials[LinuxOsKey].toArray());
329     }
330 
331     auto fillQtVersionsRange = [](const QString &shortVersion) {
332         QList<QtVersionNumber> versions;
333         QRegularExpression re("([0-9]\\.[0-9]*\\.)\\[([0-9])\\-([0-9])\\]");
334         QRegularExpressionMatch match = re.match(shortVersion);
335         if (match.hasMatch() && match.lastCapturedIndex() == 3)
336             for (int i = match.captured(2).toInt(); i <= match.captured(3).toInt(); ++i)
337                 versions.append(QtVersionNumber(match.captured(1) + QString::number(i)));
338         else
339             versions.append(QtVersionNumber(shortVersion));
340 
341         return versions;
342     };
343 
344     if (jsonObject.contains(SpecificQtVersionsKey) && jsonObject[SpecificQtVersionsKey].isArray()) {
345         QJsonArray versionsArray = jsonObject[SpecificQtVersionsKey].toArray();
346         for (const QJsonValueRef &item : versionsArray) {
347             QJsonObject itemObj = item.toObject();
348             SdkForQtVersions specificVersion;
349 
350             specificVersion.ndkPath = itemObj[NdkPathKey].toString();
351             for (const QJsonValueRef &pkg : itemObj[SdkEssentialPkgsKey].toArray())
352                 specificVersion.essentialPackages.append(pkg.toString());
353             for (const QJsonValueRef &pkg : itemObj[VersionsKey].toArray())
354                 specificVersion.versions.append(fillQtVersionsRange(pkg.toString()));
355 
356             if (itemObj[VersionsKey].toArray().first().toString() == DefaultVersionKey)
357                 m_defaultSdkDepends = specificVersion;
358             else
359                 m_specificQtVersions.append(specificVersion);
360         }
361     }
362 }
363 
364 QVector<int> AndroidConfig::availableNdkPlatforms(const BaseQtVersion *qtVersion) const
365 {
366     QVector<int> availableNdkPlatforms;
367     QDirIterator it(ndkLocation(qtVersion).pathAppended("platforms").toString(),
368                     QStringList("android-*"),
369                     QDir::Dirs);
370     while (it.hasNext()) {
371         const QString &fileName = it.next();
372         availableNdkPlatforms.push_back(
373             fileName.midRef(fileName.lastIndexOf(QLatin1Char('-')) + 1).toInt());
374     }
375     Utils::sort(availableNdkPlatforms, std::greater<>());
376 
377     return availableNdkPlatforms;
378 }
379 
380 QStringList AndroidConfig::getCustomNdkList() const
381 {
382     return m_customNdkList;
383 }
384 
385 void AndroidConfig::addCustomNdk(const QString &customNdk)
386 {
387     if (!m_customNdkList.contains(customNdk))
388         m_customNdkList.append(customNdk);
389 }
390 
391 void AndroidConfig::removeCustomNdk(const QString &customNdk)
392 {
393     m_customNdkList.removeAll(customNdk);
394 }
395 
396 Utils::FilePath AndroidConfig::openSslLocation() const
397 {
398     return m_openSslLocation;
399 }
400 
401 void AndroidConfig::setOpenSslLocation(const Utils::FilePath &openSslLocation)
402 {
403     m_openSslLocation = openSslLocation;
404 }
405 
406 QStringList AndroidConfig::apiLevelNamesFor(const SdkPlatformList &platforms)
407 {
408     return Utils::transform(platforms, AndroidConfig::apiLevelNameFor);
409 }
410 
411 QString AndroidConfig::apiLevelNameFor(const SdkPlatform *platform)
412 {
413     return platform && platform->apiLevel() > 0 ?
414                 QString("android-%1").arg(platform->apiLevel()) : "";
415 }
416 
417 bool AndroidConfig::isCmdlineSdkToolsInstalled() const
418 {
419     QString toolPath("cmdline-tools/latest/bin/sdkmanager");
420     if (HostOsInfo::isWindowsHost())
421         toolPath += ANDROID_BAT_SUFFIX;
422 
423     return m_sdkLocation.pathAppended(toolPath).exists();
424 }
425 
426 FilePath AndroidConfig::adbToolPath() const
427 {
428     return m_sdkLocation / "platform-tools/adb" QTC_HOST_EXE_SUFFIX;
429 }
430 
431 FilePath AndroidConfig::androidToolPath() const
432 {
433     if (HostOsInfo::isWindowsHost()) {
434         // I want to switch from using android.bat to using an executable. All it really does is call
435         // Java and I've made some progress on it. So if android.exe exists, return that instead.
436         const FilePath path = m_sdkLocation / "tools/android" QTC_HOST_EXE_SUFFIX;
437         if (path.exists())
438             return path;
439         return m_sdkLocation / "tools/android" ANDROID_BAT_SUFFIX;
440     }
441     return m_sdkLocation / "tools/android";
442 }
443 
444 FilePath AndroidConfig::emulatorToolPath() const
445 {
446     QString relativePath = "emulator/emulator";
447     if (sdkToolsVersion() < QVersionNumber(25, 3, 0) && !isCmdlineSdkToolsInstalled())
448         relativePath = "tools/emulator";
449     return m_sdkLocation / (relativePath + QTC_HOST_EXE_SUFFIX);
450 }
451 
452 FilePath AndroidConfig::sdkManagerToolPath() const
453 {
454     QStringList sdkmanagerPaths = {"cmdline-tools/latest/bin/sdkmanager",
455                                    "tools/bin/sdkmanager"};
456 
457     for (QString &toolPath : sdkmanagerPaths) {
458         if (HostOsInfo::isWindowsHost())
459             toolPath += ANDROID_BAT_SUFFIX;
460 
461         const FilePath sdkmanagerPath = m_sdkLocation / toolPath;
462         if (sdkmanagerPath.exists())
463             return sdkmanagerPath;
464     }
465 
466     return FilePath();
467 }
468 
469 FilePath AndroidConfig::avdManagerToolPath() const
470 {
471     QStringList sdkmanagerPaths = {"cmdline-tools/latest/bin/avdmanager",
472                                    "tools/bin/avdmanager"};
473 
474     for (QString &toolPath : sdkmanagerPaths) {
475         if (HostOsInfo::isWindowsHost())
476             toolPath += ANDROID_BAT_SUFFIX;
477 
478         const FilePath sdkmanagerPath = m_sdkLocation / toolPath;
479         if (sdkmanagerPath.exists())
480             return sdkmanagerPath;
481     }
482 
483     return FilePath();
484 }
485 
486 FilePath AndroidConfig::aaptToolPath() const
487 {
488     const FilePath aaptToolPath = m_sdkLocation / "build-tools";
489     QString toolPath = QString("%1/aapt").arg(buildToolsVersion().toString());
490     if (HostOsInfo::isWindowsHost())
491         toolPath += QTC_HOST_EXE_SUFFIX;
492     return aaptToolPath / toolPath;
493 }
494 
495 FilePath AndroidConfig::toolchainPathFromNdk(const Utils::FilePath &ndkLocation) const
496 {
497     const FilePath toolchainPath = ndkLocation / "toolchains/llvm/prebuilt/";
498 
499     // detect toolchain host
500     QStringList hostPatterns;
501     switch (HostOsInfo::hostOs()) {
502     case OsTypeLinux:
503         hostPatterns << QLatin1String("linux*");
504         break;
505     case OsTypeWindows:
506         hostPatterns << QLatin1String("windows*");
507         break;
508     case OsTypeMac:
509         hostPatterns << QLatin1String("darwin*");
510         break;
511     default: /* unknown host */ return FilePath();
512     }
513 
514     QDirIterator iter(toolchainPath.toString(), hostPatterns, QDir::Dirs);
515     if (iter.hasNext()) {
516         iter.next();
517         return toolchainPath / iter.fileName();
518     }
519 
520     return {};
521 }
522 
523 FilePath AndroidConfig::toolchainPath(const BaseQtVersion *qtVersion) const
524 {
525     return toolchainPathFromNdk(ndkLocation(qtVersion));
526 }
527 
528 FilePath AndroidConfig::clangPathFromNdk(const Utils::FilePath &ndkLocation) const
529 {
530     const FilePath path = toolchainPathFromNdk(ndkLocation);
531     if (path.isEmpty())
532         return {};
533     return path / HostOsInfo::withExecutableSuffix("bin/clang");
534 }
535 
536 FilePath AndroidConfig::clangPath(const BaseQtVersion *qtVersion) const
537 {
538     return clangPathFromNdk(ndkLocation(qtVersion));
539 }
540 
541 FilePath AndroidConfig::gdbPath(const ProjectExplorer::Abi &abi, const BaseQtVersion *qtVersion) const
542 {
543     return gdbPathFromNdk(abi, ndkLocation(qtVersion));
544 }
545 
546 FilePath AndroidConfig::gdbPathFromNdk(const Abi &abi, const FilePath &ndkLocation) const
547 {
548     const FilePath path = ndkLocation.pathAppended(
549         QString("prebuilt/%1/bin/gdb%2").arg(toolchainHostFromNdk(ndkLocation),
550                                              QString(QTC_HOST_EXE_SUFFIX)));
551     if (path.exists())
552         return path;
553     // fallback for old NDKs (e.g. 10e)
554     return ndkLocation.pathAppended(QString("toolchains/%1-4.9/prebuilt/%2/bin/%3-gdb%4")
555                                                    .arg(toolchainPrefix(abi),
556                                                         toolchainHostFromNdk(ndkLocation),
557                                                         toolsPrefix(abi),
558                                                         QString(QTC_HOST_EXE_SUFFIX)));
559 }
560 
561 FilePath AndroidConfig::makePath(const BaseQtVersion *qtVersion) const
562 {
563     return makePathFromNdk(ndkLocation(qtVersion));
564 }
565 
566 FilePath AndroidConfig::makePathFromNdk(const FilePath &ndkLocation) const
567 {
568     return ndkLocation.pathAppended(
569                 QString("prebuilt/%1/bin/make%2").arg(toolchainHostFromNdk(ndkLocation),
570                                                       QString(QTC_HOST_EXE_SUFFIX)));
571 }
572 
573 FilePath AndroidConfig::openJDKBinPath() const
574 {
575     const FilePath path = m_openJDKLocation;
576     if (!path.isEmpty())
577         return path.pathAppended("bin");
578     return path;
579 }
580 
581 FilePath AndroidConfig::keytoolPath() const
582 {
583     return openJDKBinPath().pathAppended(keytoolName);
584 }
585 
586 QVector<AndroidDeviceInfo> AndroidConfig::connectedDevices(QString *error) const
587 {
588     return connectedDevices(adbToolPath(), error);
589 }
590 
591 QVector<AndroidDeviceInfo> AndroidConfig::connectedDevices(const FilePath &adbToolPath, QString *error)
592 {
593     QVector<AndroidDeviceInfo> devices;
594     SynchronousProcess adbProc;
595     adbProc.setTimeoutS(30);
596     CommandLine cmd{adbToolPath, {"devices"}};
597     SynchronousProcessResponse response = adbProc.runBlocking(cmd);
598     if (response.result != SynchronousProcessResponse::Finished) {
599         if (error)
600             *error = QApplication::translate("AndroidConfiguration", "Could not run: %1")
601                 .arg(cmd.toUserOutput());
602         return devices;
603     }
604     QStringList adbDevs = response.allOutput().split('\n', Qt::SkipEmptyParts);
605     if (adbDevs.empty())
606         return devices;
607 
608     for (const QString &line : adbDevs) // remove the daemon logs
609         if (line.startsWith("* daemon"))
610             adbDevs.removeOne(line);
611     adbDevs.removeFirst(); // remove "List of devices attached" header line
612 
613     // workaround for '????????????' serial numbers:
614     // can use "adb -d" when only one usb device attached
615     foreach (const QString &device, adbDevs) {
616         const QString serialNo = device.left(device.indexOf('\t')).trimmed();
617         const QString deviceType = device.mid(device.indexOf('\t')).trimmed();
618         if (isBootToQt(adbToolPath, serialNo))
619             continue;
620         AndroidDeviceInfo dev;
621         dev.serialNumber = serialNo;
622         dev.type = serialNo.startsWith(QLatin1String("emulator")) ? AndroidDeviceInfo::Emulator : AndroidDeviceInfo::Hardware;
623         dev.sdk = getSDKVersion(adbToolPath, dev.serialNumber);
624         dev.cpuAbi = getAbis(adbToolPath, dev.serialNumber);
625         if (deviceType == QLatin1String("unauthorized"))
626             dev.state = AndroidDeviceInfo::UnAuthorizedState;
627         else if (deviceType == QLatin1String("offline"))
628             dev.state = AndroidDeviceInfo::OfflineState;
629         else
630             dev.state = AndroidDeviceInfo::OkState;
631 
632         if (dev.type == AndroidDeviceInfo::Emulator) {
633             dev.avdname = getAvdName(dev.serialNumber);
634             if (dev.avdname.isEmpty())
635                 dev.avdname = serialNo;
636         }
637 
638         devices.push_back(dev);
639     }
640 
641     Utils::sort(devices);
642     if (devices.isEmpty() && error)
643         *error = QApplication::translate("AndroidConfiguration",
644                                          "No devices found in output of: %1")
645             .arg(cmd.toUserOutput());
646     return devices;
647 }
648 
649 bool AndroidConfig::isConnected(const QString &serialNumber) const
650 {
651     QVector<AndroidDeviceInfo> devices = connectedDevices();
652     foreach (AndroidDeviceInfo device, devices) {
653         if (device.serialNumber == serialNumber)
654             return true;
655     }
656     return false;
657 }
658 
659 bool AndroidConfig::isBootToQt(const QString &device) const
660 {
661     return isBootToQt(adbToolPath(), device);
662 }
663 
664 bool AndroidConfig::isBootToQt(const FilePath &adbToolPath, const QString &device)
665 {
666     // workaround for '????????????' serial numbers
667     CommandLine cmd(adbToolPath, AndroidDeviceInfo::adbSelector(device));
668     cmd.addArg("shell");
669     cmd.addArg("ls -l /system/bin/appcontroller || ls -l /usr/bin/appcontroller && echo Boot2Qt");
670 
671     SynchronousProcess adbProc;
672     adbProc.setTimeoutS(10);
673     SynchronousProcessResponse response = adbProc.runBlocking(cmd);
674     return response.result == SynchronousProcessResponse::Finished
675             && response.allOutput().contains(QLatin1String("Boot2Qt"));
676 }
677 
678 
679 QString AndroidConfig::getDeviceProperty(const FilePath &adbToolPath, const QString &device, const QString &property)
680 {
681     // workaround for '????????????' serial numbers
682     CommandLine cmd(adbToolPath, AndroidDeviceInfo::adbSelector(device));
683     cmd.addArgs({"shell", "getprop", property});
684 
685     SynchronousProcess adbProc;
686     adbProc.setTimeoutS(10);
687     SynchronousProcessResponse response = adbProc.runBlocking(cmd);
688     if (response.result != SynchronousProcessResponse::Finished)
689         return QString();
690 
691     return response.allOutput();
692 }
693 
694 int AndroidConfig::getSDKVersion(const QString &device) const
695 {
696     return getSDKVersion(adbToolPath(), device);
697 }
698 
699 int AndroidConfig::getSDKVersion(const FilePath &adbToolPath, const QString &device)
700 {
701     QString tmp = getDeviceProperty(adbToolPath, device, "ro.build.version.sdk");
702     if (tmp.isEmpty())
703         return -1;
704     return tmp.trimmed().toInt();
705 }
706 
707 QString AndroidConfig::getAvdName(const QString &serialnumber)
708 {
709     int index = serialnumber.indexOf(QLatin1String("-"));
710     if (index == -1)
711         return QString();
712     bool ok;
713     int port = serialnumber.midRef(index + 1).toInt(&ok);
714     if (!ok)
715         return QString();
716 
717     const QByteArray avdName = "avd name\n";
718 
719     QTcpSocket tcpSocket;
720     tcpSocket.connectToHost(QHostAddress(QHostAddress::LocalHost), port);
721     if (!tcpSocket.waitForConnected(100)) // Don't wait more than 100ms for a local connection
722         return QString{};
723 
724     tcpSocket.write(avdName + "exit\n");
725     tcpSocket.waitForDisconnected(500);
726 
727     QByteArray name;
728     const QByteArrayList response = tcpSocket.readAll().split('\n');
729     // The input "avd name" might not be echoed as-is, but contain ASCII
730     // control sequences.
731     for (int i = response.size() - 1; i > 1; --i) {
732         if (response.at(i).startsWith("OK")) {
733             name = response.at(i - 1);
734             break;
735         }
736     }
737     return QString::fromLatin1(name).trimmed();
738 }
739 
740 AndroidConfig::OpenGl AndroidConfig::getOpenGLEnabled(const QString &emulator) const
741 {
742     QDir dir = QDir::home();
743     if (!dir.cd(QLatin1String(".android")))
744         return OpenGl::Unknown;
745     if (!dir.cd(QLatin1String("avd")))
746         return OpenGl::Unknown;
747     if (!dir.cd(emulator + QLatin1String(".avd")))
748         return OpenGl::Unknown;
749     QFile file(dir.filePath(QLatin1String("config.ini")));
750     if (!file.exists())
751         return OpenGl::Unknown;
752     if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
753         return OpenGl::Unknown;
754     while (!file.atEnd()) {
755         QByteArray line = file.readLine();
756         if (line.contains("hw.gpu.enabled") && line.contains("yes"))
757             return OpenGl::Enabled;
758     }
759     return OpenGl::Disabled;
760 }
761 
762 //!
763 //! \brief AndroidConfigurations::getProductModel
764 //! \param device serial number
765 //! \return the produce model of the device or if that cannot be read the serial number
766 //!
767 QString AndroidConfig::getProductModel(const QString &device) const
768 {
769     if (m_serialNumberToDeviceName.contains(device))
770         return m_serialNumberToDeviceName.value(device);
771 
772     QString model = getDeviceProperty(adbToolPath(), device, "ro.product.model").trimmed();
773     if (model.isEmpty())
774         return device;
775 
776     if (!device.startsWith(QLatin1String("????")))
777         m_serialNumberToDeviceName.insert(device, model);
778     return model;
779 }
780 
781 QStringList AndroidConfig::getAbis(const QString &device) const
782 {
783     return getAbis(adbToolPath(), device);
784 }
785 
786 QStringList AndroidConfig::getAbis(const FilePath &adbToolPath, const QString &device)
787 {
788     QStringList result;
789     // First try via ro.product.cpu.abilist
790     QStringList arguments = AndroidDeviceInfo::adbSelector(device);
791     arguments << "shell" << "getprop" << "ro.product.cpu.abilist";
792     SynchronousProcess adbProc;
793     adbProc.setTimeoutS(10);
794     SynchronousProcessResponse response = adbProc.runBlocking({adbToolPath, arguments});
795     if (response.result != SynchronousProcessResponse::Finished)
796         return result;
797 
798     QString output = response.allOutput().trimmed();
799     if (!output.isEmpty()) {
800         QStringList result = output.split(QLatin1Char(','));
801         if (!result.isEmpty())
802             return result;
803     }
804 
805     // Fall back to ro.product.cpu.abi, ro.product.cpu.abi2 ...
806     for (int i = 1; i < 6; ++i) {
807         QStringList arguments = AndroidDeviceInfo::adbSelector(device);
808         arguments << QLatin1String("shell") << QLatin1String("getprop");
809         if (i == 1)
810             arguments << QLatin1String("ro.product.cpu.abi");
811         else
812             arguments << QString::fromLatin1("ro.product.cpu.abi%1").arg(i);
813 
814         SynchronousProcess abiProc;
815         abiProc.setTimeoutS(10);
816         SynchronousProcessResponse abiResponse = abiProc.runBlocking({adbToolPath, arguments});
817         if (abiResponse.result != SynchronousProcessResponse::Finished)
818             return result;
819 
820         QString abi = abiResponse.allOutput().trimmed();
821         if (abi.isEmpty())
822             break;
823         result << abi;
824     }
825     return result;
826 }
827 
828 bool AndroidConfig::isValidNdk(const QString &ndkLocation) const
829 {
830     auto ndkPath = Utils::FilePath::fromUserInput(ndkLocation);
831     const Utils::FilePath ndkPlatformsDir = ndkPath.pathAppended("platforms");
832 
833     return ndkPath.exists() && ndkPath.pathAppended("toolchains").exists()
834            && ndkPlatformsDir.exists() && !ndkPlatformsDir.toString().contains(' ')
835            && !ndkVersion(ndkPath).isNull();
836 }
837 
838 QString AndroidConfig::bestNdkPlatformMatch(int target, const BaseQtVersion *qtVersion) const
839 {
840     target = std::max(AndroidManager::apiLevelRange().first, target);
841     foreach (int apiLevel, availableNdkPlatforms(qtVersion)) {
842         if (apiLevel <= target)
843             return QString::fromLatin1("android-%1").arg(apiLevel);
844     }
845     return QString("android-%1").arg(AndroidManager::apiLevelRange().first);
846 }
847 
848 FilePath AndroidConfig::sdkLocation() const
849 {
850     return m_sdkLocation;
851 }
852 
853 void AndroidConfig::setSdkLocation(const FilePath &sdkLocation)
854 {
855     m_sdkLocation = sdkLocation;
856 }
857 
858 QVersionNumber AndroidConfig::sdkToolsVersion() const
859 {
860     QVersionNumber version;
861     if (m_sdkLocation.exists()) {
862         FilePath sdkToolsPropertiesPath;
863         if (isCmdlineSdkToolsInstalled())
864             sdkToolsPropertiesPath = m_sdkLocation / "cmdline-tools/latest/source.properties";
865         else
866             sdkToolsPropertiesPath = m_sdkLocation / "tools/source.properties";
867         QSettings settings(sdkToolsPropertiesPath.toString(), QSettings::IniFormat);
868         auto versionStr = settings.value(sdkToolsVersionKey).toString();
869         version = QVersionNumber::fromString(versionStr);
870     }
871     return version;
872 }
873 
874 QVersionNumber AndroidConfig::buildToolsVersion() const
875 {
876     //TODO: return version according to qt version
877     QVersionNumber maxVersion;
878     QDir buildToolsDir(m_sdkLocation.pathAppended("build-tools").toString());
879     for (const QFileInfo &file: buildToolsDir.entryInfoList(QDir::Dirs|QDir::NoDotAndDotDot))
880         maxVersion = qMax(maxVersion, QVersionNumber::fromString(file.fileName()));
881     return maxVersion;
882 }
883 
884 QStringList AndroidConfig::sdkManagerToolArgs() const
885 {
886     return m_sdkManagerToolArgs;
887 }
888 
889 void AndroidConfig::setSdkManagerToolArgs(const QStringList &args)
890 {
891     m_sdkManagerToolArgs = args;
892 }
893 
894 FilePath AndroidConfig::ndkLocation(const BaseQtVersion *qtVersion) const
895 {
896     return sdkLocation().pathAppended(ndkPathFromQtVersion(*qtVersion));
897 }
898 
899 FilePath AndroidConfig::defaultNdkLocation() const
900 {
901     return sdkLocation().pathAppended(m_defaultSdkDepends.ndkPath);
902 }
903 
904 QVersionNumber AndroidConfig::ndkVersion(const BaseQtVersion *qtVersion) const
905 {
906     return ndkVersion(ndkLocation(qtVersion));
907 }
908 
909 QVersionNumber AndroidConfig::ndkVersion(const FilePath &ndkPath) const
910 {
911     QVersionNumber version;
912     if (!ndkPath.exists()) {
913         qCDebug(avdConfigLog) << "Cannot find ndk version. Check NDK path."
914                               << ndkPath.toString();
915         return version;
916     }
917 
918     const FilePath ndkPropertiesPath = ndkPath.pathAppended("source.properties");
919     if (ndkPropertiesPath.exists()) {
920         // source.properties files exists in NDK version > 11
921         QSettings settings(ndkPropertiesPath.toString(), QSettings::IniFormat);
922         auto versionStr = settings.value(ndkRevisionKey).toString();
923         version = QVersionNumber::fromString(versionStr);
924     } else {
925         // No source.properties. There should be a file named RELEASE.TXT
926         const FilePath ndkReleaseTxtPath = ndkPath.pathAppended("RELEASE.TXT");
927         Utils::FileReader reader;
928         QString errorString;
929         if (reader.fetch(ndkReleaseTxtPath.toString(), &errorString)) {
930             // RELEASE.TXT contains the ndk version in either of the following formats:
931             // r6a
932             // r10e (64 bit)
933             QString content = QString::fromUtf8(reader.data());
934             QRegularExpression re("(r)(?<major>[0-9]{1,2})(?<minor>[a-z]{1,1})");
935             QRegularExpressionMatch match = re.match(content);
936             if (match.hasMatch()) {
937                 QString major = match.captured("major");
938                 QString minor = match.captured("minor");
939                 // Minor version: a = 0, b = 1, c = 2 and so on.
940                 // Int equivalent = minorVersionChar - 'a'. i.e. minorVersionChar - 97.
941                 version = QVersionNumber::fromString(QString("%1.%2.0").arg(major)
942                                                      .arg((int)minor[0].toLatin1() - 97));
943             } else {
944                 qCDebug(avdConfigLog) << "Cannot find ndk version. Cannot parse RELEASE.TXT."
945                                       << content;
946             }
947         } else {
948             qCDebug(avdConfigLog) << "Cannot find ndk version." << errorString;
949         }
950     }
951     return version;
952 }
953 
954 QStringList AndroidConfig::allEssentials() const
955 {
956     QList<BaseQtVersion *> installedVersions = QtVersionManager::versions(
957         [](const BaseQtVersion *v) {
958             return v->targetDeviceTypes().contains(Android::Constants::ANDROID_DEVICE_TYPE);
959         });
960 
961     QStringList allPackages(defaultEssentials());
962     for (const BaseQtVersion *version : installedVersions)
963         allPackages.append(essentialsFromQtVersion(*version));
964     allPackages.removeDuplicates();
965 
966     return allPackages;
967 }
968 
969 QString findOlderNdk(const QStringList &olderNdks, const QString &newNdk)
970 {
971     auto splitSdkStylePath = [](const QString &package) -> QPair<QString, QVersionNumber> {
972         const QStringList elements = package.split(";");
973         if (elements.count() != 2)
974             return {};
975         return {elements.first(), QVersionNumber::fromString(elements.last())};
976     };
977 
978     const auto newNdkAndVersion = splitSdkStylePath(newNdk);
979     if (newNdkAndVersion.first != "ndk" || newNdkAndVersion.second.isNull())
980         return {};
981 
982     for (const QString &oldNdk : olderNdks) {
983         const auto oldNdkAndVersion = splitSdkStylePath(oldNdk);
984         if (oldNdkAndVersion.first != "ndk" || oldNdkAndVersion.second.isNull())
985             continue;
986         if (newNdkAndVersion.second > oldNdkAndVersion.second)
987             return oldNdk;
988     }
989     return {};
990 }
991 
992 bool AndroidConfig::allEssentialsInstalled(AndroidSdkManager *sdkManager)
993 {
994     QStringList essentialPkgs(allEssentials());
995     for (const AndroidSdkPackage *pkg : sdkManager->installedSdkPackages()) {
996         if (essentialPkgs.contains(pkg->sdkStylePath())) {
997             essentialPkgs.removeOne(pkg->sdkStylePath());
998         } else {
999             // Accept newer Ndks than prescribed by "essentialPkgs".
1000             // Check whether the list of installed packages contains a newer Ndk than "pkg".
1001             const QString olderNdk = findOlderNdk(essentialPkgs, pkg->sdkStylePath());
1002             if (!olderNdk.isEmpty())
1003                 essentialPkgs.removeOne(olderNdk);
1004         }
1005         if (essentialPkgs.isEmpty())
1006             break;
1007     }
1008     return essentialPkgs.isEmpty() ? true : false;
1009 }
1010 
1011 bool AndroidConfig::sdkToolsOk() const
1012 {
1013     bool exists = sdkLocation().exists();
1014     bool writable = sdkLocation().isWritablePath();
1015     bool sdkToolsExist = !sdkToolsVersion().isNull();
1016     return exists && writable && sdkToolsExist;
1017 }
1018 
1019 QStringList AndroidConfig::essentialsFromQtVersion(const BaseQtVersion &version) const
1020 {
1021     QtVersionNumber qtVersion = version.qtVersion();
1022     for (const SdkForQtVersions &item : m_specificQtVersions)
1023         if (item.containsVersion(qtVersion))
1024             return item.essentialPackages;
1025 
1026     return m_defaultSdkDepends.essentialPackages;
1027 }
1028 
1029 QString AndroidConfig::ndkPathFromQtVersion(const BaseQtVersion &version) const
1030 {
1031     QtVersionNumber qtVersion(version.qtVersionString());
1032     for (const SdkForQtVersions &item : m_specificQtVersions)
1033         if (item.containsVersion(qtVersion))
1034             return item.ndkPath;
1035 
1036     return m_defaultSdkDepends.ndkPath;
1037 }
1038 
1039 QStringList AndroidConfig::defaultEssentials() const
1040 {
1041     return m_defaultSdkDepends.essentialPackages + m_commonEssentialPkgs;
1042 }
1043 
1044 bool SdkForQtVersions::containsVersion(const QtVersionNumber &qtVersion) const
1045 {
1046     return versions.contains(qtVersion)
1047            || versions.contains(QtVersionNumber(qtVersion.majorVersion, qtVersion.minorVersion));
1048 }
1049 
1050 FilePath AndroidConfig::openJDKLocation() const
1051 {
1052     return m_openJDKLocation;
1053 }
1054 
1055 void AndroidConfig::setOpenJDKLocation(const FilePath &openJDKLocation)
1056 {
1057     m_openJDKLocation = openJDKLocation;
1058 }
1059 
1060 FilePath AndroidConfig::keystoreLocation() const
1061 {
1062     return m_keystoreLocation;
1063 }
1064 
1065 void AndroidConfig::setKeystoreLocation(const FilePath &keystoreLocation)
1066 {
1067     m_keystoreLocation = keystoreLocation;
1068 }
1069 
1070 QString AndroidConfig::toolchainHost(const BaseQtVersion *qtVersion) const
1071 {
1072     return toolchainHostFromNdk(ndkLocation(qtVersion));
1073 }
1074 
1075 QString AndroidConfig::toolchainHostFromNdk(const FilePath &ndkPath) const
1076 {
1077     // detect toolchain host
1078     QString toolchainHost;
1079     QStringList hostPatterns;
1080     switch (HostOsInfo::hostOs()) {
1081     case OsTypeLinux:
1082         hostPatterns << QLatin1String("linux*");
1083         break;
1084     case OsTypeWindows:
1085         hostPatterns << QLatin1String("windows*");
1086         break;
1087     case OsTypeMac:
1088         hostPatterns << QLatin1String("darwin*");
1089         break;
1090     default: /* unknown host */
1091         return toolchainHost;
1092     }
1093 
1094     QDirIterator jt(ndkPath.pathAppended("prebuilt").toString(),
1095                     hostPatterns,
1096                     QDir::Dirs);
1097     if (jt.hasNext()) {
1098         jt.next();
1099         toolchainHost = jt.fileName();
1100     }
1101 
1102     return toolchainHost;
1103 }
1104 
1105 unsigned AndroidConfig::partitionSize() const
1106 {
1107     return m_partitionSize;
1108 }
1109 
1110 void AndroidConfig::setPartitionSize(unsigned partitionSize)
1111 {
1112     m_partitionSize = partitionSize;
1113 }
1114 
1115 bool AndroidConfig::automaticKitCreation() const
1116 {
1117     return m_automaticKitCreation;
1118 }
1119 
1120 void AndroidConfig::setAutomaticKitCreation(bool b)
1121 {
1122     m_automaticKitCreation = b;
1123 }
1124 
1125 FilePath AndroidConfig::defaultSdkPath()
1126 {
1127     QString sdkFromEnvVar = QString::fromLocal8Bit(getenv("ANDROID_SDK_ROOT"));
1128     if (!sdkFromEnvVar.isEmpty())
1129         return Utils::FilePath::fromString(sdkFromEnvVar);
1130 
1131     // Set default path of SDK as used by Android Studio
1132     if (Utils::HostOsInfo::isMacHost()) {
1133         return Utils::FilePath::fromString(
1134             QStandardPaths::writableLocation(QStandardPaths::AppLocalDataLocation)
1135             + "/../Android/sdk");
1136     }
1137 
1138     if (Utils::HostOsInfo::isWindowsHost()) {
1139         return Utils::FilePath::fromString(
1140             QStandardPaths::writableLocation(QStandardPaths::GenericConfigLocation) + "/Android/Sdk");
1141     }
1142 
1143     return Utils::FilePath::fromString(
1144         QStandardPaths::writableLocation(QStandardPaths::HomeLocation) + "/Android/Sdk");
1145 }
1146 
1147 ///////////////////////////////////
1148 // AndroidConfigurations
1149 ///////////////////////////////////
1150 void AndroidConfigurations::setConfig(const AndroidConfig &devConfigs)
1151 {
1152     emit m_instance->aboutToUpdate();
1153     m_instance->m_config = devConfigs;
1154 
1155     m_instance->save();
1156     m_instance->updateAndroidDevice();
1157     m_instance->registerNewToolChains();
1158     m_instance->updateAutomaticKitList();
1159     m_instance->removeOldToolChains();
1160     emit m_instance->updated();
1161 }
1162 
1163 AndroidDeviceInfo AndroidConfigurations::showDeviceDialog(Project *project,
1164                                                           int apiLevel, const QStringList &abis)
1165 {
1166     QString serialNumber;
1167     for (const QString &abi : abis) {
1168         serialNumber = defaultDevice(project, abi);
1169         if (!serialNumber.isEmpty())
1170             break;
1171     }
1172     AndroidDeviceDialog dialog(apiLevel, abis, serialNumber, Core::ICore::dialogParent());
1173     AndroidDeviceInfo info = dialog.device();
1174     if (dialog.saveDeviceSelection() && info.isValid()) {
1175         const QString serialNumber = info.type == AndroidDeviceInfo::Hardware ?
1176                     info.serialNumber : info.avdname;
1177         if (!serialNumber.isEmpty())
1178             AndroidConfigurations::setDefaultDevice(project, AndroidManager::devicePreferredAbi(info.cpuAbi, abis), serialNumber);
1179     }
1180     return info;
1181 }
1182 
1183 void AndroidConfigurations::clearDefaultDevices(Project *project)
1184 {
1185     if (m_instance->m_defaultDeviceForAbi.contains(project))
1186         m_instance->m_defaultDeviceForAbi.remove(project);
1187 }
1188 
1189 void AndroidConfigurations::setDefaultDevice(Project *project, const QString &abi, const QString &serialNumber)
1190 {
1191     m_instance->m_defaultDeviceForAbi[project][abi] = serialNumber;
1192 }
1193 
1194 QString AndroidConfigurations::defaultDevice(Project *project, const QString &abi)
1195 {
1196     if (!m_instance->m_defaultDeviceForAbi.contains(project))
1197         return QString();
1198     const QMap<QString, QString> &map = m_instance->m_defaultDeviceForAbi.value(project);
1199     if (!map.contains(abi))
1200         return QString();
1201     return map.value(abi);
1202 }
1203 
1204 static bool matchToolChain(const ToolChain *atc, const ToolChain *btc)
1205 {
1206     if (atc == btc)
1207         return true;
1208 
1209     if (!atc || !btc)
1210         return false;
1211 
1212     if (atc->typeId() != Constants::ANDROID_TOOLCHAIN_TYPEID || btc->typeId() != Constants::ANDROID_TOOLCHAIN_TYPEID)
1213         return false;
1214 
1215     auto aatc = static_cast<const AndroidToolChain *>(atc);
1216     auto abtc = static_cast<const AndroidToolChain *>(btc);
1217     return aatc->targetAbi() == abtc->targetAbi();
1218 }
1219 
1220 void AndroidConfigurations::registerNewToolChains()
1221 {
1222     const QList<ToolChain *> existingAndroidToolChains
1223             = ToolChainManager::toolChains(Utils::equal(&ToolChain::typeId,
1224                                                         Utils::Id(Constants::ANDROID_TOOLCHAIN_TYPEID)));
1225     QList<ToolChain *> newToolchains = AndroidToolChainFactory::autodetectToolChains(
1226         existingAndroidToolChains);
1227 
1228     foreach (ToolChain *tc, newToolchains)
1229         ToolChainManager::registerToolChain(tc);
1230 
1231     registerCustomToolChainsAndDebuggers();
1232 }
1233 
1234 void AndroidConfigurations::registerCustomToolChainsAndDebuggers()
1235 {
1236     const QList<ToolChain *> existingAndroidToolChains = ToolChainManager::toolChains(
1237         Utils::equal(&ToolChain::typeId, Utils::Id(Constants::ANDROID_TOOLCHAIN_TYPEID)));
1238     QList<FilePath> customNdks = Utils::transform(currentConfig().getCustomNdkList(),
1239                                                   FilePath::fromString);
1240     QList<ToolChain *> customToolchains
1241         = AndroidToolChainFactory::autodetectToolChainsFromNdks(existingAndroidToolChains,
1242                                                                 customNdks,
1243                                                                 true);
1244     for (ToolChain *tc : customToolchains) {
1245         ToolChainManager::registerToolChain(tc);
1246 
1247         const FilePath ndk = static_cast<AndroidToolChain *>(tc)->ndkLocation();
1248         const FilePath command = AndroidConfigurations::currentConfig()
1249                                      .gdbPathFromNdk(tc->targetAbi(), ndk);
1250 
1251         const Debugger::DebuggerItem *existing = Debugger::DebuggerItemManager::findByCommand(
1252             command);
1253         QString abiStr
1254             = static_cast<AndroidToolChain *>(tc)->platformLinkerFlags().at(1).split('-').first();
1255         Abi abi = Abi::abiFromTargetTriplet(abiStr);
1256         if (existing && existing->abis().contains(abi))
1257             continue;
1258 
1259         Debugger::DebuggerItem debugger;
1260         debugger.setCommand(command);
1261         debugger.setEngineType(Debugger::GdbEngineType);
1262         debugger.setUnexpandedDisplayName(
1263             AndroidConfigurations::tr("Custom Android Debugger (%1, NDK %2)")
1264                 .arg(abiStr,
1265                      AndroidConfigurations::currentConfig().ndkVersion(ndk).toString()));
1266         debugger.setAutoDetected(true);
1267         debugger.setAbi(abi);
1268         debugger.reinitializeFromFile();
1269 
1270         Debugger::DebuggerItemManager::registerDebugger(debugger);
1271     }
1272 }
1273 
1274 void AndroidConfigurations::removeOldToolChains()
1275 {
1276     foreach (ToolChain *tc, ToolChainManager::toolChains(Utils::equal(&ToolChain::typeId, Utils::Id(Constants::ANDROID_TOOLCHAIN_TYPEID)))) {
1277         if (!tc->isValid())
1278             ToolChainManager::deregisterToolChain(tc);
1279     }
1280 }
1281 
1282 void AndroidConfigurations::removeUnusedDebuggers()
1283 {
1284     QList<FilePath> uniqueNdks;
1285     const QList<QtSupport::BaseQtVersion *> qtVersions
1286         = QtSupport::QtVersionManager::versions([](const QtSupport::BaseQtVersion *v) {
1287               return v->type() == Constants::ANDROIDQT;
1288           });
1289 
1290     for (const QtSupport::BaseQtVersion *qt : qtVersions) {
1291         FilePath ndkLocation = currentConfig().ndkLocation(qt);
1292         if (!uniqueNdks.contains(ndkLocation))
1293             uniqueNdks.append(ndkLocation);
1294     }
1295 
1296     uniqueNdks.append(Utils::transform(currentConfig().getCustomNdkList(), FilePath::fromString));
1297 
1298     const QList<Debugger::DebuggerItem> allDebuggers = Debugger::DebuggerItemManager::debuggers();
1299     for (const Debugger::DebuggerItem &debugger : allDebuggers) {
1300         if (!debugger.displayName().contains("Android"))
1301             continue;
1302 
1303         bool isChildOfNdk = false;
1304         for (const FilePath &path : uniqueNdks) {
1305             if (debugger.command().isChildOf(path)) {
1306                 isChildOfNdk = true;
1307                 break;
1308             }
1309         }
1310 
1311         if (!isChildOfNdk && debugger.isAutoDetected())
1312             Debugger::DebuggerItemManager::deregisterDebugger(debugger.id());
1313     }
1314 }
1315 
1316 static bool containsAllAbis(const QStringList &abis)
1317 {
1318     QStringList supportedAbis{
1319         ProjectExplorer::Constants::ANDROID_ABI_ARMEABI_V7A,
1320         ProjectExplorer::Constants::ANDROID_ABI_ARM64_V8A,
1321         ProjectExplorer::Constants::ANDROID_ABI_X86,
1322         ProjectExplorer::Constants::ANDROID_ABI_X86_64,
1323     };
1324     for (const QString &abi : abis)
1325         if (supportedAbis.contains(abi))
1326             supportedAbis.removeOne(abi);
1327 
1328     return supportedAbis.isEmpty();
1329 }
1330 
1331 static QVariant findOrRegisterDebugger(ToolChain *tc,
1332                                        const QStringList &abisList,
1333                                        const BaseQtVersion *qtVersion)
1334 {
1335     const FilePath command = AndroidConfigurations::currentConfig().gdbPath(tc->targetAbi(),
1336                                                                             qtVersion);
1337     // check if the debugger is already registered, but ignoring the display name
1338     const Debugger::DebuggerItem *existing = Debugger::DebuggerItemManager::findByCommand(command);
1339 
1340     QList<Abi> abis = Utils::transform(abisList, Abi::abiFromTargetTriplet);
1341 
1342     auto containsAbis = [abis](const Abis &secondAbis) {
1343         for (const Abi &abi : secondAbis) {
1344             if (!abis.contains(abi))
1345                 return false;
1346         }
1347         return true;
1348     };
1349 
1350     if (existing && existing->engineType() == Debugger::GdbEngineType && existing->isAutoDetected()
1351         && containsAbis(existing->abis())) {
1352         // update debugger info with new
1353         return existing->id();
1354     }
1355 
1356     // debugger not found, register a new one
1357     Debugger::DebuggerItem debugger;
1358     debugger.setCommand(command);
1359     debugger.setEngineType(Debugger::GdbEngineType);
1360     debugger.setUnexpandedDisplayName(
1361         AndroidConfigurations::tr("Android Debugger (%1, NDK %2)")
1362             .arg(containsAllAbis(abisList) ? "Multi-Abi" : abisList.join(","))
1363             .arg(AndroidConfigurations::currentConfig().ndkVersion(qtVersion).toString()));
1364     debugger.setAutoDetected(true);
1365     debugger.setAbis(abis.toVector());
1366     debugger.reinitializeFromFile();
1367     return Debugger::DebuggerItemManager::registerDebugger(debugger);
1368 }
1369 
1370 void AndroidConfigurations::updateAutomaticKitList()
1371 {
1372     for (Kit *k : KitManager::kits()) {
1373         if (DeviceTypeKitAspect::deviceTypeId(k) == Constants::ANDROID_DEVICE_TYPE) {
1374             if (k->value(Constants::ANDROID_KIT_NDK).isNull() || k->value(Constants::ANDROID_KIT_SDK).isNull()) {
1375                 if (BaseQtVersion *qt = QtKitAspect::qtVersion(k)) {
1376                     k->setValueSilently(Constants::ANDROID_KIT_NDK, currentConfig().ndkLocation(qt).toString());
1377                     k->setValue(Constants::ANDROID_KIT_SDK, currentConfig().sdkLocation().toString());
1378                 }
1379             }
1380         }
1381     }
1382 
1383     const QList<Kit *> existingKits = Utils::filtered(KitManager::kits(), [](Kit *k) {
1384         Utils::Id deviceTypeId = DeviceTypeKitAspect::deviceTypeId(k);
1385         if (k->isAutoDetected() && !k->isSdkProvided()
1386                 && deviceTypeId == Utils::Id(Constants::ANDROID_DEVICE_TYPE)) {
1387             if (!QtSupport::QtKitAspect::qtVersion(k))
1388                 KitManager::deregisterKit(k); // Remove autoDetected kits without Qt.
1389             else
1390                 return true;
1391         }
1392         return false;
1393     });
1394 
1395     removeUnusedDebuggers();
1396 
1397     QHash<Abi, QList<const QtSupport::BaseQtVersion *> > qtVersionsForArch;
1398     const QList<QtSupport::BaseQtVersion *> qtVersions
1399             = QtSupport::QtVersionManager::versions([](const QtSupport::BaseQtVersion *v) {
1400         return v->type() == Constants::ANDROIDQT;
1401     });
1402     for (const QtSupport::BaseQtVersion *qtVersion : qtVersions) {
1403         const Abis qtAbis = qtVersion->qtAbis();
1404         if (qtAbis.empty())
1405             continue;
1406         qtVersionsForArch[qtAbis.first()].append(qtVersion);
1407     }
1408 
1409     DeviceManager *dm = DeviceManager::instance();
1410     IDevice::ConstPtr device = dm->find(Utils::Id(Constants::ANDROID_DEVICE_ID));
1411     if (device.isNull()) {
1412         // no device, means no sdk path
1413         for (Kit *k : existingKits)
1414             KitManager::deregisterKit(k);
1415         return;
1416     }
1417 
1418     // register new kits
1419     const QList<ToolChain *> toolchains = ToolChainManager::toolChains([](const ToolChain *tc) {
1420         return tc->isAutoDetected()
1421             && tc->isValid()
1422             && tc->typeId() == Constants::ANDROID_TOOLCHAIN_TYPEID;
1423     });
1424     for (ToolChain *tc : toolchains) {
1425         if (tc->language() != Utils::Id(ProjectExplorer::Constants::CXX_LANGUAGE_ID))
1426             continue;
1427 
1428         for (const QtSupport::BaseQtVersion *qt : qtVersionsForArch.value(tc->targetAbi())) {
1429             FilePath tcNdk = static_cast<const AndroidToolChain *>(tc)->ndkLocation();
1430             if (tcNdk != currentConfig().ndkLocation(qt))
1431                 continue;
1432 
1433             const QList<ToolChain *> allLanguages
1434                 = Utils::filtered(toolchains, [tc, tcNdk](ToolChain *otherTc) {
1435                       FilePath otherNdk = static_cast<const AndroidToolChain *>(otherTc)->ndkLocation();
1436                       return tc->targetAbi() == otherTc->targetAbi() && tcNdk == otherNdk;
1437                   });
1438 
1439             QHash<Utils::Id, ToolChain *> toolChainForLanguage;
1440             for (ToolChain *tc : allLanguages)
1441                 toolChainForLanguage[tc->language()] = tc;
1442 
1443             Kit *existingKit = Utils::findOrDefault(existingKits, [&](const Kit *b) {
1444                 if (qt != QtSupport::QtKitAspect::qtVersion(b))
1445                     return false;
1446                 return matchToolChain(toolChainForLanguage[ProjectExplorer::Constants::CXX_LANGUAGE_ID],
1447                                       ToolChainKitAspect::cxxToolChain(b))
1448                         && matchToolChain(toolChainForLanguage[ProjectExplorer::Constants::C_LANGUAGE_ID],
1449                                           ToolChainKitAspect::cToolChain(b));
1450             });
1451 
1452             const auto initializeKit = [allLanguages, device, tc, qt](Kit *k) {
1453                 k->setAutoDetected(true);
1454                 k->setAutoDetectionSource("AndroidConfiguration");
1455                 DeviceTypeKitAspect::setDeviceTypeId(k, Utils::Id(Constants::ANDROID_DEVICE_TYPE));
1456                 for (ToolChain *tc : allLanguages)
1457                     ToolChainKitAspect::setToolChain(k, tc);
1458                 QtSupport::QtKitAspect::setQtVersion(k, qt);
1459                 DeviceKitAspect::setDevice(k, device);
1460                 QStringList abis = static_cast<const AndroidQtVersion *>(qt)->androidAbis();
1461                 Debugger::DebuggerKitAspect::setDebugger(k, findOrRegisterDebugger(tc, abis, QtKitAspect::qtVersion(k)));
1462                 k->makeSticky();
1463 
1464                 QString versionStr = QLatin1String("Qt %{Qt:Version}");
1465                 if (!qt->isAutodetected())
1466                     versionStr = QString("%1").arg(qt->displayName());
1467                 k->setUnexpandedDisplayName(tr("Android %1 Clang %2")
1468                                                 .arg(versionStr)
1469                                                 .arg(containsAllAbis(abis) ? "Multi-Abi" : abis.join(",")));
1470                 k->setValueSilently(Constants::ANDROID_KIT_NDK, currentConfig().ndkLocation(qt).toString());
1471                 k->setValueSilently(Constants::ANDROID_KIT_SDK, currentConfig().sdkLocation().toString());
1472             };
1473 
1474             if (existingKit)
1475                 initializeKit(existingKit); // Update the existing kit with new data.
1476             else
1477                 KitManager::registerKit(initializeKit);
1478         }
1479     }
1480 }
1481 
1482 bool AndroidConfigurations::force32bitEmulator()
1483 {
1484     return m_instance->m_force32bit;
1485 }
1486 
1487 QProcessEnvironment AndroidConfigurations::toolsEnvironment(const AndroidConfig &config)
1488 {
1489     Environment env = Environment::systemEnvironment();
1490     Utils::FilePath jdkLocation = config.openJDKLocation();
1491     if (!jdkLocation.isEmpty()) {
1492         env.set("JAVA_HOME", jdkLocation.toUserOutput());
1493         env.prependOrSetPath(jdkLocation.pathAppended("bin").toUserOutput());
1494     }
1495     return env.toProcessEnvironment();
1496 }
1497 
1498 /**
1499  * Workaround for '????????????' serial numbers
1500  * @return ("-d") for buggy devices, ("-s", <serial no>) for normal
1501  */
1502 QStringList AndroidDeviceInfo::adbSelector(const QString &serialNumber)
1503 {
1504     if (serialNumber.startsWith(QLatin1String("????")))
1505         return QStringList("-d");
1506     return QStringList({"-s",  serialNumber});
1507 }
1508 
1509 bool AndroidDeviceInfo::operator<(const AndroidDeviceInfo &other) const
1510 {
1511     if (serialNumber.contains("????") != other.serialNumber.contains("????"))
1512         return !serialNumber.contains("????");
1513     if (type != other.type)
1514         return type == AndroidDeviceInfo::Hardware;
1515     if (sdk != other.sdk)
1516         return sdk < other.sdk;
1517     if (avdname != other.avdname)
1518         return avdname < other.avdname;
1519 
1520     return serialNumber < other.serialNumber;
1521 }
1522 
1523 const AndroidConfig &AndroidConfigurations::currentConfig()
1524 {
1525     return m_instance->m_config; // ensure that m_instance is initialized
1526 }
1527 
1528 AndroidSdkManager *AndroidConfigurations::sdkManager()
1529 {
1530     return m_instance->m_sdkManager.get();
1531 }
1532 
1533 AndroidConfigurations *AndroidConfigurations::instance()
1534 {
1535     return m_instance;
1536 }
1537 
1538 void AndroidConfigurations::save()
1539 {
1540     QSettings *settings = Core::ICore::settings();
1541     settings->beginGroup(SettingsGroup);
1542     m_config.save(*settings);
1543     settings->endGroup();
1544 }
1545 
1546 AndroidConfigurations::AndroidConfigurations()
1547     : m_sdkManager(new AndroidSdkManager(m_config))
1548 {
1549     load();
1550 
1551     connect(SessionManager::instance(), &SessionManager::projectRemoved,
1552             this, &AndroidConfigurations::clearDefaultDevices);
1553     connect(DeviceManager::instance(), &DeviceManager::devicesLoaded,
1554             this, &AndroidConfigurations::updateAndroidDevice);
1555 
1556     m_force32bit = is32BitUserSpace();
1557 
1558     m_instance = this;
1559 }
1560 
1561 AndroidConfigurations::~AndroidConfigurations() = default;
1562 
1563 static Utils::FilePath androidStudioPath()
1564 {
1565     if (Utils::HostOsInfo::isWindowsHost()) {
1566         const QLatin1String registryKey("HKEY_LOCAL_MACHINE\\SOFTWARE\\Android Studio");
1567         const QLatin1String valueName("Path");
1568     #if defined(Q_OS_WIN)
1569         const QSettings settings64(registryKey, QSettings::Registry64Format);
1570         const QSettings settings32(registryKey, QSettings::Registry32Format);
1571         return Utils::FilePath::fromUserInput(
1572                     settings64.value(valueName, settings32.value(valueName).toString()).toString());
1573     #endif
1574     }
1575     return {}; // TODO non-Windows
1576 }
1577 
1578 FilePath AndroidConfig::getJdkPath()
1579 {
1580     FilePath jdkHome;
1581 
1582     if (HostOsInfo::isWindowsHost()) {
1583         QStringList allVersions;
1584         std::unique_ptr<QSettings> settings(
1585             new QSettings(jdk8SettingsPath, QSettings::NativeFormat));
1586         allVersions = settings->childGroups();
1587 #ifdef Q_OS_WIN
1588         if (allVersions.isEmpty()) {
1589             settings.reset(new QSettings(jdk8SettingsPath, QSettings::Registry64Format));
1590             allVersions = settings->childGroups();
1591         }
1592 #endif // Q_OS_WIN
1593 
1594         // If no jdk 1.8 can be found, look for jdk versions above 1.8
1595         // Android section would warn if sdkmanager cannot run with newer jdk versions
1596         if (allVersions.isEmpty()) {
1597             settings.reset(new QSettings(jdkLatestSettingsPath, QSettings::NativeFormat));
1598             allVersions = settings->childGroups();
1599 #ifdef Q_OS_WIN
1600             if (allVersions.isEmpty()) {
1601                 settings.reset(new QSettings(jdkLatestSettingsPath, QSettings::Registry64Format));
1602                 allVersions = settings->childGroups();
1603             }
1604 #endif // Q_OS_WIN
1605         }
1606 
1607         for (const QString &version : allVersions) {
1608             settings->beginGroup(version);
1609             jdkHome = FilePath::fromUserInput(settings->value("JavaHome").toString());
1610             settings->endGroup();
1611             if (version.startsWith("1.8")) {
1612                 if (!jdkHome.exists())
1613                     continue;
1614                 break;
1615             }
1616         }
1617 
1618         // Nothing found yet? Let's try finding Android Studio's jdk
1619         if (jdkHome.isEmpty()) {
1620             const Utils::FilePath androidStudioSdkPath = androidStudioPath();
1621             if (!androidStudioSdkPath.isEmpty()) {
1622                 const Utils::FilePath androidStudioSdkJrePath = androidStudioSdkPath / "jre";
1623                 if (androidStudioSdkJrePath.exists())
1624                     jdkHome = androidStudioSdkJrePath;
1625             }
1626         }
1627     } else {
1628         QStringList args;
1629         if (HostOsInfo::isMacHost())
1630             args << "-c"
1631                  << "/usr/libexec/java_home";
1632         else
1633             args << "-c"
1634                  << "readlink -f $(which java)";
1635 
1636         QProcess findJdkPathProc;
1637         findJdkPathProc.start("sh", args);
1638         findJdkPathProc.waitForFinished();
1639         QByteArray jdkPath = findJdkPathProc.readAllStandardOutput().trimmed();
1640 
1641         if (HostOsInfo::isMacHost()) {
1642             jdkHome = FilePath::fromUtf8(jdkPath);
1643         } else {
1644             jdkPath.replace("bin/java", ""); // For OpenJDK 11
1645             jdkPath.replace("jre", "");
1646             jdkPath.replace("//", "/");
1647             jdkHome = FilePath::fromUtf8(jdkPath);
1648         }
1649     }
1650 
1651     return jdkHome;
1652 }
1653 
1654 void AndroidConfigurations::load()
1655 {
1656     QSettings *settings = Core::ICore::settings();
1657     settings->beginGroup(SettingsGroup);
1658     m_config.load(*settings);
1659     settings->endGroup();
1660 }
1661 
1662 void AndroidConfigurations::updateAndroidDevice()
1663 {
1664     DeviceManager * const devMgr = DeviceManager::instance();
1665     if (m_instance->m_config.adbToolPath().exists())
1666         devMgr->addDevice(AndroidDevice::create());
1667     else if (devMgr->find(Constants::ANDROID_DEVICE_ID))
1668         devMgr->removeDevice(Utils::Id(Constants::ANDROID_DEVICE_ID));
1669 }
1670 
1671 AndroidConfigurations *AndroidConfigurations::m_instance = nullptr;
1672 
1673 QDebug &operator<<(QDebug &stream, const AndroidDeviceInfo &device)
1674 {
1675     stream << "Type:"<< (device.type == AndroidDeviceInfo::Emulator ? "Emulator" : "Device")
1676            << ", ABI:" << device.cpuAbi << ", Serial:" << device.serialNumber
1677            << ", Name:" << device.avdname << ", API:" << device.sdk
1678            << ", Authorised:" << !device.unauthorized;
1679     return stream;
1680 }
1681 
1682 } // namespace Android
