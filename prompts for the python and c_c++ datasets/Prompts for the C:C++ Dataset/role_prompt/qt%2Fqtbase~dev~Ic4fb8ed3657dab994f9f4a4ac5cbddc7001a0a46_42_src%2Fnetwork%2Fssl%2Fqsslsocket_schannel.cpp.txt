I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2018 The Qt Company Ltd.
4 ** Contact: https://www.qt.io/licensing/
5 **
6 ** This file is part of the QtNetwork module of the Qt Toolkit.
7 **
8 ** $QT_BEGIN_LICENSE:LGPL$
9 ** Commercial License Usage
10 ** Licensees holding valid commercial Qt licenses may use this file in
11 ** accordance with the commercial license agreement provided with the
12 ** Software or, alternatively, in accordance with the terms contained in
13 ** a written agreement between you and The Qt Company. For licensing terms
14 ** and conditions see https://www.qt.io/terms-conditions. For further
15 ** information use the contact form at https://www.qt.io/contact-us.
16 **
17 ** GNU Lesser General Public License Usage
18 ** Alternatively, this file may be used under the terms of the GNU Lesser
19 ** General Public License version 3 as published by the Free Software
20 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
21 ** packaging of this file. Please review the following information to
22 ** ensure the GNU Lesser General Public License version 3 requirements
23 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
24 **
25 ** GNU General Public License Usage
26 ** Alternatively, this file may be used under the terms of the GNU
27 ** General Public License version 2.0 or (at your option) the GNU General
28 ** Public license version 3 or any later version approved by the KDE Free
29 ** Qt Foundation. The licenses are as published by the Free Software
30 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
31 ** included in the packaging of this file. Please review the following
32 ** information to ensure the GNU General Public License requirements will
33 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
34 ** https://www.gnu.org/licenses/gpl-3.0.html.
35 **
36 ** $QT_END_LICENSE$
37 **
38 ****************************************************************************/
39 
40 // #define QSSLSOCKET_DEBUG
41 
42 #include "qssl_p.h"
43 #include "qsslsocket.h"
44 #include "qsslsocket_schannel_p.h"
45 #include "qsslcertificate.h"
46 #include "qsslcertificateextension.h"
47 #include "qsslcertificate_p.h"
48 #include "qsslcipher_p.h"
49 
50 #include <QtCore/qscopeguard.h>
51 #include <QtCore/qoperatingsystemversion.h>
52 #include <QtCore/qregularexpression.h>
53 #include <QtCore/qdatastream.h>
54 #include <QtCore/qmutex.h>
55 
56 #define SECURITY_WIN32
57 #include <security.h>
58 #include <schnlsp.h>
59 
60 // Not defined in MinGW
61 #ifndef SECBUFFER_ALERT
62 #define SECBUFFER_ALERT 17
63 #endif
64 #ifndef SECPKG_ATTR_APPLICATION_PROTOCOL
65 #define SECPKG_ATTR_APPLICATION_PROTOCOL 35
66 #endif
67 
68 // Another missing MinGW define
69 #ifndef SEC_E_APPLICATION_PROTOCOL_MISMATCH
70 #define SEC_E_APPLICATION_PROTOCOL_MISMATCH _HRESULT_TYPEDEF_(0x80090367L)
71 #endif
72 
73 // Also not defined in MinGW.......
74 #ifndef SP_PROT_TLS1_SERVER
75 #define SP_PROT_TLS1_SERVER 0x00000040
76 #endif
77 #ifndef SP_PROT_TLS1_CLIENT
78 #define SP_PROT_TLS1_CLIENT 0x00000080
79 #endif
80 #ifndef SP_PROT_TLS1_0_SERVER
81 #define SP_PROT_TLS1_0_SERVER SP_PROT_TLS1_SERVER
82 #endif
83 #ifndef SP_PROT_TLS1_0_CLIENT
84 #define SP_PROT_TLS1_0_CLIENT SP_PROT_TLS1_CLIENT
85 #endif
86 #ifndef SP_PROT_TLS1_0
87 #define SP_PROT_TLS1_0 (SP_PROT_TLS1_0_CLIENT | SP_PROT_TLS1_0_SERVER)
88 #endif
89 #ifndef SP_PROT_TLS1_1_SERVER
90 #define SP_PROT_TLS1_1_SERVER 0x00000100
91 #endif
92 #ifndef SP_PROT_TLS1_1_CLIENT
93 #define SP_PROT_TLS1_1_CLIENT 0x00000200
94 #endif
95 #ifndef SP_PROT_TLS1_1
96 #define SP_PROT_TLS1_1 (SP_PROT_TLS1_1_CLIENT | SP_PROT_TLS1_1_SERVER)
97 #endif
98 #ifndef SP_PROT_TLS1_2_SERVER
99 #define SP_PROT_TLS1_2_SERVER 0x00000400
100 #endif
101 #ifndef SP_PROT_TLS1_2_CLIENT
102 #define SP_PROT_TLS1_2_CLIENT 0x00000800
103 #endif
104 #ifndef SP_PROT_TLS1_2
105 #define SP_PROT_TLS1_2 (SP_PROT_TLS1_2_CLIENT | SP_PROT_TLS1_2_SERVER)
106 #endif
107 #ifndef SP_PROT_TLS1_3_SERVER
108 #define SP_PROT_TLS1_3_SERVER 0x00001000
109 #endif
110 #ifndef SP_PROT_TLS1_3_CLIENT
111 #define SP_PROT_TLS1_3_CLIENT 0x00002000
112 #endif
113 #ifndef SP_PROT_TLS1_3
114 #define SP_PROT_TLS1_3 (SP_PROT_TLS1_3_CLIENT | SP_PROT_TLS1_3_SERVER)
115 #endif
116 
117 #define CONST_REINTERPRET_CAST(target_type, value) \
118     const_cast<target_type>(reinterpret_cast<const target_type>(value))
119 
120 /*
121     @future!:
122 
123     - Transmitting intermediate certificates
124         - Look for a way to avoid putting intermediate certificates in the certificate store
125         - No documentation on how to send the chain
126         - A stackoverflow question on this from 3 years ago implies schannel only sends intermediate
127             certificates if it's "in the system or user certificate store".
128                 - https://stackoverflow.com/q/30156584/2493610
129     - PSK support
130         - Was added in Windows 10 (it seems), documentation at time of writing is sparse/non-existent.
131             - Specifically about how to supply credentials when they're requested.
132             - Or how to recognize that they're requested in the first place.
133         - Skip certificate verification.
134         - Check if "PSK-only" is still required to do PSK _at all_ (all-around bad solution).
135         - Check if SEC_I_INCOMPLETE_CREDENTIALS is still returned for both "missing certificate" and
136             "missing PSK" when calling InitializeSecurityContext in "performHandshake".
137 
138     Medium priority:
139     - Setting cipher-suites (or ALG_ID)
140         - People have survived without it in WinRT
141     - peerCertificateChain() is different in Schannel in that it includes the entire chain, not just
142         the certificates that the peer sent. This means the root certificate is found in this chain.
143         Which I would argue makes sense for a list whose purpose is displaying the chain.
144         But this should be up for discussion. Relevant (support-reported) bug: QTBUG-20119
145     - ALPN:
146         For HTTP2. Note: Windows 8.1 and up ONLY.
147 
148     Low priority:
149     - Possibly make RAII wrappers for SecBuffer (which I commonly create QScopeGuards for)
150     - Perform the '@future' optimization in "transmit()"
151 
152 */
153 
154 QT_BEGIN_NAMESPACE
155 
156 namespace {
157 SecBuffer createSecBuffer(void *ptr, unsigned long length, unsigned long bufferType)
158 {
159     return SecBuffer{ length, bufferType, ptr };
160 }
161 
162 SecBuffer createSecBuffer(QByteArray &buffer, unsigned long bufferType)
163 {
164     return createSecBuffer(buffer.data(), static_cast<unsigned long>(buffer.length()), bufferType);
165 }
166 
167 QString schannelError(qint32 status)
168 {
169     switch (status) {
170     case SEC_E_INSUFFICIENT_MEMORY:
171         return QSslSocket::tr("Insufficient memory");
172     case SEC_E_INTERNAL_ERROR:
173         return QSslSocket::tr("Internal error");
174     case SEC_E_INVALID_HANDLE:
175         return QSslSocket::tr("An internal handle was invalid");
176     case SEC_E_INVALID_TOKEN:
177         return QSslSocket::tr("An internal token was invalid");
178     case SEC_E_LOGON_DENIED:
179         // According to the link below we get this error when Schannel receives TLS1_ALERT_ACCESS_DENIED
180         // https://docs.microsoft.com/en-us/windows/desktop/secauthn/schannel-error-codes-for-tls-and-ssl-alerts
181         return QSslSocket::tr("Access denied");
182     case SEC_E_NO_AUTHENTICATING_AUTHORITY:
183         return QSslSocket::tr("No authority could be contacted for authorization");
184     case SEC_E_NO_CREDENTIALS:
185         return QSslSocket::tr("No credentials");
186     case SEC_E_TARGET_UNKNOWN:
187         return QSslSocket::tr("The target is unknown or unreachable");
188     case SEC_E_UNSUPPORTED_FUNCTION:
189         return QSslSocket::tr("An unsupported function was requested");
190     case SEC_E_WRONG_PRINCIPAL:
191         // SNI error
192         return QSslSocket::tr("The hostname provided does not match the one received from the peer");
193     case SEC_E_APPLICATION_PROTOCOL_MISMATCH:
194         return QSslSocket::tr("No common protocol exists between the client and the server");
195     case SEC_E_ILLEGAL_MESSAGE:
196         return QSslSocket::tr("Unexpected or badly-formatted message received");
197     case SEC_E_ENCRYPT_FAILURE:
198         return QSslSocket::tr("The data could not be encrypted");
199     case SEC_E_ALGORITHM_MISMATCH:
200         return QSslSocket::tr("No cipher suites in common");
201     case SEC_E_UNKNOWN_CREDENTIALS:
202         // This can mean "invalid argument" in some cases...
203         return QSslSocket::tr("The credentials were not recognized / Invalid argument");
204     default:
205         return QSslSocket::tr("Unknown error occurred: %1").arg(status);
206     }
207 }
208 
209 DWORD fromQtSslProtocol(QSsl::SslProtocol protocol)
210 {
211     DWORD protocols = SP_PROT_NONE;
212     switch (protocol) {
213     case QSsl::UnknownProtocol:
214         return SP_PROT_NONE;
215     case QSsl::DtlsV1_0:
216     case QSsl::DtlsV1_2:
217     case QSsl::DtlsV1_0OrLater:
218     case QSsl::DtlsV1_2OrLater:
219         return SP_PROT_NONE; // Not supported at the moment (@future)
220     case QSsl::AnyProtocol:
221         protocols = SP_PROT_TLS1_0 | SP_PROT_TLS1_1 | SP_PROT_TLS1_2;
222         // @future Add TLS 1.3 when supported by Windows!
223         break;
224     case QSsl::SslV2:
225     case QSsl::SslV3:
226         return SP_PROT_NONE; // Not supported
227     case QSsl::TlsV1SslV3:
228         protocols = SP_PROT_TLS1_0;
229         break;
230     case QSsl::TlsV1_0:
231         protocols = SP_PROT_TLS1_0;
232         break;
233     case QSsl::TlsV1_1:
234         protocols = SP_PROT_TLS1_1;
235         break;
236     case QSsl::TlsV1_2:
237         protocols = SP_PROT_TLS1_2;
238         break;
239     case QSsl::TlsV1_3:
240         if ((false)) // @future[0/1] Replace with version check once it's supported in Windows
241             protocols = SP_PROT_TLS1_3;
242         else
243             protocols = SP_PROT_NONE;
244         break;
245     case QSsl::SecureProtocols: // TLS v1.0 and later is currently considered secure
246     case QSsl::TlsV1_0OrLater:
247         // For the "OrLater" protocols we fall through from one to the next, adding all of them
248         // in ascending order
249         protocols = SP_PROT_TLS1_0;
250         Q_FALLTHROUGH();
251     case QSsl::TlsV1_1OrLater:
252         protocols |= SP_PROT_TLS1_1;
253         Q_FALLTHROUGH();
254     case QSsl::TlsV1_2OrLater:
255         protocols |= SP_PROT_TLS1_2;
256         Q_FALLTHROUGH();
257     case QSsl::TlsV1_3OrLater:
258         if ((false)) // @future[1/1] Also replace this with a version check
259             protocols |= SP_PROT_TLS1_3;
260         else if (protocol == QSsl::TlsV1_3OrLater)
261             protocols = SP_PROT_NONE; // if TlsV1_3OrLater was specifically chosen we should fail
262         break;
263     }
264     return protocols;
265 }
266 
267 /*!
268     \internal
269     Used when converting the established session's \a protocol back to
270     Qt's own SslProtocol type.
271 
272     Only one protocol should be passed in at a time.
273 */
274 QSsl::SslProtocol toQtSslProtocol(DWORD protocol)
275 {
276 #define MAP_PROTOCOL(sp_protocol, q_protocol) \
277     if (protocol & sp_protocol) {             \
278         Q_ASSERT(!(protocol & ~sp_protocol)); \
279         return q_protocol;                    \
280     }
281 
282     MAP_PROTOCOL(SP_PROT_TLS1_0, QSsl::TlsV1_0)
283     MAP_PROTOCOL(SP_PROT_TLS1_1, QSsl::TlsV1_1)
284     MAP_PROTOCOL(SP_PROT_TLS1_2, QSsl::TlsV1_2)
285     MAP_PROTOCOL(SP_PROT_TLS1_3, QSsl::TlsV1_3)
286 #undef MAP_PROTOCOL
287     Q_UNREACHABLE();
288     return QSsl::UnknownProtocol;
289 }
290 
291 /*!
292     \internal
293     Used by verifyCertContext to check if a client cert is used by a server or vice versa.
294 */
295 bool netscapeWrongCertType(const QList<QSslCertificateExtension> &extensions, bool isClient)
296 {
297     const auto netscapeIt = std::find_if(
298             extensions.cbegin(), extensions.cend(),
299             [](const QSslCertificateExtension &extension) {
300                 const auto netscapeCertType = QStringLiteral("2.16.840.1.113730.1.1");
301                 return extension.oid() == netscapeCertType;
302             });
303     if (netscapeIt != extensions.cend()) {
304         const QByteArray netscapeCertTypeByte = netscapeIt->value().toByteArray();
305         int netscapeCertType = 0;
306         QDataStream dataStream(netscapeCertTypeByte);
307         dataStream >> netscapeCertType;
308         if (dataStream.status() != QDataStream::Status::Ok)
309             return true;
310         const int expectedPeerCertType = isClient ? NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE
311                                                   : NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE;
312         if ((netscapeCertType & expectedPeerCertType) == 0)
313             return true;
314     }
315     return false;
316 }
317 
318 /*!
319     \internal
320     Used by verifyCertContext to check the basicConstraints certificate
321     extension to see if the certificate is a certificate authority.
322     Returns false if the certificate does not have the basicConstraints
323     extension or if it is not a certificate authority.
324 */
325 bool isCertificateAuthority(const QList<QSslCertificateExtension> &extensions)
326 {
327     auto it = std::find_if(extensions.cbegin(), extensions.cend(),
328                            [](const QSslCertificateExtension &extension) {
329                                return extension.name() == QLatin1String("basicConstraints");
330                            });
331     if (it != extensions.cend()) {
332         QVariantMap basicConstraints = it->value().toMap();
333         return basicConstraints.value(QLatin1String("ca"), false).toBool();
334     }
335     return false;
336 }
337 
338 /*!
339     \internal
340     Returns true if the attributes we requested from the context/handshake have
341     been given.
342 */
343 bool matchesContextRequirements(DWORD attributes, DWORD requirements,
344                                 QSslSocket::PeerVerifyMode verifyMode,
345                                 bool isClient)
346 {
347 #ifdef QSSLSOCKET_DEBUG
348 #define DEBUG_WARN(message) qCWarning(lcSsl, message)
349 #else
350 #define DEBUG_WARN(message)
351 #endif
352 
353 #define CHECK_ATTRIBUTE(attributeName)                                                                 \
354     do {                                                                                               \
355         const DWORD req##attributeName = isClient ? ISC_REQ_##attributeName : ASC_REQ_##attributeName; \
356         const DWORD ret##attributeName = isClient ? ISC_RET_##attributeName : ASC_RET_##attributeName; \
357         if (!(requirements & req##attributeName) != !(attributes & ret##attributeName)) {              \
358             DEBUG_WARN("Missing attribute \"" #attributeName "\"");                                    \
359             return false;                                                                              \
360         }                                                                                              \
361     } while (false)
362 
363     CHECK_ATTRIBUTE(CONFIDENTIALITY);
364     CHECK_ATTRIBUTE(REPLAY_DETECT);
365     CHECK_ATTRIBUTE(SEQUENCE_DETECT);
366     CHECK_ATTRIBUTE(STREAM);
367     if (verifyMode == QSslSocket::PeerVerifyMode::VerifyPeer)
368         CHECK_ATTRIBUTE(MUTUAL_AUTH);
369 
370     // This one is manual because there is no server / ASC_ version
371     if (isClient) {
372         const auto reqManualCredValidation = ISC_REQ_MANUAL_CRED_VALIDATION;
373         const auto retManualCredValidation = ISC_RET_MANUAL_CRED_VALIDATION;
374         if (!(requirements & reqManualCredValidation) != !(attributes & retManualCredValidation)) {
375             DEBUG_WARN("Missing attribute \"MANUAL_CRED_VALIDATION\"");
376             return false;
377         }
378     }
379 
380     return true;
381 #undef CHECK_ATTRIBUTE
382 #undef DEBUG_WARN
383 }
384 } // anonymous namespace
385 
386 bool QSslSocketPrivate::s_loadRootCertsOnDemand = true;
387 bool QSslSocketPrivate::s_loadedCiphersAndCerts = false;
388 
389 void QSslSocketPrivate::ensureInitialized()
390 {
391     static QMutex initMutex;
392 
393     if (s_loadedCiphersAndCerts)
394         return;
395     const QMutexLocker locker(&initMutex);
396     if (s_loadedCiphersAndCerts)
397         return;
398     s_loadedCiphersAndCerts = true;
399 
400     setDefaultCaCertificates(systemCaCertificates());
401     s_loadRootCertsOnDemand = true; // setDefaultCaCertificates sets it to false, re-enable it.
402 
403     resetDefaultCiphers();
404 }
405 
406 void QSslSocketPrivate::resetDefaultCiphers()
407 {
408     setDefaultSupportedCiphers(QSslSocketBackendPrivate::defaultCiphers());
409     setDefaultCiphers(QSslSocketBackendPrivate::defaultCiphers());
410 }
411 
412 void QSslSocketPrivate::resetDefaultEllipticCurves()
413 {
414     Q_UNIMPLEMENTED();
415 }
416 
417 bool QSslSocketPrivate::supportsSsl()
418 {
419     return true;
420 }
421 
422 QList<QSslCertificate> QSslSocketPrivate::systemCaCertificates()
423 {
424     // Copied from qsslsocket_openssl.cpp's systemCaCertificates function.
425     QList<QSslCertificate> systemCerts;
426     HCERTSTORE hSystemStore = CertOpenSystemStore(0, L"ROOT");
427     if (hSystemStore) {
428         PCCERT_CONTEXT pc = nullptr;
429         while ((pc = CertFindCertificateInStore(hSystemStore, X509_ASN_ENCODING, 0, CERT_FIND_ANY,
430                                                 nullptr, pc))) {
431             systemCerts.append(QSslCertificatePrivate::QSslCertificate_from_CERT_CONTEXT(pc));
432         }
433         CertCloseStore(hSystemStore, 0);
434     }
435     return systemCerts;
436 }
437 
438 long QSslSocketPrivate::sslLibraryVersionNumber()
439 {
440     const auto os = QOperatingSystemVersion::current();
441     return (os.majorVersion() << 24) | ((os.minorVersion() & 0xFF) << 16) | (os.microVersion() & 0xFFFF);
442 }
443 
444 QString QSslSocketPrivate::sslLibraryVersionString()
445 {
446     const auto os = QOperatingSystemVersion::current();
447     return QString::fromLatin1("Secure Channel, %1 %2.%3.%4")
448             .arg(os.name(),
449                  QString::number(os.majorVersion()),
450                  QString::number(os.minorVersion()),
451                  QString::number(os.microVersion()));
452 }
453 
454 long QSslSocketPrivate::sslLibraryBuildVersionNumber()
455 {
456     // There is no separate build version
457     return sslLibraryVersionNumber();
458 }
459 
460 QString QSslSocketPrivate::sslLibraryBuildVersionString()
461 {
462     const auto os = QOperatingSystemVersion::current();
463     return QString::fromLatin1("%1.%2.%3")
464             .arg(QString::number(os.majorVersion()),
465                  QString::number(os.minorVersion()),
466                  QString::number(os.microVersion()));
467 }
468 
469 QSslSocketBackendPrivate::QSslSocketBackendPrivate()
470 {
471     SecInvalidateHandle(&credentialHandle);
472     SecInvalidateHandle(&contextHandle);
473     ensureInitialized();
474 }
475 
476 QSslSocketBackendPrivate::~QSslSocketBackendPrivate()
477 {
478     closeCertificateStores();
479     deallocateContext();
480     freeCredentialsHandle();
481 }
482 
483 bool QSslSocketBackendPrivate::sendToken(void *token, unsigned long tokenLength, bool emitError)
484 {
485     qint64 written = plainSocket->write(static_cast<const char *>(token), tokenLength);
486     if (written < 0 || written != qint64(tokenLength)) {
487         // Failed to write/buffer everything
488         if (emitError)
489             setErrorAndEmit(plainSocket->error(), plainSocket->errorString());
490         return false;
491     }
492     return true;
493 }
494 
495 QString QSslSocketBackendPrivate::targetName() const
496 {
497     // Used for SNI extension
498     return verificationPeerName.isEmpty() ? q_func()->peerName() : verificationPeerName;
499 }
500 
501 ULONG QSslSocketBackendPrivate::getContextRequirements()
502 {
503     const bool isClient = mode == QSslSocket::SslClientMode;
504     ULONG req = 0;
505 
506     req |= ISC_REQ_ALLOCATE_MEMORY; // allocate memory for buffers automatically
507     req |= ISC_REQ_CONFIDENTIALITY; // encrypt messages
508     req |= ISC_REQ_REPLAY_DETECT; // detect replayed messages
509     req |= ISC_REQ_SEQUENCE_DETECT; // detect out of sequence messages
510     req |= ISC_REQ_STREAM; // Support a stream-oriented connection
511 
512     if (isClient) {
513         req |= ISC_REQ_MANUAL_CRED_VALIDATION; // Manually validate certificate
514     } else {
515         switch (configuration.peerVerifyMode) {
516         case QSslSocket::PeerVerifyMode::VerifyNone:
517         // There doesn't seem to be a way to ask for an optional client cert :-(
518         case QSslSocket::PeerVerifyMode::AutoVerifyPeer:
519         case QSslSocket::PeerVerifyMode::QueryPeer:
520             break;
521         case QSslSocket::PeerVerifyMode::VerifyPeer:
522             req |= ASC_REQ_MUTUAL_AUTH;
523             break;
524         }
525     }
526 
527     return req;
528 }
529 
530 bool QSslSocketBackendPrivate::acquireCredentialsHandle()
531 {
532     const bool isClient = mode == QSslSocket::SslClientMode;
533     const DWORD protocols = fromQtSslProtocol(configuration.protocol);
534     if (protocols == SP_PROT_NONE) {
535         setErrorAndEmit(QAbstractSocket::SslInvalidUserDataError,
536                         QSslSocket::tr("Invalid protocol chosen"));
537         return false;
538     }
539 
540     const CERT_CHAIN_CONTEXT *chainContext = nullptr;
541     const CERT_CONTEXT *localCert = nullptr;
542     auto freeCertChain = qScopeGuard([&chainContext]() {
543         if (chainContext)
544             CertFreeCertificateChain(chainContext);
545     });
546 
547     DWORD certsCount = 0;
548     // Set up our certificate stores before trying to use one...
549     initializeCertificateStores();
550 
551     // Check if user has specified a certificate chain but it could not be loaded.
552     // This happens if there was something wrong with the certificate chain or there was no private
553     // key.
554     if (!configuration.localCertificateChain.isEmpty() && !localCertificateStore)
555         return true; // 'true' because "tst_QSslSocket::setEmptyKey" expects us to not disconnect
556 
557     if (localCertificateStore != nullptr) {
558         CERT_CHAIN_FIND_BY_ISSUER_PARA findParam;
559         ZeroMemory(&findParam, sizeof(findParam));
560         findParam.cbSize = sizeof(findParam);
561         findParam.pszUsageIdentifier = isClient ? szOID_PKIX_KP_CLIENT_AUTH : szOID_PKIX_KP_SERVER_AUTH;
562 
563         // There should only be one chain in our store, so.. we grab that one.
564         chainContext = CertFindChainInStore(localCertificateStore,
565                                             X509_ASN_ENCODING,
566                                             0,
567                                             CERT_CHAIN_FIND_BY_ISSUER,
568                                             &findParam,
569                                             nullptr);
570         if (!chainContext) {
571             setErrorAndEmit(QAbstractSocket::SocketError::SslInvalidUserDataError,
572                             QSslSocket::tr("The certificate provided can not be used for a %1.")
573                                     .arg(isClient ? QSslSocket::tr("client")
574                                                   : QSslSocket::tr("server")));
575             return false;
576         }
577         localCert = chainContext->rgpChain[0]->rgpElement[0]->pCertContext;
578         certsCount = 1;
579 
580         if (chainContext->rgpChain[0]->cElement > 1) {
581             // @future: this works, but leaves the certificate in the system store
582             HCERTSTORE myStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0,
583                                                CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_OPEN_EXISTING_FLAG,
584                                                L"My");
585             if (myStore) {
586                 for (DWORD i = 1; i < chainContext->rgpChain[0]->cElement; i++) {
587                     CertAddCertificateContextToStore(myStore,
588                                                      chainContext->rgpChain[0]->rgpElement[i]->pCertContext,
589                                                      CERT_STORE_ADD_NEWER, nullptr);
590                 }
591                 CertCloseStore(myStore, 0);
592             }
593         }
594     }
595 
596     SCHANNEL_CRED cred{
597         SCHANNEL_CRED_VERSION, // dwVersion
598         certsCount, // cCreds
599         &localCert, // paCred (certificate(s) containing a private key for authentication)
600         nullptr, // hRootStore
601 
602         0, // cMappers (reserved)
603         nullptr, // aphMappers (reserved)
604 
605         0, // cSupportedAlgs
606         nullptr, // palgSupportedAlgs (nullptr = system default) @future: QSslCipher-related
607 
608         protocols, // grbitEnabledProtocols
609         0, // dwMinimumCipherStrength (0 = system default)
610         0, // dwMaximumCipherStrength (0 = system default)
611         0, // dwSessionLifespan (0 = schannel default, 10 hours)
612         SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT
613                 | SCH_CRED_NO_DEFAULT_CREDS, // dwFlags
614         0 // dwCredFormat (must be 0)
615     };
616 
617     TimeStamp expiration{};
618     auto status = AcquireCredentialsHandle(nullptr, // pszPrincipal (unused)
619                                            const_cast<wchar_t *>(UNISP_NAME), // pszPackage
620                                            isClient ? SECPKG_CRED_OUTBOUND : SECPKG_CRED_INBOUND, // fCredentialUse
621                                            nullptr, // pvLogonID (unused)
622                                            &cred, // pAuthData
623                                            nullptr, // pGetKeyFn (unused)
624                                            nullptr, // pvGetKeyArgument (unused)
625                                            &credentialHandle, // phCredential
626                                            &expiration // ptsExpir
627     );
628 
629     if (status != SEC_E_OK) {
630         setErrorAndEmit(QAbstractSocket::SslInternalError, schannelError(status));
631         return false;
632     }
633     return true;
634 }
635 
636 void QSslSocketBackendPrivate::deallocateContext()
637 {
638     if (SecIsValidHandle(&contextHandle)) {
639         DeleteSecurityContext(&contextHandle);
640         SecInvalidateHandle(&contextHandle);
641     }
642 }
643 
644 void QSslSocketBackendPrivate::freeCredentialsHandle()
645 {
646     if (SecIsValidHandle(&credentialHandle)) {
647         FreeCredentialsHandle(&credentialHandle);
648         SecInvalidateHandle(&credentialHandle);
649     }
650 }
651 
652 void QSslSocketBackendPrivate::closeCertificateStores()
653 {
654     if (localCertificateStore) {
655         CertCloseStore(localCertificateStore, 0);
656         localCertificateStore = nullptr;
657     }
658     if (peerCertificateStore) {
659         CertCloseStore(peerCertificateStore, 0);
660         peerCertificateStore = nullptr;
661     }
662     if (caCertificateStore) {
663         CertCloseStore(caCertificateStore, 0);
664         caCertificateStore = nullptr;
665     }
666 }
667 
668 bool QSslSocketBackendPrivate::createContext()
669 {
670     Q_ASSERT(mode == QSslSocket::SslClientMode);
671     ULONG contextReq = getContextRequirements();
672 
673     SecBuffer outBuffers[3];
674     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
675     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
676     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
677     auto freeBuffers = qScopeGuard([&outBuffers]() {
678         for (auto i = 0ull; i < ARRAYSIZE(outBuffers); i++) {
679             if (outBuffers[i].pvBuffer)
680                 FreeContextBuffer(outBuffers[i].pvBuffer);
681         }
682     });
683     SecBufferDesc outputBufferDesc{
684         SECBUFFER_VERSION,
685         ARRAYSIZE(outBuffers),
686         outBuffers
687     };
688 
689     TimeStamp expiry;
690 
691     auto status = InitializeSecurityContext(&credentialHandle, // phCredential
692                                             nullptr, // phContext
693                                             CONST_REINTERPRET_CAST(SEC_WCHAR *, targetName().utf16()), // pszTargetName
694                                             contextReq, // fContextReq
695                                             0, // Reserved1
696                                             0, // TargetDataRep (unused)
697                                             nullptr, // pInput (no input at the moment @future: alpn)
698                                             0, // Reserved2
699                                             &contextHandle, // phNewContext
700                                             &outputBufferDesc, // pOutput
701                                             &contextAttributes, // pfContextAttr
702                                             &expiry // ptsExpiry
703     );
704 
705     // This is the first call to InitializeSecurityContext, so theoretically "CONTINUE_NEEDED"
706     // should be the only non-error return-code here.
707     if (status != SEC_I_CONTINUE_NEEDED) {
708         setErrorAndEmit(QAbstractSocket::SslInternalError,
709                         QSslSocket::tr("Error creating SSL context (%1)").arg(schannelError(status)));
710         return false;
711     }
712 
713     if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
714         return false;
715     schannelState = SchannelState::PerformHandshake;
716     return true;
717 }
718 
719 bool QSslSocketBackendPrivate::acceptContext()
720 {
721     Q_ASSERT(mode == QSslSocket::SslServerMode);
722     ULONG contextReq = getContextRequirements();
723 
724     intermediateBuffer += plainSocket->readAll();
725     if (intermediateBuffer.isEmpty())
726         return true; // definitely need more data..
727 
728     SecBuffer inBuffers[2];
729     inBuffers[0] = createSecBuffer(intermediateBuffer, SECBUFFER_TOKEN);
730     inBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
731     SecBufferDesc inputBufferDesc{
732         SECBUFFER_VERSION,
733         ARRAYSIZE(inBuffers),
734         inBuffers
735     };
736 
737     SecBuffer outBuffers[3];
738     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
739     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
740     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
741     auto freeBuffers = qScopeGuard([&outBuffers]() {
742         for (auto i = 0ull; i < ARRAYSIZE(outBuffers); i++) {
743             if (outBuffers[i].pvBuffer)
744                 FreeContextBuffer(outBuffers[i].pvBuffer);
745         }
746     });
747     SecBufferDesc outputBufferDesc{
748         SECBUFFER_VERSION,
749         ARRAYSIZE(outBuffers),
750         outBuffers
751     };
752 
753     TimeStamp expiry;
754     auto status = AcceptSecurityContext(
755             &credentialHandle, // phCredential
756             nullptr, // phContext
757             &inputBufferDesc, // pInput
758             contextReq, // fContextReq
759             0, // TargetDataRep (unused)
760             &contextHandle, // phNewContext
761             &outputBufferDesc, // pOutput
762             &contextAttributes, // pfContextAttr
763             &expiry // ptsTimeStamp
764     );
765 
766     if (inBuffers[1].BufferType == SECBUFFER_EXTRA) {
767         // https://docs.microsoft.com/en-us/windows/desktop/secauthn/extra-buffers-returned-by-schannel
768         // inBuffers[1].cbBuffer indicates the amount of bytes _NOT_ processed, the rest need to
769         // be stored.
770         intermediateBuffer = intermediateBuffer.right(int(inBuffers[1].cbBuffer));
771     } else if (status != SEC_E_INCOMPLETE_MESSAGE) {
772         intermediateBuffer.clear();
773     }
774 
775     if (status != SEC_I_CONTINUE_NEEDED) {
776         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
777                         QSslSocket::tr("Error creating SSL context (%1)").arg(schannelError(status)));
778         return false;
779     }
780     if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
781         return false;
782     schannelState = SchannelState::PerformHandshake;
783     return true;
784 }
785 
786 bool QSslSocketBackendPrivate::performHandshake()
787 {
788     if (plainSocket->state() == QAbstractSocket::UnconnectedState) {
789         setErrorAndEmit(QAbstractSocket::RemoteHostClosedError,
790                         QSslSocket::tr("The TLS/SSL connection has been closed"));
791         return false;
792     }
793 #ifdef QSSLSOCKET_DEBUG
794     qCDebug(lcSsl) << "Bytes available from socket:" << plainSocket->bytesAvailable();
795     qCDebug(lcSsl) << "intermediateBuffer size:" << intermediateBuffer.size();
796 #endif
797 
798     intermediateBuffer += plainSocket->readAll();
799     if (intermediateBuffer.isEmpty())
800         return true; // no data, will fail
801 
802     SecBuffer inputBuffers[2];
803     inputBuffers[0] = createSecBuffer(intermediateBuffer, SECBUFFER_TOKEN);
804     inputBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
805     SecBufferDesc inputBufferDesc{
806         SECBUFFER_VERSION,
807         ARRAYSIZE(inputBuffers),
808         inputBuffers
809     };
810 
811     SecBuffer outBuffers[3];
812     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
813     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
814     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
815     auto freeBuffers = qScopeGuard([&outBuffers]() {
816         for (auto i = 0ull; i < ARRAYSIZE(outBuffers); i++) {
817             if (outBuffers[i].pvBuffer)
818                 FreeContextBuffer(outBuffers[i].pvBuffer);
819         }
820     });
821     SecBufferDesc outputBufferDesc{
822         SECBUFFER_VERSION,
823         ARRAYSIZE(outBuffers),
824         outBuffers
825     };
826 
827     ULONG contextReq = getContextRequirements();
828     TimeStamp expiry;
829     auto status = InitializeSecurityContext(&credentialHandle, // phCredential
830                                             &contextHandle, // phContext
831                                             CONST_REINTERPRET_CAST(SEC_WCHAR *, targetName().utf16()), // pszTargetName
832                                             contextReq, // fContextReq
833                                             0, // Reserved1
834                                             0, // TargetDataRep (unused)
835                                             &inputBufferDesc, // pInput
836                                             0, // Reserved2
837                                             nullptr, // phNewContext (we already have one)
838                                             &outputBufferDesc, // pOutput
839                                             &contextAttributes, // pfContextAttr
840                                             &expiry // ptsExpiry
841     );
842 
843     if (inputBuffers[1].BufferType == SECBUFFER_EXTRA) {
844         // https://docs.microsoft.com/en-us/windows/desktop/secauthn/extra-buffers-returned-by-schannel
845         // inputBuffers[1].cbBuffer indicates the amount of bytes _NOT_ processed, the rest need to
846         // be stored.
847         intermediateBuffer = intermediateBuffer.right(int(inputBuffers[1].cbBuffer));
848     } else {
849         // Clear the buffer if we weren't asked for more data
850         if (status != SEC_E_INCOMPLETE_MESSAGE)
851             intermediateBuffer.clear();
852     }
853     switch (status) {
854     case SEC_E_OK:
855         // Need to transmit a final token in the handshake if 'cbBuffer' is non-zero.
856         if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
857             return false;
858         schannelState = SchannelState::VerifyHandshake;
859         return true;
860     case SEC_I_CONTINUE_NEEDED:
861         if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
862             return false;
863         // Must call InitializeSecurityContext again later (done through continueHandshake)
864         return true;
865     case SEC_I_INCOMPLETE_CREDENTIALS:
866         // Schannel takes care of picking certificate to send (other than the one we can specify),
867         // so if we get here then that means we don't have a certificate the server accepts.
868         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
869                         QSslSocket::tr("Server did not accept any certificate we could present."));
870         return false;
871     case SEC_I_CONTEXT_EXPIRED:
872         // "The message sender has finished using the connection and has initiated a shutdown."
873         if (outBuffers[0].BufferType == SECBUFFER_TOKEN) {
874             if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer))
875                 return false;
876         }
877         if (!shutdown) { // we did not initiate this
878             setErrorAndEmit(QAbstractSocket::RemoteHostClosedError,
879                             QSslSocket::tr("The TLS/SSL connection has been closed"));
880         }
881         return true;
882     case SEC_E_INCOMPLETE_MESSAGE:
883         // Simply incomplete, wait for more data
884         return true;
885     case SEC_E_ALGORITHM_MISMATCH:
886         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
887                         QSslSocket::tr("Algorithm mismatch"));
888         shutdown = true; // skip sending the "Shutdown" alert
889         return false;
890     }
891 
892     // Note: We can get here if the connection is using TLS 1.2 and the server certificate uses
893     // MD5, which is not allowed in Schannel. This causes an "invalid token" error during handshake.
894     // (If you came here investigating an error: md5 is insecure, update your certificate)
895     setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
896                     QSslSocket::tr("Handshake failed: %1").arg(schannelError(status)));
897     return false;
898 }
899 
900 bool QSslSocketBackendPrivate::verifyHandshake()
901 {
902     Q_Q(QSslSocket);
903 
904     const bool isClient = mode == QSslSocket::SslClientMode;
905 #define CHECK_STATUS(status)                                                  \
906     if (status != SEC_E_OK) {                                                 \
907         setErrorAndEmit(QAbstractSocket::SslInternalError,                    \
908                         QSslSocket::tr("Failed to query the TLS context: %1") \
909                                 .arg(schannelError(status)));                 \
910         return false;                                                         \
911     }
912 
913     // Everything is set up, now make sure there's nothing wrong and query some attributes...
914     if (!matchesContextRequirements(contextAttributes, getContextRequirements(),
915                                     configuration.peerVerifyMode, isClient)) {
916         setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
917                         QSslSocket::tr("Did not get the required attributes for the connection."));
918         return false;
919     }
920 
921     // Get stream sizes (to know the max size of a message and the size of the header and trailer)
922     auto status = QueryContextAttributes(&contextHandle,
923                                          SECPKG_ATTR_STREAM_SIZES,
924                                          &streamSizes);
925     CHECK_STATUS(status);
926 
927     // Get session cipher info
928     status = QueryContextAttributes(&contextHandle,
929                                     SECPKG_ATTR_CONNECTION_INFO,
930                                     &connectionInfo);
931     CHECK_STATUS(status);
932 #undef CHECK_STATUS
933 
934     // Verify certificate
935     CERT_CONTEXT *certificateContext = nullptr;
936     auto freeCertificate = qScopeGuard([&certificateContext]() {
937         if (certificateContext)
938             CertFreeCertificateContext(certificateContext);
939     });
940     status = QueryContextAttributes(&contextHandle,
941                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
942                                     &certificateContext);
943 
944     // QueryPeer can (currently) not work in Schannel since Schannel itself doesn't have a way to
945     // ask for a certificate and then still be OK if it's not received.
946     // To work around this we don't request a certificate at all for QueryPeer.
947     // For servers AutoVerifyPeer is supposed to be treated the same as QueryPeer.
948     // This means that servers using Schannel will only request client certificate for "VerifyPeer".
949     if ((!isClient && configuration.peerVerifyMode == QSslSocket::PeerVerifyMode::VerifyPeer)
950         || (isClient && configuration.peerVerifyMode != QSslSocket::PeerVerifyMode::VerifyNone
951             && configuration.peerVerifyMode != QSslSocket::PeerVerifyMode::QueryPeer)) {
952         if (status != SEC_E_OK) {
953 #ifdef QSSLSOCKET_DEBUG
954             qCDebug(lcSsl) << "Couldn't retrieve peer certificate, status:"
955                            << schannelError(status);
956 #endif
957             const QSslError error{ QSslError::NoPeerCertificate };
958             sslErrors += error;
959             emit q->peerVerifyError(error);
960             if (q->state() != QAbstractSocket::ConnectedState)
961                 return false;
962         }
963     }
964 
965     // verifyCertContext returns false if the user disconnected while it was checking errors.
966     if (certificateContext && sslErrors.isEmpty() && !verifyCertContext(certificateContext))
967         return false;
968 
969     if (!checkSslErrors() || state != QAbstractSocket::ConnectedState) {
970 #ifdef QSSLSOCKET_DEBUG
971         qCDebug(lcSsl) << __func__ << "was unsuccessful. Paused:" << paused;
972 #endif
973         // If we're paused then checkSslErrors returned false, but it's not an error
974         return paused && state == QAbstractSocket::ConnectedState;
975     }
976 
977     schannelState = SchannelState::Done;
978     peerCertVerified = true;
979     return true;
980 }
981 
982 bool QSslSocketBackendPrivate::renegotiate()
983 {
984     SecBuffer outBuffers[3];
985     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
986     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
987     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
988     auto freeBuffers = qScopeGuard([&outBuffers]() {
989         for (auto i = 0ull; i < ARRAYSIZE(outBuffers); i++) {
990             if (outBuffers[i].pvBuffer)
991                 FreeContextBuffer(outBuffers[i].pvBuffer);
992         }
993     });
994     SecBufferDesc outputBufferDesc{
995         SECBUFFER_VERSION,
996         ARRAYSIZE(outBuffers),
997         outBuffers
998     };
999 
1000     ULONG contextReq = getContextRequirements();
1001     TimeStamp expiry;
1002     SECURITY_STATUS status;
1003     if (mode == QSslSocket::SslClientMode) {
1004         status = InitializeSecurityContext(&credentialHandle, // phCredential
1005                                            &contextHandle, // phContext
1006                                            CONST_REINTERPRET_CAST(SEC_WCHAR *, targetName().utf16()), // pszTargetName
1007                                            contextReq, // fContextReq
1008                                            0, // Reserved1
1009                                            0, // TargetDataRep (unused)
1010                                            nullptr, // pInput (nullptr for renegotiate)
1011                                            0, // Reserved2
1012                                            nullptr, // phNewContext (we already have one)
1013                                            &outputBufferDesc, // pOutput
1014                                            &contextAttributes, // pfContextAttr
1015                                            &expiry // ptsExpiry
1016         );
1017     } else {
1018         status = AcceptSecurityContext(
1019                 &credentialHandle, // phCredential
1020                 &contextHandle, // phContext
1021                 nullptr, // pInput
1022                 contextReq, // fContextReq
1023                 0, // TargetDataRep (unused)
1024                 nullptr, // phNewContext
1025                 &outputBufferDesc, // pOutput
1026                 &contextAttributes, // pfContextAttr,
1027                 &expiry // ptsTimeStamp
1028         );
1029     }
1030     if (status == SEC_I_CONTINUE_NEEDED) {
1031         schannelState = SchannelState::PerformHandshake;
1032         return sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer);
1033     }
1034     setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
1035                     QSslSocket::tr("Renegotiation was unsuccessful: %1").arg(schannelError(status)));
1036     return false;
1037 }
1038 
1039 /*!
1040     \internal
1041     reset the state in preparation for reuse of socket
1042 */
1043 void QSslSocketBackendPrivate::reset()
1044 {
1045     closeCertificateStores(); // certificate stores could've changed
1046     deallocateContext();
1047     freeCredentialsHandle(); // in case we already had one (@future: session resumption requires re-use)
1048 
1049     connectionInfo = {};
1050     streamSizes = {};
1051 
1052     contextAttributes = 0;
1053     intermediateBuffer.clear();
1054     schannelState = SchannelState::InitializeHandshake;
1055 
1056     connectionEncrypted = false;
1057     shutdown = false;
1058     peerCertVerified = false;
1059     renegotiating = false;
1060 }
1061 
1062 void QSslSocketBackendPrivate::startClientEncryption()
1063 {
1064     if (connectionEncrypted)
1065         return; // let's not mess up the connection...
1066     reset();
1067     continueHandshake();
1068 }
1069 
1070 void QSslSocketBackendPrivate::startServerEncryption()
1071 {
1072     if (connectionEncrypted)
1073         return; // let's not mess up the connection...
1074     reset();
1075     continueHandshake();
1076 }
1077 
1078 void QSslSocketBackendPrivate::transmit()
1079 {
1080     Q_Q(QSslSocket);
1081 
1082     if (schannelState != SchannelState::Done) {
1083         continueHandshake();
1084         return;
1085     }
1086 
1087     if (connectionEncrypted) { // encrypt data in writeBuffer and write it to plainSocket
1088         qint64 totalBytesWritten = 0;
1089         qint64 writeBufferSize;
1090         while ((writeBufferSize = writeBuffer.size()) > 0) {
1091             QByteArray plaintext;
1092             {
1093                 // Try to read 'cbMaximumMessage' bytes from buffer before encrypting.
1094                 int size = int(std::min(writeBufferSize, qint64(streamSizes.cbMaximumMessage)));
1095                 plaintext.resize(size);
1096                 // Use peek() here instead of read() so we don't lose data if encryption fails.
1097                 qint64 copied = writeBuffer.peek(plaintext.data(), size);
1098                 Q_ASSERT(copied == size);
1099             }
1100             QByteArray header(int(streamSizes.cbHeader), '\0');
1101             QByteArray trailer(int(streamSizes.cbTrailer), '\0');
1102 
1103             SecBuffer inputBuffers[4]{
1104                 // @future[0/1]: optimize by using one container for all fields...
1105                 createSecBuffer(header, SECBUFFER_STREAM_HEADER),
1106                 createSecBuffer(plaintext, SECBUFFER_DATA),
1107                 createSecBuffer(trailer, SECBUFFER_STREAM_TRAILER),
1108                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY)
1109             };
1110             SecBufferDesc message{
1111                 SECBUFFER_VERSION,
1112                 ARRAYSIZE(inputBuffers),
1113                 inputBuffers
1114             };
1115             auto status = EncryptMessage(&contextHandle, 0, &message, 0);
1116             if (status != SEC_E_OK) {
1117                 setErrorAndEmit(QAbstractSocket::SslInternalError,
1118                                 QSslSocket::tr("Schannel failed to encrypt data: %1")
1119                                         .arg(schannelError(status)));
1120                 return;
1121             }
1122             // Data was encrypted successfully, so we free() what we peek()ed earlier
1123             writeBuffer.free(plaintext.length());
1124 
1125             // trailer has been observed to change size, so resize them all (when needed) to be safe
1126             header = header.left(int(inputBuffers[0].cbBuffer));
1127             plaintext = plaintext.left(int(inputBuffers[1].cbBuffer));
1128             trailer = trailer.left(int(inputBuffers[2].cbBuffer));
1129             const qint64 bytesWritten = plainSocket->write(header // @future[1/1]: ...because they need to be merged
1130                                                            + plaintext
1131                                                            + trailer);
1132 #ifdef QSSLSOCKET_DEBUG
1133             qCDebug(lcSsl) << "Wrote" << bytesWritten << "of total"
1134                            << header.length() + plaintext.length() + trailer.length() << "bytes";
1135 #endif
1136             if (bytesWritten >= 0) {
1137                 totalBytesWritten += bytesWritten;
1138             } else {
1139                 setErrorAndEmit(plainSocket->error(), plainSocket->errorString());
1140                 return;
1141             }
1142         }
1143 
1144         if (totalBytesWritten > 0) {
1145             // Don't emit bytesWritten() recursively.
1146             if (!emittedBytesWritten) {
1147                 emittedBytesWritten = true;
1148                 emit q->bytesWritten(totalBytesWritten);
1149                 emittedBytesWritten = false;
1150             }
1151             emit q->channelBytesWritten(0, totalBytesWritten);
1152         }
1153     }
1154 
1155     if (connectionEncrypted) { // Decrypt data from remote
1156         int totalRead = 0;
1157         bool hadIncompleteData = false;
1158         while (!readBufferMaxSize || buffer.size() < readBufferMaxSize) {
1159             QByteArray ciphertext;
1160             if (intermediateBuffer.length()) {
1161 #ifdef QSSLSOCKET_DEBUG
1162                 qCDebug(lcSsl) << "Restoring data from intermediateBuffer:"
1163                                << intermediateBuffer.length() << "bytes";
1164 #endif
1165                 ciphertext.swap(intermediateBuffer);
1166             }
1167             int initialLength = ciphertext.length();
1168             ciphertext += plainSocket->read(16384);
1169 #ifdef QSSLSOCKET_DEBUG
1170             qCDebug(lcSsl) << "Read" << ciphertext.length() - initialLength
1171                            << "encrypted bytes from the socket";
1172 #endif
1173             if (ciphertext.length() == 0 || (hadIncompleteData && initialLength == ciphertext.length())) {
1174 #ifdef QSSLSOCKET_DEBUG
1175                 qCDebug(lcSsl) << (hadIncompleteData ? "No new data received, leaving loop!"
1176                                                      : "Nothing to decrypt, leaving loop!");
1177 #endif
1178                 if (ciphertext.length()) // We have data, it came from intermediateBuffer, swap back
1179                     intermediateBuffer.swap(ciphertext);
1180                 break;
1181             }
1182             hadIncompleteData = false;
1183 #ifdef QSSLSOCKET_DEBUG
1184             qCDebug(lcSsl) << "Total amount of bytes to decrypt:" << ciphertext.length();
1185 #endif
1186 
1187             SecBuffer dataBuffer[4]{
1188                 createSecBuffer(ciphertext, SECBUFFER_DATA),
1189                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY),
1190                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY),
1191                 createSecBuffer(nullptr, 0, SECBUFFER_EMPTY)
1192             };
1193             SecBufferDesc message{
1194                 SECBUFFER_VERSION,
1195                 ARRAYSIZE(dataBuffer),
1196                 dataBuffer
1197             };
1198             auto status = DecryptMessage(&contextHandle, &message, 0, nullptr);
1199             if (status == SEC_E_OK || status == SEC_I_RENEGOTIATE || status == SEC_I_CONTEXT_EXPIRED) {
1200                 // There can still be 0 output even if it succeeds, this is fine
1201                 if (dataBuffer[1].cbBuffer > 0) {
1202                     // It is always decrypted in-place.
1203                     // But [0] is the STREAM_HEADER, [1] is the DATA and [2] is the STREAM_TRAILER.
1204                     // The pointers in all of those still point into the 'ciphertext' byte array.
1205                     buffer.append(static_cast<char *>(dataBuffer[1].pvBuffer),
1206                                   dataBuffer[1].cbBuffer);
1207                     totalRead += dataBuffer[1].cbBuffer;
1208 #ifdef QSSLSOCKET_DEBUG
1209                     qCDebug(lcSsl) << "Decrypted" << dataBuffer[1].cbBuffer
1210                                    << "bytes. New read buffer size:" << buffer.size();
1211 #endif
1212                 }
1213                 if (dataBuffer[3].BufferType == SECBUFFER_EXTRA) {
1214                     // https://docs.microsoft.com/en-us/windows/desktop/secauthn/extra-buffers-returned-by-schannel
1215                     // dataBuffer[3].cbBuffer indicates the amount of bytes _NOT_ processed,
1216                     // the rest need to be stored.
1217 #ifdef QSSLSOCKET_DEBUG
1218                     qCDebug(lcSsl) << "We've got excess data, moving it to the intermediate buffer:"
1219                                    << dataBuffer[3].cbBuffer << "bytes";
1220 #endif
1221                     intermediateBuffer = ciphertext.right(int(dataBuffer[3].cbBuffer));
1222                 }
1223             } else if (status == SEC_E_INCOMPLETE_MESSAGE) {
1224                 // Need more data before we can decrypt.. to the buffer it goes!
1225 #ifdef QSSLSOCKET_DEBUG
1226                 qCDebug(lcSsl, "We didn't have enough data to decrypt anything, will try again!");
1227 #endif
1228                 Q_ASSERT(intermediateBuffer.isEmpty());
1229                 intermediateBuffer.swap(ciphertext);
1230                 // We try again, but if we don't get any more data then we leave
1231                 hadIncompleteData = true;
1232             } else if (status == SEC_E_INVALID_HANDLE) {
1233                 // I don't think this should happen, if it does we're done...
1234                 qCWarning(lcSsl, "The internal SSPI handle is invalid!");
1235                 Q_UNREACHABLE();
1236             } else if (status == SEC_E_INVALID_TOKEN) {
1237                 qCWarning(lcSsl, "Got SEC_E_INVALID_TOKEN!");
1238                 Q_UNREACHABLE(); // Happened once due to a bug, but shouldn't generally happen(?)
1239             } else if (status == SEC_E_MESSAGE_ALTERED) {
1240                 // The message has been altered, disconnect now.
1241                 // According to the Internet it also triggers for messages that are out of order.
1242                 // https://microsoft.public.platformsdk.security.narkive.com/4JAvlMvD/help-please-schannel-security-contexts-and-decryptmessage
1243                 shutdown = true; // skips sending the shutdown alert
1244                 disconnectFromHost();
1245                 setErrorAndEmit(QAbstractSocket::SslInternalError,
1246                                 QSslSocket::tr("The message was tampered with, damaged or out of sequence."));
1247                 break;
1248             } else if (status == SEC_E_OUT_OF_SEQUENCE) {
1249                 // @todo: I don't know if this one is actually "fatal"..
1250                 // This path might never be hit as it seems this is for connection-oriented connections,
1251                 // while SEC_E_MESSAGE_ALTERED is for stream-oriented ones (what we use).
1252                 shutdown = true; // skips sending the shutdown alert
1253                 disconnectFromHost();
1254                 setErrorAndEmit(QAbstractSocket::SslInternalError,
1255                                 QSslSocket::tr("A message was received out of sequence."));
1256                 break;
1257             } else if (status == SEC_I_CONTEXT_EXPIRED) {
1258                 // 'remote' has initiated a shutdown
1259                 disconnectFromHost();
1260                 setErrorAndEmit(QAbstractSocket::RemoteHostClosedError,
1261                                 QSslSocket::tr("The TLS/SSL connection has been closed"));
1262                 break;
1263             } else if (status == SEC_I_RENEGOTIATE) {
1264                 // 'remote' wants to renegotiate
1265 #ifdef QSSLSOCKET_DEBUG
1266                 qCDebug(lcSsl, "The peer wants to renegotiate.");
1267 #endif
1268                 schannelState = SchannelState::Renegotiate;
1269                 renegotiating = true;
1270                 // We need to call 'continueHandshake' or else there's no guarantee it ever gets called
1271                 continueHandshake();
1272                 break;
1273             }
1274         }
1275 
1276         if (totalRead) {
1277             if (readyReadEmittedPointer)
1278                 *readyReadEmittedPointer = true;
1279             emit q->readyRead();
1280             emit q->channelReadyRead(0);
1281         }
1282     }
1283 }
1284 
1285 void QSslSocketBackendPrivate::sendShutdown()
1286 {
1287     const bool isClient = mode == QSslSocket::SslClientMode;
1288     DWORD shutdownToken = SCHANNEL_SHUTDOWN;
1289     SecBuffer buffer = createSecBuffer(&shutdownToken, sizeof(SCHANNEL_SHUTDOWN), SECBUFFER_TOKEN);
1290     SecBufferDesc token{
1291         SECBUFFER_VERSION,
1292         1,
1293         &buffer
1294     };
1295     auto status = ApplyControlToken(&contextHandle, &token);
1296 
1297     if (status != SEC_E_OK) {
1298 #ifdef QSSLSOCKET_DEBUG
1299         qCDebug(lcSsl) << "Failed to apply shutdown control token:" << schannelError(status);
1300 #endif
1301         return;
1302     }
1303 
1304     SecBuffer outBuffers[3];
1305     outBuffers[0] = createSecBuffer(nullptr, 0, SECBUFFER_TOKEN);
1306     outBuffers[1] = createSecBuffer(nullptr, 0, SECBUFFER_ALERT);
1307     outBuffers[2] = createSecBuffer(nullptr, 0, SECBUFFER_EMPTY);
1308     auto freeBuffers = qScopeGuard([&outBuffers]() {
1309         for (auto i = 0ull; i < ARRAYSIZE(outBuffers); i++) {
1310             if (outBuffers[i].pvBuffer)
1311                 FreeContextBuffer(outBuffers[i].pvBuffer);
1312         }
1313     });
1314     SecBufferDesc outputBufferDesc{
1315         SECBUFFER_VERSION,
1316         ARRAYSIZE(outBuffers),
1317         outBuffers
1318     };
1319 
1320     ULONG contextReq = getContextRequirements();
1321     TimeStamp expiry;
1322     if (isClient) {
1323         status = InitializeSecurityContext(&credentialHandle, // phCredential
1324                                            &contextHandle, // phContext
1325                                            CONST_REINTERPRET_CAST(SEC_WCHAR *, targetName().utf16()), // pszTargetName
1326                                            contextReq, // fContextReq
1327                                            0, // Reserved1
1328                                            0, // TargetDataRep (unused)
1329                                            nullptr, // pInput
1330                                            0, // Reserved2
1331                                            nullptr, // phNewContext (we already have one)
1332                                            &outputBufferDesc, // pOutput
1333                                            &contextAttributes, // pfContextAttr
1334                                            &expiry // ptsExpiry
1335         );
1336     } else {
1337         status = AcceptSecurityContext(
1338                 &credentialHandle, // phCredential
1339                 &contextHandle, // phContext
1340                 nullptr, // pInput
1341                 contextReq, // fContextReq
1342                 0, // TargetDataRep (unused)
1343                 nullptr, // phNewContext
1344                 &outputBufferDesc, // pOutput
1345                 &contextAttributes, // pfContextAttr,
1346                 &expiry // ptsTimeStamp
1347         );
1348     }
1349     if (status == SEC_E_OK || status == SEC_I_CONTEXT_EXPIRED) {
1350         if (!sendToken(outBuffers[0].pvBuffer, outBuffers[0].cbBuffer, false)) {
1351             // We failed to send the shutdown message, but it's not that important since we're
1352             // shutting down anyway.
1353             return;
1354         }
1355 
1356         schannelState = SchannelState::PerformHandshake;
1357         continueHandshake();
1358     } else {
1359 #ifdef QSSLSOCKET_DEBUG
1360         qCDebug(lcSsl) << "Failed to initialize shutdown:" << schannelError(status);
1361 #endif
1362     }
1363 }
1364 
1365 void QSslSocketBackendPrivate::disconnectFromHost()
1366 {
1367     if (SecIsValidHandle(&contextHandle)) {
1368         if (!shutdown) {
1369             shutdown = true;
1370             if (plainSocket->state() != QAbstractSocket::UnconnectedState) {
1371                 if (connectionEncrypted) {
1372                     // Read as much as possible because this is likely our last chance
1373                     qint64 tempMax = readBufferMaxSize;
1374                     readBufferMaxSize = 0;
1375                     transmit();
1376                     readBufferMaxSize = tempMax;
1377                 }
1378 
1379                 sendShutdown();
1380             }
1381         }
1382     }
1383     if (plainSocket->state() != QAbstractSocket::UnconnectedState)
1384         plainSocket->disconnectFromHost();
1385 }
1386 
1387 void QSslSocketBackendPrivate::disconnected()
1388 {
1389     if (plainSocket->bytesAvailable() <= 0) {
1390         shutdown = true;
1391         connectionEncrypted = false;
1392         deallocateContext();
1393         freeCredentialsHandle();
1394     }
1395 }
1396 
1397 QSslCipher QSslSocketBackendPrivate::sessionCipher() const
1398 {
1399     if (!connectionEncrypted)
1400         return QSslCipher();
1401     return QSslCipher(QStringLiteral("Schannel"), sessionProtocol());
1402 }
1403 
1404 QSsl::SslProtocol QSslSocketBackendPrivate::sessionProtocol() const
1405 {
1406     if (!connectionEncrypted)
1407         return QSsl::SslProtocol::UnknownProtocol;
1408     return toQtSslProtocol(connectionInfo.dwProtocol);
1409 }
1410 
1411 void QSslSocketBackendPrivate::continueHandshake()
1412 {
1413     Q_Q(QSslSocket);
1414     const bool isServer = mode == QSslSocket::SslServerMode;
1415     switch (schannelState) {
1416     case SchannelState::InitializeHandshake:
1417         if (!SecIsValidHandle(&credentialHandle) && !acquireCredentialsHandle()) {
1418             disconnectFromHost();
1419             return;
1420         }
1421         if (!SecIsValidHandle(&credentialHandle)) // Needed to support tst_QSslSocket::setEmptyKey
1422             return;
1423         if (!SecIsValidHandle(&contextHandle) && !(isServer ? acceptContext() : createContext())) {
1424             disconnectFromHost();
1425             return;
1426         }
1427         if (schannelState != SchannelState::PerformHandshake)
1428             break;
1429         Q_FALLTHROUGH();
1430     case SchannelState::PerformHandshake:
1431         if (!performHandshake()) {
1432             disconnectFromHost();
1433             return;
1434         }
1435         if (schannelState != SchannelState::VerifyHandshake)
1436             break;
1437         Q_FALLTHROUGH();
1438     case SchannelState::VerifyHandshake:
1439         // if we're in shutdown or renegotiating then we might not need to verify
1440         // (since we already did)
1441         if (!peerCertVerified && !verifyHandshake()) {
1442             shutdown = true; // Skip sending shutdown alert
1443             q->abort(); // We don't want to send buffered data
1444             disconnectFromHost();
1445             return;
1446         }
1447         if (schannelState != SchannelState::Done)
1448             break;
1449         Q_FALLTHROUGH();
1450     case SchannelState::Done:
1451         // connectionEncrypted is already true if we come here from a renegotiation
1452         if (!connectionEncrypted) {
1453             connectionEncrypted = true; // all is done
1454             emit q->encrypted();
1455         }
1456         renegotiating = false;
1457         if (pendingClose) {
1458             pendingClose = false;
1459             disconnectFromHost();
1460         } else {
1461             transmit();
1462         }
1463         break;
1464     case SchannelState::Renegotiate:
1465         if (!renegotiate()) {
1466             disconnectFromHost();
1467             return;
1468         }
1469         break;
1470     }
1471 }
1472 
1473 QList<QSslCipher> QSslSocketBackendPrivate::defaultCiphers()
1474 {
1475     QList<QSslCipher> ciphers;
1476     // @temp (I hope), stolen from qsslsocket_winrt.cpp
1477     const QString protocolStrings[] = { QStringLiteral("TLSv1"), QStringLiteral("TLSv1.1"),
1478                                         QStringLiteral("TLSv1.2"), QStringLiteral("TLSv1.3") };
1479     const QSsl::SslProtocol protocols[] = { QSsl::TlsV1_0, QSsl::TlsV1_1,
1480                                             QSsl::TlsV1_2, QSsl::TlsV1_3 };
1481     const int size = ARRAYSIZE(protocols);
1482     Q_STATIC_ASSERT(size == ARRAYSIZE(protocolStrings));
1483     ciphers.reserve(size);
1484     for (int i = 0; i < size; ++i) {
1485         QSslCipher cipher;
1486         cipher.d->isNull = false;
1487         cipher.d->name = QStringLiteral("Schannel");
1488         cipher.d->protocol = protocols[i];
1489         cipher.d->protocolString = protocolStrings[i];
1490         ciphers.append(cipher);
1491     }
1492 
1493     return ciphers;
1494 }
1495 
1496 QList<QSslError> QSslSocketBackendPrivate::verify(const QList<QSslCertificate> &certificateChain,
1497                                                   const QString &hostName)
1498 {
1499     Q_UNUSED(certificateChain);
1500     Q_UNUSED(hostName);
1501 
1502     Q_UNIMPLEMENTED();
1503     return {}; // @future implement(?)
1504 }
1505 
1506 bool QSslSocketBackendPrivate::importPkcs12(QIODevice *device, QSslKey *key, QSslCertificate *cert,
1507                                             QList<QSslCertificate> *caCertificates,
1508                                             const QByteArray &passPhrase)
1509 {
1510     Q_UNUSED(device);
1511     Q_UNUSED(key);
1512     Q_UNUSED(cert);
1513     Q_UNUSED(caCertificates);
1514     Q_UNUSED(passPhrase);
1515     // @future: can load into its own certificate store (encountered problems extracting key).
1516     Q_UNIMPLEMENTED();
1517     return false;
1518 }
1519 
1520 /*
1521     Copied from qsslsocket_mac.cpp, which was copied from qsslsocket_openssl.cpp
1522 */
1523 bool QSslSocketBackendPrivate::checkSslErrors()
1524 {
1525     if (sslErrors.isEmpty())
1526         return true;
1527     Q_Q(QSslSocket);
1528 
1529     emit q->sslErrors(sslErrors);
1530 
1531     const bool doVerifyPeer = configuration.peerVerifyMode == QSslSocket::VerifyPeer
1532             || (configuration.peerVerifyMode == QSslSocket::AutoVerifyPeer
1533                 && mode == QSslSocket::SslClientMode);
1534     const bool doEmitSslError = !verifyErrorsHaveBeenIgnored();
1535     // check whether we need to emit an SSL handshake error
1536     if (doVerifyPeer && doEmitSslError) {
1537         if (q->pauseMode() & QAbstractSocket::PauseOnSslErrors) {
1538             pauseSocketNotifiers(q);
1539             paused = true;
1540         } else {
1541             setErrorAndEmit(QAbstractSocket::SslHandshakeFailedError,
1542                             sslErrors.constFirst().errorString());
1543             plainSocket->disconnectFromHost();
1544         }
1545         return false;
1546     }
1547 
1548     return true;
1549 }
1550 
1551 void QSslSocketBackendPrivate::initializeCertificateStores()
1552 {
1553     //// helper function which turns a chain into a certificate store
1554     auto createStoreFromCertificateChain = [](const QList<QSslCertificate> certChain, const QSslKey &privateKey) {
1555         const wchar_t *passphrase = L"";
1556         // Need to embed the private key in the certificate
1557         QByteArray pkcs12 = _q_makePkcs12(certChain,
1558                                           privateKey,
1559                                           QString::fromWCharArray(passphrase, 0));
1560         CRYPT_DATA_BLOB pfxBlob;
1561         pfxBlob.cbData = DWORD(pkcs12.length());
1562         pfxBlob.pbData = reinterpret_cast<unsigned char *>(pkcs12.data());
1563         return PFXImportCertStore(&pfxBlob, passphrase, 0); // returns HCERTSTORE
1564     };
1565 
1566     if (!configuration.localCertificateChain.isEmpty()) {
1567         if (configuration.privateKey.isNull()) {
1568             setErrorAndEmit(QAbstractSocket::SslInvalidUserDataError,
1569                             QSslSocket::tr("Cannot provide a certificate with no key"));
1570             return;
1571         }
1572         if (localCertificateStore == nullptr) {
1573             localCertificateStore = createStoreFromCertificateChain(configuration.localCertificateChain,
1574                                                                     configuration.privateKey);
1575             if (localCertificateStore == nullptr)
1576                 qCWarning(lcSsl, "Failed to load certificate chain!");
1577         }
1578     }
1579 
1580     if (!configuration.caCertificates.isEmpty() && !caCertificateStore) {
1581         caCertificateStore = createStoreFromCertificateChain(configuration.caCertificates,
1582                                                              {}); // No private key for the CA certs
1583     }
1584 }
1585 
1586 bool QSslSocketBackendPrivate::verifyCertContext(CERT_CONTEXT *certContext)
1587 {
1588     Q_ASSERT(certContext);
1589     Q_Q(QSslSocket);
1590 
1591     const bool isClient = mode == QSslSocket::SslClientMode;
1592 
1593     // Create a collection of stores so we can pass in multiple stores as additional locations to
1594     // search for the certificate chain
1595     HCERTSTORE tempCertCollection = CertOpenStore(CERT_STORE_PROV_COLLECTION,
1596                                                   X509_ASN_ENCODING,
1597                                                   0,
1598                                                   CERT_STORE_CREATE_NEW_FLAG,
1599                                                   nullptr);
1600 
1601     if (rootCertOnDemandLoadingAllowed()) {
1602         // @future(maybe): following the OpenSSL backend these certificates should be added into
1603         // the Ca list, not just included during verification.
1604         // That being said, it's not trivial to add the root certificates (if and only if they
1605         // came from the system root store). And I don't see this mentioned in our documentation.
1606         HCERTSTORE rootStore = CertOpenSystemStore(0, L"ROOT");
1607         if (rootStore) {
1608             CertAddStoreToCollection(tempCertCollection, rootStore, 0, 1);
1609             CertCloseStore(rootStore, 0);
1610         }
1611     }
1612     if (caCertificateStore)
1613         CertAddStoreToCollection(tempCertCollection, caCertificateStore, 0, 1);
1614     CertAddStoreToCollection(tempCertCollection, certContext->hCertStore, 0, 0);
1615 
1616     CERT_CHAIN_PARA parameters;
1617     ZeroMemory(&parameters, sizeof(parameters));
1618     parameters.cbSize = sizeof(CERT_CHAIN_PARA);
1619     parameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
1620     parameters.RequestedUsage.Usage.cUsageIdentifier = 1;
1621     LPSTR oid = LPSTR(isClient ? szOID_PKIX_KP_SERVER_AUTH
1622                                : szOID_PKIX_KP_CLIENT_AUTH);
1623     parameters.RequestedUsage.Usage.rgpszUsageIdentifier = &oid;
1624 
1625     configuration.peerCertificate.clear();
1626     configuration.peerCertificateChain.clear();
1627     const CERT_CHAIN_CONTEXT *chainContext = nullptr;
1628     auto freeCertChain = qScopeGuard([&chainContext]() {
1629         if (chainContext)
1630             CertFreeCertificateChain(chainContext);
1631     });
1632     BOOL status = CertGetCertificateChain(nullptr, // hChainEngine, default
1633                                           certContext, // pCertContext
1634                                           nullptr, // pTime, 'now'
1635                                           tempCertCollection, // hAdditionalStore, additional cert store
1636                                           &parameters, // pChainPara
1637                                           CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT, // dwFlags
1638                                           nullptr, // reserved
1639                                           &chainContext // ppChainContext
1640     );
1641     CertCloseStore(tempCertCollection, 0);
1642     if (status == FALSE || !chainContext || chainContext->cChain == 0) {
1643         QSslError error(QSslError::UnableToVerifyFirstCertificate);
1644         sslErrors += error;
1645         emit q->peerVerifyError(error);
1646         return q->state() == QAbstractSocket::ConnectedState;
1647     }
1648 
1649     // Helper-function to get a QSslCertificate given a CERT_CHAIN_ELEMENT
1650     static auto getCertificateFromChainElement = [](CERT_CHAIN_ELEMENT *element) {
1651         if (!element)
1652             return QSslCertificate();
1653 
1654         const CERT_CONTEXT *certContext = element->pCertContext;
1655         return QSslCertificatePrivate::QSslCertificate_from_CERT_CONTEXT(certContext);
1656     };
1657 
1658     // Pick a chain to use as the certificate chain, if multiple are available:
1659     // According to https://docs.microsoft.com/en-gb/windows/desktop/api/wincrypt/ns-wincrypt-_cert_chain_context
1660     // this seems to be the best way to get a trusted chain.
1661     CERT_SIMPLE_CHAIN *chain = chainContext->rgpChain[chainContext->cChain - 1];
1662 
1663     if (chain->TrustStatus.dwErrorStatus & CERT_TRUST_IS_PARTIAL_CHAIN) {
1664         auto error = QSslError(QSslError::SslError::UnableToGetIssuerCertificate,
1665                                getCertificateFromChainElement(chain->rgpElement[chain->cElement - 1]));
1666         sslErrors += error;
1667         emit q->peerVerifyError(error);
1668         if (q->state() != QAbstractSocket::ConnectedState)
1669             return false;
1670     }
1671     if (chain->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_BASIC_CONSTRAINTS) {
1672         // @Note: This is actually one of two errors:
1673         // "either the certificate cannot be used to issue other certificates, or the chain path length has been exceeded."
1674         // But here we are checking the chain's status, so we assume the "issuing" error cannot occur here.
1675         auto error = QSslError(QSslError::PathLengthExceeded);
1676         sslErrors += error;
1677         emit q->peerVerifyError(error);
1678         if (q->state() != QAbstractSocket::ConnectedState)
1679             return false;
1680     }
1681     static const DWORD leftoverCertChainErrorMask = CERT_TRUST_IS_CYCLIC | CERT_TRUST_INVALID_EXTENSION
1682             | CERT_TRUST_INVALID_POLICY_CONSTRAINTS | CERT_TRUST_INVALID_NAME_CONSTRAINTS
1683             | CERT_TRUST_CTL_IS_NOT_TIME_VALID | CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID
1684             | CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
1685     if (chain->TrustStatus.dwErrorStatus & leftoverCertChainErrorMask) {
1686         auto error = QSslError(QSslError::SslError::UnspecifiedError);
1687         sslErrors += error;
1688         emit q->peerVerifyError(error);
1689         if (q->state() != QAbstractSocket::ConnectedState)
1690             return false;
1691     }
1692 
1693     DWORD verifyDepth = chain->cElement;
1694     if (configuration.peerVerifyDepth > 0 && DWORD(configuration.peerVerifyDepth) < verifyDepth)
1695         verifyDepth = DWORD(configuration.peerVerifyDepth);
1696 
1697     for (DWORD i = 0; i < verifyDepth; i++) {
1698         CERT_CHAIN_ELEMENT *element = chain->rgpElement[i];
1699         QSslCertificate certificate = getCertificateFromChainElement(element);
1700         const QList<QSslCertificateExtension> extensions = certificate.extensions();
1701 
1702 #ifdef QSSLSOCKET_DEBUG
1703         qCDebug(lcSsl) << "issuer:" << certificate.issuerDisplayName()
1704                        << "\nsubject:" << certificate.subjectDisplayName()
1705                        << "\nQSslCertificate info:" << certificate
1706                        << "\nextended error info:" << element->pwszExtendedErrorInfo
1707                        << "\nerror status:" << element->TrustStatus.dwErrorStatus;
1708 #endif
1709 
1710         ////// @todo @note This is where *all* certificates are added, read at the top for "discussion".
1711         configuration.peerCertificateChain.append(certificate);
1712 
1713         if (certificate.isBlacklisted()) {
1714             const auto error = QSslError(QSslError::CertificateBlacklisted, certificate);
1715             sslErrors += error;
1716             emit q->peerVerifyError(error);
1717             if (q->state() != QAbstractSocket::ConnectedState)
1718                 return false;
1719         }
1720 
1721         LONG result = CertVerifyTimeValidity(nullptr /*== now */, element->pCertContext->pCertInfo);
1722         if (result != 0) {
1723             auto error = QSslError(result == -1 ? QSslError::CertificateNotYetValid
1724                                                 : QSslError::CertificateExpired,
1725                                    certificate);
1726             sslErrors += error;
1727             emit q->peerVerifyError(error);
1728             if (q->state() != QAbstractSocket::ConnectedState)
1729                 return false;
1730         }
1731 
1732         //// Errors
1733         if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_TIME_VALID) {
1734             // handled right above
1735             Q_ASSERT(!sslErrors.isEmpty());
1736         }
1737         if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_REVOKED) {
1738             auto error = QSslError(QSslError::CertificateRevoked, certificate);
1739             sslErrors += error;
1740             emit q->peerVerifyError(error);
1741             if (q->state() != QAbstractSocket::ConnectedState)
1742                 return false;
1743         }
1744         if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID) {
1745             auto error = QSslError(QSslError::CertificateSignatureFailed, certificate);
1746             sslErrors += error;
1747             emit q->peerVerifyError(error);
1748             if (q->state() != QAbstractSocket::ConnectedState)
1749                 return false;
1750         }
1751 
1752         // While netscape shouldn't be relevant now it defined an extension which is
1753         // still in use. Schannel does not check this automatically, so we do it here.
1754         // It is used to differentiate between client and server certificates.
1755         if (netscapeWrongCertType(extensions, isClient))
1756             element->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
1757 
1758         if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE) {
1759             auto error = QSslError(QSslError::InvalidPurpose, certificate);
1760             sslErrors += error;
1761             emit q->peerVerifyError(error);
1762             if (q->state() != QAbstractSocket::ConnectedState)
1763                 return false;
1764         }
1765         if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT) {
1766             // Override this error if we have the certificate inside our trusted CAs list.
1767             const bool isTrustedRoot = configuration.caCertificates.contains(certificate);
1768             if (!isTrustedRoot) {
1769                 auto error = QSslError(QSslError::CertificateUntrusted, certificate);
1770                 sslErrors += error;
1771                 emit q->peerVerifyError(error);
1772                 if (q->state() != QAbstractSocket::ConnectedState)
1773                     return false;
1774             }
1775         }
1776         static const DWORD certRevocationCheckUnavailableError = CERT_TRUST_IS_OFFLINE_REVOCATION
1777                 | CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
1778         if (element->TrustStatus.dwErrorStatus & certRevocationCheckUnavailableError) {
1779             // @future(maybe): Do something with this
1780         }
1781 
1782         // Dumping ground of errors that don't fit our specific errors
1783         static const DWORD leftoverCertErrorMask = CERT_TRUST_IS_CYCLIC
1784                 | CERT_TRUST_INVALID_EXTENSION | CERT_TRUST_INVALID_NAME_CONSTRAINTS
1785                 | CERT_TRUST_INVALID_POLICY_CONSTRAINTS
1786                 | CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT
1787                 | CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT
1788                 | CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT
1789                 | CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT
1790                 | CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;
1791         if (element->TrustStatus.dwErrorStatus & leftoverCertErrorMask) {
1792             auto error = QSslError(QSslError::UnspecifiedError, certificate);
1793             sslErrors += error;
1794             emit q->peerVerifyError(error);
1795             if (q->state() != QAbstractSocket::ConnectedState)
1796                 return false;
1797         }
1798         if (element->TrustStatus.dwErrorStatus & CERT_TRUST_INVALID_BASIC_CONSTRAINTS) {
1799             auto it = std::find_if(extensions.cbegin(), extensions.cend(),
1800                                    [](const QSslCertificateExtension &extension) {
1801                                        return extension.name() == QLatin1String("basicConstraints");
1802                                    });
1803             if (it != extensions.cend()) {
1804                 // @Note: This is actually one of two errors:
1805                 // "either the certificate cannot be used to issue other certificates,
1806                 // or the chain path length has been exceeded."
1807                 QVariantMap basicConstraints = it->value().toMap();
1808                 QSslError error;
1809                 if (i > 0 && !basicConstraints.value(QLatin1String("ca"), false).toBool())
1810                     error = QSslError(QSslError::InvalidPurpose, certificate);
1811                 else
1812                     error = QSslError(QSslError::PathLengthExceeded, certificate);
1813                 sslErrors += error;
1814                 emit q->peerVerifyError(error);
1815                 if (q->state() != QAbstractSocket::ConnectedState)
1816                     return false;
1817             }
1818         }
1819         if (element->TrustStatus.dwErrorStatus & CERT_TRUST_IS_EXPLICIT_DISTRUST) {
1820             auto error = QSslError(QSslError::CertificateBlacklisted, certificate);
1821             sslErrors += error;
1822             emit q->peerVerifyError(error);
1823             if (q->state() != QAbstractSocket::ConnectedState)
1824                 return false;
1825         }
1826 
1827         if (element->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) {
1828             // If it's self-signed *and* a CA then we can assume it's a root CA certificate
1829             // and we can ignore the "self-signed" note:
1830             // We check the basicConstraints certificate extension when possible, but this didn't
1831             // exist for version 1, so we can only guess in that case
1832             const bool isRootCertificateAuthority = isCertificateAuthority(extensions)
1833                     || certificate.version() == "1";
1834 
1835             // Root certificate tends to be signed by themselves, so ignore self-signed status.
1836             if (!isRootCertificateAuthority) {
1837                 auto error = QSslError(QSslError::SelfSignedCertificate, certificate);
1838                 sslErrors += error;
1839                 emit q->peerVerifyError(error);
1840                 if (q->state() != QAbstractSocket::ConnectedState)
1841                     return false;
1842             }
1843         }
1844     }
1845 
1846     if (!configuration.peerCertificateChain.isEmpty())
1847         configuration.peerCertificate = configuration.peerCertificateChain.first();
1848 
1849     // @Note: Somewhat copied from qsslsocket_mac.cpp
1850     const bool doVerifyPeer = configuration.peerVerifyMode == QSslSocket::VerifyPeer
1851             || (configuration.peerVerifyMode == QSslSocket::AutoVerifyPeer
1852                 && mode == QSslSocket::SslClientMode);
1853     // Check the peer certificate itself. First try the subject's common name
1854     // (CN) as a wildcard, then try all alternate subject name DNS entries the
1855     // same way.
1856     if (!configuration.peerCertificate.isNull()) {
1857         // but only if we're a client connecting to a server
1858         // if we're the server, don't check CN
1859         if (mode == QSslSocket::SslClientMode) {
1860             const QString peerName(verificationPeerName.isEmpty() ? q->peerName() : verificationPeerName);
1861             if (!isMatchingHostname(configuration.peerCertificate, peerName)) {
1862                 // No matches in common names or alternate names.
1863                 const QSslError error(QSslError::HostNameMismatch, configuration.peerCertificate);
1864                 sslErrors += error;
1865                 emit q->peerVerifyError(error);
1866                 if (q->state() != QAbstractSocket::ConnectedState)
1867                     return false;
1868             }
1869         }
1870     } else if (doVerifyPeer) {
1871         // No peer certificate presented. Report as error if the socket
1872         // expected one.
1873         const QSslError error(QSslError::NoPeerCertificate);
1874         sslErrors += error;
1875         emit q->peerVerifyError(error);
1876         if (q->state() != QAbstractSocket::ConnectedState)
1877             return false;
1878     }
1879 
1880     return true;
1881 }
1882 
1883 bool QSslSocketBackendPrivate::rootCertOnDemandLoadingAllowed()
1884 {
1885     return allowRootCertOnDemandLoading && s_loadRootCertsOnDemand;
1886 }
1887 
1888 QT_END_NAMESPACE
